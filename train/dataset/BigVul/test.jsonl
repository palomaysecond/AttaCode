{"func": "ext4_xattr_block_get(struct inode *inode, int name_index, const char *name,\n\t\t     void *buffer, size_t buffer_size)\n{\n\tstruct buffer_head *bh = NULL;\n \tstruct ext4_xattr_entry *entry;\n \tsize_t size;\n \tint error;\n\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n \n \tea_idebug(inode, \"name=%d.%s, buffer=%p, buffer_size=%ld\",\n \t\t  name_index, name, buffer, (long)buffer_size);\n\n\terror = -ENODATA;\n\tif (!EXT4_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tea_idebug(inode, \"reading block %llu\",\n\t\t  (unsigned long long)EXT4_I(inode)->i_file_acl);\n\tbh = sb_bread(inode->i_sb, EXT4_I(inode)->i_file_acl);\n\tif (!bh)\n\t\tgoto cleanup;\n\tea_bdebug(bh, \"b_count=%d, refcount=%d\",\n\t\tatomic_read(&(bh->b_count)), le32_to_cpu(BHDR(bh)->h_refcount));\n\tif (ext4_xattr_check_block(inode, bh)) {\nbad_block:\n\t\tEXT4_ERROR_INODE(inode, \"bad block %llu\",\n\t\t\t\t EXT4_I(inode)->i_file_acl);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto cleanup;\n\t}\n\text4_xattr_cache_insert(ext4_mb_cache, bh);\n\tentry = BFIRST(bh);\n\terror = ext4_xattr_find_entry(&entry, name_index, name, bh->b_size, 1);\n\tif (error == -EFSCORRUPTED)\n\t\tgoto bad_block;\n\tif (error)\n\t\tgoto cleanup;\n\tsize = le32_to_cpu(entry->e_value_size);\n\tif (buffer) {\n\t\terror = -ERANGE;\n\t\tif (size > buffer_size)\n\t\t\tgoto cleanup;\n\t\tmemcpy(buffer, bh->b_data + le16_to_cpu(entry->e_value_offs),\n\t\t       size);\n\t}\n\terror = size;\n\ncleanup:\n\tbrelse(bh);\n\treturn error;\n}\n", "target": 1, "idx": 183160}
{"func": "static int mptsas_process_scsi_io_request(MPTSASState *s,\n                                          MPIMsgSCSIIORequest *scsi_io,\n                                          hwaddr addr)\n{\n    MPTSASRequest *req;\n    MPIMsgSCSIIOReply reply;\n    SCSIDevice *sdev;\n    int status;\n\n    mptsas_fix_scsi_io_endianness(scsi_io);\n\n    trace_mptsas_process_scsi_io_request(s, scsi_io->Bus, scsi_io->TargetID,\n                                         scsi_io->LUN[1], scsi_io->DataLength);\n\n    status = mptsas_scsi_device_find(s, scsi_io->Bus, scsi_io->TargetID,\n                                     scsi_io->LUN, &sdev);\n    if (status) {\n         goto bad;\n     }\n \n    req = g_new(MPTSASRequest, 1);\n     QTAILQ_INSERT_TAIL(&s->pending, req, next);\n     req->scsi_io = *scsi_io;\n     req->dev = s;\n\n    status = mptsas_build_sgl(s, req, addr);\n    if (status) {\n        goto free_bad;\n    }\n\n    if (req->qsg.size < scsi_io->DataLength) {\n        trace_mptsas_sgl_overflow(s, scsi_io->MsgContext, scsi_io->DataLength,\n                                  req->qsg.size);\n        status = MPI_IOCSTATUS_INVALID_SGL;\n        goto free_bad;\n    }\n\n    req->sreq = scsi_req_new(sdev, scsi_io->MsgContext,\n                            scsi_io->LUN[1], scsi_io->CDB, req);\n\n    if (req->sreq->cmd.xfer > scsi_io->DataLength) {\n        goto overrun;\n    }\n    switch (scsi_io->Control & MPI_SCSIIO_CONTROL_DATADIRECTION_MASK) {\n    case MPI_SCSIIO_CONTROL_NODATATRANSFER:\n        if (req->sreq->cmd.mode != SCSI_XFER_NONE) {\n            goto overrun;\n        }\n        break;\n\n    case MPI_SCSIIO_CONTROL_WRITE:\n        if (req->sreq->cmd.mode != SCSI_XFER_TO_DEV) {\n            goto overrun;\n        }\n        break;\n\n    case MPI_SCSIIO_CONTROL_READ:\n        if (req->sreq->cmd.mode != SCSI_XFER_FROM_DEV) {\n            goto overrun;\n        }\n        break;\n    }\n\n    if (scsi_req_enqueue(req->sreq)) {\n        scsi_req_continue(req->sreq);\n    }\n    return 0;\n\noverrun:\n    trace_mptsas_scsi_overflow(s, scsi_io->MsgContext, req->sreq->cmd.xfer,\n                               scsi_io->DataLength);\n    status = MPI_IOCSTATUS_SCSI_DATA_OVERRUN;\nfree_bad:\n    mptsas_free_request(req);\nbad:\n    memset(&reply, 0, sizeof(reply));\n    reply.TargetID          = scsi_io->TargetID;\n    reply.Bus               = scsi_io->Bus;\n    reply.MsgLength         = sizeof(reply) / 4;\n    reply.Function          = scsi_io->Function;\n    reply.CDBLength         = scsi_io->CDBLength;\n    reply.SenseBufferLength = scsi_io->SenseBufferLength;\n    reply.MsgContext        = scsi_io->MsgContext;\n    reply.SCSIState         = MPI_SCSI_STATE_NO_SCSI_STATUS;\n    reply.IOCStatus         = status;\n\n    mptsas_fix_scsi_io_reply_endianness(&reply);\n    mptsas_reply(s, (MPIDefaultReply *)&reply);\n\n    return 0;\n}\n", "target": 1, "idx": 178100}
{"func": "void RenderFrameImpl::OnCopyToFindPboard() {\n  if (frame_->HasSelection()) {\n    if (!clipboard_host_) {\n      auto* platform = RenderThreadImpl::current_blink_platform_impl();\n      platform->GetConnector()->BindInterface(platform->GetBrowserServiceName(),\n                                              &clipboard_host_);\n    }\n    base::string16 selection = frame_->SelectionAsText().Utf16();\n    clipboard_host_->WriteStringToFindPboard(selection);\n  }\n}\n", "target": 0, "idx": 160650}
{"func": "PHP_FUNCTION(grapheme_strpos)\n{\n\tunsigned char *haystack, *needle;\n        int haystack_len, needle_len;\n        unsigned char *found;\n        long loffset = 0;\n       int32_t offset = 0;\n        int ret_pos;\n \n        if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ss|l\", (char **)&haystack, &haystack_len, (char **)&needle, &needle_len, &loffset) == FAILURE) {\n\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\t \"grapheme_strpos: unable to parse input param\", 0 TSRMLS_CC );\n\n\t\tRETURN_FALSE;\n\t}\n\n\tif ( OUTSIDE_STRING(loffset, haystack_len) ) {\n\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR, \"grapheme_strpos: Offset not contained in string\", 1 TSRMLS_CC );\n\n\t\tRETURN_FALSE;\n\t}\n \n        /* we checked that it will fit: */\n        offset = (int32_t) loffset;\n \n        /* the offset is 'grapheme count offset' so it still might be invalid - we'll check it later */\n \n\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR, \"grapheme_strpos: Empty delimiter\", 1 TSRMLS_CC );\n\n\t\tRETURN_FALSE;\n\t}\n", "target": 1, "idx": 178206}
{"func": "int kvm_arch_vcpu_init(struct kvm_vcpu *vcpu)\n{\n\tstruct page *page;\n\tstruct kvm *kvm;\n\tint r;\n\n\tBUG_ON(vcpu->kvm == NULL);\n\tkvm = vcpu->kvm;\n\n\tvcpu->arch.emulate_ctxt.ops = &emulate_ops;\n\tif (!irqchip_in_kernel(kvm) || kvm_vcpu_is_bsp(vcpu))\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\telse\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_UNINITIALIZED;\n\n\tpage = alloc_page(GFP_KERNEL | __GFP_ZERO);\n\tif (!page) {\n\t\tr = -ENOMEM;\n\t\tgoto fail;\n\t}\n\tvcpu->arch.pio_data = page_address(page);\n\n\tkvm_set_tsc_khz(vcpu, max_tsc_khz);\n\n\tr = kvm_mmu_create(vcpu);\n\tif (r < 0)\n\t\tgoto fail_free_pio_data;\n\n\tif (irqchip_in_kernel(kvm)) {\n\t\tr = kvm_create_lapic(vcpu);\n\t\tif (r < 0)\n\t\t\tgoto fail_mmu_destroy;\n\t} else\n\t\tstatic_key_slow_inc(&kvm_no_apic_vcpu);\n\n\tvcpu->arch.mce_banks = kzalloc(KVM_MAX_MCE_BANKS * sizeof(u64) * 4,\n\t\t\t\t       GFP_KERNEL);\n\tif (!vcpu->arch.mce_banks) {\n\t\tr = -ENOMEM;\n\t\tgoto fail_free_lapic;\n\t}\n\tvcpu->arch.mcg_cap = KVM_MAX_MCE_BANKS;\n\n\tif (!zalloc_cpumask_var(&vcpu->arch.wbinvd_dirty_mask, GFP_KERNEL))\n\t\tgoto fail_free_mce_banks;\n\n\tr = fx_init(vcpu);\n\tif (r)\n \t\tgoto fail_free_wbinvd_dirty_mask;\n \n \tvcpu->arch.ia32_tsc_adjust_msr = 0x0;\n \tkvm_async_pf_hash_reset(vcpu);\n \tkvm_pmu_init(vcpu);\n \n\treturn 0;\nfail_free_wbinvd_dirty_mask:\n\tfree_cpumask_var(vcpu->arch.wbinvd_dirty_mask);\nfail_free_mce_banks:\n\tkfree(vcpu->arch.mce_banks);\nfail_free_lapic:\n\tkvm_free_lapic(vcpu);\nfail_mmu_destroy:\n\tkvm_mmu_destroy(vcpu);\nfail_free_pio_data:\n\tfree_page((unsigned long)vcpu->arch.pio_data);\nfail:\n\treturn r;\n}\n", "target": 1, "idx": 179287}
{"func": " static void addDataToStreamTask(void* context)\n {\n     OwnPtr<BlobRegistryContext> blobRegistryContext = adoptPtr(static_cast<BlobRegistryContext*>(context));\n    blobRegistry().addDataToStream(blobRegistryContext->url, blobRegistryContext->streamData);\n }\n", "target": 1, "idx": 184255}
{"func": "v8::Handle<v8::Value> V8XMLHttpRequest::openCallback(const v8::Arguments& args)\n{\n    INC_STATS(\"DOM.XMLHttpRequest.open()\");\n \n     if (args.Length() < 2)\n        return V8Proxy::throwNotEnoughArgumentsError();\n \n     XMLHttpRequest* xmlHttpRequest = V8XMLHttpRequest::toNative(args.Holder());\n \n    String method = toWebCoreString(args[0]);\n    String urlstring = toWebCoreString(args[1]);\n    ScriptExecutionContext* context = getScriptExecutionContext();\n    if (!context)\n        return v8::Undefined();\n\n    KURL url = context->completeURL(urlstring);\n\n    ExceptionCode ec = 0;\n\n    if (args.Length() >= 3) {\n        bool async = args[2]->BooleanValue();\n\n        if (args.Length() >= 4 && !args[3]->IsUndefined()) {\n            String user = toWebCoreStringWithNullCheck(args[3]);\n            \n            if (args.Length() >= 5 && !args[4]->IsUndefined()) {\n                String passwd = toWebCoreStringWithNullCheck(args[4]);\n                xmlHttpRequest->open(method, url, async, user, passwd, ec);\n            } else\n                xmlHttpRequest->open(method, url, async, user, ec);\n        } else\n            xmlHttpRequest->open(method, url, async, ec);\n    } else\n        xmlHttpRequest->open(method, url, ec);\n\n    if (ec)\n        return throwError(ec, args.GetIsolate());\n\n    return v8::Undefined();\n}\n", "target": 1, "idx": 184827}
{"func": "int inode_init_always(struct super_block *sb, struct inode *inode)\n{\n\tstatic const struct inode_operations empty_iops;\n\tstatic const struct file_operations empty_fops;\n\tstruct address_space *const mapping = &inode->i_data;\n\n\tinode->i_sb = sb;\n\tinode->i_blkbits = sb->s_blocksize_bits;\n\tinode->i_flags = 0;\n\tatomic_set(&inode->i_count, 1);\n\tinode->i_op = &empty_iops;\n\tinode->i_fop = &empty_fops;\n\tinode->__i_nlink = 1;\n\tinode->i_opflags = 0;\n\ti_uid_write(inode, 0);\n\ti_gid_write(inode, 0);\n\tatomic_set(&inode->i_writecount, 0);\n\tinode->i_size = 0;\n\tinode->i_blocks = 0;\n\tinode->i_bytes = 0;\n\tinode->i_generation = 0;\n#ifdef CONFIG_QUOTA\n\tmemset(&inode->i_dquot, 0, sizeof(inode->i_dquot));\n#endif\n\tinode->i_pipe = NULL;\n\tinode->i_bdev = NULL;\n\tinode->i_cdev = NULL;\n\tinode->i_rdev = 0;\n\tinode->dirtied_when = 0;\n\n\tif (security_inode_alloc(inode))\n\t\tgoto out;\n\tspin_lock_init(&inode->i_lock);\n\tlockdep_set_class(&inode->i_lock, &sb->s_type->i_lock_key);\n\n\tmutex_init(&inode->i_mutex);\n\tlockdep_set_class(&inode->i_mutex, &sb->s_type->i_mutex_key);\n\n\tatomic_set(&inode->i_dio_count, 0);\n\n\tmapping->a_ops = &empty_aops;\n\tmapping->host = inode;\n\tmapping->flags = 0;\n\tmapping_set_gfp_mask(mapping, GFP_HIGHUSER_MOVABLE);\n\tmapping->private_data = NULL;\n\tmapping->backing_dev_info = &default_backing_dev_info;\n\tmapping->writeback_index = 0;\n\n\t/*\n\t * If the block_device provides a backing_dev_info for client\n\t * inodes then use that.  Otherwise the inode share the bdev's\n\t * backing_dev_info.\n\t */\n\tif (sb->s_bdev) {\n\t\tstruct backing_dev_info *bdi;\n\n\t\tbdi = sb->s_bdev->bd_inode->i_mapping->backing_dev_info;\n\t\tmapping->backing_dev_info = bdi;\n\t}\n\tinode->i_private = NULL;\n\tinode->i_mapping = mapping;\n\tINIT_HLIST_HEAD(&inode->i_dentry);\t/* buggered by rcu freeing */\n#ifdef CONFIG_FS_POSIX_ACL\n\tinode->i_acl = inode->i_default_acl = ACL_NOT_CACHED;\n#endif\n\n#ifdef CONFIG_FSNOTIFY\n\tinode->i_fsnotify_mask = 0;\n#endif\n\n\tthis_cpu_inc(nr_inodes);\n\n\treturn 0;\nout:\n\treturn -ENOMEM;\n}\n", "target": 0, "idx": 36867}
{"func": " static int fanout_add(struct sock *sk, u16 id, u16 type_flags)\n {\n \tstruct packet_sock *po = pkt_sk(sk);\n \tstruct packet_fanout *f, *match;\n \tu8 type = type_flags & 0xff;\n\tu8 flags = type_flags >> 8;\n\tint err;\n\n\tswitch (type) {\n\tcase PACKET_FANOUT_ROLLOVER:\n\t\tif (type_flags & PACKET_FANOUT_FLAG_ROLLOVER)\n\t\t\treturn -EINVAL;\n\tcase PACKET_FANOUT_HASH:\n\tcase PACKET_FANOUT_LB:\n\tcase PACKET_FANOUT_CPU:\n\tcase PACKET_FANOUT_RND:\n\tcase PACKET_FANOUT_QM:\n\tcase PACKET_FANOUT_CBPF:\n\tcase PACKET_FANOUT_EBPF:\n\t\tbreak;\n\tdefault:\n \t\treturn -EINVAL;\n \t}\n \n \tif (!po->running)\n\t\treturn -EINVAL;\n \n \tif (po->fanout)\n\t\treturn -EALREADY;\n \n \tif (type == PACKET_FANOUT_ROLLOVER ||\n \t    (type_flags & PACKET_FANOUT_FLAG_ROLLOVER)) {\n\t\tpo->rollover = kzalloc(sizeof(*po->rollover), GFP_KERNEL);\n\t\tif (!po->rollover)\n\t\t\treturn -ENOMEM;\n\t\tatomic_long_set(&po->rollover->num, 0);\n\t\tatomic_long_set(&po->rollover->num_huge, 0);\n\t\tatomic_long_set(&po->rollover->num_failed, 0);\n \t}\n \n\tmutex_lock(&fanout_mutex);\n \tmatch = NULL;\n \tlist_for_each_entry(f, &fanout_list, list) {\n \t\tif (f->id == id &&\n\t\t    read_pnet(&f->net) == sock_net(sk)) {\n\t\t\tmatch = f;\n\t\t\tbreak;\n\t\t}\n\t}\n\terr = -EINVAL;\n\tif (match && match->flags != flags)\n\t\tgoto out;\n\tif (!match) {\n\t\terr = -ENOMEM;\n\t\tmatch = kzalloc(sizeof(*match), GFP_KERNEL);\n\t\tif (!match)\n\t\t\tgoto out;\n\t\twrite_pnet(&match->net, sock_net(sk));\n\t\tmatch->id = id;\n\t\tmatch->type = type;\n\t\tmatch->flags = flags;\n\t\tINIT_LIST_HEAD(&match->list);\n\t\tspin_lock_init(&match->lock);\n\t\tatomic_set(&match->sk_ref, 0);\n\t\tfanout_init_data(match);\n\t\tmatch->prot_hook.type = po->prot_hook.type;\n\t\tmatch->prot_hook.dev = po->prot_hook.dev;\n\t\tmatch->prot_hook.func = packet_rcv_fanout;\n\t\tmatch->prot_hook.af_packet_priv = match;\n\t\tmatch->prot_hook.id_match = match_fanout_group;\n\t\tdev_add_pack(&match->prot_hook);\n\t\tlist_add(&match->list, &fanout_list);\n\t}\n\terr = -EINVAL;\n\tif (match->type == type &&\n\t    match->prot_hook.type == po->prot_hook.type &&\n\t    match->prot_hook.dev == po->prot_hook.dev) {\n\t\terr = -ENOSPC;\n\t\tif (atomic_read(&match->sk_ref) < PACKET_FANOUT_MAX) {\n\t\t\t__dev_remove_pack(&po->prot_hook);\n\t\t\tpo->fanout = match;\n\t\t\tatomic_inc(&match->sk_ref);\n\t\t\t__fanout_link(sk, po);\n\t\t\terr = 0;\n \t\t}\n \t}\n out:\n\tmutex_unlock(&fanout_mutex);\n\tif (err) {\n\t\tkfree(po->rollover);\n \t\tpo->rollover = NULL;\n \t}\n \treturn err;\n }\n", "target": 1, "idx": 181518}
{"func": "bool TopSitesImpl::IsKnownURL(const GURL& url) {\n  return loaded_ && cache_->IsKnownURL(url);\n}\n", "target": 0, "idx": 159886}
{"func": "wb_print(netdissect_options *ndo,\n         register const void *hdr, register u_int len)\n{\n\tregister const struct pkt_hdr *ph;\n\n\tph = (const struct pkt_hdr *)hdr;\n\tif (len < sizeof(*ph) || !ND_TTEST(*ph)) {\n\t\tND_PRINT((ndo, \"%s\", tstr));\n\t\treturn;\n\t}\n\tlen -= sizeof(*ph);\n\n\tif (ph->ph_flags)\n\t\tND_PRINT((ndo, \"*\"));\n\tswitch (ph->ph_type) {\n\n\tcase PT_KILL:\n\t\tND_PRINT((ndo, \" wb-kill\"));\n\t\treturn;\n\n \tcase PT_ID:\n \t\tif (wb_id(ndo, (const struct pkt_id *)(ph + 1), len) >= 0)\n \t\t\treturn;\n \t\tbreak;\n \n \tcase PT_RREQ:\n \t\tif (wb_rreq(ndo, (const struct pkt_rreq *)(ph + 1), len) >= 0)\n \t\t\treturn;\n \t\tbreak;\n \n \tcase PT_RREP:\n \t\tif (wb_rrep(ndo, (const struct pkt_rrep *)(ph + 1), len) >= 0)\n \t\t\treturn;\n \t\tbreak;\n \n \tcase PT_DRAWOP:\n \t\tif (wb_drawop(ndo, (const struct pkt_dop *)(ph + 1), len) >= 0)\n \t\t\treturn;\n \t\tbreak;\n \n \tcase PT_PREQ:\n \t\tif (wb_preq(ndo, (const struct pkt_preq *)(ph + 1), len) >= 0)\n \t\t\treturn;\n \t\tbreak;\n \n \tcase PT_PREP:\n \t\tif (wb_prep(ndo, (const struct pkt_prep *)(ph + 1), len) >= 0)\n \t\t\treturn;\n \t\tbreak;\n \n \tdefault:\n\t\tND_PRINT((ndo, \" wb-%d!\", ph->ph_type));\n\t\treturn;\n\t}\n}\n", "target": 1, "idx": 181051}
{"func": "\t\tvoid CWebServer::Cmd_GetAuth(WebEmSession & session, const request& req, Json::Value &root)\n\t\t{\n\t\t\troot[\"status\"] = \"OK\";\n\t\t\troot[\"title\"] = \"GetAuth\";\n\t\t\tif (session.rights != -1)\n\t\t\t{\n\t\t\t\troot[\"version\"] = szAppVersion;\n\t\t\t}\n\t\t\troot[\"user\"] = session.username;\n\t\t\troot[\"rights\"] = session.rights;\n\t\t}\n", "target": 0, "idx": 90988}
{"func": "static int srpt_ch_qp_rtr(struct srpt_rdma_ch *ch, struct ib_qp *qp)\n{\n\tstruct ib_qp_attr qp_attr;\n\tint attr_mask;\n\tint ret;\n\n\tqp_attr.qp_state = IB_QPS_RTR;\n\tret = ib_cm_init_qp_attr(ch->cm_id, &qp_attr, &attr_mask);\n\tif (ret)\n\t\tgoto out;\n\n\tqp_attr.max_dest_rd_atomic = 4;\n\n\tret = ib_modify_qp(qp, &qp_attr, attr_mask);\n\nout:\n\treturn ret;\n}\n", "target": 0, "idx": 50630}
{"func": "long Track::GetFirst(const BlockEntry*& pBlockEntry) const {\n const Cluster* pCluster = m_pSegment->GetFirst();\n\n for (int i = 0;;) {\n if (pCluster == NULL) {\n      pBlockEntry = GetEOS();\n return 1;\n }\n\n if (pCluster->EOS()) {\n if (m_pSegment->DoneParsing()) {\n        pBlockEntry = GetEOS();\n return 1;\n }\n\n      pBlockEntry = 0;\n return E_BUFFER_NOT_FULL;\n }\n\n long status = pCluster->GetFirst(pBlockEntry);\n\n if (status < 0) // error\n return status;\n\n if (pBlockEntry == 0) { // empty cluster\n      pCluster = m_pSegment->GetNext(pCluster);\n continue;\n }\n\n for (;;) {\n const Block* const pBlock = pBlockEntry->GetBlock();\n      assert(pBlock);\n\n const long long tn = pBlock->GetTrackNumber();\n\n if ((tn == m_info.number) && VetEntry(pBlockEntry))\n return 0;\n\n const BlockEntry* pNextEntry;\n\n      status = pCluster->GetNext(pBlockEntry, pNextEntry);\n\n if (status < 0) // error\n return status;\n\n if (pNextEntry == 0)\n break;\n\n      pBlockEntry = pNextEntry;\n }\n\n ++i;\n\n if (i >= 100)\n break;\n\n    pCluster = m_pSegment->GetNext(pCluster);\n }\n\n\n  pBlockEntry = GetEOS(); // so we can return a non-NULL value\n return 1;\n}\n", "target": 0, "idx": 177399}
{"func": "ConflictResolver::ProcessSimpleConflict(WriteTransaction* trans,\n                                        const Id& id,\n                                        const Cryptographer* cryptographer,\n                                        StatusController* status) {\n  MutableEntry entry(trans, syncable::GET_BY_ID, id);\n  CHECK(entry.good());\n\n  if (!entry.Get(syncable::IS_UNAPPLIED_UPDATE) ||\n      !entry.Get(syncable::IS_UNSYNCED)) {\n    return NO_SYNC_PROGRESS;\n  }\n\n  if (entry.Get(syncable::IS_DEL) && entry.Get(syncable::SERVER_IS_DEL)) {\n    entry.Put(syncable::IS_UNSYNCED, false);\n    entry.Put(syncable::IS_UNAPPLIED_UPDATE, false);\n    return NO_SYNC_PROGRESS;\n  }\n\n  if (!entry.Get(syncable::SERVER_IS_DEL)) {\n    bool name_matches = entry.Get(syncable::NON_UNIQUE_NAME) ==\n                        entry.Get(syncable::SERVER_NON_UNIQUE_NAME);\n    bool parent_matches = entry.Get(syncable::PARENT_ID) ==\n                          entry.Get(syncable::SERVER_PARENT_ID);\n    bool entry_deleted = entry.Get(syncable::IS_DEL);\n\n    syncable::Id server_prev_id = entry.ComputePrevIdFromServerPosition(\n        entry.Get(syncable::SERVER_PARENT_ID));\n    bool needs_reinsertion = !parent_matches ||\n         server_prev_id != entry.Get(syncable::PREV_ID);\n    DVLOG_IF(1, needs_reinsertion) << \"Insertion needed, server prev id \"\n        << \" is \" << server_prev_id << \", local prev id is \"\n        << entry.Get(syncable::PREV_ID);\n    const sync_pb::EntitySpecifics& specifics =\n        entry.Get(syncable::SPECIFICS);\n    const sync_pb::EntitySpecifics& server_specifics =\n        entry.Get(syncable::SERVER_SPECIFICS);\n    const sync_pb::EntitySpecifics& base_server_specifics =\n        entry.Get(syncable::BASE_SERVER_SPECIFICS);\n    std::string decrypted_specifics, decrypted_server_specifics;\n    bool specifics_match = false;\n    bool server_encrypted_with_default_key = false;\n    if (specifics.has_encrypted()) {\n      DCHECK(cryptographer->CanDecryptUsingDefaultKey(specifics.encrypted()));\n      decrypted_specifics = cryptographer->DecryptToString(\n          specifics.encrypted());\n    } else {\n      decrypted_specifics = specifics.SerializeAsString();\n    }\n    if (server_specifics.has_encrypted()) {\n      server_encrypted_with_default_key =\n          cryptographer->CanDecryptUsingDefaultKey(\n              server_specifics.encrypted());\n      decrypted_server_specifics = cryptographer->DecryptToString(\n          server_specifics.encrypted());\n    } else {\n      decrypted_server_specifics = server_specifics.SerializeAsString();\n    }\n    if (decrypted_server_specifics == decrypted_specifics &&\n        server_encrypted_with_default_key == specifics.has_encrypted()) {\n      specifics_match = true;\n    }\n    bool base_server_specifics_match = false;\n    if (server_specifics.has_encrypted() &&\n        IsRealDataType(GetModelTypeFromSpecifics(base_server_specifics))) {\n      std::string decrypted_base_server_specifics;\n      if (!base_server_specifics.has_encrypted()) {\n        decrypted_base_server_specifics =\n            base_server_specifics.SerializeAsString();\n      } else {\n        decrypted_base_server_specifics = cryptographer->DecryptToString(\n            base_server_specifics.encrypted());\n      }\n      if (decrypted_server_specifics == decrypted_base_server_specifics)\n          base_server_specifics_match = true;\n    }\n\n    if (entry.GetModelType() == syncable::NIGORI) {\n      sync_pb::EntitySpecifics specifics =\n          entry.Get(syncable::SERVER_SPECIFICS);\n      sync_pb::NigoriSpecifics* server_nigori = specifics.mutable_nigori();\n      cryptographer->UpdateNigoriFromEncryptedTypes(server_nigori);\n      if (cryptographer->is_ready()) {\n        cryptographer->GetKeys(server_nigori->mutable_encrypted());\n        server_nigori->set_using_explicit_passphrase(\n             entry.Get(syncable::SPECIFICS).nigori().\n                 using_explicit_passphrase());\n       }\n      if (entry.Get(syncable::SPECIFICS).nigori().sync_tabs()) {\n        server_nigori->set_sync_tabs(true);\n      }\n       entry.Put(syncable::SPECIFICS, specifics);\n      DVLOG(1) << \"Resolving simple conflict, merging nigori nodes: \" << entry;\n      status->increment_num_server_overwrites();\n      OverwriteServerChanges(trans, &entry);\n      UMA_HISTOGRAM_ENUMERATION(\"Sync.ResolveSimpleConflict\",\n                                NIGORI_MERGE,\n                                CONFLICT_RESOLUTION_SIZE);\n    } else if (!entry_deleted && name_matches && parent_matches &&\n               specifics_match && !needs_reinsertion) {\n      DVLOG(1) << \"Resolving simple conflict, everything matches, ignoring \"\n               << \"changes for: \" << entry;\n      OverwriteServerChanges(trans, &entry);\n      IgnoreLocalChanges(&entry);\n      UMA_HISTOGRAM_ENUMERATION(\"Sync.ResolveSimpleConflict\",\n                                CHANGES_MATCH,\n                                CONFLICT_RESOLUTION_SIZE);\n    } else if (base_server_specifics_match) {\n      DVLOG(1) << \"Resolving simple conflict, ignoring server encryption \"\n               << \" changes for: \" << entry;\n      status->increment_num_server_overwrites();\n      OverwriteServerChanges(trans, &entry);\n      UMA_HISTOGRAM_ENUMERATION(\"Sync.ResolveSimpleConflict\",\n                                IGNORE_ENCRYPTION,\n                                CONFLICT_RESOLUTION_SIZE);\n    } else if (entry_deleted || !name_matches || !parent_matches) {\n      OverwriteServerChanges(trans, &entry);\n      status->increment_num_server_overwrites();\n      DVLOG(1) << \"Resolving simple conflict, overwriting server changes \"\n               << \"for: \" << entry;\n      UMA_HISTOGRAM_ENUMERATION(\"Sync.ResolveSimpleConflict\",\n                                OVERWRITE_SERVER,\n                                CONFLICT_RESOLUTION_SIZE);\n    } else {\n      DVLOG(1) << \"Resolving simple conflict, ignoring local changes for: \"\n               << entry;\n      IgnoreLocalChanges(&entry);\n      status->increment_num_local_overwrites();\n      UMA_HISTOGRAM_ENUMERATION(\"Sync.ResolveSimpleConflict\",\n                                OVERWRITE_LOCAL,\n                                CONFLICT_RESOLUTION_SIZE);\n    }\n    entry.Put(syncable::BASE_SERVER_SPECIFICS, sync_pb::EntitySpecifics());\n    return SYNC_PROGRESS;\n  } else {  // SERVER_IS_DEL is true\n    if (entry.Get(syncable::IS_DIR)) {\n      Directory::ChildHandles children;\n      trans->directory()->GetChildHandlesById(trans,\n                                              entry.Get(syncable::ID),\n                                              &children);\n      if (0 != children.size()) {\n        DVLOG(1) << \"Entry is a server deleted directory with local contents, \"\n                 << \"should be a hierarchy conflict. (race condition).\";\n        return NO_SYNC_PROGRESS;\n      }\n    }\n\n    if (!entry.Get(syncable::UNIQUE_CLIENT_TAG).empty()) {\n      DCHECK_EQ(entry.Get(syncable::SERVER_VERSION), 0) << \"For the server to \"\n          \"know to re-create, client-tagged items should revert to version 0 \"\n          \"when server-deleted.\";\n      OverwriteServerChanges(trans, &entry);\n      status->increment_num_server_overwrites();\n      DVLOG(1) << \"Resolving simple conflict, undeleting server entry: \"\n               << entry;\n      UMA_HISTOGRAM_ENUMERATION(\"Sync.ResolveSimpleConflict\",\n                                OVERWRITE_SERVER,\n                                CONFLICT_RESOLUTION_SIZE);\n      entry.Put(syncable::SERVER_VERSION, 0);\n      entry.Put(syncable::BASE_VERSION, 0);\n    } else {\n      SyncerUtil::SplitServerInformationIntoNewEntry(trans, &entry);\n\n      MutableEntry server_update(trans, syncable::GET_BY_ID, id);\n      CHECK(server_update.good());\n      CHECK(server_update.Get(syncable::META_HANDLE) !=\n            entry.Get(syncable::META_HANDLE))\n          << server_update << entry;\n      UMA_HISTOGRAM_ENUMERATION(\"Sync.ResolveSimpleConflict\",\n                                UNDELETE,\n                                CONFLICT_RESOLUTION_SIZE);\n    }\n    return SYNC_PROGRESS;\n  }\n}\n", "target": 1, "idx": 184365}
{"func": "static long futex_wait_restart(struct restart_block *restart)\n{\n\tu32 __user *uaddr = restart->futex.uaddr;\n\tktime_t t, *tp = NULL;\n\n\tif (restart->futex.flags & FLAGS_HAS_TIMEOUT) {\n\t\tt.tv64 = restart->futex.time;\n\t\ttp = &t;\n\t}\n\trestart->fn = do_no_restart_syscall;\n\n\treturn (long)futex_wait(uaddr, restart->futex.flags,\n\t\t\t\trestart->futex.val, tp, restart->futex.bitset);\n}\n", "target": 0, "idx": 38210}
{"func": "status_t MediaPlayer::setDataSource(\n const sp<IMediaHTTPService> &httpService,\n const char *url, const KeyedVector<String8, String8> *headers)\n{\n\n     ALOGV(\"setDataSource(%s)\", url);\n     status_t err = BAD_VALUE;\n     if (url != NULL) {\n        const sp<IMediaPlayerService>& service(getMediaPlayerService());\n         if (service != 0) {\n             sp<IMediaPlayer> player(service->create(this, mAudioSessionId));\n             if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||\n (NO_ERROR != player->setDataSource(httpService, url, headers))) {\n                player.clear();\n }\n            err = attachNewPlayer(player);\n }\n }\n return err;\n}\n", "target": 1, "idx": 187559}
{"func": " void ExtensionViewGuest::DidNavigateMainFrame(\n     const content::LoadCommittedDetails& details,\n     const content::FrameNavigateParams& params) {\n  if (attached() && (params.url.GetOrigin() != url_.GetOrigin())) {\n     bad_message::ReceivedBadMessage(web_contents()->GetRenderProcessHost(),\n                                     bad_message::EVG_BAD_ORIGIN);\n   }\n}\n", "target": 1, "idx": 186251}
{"func": "static ssize_t show_ibdev(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tstruct ib_ucm_device *ucm_dev;\n\n\tucm_dev = container_of(dev, struct ib_ucm_device, dev);\n\treturn sprintf(buf, \"%s\\n\", ucm_dev->ib_dev->name);\n}\n", "target": 0, "idx": 52820}
{"func": "bool SocketStream::is_secure() const {\n  return url_.SchemeIs(\"wss\");\n }\n", "target": 0, "idx": 120972}
{"func": "void MockWebRTCPeerConnectionHandler::setRemoteDescription(const WebRTCVoidRequest& request, const WebRTCSessionDescriptionDescriptor& remoteDescription)\n{\n    if (!remoteDescription.isNull() && remoteDescription.type() == \"answer\") {\n        m_remoteDescription = remoteDescription;\n        postTask(new RTCVoidRequestTask(this, request, true));\n     } else\n        postTask(new RTCVoidRequestTask(this, request, false));\n}\n", "target": 1, "idx": 183820}
{"func": "void setSerifFontFamilyWrapper(WebSettings* settings,\n                               const string16& font,\n                               UScriptCode script) {\n  settings->setSerifFontFamily(font, script);\n}\n", "target": 0, "idx": 124416}
{"func": " void GpuVideoDecodeAccelerator::OnDecode(\n    base::SharedMemoryHandle handle, int32 id, int32 size) {\n   DCHECK(video_decode_accelerator_.get());\n   video_decode_accelerator_->Decode(media::BitstreamBuffer(id, handle, size));\n }\n", "target": 1, "idx": 185105}
{"func": "xmlXPathParseNameComplex(xmlXPathParserContextPtr ctxt, int qualified) {\n    xmlChar buf[XML_MAX_NAMELEN + 5];\n    int len = 0, l;\n    int c;\n\n    /*\n     * Handler for more complex cases\n     */\n    c = CUR_CHAR(l);\n    if ((c == ' ') || (c == '>') || (c == '/') || /* accelerators */\n        (c == '[') || (c == ']') || (c == '@') || /* accelerators */\n        (c == '*') || /* accelerators */\n\t(!IS_LETTER(c) && (c != '_') &&\n         ((qualified) && (c != ':')))) {\n\treturn(NULL);\n    }\n\n    while ((c != ' ') && (c != '>') && (c != '/') && /* test bigname.xml */\n\t   ((IS_LETTER(c)) || (IS_DIGIT(c)) ||\n            (c == '.') || (c == '-') ||\n\t    (c == '_') || ((qualified) && (c == ':')) ||\n\t    (IS_COMBINING(c)) ||\n\t    (IS_EXTENDER(c)))) {\n\tCOPY_BUF(l,buf,len,c);\n\tNEXTL(l);\n\tc = CUR_CHAR(l);\n\tif (len >= XML_MAX_NAMELEN) {\n\t    /*\n\t     * Okay someone managed to make a huge name, so he's ready to pay\n\t     * for the processing speed.\n\t     */\n\t    xmlChar *buffer;\n\t    int max = len * 2;\n\n\t    buffer = (xmlChar *) xmlMallocAtomic(max * sizeof(xmlChar));\n\t    if (buffer == NULL) {\n\t\tXP_ERRORNULL(XPATH_MEMORY_ERROR);\n\t    }\n\t    memcpy(buffer, buf, len);\n\t    while ((IS_LETTER(c)) || (IS_DIGIT(c)) || /* test bigname.xml */\n\t\t   (c == '.') || (c == '-') ||\n\t\t   (c == '_') || ((qualified) && (c == ':')) ||\n\t\t   (IS_COMBINING(c)) ||\n\t\t   (IS_EXTENDER(c))) {\n\t\tif (len + 10 > max) {\n\t\t    max *= 2;\n\t\t    buffer = (xmlChar *) xmlRealloc(buffer,\n\t\t\t                            max * sizeof(xmlChar));\n\t\t    if (buffer == NULL) {\n\t\t\tXP_ERRORNULL(XPATH_MEMORY_ERROR);\n\t\t    }\n\t\t}\n\t\tCOPY_BUF(l,buffer,len,c);\n\t\tNEXTL(l);\n\t\tc = CUR_CHAR(l);\n\t    }\n\t    buffer[len] = 0;\n\t    return(buffer);\n\t}\n    }\n    if (len == 0)\n\treturn(NULL);\n    return(xmlStrndup(buf, len));\n}\n", "target": 0, "idx": 97761}
{"func": "bool Vp9Parser::ParseSuperframe() {\n  const uint8_t* stream = stream_;\n  off_t bytes_left = bytes_left_;\n  DCHECK(frames_.empty());\n  stream_ = nullptr;\n  bytes_left_ = 0;\n  if (bytes_left < 1)\n    return false;\n  uint8_t marker = *(stream + bytes_left - 1);\n  if ((marker & 0xe0) != 0xc0) {\n    frames_.push_back(FrameInfo(stream, bytes_left));\n    return true;\n  }\n  DVLOG(1) << \"Parsing a superframe\";\n  size_t num_frames = (marker & 0x7) + 1;\n  size_t mag = ((marker >> 3) & 0x3) + 1;\n  off_t index_size = 2 + mag * num_frames;\n \n  if (bytes_left < index_size)\n     return false;\n \n  const uint8_t* index_ptr = stream + bytes_left - index_size;\n  if (marker != *index_ptr)\n    return false;\n  ++index_ptr;\n  bytes_left -= index_size;\n  for (size_t i = 0; i < num_frames; ++i) {\n    uint32_t size = 0;\n    for (size_t j = 0; j < mag; ++j) {\n      size |= *index_ptr << (j * 8);\n      ++index_ptr;\n    }\n    if (base::checked_cast<off_t>(size) > bytes_left) {\n      DVLOG(1) << \"Not enough data in the buffer for frame \" << i;\n      return false;\n    }\n    frames_.push_back(FrameInfo(stream, size));\n    stream += size;\n    bytes_left -= size;\n    DVLOG(1) << \"Frame \" << i << \", size: \" << size;\n  }\n \n   return true;\n }\n", "target": 1, "idx": 183533}
{"func": "static void nfs4_open_confirm_release(void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\tstruct nfs4_state *state = NULL;\n\n\t/* If this request hasn't been cancelled, do nothing */\n\tif (data->cancelled == 0)\n\t\tgoto out_free;\n\t/* In case of error, no cleanup! */\n\tif (!data->rpc_done)\n \t\tgoto out_free;\n \tstate = nfs4_opendata_to_nfs4_state(data);\n \tif (!IS_ERR(state))\n\t\tnfs4_close_state(&data->path, state, data->o_arg.open_flags);\n out_free:\n \tnfs4_opendata_put(data);\n }\n", "target": 1, "idx": 178866}
{"func": "mrb_vm_exec(mrb_state *mrb, struct RProc *proc, mrb_code *pc)\n{\n  /* mrb_assert(mrb_proc_cfunc_p(proc)) */\n  mrb_irep *irep = proc->body.irep;\n  mrb_value *pool = irep->pool;\n  mrb_sym *syms = irep->syms;\n  mrb_code i;\n  int ai = mrb_gc_arena_save(mrb);\n  struct mrb_jmpbuf *prev_jmp = mrb->jmp;\n  struct mrb_jmpbuf c_jmp;\n\n#ifdef DIRECT_THREADED\n  static void *optable[] = {\n    &&L_OP_NOP, &&L_OP_MOVE,\n    &&L_OP_LOADL, &&L_OP_LOADI, &&L_OP_LOADSYM, &&L_OP_LOADNIL,\n    &&L_OP_LOADSELF, &&L_OP_LOADT, &&L_OP_LOADF,\n    &&L_OP_GETGLOBAL, &&L_OP_SETGLOBAL, &&L_OP_GETSPECIAL, &&L_OP_SETSPECIAL,\n    &&L_OP_GETIV, &&L_OP_SETIV, &&L_OP_GETCV, &&L_OP_SETCV,\n    &&L_OP_GETCONST, &&L_OP_SETCONST, &&L_OP_GETMCNST, &&L_OP_SETMCNST,\n    &&L_OP_GETUPVAR, &&L_OP_SETUPVAR,\n    &&L_OP_JMP, &&L_OP_JMPIF, &&L_OP_JMPNOT,\n    &&L_OP_ONERR, &&L_OP_RESCUE, &&L_OP_POPERR, &&L_OP_RAISE, &&L_OP_EPUSH, &&L_OP_EPOP,\n    &&L_OP_SEND, &&L_OP_SENDB, &&L_OP_FSEND,\n    &&L_OP_CALL, &&L_OP_SUPER, &&L_OP_ARGARY, &&L_OP_ENTER,\n    &&L_OP_KARG, &&L_OP_KDICT, &&L_OP_RETURN, &&L_OP_TAILCALL, &&L_OP_BLKPUSH,\n    &&L_OP_ADD, &&L_OP_ADDI, &&L_OP_SUB, &&L_OP_SUBI, &&L_OP_MUL, &&L_OP_DIV,\n    &&L_OP_EQ, &&L_OP_LT, &&L_OP_LE, &&L_OP_GT, &&L_OP_GE,\n    &&L_OP_ARRAY, &&L_OP_ARYCAT, &&L_OP_ARYPUSH, &&L_OP_AREF, &&L_OP_ASET, &&L_OP_APOST,\n    &&L_OP_STRING, &&L_OP_STRCAT, &&L_OP_HASH,\n    &&L_OP_LAMBDA, &&L_OP_RANGE, &&L_OP_OCLASS,\n    &&L_OP_CLASS, &&L_OP_MODULE, &&L_OP_EXEC,\n    &&L_OP_METHOD, &&L_OP_SCLASS, &&L_OP_TCLASS,\n    &&L_OP_DEBUG, &&L_OP_STOP, &&L_OP_ERR,\n  };\n#endif\n\n  mrb_bool exc_catched = FALSE;\nRETRY_TRY_BLOCK:\n\n  MRB_TRY(&c_jmp) {\n\n  if (exc_catched) {\n    exc_catched = FALSE;\n    if (mrb->exc && mrb->exc->tt == MRB_TT_BREAK)\n      goto L_BREAK;\n    goto L_RAISE;\n  }\n  mrb->jmp = &c_jmp;\n  mrb->c->ci->proc = proc;\n  mrb->c->ci->nregs = irep->nregs;\n\n#define regs (mrb->c->stack)\n  INIT_DISPATCH {\n    CASE(OP_NOP) {\n      /* do nothing */\n      NEXT;\n    }\n\n    CASE(OP_MOVE) {\n      /* A B    R(A) := R(B) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      regs[a] = regs[b];\n      NEXT;\n    }\n\n    CASE(OP_LOADL) {\n      /* A Bx   R(A) := Pool(Bx) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n#ifdef MRB_WORD_BOXING\n      mrb_value val = pool[bx];\n#ifndef MRB_WITHOUT_FLOAT\n      if (mrb_float_p(val)) {\n        val = mrb_float_value(mrb, mrb_float(val));\n      }\n#endif\n      regs[a] = val;\n#else\n      regs[a] = pool[bx];\n#endif\n      NEXT;\n    }\n\n    CASE(OP_LOADI) {\n      /* A sBx  R(A) := sBx */\n      int a = GETARG_A(i);\n      mrb_int bx = GETARG_sBx(i);\n      SET_INT_VALUE(regs[a], bx);\n      NEXT;\n    }\n\n    CASE(OP_LOADSYM) {\n      /* A Bx   R(A) := Syms(Bx) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      SET_SYM_VALUE(regs[a], syms[bx]);\n      NEXT;\n    }\n\n    CASE(OP_LOADSELF) {\n      /* A      R(A) := self */\n      int a = GETARG_A(i);\n      regs[a] = regs[0];\n      NEXT;\n    }\n\n    CASE(OP_LOADT) {\n      /* A      R(A) := true */\n      int a = GETARG_A(i);\n      SET_TRUE_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_LOADF) {\n      /* A      R(A) := false */\n      int a = GETARG_A(i);\n      SET_FALSE_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETGLOBAL) {\n      /* A Bx   R(A) := getglobal(Syms(Bx)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_value val = mrb_gv_get(mrb, syms[bx]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETGLOBAL) {\n      /* A Bx   setglobal(Syms(Bx), R(A)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_gv_set(mrb, syms[bx], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETSPECIAL) {\n      /* A Bx   R(A) := Special[Bx] */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_value val = mrb_vm_special_get(mrb, bx);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETSPECIAL) {\n      /* A Bx   Special[Bx] := R(A) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_vm_special_set(mrb, bx, regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETIV) {\n      /* A Bx   R(A) := ivget(Bx) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_value val = mrb_vm_iv_get(mrb, syms[bx]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETIV) {\n      /* A Bx   ivset(Syms(Bx),R(A)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_vm_iv_set(mrb, syms[bx], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETCV) {\n      /* A Bx   R(A) := cvget(Syms(Bx)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_value val;\n      ERR_PC_SET(mrb, pc);\n      val = mrb_vm_cv_get(mrb, syms[bx]);\n      ERR_PC_CLR(mrb);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETCV) {\n      /* A Bx   cvset(Syms(Bx),R(A)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_vm_cv_set(mrb, syms[bx], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETCONST) {\n      /* A Bx    R(A) := constget(Syms(Bx)) */\n      mrb_value val;\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_sym sym = syms[bx];\n\n      ERR_PC_SET(mrb, pc);\n      val = mrb_vm_const_get(mrb, sym);\n      ERR_PC_CLR(mrb);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETCONST) {\n      /* A Bx   constset(Syms(Bx),R(A)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_vm_const_set(mrb, syms[bx], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETMCNST) {\n      /* A Bx   R(A) := R(A)::Syms(Bx) */\n      mrb_value val;\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n\n      ERR_PC_SET(mrb, pc);\n      val = mrb_const_get(mrb, regs[a], syms[bx]);\n      ERR_PC_CLR(mrb);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETMCNST) {\n      /* A Bx    R(A+1)::Syms(Bx) := R(A) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_const_set(mrb, regs[a+1], syms[bx], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETUPVAR) {\n      /* A B C  R(A) := uvget(B,C) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n       mrb_value *regs_a = regs + a;\n       struct REnv *e = uvenv(mrb, c);\n \n      if (!e) {\n        *regs_a = mrb_nil_value();\n       }\n       else {\n        *regs_a = e->stack[b];\n       }\n       NEXT;\n     }\n\n    CASE(OP_SETUPVAR) {\n      /* A B C  uvset(B,C,R(A)) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n\n      struct REnv *e = uvenv(mrb, c);\n\n      if (e) {\n        mrb_value *regs_a = regs + a;\n\n        if (b < MRB_ENV_STACK_LEN(e)) {\n          e->stack[b] = *regs_a;\n          mrb_write_barrier(mrb, (struct RBasic*)e);\n        }\n      }\n      NEXT;\n    }\n\n    CASE(OP_JMP) {\n      /* sBx    pc+=sBx */\n      int sbx = GETARG_sBx(i);\n      pc += sbx;\n      JUMP;\n    }\n\n    CASE(OP_JMPIF) {\n      /* A sBx  if R(A) pc+=sBx */\n      int a = GETARG_A(i);\n      int sbx = GETARG_sBx(i);\n      if (mrb_test(regs[a])) {\n        pc += sbx;\n        JUMP;\n      }\n      NEXT;\n    }\n\n    CASE(OP_JMPNOT) {\n      /* A sBx  if !R(A) pc+=sBx */\n      int a = GETARG_A(i);\n      int sbx = GETARG_sBx(i);\n      if (!mrb_test(regs[a])) {\n        pc += sbx;\n        JUMP;\n      }\n      NEXT;\n    }\n\n    CASE(OP_ONERR) {\n      /* sBx    pc+=sBx on exception */\n      int sbx = GETARG_sBx(i);\n      if (mrb->c->rsize <= mrb->c->ci->ridx) {\n        if (mrb->c->rsize == 0) mrb->c->rsize = RESCUE_STACK_INIT_SIZE;\n        else mrb->c->rsize *= 2;\n        mrb->c->rescue = (mrb_code **)mrb_realloc(mrb, mrb->c->rescue, sizeof(mrb_code*) * mrb->c->rsize);\n      }\n      mrb->c->rescue[mrb->c->ci->ridx++] = pc + sbx;\n      NEXT;\n    }\n\n    CASE(OP_RESCUE) {\n      /* A B    R(A) := exc; clear(exc); R(B) := matched (bool) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n      mrb_value exc;\n\n      if (c == 0) {\n        exc = mrb_obj_value(mrb->exc);\n        mrb->exc = 0;\n      }\n      else {           /* continued; exc taken from R(A) */\n        exc = regs[a];\n      }\n      if (b != 0) {\n        mrb_value e = regs[b];\n        struct RClass *ec;\n\n        switch (mrb_type(e)) {\n        case MRB_TT_CLASS:\n        case MRB_TT_MODULE:\n          break;\n        default:\n          {\n            mrb_value exc;\n\n            exc = mrb_exc_new_str_lit(mrb, E_TYPE_ERROR,\n                  \"class or module required for rescue clause\");\n            mrb_exc_set(mrb, exc);\n            goto L_RAISE;\n          }\n        }\n        ec = mrb_class_ptr(e);\n        regs[b] = mrb_bool_value(mrb_obj_is_kind_of(mrb, exc, ec));\n      }\n      if (a != 0 && c == 0) {\n        regs[a] = exc;\n      }\n      NEXT;\n    }\n\n    CASE(OP_POPERR) {\n      /* A      A.times{rescue_pop()} */\n      int a = GETARG_A(i);\n\n      mrb->c->ci->ridx -= a;\n      NEXT;\n    }\n\n    CASE(OP_RAISE) {\n      /* A      raise(R(A)) */\n      int a = GETARG_A(i);\n\n      mrb_exc_set(mrb, regs[a]);\n      goto L_RAISE;\n    }\n\n    CASE(OP_EPUSH) {\n      /* Bx     ensure_push(SEQ[Bx]) */\n      int bx = GETARG_Bx(i);\n      struct RProc *p;\n\n      p = mrb_closure_new(mrb, irep->reps[bx]);\n      /* push ensure_stack */\n      if (mrb->c->esize <= mrb->c->eidx+1) {\n        if (mrb->c->esize == 0) mrb->c->esize = ENSURE_STACK_INIT_SIZE;\n        else mrb->c->esize *= 2;\n        mrb->c->ensure = (struct RProc **)mrb_realloc(mrb, mrb->c->ensure, sizeof(struct RProc*) * mrb->c->esize);\n      }\n      mrb->c->ensure[mrb->c->eidx++] = p;\n      mrb->c->ensure[mrb->c->eidx] = NULL;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_EPOP) {\n      /* A      A.times{ensure_pop().call} */\n      int a = GETARG_A(i);\n      mrb_callinfo *ci = mrb->c->ci;\n      int n, epos = ci->epos;\n      mrb_value self = regs[0];\n      struct RClass *target_class = ci->target_class;\n\n      if (mrb->c->eidx <= epos) {\n        NEXT;\n      }\n\n      if (a > mrb->c->eidx - epos)\n        a = mrb->c->eidx - epos;\n      pc = pc + 1;\n      for (n=0; n<a; n++) {\n        proc = mrb->c->ensure[epos+n];\n        mrb->c->ensure[epos+n] = NULL;\n        if (proc == NULL) continue;\n        irep = proc->body.irep;\n        ci = cipush(mrb);\n        ci->mid = ci[-1].mid;\n        ci->argc = 0;\n        ci->proc = proc;\n        ci->stackent = mrb->c->stack;\n        ci->nregs = irep->nregs;\n        ci->target_class = target_class;\n        ci->pc = pc;\n        ci->acc = ci[-1].nregs;\n        mrb->c->stack += ci->acc;\n        stack_extend(mrb, ci->nregs);\n        regs[0] = self;\n        pc = irep->iseq;\n      }\n      pool = irep->pool;\n      syms = irep->syms;\n      mrb->c->eidx = epos;\n      JUMP;\n    }\n\n    CASE(OP_LOADNIL) {\n      /* A     R(A) := nil */\n      int a = GETARG_A(i);\n\n      SET_NIL_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_SENDB) {\n      /* A B C  R(A) := call(R(A),Syms(B),R(A+1),...,R(A+C),&R(A+C+1))*/\n      /* fall through */\n    };\n\n  L_SEND:\n    CASE(OP_SEND) {\n      /* A B C  R(A) := call(R(A),Syms(B),R(A+1),...,R(A+C)) */\n      int a = GETARG_A(i);\n      int n = GETARG_C(i);\n      int argc = (n == CALL_MAXARGS) ? -1 : n;\n      int bidx = (argc < 0) ? a+2 : a+n+1;\n      mrb_method_t m;\n      struct RClass *c;\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_value recv, blk;\n      mrb_sym mid = syms[GETARG_B(i)];\n\n      mrb_assert(bidx < ci->nregs);\n\n      recv = regs[a];\n      if (GET_OPCODE(i) != OP_SENDB) {\n        SET_NIL_VALUE(regs[bidx]);\n        blk = regs[bidx];\n      }\n      else {\n        blk = regs[bidx];\n        if (!mrb_nil_p(blk) && mrb_type(blk) != MRB_TT_PROC) {\n          blk = mrb_convert_type(mrb, blk, MRB_TT_PROC, \"Proc\", \"to_proc\");\n          /* The stack might have been reallocated during mrb_convert_type(),\n             see #3622 */\n          regs[bidx] = blk;\n        }\n      }\n      c = mrb_class(mrb, recv);\n      m = mrb_method_search_vm(mrb, &c, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        mrb_sym missing = mrb_intern_lit(mrb, \"method_missing\");\n        m = mrb_method_search_vm(mrb, &c, missing);\n        if (MRB_METHOD_UNDEF_P(m) || (missing == mrb->c->ci->mid && mrb_obj_eq(mrb, regs[0], recv))) {\n          mrb_value args = (argc < 0) ? regs[a+1] : mrb_ary_new_from_values(mrb, n, regs+a+1);\n          ERR_PC_SET(mrb, pc);\n          mrb_method_missing(mrb, mid, recv, args);\n        }\n        if (argc >= 0) {\n          if (a+2 >= irep->nregs) {\n            stack_extend(mrb, a+3);\n          }\n          regs[a+1] = mrb_ary_new_from_values(mrb, n, regs+a+1);\n          regs[a+2] = blk;\n          argc = -1;\n        }\n        mrb_ary_unshift(mrb, regs[a+1], mrb_symbol_value(mid));\n        mid = missing;\n      }\n\n      /* push callinfo */\n      ci = cipush(mrb);\n      ci->mid = mid;\n      ci->stackent = mrb->c->stack;\n      ci->target_class = c;\n      ci->argc = argc;\n\n      ci->pc = pc + 1;\n      ci->acc = a;\n\n      /* prepare stack */\n      mrb->c->stack += a;\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        ci->nregs = (argc < 0) ? 3 : n+2;\n        if (MRB_METHOD_PROC_P(m)) {\n          struct RProc *p = MRB_METHOD_PROC(m);\n\n          ci->proc = p;\n          recv = p->body.func(mrb, recv);\n        }\n        else {\n          recv = MRB_METHOD_FUNC(m)(mrb, recv);\n        }\n        mrb_gc_arena_restore(mrb, ai);\n        mrb_gc_arena_shrink(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        ci = mrb->c->ci;\n        if (GET_OPCODE(i) == OP_SENDB) {\n          if (mrb_type(blk) == MRB_TT_PROC) {\n            struct RProc *p = mrb_proc_ptr(blk);\n            if (p && !MRB_PROC_STRICT_P(p) && MRB_PROC_ENV(p) == ci[-1].env) {\n              p->flags |= MRB_PROC_ORPHAN;\n            }\n          }\n        }\n        if (!ci->target_class) { /* return from context modifying method (resume/yield) */\n          if (ci->acc == CI_ACC_RESUMED) {\n            mrb->jmp = prev_jmp;\n            return recv;\n          }\n          else {\n            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n            proc = ci[-1].proc;\n            irep = proc->body.irep;\n            pool = irep->pool;\n            syms = irep->syms;\n          }\n        }\n        mrb->c->stack[0] = recv;\n        /* pop stackpos */\n        mrb->c->stack = ci->stackent;\n        pc = ci->pc;\n        cipop(mrb);\n        JUMP;\n      }\n      else {\n        /* setup environment for calling method */\n        proc = ci->proc = MRB_METHOD_PROC(m);\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        ci->nregs = irep->nregs;\n        stack_extend(mrb, (argc < 0 && ci->nregs < 3) ? 3 : ci->nregs);\n        pc = irep->iseq;\n        JUMP;\n      }\n    }\n\n    CASE(OP_FSEND) {\n      /* A B C  R(A) := fcall(R(A),Syms(B),R(A+1),... ,R(A+C-1)) */\n      /* not implemented yet */\n      NEXT;\n    }\n\n    CASE(OP_CALL) {\n      /* A      R(A) := self.call(frame.argc, frame.argv) */\n      mrb_callinfo *ci;\n      mrb_value recv = mrb->c->stack[0];\n      struct RProc *m = mrb_proc_ptr(recv);\n\n      /* replace callinfo */\n      ci = mrb->c->ci;\n      ci->target_class = MRB_PROC_TARGET_CLASS(m);\n      ci->proc = m;\n      if (MRB_PROC_ENV_P(m)) {\n        mrb_sym mid;\n        struct REnv *e = MRB_PROC_ENV(m);\n\n        mid = e->mid;\n        if (mid) ci->mid = mid;\n        if (!e->stack) {\n          e->stack = mrb->c->stack;\n        }\n      }\n\n      /* prepare stack */\n      if (MRB_PROC_CFUNC_P(m)) {\n        recv = MRB_PROC_CFUNC(m)(mrb, recv);\n        mrb_gc_arena_restore(mrb, ai);\n        mrb_gc_arena_shrink(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        /* pop stackpos */\n        ci = mrb->c->ci;\n        mrb->c->stack = ci->stackent;\n        regs[ci->acc] = recv;\n        pc = ci->pc;\n        cipop(mrb);\n        irep = mrb->c->ci->proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        JUMP;\n      }\n      else {\n        /* setup environment for calling method */\n        proc = m;\n        irep = m->body.irep;\n        if (!irep) {\n          mrb->c->stack[0] = mrb_nil_value();\n          goto L_RETURN;\n        }\n        pool = irep->pool;\n        syms = irep->syms;\n        ci->nregs = irep->nregs;\n        stack_extend(mrb, ci->nregs);\n        if (ci->argc < 0) {\n          if (irep->nregs > 3) {\n            stack_clear(regs+3, irep->nregs-3);\n          }\n        }\n        else if (ci->argc+2 < irep->nregs) {\n          stack_clear(regs+ci->argc+2, irep->nregs-ci->argc-2);\n        }\n        if (MRB_PROC_ENV_P(m)) {\n          regs[0] = MRB_PROC_ENV(m)->stack[0];\n        }\n        pc = irep->iseq;\n        JUMP;\n      }\n    }\n\n    CASE(OP_SUPER) {\n      /* A C  R(A) := super(R(A+1),... ,R(A+C+1)) */\n      int a = GETARG_A(i);\n      int n = GETARG_C(i);\n      int argc = (n == CALL_MAXARGS) ? -1 : n;\n      int bidx = (argc < 0) ? a+2 : a+n+1;\n      mrb_method_t m;\n      struct RClass *c;\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_value recv, blk;\n      mrb_sym mid = ci->mid;\n      struct RClass* target_class = MRB_PROC_TARGET_CLASS(ci->proc);\n\n      mrb_assert(bidx < ci->nregs);\n\n      if (mid == 0 || !target_class) {\n        mrb_value exc = mrb_exc_new_str_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if (target_class->tt == MRB_TT_MODULE) {\n        target_class = ci->target_class;\n        if (target_class->tt != MRB_TT_ICLASS) {\n          mrb_value exc = mrb_exc_new_str_lit(mrb, E_RUNTIME_ERROR, \"superclass info lost [mruby limitations]\");\n          mrb_exc_set(mrb, exc);\n          goto L_RAISE;\n        }\n      }\n      recv = regs[0];\n      if (!mrb_obj_is_kind_of(mrb, recv, target_class)) {\n        mrb_value exc = mrb_exc_new_str_lit(mrb, E_TYPE_ERROR,\n                                            \"self has wrong type to call super in this context\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      blk = regs[bidx];\n      if (!mrb_nil_p(blk) && mrb_type(blk) != MRB_TT_PROC) {\n        blk = mrb_convert_type(mrb, blk, MRB_TT_PROC, \"Proc\", \"to_proc\");\n        /* The stack or ci stack might have been reallocated during\n           mrb_convert_type(), see #3622 and #3784 */\n        regs[bidx] = blk;\n        ci = mrb->c->ci;\n      }\n      c = target_class->super;\n      m = mrb_method_search_vm(mrb, &c, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        mrb_sym missing = mrb_intern_lit(mrb, \"method_missing\");\n\n        if (mid != missing) {\n          c = mrb_class(mrb, recv);\n        }\n        m = mrb_method_search_vm(mrb, &c, missing);\n        if (MRB_METHOD_UNDEF_P(m)) {\n          mrb_value args = (argc < 0) ? regs[a+1] : mrb_ary_new_from_values(mrb, n, regs+a+1);\n          ERR_PC_SET(mrb, pc);\n          mrb_method_missing(mrb, mid, recv, args);\n        }\n        mid = missing;\n        if (argc >= 0) {\n          if (a+2 >= ci->nregs) {\n            stack_extend(mrb, a+3);\n          }\n          regs[a+1] = mrb_ary_new_from_values(mrb, n, regs+a+1);\n          regs[a+2] = blk;\n          argc = -1;\n        }\n        mrb_ary_unshift(mrb, regs[a+1], mrb_symbol_value(ci->mid));\n      }\n\n      /* push callinfo */\n      ci = cipush(mrb);\n      ci->mid = mid;\n      ci->stackent = mrb->c->stack;\n      ci->target_class = c;\n      ci->pc = pc + 1;\n      ci->argc = argc;\n\n      /* prepare stack */\n      mrb->c->stack += a;\n      mrb->c->stack[0] = recv;\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        mrb_value v;\n        ci->nregs = (argc < 0) ? 3 : n+2;\n        if (MRB_METHOD_PROC_P(m)) {\n          ci->proc = MRB_METHOD_PROC(m);\n        }\n        v = MRB_METHOD_CFUNC(m)(mrb, recv);\n        mrb_gc_arena_restore(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        ci = mrb->c->ci;\n        if (!ci->target_class) { /* return from context modifying method (resume/yield) */\n          if (ci->acc == CI_ACC_RESUMED) {\n            mrb->jmp = prev_jmp;\n            return v;\n          }\n          else {\n            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n            proc = ci[-1].proc;\n            irep = proc->body.irep;\n            pool = irep->pool;\n            syms = irep->syms;\n          }\n        }\n        mrb->c->stack[0] = v;\n        /* pop stackpos */\n        mrb->c->stack = ci->stackent;\n        pc = ci->pc;\n        cipop(mrb);\n        JUMP;\n      }\n      else {\n        /* fill callinfo */\n        ci->acc = a;\n\n        /* setup environment for calling method */\n        proc = ci->proc = MRB_METHOD_PROC(m);\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        ci->nregs = irep->nregs;\n        stack_extend(mrb, (argc < 0 && ci->nregs < 3) ? 3 : ci->nregs);\n        pc = irep->iseq;\n        JUMP;\n      }\n    }\n\n    CASE(OP_ARGARY) {\n      /* A Bx   R(A) := argument array (16=6:1:5:4) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      int m1 = (bx>>10)&0x3f;\n      int r  = (bx>>9)&0x1;\n      int m2 = (bx>>4)&0x1f;\n      int lv = (bx>>0)&0xf;\n      mrb_value *stack;\n\n      if (mrb->c->ci->mid == 0 || mrb->c->ci->target_class == NULL) {\n        mrb_value exc;\n\n      L_NOSUPER:\n        exc = mrb_exc_new_str_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if (lv == 0) stack = regs + 1;\n      else {\n        struct REnv *e = uvenv(mrb, lv-1);\n        if (!e) goto L_NOSUPER;\n        if (MRB_ENV_STACK_LEN(e) <= m1+r+m2+1)\n          goto L_NOSUPER;\n        stack = e->stack + 1;\n      }\n      if (r == 0) {\n        regs[a] = mrb_ary_new_from_values(mrb, m1+m2, stack);\n      }\n      else {\n        mrb_value *pp = NULL;\n        struct RArray *rest;\n        int len = 0;\n\n        if (mrb_array_p(stack[m1])) {\n          struct RArray *ary = mrb_ary_ptr(stack[m1]);\n\n          pp = ARY_PTR(ary);\n          len = (int)ARY_LEN(ary);\n        }\n        regs[a] = mrb_ary_new_capa(mrb, m1+len+m2);\n        rest = mrb_ary_ptr(regs[a]);\n        if (m1 > 0) {\n          stack_copy(ARY_PTR(rest), stack, m1);\n        }\n        if (len > 0) {\n          stack_copy(ARY_PTR(rest)+m1, pp, len);\n        }\n        if (m2 > 0) {\n          stack_copy(ARY_PTR(rest)+m1+len, stack+m1+1, m2);\n        }\n        ARY_SET_LEN(rest, m1+len+m2);\n      }\n      regs[a+1] = stack[m1+r+m2];\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ENTER) {\n      /* Ax             arg setup according to flags (23=5:5:1:5:5:1:1) */\n      /* number of optional arguments times OP_JMP should follow */\n      mrb_aspec ax = GETARG_Ax(i);\n      int m1 = MRB_ASPEC_REQ(ax);\n      int o  = MRB_ASPEC_OPT(ax);\n      int r  = MRB_ASPEC_REST(ax);\n      int m2 = MRB_ASPEC_POST(ax);\n      /* unused\n      int k  = MRB_ASPEC_KEY(ax);\n      int kd = MRB_ASPEC_KDICT(ax);\n      int b  = MRB_ASPEC_BLOCK(ax);\n      */\n      int argc = mrb->c->ci->argc;\n      mrb_value *argv = regs+1;\n      mrb_value *argv0 = argv;\n      int len = m1 + o + r + m2;\n      mrb_value *blk = &argv[argc < 0 ? 1 : argc];\n\n      if (argc < 0) {\n        struct RArray *ary = mrb_ary_ptr(regs[1]);\n        argv = ARY_PTR(ary);\n        argc = (int)ARY_LEN(ary);\n        mrb_gc_protect(mrb, regs[1]);\n      }\n      if (mrb->c->ci->proc && MRB_PROC_STRICT_P(mrb->c->ci->proc)) {\n        if (argc >= 0) {\n          if (argc < m1 + m2 || (r == 0 && argc > len)) {\n            argnum_error(mrb, m1+m2);\n            goto L_RAISE;\n          }\n        }\n      }\n      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {\n        mrb_gc_protect(mrb, argv[0]);\n        argc = (int)RARRAY_LEN(argv[0]);\n        argv = RARRAY_PTR(argv[0]);\n      }\n      if (argc < len) {\n        int mlen = m2;\n        if (argc < m1+m2) {\n          if (m1 < argc)\n            mlen = argc - m1;\n          else\n            mlen = 0;\n        }\n        regs[len+1] = *blk; /* move block */\n        SET_NIL_VALUE(regs[argc+1]);\n        if (argv0 != argv) {\n          value_move(&regs[1], argv, argc-mlen); /* m1 + o */\n        }\n        if (argc < m1) {\n          stack_clear(&regs[argc+1], m1-argc);\n        }\n        if (mlen) {\n          value_move(&regs[len-m2+1], &argv[argc-mlen], mlen);\n        }\n        if (mlen < m2) {\n          stack_clear(&regs[len-m2+mlen+1], m2-mlen);\n        }\n        if (r) {\n          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);\n        }\n        if (o == 0 || argc < m1+m2) pc++;\n        else\n          pc += argc - m1 - m2 + 1;\n      }\n      else {\n        int rnum = 0;\n        if (argv0 != argv) {\n          regs[len+1] = *blk; /* move block */\n          value_move(&regs[1], argv, m1+o);\n        }\n        if (r) {\n          rnum = argc-m1-o-m2;\n          regs[m1+o+1] = mrb_ary_new_from_values(mrb, rnum, argv+m1+o);\n        }\n        if (m2) {\n          if (argc-m2 > m1) {\n            value_move(&regs[m1+o+r+1], &argv[m1+o+rnum], m2);\n          }\n        }\n        if (argv0 == argv) {\n          regs[len+1] = *blk; /* move block */\n        }\n        pc += o + 1;\n      }\n      mrb->c->ci->argc = len;\n      /* clear local (but non-argument) variables */\n      if (irep->nlocals-len-2 > 0) {\n        stack_clear(&regs[len+2], irep->nlocals-len-2);\n      }\n      JUMP;\n    }\n\n    CASE(OP_KARG) {\n      /* A B C          R(A) := kdict[Syms(B)]; if C kdict.rm(Syms(B)) */\n      /* if C == 2; raise unless kdict.empty? */\n      /* OP_JMP should follow to skip init code */\n      NEXT;\n    }\n\n    CASE(OP_KDICT) {\n      /* A C            R(A) := kdict */\n      NEXT;\n    }\n\n    L_RETURN:\n      i = MKOP_AB(OP_RETURN, GETARG_A(i), OP_R_NORMAL);\n      /* fall through */\n    CASE(OP_RETURN) {\n      /* A B     return R(A) (B=normal,in-block return/break) */\n      mrb_callinfo *ci;\n\n#define ecall_adjust() do {\\\n  ptrdiff_t cioff = ci - mrb->c->cibase;\\\n  ecall(mrb);\\\n  ci = mrb->c->cibase + cioff;\\\n} while (0)\n\n      ci = mrb->c->ci;\n      if (ci->mid) {\n        mrb_value blk;\n\n        if (ci->argc < 0) {\n          blk = regs[2];\n        }\n        else {\n          blk = regs[ci->argc+1];\n        }\n        if (mrb_type(blk) == MRB_TT_PROC) {\n          struct RProc *p = mrb_proc_ptr(blk);\n\n          if (!MRB_PROC_STRICT_P(p) &&\n              ci > mrb->c->cibase && MRB_PROC_ENV(p) == ci[-1].env) {\n            p->flags |= MRB_PROC_ORPHAN;\n          }\n        }\n      }\n\n      if (mrb->exc) {\n        mrb_callinfo *ci0;\n\n      L_RAISE:\n        ci0 = ci = mrb->c->ci;\n        if (ci == mrb->c->cibase) {\n          if (ci->ridx == 0) goto L_FTOP;\n          goto L_RESCUE;\n        }\n        while (ci[0].ridx == ci[-1].ridx) {\n          cipop(mrb);\n          mrb->c->stack = ci->stackent;\n          if (ci->acc == CI_ACC_SKIP && prev_jmp) {\n            mrb->jmp = prev_jmp;\n            MRB_THROW(prev_jmp);\n          }\n          ci = mrb->c->ci;\n          if (ci == mrb->c->cibase) {\n            if (ci->ridx == 0) {\n            L_FTOP:             /* fiber top */\n              if (mrb->c == mrb->root_c) {\n                mrb->c->stack = mrb->c->stbase;\n                goto L_STOP;\n              }\n              else {\n                struct mrb_context *c = mrb->c;\n\n                while (c->eidx > ci->epos) {\n                  ecall_adjust();\n                }\n                if (c->fib) {\n                  mrb_write_barrier(mrb, (struct RBasic*)c->fib);\n                }\n                mrb->c->status = MRB_FIBER_TERMINATED;\n                mrb->c = c->prev;\n                c->prev = NULL;\n                goto L_RAISE;\n              }\n            }\n            break;\n          }\n          /* call ensure only when we skip this callinfo */\n          if (ci[0].ridx == ci[-1].ridx) {\n            while (mrb->c->eidx > ci->epos) {\n              ecall_adjust();\n            }\n          }\n        }\n      L_RESCUE:\n        if (ci->ridx == 0) goto L_STOP;\n        proc = ci->proc;\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        if (ci < ci0) {\n          mrb->c->stack = ci[1].stackent;\n        }\n        stack_extend(mrb, irep->nregs);\n        pc = mrb->c->rescue[--ci->ridx];\n      }\n      else {\n        int acc;\n        mrb_value v;\n        struct RProc *dst;\n\n        ci = mrb->c->ci;\n        v = regs[GETARG_A(i)];\n        mrb_gc_protect(mrb, v);\n        switch (GETARG_B(i)) {\n        case OP_R_RETURN:\n          /* Fall through to OP_R_NORMAL otherwise */\n          if (ci->acc >=0 && MRB_PROC_ENV_P(proc) && !MRB_PROC_STRICT_P(proc)) {\n            mrb_callinfo *cibase = mrb->c->cibase;\n            dst = top_proc(mrb, proc);\n\n            if (MRB_PROC_ENV_P(dst)) {\n              struct REnv *e = MRB_PROC_ENV(dst);\n\n              if (!MRB_ENV_STACK_SHARED_P(e) || e->cxt != mrb->c) {\n                localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                goto L_RAISE;\n              }\n            }\n            while (cibase <= ci && ci->proc != dst) {\n              if (ci->acc < 0) {\n                localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                goto L_RAISE;\n              }\n              ci--;\n            }\n            if (ci <= cibase) {\n              localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n              goto L_RAISE;\n            }\n            break;\n          }\n        case OP_R_NORMAL:\n        NORMAL_RETURN:\n          if (ci == mrb->c->cibase) {\n            struct mrb_context *c;\n\n            if (!mrb->c->prev) { /* toplevel return */\n              localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n              goto L_RAISE;\n            }\n            if (mrb->c->prev->ci == mrb->c->prev->cibase) {\n              mrb_value exc = mrb_exc_new_str_lit(mrb, E_FIBER_ERROR, \"double resume\");\n              mrb_exc_set(mrb, exc);\n              goto L_RAISE;\n            }\n            while (mrb->c->eidx > 0) {\n              ecall(mrb);\n            }\n            /* automatic yield at the end */\n            c = mrb->c;\n            c->status = MRB_FIBER_TERMINATED;\n            mrb->c = c->prev;\n            c->prev = NULL;\n            mrb->c->status = MRB_FIBER_RUNNING;\n            ci = mrb->c->ci;\n          }\n          break;\n        case OP_R_BREAK:\n          if (MRB_PROC_STRICT_P(proc)) goto NORMAL_RETURN;\n          if (MRB_PROC_ORPHAN_P(proc)) { \n            mrb_value exc;\n\n          L_BREAK_ERROR:\n            exc = mrb_exc_new_str_lit(mrb, E_LOCALJUMP_ERROR,\n                                      \"break from proc-closure\");\n            mrb_exc_set(mrb, exc);\n            goto L_RAISE;\n          }\n          if (!MRB_PROC_ENV_P(proc) || !MRB_ENV_STACK_SHARED_P(MRB_PROC_ENV(proc))) {\n            goto L_BREAK_ERROR;\n          }\n          else {\n            struct REnv *e = MRB_PROC_ENV(proc);\n\n            if (e == mrb->c->cibase->env && proc != mrb->c->cibase->proc) {\n              goto L_BREAK_ERROR;\n            }\n            if (e->cxt != mrb->c) {\n              goto L_BREAK_ERROR;\n            }\n          }\n          while (mrb->c->eidx > mrb->c->ci->epos) {\n            ecall_adjust();\n          }\n          /* break from fiber block */\n          if (ci == mrb->c->cibase && ci->pc) {\n            struct mrb_context *c = mrb->c;\n\n            mrb->c = c->prev;\n            c->prev = NULL;\n            ci = mrb->c->ci;\n          }\n          if (ci->acc < 0) {\n            mrb_gc_arena_restore(mrb, ai);\n            mrb->c->vmexec = FALSE;\n            mrb->exc = (struct RObject*)break_new(mrb, proc, v);\n            mrb->jmp = prev_jmp;\n            MRB_THROW(prev_jmp);\n          }\n          if (FALSE) {\n          L_BREAK:\n            v = ((struct RBreak*)mrb->exc)->val;\n            proc = ((struct RBreak*)mrb->exc)->proc;\n            mrb->exc = NULL;\n            ci = mrb->c->ci;\n          }\n          mrb->c->stack = ci->stackent;\n          proc = proc->upper;\n          while (mrb->c->cibase < ci &&  ci[-1].proc != proc) {\n            if (ci[-1].acc == CI_ACC_SKIP) {\n              while (ci < mrb->c->ci) {\n                cipop(mrb);\n              }\n              goto L_BREAK_ERROR;\n            }\n            ci--;\n          }\n          if (ci == mrb->c->cibase) {\n            goto L_BREAK_ERROR;\n          }\n          break;\n        default:\n          /* cannot happen */\n          break;\n        }\n        while (ci < mrb->c->ci) {\n          cipop(mrb);\n        }\n        ci[0].ridx = ci[-1].ridx;\n        while (mrb->c->eidx > ci->epos) {\n          ecall_adjust();\n        }\n        if (mrb->c->vmexec && !ci->target_class) {\n          mrb_gc_arena_restore(mrb, ai);\n          mrb->c->vmexec = FALSE;\n          mrb->jmp = prev_jmp;\n          return v;\n        }\n        acc = ci->acc;\n        mrb->c->stack = ci->stackent;\n        cipop(mrb);\n        if (acc == CI_ACC_SKIP || acc == CI_ACC_DIRECT) {\n          mrb_gc_arena_restore(mrb, ai);\n          mrb->jmp = prev_jmp;\n          return v;\n        }\n        pc = ci->pc;\n        ci = mrb->c->ci;\n        DEBUG(fprintf(stderr, \"from :%s\\n\", mrb_sym2name(mrb, ci->mid)));\n        proc = mrb->c->ci->proc;\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n\n        regs[acc] = v;\n        mrb_gc_arena_restore(mrb, ai);\n      }\n      JUMP;\n    }\n\n    CASE(OP_TAILCALL) {\n      /* A B C  return call(R(A),Syms(B),R(A+1),... ,R(A+C+1)) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int n = GETARG_C(i);\n      mrb_method_t m;\n      struct RClass *c;\n      mrb_callinfo *ci;\n      mrb_value recv;\n      mrb_sym mid = syms[b];\n\n      recv = regs[a];\n      c = mrb_class(mrb, recv);\n      m = mrb_method_search_vm(mrb, &c, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        mrb_value sym = mrb_symbol_value(mid);\n        mrb_sym missing = mrb_intern_lit(mrb, \"method_missing\");\n        m = mrb_method_search_vm(mrb, &c, missing);\n        if (MRB_METHOD_UNDEF_P(m)) {\n          mrb_value args;\n\n          if (n == CALL_MAXARGS) {\n            args = regs[a+1];\n          }\n          else {\n            args = mrb_ary_new_from_values(mrb, n, regs+a+1);\n          }\n          ERR_PC_SET(mrb, pc);\n          mrb_method_missing(mrb, mid, recv, args);\n        }\n        mid = missing;\n        if (n == CALL_MAXARGS) {\n          mrb_ary_unshift(mrb, regs[a+1], sym);\n        }\n        else {\n          value_move(regs+a+2, regs+a+1, ++n);\n          regs[a+1] = sym;\n        }\n      }\n\n      /* replace callinfo */\n      ci = mrb->c->ci;\n      ci->mid = mid;\n      ci->target_class = c;\n      if (n == CALL_MAXARGS) {\n        ci->argc = -1;\n      }\n      else {\n        ci->argc = n;\n      }\n\n      /* move stack */\n      value_move(mrb->c->stack, &regs[a], ci->argc+1);\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        mrb_value v = MRB_METHOD_CFUNC(m)(mrb, recv);\n        mrb->c->stack[0] = v;\n        mrb_gc_arena_restore(mrb, ai);\n        goto L_RETURN;\n      }\n      else {\n        /* setup environment for calling method */\n        struct RProc *p = MRB_METHOD_PROC(m);\n        irep = p->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        if (ci->argc < 0) {\n          stack_extend(mrb, (irep->nregs < 3) ? 3 : irep->nregs);\n        }\n        else {\n          stack_extend(mrb, irep->nregs);\n        }\n        pc = irep->iseq;\n      }\n      JUMP;\n    }\n\n    CASE(OP_BLKPUSH) {\n      /* A Bx   R(A) := block (16=6:1:5:4) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      int m1 = (bx>>10)&0x3f;\n      int r  = (bx>>9)&0x1;\n      int m2 = (bx>>4)&0x1f;\n      int lv = (bx>>0)&0xf;\n      mrb_value *stack;\n\n      if (lv == 0) stack = regs + 1;\n      else {\n        struct REnv *e = uvenv(mrb, lv-1);\n        if (!e || (!MRB_ENV_STACK_SHARED_P(e) && e->mid == 0) ||\n            MRB_ENV_STACK_LEN(e) <= m1+r+m2+1) {\n          localjump_error(mrb, LOCALJUMP_ERROR_YIELD);\n          goto L_RAISE;\n        }\n        stack = e->stack + 1;\n      }\n      if (mrb_nil_p(stack[m1+r+m2])) {\n        localjump_error(mrb, LOCALJUMP_ERROR_YIELD);\n        goto L_RAISE;\n      }\n      regs[a] = stack[m1+r+m2];\n      NEXT;\n    }\n\n#define TYPES2(a,b) ((((uint16_t)(a))<<8)|(((uint16_t)(b))&0xff))\n#define OP_MATH_BODY(op,v1,v2) do {\\\n  v1(regs[a]) = v1(regs[a]) op v2(regs[a+1]);\\\n} while(0)\n\n    CASE(OP_ADD) {\n      /* A B C  R(A) := R(A)+R(A+1) (Syms[B]=:+,C=1)*/\n      int a = GETARG_A(i);\n\n      /* need to check if op is overridden */\n      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\n        {\n          mrb_int x, y, z;\n          mrb_value *regs_a = regs + a;\n\n          x = mrb_fixnum(regs_a[0]);\n          y = mrb_fixnum(regs_a[1]);\n          if (mrb_int_add_overflow(x, y, &z)) {\n#ifndef MRB_WITHOUT_FLOAT\n            SET_FLOAT_VALUE(mrb, regs_a[0], (mrb_float)x + (mrb_float)y);\n            break;\n#endif\n          }\n          SET_INT_VALUE(regs[a], z);\n        }\n        break;\n#ifndef MRB_WITHOUT_FLOAT\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):\n        {\n          mrb_int x = mrb_fixnum(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x + y);\n        }\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_int y = mrb_fixnum(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x + y);\n        }\n#else\n        OP_MATH_BODY(+,mrb_float,mrb_fixnum);\n#endif\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x + y);\n        }\n#else\n        OP_MATH_BODY(+,mrb_float,mrb_float);\n#endif\n        break;\n#endif\n      case TYPES2(MRB_TT_STRING,MRB_TT_STRING):\n        regs[a] = mrb_str_plus(mrb, regs[a], regs[a+1]);\n        break;\n      default:\n        goto L_SEND;\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_SUB) {\n      /* A B C  R(A) := R(A)-R(A+1) (Syms[B]=:-,C=1)*/\n      int a = GETARG_A(i);\n\n      /* need to check if op is overridden */\n      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\n        {\n          mrb_int x, y, z;\n\n          x = mrb_fixnum(regs[a]);\n          y = mrb_fixnum(regs[a+1]);\n          if (mrb_int_sub_overflow(x, y, &z)) {\n#ifndef MRB_WITHOUT_FLOAT\n            SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x - (mrb_float)y);\n            break;\n#endif\n          }\n          SET_INT_VALUE(regs[a], z);\n        }\n        break;\n#ifndef MRB_WITHOUT_FLOAT\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):\n        {\n          mrb_int x = mrb_fixnum(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x - y);\n        }\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_int y = mrb_fixnum(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x - y);\n        }\n#else\n        OP_MATH_BODY(-,mrb_float,mrb_fixnum);\n#endif\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x - y);\n        }\n#else\n        OP_MATH_BODY(-,mrb_float,mrb_float);\n#endif\n        break;\n#endif\n      default:\n        goto L_SEND;\n      }\n      NEXT;\n    }\n\n    CASE(OP_MUL) {\n      /* A B C  R(A) := R(A)*R(A+1) (Syms[B]=:*,C=1)*/\n      int a = GETARG_A(i);\n\n      /* need to check if op is overridden */\n      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\n        {\n          mrb_int x, y, z;\n\n          x = mrb_fixnum(regs[a]);\n          y = mrb_fixnum(regs[a+1]);\n          if (mrb_int_mul_overflow(x, y, &z)) {\n#ifndef MRB_WITHOUT_FLOAT\n            SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x * (mrb_float)y);\n            break;\n#endif\n          }\n          SET_INT_VALUE(regs[a], z);\n        }\n        break;\n#ifndef MRB_WITHOUT_FLOAT\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):\n        {\n          mrb_int x = mrb_fixnum(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x * y);\n        }\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_int y = mrb_fixnum(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x * y);\n        }\n#else\n        OP_MATH_BODY(*,mrb_float,mrb_fixnum);\n#endif\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x * y);\n        }\n#else\n        OP_MATH_BODY(*,mrb_float,mrb_float);\n#endif\n        break;\n#endif\n      default:\n        goto L_SEND;\n      }\n      NEXT;\n    }\n\n    CASE(OP_DIV) {\n      /* A B C  R(A) := R(A)/R(A+1) (Syms[B]=:/,C=1)*/\n      int a = GETARG_A(i);\n#ifndef MRB_WITHOUT_FLOAT\n      double x, y, f;\n#endif\n\n      /* need to check if op is overridden */\n      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\n#ifdef MRB_WITHOUT_FLOAT\n        {\n          mrb_int x = mrb_fixnum(regs[a]);\n          mrb_int y = mrb_fixnum(regs[a+1]);\n          SET_INT_VALUE(regs[a], y ? x / y : 0);\n        }\n        break;\n#else\n        x = (mrb_float)mrb_fixnum(regs[a]);\n        y = (mrb_float)mrb_fixnum(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):\n        x = (mrb_float)mrb_fixnum(regs[a]);\n        y = mrb_float(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):\n        x = mrb_float(regs[a]);\n        y = (mrb_float)mrb_fixnum(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n        x = mrb_float(regs[a]);\n        y = mrb_float(regs[a+1]);\n        break;\n#endif\n      default:\n        goto L_SEND;\n      }\n\n#ifndef MRB_WITHOUT_FLOAT\n      if (y == 0) {\n        if (x > 0) f = INFINITY;\n        else if (x < 0) f = -INFINITY;\n        else /* if (x == 0) */ f = NAN;\n      }\n      else {\n        f = x / y;\n      }\n      SET_FLOAT_VALUE(mrb, regs[a], f);\n#endif\n      NEXT;\n    }\n\n    CASE(OP_ADDI) {\n      /* A B C  R(A) := R(A)+C (Syms[B]=:+)*/\n      int a = GETARG_A(i);\n\n      /* need to check if + is overridden */\n      switch (mrb_type(regs[a])) {\n      case MRB_TT_FIXNUM:\n        {\n          mrb_int x = mrb_fixnum(regs[a]);\n          mrb_int y = GETARG_C(i);\n          mrb_int z;\n\n          if (mrb_int_add_overflow(x, y, &z)) {\n#ifndef MRB_WITHOUT_FLOAT\n            SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x + (mrb_float)y);\n            break;\n#endif\n          }\n          SET_INT_VALUE(regs[a], z);\n        }\n        break;\n#ifndef MRB_WITHOUT_FLOAT\n      case MRB_TT_FLOAT:\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          SET_FLOAT_VALUE(mrb, regs[a], x + GETARG_C(i));\n        }\n#else\n        mrb_float(regs[a]) += GETARG_C(i);\n#endif\n        break;\n#endif\n      default:\n        SET_INT_VALUE(regs[a+1], GETARG_C(i));\n        i = MKOP_ABC(OP_SEND, a, GETARG_B(i), 1);\n        goto L_SEND;\n      }\n      NEXT;\n    }\n\n    CASE(OP_SUBI) {\n      /* A B C  R(A) := R(A)-C (Syms[B]=:-)*/\n      int a = GETARG_A(i);\n      mrb_value *regs_a = regs + a;\n\n      /* need to check if + is overridden */\n      switch (mrb_type(regs_a[0])) {\n      case MRB_TT_FIXNUM:\n        {\n          mrb_int x = mrb_fixnum(regs_a[0]);\n          mrb_int y = GETARG_C(i);\n          mrb_int z;\n\n          if (mrb_int_sub_overflow(x, y, &z)) {\n#ifndef MRB_WITHOUT_FLOAT\n            SET_FLOAT_VALUE(mrb, regs_a[0], (mrb_float)x - (mrb_float)y);\n            break;\n#endif\n          }\n          SET_INT_VALUE(regs_a[0], z);\n        }\n        break;\n#ifndef MRB_WITHOUT_FLOAT\n      case MRB_TT_FLOAT:\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          SET_FLOAT_VALUE(mrb, regs[a], x - GETARG_C(i));\n        }\n#else\n        mrb_float(regs_a[0]) -= GETARG_C(i);\n#endif\n        break;\n#endif\n      default:\n        SET_INT_VALUE(regs_a[1], GETARG_C(i));\n        i = MKOP_ABC(OP_SEND, a, GETARG_B(i), 1);\n        goto L_SEND;\n      }\n      NEXT;\n    }\n\n#define OP_CMP_BODY(op,v1,v2) (v1(regs[a]) op v2(regs[a+1]))\n\n#ifdef MRB_WITHOUT_FLOAT\n#define OP_CMP(op) do {\\\n  int result;\\\n  /* need to check if - is overridden */\\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\\\n  case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\\\n    break;\\\n  default:\\\n    goto L_SEND;\\\n  }\\\n  if (result) {\\\n    SET_TRUE_VALUE(regs[a]);\\\n  }\\\n  else {\\\n    SET_FALSE_VALUE(regs[a]);\\\n  }\\\n} while(0)\n#else\n#define OP_CMP(op) do {\\\n  int result;\\\n  /* need to check if - is overridden */\\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\\\n  case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\\\n    break;\\\n  case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_float);\\\n    break;\\\n  case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):\\\n    result = OP_CMP_BODY(op,mrb_float,mrb_fixnum);\\\n    break;\\\n  case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\\\n    result = OP_CMP_BODY(op,mrb_float,mrb_float);\\\n    break;\\\n  default:\\\n    goto L_SEND;\\\n  }\\\n  if (result) {\\\n    SET_TRUE_VALUE(regs[a]);\\\n  }\\\n  else {\\\n    SET_FALSE_VALUE(regs[a]);\\\n  }\\\n} while(0)\n#endif\n\n    CASE(OP_EQ) {\n      /* A B C  R(A) := R(A)==R(A+1) (Syms[B]=:==,C=1)*/\n      int a = GETARG_A(i);\n      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {\n        SET_TRUE_VALUE(regs[a]);\n      }\n      else {\n        OP_CMP(==);\n      }\n      NEXT;\n    }\n\n    CASE(OP_LT) {\n      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/\n      int a = GETARG_A(i);\n      OP_CMP(<);\n      NEXT;\n    }\n\n    CASE(OP_LE) {\n      /* A B C  R(A) := R(A)<=R(A+1) (Syms[B]=:<=,C=1)*/\n      int a = GETARG_A(i);\n      OP_CMP(<=);\n      NEXT;\n    }\n\n    CASE(OP_GT) {\n      /* A B C  R(A) := R(A)>R(A+1) (Syms[B]=:>,C=1)*/\n      int a = GETARG_A(i);\n      OP_CMP(>);\n      NEXT;\n    }\n\n    CASE(OP_GE) {\n      /* A B C  R(A) := R(A)>=R(A+1) (Syms[B]=:>=,C=1)*/\n      int a = GETARG_A(i);\n      OP_CMP(>=);\n      NEXT;\n    }\n\n    CASE(OP_ARRAY) {\n      /* A B C          R(A) := ary_new(R(B),R(B+1)..R(B+C)) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n      mrb_value v = mrb_ary_new_from_values(mrb, c, &regs[b]);\n      regs[a] = v;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ARYCAT) {\n      /* A B            mrb_ary_concat(R(A),R(B)) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      mrb_value splat = mrb_ary_splat(mrb, regs[b]);\n      mrb_ary_concat(mrb, regs[a], splat);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ARYPUSH) {\n      /* A B            R(A).push(R(B)) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      mrb_ary_push(mrb, regs[a], regs[b]);\n      NEXT;\n    }\n\n    CASE(OP_AREF) {\n      /* A B C          R(A) := R(B)[C] */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n      mrb_value v = regs[b];\n\n      if (!mrb_array_p(v)) {\n        if (c == 0) {\n          regs[a] = v;\n        }\n        else {\n          SET_NIL_VALUE(regs[a]);\n        }\n      }\n      else {\n        v = mrb_ary_ref(mrb, v, c);\n        regs[a] = v;\n      }\n      NEXT;\n    }\n\n    CASE(OP_ASET) {\n      /* A B C          R(B)[C] := R(A) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n      mrb_ary_set(mrb, regs[b], c, regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_APOST) {\n      /* A B C  *R(A),R(A+1)..R(A+C) := R(A) */\n      int a = GETARG_A(i);\n      mrb_value v = regs[a];\n      int pre  = GETARG_B(i);\n      int post = GETARG_C(i);\n      struct RArray *ary;\n      int len, idx;\n\n      if (!mrb_array_p(v)) {\n        v = mrb_ary_new_from_values(mrb, 1, &regs[a]);\n      }\n      ary = mrb_ary_ptr(v);\n      len = (int)ARY_LEN(ary);\n      if (len > pre + post) {\n        v = mrb_ary_new_from_values(mrb, len - pre - post, ARY_PTR(ary)+pre);\n        regs[a++] = v;\n        while (post--) {\n          regs[a++] = ARY_PTR(ary)[len-post-1];\n        }\n      }\n      else {\n        v = mrb_ary_new_capa(mrb, 0);\n        regs[a++] = v;\n        for (idx=0; idx+pre<len; idx++) {\n          regs[a+idx] = ARY_PTR(ary)[pre+idx];\n        }\n        while (idx < post) {\n          SET_NIL_VALUE(regs[a+idx]);\n          idx++;\n        }\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_STRING) {\n      /* A Bx           R(A) := str_new(Lit(Bx)) */\n      mrb_int a = GETARG_A(i);\n      mrb_int bx = GETARG_Bx(i);\n      mrb_value str = mrb_str_dup(mrb, pool[bx]);\n\n      regs[a] = str;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_STRCAT) {\n      /* A B    R(A).concat(R(B)) */\n      mrb_int a = GETARG_A(i);\n      mrb_int b = GETARG_B(i);\n\n      mrb_str_concat(mrb, regs[a], regs[b]);\n      NEXT;\n    }\n\n    CASE(OP_HASH) {\n      /* A B C   R(A) := hash_new(R(B),R(B+1)..R(B+C)) */\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n      int lim = b+c*2;\n      mrb_value hash = mrb_hash_new_capa(mrb, c);\n\n      while (b < lim) {\n        mrb_hash_set(mrb, hash, regs[b], regs[b+1]);\n        b+=2;\n      }\n      regs[GETARG_A(i)] = hash;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_LAMBDA) {\n      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */\n      struct RProc *p;\n      int a = GETARG_A(i);\n      int b = GETARG_b(i);\n      int c = GETARG_c(i);\n      mrb_irep *nirep = irep->reps[b];\n\n      if (c & OP_L_CAPTURE) {\n        p = mrb_closure_new(mrb, nirep);\n      }\n      else {\n        p = mrb_proc_new(mrb, nirep);\n        p->flags |= MRB_PROC_SCOPE;\n      }\n      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;\n      regs[a] = mrb_obj_value(p);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_OCLASS) {\n      /* A      R(A) := ::Object */\n      regs[GETARG_A(i)] = mrb_obj_value(mrb->object_class);\n      NEXT;\n    }\n\n    CASE(OP_CLASS) {\n      /* A B    R(A) := newclass(R(A),Syms(B),R(A+1)) */\n      struct RClass *c = 0, *baseclass;\n      int a = GETARG_A(i);\n      mrb_value base, super;\n      mrb_sym id = syms[GETARG_B(i)];\n\n      base = regs[a];\n      super = regs[a+1];\n      if (mrb_nil_p(base)) {\n        baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);\n        base = mrb_obj_value(baseclass);\n      }\n      c = mrb_vm_define_class(mrb, base, super, id);\n      regs[a] = mrb_obj_value(c);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_MODULE) {\n      /* A B            R(A) := newmodule(R(A),Syms(B)) */\n      struct RClass *c = 0, *baseclass;\n      int a = GETARG_A(i);\n      mrb_value base;\n      mrb_sym id = syms[GETARG_B(i)];\n\n      base = regs[a];\n      if (mrb_nil_p(base)) {\n        baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);\n        base = mrb_obj_value(baseclass);\n      }\n      c = mrb_vm_define_module(mrb, base, id);\n      regs[a] = mrb_obj_value(c);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_EXEC) {\n      /* A Bx   R(A) := blockexec(R(A),SEQ[Bx]) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_callinfo *ci;\n      mrb_value recv = regs[a];\n      struct RProc *p;\n      mrb_irep *nirep = irep->reps[bx];\n\n      /* prepare closure */\n      p = mrb_proc_new(mrb, nirep);\n      p->c = NULL;\n      mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)proc);\n      MRB_PROC_SET_TARGET_CLASS(p, mrb_class_ptr(recv));\n      p->flags |= MRB_PROC_SCOPE;\n\n      /* prepare call stack */\n      ci = cipush(mrb);\n      ci->pc = pc + 1;\n      ci->acc = a;\n      ci->mid = 0;\n      ci->stackent = mrb->c->stack;\n      ci->argc = 0;\n      ci->target_class = mrb_class_ptr(recv);\n\n      /* prepare stack */\n      mrb->c->stack += a;\n\n      /* setup block to call */\n      ci->proc = p;\n\n      irep = p->body.irep;\n      pool = irep->pool;\n      syms = irep->syms;\n      ci->nregs = irep->nregs;\n      stack_extend(mrb, ci->nregs);\n      stack_clear(regs+1, ci->nregs-1);\n      pc = irep->iseq;\n      JUMP;\n    }\n\n    CASE(OP_METHOD) {\n      /* A B            R(A).newmethod(Syms(B),R(A+1)) */\n      int a = GETARG_A(i);\n      struct RClass *c = mrb_class_ptr(regs[a]);\n      struct RProc *p = mrb_proc_ptr(regs[a+1]);\n      mrb_method_t m;\n\n      MRB_METHOD_FROM_PROC(m, p);\n      mrb_define_method_raw(mrb, c, syms[GETARG_B(i)], m);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_SCLASS) {\n      /* A B    R(A) := R(B).singleton_class */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n\n      regs[a] = mrb_singleton_class(mrb, regs[b]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_TCLASS) {\n      /* A      R(A) := target_class */\n      if (!mrb->c->ci->target_class) {\n        mrb_value exc = mrb_exc_new_str_lit(mrb, E_TYPE_ERROR, \"no target class or module\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      regs[GETARG_A(i)] = mrb_obj_value(mrb->c->ci->target_class);\n      NEXT;\n    }\n\n    CASE(OP_RANGE) {\n      /* A B C  R(A) := range_new(R(B),R(B+1),C) */\n      int b = GETARG_B(i);\n      mrb_value val = mrb_range_new(mrb, regs[b], regs[b+1], GETARG_C(i));\n      regs[GETARG_A(i)] = val;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_DEBUG) {\n      /* A B C    debug print R(A),R(B),R(C) */\n#ifdef MRB_ENABLE_DEBUG_HOOK\n      mrb->debug_op_hook(mrb, irep, pc, regs);\n#else\n#ifndef MRB_DISABLE_STDIO\n      printf(\"OP_DEBUG %d %d %d\\n\", GETARG_A(i), GETARG_B(i), GETARG_C(i));\n#else\n      abort();\n#endif\n#endif\n      NEXT;\n    }\n\n    CASE(OP_STOP) {\n      /*        stop VM */\n    L_STOP:\n      while (mrb->c->eidx > 0) {\n        ecall(mrb);\n      }\n      ERR_PC_CLR(mrb);\n      mrb->jmp = prev_jmp;\n      if (mrb->exc) {\n        return mrb_obj_value(mrb->exc);\n      }\n      return regs[irep->nlocals];\n    }\n\n    CASE(OP_ERR) {\n      /* Bx     raise RuntimeError with message Lit(Bx) */\n      mrb_value msg = mrb_str_dup(mrb, pool[GETARG_Bx(i)]);\n      mrb_value exc;\n\n      if (GETARG_A(i) == 0) {\n        exc = mrb_exc_new_str(mrb, E_RUNTIME_ERROR, msg);\n      }\n      else {\n        exc = mrb_exc_new_str(mrb, E_LOCALJUMP_ERROR, msg);\n      }\n      ERR_PC_SET(mrb, pc);\n      mrb_exc_set(mrb, exc);\n      goto L_RAISE;\n    }\n  }\n  END_DISPATCH;\n#undef regs\n\n  }\n  MRB_CATCH(&c_jmp) {\n    exc_catched = TRUE;\n    goto RETRY_TRY_BLOCK;\n  }\n  MRB_END_EXC(&c_jmp);\n}\n", "target": 1, "idx": 182428}
{"func": "status_t Parcel::readPointer(uintptr_t *pArg) const\n{\n status_t ret;\n binder_uintptr_t ptr;\n    ret = readAligned(&ptr);\n if (!ret)\n *pArg = ptr;\n return ret;\n}\n", "target": 0, "idx": 170481}
{"func": "static struct extent_map *create_pinned_em(struct inode *inode, u64 start,\n\t\t\t\t\t   u64 len, u64 orig_start,\n\t\t\t\t\t   u64 block_start, u64 block_len,\n\t\t\t\t\t   u64 orig_block_len, int type)\n{\n\tstruct extent_map_tree *em_tree;\n\tstruct extent_map *em;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tint ret;\n\n\tem_tree = &BTRFS_I(inode)->extent_tree;\n\tem = alloc_extent_map();\n\tif (!em)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tem->start = start;\n\tem->orig_start = orig_start;\n\tem->len = len;\n\tem->block_len = block_len;\n\tem->block_start = block_start;\n\tem->bdev = root->fs_info->fs_devices->latest_bdev;\n\tem->orig_block_len = orig_block_len;\n\tem->generation = -1;\n\tset_bit(EXTENT_FLAG_PINNED, &em->flags);\n\tif (type == BTRFS_ORDERED_PREALLOC)\n\t\tset_bit(EXTENT_FLAG_FILLING, &em->flags);\n\n\tdo {\n\t\tbtrfs_drop_extent_cache(inode, em->start,\n\t\t\t\tem->start + em->len - 1, 0);\n\t\twrite_lock(&em_tree->lock);\n\t\tret = add_extent_mapping(em_tree, em);\n\t\tif (!ret)\n\t\t\tlist_move(&em->list,\n\t\t\t\t  &em_tree->modified_extents);\n\t\twrite_unlock(&em_tree->lock);\n\t} while (ret == -EEXIST);\n\n\tif (ret) {\n\t\tfree_extent_map(em);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn em;\n}\n", "target": 0, "idx": 34376}
{"func": "void comps_mrtree_unite(COMPS_MRTree *rt1, COMPS_MRTree *rt2) {\n    COMPS_HSList *tmplist, *tmp_subnodes;\n    COMPS_HSListItem *it, *it2;\n     struct Pair {\n         COMPS_HSList * subnodes;\n         char * key;\n        char added;\n     } *pair, *parent_pair;\n \n     pair = malloc(sizeof(struct Pair));\n    pair->subnodes = rt2->subnodes;\n    pair->key = NULL;\n\n    tmplist = comps_hslist_create();\n    comps_hslist_init(tmplist, NULL, NULL, &free);\n    comps_hslist_append(tmplist, pair, 0);\n\n    while (tmplist->first != NULL) {\n        it = tmplist->first;\n        comps_hslist_remove(tmplist, tmplist->first);\n        tmp_subnodes = ((struct Pair*)it->data)->subnodes;\n         parent_pair = (struct Pair*) it->data;\n         free(it);\n \n        pair->added = 0;\n         for (it = tmp_subnodes->first; it != NULL; it=it->next) {\n             pair = malloc(sizeof(struct Pair));\n             pair->subnodes = ((COMPS_MRTreeData*)it->data)->subnodes;\n\n            if (parent_pair->key != NULL) {\n                pair->key =\n                    malloc(sizeof(char)\n                           * (strlen(((COMPS_MRTreeData*)it->data)->key)\n                           + strlen(parent_pair->key) + 1));\n                memcpy(pair->key, parent_pair->key,\n                       sizeof(char) * strlen(parent_pair->key));\n                memcpy(pair->key+strlen(parent_pair->key),\n                       ((COMPS_MRTreeData*)it->data)->key,\n                       sizeof(char)*(strlen(((COMPS_MRTreeData*)it->data)->key)+1));\n            } else {\n                pair->key = malloc(sizeof(char)*\n                                (strlen(((COMPS_MRTreeData*)it->data)->key) +\n                                1));\n                memcpy(pair->key, ((COMPS_MRTreeData*)it->data)->key,\n                       sizeof(char)*(strlen(((COMPS_MRTreeData*)it->data)->key)+1));\n            }\n            /* current node has data */\n            if (((COMPS_MRTreeData*)it->data)->data->first != NULL) {\n                for (it2 = ((COMPS_MRTreeData*)it->data)->data->first;\n                     it2 != NULL; it2 = it2->next) {\n                    comps_mrtree_set(rt1, pair->key, it2->data);\n                }\n\n                if (((COMPS_MRTreeData*)it->data)->subnodes->first) {\n                    comps_hslist_append(tmplist, pair, 0);\n                } else {\n                    free(pair->key);\n                    free(pair);\n                }\n            /* current node hasn't data */\n            } else {\n                if (((COMPS_MRTreeData*)it->data)->subnodes->first) {\n                    comps_hslist_append(tmplist, pair, 0);\n                } else {\n                    free(pair->key);\n                    free(pair);\n                }\n            }\n        }\n        free(parent_pair->key);\n        free(parent_pair);\n    }\n    comps_hslist_destroy(&tmplist);\n}\n", "target": 1, "idx": 182922}
{"func": "set_string_2_svc(sstring_arg *arg, struct svc_req *rqstp)\n {\n     static generic_ret              ret;\n     char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n     OM_uint32                       minor_stat;\n     kadm5_server_handle_t           handle;\n     const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (CHANGEPW_SERVICE(rqstp)\n        || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_MODIFY,\n                               arg->princ, NULL)) {\n        ret.code = KADM5_AUTH_MODIFY;\n        log_unauth(\"kadm5_mod_strings\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_set_string((void *)handle, arg->princ, arg->key,\n                                    arg->value);\n        if (ret.code != 0)\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_mod_strings\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n             krb5_free_error_message(handle->context, errmsg);\n     }\n     free(prime_arg);\n     gss_release_buffer(&minor_stat, &client_name);\n     gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n     free_server_handle(handle);\n     return &ret;\n }\n", "target": 1, "idx": 180696}
{"func": " void HttpAuthFilterWhitelist::SetWhitelist(\n     const std::string& server_whitelist) {\n  rules_.ParseFromString(server_whitelist);\n }\n", "target": 1, "idx": 186621}
{"func": " safecat_color_encoding(char *buffer, size_t bufsize, size_t pos,\n   PNG_CONST color_encoding *e, double encoding_gamma)\n {\n    if (e != 0)\n    {\n if (encoding_gamma != 0)\n         pos = safecat(buffer, bufsize, pos, \"(\");\n      pos = safecat(buffer, bufsize, pos, \"R(\");\n      pos = safecatd(buffer, bufsize, pos, e->red.X, 4);\n      pos = safecat(buffer, bufsize, pos, \",\");\n      pos = safecatd(buffer, bufsize, pos, e->red.Y, 4);\n      pos = safecat(buffer, bufsize, pos, \",\");\n      pos = safecatd(buffer, bufsize, pos, e->red.Z, 4);\n      pos = safecat(buffer, bufsize, pos, \"),G(\");\n      pos = safecatd(buffer, bufsize, pos, e->green.X, 4);\n      pos = safecat(buffer, bufsize, pos, \",\");\n      pos = safecatd(buffer, bufsize, pos, e->green.Y, 4);\n      pos = safecat(buffer, bufsize, pos, \",\");\n      pos = safecatd(buffer, bufsize, pos, e->green.Z, 4);\n      pos = safecat(buffer, bufsize, pos, \"),B(\");\n      pos = safecatd(buffer, bufsize, pos, e->blue.X, 4);\n      pos = safecat(buffer, bufsize, pos, \",\");\n      pos = safecatd(buffer, bufsize, pos, e->blue.Y, 4);\n      pos = safecat(buffer, bufsize, pos, \",\");\n      pos = safecatd(buffer, bufsize, pos, e->blue.Z, 4);\n      pos = safecat(buffer, bufsize, pos, \")\");\n if (encoding_gamma != 0)\n         pos = safecat(buffer, bufsize, pos, \")\");\n }\n\n if (encoding_gamma != 0)\n {\n      pos = safecat(buffer, bufsize, pos, \"^\");\n      pos = safecatd(buffer, bufsize, pos, encoding_gamma, 5);\n }\n\n \n    return pos;\n }\n", "target": 1, "idx": 187712}
{"func": "mm_sshpam_init_ctx(Authctxt *authctxt)\n{\n\tBuffer m;\n\tint success;\n \n \tdebug3(\"%s\", __func__);\n \tbuffer_init(&m);\n\tbuffer_put_cstring(&m, authctxt->user);\n \tmm_request_send(pmonitor->m_recvfd, MONITOR_REQ_PAM_INIT_CTX, &m);\n \tdebug3(\"%s: waiting for MONITOR_ANS_PAM_INIT_CTX\", __func__);\n \tmm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_PAM_INIT_CTX, &m);\n\tsuccess = buffer_get_int(&m);\n\tif (success == 0) {\n\t\tdebug3(\"%s: pam_init_ctx failed\", __func__);\n\t\tbuffer_free(&m);\n\t\treturn (NULL);\n\t}\n\tbuffer_free(&m);\n\treturn (authctxt);\n}\n", "target": 1, "idx": 179758}
{"func": "bgp_nlri_parse_vpnv4 (struct peer *peer, struct attr *attr, \n\t\t      struct bgp_nlri *packet)\n{\n  u_char *pnt;\n  u_char *lim;\n  struct prefix p;\n  int psize;\n  int prefixlen;\n  u_int16_t type;\n  struct rd_as rd_as;\n  struct rd_ip rd_ip;\n  struct prefix_rd prd;\n  u_char *tagpnt;\n\n  /* Check peer status. */\n  if (peer->status != Established)\n    return 0;\n  \n  /* Make prefix_rd */\n  prd.family = AF_UNSPEC;\n  prd.prefixlen = 64;\n\n   pnt = packet->nlri;\n   lim = pnt + packet->length;\n \n   for (; pnt < lim; pnt += psize)\n     {\n       /* Clear prefix structure. */\n\n \n       /* Fetch prefix length. */\n       prefixlen = *pnt++;\n      p.family = AF_INET;\n       psize = PSIZE (prefixlen);\n      if (prefixlen < 88)\n\t{\n\t  zlog_err (\"prefix length is less than 88: %d\", prefixlen);\n\t  return -1;\n\t}\n       /* Copyr label to prefix. */\n      tagpnt = pnt;;\n \n       /* Copy routing distinguisher to rd. */\n       memcpy (&prd.val, pnt + 3, 8);\n      else if (type == RD_TYPE_IP)\n\tzlog_info (\"prefix %ld:%s:%ld:%s/%d\", label, inet_ntoa (rd_ip.ip),\n\t\t   rd_ip.val, inet_ntoa (p.u.prefix4), p.prefixlen);\n#endif /* 0 */\n\n      if (pnt + psize > lim)\n\treturn -1;\n\n      if (attr)\n\tbgp_update (peer, &p, attr, AFI_IP, SAFI_MPLS_VPN,\n\t\t    ZEBRA_ROUTE_BGP, BGP_ROUTE_NORMAL, &prd, tagpnt, 0);\n      else\n \t  return -1;\n \t}\n \n      p.prefixlen = prefixlen - 88;\n      memcpy (&p.u.prefix, pnt + 11, psize - 11);\n \n #if 0\n       if (type == RD_TYPE_AS)\n}\n", "target": 1, "idx": 178361}
{"func": "void ieee80211_sta_expire(struct ieee80211_sub_if_data *sdata,\n\t\t\t  unsigned long exp_time)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sta_info *sta, *tmp;\n\n\tmutex_lock(&local->sta_mtx);\n\n\tlist_for_each_entry_safe(sta, tmp, &local->sta_list, list) {\n\t\tif (sdata != sta->sdata)\n\t\t\tcontinue;\n\n\t\tif (time_after(jiffies, sta->last_rx + exp_time)) {\n\t\t\tsta_dbg(sta->sdata, \"expiring inactive STA %pM\\n\",\n\t\t\t\tsta->sta.addr);\n\n\t\t\tif (ieee80211_vif_is_mesh(&sdata->vif) &&\n\t\t\t    test_sta_flag(sta, WLAN_STA_PS_STA))\n\t\t\t\tatomic_dec(&sdata->u.mesh.ps.num_sta_ps);\n\n\t\t\tWARN_ON(__sta_info_destroy(sta));\n\t\t}\n\t}\n\n\tmutex_unlock(&local->sta_mtx);\n}\n", "target": 0, "idx": 38577}
{"func": "int ipc_addid(struct ipc_ids *ids, struct kern_ipc_perm *new, int size)\n{\n\tkuid_t euid;\n\tkgid_t egid;\n\tint id;\n\tint next_id = ids->next_id;\n\n\tif (size > IPCMNI)\n\t\tsize = IPCMNI;\n\n\tif (ids->in_use >= size)\n\t\treturn -ENOSPC;\n\n\tidr_preload(GFP_KERNEL);\n\n\tspin_lock_init(&new->lock);\n\tnew->deleted = false;\n \trcu_read_lock();\n \tspin_lock(&new->lock);\n \n \tid = idr_alloc(&ids->ipcs_idr, new,\n \t\t       (next_id < 0) ? 0 : ipcid_to_idx(next_id), 0,\n \t\t       GFP_NOWAIT);\n\tidr_preload_end();\n\tif (id < 0) {\n\t\tspin_unlock(&new->lock);\n\t\trcu_read_unlock();\n\t\treturn id;\n\t}\n \n \tids->in_use++;\n \n\tcurrent_euid_egid(&euid, &egid);\n\tnew->cuid = new->uid = euid;\n\tnew->gid = new->cgid = egid;\n \tif (next_id < 0) {\n \t\tnew->seq = ids->seq++;\n \t\tif (ids->seq > IPCID_SEQ_MAX)\n\t\t\tids->seq = 0;\n\t} else {\n\t\tnew->seq = ipcid_to_seqx(next_id);\n\t\tids->next_id = -1;\n\t}\n\n\tnew->id = ipc_buildid(id, new->seq);\n\treturn id;\n}\n", "target": 1, "idx": 179752}
{"func": "gplotAddPlot(GPLOT       *gplot,\n             NUMA        *nax,\n             NUMA        *nay,\n              l_int32      plotstyle,\n              const char  *plottitle)\n {\nchar       buf[L_BUF_SIZE];\n char       emptystring[] = \"\";\n char      *datastr, *title;\n l_int32    n, i;\nl_float32  valx, valy, startx, delx;\nSARRAY    *sa;\n\n    PROCNAME(\"gplotAddPlot\");\n\n    if (!gplot)\n        return ERROR_INT(\"gplot not defined\", procName, 1);\n    if (!nay)\n        return ERROR_INT(\"nay not defined\", procName, 1);\n    if (plotstyle < 0 || plotstyle >= NUM_GPLOT_STYLES)\n        return ERROR_INT(\"invalid plotstyle\", procName, 1);\n\n    if ((n = numaGetCount(nay)) == 0)\n        return ERROR_INT(\"no points to plot\", procName, 1);\n    if (nax && (n != numaGetCount(nax)))\n        return ERROR_INT(\"nax and nay sizes differ\", procName, 1);\n    if (n == 1 && plotstyle == GPLOT_LINES) {\n        L_INFO(\"only 1 pt; changing style to points\\n\", procName);\n        plotstyle = GPLOT_POINTS;\n    }\n\n        /* Save plotstyle and plottitle */\n    numaGetParameters(nay, &startx, &delx);\n    numaAddNumber(gplot->plotstyles, plotstyle);\n    if (plottitle) {\n        title = stringNew(plottitle);\n        sarrayAddString(gplot->plottitles, title, L_INSERT);\n    } else {\n        sarrayAddString(gplot->plottitles, emptystring, L_COPY);\n    }\n \n         /* Generate and save data filename */\n     gplot->nplots++;\n    snprintf(buf, L_BUF_SIZE, \"%s.data.%d\", gplot->rootname, gplot->nplots);\n     sarrayAddString(gplot->datanames, buf, L_COPY);\n \n         /* Generate data and save as a string */\n    sa = sarrayCreate(n);\n    for (i = 0; i < n; i++) {\n        if (nax)\n            numaGetFValue(nax, i, &valx);\n         else\n             valx = startx + i * delx;\n         numaGetFValue(nay, i, &valy);\n        snprintf(buf, L_BUF_SIZE, \"%f %f\\n\", valx, valy);\n         sarrayAddString(sa, buf, L_COPY);\n     }\n     datastr = sarrayToString(sa, 0);\n    sarrayAddString(gplot->plotdata, datastr, L_INSERT);\n    sarrayDestroy(&sa);\n\n    return 0;\n}\n", "target": 1, "idx": 182495}
{"func": " void ServiceWorkerPaymentInstrument::OnPaymentAppInvoked(\n     mojom::PaymentHandlerResponsePtr response) {\n  DCHECK(delegate_);\n   if (delegate_ != nullptr) {\n     delegate_->OnInstrumentDetailsReady(response->method_name,\n                                         response->stringified_details);\n    delegate_ = nullptr;\n  }\n}\n", "target": 1, "idx": 186942}
{"func": "static int __rds_rdma_map(struct rds_sock *rs, struct rds_get_mr_args *args,\n\t\t\t\tu64 *cookie_ret, struct rds_mr **mr_ret)\n{\n\tstruct rds_mr *mr = NULL, *found;\n\tunsigned int nr_pages;\n\tstruct page **pages = NULL;\n\tstruct scatterlist *sg;\n\tvoid *trans_private;\n\tunsigned long flags;\n\trds_rdma_cookie_t cookie;\n\tunsigned int nents;\n \tlong i;\n \tint ret;\n \n\tif (rs->rs_bound_addr == 0) {\n \t\tret = -ENOTCONN; /* XXX not a great errno */\n \t\tgoto out;\n \t}\n\n\tif (!rs->rs_transport->get_mr) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tnr_pages = rds_pages_in_vec(&args->vec);\n\tif (nr_pages == 0) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* Restrict the size of mr irrespective of underlying transport\n\t * To account for unaligned mr regions, subtract one from nr_pages\n\t */\n\tif ((nr_pages - 1) > (RDS_MAX_MSG_SIZE >> PAGE_SHIFT)) {\n\t\tret = -EMSGSIZE;\n\t\tgoto out;\n\t}\n\n\trdsdebug(\"RDS: get_mr addr %llx len %llu nr_pages %u\\n\",\n\t\targs->vec.addr, args->vec.bytes, nr_pages);\n\n\t/* XXX clamp nr_pages to limit the size of this alloc? */\n\tpages = kcalloc(nr_pages, sizeof(struct page *), GFP_KERNEL);\n\tif (!pages) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmr = kzalloc(sizeof(struct rds_mr), GFP_KERNEL);\n\tif (!mr) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\trefcount_set(&mr->r_refcount, 1);\n\tRB_CLEAR_NODE(&mr->r_rb_node);\n\tmr->r_trans = rs->rs_transport;\n\tmr->r_sock = rs;\n\n\tif (args->flags & RDS_RDMA_USE_ONCE)\n\t\tmr->r_use_once = 1;\n\tif (args->flags & RDS_RDMA_INVALIDATE)\n\t\tmr->r_invalidate = 1;\n\tif (args->flags & RDS_RDMA_READWRITE)\n\t\tmr->r_write = 1;\n\n\t/*\n\t * Pin the pages that make up the user buffer and transfer the page\n\t * pointers to the mr's sg array.  We check to see if we've mapped\n\t * the whole region after transferring the partial page references\n\t * to the sg array so that we can have one page ref cleanup path.\n\t *\n\t * For now we have no flag that tells us whether the mapping is\n\t * r/o or r/w. We need to assume r/w, or we'll do a lot of RDMA to\n\t * the zero page.\n\t */\n\tret = rds_pin_pages(args->vec.addr, nr_pages, pages, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tnents = ret;\n\tsg = kcalloc(nents, sizeof(*sg), GFP_KERNEL);\n\tif (!sg) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tWARN_ON(!nents);\n\tsg_init_table(sg, nents);\n\n\t/* Stick all pages into the scatterlist */\n\tfor (i = 0 ; i < nents; i++)\n\t\tsg_set_page(&sg[i], pages[i], PAGE_SIZE, 0);\n\n\trdsdebug(\"RDS: trans_private nents is %u\\n\", nents);\n\n\t/* Obtain a transport specific MR. If this succeeds, the\n\t * s/g list is now owned by the MR.\n\t * Note that dma_map() implies that pending writes are\n\t * flushed to RAM, so no dma_sync is needed here. */\n\ttrans_private = rs->rs_transport->get_mr(sg, nents, rs,\n\t\t\t\t\t\t &mr->r_key);\n\n\tif (IS_ERR(trans_private)) {\n\t\tfor (i = 0 ; i < nents; i++)\n\t\t\tput_page(sg_page(&sg[i]));\n\t\tkfree(sg);\n\t\tret = PTR_ERR(trans_private);\n\t\tgoto out;\n\t}\n\n\tmr->r_trans_private = trans_private;\n\n\trdsdebug(\"RDS: get_mr put_user key is %x cookie_addr %p\\n\",\n\t       mr->r_key, (void *)(unsigned long) args->cookie_addr);\n\n\t/* The user may pass us an unaligned address, but we can only\n\t * map page aligned regions. So we keep the offset, and build\n\t * a 64bit cookie containing <R_Key, offset> and pass that\n\t * around. */\n\tcookie = rds_rdma_make_cookie(mr->r_key, args->vec.addr & ~PAGE_MASK);\n\tif (cookie_ret)\n\t\t*cookie_ret = cookie;\n\n\tif (args->cookie_addr && put_user(cookie, (u64 __user *)(unsigned long) args->cookie_addr)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\t/* Inserting the new MR into the rbtree bumps its\n\t * reference count. */\n\tspin_lock_irqsave(&rs->rs_rdma_lock, flags);\n\tfound = rds_mr_tree_walk(&rs->rs_rdma_keys, mr->r_key, mr);\n\tspin_unlock_irqrestore(&rs->rs_rdma_lock, flags);\n\n\tBUG_ON(found && found != mr);\n\n\trdsdebug(\"RDS: get_mr key is %x\\n\", mr->r_key);\n\tif (mr_ret) {\n\t\trefcount_inc(&mr->r_refcount);\n\t\t*mr_ret = mr;\n\t}\n\n\tret = 0;\nout:\n\tkfree(pages);\n\tif (mr)\n\t\trds_mr_put(mr);\n\treturn ret;\n}\n", "target": 1, "idx": 182481}
{"func": " php_http_url_t *php_http_url_parse(const char *str, size_t len, unsigned flags TSRMLS_DC)\n {\n\tsize_t maxlen = 3 * len;\n \tstruct parse_state *state = ecalloc(1, sizeof(*state) + maxlen);\n \n \tstate->end = str + len;\n\tstate->ptr = str;\n\tstate->flags = flags;\n\tstate->maxlen = maxlen;\n\tTSRMLS_SET_CTX(state->ts);\n\n\tif (!parse_scheme(state)) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Failed to parse URL scheme: '%s'\", state->ptr);\n\t\tefree(state);\n\t\treturn NULL;\n\t}\n\n\tif (!parse_hier(state)) {\n\t\tefree(state);\n\t\treturn NULL;\n\t}\n\n\tif (!parse_query(state)) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Failed to parse URL query: '%s'\", state->ptr);\n\t\tefree(state);\n\t\treturn NULL;\n\t}\n\n\tif (!parse_fragment(state)) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Failed to parse URL fragment: '%s'\", state->ptr);\n\t\tefree(state);\n\t\treturn NULL;\n\t}\n\n\treturn (php_http_url_t *) state;\n}\n", "target": 1, "idx": 182006}
{"func": "static int ocfs2_dio_get_block(struct inode *inode, sector_t iblock,\n \t\t\t       struct buffer_head *bh_result, int create)\n {\n \tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_write_ctxt *wc;\n\tstruct ocfs2_write_cluster_desc *desc = NULL;\n\tstruct ocfs2_dio_write_ctxt *dwc = NULL;\n\tstruct buffer_head *di_bh = NULL;\n\tu64 p_blkno;\n\tloff_t pos = iblock << inode->i_sb->s_blocksize_bits;\n\tunsigned len, total_len = bh_result->b_size;\n\tint ret = 0, first_get_block = 0;\n\n\tlen = osb->s_clustersize - (pos & (osb->s_clustersize - 1));\n\tlen = min(total_len, len);\n\n\tmlog(0, \"get block of %lu at %llu:%u req %u\\n\",\n\t\t\tinode->i_ino, pos, len, total_len);\n\n\t/*\n\t * Because we need to change file size in ocfs2_dio_end_io_write(), or\n\t * we may need to add it to orphan dir. So can not fall to fast path\n \t * while file size will be changed.\n \t */\n \tif (pos + total_len <= i_size_read(inode)) {\n\t\tdown_read(&oi->ip_alloc_sem);\n\t\t/* This is the fast path for re-write. */\n\t\tret = ocfs2_get_block(inode, iblock, bh_result, create);\n\t\tup_read(&oi->ip_alloc_sem);\n \n \t\tif (buffer_mapped(bh_result) &&\n \t\t    !buffer_new(bh_result) &&\n \t\t    ret == 0)\n\t\t\tgoto out;\n\n\t\t/* Clear state set by ocfs2_get_block. */\n\t\tbh_result->b_state = 0;\n\t}\n\n\tdwc = ocfs2_dio_alloc_write_ctx(bh_result, &first_get_block);\n\tif (unlikely(dwc == NULL)) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (ocfs2_clusters_for_bytes(inode->i_sb, pos + total_len) >\n\t    ocfs2_clusters_for_bytes(inode->i_sb, i_size_read(inode)) &&\n\t    !dwc->dw_orphaned) {\n\t\t/*\n\t\t * when we are going to alloc extents beyond file size, add the\n\t\t * inode to orphan dir, so we can recall those spaces when\n\t\t * system crashed during write.\n\t\t */\n\t\tret = ocfs2_add_inode_to_orphan(osb, inode);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tdwc->dw_orphaned = 1;\n\t}\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdown_write(&oi->ip_alloc_sem);\n\n\tif (first_get_block) {\n\t\tif (ocfs2_sparse_alloc(OCFS2_SB(inode->i_sb)))\n\t\t\tret = ocfs2_zero_tail(inode, di_bh, pos);\n\t\telse\n\t\t\tret = ocfs2_expand_nonsparse_inode(inode, di_bh, pos,\n\t\t\t\t\t\t\t   total_len, NULL);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tret = ocfs2_write_begin_nolock(inode->i_mapping, pos, len,\n\t\t\t\t       OCFS2_WRITE_DIRECT, NULL,\n\t\t\t\t       (void **)&wc, di_bh, NULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto unlock;\n\t}\n\n\tdesc = &wc->w_desc[0];\n\n\tp_blkno = ocfs2_clusters_to_blocks(inode->i_sb, desc->c_phys);\n\tBUG_ON(p_blkno == 0);\n\tp_blkno += iblock & (u64)(ocfs2_clusters_to_blocks(inode->i_sb, 1) - 1);\n\n\tmap_bh(bh_result, inode->i_sb, p_blkno);\n\tbh_result->b_size = len;\n\tif (desc->c_needs_zero)\n\t\tset_buffer_new(bh_result);\n\n\t/* May sleep in end_io. It should not happen in a irq context. So defer\n\t * it to dio work queue. */\n\tset_buffer_defer_completion(bh_result);\n\n\tif (!list_empty(&wc->w_unwritten_list)) {\n\t\tstruct ocfs2_unwritten_extent *ue = NULL;\n\n\t\tue = list_first_entry(&wc->w_unwritten_list,\n\t\t\t\t      struct ocfs2_unwritten_extent,\n\t\t\t\t      ue_node);\n\t\tBUG_ON(ue->ue_cpos != desc->c_cpos);\n\t\t/* The physical address may be 0, fill it. */\n\t\tue->ue_phys = desc->c_phys;\n\n\t\tlist_splice_tail_init(&wc->w_unwritten_list, &dwc->dw_zero_list);\n\t\tdwc->dw_zero_count++;\n\t}\n\n\tret = ocfs2_write_end_nolock(inode->i_mapping, pos, len, len, wc);\n\tBUG_ON(ret != len);\n\tret = 0;\nunlock:\n\tup_write(&oi->ip_alloc_sem);\n\tocfs2_inode_unlock(inode, 1);\n\tbrelse(di_bh);\nout:\n\tif (ret < 0)\n\t\tret = -EIO;\n\treturn ret;\n}\n", "target": 1, "idx": 182568}
{"func": "static UINT drdynvc_order_recv(drdynvcPlugin* drdynvc, wStream* s)\n{\n\tint value;\n \tint Cmd;\n \tint Sp;\n \tint cbChId;\n \tStream_Read_UINT8(s, value);\n \tCmd = (value & 0xf0) >> 4;\n \tSp = (value & 0x0c) >> 2;\n\tcbChId = (value & 0x03) >> 0;\n\tWLog_Print(drdynvc->log, WLOG_DEBUG, \"order_recv: Cmd=0x%x, Sp=%d cbChId=%d\", Cmd, Sp, cbChId);\n\n\tswitch (Cmd)\n\t{\n\t\tcase CAPABILITY_REQUEST_PDU:\n\t\t\treturn drdynvc_process_capability_request(drdynvc, Sp, cbChId, s);\n\n\t\tcase CREATE_REQUEST_PDU:\n\t\t\treturn drdynvc_process_create_request(drdynvc, Sp, cbChId, s);\n\n\t\tcase DATA_FIRST_PDU:\n\t\t\treturn drdynvc_process_data_first(drdynvc, Sp, cbChId, s);\n\n\t\tcase DATA_PDU:\n\t\t\treturn drdynvc_process_data(drdynvc, Sp, cbChId, s);\n\n\t\tcase CLOSE_REQUEST_PDU:\n\t\t\treturn drdynvc_process_close_request(drdynvc, Sp, cbChId, s);\n\n\t\tdefault:\n\t\t\tWLog_Print(drdynvc->log, WLOG_ERROR, \"unknown drdynvc cmd 0x%x\", Cmd);\n\t\t\treturn ERROR_INTERNAL_ERROR;\n\t}\n}\n", "target": 1, "idx": 182105}
{"func": "raptor_rdfxml_comment_handler(void *user_data, raptor_xml_element* xml_element,\n                              const unsigned char *s)\n{\n  raptor_parser* rdf_parser = (raptor_parser*)user_data;\n  raptor_rdfxml_parser* rdf_xml_parser;\n  raptor_rdfxml_element* element;\n\n  if(rdf_parser->failed || !xml_element)\n    return;\n\n  rdf_xml_parser = (raptor_rdfxml_parser*)rdf_parser->context;\n  element = rdf_xml_parser->current_element;\n\n  if(element) {\n    if(element->child_content_type == RAPTOR_RDFXML_ELEMENT_CONTENT_TYPE_XML_LITERAL)\n      raptor_xml_writer_comment(rdf_xml_parser->xml_writer, s);\n  }\n  \n\n#ifdef RAPTOR_DEBUG_VERBOSE\n  RAPTOR_DEBUG2(\"XML Comment '%s'\\n\", s);\n#endif\n}\n", "target": 0, "idx": 22005}
{"func": "void V8TestObject::DoubleAttributeAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), \"Blink_TestObject_doubleAttribute_Getter\");\n\n  test_object_v8_internal::DoubleAttributeAttributeGetter(info);\n}\n", "target": 0, "idx": 147362}
{"func": "Init_ossl_cipher(void)\n{\n#if 0\n    mOSSL = rb_define_module(\"OpenSSL\");\n    eOSSLError = rb_define_class_under(mOSSL, \"OpenSSLError\", rb_eStandardError);\n#endif\n\n    /* Document-class: OpenSSL::Cipher\n     *\n     * Provides symmetric algorithms for encryption and decryption. The\n     * algorithms that are available depend on the particular version\n     * of OpenSSL that is installed.\n     *\n     * === Listing all supported algorithms\n     *\n     * A list of supported algorithms can be obtained by\n     *\n     *   puts OpenSSL::Cipher.ciphers\n     *\n     * === Instantiating a Cipher\n     *\n     * There are several ways to create a Cipher instance. Generally, a\n     * Cipher algorithm is categorized by its name, the key length in bits\n     * and the cipher mode to be used. The most generic way to create a\n     * Cipher is the following\n     *\n     *   cipher = OpenSSL::Cipher.new('<name>-<key length>-<mode>')\n     *\n     * That is, a string consisting of the hyphenated concatenation of the\n     * individual components name, key length and mode. Either all uppercase\n     * or all lowercase strings may be used, for example:\n     *\n     *  cipher = OpenSSL::Cipher.new('AES-128-CBC')\n     *\n     * For each algorithm supported, there is a class defined under the\n     * Cipher class that goes by the name of the cipher, e.g. to obtain an\n     * instance of AES, you could also use\n     *\n     *   # these are equivalent\n     *   cipher = OpenSSL::Cipher::AES.new(128, :CBC)\n     *   cipher = OpenSSL::Cipher::AES.new(128, 'CBC')\n     *   cipher = OpenSSL::Cipher::AES.new('128-CBC')\n     *\n     * Finally, due to its wide-spread use, there are also extra classes\n     * defined for the different key sizes of AES\n     *\n     *   cipher = OpenSSL::Cipher::AES128.new(:CBC)\n     *   cipher = OpenSSL::Cipher::AES192.new(:CBC)\n     *   cipher = OpenSSL::Cipher::AES256.new(:CBC)\n     *\n     * === Choosing either encryption or decryption mode\n     *\n     * Encryption and decryption are often very similar operations for\n     * symmetric algorithms, this is reflected by not having to choose\n     * different classes for either operation, both can be done using the\n     * same class. Still, after obtaining a Cipher instance, we need to\n     * tell the instance what it is that we intend to do with it, so we\n     * need to call either\n     *\n     *   cipher.encrypt\n     *\n     * or\n     *\n     *   cipher.decrypt\n     *\n     * on the Cipher instance. This should be the first call after creating\n     * the instance, otherwise configuration that has already been set could\n     * get lost in the process.\n     *\n     * === Choosing a key\n     *\n     * Symmetric encryption requires a key that is the same for the encrypting\n     * and for the decrypting party and after initial key establishment should\n     * be kept as private information. There are a lot of ways to create\n     * insecure keys, the most notable is to simply take a password as the key\n     * without processing the password further. A simple and secure way to\n     * create a key for a particular Cipher is\n     *\n     *  cipher = OpenSSL::AES256.new(:CFB)\n     *  cipher.encrypt\n     *  key = cipher.random_key # also sets the generated key on the Cipher\n     *\n     * If you absolutely need to use passwords as encryption keys, you\n     * should use Password-Based Key Derivation Function 2 (PBKDF2) by\n     * generating the key with the help of the functionality provided by\n     * OpenSSL::PKCS5.pbkdf2_hmac_sha1 or OpenSSL::PKCS5.pbkdf2_hmac.\n     *\n     * Although there is Cipher#pkcs5_keyivgen, its use is deprecated and\n     * it should only be used in legacy applications because it does not use\n     * the newer PKCS#5 v2 algorithms.\n     *\n     * === Choosing an IV\n     *\n     * The cipher modes CBC, CFB, OFB and CTR all need an \"initialization\n     * vector\", or short, IV. ECB mode is the only mode that does not require\n     * an IV, but there is almost no legitimate use case for this mode\n     * because of the fact that it does not sufficiently hide plaintext\n     * patterns. Therefore\n     *\n     * <b>You should never use ECB mode unless you are absolutely sure that\n     * you absolutely need it</b>\n     *\n     * Because of this, you will end up with a mode that explicitly requires\n     * an IV in any case. Note that for backwards compatibility reasons,\n     * setting an IV is not explicitly mandated by the Cipher API. If not\n     * set, OpenSSL itself defaults to an all-zeroes IV (\"\\\\0\", not the\n     * character). Although the IV can be seen as public information, i.e.\n     * it may be transmitted in public once generated, it should still stay\n     * unpredictable to prevent certain kinds of attacks. Therefore, ideally\n     *\n     * <b>Always create a secure random IV for every encryption of your\n     * Cipher</b>\n     *\n     * A new, random IV should be created for every encryption of data. Think\n     * of the IV as a nonce (number used once) - it's public but random and\n     * unpredictable. A secure random IV can be created as follows\n     *\n     *   cipher = ...\n     *   cipher.encrypt\n     *   key = cipher.random_key\n     *   iv = cipher.random_iv # also sets the generated IV on the Cipher\n     *\n     * Although the key is generally a random value, too, it is a bad choice\n     * as an IV. There are elaborate ways how an attacker can take advantage\n     * of such an IV. As a general rule of thumb, exposing the key directly\n     * or indirectly should be avoided at all cost and exceptions only be\n     * made with good reason.\n     *\n     * === Calling Cipher#final\n     *\n     * ECB (which should not be used) and CBC are both block-based modes.\n     * This means that unlike for the other streaming-based modes, they\n     * operate on fixed-size blocks of data, and therefore they require a\n     * \"finalization\" step to produce or correctly decrypt the last block of\n     * data by appropriately handling some form of padding. Therefore it is\n     * essential to add the output of OpenSSL::Cipher#final to your\n     * encryption/decryption buffer or you will end up with decryption errors\n     * or truncated data.\n     *\n     * Although this is not really necessary for streaming-mode ciphers, it is\n     * still recommended to apply the same pattern of adding the output of\n     * Cipher#final there as well - it also enables you to switch between\n     * modes more easily in the future.\n     *\n     * === Encrypting and decrypting some data\n     *\n     *   data = \"Very, very confidential data\"\n     *\n     *   cipher = OpenSSL::Cipher::AES.new(128, :CBC)\n     *   cipher.encrypt\n     *   key = cipher.random_key\n     *   iv = cipher.random_iv\n     *\n     *   encrypted = cipher.update(data) + cipher.final\n     *   ...\n     *   decipher = OpenSSL::Cipher::AES.new(128, :CBC)\n     *   decipher.decrypt\n     *   decipher.key = key\n     *   decipher.iv = iv\n     *\n     *   plain = decipher.update(encrypted) + decipher.final\n     *\n     *   puts data == plain #=> true\n     *\n     * === Authenticated Encryption and Associated Data (AEAD)\n     *\n     * If the OpenSSL version used supports it, an Authenticated Encryption\n     * mode (such as GCM or CCM) should always be preferred over any\n     * unauthenticated mode. Currently, OpenSSL supports AE only in combination\n     * with Associated Data (AEAD) where additional associated data is included\n     * in the encryption process to compute a tag at the end of the encryption.\n     * This tag will also be used in the decryption process and by verifying\n     * its validity, the authenticity of a given ciphertext is established.\n     *\n     * This is superior to unauthenticated modes in that it allows to detect\n     * if somebody effectively changed the ciphertext after it had been\n     * encrypted. This prevents malicious modifications of the ciphertext that\n     * could otherwise be exploited to modify ciphertexts in ways beneficial to\n     * potential attackers.\n     *\n     * An associated data is used where there is additional information, such as\n     * headers or some metadata, that must be also authenticated but not\n     * necessarily need to be encrypted. If no associated data is needed for\n     * encryption and later decryption, the OpenSSL library still requires a\n     * value to be set - \"\" may be used in case none is available.\n     *\n     * An example using the GCM (Galois/Counter Mode). You have 16 bytes +key+,\n     * 12 bytes (96 bits) +nonce+ and the associated data +auth_data+. Be sure\n     * not to reuse the +key+ and +nonce+ pair. Reusing an nonce ruins the\n     * security gurantees of GCM mode.\n     *\n     *   cipher = OpenSSL::Cipher::AES.new(128, :GCM).encrypt\n     *   cipher.key = key\n     *   cipher.iv = nonce\n     *   cipher.auth_data = auth_data\n     *\n     *   encrypted = cipher.update(data) + cipher.final\n     *   tag = cipher.auth_tag # produces 16 bytes tag by default\n     *\n     * Now you are the receiver. You know the +key+ and have received +nonce+,\n     * +auth_data+, +encrypted+ and +tag+ through an untrusted network. Note\n     * that GCM accepts an arbitrary length tag between 1 and 16 bytes. You may\n     * additionally need to check that the received tag has the correct length,\n     * or you allow attackers to forge a valid single byte tag for the tampered\n     * ciphertext with a probability of 1/256.\n     *\n     *   raise \"tag is truncated!\" unless tag.bytesize == 16\n     *   decipher = OpenSSL::Cipher::AES.new(128, :GCM).decrypt\n     *   decipher.key = key\n     *   decipher.iv = nonce\n     *   decipher.auth_tag = tag\n     *   decipher.auth_data = auth_data\n     *\n     *   decrypted = decipher.update(encrypted) + decipher.final\n     *\n     *   puts data == decrypted #=> true\n     */\n    cCipher = rb_define_class_under(mOSSL, \"Cipher\", rb_cObject);\n    eCipherError = rb_define_class_under(cCipher, \"CipherError\", eOSSLError);\n\n    rb_define_alloc_func(cCipher, ossl_cipher_alloc);\n    rb_define_copy_func(cCipher, ossl_cipher_copy);\n    rb_define_module_function(cCipher, \"ciphers\", ossl_s_ciphers, 0);\n    rb_define_method(cCipher, \"initialize\", ossl_cipher_initialize, 1);\n    rb_define_method(cCipher, \"reset\", ossl_cipher_reset, 0);\n    rb_define_method(cCipher, \"encrypt\", ossl_cipher_encrypt, -1);\n    rb_define_method(cCipher, \"decrypt\", ossl_cipher_decrypt, -1);\n    rb_define_method(cCipher, \"pkcs5_keyivgen\", ossl_cipher_pkcs5_keyivgen, -1);\n    rb_define_method(cCipher, \"update\", ossl_cipher_update, -1);\n    rb_define_method(cCipher, \"final\", ossl_cipher_final, 0);\n    rb_define_method(cCipher, \"name\", ossl_cipher_name, 0);\n    rb_define_method(cCipher, \"key=\", ossl_cipher_set_key, 1);\n    rb_define_method(cCipher, \"auth_data=\", ossl_cipher_set_auth_data, 1);\n    rb_define_method(cCipher, \"auth_tag=\", ossl_cipher_set_auth_tag, 1);\n    rb_define_method(cCipher, \"auth_tag\", ossl_cipher_get_auth_tag, -1);\n    rb_define_method(cCipher, \"auth_tag_len=\", ossl_cipher_set_auth_tag_len, 1);\n    rb_define_method(cCipher, \"authenticated?\", ossl_cipher_is_authenticated, 0);\n    rb_define_method(cCipher, \"key_len=\", ossl_cipher_set_key_length, 1);\n    rb_define_method(cCipher, \"key_len\", ossl_cipher_key_length, 0);\n    rb_define_method(cCipher, \"iv=\", ossl_cipher_set_iv, 1);\n    rb_define_method(cCipher, \"iv_len=\", ossl_cipher_set_iv_length, 1);\n    rb_define_method(cCipher, \"iv_len\", ossl_cipher_iv_length, 0);\n    rb_define_method(cCipher, \"block_size\", ossl_cipher_block_size, 0);\n     rb_define_method(cCipher, \"padding=\", ossl_cipher_set_padding, 1);\n \n     id_auth_tag_len = rb_intern_const(\"auth_tag_len\");\n }\n", "target": 1, "idx": 181950}
{"func": "struct sk_buff *sock_wmalloc(struct sock *sk, unsigned long size, int force,\n\t\t\t     gfp_t priority)\n{\n\tif (force || atomic_read(&sk->sk_wmem_alloc) < sk->sk_sndbuf) {\n\t\tstruct sk_buff *skb = alloc_skb(size, priority);\n\t\tif (skb) {\n\t\t\tskb_set_owner_w(skb, sk);\n\t\t\treturn skb;\n\t\t}\n\t}\n\treturn NULL;\n}\n", "target": 0, "idx": 20208}
{"func": "status_t OMXNodeInstance::getConfig(\n\n         OMX_INDEXTYPE index, void *params, size_t /* size */) {\n     Mutex::Autolock autoLock(mLock);\n \n     OMX_ERRORTYPE err = OMX_GetConfig(mHandle, index, params);\n     OMX_INDEXEXTTYPE extIndex = (OMX_INDEXEXTTYPE)index;\n if (err != OMX_ErrorNoMore) {\n        CLOG_IF_ERROR(getConfig, err, \"%s(%#x)\", asString(extIndex), index);\n }\n return StatusFromOMXError(err);\n}\n", "target": 1, "idx": 188156}
{"func": "void RenderFrameDevToolsAgentHost::InspectElement(\n    DevToolsSession* session,\n    int x,\n    int y) {\n\n  if (frame_tree_node_) {\n    if (auto* main_view =\n            frame_tree_node_->frame_tree()->GetMainFrame()->GetView()) {\n      gfx::Point transformed_point = gfx::ToRoundedPoint(\n          main_view->TransformRootPointToViewCoordSpace(gfx::PointF(x, y)));\n      x = transformed_point.x();\n      y = transformed_point.y();\n    }\n  }\n\n  session->InspectElement(gfx::Point(x, y));\n}\n", "target": 0, "idx": 161506}
{"func": "  static void CloudPrintInfoCallback(bool enabled,\n                                     const std::string& email,\n                                     const std::string& proxy_id) {\n    QuitMessageLoop();\n   }\n", "target": 1, "idx": 185961}
{"func": "static int rt_fill_info(struct net *net,  __be32 dst, __be32 src,\n\t\t\tstruct flowi4 *fl4, struct sk_buff *skb, u32 portid,\n\t\t\tu32 seq, int event, int nowait, unsigned int flags)\n{\n\tstruct rtable *rt = skb_rtable(skb);\n\tstruct rtmsg *r;\n\tstruct nlmsghdr *nlh;\n\tunsigned long expires = 0;\n\tu32 error;\n\tu32 metrics[RTAX_MAX];\n\n\tnlh = nlmsg_put(skb, portid, seq, event, sizeof(*r), flags);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tr = nlmsg_data(nlh);\n\tr->rtm_family\t = AF_INET;\n\tr->rtm_dst_len\t= 32;\n\tr->rtm_src_len\t= 0;\n\tr->rtm_tos\t= fl4->flowi4_tos;\n\tr->rtm_table\t= RT_TABLE_MAIN;\n\tif (nla_put_u32(skb, RTA_TABLE, RT_TABLE_MAIN))\n\t\tgoto nla_put_failure;\n\tr->rtm_type\t= rt->rt_type;\n\tr->rtm_scope\t= RT_SCOPE_UNIVERSE;\n\tr->rtm_protocol = RTPROT_UNSPEC;\n \tr->rtm_flags\t= (rt->rt_flags & ~0xFFFF) | RTM_F_CLONED;\n \tif (rt->rt_flags & RTCF_NOTIFY)\n \t\tr->rtm_flags |= RTM_F_NOTIFY;\n \n \tif (nla_put_be32(skb, RTA_DST, dst))\n \t\tgoto nla_put_failure;\n\tif (src) {\n\t\tr->rtm_src_len = 32;\n\t\tif (nla_put_be32(skb, RTA_SRC, src))\n\t\t\tgoto nla_put_failure;\n\t}\n\tif (rt->dst.dev &&\n\t    nla_put_u32(skb, RTA_OIF, rt->dst.dev->ifindex))\n\t\tgoto nla_put_failure;\n#ifdef CONFIG_IP_ROUTE_CLASSID\n\tif (rt->dst.tclassid &&\n\t    nla_put_u32(skb, RTA_FLOW, rt->dst.tclassid))\n\t\tgoto nla_put_failure;\n#endif\n\tif (!rt_is_input_route(rt) &&\n\t    fl4->saddr != src) {\n\t\tif (nla_put_be32(skb, RTA_PREFSRC, fl4->saddr))\n\t\t\tgoto nla_put_failure;\n\t}\n\tif (rt->rt_uses_gateway &&\n\t    nla_put_be32(skb, RTA_GATEWAY, rt->rt_gateway))\n\t\tgoto nla_put_failure;\n\n\texpires = rt->dst.expires;\n\tif (expires) {\n\t\tunsigned long now = jiffies;\n\n\t\tif (time_before(now, expires))\n\t\t\texpires -= now;\n\t\telse\n\t\t\texpires = 0;\n\t}\n\n\tmemcpy(metrics, dst_metrics_ptr(&rt->dst), sizeof(metrics));\n\tif (rt->rt_pmtu && expires)\n\t\tmetrics[RTAX_MTU - 1] = rt->rt_pmtu;\n\tif (rtnetlink_put_metrics(skb, metrics) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (fl4->flowi4_mark &&\n\t    nla_put_u32(skb, RTA_MARK, fl4->flowi4_mark))\n\t\tgoto nla_put_failure;\n\n\terror = rt->dst.error;\n\n\tif (rt_is_input_route(rt)) {\n#ifdef CONFIG_IP_MROUTE\n\t\tif (ipv4_is_multicast(dst) && !ipv4_is_local_multicast(dst) &&\n\t\t    IPV4_DEVCONF_ALL(net, MC_FORWARDING)) {\n\t\t\tint err = ipmr_get_route(net, skb,\n\t\t\t\t\t\t fl4->saddr, fl4->daddr,\n\t\t\t\t\t\t r, nowait);\n\t\t\tif (err <= 0) {\n\t\t\t\tif (!nowait) {\n\t\t\t\t\tif (err == 0)\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\tgoto nla_put_failure;\n\t\t\t\t} else {\n\t\t\t\t\tif (err == -EMSGSIZE)\n\t\t\t\t\t\tgoto nla_put_failure;\n\t\t\t\t\terror = err;\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n#endif\n\t\t\tif (nla_put_u32(skb, RTA_IIF, skb->dev->ifindex))\n\t\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (rtnl_put_cacheinfo(skb, &rt->dst, 0, expires, error) < 0)\n\t\tgoto nla_put_failure;\n\n\treturn nlmsg_end(skb, nlh);\n\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n", "target": 1, "idx": 179871}
{"func": "bool GpuProcessPolicy::PreSandboxHook() {\n  const bool chromeos_arm_gpu = IsChromeOS() && IsArchitectureArm();\n  DCHECK(!chromeos_arm_gpu);\n\n  DCHECK(!broker_process());\n  InitGpuBrokerProcess(\n      GpuBrokerProcessPolicy::Create,\n      std::vector<BrokerFilePermission>());  // No extra files in whitelist.\n\n  if (IsArchitectureX86_64() || IsArchitectureI386()) {\n     if (IsAcceleratedVaapiVideoEncodeEnabled() ||\n         IsAcceleratedVideoDecodeEnabled()) {\n       const char* I965DrvVideoPath = NULL;\n      const char* I965HybridDrvVideoPath = NULL;\n \n       if (IsArchitectureX86_64()) {\n         I965DrvVideoPath = \"/usr/lib64/va/drivers/i965_drv_video.so\";\n        I965HybridDrvVideoPath = \"/usr/lib64/va/drivers/hybrid_drv_video.so\";\n       } else if (IsArchitectureI386()) {\n         I965DrvVideoPath = \"/usr/lib/va/drivers/i965_drv_video.so\";\n       }\n \n       dlopen(I965DrvVideoPath, RTLD_NOW|RTLD_GLOBAL|RTLD_NODELETE);\n      if (I965HybridDrvVideoPath)\n        dlopen(I965HybridDrvVideoPath, RTLD_NOW|RTLD_GLOBAL|RTLD_NODELETE);\n       dlopen(\"libva.so.1\", RTLD_NOW|RTLD_GLOBAL|RTLD_NODELETE);\n #if defined(USE_OZONE)\n       dlopen(\"libva-drm.so.1\", RTLD_NOW|RTLD_GLOBAL|RTLD_NODELETE);\n#elif defined(USE_X11)\n      dlopen(\"libva-x11.so.1\", RTLD_NOW|RTLD_GLOBAL|RTLD_NODELETE);\n#endif\n    }\n  }\n\n  return true;\n}\n", "target": 1, "idx": 183528}
{"func": "WORD32 ih264d_parse_decode_slice(UWORD8 u1_is_idr_slice,\n                                 UWORD8 u1_nal_ref_idc,\n dec_struct_t *ps_dec /* Decoder parameters */\n )\n{\n dec_bit_stream_t * ps_bitstrm = ps_dec->ps_bitstrm;\n dec_pic_params_t *ps_pps;\n dec_seq_params_t *ps_seq;\n dec_slice_params_t *ps_cur_slice = ps_dec->ps_cur_slice;\n pocstruct_t s_tmp_poc;\n    WORD32 i_delta_poc[2];\n    WORD32 i4_poc = 0;\n    UWORD16 u2_first_mb_in_slice, u2_frame_num;\n    UWORD8 u1_field_pic_flag, u1_redundant_pic_cnt = 0, u1_slice_type;\n    UWORD32 u4_idr_pic_id = 0;\n    UWORD8 u1_bottom_field_flag, u1_pic_order_cnt_type;\n\n    UWORD8 u1_nal_unit_type;\n    UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;\n    UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;\n    WORD8 i1_is_end_of_poc;\n\n    WORD32 ret, end_of_frame;\n    WORD32 prev_slice_err, num_mb_skipped;\n    UWORD8 u1_mbaff;\n pocstruct_t *ps_cur_poc;\n\n    UWORD32 u4_temp;\n    WORD32 i_temp;\n    UWORD32 u4_call_end_of_pic = 0;\n\n /* read FirstMbInSlice  and slice type*/\n    ps_dec->ps_dpb_cmds->u1_dpb_commands_read_slc = 0;\n    u2_first_mb_in_slice = ih264d_uev(pu4_bitstrm_ofst,\n                                     pu4_bitstrm_buf);\n if(u2_first_mb_in_slice\n > (ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs))\n {\n\n return ERROR_CORRUPTED_SLICE;\n }\n\n /*we currently don not support ASO*/\n if(((u2_first_mb_in_slice << ps_cur_slice->u1_mbaff_frame_flag)\n <= ps_dec->u2_cur_mb_addr) && (ps_dec->u4_first_slice_in_pic == 0))\n {\n return ERROR_CORRUPTED_SLICE;\n }\n\n    COPYTHECONTEXT(\"SH: first_mb_in_slice\",u2_first_mb_in_slice);\n\n    u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);\n\n if(u4_temp > 9)\n return ERROR_INV_SLC_TYPE_T;\n\n    u1_slice_type = u4_temp;\n    COPYTHECONTEXT(\"SH: slice_type\",(u1_slice_type));\n    ps_dec->u1_sl_typ_5_9 = 0;\n /* Find Out the Slice Type is 5 to 9 or not then Set the Flag   */\n /* u1_sl_typ_5_9 = 1 .Which tells that all the slices in the Pic*/\n /* will be of same type of current                            */\n if(u1_slice_type > 4)\n {\n        u1_slice_type -= 5;\n        ps_dec->u1_sl_typ_5_9 = 1;\n }\n\n {\n        UWORD32 skip;\n\n if((ps_dec->i4_app_skip_mode == IVD_SKIP_PB)\n || (ps_dec->i4_dec_skip_mode == IVD_SKIP_PB))\n {\n            UWORD32 u4_bit_stream_offset = 0;\n\n if(ps_dec->u1_nal_unit_type == IDR_SLICE_NAL)\n {\n                skip = 0;\n\n                ps_dec->i4_dec_skip_mode = IVD_SKIP_NONE;\n }\n else if((I_SLICE == u1_slice_type)\n && (1 >= ps_dec->ps_cur_sps->u1_num_ref_frames))\n {\n                skip = 0;\n\n                ps_dec->i4_dec_skip_mode = IVD_SKIP_NONE;\n }\n else\n {\n                skip = 1;\n }\n\n /* If one frame worth of data is already skipped, do not skip the next one */\n if((0 == u2_first_mb_in_slice) && (1 == ps_dec->u4_prev_nal_skipped))\n {\n                skip = 0;\n }\n\n if(skip)\n {\n                ps_dec->u4_prev_nal_skipped = 1;\n                ps_dec->i4_dec_skip_mode = IVD_SKIP_PB;\n return 0;\n }\n else\n {\n /* If the previous NAL was skipped, then\n                 do not process that buffer in this call.\n                 Return to app and process it in the next call.\n                 This is necessary to handle cases where I/IDR is not complete in\n                 the current buffer and application intends to fill the remaining part of the bitstream\n                 later. This ensures we process only frame worth of data in every call */\n if(1 == ps_dec->u4_prev_nal_skipped)\n {\n                    ps_dec->u4_return_to_app = 1;\n return 0;\n }\n }\n }\n\n }\n\n    u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);\n if(u4_temp & MASK_ERR_PIC_SET_ID)\n return ERROR_INV_SLICE_HDR_T;\n /* discard slice if pic param is invalid */\n    COPYTHECONTEXT(\"SH: pic_parameter_set_id\", u4_temp);\n    ps_pps = &ps_dec->ps_pps[u4_temp];\n if(FALSE == ps_pps->u1_is_valid)\n {\n return ERROR_INV_SLICE_HDR_T;\n }\n    ps_seq = ps_pps->ps_sps;\n if(!ps_seq)\n return ERROR_INV_SLICE_HDR_T;\n if(FALSE == ps_seq->u1_is_valid)\n return ERROR_INV_SLICE_HDR_T;\n\n /* Get the frame num */\n    u2_frame_num = ih264d_get_bits_h264(ps_bitstrm,\n                                         ps_seq->u1_bits_in_frm_num);\n\n \n     COPYTHECONTEXT(\"SH: frame_num\", u2_frame_num);\n \n     /* Get the field related flags  */\n     if(!ps_seq->u1_frame_mbs_only_flag)\n     {\n\n        u1_field_pic_flag = ih264d_get_bit_h264(ps_bitstrm);\n        COPYTHECONTEXT(\"SH: field_pic_flag\", u1_field_pic_flag);\n        u1_bottom_field_flag = 0;\n\n if(u1_field_pic_flag)\n {\n            ps_dec->pu1_inv_scan = (UWORD8 *)gau1_ih264d_inv_scan_fld;\n            u1_bottom_field_flag = ih264d_get_bit_h264(ps_bitstrm);\n            COPYTHECONTEXT(\"SH: bottom_field_flag\", u1_bottom_field_flag);\n\n }\n else\n {\n            ps_dec->pu1_inv_scan = (UWORD8 *)gau1_ih264d_inv_scan;\n }\n }\n else\n {\n        u1_field_pic_flag = 0;\n        u1_bottom_field_flag = 0;\n\n        ps_dec->pu1_inv_scan = (UWORD8 *)gau1_ih264d_inv_scan;\n }\n\n    u1_nal_unit_type = SLICE_NAL;\n if(u1_is_idr_slice)\n {\n if(0 == u1_field_pic_flag)\n {\n            ps_dec->u1_top_bottom_decoded = TOP_FIELD_ONLY | BOT_FIELD_ONLY;\n }\n        u1_nal_unit_type = IDR_SLICE_NAL;\n        u4_idr_pic_id = ih264d_uev(pu4_bitstrm_ofst,\n                                   pu4_bitstrm_buf);\n if(u4_idr_pic_id > 65535)\n return ERROR_INV_SLICE_HDR_T;\n        COPYTHECONTEXT(\"SH:  \", u4_idr_pic_id);\n }\n\n /* read delta pic order count information*/\n    i_delta_poc[0] = i_delta_poc[1] = 0;\n    s_tmp_poc.i4_pic_order_cnt_lsb = 0;\n    s_tmp_poc.i4_delta_pic_order_cnt_bottom = 0;\n    u1_pic_order_cnt_type = ps_seq->u1_pic_order_cnt_type;\n if(u1_pic_order_cnt_type == 0)\n {\n        i_temp = ih264d_get_bits_h264(\n                        ps_bitstrm,\n                        ps_seq->u1_log2_max_pic_order_cnt_lsb_minus);\n if(i_temp < 0 || i_temp >= ps_seq->i4_max_pic_order_cntLsb)\n return ERROR_INV_SLICE_HDR_T;\n        s_tmp_poc.i4_pic_order_cnt_lsb = i_temp;\n        COPYTHECONTEXT(\"SH: pic_order_cnt_lsb\", s_tmp_poc.i4_pic_order_cnt_lsb);\n\n if((ps_pps->u1_pic_order_present_flag == 1) && (!u1_field_pic_flag))\n {\n            s_tmp_poc.i4_delta_pic_order_cnt_bottom = ih264d_sev(\n                            pu4_bitstrm_ofst, pu4_bitstrm_buf);\n            COPYTHECONTEXT(\"SH: delta_pic_order_cnt_bottom\",\n                            s_tmp_poc.i4_delta_pic_order_cnt_bottom);\n }\n }\n\n    s_tmp_poc.i4_delta_pic_order_cnt[0] = 0;\n    s_tmp_poc.i4_delta_pic_order_cnt[1] = 0;\n if(u1_pic_order_cnt_type == 1\n && (!ps_seq->u1_delta_pic_order_always_zero_flag))\n {\n        s_tmp_poc.i4_delta_pic_order_cnt[0] = ih264d_sev(pu4_bitstrm_ofst,\n                                                         pu4_bitstrm_buf);\n        COPYTHECONTEXT(\"SH: delta_pic_order_cnt[0]\",\n                        s_tmp_poc.i4_delta_pic_order_cnt[0]);\n\n if(ps_pps->u1_pic_order_present_flag && !u1_field_pic_flag)\n {\n            s_tmp_poc.i4_delta_pic_order_cnt[1] = ih264d_sev(\n                            pu4_bitstrm_ofst, pu4_bitstrm_buf);\n            COPYTHECONTEXT(\"SH: delta_pic_order_cnt[1]\",\n                            s_tmp_poc.i4_delta_pic_order_cnt[1]);\n }\n }\n\n if(ps_pps->u1_redundant_pic_cnt_present_flag)\n {\n        u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);\n if(u4_temp > MAX_REDUNDANT_PIC_CNT)\n return ERROR_INV_SLICE_HDR_T;\n        u1_redundant_pic_cnt = u4_temp;\n        COPYTHECONTEXT(\"SH: redundant_pic_cnt\", u1_redundant_pic_cnt);\n }\n\n /*--------------------------------------------------------------------*/\n /* Check if the slice is part of new picture                          */\n /*--------------------------------------------------------------------*/\n /* First slice of a picture is always considered as part of new picture */\n    i1_is_end_of_poc = 1;\n    ps_dec->ps_dec_err_status->u1_err_flag &= MASK_REJECT_CUR_PIC;\n\n if(ps_dec->u4_first_slice_in_pic != 2)\n {\n        i1_is_end_of_poc = ih264d_is_end_of_pic(u2_frame_num, u1_nal_ref_idc,\n &s_tmp_poc, &ps_dec->s_cur_pic_poc,\n                                            ps_cur_slice, u1_pic_order_cnt_type,\n\n                                             u1_nal_unit_type, u4_idr_pic_id,\n                                             u1_field_pic_flag,\n                                             u1_bottom_field_flag);\n     }\n \n     /*--------------------------------------------------------------------*/\n /* Check for error in slice and parse the missing/corrupted MB's      */\n /* as skip-MB's in an inserted P-slice                                */\n /*--------------------------------------------------------------------*/\n    u1_mbaff = ps_seq->u1_mb_aff_flag && (!u1_field_pic_flag);\n    prev_slice_err = 0;\n\n if(i1_is_end_of_poc || ps_dec->u1_first_slice_in_stream)\n {\n if(u2_frame_num != ps_dec->u2_prv_frame_num\n && ps_dec->u1_top_bottom_decoded != 0\n && ps_dec->u1_top_bottom_decoded\n != (TOP_FIELD_ONLY | BOT_FIELD_ONLY))\n {\n            ps_dec->u1_dangling_field = 1;\n if(ps_dec->u4_first_slice_in_pic)\n {\n                prev_slice_err = 1;\n }\n else\n {\n                prev_slice_err = 2;\n }\n\n if(ps_dec->u1_top_bottom_decoded ==TOP_FIELD_ONLY)\n                ps_cur_slice->u1_bottom_field_flag = 1;\n else\n                ps_cur_slice->u1_bottom_field_flag = 0;\n\n            num_mb_skipped = (ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n - ps_dec->u2_total_mbs_coded;\n            ps_cur_poc = &ps_dec->s_cur_pic_poc;\n\n            u1_is_idr_slice = ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL;\n }\n else if(ps_dec->u4_first_slice_in_pic == 2)\n {\n if(u2_first_mb_in_slice > 0)\n {\n                prev_slice_err = 1;\n                num_mb_skipped = u2_first_mb_in_slice << u1_mbaff;\n                ps_cur_poc = &s_tmp_poc;\n\n                ps_cur_slice->u4_idr_pic_id = u4_idr_pic_id;\n                ps_cur_slice->u1_field_pic_flag = u1_field_pic_flag;\n                ps_cur_slice->u1_bottom_field_flag = u1_bottom_field_flag;\n                ps_cur_slice->i4_pic_order_cnt_lsb =\n                        s_tmp_poc.i4_pic_order_cnt_lsb;\n                ps_cur_slice->u1_nal_unit_type = u1_nal_unit_type;\n                ps_cur_slice->u1_redundant_pic_cnt = u1_redundant_pic_cnt;\n                ps_cur_slice->u1_nal_ref_idc = u1_nal_ref_idc;\n                ps_cur_slice->u1_pic_order_cnt_type = u1_pic_order_cnt_type;\n                ps_cur_slice->u1_mbaff_frame_flag = ps_seq->u1_mb_aff_flag\n && (!u1_field_pic_flag);\n }\n }\n else\n {\n\n if(ps_dec->u4_first_slice_in_pic)\n {\n /* if valid slice header is not decoded do start of pic processing\n                 * since in the current process call, frame num is not updated in the slice structure yet\n                 * ih264d_is_end_of_pic is checked with valid frame num of previous process call,\n                 * although i1_is_end_of_poc is set there could be  more slices in the frame,\n                 * so conceal only till cur slice */\n                prev_slice_err = 1;\n                num_mb_skipped = u2_first_mb_in_slice << u1_mbaff;\n }\n else\n {\n /* since i1_is_end_of_poc is set ,means new frame num is encountered. so conceal the current frame\n                 * completely */\n                prev_slice_err = 2;\n                num_mb_skipped = (ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n - ps_dec->u2_total_mbs_coded;\n }\n            ps_cur_poc = &s_tmp_poc;\n }\n }\n else\n {\n if((u2_first_mb_in_slice << u1_mbaff) > ps_dec->u2_total_mbs_coded)\n {\n            prev_slice_err = 2;\n            num_mb_skipped = (u2_first_mb_in_slice << u1_mbaff)\n - ps_dec->u2_total_mbs_coded;\n            ps_cur_poc = &s_tmp_poc;\n }\n else if((u2_first_mb_in_slice << u1_mbaff) < ps_dec->u2_total_mbs_coded)\n {\n return ERROR_CORRUPTED_SLICE;\n }\n }\n\n if(prev_slice_err)\n {\n        ret = ih264d_mark_err_slice_skip(ps_dec, num_mb_skipped, u1_is_idr_slice, u2_frame_num, ps_cur_poc, prev_slice_err);\n\n if(ps_dec->u1_dangling_field == 1)\n {\n            ps_dec->u1_second_field = 1 - ps_dec->u1_second_field;\n            ps_cur_slice->u1_bottom_field_flag = u1_bottom_field_flag;\n            ps_dec->u2_prv_frame_num = u2_frame_num;\n            ps_dec->u1_first_slice_in_stream = 0;\n return ERROR_DANGLING_FIELD_IN_PIC;\n }\n\n if(prev_slice_err == 2)\n {\n            ps_dec->u1_first_slice_in_stream = 0;\n return ERROR_INCOMPLETE_FRAME;\n }\n\n if(ps_dec->u2_total_mbs_coded\n >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n {\n /* return if all MBs in frame are parsed*/\n            ps_dec->u1_first_slice_in_stream = 0;\n return ERROR_IN_LAST_SLICE_OF_PIC;\n }\n\n if(ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC)\n {\n            ih264d_err_pic_dispbuf_mgr(ps_dec);\n return ERROR_NEW_FRAME_EXPECTED;\n }\n\n if(ret != OK)\n return ret;\n\n        i1_is_end_of_poc = 0;\n }\n\n if (ps_dec->u4_first_slice_in_pic == 0)\n {\n        ps_dec->ps_parse_cur_slice++;\n        ps_dec->u2_cur_slice_num++;\n }\n\n if((ps_dec->u1_separate_parse == 0) && (ps_dec->u4_first_slice_in_pic == 0))\n {\n        ps_dec->ps_decode_cur_slice++;\n\n     }\n     ps_dec->u1_slice_header_done = 0;\n \n    /*--------------------------------------------------------------------*/\n    /* If the slice is part of new picture, do End of Pic processing.     */\n    /*--------------------------------------------------------------------*/\n    if(!ps_dec->u1_first_slice_in_stream)\n    {\n        UWORD8 uc_mbs_exceed = 0;\n        if(ps_dec->u2_total_mbs_coded\n                        == (ps_dec->ps_cur_sps->u2_max_mb_addr + 1))\n        {\n            /*u2_total_mbs_coded is forced  to u2_max_mb_addr+ 1 at the end of decode ,so\n             ,if it is first slice in pic dont consider u2_total_mbs_coded to detect new picture */\n            if(ps_dec->u4_first_slice_in_pic == 0)\n                uc_mbs_exceed = 1;\n        }\n        if(i1_is_end_of_poc || uc_mbs_exceed)\n        {\n            if(1 == ps_dec->u1_last_pic_not_decoded)\n            {\n                ret = ih264d_end_of_pic_dispbuf_mgr(ps_dec);\n                if(ret != OK)\n                    return ret;\n                ret = ih264d_end_of_pic(ps_dec, u1_is_idr_slice, u2_frame_num);\n                if(ret != OK)\n                    return ret;\n#if WIN32\n                H264_DEC_DEBUG_PRINT(\" ------ PIC SKIPPED ------\\n\");\n#endif\n                return RET_LAST_SKIP;\n            }\n            else\n            {\n                ret = ih264d_end_of_pic(ps_dec, u1_is_idr_slice, u2_frame_num);\n                if(ret != OK)\n                    return ret;\n            }\n        }\n    }\n \n     if(u1_field_pic_flag)\n     {\n        ps_dec->u2_prv_frame_num = u2_frame_num;\n }\n\n if(ps_cur_slice->u1_mmco_equalto5)\n {\n        WORD32 i4_temp_poc;\n        WORD32 i4_top_field_order_poc, i4_bot_field_order_poc;\n\n if(!ps_cur_slice->u1_field_pic_flag) // or a complementary field pair\n {\n            i4_top_field_order_poc = ps_dec->ps_cur_pic->i4_top_field_order_cnt;\n            i4_bot_field_order_poc =\n                            ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;\n            i4_temp_poc = MIN(i4_top_field_order_poc,\n                                     i4_bot_field_order_poc);\n }\n else if(!ps_cur_slice->u1_bottom_field_flag)\n            i4_temp_poc = ps_dec->ps_cur_pic->i4_top_field_order_cnt;\n else\n            i4_temp_poc = ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;\n\n        ps_dec->ps_cur_pic->i4_top_field_order_cnt = i4_temp_poc\n - ps_dec->ps_cur_pic->i4_top_field_order_cnt;\n        ps_dec->ps_cur_pic->i4_bottom_field_order_cnt = i4_temp_poc\n - ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;\n        ps_dec->ps_cur_pic->i4_poc = i4_temp_poc;\n        ps_dec->ps_cur_pic->i4_avg_poc = i4_temp_poc;\n }\n if(ps_dec->u4_first_slice_in_pic == 2)\n {\n        ret = ih264d_decode_pic_order_cnt(u1_is_idr_slice, u2_frame_num,\n &ps_dec->s_prev_pic_poc,\n &s_tmp_poc, ps_cur_slice, ps_pps,\n                                          u1_nal_ref_idc,\n                                          u1_bottom_field_flag,\n                                          u1_field_pic_flag, &i4_poc);\n if(ret != OK)\n return ret;\n /* Display seq no calculations */\n if(i4_poc >= ps_dec->i4_max_poc)\n            ps_dec->i4_max_poc = i4_poc;\n /* IDR Picture or POC wrap around */\n if(i4_poc == 0)\n {\n            ps_dec->i4_prev_max_display_seq = ps_dec->i4_prev_max_display_seq\n + ps_dec->i4_max_poc\n + ps_dec->u1_max_dec_frame_buffering + 1;\n            ps_dec->i4_max_poc = 0;\n }\n }\n\n /*--------------------------------------------------------------------*/\n /* Copy the values read from the bitstream to the slice header and then*/\n /* If the slice is first slice in picture, then do Start of Picture   */\n /* processing.                                                        */\n /*--------------------------------------------------------------------*/\n    ps_cur_slice->i4_delta_pic_order_cnt[0] = i_delta_poc[0];\n    ps_cur_slice->i4_delta_pic_order_cnt[1] = i_delta_poc[1];\n    ps_cur_slice->u4_idr_pic_id = u4_idr_pic_id;\n    ps_cur_slice->u2_first_mb_in_slice = u2_first_mb_in_slice;\n    ps_cur_slice->u1_field_pic_flag = u1_field_pic_flag;\n    ps_cur_slice->u1_bottom_field_flag = u1_bottom_field_flag;\n    ps_cur_slice->u1_slice_type = u1_slice_type;\n    ps_cur_slice->i4_pic_order_cnt_lsb = s_tmp_poc.i4_pic_order_cnt_lsb;\n\n    ps_cur_slice->u1_nal_unit_type = u1_nal_unit_type;\n    ps_cur_slice->u1_redundant_pic_cnt = u1_redundant_pic_cnt;\n    ps_cur_slice->u1_nal_ref_idc = u1_nal_ref_idc;\n    ps_cur_slice->u1_pic_order_cnt_type = u1_pic_order_cnt_type;\n\n if(ps_seq->u1_frame_mbs_only_flag)\n        ps_cur_slice->u1_direct_8x8_inference_flag =\n                        ps_seq->u1_direct_8x8_inference_flag;\n else\n        ps_cur_slice->u1_direct_8x8_inference_flag = 1;\n\n if(u1_slice_type == B_SLICE)\n {\n        ps_cur_slice->u1_direct_spatial_mv_pred_flag = ih264d_get_bit_h264(\n                        ps_bitstrm);\n        COPYTHECONTEXT(\"SH: direct_spatial_mv_pred_flag\",\n                        ps_cur_slice->u1_direct_spatial_mv_pred_flag);\n\n if(ps_cur_slice->u1_direct_spatial_mv_pred_flag)\n            ps_cur_slice->pf_decodeDirect = ih264d_decode_spatial_direct;\n else\n            ps_cur_slice->pf_decodeDirect = ih264d_decode_temporal_direct;\n if(!((ps_pps->ps_sps->u1_mb_aff_flag) && (!u1_field_pic_flag)))\n            ps_dec->pf_mvpred = ih264d_mvpred_nonmbaffB;\n }\n else\n {\n if(!((ps_pps->ps_sps->u1_mb_aff_flag) && (!u1_field_pic_flag)))\n            ps_dec->pf_mvpred = ih264d_mvpred_nonmbaff;\n }\n\n if(ps_dec->u4_first_slice_in_pic == 2)\n {\n if(u2_first_mb_in_slice == 0)\n {\n            ret = ih264d_start_of_pic(ps_dec, i4_poc, &s_tmp_poc, u2_frame_num, ps_pps);\n if(ret != OK)\n return ret;\n }\n\n        ps_dec->u4_output_present = 0;\n\n {\n            ih264d_get_next_display_field(ps_dec,\n                                          ps_dec->ps_out_buffer,\n &(ps_dec->s_disp_op));\n /* If error code is non-zero then there is no buffer available for display,\n             hence avoid format conversion */\n\n if(0 != ps_dec->s_disp_op.u4_error_code)\n {\n                ps_dec->u4_fmt_conv_cur_row = ps_dec->s_disp_frame_info.u4_y_ht;\n }\n else\n                ps_dec->u4_output_present = 1;\n }\n if(ps_dec->u1_separate_parse == 1)\n {\n if(ps_dec->u4_dec_thread_created == 0)\n {\n                ithread_create(ps_dec->pv_dec_thread_handle, NULL,\n (void *)ih264d_decode_picture_thread,\n (void *)ps_dec);\n\n                ps_dec->u4_dec_thread_created = 1;\n }\n\n if((ps_dec->u4_num_cores == 3) &&\n ((ps_dec->u4_app_disable_deblk_frm == 0) || ps_dec->i1_recon_in_thread3_flag)\n && (ps_dec->u4_bs_deblk_thread_created == 0))\n {\n                ps_dec->u4_start_recon_deblk = 0;\n                ithread_create(ps_dec->pv_bs_deblk_thread_handle, NULL,\n (void *)ih264d_recon_deblk_thread,\n (void *)ps_dec);\n                ps_dec->u4_bs_deblk_thread_created = 1;\n }\n }\n\n }\n\n /* INITIALIZATION of fn ptrs for MC and formMbPartInfo functions */\n {\n        UWORD8 uc_nofield_nombaff;\n\n\n\n        uc_nofield_nombaff = ((ps_dec->ps_cur_slice->u1_field_pic_flag == 0)\n && (ps_dec->ps_cur_slice->u1_mbaff_frame_flag == 0)\n && (u1_slice_type != B_SLICE)\n && (ps_dec->ps_cur_pps->u1_wted_pred_flag == 0));\n\n /* Initialise MC and formMbPartInfo fn ptrs one time based on profile_idc */\n\n if(uc_nofield_nombaff)\n {\n            ps_dec->p_form_mb_part_info = ih264d_form_mb_part_info_bp;\n            ps_dec->p_motion_compensate = ih264d_motion_compensate_bp;\n }\n else\n {\n            ps_dec->p_form_mb_part_info = ih264d_form_mb_part_info_mp;\n            ps_dec->p_motion_compensate = ih264d_motion_compensate_mp;\n }\n\n\n }\n\n /*\n     * Decide whether to decode the current picture or not\n     */\n {\n dec_err_status_t * ps_err = ps_dec->ps_dec_err_status;\n if(ps_err->u4_frm_sei_sync == u2_frame_num)\n {\n            ps_err->u1_err_flag = ACCEPT_ALL_PICS;\n            ps_err->u4_frm_sei_sync = SYNC_FRM_DEFAULT;\n }\n        ps_err->u4_cur_frm = u2_frame_num;\n }\n\n /* Decision for decoding if the picture is to be skipped */\n {\n        WORD32 i4_skip_b_pic, i4_skip_p_pic;\n\n        i4_skip_b_pic = (ps_dec->u4_skip_frm_mask & B_SLC_BIT)\n && (B_SLICE == u1_slice_type) && (0 == u1_nal_ref_idc);\n\n        i4_skip_p_pic = (ps_dec->u4_skip_frm_mask & P_SLC_BIT)\n && (P_SLICE == u1_slice_type) && (0 == u1_nal_ref_idc);\n\n /**************************************************************/\n /* Skip the B picture if skip mask is set for B picture and   */\n /* Current B picture is a non reference B picture or there is */\n /* no user for reference B picture                            */\n /**************************************************************/\n if(i4_skip_b_pic)\n {\n            ps_dec->ps_cur_pic->u4_pack_slc_typ |= B_SLC_BIT;\n /* Don't decode the picture in SKIP-B mode if that picture is B */\n /* and also it is not to be used as a reference picture         */\n            ps_dec->u1_last_pic_not_decoded = 1;\n\n return OK;\n }\n /**************************************************************/\n /* Skip the P picture if skip mask is set for P picture and   */\n /* Current P picture is a non reference P picture or there is */\n /* no user for reference P picture                            */\n /**************************************************************/\n if(i4_skip_p_pic)\n {\n            ps_dec->ps_cur_pic->u4_pack_slc_typ |= P_SLC_BIT;\n /* Don't decode the picture in SKIP-P mode if that picture is P */\n /* and also it is not to be used as a reference picture         */\n            ps_dec->u1_last_pic_not_decoded = 1;\n\n return OK;\n }\n }\n\n {\n        UWORD16 u2_mb_x, u2_mb_y;\n\n        ps_dec->i4_submb_ofst = ((u2_first_mb_in_slice\n << ps_cur_slice->u1_mbaff_frame_flag) * SUB_BLK_SIZE)\n - SUB_BLK_SIZE;\n if(u2_first_mb_in_slice)\n {\n            UWORD8 u1_mb_aff;\n            UWORD8 u1_field_pic;\n            UWORD16 u2_frm_wd_in_mbs;\n            u2_frm_wd_in_mbs = ps_seq->u2_frm_wd_in_mbs;\n            u1_mb_aff = ps_cur_slice->u1_mbaff_frame_flag;\n            u1_field_pic = ps_cur_slice->u1_field_pic_flag;\n\n {\n                UWORD32 x_offset;\n                UWORD32 y_offset;\n                UWORD32 u4_frame_stride;\n tfr_ctxt_t *ps_trns_addr; // = &ps_dec->s_tran_addrecon_parse;\n\n if(ps_dec->u1_separate_parse)\n {\n                    ps_trns_addr = &ps_dec->s_tran_addrecon_parse;\n }\n else\n {\n                    ps_trns_addr = &ps_dec->s_tran_addrecon;\n }\n                u2_mb_x = MOD(u2_first_mb_in_slice, u2_frm_wd_in_mbs);\n                u2_mb_y = DIV(u2_first_mb_in_slice, u2_frm_wd_in_mbs);\n\n                u2_mb_y <<= u1_mb_aff;\n\n if((u2_mb_x > u2_frm_wd_in_mbs - 1)\n || (u2_mb_y > ps_dec->u2_frm_ht_in_mbs - 1))\n {\n return ERROR_CORRUPTED_SLICE;\n }\n\n                u4_frame_stride = ps_dec->u2_frm_wd_y << u1_field_pic;\n                x_offset = u2_mb_x << 4;\n                y_offset = (u2_mb_y * u4_frame_stride) << 4;\n\n                ps_trns_addr->pu1_dest_y = ps_dec->s_cur_pic.pu1_buf1 + x_offset\n + y_offset;\n\n                u4_frame_stride = ps_dec->u2_frm_wd_uv << u1_field_pic;\n                x_offset >>= 1;\n                y_offset = (u2_mb_y * u4_frame_stride) << 3;\n\n                x_offset *= YUV420SP_FACTOR;\n\n                ps_trns_addr->pu1_dest_u = ps_dec->s_cur_pic.pu1_buf2 + x_offset\n + y_offset;\n                ps_trns_addr->pu1_dest_v = ps_dec->s_cur_pic.pu1_buf3 + x_offset\n + y_offset;\n\n                ps_trns_addr->pu1_mb_y = ps_trns_addr->pu1_dest_y;\n                ps_trns_addr->pu1_mb_u = ps_trns_addr->pu1_dest_u;\n                ps_trns_addr->pu1_mb_v = ps_trns_addr->pu1_dest_v;\n\n\n if(ps_dec->u1_separate_parse == 1)\n {\n                    ps_dec->ps_deblk_mbn = ps_dec->ps_deblk_pic\n + (u2_first_mb_in_slice << u1_mb_aff);\n }\n else\n {\n                        ps_dec->ps_deblk_mbn = ps_dec->ps_deblk_pic\n + (u2_first_mb_in_slice << u1_mb_aff);\n }\n\n                ps_dec->u2_cur_mb_addr = (u2_first_mb_in_slice << u1_mb_aff);\n\n                ps_dec->ps_mv_cur = ps_dec->s_cur_pic.ps_mv\n + ((u2_first_mb_in_slice << u1_mb_aff) << 4);\n }\n }\n else\n {\n tfr_ctxt_t *ps_trns_addr;\n\n if(ps_dec->u1_separate_parse)\n {\n                ps_trns_addr = &ps_dec->s_tran_addrecon_parse;\n }\n else\n {\n                ps_trns_addr = &ps_dec->s_tran_addrecon;\n }\n\n            u2_mb_x = 0xffff;\n            u2_mb_y = 0;\n            ps_dec->u2_cur_mb_addr = 0;\n            ps_dec->ps_deblk_mbn = ps_dec->ps_deblk_pic;\n            ps_dec->ps_mv_cur = ps_dec->s_cur_pic.ps_mv;\n            ps_trns_addr->pu1_dest_y = ps_dec->s_cur_pic.pu1_buf1;\n            ps_trns_addr->pu1_dest_u = ps_dec->s_cur_pic.pu1_buf2;\n            ps_trns_addr->pu1_dest_v = ps_dec->s_cur_pic.pu1_buf3;\n\n            ps_trns_addr->pu1_mb_y = ps_trns_addr->pu1_dest_y;\n            ps_trns_addr->pu1_mb_u = ps_trns_addr->pu1_dest_u;\n            ps_trns_addr->pu1_mb_v = ps_trns_addr->pu1_dest_v;\n\n }\n\n        ps_dec->ps_part = ps_dec->ps_parse_part_params;\n\n        ps_dec->u2_mbx =\n (MOD(u2_first_mb_in_slice - 1, ps_seq->u2_frm_wd_in_mbs));\n        ps_dec->u2_mby =\n (DIV(u2_first_mb_in_slice - 1, ps_seq->u2_frm_wd_in_mbs));\n        ps_dec->u2_mby <<= ps_cur_slice->u1_mbaff_frame_flag;\n        ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;\n        ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;\n }\n\n /* RBSP stop bit is used for CABAC decoding*/\n    ps_bitstrm->u4_max_ofst += ps_dec->ps_cur_pps->u1_entropy_coding_mode;\n\n    ps_dec->u1_B = (u1_slice_type == B_SLICE);\n    ps_dec->u4_next_mb_skip = 0;\n\n    ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice =\n                    ps_dec->ps_cur_slice->u2_first_mb_in_slice;\n    ps_dec->ps_parse_cur_slice->slice_type =\n                    ps_dec->ps_cur_slice->u1_slice_type;\n\n\n    ps_dec->u4_start_recon_deblk = 1;\n {\n        WORD32 num_entries;\n        WORD32 size;\n        UWORD8 *pu1_buf;\n\n        num_entries = MIN(MAX_FRAMES, ps_dec->u4_num_ref_frames_at_init);\n        num_entries = 2 * ((2 * num_entries) + 1);\n\n        size = num_entries * sizeof(void *);\n        size += PAD_MAP_IDX_POC * sizeof(void *);\n\n        pu1_buf = (UWORD8 *)ps_dec->pv_map_ref_idx_to_poc_buf;\n        pu1_buf += size * ps_dec->u2_cur_slice_num;\n        ps_dec->ps_parse_cur_slice->ppv_map_ref_idx_to_poc = ( void *)pu1_buf;\n }\n\n if(ps_dec->u1_separate_parse)\n {\n        ps_dec->ps_parse_cur_slice->pv_tu_coeff_data_start = ps_dec->pv_parse_tu_coeff_data;\n }\n else\n {\n        ps_dec->pv_proc_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;\n }\n\n if(u1_slice_type == I_SLICE)\n {\n        ps_dec->ps_cur_pic->u4_pack_slc_typ |= I_SLC_BIT;\n\n        ret = ih264d_parse_islice(ps_dec, u2_first_mb_in_slice);\n\n if(ps_dec->i4_pic_type != B_SLICE && ps_dec->i4_pic_type != P_SLICE)\n            ps_dec->i4_pic_type = I_SLICE;\n\n }\n else if(u1_slice_type == P_SLICE)\n {\n        ps_dec->ps_cur_pic->u4_pack_slc_typ |= P_SLC_BIT;\n        ret = ih264d_parse_pslice(ps_dec, u2_first_mb_in_slice);\n        ps_dec->u1_pr_sl_type = u1_slice_type;\n if(ps_dec->i4_pic_type != B_SLICE)\n            ps_dec->i4_pic_type = P_SLICE;\n }\n else if(u1_slice_type == B_SLICE)\n {\n        ps_dec->ps_cur_pic->u4_pack_slc_typ |= B_SLC_BIT;\n        ret = ih264d_parse_bslice(ps_dec, u2_first_mb_in_slice);\n        ps_dec->u1_pr_sl_type = u1_slice_type;\n        ps_dec->i4_pic_type = B_SLICE;\n }\n else\n return ERROR_INV_SLC_TYPE_T;\n\n if(ps_dec->u1_slice_header_done)\n {\n /* set to zero to indicate a valid slice has been decoded */\n /* first slice header successfully decoded */\n        ps_dec->u4_first_slice_in_pic = 0;\n        ps_dec->u1_first_slice_in_stream = 0;\n }\n\n if(ret != OK)\n return ret;\n\n /* storing last Mb X and MbY of the slice */\n    ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;\n    ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;\n\n /* End of Picture detection */\n\n if(ps_dec->u2_total_mbs_coded >= (ps_seq->u2_max_mb_addr + 1))\n {\n        ps_dec->u1_pic_decode_done = 1;\n\n }\n\n {\n dec_err_status_t * ps_err = ps_dec->ps_dec_err_status;\n if((ps_err->u1_err_flag & REJECT_PB_PICS)\n && (ps_err->u1_cur_pic_type == PIC_TYPE_I))\n {\n            ps_err->u1_err_flag = ACCEPT_ALL_PICS;\n }\n }\n\n    PRINT_BIN_BIT_RATIO(ps_dec)\n\n return ret;\n}\n", "target": 1, "idx": 188079}
{"func": "extern \"C\" void RIL_setcallbacks (const RIL_RadioFunctions *callbacks) {\n    memcpy(&s_callbacks, callbacks, sizeof (RIL_RadioFunctions));\n}\n", "target": 0, "idx": 175249}
{"func": "inline void PulseAudioMixer::MainloopLock() const {\n   pa_threaded_mainloop_lock(pa_mainloop_);\n   ++mainloop_lock_count_;\n }\n", "target": 1, "idx": 184162}
{"func": "ModuleExport size_t RegisterPSImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"PS\",\"EPI\",\n    \"Encapsulated PostScript Interchange format\");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/postscript\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PS\",\"EPS\",\"Encapsulated PostScript\");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/postscript\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PS\",\"EPSF\",\"Encapsulated PostScript\");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/postscript\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PS\",\"EPSI\",\n    \"Encapsulated PostScript Interchange format\");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/postscript\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PS\",\"PS\",\"PostScript\");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->mime_type=ConstantString(\"application/postscript\");\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n", "target": 0, "idx": 96749}
{"func": "static MagickBooleanType SkipDXTMipmaps(Image *image,DDSInfo *dds_info,\n  int texel_size,ExceptionInfo *exception)\n{\n  register ssize_t\n    i;\n\n  MagickOffsetType\n    offset;\n\n  size_t\n    h,\n    w;\n\n  /*\n    Only skip mipmaps for textures and cube maps\n  */\n  if (EOFBlob(image) != MagickFalse)\n    {\n      ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n        image->filename);\n      return(MagickFalse);\n    }\n  if (dds_info->ddscaps1 & DDSCAPS_MIPMAP\n      && (dds_info->ddscaps1 & DDSCAPS_TEXTURE\n          || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))\n    {\n      w = DIV2(dds_info->width);\n      h = DIV2(dds_info->height);\n\n      /*\n        Mipmapcount includes the main image, so start from one\n      */\n       for (i = 1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)\n       {\n         offset = (MagickOffsetType) ((w + 3) / 4) * ((h + 3) / 4) * texel_size;\n        (void) SeekBlob(image, offset, SEEK_CUR);\n         w = DIV2(w);\n         h = DIV2(h);\n       }\n    }\n  return(MagickTrue);\n}\n", "target": 1, "idx": 182025}
{"func": " SPL_METHOD(GlobIterator, count)\n {\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n\n\tif (php_stream_is(intern->u.dir.dirp ,&php_glob_stream_ops)) {\n\t\tRETURN_LONG(php_glob_stream_get_count(intern->u.dir.dirp, NULL));\n\t} else {\n\t\t/* should not happen */\n\t\tphp_error_docref(NULL TSRMLS_CC, E_ERROR, \"GlobIterator lost glob state\");\n\t}\n}\n", "target": 1, "idx": 180220}
{"func": "  void CreateProgramInfo(GLuint client_id, GLuint service_id) {\n    program_manager()->CreateProgramInfo(client_id, service_id);\n  }\n", "target": 0, "idx": 108045}
{"func": "void FrameFetchContext::ProvideDocumentToContext(FetchContext& context,\n                                                 Document* document) {\n  DCHECK(document);\n  CHECK(context.IsFrameFetchContext());\n  static_cast<FrameFetchContext&>(context).document_ = document;\n  static_cast<FrameFetchContext&>(context).fetch_client_settings_object_ =\n      new FetchClientSettingsObjectImpl(*document);\n}\n", "target": 0, "idx": 158631}
{"func": "armv6_pmcr_has_overflowed(unsigned long pmcr)\n{\n\treturn pmcr & ARMV6_PMCR_OVERFLOWED_MASK;\n}\n", "target": 0, "idx": 25240}
{"func": "key_ref_t key_create_or_update(key_ref_t keyring_ref,\n\t\t\t       const char *type,\n\t\t\t       const char *description,\n\t\t\t       const void *payload,\n\t\t\t       size_t plen,\n\t\t\t       key_perm_t perm,\n\t\t\t       unsigned long flags)\n{\n\tstruct keyring_index_key index_key = {\n\t\t.description\t= description,\n\t};\n\tstruct key_preparsed_payload prep;\n\tstruct assoc_array_edit *edit;\n\tconst struct cred *cred = current_cred();\n\tstruct key *keyring, *key = NULL;\n\tkey_ref_t key_ref;\n\tint ret;\n\n\t/* look up the key type to see if it's one of the registered kernel\n\t * types */\n\tindex_key.type = key_type_lookup(type);\n\tif (IS_ERR(index_key.type)) {\n\t\tkey_ref = ERR_PTR(-ENODEV);\n\t\tgoto error;\n \t}\n \n \tkey_ref = ERR_PTR(-EINVAL);\n\tif (!index_key.type->match || !index_key.type->instantiate ||\n \t    (!index_key.description && !index_key.type->preparse))\n \t\tgoto error_put_type;\n \n\tkeyring = key_ref_to_ptr(keyring_ref);\n\n\tkey_check(keyring);\n\n\tkey_ref = ERR_PTR(-ENOTDIR);\n\tif (keyring->type != &key_type_keyring)\n\t\tgoto error_put_type;\n\n\tmemset(&prep, 0, sizeof(prep));\n\tprep.data = payload;\n\tprep.datalen = plen;\n\tprep.quotalen = index_key.type->def_datalen;\n\tprep.trusted = flags & KEY_ALLOC_TRUSTED;\n\tprep.expiry = TIME_T_MAX;\n\tif (index_key.type->preparse) {\n\t\tret = index_key.type->preparse(&prep);\n\t\tif (ret < 0) {\n\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\tgoto error_free_prep;\n\t\t}\n\t\tif (!index_key.description)\n\t\t\tindex_key.description = prep.description;\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (!index_key.description)\n\t\t\tgoto error_free_prep;\n\t}\n\tindex_key.desc_len = strlen(index_key.description);\n\n\tkey_ref = ERR_PTR(-EPERM);\n\tif (!prep.trusted && test_bit(KEY_FLAG_TRUSTED_ONLY, &keyring->flags))\n\t\tgoto error_free_prep;\n\tflags |= prep.trusted ? KEY_ALLOC_TRUSTED : 0;\n\n\tret = __key_link_begin(keyring, &index_key, &edit);\n\tif (ret < 0) {\n\t\tkey_ref = ERR_PTR(ret);\n\t\tgoto error_free_prep;\n\t}\n\n\t/* if we're going to allocate a new key, we're going to have\n\t * to modify the keyring */\n\tret = key_permission(keyring_ref, KEY_NEED_WRITE);\n\tif (ret < 0) {\n\t\tkey_ref = ERR_PTR(ret);\n\t\tgoto error_link_end;\n\t}\n\n\t/* if it's possible to update this type of key, search for an existing\n\t * key of the same type and description in the destination keyring and\n\t * update that instead if possible\n\t */\n\tif (index_key.type->update) {\n\t\tkey_ref = find_key_to_update(keyring_ref, &index_key);\n\t\tif (key_ref)\n\t\t\tgoto found_matching_key;\n\t}\n\n\t/* if the client doesn't provide, decide on the permissions we want */\n\tif (perm == KEY_PERM_UNDEF) {\n\t\tperm = KEY_POS_VIEW | KEY_POS_SEARCH | KEY_POS_LINK | KEY_POS_SETATTR;\n\t\tperm |= KEY_USR_VIEW;\n\n\t\tif (index_key.type->read)\n\t\t\tperm |= KEY_POS_READ;\n\n\t\tif (index_key.type == &key_type_keyring ||\n\t\t    index_key.type->update)\n\t\t\tperm |= KEY_POS_WRITE;\n\t}\n\n\t/* allocate a new key */\n\tkey = key_alloc(index_key.type, index_key.description,\n\t\t\tcred->fsuid, cred->fsgid, cred, perm, flags);\n\tif (IS_ERR(key)) {\n\t\tkey_ref = ERR_CAST(key);\n\t\tgoto error_link_end;\n\t}\n\n\t/* instantiate it and link it into the target keyring */\n\tret = __key_instantiate_and_link(key, &prep, keyring, NULL, &edit);\n\tif (ret < 0) {\n\t\tkey_put(key);\n\t\tkey_ref = ERR_PTR(ret);\n\t\tgoto error_link_end;\n\t}\n\n\tkey_ref = make_key_ref(key, is_key_possessed(keyring_ref));\n\nerror_link_end:\n\t__key_link_end(keyring, &index_key, edit);\nerror_free_prep:\n\tif (index_key.type->preparse)\n\t\tindex_key.type->free_preparse(&prep);\nerror_put_type:\n\tkey_type_put(index_key.type);\nerror:\n\treturn key_ref;\n\n found_matching_key:\n\t/* we found a matching key, so we're going to try to update it\n\t * - we can drop the locks first as we have the key pinned\n\t */\n\t__key_link_end(keyring, &index_key, edit);\n\n\tkey_ref = __key_update(key_ref, &prep);\n\tgoto error_free_prep;\n}\n", "target": 1, "idx": 181611}
{"func": "isoent_gen_joliet_identifier(struct archive_write *a, struct isoent *isoent,\n    struct idr *idr)\n{\n\tstruct iso9660 *iso9660;\n\tstruct isoent *np;\n \tunsigned char *p;\n \tsize_t l;\n \tint r;\n\tint ffmax, parent_len;\n \tstatic const struct archive_rb_tree_ops rb_ops = {\n \t\tisoent_cmp_node_joliet, isoent_cmp_key_joliet\n \t};\n\n\tif (isoent->children.cnt == 0)\n\t\treturn (0);\n\n\tiso9660 = a->format_data;\n\tif (iso9660->opt.joliet == OPT_JOLIET_LONGNAME)\n\t\tffmax = 206;\n \telse\n \t\tffmax = 128;\n \n\tr = idr_start(a, idr, isoent->children.cnt, ffmax, 6, 2, &rb_ops);\n \tif (r < 0)\n \t\treturn (r);\n \n\tparent_len = 1;\n\tfor (np = isoent; np->parent != np; np = np->parent)\n\t\tparent_len += np->mb_len + 1;\n\n\tfor (np = isoent->children.first; np != NULL; np = np->chnext) {\n\t\tunsigned char *dot;\n \t\tint ext_off, noff, weight;\n \t\tsize_t lt;\n \n\t\tif ((int)(l = np->file->basename_utf16.length) > ffmax)\n \t\t\tl = ffmax;\n \n \t\tp = malloc((l+1)*2);\n\t\tif (p == NULL) {\n\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t    \"Can't allocate memory\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tmemcpy(p, np->file->basename_utf16.s, l);\n\t\tp[l] = 0;\n\t\tp[l+1] = 0;\n\n\t\tnp->identifier = (char *)p;\n\t\tlt = l;\n\t\tdot = p + l;\n\t\tweight = 0;\n\t\twhile (lt > 0) {\n\t\t\tif (!joliet_allowed_char(p[0], p[1]))\n\t\t\t\tarchive_be16enc(p, 0x005F); /* '_' */\n\t\t\telse if (p[0] == 0 && p[1] == 0x2E) /* '.' */\n\t\t\t\tdot = p;\n\t\t\tp += 2;\n\t\t\tlt -= 2;\n\t\t}\n\t\text_off = (int)(dot - (unsigned char *)np->identifier);\n\t\tnp->ext_off = ext_off;\n\t\tnp->ext_len = (int)l - ext_off;\n\t\tnp->id_len = (int)l;\n\n \t\t/*\n \t\t * Get a length of MBS of a full-pathname.\n \t\t */\n\t\tif ((int)np->file->basename_utf16.length > ffmax) {\n \t\t\tif (archive_strncpy_l(&iso9660->mbs,\n \t\t\t    (const char *)np->identifier, l,\n \t\t\t\tiso9660->sconv_from_utf16be) != 0 &&\n\t\t\t    errno == ENOMEM) {\n\t\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\t    \"No memory\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t\tnp->mb_len = (int)iso9660->mbs.length;\n\t\t\tif (np->mb_len != (int)np->file->basename.length)\n\t\t\t\tweight = np->mb_len;\n\t\t} else\n\t\t\tnp->mb_len = (int)np->file->basename.length;\n \n \t\t/* If a length of full-pathname is longer than 240 bytes,\n \t\t * it violates Joliet extensions regulation. */\n\t\tif (parent_len + np->mb_len > 240) {\n \t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n \t\t\t    \"The regulation of Joliet extensions;\"\n \t\t\t    \" A length of a full-pathname of `%s' is \"\n\t\t\t    \"longer than 240 bytes, (p=%d, b=%d)\",\n\t\t\t    archive_entry_pathname(np->file->entry),\n\t\t\t    (int)parent_len, (int)np->mb_len);\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n \n \t\t/* Make an offset of the number which is used to be set\n \t\t * hexadecimal number to avoid duplicate identifier. */\n\t\tif ((int)l == ffmax)\n \t\t\tnoff = ext_off - 6;\n\t\telse if ((int)l == ffmax-2)\n \t\t\tnoff = ext_off - 4;\n\t\telse if ((int)l == ffmax-4)\n \t\t\tnoff = ext_off - 2;\n \t\telse\n \t\t\tnoff = ext_off;\n\t\t/* Register entry to the identifier resolver. */\n\t\tidr_register(idr, np, weight, noff);\n\t}\n\n\t/* Resolve duplicate identifier with Joliet Volume. */\n\tidr_resolve(idr, idr_set_num_beutf16);\n\n\treturn (ARCHIVE_OK);\n}\n", "target": 1, "idx": 180175}
{"func": "my_object_many_args (MyObject *obj, guint32 x, const char *str, double trouble, double *d_ret, char **str_ret, GError **error)\n{\n  *d_ret = trouble + (x * 2);\n  *str_ret = g_ascii_strup (str, -1);\n  return TRUE;\n}\n", "target": 1, "idx": 178282}
{"func": "void PreconnectManager::Start(const GURL& url,\n                              std::vector<PreconnectRequest> requests) {\n  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n  const std::string host = url.host();\n  if (preresolve_info_.find(host) != preresolve_info_.end())\n    return;\n\n  auto iterator_and_whether_inserted = preresolve_info_.emplace(\n      host, std::make_unique<PreresolveInfo>(url, requests.size()));\n  PreresolveInfo* info = iterator_and_whether_inserted.first->second.get();\n \n   for (auto request_it = requests.begin(); request_it != requests.end();\n        ++request_it) {\n    DCHECK(request_it->origin.GetOrigin() == request_it->origin);\n     PreresolveJobId job_id = preresolve_jobs_.Add(\n         std::make_unique<PreresolveJob>(std::move(*request_it), info));\n     queued_jobs_.push_back(job_id);\n  }\n\n  TryToLaunchPreresolveJobs();\n}\n", "target": 1, "idx": 186345}
{"func": " void WtsSessionProcessDelegate::Core::KillProcess(DWORD exit_code) {\n   DCHECK(main_task_runner_->BelongsToCurrentThread());\n \n   channel_.reset();\n \n   if (launch_elevated_) {\n     if (job_.IsValid()) {\n      TerminateJobObject(job_, exit_code);\n    }\n  } else {\n    if (worker_process_.IsValid()) {\n      TerminateProcess(worker_process_, exit_code);\n    }\n  }\n}\n", "target": 1, "idx": 185262}
{"func": "int dtls1_get_record(SSL *s)\n\t{\n\tint ssl_major,ssl_minor;\n\tint i,n;\n\tSSL3_RECORD *rr;\n\tunsigned char *p = NULL;\n\tunsigned short version;\n\tDTLS1_BITMAP *bitmap;\n\tunsigned int is_next_epoch;\n\n\trr= &(s->s3->rrec);\n\n\t/* The epoch may have changed.  If so, process all the\n\t * pending records.  This is a non-blocking operation. */\n\tdtls1_process_buffered_records(s);\n\n\t/* if we're renegotiating, then there may be buffered records */\n\tif (dtls1_get_processed_record(s))\n\t\treturn 1;\n\n\t/* get something from the wire */\nagain:\n\t/* check if we have the header */\n\tif (\t(s->rstate != SSL_ST_READ_BODY) ||\n\t\t(s->packet_length < DTLS1_RT_HEADER_LENGTH)) \n\t\t{\n\t\tn=ssl3_read_n(s, DTLS1_RT_HEADER_LENGTH, s->s3->rbuf.len, 0);\n\t\t/* read timeout is handled by dtls1_read_bytes */\n\t\tif (n <= 0) return(n); /* error or non-blocking */\n\n\t\t/* this packet contained a partial record, dump it */\n\t\tif (s->packet_length != DTLS1_RT_HEADER_LENGTH)\n\t\t\t{\n\t\t\ts->packet_length = 0;\n\t\t\tgoto again;\n\t\t\t}\n\n\t\ts->rstate=SSL_ST_READ_BODY;\n\n\t\tp=s->packet;\n\n\t\tif (s->msg_callback)\n\t\t\ts->msg_callback(0, 0, SSL3_RT_HEADER, p, DTLS1_RT_HEADER_LENGTH, s, s->msg_callback_arg);\n\n\t\t/* Pull apart the header into the DTLS1_RECORD */\n\t\trr->type= *(p++);\n\t\tssl_major= *(p++);\n\t\tssl_minor= *(p++);\n\t\tversion=(ssl_major<<8)|ssl_minor;\n\n\t\t/* sequence number is 64 bits, with top 2 bytes = epoch */ \n\t\tn2s(p,rr->epoch);\n\n\t\tmemcpy(&(s->s3->read_sequence[2]), p, 6);\n\t\tp+=6;\n\n\t\tn2s(p,rr->length);\n\n\t\t/* Lets check version */\n\t\tif (!s->first_packet)\n\t\t\t{\n\t\t\tif (version != s->version)\n\t\t\t\t{\n\t\t\t\t/* unexpected version, silently discard */\n\t\t\t\trr->length = 0;\n\t\t\t\ts->packet_length = 0;\n\t\t\t\tgoto again;\n\t\t\t\t}\n\t\t\t}\n\n\t\tif ((version & 0xff00) != (s->version & 0xff00))\n\t\t\t{\n\t\t\t/* wrong version, silently discard record */\n\t\t\trr->length = 0;\n\t\t\ts->packet_length = 0;\n\t\t\tgoto again;\n\t\t\t}\n\n\t\tif (rr->length > SSL3_RT_MAX_ENCRYPTED_LENGTH)\n\t\t\t{\n\t\t\t/* record too long, silently discard it */\n\t\t\trr->length = 0;\n\t\t\ts->packet_length = 0;\n\t\t\tgoto again;\n\t\t\t}\n\n\t\t/* now s->rstate == SSL_ST_READ_BODY */\n\t\t}\n\n\t/* s->rstate == SSL_ST_READ_BODY, get and decode the data */\n\n\tif (rr->length > s->packet_length-DTLS1_RT_HEADER_LENGTH)\n\t\t{\n\t\t/* now s->packet_length == DTLS1_RT_HEADER_LENGTH */\n\t\ti=rr->length;\n\t\tn=ssl3_read_n(s,i,i,1);\n\t\t/* this packet contained a partial record, dump it */\n\t\tif ( n != i)\n\t\t\t{\n\t\t\trr->length = 0;\n\t\t\ts->packet_length = 0;\n\t\t\tgoto again;\n\t\t\t}\n\n\t\t/* now n == rr->length,\n\t\t * and s->packet_length == DTLS1_RT_HEADER_LENGTH + rr->length */\n\t\t}\n\ts->rstate=SSL_ST_READ_HEADER; /* set state for later operations */\n\n\t/* match epochs.  NULL means the packet is dropped on the floor */\n\tbitmap = dtls1_get_bitmap(s, rr, &is_next_epoch);\n\tif ( bitmap == NULL)\n\t\t{\n\t\trr->length = 0;\n\t\ts->packet_length = 0;  /* dump this record */\n\t\tgoto again;   /* get another record */\n\t\t}\n\n#ifndef OPENSSL_NO_SCTP\n\t/* Only do replay check if no SCTP bio */\n\tif (!BIO_dgram_is_sctp(SSL_get_rbio(s)))\n  \t\t{\n#endif\n\t\t/* Check whether this is a repeat, or aged record.\n\t\t * Don't check if we're listening and this message is\n\t\t * a ClientHello. They can look as if they're replayed,\n\t\t * since they arrive from different connections and\n \t\t * would be dropped unnecessarily.\n \t\t */\n \t\tif (!(s->d1->listen && rr->type == SSL3_RT_HANDSHAKE &&\n\t\t    *p == SSL3_MT_CLIENT_HELLO) &&\n \t\t    !dtls1_record_replay_check(s, bitmap))\n \t\t\t{\n \t\t\trr->length = 0;\n\t\t\ts->packet_length=0; /* dump this record */\n\t\t\tgoto again;     /* get another record */\n\t\t\t}\n#ifndef OPENSSL_NO_SCTP\n  \t\t}\n#endif\n\n\t/* just read a 0 length packet */\n\tif (rr->length == 0) goto again;\n\n\t/* If this record is from the next epoch (either HM or ALERT),\n\t * and a handshake is currently in progress, buffer it since it\n\t * cannot be processed at this time. However, do not buffer\n\t * anything while listening.\n\t */\n\tif (is_next_epoch)\n\t\t{\n\t\tif ((SSL_in_init(s) || s->in_handshake) && !s->d1->listen)\n\t\t\t{\n\t\t\tdtls1_buffer_record(s, &(s->d1->unprocessed_rcds), rr->seq_num);\n\t\t\t}\n\t\trr->length = 0;\n\t\ts->packet_length = 0;\n\t\tgoto again;\n\t\t}\n\n\tif (!dtls1_process_record(s))\n\t\t{\n\t\trr->length = 0;\n\t\ts->packet_length = 0;  /* dump this record */\n\t\tgoto again;   /* get another record */\n\t\t}\n\n\treturn(1);\n\n\t}\n", "target": 1, "idx": 179999}
{"func": "static void pdf_run_v(fz_context *ctx, pdf_processor *proc, float x2, float y2, float x3, float y3)\n{\n\tpdf_run_processor *pr = (pdf_run_processor *)proc;\n\tfz_curvetov(ctx, pr->path, x2, y2, x3, y3);\n}\n", "target": 0, "idx": 548}
{"func": "FrameView::FrameView(LocalFrame* frame)\n    : m_frame(frame)\n    , m_canHaveScrollbars(true)\n    , m_slowRepaintObjectCount(0)\n    , m_hasPendingLayout(false)\n    , m_layoutSubtreeRoot(0)\n    , m_inSynchronousPostLayout(false)\n    , m_postLayoutTasksTimer(this, &FrameView::postLayoutTimerFired)\n    , m_updateWidgetsTimer(this, &FrameView::updateWidgetsTimerFired)\n    , m_isTransparent(false)\n    , m_baseBackgroundColor(Color::white)\n    , m_mediaType(\"screen\")\n    , m_overflowStatusDirty(true)\n    , m_viewportRenderer(0)\n    , m_wasScrolledByUser(false)\n    , m_inProgrammaticScroll(false)\n    , m_safeToPropagateScrollToParent(true)\n    , m_isTrackingPaintInvalidations(false)\n    , m_scrollCorner(nullptr)\n    , m_hasSoftwareFilters(false)\n    , m_visibleContentScaleFactor(1)\n     , m_inputEventsScaleFactorForEmulation(1)\n     , m_layoutSizeFixedToFrameSize(true)\n     , m_didScrollTimer(this, &FrameView::didScrollTimerFired)\n {\n     ASSERT(m_frame);\n     init();\n\n    if (!m_frame->isMainFrame())\n        return;\n\n    ScrollableArea::setVerticalScrollElasticity(ScrollElasticityAllowed);\n    ScrollableArea::setHorizontalScrollElasticity(ScrollElasticityAllowed);\n}\n", "target": 1, "idx": 185338}
{"func": "static inline int vmcs12_write_any(struct kvm_vcpu *vcpu,\n\t\t\t\t   unsigned long field, u64 field_value){\n\tshort offset = vmcs_field_to_offset(field);\n\tchar *p = ((char *) get_vmcs12(vcpu)) + offset;\n\tif (offset < 0)\n\t\treturn offset;\n\n\tswitch (vmcs_field_width(field)) {\n\tcase VMCS_FIELD_WIDTH_U16:\n\t\t*(u16 *)p = field_value;\n\t\treturn 0;\n\tcase VMCS_FIELD_WIDTH_U32:\n\t\t*(u32 *)p = field_value;\n\t\treturn 0;\n\tcase VMCS_FIELD_WIDTH_U64:\n\t\t*(u64 *)p = field_value;\n\t\treturn 0;\n\tcase VMCS_FIELD_WIDTH_NATURAL_WIDTH:\n\t\t*(natural_width *)p = field_value;\n\t\treturn 0;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -ENOENT;\n\t}\n\n}\n", "target": 0, "idx": 81004}
{"func": "OMX_ERRORTYPE SoftAACEncoder2::internalGetParameter(\n        OMX_INDEXTYPE index, OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamAudioPortFormat:\n {\n\n             OMX_AUDIO_PARAM_PORTFORMATTYPE *formatParams =\n                 (OMX_AUDIO_PARAM_PORTFORMATTYPE *)params;\n \n             if (formatParams->nPortIndex > 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n if (formatParams->nIndex > 0) {\n return OMX_ErrorNoMore;\n }\n\n            formatParams->eEncoding =\n (formatParams->nPortIndex == 0)\n ? OMX_AUDIO_CodingPCM : OMX_AUDIO_CodingAAC;\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioAac:\n {\n\n             OMX_AUDIO_PARAM_AACPROFILETYPE *aacParams =\n                 (OMX_AUDIO_PARAM_AACPROFILETYPE *)params;\n \n             if (aacParams->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            aacParams->nBitRate = mBitRate;\n            aacParams->nAudioBandWidth = 0;\n            aacParams->nAACtools = 0;\n            aacParams->nAACERtools = 0;\n            aacParams->eAACProfile = (OMX_AUDIO_AACPROFILETYPE) mAACProfile;\n            aacParams->eAACStreamFormat = OMX_AUDIO_AACStreamFormatMP4FF;\n            aacParams->eChannelMode = OMX_AUDIO_ChannelModeStereo;\n\n            aacParams->nChannels = mNumChannels;\n            aacParams->nSampleRate = mSampleRate;\n            aacParams->nFrameLength = 0;\n\n switch (mSBRMode) {\n case 1: // sbr on\n switch (mSBRRatio) {\n case 0:\n                    aacParams->nAACtools |= OMX_AUDIO_AACToolAndroidSSBR;\n                    aacParams->nAACtools |= OMX_AUDIO_AACToolAndroidDSBR;\n break;\n case 1:\n                    aacParams->nAACtools |= OMX_AUDIO_AACToolAndroidSSBR;\n                    aacParams->nAACtools &= ~OMX_AUDIO_AACToolAndroidDSBR;\n break;\n case 2:\n                    aacParams->nAACtools &= ~OMX_AUDIO_AACToolAndroidSSBR;\n                    aacParams->nAACtools |= OMX_AUDIO_AACToolAndroidDSBR;\n break;\n default:\n                    ALOGE(\"invalid SBR ratio %d\", mSBRRatio);\n                    TRESPASS();\n }\n break;\n case 0: // sbr off\n case -1: // sbr undefined\n                aacParams->nAACtools &= ~OMX_AUDIO_AACToolAndroidSSBR;\n                aacParams->nAACtools &= ~OMX_AUDIO_AACToolAndroidDSBR;\n break;\n default:\n                ALOGE(\"invalid SBR mode %d\", mSBRMode);\n                TRESPASS();\n }\n\n\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioPcm:\n {\n\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex != 0) {\n                 return OMX_ErrorUndefined;\n             }\n\n            pcmParams->eNumData = OMX_NumericalDataSigned;\n            pcmParams->eEndian = OMX_EndianBig;\n            pcmParams->bInterleaved = OMX_TRUE;\n            pcmParams->nBitPerSample = 16;\n            pcmParams->ePCMMode = OMX_AUDIO_PCMModeLinear;\n            pcmParams->eChannelMapping[0] = OMX_AUDIO_ChannelLF;\n            pcmParams->eChannelMapping[1] = OMX_AUDIO_ChannelRF;\n\n            pcmParams->nChannels = mNumChannels;\n            pcmParams->nSamplingRate = mSampleRate;\n\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalGetParameter(index, params);\n }\n}\n", "target": 1, "idx": 188212}
{"func": "void FragmentPaintPropertyTreeBuilder::UpdateFragmentClip() {\n  DCHECK(properties_);\n\n   if (NeedsPaintPropertyUpdate()) {\n     if (context_.fragment_clip) {\n       OnUpdateClip(properties_->UpdateFragmentClip(\n          context_.current.clip,\n           ClipPaintPropertyNode::State{context_.current.transform,\n                                        ToClipRect(*context_.fragment_clip)}));\n     } else {\n      OnClearClip(properties_->ClearFragmentClip());\n    }\n  }\n\n  if (properties_->FragmentClip())\n    context_.current.clip = properties_->FragmentClip();\n}\n", "target": 1, "idx": 185674}
{"func": "ProcessIdToFilterMap* GetProcessIdToFilterMap() {\n  static base::NoDestructor<ProcessIdToFilterMap> instance;\n  return instance.get();\n}\n", "target": 1, "idx": 187023}
{"func": "int wasm_dis(WasmOp *op, const unsigned char *buf, int buf_len) {\n\top->len = 1;\n\top->op = buf[0];\n\tif (op->op > 0xbf) {\n\t\treturn 1;\n\t}\n\tWasmOpDef *opdef = &opcodes[op->op];\n\tswitch (op->op) {\n\tcase WASM_OP_TRAP:\n\tcase WASM_OP_NOP:\n\tcase WASM_OP_ELSE:\n\tcase WASM_OP_RETURN:\n\tcase WASM_OP_DROP:\n\tcase WASM_OP_SELECT:\n\tcase WASM_OP_I32EQZ:\n\tcase WASM_OP_I32EQ:\n\tcase WASM_OP_I32NE:\n\tcase WASM_OP_I32LTS:\n\tcase WASM_OP_I32LTU:\n\tcase WASM_OP_I32GTS:\n\tcase WASM_OP_I32GTU:\n\tcase WASM_OP_I32LES:\n\tcase WASM_OP_I32LEU:\n\tcase WASM_OP_I32GES:\n\tcase WASM_OP_I32GEU:\n\tcase WASM_OP_I64EQZ:\n\tcase WASM_OP_I64EQ:\n\tcase WASM_OP_I64NE:\n\tcase WASM_OP_I64LTS:\n\tcase WASM_OP_I64LTU:\n\tcase WASM_OP_I64GTS:\n\tcase WASM_OP_I64GTU:\n\tcase WASM_OP_I64LES:\n\tcase WASM_OP_I64LEU:\n\tcase WASM_OP_I64GES:\n\tcase WASM_OP_I64GEU:\n\tcase WASM_OP_F32EQ:\n\tcase WASM_OP_F32NE:\n\tcase WASM_OP_F32LT:\n\tcase WASM_OP_F32GT:\n\tcase WASM_OP_F32LE:\n\tcase WASM_OP_F32GE:\n\tcase WASM_OP_F64EQ:\n\tcase WASM_OP_F64NE:\n\tcase WASM_OP_F64LT:\n\tcase WASM_OP_F64GT:\n\tcase WASM_OP_F64LE:\n\tcase WASM_OP_F64GE:\n\tcase WASM_OP_I32CLZ:\n\tcase WASM_OP_I32CTZ:\n\tcase WASM_OP_I32POPCNT:\n\tcase WASM_OP_I32ADD:\n\tcase WASM_OP_I32SUB:\n\tcase WASM_OP_I32MUL:\n\tcase WASM_OP_I32DIVS:\n\tcase WASM_OP_I32DIVU:\n\tcase WASM_OP_I32REMS:\n\tcase WASM_OP_I32REMU:\n\tcase WASM_OP_I32AND:\n\tcase WASM_OP_I32OR:\n\tcase WASM_OP_I32XOR:\n\tcase WASM_OP_I32SHL:\n\tcase WASM_OP_I32SHRS:\n\tcase WASM_OP_I32SHRU:\n\tcase WASM_OP_I32ROTL:\n\tcase WASM_OP_I32ROTR:\n\tcase WASM_OP_I64CLZ:\n\tcase WASM_OP_I64CTZ:\n\tcase WASM_OP_I64POPCNT:\n\tcase WASM_OP_I64ADD:\n\tcase WASM_OP_I64SUB:\n\tcase WASM_OP_I64MUL:\n\tcase WASM_OP_I64DIVS:\n\tcase WASM_OP_I64DIVU:\n\tcase WASM_OP_I64REMS:\n\tcase WASM_OP_I64REMU:\n\tcase WASM_OP_I64AND:\n\tcase WASM_OP_I64OR:\n\tcase WASM_OP_I64XOR:\n\tcase WASM_OP_I64SHL:\n\tcase WASM_OP_I64SHRS:\n\tcase WASM_OP_I64SHRU:\n\tcase WASM_OP_I64ROTL:\n\tcase WASM_OP_I64ROTR:\n\tcase WASM_OP_F32ABS:\n\tcase WASM_OP_F32NEG:\n\tcase WASM_OP_F32CEIL:\n\tcase WASM_OP_F32FLOOR:\n\tcase WASM_OP_F32TRUNC:\n\tcase WASM_OP_F32NEAREST:\n\tcase WASM_OP_F32SQRT:\n\tcase WASM_OP_F32ADD:\n\tcase WASM_OP_F32SUB:\n\tcase WASM_OP_F32MUL:\n\tcase WASM_OP_F32DIV:\n\tcase WASM_OP_F32MIN:\n\tcase WASM_OP_F32MAX:\n\tcase WASM_OP_F32COPYSIGN:\n\tcase WASM_OP_F64ABS:\n\tcase WASM_OP_F64NEG:\n\tcase WASM_OP_F64CEIL:\n\tcase WASM_OP_F64FLOOR:\n\tcase WASM_OP_F64TRUNC:\n\tcase WASM_OP_F64NEAREST:\n\tcase WASM_OP_F64SQRT:\n\tcase WASM_OP_F64ADD:\n\tcase WASM_OP_F64SUB:\n\tcase WASM_OP_F64MUL:\n\tcase WASM_OP_F64DIV:\n\tcase WASM_OP_F64MIN:\n\tcase WASM_OP_F64MAX:\n\tcase WASM_OP_F64COPYSIGN:\n\tcase WASM_OP_I32WRAPI64:\n\tcase WASM_OP_I32TRUNCSF32:\n\tcase WASM_OP_I32TRUNCUF32:\n\tcase WASM_OP_I32TRUNCSF64:\n\tcase WASM_OP_I32TRUNCUF64:\n\tcase WASM_OP_I64EXTENDSI32:\n\tcase WASM_OP_I64EXTENDUI32:\n\tcase WASM_OP_I64TRUNCSF32:\n\tcase WASM_OP_I64TRUNCUF32:\n\tcase WASM_OP_I64TRUNCSF64:\n\tcase WASM_OP_I64TRUNCUF64:\n\tcase WASM_OP_F32CONVERTSI32:\n\tcase WASM_OP_F32CONVERTUI32:\n\tcase WASM_OP_F32CONVERTSI64:\n\tcase WASM_OP_F32CONVERTUI64:\n\tcase WASM_OP_F32DEMOTEF64:\n\tcase WASM_OP_F64CONVERTSI32:\n\tcase WASM_OP_F64CONVERTUI32:\n\tcase WASM_OP_F64CONVERTSI64:\n\tcase WASM_OP_F64CONVERTUI64:\n\tcase WASM_OP_F64PROMOTEF32:\n\tcase WASM_OP_I32REINTERPRETF32:\n\tcase WASM_OP_I64REINTERPRETF64:\n\tcase WASM_OP_F32REINTERPRETI32:\n\tcase WASM_OP_F64REINTERPRETI64:\n\tcase WASM_OP_END:\n\t\t{\n\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s\", opdef->txt);\n\t\t}\n\t\tbreak;\n\tcase WASM_OP_BLOCK:\n\tcase WASM_OP_LOOP:\n\tcase WASM_OP_IF:\n\t\t{\n\t\t\tst32 val = 0;\n\t\t\tsize_t n = read_i32_leb128 (buf + 1, buf + buf_len, &val);\n\t\t\tif (!(n > 0 && n < buf_len)) goto err;\n\t\t\tswitch (0x80 - val) {\n\t\t\tcase R_BIN_WASM_VALUETYPE_EMPTY:\n\t\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s\", opdef->txt);\n\t\t\t\tbreak;\n\t\t\tcase R_BIN_WASM_VALUETYPE_i32:\n\t\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s (result i32)\", opdef->txt);\n\t\t\t\tbreak;\n\t\t\tcase R_BIN_WASM_VALUETYPE_i64:\n\t\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s (result i64)\", opdef->txt);\n\t\t\t\tbreak;\n\t\t\tcase R_BIN_WASM_VALUETYPE_f32:\n\t\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s (result f32)\", opdef->txt);\n\t\t\t\tbreak;\n\t\t\tcase R_BIN_WASM_VALUETYPE_f64:\n\t\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s (result f64)\", opdef->txt);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s (result ?)\", opdef->txt);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\top->len += n;\n\t\t}\n\t\tbreak;\n\tcase WASM_OP_BR:\n\tcase WASM_OP_BRIF:\n\tcase WASM_OP_CALL:\n\t\t{\n\t\t\tut32 val = 0;\n\t\t\tsize_t n = read_u32_leb128 (buf + 1, buf + buf_len, &val);\n\t\t\tif (!(n > 0 && n < buf_len)) goto err;\n\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s %d\", opdef->txt, val);\n\t\t\top->len += n;\n\t\t}\n\t\tbreak;\n\tcase WASM_OP_BRTABLE:\n\t\t{\n\t\t\tut32 count = 0, *table = NULL, def = 0;\n\t\t\tsize_t n = read_u32_leb128 (buf + 1, buf + buf_len, &count);\n\t\t\tif (!(n > 0 && n < buf_len)) {\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tif (!(table = calloc (count, sizeof (ut32)))) {\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tint i = 0;\n\t\t\top->len += n;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tn = read_u32_leb128 (buf + op->len, buf + buf_len, &table[i]);\n\t\t\t\tif (!(op->len + n <= buf_len)) {\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\top->len += n;\n\t\t\t}\n\t\t\tn = read_u32_leb128 (buf + op->len, buf + buf_len, &def);\n\t\t\tif (!(n > 0 && n + op->len < buf_len)) {\n\t\t\t\tgoto beach;\n \t\t\t}\n \t\t\top->len += n;\n \t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s %d \", opdef->txt, count);\n\t\t\tfor (i = 0; i < count && strlen (op->txt) + 10 < R_ASM_BUFSIZE; i++) {\n\t\t\t\tint optxtlen = strlen (op->txt);\n\t\t\t\tsnprintf (op->txt + optxtlen, R_ASM_BUFSIZE - optxtlen, \"%d \", table[i]);\n \t\t\t}\n\t\t\tsnprintf (op->txt + strlen (op->txt), R_ASM_BUFSIZE, \"%d\", def);\n \t\t\tfree (table);\n \t\t\tbreak;\n\t\t\tbeach:\n \t\t\tfree (table);\n \t\t\tgoto err;\n \t\t}\n\t\tbreak;\n\tcase WASM_OP_CALLINDIRECT:\n\t\t{\n\t\t\tut32 val = 0, reserved = 0;\n\t\t\tsize_t n = read_u32_leb128 (buf + 1, buf + buf_len, &val);\n\t\t\tif (!(n > 0 && n < buf_len)) goto err;\n\t\t\top->len += n;\n\t\t\tn = read_u32_leb128 (buf + op->len, buf + buf_len, &reserved);\n\t\t\tif (!(n == 1 && op->len + n <= buf_len)) goto err;\n\t\t\treserved &= 0x1;\n\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s %d %d\", opdef->txt, val, reserved);\n\t\t\top->len += n;\n\t\t}\n\t\tbreak;\n\tcase WASM_OP_GETLOCAL:\n\tcase WASM_OP_SETLOCAL:\n\tcase WASM_OP_TEELOCAL:\n\tcase WASM_OP_GETGLOBAL:\n\tcase WASM_OP_SETGLOBAL:\n\t\t{\n\t\t\tut32 val = 0;\n\t\t\tsize_t n = read_u32_leb128 (buf + 1, buf + buf_len, &val);\n\t\t\tif (!(n > 0 && n < buf_len)) goto err;\n\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s %d\", opdef->txt, val);\n\t\t\top->len += n;\n\t\t}\n\t\tbreak;\n\tcase WASM_OP_I32LOAD:\n\tcase WASM_OP_I64LOAD:\n\tcase WASM_OP_F32LOAD:\n\tcase WASM_OP_F64LOAD:\n\tcase WASM_OP_I32LOAD8S:\n\tcase WASM_OP_I32LOAD8U:\n\tcase WASM_OP_I32LOAD16S:\n\tcase WASM_OP_I32LOAD16U:\n\tcase WASM_OP_I64LOAD8S:\n\tcase WASM_OP_I64LOAD8U:\n\tcase WASM_OP_I64LOAD16S:\n\tcase WASM_OP_I64LOAD16U:\n\tcase WASM_OP_I64LOAD32S:\n\tcase WASM_OP_I64LOAD32U:\n\tcase WASM_OP_I32STORE:\n\tcase WASM_OP_I64STORE:\n\tcase WASM_OP_F32STORE:\n\tcase WASM_OP_F64STORE:\n\tcase WASM_OP_I32STORE8:\n\tcase WASM_OP_I32STORE16:\n\tcase WASM_OP_I64STORE8:\n\tcase WASM_OP_I64STORE16:\n\tcase WASM_OP_I64STORE32:\n\t\t{\n\t\t\tut32 flag = 0, offset = 0;\n\t\t\tsize_t n = read_u32_leb128 (buf + 1, buf + buf_len, &flag);\n\t\t\tif (!(n > 0 && n < buf_len)) goto err;\n\t\t\top->len += n;\n\t\t\tn = read_u32_leb128 (buf + op->len, buf + buf_len, &offset);\n\t\t\tif (!(n > 0 && op->len + n <= buf_len)) goto err;\n\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s %d %d\", opdef->txt, flag, offset);\n\t\t\top->len += n;\n\t\t}\n\t\tbreak;\n\tcase WASM_OP_CURRENTMEMORY:\n\tcase WASM_OP_GROWMEMORY:\n\t\t{\n\t\t\tut32 reserved = 0;\n\t\t\tsize_t n = read_u32_leb128 (buf + 1, buf + buf_len, &reserved);\n\t\t\tif (!(n == 1 && n < buf_len)) goto err;\n\t\t\treserved &= 0x1;\n\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s %d\", opdef->txt, reserved);\n\t\t\top->len += n;\n\t\t}\n\t\tbreak;\n\n\tcase WASM_OP_I32CONST:\n\t\t{\n\t\t\tst32 val = 0;\n\t\t\tsize_t n = read_i32_leb128 (buf + 1, buf + buf_len, &val);\n\t\t\tif (!(n > 0 && n < buf_len)) goto err;\n\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s %\" PFMT32d, opdef->txt, val);\n\t\t\top->len += n;\n\t\t}\n\t\tbreak;\n\tcase WASM_OP_I64CONST:\n\t\t{\n\t\t\tst64 val = 0;\n\t\t\tsize_t n = read_i64_leb128 (buf + 1, buf + buf_len, &val);\n\t\t\tif (!(n > 0 && n < buf_len)) goto err;\n\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s %\" PFMT64d, opdef->txt, val);\n\t\t\top->len += n;\n\t\t}\n\t\tbreak;\n\tcase WASM_OP_F32CONST:\n\t\t{\n\t\t\tut32 val = 0;\n\t\t\tsize_t n = read_u32_leb128 (buf + 1, buf + buf_len, &val);\n\t\t\tif (!(n > 0 && n < buf_len)) goto err;\n\t\t\tlong double d =  (long double)val;\n\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s %\" LDBLFMT, opdef->txt, d);\n\t\t\top->len += n;\n\t\t}\n\t\tbreak;\n\tcase WASM_OP_F64CONST:\n\t\t{\n\t\t\tut64 val = 0;\n\t\t\tsize_t n = read_u64_leb128 (buf + 1, buf + buf_len, &val);\n\t\t\tif (!(n > 0 && n < buf_len)) goto err;\n\t\t\tlong double d =  (long double)val;\n\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s %\" LDBLFMT, opdef->txt, d);\n\t\t\top->len += n;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tgoto err;\n\t}\n\n\treturn op->len;\n\nerr:\n\top->len = 1;\n\tsnprintf (op->txt, R_ASM_BUFSIZE, \"invalid\");\n\treturn op->len;\n}\n", "target": 1, "idx": 182402}
{"func": "static Image *ReadGROUP4Image(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent];\n\n  FILE\n    *file;\n\n  Image\n    *image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  size_t\n    length;\n\n  ssize_t\n    offset,\n    strip_offset;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Write raw CCITT Group 4 wrapped as a TIFF image file.\n  */\n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(filename);\n  if (unique_file != -1)\n    file=fdopen(unique_file,\"wb\");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    ThrowImageException(FileOpenError,\"UnableToCreateTemporaryFile\");\n  length=fwrite(\"\\111\\111\\052\\000\\010\\000\\000\\000\\016\\000\",1,10,file);\n  length=fwrite(\"\\376\\000\\003\\000\\001\\000\\000\\000\\000\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\000\\001\\004\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,image->columns);\n  length=fwrite(\"\\001\\001\\004\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,image->rows);\n  length=fwrite(\"\\002\\001\\003\\000\\001\\000\\000\\000\\001\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\003\\001\\003\\000\\001\\000\\000\\000\\004\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\006\\001\\003\\000\\001\\000\\000\\000\\000\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\021\\001\\003\\000\\001\\000\\000\\000\",1,8,file);\n  strip_offset=10+(12*14)+4+8;\n  length=WriteLSBLong(file,(size_t) strip_offset);\n  length=fwrite(\"\\022\\001\\003\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(size_t) image_info->orientation);\n  length=fwrite(\"\\025\\001\\003\\000\\001\\000\\000\\000\\001\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\026\\001\\004\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,image->rows);\n  length=fwrite(\"\\027\\001\\004\\000\\001\\000\\000\\000\\000\\000\\000\\000\",1,12,file);\n  offset=(ssize_t) ftell(file)-4;\n  length=fwrite(\"\\032\\001\\005\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(size_t) (strip_offset-8));\n  length=fwrite(\"\\033\\001\\005\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(size_t) (strip_offset-8));\n  length=fwrite(\"\\050\\001\\003\\000\\001\\000\\000\\000\\002\\000\\000\\000\",1,12,file);\n   length=fwrite(\"\\000\\000\\000\\000\",1,4,file);\n   length=WriteLSBLong(file,(long) image->resolution.x);\n   length=WriteLSBLong(file,1);\n   for (length=0; (c=ReadBlobByte(image)) != EOF; length++)\n    (void) fputc(c,file);\n   offset=(ssize_t) fseek(file,(ssize_t) offset,SEEK_SET);\n   length=WriteLSBLong(file,(unsigned int) length);\n   (void) fclose(file);\n  (void) CloseBlob(image);\n  image=DestroyImage(image);\n  /*\n    Read TIFF image.\n  */\n  read_info=CloneImageInfo((ImageInfo *) NULL);\n  (void) FormatLocaleString(read_info->filename,MagickPathExtent,\"%s\",filename);\n  image=ReadTIFFImage(read_info,exception);\n  read_info=DestroyImageInfo(read_info);\n  if (image != (Image *) NULL)\n    {\n      (void) CopyMagickString(image->filename,image_info->filename,\n        MagickPathExtent);\n      (void) CopyMagickString(image->magick_filename,image_info->filename,\n        MagickPathExtent);\n       (void) CopyMagickString(image->magick,\"GROUP4\",MagickPathExtent);\n     }\n   (void) RelinquishUniqueFileResource(filename);\n   return(image);\n }\n", "target": 1, "idx": 181799}
{"func": "static int encrypt(struct blkcipher_desc *desc,\n\t\t   struct scatterlist *dst, struct scatterlist *src,\n\t\t   unsigned int nbytes)\n{\n\tstruct blkcipher_walk walk;\n\tstruct crypto_blkcipher *tfm = desc->tfm;\n\tstruct salsa20_ctx *ctx = crypto_blkcipher_ctx(tfm);\n\tint err;\n\n\tblkcipher_walk_init(&walk, dst, src, nbytes);\n\terr = blkcipher_walk_virt_block(desc, &walk, 64);\n \n \tsalsa20_ivsetup(ctx, walk.iv);\n \n\tif (likely(walk.nbytes == nbytes))\n\t{\n\t\tsalsa20_encrypt_bytes(ctx, walk.dst.virt.addr,\n\t\t\t\t      walk.src.virt.addr, nbytes);\n\t\treturn blkcipher_walk_done(desc, &walk, 0);\n\t}\n \twhile (walk.nbytes >= 64) {\n \t\tsalsa20_encrypt_bytes(ctx, walk.dst.virt.addr,\n \t\t\t\t      walk.src.virt.addr,\n\t\t\t\t      walk.nbytes - (walk.nbytes % 64));\n\t\terr = blkcipher_walk_done(desc, &walk, walk.nbytes % 64);\n\t}\n\n\tif (walk.nbytes) {\n\t\tsalsa20_encrypt_bytes(ctx, walk.dst.virt.addr,\n\t\t\t\t      walk.src.virt.addr, walk.nbytes);\n\t\terr = blkcipher_walk_done(desc, &walk, 0);\n\t}\n\n\treturn err;\n}\n", "target": 1, "idx": 180824}
{"func": "static bool vmxnet3_interrupt_asserted(VMXNET3State *s, int lidx)\n{\n    return s->interrupt_states[lidx].is_asserted;\n}\n", "target": 0, "idx": 9011}
{"func": "  CacheThread() : base::Thread(\"CacheThread_BlockFile\") {\n    CHECK(\n        StartWithOptions(base::Thread::Options(base::MessageLoop::TYPE_IO, 0)));\n  }\n", "target": 0, "idx": 160005}
{"func": "ia64_patch_vtop (unsigned long start, unsigned long end)\n{\n\ts32 *offp = (s32 *) start;\n\tu64 ip;\n\n\twhile (offp < (s32 *) end) {\n\t\tip = (u64) offp + *offp;\n\n\t\t/* replace virtual address with corresponding physical address: */\n\t\tia64_patch_imm64(ip, ia64_tpa(get_imm64(ip)));\n\t\tia64_fc((void *) ip);\n\t\t++offp;\n\t}\n\tia64_sync_i();\n \tia64_srlz_i();\n }\n", "target": 0, "idx": 74756}
{"func": "int _our_safe_pcap_next_ex(pcap_t *pcap, struct pcap_pkthdr **pkthdr,\n        const u_char **pktdata, const char *funcname,\n        const int line, const char *file)\n{\n    int res = pcap_next_ex(pcap, pkthdr, pktdata);\n\n    if (*pktdata && *pkthdr) {\n        if ((*pkthdr)->len > MAXPACKET) {\n            fprintf(stderr, \"safe_pcap_next_ex ERROR: Invalid packet length in %s:%s() line %d: %u is greater than maximum %u\\n\",\n                    file, funcname, line, (*pkthdr)->len, MAXPACKET);\n             exit(-1);\n         }\n \n        if ((*pkthdr)->len < (*pkthdr)->caplen) {\n            fprintf(stderr, \"safe_pcap_next_ex ERROR: Invalid packet length in %s:%s() line %d: packet length %u is less than capture length %u\\n\",\n                     file, funcname, line, (*pkthdr)->len, (*pkthdr)->caplen);\n             exit(-1);\n         }\n    }\n\n    return res;\n}\n", "target": 1, "idx": 182119}
{"func": "load(ImlibImage * im, ImlibProgressFunction progress,\n     char progress_granularity, char immediate_load)\n{\n   int                 rc;\n   char                p = ' ', numbers = 3, count = 0;\n   int                 w = 0, h = 0, v = 255, c = 0;\n   char                buf[256];\n   FILE               *f = NULL;\n\n   if (im->data)\n      return 0;\n   f = fopen(im->real_file, \"rb\");\n   if (!f)\n      return 0;\n\n   /* can't use fgets(), because there might be\n    * binary data after the header and there\n    * needn't be a newline before the data, so\n    * no chance to distinguish between end of buffer\n    * and a binary 0.\n    */\n\n   /* read the header info */\n\n   rc = 0;                      /* Error */\n\n   c = fgetc(f);\n   if (c != 'P')\n      goto quit;\n\n   p = fgetc(f);\n   if (p == '1' || p == '4')\n      numbers = 2;              /* bitimages don't have max value */\n\n   if ((p < '1') || (p > '8'))\n      goto quit;\n\n   count = 0;\n   while (count < numbers)\n     {\n        c = fgetc(f);\n\n        if (c == EOF)\n           goto quit;\n\n        /* eat whitespace */\n        while (isspace(c))\n           c = fgetc(f);\n        /* if comment, eat that */\n        if (c == '#')\n          {\n             do\n                c = fgetc(f);\n             while (c != '\\n' && c != EOF);\n          }\n        /* no comment -> proceed */\n        else\n          {\n             int                 i = 0;\n\n             /* read numbers */\n             while (c != EOF && !isspace(c) && (i < 255))\n               {\n                  buf[i++] = c;\n                  c = fgetc(f);\n               }\n             if (i)\n               {\n                  buf[i] = 0;\n                  count++;\n                  switch (count)\n                    {\n                       /* width */\n                    case 1:\n                       w = atoi(buf);\n                       break;\n                       /* height */\n                    case 2:\n                       h = atoi(buf);\n                       break;\n                       /* max value, only for color and greyscale */\n                    case 3:\n                       v = atoi(buf);\n                       break;\n                    }\n               }\n          }\n     }\n   if ((v < 0) || (v > 255))\n      goto quit;\n\n   im->w = w;\n   im->h = h;\n   if (!IMAGE_DIMENSIONS_OK(w, h))\n      goto quit;\n\n   if (!im->format)\n     {\n        if (p == '8')\n           SET_FLAG(im->flags, F_HAS_ALPHA);\n        else\n           UNSET_FLAG(im->flags, F_HAS_ALPHA);\n        im->format = strdup(\"pnm\");\n     }\n\n   rc = 1;                      /* Ok */\n\n   if (((!im->data) && (im->loader)) || (immediate_load) || (progress))\n     {\n        DATA8              *data = NULL;        /* for the binary versions */\n        DATA8              *ptr = NULL;\n        int                *idata = NULL;       /* for the ASCII versions */\n        int                *iptr;\n        char                buf2[256];\n        DATA32             *ptr2;\n        int                 i, j, x, y, pl = 0;\n        char                pper = 0;\n\n        /* must set the im->data member before callign progress function */\n        ptr2 = im->data = malloc(w * h * sizeof(DATA32));\n        if (!im->data)\n           goto quit_error;\n\n        /* start reading the data */\n        switch (p)\n          {\n          case '1':            /* ASCII monochrome */\n             buf[0] = 0;\n             i = 0;\n             for (y = 0; y < h; y++)\n               {\n                  x = 0;\n                  while (x < w)\n                    {\n                       if (!buf[i])     /* fill buffer */\n                         {\n                            if (!fgets(buf, 255, f))\n                               goto quit_error;\n                            i = 0;\n                         }\n                       while (buf[i] && isspace(buf[i]))\n                          i++;\n                       if (buf[i])\n                         {\n                            if (buf[i] == '1')\n                               *ptr2 = 0xff000000;\n                            else if (buf[i] == '0')\n                               *ptr2 = 0xffffffff;\n                            else\n                               goto quit_error;\n                            ptr2++;\n                            i++;\n                         }\n                    }\n                  if (progress &&\n                      do_progress(im, progress, progress_granularity,\n                                  &pper, &pl, y))\n                     goto quit_progress;\n               }\n             break;\n          case '2':            /* ASCII greyscale */\n             idata = malloc(sizeof(int) * w);\n             if (!idata)\n                goto quit_error;\n\n             buf[0] = 0;\n             i = 0;\n             j = 0;\n             for (y = 0; y < h; y++)\n               {\n                  iptr = idata;\n                  x = 0;\n                  while (x < w)\n                    {\n                       int                 k;\n\n                       /* check 4 chars ahead to see if we need to\n                        * fill the buffer */\n                       for (k = 0; k < 4; k++)\n                         {\n                            if (!buf[i + k])    /* fill buffer */\n                              {\n                                 if (fseek(f, -k, SEEK_CUR) == -1 ||\n                                     !fgets(buf, 255, f))\n                                    goto quit_error;\n                                 i = 0;\n                                 break;\n                              }\n                         }\n                       while (buf[i] && isspace(buf[i]))\n                          i++;\n                       while (buf[i] && !isspace(buf[i]))\n                          buf2[j++] = buf[i++];\n                       if (j)\n                         {\n                            buf2[j] = 0;\n                            *(iptr++) = atoi(buf2);\n                            j = 0;\n                            x++;\n                          }\n                     }\n                   iptr = idata;\n                  if (v == 255)\n                     {\n                        for (x = 0; x < w; x++)\n                          {\n                            *ptr2 =\n                               0xff000000 | (iptr[0] << 16) | (iptr[0] << 8)\n                               | iptr[0];\n                            ptr2++;\n                            iptr++;\n                         }\n                    }\n                  else\n                    {\n                       for (x = 0; x < w; x++)\n                         {\n                            *ptr2 =\n                               0xff000000 |\n                               (((iptr[0] * 255) / v) << 16) |\n                               (((iptr[0] * 255) / v) << 8) |\n                               ((iptr[0] * 255) / v);\n                            ptr2++;\n                            iptr++;\n                         }\n                    }\n                  if (progress &&\n                      do_progress(im, progress, progress_granularity,\n                                  &pper, &pl, y))\n                     goto quit_progress;\n               }\n             break;\n          case '3':            /* ASCII RGB */\n             idata = malloc(3 * sizeof(int) * w);\n             if (!idata)\n                goto quit_error;\n\n             buf[0] = 0;\n             i = 0;\n             j = 0;\n             for (y = 0; y < h; y++)\n               {\n                  int                 w3 = 3 * w;\n\n                  iptr = idata;\n                  x = 0;\n                  while (x < w3)\n                    {\n                       int                 k;\n\n                       /* check 4 chars ahead to see if we need to\n                        * fill the buffer */\n                       for (k = 0; k < 4; k++)\n                         {\n                            if (!buf[i + k])    /* fill buffer */\n                              {\n                                 if (fseek(f, -k, SEEK_CUR) == -1 ||\n                                     !fgets(buf, 255, f))\n                                    goto quit_error;\n                                 i = 0;\n                                 break;\n                              }\n                         }\n                       while (buf[i] && isspace(buf[i]))\n                          i++;\n                       while (buf[i] && !isspace(buf[i]))\n                          buf2[j++] = buf[i++];\n                       if (j)\n                         {\n                            buf2[j] = 0;\n                            *(iptr++) = atoi(buf2);\n                            j = 0;\n                            x++;\n                          }\n                     }\n                   iptr = idata;\n                  if (v == 255)\n                     {\n                        for (x = 0; x < w; x++)\n                          {\n                            *ptr2 =\n                               0xff000000 | (iptr[0] << 16) | (iptr[1] << 8)\n                               | iptr[2];\n                            ptr2++;\n                            iptr += 3;\n                         }\n                    }\n                  else\n                    {\n                       for (x = 0; x < w; x++)\n                         {\n                            *ptr2 =\n                               0xff000000 |\n                               (((iptr[0] * 255) / v) << 16) |\n                               (((iptr[1] * 255) / v) << 8) |\n                               ((iptr[2] * 255) / v);\n                            ptr2++;\n                            iptr += 3;\n                         }\n                    }\n                  if (progress &&\n                      do_progress(im, progress, progress_granularity,\n                                  &pper, &pl, y))\n                     goto quit_progress;\n               }\n             break;\n          case '4':            /* binary 1bit monochrome */\n             data = malloc((w + 7) / 8 * sizeof(DATA8));\n             if (!data)\n                goto quit_error;\n\n             ptr2 = im->data;\n             for (y = 0; y < h; y++)\n               {\n                  if (!fread(data, (w + 7) / 8, 1, f))\n                     goto quit_error;\n\n                  ptr = data;\n                  for (x = 0; x < w; x += 8)\n                    {\n                       j = (w - x >= 8) ? 8 : w - x;\n                       for (i = 0; i < j; i++)\n                         {\n                            if (ptr[0] & (0x80 >> i))\n                               *ptr2 = 0xff000000;\n                            else\n                               *ptr2 = 0xffffffff;\n                            ptr2++;\n                         }\n                       ptr++;\n                    }\n                  if (progress &&\n                      do_progress(im, progress, progress_granularity,\n                                  &pper, &pl, y))\n                     goto quit_progress;\n               }\n             break;\n          case '5':            /* binary 8bit grayscale GGGGGGGG */\n             data = malloc(1 * sizeof(DATA8) * w);\n             if (!data)\n                goto quit_error;\n\n             ptr2 = im->data;\n             for (y = 0; y < h; y++)\n               {\n                  if (!fread(data, w * 1, 1, f))\n                      break;\n \n                   ptr = data;\n                  if (v == 255)\n                     {\n                        for (x = 0; x < w; x++)\n                          {\n                            *ptr2 =\n                               0xff000000 | (ptr[0] << 16) | (ptr[0] << 8) |\n                               ptr[0];\n                            ptr2++;\n                            ptr++;\n                         }\n                    }\n                  else\n                    {\n                       for (x = 0; x < w; x++)\n                         {\n                            *ptr2 =\n                               0xff000000 |\n                               (((ptr[0] * 255) / v) << 16) |\n                               (((ptr[0] * 255) / v) << 8) |\n                               ((ptr[0] * 255) / v);\n                            ptr2++;\n                            ptr++;\n                         }\n                    }\n                  if (progress &&\n                      do_progress(im, progress, progress_granularity,\n                                  &pper, &pl, y))\n                     goto quit_progress;\n               }\n             break;\n          case '6':            /* 24bit binary RGBRGBRGB */\n             data = malloc(3 * sizeof(DATA8) * w);\n             if (!data)\n                goto quit_error;\n\n             ptr2 = im->data;\n             for (y = 0; y < h; y++)\n               {\n                  if (!fread(data, w * 3, 1, f))\n                      break;\n \n                   ptr = data;\n                  if (v == 255)\n                     {\n                        for (x = 0; x < w; x++)\n                          {\n                            *ptr2 =\n                               0xff000000 | (ptr[0] << 16) | (ptr[1] << 8) |\n                               ptr[2];\n                            ptr2++;\n                            ptr += 3;\n                         }\n                    }\n                  else\n                    {\n                       for (x = 0; x < w; x++)\n                         {\n                            *ptr2 =\n                               0xff000000 |\n                               (((ptr[0] * 255) / v) << 16) |\n                               (((ptr[1] * 255) / v) << 8) |\n                               ((ptr[2] * 255) / v);\n                            ptr2++;\n                            ptr += 3;\n                         }\n                    }\n                  if (progress &&\n                      do_progress(im, progress, progress_granularity,\n                                  &pper, &pl, y))\n                     goto quit_progress;\n               }\n             break;\n          case '7':            /* XV's 8bit 332 format */\n             data = malloc(1 * sizeof(DATA8) * w);\n             if (!data)\n                goto quit_error;\n\n             ptr2 = im->data;\n             for (y = 0; y < h; y++)\n               {\n                  if (!fread(data, w * 1, 1, f))\n                     break;\n\n                  ptr = data;\n                  for (x = 0; x < w; x++)\n                    {\n                       int                 r, g, b;\n\n                       r = (*ptr >> 5) & 0x7;\n                       g = (*ptr >> 2) & 0x7;\n                       b = (*ptr) & 0x3;\n                       *ptr2 =\n                          0xff000000 |\n                          (((r << 21) | (r << 18) | (r << 15)) & 0xff0000) |\n                          (((g << 13) | (g << 10) | (g << 7)) & 0xff00) |\n                          ((b << 6) | (b << 4) | (b << 2) | (b << 0));\n                       ptr2++;\n                       ptr++;\n                    }\n                  if (progress &&\n                      do_progress(im, progress, progress_granularity,\n                                  &pper, &pl, y))\n                     goto quit_progress;\n               }\n             break;\n          case '8':            /* 24bit binary RGBARGBARGBA */\n             data = malloc(4 * sizeof(DATA8) * w);\n             if (!data)\n                goto quit_error;\n\n             ptr2 = im->data;\n             for (y = 0; y < h; y++)\n               {\n                  if (!fread(data, w * 4, 1, f))\n                      break;\n \n                   ptr = data;\n                  if (v == 255)\n                     {\n                        for (x = 0; x < w; x++)\n                          {\n                            *ptr2 =\n                               (ptr[3] << 24) | (ptr[0] << 16) |\n                               (ptr[1] << 8) | ptr[2];\n                            ptr2++;\n                            ptr += 4;\n                         }\n                    }\n                  else\n                    {\n                       for (x = 0; x < w; x++)\n                         {\n                            *ptr2 =\n                               (((ptr[3] * 255) / v) << 24) |\n                               (((ptr[0] * 255) / v) << 16) |\n                               (((ptr[1] * 255) / v) << 8) |\n                               ((ptr[2] * 255) / v);\n                            ptr2++;\n                            ptr += 4;\n                         }\n                    }\n                  if (progress &&\n                      do_progress(im, progress, progress_granularity,\n                                  &pper, &pl, y))\n                     goto quit_progress;\n               }\n             break;\n          default:\n           quit_error:\n             rc = 0;\n             break;\n           quit_progress:\n             rc = 2;\n             break;\n          }\n        if (idata)\n           free(idata);\n        if (data)\n           free(data);\n     }\n quit:\n   fclose(f);\n   return rc;\n}\n", "target": 1, "idx": 178511}
{"func": "void OmniboxEditModel::OnWillKillFocus(gfx::NativeView view_gaining_focus) {\n  if (user_input_in_progress_ || !in_revert_)\n    delegate_->OnInputStateChanged();\n}\n", "target": 0, "idx": 119350}
{"func": "static int em_sysenter(struct x86_emulate_ctxt *ctxt)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tstruct desc_struct cs, ss;\n\tu64 msr_data;\n\tu16 cs_sel, ss_sel;\n\tu64 efer = 0;\n\n\tops->get_msr(ctxt, MSR_EFER, &efer);\n\t/* inject #GP if in real mode */\n\tif (ctxt->mode == X86EMUL_MODE_REAL)\n\t\treturn emulate_gp(ctxt, 0);\n\n\t/*\n \t * Not recognized on AMD in compat mode (but is recognized in legacy\n \t * mode).\n \t */\n\tif ((ctxt->mode == X86EMUL_MODE_PROT32) && (efer & EFER_LMA)\n \t    && !vendor_intel(ctxt))\n \t\treturn emulate_ud(ctxt);\n \n\t/* sysenter/sysexit have not been tested in 64bit mode. */\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\treturn X86EMUL_UNHANDLEABLE;\n\n \tsetup_syscalls_segments(ctxt, &cs, &ss);\n \n \tops->get_msr(ctxt, MSR_IA32_SYSENTER_CS, &msr_data);\n\tswitch (ctxt->mode) {\n\tcase X86EMUL_MODE_PROT32:\n\t\tif ((msr_data & 0xfffc) == 0x0)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tbreak;\n\tcase X86EMUL_MODE_PROT64:\n\t\tif (msr_data == 0x0)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n \n \tctxt->eflags &= ~(EFLG_VM | EFLG_IF);\n\tcs_sel = (u16)msr_data;\n\tcs_sel &= ~SELECTOR_RPL_MASK;\n \tss_sel = cs_sel + 8;\n\tss_sel &= ~SELECTOR_RPL_MASK;\n\tif (ctxt->mode == X86EMUL_MODE_PROT64 || (efer & EFER_LMA)) {\n \t\tcs.d = 0;\n \t\tcs.l = 1;\n \t}\n\n\tops->set_segment(ctxt, cs_sel, &cs, 0, VCPU_SREG_CS);\n \tops->set_segment(ctxt, ss_sel, &ss, 0, VCPU_SREG_SS);\n \n \tops->get_msr(ctxt, MSR_IA32_SYSENTER_EIP, &msr_data);\n\tctxt->_eip = msr_data;\n \n \tops->get_msr(ctxt, MSR_IA32_SYSENTER_ESP, &msr_data);\n\t*reg_write(ctxt, VCPU_REGS_RSP) = msr_data;\n \n \treturn X86EMUL_CONTINUE;\n }\n", "target": 1, "idx": 179914}
{"func": "Plugin::~Plugin() {\n  int64_t shutdown_start = NaClGetTimeOfDayMicroseconds();\n\n  PLUGIN_PRINTF((\"Plugin::~Plugin (this=%p, scriptable_plugin=%p)\\n\",\n                 static_cast<void*>(this),\n                 static_cast<void*>(scriptable_plugin())));\n  pnacl_coordinator_.reset(NULL);\n  if (ppapi_proxy_ != NULL) {\n    HistogramTimeLarge(\n        \"NaCl.ModuleUptime.Normal\",\n        (shutdown_start - ready_time_) / NACL_MICROS_PER_MILLI);\n  }\n\n  url_downloaders_.erase(url_downloaders_.begin(), url_downloaders_.end());\n\n  ShutdownProxy();\n  ScriptablePlugin* scriptable_plugin_ = scriptable_plugin();\n  ScriptablePlugin::Unref(&scriptable_plugin_);\n\n  ShutDownSubprocesses();\n\n  delete wrapper_factory_;\n  delete[] argv_;\n  delete[] argn_;\n\n  HistogramTimeSmall(\n      \"NaCl.Perf.ShutdownTime.Total\",\n      (NaClGetTimeOfDayMicroseconds() - shutdown_start)\n          / NACL_MICROS_PER_MILLI);\n\n  PLUGIN_PRINTF((\"Plugin::~Plugin (this=%p, return)\\n\",\n                 static_cast<void*>(this)));\n}\n", "target": 0, "idx": 110361}
{"func": "std::string GetStoreIdFromProfile(Profile* profile) {\n   DCHECK(profile);\n   return profile->IsOffTheRecord() ?\n       kOffTheRecordProfileStoreId : kOriginalProfileStoreId;\n}\n", "target": 1, "idx": 183475}
{"func": "gfx::Size GLES2DecoderImpl::GetBoundReadFrameBufferSize() {\n  Framebuffer* framebuffer =\n      GetFramebufferInfoForTarget(GL_READ_FRAMEBUFFER_EXT);\n  if (framebuffer != NULL) {\n    const Framebuffer::Attachment* attachment =\n        framebuffer->GetAttachment(GL_COLOR_ATTACHMENT0);\n    if (attachment) {\n      return gfx::Size(attachment->width(), attachment->height());\n    }\n    return gfx::Size(0, 0);\n  } else if (offscreen_target_frame_buffer_.get()) {\n    return offscreen_size_;\n  } else {\n    return surface_->GetSize();\n  }\n}\n", "target": 0, "idx": 129364}
{"func": "void AppControllerImpl::LaunchApp(const std::string& app_id) {\n   app_service_proxy_->Launch(app_id, ui::EventFlags::EF_NONE,\n                              apps::mojom::LaunchSource::kFromAppListGrid,\n                              display::kDefaultDisplayId);\n }\n", "target": 1, "idx": 185997}
{"func": "v8::Local<v8::Object> V8InjectedScriptHost::create(v8::Local<v8::Context> context, V8InspectorImpl* inspector)\n {\n     v8::Isolate* isolate = inspector->isolate();\n     v8::Local<v8::Object> injectedScriptHost = v8::Object::New(isolate);\n     v8::Local<v8::External> debuggerExternal = v8::External::New(isolate, inspector);\n     setFunctionProperty(context, injectedScriptHost, \"internalConstructorName\", V8InjectedScriptHost::internalConstructorNameCallback, debuggerExternal);\n     setFunctionProperty(context, injectedScriptHost, \"formatAccessorsAsProperties\", V8InjectedScriptHost::formatAccessorsAsProperties, debuggerExternal);\n    setFunctionProperty(context, injectedScriptHost, \"subtype\", V8InjectedScriptHost::subtypeCallback, debuggerExternal);\n    setFunctionProperty(context, injectedScriptHost, \"getInternalProperties\", V8InjectedScriptHost::getInternalPropertiesCallback, debuggerExternal);\n    setFunctionProperty(context, injectedScriptHost, \"objectHasOwnProperty\", V8InjectedScriptHost::objectHasOwnPropertyCallback, debuggerExternal);\n    setFunctionProperty(context, injectedScriptHost, \"bind\", V8InjectedScriptHost::bindCallback, debuggerExternal);\n    setFunctionProperty(context, injectedScriptHost, \"proxyTargetValue\", V8InjectedScriptHost::proxyTargetValueCallback, debuggerExternal);\n    return injectedScriptHost;\n}\n", "target": 1, "idx": 185982}
{"func": "dns_resolver_match(const struct key *key,\n\t\t   const struct key_match_data *match_data)\n {\n \tint slen, dlen, ret = 0;\n \tconst char *src = key->description, *dsp = match_data->raw_data;\n\n\tkenter(\"%s,%s\", src, dsp);\n\n\tif (!src || !dsp)\n\t\tgoto no_match;\n\n\tif (strcasecmp(src, dsp) == 0)\n\t\tgoto matched;\n\n\tslen = strlen(src);\n\tdlen = strlen(dsp);\n\tif (slen <= 0 || dlen <= 0)\n\t\tgoto no_match;\n\tif (src[slen - 1] == '.')\n\t\tslen--;\n\tif (dsp[dlen - 1] == '.')\n\t\tdlen--;\n\tif (slen != dlen || strncasecmp(src, dsp, slen) != 0)\n\t\tgoto no_match;\n\nmatched:\n\tret = 1;\nno_match:\n\tkleave(\" = %d\", ret);\n \treturn ret;\n }\n", "target": 1, "idx": 181610}
{"func": "int WebContentsImpl::DownloadImage(\n    const GURL& url,\n    bool is_favicon,\n    uint32_t max_bitmap_size,\n    bool bypass_cache,\n    const WebContents::ImageDownloadCallback& callback) {\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n  static int next_image_download_id = 0;\n  const image_downloader::ImageDownloaderPtr& mojo_image_downloader =\n      GetMainFrame()->GetMojoImageDownloader();\n  const int download_id = ++next_image_download_id;\n  if (!mojo_image_downloader) {\n     BrowserThread::PostTask(\n         BrowserThread::UI, FROM_HERE,\n        base::Bind(&WebContents::ImageDownloadCallback::Run,\n                   base::Owned(new ImageDownloadCallback(callback)),\n                   download_id, 400, url, std::vector<SkBitmap>(),\n                   std::vector<gfx::Size>()));\n     return download_id;\n   }\n \n  image_downloader::DownloadRequestPtr req =\n      image_downloader::DownloadRequest::New();\n\n  req->url = mojo::String::From(url);\n  req->is_favicon = is_favicon;\n  req->max_bitmap_size = max_bitmap_size;\n   req->bypass_cache = bypass_cache;\n \n   mojo_image_downloader->DownloadImage(\n      std::move(req),\n      base::Bind(&DidDownloadImage, callback, download_id, url));\n   return download_id;\n }\n", "target": 1, "idx": 186178}
{"func": "error_detected(uint32_t errnum, char *errstr, ...)\n{\n    va_list args;\n\n    va_start(args, errstr);\n\n    {\n        TSK_ERROR_INFO *errInfo = tsk_error_get_info();\n        char *loc_errstr = errInfo->errstr;\n\n        if (errInfo->t_errno == 0)\n            errInfo->t_errno = errnum;\n        else {\n            size_t sl = strlen(errstr);\n            snprintf(loc_errstr + sl, TSK_ERROR_STRING_MAX_LENGTH - sl,\n                \" Next errnum: 0x%x \", errnum);\n        }\n        if (errstr != NULL) {\n            size_t sl = strlen(loc_errstr);\n            vsnprintf(loc_errstr + sl, TSK_ERROR_STRING_MAX_LENGTH - sl,\n                errstr, args);\n        }\n    }\n\n    va_end(args);\n\n}\n", "target": 0, "idx": 75665}
{"func": "static int rfcomm_sock_create(struct net *net, struct socket *sock,\n\t\t\t      int protocol, int kern)\n{\n\tstruct sock *sk;\n\n\tBT_DBG(\"sock %p\", sock);\n\n\tsock->state = SS_UNCONNECTED;\n\n\tif (sock->type != SOCK_STREAM && sock->type != SOCK_RAW)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tsock->ops = &rfcomm_sock_ops;\n\n\tsk = rfcomm_sock_alloc(net, sock, protocol, GFP_ATOMIC);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\n\trfcomm_sock_init(sk, NULL);\n\treturn 0;\n}\n", "target": 0, "idx": 30734}
{"func": "error::Error GLES2DecoderPassthroughImpl::DoGetAttribLocation(GLuint program,\n                                                              const char* name,\n                                                              GLint* result) {\n  *result = api()->glGetAttribLocationFn(\n      GetProgramServiceID(program, resources_), name);\n  return error::kNoError;\n}\n", "target": 0, "idx": 154678}
{"func": " SPL_METHOD(RecursiveDirectoryIterator, getSubPath)\n {\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n\n\tif (intern->u.dir.sub_path) {\n\t\tRETURN_STRINGL(intern->u.dir.sub_path, intern->u.dir.sub_path_len, 1);\n\t} else {\n\t\tRETURN_STRINGL(\"\", 0, 1);\n\t}\n}\n", "target": 1, "idx": 180218}
{"func": "static int inet6_create(struct net *net, struct socket *sock, int protocol,\n\t\t\tint kern)\n{\n\tstruct inet_sock *inet;\n\tstruct ipv6_pinfo *np;\n\tstruct sock *sk;\n\tstruct inet_protosw *answer;\n\tstruct proto *answer_prot;\n\tunsigned char answer_flags;\n \tint try_loading_module = 0;\n \tint err;\n \n \t/* Look for the requested type/protocol pair. */\n lookup_protocol:\n \terr = -ESOCKTNOSUPPORT;\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(answer, &inetsw6[sock->type], list) {\n\n\t\terr = 0;\n\t\t/* Check the non-wild match. */\n\t\tif (protocol == answer->protocol) {\n\t\t\tif (protocol != IPPROTO_IP)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t/* Check for the two wild cases. */\n\t\t\tif (IPPROTO_IP == protocol) {\n\t\t\t\tprotocol = answer->protocol;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (IPPROTO_IP == answer->protocol)\n\t\t\t\tbreak;\n\t\t}\n\t\terr = -EPROTONOSUPPORT;\n\t}\n\n\tif (err) {\n\t\tif (try_loading_module < 2) {\n\t\t\trcu_read_unlock();\n\t\t\t/*\n\t\t\t * Be more specific, e.g. net-pf-10-proto-132-type-1\n\t\t\t * (net-pf-PF_INET6-proto-IPPROTO_SCTP-type-SOCK_STREAM)\n\t\t\t */\n\t\t\tif (++try_loading_module == 1)\n\t\t\t\trequest_module(\"net-pf-%d-proto-%d-type-%d\",\n\t\t\t\t\t\tPF_INET6, protocol, sock->type);\n\t\t\t/*\n\t\t\t * Fall back to generic, e.g. net-pf-10-proto-132\n\t\t\t * (net-pf-PF_INET6-proto-IPPROTO_SCTP)\n\t\t\t */\n\t\t\telse\n\t\t\t\trequest_module(\"net-pf-%d-proto-%d\",\n\t\t\t\t\t\tPF_INET6, protocol);\n\t\t\tgoto lookup_protocol;\n\t\t} else\n\t\t\tgoto out_rcu_unlock;\n\t}\n\n\terr = -EPERM;\n\tif (sock->type == SOCK_RAW && !kern &&\n\t    !ns_capable(net->user_ns, CAP_NET_RAW))\n\t\tgoto out_rcu_unlock;\n\n\tsock->ops = answer->ops;\n\tanswer_prot = answer->prot;\n\tanswer_flags = answer->flags;\n\trcu_read_unlock();\n\n\tWARN_ON(!answer_prot->slab);\n\n\terr = -ENOBUFS;\n\tsk = sk_alloc(net, PF_INET6, GFP_KERNEL, answer_prot, kern);\n\tif (!sk)\n\t\tgoto out;\n\n\tsock_init_data(sock, sk);\n\n\terr = 0;\n\tif (INET_PROTOSW_REUSE & answer_flags)\n\t\tsk->sk_reuse = SK_CAN_REUSE;\n\n\tinet = inet_sk(sk);\n\tinet->is_icsk = (INET_PROTOSW_ICSK & answer_flags) != 0;\n\n\tif (SOCK_RAW == sock->type) {\n\t\tinet->inet_num = protocol;\n\t\tif (IPPROTO_RAW == protocol)\n\t\t\tinet->hdrincl = 1;\n\t}\n\n\tsk->sk_destruct\t\t= inet_sock_destruct;\n\tsk->sk_family\t\t= PF_INET6;\n\tsk->sk_protocol\t\t= protocol;\n\n\tsk->sk_backlog_rcv\t= answer->prot->backlog_rcv;\n\n\tinet_sk(sk)->pinet6 = np = inet6_sk_generic(sk);\n\tnp->hop_limit\t= -1;\n\tnp->mcast_hops\t= IPV6_DEFAULT_MCASTHOPS;\n\tnp->mc_loop\t= 1;\n\tnp->pmtudisc\t= IPV6_PMTUDISC_WANT;\n\tnp->autoflowlabel = ip6_default_np_autolabel(sock_net(sk));\n\tsk->sk_ipv6only\t= net->ipv6.sysctl.bindv6only;\n\n\t/* Init the ipv4 part of the socket since we can have sockets\n\t * using v6 API for ipv4.\n\t */\n\tinet->uc_ttl\t= -1;\n\n\tinet->mc_loop\t= 1;\n\tinet->mc_ttl\t= 1;\n\tinet->mc_index\t= 0;\n\tinet->mc_list\t= NULL;\n\tinet->rcv_tos\t= 0;\n\n\tif (net->ipv4.sysctl_ip_no_pmtu_disc)\n\t\tinet->pmtudisc = IP_PMTUDISC_DONT;\n\telse\n\t\tinet->pmtudisc = IP_PMTUDISC_WANT;\n\t/*\n\t * Increment only the relevant sk_prot->socks debug field, this changes\n\t * the previous behaviour of incrementing both the equivalent to\n\t * answer->prot->socks (inet6_sock_nr) and inet_sock_nr.\n\t *\n\t * This allows better debug granularity as we'll know exactly how many\n\t * UDPv6, TCPv6, etc socks were allocated, not the sum of all IPv6\n\t * transport protocol socks. -acme\n\t */\n\tsk_refcnt_debug_inc(sk);\n\n\tif (inet->inet_num) {\n\t\t/* It assumes that any protocol which allows\n\t\t * the user to assign a number at socket\n\t\t * creation time automatically shares.\n\t\t */\n\t\tinet->inet_sport = htons(inet->inet_num);\n\t\tsk->sk_prot->hash(sk);\n\t}\n\tif (sk->sk_prot->init) {\n\t\terr = sk->sk_prot->init(sk);\n\t\tif (err) {\n\t\t\tsk_common_release(sk);\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\treturn err;\nout_rcu_unlock:\n\trcu_read_unlock();\n\tgoto out;\n}\n", "target": 1, "idx": 179737}
{"func": "bool GLES2Decoder::GetServiceTextureId(uint32_t client_texture_id,\n                                       uint32_t* service_texture_id) {\n  return false;\n}\n", "target": 0, "idx": 154182}
{"func": " static int inotify_release(struct inode *ignored, struct file *file)\n {\n \tstruct fsnotify_group *group = file->private_data;\n\tstruct user_struct *user = group->inotify_data.user;\n \n \tpr_debug(\"%s: group=%p\\n\", __func__, group);\n \n\tfsnotify_clear_marks_by_group(group);\n\n \t/* free this group, matching get was inotify_init->fsnotify_obtain_group */\n \tfsnotify_put_group(group);\n \n\tatomic_dec(&user->inotify_devs);\n \treturn 0;\n }\n", "target": 1, "idx": 179061}
{"func": "  bool StopInputMethodProcess() {\n     if (!IBusConnectionsAreAlive()) {\n       LOG(ERROR) << \"StopInputMethodProcess: IBus connection is not alive\";\n       return false;\n    }\n\n    ibus_bus_exit_async(ibus_,\n                        FALSE  /* do not restart */,\n                        -1  /* timeout */,\n                        NULL  /* cancellable */,\n                        NULL  /* callback */,\n                        NULL  /* user_data */);\n\n    if (ibus_config_) {\n      g_object_unref(ibus_config_);\n      ibus_config_ = NULL;\n    }\n     return true;\n   }\n", "target": 1, "idx": 184006}
{"func": "  static void UpdatePropertyCallback(IBusPanelService* panel,\n                                     IBusProperty* ibus_prop,\n                                     gpointer user_data) {\n    g_return_if_fail(user_data);\n    InputMethodStatusConnection* self\n        = static_cast<InputMethodStatusConnection*>(user_data);\n    self->UpdateProperty(ibus_prop);\n   }\n", "target": 1, "idx": 184008}
{"func": "void HostPortAllocatorSession::OnSessionRequestDone(\n    UrlFetcher* url_fetcher,\n    const net::URLRequestStatus& status,\n    int response_code,\n    const std::string& response) {\n  url_fetchers_.erase(url_fetcher);\n  delete url_fetcher;\n \n  if (response_code != net::HTTP_OK) {\n     LOG(WARNING) << \"Received error when allocating relay session: \"\n                 << response_code;\n     TryCreateRelaySession();\n     return;\n   }\n \n   ReceiveSessionResponse(response);\n }\n", "target": 1, "idx": 184384}
{"func": "static void nonpaging_invlpg(struct kvm_vcpu *vcpu, gva_t gva)\n{\n}\n", "target": 0, "idx": 37555}
{"func": "void AffineTransform::recompose(const DecomposedType& decomp)\n{\n    this->setA(decomp.remainderA);\n    this->setB(decomp.remainderB);\n    this->setC(decomp.remainderC);\n    this->setD(decomp.remainderD);\n    this->setE(decomp.translateX);\n    this->setF(decomp.translateY);\n    this->rotateRadians(decomp.angle);\n    this->scale(decomp.scaleX, decomp.scaleY);\n}\n", "target": 0, "idx": 129662}
{"func": "bool LayerTreeHost::PaintContent(const LayerList& update_layer_list,\n                                 bool* content_is_suitable_for_gpu) {\n  base::AutoReset<bool> painting(&in_paint_layer_contents_, true);\n  bool did_paint_content = false;\n  for (const auto& layer : update_layer_list) {\n    did_paint_content |= layer->Update();\n    *content_is_suitable_for_gpu &= layer->IsSuitableForGpuRasterization();\n  }\n  return did_paint_content;\n}\n", "target": 0, "idx": 149814}
{"func": "inline gl::GLApi* BackTexture::api() const {\n  return decoder_->api();\n}\n", "target": 0, "idx": 154396}
{"func": "PHP_FUNCTION(openssl_verify)\n{\n\tzval **key;\n\tEVP_PKEY *pkey;\n\tint err;\n\tEVP_MD_CTX     md_ctx;\n\tconst EVP_MD *mdtype;\n\tlong keyresource = -1;\n\tchar * data;\tint data_len;\n\tchar * signature;\tint signature_len;\n\tzval *method = NULL;\n\tlong signature_algo = OPENSSL_ALGO_SHA1;\n\t\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ssZ|z\", &data, &data_len, &signature, &signature_len, &key, &method) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (method == NULL || Z_TYPE_P(method) == IS_LONG) {\n\t\tif (method != NULL) {\n\t\t\tsignature_algo = Z_LVAL_P(method);\n\t\t}\n\t\tmdtype = php_openssl_get_evp_md_from_algo(signature_algo);\n\t} else if (Z_TYPE_P(method) == IS_STRING) {\n\t\tmdtype = EVP_get_digestbyname(Z_STRVAL_P(method));\n\t} else {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unknown signature algorithm.\");\n\t\tRETURN_FALSE;\n\t}\n\tif (!mdtype) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unknown signature algorithm.\");\n\t\tRETURN_FALSE;\n\t}\n\n\tpkey = php_openssl_evp_from_zval(key, 1, NULL, 0, &keyresource TSRMLS_CC);\n\tif (pkey == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"supplied key param cannot be coerced into a public key\");\n\t\tRETURN_FALSE;\n\t}\n\n\tEVP_VerifyInit   (&md_ctx, mdtype);\n\tEVP_VerifyUpdate (&md_ctx, data, data_len);\n\terr = EVP_VerifyFinal (&md_ctx, (unsigned char *)signature, signature_len, pkey);\n\tEVP_MD_CTX_cleanup(&md_ctx);\n\n\tif (keyresource == -1) {\n\t\tEVP_PKEY_free(pkey);\n\t}\n\tRETURN_LONG(err);\n}\n", "target": 0, "idx": 127}
{"func": "void InspectorTraceEvents::Did(const probe::ParseHTML& probe) {\n  TRACE_EVENT_END1(\n      \"devtools.timeline\", \"ParseHTML\", \"endData\",\n      InspectorParseHtmlEndData(probe.parser->LineNumber().ZeroBasedInt() - 1));\n  TRACE_EVENT_INSTANT1(TRACE_DISABLED_BY_DEFAULT(\"devtools.timeline\"),\n                       \"UpdateCounters\", TRACE_EVENT_SCOPE_THREAD, \"data\",\n                       InspectorUpdateCountersEvent::Data());\n}\n", "target": 0, "idx": 151338}
{"func": "bool ChromeClientImpl::AcceptsLoadDrops() const {\n  return !web_view_->Client() || web_view_->Client()->AcceptsLoadDrops();\n}\n", "target": 0, "idx": 160924}
{"func": "PP_InputEvent_Type ConvertEventTypes(WebInputEvent::Type wetype) {\n  switch (wetype) {\n    case WebInputEvent::MouseDown:\n      return PP_INPUTEVENT_TYPE_MOUSEDOWN;\n    case WebInputEvent::MouseUp:\n      return PP_INPUTEVENT_TYPE_MOUSEUP;\n    case WebInputEvent::MouseMove:\n      return PP_INPUTEVENT_TYPE_MOUSEMOVE;\n    case WebInputEvent::MouseEnter:\n       return PP_INPUTEVENT_TYPE_MOUSEENTER;\n     case WebInputEvent::MouseLeave:\n       return PP_INPUTEVENT_TYPE_MOUSELEAVE;\n     case WebInputEvent::MouseWheel:\n       return PP_INPUTEVENT_TYPE_MOUSEWHEEL;\n     case WebInputEvent::RawKeyDown:\n      return PP_INPUTEVENT_TYPE_RAWKEYDOWN;\n    case WebInputEvent::KeyDown:\n      return PP_INPUTEVENT_TYPE_KEYDOWN;\n    case WebInputEvent::KeyUp:\n      return PP_INPUTEVENT_TYPE_KEYUP;\n    case WebInputEvent::Char:\n      return PP_INPUTEVENT_TYPE_CHAR;\n    case WebInputEvent::Undefined:\n    default:\n      return PP_INPUTEVENT_TYPE_UNDEFINED;\n  }\n}\n", "target": 1, "idx": 184075}
{"func": "static double abserr(PNG_CONST png_modifier *pm, int in_depth, int out_depth)\n {\n    /* Absolute error permitted in linear values - affected by the bit depth of\n     * the calculations.\n    */\n if (pm->assume_16_bit_calculations ||\n (pm->calculations_use_input_precision ? in_depth : out_depth) == 16)\n return pm->maxabs16;\n else\n\n       return pm->maxabs8;\n }\n", "target": 1, "idx": 187625}
{"func": " static inline void sem_getref_and_unlock(struct sem_array *sma)\n {\n\tipc_rcu_getref(sma);\n\tipc_unlock(&(sma)->sem_perm);\n }\n", "target": 1, "idx": 179146}
{"func": "static EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionOverloadedMethod6(ExecState* exec)\n{\n    JSValue thisValue = exec->hostThisValue();\n    if (!thisValue.inherits(&JSTestObj::s_info))\n        return throwVMTypeError(exec);\n    JSTestObj* castedThis = jsCast<JSTestObj*>(asObject(thisValue));\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\n     TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n     if (exec->argumentCount() < 1)\n        return throwVMError(exec, createTypeError(exec, \"Not enough arguments\"));\n     DOMStringList* listArg(toDOMStringList(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined)));\n     if (exec->hadException())\n         return JSValue::encode(jsUndefined());\n    impl->overloadedMethod(listArg);\n    return JSValue::encode(jsUndefined());\n}\n", "target": 1, "idx": 184062}
{"func": "void drop_privileges(char *username) {\n\tstruct passwd *user = (struct passwd *) getpwnam(username);\n\tif (user == NULL) {\n\t\tfprintf(stderr, _(\"Failed dropping privileges. The user %s is not a valid username on local system.\\n\"), username);\n\t\texit(1);\n\t}\n\tif (getuid() == 0) {\n\t\t/* process is running as root, drop privileges */\n\t\tif (setgid(user->pw_gid) != 0) {\n\t\t\tfprintf(stderr, _(\"setgid: Error dropping group privileges\\n\"));\n\t\t\texit(1);\n\t\t}\n\t\tif (setuid(user->pw_uid) != 0) {\n\t\t\tfprintf(stderr, _(\"setuid: Error dropping user privileges\\n\"));\n\t\t\texit(1);\n\t\t}\n\t\t/* Verify if the privileges were developed. */\n\t\tif (setuid(0) != -1) {\n\t\t\tfprintf(stderr, _(\"Failed to drop privileges\\n\"));\n\t\t\texit(1);\n\t\t}\n\t}\n}\n", "target": 0, "idx": 50284}
{"func": "static struct mt_connection *list_find_connection(unsigned short seskey, unsigned char *srcmac) {\n\tstruct mt_connection *p;\n\n\tDL_FOREACH(connections_head, p) {\n\t\tif (p->seskey == seskey && memcmp(srcmac, p->srcmac, ETH_ALEN) == 0) {\n\t\t\treturn p;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n", "target": 0, "idx": 50295}
{"func": "void TaskManagerHandler::HandleActivatePage(const ListValue* unique_ids) {\n  for (ListValue::const_iterator i = unique_ids->begin();\n       i != unique_ids->end(); ++i) {\n    int unique_id = parseIndex(*i);\n    int resource_index = model_->GetResourceIndexByUniqueId(unique_id);\n    if (resource_index == -1)\n      continue;\n\n    task_manager_->ActivateProcess(resource_index);\n    break;\n  }\n}\n", "target": 0, "idx": 100910}
{"func": "TestBrowserWindow::~TestBrowserWindow() {}\n", "target": 0, "idx": 168433}
{"func": "png_set_tIME(png_structp png_ptr, png_infop info_ptr, png_timep mod_time)\n{\n   png_debug1(1, \"in %s storage function\", \"tIME\");\n\n   if (png_ptr == NULL || info_ptr == NULL ||\n        (png_ptr->mode & PNG_WROTE_tIME))\n       return;\n \n    png_memcpy(&(info_ptr->mod_time), mod_time, png_sizeof(png_time));\n    info_ptr->valid |= PNG_INFO_tIME;\n }\n", "target": 1, "idx": 186152}
{"func": "static void calc_coeff(double mu[4], const int index[4], int prefilter, double r2, double mul)\n{\n    double mul2 = mul * mul, mul3 = mul2 * mul;\n    double kernel[] = {\n        (5204 + 2520 * mul + 1092 * mul2 + 3280 * mul3) / 12096,\n        (2943 -  210 * mul -  273 * mul2 - 2460 * mul3) / 12096,\n        ( 486 -  924 * mul -  546 * mul2 +  984 * mul3) / 12096,\n         (  17 -  126 * mul +  273 * mul2 -  164 * mul3) / 12096,\n     };\n \n    double mat_freq[13];\n     memcpy(mat_freq, kernel, sizeof(kernel));\n     memset(mat_freq + 4, 0, sizeof(mat_freq) - sizeof(kernel));\n     int n = 6;\n    coeff_filter(mat_freq, n, kernel);\n    for (int k = 0; k < 2 * prefilter; ++k)\n        coeff_blur121(mat_freq, ++n);\n\n    double vec_freq[13];\n    n = index[3] + prefilter + 3;\n    calc_gauss(vec_freq, n, r2);\n    memset(vec_freq + n + 1, 0, sizeof(vec_freq) - (n + 1) * sizeof(vec_freq[0]));\n    n -= 3;\n    coeff_filter(vec_freq, n, kernel);\n    for (int k = 0; k < prefilter; ++k)\n        coeff_blur121(vec_freq, --n);\n\n    double mat[4][4];\n    calc_matrix(mat, mat_freq, index);\n\n    double vec[4];\n    for (int i = 0; i < 4; ++i)\n        vec[i] = mat_freq[0] - mat_freq[index[i]] - vec_freq[0] + vec_freq[index[i]];\n\n    for (int i = 0; i < 4; ++i) {\n        double res = 0;\n        for (int j = 0; j < 4; ++j)\n            res += mat[i][j] * vec[j];\n        mu[i] = FFMAX(0, res);\n    }\n}\n", "target": 1, "idx": 181947}
{"func": "const char* Track::GetLanguage() const\n{\n    return m_info.language;\n}\n", "target": 1, "idx": 188359}
{"func": "static void write_exception(struct pstore *ps,\n\t\t\t    uint32_t index, struct core_exception *e)\n{\n\tstruct disk_exception *de = get_exception(ps, index);\n\n\t/* copy it */\n\tde->old_chunk = cpu_to_le64(e->old_chunk);\n\tde->new_chunk = cpu_to_le64(e->new_chunk);\n}\n", "target": 0, "idx": 29686}
{"func": "static int php_stream_temp_seek(php_stream *stream, off_t offset, int whence, off_t *newoffs TSRMLS_DC)\n{\n\tphp_stream_temp_data *ts = (php_stream_temp_data*)stream->abstract;\n\tint ret;\n\n\tassert(ts != NULL);\n\n\tif (!ts->innerstream) {\n\t\t*newoffs = -1;\n\t\treturn -1;\n\t}\n        ret = php_stream_seek(ts->innerstream, offset, whence);\n        *newoffs = php_stream_tell(ts->innerstream);\n        stream->eof = ts->innerstream->eof;\n        return ret;\n }\n", "target": 1, "idx": 178653}
{"func": "xps_parse_glyphs(xps_document *doc, const fz_matrix *ctm,\n\t\tchar *base_uri, xps_resource *dict, fz_xml *root)\n{\n\tfz_xml *node;\n\n\tchar *fill_uri;\n\tchar *opacity_mask_uri;\n\n\tchar *bidi_level_att;\n\tchar *fill_att;\n\tchar *font_size_att;\n\tchar *font_uri_att;\n\tchar *origin_x_att;\n\tchar *origin_y_att;\n\tchar *is_sideways_att;\n\tchar *indices_att;\n\tchar *unicode_att;\n\tchar *style_att;\n\tchar *transform_att;\n\tchar *clip_att;\n\tchar *opacity_att;\n\tchar *opacity_mask_att;\n\tchar *navigate_uri_att;\n\n\tfz_xml *transform_tag = NULL;\n\tfz_xml *clip_tag = NULL;\n\tfz_xml *fill_tag = NULL;\n\tfz_xml *opacity_mask_tag = NULL;\n\n\tchar *fill_opacity_att = NULL;\n\n\txps_part *part;\n\tfz_font *font;\n\n\tchar partname[1024];\n\tchar fakename[1024];\n\tchar *subfont;\n\n\tfloat font_size = 10;\n\tint subfontid = 0;\n\tint is_sideways = 0;\n\tint bidi_level = 0;\n\n\tfz_text *text;\n\tfz_rect area;\n\n\tfz_matrix local_ctm = *ctm;\n\n\t/*\n\t * Extract attributes and extended attributes.\n\t */\n\n\tbidi_level_att = fz_xml_att(root, \"BidiLevel\");\n\tfill_att = fz_xml_att(root, \"Fill\");\n\tfont_size_att = fz_xml_att(root, \"FontRenderingEmSize\");\n\tfont_uri_att = fz_xml_att(root, \"FontUri\");\n\torigin_x_att = fz_xml_att(root, \"OriginX\");\n\torigin_y_att = fz_xml_att(root, \"OriginY\");\n\tis_sideways_att = fz_xml_att(root, \"IsSideways\");\n\tindices_att = fz_xml_att(root, \"Indices\");\n\tunicode_att = fz_xml_att(root, \"UnicodeString\");\n\tstyle_att = fz_xml_att(root, \"StyleSimulations\");\n\ttransform_att = fz_xml_att(root, \"RenderTransform\");\n\tclip_att = fz_xml_att(root, \"Clip\");\n\topacity_att = fz_xml_att(root, \"Opacity\");\n\topacity_mask_att = fz_xml_att(root, \"OpacityMask\");\n\tnavigate_uri_att = fz_xml_att(root, \"FixedPage.NavigateUri\");\n\n\tfor (node = fz_xml_down(root); node; node = fz_xml_next(node))\n\t{\n\t\tif (!strcmp(fz_xml_tag(node), \"Glyphs.RenderTransform\"))\n\t\t\ttransform_tag = fz_xml_down(node);\n\t\tif (!strcmp(fz_xml_tag(node), \"Glyphs.OpacityMask\"))\n\t\t\topacity_mask_tag = fz_xml_down(node);\n\t\tif (!strcmp(fz_xml_tag(node), \"Glyphs.Clip\"))\n\t\t\tclip_tag = fz_xml_down(node);\n\t\tif (!strcmp(fz_xml_tag(node), \"Glyphs.Fill\"))\n\t\t\tfill_tag = fz_xml_down(node);\n\t}\n\n\tfill_uri = base_uri;\n\topacity_mask_uri = base_uri;\n\n\txps_resolve_resource_reference(doc, dict, &transform_att, &transform_tag, NULL);\n\txps_resolve_resource_reference(doc, dict, &clip_att, &clip_tag, NULL);\n\txps_resolve_resource_reference(doc, dict, &fill_att, &fill_tag, &fill_uri);\n\txps_resolve_resource_reference(doc, dict, &opacity_mask_att, &opacity_mask_tag, &opacity_mask_uri);\n\n\t/*\n\t * Check that we have all the necessary information.\n\t */\n\n\tif (!font_size_att || !font_uri_att || !origin_x_att || !origin_y_att) {\n\t\tfz_warn(doc->ctx, \"missing attributes in glyphs element\");\n\t\treturn;\n\t}\n\n\tif (!indices_att && !unicode_att)\n\t\treturn; /* nothing to draw */\n\n\tif (is_sideways_att)\n\t\tis_sideways = !strcmp(is_sideways_att, \"true\");\n\n\tif (bidi_level_att)\n\t\tbidi_level = atoi(bidi_level_att);\n\n\t/*\n\t * Find and load the font resource\n\t */\n\n\txps_resolve_url(partname, base_uri, font_uri_att, sizeof partname);\n\tsubfont = strrchr(partname, '#');\n\tif (subfont)\n\t{\n\t\tsubfontid = atoi(subfont + 1);\n\t\t*subfont = 0;\n\t}\n\n\t/* Make a new part name for font with style simulation applied */\n\tfz_strlcpy(fakename, partname, sizeof fakename);\n\tif (style_att)\n\t{\n\t\tif (!strcmp(style_att, \"BoldSimulation\"))\n\t\t\tfz_strlcat(fakename, \"#Bold\", sizeof fakename);\n\t\telse if (!strcmp(style_att, \"ItalicSimulation\"))\n\t\t\tfz_strlcat(fakename, \"#Italic\", sizeof fakename);\n\t\telse if (!strcmp(style_att, \"BoldItalicSimulation\"))\n\t\t\tfz_strlcat(fakename, \"#BoldItalic\", sizeof fakename);\n\t}\n\n\tfont = xps_lookup_font(doc, fakename);\n\tif (!font)\n\t{\n\t\tfz_try(doc->ctx)\n\t\t{\n\t\t\tpart = xps_read_part(doc, partname);\n\t\t}\n\t\tfz_catch(doc->ctx)\n\t\t{\n\t\t\tfz_rethrow_if(doc->ctx, FZ_ERROR_TRYLATER);\n\t\t\tfz_warn(doc->ctx, \"cannot find font resource part '%s'\", partname);\n\t\t\treturn;\n\t\t}\n\n\t\t/* deobfuscate if necessary */\n\t\tif (strstr(part->name, \".odttf\"))\n\t\t\txps_deobfuscate_font_resource(doc, part);\n\t\tif (strstr(part->name, \".ODTTF\"))\n\t\t\txps_deobfuscate_font_resource(doc, part);\n\n\t\tfz_try(doc->ctx)\n\t\t{\n\t\t\tfz_buffer *buf = fz_new_buffer_from_data(doc->ctx, part->data, part->size);\n\t\t\tfont = fz_new_font_from_buffer(doc->ctx, NULL, buf, subfontid, 1);\n\t\t\tfz_drop_buffer(doc->ctx, buf);\n\t\t}\n\t\tfz_catch(doc->ctx)\n\t\t{\n\t\t\tfz_rethrow_if(doc->ctx, FZ_ERROR_TRYLATER);\n\t\t\tfz_warn(doc->ctx, \"cannot load font resource '%s'\", partname);\n\t\t\txps_free_part(doc, part);\n\t\t\treturn;\n\t\t}\n\n\t\tif (style_att)\n\t\t{\n\t\t\tfont->ft_bold = !!strstr(style_att, \"Bold\");\n\t\t\tfont->ft_italic = !!strstr(style_att, \"Italic\");\n\t\t}\n\n\t\txps_select_best_font_encoding(doc, font);\n\n\t\txps_insert_font(doc, fakename, font);\n\n\t\t/* NOTE: we already saved part->data in the buffer in the font */\n\t\tfz_free(doc->ctx, part->name);\n\t\tfz_free(doc->ctx, part);\n\t}\n\n\t/*\n\t * Set up graphics state.\n\t */\n\n\tif (transform_att || transform_tag)\n\t{\n\t\tfz_matrix transform;\n\t\tif (transform_att)\n\t\t\txps_parse_render_transform(doc, transform_att, &transform);\n\t\tif (transform_tag)\n\t\t\txps_parse_matrix_transform(doc, transform_tag, &transform);\n\t\tfz_concat(&local_ctm, &transform, &local_ctm);\n\t}\n\n\tif (clip_att || clip_tag)\n\t\txps_clip(doc, &local_ctm, dict, clip_att, clip_tag);\n\n\tfont_size = fz_atof(font_size_att);\n\n\ttext = xps_parse_glyphs_imp(doc, &local_ctm, font, font_size,\n\t\t\tfz_atof(origin_x_att), fz_atof(origin_y_att),\n\t\t\tis_sideways, bidi_level, indices_att, unicode_att);\n\n\tfz_bound_text(doc->ctx, text, NULL, &local_ctm, &area);\n\n\tif (navigate_uri_att)\n\t\txps_add_link(doc, &area, base_uri, navigate_uri_att);\n\n\txps_begin_opacity(doc, &local_ctm, &area, opacity_mask_uri, dict, opacity_att, opacity_mask_tag);\n\n\t/* If it's a solid color brush fill/stroke do a simple fill */\n\n\tif (fill_tag && !strcmp(fz_xml_tag(fill_tag), \"SolidColorBrush\"))\n\t{\n\t\tfill_opacity_att = fz_xml_att(fill_tag, \"Opacity\");\n\t\tfill_att = fz_xml_att(fill_tag, \"Color\");\n\t\tfill_tag = NULL;\n\t}\n \n        if (fill_att)\n        {\n               float samples[32];\n                fz_colorspace *colorspace;\n \n                xps_parse_color(doc, base_uri, fill_att, &colorspace, samples);\n\t\tif (fill_opacity_att)\n\t\t\tsamples[0] *= fz_atof(fill_opacity_att);\n\t\txps_set_color(doc, colorspace, samples);\n\n\t\tfz_fill_text(doc->dev, text, &local_ctm,\n\t\t\tdoc->colorspace, doc->color, doc->alpha);\n\t}\n\n\t/* If it's a complex brush, use the charpath as a clip mask */\n\n\tif (fill_tag)\n\t{\n\t\tfz_clip_text(doc->dev, text, &local_ctm, 0);\n\t\txps_parse_brush(doc, &local_ctm, &area, fill_uri, dict, fill_tag);\n\t\tfz_pop_clip(doc->dev);\n\t}\n\n\txps_end_opacity(doc, opacity_mask_uri, dict, opacity_att, opacity_mask_tag);\n\n\tfz_free_text(doc->ctx, text);\n\n\tif (clip_att || clip_tag)\n\t\tfz_pop_clip(doc->dev);\n\n\tfz_drop_font(doc->ctx, font);\n}\n", "target": 1, "idx": 178401}
{"func": "hash_foreach_mangle_dict_of_strings (gpointer key, gpointer val, gpointer user_data)\n{\n  GHashTable *out = (GHashTable*) user_data;\n  GHashTable *in_dict = (GHashTable *) val;\n  HashAndString *data = g_new0 (HashAndString, 1);\n  data->string = (gchar*) key;\n  data->hash = g_hash_table_new_full (g_str_hash, g_str_equal,\n                                            g_free, g_free);\n  g_hash_table_foreach (in_dict, hash_foreach_prepend_string, data);\n  g_hash_table_insert(out, g_strdup ((gchar*) key), data->hash);\n}\n", "target": 1, "idx": 178257}
{"func": "xmlPopInput(xmlParserCtxtPtr ctxt) {\n if ((ctxt == NULL) || (ctxt->inputNr <= 1)) return(0);\n if (xmlParserDebugEntities)\n\txmlGenericError(xmlGenericErrorContext,\n \"Popping input %d\\n\", ctxt->inputNr);\n    xmlFreeInputStream(inputPop(ctxt));\n if ((*ctxt->input->cur == 0) &&\n (xmlParserInputGrow(ctxt->input, INPUT_CHUNK) <= 0))\n return(xmlPopInput(ctxt));\n return(CUR);\n}\n", "target": 0, "idx": 176681}
{"func": "  void DidReceiveData(const char* buffer, int length, int data_offset) {\n    DCHECK(channel_ != NULL);\n    DCHECK_GT(length, 0);\n    std::vector<char> data;\n    data.resize(static_cast<size_t>(length));\n    memcpy(&data.front(), buffer, length);\n    scoped_refptr<PluginChannelHost> channel_ref(channel_);\n    channel_->Send(new PluginMsg_DidReceiveData(instance_id_, resource_id_,\n                                                data, data_offset));\n  }\n", "target": 0, "idx": 98767}
{"func": "bool JSTestInterfaceConstructor::getOwnPropertySlot(JSCell* cell, ExecState* exec, const Identifier& propertyName, PropertySlot& slot)\n{\n    return getStaticPropertySlot<JSTestInterfaceConstructor, JSDOMWrapper>(exec, &JSTestInterfaceConstructorTable, jsCast<JSTestInterfaceConstructor*>(cell), propertyName, slot);\n}\n", "target": 0, "idx": 106005}
{"func": "static v8::Handle<v8::Value> methodWithCallbackArgCallback(const v8::Arguments& args)\n {\n     INC_STATS(\"DOM.TestObj.methodWithCallbackArg\");\n     if (args.Length() < 1)\n        return V8Proxy::throwNotEnoughArgumentsError();\n     TestObj* imp = V8TestObj::toNative(args.Holder());\n     if (args.Length() <= 0 || !args[0]->IsFunction())\n         return throwError(TYPE_MISMATCH_ERR, args.GetIsolate());\n    RefPtr<TestCallback> callback = V8TestCallback::create(args[0], getScriptExecutionContext());\n    imp->methodWithCallbackArg(callback);\n    return v8::Handle<v8::Value>();\n}\n", "target": 1, "idx": 184780}
{"func": "free_client(struct nfs4_client *clp)\n{\n\twhile (!list_empty(&clp->cl_sessions)) {\n\t\tstruct nfsd4_session *ses;\n\t\tses = list_entry(clp->cl_sessions.next, struct nfsd4_session,\n\t\t\t\tse_perclnt);\n\t\tlist_del(&ses->se_perclnt);\n\t\tWARN_ON_ONCE(atomic_read(&ses->se_ref));\n\t\tfree_session(ses);\n\t}\n\trpc_destroy_wait_queue(&clp->cl_cb_waitq);\n\tfree_svc_cred(&clp->cl_cred);\n\tkfree(clp->cl_ownerstr_hashtbl);\n\tkfree(clp->cl_name.data);\n\tidr_destroy(&clp->cl_stateids);\n\tkfree(clp);\n}\n", "target": 0, "idx": 65469}
{"func": "long ContentEncoding::ParseContentEncodingEntry(long long start,\n                                                long long size,\n                                                 IMkvReader* pReader) {\n   assert(pReader);\n \n long long pos = start;\n const long long stop = start + size;\n\n int compression_count = 0;\n int encryption_count = 0;\n\n \n   while (pos < stop) {\n     long long id, size;\n    const long status = ParseElementHeader(pReader,\n                                           pos,\n                                           stop,\n                                           id,\n                                           size);\n    if (status < 0)  //error\n       return status;\n \n     if (id == 0x1034)  // ContentCompression ID\n ++compression_count;\n\n\n     if (id == 0x1035)  // ContentEncryption ID\n       ++encryption_count;\n \n    pos += size;  //consume payload\n     assert(pos <= stop);\n   }\n \n if (compression_count <= 0 && encryption_count <= 0)\n return -1;\n\n \n   if (compression_count > 0) {\n     compression_entries_ =\n        new (std::nothrow) ContentCompression*[compression_count];\n     if (!compression_entries_)\n       return -1;\n     compression_entries_end_ = compression_entries_;\n }\n\n \n   if (encryption_count > 0) {\n     encryption_entries_ =\n        new (std::nothrow) ContentEncryption*[encryption_count];\n     if (!encryption_entries_) {\n      delete [] compression_entries_;\n       return -1;\n     }\n     encryption_entries_end_ = encryption_entries_;\n }\n\n\n   pos = start;\n   while (pos < stop) {\n     long long id, size;\n    long status = ParseElementHeader(pReader,\n                                     pos,\n                                     stop,\n                                     id,\n                                     size);\n    if (status < 0)  //error\n       return status;\n \n     if (id == 0x1031) {\n      encoding_order_ = UnserializeUInt(pReader, pos, size);\n } else if (id == 0x1032) {\n      encoding_scope_ = UnserializeUInt(pReader, pos, size);\n if (encoding_scope_ < 1)\n return -1;\n } else if (id == 0x1033) {\n      encoding_type_ = UnserializeUInt(pReader, pos, size);\n\n     } else if (id == 0x1034) {\n       ContentCompression* const compression =\n        new (std::nothrow) ContentCompression();\n       if (!compression)\n         return -1;\n \n      status = ParseCompressionEntry(pos, size, pReader, compression);\n if (status) {\n delete compression;\n return status;\n }\n *compression_entries_end_++ = compression;\n } else if (id == 0x1035) {\n ContentEncryption* const encryption =\n new (std::nothrow) ContentEncryption();\n if (!encryption)\n return -1;\n\n      status = ParseEncryptionEntry(pos, size, pReader, encryption);\n if (status) {\n delete encryption;\n return status;\n }\n\n       *encryption_entries_end_++ = encryption;\n     }\n \n    pos += size;  //consume payload\n     assert(pos <= stop);\n   }\n \n  assert(pos == stop);\n\n   return 0;\n }\n", "target": 1, "idx": 188441}
{"func": "static int l2tp_ip6_backlog_recv(struct sock *sk, struct sk_buff *skb)\n{\n\tint rc;\n\n\t/* Charge it to the socket, dropping if the queue is full. */\n\trc = sock_queue_rcv_skb(sk, skb);\n\tif (rc < 0)\n\t\tgoto drop;\n\n\treturn 0;\n\ndrop:\n\tIP_INC_STATS(&init_net, IPSTATS_MIB_INDISCARDS);\n\tkfree_skb(skb);\n\treturn -1;\n}\n", "target": 0, "idx": 30557}
{"func": "long Chapters::Parse()\n{\n    IMkvReader* const pReader = m_pSegment->m_pReader;\n    long long pos = m_start;  // payload start\n    const long long stop = pos + m_size;  // payload stop\n    while (pos < stop)\n    {\n        long long id, size;\n        long status = ParseElementHeader(\n                        pReader,\n                        pos,\n                        stop,\n                        id,\n                        size);\n        if (status < 0)  // error\n            return status;\n        if (size == 0)  // weird\n            continue;\n        if (id == 0x05B9)  // EditionEntry ID\n        {\n            status = ParseEdition(pos, size);\n            if (status < 0)  // error\n                return status;\n        }\n        pos += size;\n        assert(pos <= stop);\n     }\n \n    assert(pos == stop);\n    return 0;\n }\n", "target": 1, "idx": 188422}
{"func": " static void ReconfigureImpl(Handle<JSObject> object,\n Handle<FixedArrayBase> store, uint32_t entry,\n Handle<Object> value,\n PropertyAttributes attributes) {\n Handle<SeededNumberDictionary> dictionary =\n JSObject::NormalizeElements(object);\n FixedArray::cast(*store)->set(1, *dictionary);\n uint32_t length = static_cast<uint32_t>(store->length()) - 2;\n if (entry >= length) {\n      entry = dictionary->FindEntry(entry - length) + length;\n }\n SlowSloppyArgumentsElementsAccessor::ReconfigureImpl(object, store, entry,\n                                                         value, attributes);\n }\n", "target": 0, "idx": 176341}
{"func": "media::AudioParameters GetDeviceParametersOnDeviceThread(\n    media::AudioManager* audio_manager,\n    const std::string& unique_id) {\n  DCHECK(audio_manager->GetTaskRunner()->BelongsToCurrentThread());\n  return media::AudioDeviceDescription::IsDefaultDevice(unique_id)\n             ? audio_manager->GetDefaultOutputStreamParameters()\n             : audio_manager->GetOutputStreamParameters(unique_id);\n}\n", "target": 1, "idx": 185860}
{"func": "SQLWCHAR* _multi_string_alloc_and_expand( LPCSTR in )\n{\n    SQLWCHAR *chr;\n    int len = 0;\n \n     if ( !in )\n     {\n        return in;\n     }\n     \n     while ( in[ len ] != 0 || in[ len + 1 ] != 0 )\n    {\n        len ++;\n    }\n\n    chr = malloc(sizeof( SQLWCHAR ) * ( len + 2 ));\n\n    len = 0;\n    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )\n    {\n        chr[ len ] = in[ len ];\n        len ++;\n    }\n    chr[ len ++ ] = 0;\n    chr[ len ++ ] = 0;\n\n    return chr;\n}\n", "target": 1, "idx": 182486}
{"func": " OJPEGDecode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)\n {\n \tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n \t(void)s;\n \tif (sp->libjpeg_jpeg_query_style==0)\n \t{\n \t\tif (OJPEGDecodeRaw(tif,buf,cc)==0)\n\t\t\treturn(0);\n\t}\n\telse\n\t{\n\t\tif (OJPEGDecodeScanlines(tif,buf,cc)==0)\n\t\t\treturn(0);\n\t}\n\treturn(1);\n}\n", "target": 1, "idx": 181640}
{"func": " virtual void allocateBuffers(bool async, uint32_t width, uint32_t height,\n PixelFormat format, uint32_t usage) {\n Parcel data, reply;\n        data.writeInterfaceToken(IGraphicBufferProducer::getInterfaceDescriptor());\n        data.writeInt32(static_cast<int32_t>(async));\n        data.writeUint32(width);\n        data.writeUint32(height);\n        data.writeInt32(static_cast<int32_t>(format));\n        data.writeUint32(usage);\n status_t result = remote()->transact(ALLOCATE_BUFFERS, data, &reply);\n if (result != NO_ERROR) {\n            ALOGE(\"allocateBuffers failed to transact: %d\", result);\n }\n }\n", "target": 0, "idx": 174094}
{"func": "xmlXPathNextDescendant(xmlXPathParserContextPtr ctxt, xmlNodePtr cur) {\n    if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);\n    if (cur == NULL) {\n\tif (ctxt->context->node == NULL)\n\t    return(NULL);\n\tif ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||\n\t    (ctxt->context->node->type == XML_NAMESPACE_DECL))\n\t    return(NULL);\n\n        if (ctxt->context->node == (xmlNodePtr) ctxt->context->doc)\n\t    return(ctxt->context->doc->children);\n        return(ctxt->context->node->children);\n    }\n\n    if (cur->children != NULL) {\n\t/*\n\t * Do not descend on entities declarations\n\t */\n\tif (cur->children->type != XML_ENTITY_DECL) {\n\t    cur = cur->children;\n\t    /*\n\t     * Skip DTDs\n\t     */\n\t    if (cur->type != XML_DTD_NODE)\n\t\treturn(cur);\n\t}\n    }\n\n    if (cur == ctxt->context->node) return(NULL);\n\n    while (cur->next != NULL) {\n\tcur = cur->next;\n\tif ((cur->type != XML_ENTITY_DECL) &&\n\t    (cur->type != XML_DTD_NODE))\n\t    return(cur);\n    }\n\n    do {\n        cur = cur->parent;\n\tif (cur == NULL) break;\n\tif (cur == ctxt->context->node) return(NULL);\n\tif (cur->next != NULL) {\n\t    cur = cur->next;\n\t    return(cur);\n\t}\n    } while (cur != NULL);\n    return(cur);\n}\n", "target": 0, "idx": 97722}
{"func": "XRRGetMonitors(Display *dpy, Window window, Bool get_active, int *nmonitors)\n{\n    XExtDisplayInfo\t    *info = XRRFindDisplay(dpy);\n    xRRGetMonitorsReply\t    rep;\n    xRRGetMonitorsReq\t    *req;\n    int\t\t\t    nbytes, nbytesRead, rbytes;\n    int\t\t\t    nmon, noutput;\n    int\t\t\t    m, o;\n    char\t\t    *buf, *buf_head;\n    xRRMonitorInfo\t    *xmon;\n    CARD32\t\t    *xoutput;\n    XRRMonitorInfo\t    *mon = NULL;\n    RROutput\t\t    *output;\n\n    RRCheckExtension (dpy, info, NULL);\n\n    *nmonitors = -1;\n\n    LockDisplay (dpy);\n    GetReq (RRGetMonitors, req);\n    req->reqType = info->codes->major_opcode;\n    req->randrReqType = X_RRGetMonitors;\n    req->window = window;\n    req->get_active = get_active;\n\n    if (!_XReply (dpy, (xReply *) &rep, 0, xFalse))\n    {\n\tUnlockDisplay (dpy);\n\tSyncHandle ();\n\treturn NULL;\n \treturn NULL;\n     }\n \n     nbytes = (long) rep.length << 2;\n     nmon = rep.nmonitors;\n     noutput = rep.noutputs;\n\trbytes = nmon * sizeof (XRRMonitorInfo) + noutput * sizeof(RROutput);\n\n\tbuf = buf_head = Xmalloc (nbytesRead);\n\tmon = Xmalloc (rbytes);\n\n\tif (buf == NULL || mon == NULL) {\n\t    Xfree(buf);\n\t    Xfree(mon);\n\t    _XEatDataWords (dpy, rep.length);\n\t    UnlockDisplay (dpy);\n\t    SyncHandle ();\n\t    return NULL;\n\t}\n\n\t_XReadPad(dpy, buf, nbytesRead);\n\n\toutput = (RROutput *) (mon + nmon);\n\n\tfor (m = 0; m < nmon; m++) {\n\t    xmon = (xRRMonitorInfo *) buf;\n\t    mon[m].name = xmon->name;\n\t    mon[m].primary = xmon->primary;\n\t    mon[m].automatic = xmon->automatic;\n\t    mon[m].noutput = xmon->noutput;\n\t    mon[m].x = xmon->x;\n\t    mon[m].y = xmon->y;\n\t    mon[m].width = xmon->width;\n\t    mon[m].height = xmon->height;\n\t    mon[m].mwidth = xmon->widthInMillimeters;\n\t    mon[m].mheight = xmon->heightInMillimeters;\n\t    mon[m].outputs = output;\n\t    buf += SIZEOF (xRRMonitorInfo);\n\t    xoutput = (CARD32 *) buf;\n\t    for (o = 0; o < xmon->noutput; o++)\n\t\toutput[o] = xoutput[o];\n\t    output += xmon->noutput;\n\t    buf += xmon->noutput * 4;\n\t}\n\tXfree(buf_head);\n    }\n", "target": 1, "idx": 178086}
{"func": "static int ext4_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tchar *orig_data = kstrdup(data, GFP_KERNEL);\n\tstruct buffer_head *bh;\n\tstruct ext4_super_block *es = NULL;\n\tstruct ext4_sb_info *sbi;\n\text4_fsblk_t block;\n\text4_fsblk_t sb_block = get_sb_block(&data);\n\text4_fsblk_t logical_sb_block;\n\tunsigned long offset = 0;\n\tunsigned long journal_devnum = 0;\n\tunsigned long def_mount_opts;\n\tstruct inode *root;\n\tconst char *descr;\n\tint ret = -ENOMEM;\n\tint blocksize, clustersize;\n\tunsigned int db_count;\n\tunsigned int i;\n\tint needs_recovery, has_huge_files, has_bigalloc;\n\t__u64 blocks_count;\n\tint err = 0;\n\tunsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO;\n\text4_group_t first_not_zeroed;\n\n\tsbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\tif (!sbi)\n\t\tgoto out_free_orig;\n\n\tsbi->s_blockgroup_lock =\n\t\tkzalloc(sizeof(struct blockgroup_lock), GFP_KERNEL);\n\tif (!sbi->s_blockgroup_lock) {\n\t\tkfree(sbi);\n\t\tgoto out_free_orig;\n\t}\n\tsb->s_fs_info = sbi;\n\tsbi->s_sb = sb;\n\tsbi->s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS;\n\tsbi->s_sb_block = sb_block;\n\tif (sb->s_bdev->bd_part)\n\t\tsbi->s_sectors_written_start =\n\t\t\tpart_stat_read(sb->s_bdev->bd_part, sectors[1]);\n\n\t/* Cleanup superblock name */\n\tstrreplace(sb->s_id, '/', '!');\n\n\t/* -EINVAL is default */\n\tret = -EINVAL;\n\tblocksize = sb_min_blocksize(sb, EXT4_MIN_BLOCK_SIZE);\n\tif (!blocksize) {\n\t\text4_msg(sb, KERN_ERR, \"unable to set blocksize\");\n\t\tgoto out_fail;\n\t}\n\n\t/*\n\t * The ext4 superblock will not be buffer aligned for other than 1kB\n\t * block sizes.  We need to calculate the offset from buffer start.\n\t */\n\tif (blocksize != EXT4_MIN_BLOCK_SIZE) {\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t} else {\n\t\tlogical_sb_block = sb_block;\n\t}\n\n\tif (!(bh = sb_bread_unmovable(sb, logical_sb_block))) {\n\t\text4_msg(sb, KERN_ERR, \"unable to read superblock\");\n\t\tgoto out_fail;\n\t}\n\t/*\n\t * Note: s_es must be initialized as soon as possible because\n\t *       some ext4 macro-instructions depend on its value\n\t */\n\tes = (struct ext4_super_block *) (bh->b_data + offset);\n\tsbi->s_es = es;\n\tsb->s_magic = le16_to_cpu(es->s_magic);\n\tif (sb->s_magic != EXT4_SUPER_MAGIC)\n\t\tgoto cantfind_ext4;\n\tsbi->s_kbytes_written = le64_to_cpu(es->s_kbytes_written);\n\n\t/* Warn if metadata_csum and gdt_csum are both set. */\n\tif (ext4_has_feature_metadata_csum(sb) &&\n\t    ext4_has_feature_gdt_csum(sb))\n\t\text4_warning(sb, \"metadata_csum and uninit_bg are \"\n\t\t\t     \"redundant flags; please run fsck.\");\n\n\t/* Check for a known checksum algorithm */\n\tif (!ext4_verify_csum_type(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"unknown checksum algorithm.\");\n\t\tsilent = 1;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Load the checksum driver */\n\tif (ext4_has_feature_metadata_csum(sb)) {\n\t\tsbi->s_chksum_driver = crypto_alloc_shash(\"crc32c\", 0, 0);\n\t\tif (IS_ERR(sbi->s_chksum_driver)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Cannot load crc32c driver.\");\n\t\t\tret = PTR_ERR(sbi->s_chksum_driver);\n\t\t\tsbi->s_chksum_driver = NULL;\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/* Check superblock checksum */\n\tif (!ext4_superblock_csum_verify(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"invalid superblock checksum.  Run e2fsck?\");\n\t\tsilent = 1;\n\t\tret = -EFSBADCRC;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Precompute checksum seed for all metadata */\n\tif (ext4_has_feature_csum_seed(sb))\n\t\tsbi->s_csum_seed = le32_to_cpu(es->s_checksum_seed);\n\telse if (ext4_has_metadata_csum(sb))\n\t\tsbi->s_csum_seed = ext4_chksum(sbi, ~0, es->s_uuid,\n\t\t\t\t\t       sizeof(es->s_uuid));\n\n\t/* Set defaults before we parse the mount options */\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\tset_opt(sb, INIT_INODE_TABLE);\n\tif (def_mount_opts & EXT4_DEFM_DEBUG)\n\t\tset_opt(sb, DEBUG);\n\tif (def_mount_opts & EXT4_DEFM_BSDGROUPS)\n\t\tset_opt(sb, GRPID);\n\tif (def_mount_opts & EXT4_DEFM_UID16)\n\t\tset_opt(sb, NO_UID32);\n\t/* xattr user namespace & acls are now defaulted on */\n\tset_opt(sb, XATTR_USER);\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\tset_opt(sb, POSIX_ACL);\n#endif\n\t/* don't forget to enable journal_csum when metadata_csum is enabled. */\n\tif (ext4_has_metadata_csum(sb))\n\t\tset_opt(sb, JOURNAL_CHECKSUM);\n\n\tif ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_DATA)\n\t\tset_opt(sb, JOURNAL_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_ORDERED)\n\t\tset_opt(sb, ORDERED_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_WBACK)\n\t\tset_opt(sb, WRITEBACK_DATA);\n\n\tif (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_PANIC)\n\t\tset_opt(sb, ERRORS_PANIC);\n\telse if (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_CONTINUE)\n\t\tset_opt(sb, ERRORS_CONT);\n\telse\n\t\tset_opt(sb, ERRORS_RO);\n\t/* block_validity enabled by default; disable with noblock_validity */\n\tset_opt(sb, BLOCK_VALIDITY);\n\tif (def_mount_opts & EXT4_DEFM_DISCARD)\n\t\tset_opt(sb, DISCARD);\n\n\tsbi->s_resuid = make_kuid(&init_user_ns, le16_to_cpu(es->s_def_resuid));\n\tsbi->s_resgid = make_kgid(&init_user_ns, le16_to_cpu(es->s_def_resgid));\n\tsbi->s_commit_interval = JBD2_DEFAULT_MAX_COMMIT_AGE * HZ;\n\tsbi->s_min_batch_time = EXT4_DEF_MIN_BATCH_TIME;\n\tsbi->s_max_batch_time = EXT4_DEF_MAX_BATCH_TIME;\n\n\tif ((def_mount_opts & EXT4_DEFM_NOBARRIER) == 0)\n\t\tset_opt(sb, BARRIER);\n\n\t/*\n\t * enable delayed allocation by default\n\t * Use -o nodelalloc to turn it off\n\t */\n\tif (!IS_EXT3_SB(sb) && !IS_EXT2_SB(sb) &&\n\t    ((def_mount_opts & EXT4_DEFM_NODELALLOC) == 0))\n\t\tset_opt(sb, DELALLOC);\n\n\t/*\n\t * set default s_li_wait_mult for lazyinit, for the case there is\n\t * no mount option specified.\n\t */\n\tsbi->s_li_wait_mult = EXT4_DEF_LI_WAIT_MULT;\n\n\tif (!parse_options((char *) sbi->s_es->s_mount_opts, sb,\n\t\t\t   &journal_devnum, &journal_ioprio, 0)) {\n\t\text4_msg(sb, KERN_WARNING,\n\t\t\t \"failed to parse options in superblock: %s\",\n\t\t\t sbi->s_es->s_mount_opts);\n\t}\n\tsbi->s_def_mount_opt = sbi->s_mount_opt;\n\tif (!parse_options((char *) data, sb, &journal_devnum,\n\t\t\t   &journal_ioprio, 0))\n\t\tgoto failed_mount;\n\n\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA) {\n\t\tprintk_once(KERN_WARNING \"EXT4-fs: Warning: mounting \"\n\t\t\t    \"with data=journal disables delayed \"\n\t\t\t    \"allocation and O_DIRECT support!\\n\");\n\t\tif (test_opt2(sb, EXPLICIT_DELALLOC)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and delalloc\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DIOREAD_NOLOCK)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dioread_nolock\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DAX)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dax\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DELALLOC))\n\t\t\tclear_opt(sb, DELALLOC);\n\t} else {\n\t\tsb->s_iflags |= SB_I_CGROUPWB;\n\t}\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t(test_opt(sb, POSIX_ACL) ? MS_POSIXACL : 0);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV &&\n\t    (ext4_has_compat_features(sb) ||\n\t     ext4_has_ro_compat_features(sb) ||\n\t     ext4_has_incompat_features(sb)))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t       \"feature flags set on rev 0 fs, \"\n\t\t       \"running e2fsck is recommended\");\n\n\tif (es->s_creator_os == cpu_to_le32(EXT4_OS_HURD)) {\n\t\tset_opt2(sb, HURD_COMPAT);\n\t\tif (ext4_has_feature_64bit(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"The Hurd can't support 64-bit file systems\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT2_SB(sb)) {\n\t\tif (ext2_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext2 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext2 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT3_SB(sb)) {\n\t\tif (ext3_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext3 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext3 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/*\n\t * Check feature flags regardless of the revision level, since we\n\t * previously didn't change the revision level when setting the flags,\n\t * so there is a chance incompat flags are set on a rev 0 filesystem.\n\t */\n\tif (!ext4_feature_set_ok(sb, (sb->s_flags & MS_RDONLY)))\n\t\tgoto failed_mount;\n\n\tblocksize = BLOCK_SIZE << le32_to_cpu(es->s_log_block_size);\n\tif (blocksize < EXT4_MIN_BLOCK_SIZE ||\n\t    blocksize > EXT4_MAX_BLOCK_SIZE) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t       \"Unsupported filesystem blocksize %d\", blocksize);\n\t\tgoto failed_mount;\n\t}\n\n\tif (sbi->s_mount_opt & EXT4_MOUNT_DAX) {\n\t\tif (blocksize != PAGE_SIZE) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t\t\"error: unsupported blocksize for dax\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (!sb->s_bdev->bd_disk->fops->direct_access) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t\t\"error: device does not support dax\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (ext4_has_feature_encrypt(sb) && es->s_encryption_level) {\n\t\text4_msg(sb, KERN_ERR, \"Unsupported encryption level %d\",\n\t\t\t es->s_encryption_level);\n\t\tgoto failed_mount;\n\t}\n\n\tif (sb->s_blocksize != blocksize) {\n\t\t/* Validate the filesystem blocksize */\n\t\tif (!sb_set_blocksize(sb, blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR, \"bad block size %d\",\n\t\t\t\t\tblocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t\tbh = sb_bread_unmovable(sb, logical_sb_block);\n\t\tif (!bh) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Can't read superblock on 2nd try\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tes = (struct ext4_super_block *)(bh->b_data + offset);\n\t\tsbi->s_es = es;\n\t\tif (es->s_magic != cpu_to_le16(EXT4_SUPER_MAGIC)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Magic mismatch, very weird!\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\thas_huge_files = ext4_has_feature_huge_file(sb);\n\tsbi->s_bitmap_maxbytes = ext4_max_bitmap_size(sb->s_blocksize_bits,\n\t\t\t\t\t\t      has_huge_files);\n\tsb->s_maxbytes = ext4_max_size(sb->s_blocksize_bits, has_huge_files);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV) {\n\t\tsbi->s_inode_size = EXT4_GOOD_OLD_INODE_SIZE;\n\t\tsbi->s_first_ino = EXT4_GOOD_OLD_FIRST_INO;\n\t} else {\n\t\tsbi->s_inode_size = le16_to_cpu(es->s_inode_size);\n\t\tsbi->s_first_ino = le32_to_cpu(es->s_first_ino);\n\t\tif ((sbi->s_inode_size < EXT4_GOOD_OLD_INODE_SIZE) ||\n\t\t    (!is_power_of_2(sbi->s_inode_size)) ||\n\t\t    (sbi->s_inode_size > blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported inode size: %d\",\n\t\t\t       sbi->s_inode_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE)\n\t\t\tsb->s_time_gran = 1 << (EXT4_EPOCH_BITS - 2);\n\t}\n\n\tsbi->s_desc_size = le16_to_cpu(es->s_desc_size);\n\tif (ext4_has_feature_64bit(sb)) {\n\t\tif (sbi->s_desc_size < EXT4_MIN_DESC_SIZE_64BIT ||\n\t\t    sbi->s_desc_size > EXT4_MAX_DESC_SIZE ||\n\t\t    !is_power_of_2(sbi->s_desc_size)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported descriptor size %lu\",\n\t\t\t       sbi->s_desc_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else\n\t\tsbi->s_desc_size = EXT4_MIN_DESC_SIZE;\n\n\tsbi->s_blocks_per_group = le32_to_cpu(es->s_blocks_per_group);\n\tsbi->s_inodes_per_group = le32_to_cpu(es->s_inodes_per_group);\n\tif (EXT4_INODE_SIZE(sb) == 0 || EXT4_INODES_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext4;\n\n\tsbi->s_inodes_per_block = blocksize / EXT4_INODE_SIZE(sb);\n\tif (sbi->s_inodes_per_block == 0)\n\t\tgoto cantfind_ext4;\n\tsbi->s_itb_per_group = sbi->s_inodes_per_group /\n\t\t\t\t\tsbi->s_inodes_per_block;\n\tsbi->s_desc_per_block = blocksize / EXT4_DESC_SIZE(sb);\n\tsbi->s_sbh = bh;\n\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\tsbi->s_addr_per_block_bits = ilog2(EXT4_ADDR_PER_BLOCK(sb));\n\tsbi->s_desc_per_block_bits = ilog2(EXT4_DESC_PER_BLOCK(sb));\n\n\tfor (i = 0; i < 4; i++)\n\t\tsbi->s_hash_seed[i] = le32_to_cpu(es->s_hash_seed[i]);\n\tsbi->s_def_hash_version = es->s_def_hash_version;\n\tif (ext4_has_feature_dir_index(sb)) {\n\t\ti = le32_to_cpu(es->s_flags);\n\t\tif (i & EXT2_FLAGS_UNSIGNED_HASH)\n\t\t\tsbi->s_hash_unsigned = 3;\n\t\telse if ((i & EXT2_FLAGS_SIGNED_HASH) == 0) {\n#ifdef __CHAR_UNSIGNED__\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_UNSIGNED_HASH);\n\t\t\tsbi->s_hash_unsigned = 3;\n#else\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_SIGNED_HASH);\n#endif\n\t\t}\n\t}\n\n\t/* Handle clustersize */\n\tclustersize = BLOCK_SIZE << le32_to_cpu(es->s_log_cluster_size);\n\thas_bigalloc = ext4_has_feature_bigalloc(sb);\n\tif (has_bigalloc) {\n\t\tif (clustersize < blocksize) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"cluster size (%d) smaller than \"\n\t\t\t\t \"block size (%d)\", clustersize, blocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_cluster_bits = le32_to_cpu(es->s_log_cluster_size) -\n\t\t\tle32_to_cpu(es->s_log_block_size);\n\t\tsbi->s_clusters_per_group =\n\t\t\tle32_to_cpu(es->s_clusters_per_group);\n\t\tif (sbi->s_clusters_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#clusters per group too big: %lu\",\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_blocks_per_group !=\n\t\t    (sbi->s_clusters_per_group * (clustersize / blocksize))) {\n\t\t\text4_msg(sb, KERN_ERR, \"blocks per group (%lu) and \"\n\t\t\t\t \"clusters per group (%lu) inconsistent\",\n\t\t\t\t sbi->s_blocks_per_group,\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else {\n\t\tif (clustersize != blocksize) {\n\t\t\text4_warning(sb, \"fragment/cluster size (%d) != \"\n\t\t\t\t     \"block size (%d)\", clustersize,\n\t\t\t\t     blocksize);\n\t\t\tclustersize = blocksize;\n\t\t}\n\t\tif (sbi->s_blocks_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#blocks per group too big: %lu\",\n\t\t\t\t sbi->s_blocks_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_clusters_per_group = sbi->s_blocks_per_group;\n\t\tsbi->s_cluster_bits = 0;\n\t}\n\tsbi->s_cluster_ratio = clustersize / blocksize;\n\n\tif (sbi->s_inodes_per_group > blocksize * 8) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t       \"#inodes per group too big: %lu\",\n\t\t       sbi->s_inodes_per_group);\n\t\tgoto failed_mount;\n\t}\n\n\t/* Do we have standard group size of clustersize * 8 blocks ? */\n\tif (sbi->s_blocks_per_group == clustersize << 3)\n\t\tset_opt2(sb, STD_GROUP_SIZE);\n\n\t/*\n\t * Test whether we have more sectors than will fit in sector_t,\n\t * and whether the max offset is addressable by the page cache.\n\t */\n\terr = generic_check_addressable(sb->s_blocksize_bits,\n\t\t\t\t\text4_blocks_count(es));\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"filesystem\"\n\t\t\t \" too large to mount safely on this system\");\n\t\tif (sizeof(sector_t) < 8)\n\t\t\text4_msg(sb, KERN_WARNING, \"CONFIG_LBDAF not enabled\");\n\t\tgoto failed_mount;\n\t}\n\n\tif (EXT4_BLOCKS_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext4;\n\n\t/* check blocks count against device size */\n\tblocks_count = sb->s_bdev->bd_inode->i_size >> sb->s_blocksize_bits;\n\tif (blocks_count && ext4_blocks_count(es) > blocks_count) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: block count %llu \"\n\t\t       \"exceeds size of device (%llu blocks)\",\n\t\t       ext4_blocks_count(es), blocks_count);\n\t\tgoto failed_mount;\n\t}\n\n\t/*\n\t * It makes no sense for the first data block to be beyond the end\n\t * of the filesystem.\n\t */\n\tif (le32_to_cpu(es->s_first_data_block) >= ext4_blocks_count(es)) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: first data \"\n\t\t\t \"block %u is beyond end of filesystem (%llu)\",\n\t\t\t le32_to_cpu(es->s_first_data_block),\n\t\t\t ext4_blocks_count(es));\n\t\tgoto failed_mount;\n\t}\n\tblocks_count = (ext4_blocks_count(es) -\n\t\t\tle32_to_cpu(es->s_first_data_block) +\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb) - 1);\n\tdo_div(blocks_count, EXT4_BLOCKS_PER_GROUP(sb));\n\tif (blocks_count > ((uint64_t)1<<32) - EXT4_DESC_PER_BLOCK(sb)) {\n\t\text4_msg(sb, KERN_WARNING, \"groups count too large: %u \"\n\t\t       \"(block count %llu, first data block %u, \"\n\t\t       \"blocks per group %lu)\", sbi->s_groups_count,\n\t\t       ext4_blocks_count(es),\n\t\t       le32_to_cpu(es->s_first_data_block),\n\t\t       EXT4_BLOCKS_PER_GROUP(sb));\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_groups_count = blocks_count;\n\tsbi->s_blockfile_groups = min_t(ext4_group_t, sbi->s_groups_count,\n\t\t\t(EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP(sb)));\n\tdb_count = (sbi->s_groups_count + EXT4_DESC_PER_BLOCK(sb) - 1) /\n\t\t   EXT4_DESC_PER_BLOCK(sb);\n\tsbi->s_group_desc = ext4_kvmalloc(db_count *\n\t\t\t\t\t  sizeof(struct buffer_head *),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (sbi->s_group_desc == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount;\n\t}\n\n\tbgl_lock_init(sbi->s_blockgroup_lock);\n\n\tfor (i = 0; i < db_count; i++) {\n\t\tblock = descriptor_loc(sb, logical_sb_block, i);\n\t\tsbi->s_group_desc[i] = sb_bread_unmovable(sb, block);\n\t\tif (!sbi->s_group_desc[i]) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"can't read group descriptor %d\", i);\n\t\t\tdb_count = i;\n\t\t\tgoto failed_mount2;\n\t\t}\n\t}\n\tif (!ext4_check_descriptors(sb, &first_not_zeroed)) {\n\t\text4_msg(sb, KERN_ERR, \"group descriptors corrupted!\");\n\t\tret = -EFSCORRUPTED;\n\t\tgoto failed_mount2;\n\t}\n\n\tsbi->s_gdb_count = db_count;\n\tget_random_bytes(&sbi->s_next_generation, sizeof(u32));\n\tspin_lock_init(&sbi->s_next_gen_lock);\n\n\tsetup_timer(&sbi->s_err_report, print_daily_error_info,\n\t\t(unsigned long) sb);\n\n\t/* Register extent status tree shrinker */\n\tif (ext4_es_register_shrinker(sbi))\n\t\tgoto failed_mount3;\n\n\tsbi->s_stripe = ext4_get_stripe_size(sbi);\n\tsbi->s_extent_max_zeroout_kb = 32;\n\n\t/*\n\t * set up enough so that it can read an inode\n\t */\n\tsb->s_op = &ext4_sops;\n\tsb->s_export_op = &ext4_export_ops;\n\tsb->s_xattr = ext4_xattr_handlers;\n#ifdef CONFIG_QUOTA\n\tsb->dq_op = &ext4_quota_operations;\n\tif (ext4_has_feature_quota(sb))\n\t\tsb->s_qcop = &dquot_quotactl_sysfile_ops;\n\telse\n\t\tsb->s_qcop = &ext4_qctl_operations;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP | QTYPE_MASK_PRJ;\n#endif\n\tmemcpy(sb->s_uuid, es->s_uuid, sizeof(es->s_uuid));\n\n\tINIT_LIST_HEAD(&sbi->s_orphan); /* unlinked but open files */\n\tmutex_init(&sbi->s_orphan_lock);\n\n\tsb->s_root = NULL;\n\n\tneeds_recovery = (es->s_last_orphan != 0 ||\n\t\t\t  ext4_has_feature_journal_needs_recovery(sb));\n\n\tif (ext4_has_feature_mmp(sb) && !(sb->s_flags & MS_RDONLY))\n\t\tif (ext4_multi_mount_protect(sb, le64_to_cpu(es->s_mmp_block)))\n\t\t\tgoto failed_mount3a;\n\n\t/*\n\t * The first inode we look at is the journal inode.  Don't try\n\t * root first: it may be modified in the journal!\n\t */\n\tif (!test_opt(sb, NOLOAD) && ext4_has_feature_journal(sb)) {\n\t\tif (ext4_load_journal(sb, es, journal_devnum))\n\t\t\tgoto failed_mount3a;\n\t} else if (test_opt(sb, NOLOAD) && !(sb->s_flags & MS_RDONLY) &&\n\t\t   ext4_has_feature_journal_needs_recovery(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"required journal recovery \"\n\t\t       \"suppressed and not mounted read-only\");\n\t\tgoto failed_mount_wq;\n\t} else {\n\t\t/* Nojournal mode, all journal mount options are illegal */\n\t\tif (test_opt2(sb, EXPLICIT_JOURNAL_CHECKSUM)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_checksum, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_async_commit, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (sbi->s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE*HZ) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"commit=%lu, fs mounted w/o journal\",\n\t\t\t\t sbi->s_commit_interval / HZ);\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (EXT4_MOUNT_DATA_FLAGS &\n\t\t    (sbi->s_mount_opt ^ sbi->s_def_mount_opt)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"data=, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tsbi->s_def_mount_opt &= EXT4_MOUNT_JOURNAL_CHECKSUM;\n\t\tclear_opt(sb, JOURNAL_CHECKSUM);\n\t\tclear_opt(sb, DATA_FLAGS);\n\t\tsbi->s_journal = NULL;\n\t\tneeds_recovery = 0;\n\t\tgoto no_journal;\n\t}\n\n\tif (ext4_has_feature_64bit(sb) &&\n\t    !jbd2_journal_set_features(EXT4_SB(sb)->s_journal, 0, 0,\n\t\t\t\t       JBD2_FEATURE_INCOMPAT_64BIT)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set 64-bit journal feature\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (!set_journal_csum_feature_set(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set journal checksum \"\n\t\t\t \"feature set\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\t/* We have now updated the journal if required, so we can\n\t * validate the data journaling mode. */\n\tswitch (test_opt(sb, DATA_FLAGS)) {\n\tcase 0:\n\t\t/* No mode set, assume a default based on the journal\n\t\t * capabilities: ORDERED_DATA if the journal can\n\t\t * cope, else JOURNAL_DATA\n\t\t */\n\t\tif (jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE))\n\t\t\tset_opt(sb, ORDERED_DATA);\n\t\telse\n\t\t\tset_opt(sb, JOURNAL_DATA);\n\t\tbreak;\n\n\tcase EXT4_MOUNT_ORDERED_DATA:\n\tcase EXT4_MOUNT_WRITEBACK_DATA:\n\t\tif (!jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Journal does not support \"\n\t\t\t       \"requested data journaling mode\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\tdefault:\n\t\tbreak;\n\t}\n\tset_task_ioprio(sbi->s_journal->j_task, journal_ioprio);\n\n\tsbi->s_journal->j_commit_callback = ext4_journal_commit_callback;\n \n no_journal:\n \tif (ext4_mballoc_ready) {\n\t\tsbi->s_mb_cache = ext4_xattr_create_cache(sb->s_id);\n \t\tif (!sbi->s_mb_cache) {\n \t\t\text4_msg(sb, KERN_ERR, \"Failed to create an mb_cache\");\n \t\t\tgoto failed_mount_wq;\n\t\t}\n\t}\n\n\tif ((DUMMY_ENCRYPTION_ENABLED(sbi) || ext4_has_feature_encrypt(sb)) &&\n\t    (blocksize != PAGE_CACHE_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Unsupported blocksize for fs encryption\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (DUMMY_ENCRYPTION_ENABLED(sbi) && !(sb->s_flags & MS_RDONLY) &&\n\t    !ext4_has_feature_encrypt(sb)) {\n\t\text4_set_feature_encrypt(sb);\n\t\text4_commit_super(sb, 1);\n\t}\n\n\t/*\n\t * Get the # of file system overhead blocks from the\n\t * superblock if present.\n\t */\n\tif (es->s_overhead_clusters)\n\t\tsbi->s_overhead = le32_to_cpu(es->s_overhead_clusters);\n\telse {\n\t\terr = ext4_calculate_overhead(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount_wq;\n\t}\n\n\t/*\n\t * The maximum number of concurrent works can be high and\n\t * concurrency isn't really necessary.  Limit it to 1.\n\t */\n\tEXT4_SB(sb)->rsv_conversion_wq =\n\t\talloc_workqueue(\"ext4-rsv-conversion\", WQ_MEM_RECLAIM | WQ_UNBOUND, 1);\n\tif (!EXT4_SB(sb)->rsv_conversion_wq) {\n\t\tprintk(KERN_ERR \"EXT4-fs: failed to create workqueue\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\t/*\n\t * The jbd2_journal_load will have done any necessary log recovery,\n\t * so we can safely mount the rest of the filesystem now.\n\t */\n\n\troot = ext4_iget(sb, EXT4_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\text4_msg(sb, KERN_ERR, \"get root inode failed\");\n\t\tret = PTR_ERR(root);\n\t\troot = NULL;\n\t\tgoto failed_mount4;\n\t}\n\tif (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {\n\t\text4_msg(sb, KERN_ERR, \"corrupt root inode, run e2fsck\");\n\t\tiput(root);\n\t\tgoto failed_mount4;\n\t}\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\text4_msg(sb, KERN_ERR, \"get root dentry failed\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\tif (ext4_setup_super(sb, es, sb->s_flags & MS_RDONLY))\n\t\tsb->s_flags |= MS_RDONLY;\n\n\t/* determine the minimum size of new large inodes, if present */\n\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t     EXT4_GOOD_OLD_INODE_SIZE;\n\t\tif (ext4_has_feature_extra_isize(sb)) {\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_want_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_want_extra_isize);\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_min_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_min_extra_isize);\n\t\t}\n\t}\n\t/* Check if enough inode space is available */\n\tif (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >\n\t\t\t\t\t\t\tsbi->s_inode_size) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t       EXT4_GOOD_OLD_INODE_SIZE;\n\t\text4_msg(sb, KERN_INFO, \"required extra inode space not\"\n\t\t\t \"available\");\n\t}\n\n\text4_set_resv_clusters(sb);\n\n\terr = ext4_setup_system_zone(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize system \"\n\t\t\t \"zone (%d)\", err);\n\t\tgoto failed_mount4a;\n\t}\n\n\text4_ext_init(sb);\n\terr = ext4_mb_init(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize mballoc (%d)\",\n\t\t\t err);\n\t\tgoto failed_mount5;\n\t}\n\n\tblock = ext4_count_free_clusters(sb);\n\text4_free_blocks_count_set(sbi->s_es, \n\t\t\t\t   EXT4_C2B(sbi, block));\n\terr = percpu_counter_init(&sbi->s_freeclusters_counter, block,\n\t\t\t\t  GFP_KERNEL);\n\tif (!err) {\n\t\tunsigned long freei = ext4_count_free_inodes(sb);\n\t\tsbi->s_es->s_free_inodes_count = cpu_to_le32(freei);\n\t\terr = percpu_counter_init(&sbi->s_freeinodes_counter, freei,\n\t\t\t\t\t  GFP_KERNEL);\n\t}\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirs_counter,\n\t\t\t\t\t  ext4_count_dirs(sb), GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirtyclusters_counter, 0,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"insufficient memory\");\n\t\tgoto failed_mount6;\n\t}\n\n\tif (ext4_has_feature_flex_bg(sb))\n\t\tif (!ext4_fill_flex_info(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unable to initialize \"\n\t\t\t       \"flex_bg meta info!\");\n\t\t\tgoto failed_mount6;\n\t\t}\n\n\terr = ext4_register_li_request(sb, first_not_zeroed);\n\tif (err)\n\t\tgoto failed_mount6;\n\n\terr = ext4_register_sysfs(sb);\n\tif (err)\n\t\tgoto failed_mount7;\n\n#ifdef CONFIG_QUOTA\n\t/* Enable quota usage during mount. */\n\tif (ext4_has_feature_quota(sb) && !(sb->s_flags & MS_RDONLY)) {\n\t\terr = ext4_enable_quotas(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount8;\n\t}\n#endif  /* CONFIG_QUOTA */\n\n\tEXT4_SB(sb)->s_mount_state |= EXT4_ORPHAN_FS;\n\text4_orphan_cleanup(sb, es);\n\tEXT4_SB(sb)->s_mount_state &= ~EXT4_ORPHAN_FS;\n\tif (needs_recovery) {\n\t\text4_msg(sb, KERN_INFO, \"recovery complete\");\n\t\text4_mark_recovery_complete(sb, es);\n\t}\n\tif (EXT4_SB(sb)->s_journal) {\n\t\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)\n\t\t\tdescr = \" journalled data mode\";\n\t\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)\n\t\t\tdescr = \" ordered data mode\";\n\t\telse\n\t\t\tdescr = \" writeback data mode\";\n\t} else\n\t\tdescr = \"out journal\";\n\n\tif (test_opt(sb, DISCARD)) {\n\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\tif (!blk_queue_discard(q))\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"mounting with \\\"discard\\\" option, but \"\n\t\t\t\t \"the device does not support discard\");\n\t}\n\n\tif (___ratelimit(&ext4_mount_msg_ratelimit, \"EXT4-fs mount\"))\n\t\text4_msg(sb, KERN_INFO, \"mounted filesystem with%s. \"\n\t\t\t \"Opts: %s%s%s\", descr, sbi->s_es->s_mount_opts,\n\t\t\t *sbi->s_es->s_mount_opts ? \"; \" : \"\", orig_data);\n\n\tif (es->s_error_count)\n\t\tmod_timer(&sbi->s_err_report, jiffies + 300*HZ); /* 5 minutes */\n\n\t/* Enable message ratelimiting. Default is 10 messages per 5 secs. */\n\tratelimit_state_init(&sbi->s_err_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_warning_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_msg_ratelimit_state, 5 * HZ, 10);\n\n\tkfree(orig_data);\n\treturn 0;\n\ncantfind_ext4:\n\tif (!silent)\n\t\text4_msg(sb, KERN_ERR, \"VFS: Can't find ext4 filesystem\");\n\tgoto failed_mount;\n\n#ifdef CONFIG_QUOTA\nfailed_mount8:\n\text4_unregister_sysfs(sb);\n#endif\nfailed_mount7:\n\text4_unregister_li_request(sb);\nfailed_mount6:\n\text4_mb_release(sb);\n\tif (sbi->s_flex_groups)\n\t\tkvfree(sbi->s_flex_groups);\n\tpercpu_counter_destroy(&sbi->s_freeclusters_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tpercpu_counter_destroy(&sbi->s_dirtyclusters_counter);\nfailed_mount5:\n\text4_ext_release(sb);\n\text4_release_system_zone(sb);\nfailed_mount4a:\n\tdput(sb->s_root);\n\tsb->s_root = NULL;\nfailed_mount4:\n\text4_msg(sb, KERN_ERR, \"mount failed\");\n \tif (EXT4_SB(sb)->rsv_conversion_wq)\n \t\tdestroy_workqueue(EXT4_SB(sb)->rsv_conversion_wq);\n failed_mount_wq:\n \tif (sbi->s_journal) {\n \t\tjbd2_journal_destroy(sbi->s_journal);\n \t\tsbi->s_journal = NULL;\n\t}\nfailed_mount3a:\n\text4_es_unregister_shrinker(sbi);\nfailed_mount3:\n\tdel_timer_sync(&sbi->s_err_report);\n\tif (sbi->s_mmp_tsk)\n\t\tkthread_stop(sbi->s_mmp_tsk);\nfailed_mount2:\n\tfor (i = 0; i < db_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\n\tkvfree(sbi->s_group_desc);\nfailed_mount:\n\tif (sbi->s_chksum_driver)\n\t\tcrypto_free_shash(sbi->s_chksum_driver);\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\text4_blkdev_remove(sbi);\n\tbrelse(bh);\nout_fail:\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\n\tkfree(sbi);\nout_free_orig:\n\tkfree(orig_data);\n\treturn err ? err : ret;\n}\n", "target": 1, "idx": 183158}
{"func": "cib_shutdown(int nsig)\n{\n    struct qb_ipcs_stats srv_stats;\n    if (cib_shutdown_flag == FALSE) {\n        int disconnects = 0;\n        qb_ipcs_connection_t *c = NULL;\n\n        cib_shutdown_flag = TRUE;\n\n        c = qb_ipcs_connection_first_get(ipcs_rw);\n        while(c != NULL) {\n            qb_ipcs_connection_t *last = c;\n            c = qb_ipcs_connection_next_get(ipcs_rw, last);\n\n            crm_debug(\"Disconnecting r/w client %p...\", last);\n            qb_ipcs_disconnect(last);\n            qb_ipcs_connection_unref(last);\n            disconnects++;\n        }\n\n        c = qb_ipcs_connection_first_get(ipcs_ro);\n        while(c != NULL) {\n            qb_ipcs_connection_t *last = c;\n            c = qb_ipcs_connection_next_get(ipcs_ro, last);\n\n            crm_debug(\"Disconnecting r/o client %p...\", last);\n            qb_ipcs_disconnect(last);\n            qb_ipcs_connection_unref(last);\n            disconnects++;\n        }\n\n        c = qb_ipcs_connection_first_get(ipcs_shm);\n        while(c != NULL) {\n            qb_ipcs_connection_t *last = c;\n            c = qb_ipcs_connection_next_get(ipcs_shm, last);\n\n            crm_debug(\"Disconnecting non-blocking r/w client %p...\", last);\n            qb_ipcs_disconnect(last);\n            qb_ipcs_connection_unref(last);\n            disconnects++;\n        }\n\n        disconnects += g_hash_table_size(client_list);\n\n        crm_debug(\"Disconnecting %d remote clients\", g_hash_table_size(client_list));\n        g_hash_table_foreach(client_list, disconnect_remote_client, NULL);\n        crm_info(\"Disconnected %d clients\", disconnects);\n    }\n\n    qb_ipcs_stats_get(ipcs_rw, &srv_stats, QB_FALSE);\n    \n    if(g_hash_table_size(client_list) == 0) {\n        crm_info(\"All clients disconnected (%d)\", srv_stats.active_connections);\n        initiate_exit();\n        \n    } else {\n        crm_info(\"Waiting on %d clients to disconnect (%d)\", g_hash_table_size(client_list), srv_stats.active_connections);\n    }\n}\n", "target": 0, "idx": 33866}
{"func": "PassRefPtrWillBeRawPtr<Node> ContainerNode::replaceChild(PassRefPtrWillBeRawPtr<Node> newChild, PassRefPtrWillBeRawPtr<Node> oldChild, ExceptionState& exceptionState)\n{\n#if !ENABLE(OILPAN)\n    ASSERT(refCount() || parentOrShadowHostNode());\n#endif\n\n    RefPtrWillBeRawPtr<Node> protect(this);\n\n    if (oldChild == newChild) // Nothing to do.\n        return oldChild;\n\n    if (!oldChild) {\n        exceptionState.throwDOMException(NotFoundError, \"The node to be replaced is null.\");\n        return nullptr;\n    }\n\n    RefPtrWillBeRawPtr<Node> child = oldChild;\n\n    if (!checkAcceptChild(newChild.get(), child.get(), exceptionState)) {\n        if (exceptionState.hadException())\n            return nullptr;\n        return child;\n    }\n\n    if (child->parentNode() != this) {\n        exceptionState.throwDOMException(NotFoundError, \"The node to be replaced is not a child of this node.\");\n        return nullptr;\n    }\n\n    ChildListMutationScope mutation(*this);\n\n    RefPtrWillBeRawPtr<Node> next = child->nextSibling();\n\n    removeChild(child, exceptionState);\n    if (exceptionState.hadException())\n        return nullptr;\n\n    if (next && (next->previousSibling() == newChild || next == newChild)) // nothing to do\n        return child;\n\n    if (!checkAcceptChild(newChild.get(), child.get(), exceptionState)) {\n        if (exceptionState.hadException())\n            return nullptr;\n        return child;\n    }\n\n    NodeVector targets;\n    collectChildrenAndRemoveFromOldParent(*newChild, targets, exceptionState);\n    if (exceptionState.hadException())\n        return nullptr;\n\n    if (!checkAcceptChild(newChild.get(), child.get(), exceptionState)) {\n        if (exceptionState.hadException())\n            return nullptr;\n        return child;\n    }\n\n    InspectorInstrumentation::willInsertDOMNode(this);\n\n    for (const auto& targetNode : targets) {\n        ASSERT(targetNode);\n        Node& child = *targetNode;\n\n        if (next && next->parentNode() != this)\n            break;\n        if (child.parentNode())\n            break;\n\n        treeScope().adoptIfNeeded(child);\n\n        {\n            EventDispatchForbiddenScope assertNoEventDispatch;\n            if (next)\n                insertBeforeCommon(*next, child);\n            else\n                appendChildCommon(child);\n        }\n\n        updateTreeAfterInsertion(child);\n    }\n\n    dispatchSubtreeModifiedEvent();\n    return child;\n}\n", "target": 0, "idx": 135969}
{"func": "int ipmi_destroy_user(struct ipmi_user *user)\n {\n \t_ipmi_destroy_user(user);\n \n\tcleanup_srcu_struct(&user->release_barrier);\n \tkref_put(&user->refcount, free_user);\n \n \treturn 0;\n}\n", "target": 1, "idx": 182898}
{"func": "static int php_stream_temp_cast(php_stream *stream, int castas, void **ret TSRMLS_DC)\n{\n\tphp_stream_temp_data *ts = (php_stream_temp_data*)stream->abstract;\n\tphp_stream *file;\n\tsize_t memsize;\n\tchar *membuf;\n\toff_t pos;\n\n\tassert(ts != NULL);\n\n\tif (!ts->innerstream) {\n\t\treturn FAILURE;\n\t}\n\tif (php_stream_is(ts->innerstream, PHP_STREAM_IS_STDIO)) {\n\t\treturn php_stream_cast(ts->innerstream, castas, ret, 0);\n\t}\n\n\t/* we are still using a memory based backing. If they are if we can be\n\t * a FILE*, say yes because we can perform the conversion.\n\t * If they actually want to perform the conversion, we need to switch\n\t * the memory stream to a tmpfile stream */\n\n\tif (ret == NULL && castas == PHP_STREAM_AS_STDIO) {\n\t\treturn SUCCESS;\n\t}\n\n\t/* say \"no\" to other stream forms */\n\tif (ret == NULL) {\n\t\treturn FAILURE;\n\t}\n\n\t/* perform the conversion and then pass the request on to the innerstream */\n\tmembuf = php_stream_memory_get_buffer(ts->innerstream, &memsize);\n        file = php_stream_fopen_tmpfile();\n        php_stream_write(file, membuf, memsize);\n        pos = php_stream_tell(ts->innerstream);\n        php_stream_free_enclosed(ts->innerstream, PHP_STREAM_FREE_CLOSE);\n        ts->innerstream = file;\n        php_stream_encloses(stream, ts->innerstream);\n\tphp_stream_seek(ts->innerstream, pos, SEEK_SET);\n\n\treturn php_stream_cast(ts->innerstream, castas, ret, 1);\n}\n", "target": 1, "idx": 178650}
{"func": "void FrameLoader::clear(bool clearWindowProperties, bool clearScriptObjects, bool clearFrameView)\n{\n    m_frame->editor()->clear();\n\n    if (!m_needsClear)\n        return;\n    m_needsClear = false;\n    \n    if (!m_frame->document()->inPageCache()) {\n        m_frame->document()->cancelParsing();\n        m_frame->document()->stopActiveDOMObjects();\n        if (m_frame->document()->attached()) {\n            m_frame->document()->willRemove();\n            m_frame->document()->detach();\n            \n            m_frame->document()->removeFocusedNodeOfSubtree(m_frame->document());\n        }\n    }\n\n    if (clearWindowProperties) {\n        m_frame->clearDOMWindow();\n        m_frame->script()->clearWindowShell();\n    }\n\n    m_frame->selection()->clear();\n    m_frame->eventHandler()->clear();\n    if (clearFrameView && m_frame->view())\n        m_frame->view()->clear();\n\n    m_frame->setSelectionGranularity(CharacterGranularity);\n\n    m_frame->setDocument(0);\n    m_decoder = 0;\n\n    m_containsPlugIns = false;\n\n    if (clearScriptObjects)\n        m_frame->script()->clearScriptObjects();\n\n    m_frame->redirectScheduler()->clear();\n\n    m_checkTimer.stop();\n    m_shouldCallCheckCompleted = false;\n    m_shouldCallCheckLoadComplete = false;\n\n    m_receivedData = false;\n    m_isDisplayingInitialEmptyDocument = false;\n\n    if (!m_encodingWasChosenByUser)\n        m_encoding = String();\n}\n", "target": 0, "idx": 97369}
{"func": "void RenderFrameHostImpl::RegisterMojoInterfaces() {\n#if !defined(OS_ANDROID)\n  registry_->AddInterface(base::Bind(&InstalledAppProviderImplDefault::Create));\n#endif  // !defined(OS_ANDROID)\n\n  PermissionManager* permission_manager =\n      GetProcess()->GetBrowserContext()->GetPermissionManager();\n\n  if (delegate_) {\n    auto* geolocation_context = delegate_->GetGeolocationContext();\n    if (geolocation_context && permission_manager) {\n      geolocation_service_.reset(new GeolocationServiceImpl(\n          geolocation_context, permission_manager, this));\n      registry_->AddInterface(\n          base::Bind(&GeolocationServiceImpl::Bind,\n                     base::Unretained(geolocation_service_.get())));\n    }\n  }\n\n  registry_->AddInterface<device::mojom::WakeLock>(base::Bind(\n      &RenderFrameHostImpl::BindWakeLockRequest, base::Unretained(this)));\n\n#if defined(OS_ANDROID)\n  if (base::FeatureList::IsEnabled(features::kWebNfc)) {\n    registry_->AddInterface<device::mojom::NFC>(base::Bind(\n        &RenderFrameHostImpl::BindNFCRequest, base::Unretained(this)));\n  }\n#endif\n\n  if (!permission_service_context_)\n    permission_service_context_.reset(new PermissionServiceContext(this));\n\n  registry_->AddInterface(\n      base::Bind(&PermissionServiceContext::CreateService,\n                 base::Unretained(permission_service_context_.get())));\n\n  registry_->AddInterface(\n      base::Bind(&RenderFrameHostImpl::BindPresentationServiceRequest,\n                 base::Unretained(this)));\n\n  registry_->AddInterface(\n      base::Bind(&MediaSessionServiceImpl::Create, base::Unretained(this)));\n\n#if defined(OS_ANDROID)\n  registry_->AddInterface<media::mojom::Renderer>(\n      base::Bind(&content::CreateMediaPlayerRenderer, GetProcess()->GetID(),\n                 GetRoutingID(), delegate_));\n#endif  // defined(OS_ANDROID)\n\n  registry_->AddInterface(base::Bind(\n      base::IgnoreResult(&RenderFrameHostImpl::CreateWebBluetoothService),\n      base::Unretained(this)));\n\n  registry_->AddInterface(base::BindRepeating(\n      &RenderFrameHostImpl::CreateUsbDeviceManager, base::Unretained(this)));\n\n  registry_->AddInterface(base::BindRepeating(\n      &RenderFrameHostImpl::CreateUsbChooserService, base::Unretained(this)));\n\n  registry_->AddInterface<media::mojom::InterfaceFactory>(\n      base::Bind(&RenderFrameHostImpl::BindMediaInterfaceFactoryRequest,\n                 base::Unretained(this)));\n\n  registry_->AddInterface(base::Bind(&WebSocketManager::CreateWebSocket,\n                                     process_->GetID(), routing_id_));\n\n  registry_->AddInterface(base::Bind(&SharedWorkerConnectorImpl::Create,\n                                     process_->GetID(), routing_id_));\n\n  registry_->AddInterface<device::mojom::VRService>(base::Bind(\n      &WebvrServiceProvider::BindWebvrService, base::Unretained(this)));\n\n  if (RenderFrameAudioInputStreamFactory::UseMojoFactories()) {\n    registry_->AddInterface(\n        base::BindRepeating(&RenderFrameHostImpl::CreateAudioInputStreamFactory,\n                            base::Unretained(this)));\n  }\n\n  if (RendererAudioOutputStreamFactoryContextImpl::UseMojoFactories()) {\n    registry_->AddInterface(base::BindRepeating(\n        &RenderFrameHostImpl::CreateAudioOutputStreamFactory,\n        base::Unretained(this)));\n  }\n\n  if (resource_coordinator::IsResourceCoordinatorEnabled()) {\n    registry_->AddInterface(\n        base::Bind(&CreateFrameResourceCoordinator, base::Unretained(this)));\n  }\n\n#if BUILDFLAG(ENABLE_WEBRTC)\n  if (BrowserMainLoop::GetInstance()) {\n    MediaStreamManager* media_stream_manager =\n        BrowserMainLoop::GetInstance()->media_stream_manager();\n    registry_->AddInterface(\n        base::Bind(&MediaDevicesDispatcherHost::Create, GetProcess()->GetID(),\n                   GetRoutingID(),\n                   base::Unretained(media_stream_manager)),\n        BrowserThread::GetTaskRunnerForThread(BrowserThread::IO));\n  }\n#endif\n\n#if BUILDFLAG(ENABLE_MEDIA_REMOTING)\n  registry_->AddInterface(base::Bind(&RemoterFactoryImpl::Bind,\n                                     GetProcess()->GetID(), GetRoutingID()));\n#endif  // BUILDFLAG(ENABLE_MEDIA_REMOTING)\n\n  registry_->AddInterface(base::Bind(\n      &KeyboardLockServiceImpl::CreateMojoService, base::Unretained(this)));\n\n  registry_->AddInterface(base::Bind(&ImageCaptureImpl::Create));\n\n#if !defined(OS_ANDROID)\n  if (base::FeatureList::IsEnabled(features::kWebAuth)) {\n    registry_->AddInterface(\n        base::Bind(&RenderFrameHostImpl::BindAuthenticatorRequest,\n                   base::Unretained(this)));\n  }\n#endif  // !defined(OS_ANDROID)\n\n  if (permission_manager) {\n    sensor_provider_proxy_.reset(\n        new SensorProviderProxyImpl(permission_manager, this));\n    registry_->AddInterface(\n        base::Bind(&SensorProviderProxyImpl::Bind,\n                   base::Unretained(sensor_provider_proxy_.get())));\n  }\n\n  registry_->AddInterface(base::BindRepeating(\n      &media::MediaMetricsProvider::Create,\n      GetSiteInstance()->GetBrowserContext()->IsOffTheRecord()\n          ? nullptr\n          : GetSiteInstance()\n                ->GetBrowserContext()\n                ->GetVideoDecodePerfHistory()));\n\n  if (base::CommandLine::ForCurrentProcess()->HasSwitch(\n          cc::switches::kEnableGpuBenchmarking)) {\n    registry_->AddInterface(\n        base::Bind(&InputInjectorImpl::Create, weak_ptr_factory_.GetWeakPtr()));\n  }\n\n  registry_->AddInterface(\n      base::BindRepeating(GetRestrictedCookieManager, base::Unretained(this)));\n\n  registry_->AddInterface(base::BindRepeating(\n      &QuotaDispatcherHost::CreateForFrame, GetProcess(), routing_id_));\n}\n", "target": 0, "idx": 160476}
{"func": "void page_put_link(void *arg)\n{\n\tput_page(arg);\n}\n", "target": 0, "idx": 51037}
{"func": "base::FilePath ChromeContentBrowserClient::GetShaderDiskCacheDirectory() {\n  base::FilePath user_data_dir;\n  base::PathService::Get(chrome::DIR_USER_DATA, &user_data_dir);\n  DCHECK(!user_data_dir.empty());\n  return user_data_dir.Append(FILE_PATH_LITERAL(\"ShaderCache\"));\n}\n", "target": 0, "idx": 155368}
{"func": "static int transport_read_nonblocking(rdpTransport* transport)\n{\n\tint status;\n\n\tstatus = transport_read(transport, transport->ReceiveBuffer);\n\n\tif (status <= 0)\n\t\treturn status;\n\n\tStream_Seek(transport->ReceiveBuffer, status);\n\n\treturn status;\n}\n", "target": 0, "idx": 58565}
{"func": "ftp_readline(ftpbuf_t *ftp)\n{\n\tlong\t\tsize, rcvd;\n\tchar\t\t*data, *eol;\n\n\t/* shift the extra to the front */\n\tsize = FTP_BUFSIZE;\n\trcvd = 0;\n\tif (ftp->extra) {\n\t\tmemmove(ftp->inbuf, ftp->extra, ftp->extralen);\n\t\trcvd = ftp->extralen;\n\t}\n\n\tdata = ftp->inbuf;\n\n\tdo {\n\t\tsize -= rcvd;\n\t\tfor (eol = data; rcvd; rcvd--, eol++) {\n\t\t\tif (*eol == '\\r') {\n\t\t\t\t*eol = 0;\n\t\t\t\tftp->extra = eol + 1;\n\t\t\t\tif (rcvd > 1 && *(eol + 1) == '\\n') {\n\t\t\t\t\tftp->extra++;\n\t\t\t\t\trcvd--;\n\t\t\t\t}\n\t\t\t\tif ((ftp->extralen = --rcvd) == 0) {\n\t\t\t\t\tftp->extra = NULL;\n\t\t\t\t}\n\t\t\t\treturn 1;\n\t\t\t} else if (*eol == '\\n') {\n\t\t\t\t*eol = 0;\n\t\t\t\tftp->extra = eol + 1;\n\t\t\t\tif ((ftp->extralen = --rcvd) == 0) {\n\t\t\t\t\tftp->extra = NULL;\n\t\t\t\t}\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\tdata = eol;\n\t\tif ((rcvd = my_recv(ftp, ftp->fd, data, size)) < 1) {\n\t\t\treturn 0;\n\t\t}\n\t} while (size);\n\n\treturn 0;\n}\n", "target": 0, "idx": 14806}
{"func": "parse_netscreen_hex_dump(FILE_T fh, int pkt_len, const char *cap_int,\n    const char *cap_dst, struct wtap_pkthdr *phdr, Buffer* buf,\n    int *err, gchar **err_info)\n{\n\tguint8\t*pd;\n\tgchar\tline[NETSCREEN_LINE_LENGTH];\n\tgchar\t*p;\n\tint\tn, i = 0, offset = 0;\n\tgchar\tdststr[13];\n \t/* Make sure we have enough room for the packet */\n\tws_buffer_assure_space(buf, NETSCREEN_MAX_PACKET_LEN);\n \tpd = ws_buffer_start_ptr(buf);\n \n \twhile(1) {\n\n\t\t/* The last packet is not delimited by an empty line, but by EOF\n\t\t * So accept EOF as a valid delimiter too\n\t\t */\n\t\tif (file_gets(line, NETSCREEN_LINE_LENGTH, fh) == NULL) {\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Skip blanks.\n\t\t * The number of blanks is not fixed - for wireless\n\t\t * interfaces, there may be 14 extra spaces before\n\t\t * the hex data.\n\t\t */\n\t\tfor (p = &line[0]; g_ascii_isspace(*p); p++)\n\t\t\t;\n\t\t/* packets are delimited with empty lines */\n\t\tif (*p == '\\0') {\n\t\t\tbreak;\n\t\t}\n\n\t\tn = parse_single_hex_dump_line(p, pd, offset);\n\n\t\t/* the smallest packet has a length of 6 bytes, if\n\t\t * the first hex-data is less then check whether\n\t\t * it is a info-line and act accordingly\n\t\t */\n\t\tif (offset == 0 && n < 6) {\n\t\t\tif (info_line(line)) {\n\t\t\t\tif (++i <= NETSCREEN_MAX_INFOLINES) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t\t*err_info = g_strdup(\"netscreen: cannot parse hex-data\");\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\n \t\t/* If there is no more data and the line was not empty,\n \t\t * then there must be an error in the file\n \t\t */\n\t\tif(n == -1) {\n \t\t\t*err = WTAP_ERR_BAD_FILE;\n \t\t\t*err_info = g_strdup(\"netscreen: cannot parse hex-data\");\n \t\t\treturn FALSE;\n\t\t}\n\n\t\t/* Adjust the offset to the data that was just added to the buffer */\n\t\toffset += n;\n\n \t\t/* If there was more hex-data than was announced in the len=x\n \t\t * header, then then there must be an error in the file\n \t\t */\n\t\tif(offset > pkt_len) {\n \t\t\t*err = WTAP_ERR_BAD_FILE;\n \t\t\t*err_info = g_strdup(\"netscreen: too much hex-data\");\n \t\t\treturn FALSE;\n\t\t}\n\t}\n\n\t/*\n\t * Determine the encapsulation type, based on the\n\t * first 4 characters of the interface name\n\t *\n\t * XXX\tconvert this to a 'case' structure when adding more\n\t *\t(non-ethernet) interfacetypes\n\t */\n\tif (strncmp(cap_int, \"adsl\", 4) == 0) {\n\t\t/* The ADSL interface can be bridged with or without\n\t\t * PPP encapsulation. Check whether the first six bytes\n\t\t * of the hex data are the same as the destination mac\n\t\t * address in the header. If they are, assume ethernet\n\t\t * LinkLayer or else PPP\n\t\t */\n\t\tg_snprintf(dststr, 13, \"%02x%02x%02x%02x%02x%02x\",\n\t\t   pd[0], pd[1], pd[2], pd[3], pd[4], pd[5]);\n\t\tif (strncmp(dststr, cap_dst, 12) == 0)\n\t\t\tphdr->pkt_encap = WTAP_ENCAP_ETHERNET;\n\t\telse\n\t\t\tphdr->pkt_encap = WTAP_ENCAP_PPP;\n\t\t}\n\telse if (strncmp(cap_int, \"seri\", 4) == 0)\n\t\tphdr->pkt_encap = WTAP_ENCAP_PPP;\n\telse\n\t\tphdr->pkt_encap = WTAP_ENCAP_ETHERNET;\n\n\tphdr->caplen = offset;\n\n\treturn TRUE;\n}\n", "target": 1, "idx": 180320}
{"func": "static void bs_open_read (Bitstream *bs, void *buffer_start, void *buffer_end)\n{\n    bs->error = bs->sr = bs->bc = 0;\n    bs->ptr = (bs->buf = buffer_start) - 1;\n    bs->end = buffer_end;\n    bs->wrap = bs_read;\n}\n", "target": 0, "idx": 70885}
{"func": "vips_malloc( VipsObject *object, size_t size )\n {\n \tvoid *buf;\n \n\tbuf = g_malloc( size );\n \n         if( object ) {\n \t\tg_signal_connect( object, \"postclose\", \n\t\t\tG_CALLBACK( vips_malloc_cb ), buf );\n\t\tobject->local_memory += size;\n\t}\n\n\treturn( buf );\n}\n", "target": 1, "idx": 182911}
{"func": "main(int argc, char **argv)\n{\n\tint ch, fflag, tflag, status, n;\n\tchar **newargv;\n\tconst char *errstr;\n\textern char *optarg;\n\textern int optind;\n\n\t/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */\n\tsanitise_stdfd();\n\n\tmsetlocale();\n\n\t/* Copy argv, because we modify it */\n\tnewargv = xcalloc(MAXIMUM(argc + 1, 1), sizeof(*newargv));\n\tfor (n = 0; n < argc; n++)\n\t\tnewargv[n] = xstrdup(argv[n]);\n\targv = newargv;\n\n\t__progname = ssh_get_progname(argv[0]);\n\n\tmemset(&args, '\\0', sizeof(args));\n\tmemset(&remote_remote_args, '\\0', sizeof(remote_remote_args));\n\targs.list = remote_remote_args.list = NULL;\n\taddargs(&args, \"%s\", ssh_program);\n\taddargs(&args, \"-x\");\n\taddargs(&args, \"-oForwardAgent=no\");\n\taddargs(&args, \"-oPermitLocalCommand=no\");\n\taddargs(&args, \"-oClearAllForwardings=yes\");\n\taddargs(&args, \"-oRemoteCommand=none\");\n\taddargs(&args, \"-oRequestTTY=no\");\n\n\tfflag = tflag = 0;\n\twhile ((ch = getopt(argc, argv, \"dfl:prtvBCc:i:P:q12346S:o:F:\")) != -1)\n\t\tswitch (ch) {\n\t\t/* User-visible flags. */\n\t\tcase '1':\n\t\t\tfatal(\"SSH protocol v.1 is no longer supported\");\n\t\t\tbreak;\n\t\tcase '2':\n\t\t\t/* Ignored */\n\t\t\tbreak;\n\t\tcase '4':\n\t\tcase '6':\n\t\tcase 'C':\n\t\t\taddargs(&args, \"-%c\", ch);\n\t\t\taddargs(&remote_remote_args, \"-%c\", ch);\n\t\t\tbreak;\n\t\tcase '3':\n\t\t\tthroughlocal = 1;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\tcase 'c':\n\t\tcase 'i':\n\t\tcase 'F':\n\t\t\taddargs(&remote_remote_args, \"-%c\", ch);\n\t\t\taddargs(&remote_remote_args, \"%s\", optarg);\n\t\t\taddargs(&args, \"-%c\", ch);\n\t\t\taddargs(&args, \"%s\", optarg);\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tsshport = a2port(optarg);\n\t\t\tif (sshport <= 0)\n\t\t\t\tfatal(\"bad port \\\"%s\\\"\\n\", optarg);\n\t\t\tbreak;\n\t\tcase 'B':\n\t\t\taddargs(&remote_remote_args, \"-oBatchmode=yes\");\n\t\t\taddargs(&args, \"-oBatchmode=yes\");\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tlimit_kbps = strtonum(optarg, 1, 100 * 1024 * 1024,\n\t\t\t    &errstr);\n\t\t\tif (errstr != NULL)\n\t\t\t\tusage();\n\t\t\tlimit_kbps *= 1024; /* kbps */\n\t\t\tbandwidth_limit_init(&bwlimit, limit_kbps, COPY_BUFLEN);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tpflag = 1;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tiamrecursive = 1;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tssh_program = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\taddargs(&args, \"-v\");\n\t\t\taddargs(&remote_remote_args, \"-v\");\n\t\t\tverbose_mode = 1;\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\taddargs(&args, \"-q\");\n\t\t\taddargs(&remote_remote_args, \"-q\");\n\t\t\tshowprogress = 0;\n\t\t\tbreak;\n\n\t\t/* Server options. */\n\t\tcase 'd':\n\t\t\ttargetshouldbedirectory = 1;\n\t\t\tbreak;\n\t\tcase 'f':\t/* \"from\" */\n\t\t\tiamremote = 1;\n\t\t\tfflag = 1;\n\t\t\tbreak;\n\t\tcase 't':\t/* \"to\" */\n\t\t\tiamremote = 1;\n\t\t\ttflag = 1;\n#ifdef HAVE_CYGWIN\n\t\t\tsetmode(0, O_BINARY);\n#endif\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t}\n\targc -= optind;\n\targv += optind;\n\n\tif ((pwd = getpwuid(userid = getuid())) == NULL)\n\t\tfatal(\"unknown user %u\", (u_int) userid);\n\n\tif (!isatty(STDOUT_FILENO))\n\t\tshowprogress = 0;\n\n\tif (pflag) {\n\t\t/* Cannot pledge: -p allows setuid/setgid files... */\n\t} else {\n\t\tif (pledge(\"stdio rpath wpath cpath fattr tty proc exec\",\n\t\t    NULL) == -1) {\n\t\t\tperror(\"pledge\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tremin = STDIN_FILENO;\n\tremout = STDOUT_FILENO;\n\n\tif (fflag) {\n\t\t/* Follow \"protocol\", send data. */\n\t\t(void) response();\n\t\tsource(argc, argv);\n\t\texit(errs != 0);\n\t}\n\tif (tflag) {\n\t\t/* Receive data. */\n\t\tsink(argc, argv);\n\t\texit(errs != 0);\n\t}\n\tif (argc < 2)\n\t\tusage();\n\tif (argc > 2)\n\t\ttargetshouldbedirectory = 1;\n\n\tremin = remout = -1;\n\tdo_cmd_pid = -1;\n\t/* Command to be executed on remote system using \"ssh\". */\n\t(void) snprintf(cmd, sizeof cmd, \"scp%s%s%s%s\",\n\t    verbose_mode ? \" -v\" : \"\",\n\t    iamrecursive ? \" -r\" : \"\", pflag ? \" -p\" : \"\",\n\t    targetshouldbedirectory ? \" -d\" : \"\");\n\n\t(void) signal(SIGPIPE, lostconn);\n\n\tif (colon(argv[argc - 1]))\t/* Dest is remote host. */\n\t\ttoremote(argc, argv);\n\telse {\n\t\tif (targetshouldbedirectory)\n\t\t\tverifydir(argv[argc - 1]);\n\t\ttolocal(argc, argv);\t/* Dest is local host. */\n\t}\n\t/*\n\t * Finally check the exit status of the ssh process, if one was forked\n\t * and no error has occurred yet\n\t */\n\tif (do_cmd_pid != -1 && errs == 0) {\n\t\tif (remin != -1)\n\t\t    (void) close(remin);\n\t\tif (remout != -1)\n\t\t    (void) close(remout);\n\t\tif (waitpid(do_cmd_pid, &status, 0) == -1)\n\t\t\terrs = 1;\n\t\telse {\n\t\t\tif (!WIFEXITED(status) || WEXITSTATUS(status) != 0)\n\t\t\t\terrs = 1;\n\t\t}\n\t}\n\texit(errs != 0);\n}\n", "target": 0, "idx": 92903}
{"func": " void SynchronousCompositorImpl::PostInvalidate() {\n   DCHECK(CalledOnValidThread());\n   DCHECK(compositor_client_);\n  compositor_client_->PostInvalidate();\n }\n", "target": 1, "idx": 185591}
{"func": "int gdTransformAffineGetImage(gdImagePtr *dst,\n\t\t  const gdImagePtr src,\n\t\t  gdRectPtr src_area,\n\t\t  const double affine[6])\n{\n\tint res;\n\tdouble m[6];\n\tgdRect bbox;\n\tgdRect area_full;\n\n\tif (src_area == NULL) {\n\t\tarea_full.x = 0;\n\t\tarea_full.y = 0;\n\t\tarea_full.width  = gdImageSX(src);\n\t\tarea_full.height = gdImageSY(src);\n\t\tsrc_area = &area_full;\n\t}\n\n\tgdTransformAffineBoundingBox(src_area, affine, &bbox);\n\n\t*dst = gdImageCreateTrueColor(bbox.width, bbox.height);\n\tif (*dst == NULL) {\n\t\treturn GD_FALSE;\n\t}\n\t(*dst)->saveAlphaFlag = 1;\n\n \tif (!src->trueColor) {\n \t\tgdImagePaletteToTrueColor(src);\n \t}\n \t/* Translate to dst origin (0,0) */\n \tgdAffineTranslate(m, -bbox.x, -bbox.y);\n \tgdAffineConcat(m, affine, m);\n\n\tgdImageAlphaBlending(*dst, 0);\n\n\tres = gdTransformAffineCopy(*dst,\n\t\t  0,0,\n\t\t  src,\n\t\t  src_area,\n\t\t  m);\n\n\tif (res != GD_TRUE) {\n\t\tgdImageDestroy(*dst);\n\t\tdst = NULL;\n\t\treturn GD_FALSE;\n\t} else {\n\t\treturn GD_TRUE;\n\t}\n}\n", "target": 1, "idx": 183179}
{"func": "gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\t   gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n\t\t   int iov_count)\n{\n    OM_uint32 status;\n    gss_union_ctx_id_t ctx;\n    gss_mechanism mech;\n\n    status = val_unwrap_iov_args(minor_status, context_handle, NULL,\n\t\t\t\t qop_state, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\treturn status;\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;\n    if (mech->gss_verify_mic_iov == NULL)\n\treturn GSS_S_UNAVAILABLE;\n    status = mech->gss_verify_mic_iov(minor_status, ctx->internal_ctx_id,\n\t\t\t\t      qop_state, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\tmap_error(minor_status, mech);\n    return status;\n}\n", "target": 1, "idx": 181198}
{"func": "int Reverb_command(effect_handle_t  self,\n uint32_t            cmdCode,\n uint32_t            cmdSize,\n void *pCmdData,\n uint32_t *replySize,\n void *pReplyData){\n    android::ReverbContext * pContext = (android::ReverbContext *) self;\n int retsize;\n    LVREV_ControlParams_st    ActiveParams; /* Current control Parameters */\n    LVREV_ReturnStatus_en     LvmStatus=LVREV_SUCCESS; /* Function call status */\n\n\n if (pContext == NULL){\n        ALOGV(\"\\tLVM_ERROR : Reverb_command ERROR pContext == NULL\");\n return -EINVAL;\n }\n\n\n switch (cmdCode){\n case EFFECT_CMD_INIT:\n\n if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)){\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_INIT: ERROR\");\n return -EINVAL;\n }\n *(int *) pReplyData = 0;\n break;\n\n case EFFECT_CMD_SET_CONFIG:\n if (pCmdData == NULL || cmdSize != sizeof(effect_config_t) ||\n                    pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_SET_CONFIG: ERROR\");\n return -EINVAL;\n }\n *(int *) pReplyData = android::Reverb_setConfig(pContext,\n (effect_config_t *) pCmdData);\n break;\n\n case EFFECT_CMD_GET_CONFIG:\n if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(effect_config_t)) {\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_GET_CONFIG: ERROR\");\n return -EINVAL;\n }\n\n            android::Reverb_getConfig(pContext, (effect_config_t *)pReplyData);\n break;\n\n case EFFECT_CMD_RESET:\n Reverb_setConfig(pContext, &pContext->config);\n break;\n\n case EFFECT_CMD_GET_PARAM:{\n\n             effect_param_t *p = (effect_param_t *)pCmdData;\n             if (pCmdData == NULL || cmdSize < sizeof(effect_param_t) ||\n                     cmdSize < (sizeof(effect_param_t) + p->psize) ||\n                     pReplyData == NULL || replySize == NULL ||\n *replySize < (sizeof(effect_param_t) + p->psize)) {\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_GET_PARAM: ERROR\");\n return -EINVAL;\n }\n\n            memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + p->psize);\n\n            p = (effect_param_t *)pReplyData;\n\n int voffset = ((p->psize - 1) / sizeof(int32_t) + 1) * sizeof(int32_t);\n\n            p->status = android::Reverb_getParameter(pContext,\n (void *)p->data,\n (size_t *)&p->vsize,\n                                                          p->data + voffset);\n\n *replySize = sizeof(effect_param_t) + voffset + p->vsize;\n\n\n } break;\n case EFFECT_CMD_SET_PARAM:{\n\n\n if (pCmdData == NULL || (cmdSize < (sizeof(effect_param_t) + sizeof(int32_t))) ||\n                    pReplyData == NULL ||  replySize == NULL || *replySize != sizeof(int32_t)) {\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_SET_PARAM: ERROR\");\n return -EINVAL;\n }\n\n effect_param_t *p = (effect_param_t *) pCmdData;\n\n if (p->psize != sizeof(int32_t)){\n                ALOGV(\"\\t4LVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_SET_PARAM: ERROR, psize is not sizeof(int32_t)\");\n return -EINVAL;\n }\n\n\n *(int *)pReplyData = android::Reverb_setParameter(pContext,\n (void *)p->data,\n                                                              p->data + p->psize);\n } break;\n\n case EFFECT_CMD_ENABLE:\n\n if (pReplyData == NULL || *replySize != sizeof(int)){\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_ENABLE: ERROR\");\n return -EINVAL;\n }\n if(pContext->bEnabled == LVM_TRUE){\n                 ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_ENABLE: ERROR-Effect is already enabled\");\n return -EINVAL;\n }\n *(int *)pReplyData = 0;\n            pContext->bEnabled = LVM_TRUE;\n /* Get the current settings */\n LvmStatus = LVREV_GetControlParameters(pContext->hInstance, &ActiveParams);\n            LVM_ERROR_CHECK(LvmStatus, \"LVREV_GetControlParameters\", \"EFFECT_CMD_ENABLE\")\n            pContext->SamplesToExitCount =\n (ActiveParams.T60 * pContext->config.inputCfg.samplingRate)/1000;\n            pContext->volumeMode = android::REVERB_VOLUME_FLAT;\n break;\n case EFFECT_CMD_DISABLE:\n\n if (pReplyData == NULL || *replySize != sizeof(int)){\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_DISABLE: ERROR\");\n return -EINVAL;\n }\n if(pContext->bEnabled == LVM_FALSE){\n                 ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_DISABLE: ERROR-Effect is not yet enabled\");\n return -EINVAL;\n }\n *(int *)pReplyData = 0;\n            pContext->bEnabled = LVM_FALSE;\n break;\n\n case EFFECT_CMD_SET_VOLUME:\n if (pCmdData == NULL ||\n                cmdSize != 2 * sizeof(uint32_t)) {\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_SET_VOLUME: ERROR\");\n return -EINVAL;\n }\n\n\n if (pReplyData != NULL) { // we have volume control\n                pContext->leftVolume = (LVM_INT16)((*(uint32_t *)pCmdData + (1 << 11)) >> 12);\n                pContext->rightVolume = (LVM_INT16)((*((uint32_t *)pCmdData + 1) + (1 << 11)) >> 12);\n *(uint32_t *)pReplyData = (1 << 24);\n *((uint32_t *)pReplyData + 1) = (1 << 24);\n if (pContext->volumeMode == android::REVERB_VOLUME_OFF) {\n                    pContext->volumeMode = android::REVERB_VOLUME_FLAT;\n }\n } else { // we don't have volume control\n                pContext->leftVolume = REVERB_UNIT_VOLUME;\n                pContext->rightVolume = REVERB_UNIT_VOLUME;\n                pContext->volumeMode = android::REVERB_VOLUME_OFF;\n }\n            ALOGV(\"EFFECT_CMD_SET_VOLUME left %d, right %d mode %d\",\n                    pContext->leftVolume, pContext->rightVolume,  pContext->volumeMode);\n break;\n\n case EFFECT_CMD_SET_DEVICE:\n case EFFECT_CMD_SET_AUDIO_MODE:\n break;\n\n default:\n            ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"DEFAULT start %d ERROR\",cmdCode);\n return -EINVAL;\n }\n\n return 0;\n} /* end Reverb_command */\n", "target": 1, "idx": 187957}
{"func": "void PrintPreviewMessageHandler::OnInvalidPrinterSettings(int document_cookie) {\n  StopWorker(document_cookie);\n  PrintPreviewUI* print_preview_ui = GetPrintPreviewUI();\n  if (!print_preview_ui)\n    return;\n  print_preview_ui->OnInvalidPrinterSettings();\n}\n", "target": 0, "idx": 137691}
{"func": "static ssize_t handle_readlink(FsContext *fs_ctx, V9fsPath *fs_path,\n                               char *buf, size_t bufsz)\n{\n    int fd, ret;\n    struct handle_data *data = (struct handle_data *)fs_ctx->private;\n\n    fd = open_by_handle(data->mountfd, fs_path->data, O_PATH);\n    if (fd < 0) {\n        return fd;\n    }\n    ret = readlinkat(fd, \"\", buf, bufsz);\n    close(fd);\n    return ret;\n}\n", "target": 0, "idx": 7688}
{"func": " static void shm_destroy(struct ipc_namespace *ns, struct shmid_kernel *shp)\n {\n \tns->shm_tot -= (shp->shm_segsz + PAGE_SIZE - 1) >> PAGE_SHIFT;\n \tshm_rmid(ns, shp);\n \tshm_unlock(shp);\n\tif (!is_file_hugepages(shp->shm_file))\n\t\tshmem_lock(shp->shm_file, 0, shp->mlock_user);\n \telse if (shp->mlock_user)\n\t\tuser_shm_unlock(file_inode(shp->shm_file)->i_size,\n\t\t\t\t\t\tshp->mlock_user);\n\tfput (shp->shm_file);\n \tipc_rcu_putref(shp, shm_rcu_free);\n }\n", "target": 1, "idx": 179084}
{"func": "__imlib_MergeUpdate(ImlibUpdate * u, int w, int h, int hgapmax)\n{\n   ImlibUpdate        *nu = NULL, *uu;\n   struct _tile       *t;\n   int                 tw, th, x, y, i;\n   int                *gaps = NULL;\n\n   /* if theres no rects to process.. return NULL */\n   if (!u)\n      return NULL;\n   tw = w >> TB;\n   if (w & TM)\n      tw++;\n   th = h >> TB;\n   if (h & TM)\n      th++;\n   t = malloc(tw * th * sizeof(struct _tile));\n   /* fill in tiles to be all not used */\n   for (i = 0, y = 0; y < th; y++)\n     {\n        for (x = 0; x < tw; x++)\n           t[i++].used = T_UNUSED;\n     }\n   /* fill in all tiles */\n   for (uu = u; uu; uu = uu->next)\n     {\n        CLIP(uu->x, uu->y, uu->w, uu->h, 0, 0, w, h);\n        for (y = uu->y >> TB; y <= ((uu->y + uu->h - 1) >> TB); y++)\n          {\n             for (x = uu->x >> TB; x <= ((uu->x + uu->w - 1) >> TB); x++)\n                T(x, y).used = T_USED;\n          }\n     }\n   /* scan each line - if > hgapmax gaps between tiles, then fill smallest */\n   gaps = malloc(tw * sizeof(int));\n   for (y = 0; y < th; y++)\n     {\n        int                 hgaps = 0, start = -1, min;\n        char                have = 1, gap = 0;\n\n        for (x = 0; x < tw; x++)\n           gaps[x] = 0;\n        for (x = 0; x < tw; x++)\n          {\n             if ((have) && (T(x, y).used == T_UNUSED))\n               {\n                  start = x;\n                  gap = 1;\n                  have = 0;\n               }\n             else if ((!have) && (gap) && (T(x, y).used & T_USED))\n               {\n                  gap = 0;\n                  hgaps++;\n                  have = 1;\n                  gaps[start] = x - start;\n               }\n             else if (T(x, y).used & T_USED)\n                have = 1;\n          }\n        while (hgaps > hgapmax)\n          {\n             start = -1;\n             min = tw;\n\n             for (x = 0; x < tw; x++)\n               {\n                  if ((gaps[x] > 0) && (gaps[x] < min))\n                    {\n                       start = x;\n                       min = gaps[x];\n                    }\n               }\n             if (start >= 0)\n               {\n                  gaps[start] = 0;\n                  for (x = start;\n                       T(x, y).used == T_UNUSED; T(x++, y).used = T_USED);\n                  hgaps--;\n               }\n          }\n     }\n   free(gaps);\n   /* coalesce tiles into larger blocks and make new rect list */\n   for (y = 0; y < th; y++)\n     {\n        for (x = 0; x < tw; x++)\n          {\n             if (T(x, y).used & T_USED)\n               {\n                   int                 xx, yy, ww, hh, ok, xww;\n \n                   for (xx = x + 1, ww = 1;\n                       (T(xx, y).used & T_USED) && (xx < tw); xx++, ww++);\n                   xww = x + ww;\n                   for (yy = y + 1, hh = 1, ok = 1;\n                        (yy < th) && (ok); yy++, hh++)\n                    {\n                       for (xx = x; xx < xww; xx++)\n                         {\n                            if (!(T(xx, yy).used & T_USED))\n                              {\n                                 ok = 0;\n                                 hh--;\n                                 break;\n                              }\n                         }\n                    }\n                  for (yy = y; yy < (y + hh); yy++)\n                    {\n                       for (xx = x; xx < xww; xx++)\n                          T(xx, yy).used = T_UNUSED;\n                    }\n                  nu = __imlib_AddUpdate(nu, (x << TB), (y << TB),\n                                         (ww << TB), (hh << TB));\n               }\n          }\n     }\n   free(t);\n   __imlib_FreeUpdates(u);\n   return nu;\n}\n", "target": 1, "idx": 178252}
{"func": "bool xmp_init()\n{\n     RESET_ERROR;\n     try {\n         bool result = SXMPFiles::Initialize(kXMPFiles_IgnoreLocalText);\n         SXMPMeta::SetDefaultErrorCallback(&_xmp_error_callback, nullptr, 1);\n         return result;\n        SXMPMeta::SetDefaultErrorCallback(&_xmp_error_callback, nullptr, 1);\n        return result;\n    }\n    catch (const XMP_Error &e) {\n        set_error(e);\n    }\n    return false;\n}\n", "target": 1, "idx": 178540}
{"func": " PP_Bool LaunchSelLdr(PP_Instance instance,\n                     const char* alleged_url,\n                     int socket_count,\n                      void* imc_handles) {\n   std::vector<nacl::FileDescriptor> sockets;\n   IPC::Sender* sender = content::RenderThread::Get();\n   if (sender == NULL)\n     sender = g_background_thread_sender.Pointer()->get();\n \n  IPC::ChannelHandle channel_handle;\n   if (!sender->Send(new ChromeViewHostMsg_LaunchNaCl(\n          GURL(alleged_url), socket_count, &sockets,\n          &channel_handle))) {\n     return PP_FALSE;\n  }\n  bool invalid_handle = channel_handle.name.empty();\n#if defined(OS_POSIX)\n  if (!invalid_handle)\n    invalid_handle = (channel_handle.socket.fd == -1);\n#endif\n  if (!invalid_handle)\n    g_channel_handle_map.Get()[instance] = channel_handle;\n \n   CHECK(static_cast<int>(sockets.size()) == socket_count);\n   for (int i = 0; i < socket_count; i++) {\n    static_cast<nacl::Handle*>(imc_handles)[i] =\n        nacl::ToNativeHandle(sockets[i]);\n  }\n\n   return PP_TRUE;\n }\n", "target": 1, "idx": 184310}
{"func": "static int ipgre_close(struct net_device *dev)\n{\n\tstruct ip_tunnel *t = netdev_priv(dev);\n\n\tif (ipv4_is_multicast(t->parms.iph.daddr) && t->mlink) {\n\t\tstruct in_device *in_dev;\n\t\tin_dev = inetdev_by_index(dev_net(dev), t->mlink);\n\t\tif (in_dev) {\n\t\t\tip_mc_dec_group(in_dev, t->parms.iph.daddr);\n\t\t\tin_dev_put(in_dev);\n\t\t}\n\t}\n\treturn 0;\n}\n", "target": 0, "idx": 27479}
{"func": "void svc_rdma_xdr_encode_reply_array(struct rpcrdma_write_array *ary,\n\t\t\t\t int chunks)\n{\n\tary->wc_discrim = xdr_one;\n\tary->wc_nchunks = cpu_to_be32(chunks);\n}\n", "target": 1, "idx": 181333}
{"func": "static inline int qeth_get_initial_mtu_for_card(struct qeth_card *card)\n{\n\tswitch (card->info.type) {\n\tcase QETH_CARD_TYPE_UNKNOWN:\n\t\treturn 1500;\n\tcase QETH_CARD_TYPE_IQD:\n\t\treturn card->info.max_mtu;\n\tcase QETH_CARD_TYPE_OSD:\n\t\tswitch (card->info.link_type) {\n\t\tcase QETH_LINK_TYPE_HSTR:\n\t\tcase QETH_LINK_TYPE_LANE_TR:\n\t\t\treturn 2000;\n\t\tdefault:\n\t\t\treturn card->options.layer2 ? 1500 : 1492;\n\t\t}\n\tcase QETH_CARD_TYPE_OSM:\n\tcase QETH_CARD_TYPE_OSX:\n\t\treturn card->options.layer2 ? 1500 : 1492;\n\tdefault:\n\t\treturn 1500;\n\t}\n}\n", "target": 0, "idx": 28561}
{"func": "void BluetoothDeviceChooserController::GetDevice(\n    blink::mojom::WebBluetoothRequestDeviceOptionsPtr options,\n    const SuccessCallback& success_callback,\n    const ErrorCallback& error_callback) {\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n\n  DCHECK(success_callback_.is_null());\n  DCHECK(error_callback_.is_null());\n\n  success_callback_ = success_callback;\n  error_callback_ = error_callback;\n  options_ = std::move(options);\n  LogRequestDeviceOptions(options_);\n\n  if (options_->filters &&\n       BluetoothBlocklist::Get().IsExcluded(options_->filters.value())) {\n     RecordRequestDeviceOutcome(\n         UMARequestDeviceOutcome::BLOCKLISTED_SERVICE_IN_FILTER);\n    PostErrorCallback(\n        blink::mojom::WebBluetoothResult::REQUEST_DEVICE_WITH_BLOCKLISTED_UUID);\n     return;\n   }\n   BluetoothBlocklist::Get().RemoveExcludedUUIDs(options_.get());\n \n  const url::Origin requesting_origin =\n      render_frame_host_->GetLastCommittedOrigin();\n  const url::Origin embedding_origin =\n      web_contents_->GetMainFrame()->GetLastCommittedOrigin();\n  if (!embedding_origin.IsSameOriginWith(requesting_origin)) {\n    PostErrorCallback(blink::mojom::WebBluetoothResult::\n                          REQUEST_DEVICE_FROM_CROSS_ORIGIN_IFRAME);\n     return;\n   }\n  DCHECK(!requesting_origin.opaque());\n \n   if (!adapter_->IsPresent()) {\n     DVLOG(1) << \"Bluetooth Adapter not present. Can't serve requestDevice.\";\n     RecordRequestDeviceOutcome(\n         UMARequestDeviceOutcome::BLUETOOTH_ADAPTER_NOT_PRESENT);\n    PostErrorCallback(blink::mojom::WebBluetoothResult::NO_BLUETOOTH_ADAPTER);\n     return;\n   }\n \n  switch (GetContentClient()->browser()->AllowWebBluetooth(\n      web_contents_->GetBrowserContext(), requesting_origin,\n      embedding_origin)) {\n    case ContentBrowserClient::AllowWebBluetoothResult::BLOCK_POLICY: {\n      RecordRequestDeviceOutcome(\n          UMARequestDeviceOutcome::BLUETOOTH_CHOOSER_POLICY_DISABLED);\n      PostErrorCallback(blink::mojom::WebBluetoothResult::\n                            CHOOSER_NOT_SHOWN_API_LOCALLY_DISABLED);\n      return;\n    }\n    case ContentBrowserClient::AllowWebBluetoothResult::\n        BLOCK_GLOBALLY_DISABLED: {\n      web_contents_->GetMainFrame()->AddMessageToConsole(\n          blink::mojom::ConsoleMessageLevel::kInfo,\n          \"Bluetooth permission has been blocked.\");\n      RecordRequestDeviceOutcome(\n          UMARequestDeviceOutcome::BLUETOOTH_GLOBALLY_DISABLED);\n      PostErrorCallback(blink::mojom::WebBluetoothResult::\n                            CHOOSER_NOT_SHOWN_API_GLOBALLY_DISABLED);\n      return;\n    }\n    case ContentBrowserClient::AllowWebBluetoothResult::ALLOW:\n      break;\n  }\n   BluetoothChooser::EventHandler chooser_event_handler =\n       base::Bind(&BluetoothDeviceChooserController::OnBluetoothChooserEvent,\n                  base::Unretained(this));\n\n  if (WebContentsDelegate* delegate = web_contents_->GetDelegate()) {\n    chooser_ = delegate->RunBluetoothChooser(render_frame_host_,\n                                             std::move(chooser_event_handler));\n   }\n \n   if (!chooser_.get()) {\n    PostErrorCallback(\n        blink::mojom::WebBluetoothResult::WEB_BLUETOOTH_NOT_SUPPORTED);\n     return;\n   }\n \n  if (!chooser_->CanAskForScanningPermission()) {\n    DVLOG(1) << \"Closing immediately because Chooser cannot obtain permission.\";\n    OnBluetoothChooserEvent(BluetoothChooser::Event::DENIED_PERMISSION,\n                            \"\" /* device_address */);\n    return;\n  }\n\n  device_ids_.clear();\n  PopulateConnectedDevices();\n  if (!chooser_.get()) {\n    return;\n  }\n\n  if (!adapter_->IsPowered()) {\n    chooser_->SetAdapterPresence(\n        BluetoothChooser::AdapterPresence::POWERED_OFF);\n    return;\n  }\n\n  StartDeviceDiscovery();\n}\n", "target": 1, "idx": 186411}
{"func": "my_object_dict_of_dicts (MyObject *obj, GHashTable *in,\n                                GHashTable **out, GError **error)\n{\n  *out = g_hash_table_new_full (g_str_hash, g_str_equal,\n\t\t\t\t(GDestroyNotify) g_free,\n                                (GDestroyNotify) g_hash_table_destroy);\n  g_hash_table_foreach (in, hash_foreach_mangle_dict_of_strings, *out);\n  return TRUE;\n}\n", "target": 1, "idx": 178263}
{"func": "static int l2tp_ip6_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t    int *uaddr_len, int peer)\n{\n\tstruct sockaddr_l2tpip6 *lsa = (struct sockaddr_l2tpip6 *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct l2tp_ip6_sock *lsk = l2tp_ip6_sk(sk);\n\n \tlsa->l2tp_family = AF_INET6;\n \tlsa->l2tp_flowinfo = 0;\n \tlsa->l2tp_scope_id = 0;\n \tif (peer) {\n \t\tif (!lsk->peer_conn_id)\n \t\t\treturn -ENOTCONN;\n\t\tlsa->l2tp_conn_id = lsk->peer_conn_id;\n\t\tlsa->l2tp_addr = np->daddr;\n\t\tif (np->sndflow)\n\t\t\tlsa->l2tp_flowinfo = np->flow_label;\n\t} else {\n\t\tif (ipv6_addr_any(&np->rcv_saddr))\n\t\t\tlsa->l2tp_addr = np->saddr;\n\t\telse\n\t\t\tlsa->l2tp_addr = np->rcv_saddr;\n\n\t\tlsa->l2tp_conn_id = lsk->conn_id;\n\t}\n\tif (ipv6_addr_type(&lsa->l2tp_addr) & IPV6_ADDR_LINKLOCAL)\n\t\tlsa->l2tp_scope_id = sk->sk_bound_dev_if;\n\t*uaddr_len = sizeof(*lsa);\n\treturn 0;\n}\n", "target": 1, "idx": 179355}
{"func": "static ssize_t f_hidg_write(struct file *file, const char __user *buffer,\n\t\t\t    size_t count, loff_t *offp)\n{\n\tstruct f_hidg *hidg  = file->private_data;\n\tstruct usb_request *req;\n\tunsigned long flags;\n\tssize_t status = -ENOMEM;\n\n\tif (!access_ok(buffer, count))\n\t\treturn -EFAULT;\n\n\tspin_lock_irqsave(&hidg->write_spinlock, flags);\n\n#define WRITE_COND (!hidg->write_pending)\ntry_again:\n\t/* write queue */\n\twhile (!WRITE_COND) {\n\t\tspin_unlock_irqrestore(&hidg->write_spinlock, flags);\n\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\n\t\tif (wait_event_interruptible_exclusive(\n\t\t\t\thidg->write_queue, WRITE_COND))\n\t\t\treturn -ERESTARTSYS;\n\n\t\tspin_lock_irqsave(&hidg->write_spinlock, flags);\n\t}\n\n\thidg->write_pending = 1;\n\treq = hidg->req;\n\tcount  = min_t(unsigned, count, hidg->report_length);\n\n\tspin_unlock_irqrestore(&hidg->write_spinlock, flags);\n\tstatus = copy_from_user(req->buf, buffer, count);\n\n\tif (status != 0) {\n\t\tERROR(hidg->func.config->cdev,\n\t\t\t\"copy_from_user error\\n\");\n\t\tstatus = -EINVAL;\n\t\tgoto release_write_pending;\n\t}\n\n\tspin_lock_irqsave(&hidg->write_spinlock, flags);\n\n\t/* when our function has been disabled by host */\n\tif (!hidg->req) {\n\t\tfree_ep_req(hidg->in_ep, req);\n\t\t/*\n\t\t * TODO\n\t\t * Should we fail with error here?\n\t\t */\n\t\tgoto try_again;\n\t}\n\n\treq->status   = 0;\n\treq->zero     = 0;\n\treq->length   = count;\n \treq->complete = f_hidg_req_complete;\n \treq->context  = hidg;\n \n \tstatus = usb_ep_queue(hidg->in_ep, req, GFP_ATOMIC);\n \tif (status < 0) {\n \t\tERROR(hidg->func.config->cdev,\n \t\t\t\"usb_ep_queue error on int endpoint %zd\\n\", status);\n\t\tgoto release_write_pending_unlocked;\n \t} else {\n \t\tstatus = count;\n \t}\n\tspin_unlock_irqrestore(&hidg->write_spinlock, flags);\n \n \treturn status;\n release_write_pending:\n \tspin_lock_irqsave(&hidg->write_spinlock, flags);\nrelease_write_pending_unlocked:\n \thidg->write_pending = 0;\n \tspin_unlock_irqrestore(&hidg->write_spinlock, flags);\n \n\twake_up(&hidg->write_queue);\n\n\treturn status;\n}\n", "target": 1, "idx": 183363}
{"func": "static inline int object_common2(UNSERIALIZE_PARAMETER, long elements)\n{\n\tzval *retval_ptr = NULL;\n\tzval fname;\n\n\tif (Z_TYPE_PP(rval) != IS_OBJECT) {\n\t\treturn 0;\n\t}\n\n\tif (!process_nested_data(UNSERIALIZE_PASSTHRU, Z_OBJPROP_PP(rval), elements, 1)) {\n\t    /* We've got partially constructed object on our hands here. Wipe it. */\n\t    if(Z_TYPE_PP(rval) == IS_OBJECT) {\n\t       zend_hash_clean(Z_OBJPROP_PP(rval));\n\t       zend_object_store_ctor_failed(*rval TSRMLS_CC);\n\t    }\n\t    ZVAL_NULL(*rval);\n\t\treturn 0;\n\t}\n\n    if (Z_TYPE_PP(rval) != IS_OBJECT) {\n        return 0;\n    }\n\n\tif (Z_OBJCE_PP(rval) != PHP_IC_ENTRY &&\n\t\tzend_hash_exists(&Z_OBJCE_PP(rval)->function_table, \"__wakeup\", sizeof(\"__wakeup\"))) {\n\t\tINIT_PZVAL(&fname);\n\t\tZVAL_STRINGL(&fname, \"__wakeup\", sizeof(\"__wakeup\") - 1, 0);\n\t\tBG(serialize_lock)++;\n\t\tcall_user_function_ex(CG(function_table), rval, &fname, &retval_ptr, 0, 0, 1, NULL TSRMLS_CC);\n\t\tBG(serialize_lock)--;\n\t}\n\n\tif (retval_ptr) {\n\t\tzval_ptr_dtor(&retval_ptr);\n\t}\n\n\tif (EG(exception)) {\n\t\treturn 0;\n\t}\n\n\treturn finish_nested_data(UNSERIALIZE_PASSTHRU);\n\n}\n", "target": 0, "idx": 71130}
{"func": "gx_dc_colored_masked_get_dev_halftone(const gx_device_color * pdevc)\n{\n    return pdevc->colors.colored.c_ht;\n}\n", "target": 0, "idx": 1668}
{"func": "  views::ImageButton* close_button() const {\n    return media_controls_view_->close_button_;\n  }\n", "target": 1, "idx": 186311}
{"func": " static grub_err_t read_foo (struct grub_disk *disk, grub_disk_addr_t sector, grub_size_t size, char *buf) {\n\tif (disk != NULL) {\n\t\tconst int blocksize = 512; // unhardcode 512\n\t\tint ret;\n\t\tRIOBind *iob = disk->data;\n\t\tif (bio) iob = bio;\n\t\tret = iob->read_at (iob->io, delta+(blocksize*sector),\n\t\t\t(ut8*)buf, size*blocksize);\n\t\tif (ret == -1)\n\t\t\treturn 1;\n\t} else eprintf (\"oops. no disk\\n\");\n\treturn 0; // 0 is ok\n }\n", "target": 1, "idx": 181263}
{"func": "static int nfs_idmap_read_and_verify_message(struct idmap_msg *im,\n\t\tstruct idmap_msg *upcall,\n\t\tstruct key *key, struct key *authkey)\n{\n\tchar id_str[NFS_UINT_MAXLEN];\n\tsize_t len;\n\tint ret = -ENOKEY;\n\n\t/* ret = -ENOKEY */\n\tif (upcall->im_type != im->im_type || upcall->im_conv != im->im_conv)\n\t\tgoto out;\n\tswitch (im->im_conv) {\n\tcase IDMAP_CONV_NAMETOID:\n\t\tif (strcmp(upcall->im_name, im->im_name) != 0)\n\t\t\tbreak;\n\t\t/* Note: here we store the NUL terminator too */\n\t\tlen = sprintf(id_str, \"%d\", im->im_id) + 1;\n\t\tret = nfs_idmap_instantiate(key, authkey, id_str, len);\n\t\tbreak;\n\tcase IDMAP_CONV_IDTONAME:\n\t\tif (upcall->im_id != im->im_id)\n\t\t\tbreak;\n\t\tlen = strlen(im->im_name);\n\t\tret = nfs_idmap_instantiate(key, authkey, im->im_name, len);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\nout:\n\treturn ret;\n}\n", "target": 0, "idx": 69469}
{"func": "ScreenLockLibrary* CrosLibrary::GetScreenLockLibrary() {\n  return screen_lock_lib_.GetDefaultImpl(use_stub_impl_);\n}\n", "target": 1, "idx": 184097}
{"func": "bool BrowserCommandController::IsCommandEnabled(int id) const {\n  return command_updater_.IsCommandEnabled(id);\n}\n", "target": 0, "idx": 166542}
{"func": "static int is_hugetlb_entry_hwpoisoned(pte_t pte)\n{\n\tswp_entry_t swp;\n\n\tif (huge_pte_none(pte) || pte_present(pte))\n\t\treturn 0;\n\tswp = pte_to_swp_entry(pte);\n\tif (non_swap_entry(swp) && is_hwpoison_entry(swp))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n", "target": 0, "idx": 19726}
{"func": " long Cluster::HasBlockEntries(\n     const Segment* pSegment,\n    long long off,  //relative to start of segment payload\n    long long& pos,\n    long& len)\n{\n    assert(pSegment);\n    assert(off >= 0);  //relative to segment\n \n    IMkvReader* const pReader = pSegment->m_pReader;\n \n    long long total, avail;\n \n    long status = pReader->Length(&total, &avail);\n \n    if (status < 0)  //error\n        return status;\n \n    assert((total < 0) || (avail <= total));\n \n    pos = pSegment->m_start + off;  //absolute\n \n    if ((total >= 0) && (pos >= total))\n        return 0;  //we don't even have a complete cluster\n \n    const long long segment_stop =\n        (pSegment->m_size < 0) ? -1 : pSegment->m_start + pSegment->m_size;\n \n    long long cluster_stop = -1;  //interpreted later to mean \"unknown size\"\n \n    {\n        if ((pos + 1) > avail)\n        {\n            len = 1;\n            return E_BUFFER_NOT_FULL;\n        }\n        long long result = GetUIntLength(pReader, pos, len);\n        if (result < 0)  //error\n            return static_cast<long>(result);\n        if (result > 0)  //need more data\n            return E_BUFFER_NOT_FULL;\n        if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n            return E_FILE_FORMAT_INVALID;\n        if ((total >= 0) && ((pos + len) > total))\n            return 0;\n        if ((pos + len) > avail)\n            return E_BUFFER_NOT_FULL;\n        const long long id = ReadUInt(pReader, pos, len);\n        if (id < 0)  //error\n            return static_cast<long>(id);\n        if (id != 0x0F43B675)  //weird: not cluster ID\n            return -1;         //generic error\n        pos += len;  //consume Cluster ID field\n        if ((pos + 1) > avail)\n        {\n            len = 1;\n            return E_BUFFER_NOT_FULL;\n        }\n        result = GetUIntLength(pReader, pos, len);\n        if (result < 0)  //error\n            return static_cast<long>(result);\n        if (result > 0)  //weird\n            return E_BUFFER_NOT_FULL;\n        if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n            return E_FILE_FORMAT_INVALID;\n        if ((total >= 0) && ((pos + len) > total))\n            return 0;\n        if ((pos + len) > avail)\n            return E_BUFFER_NOT_FULL;\n        const long long size = ReadUInt(pReader, pos, len);\n        if (size < 0)  //error\n            return static_cast<long>(size);\n        if (size == 0)\n            return 0;  //cluster does not have entries\n        pos += len;  //consume size field\n        const long long unknown_size = (1LL << (7 * len)) - 1;\n        if (size != unknown_size)\n        {\n            cluster_stop = pos + size;\n            assert(cluster_stop >= 0);\n            if ((segment_stop >= 0) && (cluster_stop > segment_stop))\n                return E_FILE_FORMAT_INVALID;\n            if ((total >= 0) && (cluster_stop > total))\n                return 0;  //cluster does not have any entries\n        }\n     }\n \n    for (;;)\n    {\n        if ((cluster_stop >= 0) && (pos >= cluster_stop))\n            return 0;  //no entries detected\n \n        if ((pos + 1) > avail)\n        {\n            len = 1;\n            return E_BUFFER_NOT_FULL;\n        }\n \n        long long result = GetUIntLength(pReader, pos, len);\n \n        if (result < 0)  //error\n            return static_cast<long>(result);\n \n        if (result > 0)  //need more data\n            return E_BUFFER_NOT_FULL;\n \n        if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))\n            return E_FILE_FORMAT_INVALID;\n \n        if ((pos + len) > avail)\n            return E_BUFFER_NOT_FULL;\n \n        const long long id = ReadUInt(pReader, pos, len);\n \n        if (id < 0)  //error\n            return static_cast<long>(id);\n \n \n        if (id == 0x0F43B675)  //Cluster ID\n            return 0;  //no entries found\n \n        if (id == 0x0C53BB6B)  //Cues ID\n            return 0;  //no entries found\n        pos += len;  //consume id field\n        if ((cluster_stop >= 0) && (pos >= cluster_stop))\n            return E_FILE_FORMAT_INVALID;\n        if ((pos + 1) > avail)\n        {\n            len = 1;\n            return E_BUFFER_NOT_FULL;\n        }\n        result = GetUIntLength(pReader, pos, len);\n        if (result < 0)  //error\n            return static_cast<long>(result);\n        if (result > 0)  //underflow\n            return E_BUFFER_NOT_FULL;\n        if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))\n            return E_FILE_FORMAT_INVALID;\n        if ((pos + len) > avail)\n            return E_BUFFER_NOT_FULL;\n        const long long size = ReadUInt(pReader, pos, len);\n        if (size < 0)  //error\n            return static_cast<long>(size);\n        pos += len;  //consume size field\n        if ((cluster_stop >= 0) && (pos > cluster_stop))\n            return E_FILE_FORMAT_INVALID;\n        if (size == 0)  //weird\n            continue;\n        const long long unknown_size = (1LL << (7 * len)) - 1;\n        if (size == unknown_size)\n            return E_FILE_FORMAT_INVALID;  //not supported inside cluster\n        if ((cluster_stop >= 0) && ((pos + size) > cluster_stop))\n            return E_FILE_FORMAT_INVALID;\n        if (id == 0x20)  //BlockGroup ID\n            return 1;    //have at least one entry\n        if (id == 0x23)  //SimpleBlock ID\n            return 1;    //have at least one entry\n        pos += size;  //consume payload\n        assert((cluster_stop < 0) || (pos <= cluster_stop));\n     }\n }\n", "target": 1, "idx": 188406}
{"func": "ossl_cipher_initialize(VALUE self, VALUE str)\n{\n     EVP_CIPHER_CTX *ctx;\n     const EVP_CIPHER *cipher;\n     char *name;\n    unsigned char dummy_key[EVP_MAX_KEY_LENGTH] = { 0 };\n \n     name = StringValueCStr(str);\n     GetCipherInit(self, ctx);\n    if (ctx) {\n\tossl_raise(rb_eRuntimeError, \"Cipher already inititalized!\");\n    }\n    AllocCipher(self, ctx);\n     if (!(cipher = EVP_get_cipherbyname(name))) {\n \tossl_raise(rb_eRuntimeError, \"unsupported cipher algorithm (%\"PRIsVALUE\")\", str);\n     }\n    /*\n     * EVP_CipherInit_ex() allows to specify NULL to key and IV, however some\n     * ciphers don't handle well (OpenSSL's bug). [Bug #2768]\n     *\n     * The EVP which has EVP_CIPH_RAND_KEY flag (such as DES3) allows\n     * uninitialized key, but other EVPs (such as AES) does not allow it.\n     * Calling EVP_CipherUpdate() without initializing key causes SEGV so we\n     * set the data filled with \"\\0\" as the key by default.\n     */\n    if (EVP_CipherInit_ex(ctx, cipher, NULL, dummy_key, NULL, -1) != 1)\n \tossl_raise(eCipherError, NULL);\n \n     return self;\n}\n", "target": 1, "idx": 181952}
{"func": "int WebContentsImpl::CreateOpenerRenderViewsForRenderManager(\n    SiteInstance* instance) {\n  if (!opener_)\n    return MSG_ROUTING_NONE;\n\n  return opener_->CreateOpenerRenderViews(instance);\n}\n", "target": 0, "idx": 118831}
{"func": " static int get_default_root(pool *p, int allow_symlinks, char **root) {\n   config_rec *c = NULL;\n   char *dir = NULL;\n  int res;\n\n  c = find_config(main_server->conf, CONF_PARAM, \"DefaultRoot\", FALSE);\n  while (c) {\n    pr_signals_handle();\n\n    /* Check the groups acl */\n    if (c->argc < 2) {\n      dir = c->argv[0];\n      break;\n    }\n\n    res = pr_expr_eval_group_and(((char **) c->argv)+1);\n    if (res) {\n      dir = c->argv[0];\n      break;\n    }\n\n    c = find_config_next(c, c->next, CONF_PARAM, \"DefaultRoot\", FALSE);\n  }\n\n  if (dir) {\n    char *new_dir;\n\n    /* Check for any expandable variables. */\n    new_dir = path_subst_uservar(p, &dir);\n    if (new_dir != NULL) {\n      dir = new_dir;\n    }\n\n    if (strncmp(dir, \"/\", 2) == 0) {\n      dir = NULL;\n\n    } else {\n      char *realdir;\n      int xerrno = 0;\n \n       if (allow_symlinks == FALSE) {\n         char *path, target_path[PR_TUNABLE_PATH_MAX + 1];\n        struct stat st;\n         size_t pathlen;\n \n         /* First, deal with any possible interpolation.  dir_realpath() will\n         * do this for us, but dir_realpath() ALSO automatically follows\n         * symlinks, which is what we do NOT want to do here.\n         */\n\n        path = dir;\n        if (*path != '/') {\n          if (*path == '~') {\n            if (pr_fs_interpolate(dir, target_path,\n                sizeof(target_path)-1) < 0) {\n              return -1;\n            }\n\n            path = target_path;\n          }\n        }\n\n        /* Note: lstat(2) is sensitive to the presence of a trailing slash on\n         * the path, particularly in the case of a symlink to a directory.\n         * Thus to get the correct test, we need to remove any trailing slash\n         * that might be present.  Subtle.\n         */\n        pathlen = strlen(path);\n        if (pathlen > 1 &&\n            path[pathlen-1] == '/') {\n           path[pathlen-1] = '\\0';\n         }\n \n        pr_fs_clear_cache();\n        res = pr_fsio_lstat(path, &st);\n         if (res < 0) {\n          xerrno = errno;\n          pr_log_pri(PR_LOG_WARNING, \"error: unable to check %s: %s\", path,\n            strerror(xerrno));\n          errno = xerrno;\n          return -1;\n        }\n \n        if (S_ISLNK(st.st_mode)) {\n          pr_log_pri(PR_LOG_WARNING,\n            \"error: DefaultRoot %s is a symlink (denied by AllowChrootSymlinks \"\n            \"config)\", path);\n           errno = EPERM;\n           return -1;\n         }\n      }\n\n      /* We need to be the final user here so that if the user has their home\n       * directory with a mode the user proftpd is running (i.e. the User\n       * directive) as can not traverse down, we can still have the default\n       * root.\n       */\n\n      PRIVS_USER\n      realdir = dir_realpath(p, dir);\n      xerrno = errno;\n      PRIVS_RELINQUISH\n\n      if (realdir) {\n        dir = realdir;\n\n      } else {\n        /* Try to provide a more informative message. */\n        char interp_dir[PR_TUNABLE_PATH_MAX + 1];\n\n        memset(interp_dir, '\\0', sizeof(interp_dir));\n        (void) pr_fs_interpolate(dir, interp_dir, sizeof(interp_dir)-1); \n\n        pr_log_pri(PR_LOG_NOTICE,\n          \"notice: unable to use DefaultRoot '%s' [resolved to '%s']: %s\",\n          dir, interp_dir, strerror(xerrno));\n\n        errno = xerrno;\n      }\n    }\n  }\n\n  *root = dir;\n  return 0;\n}\n", "target": 1, "idx": 183242}
{"func": "getnetnum(\n\tconst char *num,\n\tsockaddr_u *addr,\n\tint complain,\n\tenum gnn_type a_type\t/* ignored */\n\t)\n{\n\tNTP_REQUIRE(AF_UNSPEC == AF(addr) ||\n\t\t    AF_INET == AF(addr) ||\n\t\t    AF_INET6 == AF(addr));\n\n\tif (!is_ip_address(num, AF(addr), addr))\n\t\treturn 0;\n\n\tif (IS_IPV6(addr) && !ipv6_works)\n\t\treturn -1;\n\n# ifdef ISC_PLATFORM_HAVESALEN\n\taddr->sa.sa_len = SIZEOF_SOCKADDR(AF(addr));\n# endif\n\tSET_PORT(addr, NTP_PORT);\n\n\tDPRINTF(2, (\"getnetnum given %s, got %s\\n\", num, stoa(addr)));\n\n\treturn 1;\n}\n", "target": 0, "idx": 74206}
{"func": "static Image *ReadSCREENSHOTImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=(Image *) NULL;\n#if defined(MAGICKCORE_WINGDI32_DELEGATE)\n  {\n    BITMAPINFO\n      bmi;\n\n    DISPLAY_DEVICE\n      device;\n\n    HBITMAP\n      bitmap,\n      bitmapOld;\n\n    HDC\n      bitmapDC,\n      hDC;\n\n    Image\n      *screen;\n\n     int\n       i;\n \n     register PixelPacket\n       *q;\n \n    register ssize_t\n      x;\n\n    RGBTRIPLE\n      *p;\n\n    ssize_t\n      y;\n\n    assert(image_info != (const ImageInfo *) NULL);\n    i=0;\n    device.cb = sizeof(device);\n    image=(Image *) NULL;\n    while(EnumDisplayDevices(NULL,i,&device,0) && ++i)\n    {\n      if ((device.StateFlags & DISPLAY_DEVICE_ACTIVE) != DISPLAY_DEVICE_ACTIVE)\n        continue;\n\n      hDC=CreateDC(device.DeviceName,device.DeviceName,NULL,NULL);\n      if (hDC == (HDC) NULL)\n        ThrowReaderException(CoderError,\"UnableToCreateDC\");\n\n      screen=AcquireImage(image_info);\n       screen->columns=(size_t) GetDeviceCaps(hDC,HORZRES);\n       screen->rows=(size_t) GetDeviceCaps(hDC,VERTRES);\n       screen->storage_class=DirectClass;\n       if (image == (Image *) NULL)\n         image=screen;\n       else\n        AppendImageToList(&image,screen);\n\n      bitmapDC=CreateCompatibleDC(hDC);\n      if (bitmapDC == (HDC) NULL)\n        {\n          DeleteDC(hDC);\n          ThrowReaderException(CoderError,\"UnableToCreateDC\");\n        }\n      (void) ResetMagickMemory(&bmi,0,sizeof(BITMAPINFO));\n      bmi.bmiHeader.biSize=sizeof(BITMAPINFOHEADER);\n      bmi.bmiHeader.biWidth=(LONG) screen->columns;\n      bmi.bmiHeader.biHeight=(-1)*(LONG) screen->rows;\n      bmi.bmiHeader.biPlanes=1;\n      bmi.bmiHeader.biBitCount=24;\n      bmi.bmiHeader.biCompression=BI_RGB;\n      bitmap=CreateDIBSection(hDC,&bmi,DIB_RGB_COLORS,(void **) &p,NULL,0);\n      if (bitmap == (HBITMAP) NULL)\n        {\n          DeleteDC(hDC);\n          DeleteDC(bitmapDC);\n          ThrowReaderException(CoderError,\"UnableToCreateBitmap\");\n        }\n      bitmapOld=(HBITMAP) SelectObject(bitmapDC,bitmap);\n      if (bitmapOld == (HBITMAP) NULL)\n        {\n          DeleteDC(hDC);\n          DeleteDC(bitmapDC);\n          DeleteObject(bitmap);\n          ThrowReaderException(CoderError,\"UnableToCreateBitmap\");\n        }\n      BitBlt(bitmapDC,0,0,(int) screen->columns,(int) screen->rows,hDC,0,0,\n        SRCCOPY);\n      (void) SelectObject(bitmapDC,bitmapOld);\n\n      for (y=0; y < (ssize_t) screen->rows; y++)\n      {\n        q=QueueAuthenticPixels(screen,0,y,screen->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n          break;\n        for (x=0; x < (ssize_t) screen->columns; x++)\n        {\n          SetPixelRed(q,ScaleCharToQuantum(p->rgbtRed));\n          SetPixelGreen(q,ScaleCharToQuantum(p->rgbtGreen));\n          SetPixelBlue(q,ScaleCharToQuantum(p->rgbtBlue));\n          SetPixelOpacity(q,OpaqueOpacity);\n          p++;\n          q++;\n        }\n        if (SyncAuthenticPixels(screen,exception) == MagickFalse)\n          break;\n      }\n\n      DeleteDC(hDC);\n      DeleteDC(bitmapDC);\n      DeleteObject(bitmap);\n    }\n  }\n#elif defined(MAGICKCORE_X11_DELEGATE)\n  {\n    const char\n      *option;\n\n    XImportInfo\n      ximage_info;\n\n    (void) exception;\n    XGetImportInfo(&ximage_info);\n    option=GetImageOption(image_info,\"x:screen\");\n    if (option != (const char *) NULL)\n      ximage_info.screen=IsMagickTrue(option);\n    option=GetImageOption(image_info,\"x:silent\");\n    if (option != (const char *) NULL)\n      ximage_info.silent=IsMagickTrue(option);\n    image=XImportImage(image_info,&ximage_info);\n  }\n#endif\n  return(image);\n}\n", "target": 1, "idx": 181774}
{"func": "void HTMLFormControlElement::AssociateWith(HTMLFormElement* form) {\n  AssociateByParser(form);\n}\n", "target": 0, "idx": 149217}
{"func": "static int mov_read_ares(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    if (c->fc->nb_streams >= 1) {\n        AVCodecParameters *par = c->fc->streams[c->fc->nb_streams-1]->codecpar;\n        if (par->codec_tag == MKTAG('A', 'V', 'i', 'n') &&\n            par->codec_id == AV_CODEC_ID_H264 &&\n            atom.size > 11) {\n            int cid;\n            avio_skip(pb, 10);\n            cid = avio_rb16(pb);\n            /* For AVID AVCI50, force width of 1440 to be able to select the correct SPS and PPS */\n            if (cid == 0xd4d || cid == 0xd4e)\n                par->width = 1440;\n            return 0;\n        } else if ((par->codec_tag == MKTAG('A', 'V', 'd', '1') ||\n                    par->codec_tag == MKTAG('A', 'V', 'd', 'n')) &&\n                   atom.size >= 24) {\n            int num, den;\n            avio_skip(pb, 12);\n            num = avio_rb32(pb);\n            den = avio_rb32(pb);\n            if (num <= 0 || den <= 0)\n                return 0;\n            switch (avio_rb32(pb)) {\n            case 2:\n                if (den >= INT_MAX / 2)\n                    return 0;\n                den *= 2;\n            case 1:\n                c->fc->streams[c->fc->nb_streams-1]->display_aspect_ratio.num = num;\n                c->fc->streams[c->fc->nb_streams-1]->display_aspect_ratio.den = den;\n            default:\n                return 0;\n            }\n        }\n    }\n\n    return mov_read_avid(c, pb, atom);\n}\n", "target": 0, "idx": 61408}
{"func": "WebInputEvent* CreateWebInputEvent(const PP_InputEvent& event) {\n  scoped_ptr<WebInputEvent> web_input_event;\n  switch (event.type) {\n    case PP_INPUTEVENT_TYPE_UNDEFINED:\n      return NULL;\n    case PP_INPUTEVENT_TYPE_MOUSEDOWN:\n    case PP_INPUTEVENT_TYPE_MOUSEUP:\n     case PP_INPUTEVENT_TYPE_MOUSEMOVE:\n     case PP_INPUTEVENT_TYPE_MOUSEENTER:\n     case PP_INPUTEVENT_TYPE_MOUSELEAVE:\n       web_input_event.reset(BuildMouseEvent(event));\n       break;\n     case PP_INPUTEVENT_TYPE_MOUSEWHEEL:\n      web_input_event.reset(BuildMouseWheelEvent(event));\n      break;\n    case PP_INPUTEVENT_TYPE_RAWKEYDOWN:\n    case PP_INPUTEVENT_TYPE_KEYDOWN:\n    case PP_INPUTEVENT_TYPE_KEYUP:\n      web_input_event.reset(BuildKeyEvent(event));\n      break;\n    case PP_INPUTEVENT_TYPE_CHAR:\n      web_input_event.reset(BuildCharEvent(event));\n      break;\n  }\n \n   return web_input_event.release();\n }\n", "target": 1, "idx": 184077}
{"func": "process(struct magic_set *ms, const char *inname, int wid)\n{\n\tconst char *type;\n\tint std_in = strcmp(inname, \"-\") == 0;\n\n\tif (wid > 0 && !bflag) {\n\t\t(void)printf(\"%s\", std_in ? \"/dev/stdin\" : inname);\n\t\tif (nulsep)\n\t\t\t(void)putc('\\0', stdout);\n\t\t(void)printf(\"%s\", separator);\n\t\t(void)printf(\"%*s \",\n\t\t    (int) (nopad ? 0 : (wid - file_mbswidth(inname))), \"\");\n\t}\n\n\ttype = magic_file(ms, std_in ? NULL : inname);\n\tif (type == NULL) {\n\t\t(void)printf(\"ERROR: %s\\n\", magic_error(ms));\n\t\treturn 1;\n\t} else {\n\t\t(void)printf(\"%s\\n\", type);\n\t\treturn 0;\n\t}\n}\n", "target": 0, "idx": 45965}
{"func": "ext4_xattr_create_cache(char *name)\n {\n\treturn mb_cache_create(name, HASH_BUCKET_BITS);\n }\n", "target": 1, "idx": 183165}
{"func": "static inline void invalidate_cursor1(CirrusVGAState *s)\n{\n    if (s->last_hw_cursor_size) {\n        vga_invalidate_scanlines(&s->vga,\n                                 s->last_hw_cursor_y + s->last_hw_cursor_y_start,\n                                 s->last_hw_cursor_y + s->last_hw_cursor_y_end);\n    }\n}\n", "target": 0, "idx": 7615}
{"func": "void Preferences::NotifyPrefChanged(const std::wstring* pref_name) {\n  if (!pref_name || *pref_name == prefs::kTapToClickEnabled) {\n    CrosLibrary::Get()->GetSynapticsLibrary()->SetBoolParameter(\n        PARAM_BOOL_TAP_TO_CLICK,\n        tap_to_click_enabled_.GetValue());\n  }\n  if (!pref_name || *pref_name == prefs::kVertEdgeScrollEnabled) {\n    CrosLibrary::Get()->GetSynapticsLibrary()->SetBoolParameter(\n        PARAM_BOOL_VERTICAL_EDGE_SCROLLING,\n        vert_edge_scroll_enabled_.GetValue());\n  }\n  if (!pref_name || *pref_name == prefs::kTouchpadSpeedFactor) {\n    CrosLibrary::Get()->GetSynapticsLibrary()->SetRangeParameter(\n        PARAM_RANGE_SPEED_SENSITIVITY,\n        speed_factor_.GetValue());\n  }\n  if (!pref_name || *pref_name == prefs::kTouchpadSensitivity) {\n    CrosLibrary::Get()->GetSynapticsLibrary()->SetRangeParameter(\n          PARAM_RANGE_TOUCH_SENSITIVITY,\n          sensitivity_.GetValue());\n  }\n\n\n  if (!pref_name || *pref_name == prefs::kLanguageHotkeyNextEngineInMenu) {\n    SetLanguageConfigStringListAsCSV(\n        kHotKeySectionName,\n        kNextEngineInMenuConfigName,\n        language_hotkey_next_engine_in_menu_.GetValue());\n  }\n  if (!pref_name || *pref_name == prefs::kLanguageHotkeyPreviousEngine) {\n    SetLanguageConfigStringListAsCSV(\n        kHotKeySectionName,\n        kPreviousEngineConfigName,\n        language_hotkey_previous_engine_.GetValue());\n  }\n  if (!pref_name || *pref_name == prefs::kLanguagePreloadEngines) {\n    SetLanguageConfigStringListAsCSV(kGeneralSectionName,\n                                     kPreloadEnginesConfigName,\n                                     language_preload_engines_.GetValue());\n  }\n  for (size_t i = 0; i < kNumChewingBooleanPrefs; ++i) {\n    if (!pref_name || *pref_name == kChewingBooleanPrefs[i].pref_name) {\n      SetLanguageConfigBoolean(kChewingSectionName,\n                               kChewingBooleanPrefs[i].ibus_config_name,\n                               language_chewing_boolean_prefs_[i].GetValue());\n    }\n  }\n  for (size_t i = 0; i < kNumChewingMultipleChoicePrefs; ++i) {\n    if (!pref_name || *pref_name == kChewingMultipleChoicePrefs[i].pref_name) {\n      SetLanguageConfigString(\n          kChewingSectionName,\n          kChewingMultipleChoicePrefs[i].ibus_config_name,\n          language_chewing_multiple_choice_prefs_[i].GetValue());\n    }\n  }\n  if (!pref_name || *pref_name == kChewingHsuSelKeyType.pref_name) {\n    SetLanguageConfigInteger(\n        kChewingSectionName,\n        kChewingHsuSelKeyType.ibus_config_name,\n        language_chewing_hsu_sel_key_type_.GetValue());\n  }\n  for (size_t i = 0; i < kNumChewingIntegerPrefs; ++i) {\n    if (!pref_name || *pref_name == kChewingIntegerPrefs[i].pref_name) {\n      SetLanguageConfigInteger(kChewingSectionName,\n                               kChewingIntegerPrefs[i].ibus_config_name,\n                               language_chewing_integer_prefs_[i].GetValue());\n    }\n  }\n  if (!pref_name || *pref_name == prefs::kLanguageHangulKeyboard) {\n     SetLanguageConfigString(kHangulSectionName, kHangulKeyboardConfigName,\n                             language_hangul_keyboard_.GetValue());\n   }\n   for (size_t i = 0; i < kNumPinyinBooleanPrefs; ++i) {\n     if (!pref_name || *pref_name == kPinyinBooleanPrefs[i].pref_name) {\n       SetLanguageConfigBoolean(kPinyinSectionName,\n                               kPinyinBooleanPrefs[i].ibus_config_name,\n                               language_pinyin_boolean_prefs_[i].GetValue());\n    }\n  }\n  for (size_t i = 0; i < kNumPinyinIntegerPrefs; ++i) {\n    if (!pref_name || *pref_name == kPinyinIntegerPrefs[i].pref_name) {\n      SetLanguageConfigInteger(kPinyinSectionName,\n                               kPinyinIntegerPrefs[i].ibus_config_name,\n                               language_pinyin_int_prefs_[i].GetValue());\n    }\n  }\n  if (!pref_name || *pref_name == kPinyinDoublePinyinSchema.pref_name) {\n    SetLanguageConfigInteger(\n        kPinyinSectionName,\n        kPinyinDoublePinyinSchema.ibus_config_name,\n        language_pinyin_double_pinyin_schema_.GetValue());\n  }\n  for (size_t i = 0; i < kNumMozcBooleanPrefs; ++i) {\n    if (!pref_name || *pref_name == kMozcBooleanPrefs[i].pref_name) {\n      SetLanguageConfigBoolean(kMozcSectionName,\n                               kMozcBooleanPrefs[i].ibus_config_name,\n                               language_mozc_boolean_prefs_[i].GetValue());\n    }\n  }\n  for (size_t i = 0; i < kNumMozcMultipleChoicePrefs; ++i) {\n    if (!pref_name || *pref_name == kMozcMultipleChoicePrefs[i].pref_name) {\n      SetLanguageConfigString(\n          kMozcSectionName,\n          kMozcMultipleChoicePrefs[i].ibus_config_name,\n          language_mozc_multiple_choice_prefs_[i].GetValue());\n    }\n  }\n  for (size_t i = 0; i < kNumMozcIntegerPrefs; ++i) {\n    if (!pref_name || *pref_name == kMozcIntegerPrefs[i].pref_name) {\n      SetLanguageConfigInteger(kMozcSectionName,\n                               kMozcIntegerPrefs[i].ibus_config_name,\n                               language_mozc_integer_prefs_[i].GetValue());\n    }\n  }\n}\n", "target": 1, "idx": 183451}
{"func": "static inline int pipelined_send(struct msg_queue *msq, struct msg_msg *msg)\n{\n\tstruct msg_receiver *msr, *t;\n\n\tlist_for_each_entry_safe(msr, t, &msq->q_receivers, r_list) {\n\t\tif (testmsg(msg, msr->r_msgtype, msr->r_mode) &&\n\t\t    !security_msg_queue_msgrcv(msq, msg, msr->r_tsk,\n\t\t\t\t\t       msr->r_msgtype, msr->r_mode)) {\n\n\t\t\tlist_del(&msr->r_list);\n\t\t\tif (msr->r_maxsize < msg->m_ts) {\n\t\t\t\t/* initialize pipelined send ordering */\n\t\t\t\tmsr->r_msg = NULL;\n\t\t\t\twake_up_process(msr->r_tsk);\n\t\t\t\t/* barrier (B) see barrier comment below */\n\t\t\t\tsmp_wmb();\n\t\t\t\tmsr->r_msg = ERR_PTR(-E2BIG);\n\t\t\t} else {\n\t\t\t\tmsr->r_msg = NULL;\n\t\t\t\tmsq->q_lrpid = task_pid_vnr(msr->r_tsk);\n\t\t\t\tmsq->q_rtime = get_seconds();\n\t\t\t\twake_up_process(msr->r_tsk);\n\t\t\t\t/*\n\t\t\t\t * Ensure that the wakeup is visible before\n\t\t\t\t * setting r_msg, as the receiving can otherwise\n\t\t\t\t * exit - once r_msg is set, the receiver can\n\t\t\t\t * continue. See lockless receive part 1 and 2\n\t\t\t\t * in do_msgrcv(). Barrier (B).\n\t\t\t\t */\n\t\t\t\tsmp_wmb();\n\t\t\t\tmsr->r_msg = msg;\n\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n", "target": 0, "idx": 42007}
{"func": "int udhcpc_main(int argc UNUSED_PARAM, char **argv)\n{\n\tuint8_t *message;\n\tconst char *str_V, *str_h, *str_F, *str_r;\n\tIF_FEATURE_UDHCPC_ARPING(const char *str_a = \"2000\";)\n\tIF_FEATURE_UDHCP_PORT(char *str_P;)\n\tvoid *clientid_mac_ptr;\n\tllist_t *list_O = NULL;\n\tllist_t *list_x = NULL;\n\tint tryagain_timeout = 20;\n\tint discover_timeout = 3;\n\tint discover_retries = 3;\n\tuint32_t server_addr = server_addr; /* for compiler */\n\tuint32_t requested_ip = 0;\n\tuint32_t xid = xid; /* for compiler */\n\tint packet_num;\n\tint timeout; /* must be signed */\n\tunsigned already_waited_sec;\n\tunsigned opt;\n\tIF_FEATURE_UDHCPC_ARPING(unsigned arpping_ms;)\n\tint retval;\n\n\tsetup_common_bufsiz();\n\n\t/* Default options */\n\tIF_FEATURE_UDHCP_PORT(SERVER_PORT = 67;)\n\tIF_FEATURE_UDHCP_PORT(CLIENT_PORT = 68;)\n\tclient_config.interface = \"eth0\";\n\tclient_config.script = CONFIG_UDHCPC_DEFAULT_SCRIPT;\n\tstr_V = \"udhcp \"BB_VER;\n\n\t/* Parse command line */\n\topt = getopt32long(argv, \"^\"\n\t\t/* O,x: list; -T,-t,-A take numeric param */\n\t\t\"CV:H:h:F:i:np:qRr:s:T:+t:+SA:+O:*ox:*fB\"\n\t\tUSE_FOR_MMU(\"b\")\n\t\tIF_FEATURE_UDHCPC_ARPING(\"a::\")\n\t\tIF_FEATURE_UDHCP_PORT(\"P:\")\n\t\t\"v\"\n\t\t\"\\0\" IF_UDHCP_VERBOSE(\"vv\") /* -v is a counter */\n\t\t, udhcpc_longopts\n\t\t, &str_V, &str_h, &str_h, &str_F\n\t\t, &client_config.interface, &client_config.pidfile /* i,p */\n\t\t, &str_r /* r */\n\t\t, &client_config.script /* s */\n\t\t, &discover_timeout, &discover_retries, &tryagain_timeout /* T,t,A */\n\t\t, &list_O\n\t\t, &list_x\n\t\tIF_FEATURE_UDHCPC_ARPING(, &str_a)\n\t\tIF_FEATURE_UDHCP_PORT(, &str_P)\n\t\tIF_UDHCP_VERBOSE(, &dhcp_verbose)\n\t);\n\tif (opt & (OPT_h|OPT_H)) {\n\t\tbb_error_msg(\"option -h NAME is deprecated, use -x hostname:NAME\");\n\t\tclient_config.hostname = alloc_dhcp_option(DHCP_HOST_NAME, str_h, 0);\n\t}\n\tif (opt & OPT_F) {\n\t\t/* FQDN option format: [0x51][len][flags][0][0]<fqdn> */\n\t\tclient_config.fqdn = alloc_dhcp_option(DHCP_FQDN, str_F, 3);\n\t\t/* Flag bits: 0000NEOS\n\t\t * S: 1 = Client requests server to update A RR in DNS as well as PTR\n\t\t * O: 1 = Server indicates to client that DNS has been updated regardless\n\t\t * E: 1 = Name is in DNS format, i.e. <4>host<6>domain<3>com<0>,\n\t\t *    not \"host.domain.com\". Format 0 is obsolete.\n\t\t * N: 1 = Client requests server to not update DNS (S must be 0 then)\n\t\t * Two [0] bytes which follow are deprecated and must be 0.\n\t\t */\n\t\tclient_config.fqdn[OPT_DATA + 0] = 0x1;\n\t\t/*client_config.fqdn[OPT_DATA + 1] = 0; - xzalloc did it */\n\t\t/*client_config.fqdn[OPT_DATA + 2] = 0; */\n\t}\n\tif (opt & OPT_r)\n\t\trequested_ip = inet_addr(str_r);\n#if ENABLE_FEATURE_UDHCP_PORT\n\tif (opt & OPT_P) {\n\t\tCLIENT_PORT = xatou16(str_P);\n\t\tSERVER_PORT = CLIENT_PORT - 1;\n\t}\n#endif\n\tIF_FEATURE_UDHCPC_ARPING(arpping_ms = xatou(str_a);)\n\twhile (list_O) {\n\t\tchar *optstr = llist_pop(&list_O);\n\t\tunsigned n = bb_strtou(optstr, NULL, 0);\n\t\tif (errno || n > 254) {\n\t\t\tn = udhcp_option_idx(optstr, dhcp_option_strings);\n\t\t\tn = dhcp_optflags[n].code;\n\t\t}\n\t\tclient_config.opt_mask[n >> 3] |= 1 << (n & 7);\n\t}\n\tif (!(opt & OPT_o)) {\n\t\tunsigned i, n;\n\t\tfor (i = 0; (n = dhcp_optflags[i].code) != 0; i++) {\n\t\t\tif (dhcp_optflags[i].flags & OPTION_REQ) {\n\t\t\t\tclient_config.opt_mask[n >> 3] |= 1 << (n & 7);\n\t\t\t}\n\t\t}\n\t}\n\twhile (list_x) {\n\t\tchar *optstr = xstrdup(llist_pop(&list_x));\n\t\tudhcp_str2optset(optstr, &client_config.options,\n\t\t\t\tdhcp_optflags, dhcp_option_strings,\n\t\t\t\t/*dhcpv6:*/ 0\n\t\t);\n\t\tfree(optstr);\n\t}\n\n\tif (udhcp_read_interface(client_config.interface,\n\t\t\t&client_config.ifindex,\n\t\t\tNULL,\n\t\t\tclient_config.client_mac)\n\t) {\n\t\treturn 1;\n\t}\n\n\tclientid_mac_ptr = NULL;\n\tif (!(opt & OPT_C) && !udhcp_find_option(client_config.options, DHCP_CLIENT_ID)) {\n\t\t/* not suppressed and not set, set the default client ID */\n\t\tclient_config.clientid = alloc_dhcp_option(DHCP_CLIENT_ID, \"\", 7);\n\t\tclient_config.clientid[OPT_DATA] = 1; /* type: ethernet */\n\t\tclientid_mac_ptr = client_config.clientid + OPT_DATA+1;\n\t\tmemcpy(clientid_mac_ptr, client_config.client_mac, 6);\n\t}\n\tif (str_V[0] != '\\0') {\n\t\tclient_config.vendorclass = alloc_dhcp_option(DHCP_VENDOR, str_V, 0);\n\t}\n\n#if !BB_MMU\n\t/* on NOMMU reexec (i.e., background) early */\n\tif (!(opt & OPT_f)) {\n\t\tbb_daemonize_or_rexec(0 /* flags */, argv);\n\t\tlogmode = LOGMODE_NONE;\n\t}\n#endif\n\tif (opt & OPT_S) {\n\t\topenlog(applet_name, LOG_PID, LOG_DAEMON);\n\t\tlogmode |= LOGMODE_SYSLOG;\n\t}\n\n\t/* Make sure fd 0,1,2 are open */\n\tbb_sanitize_stdio();\n\t/* Create pidfile */\n\twrite_pidfile(client_config.pidfile);\n\t/* Goes to stdout (unless NOMMU) and possibly syslog */\n\tbb_error_msg(\"started, v\"BB_VER);\n\t/* Set up the signal pipe */\n\tudhcp_sp_setup();\n\t/* We want random_xid to be random... */\n\tsrand(monotonic_us());\n\n\tstate = INIT_SELECTING;\n\tudhcp_run_script(NULL, \"deconfig\");\n\tchange_listen_mode(LISTEN_RAW);\n\tpacket_num = 0;\n\ttimeout = 0;\n\talready_waited_sec = 0;\n\n\t/* Main event loop. select() waits on signal pipe and possibly\n\t * on sockfd.\n\t * \"continue\" statements in code below jump to the top of the loop.\n\t */\n\tfor (;;) {\n\t\tint tv;\n\t\tstruct pollfd pfds[2];\n\t\tstruct dhcp_packet packet;\n\t\t/* silence \"uninitialized!\" warning */\n\t\tunsigned timestamp_before_wait = timestamp_before_wait;\n\n\n\t\t/* Was opening raw or udp socket here\n\t\t * if (listen_mode != LISTEN_NONE && sockfd < 0),\n\t\t * but on fast network renew responses return faster\n\t\t * than we open sockets. Thus this code is moved\n\t\t * to change_listen_mode(). Thus we open listen socket\n\t\t * BEFORE we send renew request (see \"case BOUND:\"). */\n\n\t\tudhcp_sp_fd_set(pfds, sockfd);\n\n\t\ttv = timeout - already_waited_sec;\n\t\tretval = 0;\n\t\t/* If we already timed out, fall through with retval = 0, else... */\n\t\tif (tv > 0) {\n\t\t\tlog1(\"waiting %u seconds\", tv);\n\t\t\ttimestamp_before_wait = (unsigned)monotonic_sec();\n\t\t\tretval = poll(pfds, 2, tv < INT_MAX/1000 ? tv * 1000 : INT_MAX);\n\t\t\tif (retval < 0) {\n\t\t\t\t/* EINTR? A signal was caught, don't panic */\n\t\t\t\tif (errno == EINTR) {\n\t\t\t\t\talready_waited_sec += (unsigned)monotonic_sec() - timestamp_before_wait;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* Else: an error occurred, panic! */\n\t\t\t\tbb_perror_msg_and_die(\"poll\");\n\t\t\t}\n\t\t}\n\n\t\t/* If timeout dropped to zero, time to become active:\n\t\t * resend discover/renew/whatever\n\t\t */\n\t\tif (retval == 0) {\n\t\t\t/* When running on a bridge, the ifindex may have changed\n\t\t\t * (e.g. if member interfaces were added/removed\n\t\t\t * or if the status of the bridge changed).\n\t\t\t * Refresh ifindex and client_mac:\n\t\t\t */\n\t\t\tif (udhcp_read_interface(client_config.interface,\n\t\t\t\t\t&client_config.ifindex,\n\t\t\t\t\tNULL,\n\t\t\t\t\tclient_config.client_mac)\n\t\t\t) {\n\t\t\t\tgoto ret0; /* iface is gone? */\n\t\t\t}\n\t\t\tif (clientid_mac_ptr)\n\t\t\t\tmemcpy(clientid_mac_ptr, client_config.client_mac, 6);\n\n\t\t\t/* We will restart the wait in any case */\n\t\t\talready_waited_sec = 0;\n\n\t\t\tswitch (state) {\n\t\t\tcase INIT_SELECTING:\n\t\t\t\tif (!discover_retries || packet_num < discover_retries) {\n\t\t\t\t\tif (packet_num == 0)\n\t\t\t\t\t\txid = random_xid();\n\t\t\t\t\t/* broadcast */\n\t\t\t\t\tsend_discover(xid, requested_ip);\n\t\t\t\t\ttimeout = discover_timeout;\n\t\t\t\t\tpacket_num++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n leasefail:\n\t\t\t\tudhcp_run_script(NULL, \"leasefail\");\n#if BB_MMU /* -b is not supported on NOMMU */\n\t\t\t\tif (opt & OPT_b) { /* background if no lease */\n\t\t\t\t\tbb_error_msg(\"no lease, forking to background\");\n\t\t\t\t\tclient_background();\n\t\t\t\t\t/* do not background again! */\n\t\t\t\t\topt = ((opt & ~OPT_b) | OPT_f);\n\t\t\t\t} else\n#endif\n\t\t\t\tif (opt & OPT_n) { /* abort if no lease */\n\t\t\t\t\tbb_error_msg(\"no lease, failing\");\n\t\t\t\t\tretval = 1;\n\t\t\t\t\tgoto ret;\n\t\t\t\t}\n\t\t\t\t/* wait before trying again */\n\t\t\t\ttimeout = tryagain_timeout;\n\t\t\t\tpacket_num = 0;\n\t\t\t\tcontinue;\n\t\t\tcase REQUESTING:\n\t\t\t\tif (packet_num < 3) {\n\t\t\t\t\t/* send broadcast select packet */\n\t\t\t\t\tsend_select(xid, server_addr, requested_ip);\n\t\t\t\t\ttimeout = discover_timeout;\n\t\t\t\t\tpacket_num++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* Timed out, go back to init state.\n\t\t\t\t * \"discover...select...discover...\" loops\n\t\t\t\t * were seen in the wild. Treat them similarly\n\t\t\t\t * to \"no response to discover\" case */\n\t\t\t\tchange_listen_mode(LISTEN_RAW);\n\t\t\t\tstate = INIT_SELECTING;\n\t\t\t\tgoto leasefail;\n\t\t\tcase BOUND:\n\t\t\t\t/* 1/2 lease passed, enter renewing state */\n\t\t\t\tstate = RENEWING;\n\t\t\t\tclient_config.first_secs = 0; /* make secs field count from 0 */\n\t\t\t\tchange_listen_mode(LISTEN_KERNEL);\n\t\t\t\tlog1(\"entering renew state\");\n\t\t\t\t/* fall right through */\n\t\t\tcase RENEW_REQUESTED: /* manual (SIGUSR1) renew */\n\t\t\tcase_RENEW_REQUESTED:\n\t\t\tcase RENEWING:\n\t\t\t\tif (timeout >= 60) {\n\t\t\t\t\t/* send an unicast renew request */\n\t\t\t/* Sometimes observed to fail (EADDRNOTAVAIL) to bind\n\t\t\t * a new UDP socket for sending inside send_renew.\n\t\t\t * I hazard to guess existing listening socket\n\t\t\t * is somehow conflicting with it, but why is it\n\t\t\t * not deterministic then?! Strange.\n\t\t\t * Anyway, it does recover by eventually failing through\n\t\t\t * into INIT_SELECTING state.\n\t\t\t */\n\t\t\t\t\tif (send_renew(xid, server_addr, requested_ip) >= 0) {\n\t\t\t\t\t\ttimeout >>= 1;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t/* else: error sending.\n\t\t\t\t\t * example: ENETUNREACH seen with server\n\t\t\t\t\t * which gave us bogus server ID 1.1.1.1\n\t\t\t\t\t * which wasn't reachable (and probably did not exist).\n\t\t\t\t\t */\n\t\t\t\t}\n\t\t\t\t/* Timed out or error, enter rebinding state */\n\t\t\t\tlog1(\"entering rebinding state\");\n\t\t\t\tstate = REBINDING;\n\t\t\t\t/* fall right through */\n\t\t\tcase REBINDING:\n\t\t\t\t/* Switch to bcast receive */\n\t\t\t\tchange_listen_mode(LISTEN_RAW);\n\t\t\t\t/* Lease is *really* about to run out,\n\t\t\t\t * try to find DHCP server using broadcast */\n\t\t\t\tif (timeout > 0) {\n\t\t\t\t\t/* send a broadcast renew request */\n\t\t\t\t\tsend_renew(xid, 0 /*INADDR_ANY*/, requested_ip);\n\t\t\t\t\ttimeout >>= 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* Timed out, enter init state */\n\t\t\t\tbb_error_msg(\"lease lost, entering init state\");\n\t\t\t\tudhcp_run_script(NULL, \"deconfig\");\n\t\t\t\tstate = INIT_SELECTING;\n\t\t\t\tclient_config.first_secs = 0; /* make secs field count from 0 */\n\t\t\t\t/*timeout = 0; - already is */\n\t\t\t\tpacket_num = 0;\n\t\t\t\tcontinue;\n\t\t\t/* case RELEASED: */\n\t\t\t}\n\t\t\t/* yah, I know, *you* say it would never happen */\n\t\t\ttimeout = INT_MAX;\n\t\t\tcontinue; /* back to main loop */\n\t\t} /* if poll timed out */\n\n\t\t/* poll() didn't timeout, something happened */\n\n\t\t/* Is it a signal? */\n\t\tswitch (udhcp_sp_read()) {\n\t\tcase SIGUSR1:\n\t\t\tclient_config.first_secs = 0; /* make secs field count from 0 */\n\t\t\talready_waited_sec = 0;\n\t\t\tperform_renew();\n\t\t\tif (state == RENEW_REQUESTED) {\n\t\t\t\t/* We might be either on the same network\n\t\t\t\t * (in which case renew might work),\n\t\t\t\t * or we might be on a completely different one\n\t\t\t\t * (in which case renew won't ever succeed).\n\t\t\t\t * For the second case, must make sure timeout\n\t\t\t\t * is not too big, or else we can send\n\t\t\t\t * futile renew requests for hours.\n\t\t\t\t */\n\t\t\t\tif (timeout > 60)\n\t\t\t\t\ttimeout = 60;\n\t\t\t\tgoto case_RENEW_REQUESTED;\n\t\t\t}\n\t\t\t/* Start things over */\n\t\t\tpacket_num = 0;\n\t\t\t/* Kill any timeouts, user wants this to hurry along */\n\t\t\ttimeout = 0;\n\t\t\tcontinue;\n\t\tcase SIGUSR2:\n\t\t\tperform_release(server_addr, requested_ip);\n\t\t\ttimeout = INT_MAX;\n\t\t\tcontinue;\n\t\tcase SIGTERM:\n\t\t\tbb_error_msg(\"received %s\", \"SIGTERM\");\n\t\t\tgoto ret0;\n\t\t}\n\n\t\t/* Is it a packet? */\n\t\tif (!pfds[1].revents)\n\t\t\tcontinue; /* no */\n\n\t\t{\n\t\t\tint len;\n\n\t\t\t/* A packet is ready, read it */\n\t\t\tif (listen_mode == LISTEN_KERNEL)\n\t\t\t\tlen = udhcp_recv_kernel_packet(&packet, sockfd);\n\t\t\telse\n\t\t\t\tlen = udhcp_recv_raw_packet(&packet, sockfd);\n\t\t\tif (len == -1) {\n\t\t\t\t/* Error is severe, reopen socket */\n\t\t\t\tbb_error_msg(\"read error: \"STRERROR_FMT\", reopening socket\" STRERROR_ERRNO);\n\t\t\t\tsleep(discover_timeout); /* 3 seconds by default */\n\t\t\t\tchange_listen_mode(listen_mode); /* just close and reopen */\n\t\t\t}\n\t\t\t/* If this packet will turn out to be unrelated/bogus,\n\t\t\t * we will go back and wait for next one.\n\t\t\t * Be sure timeout is properly decreased. */\n\t\t\talready_waited_sec += (unsigned)monotonic_sec() - timestamp_before_wait;\n\t\t\tif (len < 0)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (packet.xid != xid) {\n\t\t\tlog1(\"xid %x (our is %x), ignoring packet\",\n\t\t\t\t(unsigned)packet.xid, (unsigned)xid);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Ignore packets that aren't for us */\n\t\tif (packet.hlen != 6\n\t\t || memcmp(packet.chaddr, client_config.client_mac, 6) != 0\n\t\t) {\n\t\t\tlog1(\"chaddr does not match, ignoring packet\"); // log2?\n\t\t\tcontinue;\n\t\t}\n\n\t\tmessage = udhcp_get_option(&packet, DHCP_MESSAGE_TYPE);\n\t\tif (message == NULL) {\n\t\t\tbb_error_msg(\"no message type option, ignoring packet\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (state) {\n\t\tcase INIT_SELECTING:\n\t\t\t/* Must be a DHCPOFFER */\n\t\t\tif (*message == DHCPOFFER) {\n\t\t\t\tuint8_t *temp;\n\n/* What exactly is server's IP? There are several values.\n * Example DHCP offer captured with tchdump:\n *\n * 10.34.25.254:67 > 10.34.25.202:68 // IP header's src\n * BOOTP fields:\n * Your-IP 10.34.25.202\n * Server-IP 10.34.32.125   // \"next server\" IP\n * Gateway-IP 10.34.25.254  // relay's address (if DHCP relays are in use)\n * DHCP options:\n * DHCP-Message Option 53, length 1: Offer\n * Server-ID Option 54, length 4: 10.34.255.7       // \"server ID\"\n * Default-Gateway Option 3, length 4: 10.34.25.254 // router\n *\n * We think that real server IP (one to use in renew/release)\n * is one in Server-ID option. But I am not 100% sure.\n * IP header's src and Gateway-IP (same in this example)\n * might work too.\n * \"Next server\" and router are definitely wrong ones to use, though...\n */\n/* We used to ignore pcakets without DHCP_SERVER_ID.\n * I've got user reports from people who run \"address-less\" servers.\n * They either supply DHCP_SERVER_ID of 0.0.0.0 or don't supply it at all.\n  * They say ISC DHCP client supports this case.\n  */\n \t\t\t\tserver_addr = 0;\n\t\t\t\ttemp = udhcp_get_option(&packet, DHCP_SERVER_ID);\n \t\t\t\tif (!temp) {\n \t\t\t\t\tbb_error_msg(\"no server ID, using 0.0.0.0\");\n \t\t\t\t} else {\n\t\t\t\t\t/* it IS unaligned sometimes, don't \"optimize\" */\n\t\t\t\t\tmove_from_unaligned32(server_addr, temp);\n\t\t\t\t}\n\t\t\t\t/*xid = packet.xid; - already is */\n\t\t\t\trequested_ip = packet.yiaddr;\n\n\t\t\t\t/* enter requesting state */\n\t\t\t\tstate = REQUESTING;\n\t\t\t\ttimeout = 0;\n\t\t\t\tpacket_num = 0;\n\t\t\t\talready_waited_sec = 0;\n\t\t\t}\n\t\t\tcontinue;\n\t\tcase REQUESTING:\n\t\tcase RENEWING:\n\t\tcase RENEW_REQUESTED:\n\t\tcase REBINDING:\n\t\t\tif (*message == DHCPACK) {\n\t\t\t\tunsigned start;\n\t\t\t\tuint32_t lease_seconds;\n \t\t\t\tstruct in_addr temp_addr;\n \t\t\t\tuint8_t *temp;\n \n\t\t\t\ttemp = udhcp_get_option(&packet, DHCP_LEASE_TIME);\n \t\t\t\tif (!temp) {\n \t\t\t\t\tbb_error_msg(\"no lease time with ACK, using 1 hour lease\");\n \t\t\t\t\tlease_seconds = 60 * 60;\n\t\t\t\t} else {\n\t\t\t\t\t/* it IS unaligned sometimes, don't \"optimize\" */\n\t\t\t\t\tmove_from_unaligned32(lease_seconds, temp);\n\t\t\t\t\tlease_seconds = ntohl(lease_seconds);\n\t\t\t\t\t/* paranoia: must not be too small and not prone to overflows */\n\t\t\t\t\t/* timeout > 60 - ensures at least one unicast renew attempt */\n\t\t\t\t\tif (lease_seconds < 2 * 61)\n\t\t\t\t\t\tlease_seconds = 2 * 61;\n\t\t\t\t}\n#if ENABLE_FEATURE_UDHCPC_ARPING\n\t\t\t\tif (opt & OPT_a) {\n/* RFC 2131 3.1 paragraph 5:\n * \"The client receives the DHCPACK message with configuration\n * parameters. The client SHOULD perform a final check on the\n * parameters (e.g., ARP for allocated network address), and notes\n * the duration of the lease specified in the DHCPACK message. At this\n * point, the client is configured. If the client detects that the\n * address is already in use (e.g., through the use of ARP),\n * the client MUST send a DHCPDECLINE message to the server and restarts\n * the configuration process...\" */\n\t\t\t\t\tif (!arpping(packet.yiaddr,\n\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t(uint32_t) 0,\n\t\t\t\t\t\t\tclient_config.client_mac,\n\t\t\t\t\t\t\tclient_config.interface,\n\t\t\t\t\t\t\tarpping_ms)\n\t\t\t\t\t) {\n\t\t\t\t\t\tbb_error_msg(\"offered address is in use \"\n\t\t\t\t\t\t\t\"(got ARP reply), declining\");\n\t\t\t\t\t\tsend_decline(/*xid,*/ server_addr, packet.yiaddr);\n\n\t\t\t\t\t\tif (state != REQUESTING)\n\t\t\t\t\t\t\tudhcp_run_script(NULL, \"deconfig\");\n\t\t\t\t\t\tchange_listen_mode(LISTEN_RAW);\n\t\t\t\t\t\tstate = INIT_SELECTING;\n\t\t\t\t\t\tclient_config.first_secs = 0; /* make secs field count from 0 */\n\t\t\t\t\t\trequested_ip = 0;\n\t\t\t\t\t\ttimeout = tryagain_timeout;\n\t\t\t\t\t\tpacket_num = 0;\n\t\t\t\t\t\talready_waited_sec = 0;\n\t\t\t\t\t\tcontinue; /* back to main loop */\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t\t/* enter bound state */\n\t\t\t\ttemp_addr.s_addr = packet.yiaddr;\n\t\t\t\tbb_error_msg(\"lease of %s obtained, lease time %u\",\n\t\t\t\t\tinet_ntoa(temp_addr), (unsigned)lease_seconds);\n\t\t\t\trequested_ip = packet.yiaddr;\n\n\t\t\t\tstart = monotonic_sec();\n\t\t\t\tudhcp_run_script(&packet, state == REQUESTING ? \"bound\" : \"renew\");\n\t\t\t\talready_waited_sec = (unsigned)monotonic_sec() - start;\n\t\t\t\ttimeout = lease_seconds / 2;\n\t\t\t\tif ((unsigned)timeout < already_waited_sec) {\n\t\t\t\t\t/* Something went wrong. Back to discover state */\n\t\t\t\t\ttimeout = already_waited_sec = 0;\n\t\t\t\t}\n\n\t\t\t\tstate = BOUND;\n\t\t\t\tchange_listen_mode(LISTEN_NONE);\n\t\t\t\tif (opt & OPT_q) { /* quit after lease */\n\t\t\t\t\tgoto ret0;\n\t\t\t\t}\n\t\t\t\t/* future renew failures should not exit (JM) */\n\t\t\t\topt &= ~OPT_n;\n#if BB_MMU /* NOMMU case backgrounded earlier */\n\t\t\t\tif (!(opt & OPT_f)) {\n\t\t\t\t\tclient_background();\n\t\t\t\t\t/* do not background again! */\n\t\t\t\t\topt = ((opt & ~OPT_b) | OPT_f);\n\t\t\t\t}\n#endif\n\t\t\t\t/* make future renew packets use different xid */\n\t\t\t\t/* xid = random_xid(); ...but why bother? */\n\n\t\t\t\tcontinue; /* back to main loop */\n\t\t\t}\n\t\t\tif (*message == DHCPNAK) {\n\t\t\t\t/* If network has more than one DHCP server,\n\t\t\t\t * \"wrong\" server can reply first, with a NAK.\n\t\t\t\t * Do not interpret it as a NAK from \"our\" server.\n\t\t\t\t */\n\t\t\t\tif (server_addr != 0) {\n \t\t\t\t\tuint32_t svid;\n \t\t\t\t\tuint8_t *temp;\n \n\t\t\t\t\ttemp = udhcp_get_option(&packet, DHCP_SERVER_ID);\n \t\t\t\t\tif (!temp) {\n  non_matching_svid:\n \t\t\t\t\t\tlog1(\"received DHCP NAK with wrong\"\n\t\t\t\t\t\t\t\" server ID, ignoring packet\");\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tmove_from_unaligned32(svid, temp);\n\t\t\t\t\tif (svid != server_addr)\n\t\t\t\t\t\tgoto non_matching_svid;\n\t\t\t\t}\n\t\t\t\t/* return to init state */\n\t\t\t\tbb_error_msg(\"received %s\", \"DHCP NAK\");\n\t\t\t\tudhcp_run_script(&packet, \"nak\");\n\t\t\t\tif (state != REQUESTING)\n\t\t\t\t\tudhcp_run_script(NULL, \"deconfig\");\n\t\t\t\tchange_listen_mode(LISTEN_RAW);\n\t\t\t\tsleep(3); /* avoid excessive network traffic */\n\t\t\t\tstate = INIT_SELECTING;\n\t\t\t\tclient_config.first_secs = 0; /* make secs field count from 0 */\n\t\t\t\trequested_ip = 0;\n\t\t\t\ttimeout = 0;\n\t\t\t\tpacket_num = 0;\n\t\t\t\talready_waited_sec = 0;\n\t\t\t}\n\t\t\tcontinue;\n\t\t/* case BOUND: - ignore all packets */\n\t\t/* case RELEASED: - ignore all packets */\n\t\t}\n\t\t/* back to main loop */\n\t} /* for (;;) - main loop ends */\n\n ret0:\n\tif (opt & OPT_R) /* release on quit */\n\t\tperform_release(server_addr, requested_ip);\n\tretval = 0;\n ret:\n\t/*if (client_config.pidfile) - remove_pidfile has its own check */\n\t\tremove_pidfile(client_config.pidfile);\n\treturn retval;\n}\n", "target": 1, "idx": 178396}
{"func": "void PDFiumEngine::OnDocumentComplete() {\n  if (!doc_ || !form_) {\n    file_access_.m_FileLen = doc_loader_.document_size();\n    if (!fpdf_availability_) {\n      fpdf_availability_ = FPDFAvail_Create(&file_availability_, &file_access_);\n      DCHECK(fpdf_availability_);\n    }\n    LoadDocument();\n    return;\n  }\n\n  FinishLoadingDocument();\n}\n", "target": 0, "idx": 153071}
{"func": "RenderThreadImpl::HostAllocateSharedMemoryBuffer(size_t size) {\n  return ChildThreadImpl::AllocateSharedMemory(size);\n}\n", "target": 0, "idx": 163345}
{"func": " static void sas_scsi_clear_queue_lu(struct list_head *error_q, struct scsi_cmnd *my_cmd)\n {\n \tstruct scsi_cmnd *cmd, *n;\n \n \tlist_for_each_entry_safe(cmd, n, error_q, eh_entry) {\n \t\tif (cmd->device->sdev_target == my_cmd->device->sdev_target &&\n \t\t    cmd->device->lun == my_cmd->device->lun)\n\t\t\tsas_eh_defer_cmd(cmd);\n \t}\n }\n", "target": 1, "idx": 182435}
{"func": "bool BrowserView::HasClientEdge() const {\n  return frame()->GetFrameView()->HasClientEdge();\n}\n", "target": 0, "idx": 168299}
{"func": "void WebPluginDelegateProxy::Paint(WebKit::WebCanvas* canvas,\n                                   const gfx::Rect& damaged_rect) {\n  gfx::Rect rect = damaged_rect.Intersect(plugin_rect_);\n\n  if (!channel_host_ || !channel_host_->channel_valid()) {\n    PaintSadPlugin(canvas, rect);\n    return;\n  }\n\n  if (!uses_shared_bitmaps_)\n    return;\n\n  if (!front_buffer_canvas())\n    return;\n\n#if WEBKIT_USING_SKIA\n  if (!skia::SupportsPlatformPaint(canvas)) {\n    DLOG(WARNING) << \"Could not paint plugin\";\n    return;\n  }\n  skia::ScopedPlatformPaint scoped_platform_paint(canvas);\n  gfx::NativeDrawingContext context =\n      scoped_platform_paint.GetPlatformSurface();\n#elif WEBKIT_USING_CG\n  gfx::NativeDrawingContext context = canvas;\n#endif\n\n  gfx::Rect offset_rect = rect;\n  offset_rect.Offset(-plugin_rect_.x(), -plugin_rect_.y());\n  gfx::Rect canvas_rect = offset_rect;\n#if defined(OS_MACOSX)\n  FlipRectVerticallyWithHeight(&canvas_rect, plugin_rect_.height());\n#endif\n\n  bool background_changed = false;\n  if (background_store_.canvas.get() && BackgroundChanged(context, rect)) {\n    background_changed = true;\n    BlitContextToCanvas(background_store_.canvas.get(), canvas_rect,\n                        context, rect.origin());\n  }\n\n  if (background_changed ||\n      !transport_store_painted_.Contains(offset_rect)) {\n    Send(new PluginMsg_Paint(instance_id_, offset_rect));\n    UpdateFrontBuffer(offset_rect, false);\n  }\n\n#if defined(OS_MACOSX)\n  CGContextSaveGState(context);\n  CGContextScaleCTM(context, 1, -1);\n  rect.set_y(-rect.bottom());\n#endif\n  BlitCanvasToContext(context,\n                      rect,\n                      front_buffer_canvas(),\n                      offset_rect.origin());\n#if defined(OS_MACOSX)\n  CGContextRestoreGState(context);\n#endif\n\n  if (invalidate_pending_) {\n    invalidate_pending_ = false;\n    Send(new PluginMsg_DidPaint(instance_id_));\n  }\n}\n", "target": 0, "idx": 114647}
{"func": "int send_event (int fd, uint16_t type, uint16_t code, int32_t value)\n{\n struct uinput_event event;\n    BTIF_TRACE_DEBUG(\"%s type:%u code:%u value:%d\", __FUNCTION__,\n        type, code, value);\n    memset(&event, 0, sizeof(event));\n    event.type  = type;\n\n     event.code  = code;\n     event.value = value;\n \n    return write(fd, &event, sizeof(event));\n }\n", "target": 1, "idx": 187473}
{"func": "bool FlagsState::IsRestartNeededToCommitChanges() {\n  return needs_restart_;\n}\n", "target": 0, "idx": 111764}
{"func": "make_error(png_store* volatile psIn, png_byte PNG_CONST colour_type,\n     png_byte bit_depth, int interlace_type, int test, png_const_charp name)\n {\n   png_store * volatile ps = psIn;\n    context(ps, fault);\n \n    check_interlace_type(interlace_type);\n \n    Try\n    {\n      png_structp pp;\n       png_infop pi;\n      pp = set_store_for_write(ps, &pi, name);\n \n       if (pp == NULL)\n          Throw ps;\n \n      png_set_IHDR(pp, pi, transform_width(pp, colour_type, bit_depth),\n         transform_height(pp, colour_type, bit_depth), bit_depth, colour_type,\n         interlace_type, PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);\n \n       if (colour_type == 3) /* palette */\n          init_standard_palette(ps, pp, pi, 1U << bit_depth, 0/*do tRNS*/);\n\n /* Time for a few errors; these are in various optional chunks, the\n       * standard tests test the standard chunks pretty well.\n       */\n#     define exception__prev exception_prev_1\n\n #     define exception__env exception_env_1\n       Try\n       {\n          /* Expect this to throw: */\n          ps->expect_error = !error_test[test].warning;\n          ps->expect_warning = error_test[test].warning;\n         ps->saw_warning = 0;\n         error_test[test].fn(pp, pi);\n\n /* Normally the error is only detected here: */\n         png_write_info(pp, pi);\n\n /* And handle the case where it was only a warning: */\n if (ps->expect_warning && ps->saw_warning)\n Throw ps;\n\n /* If we get here there is a problem, we have success - no error or\n          * no warning - when we shouldn't have success.  Log an error.\n          */\n         store_log(ps, pp, error_test[test].msg, 1 /*error*/);\n\n       }\n \n       Catch (fault)\n         ps = fault; /* expected exit, make sure ps is not clobbered */\n #undef exception__prev\n #undef exception__env\n \n /* And clear these flags */\n      ps->expect_error = 0;\n      ps->expect_warning = 0;\n\n /* Now write the whole image, just to make sure that the detected, or\n       * undetected, errro has not created problems inside libpng.\n       */\n if (png_get_rowbytes(pp, pi) !=\n          transform_rowsize(pp, colour_type, bit_depth))\n         png_error(pp, \"row size incorrect\");\n\n \n       else\n       {\n         png_uint_32 h = transform_height(pp, colour_type, bit_depth);\n         int npasses = png_set_interlace_handling(pp);\n          int pass;\n \n          if (npasses != npasses_from_interlace_type(pp, interlace_type))\n            png_error(pp, \"write: png_set_interlace_handling failed\");\n\n for (pass=0; pass<npasses; ++pass)\n {\n            png_uint_32 y;\n\n for (y=0; y<h; ++y)\n {\n\n                png_byte buffer[TRANSFORM_ROWMAX];\n \n                transform_row(pp, buffer, colour_type, bit_depth, y);\n                png_write_row(pp, buffer);\n             }\n          }\n }\n\n      png_write_end(pp, pi);\n\n /* The following deletes the file that was just written. */\n      store_write_reset(ps);\n }\n\n Catch(fault)\n {\n      store_write_reset(fault);\n }\n\n }\n", "target": 1, "idx": 187683}
{"func": "static const char *func_id_name(int id)\n{\n\tBUILD_BUG_ON(ARRAY_SIZE(func_id_str) != __BPF_FUNC_MAX_ID);\n\n\tif (id >= 0 && id < __BPF_FUNC_MAX_ID && func_id_str[id])\n\t\treturn func_id_str[id];\n\telse\n\t\treturn \"unknown\";\n}\n", "target": 0, "idx": 65062}
{"func": "static MagickBooleanType OpenPixelCache(Image *image,const MapMode mode,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info,\n    source_info;\n\n  char\n    format[MagickPathExtent],\n    message[MagickPathExtent];\n\n  const char\n    *type;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    length,\n    number_pixels;\n\n  size_t\n    columns,\n    packet_size;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if ((image->columns == 0) || (image->rows == 0))\n    ThrowBinaryException(CacheError,\"NoPixelsDefinedInCache\",image->filename);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  if ((AcquireMagickResource(WidthResource,image->columns) == MagickFalse) ||\n      (AcquireMagickResource(HeightResource,image->rows) == MagickFalse))\n    ThrowBinaryException(ImageError,\"WidthOrHeightExceedsLimit\",\n      image->filename);\n  source_info=(*cache_info);\n  source_info.file=(-1);\n  (void) FormatLocaleString(cache_info->filename,MagickPathExtent,\"%s[%.20g]\",\n    image->filename,(double) GetImageIndexInList(image));\n  cache_info->storage_class=image->storage_class;\n  cache_info->colorspace=image->colorspace;\n  cache_info->alpha_trait=image->alpha_trait;\n  cache_info->read_mask=image->read_mask;\n  cache_info->write_mask=image->write_mask;\n  cache_info->rows=image->rows;\n  cache_info->columns=image->columns;\n  InitializePixelChannelMap(image);\n  cache_info->number_channels=GetPixelChannels(image);\n  (void) memcpy(cache_info->channel_map,image->channel_map,MaxPixelChannels*\n    sizeof(*image->channel_map));\n  cache_info->metacontent_extent=image->metacontent_extent;\n  cache_info->mode=mode;\n  number_pixels=(MagickSizeType) cache_info->columns*cache_info->rows;\n  packet_size=cache_info->number_channels*sizeof(Quantum);\n  if (image->metacontent_extent != 0)\n    packet_size+=cache_info->metacontent_extent;\n  length=number_pixels*packet_size;\n  columns=(size_t) (length/cache_info->rows/packet_size);\n  if ((cache_info->columns != columns) || ((ssize_t) cache_info->columns < 0) ||\n      ((ssize_t) cache_info->rows < 0))\n    ThrowBinaryException(ResourceLimitError,\"PixelCacheAllocationFailed\",\n      image->filename);\n  cache_info->length=length;\n  if (image->ping != MagickFalse)\n    {\n      cache_info->storage_class=image->storage_class;\n      cache_info->colorspace=image->colorspace;\n      cache_info->type=PingCache;\n      return(MagickTrue);\n    }\n  status=AcquireMagickResource(AreaResource,cache_info->length);\n  length=number_pixels*(cache_info->number_channels*sizeof(Quantum)+\n    cache_info->metacontent_extent);\n  if ((status != MagickFalse) && (length == (MagickSizeType) ((size_t) length)))\n    {\n      status=AcquireMagickResource(MemoryResource,cache_info->length);\n      if (((cache_info->type == UndefinedCache) && (status != MagickFalse)) ||\n          (cache_info->type == MemoryCache))\n        {\n          cache_info->mapped=MagickFalse;\n          cache_info->pixels=(Quantum *) MagickAssumeAligned(\n            AcquireAlignedMemory(1,(size_t) cache_info->length));\n          if (cache_info->pixels == (Quantum *) NULL)\n            cache_info->pixels=source_info.pixels;\n          else\n            {\n              /*\n                Create memory pixel cache.\n              */\n              status=MagickTrue;\n              cache_info->type=MemoryCache;\n              cache_info->metacontent=(void *) NULL;\n              if (cache_info->metacontent_extent != 0)\n                cache_info->metacontent=(void *) (cache_info->pixels+\n                  number_pixels*cache_info->number_channels);\n              if ((source_info.storage_class != UndefinedClass) &&\n                  (mode != ReadMode))\n                {\n                  status=ClonePixelCacheRepository(cache_info,&source_info,\n                    exception);\n                  RelinquishPixelCachePixels(&source_info);\n                }\n              if (image->debug != MagickFalse)\n                {\n                  (void) FormatMagickSize(cache_info->length,MagickTrue,\"B\",\n                    MagickPathExtent,format);\n                  type=CommandOptionToMnemonic(MagickCacheOptions,(ssize_t)\n                    cache_info->type);\n                  (void) FormatLocaleString(message,MagickPathExtent,\n                    \"open %s (%s %s, %.20gx%.20gx%.20g %s)\",\n                    cache_info->filename,cache_info->mapped != MagickFalse ?\n                    \"Anonymous\" : \"Heap\",type,(double) cache_info->columns,\n                    (double) cache_info->rows,(double)\n                    cache_info->number_channels,format);\n                  (void) LogMagickEvent(CacheEvent,GetMagickModule(),\"%s\",\n                    message);\n                }\n              return(status);\n            }\n        }\n      RelinquishMagickResource(MemoryResource,cache_info->length);\n    }\n  /*\n    Create pixel cache on disk.\n  */\n  status=AcquireMagickResource(DiskResource,cache_info->length);\n  if ((status == MagickFalse) || (cache_info->type == DistributedCache))\n    {\n      DistributeCacheInfo\n        *server_info;\n\n      if (cache_info->type == DistributedCache)\n        RelinquishMagickResource(DiskResource,cache_info->length);\n      server_info=AcquireDistributeCacheInfo(exception);\n      if (server_info != (DistributeCacheInfo *) NULL)\n        {\n          status=OpenDistributePixelCache(server_info,image);\n          if (status == MagickFalse)\n            {\n              ThrowFileException(exception,CacheError,\"UnableToOpenPixelCache\",\n                GetDistributeCacheHostname(server_info));\n              server_info=DestroyDistributeCacheInfo(server_info);\n            }\n          else\n            {\n              /*\n                Create a distributed pixel cache.\n              */\n              cache_info->type=DistributedCache;\n              cache_info->server_info=server_info;\n              (void) FormatLocaleString(cache_info->cache_filename,\n                MagickPathExtent,\"%s:%d\",GetDistributeCacheHostname(\n                (DistributeCacheInfo *) cache_info->server_info),\n                GetDistributeCachePort((DistributeCacheInfo *)\n                cache_info->server_info));\n              if ((source_info.storage_class != UndefinedClass) &&\n                  (mode != ReadMode))\n                {\n                  status=ClonePixelCacheRepository(cache_info,&source_info,\n                    exception);\n                  RelinquishPixelCachePixels(&source_info);\n                }\n              if (image->debug != MagickFalse)\n                {\n                  (void) FormatMagickSize(cache_info->length,MagickFalse,\"B\",\n                    MagickPathExtent,format);\n                  type=CommandOptionToMnemonic(MagickCacheOptions,(ssize_t)\n                    cache_info->type);\n                  (void) FormatLocaleString(message,MagickPathExtent,\n                    \"open %s (%s[%d], %s, %.20gx%.20gx%.20g %s)\",\n                    cache_info->filename,cache_info->cache_filename,\n                    GetDistributeCacheFile((DistributeCacheInfo *)\n                    cache_info->server_info),type,(double) cache_info->columns,\n                    (double) cache_info->rows,(double)\n                    cache_info->number_channels,format);\n                  (void) LogMagickEvent(CacheEvent,GetMagickModule(),\"%s\",\n                    message);\n                }\n              return(MagickTrue);\n             }\n         }\n       RelinquishMagickResource(DiskResource,cache_info->length);\n       (void) ThrowMagickException(exception,GetMagickModule(),CacheError,\n         \"CacheResourcesExhausted\",\"`%s'\",image->filename);\n       return(MagickFalse);\n    }\n  if ((source_info.storage_class != UndefinedClass) && (mode != ReadMode))\n    {\n      (void) ClosePixelCacheOnDisk(cache_info);\n      *cache_info->cache_filename='\\0';\n    }\n   if (OpenPixelCacheOnDisk(cache_info,mode) == MagickFalse)\n     {\n       RelinquishMagickResource(DiskResource,cache_info->length);\n       ThrowFileException(exception,CacheError,\"UnableToOpenPixelCache\",\n         image->filename);\n       return(MagickFalse);\n    }\n  status=SetPixelCacheExtent(image,(MagickSizeType) cache_info->offset+\n     cache_info->length);\n   if (status == MagickFalse)\n     {\n       ThrowFileException(exception,CacheError,\"UnableToExtendCache\",\n         image->filename);\n       return(MagickFalse);\n    }\n  length=number_pixels*(cache_info->number_channels*sizeof(Quantum)+\n    cache_info->metacontent_extent);\n  if (length != (MagickSizeType) ((size_t) length))\n    cache_info->type=DiskCache;\n  else\n    {\n      status=AcquireMagickResource(MapResource,cache_info->length);\n      if ((status == MagickFalse) && (cache_info->type != MapCache) &&\n          (cache_info->type != MemoryCache))\n        cache_info->type=DiskCache;\n      else\n        {\n          cache_info->pixels=(Quantum *) MapBlob(cache_info->file,mode,\n            cache_info->offset,(size_t) cache_info->length);\n          if (cache_info->pixels == (Quantum *) NULL)\n            {\n              cache_info->type=DiskCache;\n              cache_info->pixels=source_info.pixels;\n            }\n          else\n            {\n              /*\n                Create file-backed memory-mapped pixel cache.\n              */\n              status=MagickTrue;\n              (void) ClosePixelCacheOnDisk(cache_info);\n              cache_info->type=MapCache;\n              cache_info->mapped=MagickTrue;\n              cache_info->metacontent=(void *) NULL;\n              if (cache_info->metacontent_extent != 0)\n                cache_info->metacontent=(void *) (cache_info->pixels+\n                  number_pixels*cache_info->number_channels);\n              if ((source_info.storage_class != UndefinedClass) &&\n                  (mode != ReadMode))\n                {\n                  status=ClonePixelCacheRepository(cache_info,&source_info,\n                    exception);\n                  RelinquishPixelCachePixels(&source_info);\n                }\n              if (image->debug != MagickFalse)\n                {\n                  (void) FormatMagickSize(cache_info->length,MagickTrue,\"B\",\n                    MagickPathExtent,format);\n                  type=CommandOptionToMnemonic(MagickCacheOptions,(ssize_t)\n                    cache_info->type);\n                  (void) FormatLocaleString(message,MagickPathExtent,\n                    \"open %s (%s[%d], %s, %.20gx%.20gx%.20g %s)\",\n                    cache_info->filename,cache_info->cache_filename,\n                    cache_info->file,type,(double) cache_info->columns,(double)\n                    cache_info->rows,(double) cache_info->number_channels,\n                    format);\n                   (void) LogMagickEvent(CacheEvent,GetMagickModule(),\"%s\",\n                     message);\n                 }\n               return(status);\n             }\n         }\n      RelinquishMagickResource(MapResource,cache_info->length);\n    }\n  status=MagickTrue;\n  if ((source_info.storage_class != UndefinedClass) && (mode != ReadMode))\n    {\n      status=ClonePixelCacheRepository(cache_info,&source_info,exception);\n      RelinquishPixelCachePixels(&source_info);\n    }\n  if (image->debug != MagickFalse)\n    {\n      (void) FormatMagickSize(cache_info->length,MagickFalse,\"B\",\n        MagickPathExtent,format);\n      type=CommandOptionToMnemonic(MagickCacheOptions,(ssize_t)\n        cache_info->type);\n      (void) FormatLocaleString(message,MagickPathExtent,\n        \"open %s (%s[%d], %s, %.20gx%.20gx%.20g %s)\",cache_info->filename,\n        cache_info->cache_filename,cache_info->file,type,(double)\n        cache_info->columns,(double) cache_info->rows,(double)\n         cache_info->number_channels,format);\n       (void) LogMagickEvent(CacheEvent,GetMagickModule(),\"%s\",message);\n     }\n   return(status);\n }\n", "target": 1, "idx": 183131}
{"func": "void BackendImpl::CleanupCache() {\n  DCHECK(background_queue_.BackgroundIsCurrentSequence());\n  Trace(\"Backend Cleanup\");\n  eviction_.Stop();\n  timer_.reset();\n\n  if (init_) {\n    StoreStats();\n    if (data_)\n      data_->header.crash = 0;\n\n    if (user_flags_ & kNoRandom) {\n      File::WaitForPendingIO(&num_pending_io_);\n      DCHECK(!num_refs_);\n    } else {\n      File::DropPendingIO();\n    }\n  }\n  block_files_.CloseFiles();\n  FlushIndex();\n  index_ = NULL;\n  ptr_factory_.InvalidateWeakPtrs();\n  done_.Signal();\n}\n", "target": 0, "idx": 160010}
{"func": "xmlFatalErrMsg(xmlParserCtxtPtr ctxt, xmlParserErrors error,\n const char *msg)\n{\n if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&\n (ctxt->instate == XML_PARSER_EOF))\n return;\n if (ctxt != NULL)\n\tctxt->errNo = error;\n    __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,\n                    XML_ERR_FATAL, NULL, 0, NULL, NULL, NULL, 0, 0, \"%s\", msg);\n if (ctxt != NULL) {\n\tctxt->wellFormed = 0;\n if (ctxt->recovery == 0)\n\t    ctxt->disableSAX = 1;\n }\n}\n", "target": 0, "idx": 176584}
{"func": "bool  PrintWebViewHelper::PrintPreviewContext::IsFinalPageRendered() const {\n  return static_cast<size_t>(current_page_index_) == pages_to_render_.size();\n}\n", "target": 0, "idx": 101962}
{"func": "  virtual void TabMoved(\n      TabContentsWrapper* contents, int from_index, int to_index) {\n    State* s = new State(contents, to_index, MOVE);\n    s->src_index = from_index;\n    states_.push_back(s);\n  }\n", "target": 0, "idx": 103055}
{"func": "static void disk_seqf_stop(struct seq_file *seqf, void *v)\n{\n\tstruct class_dev_iter *iter = seqf->private;\n\n\t/* stop is called even after start failed :-( */\n \tif (iter) {\n \t\tclass_dev_iter_exit(iter);\n \t\tkfree(iter);\n \t}\n }\n", "target": 1, "idx": 180098}
{"func": "static u8 vhost_scsi_get_fabric_proto_ident(struct se_portal_group *se_tpg)\n{\n\tstruct vhost_scsi_tpg *tpg = container_of(se_tpg,\n\t\t\t\tstruct vhost_scsi_tpg, se_tpg);\n\tstruct vhost_scsi_tport *tport = tpg->tport;\n\n\tswitch (tport->tport_proto_id) {\n\tcase SCSI_PROTOCOL_SAS:\n\t\treturn sas_get_fabric_proto_ident(se_tpg);\n\tcase SCSI_PROTOCOL_FCP:\n\t\treturn fc_get_fabric_proto_ident(se_tpg);\n\tcase SCSI_PROTOCOL_ISCSI:\n\t\treturn iscsi_get_fabric_proto_ident(se_tpg);\n\tdefault:\n\t\tpr_err(\"Unknown tport_proto_id: 0x%02x, using\"\n\t\t\t\" SAS emulation\\n\", tport->tport_proto_id);\n\t\tbreak;\n\t}\n\n\treturn sas_get_fabric_proto_ident(se_tpg);\n}\n", "target": 0, "idx": 43097}
{"func": "int dns_packet_is_reply_for(DnsPacket *p, const DnsResourceKey *key) {\n        int r;\n\n        assert(p);\n        assert(key);\n\n        /* Checks if the specified packet is a reply for the specified\n         * key and the specified key is the only one in the question\n         * section. */\n\n        if (DNS_PACKET_QR(p) != 1)\n                return 0;\n\n        /* Let's unpack the packet, if that hasn't happened yet. */\n        r = dns_packet_extract(p);\n         if (r < 0)\n                 return r;\n \n         if (p->question->n_keys != 1)\n                 return 0;\n \n        return dns_resource_key_equal(p->question->keys[0], key);\n}\n", "target": 1, "idx": 181283}
{"func": "ZEND_API int zend_declare_property_double(zend_class_entry *ce, const char *name, int name_length, double value, int access_type TSRMLS_DC) /* {{{ */\n{\n\tzval *property;\n\n\tif (ce->type & ZEND_INTERNAL_CLASS) {\n\t\tALLOC_PERMANENT_ZVAL(property);\n\t} else {\n\t\tALLOC_ZVAL(property);\n\t}\n\tINIT_PZVAL(property);\n\tZVAL_DOUBLE(property, value);\n\treturn zend_declare_property(ce, name, name_length, property, access_type TSRMLS_CC);\n}\n/* }}} */\n", "target": 0, "idx": 13782}
{"func": "void __init proc_caches_init(void)\n{\n\tsighand_cachep = kmem_cache_create(\"sighand_cache\",\n\t\t\tsizeof(struct sighand_struct), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_DESTROY_BY_RCU|\n\t\t\tSLAB_NOTRACK, sighand_ctor);\n\tsignal_cachep = kmem_cache_create(\"signal_cache\",\n\t\t\tsizeof(struct signal_struct), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_NOTRACK, NULL);\n\tfiles_cachep = kmem_cache_create(\"files_cache\",\n\t\t\tsizeof(struct files_struct), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_NOTRACK, NULL);\n\tfs_cachep = kmem_cache_create(\"fs_cache\",\n\t\t\tsizeof(struct fs_struct), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_NOTRACK, NULL);\n\tmm_cachep = kmem_cache_create(\"mm_struct\",\n\t\t\tsizeof(struct mm_struct), ARCH_MIN_MMSTRUCT_ALIGN,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_NOTRACK, NULL);\n\tvm_area_cachep = KMEM_CACHE(vm_area_struct, SLAB_PANIC);\n\tmmap_init();\n}\n", "target": 0, "idx": 22279}
{"func": "void mon_st_callback(stonith_t *st, stonith_event_t *e)\n{\n    char *desc = g_strdup_printf(\n        \"Operation %s requested by %s for peer %s: %s (ref=%s)\",\n        e->operation, e->origin, e->target, pcmk_strerror(e->result), e->id); \n\n    if (snmp_target) {\n        send_snmp_trap(e->target, NULL, e->operation, pcmk_ok, e->result, 0, desc);\n    }\n    if (crm_mail_to) {\n        send_smtp_trap(e->target, NULL, e->operation, pcmk_ok, e->result, 0, desc);\n    }\n    if (external_agent) {\n        send_custom_trap(e->target, NULL, e->operation, pcmk_ok, e->result, 0, desc);\n    }\n    g_free(desc);\n}\n", "target": 0, "idx": 33943}
{"func": "LayoutUnit RenderFlexibleBox::crossAxisExtentForChild(RenderBox* child) const\n{\n    return isHorizontalFlow() ? child->height() : child->width();\n}\n", "target": 0, "idx": 125001}
{"func": "void GLSurfaceOzoneSurfacelessSurfaceImpl::Destroy() {\n  if (!context_)\n    return;\n  scoped_refptr<gfx::GLContext> previous_context = gfx::GLContext::GetCurrent();\n  scoped_refptr<gfx::GLSurface> previous_surface;\n\n  bool was_current = previous_context && previous_context->IsCurrent(nullptr) &&\n                     gfx::GLSurface::GetCurrent() == this;\n  if (!was_current) {\n    previous_surface = gfx::GLSurface::GetCurrent();\n    context_->MakeCurrent(this);\n  }\n\n  glBindFramebufferEXT(GL_FRAMEBUFFER, 0);\n  if (fbo_) {\n    glDeleteTextures(arraysize(textures_), textures_);\n    for (auto& texture : textures_)\n      texture = 0;\n    glDeleteFramebuffersEXT(1, &fbo_);\n    fbo_ = 0;\n  }\n  for (auto image : images_) {\n    if (image)\n      image->Destroy(true);\n   }\n \n   if (!was_current) {\n    previous_context->MakeCurrent(previous_surface.get());\n  } else {\n    context_->ReleaseCurrent(this);\n   }\n }\n", "target": 1, "idx": 185352}
{"func": "static struct sock *dccp_v6_request_recv_sock(const struct sock *sk,\n\t\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t\t      struct request_sock *req,\n\t\t\t\t\t      struct dst_entry *dst,\n\t\t\t\t\t      struct request_sock *req_unhash,\n\t\t\t\t\t      bool *own_req)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\tstruct ipv6_pinfo *newnp;\n\tconst struct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct ipv6_txoptions *opt;\n\tstruct inet_sock *newinet;\n\tstruct dccp6_sock *newdp6;\n\tstruct sock *newsk;\n\n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\t/*\n\t\t *\tv6 mapped\n\t\t */\n\t\tnewsk = dccp_v4_request_recv_sock(sk, skb, req, dst,\n\t\t\t\t\t\t  req_unhash, own_req);\n\t\tif (newsk == NULL)\n\t\t\treturn NULL;\n\n\t\tnewdp6 = (struct dccp6_sock *)newsk;\n\t\tnewinet = inet_sk(newsk);\n\t\tnewinet->pinet6 = &newdp6->inet6;\n\t\tnewnp = inet6_sk(newsk);\n\n\t\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\t\tnewnp->saddr = newsk->sk_v6_rcv_saddr;\n\n\t\tinet_csk(newsk)->icsk_af_ops = &dccp_ipv6_mapped;\n \t\tnewsk->sk_backlog_rcv = dccp_v4_do_rcv;\n \t\tnewnp->pktoptions  = NULL;\n \t\tnewnp->opt\t   = NULL;\n \t\tnewnp->mcast_oif   = inet6_iif(skb);\n \t\tnewnp->mcast_hops  = ipv6_hdr(skb)->hop_limit;\n \n\t\t/*\n\t\t * No need to charge this sock to the relevant IPv6 refcnt debug socks count\n\t\t * here, dccp_create_openreq_child now does this for us, see the comment in\n\t\t * that function for the gory details. -acme\n\t\t */\n\n\t\t/* It is tricky place. Until this moment IPv4 tcp\n\t\t   worked with IPv6 icsk.icsk_af_ops.\n\t\t   Sync it now.\n\t\t */\n\t\tdccp_sync_mss(newsk, inet_csk(newsk)->icsk_pmtu_cookie);\n\n\t\treturn newsk;\n\t}\n\n\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto out_overflow;\n\n\tif (!dst) {\n\t\tstruct flowi6 fl6;\n\n\t\tdst = inet6_csk_route_req(sk, &fl6, req, IPPROTO_DCCP);\n\t\tif (!dst)\n\t\t\tgoto out;\n\t}\n\n\tnewsk = dccp_create_openreq_child(sk, req, skb);\n\tif (newsk == NULL)\n\t\tgoto out_nonewsk;\n\n\t/*\n\t * No need to charge this sock to the relevant IPv6 refcnt debug socks\n\t * count here, dccp_create_openreq_child now does this for us, see the\n\t * comment in that function for the gory details. -acme\n\t */\n\n\tip6_dst_store(newsk, dst, NULL, NULL);\n\tnewsk->sk_route_caps = dst->dev->features & ~(NETIF_F_IP_CSUM |\n\t\t\t\t\t\t      NETIF_F_TSO);\n\tnewdp6 = (struct dccp6_sock *)newsk;\n\tnewinet = inet_sk(newsk);\n\tnewinet->pinet6 = &newdp6->inet6;\n\tnewnp = inet6_sk(newsk);\n\n\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\tnewsk->sk_v6_daddr\t= ireq->ir_v6_rmt_addr;\n\tnewnp->saddr\t\t= ireq->ir_v6_loc_addr;\n\tnewsk->sk_v6_rcv_saddr\t= ireq->ir_v6_loc_addr;\n\tnewsk->sk_bound_dev_if\t= ireq->ir_iif;\n\n\t/* Now IPv6 options...\n\n\t   First: no IPv4 options.\n\t */\n\tnewinet->inet_opt = NULL;\n\n \t/* Clone RX bits */\n \tnewnp->rxopt.all = np->rxopt.all;\n \n \tnewnp->pktoptions = NULL;\n \tnewnp->opt\t  = NULL;\n \tnewnp->mcast_oif  = inet6_iif(skb);\n\tnewnp->mcast_hops = ipv6_hdr(skb)->hop_limit;\n\n\t/*\n\t * Clone native IPv6 options from listening socket (if any)\n\t *\n\t * Yes, keeping reference count would be much more clever, but we make\n\t * one more one thing there: reattach optmem to newsk.\n\t */\n\topt = ireq->ipv6_opt;\n\tif (!opt)\n\t\topt = rcu_dereference(np->opt);\n\tif (opt) {\n\t\topt = ipv6_dup_options(newsk, opt);\n\t\tRCU_INIT_POINTER(newnp->opt, opt);\n\t}\n\tinet_csk(newsk)->icsk_ext_hdr_len = 0;\n\tif (opt)\n\t\tinet_csk(newsk)->icsk_ext_hdr_len = opt->opt_nflen +\n\t\t\t\t\t\t    opt->opt_flen;\n\n\tdccp_sync_mss(newsk, dst_mtu(dst));\n\n\tnewinet->inet_daddr = newinet->inet_saddr = LOOPBACK4_IPV6;\n\tnewinet->inet_rcv_saddr = LOOPBACK4_IPV6;\n\n\tif (__inet_inherit_port(sk, newsk) < 0) {\n\t\tinet_csk_prepare_forced_close(newsk);\n\t\tdccp_done(newsk);\n\t\tgoto out;\n\t}\n\t*own_req = inet_ehash_nolisten(newsk, req_to_sk(req_unhash));\n\t/* Clone pktoptions received with SYN, if we own the req */\n\tif (*own_req && ireq->pktopts) {\n\t\tnewnp->pktoptions = skb_clone(ireq->pktopts, GFP_ATOMIC);\n\t\tconsume_skb(ireq->pktopts);\n\t\tireq->pktopts = NULL;\n\t\tif (newnp->pktoptions)\n\t\t\tskb_set_owner_r(newnp->pktoptions, newsk);\n\t}\n\n\treturn newsk;\n\nout_overflow:\n\t__NET_INC_STATS(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nout_nonewsk:\n\tdst_release(dst);\nout:\n\t__NET_INC_STATS(sock_net(sk), LINUX_MIB_LISTENDROPS);\n\treturn NULL;\n}\n", "target": 1, "idx": 181299}
{"func": "static void srpt_cm_rep_error(struct ib_cm_id *cm_id)\n{\n\tpr_info(\"Received IB REP error for cm_id %p.\\n\", cm_id);\n\tsrpt_drain_channel(cm_id);\n}\n", "target": 0, "idx": 50641}
{"func": "void GetIntersection (uint64 start1, uint32 length1, uint64 start2, uint64 end2, uint64 *intersectStart, uint32 *intersectLength)\n{\n\tuint64 end1 = start1 + length1 - 1;\n\tuint64 intersectEnd = (end1 <= end2) ? end1 : end2;\n\n\t*intersectStart = (start1 >= start2) ? start1 : start2;\n\t*intersectLength = (uint32) ((*intersectStart > intersectEnd) ? 0 : intersectEnd + 1 - *intersectStart);\n\n\tif (*intersectLength == 0)\n\t\t*intersectStart = start1;\n}\n", "target": 0, "idx": 87176}
{"func": " tiffcp(TIFF* in, TIFF* out)\n {\n\tuint16 bitspersample, samplesperpixel = 1;\n \tuint16 input_compression, input_photometric = PHOTOMETRIC_MINISBLACK;\n \tcopyFunc cf;\n \tuint32 width, length;\n\tstruct cpTag* p;\n\n\tCopyField(TIFFTAG_IMAGEWIDTH, width);\n\tCopyField(TIFFTAG_IMAGELENGTH, length);\n\tCopyField(TIFFTAG_BITSPERSAMPLE, bitspersample);\n\tCopyField(TIFFTAG_SAMPLESPERPIXEL, samplesperpixel);\n\tif (compression != (uint16)-1)\n\t\tTIFFSetField(out, TIFFTAG_COMPRESSION, compression);\n\telse\n\t\tCopyField(TIFFTAG_COMPRESSION, compression);\n\tTIFFGetFieldDefaulted(in, TIFFTAG_COMPRESSION, &input_compression);\n\tTIFFGetFieldDefaulted(in, TIFFTAG_PHOTOMETRIC, &input_photometric);\n\tif (input_compression == COMPRESSION_JPEG) {\n\t\t/* Force conversion to RGB */\n\t\tTIFFSetField(in, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n\t} else if (input_photometric == PHOTOMETRIC_YCBCR) {\n\t\t/* Otherwise, can't handle subsampled input */\n\t\tuint16 subsamplinghor,subsamplingver;\n\n\t\tTIFFGetFieldDefaulted(in, TIFFTAG_YCBCRSUBSAMPLING,\n\t\t\t\t      &subsamplinghor, &subsamplingver);\n\t\tif (subsamplinghor!=1 || subsamplingver!=1) {\n\t\t\tfprintf(stderr, \"tiffcp: %s: Can't copy/convert subsampled image.\\n\",\n\t\t\t\tTIFFFileName(in));\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\tif (compression == COMPRESSION_JPEG) {\n\t\tif (input_photometric == PHOTOMETRIC_RGB &&\n\t\t    jpegcolormode == JPEGCOLORMODE_RGB)\n\t\t  TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);\n\t\telse\n\t\t  TIFFSetField(out, TIFFTAG_PHOTOMETRIC, input_photometric);\n\t}\n\telse if (compression == COMPRESSION_SGILOG\n\t    || compression == COMPRESSION_SGILOG24)\n\t\tTIFFSetField(out, TIFFTAG_PHOTOMETRIC,\n\t\t    samplesperpixel == 1 ?\n\t\t    PHOTOMETRIC_LOGL : PHOTOMETRIC_LOGLUV);\n\telse if (input_compression == COMPRESSION_JPEG &&\n\t\t\t samplesperpixel == 3 ) {\n\t\t/* RGB conversion was forced above\n\t\thence the output will be of the same type */\n\t\tTIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n\t}\n\telse\n\t\tCopyTag(TIFFTAG_PHOTOMETRIC, 1, TIFF_SHORT);\n\tif (fillorder != 0)\n\t\tTIFFSetField(out, TIFFTAG_FILLORDER, fillorder);\n\telse\n\t\tCopyTag(TIFFTAG_FILLORDER, 1, TIFF_SHORT);\n\t/*\n\t * Will copy `Orientation' tag from input image\n\t */\n\tTIFFGetFieldDefaulted(in, TIFFTAG_ORIENTATION, &orientation);\n\tswitch (orientation) {\n\t\tcase ORIENTATION_BOTRIGHT:\n\t\tcase ORIENTATION_RIGHTBOT:\t/* XXX */\n\t\t\tTIFFWarning(TIFFFileName(in), \"using bottom-left orientation\");\n\t\t\torientation = ORIENTATION_BOTLEFT;\n\t\t/* fall thru... */\n\t\tcase ORIENTATION_LEFTBOT:\t/* XXX */\n\t\tcase ORIENTATION_BOTLEFT:\n\t\t\tbreak;\n\t\tcase ORIENTATION_TOPRIGHT:\n\t\tcase ORIENTATION_RIGHTTOP:\t/* XXX */\n\t\tdefault:\n\t\t\tTIFFWarning(TIFFFileName(in), \"using top-left orientation\");\n\t\t\torientation = ORIENTATION_TOPLEFT;\n\t\t/* fall thru... */\n\t\tcase ORIENTATION_LEFTTOP:\t/* XXX */\n\t\tcase ORIENTATION_TOPLEFT:\n\t\t\tbreak;\n\t}\n\tTIFFSetField(out, TIFFTAG_ORIENTATION, orientation);\n\t/*\n\t * Choose tiles/strip for the output image according to\n\t * the command line arguments (-tiles, -strips) and the\n\t * structure of the input image.\n\t */\n\tif (outtiled == -1)\n\t\touttiled = TIFFIsTiled(in);\n\tif (outtiled) {\n\t\t/*\n\t\t * Setup output file's tile width&height.  If either\n\t\t * is not specified, use either the value from the\n\t\t * input image or, if nothing is defined, use the\n\t\t * library default.\n\t\t */\n\t\tif (tilewidth == (uint32) -1)\n\t\t\tTIFFGetField(in, TIFFTAG_TILEWIDTH, &tilewidth);\n\t\tif (tilelength == (uint32) -1)\n\t\t\tTIFFGetField(in, TIFFTAG_TILELENGTH, &tilelength);\n\t\tTIFFDefaultTileSize(out, &tilewidth, &tilelength);\n\t\tTIFFSetField(out, TIFFTAG_TILEWIDTH, tilewidth);\n\t\tTIFFSetField(out, TIFFTAG_TILELENGTH, tilelength);\n\t} else {\n\t\t/*\n\t\t * RowsPerStrip is left unspecified: use either the\n\t\t * value from the input image or, if nothing is defined,\n\t\t * use the library default.\n\t\t */\n\t\tif (rowsperstrip == (uint32) 0) {\n\t\t\tif (!TIFFGetField(in, TIFFTAG_ROWSPERSTRIP,\n\t\t\t    &rowsperstrip)) {\n\t\t\t\trowsperstrip =\n\t\t\t\t    TIFFDefaultStripSize(out, rowsperstrip);\n\t\t\t}\n\t\t\tif (rowsperstrip > length && rowsperstrip != (uint32)-1)\n\t\t\t\trowsperstrip = length;\n\t\t}\n\t\telse if (rowsperstrip == (uint32) -1)\n\t\t\trowsperstrip = length;\n\t\tTIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\n\t}\n\tif (config != (uint16) -1)\n\t\tTIFFSetField(out, TIFFTAG_PLANARCONFIG, config);\n\telse\n\t\tCopyField(TIFFTAG_PLANARCONFIG, config);\n\tif (samplesperpixel <= 4)\n\t\tCopyTag(TIFFTAG_TRANSFERFUNCTION, 4, TIFF_SHORT);\n\tCopyTag(TIFFTAG_COLORMAP, 4, TIFF_SHORT);\n/* SMinSampleValue & SMaxSampleValue */\n\tswitch (compression) {\n\t\tcase COMPRESSION_JPEG:\n\t\t\tTIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);\n\t\t\tTIFFSetField(out, TIFFTAG_JPEGCOLORMODE, jpegcolormode);\n\t\t\tbreak;\n\t\tcase COMPRESSION_JBIG:\n\t\t\tCopyTag(TIFFTAG_FAXRECVPARAMS, 1, TIFF_LONG);\n\t\t\tCopyTag(TIFFTAG_FAXRECVTIME, 1, TIFF_LONG);\n\t\t\tCopyTag(TIFFTAG_FAXSUBADDRESS, 1, TIFF_ASCII);\n\t\t\tCopyTag(TIFFTAG_FAXDCS, 1, TIFF_ASCII);\n\t\t\tbreak;\n\t\tcase COMPRESSION_LZW:\n\t\tcase COMPRESSION_ADOBE_DEFLATE:\n\t\tcase COMPRESSION_DEFLATE:\n                case COMPRESSION_LZMA:\n\t\t\tif (predictor != (uint16)-1)\n\t\t\t\tTIFFSetField(out, TIFFTAG_PREDICTOR, predictor);\n\t\t\telse\n\t\t\t\tCopyField(TIFFTAG_PREDICTOR, predictor);\n\t\t\tif (preset != -1) {\n                                if (compression == COMPRESSION_ADOBE_DEFLATE\n                                         || compression == COMPRESSION_DEFLATE)\n                                        TIFFSetField(out, TIFFTAG_ZIPQUALITY, preset);\n\t\t\t\telse if (compression == COMPRESSION_LZMA)\n\t\t\t\t\tTIFFSetField(out, TIFFTAG_LZMAPRESET, preset);\n                        }\n\t\t\tbreak;\n\t\tcase COMPRESSION_CCITTFAX3:\n\t\tcase COMPRESSION_CCITTFAX4:\n\t\t\tif (compression == COMPRESSION_CCITTFAX3) {\n\t\t\t\tif (g3opts != (uint32) -1)\n\t\t\t\t\tTIFFSetField(out, TIFFTAG_GROUP3OPTIONS,\n\t\t\t\t\t    g3opts);\n\t\t\t\telse\n\t\t\t\t\tCopyField(TIFFTAG_GROUP3OPTIONS, g3opts);\n\t\t\t} else\n\t\t\t\tCopyTag(TIFFTAG_GROUP4OPTIONS, 1, TIFF_LONG);\n\t\t\tCopyTag(TIFFTAG_BADFAXLINES, 1, TIFF_LONG);\n\t\t\tCopyTag(TIFFTAG_CLEANFAXDATA, 1, TIFF_LONG);\n\t\t\tCopyTag(TIFFTAG_CONSECUTIVEBADFAXLINES, 1, TIFF_LONG);\n\t\t\tCopyTag(TIFFTAG_FAXRECVPARAMS, 1, TIFF_LONG);\n\t\t\tCopyTag(TIFFTAG_FAXRECVTIME, 1, TIFF_LONG);\n\t\t\tCopyTag(TIFFTAG_FAXSUBADDRESS, 1, TIFF_ASCII);\n\t\t\tbreak;\n\t}\n\t{\n\t\tuint32 len32;\n\t\tvoid** data;\n\t\tif (TIFFGetField(in, TIFFTAG_ICCPROFILE, &len32, &data))\n\t\t\tTIFFSetField(out, TIFFTAG_ICCPROFILE, len32, data);\n\t}\n\t{\n\t\tuint16 ninks;\n\t\tconst char* inknames;\n\t\tif (TIFFGetField(in, TIFFTAG_NUMBEROFINKS, &ninks)) {\n\t\t\tTIFFSetField(out, TIFFTAG_NUMBEROFINKS, ninks);\n\t\t\tif (TIFFGetField(in, TIFFTAG_INKNAMES, &inknames)) {\n\t\t\t\tint inknameslen = strlen(inknames) + 1;\n\t\t\t\tconst char* cp = inknames;\n\t\t\t\twhile (ninks > 1) {\n\t\t\t\t\tcp = strchr(cp, '\\0');\n                                        cp++;\n                                        inknameslen += (strlen(cp) + 1);\n\t\t\t\t\tninks--;\n\t\t\t\t}\n\t\t\t\tTIFFSetField(out, TIFFTAG_INKNAMES, inknameslen, inknames);\n\t\t\t}\n\t\t}\n\t}\n\t{\n\t\tunsigned short pg0, pg1;\n\n\t\tif (pageInSeq == 1) {\n\t\t\tif (pageNum < 0) /* only one input file */ {\n\t\t\t\tif (TIFFGetField(in, TIFFTAG_PAGENUMBER, &pg0, &pg1))\n\t\t\t\t\tTIFFSetField(out, TIFFTAG_PAGENUMBER, pg0, pg1);\n\t\t\t} else\n\t\t\t\tTIFFSetField(out, TIFFTAG_PAGENUMBER, pageNum++, 0);\n\n\t\t} else {\n\t\t\tif (TIFFGetField(in, TIFFTAG_PAGENUMBER, &pg0, &pg1)) {\n\t\t\t\tif (pageNum < 0) /* only one input file */\n\t\t\t\t\tTIFFSetField(out, TIFFTAG_PAGENUMBER, pg0, pg1);\n\t\t\t\telse\n\t\t\t\t\tTIFFSetField(out, TIFFTAG_PAGENUMBER, pageNum++, 0);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (p = tags; p < &tags[NTAGS]; p++)\n\t\tCopyTag(p->tag, p->count, p->type);\n\n\tcf = pickCopyFunc(in, out, bitspersample, samplesperpixel);\n\treturn (cf ? (*cf)(in, out, length, width, samplesperpixel) : FALSE);\n}\n", "target": 1, "idx": 181587}
{"func": "void WebPage::loadString(const BlackBerry::Platform::String& string, const BlackBerry::Platform::String& baseURL, const BlackBerry::Platform::String& mimeType, const BlackBerry::Platform::String& failingURL)\n{\n    d->loadString(string, baseURL, mimeType, failingURL);\n}\n", "target": 0, "idx": 111206}
{"func": "static int do_ipv6_setsockopt(struct sock *sk, int level, int optname,\n\t\t    char __user *optval, unsigned int optlen)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct net *net = sock_net(sk);\n\tint val, valbool;\n\tint retv = -ENOPROTOOPT;\n\tbool needs_rtnl = setsockopt_needs_rtnl(optname);\n\n\tif (!optval)\n\t\tval = 0;\n\telse {\n\t\tif (optlen >= sizeof(int)) {\n\t\t\tif (get_user(val, (int __user *) optval))\n\t\t\t\treturn -EFAULT;\n\t\t} else\n\t\t\tval = 0;\n\t}\n\n\tvalbool = (val != 0);\n\n\tif (ip6_mroute_opt(optname))\n\t\treturn ip6_mroute_setsockopt(sk, optname, optval, optlen);\n\n\tif (needs_rtnl)\n\t\trtnl_lock();\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\n\tcase IPV6_ADDRFORM:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val == PF_INET) {\n\t\t\tstruct ipv6_txoptions *opt;\n\t\t\tstruct sk_buff *pktopt;\n\n\t\t\tif (sk->sk_type == SOCK_RAW)\n\t\t\t\tbreak;\n\n\t\t\tif (sk->sk_protocol == IPPROTO_UDP ||\n\t\t\t    sk->sk_protocol == IPPROTO_UDPLITE) {\n\t\t\t\tstruct udp_sock *up = udp_sk(sk);\n\t\t\t\tif (up->pending == AF_INET6) {\n\t\t\t\t\tretv = -EBUSY;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (sk->sk_protocol != IPPROTO_TCP)\n\t\t\t\tbreak;\n\n\t\t\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\t\t\tretv = -ENOTCONN;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (ipv6_only_sock(sk) ||\n\t\t\t    !ipv6_addr_v4mapped(&sk->sk_v6_daddr)) {\n\t\t\t\tretv = -EADDRNOTAVAIL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfl6_free_socklist(sk);\n\t\t\tipv6_sock_mc_close(sk);\n\n\t\t\t/*\n\t\t\t * Sock is moving from IPv6 to IPv4 (sk_prot), so\n\t\t\t * remove it from the refcnt debug socks count in the\n\t\t\t * original family...\n\t\t\t */\n\t\t\tsk_refcnt_debug_dec(sk);\n\n\t\t\tif (sk->sk_protocol == IPPROTO_TCP) {\n\t\t\t\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\t\t\t\tlocal_bh_disable();\n\t\t\t\tsock_prot_inuse_add(net, sk->sk_prot, -1);\n\t\t\t\tsock_prot_inuse_add(net, &tcp_prot, 1);\n\t\t\t\tlocal_bh_enable();\n\t\t\t\tsk->sk_prot = &tcp_prot;\n\t\t\t\ticsk->icsk_af_ops = &ipv4_specific;\n\t\t\t\tsk->sk_socket->ops = &inet_stream_ops;\n\t\t\t\tsk->sk_family = PF_INET;\n\t\t\t\ttcp_sync_mss(sk, icsk->icsk_pmtu_cookie);\n\t\t\t} else {\n\t\t\t\tstruct proto *prot = &udp_prot;\n\n\t\t\t\tif (sk->sk_protocol == IPPROTO_UDPLITE)\n\t\t\t\t\tprot = &udplite_prot;\n\t\t\t\tlocal_bh_disable();\n\t\t\t\tsock_prot_inuse_add(net, sk->sk_prot, -1);\n\t\t\t\tsock_prot_inuse_add(net, prot, 1);\n\t\t\t\tlocal_bh_enable();\n\t\t\t\tsk->sk_prot = prot;\n \t\t\t\tsk->sk_socket->ops = &inet_dgram_ops;\n \t\t\t\tsk->sk_family = PF_INET;\n \t\t\t}\n\t\t\topt = xchg(&np->opt, NULL);\n\t\t\tif (opt)\n\t\t\t\tsock_kfree_s(sk, opt, opt->tot_len);\n \t\t\tpktopt = xchg(&np->pktoptions, NULL);\n \t\t\tkfree_skb(pktopt);\n \n\t\t\tsk->sk_destruct = inet_sock_destruct;\n\t\t\t/*\n\t\t\t * ... and add it to the refcnt debug socks count\n\t\t\t * in the new family. -acme\n\t\t\t */\n\t\t\tsk_refcnt_debug_inc(sk);\n\t\t\tmodule_put(THIS_MODULE);\n\t\t\tretv = 0;\n\t\t\tbreak;\n\t\t}\n\t\tgoto e_inval;\n\n\tcase IPV6_V6ONLY:\n\t\tif (optlen < sizeof(int) ||\n\t\t    inet_sk(sk)->inet_num)\n\t\t\tgoto e_inval;\n\t\tsk->sk_ipv6only = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_RECVPKTINFO:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.rxinfo = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_2292PKTINFO:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.rxoinfo = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_RECVHOPLIMIT:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.rxhlim = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_2292HOPLIMIT:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.rxohlim = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_RECVRTHDR:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.srcrt = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_2292RTHDR:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.osrcrt = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_RECVHOPOPTS:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.hopopts = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_2292HOPOPTS:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.ohopopts = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_RECVDSTOPTS:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.dstopts = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_2292DSTOPTS:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.odstopts = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_TCLASS:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val < -1 || val > 0xff)\n\t\t\tgoto e_inval;\n\t\t/* RFC 3542, 6.5: default traffic class of 0x0 */\n\t\tif (val == -1)\n\t\t\tval = 0;\n\t\tnp->tclass = val;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_RECVTCLASS:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.rxtclass = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_FLOWINFO:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.rxflow = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_RECVPATHMTU:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.rxpmtu = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_TRANSPARENT:\n\t\tif (valbool && !ns_capable(net->user_ns, CAP_NET_ADMIN) &&\n\t\t    !ns_capable(net->user_ns, CAP_NET_RAW)) {\n\t\t\tretv = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\t/* we don't have a separate transparent bit for IPV6 we use the one in the IPv4 socket */\n\t\tinet_sk(sk)->transparent = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_RECVORIGDSTADDR:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.rxorigdstaddr = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_HOPOPTS:\n\tcase IPV6_RTHDRDSTOPTS:\n\tcase IPV6_RTHDR:\n\tcase IPV6_DSTOPTS:\n\t{\n\t\tstruct ipv6_txoptions *opt;\n\n\t\t/* remove any sticky options header with a zero option\n\t\t * length, per RFC3542.\n\t\t */\n\t\tif (optlen == 0)\n\t\t\toptval = NULL;\n\t\telse if (!optval)\n\t\t\tgoto e_inval;\n\t\telse if (optlen < sizeof(struct ipv6_opt_hdr) ||\n\t\t\t optlen & 0x7 || optlen > 8 * 255)\n\t\t\tgoto e_inval;\n\n\t\t/* hop-by-hop / destination options are privileged option */\n\t\tretv = -EPERM;\n \t\tif (optname != IPV6_RTHDR && !ns_capable(net->user_ns, CAP_NET_RAW))\n \t\t\tbreak;\n \n\t\topt = ipv6_renew_options(sk, np->opt, optname,\n \t\t\t\t\t (struct ipv6_opt_hdr __user *)optval,\n \t\t\t\t\t optlen);\n \t\tif (IS_ERR(opt)) {\n\t\t\tretv = PTR_ERR(opt);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* routing header option needs extra check */\n\t\tretv = -EINVAL;\n\t\tif (optname == IPV6_RTHDR && opt && opt->srcrt) {\n\t\t\tstruct ipv6_rt_hdr *rthdr = opt->srcrt;\n\t\t\tswitch (rthdr->type) {\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\t\t\tcase IPV6_SRCRT_TYPE_2:\n\t\t\t\tif (rthdr->hdrlen != 2 ||\n\t\t\t\t    rthdr->segments_left != 1)\n\t\t\t\t\tgoto sticky_done;\n\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tgoto sticky_done;\n\t\t\t}\n\t\t}\n\n \t\tretv = 0;\n \t\topt = ipv6_update_options(sk, opt);\n sticky_done:\n\t\tif (opt)\n\t\t\tsock_kfree_s(sk, opt, opt->tot_len);\n \t\tbreak;\n \t}\n \n\tcase IPV6_PKTINFO:\n\t{\n\t\tstruct in6_pktinfo pkt;\n\n\t\tif (optlen == 0)\n\t\t\tgoto e_inval;\n\t\telse if (optlen < sizeof(struct in6_pktinfo) || !optval)\n\t\t\tgoto e_inval;\n\n\t\tif (copy_from_user(&pkt, optval, sizeof(struct in6_pktinfo))) {\n\t\t\t\tretv = -EFAULT;\n\t\t\t\tbreak;\n\t\t}\n\t\tif (sk->sk_bound_dev_if && pkt.ipi6_ifindex != sk->sk_bound_dev_if)\n\t\t\tgoto e_inval;\n\n\t\tnp->sticky_pktinfo.ipi6_ifindex = pkt.ipi6_ifindex;\n\t\tnp->sticky_pktinfo.ipi6_addr = pkt.ipi6_addr;\n\t\tretv = 0;\n\t\tbreak;\n\t}\n\n\tcase IPV6_2292PKTOPTIONS:\n\t{\n\t\tstruct ipv6_txoptions *opt = NULL;\n\t\tstruct msghdr msg;\n\t\tstruct flowi6 fl6;\n\t\tint junk;\n\n\t\tmemset(&fl6, 0, sizeof(fl6));\n\t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\t\tfl6.flowi6_mark = sk->sk_mark;\n\n\t\tif (optlen == 0)\n\t\t\tgoto update;\n\n\t\t/* 1K is probably excessive\n\t\t * 1K is surely not enough, 2K per standard header is 16K.\n\t\t */\n\t\tretv = -EINVAL;\n\t\tif (optlen > 64*1024)\n\t\t\tbreak;\n\n\t\topt = sock_kmalloc(sk, sizeof(*opt) + optlen, GFP_KERNEL);\n\t\tretv = -ENOBUFS;\n\t\tif (!opt)\n \t\t\tbreak;\n \n \t\tmemset(opt, 0, sizeof(*opt));\n \t\topt->tot_len = sizeof(*opt) + optlen;\n \t\tretv = -EFAULT;\n \t\tif (copy_from_user(opt+1, optval, optlen))\n\t\t\tgoto done;\n\n\t\tmsg.msg_controllen = optlen;\n\t\tmsg.msg_control = (void *)(opt+1);\n\n\t\tretv = ip6_datagram_send_ctl(net, sk, &msg, &fl6, opt, &junk,\n\t\t\t\t\t     &junk, &junk);\n\t\tif (retv)\n\t\t\tgoto done;\nupdate:\n \t\tretv = 0;\n \t\topt = ipv6_update_options(sk, opt);\n done:\n\t\tif (opt)\n\t\t\tsock_kfree_s(sk, opt, opt->tot_len);\n \t\tbreak;\n \t}\n \tcase IPV6_UNICAST_HOPS:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val > 255 || val < -1)\n\t\t\tgoto e_inval;\n\t\tnp->hop_limit = val;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_MULTICAST_HOPS:\n\t\tif (sk->sk_type == SOCK_STREAM)\n\t\t\tbreak;\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val > 255 || val < -1)\n\t\t\tgoto e_inval;\n\t\tnp->mcast_hops = (val == -1 ? IPV6_DEFAULT_MCASTHOPS : val);\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_MULTICAST_LOOP:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val != valbool)\n\t\t\tgoto e_inval;\n\t\tnp->mc_loop = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_UNICAST_IF:\n\t{\n\t\tstruct net_device *dev = NULL;\n\t\tint ifindex;\n\n\t\tif (optlen != sizeof(int))\n\t\t\tgoto e_inval;\n\n\t\tifindex = (__force int)ntohl((__force __be32)val);\n\t\tif (ifindex == 0) {\n\t\t\tnp->ucast_oif = 0;\n\t\t\tretv = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tdev = dev_get_by_index(net, ifindex);\n\t\tretv = -EADDRNOTAVAIL;\n\t\tif (!dev)\n\t\t\tbreak;\n\t\tdev_put(dev);\n\n\t\tretv = -EINVAL;\n\t\tif (sk->sk_bound_dev_if)\n\t\t\tbreak;\n\n\t\tnp->ucast_oif = ifindex;\n\t\tretv = 0;\n\t\tbreak;\n\t}\n\n\tcase IPV6_MULTICAST_IF:\n\t\tif (sk->sk_type == SOCK_STREAM)\n\t\t\tbreak;\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\n\t\tif (val) {\n\t\t\tstruct net_device *dev;\n\n\t\t\tif (sk->sk_bound_dev_if && sk->sk_bound_dev_if != val)\n\t\t\t\tgoto e_inval;\n\n\t\t\tdev = dev_get_by_index(net, val);\n\t\t\tif (!dev) {\n\t\t\t\tretv = -ENODEV;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdev_put(dev);\n\t\t}\n\t\tnp->mcast_oif = val;\n\t\tretv = 0;\n\t\tbreak;\n\tcase IPV6_ADD_MEMBERSHIP:\n\tcase IPV6_DROP_MEMBERSHIP:\n\t{\n\t\tstruct ipv6_mreq mreq;\n\n\t\tif (optlen < sizeof(struct ipv6_mreq))\n\t\t\tgoto e_inval;\n\n\t\tretv = -EPROTO;\n\t\tif (inet_sk(sk)->is_icsk)\n\t\t\tbreak;\n\n\t\tretv = -EFAULT;\n\t\tif (copy_from_user(&mreq, optval, sizeof(struct ipv6_mreq)))\n\t\t\tbreak;\n\n\t\tif (optname == IPV6_ADD_MEMBERSHIP)\n\t\t\tretv = ipv6_sock_mc_join(sk, mreq.ipv6mr_ifindex, &mreq.ipv6mr_multiaddr);\n\t\telse\n\t\t\tretv = ipv6_sock_mc_drop(sk, mreq.ipv6mr_ifindex, &mreq.ipv6mr_multiaddr);\n\t\tbreak;\n\t}\n\tcase IPV6_JOIN_ANYCAST:\n\tcase IPV6_LEAVE_ANYCAST:\n\t{\n\t\tstruct ipv6_mreq mreq;\n\n\t\tif (optlen < sizeof(struct ipv6_mreq))\n\t\t\tgoto e_inval;\n\n\t\tretv = -EFAULT;\n\t\tif (copy_from_user(&mreq, optval, sizeof(struct ipv6_mreq)))\n\t\t\tbreak;\n\n\t\tif (optname == IPV6_JOIN_ANYCAST)\n\t\t\tretv = ipv6_sock_ac_join(sk, mreq.ipv6mr_ifindex, &mreq.ipv6mr_acaddr);\n\t\telse\n\t\t\tretv = ipv6_sock_ac_drop(sk, mreq.ipv6mr_ifindex, &mreq.ipv6mr_acaddr);\n\t\tbreak;\n\t}\n\tcase MCAST_JOIN_GROUP:\n\tcase MCAST_LEAVE_GROUP:\n\t{\n\t\tstruct group_req greq;\n\t\tstruct sockaddr_in6 *psin6;\n\n\t\tif (optlen < sizeof(struct group_req))\n\t\t\tgoto e_inval;\n\n\t\tretv = -EFAULT;\n\t\tif (copy_from_user(&greq, optval, sizeof(struct group_req)))\n\t\t\tbreak;\n\t\tif (greq.gr_group.ss_family != AF_INET6) {\n\t\t\tretv = -EADDRNOTAVAIL;\n\t\t\tbreak;\n\t\t}\n\t\tpsin6 = (struct sockaddr_in6 *)&greq.gr_group;\n\t\tif (optname == MCAST_JOIN_GROUP)\n\t\t\tretv = ipv6_sock_mc_join(sk, greq.gr_interface,\n\t\t\t\t\t\t &psin6->sin6_addr);\n\t\telse\n\t\t\tretv = ipv6_sock_mc_drop(sk, greq.gr_interface,\n\t\t\t\t\t\t &psin6->sin6_addr);\n\t\tbreak;\n\t}\n\tcase MCAST_JOIN_SOURCE_GROUP:\n\tcase MCAST_LEAVE_SOURCE_GROUP:\n\tcase MCAST_BLOCK_SOURCE:\n\tcase MCAST_UNBLOCK_SOURCE:\n\t{\n\t\tstruct group_source_req greqs;\n\t\tint omode, add;\n\n\t\tif (optlen < sizeof(struct group_source_req))\n\t\t\tgoto e_inval;\n\t\tif (copy_from_user(&greqs, optval, sizeof(greqs))) {\n\t\t\tretv = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (greqs.gsr_group.ss_family != AF_INET6 ||\n\t\t    greqs.gsr_source.ss_family != AF_INET6) {\n\t\t\tretv = -EADDRNOTAVAIL;\n\t\t\tbreak;\n\t\t}\n\t\tif (optname == MCAST_BLOCK_SOURCE) {\n\t\t\tomode = MCAST_EXCLUDE;\n\t\t\tadd = 1;\n\t\t} else if (optname == MCAST_UNBLOCK_SOURCE) {\n\t\t\tomode = MCAST_EXCLUDE;\n\t\t\tadd = 0;\n\t\t} else if (optname == MCAST_JOIN_SOURCE_GROUP) {\n\t\t\tstruct sockaddr_in6 *psin6;\n\n\t\t\tpsin6 = (struct sockaddr_in6 *)&greqs.gsr_group;\n\t\t\tretv = ipv6_sock_mc_join(sk, greqs.gsr_interface,\n\t\t\t\t\t\t &psin6->sin6_addr);\n\t\t\t/* prior join w/ different source is ok */\n\t\t\tif (retv && retv != -EADDRINUSE)\n\t\t\t\tbreak;\n\t\t\tomode = MCAST_INCLUDE;\n\t\t\tadd = 1;\n\t\t} else /* MCAST_LEAVE_SOURCE_GROUP */ {\n\t\t\tomode = MCAST_INCLUDE;\n\t\t\tadd = 0;\n\t\t}\n\t\tretv = ip6_mc_source(add, omode, sk, &greqs);\n\t\tbreak;\n\t}\n\tcase MCAST_MSFILTER:\n\t{\n\t\tstruct group_filter *gsf;\n\n\t\tif (optlen < GROUP_FILTER_SIZE(0))\n\t\t\tgoto e_inval;\n\t\tif (optlen > sysctl_optmem_max) {\n\t\t\tretv = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\tgsf = kmalloc(optlen, GFP_KERNEL);\n\t\tif (!gsf) {\n\t\t\tretv = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\tretv = -EFAULT;\n\t\tif (copy_from_user(gsf, optval, optlen)) {\n\t\t\tkfree(gsf);\n\t\t\tbreak;\n\t\t}\n\t\t/* numsrc >= (4G-140)/128 overflow in 32 bits */\n\t\tif (gsf->gf_numsrc >= 0x1ffffffU ||\n\t\t    gsf->gf_numsrc > sysctl_mld_max_msf) {\n\t\t\tkfree(gsf);\n\t\t\tretv = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\tif (GROUP_FILTER_SIZE(gsf->gf_numsrc) > optlen) {\n\t\t\tkfree(gsf);\n\t\t\tretv = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tretv = ip6_mc_msfilter(sk, gsf);\n\t\tkfree(gsf);\n\n\t\tbreak;\n\t}\n\tcase IPV6_ROUTER_ALERT:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tretv = ip6_ra_control(sk, val);\n\t\tbreak;\n\tcase IPV6_MTU_DISCOVER:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val < IPV6_PMTUDISC_DONT || val > IPV6_PMTUDISC_OMIT)\n\t\t\tgoto e_inval;\n\t\tnp->pmtudisc = val;\n\t\tretv = 0;\n\t\tbreak;\n\tcase IPV6_MTU:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val && val < IPV6_MIN_MTU)\n\t\t\tgoto e_inval;\n\t\tnp->frag_size = val;\n\t\tretv = 0;\n\t\tbreak;\n\tcase IPV6_RECVERR:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->recverr = valbool;\n\t\tif (!val)\n\t\t\tskb_queue_purge(&sk->sk_error_queue);\n\t\tretv = 0;\n\t\tbreak;\n\tcase IPV6_FLOWINFO_SEND:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->sndflow = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\tcase IPV6_FLOWLABEL_MGR:\n\t\tretv = ipv6_flowlabel_opt(sk, optval, optlen);\n\t\tbreak;\n\tcase IPV6_IPSEC_POLICY:\n\tcase IPV6_XFRM_POLICY:\n\t\tretv = -EPERM;\n\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\tbreak;\n\t\tretv = xfrm_user_policy(sk, optname, optval, optlen);\n\t\tbreak;\n\n\tcase IPV6_ADDR_PREFERENCES:\n\t    {\n\t\tunsigned int pref = 0;\n\t\tunsigned int prefmask = ~0;\n\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\n\t\tretv = -EINVAL;\n\n\t\t/* check PUBLIC/TMP/PUBTMP_DEFAULT conflicts */\n\t\tswitch (val & (IPV6_PREFER_SRC_PUBLIC|\n\t\t\t       IPV6_PREFER_SRC_TMP|\n\t\t\t       IPV6_PREFER_SRC_PUBTMP_DEFAULT)) {\n\t\tcase IPV6_PREFER_SRC_PUBLIC:\n\t\t\tpref |= IPV6_PREFER_SRC_PUBLIC;\n\t\t\tbreak;\n\t\tcase IPV6_PREFER_SRC_TMP:\n\t\t\tpref |= IPV6_PREFER_SRC_TMP;\n\t\t\tbreak;\n\t\tcase IPV6_PREFER_SRC_PUBTMP_DEFAULT:\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tgoto pref_skip_pubtmp;\n\t\tdefault:\n\t\t\tgoto e_inval;\n\t\t}\n\n\t\tprefmask &= ~(IPV6_PREFER_SRC_PUBLIC|\n\t\t\t      IPV6_PREFER_SRC_TMP);\npref_skip_pubtmp:\n\n\t\t/* check HOME/COA conflicts */\n\t\tswitch (val & (IPV6_PREFER_SRC_HOME|IPV6_PREFER_SRC_COA)) {\n\t\tcase IPV6_PREFER_SRC_HOME:\n\t\t\tbreak;\n\t\tcase IPV6_PREFER_SRC_COA:\n\t\t\tpref |= IPV6_PREFER_SRC_COA;\n\t\tcase 0:\n\t\t\tgoto pref_skip_coa;\n\t\tdefault:\n\t\t\tgoto e_inval;\n\t\t}\n\n\t\tprefmask &= ~IPV6_PREFER_SRC_COA;\npref_skip_coa:\n\n\t\t/* check CGA/NONCGA conflicts */\n\t\tswitch (val & (IPV6_PREFER_SRC_CGA|IPV6_PREFER_SRC_NONCGA)) {\n\t\tcase IPV6_PREFER_SRC_CGA:\n\t\tcase IPV6_PREFER_SRC_NONCGA:\n\t\tcase 0:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto e_inval;\n\t\t}\n\n\t\tnp->srcprefs = (np->srcprefs & prefmask) | pref;\n\t\tretv = 0;\n\n\t\tbreak;\n\t    }\n\tcase IPV6_MINHOPCOUNT:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val < 0 || val > 255)\n\t\t\tgoto e_inval;\n\t\tnp->min_hopcount = val;\n\t\tretv = 0;\n\t\tbreak;\n\tcase IPV6_DONTFRAG:\n\t\tnp->dontfrag = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\tcase IPV6_AUTOFLOWLABEL:\n\t\tnp->autoflowlabel = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\tif (needs_rtnl)\n\t\trtnl_unlock();\n\n\treturn retv;\n\ne_inval:\n\trelease_sock(sk);\n\tif (needs_rtnl)\n\t\trtnl_unlock();\n\treturn -EINVAL;\n}\n", "target": 1, "idx": 180508}
{"func": "int svc_rdma_recvfrom(struct svc_rqst *rqstp)\n{\n\tstruct svc_xprt *xprt = rqstp->rq_xprt;\n\tstruct svcxprt_rdma *rdma_xprt =\n\t\tcontainer_of(xprt, struct svcxprt_rdma, sc_xprt);\n\tstruct svc_rdma_op_ctxt *ctxt = NULL;\n\tstruct rpcrdma_msg *rmsgp;\n\tint ret = 0;\n\n\tdprintk(\"svcrdma: rqstp=%p\\n\", rqstp);\n\n\tspin_lock(&rdma_xprt->sc_rq_dto_lock);\n\tif (!list_empty(&rdma_xprt->sc_read_complete_q)) {\n\t\tctxt = list_first_entry(&rdma_xprt->sc_read_complete_q,\n\t\t\t\t\tstruct svc_rdma_op_ctxt, list);\n\t\tlist_del(&ctxt->list);\n\t\tspin_unlock(&rdma_xprt->sc_rq_dto_lock);\n\t\trdma_read_complete(rqstp, ctxt);\n\t\tgoto complete;\n\t} else if (!list_empty(&rdma_xprt->sc_rq_dto_q)) {\n\t\tctxt = list_first_entry(&rdma_xprt->sc_rq_dto_q,\n\t\t\t\t\tstruct svc_rdma_op_ctxt, list);\n\t\tlist_del(&ctxt->list);\n\t} else {\n\t\tatomic_inc(&rdma_stat_rq_starve);\n\t\tclear_bit(XPT_DATA, &xprt->xpt_flags);\n\t\tctxt = NULL;\n\t}\n\tspin_unlock(&rdma_xprt->sc_rq_dto_lock);\n\tif (!ctxt) {\n\t\t/* This is the EAGAIN path. The svc_recv routine will\n\t\t * return -EAGAIN, the nfsd thread will go to call into\n\t\t * svc_recv again and we shouldn't be on the active\n\t\t * transport list\n\t\t */\n\t\tif (test_bit(XPT_CLOSE, &xprt->xpt_flags))\n\t\t\tgoto defer;\n\t\tgoto out;\n\t}\n\tdprintk(\"svcrdma: processing ctxt=%p on xprt=%p, rqstp=%p\\n\",\n\t\tctxt, rdma_xprt, rqstp);\n\tatomic_inc(&rdma_stat_recv);\n\n\t/* Build up the XDR from the receive buffers. */\n\trdma_build_arg_xdr(rqstp, ctxt, ctxt->byte_len);\n\n\t/* Decode the RDMA header. */\n\trmsgp = (struct rpcrdma_msg *)rqstp->rq_arg.head[0].iov_base;\n\tret = svc_rdma_xdr_decode_req(&rqstp->rq_arg);\n\tif (ret < 0)\n\t\tgoto out_err;\n\tif (ret == 0)\n \t\tgoto out_drop;\n \trqstp->rq_xprt_hlen = ret;\n \n\tif (svc_rdma_is_backchannel_reply(xprt, rmsgp)) {\n\t\tret = svc_rdma_handle_bc_reply(xprt->xpt_bc_xprt, rmsgp,\n \t\t\t\t\t       &rqstp->rq_arg);\n \t\tsvc_rdma_put_context(ctxt, 0);\n \t\tif (ret)\n\t\t\tgoto repost;\n\t\treturn ret;\n\t}\n\n\t/* Read read-list data. */\n\tret = rdma_read_chunks(rdma_xprt, rmsgp, rqstp, ctxt);\n\tif (ret > 0) {\n\t\t/* read-list posted, defer until data received from client. */\n\t\tgoto defer;\n\t} else if (ret < 0) {\n\t\t/* Post of read-list failed, free context. */\n\t\tsvc_rdma_put_context(ctxt, 1);\n\t\treturn 0;\n\t}\n\ncomplete:\n\tret = rqstp->rq_arg.head[0].iov_len\n\t\t+ rqstp->rq_arg.page_len\n\t\t+ rqstp->rq_arg.tail[0].iov_len;\n\tsvc_rdma_put_context(ctxt, 0);\n out:\n\tdprintk(\"svcrdma: ret=%d, rq_arg.len=%u, \"\n\t\t\"rq_arg.head[0].iov_base=%p, rq_arg.head[0].iov_len=%zd\\n\",\n\t\tret, rqstp->rq_arg.len,\n\t\trqstp->rq_arg.head[0].iov_base,\n\t\trqstp->rq_arg.head[0].iov_len);\n\trqstp->rq_prot = IPPROTO_MAX;\n\tsvc_xprt_copy_addrs(rqstp, xprt);\n \treturn ret;\n \n out_err:\n\tsvc_rdma_send_error(rdma_xprt, rmsgp, ret);\n \tsvc_rdma_put_context(ctxt, 0);\n \treturn 0;\n \ndefer:\n\treturn 0;\n\nout_drop:\n\tsvc_rdma_put_context(ctxt, 1);\nrepost:\n\treturn svc_rdma_repost_recv(rdma_xprt, GFP_KERNEL);\n}\n", "target": 1, "idx": 181337}
{"func": "mrb_vm_define_class(mrb_state *mrb, mrb_value outer, mrb_value super, mrb_sym id)\n{\n  struct RClass *s;\n  struct RClass *c;\n\n  if (!mrb_nil_p(super)) {\n    if (mrb_type(super) != MRB_TT_CLASS) {\n      mrb_raisef(mrb, E_TYPE_ERROR, \"superclass must be a Class (%S given)\",\n                 mrb_inspect(mrb, super));\n    }\n    s = mrb_class_ptr(super);\n  }\n  else {\n    s = 0;\n  }\n  check_if_class_or_module(mrb, outer);\n  if (mrb_const_defined_at(mrb, outer, id)) {\n    mrb_value old = mrb_const_get(mrb, outer, id);\n\n    if (mrb_type(old) != MRB_TT_CLASS) {\n      mrb_raisef(mrb, E_TYPE_ERROR, \"%S is not a class\", mrb_inspect(mrb, old));\n    }\n    c = mrb_class_ptr(old);\n    if (s) {\n      /* check super class */\n      if (mrb_class_real(c->super) != s) {\n        mrb_raisef(mrb, E_TYPE_ERROR, \"superclass mismatch for class %S\", old);\n      }\n    }\n    return c;\n  }\n  c = define_class(mrb, id, s, mrb_class_ptr(outer));\n  mrb_class_inherited(mrb, mrb_class_real(c->super), c);\n\n  return c;\n}\n", "target": 0, "idx": 82143}
{"func": " void install_local_socket(asocket* s) {\n    adb_mutex_lock(&socket_list_lock);\n \n     s->id = local_socket_next_id++;\n \n     if (local_socket_next_id == 0) {\n        local_socket_next_id = 1;\n     }\n \n     insert_local_socket(s, &local_socket_list);\n    adb_mutex_unlock(&socket_list_lock);\n }\n", "target": 1, "idx": 188174}
{"func": "vhost_scsi_make_tpg(struct se_wwn *wwn,\n\t\t   struct config_group *group,\n\t\t   const char *name)\n{\n\tstruct vhost_scsi_tport *tport = container_of(wwn,\n \t\t\tstruct vhost_scsi_tport, tport_wwn);\n \n \tstruct vhost_scsi_tpg *tpg;\n\tunsigned long tpgt;\n \tint ret;\n \n \tif (strstr(name, \"tpgt_\") != name)\n \t\treturn ERR_PTR(-EINVAL);\n\tif (kstrtoul(name + 5, 10, &tpgt) || tpgt > UINT_MAX)\n \t\treturn ERR_PTR(-EINVAL);\n \n \ttpg = kzalloc(sizeof(struct vhost_scsi_tpg), GFP_KERNEL);\n\tif (!tpg) {\n\t\tpr_err(\"Unable to allocate struct vhost_scsi_tpg\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tmutex_init(&tpg->tv_tpg_mutex);\n\tINIT_LIST_HEAD(&tpg->tv_tpg_list);\n\ttpg->tport = tport;\n\ttpg->tport_tpgt = tpgt;\n\n\tret = core_tpg_register(&vhost_scsi_fabric_configfs->tf_ops, wwn,\n\t\t\t\t&tpg->se_tpg, tpg, TRANSPORT_TPG_TYPE_NORMAL);\n\tif (ret < 0) {\n\t\tkfree(tpg);\n\t\treturn NULL;\n\t}\n\tmutex_lock(&vhost_scsi_mutex);\n\tlist_add_tail(&tpg->tv_tpg_list, &vhost_scsi_list);\n\tmutex_unlock(&vhost_scsi_mutex);\n\n\treturn &tpg->se_tpg;\n}\n", "target": 1, "idx": 179787}
{"func": "void ImageLoader::DecodeRequest::Reject() {\n  resolver_->Reject(DOMException::Create(\n      kEncodingError, \"The source image cannot be decoded.\"));\n  loader_ = nullptr;\n}\n", "target": 0, "idx": 160313}
{"func": "static int ssl3_read_internal(SSL *s, void *buf, int len, int peek)\n\t{\n\tint ret;\n\t\n\tclear_sys_error();\n\tif (s->s3->renegotiate) ssl3_renegotiate_check(s);\n\ts->s3->in_read_app_data=1;\n\tret=s->method->ssl_read_bytes(s,SSL3_RT_APPLICATION_DATA,buf,len,peek);\n\tif ((ret == -1) && (s->s3->in_read_app_data == 2))\n\t\t{\n\t\t/* ssl3_read_bytes decided to call s->handshake_func, which\n\t\t * called ssl3_read_bytes to read handshake data.\n\t\t * However, ssl3_read_bytes actually found application data\n\t\t * and thinks that application data makes sense here; so disable\n\t\t * handshake processing and try to read application data again. */\n\t\ts->in_handshake++;\n\t\tret=s->method->ssl_read_bytes(s,SSL3_RT_APPLICATION_DATA,buf,len,peek);\n\t\ts->in_handshake--;\n\t\t}\n\telse\n\t\ts->s3->in_read_app_data=0;\n\n\treturn(ret);\n\t}\n", "target": 0, "idx": 94}
{"func": "aodv_extension(netdissect_options *ndo,\n               const struct aodv_ext *ep, u_int length)\n {\n \tconst struct aodv_hello *ah;\n \n \tswitch (ep->type) {\n \tcase AODV_EXT_HELLO:\n \t\tah = (const struct aodv_hello *)(const void *)ep;\n \t\tND_TCHECK(*ah);\n \t\tif (length < sizeof(struct aodv_hello))\n \t\t\tgoto trunc;\n \t\tND_PRINT((ndo, \"\\n\\text HELLO %ld ms\",\n \t\t    (unsigned long)EXTRACT_32BITS(&ah->interval)));\n \t\tbreak;\n\n\tdefault:\n\t\tND_PRINT((ndo, \"\\n\\text %u %u\", ep->type, ep->length));\n\t\tbreak;\n\t}\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \" [|hello]\"));\n}\n", "target": 1, "idx": 181077}
{"func": "void kvm_register_target_sys_reg_table(unsigned int target,\n\t\t\t\t       struct kvm_sys_reg_target_table *table)\n{\n\ttarget_tables[target] = table;\n}\n", "target": 0, "idx": 62904}
{"func": " void DistillerNativeJavaScript::EnsureServiceConnected() {\n  if (!distiller_js_service_) {\n     render_frame_->GetServiceRegistry()->ConnectToRemoteService(\n         mojo::GetProxy(&distiller_js_service_));\n   }\n }\n", "target": 1, "idx": 185398}
{"func": "MagickExport void *RelinquishAlignedMemory(void *memory)\n{\n  if (memory == (void *) NULL)\n    return((void *) NULL);\n#if defined(MAGICKCORE_HAVE_POSIX_MEMALIGN)\n  free(memory);\n#elif defined(MAGICKCORE_HAVE__ALIGNED_MALLOC)\n  _aligned_free(memory);\n#else\n  free(*((void **) memory-1));\n#endif\n  return(NULL);\n}\n", "target": 0, "idx": 71435}
{"func": "bool effect_exists(effect_context_t *context)\n{\n struct listnode *node;\n\n    list_for_each(node, &created_effects_list) {\n effect_context_t *fx_ctxt = node_to_item(node,\n effect_context_t,\n                                                 effects_list_node);\n if (fx_ctxt == context) {\n return true;\n }\n }\n return false;\n}\n", "target": 0, "idx": 173521}
{"func": "xfs_attr_rmtval_set(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_bmbt_irec\tmap;\n\txfs_dablk_t\t\tlblkno;\n\txfs_fileoff_t\t\tlfileoff = 0;\n\t__uint8_t\t\t*src = args->value;\n\tint\t\t\tblkcnt;\n\tint\t\t\tvaluelen;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\tint\t\t\toffset = 0;\n\n\ttrace_xfs_attr_rmtval_set(args);\n\n\t/*\n\t * Find a \"hole\" in the attribute address space large enough for\n\t * us to drop the new attribute's value into. Because CRC enable\n \t * attributes have headers, we can't just do a straight byte to FSB\n \t * conversion and have to take the header space into account.\n \t */\n\tblkcnt = xfs_attr3_rmt_blocks(mp, args->valuelen);\n \terror = xfs_bmap_first_unused(args->trans, args->dp, blkcnt, &lfileoff,\n \t\t\t\t\t\t   XFS_ATTR_FORK);\n \tif (error)\n\t\treturn error;\n\n\targs->rmtblkno = lblkno = (xfs_dablk_t)lfileoff;\n\targs->rmtblkcnt = blkcnt;\n\n\t/*\n\t * Roll through the \"value\", allocating blocks on disk as required.\n\t */\n\twhile (blkcnt > 0) {\n\t\tint\tcommitted;\n\n\t\t/*\n\t\t * Allocate a single extent, up to the size of the value.\n\t\t */\n\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\tnmap = 1;\n\t\terror = xfs_bmapi_write(args->trans, dp, (xfs_fileoff_t)lblkno,\n\t\t\t\t  blkcnt,\n\t\t\t\t  XFS_BMAPI_ATTRFORK | XFS_BMAPI_METADATA,\n\t\t\t\t  args->firstblock, args->total, &map, &nmap,\n\t\t\t\t  args->flist);\n\t\tif (!error) {\n\t\t\terror = xfs_bmap_finish(&args->trans, args->flist,\n\t\t\t\t\t\t&committed);\n\t\t}\n\t\tif (error) {\n\t\t\tASSERT(committed);\n\t\t\targs->trans = NULL;\n\t\t\txfs_bmap_cancel(args->flist);\n\t\t\treturn(error);\n\t\t}\n\n\t\t/*\n\t\t * bmap_finish() may have committed the last trans and started\n\t\t * a new one.  We need the inode to be in all transactions.\n\t\t */\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\n\t\tASSERT(nmap == 1);\n\t\tASSERT((map.br_startblock != DELAYSTARTBLOCK) &&\n\t\t       (map.br_startblock != HOLESTARTBLOCK));\n\t\tlblkno += map.br_blockcount;\n\t\tblkcnt -= map.br_blockcount;\n\n\t\t/*\n\t\t * Start the next trans in the chain.\n\t\t */\n\t\terror = xfs_trans_roll(&args->trans, dp);\n\t\tif (error)\n\t\t\treturn (error);\n\t}\n\n\t/*\n\t * Roll through the \"value\", copying the attribute value to the\n\t * already-allocated blocks.  Blocks are written synchronously\n\t * so that we can know they are all on disk before we turn off\n\t * the INCOMPLETE flag.\n \t */\n \tlblkno = args->rmtblkno;\n \tblkcnt = args->rmtblkcnt;\n\tvaluelen = args->valuelen;\n \twhile (valuelen > 0) {\n \t\tstruct xfs_buf\t*bp;\n \t\txfs_daddr_t\tdblkno;\n\t\tint\t\tdblkcnt;\n\n\t\tASSERT(blkcnt > 0);\n\n\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\tnmap = 1;\n\t\terror = xfs_bmapi_read(dp, (xfs_fileoff_t)lblkno,\n\t\t\t\t       blkcnt, &map, &nmap,\n\t\t\t\t       XFS_BMAPI_ATTRFORK);\n\t\tif (error)\n\t\t\treturn(error);\n\t\tASSERT(nmap == 1);\n\t\tASSERT((map.br_startblock != DELAYSTARTBLOCK) &&\n\t\t       (map.br_startblock != HOLESTARTBLOCK));\n\n\t\tdblkno = XFS_FSB_TO_DADDR(mp, map.br_startblock),\n\t\tdblkcnt = XFS_FSB_TO_BB(mp, map.br_blockcount);\n\n\t\tbp = xfs_buf_get(mp->m_ddev_targp, dblkno, dblkcnt, 0);\n\t\tif (!bp)\n\t\t\treturn ENOMEM;\n\t\tbp->b_ops = &xfs_attr3_rmt_buf_ops;\n\n\t\txfs_attr_rmtval_copyin(mp, bp, args->dp->i_ino, &offset,\n\t\t\t\t       &valuelen, &src);\n\n\t\terror = xfs_bwrite(bp);\t/* GROT: NOTE: synchronous write */\n\t\txfs_buf_relse(bp);\n\t\tif (error)\n\t\t\treturn error;\n\n\n\t\t/* roll attribute extent map forwards */\n\t\tlblkno += map.br_blockcount;\n\t\tblkcnt -= map.br_blockcount;\n\t}\n\tASSERT(valuelen == 0);\n\treturn 0;\n}\n", "target": 1, "idx": 179912}
{"func": "base::string16 AuthenticatorBlePairingBeginSheetModel::GetStepDescription()\n    const {\n  return l10n_util::GetStringUTF16(IDS_WEBAUTHN_BLE_PAIRING_BEGIN_DESCRIPTION);\n}\n", "target": 0, "idx": 155572}
{"func": "bool WebGLRenderingContextBase::ValidateHTMLImageElement(\n    const SecurityOrigin* security_origin,\n    const char* function_name,\n    HTMLImageElement* image,\n    ExceptionState& exception_state) {\n  if (!image || !image->CachedImage()) {\n    SynthesizeGLError(GL_INVALID_VALUE, function_name, \"no image\");\n    return false;\n  }\n  const KURL& url = image->CachedImage()->GetResponse().Url();\n  if (url.IsNull() || url.IsEmpty() || !url.IsValid()) {\n    SynthesizeGLError(GL_INVALID_VALUE, function_name, \"invalid image\");\n    return false;\n   }\n \n   if (WouldTaintOrigin(image, security_origin)) {\n    exception_state.ThrowSecurityError(\"The cross-origin image at \" +\n                                       url.ElidedString() +\n                                       \" may not be loaded.\");\n     return false;\n   }\n   return true;\n}\n", "target": 1, "idx": 186667}
{"func": "static void perf_event_reset(struct perf_event *event)\n {\n \t(void)perf_event_read(event);\n \tlocal64_set(&event->count, 0);\n\tperf_event_update_userpage(event);\n}\n", "target": 1, "idx": 180160}
{"func": "PHP_FUNCTION(imagesetstyle)\n{\n\tzval *IM, *styles;\n\tgdImagePtr im;\n\tint * stylearr;\n\tint index;\n\tHashPosition pos;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ra\", &IM, &styles) == FAILURE)  {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\t/* copy the style values in the stylearr */\n\tstylearr = safe_emalloc(sizeof(int), zend_hash_num_elements(HASH_OF(styles)), 0);\n\n\tzend_hash_internal_pointer_reset_ex(HASH_OF(styles), &pos);\n\n\tfor (index = 0;; zend_hash_move_forward_ex(HASH_OF(styles), &pos))\t{\n\t\tzval ** item;\n\n\t\tif (zend_hash_get_current_data_ex(HASH_OF(styles), (void **) &item, &pos) == FAILURE) {\n \t\t\tbreak;\n \t\t}\n \n\t\tconvert_to_long_ex(item);\n\t\tstylearr[index++] = Z_LVAL_PP(item);\n \t}\n \n \tgdImageSetStyle(im, stylearr, index);\n\n\tefree(stylearr);\n\n\tRETURN_TRUE;\n}\n", "target": 1, "idx": 179597}
{"func": "static int cx24116_sleep(struct dvb_frontend *fe)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\tstruct cx24116_cmd cmd;\n\tint ret;\n\n\tdprintk(\"%s()\\n\", __func__);\n\n\t/* Firmware CMD 36: Power config */\n\tcmd.args[0x00] = CMD_TUNERSLEEP;\n\tcmd.args[0x01] = 1;\n\tcmd.len = 0x02;\n\tret = cx24116_cmd_execute(fe, &cmd);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t/* Power off (Shutdown clocks) */\n\tcx24116_writereg(state, 0xea, 0xff);\n\tcx24116_writereg(state, 0xe1, 1);\n\tcx24116_writereg(state, 0xe0, 1);\n\n\treturn 0;\n}\n", "target": 0, "idx": 94069}
{"func": "void WebPage::removeCompositingThreadOverlay(WebOverlay* overlay)\n{\n#if USE(ACCELERATED_COMPOSITING)\n    ASSERT(Platform::userInterfaceThreadMessageClient()->isCurrentThread());\n    if (d->compositor())\n        d->compositor()->removeOverlay(overlay->d->layerCompositingThread());\n    overlay->d->clear();\n    overlay->d->setPage(0);\n#endif\n}\n", "target": 0, "idx": 111299}
{"func": "int snd_timer_close(struct snd_timer_instance *timeri)\n{\n\tstruct snd_timer *timer = NULL;\n\tstruct snd_timer_instance *slave, *tmp;\n\n\tif (snd_BUG_ON(!timeri))\n\t\treturn -ENXIO;\n\n\t/* force to stop the timer */\n\tsnd_timer_stop(timeri);\n\n\tif (timeri->flags & SNDRV_TIMER_IFLG_SLAVE) {\n\t\t/* wait, until the active callback is finished */\n\t\tspin_lock_irq(&slave_active_lock);\n\t\twhile (timeri->flags & SNDRV_TIMER_IFLG_CALLBACK) {\n\t\t\tspin_unlock_irq(&slave_active_lock);\n\t\t\tudelay(10);\n\t\t\tspin_lock_irq(&slave_active_lock);\n\t\t}\n\t\tspin_unlock_irq(&slave_active_lock);\n\t\tmutex_lock(&register_mutex);\n\t\tlist_del(&timeri->open_list);\n\t\tmutex_unlock(&register_mutex);\n\t} else {\n\t\ttimer = timeri->timer;\n\t\tif (snd_BUG_ON(!timer))\n\t\t\tgoto out;\n\t\t/* wait, until the active callback is finished */\n\t\tspin_lock_irq(&timer->lock);\n\t\twhile (timeri->flags & SNDRV_TIMER_IFLG_CALLBACK) {\n\t\t\tspin_unlock_irq(&timer->lock);\n\t\t\tudelay(10);\n\t\t\tspin_lock_irq(&timer->lock);\n\t\t}\n\t\tspin_unlock_irq(&timer->lock);\n\t\tmutex_lock(&register_mutex);\n\t\tlist_del(&timeri->open_list);\n\t\tif (timer && list_empty(&timer->open_list_head) &&\n \t\t    timer->hw.close)\n \t\t\ttimer->hw.close(timer);\n \t\t/* remove slave links */\n \t\tlist_for_each_entry_safe(slave, tmp, &timeri->slave_list_head,\n \t\t\t\t\t open_list) {\n\t\t\tspin_lock_irq(&slave_active_lock);\n\t\t\t_snd_timer_stop(slave, 1, SNDRV_TIMER_EVENT_RESOLUTION);\n \t\t\tlist_move_tail(&slave->open_list, &snd_timer_slave_list);\n \t\t\tslave->master = NULL;\n \t\t\tslave->timer = NULL;\n\t\t\tspin_unlock_irq(&slave_active_lock);\n \t\t}\n \t\tmutex_unlock(&register_mutex);\n \t}\n  out:\n\tif (timeri->private_free)\n\t\ttimeri->private_free(timeri);\n\tkfree(timeri->owner);\n\tkfree(timeri);\n\tif (timer)\n\t\tmodule_put(timer->module);\n\treturn 0;\n}\n", "target": 1, "idx": 180574}
{"func": "static Bool leap_year(u32 year) {\n\tyear += 1900;\n\treturn (year % 4) == 0 && ((year % 100) != 0 || (year % 400) == 0) ? GF_TRUE : GF_FALSE;\n}\n", "target": 0, "idx": 90850}
{"func": "static void enforcedRangeLongLongAttrAttributeSetterCallback(v8::Local<v8::String>, v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)\n{\n    TRACE_EVENT_SET_SAMPLING_STATE(\"Blink\", \"DOMSetter\");\n    TestObjectV8Internal::enforcedRangeLongLongAttrAttributeSetter(jsValue, info);\n    TRACE_EVENT_SET_SAMPLING_STATE(\"V8\", \"V8Execution\");\n}\n", "target": 0, "idx": 130756}
{"func": "  gray_render_span( int             y,\n                    int             count,\n                    const FT_Span*  spans,\n                    PWorker         worker )\n  {\n    unsigned char*  p;\n    FT_Bitmap*      map = &worker->target;\n\n\n     /* first of all, compute the scanline offset */\n     p = (unsigned char*)map->buffer - y * map->pitch;\n     if ( map->pitch >= 0 )\n      p += ( map->rows - 1 ) * map->pitch;\n \n     for ( ; count > 0; count--, spans++ )\n     {\n      unsigned char  coverage = spans->coverage;\n\n\n      if ( coverage )\n      {\n        /* For small-spans it is faster to do it by ourselves than\n         * calling `memset'.  This is mainly due to the cost of the\n         * function call.\n         */\n        if ( spans->len >= 8 )\n          FT_MEM_SET( p + spans->x, (unsigned char)coverage, spans->len );\n        else\n        {\n          unsigned char*  q = p + spans->x;\n\n\n          switch ( spans->len )\n          {\n          case 7: *q++ = (unsigned char)coverage;\n          case 6: *q++ = (unsigned char)coverage;\n          case 5: *q++ = (unsigned char)coverage;\n          case 4: *q++ = (unsigned char)coverage;\n          case 3: *q++ = (unsigned char)coverage;\n          case 2: *q++ = (unsigned char)coverage;\n          case 1: *q   = (unsigned char)coverage;\n          default:\n            ;\n          }\n        }\n      }\n    }\n  }\n", "target": 1, "idx": 178176}
{"func": "static inline bool nested_svm_nmi(struct vcpu_svm *svm)\n{\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn true;\n\n\tif (!(svm->nested.intercept & (1ULL << INTERCEPT_NMI)))\n\t\treturn true;\n\n\tsvm->vmcb->control.exit_code = SVM_EXIT_NMI;\n\tsvm->nested.exit_required = true;\n\n\treturn false;\n}\n", "target": 0, "idx": 37791}
{"func": "GBool ArthurOutputDev::beginType3Char(GfxState *state, double x, double y,\n\t\t\t\t      double dx, double dy,\n\t\t\t\t      CharCode code, Unicode *u, int uLen)\n{\n  return gFalse;\n}\n", "target": 0, "idx": 845}
{"func": "error::Error GLES2DecoderPassthroughImpl::DoEndQueryEXT(GLenum target,\n                                                        uint32_t submit_count) {\n  if (IsEmulatedQueryTarget(target)) {\n    auto active_query_iter = active_queries_.find(target);\n    if (active_query_iter == active_queries_.end()) {\n      InsertError(GL_INVALID_OPERATION, \"No active query on target.\");\n      return error::kNoError;\n    }\n    if (target == GL_ASYNC_PIXEL_PACK_COMPLETED_CHROMIUM &&\n        !pending_read_pixels_.empty()) {\n      GLuint query_service_id = active_query_iter->second.service_id;\n      pending_read_pixels_.back().waiting_async_pack_queries.insert(\n          query_service_id);\n    }\n  } else {\n    CheckErrorCallbackState();\n\n    api()->glEndQueryFn(target);\n\n    if (CheckErrorCallbackState()) {\n      return error::kNoError;\n    }\n  }\n\n  DCHECK(active_queries_.find(target) != active_queries_.end());\n  ActiveQuery active_query = std::move(active_queries_[target]);\n  active_queries_.erase(target);\n\n  PendingQuery pending_query;\n  pending_query.target = target;\n  pending_query.service_id = active_query.service_id;\n  pending_query.shm = std::move(active_query.shm);\n  pending_query.sync = active_query.sync;\n  pending_query.submit_count = submit_count;\n  switch (target) {\n    case GL_COMMANDS_COMPLETED_CHROMIUM:\n      pending_query.commands_completed_fence = gl::GLFence::Create();\n      break;\n\n    case GL_READBACK_SHADOW_COPIES_UPDATED_CHROMIUM:\n      pending_query.buffer_shadow_update_fence = gl::GLFence::Create();\n      pending_query.buffer_shadow_updates = std::move(buffer_shadow_updates_);\n       buffer_shadow_updates_.clear();\n       break;\n \n     default:\n       break;\n   }\n  pending_queries_.push_back(std::move(pending_query));\n  return ProcessQueries(false);\n}\n", "target": 1, "idx": 186502}
{"func": "calc_delta_mine(unsigned long delta_exec, unsigned long weight,\n\t\tstruct load_weight *lw)\n{\n\tu64 tmp;\n\n\t/*\n\t * weight can be less than 2^SCHED_LOAD_RESOLUTION for task group sched\n\t * entities since MIN_SHARES = 2. Treat weight as 1 if less than\n\t * 2^SCHED_LOAD_RESOLUTION.\n\t */\n\tif (likely(weight > (1UL << SCHED_LOAD_RESOLUTION)))\n\t\ttmp = (u64)delta_exec * scale_load_down(weight);\n\telse\n\t\ttmp = (u64)delta_exec;\n\n\tif (!lw->inv_weight) {\n\t\tunsigned long w = scale_load_down(lw->weight);\n\n\t\tif (BITS_PER_LONG > 32 && unlikely(w >= WMULT_CONST))\n\t\t\tlw->inv_weight = 1;\n\t\telse if (unlikely(!w))\n\t\t\tlw->inv_weight = WMULT_CONST;\n\t\telse\n\t\t\tlw->inv_weight = WMULT_CONST / w;\n\t}\n\n\t/*\n\t * Check whether we'd overflow the 64-bit multiplication:\n\t */\n\tif (unlikely(tmp > WMULT_CONST))\n\t\ttmp = SRR(SRR(tmp, WMULT_SHIFT/2) * lw->inv_weight,\n\t\t\tWMULT_SHIFT/2);\n\telse\n\t\ttmp = SRR(tmp * lw->inv_weight, WMULT_SHIFT);\n\n\treturn (unsigned long)min(tmp, (u64)(unsigned long)LONG_MAX);\n}\n", "target": 0, "idx": 26261}
{"func": "write_stats(void)\n{\n\tFILE\t*fp;\n#ifdef DOSYNCTODR\n\tstruct timeval tv;\n#if !defined(VMS)\n\tint\tprio_set;\n#endif\n#ifdef HAVE_GETCLOCK\n\tstruct timespec ts;\n#endif\n\tint\to_prio;\n\n\t/*\n\t * Sometimes having a Sun can be a drag.\n\t *\n\t * The kernel variable dosynctodr controls whether the system's\n\t * soft clock is kept in sync with the battery clock. If it\n\t * is zero, then the soft clock is not synced, and the battery\n\t * clock is simply left to rot. That means that when the system\n\t * reboots, the battery clock (which has probably gone wacky)\n\t * sets the soft clock. That means ntpd starts off with a very\n\t * confused idea of what time it is. It then takes a large\n\t * amount of time to figure out just how wacky the battery clock\n\t * has made things drift, etc, etc. The solution is to make the\n\t * battery clock sync up to system time. The way to do THAT is\n\t * to simply set the time of day to the current time of day, but\n\t * as quickly as possible. This may, or may not be a sensible\n\t * thing to do.\n\t *\n\t * CAVEAT: settimeofday() steps the sun clock by about 800 us,\n\t *\t   so setting DOSYNCTODR seems a bad idea in the\n\t *\t   case of us resolution\n\t */\n\n#if !defined(VMS)\n\t/*\n\t * (prr) getpriority returns -1 on error, but -1 is also a valid\n\t * return value (!), so instead we have to zero errno before the\n\t * call and check it for non-zero afterwards.\n\t */\n\terrno = 0;\n\tprio_set = 0;\n\to_prio = getpriority(PRIO_PROCESS,0); /* Save setting */\n\n\t/*\n\t * (prr) if getpriority succeeded, call setpriority to raise\n\t * scheduling priority as high as possible.  If that succeeds\n\t * as well, set the prio_set flag so we remember to reset\n\t * priority to its previous value below.  Note that on Solaris\n\t * 2.6 (and beyond?), both getpriority and setpriority will fail\n\t * with ESRCH, because sched_setscheduler (called from main) put\n\t * us in the real-time scheduling class which setpriority\n\t * doesn't know about. Being in the real-time class is better\n\t * than anything setpriority can do, anyhow, so this error is\n\t * silently ignored.\n\t */\n\tif ((errno == 0) && (setpriority(PRIO_PROCESS,0,-20) == 0))\n\t\tprio_set = 1;\t/* overdrive */\n#endif /* VMS */\n#ifdef HAVE_GETCLOCK\n\t(void) getclock(TIMEOFDAY, &ts);\n\ttv.tv_sec = ts.tv_sec;\n\ttv.tv_usec = ts.tv_nsec / 1000;\n#else /*  not HAVE_GETCLOCK */\n\tGETTIMEOFDAY(&tv,(struct timezone *)NULL);\n#endif /* not HAVE_GETCLOCK */\n\tif (ntp_set_tod(&tv,(struct timezone *)NULL) != 0)\n\t\tmsyslog(LOG_ERR, \"can't sync battery time: %m\");\n#if !defined(VMS)\n\tif (prio_set)\n\t\tsetpriority(PRIO_PROCESS, 0, o_prio); /* downshift */\n#endif /* VMS */\n#endif /* DOSYNCTODR */\n\trecord_sys_stats();\n\tif (stats_drift_file != 0) {\n\n\t\t/*\n\t\t * When the frequency file is written, initialize the\n\t\t * prev_drift_comp and wander_resid. Thereafter,\n\t\t * reduce the wander_resid by half each hour. When\n\t\t * the difference between the prev_drift_comp and\n\t\t * drift_comp is less than the wander_resid, update\n\t\t * the frequncy file. This minimizes the file writes to\n\t\t * nonvolaile storage.\n\t\t */\n#ifdef DEBUG\n\t\tif (debug)\n\t\t\tprintf(\"write_stats: frequency %.6lf thresh %.6lf, freq %.6lf\\n\",\n\t\t\t    (prev_drift_comp - drift_comp) * 1e6, wander_resid *\n\t\t\t    1e6, drift_comp * 1e6);\n#endif\n\t\tif (fabs(prev_drift_comp - drift_comp) < wander_resid) {\n\t\t\twander_resid *= 0.5;\n\t\t\treturn;\n\t\t}\n\t\tprev_drift_comp = drift_comp;\n\t\twander_resid = wander_threshold;\n\t\tif ((fp = fopen(stats_temp_file, \"w\")) == NULL) {\n\t\t\tmsyslog(LOG_ERR, \"frequency file %s: %m\",\n\t\t\t    stats_temp_file);\n\t\t\treturn;\n\t\t}\n\t\tfprintf(fp, \"%.3f\\n\", drift_comp * 1e6);\n\t\t(void)fclose(fp);\n\t\t/* atomic */\n#ifdef SYS_WINNT\n\t\tif (_unlink(stats_drift_file)) /* rename semantics differ under NT */\n\t\t\tmsyslog(LOG_WARNING, \n\t\t\t\t\"Unable to remove prior drift file %s, %m\", \n\t\t\t\tstats_drift_file);\n#endif /* SYS_WINNT */\n\n#ifndef NO_RENAME\n\t\tif (rename(stats_temp_file, stats_drift_file))\n\t\t\tmsyslog(LOG_WARNING, \n\t\t\t\t\"Unable to rename temp drift file %s to %s, %m\", \n\t\t\t\tstats_temp_file, stats_drift_file);\n#else\n\t\t/* we have no rename NFS of ftp in use */\n\t\tif ((fp = fopen(stats_drift_file, \"w\")) ==\n\t\t    NULL) {\n\t\t\tmsyslog(LOG_ERR,\n\t\t\t    \"frequency file %s: %m\",\n\t\t\t    stats_drift_file);\n\t\t\treturn;\n\t\t}\n#endif\n\n#if defined(VMS)\n\t\t/* PURGE */\n\t\t{\n\t\t\t$DESCRIPTOR(oldvers,\";-1\");\n\t\t\tstruct dsc$descriptor driftdsc = {\n\t\t\t\tstrlen(stats_drift_file), 0, 0,\n\t\t\t\t    stats_drift_file };\n\t\t\twhile(lib$delete_file(&oldvers,\n\t\t\t    &driftdsc) & 1);\n\t\t}\n#endif\n\t}\n}\n", "target": 0, "idx": 74233}
{"func": "void SkippedMBMotionComp(\n VideoDecData *video\n)\n{\n Vop *prev = video->prevVop;\n Vop *comp;\n int ypos, xpos;\n    PIXEL *c_comp, *c_prev;\n    PIXEL *cu_comp, *cu_prev;\n    PIXEL *cv_comp, *cv_prev;\n int width, width_uv;\n int32 offset;\n#ifdef PV_POSTPROC_ON // 2/14/2001      \n int imv;\n int32 size = (int32) video->nTotalMB << 8;\n uint8 *pp_dec_y, *pp_dec_u;\n uint8 *pp_prev1;\n int mvwidth = video->nMBPerRow << 1;\n#endif\n\n    width = video->width;\n    width_uv  = width >> 1;\n    ypos = video->mbnum_row << 4 ;\n    xpos = video->mbnum_col << 4 ;\n    offset = (int32)ypos * width + xpos;\n\n\n \n     /* zero motion compensation for previous frame */\n     /*mby*width + mbx;*/\n    c_prev  = prev->yChan + offset;\n     /*by*width_uv + bx;*/\n     cu_prev = prev->uChan + (offset >> 2) + (xpos >> 2);\n     /*by*width_uv + bx;*/\n    cv_prev = prev->vChan + (offset >> 2) + (xpos >> 2);\n\n    comp = video->currVop;\n\n    c_comp  = comp->yChan + offset;\n    cu_comp = comp->uChan + (offset >> 2) + (xpos >> 2);\n    cv_comp = comp->vChan + (offset >> 2) + (xpos >> 2);\n\n\n /* Copy previous reconstructed frame into the current frame */\n PutSKIPPED_MB(c_comp,  c_prev, width);\n PutSKIPPED_B(cu_comp, cu_prev, width_uv);\n PutSKIPPED_B(cv_comp, cv_prev, width_uv);\n\n /*  10/24/2000 post_processing semaphore generation */\n#ifdef PV_POSTPROC_ON // 2/14/2001\n if (video->postFilterType != PV_NO_POST_PROC)\n {\n        imv = (offset >> 6) - (xpos >> 6) + (xpos >> 3);\n /* Post-processing mode (copy previous MB) */\n        pp_prev1 = video->pstprcTypPrv + imv;\n        pp_dec_y = video->pstprcTypCur + imv;\n *pp_dec_y = *pp_prev1;\n *(pp_dec_y + 1) = *(pp_prev1 + 1);\n *(pp_dec_y + mvwidth) = *(pp_prev1 + mvwidth);\n *(pp_dec_y + mvwidth + 1) = *(pp_prev1 + mvwidth + 1);\n\n /* chrominance */\n /*4*MB_in_width*MB_in_height*/\n        pp_prev1 = video->pstprcTypPrv + (size >> 6) +\n ((imv + (xpos >> 3)) >> 2);\n        pp_dec_u = video->pstprcTypCur + (size >> 6) +\n ((imv + (xpos >> 3)) >> 2);\n *pp_dec_u = *pp_prev1;\n        pp_dec_u[size>>8] = pp_prev1[size>>8];\n }\n#endif\n /*----------------------------------------------------------------------------\n    ; Return nothing or data or data pointer\n    ----------------------------------------------------------------------------*/\n\n return;\n}\n", "target": 1, "idx": 188027}
{"func": "static void display_motd() {\n\tFILE *fp;\n\tint c;\n\n\tif ((fp = fopen(\"/etc/motd\", \"r\"))) {\n\t\twhile ((c = getc(fp)) != EOF) {\n\t\t\tputchar(c);\n\t\t}\n\t\tfclose(fp);\n\t}\n}\n", "target": 0, "idx": 50290}
{"func": "static bool is_ereg(u32 reg)\n{\n\treturn (1 << reg) & (BIT(BPF_REG_5) |\n\t\t\t     BIT(AUX_REG) |\n\t\t\t     BIT(BPF_REG_7) |\n\t\t\t     BIT(BPF_REG_8) |\n\t\t\t     BIT(BPF_REG_9));\n}\n", "target": 0, "idx": 43031}
{"func": "unsigned long nr_iowait(void)\n{\n\tunsigned long i, sum = 0;\n\n\tfor_each_possible_cpu(i)\n\t\tsum += atomic_read(&cpu_rq(i)->nr_iowait);\n\n\treturn sum;\n}\n", "target": 0, "idx": 22494}
{"func": " static MagickBooleanType ReadDXT5(Image *image, DDSInfo *dds_info,\n  ExceptionInfo *exception)\n{\n  DDSColors\n    colors;\n\n  ssize_t\n    j,\n    y;\n\n  MagickSizeType\n    alpha_bits;\n\n  PixelPacket\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  unsigned char\n    a0,\n    a1;\n\n  size_t\n    alpha,\n    bits,\n    code,\n    alpha_code;\n\n  unsigned short\n    c0,\n    c1;\n\n  for (y = 0; y < (ssize_t) dds_info->height; y += 4)\n  {\n     for (x = 0; x < (ssize_t) dds_info->width; x += 4)\n     {\n       /* Get 4x4 patch of pixels to write on */\n      q = QueueAuthenticPixels(image, x, y, Min(4, dds_info->width - x),\n                         Min(4, dds_info->height - y),exception);\n \n       if (q == (PixelPacket *) NULL)\n         return MagickFalse;\n\n      /* Read alpha values (8 bytes) */\n      a0 = (unsigned char) ReadBlobByte(image);\n      a1 = (unsigned char) ReadBlobByte(image);\n\n      alpha_bits = (MagickSizeType)ReadBlobLSBLong(image);\n      alpha_bits = alpha_bits | ((MagickSizeType)ReadBlobLSBShort(image) << 32);\n\n      /* Read 8 bytes of data from the image */\n      c0 = ReadBlobLSBShort(image);\n      c1 = ReadBlobLSBShort(image);\n      bits = ReadBlobLSBLong(image);\n\n      CalculateColors(c0, c1, &colors, MagickTrue);\n\n      /* Write the pixels */\n      for (j = 0; j < 4; j++)\n      {\n        for (i = 0; i < 4; i++)\n        {\n          if ((x + i) < (ssize_t) dds_info->width && (y + j) < (ssize_t) dds_info->height)\n            {\n              code = (bits >> ((4*j+i)*2)) & 0x3;\n              SetPixelRed(q,ScaleCharToQuantum(colors.r[code]));\n              SetPixelGreen(q,ScaleCharToQuantum(colors.g[code]));\n              SetPixelBlue(q,ScaleCharToQuantum(colors.b[code]));\n              /* Extract alpha value */\n              alpha_code = (size_t) (alpha_bits >> (3*(4*j+i))) & 0x7;\n              if (alpha_code == 0)\n                alpha = a0;\n              else if (alpha_code == 1)\n                alpha = a1;\n              else if (a0 > a1)\n                alpha = ((8-alpha_code) * a0 + (alpha_code-1) * a1) / 7;\n              else if (alpha_code == 6)\n                alpha = 0;\n              else if (alpha_code == 7)\n                alpha = 255;\n              else\n                alpha = (((6-alpha_code) * a0 + (alpha_code-1) * a1) / 5);\n              SetPixelAlpha(q,ScaleCharToQuantum((unsigned char)\n                alpha));\n              q++;\n            }\n        }\n      }\n\n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        return MagickFalse;\n     }\n   }\n \n  SkipDXTMipmaps(image, dds_info, 16);\n  return MagickTrue;\n }\n", "target": 1, "idx": 182073}
{"func": "static NetworkRoamingState ParseRoamingState(\n    const std::string& roaming_state) {\n    if (roaming_state == kRoamingStateHome)\n    return ROAMING_STATE_HOME;\n  if (roaming_state == kRoamingStateRoaming)\n    return ROAMING_STATE_ROAMING;\n  if (roaming_state == kRoamingStateUnknown)\n    return ROAMING_STATE_UNKNOWN;\n  return ROAMING_STATE_UNKNOWN;\n}\n", "target": 0, "idx": 100280}
{"func": "static int kvm_vm_ioctl_reinject(struct kvm *kvm,\n\t\t\t\t struct kvm_reinject_control *control)\n{\n\tif (!kvm->arch.vpit)\n\t\treturn -ENXIO;\n\tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n\tkvm->arch.vpit->pit_state.pit_timer.reinject = control->pit_reinject;\n\tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n\treturn 0;\n}\n", "target": 0, "idx": 20848}
{"func": "DefaultAudioDestinationNode* DefaultAudioDestinationNode::Create(\n    BaseAudioContext* context,\n    const WebAudioLatencyHint& latency_hint) {\n  return MakeGarbageCollected<DefaultAudioDestinationNode>(*context,\n                                                           latency_hint);\n}\n", "target": 0, "idx": 143061}
{"func": "static void vmx_complete_atomic_exit(struct vcpu_vmx *vmx)\n{\n\tu32 exit_intr_info;\n\n\tif (!(vmx->exit_reason == EXIT_REASON_MCE_DURING_VMENTRY\n\t      || vmx->exit_reason == EXIT_REASON_EXCEPTION_NMI))\n\t\treturn;\n\n\tvmx->exit_intr_info = vmcs_read32(VM_EXIT_INTR_INFO);\n\texit_intr_info = vmx->exit_intr_info;\n\n\t/* Handle machine checks before interrupts are enabled */\n\tif (is_machine_check(exit_intr_info))\n \t\tkvm_machine_check();\n \n \t/* We need to handle NMIs before interrupts are enabled */\n\tif ((exit_intr_info & INTR_INFO_INTR_TYPE_MASK) == INTR_TYPE_NMI_INTR &&\n\t    (exit_intr_info & INTR_INFO_VALID_MASK)) {\n \t\tkvm_before_handle_nmi(&vmx->vcpu);\n \t\tasm(\"int $2\");\n \t\tkvm_after_handle_nmi(&vmx->vcpu);\n\t}\n}\n", "target": 1, "idx": 180029}
{"func": "static int peer_recv_callback(rdpTransport* transport, wStream* s, void* extra)\n{\n\tfreerdp_peer* client = (freerdp_peer*) extra;\n\trdpRdp* rdp = client->context->rdp;\n\n\tswitch (rdp->state)\n\t{\n\t\tcase CONNECTION_STATE_INITIAL:\n\t\t\tif (!rdp_server_accept_nego(rdp, s))\n\t\t\t\treturn -1;\n\n\t\t\tif (rdp->nego->selected_protocol & PROTOCOL_NLA)\n\t\t\t{\n \t\t\t\tsspi_CopyAuthIdentity(&client->identity, &(rdp->nego->transport->credssp->identity));\n \t\t\t\tIFCALLRET(client->Logon, client->authenticated, client, &client->identity, TRUE);\n \t\t\t\tcredssp_free(rdp->nego->transport->credssp);\n \t\t\t}\n \t\t\telse\n \t\t\t{\n\t\t\t\tIFCALLRET(client->Logon, client->authenticated, client, &client->identity, FALSE);\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_NEGO:\n\t\t\tif (!rdp_server_accept_mcs_connect_initial(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_CONNECT:\n\t\t\tif (!rdp_server_accept_mcs_erect_domain_request(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_ERECT_DOMAIN:\n\t\t\tif (!rdp_server_accept_mcs_attach_user_request(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_ATTACH_USER:\n\t\t\tif (!rdp_server_accept_mcs_channel_join_request(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_CHANNEL_JOIN:\n\t\t\tif (rdp->settings->DisableEncryption)\n\t\t\t{\n\t\t\t\tif (!rdp_server_accept_client_keys(rdp, s))\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trdp->state = CONNECTION_STATE_ESTABLISH_KEYS;\n\t\t\t/* FALLTHROUGH */\n\n\t\tcase CONNECTION_STATE_ESTABLISH_KEYS:\n\t\t\tif (!rdp_server_accept_client_info(rdp, s))\n\t\t\t\treturn -1;\n\n\t\t\tIFCALL(client->Capabilities, client);\n\n\t\t\tif (!rdp_send_demand_active(rdp))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_LICENSE:\n\t\t\tif (!rdp_server_accept_confirm_active(rdp, s))\n\t\t\t{\n\t\t\t\t/**\n\t\t\t\t * During reactivation sequence the client might sent some input or channel data\n\t\t\t\t * before receiving the Deactivate All PDU. We need to process them as usual.\n\t\t\t\t */\n\t\t\t\tStream_SetPosition(s, 0);\n\t\t\t\treturn peer_recv_pdu(client, s);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_ACTIVE:\n\t\t\tif (peer_recv_pdu(client, s) < 0)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Invalid state %d\\n\", rdp->state);\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n", "target": 1, "idx": 180772}
{"func": "void simulatePageScale(WebViewImpl* webViewImpl, float& scale)\n{\n    WebCore::IntSize scrollDelta = webViewImpl->fakePageScaleAnimationTargetPositionForTesting() - webViewImpl->mainFrameImpl()->frameView()->scrollPosition();\n    float scaleDelta = webViewImpl->fakePageScaleAnimationPageScaleForTesting() / webViewImpl->pageScaleFactor();\n    webViewImpl->applyScrollAndScale(scrollDelta, scaleDelta);\n    scale = webViewImpl->pageScaleFactor();\n}\n", "target": 0, "idx": 119541}
{"func": "static inline void mark_all_clean(struct vmcb *vmcb)\n{\n\tvmcb->control.clean = ((1 << VMCB_DIRTY_MAX) - 1)\n\t\t\t       & ~VMCB_ALWAYS_DIRTY_MASK;\n}\n", "target": 0, "idx": 37771}
{"func": "static int key_notify_policy_flush(const struct km_event *c)\n{\n\tstruct sk_buff *skb_out;\n\tstruct sadb_msg *hdr;\n\n\tskb_out = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);\n\tif (!skb_out)\n\t\treturn -ENOBUFS;\n\thdr = (struct sadb_msg *) skb_put(skb_out, sizeof(struct sadb_msg));\n\thdr->sadb_msg_type = SADB_X_SPDFLUSH;\n\thdr->sadb_msg_seq = c->seq;\n \thdr->sadb_msg_pid = c->portid;\n \thdr->sadb_msg_version = PF_KEY_V2;\n \thdr->sadb_msg_errno = (uint8_t) 0;\n \thdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));\n \tpfkey_broadcast(skb_out, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);\n \treturn 0;\n\n}\n", "target": 1, "idx": 179245}
{"func": " static MagickBooleanType CheckMemoryOverflow(const size_t count,\n   const size_t quantum)\n {\n  size_t\n    size;\n\n  size=count*quantum;\n  if ((count == 0) || (quantum != (size/count)))\n    {\n      errno=ENOMEM;\n      return(MagickTrue);\n    }\n  return(MagickFalse);\n}\n", "target": 0, "idx": 71857}
{"func": "long Track::GetNumber() const\n{\n    return m_info.number;\n}\n", "target": 1, "idx": 188371}
{"func": "LayoutBlockFlow::~LayoutBlockFlow()\n{\n}\n", "target": 0, "idx": 132138}
{"func": "ikev1_n_print(netdissect_options *ndo, u_char tpay _U_,\n\t      const struct isakmp_gen *ext, u_int item_len,\n\t      const u_char *ep, uint32_t phase _U_, uint32_t doi0 _U_,\n\t      uint32_t proto0 _U_, int depth _U_)\n{\n\tconst struct ikev1_pl_n *p;\n\tstruct ikev1_pl_n n;\n\tconst u_char *cp;\n\tconst u_char *ep2;\n\tuint32_t doi;\n\tuint32_t proto;\n\tstatic const char *notify_error_str[] = {\n\t\tNULL,\t\t\t\t\"INVALID-PAYLOAD-TYPE\",\n\t\t\"DOI-NOT-SUPPORTED\",\t\t\"SITUATION-NOT-SUPPORTED\",\n\t\t\"INVALID-COOKIE\",\t\t\"INVALID-MAJOR-VERSION\",\n\t\t\"INVALID-MINOR-VERSION\",\t\"INVALID-EXCHANGE-TYPE\",\n\t\t\"INVALID-FLAGS\",\t\t\"INVALID-MESSAGE-ID\",\n\t\t\"INVALID-PROTOCOL-ID\",\t\t\"INVALID-SPI\",\n\t\t\"INVALID-TRANSFORM-ID\",\t\t\"ATTRIBUTES-NOT-SUPPORTED\",\n\t\t\"NO-PROPOSAL-CHOSEN\",\t\t\"BAD-PROPOSAL-SYNTAX\",\n\t\t\"PAYLOAD-MALFORMED\",\t\t\"INVALID-KEY-INFORMATION\",\n\t\t\"INVALID-ID-INFORMATION\",\t\"INVALID-CERT-ENCODING\",\n\t\t\"INVALID-CERTIFICATE\",\t\t\"CERT-TYPE-UNSUPPORTED\",\n\t\t\"INVALID-CERT-AUTHORITY\",\t\"INVALID-HASH-INFORMATION\",\n\t\t\"AUTHENTICATION-FAILED\",\t\"INVALID-SIGNATURE\",\n\t\t\"ADDRESS-NOTIFICATION\",\t\t\"NOTIFY-SA-LIFETIME\",\n\t\t\"CERTIFICATE-UNAVAILABLE\",\t\"UNSUPPORTED-EXCHANGE-TYPE\",\n\t\t\"UNEQUAL-PAYLOAD-LENGTHS\",\n\t};\n\tstatic const char *ipsec_notify_error_str[] = {\n\t\t\"RESERVED\",\n\t};\n\tstatic const char *notify_status_str[] = {\n\t\t\"CONNECTED\",\n\t};\n\tstatic const char *ipsec_notify_status_str[] = {\n\t\t\"RESPONDER-LIFETIME\",\t\t\"REPLAY-STATUS\",\n\t\t\"INITIAL-CONTACT\",\n\t};\n/* NOTE: these macro must be called with x in proper range */\n\n/* 0 - 8191 */\n#define NOTIFY_ERROR_STR(x) \\\n\tSTR_OR_ID((x), notify_error_str)\n\n/* 8192 - 16383 */\n#define IPSEC_NOTIFY_ERROR_STR(x) \\\n\tSTR_OR_ID((u_int)((x) - 8192), ipsec_notify_error_str)\n\n/* 16384 - 24575 */\n#define NOTIFY_STATUS_STR(x) \\\n\tSTR_OR_ID((u_int)((x) - 16384), notify_status_str)\n\n/* 24576 - 32767 */\n#define IPSEC_NOTIFY_STATUS_STR(x) \\\n\tSTR_OR_ID((u_int)((x) - 24576), ipsec_notify_status_str)\n\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_N)));\n\n\tp = (const struct ikev1_pl_n *)ext;\n\tND_TCHECK(*p);\n\tUNALIGNED_MEMCPY(&n, ext, sizeof(n));\n\tdoi = ntohl(n.doi);\n\tproto = n.prot_id;\n\tif (doi != 1) {\n\t\tND_PRINT((ndo,\" doi=%d\", doi));\n\t\tND_PRINT((ndo,\" proto=%d\", proto));\n\t\tif (ntohs(n.type) < 8192)\n\t\t\tND_PRINT((ndo,\" type=%s\", NOTIFY_ERROR_STR(ntohs(n.type))));\n\t\telse if (ntohs(n.type) < 16384)\n\t\t\tND_PRINT((ndo,\" type=%s\", numstr(ntohs(n.type))));\n\t\telse if (ntohs(n.type) < 24576)\n\t\t\tND_PRINT((ndo,\" type=%s\", NOTIFY_STATUS_STR(ntohs(n.type))));\n\t\telse\n\t\t\tND_PRINT((ndo,\" type=%s\", numstr(ntohs(n.type))));\n\t\tif (n.spi_size) {\n\t\t\tND_PRINT((ndo,\" spi=\"));\n\t\t\tif (!rawprint(ndo, (const uint8_t *)(p + 1), n.spi_size))\n\t\t\t\tgoto trunc;\n\t\t}\n\t\treturn (const u_char *)(p + 1) + n.spi_size;\n\t}\n\n\tND_PRINT((ndo,\" doi=ipsec\"));\n\tND_PRINT((ndo,\" proto=%s\", PROTOIDSTR(proto)));\n\tif (ntohs(n.type) < 8192)\n\t\tND_PRINT((ndo,\" type=%s\", NOTIFY_ERROR_STR(ntohs(n.type))));\n\telse if (ntohs(n.type) < 16384)\n\t\tND_PRINT((ndo,\" type=%s\", IPSEC_NOTIFY_ERROR_STR(ntohs(n.type))));\n\telse if (ntohs(n.type) < 24576)\n\t\tND_PRINT((ndo,\" type=%s\", NOTIFY_STATUS_STR(ntohs(n.type))));\n\telse if (ntohs(n.type) < 32768)\n\t\tND_PRINT((ndo,\" type=%s\", IPSEC_NOTIFY_STATUS_STR(ntohs(n.type))));\n\telse\n\t\tND_PRINT((ndo,\" type=%s\", numstr(ntohs(n.type))));\n\tif (n.spi_size) {\n\t\tND_PRINT((ndo,\" spi=\"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(p + 1), n.spi_size))\n\t\t\tgoto trunc;\n\t}\n\n\tcp = (const u_char *)(p + 1) + n.spi_size;\n\tep2 = (const u_char *)p + item_len;\n\n\tif (cp < ep) {\n\t\tswitch (ntohs(n.type)) {\n\t\tcase IPSECDOI_NTYPE_RESPONDER_LIFETIME:\n\t\t    {\n\t\t\tconst struct attrmap *map = oakley_t_map;\n\t\t\tsize_t nmap = sizeof(oakley_t_map)/sizeof(oakley_t_map[0]);\n\t\t\tND_PRINT((ndo,\" attrs=(\"));\n\t\t\twhile (cp < ep && cp < ep2) {\n\t\t\t\tcp = ikev1_attrmap_print(ndo, cp, ep2, map, nmap);\n\t\t\t\tif (cp == NULL) {\n\t\t\t\t\tND_PRINT((ndo,\")\"));\n\t\t\t\t\tgoto trunc;\n\t\t\t\t}\n\t\t\t}\n\t\t\tND_PRINT((ndo,\")\"));\n\t\t\tbreak;\n\t\t    }\n\t\tcase IPSECDOI_NTYPE_REPLAY_STATUS:\n\t\t\tND_PRINT((ndo,\" status=(\"));\n\t\t\tND_PRINT((ndo,\"replay detection %sabled\",\n\t\t\t\t  EXTRACT_32BITS(cp) ? \"en\" : \"dis\"));\n\t\t\tND_PRINT((ndo,\")\"));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/*\n\t\t\t * XXX - fill in more types here; see, for example,\n\t\t\t * draft-ietf-ipsec-notifymsg-04.\n\t\t\t */\n\t\t\tif (ndo->ndo_vflag > 3) {\n\t\t\t\tND_PRINT((ndo,\" data=(\"));\n\t\t\t\tif (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))\n\t\t\t\t\tgoto trunc;\n\t\t\t\tND_PRINT((ndo,\")\"));\n\t\t\t} else {\n\t\t\t\tif (!ike_show_somedata(ndo, cp, ep))\n\t\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (const u_char *)ext + item_len;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_N)));\n\treturn NULL;\n}\n", "target": 0, "idx": 61994}
{"func": "static inline __u32 __peek_user_per_compat(struct task_struct *child,\n\t\t\t\t\t   addr_t addr)\n{\n\tstruct compat_per_struct_kernel *dummy32 = NULL;\n\n\tif (addr == (addr_t) &dummy32->cr9)\n\t\t/* Control bits of the active per set. */\n\t\treturn (__u32) test_thread_flag(TIF_SINGLE_STEP) ?\n\t\t\tPER_EVENT_IFETCH : child->thread.per_user.control;\n\telse if (addr == (addr_t) &dummy32->cr10)\n\t\t/* Start address of the active per set. */\n\t\treturn (__u32) test_thread_flag(TIF_SINGLE_STEP) ?\n\t\t\t0 : child->thread.per_user.start;\n\telse if (addr == (addr_t) &dummy32->cr11)\n\t\t/* End address of the active per set. */\n\t\treturn test_thread_flag(TIF_SINGLE_STEP) ?\n\t\t\tPSW32_ADDR_INSN : child->thread.per_user.end;\n\telse if (addr == (addr_t) &dummy32->bits)\n\t\t/* Single-step bit. */\n\t\treturn (__u32) test_thread_flag(TIF_SINGLE_STEP) ?\n\t\t\t0x80000000 : 0;\n\telse if (addr == (addr_t) &dummy32->starting_addr)\n\t\t/* Start address of the user specified per set. */\n\t\treturn (__u32) child->thread.per_user.start;\n\telse if (addr == (addr_t) &dummy32->ending_addr)\n\t\t/* End address of the user specified per set. */\n\t\treturn (__u32) child->thread.per_user.end;\n\telse if (addr == (addr_t) &dummy32->perc_atmid)\n\t\t/* PER code, ATMID and AI of the last PER trap */\n\t\treturn (__u32) child->thread.per_event.cause << 16;\n\telse if (addr == (addr_t) &dummy32->address)\n\t\t/* Address of the last PER trap */\n\t\treturn (__u32) child->thread.per_event.address;\n\telse if (addr == (addr_t) &dummy32->access_id)\n\t\t/* Access id of the last PER trap */\n\t\treturn (__u32) child->thread.per_event.paid << 24;\n\treturn 0;\n}\n", "target": 0, "idx": 38016}
{"func": "     void makeCurrent()\n     {\n#if PLATFORM(QT)\n        m_detachedContext = QOpenGLContext::currentContext();\n        if (m_detachedContext)\n            m_detachedSurface = m_detachedContext->surface();\n        if (m_surface && m_glContext)\n            m_glContext->makeCurrent(m_surface.get());\n#elif PLATFORM(EFL)\n         m_detachedContext = glXGetCurrentContext();\n         m_detachedSurface = glXGetCurrentDrawable();\n         if (m_surface && m_glContext)\n             glXMakeCurrent(m_display, m_surface, m_glContext);\n#endif\n     }\n", "target": 1, "idx": 183712}
{"func": "static int asn1_decode_p15_object(sc_context_t *ctx, const u8 *in,\n\t\t\t\t  size_t len, struct sc_asn1_pkcs15_object *obj,\n\t\t\t\t  int depth)\n{\n\tstruct sc_pkcs15_object *p15_obj = obj->p15_obj;\n\tstruct sc_asn1_entry asn1_c_attr[6], asn1_p15_obj[5];\n\tstruct sc_asn1_entry asn1_ac_rules[SC_PKCS15_MAX_ACCESS_RULES + 1], asn1_ac_rule[SC_PKCS15_MAX_ACCESS_RULES][3];\n\tsize_t flags_len = sizeof(p15_obj->flags);\n\tsize_t label_len = sizeof(p15_obj->label);\n\tsize_t access_mode_len = sizeof(p15_obj->access_rules[0].access_mode);\n\tint r, ii;\n\n\tfor (ii=0; ii<SC_PKCS15_MAX_ACCESS_RULES; ii++)\n\t\tsc_copy_asn1_entry(c_asn1_access_control_rule, asn1_ac_rule[ii]);\n\tsc_copy_asn1_entry(c_asn1_access_control_rules, asn1_ac_rules);\n\n\n\tsc_copy_asn1_entry(c_asn1_com_obj_attr, asn1_c_attr);\n\tsc_copy_asn1_entry(c_asn1_p15_obj, asn1_p15_obj);\n\tsc_format_asn1_entry(asn1_c_attr + 0, p15_obj->label, &label_len, 0);\n\tsc_format_asn1_entry(asn1_c_attr + 1, &p15_obj->flags, &flags_len, 0);\n\tsc_format_asn1_entry(asn1_c_attr + 2, &p15_obj->auth_id, NULL, 0);\n\tsc_format_asn1_entry(asn1_c_attr + 3, &p15_obj->user_consent, NULL, 0);\n\n\tfor (ii=0; ii<SC_PKCS15_MAX_ACCESS_RULES; ii++)   {\n\t\tsc_format_asn1_entry(asn1_ac_rule[ii] + 0, &p15_obj->access_rules[ii].access_mode, &access_mode_len, 0);\n\t\tsc_format_asn1_entry(asn1_ac_rule[ii] + 1, &p15_obj->access_rules[ii].auth_id, NULL, 0);\n\t\tsc_format_asn1_entry(asn1_ac_rules + ii, asn1_ac_rule[ii], NULL, 0);\n\t}\n\tsc_format_asn1_entry(asn1_c_attr + 4, asn1_ac_rules, NULL, 0);\n\n\tsc_format_asn1_entry(asn1_p15_obj + 0, asn1_c_attr, NULL, 0);\n\tsc_format_asn1_entry(asn1_p15_obj + 1, obj->asn1_class_attr, NULL, 0);\n\tsc_format_asn1_entry(asn1_p15_obj + 2, obj->asn1_subclass_attr, NULL, 0);\n\tsc_format_asn1_entry(asn1_p15_obj + 3, obj->asn1_type_attr, NULL, 0);\n\n\tr = asn1_decode(ctx, asn1_p15_obj, in, len, NULL, NULL, 0, depth + 1);\n\treturn r;\n}\n", "target": 0, "idx": 78102}
{"func": "int invalidate_partition(struct gendisk *disk, int partno)\n{\n\tint res = 0;\n\tstruct block_device *bdev = bdget_disk(disk, partno);\n\tif (bdev) {\n\t\tfsync_bdev(bdev);\n\t\tres = __invalidate_device(bdev, true);\n\t\tbdput(bdev);\n\t}\n\treturn res;\n}\n", "target": 0, "idx": 49708}
{"func": "void RenderFrameImpl::OnGetSerializedHtmlWithLocalLinks(\n    const std::map<GURL, base::FilePath>& url_to_local_path,\n    const std::map<int, base::FilePath>& frame_routing_id_to_local_path) {\n  LinkRewritingDelegate delegate(url_to_local_path,\n                                 frame_routing_id_to_local_path);\n\n  WebFrameSerializer::Serialize(GetWebFrame(),\n                                this,  // WebFrameSerializerClient.\n                                &delegate);\n}\n", "target": 0, "idx": 160663}
{"func": " static int atusb_get_and_show_revision(struct atusb *atusb)\n {\n \tstruct usb_device *usb_dev = atusb->usb_dev;\n\tunsigned char buffer[3];\n \tint ret;\n \n \t/* Get a couple of the ATMega Firmware values */\n \tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n \t\t\t\tATUSB_ID, ATUSB_REQ_FROM_DEV, 0, 0,\n\t\t\t\tbuffer, 3, 1000);\n\tif (ret >= 0) {\n\t\tatusb->fw_ver_maj = buffer[0];\n\t\tatusb->fw_ver_min = buffer[1];\n\t\tatusb->fw_hw_type = buffer[2];\n\n\t\tdev_info(&usb_dev->dev,\n\t\t\t \"Firmware: major: %u, minor: %u, hardware type: %u\\n\",\n\t\t\t atusb->fw_ver_maj, atusb->fw_ver_min, atusb->fw_hw_type);\n\t}\n\tif (atusb->fw_ver_maj == 0 && atusb->fw_ver_min < 2) {\n\t\tdev_info(&usb_dev->dev,\n\t\t\t \"Firmware version (%u.%u) predates our first public release.\",\n\t\t\t atusb->fw_ver_maj, atusb->fw_ver_min);\n \t\tdev_info(&usb_dev->dev, \"Please update to version 0.2 or newer\");\n \t}\n \n \treturn ret;\n }\n", "target": 1, "idx": 181563}
{"func": "void svc_rdma_send_error(struct svcxprt_rdma *xprt, struct rpcrdma_msg *rmsgp,\n\t\t\t int status)\n{\n\tstruct ib_send_wr err_wr;\n\tstruct page *p;\n\tstruct svc_rdma_op_ctxt *ctxt;\n\tenum rpcrdma_errcode err;\n\t__be32 *va;\n\tint length;\n\tint ret;\n\tret = svc_rdma_repost_recv(xprt, GFP_KERNEL);\n\tif (ret)\n\t\treturn;\n\tp = alloc_page(GFP_KERNEL);\n\tif (!p)\n\t\treturn;\n\tva = page_address(p);\n\t/* XDR encode an error reply */\n\terr = ERR_CHUNK;\n\tif (status == -EPROTONOSUPPORT)\n\t\terr = ERR_VERS;\n\tlength = svc_rdma_xdr_encode_error(xprt, rmsgp, err, va);\n\tctxt = svc_rdma_get_context(xprt);\n\tctxt->direction = DMA_TO_DEVICE;\n\tctxt->count = 1;\n\tctxt->pages[0] = p;\n\t/* Prepare SGE for local address */\n\tctxt->sge[0].lkey = xprt->sc_pd->local_dma_lkey;\n\tctxt->sge[0].length = length;\n\tctxt->sge[0].addr = ib_dma_map_page(xprt->sc_cm_id->device,\n\t\t\t\t\t    p, 0, length, DMA_TO_DEVICE);\n\tif (ib_dma_mapping_error(xprt->sc_cm_id->device, ctxt->sge[0].addr)) {\n\t\tdprintk(\"svcrdma: Error mapping buffer for protocol error\\n\");\n\t\tsvc_rdma_put_context(ctxt, 1);\n\t\treturn;\n\t}\n\tsvc_rdma_count_mappings(xprt, ctxt);\n\t/* Prepare SEND WR */\n\tmemset(&err_wr, 0, sizeof(err_wr));\n\tctxt->cqe.done = svc_rdma_wc_send;\n\terr_wr.wr_cqe = &ctxt->cqe;\n\terr_wr.sg_list = ctxt->sge;\n\terr_wr.num_sge = 1;\n\terr_wr.opcode = IB_WR_SEND;\n\terr_wr.send_flags = IB_SEND_SIGNALED;\n\t/* Post It */\n\tret = svc_rdma_send(xprt, &err_wr);\n\tif (ret) {\n\t\tdprintk(\"svcrdma: Error %d posting send for protocol error\\n\",\n\t\t\tret);\n\t\tsvc_rdma_unmap_dma(ctxt);\n\t\tsvc_rdma_put_context(ctxt, 1);\n\t}\n}\n", "target": 1, "idx": 181346}
{"func": "rar_read_ahead(struct archive_read *a, size_t min, ssize_t *avail)\n{\n  struct rar *rar = (struct rar *)(a->format->data);\n  const void *h = __archive_read_ahead(a, min, avail);\n  int ret;\n  if (avail)\n  {\n    if (a->archive.read_data_is_posix_read && *avail > (ssize_t)a->archive.read_data_requested)\n      *avail = a->archive.read_data_requested;\n    if (*avail > rar->bytes_remaining)\n      *avail = (ssize_t)rar->bytes_remaining;\n    if (*avail < 0)\n      return NULL;\n     else if (*avail == 0 && rar->main_flags & MHD_VOLUME &&\n       rar->file_flags & FHD_SPLIT_AFTER)\n     {\n       ret = archive_read_format_rar_read_header(a, a->entry);\n       if (ret == (ARCHIVE_EOF))\n       {\n         rar->has_endarc_header = 1;\n         ret = archive_read_format_rar_read_header(a, a->entry);\n       }\n       if (ret != (ARCHIVE_OK))\n         return NULL;\n       return rar_read_ahead(a, min, avail);\n    }\n  }\n  return h;\n}\n", "target": 1, "idx": 182102}
{"func": "status_t SampleIterator::seekTo(uint32_t sampleIndex) {\n    ALOGV(\"seekTo(%d)\", sampleIndex);\n\n if (sampleIndex >= mTable->mNumSampleSizes) {\n return ERROR_END_OF_STREAM;\n }\n\n if (mTable->mSampleToChunkOffset < 0\n || mTable->mChunkOffsetOffset < 0\n || mTable->mSampleSizeOffset < 0\n || mTable->mTimeToSampleCount == 0) {\n\n return ERROR_MALFORMED;\n }\n\n if (mInitialized && mCurrentSampleIndex == sampleIndex) {\n return OK;\n }\n\n if (!mInitialized || sampleIndex < mFirstChunkSampleIndex) {\n        reset();\n }\n\n if (sampleIndex >= mStopChunkSampleIndex) {\n status_t err;\n if ((err = findChunkRange(sampleIndex)) != OK) {\n            ALOGE(\"findChunkRange failed\");\n return err;\n }\n }\n\n \n     CHECK(sampleIndex < mStopChunkSampleIndex);\n \n     uint32_t chunk =\n         (sampleIndex - mFirstChunkSampleIndex) / mSamplesPerChunk\n         + mFirstChunk;\n\n if (!mInitialized || chunk != mCurrentChunkIndex) {\n        mCurrentChunkIndex = chunk;\n\n status_t err;\n if ((err = getChunkOffset(chunk, &mCurrentChunkOffset)) != OK) {\n            ALOGE(\"getChunkOffset return error\");\n return err;\n }\n\n        mCurrentChunkSampleSizes.clear();\n\n uint32_t firstChunkSampleIndex =\n            mFirstChunkSampleIndex\n + mSamplesPerChunk * (mCurrentChunkIndex - mFirstChunk);\n\n for (uint32_t i = 0; i < mSamplesPerChunk; ++i) {\n size_t sampleSize;\n if ((err = getSampleSizeDirect(\n                            firstChunkSampleIndex + i, &sampleSize)) != OK) {\n                ALOGE(\"getSampleSizeDirect return error\");\n return err;\n }\n\n            mCurrentChunkSampleSizes.push(sampleSize);\n }\n }\n\n uint32_t chunkRelativeSampleIndex =\n (sampleIndex - mFirstChunkSampleIndex) % mSamplesPerChunk;\n\n    mCurrentSampleOffset = mCurrentChunkOffset;\n for (uint32_t i = 0; i < chunkRelativeSampleIndex; ++i) {\n        mCurrentSampleOffset += mCurrentChunkSampleSizes[i];\n }\n\n    mCurrentSampleSize = mCurrentChunkSampleSizes[chunkRelativeSampleIndex];\n if (sampleIndex < mTTSSampleIndex) {\n        mTimeToSampleIndex = 0;\n        mTTSSampleIndex = 0;\n        mTTSSampleTime = 0;\n        mTTSCount = 0;\n        mTTSDuration = 0;\n }\n\n status_t err;\n if ((err = findSampleTimeAndDuration(\n            sampleIndex, &mCurrentSampleTime, &mCurrentSampleDuration)) != OK) {\n        ALOGE(\"findSampleTime return error\");\n return err;\n }\n\n    mCurrentSampleIndex = sampleIndex;\n\n    mInitialized = true;\n\n return OK;\n}\n", "target": 1, "idx": 187788}
{"func": "parse_escapes(char *src, struct mtree_entry *mentry)\n{\n\tchar *dest = src;\n\tchar c;\n\n\tif (mentry != NULL && strcmp(src, \".\") == 0)\n\t\tmentry->full = 1;\n\n\twhile (*src != '\\0') {\n\t\tc = *src++;\n\t\tif (c == '/' && mentry != NULL)\n\t\t\tmentry->full = 1;\n\t\tif (c == '\\\\') {\n\t\t\tswitch (src[0]) {\n\t\t\tcase '0':\n\t\t\t\tif (src[1] < '0' || src[1] > '7') {\n\t\t\t\t\tc = 0;\n\t\t\t\t\t++src;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase '1':\n\t\t\tcase '2':\n\t\t\tcase '3':\n\t\t\t\tif (src[1] >= '0' && src[1] <= '7' &&\n\t\t\t\t    src[2] >= '0' && src[2] <= '7') {\n\t\t\t\t\tc = (src[0] - '0') << 6;\n\t\t\t\t\tc |= (src[1] - '0') << 3;\n\t\t\t\t\tc |= (src[2] - '0');\n\t\t\t\t\tsrc += 3;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'a':\n\t\t\t\tc = '\\a';\n\t\t\t\t++src;\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\t\tc = '\\b';\n\t\t\t\t++src;\n\t\t\t\tbreak;\n\t\t\tcase 'f':\n\t\t\t\tc = '\\f';\n\t\t\t\t++src;\n\t\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\tc = '\\n';\n\t\t\t\t++src;\n\t\t\t\tbreak;\n\t\t\tcase 'r':\n\t\t\t\tc = '\\r';\n\t\t\t\t++src;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\tc = ' ';\n\t\t\t\t++src;\n\t\t\t\tbreak;\n\t\t\tcase 't':\n\t\t\t\tc = '\\t';\n\t\t\t\t++src;\n\t\t\t\tbreak;\n\t\t\tcase 'v':\n\t\t\t\tc = '\\v';\n\t\t\t\t++src;\n\t\t\t\tbreak;\n\t\t\tcase '\\\\':\n\t\t\t\tc = '\\\\';\n\t\t\t\t++src;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t*dest++ = c;\n\t}\n\t*dest = '\\0';\n}\n", "target": 0, "idx": 53518}
{"func": "ikev2_auth_print(netdissect_options *ndo, u_char tpay,\n\t\tconst struct isakmp_gen *ext,\n\t\tu_int item_len _U_, const u_char *ep,\n\t\tuint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tstruct ikev2_auth a;\n\tconst char *v2_auth[]={ \"invalid\", \"rsasig\",\n\t\t\t\t\"shared-secret\", \"dsssig\" };\n \tconst u_char *authdata = (const u_char*)ext + sizeof(a);\n \tunsigned int len;\n \n\tND_TCHECK(*ext);\n \tUNALIGNED_MEMCPY(&a, ext, sizeof(a));\n \tikev2_pay_print(ndo, NPSTR(tpay), a.h.critical);\n \tlen = ntohs(a.h.len);\n\n\t/*\n\t * Our caller has ensured that the length is >= 4.\n\t */\n\tND_PRINT((ndo,\" len=%u method=%s\", len-4,\n\t\t  STR_OR_ID(a.auth_method, v2_auth)));\n\tif (len > 4) {\n\t\tif (ndo->ndo_vflag > 1) {\n\t\t\tND_PRINT((ndo, \" authdata=(\"));\n\t\t\tif (!rawprint(ndo, (const uint8_t *)authdata, len - sizeof(a)))\n\t\t\t\tgoto trunc;\n\t\t\tND_PRINT((ndo, \") \"));\n\t\t} else if (ndo->ndo_vflag) {\n\t\t\tif (!ike_show_somedata(ndo, authdata, ep))\n\t\t\t\tgoto trunc;\n\t\t}\n\t}\n\n\treturn (const u_char *)ext + len;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(tpay)));\n\treturn NULL;\n}\n", "target": 1, "idx": 180969}
{"func": "IMPEG2D_ERROR_CODES_T impeg2d_dec_seq_hdr(dec_state_t *ps_dec)\n{\n stream_t *ps_stream;\n    ps_stream = &ps_dec->s_bit_stream;\n    UWORD16 u2_height;\n    UWORD16 u2_width;\n\n if (impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != SEQUENCE_HEADER_CODE)\n {\n        impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n return IMPEG2D_FRM_HDR_START_CODE_NOT_FOUND;\n\n }\n    impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n\n    u2_width    = impeg2d_bit_stream_get(ps_stream,12);\n    u2_height   = impeg2d_bit_stream_get(ps_stream,12);\n\n if (0 == u2_width || 0 == u2_height)\n {\n        IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_FRM_HDR_DECODE_ERR;\n return e_error;\n }\n\n if ((u2_width != ps_dec->u2_horizontal_size)\n || (u2_height != ps_dec->u2_vertical_size))\n {\n if (0 == ps_dec->u2_header_done)\n {\n\n             /* This is the first time we are reading the resolution */\n             ps_dec->u2_horizontal_size = u2_width;\n             ps_dec->u2_vertical_size = u2_height;\n            if (0 == ps_dec->u4_frm_buf_stride)\n            {\n                ps_dec->u4_frm_buf_stride  = (UWORD32) (u2_width);\n            }\n         }\n         else\n         {\n if (0 == ps_dec->i4_pic_count)\n {\n /* Decoder has not decoded a single frame since the last\n                 * reset/init. This implies that we have two headers in the\n                 * input stream. So, do not indicate a resolution change, since\n                 * this can take the decoder into an infinite loop.\n                 */\n return (IMPEG2D_ERROR_CODES_T) IMPEG2D_FRM_HDR_DECODE_ERR;\n }\n else if((u2_width > ps_dec->u2_create_max_width)\n || (u2_height > ps_dec->u2_create_max_height))\n {\n                IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS;\n\n                ps_dec->u2_reinit_max_height   = u2_height;\n                ps_dec->u2_reinit_max_width    = u2_width;\n\n \n                 return e_error;\n             }\n             else\n             {\n                 /* The resolution has changed */\n return (IMPEG2D_ERROR_CODES_T)IVD_RES_CHANGED;\n }\n }\n }\n\n if((ps_dec->u2_horizontal_size > ps_dec->u2_create_max_width)\n || (ps_dec->u2_vertical_size > ps_dec->u2_create_max_height))\n {\n        IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS;\n        ps_dec->u2_reinit_max_height   = ps_dec->u2_vertical_size;\n        ps_dec->u2_reinit_max_width    = ps_dec->u2_horizontal_size;\n\n         return e_error;\n     }\n \n \n     /*------------------------------------------------------------------------*/\n     /* Flush the following as they are not being used                         */\n /* aspect_ratio_info (4 bits)                                             */\n /*------------------------------------------------------------------------*/\n    ps_dec->u2_aspect_ratio_info = impeg2d_bit_stream_get(ps_stream,4);\n\n /*------------------------------------------------------------------------*/\n /* Frame rate code(4 bits)                                                */\n /*------------------------------------------------------------------------*/\n    ps_dec->u2_frame_rate_code = impeg2d_bit_stream_get(ps_stream,4);\n if (ps_dec->u2_frame_rate_code > MPEG2_MAX_FRAME_RATE_CODE)\n {\n return IMPEG2D_FRM_HDR_DECODE_ERR;\n }\n /*------------------------------------------------------------------------*/\n /* Flush the following as they are not being used                         */\n /* bit_rate_value (18 bits)                                               */\n /*------------------------------------------------------------------------*/\n    impeg2d_bit_stream_flush(ps_stream,18);\n    GET_MARKER_BIT(ps_dec,ps_stream);\n /*------------------------------------------------------------------------*/\n /* Flush the following as they are not being used                         */\n /* vbv_buffer_size_value(10 bits), constrained_parameter_flag (1 bit)     */\n /*------------------------------------------------------------------------*/\n    impeg2d_bit_stream_flush(ps_stream,11);\n\n /*------------------------------------------------------------------------*/\n /* Quantization matrix for the intra blocks                               */\n /*------------------------------------------------------------------------*/\n if(impeg2d_bit_stream_get_bit(ps_stream) == 1)\n {\n        UWORD16 i;\n for(i = 0; i < NUM_PELS_IN_BLOCK; i++)\n {\n            ps_dec->au1_intra_quant_matrix[gau1_impeg2_inv_scan_zig_zag[i]] = (UWORD8)impeg2d_bit_stream_get(ps_stream,8);\n }\n\n }\n else\n {\n        memcpy(ps_dec->au1_intra_quant_matrix,gau1_impeg2_intra_quant_matrix_default,\n                NUM_PELS_IN_BLOCK);\n }\n\n /*------------------------------------------------------------------------*/\n /* Quantization matrix for the inter blocks                               */\n /*------------------------------------------------------------------------*/\n if(impeg2d_bit_stream_get_bit(ps_stream) == 1)\n {\n        UWORD16 i;\n for(i = 0; i < NUM_PELS_IN_BLOCK; i++)\n {\n            ps_dec->au1_inter_quant_matrix[gau1_impeg2_inv_scan_zig_zag[i]] = (UWORD8)impeg2d_bit_stream_get(ps_stream,8);\n }\n }\n else\n {\n        memcpy(ps_dec->au1_inter_quant_matrix,gau1_impeg2_inter_quant_matrix_default,\n            NUM_PELS_IN_BLOCK);\n }\n    impeg2d_next_start_code(ps_dec);\n\n return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;\n}\n", "target": 1, "idx": 188107}
{"func": "_tiffReadProc(thandle_t fd, tdata_t buf, tsize_t size)\n{\n\treturn (read((int) fd, buf, size));\n}\n", "target": 0, "idx": 86791}
{"func": "static Image *ReadJPEGImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    value[MaxTextExtent];\n\n  const char\n    *option;\n\n  ErrorManager\n    error_manager;\n\n  Image\n    *image;\n\n  IndexPacket\n    index;\n\n  JSAMPLE\n    *volatile jpeg_pixels;\n\n  JSAMPROW\n    scanline[1];\n\n  MagickBooleanType\n    debug,\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  MemoryInfo\n    *memory_info;\n\n  register ssize_t\n    i;\n\n  struct jpeg_decompress_struct\n    jpeg_info;\n\n  struct jpeg_error_mgr\n    jpeg_error;\n\n  register JSAMPLE\n    *p;\n\n  size_t\n    units;\n\n  ssize_t\n    y;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  debug=IsEventLogging();\n  (void) debug;\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n       image=DestroyImageList(image);\n       return((Image *) NULL);\n     }\n   /*\n     Initialize JPEG parameters.\n   */\n  (void) ResetMagickMemory(&error_manager,0,sizeof(error_manager));\n  (void) ResetMagickMemory(&jpeg_info,0,sizeof(jpeg_info));\n  (void) ResetMagickMemory(&jpeg_error,0,sizeof(jpeg_error));\n  jpeg_info.err=jpeg_std_error(&jpeg_error);\n  jpeg_info.err->emit_message=(void (*)(j_common_ptr,int)) JPEGWarningHandler;\n  jpeg_info.err->error_exit=(void (*)(j_common_ptr)) JPEGErrorHandler;\n  memory_info=(MemoryInfo *) NULL;\n  error_manager.image=image;\n  if (setjmp(error_manager.error_recovery) != 0)\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      if (error_manager.profile != (StringInfo *) NULL)\n        error_manager.profile=DestroyStringInfo(error_manager.profile);\n      (void) CloseBlob(image);\n      number_pixels=(MagickSizeType) image->columns*image->rows;\n      if (number_pixels != 0)\n        return(GetFirstImageInList(image));\n      InheritException(exception,&image->exception);\n      return(DestroyImage(image));\n    }\n  jpeg_info.client_data=(void *) &error_manager;\n  jpeg_create_decompress(&jpeg_info);\n  JPEGSourceManager(&jpeg_info,image);\n  jpeg_set_marker_processor(&jpeg_info,JPEG_COM,ReadComment);\n  option=GetImageOption(image_info,\"profile:skip\");\n  if (IsOptionMember(\"ICC\",option) == MagickFalse)\n    jpeg_set_marker_processor(&jpeg_info,ICC_MARKER,ReadICCProfile);\n  if (IsOptionMember(\"IPTC\",option) == MagickFalse)\n    jpeg_set_marker_processor(&jpeg_info,IPTC_MARKER,ReadIPTCProfile);\n  for (i=1; i < 16; i++)\n    if ((i != 2) && (i != 13) && (i != 14))\n      if (IsOptionMember(\"APP\",option) == MagickFalse)\n        jpeg_set_marker_processor(&jpeg_info,(int) (JPEG_APP0+i),ReadProfile);\n  i=(ssize_t) jpeg_read_header(&jpeg_info,TRUE);\n  if ((image_info->colorspace == YCbCrColorspace) ||\n      (image_info->colorspace == Rec601YCbCrColorspace) ||\n      (image_info->colorspace == Rec709YCbCrColorspace))\n    jpeg_info.out_color_space=JCS_YCbCr;\n  /*\n    Set image resolution.\n  */\n  units=0;\n  if ((jpeg_info.saw_JFIF_marker != 0) && (jpeg_info.X_density != 1) &&\n      (jpeg_info.Y_density != 1))\n    {\n      image->x_resolution=(double) jpeg_info.X_density;\n      image->y_resolution=(double) jpeg_info.Y_density;\n      units=(size_t) jpeg_info.density_unit;\n    }\n  if (units == 1)\n    image->units=PixelsPerInchResolution;\n  if (units == 2)\n    image->units=PixelsPerCentimeterResolution;\n  number_pixels=(MagickSizeType) image->columns*image->rows;\n  option=GetImageOption(image_info,\"jpeg:size\");\n  if ((option != (const char *) NULL) &&\n      (jpeg_info.out_color_space != JCS_YCbCr))\n    {\n      double\n        scale_factor;\n\n      GeometryInfo\n        geometry_info;\n\n      MagickStatusType\n        flags;\n\n      /*\n        Scale the image.\n      */\n      flags=ParseGeometry(option,&geometry_info);\n      if ((flags & SigmaValue) == 0)\n        geometry_info.sigma=geometry_info.rho;\n      jpeg_calc_output_dimensions(&jpeg_info);\n      image->magick_columns=jpeg_info.output_width;\n      image->magick_rows=jpeg_info.output_height;\n      scale_factor=1.0;\n      if (geometry_info.rho != 0.0)\n        scale_factor=jpeg_info.output_width/geometry_info.rho;\n      if ((geometry_info.sigma != 0.0) &&\n          (scale_factor > (jpeg_info.output_height/geometry_info.sigma)))\n        scale_factor=jpeg_info.output_height/geometry_info.sigma;\n      jpeg_info.scale_num=1U;\n      jpeg_info.scale_denom=(unsigned int) scale_factor;\n      jpeg_calc_output_dimensions(&jpeg_info);\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Scale factor: %.20g\",(double) scale_factor);\n    }\n#if (JPEG_LIB_VERSION >= 61) && defined(D_PROGRESSIVE_SUPPORTED)\n#if defined(D_LOSSLESS_SUPPORTED)\n  image->interlace=jpeg_info.process == JPROC_PROGRESSIVE ?\n    JPEGInterlace : NoInterlace;\n  image->compression=jpeg_info.process == JPROC_LOSSLESS ?\n    LosslessJPEGCompression : JPEGCompression;\n  if (jpeg_info.data_precision > 8)\n    (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n      \"12-bit JPEG not supported. Reducing pixel data to 8 bits\",\"`%s'\",\n      image->filename);\n  if (jpeg_info.data_precision == 16)\n    jpeg_info.data_precision=12;\n#else\n  image->interlace=jpeg_info.progressive_mode != 0 ? JPEGInterlace :\n    NoInterlace;\n  image->compression=JPEGCompression;\n#endif\n#else\n  image->compression=JPEGCompression;\n  image->interlace=JPEGInterlace;\n#endif\n  option=GetImageOption(image_info,\"jpeg:colors\");\n  if (option != (const char *) NULL)\n    {\n      /*\n        Let the JPEG library quantize for us.\n      */\n      jpeg_info.quantize_colors=TRUE;\n      jpeg_info.desired_number_of_colors=(int) StringToUnsignedLong(option);\n    }\n  option=GetImageOption(image_info,\"jpeg:block-smoothing\");\n  if (option != (const char *) NULL)\n    jpeg_info.do_block_smoothing=IsStringTrue(option) != MagickFalse ? TRUE :\n      FALSE;\n  jpeg_info.dct_method=JDCT_FLOAT;\n  option=GetImageOption(image_info,\"jpeg:dct-method\");\n  if (option != (const char *) NULL)\n    switch (*option)\n    {\n      case 'D':\n      case 'd':\n      {\n        if (LocaleCompare(option,\"default\") == 0)\n          jpeg_info.dct_method=JDCT_DEFAULT;\n        break;\n      }\n      case 'F':\n      case 'f':\n      {\n        if (LocaleCompare(option,\"fastest\") == 0)\n          jpeg_info.dct_method=JDCT_FASTEST;\n        if (LocaleCompare(option,\"float\") == 0)\n          jpeg_info.dct_method=JDCT_FLOAT;\n        break;\n      }\n      case 'I':\n      case 'i':\n      {\n        if (LocaleCompare(option,\"ifast\") == 0)\n          jpeg_info.dct_method=JDCT_IFAST;\n        if (LocaleCompare(option,\"islow\") == 0)\n          jpeg_info.dct_method=JDCT_ISLOW;\n        break;\n      }\n    }\n  option=GetImageOption(image_info,\"jpeg:fancy-upsampling\");\n  if (option != (const char *) NULL)\n    jpeg_info.do_fancy_upsampling=IsStringTrue(option) != MagickFalse ? TRUE :\n      FALSE;\n  (void) jpeg_start_decompress(&jpeg_info);\n  image->columns=jpeg_info.output_width;\n  image->rows=jpeg_info.output_height;\n  image->depth=(size_t) jpeg_info.data_precision;\n  switch (jpeg_info.out_color_space)\n  {\n    case JCS_RGB:\n    default:\n    {\n      (void) SetImageColorspace(image,sRGBColorspace);\n      break;\n    }\n    case JCS_GRAYSCALE:\n    {\n      (void) SetImageColorspace(image,GRAYColorspace);\n      break;\n    }\n    case JCS_YCbCr:\n    {\n      (void) SetImageColorspace(image,YCbCrColorspace);\n      break;\n    }\n    case JCS_CMYK:\n    {\n      (void) SetImageColorspace(image,CMYKColorspace);\n      break;\n    }\n  }\n  if (IsITUFaxImage(image) != MagickFalse)\n    {\n      (void) SetImageColorspace(image,LabColorspace);\n      jpeg_info.out_color_space=JCS_YCbCr;\n    }\n  option=GetImageOption(image_info,\"jpeg:colors\");\n  if (option != (const char *) NULL)\n    if (AcquireImageColormap(image,StringToUnsignedLong(option)) == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n  if ((jpeg_info.output_components == 1) && (jpeg_info.quantize_colors == 0))\n    {\n      size_t\n        colors;\n\n      colors=(size_t) GetQuantumRange(image->depth)+1;\n      if (AcquireImageColormap(image,colors) == MagickFalse)\n        {\n          InheritException(exception,&image->exception);\n          return(DestroyImageList(image));\n        }\n    }\n  if (image->debug != MagickFalse)\n    {\n      if (image->interlace != NoInterlace)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Interlace: progressive\");\n      else\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Interlace: nonprogressive\");\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Data precision: %d\",\n        (int) jpeg_info.data_precision);\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Geometry: %dx%d\",\n        (int) jpeg_info.output_width,(int) jpeg_info.output_height);\n    }\n  JPEGSetImageQuality(&jpeg_info,image);\n  JPEGSetImageSamplingFactor(&jpeg_info,image);\n  (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",(double)\n    jpeg_info.out_color_space);\n  (void) SetImageProperty(image,\"jpeg:colorspace\",value);\n  if (image_info->ping != MagickFalse)\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  if ((jpeg_info.output_components != 1) &&\n      (jpeg_info.output_components != 3) && (jpeg_info.output_components != 4))\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      ThrowReaderException(CorruptImageError,\"ImageTypeNotSupported\");\n    }\n  memory_info=AcquireVirtualMemory((size_t) image->columns,\n    jpeg_info.output_components*sizeof(*jpeg_pixels));\n  if (memory_info == (MemoryInfo *) NULL)\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  jpeg_pixels=(JSAMPLE *) GetVirtualMemoryBlob(memory_info);\n  /*\n    Convert JPEG pixels to pixel packets.\n  */\n  if (setjmp(error_manager.error_recovery) != 0)\n    {\n      if (memory_info != (MemoryInfo *) NULL)\n        memory_info=RelinquishVirtualMemory(memory_info);\n      jpeg_destroy_decompress(&jpeg_info);\n      (void) CloseBlob(image);\n      number_pixels=(MagickSizeType) image->columns*image->rows;\n      if (number_pixels != 0)\n        return(GetFirstImageInList(image));\n      return(DestroyImage(image));\n    }\n  if (jpeg_info.quantize_colors != 0)\n    {\n      image->colors=(size_t) jpeg_info.actual_number_of_colors;\n      if (jpeg_info.out_color_space == JCS_GRAYSCALE)\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          image->colormap[i].red=ScaleCharToQuantum(jpeg_info.colormap[0][i]);\n          image->colormap[i].green=image->colormap[i].red;\n          image->colormap[i].blue=image->colormap[i].red;\n          image->colormap[i].opacity=OpaqueOpacity;\n        }\n      else\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          image->colormap[i].red=ScaleCharToQuantum(jpeg_info.colormap[0][i]);\n          image->colormap[i].green=ScaleCharToQuantum(jpeg_info.colormap[1][i]);\n          image->colormap[i].blue=ScaleCharToQuantum(jpeg_info.colormap[2][i]);\n          image->colormap[i].opacity=OpaqueOpacity;\n        }\n    }\n  scanline[0]=(JSAMPROW) jpeg_pixels;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register IndexPacket\n      *magick_restrict indexes;\n\n    register ssize_t\n      x;\n\n    register PixelPacket\n      *magick_restrict q;\n\n    if (jpeg_read_scanlines(&jpeg_info,scanline,1) != 1)\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          CorruptImageWarning,\"SkipToSyncByte\",\"`%s'\",image->filename);\n        continue;\n      }\n    p=jpeg_pixels;\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      break;\n    indexes=GetAuthenticIndexQueue(image);\n    if (jpeg_info.data_precision > 8)\n      {\n        unsigned short\n          scale;\n\n        scale=65535/(unsigned short) GetQuantumRange((size_t)\n          jpeg_info.data_precision);\n        if (jpeg_info.output_components == 1)\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            size_t\n              pixel;\n\n            pixel=(size_t) (scale*GETJSAMPLE(*p));\n            index=ConstrainColormapIndex(image,pixel);\n            SetPixelIndex(indexes+x,index);\n            SetPixelRGBO(q,image->colormap+(ssize_t) index);\n            p++;\n            q++;\n          }\n        else\n          if (image->colorspace != CMYKColorspace)\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelRed(q,ScaleShortToQuantum((unsigned short)\n                (scale*GETJSAMPLE(*p++))));\n              SetPixelGreen(q,ScaleShortToQuantum((unsigned short)\n                (scale*GETJSAMPLE(*p++))));\n              SetPixelBlue(q,ScaleShortToQuantum((unsigned short)\n                (scale*GETJSAMPLE(*p++))));\n              SetPixelOpacity(q,OpaqueOpacity);\n              q++;\n            }\n          else\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelCyan(q,QuantumRange-ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))));\n              SetPixelMagenta(q,QuantumRange-ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))));\n              SetPixelYellow(q,QuantumRange-ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))));\n              SetPixelBlack(indexes+x,QuantumRange-ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))));\n              SetPixelOpacity(q,OpaqueOpacity);\n              q++;\n            }\n      }\n    else\n      if (jpeg_info.output_components == 1)\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          index=ConstrainColormapIndex(image,(size_t) GETJSAMPLE(*p));\n          SetPixelIndex(indexes+x,index);\n          SetPixelRGBO(q,image->colormap+(ssize_t) index);\n          p++;\n          q++;\n        }\n      else\n        if (image->colorspace != CMYKColorspace)\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(q,ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)));\n            SetPixelGreen(q,ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)));\n            SetPixelBlue(q,ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)));\n            SetPixelOpacity(q,OpaqueOpacity);\n            q++;\n          }\n        else\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelCyan(q,QuantumRange-ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)));\n            SetPixelMagenta(q,QuantumRange-ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)));\n            SetPixelYellow(q,QuantumRange-ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)));\n            SetPixelBlack(indexes+x,QuantumRange-ScaleCharToQuantum(\n              (unsigned char) GETJSAMPLE(*p++)));\n            SetPixelOpacity(q,OpaqueOpacity);\n            q++;\n          }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      {\n        jpeg_abort_decompress(&jpeg_info);\n        break;\n      }\n  }\n  if (status != MagickFalse)\n    {\n      error_manager.finished=MagickTrue;\n      if (setjmp(error_manager.error_recovery) == 0)\n        (void) jpeg_finish_decompress(&jpeg_info);\n    }\n  /*\n    Free jpeg resources.\n  */\n  jpeg_destroy_decompress(&jpeg_info);\n  memory_info=RelinquishVirtualMemory(memory_info);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n", "target": 1, "idx": 181205}
{"func": "static unsigned int stack_maxrandom_size(void)\n {\n\tunsigned int max = 0;\n \tif ((current->flags & PF_RANDOMIZE) &&\n \t\t!(current->personality & ADDR_NO_RANDOMIZE)) {\n\t\tmax = ((-1U) & STACK_RND_MASK) << PAGE_SHIFT;\n \t}\n \n \treturn max;\n}\n", "target": 1, "idx": 179867}
{"func": "  virtual void SetImePropertyActivated(const std::string& key,\n                                       bool activated) {\n    if (!initialized_successfully_)\n       return;\n \n     DCHECK(!key.empty());\n    chromeos::SetImePropertyActivated(\n        input_method_status_connection_, key.c_str(), activated);\n   }\n", "target": 1, "idx": 183964}
{"func": "WKURLRequestRef InjectedBundlePage::willSendRequestForFrame(WKBundlePageRef, WKBundleFrameRef frame, uint64_t identifier, WKURLRequestRef request, WKURLResponseRef response)\n{\n    if (InjectedBundle::shared().isTestRunning()\n        && InjectedBundle::shared().testRunner()->shouldDumpResourceLoadCallbacks()) {\n        StringBuilder stringBuilder;\n        dumpResourceURL(identifier, stringBuilder);\n        stringBuilder.appendLiteral(\" - willSendRequest \");\n        dumpRequestDescriptionSuitableForTestResult(request, stringBuilder);\n        stringBuilder.appendLiteral(\" redirectResponse \");\n        dumpResponseDescriptionSuitableForTestResult(response, stringBuilder);\n        stringBuilder.append('\\n');\n        InjectedBundle::shared().outputText(stringBuilder.toString());\n    }\n\n    if (InjectedBundle::shared().isTestRunning() && InjectedBundle::shared().testRunner()->willSendRequestReturnsNull())\n        return 0;\n\n    WKRetainPtr<WKURLRef> redirectURL = adoptWK(WKURLResponseCopyURL(response));\n    if (InjectedBundle::shared().isTestRunning() && InjectedBundle::shared().testRunner()->willSendRequestReturnsNullOnRedirect() && redirectURL) {\n        InjectedBundle::shared().outputText(\"Returning null for this redirect\\n\");\n        return 0;\n    }\n\n    WKRetainPtr<WKURLRef> url = adoptWK(WKURLRequestCopyURL(request));\n    WKRetainPtr<WKStringRef> host = adoptWK(WKURLCopyHostName(url.get()));\n    WKRetainPtr<WKStringRef> scheme = adoptWK(WKURLCopyScheme(url.get()));\n    WKRetainPtr<WKStringRef> urlString = adoptWK(WKURLCopyString(url.get()));\n    if (host && !WKStringIsEmpty(host.get())\n        && isHTTPOrHTTPSScheme(scheme.get())\n        && !WKStringIsEqualToUTF8CString(host.get(), \"255.255.255.255\") // Used in some tests that expect to get back an error.\n        && !isLocalHost(host.get())) {\n        bool mainFrameIsExternal = false;\n        if (InjectedBundle::shared().isTestRunning()) {\n            WKBundleFrameRef mainFrame = InjectedBundle::shared().topLoadingFrame();\n            WKRetainPtr<WKURLRef> mainFrameURL = adoptWK(WKBundleFrameCopyURL(mainFrame));\n            if (!mainFrameURL || WKStringIsEqualToUTF8CString(adoptWK(WKURLCopyString(mainFrameURL.get())).get(), \"about:blank\"))\n                mainFrameURL = adoptWK(WKBundleFrameCopyProvisionalURL(mainFrame));\n\n            WKRetainPtr<WKStringRef> mainFrameHost = WKURLCopyHostName(mainFrameURL.get());\n            WKRetainPtr<WKStringRef> mainFrameScheme = WKURLCopyScheme(mainFrameURL.get());\n            mainFrameIsExternal = isHTTPOrHTTPSScheme(mainFrameScheme.get()) && !isLocalHost(mainFrameHost.get());\n        }\n        if (!mainFrameIsExternal) {\n            StringBuilder stringBuilder;\n            stringBuilder.appendLiteral(\"Blocked access to external URL \");\n            stringBuilder.append(toWTFString(urlString));\n            stringBuilder.append('\\n');\n            InjectedBundle::shared().outputText(stringBuilder.toString());\n            return 0;\n        }\n    }\n\n    WKRetain(request);\n    return request;\n}\n", "target": 0, "idx": 115488}
{"func": " static int get_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)\n {\n\treturn usb_control_msg(dev->udev, usb_rcvctrlpipe(dev->udev, 0),\n\t\t\t       RTL8150_REQ_GET_REGS, RTL8150_REQT_READ,\n\t\t\t       indx, 0, data, size, 500);\n }\n", "target": 1, "idx": 181386}
{"func": "static void mptsas_free_request(MPTSASRequest *req)\n{\n    MPTSASState *s = req->dev;\n\n    if (req->sreq != NULL) {\n        req->sreq->hba_private = NULL;\n        scsi_req_unref(req->sreq);\n        req->sreq = NULL;\n        QTAILQ_REMOVE(&s->pending, req, next);\n    }\n    qemu_sglist_destroy(&req->qsg);\n    g_free(req);\n}\n", "target": 0, "idx": 8361}
{"func": " fbOver (CARD32 x, CARD32 y)\n {\n\t\t\t\t  PicturePtr pDst,\n\t\t\t\t  INT16      xSrc,\n\t\t\t\t  INT16      ySrc,\n\t\t\t\t  INT16      xMask,\n                                  INT16      yMask,\n\t\t\t\t  INT16      xDst,\n\t\t\t\t  INT16      yDst,\n\t\t\t\t  CARD16     width,\n\t\t\t\t  CARD16     height);\n\nCARD32\nfbOver (CARD32 x, CARD32 y)\n{\n    CARD16  a = ~x >> 24;\n    CARD16  t;\n    CARD32  m,n,o,p;\n\n    m = FbOverU(x,y,0,a,t);\n    n = FbOverU(x,y,8,a,t);\n    o = FbOverU(x,y,16,a,t);\n    p = FbOverU(x,y,24,a,t);\n    return m|n|o|p;\n}\n\nCARD32\nfbOver24 (CARD32 x, CARD32 y)\n{\n    CARD16  a = ~x >> 24;\n    CARD16  t;\n    CARD32  m,n,o;\n\n    m = FbOverU(x,y,0,a,t);\n    n = FbOverU(x,y,8,a,t);\n    o = FbOverU(x,y,16,a,t);\n    return m|n|o;\n}\n\nCARD32\nfbIn (CARD32 x, CARD8 y)\n{\n    CARD16  a = y;\n    CARD16  t;\n    CARD32  m,n,o,p;\n\n    m = FbInU(x,0,a,t);\n    n = FbInU(x,8,a,t);\n    o = FbInU(x,16,a,t);\n    p = FbInU(x,24,a,t);\n    return m|n|o|p;\n}\n\n#define genericCombine24(a,b,c,d) (((a)*(c)+(b)*(d)))\n\n/*\n * This macro does src IN mask OVER dst when src and dst are 0888.\n * If src has alpha, this will not work\n */\n#define inOver0888(alpha, source, destval, dest) { \\\n \tCARD32 dstrb=destval&0xFF00FF; CARD32 dstag=(destval>>8)&0xFF00FF; \\\n \tCARD32 drb=((source&0xFF00FF)-dstrb)*alpha; CARD32 dag=(((source>>8)&0xFF00FF)-dstag)*alpha; \\\n\tWRITE(dest, ((((drb>>8) + dstrb) & 0x00FF00FF) | ((((dag>>8) + dstag) << 8) & 0xFF00FF00))); \\\n    }\n\n/*\n * This macro does src IN mask OVER dst when src and dst are 0565 and\n * mask is a 5-bit alpha value.  Again, if src has alpha, this will not\n * work.\n */\n#define inOver0565(alpha, source, destval, dest) { \\\n \tCARD16 dstrb = destval & 0xf81f; CARD16 dstg  = destval & 0x7e0; \\\n \tCARD32 drb = ((source&0xf81f)-dstrb)*alpha; CARD32 dg=((source & 0x7e0)-dstg)*alpha; \\\n\tWRITE(dest, ((((drb>>5) + dstrb)&0xf81f) | (((dg>>5)  + dstg) & 0x7e0))); \\\n    }\n\n\n#define inOver2x0565(alpha, source, destval, dest) { \\\n \tCARD32 dstrb = destval & 0x07e0f81f; CARD32 dstg  = (destval & 0xf81f07e0)>>5; \\\n \tCARD32 drb = ((source&0x07e0f81f)-dstrb)*alpha; CARD32 dg=(((source & 0xf81f07e0)>>5)-dstg)*alpha; \\\n\tWRITE(dest, ((((drb>>5) + dstrb)&0x07e0f81f) | ((((dg>>5)  + dstg)<<5) & 0xf81f07e0))); \\\n    }\n\n\n#if IMAGE_BYTE_ORDER == LSBFirst\n#define setupPackedReader(count,temp,where,workingWhere,workingVal) count=(long)where; \\\n\t\t\t\t\ttemp=count&3; \\\n\t\t\t\t\twhere-=temp; \\\n\t\t\t\t\tworkingWhere=(CARD32 *)where; \\\n                                        workingVal=READ(workingWhere++); \\\n\t\t\t\t\tcount=4-temp; \\\n\t\t\t\t\tworkingVal>>=(8*temp)\n        #define readPacked(where,x,y,z) {if(!(x)) { (x)=4; y = READ(z++); } where=(y)&0xff; (y)>>=8; (x)--;}\n\t#define readPackedSource(where) readPacked(where,ws,workingSource,wsrc)\n\t#define readPackedDest(where) readPacked(where,wd,workingiDest,widst)\n        #define writePacked(what) workingoDest>>=8; workingoDest|=(what<<24); ww--; if(!ww) { ww=4; WRITE (wodst++, workingoDest); } \n#else\n\t#warning \"I havn't tested fbCompositeTrans_0888xnx0888() on big endian yet!\"\n\t#define setupPackedReader(count,temp,where,workingWhere,workingVal) count=(long)where; \\\n\t\t\t\t\ttemp=count&3; \\\n\t\t\t\t\twhere-=temp; \\\n\t\t\t\t\tworkingWhere=(CARD32 *)where; \\\n                                        workingVal=READ(workingWhere++); \\\n\t\t\t\t\tcount=4-temp; \\\n\t\t\t\t\tworkingVal<<=(8*temp)\n        #define readPacked(where,x,y,z) {if(!(x)) { (x)=4; y = READ(z++); } where=(y)>>24; (y)<<=8; (x)--;}\n\t#define readPackedSource(where) readPacked(where,ws,workingSource,wsrc)\n\t#define readPackedDest(where) readPacked(where,wd,workingiDest,widst)\n        #define writePacked(what) workingoDest<<=8; workingoDest|=what; ww--; if(!ww) { ww=4; WRITE(wodst++, workingoDest); } \n#endif\n\n/*\n * Naming convention:\n *\n *  opSRCxMASKxDST\n */\n\nvoid\nfbCompositeSolidMask_nx8x8888 (CARD8      op,\n\t\t\t       PicturePtr pSrc,\n\t\t\t       PicturePtr pMask,\n\t\t\t       PicturePtr pDst,\n\t\t\t       INT16      xSrc,\n\t\t\t       INT16      ySrc,\n\t\t\t       INT16      xMask,\n\t\t\t       INT16      yMask,\n\t\t\t       INT16      xDst,\n\t\t\t       INT16      yDst,\n\t\t\t       CARD16     width,\n\t\t\t       CARD16     height)\n{\n    CARD32\tsrc, srca;\n    CARD32\t*dstLine, *dst, d, dstMask;\n    CARD8\t*maskLine, *mask, m;\n    FbStride\tdstStride, maskStride;\n    CARD16\tw;\n\n    fbComposeGetSolid(pSrc, src, pDst->format);\n\n    dstMask = FbFullMask (pDst->pDrawable->depth);\n    srca = src >> 24;\n    if (src == 0)\n\treturn;\n\n    fbComposeGetStart (pDst, xDst, yDst, CARD32, dstStride, dstLine, 1);\n    fbComposeGetStart (pMask, xMask, yMask, CARD8, maskStride, maskLine, 1);\n\n    while (height--)\n    {\n\tdst = dstLine;\n\tdstLine += dstStride;\n\tmask = maskLine;\n\tmaskLine += maskStride;\n\tw = width;\n\n\twhile (w--)\n\t{\n\t    m = READ(mask++);\n\t    if (m == 0xff)\n\t    {\n\t\tif (srca == 0xff)\n\t\t    WRITE(dst, src & dstMask);\n\t\telse\n\t\t    WRITE(dst, fbOver (src, READ(dst)) & dstMask);\n\t    }\n\t    else if (m)\n\t    {\n\t\td = fbIn (src, m);\n\t\tWRITE(dst, fbOver (d, READ(dst)) & dstMask);\n\t    }\n\t    dst++;\n\t}\n    }\n\n    fbFinishAccess (pMask->pDrawable);\n    fbFinishAccess (pDst->pDrawable);\n}\n\nvoid\nfbCompositeSolidMask_nx8888x8888C (CARD8      op,\n\t\t\t\t   PicturePtr pSrc,\n\t\t\t\t   PicturePtr pMask,\n\t\t\t\t   PicturePtr pDst,\n\t\t\t\t   INT16      xSrc,\n\t\t\t\t   INT16      ySrc,\n\t\t\t\t   INT16      xMask,\n\t\t\t\t   INT16      yMask,\n\t\t\t\t   INT16      xDst,\n\t\t\t\t   INT16      yDst,\n\t\t\t\t   CARD16     width,\n\t\t\t\t   CARD16     height)\n{\n    CARD32\tsrc, srca;\n    CARD32\t*dstLine, *dst, d, dstMask;\n    CARD32\t*maskLine, *mask, ma;\n    FbStride\tdstStride, maskStride;\n    CARD16\tw;\n    CARD32\tm, n, o, p;\n\n    fbComposeGetSolid(pSrc, src, pDst->format);\n\n    dstMask = FbFullMask (pDst->pDrawable->depth);\n    srca = src >> 24;\n    if (src == 0)\n\treturn;\n\n    fbComposeGetStart (pDst, xDst, yDst, CARD32, dstStride, dstLine, 1);\n    fbComposeGetStart (pMask, xMask, yMask, CARD32, maskStride, maskLine, 1);\n\n    while (height--)\n    {\n\tdst = dstLine;\n\tdstLine += dstStride;\n\tmask = maskLine;\n\tmaskLine += maskStride;\n\tw = width;\n\n\twhile (w--)\n\t{\n\t    ma = READ(mask++);\n\t    if (ma == 0xffffffff)\n\t    {\n\t\tif (srca == 0xff)\n\t\t    WRITE(dst, src & dstMask);\n\t\telse\n\t\t    WRITE(dst, fbOver (src, READ(dst)) & dstMask);\n\t    }\n\t    else if (ma)\n\t    {\n\t\td = READ(dst);\n#define FbInOverC(src,srca,msk,dst,i,result) { \\\n    CARD16  __a = FbGet8(msk,i); \\\n    CARD32  __t, __ta; \\\n    CARD32  __i; \\\n    __t = FbIntMult (FbGet8(src,i), __a,__i); \\\n    __ta = (CARD8) ~FbIntMult (srca, __a,__i); \\\n    __t = __t + FbIntMult(FbGet8(dst,i),__ta,__i); \\\n    __t = (CARD32) (CARD8) (__t | (-(__t >> 8))); \\\n    result = __t << (i); \\\n}\n\t\tFbInOverC (src, srca, ma, d, 0, m);\n\t\tFbInOverC (src, srca, ma, d, 8, n);\n\t\tFbInOverC (src, srca, ma, d, 16, o);\n\t\tFbInOverC (src, srca, ma, d, 24, p);\n\t\tWRITE(dst, m|n|o|p);\n\t    }\n\t    dst++;\n\t}\n    }\n\n    fbFinishAccess (pMask->pDrawable);\n    fbFinishAccess (pDst->pDrawable);\n}\n\n#define srcAlphaCombine24(a,b) genericCombine24(a,b,srca,srcia)\nvoid\nfbCompositeSolidMask_nx8x0888 (CARD8      op,\n\t\t\t       PicturePtr pSrc,\n\t\t\t       PicturePtr pMask,\n\t\t\t       PicturePtr pDst,\n\t\t\t       INT16      xSrc,\n\t\t\t       INT16      ySrc,\n\t\t\t       INT16      xMask,\n\t\t\t       INT16      yMask,\n\t\t\t       INT16      xDst,\n\t\t\t       INT16      yDst,\n\t\t\t       CARD16     width,\n\t\t\t       CARD16     height)\n{\n    CARD32\tsrc, srca, srcia;\n    CARD8\t*dstLine, *dst, *edst;\n    CARD8\t*maskLine, *mask, m;\n    FbStride\tdstStride, maskStride;\n    CARD16\tw;\n    CARD32 rs,gs,bs,rd,gd,bd;\n\n    fbComposeGetSolid(pSrc, src, pDst->format);\n\n    srca = src >> 24;\n    srcia = 255-srca;\n    if (src == 0)\n\treturn;\n\n    rs=src&0xff;\n    gs=(src>>8)&0xff;\n    bs=(src>>16)&0xff;\n      \n    fbComposeGetStart (pDst, xDst, yDst, CARD8, dstStride, dstLine, 3);\n    fbComposeGetStart (pMask, xMask, yMask, CARD8, maskStride, maskLine, 1);\n\n    while (height--)\n    {\n\t/* fixme: cleanup unused */\n\tunsigned long wt, wd;\n\tCARD32 workingiDest;\n\tCARD32 *widst;\n \t\n\tedst = dst = dstLine;\n\tdstLine += dstStride;\n\tmask = maskLine;\n\tmaskLine += maskStride;\n\tw = width;\n \t\n#ifndef NO_MASKED_PACKED_READ\n\tsetupPackedReader(wd,wt,edst,widst,workingiDest);\n#endif\n \t\n\twhile (w--)\n\t{\n#ifndef NO_MASKED_PACKED_READ\n\t    readPackedDest(rd);\n\t    readPackedDest(gd);\n\t    readPackedDest(bd);\n#else\n\t    rd = READ(edst++);\n\t    gd = READ(edst++);\n\t    bd = READ(edst++);\n#endif\n\t    m = READ(mask++);\n\t    if (m == 0xff)\n\t    {\n\t\tif (srca == 0xff)\n\t\t{\n\t\t    WRITE(dst++, rs);\n\t\t    WRITE(dst++, gs);\n\t\t    WRITE(dst++, bs);\n\t\t}\n\t\telse\n\t\t{\n\t\t    WRITE(dst++, (srcAlphaCombine24(rs, rd)>>8));\n\t\t    WRITE(dst++, (srcAlphaCombine24(gs, gd)>>8));\n\t\t    WRITE(dst++, (srcAlphaCombine24(bs, bd)>>8));\n\t\t}\n\t    }\n\t    else if (m)\n\t    {\n\t\tint na=(srca*(int)m)>>8;\n\t\tint nia=255-na;\n\t\tWRITE(dst++, (genericCombine24(rs, rd, na, nia)>>8));\n\t\tWRITE(dst++, (genericCombine24(gs, gd, na, nia)>>8));\n\t\tWRITE(dst++, (genericCombine24(bs, bd, na, nia)>>8));\n\t    }\n\t    else\n\t    {\n\t\tdst+=3;\n\t    }\n\t}\n    }\n    \n    fbFinishAccess (pMask->pDrawable);\n    fbFinishAccess (pDst->pDrawable);\n}\n\nvoid\nfbCompositeSolidMask_nx8x0565 (CARD8      op,\n\t\t\t\t  PicturePtr pSrc,\n\t\t\t\t  PicturePtr pMask,\n\t\t\t\t  PicturePtr pDst,\n\t\t\t\t  INT16      xSrc,\n\t\t\t\t  INT16      ySrc,\n\t\t\t\t  INT16      xMask,\n\t\t\t\t  INT16      yMask,\n\t\t\t\t  INT16      xDst,\n\t\t\t\t  INT16      yDst,\n\t\t\t\t  CARD16     width,\n\t\t\t\t  CARD16     height)\n{\n    CARD32\tsrc, srca8, srca5;\n    CARD16\t*dstLine, *dst;\n    CARD16\td;\n    CARD32\tt;\n    CARD8\t*maskLine, *mask, m;\n    FbStride\tdstStride, maskStride;\n    CARD16\tw,src16;\n    \n    fbComposeGetSolid(pSrc, src, pDst->format);\n    \n    if (src == 0)\n\treturn;\n      \n    srca8 = (src >> 24);\n    srca5 = (srca8 >> 3);\n    src16 = cvt8888to0565(src);\n     \n    fbComposeGetStart (pDst, xDst, yDst, CARD16, dstStride, dstLine, 1);\n    fbComposeGetStart (pMask, xMask, yMask, CARD8, maskStride, maskLine, 1);\n    \n    while (height--)\n    {\n\tdst = dstLine;\n\tdstLine += dstStride;\n\tmask = maskLine;\n\tmaskLine += maskStride;\n\tw = width;\n \n\twhile (w--)\n\t{\n\t    m = READ(mask++);\n\t    if (m == 0)\n\t\tdst++;\n\t    else if (srca5 == (0xff >> 3))\n\t    {\n\t\tif (m == 0xff)\n\t\t    WRITE(dst++, src16);\n\t\telse \n \t\t{\n\t\t    d = READ(dst);\n\t\t    m >>= 3;\n\t\t    inOver0565 (m, src16, d, dst++);\n \t\t}\n\t    }\n\t    else\n\t    {\n\t\td = READ(dst);\n\t\tif (m == 0xff) \n\t\t{\n\t\t    t = fbOver24 (src, cvt0565to0888 (d));\n\t\t}\n\t\telse\n\t\t{\n\t\t    t = fbIn (src, m);\n\t\t    t = fbOver (t, cvt0565to0888 (d));\n\t\t}\n\t\tWRITE(dst++, cvt8888to0565 (t));\n\t    }\n\t}\n    }\n    \n    fbFinishAccess (pMask->pDrawable);\n    fbFinishAccess (pDst->pDrawable);\n}\n\nstatic void\nfbCompositeSolidMask_nx8888x0565 (CARD8      op,\n\t\t\t\t  PicturePtr pSrc,\n\t\t\t\t  PicturePtr pMask,\n\t\t\t\t  PicturePtr pDst,\n\t\t\t\t  INT16      xSrc,\n\t\t\t\t  INT16      ySrc,\n\t\t\t\t  INT16      xMask,\n\t\t\t\t  INT16      yMask,\n\t\t\t\t  INT16      xDst,\n\t\t\t\t  INT16      yDst,\n\t\t\t\t  CARD16     width,\n\t\t\t\t  CARD16     height)\n{\n    CARD32\tsrc, srca8, srca5;\n    CARD16\t*dstLine, *dst;\n    CARD16\td;\n    CARD32\t*maskLine, *mask;\n    CARD32\tt;\n    CARD8\tm;\n    FbStride\tdstStride, maskStride;\n    CARD16\tw, src16;\n\n    fbComposeGetSolid(pSrc, src, pDst->format);\n\n    if (src == 0)\n\treturn;\n\n    srca8 = src >> 24;\n    srca5 = srca8 >> 3;\n    src16 = cvt8888to0565(src);\n\n    fbComposeGetStart (pDst, xDst, yDst, CARD16, dstStride, dstLine, 1);\n    fbComposeGetStart (pMask, xMask, yMask, CARD32, maskStride, maskLine, 1);\n\n    while (height--)\n    {\n\tdst = dstLine;\n\tdstLine += dstStride;\n\tmask = maskLine;\n\tmaskLine += maskStride;\n\tw = width;\n\n\twhile (w--)\n\t{\n\t    m = READ(mask++) >> 24;\n\t    if (m == 0)\n\t\tdst++;\n\t    else if (srca5 == (0xff >> 3))\n\t    {\n\t\tif (m == 0xff)\n\t\t    WRITE(dst++, src16);\n\t\telse\n\t\t{\n\t\t    d = READ(dst);\n\t\t    m >>= 3;\n\t\t    inOver0565 (m, src16, d, dst++);\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tif (m == 0xff) \n\t\t{\n\t\t    d = READ(dst);\n\t\t    t = fbOver24 (src, cvt0565to0888 (d));\n\t\t    WRITE(dst++, cvt8888to0565 (t));\n\t\t}\n\t\telse\n\t\t{\n\t\t    d = READ(dst);\n\t\t    t = fbIn (src, m);\n\t\t    t = fbOver (t, cvt0565to0888 (d));\n\t\t    WRITE(dst++, cvt8888to0565 (t));\n\t\t}\n\t    }\n\t}\n    }\n}\n\nvoid\nfbCompositeSolidMask_nx8888x0565C (CARD8      op,\n\t\t\t\t   PicturePtr pSrc,\n\t\t\t\t   PicturePtr pMask,\n\t\t\t\t   PicturePtr pDst,\n\t\t\t\t   INT16      xSrc,\n\t\t\t\t   INT16      ySrc,\n\t\t\t\t   INT16      xMask,\n\t\t\t\t   INT16      yMask,\n\t\t\t\t   INT16      xDst,\n\t\t\t\t   INT16      yDst,\n\t\t\t\t   CARD16     width,\n\t\t\t\t   CARD16     height)\n{\n    CARD32\tsrc, srca;\n    CARD16\tsrc16;\n    CARD16\t*dstLine, *dst;\n    CARD32\td;\n    CARD32\t*maskLine, *mask, ma;\n    FbStride\tdstStride, maskStride;\n    CARD16\tw;\n    CARD32\tm, n, o;\n\n    fbComposeGetSolid(pSrc, src, pDst->format);\n\n    srca = src >> 24;\n    if (src == 0)\n\treturn;\n\n    src16 = cvt8888to0565(src);\n\n    fbComposeGetStart (pDst, xDst, yDst, CARD16, dstStride, dstLine, 1);\n    fbComposeGetStart (pMask, xMask, yMask, CARD32, maskStride, maskLine, 1);\n\n    while (height--)\n    {\n\tdst = dstLine;\n\tdstLine += dstStride;\n\tmask = maskLine;\n\tmaskLine += maskStride;\n\tw = width;\n\n\twhile (w--)\n\t{\n\t    ma = READ(mask++);\n\t    if (ma == 0xffffffff)\n\t    {\n\t\tif (srca == 0xff)\n\t\t{\n\t\t    WRITE(dst, src16);\n\t\t}\n\t\telse\n\t\t{\n\t\t    d = READ(dst);\n\t\t    d = fbOver24 (src, cvt0565to0888(d));\n\t\t    WRITE(dst, cvt8888to0565(d));\n\t\t}\n\t    }\n\t    else if (ma)\n\t    {\n\t\td = READ(dst);\n\t\td = cvt0565to0888(d);\n\t\tFbInOverC (src, srca, ma, d, 0, m);\n\t\tFbInOverC (src, srca, ma, d, 8, n);\n\t\tFbInOverC (src, srca, ma, d, 16, o);\n\t\td = m|n|o;\n\t\tWRITE(dst, cvt8888to0565(d));\n\t    }\n\t    dst++;\n\t}\n    }\n\n    fbFinishAccess (pMask->pDrawable);\n    fbFinishAccess (pDst->pDrawable);\n}\n\nvoid\nfbCompositeSrc_8888x8888 (CARD8      op,\n\t\t\t PicturePtr pSrc,\n\t\t\t PicturePtr pMask,\n\t\t\t PicturePtr pDst,\n\t\t\t INT16      xSrc,\n\t\t\t INT16      ySrc,\n\t\t\t INT16      xMask,\n\t\t\t INT16      yMask,\n\t\t\t INT16      xDst,\n\t\t\t INT16      yDst,\n\t\t\t CARD16     width,\n\t\t\t CARD16     height)\n{\n    CARD32\t*dstLine, *dst, dstMask;\n    CARD32\t*srcLine, *src, s;\n    FbStride\tdstStride, srcStride;\n    CARD8\ta;\n    CARD16\tw;\n\n    fbComposeGetStart (pDst, xDst, yDst, CARD32, dstStride, dstLine, 1);\n    fbComposeGetStart (pSrc, xSrc, ySrc, CARD32, srcStride, srcLine, 1);\n\n    dstMask = FbFullMask (pDst->pDrawable->depth);\n\n    while (height--)\n    {\n\tdst = dstLine;\n\tdstLine += dstStride;\n\tsrc = srcLine;\n\tsrcLine += srcStride;\n\tw = width;\n\n\twhile (w--)\n\t{\n\t    s = READ(src++);\n\t    a = s >> 24;\n\t    if (a == 0xff)\n\t\tWRITE(dst, s & dstMask);\n\t    else if (a)\n\t\tWRITE(dst, fbOver (s, READ(dst)) & dstMask);\n\t    dst++;\n\t}\n    }\n\n    fbFinishAccess (pSrc->pDrawable);\n    fbFinishAccess (pDst->pDrawable);\n}\n\nvoid\nfbCompositeSrc_8888x0888 (CARD8      op,\n\t\t\t PicturePtr pSrc,\n\t\t\t PicturePtr pMask,\n\t\t\t PicturePtr pDst,\n\t\t\t INT16      xSrc,\n\t\t\t INT16      ySrc,\n\t\t\t INT16      xMask,\n\t\t\t INT16      yMask,\n\t\t\t INT16      xDst,\n\t\t\t INT16      yDst,\n\t\t\t CARD16     width,\n\t\t\t CARD16     height)\n{\n    CARD8\t*dstLine, *dst;\n    CARD32\td;\n    CARD32\t*srcLine, *src, s;\n    CARD8\ta;\n    FbStride\tdstStride, srcStride;\n    CARD16\tw;\n\n    fbComposeGetStart (pDst, xDst, yDst, CARD8, dstStride, dstLine, 3);\n    fbComposeGetStart (pSrc, xSrc, ySrc, CARD32, srcStride, srcLine, 1);\n\n    while (height--)\n    {\n\tdst = dstLine;\n\tdstLine += dstStride;\n\tsrc = srcLine;\n\tsrcLine += srcStride;\n\tw = width;\n\n\twhile (w--)\n\t{\n\t    s = READ(src++);\n\t    a = s >> 24;\n\t    if (a)\n\t    {\n\t\tif (a == 0xff)\n\t\t    d = s;\n\t\telse\n\t\t    d = fbOver24 (s, Fetch24(dst));\n\t\tStore24(dst,d);\n\t    }\n\t    dst += 3;\n\t}\n    }\n\n    fbFinishAccess (pSrc->pDrawable);\n    fbFinishAccess (pDst->pDrawable);\n}\n\nvoid\nfbCompositeSrc_8888x0565 (CARD8      op,\n\t\t\t PicturePtr pSrc,\n\t\t\t PicturePtr pMask,\n\t\t\t PicturePtr pDst,\n\t\t\t INT16      xSrc,\n\t\t\t INT16      ySrc,\n\t\t\t INT16      xMask,\n\t\t\t INT16      yMask,\n\t\t\t INT16      xDst,\n\t\t\t INT16      yDst,\n\t\t\t CARD16     width,\n\t\t\t CARD16     height)\n{\n    CARD16\t*dstLine, *dst;\n    CARD32\td;\n    CARD32\t*srcLine, *src, s;\n    CARD8\ta;\n    FbStride\tdstStride, srcStride;\n    CARD16\tw;\n\n    fbComposeGetStart (pSrc, xSrc, ySrc, CARD32, srcStride, srcLine, 1);\n    fbComposeGetStart (pDst, xDst, yDst, CARD16, dstStride, dstLine, 1);\n\n    while (height--)\n    {\n\tdst = dstLine;\n\tdstLine += dstStride;\n\tsrc = srcLine;\n\tsrcLine += srcStride;\n\tw = width;\n\n\twhile (w--)\n\t{\n\t    s = READ(src++);\n\t    a = s >> 24;\n\t    if (a)\n\t    {\n\t\tif (a == 0xff)\n\t\t    d = s;\n\t\telse\n\t\t{\n\t\t    d = READ(dst);\n\t\t    d = fbOver24 (s, cvt0565to0888(d));\n\t\t}\n\t\tWRITE(dst, cvt8888to0565(d));\n\t    }\n\t    dst++;\n\t}\n    }\n\n    fbFinishAccess (pDst->pDrawable);\n    fbFinishAccess (pSrc->pDrawable);\n}\n\nvoid\nfbCompositeSrcAdd_8000x8000 (CARD8\top,\n\t\t\t     PicturePtr pSrc,\n\t\t\t     PicturePtr pMask,\n\t\t\t     PicturePtr pDst,\n\t\t\t     INT16      xSrc,\n\t\t\t     INT16      ySrc,\n\t\t\t     INT16      xMask,\n\t\t\t     INT16      yMask,\n\t\t\t     INT16      xDst,\n\t\t\t     INT16      yDst,\n\t\t\t     CARD16     width,\n\t\t\t     CARD16     height)\n{\n    CARD8\t*dstLine, *dst;\n    CARD8\t*srcLine, *src;\n    FbStride\tdstStride, srcStride;\n    CARD16\tw;\n    CARD8\ts, d;\n    CARD16\tt;\n\n    fbComposeGetStart (pSrc, xSrc, ySrc, CARD8, srcStride, srcLine, 1);\n    fbComposeGetStart (pDst, xDst, yDst, CARD8, dstStride, dstLine, 1);\n\n    while (height--)\n    {\n\tdst = dstLine;\n\tdstLine += dstStride;\n\tsrc = srcLine;\n\tsrcLine += srcStride;\n\tw = width;\n\n\twhile (w--)\n\t{\n\t    s = READ(src++);\n\t    if (s)\n\t    {\n\t\tif (s != 0xff)\n\t\t{\n\t\t    d = READ(dst);\n\t\t    t = d + s;\n\t\t    s = t | (0 - (t >> 8));\n\t\t}\n\t\tWRITE(dst, s);\n\t    }\n\t    dst++;\n\t}\n    }\n\n    fbFinishAccess (pDst->pDrawable);\n    fbFinishAccess (pSrc->pDrawable);\n}\n\nvoid\nfbCompositeSrcAdd_8888x8888 (CARD8\top,\n\t\t\t     PicturePtr pSrc,\n\t\t\t     PicturePtr pMask,\n\t\t\t     PicturePtr pDst,\n\t\t\t     INT16      xSrc,\n\t\t\t     INT16      ySrc,\n\t\t\t     INT16      xMask,\n\t\t\t     INT16      yMask,\n\t\t\t     INT16      xDst,\n\t\t\t     INT16      yDst,\n\t\t\t     CARD16     width,\n\t\t\t     CARD16     height)\n{\n    CARD32\t*dstLine, *dst;\n    CARD32\t*srcLine, *src;\n    FbStride\tdstStride, srcStride;\n    CARD16\tw;\n    CARD32\ts, d;\n    CARD16\tt;\n    CARD32\tm,n,o,p;\n\n    fbComposeGetStart (pSrc, xSrc, ySrc, CARD32, srcStride, srcLine, 1);\n    fbComposeGetStart (pDst, xDst, yDst, CARD32, dstStride, dstLine, 1);\n\n    while (height--)\n    {\n\tdst = dstLine;\n\tdstLine += dstStride;\n\tsrc = srcLine;\n\tsrcLine += srcStride;\n\tw = width;\n\n\twhile (w--)\n\t{\n\t    s = READ(src++);\n\t    if (s)\n\t    {\n\t\tif (s != 0xffffffff)\n\t\t{\n\t\t    d = READ(dst);\n\t\t    if (d)\n\t\t    {\n\t\t\tm = FbAdd(s,d,0,t);\n\t\t\tn = FbAdd(s,d,8,t);\n\t\t\to = FbAdd(s,d,16,t);\n\t\t\tp = FbAdd(s,d,24,t);\n\t\t\ts = m|n|o|p;\n\t\t    }\n\t\t}\n\t\tWRITE(dst, s);\n\t    }\n\t    dst++;\n\t}\n    }\n\n    fbFinishAccess (pDst->pDrawable);\n    fbFinishAccess (pSrc->pDrawable);\n}\n\nstatic void\nfbCompositeSrcAdd_8888x8x8 (CARD8      op,\n\t\t\t    PicturePtr pSrc,\n\t\t\t    PicturePtr pMask,\n\t\t\t    PicturePtr pDst,\n\t\t\t    INT16      xSrc,\n\t\t\t    INT16      ySrc,\n\t\t\t    INT16      xMask,\n\t\t\t    INT16      yMask,\n\t\t\t    INT16      xDst,\n\t\t\t    INT16      yDst,\n\t\t\t    CARD16     width,\n\t\t\t    CARD16     height)\n{\n    CARD8\t*dstLine, *dst;\n    CARD8\t*maskLine, *mask;\n    FbStride\tdstStride, maskStride;\n    CARD16\tw;\n    CARD32\tsrc;\n    CARD8\tsa;\n\n    fbComposeGetStart (pDst, xDst, yDst, CARD8, dstStride, dstLine, 1);\n    fbComposeGetStart (pMask, xMask, yMask, CARD8, maskStride, maskLine, 1);\n    fbComposeGetSolid (pSrc, src, pDst->format);\n    sa = (src >> 24);\n\n    while (height--)\n    {\n\tdst = dstLine;\n\tdstLine += dstStride;\n\tmask = maskLine;\n\tmaskLine += maskStride;\n\tw = width;\n\n\twhile (w--)\n\t{\n\t    CARD16\ttmp;\n\t    CARD16\ta;\n\t    CARD32\tm, d;\n\t    CARD32\tr;\n\n\t    a = READ(mask++);\n\t    d = READ(dst);\n\n\t    m = FbInU (sa, 0, a, tmp);\n\t    r = FbAdd (m, d, 0, tmp);\n\n\t    WRITE(dst++, r);\n\t}\n    }\n    \n    fbFinishAccess(pDst->pDrawable);\n    fbFinishAccess(pMask->pDrawable);\n}\n\nvoid\nfbCompositeSrcAdd_1000x1000 (CARD8\top,\n\t\t\t     PicturePtr pSrc,\n\t\t\t     PicturePtr pMask,\n\t\t\t     PicturePtr pDst,\n\t\t\t     INT16      xSrc,\n\t\t\t     INT16      ySrc,\n\t\t\t     INT16      xMask,\n\t\t\t     INT16      yMask,\n\t\t\t     INT16      xDst,\n\t\t\t     INT16      yDst,\n\t\t\t     CARD16     width,\n\t\t\t     CARD16     height)\n{\n    FbBits\t*dstBits, *srcBits;\n    FbStride\tdstStride, srcStride;\n    int\t\tdstBpp, srcBpp;\n    int\t\tdstXoff, dstYoff;\n    int\t\tsrcXoff, srcYoff;\n\n    fbGetDrawable(pSrc->pDrawable, srcBits, srcStride, srcBpp, srcXoff, srcYoff);\n\n    fbGetDrawable(pDst->pDrawable, dstBits, dstStride, dstBpp, dstXoff, dstYoff);\n\n    fbBlt (srcBits + srcStride * (ySrc + srcYoff),\n\t   srcStride,\n\t   xSrc + srcXoff,\n\n\t   dstBits + dstStride * (yDst + dstYoff),\n\t   dstStride,\n\t   xDst + dstXoff,\n\n\t   width,\n\t   height,\n\n\t   GXor,\n\t   FB_ALLONES,\n\t   srcBpp,\n\n\t   FALSE,\n\t   FALSE);\n\n    fbFinishAccess(pDst->pDrawable);\n    fbFinishAccess(pSrc->pDrawable);\n}\n\nvoid\nfbCompositeSolidMask_nx1xn (CARD8      op,\n\t\t\t    PicturePtr pSrc,\n\t\t\t    PicturePtr pMask,\n\t\t\t    PicturePtr pDst,\n\t\t\t    INT16      xSrc,\n\t\t\t    INT16      ySrc,\n\t\t\t    INT16      xMask,\n\t\t\t    INT16      yMask,\n\t\t\t    INT16      xDst,\n\t\t\t    INT16      yDst,\n\t\t\t    CARD16     width,\n\t\t\t    CARD16     height)\n{\n    FbBits\t*dstBits;\n    FbStip\t*maskBits;\n    FbStride\tdstStride, maskStride;\n    int\t\tdstBpp, maskBpp;\n    int\t\tdstXoff, dstYoff;\n    int\t\tmaskXoff, maskYoff;\n    FbBits\tsrc;\n\n    fbComposeGetSolid(pSrc, src, pDst->format);\n    fbGetStipDrawable (pMask->pDrawable, maskBits, maskStride, maskBpp, maskXoff, maskYoff);\n    fbGetDrawable (pDst->pDrawable, dstBits, dstStride, dstBpp, dstXoff, dstYoff);\n\n    switch (dstBpp) {\n    case 32:\n\tbreak;\n    case 24:\n\tbreak;\n    case 16:\n\tsrc = cvt8888to0565(src);\n\tbreak;\n    }\n\n    src = fbReplicatePixel (src, dstBpp);\n\n    fbBltOne (maskBits + maskStride * (yMask + maskYoff),\n\t      maskStride,\n\t      xMask + maskXoff,\n\n\t      dstBits + dstStride * (yDst + dstYoff),\n\t      dstStride,\n\t      (xDst + dstXoff) * dstBpp,\n\t      dstBpp,\n\n\t      width * dstBpp,\n\t      height,\n\n\t      0x0,\n\t      src,\n\t      FB_ALLONES,\n\t      0x0);\n\n    fbFinishAccess (pDst->pDrawable);\n    fbFinishAccess (pMask->pDrawable);\n}\n\n# define mod(a,b)\t((b) == 1 ? 0 : (a) >= 0 ? (a) % (b) : (b) - (-a) % (b))\n\n/*\n * Apply a constant alpha value in an over computation\n */\nstatic void\nfbCompositeSrcSrc_nxn  (CARD8\t   op,\n\t\t\tPicturePtr pSrc,\n\t\t\tPicturePtr pMask,\n\t\t\tPicturePtr pDst,\n\t\t\tINT16      xSrc,\n\t\t\tINT16      ySrc,\n\t\t\tINT16      xMask,\n\t\t\tINT16      yMask,\n\t\t\tINT16      xDst,\n\t\t\tINT16      yDst,\n\t\t\tCARD16     width,\n\t\t\tCARD16     height);\n\nstatic void\nfbCompositeTrans_0565xnx0565(CARD8      op,\n\t\t\t     PicturePtr pSrc,\n\t\t\t     PicturePtr pMask,\n\t\t\t     PicturePtr pDst,\n\t\t\t     INT16      xSrc,\n\t\t\t     INT16      ySrc,\n\t\t\t     INT16      xMask,\n\t\t\t     INT16      yMask,\n\t\t\t     INT16      xDst,\n\t\t\t     INT16      yDst,\n\t\t\t     CARD16     width,\n\t\t\t     CARD16     height)\n{\n    CARD16\t*dstLine, *dst;\n    CARD16\t*srcLine, *src;\n    FbStride\tdstStride, srcStride;\n    CARD16\tw;\n    FbBits\tmask;\n    CARD8\tmaskAlpha;\n    CARD16\ts_16, d_16;\n    CARD32\ts_32, d_32;\n    \n    fbComposeGetSolid (pMask, mask, pDst->format);\n    maskAlpha = mask >> 27;\n    \n    if (!maskAlpha)\n\treturn;\n    if (maskAlpha == 0xff)\n    {\n\tfbCompositeSrcSrc_nxn (PictOpSrc, pSrc, pMask, pDst,\n\t\t\t       xSrc, ySrc, xMask, yMask, xDst, yDst, \n\t\t\t       width, height);\n\treturn;\n    }\n\n    fbComposeGetStart (pSrc, xSrc, ySrc, CARD16, srcStride, srcLine, 1);\n    fbComposeGetStart (pDst, xDst, yDst, CARD16, dstStride, dstLine, 1);\n\n    while (height--)\n    {\n\tCARD32 *isrc, *idst;\n\tdst = dstLine;\n\tdstLine += dstStride;\n\tsrc = srcLine;\n\tsrcLine += srcStride;\n\tw = width;\n\t\n\tif(((long)src&1)==1)\n\t{\n\t    s_16 = READ(src++);\n\t    d_16 = READ(dst);\n\t    inOver0565(maskAlpha, s_16, d_16, dst++);\n\t    w--;\n\t}\n\tisrc=(CARD32 *)src;\n\tif(((long)dst&1)==0)\n\t{\n\t    idst=(CARD32 *)dst;\n\t    while (w>1)\n\t    {\n\t\ts_32 = READ(isrc++);\n\t\td_32 = READ(idst);\n\t\tinOver2x0565(maskAlpha, s_32, d_32, idst++);\n\t\tw-=2;\n\t    }\n\t    dst=(CARD16 *)idst;\n\t}\n\telse\n\t{\n\t    while (w > 1)\n\t    {\n\t\ts_32 = READ(isrc++);\n#if IMAGE_BYTE_ORDER == LSBFirst\n\t\ts_16=s_32&0xffff;\n#else\n\t\ts_16=s_32>>16;\n#endif\n\t\td_16 = READ(dst);\n\t\tinOver0565 (maskAlpha, s_16, d_16, dst++);\n#if IMAGE_BYTE_ORDER == LSBFirst\n\t\ts_16=s_32>>16;\n#else\n\t\ts_16=s_32&0xffff;\n#endif\n\t\td_16 = READ(dst);\n\t\tinOver0565(maskAlpha, s_16, d_16, dst++);\n\t\tw-=2;\n\t    }\n\t}\n\tsrc=(CARD16 *)isrc;\n\tif(w!=0)\n\t{\n\t    s_16 = READ(src);\n\t    d_16 = READ(dst);\n\t    inOver0565(maskAlpha, s_16, d_16, dst);\n\t}\n    }\n    \n    fbFinishAccess (pSrc->pDrawable);\n    fbFinishAccess (pDst->pDrawable);\n}\n\n/* macros for \"i can't believe it's not fast\" packed pixel handling */\n#define alphamaskCombine24(a,b) genericCombine24(a,b,maskAlpha,maskiAlpha)\n\nstatic void\nfbCompositeTrans_0888xnx0888(CARD8      op,\n \t\t\t     PicturePtr pSrc,\n \t\t\t     PicturePtr pMask,\n \t\t\t     PicturePtr pDst,\n \t\t\t     INT16      xSrc,\n \t\t\t     INT16      ySrc,\n \t\t\t     INT16      xMask,\n \t\t\t     INT16      yMask,\n \t\t\t     INT16      xDst,\n \t\t\t     INT16      yDst,\n \t\t\t     CARD16     width,\n \t\t\t     CARD16     height)\n{\n    CARD8\t*dstLine, *dst,*idst;\n    CARD8\t*srcLine, *src;\n    FbStride\tdstStride, srcStride;\n    CARD16\tw;\n    FbBits\tmask;\n    CARD16\tmaskAlpha,maskiAlpha;\n    \n    fbComposeGetSolid (pMask, mask, pDst->format);\n    maskAlpha = mask >> 24;\n    maskiAlpha= 255-maskAlpha;\n    \n    if (!maskAlpha)\n \treturn;\n    /*\n      if (maskAlpha == 0xff)\n      {\n      fbCompositeSrc_0888x0888 (op, pSrc, pMask, pDst,\n      xSrc, ySrc, xMask, yMask, xDst, yDst, \n      width, height);\n      return;\n      }\n    */\n    \n    fbComposeGetStart (pSrc, xSrc, ySrc, CARD8, srcStride, srcLine, 3);\n    fbComposeGetStart (pDst, xDst, yDst, CARD8, dstStride, dstLine, 3);\n    \n    {\n\tunsigned long ws,wt;\n\tCARD32 workingSource;\n\tCARD32 *wsrc, *wdst, *widst;\n\tCARD32 rs, rd, nd;\n\tCARD8 *isrc;\n\t\n\t\n\t/* are xSrc and xDst at the same alignment?  if not, we need to be complicated :) */\n\t/* if(0==0) */\n\tif ((((xSrc * 3) & 3) != ((xDst * 3) & 3)) ||\n\t    ((srcStride & 3) != (dstStride & 3)))\n\t{\n\t    while (height--)\n\t    {\n\t\tdst = dstLine;\n\t\tdstLine += dstStride;\n\t\tisrc = src = srcLine;\n\t\tsrcLine += srcStride;\n\t\tw = width*3;\n\t\t\n\t\tsetupPackedReader(ws,wt,isrc,wsrc,workingSource);\n\t\t\n\t\t/* get to word aligned */\n\t\tswitch(~(long)dst&3)\n\t\t{\n\t\tcase 1:\n\t\t    readPackedSource(rs);\n\t\t    /* *dst++=alphamaskCombine24(rs, *dst)>>8; */\n\t\t    rd = READ(dst);  /* make gcc happy.  hope it doens't cost us too much performance*/\n\t\t    WRITE(dst++, alphamaskCombine24(rs, rd) >> 8);\n\t\t    w--; if(w==0) break;\n\t\tcase 2:\n\t\t    readPackedSource(rs);\n\t\t    rd = READ(dst);\n\t\t    WRITE(dst++, alphamaskCombine24(rs, rd) >> 8);\n\t\t    w--; if(w==0) break;\n\t\tcase 3:\n\t\t    readPackedSource(rs);\n\t\t    rd = READ(dst);\n\t\t    WRITE(dst++,alphamaskCombine24(rs, rd) >> 8);\n\t\t    w--; if(w==0) break;\n\t\t}\n\t\twdst=(CARD32 *)dst;\n\t\twhile (w>3)\n\t\t{\n\t\t    rs=READ(wsrc++);\n\t\t    /* FIXME: write a special readPackedWord macro, which knows how to \n\t\t     * halfword combine\n\t\t     */\n#if IMAGE_BYTE_ORDER == LSBFirst\n\t\t    rd=READ(wdst);\n\t\t    readPackedSource(nd);\n\t\t    readPackedSource(rs);\n\t\t    nd|=rs<<8;\n\t\t    readPackedSource(rs);\n\t\t    nd|=rs<<16;\n\t\t    readPackedSource(rs);\n\t\t    nd|=rs<<24;\n#else\n\t\t    readPackedSource(nd);\n\t\t    nd<<=24;\n\t\t    readPackedSource(rs);\n\t\t    nd|=rs<<16;\n\t\t    readPackedSource(rs);\n\t\t    nd|=rs<<8;\n\t\t    readPackedSource(rs);\n\t\t    nd|=rs;\n#endif\n\t\t    inOver0888(maskAlpha, nd, rd, wdst++);\n\t\t    w-=4;\n\t\t}\n\t\tsrc=(CARD8 *)wdst;\n\t\tswitch(w)\n\t\t{\n\t\tcase 3:\n\t\t    readPackedSource(rs);\n\t\t    rd=READ(dst);\n\t\t    WRITE(dst++,alphamaskCombine24(rs, rd)>>8);\n\t\tcase 2:\n\t\t    readPackedSource(rs);\n\t\t    rd = READ(dst);  \n\t\t    WRITE(dst++, alphamaskCombine24(rs, rd)>>8);\n\t\tcase 1:\n\t\t    readPackedSource(rs);\n\t\t    rd = READ(dst);  \n\t\t    WRITE(dst++, alphamaskCombine24(rs, rd)>>8);\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    while (height--)\n\t    {\n\t\tidst=dst = dstLine;\n\t\tdstLine += dstStride;\n\t\tsrc = srcLine;\n\t\tsrcLine += srcStride;\n\t\tw = width*3;\n\t\t/* get to word aligned */\n\t\tswitch(~(long)src&3)\n\t\t{\n\t\tcase 1:\n\t\t    rd=alphamaskCombine24(READ(src++), READ(dst))>>8;\n\t\t    WRITE(dst++, rd);\n\t\t    w--; if(w==0) break;\n\t\tcase 2:\n\t\t    rd=alphamaskCombine24(READ(src++), READ(dst))>>8;\n\t\t    WRITE(dst++, rd);\n\t\t    w--; if(w==0) break;\n\t\tcase 3:\n\t\t    rd=alphamaskCombine24(READ(src++), READ(dst))>>8;\n\t\t    WRITE(dst++, rd);\n\t\t    w--; if(w==0) break;\n\t\t}\n\t\twsrc=(CARD32 *)src;\n\t\twidst=(CARD32 *)dst;\n\t\twhile(w>3)\n\t\t{\n\t\t    rs = READ(wsrc++);\n\t\t    rd = READ(widst);\n\t\t    inOver0888 (maskAlpha, rs, rd, widst++);\n\t\t    w-=4;\n\t\t}\n\t\tsrc=(CARD8 *)wsrc;\n\t\tdst=(CARD8 *)widst;\n\t\tswitch(w)\n\t\t{\n\t\tcase 3:\n\t\t    rd=alphamaskCombine24(READ(src++), READ(dst))>>8;\n\t\t    WRITE(dst++, rd);\n\t\tcase 2:\n\t\t    rd=alphamaskCombine24(READ(src++), READ(dst))>>8;\n\t\t    WRITE(dst++, rd);\n\t\tcase 1:\n\t\t    rd=alphamaskCombine24(READ(src++), READ(dst))>>8;\n\t\t    WRITE(dst++, rd);\n\t\t}\n\t    }\n\t}\n    }\n}\n\n/*\n * Simple bitblt\n */\n\nstatic void\nfbCompositeSrcSrc_nxn  (CARD8\t   op,\n\t\t\tPicturePtr pSrc,\n\t\t\tPicturePtr pMask,\n\t\t\tPicturePtr pDst,\n\t\t\tINT16      xSrc,\n\t\t\tINT16      ySrc,\n\t\t\tINT16      xMask,\n\t\t\tINT16      yMask,\n\t\t\tINT16      xDst,\n\t\t\tINT16      yDst,\n\t\t\tCARD16     width,\n\t\t\tCARD16     height)\n{\n    FbBits\t*dst;\n    FbBits\t*src;\n    FbStride\tdstStride, srcStride;\n    int\t\tsrcXoff, srcYoff;\n    int\t\tdstXoff, dstYoff;\n    int\t\tsrcBpp;\n    int\t\tdstBpp;\n    Bool\treverse = FALSE;\n    Bool\tupsidedown = FALSE;\n    \n    fbGetDrawable(pSrc->pDrawable,src,srcStride,srcBpp,srcXoff,srcYoff);\n    fbGetDrawable(pDst->pDrawable,dst,dstStride,dstBpp,dstXoff,dstYoff);\n\t\n    fbBlt (src + (ySrc + srcYoff) * srcStride,\n\t   srcStride,\n\t   (xSrc + srcXoff) * srcBpp,\n \n\t   dst + (yDst + dstYoff) * dstStride,\n\t   dstStride,\n\t   (xDst + dstXoff) * dstBpp,\n\n\t   (width) * dstBpp,\n\t   (height),\n\n\t   GXcopy,\n\t   FB_ALLONES,\n\t   dstBpp,\n\n\t   reverse,\n\t   upsidedown);\n    \n    fbFinishAccess(pSrc->pDrawable);\n    fbFinishAccess(pDst->pDrawable);\n}\n\n/*\n * Solid fill\nvoid\nfbCompositeSolidSrc_nxn  (CARD8\top,\n\t\t\t  PicturePtr pSrc,\n\t\t\t  PicturePtr pMask,\n\t\t\t  PicturePtr pDst,\n\t\t\t  INT16      xSrc,\n\t\t\t  INT16      ySrc,\n\t\t\t  INT16      xMask,\n\t\t\t  INT16      yMask,\n\t\t\t  INT16      xDst,\n\t\t\t  INT16      yDst,\n\t\t\t  CARD16     width,\n\t\t\t  CARD16     height)\n{\n    \n}\n */\n\n#define SCANLINE_BUFFER_LENGTH 2048\n \nstatic void\nfbCompositeRectWrapper  (CARD8\t   op,\n\t\t\t PicturePtr pSrc,\n\t\t\t PicturePtr pMask,\n\t\t\t PicturePtr pDst,\n\t\t\t INT16      xSrc,\n\t\t\t INT16      ySrc,\n\t\t\t INT16      xMask,\n\t\t\t INT16      yMask,\n\t\t\t INT16      xDst,\n\t\t\t INT16      yDst,\n\t\t\t CARD16     width,\n\t\t\t CARD16     height)\n{\n    CARD32 _scanline_buffer[SCANLINE_BUFFER_LENGTH * 3];\n    CARD32 *scanline_buffer = _scanline_buffer;\n    FbComposeData data;\n\n    data.op = op;\n    data.src = pSrc;\n    data.mask = pMask;\n    data.dest = pDst;\n    data.xSrc = xSrc;\n    data.ySrc = ySrc;\n    data.xMask = xMask;\n }\n \n void\n fbComposite (CARD8      op,\n \t     PicturePtr pSrc,\n \t     PicturePtr pMask,\n\t\t\tcase PICT_x8r8g8b8:\n\t\t\tcase PICT_a8b8g8r8:\n\t\t\tcase PICT_x8b8g8r8:\n#ifdef USE_MMX\n\t\t\t    if (fbHaveMMX())\n\t\t\t\tfunc = fbCompositeSolidMask_nx8x8888mmx;\n\t\t\t    else\n \t     CARD16     width,\n \t     CARD16     height)\n {\n    RegionRec\t    region;\n    int\t\t    n;\n    BoxPtr\t    pbox;\n    CompositeFunc   func = NULL;\n     Bool\t    srcRepeat = pSrc->pDrawable && pSrc->repeatType == RepeatNormal;\n     Bool\t    maskRepeat = FALSE;\n     Bool\t    srcTransform = pSrc->transform != 0;\n\t\t\tbreak;\n     Bool\t    srcAlphaMap = pSrc->alphaMap != 0;\n     Bool\t    maskAlphaMap = FALSE;\n     Bool\t    dstAlphaMap = pDst->alphaMap != 0;\n    int\t\t    x_msk, y_msk, x_src, y_src, x_dst, y_dst;\n    int\t\t    w, h, w_this, h_this;\n \n #ifdef USE_MMX\n     static Bool mmx_setup = FALSE;\n\t\t\t\t    func = fbCompositeSolidMask_nx8888x8888Cmmx;\n\t\t\t\telse\n#endif\n     }\n #endif\n \n    xDst += pDst->pDrawable->x;\n    yDst += pDst->pDrawable->y;\n    if (pSrc->pDrawable) {\n        xSrc += pSrc->pDrawable->x;\n        ySrc += pSrc->pDrawable->y;\n    }\n     if (srcRepeat && srcTransform &&\n \tpSrc->pDrawable->width == 1 &&\n \tpSrc->pDrawable->height == 1)\n\t\t\t\telse\n     \n     if (pMask && pMask->pDrawable)\n     {\n\txMask += pMask->pDrawable->x;\n\tyMask += pMask->pDrawable->y;\n \tmaskRepeat = pMask->repeatType == RepeatNormal;\n \n \tif (pMask->filter == PictFilterConvolution)\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    switch (pDst->format) {\n                            case PICT_r5g6b5:\n                                func = fbCompositeSolidMask_nx8888x0565;\n                                break;\n\t\t\t    default:\n\t\t\t\tbreak;\n                            }\n\t\t\t}\n\t\t\tbreak;\n\t\t    case PICT_a8b8g8r8:\n\t\t\tif (pMask->componentAlpha) {\n\t\t\t    switch (pDst->format) {\n\t\t\t    case PICT_a8b8g8r8:\n\t\t\t    case PICT_x8b8g8r8:\n#ifdef USE_MMX\n\t\t\t\tif (fbHaveMMX())\n\t\t\t\t    func = fbCompositeSolidMask_nx8888x8888Cmmx;\n\t\t\t\telse\n#endif\n\t\t\t\t    func = fbCompositeSolidMask_nx8888x8888C;\n\t\t\t\tbreak;\n\t\t\t    case PICT_b5g6r5:\n#ifdef USE_MMX\n\t\t\t\tif (fbHaveMMX())\n\t\t\t\t    func = fbCompositeSolidMask_nx8888x0565Cmmx;\n\t\t\t\telse\n#endif\n\t\t\t\t    func = fbCompositeSolidMask_nx8888x0565C;\n\t\t\t\tbreak;\n\t\t\t    default:\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    switch (pDst->format) {\n                            case PICT_b5g6r5:\n                                func = fbCompositeSolidMask_nx8888x0565;\n                                break;\n\t\t\t    default:\n\t\t\t\tbreak;\n                            }\n\t\t\t}\n\t\t\tbreak;\n\t\t    case PICT_a1:\n\t\t\tswitch (pDst->format) {\n\t\t\tcase PICT_r5g6b5:\n\t\t\tcase PICT_b5g6r5:\n\t\t\tcase PICT_r8g8b8:\n\t\t\tcase PICT_b8g8r8:\n\t\t\tcase PICT_a8r8g8b8:\n\t\t\tcase PICT_x8r8g8b8:\n\t\t\tcase PICT_a8b8g8r8:\n\t\t\tcase PICT_x8b8g8r8:\n\t\t\t{\n\t\t\t    FbBits src;\n\n\t\t\t    fbComposeGetSolid(pSrc, src, pDst->format);\n\t\t\t    if ((src & 0xff000000) == 0xff000000)\n\t\t\t\tfunc = fbCompositeSolidMask_nx1xn;\n\t\t\t    break;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t    break;\n\t\t\t}\n\t\t\tbreak;\n\t\t    default:\n\t\t\tbreak;\n\t\t    }\n", "target": 1, "idx": 178301}
{"func": "bool ATSParser::PTSTimeDeltaEstablished() {\n if (mPrograms.isEmpty()) {\n return false;\n }\n\n return mPrograms.editItemAt(0)->PTSTimeDeltaEstablished();\n}\n", "target": 0, "idx": 173646}
{"func": "static int store_xauthority(void) {\n\tfs_build_mnt_dir();\n \n \tchar *src;\n \tchar *dest = RUN_XAUTHORITY_FILE;\n \tFILE *fp = fopen(dest, \"w\");\n \tif (fp) {\n \t\tfprintf(fp, \"\\n\");\n\t\tSET_PERMS_STREAM(fp, getuid(), getgid(), 0600);\n\t\tfclose(fp);\n\t}\n\t\n\tif (asprintf(&src, \"%s/.Xauthority\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\t\n\tstruct stat s;\n\tif (stat(src, &s) == 0) {\n\t\tif (is_link(src)) {\n\t\t\tfprintf(stderr, \"Warning: invalid .Xauthority file\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tcopy_file_as_user(src, dest, getuid(), getgid(), 0600);\n\t\tfs_logger2(\"clone\", dest);\n\t\treturn 1; // file copied\n\t}\n\t\n\treturn 0;\n}\n", "target": 1, "idx": 181545}
{"func": "acc_ctx_cont(OM_uint32 *minstat,\n\t     gss_buffer_t buf,\n\t     gss_ctx_id_t *ctx,\n\t     gss_buffer_t *responseToken,\n\t     gss_buffer_t *mechListMIC,\n\t     OM_uint32 *negState,\n\t     send_token_flag *return_token)\n{\n\tOM_uint32 ret, tmpmin;\n\tgss_OID supportedMech;\n\tspnego_gss_ctx_id_t sc;\n\tunsigned int len;\n\tunsigned char *ptr, *bufstart;\n\n\tsc = (spnego_gss_ctx_id_t)*ctx;\n\tret = GSS_S_DEFECTIVE_TOKEN;\n\t*negState = REJECT;\n\t*minstat = 0;\n\tsupportedMech = GSS_C_NO_OID;\n\t*return_token = ERROR_TOKEN_SEND;\n\t*responseToken = *mechListMIC = GSS_C_NO_BUFFER;\n \n \tptr = bufstart = buf->value;\n #define REMAIN (buf->length - (ptr - bufstart))\n\tif (REMAIN > INT_MAX)\n \t\treturn GSS_S_DEFECTIVE_TOKEN;\n \n \t/*\n\t * Attempt to work with old Sun SPNEGO.\n\t */\n\tif (*ptr == HEADER_ID) {\n\t\tret = g_verify_token_header(gss_mech_spnego,\n\t\t\t\t\t    &len, &ptr, 0, REMAIN);\n\t\tif (ret) {\n\t\t\t*minstat = ret;\n\t\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t\t}\n\t}\n\tif (*ptr != (CONTEXT | 0x01)) {\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t}\n\tret = get_negTokenResp(minstat, ptr, REMAIN,\n\t\t\t       negState, &supportedMech,\n\t\t\t       responseToken, mechListMIC);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\n\tif (*responseToken == GSS_C_NO_BUFFER &&\n\t    *mechListMIC == GSS_C_NO_BUFFER) {\n\n\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\tgoto cleanup;\n\t}\n\tif (supportedMech != GSS_C_NO_OID) {\n\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\tgoto cleanup;\n\t}\n\tsc->firstpass = 0;\n\t*negState = ACCEPT_INCOMPLETE;\n\t*return_token = CONT_TOKEN_SEND;\ncleanup:\n\tif (supportedMech != GSS_C_NO_OID) {\n\t\tgeneric_gss_release_oid(&tmpmin, &supportedMech);\n\t}\n\treturn ret;\n#undef REMAIN\n}\n", "target": 1, "idx": 179482}
{"func": "BOOL pnm2png (FILE *pnm_file, FILE *png_file, FILE *alpha_file, BOOL interlace, BOOL alpha)\n {\n   png_struct    *png_ptr = NULL;\n   png_info      *info_ptr = NULL;\n   png_byte      *png_pixels = NULL;\n   png_byte      **row_pointers = NULL;\n   png_byte      *pix_ptr = NULL;\n  png_uint_32   row_bytes;\n \n   char          type_token[16];\n   char          width_token[16];\n   char          height_token[16];\n   char          maxval_token[16];\n  int           color_type;\n   unsigned long   ul_width=0, ul_alpha_width=0;\n   unsigned long   ul_height=0, ul_alpha_height=0;\n   unsigned long   ul_maxval=0;\n  png_uint_32   width, alpha_width;\n  png_uint_32   height, alpha_height;\n   png_uint_32   maxval;\n  int           bit_depth = 0;\n  int           channels;\n   int           alpha_depth = 0;\n  int           alpha_present;\n   int           row, col;\n   BOOL          raw, alpha_raw = FALSE;\n #if defined(PNG_WRITE_INVERT_SUPPORTED) || defined(PNG_WRITE_PACK_SUPPORTED)\n  BOOL          packed_bitmap = FALSE;\n#endif\n  png_uint_32   tmp16;\n int           i;\n\n /* read header of PNM file */\n\n  get_token(pnm_file, type_token);\n if (type_token[0] != 'P')\n {\n return FALSE;\n }\n else if ((type_token[1] == '1') || (type_token[1] == '4'))\n {\n#if defined(PNG_WRITE_INVERT_SUPPORTED) || defined(PNG_WRITE_PACK_SUPPORTED)\n    raw = (type_token[1] == '4');\n    color_type = PNG_COLOR_TYPE_GRAY;\n    get_token(pnm_file, width_token);\n    sscanf (width_token, \"%lu\", &ul_width);\n    width = (png_uint_32) ul_width;\n    get_token(pnm_file, height_token);\n    sscanf (height_token, \"%lu\", &ul_height);\n    height = (png_uint_32) ul_height;\n    bit_depth = 1;\n    packed_bitmap = TRUE;\n#else\n    fprintf (stderr, \"PNM2PNG built without PNG_WRITE_INVERT_SUPPORTED and \\n\");\n    fprintf (stderr, \"PNG_WRITE_PACK_SUPPORTED can't read PBM (P1,P4) files\\n\");\n#endif\n }\n else if ((type_token[1] == '2') || (type_token[1] == '5'))\n {\n    raw = (type_token[1] == '5');\n    color_type = PNG_COLOR_TYPE_GRAY;\n    get_token(pnm_file, width_token);\n    sscanf (width_token, \"%lu\", &ul_width);\n    width = (png_uint_32) ul_width;\n    get_token(pnm_file, height_token);\n    sscanf (height_token, \"%lu\", &ul_height);\n    height = (png_uint_32) ul_height;\n    get_token(pnm_file, maxval_token);\n    sscanf (maxval_token, \"%lu\", &ul_maxval);\n    maxval = (png_uint_32) ul_maxval;\n\n if (maxval <= 1)\n      bit_depth = 1;\n else if (maxval <= 3)\n      bit_depth = 2;\n else if (maxval <= 15)\n      bit_depth = 4;\n else if (maxval <= 255)\n      bit_depth = 8;\n else /* if (maxval <= 65535) */\n      bit_depth = 16;\n }\n else if ((type_token[1] == '3') || (type_token[1] == '6'))\n {\n    raw = (type_token[1] == '6');\n    color_type = PNG_COLOR_TYPE_RGB;\n    get_token(pnm_file, width_token);\n    sscanf (width_token, \"%lu\", &ul_width);\n    width = (png_uint_32) ul_width;\n    get_token(pnm_file, height_token);\n    sscanf (height_token, \"%lu\", &ul_height);\n    height = (png_uint_32) ul_height;\n    get_token(pnm_file, maxval_token);\n    sscanf (maxval_token, \"%lu\", &ul_maxval);\n    maxval = (png_uint_32) ul_maxval;\n if (maxval <= 1)\n      bit_depth = 1;\n else if (maxval <= 3)\n      bit_depth = 2;\n else if (maxval <= 15)\n      bit_depth = 4;\n else if (maxval <= 255)\n      bit_depth = 8;\n else /* if (maxval <= 65535) */\n      bit_depth = 16;\n }\n else\n {\n return FALSE;\n }\n\n /* read header of PGM file with alpha channel */\n\n if (alpha)\n {\n if (color_type == PNG_COLOR_TYPE_GRAY)\n      color_type = PNG_COLOR_TYPE_GRAY_ALPHA;\n if (color_type == PNG_COLOR_TYPE_RGB)\n      color_type = PNG_COLOR_TYPE_RGB_ALPHA;\n\n    get_token(alpha_file, type_token);\n if (type_token[0] != 'P')\n {\n return FALSE;\n }\n else if ((type_token[1] == '2') || (type_token[1] == '5'))\n {\n      alpha_raw = (type_token[1] == '5');\n      get_token(alpha_file, width_token);\n      sscanf (width_token, \"%lu\", &ul_alpha_width);\n      alpha_width=(png_uint_32) ul_alpha_width;\n if (alpha_width != width)\n return FALSE;\n      get_token(alpha_file, height_token);\n      sscanf (height_token, \"%lu\", &ul_alpha_height);\n      alpha_height = (png_uint_32) ul_alpha_height;\n if (alpha_height != height)\n return FALSE;\n      get_token(alpha_file, maxval_token);\n      sscanf (maxval_token, \"%lu\", &ul_maxval);\n      maxval = (png_uint_32) ul_maxval;\n if (maxval <= 1)\n        alpha_depth = 1;\n else if (maxval <= 3)\n        alpha_depth = 2;\n else if (maxval <= 15)\n        alpha_depth = 4;\n else if (maxval <= 255)\n        alpha_depth = 8;\n else /* if (maxval <= 65535) */\n        alpha_depth = 16;\n if (alpha_depth != bit_depth)\n return FALSE;\n }\n else\n {\n return FALSE;\n }\n } /* end if alpha */\n\n /* calculate the number of channels and store alpha-presence */\n if (color_type == PNG_COLOR_TYPE_GRAY)\n    channels = 1;\n else if (color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n    channels = 2;\n else if (color_type == PNG_COLOR_TYPE_RGB)\n\n     channels = 3;\n   else if (color_type == PNG_COLOR_TYPE_RGB_ALPHA)\n     channels = 4;\n   else\n    channels = 0; /* should not happen */\n \n   alpha_present = (channels - 1) % 2;\n \n#if defined(PNG_WRITE_INVERT_SUPPORTED) || defined(PNG_WRITE_PACK_SUPPORTED)\n if (packed_bitmap)\n /* row data is as many bytes as can fit width x channels x bit_depth */\n    row_bytes = (width * channels * bit_depth + 7) / 8;\n else\n#endif\n\n     /* row_bytes is the width x number of channels x (bit-depth / 8) */\n     row_bytes = width * channels * ((bit_depth <= 8) ? 1 : 2);\n \n  if ((png_pixels = (png_byte *) malloc (row_bytes * height * sizeof (png_byte))) == NULL)\n     return FALSE;\n \n   /* read data from PNM file */\n   pix_ptr = png_pixels;\n \n  for (row = 0; row < height; row++)\n   {\n #if defined(PNG_WRITE_INVERT_SUPPORTED) || defined(PNG_WRITE_PACK_SUPPORTED)\n     if (packed_bitmap) {\n      for (i = 0; i < row_bytes; i++)\n         /* png supports this format natively so no conversion is needed */\n         *pix_ptr++ = get_data (pnm_file, 8);\n     } else\n #endif\n     {\n      for (col = 0; col < width; col++)\n       {\n         for (i = 0; i < (channels - alpha_present); i++)\n         {\n if (raw)\n *pix_ptr++ = get_data (pnm_file, bit_depth);\n else\n if (bit_depth <= 8)\n *pix_ptr++ = get_value (pnm_file, bit_depth);\n else\n {\n              tmp16 = get_value (pnm_file, bit_depth);\n *pix_ptr = (png_byte) ((tmp16 >> 8) & 0xFF);\n              pix_ptr++;\n *pix_ptr = (png_byte) (tmp16 & 0xFF);\n              pix_ptr++;\n }\n }\n\n if (alpha) /* read alpha-channel from pgm file */\n {\n if (alpha_raw)\n *pix_ptr++ = get_data (alpha_file, alpha_depth);\n else\n if (alpha_depth <= 8)\n *pix_ptr++ = get_value (alpha_file, bit_depth);\n else\n {\n              tmp16 = get_value (alpha_file, bit_depth);\n *pix_ptr++ = (png_byte) ((tmp16 >> 8) & 0xFF);\n *pix_ptr++ = (png_byte) (tmp16 & 0xFF);\n }\n } /* if alpha */\n } /* if packed_bitmap */\n } /* end for col */\n\n   } /* end for row */\n \n   /* prepare the standard PNG structures */\n  png_ptr = png_create_write_struct (PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);\n   if (!png_ptr)\n   {\n     return FALSE;\n   }\n   info_ptr = png_create_info_struct (png_ptr);\n   if (!info_ptr)\n   {\n     png_destroy_write_struct (&png_ptr, (png_infopp) NULL);\n     return FALSE;\n   }\n \n#if defined(PNG_WRITE_INVERT_SUPPORTED) || defined(PNG_WRITE_PACK_SUPPORTED)\n if (packed_bitmap == TRUE)\n {\n    png_set_packing (png_ptr);\n    png_set_invert_mono (png_ptr);\n }\n#endif\n\n\n   /* setjmp() must be called in every function that calls a PNG-reading libpng function */\n   if (setjmp (png_jmpbuf(png_ptr)))\n   {\n    png_destroy_write_struct (&png_ptr, (png_infopp) NULL);\n     return FALSE;\n   }\n \n /* initialize the png structure */\n  png_init_io (png_ptr, png_file);\n\n /* we're going to write more or less the same PNG as the input file */\n  png_set_IHDR (png_ptr, info_ptr, width, height, bit_depth, color_type,\n (!interlace) ? PNG_INTERLACE_NONE : PNG_INTERLACE_ADAM7,\n    PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);\n\n /* write the file header information */\n  png_write_info (png_ptr, info_ptr);\n\n\n   /* if needed we will allocate memory for an new array of row-pointers */\n   if (row_pointers == (unsigned char**) NULL)\n   {\n    if ((row_pointers = (png_byte **) malloc (height * sizeof (png_bytep))) == NULL)\n     {\n      png_destroy_write_struct (&png_ptr, (png_infopp) NULL);\n       return FALSE;\n     }\n   }\n \n   /* set the individual row_pointers to point at the correct offsets */\n  for (i = 0; i < (height); i++)\n     row_pointers[i] = png_pixels + i * row_bytes;\n \n   /* write out the entire image data in one call */\n   png_write_image (png_ptr, row_pointers);\n \n  /* write the additional chuncks to the PNG file (not really needed) */\n   png_write_end (png_ptr, info_ptr);\n \n   /* clean up after the write, and free any memory allocated */\n  png_destroy_write_struct (&png_ptr, (png_infopp) NULL);\n \n   if (row_pointers != (unsigned char**) NULL)\n     free (row_pointers);\n if (png_pixels != (unsigned char*) NULL)\n    free (png_pixels);\n\n return TRUE;\n} /* end of pnm2png */\n", "target": 1, "idx": 187747}
{"func": "int32_t InputHandler::finishComposition()\n{\n    if (!isActiveTextEdit())\n        return -1;\n\n    if (!compositionActive())\n        return 0;\n\n    removeAttributedTextMarker();\n\n    InputLog(LogLevelInfo, \"InputHandler::finishComposition completed\");\n\n    return 0;\n}\n", "target": 0, "idx": 111468}
{"func": "uint32 PluginInstance::ScheduleTimer(uint32 interval,\n                                     NPBool repeat,\n                                     void (*func)(NPP id, uint32 timer_id)) {\n  uint32 timer_id;\n  timer_id = next_timer_id_;\n  ++next_timer_id_;\n  DCHECK(next_timer_id_ != 0);\n\n  TimerInfo info;\n  info.interval = interval;\n  info.repeat = repeat;\n   timers_[timer_id] = info;\n \n  message_loop_->PostDelayedTask(FROM_HERE,\n                                 NewRunnableMethod(this,\n                                                   &PluginInstance::OnTimerCall,\n                                                   func,\n                                                   npp_,\n                                                   timer_id),\n                                 interval);\n   return timer_id;\n }\n", "target": 1, "idx": 183591}
{"func": "DOMWindow* Document::open(v8::Isolate* isolate,\n                          const USVStringOrTrustedURL& string_or_url,\n                          const AtomicString& name,\n                          const AtomicString& features,\n                          ExceptionState& exception_state) {\n  if (!domWindow()) {\n    exception_state.ThrowDOMException(DOMExceptionCode::kInvalidAccessError,\n                                      \"The document has no window associated.\");\n    return nullptr;\n  }\n\n  return domWindow()->open(isolate, string_or_url, name, features,\n                           exception_state);\n}\n", "target": 0, "idx": 141349}
{"func": "  void SendRequest() {\n    DCHECK_CURRENTLY_ON(BrowserThread::UI);\n\n    if (!service_)\n      return;\n    bool is_extended_reporting = false;\n    if (item_->GetBrowserContext()) {\n      Profile* profile =\n          Profile::FromBrowserContext(item_->GetBrowserContext());\n      is_extended_reporting = profile &&\n                              profile->GetPrefs()->GetBoolean(\n                                  prefs::kSafeBrowsingExtendedReportingEnabled);\n    }\n\n    ClientDownloadRequest request;\n    if (is_extended_reporting) {\n      request.mutable_population()->set_user_population(\n          ChromeUserPopulation::EXTENDED_REPORTING);\n    } else {\n      request.mutable_population()->set_user_population(\n          ChromeUserPopulation::SAFE_BROWSING);\n    }\n    request.set_url(SanitizeUrl(item_->GetUrlChain().back()));\n    request.mutable_digests()->set_sha256(item_->GetHash());\n    request.set_length(item_->GetReceivedBytes());\n    for (size_t i = 0; i < item_->GetUrlChain().size(); ++i) {\n      ClientDownloadRequest::Resource* resource = request.add_resources();\n      resource->set_url(SanitizeUrl(item_->GetUrlChain()[i]));\n      if (i == item_->GetUrlChain().size() - 1) {\n        resource->set_type(ClientDownloadRequest::DOWNLOAD_URL);\n        resource->set_referrer(SanitizeUrl(item_->GetReferrerUrl()));\n        DVLOG(2) << \"dl url \" << resource->url();\n        if (!item_->GetRemoteAddress().empty()) {\n          resource->set_remote_ip(item_->GetRemoteAddress());\n          DVLOG(2) << \"  dl url remote addr: \" << resource->remote_ip();\n        }\n        DVLOG(2) << \"dl referrer \" << resource->referrer();\n      } else {\n        DVLOG(2) << \"dl redirect \" << i << \" \" << resource->url();\n        resource->set_type(ClientDownloadRequest::DOWNLOAD_REDIRECT);\n      }\n    }\n    for (size_t i = 0; i < tab_redirects_.size(); ++i) {\n      ClientDownloadRequest::Resource* resource = request.add_resources();\n      DVLOG(2) << \"tab redirect \" << i << \" \" << tab_redirects_[i].spec();\n      resource->set_url(SanitizeUrl(tab_redirects_[i]));\n      resource->set_type(ClientDownloadRequest::TAB_REDIRECT);\n    }\n    if (tab_url_.is_valid()) {\n      ClientDownloadRequest::Resource* resource = request.add_resources();\n      resource->set_url(SanitizeUrl(tab_url_));\n      DVLOG(2) << \"tab url \" << resource->url();\n      resource->set_type(ClientDownloadRequest::TAB_URL);\n      if (tab_referrer_url_.is_valid()) {\n        resource->set_referrer(SanitizeUrl(tab_referrer_url_));\n        DVLOG(2) << \"tab referrer \" << resource->referrer();\n      }\n    }\n\n    request.set_user_initiated(item_->HasUserGesture());\n    request.set_file_basename(\n        item_->GetTargetFilePath().BaseName().AsUTF8Unsafe());\n    request.set_download_type(type_);\n     request.mutable_signature()->CopyFrom(signature_info_);\n     if (image_headers_)\n       request.set_allocated_image_headers(image_headers_.release());\n    if (zipped_executable_)\n       request.mutable_archived_binary()->Swap(&archived_binary_);\n     if (!request.SerializeToString(&client_download_request_data_)) {\n       FinishRequest(UNKNOWN, REASON_INVALID_REQUEST_PROTO);\n      return;\n    }\n    service_->client_download_request_callbacks_.Notify(item_, &request);\n \n     DVLOG(2) << \"Sending a request for URL: \"\n              << item_->GetUrlChain().back();\n     fetcher_ = net::URLFetcher::Create(0 /* ID used for testing */,\n                                        GetDownloadRequestUrl(),\n                                        net::URLFetcher::POST, this);\n    fetcher_->SetLoadFlags(net::LOAD_DISABLE_CACHE);\n    fetcher_->SetAutomaticallyRetryOn5xx(false);  // Don't retry on error.\n    fetcher_->SetRequestContext(service_->request_context_getter_.get());\n    fetcher_->SetUploadData(\"application/octet-stream\",\n                            client_download_request_data_);\n    request_start_time_ = base::TimeTicks::Now();\n    UMA_HISTOGRAM_COUNTS(\"SBClientDownload.DownloadRequestPayloadSize\",\n                         client_download_request_data_.size());\n    fetcher_->Start();\n  }\n", "target": 1, "idx": 185544}
{"func": "ASN1_OBJECT *OBJ_txt2obj(const char *s, int no_name)\n\t{\n\tint nid = NID_undef;\n\tASN1_OBJECT *op=NULL;\n\tunsigned char *buf;\n\tunsigned char *p;\n\tconst unsigned char *cp;\n\tint i, j;\n\n\tif(!no_name) {\n\t\tif( ((nid = OBJ_sn2nid(s)) != NID_undef) ||\n\t\t\t((nid = OBJ_ln2nid(s)) != NID_undef) ) \n\t\t\t\t\treturn OBJ_nid2obj(nid);\n\t}\n\n\t/* Work out size of content octets */\n\ti=a2d_ASN1_OBJECT(NULL,0,s,-1);\n\tif (i <= 0) {\n\t\t/* Don't clear the error */\n\t\t/*ERR_clear_error();*/\n\t\treturn NULL;\n\t}\n\t/* Work out total size */\n\tj = ASN1_object_size(0,i,V_ASN1_OBJECT);\n\n\tif((buf=(unsigned char *)OPENSSL_malloc(j)) == NULL) return NULL;\n\n\tp = buf;\n\t/* Write out tag+length */\n\tASN1_put_object(&p,0,i,V_ASN1_OBJECT,V_ASN1_UNIVERSAL);\n\t/* Write out contents */\n\ta2d_ASN1_OBJECT(p,i,s,-1);\n\n\tcp=buf;\n\top=d2i_ASN1_OBJECT(NULL,&cp,j);\n\tOPENSSL_free(buf);\n\treturn op;\n\t}\n", "target": 0, "idx": 12477}
{"func": "mm_create(struct mm_master *mmalloc, size_t size)\n{\n\tvoid *address;\n\tstruct mm_master *mm;\n\n\tif (mmalloc == NULL)\n\t\tmm = xcalloc(1, sizeof(struct mm_master));\n\telse\n\t\tmm = mm_xmalloc(mmalloc, sizeof(struct mm_master));\n\n\t/*\n\t * If the memory map has a mm_master it can be completely\n\t * shared including authentication between the child\n\t * and the client.\n\t */\n\tmm->mmalloc = mmalloc;\n\n\taddress = mmap(NULL, size, PROT_WRITE|PROT_READ, MAP_ANON|MAP_SHARED,\n\t    -1, 0);\n\tif (address == MAP_FAILED)\n\t\tfatal(\"mmap(%zu): %s\", size, strerror(errno));\n\n\tmm->address = address;\n\tmm->size = size;\n\n\tRB_INIT(&mm->rb_free);\n\tRB_INIT(&mm->rb_allocated);\n\n\tmm_make_entry(mm, &mm->rb_free, address, size);\n\n\treturn (mm);\n}\n", "target": 0, "idx": 72189}
{"func": " int validate_camera_metadata_structure(const camera_metadata_t *metadata,\n                                        const size_t *expected_size) {\n \n if (metadata == NULL) {\n        ALOGE(\"%s: metadata is null!\", __FUNCTION__);\n return ERROR;\n }\n\n {\n static const struct {\n const char *name;\n size_t alignment;\n } alignments[] = {\n {\n .name = \"camera_metadata\",\n .alignment = METADATA_ALIGNMENT\n },\n {\n .name = \"camera_metadata_buffer_entry\",\n .alignment = ENTRY_ALIGNMENT\n },\n {\n .name = \"camera_metadata_data\",\n .alignment = DATA_ALIGNMENT\n },\n };\n\n for (size_t i = 0; i < sizeof(alignments)/sizeof(alignments[0]); ++i) {\n uintptr_t aligned_ptr = ALIGN_TO(metadata, alignments[i].alignment);\n\n if ((uintptr_t)metadata != aligned_ptr) {\n                ALOGE(\"%s: Metadata pointer is not aligned (actual %p, \"\n \"expected %p) to type %s\",\n                      __FUNCTION__, metadata,\n (void*)aligned_ptr, alignments[i].name);\n return ERROR;\n }\n }\n }\n\n /**\n     * Check that the metadata contents are correct\n     */\n\n if (expected_size != NULL && metadata->size > *expected_size) {\n        ALOGE(\"%s: Metadata size (%\" PRIu32 \") should be <= expected size (%zu)\",\n              __FUNCTION__, metadata->size, *expected_size);\n return ERROR;\n }\n\n if (metadata->entry_count > metadata->entry_capacity) {\n        ALOGE(\"%s: Entry count (%\" PRIu32 \") should be <= entry capacity \"\n \"(%\" PRIu32 \")\",\n              __FUNCTION__, metadata->entry_count, metadata->entry_capacity);\n return ERROR;\n }\n\n const metadata_uptrdiff_t entries_end =\n        metadata->entries_start + metadata->entry_capacity;\n if (entries_end < metadata->entries_start || // overflow check\n        entries_end > metadata->data_start) {\n\n        ALOGE(\"%s: Entry start + capacity (%\" PRIu32 \") should be <= data start \"\n \"(%\" PRIu32 \")\",\n               __FUNCTION__,\n (metadata->entries_start + metadata->entry_capacity),\n              metadata->data_start);\n return ERROR;\n }\n\n const metadata_uptrdiff_t data_end =\n        metadata->data_start + metadata->data_capacity;\n if (data_end < metadata->data_start || // overflow check\n        data_end > metadata->size) {\n\n        ALOGE(\"%s: Data start + capacity (%\" PRIu32 \") should be <= total size \"\n \"(%\" PRIu32 \")\",\n               __FUNCTION__,\n (metadata->data_start + metadata->data_capacity),\n              metadata->size);\n return ERROR;\n }\n\n const metadata_size_t entry_count = metadata->entry_count;\n camera_metadata_buffer_entry_t *entries = get_entries(metadata);\n\n for (size_t i = 0; i < entry_count; ++i) {\n\n if ((uintptr_t)&entries[i] != ALIGN_TO(&entries[i], ENTRY_ALIGNMENT)) {\n            ALOGE(\"%s: Entry index %zu had bad alignment (address %p),\"\n \" expected alignment %zu\",\n                  __FUNCTION__, i, &entries[i], ENTRY_ALIGNMENT);\n return ERROR;\n }\n\n camera_metadata_buffer_entry_t entry = entries[i];\n\n if (entry.type >= NUM_TYPES) {\n            ALOGE(\"%s: Entry index %zu had a bad type %d\",\n                  __FUNCTION__, i, entry.type);\n return ERROR;\n }\n\n uint32_t tag_section = entry.tag >> 16;\n int tag_type = get_camera_metadata_tag_type(entry.tag);\n if (tag_type != (int)entry.type && tag_section < VENDOR_SECTION) {\n            ALOGE(\"%s: Entry index %zu had tag type %d, but the type was %d\",\n                  __FUNCTION__, i, tag_type, entry.type);\n\n             return ERROR;\n         }\n \n        size_t data_size =\n                calculate_camera_metadata_entry_data_size(entry.type,\n                                                          entry.count);\n \n         if (data_size != 0) {\n             camera_metadata_data_t *data =\n (camera_metadata_data_t*) (get_data(metadata) +\n                                               entry.data.offset);\n\n if ((uintptr_t)data != ALIGN_TO(data, DATA_ALIGNMENT)) {\n                ALOGE(\"%s: Entry index %zu had bad data alignment (address %p),\"\n \" expected align %zu, (tag name %s, data size %zu)\",\n                      __FUNCTION__, i, data, DATA_ALIGNMENT,\n                      get_camera_metadata_tag_name(entry.tag) ?: \"unknown\",\n                      data_size);\n return ERROR;\n }\n\n size_t data_entry_end = entry.data.offset + data_size;\n if (data_entry_end < entry.data.offset || // overflow check\n                data_entry_end > metadata->data_capacity) {\n\n                ALOGE(\"%s: Entry index %zu data ends (%zu) beyond the capacity \"\n \"%\" PRIu32, __FUNCTION__, i, data_entry_end,\n                      metadata->data_capacity);\n return ERROR;\n }\n\n } else if (entry.count == 0) {\n if (entry.data.offset != 0) {\n                ALOGE(\"%s: Entry index %zu had 0 items, but offset was non-0 \"\n \"(%\" PRIu32 \"), tag name: %s\", __FUNCTION__, i, entry.data.offset,\n                        get_camera_metadata_tag_name(entry.tag) ?: \"unknown\");\n return ERROR;\n }\n } // else data stored inline, so we look at value which can be anything.\n }\n\n return OK;\n}\n", "target": 1, "idx": 187417}
{"func": "void AppCacheUpdateJob::StartUpdate(AppCacheHost* host,\n                                    const GURL& new_master_resource) {\n  DCHECK(group_->update_job() == this);\n  DCHECK(!group_->is_obsolete());\n\n  bool is_new_pending_master_entry = false;\n  if (!new_master_resource.is_empty()) {\n    DCHECK(new_master_resource == host->pending_master_entry_url());\n     DCHECK(!new_master_resource.has_ref());\n     DCHECK(new_master_resource.GetOrigin() == manifest_url_.GetOrigin());\n \n     if (IsTerminating()) {\n       group_->QueueUpdate(host, new_master_resource);\n      return;\n    }\n\n    std::pair<PendingMasters::iterator, bool> ret =\n        pending_master_entries_.insert(\n            PendingMasters::value_type(new_master_resource, PendingHosts()));\n    is_new_pending_master_entry = ret.second;\n    ret.first->second.push_back(host);\n    host->AddObserver(this);\n  }\n\n  AppCacheGroup::UpdateAppCacheStatus update_status = group_->update_status();\n  if (update_status == AppCacheGroup::CHECKING ||\n      update_status == AppCacheGroup::DOWNLOADING) {\n    if (host) {\n      NotifySingleHost(host, APPCACHE_CHECKING_EVENT);\n      if (update_status == AppCacheGroup::DOWNLOADING)\n        NotifySingleHost(host, APPCACHE_DOWNLOADING_EVENT);\n\n      if (!new_master_resource.is_empty()) {\n        AddMasterEntryToFetchList(host, new_master_resource,\n                                  is_new_pending_master_entry);\n      }\n    }\n    return;\n  }\n\n  MadeProgress();\n  group_->SetUpdateAppCacheStatus(AppCacheGroup::CHECKING);\n  if (group_->HasCache()) {\n    base::TimeDelta kFullUpdateInterval = base::TimeDelta::FromHours(24);\n    update_type_ = UPGRADE_ATTEMPT;\n    base::TimeDelta time_since_last_check =\n        base::Time::Now() - group_->last_full_update_check_time();\n    doing_full_update_check_ = time_since_last_check > kFullUpdateInterval;\n    NotifyAllAssociatedHosts(APPCACHE_CHECKING_EVENT);\n  } else {\n    update_type_ = CACHE_ATTEMPT;\n    doing_full_update_check_ = true;\n    DCHECK(host);\n    NotifySingleHost(host, APPCACHE_CHECKING_EVENT);\n  }\n\n  if (!new_master_resource.is_empty()) {\n    AddMasterEntryToFetchList(host, new_master_resource,\n                              is_new_pending_master_entry);\n  }\n\n  BrowserThread::PostAfterStartupTask(\n      FROM_HERE, base::ThreadTaskRunnerHandle::Get(),\n      base::Bind(&AppCacheUpdateJob::FetchManifest, weak_factory_.GetWeakPtr(),\n                 true));\n}\n", "target": 1, "idx": 185610}
{"func": "SampleTable::SampleTable(const sp<DataSource> &source)\n : mDataSource(source),\n      mChunkOffsetOffset(-1),\n      mChunkOffsetType(0),\n      mNumChunkOffsets(0),\n      mSampleToChunkOffset(-1),\n      mNumSampleToChunkOffsets(0),\n      mSampleSizeOffset(-1),\n\n       mSampleSizeFieldSize(0),\n       mDefaultSampleSize(0),\n       mNumSampleSizes(0),\n       mTimeToSampleCount(0),\n       mTimeToSample(),\n       mSampleTimeEntries(NULL),\n      mCompositionTimeDeltaEntries(NULL),\n      mNumCompositionTimeDeltaEntries(0),\n      mCompositionDeltaLookup(new CompositionDeltaLookup),\n      mSyncSampleOffset(-1),\n      mNumSyncSamples(0),\n      mSyncSamples(NULL),\n      mLastSyncSampleIndex(0),\n      mSampleToChunkEntries(NULL) {\n    mSampleIterator = new SampleIterator(this);\n}\n", "target": 1, "idx": 187793}
{"func": "nfssvc_decode_writeargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_writeargs *args)\n{\n\tunsigned int len, hdr, dlen;\n\tstruct kvec *head = rqstp->rq_arg.head;\n\tint v;\n\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\n\tp++;\t\t\t\t/* beginoffset */\n\targs->offset = ntohl(*p++);\t/* offset */\n\tp++;\t\t\t\t/* totalcount */\n\tlen = args->len = ntohl(*p++);\n\t/*\n\t * The protocol specifies a maximum of 8192 bytes.\n\t */\n\tif (len > NFSSVC_MAXBLKSIZE_V2)\n\t\treturn 0;\n\n\t/*\n\t * Check to make sure that we got the right number of\n \t * bytes.\n \t */\n \thdr = (void*)p - head->iov_base;\n \tdlen = head->iov_len + rqstp->rq_arg.page_len - hdr;\n \n \t/*\n\t * Round the length of the data which was specified up to\n\t * the next multiple of XDR units and then compare that\n\t * against the length which was actually received.\n\t * Note that when RPCSEC/GSS (for example) is used, the\n\t * data buffer can be padded so dlen might be larger\n\t * than required.  It must never be smaller.\n\t */\n\tif (dlen < XDR_QUADLEN(len)*4)\n\t\treturn 0;\n\n\trqstp->rq_vec[0].iov_base = (void*)p;\n\trqstp->rq_vec[0].iov_len = head->iov_len - hdr;\n\tv = 0;\n\twhile (len > rqstp->rq_vec[v].iov_len) {\n\t\tlen -= rqstp->rq_vec[v].iov_len;\n\t\tv++;\n\t\trqstp->rq_vec[v].iov_base = page_address(rqstp->rq_pages[v]);\n\t\trqstp->rq_vec[v].iov_len = PAGE_SIZE;\n\t}\n\trqstp->rq_vec[v].iov_len = len;\n\targs->vlen = v + 1;\n\treturn 1;\n}\n", "target": 1, "idx": 181412}
{"func": "WebContents* GetEmbedderForGuest(content::WebContents* guest) {\n  CHECK(guest);\n  return static_cast<content::WebContentsImpl*>(guest)->GetOuterWebContents();\n}\n", "target": 0, "idx": 169244}
{"func": "static void ifb_setup(struct net_device *dev)\n{\n\t/* Initialize the device structure. */\n\tdev->destructor = free_netdev;\n\tdev->netdev_ops = &ifb_netdev_ops;\n\n\t/* Fill in device structure with ethernet-generic values. */\n\tether_setup(dev);\n\tdev->tx_queue_len = TX_Q_LIMIT;\n\n\tdev->features |= IFB_FEATURES;\n\tdev->vlan_features |= IFB_FEATURES;\n \n \tdev->flags |= IFF_NOARP;\n \tdev->flags &= ~IFF_MULTICAST;\n\tdev->priv_flags &= ~IFF_XMIT_DST_RELEASE;\n \trandom_ether_addr(dev->dev_addr);\n }\n", "target": 1, "idx": 178900}
{"func": "bool SiteInstanceImpl::ShouldLockToOrigin(BrowserContext* browser_context,\n                                          GURL site_url) {\n  if (RenderProcessHost::run_renderer_in_process())\n    return false;\n\n  if (!DoesSiteRequireDedicatedProcess(browser_context, site_url))\n    return false;\n\n   if (site_url.SchemeIs(content::kGuestScheme))\n     return false;\n \n  if (site_url.SchemeIs(content::kChromeUIScheme))\n    return false;\n  if (!GetContentClient()->browser()->ShouldLockToOrigin(browser_context,\n                                                         site_url)) {\n    return false;\n  }\n\n  return true;\n}\n", "target": 1, "idx": 187304}
{"func": "MagickExport char *GetNextImageProfile(const Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->profiles == (SplayTreeInfo *) NULL)\n    return((char *) NULL);\n  return((char *) GetNextKeyInSplayTree((SplayTreeInfo *) image->profiles));\n}\n", "target": 0, "idx": 73392}
{"func": "i915_gem_execbuffer2(struct drm_device *dev, void *data,\n\t\t     struct drm_file *file)\n{\n\tstruct drm_i915_gem_execbuffer2 *args = data;\n \tstruct drm_i915_gem_exec_object2 *exec2_list = NULL;\n \tint ret;\n \n\tif (args->buffer_count < 1) {\n \t\tDRM_DEBUG(\"execbuf2 with %d buffers\\n\", args->buffer_count);\n \t\treturn -EINVAL;\n \t}\n\n\texec2_list = kmalloc(sizeof(*exec2_list)*args->buffer_count,\n\t\t\t     GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY);\n\tif (exec2_list == NULL)\n\t\texec2_list = drm_malloc_ab(sizeof(*exec2_list),\n\t\t\t\t\t   args->buffer_count);\n\tif (exec2_list == NULL) {\n\t\tDRM_DEBUG(\"Failed to allocate exec list for %d buffers\\n\",\n\t\t\t  args->buffer_count);\n\t\treturn -ENOMEM;\n\t}\n\tret = copy_from_user(exec2_list,\n\t\t\t     (struct drm_i915_relocation_entry __user *)\n\t\t\t     (uintptr_t) args->buffers_ptr,\n\t\t\t     sizeof(*exec2_list) * args->buffer_count);\n\tif (ret != 0) {\n\t\tDRM_DEBUG(\"copy %d exec entries failed %d\\n\",\n\t\t\t  args->buffer_count, ret);\n\t\tdrm_free_large(exec2_list);\n\t\treturn -EFAULT;\n\t}\n\n\tret = i915_gem_do_execbuffer(dev, data, file, args, exec2_list);\n\tif (!ret) {\n\t\t/* Copy the new buffer offsets back to the user's exec list. */\n\t\tret = copy_to_user((struct drm_i915_relocation_entry __user *)\n\t\t\t\t   (uintptr_t) args->buffers_ptr,\n\t\t\t\t   exec2_list,\n\t\t\t\t   sizeof(*exec2_list) * args->buffer_count);\n\t\tif (ret) {\n\t\t\tret = -EFAULT;\n\t\t\tDRM_DEBUG(\"failed to copy %d exec entries \"\n\t\t\t\t  \"back to user (%d)\\n\",\n\t\t\t\t  args->buffer_count, ret);\n\t\t}\n\t}\n\n\tdrm_free_large(exec2_list);\n\treturn ret;\n}\n", "target": 1, "idx": 178769}
{"func": "bool AppCacheDatabase::FindEntriesForCache(int64_t cache_id,\n                                           std::vector<EntryRecord>* records) {\n  DCHECK(records && records->empty());\n  if (!LazyOpen(kDontCreate))\n     return false;\n \n   static const char kSql[] =\n      \"SELECT cache_id, url, flags, response_id, response_size FROM Entries\"\n       \"  WHERE cache_id = ?\";\n \n   sql::Statement statement(db_->GetCachedStatement(SQL_FROM_HERE, kSql));\n  statement.BindInt64(0, cache_id);\n\n  while (statement.Step()) {\n    records->push_back(EntryRecord());\n    ReadEntryRecord(statement, &records->back());\n    DCHECK(records->back().cache_id == cache_id);\n  }\n\n  return statement.Succeeded();\n}\n", "target": 1, "idx": 186953}
{"func": "static void vc1_put_blocks_clamped(VC1Context *v, int put_signed)\n{\n    MpegEncContext *s = &v->s;\n    uint8_t *dest;\n    int block_count = CONFIG_GRAY && (s->avctx->flags & AV_CODEC_FLAG_GRAY) ? 4 : 6;\n    int fieldtx = 0;\n    int i;\n\n    /* The put pixels loop is one MB row and one MB column behind the decoding\n     * loop because we can only put pixels when overlap filtering is done. For\n     * interlaced frame pictures, however, the put pixels loop is only one\n     * column behind the decoding loop as interlaced frame pictures only need\n     * horizontal overlap filtering. */\n    if (!s->first_slice_line && v->fcm != ILACE_FRAME) {\n        if (s->mb_x) {\n            for (i = 0; i < block_count; i++) {\n                if (i > 3 ? v->mb_type[0][s->block_index[i] - s->block_wrap[i] - 1] :\n                            v->mb_type[0][s->block_index[i] - 2 * s->block_wrap[i] - 2]) {\n                    dest = s->dest[0] + ((i & 2) - 4) * 4 * s->linesize + ((i & 1) - 2) * 8;\n                    if (put_signed)\n                        s->idsp.put_signed_pixels_clamped(v->block[v->topleft_blk_idx][block_map[i]],\n                                                          i > 3 ? s->dest[i - 3] - 8 * s->uvlinesize - 8 : dest,\n                                                          i > 3 ? s->uvlinesize : s->linesize);\n                    else\n                        s->idsp.put_pixels_clamped(v->block[v->topleft_blk_idx][block_map[i]],\n                                                   i > 3 ? s->dest[i - 3] - 8 * s->uvlinesize - 8 : dest,\n                                                   i > 3 ? s->uvlinesize : s->linesize);\n                }\n            }\n        }\n        if (s->mb_x == v->end_mb_x - 1) {\n            for (i = 0; i < block_count; i++) {\n                if (i > 3 ? v->mb_type[0][s->block_index[i] - s->block_wrap[i]] :\n                            v->mb_type[0][s->block_index[i] - 2 * s->block_wrap[i]]) {\n                    dest = s->dest[0] + ((i & 2) - 4) * 4 * s->linesize + (i & 1) * 8;\n                    if (put_signed)\n                        s->idsp.put_signed_pixels_clamped(v->block[v->top_blk_idx][block_map[i]],\n                                                          i > 3 ? s->dest[i - 3] - 8 * s->uvlinesize : dest,\n                                                          i > 3 ? s->uvlinesize : s->linesize);\n                    else\n                        s->idsp.put_pixels_clamped(v->block[v->top_blk_idx][block_map[i]],\n                                                   i > 3 ? s->dest[i - 3] - 8 * s->uvlinesize : dest,\n                                                   i > 3 ? s->uvlinesize : s->linesize);\n                }\n            }\n        }\n    }\n    if (s->mb_y == s->end_mb_y - 1 || v->fcm == ILACE_FRAME) {\n        if (s->mb_x) {\n            if (v->fcm == ILACE_FRAME)\n                fieldtx = v->fieldtx_plane[s->mb_y * s->mb_stride + s->mb_x - 1];\n            for (i = 0; i < block_count; i++) {\n                if (i > 3 ? v->mb_type[0][s->block_index[i] - 1] :\n                            v->mb_type[0][s->block_index[i] - 2]) {\n                    if (fieldtx)\n                        dest = s->dest[0] + ((i & 2) >> 1) * s->linesize + ((i & 1) - 2) * 8;\n                    else\n                        dest = s->dest[0] + (i & 2) * 4 * s->linesize + ((i & 1) - 2) * 8;\n                    if (put_signed)\n                        s->idsp.put_signed_pixels_clamped(v->block[v->left_blk_idx][block_map[i]],\n                                                          i > 3 ? s->dest[i - 3] - 8 : dest,\n                                                          i > 3 ? s->uvlinesize : s->linesize << fieldtx);\n                    else\n                        s->idsp.put_pixels_clamped(v->block[v->left_blk_idx][block_map[i]],\n                                                   i > 3 ? s->dest[i - 3] - 8 : dest,\n                                                   i > 3 ? s->uvlinesize : s->linesize << fieldtx);\n                }\n            }\n        }\n        if (s->mb_x == v->end_mb_x - 1) {\n            if (v->fcm == ILACE_FRAME)\n                fieldtx = v->fieldtx_plane[s->mb_y * s->mb_stride + s->mb_x];\n            for (i = 0; i < block_count; i++) {\n                if (v->mb_type[0][s->block_index[i]]) {\n                    if (fieldtx)\n                        dest = s->dest[0] + ((i & 2) >> 1) * s->linesize + (i & 1) * 8;\n                    else\n                        dest = s->dest[0] + (i & 2) * 4 * s->linesize + (i & 1) * 8;\n                    if (put_signed)\n                        s->idsp.put_signed_pixels_clamped(v->block[v->cur_blk_idx][block_map[i]],\n                                                          i > 3 ? s->dest[i - 3] : dest,\n                                                          i > 3 ? s->uvlinesize : s->linesize << fieldtx);\n                    else\n                        s->idsp.put_pixels_clamped(v->block[v->cur_blk_idx][block_map[i]],\n                                                   i > 3 ? s->dest[i - 3] : dest,\n                                                   i > 3 ? s->uvlinesize : s->linesize << fieldtx);\n                }\n            }\n        }\n    }\n}\n", "target": 0, "idx": 79865}
{"func": "int create_flush_cmd_control(struct f2fs_sb_info *sbi)\n{\n\tdev_t dev = sbi->sb->s_bdev->bd_dev;\n\tstruct flush_cmd_control *fcc;\n\tint err = 0;\n\n\tif (SM_I(sbi)->fcc_info) {\n\t\tfcc = SM_I(sbi)->fcc_info;\n\t\tgoto init_thread;\n\t}\n\n\tfcc = kzalloc(sizeof(struct flush_cmd_control), GFP_KERNEL);\n\tif (!fcc)\n\t\treturn -ENOMEM;\n\tatomic_set(&fcc->issued_flush, 0);\n\tatomic_set(&fcc->issing_flush, 0);\n \tinit_waitqueue_head(&fcc->flush_wait_queue);\n \tinit_llist_head(&fcc->issue_list);\n \tSM_I(sbi)->fcc_info = fcc;\n init_thread:\n \tfcc->f2fs_issue_flush = kthread_run(issue_flush_thread, sbi,\n \t\t\t\t\"f2fs_flush-%u:%u\", MAJOR(dev), MINOR(dev));\n\tif (IS_ERR(fcc->f2fs_issue_flush)) {\n\t\terr = PTR_ERR(fcc->f2fs_issue_flush);\n\t\tkfree(fcc);\n\t\tSM_I(sbi)->fcc_info = NULL;\n\t\treturn err;\n\t}\n\n\treturn err;\n}\n", "target": 1, "idx": 182554}
{"func": "void ide_dma_cb(void *opaque, int ret)\n{\n    IDEState *s = opaque;\n    int n;\n    int64_t sector_num;\n    bool stay_active = false;\n\n    if (ret == -ECANCELED) {\n        return;\n    }\n    if (ret < 0) {\n        int op = IDE_RETRY_DMA;\n\n        if (s->dma_cmd == IDE_DMA_READ)\n            op |= IDE_RETRY_READ;\n        else if (s->dma_cmd == IDE_DMA_TRIM)\n            op |= IDE_RETRY_TRIM;\n\n        if (ide_handle_rw_error(s, -ret, op)) {\n            return;\n        }\n    }\n\n    n = s->io_buffer_size >> 9;\n    if (n > s->nsector) {\n        /* The PRDs were longer than needed for this request. Shorten them so\n         * we don't get a negative remainder. The Active bit must remain set\n         * after the request completes. */\n        n = s->nsector;\n        stay_active = true;\n    }\n\n    sector_num = ide_get_sector(s);\n    if (n > 0) {\n        assert(s->io_buffer_size == s->sg.size);\n        dma_buf_commit(s, s->io_buffer_size);\n        sector_num += n;\n        ide_set_sector(s, sector_num);\n        s->nsector -= n;\n    }\n\n    /* end of transfer ? */\n    if (s->nsector == 0) {\n        s->status = READY_STAT | SEEK_STAT;\n        ide_set_irq(s->bus);\n        goto eot;\n    }\n\n    /* launch next transfer */\n     n = s->nsector;\n     s->io_buffer_index = 0;\n     s->io_buffer_size = n * 512;\n    if (s->bus->dma->ops->prepare_buf(s->bus->dma, ide_cmd_is_read(s)) == 0) {\n         /* The PRDs were too short. Reset the Active bit, but don't raise an\n          * interrupt. */\n         s->status = READY_STAT | SEEK_STAT;\n         goto eot;\n     }\n \n    printf(\"ide_dma_cb: sector_num=%\" PRId64 \" n=%d, cmd_cmd=%d\\n\",\n           sector_num, n, s->dma_cmd);\n#endif\n\n    if ((s->dma_cmd == IDE_DMA_READ || s->dma_cmd == IDE_DMA_WRITE) &&\n        !ide_sect_range_ok(s, sector_num, n)) {\n        ide_dma_error(s);\n        return;\n    }\n\n    switch (s->dma_cmd) {\n    case IDE_DMA_READ:\n        s->bus->dma->aiocb = dma_blk_read(s->blk, &s->sg, sector_num,\n                                          ide_dma_cb, s);\n        break;\n    case IDE_DMA_WRITE:\n        s->bus->dma->aiocb = dma_blk_write(s->blk, &s->sg, sector_num,\n                                           ide_dma_cb, s);\n        break;\n    case IDE_DMA_TRIM:\n        s->bus->dma->aiocb = dma_blk_io(s->blk, &s->sg, sector_num,\n                                        ide_issue_trim, ide_dma_cb, s,\n                                        DMA_DIRECTION_TO_DEVICE);\n        break;\n    }\n    return;\n\neot:\n    if (s->dma_cmd == IDE_DMA_READ || s->dma_cmd == IDE_DMA_WRITE) {\n        block_acct_done(blk_get_stats(s->blk), &s->acct);\n    }\n    ide_set_inactive(s, stay_active);\n}\n", "target": 1, "idx": 178011}
{"func": "   bool ReceiverWasAdded(const RtpTransceiverState& transceiver_state) {\n     uintptr_t receiver_id = RTCRtpReceiver::getId(\n         transceiver_state.receiver_state()->webrtc_receiver().get());\n     for (const auto& receiver : handler_->rtp_receivers_) {\n      if (receiver->Id() == receiver_id)\n        return false;\n    }\n    return true;\n  }\n", "target": 1, "idx": 187060}
{"func": "bool Instance::HandleInputEvent(const pp::InputEvent& event) {\n  pp::InputEvent event_device_res(event);\n  {\n    pp::MouseInputEvent mouse_event(event);\n    if (!mouse_event.is_null()) {\n      pp::Point point = mouse_event.GetPosition();\n      pp::Point movement = mouse_event.GetMovement();\n      ScalePoint(device_scale_, &point);\n      ScalePoint(device_scale_, &movement);\n      mouse_event = pp::MouseInputEvent(\n          this,\n          event.GetType(),\n          event.GetTimeStamp(),\n          event.GetModifiers(),\n          mouse_event.GetButton(),\n          point,\n          mouse_event.GetClickCount(),\n          movement);\n      event_device_res = mouse_event;\n    }\n  }\n\n  if (event.GetType() == PP_INPUTEVENT_TYPE_MOUSEMOVE &&\n     (event.GetModifiers() & PP_INPUTEVENT_MODIFIER_MIDDLEBUTTONDOWN)) {\n    pp::MouseInputEvent mouse_event(event_device_res);\n    pp::Point pos = mouse_event.GetPosition();\n    EnableAutoscroll(pos);\n    UpdateCursor(CalculateAutoscroll(pos));\n    return true;\n  } else {\n    DisableAutoscroll();\n  }\n\n#ifdef ENABLE_THUMBNAILS\n  if (event.GetType() == PP_INPUTEVENT_TYPE_MOUSELEAVE)\n    thumbnails_.SlideOut();\n\n  if (thumbnails_.HandleEvent(event_device_res))\n    return true;\n#endif\n\n  if (toolbar_->HandleEvent(event_device_res))\n    return true;\n\n#ifdef ENABLE_THUMBNAILS\n  if (v_scrollbar_.get() && event.GetType() == PP_INPUTEVENT_TYPE_MOUSEMOVE) {\n    pp::MouseInputEvent mouse_event(event);\n    pp::Point pt = mouse_event.GetPosition();\n    pp::Rect v_scrollbar_rc;\n    v_scrollbar_->GetLocation(&v_scrollbar_rc);\n    if (v_scrollbar_rc.Contains(pt) &&\n        (event.GetModifiers() & PP_INPUTEVENT_MODIFIER_LEFTBUTTONDOWN)) {\n      thumbnails_.SlideIn();\n    }\n\n    if (!v_scrollbar_rc.Contains(pt) && thumbnails_.visible() &&\n        !(event.GetModifiers() & PP_INPUTEVENT_MODIFIER_LEFTBUTTONDOWN) &&\n        !thumbnails_.rect().Contains(pt)) {\n      thumbnails_.SlideOut();\n    }\n  }\n#endif\n\n  pp::InputEvent offset_event(event_device_res);\n  bool try_engine_first = true;\n  switch (offset_event.GetType()) {\n    case PP_INPUTEVENT_TYPE_MOUSEDOWN:\n    case PP_INPUTEVENT_TYPE_MOUSEUP:\n    case PP_INPUTEVENT_TYPE_MOUSEMOVE:\n    case PP_INPUTEVENT_TYPE_MOUSEENTER:\n    case PP_INPUTEVENT_TYPE_MOUSELEAVE: {\n      pp::MouseInputEvent mouse_event(event_device_res);\n      pp::MouseInputEvent mouse_event_dip(event);\n      pp::Point point = mouse_event.GetPosition();\n      point.set_x(point.x() - available_area_.x());\n      offset_event = pp::MouseInputEvent(\n          this,\n          event.GetType(),\n          event.GetTimeStamp(),\n          event.GetModifiers(),\n          mouse_event.GetButton(),\n          point,\n          mouse_event.GetClickCount(),\n          mouse_event.GetMovement());\n      if (!engine_->IsSelecting()) {\n        if (!IsOverlayScrollbar() &&\n            !available_area_.Contains(mouse_event.GetPosition())) {\n          try_engine_first = false;\n        } else if (IsOverlayScrollbar()) {\n          pp::Rect temp;\n          if ((v_scrollbar_.get() && v_scrollbar_->GetLocation(&temp) &&\n              temp.Contains(mouse_event_dip.GetPosition())) ||\n              (h_scrollbar_.get() && h_scrollbar_->GetLocation(&temp) &&\n              temp.Contains(mouse_event_dip.GetPosition()))) {\n            try_engine_first = false;\n          }\n        }\n      }\n      break;\n    }\n    default:\n      break;\n  }\n  if (try_engine_first && engine_->HandleEvent(offset_event))\n    return true;\n\n  if (v_scrollbar_.get() && event.GetType() == PP_INPUTEVENT_TYPE_KEYDOWN) {\n    pp::KeyboardInputEvent keyboard_event(event);\n    bool no_h_scrollbar = !h_scrollbar_.get();\n    uint32_t key_code = keyboard_event.GetKeyCode();\n    bool page_down = no_h_scrollbar && key_code == ui::VKEY_RIGHT;\n    bool page_up = no_h_scrollbar && key_code == ui::VKEY_LEFT;\n    if (zoom_mode_ == ZOOM_FIT_TO_PAGE) {\n      bool has_shift =\n          keyboard_event.GetModifiers() & PP_INPUTEVENT_MODIFIER_SHIFTKEY;\n      bool key_is_space = key_code == ui::VKEY_SPACE;\n      page_down |= key_is_space || key_code == ui::VKEY_NEXT;\n      page_up |= (key_is_space && has_shift) || (key_code == ui::VKEY_PRIOR);\n     }\n     if (page_down) {\n       int page = engine_->GetFirstVisiblePage();\n      if (engine_->GetPageRect(page).bottom() * zoom_ <=\n          v_scrollbar_->GetValue())\n        page++;\n      ScrollToPage(page + 1);\n      UpdateCursor(PP_CURSORTYPE_POINTER);\n       return true;\n     } else if (page_up) {\n       int page = engine_->GetFirstVisiblePage();\n       if (engine_->GetPageRect(page).y() * zoom_ >= v_scrollbar_->GetValue())\n         page--;\n       ScrollToPage(page);\n      UpdateCursor(PP_CURSORTYPE_POINTER);\n      return true;\n    }\n  }\n\n  if (v_scrollbar_.get() && v_scrollbar_->HandleEvent(event)) {\n    UpdateCursor(PP_CURSORTYPE_POINTER);\n    return true;\n  }\n\n  if (h_scrollbar_.get() && h_scrollbar_->HandleEvent(event)) {\n    UpdateCursor(PP_CURSORTYPE_POINTER);\n    return true;\n  }\n\n  if (timer_pending_ &&\n      (event.GetType() == PP_INPUTEVENT_TYPE_MOUSEUP ||\n       event.GetType() == PP_INPUTEVENT_TYPE_MOUSEMOVE)) {\n    timer_factory_.CancelAll();\n    timer_pending_ = false;\n  } else if (event.GetType() == PP_INPUTEVENT_TYPE_MOUSEMOVE &&\n             engine_->IsSelecting()) {\n    bool set_timer = false;\n    pp::MouseInputEvent mouse_event(event);\n    if (v_scrollbar_.get() &&\n        (mouse_event.GetPosition().y() <= 0 ||\n         mouse_event.GetPosition().y() >= (plugin_dip_size_.height() - 1))) {\n      v_scrollbar_->ScrollBy(\n          PP_SCROLLBY_LINE, mouse_event.GetPosition().y() >= 0 ? 1: -1);\n      set_timer = true;\n    }\n    if (h_scrollbar_.get() &&\n        (mouse_event.GetPosition().x() <= 0 ||\n         mouse_event.GetPosition().x() >= (plugin_dip_size_.width() - 1))) {\n      h_scrollbar_->ScrollBy(PP_SCROLLBY_LINE,\n          mouse_event.GetPosition().x() >= 0 ? 1: -1);\n      set_timer = true;\n    }\n\n    if (set_timer) {\n      last_mouse_event_ = pp::MouseInputEvent(event);\n\n      pp::CompletionCallback callback =\n          timer_factory_.NewCallback(&Instance::OnTimerFired);\n      pp::Module::Get()->core()->CallOnMainThread(kDragTimerMs, callback);\n      timer_pending_ = true;\n    }\n  }\n\n  if (event.GetType() == PP_INPUTEVENT_TYPE_KEYDOWN &&\n      event.GetModifiers() & kDefaultKeyModifier) {\n    pp::KeyboardInputEvent keyboard_event(event);\n    switch (keyboard_event.GetKeyCode()) {\n      case 'A':\n        engine_->SelectAll();\n        return true;\n    }\n  }\n\n  return (event.GetType() == PP_INPUTEVENT_TYPE_MOUSEDOWN);\n}\n", "target": 1, "idx": 185343}
{"func": "void red_channel_push(RedChannel *channel)\n{\n    RingItem *link;\n    RingItem *next;\n    RedChannelClient *rcc;\n\n    if (!channel) {\n        return;\n    }\n    RING_FOREACH_SAFE(link, next, &channel->clients) {\n        rcc = SPICE_CONTAINEROF(link, RedChannelClient, channel_link);\n        red_channel_client_push(rcc);\n    }\n}\n", "target": 0, "idx": 2171}
{"func": " av_cold void ff_mpv_idct_init(MpegEncContext *s)\n {\n     ff_idctdsp_init(&s->idsp, s->avctx);\n \n     /* load & permutate scantables\n     * note: only wmv uses different ones\n     */\n    if (s->alternate_scan) {\n        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable, ff_alternate_vertical_scan);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, ff_alternate_vertical_scan);\n    } else {\n        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable, ff_zigzag_direct);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, ff_zigzag_direct);\n    }\n    ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_horizontal_scan);\n    ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);\n}\n", "target": 1, "idx": 182362}
{"func": "static Image *ReadOneJNGImage(MngInfo *mng_info,\n    const ImageInfo *image_info, ExceptionInfo *exception)\n{\n  Image\n    *alpha_image,\n    *color_image,\n    *image,\n    *jng_image;\n\n  ImageInfo\n    *alpha_image_info,\n    *color_image_info;\n\n  MagickBooleanType\n    logging;\n\n  int\n    unique_filenames;\n\n  ssize_t\n    y;\n\n  MagickBooleanType\n    status;\n\n  png_uint_32\n    jng_height,\n    jng_width;\n\n  png_byte\n    jng_color_type,\n    jng_image_sample_depth,\n    jng_image_compression_method,\n    jng_image_interlace_method,\n    jng_alpha_sample_depth,\n    jng_alpha_compression_method,\n    jng_alpha_filter_method,\n    jng_alpha_interlace_method;\n\n  register const PixelPacket\n    *s;\n\n  register ssize_t\n    i,\n    x;\n\n  register PixelPacket\n    *q;\n\n  register unsigned char\n    *p;\n\n  unsigned int\n    read_JSEP,\n    reading_idat;\n\n  size_t\n    length;\n\n  jng_alpha_compression_method=0;\n  jng_alpha_sample_depth=8;\n  jng_color_type=0;\n  jng_height=0;\n  jng_width=0;\n  alpha_image=(Image *) NULL;\n  color_image=(Image *) NULL;\n  alpha_image_info=(ImageInfo *) NULL;\n  color_image_info=(ImageInfo *) NULL;\n  unique_filenames=0;\n\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  Enter ReadOneJNGImage()\");\n\n  image=mng_info->image;\n\n  if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL)\n    {\n      /*\n        Allocate next image structure.\n      */\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"  AcquireNextImage()\");\n\n      AcquireNextImage(image_info,image);\n\n      if (GetNextImageInList(image) == (Image *) NULL)\n        return(DestroyImageList(image));\n\n      image=SyncNextImageInList(image);\n    }\n  mng_info->image=image;\n\n  /*\n    Signature bytes have already been read.\n  */\n\n  read_JSEP=MagickFalse;\n  reading_idat=MagickFalse;\n  for (;;)\n  {\n    char\n      type[MaxTextExtent];\n\n    unsigned char\n      *chunk;\n\n    unsigned int\n      count;\n\n    /*\n      Read a new JNG chunk.\n    */\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n      2*GetBlobSize(image));\n\n    if (status == MagickFalse)\n      break;\n\n    type[0]='\\0';\n    (void) ConcatenateMagickString(type,\"errr\",MaxTextExtent);\n    length=ReadBlobMSBLong(image);\n    count=(unsigned int) ReadBlob(image,4,(unsigned char *) type);\n\n    if (logging != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Reading JNG chunk type %c%c%c%c, length: %.20g\",\n        type[0],type[1],type[2],type[3],(double) length);\n\n    if (length > PNG_UINT_31_MAX || count == 0)\n      ThrowReaderException(CorruptImageError,\"CorruptImage\");\n\n    p=NULL;\n    chunk=(unsigned char *) NULL;\n \n     if (length != 0)\n       {\n         chunk=(unsigned char *) AcquireQuantumMemory(length+MagickPathExtent,\n           sizeof(*chunk));\n \n        if (chunk == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        for (i=0; i < (ssize_t) length; i++)\n        {\n          int\n            c;\n\n          c=ReadBlobByte(image);\n          if (c == EOF)\n            break;\n          chunk[i]=(unsigned char) c;\n        }\n\n        p=chunk;\n      }\n\n    (void) ReadBlobMSBLong(image);  /* read crc word */\n\n    if (memcmp(type,mng_JHDR,4) == 0)\n      {\n        if (length == 16)\n          {\n            jng_width=(size_t) ((p[0] << 24) | (p[1] << 16) |\n              (p[2] << 8) | p[3]);\n            jng_height=(size_t) ((p[4] << 24) | (p[5] << 16) |\n              (p[6] << 8) | p[7]);\n            if ((jng_width == 0) || (jng_height == 0))\n              ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n            jng_color_type=p[8];\n            jng_image_sample_depth=p[9];\n            jng_image_compression_method=p[10];\n            jng_image_interlace_method=p[11];\n\n            image->interlace=jng_image_interlace_method != 0 ? PNGInterlace :\n              NoInterlace;\n\n            jng_alpha_sample_depth=p[12];\n            jng_alpha_compression_method=p[13];\n            jng_alpha_filter_method=p[14];\n            jng_alpha_interlace_method=p[15];\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_width:      %16lu,    jng_height:     %16lu\\n\"\n                  \"    jng_color_type: %16d,     jng_image_sample_depth: %3d\\n\"\n                  \"    jng_image_compression_method:%3d\",\n                  (unsigned long) jng_width, (unsigned long) jng_height,\n                  jng_color_type, jng_image_sample_depth,\n                  jng_image_compression_method);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_image_interlace_method:  %3d\"\n                  \"    jng_alpha_sample_depth:      %3d\",\n                  jng_image_interlace_method,\n                  jng_alpha_sample_depth);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_alpha_compression_method:%3d\\n\"\n                  \"    jng_alpha_filter_method:     %3d\\n\"\n                  \"    jng_alpha_interlace_method:  %3d\",\n                  jng_alpha_compression_method,\n                  jng_alpha_filter_method,\n                  jng_alpha_interlace_method);\n              }\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n\n    if ((reading_idat == MagickFalse) && (read_JSEP == MagickFalse) &&\n        ((memcmp(type,mng_JDAT,4) == 0) || (memcmp(type,mng_JdAA,4) == 0) ||\n         (memcmp(type,mng_IDAT,4) == 0) || (memcmp(type,mng_JDAA,4) == 0)))\n      {\n        /*\n           o create color_image\n           o open color_blob, attached to color_image\n           o if (color type has alpha)\n               open alpha_blob, attached to alpha_image\n        */\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Creating color_blob.\");\n\n        color_image_info=(ImageInfo *)AcquireMagickMemory(sizeof(ImageInfo));\n\n        if (color_image_info == (ImageInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        GetImageInfo(color_image_info);\n        color_image=AcquireImage(color_image_info);\n\n        if (color_image == (Image *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        (void) AcquireUniqueFilename(color_image->filename);\n        unique_filenames++;\n        status=OpenBlob(color_image_info,color_image,WriteBinaryBlobMode,\n          exception);\n\n        if (status == MagickFalse)\n          {\n            color_image=DestroyImage(color_image);\n            return(DestroyImageList(image));\n          }\n\n        if ((image_info->ping == MagickFalse) && (jng_color_type >= 12))\n          {\n            alpha_image_info=(ImageInfo *)\n              AcquireMagickMemory(sizeof(ImageInfo));\n\n            if (alpha_image_info == (ImageInfo *) NULL)\n              {\n                color_image=DestroyImage(color_image);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n\n            GetImageInfo(alpha_image_info);\n            alpha_image=AcquireImage(alpha_image_info);\n\n            if (alpha_image == (Image *) NULL)\n              {\n                alpha_image_info=DestroyImageInfo(alpha_image_info);\n                color_image=DestroyImage(color_image);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Creating alpha_blob.\");\n\n            (void) AcquireUniqueFilename(alpha_image->filename);\n            unique_filenames++;\n            status=OpenBlob(alpha_image_info,alpha_image,WriteBinaryBlobMode,\n              exception);\n\n            if (status == MagickFalse)\n              {\n                alpha_image=DestroyImage(alpha_image);\n                alpha_image_info=DestroyImageInfo(alpha_image_info);\n                color_image=DestroyImage(color_image);\n                return(DestroyImageList(image));\n              }\n\n            if (jng_alpha_compression_method == 0)\n              {\n                unsigned char\n                  data[18];\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Writing IHDR chunk to alpha_blob.\");\n\n                (void) WriteBlob(alpha_image,8,(const unsigned char *)\n                  \"\\211PNG\\r\\n\\032\\n\");\n\n                (void) WriteBlobMSBULong(alpha_image,13L);\n                PNGType(data,mng_IHDR);\n                LogPNGChunk(logging,mng_IHDR,13L);\n                PNGLong(data+4,jng_width);\n                PNGLong(data+8,jng_height);\n                data[12]=jng_alpha_sample_depth;\n                data[13]=0; /* color_type gray */\n                data[14]=0; /* compression method 0 */\n                data[15]=0; /* filter_method 0 */\n                data[16]=0; /* interlace_method 0 */\n                (void) WriteBlob(alpha_image,17,data);\n                (void) WriteBlobMSBULong(alpha_image,crc32(0,data,17));\n              }\n          }\n        reading_idat=MagickTrue;\n      }\n\n    if (memcmp(type,mng_JDAT,4) == 0)\n      {\n        /* Copy chunk to color_image->blob */\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Copying JDAT chunk data to color_blob.\");\n\n        if (length != 0)\n          {\n            (void) WriteBlob(color_image,length,chunk);\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n          }\n\n        continue;\n      }\n\n    if (memcmp(type,mng_IDAT,4) == 0)\n      {\n        png_byte\n           data[5];\n\n        /* Copy IDAT header and chunk data to alpha_image->blob */\n\n        if (alpha_image != NULL && image_info->ping == MagickFalse)\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Copying IDAT chunk data to alpha_blob.\");\n\n            (void) WriteBlobMSBULong(alpha_image,(size_t) length);\n            PNGType(data,mng_IDAT);\n            LogPNGChunk(logging,mng_IDAT,length);\n            (void) WriteBlob(alpha_image,4,data);\n            (void) WriteBlob(alpha_image,length,chunk);\n            (void) WriteBlobMSBULong(alpha_image,\n              crc32(crc32(0,data,4),chunk,(uInt) length));\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if ((memcmp(type,mng_JDAA,4) == 0) || (memcmp(type,mng_JdAA,4) == 0))\n      {\n        /* Copy chunk data to alpha_image->blob */\n\n        if (alpha_image != NULL && image_info->ping == MagickFalse)\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Copying JDAA chunk data to alpha_blob.\");\n\n            (void) WriteBlob(alpha_image,length,chunk);\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_JSEP,4) == 0)\n      {\n        read_JSEP=MagickTrue;\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_bKGD,4) == 0)\n      {\n        if (length == 2)\n          {\n            image->background_color.red=ScaleCharToQuantum(p[1]);\n            image->background_color.green=image->background_color.red;\n            image->background_color.blue=image->background_color.red;\n          }\n\n        if (length == 6)\n          {\n            image->background_color.red=ScaleCharToQuantum(p[1]);\n            image->background_color.green=ScaleCharToQuantum(p[3]);\n            image->background_color.blue=ScaleCharToQuantum(p[5]);\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_gAMA,4) == 0)\n      {\n        if (length == 4)\n          image->gamma=((float) mng_get_long(p))*0.00001;\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_cHRM,4) == 0)\n      {\n        if (length == 32)\n          {\n            image->chromaticity.white_point.x=0.00001*mng_get_long(p);\n            image->chromaticity.white_point.y=0.00001*mng_get_long(&p[4]);\n            image->chromaticity.red_primary.x=0.00001*mng_get_long(&p[8]);\n            image->chromaticity.red_primary.y=0.00001*mng_get_long(&p[12]);\n            image->chromaticity.green_primary.x=0.00001*mng_get_long(&p[16]);\n            image->chromaticity.green_primary.y=0.00001*mng_get_long(&p[20]);\n            image->chromaticity.blue_primary.x=0.00001*mng_get_long(&p[24]);\n            image->chromaticity.blue_primary.y=0.00001*mng_get_long(&p[28]);\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_sRGB,4) == 0)\n      {\n        if (length == 1)\n          {\n            image->rendering_intent=\n              Magick_RenderingIntent_from_PNG_RenderingIntent(p[0]);\n            image->gamma=1.000f/2.200f;\n            image->chromaticity.red_primary.x=0.6400f;\n            image->chromaticity.red_primary.y=0.3300f;\n            image->chromaticity.green_primary.x=0.3000f;\n            image->chromaticity.green_primary.y=0.6000f;\n            image->chromaticity.blue_primary.x=0.1500f;\n            image->chromaticity.blue_primary.y=0.0600f;\n            image->chromaticity.white_point.x=0.3127f;\n            image->chromaticity.white_point.y=0.3290f;\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_oFFs,4) == 0)\n      {\n        if (length > 8)\n          {\n            image->page.x=(ssize_t) mng_get_long(p);\n            image->page.y=(ssize_t) mng_get_long(&p[4]);\n\n            if ((int) p[8] != 0)\n              {\n                image->page.x/=10000;\n                image->page.y/=10000;\n              }\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_pHYs,4) == 0)\n      {\n        if (length > 8)\n          {\n            image->x_resolution=(double) mng_get_long(p);\n            image->y_resolution=(double) mng_get_long(&p[4]);\n            if ((int) p[8] == PNG_RESOLUTION_METER)\n              {\n                image->units=PixelsPerCentimeterResolution;\n                image->x_resolution=image->x_resolution/100.0f;\n                image->y_resolution=image->y_resolution/100.0f;\n              }\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n#if 0\n    if (memcmp(type,mng_iCCP,4) == 0)\n      {\n        /* To do: */\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n#endif\n\n    if (length != 0)\n      chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n    if (memcmp(type,mng_IEND,4))\n      continue;\n\n    break;\n  }\n\n\n  /* IEND found */\n\n  /*\n    Finish up reading image data:\n\n       o read main image from color_blob.\n\n       o close color_blob.\n\n       o if (color_type has alpha)\n            if alpha_encoding is PNG\n               read secondary image from alpha_blob via ReadPNG\n            if alpha_encoding is JPEG\n               read secondary image from alpha_blob via ReadJPEG\n\n       o close alpha_blob.\n\n       o copy intensity of secondary image into\n         opacity samples of main image.\n\n       o destroy the secondary image.\n  */\n\n  if (color_image_info == (ImageInfo *) NULL)\n    {\n      assert(color_image == (Image *) NULL);\n      assert(alpha_image == (Image *) NULL);\n      return(DestroyImageList(image));\n    }\n\n  if (color_image == (Image *) NULL)\n    {\n      assert(alpha_image == (Image *) NULL);\n      return(DestroyImageList(image));\n    }\n\n  (void) SeekBlob(color_image,0,SEEK_SET);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Reading jng_image from color_blob.\");\n\n  assert(color_image_info != (ImageInfo *) NULL);\n  (void) FormatLocaleString(color_image_info->filename,MaxTextExtent,\"%s\",\n    color_image->filename);\n\n  color_image_info->ping=MagickFalse;   /* To do: avoid this */\n  jng_image=ReadImage(color_image_info,exception);\n\n  (void) RelinquishUniqueFileResource(color_image->filename);\n  unique_filenames--;\n  color_image=DestroyImage(color_image);\n  color_image_info=DestroyImageInfo(color_image_info);\n\n  if (jng_image == (Image *) NULL)\n    return(DestroyImageList(image));\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Copying jng_image pixels to main image.\");\n  image->columns=jng_width;\n  image->rows=jng_height;\n  length=image->columns*sizeof(PixelPacket);\n\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    s=GetVirtualPixels(jng_image,0,y,image->columns,1,&image->exception);\n    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    (void) CopyMagickMemory(q,s,length);\n\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n  }\n\n  jng_image=DestroyImage(jng_image);\n\n  if (image_info->ping == MagickFalse)\n    {\n     if (jng_color_type >= 12)\n       {\n         if (jng_alpha_compression_method == 0)\n           {\n             png_byte\n               data[5];\n             (void) WriteBlobMSBULong(alpha_image,0x00000000L);\n             PNGType(data,mng_IEND);\n             LogPNGChunk(logging,mng_IEND,0L);\n             (void) WriteBlob(alpha_image,4,data);\n             (void) WriteBlobMSBULong(alpha_image,crc32(0,data,4));\n           }\n\n         (void) SeekBlob(alpha_image,0,SEEK_SET);\n\n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"    Reading opacity from alpha_blob.\");\n\n         (void) FormatLocaleString(alpha_image_info->filename,MaxTextExtent,\n           \"%s\",alpha_image->filename);\n\n         jng_image=ReadImage(alpha_image_info,exception);\n\n         if (jng_image != (Image *) NULL)\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             s=GetVirtualPixels(jng_image,0,y,image->columns,1,\n                &image->exception);\n             q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n             if (image->matte != MagickFalse)\n               for (x=(ssize_t) image->columns; x != 0; x--,q++,s++)\n                  SetPixelOpacity(q,QuantumRange-\n                      GetPixelRed(s));\n\n             else\n               for (x=(ssize_t) image->columns; x != 0; x--,q++,s++)\n               {\n                  SetPixelAlpha(q,GetPixelRed(s));\n                  if (GetPixelOpacity(q) != OpaqueOpacity)\n                    image->matte=MagickTrue;\n               }\n\n             if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               break;\n           }\n         (void) RelinquishUniqueFileResource(alpha_image->filename);\n         unique_filenames--;\n         alpha_image=DestroyImage(alpha_image);\n         alpha_image_info=DestroyImageInfo(alpha_image_info);\n         if (jng_image != (Image *) NULL)\n           jng_image=DestroyImage(jng_image);\n       }\n    }\n\n  /* Read the JNG image.  */\n\n  if (mng_info->mng_type == 0)\n    {\n      mng_info->mng_width=jng_width;\n      mng_info->mng_height=jng_height;\n    }\n\n  if (image->page.width == 0 && image->page.height == 0)\n    {\n      image->page.width=jng_width;\n      image->page.height=jng_height;\n    }\n\n  if (image->page.x == 0 && image->page.y == 0)\n    {\n      image->page.x=mng_info->x_off[mng_info->object_id];\n      image->page.y=mng_info->y_off[mng_info->object_id];\n    }\n\n  else\n    {\n      image->page.y=mng_info->y_off[mng_info->object_id];\n    }\n\n  mng_info->image_found++;\n  status=SetImageProgress(image,LoadImagesTag,2*TellBlob(image),\n    2*GetBlobSize(image));\n\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  exit ReadOneJNGImage(); unique_filenames=%d\",unique_filenames);\n\n  return(image);\n}\n", "target": 1, "idx": 181151}
{"func": "nfsd4_close(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t    struct nfsd4_close *close)\n{\n\t__be32 status;\n\tstruct nfs4_ol_stateid *stp;\n\tstruct net *net = SVC_NET(rqstp);\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tdprintk(\"NFSD: nfsd4_close on file %pd\\n\", \n\t\t\tcstate->current_fh.fh_dentry);\n\n\tstatus = nfs4_preprocess_seqid_op(cstate, close->cl_seqid,\n\t\t\t\t\t&close->cl_stateid,\n\t\t\t\t\tNFS4_OPEN_STID|NFS4_CLOSED_STID,\n\t\t\t\t\t&stp, nn);\n\tnfsd4_bump_seqid(cstate, status);\n\tif (status)\n\t\tgoto out; \n\tnfs4_inc_and_copy_stateid(&close->cl_stateid, &stp->st_stid);\n\tmutex_unlock(&stp->st_mutex);\n\n\tnfsd4_close_open_stateid(stp);\n\n\t/* put reference from nfs4_preprocess_seqid_op */\n\tnfs4_put_stid(&stp->st_stid);\nout:\n\treturn status;\n}\n", "target": 0, "idx": 65570}
{"func": "net::BackoffEntry* DataReductionProxyConfigServiceClient::GetBackoffEntry() {\n  DCHECK(thread_checker_.CalledOnValidThread());\n  return &backoff_entry_;\n}\n", "target": 0, "idx": 150576}
{"func": "std::string ExtractResourceId(const GURL& url) {\n  return net::UnescapeURLComponent(url.ExtractFileName(),\n                                   net::UnescapeRule::URL_SPECIAL_CHARS);\n}\n", "target": 0, "idx": 111633}
{"func": "static int collationMatch(const char *zColl, Index *pIndex){\n  int i;\n  assert( zColl!=0 );\n  for(i=0; i<pIndex->nColumn; i++){\n    const char *z = pIndex->azColl[i];\n    assert( z!=0 || pIndex->aiColumn[i]<0 );\n    if( pIndex->aiColumn[i]>=0 && 0==sqlite3StrICmp(z, zColl) ){\n      return 1;\n    }\n  }\n  return 0;\n}\n", "target": 0, "idx": 149098}
{"func": "GLES2Implementation::SingleThreadChecker::~SingleThreadChecker() {\n  --gles2_implementation_->use_count_;\n  CHECK_EQ(0, gles2_implementation_->use_count_);\n}\n", "target": 0, "idx": 153860}
{"func": "INST_HANDLER (muls) {\t// MULS Rd, Rr\n\tint d = (buf[0] >> 4 & 0x0f) + 16;\n\tint r = (buf[0] & 0x0f) + 16;\n\n\tESIL_A (\"r%d,DUP,0x80,&,?{,0xffff00,|,},\", r);\t// sign extension Rr\n\tESIL_A (\"r%d,DUP,0x80,&,?{,0xffff00,|,},\", d);\t// sign extension Rd\n\tESIL_A (\"*,\");\t\t\t\t\t// 0: (Rd*Rr)\n\tESIL_A (\"DUP,0xff,&,r0,=,\");\t\t\t// r0 = LO(0)\n\tESIL_A (\"8,0,RPICK,>>,0xff,&,r1,=,\");\t\t// r1 = HI(0)\n\tESIL_A (\"DUP,0x8000,&,!,!,cf,=,\");\t\t// C = R/15\n\tESIL_A (\"DUP,!,zf,=,\");\t\t\t\t// Z = !R\n}\n", "target": 0, "idx": 82740}
{"func": "parse_post_op_attr(netdissect_options *ndo,\n                   const uint32_t *dp, int verbose)\n{\n\tND_TCHECK(dp[0]);\n\tif (!EXTRACT_32BITS(&dp[0]))\n\t\treturn (dp + 1);\n\tdp++;\n\tif (verbose) {\n\t\treturn parsefattr(ndo, dp, verbose, 1);\n\t} else\n\t\treturn (dp + (NFSX_V3FATTR / sizeof (uint32_t)));\ntrunc:\n\treturn (NULL);\n}\n", "target": 0, "idx": 62446}
{"func": "static int su3000_frontend_attach(struct dvb_usb_adapter *d)\n {\n\tu8 obuf[3] = { 0xe, 0x80, 0 };\n\tu8 ibuf[] = { 0 };\n \n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n \t\terr(\"command 0x0e transfer failed.\");\n \n\tobuf[0] = 0xe;\n\tobuf[1] = 0x02;\n\tobuf[2] = 1;\n \n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n \t\terr(\"command 0x0e transfer failed.\");\n \tmsleep(300);\n \n\tobuf[0] = 0xe;\n\tobuf[1] = 0x83;\n\tobuf[2] = 0;\n \n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n \t\terr(\"command 0x0e transfer failed.\");\n \n\tobuf[0] = 0xe;\n\tobuf[1] = 0x83;\n\tobuf[2] = 1;\n \n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n \t\terr(\"command 0x0e transfer failed.\");\n \n\tobuf[0] = 0x51;\n \n\tif (dvb_usb_generic_rw(d->dev, obuf, 1, ibuf, 1, 0) < 0)\n \t\terr(\"command 0x51 transfer failed.\");\n \n\td->fe_adap[0].fe = dvb_attach(ds3000_attach, &su3000_ds3000_config,\n\t\t\t\t\t&d->dev->i2c_adap);\n\tif (d->fe_adap[0].fe == NULL)\n \t\treturn -EIO;\n \n\tif (dvb_attach(ts2020_attach, d->fe_adap[0].fe,\n \t\t\t\t&dw2104_ts2020_config,\n\t\t\t\t&d->dev->i2c_adap)) {\n \t\tinfo(\"Attached DS3000/TS2020!\");\n \t\treturn 0;\n \t}\n\n\tinfo(\"Failed to attach DS3000/TS2020!\");\n \treturn -EIO;\n }\n", "target": 1, "idx": 181397}
{"func": " bool BluetoothDeviceChromeOS::ExpectingConfirmation() const {\n  return !confirmation_callback_.is_null();\n }\n", "target": 1, "idx": 184916}
{"func": " bool SoundPool::unload(int sampleID)\n{\n    ALOGV(\"unload: sampleID=%d\", sampleID);\n Mutex::Autolock lock(&mLock);\n return mSamples.removeItem(sampleID);\n}\n", "target": 0, "idx": 175100}
{"func": "static int dynamicGetbuf(gdIOCtxPtr ctx, void *buf, int len)\n{\n\tint rlen, remain;\n\tdpIOCtxPtr dctx;\n\tdynamicPtr *dp;\n\n\tdctx = (dpIOCtxPtr) ctx;\n\tdp = dctx->dp;\n\n\tremain = dp->logicalSize - dp->pos;\n \tif(remain >= len) {\n \t\trlen = len;\n \t} else {\n\t\tif(remain == 0) {\n \t\t\t/* 2.0.34: EOF is incorrect. We use 0 for\n \t\t\t * errors and EOF, just like fileGetbuf,\n \t\t\t * which is a simple fread() wrapper.\n\t\t\t * TBB. Original bug report: Daniel Cowgill. */\n\t\t\treturn 0; /* NOT EOF */\n\t\t}\n\n\t\trlen = remain;\n\t}\n\n\tmemcpy(buf, (void *) ((char *)dp->data + dp->pos), rlen);\n\tdp->pos += rlen;\n\n\treturn rlen;\n}\n", "target": 1, "idx": 181941}
{"func": " ServiceWorkerHandler::ServiceWorkerHandler()\n     : DevToolsDomainHandler(ServiceWorker::Metainfo::domainName),\n       enabled_(false),\n      process_(nullptr),\n       weak_factory_(this) {}\n", "target": 1, "idx": 186745}
{"func": "  void CheckMaybeActivateDataReductionProxy(bool initially_enabled,\n                                            bool request_succeeded,\n                                            bool expected_enabled,\n                                            bool expected_restricted,\n                                            bool expected_fallback_restricted) {\n    test_context_->SetDataReductionProxyEnabled(initially_enabled);\n    test_context_->config()->UpdateConfigForTesting(initially_enabled,\n                                                    request_succeeded, true);\n    ExpectSetProxyPrefs(expected_enabled, false);\n     settings_->MaybeActivateDataReductionProxy(false);\n     test_context_->RunUntilIdle();\n   }\n", "target": 0, "idx": 155522}
{"func": "void Chunk::changesAndSize( RIFF_MetaHandler* handler )\n{\n\thasChange = false; // unknown chunk ==> no change, naturally\n\tthis->newSize = this->oldSize;\n}\n", "target": 0, "idx": 16071}
{"func": " void OffscreenCanvasSurfaceImpl::Create(\n    mojo::InterfaceRequest<blink::mojom::OffscreenCanvasSurface> request) {\n  mojo::MakeStrongBinding(base::MakeUnique<OffscreenCanvasSurfaceImpl>(),\n                          std::move(request));\n}\n", "target": 0, "idx": 139766}
{"func": "void Dispatcher::OnShouldSuspend(const std::string& extension_id,\n                                 uint64_t sequence_id) {\n  RenderThread::Get()->Send(\n      new ExtensionHostMsg_ShouldSuspendAck(extension_id, sequence_id));\n}\n", "target": 0, "idx": 145243}
{"func": "static void fpu_init(struct sh_fpu_soft_struct *fpu)\n{\n\tint i;\n\n\tfpu->fpscr = FPSCR_INIT;\n\tfpu->fpul = 0;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tfpu->fp_regs[i] = 0;\n\t\tfpu->xfp_regs[i]= 0;\n\t}\n}\n", "target": 0, "idx": 25611}
{"func": " static void sycc422_to_rgb(opj_image_t *img)\n {\t\n \tint *d0, *d1, *d2, *r, *g, *b;\n \tconst int *y, *cb, *cr;\n\tunsigned int maxw, maxh, max;\n \tint offset, upb;\n\tunsigned int i, j;\n \n \tupb = (int)img->comps[0].prec;\n \toffset = 1<<(upb - 1); upb = (1<<upb)-1;\n \n\tmaxw = (unsigned int)img->comps[0].w; maxh = (unsigned int)img->comps[0].h;\n \tmax = maxw * maxh;\n \n \ty = img->comps[0].data;\n \tcb = img->comps[1].data;\n \tcr = img->comps[2].data;\n \n\td0 = r = (int*)malloc(sizeof(int) * (size_t)max);\n\td1 = g = (int*)malloc(sizeof(int) * (size_t)max);\n\td2 = b = (int*)malloc(sizeof(int) * (size_t)max);\n \n \tif(r == NULL || g == NULL || b == NULL) goto fails;\n \n \tfor(i=0U; i < maxh; ++i)\n \t{\n\t\tfor(j=0U; j < (maxw & ~(unsigned int)1U); j += 2U)\n \t\t{\n \t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n \t\t\t++y; ++r; ++g; ++b;\n \t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n \t\t\t++y; ++r; ++g; ++b; ++cb; ++cr;\n \t\t}\n\t\tif (j < maxw) {\n \t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n \t\t\t++y; ++r; ++g; ++b; ++cb; ++cr;\n \t\t}\n \t}\n \tfree(img->comps[0].data); img->comps[0].data = d0;\n \tfree(img->comps[1].data); img->comps[1].data = d1;\n \tfree(img->comps[2].data); img->comps[2].data = d2;\n \n#if defined(USE_JPWL) || defined(USE_MJ2)\n\timg->comps[1].w = maxw; img->comps[1].h = maxh;\n\timg->comps[2].w = maxw; img->comps[2].h = maxh;\n#else\n\timg->comps[1].w = (OPJ_UINT32)maxw; img->comps[1].h = (OPJ_UINT32)maxh;\n\timg->comps[2].w = (OPJ_UINT32)maxw; img->comps[2].h = (OPJ_UINT32)maxh;\n#endif\n\timg->comps[1].dx = img->comps[0].dx;\n\timg->comps[2].dx = img->comps[0].dx;\n\timg->comps[1].dy = img->comps[0].dy;\n\timg->comps[2].dy = img->comps[0].dy;\n \treturn;\n \n fails:\n\tif(r) free(r);\n\tif(g) free(g);\n\tif(b) free(b);\n }/* sycc422_to_rgb() */\n", "target": 1, "idx": 182012}
{"func": "R_API RConfigNode* r_config_set(RConfig *cfg, const char *name, const char *value) {\n\tRConfigNode *node = NULL;\n\tchar *ov = NULL;\n\tut64 oi;\n\tif (!cfg || STRNULL (name)) {\n\t\treturn NULL;\n\t}\n\tnode = r_config_node_get (cfg, name);\n\tif (node) {\n\t\tif (node->flags & CN_RO) {\n\t\t\teprintf (\"(error: '%s' config key is read only)\\n\", name);\n\t\t\treturn node;\n\t\t}\n\t\toi = node->i_value;\n\t\tif (node->value) {\n\t\t\tov = strdup (node->value);\n\t\t\tif (!ov) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t} else {\n\t\t\tfree (node->value);\n\t\t\tnode->value = strdup (\"\");\n\t\t}\n\t\tif (node->flags & CN_BOOL) {\n\t\t\tbool b = is_true (value);\n\t\t\tnode->i_value = (ut64) b? 1: 0;\n\t\t\tchar *value = strdup (r_str_bool (b));\n\t\t\tif (value) {\n\t\t\t\tfree (node->value);\n\t\t\t\tnode->value = value;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!value) {\n\t\t\t\tfree (node->value);\n\t\t\t\tnode->value = strdup (\"\");\n\t\t\t\tnode->i_value = 0;\n\t\t\t} else {\n \t\t\t\tif (node->value == value) {\n \t\t\t\t\tgoto beach;\n \t\t\t\t}\n\t\t\t\tfree (node->value);\n \t\t\t\tnode->value = strdup (value);\n \t\t\t\tif (IS_DIGIT (*value)) {\n \t\t\t\t\tif (strchr (value, '/')) {\n \t\t\t\t\t\tnode->i_value = r_num_get (cfg->num, value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnode->i_value = r_num_math (cfg->num, value);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnode->i_value = 0;\n\t\t\t\t}\n\t\t\t\tnode->flags |= CN_INT;\n\t\t\t}\n\t\t}\n\t} else { // Create a new RConfigNode\n\t\toi = UT64_MAX;\n\t\tif (!cfg->lock) {\n\t\t\tnode = r_config_node_new (name, value);\n\t\t\tif (node) {\n\t\t\t\tif (value && is_bool (value)) {\n\t\t\t\t\tnode->flags |= CN_BOOL;\n\t\t\t\t\tnode->i_value = is_true (value)? 1: 0;\n\t\t\t\t}\n\t\t\t\tif (cfg->ht) {\n\t\t\t\t\tht_insert (cfg->ht, node->name, node);\n\t\t\t\t\tr_list_append (cfg->nodes, node);\n\t\t\t\t\tcfg->n_nodes++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\teprintf (\"r_config_set: unable to create a new RConfigNode\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"r_config_set: variable '%s' not found\\n\", name);\n\t\t}\n\t}\n\n\tif (node && node->setter) {\n\t\tint ret = node->setter (cfg->user, node);\n\t\tif (ret == false) {\n\t\t\tif (oi != UT64_MAX) {\n\t\t\t\tnode->i_value = oi;\n\t\t\t}\n\t\t\tfree (node->value);\n\t\t\tnode->value = strdup (ov? ov: \"\");\n\t\t}\n\t}\nbeach:\n\tfree (ov);\n\treturn node;\n}\n", "target": 1, "idx": 181267}
{"func": " static struct page *alloc_huge_page(struct vm_area_struct *vma,\n \t\t\t\t    unsigned long addr, int avoid_reserve)\n {\n \tstruct hstate *h = hstate_vma(vma);\n \tstruct page *page;\n\tstruct address_space *mapping = vma->vm_file->f_mapping;\n\tstruct inode *inode = mapping->host;\n \tlong chg;\n \n \t/*\n\t * Processes that did not create the mapping will have no reserves and\n\t * will not have accounted against quota. Check that the quota can be\n\t * made before satisfying the allocation\n\t * MAP_NORESERVE mappings may also need pages and quota allocated\n\t * if no reserve mapping overlaps.\n \t */\n \tchg = vma_needs_reservation(h, vma, addr);\n \tif (chg < 0)\n \t\treturn ERR_PTR(-VM_FAULT_OOM);\n \tif (chg)\n\t\tif (hugetlb_get_quota(inode->i_mapping, chg))\n \t\t\treturn ERR_PTR(-VM_FAULT_SIGBUS);\n \n \tspin_lock(&hugetlb_lock);\n\tpage = dequeue_huge_page_vma(h, vma, addr, avoid_reserve);\n\tspin_unlock(&hugetlb_lock);\n\n \tif (!page) {\n \t\tpage = alloc_buddy_huge_page(h, NUMA_NO_NODE);\n \t\tif (!page) {\n\t\t\thugetlb_put_quota(inode->i_mapping, chg);\n \t\t\treturn ERR_PTR(-VM_FAULT_SIGBUS);\n \t\t}\n \t}\n \n\tset_page_private(page, (unsigned long) mapping);\n \n \tvma_commit_reservation(h, vma, addr);\n \n\treturn page;\n}\n", "target": 1, "idx": 178780}
{"func": " static inline void VectorClamp3(DDSVector3 *value)\n {\n  value->x = MinF(1.0f,MaxF(0.0f,value->x));\n  value->y = MinF(1.0f,MaxF(0.0f,value->y));\n  value->z = MinF(1.0f,MaxF(0.0f,value->z));\n }\n", "target": 1, "idx": 182079}
{"func": "static int __meminit __add_zone(struct zone *zone, unsigned long phys_start_pfn)\n{\n\tstruct pglist_data *pgdat = zone->zone_pgdat;\n\tint nr_pages = PAGES_PER_SECTION;\n\tint nid = pgdat->node_id;\n\tint zone_type;\n\tunsigned long flags;\n\n\tzone_type = zone - pgdat->node_zones;\n\tif (!zone->wait_table) {\n\t\tint ret;\n\n\t\tret = init_currently_empty_zone(zone, phys_start_pfn,\n\t\t\t\t\t\tnr_pages, MEMMAP_HOTPLUG);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tpgdat_resize_lock(zone->zone_pgdat, &flags);\n\tgrow_zone_span(zone, phys_start_pfn, phys_start_pfn + nr_pages);\n\tgrow_pgdat_span(zone->zone_pgdat, phys_start_pfn,\n\t\t\tphys_start_pfn + nr_pages);\n\tpgdat_resize_unlock(zone->zone_pgdat, &flags);\n\tmemmap_init_zone(nr_pages, nid, zone_type,\n\t\t\t phys_start_pfn, MEMMAP_HOTPLUG);\n\treturn 0;\n}\n", "target": 0, "idx": 18486}
{"func": "SPL_METHOD(RecursiveDirectoryIterator, getChildren)\n{\n\tzval *zpath, *zflags;\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n \tspl_filesystem_object *subdir;\n \tchar slash = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_UNIXPATHS) ? '/' : DEFAULT_SLASH;\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n \tspl_filesystem_object_get_file_name(intern TSRMLS_CC);\n \n \tMAKE_STD_ZVAL(zflags);\n\tMAKE_STD_ZVAL(zpath);\n\tZVAL_LONG(zflags, intern->flags);\n\tZVAL_STRINGL(zpath, intern->file_name, intern->file_name_len, 1);\n\tspl_instantiate_arg_ex2(Z_OBJCE_P(getThis()), &return_value, 0, zpath, zflags TSRMLS_CC);\n\tzval_ptr_dtor(&zpath);\n\tzval_ptr_dtor(&zflags);\n\n\tsubdir = (spl_filesystem_object*)zend_object_store_get_object(return_value TSRMLS_CC);\n\tif (subdir) {\n\t\tif (intern->u.dir.sub_path && intern->u.dir.sub_path[0]) {\n\t\t\tsubdir->u.dir.sub_path_len = spprintf(&subdir->u.dir.sub_path, 0, \"%s%c%s\", intern->u.dir.sub_path, slash, intern->u.dir.entry.d_name);\n\t\t} else {\n\t\t\tsubdir->u.dir.sub_path_len = strlen(intern->u.dir.entry.d_name);\n\t\t\tsubdir->u.dir.sub_path = estrndup(intern->u.dir.entry.d_name, subdir->u.dir.sub_path_len);\n\t\t}\n\t\tsubdir->info_class = intern->info_class;\n\t\tsubdir->file_class = intern->file_class;\n\t\tsubdir->oth = intern->oth;\n\t}\n}\n", "target": 1, "idx": 180217}
{"func": "QQuickWebViewPrivate::~QQuickWebViewPrivate()\n{\n    webPageProxy->close();\n}\n", "target": 0, "idx": 107093}
{"func": "const PPB_NaCl_Private* GetNaclInterface() {\n  pp::Module *module = pp::Module::Get();\n  CHECK(module);\n  return static_cast<const PPB_NaCl_Private*>(\n      module->GetBrowserInterface(PPB_NACL_PRIVATE_INTERFACE));\n}\n", "target": 1, "idx": 184315}
{"func": "void xmlrpc_char_encode(char *outbuffer, const char *s1)\n{\n\tlong unsigned int i;\n\tunsigned char c;\n\tchar buf2[15];\n\tmowgli_string_t *s = mowgli_string_create();\n\t*buf2 = '\\0';\n\t*outbuffer = '\\0';\n\n\tif ((!(s1) || (*(s1) == '\\0')))\n\t{\n\t\treturn;\n\t}\n\n\tfor (i = 0; s1[i] != '\\0'; i++)\n\t{\n\t\tc = s1[i];\n\t\tif (c > 127)\n\t\t{\n\t\t\tsnprintf(buf2, sizeof buf2, \"&#%d;\", c);\n\t\t\ts->append(s, buf2, strlen(buf2));\n\t\t}\n\t\telse if (c == '&')\n\t\t{\n\t\t\ts->append(s, \"&amp;\", 5);\n\t\t}\n\t\telse if (c == '<')\n\t\t{\n\t\t\ts->append(s, \"&lt;\", 4);\n\t\t}\n\t\telse if (c == '>')\n\t\t{\n\t\t\ts->append(s, \"&gt;\", 4);\n\t\t}\n\t\telse if (c == '\"')\n\t\t{\n\t\t\ts->append(s, \"&quot;\", 6);\n\t\t}\n\t\telse\n\t\t{\n \t\t\ts->append_char(s, c);\n \t\t}\n \t}\n \n\tmemcpy(outbuffer, s->str, XMLRPC_BUFSIZE);\n }\n", "target": 1, "idx": 180432}
{"func": "xfs_attr3_leaf_compact(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_attr3_icleaf_hdr *ichdr_dst,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_attr_leafblock *leaf_src;\n\tstruct xfs_attr_leafblock *leaf_dst;\n\tstruct xfs_attr3_icleaf_hdr ichdr_src;\n\tstruct xfs_trans\t*trans = args->trans;\n\tchar\t\t\t*tmpbuffer;\n\n\ttrace_xfs_attr_leaf_compact(args);\n\n\ttmpbuffer = kmem_alloc(args->geo->blksize, KM_SLEEP);\n\tmemcpy(tmpbuffer, bp->b_addr, args->geo->blksize);\n\tmemset(bp->b_addr, 0, args->geo->blksize);\n\tleaf_src = (xfs_attr_leafblock_t *)tmpbuffer;\n\tleaf_dst = bp->b_addr;\n\n\t/*\n\t * Copy the on-disk header back into the destination buffer to ensure\n\t * all the information in the header that is not part of the incore\n\t * header structure is preserved.\n\t */\n\tmemcpy(bp->b_addr, tmpbuffer, xfs_attr3_leaf_hdr_size(leaf_src));\n\n\t/* Initialise the incore headers */\n\tichdr_src = *ichdr_dst;\t/* struct copy */\n\tichdr_dst->firstused = args->geo->blksize;\n\tichdr_dst->usedbytes = 0;\n\tichdr_dst->count = 0;\n\tichdr_dst->holes = 0;\n\tichdr_dst->freemap[0].base = xfs_attr3_leaf_hdr_size(leaf_src);\n\tichdr_dst->freemap[0].size = ichdr_dst->firstused -\n\t\t\t\t\t\tichdr_dst->freemap[0].base;\n\n\t/* write the header back to initialise the underlying buffer */\n\txfs_attr3_leaf_hdr_to_disk(args->geo, leaf_dst, ichdr_dst);\n\n\t/*\n\t * Copy all entry's in the same (sorted) order,\n\t * but allocate name/value pairs packed and in sequence.\n\t */\n\txfs_attr3_leaf_moveents(args, leaf_src, &ichdr_src, 0,\n\t\t\t\tleaf_dst, ichdr_dst, 0, ichdr_src.count);\n\t/*\n\t * this logs the entire buffer, but the caller must write the header\n\t * back to the buffer when it is finished modifying it.\n\t */\n\txfs_trans_log_buf(trans, bp, 0, args->geo->blksize - 1);\n\n\tkmem_free(tmpbuffer);\n}\n", "target": 0, "idx": 79910}
{"func": "lldp_private_8021_print(netdissect_options *ndo,\n                        const u_char *tptr, u_int tlv_len)\n{\n     int subtype, hexdump = FALSE;\n     u_int sublen;\n     u_int tval;\n    uint8_t i;\n \n     if (tlv_len < 4) {\n         return hexdump;\n    }\n    subtype = *(tptr+3);\n\n    ND_PRINT((ndo, \"\\n\\t  %s Subtype (%u)\",\n           tok2str(lldp_8021_subtype_values, \"unknown\", subtype),\n           subtype));\n\n    switch (subtype) {\n    case LLDP_PRIVATE_8021_SUBTYPE_PORT_VLAN_ID:\n        if (tlv_len < 6) {\n            return hexdump;\n        }\n        ND_PRINT((ndo, \"\\n\\t    port vlan id (PVID): %u\",\n               EXTRACT_16BITS(tptr + 4)));\n        break;\n    case LLDP_PRIVATE_8021_SUBTYPE_PROTOCOL_VLAN_ID:\n        if (tlv_len < 7) {\n            return hexdump;\n        }\n        ND_PRINT((ndo, \"\\n\\t    port and protocol vlan id (PPVID): %u, flags [%s] (0x%02x)\",\n               EXTRACT_16BITS(tptr+5),\n\t       bittok2str(lldp_8021_port_protocol_id_values, \"none\", *(tptr+4)),\n\t       *(tptr + 4)));\n        break;\n    case LLDP_PRIVATE_8021_SUBTYPE_VLAN_NAME:\n        if (tlv_len < 6) {\n            return hexdump;\n        }\n        ND_PRINT((ndo, \"\\n\\t    vlan id (VID): %u\", EXTRACT_16BITS(tptr + 4)));\n        if (tlv_len < 7) {\n            return hexdump;\n        }\n        sublen = *(tptr+6);\n        if (tlv_len < 7+sublen) {\n            return hexdump;\n        }\n        ND_PRINT((ndo, \"\\n\\t    vlan name: \"));\n        safeputs(ndo, tptr + 7, sublen);\n        break;\n    case LLDP_PRIVATE_8021_SUBTYPE_PROTOCOL_IDENTITY:\n        if (tlv_len < 5) {\n            return hexdump;\n        }\n        sublen = *(tptr+4);\n        if (tlv_len < 5+sublen) {\n            return hexdump;\n        }\n        ND_PRINT((ndo, \"\\n\\t    protocol identity: \"));\n        safeputs(ndo, tptr + 5, sublen);\n        break;\n    case LLDP_PRIVATE_8021_SUBTYPE_CONGESTION_NOTIFICATION:\n        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_CONGESTION_NOTIFICATION_LENGTH){\n        \treturn hexdump;\n        }\n        tval=*(tptr+4);\n        ND_PRINT((ndo, \"\\n\\t    Pre-Priority CNPV Indicator\"));\n        ND_PRINT((ndo, \"\\n\\t     Priority : 0  1  2  3  4  5  6  7\"));\n        ND_PRINT((ndo, \"\\n\\t     Value    : \"));\n        for(i=0;i<NO_OF_BITS;i++)\n            ND_PRINT((ndo, \"%-2d \", (tval >> i) & 0x01));\n        tval=*(tptr+5);\n        ND_PRINT((ndo, \"\\n\\t    Pre-Priority Ready Indicator\"));\n        ND_PRINT((ndo, \"\\n\\t     Priority : 0  1  2  3  4  5  6  7\"));\n        ND_PRINT((ndo, \"\\n\\t     Value    : \"));\n        for(i=0;i<NO_OF_BITS;i++)\n            ND_PRINT((ndo, \"%-2d \", (tval >> i) & 0x01));\n        break;\n\n    case LLDP_PRIVATE_8021_SUBTYPE_ETS_CONFIGURATION:\n        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_ETS_CONFIGURATION_LENGTH) {\n            return hexdump;\n        }\n        tval=*(tptr+4);\n        ND_PRINT((ndo, \"\\n\\t    Willing:%d, CBS:%d, RES:%d, Max TCs:%d\",\n        \ttval >> 7, (tval >> 6) & 0x02, (tval >> 3) & 0x07, tval & 0x07));\n\n        /*Print Priority Assignment Table*/\n        print_ets_priority_assignment_table(ndo, tptr + 5);\n\n        /*Print TC Bandwidth Table*/\n        print_tc_bandwidth_table(ndo, tptr + 9);\n\n        /* Print TSA Assignment Table */\n        print_tsa_assignment_table(ndo, tptr + 17);\n\n        break;\n\n    case LLDP_PRIVATE_8021_SUBTYPE_ETS_RECOMMENDATION:\n        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_ETS_RECOMMENDATION_LENGTH) {\n        \treturn hexdump;\n        }\n        ND_PRINT((ndo, \"\\n\\t    RES: %d\", *(tptr + 4)));\n        /*Print Priority Assignment Table */\n        print_ets_priority_assignment_table(ndo, tptr + 5);\n        /*Print TC Bandwidth Table */\n        print_tc_bandwidth_table(ndo, tptr + 9);\n        /* Print TSA Assignment Table */\n        print_tsa_assignment_table(ndo, tptr + 17);\n        break;\n\n    case LLDP_PRIVATE_8021_SUBTYPE_PFC_CONFIGURATION:\n        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_PFC_CONFIGURATION_LENGTH) {\n            return hexdump;\n        }\n        tval=*(tptr+4);\n        ND_PRINT((ndo, \"\\n\\t    Willing: %d, MBC: %d, RES: %d, PFC cap:%d \",\n        \ttval >> 7, (tval >> 6) & 0x01, (tval >> 4) & 0x03, (tval & 0x0f)));\n        ND_PRINT((ndo, \"\\n\\t    PFC Enable\"));\n        tval=*(tptr+5);\n        ND_PRINT((ndo, \"\\n\\t     Priority : 0  1  2  3  4  5  6  7\"));\n        ND_PRINT((ndo, \"\\n\\t     Value    : \"));\n        for(i=0;i<NO_OF_BITS;i++)\n            ND_PRINT((ndo, \"%-2d \", (tval >> i) & 0x01));\n        break;\n\n    case LLDP_PRIVATE_8021_SUBTYPE_APPLICATION_PRIORITY:\n        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_APPLICATION_PRIORITY_MIN_LENGTH) {\n            return hexdump;\n        }\n        ND_PRINT((ndo, \"\\n\\t    RES: %d\", *(tptr + 4)));\n        if(tlv_len<=LLDP_PRIVATE_8021_SUBTYPE_APPLICATION_PRIORITY_MIN_LENGTH){\n        \treturn hexdump;\n        }\n        /*  Length of Application Priority Table */\n        sublen=tlv_len-5;\n        if(sublen%3!=0){\n        \treturn hexdump;\n        }\n        i=0;\n         ND_PRINT((ndo, \"\\n\\t    Application Priority Table\"));\n         while(i<sublen) {\n         \ttval=*(tptr+i+5);\n        \tND_PRINT((ndo, \"\\n\\t      Priority: %d, RES: %d, Sel: %d\",\n        \t\t tval >> 5, (tval >> 3) & 0x03, (tval & 0x07)));\n        \tND_PRINT((ndo, \"Protocol ID: %d\", EXTRACT_16BITS(tptr + i + 5)));\n         \ti=i+3;\n         }\n         break;\n    case LLDP_PRIVATE_8021_SUBTYPE_EVB:\n        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_EVB_LENGTH){\n        \treturn hexdump;\n        }\n        ND_PRINT((ndo, \"\\n\\t    EVB Bridge Status\"));\n        tval=*(tptr+4);\n        ND_PRINT((ndo, \"\\n\\t      RES: %d, BGID: %d, RRCAP: %d, RRCTR: %d\",\n        \ttval >> 3, (tval >> 2) & 0x01, (tval >> 1) & 0x01, tval & 0x01));\n        ND_PRINT((ndo, \"\\n\\t    EVB Station Status\"));\n        tval=*(tptr+5);\n        ND_PRINT((ndo, \"\\n\\t      RES: %d, SGID: %d, RRREQ: %d,RRSTAT: %d\",\n        \ttval >> 4, (tval >> 3) & 0x01, (tval >> 2) & 0x01, tval & 0x03));\n        tval=*(tptr+6);\n        ND_PRINT((ndo, \"\\n\\t    R: %d, RTE: %d, \",tval >> 5, tval & 0x1f));\n        tval=*(tptr+7);\n        ND_PRINT((ndo, \"EVB Mode: %s [%d]\",\n        \ttok2str(lldp_evb_mode_values, \"unknown\", tval >> 6), tval >> 6));\n        ND_PRINT((ndo, \"\\n\\t    ROL: %d, RWD: %d, \", (tval >> 5) & 0x01, tval & 0x1f));\n        tval=*(tptr+8);\n        ND_PRINT((ndo, \"RES: %d, ROL: %d, RKA: %d\", tval >> 6, (tval >> 5) & 0x01, tval & 0x1f));\n        break;\n\n    case LLDP_PRIVATE_8021_SUBTYPE_CDCP:\n        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_CDCP_MIN_LENGTH){\n        \treturn hexdump;\n        }\n        tval=*(tptr+4);\n        ND_PRINT((ndo, \"\\n\\t    Role: %d, RES: %d, Scomp: %d \",\n        \ttval >> 7, (tval >> 4) & 0x07, (tval >> 3) & 0x01));\n        ND_PRINT((ndo, \"ChnCap: %d\", EXTRACT_16BITS(tptr + 6) & 0x0fff));\n        sublen=tlv_len-8;\n        if(sublen%3!=0) {\n        \treturn hexdump;\n        }\n        i=0;\n        while(i<sublen) {\n        \ttval=EXTRACT_24BITS(tptr+i+8);\n        \tND_PRINT((ndo, \"\\n\\t    SCID: %d, SVID: %d\",\n        \t\ttval >> 12, tval & 0x000fff));\n        \ti=i+3;\n        }\n        break;\n\n    default:\n        hexdump = TRUE;\n        break;\n    }\n\n    return hexdump;\n}\n", "target": 1, "idx": 181082}
{"func": "IPC::PlatformFileForTransit ProxyChannelDelegate::ShareHandleWithRemote(\n    base::PlatformFile handle,\n    const IPC::SyncChannel& channel,\n    bool should_close_source) {\n  return content::BrokerGetFileHandleForProcess(handle, channel.peer_pid(),\n                                                should_close_source);\n}\n", "target": 1, "idx": 184312}
{"func": " image_transform_png_set_expand_16_add(image_transform *this,\n    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)\n {\n    UNUSED(colour_type)\n \n this->next = *that;\n *that = this;\n\n /* expand_16 does something unless the bit depth is already 16. */\n return bit_depth < 16;\n}\n", "target": 1, "idx": 187648}
{"func": "void WebGL2RenderingContextBase::texImage3D(\n    GLenum target,\n    GLint level,\n    GLint internalformat,\n    GLsizei width,\n    GLsizei height,\n    GLsizei depth,\n    GLint border,\n    GLenum format,\n    GLenum type,\n    MaybeShared<DOMArrayBufferView> pixels,\n    GLuint src_offset) {\n  if (isContextLost())\n    return;\n  if (bound_pixel_unpack_buffer_) {\n    SynthesizeGLError(GL_INVALID_OPERATION, \"texImage3D\",\n                       \"a buffer is bound to PIXEL_UNPACK_BUFFER\");\n     return;\n   }\n   TexImageHelperDOMArrayBufferView(\n       kTexImage3D, target, level, internalformat, width, height, depth, border,\n       format, type, 0, 0, 0, pixels.View(), kNullNotReachable, src_offset);\n}\n", "target": 1, "idx": 186653}
{"func": "static void ipgre_tap_setup(struct net_device *dev)\n{\n\n\tether_setup(dev);\n\n\tdev->netdev_ops\t\t= &ipgre_tap_netdev_ops;\n\tdev->destructor \t= ipgre_dev_free;\n\n\tdev->iflink\t\t= 0;\n\tdev->features\t\t|= NETIF_F_NETNS_LOCAL;\n}\n", "target": 0, "idx": 35326}
{"func": "_ksba_name_new_from_der (ksba_name_t *r_name,\n                         const unsigned char *image, size_t imagelen)\n{\n  gpg_error_t err;\n  ksba_name_t name;\n  struct tag_info ti;\n  const unsigned char *der;\n  size_t derlen;\n  int n;\n  char *p;\n\n  if (!r_name || !image)\n    return gpg_error (GPG_ERR_INV_VALUE);\n \n   *r_name = NULL;\n \n  /* count and check for encoding errors - we won;t do this again\n      during the second pass */\n   der = image;\n   derlen = imagelen;\n  n = 0;\n  while (derlen)\n    {\n      err = _ksba_ber_parse_tl (&der, &derlen, &ti);\n      if (err)\n        return err;\n      if (ti.class != CLASS_CONTEXT)\n        return gpg_error (GPG_ERR_INV_CERT_OBJ); /* we expected a tag */\n      if (ti.ndef)\n        return gpg_error (GPG_ERR_NOT_DER_ENCODED);\n      if (derlen < ti.length)\n        return gpg_error (GPG_ERR_BAD_BER);\n      switch (ti.tag)\n        {\n        case 1: /* rfc822Name - this is an imlicit IA5_STRING */\n        case 4: /* Name */\n        case 6: /* URI */\n          n++;\n          break;\n        default:\n          break;\n        }\n\n      /* advance pointer */\n      der += ti.length;\n      derlen -= ti.length;\n    }\n\n  /* allocate array and set all slots to NULL for easier error recovery */\n  err = ksba_name_new (&name);\n  if (err)\n    return err;\n  if (!n)\n    return 0; /* empty GeneralNames */\n  name->names = xtrycalloc (n, sizeof *name->names);\n  if (!name->names)\n    {\n      ksba_name_release (name);\n      return gpg_error (GPG_ERR_ENOMEM);\n    }\n  name->n_names = n;\n\n  /* start the second pass */\n  der = image;\n  derlen = imagelen;\n  n = 0;\n  while (derlen)\n    {\n      char numbuf[21];\n\n      err = _ksba_ber_parse_tl (&der, &derlen, &ti);\n      assert (!err);\n      switch (ti.tag)\n        {\n        case 1: /* rfc822Name - this is an imlicit IA5_STRING */\n          p = name->names[n] = xtrymalloc (ti.length+3);\n          if (!p)\n            {\n              ksba_name_release (name);\n              return gpg_error (GPG_ERR_ENOMEM);\n            }\n          *p++ = '<';\n          memcpy (p, der, ti.length);\n          p += ti.length;\n          *p++ = '>';\n          *p = 0;\n          n++;\n          break;\n        case 4: /* Name */\n          err = _ksba_derdn_to_str (der, ti.length, &p);\n          if (err)\n            return err; /* FIXME: we need to release some of the memory */\n          name->names[n++] = p;\n          break;\n        case 6: /* URI */\n          sprintf (numbuf, \"%u:\", (unsigned int)ti.length);\n          p = name->names[n] = xtrymalloc (1+5+strlen (numbuf)\n                                           + ti.length +1+1);\n          if (!p)\n            {\n              ksba_name_release (name);\n              return gpg_error (GPG_ERR_ENOMEM);\n            }\n          p = stpcpy (p, \"(3:uri\");\n          p = stpcpy (p, numbuf);\n          memcpy (p, der, ti.length);\n          p += ti.length;\n          *p++ = ')';\n          *p = 0; /* extra safeguard null */\n          n++;\n          break;\n        default:\n          break;\n        }\n\n      /* advance pointer */\n      der += ti.length;\n      derlen -= ti.length;\n    }\n  *r_name = name;\n  return 0;\n}\n", "target": 1, "idx": 178201}
{"func": "struct in6_addr *ndp_msg_opt_route_prefix(struct ndp_msg *msg, int offset)\n{\n\tstatic struct in6_addr prefix;\n\tstruct __nd_opt_route_info *ri =\n\t\t\tndp_msg_payload_opts_offset(msg, offset);\n\n\tmemset(&prefix, 0, sizeof(prefix));\n\tmemcpy(&prefix, &ri->nd_opt_ri_prefix, (ri->nd_opt_ri_len - 1) << 3);\n\treturn &prefix;\n}\n", "target": 0, "idx": 53937}
{"func": "vmnc_handle_wmvi_rectangle (GstVMncDec * dec, struct RfbRectangle *rect,\n    const guint8 * data, int len, gboolean decode)\n{\n  GstVideoFormat format;\n  gint bpp, tc;\n  guint32 redmask, greenmask, bluemask;\n  guint32 endianness, dataendianness;\n  GstVideoCodecState *state;\n\n  /* A WMVi rectangle has a 16byte payload */\n  if (len < 16) {\n    GST_DEBUG_OBJECT (dec, \"Bad WMVi rect: too short\");\n    return ERROR_INSUFFICIENT_DATA;\n  }\n\n  /* We only compare 13 bytes; ignoring the 3 padding bytes at the end */\n  if (dec->have_format && memcmp (data, dec->format.descriptor, 13) == 0) {\n    /* Nothing changed, so just exit */\n    return 16;\n  }\n\n  /* Store the whole block for simple comparison later */\n  memcpy (dec->format.descriptor, data, 16);\n\n  if (rect->x != 0 || rect->y != 0) {\n    GST_WARNING_OBJECT (dec, \"Bad WMVi rect: wrong coordinates\");\n    return ERROR_INVALID;\n  }\n\n  bpp = data[0];\n  dec->format.depth = data[1];\n  dec->format.big_endian = data[2];\n  dataendianness = data[2] ? G_BIG_ENDIAN : G_LITTLE_ENDIAN;\n  tc = data[3];\n\n  if (bpp != 8 && bpp != 16 && bpp != 32) {\n    GST_WARNING_OBJECT (dec, \"Bad bpp value: %d\", bpp);\n    return ERROR_INVALID;\n  }\n\n  if (!tc) {\n    GST_WARNING_OBJECT (dec, \"Paletted video not supported\");\n    return ERROR_INVALID;\n  }\n\n  dec->format.bytes_per_pixel = bpp / 8;\n  dec->format.width = rect->width;\n  dec->format.height = rect->height;\n\n  redmask = (guint32) (RFB_GET_UINT16 (data + 4)) << data[10];\n  greenmask = (guint32) (RFB_GET_UINT16 (data + 6)) << data[11];\n  bluemask = (guint32) (RFB_GET_UINT16 (data + 8)) << data[12];\n\n  GST_DEBUG_OBJECT (dec, \"Red: mask %d, shift %d\",\n      RFB_GET_UINT16 (data + 4), data[10]);\n  GST_DEBUG_OBJECT (dec, \"Green: mask %d, shift %d\",\n      RFB_GET_UINT16 (data + 6), data[11]);\n  GST_DEBUG_OBJECT (dec, \"Blue: mask %d, shift %d\",\n      RFB_GET_UINT16 (data + 8), data[12]);\n  GST_DEBUG_OBJECT (dec, \"BPP: %d. endianness: %s\", bpp,\n      data[2] ? \"big\" : \"little\");\n\n  /* GStreamer's RGB caps are a bit weird. */\n  if (bpp == 8) {\n    endianness = G_BYTE_ORDER;  /* Doesn't matter */\n  } else if (bpp == 16) {\n    /* We require host-endian. */\n    endianness = G_BYTE_ORDER;\n  } else {                      /* bpp == 32 */\n    /* We require big endian */\n    endianness = G_BIG_ENDIAN;\n    if (endianness != dataendianness) {\n      redmask = GUINT32_SWAP_LE_BE (redmask);\n      greenmask = GUINT32_SWAP_LE_BE (greenmask);\n      bluemask = GUINT32_SWAP_LE_BE (bluemask);\n    }\n  }\n\n  format = gst_video_format_from_masks (dec->format.depth, bpp, endianness,\n      redmask, greenmask, bluemask, 0);\n\n  GST_DEBUG_OBJECT (dec, \"From depth: %d bpp: %u endianess: %s redmask: %X \"\n      \"greenmask: %X bluemask: %X got format %s\",\n      dec->format.depth, bpp, endianness == G_BIG_ENDIAN ? \"BE\" : \"LE\",\n      GUINT32_FROM_BE (redmask), GUINT32_FROM_BE (greenmask),\n      GUINT32_FROM_BE (bluemask),\n      format == GST_VIDEO_FORMAT_UNKNOWN ? \"UNKOWN\" :\n      gst_video_format_to_string (format));\n\n  if (format == GST_VIDEO_FORMAT_UNKNOWN) {\n    GST_WARNING_OBJECT (dec, \"Video format unknown to GStreamer\");\n    return ERROR_INVALID;\n  }\n\n  dec->have_format = TRUE;\n  if (!decode) {\n    GST_LOG_OBJECT (dec, \"Parsing, not setting caps\");\n    return 16;\n  }\n\n\n  state = gst_video_decoder_set_output_state (GST_VIDEO_DECODER (dec), format,\n      rect->width, rect->height, dec->input_state);\n   gst_video_codec_state_unref (state);\n \n   g_free (dec->imagedata);\n  dec->imagedata = g_malloc (dec->format.width * dec->format.height *\n       dec->format.bytes_per_pixel);\n   GST_DEBUG_OBJECT (dec, \"Allocated image data at %p\", dec->imagedata);\n \n  dec->format.stride = dec->format.width * dec->format.bytes_per_pixel;\n\n  return 16;\n}\n", "target": 1, "idx": 178424}
{"func": "static int complete_emulated_mmio(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *run = vcpu->run;\n\tstruct kvm_mmio_fragment *frag;\n\tunsigned len;\n\n\tBUG_ON(!vcpu->mmio_needed);\n\n\t/* Complete previous fragment */\n\tfrag = &vcpu->mmio_fragments[vcpu->mmio_cur_fragment];\n\tlen = min(8u, frag->len);\n\tif (!vcpu->mmio_is_write)\n\t\tmemcpy(frag->data, run->mmio.data, len);\n\n\tif (frag->len <= 8) {\n\t\t/* Switch to the next fragment. */\n\t\tfrag++;\n\t\tvcpu->mmio_cur_fragment++;\n\t} else {\n\t\t/* Go forward to the next mmio piece. */\n\t\tfrag->data += len;\n\t\tfrag->gpa += len;\n \t\tfrag->len -= len;\n \t}\n \n\tif (vcpu->mmio_cur_fragment == vcpu->mmio_nr_fragments) {\n \t\tvcpu->mmio_needed = 0;\n \n \t\t/* FIXME: return into emulator if single-stepping.  */\n\t\tif (vcpu->mmio_is_write)\n\t\t\treturn 1;\n\t\tvcpu->mmio_read_completed = 1;\n\t\treturn complete_emulated_io(vcpu);\n\t}\n\n\trun->exit_reason = KVM_EXIT_MMIO;\n\trun->mmio.phys_addr = frag->gpa;\n\tif (vcpu->mmio_is_write)\n\t\tmemcpy(run->mmio.data, frag->data, min(8u, frag->len));\n\trun->mmio.len = min(8u, frag->len);\n\trun->mmio.is_write = vcpu->mmio_is_write;\n\tvcpu->arch.complete_userspace_io = complete_emulated_mmio;\n\treturn 0;\n}\n", "target": 1, "idx": 179638}
{"func": "static int crypto_report_cipher(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_cipher rcipher;\n \n\tsnprintf(rcipher.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"cipher\");\n \n \trcipher.blocksize = alg->cra_blocksize;\n \trcipher.min_keysize = alg->cra_cipher.cia_min_keysize;\n\trcipher.max_keysize = alg->cra_cipher.cia_max_keysize;\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_CIPHER,\n\t\t    sizeof(struct crypto_report_cipher), &rcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n", "target": 1, "idx": 179239}
{"func": "void TypingCommand::forwardDeleteKeyPressed(TextGranularity granularity,\n                                            bool killRing,\n                                            EditingState* editingState) {\n  LocalFrame* frame = document().frame();\n  if (!frame)\n    return;\n\n  frame->spellChecker().updateMarkersForWordsAffectedByEditing(false);\n\n  VisibleSelection selectionToDelete;\n  VisibleSelection selectionAfterUndo;\n\n  switch (endingSelection().getSelectionType()) {\n    case RangeSelection:\n      selectionToDelete = endingSelection();\n      selectionAfterUndo = selectionToDelete;\n      break;\n    case CaretSelection: {\n      m_smartDelete = false;\n      document().updateStyleAndLayoutIgnorePendingStylesheets();\n\n      SelectionModifier selectionModifier(*frame, endingSelection());\n      selectionModifier.modify(FrameSelection::AlterationExtend,\n                               DirectionForward, granularity);\n      if (killRing && selectionModifier.selection().isCaret() &&\n          granularity != CharacterGranularity)\n        selectionModifier.modify(FrameSelection::AlterationExtend,\n                                 DirectionForward, CharacterGranularity);\n\n      Position downstreamEnd =\n          mostForwardCaretPosition(endingSelection().end());\n      VisiblePosition visibleEnd = endingSelection().visibleEnd();\n      Node* enclosingTableCell =\n          enclosingNodeOfType(visibleEnd.deepEquivalent(), &isTableCell);\n      if (enclosingTableCell &&\n          visibleEnd.deepEquivalent() ==\n              VisiblePosition::lastPositionInNode(enclosingTableCell)\n                  .deepEquivalent())\n        return;\n      if (visibleEnd.deepEquivalent() ==\n          endOfParagraph(visibleEnd).deepEquivalent())\n        downstreamEnd = mostForwardCaretPosition(\n            nextPositionOf(visibleEnd, CannotCrossEditingBoundary)\n                .deepEquivalent());\n      if (isDisplayInsideTable(downstreamEnd.computeContainerNode()) &&\n          downstreamEnd.computeOffsetInContainerNode() <=\n              caretMinOffset(downstreamEnd.computeContainerNode())) {\n        setEndingSelection(\n            SelectionInDOMTree::Builder()\n                .setBaseAndExtentDeprecated(\n                    endingSelection().end(),\n                    Position::afterNode(downstreamEnd.computeContainerNode()))\n                .setIsDirectional(endingSelection().isDirectional())\n                .build());\n        typingAddedToOpenCommand(ForwardDeleteKey);\n        return;\n      }\n\n      if (granularity == ParagraphBoundary &&\n          selectionModifier.selection().isCaret() &&\n          isEndOfParagraph(selectionModifier.selection().visibleEnd()))\n        selectionModifier.modify(FrameSelection::AlterationExtend,\n                                 DirectionForward, CharacterGranularity);\n\n      selectionToDelete = selectionModifier.selection();\n      if (!startingSelection().isRange() ||\n          selectionToDelete.base() != startingSelection().start()) {\n        selectionAfterUndo = selectionToDelete;\n      } else {\n        Position extent = startingSelection().end();\n        if (extent.computeContainerNode() !=\n            selectionToDelete.end().computeContainerNode()) {\n          extent = selectionToDelete.extent();\n        } else {\n          int extraCharacters;\n          if (selectionToDelete.start().computeContainerNode() ==\n              selectionToDelete.end().computeContainerNode())\n            extraCharacters =\n                selectionToDelete.end().computeOffsetInContainerNode() -\n                selectionToDelete.start().computeOffsetInContainerNode();\n          else\n            extraCharacters =\n                selectionToDelete.end().computeOffsetInContainerNode();\n          extent =\n              Position(extent.computeContainerNode(),\n                       extent.computeOffsetInContainerNode() + extraCharacters);\n        }\n        selectionAfterUndo.setWithoutValidation(startingSelection().start(),\n                                                extent);\n      }\n      break;\n    }\n    case NoSelection:\n      NOTREACHED();\n      break;\n  }\n\n  DCHECK(!selectionToDelete.isNone());\n  if (selectionToDelete.isNone())\n    return;\n\n  if (selectionToDelete.isCaret())\n    return;\n\n  if (killRing)\n    frame->editor().addToKillRing(\n        selectionToDelete.toNormalizedEphemeralRange());\n  if (frame->editor().behavior().shouldUndoOfDeleteSelectText())\n    setStartingSelection(selectionAfterUndo);\n  deleteSelectionIfRange(selectionToDelete, editingState, m_smartDelete);\n  if (editingState->isAborted())\n    return;\n  setSmartDelete(false);\n  typingAddedToOpenCommand(ForwardDeleteKey);\n}\n", "target": 0, "idx": 140396}
{"func": "static void calcstepsizes(uint_fast16_t refstepsize, int numrlvls,\n  uint_fast16_t *stepsizes)\n{\n\tint bandno;\n\tint numbands;\n\tuint_fast16_t expn;\n\tuint_fast16_t mant;\n\texpn = JPC_QCX_GETEXPN(refstepsize);\n \tmant = JPC_QCX_GETMANT(refstepsize);\n \tnumbands = 3 * numrlvls - 2;\n \tfor (bandno = 0; bandno < numbands; ++bandno) {\n////jas_eprintf(\"DEBUG %d %d %d %d %d\\n\", bandno, expn, numrlvls, bandno, ((numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0)))));\n \t\tstepsizes[bandno] = JPC_QCX_MANT(mant) | JPC_QCX_EXPN(expn +\n \t\t  (numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0))));\n \t}\n}\n", "target": 1, "idx": 181907}
{"func": "void WebGraphicsContext3DCommandBufferImpl::OnMemoryAllocationChanged(\n    const GpuMemoryAllocation& allocation) {\n  if (memory_allocation_changed_callback_)\n    memory_allocation_changed_callback_->onMemoryAllocationChanged(\n        allocation.gpu_resource_size_in_bytes);\n}\n", "target": 0, "idx": 117440}
{"func": "int ff_mms_asf_header_parser(MMSContext *mms)\n{\n    uint8_t *p = mms->asf_header;\n    uint8_t *end;\n    int flags, stream_id;\n    mms->stream_num = 0;\n\n    if (mms->asf_header_size < sizeof(ff_asf_guid) * 2 + 22 ||\n        memcmp(p, ff_asf_header, sizeof(ff_asf_guid))) {\n        av_log(NULL, AV_LOG_ERROR,\n               \"Corrupt stream (invalid ASF header, size=%d)\\n\",\n               mms->asf_header_size);\n        return AVERROR_INVALIDDATA;\n    }\n\n    end = mms->asf_header + mms->asf_header_size;\n\n    p += sizeof(ff_asf_guid) + 14;\n    while(end - p >= sizeof(ff_asf_guid) + 8) {\n        uint64_t chunksize;\n        if (!memcmp(p, ff_asf_data_header, sizeof(ff_asf_guid))) {\n            chunksize = 50; // see Reference [2] section 5.1\n        } else {\n            chunksize = AV_RL64(p + sizeof(ff_asf_guid));\n        }\n        if (!chunksize || chunksize > end - p) {\n            av_log(NULL, AV_LOG_ERROR,\n                   \"Corrupt stream (header chunksize %\"PRId64\" is invalid)\\n\",\n                   chunksize);\n            return AVERROR_INVALIDDATA;\n        }\n        if (!memcmp(p, ff_asf_file_header, sizeof(ff_asf_guid))) {\n            /* read packet size */\n            if (end - p > sizeof(ff_asf_guid) * 2 + 68) {\n                mms->asf_packet_len = AV_RL32(p + sizeof(ff_asf_guid) * 2 + 64);\n                if (mms->asf_packet_len <= 0 || mms->asf_packet_len > sizeof(mms->in_buffer)) {\n                    av_log(NULL, AV_LOG_ERROR,\n                           \"Corrupt stream (too large pkt_len %d)\\n\",\n                           mms->asf_packet_len);\n                    return AVERROR_INVALIDDATA;\n                 }\n             }\n         } else if (!memcmp(p, ff_asf_stream_header, sizeof(ff_asf_guid))) {\n            flags     = AV_RL16(p + sizeof(ff_asf_guid)*3 + 24);\n            stream_id = flags & 0x7F;\n            if (mms->stream_num < MMS_MAX_STREAMS &&\n                    46 + mms->stream_num * 6 < sizeof(mms->out_buffer)) {\n                mms->streams = av_fast_realloc(mms->streams,\n                                   &mms->nb_streams_allocated,\n                                   (mms->stream_num + 1) * sizeof(MMSStream));\n                if (!mms->streams)\n                    return AVERROR(ENOMEM);\n                mms->streams[mms->stream_num].id = stream_id;\n                mms->stream_num++;\n            } else {\n                av_log(NULL, AV_LOG_ERROR,\n                       \"Corrupt stream (too many A/V streams)\\n\");\n                return AVERROR_INVALIDDATA;\n             }\n         } else if (!memcmp(p, ff_asf_ext_stream_header, sizeof(ff_asf_guid))) {\n             if (end - p >= 88) {\n                int stream_count = AV_RL16(p + 84), ext_len_count = AV_RL16(p + 86);\n                uint64_t skip_bytes = 88;\n                while (stream_count--) {\n                    if (end - p < skip_bytes + 4) {\n                        av_log(NULL, AV_LOG_ERROR,\n                               \"Corrupt stream (next stream name length is not in the buffer)\\n\");\n                        return AVERROR_INVALIDDATA;\n                    }\n                    skip_bytes += 4 + AV_RL16(p + skip_bytes + 2);\n                }\n                while (ext_len_count--) {\n                    if (end - p < skip_bytes + 22) {\n                        av_log(NULL, AV_LOG_ERROR,\n                               \"Corrupt stream (next extension system info length is not in the buffer)\\n\");\n                        return AVERROR_INVALIDDATA;\n                    }\n                    skip_bytes += 22 + AV_RL32(p + skip_bytes + 18);\n                }\n                if (end - p < skip_bytes) {\n                    av_log(NULL, AV_LOG_ERROR,\n                           \"Corrupt stream (the last extension system info length is invalid)\\n\");\n                    return AVERROR_INVALIDDATA;\n                }\n                if (chunksize - skip_bytes > 24)\n                    chunksize = skip_bytes;\n             }\n         } else if (!memcmp(p, ff_asf_head1_guid, sizeof(ff_asf_guid))) {\n             chunksize = 46; // see references [2] section 3.4. This should be set 46.\n         }\n         p += chunksize;\n     }\n\n    return 0;\n}\n", "target": 1, "idx": 182099}
{"func": "void GLES2DecoderImpl::DoBindTexture(GLenum target, GLuint client_id) {\n  TextureRef* texture_ref = nullptr;\n  GLuint service_id = 0;\n  if (client_id != 0) {\n    texture_ref = GetTexture(client_id);\n    if (!texture_ref) {\n      if (!group_->bind_generates_resource()) {\n        LOCAL_SET_GL_ERROR(GL_INVALID_OPERATION,\n                           \"glBindTexture\",\n                           \"id not generated by glGenTextures\");\n        return;\n      }\n\n      api()->glGenTexturesFn(1, &service_id);\n      DCHECK_NE(0u, service_id);\n      CreateTexture(client_id, service_id);\n      texture_ref = GetTexture(client_id);\n    }\n  } else {\n    texture_ref = texture_manager()->GetDefaultTextureInfo(target);\n  }\n\n  if (texture_ref) {\n    Texture* texture = texture_ref->texture();\n    if (texture->target() != 0 && texture->target() != target) {\n      LOCAL_SET_GL_ERROR(GL_INVALID_OPERATION,\n                         \"glBindTexture\",\n                         \"texture bound to more than 1 target.\");\n      return;\n    }\n    LogClientServiceForInfo(texture, client_id, \"glBindTexture\");\n    api()->glBindTextureFn(target, texture->service_id());\n    if (texture->target() == 0) {\n      texture_manager()->SetTarget(texture_ref, target);\n      if (!gl_version_info().BehavesLikeGLES() &&\n          gl_version_info().IsAtLeastGL(3, 2)) {\n        api()->glTexParameteriFn(target, GL_DEPTH_TEXTURE_MODE, GL_RED);\n      }\n    }\n  } else {\n    api()->glBindTextureFn(target, 0);\n  }\n\n  TextureUnit& unit = state_.texture_units[state_.active_texture_unit];\n  unit.bind_target = target;\n  unit.SetInfoForTarget(target, texture_ref);\n}\n", "target": 0, "idx": 153959}
{"func": "void TEMPLATE(process_block_dec)(decoder_info_t *decoder_info,int size,int yposY,int xposY,int sub)\n{\n  int width = decoder_info->width;\n  int height = decoder_info->height;\n  stream_t *stream = decoder_info->stream;\n  frame_type_t frame_type = decoder_info->frame_info.frame_type;\n  int split_flag = 0;\n\n  if (yposY >= height || xposY >= width)\n    return;\n\n  int decode_this_size = (yposY + size <= height) && (xposY + size <= width);\n  int decode_rectangular_size = !decode_this_size && frame_type != I_FRAME;\n\n  int bit_start = stream->bitcnt;\n\n  int mode = MODE_SKIP;\n \n  block_context_t block_context;\n  TEMPLATE(find_block_contexts)(yposY, xposY, height, width, size, decoder_info->deblock_data, &block_context, decoder_info->use_block_contexts);\n  decoder_info->block_context = &block_context;\n\n  split_flag = decode_super_mode(decoder_info,size,decode_this_size);\n  mode = decoder_info->mode;\n  \n  /* Read delta_qp and set block-level qp */\n  if (size == (1<<decoder_info->log2_sb_size) && (split_flag || mode != MODE_SKIP) && decoder_info->max_delta_qp > 0) {\n    /* Read delta_qp */\n    int delta_qp = read_delta_qp(stream);\n    int prev_qp;\n    if (yposY == 0 && xposY == 0)\n      prev_qp = decoder_info->frame_info.qp;\n    else\n      prev_qp = decoder_info->frame_info.qpb;\n    decoder_info->frame_info.qpb = prev_qp + delta_qp;\n  }\n \n   decoder_info->bit_count.super_mode[decoder_info->bit_count.stat_frame_type] += (stream->bitcnt - bit_start);\n \n  if (split_flag){\n     int new_size = size/2;\n     TEMPLATE(process_block_dec)(decoder_info,new_size,yposY+0*new_size,xposY+0*new_size,sub);\n     TEMPLATE(process_block_dec)(decoder_info,new_size,yposY+1*new_size,xposY+0*new_size,sub);\n    TEMPLATE(process_block_dec)(decoder_info,new_size,yposY+0*new_size,xposY+1*new_size,sub);\n    TEMPLATE(process_block_dec)(decoder_info,new_size,yposY+1*new_size,xposY+1*new_size,sub);\n  }\n  else if (decode_this_size || decode_rectangular_size){\n    decode_block(decoder_info,size,yposY,xposY,sub);\n  }\n}\n", "target": 1, "idx": 182538}
{"func": "static int tg3_set_pauseparam(struct net_device *dev, struct ethtool_pauseparam *epause)\n{\n\tstruct tg3 *tp = netdev_priv(dev);\n\tint err = 0;\n\n\tif (tg3_flag(tp, USE_PHYLIB)) {\n\t\tu32 newadv;\n\t\tstruct phy_device *phydev;\n\n\t\tphydev = tp->mdio_bus->phy_map[TG3_PHY_MII_ADDR];\n\n\t\tif (!(phydev->supported & SUPPORTED_Pause) ||\n\t\t    (!(phydev->supported & SUPPORTED_Asym_Pause) &&\n\t\t     (epause->rx_pause != epause->tx_pause)))\n\t\t\treturn -EINVAL;\n\n\t\ttp->link_config.flowctrl = 0;\n\t\tif (epause->rx_pause) {\n\t\t\ttp->link_config.flowctrl |= FLOW_CTRL_RX;\n\n\t\t\tif (epause->tx_pause) {\n\t\t\t\ttp->link_config.flowctrl |= FLOW_CTRL_TX;\n\t\t\t\tnewadv = ADVERTISED_Pause;\n\t\t\t} else\n\t\t\t\tnewadv = ADVERTISED_Pause |\n\t\t\t\t\t ADVERTISED_Asym_Pause;\n\t\t} else if (epause->tx_pause) {\n\t\t\ttp->link_config.flowctrl |= FLOW_CTRL_TX;\n\t\t\tnewadv = ADVERTISED_Asym_Pause;\n\t\t} else\n\t\t\tnewadv = 0;\n\n\t\tif (epause->autoneg)\n\t\t\ttg3_flag_set(tp, PAUSE_AUTONEG);\n\t\telse\n\t\t\ttg3_flag_clear(tp, PAUSE_AUTONEG);\n\n\t\tif (tp->phy_flags & TG3_PHYFLG_IS_CONNECTED) {\n\t\t\tu32 oldadv = phydev->advertising &\n\t\t\t\t     (ADVERTISED_Pause | ADVERTISED_Asym_Pause);\n\t\t\tif (oldadv != newadv) {\n\t\t\t\tphydev->advertising &=\n\t\t\t\t\t~(ADVERTISED_Pause |\n\t\t\t\t\t  ADVERTISED_Asym_Pause);\n\t\t\t\tphydev->advertising |= newadv;\n\t\t\t\tif (phydev->autoneg) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Always renegotiate the link to\n\t\t\t\t\t * inform our link partner of our\n\t\t\t\t\t * flow control settings, even if the\n\t\t\t\t\t * flow control is forced.  Let\n\t\t\t\t\t * tg3_adjust_link() do the final\n\t\t\t\t\t * flow control setup.\n\t\t\t\t\t */\n\t\t\t\t\treturn phy_start_aneg(phydev);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!epause->autoneg)\n\t\t\t\ttg3_setup_flow_control(tp, 0, 0);\n\t\t} else {\n\t\t\ttp->link_config.advertising &=\n\t\t\t\t\t~(ADVERTISED_Pause |\n\t\t\t\t\t  ADVERTISED_Asym_Pause);\n\t\t\ttp->link_config.advertising |= newadv;\n\t\t}\n\t} else {\n\t\tint irq_sync = 0;\n\n\t\tif (netif_running(dev)) {\n\t\t\ttg3_netif_stop(tp);\n\t\t\tirq_sync = 1;\n\t\t}\n\n\t\ttg3_full_lock(tp, irq_sync);\n\n\t\tif (epause->autoneg)\n\t\t\ttg3_flag_set(tp, PAUSE_AUTONEG);\n\t\telse\n\t\t\ttg3_flag_clear(tp, PAUSE_AUTONEG);\n\t\tif (epause->rx_pause)\n\t\t\ttp->link_config.flowctrl |= FLOW_CTRL_RX;\n\t\telse\n\t\t\ttp->link_config.flowctrl &= ~FLOW_CTRL_RX;\n\t\tif (epause->tx_pause)\n\t\t\ttp->link_config.flowctrl |= FLOW_CTRL_TX;\n\t\telse\n\t\t\ttp->link_config.flowctrl &= ~FLOW_CTRL_TX;\n\n\t\tif (netif_running(dev)) {\n\t\t\ttg3_halt(tp, RESET_KIND_SHUTDOWN, 1);\n\t\t\terr = tg3_restart_hw(tp, 1);\n\t\t\tif (!err)\n\t\t\t\ttg3_netif_start(tp);\n\t\t}\n\n\t\ttg3_full_unlock(tp);\n\t}\n\n\treturn err;\n}\n", "target": 0, "idx": 32752}
{"func": "void WebContentsImpl::CreateNewWidget(int32_t render_process_id,\n                                      int32_t route_id,\n                                      bool is_fullscreen,\n                                      mojom::WidgetPtr widget,\n                                      blink::WebPopupType popup_type) {\n  RenderProcessHost* process = RenderProcessHost::FromID(render_process_id);\n  if (!HasMatchingProcess(&frame_tree_, render_process_id)) {\n    ReceivedBadMessage(process, bad_message::WCI_NEW_WIDGET_PROCESS_MISMATCH);\n    return;\n  }\n\n  RenderWidgetHostImpl* widget_host = new RenderWidgetHostImpl(\n      this, process, route_id, std::move(widget), IsHidden());\n\n  RenderWidgetHostViewBase* widget_view =\n      static_cast<RenderWidgetHostViewBase*>(\n          view_->CreateViewForPopupWidget(widget_host));\n  if (!widget_view)\n    return;\n  if (!is_fullscreen) {\n    widget_view->SetPopupType(popup_type);\n  }\n  pending_widget_views_[GlobalRoutingID(render_process_id, route_id)] =\n      widget_view;\n}\n", "target": 0, "idx": 158893}
{"func": "bool BaseAudioContext::WouldTaintOrigin(const KURL& url) const {\n  if (url.ProtocolIsData()) {\n    return false;\n  }\n  Document* document = GetDocument();\n  if (document && document->GetSecurityOrigin()) {\n    return !document->GetSecurityOrigin()->CanRequest(url);\n  }\n  return true;\n}\n", "target": 1, "idx": 186610}
{"func": "vrrp_state_handler(vector_t *strvec)\n{\n\tchar *str = strvec_slot(strvec, 1);\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\n\tif (!strcmp(str, \"MASTER\"))\n\t\tvrrp->wantstate = VRRP_STATE_MAST;\n\telse if (!strcmp(str, \"BACKUP\"))\n\t{\n\t\tif (vrrp->wantstate == VRRP_STATE_MAST)\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s) state previously set as MASTER - ignoring BACKUP\", vrrp->iname);\n\t\telse\n\t\t\tvrrp->wantstate = VRRP_STATE_BACK;\n\t}\n\telse {\n\t\treport_config_error(CONFIG_GENERAL_ERROR,\"(%s) unknown state '%s', defaulting to BACKUP\", vrrp->iname, str);\n\t\tvrrp->wantstate = VRRP_STATE_BACK;\n\t}\n}\n", "target": 0, "idx": 76035}
{"func": "ChromeContentBrowserClient::CreateThrottlesForNavigation(\n    content::NavigationHandle* handle) {\n  std::vector<std::unique_ptr<content::NavigationThrottle>> throttles;\n\n  if (handle->IsInMainFrame()) {\n    throttles.push_back(\n        page_load_metrics::MetricsNavigationThrottle::Create(handle));\n  }\n\n#if BUILDFLAG(ENABLE_PLUGINS)\n  std::unique_ptr<content::NavigationThrottle> flash_url_throttle =\n      FlashDownloadInterception::MaybeCreateThrottleFor(handle);\n  if (flash_url_throttle)\n    throttles.push_back(std::move(flash_url_throttle));\n#endif\n\n#if BUILDFLAG(ENABLE_SUPERVISED_USERS)\n  std::unique_ptr<content::NavigationThrottle> supervised_user_throttle =\n      SupervisedUserNavigationThrottle::MaybeCreateThrottleFor(handle);\n  if (supervised_user_throttle)\n    throttles.push_back(std::move(supervised_user_throttle));\n#endif\n\n#if defined(OS_ANDROID)\n  prerender::PrerenderContents* prerender_contents =\n      prerender::PrerenderContents::FromWebContents(handle->GetWebContents());\n  if (!prerender_contents && handle->IsInMainFrame()) {\n    throttles.push_back(\n        navigation_interception::InterceptNavigationDelegate::CreateThrottleFor(\n            handle));\n  }\n  throttles.push_back(InterceptOMADownloadNavigationThrottle::Create(handle));\n#elif BUILDFLAG(ENABLE_EXTENSIONS)\n  if (handle->IsInMainFrame()) {\n    auto url_to_app_throttle =\n        PlatformAppNavigationRedirector::MaybeCreateThrottleFor(handle);\n    if (url_to_app_throttle)\n      throttles.push_back(std::move(url_to_app_throttle));\n  }\n\n  if (base::FeatureList::IsEnabled(features::kDesktopPWAWindowing)) {\n    if (base::FeatureList::IsEnabled(features::kDesktopPWAsLinkCapturing)) {\n      auto bookmark_app_experimental_throttle =\n          extensions::BookmarkAppExperimentalNavigationThrottle::\n              MaybeCreateThrottleFor(handle);\n      if (bookmark_app_experimental_throttle)\n        throttles.push_back(std::move(bookmark_app_experimental_throttle));\n    } else if (!base::FeatureList::IsEnabled(\n                   features::kDesktopPWAsStayInWindow)) {\n      auto bookmark_app_throttle =\n          extensions::BookmarkAppNavigationThrottle::MaybeCreateThrottleFor(\n              handle);\n      if (bookmark_app_throttle)\n        throttles.push_back(std::move(bookmark_app_throttle));\n    }\n  }\n   if (base::FeatureList::IsEnabled(\n           features::kMimeHandlerViewInCrossProcessFrame)) {\n     auto plugin_frame_attach_throttle =\n        extensions::ExtensionsGuestViewMessageFilter::MaybeCreateThrottle(\n            handle);\n     if (plugin_frame_attach_throttle)\n       throttles.push_back(std::move(plugin_frame_attach_throttle));\n   }\n#endif\n\n#if defined(OS_CHROMEOS)\n  if (handle->IsInMainFrame()) {\n    if (merge_session_throttling_utils::ShouldAttachNavigationThrottle() &&\n        !merge_session_throttling_utils::AreAllSessionMergedAlready() &&\n        handle->GetURL().SchemeIsHTTPOrHTTPS()) {\n      throttles.push_back(MergeSessionNavigationThrottle::Create(handle));\n    }\n\n    auto url_to_apps_throttle =\n        chromeos::AppsNavigationThrottle::MaybeCreate(handle);\n    if (url_to_apps_throttle)\n      throttles.push_back(std::move(url_to_apps_throttle));\n  }\n#endif\n\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n  throttles.push_back(\n      std::make_unique<extensions::ExtensionNavigationThrottle>(handle));\n\n  std::unique_ptr<content::NavigationThrottle> user_script_throttle =\n      extensions::ExtensionsBrowserClient::Get()\n          ->GetUserScriptListener()\n          ->CreateNavigationThrottle(handle);\n  if (user_script_throttle)\n    throttles.push_back(std::move(user_script_throttle));\n#endif\n\n#if BUILDFLAG(ENABLE_SUPERVISED_USERS)\n  std::unique_ptr<content::NavigationThrottle> supervised_user_nav_throttle =\n      SupervisedUserGoogleAuthNavigationThrottle::MaybeCreate(handle);\n  if (supervised_user_nav_throttle)\n    throttles.push_back(std::move(supervised_user_nav_throttle));\n#endif\n\n  content::WebContents* web_contents = handle->GetWebContents();\n  if (auto* subresource_filter_client =\n          ChromeSubresourceFilterClient::FromWebContents(web_contents)) {\n    subresource_filter_client->MaybeAppendNavigationThrottles(handle,\n                                                              &throttles);\n  }\n\n#if !defined(OS_ANDROID)\n  std::unique_ptr<content::NavigationThrottle>\n      background_tab_navigation_throttle = resource_coordinator::\n          BackgroundTabNavigationThrottle::MaybeCreateThrottleFor(handle);\n  if (background_tab_navigation_throttle)\n    throttles.push_back(std::move(background_tab_navigation_throttle));\n#endif\n\n#if defined(SAFE_BROWSING_DB_LOCAL)\n  std::unique_ptr<content::NavigationThrottle>\n      password_protection_navigation_throttle =\n          safe_browsing::MaybeCreateNavigationThrottle(handle);\n  if (password_protection_navigation_throttle) {\n    throttles.push_back(std::move(password_protection_navigation_throttle));\n  }\n#endif\n\n  std::unique_ptr<content::NavigationThrottle> pdf_iframe_throttle =\n      PDFIFrameNavigationThrottle::MaybeCreateThrottleFor(handle);\n  if (pdf_iframe_throttle)\n    throttles.push_back(std::move(pdf_iframe_throttle));\n\n  std::unique_ptr<content::NavigationThrottle> tab_under_throttle =\n      TabUnderNavigationThrottle::MaybeCreate(handle);\n  if (tab_under_throttle)\n    throttles.push_back(std::move(tab_under_throttle));\n\n  throttles.push_back(std::make_unique<PolicyBlacklistNavigationThrottle>(\n      handle, handle->GetWebContents()->GetBrowserContext()));\n\n  if (base::FeatureList::IsEnabled(features::kSSLCommittedInterstitials)) {\n    throttles.push_back(std::make_unique<SSLErrorNavigationThrottle>(\n        handle,\n        std::make_unique<CertificateReportingServiceCertReporter>(web_contents),\n        base::Bind(&SSLErrorHandler::HandleSSLError)));\n  }\n\n  std::unique_ptr<content::NavigationThrottle> https_upgrade_timing_throttle =\n      TypedNavigationTimingThrottle::MaybeCreateThrottleFor(handle);\n  if (https_upgrade_timing_throttle)\n    throttles.push_back(std::move(https_upgrade_timing_throttle));\n\n#if !defined(OS_ANDROID)\n  std::unique_ptr<content::NavigationThrottle> devtools_throttle =\n      DevToolsWindow::MaybeCreateNavigationThrottle(handle);\n  if (devtools_throttle)\n    throttles.push_back(std::move(devtools_throttle));\n\n  std::unique_ptr<content::NavigationThrottle> new_tab_page_throttle =\n      NewTabPageNavigationThrottle::MaybeCreateThrottleFor(handle);\n  if (new_tab_page_throttle)\n    throttles.push_back(std::move(new_tab_page_throttle));\n\n  std::unique_ptr<content::NavigationThrottle>\n      google_password_manager_throttle =\n          GooglePasswordManagerNavigationThrottle::MaybeCreateThrottleFor(\n              handle);\n  if (google_password_manager_throttle)\n    throttles.push_back(std::move(google_password_manager_throttle));\n#endif\n\n  std::unique_ptr<content::NavigationThrottle> previews_lite_page_throttle =\n      PreviewsLitePageDecider::MaybeCreateThrottleFor(handle);\n  if (previews_lite_page_throttle)\n    throttles.push_back(std::move(previews_lite_page_throttle));\n  if (base::FeatureList::IsEnabled(safe_browsing::kCommittedSBInterstitials)) {\n    throttles.push_back(\n        std::make_unique<safe_browsing::SafeBrowsingNavigationThrottle>(\n            handle));\n  }\n\n#if defined(OS_WIN) || defined(OS_MACOSX) || \\\n    (defined(OS_LINUX) && !defined(OS_CHROMEOS))\n  std::unique_ptr<content::NavigationThrottle> browser_switcher_throttle =\n      browser_switcher::BrowserSwitcherNavigationThrottle ::\n          MaybeCreateThrottleFor(handle);\n  if (browser_switcher_throttle)\n    throttles.push_back(std::move(browser_switcher_throttle));\n#endif\n\n  return throttles;\n}\n", "target": 1, "idx": 187015}
{"func": "void Editor::pasteAsPlainText(EditorCommandSource source) {\n  if (tryDHTMLPaste(PlainTextOnly))\n    return;\n  if (!canPaste())\n    return;\n  spellChecker().updateMarkersForWordsAffectedByEditing(false);\n  pasteAsPlainTextWithPasteboard(Pasteboard::generalPasteboard());\n}\n", "target": 0, "idx": 140347}
{"func": "static void webkitWebViewBaseContainerAdd(GtkContainer* container, GtkWidget* widget)\n{\n    WebKitWebViewBase* webView = WEBKIT_WEB_VIEW_BASE(container);\n    WebKitWebViewBasePrivate* priv = webView->priv;\n\n    if (WEBKIT_IS_WEB_VIEW_BASE(widget)\n         && WebInspectorProxy::isInspectorPage(WEBKIT_WEB_VIEW_BASE(widget)->priv->pageProxy.get())) {\n         ASSERT(!priv->inspectorView);\n         priv->inspectorView = widget;\n        priv->inspectorViewHeight = gMinimumAttachedInspectorHeight;\n     } else {\n         GtkAllocation childAllocation;\n         gtk_widget_get_allocation(widget, &childAllocation);\n        priv->children.set(widget, childAllocation);\n    }\n\n    gtk_widget_set_parent(widget, GTK_WIDGET(container));\n}\n", "target": 1, "idx": 184744}
{"func": "static void put_crypt_info(struct fscrypt_info *ci)\n{\n \tif (!ci)\n \t\treturn;\n \n\tkey_put(ci->ci_keyring_key);\n \tcrypto_free_skcipher(ci->ci_ctfm);\n \tkmem_cache_free(fscrypt_info_cachep, ci);\n }\n", "target": 1, "idx": 181455}
{"func": "AP_DECLARE(int) ap_some_auth_required(request_rec *r)\n{\n    /* Is there a require line configured for the type of *this* req? */\n    if (ap__authz_ap_some_auth_required) {\n        return ap__authz_ap_some_auth_required(r);\n    }\n    else\n        return 0;\n}\n", "target": 0, "idx": 43608}
{"func": "void acpi_os_printf(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tacpi_os_vprintf(fmt, args);\n\tva_end(args);\n}\n", "target": 0, "idx": 53859}
{"func": " PassRefPtr<DocumentFragment> Range::createContextualFragment(const String& markup, ExceptionCode& ec)\n {\n     if (!m_start.container()) {\n        ec = INVALID_STATE_ERR;\n        return 0;\n    }\n\n    Node* element = m_start.container()->isElementNode() ? m_start.container() : m_start.container()->parentNode();\n    if (!element || !element->isHTMLElement()) {\n        ec = NOT_SUPPORTED_ERR;\n         return 0;\n     }\n \n    RefPtr<DocumentFragment> fragment = createDocumentFragmentForElement(markup, toElement(element), AllowScriptingContentAndDoNotMarkAlreadyStarted);\n \n     if (!fragment) {\n         ec = NOT_SUPPORTED_ERR;\n        return 0;\n    }\n\n    return fragment.release();\n}\n", "target": 1, "idx": 183891}
{"func": "bdfReadCharacters(FontFilePtr file, FontPtr pFont, bdfFileState *pState,\n\t\t  int bit, int byte, int glyph, int scan)\n{\n    unsigned char *line;\n    register CharInfoPtr ci;\n    int         i,\n                ndx,\n                nchars,\n                nignored;\n    unsigned int char_row, char_col;\n    int         numEncodedGlyphs = 0;\n    CharInfoPtr *bdfEncoding[256];\n    BitmapFontPtr  bitmapFont;\n    BitmapExtraPtr bitmapExtra;\n    CARD32     *bitmapsSizes;\n    unsigned char        lineBuf[BDFLINELEN];\n    int         nencoding;\n\n    bitmapFont = (BitmapFontPtr) pFont->fontPrivate;\n    bitmapExtra = (BitmapExtraPtr) bitmapFont->bitmapExtra;\n\n    if (bitmapExtra) {\n\tbitmapsSizes = bitmapExtra->bitmapsSizes;\n\tfor (i = 0; i < GLYPHPADOPTIONS; i++)\n\t    bitmapsSizes[i] = 0;\n    } else\n\tbitmapsSizes = NULL;\n\n    bzero(bdfEncoding, sizeof(bdfEncoding));\n    bitmapFont->metrics = NULL;\n    ndx = 0;\n\n    line = bdfGetLine(file, lineBuf, BDFLINELEN);\n\n    if ((!line) || (sscanf((char *) line, \"CHARS %d\", &nchars) != 1)) {\n\tbdfError(\"bad 'CHARS' in bdf file\\n\");\n\treturn (FALSE);\n    }\n    if (nchars < 1) {\n\tbdfError(\"invalid number of CHARS in BDF file\\n\");\n\treturn (FALSE);\n    }\n    if (nchars > INT32_MAX / sizeof(CharInfoRec)) {\n\tbdfError(\"Couldn't allocate pCI (%d*%d)\\n\", nchars,\n\t\t (int) sizeof(CharInfoRec));\n\tgoto BAILOUT;\n    }\n    ci = calloc(nchars, sizeof(CharInfoRec));\n    if (!ci) {\n\tbdfError(\"Couldn't allocate pCI (%d*%d)\\n\", nchars,\n\t\t (int) sizeof(CharInfoRec));\n\tgoto BAILOUT;\n    }\n    bitmapFont->metrics = ci;\n\n    if (bitmapExtra) {\n\tbitmapExtra->glyphNames = malloc(nchars * sizeof(Atom));\n\tif (!bitmapExtra->glyphNames) {\n\t    bdfError(\"Couldn't allocate glyphNames (%d*%d)\\n\",\n\t\t     nchars, (int) sizeof(Atom));\n\t    goto BAILOUT;\n\t}\n    }\n    if (bitmapExtra) {\n\tbitmapExtra->sWidths = malloc(nchars * sizeof(int));\n\tif (!bitmapExtra->sWidths) {\n\t    bdfError(\"Couldn't allocate sWidth (%d *%d)\\n\",\n\t\t     nchars, (int) sizeof(int));\n\t    return FALSE;\n\t}\n    }\n    line = bdfGetLine(file, lineBuf, BDFLINELEN);\n    pFont->info.firstRow = 256;\n    pFont->info.lastRow = 0;\n    pFont->info.firstCol = 256;\n    pFont->info.lastCol = 0;\n    nignored = 0;\n    for (ndx = 0; (ndx < nchars) && (line) && (bdfIsPrefix(line, \"STARTCHAR\"));) {\n\tint         t;\n\tint         wx;\t\t/* x component of width */\n\tint         wy;\t\t/* y component of width */\n\tint         bw;\t\t/* bounding-box width */\n\tint         bh;\t\t/* bounding-box height */\n\tint         bl;\t\t/* bounding-box left */\n\tint         bb;\t\t/* bounding-box bottom */\n\tint         enc,\n\t            enc2;\t/* encoding */\n\tunsigned char *p;\t/* temp pointer into line */\n \tchar        charName[100];\n \tint         ignore;\n \n\tif (sscanf((char *) line, \"STARTCHAR %s\", charName) != 1) {\n \t    bdfError(\"bad character name in BDF file\\n\");\n \t    goto BAILOUT;\t/* bottom of function, free and return error */\n \t}\n\tif (bitmapExtra)\n\t    bitmapExtra->glyphNames[ndx] = bdfForceMakeAtom(charName, NULL);\n\n\tline = bdfGetLine(file, lineBuf, BDFLINELEN);\n\tif (!line || (t = sscanf((char *) line, \"ENCODING %d %d\", &enc, &enc2)) < 1) {\n\t    bdfError(\"bad 'ENCODING' in BDF file\\n\");\n\t    goto BAILOUT;\n\t}\n\tif (enc < -1 || (t == 2 && enc2 < -1)) {\n\t    bdfError(\"bad ENCODING value\");\n\t    goto BAILOUT;\n\t}\n\tif (t == 2 && enc == -1)\n\t    enc = enc2;\n\tignore = 0;\n\tif (enc == -1) {\n\t    if (!bitmapExtra) {\n\t\tnignored++;\n\t\tignore = 1;\n\t    }\n\t} else if (enc > MAXENCODING) {\n\t    bdfError(\"char '%s' has encoding too large (%d)\\n\",\n\t\t     charName, enc);\n\t} else {\n\t    char_row = (enc >> 8) & 0xFF;\n\t    char_col = enc & 0xFF;\n\t    if (char_row < pFont->info.firstRow)\n\t\tpFont->info.firstRow = char_row;\n\t    if (char_row > pFont->info.lastRow)\n\t\tpFont->info.lastRow = char_row;\n\t    if (char_col < pFont->info.firstCol)\n\t\tpFont->info.firstCol = char_col;\n\t    if (char_col > pFont->info.lastCol)\n\t\tpFont->info.lastCol = char_col;\n\t    if (bdfEncoding[char_row] == (CharInfoPtr *) NULL) {\n\t\tbdfEncoding[char_row] = malloc(256 * sizeof(CharInfoPtr));\n\t\tif (!bdfEncoding[char_row]) {\n\t\t    bdfError(\"Couldn't allocate row %d of encoding (%d*%d)\\n\",\n\t\t\t     char_row, INDICES, (int) sizeof(CharInfoPtr));\n\t\t    goto BAILOUT;\n\t\t}\n\t\tfor (i = 0; i < 256; i++)\n\t\t    bdfEncoding[char_row][i] = (CharInfoPtr) NULL;\n\t    }\n\t    if (bdfEncoding[char_row] != NULL) {\n\t\tbdfEncoding[char_row][char_col] = ci;\n\t\tnumEncodedGlyphs++;\n\t    }\n\t}\n\n\tline = bdfGetLine(file, lineBuf, BDFLINELEN);\n\tif ((!line) || (sscanf((char *) line, \"SWIDTH %d %d\", &wx, &wy) != 2)) {\n\t    bdfError(\"bad 'SWIDTH'\\n\");\n\t    goto BAILOUT;\n\t}\n\tif (wy != 0) {\n\t    bdfError(\"SWIDTH y value must be zero\\n\");\n\t    goto BAILOUT;\n\t}\n\tif (bitmapExtra)\n\t    bitmapExtra->sWidths[ndx] = wx;\n\n/* 5/31/89 (ef) -- we should be able to ditch the character and recover */\n/*\t\tfrom all of these.\t\t\t\t\t*/\n\n\tline = bdfGetLine(file, lineBuf, BDFLINELEN);\n\tif ((!line) || (sscanf((char *) line, \"DWIDTH %d %d\", &wx, &wy) != 2)) {\n\t    bdfError(\"bad 'DWIDTH'\\n\");\n\t    goto BAILOUT;\n\t}\n\tif (wy != 0) {\n\t    bdfError(\"DWIDTH y value must be zero\\n\");\n\t    goto BAILOUT;\n\t}\n\tline = bdfGetLine(file, lineBuf, BDFLINELEN);\n\tif ((!line) || (sscanf((char *) line, \"BBX %d %d %d %d\", &bw, &bh, &bl, &bb) != 4)) {\n\t    bdfError(\"bad 'BBX'\\n\");\n\t    goto BAILOUT;\n\t}\n\tif ((bh < 0) || (bw < 0)) {\n\t    bdfError(\"character '%s' has a negative sized bitmap, %dx%d\\n\",\n\t\t     charName, bw, bh);\n\t    goto BAILOUT;\n\t}\n\tline = bdfGetLine(file, lineBuf, BDFLINELEN);\n\tif ((line) && (bdfIsPrefix(line, \"ATTRIBUTES\"))) {\n\t    for (p = line + strlen(\"ATTRIBUTES \");\n\t\t    (*p == ' ') || (*p == '\\t');\n\t\t    p++)\n\t\t /* empty for loop */ ;\n\t    ci->metrics.attributes = (bdfHexByte(p) << 8) + bdfHexByte(p + 2);\n\t    line = bdfGetLine(file, lineBuf, BDFLINELEN);\n\t} else\n\t    ci->metrics.attributes = 0;\n\n\tif (!line || !bdfIsPrefix(line, \"BITMAP\")) {\n\t    bdfError(\"missing 'BITMAP'\\n\");\n\t    goto BAILOUT;\n\t}\n\t/* collect data for generated properties */\n\tif ((strlen(charName) == 1)) {\n\t    if ((charName[0] >= '0') && (charName[0] <= '9')) {\n\t\tpState->digitWidths += wx;\n\t\tpState->digitCount++;\n\t    } else if (charName[0] == 'x') {\n\t\tpState->exHeight = (bh + bb) <= 0 ? bh : bh + bb;\n\t    }\n\t}\n\tif (!ignore) {\n\t    ci->metrics.leftSideBearing = bl;\n\t    ci->metrics.rightSideBearing = bl + bw;\n\t    ci->metrics.ascent = bh + bb;\n\t    ci->metrics.descent = -bb;\n\t    ci->metrics.characterWidth = wx;\n\t    ci->bits = NULL;\n\t    bdfReadBitmap(ci, file, bit, byte, glyph, scan, bitmapsSizes);\n\t    ci++;\n\t    ndx++;\n\t} else\n\t    bdfSkipBitmap(file, bh);\n\n\tline = bdfGetLine(file, lineBuf, BDFLINELEN);\t/* get STARTCHAR or\n\t\t\t\t\t\t\t * ENDFONT */\n    }\n\n    if (ndx + nignored != nchars) {\n\tbdfError(\"%d too few characters\\n\", nchars - (ndx + nignored));\n\tgoto BAILOUT;\n    }\n    nchars = ndx;\n    bitmapFont->num_chars = nchars;\n    if ((line) && (bdfIsPrefix(line, \"STARTCHAR\"))) {\n\tbdfError(\"more characters than specified\\n\");\n\tgoto BAILOUT;\n    }\n    if ((!line) || (!bdfIsPrefix(line, \"ENDFONT\"))) {\n\tbdfError(\"missing 'ENDFONT'\\n\");\n\tgoto BAILOUT;\n    }\n    if (numEncodedGlyphs == 0)\n\tbdfWarning(\"No characters with valid encodings\\n\");\n\n    nencoding = (pFont->info.lastRow - pFont->info.firstRow + 1) *\n\t(pFont->info.lastCol - pFont->info.firstCol + 1);\n    bitmapFont->encoding = calloc(NUM_SEGMENTS(nencoding),sizeof(CharInfoPtr*));\n    if (!bitmapFont->encoding) {\n\tbdfError(\"Couldn't allocate ppCI (%d,%d)\\n\",\n                 NUM_SEGMENTS(nencoding),\n                 (int) sizeof(CharInfoPtr*));\n\tgoto BAILOUT;\n    }\n    pFont->info.allExist = TRUE;\n    i = 0;\n    for (char_row = pFont->info.firstRow;\n\t    char_row <= pFont->info.lastRow;\n\t    char_row++) {\n\tif (bdfEncoding[char_row] == (CharInfoPtr *) NULL) {\n\t    pFont->info.allExist = FALSE;\n            i += pFont->info.lastCol - pFont->info.firstCol + 1;\n\t} else {\n\t    for (char_col = pFont->info.firstCol;\n\t\t    char_col <= pFont->info.lastCol;\n\t\t    char_col++) {\n\t\tif (!bdfEncoding[char_row][char_col])\n\t\t    pFont->info.allExist = FALSE;\n                else {\n                    if (!bitmapFont->encoding[SEGMENT_MAJOR(i)]) {\n                        bitmapFont->encoding[SEGMENT_MAJOR(i)]=\n                            calloc(BITMAP_FONT_SEGMENT_SIZE,\n                                   sizeof(CharInfoPtr));\n                        if (!bitmapFont->encoding[SEGMENT_MAJOR(i)])\n                            goto BAILOUT;\n                    }\n                    ACCESSENCODINGL(bitmapFont->encoding,i) =\n                        bdfEncoding[char_row][char_col];\n                }\n                i++;\n            }\n\t}\n    }\n    for (i = 0; i < 256; i++)\n\tif (bdfEncoding[i])\n\t    free(bdfEncoding[i]);\n    return (TRUE);\nBAILOUT:\n    for (i = 0; i < 256; i++)\n\tif (bdfEncoding[i])\n\t    free(bdfEncoding[i]);\n    /* bdfFreeFontBits will clean up the rest */\n    return (FALSE);\n}\n", "target": 1, "idx": 178505}
{"func": "snap_print(netdissect_options *ndo, const u_char *p, u_int length, u_int caplen,\n\tconst struct lladdr_info *src, const struct lladdr_info *dst,\n\tu_int bridge_pad)\n{\n\tuint32_t orgcode;\n\tregister u_short et;\n\tregister int ret;\n\n\tND_TCHECK2(*p, 5);\n\tif (caplen < 5 || length < 5)\n\t\tgoto trunc;\n\torgcode = EXTRACT_24BITS(p);\n\tet = EXTRACT_16BITS(p + 3);\n\n\tif (ndo->ndo_eflag) {\n\t\t/*\n\t\t * Somebody's already printed the MAC addresses, if there\n\t\t * are any, so just print the SNAP header, not the MAC\n\t\t * addresses.\n\t\t */\n\t\tND_PRINT((ndo, \"oui %s (0x%06x), %s %s (0x%04x), length %u: \",\n\t\t     tok2str(oui_values, \"Unknown\", orgcode),\n\t\t     orgcode,\n\t\t     (orgcode == 0x000000 ? \"ethertype\" : \"pid\"),\n\t\t     tok2str(oui_to_struct_tok(orgcode), \"Unknown\", et),\n\t\t     et, length - 5));\n\t}\n\tp += 5;\n\tlength -= 5;\n\tcaplen -= 5;\n\n\tswitch (orgcode) {\n\tcase OUI_ENCAP_ETHER:\n\tcase OUI_CISCO_90:\n\t\t/*\n\t\t * This is an encapsulated Ethernet packet,\n\t\t * or a packet bridged by some piece of\n\t\t * Cisco hardware; the protocol ID is\n\t\t * an Ethernet protocol type.\n\t\t */\n\t\tret = ethertype_print(ndo, et, p, length, caplen, src, dst);\n\t\tif (ret)\n\t\t\treturn (ret);\n\t\tbreak;\n\n\tcase OUI_APPLETALK:\n\t\tif (et == ETHERTYPE_ATALK) {\n\t\t\t/*\n\t\t\t * No, I have no idea why Apple used one\n\t\t\t * of their own OUIs, rather than\n\t\t\t * 0x000000, and an Ethernet packet\n\t\t\t * type, for Appletalk data packets,\n\t\t\t * but used 0x000000 and an Ethernet\n\t\t\t * packet type for AARP packets.\n\t\t\t */\n\t\t\tret = ethertype_print(ndo, et, p, length, caplen, src, dst);\n\t\t\tif (ret)\n\t\t\t\treturn (ret);\n\t\t}\n\t\tbreak;\n\n\tcase OUI_CISCO:\n                switch (et) {\n                case PID_CISCO_CDP:\n                        cdp_print(ndo, p, length, caplen);\n                        return (1);\n                case PID_CISCO_DTP:\n                        dtp_print(ndo, p, length);\n                        return (1);\n                case PID_CISCO_UDLD:\n                        udld_print(ndo, p, length);\n                        return (1);\n                case PID_CISCO_VTP:\n                        vtp_print(ndo, p, length);\n                        return (1);\n                case PID_CISCO_PVST:\n                case PID_CISCO_VLANBRIDGE:\n                        stp_print(ndo, p, length);\n                        return (1);\n                default:\n                        break;\n                }\n\t\tbreak;\n\n\tcase OUI_RFC2684:\n\t\tswitch (et) {\n\n\t\tcase PID_RFC2684_ETH_FCS:\n\t\tcase PID_RFC2684_ETH_NOFCS:\n\t\t\t/*\n\t\t\t * XXX - remove the last two bytes for\n\t\t\t * PID_RFC2684_ETH_FCS?\n\t\t\t */\n\t\t\t/*\n\t\t\t * Skip the padding.\n\t\t\t */\n\t\t\tND_TCHECK2(*p, bridge_pad);\n\t\t\tcaplen -= bridge_pad;\n\t\t\tlength -= bridge_pad;\n\t\t\tp += bridge_pad;\n\n\t\t\t/*\n\t\t\t * What remains is an Ethernet packet.\n\t\t\t */\n\t\t\tether_print(ndo, p, length, caplen, NULL, NULL);\n\t\t\treturn (1);\n\n\t\tcase PID_RFC2684_802_5_FCS:\n\t\tcase PID_RFC2684_802_5_NOFCS:\n\t\t\t/*\n\t\t\t * XXX - remove the last two bytes for\n\t\t\t * PID_RFC2684_ETH_FCS?\n\t\t\t */\n\t\t\t/*\n\t\t\t * Skip the padding, but not the Access\n\t\t\t * Control field.\n\t\t\t */\n\t\t\tND_TCHECK2(*p, bridge_pad);\n\t\t\tcaplen -= bridge_pad;\n\t\t\tlength -= bridge_pad;\n\t\t\tp += bridge_pad;\n\n\t\t\t/*\n\t\t\t * What remains is an 802.5 Token Ring\n\t\t\t * packet.\n\t\t\t */\n\t\t\ttoken_print(ndo, p, length, caplen);\n\t\t\treturn (1);\n\n\t\tcase PID_RFC2684_FDDI_FCS:\n\t\tcase PID_RFC2684_FDDI_NOFCS:\n\t\t\t/*\n\t\t\t * XXX - remove the last two bytes for\n\t\t\t * PID_RFC2684_ETH_FCS?\n\t\t\t */\n\t\t\t/*\n\t\t\t * Skip the padding.\n\t\t\t */\n\t\t\tND_TCHECK2(*p, bridge_pad + 1);\n\t\t\tcaplen -= bridge_pad + 1;\n\t\t\tlength -= bridge_pad + 1;\n\t\t\tp += bridge_pad + 1;\n\n\t\t\t/*\n\t\t\t * What remains is an FDDI packet.\n\t\t\t */\n\t\t\tfddi_print(ndo, p, length, caplen);\n\t\t\treturn (1);\n\n\t\tcase PID_RFC2684_BPDU:\n\t\t\tstp_print(ndo, p, length);\n\t\t\treturn (1);\n\t\t}\n\t}\n\tif (!ndo->ndo_eflag) {\n\t\t/*\n\t\t * Nobody printed the link-layer addresses, so print them, if\n\t\t * we have any.\n\t\t */\n\t\tif (src != NULL && dst != NULL) {\n\t\t\tND_PRINT((ndo, \"%s > %s \",\n\t\t\t\t(src->addr_string)(ndo, src->addr),\n\t\t\t\t(dst->addr_string)(ndo, dst->addr)));\n\t\t}\n\t\t/*\n\t\t * Print the SNAP header, but if the OUI is 000000, don't\n\t\t * bother printing it, and report the PID as being an\n\t\t * ethertype.\n\t\t */\n\t\tif (orgcode == 0x000000) {\n\t\t\tND_PRINT((ndo, \"SNAP, ethertype %s (0x%04x), length %u: \",\n\t\t\t     tok2str(ethertype_values, \"Unknown\", et),\n\t\t\t     et, length));\n\t\t} else {\n\t\t\tND_PRINT((ndo, \"SNAP, oui %s (0x%06x), pid %s (0x%04x), length %u: \",\n\t\t\t     tok2str(oui_values, \"Unknown\", orgcode),\n\t\t\t     orgcode,\n\t\t\t     tok2str(oui_to_struct_tok(orgcode), \"Unknown\", et),\n\t\t\t     et, length));\n\t\t}\n\t}\n\treturn (0);\n\ntrunc:\n\tND_PRINT((ndo, \"[|snap]\"));\n\treturn (1);\n}\n", "target": 0, "idx": 62584}
{"func": "bool RenderViewHostManager::ShouldReuseWebUI(\n    const NavigationEntry* curr_entry,\n    const NavigationEntryImpl* new_entry) const {\n  NavigationControllerImpl& controller =\n      delegate_->GetControllerForRenderManager();\n  return curr_entry && web_ui_.get() &&\n      (WebUIControllerFactoryRegistry::GetInstance()->GetWebUIType(\n          controller.GetBrowserContext(), curr_entry->GetURL()) ==\n       WebUIControllerFactoryRegistry::GetInstance()->GetWebUIType(\n          controller.GetBrowserContext(), new_entry->GetURL()));\n}\n", "target": 0, "idx": 124167}
{"func": "megasas_ld_list_query(struct megasas_instance *instance, u8 query_type)\n{\n\tint ret = 0, ld_index = 0, ids = 0;\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\tstruct MR_LD_TARGETID_LIST *ci;\n\tdma_addr_t ci_h = 0;\n\tu32 tgtid_count;\n\n\tci = instance->ld_targetid_list_buf;\n\tci_h = instance->ld_targetid_list_buf_h;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd) {\n\t\tdev_warn(&instance->pdev->dev,\n\t\t         \"megasas_ld_list_query: Failed to get cmd\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tmemset(ci, 0, sizeof(*ci));\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tdcmd->mbox.b[0] = query_type;\n\tif (instance->supportmax256vd)\n\t\tdcmd->mbox.b[2] = 1;\n\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = MFI_STAT_INVALID_STATUS;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = MFI_FRAME_DIR_READ;\n\tdcmd->timeout = 0;\n\tdcmd->data_xfer_len = cpu_to_le32(sizeof(struct MR_LD_TARGETID_LIST));\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_LD_LIST_QUERY);\n\tdcmd->pad_0  = 0;\n\n\tmegasas_set_dma_settings(instance, dcmd, ci_h,\n\t\t\t\t sizeof(struct MR_LD_TARGETID_LIST));\n\n\tif ((instance->adapter_type != MFI_SERIES) &&\n\t    !instance->mask_interrupts)\n\t\tret = megasas_issue_blocked_cmd(instance, cmd, MFI_IO_TIMEOUT_SECS);\n\telse\n\t\tret = megasas_issue_polled(instance, cmd);\n\n\tswitch (ret) {\n\tcase DCMD_FAILED:\n\t\tdev_info(&instance->pdev->dev,\n\t\t\t\"DCMD not supported by firmware - %s %d\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\tret = megasas_get_ld_list(instance);\n\t\tbreak;\n\tcase DCMD_TIMEOUT:\n\t\tswitch (dcmd_timeout_ocr_possible(instance)) {\n\t\tcase INITIATE_OCR:\n\t\t\tcmd->flags |= DRV_DCMD_SKIP_REFIRE;\n\t\t\t/*\n\t\t\t * DCMD failed from AEN path.\n\t\t\t * AEN path already hold reset_mutex to avoid PCI access\n\t\t\t * while OCR is in progress.\n\t\t\t */\n\t\t\tmutex_unlock(&instance->reset_mutex);\n\t\t\tmegasas_reset_fusion(instance->host,\n\t\t\t\t\t\tMFI_IO_TIMEOUT_OCR);\n\t\t\tmutex_lock(&instance->reset_mutex);\n\t\t\tbreak;\n\t\tcase KILL_ADAPTER:\n\t\t\tmegaraid_sas_kill_hba(instance);\n\t\t\tbreak;\n\t\tcase IGNORE_TIMEOUT:\n\t\t\tdev_info(&instance->pdev->dev, \"Ignore DCMD timeout: %s %d\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\tcase DCMD_SUCCESS:\n\t\ttgtid_count = le32_to_cpu(ci->count);\n\n\t\tif ((tgtid_count > (instance->fw_supported_vd_count)))\n\t\t\tbreak;\n\n\t\tmemset(instance->ld_ids, 0xff, MEGASAS_MAX_LD_IDS);\n\t\tfor (ld_index = 0; ld_index < tgtid_count; ld_index++) {\n\t\t\tids = ci->targetId[ld_index];\n\t\t\tinstance->ld_ids[ids] = ci->targetId[ld_index];\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tif (ret != DCMD_TIMEOUT)\n\t\tmegasas_return_cmd(instance, cmd);\n\n\treturn ret;\n}\n", "target": 0, "idx": 90374}
{"func": "char *path_name(const struct name_path *path, const char *name)\n{\n\tconst struct name_path *p;\n\tchar *n, *m;\n\tint nlen = strlen(name);\n\tint len = nlen + 1;\n\n\tfor (p = path; p; p = p->up) {\n\t\tif (p->elem_len)\n\t\t\tlen += p->elem_len + 1;\n \t}\n \tn = xmalloc(len);\n \tm = n + len - (nlen + 1);\n\tstrcpy(m, name);\n \tfor (p = path; p; p = p->up) {\n \t\tif (p->elem_len) {\n \t\t\tm -= p->elem_len + 1;\n\t\t\tmemcpy(m, p->elem, p->elem_len);\n\t\t\tm[p->elem_len] = '/';\n\t\t}\n\t}\n\treturn n;\n}\n", "target": 1, "idx": 180601}
{"func": "static int ssh_channelcmp(void *av, void *bv)\n{\n    struct ssh_channel *a = (struct ssh_channel *) av;\n    struct ssh_channel *b = (struct ssh_channel *) bv;\n    if (a->localid < b->localid)\n\treturn -1;\n    if (a->localid > b->localid)\n\treturn +1;\n    return 0;\n}\n", "target": 0, "idx": 8554}
{"func": "jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)\n{\n\tjas_image_t *image;\n\tbmp_hdr_t hdr;\n\tbmp_info_t *info;\n\tuint_fast16_t cmptno;\n\tjas_image_cmptparm_t cmptparms[3];\n\tjas_image_cmptparm_t *cmptparm;\n \tuint_fast16_t numcmpts;\n \tlong n;\n \n \tif (optstr) {\n \t\tjas_eprintf(\"warning: ignoring BMP decoder options\\n\");\n \t}\n\n\tjas_eprintf(\n\t  \"THE BMP FORMAT IS NOT FULLY SUPPORTED!\\n\"\n\t  \"THAT IS, THE JASPER SOFTWARE CANNOT DECODE ALL TYPES OF BMP DATA.\\n\"\n\t  \"IF YOU HAVE ANY PROBLEMS, PLEASE TRY CONVERTING YOUR IMAGE DATA\\n\"\n\t  \"TO THE PNM FORMAT, AND USING THIS FORMAT INSTEAD.\\n\"\n\t  );\n\n \t/* Read the bitmap header. */\n \tif (bmp_gethdr(in, &hdr)) {\n \t\tjas_eprintf(\"cannot get header\\n\");\n\t\treturn 0;\n \t}\n \tJAS_DBGLOG(1, (\n \t  \"BMP header: magic 0x%x; siz %d; res1 %d; res2 %d; off %d\\n\",\n\t  hdr.magic, hdr.siz, hdr.reserved1, hdr.reserved2, hdr.off\n\t  ));\n\n \t/* Read the bitmap information. */\n \tif (!(info = bmp_getinfo(in))) {\n \t\tjas_eprintf(\"cannot get info\\n\");\n\t\treturn 0;\n \t}\n \tJAS_DBGLOG(1,\n\t  (\"BMP information: len %d; width %d; height %d; numplanes %d; \"\n\t  \"depth %d; enctype %d; siz %d; hres %d; vres %d; numcolors %d; \"\n\t  \"mincolors %d\\n\", info->len, info->width, info->height, info->numplanes,\n\t  info->depth, info->enctype, info->siz, info->hres, info->vres,\n\t  info->numcolors, info->mincolors));\n \n \t/* Ensure that we support this type of BMP file. */\n \tif (!bmp_issupported(&hdr, info)) {\n \t\tjas_eprintf(\"error: unsupported BMP encoding\\n\");\n\t\tbmp_info_destroy(info);\n\t\treturn 0;\n \t}\n \n \t/* Skip over any useless data between the end of the palette\n \t  and start of the bitmap data. */\n \tif ((n = hdr.off - (BMP_HDRLEN + BMP_INFOLEN + BMP_PALLEN(info))) < 0) {\n \t\tjas_eprintf(\"error: possibly bad bitmap offset?\\n\");\n\t\treturn 0;\n \t}\n \tif (n > 0) {\n \t\tjas_eprintf(\"skipping unknown data in BMP file\\n\");\n \t\tif (bmp_gobble(in, n)) {\n\t\t\tbmp_info_destroy(info);\n\t\t\treturn 0;\n \t\t}\n \t}\n \n\t/* Get the number of components. */\n\tnumcmpts = bmp_numcmpts(info);\n\n\tfor (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,\n\t  ++cmptparm) {\n\t\tcmptparm->tlx = 0;\n\t\tcmptparm->tly = 0;\n\t\tcmptparm->hstep = 1;\n\t\tcmptparm->vstep = 1;\n\t\tcmptparm->width = info->width;\n\t\tcmptparm->height = info->height;\n\t\tcmptparm->prec = 8;\n\t\tcmptparm->sgnd = false;\n\t}\n\n \t/* Create image object. */\n \tif (!(image = jas_image_create(numcmpts, cmptparms,\n \t  JAS_CLRSPC_UNKNOWN))) {\n\t\tbmp_info_destroy(info);\n\t\treturn 0;\n \t}\n \n \tif (numcmpts == 3) {\n\t\tjas_image_setclrspc(image, JAS_CLRSPC_SRGB);\n\t\tjas_image_setcmpttype(image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R));\n\t\tjas_image_setcmpttype(image, 1,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G));\n\t\tjas_image_setcmpttype(image, 2,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B));\n\t} else {\n\t\tjas_image_setclrspc(image, JAS_CLRSPC_SGRAY);\n\t\tjas_image_setcmpttype(image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y));\n\t}\n \n \t/* Read the bitmap data. */\n \tif (bmp_getdata(in, info, image)) {\n\t\tbmp_info_destroy(info);\n\t\tjas_image_destroy(image);\n\t\treturn 0;\n \t}\n \n \tbmp_info_destroy(info);\n \n \treturn image;\n }\n", "target": 1, "idx": 181928}
{"func": "cJSON *cJSON_DetachItemFromArray( cJSON *array, int which )\n{\n\tcJSON *c = array->child;\n\twhile ( c && which > 0 ) {\n\t\tc = c->next;\n\t\t--which;\n\t}\n\tif ( ! c )\n\t\treturn 0;\n\tif ( c->prev )\n\t\tc->prev->next = c->next;\n\tif ( c->next ) c->next->prev = c->prev;\n\tif ( c == array->child )\n\t\tarray->child = c->next;\n\tc->prev = c->next = 0;\n\treturn c;\n}\n", "target": 1, "idx": 180456}
{"func": "process_pa_data_to_key(krb5_context context,\n\t\t       krb5_get_init_creds_ctx *ctx,\n\t\t       krb5_creds *creds,\n\t\t       AS_REQ *a,\n\t\t       AS_REP *rep,\n\t\t       const krb5_krbhst_info *hi,\n\t\t       krb5_keyblock **key)\n{\n    struct pa_info_data paid, *ppaid = NULL;\n    krb5_error_code ret;\n    krb5_enctype etype;\n    PA_DATA *pa;\n\n    memset(&paid, 0, sizeof(paid));\n\n    etype = rep->enc_part.etype;\n\n    if (rep->padata) {\n\tpaid.etype = etype;\n\tppaid = process_pa_info(context, creds->client, a, &paid,\n\t\t\t\trep->padata);\n    }\n    if (ppaid == NULL)\n\tppaid = ctx->ppaid;\n    if (ppaid == NULL) {\n\tret = krb5_get_pw_salt (context, creds->client, &paid.salt);\n\tif (ret)\n\t    return ret;\n\tpaid.etype = etype;\n\tpaid.s2kparams = NULL;\n\tppaid = &paid;\n    }\n\n    pa = NULL;\n    if (rep->padata) {\n\tint idx = 0;\n\tpa = krb5_find_padata(rep->padata->val,\n\t\t\t      rep->padata->len,\n\t\t\t      KRB5_PADATA_PK_AS_REP,\n\t\t\t      &idx);\n\tif (pa == NULL) {\n\t    idx = 0;\n\t    pa = krb5_find_padata(rep->padata->val,\n\t\t\t\t  rep->padata->len,\n\t\t\t\t  KRB5_PADATA_PK_AS_REP_19,\n\t\t\t\t  &idx);\n\t}\n    }\n    if (pa && ctx->pk_init_ctx) {\n#ifdef PKINIT\n\t_krb5_debug(context, 5, \"krb5_get_init_creds: using PKINIT\");\n\n\tret = _krb5_pk_rd_pa_reply(context,\n\t\t\t\t   a->req_body.realm,\n\t\t\t\t   ctx->pk_init_ctx,\n\t\t\t\t   etype,\n\t\t\t\t   hi,\n\t\t\t\t   ctx->pk_nonce,\n\t\t\t\t   &ctx->req_buffer,\n\t\t\t\t   pa,\n\t\t\t\t   key);\n#else\n\tret = EINVAL;\n\tkrb5_set_error_message(context, ret, N_(\"no support for PKINIT compiled in\", \"\"));\n#endif\n    } else if (ctx->keyseed) {\n \t_krb5_debug(context, 5, \"krb5_get_init_creds: using keyproc\");\n\tret = pa_data_to_key_plain(context, creds->client, ctx,\n\t\t\t\t   ppaid->salt, ppaid->s2kparams, etype, key);\n    } else {\n\tret = EINVAL;\n\tkrb5_set_error_message(context, ret, N_(\"No usable pa data type\", \"\"));\n    }\n\n    free_paid(context, &paid);\n    return ret;\n}\n", "target": 0, "idx": 89941}
{"func": "static void spl_filesystem_object_free_storage(void *object TSRMLS_DC) /* {{{ */\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)object;\n\n \tif (intern->oth_handler && intern->oth_handler->dtor) {\n \t\tintern->oth_handler->dtor(intern TSRMLS_CC);\n \t}\n \tzend_object_std_dtor(&intern->std TSRMLS_CC);\n \tif (intern->_path) {\n \t\tefree(intern->_path);\n \t}\n\tif (intern->file_name) {\n\t\tefree(intern->file_name);\n\t}\n\tswitch(intern->type) {\n\tcase SPL_FS_INFO:\n\t\tbreak;\n\tcase SPL_FS_DIR:\n\t\tif (intern->u.dir.dirp) {\n\t\t\tphp_stream_close(intern->u.dir.dirp);\n\t\t\tintern->u.dir.dirp = NULL;\n \t\t}\n \t\tif (intern->u.dir.sub_path) {\n \t\t\tefree(intern->u.dir.sub_path);\n\t\t}\t\t\n \t\tbreak;\n \tcase SPL_FS_FILE:\n \t\tif (intern->u.file.stream) {\n\t\t\tif (intern->u.file.zcontext) {\n/*\t\t\t\tzend_list_delref(Z_RESVAL_P(intern->zcontext));*/\n\t\t\t}\n\t\t\tif (!intern->u.file.stream->is_persistent) {\n\t\t\t\tphp_stream_free(intern->u.file.stream, PHP_STREAM_FREE_CLOSE);\n\t\t\t} else {\n\t\t\t\tphp_stream_free(intern->u.file.stream, PHP_STREAM_FREE_CLOSE_PERSISTENT);\n\t\t\t}\n\t\t\tif (intern->u.file.open_mode) {\n\t\t\t\tefree(intern->u.file.open_mode);\n\t\t\t}\n\t\t\tif (intern->orig_path) {\n\t\t\t\tefree(intern->orig_path);\n\t\t\t}\n\t\t}\n\t\tspl_filesystem_file_free_line(intern TSRMLS_CC);\n\t\tbreak;\n\t}\n\n\t{\n\t\tzend_object_iterator *iterator;\n\t\titerator = (zend_object_iterator*)\n\t\t\t\tspl_filesystem_object_to_iterator(intern);\n\t\tif (iterator->data != NULL) {\n\t\t\titerator->data = NULL;\n\t\t\titerator->funcs->dtor(iterator TSRMLS_CC);\n\t\t}\n\t}\n\tefree(object);\n } /* }}} */\n", "target": 1, "idx": 180255}
{"func": "XGetDeviceControl(\n    register Display\t*dpy,\n    XDevice\t\t*dev,\n    int\t\t\t control)\n{\n    XDeviceControl *Device = NULL;\n    XDeviceControl *Sav = NULL;\n    xDeviceState *d = NULL;\n    xDeviceState *sav = NULL;\n    xGetDeviceControlReq *req;\n    xGetDeviceControlReply rep;\n    XExtDisplayInfo *info = XInput_find_display(dpy);\n\n    LockDisplay(dpy);\n    if (_XiCheckExtInit(dpy, XInput_Add_XChangeDeviceControl, info) == -1)\n        return NULL;\n\n    GetReq(GetDeviceControl, req);\n    req->reqType = info->codes->major_opcode;\n    req->ReqType = X_GetDeviceControl;\n    req->deviceid = dev->device_id;\n    req->control = control;\n\n    if (!_XReply(dpy, (xReply *) & rep, 0, xFalse))\n\tgoto out;\n\n     if (rep.length > 0) {\n \tunsigned long nbytes;\n \tsize_t size = 0;\n\tif (rep.length < (INT_MAX >> 2)) {\n \t    nbytes = (unsigned long) rep.length << 2;\n \t    d = Xmalloc(nbytes);\n \t}\n\t    _XEatDataWords(dpy, rep.length);\n\t    goto out;\n\t}\n\tsav = d;\n\t_XRead(dpy, (char *)d, nbytes);\n\n        /* In theory, we should just be able to use d->length to get the size.\n         * Turns out that a number of X servers (up to and including server\n         * 1.4) sent the wrong length value down the wire. So to not break\n         * apps that run against older servers, we have to calculate the size\n         * manually.\n         */\n\tswitch (d->control) {\n\tcase DEVICE_RESOLUTION:\n\t{\n\t    xDeviceResolutionState *r;\n\t    size_t val_size;\n \t    size_t val_size;\n \n \t    r = (xDeviceResolutionState *) d;\n\t    if (r->num_valuators >= (INT_MAX / (3 * sizeof(int))))\n \t\tgoto out;\n \t    val_size = 3 * sizeof(int) * r->num_valuators;\n \t    if ((sizeof(xDeviceResolutionState) + val_size) > nbytes)\n\t    break;\n\t}\n        case DEVICE_ABS_CALIB:\n        {\n            if (sizeof(xDeviceAbsCalibState) > nbytes)\n                goto out;\n            size = sizeof(XDeviceAbsCalibState);\n            break;\n        }\n        case DEVICE_ABS_AREA:\n        {\n            if (sizeof(xDeviceAbsAreaState) > nbytes)\n                goto out;\n            size = sizeof(XDeviceAbsAreaState);\n            break;\n        }\n        case DEVICE_CORE:\n        {\n            if (sizeof(xDeviceCoreState) > nbytes)\n                goto out;\n            size = sizeof(XDeviceCoreState);\n            break;\n        }\n\tdefault:\n\t    if (d->length > nbytes)\n\t\tgoto out;\n\t    size = d->length;\n\t    break;\n\t}\n\n\tDevice = Xmalloc(size);\n\tif (!Device)\n\t    goto out;\n\n\tSav = Device;\n\n\td = sav;\n\tswitch (control) {\n\tcase DEVICE_RESOLUTION:\n\t{\n\t    int *iptr, *iptr2;\n\t    xDeviceResolutionState *r;\n\t    XDeviceResolutionState *R;\n\t    unsigned int i;\n\n\t    r = (xDeviceResolutionState *) d;\n\t    R = (XDeviceResolutionState *) Device;\n\n\t    R->control = DEVICE_RESOLUTION;\n\t    R->length = sizeof(XDeviceResolutionState);\n\t    R->num_valuators = r->num_valuators;\n\t    iptr = (int *)(R + 1);\n\t    iptr2 = (int *)(r + 1);\n\t    R->resolutions = iptr;\n\t    R->min_resolutions = iptr + R->num_valuators;\n\t    R->max_resolutions = iptr + (2 * R->num_valuators);\n\t    for (i = 0; i < (3 * R->num_valuators); i++)\n\t\t*iptr++ = *iptr2++;\n\t    break;\n\t}\n        case DEVICE_ABS_CALIB:\n        {\n            xDeviceAbsCalibState *c = (xDeviceAbsCalibState *) d;\n            XDeviceAbsCalibState *C = (XDeviceAbsCalibState *) Device;\n\n            C->control = DEVICE_ABS_CALIB;\n            C->length = sizeof(XDeviceAbsCalibState);\n            C->min_x = c->min_x;\n            C->max_x = c->max_x;\n            C->min_y = c->min_y;\n            C->max_y = c->max_y;\n            C->flip_x = c->flip_x;\n            C->flip_y = c->flip_y;\n            C->rotation = c->rotation;\n            C->button_threshold = c->button_threshold;\n\n            break;\n        }\n        case DEVICE_ABS_AREA:\n        {\n            xDeviceAbsAreaState *a = (xDeviceAbsAreaState *) d;\n            XDeviceAbsAreaState *A = (XDeviceAbsAreaState *) Device;\n\n            A->control = DEVICE_ABS_AREA;\n            A->length = sizeof(XDeviceAbsAreaState);\n            A->offset_x = a->offset_x;\n            A->offset_y = a->offset_y;\n            A->width = a->width;\n            A->height = a->height;\n            A->screen = a->screen;\n            A->following = a->following;\n\n            break;\n        }\n        case DEVICE_CORE:\n        {\n            xDeviceCoreState *c = (xDeviceCoreState *) d;\n            XDeviceCoreState *C = (XDeviceCoreState *) Device;\n\n            C->control = DEVICE_CORE;\n            C->length = sizeof(XDeviceCoreState);\n            C->status = c->status;\n            C->iscore = c->iscore;\n\n            break;\n        }\n        case DEVICE_ENABLE:\n        {\n            xDeviceEnableState *e = (xDeviceEnableState *) d;\n            XDeviceEnableState *E = (XDeviceEnableState *) Device;\n\n            E->control = DEVICE_ENABLE;\n            E->length = sizeof(E);\n            E->enable = e->enable;\n\n            break;\n        }\n\tdefault:\n\t    break;\n\t}\n    }\n", "target": 1, "idx": 178090}
{"func": "void WebContentsImpl::OnDidDownloadImage(\n    int id,\n    int http_status_code,\n    const GURL& image_url,\n    int requested_size,\n    const std::vector<SkBitmap>& bitmaps) {\n  ImageDownloadMap::iterator iter = image_download_map_.find(id);\n  if (iter == image_download_map_.end()) {\n    return;\n  }\n  if (!iter->second.is_null()) {\n    iter->second.Run(id, http_status_code, image_url, requested_size, bitmaps);\n  }\n  image_download_map_.erase(id);\n}\n", "target": 0, "idx": 119852}
{"func": "static int start_decoder(vorb *f)\n{\n   uint8 header[6], x,y;\n   int len,i,j,k, max_submaps = 0;\n   int longest_floorlist=0;\n\n\n   if (!start_page(f))                              return FALSE;\n   if (!(f->page_flag & PAGEFLAG_first_page))       return error(f, VORBIS_invalid_first_page);\n   if (f->page_flag & PAGEFLAG_last_page)           return error(f, VORBIS_invalid_first_page);\n   if (f->page_flag & PAGEFLAG_continued_packet)    return error(f, VORBIS_invalid_first_page);\n   if (f->segment_count != 1)                       return error(f, VORBIS_invalid_first_page);\n   if (f->segments[0] != 30)                        return error(f, VORBIS_invalid_first_page);\n   if (get8(f) != VORBIS_packet_id)                 return error(f, VORBIS_invalid_first_page);\n   if (!getn(f, header, 6))                         return error(f, VORBIS_unexpected_eof);\n   if (!vorbis_validate(header))                    return error(f, VORBIS_invalid_first_page);\n   if (get32(f) != 0)                               return error(f, VORBIS_invalid_first_page);\n   f->channels = get8(f); if (!f->channels)         return error(f, VORBIS_invalid_first_page);\n   if (f->channels > STB_VORBIS_MAX_CHANNELS)       return error(f, VORBIS_too_many_channels);\n   f->sample_rate = get32(f); if (!f->sample_rate)  return error(f, VORBIS_invalid_first_page);\n   get32(f); // bitrate_maximum\n   get32(f); // bitrate_nominal\n   get32(f); // bitrate_minimum\n   x = get8(f);\n   {\n      int log0,log1;\n      log0 = x & 15;\n      log1 = x >> 4;\n      f->blocksize_0 = 1 << log0;\n      f->blocksize_1 = 1 << log1;\n      if (log0 < 6 || log0 > 13)                       return error(f, VORBIS_invalid_setup);\n      if (log1 < 6 || log1 > 13)                       return error(f, VORBIS_invalid_setup);\n      if (log0 > log1)                                 return error(f, VORBIS_invalid_setup);\n   }\n\n   x = get8(f);\n   if (!(x & 1))                                    return error(f, VORBIS_invalid_first_page);\n\n   if (!start_page(f))                              return FALSE;\n\n   if (!start_packet(f))                            return FALSE;\n   do {\n      len = next_segment(f);\n      skip(f, len);\n      f->bytes_in_seg = 0;\n   } while (len);\n\n   if (!start_packet(f))                            return FALSE;\n\n   #ifndef STB_VORBIS_NO_PUSHDATA_API\n   if (IS_PUSH_MODE(f)) {\n      if (!is_whole_packet_present(f, TRUE)) {\n         if (f->error == VORBIS_invalid_stream)\n            f->error = VORBIS_invalid_setup;\n         return FALSE;\n      }\n   }\n   #endif\n\n   crc32_init(); // always init it, to avoid multithread race conditions\n\n   if (get8_packet(f) != VORBIS_packet_setup)       return error(f, VORBIS_invalid_setup);\n   for (i=0; i < 6; ++i) header[i] = get8_packet(f);\n   if (!vorbis_validate(header))                    return error(f, VORBIS_invalid_setup);\n\n\n   f->codebook_count = get_bits(f,8) + 1;\n   f->codebooks = (Codebook *) setup_malloc(f, sizeof(*f->codebooks) * f->codebook_count);\n   if (f->codebooks == NULL)                        return error(f, VORBIS_outofmem);\n   memset(f->codebooks, 0, sizeof(*f->codebooks) * f->codebook_count);\n   for (i=0; i < f->codebook_count; ++i) {\n      uint32 *values;\n      int ordered, sorted_count;\n      int total=0;\n      uint8 *lengths;\n      Codebook *c = f->codebooks+i;\n      CHECK(f);\n      x = get_bits(f, 8); if (x != 0x42)            return error(f, VORBIS_invalid_setup);\n      x = get_bits(f, 8); if (x != 0x43)            return error(f, VORBIS_invalid_setup);\n      x = get_bits(f, 8); if (x != 0x56)            return error(f, VORBIS_invalid_setup);\n      x = get_bits(f, 8);\n      c->dimensions = (get_bits(f, 8)<<8) + x;\n      x = get_bits(f, 8);\n      y = get_bits(f, 8);\n      c->entries = (get_bits(f, 8)<<16) + (y<<8) + x;\n      ordered = get_bits(f,1);\n      c->sparse = ordered ? 0 : get_bits(f,1);\n\n      if (c->dimensions == 0 && c->entries != 0)    return error(f, VORBIS_invalid_setup);\n\n      if (c->sparse)\n         lengths = (uint8 *) setup_temp_malloc(f, c->entries);\n      else\n         lengths = c->codeword_lengths = (uint8 *) setup_malloc(f, c->entries);\n\n      if (!lengths) return error(f, VORBIS_outofmem);\n\n      if (ordered) {\n         int current_entry = 0;\n         int current_length = get_bits(f,5) + 1;\n         while (current_entry < c->entries) {\n            int limit = c->entries - current_entry;\n            int n = get_bits(f, ilog(limit));\n            if (current_entry + n > (int) c->entries) { return error(f, VORBIS_invalid_setup); }\n            memset(lengths + current_entry, current_length, n);\n            current_entry += n;\n            ++current_length;\n         }\n      } else {\n         for (j=0; j < c->entries; ++j) {\n            int present = c->sparse ? get_bits(f,1) : 1;\n            if (present) {\n               lengths[j] = get_bits(f, 5) + 1;\n               ++total;\n               if (lengths[j] == 32)\n                  return error(f, VORBIS_invalid_setup);\n            } else {\n               lengths[j] = NO_CODE;\n            }\n         }\n      }\n\n      if (c->sparse && total >= c->entries >> 2) {\n         if (c->entries > (int) f->setup_temp_memory_required)\n            f->setup_temp_memory_required = c->entries;\n\n         c->codeword_lengths = (uint8 *) setup_malloc(f, c->entries);\n         if (c->codeword_lengths == NULL) return error(f, VORBIS_outofmem);\n         memcpy(c->codeword_lengths, lengths, c->entries);\n         setup_temp_free(f, lengths, c->entries); // note this is only safe if there have been no intervening temp mallocs!\n         lengths = c->codeword_lengths;\n         c->sparse = 0;\n      }\n\n      if (c->sparse) {\n         sorted_count = total;\n      } else {\n         sorted_count = 0;\n         #ifndef STB_VORBIS_NO_HUFFMAN_BINARY_SEARCH\n         for (j=0; j < c->entries; ++j)\n            if (lengths[j] > STB_VORBIS_FAST_HUFFMAN_LENGTH && lengths[j] != NO_CODE)\n               ++sorted_count;\n         #endif\n      }\n\n      c->sorted_entries = sorted_count;\n      values = NULL;\n\n      CHECK(f);\n      if (!c->sparse) {\n         c->codewords = (uint32 *) setup_malloc(f, sizeof(c->codewords[0]) * c->entries);\n         if (!c->codewords)                  return error(f, VORBIS_outofmem);\n      } else {\n         unsigned int size;\n         if (c->sorted_entries) {\n            c->codeword_lengths = (uint8 *) setup_malloc(f, c->sorted_entries);\n            if (!c->codeword_lengths)           return error(f, VORBIS_outofmem);\n            c->codewords = (uint32 *) setup_temp_malloc(f, sizeof(*c->codewords) * c->sorted_entries);\n            if (!c->codewords)                  return error(f, VORBIS_outofmem);\n            values = (uint32 *) setup_temp_malloc(f, sizeof(*values) * c->sorted_entries);\n            if (!values)                        return error(f, VORBIS_outofmem);\n         }\n         size = c->entries + (sizeof(*c->codewords) + sizeof(*values)) * c->sorted_entries;\n         if (size > f->setup_temp_memory_required)\n            f->setup_temp_memory_required = size;\n      }\n\n      if (!compute_codewords(c, lengths, c->entries, values)) {\n         if (c->sparse) setup_temp_free(f, values, 0);\n         return error(f, VORBIS_invalid_setup);\n      }\n\n      if (c->sorted_entries) {\n         c->sorted_codewords = (uint32 *) setup_malloc(f, sizeof(*c->sorted_codewords) * (c->sorted_entries+1));\n         if (c->sorted_codewords == NULL) return error(f, VORBIS_outofmem);\n         c->sorted_values    = ( int   *) setup_malloc(f, sizeof(*c->sorted_values   ) * (c->sorted_entries+1));\n         if (c->sorted_values == NULL) return error(f, VORBIS_outofmem);\n         ++c->sorted_values;\n         c->sorted_values[-1] = -1;\n         compute_sorted_huffman(c, lengths, values);\n      }\n\n      if (c->sparse) {\n         setup_temp_free(f, values, sizeof(*values)*c->sorted_entries);\n         setup_temp_free(f, c->codewords, sizeof(*c->codewords)*c->sorted_entries);\n         setup_temp_free(f, lengths, c->entries);\n         c->codewords = NULL;\n      }\n\n      compute_accelerated_huffman(c);\n\n      CHECK(f);\n      c->lookup_type = get_bits(f, 4);\n      if (c->lookup_type > 2) return error(f, VORBIS_invalid_setup);\n      if (c->lookup_type > 0) {\n         uint16 *mults;\n         c->minimum_value = float32_unpack(get_bits(f, 32));\n         c->delta_value = float32_unpack(get_bits(f, 32));\n         c->value_bits = get_bits(f, 4)+1;\n         c->sequence_p = get_bits(f,1);\n         if (c->lookup_type == 1) {\n            c->lookup_values = lookup1_values(c->entries, c->dimensions);\n         } else {\n            c->lookup_values = c->entries * c->dimensions;\n         }\n         if (c->lookup_values == 0) return error(f, VORBIS_invalid_setup);\n         mults = (uint16 *) setup_temp_malloc(f, sizeof(mults[0]) * c->lookup_values);\n         if (mults == NULL) return error(f, VORBIS_outofmem);\n         for (j=0; j < (int) c->lookup_values; ++j) {\n            int q = get_bits(f, c->value_bits);\n            if (q == EOP) { setup_temp_free(f,mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_invalid_setup); }\n            mults[j] = q;\n         }\n\n#ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK\n         if (c->lookup_type == 1) {\n            int len, sparse = c->sparse;\n            float last=0;\n            if (sparse) {\n               if (c->sorted_entries == 0) goto skip;\n               c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->sorted_entries * c->dimensions);\n            } else\n               c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->entries        * c->dimensions);\n            if (c->multiplicands == NULL) { setup_temp_free(f,mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_outofmem); }\n            len = sparse ? c->sorted_entries : c->entries;\n            for (j=0; j < len; ++j) {\n               unsigned int z = sparse ? c->sorted_values[j] : j;\n               unsigned int div=1;\n               for (k=0; k < c->dimensions; ++k) {\n                  int off = (z / div) % c->lookup_values;\n                  float val = mults[off];\n                  val = mults[off]*c->delta_value + c->minimum_value + last;\n                  c->multiplicands[j*c->dimensions + k] = val;\n                  if (c->sequence_p)\n                     last = val;\n                  if (k+1 < c->dimensions) {\n                     if (div > UINT_MAX / (unsigned int) c->lookup_values) {\n                        setup_temp_free(f, mults,sizeof(mults[0])*c->lookup_values);\n                        return error(f, VORBIS_invalid_setup);\n                     }\n                     div *= c->lookup_values;\n                  }\n               }\n            }\n            c->lookup_type = 2;\n         }\n         else\n#endif\n         {\n            float last=0;\n            CHECK(f);\n            c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->lookup_values);\n            if (c->multiplicands == NULL) { setup_temp_free(f, mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_outofmem); }\n            for (j=0; j < (int) c->lookup_values; ++j) {\n               float val = mults[j] * c->delta_value + c->minimum_value + last;\n               c->multiplicands[j] = val;\n               if (c->sequence_p)\n                  last = val;\n            }\n         }\n#ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK\n        skip:;\n#endif\n         setup_temp_free(f, mults, sizeof(mults[0])*c->lookup_values);\n\n         CHECK(f);\n      }\n      CHECK(f);\n   }\n\n\n   x = get_bits(f, 6) + 1;\n   for (i=0; i < x; ++i) {\n      uint32 z = get_bits(f, 16);\n      if (z != 0) return error(f, VORBIS_invalid_setup);\n   }\n\n   f->floor_count = get_bits(f, 6)+1;\n   f->floor_config = (Floor *)  setup_malloc(f, f->floor_count * sizeof(*f->floor_config));\n   if (f->floor_config == NULL) return error(f, VORBIS_outofmem);\n   for (i=0; i < f->floor_count; ++i) {\n      f->floor_types[i] = get_bits(f, 16);\n      if (f->floor_types[i] > 1) return error(f, VORBIS_invalid_setup);\n      if (f->floor_types[i] == 0) {\n         Floor0 *g = &f->floor_config[i].floor0;\n         g->order = get_bits(f,8);\n         g->rate = get_bits(f,16);\n         g->bark_map_size = get_bits(f,16);\n         g->amplitude_bits = get_bits(f,6);\n         g->amplitude_offset = get_bits(f,8);\n         g->number_of_books = get_bits(f,4) + 1;\n         for (j=0; j < g->number_of_books; ++j)\n            g->book_list[j] = get_bits(f,8);\n         return error(f, VORBIS_feature_not_supported);\n      } else {\n         stbv__floor_ordering p[31*8+2];\n         Floor1 *g = &f->floor_config[i].floor1;\n         int max_class = -1; \n         g->partitions = get_bits(f, 5);\n         for (j=0; j < g->partitions; ++j) {\n            g->partition_class_list[j] = get_bits(f, 4);\n            if (g->partition_class_list[j] > max_class)\n               max_class = g->partition_class_list[j];\n         }\n         for (j=0; j <= max_class; ++j) {\n            g->class_dimensions[j] = get_bits(f, 3)+1;\n            g->class_subclasses[j] = get_bits(f, 2);\n            if (g->class_subclasses[j]) {\n               g->class_masterbooks[j] = get_bits(f, 8);\n               if (g->class_masterbooks[j] >= f->codebook_count) return error(f, VORBIS_invalid_setup);\n            }\n            for (k=0; k < 1 << g->class_subclasses[j]; ++k) {\n               g->subclass_books[j][k] = get_bits(f,8)-1;\n               if (g->subclass_books[j][k] >= f->codebook_count) return error(f, VORBIS_invalid_setup);\n            }\n         }\n         g->floor1_multiplier = get_bits(f,2)+1;\n         g->rangebits = get_bits(f,4);\n         g->Xlist[0] = 0;\n         g->Xlist[1] = 1 << g->rangebits;\n         g->values = 2;\n         for (j=0; j < g->partitions; ++j) {\n            int c = g->partition_class_list[j];\n            for (k=0; k < g->class_dimensions[c]; ++k) {\n               g->Xlist[g->values] = get_bits(f, g->rangebits);\n               ++g->values;\n            }\n         }\n         for (j=0; j < g->values; ++j) {\n            p[j].x = g->Xlist[j];\n            p[j].id = j;\n         }\n         qsort(p, g->values, sizeof(p[0]), point_compare);\n         for (j=0; j < g->values; ++j)\n            g->sorted_order[j] = (uint8) p[j].id;\n         for (j=2; j < g->values; ++j) {\n            int low,hi;\n            neighbors(g->Xlist, j, &low,&hi);\n            g->neighbors[j][0] = low;\n            g->neighbors[j][1] = hi;\n         }\n\n         if (g->values > longest_floorlist)\n            longest_floorlist = g->values;\n      }\n   }\n\n   f->residue_count = get_bits(f, 6)+1;\n   f->residue_config = (Residue *) setup_malloc(f, f->residue_count * sizeof(f->residue_config[0]));\n   if (f->residue_config == NULL) return error(f, VORBIS_outofmem);\n   memset(f->residue_config, 0, f->residue_count * sizeof(f->residue_config[0]));\n   for (i=0; i < f->residue_count; ++i) {\n      uint8 residue_cascade[64];\n      Residue *r = f->residue_config+i;\n      f->residue_types[i] = get_bits(f, 16);\n      if (f->residue_types[i] > 2) return error(f, VORBIS_invalid_setup);\n      r->begin = get_bits(f, 24);\n      r->end = get_bits(f, 24);\n      if (r->end < r->begin) return error(f, VORBIS_invalid_setup);\n      r->part_size = get_bits(f,24)+1;\n      r->classifications = get_bits(f,6)+1;\n      r->classbook = get_bits(f,8);\n      if (r->classbook >= f->codebook_count) return error(f, VORBIS_invalid_setup);\n      for (j=0; j < r->classifications; ++j) {\n         uint8 high_bits=0;\n         uint8 low_bits=get_bits(f,3);\n         if (get_bits(f,1))\n            high_bits = get_bits(f,5);\n         residue_cascade[j] = high_bits*8 + low_bits;\n      }\n      r->residue_books = (short (*)[8]) setup_malloc(f, sizeof(r->residue_books[0]) * r->classifications);\n      if (r->residue_books == NULL) return error(f, VORBIS_outofmem);\n      for (j=0; j < r->classifications; ++j) {\n         for (k=0; k < 8; ++k) {\n            if (residue_cascade[j] & (1 << k)) {\n               r->residue_books[j][k] = get_bits(f, 8);\n               if (r->residue_books[j][k] >= f->codebook_count) return error(f, VORBIS_invalid_setup);\n            } else {\n               r->residue_books[j][k] = -1;\n            }\n         }\n      }\n      r->classdata = (uint8 **) setup_malloc(f, sizeof(*r->classdata) * f->codebooks[r->classbook].entries);\n      if (!r->classdata) return error(f, VORBIS_outofmem);\n      memset(r->classdata, 0, sizeof(*r->classdata) * f->codebooks[r->classbook].entries);\n      for (j=0; j < f->codebooks[r->classbook].entries; ++j) {\n         int classwords = f->codebooks[r->classbook].dimensions;\n         int temp = j;\n         r->classdata[j] = (uint8 *) setup_malloc(f, sizeof(r->classdata[j][0]) * classwords);\n         if (r->classdata[j] == NULL) return error(f, VORBIS_outofmem);\n         for (k=classwords-1; k >= 0; --k) {\n            r->classdata[j][k] = temp % r->classifications;\n            temp /= r->classifications;\n         }\n      }\n   }\n\n   f->mapping_count = get_bits(f,6)+1;\n   f->mapping = (Mapping *) setup_malloc(f, f->mapping_count * sizeof(*f->mapping));\n   if (f->mapping == NULL) return error(f, VORBIS_outofmem);\n   memset(f->mapping, 0, f->mapping_count * sizeof(*f->mapping));\n   for (i=0; i < f->mapping_count; ++i) {\n      Mapping *m = f->mapping + i;      \n      int mapping_type = get_bits(f,16);\n      if (mapping_type != 0) return error(f, VORBIS_invalid_setup);\n      m->chan = (MappingChannel *) setup_malloc(f, f->channels * sizeof(*m->chan));\n      if (m->chan == NULL) return error(f, VORBIS_outofmem);\n      if (get_bits(f,1))\n         m->submaps = get_bits(f,4)+1;\n      else\n         m->submaps = 1;\n      if (m->submaps > max_submaps)\n         max_submaps = m->submaps;\n      if (get_bits(f,1)) {\n         m->coupling_steps = get_bits(f,8)+1;\n         for (k=0; k < m->coupling_steps; ++k) {\n            m->chan[k].magnitude = get_bits(f, ilog(f->channels-1));\n            m->chan[k].angle = get_bits(f, ilog(f->channels-1));\n            if (m->chan[k].magnitude >= f->channels)        return error(f, VORBIS_invalid_setup);\n            if (m->chan[k].angle     >= f->channels)        return error(f, VORBIS_invalid_setup);\n            if (m->chan[k].magnitude == m->chan[k].angle)   return error(f, VORBIS_invalid_setup);\n         }\n      } else\n         m->coupling_steps = 0;\n\n      if (get_bits(f,2)) return error(f, VORBIS_invalid_setup);\n      if (m->submaps > 1) {\n         for (j=0; j < f->channels; ++j) {\n            m->chan[j].mux = get_bits(f, 4);\n            if (m->chan[j].mux >= m->submaps)                return error(f, VORBIS_invalid_setup);\n         }\n      } else\n         for (j=0; j < f->channels; ++j)\n            m->chan[j].mux = 0;\n\n      for (j=0; j < m->submaps; ++j) {\n         get_bits(f,8); // discard\n         m->submap_floor[j] = get_bits(f,8);\n         m->submap_residue[j] = get_bits(f,8);\n         if (m->submap_floor[j] >= f->floor_count)      return error(f, VORBIS_invalid_setup);\n         if (m->submap_residue[j] >= f->residue_count)  return error(f, VORBIS_invalid_setup);\n      }\n   }\n\n   f->mode_count = get_bits(f, 6)+1;\n   for (i=0; i < f->mode_count; ++i) {\n      Mode *m = f->mode_config+i;\n      m->blockflag = get_bits(f,1);\n      m->windowtype = get_bits(f,16);\n      m->transformtype = get_bits(f,16);\n      m->mapping = get_bits(f,8);\n      if (m->windowtype != 0)                 return error(f, VORBIS_invalid_setup);\n      if (m->transformtype != 0)              return error(f, VORBIS_invalid_setup);\n      if (m->mapping >= f->mapping_count)     return error(f, VORBIS_invalid_setup);\n   }\n\n   flush_packet(f);\n\n   f->previous_length = 0;\n\n   for (i=0; i < f->channels; ++i) {\n      f->channel_buffers[i] = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1);\n      f->previous_window[i] = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1/2);\n      f->finalY[i]          = (int16 *) setup_malloc(f, sizeof(int16) * longest_floorlist);\n      if (f->channel_buffers[i] == NULL || f->previous_window[i] == NULL || f->finalY[i] == NULL) return error(f, VORBIS_outofmem);\n      #ifdef STB_VORBIS_NO_DEFER_FLOOR\n      f->floor_buffers[i]   = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1/2);\n      if (f->floor_buffers[i] == NULL) return error(f, VORBIS_outofmem);\n      #endif\n   }\n\n   if (!init_blocksize(f, 0, f->blocksize_0)) return FALSE;\n   if (!init_blocksize(f, 1, f->blocksize_1)) return FALSE;\n   f->blocksize[0] = f->blocksize_0;\n   f->blocksize[1] = f->blocksize_1;\n\n#ifdef STB_VORBIS_DIVIDE_TABLE\n   if (integer_divide_table[1][1]==0)\n      for (i=0; i < DIVTAB_NUMER; ++i)\n         for (j=1; j < DIVTAB_DENOM; ++j)\n            integer_divide_table[i][j] = i / j;\n#endif\n\n\n   {\n      uint32 imdct_mem = (f->blocksize_1 * sizeof(float) >> 1);\n      uint32 classify_mem;\n       int i,max_part_read=0;\n       for (i=0; i < f->residue_count; ++i) {\n          Residue *r = f->residue_config + i;\n         int n_read = r->end - r->begin;\n          int part_read = n_read / r->part_size;\n          if (part_read > max_part_read)\n             max_part_read = part_read;\n      }\n      #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n      classify_mem = f->channels * (sizeof(void*) + max_part_read * sizeof(uint8 *));\n      #else\n       classify_mem = f->channels * (sizeof(void*) + max_part_read * sizeof(int *));\n       #endif\n \n       f->temp_memory_required = classify_mem;\n       if (imdct_mem > f->temp_memory_required)\n          f->temp_memory_required = imdct_mem;\n   }\n\n   f->first_decode = TRUE;\n\n   if (f->alloc.alloc_buffer) {\n      assert(f->temp_offset == f->alloc.alloc_buffer_length_in_bytes);\n      if (f->setup_offset + sizeof(*f) + f->temp_memory_required > (unsigned) f->temp_offset)\n         return error(f, VORBIS_outofmem);\n   }\n\n   f->first_audio_page_offset = stb_vorbis_get_file_offset(f);\n\n   return TRUE;\n}\n", "target": 1, "idx": 182117}
{"func": "OMX_ERRORTYPE omx_vdec::set_buffer_req(vdec_allocatorproperty *buffer_prop)\n{\n    OMX_ERRORTYPE eRet = OMX_ErrorNone;\n unsigned buf_size = 0;\n struct v4l2_format fmt;\n struct v4l2_requestbuffers bufreq;\n int ret;\n    DEBUG_PRINT_LOW(\"SetBufReq IN: ActCnt(%d) Size(%u)\",\n            buffer_prop->actualcount, (unsigned int)buffer_prop->buffer_size);\n    buf_size = (buffer_prop->buffer_size + buffer_prop->alignment - 1)&(~(buffer_prop->alignment - 1));\n if (buf_size != buffer_prop->buffer_size) {\n        DEBUG_PRINT_ERROR(\"Buffer size alignment error: Requested(%u) Required(%d)\",\n (unsigned int)buffer_prop->buffer_size, buf_size);\n        eRet = OMX_ErrorBadParameter;\n } else {\n        memset(&fmt, 0x0, sizeof(struct v4l2_format));\n        fmt.fmt.pix_mp.height = drv_ctx.video_resolution.frame_height;\n        fmt.fmt.pix_mp.width = drv_ctx.video_resolution.frame_width;\n\n if (buffer_prop->buffer_type == VDEC_BUFFER_TYPE_INPUT) {\n            fmt.type =V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\n            fmt.fmt.pix_mp.pixelformat = output_capability;\n            fmt.fmt.pix_mp.plane_fmt[0].sizeimage = buf_size;\n } else if (buffer_prop->buffer_type == VDEC_BUFFER_TYPE_OUTPUT) {\n            fmt.type =V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n            fmt.fmt.pix_mp.pixelformat = capture_capability;\n } else {\n            eRet = OMX_ErrorBadParameter;\n }\n\n        ret = ioctl(drv_ctx.video_driver_fd, VIDIOC_S_FMT, &fmt);\n if (ret) {\n /*TODO: How to handle this case */\n            DEBUG_PRINT_ERROR(\"Setting buffer requirements (format) failed %d\", ret);\n            eRet = OMX_ErrorInsufficientResources;\n }\n\n        bufreq.memory = V4L2_MEMORY_USERPTR;\n        bufreq.count = buffer_prop->actualcount;\n if (buffer_prop->buffer_type == VDEC_BUFFER_TYPE_INPUT) {\n            bufreq.type=V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\n } else if (buffer_prop->buffer_type == VDEC_BUFFER_TYPE_OUTPUT) {\n            bufreq.type=V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n } else {\n            eRet = OMX_ErrorBadParameter;\n }\n\n if (eRet==OMX_ErrorNone) {\n            ret = ioctl(drv_ctx.video_driver_fd,VIDIOC_REQBUFS, &bufreq);\n }\n\n if (ret) {\n            DEBUG_PRINT_ERROR(\"Setting buffer requirements (reqbufs) failed %d\", ret);\n /*TODO: How to handle this case */\n            eRet = OMX_ErrorInsufficientResources;\n } else if (bufreq.count < buffer_prop->actualcount) {\n            DEBUG_PRINT_ERROR(\"Driver refused to change the number of buffers\"\n \" on v4l2 port %d to %d (prefers %d)\", bufreq.type,\n                    buffer_prop->actualcount, bufreq.count);\n            eRet = OMX_ErrorInsufficientResources;\n } else {\n if (!client_buffers.update_buffer_req()) {\n                DEBUG_PRINT_ERROR(\"Setting c2D buffer requirements failed\");\n                eRet = OMX_ErrorInsufficientResources;\n }\n }\n }\n return eRet;\n}\n", "target": 0, "idx": 173496}
{"func": " parse_rock_ridge_inode_internal(struct iso_directory_record *de,\n\t\t\t\tstruct inode *inode, int regard_xa)\n {\n \tint symlink_len = 0;\n \tint cnt, sig;\n \tstruct inode *reloc;\n \tstruct rock_ridge *rr;\n \tint rootflag;\n\tstruct rock_state rs;\n\tint ret = 0;\n\n\tif (!ISOFS_SB(inode->i_sb)->s_rock)\n\t\treturn 0;\n \n \tinit_rock_state(&rs, inode);\n \tsetup_rock_ridge(de, inode, &rs);\n\tif (regard_xa) {\n \t\trs.chr += 14;\n \t\trs.len -= 14;\n \t\tif (rs.len < 0)\n\t\t\trs.len = 0;\n\t}\n\nrepeat:\n\twhile (rs.len > 2) { /* There may be one byte for padding somewhere */\n\t\trr = (struct rock_ridge *)rs.chr;\n\t\t/*\n\t\t * Ignore rock ridge info if rr->len is out of range, but\n\t\t * don't return -EIO because that would make the file\n\t\t * invisible.\n\t\t */\n\t\tif (rr->len < 3)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\t\tsig = isonum_721(rs.chr);\n\t\tif (rock_check_overflow(&rs, sig))\n\t\t\tgoto eio;\n\t\trs.chr += rr->len;\n\t\trs.len -= rr->len;\n\t\t/*\n\t\t * As above, just ignore the rock ridge info if rr->len\n\t\t * is bogus.\n\t\t */\n\t\tif (rs.len < 0)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\n\t\tswitch (sig) {\n#ifndef CONFIG_ZISOFS\t\t/* No flag for SF or ZF */\n\t\tcase SIG('R', 'R'):\n\t\t\tif ((rr->u.RR.flags[0] &\n\t\t\t     (RR_PX | RR_TF | RR_SL | RR_CL)) == 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n#endif\n\t\tcase SIG('S', 'P'):\n\t\t\tif (check_sp(rr, inode))\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('C', 'E'):\n\t\t\trs.cont_extent = isonum_733(rr->u.CE.extent);\n\t\t\trs.cont_offset = isonum_733(rr->u.CE.offset);\n\t\t\trs.cont_size = isonum_733(rr->u.CE.size);\n\t\t\tbreak;\n\t\tcase SIG('E', 'R'):\n\t\t\tISOFS_SB(inode->i_sb)->s_rock = 1;\n\t\t\tprintk(KERN_DEBUG \"ISO 9660 Extensions: \");\n\t\t\t{\n\t\t\t\tint p;\n\t\t\t\tfor (p = 0; p < rr->u.ER.len_id; p++)\n\t\t\t\t\tprintk(\"%c\", rr->u.ER.data[p]);\n\t\t\t}\n\t\t\tprintk(\"\\n\");\n\t\t\tbreak;\n\t\tcase SIG('P', 'X'):\n\t\t\tinode->i_mode = isonum_733(rr->u.PX.mode);\n\t\t\tset_nlink(inode, isonum_733(rr->u.PX.n_links));\n\t\t\ti_uid_write(inode, isonum_733(rr->u.PX.uid));\n\t\t\ti_gid_write(inode, isonum_733(rr->u.PX.gid));\n\t\t\tbreak;\n\t\tcase SIG('P', 'N'):\n\t\t\t{\n\t\t\t\tint high, low;\n\t\t\t\thigh = isonum_733(rr->u.PN.dev_high);\n\t\t\t\tlow = isonum_733(rr->u.PN.dev_low);\n\t\t\t\t/*\n\t\t\t\t * The Rock Ridge standard specifies that if\n\t\t\t\t * sizeof(dev_t) <= 4, then the high field is\n\t\t\t\t * unused, and the device number is completely\n\t\t\t\t * stored in the low field.  Some writers may\n\t\t\t\t * ignore this subtlety,\n\t\t\t\t * and as a result we test to see if the entire\n\t\t\t\t * device number is\n\t\t\t\t * stored in the low field, and use that.\n\t\t\t\t */\n\t\t\t\tif ((low & ~0xff) && high == 0) {\n\t\t\t\t\tinode->i_rdev =\n\t\t\t\t\t    MKDEV(low >> 8, low & 0xff);\n\t\t\t\t} else {\n\t\t\t\t\tinode->i_rdev =\n\t\t\t\t\t    MKDEV(high, low);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SIG('T', 'F'):\n\t\t\t/*\n\t\t\t * Some RRIP writers incorrectly place ctime in the\n\t\t\t * TF_CREATE field. Try to handle this correctly for\n\t\t\t * either case.\n\t\t\t */\n\t\t\t/* Rock ridge never appears on a High Sierra disk */\n\t\t\tcnt = 0;\n\t\t\tif (rr->u.TF.flags & TF_CREATE) {\n\t\t\t\tinode->i_ctime.tv_sec =\n\t\t\t\t    iso_date(rr->u.TF.times[cnt++].time,\n\t\t\t\t\t     0);\n\t\t\t\tinode->i_ctime.tv_nsec = 0;\n\t\t\t}\n\t\t\tif (rr->u.TF.flags & TF_MODIFY) {\n\t\t\t\tinode->i_mtime.tv_sec =\n\t\t\t\t    iso_date(rr->u.TF.times[cnt++].time,\n\t\t\t\t\t     0);\n\t\t\t\tinode->i_mtime.tv_nsec = 0;\n\t\t\t}\n\t\t\tif (rr->u.TF.flags & TF_ACCESS) {\n\t\t\t\tinode->i_atime.tv_sec =\n\t\t\t\t    iso_date(rr->u.TF.times[cnt++].time,\n\t\t\t\t\t     0);\n\t\t\t\tinode->i_atime.tv_nsec = 0;\n\t\t\t}\n\t\t\tif (rr->u.TF.flags & TF_ATTRIBUTES) {\n\t\t\t\tinode->i_ctime.tv_sec =\n\t\t\t\t    iso_date(rr->u.TF.times[cnt++].time,\n\t\t\t\t\t     0);\n\t\t\t\tinode->i_ctime.tv_nsec = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SIG('S', 'L'):\n\t\t\t{\n\t\t\t\tint slen;\n\t\t\t\tstruct SL_component *slp;\n\t\t\t\tstruct SL_component *oldslp;\n\t\t\t\tslen = rr->len - 5;\n\t\t\t\tslp = &rr->u.SL.link;\n\t\t\t\tinode->i_size = symlink_len;\n\t\t\t\twhile (slen > 1) {\n\t\t\t\t\trootflag = 0;\n\t\t\t\t\tswitch (slp->flags & ~1) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tinode->i_size +=\n\t\t\t\t\t\t    slp->len;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tinode->i_size += 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tinode->i_size += 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 8:\n\t\t\t\t\t\trootflag = 1;\n\t\t\t\t\t\tinode->i_size += 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tprintk(\"Symlink component flag \"\n\t\t\t\t\t\t\t\"not implemented\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tslen -= slp->len + 2;\n\t\t\t\t\toldslp = slp;\n\t\t\t\t\tslp = (struct SL_component *)\n\t\t\t\t\t\t(((char *)slp) + slp->len + 2);\n\n\t\t\t\t\tif (slen < 2) {\n\t\t\t\t\t\tif (((rr->u.SL.\n\t\t\t\t\t\t      flags & 1) != 0)\n\t\t\t\t\t\t    &&\n\t\t\t\t\t\t    ((oldslp->\n\t\t\t\t\t\t      flags & 1) == 0))\n\t\t\t\t\t\t\tinode->i_size +=\n\t\t\t\t\t\t\t    1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * If this component record isn't\n\t\t\t\t\t * continued, then append a '/'.\n\t\t\t\t\t */\n\t\t\t\t\tif (!rootflag\n\t\t\t\t\t    && (oldslp->flags & 1) == 0)\n\t\t\t\t\t\tinode->i_size += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsymlink_len = inode->i_size;\n\t\t\tbreak;\n\t\tcase SIG('R', 'E'):\n\t\t\tprintk(KERN_WARNING \"Attempt to read inode for \"\n \t\t\t\t\t\"relocated directory\\n\");\n \t\t\tgoto out;\n \t\tcase SIG('C', 'L'):\n\t\t\tISOFS_I(inode)->i_first_extent =\n\t\t\t    isonum_733(rr->u.CL.location);\n\t\t\treloc =\n\t\t\t    isofs_iget(inode->i_sb,\n\t\t\t\t       ISOFS_I(inode)->i_first_extent,\n\t\t\t\t       0);\n \t\t\tif (IS_ERR(reloc)) {\n \t\t\t\tret = PTR_ERR(reloc);\n \t\t\t\tgoto out;\n\t\t\t}\n\t\t\tinode->i_mode = reloc->i_mode;\n\t\t\tset_nlink(inode, reloc->i_nlink);\n\t\t\tinode->i_uid = reloc->i_uid;\n\t\t\tinode->i_gid = reloc->i_gid;\n\t\t\tinode->i_rdev = reloc->i_rdev;\n\t\t\tinode->i_size = reloc->i_size;\n\t\t\tinode->i_blocks = reloc->i_blocks;\n\t\t\tinode->i_atime = reloc->i_atime;\n\t\t\tinode->i_ctime = reloc->i_ctime;\n\t\t\tinode->i_mtime = reloc->i_mtime;\n\t\t\tiput(reloc);\n\t\t\tbreak;\n#ifdef CONFIG_ZISOFS\n\t\tcase SIG('Z', 'F'): {\n\t\t\tint algo;\n\n\t\t\tif (ISOFS_SB(inode->i_sb)->s_nocompress)\n\t\t\t\tbreak;\n\t\t\talgo = isonum_721(rr->u.ZF.algorithm);\n\t\t\tif (algo == SIG('p', 'z')) {\n\t\t\t\tint block_shift =\n\t\t\t\t\tisonum_711(&rr->u.ZF.parms[1]);\n\t\t\t\tif (block_shift > 17) {\n\t\t\t\t\tprintk(KERN_WARNING \"isofs: \"\n\t\t\t\t\t\t\"Can't handle ZF block \"\n\t\t\t\t\t\t\"size of 2^%d\\n\",\n\t\t\t\t\t\tblock_shift);\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t * Note: we don't change\n\t\t\t\t\t * i_blocks here\n\t\t\t\t\t */\n\t\t\t\t\tISOFS_I(inode)->i_file_format =\n\t\t\t\t\t\tisofs_file_compressed;\n\t\t\t\t\t/*\n\t\t\t\t\t * Parameters to compression\n\t\t\t\t\t * algorithm (header size,\n\t\t\t\t\t * block size)\n\t\t\t\t\t */\n\t\t\t\t\tISOFS_I(inode)->i_format_parm[0] =\n\t\t\t\t\t\tisonum_711(&rr->u.ZF.parms[0]);\n\t\t\t\t\tISOFS_I(inode)->i_format_parm[1] =\n\t\t\t\t\t\tisonum_711(&rr->u.ZF.parms[1]);\n\t\t\t\t\tinode->i_size =\n\t\t\t\t\t    isonum_733(rr->u.ZF.\n\t\t\t\t\t\t       real_size);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t       \"isofs: Unknown ZF compression \"\n\t\t\t\t\t\t\"algorithm: %c%c\\n\",\n\t\t\t\t       rr->u.ZF.algorithm[0],\n\t\t\t\t       rr->u.ZF.algorithm[1]);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tret = rock_continue(&rs);\n\tif (ret == 0)\n\t\tgoto repeat;\n\tif (ret == 1)\n\t\tret = 0;\nout:\n\tkfree(rs.buffer);\n\treturn ret;\neio:\n\tret = -EIO;\n\tgoto out;\n}\n", "target": 1, "idx": 179443}
{"func": "void Segment::PreloadCluster(Cluster* pCluster, ptrdiff_t idx)\n{\n    assert(pCluster);\n    assert(pCluster->m_index < 0);\n    assert(idx >= m_clusterCount);\n    const long count = m_clusterCount + m_clusterPreloadCount;\n    long& size = m_clusterSize;\n    assert(size >= count);\n    if (count >= size)\n    {\n        const long n = (size <= 0) ? 2048 : 2*size;\n        Cluster** const qq = new Cluster*[n];\n        Cluster** q = qq;\n        Cluster** p = m_clusters;\n        Cluster** const pp = p + count;\n        while (p != pp)\n            *q++ = *p++;\n        delete[] m_clusters;\n        m_clusters = qq;\n        size = n;\n    }\n     assert(m_clusters);\n \n    Cluster** const p = m_clusters + idx;\n \n    Cluster** q = m_clusters + count;\n    assert(q >= p);\n     assert(q < (m_clusters + size));\n \n    while (q > p)\n    {\n        Cluster** const qq = q - 1;\n        assert((*qq)->m_index < 0);\n \n        *q = *qq;\n        q = qq;\n     }\n \n    m_clusters[idx] = pCluster;\n    ++m_clusterPreloadCount;\n }\n", "target": 1, "idx": 188453}
{"func": "static int sd_ioctl(struct block_device *bdev, fmode_t mode,\n\t\t    unsigned int cmd, unsigned long arg)\n{\n\tstruct gendisk *disk = bdev->bd_disk;\n\tstruct scsi_disk *sdkp = scsi_disk(disk);\n\tstruct scsi_device *sdp = sdkp->device;\n\tvoid __user *p = (void __user *)arg;\n\tint error;\n    \n \tSCSI_LOG_IOCTL(1, sd_printk(KERN_INFO, sdkp, \"sd_ioctl: disk=%s, \"\n \t\t\t\t    \"cmd=0x%x\\n\", disk->disk_name, cmd));\n \n \t/*\n \t * If we are in the middle of error recovery, don't let anyone\n \t * else try and use this device.  Also, if error recovery fails, it\n\t * may try and take the device offline, in which case all further\n\t * access to the device is prohibited.\n\t */\n\terror = scsi_nonblockable_ioctl(sdp, cmd, p,\n\t\t\t\t\t(mode & FMODE_NDELAY) != 0);\n\tif (!scsi_block_when_processing_errors(sdp) || !error)\n\t\tgoto out;\n\n\t/*\n\t * Send SCSI addressing ioctls directly to mid level, send other\n\t * ioctls to block level and then onto mid level if they can't be\n\t * resolved.\n\t */\n\tswitch (cmd) {\n\t\tcase SCSI_IOCTL_GET_IDLUN:\n\t\tcase SCSI_IOCTL_GET_BUS_NUMBER:\n\t\t\terror = scsi_ioctl(sdp, cmd, p);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror = scsi_cmd_blk_ioctl(bdev, mode, cmd, p);\n\t\t\tif (error != -ENOTTY)\n\t\t\t\tbreak;\n\t\t\terror = scsi_ioctl(sdp, cmd, p);\n\t\t\tbreak;\n\t}\nout:\n\treturn error;\n}\n", "target": 1, "idx": 183063}
{"func": "AtomicString GetInputModeAttribute(Element* element) {\n  if (!element)\n    return AtomicString();\n\n  bool query_attribute = false;\n  if (isHTMLInputElement(*element)) {\n    query_attribute = toHTMLInputElement(*element).SupportsInputModeAttribute();\n  } else if (isHTMLTextAreaElement(*element)) {\n    query_attribute = true;\n  } else {\n    element->GetDocument().UpdateStyleAndLayoutTree();\n    if (HasEditableStyle(*element))\n      query_attribute = true;\n  }\n\n  if (!query_attribute)\n    return AtomicString();\n\n  return element->FastGetAttribute(HTMLNames::inputmodeAttr).DeprecatedLower();\n}\n", "target": 0, "idx": 135743}
{"func": "void HTMLMediaElement::setPlaybackRate(double rate,\n                                       ExceptionState& exception_state) {\n  BLINK_MEDIA_LOG << \"setPlaybackRate(\" << (void*)this << \", \" << rate << \")\";\n  if (GetLoadType() == WebMediaPlayer::kLoadTypeMediaStream)\n    return;\n\n  if (rate != 0.0 && (rate < kMinRate || rate > kMaxRate)) {\n    UseCounter::Count(GetDocument(),\n                      WebFeature::kHTMLMediaElementMediaPlaybackRateOutOfRange);\n\n    exception_state.ThrowDOMException(\n        DOMExceptionCode::kNotSupportedError,\n        \"The provided playback rate (\" + String::Number(rate) +\n            \") is not in the \" + \"supported playback range.\");\n\n    return;\n  }\n\n  if (playback_rate_ != rate) {\n    playback_rate_ = rate;\n    ScheduleEvent(event_type_names::kRatechange);\n  }\n\n  UpdatePlaybackRate();\n}\n", "target": 0, "idx": 142970}
{"func": " void PrintWebViewHelper::OnPrintForSystemDialog() {\n   blink::WebLocalFrame* frame = print_preview_context_.source_frame();\n   if (!frame) {\n     NOTREACHED();\n    return;\n  }\n  Print(frame, print_preview_context_.source_node(), false);\n}\n", "target": 1, "idx": 185752}
{"func": " static void ieee80211_if_setup(struct net_device *dev)\n {\n \tether_setup(dev);\n \tdev->netdev_ops = &ieee80211_dataif_ops;\n \tdev->destructor = free_netdev;\n }\n", "target": 1, "idx": 178911}
{"func": "static void RelinquishZIPMemory(voidpf context,voidpf memory)\n{\n  (void) context;\n  memory=RelinquishMagickMemory(memory);\n}\n", "target": 0, "idx": 62094}
{"func": "compile_bag_node(BagNode* node, regex_t* reg, ScanEnv* env)\n{\n  int r, len;\n\n  switch (node->type) {\n  case BAG_MEMORY:\n    r = compile_bag_memory_node(node, reg, env);\n    break;\n\n  case BAG_OPTION:\n    r = compile_option_node(node, reg, env);\n    break;\n\n  case BAG_STOP_BACKTRACK:\n    if (NODE_IS_STOP_BT_SIMPLE_REPEAT(node)) {\n      QuantNode* qn = QUANT_(NODE_BAG_BODY(node));\n      r = compile_tree_n_times(NODE_QUANT_BODY(qn), qn->lower, reg, env);\n      if (r != 0) return r;\n\n      len = compile_length_tree(NODE_QUANT_BODY(qn), reg);\n      if (len < 0) return len;\n\n      r = add_op(reg, OP_PUSH);\n      if (r != 0) return r;\n      COP(reg)->push.addr = SIZE_INC_OP + len + SIZE_OP_POP_OUT + SIZE_OP_JUMP;\n\n      r = compile_tree(NODE_QUANT_BODY(qn), reg, env);\n      if (r != 0) return r;\n      r = add_op(reg, OP_POP_OUT);\n      if (r != 0) return r;\n\n      r = add_op(reg, OP_JUMP);\n      if (r != 0) return r;\n      COP(reg)->jump.addr = -((int )SIZE_OP_PUSH + len + (int )SIZE_OP_POP_OUT);\n    }\n    else {\n      r = add_op(reg, OP_ATOMIC_START);\n      if (r != 0) return r;\n      r = compile_tree(NODE_BAG_BODY(node), reg, env);\n      if (r != 0) return r;\n      r = add_op(reg, OP_ATOMIC_END);\n    }\n    break;\n \n   case BAG_IF_ELSE:\n     {\n      int cond_len, then_len, jump_len;\n       Node* cond = NODE_BAG_BODY(node);\n       Node* Then = node->te.Then;\n       Node* Else = node->te.Else;\n\n      r = add_op(reg, OP_ATOMIC_START);\n      if (r != 0) return r;\n\n      cond_len = compile_length_tree(cond, reg);\n      if (cond_len < 0) return cond_len;\n      if (IS_NOT_NULL(Then)) {\n        then_len = compile_length_tree(Then, reg);\n        if (then_len < 0) return then_len;\n      }\n       else\n         then_len = 0;\n \n      jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END;\n      if (IS_NOT_NULL(Else)) jump_len += SIZE_OP_JUMP;\n \n       r = add_op(reg, OP_PUSH);\n       if (r != 0) return r;\n      COP(reg)->push.addr = SIZE_INC_OP + jump_len;\n\n      r = compile_tree(cond, reg, env);\n      if (r != 0) return r;\n      r = add_op(reg, OP_ATOMIC_END);\n      if (r != 0) return r;\n\n      if (IS_NOT_NULL(Then)) {\n        r = compile_tree(Then, reg, env);\n        if (r != 0) return r;\n       }\n \n       if (IS_NOT_NULL(Else)) {\n        int else_len = compile_length_tree(Else, reg);\n        r = add_op(reg, OP_JUMP);\n        if (r != 0) return r;\n        COP(reg)->jump.addr = else_len + SIZE_INC_OP;\n \n         r = compile_tree(Else, reg, env);\n       }\n     }\n    break;\n  }\n\n  return r;\n}\n", "target": 1, "idx": 182783}
{"func": "static int sapi_fcgi_read_post(char *buffer, uint count_bytes TSRMLS_DC)\n{\n\tuint read_bytes = 0;\n\tint tmp_read_bytes;\n\tfcgi_request *request = (fcgi_request*) SG(server_context);\n\n\tcount_bytes = MIN(count_bytes, (uint) SG(request_info).content_length - SG(read_post_bytes));\n\twhile (read_bytes < count_bytes) {\n\t\ttmp_read_bytes = fcgi_read(request, buffer + read_bytes, count_bytes - read_bytes);\n\t\tif (tmp_read_bytes <= 0) {\n\t\t\tbreak;\n\t\t}\n\t\tread_bytes += tmp_read_bytes;\n\t}\n\treturn read_bytes;\n}\n", "target": 0, "idx": 7274}
{"func": "NaClProcessHost::NaClProcessHost(const GURL& manifest_url, bool off_the_record)\n    : manifest_url_(manifest_url),\n#if defined(OS_WIN)\n      process_launched_by_broker_(false),\n#elif defined(OS_LINUX)\n      wait_for_nacl_gdb_(false),\n#endif\n      reply_msg_(NULL),\n#if defined(OS_WIN)\n      debug_exception_handler_requested_(false),\n#endif\n      internal_(new NaClInternal()),\n      ALLOW_THIS_IN_INITIALIZER_LIST(weak_factory_(this)),\n      enable_exception_handling_(false),\n      off_the_record_(off_the_record) {\n  process_.reset(content::BrowserChildProcessHost::Create(\n      content::PROCESS_TYPE_NACL_LOADER, this));\n\n  process_->SetName(net::FormatUrl(manifest_url_, std::string()));\n\n  if (CommandLine::ForCurrentProcess()->HasSwitch(\n          switches::kEnableNaClExceptionHandling) ||\n       getenv(\"NACL_UNTRUSTED_EXCEPTION_HANDLING\") != NULL) {\n     enable_exception_handling_ = true;\n   }\n  enable_ipc_proxy_ = CommandLine::ForCurrentProcess()->HasSwitch(\n      switches::kEnableNaClIPCProxy);\n }\n", "target": 1, "idx": 184298}
{"func": "static void sctp_sock_migrate(struct sock *oldsk, struct sock *newsk,\n\t\t\t      struct sctp_association *assoc,\n\t\t\t      sctp_socket_type_t type)\n{\n\tstruct sctp_sock *oldsp = sctp_sk(oldsk);\n\tstruct sctp_sock *newsp = sctp_sk(newsk);\n\tstruct sctp_bind_bucket *pp; /* hash list port iterator */\n\tstruct sctp_endpoint *newep = newsp->ep;\n \tstruct sk_buff *skb, *tmp;\n \tstruct sctp_ulpevent *event;\n \tstruct sctp_bind_hashbucket *head;\n\tstruct list_head tmplist;\n \n \t/* Migrate socket buffer sizes and all the socket level options to the\n \t * new socket.\n \t */\n \tnewsk->sk_sndbuf = oldsk->sk_sndbuf;\n \tnewsk->sk_rcvbuf = oldsk->sk_rcvbuf;\n \t/* Brute force copy old sctp opt. */\n\tif (oldsp->do_auto_asconf) {\n\t\tmemcpy(&tmplist, &newsp->auto_asconf_list, sizeof(tmplist));\n\t\tinet_sk_copy_descendant(newsk, oldsk);\n\t\tmemcpy(&newsp->auto_asconf_list, &tmplist, sizeof(tmplist));\n\t} else\n\t\tinet_sk_copy_descendant(newsk, oldsk);\n \n \t/* Restore the ep value that was overwritten with the above structure\n \t * copy.\n\t */\n\tnewsp->ep = newep;\n\tnewsp->hmac = NULL;\n\n\t/* Hook this new socket in to the bind_hash list. */\n\thead = &sctp_port_hashtable[sctp_phashfn(sock_net(oldsk),\n\t\t\t\t\t\t inet_sk(oldsk)->inet_num)];\n\tlocal_bh_disable();\n\tspin_lock(&head->lock);\n\tpp = sctp_sk(oldsk)->bind_hash;\n\tsk_add_bind_node(newsk, &pp->owner);\n\tsctp_sk(newsk)->bind_hash = pp;\n\tinet_sk(newsk)->inet_num = inet_sk(oldsk)->inet_num;\n\tspin_unlock(&head->lock);\n\tlocal_bh_enable();\n\n\t/* Copy the bind_addr list from the original endpoint to the new\n\t * endpoint so that we can handle restarts properly\n\t */\n\tsctp_bind_addr_dup(&newsp->ep->base.bind_addr,\n\t\t\t\t&oldsp->ep->base.bind_addr, GFP_KERNEL);\n\n\t/* Move any messages in the old socket's receive queue that are for the\n\t * peeled off association to the new socket's receive queue.\n\t */\n\tsctp_skb_for_each(skb, &oldsk->sk_receive_queue, tmp) {\n\t\tevent = sctp_skb2event(skb);\n\t\tif (event->asoc == assoc) {\n\t\t\t__skb_unlink(skb, &oldsk->sk_receive_queue);\n\t\t\t__skb_queue_tail(&newsk->sk_receive_queue, skb);\n\t\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n\t\t}\n\t}\n\n\t/* Clean up any messages pending delivery due to partial\n\t * delivery.   Three cases:\n\t * 1) No partial deliver;  no work.\n\t * 2) Peeling off partial delivery; keep pd_lobby in new pd_lobby.\n\t * 3) Peeling off non-partial delivery; move pd_lobby to receive_queue.\n\t */\n\tskb_queue_head_init(&newsp->pd_lobby);\n\tatomic_set(&sctp_sk(newsk)->pd_mode, assoc->ulpq.pd_mode);\n\n\tif (atomic_read(&sctp_sk(oldsk)->pd_mode)) {\n\t\tstruct sk_buff_head *queue;\n\n\t\t/* Decide which queue to move pd_lobby skbs to. */\n\t\tif (assoc->ulpq.pd_mode) {\n\t\t\tqueue = &newsp->pd_lobby;\n\t\t} else\n\t\t\tqueue = &newsk->sk_receive_queue;\n\n\t\t/* Walk through the pd_lobby, looking for skbs that\n\t\t * need moved to the new socket.\n\t\t */\n\t\tsctp_skb_for_each(skb, &oldsp->pd_lobby, tmp) {\n\t\t\tevent = sctp_skb2event(skb);\n\t\t\tif (event->asoc == assoc) {\n\t\t\t\t__skb_unlink(skb, &oldsp->pd_lobby);\n\t\t\t\t__skb_queue_tail(queue, skb);\n\t\t\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n\t\t\t}\n\t\t}\n\n\t\t/* Clear up any skbs waiting for the partial\n\t\t * delivery to finish.\n\t\t */\n\t\tif (assoc->ulpq.pd_mode)\n\t\t\tsctp_clear_pd(oldsk, NULL);\n\n\t}\n\n\tsctp_skb_for_each(skb, &assoc->ulpq.reasm, tmp)\n\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n\n\tsctp_skb_for_each(skb, &assoc->ulpq.lobby, tmp)\n\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n\n\t/* Set the type of socket to indicate that it is peeled off from the\n\t * original UDP-style socket or created with the accept() call on a\n\t * TCP-style socket..\n\t */\n\tnewsp->type = type;\n\n\t/* Mark the new socket \"in-use\" by the user so that any packets\n\t * that may arrive on the association after we've moved it are\n\t * queued to the backlog.  This prevents a potential race between\n\t * backlog processing on the old socket and new-packet processing\n\t * on the new socket.\n\t *\n\t * The caller has just allocated newsk so we can guarantee that other\n\t * paths won't try to lock it and then oldsk.\n\t */\n\tlock_sock_nested(newsk, SINGLE_DEPTH_NESTING);\n\tsctp_assoc_migrate(assoc, newsk);\n\n\t/* If the association on the newsk is already closed before accept()\n\t * is called, set RCV_SHUTDOWN flag.\n\t */\n\tif (sctp_state(assoc, CLOSED) && sctp_style(newsk, TCP))\n\t\tnewsk->sk_shutdown |= RCV_SHUTDOWN;\n\n\tnewsk->sk_state = SCTP_SS_ESTABLISHED;\n\trelease_sock(newsk);\n}\n", "target": 1, "idx": 179803}
{"func": "status_t SoundTriggerHwService::Module::startRecognition(sound_model_handle_t handle,\n const sp<IMemory>& dataMemory)\n{\n    ALOGV(\"startRecognition() model handle %d\", handle);\n if (!captureHotwordAllowed()) {\n\n         return PERMISSION_DENIED;\n     }\n \n    if (dataMemory != 0 && dataMemory->pointer() == NULL) {\n        ALOGE(\"startRecognition() dataMemory is non-0 but has NULL pointer()\");\n         return BAD_VALUE;\n \n     }\n     AutoMutex lock(mLock);\n     if (mServiceState == SOUND_TRIGGER_STATE_DISABLED) {\n         return INVALID_OPERATION;\n }\n    sp<Model> model = getModel(handle);\n\n     if (model == 0) {\n         return BAD_VALUE;\n     }\n    if ((dataMemory == 0) ||\n            (dataMemory->size() < sizeof(struct sound_trigger_recognition_config))) {\n        return BAD_VALUE;\n    }\n \n     if (model->mState == Model::STATE_ACTIVE) {\n         return INVALID_OPERATION;\n     }\n \n    struct sound_trigger_recognition_config *config =\n            (struct sound_trigger_recognition_config *)dataMemory->pointer();\n \n     config->capture_handle = model->mCaptureIOHandle;\n    config->capture_device = model->mCaptureDevice;\n status_t status = mHwDevice->start_recognition(mHwDevice, handle, config,\n SoundTriggerHwService::recognitionCallback,\n this);\n\n if (status == NO_ERROR) {\n        model->mState = Model::STATE_ACTIVE;\n        model->mConfig = *config;\n }\n\n return status;\n}\n", "target": 1, "idx": 187422}
{"func": "inline void DialogHandler::dialogCreated(DOMWindow* dialogFrame)\n{\n    m_dialogContext = dialogFrame->frame() ? dialogFrame->frame()->script()->currentWorldContext() : v8::Local<v8::Context>();\n    if (m_dialogContext.IsEmpty())\n        return;\n    if (m_dialogArguments.IsEmpty())\n        return;\n    v8::Context::Scope scope(m_dialogContext);\n    m_dialogContext->Global()->Set(v8::String::NewSymbol(\"dialogArguments\"), m_dialogArguments);\n}\n", "target": 0, "idx": 118702}
{"func": "bool AsyncPixelTransfersCompletedQuery::End(\n    base::subtle::Atomic32 submit_count) {\n  AsyncMemoryParams mem_params;\n  Buffer buffer = manager()->decoder()->GetSharedMemoryBuffer(shm_id());\n  if (!buffer.shared_memory)\n    return false;\n  mem_params.shared_memory = buffer.shared_memory;\n   mem_params.shm_size = buffer.size;\n   mem_params.shm_data_offset = shm_offset();\n   mem_params.shm_data_size = sizeof(QuerySync);\n \n   observer_ = new AsyncPixelTransferCompletionObserverImpl(submit_count);\n \n  manager()->decoder()->GetAsyncPixelTransferManager()\n      ->AsyncNotifyCompletion(mem_params, observer_);\n\n  return AddToPendingTransferQueue(submit_count);\n}\n", "target": 1, "idx": 185457}
{"func": "grub_ext2_read_block (grub_fshelp_node_t node, grub_disk_addr_t fileblock)\n{\n  struct grub_ext2_data *data = node->data;\n  struct grub_ext2_inode *inode = &node->inode;\n  int blknr = -1;\n  unsigned int blksz = EXT2_BLOCK_SIZE (data);\n  int log2_blksz = LOG2_EXT2_BLOCK_SIZE (data);\n\n  if (grub_le_to_cpu32(inode->flags) & EXT4_EXTENTS_FLAG)\n    {\n#ifndef _MSC_VER\n\t  char buf[EXT2_BLOCK_SIZE (data)];\n#else\n\t  char * buf = grub_malloc (EXT2_BLOCK_SIZE(data));\n#endif\n      struct grub_ext4_extent_header *leaf;\n      struct grub_ext4_extent *ext;\n      int i;\n\n      leaf = grub_ext4_find_leaf (data, buf,\n\t\t  (struct grub_ext4_extent_header *) inode->blocks.dir_blocks,\n\t\t  fileblock);\n      if (! leaf)\n        {\n          grub_error (GRUB_ERR_BAD_FS, \"invalid extent\");\n          return -1;\n        }\n\n      ext = (struct grub_ext4_extent *) (leaf + 1);\n      for (i = 0; i < grub_le_to_cpu16 (leaf->entries); i++)\n        {\n          if (fileblock < grub_le_to_cpu32 (ext[i].block))\n            break;\n        }\n\n      if (--i >= 0)\n        {\n          fileblock -= grub_le_to_cpu32 (ext[i].block);\n          if (fileblock >= grub_le_to_cpu16 (ext[i].len))\n            return 0;\n          else\n            {\n              grub_disk_addr_t start;\n\n              start = grub_le_to_cpu16 (ext[i].start_hi);\n              start = (start << 32) + grub_le_to_cpu32 (ext[i].start);\n\n              return fileblock + start;\n            }\n        }\n      else\n        {\n          grub_error (GRUB_ERR_BAD_FS, \"something wrong with extent\");\n          return -1;\n         }\n     }\n   /* Direct blocks.  */\n  if (fileblock < INDIRECT_BLOCKS)\n     blknr = grub_le_to_cpu32 (inode->blocks.dir_blocks[fileblock]);\n   /* Indirect.  */\n  else if (fileblock < INDIRECT_BLOCKS + blksz / 4)\n     {\n       grub_uint32_t *indir;\n \n      indir = grub_malloc (blksz);\n      if (! indir)\n\treturn grub_errno;\n\n      if (grub_disk_read (data->disk,\n\t\t\t  ((grub_disk_addr_t)\n\t\t\t   grub_le_to_cpu32 (inode->blocks.indir_block))\n\t\t\t  << log2_blksz,\n\t\t\t  0, blksz, indir))\n\treturn grub_errno;\n\n      blknr = grub_le_to_cpu32 (indir[fileblock - INDIRECT_BLOCKS]);\n      grub_free (indir);\n    }\n  /* Double indirect.  */\n  else if (fileblock < (grub_disk_addr_t)(INDIRECT_BLOCKS + blksz / 4) \\\n\t\t  * (grub_disk_addr_t)(blksz / 4 + 1))\n    {\n      unsigned int perblock = blksz / 4;\n      unsigned int rblock = fileblock - (INDIRECT_BLOCKS\n\t\t\t\t\t + blksz / 4);\n      grub_uint32_t *indir;\n\n      indir = grub_malloc (blksz);\n      if (! indir)\n\treturn grub_errno;\n\n      if (grub_disk_read (data->disk,\n\t\t\t  ((grub_disk_addr_t)\n\t\t\t   grub_le_to_cpu32 (inode->blocks.double_indir_block))\n\t\t\t  << log2_blksz,\n\t\t\t  0, blksz, indir))\n\treturn grub_errno;\n\n      if (grub_disk_read (data->disk,\n\t\t\t  ((grub_disk_addr_t)\n\t\t\t   grub_le_to_cpu32 (indir[rblock / perblock]))\n\t\t\t  << log2_blksz,\n\t\t\t  0, blksz, indir))\n\treturn grub_errno;\n\n      blknr = grub_le_to_cpu32 (indir[rblock % perblock]);\n            grub_free (indir);\n    }\n  /* triple indirect.  */\n  else\n    {\n      grub_error (GRUB_ERR_NOT_IMPLEMENTED_YET,\n\t\t  \"ext2fs doesn't support triple indirect blocks\");\n    }\n\n  return blknr;\n}\n", "target": 1, "idx": 181255}
{"func": "void mp_encode_lua_table_as_map(lua_State *L, mp_buf *buf, int level) {\n    size_t len = 0;\n\n    /* First step: count keys into table. No other way to do it with the\n      * Lua API, we need to iterate a first time. Note that an alternative\n      * would be to do a single run, and then hack the buffer to insert the\n      * map opcodes for message pack. Too hackish for this lib. */\n     lua_pushnil(L);\n     while(lua_next(L,-2)) {\n         lua_pop(L,1); /* remove value, keep key for next iteration. */\n        len++;\n    }\n\n    /* Step two: actually encoding of the map. */\n    mp_encode_map(L,buf,len);\n    lua_pushnil(L);\n    while(lua_next(L,-2)) {\n        /* Stack: ... key value */\n        lua_pushvalue(L,-2); /* Stack: ... key value key */\n        mp_encode_lua_type(L,buf,level+1); /* encode key */\n        mp_encode_lua_type(L,buf,level+1); /* encode val */\n    }\n}\n", "target": 1, "idx": 182412}
{"func": "int fastcall __lock_page_killable(struct page *page)\n{\n\tDEFINE_WAIT_BIT(wait, &page->flags, PG_locked);\n\n\treturn __wait_on_bit_lock(page_waitqueue(page), &wait,\n\t\t\t\t\tsync_page_killable, TASK_KILLABLE);\n}\n", "target": 0, "idx": 58784}
{"func": "void LargeObjectPage::RemoveFromHeap() {\n  static_cast<LargeObjectArena*>(Arena())->FreeLargeObjectPage(this);\n}\n", "target": 0, "idx": 166773}
{"func": " FileStream::FileStream(base::File file,\n                        const scoped_refptr<base::TaskRunner>& task_runner)\n    : context_(base::MakeUnique<Context>(std::move(file), task_runner)) {}\n", "target": 1, "idx": 187285}
{"func": "xmlParseDocTypeDecl(xmlParserCtxtPtr ctxt) {\n    const xmlChar *name = NULL;\n    xmlChar *ExternalID = NULL;\n    xmlChar *URI = NULL;\n\n    /*\n     * We know that '<!DOCTYPE' has been detected.\n     */\n    SKIP(9);\n\n    SKIP_BLANKS;\n\n    /*\n     * Parse the DOCTYPE name.\n     */\n    name = xmlParseName(ctxt);\n    if (name == NULL) {\n\txmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n\t\t       \"xmlParseDocTypeDecl : no DOCTYPE name !\\n\");\n    }\n    ctxt->intSubName = name;\n\n    SKIP_BLANKS;\n\n    /*\n     * Check for SystemID and ExternalID\n     */\n    URI = xmlParseExternalID(ctxt, &ExternalID, 1);\n\n    if ((URI != NULL) || (ExternalID != NULL)) {\n        ctxt->hasExternalSubset = 1;\n    }\n    ctxt->extSubURI = URI;\n    ctxt->extSubSystem = ExternalID;\n\n    SKIP_BLANKS;\n\n    /*\n     * Create and update the internal subset.\n     */\n    if ((ctxt->sax != NULL) && (ctxt->sax->internalSubset != NULL) &&\n\t(!ctxt->disableSAX))\n\tctxt->sax->internalSubset(ctxt->userData, name, ExternalID, URI);\n    if (ctxt->instate == XML_PARSER_EOF)\n\treturn;\n\n    /*\n     * Is there any internal subset declarations ?\n     * they are handled separately in xmlParseInternalSubset()\n     */\n    if (RAW == '[')\n\treturn;\n\n    /*\n     * We should be at the end of the DOCTYPE declaration.\n     */\n    if (RAW != '>') {\n\txmlFatalErr(ctxt, XML_ERR_DOCTYPE_NOT_FINISHED, NULL);\n    }\n    NEXT;\n}\n", "target": 0, "idx": 59472}
{"func": "void PrintMsg_Print_Params::Reset() {\n  page_size = gfx::Size();\n  content_size = gfx::Size();\n  printable_area = gfx::Rect();\n  margin_top = 0;\n  margin_left = 0;\n  dpi = 0;\n  scale_factor = 1.0f;\n  rasterize_pdf = false;\n  document_cookie = 0;\n  selection_only = false;\n  supports_alpha_blend = false;\n  preview_ui_id = -1;\n  preview_request_id = 0;\n  is_first_request = false;\n  print_scaling_option = blink::kWebPrintScalingOptionSourceSize;\n  print_to_pdf = false;\n   display_header_footer = false;\n   title = base::string16();\n   url = base::string16();\n   should_print_backgrounds = false;\n   printed_doc_type = printing::SkiaDocumentType::PDF;\n }\n", "target": 1, "idx": 186875}
{"func": "xfs_attr_refillstate(xfs_da_state_t *state)\n{\n\txfs_da_state_path_t *path;\n\txfs_da_state_blk_t *blk;\n\tint level, error;\n\n\ttrace_xfs_attr_refillstate(state->args);\n\n\t/*\n\t * Roll down the \"path\" in the state structure, storing the on-disk\n\t * block number for those buffers in the \"path\".\n\t */\n\tpath = &state->path;\n\tASSERT((path->active >= 0) && (path->active < XFS_DA_NODE_MAXDEPTH));\n\tfor (blk = path->blk, level = 0; level < path->active; blk++, level++) {\n\t\tif (blk->disk_blkno) {\n\t\t\terror = xfs_da3_node_read(state->args->trans,\n\t\t\t\t\t\tstate->args->dp,\n\t\t\t\t\t\tblk->blkno, blk->disk_blkno,\n\t\t\t\t\t\t&blk->bp, XFS_ATTR_FORK);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t} else {\n\t\t\tblk->bp = NULL;\n\t\t}\n\t}\n\n\t/*\n\t * Roll down the \"altpath\" in the state structure, storing the on-disk\n\t * block number for those buffers in the \"altpath\".\n\t */\n\tpath = &state->altpath;\n\tASSERT((path->active >= 0) && (path->active < XFS_DA_NODE_MAXDEPTH));\n\tfor (blk = path->blk, level = 0; level < path->active; blk++, level++) {\n\t\tif (blk->disk_blkno) {\n\t\t\terror = xfs_da3_node_read(state->args->trans,\n\t\t\t\t\t\tstate->args->dp,\n\t\t\t\t\t\tblk->blkno, blk->disk_blkno,\n\t\t\t\t\t\t&blk->bp, XFS_ATTR_FORK);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t} else {\n\t\t\tblk->bp = NULL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n", "target": 0, "idx": 76324}
{"func": "NetworkThrottleManagerImpl::NetworkThrottleManagerImpl()\n     : lifetime_median_estimate_(PercentileEstimator::kMedianPercentile,\n                                 kInitialMedianInMs),\n       outstanding_recomputation_timer_(\n          base::MakeUnique<base::Timer>(false /* retain_user_task */,\n                                         false /* is_repeating */)),\n       tick_clock_(new base::DefaultTickClock()),\n       weak_ptr_factory_(this) {}\n", "target": 1, "idx": 187288}
{"func": "void InspectorResourceAgent::frameScheduledNavigation(Frame* frame, double)\n{\n    RefPtr<TypeBuilder::Network::Initiator> initiator = buildInitiatorObject(frame->document(), FetchInitiatorInfo());\n    m_frameNavigationInitiatorMap.set(m_pageAgent->frameId(frame), initiator);\n}\n", "target": 0, "idx": 109382}
{"func": "void Editor::RevealSelectionAfterEditingOperation(\n    const ScrollAlignment& alignment,\n    RevealExtentOption reveal_extent_option) {\n  if (prevent_reveal_selection_)\n    return;\n  if (!GetFrame().Selection().IsAvailable())\n    return;\n   GetFrame().Selection().RevealSelection(alignment, reveal_extent_option);\n }\n", "target": 0, "idx": 139372}
{"func": "get_caller_uid (GDBusMethodInvocation *context, gint *uid)\n {\n        PolkitSubject *subject;\n        PolkitSubject *process;\n \n        subject = polkit_system_bus_name_new (g_dbus_method_invocation_get_sender (context));\n        process = polkit_system_bus_name_get_process_sync (POLKIT_SYSTEM_BUS_NAME (subject), NULL, NULL);\n        if (!process) {\n                g_object_unref (subject);\n                 return FALSE;\n         }\n \n        *uid = polkit_unix_process_get_uid (POLKIT_UNIX_PROCESS (process));\n        g_object_unref (subject);\n        g_object_unref (process);\n \n         return TRUE;\n }\n", "target": 1, "idx": 178183}
{"func": "static v8::Handle<v8::Value> acceptTransferListCallback(const v8::Arguments& args)\n {\n     INC_STATS(\"DOM.TestSerializedScriptValueInterface.acceptTransferList\");\n     if (args.Length() < 1)\n        return V8Proxy::throwNotEnoughArgumentsError();\n     TestSerializedScriptValueInterface* imp = V8TestSerializedScriptValueInterface::toNative(args.Holder());\n     MessagePortArray messagePortArrayTransferList;\n     ArrayBufferArray arrayBufferArrayTransferList;\n    if (args.Length() > 1) {\n        if (!extractTransferables(args[1], messagePortArrayTransferList, arrayBufferArrayTransferList))\n            return V8Proxy::throwTypeError(\"Could not extract transferables\");\n    }\n    bool dataDidThrow = false;\n    RefPtr<SerializedScriptValue> data = SerializedScriptValue::create(args[0], &messagePortArrayTransferList, &arrayBufferArrayTransferList, dataDidThrow, args.GetIsolate());\n    if (dataDidThrow)\n        return v8::Undefined();\n    if (args.Length() <= 1) {\n        imp->acceptTransferList(data);\n        return v8::Handle<v8::Value>();\n    }\n    imp->acceptTransferList(data, messagePortArrayTransferList);\n    return v8::Handle<v8::Value>();\n}\n", "target": 1, "idx": 184799}
{"func": "pdf14_forward_device_procs(gx_device * dev)\n{\n    gx_device_forward * pdev = (gx_device_forward *)dev;\n\n    /*\n     * We are using gx_device_forward_fill_in_procs to set the various procs.\n     * This will ensure that any new device procs are also set.  However that\n     * routine only changes procs which are NULL.  Thus we start by setting all\n     * procs to NULL.\n     */\n    memset(&(pdev->procs), 0, size_of(pdev->procs));\n    gx_device_forward_fill_in_procs(pdev);\n    /*\n     * gx_device_forward_fill_in_procs does not forward all procs.\n     * Set the remainding procs to also forward.\n     */\n    set_dev_proc(dev, close_device, gx_forward_close_device);\n    set_dev_proc(dev, fill_rectangle, gx_forward_fill_rectangle);\n    set_dev_proc(dev, fill_rectangle_hl_color, gx_forward_fill_rectangle_hl_color);\n    set_dev_proc(dev, tile_rectangle, gx_forward_tile_rectangle);\n    set_dev_proc(dev, copy_mono, gx_forward_copy_mono);\n    set_dev_proc(dev, copy_color, gx_forward_copy_color);\n    set_dev_proc(dev, get_page_device, gx_forward_get_page_device);\n    set_dev_proc(dev, strip_tile_rectangle, gx_forward_strip_tile_rectangle);\n    set_dev_proc(dev, copy_alpha, gx_forward_copy_alpha);\n    set_dev_proc(dev, get_profile, gx_forward_get_profile);\n    set_dev_proc(dev, set_graphics_type_tag, gx_forward_set_graphics_type_tag);\n    /* These are forwarding devices with minor tweaks. */\n    set_dev_proc(dev, open_device, pdf14_forward_open_device);\n    set_dev_proc(dev, put_params, pdf14_forward_put_params);\n}\n", "target": 0, "idx": 2953}
{"func": "static void vrend_renderer_init_blit_ctx(struct vrend_blitter_ctx *blit_ctx)\n{\n   struct virgl_gl_ctx_param ctx_params;\n   int i;\n   if (blit_ctx->initialised) {\n      vrend_clicbs->make_current(0, blit_ctx->gl_context);\n       return;\n    }\n \n    ctx_params.shared = true;\n    ctx_params.major_ver = VREND_GL_VER_MAJOR;\n    ctx_params.minor_ver = VREND_GL_VER_MINOR;\n\n   vrend_clicbs->make_current(0, blit_ctx->gl_context);\n   glGenVertexArrays(1, &blit_ctx->vaoid);\n   glGenFramebuffers(1, &blit_ctx->fb_id);\n\n   glGenBuffers(1, &blit_ctx->vbo_id);\n   blit_build_vs_passthrough(blit_ctx);\n\n   for (i = 0; i < 4; i++)\n      blit_ctx->vertices[i][0][3] = 1; /*v.w*/\n   glBindVertexArray(blit_ctx->vaoid);\n   glBindBuffer(GL_ARRAY_BUFFER, blit_ctx->vbo_id);\n}\n", "target": 1, "idx": 178127}
{"func": "struct symbol_t* MACH0_(get_symbols)(struct MACH0_(obj_t)* bin) {\n\tconst char *symstr;\n\tstruct symbol_t *symbols;\n\tint from, to, i, j, s, stridx, symbols_size, symbols_count;\n\tSdbHash *hash;\n\n\tif (!bin || !bin->symtab || !bin->symstr) {\n\t\treturn NULL;\n\t}\n\t/* parse symbol table */\n\t/* parse dynamic symbol table */\n\tsymbols_count = (bin->dysymtab.nextdefsym + \\\n\t\t\tbin->dysymtab.nlocalsym + \\\n\t\t\tbin->dysymtab.nundefsym );\n\tsymbols_count += bin->nsymtab;\n\tsymbols_size = (symbols_count + 1) * 2 * sizeof (struct symbol_t);\n\n\tif (symbols_size < 1) {\n\t\treturn NULL;\n\t}\n\tif (!(symbols = calloc (1, symbols_size))) {\n\t\treturn NULL;\n\t}\n\thash = sdb_ht_new ();\n\tj = 0; // symbol_idx\n\tfor (s = 0; s < 2; s++) {\n\t\tswitch (s) {\n\t\tcase 0:\n\t\t\tfrom = bin->dysymtab.iextdefsym;\n\t\t\tto = from + bin->dysymtab.nextdefsym;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tfrom = bin->dysymtab.ilocalsym;\n\t\t\tto = from + bin->dysymtab.nlocalsym;\n\t\t\tbreak;\n#if NOT_USED\n\t\tcase 2:\n\t\t\tfrom = bin->dysymtab.iundefsym;\n\t\t\tto = from + bin->dysymtab.nundefsym;\n\t\t\tbreak;\n#endif\n\t\t}\n\t\tif (from == to) {\n\t\t\tcontinue;\n\t\t}\n#define OLD 1\n#if OLD\n\t\tfrom = R_MIN (R_MAX (0, from), symbols_size / sizeof (struct symbol_t));\n\t\tto = R_MIN (to , symbols_size / sizeof (struct symbol_t));\n\t\tto = R_MIN (to, bin->nsymtab);\n#else\n\t\tfrom = R_MIN (R_MAX (0, from), symbols_size/sizeof (struct symbol_t));\n\t\tto = symbols_count; //symbols_size/sizeof(struct symbol_t);\n#endif\n\t\tint maxsymbols = symbols_size / sizeof (struct symbol_t);\n\t\tif (to > 0x500000) {\n\t\t\tbprintf (\"WARNING: corrupted mach0 header: symbol table is too big %d\\n\", to);\n\t\t\tfree (symbols);\n\t\t\tsdb_ht_free (hash);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (symbols_count >= maxsymbols) {\n\t\t\tsymbols_count = maxsymbols - 1;\n\t\t}\n\t\tfor (i = from; i < to && j < symbols_count; i++, j++) {\n\t\t\tsymbols[j].offset = addr_to_offset (bin, bin->symtab[i].n_value);\n\t\t\tsymbols[j].addr = bin->symtab[i].n_value;\n\t\t\tsymbols[j].size = 0; /* TODO: Is it anywhere? */\n\t\t\tif (bin->symtab[i].n_type & N_EXT) {\n\t\t\t\tsymbols[j].type = R_BIN_MACH0_SYMBOL_TYPE_EXT;\n\t\t\t} else {\n\t\t\t\tsymbols[j].type = R_BIN_MACH0_SYMBOL_TYPE_LOCAL;\n\t\t\t}\n\t\t\tstridx = bin->symtab[i].n_strx;\n\t\t\tif (stridx >= 0 && stridx < bin->symstrlen) {\n\t\t\t\tsymstr = (char*)bin->symstr + stridx;\n\t\t\t} else {\n\t\t\t\tsymstr = \"???\";\n\t\t\t}\n\t\t\t{\n\t\t\t\tint i = 0;\n\t\t\t\tint len = 0;\n\t\t\t\tlen = bin->symstrlen - stridx;\n\t\t\t\tif (len > 0) {\n\t\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\t\tif ((ut8)(symstr[i] & 0xff) == 0xff || !symstr[i]) {\n\t\t\t\t\t\t\tlen = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tchar *symstr_dup = NULL;\n\t\t\t\t\tif (len > 0) {\n\t\t\t\t\t\tsymstr_dup = r_str_ndup (symstr, len);\n\t\t\t\t\t}\n\t\t\t\t\tif (!symstr_dup) {\n\t\t\t\t\t\tsymbols[j].name[0] = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_str_ncpy (symbols[j].name, symstr_dup, R_BIN_MACH0_STRING_LENGTH);\n\t\t\t\t\t\tr_str_filter (symbols[j].name, -1);\n\t\t\t\t\t\tsymbols[j].name[R_BIN_MACH0_STRING_LENGTH - 2] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tfree (symstr_dup);\n\t\t\t\t} else {\n\t\t\t\t\tsymbols[j].name[0] = 0;\n\t\t\t\t}\n\t\t\t\tsymbols[j].last = 0;\n\t\t\t}\n\t\t\tif (inSymtab (hash, symbols, symbols[j].name, symbols[j].addr)) {\n\t\t\t\tsymbols[j].name[0] = 0;\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t}\n\tto = R_MIN (bin->nsymtab, bin->dysymtab.iundefsym + bin->dysymtab.nundefsym);\n\tfor (i = bin->dysymtab.iundefsym; i < to; i++) {\n\t\tif (j > symbols_count) {\n \t\t\tbprintf (\"mach0-get-symbols: error\\n\");\n \t\t\tbreak;\n \t\t}\n\t\tif (parse_import_stub(bin, &symbols[j], i))\n \t\t\tsymbols[j++].last = 0;\n \t}\n \n #if 1\n\tfor (i = 0; i < bin->nsymtab; i++) {\n\t\tstruct MACH0_(nlist) *st = &bin->symtab[i];\n#if 0\n\t\tbprintf (\"stridx %d -> section %d type %d value = %d\\n\",\n\t\t\tst->n_strx, st->n_sect, st->n_type, st->n_value);\n#endif\n\t\tstridx = st->n_strx;\n\t\tif (stridx >= 0 && stridx < bin->symstrlen) {\n\t\t\tsymstr = (char*)bin->symstr + stridx;\n\t\t} else {\n\t\t\tsymstr = \"???\";\n\t\t}\n\t\tint section = st->n_sect;\n\t\tif (section == 1 && j < symbols_count) { // text ??st->n_type == 1)\n\t\t\t/* is symbol */\n\t\t\tsymbols[j].addr = st->n_value; // + text_base;\n\t\t\tsymbols[j].offset = addr_to_offset (bin, symbols[j].addr);\n\t\t\tsymbols[j].size = 0; /* find next symbol and crop */\n\t\t\tif (st->n_type & N_EXT) {\n\t\t\t\tsymbols[j].type = R_BIN_MACH0_SYMBOL_TYPE_EXT;\n\t\t\t} else {\n\t\t\t\tsymbols[j].type = R_BIN_MACH0_SYMBOL_TYPE_LOCAL;\n\t\t\t}\n\t\t\tstrncpy (symbols[j].name, symstr, R_BIN_MACH0_STRING_LENGTH);\n\t\t\tsymbols[j].name[R_BIN_MACH0_STRING_LENGTH - 1] = 0;\n\t\t\tsymbols[j].last = 0;\n\t\t\tif (inSymtab (hash, symbols, symbols[j].name, symbols[j].addr)) {\n\t\t\t\tsymbols[j].name[0] = 0;\n\t\t\t} else {\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\tsdb_ht_free (hash);\n\tsymbols[j].last = 1;\n\treturn symbols;\n}\n", "target": 1, "idx": 182398}
{"func": "xsltGetNamespace(xsltTransformContextPtr ctxt, xmlNodePtr cur, xmlNsPtr ns,\n\t         xmlNodePtr out)\n{\n\n    if (ns == NULL)\n\treturn(NULL);\n\n#ifdef XSLT_REFACTORED\n    /*\n    * Namespace exclusion and ns-aliasing is performed at\n    * compilation-time in the refactored code.\n    * Additionally, aliasing is not intended for non Literal\n    * Result Elements.\n    */\n    return(xsltGetSpecialNamespace(ctxt, cur, ns->href, ns->prefix, out));\n#else\n    {\n\txsltStylesheetPtr style;\n\tconst xmlChar *URI = NULL; /* the replacement URI */\n\n\tif ((ctxt == NULL) || (cur == NULL) || (out == NULL))\n\t    return(NULL);\n\n\tstyle = ctxt->style;\n\twhile (style != NULL) {\n\t    if (style->nsAliases != NULL)\n\t\tURI = (const xmlChar *)\n\t\txmlHashLookup(style->nsAliases, ns->href);\n\t    if (URI != NULL)\n\t\tbreak;\n\n\t    style = xsltNextImport(style);\n\t}\n\n\n\tif (URI == UNDEFINED_DEFAULT_NS) {\n\t    return(xsltGetSpecialNamespace(ctxt, cur, NULL, NULL, out));\n#if 0\n\t    /*\n\t    * TODO: Removed, since wrong. If there was no default\n\t    * namespace in the stylesheet then this must resolve to\n\t    * the NULL namespace.\n\t    */\n\t    xmlNsPtr dflt;\n\t    dflt = xmlSearchNs(cur->doc, cur, NULL);\n\t    if (dflt != NULL)\n\t\tURI = dflt->href;\n\t    else\n\t\treturn NULL;\n#endif\n\t} else if (URI == NULL)\n\t    URI = ns->href;\n\n\treturn(xsltGetSpecialNamespace(ctxt, cur, URI, ns->prefix, out));\n    }\n#endif\n}\n", "target": 0, "idx": 169923}
{"func": "status_t ACodec::setupAACCodec(\n bool encoder, int32_t numChannels, int32_t sampleRate,\n int32_t bitRate, int32_t aacProfile, bool isADTS, int32_t sbrMode,\n int32_t maxOutputChannelCount, const drcParams_t& drc,\n int32_t pcmLimiterEnable) {\n if (encoder && isADTS) {\n return -EINVAL;\n }\n\n status_t err = setupRawAudioFormat(\n            encoder ? kPortIndexInput : kPortIndexOutput,\n            sampleRate,\n            numChannels);\n\n if (err != OK) {\n return err;\n }\n\n if (encoder) {\n        err = selectAudioPortFormat(kPortIndexOutput, OMX_AUDIO_CodingAAC);\n\n if (err != OK) {\n return err;\n }\n\n        OMX_PARAM_PORTDEFINITIONTYPE def;\n InitOMXParams(&def);\n        def.nPortIndex = kPortIndexOutput;\n\n        err = mOMX->getParameter(\n                mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));\n\n if (err != OK) {\n return err;\n }\n\n        def.format.audio.bFlagErrorConcealment = OMX_TRUE;\n        def.format.audio.eEncoding = OMX_AUDIO_CodingAAC;\n\n        err = mOMX->setParameter(\n                mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));\n\n if (err != OK) {\n return err;\n }\n\n        OMX_AUDIO_PARAM_AACPROFILETYPE profile;\n InitOMXParams(&profile);\n        profile.nPortIndex = kPortIndexOutput;\n\n        err = mOMX->getParameter(\n                mNode, OMX_IndexParamAudioAac, &profile, sizeof(profile));\n\n if (err != OK) {\n return err;\n }\n\n        profile.nChannels = numChannels;\n\n        profile.eChannelMode =\n (numChannels == 1)\n ? OMX_AUDIO_ChannelModeMono: OMX_AUDIO_ChannelModeStereo;\n\n        profile.nSampleRate = sampleRate;\n        profile.nBitRate = bitRate;\n        profile.nAudioBandWidth = 0;\n        profile.nFrameLength = 0;\n        profile.nAACtools = OMX_AUDIO_AACToolAll;\n        profile.nAACERtools = OMX_AUDIO_AACERNone;\n        profile.eAACProfile = (OMX_AUDIO_AACPROFILETYPE) aacProfile;\n        profile.eAACStreamFormat = OMX_AUDIO_AACStreamFormatMP4FF;\n switch (sbrMode) {\n case 0:\n            profile.nAACtools &= ~OMX_AUDIO_AACToolAndroidSSBR;\n            profile.nAACtools &= ~OMX_AUDIO_AACToolAndroidDSBR;\n break;\n case 1:\n            profile.nAACtools |= OMX_AUDIO_AACToolAndroidSSBR;\n            profile.nAACtools &= ~OMX_AUDIO_AACToolAndroidDSBR;\n break;\n case 2:\n            profile.nAACtools &= ~OMX_AUDIO_AACToolAndroidSSBR;\n            profile.nAACtools |= OMX_AUDIO_AACToolAndroidDSBR;\n break;\n case -1:\n            profile.nAACtools |= OMX_AUDIO_AACToolAndroidSSBR;\n            profile.nAACtools |= OMX_AUDIO_AACToolAndroidDSBR;\n break;\n default:\n return BAD_VALUE;\n }\n\n\n        err = mOMX->setParameter(\n                mNode, OMX_IndexParamAudioAac, &profile, sizeof(profile));\n\n if (err != OK) {\n return err;\n }\n\n return err;\n }\n\n    OMX_AUDIO_PARAM_AACPROFILETYPE profile;\n InitOMXParams(&profile);\n    profile.nPortIndex = kPortIndexInput;\n\n    err = mOMX->getParameter(\n            mNode, OMX_IndexParamAudioAac, &profile, sizeof(profile));\n\n if (err != OK) {\n return err;\n }\n\n    profile.nChannels = numChannels;\n    profile.nSampleRate = sampleRate;\n\n    profile.eAACStreamFormat =\n        isADTS\n ? OMX_AUDIO_AACStreamFormatMP4ADTS\n\n             : OMX_AUDIO_AACStreamFormatMP4FF;\n \n     OMX_AUDIO_PARAM_ANDROID_AACPRESENTATIONTYPE presentation;\n     presentation.nMaxOutputChannels = maxOutputChannelCount;\n     presentation.nDrcCut = drc.drcCut;\n     presentation.nDrcBoost = drc.drcBoost;\n    presentation.nHeavyCompression = drc.heavyCompression;\n    presentation.nTargetReferenceLevel = drc.targetRefLevel;\n    presentation.nEncodedTargetLevel = drc.encodedTargetLevel;\n    presentation.nPCMLimiterEnable = pcmLimiterEnable;\n\n status_t res = mOMX->setParameter(mNode, OMX_IndexParamAudioAac, &profile, sizeof(profile));\n if (res == OK) {\n        mOMX->setParameter(mNode, (OMX_INDEXTYPE)OMX_IndexParamAudioAndroidAacPresentation,\n &presentation, sizeof(presentation));\n } else {\n        ALOGW(\"did not set AudioAndroidAacPresentation due to error %d when setting AudioAac\", res);\n }\n return res;\n}\n", "target": 1, "idx": 188250}
{"func": "onig_free_body(regex_t* reg)\n{\n  if (IS_NOT_NULL(reg)) {\n    ops_free(reg);\n    if (IS_NOT_NULL(reg->string_pool)) {\n      xfree(reg->string_pool);\n      reg->string_pool_end = reg->string_pool = 0;\n    }\n    if (IS_NOT_NULL(reg->exact))            xfree(reg->exact);\n    if (IS_NOT_NULL(reg->repeat_range))     xfree(reg->repeat_range);\n    if (IS_NOT_NULL(reg->extp)) {\n      free_regex_ext(reg->extp);\n      reg->extp = 0;\n    }\n\n    onig_names_free(reg);\n  }\n}\n", "target": 0, "idx": 89187}
{"func": "PasswordStoreLoginsChangedObserver::PasswordStoreLoginsChangedObserver(\n    AutomationProvider* automation,\n    IPC::Message* reply_message,\n    PasswordStoreChange::Type expected_type,\n    const std::string& result_key)\n    : automation_(automation->AsWeakPtr()),\n      reply_message_(reply_message),\n      expected_type_(expected_type),\n      result_key_(result_key),\n      done_event_(false, false) {\n  AddRef();\n}\n", "target": 0, "idx": 126034}
{"func": "scoped_refptr<PrintBackend> PrintBackend::CreateInstance(\n    const base::DictionaryValue* print_backend_settings) {\n  return new PrintBackendWin;\n}\n", "target": 0, "idx": 130206}
{"func": "DGACreateColormap(int index, ClientPtr client, int id, int mode, int alloc)\n{\n    ScreenPtr pScreen = screenInfo.screens[index];\n    DGAScreenPtr pScreenPriv = DGA_GET_SCREEN_PRIV(pScreen);\n    FakedVisualList *fvlp;\n    VisualPtr pVisual;\n    DGAModePtr pMode;\n    ColormapPtr pmap;\n\n    if (!mode || (mode > pScreenPriv->numModes))\n        return BadValue;\n\n    if ((alloc != AllocNone) && (alloc != AllocAll))\n        return BadValue;\n\n    pMode = &(pScreenPriv->modes[mode - 1]);\n\n    if (!(pVisual = malloc(sizeof(VisualRec))))\n        return BadAlloc;\n\n    pVisual->vid = FakeClientID(0);\n    pVisual->class = pMode->visualClass;\n    pVisual->nplanes = pMode->depth;\n    pVisual->ColormapEntries = 1 << pMode->depth;\n    pVisual->bitsPerRGBValue = (pMode->depth + 2) / 3;\n\n    switch (pVisual->class) {\n    case PseudoColor:\n    case GrayScale:\n    case StaticGray:\n        pVisual->bitsPerRGBValue = 8;   /* not quite */\n        pVisual->redMask = 0;\n        pVisual->greenMask = 0;\n        pVisual->blueMask = 0;\n        pVisual->offsetRed = 0;\n        pVisual->offsetGreen = 0;\n        pVisual->offsetBlue = 0;\n        break;\n    case DirectColor:\n    case TrueColor:\n        pVisual->ColormapEntries = 1 << pVisual->bitsPerRGBValue;\n        /* fall through */\n    case StaticColor:\n        pVisual->redMask = pMode->red_mask;\n        pVisual->greenMask = pMode->green_mask;\n        pVisual->blueMask = pMode->blue_mask;\n        pVisual->offsetRed = BitsClear(pVisual->redMask);\n        pVisual->offsetGreen = BitsClear(pVisual->greenMask);\n        pVisual->offsetBlue = BitsClear(pVisual->blueMask);\n    }\n\n    if (!(fvlp = malloc(sizeof(FakedVisualList)))) {\n        free(pVisual);\n        return BadAlloc;\n    }\n\n    fvlp->free = FALSE;\n    fvlp->pVisual = pVisual;\n    fvlp->next = pScreenPriv->fakedVisuals;\n    pScreenPriv->fakedVisuals = fvlp;\n\n    LEGAL_NEW_RESOURCE(id, client);\n\n    return CreateColormap(id, pScreen, pVisual, &pmap, alloc, client->index);\n}\n", "target": 0, "idx": 17703}
{"func": "store_current_palette(png_store *ps, int *npalette)\n{\n /* This is an internal error (the call has been made outside a read\n\n     * operation.)\n     */\n    if (ps->current == NULL)\n       store_log(ps, ps->pread, \"no current stream for palette\", 1);\n \n    /* The result may be null if there is no palette. */\n    *npalette = ps->current->npalette;\n return ps->current->palette;\n}\n", "target": 1, "idx": 187725}
{"func": "EncodedJSValue JSC_HOST_CALL jsTestInterfacePrototypeFunctionSupplementalMethod2(ExecState* exec)\n{\n    JSValue thisValue = exec->hostThisValue();\n    if (!thisValue.inherits(&JSTestInterface::s_info))\n        return throwVMTypeError(exec);\n    JSTestInterface* castedThis = jsCast<JSTestInterface*>(asObject(thisValue));\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestInterface::s_info);\n     TestInterface* impl = static_cast<TestInterface*>(castedThis->impl());\n     if (exec->argumentCount() < 2)\n        return throwVMError(exec, createTypeError(exec, \"Not enough arguments\"));\n     ExceptionCode ec = 0;\n     ScriptExecutionContext* scriptContext = jsCast<JSDOMGlobalObject*>(exec->lexicalGlobalObject())->scriptExecutionContext();\n     if (!scriptContext)\n        return JSValue::encode(jsUndefined());\n    const String& strArg(ustringToString(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).isEmpty() ? UString() : MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toString(exec)->value(exec)));\n    if (exec->hadException())\n        return JSValue::encode(jsUndefined());\n    TestObj* objArg(toTestObj(MAYBE_MISSING_PARAMETER(exec, 1, DefaultIsUndefined)));\n    if (exec->hadException())\n        return JSValue::encode(jsUndefined());\n\n    JSC::JSValue result = toJS(exec, castedThis->globalObject(), WTF::getPtr(TestSupplemental::supplementalMethod2(impl, scriptContext, strArg, objArg, ec)));\n    setDOMException(exec, ec);\n    return JSValue::encode(result);\n}\n", "target": 1, "idx": 184032}
{"func": "void InterstitialPageImpl::InterstitialPageRVHDelegateView::ShowPopupMenu(\n    RenderFrameHost* render_frame_host,\n    const gfx::Rect& bounds,\n    int item_height,\n    double item_font_size,\n    int selected_item,\n    const std::vector<MenuItem>& items,\n    bool right_aligned,\n    bool allow_multiple_selection) {\n  NOTREACHED() << \"InterstitialPage does not support showing popup menus.\";\n}\n", "target": 0, "idx": 148814}
{"func": "status_t SampleTable::setChunkOffsetParams(\n uint32_t type, off64_t data_offset, size_t data_size) {\n if (mChunkOffsetOffset >= 0) {\n return ERROR_MALFORMED;\n }\n\n    CHECK(type == kChunkOffsetType32 || type == kChunkOffsetType64);\n\n    mChunkOffsetOffset = data_offset;\n    mChunkOffsetType = type;\n\n if (data_size < 8) {\n return ERROR_MALFORMED;\n }\n\n uint8_t header[8];\n if (mDataSource->readAt(\n                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {\n return ERROR_IO;\n }\n\n if (U32_AT(header) != 0) {\n return ERROR_MALFORMED;\n }\n\n    mNumChunkOffsets = U32_AT(&header[4]);\n\n if (mChunkOffsetType == kChunkOffsetType32) {\n if ((data_size - 8) / 4 < mNumChunkOffsets) {\n return ERROR_MALFORMED;\n }\n } else {\n if ((data_size - 8) / 8 < mNumChunkOffsets) {\n return ERROR_MALFORMED;\n }\n }\n\n return OK;\n}\n", "target": 0, "idx": 175404}
{"func": "map_id_range_down_base(unsigned extents, struct uid_gid_map *map, u32 id, u32 count)\n{\n\tunsigned idx;\n\tu32 first, last, id2;\n\n\tid2 = id + count - 1;\n\n\t/* Find the matching extent */\n\tfor (idx = 0; idx < extents; idx++) {\n\t\tfirst = map->extent[idx].first;\n\t\tlast = first + map->extent[idx].count - 1;\n\t\tif (id >= first && id <= last &&\n\t\t    (id2 >= first && id2 <= last))\n\t\t\treturn &map->extent[idx];\n\t}\n\treturn NULL;\n}\n", "target": 0, "idx": 76185}
{"func": "TIFFFetchSubjectDistance(TIFF* tif, TIFFDirEntry* dir)\n{\n\tstatic const char module[] = \"TIFFFetchSubjectDistance\";\n\tenum TIFFReadDirEntryErr err;\n\tUInt64Aligned_t m;\n    m.l=0;\n\tassert(sizeof(double)==8);\n\tassert(sizeof(uint64)==8);\n\tassert(sizeof(uint32)==4);\n\tif (dir->tdir_count!=1)\n\t\terr=TIFFReadDirEntryErrCount;\n\telse if (dir->tdir_type!=TIFF_RATIONAL)\n\t\terr=TIFFReadDirEntryErrType;\n\telse\n\t{\n\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t{\n\t\t\tuint32 offset;\n\t\t\toffset=*(uint32*)(&dir->tdir_offset);\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong(&offset);\n\t\t\terr=TIFFReadDirEntryData(tif,offset,8,m.i);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm.l=dir->tdir_offset.toff_long8;\n\t\t\terr=TIFFReadDirEntryErrOk;\n\t\t}\n\t}\n\tif (err==TIFFReadDirEntryErrOk)\n\t{\n\t\tdouble n;\n\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\tTIFFSwabArrayOfLong(m.i,2);\n\t\tif (m.i[0]==0)\n\t\t\tn=0.0;\n\t\telse if (m.i[0]==0xFFFFFFFF)\n\t\t\t/*\n\t\t\t * XXX: Numerator 0xFFFFFFFF means that we have infinite\n\t\t\t * distance. Indicate that with a negative floating point\n\t\t\t * SubjectDistance value.\n\t\t\t */\n\t\t\tn=-1.0;\n\t\telse\n\t\t\tn=(double)m.i[0]/(double)m.i[1];\n\t\treturn(TIFFSetField(tif,dir->tdir_tag,n));\n\t}\n\telse\n\t{\n\t\tTIFFReadDirEntryOutputErr(tif,err,module,\"SubjectDistance\",TRUE);\n\t\treturn(0);\n\t}\n}\n", "target": 0, "idx": 70129}
{"func": "OMX_ERRORTYPE SoftAMR::internalGetParameter(\n        OMX_INDEXTYPE index, OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamAudioAmr:\n {\n\n             OMX_AUDIO_PARAM_AMRTYPE *amrParams =\n                 (OMX_AUDIO_PARAM_AMRTYPE *)params;\n \n             if (amrParams->nPortIndex != 0) {\n                 return OMX_ErrorUndefined;\n             }\n\n            amrParams->nChannels = 1;\n            amrParams->eAMRDTXMode = OMX_AUDIO_AMRDTXModeOff;\n            amrParams->eAMRFrameFormat = OMX_AUDIO_AMRFrameFormatFSF;\n\n if (!isConfigured()) {\n                amrParams->nBitRate = 0;\n                amrParams->eAMRBandMode = OMX_AUDIO_AMRBandModeUnused;\n } else {\n                amrParams->nBitRate = 0;\n                amrParams->eAMRBandMode =\n                    mMode == MODE_NARROW\n ? OMX_AUDIO_AMRBandModeNB0 : OMX_AUDIO_AMRBandModeWB0;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioPcm:\n {\n\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            pcmParams->nChannels = 1;\n            pcmParams->eNumData = OMX_NumericalDataSigned;\n            pcmParams->eEndian = OMX_EndianBig;\n            pcmParams->bInterleaved = OMX_TRUE;\n            pcmParams->nBitPerSample = 16;\n\n            pcmParams->nSamplingRate =\n (mMode == MODE_NARROW) ? kSampleRateNB : kSampleRateWB;\n\n            pcmParams->ePCMMode = OMX_AUDIO_PCMModeLinear;\n            pcmParams->eChannelMapping[0] = OMX_AUDIO_ChannelLF;\n            pcmParams->eChannelMapping[1] = OMX_AUDIO_ChannelRF;\n\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalGetParameter(index, params);\n }\n}\n", "target": 1, "idx": 188214}
{"func": " void RTCSessionDescriptionRequestImpl::requestFailed(const String& error)\n {\n     if (m_errorCallback)\n        m_errorCallback->handleEvent(error);\n \n     clear();\n }\n", "target": 1, "idx": 183800}
{"func": "SYSCALL_DEFINE6(move_pages, pid_t, pid, unsigned long, nr_pages,\n\t\tconst void __user * __user *, pages,\n \t\tconst int __user *, nodes,\n \t\tint __user *, status, int, flags)\n {\n\tconst struct cred *cred = current_cred(), *tcred;\n \tstruct task_struct *task;\n \tstruct mm_struct *mm;\n \tint err;\n\tnodemask_t task_nodes;\n\n\t/* Check flags */\n\tif (flags & ~(MPOL_MF_MOVE|MPOL_MF_MOVE_ALL))\n\t\treturn -EINVAL;\n\n\tif ((flags & MPOL_MF_MOVE_ALL) && !capable(CAP_SYS_NICE))\n\t\treturn -EPERM;\n\n\t/* Find the mm_struct */\n\trcu_read_lock();\n\ttask = pid ? find_task_by_vpid(pid) : current;\n\tif (!task) {\n\t\trcu_read_unlock();\n\t\treturn -ESRCH;\n\t}\n\tget_task_struct(task);\n \n \t/*\n \t * Check if this process has the right to modify the specified\n\t * process. The right exists if the process has administrative\n\t * capabilities, superuser privileges or the same\n\t * userid as the target process.\n \t */\n\ttcred = __task_cred(task);\n\tif (!uid_eq(cred->euid, tcred->suid) && !uid_eq(cred->euid, tcred->uid) &&\n\t    !uid_eq(cred->uid,  tcred->suid) && !uid_eq(cred->uid,  tcred->uid) &&\n\t    !capable(CAP_SYS_NICE)) {\n \t\trcu_read_unlock();\n \t\terr = -EPERM;\n \t\tgoto out;\n\t}\n\trcu_read_unlock();\n\n \terr = security_task_movememory(task);\n \tif (err)\n\t\tgoto out;\n\n\ttask_nodes = cpuset_mems_allowed(task);\n\tmm = get_task_mm(task);\n\tput_task_struct(task);\n\n\tif (!mm)\n\t\treturn -EINVAL;\n\n\tif (nodes)\n\t\terr = do_pages_move(mm, task_nodes, nr_pages, pages,\n\t\t\t\t    nodes, status, flags);\n\telse\n\t\terr = do_pages_stat(mm, nr_pages, pages, status);\n\n\tmmput(mm);\n\treturn err;\n\nout:\n\tput_task_struct(task);\n\treturn err;\n}\n", "target": 1, "idx": 180942}
{"func": "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list)\n{\n#if DEBUG\n\tvoid *next = *list;\n\tvoid *objp;\n\n\twhile (next) {\n\t\tobjp = next - obj_offset(cachep);\n\t\tnext = *(void **)next;\n\t\tpoison_obj(cachep, objp, POISON_FREE);\n\t}\n#endif\n}\n", "target": 0, "idx": 68877}
{"func": "bool isUserInteractionEventForSlider(Event* event, LayoutObject* layoutObject) {\n  if (isUserInteractionEvent(event))\n    return true;\n\n  LayoutSliderItem slider = LayoutSliderItem(toLayoutSlider(layoutObject));\n  if (!slider.isNull() && !slider.inDragMode())\n    return false;\n \n   const AtomicString& type = event->type();\n   return type == EventTypeNames::mouseover ||\n         type == EventTypeNames::mouseout || type == EventTypeNames::mousemove;\n }\n", "target": 1, "idx": 185778}
{"func": "Compositor::Compositor(const viz::FrameSinkId& frame_sink_id,\n                       ui::ContextFactory* context_factory,\n                       ui::ContextFactoryPrivate* context_factory_private,\n                       scoped_refptr<base::SingleThreadTaskRunner> task_runner,\n                       bool enable_surface_synchronization,\n                       bool enable_pixel_canvas,\n                       bool external_begin_frames_enabled,\n                       bool force_software_compositor,\n                       const char* trace_environment_name)\n    : context_factory_(context_factory),\n      context_factory_private_(context_factory_private),\n      frame_sink_id_(frame_sink_id),\n      task_runner_(task_runner),\n      vsync_manager_(new CompositorVSyncManager()),\n      external_begin_frames_enabled_(external_begin_frames_enabled),\n      force_software_compositor_(force_software_compositor),\n      layer_animator_collection_(this),\n      is_pixel_canvas_(enable_pixel_canvas),\n      lock_manager_(task_runner),\n      trace_environment_name_(trace_environment_name\n                                  ? trace_environment_name\n                                  : kDefaultTraceEnvironmentName),\n      context_creation_weak_ptr_factory_(this) {\n  if (context_factory_private) {\n     auto* host_frame_sink_manager =\n         context_factory_private_->GetHostFrameSinkManager();\n     host_frame_sink_manager->RegisterFrameSinkId(\n        frame_sink_id_, this, viz::ReportFirstSurfaceActivation::kYes);\n     host_frame_sink_manager->SetFrameSinkDebugLabel(frame_sink_id_,\n                                                     \"Compositor\");\n   }\n  root_web_layer_ = cc::Layer::Create();\n\n  base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();\n\n  cc::LayerTreeSettings settings;\n\n  settings.layers_always_allowed_lcd_text = true;\n  settings.use_occlusion_for_tile_prioritization = true;\n  refresh_rate_ = context_factory_->GetRefreshRate();\n  settings.main_frame_before_activation_enabled = false;\n  settings.delegated_sync_points_required =\n      context_factory_->SyncTokensRequiredForDisplayCompositor();\n\n  settings.enable_edge_anti_aliasing = false;\n\n  if (command_line->HasSwitch(switches::kLimitFps)) {\n    std::string fps_str =\n        command_line->GetSwitchValueASCII(switches::kLimitFps);\n    double fps;\n    if (base::StringToDouble(fps_str, &fps) && fps > 0) {\n      forced_refresh_rate_ = fps;\n    }\n  }\n\n  if (command_line->HasSwitch(cc::switches::kUIShowCompositedLayerBorders)) {\n    std::string layer_borders_string = command_line->GetSwitchValueASCII(\n        cc::switches::kUIShowCompositedLayerBorders);\n    std::vector<base::StringPiece> entries = base::SplitStringPiece(\n        layer_borders_string, \",\", base::TRIM_WHITESPACE, base::SPLIT_WANT_ALL);\n    if (entries.empty()) {\n      settings.initial_debug_state.show_debug_borders.set();\n    } else {\n      for (const auto& entry : entries) {\n        const struct {\n          const char* name;\n          cc::DebugBorderType type;\n        } kBorders[] = {{cc::switches::kCompositedRenderPassBorders,\n                         cc::DebugBorderType::RENDERPASS},\n                        {cc::switches::kCompositedSurfaceBorders,\n                         cc::DebugBorderType::SURFACE},\n                        {cc::switches::kCompositedLayerBorders,\n                         cc::DebugBorderType::LAYER}};\n        for (const auto& border : kBorders) {\n          if (border.name == entry) {\n            settings.initial_debug_state.show_debug_borders.set(border.type);\n            break;\n          }\n        }\n      }\n    }\n  }\n  settings.initial_debug_state.show_fps_counter =\n      command_line->HasSwitch(cc::switches::kUIShowFPSCounter);\n  settings.initial_debug_state.show_layer_animation_bounds_rects =\n      command_line->HasSwitch(cc::switches::kUIShowLayerAnimationBounds);\n  settings.initial_debug_state.show_paint_rects =\n      command_line->HasSwitch(switches::kUIShowPaintRects);\n  settings.initial_debug_state.show_property_changed_rects =\n      command_line->HasSwitch(cc::switches::kUIShowPropertyChangedRects);\n  settings.initial_debug_state.show_surface_damage_rects =\n      command_line->HasSwitch(cc::switches::kUIShowSurfaceDamageRects);\n  settings.initial_debug_state.show_screen_space_rects =\n      command_line->HasSwitch(cc::switches::kUIShowScreenSpaceRects);\n\n  settings.initial_debug_state.SetRecordRenderingStats(\n      command_line->HasSwitch(cc::switches::kEnableGpuBenchmarking));\n  settings.enable_surface_synchronization = enable_surface_synchronization;\n  settings.build_hit_test_data = features::IsVizHitTestingSurfaceLayerEnabled();\n\n  settings.use_zero_copy = IsUIZeroCopyEnabled();\n\n  settings.use_layer_lists =\n      command_line->HasSwitch(cc::switches::kUIEnableLayerLists);\n\n  settings.use_partial_raster = !settings.use_zero_copy;\n\n  settings.use_rgba_4444 =\n      command_line->HasSwitch(switches::kUIEnableRGBA4444Textures);\n\n#if defined(OS_MACOSX)\n  settings.resource_settings.use_gpu_memory_buffer_resources =\n      settings.use_zero_copy;\n  settings.enable_elastic_overscroll = true;\n#endif\n\n  settings.memory_policy.bytes_limit_when_visible = 512 * 1024 * 1024;\n  settings.memory_policy.priority_cutoff_when_visible =\n      gpu::MemoryAllocation::CUTOFF_ALLOW_NICE_TO_HAVE;\n\n  settings.disallow_non_exact_resource_reuse =\n      command_line->HasSwitch(switches::kDisallowNonExactResourceReuse);\n\n  if (command_line->HasSwitch(switches::kRunAllCompositorStagesBeforeDraw)) {\n    settings.wait_for_all_pipeline_stages_before_draw = true;\n    settings.enable_latency_recovery = false;\n  }\n\n  settings.always_request_presentation_time =\n      command_line->HasSwitch(cc::switches::kAlwaysRequestPresentationTime);\n\n  animation_host_ = cc::AnimationHost::CreateMainInstance();\n\n  cc::LayerTreeHost::InitParams params;\n  params.client = this;\n  params.task_graph_runner = context_factory_->GetTaskGraphRunner();\n  params.settings = &settings;\n  params.main_task_runner = task_runner_;\n  params.mutator_host = animation_host_.get();\n  host_ = cc::LayerTreeHost::CreateSingleThreaded(this, std::move(params));\n\n  if (base::FeatureList::IsEnabled(features::kUiCompositorScrollWithLayers) &&\n      host_->GetInputHandler()) {\n    scroll_input_handler_.reset(\n        new ScrollInputHandler(host_->GetInputHandler()));\n  }\n\n  animation_timeline_ =\n      cc::AnimationTimeline::Create(cc::AnimationIdProvider::NextTimelineId());\n  animation_host_->AddAnimationTimeline(animation_timeline_.get());\n\n  host_->SetHasGpuRasterizationTrigger(features::IsUiGpuRasterizationEnabled());\n  host_->SetRootLayer(root_web_layer_);\n  host_->SetVisible(true);\n\n  if (command_line->HasSwitch(switches::kUISlowAnimations)) {\n    slow_animations_ = std::make_unique<ScopedAnimationDurationScaleMode>(\n        ScopedAnimationDurationScaleMode::SLOW_DURATION);\n  }\n}\n", "target": 1, "idx": 186537}
{"func": "bool CopyDirectory(const FilePath& from_path,\n                   const FilePath& to_path,\n                   bool recursive) {\n  base::ThreadRestrictions::AssertIOAllowed();\n  DCHECK(to_path.value().find('*') == std::string::npos);\n  DCHECK(from_path.value().find('*') == std::string::npos);\n\n  char top_dir[PATH_MAX];\n  if (base::strlcpy(top_dir, from_path.value().c_str(),\n                    arraysize(top_dir)) >= arraysize(top_dir)) {\n    return false;\n  }\n\n  FilePath real_to_path = to_path;\n  if (PathExists(real_to_path)) {\n    if (!AbsolutePath(&real_to_path))\n      return false;\n  } else {\n    real_to_path = real_to_path.DirName();\n    if (!AbsolutePath(&real_to_path))\n      return false;\n  }\n  FilePath real_from_path = from_path;\n  if (!AbsolutePath(&real_from_path))\n    return false;\n  if (real_to_path.value().size() >= real_from_path.value().size() &&\n      real_to_path.value().compare(0, real_from_path.value().size(),\n      real_from_path.value()) == 0)\n    return false;\n\n  bool success = true;\n  int traverse_type = FileEnumerator::FILES | FileEnumerator::SHOW_SYM_LINKS;\n  if (recursive)\n    traverse_type |= FileEnumerator::DIRECTORIES;\n  FileEnumerator traversal(from_path, recursive, traverse_type);\n\n  FileEnumerator::FindInfo info;\n  FilePath current = from_path;\n  if (stat(from_path.value().c_str(), &info.stat) < 0) {\n    DLOG(ERROR) << \"CopyDirectory() couldn't stat source directory: \"\n                << from_path.value() << \" errno = \" << errno;\n    success = false;\n  }\n  struct stat to_path_stat;\n  FilePath from_path_base = from_path;\n  if (recursive && stat(to_path.value().c_str(), &to_path_stat) == 0 &&\n      S_ISDIR(to_path_stat.st_mode)) {\n    from_path_base = from_path.DirName();\n  }\n\n   DCHECK(recursive || S_ISDIR(info.stat.st_mode));\n \n   while (success && !current.empty()) {\n    std::string suffix(&current.value().c_str()[from_path_base.value().size()]);\n    if (!suffix.empty()) {\n      DCHECK_EQ('/', suffix[0]);\n      suffix.erase(0, 1);\n     }\n    const FilePath target_path = to_path.Append(suffix);\n \n     if (S_ISDIR(info.stat.st_mode)) {\n       if (mkdir(target_path.value().c_str(), info.stat.st_mode & 01777) != 0 &&\n          errno != EEXIST) {\n        DLOG(ERROR) << \"CopyDirectory() couldn't create directory: \"\n                    << target_path.value() << \" errno = \" << errno;\n        success = false;\n      }\n    } else if (S_ISREG(info.stat.st_mode)) {\n      if (!CopyFile(current, target_path)) {\n        DLOG(ERROR) << \"CopyDirectory() couldn't create file: \"\n                    << target_path.value();\n        success = false;\n      }\n    } else {\n      DLOG(WARNING) << \"CopyDirectory() skipping non-regular file: \"\n                    << current.value();\n    }\n\n    current = traversal.Next();\n    traversal.GetFindInfo(&info);\n  }\n\n  return success;\n}\n", "target": 1, "idx": 185107}
{"func": "int ext4_insert_range(struct inode *inode, loff_t offset, loff_t len)\n{\n\tstruct super_block *sb = inode->i_sb;\n\thandle_t *handle;\n\tstruct ext4_ext_path *path;\n\tstruct ext4_extent *extent;\n\text4_lblk_t offset_lblk, len_lblk, ee_start_lblk = 0;\n\tunsigned int credits, ee_len;\n\tint ret = 0, depth, split_flag = 0;\n\tloff_t ioffset;\n\n\t/*\n\t * We need to test this early because xfstests assumes that an\n\t * insert range of (0, 1) will return EOPNOTSUPP if the file\n\t * system does not support insert range.\n\t */\n\tif (!ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\treturn -EOPNOTSUPP;\n\n\t/* Insert range works only on fs block size aligned offsets. */\n\tif (offset & (EXT4_CLUSTER_SIZE(sb) - 1) ||\n\t\t\tlen & (EXT4_CLUSTER_SIZE(sb) - 1))\n\t\treturn -EINVAL;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\n\ttrace_ext4_insert_range(inode, offset, len);\n\n\toffset_lblk = offset >> EXT4_BLOCK_SIZE_BITS(sb);\n\tlen_lblk = len >> EXT4_BLOCK_SIZE_BITS(sb);\n\n\t/* Call ext4_force_commit to flush all data in case of data=journal */\n\tif (ext4_should_journal_data(inode)) {\n\t\tret = ext4_force_commit(inode->i_sb);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * Need to round down to align start offset to page size boundary\n\t * for page size > block size.\n\t */\n\tioffset = round_down(offset, PAGE_SIZE);\n\n\t/* Write out all dirty pages */\n\tret = filemap_write_and_wait_range(inode->i_mapping, ioffset,\n\t\t\tLLONG_MAX);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Take mutex lock */\n\tmutex_lock(&inode->i_mutex);\n\n\t/* Currently just for extent based files */\n\tif (!ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out_mutex;\n\t}\n\n\t/* Check for wrap through zero */\n\tif (inode->i_size + len > inode->i_sb->s_maxbytes) {\n\t\tret = -EFBIG;\n\t\tgoto out_mutex;\n\t}\n\n\t/* Offset should be less than i_size */\n\tif (offset >= i_size_read(inode)) {\n\t\tret = -EINVAL;\n \t\tgoto out_mutex;\n \t}\n \n\ttruncate_pagecache(inode, ioffset);\n \t/* Wait for existing dio to complete */\n \text4_inode_block_unlocked_dio(inode);\n \tinode_dio_wait(inode);\n \n \tcredits = ext4_writepage_trans_blocks(inode);\n \thandle = ext4_journal_start(inode, EXT4_HT_TRUNCATE, credits);\n \tif (IS_ERR(handle)) {\n \t\tret = PTR_ERR(handle);\n\t\tgoto out_dio;\n \t}\n \n \t/* Expand file to avoid data loss if there is error while shifting */\n\tinode->i_size += len;\n\tEXT4_I(inode)->i_disksize += len;\n\tinode->i_mtime = inode->i_ctime = ext4_current_time(inode);\n\tret = ext4_mark_inode_dirty(handle, inode);\n\tif (ret)\n\t\tgoto out_stop;\n\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\text4_discard_preallocations(inode);\n\n\tpath = ext4_find_extent(inode, offset_lblk, NULL, 0);\n\tif (IS_ERR(path)) {\n\t\tup_write(&EXT4_I(inode)->i_data_sem);\n\t\tgoto out_stop;\n\t}\n\n\tdepth = ext_depth(inode);\n\textent = path[depth].p_ext;\n\tif (extent) {\n\t\tee_start_lblk = le32_to_cpu(extent->ee_block);\n\t\tee_len = ext4_ext_get_actual_len(extent);\n\n\t\t/*\n\t\t * If offset_lblk is not the starting block of extent, split\n\t\t * the extent @offset_lblk\n\t\t */\n\t\tif ((offset_lblk > ee_start_lblk) &&\n\t\t\t\t(offset_lblk < (ee_start_lblk + ee_len))) {\n\t\t\tif (ext4_ext_is_unwritten(extent))\n\t\t\t\tsplit_flag = EXT4_EXT_MARK_UNWRIT1 |\n\t\t\t\t\tEXT4_EXT_MARK_UNWRIT2;\n\t\t\tret = ext4_split_extent_at(handle, inode, &path,\n\t\t\t\t\toffset_lblk, split_flag,\n\t\t\t\t\tEXT4_EX_NOCACHE |\n\t\t\t\t\tEXT4_GET_BLOCKS_PRE_IO |\n\t\t\t\t\tEXT4_GET_BLOCKS_METADATA_NOFAIL);\n\t\t}\n\n\t\text4_ext_drop_refs(path);\n\t\tkfree(path);\n\t\tif (ret < 0) {\n\t\t\tup_write(&EXT4_I(inode)->i_data_sem);\n\t\t\tgoto out_stop;\n\t\t}\n\t}\n\n\tret = ext4_es_remove_extent(inode, offset_lblk,\n\t\t\tEXT_MAX_BLOCKS - offset_lblk);\n\tif (ret) {\n\t\tup_write(&EXT4_I(inode)->i_data_sem);\n\t\tgoto out_stop;\n\t}\n\n\t/*\n\t * if offset_lblk lies in a hole which is at start of file, use\n\t * ee_start_lblk to shift extents\n\t */\n\tret = ext4_ext_shift_extents(inode, handle,\n\t\tee_start_lblk > offset_lblk ? ee_start_lblk : offset_lblk,\n\t\tlen_lblk, SHIFT_RIGHT);\n\n\tup_write(&EXT4_I(inode)->i_data_sem);\n\tif (IS_SYNC(inode))\n\t\text4_handle_sync(handle);\n \n out_stop:\n \text4_journal_stop(handle);\nout_dio:\n \text4_inode_resume_unlocked_dio(inode);\n out_mutex:\n \tmutex_unlock(&inode->i_mutex);\n\treturn ret;\n}\n", "target": 1, "idx": 180656}
{"func": "static void picolcd_remove(struct hid_device *hdev)\n{\n\tstruct picolcd_data *data = hid_get_drvdata(hdev);\n\tunsigned long flags;\n\n\tdbg_hid(PICOLCD_NAME \" hardware remove...\\n\");\n\tspin_lock_irqsave(&data->lock, flags);\n\tdata->status |= PICOLCD_FAILED;\n\tspin_unlock_irqrestore(&data->lock, flags);\n\n\tpicolcd_exit_devfs(data);\n\tdevice_remove_file(&hdev->dev, &dev_attr_operation_mode);\n\tdevice_remove_file(&hdev->dev, &dev_attr_operation_mode_delay);\n\thid_hw_close(hdev);\n\thid_hw_stop(hdev);\n\n\t/* Shortcut potential pending reply that will never arrive */\n\tspin_lock_irqsave(&data->lock, flags);\n\tif (data->pending)\n\t\tcomplete(&data->pending->ready);\n\tspin_unlock_irqrestore(&data->lock, flags);\n\n\t/* Cleanup LED */\n\tpicolcd_exit_leds(data);\n\t/* Clean up the framebuffer */\n\tpicolcd_exit_backlight(data);\n\tpicolcd_exit_lcd(data);\n\tpicolcd_exit_framebuffer(data);\n\t/* Cleanup input */\n\tpicolcd_exit_cir(data);\n\tpicolcd_exit_keys(data);\n\n\thid_set_drvdata(hdev, NULL);\n\tmutex_destroy(&data->mutex);\n\t/* Finally, clean up the picolcd data itself */\n\tkfree(data);\n}\n", "target": 0, "idx": 38076}
{"func": "void SyncBackendHost::HandleConnectionStatusChangeOnFrontendLoop(\n    sync_api::ConnectionStatus status) {\n  if (!frontend_)\n    return;\n\n  DCHECK_EQ(MessageLoop::current(), frontend_loop_);\n\n  frontend_->OnConnectionStatusChange(status);\n}\n", "target": 0, "idx": 111801}
{"func": "static MagickBooleanType WriteJBIGImage(const ImageInfo *image_info,\n  Image *image)\n{\n  double\n    version;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  MemoryInfo\n    *pixel_info;\n\n  register const PixelPacket\n    *p;\n\n  register ssize_t\n    x;\n\n  register unsigned char\n    *q;\n\n  size_t\n    number_packets;\n\n  ssize_t\n    y;\n\n  struct jbg_enc_state\n    jbig_info;\n\n  unsigned char\n    bit,\n    byte,\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(status);\n  version=StringToDouble(JBG_VERSION,(char **) NULL);\n  scene=0;\n  do\n  {\n    /*\n      Allocate pixel data.\n    */\n    (void) TransformImageColorspace(image,sRGBColorspace);\n    number_packets=(image->columns+7)/8;\n    pixel_info=AcquireVirtualMemory(number_packets,image->rows*sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    /*\n      Convert pixels to a bitmap.\n    */\n    (void) SetImageType(image,BilevelType);\n    q=pixels;\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n      if (p == (const PixelPacket *) NULL)\n        break;\n      bit=0;\n      byte=0;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        byte<<=1;\n        if (GetPixelLuma(image,p) < (QuantumRange/2.0))\n          byte|=0x01;\n        bit++;\n        if (bit == 8)\n          {\n            *q++=byte;\n            bit=0;\n            byte=0;\n          }\n        p++;\n      }\n      if (bit != 0)\n        *q++=byte << (8-bit);\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n    /*\n      Initialize JBIG info structure.\n    */\n    jbg_enc_init(&jbig_info,(unsigned long) image->columns,(unsigned long)\n      image->rows,1,&pixels,(void (*)(unsigned char *,size_t,void *))\n      JBIGEncode,image);\n    if (image_info->scene != 0)\n      jbg_enc_layers(&jbig_info,(int) image_info->scene);\n    else\n      {\n        size_t\n          x_resolution,\n          y_resolution;\n\n        x_resolution=640;\n        y_resolution=480;\n        if (image_info->density != (char *) NULL)\n          {\n            GeometryInfo\n              geometry_info;\n\n            MagickStatusType\n              flags;\n\n            flags=ParseGeometry(image_info->density,&geometry_info);\n            x_resolution=geometry_info.rho;\n            y_resolution=geometry_info.sigma;\n            if ((flags & SigmaValue) == 0)\n              y_resolution=x_resolution;\n          }\n        if (image->units == PixelsPerCentimeterResolution)\n          {\n            x_resolution=(size_t) (100.0*2.54*x_resolution+0.5)/100.0;\n            y_resolution=(size_t) (100.0*2.54*y_resolution+0.5)/100.0;\n          }\n        (void) jbg_enc_lrlmax(&jbig_info,(unsigned long) x_resolution,\n          (unsigned long) y_resolution);\n      }\n    (void) jbg_enc_lrange(&jbig_info,-1,-1);\n    jbg_enc_options(&jbig_info,JBG_ILEAVE | JBG_SMID,JBG_TPDON | JBG_TPBON |\n      JBG_DPON,version < 1.6 ? -1 : 0,-1,-1);\n    /*\n      Write JBIG image.\n    */\n    jbg_enc_out(&jbig_info);\n    jbg_enc_free(&jbig_info);\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n", "target": 0, "idx": 71581}
{"func": " bool IsSiteMuted(const TabStripModel& tab_strip, const int index) {\n   content::WebContents* web_contents = tab_strip.GetWebContentsAt(index);\n   GURL url = web_contents->GetLastCommittedURL();\n \n  if (url.SchemeIs(content::kChromeUIScheme)) {\n    return web_contents->IsAudioMuted() &&\n           GetTabAudioMutedReason(web_contents) ==\n               TabMutedReason::CONTENT_SETTING_CHROME;\n  }\n\n  Profile* profile =\n      Profile::FromBrowserContext(web_contents->GetBrowserContext());\n  HostContentSettingsMap* settings =\n      HostContentSettingsMapFactory::GetForProfile(profile);\n  return settings->GetContentSetting(url, url, CONTENT_SETTINGS_TYPE_SOUND,\n                                     std::string()) == CONTENT_SETTING_BLOCK;\n}\n", "target": 1, "idx": 185775}
{"func": "parse_group_prop_ntr_selection_method(struct ofpbuf *payload,\n                                      enum ofp11_group_type group_type,\n                                      enum ofp15_group_mod_command group_cmd,\n                                      struct ofputil_group_props *gp)\n{\n    struct ntr_group_prop_selection_method *prop = payload->data;\n    size_t fields_len, method_len;\n    enum ofperr error;\n\n    switch (group_type) {\n    case OFPGT11_SELECT:\n        break;\n    case OFPGT11_ALL:\n    case OFPGT11_INDIRECT:\n    case OFPGT11_FF:\n        OFPPROP_LOG(&bad_ofmsg_rl, false, \"ntr selection method property is \"\n                     \"only allowed for select groups\");\n         return OFPERR_OFPBPC_BAD_VALUE;\n     default:\n        OVS_NOT_REACHED();\n     }\n \n     switch (group_cmd) {\n    case OFPGC15_ADD:\n    case OFPGC15_MODIFY:\n    case OFPGC15_ADD_OR_MOD:\n        break;\n    case OFPGC15_DELETE:\n    case OFPGC15_INSERT_BUCKET:\n    case OFPGC15_REMOVE_BUCKET:\n        OFPPROP_LOG(&bad_ofmsg_rl, false, \"ntr selection method property is \"\n                     \"only allowed for add and delete group modifications\");\n         return OFPERR_OFPBPC_BAD_VALUE;\n     default:\n        OVS_NOT_REACHED();\n     }\n \n     if (payload->size < sizeof *prop) {\n        OFPPROP_LOG(&bad_ofmsg_rl, false, \"ntr selection method property \"\n                    \"length %u is not valid\", payload->size);\n        return OFPERR_OFPBPC_BAD_LEN;\n    }\n\n    method_len = strnlen(prop->selection_method, NTR_MAX_SELECTION_METHOD_LEN);\n\n    if (method_len == NTR_MAX_SELECTION_METHOD_LEN) {\n        OFPPROP_LOG(&bad_ofmsg_rl, false,\n                    \"ntr selection method is not null terminated\");\n        return OFPERR_OFPBPC_BAD_VALUE;\n    }\n\n    if (strcmp(\"hash\", prop->selection_method)\n        && strcmp(\"dp_hash\", prop->selection_method)) {\n        OFPPROP_LOG(&bad_ofmsg_rl, false,\n                    \"ntr selection method '%s' is not supported\",\n                    prop->selection_method);\n        return OFPERR_OFPBPC_BAD_VALUE;\n    }\n    /* 'method_len' is now non-zero. */\n\n    strcpy(gp->selection_method, prop->selection_method);\n    gp->selection_method_param = ntohll(prop->selection_method_param);\n\n    ofpbuf_pull(payload, sizeof *prop);\n\n    fields_len = ntohs(prop->length) - sizeof *prop;\n    if (fields_len && strcmp(\"hash\", gp->selection_method)) {\n        OFPPROP_LOG(&bad_ofmsg_rl, false, \"ntr selection method %s \"\n                    \"does not support fields\", gp->selection_method);\n        return OFPERR_OFPBPC_BAD_VALUE;\n    }\n\n    error = oxm_pull_field_array(payload->data, fields_len,\n                                 &gp->fields);\n    if (error) {\n        OFPPROP_LOG(&bad_ofmsg_rl, false,\n                    \"ntr selection method fields are invalid\");\n        return error;\n    }\n\n    return 0;\n}\n", "target": 1, "idx": 182197}
{"func": "void AppCacheUpdateJob::OnResponseInfoLoaded(\n    AppCacheResponseInfo* response_info, int64 response_id) {\n  const net::HttpResponseInfo* http_info = response_info ?\n      response_info->http_response_info() : NULL;\n\n  if (internal_state_ == FETCH_MANIFEST) {\n    if (http_info)\n      manifest_fetcher_->set_existing_response_headers(\n          http_info->headers.get());\n    manifest_fetcher_->Start();\n    return;\n  }\n\n  LoadingResponses::iterator found = loading_responses_.find(response_id);\n  DCHECK(found != loading_responses_.end());\n  const GURL& url = found->second;\n\n  if (!http_info) {\n    LoadFromNewestCacheFailed(url, NULL);  // no response found\n  } else {\n    const std::string name = \"vary\";\n    std::string value;\n    void* iter = NULL;\n    if (!http_info->headers.get() ||\n        http_info->headers->RequiresValidation(http_info->request_time,\n                                               http_info->response_time,\n                                               base::Time::Now()) ||\n        http_info->headers->EnumerateHeader(&iter, name, &value)) {\n      LoadFromNewestCacheFailed(url, response_info);\n    } else {\n      DCHECK(group_->newest_complete_cache());\n      AppCacheEntry* copy_me = group_->newest_complete_cache()->GetEntry(url);\n      DCHECK(copy_me);\n      DCHECK(copy_me->response_id() == response_id);\n\n      AppCache::EntryMap::iterator it = url_file_list_.find(url);\n      DCHECK(it != url_file_list_.end());\n      AppCacheEntry& entry = it->second;\n      entry.set_response_id(response_id);\n      entry.set_response_size(copy_me->response_size());\n      inprogress_cache_->AddOrModifyEntry(url, entry);\n      NotifyAllProgress(url);\n      ++url_fetches_completed_;\n    }\n  }\n  loading_responses_.erase(found);\n\n  MaybeCompleteUpdate();\n}\n", "target": 0, "idx": 135027}
{"func": "void exit_creds(struct task_struct *tsk)\n{\n\tstruct cred *cred;\n\n\tkdebug(\"exit_creds(%u,%p,%p,{%d,%d})\", tsk->pid, tsk->real_cred, tsk->cred,\n\t       atomic_read(&tsk->cred->usage),\n\t       read_cred_subscribers(tsk->cred));\n\n\tcred = (struct cred *) tsk->real_cred;\n\ttsk->real_cred = NULL;\n\tvalidate_creds(cred);\n\talter_cred_subscribers(cred, -1);\n\tput_cred(cred);\n\n\tcred = (struct cred *) tsk->cred;\n\ttsk->cred = NULL;\n\tvalidate_creds(cred);\n\talter_cred_subscribers(cred, -1);\n\tput_cred(cred);\n\n\tcred = (struct cred *) tsk->replacement_session_keyring;\n\tif (cred) {\n\t\ttsk->replacement_session_keyring = NULL;\n\t\tvalidate_creds(cred);\n\t\tput_cred(cred);\n\t}\n}\n", "target": 0, "idx": 19605}
{"func": "cdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h,\n    uint32_t offs, cdf_property_info_t **info, size_t *count, size_t *maxcount)\n{\n\tconst cdf_section_header_t *shp;\n\tcdf_section_header_t sh;\n\tconst uint8_t *p, *q, *e;\n\tint16_t s16;\n\tint32_t s32;\n\tuint32_t u32;\n\tint64_t s64;\n\tuint64_t u64;\n\tcdf_timestamp_t tp;\n\tsize_t i, o, o4, nelements, j;\n\tcdf_property_info_t *inp;\n\n\tif (offs > UINT32_MAX / 4) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tshp = CAST(const cdf_section_header_t *, (const void *)\n\t    ((const char *)sst->sst_tab + offs));\n\tif (cdf_check_stream_offset(sst, h, shp, sizeof(*shp), __LINE__) == -1)\n\t\tgoto out;\n\tsh.sh_len = CDF_TOLE4(shp->sh_len);\n#define CDF_SHLEN_LIMIT (UINT32_MAX / 8)\n\tif (sh.sh_len > CDF_SHLEN_LIMIT) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tsh.sh_properties = CDF_TOLE4(shp->sh_properties);\n#define CDF_PROP_LIMIT (UINT32_MAX / (4 * sizeof(*inp)))\n\tif (sh.sh_properties > CDF_PROP_LIMIT)\n\t\tgoto out;\n\tDPRINTF((\"section len: %u properties %u\\n\", sh.sh_len,\n\t    sh.sh_properties));\n\tif (*maxcount) {\n\t\tif (*maxcount > CDF_PROP_LIMIT)\n\t\t\tgoto out;\n\t\t*maxcount += sh.sh_properties;\n\t\tinp = CAST(cdf_property_info_t *,\n\t\t    realloc(*info, *maxcount * sizeof(*inp)));\n\t} else {\n\t\t*maxcount = sh.sh_properties;\n\t\tinp = CAST(cdf_property_info_t *,\n\t\t    malloc(*maxcount * sizeof(*inp)));\n\t}\n\tif (inp == NULL)\n\t\tgoto out;\n\t*info = inp;\n\tinp += *count;\n\t*count += sh.sh_properties;\n\tp = CAST(const uint8_t *, (const void *)\n\t    ((const char *)(const void *)sst->sst_tab +\n\t    offs + sizeof(sh)));\n\te = CAST(const uint8_t *, (const void *)\n\t    (((const char *)(const void *)shp) + sh.sh_len));\n\tif (cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1)\n\t\tgoto out;\n\tfor (i = 0; i < sh.sh_properties; i++) {\n\t\tq = (const uint8_t *)(const void *)\n\t\t    ((const char *)(const void *)p +\n\t\t    CDF_GETUINT32(p, (i << 1) + 1)) - 2 * sizeof(uint32_t);\n\t\tif (q > e) {\n\t\t\tDPRINTF((\"Ran of the end %p > %p\\n\", q, e));\n\t\t\tgoto out;\n\t\t}\n\t\tinp[i].pi_id = CDF_GETUINT32(p, i << 1);\n\t\tinp[i].pi_type = CDF_GETUINT32(q, 0);\n\t\tDPRINTF((\"%d) id=%x type=%x offs=%x,%d\\n\", i, inp[i].pi_id,\n\t\t    inp[i].pi_type, q - p, CDF_GETUINT32(p, (i << 1) + 1)));\n\t\tif (inp[i].pi_type & CDF_VECTOR) {\n\t\t\tnelements = CDF_GETUINT32(q, 1);\n\t\t\to = 2;\n\t\t} else {\n\t\t\tnelements = 1;\n\t\t\to = 1;\n\t\t}\n\t\to4 = o * sizeof(uint32_t);\n\t\tif (inp[i].pi_type & (CDF_ARRAY|CDF_BYREF|CDF_RESERVED))\n\t\t\tgoto unknown;\n\t\tswitch (inp[i].pi_type & CDF_TYPEMASK) {\n\t\tcase CDF_NULL:\n\t\tcase CDF_EMPTY:\n\t\t\tbreak;\n\t\tcase CDF_SIGNED16:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s16, &q[o4], sizeof(s16));\n\t\t\tinp[i].pi_s16 = CDF_TOLE2(s16);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED32:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s32, &q[o4], sizeof(s32));\n\t\t\tinp[i].pi_s32 = CDF_TOLE4((uint32_t)s32);\n\t\t\tbreak;\n\t\tcase CDF_BOOL:\n\t\tcase CDF_UNSIGNED32:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u32, &q[o4], sizeof(u32));\n\t\t\tinp[i].pi_u32 = CDF_TOLE4(u32);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED64:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s64, &q[o4], sizeof(s64));\n\t\t\tinp[i].pi_s64 = CDF_TOLE8((uint64_t)s64);\n\t\t\tbreak;\n\t\tcase CDF_UNSIGNED64:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u64, &q[o4], sizeof(u64));\n\t\t\tinp[i].pi_u64 = CDF_TOLE8((uint64_t)u64);\n\t\t\tbreak;\n\t\tcase CDF_LENGTH32_STRING:\n\t\tcase CDF_LENGTH32_WSTRING:\n\t\t\tif (nelements > 1) {\n\t\t\t\tsize_t nelem = inp - *info;\n\t\t\t\tif (*maxcount > CDF_PROP_LIMIT\n\t\t\t\t    || nelements > CDF_PROP_LIMIT)\n\t\t\t\t\tgoto out;\n\t\t\t\t*maxcount += nelements;\n\t\t\t\tinp = CAST(cdf_property_info_t *,\n\t\t\t\t    realloc(*info, *maxcount * sizeof(*inp)));\n\t\t\t\tif (inp == NULL)\n\t\t\t\t\tgoto out;\n\t\t\t\t*info = inp;\n\t\t\t\tinp = *info + nelem;\n\t\t\t}\n\t\t\tDPRINTF((\"nelements = %d\\n\", nelements));\n\t\t\tfor (j = 0; j < nelements; j++, i++) {\n\t\t\t\tuint32_t l = CDF_GETUINT32(q, o);\n\t\t\t\tinp[i].pi_str.s_len = l;\n\t\t\t\tinp[i].pi_str.s_buf = (const char *)\n\t\t\t\t    (const void *)(&q[o4 + sizeof(l)]);\n\t\t\t\tDPRINTF((\"l = %d, r = %d, s = %s\\n\", l,\n\t\t\t\t    CDF_ROUND(l, sizeof(l)),\n \t\t\t\t    inp[i].pi_str.s_buf));\n \t\t\t\tl = 4 + (uint32_t)CDF_ROUND(l, sizeof(l));\n \t\t\t\to += l >> 2;\n \t\t\t\to4 = o * sizeof(uint32_t);\n \t\t\t}\n \t\t\ti--;\n\t\t\tbreak;\n\t\tcase CDF_FILETIME:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&tp, &q[o4], sizeof(tp));\n\t\t\tinp[i].pi_tp = CDF_TOLE8((uint64_t)tp);\n\t\t\tbreak;\n\t\tcase CDF_CLIPBOARD:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tdefault:\n\t\tunknown:\n\t\t\tDPRINTF((\"Don't know how to deal with %x\\n\",\n\t\t\t    inp[i].pi_type));\n\t\t\tgoto out;\n\t\t}\n\t}\n\treturn 0;\nout:\n\tfree(*info);\n\treturn -1;\n}\n", "target": 1, "idx": 183054}
{"func": "void br_netfilter_rtable_init(struct net_bridge *br)\n{\n\tstruct rtable *rt = &br->fake_rtable;\n\n\tatomic_set(&rt->dst.__refcnt, 1);\n\trt->dst.dev = br->dev;\n\trt->dst.path = &rt->dst;\n\tdst_metric_set(&rt->dst, RTAX_MTU, 1500);\n\trt->dst.flags\t= DST_NOXFRM;\n\trt->dst.ops = &fake_dst_ops;\n}\n", "target": 0, "idx": 34706}
{"func": "int orangefs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tstruct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);\n\tint error = 0;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tconst char *name = NULL;\n\n\tswitch (type) {\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n\t\t\tumode_t mode = inode->i_mode;\n\t\t\t/*\n\t\t\t * can we represent this with the traditional file\n\t\t\t * mode permission bits?\n\t\t\t */\n\t\t\terror = posix_acl_equiv_mode(acl, &mode);\n\t\t\tif (error < 0) {\n\t\t\t\tgossip_err(\"%s: posix_acl_equiv_mode err: %d\\n\",\n \t\t\t\t\t   __func__,\n \t\t\t\t\t   error);\n \t\t\t\treturn error;\n\t\t\t}\n\n\t\t\tif (inode->i_mode != mode)\n \t\t\t\tSetModeFlag(orangefs_inode);\n \t\t\tinode->i_mode = mode;\n \t\t\tmark_inode_dirty_sync(inode);\n\t\t\tif (error == 0)\n\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tgossip_err(\"%s: invalid type %d!\\n\", __func__, type);\n\t\treturn -EINVAL;\n\t}\n\n\tgossip_debug(GOSSIP_ACL_DEBUG,\n\t\t     \"%s: inode %pU, key %s type %d\\n\",\n\t\t     __func__, get_khandle_from_ino(inode),\n\t\t     name,\n\t\t     type);\n\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmalloc(size, GFP_KERNEL);\n\t\tif (!value)\n\t\t\treturn -ENOMEM;\n\n\t\terror = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (error < 0)\n\t\t\tgoto out;\n\t}\n\n\tgossip_debug(GOSSIP_ACL_DEBUG,\n\t\t     \"%s: name %s, value %p, size %zd, acl %p\\n\",\n\t\t     __func__, name, value, size, acl);\n\t/*\n\t * Go ahead and set the extended attribute now. NOTE: Suppose acl\n\t * was NULL, then value will be NULL and size will be 0 and that\n\t * will xlate to a removexattr. However, we don't want removexattr\n\t * complain if attributes does not exist.\n\t */\n\terror = orangefs_inode_setxattr(inode, name, value, size, 0);\n\nout:\n\tkfree(value);\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\treturn error;\n}\n", "target": 1, "idx": 180149}
{"func": "void RenderFrameHostImpl::OnJavaScriptExecuteResponse(\n    int id, const base::ListValue& result) {\n  const base::Value* result_value;\n  if (!result.Get(0, &result_value)) {\n    NOTREACHED() << \"Got bad arguments for OnJavaScriptExecuteResponse\";\n    return;\n  }\n\n  auto it = javascript_callbacks_.find(id);\n  if (it != javascript_callbacks_.end()) {\n    it->second.Run(result_value);\n    javascript_callbacks_.erase(it);\n  } else {\n    NOTREACHED() << \"Received script response for unknown request\";\n  }\n}\n", "target": 0, "idx": 166146}
{"func": "GahpServer::RemoveGahpClient()\n{\n\tm_reference_count--;\n\n\tif ( m_reference_count <= 0 ) {\n\t\tm_deleteMeTid = daemonCore->Register_Timer( 30,\n\t\t\t\t\t\t\t\t(TimerHandlercpp)&GahpServer::DeleteMe,\n\t\t\t\t\t\t\t\t\"GahpServer::DeleteMe\", (Service*)this );\n\t}\n}\n", "target": 0, "idx": 16122}
{"func": "static int entersafe_process_fci(struct sc_card *card, struct sc_file *file,\n\t\t\t\t\t\t  const u8 *buf, size_t buflen)\n{\n\t int r;\n\n\t assert(file);\n\t SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\t r = iso_ops->process_fci(card,file,buf,buflen);\n\t SC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"Process fci failed\");\n\n\t if(file->namelen)\n\t {\n\t\t  file->type = SC_FILE_TYPE_DF;\n\t\t  file->ef_structure = SC_FILE_EF_UNKNOWN;\n\t }\n\t else\n\t {\n\t\t  file->type = SC_FILE_TYPE_WORKING_EF;\n\t\t  file->ef_structure = SC_FILE_EF_TRANSPARENT;\n\t }\n\n\t SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);\n}\n", "target": 0, "idx": 78351}
{"func": "static int handle_cmd(AHCIState *s, int port, uint8_t slot)\n{\n    IDEState *ide_state;\n    uint64_t tbl_addr;\n    AHCICmdHdr *cmd;\n    uint8_t *cmd_fis;\n    dma_addr_t cmd_len;\n\n    if (s->dev[port].port.ifs[0].status & (BUSY_STAT|DRQ_STAT)) {\n        /* Engine currently busy, try again later */\n        DPRINTF(port, \"engine busy\\n\");\n        return -1;\n    }\n\n    if (!s->dev[port].lst) {\n        DPRINTF(port, \"error: lst not given but cmd handled\");\n        return -1;\n    }\n    cmd = get_cmd_header(s, port, slot);\n    /* remember current slot handle for later */\n    s->dev[port].cur_cmd = cmd;\n\n    /* The device we are working for */\n    ide_state = &s->dev[port].port.ifs[0];\n    if (!ide_state->blk) {\n        DPRINTF(port, \"error: guest accessed unused port\");\n        return -1;\n    }\n\n    tbl_addr = le64_to_cpu(cmd->tbl_addr);\n    cmd_len = 0x80;\n    cmd_fis = dma_memory_map(s->as, tbl_addr, &cmd_len,\n                             DMA_DIRECTION_FROM_DEVICE);\n    if (!cmd_fis) {\n        DPRINTF(port, \"error: guest passed us an invalid cmd fis\\n\");\n        return -1;\n    } else if (cmd_len != 0x80) {\n        ahci_trigger_irq(s, &s->dev[port], PORT_IRQ_HBUS_ERR);\n        DPRINTF(port, \"error: dma_memory_map failed: \"\n                \"(len(%02\"PRIx64\") != 0x80)\\n\",\n                cmd_len);\n        goto out;\n    }\n    debug_print_fis(cmd_fis, 0x80);\n\n    switch (cmd_fis[0]) {\n        case SATA_FIS_TYPE_REGISTER_H2D:\n            handle_reg_h2d_fis(s, port, slot, cmd_fis);\n            break;\n        default:\n            DPRINTF(port, \"unknown command cmd_fis[0]=%02x cmd_fis[1]=%02x \"\n                          \"cmd_fis[2]=%02x\\n\", cmd_fis[0], cmd_fis[1],\n                          cmd_fis[2]);\n            break;\n    }\n\nout:\n    dma_memory_unmap(s->as, cmd_fis, cmd_len, DMA_DIRECTION_FROM_DEVICE,\n                     cmd_len);\n\n    if (s->dev[port].port.ifs[0].status & (BUSY_STAT|DRQ_STAT)) {\n        /* async command, complete later */\n        s->dev[port].busy_slot = slot;\n        return -1;\n    }\n\n    /* done handling the command */\n    return 0;\n}\n", "target": 0, "idx": 5892}
{"func": "static int authenticate_and_decrypt_nss_2_0 (\n\tstruct crypto_instance *instance,\n\tunsigned char *buf,\n\tint *buf_len)\n{\n\tif (hash_to_nss[instance->crypto_hash_type]) {\n\t\tunsigned char\ttmp_hash[hash_len[instance->crypto_hash_type]];\n\t\tunsigned char\t*hash = buf;\n\t\tunsigned char\t*data = hash + hash_len[instance->crypto_hash_type];\n\t\tint\t\tdatalen = *buf_len - hash_len[instance->crypto_hash_type];\n\n\t\tif (calculate_nss_hash(instance, data, datalen, tmp_hash) < 0) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (memcmp(tmp_hash, hash, hash_len[instance->crypto_hash_type]) != 0) {\n\t\t\tlog_printf(instance->log_level_error, \"Digest does not match\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tmemmove(buf, data, datalen);\n\t\t*buf_len = datalen;\n\t}\n\n\tif (decrypt_nss(instance, buf, buf_len) < 0) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n", "target": 0, "idx": 41052}
{"func": "static void parse_error(struct filter_parse_error *pe, int err, int pos)\n{\n\tpe->lasterr = err;\n\tpe->lasterr_pos = pos;\n}\n", "target": 0, "idx": 81593}
{"func": "void RenderFrameImpl::OnJavaScriptExecuteRequestInIsolatedWorld(\n    const base::string16& jscript,\n    int id,\n    bool notify_result,\n    int world_id) {\n  TRACE_EVENT_INSTANT0(\"test_tracing\",\n                       \"OnJavaScriptExecuteRequestInIsolatedWorld\",\n                       TRACE_EVENT_SCOPE_THREAD);\n\n  if (world_id <= ISOLATED_WORLD_ID_GLOBAL ||\n      world_id > ISOLATED_WORLD_ID_MAX) {\n    NOTREACHED();\n    return;\n  }\n\n  v8::HandleScope handle_scope(v8::Isolate::GetCurrent());\n  WebScriptSource script = WebScriptSource(jscript);\n  JavaScriptIsolatedWorldRequest* request = new JavaScriptIsolatedWorldRequest(\n      id, notify_result, routing_id_, weak_factory_.GetWeakPtr());\n  frame_->requestExecuteScriptInIsolatedWorld(world_id, &script, 1, 0, false,\n                                              request);\n}\n", "target": 0, "idx": 132242}
{"func": "int jas_stream_write(jas_stream_t *stream, const void *buf, int cnt)\n{\n\tint n;\n\tconst char *bufptr;\n\n\tJAS_DBGLOG(100, (\"jas_stream_write(%p, %p, %d)\\n\", stream, buf, cnt));\n\n\tif (cnt < 0) {\n\t\tjas_deprecated(\"negative count for jas_stream_write\");\n\t}\n\n\tbufptr = buf;\n\n\tn = 0;\n\twhile (n < cnt) {\n\t\tif (jas_stream_putc(stream, *bufptr) == EOF) {\n\t\t\treturn n;\n\t\t}\n\t\t++bufptr;\n\t\t++n;\n\t}\n\n\treturn n;\n}\n", "target": 0, "idx": 72801}
{"func": "void ResourceMessageFilter::OnGetCookies(const GURL& url,\n                                         const GURL& first_party_for_cookies,\n                                         IPC::Message* reply_msg) {\n  URLRequestContext* context = GetRequestContextForURL(url);\n\n  GetCookiesCompletion* callback =\n      new GetCookiesCompletion(url, reply_msg, this, context);\n\n  int policy = net::OK;\n  if (context->cookie_policy()) {\n    policy = context->cookie_policy()->CanGetCookies(\n        url, first_party_for_cookies, callback);\n    if (policy == net::ERR_IO_PENDING) {\n      Send(new ViewMsg_SignalCookiePromptEvent());\n      return;\n    }\n  }\n  callback->Run(policy);\n}\n", "target": 0, "idx": 99297}
{"func": "bool BrowserRenderProcessHost::Send(IPC::Message* msg) {\n  if (!channel_.get()) {\n    delete msg;\n    return false;\n  }\n  return channel_->Send(msg);\n}\n", "target": 0, "idx": 100392}
{"func": "  Ins_OR( INS_ARG )\n  {\n    DO_OR\n  }\n", "target": 0, "idx": 10145}
{"func": "_tiffMapProc(thandle_t fd, tdata_t* pbase, toff_t* psize)\n{\n\treturn (0);\n}\n", "target": 0, "idx": 86790}
{"func": "TEE_Result tee_mmu_check_access_rights(const struct user_ta_ctx *utc,\n\t\t\t\t       uint32_t flags, uaddr_t uaddr,\n \t\t\t\t       size_t len)\n {\n \tuaddr_t a;\n \tsize_t addr_incr = MIN(CORE_MMU_USER_CODE_SIZE,\n \t\t\t       CORE_MMU_USER_PARAM_SIZE);\n \n\tif (ADD_OVERFLOW(uaddr, len, &a))\n \t\treturn TEE_ERROR_ACCESS_DENIED;\n \n \tif ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&\n\t    (flags & TEE_MEMORY_ACCESS_SECURE))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\n\t/*\n\t * Rely on TA private memory test to check if address range is private\n\t * to TA or not.\n\t */\n\tif (!(flags & TEE_MEMORY_ACCESS_ANY_OWNER) &&\n \t   !tee_mmu_is_vbuf_inside_ta_private(utc, (void *)uaddr, len))\n \t\treturn TEE_ERROR_ACCESS_DENIED;\n \n\tfor (a = uaddr; a < (uaddr + len); a += addr_incr) {\n \t\tuint32_t attr;\n \t\tTEE_Result res;\n \n\t\tres = tee_mmu_user_va2pa_attr(utc, (void *)a, NULL, &attr);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\n\t\tif ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&\n\t\t    (attr & TEE_MATTR_SECURE))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\n\t\tif ((flags & TEE_MEMORY_ACCESS_SECURE) &&\n\t\t    !(attr & TEE_MATTR_SECURE))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\n\t\tif ((flags & TEE_MEMORY_ACCESS_WRITE) && !(attr & TEE_MATTR_UW))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t\tif ((flags & TEE_MEMORY_ACCESS_READ) && !(attr & TEE_MATTR_UR))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t}\n\n\treturn TEE_SUCCESS;\n}\n", "target": 1, "idx": 182645}
{"func": "void AXObjectCacheImpl::handleAriaSelectedChanged(Node* node) {\n  AXObject* obj = get(node);\n  if (!obj)\n    return;\n\n  postNotification(obj, AXCheckedStateChanged);\n\n  AXObject* listbox = obj->parentObjectUnignored();\n  if (listbox && listbox->roleValue() == ListBoxRole)\n    postNotification(listbox, AXSelectedChildrenChanged);\n}\n", "target": 0, "idx": 138246}
{"func": "static bool cgroupfs_mount_cgroup(void *hdata, const char *root, int type)\n{\n\tsize_t bufsz = strlen(root) + sizeof(\"/sys/fs/cgroup\");\n\tchar *path = NULL;\n\tchar **parts = NULL;\n\tchar *dirname = NULL;\n\tchar *abs_path = NULL;\n\tchar *abs_path2 = NULL;\n\tstruct cgfs_data *cgfs_d;\n\tstruct cgroup_process_info *info, *base_info;\n\tint r, saved_errno = 0;\n\n\tcgfs_d = hdata;\n\tif (!cgfs_d)\n\t\treturn false;\n\tbase_info = cgfs_d->info;\n\n\t/* If we get passed the _NOSPEC types, we default to _MIXED, since we don't\n\t * have access to the lxc_conf object at this point. It really should be up\n\t * to the caller to fix this, but this doesn't really hurt.\n\t */\n\tif (type == LXC_AUTO_CGROUP_FULL_NOSPEC)\n\t\ttype = LXC_AUTO_CGROUP_FULL_MIXED;\n\telse if (type == LXC_AUTO_CGROUP_NOSPEC)\n\t\ttype = LXC_AUTO_CGROUP_MIXED;\n\n\tif (type < LXC_AUTO_CGROUP_RO || type > LXC_AUTO_CGROUP_FULL_MIXED) {\n\t\tERROR(\"could not mount cgroups into container: invalid type specified internally\");\n\t\terrno = EINVAL;\n\t\treturn false;\n\t}\n\n\tpath = calloc(1, bufsz);\n \tif (!path)\n \t\treturn false;\n \tsnprintf(path, bufsz, \"%s/sys/fs/cgroup\", root);\n\tr = mount(\"cgroup_root\", path, \"tmpfs\", MS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME, \"size=10240k,mode=755\");\n \tif (r < 0) {\n \t\tSYSERROR(\"could not mount tmpfs to /sys/fs/cgroup in the container\");\n \t\treturn false;\n\t}\n\n\t/* now mount all the hierarchies we care about */\n\tfor (info = base_info; info; info = info->next) {\n\t\tsize_t subsystem_count, i;\n\t\tstruct cgroup_mount_point *mp = info->designated_mount_point;\n\t\tif (!mp)\n\t\t\tmp = lxc_cgroup_find_mount_point(info->hierarchy, info->cgroup_path, true);\n\t\tif (!mp) {\n\t\t\tSYSERROR(\"could not find original mount point for cgroup hierarchy while trying to mount cgroup filesystem\");\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tsubsystem_count = lxc_array_len((void **)info->hierarchy->subsystems);\n\t\tparts = calloc(subsystem_count + 1, sizeof(char *));\n\t\tif (!parts)\n\t\t\tgoto out_error;\n\n\t\tfor (i = 0; i < subsystem_count; i++) {\n\t\t\tif (!strncmp(info->hierarchy->subsystems[i], \"name=\", 5))\n\t\t\t\tparts[i] = info->hierarchy->subsystems[i] + 5;\n\t\t\telse\n\t\t\t\tparts[i] = info->hierarchy->subsystems[i];\n\t\t}\n\t\tdirname = lxc_string_join(\",\", (const char **)parts, false);\n\t\tif (!dirname)\n\t\t\tgoto out_error;\n\n\t\t/* create subsystem directory */\n\t\tabs_path = lxc_append_paths(path, dirname);\n\t\tif (!abs_path)\n\t\t\tgoto out_error;\n\t\tr = mkdir_p(abs_path, 0755);\n\t\tif (r < 0 && errno != EEXIST) {\n\t\t\tSYSERROR(\"could not create cgroup subsystem directory /sys/fs/cgroup/%s\", dirname);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tabs_path2 = lxc_append_paths(abs_path, info->cgroup_path);\n\t\tif (!abs_path2)\n\t\t\tgoto out_error;\n\n\t\tif (type == LXC_AUTO_CGROUP_FULL_RO || type == LXC_AUTO_CGROUP_FULL_RW || type == LXC_AUTO_CGROUP_FULL_MIXED) {\n\t\t\t/* bind-mount the cgroup entire filesystem there */\n\t\t\tif (strcmp(mp->mount_prefix, \"/\") != 0) {\n\t\t\t\t/* FIXME: maybe we should just try to remount the entire hierarchy\n\t\t\t\t *        with a regular mount command? may that works? */\n\t\t\t\tERROR(\"could not automatically mount cgroup-full to /sys/fs/cgroup/%s: host has no mount point for this cgroup filesystem that has access to the root cgroup\", dirname);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tr = mount(mp->mount_point, abs_path, \"none\", MS_BIND, 0);\n\t\t\tif (r < 0) {\n\t\t\t\tSYSERROR(\"error bind-mounting %s to %s\", mp->mount_point, abs_path);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\t/* main cgroup path should be read-only */\n\t\t\tif (type == LXC_AUTO_CGROUP_FULL_RO || type == LXC_AUTO_CGROUP_FULL_MIXED) {\n\t\t\t\tr = mount(NULL, abs_path, NULL, MS_REMOUNT|MS_BIND|MS_RDONLY, NULL);\n\t\t\t\tif (r < 0) {\n\t\t\t\t\tSYSERROR(\"error re-mounting %s readonly\", abs_path);\n\t\t\t\t\tgoto out_error;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* own cgroup should be read-write */\n\t\t\tif (type == LXC_AUTO_CGROUP_FULL_MIXED) {\n\t\t\t\tr = mount(abs_path2, abs_path2, NULL, MS_BIND, NULL);\n\t\t\t\tif (r < 0) {\n\t\t\t\t\tSYSERROR(\"error bind-mounting %s onto itself\", abs_path2);\n\t\t\t\t\tgoto out_error;\n\t\t\t\t}\n\t\t\t\tr = mount(NULL, abs_path2, NULL, MS_REMOUNT|MS_BIND, NULL);\n\t\t\t\tif (r < 0) {\n\t\t\t\t\tSYSERROR(\"error re-mounting %s readwrite\", abs_path2);\n\t\t\t\t\tgoto out_error;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t/* create path for container's cgroup */\n\t\t\tr = mkdir_p(abs_path2, 0755);\n\t\t\tif (r < 0 && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"could not create cgroup directory /sys/fs/cgroup/%s%s\", dirname, info->cgroup_path);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\n\t\t\t/* for read-only and mixed cases, we have to bind-mount the tmpfs directory\n\t\t\t * that points to the hierarchy itself (i.e. /sys/fs/cgroup/cpu etc.) onto\n\t\t\t * itself and then bind-mount it read-only, since we keep the tmpfs itself\n\t\t\t * read-write (see comment below)\n\t\t\t */\n\t\t\tif (type == LXC_AUTO_CGROUP_MIXED || type == LXC_AUTO_CGROUP_RO) {\n\t\t\t\tr = mount(abs_path, abs_path, NULL, MS_BIND, NULL);\n\t\t\t\tif (r < 0) {\n\t\t\t\t\tSYSERROR(\"error bind-mounting %s onto itself\", abs_path);\n\t\t\t\t\tgoto out_error;\n\t\t\t\t}\n\t\t\t\tr = mount(NULL, abs_path, NULL, MS_REMOUNT|MS_BIND|MS_RDONLY, NULL);\n\t\t\t\tif (r < 0) {\n\t\t\t\t\tSYSERROR(\"error re-mounting %s readonly\", abs_path);\n\t\t\t\t\tgoto out_error;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfree(abs_path);\n\t\t\tabs_path = NULL;\n\n\t\t\t/* bind-mount container's cgroup to that directory */\n\t\t\tabs_path = cgroup_to_absolute_path(mp, info->cgroup_path, NULL);\n\t\t\tif (!abs_path)\n\t\t\t\tgoto out_error;\n\t\t\tr = mount(abs_path, abs_path2, \"none\", MS_BIND, 0);\n\t\t\tif (r < 0) {\n\t\t\t\tSYSERROR(\"error bind-mounting %s to %s\", abs_path, abs_path2);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tif (type == LXC_AUTO_CGROUP_RO) {\n\t\t\t\tr = mount(NULL, abs_path2, NULL, MS_REMOUNT|MS_BIND|MS_RDONLY, NULL);\n\t\t\t\tif (r < 0) {\n\t\t\t\t\tSYSERROR(\"error re-mounting %s readonly\", abs_path2);\n\t\t\t\t\tgoto out_error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfree(abs_path);\n\t\tfree(abs_path2);\n\t\tabs_path = NULL;\n\t\tabs_path2 = NULL;\n\n\t\t/* add symlinks for every single subsystem */\n\t\tif (subsystem_count > 1) {\n\t\t\tfor (i = 0; i < subsystem_count; i++) {\n\t\t\t\tabs_path = lxc_append_paths(path, parts[i]);\n\t\t\t\tif (!abs_path)\n\t\t\t\t\tgoto out_error;\n\t\t\t\tr = symlink(dirname, abs_path);\n\t\t\t\tif (r < 0)\n\t\t\t\t\tWARN(\"could not create symlink %s -> %s in /sys/fs/cgroup of container\", parts[i], dirname);\n\t\t\t\tfree(abs_path);\n\t\t\t\tabs_path = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(dirname);\n\t\tfree(parts);\n\t\tdirname = NULL;\n\t\tparts = NULL;\n\t}\n\n\t/* We used to remount the entire tmpfs readonly if any :ro or\n\t * :mixed mode was specified. However, Ubuntu's mountall has the\n\t * unfortunate behavior to block bootup if /sys/fs/cgroup is\n\t * mounted read-only and cannot be remounted read-write.\n\t * (mountall reads /lib/init/fstab and tries to (re-)mount all of\n\t * these if they are not already mounted with the right options;\n\t * it contains an entry for /sys/fs/cgroup. In case it can't do\n\t * that, it prompts for the user to either manually fix it or\n\t * boot anyway. But without user input, booting of the container\n\t * hangs.)\n\t *\n\t * Instead of remounting the entire tmpfs readonly, we only\n\t * remount the paths readonly that are part of the cgroup\n\t * hierarchy.\n\t */\n\n\tfree(path);\n\n\treturn true;\n\nout_error:\n\tsaved_errno = errno;\n\tfree(path);\n\tfree(dirname);\n\tfree(parts);\n\tfree(abs_path);\n\tfree(abs_path2);\n\terrno = saved_errno;\n\treturn false;\n}\n", "target": 1, "idx": 179881}
{"func": "xsltDocumentElem(xsltTransformContextPtr ctxt, xmlNodePtr node,\n                 xmlNodePtr inst, xsltStylePreCompPtr castedComp)\n{\n#ifdef XSLT_REFACTORED\n    xsltStyleItemDocumentPtr comp = (xsltStyleItemDocumentPtr) castedComp;\n#else\n    xsltStylePreCompPtr comp = castedComp;\n#endif\n    xsltStylesheetPtr style = NULL;\n    int ret;\n    xmlChar *filename = NULL, *prop, *elements;\n    xmlChar *element, *end;\n    xmlDocPtr res = NULL;\n    xmlDocPtr oldOutput;\n    xmlNodePtr oldInsert, root;\n    const char *oldOutputFile;\n    xsltOutputType oldType;\n    xmlChar *URL = NULL;\n    const xmlChar *method;\n    const xmlChar *doctypePublic;\n    const xmlChar *doctypeSystem;\n    const xmlChar *version;\n    const xmlChar *encoding;\n    int redirect_write_append = 0;\n\n    if ((ctxt == NULL) || (node == NULL) || (inst == NULL) || (comp == NULL))\n        return;\n\n    if (comp->filename == NULL) {\n\n        if (xmlStrEqual(inst->name, (const xmlChar *) \"output\")) {\n\t    /*\n\t    * The element \"output\" is in the namespace XSLT_SAXON_NAMESPACE\n\t    *   (http://icl.com/saxon)\n\t    * The @file is in no namespace.\n\t    */\n#ifdef WITH_XSLT_DEBUG_EXTRA\n            xsltGenericDebug(xsltGenericDebugContext,\n                             \"Found saxon:output extension\\n\");\n#endif\n            URL = xsltEvalAttrValueTemplate(ctxt, inst,\n                                                 (const xmlChar *) \"file\",\n                                                 XSLT_SAXON_NAMESPACE);\n\n\t    if (URL == NULL)\n\t\tURL = xsltEvalAttrValueTemplate(ctxt, inst,\n                                                 (const xmlChar *) \"href\",\n                                                 XSLT_SAXON_NAMESPACE);\n        } else if (xmlStrEqual(inst->name, (const xmlChar *) \"write\")) {\n#ifdef WITH_XSLT_DEBUG_EXTRA\n            xsltGenericDebug(xsltGenericDebugContext,\n                             \"Found xalan:write extension\\n\");\n#endif\n            URL = xsltEvalAttrValueTemplate(ctxt, inst,\n                                                 (const xmlChar *)\n                                                 \"select\",\n                                                 XSLT_XALAN_NAMESPACE);\n\t    if (URL != NULL) {\n\t\txmlXPathCompExprPtr cmp;\n\t\txmlChar *val;\n\n\t\t/*\n\t\t * Trying to handle bug #59212\n\t\t * The value of the \"select\" attribute is an\n\t\t * XPath expression.\n\t\t * (see http://xml.apache.org/xalan-j/extensionslib.html#redirect)\n\t\t */\n\t\tcmp = xmlXPathCompile(URL);\n                val = xsltEvalXPathString(ctxt, cmp);\n\t\txmlXPathFreeCompExpr(cmp);\n\t\txmlFree(URL);\n\t\tURL = val;\n\t    }\n\t    if (URL == NULL)\n\t\tURL = xsltEvalAttrValueTemplate(ctxt, inst,\n\t\t\t\t\t\t     (const xmlChar *)\n\t\t\t\t\t\t     \"file\",\n\t\t\t\t\t\t     XSLT_XALAN_NAMESPACE);\n\t    if (URL == NULL)\n\t\tURL = xsltEvalAttrValueTemplate(ctxt, inst,\n\t\t\t\t\t\t     (const xmlChar *)\n\t\t\t\t\t\t     \"href\",\n\t\t\t\t\t\t     XSLT_XALAN_NAMESPACE);\n        } else if (xmlStrEqual(inst->name, (const xmlChar *) \"document\")) {\n            URL = xsltEvalAttrValueTemplate(ctxt, inst,\n                                                 (const xmlChar *) \"href\",\n                                                 NULL);\n        }\n\n    } else {\n        URL = xmlStrdup(comp->filename);\n    }\n\n    if (URL == NULL) {\n\txsltTransformError(ctxt, NULL, inst,\n\t\t         \"xsltDocumentElem: href/URI-Reference not found\\n\");\n\treturn;\n    }\n\n    /*\n     * If the computation failed, it's likely that the URL wasn't escaped\n     */\n    filename = xmlBuildURI(URL, (const xmlChar *) ctxt->outputFile);\n    if (filename == NULL) {\n\txmlChar *escURL;\n\n\tescURL=xmlURIEscapeStr(URL, BAD_CAST \":/.?,\");\n\tif (escURL != NULL) {\n\t    filename = xmlBuildURI(escURL, (const xmlChar *) ctxt->outputFile);\n\t    xmlFree(escURL);\n\t}\n    }\n\n    if (filename == NULL) {\n\txsltTransformError(ctxt, NULL, inst,\n\t\t         \"xsltDocumentElem: URL computation failed for %s\\n\",\n\t\t\t URL);\n\txmlFree(URL);\n\treturn;\n    }\n\n    /*\n     * Security checking: can we write to this resource\n     */\n    if (ctxt->sec != NULL) {\n\tret = xsltCheckWrite(ctxt->sec, ctxt, filename);\n\tif (ret == 0) {\n\t    xsltTransformError(ctxt, NULL, inst,\n\t\t \"xsltDocumentElem: write rights for %s denied\\n\",\n\t\t\t     filename);\n\t    xmlFree(URL);\n\t    xmlFree(filename);\n\t    return;\n\t}\n    }\n\n    oldOutputFile = ctxt->outputFile;\n    oldOutput = ctxt->output;\n    oldInsert = ctxt->insert;\n    oldType = ctxt->type;\n    ctxt->outputFile = (const char *) filename;\n\n    style = xsltNewStylesheet();\n    if (style == NULL) {\n\txsltTransformError(ctxt, NULL, inst,\n                         \"xsltDocumentElem: out of memory\\n\");\n        goto error;\n    }\n\n    /*\n     * Version described in 1.1 draft allows full parameterization\n     * of the output.\n     */\n    prop = xsltEvalAttrValueTemplate(ctxt, inst,\n\t\t\t\t     (const xmlChar *) \"version\",\n\t\t\t\t     NULL);\n    if (prop != NULL) {\n\tif (style->version != NULL)\n\t    xmlFree(style->version);\n\tstyle->version = prop;\n    }\n    prop = xsltEvalAttrValueTemplate(ctxt, inst,\n\t\t\t\t     (const xmlChar *) \"encoding\",\n\t\t\t\t     NULL);\n    if (prop != NULL) {\n\tif (style->encoding != NULL)\n\t    xmlFree(style->encoding);\n\tstyle->encoding = prop;\n    }\n    prop = xsltEvalAttrValueTemplate(ctxt, inst,\n\t\t\t\t     (const xmlChar *) \"method\",\n\t\t\t\t     NULL);\n    if (prop != NULL) {\n\tconst xmlChar *URI;\n\n\tif (style->method != NULL)\n\t    xmlFree(style->method);\n\tstyle->method = NULL;\n\tif (style->methodURI != NULL)\n\t    xmlFree(style->methodURI);\n\tstyle->methodURI = NULL;\n\n\tURI = xsltGetQNameURI(inst, &prop);\n\tif (prop == NULL) {\n\t    if (style != NULL) style->errors++;\n\t} else if (URI == NULL) {\n\t    if ((xmlStrEqual(prop, (const xmlChar *) \"xml\")) ||\n\t\t(xmlStrEqual(prop, (const xmlChar *) \"html\")) ||\n\t\t(xmlStrEqual(prop, (const xmlChar *) \"text\"))) {\n\t\tstyle->method = prop;\n\t    } else {\n\t\txsltTransformError(ctxt, NULL, inst,\n\t\t\t\t \"invalid value for method: %s\\n\", prop);\n\t\tif (style != NULL) style->warnings++;\n\t    }\n\t} else {\n\t    style->method = prop;\n\t    style->methodURI = xmlStrdup(URI);\n\t}\n    }\n    prop = xsltEvalAttrValueTemplate(ctxt, inst,\n\t\t\t\t     (const xmlChar *)\n\t\t\t\t     \"doctype-system\", NULL);\n    if (prop != NULL) {\n\tif (style->doctypeSystem != NULL)\n\t    xmlFree(style->doctypeSystem);\n\tstyle->doctypeSystem = prop;\n    }\n    prop = xsltEvalAttrValueTemplate(ctxt, inst,\n\t\t\t\t     (const xmlChar *)\n\t\t\t\t     \"doctype-public\", NULL);\n    if (prop != NULL) {\n\tif (style->doctypePublic != NULL)\n\t    xmlFree(style->doctypePublic);\n\tstyle->doctypePublic = prop;\n    }\n    prop = xsltEvalAttrValueTemplate(ctxt, inst,\n\t\t\t\t     (const xmlChar *) \"standalone\",\n\t\t\t\t     NULL);\n    if (prop != NULL) {\n\tif (xmlStrEqual(prop, (const xmlChar *) \"yes\")) {\n\t    style->standalone = 1;\n\t} else if (xmlStrEqual(prop, (const xmlChar *) \"no\")) {\n\t    style->standalone = 0;\n\t} else {\n\t    xsltTransformError(ctxt, NULL, inst,\n\t\t\t     \"invalid value for standalone: %s\\n\",\n\t\t\t     prop);\n\t    if (style != NULL) style->warnings++;\n\t}\n\txmlFree(prop);\n    }\n\n    prop = xsltEvalAttrValueTemplate(ctxt, inst,\n\t\t\t\t     (const xmlChar *) \"indent\",\n\t\t\t\t     NULL);\n    if (prop != NULL) {\n\tif (xmlStrEqual(prop, (const xmlChar *) \"yes\")) {\n\t    style->indent = 1;\n\t} else if (xmlStrEqual(prop, (const xmlChar *) \"no\")) {\n\t    style->indent = 0;\n\t} else {\n\t    xsltTransformError(ctxt, NULL, inst,\n\t\t\t     \"invalid value for indent: %s\\n\", prop);\n\t    if (style != NULL) style->warnings++;\n\t}\n\txmlFree(prop);\n    }\n\n    prop = xsltEvalAttrValueTemplate(ctxt, inst,\n\t\t\t\t     (const xmlChar *)\n\t\t\t\t     \"omit-xml-declaration\",\n\t\t\t\t     NULL);\n    if (prop != NULL) {\n\tif (xmlStrEqual(prop, (const xmlChar *) \"yes\")) {\n\t    style->omitXmlDeclaration = 1;\n\t} else if (xmlStrEqual(prop, (const xmlChar *) \"no\")) {\n\t    style->omitXmlDeclaration = 0;\n\t} else {\n\t    xsltTransformError(ctxt, NULL, inst,\n\t\t\t     \"invalid value for omit-xml-declaration: %s\\n\",\n\t\t\t     prop);\n\t    if (style != NULL) style->warnings++;\n\t}\n\txmlFree(prop);\n    }\n\n    elements = xsltEvalAttrValueTemplate(ctxt, inst,\n\t\t\t\t\t (const xmlChar *)\n\t\t\t\t\t \"cdata-section-elements\",\n\t\t\t\t\t NULL);\n    if (elements != NULL) {\n\tif (style->stripSpaces == NULL)\n\t    style->stripSpaces = xmlHashCreate(10);\n\tif (style->stripSpaces == NULL)\n\t    return;\n\n\telement = elements;\n\twhile (*element != 0) {\n\t    while (IS_BLANK_CH(*element))\n\t\telement++;\n\t    if (*element == 0)\n\t\tbreak;\n\t    end = element;\n\t    while ((*end != 0) && (!IS_BLANK_CH(*end)))\n\t\tend++;\n\t    element = xmlStrndup(element, end - element);\n\t    if (element) {\n\t\tconst xmlChar *URI;\n\n#ifdef WITH_XSLT_DEBUG_PARSING\n\t\txsltGenericDebug(xsltGenericDebugContext,\n\t\t\t\t \"add cdata section output element %s\\n\",\n\t\t\t\t element);\n#endif\n                URI = xsltGetQNameURI(inst, &element);\n\n\t\txmlHashAddEntry2(style->stripSpaces, element, URI,\n\t\t\t        (xmlChar *) \"cdata\");\n\t\txmlFree(element);\n\t    }\n\t    element = end;\n\t}\n\txmlFree(elements);\n    }\n\n    /*\n     * Create a new document tree and process the element template\n     */\n    XSLT_GET_IMPORT_PTR(method, style, method)\n    XSLT_GET_IMPORT_PTR(doctypePublic, style, doctypePublic)\n    XSLT_GET_IMPORT_PTR(doctypeSystem, style, doctypeSystem)\n    XSLT_GET_IMPORT_PTR(version, style, version)\n    XSLT_GET_IMPORT_PTR(encoding, style, encoding)\n\n    if ((method != NULL) &&\n\t(!xmlStrEqual(method, (const xmlChar *) \"xml\"))) {\n\tif (xmlStrEqual(method, (const xmlChar *) \"html\")) {\n\t    ctxt->type = XSLT_OUTPUT_HTML;\n\t    if (((doctypePublic != NULL) || (doctypeSystem != NULL)))\n\t\tres = htmlNewDoc(doctypeSystem, doctypePublic);\n\t    else {\n\t\tif (version != NULL) {\n#ifdef XSLT_GENERATE_HTML_DOCTYPE\n\t\t    xsltGetHTMLIDs(version, &doctypePublic, &doctypeSystem);\n#endif\n                }\n\t\tres = htmlNewDocNoDtD(doctypeSystem, doctypePublic);\n\t    }\n\t    if (res == NULL)\n\t\tgoto error;\n\t    res->dict = ctxt->dict;\n \t    xmlDictReference(res->dict);\n \t} else if (xmlStrEqual(method, (const xmlChar *) \"xhtml\")) {\n \t    xsltTransformError(ctxt, NULL, inst,\n\t     \"xsltDocumentElem: unsupported method xhtml\\n\",\n\t\t             style->method);\n \t    ctxt->type = XSLT_OUTPUT_HTML;\n \t    res = htmlNewDocNoDtD(doctypeSystem, doctypePublic);\n \t    if (res == NULL)\n\t\tgoto error;\n\t    res->dict = ctxt->dict;\n\t    xmlDictReference(res->dict);\n\t} else if (xmlStrEqual(method, (const xmlChar *) \"text\")) {\n\t    ctxt->type = XSLT_OUTPUT_TEXT;\n\t    res = xmlNewDoc(style->version);\n\t    if (res == NULL)\n\t\tgoto error;\n\t    res->dict = ctxt->dict;\n\t    xmlDictReference(res->dict);\n#ifdef WITH_XSLT_DEBUG\n\t    xsltGenericDebug(xsltGenericDebugContext,\n                     \"reusing transformation dict for output\\n\");\n #endif\n \t} else {\n \t    xsltTransformError(ctxt, NULL, inst,\n\t\t\t     \"xsltDocumentElem: unsupported method %s\\n\",\n\t\t             style->method);\n \t    goto error;\n \t}\n     } else {\n\tctxt->type = XSLT_OUTPUT_XML;\n\tres = xmlNewDoc(style->version);\n\tif (res == NULL)\n\t    goto error;\n\tres->dict = ctxt->dict;\n\txmlDictReference(res->dict);\n#ifdef WITH_XSLT_DEBUG\n\txsltGenericDebug(xsltGenericDebugContext,\n                     \"reusing transformation dict for output\\n\");\n#endif\n    }\n    res->charset = XML_CHAR_ENCODING_UTF8;\n    if (encoding != NULL)\n\tres->encoding = xmlStrdup(encoding);\n    ctxt->output = res;\n    ctxt->insert = (xmlNodePtr) res;\n    xsltApplySequenceConstructor(ctxt, node, inst->children, NULL);\n\n    /*\n     * Do some post processing work depending on the generated output\n     */\n    root = xmlDocGetRootElement(res);\n    if (root != NULL) {\n        const xmlChar *doctype = NULL;\n\n        if ((root->ns != NULL) && (root->ns->prefix != NULL))\n\t    doctype = xmlDictQLookup(ctxt->dict, root->ns->prefix, root->name);\n\tif (doctype == NULL)\n\t    doctype = root->name;\n\n        /*\n         * Apply the default selection of the method\n         */\n        if ((method == NULL) &&\n            (root->ns == NULL) &&\n            (!xmlStrcasecmp(root->name, (const xmlChar *) \"html\"))) {\n            xmlNodePtr tmp;\n\n            tmp = res->children;\n            while ((tmp != NULL) && (tmp != root)) {\n                if (tmp->type == XML_ELEMENT_NODE)\n                    break;\n                if ((tmp->type == XML_TEXT_NODE) && (!xmlIsBlankNode(tmp)))\n                    break;\n\t\ttmp = tmp->next;\n            }\n            if (tmp == root) {\n                ctxt->type = XSLT_OUTPUT_HTML;\n                res->type = XML_HTML_DOCUMENT_NODE;\n                if (((doctypePublic != NULL) || (doctypeSystem != NULL))) {\n                    res->intSubset = xmlCreateIntSubset(res, doctype,\n                                                        doctypePublic,\n                                                        doctypeSystem);\n#ifdef XSLT_GENERATE_HTML_DOCTYPE\n\t\t} else if (version != NULL) {\n                    xsltGetHTMLIDs(version, &doctypePublic,\n                                   &doctypeSystem);\n                    if (((doctypePublic != NULL) || (doctypeSystem != NULL)))\n                        res->intSubset =\n                            xmlCreateIntSubset(res, doctype,\n                                               doctypePublic,\n                                               doctypeSystem);\n#endif\n                }\n            }\n\n        }\n        if (ctxt->type == XSLT_OUTPUT_XML) {\n            XSLT_GET_IMPORT_PTR(doctypePublic, style, doctypePublic)\n                XSLT_GET_IMPORT_PTR(doctypeSystem, style, doctypeSystem)\n                if (((doctypePublic != NULL) || (doctypeSystem != NULL)))\n                res->intSubset = xmlCreateIntSubset(res, doctype,\n                                                    doctypePublic,\n                                                    doctypeSystem);\n        }\n    }\n\n    /*\n     * Calls to redirect:write also take an optional attribute append.\n     * Attribute append=\"true|yes\" which will attempt to simply append\n     * to an existing file instead of always opening a new file. The\n     * default behavior of always overwriting the file still happens\n     * if we do not specify append.\n     * Note that append use will forbid use of remote URI target.\n     */\n    prop = xsltEvalAttrValueTemplate(ctxt, inst, (const xmlChar *)\"append\",\n\t\t\t\t     NULL);\n    if (prop != NULL) {\n\tif (xmlStrEqual(prop, (const xmlChar *) \"true\") ||\n\t    xmlStrEqual(prop, (const xmlChar *) \"yes\")) {\n\t    style->omitXmlDeclaration = 1;\n\t    redirect_write_append = 1;\n\t} else\n\t    style->omitXmlDeclaration = 0;\n\txmlFree(prop);\n    }\n\n    if (redirect_write_append) {\n        FILE *f;\n\n\tf = fopen((const char *) filename, \"ab\");\n\tif (f == NULL) {\n\t    ret = -1;\n\t} else {\n\t    ret = xsltSaveResultToFile(f, res, style);\n\t    fclose(f);\n\t}\n    } else {\n\tret = xsltSaveResultToFilename((const char *) filename, res, style, 0);\n    }\n    if (ret < 0) {\n\txsltTransformError(ctxt, NULL, inst,\n                         \"xsltDocumentElem: unable to save to %s\\n\",\n                         filename);\n\tctxt->state = XSLT_STATE_ERROR;\n#ifdef WITH_XSLT_DEBUG_EXTRA\n    } else {\n        xsltGenericDebug(xsltGenericDebugContext,\n                         \"Wrote %d bytes to %s\\n\", ret, filename);\n#endif\n    }\n\n  error:\n    ctxt->output = oldOutput;\n    ctxt->insert = oldInsert;\n    ctxt->type = oldType;\n    ctxt->outputFile = oldOutputFile;\n    if (URL != NULL)\n        xmlFree(URL);\n    if (filename != NULL)\n        xmlFree(filename);\n    if (style != NULL)\n        xsltFreeStylesheet(style);\n    if (res != NULL)\n        xmlFreeDoc(res);\n}\n", "target": 1, "idx": 187347}
{"func": "static int store_asoundrc(void) {\n\tfs_build_mnt_dir();\n \n \tchar *src;\n \tchar *dest = RUN_ASOUNDRC_FILE;\n \tFILE *fp = fopen(dest, \"w\");\n \tif (fp) {\n \t\tfprintf(fp, \"\\n\");\n\t\tSET_PERMS_STREAM(fp, getuid(), getgid(), 0644);\n\t\tfclose(fp);\n\t}\n\t\n\tif (asprintf(&src, \"%s/.asoundrc\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\t\n\tstruct stat s;\n\tif (stat(src, &s) == 0) {\n\t\tif (is_link(src)) {\n\t\t\t/* coverity[toctou] */\n\t\t\tchar* rp = realpath(src, NULL);\n\t\t\tif (!rp) {\n\t\t\t\tfprintf(stderr, \"Error: Cannot access %s\\n\", src);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (strncmp(rp, cfg.homedir, strlen(cfg.homedir)) != 0) {\n\t\t\t\tfprintf(stderr, \"Error: .asoundrc is a symbolic link pointing to a file outside home directory\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tfree(rp);\n\t\t}\n\n\t\tcopy_file_as_user(src, dest, getuid(), getgid(), 0644);\n\t\tfs_logger2(\"clone\", dest);\n\t\treturn 1; // file copied\n\t}\n\t\n\treturn 0;\n}\n", "target": 1, "idx": 181544}
{"func": " bool ClipboardUtil::HasFilenames(IDataObject* data_object) {\n   DCHECK(data_object);\n  return HasData(data_object, Clipboard::GetCFHDropFormatType());\n }\n", "target": 1, "idx": 185440}
{"func": "    virtual bool detach()\n    {\n        m_events.append(Detach);\n        return TRUE;\n    }\n", "target": 0, "idx": 117172}
{"func": "void ptrace_triggered(struct perf_event *bp, int nmi,\n \t\t      struct perf_sample_data *data, struct pt_regs *regs)\n {\n \tstruct perf_event_attr attr;\n\n\t/*\n\t * Disable the breakpoint request here since ptrace has defined a\n\t * one-shot behaviour for breakpoint exceptions in PPC64.\n\t * The SIGTRAP signal is generated automatically for us in do_dabr().\n\t * We don't have to do anything about that here\n\t */\n\tattr = bp->attr;\n\tattr.disabled = true;\n\tmodify_user_hw_breakpoint(bp, &attr);\n}\n", "target": 1, "idx": 178964}
{"func": "void* JSArray::subclassData() const\n{\n    return m_storage->subclassData;\n}\n", "target": 0, "idx": 107453}
{"func": "int main(int argc, char *argv[])\n{\n\tint ret;\n\tstruct lxc_lock *lock;\n\n\tlock = lxc_newlock(NULL, NULL);\n\tif (!lock) {\n\t\tfprintf(stderr, \"%d: failed to get unnamed lock\\n\", __LINE__);\n\t\texit(1);\n\t}\n\tret = lxclock(lock, 0);\n\tif (ret) {\n\t\tfprintf(stderr, \"%d: failed to take unnamed lock (%d)\\n\", __LINE__, ret);\n\t\texit(1);\n\t}\n\n\tret = lxcunlock(lock);\n\tif (ret) {\n\t\tfprintf(stderr, \"%d: failed to put unnamed lock (%d)\\n\", __LINE__, ret);\n\t\texit(1);\n\t}\n\tlxc_putlock(lock);\n\n\tlock = lxc_newlock(\"/var/lib/lxc\", mycontainername);\n\tif (!lock) {\n\t\tfprintf(stderr, \"%d: failed to get lock\\n\", __LINE__);\n \t\texit(1);\n \t}\n \tstruct stat sb;\n\tchar *pathname = RUNTIME_PATH \"/lock/lxc/var/lib/lxc/\";\n \tret = stat(pathname, &sb);\n \tif (ret != 0) {\n \t\tfprintf(stderr, \"%d: filename %s not created\\n\", __LINE__,\n\t\t\tpathname);\n\t\texit(1);\n\t}\n\tlxc_putlock(lock);\n\n\ttest_two_locks();\n\n\tfprintf(stderr, \"all tests passed\\n\");\n\n\texit(ret);\n}\n", "target": 1, "idx": 179898}
{"func": "parse_field(netdissect_options *ndo, const char **pptr, int *len)\n {\n     const char *s;\n \n    if (*len <= 0 || !pptr || !*pptr)\n\treturn NULL;\n    if (*pptr > (const char *) ndo->ndo_snapend)\n\treturn NULL;\n     s = *pptr;\n    while (*pptr <= (const char *) ndo->ndo_snapend && *len >= 0 && **pptr) {\n \t(*pptr)++;\n \t(*len)--;\n     }\n     (*pptr)++;\n     (*len)--;\n    if (*len < 0 || *pptr > (const char *) ndo->ndo_snapend)\n\treturn NULL;\n     return s;\n }\n", "target": 1, "idx": 181107}
{"func": "cib_remote_dispatch(gpointer user_data)\n {\n     cib_t *cib = user_data;\n     cib_remote_opaque_t *private = cib->variant_opaque;\n \n     xmlNode *msg = NULL;\n    const char *type = NULL;\n \n     crm_info(\"Message on callback channel\");\n    msg = crm_recv_remote_msg(private->callback.session, private->callback.encrypted);\n \n    type = crm_element_value(msg, F_TYPE);\n    crm_trace(\"Activating %s callbacks...\", type);\n \n    if (safe_str_eq(type, T_CIB)) {\n        cib_native_callback(cib, msg, 0, 0);\n \n    } else if (safe_str_eq(type, T_CIB_NOTIFY)) {\n        g_list_foreach(cib->notify_list, cib_native_notify, msg);\n \n    } else {\n        crm_err(\"Unknown message type: %s\", type);\n    }\n \n    if (msg != NULL) {\n         free_xml(msg);\n        return 0;\n     }\n    return -1;\n }\n", "target": 1, "idx": 179323}
{"func": "usage (int ecode, FILE *out)\n{\n  fprintf (out, \"usage: %s [OPTIONS...] [--] COMMAND [ARGS...]\\n\\n\", argv0);\n\n  fprintf (out,\n           \"    --help                       Print this help\\n\"\n           \"    --version                    Print version\\n\"\n           \"    --args FD                    Parse NUL-separated args from FD\\n\"\n           \"    --unshare-all                Unshare every namespace we support by default\\n\"\n           \"    --share-net                  Retain the network namespace (can only combine with --unshare-all)\\n\"\n           \"    --unshare-user               Create new user namespace (may be automatically implied if not setuid)\\n\"\n           \"    --unshare-user-try           Create new user namespace if possible else continue by skipping it\\n\"\n           \"    --unshare-ipc                Create new ipc namespace\\n\"\n           \"    --unshare-pid                Create new pid namespace\\n\"\n           \"    --unshare-net                Create new network namespace\\n\"\n           \"    --unshare-uts                Create new uts namespace\\n\"\n           \"    --unshare-cgroup             Create new cgroup namespace\\n\"\n           \"    --unshare-cgroup-try         Create new cgroup namespace if possible else continue by skipping it\\n\"\n           \"    --uid UID                    Custom uid in the sandbox (requires --unshare-user)\\n\"\n           \"    --gid GID                    Custom gid in the sandbox (requires --unshare-user)\\n\"\n           \"    --hostname NAME              Custom hostname in the sandbox (requires --unshare-uts)\\n\"\n           \"    --chdir DIR                  Change directory to DIR\\n\"\n           \"    --setenv VAR VALUE           Set an environment variable\\n\"\n           \"    --unsetenv VAR               Unset an environment variable\\n\"\n           \"    --lock-file DEST             Take a lock on DEST while sandbox is running\\n\"\n           \"    --sync-fd FD                 Keep this fd open while sandbox is running\\n\"\n           \"    --bind SRC DEST              Bind mount the host path SRC on DEST\\n\"\n           \"    --bind-try SRC DEST          Equal to --bind but ignores non-existent SRC\\n\"\n           \"    --dev-bind SRC DEST          Bind mount the host path SRC on DEST, allowing device access\\n\"\n           \"    --dev-bind-try SRC DEST      Equal to --dev-bind but ignores non-existent SRC\\n\"\n           \"    --ro-bind SRC DEST           Bind mount the host path SRC readonly on DEST\\n\"\n           \"    --ro-bind-try SRC DEST       Equal to --ro-bind but ignores non-existent SRC\\n\"\n           \"    --remount-ro DEST            Remount DEST as readonly; does not recursively remount\\n\"\n           \"    --exec-label LABEL           Exec label for the sandbox\\n\"\n           \"    --file-label LABEL           File label for temporary sandbox content\\n\"\n           \"    --proc DEST                  Mount new procfs on DEST\\n\"\n           \"    --dev DEST                   Mount new dev on DEST\\n\"\n           \"    --tmpfs DEST                 Mount new tmpfs on DEST\\n\"\n           \"    --mqueue DEST                Mount new mqueue on DEST\\n\"\n           \"    --dir DEST                   Create dir at DEST\\n\"\n           \"    --file FD DEST               Copy from FD to destination DEST\\n\"\n           \"    --bind-data FD DEST          Copy from FD to file which is bind-mounted on DEST\\n\"\n           \"    --ro-bind-data FD DEST       Copy from FD to file which is readonly bind-mounted on DEST\\n\"\n           \"    --symlink SRC DEST           Create symlink at DEST with target SRC\\n\"\n           \"    --seccomp FD                 Load and use seccomp rules from FD\\n\"\n           \"    --block-fd FD                Block on FD until some data to read is available\\n\"\n           \"    --userns-block-fd FD         Block on FD until the user namespace is ready\\n\"\n           \"    --info-fd FD                 Write information about the running container to FD\\n\"\n           \"    --json-status-fd FD          Write container status to FD as multiple JSON documents\\n\"\n           \"    --new-session                Create a new terminal session\\n\"\n           \"    --die-with-parent            Kills with SIGKILL child process (COMMAND) when bwrap or bwrap's parent dies.\\n\"\n           \"    --as-pid-1                   Do not install a reaper process with PID=1\\n\"\n           \"    --cap-add CAP                Add cap CAP when running as privileged user\\n\"\n           \"    --cap-drop CAP               Drop cap CAP when running as privileged user\\n\"\n          );\n  exit (ecode);\n}\n", "target": 0, "idx": 89789}
{"func": "rfc1048_print(netdissect_options *ndo,\n\t      register const u_char *bp)\n{\n\tregister uint16_t tag;\n\tregister u_int len;\n\tregister const char *cp;\n\tregister char c;\n\tint first, idx;\n\tuint32_t ul;\n\tuint16_t us;\n\tuint8_t uc, subopt, suboptlen;\n\n\tND_PRINT((ndo, \"\\n\\t  Vendor-rfc1048 Extensions\"));\n\n\t/* Step over magic cookie */\n\tND_PRINT((ndo, \"\\n\\t    Magic Cookie 0x%08x\", EXTRACT_32BITS(bp)));\n\tbp += sizeof(int32_t);\n\n\t/* Loop while we there is a tag left in the buffer */\n\twhile (ND_TTEST2(*bp, 1)) {\n\t\ttag = *bp++;\n\t\tif (tag == TAG_PAD && ndo->ndo_vflag < 3)\n\t\t\tcontinue;\n\t\tif (tag == TAG_END && ndo->ndo_vflag < 3)\n\t\t\treturn;\n\t\tif (tag == TAG_EXTENDED_OPTION) {\n\t\t\tND_TCHECK2(*(bp + 1), 2);\n\t\t\ttag = EXTRACT_16BITS(bp + 1);\n\t\t\t/* XXX we don't know yet if the IANA will\n\t\t\t * preclude overlap of 1-byte and 2-byte spaces.\n\t\t\t * If not, we need to offset tag after this step.\n\t\t\t */\n\t\t\tcp = tok2str(xtag2str, \"?xT%u\", tag);\n\t\t} else\n\t\t\tcp = tok2str(tag2str, \"?T%u\", tag);\n\t\tc = *cp++;\n\n\t\tif (tag == TAG_PAD || tag == TAG_END)\n\t\t\tlen = 0;\n\t\telse {\n\t\t\t/* Get the length; check for truncation */\n\t\t\tND_TCHECK2(*bp, 1);\n\t\t\tlen = *bp++;\n\t\t}\n\n\t\tND_PRINT((ndo, \"\\n\\t    %s Option %u, length %u%s\", cp, tag, len,\n\t\t\t  len > 0 ? \": \" : \"\"));\n\n\t\tif (tag == TAG_PAD && ndo->ndo_vflag > 2) {\n\t\t\tu_int ntag = 1;\n\t\t\twhile (ND_TTEST2(*bp, 1) && *bp == TAG_PAD) {\n\t\t\t\tbp++;\n\t\t\t\tntag++;\n\t\t\t}\n\t\t\tif (ntag > 1)\n\t\t\t\tND_PRINT((ndo, \", occurs %u\", ntag));\n\t\t}\n\n\t\tif (!ND_TTEST2(*bp, len)) {\n\t\t\tND_PRINT((ndo, \"[|rfc1048 %u]\", len));\n\t\t\treturn;\n\t\t}\n\n\t\tif (tag == TAG_DHCP_MESSAGE && len == 1) {\n\t\t\tuc = *bp++;\n\t\t\tND_PRINT((ndo, \"%s\", tok2str(dhcp_msg_values, \"Unknown (%u)\", uc)));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (tag == TAG_PARM_REQUEST) {\n\t\t\tidx = 0;\n\t\t\twhile (len-- > 0) {\n\t\t\t\tuc = *bp++;\n\t\t\t\tcp = tok2str(tag2str, \"?Option %u\", uc);\n\t\t\t\tif (idx % 4 == 0)\n\t\t\t\t\tND_PRINT((ndo, \"\\n\\t      \"));\n\t\t\t\telse\n\t\t\t\t\tND_PRINT((ndo, \", \"));\n\t\t\t\tND_PRINT((ndo, \"%s\", cp + 1));\n\t\t\t\tidx++;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (tag == TAG_EXTENDED_REQUEST) {\n\t\t\tfirst = 1;\n\t\t\twhile (len > 1) {\n\t\t\t\tlen -= 2;\n\t\t\t\tus = EXTRACT_16BITS(bp);\n\t\t\t\tbp += 2;\n\t\t\t\tcp = tok2str(xtag2str, \"?xT%u\", us);\n\t\t\t\tif (!first)\n\t\t\t\t\tND_PRINT((ndo, \"+\"));\n\t\t\t\tND_PRINT((ndo, \"%s\", cp + 1));\n\t\t\t\tfirst = 0;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Print data */\n\t\tif (c == '?') {\n\t\t\t/* Base default formats for unknown tags on data size */\n\t\t\tif (len & 1)\n\t\t\t\tc = 'b';\n\t\t\telse if (len & 2)\n\t\t\t\tc = 's';\n\t\t\telse\n\t\t\t\tc = 'l';\n\t\t}\n\t\tfirst = 1;\n\t\tswitch (c) {\n\n\t\tcase 'a':\n\t\t\t/* ASCII strings */\n\t\t\tND_PRINT((ndo, \"\\\"\"));\n\t\t\tif (fn_printn(ndo, bp, len, ndo->ndo_snapend)) {\n\t\t\t\tND_PRINT((ndo, \"\\\"\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \"\\\"\"));\n\t\t\tbp += len;\n\t\t\tlen = 0;\n\t\t\tbreak;\n\n\t\tcase 'i':\n\t\tcase 'l':\n\t\tcase 'L':\n\t\t\t/* ip addresses/32-bit words */\n\t\t\twhile (len >= sizeof(ul)) {\n\t\t\t\tif (!first)\n\t\t\t\t\tND_PRINT((ndo, \",\"));\n\t\t\t\tul = EXTRACT_32BITS(bp);\n\t\t\t\tif (c == 'i') {\n\t\t\t\t\tul = htonl(ul);\n\t\t\t\t\tND_PRINT((ndo, \"%s\", ipaddr_string(ndo, &ul)));\n\t\t\t\t} else if (c == 'L')\n\t\t\t\t\tND_PRINT((ndo, \"%d\", ul));\n\t\t\t\telse\n\t\t\t\t\tND_PRINT((ndo, \"%u\", ul));\n\t\t\t\tbp += sizeof(ul);\n\t\t\t\tlen -= sizeof(ul);\n\t\t\t\tfirst = 0;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'p':\n\t\t\t/* IP address pairs */\n\t\t\twhile (len >= 2*sizeof(ul)) {\n\t\t\t\tif (!first)\n\t\t\t\t\tND_PRINT((ndo, \",\"));\n\t\t\t\tmemcpy((char *)&ul, (const char *)bp, sizeof(ul));\n\t\t\t\tND_PRINT((ndo, \"(%s:\", ipaddr_string(ndo, &ul)));\n\t\t\t\tbp += sizeof(ul);\n\t\t\t\tmemcpy((char *)&ul, (const char *)bp, sizeof(ul));\n\t\t\t\tND_PRINT((ndo, \"%s)\", ipaddr_string(ndo, &ul)));\n\t\t\t\tbp += sizeof(ul);\n\t\t\t\tlen -= 2*sizeof(ul);\n\t\t\t\tfirst = 0;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 's':\n\t\t\t/* shorts */\n\t\t\twhile (len >= sizeof(us)) {\n\t\t\t\tif (!first)\n\t\t\t\t\tND_PRINT((ndo, \",\"));\n\t\t\t\tus = EXTRACT_16BITS(bp);\n\t\t\t\tND_PRINT((ndo, \"%u\", us));\n\t\t\t\tbp += sizeof(us);\n\t\t\t\tlen -= sizeof(us);\n\t\t\t\tfirst = 0;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'B':\n\t\t\t/* boolean */\n\t\t\twhile (len > 0) {\n\t\t\t\tif (!first)\n\t\t\t\t\tND_PRINT((ndo, \",\"));\n\t\t\t\tswitch (*bp) {\n\t\t\t\tcase 0:\n\t\t\t\t\tND_PRINT((ndo, \"N\"));\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tND_PRINT((ndo, \"Y\"));\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tND_PRINT((ndo, \"%u?\", *bp));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t++bp;\n\t\t\t\t--len;\n\t\t\t\tfirst = 0;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'b':\n\t\tcase 'x':\n\t\tdefault:\n\t\t\t/* Bytes */\n\t\t\twhile (len > 0) {\n\t\t\t\tif (!first)\n\t\t\t\t\tND_PRINT((ndo, c == 'x' ? \":\" : \".\"));\n\t\t\t\tif (c == 'x')\n\t\t\t\t\tND_PRINT((ndo, \"%02x\", *bp));\n\t\t\t\telse\n\t\t\t\t\tND_PRINT((ndo, \"%u\", *bp));\n\t\t\t\t++bp;\n\t\t\t\t--len;\n\t\t\t\tfirst = 0;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase '$':\n\t\t\t/* Guys we can't handle with one of the usual cases */\n\t\t\tswitch (tag) {\n\n\t\t\tcase TAG_NETBIOS_NODE:\n\t\t\t\t/* this option should be at least 1 byte long */\n\t\t\t\tif (len < 1) {\n\t\t\t\t\tND_PRINT((ndo, \"ERROR: length < 1 bytes\"));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttag = *bp++;\n\t\t\t\t--len;\n\t\t\t\tND_PRINT((ndo, \"%s\", tok2str(nbo2str, NULL, tag)));\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_OPT_OVERLOAD:\n\t\t\t\t/* this option should be at least 1 byte long */\n\t\t\t\tif (len < 1) {\n\t\t\t\t\tND_PRINT((ndo, \"ERROR: length < 1 bytes\"));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttag = *bp++;\n\t\t\t\t--len;\n\t\t\t\tND_PRINT((ndo, \"%s\", tok2str(oo2str, NULL, tag)));\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_CLIENT_FQDN:\n\t\t\t\t/* this option should be at least 3 bytes long */\n\t\t\t\tif (len < 3) {\n\t\t\t\t\tND_PRINT((ndo, \"ERROR: length < 3 bytes\"));\n\t\t\t\t\tbp += len;\n\t\t\t\t\tlen = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (*bp)\n\t\t\t\t\tND_PRINT((ndo, \"[%s] \", client_fqdn_flags(*bp)));\n\t\t\t\tbp++;\n\t\t\t\tif (*bp || *(bp+1))\n\t\t\t\t\tND_PRINT((ndo, \"%u/%u \", *bp, *(bp+1)));\n\t\t\t\tbp += 2;\n\t\t\t\tND_PRINT((ndo, \"\\\"\"));\n\t\t\t\tif (fn_printn(ndo, bp, len - 3, ndo->ndo_snapend)) {\n\t\t\t\t\tND_PRINT((ndo, \"\\\"\"));\n\t\t\t\t\tgoto trunc;\n\t\t\t\t}\n\t\t\t\tND_PRINT((ndo, \"\\\"\"));\n\t\t\t\tbp += len - 3;\n\t\t\t\tlen = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_CLIENT_ID:\n\t\t\t    {\n\t\t\t\tint type;\n\n\t\t\t\t/* this option should be at least 1 byte long */\n\t\t\t\tif (len < 1) {\n\t\t\t\t\tND_PRINT((ndo, \"ERROR: length < 1 bytes\"));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttype = *bp++;\n\t\t\t\tlen--;\n\t\t\t\tif (type == 0) {\n\t\t\t\t\tND_PRINT((ndo, \"\\\"\"));\n\t\t\t\t\tif (fn_printn(ndo, bp, len, ndo->ndo_snapend)) {\n\t\t\t\t\t\tND_PRINT((ndo, \"\\\"\"));\n\t\t\t\t\t\tgoto trunc;\n\t\t\t\t\t}\n\t\t\t\t\tND_PRINT((ndo, \"\\\"\"));\n\t\t\t\t\tbp += len;\n\t\t\t\t\tlen = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tND_PRINT((ndo, \"%s \", tok2str(arp2str, \"hardware-type %u,\", type)));\n\t\t\t\t\twhile (len > 0) {\n\t\t\t\t\t\tif (!first)\n\t\t\t\t\t\t\tND_PRINT((ndo, \":\"));\n\t\t\t\t\t\tND_PRINT((ndo, \"%02x\", *bp));\n\t\t\t\t\t\t++bp;\n\t\t\t\t\t\t--len;\n\t\t\t\t\t\tfirst = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t    }\n\n\t\t\tcase TAG_AGENT_CIRCUIT:\n\t\t\t\twhile (len >= 2) {\n\t\t\t\t\tsubopt = *bp++;\n\t\t\t\t\tsuboptlen = *bp++;\n\t\t\t\t\tlen -= 2;\n\t\t\t\t\tif (suboptlen > len) {\n\t\t\t\t\t\tND_PRINT((ndo, \"\\n\\t      %s SubOption %u, length %u: length goes past end of option\",\n\t\t\t\t\t\t\t  tok2str(agent_suboption_values, \"Unknown\", subopt),\n\t\t\t\t\t\t\t  subopt,\n\t\t\t\t\t\t\t  suboptlen));\n\t\t\t\t\t\tbp += len;\n\t\t\t\t\t\tlen = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tND_PRINT((ndo, \"\\n\\t      %s SubOption %u, length %u: \",\n\t\t\t\t\t\t  tok2str(agent_suboption_values, \"Unknown\", subopt),\n\t\t\t\t\t\t  subopt,\n\t\t\t\t\t\t  suboptlen));\n\t\t\t\t\tswitch (subopt) {\n\n\t\t\t\t\tcase AGENT_SUBOPTION_CIRCUIT_ID: /* fall through */\n\t\t\t\t\tcase AGENT_SUBOPTION_REMOTE_ID:\n\t\t\t\t\tcase AGENT_SUBOPTION_SUBSCRIBER_ID:\n\t\t\t\t\t\tif (fn_printn(ndo, bp, suboptlen, ndo->ndo_snapend))\n\t\t\t\t\t\t\tgoto trunc;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tprint_unknown_data(ndo, bp, \"\\n\\t\\t\", suboptlen);\n\t\t\t\t\t}\n\n\t\t\t\t\tlen -= suboptlen;\n\t\t\t\t\tbp += suboptlen;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_CLASSLESS_STATIC_RT:\n\t\t\tcase TAG_CLASSLESS_STA_RT_MS:\n\t\t\t    {\n\t\t\t\tu_int mask_width, significant_octets, i;\n\n\t\t\t\t/* this option should be at least 5 bytes long */\n\t\t\t\tif (len < 5) {\n\t\t\t\t\tND_PRINT((ndo, \"ERROR: length < 5 bytes\"));\n\t\t\t\t\tbp += len;\n\t\t\t\t\tlen = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\twhile (len > 0) {\n\t\t\t\t\tif (!first)\n\t\t\t\t\t\tND_PRINT((ndo, \",\"));\n\t\t\t\t\tmask_width = *bp++;\n\t\t\t\t\tlen--;\n\t\t\t\t\t/* mask_width <= 32 */\n\t\t\t\t\tif (mask_width > 32) {\n\t\t\t\t\t\tND_PRINT((ndo, \"[ERROR: Mask width (%d) > 32]\", mask_width));\n\t\t\t\t\t\tbp += len;\n\t\t\t\t\t\tlen = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsignificant_octets = (mask_width + 7) / 8;\n\t\t\t\t\t/* significant octets + router(4) */\n\t\t\t\t\tif (len < significant_octets + 4) {\n\t\t\t\t\t\tND_PRINT((ndo, \"[ERROR: Remaining length (%u) < %u bytes]\", len, significant_octets + 4));\n\t\t\t\t\t\tbp += len;\n\t\t\t\t\t\tlen = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tND_PRINT((ndo, \"(\"));\n\t\t\t\t\tif (mask_width == 0)\n\t\t\t\t\t\tND_PRINT((ndo, \"default\"));\n\t\t\t\t\telse {\n\t\t\t\t\t\tfor (i = 0; i < significant_octets ; i++) {\n\t\t\t\t\t\t\tif (i > 0)\n\t\t\t\t\t\t\t\tND_PRINT((ndo, \".\"));\n\t\t\t\t\t\t\tND_PRINT((ndo, \"%d\", *bp++));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (i = significant_octets ; i < 4 ; i++)\n\t\t\t\t\t\t\tND_PRINT((ndo, \".0\"));\n\t\t\t\t\t\tND_PRINT((ndo, \"/%d\", mask_width));\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy((char *)&ul, (const char *)bp, sizeof(ul));\n\t\t\t\t\tND_PRINT((ndo, \":%s)\", ipaddr_string(ndo, &ul)));\n\t\t\t\t\tbp += sizeof(ul);\n\t\t\t\t\tlen -= (significant_octets + 4);\n\t\t\t\t\tfirst = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t    }\n\n\t\t\tcase TAG_USER_CLASS:\n\t\t\t    {\n\t\t\t\tu_int suboptnumber = 1;\n\n\t\t\t\tfirst = 1;\n\t\t\t\tif (len < 2) {\n\t\t\t\t\tND_PRINT((ndo, \"ERROR: length < 2 bytes\"));\n\t\t\t\t\tbp += len;\n\t\t\t\t\tlen = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\twhile (len > 0) {\n\t\t\t\t\tsuboptlen = *bp++;\n\t\t\t\t\tlen--;\n\t\t\t\t\tND_PRINT((ndo, \"\\n\\t      \"));\n\t\t\t\t\tND_PRINT((ndo, \"instance#%u: \", suboptnumber));\n\t\t\t\t\tif (suboptlen == 0) {\n\t\t\t\t\t\tND_PRINT((ndo, \"ERROR: suboption length must be non-zero\"));\n\t\t\t\t\t\tbp += len;\n\t\t\t\t\t\tlen = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (len < suboptlen) {\n\t\t\t\t\t\tND_PRINT((ndo, \"ERROR: invalid option\"));\n\t\t\t\t\t\tbp += len;\n\t\t\t\t\t\tlen = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tND_PRINT((ndo, \"\\\"\"));\n\t\t\t\t\tif (fn_printn(ndo, bp, suboptlen, ndo->ndo_snapend)) {\n\t\t\t\t\t\tND_PRINT((ndo, \"\\\"\"));\n\t\t\t\t\t\tgoto trunc;\n\t\t\t\t\t}\n\t\t\t\t\tND_PRINT((ndo, \"\\\"\"));\n\t\t\t\t\tND_PRINT((ndo, \", length %d\", suboptlen));\n\t\t\t\t\tsuboptnumber++;\n\t\t\t\t\tlen -= suboptlen;\n\t\t\t\t\tbp += suboptlen;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t    }\n\n\t\t\tdefault:\n\t\t\t\tND_PRINT((ndo, \"[unknown special tag %u, size %u]\",\n\t\t\t\t\t  tag, len));\n\t\t\t\tbp += len;\n\t\t\t\tlen = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t/* Data left over? */\n\t\tif (len) {\n\t\t\tND_PRINT((ndo, \"\\n\\t  trailing data length %u\", len));\n\t\t\tbp += len;\n\t\t}\n\t}\n\treturn;\ntrunc:\n\tND_PRINT((ndo, \"|[rfc1048]\"));\n}\n", "target": 0, "idx": 95092}
{"func": "GC_INNER void * GC_generic_malloc_ignore_off_page(size_t lb, int k)\n{\n    void *result;\n    size_t lg;\n    size_t lb_rounded;\n    word n_blocks;\n    GC_bool init;\n    DCL_LOCK_STATE;\n\n    if (SMALL_OBJ(lb))\n         return(GC_generic_malloc((word)lb, k));\n     lg = ROUNDED_UP_GRANULES(lb);\n     lb_rounded = GRANULES_TO_BYTES(lg);\n     n_blocks = OBJ_SZ_TO_BLOCKS(lb_rounded);\n     init = GC_obj_kinds[k].ok_init;\n     if (EXPECT(GC_have_errors, FALSE))\n      GC_print_all_errors();\n    GC_INVOKE_FINALIZERS();\n    LOCK();\n    result = (ptr_t)GC_alloc_large(ADD_SLOP(lb), k, IGNORE_OFF_PAGE);\n    if (0 != result) {\n        if (GC_debugging_started) {\n            BZERO(result, n_blocks * HBLKSIZE);\n        } else {\n#           ifdef THREADS\n              /* Clear any memory that might be used for GC descriptors */\n              /* before we release the lock.                          */\n                ((word *)result)[0] = 0;\n                ((word *)result)[1] = 0;\n                ((word *)result)[GRANULES_TO_WORDS(lg)-1] = 0;\n                ((word *)result)[GRANULES_TO_WORDS(lg)-2] = 0;\n#           endif\n        }\n    }\n    GC_bytes_allocd += lb_rounded;\n    if (0 == result) {\n        GC_oom_func oom_fn = GC_oom_fn;\n        UNLOCK();\n        return((*oom_fn)(lb));\n    } else {\n        UNLOCK();\n        if (init && !GC_debugging_started) {\n            BZERO(result, n_blocks * HBLKSIZE);\n        }\n        return(result);\n    }\n}\n", "target": 1, "idx": 183051}
{"func": "const char *string_of_NPNVariable(int variable)\n{\n  const char *str;\n\n  switch (variable) {\n#define _(VAL) case VAL: str = #VAL; break;\n\t_(NPNVxDisplay);\n\t_(NPNVxtAppContext);\n\t_(NPNVnetscapeWindow);\n\t_(NPNVjavascriptEnabledBool);\n\t_(NPNVasdEnabledBool);\n\t_(NPNVisOfflineBool);\n\t_(NPNVserviceManager);\n\t_(NPNVDOMElement);\n\t_(NPNVDOMWindow);\n\t_(NPNVToolkit);\n\t_(NPNVSupportsXEmbedBool);\n \t_(NPNVWindowNPObject);\n \t_(NPNVPluginElementNPObject);\n \t_(NPNVSupportsWindowless);\n #undef _\n   default:\n \tswitch (variable & 0xff) {\n#define _(VAL, VAR) case VAL: str = #VAR; break\n\t  _(10, NPNVserviceManager);\n\t  _(11, NPNVDOMElement);\n\t  _(12, NPNVDOMWindow);\n\t  _(13, NPNVToolkit);\n#undef _\n\tdefault:\n\t  str = \"<unknown variable>\";\n\t  break;\n\t}\n\tbreak;\n  }\n\n  return str;\n}\n", "target": 1, "idx": 179037}
{"func": "   void DoTest(ExternalProtocolHandler::BlockState block_state,\n               shell_integration::DefaultWebClientState os_state,\n               Action expected_action) {\n    GURL url(\"mailto:test@test.com\");\n     EXPECT_FALSE(delegate_.has_prompted());\n     EXPECT_FALSE(delegate_.has_launched());\n     EXPECT_FALSE(delegate_.has_blocked());\n\n    delegate_.set_block_state(block_state);\n    delegate_.set_os_state(os_state);\n    ExternalProtocolHandler::LaunchUrlWithDelegate(\n        url, 0, 0, ui::PAGE_TRANSITION_LINK, true, &delegate_);\n    content::RunAllTasksUntilIdle();\n\n    EXPECT_EQ(expected_action == Action::PROMPT, delegate_.has_prompted());\n    EXPECT_EQ(expected_action == Action::LAUNCH, delegate_.has_launched());\n    EXPECT_EQ(expected_action == Action::BLOCK, delegate_.has_blocked());\n  }\n", "target": 1, "idx": 186665}
{"func": "static BOOL nsc_context_initialize_encode(NSC_CONTEXT* context)\n{\n\tint i;\n\tUINT32 length;\n\tUINT32 tempWidth;\n\tUINT32 tempHeight;\n\ttempWidth = ROUND_UP_TO(context->width, 8);\n\ttempHeight = ROUND_UP_TO(context->height, 2);\n\t/* The maximum length a decoded plane can reach in all cases */\n\tlength = tempWidth * tempHeight + 16;\n\n\tif (length > context->priv->PlaneBuffersLength)\n\t{\n \t\tfor (i = 0; i < 5; i++)\n \t\t{\n \t\t\tBYTE* tmp = (BYTE*) realloc(context->priv->PlaneBuffers[i], length);\n \t\t\tif (!tmp)\n \t\t\t\tgoto fail;\n \n\t\t\tcontext->priv->PlaneBuffers[i] = tmp;\n\t\t}\n\n\t\tcontext->priv->PlaneBuffersLength = length;\n\t}\n\n\tif (context->ChromaSubsamplingLevel)\n\t{\n\t\tcontext->OrgByteCount[0] = tempWidth * context->height;\n\t\tcontext->OrgByteCount[1] = tempWidth * tempHeight / 4;\n\t\tcontext->OrgByteCount[2] = tempWidth * tempHeight / 4;\n\t\tcontext->OrgByteCount[3] = context->width * context->height;\n\t}\n\telse\n\t{\n\t\tcontext->OrgByteCount[0] = context->width * context->height;\n\t\tcontext->OrgByteCount[1] = context->width * context->height;\n\t\tcontext->OrgByteCount[2] = context->width * context->height;\n\t\tcontext->OrgByteCount[3] = context->width * context->height;\n\t}\n\n\treturn TRUE;\nfail:\n\n\tif (length > context->priv->PlaneBuffersLength)\n\t{\n\t\tfor (i = 0; i < 5; i++)\n\t\t\tfree(context->priv->PlaneBuffers[i]);\n\t}\n\n \treturn FALSE;\n }\n", "target": 1, "idx": 182458}
{"func": "static int snd_timer_user_tselect(struct file *file,\n\t\t\t\t  struct snd_timer_select __user *_tselect)\n{\n\tstruct snd_timer_user *tu;\n\tstruct snd_timer_select tselect;\n\tchar str[32];\n\tint err = 0;\n\n\ttu = file->private_data;\n\tif (tu->timeri) {\n\t\tsnd_timer_close(tu->timeri);\n\t\ttu->timeri = NULL;\n\t}\n\tif (copy_from_user(&tselect, _tselect, sizeof(tselect))) {\n\t\terr = -EFAULT;\n\t\tgoto __err;\n\t}\n\tsprintf(str, \"application %i\", current->pid);\n\tif (tselect.id.dev_class != SNDRV_TIMER_CLASS_SLAVE)\n\t\ttselect.id.dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION;\n\terr = snd_timer_open(&tu->timeri, str, &tselect.id, current->pid);\n \tif (err < 0)\n \t\tgoto __err;\n \n \tkfree(tu->queue);\n \ttu->queue = NULL;\n \tkfree(tu->tqueue);\n\ttu->tqueue = NULL;\n\tif (tu->tread) {\n\t\ttu->tqueue = kmalloc(tu->queue_size * sizeof(struct snd_timer_tread),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (tu->tqueue == NULL)\n\t\t\terr = -ENOMEM;\n\t} else {\n\t\ttu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),\n\t\t\t\t    GFP_KERNEL);\n\t\tif (tu->queue == NULL)\n\t\t\terr = -ENOMEM;\n\t}\n\n      \tif (err < 0) {\n\t\tsnd_timer_close(tu->timeri);\n      \t\ttu->timeri = NULL;\n      \t} else {\n\t\ttu->timeri->flags |= SNDRV_TIMER_IFLG_FAST;\n\t\ttu->timeri->callback = tu->tread\n\t\t\t? snd_timer_user_tinterrupt : snd_timer_user_interrupt;\n\t\ttu->timeri->ccallback = snd_timer_user_ccallback;\n\t\ttu->timeri->callback_data = (void *)tu;\n\t\ttu->timeri->disconnect = snd_timer_user_disconnect;\n\t}\n\n      __err:\n\treturn err;\n}\n", "target": 1, "idx": 180791}
{"func": "GF_Err name_Size(GF_Box *s)\n{\n\tGF_NameBox *ptr = (GF_NameBox *)s;\n\tif (ptr->string) ptr->size += strlen(ptr->string) + 1;\n\treturn GF_OK;\n}\n", "target": 0, "idx": 80284}
{"func": "asmlinkage long compat_sys_recvmmsg(int fd, struct compat_mmsghdr __user *mmsg,\n\t\t\t\t    unsigned int vlen, unsigned int flags,\n\t\t\t\t    struct compat_timespec __user *timeout)\n{\n\tint datagrams;\n\tstruct timespec ktspec;\n\n \tif (flags & MSG_CMSG_COMPAT)\n \t\treturn -EINVAL;\n \n\tif (COMPAT_USE_64BIT_TIME)\n\t\treturn __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t      flags | MSG_CMSG_COMPAT,\n\t\t\t\t      (struct timespec *) timeout);\n \tif (timeout == NULL)\n \t\treturn __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n \t\t\t\t      flags | MSG_CMSG_COMPAT, NULL);\n \n\tif (get_compat_timespec(&ktspec, timeout))\n \t\treturn -EFAULT;\n \n \tdatagrams = __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n \t\t\t\t   flags | MSG_CMSG_COMPAT, &ktspec);\n\tif (datagrams > 0 && put_compat_timespec(&ktspec, timeout))\n \t\tdatagrams = -EFAULT;\n \n \treturn datagrams;\n}\n", "target": 1, "idx": 179639}
{"func": "NO_INLINE JsVar *jspeFactorFunctionCall() {\n  /* The parent if we're executing a method call */\n  bool isConstructor = false;\n  if (lex->tk==LEX_R_NEW) {\n    JSP_ASSERT_MATCH(LEX_R_NEW);\n    isConstructor = true;\n\n    if (lex->tk==LEX_R_NEW) {\n      jsExceptionHere(JSET_ERROR, \"Nesting 'new' operators is unsupported\");\n      jspSetError(false);\n      return 0;\n    }\n  }\n\n  JsVar *parent = 0;\n#ifndef SAVE_ON_FLASH\n  bool wasSuper = lex->tk==LEX_R_SUPER;\n#endif\n  JsVar *a = jspeFactorMember(jspeFactor(), &parent);\n#ifndef SAVE_ON_FLASH\n  if (wasSuper) {\n    /* if this was 'super.something' then we need\n     * to overwrite the parent, because it'll be\n     * set to the prototype otherwise.\n     */\n    jsvUnLock(parent);\n    parent = jsvLockAgainSafe(execInfo.thisVar);\n  }\n#endif\n\n  while ((lex->tk=='(' || (isConstructor && JSP_SHOULD_EXECUTE)) && !jspIsInterrupted()) {\n    JsVar *funcName = a;\n    JsVar *func = jsvSkipName(funcName);\n\n    /* The constructor function doesn't change parsing, so if we're\n     * not executing, just short-cut it. */\n    if (isConstructor && JSP_SHOULD_EXECUTE) {\n      bool parseArgs = lex->tk=='(';\n      a = jspeConstruct(func, funcName, parseArgs);\n      isConstructor = false; // don't treat subsequent brackets as constructors\n    } else\n      a = jspeFunctionCall(func, funcName, parent, true, 0, 0);\n\n    jsvUnLock3(funcName, func, parent);\n    parent=0;\n    a = jspeFactorMember(a, &parent);\n  }\n#ifndef SAVE_ON_FLASH\n  /* If we've got something that we care about the parent of (eg. a getter/setter)\n   * then we repackage it into a 'NewChild' name that references the parent before\n   * we leave. Note: You can't do this on everything because normally NewChild\n   * forces a new child to be blindly created. It works on Getters/Setters because\n   * we *always* run those rather than adding them.\n   */\n  if (parent && jsvIsName(a) && !jsvIsNewChild(a)) {\n    JsVar *value = jsvGetValueOfName(a);\n    if (jsvIsGetterOrSetter(value)) { // no need to do this for functions since we've just executed whatever we needed to\n      JsVar *nameVar = jsvCopyNameOnly(a,false,true);\n      JsVar *newChild = jsvCreateNewChild(parent, nameVar, value);\n      jsvUnLock2(nameVar, a);\n      a = newChild;\n    }\n    jsvUnLock(value);\n  }\n#endif\n  jsvUnLock(parent);\n  return a;\n}\n", "target": 0, "idx": 82347}
{"func": "void ThreadableBlobRegistry::registerBlobURL(SecurityOrigin* origin, const KURL& url, const KURL& srcURL)\n {\n     if (origin && BlobURL::getOrigin(url) == \"null\")\n         originMap()->add(url.string(), origin);\n \n    if (isMainThread())\n        blobRegistry().registerBlobURL(url, srcURL);\n    else {\n         OwnPtr<BlobRegistryContext> context = adoptPtr(new BlobRegistryContext(url, srcURL));\n         callOnMainThread(&registerBlobURLFromTask, context.leakPtr());\n     }\n}\n", "target": 1, "idx": 184259}
{"func": "PHP_FUNCTION(openssl_x509_check_private_key)\n{\n\tzval ** zcert, **zkey;\n\tX509 * cert = NULL;\n\tEVP_PKEY * key = NULL;\n\tlong certresource = -1, keyresource = -1;\n\n\tRETVAL_FALSE;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ZZ\", &zcert, &zkey) == FAILURE) {\n\t\treturn;\n\t}\n\tcert = php_openssl_x509_from_zval(zcert, 0, &certresource TSRMLS_CC);\n\tif (cert == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tkey = php_openssl_evp_from_zval(zkey, 0, \"\", 1, &keyresource TSRMLS_CC);\n\tif (key) {\n\t\tRETVAL_BOOL(X509_check_private_key(cert, key));\n\t}\n\n\tif (keyresource == -1 && key) {\n\t\tEVP_PKEY_free(key);\n\t}\n\tif (certresource == -1 && cert) {\n\t\tX509_free(cert);\n\t}\n }\n", "target": 0, "idx": 2020}
{"func": " queue_unlock(struct futex_q *q, struct futex_hash_bucket *hb)\n {\n \tspin_unlock(&hb->lock);\n\tdrop_futex_key_refs(&q->key);\n }\n", "target": 1, "idx": 179624}
{"func": "static int asepcos_build_pin_apdu(sc_card_t *card, sc_apdu_t *apdu,\n\tstruct sc_pin_cmd_data *data, u8 *buf, size_t buf_len,\n\tunsigned int cmd, int is_puk)\n{\n\tint r, fileid;\n\tu8  *p = buf;\n\tsc_cardctl_asepcos_akn2fileid_t st;\n\n\tswitch (cmd) {\n\tcase SC_PIN_CMD_VERIFY:\n\t\tst.akn = data->pin_reference;\n\t\tr = asepcos_akn_to_fileid(card, &st);\n\t\tif (r != SC_SUCCESS)\n\t\t\treturn r;\n\t\tfileid = st.fileid;\n\t\t/* the fileid of the puk is the fileid of the pin + 1 */\n\t\tif (is_puk != 0)\n\t\t\tfileid++;\n\t\tsc_format_apdu(card, apdu, SC_APDU_CASE_3_SHORT, 0x20, 0x02, 0x80);\n\t\t*p++ = (fileid >> 24) & 0xff;\n\t\t*p++ = (fileid >> 16) & 0xff;\n\t\t*p++ = (fileid >> 8 ) & 0xff;\n\t\t*p++ = fileid & 0xff;\n\t\tmemcpy(p, data->pin1.data, data->pin1.len);\n\t\tp += data->pin1.len;\n\t\tapdu->lc       = p - buf;\n\t\tapdu->datalen  = p - buf;\n\t\tapdu->data     = buf;\n\t\tbreak;\n\tcase SC_PIN_CMD_CHANGE:\n\t\t/* build the CHANGE KEY apdu. Note: the PIN file is implicitly\n\t\t * selected by its SFID */\n\t\t*p++ = 0x81;\n\t\t*p++ = data->pin2.len & 0xff;\n\t\tmemcpy(p, data->pin2.data, data->pin2.len);\n\t\tp   += data->pin2.len;\n\t\tst.akn = data->pin_reference;\n\t\tr = asepcos_akn_to_fileid(card, &st);\n\t\tif (r != SC_SUCCESS)\n\t\t\treturn r;\n\t\tfileid = 0x80 | (st.fileid & 0x1f);\n\t\tsc_format_apdu(card, apdu, SC_APDU_CASE_3_SHORT, 0x24, 0x01, fileid);\n\t\tapdu->lc       = p - buf;\n\t\tapdu->datalen  = p - buf;\n\t\tapdu->data     = buf;\n\t\tbreak;\n\tcase SC_PIN_CMD_UNBLOCK:\n\t\t/* build the UNBLOCK KEY apdu. The PIN file is implicitly \n\t\t * selected by its SFID. The new PIN is provided in the\n\t\t * data field of the UNBLOCK KEY command. */\n\t\t*p++ = 0x81;\n\t\t*p++ = data->pin2.len & 0xff;\n\t\tmemcpy(p, data->pin2.data, data->pin2.len);\n\t\tp   += data->pin2.len;\n\t\tst.akn = data->pin_reference;\n\t\tr = asepcos_akn_to_fileid(card, &st);\n\t\tif (r != SC_SUCCESS)\n\t\t\treturn r;\n\t\tfileid = 0x80 | (st.fileid & 0x1f);\n\t\tsc_format_apdu(card, apdu, SC_APDU_CASE_3_SHORT, 0x2C, 0x02, fileid);\n\t\tapdu->lc       = p - buf;\n\t\tapdu->datalen  = p - buf;\n\t\tapdu->data     = buf;\n\t\tbreak;\n\tdefault:\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t}\n\treturn SC_SUCCESS;\n}\n", "target": 0, "idx": 78153}
{"func": "int t2p_process_jpeg_strip(\n\tunsigned char* strip, \n\ttsize_t* striplength, \n\tunsigned char* buffer, \n    tsize_t buffersize,\n\ttsize_t* bufferoffset, \n\ttstrip_t no, \n\tuint32 height){\n\n\ttsize_t i=0;\n\n\twhile (i < *striplength) {\n\t\ttsize_t datalen;\n\t\tuint16 ri;\n\t\tuint16 v_samp;\n\t\tuint16 h_samp;\n\t\tint j;\n\t\tint ncomp;\n\n\t\t/* marker header: one or more FFs */\n\t\tif (strip[i] != 0xff)\n\t\t\treturn(0);\n\t\ti++;\n\t\twhile (i < *striplength && strip[i] == 0xff)\n\t\t\ti++;\n\t\tif (i >= *striplength)\n\t\t\treturn(0);\n\t\t/* SOI is the only pre-SOS marker without a length word */\n\t\tif (strip[i] == 0xd8)\n\t\t\tdatalen = 0;\n\t\telse {\n\t\t\tif ((*striplength - i) <= 2)\n\t\t\t\treturn(0);\n\t\t\tdatalen = (strip[i+1] << 8) | strip[i+2];\n\t\t\tif (datalen < 2 || datalen >= (*striplength - i))\n\t\t\t\treturn(0);\n\t\t}\n\t\tswitch( strip[i] ){\n\t\t\tcase 0xd8:\t/* SOI - start of image */\n                if( *bufferoffset + 2 > buffersize )\n                    return(0);\n\t\t\t\t_TIFFmemcpy(&(buffer[*bufferoffset]), &(strip[i-1]), 2);\n\t\t\t\t*bufferoffset+=2;\n\t\t\t\tbreak;\n\t\t\tcase 0xc0:\t/* SOF0 */\n\t\t\tcase 0xc1:\t/* SOF1 */\n\t\t\tcase 0xc3:\t/* SOF3 */\n\t\t\tcase 0xc9:\t/* SOF9 */\n\t\t\tcase 0xca:\t/* SOF10 */\n\t\t\t\tif(no==0){\n                    if( *bufferoffset + datalen + 2 + 6 > buffersize )\n                        return(0);\n\t\t\t\t\t_TIFFmemcpy(&(buffer[*bufferoffset]), &(strip[i-1]), datalen+2);\n                    if( *bufferoffset + 9 >= buffersize )\n                        return(0);\n\t\t\t\t\tncomp = buffer[*bufferoffset+9];\n\t\t\t\t\tif (ncomp < 1 || ncomp > 4)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t\tv_samp=1;\n\t\t\t\t\th_samp=1;\n                    if( *bufferoffset + 11 + 3*(ncomp-1) >= buffersize )\n                        return(0);\n\t\t\t\t\tfor(j=0;j<ncomp;j++){\n\t\t\t\t\t\tuint16 samp = buffer[*bufferoffset+11+(3*j)];\n\t\t\t\t\t\tif( (samp>>4) > h_samp) \n\t\t\t\t\t\t\th_samp = (samp>>4);\n\t\t\t\t\t\tif( (samp & 0x0f) > v_samp) \n\t\t\t\t\t\t\tv_samp = (samp & 0x0f);\n\t\t\t\t\t}\n\t\t\t\t\tv_samp*=8;\n\t\t\t\t\th_samp*=8;\n\t\t\t\t\tri=((( ((uint16)(buffer[*bufferoffset+5])<<8) | \n\t\t\t\t\t(uint16)(buffer[*bufferoffset+6]) )+v_samp-1)/ \n\t\t\t\t\tv_samp);\n\t\t\t\t\tri*=((( ((uint16)(buffer[*bufferoffset+7])<<8) | \n\t\t\t\t\t(uint16)(buffer[*bufferoffset+8]) )+h_samp-1)/ \n\t\t\t\t\th_samp);\n\t\t\t\t\tbuffer[*bufferoffset+5]=\n                                          (unsigned char) ((height>>8) & 0xff);\n\t\t\t\t\tbuffer[*bufferoffset+6]=\n                                            (unsigned char) (height & 0xff);\n\t\t\t\t\t*bufferoffset+=datalen+2;\n\t\t\t\t\t/* insert a DRI marker */\n\t\t\t\t\tbuffer[(*bufferoffset)++]=0xff;\n\t\t\t\t\tbuffer[(*bufferoffset)++]=0xdd;\n\t\t\t\t\tbuffer[(*bufferoffset)++]=0x00;\n\t\t\t\t\tbuffer[(*bufferoffset)++]=0x04;\n\t\t\t\t\tbuffer[(*bufferoffset)++]=(ri >> 8) & 0xff;\n\t\t\t\t\tbuffer[(*bufferoffset)++]= ri & 0xff;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 0xc4: /* DHT */\n\t\t\tcase 0xdb: /* DQT */\n                if( *bufferoffset + datalen + 2 > buffersize )\n                    return(0);\n\t\t\t\t_TIFFmemcpy(&(buffer[*bufferoffset]), &(strip[i-1]), datalen+2);\n\t\t\t\t*bufferoffset+=datalen+2;\n\t\t\t\tbreak;\n\t\t\tcase 0xda: /* SOS */\n\t\t\t\tif(no==0){\n                    if( *bufferoffset + datalen + 2 > buffersize )\n                        return(0);\n\t\t\t\t\t_TIFFmemcpy(&(buffer[*bufferoffset]), &(strip[i-1]), datalen+2);\n\t\t\t\t\t*bufferoffset+=datalen+2;\n\t\t\t\t} else {\n                    if( *bufferoffset + 2 > buffersize )\n                        return(0);\n\t\t\t\t\tbuffer[(*bufferoffset)++]=0xff;\n\t\t\t\t\tbuffer[(*bufferoffset)++]=\n                                            (unsigned char)(0xd0 | ((no-1)%8));\n\t\t\t\t}\n\t\t\t\ti += datalen + 1;\n\t\t\t\t/* copy remainder of strip */\n                if( *bufferoffset + *striplength - i > buffersize )\n                    return(0);\n\t\t\t\t_TIFFmemcpy(&(buffer[*bufferoffset]), &(strip[i]), *striplength - i);\n\t\t\t\t*bufferoffset+= *striplength - i;\n\t\t\t\treturn(1);\n\t\t\tdefault:\n\t\t\t\t/* ignore any other marker */\n\t\t\t\tbreak;\n\t\t}\n\t\ti += datalen + 1;\n\t}\n\n\t/* failed to find SOS marker */\n\treturn(0);\n}\n", "target": 0, "idx": 71378}
{"func": "static netdev_tx_t hns_nic_net_xmit(struct sk_buff *skb,\n \t\t\t\t    struct net_device *ndev)\n {\n \tstruct hns_nic_priv *priv = netdev_priv(ndev);\n\tint ret;\n \n \tassert(skb->queue_mapping < ndev->ae_handle->q_num);\n\tret = hns_nic_net_xmit_hw(ndev, skb,\n\t\t\t\t  &tx_ring_data(priv, skb->queue_mapping));\n\tif (ret == NETDEV_TX_OK) {\n\t\tnetif_trans_update(ndev);\n\t\tndev->stats.tx_bytes += skb->len;\n\t\tndev->stats.tx_packets++;\n\t}\n\treturn (netdev_tx_t)ret;\n }\n", "target": 1, "idx": 182575}
{"func": "static SharedMemorySupport DoQuerySharedMemorySupport(Display* dpy) {\n  int dummy;\n  Bool pixmaps_supported;\n  if (!XShmQueryVersion(dpy, &dummy, &dummy, &pixmaps_supported))\n    return SHARED_MEMORY_NONE;\n\n#if defined(OS_FREEBSD)\n  int allow_removed;\n  size_t length = sizeof(allow_removed);\n\n  if ((sysctlbyname(\"kern.ipc.shm_allow_removed\", &allow_removed, &length,\n      NULL, 0) < 0) || allow_removed < 1) {\n    return SHARED_MEMORY_NONE;\n  }\n #endif\n \n  int shmkey = shmget(IPC_PRIVATE, 1, 0666);\n  if (shmkey == -1)\n     return SHARED_MEMORY_NONE;\n   void* address = shmat(shmkey, NULL, 0);\n   shmctl(shmkey, IPC_RMID, NULL);\n\n  XShmSegmentInfo shminfo;\n  memset(&shminfo, 0, sizeof(shminfo));\n  shminfo.shmid = shmkey;\n \n   gdk_error_trap_push();\n   bool result = XShmAttach(dpy, &shminfo);\n   XSync(dpy, False);\n   if (gdk_error_trap_pop())\n     result = false;\n   shmdt(address);\n  if (!result)\n     return SHARED_MEMORY_NONE;\n \n   XShmDetach(dpy, &shminfo);\n   return pixmaps_supported ? SHARED_MEMORY_PIXMAP : SHARED_MEMORY_PUTIMAGE;\n}\n", "target": 1, "idx": 185297}
{"func": "static inline void unmap_mapping_range_tree(struct rb_root *root,\n\t\t\t\t\t    struct zap_details *details)\n{\n\tstruct vm_area_struct *vma;\n\tpgoff_t vba, vea, zba, zea;\n\n\tvma_interval_tree_foreach(vma, root,\n\t\t\tdetails->first_index, details->last_index) {\n\n\t\tvba = vma->vm_pgoff;\n\t\tvea = vba + vma_pages(vma) - 1;\n\t\t/* Assume for now that PAGE_CACHE_SHIFT == PAGE_SHIFT */\n\t\tzba = details->first_index;\n\t\tif (zba < vba)\n\t\t\tzba = vba;\n\t\tzea = details->last_index;\n\t\tif (zea > vea)\n\t\t\tzea = vea;\n\n\t\tunmap_mapping_range_vma(vma,\n\t\t\t((zba - vba) << PAGE_SHIFT) + vma->vm_start,\n\t\t\t((zea - vba + 1) << PAGE_SHIFT) + vma->vm_start,\n\t\t\t\tdetails);\n\t}\n}\n", "target": 0, "idx": 57893}
{"func": "ikev1_n_print(netdissect_options *ndo, u_char tpay _U_,\n\t      const struct isakmp_gen *ext, u_int item_len,\n\t      const u_char *ep, uint32_t phase _U_, uint32_t doi0 _U_,\n\t      uint32_t proto0 _U_, int depth _U_)\n{\n\tconst struct ikev1_pl_n *p;\n\tstruct ikev1_pl_n n;\n\tconst u_char *cp;\n\tconst u_char *ep2;\n\tuint32_t doi;\n\tuint32_t proto;\n\tstatic const char *notify_error_str[] = {\n\t\tNULL,\t\t\t\t\"INVALID-PAYLOAD-TYPE\",\n\t\t\"DOI-NOT-SUPPORTED\",\t\t\"SITUATION-NOT-SUPPORTED\",\n\t\t\"INVALID-COOKIE\",\t\t\"INVALID-MAJOR-VERSION\",\n\t\t\"INVALID-MINOR-VERSION\",\t\"INVALID-EXCHANGE-TYPE\",\n\t\t\"INVALID-FLAGS\",\t\t\"INVALID-MESSAGE-ID\",\n\t\t\"INVALID-PROTOCOL-ID\",\t\t\"INVALID-SPI\",\n\t\t\"INVALID-TRANSFORM-ID\",\t\t\"ATTRIBUTES-NOT-SUPPORTED\",\n\t\t\"NO-PROPOSAL-CHOSEN\",\t\t\"BAD-PROPOSAL-SYNTAX\",\n\t\t\"PAYLOAD-MALFORMED\",\t\t\"INVALID-KEY-INFORMATION\",\n\t\t\"INVALID-ID-INFORMATION\",\t\"INVALID-CERT-ENCODING\",\n\t\t\"INVALID-CERTIFICATE\",\t\t\"CERT-TYPE-UNSUPPORTED\",\n\t\t\"INVALID-CERT-AUTHORITY\",\t\"INVALID-HASH-INFORMATION\",\n\t\t\"AUTHENTICATION-FAILED\",\t\"INVALID-SIGNATURE\",\n\t\t\"ADDRESS-NOTIFICATION\",\t\t\"NOTIFY-SA-LIFETIME\",\n\t\t\"CERTIFICATE-UNAVAILABLE\",\t\"UNSUPPORTED-EXCHANGE-TYPE\",\n\t\t\"UNEQUAL-PAYLOAD-LENGTHS\",\n\t};\n\tstatic const char *ipsec_notify_error_str[] = {\n\t\t\"RESERVED\",\n\t};\n\tstatic const char *notify_status_str[] = {\n\t\t\"CONNECTED\",\n\t};\n\tstatic const char *ipsec_notify_status_str[] = {\n\t\t\"RESPONDER-LIFETIME\",\t\t\"REPLAY-STATUS\",\n\t\t\"INITIAL-CONTACT\",\n\t};\n/* NOTE: these macro must be called with x in proper range */\n\n/* 0 - 8191 */\n#define NOTIFY_ERROR_STR(x) \\\n\tSTR_OR_ID((x), notify_error_str)\n\n/* 8192 - 16383 */\n#define IPSEC_NOTIFY_ERROR_STR(x) \\\n\tSTR_OR_ID((u_int)((x) - 8192), ipsec_notify_error_str)\n\n/* 16384 - 24575 */\n#define NOTIFY_STATUS_STR(x) \\\n\tSTR_OR_ID((u_int)((x) - 16384), notify_status_str)\n\n/* 24576 - 32767 */\n#define IPSEC_NOTIFY_STATUS_STR(x) \\\n\tSTR_OR_ID((u_int)((x) - 24576), ipsec_notify_status_str)\n\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_N)));\n\n\tp = (const struct ikev1_pl_n *)ext;\n\tND_TCHECK(*p);\n\tUNALIGNED_MEMCPY(&n, ext, sizeof(n));\n\tdoi = ntohl(n.doi);\n\tproto = n.prot_id;\n\tif (doi != 1) {\n\t\tND_PRINT((ndo,\" doi=%d\", doi));\n\t\tND_PRINT((ndo,\" proto=%d\", proto));\n\t\tif (ntohs(n.type) < 8192)\n\t\t\tND_PRINT((ndo,\" type=%s\", NOTIFY_ERROR_STR(ntohs(n.type))));\n\t\telse if (ntohs(n.type) < 16384)\n\t\t\tND_PRINT((ndo,\" type=%s\", numstr(ntohs(n.type))));\n\t\telse if (ntohs(n.type) < 24576)\n\t\t\tND_PRINT((ndo,\" type=%s\", NOTIFY_STATUS_STR(ntohs(n.type))));\n\t\telse\n\t\t\tND_PRINT((ndo,\" type=%s\", numstr(ntohs(n.type))));\n\t\tif (n.spi_size) {\n\t\t\tND_PRINT((ndo,\" spi=\"));\n\t\t\tif (!rawprint(ndo, (const uint8_t *)(p + 1), n.spi_size))\n\t\t\t\tgoto trunc;\n\t\t}\n\t\treturn (const u_char *)(p + 1) + n.spi_size;\n\t}\n\n\tND_PRINT((ndo,\" doi=ipsec\"));\n\tND_PRINT((ndo,\" proto=%s\", PROTOIDSTR(proto)));\n\tif (ntohs(n.type) < 8192)\n\t\tND_PRINT((ndo,\" type=%s\", NOTIFY_ERROR_STR(ntohs(n.type))));\n\telse if (ntohs(n.type) < 16384)\n\t\tND_PRINT((ndo,\" type=%s\", IPSEC_NOTIFY_ERROR_STR(ntohs(n.type))));\n\telse if (ntohs(n.type) < 24576)\n\t\tND_PRINT((ndo,\" type=%s\", NOTIFY_STATUS_STR(ntohs(n.type))));\n\telse if (ntohs(n.type) < 32768)\n\t\tND_PRINT((ndo,\" type=%s\", IPSEC_NOTIFY_STATUS_STR(ntohs(n.type))));\n\telse\n\t\tND_PRINT((ndo,\" type=%s\", numstr(ntohs(n.type))));\n\tif (n.spi_size) {\n\t\tND_PRINT((ndo,\" spi=\"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(p + 1), n.spi_size))\n\t\t\tgoto trunc;\n\t}\n\n\tcp = (const u_char *)(p + 1) + n.spi_size;\n\tep2 = (const u_char *)p + item_len;\n\n\tif (cp < ep) {\n\t\tswitch (ntohs(n.type)) {\n\t\tcase IPSECDOI_NTYPE_RESPONDER_LIFETIME:\n\t\t    {\n\t\t\tconst struct attrmap *map = oakley_t_map;\n \t\t\tsize_t nmap = sizeof(oakley_t_map)/sizeof(oakley_t_map[0]);\n \t\t\tND_PRINT((ndo,\" attrs=(\"));\n \t\t\twhile (cp < ep && cp < ep2) {\n\t\t\t\tcp = ikev1_attrmap_print(ndo, cp,\n\t\t\t\t\t(ep < ep2) ? ep : ep2, map, nmap);\n \t\t\t}\n \t\t\tND_PRINT((ndo,\")\"));\n \t\t\tbreak;\n\t\t    }\n\t\tcase IPSECDOI_NTYPE_REPLAY_STATUS:\n\t\t\tND_PRINT((ndo,\" status=(\"));\n\t\t\tND_PRINT((ndo,\"replay detection %sabled\",\n\t\t\t\t  EXTRACT_32BITS(cp) ? \"en\" : \"dis\"));\n\t\t\tND_PRINT((ndo,\")\"));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/*\n\t\t\t * XXX - fill in more types here; see, for example,\n\t\t\t * draft-ietf-ipsec-notifymsg-04.\n\t\t\t */\n\t\t\tif (ndo->ndo_vflag > 3) {\n\t\t\t\tND_PRINT((ndo,\" data=(\"));\n\t\t\t\tif (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))\n\t\t\t\t\tgoto trunc;\n\t\t\t\tND_PRINT((ndo,\")\"));\n\t\t\t} else {\n\t\t\t\tif (!ike_show_somedata(ndo, cp, ep))\n\t\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (const u_char *)ext + item_len;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_N)));\n\treturn NULL;\n}\n", "target": 1, "idx": 181013}
{"func": "int udp6_seq_show(struct seq_file *seq, void *v)\n{\n\tif (v == SEQ_START_TOKEN)\n\t\tseq_printf(seq,\n\t\t\t   \"  sl  \"\n\t\t\t   \"local_address                         \"\n\t\t\t   \"remote_address                        \"\n\t\t\t   \"st tx_queue rx_queue tr tm->when retrnsmt\"\n\t\t\t   \"   uid  timeout inode ref pointer drops\\n\");\n\telse\n\t\tudp6_sock_seq_show(seq, v, ((struct udp_iter_state *)seq->private)->bucket);\n\treturn 0;\n}\n", "target": 0, "idx": 22757}
{"func": "WORD32 ih264d_video_decode(iv_obj_t *dec_hdl, void *pv_api_ip, void *pv_api_op)\n{\n /* ! */\n\n dec_struct_t * ps_dec = (dec_struct_t *)(dec_hdl->pv_codec_handle);\n\n    WORD32 i4_err_status = 0;\n    UWORD8 *pu1_buf = NULL;\n    WORD32 buflen;\n    UWORD32 u4_max_ofst, u4_length_of_start_code = 0;\n\n    UWORD32 bytes_consumed = 0;\n    UWORD32 cur_slice_is_nonref = 0;\n    UWORD32 u4_next_is_aud;\n    UWORD32 u4_first_start_code_found = 0;\n    WORD32 ret = 0,api_ret_value = IV_SUCCESS;\n    WORD32 header_data_left = 0,frame_data_left = 0;\n    UWORD8 *pu1_bitstrm_buf;\n ivd_video_decode_ip_t *ps_dec_ip;\n ivd_video_decode_op_t *ps_dec_op;\n\n    ithread_set_name((void*)\"Parse_thread\");\n\n    ps_dec_ip = (ivd_video_decode_ip_t *)pv_api_ip;\n    ps_dec_op = (ivd_video_decode_op_t *)pv_api_op;\n\n {\n        UWORD32 u4_size;\n        u4_size = ps_dec_op->u4_size;\n        memset(ps_dec_op, 0, sizeof(ivd_video_decode_op_t));\n        ps_dec_op->u4_size = u4_size;\n }\n\n    ps_dec->pv_dec_out = ps_dec_op;\n if(ps_dec->init_done != 1)\n {\n return IV_FAIL;\n }\n\n /*Data memory barries instruction,so that bitstream write by the application is complete*/\n    DATA_SYNC();\n\n if(0 == ps_dec->u1_flushfrm)\n {\n if(ps_dec_ip->pv_stream_buffer == NULL)\n {\n            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n            ps_dec_op->u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL;\n return IV_FAIL;\n }\n if(ps_dec_ip->u4_num_Bytes <= 0)\n {\n            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n            ps_dec_op->u4_error_code |= IVD_DEC_NUMBYTES_INV;\n return IV_FAIL;\n\n }\n }\n    ps_dec->u1_pic_decode_done = 0;\n\n    ps_dec_op->u4_num_bytes_consumed = 0;\n\n    ps_dec->ps_out_buffer = NULL;\n\n if(ps_dec_ip->u4_size\n >= offsetof(ivd_video_decode_ip_t, s_out_buffer))\n        ps_dec->ps_out_buffer = &ps_dec_ip->s_out_buffer;\n\n    ps_dec->u4_fmt_conv_cur_row = 0;\n\n    ps_dec->u4_output_present = 0;\n    ps_dec->s_disp_op.u4_error_code = 1;\n    ps_dec->u4_fmt_conv_num_rows = FMT_CONV_NUM_ROWS;\n if(0 == ps_dec->u4_share_disp_buf\n && ps_dec->i4_decode_header == 0)\n {\n        UWORD32 i;\n if((ps_dec->ps_out_buffer->u4_num_bufs == 0) ||\n (ps_dec->ps_out_buffer->u4_num_bufs > IVD_VIDDEC_MAX_IO_BUFFERS))\n {\n            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n            ps_dec_op->u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS;\n return IV_FAIL;\n }\n\n for(i = 0; i < ps_dec->ps_out_buffer->u4_num_bufs; i++)\n {\n if(ps_dec->ps_out_buffer->pu1_bufs[i] == NULL)\n {\n                ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n                ps_dec_op->u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL;\n return IV_FAIL;\n }\n\n if(ps_dec->ps_out_buffer->u4_min_out_buf_size[i] == 0)\n {\n                ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n                ps_dec_op->u4_error_code |=\n                                IVD_DISP_FRM_ZERO_OP_BUF_SIZE;\n return IV_FAIL;\n }\n }\n }\n\n if(ps_dec->u4_total_frames_decoded >= NUM_FRAMES_LIMIT)\n {\n        ps_dec_op->u4_error_code = ERROR_FRAME_LIMIT_OVER;\n return IV_FAIL;\n }\n\n /* ! */\n    ps_dec->u4_ts = ps_dec_ip->u4_ts;\n\n    ps_dec_op->u4_error_code = 0;\n    ps_dec_op->e_pic_type = -1;\n    ps_dec_op->u4_output_present = 0;\n    ps_dec_op->u4_frame_decoded_flag = 0;\n\n    ps_dec->i4_frametype = -1;\n    ps_dec->i4_content_type = -1;\n\n    ps_dec->u4_slice_start_code_found = 0;\n\n /* In case the deocder is not in flush mode(in shared mode),\n     then decoder has to pick up a buffer to write current frame.\n     Check if a frame is available in such cases */\n\n if(ps_dec->u1_init_dec_flag == 1 && ps_dec->u4_share_disp_buf == 1\n && ps_dec->u1_flushfrm == 0)\n {\n        UWORD32 i;\n\n        WORD32 disp_avail = 0, free_id;\n\n /* Check if at least one buffer is available with the codec */\n /* If not then return to application with error */\n for(i = 0; i < ps_dec->u1_pic_bufs; i++)\n {\n if(0 == ps_dec->u4_disp_buf_mapping[i]\n || 1 == ps_dec->u4_disp_buf_to_be_freed[i])\n {\n                disp_avail = 1;\n break;\n }\n\n }\n\n if(0 == disp_avail)\n {\n /* If something is queued for display wait for that buffer to be returned */\n\n            ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;\n            ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);\n return (IV_FAIL);\n }\n\n while(1)\n {\n pic_buffer_t *ps_pic_buf;\n            ps_pic_buf = (pic_buffer_t *)ih264_buf_mgr_get_next_free(\n (buf_mgr_t *)ps_dec->pv_pic_buf_mgr, &free_id);\n\n if(ps_pic_buf == NULL)\n {\n                UWORD32 i, display_queued = 0;\n\n /* check if any buffer was given for display which is not returned yet */\n for(i = 0; i < (MAX_DISP_BUFS_NEW); i++)\n {\n if(0 != ps_dec->u4_disp_buf_mapping[i])\n {\n                        display_queued = 1;\n break;\n }\n }\n /* If some buffer is queued for display, then codec has to singal an error and wait\n                 for that buffer to be returned.\n                 If nothing is queued for display then codec has ownership of all display buffers\n                 and it can reuse any of the existing buffers and continue decoding */\n\n if(1 == display_queued)\n {\n /* If something is queued for display wait for that buffer to be returned */\n                    ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;\n                    ps_dec_op->u4_error_code |= (1\n << IVD_UNSUPPORTEDPARAM);\n return (IV_FAIL);\n }\n }\n else\n {\n /* If the buffer is with display, then mark it as in use and then look for a buffer again */\n if(1 == ps_dec->u4_disp_buf_mapping[free_id])\n {\n                    ih264_buf_mgr_set_status(\n (buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n                                    free_id,\n                                    BUF_MGR_IO);\n }\n else\n {\n /**\n                     *  Found a free buffer for present call. Release it now.\n                     *  Will be again obtained later.\n                     */\n                    ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n                                          free_id,\n                                          BUF_MGR_IO);\n break;\n }\n }\n }\n\n }\n\n if(ps_dec->u1_flushfrm)\n {\n if(ps_dec->u1_init_dec_flag == 0)\n {\n /*Come out of flush mode and return*/\n            ps_dec->u1_flushfrm = 0;\n return (IV_FAIL);\n }\n\n\n\n        ih264d_get_next_display_field(ps_dec, ps_dec->ps_out_buffer,\n &(ps_dec->s_disp_op));\n if(0 == ps_dec->s_disp_op.u4_error_code)\n {\n /* check output buffer size given by the application */\n if(check_app_out_buf_size(ps_dec) != IV_SUCCESS)\n {\n                ps_dec_op->u4_error_code= IVD_DISP_FRM_ZERO_OP_BUF_SIZE;\n return (IV_FAIL);\n }\n\n            ps_dec->u4_fmt_conv_cur_row = 0;\n            ps_dec->u4_fmt_conv_num_rows = ps_dec->s_disp_frame_info.u4_y_ht;\n            ih264d_format_convert(ps_dec, &(ps_dec->s_disp_op),\n                                  ps_dec->u4_fmt_conv_cur_row,\n                                  ps_dec->u4_fmt_conv_num_rows);\n            ps_dec->u4_fmt_conv_cur_row += ps_dec->u4_fmt_conv_num_rows;\n            ps_dec->u4_output_present = 1;\n\n }\n        ih264d_release_display_field(ps_dec, &(ps_dec->s_disp_op));\n\n        ps_dec_op->u4_pic_wd = (UWORD32)ps_dec->u2_disp_width;\n        ps_dec_op->u4_pic_ht = (UWORD32)ps_dec->u2_disp_height;\n\n        ps_dec_op->u4_new_seq = 0;\n\n        ps_dec_op->u4_output_present = ps_dec->u4_output_present;\n        ps_dec_op->u4_progressive_frame_flag =\n                        ps_dec->s_disp_op.u4_progressive_frame_flag;\n        ps_dec_op->e_output_format =\n                        ps_dec->s_disp_op.e_output_format;\n        ps_dec_op->s_disp_frm_buf = ps_dec->s_disp_op.s_disp_frm_buf;\n        ps_dec_op->e4_fld_type = ps_dec->s_disp_op.e4_fld_type;\n        ps_dec_op->u4_ts = ps_dec->s_disp_op.u4_ts;\n        ps_dec_op->u4_disp_buf_id = ps_dec->s_disp_op.u4_disp_buf_id;\n\n /*In the case of flush ,since no frame is decoded set pic type as invalid*/\n        ps_dec_op->u4_is_ref_flag = -1;\n        ps_dec_op->e_pic_type = IV_NA_FRAME;\n        ps_dec_op->u4_frame_decoded_flag = 0;\n\n if(0 == ps_dec->s_disp_op.u4_error_code)\n {\n return (IV_SUCCESS);\n }\n else\n return (IV_FAIL);\n\n }\n if(ps_dec->u1_res_changed == 1)\n {\n /*if resolution has changed and all buffers have been flushed, reset decoder*/\n        ih264d_init_decoder(ps_dec);\n }\n\n    ps_dec->u4_prev_nal_skipped = 0;\n\n    ps_dec->u2_cur_mb_addr = 0;\n    ps_dec->u2_total_mbs_coded = 0;\n    ps_dec->u2_cur_slice_num = 0;\n    ps_dec->cur_dec_mb_num = 0;\n    ps_dec->cur_recon_mb_num = 0;\n    ps_dec->u4_first_slice_in_pic = 1;\n    ps_dec->u1_slice_header_done = 0;\n    ps_dec->u1_dangling_field = 0;\n\n    ps_dec->u4_dec_thread_created = 0;\n    ps_dec->u4_bs_deblk_thread_created = 0;\n    ps_dec->u4_cur_bs_mb_num = 0;\n    ps_dec->u4_start_recon_deblk  = 0;\n    ps_dec->u4_sps_cnt_in_process = 0;\n\n    DEBUG_THREADS_PRINTF(\" Starting process call\\n\");\n\n\n    ps_dec->u4_pic_buf_got = 0;\n\n do\n {\n        WORD32 buf_size;\n\n        pu1_buf = (UWORD8*)ps_dec_ip->pv_stream_buffer\n + ps_dec_op->u4_num_bytes_consumed;\n\n        u4_max_ofst = ps_dec_ip->u4_num_Bytes\n - ps_dec_op->u4_num_bytes_consumed;\n\n /* If dynamic bitstream buffer is not allocated and\n         * header decode is done, then allocate dynamic bitstream buffer\n         */\n if((NULL == ps_dec->pu1_bits_buf_dynamic) &&\n (ps_dec->i4_header_decoded & 1))\n {\n            WORD32 size;\n\n\n             void *pv_buf;\n             void *pv_mem_ctxt = ps_dec->pv_mem_ctxt;\n             size = MAX(256000, ps_dec->u2_pic_wd * ps_dec->u2_pic_ht * 3 / 2);\n            pv_buf = ps_dec->pf_aligned_alloc(pv_mem_ctxt, 128, size);\n             RETURN_IF((NULL == pv_buf), IV_FAIL);\n             ps_dec->pu1_bits_buf_dynamic = pv_buf;\n             ps_dec->u4_dynamic_bits_buf_size = size;\n }\n\n if(ps_dec->pu1_bits_buf_dynamic)\n {\n            pu1_bitstrm_buf = ps_dec->pu1_bits_buf_dynamic;\n            buf_size = ps_dec->u4_dynamic_bits_buf_size;\n }\n else\n {\n            pu1_bitstrm_buf = ps_dec->pu1_bits_buf_static;\n            buf_size = ps_dec->u4_static_bits_buf_size;\n }\n\n        u4_next_is_aud = 0;\n\n        buflen = ih264d_find_start_code(pu1_buf, 0, u4_max_ofst,\n &u4_length_of_start_code,\n &u4_next_is_aud);\n\n if(buflen == -1)\n            buflen = 0;\n /* Ignore bytes beyond the allocated size of intermediate buffer */\n /* Since 8 bytes are read ahead, ensure 8 bytes are free at the\n        end of the buffer, which will be memset to 0 after emulation prevention */\n        buflen = MIN(buflen, buf_size - 8);\n\n        bytes_consumed = buflen + u4_length_of_start_code;\n        ps_dec_op->u4_num_bytes_consumed += bytes_consumed;\n\n {\n            UWORD8 u1_firstbyte, u1_nal_ref_idc;\n\n if(ps_dec->i4_app_skip_mode == IVD_SKIP_B)\n {\n                u1_firstbyte = *(pu1_buf + u4_length_of_start_code);\n                u1_nal_ref_idc = (UWORD8)(NAL_REF_IDC(u1_firstbyte));\n if(u1_nal_ref_idc == 0)\n {\n /*skip non reference frames*/\n                    cur_slice_is_nonref = 1;\n continue;\n }\n else\n {\n if(1 == cur_slice_is_nonref)\n {\n /*We have encountered a referenced frame,return to app*/\n                        ps_dec_op->u4_num_bytes_consumed -=\n                                        bytes_consumed;\n                        ps_dec_op->e_pic_type = IV_B_FRAME;\n                        ps_dec_op->u4_error_code =\n                                        IVD_DEC_FRM_SKIPPED;\n                        ps_dec_op->u4_error_code |= (1\n << IVD_UNSUPPORTEDPARAM);\n                        ps_dec_op->u4_frame_decoded_flag = 0;\n                        ps_dec_op->u4_size =\n sizeof(ivd_video_decode_op_t);\n /*signal the decode thread*/\n                        ih264d_signal_decode_thread(ps_dec);\n /* close deblock thread if it is not closed yet*/\n if(ps_dec->u4_num_cores == 3)\n {\n                            ih264d_signal_bs_deblk_thread(ps_dec);\n }\n\n return (IV_FAIL);\n }\n }\n\n }\n\n }\n\n\n if(buflen)\n {\n            memcpy(pu1_bitstrm_buf, pu1_buf + u4_length_of_start_code,\n                   buflen);\n /* Decoder may read extra 8 bytes near end of the frame */\n if((buflen + 8) < buf_size)\n {\n                memset(pu1_bitstrm_buf + buflen, 0, 8);\n }\n            u4_first_start_code_found = 1;\n\n }\n else\n {\n /*start code not found*/\n\n if(u4_first_start_code_found == 0)\n {\n /*no start codes found in current process call*/\n\n                ps_dec->i4_error_code = ERROR_START_CODE_NOT_FOUND;\n                ps_dec_op->u4_error_code |= 1 << IVD_INSUFFICIENTDATA;\n\n if(ps_dec->u4_pic_buf_got == 0)\n {\n\n                    ih264d_fill_output_struct_from_context(ps_dec,\n                                                           ps_dec_op);\n\n                    ps_dec_op->u4_error_code = ps_dec->i4_error_code;\n                    ps_dec_op->u4_frame_decoded_flag = 0;\n\n return (IV_FAIL);\n }\n else\n {\n                    ps_dec->u1_pic_decode_done = 1;\n continue;\n }\n }\n else\n {\n /* a start code has already been found earlier in the same process call*/\n                frame_data_left = 0;\n                header_data_left = 0;\n continue;\n }\n\n }\n\n        ps_dec->u4_return_to_app = 0;\n        ret = ih264d_parse_nal_unit(dec_hdl, ps_dec_op,\n                              pu1_bitstrm_buf, buflen);\n if(ret != OK)\n {\n            UWORD32 error =  ih264d_map_error(ret);\n            ps_dec_op->u4_error_code = error | ret;\n            api_ret_value = IV_FAIL;\n\n if((ret == IVD_RES_CHANGED)\n || (ret == IVD_MEM_ALLOC_FAILED)\n || (ret == ERROR_UNAVAIL_PICBUF_T)\n || (ret == ERROR_UNAVAIL_MVBUF_T)\n || (ret == ERROR_INV_SPS_PPS_T)\n || (ret == IVD_DISP_FRM_ZERO_OP_BUF_SIZE))\n {\n                ps_dec->u4_slice_start_code_found = 0;\n break;\n }\n\n if((ret == ERROR_INCOMPLETE_FRAME) || (ret == ERROR_DANGLING_FIELD_IN_PIC))\n {\n                ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;\n                api_ret_value = IV_FAIL;\n break;\n }\n\n if(ret == ERROR_IN_LAST_SLICE_OF_PIC)\n {\n                api_ret_value = IV_FAIL;\n break;\n }\n\n }\n\n if(ps_dec->u4_return_to_app)\n {\n /*We have encountered a referenced frame,return to app*/\n            ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;\n            ps_dec_op->u4_error_code = IVD_DEC_FRM_SKIPPED;\n            ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);\n            ps_dec_op->u4_frame_decoded_flag = 0;\n            ps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);\n /*signal the decode thread*/\n            ih264d_signal_decode_thread(ps_dec);\n /* close deblock thread if it is not closed yet*/\n if(ps_dec->u4_num_cores == 3)\n {\n                ih264d_signal_bs_deblk_thread(ps_dec);\n }\n return (IV_FAIL);\n\n }\n\n\n\n        header_data_left = ((ps_dec->i4_decode_header == 1)\n && (ps_dec->i4_header_decoded != 3)\n && (ps_dec_op->u4_num_bytes_consumed\n < ps_dec_ip->u4_num_Bytes));\n        frame_data_left = (((ps_dec->i4_decode_header == 0)\n && ((ps_dec->u1_pic_decode_done == 0)\n || (u4_next_is_aud == 1)))\n && (ps_dec_op->u4_num_bytes_consumed\n < ps_dec_ip->u4_num_Bytes));\n }\n while(( header_data_left == 1)||(frame_data_left == 1));\n\n if((ps_dec->u4_pic_buf_got == 1)\n && (ret != IVD_MEM_ALLOC_FAILED)\n && ps_dec->u2_total_mbs_coded < ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n {\n        WORD32 num_mb_skipped;\n        WORD32 prev_slice_err;\n pocstruct_t temp_poc;\n        WORD32 ret1;\n        WORD32 ht_in_mbs;\n        ht_in_mbs = ps_dec->u2_pic_ht >> (4 + ps_dec->ps_cur_slice->u1_field_pic_flag);\n        num_mb_skipped = (ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n - ps_dec->u2_total_mbs_coded;\n\n if(ps_dec->u4_first_slice_in_pic && (ps_dec->u4_pic_buf_got == 0))\n            prev_slice_err = 1;\n else\n            prev_slice_err = 2;\n\n if(ps_dec->u4_first_slice_in_pic && (ps_dec->u2_total_mbs_coded == 0))\n            prev_slice_err = 1;\n\n        ret1 = ih264d_mark_err_slice_skip(ps_dec, num_mb_skipped, ps_dec->u1_nal_unit_type == IDR_SLICE_NAL, ps_dec->ps_cur_slice->u2_frame_num,\n &temp_poc, prev_slice_err);\n\n if((ret1 == ERROR_UNAVAIL_PICBUF_T) || (ret1 == ERROR_UNAVAIL_MVBUF_T) ||\n (ret1 == ERROR_INV_SPS_PPS_T))\n {\n            ret = ret1;\n }\n }\n\n if((ret == IVD_RES_CHANGED)\n || (ret == IVD_MEM_ALLOC_FAILED)\n || (ret == ERROR_UNAVAIL_PICBUF_T)\n || (ret == ERROR_UNAVAIL_MVBUF_T)\n || (ret == ERROR_INV_SPS_PPS_T))\n {\n\n /* signal the decode thread */\n        ih264d_signal_decode_thread(ps_dec);\n /* close deblock thread if it is not closed yet */\n if(ps_dec->u4_num_cores == 3)\n {\n            ih264d_signal_bs_deblk_thread(ps_dec);\n }\n /* dont consume bitstream for change in resolution case */\n if(ret == IVD_RES_CHANGED)\n {\n            ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;\n }\n return IV_FAIL;\n }\n\n\n if(ps_dec->u1_separate_parse)\n {\n /* If Format conversion is not complete,\n         complete it here */\n if(ps_dec->u4_num_cores == 2)\n {\n\n /*do deblocking of all mbs*/\n if((ps_dec->u4_nmb_deblk == 0) &&(ps_dec->u4_start_recon_deblk == 1) && (ps_dec->ps_cur_sps->u1_mb_aff_flag == 0))\n {\n                UWORD32 u4_num_mbs,u4_max_addr;\n tfr_ctxt_t s_tfr_ctxt;\n tfr_ctxt_t *ps_tfr_cxt = &s_tfr_ctxt;\n pad_mgr_t *ps_pad_mgr = &ps_dec->s_pad_mgr;\n\n /*BS is done for all mbs while parsing*/\n                u4_max_addr = (ps_dec->u2_frm_wd_in_mbs * ps_dec->u2_frm_ht_in_mbs) - 1;\n                ps_dec->u4_cur_bs_mb_num = u4_max_addr + 1;\n\n\n                ih264d_init_deblk_tfr_ctxt(ps_dec, ps_pad_mgr, ps_tfr_cxt,\n                                           ps_dec->u2_frm_wd_in_mbs, 0);\n\n\n                u4_num_mbs = u4_max_addr\n - ps_dec->u4_cur_deblk_mb_num + 1;\n\n                DEBUG_PERF_PRINTF(\"mbs left for deblocking= %d \\n\",u4_num_mbs);\n\n if(u4_num_mbs != 0)\n                    ih264d_check_mb_map_deblk(ps_dec, u4_num_mbs,\n                                                   ps_tfr_cxt,1);\n\n                ps_dec->u4_start_recon_deblk  = 0;\n\n }\n\n }\n\n /*signal the decode thread*/\n        ih264d_signal_decode_thread(ps_dec);\n /* close deblock thread if it is not closed yet*/\n if(ps_dec->u4_num_cores == 3)\n {\n            ih264d_signal_bs_deblk_thread(ps_dec);\n }\n }\n\n\n    DATA_SYNC();\n\n\n if((ps_dec_op->u4_error_code & 0xff)\n != ERROR_DYNAMIC_RESOLUTION_NOT_SUPPORTED)\n {\n        ps_dec_op->u4_pic_wd = (UWORD32)ps_dec->u2_disp_width;\n        ps_dec_op->u4_pic_ht = (UWORD32)ps_dec->u2_disp_height;\n }\n\n if(ps_dec->i4_header_decoded != 3)\n {\n        ps_dec_op->u4_error_code |= (1 << IVD_INSUFFICIENTDATA);\n\n }\n\n if(ps_dec->i4_decode_header == 1 && ps_dec->i4_header_decoded != 3)\n {\n        ps_dec_op->u4_error_code |= (1 << IVD_INSUFFICIENTDATA);\n\n }\n if(ps_dec->u4_prev_nal_skipped)\n {\n /*We have encountered a referenced frame,return to app*/\n        ps_dec_op->u4_error_code = IVD_DEC_FRM_SKIPPED;\n        ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);\n        ps_dec_op->u4_frame_decoded_flag = 0;\n        ps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);\n /* close deblock thread if it is not closed yet*/\n if(ps_dec->u4_num_cores == 3)\n {\n            ih264d_signal_bs_deblk_thread(ps_dec);\n }\n return (IV_FAIL);\n\n }\n\n if((ps_dec->u4_pic_buf_got == 1)\n && (ERROR_DANGLING_FIELD_IN_PIC != i4_err_status))\n {\n /*\n         * For field pictures, set the bottom and top picture decoded u4_flag correctly.\n         */\n\n if(ps_dec->ps_cur_slice->u1_field_pic_flag)\n {\n if(1 == ps_dec->ps_cur_slice->u1_bottom_field_flag)\n {\n                ps_dec->u1_top_bottom_decoded |= BOT_FIELD_ONLY;\n }\n else\n {\n                ps_dec->u1_top_bottom_decoded |= TOP_FIELD_ONLY;\n }\n }\n else\n {\n                ps_dec->u1_top_bottom_decoded = TOP_FIELD_ONLY | BOT_FIELD_ONLY;\n }\n\n /* if new frame in not found (if we are still getting slices from previous frame)\n         * ih264d_deblock_display is not called. Such frames will not be added to reference /display\n         */\n if ((ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC) == 0)\n {\n /* Calling Function to deblock Picture and Display */\n            ret = ih264d_deblock_display(ps_dec);\n }\n\n\n /*set to complete ,as we dont support partial frame decode*/\n if(ps_dec->i4_header_decoded == 3)\n {\n            ps_dec->u2_total_mbs_coded = ps_dec->ps_cur_sps->u2_max_mb_addr + 1;\n }\n\n /*Update the i4_frametype at the end of picture*/\n if(ps_dec->ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL)\n {\n            ps_dec->i4_frametype = IV_IDR_FRAME;\n }\n else if(ps_dec->i4_pic_type == B_SLICE)\n {\n            ps_dec->i4_frametype = IV_B_FRAME;\n }\n else if(ps_dec->i4_pic_type == P_SLICE)\n {\n            ps_dec->i4_frametype = IV_P_FRAME;\n }\n else if(ps_dec->i4_pic_type == I_SLICE)\n {\n            ps_dec->i4_frametype = IV_I_FRAME;\n }\n else\n {\n            H264_DEC_DEBUG_PRINT(\"Shouldn't come here\\n\");\n }\n\n        ps_dec->i4_content_type = ps_dec->ps_cur_slice->u1_field_pic_flag;\n\n        ps_dec->u4_total_frames_decoded = ps_dec->u4_total_frames_decoded + 2;\n        ps_dec->u4_total_frames_decoded = ps_dec->u4_total_frames_decoded\n - ps_dec->ps_cur_slice->u1_field_pic_flag;\n\n }\n\n /* close deblock thread if it is not closed yet*/\n if(ps_dec->u4_num_cores == 3)\n {\n        ih264d_signal_bs_deblk_thread(ps_dec);\n }\n\n\n {\n /* In case the decoder is configured to run in low delay mode,\n         * then get display buffer and then format convert.\n         * Note in this mode, format conversion does not run paralelly in a thread and adds to the codec cycles\n         */\n\n if((IVD_DECODE_FRAME_OUT == ps_dec->e_frm_out_mode)\n && ps_dec->u1_init_dec_flag)\n {\n\n            ih264d_get_next_display_field(ps_dec, ps_dec->ps_out_buffer,\n &(ps_dec->s_disp_op));\n if(0 == ps_dec->s_disp_op.u4_error_code)\n {\n                ps_dec->u4_fmt_conv_cur_row = 0;\n                ps_dec->u4_output_present = 1;\n }\n }\n\n        ih264d_fill_output_struct_from_context(ps_dec, ps_dec_op);\n\n /* If Format conversion is not complete,\n         complete it here */\n if(ps_dec->u4_output_present &&\n (ps_dec->u4_fmt_conv_cur_row < ps_dec->s_disp_frame_info.u4_y_ht))\n {\n            ps_dec->u4_fmt_conv_num_rows = ps_dec->s_disp_frame_info.u4_y_ht\n - ps_dec->u4_fmt_conv_cur_row;\n            ih264d_format_convert(ps_dec, &(ps_dec->s_disp_op),\n                                  ps_dec->u4_fmt_conv_cur_row,\n                                  ps_dec->u4_fmt_conv_num_rows);\n            ps_dec->u4_fmt_conv_cur_row += ps_dec->u4_fmt_conv_num_rows;\n }\n\n        ih264d_release_display_field(ps_dec, &(ps_dec->s_disp_op));\n }\n\n if(ps_dec->i4_decode_header == 1 && (ps_dec->i4_header_decoded & 1) == 1)\n {\n        ps_dec_op->u4_progressive_frame_flag = 1;\n if((NULL != ps_dec->ps_cur_sps) && (1 == (ps_dec->ps_cur_sps->u1_is_valid)))\n {\n if((0 == ps_dec->ps_sps->u1_frame_mbs_only_flag)\n && (0 == ps_dec->ps_sps->u1_mb_aff_flag))\n                ps_dec_op->u4_progressive_frame_flag = 0;\n\n }\n }\n\n if((TOP_FIELD_ONLY | BOT_FIELD_ONLY) == ps_dec->u1_top_bottom_decoded)\n {\n        ps_dec->u1_top_bottom_decoded = 0;\n }\n /*--------------------------------------------------------------------*/\n /* Do End of Pic processing.                                          */\n /* Should be called only if frame was decoded in previous process call*/\n /*--------------------------------------------------------------------*/\n if(ps_dec->u4_pic_buf_got == 1)\n {\n if(1 == ps_dec->u1_last_pic_not_decoded)\n {\n            ret = ih264d_end_of_pic_dispbuf_mgr(ps_dec);\n\n if(ret != OK)\n return ret;\n\n            ret = ih264d_end_of_pic(ps_dec);\n if(ret != OK)\n return ret;\n }\n else\n {\n            ret = ih264d_end_of_pic(ps_dec);\n if(ret != OK)\n return ret;\n }\n\n }\n\n\n /*Data memory barrier instruction,so that yuv write by the library is complete*/\n    DATA_SYNC();\n\n    H264_DEC_DEBUG_PRINT(\"The num bytes consumed: %d\\n\",\n                         ps_dec_op->u4_num_bytes_consumed);\n return api_ret_value;\n}\n", "target": 1, "idx": 188128}
{"func": "flush_signal_handlers(struct task_struct *t, int force_default)\n{\n\tint i;\n\tstruct k_sigaction *ka = &t->sighand->action[0];\n\tfor (i = _NSIG ; i != 0 ; i--) {\n \t\tif (force_default || ka->sa.sa_handler != SIG_IGN)\n \t\t\tka->sa.sa_handler = SIG_DFL;\n \t\tka->sa.sa_flags = 0;\n \t\tsigemptyset(&ka->sa.sa_mask);\n \t\tka++;\n \t}\n}\n", "target": 1, "idx": 179306}
{"func": "PasswordGenerationUIData GetTestGenerationUIData2() {\n  PasswordForm form;\n  form.form_data = autofill::FormData();\n  form.form_data.action = GURL(\"http://www.example2.com/accounts/Login\");\n  form.form_data.origin = GURL(\"http://www.example2.com/accounts/LoginAuth\");\n  PasswordGenerationUIData data;\n  data.password_form = form;\n  data.generation_element = ASCIIToUTF16(\"testelement2\");\n  data.max_length = 11;\n  return data;\n}\n", "target": 1, "idx": 186036}
{"func": " static int hns_xgmac_get_sset_count(int stringset)\n {\n\tif (stringset == ETH_SS_STATS)\n \t\treturn ARRAY_SIZE(g_xgmac_stats_string);\n \n \treturn 0;\n}\n", "target": 1, "idx": 182573}
{"func": "void BrowserViewRenderer::DidDestroyCompositor(\n     content::SynchronousCompositor* compositor) {\n   TRACE_EVENT0(\"android_webview\", \"BrowserViewRenderer::DidDestroyCompositor\");\n   DCHECK(compositor_);\n   compositor_ = NULL;\n }\n", "target": 1, "idx": 185581}
{"func": "GF_Err tfxd_dump(GF_Box *a, FILE * trace)\n{\n\tGF_MSSTimeExtBox *ptr = (GF_MSSTimeExtBox*)a;\n\tif (!a) return GF_BAD_PARAM;\n\tgf_isom_box_dump_start(a, \"MSSTimeExtensionBox\", trace);\n\tfprintf(trace, \"AbsoluteTime=\\\"\"LLU\"\\\" FragmentDuration=\\\"\"LLU\"\\\">\\n\", ptr->absolute_time_in_track_timescale, ptr->fragment_duration_in_track_timescale);\n\tfprintf(trace, \"<FullBoxInfo Version=\\\"%d\\\" Flags=\\\"%d\\\"/>\\n\", ptr->version, ptr->flags);\n\tgf_isom_box_dump_done(\"MSSTimeExtensionBox\", a, trace);\n\treturn GF_OK;\n}\n", "target": 0, "idx": 80868}
{"func": "void TypingCommand::insertText(Document& document,\n                               const String& text,\n                               Options options,\n                               TextCompositionType composition,\n                               const bool isIncrementalInsertion) {\n  LocalFrame* frame = document.frame();\n  DCHECK(frame);\n\n  if (!text.isEmpty())\n     document.frame()->spellChecker().updateMarkersForWordsAffectedByEditing(\n         isSpaceOrNewline(text[0]));\n \n  insertText(document, text,\n             frame->selection().computeVisibleSelectionInDOMTreeDeprecated(),\n             options, composition, isIncrementalInsertion);\n }\n", "target": 1, "idx": 185940}
{"func": "void jpc_quantize(jas_matrix_t *data, jpc_fix_t stepsize)\n{\n\tint i;\n\tint j;\n\tjpc_fix_t t;\n\n\tif (stepsize == jpc_inttofix(1)) {\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < jas_matrix_numrows(data); ++i) {\n\t\tfor (j = 0; j < jas_matrix_numcols(data); ++j) {\n\t\t\tt = jas_matrix_get(data, i, j);\n\n{\n\tif (t < 0) {\n\t\tt = jpc_fix_neg(jpc_fix_div(jpc_fix_neg(t), stepsize));\n\t} else {\n\t\tt = jpc_fix_div(t, stepsize);\n\t}\n}\n\n\t\t\tjas_matrix_set(data, i, j, t);\n\t\t}\n\t}\n}\n", "target": 0, "idx": 72924}
{"func": "void BinaryUploadService::IsAuthorized(AuthorizationCallback callback) {\n  if (!timer_.IsRunning()) {\n    timer_.Start(FROM_HERE, base::TimeDelta::FromHours(24), this,\n                 &BinaryUploadService::ResetAuthorizationData);\n  }\n\n   if (!can_upload_data_.has_value()) {\n     if (!pending_validate_data_upload_request_) {\n      std::string dm_token = GetDMToken();\n      if (dm_token.empty()) {\n         std::move(callback).Run(false);\n         return;\n       }\n\n      pending_validate_data_upload_request_ = true;\n       auto request = std::make_unique<ValidateDataUploadRequest>(base::BindOnce(\n           &BinaryUploadService::ValidateDataUploadRequestCallback,\n           weakptr_factory_.GetWeakPtr()));\n      request->set_dm_token(dm_token);\n       UploadForDeepScanning(std::move(request));\n     }\n     authorization_callbacks_.push_back(std::move(callback));\n    return;\n  }\n  std::move(callback).Run(can_upload_data_.value());\n}\n", "target": 1, "idx": 186323}
{"func": "bool GLES2DecoderImpl::DoIsProgram(GLuint client_id) {\n  const ProgramManager::ProgramInfo* program = GetProgramInfo(client_id);\n  return program != NULL && !program->IsDeleted();\n}\n", "target": 0, "idx": 110491}
{"func": " int __glXDispSwap_CreateContext(__GLXclientState *cl, GLbyte *pc)\n {\n     xGLXCreateContextReq *req = (xGLXCreateContextReq *) pc;\n     __GLX_DECLARE_SWAP_VARIABLES;\n \n     __GLX_SWAP_SHORT(&req->length);\n     __GLX_SWAP_INT(&req->context);\n     __GLX_SWAP_INT(&req->visual);\n    return __glXDisp_CreateContext(cl, pc);\n}\n", "target": 1, "idx": 178441}
{"func": "void PreconnectManager::StartPreconnectUrl(\n    const GURL& url,\n    bool allow_credentials,\n    net::NetworkIsolationKey network_isolation_key) {\n  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n  if (!url.SchemeIsHTTPOrHTTPS())\n    return;\n  PreresolveJobId job_id = preresolve_jobs_.Add(std::make_unique<PreresolveJob>(\n      url.GetOrigin(), 1, allow_credentials, std::move(network_isolation_key),\n      nullptr));\n  queued_jobs_.push_front(job_id);\n\n  TryToLaunchPreresolveJobs();\n}\n", "target": 0, "idx": 149606}
{"func": " void PrintPreviewUI::ClearAllPreviewData() {\n  print_preview_data_service()->RemoveEntry(preview_ui_addr_str_);\n }\n", "target": 1, "idx": 184403}
{"func": "PS_SERIALIZER_DECODE_FUNC(php_serialize) /* {{{ */\n{\n\tconst char *endptr = val + vallen;\n\tzval *session_vars;\n\tphp_unserialize_data_t var_hash;\n\n\tPHP_VAR_UNSERIALIZE_INIT(var_hash);\n\tALLOC_INIT_ZVAL(session_vars);\n        if (php_var_unserialize(&session_vars, &val, endptr, &var_hash TSRMLS_CC)) {\n                var_push_dtor(&var_hash, &session_vars);\n        }\n        PHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n        if (PS(http_session_vars)) {\n                zval_ptr_dtor(&PS(http_session_vars));\n\t}\n\tif (Z_TYPE_P(session_vars) == IS_NULL) {\n\t\tarray_init(session_vars);\n\t}\n\tPS(http_session_vars) = session_vars;\n\tZEND_SET_GLOBAL_VAR_WITH_LENGTH(\"_SESSION\", sizeof(\"_SESSION\"), PS(http_session_vars), Z_REFCOUNT_P(PS(http_session_vars)) + 1, 1);\n\treturn SUCCESS;\n}\n/* }}} */\n", "target": 1, "idx": 178152}
{"func": "l2tp_proto_ver_print(netdissect_options *ndo, const uint16_t *dat)\n {\n \tND_PRINT((ndo, \"%u.%u\", (EXTRACT_16BITS(dat) >> 8),\n \t    (EXTRACT_16BITS(dat) & 0xff)));\n }\n", "target": 1, "idx": 181070}
{"func": "int drm_mode_dirtyfb_ioctl(struct drm_device *dev,\n\t\t\t   void *data, struct drm_file *file_priv)\n{\n\tstruct drm_clip_rect __user *clips_ptr;\n\tstruct drm_clip_rect *clips = NULL;\n\tstruct drm_mode_fb_dirty_cmd *r = data;\n\tstruct drm_mode_object *obj;\n\tstruct drm_framebuffer *fb;\n\tunsigned flags;\n\tint num_clips;\n\tint ret = 0;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dev->mode_config.mutex);\n\tobj = drm_mode_object_find(dev, r->fb_id, DRM_MODE_OBJECT_FB);\n\tif (!obj) {\n\t\tDRM_ERROR(\"invalid framebuffer id\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_err1;\n\t}\n\tfb = obj_to_fb(obj);\n\n\tnum_clips = r->num_clips;\n\tclips_ptr = (struct drm_clip_rect *)(unsigned long)r->clips_ptr;\n\n\tif (!num_clips != !clips_ptr) {\n\t\tret = -EINVAL;\n\t\tgoto out_err1;\n\t}\n\n\tflags = DRM_MODE_FB_DIRTY_FLAGS & r->flags;\n\n\t/* If userspace annotates copy, clips must come in pairs */\n\tif (flags & DRM_MODE_FB_DIRTY_ANNOTATE_COPY && (num_clips % 2)) {\n\t\tret = -EINVAL;\n\t\tgoto out_err1;\n \t}\n \n \tif (num_clips && clips_ptr) {\n \t\tclips = kzalloc(num_clips * sizeof(*clips), GFP_KERNEL);\n \t\tif (!clips) {\n \t\t\tret = -ENOMEM;\n\t\t\tgoto out_err1;\n\t\t}\n\n\t\tret = copy_from_user(clips, clips_ptr,\n\t\t\t\t     num_clips * sizeof(*clips));\n\t\tif (ret) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out_err2;\n\t\t}\n\t}\n\n\tif (fb->funcs->dirty) {\n\t\tret = fb->funcs->dirty(fb, file_priv, flags, r->color,\n\t\t\t\t       clips, num_clips);\n\t} else {\n\t\tret = -ENOSYS;\n\t\tgoto out_err2;\n\t}\n\nout_err2:\n\tkfree(clips);\nout_err1:\n\tmutex_unlock(&dev->mode_config.mutex);\n\treturn ret;\n}\n", "target": 1, "idx": 178827}
{"func": "static OPJ_BOOL opj_pi_next_rlcp(opj_pi_iterator_t * pi) {\n\topj_pi_comp_t *comp = NULL;\n\topj_pi_resolution_t *res = NULL;\n\tOPJ_UINT32 index = 0;\n\n\tif (!pi->first) {\n\t\tcomp = &pi->comps[pi->compno];\n\t\tres = &comp->resolutions[pi->resno];\n\t\tgoto LABEL_SKIP;\n\t} else {\n\t\tpi->first = 0;\n\t}\n\n\tfor (pi->resno = pi->poc.resno0; pi->resno < pi->poc.resno1; pi->resno++) {\n\t\tfor (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n\t\t\tfor (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n\t\t\t\tcomp = &pi->comps[pi->compno];\n\t\t\t\tif (pi->resno >= comp->numresolutions) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tres = &comp->resolutions[pi->resno];\n\t\t\t\tif(!pi->tp_on){\n\t\t\t\t\tpi->poc.precno1 = res->pw * res->ph;\n\t\t\t\t}\n\t\t\t\tfor (pi->precno = pi->poc.precno0; pi->precno < pi->poc.precno1; pi->precno++) {\n\t\t\t\t\tindex = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno * pi->step_c + pi->precno * pi->step_p;\n\t\t\t\t\tif (!pi->include[index]) {\n\t\t\t\t\t\tpi->include[index] = 1;\n\t\t\t\t\t\treturn OPJ_TRUE;\n\t\t\t\t\t}\nLABEL_SKIP:;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn OPJ_FALSE;\n}\n", "target": 0, "idx": 50053}
{"func": "   void TestPlaybackRate(double playback_rate) {\n    static const int kDefaultBufferSize = kSamplesPerSecond / 10;\n    static const int kDefaultFramesRequested = 5 * kSamplesPerSecond;\n \n     TestPlaybackRate(playback_rate, kDefaultBufferSize,\n                      kDefaultFramesRequested);\n  }\n", "target": 1, "idx": 185238}
{"func": "void WebPluginImpl::didFinishLoadingFrameRequest(\n     const WebURL& url, void* notify_data) {\n   if (delegate_) {\n     delegate_->DidFinishLoadWithReason(\n        url, NPRES_DONE, reinterpret_cast<intptr_t>(notify_data));\n   }\n }\n", "target": 1, "idx": 183603}
{"func": "static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOptionType options, int is_callable)\n{\n\tzval **arg_pattern_zval;\n\n\tchar *arg_pattern;\n\tint arg_pattern_len;\n\n\tchar *replace;\n\tint replace_len;\n\n\tzend_fcall_info arg_replace_fci;\n\tzend_fcall_info_cache arg_replace_fci_cache;\n\n\tchar *string;\n\tint string_len;\n\n\tchar *p;\n\tphp_mb_regex_t *re;\n\tOnigSyntaxType *syntax;\n\tOnigRegion *regs = NULL;\n\tsmart_str out_buf = { 0 };\n\tsmart_str eval_buf = { 0 };\n\tsmart_str *pbuf;\n\tint i, err, eval, n;\n\tOnigUChar *pos;\n\tOnigUChar *string_lim;\n\tchar *description = NULL;\n\tchar pat_buf[2];\n\n\tconst mbfl_encoding *enc;\n\n\t{\n\t\tconst char *current_enc_name;\n\t\tcurrent_enc_name = _php_mb_regex_mbctype2name(MBREX(current_mbctype));\n\t\tif (current_enc_name == NULL ||\n\t\t\t(enc = mbfl_name2encoding(current_enc_name)) == NULL) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unknown error\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\t}\n\teval = 0;\n\t{\n\t\tchar *option_str = NULL;\n\t\tint option_str_len = 0;\n\n\t\tif (!is_callable) {\n\t\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"Zss|s\",\n\t\t\t\t\t\t&arg_pattern_zval,\n\t\t\t\t\t\t&replace, &replace_len,\n\t\t\t\t\t\t&string, &string_len,\n\t\t\t\t\t\t&option_str, &option_str_len) == FAILURE) {\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t} else {\n\t\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"Zfs|s\",\n\t\t\t\t\t\t&arg_pattern_zval,\n\t\t\t\t\t\t&arg_replace_fci, &arg_replace_fci_cache,\n\t\t\t\t\t\t&string, &string_len,\n\t\t\t\t\t\t&option_str, &option_str_len) == FAILURE) {\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t}\n\n\t\tif (option_str != NULL) {\n\t\t\t_php_mb_regex_init_options(option_str, option_str_len, &options, &syntax, &eval);\n\t\t} else {\n\t\t\toptions |= MBREX(regex_default_options);\n\t\t\tsyntax = MBREX(regex_default_syntax);\n\t\t}\n\t}\n\tif (Z_TYPE_PP(arg_pattern_zval) == IS_STRING) {\n\t\targ_pattern = Z_STRVAL_PP(arg_pattern_zval);\n\t\targ_pattern_len = Z_STRLEN_PP(arg_pattern_zval);\n \t} else {\n \t\t/* FIXME: this code is not multibyte aware! */\n \t\tconvert_to_long_ex(arg_pattern_zval);\n\t\tpat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);\t\n \t\tpat_buf[1] = '\\0';\n \n \t\targ_pattern = pat_buf;\n\t\targ_pattern_len = 1;\t\n \t}\n \t/* create regex pattern buffer */\n \tre = php_mbregex_compile_pattern(arg_pattern, arg_pattern_len, options, MBREX(current_mbctype), syntax TSRMLS_CC);\n\tif (re == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (eval || is_callable) {\n\t\tpbuf = &eval_buf;\n\t\tdescription = zend_make_compiled_string_description(\"mbregex replace\" TSRMLS_CC);\n\t} else {\n\t\tpbuf = &out_buf;\n\t\tdescription = NULL;\n\t}\n\n\tif (is_callable) {\n\t\tif (eval) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Option 'e' cannot be used with replacement callback\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\t}\n\n\t/* do the actual work */\n\terr = 0;\n\tpos = (OnigUChar *)string;\n\tstring_lim = (OnigUChar*)(string + string_len);\n\tregs = onig_region_new();\n\twhile (err >= 0) {\n\t\terr = onig_search(re, (OnigUChar *)string, (OnigUChar *)string_lim, pos, (OnigUChar *)string_lim, regs, 0);\n\t\tif (err <= -2) {\n\t\t\tOnigUChar err_str[ONIG_MAX_ERROR_MESSAGE_LEN];\n\t\t\tonig_error_code_to_str(err_str, err);\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"mbregex search failure in php_mbereg_replace_exec(): %s\", err_str);\n\t\t\tbreak;\n\t\t}\n\t\tif (err >= 0) {\n#if moriyoshi_0\n\t\t\tif (regs->beg[0] == regs->end[0]) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Empty regular expression\");\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n\t\t\t/* copy the part of the string before the match */\n\t\t\tsmart_str_appendl(&out_buf, pos, (size_t)((OnigUChar *)(string + regs->beg[0]) - pos));\n\n\t\t\tif (!is_callable) {\n\t\t\t\t/* copy replacement and backrefs */\n\t\t\t\ti = 0;\n\t\t\t\tp = replace;\n\t\t\t\twhile (i < replace_len) {\n\t\t\t\t\tint fwd = (int) php_mb_mbchar_bytes_ex(p, enc);\n\t\t\t\t\tn = -1;\n\t\t\t\t\tif ((replace_len - i) >= 2 && fwd == 1 &&\n\t\t\t\t\tp[0] == '\\\\' && p[1] >= '0' && p[1] <= '9') {\n\t\t\t\t\t\tn = p[1] - '0';\n\t\t\t\t\t}\n\t\t\t\t\tif (n >= 0 && n < regs->num_regs) {\n\t\t\t\t\t\tif (regs->beg[n] >= 0 && regs->beg[n] < regs->end[n] && regs->end[n] <= string_len) {\n\t\t\t\t\t\t\tsmart_str_appendl(pbuf, string + regs->beg[n], regs->end[n] - regs->beg[n]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tp += 2;\n\t\t\t\t\t\ti += 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsmart_str_appendl(pbuf, p, fwd);\n\t\t\t\t\t\tp += fwd;\n\t\t\t\t\t\ti += fwd;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (eval) {\n \t\t\t\tzval v;\n \t\t\t\t/* null terminate buffer */\n\t\t\t\tsmart_str_0(&eval_buf);\n\t\t\t\t/* do eval */\n\t\t\t\tif (zend_eval_stringl(eval_buf.c, eval_buf.len, &v, description TSRMLS_CC) == FAILURE) {\n\t\t\t\t\tefree(description);\n\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC,E_ERROR, \"Failed evaluating code: %s%s\", PHP_EOL, eval_buf.c);\n\t\t\t\t\t/* zend_error() does not return in this case */\n\t\t\t\t}\n\n\t\t\t\t/* result of eval */\n\t\t\t\tconvert_to_string(&v);\n\t\t\t\tsmart_str_appendl(&out_buf, Z_STRVAL(v), Z_STRLEN(v));\n\t\t\t\t/* Clean up */\n \t\t\t\teval_buf.len = 0;\n \t\t\t\tzval_dtor(&v);\n \t\t\t} else if (is_callable) {\n\t\t\t\tzval *retval_ptr;\n \t\t\t\tzval **args[1];\n \t\t\t\tzval *subpats;\n \t\t\t\tint i;\n \t\t\t\tMAKE_STD_ZVAL(subpats);\n \t\t\t\tarray_init(subpats);\n \t\t\t\tfor (i = 0; i < regs->num_regs; i++) {\n \t\t\t\t\tadd_next_index_stringl(subpats, string + regs->beg[i], regs->end[i] - regs->beg[i], 1);\n\t\t\t\t}\t\t\t\t\n \t\t\t\targs[0] = &subpats;\n \t\t\t\t/* null terminate buffer */\n \t\t\t\tsmart_str_0(&eval_buf);\n \t\t\t\targ_replace_fci.param_count = 1;\n \t\t\t\targ_replace_fci.params = args;\n \t\t\t\targ_replace_fci.retval_ptr_ptr = &retval_ptr;\n\t\t\t\tif (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr) {\n \t\t\t\t\tconvert_to_string_ex(&retval_ptr);\n \t\t\t\t\tsmart_str_appendl(&out_buf, Z_STRVAL_P(retval_ptr), Z_STRLEN_P(retval_ptr));\n \t\t\t\t\teval_buf.len = 0;\n \t\t\t\t\tzval_ptr_dtor(&retval_ptr);\n \t\t\t\t} else {\n\t\t\t\t\tefree(description);\n \t\t\t\t\tif (!EG(exception)) {\n \t\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to call custom replacement function\");\n \t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tzval_ptr_dtor(&subpats);\n\t\t\t}\n\n\t\t\tn = regs->end[0];\n\t\t\tif ((pos - (OnigUChar *)string) < n) {\n \t\t\t\tpos = (OnigUChar *)string + n;\n \t\t\t} else {\n \t\t\t\tif (pos < string_lim) {\n\t\t\t\t\tsmart_str_appendl(&out_buf, pos, 1); \n \t\t\t\t}\n \t\t\t\tpos++;\n \t\t\t}\n\t\t} else { /* nomatch */\n\t\t\t/* stick that last bit of string on our output */\n\t\t\tif (string_lim - pos > 0) {\n\t\t\t\tsmart_str_appendl(&out_buf, pos, string_lim - pos);\n\t\t\t}\n\t\t}\n\t\tonig_region_free(regs, 0);\n\t}\n\n\tif (description) {\n\t\tefree(description);\n\t}\n\tif (regs != NULL) {\n\t\tonig_region_free(regs, 1);\n\t}\n \tsmart_str_free(&eval_buf);\n \n \tif (err <= -2) {\n\t\tsmart_str_free(&out_buf);\t\n \t\tRETVAL_FALSE;\n \t} else {\n \t\tsmart_str_appendc(&out_buf, '\\0');\n\t\tRETVAL_STRINGL((char *)out_buf.c, out_buf.len - 1, 0);\n\t}\n}\n", "target": 1, "idx": 180289}
{"func": "    virtual void TearDown()\n    {\n        Platform::current()->unitTestSupport()->unregisterAllMockedURLs();\n    }\n", "target": 0, "idx": 119503}
{"func": "static ssize_t o2nm_node_ipv4_address_store(struct config_item *item,\n\t\t\t\t\t    const char *page,\n \t\t\t\t\t    size_t count)\n {\n \tstruct o2nm_node *node = to_o2nm_node(item);\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);\n \tint ret, i;\n \tstruct rb_node **p, *parent;\n \tunsigned int octets[4];\n\t__be32 ipv4_addr = 0;\n\n\tret = sscanf(page, \"%3u.%3u.%3u.%3u\", &octets[3], &octets[2],\n\t\t     &octets[1], &octets[0]);\n\tif (ret != 4)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ARRAY_SIZE(octets); i++) {\n\t\tif (octets[i] > 255)\n\t\t\treturn -ERANGE;\n \t\tbe32_add_cpu(&ipv4_addr, octets[i] << (i * 8));\n \t}\n \n \tret = 0;\n \twrite_lock(&cluster->cl_nodes_lock);\n \tif (o2nm_node_ip_tree_lookup(cluster, ipv4_addr, &p, &parent))\n\t\tret = -EEXIST;\n\telse if (test_and_set_bit(O2NM_NODE_ATTR_ADDRESS,\n\t\t\t&node->nd_set_attributes))\n\t\tret = -EBUSY;\n\telse {\n\t\trb_link_node(&node->nd_ip_node, parent, p);\n \t\trb_insert_color(&node->nd_ip_node, &cluster->cl_node_ip_tree);\n \t}\n \twrite_unlock(&cluster->cl_nodes_lock);\n \tif (ret)\n \t\treturn ret;\n \n\tmemcpy(&node->nd_ipv4_address, &ipv4_addr, sizeof(ipv4_addr));\n\n\treturn count;\n}\n", "target": 1, "idx": 182577}
{"func": "void IndexedDBCursor::RemoveCursorFromTransaction() {\n  if (transaction_)\n    transaction_->UnregisterOpenCursor(this);\n}\n", "target": 1, "idx": 186275}
{"func": " static int zrle_send_framebuffer_update(VncState *vs, int x, int y,\n                                         int w, int h)\n {\n    bool be = !!(vs->clientds.flags & QEMU_BIG_ENDIAN_FLAG);\n     size_t bytes;\n     int zywrle_level;\n \n    if (vs->zrle.type == VNC_ENCODING_ZYWRLE) {\n        if (!vs->vd->lossy || vs->tight.quality == (uint8_t)-1\n            || vs->tight.quality == 9) {\n            zywrle_level = 0;\n            vs->zrle.type = VNC_ENCODING_ZRLE;\n        } else if (vs->tight.quality < 3) {\n            zywrle_level = 3;\n        } else if (vs->tight.quality < 6) {\n            zywrle_level = 2;\n        } else {\n            zywrle_level = 1;\n        }\n    } else {\n        zywrle_level = 0;\n    }\n \n     vnc_zrle_start(vs);\n \n    switch(vs->clientds.pf.bytes_per_pixel) {\n     case 1:\n         zrle_encode_8ne(vs, x, y, w, h, zywrle_level);\n         break;\n \n     case 2:\n        if (vs->clientds.pf.gmax > 0x1F) {\n             if (be) {\n                 zrle_encode_16be(vs, x, y, w, h, zywrle_level);\n             } else {\n                zrle_encode_16le(vs, x, y, w, h, zywrle_level);\n            }\n        } else {\n            if (be) {\n                zrle_encode_15be(vs, x, y, w, h, zywrle_level);\n            } else {\n                zrle_encode_15le(vs, x, y, w, h, zywrle_level);\n            }\n        }\n        break;\n\n    case 4:\n    {\n        bool fits_in_ls3bytes;\n         bool fits_in_ms3bytes;\n \n         fits_in_ls3bytes =\n            ((vs->clientds.pf.rmax << vs->clientds.pf.rshift) < (1 << 24) &&\n             (vs->clientds.pf.gmax << vs->clientds.pf.gshift) < (1 << 24) &&\n             (vs->clientds.pf.bmax << vs->clientds.pf.bshift) < (1 << 24));\n \n        fits_in_ms3bytes = (vs->clientds.pf.rshift > 7 &&\n                            vs->clientds.pf.gshift > 7 &&\n                            vs->clientds.pf.bshift > 7);\n \n         if ((fits_in_ls3bytes && !be) || (fits_in_ms3bytes && be)) {\n             if (be) {\n                zrle_encode_24abe(vs, x, y, w, h, zywrle_level);\n            } else {\n                zrle_encode_24ale(vs, x, y, w, h, zywrle_level);\n          }\n        } else if ((fits_in_ls3bytes && be) || (fits_in_ms3bytes && !be)) {\n            if (be) {\n                zrle_encode_24bbe(vs, x, y, w, h, zywrle_level);\n            } else {\n                zrle_encode_24ble(vs, x, y, w, h, zywrle_level);\n            }\n        } else {\n            if (be) {\n                zrle_encode_32be(vs, x, y, w, h, zywrle_level);\n            } else {\n                zrle_encode_32le(vs, x, y, w, h, zywrle_level);\n            }\n        }\n    }\n    break;\n    }\n\n    vnc_zrle_stop(vs);\n    bytes = zrle_compress_data(vs, Z_DEFAULT_COMPRESSION);\n    vnc_framebuffer_update(vs, x, y, w, h, vs->zrle.type);\n    vnc_write_u32(vs, bytes);\n    vnc_write(vs, vs->zrle.zlib.buffer, vs->zrle.zlib.offset);\n    return 1;\n}\n", "target": 1, "idx": 178640}
{"func": "  void RegisterProperties(IBusPropList* ibus_prop_list) {\n    DLOG(INFO) << \"RegisterProperties\" << (ibus_prop_list ? \"\" : \" (clear)\");\n \n     ImePropertyList prop_list;  // our representation.\n     if (ibus_prop_list) {\n       if (!FlattenPropertyList(ibus_prop_list, &prop_list)) {\n        RegisterProperties(NULL);\n         return;\n       }\n     }\n    register_ime_properties_(language_library_, prop_list);\n  }\n", "target": 1, "idx": 184001}
{"func": "ProcRenderCreateConicalGradient(ClientPtr client)\n{\n    PicturePtr pPicture;\n    int len;\n    int error = 0;\n    xFixed *stops;\n    xRenderColor *colors;\n\n    REQUEST(xRenderCreateConicalGradientReq);\n\n    REQUEST_AT_LEAST_SIZE(xRenderCreateConicalGradientReq);\n\n    LEGAL_NEW_RESOURCE(stuff->pid, client);\n\n    len = (client->req_len << 2) - sizeof(xRenderCreateConicalGradientReq);\n    if (stuff->nStops > UINT32_MAX / (sizeof(xFixed) + sizeof(xRenderColor)))\n        return BadLength;\n    if (len != stuff->nStops * (sizeof(xFixed) + sizeof(xRenderColor)))\n        return BadLength;\n\n    stops = (xFixed *) (stuff + 1);\n    colors = (xRenderColor *) (stops + stuff->nStops);\n\n    pPicture =\n        CreateConicalGradientPicture(stuff->pid, &stuff->center, stuff->angle,\n                                     stuff->nStops, stops, colors, &error);\n    if (!pPicture)\n        return error;\n    /* security creation/labeling check */\n    error = XaceHook(XACE_RESOURCE_ACCESS, client, stuff->pid, PictureType,\n                     pPicture, RT_NONE, NULL, DixCreateAccess);\n    if (error != Success)\n        return error;\n    if (!AddResource(stuff->pid, PictureType, (void *) pPicture))\n        return BadAlloc;\n    return Success;\n}\n", "target": 0, "idx": 17578}
{"func": "RenderWidgetHostViewAura::RenderWidgetHostViewAura(RenderWidgetHost* host,\n                                                   bool is_guest_view_hack)\n    : host_(RenderWidgetHostImpl::From(host)),\n      window_(nullptr),\n      in_shutdown_(false),\n      in_bounds_changed_(false),\n      popup_parent_host_view_(nullptr),\n      popup_child_host_view_(nullptr),\n      is_loading_(false),\n      has_composition_text_(false),\n      background_color_(SK_ColorWHITE),\n      needs_begin_frames_(false),\n      needs_flush_input_(false),\n      added_frame_observer_(false),\n      cursor_visibility_state_in_renderer_(UNKNOWN),\n#if defined(OS_WIN)\n      legacy_render_widget_host_HWND_(nullptr),\n      legacy_window_destroyed_(false),\n      virtual_keyboard_requested_(false),\n#endif\n      has_snapped_to_boundary_(false),\n       is_guest_view_hack_(is_guest_view_hack),\n       device_scale_factor_(0.0f),\n       event_handler_(new RenderWidgetHostViewEventHandler(host_, this, this)),\n       weak_ptr_factory_(this) {\n   if (!is_guest_view_hack_)\n     host_->SetView(this);\n\n  if (GetTextInputManager())\n    GetTextInputManager()->AddObserver(this);\n\n  bool overscroll_enabled = base::CommandLine::ForCurrentProcess()->\n      GetSwitchValueASCII(switches::kOverscrollHistoryNavigation) != \"0\";\n  SetOverscrollControllerEnabled(overscroll_enabled);\n\n  selection_controller_client_.reset(\n      new TouchSelectionControllerClientAura(this));\n  CreateSelectionController();\n\n  RenderViewHost* rvh = RenderViewHost::From(host_);\n  if (rvh) {\n    ignore_result(rvh->GetWebkitPreferences());\n  }\n}\n", "target": 1, "idx": 186203}
{"func": "PHP_METHOD(Phar, getSupportedCompression)\n{\n        if (zend_parse_parameters_none() == FAILURE) {\n                return;\n        }\n        array_init(return_value);\n        phar_request_initialize(TSRMLS_C);\n \n\tif (PHAR_G(has_zlib)) {\n\t\tadd_next_index_stringl(return_value, \"GZ\", 2, 1);\n\t}\n\n\tif (PHAR_G(has_bz2)) {\n\t\tadd_next_index_stringl(return_value, \"BZIP2\", 5, 1);\n\t}\n}\n", "target": 1, "idx": 178465}
{"func": "  CurrentThreadMock()\n      : task_runner_delegate_(\n            scheduler::LazySchedulerMessageLoopDelegateForTests::Create()),\n        scheduler_(\n            new scheduler::RendererSchedulerImpl(task_runner_delegate_.get())),\n        web_scheduler_(\n            new scheduler::RendererWebSchedulerImpl(scheduler_.get())),\n        web_task_runner_(\n            new scheduler::WebTaskRunnerImpl(scheduler_->DefaultTaskRunner())) {\n  }\n", "target": 0, "idx": 145052}
{"func": "void WebLocalFrameImpl::BindDevToolsAgentRequest(\n    mojom::blink::DevToolsAgentAssociatedRequest request) {\n  if (!dev_tools_agent_)\n    dev_tools_agent_ = WebDevToolsAgentImpl::CreateForFrame(this);\n  dev_tools_agent_->BindRequest(std::move(request));\n}\n", "target": 0, "idx": 158501}
{"func": "static int setup_dev_console(const struct lxc_rootfs *rootfs,\n\t\t\t const struct lxc_console *console)\n{\n\tchar path[MAXPATHLEN];\n\tstruct stat s;\n\tint ret;\n\n\tret = snprintf(path, sizeof(path), \"%s/dev/console\", rootfs->mount);\n\tif (ret >= sizeof(path)) {\n\t\tERROR(\"console path too long\");\n\t\treturn -1;\n\t}\n\n\tif (access(path, F_OK)) {\n\t\tWARN(\"rootfs specified but no console found at '%s'\", path);\n\t\treturn 0;\n\t}\n\n\tif (console->master < 0) {\n\t\tINFO(\"no console\");\n\t\treturn 0;\n\t}\n\n\tif (stat(path, &s)) {\n\t\tSYSERROR(\"failed to stat '%s'\", path);\n\t\treturn -1;\n\t}\n\n\tif (chmod(console->name, s.st_mode)) {\n\t\tSYSERROR(\"failed to set mode '0%o' to '%s'\",\n\t\t\t s.st_mode, console->name);\n \t\treturn -1;\n \t}\n \n\tif (mount(console->name, path, \"none\", MS_BIND, 0)) {\n \t\tERROR(\"failed to mount '%s' on '%s'\", console->name, path);\n \t\treturn -1;\n \t}\n\n\tINFO(\"console has been setup\");\n\treturn 0;\n}\n", "target": 1, "idx": 179892}
{"func": "  void UpdateNetworkManagerStatus() {\n    if (!BrowserThread::CurrentlyOn(BrowserThread::UI)) {\n      BrowserThread::PostTask(\n          BrowserThread::UI, FROM_HERE,\n          NewRunnableMethod(this,\n                            &NetworkLibraryImpl::UpdateNetworkManagerStatus));\n      return;\n    }\n\n    SystemInfo* system = GetSystemInfo();\n    if (!system)\n      return;\n\n\n    std::string prev_cellular_service_path = cellular_ ?\n        cellular_->service_path() : std::string();\n\n    ClearNetworks();\n\n    ParseSystem(system, &ethernet_, &wifi_networks_, &cellular_networks_,\n                &remembered_wifi_networks_);\n\n    wifi_ = NULL;\n    for (size_t i = 0; i < wifi_networks_.size(); i++) {\n      if (wifi_networks_[i]->connecting_or_connected()) {\n        wifi_ = wifi_networks_[i];\n        break;  // There is only one connected or connecting wifi network.\n      }\n    }\n    cellular_ = NULL;\n     for (size_t i = 0; i < cellular_networks_.size(); i++) {\n       if (cellular_networks_[i]->connecting_or_connected()) {\n         cellular_ = cellular_networks_[i];\n         if (cellular_networks_[i]->service_path() !=\n                 prev_cellular_service_path) {\n          CellularDataPlanList* list = RetrieveCellularDataPlans(\n              cellular_->service_path().c_str());\n          UpdateCellularDataPlan(list);\n          FreeCellularDataPlanList(list);\n         }\n         break;  // There is only one connected or connecting cellular network.\n       }\n    }\n\n    available_devices_ = system->available_technologies;\n    enabled_devices_ = system->enabled_technologies;\n    connected_devices_ = system->connected_technologies;\n    offline_mode_ = system->offline_mode;\n\n    NotifyNetworkManagerChanged();\n    FreeSystemInfo(system);\n  }\n", "target": 1, "idx": 183616}
{"func": "void RenderWidgetHostImpl::ForwardMouseEvent(const WebMouseEvent& mouse_event) {\n  if (GetView()->IsInVR() &&\n      (is_in_gesture_scroll_[blink::kWebGestureDeviceTouchpad] ||\n       is_in_touchpad_gesture_fling_)) {\n    return;\n  }\n\n  ForwardMouseEventWithLatencyInfo(mouse_event,\n                                   ui::LatencyInfo(ui::SourceEventType::MOUSE));\n  if (owner_delegate_)\n    owner_delegate_->RenderWidgetDidForwardMouseEvent(mouse_event);\n}\n", "target": 0, "idx": 158270}
{"func": "static int raw_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct net *net = sock_net(sk);\n\tstruct ipcm_cookie ipc;\n\tstruct rtable *rt = NULL;\n\tstruct flowi4 fl4;\n\tint free = 0;\n\t__be32 daddr;\n\t__be32 saddr;\n\tu8  tos;\n \tint err;\n \tstruct ip_options_data opt_copy;\n \tstruct raw_frag_vec rfv;\n \n \terr = -EMSGSIZE;\n \tif (len > 0xFFFF)\n \t\tgoto out;\n \n \t/*\n \t *\tCheck the flags.\n \t */\n\n\terr = -EOPNOTSUPP;\n\tif (msg->msg_flags & MSG_OOB)\t/* Mirror BSD error message */\n\t\tgoto out;               /* compatibility */\n\n\t/*\n\t *\tGet and verify the address.\n\t */\n\n\tif (msg->msg_namelen) {\n\t\tDECLARE_SOCKADDR(struct sockaddr_in *, usin, msg->msg_name);\n\t\terr = -EINVAL;\n\t\tif (msg->msg_namelen < sizeof(*usin))\n\t\t\tgoto out;\n\t\tif (usin->sin_family != AF_INET) {\n\t\t\tpr_info_once(\"%s: %s forgot to set AF_INET. Fix it!\\n\",\n\t\t\t\t     __func__, current->comm);\n\t\t\terr = -EAFNOSUPPORT;\n\t\t\tif (usin->sin_family)\n\t\t\t\tgoto out;\n\t\t}\n\t\tdaddr = usin->sin_addr.s_addr;\n\t\t/* ANK: I did not forget to get protocol from port field.\n\t\t * I just do not know, who uses this weirdness.\n\t\t * IP_HDRINCL is much more convenient.\n\t\t */\n\t} else {\n\t\terr = -EDESTADDRREQ;\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out;\n\t\tdaddr = inet->inet_daddr;\n\t}\n\n\tipc.sockc.tsflags = sk->sk_tsflags;\n\tipc.addr = inet->inet_saddr;\n\tipc.opt = NULL;\n\tipc.tx_flags = 0;\n\tipc.ttl = 0;\n\tipc.tos = -1;\n\tipc.oif = sk->sk_bound_dev_if;\n\n\tif (msg->msg_controllen) {\n\t\terr = ip_cmsg_send(sk, msg, &ipc, false);\n\t\tif (unlikely(err)) {\n\t\t\tkfree(ipc.opt);\n\t\t\tgoto out;\n\t\t}\n\t\tif (ipc.opt)\n\t\t\tfree = 1;\n\t}\n\n\tsaddr = ipc.addr;\n\tipc.addr = daddr;\n\n\tif (!ipc.opt) {\n\t\tstruct ip_options_rcu *inet_opt;\n\n\t\trcu_read_lock();\n\t\tinet_opt = rcu_dereference(inet->inet_opt);\n\t\tif (inet_opt) {\n\t\t\tmemcpy(&opt_copy, inet_opt,\n\t\t\t       sizeof(*inet_opt) + inet_opt->opt.optlen);\n\t\t\tipc.opt = &opt_copy.opt;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tif (ipc.opt) {\n\t\terr = -EINVAL;\n \t\t/* Linux does not mangle headers on raw sockets,\n \t\t * so that IP options + IP_HDRINCL is non-sense.\n \t\t */\n\t\tif (inet->hdrincl)\n \t\t\tgoto done;\n \t\tif (ipc.opt->opt.srr) {\n \t\t\tif (!daddr)\n\t\t\t\tgoto done;\n\t\t\tdaddr = ipc.opt->opt.faddr;\n\t\t}\n\t}\n\ttos = get_rtconn_flags(&ipc, sk);\n\tif (msg->msg_flags & MSG_DONTROUTE)\n\t\ttos |= RTO_ONLINK;\n\n\tif (ipv4_is_multicast(daddr)) {\n\t\tif (!ipc.oif)\n\t\t\tipc.oif = inet->mc_index;\n\t\tif (!saddr)\n\t\t\tsaddr = inet->mc_addr;\n\t} else if (!ipc.oif)\n\t\tipc.oif = inet->uc_index;\n \n \tflowi4_init_output(&fl4, ipc.oif, sk->sk_mark, tos,\n \t\t\t   RT_SCOPE_UNIVERSE,\n\t\t\t   inet->hdrincl ? IPPROTO_RAW : sk->sk_protocol,\n \t\t\t   inet_sk_flowi_flags(sk) |\n\t\t\t    (inet->hdrincl ? FLOWI_FLAG_KNOWN_NH : 0),\n \t\t\t   daddr, saddr, 0, 0, sk->sk_uid);\n \n\tif (!inet->hdrincl) {\n \t\trfv.msg = msg;\n \t\trfv.hlen = 0;\n \n\t\terr = raw_probe_proto_opt(&rfv, &fl4);\n\t\tif (err)\n\t\t\tgoto done;\n\t}\n\n\tsecurity_sk_classify_flow(sk, flowi4_to_flowi(&fl4));\n\trt = ip_route_output_flow(net, &fl4, sk);\n\tif (IS_ERR(rt)) {\n\t\terr = PTR_ERR(rt);\n\t\trt = NULL;\n\t\tgoto done;\n\t}\n\n\terr = -EACCES;\n\tif (rt->rt_flags & RTCF_BROADCAST && !sock_flag(sk, SOCK_BROADCAST))\n\t\tgoto done;\n\n\tif (msg->msg_flags & MSG_CONFIRM)\n \t\tgoto do_confirm;\n back_from_confirm:\n \n\tif (inet->hdrincl)\n \t\terr = raw_send_hdrinc(sk, &fl4, msg, len,\n \t\t\t\t      &rt, msg->msg_flags, &ipc.sockc);\n \n\t else {\n\t\tsock_tx_timestamp(sk, ipc.sockc.tsflags, &ipc.tx_flags);\n\n\t\tif (!ipc.addr)\n\t\t\tipc.addr = fl4.daddr;\n\t\tlock_sock(sk);\n\t\terr = ip_append_data(sk, &fl4, raw_getfrag,\n\t\t\t\t     &rfv, len, 0,\n\t\t\t\t     &ipc, &rt, msg->msg_flags);\n\t\tif (err)\n\t\t\tip_flush_pending_frames(sk);\n\t\telse if (!(msg->msg_flags & MSG_MORE)) {\n\t\t\terr = ip_push_pending_frames(sk, &fl4);\n\t\t\tif (err == -ENOBUFS && !inet->recverr)\n\t\t\t\terr = 0;\n\t\t}\n\t\trelease_sock(sk);\n\t}\ndone:\n\tif (free)\n\t\tkfree(ipc.opt);\n\tip_rt_put(rt);\n\nout:\n\tif (err < 0)\n\t\treturn err;\n\treturn len;\n\ndo_confirm:\n\tif (msg->msg_flags & MSG_PROBE)\n\t\tdst_confirm_neigh(&rt->dst, &fl4.daddr);\n\tif (!(msg->msg_flags & MSG_PROBE) || len)\n\t\tgoto back_from_confirm;\n\terr = 0;\n\tgoto done;\n}\n", "target": 1, "idx": 180825}
{"func": "void NetworkReaderProxy::OnGetContent(scoped_ptr<std::string> data) {\n   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));\n   DCHECK(data && !data->empty());\n \n   pending_data_.push_back(data.release());\n   if (!buffer_) {\n    return;\n  }\n\n  int result = ReadInternal(&pending_data_, buffer_.get(), buffer_length_);\n  remaining_content_length_ -= result;\n  DCHECK_GE(remaining_content_length_, 0);\n\n  buffer_ = NULL;\n  buffer_length_ = 0;\n  DCHECK(!callback_.is_null());\n  base::ResetAndReturn(&callback_).Run(result);\n}\n", "target": 1, "idx": 185005}
{"func": "InlineBoxPosition ComputeInlineBoxPositionTemplate(\n    const PositionTemplate<Strategy>& position,\n    TextAffinity affinity,\n    TextDirection primary_direction) {\n  int caret_offset = position.ComputeEditingOffset();\n  Node* const anchor_node = position.AnchorNode();\n  LayoutObject* layout_object =\n      anchor_node->IsShadowRoot()\n          ? ToShadowRoot(anchor_node)->host().GetLayoutObject()\n          : anchor_node->GetLayoutObject();\n\n  DCHECK(layout_object) << position;\n\n  if (layout_object->IsText()) {\n    return ComputeInlineBoxPositionForTextNode(layout_object, caret_offset,\n                                                affinity, primary_direction);\n   }\n \n  if (layout_object->IsLayoutBlockFlow()) {\n    if (CanHaveChildrenForEditing(anchor_node) &&\n        HasRenderedNonAnonymousDescendantsWithHeight(layout_object)) {\n      const PositionTemplate<Strategy>& downstream_equivalent =\n          DownstreamIgnoringEditingBoundaries(position);\n      if (downstream_equivalent != position) {\n        return ComputeInlineBoxPosition(\n            downstream_equivalent, TextAffinity::kUpstream, primary_direction);\n      }\n      const PositionTemplate<Strategy>& upstream_equivalent =\n          UpstreamIgnoringEditingBoundaries(position);\n      if (upstream_equivalent == position ||\n          DownstreamIgnoringEditingBoundaries(upstream_equivalent) == position)\n        return InlineBoxPosition();\n      return ComputeInlineBoxPosition(\n          upstream_equivalent, TextAffinity::kUpstream, primary_direction);\n    }\n   }\n \n  if (!layout_object->IsAtomicInlineLevel())\n     return InlineBoxPosition();\n  if (!layout_object->IsBox())\n     return InlineBoxPosition();\n  InlineBox* const inline_box = ToLayoutBox(layout_object)->InlineBoxWrapper();\n  if (!inline_box)\n     return InlineBoxPosition();\n  if ((caret_offset > inline_box->CaretMinOffset() &&\n       caret_offset < inline_box->CaretMaxOffset()))\n    return InlineBoxPosition(inline_box, caret_offset);\n  return AdjustInlineBoxPositionForTextDirection(\n      inline_box, caret_offset, layout_object->Style()->GetUnicodeBidi(),\n      primary_direction);\n }\n", "target": 1, "idx": 186941}
{"func": "void PDFiumEngine::Form_Beep(IPDF_JSPLATFORM* param, int type) {\n}\n", "target": 0, "idx": 152974}
{"func": "void QuotaManager::GetUsageAndQuotaForEviction(\n    const GetUsageAndQuotaForEvictionCallback& callback) {\n  DCHECK(io_thread_->BelongsToCurrentThread());\n  GetUsageAndQuotaInternal(\n      GURL(), kStorageTypeTemporary, true /* global */, callback);\n}\n", "target": 0, "idx": 108510}
{"func": " static unsigned int seedsize(struct crypto_alg *alg)\n {\n \tstruct rng_alg *ralg = container_of(alg, struct rng_alg, base);\n \n\treturn alg->cra_rng.rng_make_random ?\n\t       alg->cra_rng.seedsize : ralg->seedsize;\n }\n", "target": 1, "idx": 180907}
{"func": "PHP_FUNCTION(imagecopyresampled)\n{\n\tzval *SIM, *DIM;\n\tlong SX, SY, SW, SH, DX, DY, DW, DH;\n\tgdImagePtr im_dst, im_src;\n\tint srcH, srcW, dstH, dstW, srcY, srcX, dstY, dstX;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rrllllllll\", &DIM, &SIM, &DX, &DY, &SX, &SY, &DW, &DH, &SW, &SH) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im_dst, gdImagePtr, &DIM, -1, \"Image\", le_gd);\n\tZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, \"Image\", le_gd);\n\n\tsrcX = SX;\n\tsrcY = SY;\n\tsrcH = SH;\n\tsrcW = SW;\n\tdstX = DX;\n\tdstY = DY;\n\tdstH = DH;\n\tdstW = DW;\n\n\tgdImageCopyResampled(im_dst, im_src, dstX, dstY, srcX, srcY, dstW, dstH, srcW, srcH);\n\n\tRETURN_TRUE;\n}\n", "target": 0, "idx": 15103}
{"func": "int git_index__changed_relative_to(\n\tgit_index *index, const git_oid *checksum)\n{\n\t/* attempt to update index (ignoring errors) */\n\tif (git_index_read(index, false) < 0)\n\t\tgiterr_clear();\n\n\treturn !!git_oid_cmp(&index->checksum, checksum);\n}\n", "target": 0, "idx": 83650}
{"func": " static bool HasElementImpl(Isolate* isolate, Handle<JSObject> holder,\n uint32_t index,\n Handle<FixedArrayBase> backing_store,\n PropertyFilter filter = ALL_PROPERTIES) {\n return Subclass::GetEntryForIndexImpl(isolate, *holder, *backing_store,\n                                          index, filter) != kMaxUInt32;\n }\n", "target": 0, "idx": 176303}
{"func": "int hugetlb_reserve_pages(struct inode *inode,\n\t\t\t\t\tlong from, long to,\n\t\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\t\tvm_flags_t vm_flags)\n{\n\tlong ret, chg;\n\tstruct hstate *h = hstate_inode(inode);\n\tstruct hugepage_subpool *spool = subpool_inode(inode);\n\n\t/*\n\t * Only apply hugepage reservation if asked. At fault time, an\n\t * attempt will be made for VM_NORESERVE to allocate a page\n\t * without using reserves\n\t */\n\tif (vm_flags & VM_NORESERVE)\n\t\treturn 0;\n\n\t/*\n\t * Shared mappings base their reservation on the number of pages that\n\t * are already allocated on behalf of the file. Private mappings need\n\t * to reserve the full area even if read-only as mprotect() may be\n\t * called to make the mapping read-write. Assume !vma is a shm mapping\n\t */\n\tif (!vma || vma->vm_flags & VM_MAYSHARE)\n\t\tchg = region_chg(&inode->i_mapping->private_list, from, to);\n\telse {\n\t\tstruct resv_map *resv_map = resv_map_alloc();\n\t\tif (!resv_map)\n\t\t\treturn -ENOMEM;\n\n\t\tchg = to - from;\n\n\t\tset_vma_resv_map(vma, resv_map);\n \t\tset_vma_resv_flags(vma, HPAGE_RESV_OWNER);\n \t}\n \n\tif (chg < 0)\n\t\treturn chg;\n \n \t/* There must be enough pages in the subpool for the mapping */\n\tif (hugepage_subpool_get_pages(spool, chg))\n\t\treturn -ENOSPC;\n \n \t/*\n \t * Check enough hugepages are available for the reservation.\n\t * Hand the pages back to the subpool if there are not\n\t */\n \tret = hugetlb_acct_memory(h, chg);\n \tif (ret < 0) {\n \t\thugepage_subpool_put_pages(spool, chg);\n\t\treturn ret;\n \t}\n \n \t/*\n\t * Account for the reservations made. Shared mappings record regions\n\t * that have reservations as they are shared by multiple VMAs.\n\t * When the last VMA disappears, the region map says how much\n\t * the reservation was and the page cache tells how much of\n\t * the reservation was consumed. Private mappings are per-VMA and\n\t * only the consumed reservations are tracked. When the VMA\n\t * disappears, the original reservation is the VMA size and the\n\t * consumed reservations are stored in the map. Hence, nothing\n\t * else has to be done for private mappings here\n\t */\n \tif (!vma || vma->vm_flags & VM_MAYSHARE)\n \t\tregion_add(&inode->i_mapping->private_list, from, to);\n \treturn 0;\n }\n", "target": 1, "idx": 178766}
{"func": "void WebGLRenderingContextBase::TexImageHelperHTMLVideoElement(\n    SecurityOrigin* security_origin,\n    TexImageFunctionID function_id,\n    GLenum target,\n    GLint level,\n    GLint internalformat,\n    GLenum format,\n    GLenum type,\n    GLint xoffset,\n    GLint yoffset,\n    GLint zoffset,\n    HTMLVideoElement* video,\n    const IntRect& source_image_rect,\n    GLsizei depth,\n    GLint unpack_image_height,\n    ExceptionState& exception_state) {\n  const char* func_name = GetTexImageFunctionName(function_id);\n  if (isContextLost())\n    return;\n\n  if (!ValidateHTMLVideoElement(security_origin, func_name, video,\n                                exception_state))\n    return;\n  WebGLTexture* texture =\n      ValidateTexImageBinding(func_name, function_id, target);\n  if (!texture)\n    return;\n  TexImageFunctionType function_type;\n  if (function_id == kTexImage2D || function_id == kTexImage3D)\n    function_type = kTexImage;\n  else\n    function_type = kTexSubImage;\n  if (!ValidateTexFunc(func_name, function_type, kSourceHTMLVideoElement,\n                       target, level, internalformat, video->videoWidth(),\n                       video->videoHeight(), 1, 0, format, type, xoffset,\n                       yoffset, zoffset))\n    return;\n\n  bool source_image_rect_is_default =\n      source_image_rect == SentinelEmptyRect() ||\n      source_image_rect ==\n          IntRect(0, 0, video->videoWidth(), video->videoHeight());\n  const bool use_copyTextureCHROMIUM = function_id == kTexImage2D &&\n                                       source_image_rect_is_default &&\n                                       depth == 1 && GL_TEXTURE_2D == target &&\n                                       CanUseTexImageByGPU(format, type);\n  if (use_copyTextureCHROMIUM) {\n    DCHECK_EQ(xoffset, 0);\n    DCHECK_EQ(yoffset, 0);\n    DCHECK_EQ(zoffset, 0);\n\n    if (video->CopyVideoTextureToPlatformTexture(\n            ContextGL(), target, texture->Object(), internalformat, format,\n            type, level, unpack_premultiply_alpha_, unpack_flip_y_)) {\n      texture->UpdateLastUploadedVideo(video->GetWebMediaPlayer());\n      return;\n    }\n  }\n\n  if (source_image_rect_is_default) {\n    ScopedUnpackParametersResetRestore(\n        this, unpack_flip_y_ || unpack_premultiply_alpha_);\n    if (video->TexImageImpl(\n            static_cast<WebMediaPlayer::TexImageFunctionID>(function_id),\n            target, ContextGL(), texture->Object(), level,\n            ConvertTexInternalFormat(internalformat, type), format, type,\n            xoffset, yoffset, zoffset, unpack_flip_y_,\n            unpack_premultiply_alpha_ &&\n                unpack_colorspace_conversion_ == GL_NONE)) {\n      texture->UpdateLastUploadedVideo(video->GetWebMediaPlayer());\n      return;\n    }\n  }\n\n  if (use_copyTextureCHROMIUM) {\n    std::unique_ptr<ImageBufferSurface> surface =\n        WTF::WrapUnique(new AcceleratedImageBufferSurface(\n            IntSize(video->videoWidth(), video->videoHeight())));\n    if (surface->IsValid()) {\n      std::unique_ptr<ImageBuffer> image_buffer(\n          ImageBuffer::Create(std::move(surface)));\n      if (image_buffer) {\n        video->PaintCurrentFrame(\n            image_buffer->Canvas(),\n            IntRect(0, 0, video->videoWidth(), video->videoHeight()), nullptr);\n\n\n        TexImage2DBase(target, level, internalformat, video->videoWidth(),\n                       video->videoHeight(), 0, format, type, nullptr);\n\n        if (image_buffer->CopyToPlatformTexture(\n                FunctionIDToSnapshotReason(function_id), ContextGL(), target,\n                texture->Object(), unpack_premultiply_alpha_, unpack_flip_y_,\n                IntPoint(0, 0),\n                IntRect(0, 0, video->videoWidth(), video->videoHeight()))) {\n          texture->UpdateLastUploadedVideo(video->GetWebMediaPlayer());\n          return;\n        }\n      }\n    }\n  }\n\n  RefPtr<Image> image = VideoFrameToImage(video);\n  if (!image)\n    return;\n  TexImageImpl(function_id, target, level, internalformat, xoffset, yoffset,\n               zoffset, format, type, image.Get(),\n               WebGLImageConversion::kHtmlDomVideo, unpack_flip_y_,\n               unpack_premultiply_alpha_, source_image_rect, depth,\n               unpack_image_height);\n  texture->UpdateLastUploadedVideo(video->GetWebMediaPlayer());\n}\n", "target": 0, "idx": 146388}
{"func": "const CuePoint* Cues::GetFirst() const {\n if (m_cue_points == NULL || m_count == 0)\n return NULL;\n\n CuePoint* const* const pp = m_cue_points;\n if (pp == NULL)\n return NULL;\n\n CuePoint* const pCP = pp[0];\n if (pCP == NULL || pCP->GetTimeCode() < 0)\n return NULL;\n\n return pCP;\n}\n", "target": 0, "idx": 177397}
{"func": "xfs_da_map_covers_blocks(\n\tint\t\tnmap,\n\txfs_bmbt_irec_t\t*mapp,\n\txfs_dablk_t\tbno,\n\tint\t\tcount)\n{\n\tint\t\ti;\n\txfs_fileoff_t\toff;\n\n\tfor (i = 0, off = bno; i < nmap; i++) {\n\t\tif (mapp[i].br_startblock == HOLESTARTBLOCK ||\n\t\t    mapp[i].br_startblock == DELAYSTARTBLOCK) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (off != mapp[i].br_startoff) {\n\t\t\treturn 0;\n\t\t}\n\t\toff += mapp[i].br_blockcount;\n\t}\n\treturn off == bno + count;\n}\n", "target": 0, "idx": 35959}
{"func": "RenderFrameImpl::createWorkerPermissionClientProxy(\n    blink::WebLocalFrame* frame) {\n  if (!frame || !frame->view())\n    return NULL;\n  DCHECK(!frame_ || frame_ == frame);\n  return GetContentClient()->renderer()->CreateWorkerPermissionClientProxy(\n      this, frame);\n}\n", "target": 0, "idx": 118483}
{"func": "  void SendAlternateCut() {\n    if (TestingNativeMac())\n      SendKeyEvent(ui::VKEY_X, false, true);\n    else\n      SendKeyEvent(ui::VKEY_DELETE, true, false);\n  }\n", "target": 0, "idx": 137356}
{"func": "void ServiceWorkerDevToolsAgentHost::AttachSession(DevToolsSession* session) {\n  if (state_ == WORKER_READY) {\n    if (sessions().size() == 1) {\n      BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,\n                               base::BindOnce(&SetDevToolsAttachedOnIO,\n                                              context_weak_, version_id_, true));\n     }\n    session->SetRenderer(RenderProcessHost::FromID(worker_process_id_),\n                         nullptr);\n     session->AttachToAgent(agent_ptr_);\n   }\n   session->AddHandler(base::WrapUnique(new protocol::InspectorHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::NetworkHandler(GetId())));\n  session->AddHandler(base::WrapUnique(new protocol::SchemaHandler()));\n}\n", "target": 1, "idx": 186760}
{"func": "cJSON *cJSON_CreateBool(int b)\t\t\t\t\t{cJSON *item=cJSON_New_Item();if(item)item->type=b?cJSON_True:cJSON_False;return item;}\n", "target": 0, "idx": 93696}
{"func": "static ssize_t WritePSDChannels(const PSDInfo *psd_info,\n  const ImageInfo *image_info,Image *image,Image *next_image,\n  MagickOffsetType size_offset,const MagickBooleanType separate)\n{\n  Image\n    *mask;\n\n  MagickOffsetType\n    rows_offset;\n\n  size_t\n    channels,\n    count,\n    length,\n    offset_length;\n\n  unsigned char\n    *compact_pixels;\n\n  count=0;\n  offset_length=0;\n  rows_offset=0;\n   compact_pixels=(unsigned char *) NULL;\n   if (next_image->compression == RLECompression)\n     {\n      compact_pixels=AcquireCompactPixels(image);\n       if (compact_pixels == (unsigned char *) NULL)\n         return(0);\n     }\n  channels=1;\n  if (separate == MagickFalse)\n    {\n      if (next_image->storage_class != PseudoClass)\n        {\n          if (IsGrayImage(next_image,&next_image->exception) == MagickFalse)\n            channels=next_image->colorspace == CMYKColorspace ? 4 : 3;\n          if (next_image->matte != MagickFalse)\n            channels++;\n        }\n      rows_offset=TellBlob(image)+2;\n      count+=WriteCompressionStart(psd_info,image,next_image,channels);\n      offset_length=(next_image->rows*(psd_info->version == 1 ? 2 : 4));\n    }\n  size_offset+=2;\n  if (next_image->storage_class == PseudoClass)\n    {\n      length=WritePSDChannel(psd_info,image_info,image,next_image,\n        IndexQuantum,compact_pixels,rows_offset,separate);\n      if (separate != MagickFalse)\n        size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;\n      else\n        rows_offset+=offset_length;\n      count+=length;\n    }\n  else\n    {\n      if (IsGrayImage(next_image,&next_image->exception) != MagickFalse)\n        {\n          length=WritePSDChannel(psd_info,image_info,image,next_image,\n            GrayQuantum,compact_pixels,rows_offset,separate);\n          if (separate != MagickFalse)\n            size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;\n          else\n            rows_offset+=offset_length;\n          count+=length;\n        }\n      else\n        {\n          if (next_image->colorspace == CMYKColorspace)\n            (void) NegateImage(next_image,MagickFalse);\n\n          length=WritePSDChannel(psd_info,image_info,image,next_image,\n            RedQuantum,compact_pixels,rows_offset,separate);\n          if (separate != MagickFalse)\n            size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;\n          else\n            rows_offset+=offset_length;\n          count+=length;\n\n          length=WritePSDChannel(psd_info,image_info,image,next_image,\n            GreenQuantum,compact_pixels,rows_offset,separate);\n          if (separate != MagickFalse)\n            size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;\n          else\n            rows_offset+=offset_length;\n          count+=length;\n\n          length=WritePSDChannel(psd_info,image_info,image,next_image,\n            BlueQuantum,compact_pixels,rows_offset,separate);\n          if (separate != MagickFalse)\n            size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;\n          else\n            rows_offset+=offset_length;\n          count+=length;\n\n          if (next_image->colorspace == CMYKColorspace)\n            {\n              length=WritePSDChannel(psd_info,image_info,image,next_image,\n                BlackQuantum,compact_pixels,rows_offset,separate);\n              if (separate != MagickFalse)\n                size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;\n              else\n                rows_offset+=offset_length;\n              count+=length;\n            }\n        }\n      if (next_image->matte != MagickFalse)\n        {\n          length=WritePSDChannel(psd_info,image_info,image,next_image,\n            AlphaQuantum,compact_pixels,rows_offset,separate);\n          if (separate != MagickFalse)\n            size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;\n          else\n            rows_offset+=offset_length;\n          count+=length;\n        }\n    }\n  compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);\n  if (next_image->colorspace == CMYKColorspace)\n    (void) NegateImage(next_image,MagickFalse);\n  if (separate != MagickFalse)\n    {\n      const char\n        *property;\n\n      property=GetImageArtifact(next_image,\"psd:opacity-mask\");\n      if (property != (const char *) NULL)\n        {\n          mask=(Image *) GetImageRegistry(ImageRegistryType,property,\n            &image->exception);\n          if (mask != (Image *) NULL)\n            {\n              if (mask->compression == RLECompression)\n                {\n                  compact_pixels=AcquireCompactPixels(mask);\n                  if (compact_pixels == (unsigned char *) NULL)\n                    return(0);\n                }\n              length=WritePSDChannel(psd_info,image_info,image,mask,\n                RedQuantum,compact_pixels,rows_offset,MagickTrue);\n              (void) WritePSDSize(psd_info,image,length,size_offset);\n              count+=length;\n              compact_pixels=(unsigned char *) RelinquishMagickMemory(\n                compact_pixels);\n            }\n        }\n    }\n  return(count);\n}\n", "target": 1, "idx": 183275}
{"func": "void VideoCaptureImpl::OnBufferCreated(int32_t buffer_id,\n                                       mojo::ScopedSharedBufferHandle handle) {\n  DVLOG(1) << __func__ << \" buffer_id: \" << buffer_id;\n  DCHECK(io_thread_checker_.CalledOnValidThread());\n  DCHECK(handle.is_valid());\n \n   base::SharedMemoryHandle memory_handle;\n   size_t memory_size = 0;\n  bool read_only_flag = false;\n \n   const MojoResult result = mojo::UnwrapSharedMemoryHandle(\n      std::move(handle), &memory_handle, &memory_size, &read_only_flag);\n   DCHECK_EQ(MOJO_RESULT_OK, result);\n   DCHECK_GT(memory_size, 0u);\n \n   std::unique_ptr<base::SharedMemory> shm(\n       new base::SharedMemory(memory_handle, true /* read_only */));\n   if (!shm->Map(memory_size)) {\n    DLOG(ERROR) << \"OnBufferCreated: Map failed.\";\n    return;\n  }\n  const bool inserted =\n      client_buffers_\n          .insert(std::make_pair(buffer_id,\n                                 new ClientBuffer(std::move(shm), memory_size)))\n          .second;\n  DCHECK(inserted);\n}\n", "target": 1, "idx": 186842}
{"func": "static void vapic_exit(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tint idx;\n\n\tif (!apic || !apic->vapic_addr)\n\t\treturn;\n\n\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\tkvm_release_page_dirty(apic->vapic_page);\n\tmark_page_dirty(vcpu->kvm, apic->vapic_addr >> PAGE_SHIFT);\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n}\n", "target": 0, "idx": 20890}
{"func": "s32 brcmf_vif_set_mgmt_ie(struct brcmf_cfg80211_vif *vif, s32 pktflag,\n\t\t\t  const u8 *vndr_ie_buf, u32 vndr_ie_len)\n{\n\tstruct brcmf_if *ifp;\n\tstruct vif_saved_ie *saved_ie;\n\ts32 err = 0;\n\tu8  *iovar_ie_buf;\n\tu8  *curr_ie_buf;\n\tu8  *mgmt_ie_buf = NULL;\n\tint mgmt_ie_buf_len;\n\tu32 *mgmt_ie_len;\n\tu32 del_add_ie_buf_len = 0;\n\tu32 total_ie_buf_len = 0;\n\tu32 parsed_ie_buf_len = 0;\n\tstruct parsed_vndr_ies old_vndr_ies;\n\tstruct parsed_vndr_ies new_vndr_ies;\n\tstruct parsed_vndr_ie_info *vndrie_info;\n\ts32 i;\n\tu8 *ptr;\n\tint remained_buf_len;\n\n\tif (!vif)\n\t\treturn -ENODEV;\n\tifp = vif->ifp;\n\tsaved_ie = &vif->saved_ie;\n\n\tbrcmf_dbg(TRACE, \"bsscfgidx %d, pktflag : 0x%02X\\n\", ifp->bsscfgidx,\n\t\t  pktflag);\n\tiovar_ie_buf = kzalloc(WL_EXTRA_BUF_MAX, GFP_KERNEL);\n\tif (!iovar_ie_buf)\n\t\treturn -ENOMEM;\n\tcurr_ie_buf = iovar_ie_buf;\n\tswitch (pktflag) {\n\tcase BRCMF_VNDR_IE_PRBREQ_FLAG:\n\t\tmgmt_ie_buf = saved_ie->probe_req_ie;\n\t\tmgmt_ie_len = &saved_ie->probe_req_ie_len;\n\t\tmgmt_ie_buf_len = sizeof(saved_ie->probe_req_ie);\n\t\tbreak;\n\tcase BRCMF_VNDR_IE_PRBRSP_FLAG:\n\t\tmgmt_ie_buf = saved_ie->probe_res_ie;\n\t\tmgmt_ie_len = &saved_ie->probe_res_ie_len;\n\t\tmgmt_ie_buf_len = sizeof(saved_ie->probe_res_ie);\n\t\tbreak;\n\tcase BRCMF_VNDR_IE_BEACON_FLAG:\n\t\tmgmt_ie_buf = saved_ie->beacon_ie;\n\t\tmgmt_ie_len = &saved_ie->beacon_ie_len;\n\t\tmgmt_ie_buf_len = sizeof(saved_ie->beacon_ie);\n\t\tbreak;\n\tcase BRCMF_VNDR_IE_ASSOCREQ_FLAG:\n\t\tmgmt_ie_buf = saved_ie->assoc_req_ie;\n\t\tmgmt_ie_len = &saved_ie->assoc_req_ie_len;\n\t\tmgmt_ie_buf_len = sizeof(saved_ie->assoc_req_ie);\n\t\tbreak;\n\tdefault:\n\t\terr = -EPERM;\n\t\tbrcmf_err(\"not suitable type\\n\");\n\t\tgoto exit;\n\t}\n\n\tif (vndr_ie_len > mgmt_ie_buf_len) {\n\t\terr = -ENOMEM;\n\t\tbrcmf_err(\"extra IE size too big\\n\");\n\t\tgoto exit;\n\t}\n\n\t/* parse and save new vndr_ie in curr_ie_buff before comparing it */\n\tif (vndr_ie_buf && vndr_ie_len && curr_ie_buf) {\n\t\tptr = curr_ie_buf;\n\t\tbrcmf_parse_vndr_ies(vndr_ie_buf, vndr_ie_len, &new_vndr_ies);\n\t\tfor (i = 0; i < new_vndr_ies.count; i++) {\n\t\t\tvndrie_info = &new_vndr_ies.ie_info[i];\n\t\t\tmemcpy(ptr + parsed_ie_buf_len, vndrie_info->ie_ptr,\n\t\t\t       vndrie_info->ie_len);\n\t\t\tparsed_ie_buf_len += vndrie_info->ie_len;\n\t\t}\n\t}\n\n\tif (mgmt_ie_buf && *mgmt_ie_len) {\n\t\tif (parsed_ie_buf_len && (parsed_ie_buf_len == *mgmt_ie_len) &&\n\t\t    (memcmp(mgmt_ie_buf, curr_ie_buf,\n\t\t\t    parsed_ie_buf_len) == 0)) {\n\t\t\tbrcmf_dbg(TRACE, \"Previous mgmt IE equals to current IE\\n\");\n\t\t\tgoto exit;\n\t\t}\n\n\t\t/* parse old vndr_ie */\n\t\tbrcmf_parse_vndr_ies(mgmt_ie_buf, *mgmt_ie_len, &old_vndr_ies);\n\n\t\t/* make a command to delete old ie */\n\t\tfor (i = 0; i < old_vndr_ies.count; i++) {\n\t\t\tvndrie_info = &old_vndr_ies.ie_info[i];\n\n\t\t\tbrcmf_dbg(TRACE, \"DEL ID : %d, Len: %d , OUI:%02x:%02x:%02x\\n\",\n\t\t\t\t  vndrie_info->vndrie.id,\n\t\t\t\t  vndrie_info->vndrie.len,\n\t\t\t\t  vndrie_info->vndrie.oui[0],\n\t\t\t\t  vndrie_info->vndrie.oui[1],\n\t\t\t\t  vndrie_info->vndrie.oui[2]);\n\n\t\t\tdel_add_ie_buf_len = brcmf_vndr_ie(curr_ie_buf, pktflag,\n\t\t\t\t\t\t\t   vndrie_info->ie_ptr,\n\t\t\t\t\t\t\t   vndrie_info->ie_len,\n\t\t\t\t\t\t\t   \"del\");\n\t\t\tcurr_ie_buf += del_add_ie_buf_len;\n\t\t\ttotal_ie_buf_len += del_add_ie_buf_len;\n\t\t}\n\t}\n\n\t*mgmt_ie_len = 0;\n\t/* Add if there is any extra IE */\n\tif (mgmt_ie_buf && parsed_ie_buf_len) {\n\t\tptr = mgmt_ie_buf;\n\n\t\tremained_buf_len = mgmt_ie_buf_len;\n\n\t\t/* make a command to add new ie */\n\t\tfor (i = 0; i < new_vndr_ies.count; i++) {\n\t\t\tvndrie_info = &new_vndr_ies.ie_info[i];\n\n\t\t\t/* verify remained buf size before copy data */\n\t\t\tif (remained_buf_len < (vndrie_info->vndrie.len +\n\t\t\t\t\t\t\tVNDR_IE_VSIE_OFFSET)) {\n\t\t\t\tbrcmf_err(\"no space in mgmt_ie_buf: len left %d\",\n\t\t\t\t\t  remained_buf_len);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tremained_buf_len -= (vndrie_info->ie_len +\n\t\t\t\t\t     VNDR_IE_VSIE_OFFSET);\n\n\t\t\tbrcmf_dbg(TRACE, \"ADDED ID : %d, Len: %d, OUI:%02x:%02x:%02x\\n\",\n\t\t\t\t  vndrie_info->vndrie.id,\n\t\t\t\t  vndrie_info->vndrie.len,\n\t\t\t\t  vndrie_info->vndrie.oui[0],\n\t\t\t\t  vndrie_info->vndrie.oui[1],\n\t\t\t\t  vndrie_info->vndrie.oui[2]);\n\n\t\t\tdel_add_ie_buf_len = brcmf_vndr_ie(curr_ie_buf, pktflag,\n\t\t\t\t\t\t\t   vndrie_info->ie_ptr,\n\t\t\t\t\t\t\t   vndrie_info->ie_len,\n\t\t\t\t\t\t\t   \"add\");\n\n\t\t\t/* save the parsed IE in wl struct */\n\t\t\tmemcpy(ptr + (*mgmt_ie_len), vndrie_info->ie_ptr,\n\t\t\t       vndrie_info->ie_len);\n\t\t\t*mgmt_ie_len += vndrie_info->ie_len;\n\n\t\t\tcurr_ie_buf += del_add_ie_buf_len;\n\t\t\ttotal_ie_buf_len += del_add_ie_buf_len;\n\t\t}\n\t}\n\tif (total_ie_buf_len) {\n\t\terr  = brcmf_fil_bsscfg_data_set(ifp, \"vndr_ie\", iovar_ie_buf,\n\t\t\t\t\t\t total_ie_buf_len);\n\t\tif (err)\n\t\t\tbrcmf_err(\"vndr ie set error : %d\\n\", err);\n\t}\n\nexit:\n\tkfree(iovar_ie_buf);\n\treturn err;\n}\n", "target": 0, "idx": 49133}
{"func": "ForeignSessionHelper::ForeignSessionHelper(Profile* profile)\n    : profile_(profile) {\n  sync_sessions::SessionSyncService* service =\n      SessionSyncServiceFactory::GetInstance()->GetForProfile(profile);\n\n  if (service) {\n    foreign_session_updated_subscription_ =\n        service->SubscribeToForeignSessionsChanged(base::BindRepeating(\n            &ForeignSessionHelper::FireForeignSessionCallback,\n            base::Unretained(this)));\n  }\n}\n", "target": 0, "idx": 141574}
{"func": "error::Error GLES2DecoderPassthroughImpl::DoBindFragmentInputLocationCHROMIUM(\n    GLuint program,\n    GLint location,\n    const char* name) {\n  NOTIMPLEMENTED();\n  return error::kNoError;\n}\n", "target": 0, "idx": 154564}
{"func": " static MagickBooleanType ReadUncompressedRGB(Image *image, DDSInfo *dds_info,\n  ExceptionInfo *exception)\n{\n  PixelPacket\n    *q;\n\n  ssize_t\n    x, y;\n\n  unsigned short\n    color;\n\n  if (dds_info->pixelformat.rgb_bitcount == 8)\n    (void) SetImageType(image,GrayscaleType);\n  else if (dds_info->pixelformat.rgb_bitcount == 16 && !IsBitMask(\n    dds_info->pixelformat,0xf800,0x07e0,0x001f,0x0000))\n    ThrowBinaryException(CorruptImageError,\"ImageTypeNotSupported\",\n      image->filename);\n\n  for (y = 0; y < (ssize_t) dds_info->height; y++)\n  {\n    q = QueueAuthenticPixels(image, 0, y, dds_info->width, 1,exception);\n\n    if (q == (PixelPacket *) NULL)\n      return MagickFalse;\n\n    for (x = 0; x < (ssize_t) dds_info->width; x++)\n    {\n      if (dds_info->pixelformat.rgb_bitcount == 8)\n        SetPixelGray(q,ScaleCharToQuantum(ReadBlobByte(image)));\n      else if (dds_info->pixelformat.rgb_bitcount == 16)\n        {\n           color=ReadBlobShort(image);\n           SetPixelRed(q,ScaleCharToQuantum((unsigned char)\n             (((color >> 11)/31.0)*255)));\n           SetPixelGreen(q,ScaleCharToQuantum((unsigned char)\n             ((((unsigned short)(color << 5) >> 10)/63.0)*255)));\n           SetPixelBlue(q,ScaleCharToQuantum((unsigned char)\n             ((((unsigned short)(color << 11) >> 11)/31.0)*255)));\n        }\n      else\n        {\n          SetPixelBlue(q,ScaleCharToQuantum((unsigned char)\n            ReadBlobByte(image)));\n          SetPixelGreen(q,ScaleCharToQuantum((unsigned char)\n            ReadBlobByte(image)));\n          SetPixelRed(q,ScaleCharToQuantum((unsigned char)\n            ReadBlobByte(image)));\n          if (dds_info->pixelformat.rgb_bitcount == 32)\n            (void) ReadBlobByte(image);\n        }\n      SetPixelAlpha(q,QuantumRange);\n      q++;\n    }\n \n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n       return MagickFalse;\n   }\n \n  SkipRGBMipmaps(image, dds_info, 3);\n  return MagickTrue;\n }\n", "target": 1, "idx": 182074}
{"func": "std::unique_ptr<BlobDataHandle> BlobStorageContext::GetBlobDataFromPublicURL(\n    const GURL& url) {\n  std::string uuid;\n  BlobEntry* entry = registry_.GetEntryFromURL(url, &uuid);\n  if (!entry)\n    return nullptr;\n  return CreateHandle(uuid, entry);\n}\n", "target": 0, "idx": 163099}
{"func": "static void SortByDimension(\n  Rtree *pRtree,\n  int *aIdx,\n  int nIdx,\n  int iDim,\n  RtreeCell *aCell,\n  int *aSpare\n){\n  if( nIdx>1 ){\n\n    int iLeft = 0;\n    int iRight = 0;\n\n    int nLeft = nIdx/2;\n    int nRight = nIdx-nLeft;\n    int *aLeft = aIdx;\n    int *aRight = &aIdx[nLeft];\n\n    SortByDimension(pRtree, aLeft, nLeft, iDim, aCell, aSpare);\n    SortByDimension(pRtree, aRight, nRight, iDim, aCell, aSpare);\n\n    memcpy(aSpare, aLeft, sizeof(int)*nLeft);\n    aLeft = aSpare;\n    while( iLeft<nLeft || iRight<nRight ){\n      RtreeDValue xleft1 = DCOORD(aCell[aLeft[iLeft]].aCoord[iDim*2]);\n      RtreeDValue xleft2 = DCOORD(aCell[aLeft[iLeft]].aCoord[iDim*2+1]);\n      RtreeDValue xright1 = DCOORD(aCell[aRight[iRight]].aCoord[iDim*2]);\n      RtreeDValue xright2 = DCOORD(aCell[aRight[iRight]].aCoord[iDim*2+1]);\n      if( (iLeft!=nLeft) && ((iRight==nRight)\n       || (xleft1<xright1)\n       || (xleft1==xright1 && xleft2<xright2)\n      )){\n        aIdx[iLeft+iRight] = aLeft[iLeft];\n        iLeft++;\n      }else{\n        aIdx[iLeft+iRight] = aRight[iRight];\n        iRight++;\n      }\n    }\n\n#if 0\n    /* Check that the sort worked */\n    {\n      int jj;\n      for(jj=1; jj<nIdx; jj++){\n        RtreeDValue xleft1 = aCell[aIdx[jj-1]].aCoord[iDim*2];\n        RtreeDValue xleft2 = aCell[aIdx[jj-1]].aCoord[iDim*2+1];\n        RtreeDValue xright1 = aCell[aIdx[jj]].aCoord[iDim*2];\n        RtreeDValue xright2 = aCell[aIdx[jj]].aCoord[iDim*2+1];\n        assert( xleft1<=xright1 && (xleft1<xright1 || xleft2<=xright2) );\n      }\n    }\n#endif\n  }\n}\n", "target": 0, "idx": 164441}
{"func": "static void tcp_data_queue_ofo(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct sk_buff *skb1;\n\tu32 seq, end_seq;\n\n\ttcp_ecn_check_ce(tp, skb);\n\n\tif (unlikely(tcp_try_rmem_schedule(sk, skb, skb->truesize))) {\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPOFODROP);\n\t\ttcp_drop(sk, skb);\n\t\treturn;\n\t}\n\n\t/* Disable header prediction. */\n\ttp->pred_flags = 0;\n\tinet_csk_schedule_ack(sk);\n\n\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPOFOQUEUE);\n\tSOCK_DEBUG(sk, \"out of order segment: rcv_next %X seq %X - %X\\n\",\n\t\t   tp->rcv_nxt, TCP_SKB_CB(skb)->seq, TCP_SKB_CB(skb)->end_seq);\n\n\tskb1 = skb_peek_tail(&tp->out_of_order_queue);\n\tif (!skb1) {\n\t\t/* Initial out of order segment, build 1 SACK. */\n\t\tif (tcp_is_sack(tp)) {\n\t\t\ttp->rx_opt.num_sacks = 1;\n\t\t\ttp->selective_acks[0].start_seq = TCP_SKB_CB(skb)->seq;\n\t\t\ttp->selective_acks[0].end_seq =\n\t\t\t\t\t\tTCP_SKB_CB(skb)->end_seq;\n\t\t}\n\t\t__skb_queue_head(&tp->out_of_order_queue, skb);\n\t\tgoto end;\n\t}\n\n\tseq = TCP_SKB_CB(skb)->seq;\n\tend_seq = TCP_SKB_CB(skb)->end_seq;\n\n\tif (seq == TCP_SKB_CB(skb1)->end_seq) {\n\t\tbool fragstolen;\n\n\t\tif (!tcp_try_coalesce(sk, skb1, skb, &fragstolen)) {\n\t\t\t__skb_queue_after(&tp->out_of_order_queue, skb1, skb);\n\t\t} else {\n\t\t\ttcp_grow_window(sk, skb);\n\t\t\tkfree_skb_partial(skb, fragstolen);\n\t\t\tskb = NULL;\n\t\t}\n\n\t\tif (!tp->rx_opt.num_sacks ||\n\t\t    tp->selective_acks[0].end_seq != seq)\n\t\t\tgoto add_sack;\n\n\t\t/* Common case: data arrive in order after hole. */\n\t\ttp->selective_acks[0].end_seq = end_seq;\n\t\tgoto end;\n\t}\n\n\t/* Find place to insert this segment. */\n\twhile (1) {\n\t\tif (!after(TCP_SKB_CB(skb1)->seq, seq))\n\t\t\tbreak;\n\t\tif (skb_queue_is_first(&tp->out_of_order_queue, skb1)) {\n\t\t\tskb1 = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tskb1 = skb_queue_prev(&tp->out_of_order_queue, skb1);\n\t}\n\n\t/* Do skb overlap to previous one? */\n\tif (skb1 && before(seq, TCP_SKB_CB(skb1)->end_seq)) {\n\t\tif (!after(end_seq, TCP_SKB_CB(skb1)->end_seq)) {\n\t\t\t/* All the bits are present. Drop. */\n\t\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPOFOMERGE);\n\t\t\ttcp_drop(sk, skb);\n\t\t\tskb = NULL;\n\t\t\ttcp_dsack_set(sk, seq, end_seq);\n\t\t\tgoto add_sack;\n\t\t}\n\t\tif (after(seq, TCP_SKB_CB(skb1)->seq)) {\n\t\t\t/* Partial overlap. */\n\t\t\ttcp_dsack_set(sk, seq,\n\t\t\t\t      TCP_SKB_CB(skb1)->end_seq);\n\t\t} else {\n\t\t\tif (skb_queue_is_first(&tp->out_of_order_queue,\n\t\t\t\t\t       skb1))\n\t\t\t\tskb1 = NULL;\n\t\t\telse\n\t\t\t\tskb1 = skb_queue_prev(\n\t\t\t\t\t&tp->out_of_order_queue,\n\t\t\t\t\tskb1);\n\t\t}\n\t}\n\tif (!skb1)\n\t\t__skb_queue_head(&tp->out_of_order_queue, skb);\n\telse\n\t\t__skb_queue_after(&tp->out_of_order_queue, skb1, skb);\n\n\t/* And clean segments covered by new one as whole. */\n\twhile (!skb_queue_is_last(&tp->out_of_order_queue, skb)) {\n\t\tskb1 = skb_queue_next(&tp->out_of_order_queue, skb);\n\n\t\tif (!after(end_seq, TCP_SKB_CB(skb1)->seq))\n\t\t\tbreak;\n\t\tif (before(end_seq, TCP_SKB_CB(skb1)->end_seq)) {\n\t\t\ttcp_dsack_extend(sk, TCP_SKB_CB(skb1)->seq,\n\t\t\t\t\t end_seq);\n\t\t\tbreak;\n\t\t}\n\t\t__skb_unlink(skb1, &tp->out_of_order_queue);\n\t\ttcp_dsack_extend(sk, TCP_SKB_CB(skb1)->seq,\n\t\t\t\t TCP_SKB_CB(skb1)->end_seq);\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPOFOMERGE);\n\t\ttcp_drop(sk, skb1);\n\t}\n\nadd_sack:\n\tif (tcp_is_sack(tp))\n\t\ttcp_sack_new_ofo_skb(sk, seq, end_seq);\nend:\n\tif (skb) {\n\t\ttcp_grow_window(sk, skb);\n\t\tskb_set_owner_r(skb, sk);\n\t}\n}\n", "target": 0, "idx": 51533}
{"func": "void StoreAccumulatedContentLength(int received_content_length,\n                                   int original_content_length,\n                                   bool data_reduction_proxy_was_used) {\n   BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,\n       base::Bind(&UpdateContentLengthPrefs,\n                  received_content_length, original_content_length,\n                 data_reduction_proxy_was_used));\n }\n", "target": 1, "idx": 185031}
{"func": "static MagickStatusType ReadPSDChannel(Image *image,const PSDInfo *psd_info,\n  const LayerInfo* layer_info,const size_t channel,\n  const PSDCompressionType compression,ExceptionInfo *exception)\n{\n  MagickOffsetType\n    offset;\n\n  MagickStatusType\n    status;\n\n  if (layer_info->channel_info[channel].type < -1)\n  {\n    /* ignore user supplied layer mask */\n    SeekBlob(image,layer_info->channel_info[channel].size-2,SEEK_CUR);\n    return(MagickTrue);\n  }\n\n  offset=TellBlob(image);\n  status=MagickTrue;\n  switch(compression)\n  {\n    case Raw:\n      return(ReadPSDChannelRaw(image,psd_info->channels,\n        layer_info->channel_info[channel].type,exception));\n    case RLE:\n      {\n        MagickOffsetType\n          *offsets;\n\n        offsets=ReadPSDRLEOffsets(image,psd_info,image->rows);\n        if (offsets == (MagickOffsetType *) NULL)\n          ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n            image->filename);\n        status=ReadPSDChannelRLE(image,psd_info,\n                 layer_info->channel_info[channel].type,offsets,exception);\n        offsets=(MagickOffsetType *) RelinquishMagickMemory(offsets);\n      }\n      break;\n    case ZipWithPrediction:\n    case ZipWithoutPrediction:\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n      status=ReadPSDChannelZip(image,layer_info->channels,\n        layer_info->channel_info[channel].type,compression,\n        layer_info->channel_info[channel].size-2,exception);\n#else\n      SeekBlob(image,offset+layer_info->channel_info[channel].size-2,SEEK_SET);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n          MissingDelegateWarning,\"DelegateLibrarySupportNotBuiltIn\",\n            \"'%s' (ZLIB)\",image->filename);\n#endif\n      break;\n    default:\n      SeekBlob(image,offset+layer_info->channel_info[channel].size-2,SEEK_SET);\n      (void) ThrowMagickException(exception,GetMagickModule(),TypeWarning,\n        \"CompressionNotSupported\",\"'%.20g'\",(double) compression);\n      break;\n  }\n\n  if (status == MagickFalse)\n    SeekBlob(image,offset+layer_info->channel_info[channel].size-2,SEEK_SET);\n\n  return(status);\n}\n", "target": 0, "idx": 71652}
{"func": "void WorkerThread::shutdown()\n{\n    ASSERT(isCurrentThread());\n    {\n        MutexLocker lock(m_threadStateMutex);\n        ASSERT(!m_shutdown);\n        m_shutdown = true;\n    }\n\n    PlatformThreadData::current().threadTimers().setSharedTimer(nullptr);\n    workerGlobalScope()->dispose();\n    willDestroyIsolate();\n\n    workerReportingProxy().willDestroyWorkerGlobalScope();\n\n#if !ENABLE(OILPAN)\n    ASSERT(m_workerGlobalScope->hasOneRef());\n#endif\n    m_workerGlobalScope->notifyContextDestroyed();\n    m_workerGlobalScope = nullptr;\n\n    backingThread().removeTaskObserver(m_microtaskRunner.get());\n    backingThread().shutdown();\n    destroyIsolate();\n\n    m_microtaskRunner = nullptr;\n\n    workerReportingProxy().workerThreadTerminated();\n\n    m_terminationEvent->signal();\n\n    PlatformThreadData::current().destroy();\n}\n", "target": 0, "idx": 138517}
{"func": " static void fpm_child_init(struct fpm_worker_pool_s *wp) /* {{{ */\n {\n \tfpm_globals.max_requests = wp->config->pm_max_requests;\n \n \tif (0 > fpm_stdio_init_child(wp)  ||\n \t    0 > fpm_log_init_child(wp)    ||\n\t    0 > fpm_status_init_child(wp) ||\n\t    0 > fpm_unix_init_child(wp)   ||\n\t    0 > fpm_signals_init_child()  ||\n\t    0 > fpm_env_init_child(wp)    ||\n\t    0 > fpm_php_init_child(wp)) {\n\n\t\tzlog(ZLOG_ERROR, \"[pool %s] child failed to initialize\", wp->config->name);\n\t\texit(FPM_EXIT_SOFTWARE);\n\t}\n}\n/* }}} */\n", "target": 1, "idx": 182623}
{"func": "static int r_bin_mdmp_init(struct r_bin_mdmp_obj *obj) {\n\tr_bin_mdmp_init_parsing (obj);\n\n\tif (!r_bin_mdmp_init_hdr (obj)) {\n\t\teprintf (\"[ERROR] Failed to initialise header\\n\");\n\t\treturn false;\n\t}\n\n\tif (!r_bin_mdmp_init_directory (obj)) {\n\t\teprintf (\"[ERROR] Failed to initialise directory structures!\\n\");\n\t\treturn false;\n\t}\n\n\tif (!r_bin_mdmp_init_pe_bins (obj)) {\n\t\teprintf (\"[ERROR] Failed to initialise pe binaries!\\n\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n", "target": 0, "idx": 79707}
{"func": " void ImageBitmapFactories::ImageBitmapLoader::Trace(blink::Visitor* visitor) {\n   visitor->Trace(factory_);\n   visitor->Trace(resolver_);\n   visitor->Trace(options_);\n}\n", "target": 1, "idx": 187055}
{"func": "static int writeWepKeyRid(struct airo_info *ai, WepKeyRid *wkr, int perm, int lock)\n{\n\tint rc;\n\trc = PC4500_writerid(ai, RID_WEP_TEMP, wkr, sizeof(*wkr), lock);\n\tif (rc!=SUCCESS)\n\t\tairo_print_err(ai->dev->name, \"WEP_TEMP set %x\", rc);\n\tif (perm) {\n\t\trc = PC4500_writerid(ai, RID_WEP_PERM, wkr, sizeof(*wkr), lock);\n\t\tif (rc!=SUCCESS)\n\t\t\tairo_print_err(ai->dev->name, \"WEP_PERM set %x\", rc);\n\t}\n\treturn rc;\n}\n", "target": 0, "idx": 24094}
{"func": "R_API void r_core_cmd_init(RCore *core) {\n\tstruct {\n\t\tconst char *cmd;\n\t\tconst char *description;\n\t\tr_cmd_callback (cb);\n\t\tvoid (*descriptor_init)(RCore *core);\n\t} cmds[] = {\n\t\t{\"!\",        \"run system command\", cmd_system},\n\t\t{\"_\",        \"print last output\", cmd_last},\n\t\t{\"#\",        \"calculate hash\", cmd_hash},\n\t\t{\"$\",        \"alias\", cmd_alias},\n\t\t{\"%\",        \"short version of 'env' command\", cmd_env},\n\t\t{\"&\",        \"tasks\", cmd_tasks},\n\t\t{\"(\",        \"macro\", cmd_macro, cmd_macro_init},\n\t\t{\"*\",        \"pointer read/write\", cmd_pointer},\n\t\t{\"-\",        \"open cfg.editor and run script\", cmd_stdin},\n\t\t{\".\",        \"interpret\", cmd_interpret},\n\t\t{\"/\",        \"search kw, pattern aes\", cmd_search, cmd_search_init},\n\t\t{\"=\",        \"io pipe\", cmd_rap},\n\t\t{\"?\",        \"help message\", cmd_help, cmd_help_init},\n\t\t{\"\\\\\",       \"alias for =!\", cmd_rap_run},\n\t\t{\"'\",        \"alias for =!\", cmd_rap_run},\n\t\t{\"0x\",       \"alias for s 0x\", cmd_ox},\n\t\t{\"analysis\", \"analysis\", cmd_anal, cmd_anal_init},\n\t\t{\"bsize\",    \"change block size\", cmd_bsize},\n\t\t{\"cmp\",      \"compare memory\", cmd_cmp, cmd_cmp_init},\n\t\t{\"Code\",     \"code metadata\", cmd_meta, cmd_meta_init},\n\t\t{\"debug\",    \"debugger operations\", cmd_debug, cmd_debug_init},\n\t\t{\"eval\",     \"evaluate configuration variable\", cmd_eval, cmd_eval_init},\n\t\t{\"flag\",     \"get/set flags\", cmd_flag, cmd_flag_init},\n\t\t{\"g\",        \"egg manipulation\", cmd_egg, cmd_egg_init},\n\t\t{\"info\",     \"get file info\", cmd_info, cmd_info_init},\n\t\t{\"kuery\",    \"perform sdb query\", cmd_kuery},\n\t\t{\"l\",       \"list files and directories\", cmd_ls},\n\t\t{\"join\",    \"join the contents of the two files\", cmd_join},\n\t\t{\"head\",    \"show the top n number of line in file\", cmd_head},\n\t\t{\"L\",        \"manage dynamically loaded plugins\", cmd_plugins},\n\t\t{\"mount\",    \"mount filesystem\", cmd_mount, cmd_mount_init},\n\t\t{\"open\",     \"open or map file\", cmd_open, cmd_open_init},\n\t\t{\"print\",    \"print current block\", cmd_print, cmd_print_init},\n\t\t{\"Project\",  \"project\", cmd_project, cmd_project_init},\n\t\t{\"quit\",     \"exit program session\", cmd_quit, cmd_quit_init},\n\t\t{\"Q\",        \"alias for q!\", cmd_Quit},\n\t\t{\":\",        \"long commands starting with :\", cmd_colon},\n\t\t{\"resize\",   \"change file size\", cmd_resize},\n\t\t{\"seek\",     \"seek to an offset\", cmd_seek, cmd_seek_init},\n\t\t{\"t\",        \"type information (cparse)\", cmd_type, cmd_type_init},\n\t\t{\"Text\",     \"Text log utility\", cmd_log, cmd_log_init},\n\t\t{\"u\",        \"uname/undo\", cmd_uname},\n\t\t{\"<\",        \"pipe into RCons.readChar\", cmd_pipein},\n\t\t{\"Visual\",   \"enter visual mode\", cmd_visual},\n\t\t{\"visualPanels\",   \"enter visual mode\", cmd_panels},\n\t\t{\"write\",    \"write bytes\", cmd_write, cmd_write_init},\n\t\t{\"x\",        \"alias for px\", cmd_hexdump},\n\t\t{\"yank\",     \"yank bytes\", cmd_yank},\n\t\t{\"zign\",     \"zignatures\", cmd_zign, cmd_zign_init},\n\t};\n\n\tcore->rcmd = r_cmd_new ();\n\tcore->rcmd->macro.user = core;\n\tcore->rcmd->macro.num = core->num;\n\tcore->rcmd->macro.cmd = core_cmd0_wrapper;\n\tcore->rcmd->nullcallback = r_core_cmd_nullcallback;\n\tcore->rcmd->macro.cb_printf = (PrintfCallback)r_cons_printf;\n\tr_cmd_set_data (core->rcmd, core);\n\tcore->cmd_descriptors = r_list_newf (free);\n\tint i;\n\tfor (i = 0; i < R_ARRAY_SIZE (cmds); i++) {\n\t\tr_cmd_add (core->rcmd, cmds[i].cmd, cmds[i].description, cmds[i].cb);\n\t\tif (cmds[i].descriptor_init) {\n\t\t\tcmds[i].descriptor_init (core);\n\t\t}\n\t}\n\tDEFINE_CMD_DESCRIPTOR_SPECIAL (core, $, dollar);\n\tDEFINE_CMD_DESCRIPTOR_SPECIAL (core, %, percent);\n\tDEFINE_CMD_DESCRIPTOR_SPECIAL (core, *, star);\n\tDEFINE_CMD_DESCRIPTOR_SPECIAL (core, ., dot);\n\tDEFINE_CMD_DESCRIPTOR_SPECIAL (core, =, equal);\n\tDEFINE_CMD_DESCRIPTOR (core, b);\n\tDEFINE_CMD_DESCRIPTOR (core, k);\n\tDEFINE_CMD_DESCRIPTOR (core, r);\n\tDEFINE_CMD_DESCRIPTOR (core, u);\n\tDEFINE_CMD_DESCRIPTOR (core, y);\n\tcmd_descriptor_init (core);\n}\n", "target": 0, "idx": 87816}
{"func": "void ResourceMessageFilter::OnClipboardIsFormatAvailable(\n    Clipboard::FormatType format, Clipboard::Buffer buffer,\n    IPC::Message* reply) {\n  const bool result = GetClipboard()->IsFormatAvailable(format, buffer);\n  ViewHostMsg_ClipboardIsFormatAvailable::WriteReplyParams(reply, result);\n  Send(reply);\n}\n", "target": 0, "idx": 99276}
{"func": "WORD32 ih264d_cavlc_4x4res_block_totalcoeff_2to10(UWORD32 u4_isdc,\n                                               UWORD32 u4_total_coeff_trail_one, /*!<TotalCoefficients<<16+trailingones*/\n dec_bit_stream_t *ps_bitstrm)\n{\n    UWORD32 u4_total_zeroes;\n    WORD32 i;\n    UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;\n\n     UWORD32 u4_bitstream_offset = ps_bitstrm->u4_ofst;\n     UWORD32 u4_trailing_ones = u4_total_coeff_trail_one & 0xFFFF;\n     UWORD32 u4_total_coeff = u4_total_coeff_trail_one >> 16;\n    WORD16 i2_level_arr[16];\n \n     tu_sblk4x4_coeff_data_t *ps_tu_4x4;\n     WORD16 *pi2_coeff_data;\n dec_struct_t *ps_dec = (dec_struct_t *)ps_bitstrm->pv_codec_handle;\n\n    ps_tu_4x4 = (tu_sblk4x4_coeff_data_t *)ps_dec->pv_parse_tu_coeff_data;\n    ps_tu_4x4->u2_sig_coeff_map = 0;\n    pi2_coeff_data = &ps_tu_4x4->ai2_level[0];\n\n    i = u4_total_coeff - 1;\n\n if(u4_trailing_ones)\n {\n /*********************************************************************/\n /* Decode Trailing Ones                                              */\n /* read the sign of T1's and put them in level array                 */\n /*********************************************************************/\n        UWORD32 u4_signs, u4_cnt = u4_trailing_ones;\n        WORD16 (*ppi2_trlone_lkup)[3] =\n (WORD16 (*)[3])gai2_ih264d_trailing_one_level;\n        WORD16 *pi2_trlone_lkup;\n\n        GETBITS(u4_signs, u4_bitstream_offset, pu4_bitstrm_buf, u4_cnt);\n\n        pi2_trlone_lkup = ppi2_trlone_lkup[(1 << u4_cnt) - 2 + u4_signs];\n\n while(u4_cnt--)\n            i2_level_arr[i--] = *pi2_trlone_lkup++;\n }\n\n /****************************************************************/\n /* Decoding Levels Begins                                       */\n /****************************************************************/\n if(i >= 0)\n {\n /****************************************************************/\n /* First level is decoded outside the loop as it has lot of     */\n /* special cases.                                               */\n /****************************************************************/\n        UWORD32 u4_lev_suffix, u4_suffix_len, u4_lev_suffix_size;\n        WORD32 u2_lev_code, u2_abs_value;\n        UWORD32 u4_lev_prefix;\n\n /***************************************************************/\n /* u4_suffix_len = 0,  Find leading zeros in next 32 bits      */\n /***************************************************************/\n        FIND_ONE_IN_STREAM_32(u4_lev_prefix, u4_bitstream_offset,\n                              pu4_bitstrm_buf);\n\n /*********************************************************/\n /* Special decoding case when trailing ones are 3        */\n /*********************************************************/\n        u2_lev_code = MIN(15, u4_lev_prefix);\n\n        u2_lev_code += (3 == u4_trailing_ones) ? 0 : 2;\n\n if(14 == u4_lev_prefix)\n            u4_lev_suffix_size = 4;\n else if(15 <= u4_lev_prefix)\n {\n            u2_lev_code += 15;\n            u4_lev_suffix_size = u4_lev_prefix - 3;\n }\n else\n            u4_lev_suffix_size = 0;\n\n if(16 <= u4_lev_prefix)\n {\n            u2_lev_code += ((1 << (u4_lev_prefix - 3)) - 4096);\n }\n if(u4_lev_suffix_size)\n {\n            GETBITS(u4_lev_suffix, u4_bitstream_offset, pu4_bitstrm_buf,\n                    u4_lev_suffix_size);\n            u2_lev_code += u4_lev_suffix;\n }\n\n        u2_abs_value = (u2_lev_code + 2) >> 1;\n /*********************************************************/\n /* If Level code is odd, level is negative else positive */\n /*********************************************************/\n        i2_level_arr[i--] = (u2_lev_code & 1) ? -u2_abs_value : u2_abs_value;\n\n        u4_suffix_len = (u2_abs_value > 3) ? 2 : 1;\n\n /*********************************************************/\n /* Now loop over the remaining levels                    */\n /*********************************************************/\n while(i >= 0)\n {\n\n /***************************************************************/\n /* Find leading zeros in next 32 bits                          */\n /***************************************************************/\n            FIND_ONE_IN_STREAM_32(u4_lev_prefix, u4_bitstream_offset,\n                                  pu4_bitstrm_buf);\n\n            u4_lev_suffix_size =\n (15 <= u4_lev_prefix) ?\n (u4_lev_prefix - 3) : u4_suffix_len;\n\n /*********************************************************/\n /* Compute level code using prefix and suffix            */\n /*********************************************************/\n            GETBITS(u4_lev_suffix, u4_bitstream_offset, pu4_bitstrm_buf,\n                    u4_lev_suffix_size);\n            u2_lev_code = (MIN(15,u4_lev_prefix) << u4_suffix_len)\n + u4_lev_suffix;\n\n if(16 <= u4_lev_prefix)\n {\n                u2_lev_code += ((1 << (u4_lev_prefix - 3)) - 4096);\n }\n            u2_abs_value = (u2_lev_code + 2) >> 1;\n\n /*********************************************************/\n /* If Level code is odd, level is negative else positive */\n /*********************************************************/\n            i2_level_arr[i--] =\n (u2_lev_code & 1) ? -u2_abs_value : u2_abs_value;\n\n /*********************************************************/\n /* Increment suffix length if required                   */\n /*********************************************************/\n            u4_suffix_len +=\n (u4_suffix_len < 6) ?\n (u2_abs_value\n > (3\n << (u4_suffix_len\n - 1))) :\n 0;\n }\n\n /****************************************************************/\n /* Decoding Levels Ends                                         */\n /****************************************************************/\n }\n\n /****************************************************************/\n /* Decoding total zeros as in section 9.2.3, table 9.7          */\n /****************************************************************/\n {\n        UWORD32 u4_index;\n const UWORD8 (*ppu1_total_zero_lkup)[64] =\n (const UWORD8 (*)[64])gau1_ih264d_table_total_zero_2to10;\n\n        NEXTBITS(u4_index, u4_bitstream_offset, pu4_bitstrm_buf, 6);\n        u4_total_zeroes = ppu1_total_zero_lkup[u4_total_coeff - 2][u4_index];\n\n        FLUSHBITS(u4_bitstream_offset, (u4_total_zeroes >> 4));\n        u4_total_zeroes &= 0xf;\n }\n\n /**************************************************************/\n /* Decode the runs and form the coefficient buffer            */\n /**************************************************************/\n {\n const UWORD8 *pu1_table_runbefore;\n        UWORD32 u4_run;\n        WORD32 k;\n        UWORD32 u4_scan_pos = u4_total_coeff + u4_total_zeroes - 1 + u4_isdc;\n        WORD32 u4_zeroes_left = u4_total_zeroes;\n        k = u4_total_coeff - 1;\n\n /**************************************************************/\n /* Decoding Runs Begin for zeros left > 6                     */\n /**************************************************************/\n while((u4_zeroes_left > 6) && k)\n {\n            UWORD32 u4_code;\n\n            NEXTBITS(u4_code, u4_bitstream_offset, pu4_bitstrm_buf, 3);\n\n if(u4_code != 0)\n {\n                FLUSHBITS(u4_bitstream_offset, 3);\n                u4_run = (7 - u4_code);\n }\n else\n {\n\n                FIND_ONE_IN_STREAM_LEN(u4_code, u4_bitstream_offset,\n                                       pu4_bitstrm_buf, 11);\n                u4_run = (4 + u4_code);\n }\n\n            SET_BIT(ps_tu_4x4->u2_sig_coeff_map, u4_scan_pos);\n *pi2_coeff_data++ = i2_level_arr[k--];\n            u4_zeroes_left -= u4_run;\n            u4_scan_pos -= (u4_run + 1);\n }\n\n /**************************************************************/\n /* Decoding Runs for 0 < zeros left <=6                       */\n /**************************************************************/\n        pu1_table_runbefore = (UWORD8 *)gau1_ih264d_table_run_before;\n while((u4_zeroes_left > 0) && k)\n {\n            UWORD32 u4_code;\n            NEXTBITS(u4_code, u4_bitstream_offset, pu4_bitstrm_buf, 3);\n\n            u4_code = pu1_table_runbefore[u4_code + (u4_zeroes_left << 3)];\n            u4_run = u4_code >> 2;\n\n            FLUSHBITS(u4_bitstream_offset, (u4_code & 0x03));\n\n            SET_BIT(ps_tu_4x4->u2_sig_coeff_map, u4_scan_pos);\n *pi2_coeff_data++ = i2_level_arr[k--];\n            u4_zeroes_left -= u4_run;\n            u4_scan_pos -= (u4_run + 1);\n }\n /**************************************************************/\n /* Decoding Runs End                                          */\n /**************************************************************/\n\n /**************************************************************/\n /* Copy the remaining coefficients                            */\n /**************************************************************/\n if(u4_zeroes_left < 0)\n return -1;\n while(k >= 0)\n {\n\n            SET_BIT(ps_tu_4x4->u2_sig_coeff_map, u4_scan_pos);\n *pi2_coeff_data++ = i2_level_arr[k--];\n            u4_scan_pos--;\n }\n }\n\n {\n        WORD32 offset;\n        offset = (UWORD8 *)pi2_coeff_data - (UWORD8 *)ps_tu_4x4;\n        offset = ALIGN4(offset);\n        ps_dec->pv_parse_tu_coeff_data = (void *)((UWORD8 *)ps_dec->pv_parse_tu_coeff_data + offset);\n }\n\n    ps_bitstrm->u4_ofst = u4_bitstream_offset;\n return 0;\n}\n", "target": 1, "idx": 187936}
{"func": "void impeg2d_dec_hdr(void *pv_dec,impeg2d_video_decode_ip_t *ps_ip,\n impeg2d_video_decode_op_t *ps_op)\n{\n\n    UWORD32 u4_bits_read;\n dec_state_t *ps_dec;\n    UWORD32 u4_size = ps_ip->s_ivd_video_decode_ip_t.u4_num_Bytes;\n\n    ps_dec = (dec_state_t *)pv_dec;\n    ps_op->s_ivd_video_decode_op_t.u4_error_code = 0;\n if (u4_size > MAX_BITSTREAM_BUFFER_SIZE)\n {\n        u4_size = MAX_BITSTREAM_BUFFER_SIZE;\n }\n\n    memcpy(ps_dec->pu1_input_buffer, ps_ip->s_ivd_video_decode_ip_t.pv_stream_buffer, u4_size);\n\n    impeg2d_bit_stream_init(&(ps_dec->s_bit_stream), ps_dec->pu1_input_buffer,\n        u4_size);\n\n {\n {\n            IMPEG2D_ERROR_CODES_T e_error;\n            e_error = impeg2d_process_video_header(ps_dec);\n if ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE != e_error)\n {\n                ps_op->s_ivd_video_decode_op_t.u4_error_code    = e_error;\n\n                u4_bits_read     = impeg2d_bit_stream_num_bits_read(&ps_dec->s_bit_stream);\n\n                ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed = u4_bits_read>> 3;\n if(ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed > ps_ip->s_ivd_video_decode_ip_t.u4_num_Bytes)\n {\n                    ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed = ps_ip->s_ivd_video_decode_ip_t.u4_num_Bytes;\n }\n if(ps_op->s_ivd_video_decode_op_t.u4_error_code == 0)\n                    ps_op->s_ivd_video_decode_op_t.u4_error_code = e_error;\n\n if (IMPEG2D_UNSUPPORTED_DIMENSIONS == e_error)\n {\n                    ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed = 0;\n                    ps_dec->u2_header_done = 0;\n\n                    ps_op->s_ivd_video_decode_op_t.u4_pic_ht = ps_dec->u2_reinit_max_height;\n                    ps_op->s_ivd_video_decode_op_t.u4_pic_wd = ps_dec->u2_reinit_max_width;\n }\n                impeg2d_next_code(ps_dec, SEQUENCE_HEADER_CODE);\n return;\n }\n }\n        ps_op->s_ivd_video_decode_op_t.u4_pic_ht = ps_dec->u2_vertical_size;\n        ps_op->s_ivd_video_decode_op_t.u4_pic_wd = ps_dec->u2_horizontal_size;\n\n        ps_op->s_ivd_video_decode_op_t.e_pic_type            = IV_NA_FRAME;\n        ps_op->s_ivd_video_decode_op_t.u4_error_code        = IV_SUCCESS;\n\n        u4_bits_read     = impeg2d_bit_stream_num_bits_read(&ps_dec->s_bit_stream);\n        ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed = u4_bits_read>> 3;\n if(ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed > ps_ip->s_ivd_video_decode_ip_t.u4_num_Bytes)\n {\n\n             ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed = ps_ip->s_ivd_video_decode_ip_t.u4_num_Bytes;\n         }\n         ps_op->s_ivd_video_decode_op_t.u4_frame_decoded_flag = 0;\n         /* MOD */\n         ps_dec->u2_header_done = 1;\n \n }\n}\n", "target": 1, "idx": 188108}
{"func": "  virtual void SetUpCommandLine(CommandLine* command_line) {\n    GpuFeatureTest::SetUpCommandLine(command_line);\n    command_line->AppendSwitch(switches::kDisableExperimentalWebGL);\n  }\n", "target": 0, "idx": 114726}
{"func": "status_t IPCThreadState::requestDeathNotification(int32_t handle, BpBinder* proxy)\n{\n    mOut.writeInt32(BC_REQUEST_DEATH_NOTIFICATION);\n    mOut.writeInt32((int32_t)handle);\n    mOut.writePointer((uintptr_t)proxy);\n return NO_ERROR;\n}\n", "target": 0, "idx": 174330}
{"func": " virtual void ResetModel() {\n    last_pts_ = 0;\n    bits_in_buffer_model_ = cfg_.rc_target_bitrate * cfg_.rc_buf_initial_sz;\n    frame_number_ = 0;\n\n     tot_frame_number_ = 0;\n     first_drop_ = 0;\n     num_drops_ = 0;\n     for (int i = 0; i < 3; ++i) {\n       bits_total_[i] = 0;\n     }\n   }\n", "target": 1, "idx": 188540}
{"func": "BGD_DECLARE(gdImagePtr) gdImageCropThreshold(gdImagePtr im, const unsigned int color, const float threshold)\n{\n\tconst int width = gdImageSX(im);\n\tconst int height = gdImageSY(im);\n\n\tint x,y;\n\tint match;\n\tgdRect crop;\n\n\tcrop.x = 0;\n\tcrop.y = 0;\n\tcrop.width = 0;\n\tcrop.height = 0;\n\n\t/* Pierre: crop everything sounds bad */\n\tif (threshold > 100.0) {\n \t\treturn NULL;\n \t}\n \n \t/* TODO: Add gdImageGetRowPtr and works with ptr at the row level\n \t * for the true color and palette images\n \t * new formats will simply work with ptr\n\t */\n\tmatch = 1;\n\tfor (y = 0; match && y < height; y++) {\n\t\tfor (x = 0; match && x < width; x++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\n\t/* Pierre\n\t * Nothing to do > bye\n\t * Duplicate the image?\n\t */\n\tif (y == height - 1) {\n\t\treturn NULL;\n\t}\n\n\tcrop.y = y -1;\n\tmatch = 1;\n\tfor (y = height - 1; match && y >= 0; y--) {\n\t\tfor (x = 0; match && x < width; x++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x, y), threshold)) > 0;\n\t\t}\n\t}\n\n\tif (y == 0) {\n\t\tcrop.height = height - crop.y + 1;\n\t} else {\n\t\tcrop.height = y - crop.y + 2;\n\t}\n\n\tmatch = 1;\n\tfor (x = 0; match && x < width; x++) {\n\t\tfor (y = 0; match && y < crop.y + crop.height - 1; y++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\tcrop.x = x - 1;\n\n\tmatch = 1;\n\tfor (x = width - 1; match && x >= 0; x--) {\n\t\tfor (y = 0; match &&  y < crop.y + crop.height - 1; y++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\tcrop.width = x - crop.x + 2;\n\n\treturn gdImageCrop(im, &crop);\n}\n", "target": 1, "idx": 183116}
{"func": "WebPreferences RenderViewHostDelegateHelper::GetWebkitPrefs(\n    PrefService* prefs, bool is_dom_ui) {\n\n  WebPreferences web_prefs;\n\n  web_prefs.fixed_font_family =\n      prefs->GetString(prefs::kWebKitFixedFontFamily);\n  web_prefs.serif_font_family =\n      prefs->GetString(prefs::kWebKitSerifFontFamily);\n  web_prefs.sans_serif_font_family =\n      prefs->GetString(prefs::kWebKitSansSerifFontFamily);\n  if (prefs->GetBoolean(prefs::kWebKitStandardFontIsSerif))\n    web_prefs.standard_font_family = web_prefs.serif_font_family;\n  else\n    web_prefs.standard_font_family = web_prefs.sans_serif_font_family;\n  web_prefs.cursive_font_family =\n      prefs->GetString(prefs::kWebKitCursiveFontFamily);\n  web_prefs.fantasy_font_family =\n      prefs->GetString(prefs::kWebKitFantasyFontFamily);\n\n  web_prefs.default_font_size =\n      prefs->GetInteger(prefs::kWebKitDefaultFontSize);\n  web_prefs.default_fixed_font_size =\n      prefs->GetInteger(prefs::kWebKitDefaultFixedFontSize);\n  web_prefs.minimum_font_size =\n      prefs->GetInteger(prefs::kWebKitMinimumFontSize);\n  web_prefs.minimum_logical_font_size =\n      prefs->GetInteger(prefs::kWebKitMinimumLogicalFontSize);\n\n  web_prefs.default_encoding =\n      WideToASCII(prefs->GetString(prefs::kDefaultCharset));\n\n  web_prefs.javascript_can_open_windows_automatically =\n      prefs->GetBoolean(prefs::kWebKitJavascriptCanOpenWindowsAutomatically);\n  web_prefs.dom_paste_enabled =\n      prefs->GetBoolean(prefs::kWebKitDomPasteEnabled);\n  web_prefs.shrinks_standalone_images_to_fit =\n      prefs->GetBoolean(prefs::kWebKitShrinksStandaloneImagesToFit);\n  web_prefs.inspector_settings = WideToUTF8(\n      prefs->GetString(prefs::kWebKitInspectorSettings));\n\n  {  // Command line switches are used for preferences with no user interface.\n    const CommandLine& command_line = *CommandLine::ForCurrentProcess();\n    web_prefs.developer_extras_enabled =\n        !command_line.HasSwitch(switches::kDisableDevTools);\n    web_prefs.javascript_enabled =\n        !command_line.HasSwitch(switches::kDisableJavaScript) &&\n        prefs->GetBoolean(prefs::kWebKitJavascriptEnabled);\n    web_prefs.web_security_enabled =\n        !command_line.HasSwitch(switches::kDisableWebSecurity) &&\n        prefs->GetBoolean(prefs::kWebKitWebSecurityEnabled);\n    web_prefs.plugins_enabled =\n        !command_line.HasSwitch(switches::kDisablePlugins) &&\n        prefs->GetBoolean(prefs::kWebKitPluginsEnabled);\n    web_prefs.java_enabled =\n        !command_line.HasSwitch(switches::kDisableJava) &&\n        prefs->GetBoolean(prefs::kWebKitJavaEnabled);\n    web_prefs.loads_images_automatically =\n        !command_line.HasSwitch(switches::kDisableImages) &&\n        prefs->GetBoolean(prefs::kWebKitLoadsImagesAutomatically);\n    web_prefs.uses_page_cache =\n        command_line.HasSwitch(switches::kEnableFastback);\n    web_prefs.remote_fonts_enabled =\n        command_line.HasSwitch(switches::kEnableRemoteFonts);\n    web_prefs.xss_auditor_enabled =\n        !command_line.HasSwitch(switches::kDisableXSSAuditor);\n    web_prefs.application_cache_enabled =\n        command_line.HasSwitch(switches::kEnableApplicationCache);\n\n    web_prefs.local_storage_enabled =\n      command_line.HasSwitch(switches::kEnableLocalStorage);\n    web_prefs.databases_enabled =\n      command_line.HasSwitch(switches::kEnableDatabases);\n    web_prefs.session_storage_enabled =\n       command_line.HasSwitch(switches::kEnableSessionStorage);\n     web_prefs.experimental_webgl_enabled =\n       command_line.HasSwitch(switches::kEnableExperimentalWebGL);\n    web_prefs.experimental_notifications_enabled =\n      command_line.HasSwitch(switches::kEnableDesktopNotifications);\n   }\n \n   web_prefs.uses_universal_detector =\n      prefs->GetBoolean(prefs::kWebKitUsesUniversalDetector);\n  web_prefs.text_areas_are_resizable =\n      prefs->GetBoolean(prefs::kWebKitTextAreasAreResizable);\n\n\n  web_prefs.default_encoding =\n      CharacterEncoding::GetCanonicalEncodingNameByAliasName(\n          web_prefs.default_encoding);\n  if (web_prefs.default_encoding.empty()) {\n    prefs->ClearPref(prefs::kDefaultCharset);\n    web_prefs.default_encoding = WideToASCII(\n        prefs->GetString(prefs::kDefaultCharset));\n  }\n  DCHECK(!web_prefs.default_encoding.empty());\n\n  if (is_dom_ui) {\n    web_prefs.loads_images_automatically = true;\n    web_prefs.javascript_enabled = true;\n  }\n\n  return web_prefs;\n}\n", "target": 1, "idx": 183618}
{"func": "  bool focused() const { return focused_; }\n", "target": 0, "idx": 150746}
{"func": " Blob::Blob(PassOwnPtr<BlobData> blobData, long long size)\n    : m_type(blobData->contentType())\n    , m_size(size)\n{\n    ASSERT(blobData);\n    ScriptWrappable::init(this);\n \n     m_internalURL = BlobURL::createInternalURL();\n    ThreadableBlobRegistry::registerBlobURL(m_internalURL, blobData);\n }\n", "target": 1, "idx": 184249}
{"func": "  void SetMetrics(OomInterventionMetrics metrics) {\n    metrics_ = std::make_unique<OomInterventionMetrics>();\n    *metrics_ = metrics;\n  }\n", "target": 0, "idx": 143594}
{"func": "  int64 host_quota() const { return host_quota_; }\n", "target": 0, "idx": 108549}
{"func": "EncodedJSValue JSC_HOST_CALL JSTestObjConstructor::constructJSTestObj(ExecState* exec)\n {\n     JSTestObjConstructor* castedThis = jsCast<JSTestObjConstructor*>(exec->callee());\n     if (exec->argumentCount() < 1)\n        return throwVMError(exec, createTypeError(exec, \"Not enough arguments\"));\n     if (exec->argumentCount() <= 0 || !exec->argument(0).isFunction()) {\n         setDOMException(exec, TYPE_MISMATCH_ERR);\n         return JSValue::encode(jsUndefined());\n    }\n    RefPtr<TestCallback> testCallback = JSTestCallback::create(asObject(exec->argument(0)), castedThis->globalObject());\n    RefPtr<TestObj> object = TestObj::create(testCallback);\n    return JSValue::encode(asObject(toJS(exec, castedThis->globalObject(), object.get())));\n}\n", "target": 1, "idx": 184035}
{"func": "static void _close_pgsql_plink(zend_rsrc_list_entry *rsrc TSRMLS_DC)\n{\n\tPGconn *link = (PGconn *)rsrc->ptr;\n\tPGresult *res;\n\n\twhile ((res = PQgetResult(link))) {\n\t\tPQclear(res);\n\t}\n\tPQfinish(link);\n\tPGG(num_persistent)--;\n\tPGG(num_links)--;\n}\n", "target": 0, "idx": 14772}
{"func": "BrowserInit::LaunchWithProfile::~LaunchWithProfile() {\n}\n", "target": 0, "idx": 117672}
{"func": "void TextIterator::handleTextNodeFirstLetter(RenderTextFragment* renderer)\n{\n    if (renderer->firstLetter()) {\n        RenderObject* r = renderer->firstLetter();\n        if (r->style()->visibility() != VISIBLE && !m_ignoresStyleVisibility)\n            return;\n        if (RenderText* firstLetter = firstRenderTextInFirstLetter(r)) {\n            m_handledFirstLetter = true;\n            m_remainingTextBox = m_textBox;\n            m_textBox = firstLetter->firstTextBox();\n            m_sortedTextBoxes.clear();\n            m_firstLetterText = firstLetter;\n        }\n    }\n    m_handledFirstLetter = true;\n}\n", "target": 0, "idx": 121606}
{"func": "int MSG_ReadBits( msg_t *msg, int bits ) {\n\tint\t\t\tvalue;\n\tint\t\t\tget;\n\tqboolean\tsgn;\n \tint\t\t\ti, nbits;\n \n \tvalue = 0;\n \n \tif ( bits < 0 ) {\n\t\tbits = -bits;\n\t\tsgn = qtrue;\n\t} else {\n\t\tsgn = qfalse;\n \t}\n \n \tif (msg->oob) {\n \t\tif(bits==8)\n \t\t{\n \t\t\tvalue = msg->data[msg->readcount];\n\t\t\tmsg->readcount += 1;\n\t\t\tmsg->bit += 8;\n\t\t}\n\t\telse if(bits==16)\n\t\t{\n\t\t\tshort temp;\n\t\t\t\n\t\t\tCopyLittleShort(&temp, &msg->data[msg->readcount]);\n\t\t\tvalue = temp;\n\t\t\tmsg->readcount += 2;\n\t\t\tmsg->bit += 16;\n\t\t}\n\t\telse if(bits==32)\n\t\t{\n\t\t\tCopyLittleLong(&value, &msg->data[msg->readcount]);\n\t\t\tmsg->readcount += 4;\n\t\t\tmsg->bit += 32;\n\t\t}\n\t\telse\n\t\t\tCom_Error(ERR_DROP, \"can't read %d bits\", bits);\n\t} else {\n \t\tnbits = 0;\n \t\tif (bits&7) {\n \t\t\tnbits = bits&7;\n \t\t\tfor(i=0;i<nbits;i++) {\n \t\t\t\tvalue |= (Huff_getBit(msg->data, &msg->bit)<<i);\n \t\t\t}\n\t\t\tbits = bits - nbits;\n\t\t}\n \t\tif (bits) {\n \t\t\tfor(i=0;i<bits;i+=8) {\n\t\t\t\tHuff_offsetReceive (msgHuff.decompressor.tree, &get, msg->data, &msg->bit);\n \t\t\t\tvalue |= (get<<(i+nbits));\n \t\t\t}\n \t\t}\n\t\tmsg->readcount = (msg->bit>>3)+1;\n\t}\n\tif ( sgn && bits > 0 && bits < 32 ) {\n\t\tif ( value & ( 1 << ( bits - 1 ) ) ) {\n\t\t\tvalue |= -1 ^ ( ( 1 << bits ) - 1 );\n\t\t}\n\t}\n\n\treturn value;\n}\n", "target": 1, "idx": 181170}
{"func": " SPL_METHOD(SplFileObject, getMaxLineLen)\n {\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n\n\tRETURN_LONG((long)intern->u.file.max_line_len);\n} /* }}} */\n\n/* {{{ proto bool SplFileObject::hasChildren()\n", "target": 1, "idx": 180231}
{"func": "pgp_free_blob(pgp_blob_t *blob)\n{\n\tif (blob) {\n\t\tif (blob->parent) {\n\t\t\tpgp_blob_t **p;\n\n\t\t\t/* remove blob from list of parent's children */\n\t\t\tfor (p = &blob->parent->files; *p != NULL && *p != blob; p = &(*p)->next)\n\t\t\t\t;\n\t\t\tif (*p == blob)\n\t\t\t\t*p = blob->next;\n\t\t}\n\n\t\tsc_file_free(blob->file);\n\t\tif (blob->data)\n\t\t\tfree(blob->data);\n\t\tfree(blob);\n\t}\n}\n", "target": 0, "idx": 78585}
{"func": "int rds_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,\n\t\tsize_t size, int msg_flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rds_sock *rs = rds_sk_to_rs(sk);\n\tlong timeo;\n\tint ret = 0, nonblock = msg_flags & MSG_DONTWAIT;\n\tstruct sockaddr_in *sin;\n\tstruct rds_incoming *inc = NULL;\n\n\t/* udp_recvmsg()->sock_recvtimeo() gets away without locking too.. */\n\ttimeo = sock_rcvtimeo(sk, nonblock);\n \n \trdsdebug(\"size %zu flags 0x%x timeo %ld\\n\", size, msg_flags, timeo);\n \n \tif (msg_flags & MSG_OOB)\n \t\tgoto out;\n \n\twhile (1) {\n\t\t/* If there are pending notifications, do those - and nothing else */\n\t\tif (!list_empty(&rs->rs_notify_queue)) {\n\t\t\tret = rds_notify_queue_get(rs, msg);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rs->rs_cong_notify) {\n\t\t\tret = rds_notify_cong(rs, msg);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!rds_next_incoming(rs, &inc)) {\n\t\t\tif (nonblock) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ttimeo = wait_event_interruptible_timeout(*sk_sleep(sk),\n\t\t\t\t\t(!list_empty(&rs->rs_notify_queue) ||\n\t\t\t\t\t rs->rs_cong_notify ||\n\t\t\t\t\t rds_next_incoming(rs, &inc)), timeo);\n\t\t\trdsdebug(\"recvmsg woke inc %p timeo %ld\\n\", inc,\n\t\t\t\t timeo);\n\t\t\tif (timeo > 0 || timeo == MAX_SCHEDULE_TIMEOUT)\n\t\t\t\tcontinue;\n\n\t\t\tret = timeo;\n\t\t\tif (ret == 0)\n\t\t\t\tret = -ETIMEDOUT;\n\t\t\tbreak;\n\t\t}\n\n\t\trdsdebug(\"copying inc %p from %pI4:%u to user\\n\", inc,\n\t\t\t &inc->i_conn->c_faddr,\n\t\t\t ntohs(inc->i_hdr.h_sport));\n\t\tret = inc->i_conn->c_trans->inc_copy_to_user(inc, msg->msg_iov,\n\t\t\t\t\t\t\t     size);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * if the message we just copied isn't at the head of the\n\t\t * recv queue then someone else raced us to return it, try\n\t\t * to get the next message.\n\t\t */\n\t\tif (!rds_still_queued(rs, inc, !(msg_flags & MSG_PEEK))) {\n\t\t\trds_inc_put(inc);\n\t\t\tinc = NULL;\n\t\t\trds_stats_inc(s_recv_deliver_raced);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ret < be32_to_cpu(inc->i_hdr.h_len)) {\n\t\t\tif (msg_flags & MSG_TRUNC)\n\t\t\t\tret = be32_to_cpu(inc->i_hdr.h_len);\n\t\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\t}\n\n\t\tif (rds_cmsg_recv(inc, msg)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\trds_stats_inc(s_recv_delivered);\n\n\t\tsin = (struct sockaddr_in *)msg->msg_name;\n\t\tif (sin) {\n\t\t\tsin->sin_family = AF_INET;\n \t\t\tsin->sin_port = inc->i_hdr.h_sport;\n \t\t\tsin->sin_addr.s_addr = inc->i_saddr;\n \t\t\tmemset(sin->sin_zero, 0, sizeof(sin->sin_zero));\n \t\t}\n \t\tbreak;\n \t}\n\n\tif (inc)\n\t\trds_inc_put(inc);\n\nout:\n\treturn ret;\n}\n", "target": 1, "idx": 178755}
{"func": "static void kgdb_hw_overflow_handler(struct perf_event *event, int nmi,\n \t\tstruct perf_sample_data *data, struct pt_regs *regs)\n {\n \tstruct task_struct *tsk = current;\n\tint i;\n\n\tfor (i = 0; i < 4; i++)\n\t\tif (breakinfo[i].enabled)\n\t\t\ttsk->thread.debugreg6 |= (DR_TRAP0 << i);\n}\n", "target": 1, "idx": 178995}
{"func": "static void reflectUnsignedShortAttributeAttributeSetterCallback(v8::Local<v8::String>, v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)\n{\n    TRACE_EVENT_SET_SAMPLING_STATE(\"Blink\", \"DOMSetter\");\n    CustomElementCallbackDispatcher::CallbackDeliveryScope deliveryScope;\n    TestObjectPythonV8Internal::reflectUnsignedShortAttributeAttributeSetter(jsValue, info);\n    TRACE_EVENT_SET_SAMPLING_STATE(\"V8\", \"V8Execution\");\n}\n", "target": 0, "idx": 131673}
{"func": "static int command_read(struct pci_dev *dev, int offset, u16 *value, void *data)\n {\n\tint i;\n\tint ret;\n\tret = xen_pcibk_read_config_word(dev, offset, value, data);\n\tif (!pci_is_enabled(dev))\n\t\treturn ret;\n\tfor (i = 0; i < PCI_ROM_RESOURCE; i++) {\n\t\tif (dev->resource[i].flags & IORESOURCE_IO)\n\t\t\t*value |= PCI_COMMAND_IO;\n\t\tif (dev->resource[i].flags & IORESOURCE_MEM)\n\t\t\t*value |= PCI_COMMAND_MEMORY;\n \t}\n \n \treturn ret;\n }\n", "target": 1, "idx": 179854}
{"func": "_zip_cdir_new(int nentry, struct zip_error *error)\n{\n    struct zip_cdir *cd;\n    \n    if ((cd=(struct zip_cdir *)malloc(sizeof(*cd))) == NULL) {\n\t_zip_error_set(error, ZIP_ER_MEMORY, 0);\n        return NULL;\n     }\n \n    if ((cd->entry=(struct zip_dirent *)malloc(sizeof(*(cd->entry))*nentry))\n        == NULL) {\n        _zip_error_set(error, ZIP_ER_MEMORY, 0);\n        free(cd);\n\treturn NULL;\n    }\n\n    /* entries must be initialized by caller */\n\n    cd->nentry = nentry;\n    cd->size = cd->offset = 0;\n    cd->comment = NULL;\n    cd->comment_len = 0;\n\n    return cd;\n}\n", "target": 1, "idx": 177924}
{"func": "xmlParseConditionalSections(xmlParserCtxtPtr ctxt) {\n    int id = ctxt->input->id;\n\n    SKIP(3);\n    SKIP_BLANKS;\n    if (CMP7(CUR_PTR, 'I', 'N', 'C', 'L', 'U', 'D', 'E')) {\n\tSKIP(7);\n\tSKIP_BLANKS;\n\tif (RAW != '[') {\n\t    xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID, NULL);\n\t} else {\n\t    if (ctxt->input->id != id) {\n\t\txmlValidityError(ctxt, XML_ERR_ENTITY_BOUNDARY,\n\t    \"All markup of the conditional section is not in the same entity\\n\",\n\t\t\t\t     NULL, NULL);\n\t    }\n\t    NEXT;\n\t}\n\tif (xmlParserDebugEntities) {\n\t    if ((ctxt->input != NULL) && (ctxt->input->filename))\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"%s(%d): \", ctxt->input->filename,\n\t\t\tctxt->input->line);\n\t    xmlGenericError(xmlGenericErrorContext,\n \t\t    \"Entering INCLUDE Conditional Section\\n\");\n \t}\n \n\twhile ((RAW != 0) && ((RAW != ']') || (NXT(1) != ']') ||\n\t       (NXT(2) != '>'))) {\n \t    const xmlChar *check = CUR_PTR;\n \t    unsigned int cons = ctxt->input->consumed;\n \n\t    if ((RAW == '<') && (NXT(1) == '!') && (NXT(2) == '[')) {\n\t\txmlParseConditionalSections(ctxt);\n\t    } else if (IS_BLANK_CH(CUR)) {\n\t\tNEXT;\n\t    } else if (RAW == '%') {\n\t\txmlParsePEReference(ctxt);\n\t    } else\n\t\txmlParseMarkupDecl(ctxt);\n\n\t    /*\n\t     * Pop-up of finished entities.\n\t     */\n\t    while ((RAW == 0) && (ctxt->inputNr > 1))\n\t\txmlPopInput(ctxt);\n\n\t    if ((CUR_PTR == check) && (cons == ctxt->input->consumed)) {\n\t\txmlFatalErr(ctxt, XML_ERR_EXT_SUBSET_NOT_FINISHED, NULL);\n\t\tbreak;\n\t    }\n\t}\n\tif (xmlParserDebugEntities) {\n\t    if ((ctxt->input != NULL) && (ctxt->input->filename))\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"%s(%d): \", ctxt->input->filename,\n\t\t\tctxt->input->line);\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"Leaving INCLUDE Conditional Section\\n\");\n\t}\n\n    } else if (CMP6(CUR_PTR, 'I', 'G', 'N', 'O', 'R', 'E')) {\n\tint state;\n\txmlParserInputState instate;\n\tint depth = 0;\n\n\tSKIP(6);\n\tSKIP_BLANKS;\n\tif (RAW != '[') {\n\t    xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID, NULL);\n\t} else {\n\t    if (ctxt->input->id != id) {\n\t\txmlValidityError(ctxt, XML_ERR_ENTITY_BOUNDARY,\n\t    \"All markup of the conditional section is not in the same entity\\n\",\n\t\t\t\t     NULL, NULL);\n\t    }\n\t    NEXT;\n\t}\n\tif (xmlParserDebugEntities) {\n\t    if ((ctxt->input != NULL) && (ctxt->input->filename))\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"%s(%d): \", ctxt->input->filename,\n\t\t\tctxt->input->line);\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"Entering IGNORE Conditional Section\\n\");\n\t}\n\n\t/*\n\t * Parse up to the end of the conditional section\n\t * But disable SAX event generating DTD building in the meantime\n\t */\n\tstate = ctxt->disableSAX;\n\tinstate = ctxt->instate;\n \tif (ctxt->recovery == 0) ctxt->disableSAX = 1;\n \tctxt->instate = XML_PARSER_IGNORE;\n \n\twhile ((depth >= 0) && (RAW != 0)) {\n \t  if ((RAW == '<') && (NXT(1) == '!') && (NXT(2) == '[')) {\n \t    depth++;\n \t    SKIP(3);\n\t    continue;\n\t  }\n\t  if ((RAW == ']') && (NXT(1) == ']') && (NXT(2) == '>')) {\n\t    if (--depth >= 0) SKIP(3);\n\t    continue;\n\t  }\n\t  NEXT;\n\t  continue;\n\t}\n\n\tctxt->disableSAX = state;\n\tctxt->instate = instate;\n\n\tif (xmlParserDebugEntities) {\n\t    if ((ctxt->input != NULL) && (ctxt->input->filename))\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"%s(%d): \", ctxt->input->filename,\n\t\t\tctxt->input->line);\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"Leaving IGNORE Conditional Section\\n\");\n\t}\n\n    } else {\n\txmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID_KEYWORD, NULL);\n    }\n\n    if (RAW == 0)\n        SHRINK;\n\n    if (RAW == 0) {\n\txmlFatalErr(ctxt, XML_ERR_CONDSEC_NOT_FINISHED, NULL);\n    } else {\n\tif (ctxt->input->id != id) {\n\t    xmlValidityError(ctxt, XML_ERR_ENTITY_BOUNDARY,\n\t\"All markup of the conditional section is not in the same entity\\n\",\n\t\t\t\t NULL, NULL);\n\t}\n        SKIP(3);\n    }\n}\n", "target": 1, "idx": 184972}
{"func": "    LRUCanvasResourceProviderCache(wtf_size_t capacity)\n    : resource_providers_(capacity) {}\n", "target": 0, "idx": 154963}
{"func": "bgp_attr_print(netdissect_options *ndo,\n               u_int atype, const u_char *pptr, u_int len)\n{\n\tint i;\n\tuint16_t af;\n\tuint8_t safi, snpa, nhlen;\n        union { /* copy buffer for bandwidth values */\n            float f;\n            uint32_t i;\n        } bw;\n\tint advance;\n\tu_int tlen;\n\tconst u_char *tptr;\n\tchar buf[MAXHOSTNAMELEN + 100];\n        int  as_size;\n\n        tptr = pptr;\n        tlen=len;\n\n\tswitch (atype) {\n\tcase BGPTYPE_ORIGIN:\n\t\tif (len != 1)\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\telse {\n\t\t\tND_TCHECK(*tptr);\n\t\t\tND_PRINT((ndo, \"%s\", tok2str(bgp_origin_values,\n\t\t\t\t\t\t\"Unknown Origin Typecode\",\n\t\t\t\t\t\ttptr[0])));\n\t\t}\n\t\tbreak;\n\n        /*\n         * Process AS4 byte path and AS2 byte path attributes here.\n         */\n\tcase BGPTYPE_AS4_PATH:\n\tcase BGPTYPE_AS_PATH:\n\t\tif (len % 2) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n                if (!len) {\n\t\t\tND_PRINT((ndo, \"empty\"));\n\t\t\tbreak;\n                }\n\n                /*\n                 * BGP updates exchanged between New speakers that support 4\n                 * byte AS, ASs are always encoded in 4 bytes. There is no\n                 * definitive way to find this, just by the packet's\n                 * contents. So, check for packet's TLV's sanity assuming\n                 * 2 bytes first, and it does not pass, assume that ASs are\n                 * encoded in 4 bytes format and move on.\n                 */\n                as_size = bgp_attr_get_as_size(ndo, atype, pptr, len);\n\n\t\twhile (tptr < pptr + len) {\n\t\t\tND_TCHECK(tptr[0]);\n                        ND_PRINT((ndo, \"%s\", tok2str(bgp_as_path_segment_open_values,\n\t\t\t\t\t\t\"?\", tptr[0])));\n\t\t\tND_TCHECK(tptr[1]);\n                        for (i = 0; i < tptr[1] * as_size; i += as_size) {\n                            ND_TCHECK2(tptr[2 + i], as_size);\n\t\t\t    ND_PRINT((ndo, \"%s \",\n\t\t\t\tas_printf(ndo, astostr, sizeof(astostr),\n\t\t\t\tas_size == 2 ?\n\t\t\t\tEXTRACT_16BITS(&tptr[2 + i]) :\n\t\t\t\tEXTRACT_32BITS(&tptr[2 + i]))));\n                        }\n\t\t\tND_TCHECK(tptr[0]);\n                        ND_PRINT((ndo, \"%s\", tok2str(bgp_as_path_segment_close_values,\n\t\t\t\t\t\t\"?\", tptr[0])));\n                        ND_TCHECK(tptr[1]);\n                        tptr += 2 + tptr[1] * as_size;\n\t\t}\n\t\tbreak;\n\tcase BGPTYPE_NEXT_HOP:\n\t\tif (len != 4)\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\telse {\n\t\t\tND_TCHECK2(tptr[0], 4);\n\t\t\tND_PRINT((ndo, \"%s\", ipaddr_string(ndo, tptr)));\n\t\t}\n\t\tbreak;\n\tcase BGPTYPE_MULTI_EXIT_DISC:\n\tcase BGPTYPE_LOCAL_PREF:\n\t\tif (len != 4)\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\telse {\n\t\t\tND_TCHECK2(tptr[0], 4);\n\t\t\tND_PRINT((ndo, \"%u\", EXTRACT_32BITS(tptr)));\n\t\t}\n\t\tbreak;\n\tcase BGPTYPE_ATOMIC_AGGREGATE:\n\t\tif (len != 0)\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\tbreak;\n        case BGPTYPE_AGGREGATOR:\n\n                /*\n                 * Depending on the AS encoded is of 2 bytes or of 4 bytes,\n                 * the length of this PA can be either 6 bytes or 8 bytes.\n                 */\n                if (len != 6 && len != 8) {\n                    ND_PRINT((ndo, \"invalid len\"));\n                    break;\n                }\n                ND_TCHECK2(tptr[0], len);\n                if (len == 6) {\n\t\t    ND_PRINT((ndo, \" AS #%s, origin %s\",\n\t\t\tas_printf(ndo, astostr, sizeof(astostr), EXTRACT_16BITS(tptr)),\n\t\t\tipaddr_string(ndo, tptr + 2)));\n                } else {\n\t\t    ND_PRINT((ndo, \" AS #%s, origin %s\",\n\t\t\tas_printf(ndo, astostr, sizeof(astostr),\n\t\t\tEXTRACT_32BITS(tptr)), ipaddr_string(ndo, tptr + 4)));\n                }\n                break;\n\tcase BGPTYPE_AGGREGATOR4:\n\t\tif (len != 8) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n\t\tND_TCHECK2(tptr[0], 8);\n\t\tND_PRINT((ndo, \" AS #%s, origin %s\",\n\t   \t    as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(tptr)),\n\t\t    ipaddr_string(ndo, tptr + 4)));\n\t\tbreak;\n\tcase BGPTYPE_COMMUNITIES:\n\t\tif (len % 4) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n\t\twhile (tlen>0) {\n\t\t\tuint32_t comm;\n\t\t\tND_TCHECK2(tptr[0], 4);\n\t\t\tcomm = EXTRACT_32BITS(tptr);\n\t\t\tswitch (comm) {\n\t\t\tcase BGP_COMMUNITY_NO_EXPORT:\n\t\t\t\tND_PRINT((ndo, \" NO_EXPORT\"));\n\t\t\t\tbreak;\n\t\t\tcase BGP_COMMUNITY_NO_ADVERT:\n\t\t\t\tND_PRINT((ndo, \" NO_ADVERTISE\"));\n\t\t\t\tbreak;\n\t\t\tcase BGP_COMMUNITY_NO_EXPORT_SUBCONFED:\n\t\t\t\tND_PRINT((ndo, \" NO_EXPORT_SUBCONFED\"));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tND_PRINT((ndo, \"%u:%u%s\",\n                                       (comm >> 16) & 0xffff,\n                                       comm & 0xffff,\n                                       (tlen>4) ? \", \" : \"\"));\n\t\t\t\tbreak;\n\t\t\t}\n                        tlen -=4;\n                        tptr +=4;\n\t\t}\n\t\tbreak;\n        case BGPTYPE_ORIGINATOR_ID:\n\t\tif (len != 4) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n\t\tND_TCHECK2(tptr[0], 4);\n                ND_PRINT((ndo, \"%s\",ipaddr_string(ndo, tptr)));\n                break;\n        case BGPTYPE_CLUSTER_LIST:\n\t\tif (len % 4) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n                while (tlen>0) {\n\t\t\tND_TCHECK2(tptr[0], 4);\n                        ND_PRINT((ndo, \"%s%s\",\n                               ipaddr_string(ndo, tptr),\n                                (tlen>4) ? \", \" : \"\"));\n                        tlen -=4;\n                        tptr +=4;\n                }\n                break;\n\tcase BGPTYPE_MP_REACH_NLRI:\n\t\tND_TCHECK2(tptr[0], 3);\n\t\taf = EXTRACT_16BITS(tptr);\n\t\tsafi = tptr[2];\n\n                ND_PRINT((ndo, \"\\n\\t    AFI: %s (%u), %sSAFI: %s (%u)\",\n                       tok2str(af_values, \"Unknown AFI\", af),\n                       af,\n                       (safi>128) ? \"vendor specific \" : \"\", /* 128 is meanwhile wellknown */\n                       tok2str(bgp_safi_values, \"Unknown SAFI\", safi),\n                       safi));\n\n                switch(af<<8 | safi) {\n                case (AFNUM_INET<<8 | SAFNUM_UNICAST):\n                case (AFNUM_INET<<8 | SAFNUM_MULTICAST):\n                case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):\n                case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):\n                case (AFNUM_INET<<8 | SAFNUM_RT_ROUTING_INFO):\n                case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):\n                case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):\n                case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):\n                case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN):\n\t\tcase (AFNUM_INET<<8 | SAFNUM_MDT):\n                case (AFNUM_INET6<<8 | SAFNUM_UNICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):\n                case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):\n                case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):\n                case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):\n                case (AFNUM_VPLS<<8 | SAFNUM_VPLS):\n                    break;\n                default:\n                    ND_TCHECK2(tptr[0], tlen);\n                    ND_PRINT((ndo, \"\\n\\t    no AFI %u / SAFI %u decoder\", af, safi));\n                    if (ndo->ndo_vflag <= 1)\n                        print_unknown_data(ndo, tptr, \"\\n\\t    \", tlen);\n                    goto done;\n                    break;\n                }\n\n                tptr +=3;\n\n\t\tND_TCHECK(tptr[0]);\n\t\tnhlen = tptr[0];\n                tlen = nhlen;\n                tptr++;\n\n\t\tif (tlen) {\n                    int nnh = 0;\n                    ND_PRINT((ndo, \"\\n\\t    nexthop: \"));\n                    while (tlen > 0) {\n                        if ( nnh++ > 0 ) {\n                            ND_PRINT((ndo,  \", \" ));\n                        }\n                        switch(af<<8 | safi) {\n                        case (AFNUM_INET<<8 | SAFNUM_UNICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_MULTICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_RT_ROUTING_INFO):\n                        case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN):\n                        case (AFNUM_INET<<8 | SAFNUM_MDT):\n\t\t\t    if (tlen < (int)sizeof(struct in_addr)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in_addr));\n                                ND_PRINT((ndo, \"%s\",ipaddr_string(ndo, tptr)));\n                                tlen -= sizeof(struct in_addr);\n                                tptr += sizeof(struct in_addr);\n                            }\n                            break;\n                        case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):\n                            if (tlen < (int)(sizeof(struct in_addr)+BGP_VPN_RD_LEN)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in_addr)+BGP_VPN_RD_LEN);\n                                ND_PRINT((ndo, \"RD: %s, %s\",\n                                       bgp_vpn_rd_print(ndo, tptr),\n                                       ipaddr_string(ndo, tptr+BGP_VPN_RD_LEN)));\n                                tlen -= (sizeof(struct in_addr)+BGP_VPN_RD_LEN);\n                                tptr += (sizeof(struct in_addr)+BGP_VPN_RD_LEN);\n                            }\n                            break;\n                        case (AFNUM_INET6<<8 | SAFNUM_UNICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):\n                            if (tlen < (int)sizeof(struct in6_addr)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in6_addr));\n                                ND_PRINT((ndo, \"%s\", ip6addr_string(ndo, tptr)));\n                                tlen -= sizeof(struct in6_addr);\n                                tptr += sizeof(struct in6_addr);\n                            }\n                            break;\n                        case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):\n                            if (tlen < (int)(sizeof(struct in6_addr)+BGP_VPN_RD_LEN)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in6_addr)+BGP_VPN_RD_LEN);\n                                ND_PRINT((ndo, \"RD: %s, %s\",\n                                       bgp_vpn_rd_print(ndo, tptr),\n                                       ip6addr_string(ndo, tptr+BGP_VPN_RD_LEN)));\n                                tlen -= (sizeof(struct in6_addr)+BGP_VPN_RD_LEN);\n                                tptr += (sizeof(struct in6_addr)+BGP_VPN_RD_LEN);\n                            }\n                            break;\n                        case (AFNUM_VPLS<<8 | SAFNUM_VPLS):\n                        case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):\n                        case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):\n                        case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):\n                            if (tlen < (int)sizeof(struct in_addr)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in_addr));\n                                ND_PRINT((ndo, \"%s\", ipaddr_string(ndo, tptr)));\n                                tlen -= (sizeof(struct in_addr));\n                                tptr += (sizeof(struct in_addr));\n                            }\n                            break;\n                        case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):\n                        case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):\n                        case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):\n                            ND_TCHECK2(tptr[0], tlen);\n                            ND_PRINT((ndo, \"%s\", isonsap_string(ndo, tptr, tlen)));\n                            tptr += tlen;\n                            tlen = 0;\n                            break;\n\n                        case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):\n                        case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):\n                        case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):\n                            if (tlen < BGP_VPN_RD_LEN+1) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], tlen);\n                                ND_PRINT((ndo, \"RD: %s, %s\",\n                                       bgp_vpn_rd_print(ndo, tptr),\n                                       isonsap_string(ndo, tptr+BGP_VPN_RD_LEN,tlen-BGP_VPN_RD_LEN)));\n                                /* rfc986 mapped IPv4 address ? */\n                                if (EXTRACT_32BITS(tptr+BGP_VPN_RD_LEN) ==  0x47000601)\n                                    ND_PRINT((ndo, \" = %s\", ipaddr_string(ndo, tptr+BGP_VPN_RD_LEN+4)));\n                                /* rfc1888 mapped IPv6 address ? */\n                                else if (EXTRACT_24BITS(tptr+BGP_VPN_RD_LEN) ==  0x350000)\n                                    ND_PRINT((ndo, \" = %s\", ip6addr_string(ndo, tptr+BGP_VPN_RD_LEN+3)));\n                                tptr += tlen;\n                                tlen = 0;\n                            }\n                            break;\n                        default:\n                            ND_TCHECK2(tptr[0], tlen);\n                            ND_PRINT((ndo, \"no AFI %u/SAFI %u decoder\", af, safi));\n                            if (ndo->ndo_vflag <= 1)\n                                print_unknown_data(ndo, tptr, \"\\n\\t    \", tlen);\n                            tptr += tlen;\n                            tlen = 0;\n                            goto done;\n                            break;\n                        }\n                    }\n\t\t}\n\t\tND_PRINT((ndo, \", nh-length: %u\", nhlen));\n\t\ttptr += tlen;\n\n\t\tND_TCHECK(tptr[0]);\n\t\tsnpa = tptr[0];\n\t\ttptr++;\n\n\t\tif (snpa) {\n\t\t\tND_PRINT((ndo, \"\\n\\t    %u SNPA\", snpa));\n\t\t\tfor (/*nothing*/; snpa > 0; snpa--) {\n\t\t\t\tND_TCHECK(tptr[0]);\n\t\t\t\tND_PRINT((ndo, \"\\n\\t      %d bytes\", tptr[0]));\n\t\t\t\ttptr += tptr[0] + 1;\n\t\t\t}\n\t\t} else {\n\t\t\tND_PRINT((ndo, \", no SNPA\"));\n                }\n\n\t\twhile (tptr < pptr + len) {\n                    switch (af<<8 | safi) {\n                    case (AFNUM_INET<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_prefix4(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):\n                        advance = decode_labeled_prefix4(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_prefix4(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_RT_ROUTING_INFO):\n                        advance = decode_rt_routing_info(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN): /* fall through */\n                    case (AFNUM_INET6<<8 | SAFNUM_MULTICAST_VPN):\n                        advance = decode_multicast_vpn(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n\n\t\t    case (AFNUM_INET<<8 | SAFNUM_MDT):\n\t\t      advance = decode_mdt_vpn_nlri(ndo, tptr, buf, sizeof(buf));\n\t\t      if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n\t\t       break;\n                    case (AFNUM_INET6<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_prefix6(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):\n                        advance = decode_labeled_prefix6(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_prefix6(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_VPLS<<8 | SAFNUM_VPLS):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_l2(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_clnp_prefix(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_clnp_prefix(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    default:\n                        ND_TCHECK2(*tptr,tlen);\n                        ND_PRINT((ndo, \"\\n\\t    no AFI %u / SAFI %u decoder\", af, safi));\n                        if (ndo->ndo_vflag <= 1)\n                            print_unknown_data(ndo, tptr, \"\\n\\t    \", tlen);\n                        advance = 0;\n                        tptr = pptr + len;\n                        break;\n                    }\n                    if (advance < 0)\n                        break;\n                    tptr += advance;\n\t\t}\n        done:\n\t\tbreak;\n\n\tcase BGPTYPE_MP_UNREACH_NLRI:\n\t\tND_TCHECK2(tptr[0], BGP_MP_NLRI_MINSIZE);\n\t\taf = EXTRACT_16BITS(tptr);\n\t\tsafi = tptr[2];\n\n                ND_PRINT((ndo, \"\\n\\t    AFI: %s (%u), %sSAFI: %s (%u)\",\n                       tok2str(af_values, \"Unknown AFI\", af),\n                       af,\n                       (safi>128) ? \"vendor specific \" : \"\", /* 128 is meanwhile wellknown */\n                       tok2str(bgp_safi_values, \"Unknown SAFI\", safi),\n                       safi));\n\n                if (len == BGP_MP_NLRI_MINSIZE)\n                    ND_PRINT((ndo, \"\\n\\t      End-of-Rib Marker (empty NLRI)\"));\n\n\t\ttptr += 3;\n\n\t\twhile (tptr < pptr + len) {\n                    switch (af<<8 | safi) {\n                    case (AFNUM_INET<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_prefix4(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):\n                        advance = decode_labeled_prefix4(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_prefix4(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_prefix6(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):\n                        advance = decode_labeled_prefix6(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_prefix6(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_VPLS<<8 | SAFNUM_VPLS):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_l2(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_clnp_prefix(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_clnp_prefix(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n\t\t    case (AFNUM_INET<<8 | SAFNUM_MDT):\n\t\t      advance = decode_mdt_vpn_nlri(ndo, tptr, buf, sizeof(buf));\n\t\t      if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n\t\t       break;\n                    case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN): /* fall through */\n                    case (AFNUM_INET6<<8 | SAFNUM_MULTICAST_VPN):\n                        advance = decode_multicast_vpn(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    default:\n                        ND_TCHECK2(*(tptr-3),tlen);\n                        ND_PRINT((ndo, \"no AFI %u / SAFI %u decoder\", af, safi));\n                        if (ndo->ndo_vflag <= 1)\n                            print_unknown_data(ndo, tptr-3, \"\\n\\t    \", tlen);\n                        advance = 0;\n                        tptr = pptr + len;\n                        break;\n                    }\n                    if (advance < 0)\n                        break;\n                    tptr += advance;\n\t\t}\n\t\tbreak;\n        case BGPTYPE_EXTD_COMMUNITIES:\n\t\tif (len % 8) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n                while (tlen>0) {\n                    uint16_t extd_comm;\n\n                    ND_TCHECK2(tptr[0], 2);\n                    extd_comm=EXTRACT_16BITS(tptr);\n\n\t\t    ND_PRINT((ndo, \"\\n\\t    %s (0x%04x), Flags [%s]\",\n\t\t\t   tok2str(bgp_extd_comm_subtype_values,\n\t\t\t\t      \"unknown extd community typecode\",\n\t\t\t\t      extd_comm),\n\t\t\t   extd_comm,\n\t\t\t   bittok2str(bgp_extd_comm_flag_values, \"none\", extd_comm)));\n\n                    ND_TCHECK2(*(tptr+2), 6);\n                    switch(extd_comm) {\n                    case BGP_EXT_COM_RT_0:\n                    case BGP_EXT_COM_RO_0:\n                    case BGP_EXT_COM_L2VPN_RT_0:\n                        ND_PRINT((ndo, \": %u:%u (= %s)\",\n                               EXTRACT_16BITS(tptr+2),\n                               EXTRACT_32BITS(tptr+4),\n                               ipaddr_string(ndo, tptr+4)));\n                        break;\n                    case BGP_EXT_COM_RT_1:\n                    case BGP_EXT_COM_RO_1:\n                    case BGP_EXT_COM_L2VPN_RT_1:\n                    case BGP_EXT_COM_VRF_RT_IMP:\n                        ND_PRINT((ndo, \": %s:%u\",\n                               ipaddr_string(ndo, tptr+2),\n                               EXTRACT_16BITS(tptr+6)));\n                        break;\n                    case BGP_EXT_COM_RT_2:\n                    case BGP_EXT_COM_RO_2:\n\t\t\tND_PRINT((ndo, \": %s:%u\",\n\t\t\t    as_printf(ndo, astostr, sizeof(astostr),\n\t\t\t    EXTRACT_32BITS(tptr+2)), EXTRACT_16BITS(tptr+6)));\n\t\t\tbreak;\n                    case BGP_EXT_COM_LINKBAND:\n\t\t        bw.i = EXTRACT_32BITS(tptr+2);\n                        ND_PRINT((ndo, \": bandwidth: %.3f Mbps\",\n                               bw.f*8/1000000));\n                        break;\n                    case BGP_EXT_COM_VPN_ORIGIN:\n                    case BGP_EXT_COM_VPN_ORIGIN2:\n                    case BGP_EXT_COM_VPN_ORIGIN3:\n                    case BGP_EXT_COM_VPN_ORIGIN4:\n                    case BGP_EXT_COM_OSPF_RID:\n                    case BGP_EXT_COM_OSPF_RID2:\n                        ND_PRINT((ndo, \"%s\", ipaddr_string(ndo, tptr+2)));\n                        break;\n                    case BGP_EXT_COM_OSPF_RTYPE:\n                    case BGP_EXT_COM_OSPF_RTYPE2:\n                        ND_PRINT((ndo, \": area:%s, router-type:%s, metric-type:%s%s\",\n                               ipaddr_string(ndo, tptr+2),\n                               tok2str(bgp_extd_comm_ospf_rtype_values,\n\t\t\t\t\t  \"unknown (0x%02x)\",\n\t\t\t\t\t  *(tptr+6)),\n                               (*(tptr+7) &  BGP_OSPF_RTYPE_METRIC_TYPE) ? \"E2\" : \"\",\n                               ((*(tptr+6) == BGP_OSPF_RTYPE_EXT) || (*(tptr+6) == BGP_OSPF_RTYPE_NSSA)) ? \"E1\" : \"\"));\n                        break;\n                    case BGP_EXT_COM_L2INFO:\n                        ND_PRINT((ndo, \": %s Control Flags [0x%02x]:MTU %u\",\n                               tok2str(l2vpn_encaps_values,\n\t\t\t\t\t  \"unknown encaps\",\n\t\t\t\t\t  *(tptr+2)),\n                                       *(tptr+3),\n                               EXTRACT_16BITS(tptr+4)));\n                        break;\n                    case BGP_EXT_COM_SOURCE_AS:\n                        ND_PRINT((ndo, \": AS %u\", EXTRACT_16BITS(tptr+2)));\n                        break;\n                    default:\n                        ND_TCHECK2(*tptr,8);\n                        print_unknown_data(ndo, tptr, \"\\n\\t      \", 8);\n                        break;\n                    }\n                    tlen -=8;\n                    tptr +=8;\n                }\n                break;\n\n        case BGPTYPE_PMSI_TUNNEL:\n         {\n                 uint8_t tunnel_type, flags;\n \n                 tunnel_type = *(tptr+1);\n                 flags = *tptr;\n                 tlen = len;\n \n                ND_TCHECK2(tptr[0], 5);\n                 ND_PRINT((ndo, \"\\n\\t    Tunnel-type %s (%u), Flags [%s], MPLS Label %u\",\n                        tok2str(bgp_pmsi_tunnel_values, \"Unknown\", tunnel_type),\n                        tunnel_type,\n                       bittok2str(bgp_pmsi_flag_values, \"none\", flags),\n                       EXTRACT_24BITS(tptr+2)>>4));\n\n                tptr +=5;\n                tlen -= 5;\n\n                switch (tunnel_type) {\n                case BGP_PMSI_TUNNEL_PIM_SM: /* fall through */\n                case BGP_PMSI_TUNNEL_PIM_BIDIR:\n                    ND_TCHECK2(tptr[0], 8);\n                    ND_PRINT((ndo, \"\\n\\t      Sender %s, P-Group %s\",\n                           ipaddr_string(ndo, tptr),\n                           ipaddr_string(ndo, tptr+4)));\n                    break;\n\n                case BGP_PMSI_TUNNEL_PIM_SSM:\n                    ND_TCHECK2(tptr[0], 8);\n                    ND_PRINT((ndo, \"\\n\\t      Root-Node %s, P-Group %s\",\n                           ipaddr_string(ndo, tptr),\n                           ipaddr_string(ndo, tptr+4)));\n                    break;\n                case BGP_PMSI_TUNNEL_INGRESS:\n                    ND_TCHECK2(tptr[0], 4);\n                    ND_PRINT((ndo, \"\\n\\t      Tunnel-Endpoint %s\",\n                           ipaddr_string(ndo, tptr)));\n                    break;\n                case BGP_PMSI_TUNNEL_LDP_P2MP: /* fall through */\n                case BGP_PMSI_TUNNEL_LDP_MP2MP:\n                    ND_TCHECK2(tptr[0], 8);\n                    ND_PRINT((ndo, \"\\n\\t      Root-Node %s, LSP-ID 0x%08x\",\n                           ipaddr_string(ndo, tptr),\n                           EXTRACT_32BITS(tptr+4)));\n                    break;\n                case BGP_PMSI_TUNNEL_RSVP_P2MP:\n                    ND_TCHECK2(tptr[0], 8);\n                    ND_PRINT((ndo, \"\\n\\t      Extended-Tunnel-ID %s, P2MP-ID 0x%08x\",\n                           ipaddr_string(ndo, tptr),\n                           EXTRACT_32BITS(tptr+4)));\n                    break;\n                default:\n                    if (ndo->ndo_vflag <= 1) {\n                        print_unknown_data(ndo, tptr, \"\\n\\t      \", tlen);\n                    }\n                }\n                break;\n        }\n\tcase BGPTYPE_AIGP:\n\t{\n\t\tuint8_t type;\n\t\tuint16_t length;\n\n\t\ttlen = len;\n\n\t\twhile (tlen >= 3) {\n\n\t\t    ND_TCHECK2(tptr[0], 3);\n\n\t\t    type = *tptr;\n\t\t    length = EXTRACT_16BITS(tptr+1);\n\t\t    tptr += 3;\n\t\t    tlen -= 3;\n\n\t\t    ND_PRINT((ndo, \"\\n\\t    %s TLV (%u), length %u\",\n\t\t\t      tok2str(bgp_aigp_values, \"Unknown\", type),\n\t\t\t      type, length));\n\n\t\t    if (length < 3)\n\t\t\tgoto trunc;\n\t\t    length -= 3;\n\n\t\t    /*\n\t\t     * Check if we can read the TLV data.\n\t\t     */\n\t\t    ND_TCHECK2(tptr[3], length);\n\n\t\t    switch (type) {\n\n\t\t    case BGP_AIGP_TLV:\n\t\t        if (length < 8)\n\t\t            goto trunc;\n\t\t\tND_PRINT((ndo, \", metric %\" PRIu64,\n\t\t\t\t  EXTRACT_64BITS(tptr)));\n\t\t\tbreak;\n\n\t\t    default:\n\t\t\tif (ndo->ndo_vflag <= 1) {\n\t\t\t    print_unknown_data(ndo, tptr,\"\\n\\t      \", length);\n\t\t\t}\n\t\t    }\n\n\t\t    tptr += length;\n\t\t    tlen -= length;\n\t\t}\n\t\tbreak;\n\t}\n        case BGPTYPE_ATTR_SET:\n                ND_TCHECK2(tptr[0], 4);\n                if (len < 4)\n                \tgoto trunc;\n\t\tND_PRINT((ndo, \"\\n\\t    Origin AS: %s\",\n\t\t    as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(tptr))));\n\t\ttptr+=4;\n                len -=4;\n\n                while (len) {\n                    u_int aflags, alenlen, alen;\n\n                    ND_TCHECK2(tptr[0], 2);\n                    if (len < 2)\n                        goto trunc;\n                    aflags = *tptr;\n                    atype = *(tptr + 1);\n                    tptr += 2;\n                    len -= 2;\n                    alenlen = bgp_attr_lenlen(aflags, tptr);\n                    ND_TCHECK2(tptr[0], alenlen);\n                    if (len < alenlen)\n                        goto trunc;\n                    alen = bgp_attr_len(aflags, tptr);\n                    tptr += alenlen;\n                    len -= alenlen;\n\n                    ND_PRINT((ndo, \"\\n\\t      %s (%u), length: %u\",\n                           tok2str(bgp_attr_values,\n                                      \"Unknown Attribute\", atype),\n                           atype,\n                           alen));\n\n                    if (aflags) {\n                        ND_PRINT((ndo, \", Flags [%s%s%s%s\",\n                               aflags & 0x80 ? \"O\" : \"\",\n                               aflags & 0x40 ? \"T\" : \"\",\n                               aflags & 0x20 ? \"P\" : \"\",\n                               aflags & 0x10 ? \"E\" : \"\"));\n                        if (aflags & 0xf)\n                            ND_PRINT((ndo, \"+%x\", aflags & 0xf));\n                        ND_PRINT((ndo, \"]: \"));\n                    }\n                    /* FIXME check for recursion */\n                    if (!bgp_attr_print(ndo, atype, tptr, alen))\n                        return 0;\n                    tptr += alen;\n                    len -= alen;\n\t\t}\n                break;\n\n\tcase BGPTYPE_LARGE_COMMUNITY:\n\t\tif (len == 0 || len % 12) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n\t\tND_PRINT((ndo, \"\\n\\t    \"));\n\t\twhile (len > 0) {\n\t\t\tND_TCHECK2(*tptr, 12);\n\t\t\tND_PRINT((ndo, \"%u:%u:%u%s\",\n\t\t\t\t EXTRACT_32BITS(tptr),\n\t\t\t\t EXTRACT_32BITS(tptr + 4),\n\t\t\t\t EXTRACT_32BITS(tptr + 8),\n\t\t\t\t (len > 12) ? \", \" : \"\"));\n                        tptr += 12;\n                        len -= 12;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t    ND_TCHECK2(*pptr,len);\n            ND_PRINT((ndo, \"\\n\\t    no Attribute %u decoder\", atype)); /* we have no decoder for the attribute */\n            if (ndo->ndo_vflag <= 1)\n                print_unknown_data(ndo, pptr, \"\\n\\t    \", len);\n            break;\n\t}\n        if (ndo->ndo_vflag > 1 && len) { /* omit zero length attributes*/\n            ND_TCHECK2(*pptr,len);\n            print_unknown_data(ndo, pptr, \"\\n\\t    \", len);\n        }\n        return 1;\n\ntrunc:\n        return 0;\n}\n", "target": 1, "idx": 181001}
{"func": "static EAS_I16 ConvertLFOPhaseIncrement (EAS_I32 pitchCents)\n{\n\n /* check range */\n if (pitchCents > MAX_LFO_FREQUENCY_IN_PITCHCENTS)\n        pitchCents = MAX_LFO_FREQUENCY_IN_PITCHCENTS;\n if (pitchCents < MIN_LFO_FREQUENCY_IN_PITCHCENTS)\n        pitchCents = MIN_LFO_FREQUENCY_IN_PITCHCENTS;\n\n /* double the rate and divide by frame rate by subtracting in log domain */\n    pitchCents = pitchCents - dlsLFOFrequencyConvert;\n\n /* convert to phase increment */\n return (EAS_I16) EAS_Calculate2toX(pitchCents);\n}\n", "target": 0, "idx": 170677}
{"func": "static bool tailmatch(const char *little, const char *bigone)\n {\n  size_t littlelen = strlen(little);\n  size_t biglen = strlen(bigone);\n \n  if(littlelen > biglen)\n     return FALSE;\n \n  return Curl_raw_equal(little, bigone+biglen-littlelen) ? TRUE : FALSE;\n }\n", "target": 1, "idx": 179270}
{"func": "void vfio_pci_intx_mask(struct vfio_pci_device *vdev)\n{\n\tstruct pci_dev *pdev = vdev->pdev;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&vdev->irqlock, flags);\n\n\t/*\n\t * Masking can come from interrupt, ioctl, or config space\n\t * via INTx disable.  The latter means this can get called\n\t * even when not using intx delivery.  In this case, just\n\t * try to have the physical bit follow the virtual bit.\n\t */\n\tif (unlikely(!is_intx(vdev))) {\n\t\tif (vdev->pci_2_3)\n\t\t\tpci_intx(pdev, 0);\n\t} else if (!vdev->ctx[0].masked) {\n\t\t/*\n\t\t * Can't use check_and_mask here because we always want to\n\t\t * mask, not just when something is pending.\n\t\t */\n\t\tif (vdev->pci_2_3)\n\t\t\tpci_intx(pdev, 0);\n\t\telse\n\t\t\tdisable_irq_nosync(pdev->irq);\n\n\t\tvdev->ctx[0].masked = true;\n\t}\n\n\tspin_unlock_irqrestore(&vdev->irqlock, flags);\n}\n", "target": 0, "idx": 48617}
{"func": "void FrameLoader::Trace(blink::Visitor* visitor) {\n  visitor->Trace(frame_);\n   visitor->Trace(progress_tracker_);\n   visitor->Trace(document_loader_);\n   visitor->Trace(provisional_document_loader_);\n }\n", "target": 1, "idx": 187043}
{"func": "int dtls_get_message(SSL *s, int *mt, unsigned long *len)\n{\n    struct hm_header_st *msg_hdr;\n    unsigned char *p;\n    unsigned long msg_len;\n    int ok;\n    long tmplen;\n\n    msg_hdr = &s->d1->r_msg_hdr;\n    memset(msg_hdr, 0, sizeof(*msg_hdr));\n\n again:\n    ok = dtls_get_reassembled_message(s, &tmplen);\n    if (tmplen == DTLS1_HM_BAD_FRAGMENT || tmplen == DTLS1_HM_FRAGMENT_RETRY) {\n        /* bad fragment received */\n        goto again;\n    } else if (tmplen <= 0 && !ok) {\n        return 0;\n    }\n\n    *mt = s->s3->tmp.message_type;\n\n    p = (unsigned char *)s->init_buf->data;\n\n    if (*mt == SSL3_MT_CHANGE_CIPHER_SPEC) {\n        if (s->msg_callback) {\n            s->msg_callback(0, s->version, SSL3_RT_CHANGE_CIPHER_SPEC,\n                            p, 1, s, s->msg_callback_arg);\n        }\n        /*\n         * This isn't a real handshake message so skip the processing below.\n         */\n        *len = (unsigned long)tmplen;\n        return 1;\n    }\n\n    msg_len = msg_hdr->msg_len;\n\n    /* reconstruct message header */\n    *(p++) = msg_hdr->type;\n    l2n3(msg_len, p);\n    s2n(msg_hdr->seq, p);\n    l2n3(0, p);\n    l2n3(msg_len, p);\n    if (s->version != DTLS1_BAD_VER) {\n        p -= DTLS1_HM_HEADER_LENGTH;\n        msg_len += DTLS1_HM_HEADER_LENGTH;\n    }\n\n    if (!ssl3_finish_mac(s, p, msg_len))\n        return 0;\n    if (s->msg_callback)\n        s->msg_callback(0, s->version, SSL3_RT_HANDSHAKE,\n                        p, msg_len, s, s->msg_callback_arg);\n\n    memset(msg_hdr, 0, sizeof(*msg_hdr));\n\n    s->d1->handshake_read_seq++;\n\n    s->init_msg = s->init_buf->data + DTLS1_HM_HEADER_LENGTH;\n    *len = s->init_num;\n\n    return 1;\n}\n", "target": 0, "idx": 12715}
{"func": " static int omninet_open(struct tty_struct *tty, struct usb_serial_port *port)\n {\n\tstruct usb_serial\t*serial = port->serial;\n\tstruct usb_serial_port\t*wport;\n\twport = serial->port[1];\n\ttty_port_tty_set(&wport->port, tty);\n \treturn usb_serial_generic_open(tty, port);\n }\n", "target": 1, "idx": 181360}
{"func": "static void close_table_device(struct table_device *td, struct mapped_device *md)\n{\n\tif (!td->dm_dev.bdev)\n\t\treturn;\n\n\tbd_unlink_disk_holder(td->dm_dev.bdev, dm_disk(md));\n\tblkdev_put(td->dm_dev.bdev, td->dm_dev.mode | FMODE_EXCL);\n\tput_dax(td->dm_dev.dax_dev);\n\ttd->dm_dev.bdev = NULL;\n\ttd->dm_dev.dax_dev = NULL;\n}\n", "target": 0, "idx": 85863}
{"func": "MagickExport Image *ComplexImages(const Image *images,const ComplexOperator op,\n  ExceptionInfo *exception)\n{\n#define ComplexImageTag  \"Complex/Image\"\n\n  CacheView\n    *Ai_view,\n    *Ar_view,\n    *Bi_view,\n    *Br_view,\n    *Ci_view,\n    *Cr_view;\n\n  const char\n    *artifact;\n\n  const Image\n    *Ai_image,\n    *Ar_image,\n    *Bi_image,\n    *Br_image;\n\n  double\n    snr;\n\n  Image\n    *Ci_image,\n    *complex_images,\n    *Cr_image,\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  ssize_t\n    y;\n\n  assert(images != (Image *) NULL);\n  assert(images->signature == MagickCoreSignature);\n  if (images->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",images->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if (images->next == (Image *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ImageSequenceRequired\",\"`%s'\",images->filename);\n      return((Image *) NULL);\n    }\n  image=CloneImage(images,0,0,MagickTrue,exception);\n  if (image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return(image);\n    }\n  image->depth=32UL;\n  complex_images=NewImageList();\n  AppendImageToList(&complex_images,image);\n  image=CloneImage(images,0,0,MagickTrue,exception);\n  if (image == (Image *) NULL)\n    {\n      complex_images=DestroyImageList(complex_images);\n      return(complex_images);\n    }\n  AppendImageToList(&complex_images,image);\n  /*\n    Apply complex mathematics to image pixels.\n  */\n  artifact=GetImageArtifact(image,\"complex:snr\");\n  snr=0.0;\n  if (artifact != (const char *) NULL)\n    snr=StringToDouble(artifact,(char **) NULL);\n  Ar_image=images;\n  Ai_image=images->next;\n  Br_image=images;\n  Bi_image=images->next;\n  if ((images->next->next != (Image *) NULL) &&\n      (images->next->next->next != (Image *) NULL))\n    {\n      Br_image=images->next->next;\n      Bi_image=images->next->next->next;\n    }\n  Cr_image=complex_images;\n  Ci_image=complex_images->next;\n  Ar_view=AcquireVirtualCacheView(Ar_image,exception);\n  Ai_view=AcquireVirtualCacheView(Ai_image,exception);\n  Br_view=AcquireVirtualCacheView(Br_image,exception);\n  Bi_view=AcquireVirtualCacheView(Bi_image,exception);\n  Cr_view=AcquireAuthenticCacheView(Cr_image,exception);\n  Ci_view=AcquireAuthenticCacheView(Ci_image,exception);\n  status=MagickTrue;\n   progress=0;\n #if defined(MAGICKCORE_OPENMP_SUPPORT)\n   #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(images,complex_images,images->rows,1L)\n #endif\n  for (y=0; y < (ssize_t) images->rows; y++)\n   {\n     register const Quantum\n       *magick_restrict Ai,\n      *magick_restrict Ar,\n      *magick_restrict Bi,\n      *magick_restrict Br;\n\n    register Quantum\n      *magick_restrict Ci,\n      *magick_restrict Cr;\n\n    register ssize_t\n      x;\n \n     if (status == MagickFalse)\n       continue;\n    Ar=GetCacheViewVirtualPixels(Ar_view,0,y,\n      MagickMax(Ar_image->columns,Cr_image->columns),1,exception);\n    Ai=GetCacheViewVirtualPixels(Ai_view,0,y,\n      MagickMax(Ai_image->columns,Ci_image->columns),1,exception);\n    Br=GetCacheViewVirtualPixels(Br_view,0,y,\n      MagickMax(Br_image->columns,Cr_image->columns),1,exception);\n    Bi=GetCacheViewVirtualPixels(Bi_view,0,y,\n      MagickMax(Bi_image->columns,Ci_image->columns),1,exception);\n     Cr=QueueCacheViewAuthenticPixels(Cr_view,0,y,Cr_image->columns,1,exception);\n     Ci=QueueCacheViewAuthenticPixels(Ci_view,0,y,Ci_image->columns,1,exception);\n     if ((Ar == (const Quantum *) NULL) || (Ai == (const Quantum *) NULL) || \n        (Br == (const Quantum *) NULL) || (Bi == (const Quantum *) NULL) ||\n        (Cr == (Quantum *) NULL) || (Ci == (Quantum *) NULL))\n      {\n         status=MagickFalse;\n         continue;\n       }\n    for (x=0; x < (ssize_t) images->columns; x++)\n     {\n       register ssize_t\n         i;\n \n      for (i=0; i < (ssize_t) GetPixelChannels(images); i++)\n       {\n         switch (op)\n         {\n          case AddComplexOperator:\n          {\n            Cr[i]=Ar[i]+Br[i];\n            Ci[i]=Ai[i]+Bi[i];\n            break;\n          }\n          case ConjugateComplexOperator:\n          default:\n          {\n            Cr[i]=Ar[i];\n            Ci[i]=(-Bi[i]);\n            break;\n          }\n          case DivideComplexOperator:\n          {\n             double\n               gamma;\n \n            gamma=PerceptibleReciprocal(Br[i]*Br[i]+Bi[i]*Bi[i]+snr);\n            Cr[i]=gamma*(Ar[i]*Br[i]+Ai[i]*Bi[i]);\n            Ci[i]=gamma*(Ai[i]*Br[i]-Ar[i]*Bi[i]);\n             break;\n           }\n           case MagnitudePhaseComplexOperator:\n           {\n            Cr[i]=sqrt(Ar[i]*Ar[i]+Ai[i]*Ai[i]);\n            Ci[i]=atan2(Ai[i],Ar[i])/(2.0*MagickPI)+0.5;\n             break;\n           }\n           case MultiplyComplexOperator:\n           {\n            Cr[i]=QuantumScale*(Ar[i]*Br[i]-Ai[i]*Bi[i]);\n            Ci[i]=QuantumScale*(Ai[i]*Br[i]+Ar[i]*Bi[i]);\n             break;\n           }\n           case RealImaginaryComplexOperator:\n          {\n            Cr[i]=Ar[i]*cos(2.0*MagickPI*(Ai[i]-0.5));\n            Ci[i]=Ar[i]*sin(2.0*MagickPI*(Ai[i]-0.5));\n            break;\n          }\n          case SubtractComplexOperator:\n          {\n            Cr[i]=Ar[i]-Br[i];\n            Ci[i]=Ai[i]-Bi[i];\n            break;\n          }\n        }\n      }\n      Ar+=GetPixelChannels(Ar_image);\n      Ai+=GetPixelChannels(Ai_image);\n      Br+=GetPixelChannels(Br_image);\n      Bi+=GetPixelChannels(Bi_image);\n      Cr+=GetPixelChannels(Cr_image);\n      Ci+=GetPixelChannels(Ci_image);\n    }\n    if (SyncCacheViewAuthenticPixels(Ci_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (SyncCacheViewAuthenticPixels(Cr_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (images->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n#endif\n        progress++;\n        proceed=SetImageProgress(images,ComplexImageTag,progress,images->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  Cr_view=DestroyCacheView(Cr_view);\n  Ci_view=DestroyCacheView(Ci_view);\n  Br_view=DestroyCacheView(Br_view);\n  Bi_view=DestroyCacheView(Bi_view);\n  Ar_view=DestroyCacheView(Ar_view);\n  Ai_view=DestroyCacheView(Ai_view);\n  if (status == MagickFalse)\n    complex_images=DestroyImageList(complex_images);\n  return(complex_images);\n}\n", "target": 1, "idx": 183371}
{"func": "void DiceResponseHandler::DeleteTokenFetcher(DiceTokenFetcher* token_fetcher) {\n  for (auto it = token_fetchers_.begin(); it != token_fetchers_.end(); ++it) {\n    if (it->get() == token_fetcher) {\n      token_fetchers_.erase(it);\n      return;\n    }\n  }\n  NOTREACHED();\n}\n", "target": 0, "idx": 155778}
{"func": "cifs_mount(struct super_block *sb, struct cifs_sb_info *cifs_sb,\n\t\tchar *mount_data_global, const char *devname)\n{\n\tint rc;\n\tint xid;\n\tstruct smb_vol *volume_info;\n\tstruct cifsSesInfo *pSesInfo;\n\tstruct cifsTconInfo *tcon;\n\tstruct TCP_Server_Info *srvTcp;\n\tchar   *full_path;\n\tchar *mount_data = mount_data_global;\n\tstruct tcon_link *tlink;\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\tstruct dfs_info3_param *referrals = NULL;\n\tunsigned int num_referrals = 0;\n\tint referral_walks_count = 0;\ntry_mount_again:\n#endif\n\trc = 0;\n\ttcon = NULL;\n\tpSesInfo = NULL;\n\tsrvTcp = NULL;\n\tfull_path = NULL;\n\ttlink = NULL;\n\n\txid = GetXid();\n\n\tvolume_info = kzalloc(sizeof(struct smb_vol), GFP_KERNEL);\n\tif (!volume_info) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (cifs_parse_mount_options(mount_data, devname, volume_info)) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (volume_info->nullauth) {\n\t\tcFYI(1, \"null user\");\n\t\tvolume_info->username = \"\";\n\t} else if (volume_info->username) {\n\t\t/* BB fixme parse for domain name here */\n\t\tcFYI(1, \"Username: %s\", volume_info->username);\n\t} else {\n\t\tcifserror(\"No username specified\");\n\t/* In userspace mount helper we can get user name from alternate\n\t   locations such as env variables and files on disk */\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* this is needed for ASCII cp to Unicode converts */\n\tif (volume_info->iocharset == NULL) {\n\t\t/* load_nls_default cannot return null */\n\t\tvolume_info->local_nls = load_nls_default();\n\t} else {\n\t\tvolume_info->local_nls = load_nls(volume_info->iocharset);\n\t\tif (volume_info->local_nls == NULL) {\n\t\t\tcERROR(1, \"CIFS mount error: iocharset %s not found\",\n\t\t\t\t volume_info->iocharset);\n\t\t\trc = -ELIBACC;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tcifs_sb->local_nls = volume_info->local_nls;\n\n\t/* get a reference to a tcp session */\n\tsrvTcp = cifs_get_tcp_session(volume_info);\n\tif (IS_ERR(srvTcp)) {\n\t\trc = PTR_ERR(srvTcp);\n\t\tgoto out;\n\t}\n\n\t/* get a reference to a SMB session */\n\tpSesInfo = cifs_get_smb_ses(srvTcp, volume_info);\n\tif (IS_ERR(pSesInfo)) {\n\t\trc = PTR_ERR(pSesInfo);\n\t\tpSesInfo = NULL;\n\t\tgoto mount_fail_check;\n\t}\n\n\tsetup_cifs_sb(volume_info, cifs_sb);\n\tif (pSesInfo->capabilities & CAP_LARGE_FILES)\n\t\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\telse\n\t\tsb->s_maxbytes = MAX_NON_LFS;\n\n\t/* BB FIXME fix time_gran to be larger for LANMAN sessions */\n\tsb->s_time_gran = 100;\n\n\t/* search for existing tcon to this server share */\n\ttcon = cifs_get_tcon(pSesInfo, volume_info);\n\tif (IS_ERR(tcon)) {\n\t\trc = PTR_ERR(tcon);\n\t\ttcon = NULL;\n\t\tgoto remote_path_check;\n\t}\n\n\t/* do not care if following two calls succeed - informational */\n\tif (!tcon->ipc) {\n\t\tCIFSSMBQFSDeviceInfo(xid, tcon);\n\t\tCIFSSMBQFSAttributeInfo(xid, tcon);\n\t}\n\n\t/* tell server which Unix caps we support */\n\tif (tcon->ses->capabilities & CAP_UNIX)\n\t\t/* reset of caps checks mount to see if unix extensions\n\t\t   disabled for just this mount */\n\t\treset_cifs_unix_caps(xid, tcon, sb, volume_info);\n\telse\n\t\ttcon->unix_ext = 0; /* server does not support them */\n\n\t/* convert forward to back slashes in prepath here if needed */\n\tif ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) == 0)\n\t\tconvert_delimiter(cifs_sb->prepath, CIFS_DIR_SEP(cifs_sb));\n\n\tif ((tcon->unix_ext == 0) && (cifs_sb->rsize > (1024 * 127))) {\n\t\tcifs_sb->rsize = 1024 * 127;\n\t\tcFYI(DBG2, \"no very large read support, rsize now 127K\");\n\t}\n\tif (!(tcon->ses->capabilities & CAP_LARGE_WRITE_X))\n\t\tcifs_sb->wsize = min(cifs_sb->wsize,\n\t\t\t       (tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE));\n\tif (!(tcon->ses->capabilities & CAP_LARGE_READ_X))\n\t\tcifs_sb->rsize = min(cifs_sb->rsize,\n\t\t\t       (tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE));\n \n remote_path_check:\n \t/* check if a whole path (including prepath) is not remote */\n\tif (!rc && cifs_sb->prepathlen && tcon) {\n \t\t/* build_path_to_root works only when we have a valid tcon */\n \t\tfull_path = cifs_build_path_to_root(cifs_sb, tcon);\n \t\tif (full_path == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto mount_fail_check;\n\t\t}\n\t\trc = is_path_accessible(xid, tcon, cifs_sb, full_path);\n\t\tif (rc != 0 && rc != -EREMOTE) {\n\t\t\tkfree(full_path);\n\t\t\tgoto mount_fail_check;\n\t\t}\n\t\tkfree(full_path);\n\t}\n\n\t/* get referral if needed */\n\tif (rc == -EREMOTE) {\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\t\tif (referral_walks_count > MAX_NESTED_LINKS) {\n\t\t\t/*\n\t\t\t * BB: when we implement proper loop detection,\n\t\t\t *     we will remove this check. But now we need it\n\t\t\t *     to prevent an indefinite loop if 'DFS tree' is\n\t\t\t *     misconfigured (i.e. has loops).\n\t\t\t */\n\t\t\trc = -ELOOP;\n\t\t\tgoto mount_fail_check;\n\t\t}\n\t\t/* convert forward to back slashes in prepath here if needed */\n\t\tif ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) == 0)\n\t\t\tconvert_delimiter(cifs_sb->prepath,\n\t\t\t\t\tCIFS_DIR_SEP(cifs_sb));\n\t\tfull_path = build_unc_path_to_root(volume_info, cifs_sb);\n\t\tif (IS_ERR(full_path)) {\n\t\t\trc = PTR_ERR(full_path);\n\t\t\tgoto mount_fail_check;\n\t\t}\n\n\t\tcFYI(1, \"Getting referral for: %s\", full_path);\n\t\trc = get_dfs_path(xid, pSesInfo , full_path + 1,\n\t\t\tcifs_sb->local_nls, &num_referrals, &referrals,\n\t\t\tcifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR);\n\t\tif (!rc && num_referrals > 0) {\n\t\t\tchar *fake_devname = NULL;\n\n\t\t\tif (mount_data != mount_data_global)\n\t\t\t\tkfree(mount_data);\n\n\t\t\tmount_data = cifs_compose_mount_options(\n\t\t\t\t\tcifs_sb->mountdata, full_path + 1,\n\t\t\t\t\treferrals, &fake_devname);\n\n\t\t\tfree_dfs_info_array(referrals, num_referrals);\n\t\t\tkfree(fake_devname);\n\t\t\tkfree(full_path);\n\n\t\t\tif (IS_ERR(mount_data)) {\n\t\t\t\trc = PTR_ERR(mount_data);\n\t\t\t\tmount_data = NULL;\n\t\t\t\tgoto mount_fail_check;\n\t\t\t}\n\n\t\t\tif (tcon)\n\t\t\t\tcifs_put_tcon(tcon);\n\t\t\telse if (pSesInfo)\n\t\t\t\tcifs_put_smb_ses(pSesInfo);\n\n\t\t\tcleanup_volume_info(&volume_info);\n\t\t\treferral_walks_count++;\n\t\t\tFreeXid(xid);\n\t\t\tgoto try_mount_again;\n\t\t}\n#else /* No DFS support, return error on mount */\n\t\trc = -EOPNOTSUPP;\n#endif\n\t}\n\n\tif (rc)\n\t\tgoto mount_fail_check;\n\n\t/* now, hang the tcon off of the superblock */\n\ttlink = kzalloc(sizeof *tlink, GFP_KERNEL);\n\tif (tlink == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto mount_fail_check;\n\t}\n\n\ttlink->tl_uid = pSesInfo->linux_uid;\n\ttlink->tl_tcon = tcon;\n\ttlink->tl_time = jiffies;\n\tset_bit(TCON_LINK_MASTER, &tlink->tl_flags);\n\tset_bit(TCON_LINK_IN_TREE, &tlink->tl_flags);\n\n\tcifs_sb->master_tlink = tlink;\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tqueue_delayed_work(system_nrt_wq, &cifs_sb->prune_tlinks,\n\t\t\t\tTLINK_IDLE_EXPIRE);\n\nmount_fail_check:\n\t/* on error free sesinfo and tcon struct if needed */\n\tif (rc) {\n\t\tif (mount_data != mount_data_global)\n\t\t\tkfree(mount_data);\n\t\t/* If find_unc succeeded then rc == 0 so we can not end */\n\t\t/* up accidentally freeing someone elses tcon struct */\n\t\tif (tcon)\n\t\t\tcifs_put_tcon(tcon);\n\t\telse if (pSesInfo)\n\t\t\tcifs_put_smb_ses(pSesInfo);\n\t\telse\n\t\t\tcifs_put_tcp_session(srvTcp);\n\t\tgoto out;\n\t}\n\n\t/* volume_info->password is freed above when existing session found\n\t(in which case it is not needed anymore) but when new sesion is created\n\tthe password ptr is put in the new session structure (in which case the\n\tpassword will be freed at unmount time) */\nout:\n\t/* zero out password before freeing */\n\tcleanup_volume_info(&volume_info);\n\tFreeXid(xid);\n\treturn rc;\n}\n", "target": 1, "idx": 178917}
{"func": "status_t MPEG4Extractor::readMetaData() {\n if (mInitCheck != NO_INIT) {\n return mInitCheck;\n }\n\n off64_t offset = 0;\n status_t err;\n while (true) {\n off64_t orig_offset = offset;\n        err = parseChunk(&offset, 0);\n\n if (err != OK && err != UNKNOWN_ERROR) {\n break;\n } else if (offset <= orig_offset) {\n            ALOGE(\"did not advance: 0x%lld->0x%lld\", orig_offset, offset);\n            err = ERROR_MALFORMED;\n break;\n } else if (err == OK) {\n continue;\n }\n\n uint32_t hdr[2];\n if (mDataSource->readAt(offset, hdr, 8) < 8) {\n break;\n }\n uint32_t chunk_type = ntohl(hdr[1]);\n if (chunk_type == FOURCC('m', 'o', 'o', 'f')) {\n            mMoofOffset = offset;\n } else if (chunk_type != FOURCC('m', 'd', 'a', 't')) {\n continue;\n }\n break;\n }\n\n if (mInitCheck == OK) {\n if (mHasVideo) {\n            mFileMetaData->setCString(\n                    kKeyMIMEType, MEDIA_MIMETYPE_CONTAINER_MPEG4);\n } else {\n            mFileMetaData->setCString(kKeyMIMEType, \"audio/mp4\");\n }\n } else {\n        mInitCheck = err;\n }\n\n    CHECK_NE(err, (status_t)NO_INIT);\n\n int psshsize = 0;\n for (size_t i = 0; i < mPssh.size(); i++) {\n        psshsize += 20 + mPssh[i].datalen;\n }\n if (psshsize) {\n char *buf = (char*)malloc(psshsize);\n char *ptr = buf;\n for (size_t i = 0; i < mPssh.size(); i++) {\n            memcpy(ptr, mPssh[i].uuid, 20); // uuid + length\n            memcpy(ptr + 20, mPssh[i].data, mPssh[i].datalen);\n            ptr += (20 + mPssh[i].datalen);\n }\n        mFileMetaData->setData(kKeyPssh, 'pssh', buf, psshsize);\n        free(buf);\n }\n return mInitCheck;\n}\n", "target": 0, "idx": 170379}
{"func": "BGD_DECLARE(gdImagePtr) gdImageCreateFromWebpPtr (int size, void *data)\n{\n\tgdImagePtr im;\n\tgdIOCtx *in = gdNewDynamicCtxEx(size, data, 0);\n\tif (!in)\n\t\treturn 0;\n\tim = gdImageCreateFromWebpCtx(in);\n\tin->gd_free(in);\n\treturn im;\n}\n", "target": 0, "idx": 49724}
{"func": "PHP_FUNCTION(imageconvolution)\n{\n\tzval *SIM, *hash_matrix;\n\tzval **var = NULL, **var2 = NULL;\n\tgdImagePtr im_src = NULL;\n\tdouble div, offset;\n\tint nelem, i, j, res;\n\tfloat matrix[3][3] = {{0,0,0}, {0,0,0}, {0,0,0}};\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"radd\", &SIM, &hash_matrix, &div, &offset) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, \"Image\", le_gd);\n\n\tnelem = zend_hash_num_elements(Z_ARRVAL_P(hash_matrix));\n\tif (nelem != 3) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"You must have 3x3 array\");\n\t\tRETURN_FALSE;\n\t}\n\n\tfor (i=0; i<3; i++) {\n\t\tif (zend_hash_index_find(Z_ARRVAL_P(hash_matrix), (i), (void **) &var) == SUCCESS && Z_TYPE_PP(var) == IS_ARRAY) {\n\t\t\tif (Z_TYPE_PP(var) != IS_ARRAY || zend_hash_num_elements(Z_ARRVAL_PP(var)) != 3 ) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"You must have 3x3 array\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n \n \t\t\tfor (j=0; j<3; j++) {\n \t\t\t\tif (zend_hash_index_find(Z_ARRVAL_PP(var), (j), (void **) &var2) == SUCCESS) {\n\t\t\t\t\tSEPARATE_ZVAL(var2);\n\t\t\t\t\tconvert_to_double(*var2);\n\t\t\t\t\tmatrix[i][j] = (float)Z_DVAL_PP(var2);\n \t\t\t\t} else {\n \t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"You must have a 3x3 matrix\");\n \t\t\t\t\tRETURN_FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tres = gdImageConvolution(im_src, matrix, (float)div, (float)offset);\n\n\tif (res) {\n\t\tRETURN_TRUE;\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n", "target": 1, "idx": 179598}
{"func": "void setAnimationUpdateIfNeeded(StyleResolverState& state, Element& element)\n{\n    if (RuntimeEnabledFeatures::webAnimationsCSSEnabled() && state.animationUpdate())\n        element.ensureActiveAnimations()->cssAnimations().setPendingUpdate(state.takeAnimationUpdate());\n}\n", "target": 0, "idx": 127409}
{"func": "krb5_gss_process_context_token(minor_status, context_handle,\n                               token_buffer)\n    OM_uint32 *minor_status;\n    gss_ctx_id_t context_handle;\n    gss_buffer_t token_buffer;\n{\n    krb5_gss_ctx_id_rec *ctx;\n    OM_uint32 majerr;\n \n     ctx = (krb5_gss_ctx_id_t) context_handle;\n \n    if (! ctx->established) {\n         *minor_status = KG_CTX_INCOMPLETE;\n         return(GSS_S_NO_CONTEXT);\n     }\n \n     /* \"unseal\" the token */\n \n     if (GSS_ERROR(majerr = kg_unseal(minor_status, context_handle,\n                                     token_buffer,\n                                     GSS_C_NO_BUFFER, NULL, NULL,\n                                      KG_TOK_DEL_CTX)))\n         return(majerr);\n \n    /* that's it.  delete the context */\n    return(krb5_gss_delete_sec_context(minor_status, &context_handle,\n                                       GSS_C_NO_BUFFER));\n }\n", "target": 1, "idx": 179995}
{"func": "EntryInfoResult::EntryInfoResult() : error(GDATA_FILE_ERROR_FAILED) {\n}\n", "target": 0, "idx": 125496}
{"func": "bool OSExchangeData::HasAnyFormat(\n    int formats,\n    const std::set<CustomFormat>& custom_formats) const {\n  if ((formats & STRING) != 0 && HasString())\n    return true;\n  if ((formats & URL) != 0 && HasURL())\n    return true;\n#if defined(OS_WIN)\n  if ((formats & FILE_CONTENTS) != 0 && provider_->HasFileContents())\n    return true;\n#endif\n#if defined(OS_WIN) || defined(USE_AURA)\n  if ((formats & HTML) != 0 && provider_->HasHtml())\n    return true;\n#endif\n  if ((formats & FILE_NAME) != 0 && provider_->HasFile())\n    return true;\n  for (std::set<CustomFormat>::const_iterator i = custom_formats.begin();\n       i != custom_formats.end(); ++i) {\n    if (HasCustomFormat(*i))\n      return true;\n  }\n  return false;\n}\n", "target": 0, "idx": 134588}
{"func": " static char *ps_files_path_create(char *buf, size_t buflen, ps_files *data, const char *key)\n {\n{\n\tsize_t len;\n\tconst char *p;\n\tchar c;\n\tint ret = 1;\n\n\tfor (p = key; (c = *p); p++) {\n\t\t/* valid characters are a..z,A..Z,0..9 */\n\t\tif (!((c >= 'a' && c <= 'z')\n\t\t\t\t|| (c >= 'A' && c <= 'Z')\n\t\t\t\t|| (c >= '0' && c <= '9')\n\t\t\t\t|| c == ','\n\t\t\t\t|| c == '-')) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tlen = p - key;\n\n\t/* Somewhat arbitrary length limit here, but should be way more than\n\t   anyone needs and avoids file-level warnings later on if we exceed MAX_PATH */\n\tif (len == 0 || len > 128) {\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\nstatic char *ps_files_path_create(char *buf, size_t buflen, ps_files *data, const char *key)\n{\n\tsize_t key_len;\n\tconst char *p;\n\tint i;\n\tint n;\n\n\tkey_len = strlen(key);\n\tif (key_len <= data->dirdepth ||\n\t\tbuflen < (strlen(data->basedir) + 2 * data->dirdepth + key_len + 5 + sizeof(FILE_PREFIX))) {\n\t\treturn NULL;\n\t}\n\n\tp = key;\n\tmemcpy(buf, data->basedir, data->basedir_len);\n\tn = data->basedir_len;\n\tbuf[n++] = PHP_DIR_SEPARATOR;\n\tfor (i = 0; i < (int)data->dirdepth; i++) {\n\t\tbuf[n++] = *p++;\n\t\tbuf[n++] = PHP_DIR_SEPARATOR;\n\t}\n\tmemcpy(buf + n, FILE_PREFIX, sizeof(FILE_PREFIX) - 1);\n\tn += sizeof(FILE_PREFIX) - 1;\n\tmemcpy(buf + n, key, key_len);\n\tn += key_len;\n \n                ps_files_close(data);\n \n               if (!ps_files_valid_key(key)) {\n                        php_error_docref(NULL TSRMLS_CC, E_WARNING, \"The session id is too long or contains illegal characters, valid characters are a-z, A-Z, 0-9 and '-,'\");\n                       PS(invalid_session_id) = 1;\n                        return;\n                }\n                if (!ps_files_path_create(buf, sizeof(buf), data, key)) {\n                        return;\n                }\n\tif (data->fd != -1) {\n#ifdef PHP_WIN32\n\t\t/* On Win32 locked files that are closed without being explicitly unlocked\n\t\t   will be unlocked only when \"system resources become available\". */\n\t\tflock(data->fd, LOCK_UN);\n#endif\n\t\tclose(data->fd);\n\t\tdata->fd = -1;\n\t}\n}\n\nstatic void ps_files_open(ps_files *data, const char *key TSRMLS_DC)\n{\n\tchar buf[MAXPATHLEN];\n\n\tif (data->fd < 0 || !data->lastkey || strcmp(key, data->lastkey)) {\n\t\tif (data->lastkey) {\n\t\t\tefree(data->lastkey);\n\t\t\tdata->lastkey = NULL;\n\t\t}\n\n\t\tps_files_close(data);\n\n\t\tif (!ps_files_valid_key(key)) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"The session id is too long or contains illegal characters, valid characters are a-z, A-Z, 0-9 and '-,'\");\n\t\t\tPS(invalid_session_id) = 1;\n\t\t\treturn;\n\t\t}\n\t\tif (!ps_files_path_create(buf, sizeof(buf), data, key)) {\n\t\t\treturn;\n\t\t}\n\n\t\tdata->lastkey = estrdup(key);\n\n\t\tdata->fd = VCWD_OPEN_MODE(buf, O_CREAT | O_RDWR | O_BINARY, data->filemode);\n\n\t\tif (data->fd != -1) {\n#ifndef PHP_WIN32\n\t\t\t/* check to make sure that the opened file is not a symlink, linking to data outside of allowable dirs */\n\t\t\tif (PG(open_basedir)) {\n\t\t\t\tstruct stat sbuf;\n\n\t\t\t\tif (fstat(data->fd, &sbuf)) {\n\t\t\t\t\tclose(data->fd);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (S_ISLNK(sbuf.st_mode) && php_check_open_basedir(buf TSRMLS_CC)) {\n\t\t\t\t\tclose(data->fd);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\tflock(data->fd, LOCK_EX);\n\n#ifdef F_SETFD\n# ifndef FD_CLOEXEC\n#  define FD_CLOEXEC 1\n# endif\n\t\t\tif (fcntl(data->fd, F_SETFD, FD_CLOEXEC)) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"fcntl(%d, F_SETFD, FD_CLOEXEC) failed: %s (%d)\", data->fd, strerror(errno), errno);\n\t\t\t}\n#endif\n\t\t} else {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"open(%s, O_RDWR) failed: %s (%d)\", buf, strerror(errno), errno);\n\t\t}\n\t}\n}\n\nstatic int ps_files_cleanup_dir(const char *dirname, int maxlifetime TSRMLS_DC)\n{\n\tDIR *dir;\n\tchar dentry[sizeof(struct dirent) + MAXPATHLEN];\n\tstruct dirent *entry = (struct dirent *) &dentry;\n\tstruct stat sbuf;\n\tchar buf[MAXPATHLEN];\n\ttime_t now;\n\tint nrdels = 0;\n\tsize_t dirname_len;\n\n\tdir = opendir(dirname);\n\tif (!dir) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"ps_files_cleanup_dir: opendir(%s) failed: %s (%d)\", dirname, strerror(errno), errno);\n\t\treturn (0);\n\t}\n\n\ttime(&now);\n\n        return (nrdels);\n }\n \n #define PS_FILES_DATA ps_files *data = PS_GET_MOD_DATA()\n \n PS_OPEN_FUNC(files)\n\t\t\t\t\t\t(now - sbuf.st_mtime) > maxlifetime) {\n\t\t\t\t\tVCWD_UNLINK(buf);\n\t\t\t\t\tnrdels++;\n\t\t\t\t}\n\t\t\t}\n", "target": 1, "idx": 178042}
{"func": "bool IsFormSubmit(const NavigationEntry* entry) {\n  return (ui::PageTransitionStripQualifier(entry->GetTransitionType()) ==\n          ui::PAGE_TRANSITION_FORM_SUBMIT);\n}\n", "target": 0, "idx": 130382}
{"func": "void ResourceDispatcherHostImpl::BeginRequest(\n    int request_id,\n    const ResourceHostMsg_Request& request_data,\n    IPC::Message* sync_result,  // only valid for sync\n    int route_id) {\n   int process_type = filter_->process_type();\n   int child_id = filter_->child_id();\n \n   if (IsBrowserSideNavigationEnabled() &&\n       IsResourceTypeFrame(request_data.resource_type) &&\n      !request_data.url.SchemeIs(url::kBlobScheme)) {\n    bad_message::ReceivedBadMessage(filter_, bad_message::RDH_INVALID_URL);\n    return;\n  }\n\n  if (request_data.priority < net::MINIMUM_PRIORITY ||\n      request_data.priority > net::MAXIMUM_PRIORITY) {\n    bad_message::ReceivedBadMessage(filter_, bad_message::RDH_INVALID_PRIORITY);\n    return;\n  }\n\n  char url_buf[128];\n  base::strlcpy(url_buf, request_data.url.spec().c_str(), arraysize(url_buf));\n  base::debug::Alias(url_buf);\n\n  LoaderMap::iterator it = pending_loaders_.find(\n      GlobalRequestID(request_data.transferred_request_child_id,\n                      request_data.transferred_request_request_id));\n  if (it != pending_loaders_.end()) {\n    if (it->second->is_transferring()) {\n      ResourceLoader* deferred_loader = it->second.get();\n      UpdateRequestForTransfer(child_id, route_id, request_id,\n                               request_data, it);\n      deferred_loader->CompleteTransfer();\n    } else {\n      bad_message::ReceivedBadMessage(\n          filter_, bad_message::RDH_REQUEST_NOT_TRANSFERRING);\n    }\n    return;\n  }\n\n  ResourceContext* resource_context = NULL;\n  net::URLRequestContext* request_context = NULL;\n  filter_->GetContexts(request_data.resource_type, request_data.origin_pid,\n                       &resource_context, &request_context);\n  CHECK(ContainsKey(active_resource_contexts_, resource_context));\n\n  net::HttpRequestHeaders headers;\n  headers.AddHeadersFromString(request_data.headers);\n\n  if (is_shutdown_ ||\n      !ShouldServiceRequest(process_type, child_id, request_data, headers,\n                            filter_, resource_context)) {\n    AbortRequestBeforeItStarts(filter_, sync_result, request_id);\n    return;\n  }\n\n  if (delegate_ && !delegate_->ShouldBeginRequest(request_data.method,\n                                                  request_data.url,\n                                                  request_data.resource_type,\n                                                  resource_context)) {\n    AbortRequestBeforeItStarts(filter_, sync_result, request_id);\n    return;\n  }\n\n  scoped_ptr<net::URLRequest> new_request = request_context->CreateRequest(\n      request_data.url, request_data.priority, NULL);\n\n  new_request->set_method(request_data.method);\n  new_request->set_first_party_for_cookies(\n      request_data.first_party_for_cookies);\n  new_request->set_initiator(request_data.request_initiator);\n\n  if (request_data.resource_type == RESOURCE_TYPE_MAIN_FRAME) {\n    new_request->set_first_party_url_policy(\n        net::URLRequest::UPDATE_FIRST_PARTY_URL_ON_REDIRECT);\n  }\n\n  const Referrer referrer(request_data.referrer, request_data.referrer_policy);\n  SetReferrerForRequest(new_request.get(), referrer);\n\n  new_request->SetExtraRequestHeaders(headers);\n\n  storage::BlobStorageContext* blob_context =\n      GetBlobStorageContext(filter_->blob_storage_context());\n  if (request_data.request_body.get()) {\n    if (blob_context) {\n      AttachRequestBodyBlobDataHandles(\n          request_data.request_body.get(),\n          blob_context);\n    }\n    new_request->set_upload(UploadDataStreamBuilder::Build(\n        request_data.request_body.get(),\n        blob_context,\n        filter_->file_system_context(),\n        BrowserThread::GetMessageLoopProxyForThread(BrowserThread::FILE)\n            .get()));\n  }\n\n  bool allow_download = request_data.allow_download &&\n      IsResourceTypeFrame(request_data.resource_type);\n  bool do_not_prompt_for_login = request_data.do_not_prompt_for_login;\n  bool is_sync_load = sync_result != NULL;\n\n  ChildProcessSecurityPolicyImpl* policy =\n      ChildProcessSecurityPolicyImpl::GetInstance();\n  bool report_raw_headers = request_data.report_raw_headers;\n  if (report_raw_headers && !policy->CanReadRawCookies(child_id)) {\n    VLOG(1) << \"Denied unauthorized request for raw headers\";\n    report_raw_headers = false;\n  }\n  int load_flags =\n      BuildLoadFlagsForRequest(request_data, child_id, is_sync_load);\n  if (request_data.resource_type == RESOURCE_TYPE_PREFETCH ||\n      request_data.resource_type == RESOURCE_TYPE_FAVICON) {\n    do_not_prompt_for_login = true;\n  }\n  if (request_data.resource_type == RESOURCE_TYPE_IMAGE &&\n      HTTP_AUTH_RELATION_BLOCKED_CROSS ==\n          HttpAuthRelationTypeOf(request_data.url,\n                                 request_data.first_party_for_cookies)) {\n    do_not_prompt_for_login = true;\n    load_flags |= net::LOAD_DO_NOT_USE_EMBEDDED_IDENTITY;\n  }\n\n  bool support_async_revalidation =\n      !is_sync_load && async_revalidation_manager_ &&\n      AsyncRevalidationManager::QualifiesForAsyncRevalidation(request_data);\n\n  if (support_async_revalidation)\n    load_flags |= net::LOAD_SUPPORT_ASYNC_REVALIDATION;\n\n  if (is_sync_load) {\n    DCHECK_EQ(request_data.priority, net::MAXIMUM_PRIORITY);\n    DCHECK_NE(load_flags & net::LOAD_IGNORE_LIMITS, 0);\n  } else {\n    DCHECK_EQ(load_flags & net::LOAD_IGNORE_LIMITS, 0);\n  }\n  new_request->SetLoadFlags(load_flags);\n\n  ResourceRequestInfoImpl* extra_info = new ResourceRequestInfoImpl(\n      process_type, child_id, route_id,\n      -1,  // frame_tree_node_id\n      request_data.origin_pid, request_id, request_data.render_frame_id,\n      request_data.is_main_frame, request_data.parent_is_main_frame,\n      request_data.resource_type, request_data.transition_type,\n      request_data.should_replace_current_entry,\n      false,  // is download\n      false,  // is stream\n      allow_download, request_data.has_user_gesture,\n      request_data.enable_load_timing, request_data.enable_upload_progress,\n      do_not_prompt_for_login, request_data.referrer_policy,\n      request_data.visiblity_state, resource_context, filter_->GetWeakPtr(),\n      report_raw_headers, !is_sync_load,\n      IsUsingLoFi(request_data.lofi_state, delegate_, *new_request,\n                  resource_context,\n                  request_data.resource_type == RESOURCE_TYPE_MAIN_FRAME),\n      support_async_revalidation ? request_data.headers : std::string());\n  extra_info->AssociateWithRequest(new_request.get());\n\n  if (new_request->url().SchemeIs(url::kBlobScheme)) {\n    storage::BlobProtocolHandler::SetRequestedBlobDataHandle(\n        new_request.get(),\n        filter_->blob_storage_context()->context()->GetBlobDataFromPublicURL(\n            new_request->url()));\n  }\n\n  const bool should_skip_service_worker =\n      request_data.skip_service_worker || is_sync_load;\n  ServiceWorkerRequestHandler::InitializeHandler(\n      new_request.get(), filter_->service_worker_context(), blob_context,\n      child_id, request_data.service_worker_provider_id,\n      should_skip_service_worker,\n      request_data.fetch_request_mode, request_data.fetch_credentials_mode,\n      request_data.fetch_redirect_mode, request_data.resource_type,\n      request_data.fetch_request_context_type, request_data.fetch_frame_type,\n      request_data.request_body);\n\n  if (base::CommandLine::ForCurrentProcess()->HasSwitch(\n          switches::kEnableExperimentalWebPlatformFeatures)) {\n    ForeignFetchRequestHandler::InitializeHandler(\n        new_request.get(), filter_->service_worker_context(), blob_context,\n        child_id, request_data.service_worker_provider_id,\n        should_skip_service_worker,\n        request_data.fetch_request_mode, request_data.fetch_credentials_mode,\n        request_data.fetch_redirect_mode, request_data.resource_type,\n        request_data.fetch_request_context_type, request_data.fetch_frame_type,\n        request_data.request_body);\n  }\n\n  AppCacheInterceptor::SetExtraRequestInfo(\n      new_request.get(), filter_->appcache_service(), child_id,\n      request_data.appcache_host_id, request_data.resource_type,\n      request_data.should_reset_appcache);\n\n  scoped_ptr<ResourceHandler> handler(\n       CreateResourceHandler(\n           new_request.get(),\n           request_data, sync_result, route_id, process_type, child_id,\n           resource_context));\n\n  if (handler)\n    BeginRequestInternal(std::move(new_request), std::move(handler));\n}\n", "target": 1, "idx": 186239}
{"func": "SMB2_sess_auth_rawntlmssp_authenticate(struct SMB2_sess_data *sess_data)\n{\n\tint rc;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tstruct smb2_sess_setup_req *req;\n\tstruct smb2_sess_setup_rsp *rsp = NULL;\n\tunsigned char *ntlmssp_blob = NULL;\n\tbool use_spnego = false; /* else use raw ntlmssp */\n\tu16 blob_length = 0;\n\n\trc = SMB2_sess_alloc_buffer(sess_data);\n\tif (rc)\n\t\tgoto out;\n\n\treq = (struct smb2_sess_setup_req *) sess_data->iov[0].iov_base;\n\treq->hdr.sync_hdr.SessionId = ses->Suid;\n\n\trc = build_ntlmssp_auth_blob(&ntlmssp_blob, &blob_length, ses,\n\t\t\t\t\tsess_data->nls_cp);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"build_ntlmssp_auth_blob failed %d\\n\", rc);\n\t\tgoto out;\n\t}\n\n\tif (use_spnego) {\n\t\t/* BB eventually need to add this */\n\t\tcifs_dbg(VFS, \"spnego not supported for SMB2 yet\\n\");\n\t\trc = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\tsess_data->iov[1].iov_base = ntlmssp_blob;\n\tsess_data->iov[1].iov_len = blob_length;\n\n\trc = SMB2_sess_sendreceive(sess_data);\n\tif (rc)\n\t\tgoto out;\n\n\trsp = (struct smb2_sess_setup_rsp *)sess_data->iov[0].iov_base;\n\n\tses->Suid = rsp->hdr.sync_hdr.SessionId;\n\tses->session_flags = le16_to_cpu(rsp->SessionFlags);\n\tif (ses->session_flags & SMB2_SESSION_FLAG_ENCRYPT_DATA)\n\t\tcifs_dbg(VFS, \"SMB3 encryption not supported yet\\n\");\n\n\trc = SMB2_sess_establish_session(sess_data);\nout:\n\tkfree(ntlmssp_blob);\n\tSMB2_sess_free_buffer(sess_data);\n\tkfree(ses->ntlmssp);\n\tses->ntlmssp = NULL;\n\tsess_data->result = rc;\n\tsess_data->func = NULL;\n}\n", "target": 0, "idx": 84920}
{"func": "static void lg_remove(struct hid_device *hdev)\n{\n\tstruct lg_drv_data *drv_data = hid_get_drvdata(hdev);\n\tif (drv_data->quirks & LG_FF4)\n\t\tlg4ff_deinit(hdev);\n\n\thid_hw_stop(hdev);\n\tkfree(drv_data);\n}\n", "target": 0, "idx": 38116}
{"func": "void EnterpriseEnrollmentScreen::OnPolicyStateChanged(\n    policy::CloudPolicySubsystem::PolicySubsystemState state,\n    policy::CloudPolicySubsystem::ErrorDetails error_details) {\n\n  if (is_showing_) {\n    switch (state) {\n      case policy::CloudPolicySubsystem::UNENROLLED:\n        return;\n      case policy::CloudPolicySubsystem::BAD_GAIA_TOKEN:\n      case policy::CloudPolicySubsystem::LOCAL_ERROR:\n        actor_->ShowFatalEnrollmentError();\n        break;\n      case policy::CloudPolicySubsystem::UNMANAGED:\n        actor_->ShowAccountError();\n        break;\n      case policy::CloudPolicySubsystem::NETWORK_ERROR:\n        actor_->ShowNetworkEnrollmentError();\n        break;\n      case policy::CloudPolicySubsystem::TOKEN_FETCHED:\n        WriteInstallAttributesData();\n        return;\n      case policy::CloudPolicySubsystem::SUCCESS:\n        registrar_.reset();\n        UMA_HISTOGRAM_ENUMERATION(policy::kMetricEnrollment,\n                                  policy::kMetricEnrollmentOK,\n                                  policy::kMetricEnrollmentSize);\n        actor_->ShowConfirmationScreen();\n        return;\n    }\n    if (state == policy::CloudPolicySubsystem::UNMANAGED) {\n      UMA_HISTOGRAM_ENUMERATION(policy::kMetricEnrollment,\n                                policy::kMetricEnrollmentNotSupported,\n                                policy::kMetricEnrollmentSize);\n    } else {\n      UMA_HISTOGRAM_ENUMERATION(policy::kMetricEnrollment,\n                                policy::kMetricEnrollmentPolicyFailed,\n                                policy::kMetricEnrollmentSize);\n    }\n    LOG(WARNING) << \"Policy subsystem error during enrollment: \" << state\n                 << \" details: \" << error_details;\n  }\n \n   registrar_.reset();\n  g_browser_process->browser_policy_connector()->DeviceStopAutoRetry();\n }\n", "target": 1, "idx": 183734}
{"func": "TIFFWriteEncodedStrip(TIFF* tif, uint32 strip, void* data, tmsize_t cc)\n{\n\tstatic const char module[] = \"TIFFWriteEncodedStrip\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint16 sample;\n\n\tif (!WRITECHECKSTRIPS(tif, module))\n\t\treturn ((tmsize_t) -1);\n\t/*\n\t * Check strip array to make sure there's space.\n\t * We don't support dynamically growing files that\n\t * have data organized in separate bitplanes because\n\t * it's too painful.  In that case we require that\n\t * the imagelength be set properly before the first\n\t * write (so that the strips array will be fully\n\t * allocated above).\n\t */\n\tif (strip >= td->td_nstrips) {\n\t\tif (td->td_planarconfig == PLANARCONFIG_SEPARATE) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t    \"Can not grow image by strips when using separate planes\");\n\t\t\treturn ((tmsize_t) -1);\n\t\t}\n\t\tif (!TIFFGrowStrips(tif, 1, module))\n\t\t\treturn ((tmsize_t) -1);\n\t\ttd->td_stripsperimage =\n\t\t    TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);  \n\t}\n\t/*\n\t * Handle delayed allocation of data buffer.  This\n\t * permits it to be sized according to the directory\n\t * info.\n\t */\n\tif (!BUFFERCHECK(tif))\n\t\treturn ((tmsize_t) -1);\n\n        tif->tif_flags |= TIFF_BUF4WRITE;\n\ttif->tif_curstrip = strip;\n\n        if (td->td_stripsperimage == 0) {\n                TIFFErrorExt(tif->tif_clientdata, module, \"Zero strips per image\");\n                return ((tmsize_t) -1);\n        }\n\n\ttif->tif_row = (strip % td->td_stripsperimage) * td->td_rowsperstrip;\n\tif ((tif->tif_flags & TIFF_CODERSETUP) == 0) {\n\t\tif (!(*tif->tif_setupencode)(tif))\n\t\t\treturn ((tmsize_t) -1);\n\t\ttif->tif_flags |= TIFF_CODERSETUP;\n\t}\n\n\tif( td->td_stripbytecount[strip] > 0 )\n        {\n            /* Make sure that at the first attempt of rewriting the tile, we will have */\n            /* more bytes available in the output buffer than the previous byte count, */\n            /* so that TIFFAppendToStrip() will detect the overflow when it is called the first */\n            /* time if the new compressed tile is bigger than the older one. (GDAL #4771) */\n            if( tif->tif_rawdatasize <= (tmsize_t)td->td_stripbytecount[strip] )\n            {\n                if( !(TIFFWriteBufferSetup(tif, NULL,\n                    (tmsize_t)TIFFroundup_64((uint64)(td->td_stripbytecount[strip] + 1), 1024))) )\n                    return ((tmsize_t)(-1));\n            }\n\n\t    /* Force TIFFAppendToStrip() to consider placing data at end\n               of file. */\n            tif->tif_curoff = 0;\n        }\n\n    tif->tif_rawcc = 0;\n    tif->tif_rawcp = tif->tif_rawdata;\n\n\ttif->tif_flags &= ~TIFF_POSTENCODE;\n\n    /* shortcut to avoid an extra memcpy() */\n    if( td->td_compression == COMPRESSION_NONE )\n    {\n        /* swab if needed - note that source buffer will be altered */\n        tif->tif_postdecode( tif, (uint8*) data, cc );\n\n        if (!isFillOrder(tif, td->td_fillorder) &&\n            (tif->tif_flags & TIFF_NOBITREV) == 0)\n            TIFFReverseBits((uint8*) data, cc);\n\n        if (cc > 0 &&\n            !TIFFAppendToStrip(tif, strip, (uint8*) data, cc))\n            return ((tmsize_t) -1);\n        return (cc);\n    }\n\n\tsample = (uint16)(strip / td->td_stripsperimage);\n\tif (!(*tif->tif_preencode)(tif, sample))\n\t\treturn ((tmsize_t) -1);\n\n        /* swab if needed - note that source buffer will be altered */\n\ttif->tif_postdecode( tif, (uint8*) data, cc );\n\n\tif (!(*tif->tif_encodestrip)(tif, (uint8*) data, cc, sample))\n\t\treturn ((tmsize_t) -1);\n\tif (!(*tif->tif_postencode)(tif))\n\t\treturn ((tmsize_t) -1);\n\tif (!isFillOrder(tif, td->td_fillorder) &&\n\t    (tif->tif_flags & TIFF_NOBITREV) == 0)\n\t\tTIFFReverseBits(tif->tif_rawdata, tif->tif_rawcc);\n\tif (tif->tif_rawcc > 0 &&\n\t    !TIFFAppendToStrip(tif, strip, tif->tif_rawdata, tif->tif_rawcc))\n\t\treturn ((tmsize_t) -1);\n\ttif->tif_rawcc = 0;\n\ttif->tif_rawcp = tif->tif_rawdata;\n\treturn (cc);\n}\n", "target": 0, "idx": 48326}
{"func": "static int ovl_readlink(struct dentry *dentry, char __user *buf, int bufsiz)\n{\n\tstruct path realpath;\n\tstruct inode *realinode;\n\n\tovl_path_real(dentry, &realpath);\n\trealinode = realpath.dentry->d_inode;\n\n\tif (!realinode->i_op->readlink)\n\t\treturn -EINVAL;\n\n\ttouch_atime(&realpath);\n\n\treturn realinode->i_op->readlink(realpath.dentry, buf, bufsiz);\n}\n", "target": 0, "idx": 41435}
{"func": "LayoutUnit RenderBox::computeReplacedLogicalWidthRespectingMinMaxWidth(LayoutUnit logicalWidth, ShouldComputePreferred shouldComputePreferred) const\n{\n    LayoutUnit minLogicalWidth = (shouldComputePreferred == ComputePreferred && style()->logicalMinWidth().isPercent()) || style()->logicalMinWidth().isUndefined() ? logicalWidth : computeReplacedLogicalWidthUsing(style()->logicalMinWidth());\n    LayoutUnit maxLogicalWidth = (shouldComputePreferred == ComputePreferred && style()->logicalMaxWidth().isPercent()) || style()->logicalMaxWidth().isUndefined() ? logicalWidth : computeReplacedLogicalWidthUsing(style()->logicalMaxWidth());\n    return max(minLogicalWidth, min(logicalWidth, maxLogicalWidth));\n}\n", "target": 0, "idx": 124850}
{"func": "static bool cmd_ibm_sense_condition(IDEState *s, uint8_t cmd)\n{\n    switch (s->feature) {\n    case 0x01:  /* sense temperature in device */\n        s->nsector = 0x50;      /* +20 C */\n        break;\n    default:\n        ide_abort_command(s);\n        return true;\n    }\n\n    return true;\n}\n", "target": 0, "idx": 6693}
{"func": "void AXObject::tokenVectorFromAttribute(Vector<String>& tokens,\n                                        const QualifiedName& attribute) const {\n  Node* node = this->getNode();\n  if (!node || !node->isElementNode())\n    return;\n\n  String attributeValue = getAttribute(attribute).getString();\n  if (attributeValue.isEmpty())\n    return;\n\n  attributeValue.simplifyWhiteSpace();\n  attributeValue.split(' ', tokens);\n}\n", "target": 0, "idx": 138210}
{"func": "void InlineSigninHelper::OnClientOAuthSuccessAndBrowserOpened(\n    const ClientOAuthResult& result,\n    Profile* profile,\n    Profile::CreateStatus status) {\n  if (is_force_sign_in_with_usermanager_)\n    UnlockProfileAndHideLoginUI(profile_->GetPath(), handler_.get());\n  Browser* browser = NULL;\n  if (handler_) {\n    browser = handler_->GetDesktopBrowser();\n  }\n\n  AboutSigninInternals* about_signin_internals =\n      AboutSigninInternalsFactory::GetForProfile(profile_);\n  about_signin_internals->OnRefreshTokenReceived(\"Successful\");\n\n  std::string account_id =\n      AccountTrackerServiceFactory::GetForProfile(profile_)\n          ->SeedAccountInfo(gaia_id_, email_);\n\n  signin_metrics::AccessPoint access_point =\n      signin::GetAccessPointForPromoURL(current_url_);\n  signin_metrics::Reason reason =\n      signin::GetSigninReasonForPromoURL(current_url_);\n\n  SigninManager* signin_manager = SigninManagerFactory::GetForProfile(profile_);\n  std::string primary_email =\n      signin_manager->GetAuthenticatedAccountInfo().email;\n  if (gaia::AreEmailsSame(email_, primary_email) &&\n      (reason == signin_metrics::Reason::REASON_REAUTHENTICATION ||\n       reason == signin_metrics::Reason::REASON_UNLOCK) &&\n      !password_.empty() && profiles::IsLockAvailable(profile_)) {\n    LocalAuth::SetLocalAuthCredentials(profile_, password_);\n  }\n\n#if defined(SYNC_PASSWORD_REUSE_DETECTION_ENABLED)\n  if (!password_.empty()) {\n    scoped_refptr<password_manager::PasswordStore> password_store =\n        PasswordStoreFactory::GetForProfile(profile_,\n                                            ServiceAccessType::EXPLICIT_ACCESS);\n    if (password_store && !primary_email.empty()) {\n      password_store->SaveGaiaPasswordHash(\n          primary_email, base::UTF8ToUTF16(password_),\n          password_manager::metrics_util::SyncPasswordHashChange::\n              SAVED_ON_CHROME_SIGNIN);\n    }\n  }\n#endif\n\n   if (reason == signin_metrics::Reason::REASON_REAUTHENTICATION ||\n       reason == signin_metrics::Reason::REASON_UNLOCK ||\n       reason == signin_metrics::Reason::REASON_ADD_SECONDARY_ACCOUNT) {\n    ProfileOAuth2TokenServiceFactory::GetForProfile(profile_)->\n        UpdateCredentials(account_id, result.refresh_token);\n \n     if (signin::IsAutoCloseEnabledInURL(current_url_)) {\n      bool show_account_management = ShouldShowAccountManagement(\n          current_url_,\n          AccountConsistencyModeManager::IsMirrorEnabledForProfile(profile_));\n      base::ThreadTaskRunnerHandle::Get()->PostTask(\n          FROM_HERE, base::BindOnce(&InlineLoginHandlerImpl::CloseTab, handler_,\n                                    show_account_management));\n    }\n\n    if (reason == signin_metrics::Reason::REASON_REAUTHENTICATION ||\n        reason == signin_metrics::Reason::REASON_UNLOCK) {\n      signin_manager->MergeSigninCredentialIntoCookieJar();\n    }\n    LogSigninReason(reason);\n  } else {\n    browser_sync::ProfileSyncService* sync_service =\n        ProfileSyncServiceFactory::GetForProfile(profile_);\n    SigninErrorController* error_controller =\n        SigninErrorControllerFactory::GetForProfile(profile_);\n\n    OneClickSigninSyncStarter::StartSyncMode start_mode =\n        OneClickSigninSyncStarter::CONFIRM_SYNC_SETTINGS_FIRST;\n    if (access_point == signin_metrics::AccessPoint::ACCESS_POINT_SETTINGS ||\n        choose_what_to_sync_) {\n      bool show_settings_without_configure =\n          error_controller->HasError() && sync_service &&\n          sync_service->IsFirstSetupComplete();\n      if (!show_settings_without_configure)\n        start_mode = OneClickSigninSyncStarter::CONFIGURE_SYNC_FIRST;\n    }\n\n    OneClickSigninSyncStarter::ConfirmationRequired confirmation_required =\n        confirm_untrusted_signin_ ?\n            OneClickSigninSyncStarter::CONFIRM_UNTRUSTED_SIGNIN :\n            OneClickSigninSyncStarter::CONFIRM_AFTER_SIGNIN;\n\n    bool start_signin = !HandleCrossAccountError(\n        result.refresh_token, confirmation_required, start_mode);\n    if (start_signin) {\n      CreateSyncStarter(browser, current_url_, result.refresh_token,\n                        OneClickSigninSyncStarter::CURRENT_PROFILE, start_mode,\n                        confirmation_required);\n      base::ThreadTaskRunnerHandle::Get()->DeleteSoon(FROM_HERE, this);\n    }\n  }\n}\n", "target": 1, "idx": 186550}
{"func": "void SocketStreamDispatcherHost::ContinueSSLRequest(\n    const content::GlobalRequestID& id) {\n  int socket_id = id.request_id;\n  DVLOG(1) << \"SocketStreamDispatcherHost::ContinueSSLRequest socket_id=\"\n           << socket_id;\n  DCHECK_NE(content::kNoSocketId, socket_id);\n  SocketStreamHost* socket_stream_host = hosts_.Lookup(socket_id);\n  DCHECK(socket_stream_host);\n  socket_stream_host->ContinueDespiteError();\n}\n", "target": 0, "idx": 116175}
{"func": "static struct cm_timewait_info * cm_create_timewait_info(__be32 local_id)\n{\n\tstruct cm_timewait_info *timewait_info;\n\n\ttimewait_info = kzalloc(sizeof *timewait_info, GFP_KERNEL);\n\tif (!timewait_info)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttimewait_info->work.local_id = local_id;\n\tINIT_DELAYED_WORK(&timewait_info->work.work, cm_work_handler);\n\ttimewait_info->work.cm_event.event = IB_CM_TIMEWAIT_EXIT;\n\treturn timewait_info;\n}\n", "target": 0, "idx": 38354}
{"func": "long AudioTrack::Parse(Segment* pSegment, const Info& info,\n long long element_start, long long element_size,\n AudioTrack*& pResult) {\n if (pResult)\n return -1;\n\n if (info.type != Track::kAudio)\n return -1;\n\n IMkvReader* const pReader = pSegment->m_pReader;\n\n const Settings& s = info.settings;\n  assert(s.start >= 0);\n  assert(s.size >= 0);\n\n long long pos = s.start;\n  assert(pos >= 0);\n\n const long long stop = pos + s.size;\n\n double rate = 8000.0; // MKV default\n long long channels = 1;\n long long bit_depth = 0;\n\n while (pos < stop) {\n long long id, size;\n\n long status = ParseElementHeader(pReader, pos, stop, id, size);\n\n if (status < 0) // error\n return status;\n\n if (id == 0x35) { // Sample Rate\n      status = UnserializeFloat(pReader, pos, size, rate);\n\n if (status < 0)\n return status;\n\n if (rate <= 0)\n return E_FILE_FORMAT_INVALID;\n } else if (id == 0x1F) { // Channel Count\n      channels = UnserializeUInt(pReader, pos, size);\n\n if (channels <= 0)\n return E_FILE_FORMAT_INVALID;\n } else if (id == 0x2264) { // Bit Depth\n      bit_depth = UnserializeUInt(pReader, pos, size);\n\n if (bit_depth <= 0)\n return E_FILE_FORMAT_INVALID;\n\n     }\n \n     pos += size;  // consume payload\n    assert(pos <= stop);\n   }\n \n  assert(pos == stop);\n \n   AudioTrack* const pTrack =\n       new (std::nothrow) AudioTrack(pSegment, element_start, element_size);\n\n if (pTrack == NULL)\n return -1; // generic error\n\n const int status = info.Copy(pTrack->m_info);\n\n if (status) {\n delete pTrack;\n return status;\n }\n\n  pTrack->m_rate = rate;\n  pTrack->m_channels = channels;\n  pTrack->m_bitDepth = bit_depth;\n\n  pResult = pTrack;\n return 0; // success\n}\n", "target": 1, "idx": 187866}
{"func": " static void locationWithCallWithAttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)\n {\n     TestObjectPython* proxyImp = V8TestObjectPython::toNative(info.Holder());\n    TestNode* imp = WTF::getPtr(proxyImp->locationWithCallWith());\n     if (!imp)\n         return;\n     V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID(V8StringResource<>, cppValue, jsValue);\n    imp->setHrefCallWith(callingDOMWindow(info.GetIsolate()), enteredDOMWindow(info.GetIsolate()), cppValue);\n}\n", "target": 1, "idx": 185466}
{"func": "void EventBindings::AttachFilteredEvent(\n    const v8::FunctionCallbackInfo<v8::Value>& args) {\n  CHECK_EQ(2, args.Length());\n  CHECK(args[0]->IsString());\n  CHECK(args[1]->IsObject());\n\n  std::string event_name = *v8::String::Utf8Value(args[0]);\n  if (!context()->HasAccessOrThrowError(event_name))\n    return;\n\n  std::unique_ptr<base::DictionaryValue> filter;\n  {\n    std::unique_ptr<content::V8ValueConverter> converter(\n        content::V8ValueConverter::create());\n    std::unique_ptr<base::Value> filter_value(converter->FromV8Value(\n        v8::Local<v8::Object>::Cast(args[1]), context()->v8_context()));\n    if (!filter_value || !filter_value->IsType(base::Value::TYPE_DICTIONARY)) {\n      args.GetReturnValue().Set(static_cast<int32_t>(-1));\n      return;\n    }\n     filter = base::DictionaryValue::From(std::move(filter_value));\n   }\n \n  base::DictionaryValue* filter_weak = filter.get();\n   int id = g_event_filter.Get().AddEventMatcher(\n       event_name, ParseEventMatcher(std::move(filter)));\n   attached_matcher_ids_.insert(id);\n \n   std::string extension_id = context()->GetExtensionID();\n   if (AddFilter(event_name, extension_id, *filter_weak)) {\n     bool lazy = ExtensionFrameHelper::IsContextForEventPage(context());\n    content::RenderThread::Get()->Send(new ExtensionHostMsg_AddFilteredListener(\n        extension_id, event_name, *filter_weak, lazy));\n  }\n\n  args.GetReturnValue().Set(static_cast<int32_t>(id));\n}\n", "target": 1, "idx": 185973}
{"func": "gst_vorbis_tag_add_coverart (GstTagList * tags, const gchar * img_data_base64,\n     gint base64_len)\n {\n   GstBuffer *img;\n  guchar *img_data;\n   gsize img_len;\n   guint save = 0;\n   gint state = 0;\n \n   if (base64_len < 2)\n     goto not_enough_data;\n \n  img_data = g_try_malloc0 (base64_len * 3 / 4);\n  if (img_data == NULL)\n    goto alloc_failed;\n  img_len = g_base64_decode_step (img_data_base64, base64_len, img_data,\n      &state, &save);\n \n   if (img_len == 0)\n     goto decode_failed;\n \n  img = gst_tag_image_data_to_image_buffer (img_data, img_len,\n       GST_TAG_IMAGE_TYPE_NONE);\n \n   if (img == NULL)\n  gst_tag_list_add (tags, GST_TAG_MERGE_APPEND,\n      GST_TAG_PREVIEW_IMAGE, img, NULL);\n\n       GST_TAG_PREVIEW_IMAGE, img, NULL);\n \n   gst_buffer_unref (img);\n  g_free (img_data);\n   return;\n \n /* ERRORS */\n  {\n    GST_WARNING (\"COVERART tag with too little base64-encoded data\");\n     GST_WARNING (\"COVERART tag with too little base64-encoded data\");\n     return;\n   }\nalloc_failed:\n  {\n    GST_WARNING (\"Couldn't allocate enough memory to decode COVERART tag\");\n    return;\n  }\n decode_failed:\n   {\n    GST_WARNING (\"Couldn't decode bas64 image data from COVERART tag\");\n    g_free (img_data);\n     return;\n   }\n convert_failed:\n   {\n     GST_WARNING (\"Couldn't extract image or image type from COVERART tag\");\n    g_free (img_data);\n     return;\n   }\n }\n", "target": 1, "idx": 177926}
{"func": "Eina_Bool ewk_frame_back(Evas_Object* ewkFrame)\n{\n    return ewk_frame_navigate(ewkFrame, -1);\n}\n", "target": 0, "idx": 115887}
{"func": "int wc_ecc_make_key(WC_RNG* rng, int keysize, ecc_key* key)\n{\n    return wc_ecc_make_key_ex(rng, keysize, key, ECC_CURVE_DEF);\n}\n", "target": 0, "idx": 81907}
{"func": "drive_eject_completed_cb (DBusGMethodInvocation *context,\n                          Device *device,\n                          gboolean job_was_cancelled,\n                          int status,\n                          const char *stderr,\n                          const char *stdout,\n                          gpointer user_data)\n{\n  if (WEXITSTATUS (status) == 0 && !job_was_cancelled)\n    {\n      /* TODO: probably wait for has_media to change to FALSE */\n      dbus_g_method_return (context);\n    }\n  else\n    {\n      if (job_was_cancelled)\n        {\n          throw_error (context, ERROR_CANCELLED, \"Job was cancelled\");\n        }\n      else\n        {\n          throw_error (context,\n                       ERROR_FAILED,\n                       \"Error ejecting: eject exited with exit code %d: %s\",\n                       WEXITSTATUS (status),\n                       stderr);\n        }\n    }\n}\n", "target": 0, "idx": 11687}
{"func": " static int set_register(pegasus_t *pegasus, __u16 indx, __u8 data)\n {\n \tint ret;\n \n \tret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),\n \t\t\t      PEGASUS_REQ_SET_REG, PEGASUS_REQT_WRITE, data,\n\t\t\t      indx, &data, 1, 1000);\n \tif (ret < 0)\n \t\tnetif_dbg(pegasus, drv, pegasus->net,\n \t\t\t  \"%s returned %d\\n\", __func__, ret);\n \treturn ret;\n }\n", "target": 1, "idx": 181389}
{"func": " DeviceOrientationData* InspectorPageAgent::overrideDeviceOrientation(DeviceOrientationData* deviceOrientation)\n{\n    if (m_deviceOrientation)\n        deviceOrientation = m_deviceOrientation.get();\n    return deviceOrientation;\n}\n", "target": 0, "idx": 109313}
{"func": " PageInfoUI::IdentityInfo::IdentityInfo()\n     : identity_status(PageInfo::SITE_IDENTITY_STATUS_UNKNOWN),\n      safe_browsing_status(PageInfo::SAFE_BROWSING_STATUS_NONE),\n       connection_status(PageInfo::SITE_CONNECTION_STATUS_UNKNOWN),\n       show_ssl_decision_revoke_button(false),\n       show_change_password_buttons(false) {}\n", "target": 1, "idx": 186409}
{"func": "HTMLAllCollection* Document::all() {\n  return EnsureCachedCollection<HTMLAllCollection>(kDocAll);\n}\n", "target": 0, "idx": 141302}
{"func": "static inline u64 __scale_tsc(u64 ratio, u64 tsc)\n{\n\treturn mul_u64_u64_shr(tsc, ratio, kvm_tsc_scaling_ratio_frac_bits);\n}\n", "target": 0, "idx": 57664}
{"func": "void RenderViewImpl::DidFlushPaint() {\n  pepper_helper_->ViewFlushedPaint();\n\n  if (!webview())\n    return;\n\n  WebFrame* main_frame = webview()->mainFrame();\n\n  if (!main_frame->provisionalDataSource()) {\n    WebDataSource* ds = main_frame->dataSource();\n    DocumentState* document_state = DocumentState::FromDataSource(ds);\n\n    Time now = Time::Now();\n    if (document_state->first_paint_time().is_null()) {\n      document_state->set_first_paint_time(now);\n    }\n    if (document_state->first_paint_after_load_time().is_null() &&\n        !document_state->finish_load_time().is_null()) {\n      document_state->set_first_paint_after_load_time(now);\n    }\n  }\n}\n", "target": 0, "idx": 123849}
{"func": "gst_pngdec_base_init (gpointer g_class)\n{\n  GstElementClass *element_class = GST_ELEMENT_CLASS (g_class);\n\n  gst_element_class_add_pad_template (element_class,\n      gst_static_pad_template_get (&gst_pngdec_src_pad_template));\n  gst_element_class_add_pad_template (element_class,\n      gst_static_pad_template_get (&gst_pngdec_sink_pad_template));\n  gst_element_class_set_details (element_class, &gst_pngdec_details);\n}\n", "target": 0, "idx": 2852}
{"func": "PlatformSensorFusion::~PlatformSensorFusion() {\n  for (const auto& pair : source_sensors_)\n    pair.second->RemoveClient(this);\n}\n", "target": 0, "idx": 161770}
{"func": "static int acm_tty_put_char(struct tty_struct *tty, unsigned char ch)\n{\n\tstruct acm *acm = tty->driver_data;\n\tstruct acm_wb *cur;\n\tint wbn;\n\tunsigned long flags;\n\noverflow:\n\tcur = acm->putbuffer;\n\tif (!cur) {\n\t\tspin_lock_irqsave(&acm->write_lock, flags);\n\t\twbn = acm_wb_alloc(acm);\n\t\tif (wbn >= 0) {\n\t\t\tcur = &acm->wb[wbn];\n\t\t\tacm->putbuffer = cur;\n\t\t}\n\t\tspin_unlock_irqrestore(&acm->write_lock, flags);\n\t\tif (!cur)\n\t\t\treturn 0;\n\t}\n\n\tif (cur->len == acm->writesize) {\n\t\tacm_tty_flush_chars(tty);\n\t\tgoto overflow;\n\t}\n\n\tcur->buf[cur->len++] = ch;\n\treturn 1;\n}\n", "target": 0, "idx": 54211}
{"func": "void DownloadResourceHandler::OnRequestRedirected(\n    const net::RedirectInfo& redirect_info,\n    network::ResourceResponse* response,\n    std::unique_ptr<ResourceController> controller) {\n  url::Origin new_origin(url::Origin::Create(redirect_info.new_url));\n  if (!follow_cross_origin_redirects_ &&\n      !first_origin_.IsSameOriginWith(new_origin)) {\n    base::PostTaskWithTraits(\n        FROM_HERE, {BrowserThread::UI},\n        base::BindOnce(\n            &NavigateOnUIThread, redirect_info.new_url, request()->url_chain(),\n            Referrer(GURL(redirect_info.new_referrer),\n                      Referrer::NetReferrerPolicyToBlinkReferrerPolicy(\n                          redirect_info.new_referrer_policy)),\n             GetRequestInfo()->HasUserGesture(),\n            GetRequestInfo()->GetWebContentsGetterForRequest()));\n     controller->Cancel();\n     return;\n   }\n  if (core_.OnRequestRedirected()) {\n    controller->Resume();\n  } else {\n    controller->Cancel();\n  }\n}\n", "target": 1, "idx": 187005}
{"func": "bool WebRuntimeFeatures::isPrefixedEncryptedMediaEnabled()\n{\n    return RuntimeEnabledFeatures::prefixedEncryptedMediaEnabled();\n}\n", "target": 0, "idx": 124464}
{"func": "void SynchronousCompositorImpl::UpdateFrameMetaData(\n    const cc::CompositorFrameMetadata& frame_metadata) {\n  RenderWidgetHostViewAndroid* rwhv = static_cast<RenderWidgetHostViewAndroid*>(\n      contents_->GetRenderWidgetHostView());\n  if (rwhv)\n    rwhv->SynchronousFrameMetadata(frame_metadata);\n  DeliverMessages();\n}\n", "target": 0, "idx": 134704}
{"func": "bool AXNodeObject::isMenu() const {\n  return roleValue() == MenuRole;\n}\n", "target": 0, "idx": 138072}
{"func": "static u8 *crypto_authenc_ahash(struct aead_request *req, unsigned int flags)\n{\n\tstruct crypto_aead *authenc = crypto_aead_reqtfm(req);\n\tstruct crypto_authenc_ctx *ctx = crypto_aead_ctx(authenc);\n\tstruct crypto_ahash *auth = ctx->auth;\n\tstruct authenc_request_ctx *areq_ctx = aead_request_ctx(req);\n\tstruct ahash_request *ahreq = (void *)(areq_ctx->tail + ctx->reqoff);\n\tu8 *hash = areq_ctx->tail;\n\tint err;\n\n\thash = (u8 *)ALIGN((unsigned long)hash + crypto_ahash_alignmask(auth),\n\t\t\t   crypto_ahash_alignmask(auth) + 1);\n\n\tahash_request_set_tfm(ahreq, auth);\n\tahash_request_set_crypt(ahreq, areq_ctx->sg, hash,\n\t\t\t\tareq_ctx->cryptlen);\n\tahash_request_set_callback(ahreq, aead_request_flags(req) & flags,\n\t\t\t\t   areq_ctx->complete, req);\n\n\terr = crypto_ahash_digest(ahreq);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn hash;\n}\n", "target": 0, "idx": 45517}
{"func": "void *hns_xgmac_config(struct hns_mac_cb *mac_cb, struct mac_params *mac_param)\n{\n\tstruct mac_driver *mac_drv;\n\n\tmac_drv = devm_kzalloc(mac_cb->dev, sizeof(*mac_drv), GFP_KERNEL);\n\tif (!mac_drv)\n\t\treturn NULL;\n\n\tmac_drv->mac_init = hns_xgmac_init;\n\tmac_drv->mac_enable = hns_xgmac_enable;\n\tmac_drv->mac_disable = hns_xgmac_disable;\n\n\tmac_drv->mac_id = mac_param->mac_id;\n\tmac_drv->mac_mode = mac_param->mac_mode;\n\tmac_drv->io_base = mac_param->vaddr;\n\tmac_drv->dev = mac_param->dev;\n\tmac_drv->mac_cb = mac_cb;\n\n\tmac_drv->set_mac_addr = hns_xgmac_set_pausefrm_mac_addr;\n\tmac_drv->set_an_mode = NULL;\n\tmac_drv->config_loopback = NULL;\n\tmac_drv->config_pad_and_crc = hns_xgmac_config_pad_and_crc;\n\tmac_drv->config_half_duplex = NULL;\n\tmac_drv->set_rx_ignore_pause_frames =\n\t\thns_xgmac_set_rx_ignore_pause_frames;\n\tmac_drv->mac_free = hns_xgmac_free;\n\tmac_drv->adjust_link = NULL;\n\tmac_drv->set_tx_auto_pause_frames = hns_xgmac_set_tx_auto_pause_frames;\n\tmac_drv->config_max_frame_length = hns_xgmac_config_max_frame_length;\n\tmac_drv->mac_pausefrm_cfg = hns_xgmac_pausefrm_cfg;\n\tmac_drv->autoneg_stat = NULL;\n\tmac_drv->get_info = hns_xgmac_get_info;\n\tmac_drv->get_pause_enable = hns_xgmac_get_pausefrm_cfg;\n\tmac_drv->get_link_status = hns_xgmac_get_link_status;\n\tmac_drv->get_regs = hns_xgmac_get_regs;\n\tmac_drv->get_ethtool_stats = hns_xgmac_get_stats;\n\tmac_drv->get_sset_count = hns_xgmac_get_sset_count;\n\tmac_drv->get_regs_count = hns_xgmac_get_regs_count;\n\tmac_drv->get_strings = hns_xgmac_get_strings;\n\tmac_drv->update_stats = hns_xgmac_update_stats;\n\n\treturn (void *)mac_drv;\n}\n", "target": 0, "idx": 85626}
{"func": " static int ohci_bus_start(OHCIState *ohci)\n {\n    ohci->eof_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,\n                    ohci_frame_boundary,\n                    ohci);\n    if (ohci->eof_timer == NULL) {\n        trace_usb_ohci_bus_eof_timer_failed(ohci->name);\n        ohci_die(ohci);\n        return 0;\n    }\n     trace_usb_ohci_start(ohci->name);\n \n     /* Delay the first SOF event by one frame time as\n\n    if (ohci->eof_timer == NULL) {\n        trace_usb_ohci_bus_eof_timer_failed(ohci->name);\n        ohci_die(ohci);\n        return 0;\n    }\n\n    trace_usb_ohci_start(ohci->name);\n\n    /* Delay the first SOF event by one frame time as\n static void ohci_bus_stop(OHCIState *ohci)\n {\n     trace_usb_ohci_stop(ohci->name);\n    if (ohci->eof_timer) {\n        timer_del(ohci->eof_timer);\n        timer_free(ohci->eof_timer);\n    }\n    ohci->eof_timer = NULL;\n }\n \n /* Sets a flag in a port status register but only set it if the port is\n}\n", "target": 1, "idx": 178360}
{"func": "void ImageCapture::SetMediaTrackConstraints(\n    ScriptPromiseResolver* resolver,\n    const HeapVector<MediaTrackConstraintSet>& constraints_vector) {\n  DCHECK_GT(constraints_vector.size(), 0u);\n  if (!service_) {\n    resolver->Reject(DOMException::Create(kNotFoundError, kNoServiceError));\n    return;\n  }\n  auto constraints = constraints_vector[0];\n\n  if ((constraints.hasWhiteBalanceMode() &&\n       !capabilities_.hasWhiteBalanceMode()) ||\n      (constraints.hasExposureMode() && !capabilities_.hasExposureMode()) ||\n      (constraints.hasFocusMode() && !capabilities_.hasFocusMode()) ||\n      (constraints.hasExposureCompensation() &&\n       !capabilities_.hasExposureCompensation()) ||\n      (constraints.hasColorTemperature() &&\n       !capabilities_.hasColorTemperature()) ||\n      (constraints.hasIso() && !capabilities_.hasIso()) ||\n      (constraints.hasBrightness() && !capabilities_.hasBrightness()) ||\n      (constraints.hasContrast() && !capabilities_.hasContrast()) ||\n      (constraints.hasSaturation() && !capabilities_.hasSaturation()) ||\n      (constraints.hasSharpness() && !capabilities_.hasSharpness()) ||\n      (constraints.hasZoom() && !capabilities_.hasZoom()) ||\n      (constraints.hasTorch() && !capabilities_.hasTorch())) {\n    resolver->Reject(\n        DOMException::Create(kNotSupportedError, \"Unsupported constraint(s)\"));\n    return;\n  }\n\n  auto settings = media::mojom::blink::PhotoSettings::New();\n  MediaTrackConstraintSet temp_constraints = current_constraints_;\n\n  settings->has_white_balance_mode = constraints.hasWhiteBalanceMode() &&\n                                     constraints.whiteBalanceMode().IsString();\n  if (settings->has_white_balance_mode) {\n    const auto white_balance_mode =\n        constraints.whiteBalanceMode().GetAsString();\n    if (capabilities_.whiteBalanceMode().Find(white_balance_mode) ==\n        kNotFound) {\n      resolver->Reject(DOMException::Create(kNotSupportedError,\n                                            \"Unsupported whiteBalanceMode.\"));\n      return;\n    }\n    temp_constraints.setWhiteBalanceMode(constraints.whiteBalanceMode());\n    settings->white_balance_mode = ParseMeteringMode(white_balance_mode);\n  }\n  settings->has_exposure_mode =\n      constraints.hasExposureMode() && constraints.exposureMode().IsString();\n  if (settings->has_exposure_mode) {\n    const auto exposure_mode = constraints.exposureMode().GetAsString();\n    if (capabilities_.exposureMode().Find(exposure_mode) == kNotFound) {\n      resolver->Reject(DOMException::Create(kNotSupportedError,\n                                            \"Unsupported exposureMode.\"));\n      return;\n    }\n    temp_constraints.setExposureMode(constraints.exposureMode());\n    settings->exposure_mode = ParseMeteringMode(exposure_mode);\n  }\n\n  settings->has_focus_mode =\n      constraints.hasFocusMode() && constraints.focusMode().IsString();\n  if (settings->has_focus_mode) {\n    const auto focus_mode = constraints.focusMode().GetAsString();\n    if (capabilities_.focusMode().Find(focus_mode) == kNotFound) {\n      resolver->Reject(\n          DOMException::Create(kNotSupportedError, \"Unsupported focusMode.\"));\n      return;\n    }\n    temp_constraints.setFocusMode(constraints.focusMode());\n    settings->focus_mode = ParseMeteringMode(focus_mode);\n  }\n\n  if (constraints.hasPointsOfInterest() &&\n      constraints.pointsOfInterest().IsPoint2DSequence()) {\n    for (const auto& point :\n         constraints.pointsOfInterest().GetAsPoint2DSequence()) {\n      auto mojo_point = media::mojom::blink::Point2D::New();\n      mojo_point->x = point.x();\n      mojo_point->y = point.y();\n      settings->points_of_interest.push_back(std::move(mojo_point));\n    }\n    temp_constraints.setPointsOfInterest(constraints.pointsOfInterest());\n  }\n\n  settings->has_exposure_compensation =\n      constraints.hasExposureCompensation() &&\n      constraints.exposureCompensation().IsDouble();\n  if (settings->has_exposure_compensation) {\n    const auto exposure_compensation =\n        constraints.exposureCompensation().GetAsDouble();\n    if (exposure_compensation < capabilities_.exposureCompensation()->min() ||\n        exposure_compensation > capabilities_.exposureCompensation()->max()) {\n      resolver->Reject(DOMException::Create(\n          kNotSupportedError, \"exposureCompensation setting out of range\"));\n      return;\n    }\n    temp_constraints.setExposureCompensation(\n        constraints.exposureCompensation());\n    settings->exposure_compensation = exposure_compensation;\n  }\n  settings->has_color_temperature = constraints.hasColorTemperature() &&\n                                    constraints.colorTemperature().IsDouble();\n  if (settings->has_color_temperature) {\n    const auto color_temperature = constraints.colorTemperature().GetAsDouble();\n    if (color_temperature < capabilities_.colorTemperature()->min() ||\n        color_temperature > capabilities_.colorTemperature()->max()) {\n      resolver->Reject(DOMException::Create(\n          kNotSupportedError, \"colorTemperature setting out of range\"));\n      return;\n    }\n    temp_constraints.setColorTemperature(constraints.colorTemperature());\n    settings->color_temperature = color_temperature;\n  }\n  settings->has_iso = constraints.hasIso() && constraints.iso().IsDouble();\n  if (settings->has_iso) {\n    const auto iso = constraints.iso().GetAsDouble();\n    if (iso < capabilities_.iso()->min() || iso > capabilities_.iso()->max()) {\n      resolver->Reject(\n          DOMException::Create(kNotSupportedError, \"iso setting out of range\"));\n      return;\n    }\n    temp_constraints.setIso(constraints.iso());\n    settings->iso = iso;\n  }\n\n  settings->has_brightness =\n      constraints.hasBrightness() && constraints.brightness().IsDouble();\n  if (settings->has_brightness) {\n    const auto brightness = constraints.brightness().GetAsDouble();\n    if (brightness < capabilities_.brightness()->min() ||\n        brightness > capabilities_.brightness()->max()) {\n      resolver->Reject(DOMException::Create(kNotSupportedError,\n                                            \"brightness setting out of range\"));\n      return;\n    }\n    temp_constraints.setBrightness(constraints.brightness());\n    settings->brightness = brightness;\n  }\n  settings->has_contrast =\n      constraints.hasContrast() && constraints.contrast().IsDouble();\n  if (settings->has_contrast) {\n    const auto contrast = constraints.contrast().GetAsDouble();\n    if (contrast < capabilities_.contrast()->min() ||\n        contrast > capabilities_.contrast()->max()) {\n      resolver->Reject(DOMException::Create(kNotSupportedError,\n                                            \"contrast setting out of range\"));\n      return;\n    }\n    temp_constraints.setContrast(constraints.contrast());\n    settings->contrast = contrast;\n  }\n  settings->has_saturation =\n      constraints.hasSaturation() && constraints.saturation().IsDouble();\n  if (settings->has_saturation) {\n    const auto saturation = constraints.saturation().GetAsDouble();\n    if (saturation < capabilities_.saturation()->min() ||\n        saturation > capabilities_.saturation()->max()) {\n      resolver->Reject(DOMException::Create(kNotSupportedError,\n                                            \"saturation setting out of range\"));\n      return;\n    }\n    temp_constraints.setSaturation(constraints.saturation());\n    settings->saturation = saturation;\n  }\n  settings->has_sharpness =\n      constraints.hasSharpness() && constraints.sharpness().IsDouble();\n  if (settings->has_sharpness) {\n    const auto sharpness = constraints.sharpness().GetAsDouble();\n    if (sharpness < capabilities_.sharpness()->min() ||\n        sharpness > capabilities_.sharpness()->max()) {\n      resolver->Reject(DOMException::Create(kNotSupportedError,\n                                            \"sharpness setting out of range\"));\n      return;\n    }\n    temp_constraints.setSharpness(constraints.sharpness());\n    settings->sharpness = sharpness;\n  }\n\n  settings->has_zoom = constraints.hasZoom() && constraints.zoom().IsDouble();\n  if (settings->has_zoom) {\n    const auto zoom = constraints.zoom().GetAsDouble();\n    if (zoom < capabilities_.zoom()->min() ||\n        zoom > capabilities_.zoom()->max()) {\n      resolver->Reject(DOMException::Create(kNotSupportedError,\n                                            \"zoom setting out of range\"));\n      return;\n    }\n    temp_constraints.setZoom(constraints.zoom());\n    settings->zoom = zoom;\n  }\n\n  settings->has_torch =\n      constraints.hasTorch() && constraints.torch().IsBoolean();\n  if (settings->has_torch) {\n    const auto torch = constraints.torch().GetAsBoolean();\n    if (torch && !capabilities_.torch()) {\n      resolver->Reject(\n          DOMException::Create(kNotSupportedError, \"torch not supported\"));\n      return;\n    }\n    temp_constraints.setTorch(constraints.torch());\n    settings->torch = torch;\n  }\n\n  current_constraints_ = temp_constraints;\n\n  service_requests_.insert(resolver);\n \n   MediaTrackConstraints resolver_constraints;\n   resolver_constraints.setAdvanced(constraints_vector);\n  auto resolver_cb = WTF::Bind(&ImageCapture::ResolveWithMediaTrackConstraints,\n                               WrapPersistent(this), resolver_constraints);\n \n   service_->SetOptions(\n       stream_track_->Component()->Source()->Id(), std::move(settings),\n      ConvertToBaseCallback(WTF::Bind(\n          &ImageCapture::OnMojoSetOptions, WrapPersistent(this),\n          WrapPersistent(resolver), WTF::Passed(std::move(resolver_cb)),\n          false /* trigger_take_photo */)));\n}\n", "target": 1, "idx": 186940}
{"func": "static void bt_for_each(struct blk_mq_hw_ctx *hctx,\n\t\tstruct blk_mq_bitmap_tags *bt, unsigned int off,\n\t\tbusy_iter_fn *fn, void *data, bool reserved)\n{\n\tstruct request *rq;\n\tint bit, i;\n\n\tfor (i = 0; i < bt->map_nr; i++) {\n\t\tstruct blk_align_bitmap *bm = &bt->map[i];\n\n \t\tfor (bit = find_first_bit(&bm->word, bm->depth);\n \t\t     bit < bm->depth;\n \t\t     bit = find_next_bit(&bm->word, bm->depth, bit + 1)) {\n\t\t     \trq = blk_mq_tag_to_rq(hctx->tags, off + bit);\n \t\t\tif (rq->q == hctx->queue)\n \t\t\t\tfn(hctx, rq, data, reserved);\n \t\t}\n\n\t\toff += (1 << bt->bits_per_word);\n\t}\n}\n", "target": 1, "idx": 182627}
{"func": "xdr_dpol_arg(XDR *xdrs, dpol_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_nullstring(xdrs, &objp->name)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n", "target": 0, "idx": 46049}
{"func": "void Vp9Parser::ReadSegmentationMap() {\n   for (size_t i = 0; i < Vp9Segmentation::kNumTreeProbs; i++) {\n    segmentation_.tree_probs[i] =\n         reader_.ReadBool() ? reader_.ReadLiteral(8) : kVp9MaxProb;\n   }\n \n   for (size_t i = 0; i < Vp9Segmentation::kNumPredictionProbs; i++)\n    segmentation_.pred_probs[i] = kVp9MaxProb;\n \n  segmentation_.temporal_update = reader_.ReadBool();\n  if (segmentation_.temporal_update) {\n     for (size_t i = 0; i < Vp9Segmentation::kNumPredictionProbs; i++) {\n       if (reader_.ReadBool())\n        segmentation_.pred_probs[i] = reader_.ReadLiteral(8);\n     }\n   }\n }\n", "target": 1, "idx": 183539}
{"func": "PS_SERIALIZER_DECODE_FUNC(php_binary) /* {{{ */\n{\n\tconst char *p;\n\tchar *name;\n\tconst char *endptr = val + vallen;\n\tzval *current;\n\tint namelen;\n\tint has_value;\n\tphp_unserialize_data_t var_hash;\n\n\tPHP_VAR_UNSERIALIZE_INIT(var_hash);\n\n\tfor (p = val; p < endptr; ) {\n\t\tzval **tmp;\n                namelen = ((unsigned char)(*p)) & (~PS_BIN_UNDEF);\n \n                if (namelen < 0 || namelen > PS_BIN_MAX || (p + namelen) >= endptr) {\n                        return FAILURE;\n                }\n\n\t\tname = estrndup(p + 1, namelen);\n\n\t\tp += namelen + 1;\n\n\t\tif (zend_hash_find(&EG(symbol_table), name, namelen + 1, (void **) &tmp) == SUCCESS) {\n\t\t\tif ((Z_TYPE_PP(tmp) == IS_ARRAY && Z_ARRVAL_PP(tmp) == &EG(symbol_table)) || *tmp == PS(http_session_vars)) {\n\t\t\t\tefree(name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (has_value) {\n\t\t\tALLOC_INIT_ZVAL(current);\n\t\t\tif (php_var_unserialize(&current, (const unsigned char **) &p, (const unsigned char *) endptr, &var_hash TSRMLS_CC)) {\n\t\t\t\tphp_set_session_var(name, namelen, current, &var_hash  TSRMLS_CC);\n\t\t\t} else {\n\t\t\t\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tvar_push_dtor_no_addref(&var_hash, &current);\n\t\t}\n\t\tPS_ADD_VARL(name, namelen);\n\t\tefree(name);\n\t}\n\n\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\n\treturn SUCCESS;\n}\n/* }}} */\n", "target": 1, "idx": 178153}
{"func": " static void parse_cfg(int flags, int argc, const char **argv, cfg_t *cfg) {\n   int i;\n   memset(cfg, 0, sizeof(cfg_t));\n   cfg->debug_file = stderr;\n \n  for (i = 0; i < argc; i++) {\n    if (strncmp(argv[i], \"max_devices=\", 12) == 0)\n      sscanf(argv[i], \"max_devices=%u\", &cfg->max_devs);\n    if (strcmp(argv[i], \"manual\") == 0)\n      cfg->manual = 1;\n    if (strcmp(argv[i], \"debug\") == 0)\n      cfg->debug = 1;\n    if (strcmp(argv[i], \"nouserok\") == 0)\n      cfg->nouserok = 1;\n    if (strcmp(argv[i], \"openasuser\") == 0)\n      cfg->openasuser = 1;\n    if (strcmp(argv[i], \"alwaysok\") == 0)\n      cfg->alwaysok = 1;\n    if (strcmp(argv[i], \"interactive\") == 0)\n      cfg->interactive = 1;\n    if (strcmp(argv[i], \"cue\") == 0)\n      cfg->cue = 1;\n    if (strcmp(argv[i], \"nodetect\") == 0)\n      cfg->nodetect = 1;\n    if (strncmp(argv[i], \"authfile=\", 9) == 0)\n      cfg->auth_file = argv[i] + 9;\n    if (strncmp(argv[i], \"authpending_file=\", 17) == 0)\n      cfg->authpending_file = argv[i] + 17;\n    if (strncmp(argv[i], \"origin=\", 7) == 0)\n      cfg->origin = argv[i] + 7;\n    if (strncmp(argv[i], \"appid=\", 6) == 0)\n      cfg->appid = argv[i] + 6;\n    if (strncmp(argv[i], \"prompt=\", 7) == 0)\n      cfg->prompt = argv[i] + 7;\n    if (strncmp (argv[i], \"debug_file=\", 11) == 0) {\n      const char *filename = argv[i] + 11;\n      if(strncmp (filename, \"stdout\", 6) == 0) {\n        cfg->debug_file = stdout;\n      }\n      else if(strncmp (filename, \"stderr\", 6) == 0) {\n        cfg->debug_file = stderr;\n      }\n      else if( strncmp (filename, \"syslog\", 6) == 0) {\n         cfg->debug_file = (FILE *)-1;\n       }\n       else {\n        struct stat st;\n        FILE *file;\n        if(lstat(filename, &st) == 0) {\n          if(S_ISREG(st.st_mode)) {\n            file = fopen(filename, \"a\");\n            if(file != NULL) {\n              cfg->debug_file = file;\n            }\n           }\n         }\n       }\n    }\n  }\n\n  if (cfg->debug) {\n    D(cfg->debug_file, \"called.\");\n    D(cfg->debug_file, \"flags %d argc %d\", flags, argc);\n    for (i = 0; i < argc; i++) {\n      D(cfg->debug_file, \"argv[%d]=%s\", i, argv[i]);\n    }\n    D(cfg->debug_file, \"max_devices=%d\", cfg->max_devs);\n    D(cfg->debug_file, \"debug=%d\", cfg->debug);\n    D(cfg->debug_file, \"interactive=%d\", cfg->interactive);\n    D(cfg->debug_file, \"cue=%d\", cfg->cue);\n    D(cfg->debug_file, \"nodetect=%d\", cfg->nodetect);\n    D(cfg->debug_file, \"manual=%d\", cfg->manual);\n    D(cfg->debug_file, \"nouserok=%d\", cfg->nouserok);\n    D(cfg->debug_file, \"openasuser=%d\", cfg->openasuser);\n    D(cfg->debug_file, \"alwaysok=%d\", cfg->alwaysok);\n    D(cfg->debug_file, \"authfile=%s\", cfg->auth_file ? cfg->auth_file : \"(null)\");\n    D(cfg->debug_file, \"authpending_file=%s\", cfg->authpending_file ? cfg->authpending_file : \"(null)\");\n    D(cfg->debug_file, \"origin=%s\", cfg->origin ? cfg->origin : \"(null)\");\n     D(cfg->debug_file, \"appid=%s\", cfg->appid ? cfg->appid : \"(null)\");\n     D(cfg->debug_file, \"prompt=%s\", cfg->prompt ? cfg->prompt : \"(null)\");\n   }\n }\n", "target": 1, "idx": 182834}
{"func": "static int __driver_rfc4106_decrypt(struct aead_request *req)\n{\n\tu8 one_entry_in_sg = 0;\n\tu8 *src, *dst, *assoc;\n\tunsigned long tempCipherLen = 0;\n\t__be32 counter = cpu_to_be32(1);\n\tint retval = 0;\n\tstruct crypto_aead *tfm = crypto_aead_reqtfm(req);\n\tstruct aesni_rfc4106_gcm_ctx *ctx = aesni_rfc4106_gcm_ctx_get(tfm);\n\tu32 key_len = ctx->aes_key_expanded.key_length;\n\tvoid *aes_ctx = &(ctx->aes_key_expanded);\n\tunsigned long auth_tag_len = crypto_aead_authsize(tfm);\n\tu8 iv_and_authTag[32+AESNI_ALIGN];\n\tu8 *iv = (u8 *) PTR_ALIGN((u8 *)iv_and_authTag, AESNI_ALIGN);\n\tu8 *authTag = iv + 16;\n\tstruct scatter_walk src_sg_walk;\n\tstruct scatter_walk assoc_sg_walk;\n\tstruct scatter_walk dst_sg_walk;\n\tunsigned int i;\n\n\tif (unlikely((req->cryptlen < auth_tag_len) ||\n\t\t(req->assoclen != 8 && req->assoclen != 12)))\n\t\treturn -EINVAL;\n\tif (unlikely(auth_tag_len != 8 && auth_tag_len != 12 && auth_tag_len != 16))\n\t        return -EINVAL;\n\tif (unlikely(key_len != AES_KEYSIZE_128 &&\n\t             key_len != AES_KEYSIZE_192 &&\n\t             key_len != AES_KEYSIZE_256))\n\t        return -EINVAL;\n\n\t/* Assuming we are supporting rfc4106 64-bit extended */\n\t/* sequence numbers We need to have the AAD length */\n\t/* equal to 8 or 12 bytes */\n\n\ttempCipherLen = (unsigned long)(req->cryptlen - auth_tag_len);\n\t/* IV below built */\n\tfor (i = 0; i < 4; i++)\n\t\t*(iv+i) = ctx->nonce[i];\n\tfor (i = 0; i < 8; i++)\n\t\t*(iv+4+i) = req->iv[i];\n\t*((__be32 *)(iv+12)) = counter;\n\n\tif ((sg_is_last(req->src)) && (sg_is_last(req->assoc))) {\n\t\tone_entry_in_sg = 1;\n\t\tscatterwalk_start(&src_sg_walk, req->src);\n\t\tscatterwalk_start(&assoc_sg_walk, req->assoc);\n\t\tsrc = scatterwalk_map(&src_sg_walk);\n\t\tassoc = scatterwalk_map(&assoc_sg_walk);\n\t\tdst = src;\n\t\tif (unlikely(req->src != req->dst)) {\n\t\t\tscatterwalk_start(&dst_sg_walk, req->dst);\n\t\t\tdst = scatterwalk_map(&dst_sg_walk);\n\t\t}\n\n\t} else {\n\t\t/* Allocate memory for src, dst, assoc */\n \t\tsrc = kmalloc(req->cryptlen + req->assoclen, GFP_ATOMIC);\n \t\tif (!src)\n \t\t\treturn -ENOMEM;\n\t\tassoc = (src + req->cryptlen + auth_tag_len);\n \t\tscatterwalk_map_and_copy(src, req->src, 0, req->cryptlen, 0);\n \t\tscatterwalk_map_and_copy(assoc, req->assoc, 0,\n \t\t\treq->assoclen, 0);\n\t\tdst = src;\n\t}\n\n\taesni_gcm_dec_tfm(aes_ctx, dst, src, tempCipherLen, iv,\n\t\tctx->hash_subkey, assoc, (unsigned long)req->assoclen,\n\t\tauthTag, auth_tag_len);\n\n\t/* Compare generated tag with passed in tag. */\n\tretval = crypto_memneq(src + tempCipherLen, authTag, auth_tag_len) ?\n\t\t-EBADMSG : 0;\n\n\tif (one_entry_in_sg) {\n\t\tif (unlikely(req->src != req->dst)) {\n\t\t\tscatterwalk_unmap(dst);\n\t\t\tscatterwalk_done(&dst_sg_walk, 0, 0);\n\t\t}\n\t\tscatterwalk_unmap(src);\n\t\tscatterwalk_unmap(assoc);\n \t\tscatterwalk_done(&src_sg_walk, 0, 0);\n \t\tscatterwalk_done(&assoc_sg_walk, 0, 0);\n \t} else {\n\t\tscatterwalk_map_and_copy(dst, req->dst, 0, req->cryptlen, 1);\n \t\tkfree(src);\n \t}\n \treturn retval;\n}\n", "target": 1, "idx": 179798}
{"func": "  void FireInvalidateUnknownVersion(const char* type_name) {\n    const invalidation::ObjectId object_id(\n        ipc::invalidation::ObjectSource::CHROME_SYNC, type_name);\n    invalidation::AckHandle ack_handle(\"fakedata\");\n    EXPECT_CALL(mock_invalidation_client_, Acknowledge(ack_handle));\n    client_.InvalidateUnknownVersion(&mock_invalidation_client_, object_id,\n                                      ack_handle);\n   }\n", "target": 1, "idx": 184522}
{"func": " void WebPluginDelegateProxy::OnGetWindowScriptNPObject(\n    int route_id, bool* success, intptr_t* npobject_ptr) {\n   *success = false;\n   NPObject* npobject = NULL;\n   if (plugin_)\n    npobject = plugin_->GetWindowScriptNPObject();\n\n  if (!npobject)\n    return;\n\n   window_script_object_ = (new NPObjectStub(\n       npobject, channel_host_.get(), route_id, 0, page_url_))->AsWeakPtr();\n   *success = true;\n  *npobject_ptr = reinterpret_cast<intptr_t>(npobject);\n }\n", "target": 1, "idx": 183576}
{"func": "static unsigned char *DecodeImage(Image *blob,Image *image,\n  size_t bytes_per_line,const unsigned int bits_per_pixel,size_t *extent)\n{\n  MagickSizeType\n    number_pixels;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p,\n    *q;\n\n  size_t\n    bytes_per_pixel,\n    length,\n    row_bytes,\n    scanline_length,\n    width;\n\n  ssize_t\n    count,\n    j,\n    y;\n\n  unsigned char\n    *pixels,\n    *scanline;\n\n  /*\n    Determine pixel buffer size.\n  */\n  if (bits_per_pixel <= 8)\n    bytes_per_line&=0x7fff;\n  width=image->columns;\n  bytes_per_pixel=1;\n  if (bits_per_pixel == 16)\n    {\n      bytes_per_pixel=2;\n      width*=2;\n    }\n  else\n    if (bits_per_pixel == 32)\n      width*=image->matte != MagickFalse ? 4 : 3;\n  if (bytes_per_line == 0)\n    bytes_per_line=width;\n  row_bytes=(size_t) (image->columns | 0x8000);\n  if (image->storage_class == DirectClass)\n    row_bytes=(size_t) ((4*image->columns) | 0x8000);\n  /*\n    Allocate pixel and scanline buffer.\n  */\n  pixels=(unsigned char *) AcquireQuantumMemory(image->rows,row_bytes*\n    sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    return((unsigned char *) NULL);\n  *extent=row_bytes*image->rows*sizeof(*pixels);\n  (void) ResetMagickMemory(pixels,0,*extent);\n  scanline=(unsigned char *) AcquireQuantumMemory(row_bytes,2*\n    sizeof(*scanline));\n  if (scanline == (unsigned char *) NULL)\n    return((unsigned char *) NULL);\n  if (bytes_per_line < 8)\n    {\n      /*\n        Pixels are already uncompressed.\n      */\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=pixels+y*width;\n        number_pixels=bytes_per_line;\n        count=ReadBlob(blob,(size_t) number_pixels,scanline);\n        if (count != (ssize_t) number_pixels)\n          {\n            (void) ThrowMagickException(&image->exception,GetMagickModule(),\n              CorruptImageError,\"UnableToUncompressImage\",\"`%s'\",\n              image->filename);\n            break;\n          }\n        p=ExpandBuffer(scanline,&number_pixels,bits_per_pixel);\n        if ((q+number_pixels) > (pixels+(*extent)))\n          {\n            (void) ThrowMagickException(&image->exception,GetMagickModule(),\n              CorruptImageError,\"UnableToUncompressImage\",\"`%s'\",\n              image->filename);\n            break;\n          }\n        (void) CopyMagickMemory(q,p,(size_t) number_pixels);\n      }\n      scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n      return(pixels);\n    }\n  /*\n    Uncompress RLE pixels into uncompressed pixel buffer.\n  */\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    q=pixels+y*width;\n    if (bytes_per_line > 200)\n      scanline_length=ReadBlobMSBShort(blob);\n    else\n      scanline_length=1UL*ReadBlobByte(blob);\n    if (scanline_length >= row_bytes)\n      {\n        (void) ThrowMagickException(&image->exception,GetMagickModule(),\n          CorruptImageError,\"UnableToUncompressImage\",\"`%s'\",image->filename);\n        break;\n      }\n    count=ReadBlob(blob,scanline_length,scanline);\n    if (count != (ssize_t) scanline_length)\n      {\n        (void) ThrowMagickException(&image->exception,GetMagickModule(),\n          CorruptImageError,\"UnableToUncompressImage\",\"`%s'\",image->filename);\n        break;\n      }\n    for (j=0; j < (ssize_t) scanline_length; )\n      if ((scanline[j] & 0x80) == 0)\n        {\n          length=(size_t) ((scanline[j] & 0xff)+1);\n          number_pixels=length*bytes_per_pixel;\n          p=ExpandBuffer(scanline+j+1,&number_pixels,bits_per_pixel);\n          if ((q-pixels+number_pixels) <= *extent)\n            (void) CopyMagickMemory(q,p,(size_t) number_pixels);\n          q+=number_pixels;\n          j+=(ssize_t) (length*bytes_per_pixel+1);\n        }\n      else\n        {\n          length=(size_t) (((scanline[j] ^ 0xff) & 0xff)+2);\n          number_pixels=bytes_per_pixel;\n          p=ExpandBuffer(scanline+j+1,&number_pixels,bits_per_pixel);\n          for (i=0; i < (ssize_t) length; i++)\n          {\n            if ((q-pixels+number_pixels) <= *extent)\n              (void) CopyMagickMemory(q,p,(size_t) number_pixels);\n            q+=number_pixels;\n          }\n          j+=(ssize_t) bytes_per_pixel+1;\n        }\n  }\n  scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n  return(pixels);\n}\n", "target": 0, "idx": 62682}
{"func": "struct sock *llc_sk_alloc(struct net *net, int family, gfp_t priority, struct proto *prot, int kern)\n{\n\tstruct sock *sk = sk_alloc(net, family, priority, prot, kern);\n\n\tif (!sk)\n\t\tgoto out;\n\tllc_sk_init(sk);\n\tsock_init_data(NULL, sk);\n#ifdef LLC_REFCNT_DEBUG\n\tatomic_inc(&llc_sock_nr);\n\tprintk(KERN_DEBUG \"LLC socket %p created in %s, now we have %d alive\\n\", sk,\n\t\t__func__, atomic_read(&llc_sock_nr));\n#endif\nout:\n\treturn sk;\n}\n", "target": 0, "idx": 68211}
{"func": "static uint32_t kvm_get_exit_reason(struct kvm_vcpu *vcpu)\n{\n\tstruct exit_ctl_data *p_exit_data;\n\n\tp_exit_data = kvm_get_exit_data(vcpu);\n\treturn p_exit_data->exit_reason;\n}\n", "target": 0, "idx": 20622}
{"func": "static MagickBooleanType WritePNMImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  char\n    buffer[MagickPathExtent],\n    format,\n    magick[MagickPathExtent];\n\n  const char\n    *value;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  Quantum\n    index;\n\n  QuantumAny\n    pixel;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  register unsigned char\n    *q;\n\n  size_t\n    extent,\n    imageListLength,\n    packet_size;\n\n  ssize_t\n    count,\n    y;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  scene=0;\n  imageListLength=GetImageListLength(image);\n  do\n  {\n    QuantumAny\n      max_value;\n\n    /*\n      Write PNM file header.\n    */\n    packet_size=3;\n    quantum_type=RGBQuantum;\n    (void) CopyMagickString(magick,image_info->magick,MagickPathExtent);\n    max_value=GetQuantumRange(image->depth);\n    switch (magick[1])\n    {\n      case 'A':\n      case 'a':\n      {\n        format='7';\n        break;\n      }\n      case 'B':\n      case 'b':\n      {\n        format='4';\n        if (image_info->compression == NoCompression)\n          format='1';\n        break;\n      }\n      case 'F':\n      case 'f':\n      {\n        format='F';\n        if (SetImageGray(image,exception) != MagickFalse)\n          format='f';\n        break;\n      }\n      case 'G':\n      case 'g':\n      {\n        format='5';\n        if (image_info->compression == NoCompression)\n          format='2';\n        break;\n      }\n      case 'N':\n      case 'n':\n      {\n        if ((image_info->type != TrueColorType) &&\n            (SetImageGray(image,exception) != MagickFalse))\n          {\n            format='5';\n            if (image_info->compression == NoCompression)\n              format='2';\n            if (SetImageMonochrome(image,exception) != MagickFalse)\n              {\n                format='4';\n                if (image_info->compression == NoCompression)\n                  format='1';\n              }\n            break;\n          }\n      }\n      default:\n      {\n        format='6';\n        if (image_info->compression == NoCompression)\n          format='3';\n        break;\n      }\n    }\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"P%c\\n\",format);\n    (void) WriteBlobString(image,buffer);\n    value=GetImageProperty(image,\"comment\",exception);\n    if (value != (const char *) NULL)\n      {\n        register const char\n          *p;\n\n        /*\n          Write comments to file.\n        */\n        (void) WriteBlobByte(image,'#');\n        for (p=value; *p != '\\0'; p++)\n        {\n          (void) WriteBlobByte(image,(unsigned char) *p);\n          if ((*p == '\\n') || (*p == '\\r'))\n            (void) WriteBlobByte(image,'#');\n        }\n        (void) WriteBlobByte(image,'\\n');\n      }\n    if (format != '7')\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g %.20g\\n\",\n          (double) image->columns,(double) image->rows);\n        (void) WriteBlobString(image,buffer);\n      }\n    else\n      {\n        char\n          type[MagickPathExtent];\n\n        /*\n          PAM header.\n        */\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"WIDTH %.20g\\nHEIGHT %.20g\\n\",(double) image->columns,(double)\n          image->rows);\n        (void) WriteBlobString(image,buffer);\n        quantum_type=GetQuantumType(image,exception);\n        switch (quantum_type)\n        {\n          case CMYKQuantum:\n          case CMYKAQuantum:\n          {\n            packet_size=4;\n            (void) CopyMagickString(type,\"CMYK\",MagickPathExtent);\n            break;\n          }\n          case GrayQuantum:\n          case GrayAlphaQuantum:\n          {\n            packet_size=1;\n            (void) CopyMagickString(type,\"GRAYSCALE\",MagickPathExtent);\n            if (IdentifyImageMonochrome(image,exception) != MagickFalse)\n              (void) CopyMagickString(type,\"BLACKANDWHITE\",MagickPathExtent);\n            break;\n          }\n          default:\n          {\n            quantum_type=RGBQuantum;\n            if (image->alpha_trait != UndefinedPixelTrait)\n              quantum_type=RGBAQuantum;\n            packet_size=3;\n            (void) CopyMagickString(type,\"RGB\",MagickPathExtent);\n            break;\n          }\n        }\n        if (image->alpha_trait != UndefinedPixelTrait)\n          {\n            packet_size++;\n            (void) ConcatenateMagickString(type,\"_ALPHA\",MagickPathExtent);\n          }\n        if (image->depth > 32)\n          image->depth=32;\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"DEPTH %.20g\\nMAXVAL %.20g\\n\",(double) packet_size,(double)\n          ((MagickOffsetType) GetQuantumRange(image->depth)));\n        (void) WriteBlobString(image,buffer);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"TUPLTYPE %s\\nENDHDR\\n\",type);\n        (void) WriteBlobString(image,buffer);\n      }\n    /*\n      Convert runextent encoded to PNM raster pixels.\n    */\n    switch (format)\n    {\n      case '1':\n      {\n        unsigned char\n          pixels[2048];\n\n        /*\n          Convert image to a PBM image.\n        */\n        (void) SetImageType(image,BilevelType,exception);\n        q=pixels;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n           {\n             *q++=(unsigned char) (GetPixelLuma(image,p) >= (QuantumRange/2.0) ?\n               '0' : '1');\n            *q++=' ';\n             if ((q-pixels+1) >= (ssize_t) sizeof(pixels))\n               {\n                 *q++='\\n';\n                 (void) WriteBlob(image,q-pixels,pixels);\n                 q=pixels;\n               }\n             p+=GetPixelChannels(image);\n           }\n           *q++='\\n';\n          (void) WriteBlob(image,q-pixels,pixels);\n          q=pixels;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        if (q != pixels)\n          {\n            *q++='\\n';\n            (void) WriteBlob(image,q-pixels,pixels);\n          }\n        break;\n      }\n      case '2':\n      {\n        unsigned char\n          pixels[2048];\n\n        /*\n          Convert image to a PGM image.\n        */\n        if (image->depth <= 8)\n          (void) WriteBlobString(image,\"255\\n\");\n        else\n          if (image->depth <= 16)\n            (void) WriteBlobString(image,\"65535\\n\");\n          else\n            (void) WriteBlobString(image,\"4294967295\\n\");\n        q=pixels;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            index=ClampToQuantum(GetPixelLuma(image,p));\n            if (image->depth <= 8)\n              count=(ssize_t) FormatLocaleString(buffer,MagickPathExtent,\"%u \",\n                ScaleQuantumToChar(index));\n            else\n              if (image->depth <= 16)\n                count=(ssize_t) FormatLocaleString(buffer,MagickPathExtent,\n                  \"%u \",ScaleQuantumToShort(index));\n              else\n                count=(ssize_t) FormatLocaleString(buffer,MagickPathExtent,\n                  \"%u \",ScaleQuantumToLong(index));\n            extent=(size_t) count;\n            if ((q-pixels+extent+1) >= sizeof(pixels))\n              {\n                *q++='\\n';\n                (void) WriteBlob(image,q-pixels,pixels);\n                q=pixels;\n              }\n            (void) strncpy((char *) q,buffer,extent);\n            q+=extent;\n            p+=GetPixelChannels(image);\n          }\n          *q++='\\n';\n          (void) WriteBlob(image,q-pixels,pixels);\n          q=pixels;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        if (q != pixels)\n          {\n            *q++='\\n';\n            (void) WriteBlob(image,q-pixels,pixels);\n          }\n        break;\n      }\n      case '3':\n      {\n        unsigned char\n          pixels[2048];\n\n        /*\n          Convert image to a PNM image.\n        */\n        (void) TransformImageColorspace(image,sRGBColorspace,exception);\n        if (image->depth <= 8)\n          (void) WriteBlobString(image,\"255\\n\");\n        else\n          if (image->depth <= 16)\n            (void) WriteBlobString(image,\"65535\\n\");\n          else\n            (void) WriteBlobString(image,\"4294967295\\n\");\n        q=pixels;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            if (image->depth <= 8)\n              count=(ssize_t) FormatLocaleString(buffer,MagickPathExtent,\n                \"%u %u %u \",ScaleQuantumToChar(GetPixelRed(image,p)),\n                ScaleQuantumToChar(GetPixelGreen(image,p)),\n                ScaleQuantumToChar(GetPixelBlue(image,p)));\n            else\n              if (image->depth <= 16)\n                count=(ssize_t) FormatLocaleString(buffer,MagickPathExtent,\n                  \"%u %u %u \",ScaleQuantumToShort(GetPixelRed(image,p)),\n                  ScaleQuantumToShort(GetPixelGreen(image,p)),\n                  ScaleQuantumToShort(GetPixelBlue(image,p)));\n              else\n                count=(ssize_t) FormatLocaleString(buffer,MagickPathExtent,\n                  \"%u %u %u \",ScaleQuantumToLong(GetPixelRed(image,p)),\n                  ScaleQuantumToLong(GetPixelGreen(image,p)),\n                  ScaleQuantumToLong(GetPixelBlue(image,p)));\n            extent=(size_t) count;\n            if ((q-pixels+extent+2) >= sizeof(pixels))\n              {\n                *q++='\\n';\n                (void) WriteBlob(image,q-pixels,pixels);\n                q=pixels;\n              }\n            (void) strncpy((char *) q,buffer,extent);\n            q+=extent;\n            p+=GetPixelChannels(image);\n          }\n          *q++='\\n';\n          (void) WriteBlob(image,q-pixels,pixels);\n          q=pixels;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        if (q != pixels)\n          {\n            *q++='\\n';\n            (void) WriteBlob(image,q-pixels,pixels);\n          }\n        break;\n      }\n      case '4':\n      {\n        register unsigned char\n          *pixels;\n\n        /*\n          Convert image to a PBM image.\n        */\n        (void) SetImageType(image,BilevelType,exception);\n        image->depth=1;\n        quantum_info=AcquireQuantumInfo(image_info,image);\n        if (quantum_info == (QuantumInfo *) NULL)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) SetQuantumEndian(image,quantum_info,MSBEndian);\n        quantum_info->min_is_white=MagickTrue;\n        pixels=GetQuantumPixels(quantum_info);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          extent=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            GrayQuantum,pixels,exception);\n          count=WriteBlob(image,extent,pixels);\n          if (count != (ssize_t) extent)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        quantum_info=DestroyQuantumInfo(quantum_info);\n        break;\n      }\n      case '5':\n      {\n        register unsigned char\n          *pixels;\n\n        /*\n          Convert image to a PGM image.\n        */\n        if (image->depth > 32)\n          image->depth=32;\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g\\n\",(double)\n          ((MagickOffsetType) GetQuantumRange(image->depth)));\n        (void) WriteBlobString(image,buffer);\n        quantum_info=AcquireQuantumInfo(image_info,image);\n        if (quantum_info == (QuantumInfo *) NULL)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) SetQuantumEndian(image,quantum_info,MSBEndian);\n        quantum_info->min_is_white=MagickTrue;\n        pixels=GetQuantumPixels(quantum_info);\n        extent=GetQuantumExtent(image,quantum_info,GrayQuantum);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels;\n          switch (image->depth)\n          {\n            case 8:\n            case 16:\n            case 32:\n            {\n              extent=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                GrayQuantum,pixels,exception);\n              break;\n            }\n            default:\n            {\n              if (image->depth <= 8)\n                {\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    if (IsPixelGray(image,p) == MagickFalse)\n                      pixel=ScaleQuantumToAny(ClampToQuantum(GetPixelLuma(\n                        image,p)),max_value);\n                    else\n                      {\n                        if (image->depth == 8)\n                          pixel=ScaleQuantumToChar(GetPixelRed(image,p));\n                        else\n                          pixel=ScaleQuantumToAny(GetPixelRed(image,p),\n                            max_value);\n                      }\n                    q=PopCharPixel((unsigned char) pixel,q);\n                    p+=GetPixelChannels(image);\n                  }\n                  extent=(size_t) (q-pixels);\n                  break;\n                }\n              if (image->depth <= 16)\n                {\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    if (IsPixelGray(image,p) == MagickFalse)\n                      pixel=ScaleQuantumToAny(ClampToQuantum(GetPixelLuma(image,\n                        p)),max_value);\n                    else\n                      {\n                        if (image->depth == 16)\n                          pixel=ScaleQuantumToShort(GetPixelRed(image,p));\n                        else\n                          pixel=ScaleQuantumToAny(GetPixelRed(image,p),\n                            max_value);\n                      }\n                    q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                    p+=GetPixelChannels(image);\n                  }\n                  extent=(size_t) (q-pixels);\n                  break;\n                }\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                if (IsPixelGray(image,p) == MagickFalse)\n                  pixel=ScaleQuantumToAny(ClampToQuantum(GetPixelLuma(image,p)),\n                    max_value);\n                else\n                  {\n                    if (image->depth == 16)\n                      pixel=ScaleQuantumToLong(GetPixelRed(image,p));\n                    else\n                      pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);\n                  }\n                q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                p+=GetPixelChannels(image);\n              }\n              extent=(size_t) (q-pixels);\n              break;\n            }\n          }\n          count=WriteBlob(image,extent,pixels);\n          if (count != (ssize_t) extent)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        quantum_info=DestroyQuantumInfo(quantum_info);\n        break;\n      }\n      case '6':\n      {\n        register unsigned char\n          *pixels;\n\n        /*\n          Convert image to a PNM image.\n        */\n        (void) TransformImageColorspace(image,sRGBColorspace,exception);\n        if (image->depth > 32)\n          image->depth=32;\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g\\n\",(double)\n          ((MagickOffsetType) GetQuantumRange(image->depth)));\n        (void) WriteBlobString(image,buffer);\n        quantum_info=AcquireQuantumInfo(image_info,image);\n        if (quantum_info == (QuantumInfo *) NULL)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) SetQuantumEndian(image,quantum_info,MSBEndian);\n        pixels=GetQuantumPixels(quantum_info);\n        extent=GetQuantumExtent(image,quantum_info,quantum_type);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels;\n          switch (image->depth)\n          {\n            case 8:\n            case 16:\n            case 32:\n            {\n              extent=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                quantum_type,pixels,exception);\n              break;\n            }\n            default:\n            {\n              if (image->depth <= 8)\n                {\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);\n                    q=PopCharPixel((unsigned char) pixel,q);\n                    pixel=ScaleQuantumToAny(GetPixelGreen(image,p),max_value);\n                    q=PopCharPixel((unsigned char) pixel,q);\n                    pixel=ScaleQuantumToAny(GetPixelBlue(image,p),max_value);\n                    q=PopCharPixel((unsigned char) pixel,q);\n                    p+=GetPixelChannels(image);\n                  }\n                  extent=(size_t) (q-pixels);\n                  break;\n                }\n              if (image->depth <= 16)\n                {\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);\n                    q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                    pixel=ScaleQuantumToAny(GetPixelGreen(image,p),max_value);\n                    q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                    pixel=ScaleQuantumToAny(GetPixelBlue(image,p),max_value);\n                    q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                    p+=GetPixelChannels(image);\n                  }\n                  extent=(size_t) (q-pixels);\n                  break;\n                }\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);\n                q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                pixel=ScaleQuantumToAny(GetPixelGreen(image,p),max_value);\n                q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                pixel=ScaleQuantumToAny(GetPixelBlue(image,p),max_value);\n                q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                p+=GetPixelChannels(image);\n              }\n              extent=(size_t) (q-pixels);\n              break;\n            }\n          }\n          count=WriteBlob(image,extent,pixels);\n          if (count != (ssize_t) extent)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        quantum_info=DestroyQuantumInfo(quantum_info);\n        break;\n      }\n      case '7':\n      {\n        register unsigned char\n          *pixels;\n\n        /*\n          Convert image to a PAM.\n        */\n        if (image->depth > 32)\n          image->depth=32;\n        quantum_info=AcquireQuantumInfo(image_info,image);\n        if (quantum_info == (QuantumInfo *) NULL)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) SetQuantumEndian(image,quantum_info,MSBEndian);\n        pixels=GetQuantumPixels(quantum_info);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels;\n          switch (image->depth)\n          {\n            case 8:\n            case 16:\n            case 32:\n            {\n              extent=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                quantum_type,pixels,exception);\n              break;\n            }\n            default:\n            {\n              switch (quantum_type)\n              {\n                case GrayQuantum:\n                case GrayAlphaQuantum:\n                {\n                  if (image->depth <= 8)\n                    {\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        pixel=ScaleQuantumToAny(ClampToQuantum(GetPixelLuma(\n                          image,p)),max_value);\n                        q=PopCharPixel((unsigned char) pixel,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            pixel=(unsigned char) ScaleQuantumToAny(\n                              GetPixelAlpha(image,p),max_value);\n                            q=PopCharPixel((unsigned char) pixel,q);\n                          }\n                        p+=GetPixelChannels(image);\n                      }\n                      break;\n                    }\n                  if (image->depth <= 16)\n                    {\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        pixel=ScaleQuantumToAny(ClampToQuantum(GetPixelLuma(\n                          image,p)),max_value);\n                        q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            pixel=(unsigned char) ScaleQuantumToAny(\n                              GetPixelAlpha(image,p),max_value);\n                            q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                          }\n                        p+=GetPixelChannels(image);\n                      }\n                      break;\n                    }\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    pixel=ScaleQuantumToAny(ClampToQuantum(GetPixelLuma(image,\n                      p)),max_value);\n                    q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                    if (image->alpha_trait != UndefinedPixelTrait)\n                      {\n                        pixel=(unsigned char) ScaleQuantumToAny(\n                          GetPixelAlpha(image,p),max_value);\n                        q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                      }\n                    p+=GetPixelChannels(image);\n                  }\n                  break;\n                }\n                case CMYKQuantum:\n                case CMYKAQuantum:\n                {\n                  if (image->depth <= 8)\n                    {\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);\n                        q=PopCharPixel((unsigned char) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelGreen(image,p),\n                          max_value);\n                        q=PopCharPixel((unsigned char) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelBlue(image,p),\n                          max_value);\n                        q=PopCharPixel((unsigned char) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelBlack(image,p),\n                          max_value);\n                        q=PopCharPixel((unsigned char) pixel,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            pixel=ScaleQuantumToAny(GetPixelAlpha(image,p),\n                              max_value);\n                            q=PopCharPixel((unsigned char) pixel,q);\n                          }\n                        p+=GetPixelChannels(image);\n                      }\n                      break;\n                    }\n                  if (image->depth <= 16)\n                    {\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);\n                        q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelGreen(image,p),\n                          max_value);\n                        q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelBlue(image,p),\n                          max_value);\n                        q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelBlack(image,p),\n                          max_value);\n                        q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            pixel=ScaleQuantumToAny(GetPixelAlpha(image,p),\n                              max_value);\n                            q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                          }\n                        p+=GetPixelChannels(image);\n                      }\n                      break;\n                    }\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);\n                    q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                    pixel=ScaleQuantumToAny(GetPixelGreen(image,p),max_value);\n                    q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                    pixel=ScaleQuantumToAny(GetPixelBlue(image,p),max_value);\n                    q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                    pixel=ScaleQuantumToAny(GetPixelBlack(image,p),max_value);\n                    q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                    if (image->alpha_trait != UndefinedPixelTrait)\n                      {\n                        pixel=ScaleQuantumToAny(GetPixelAlpha(image,p),\n                          max_value);\n                        q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                      }\n                    p+=GetPixelChannels(image);\n                  }\n                  break;\n                }\n                default:\n                {\n                  if (image->depth <= 8)\n                    {\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);\n                        q=PopCharPixel((unsigned char) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelGreen(image,p),\n                          max_value);\n                        q=PopCharPixel((unsigned char) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelBlue(image,p),\n                          max_value);\n                        q=PopCharPixel((unsigned char) pixel,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            pixel=ScaleQuantumToAny(GetPixelAlpha(image,p),\n                              max_value);\n                            q=PopCharPixel((unsigned char) pixel,q);\n                          }\n                        p+=GetPixelChannels(image);\n                      }\n                      break;\n                    }\n                  if (image->depth <= 16)\n                    {\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);\n                        q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelGreen(image,p),\n                          max_value);\n                        q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelBlue(image,p),\n                          max_value);\n                        q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            pixel=ScaleQuantumToAny(GetPixelAlpha(image,p),\n                              max_value);\n                            q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                          }\n                        p+=GetPixelChannels(image);\n                      }\n                      break;\n                    }\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);\n                    q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                    pixel=ScaleQuantumToAny(GetPixelGreen(image,p),max_value);\n                    q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                    pixel=ScaleQuantumToAny(GetPixelBlue(image,p),max_value);\n                    q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                    if (image->alpha_trait != UndefinedPixelTrait)\n                      {\n                        pixel=ScaleQuantumToAny(GetPixelAlpha(image,p),\n                          max_value);\n                        q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                      }\n                    p+=GetPixelChannels(image);\n                  }\n                  break;\n                }\n              }\n              extent=(size_t) (q-pixels);\n              break;\n            }\n          }\n          count=WriteBlob(image,extent,pixels);\n          if (count != (ssize_t) extent)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        quantum_info=DestroyQuantumInfo(quantum_info);\n        break;\n      }\n      case 'F':\n      case 'f':\n      {\n        register unsigned char\n          *pixels;\n\n        (void) WriteBlobString(image,image->endian == LSBEndian ? \"-1.0\\n\" :\n          \"1.0\\n\");\n        image->depth=32;\n        quantum_type=format == 'f' ? GrayQuantum : RGBQuantum;\n        quantum_info=AcquireQuantumInfo(image_info,image);\n        if (quantum_info == (QuantumInfo *) NULL)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);\n        if (status == MagickFalse)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        pixels=GetQuantumPixels(quantum_info);\n        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          extent=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            quantum_type,pixels,exception);\n          (void) WriteBlob(image,extent,pixels);\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        quantum_info=DestroyQuantumInfo(quantum_info);\n        break;\n      }\n    }\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,imageListLength);\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n", "target": 1, "idx": 182770}
{"func": "void ReleaseProcessIfNeeded() {\n  content::UtilityThread::Get()->ReleaseProcessIfNeeded();\n}\n", "target": 0, "idx": 133843}
{"func": "bool AXNodeObject::isModal() const {\n  if (roleValue() != DialogRole && roleValue() != AlertDialogRole)\n    return false;\n \n   if (hasAttribute(aria_modalAttr)) {\n     const AtomicString& modal = getAttribute(aria_modalAttr);\n    if (equalIgnoringCase(modal, \"true\"))\n       return true;\n    if (equalIgnoringCase(modal, \"false\"))\n       return false;\n   }\n \n  if (getNode() && isHTMLDialogElement(*getNode()))\n    return toElement(getNode())->isInTopLayer();\n\n  return false;\n}\n", "target": 1, "idx": 185794}
{"func": "  void OnDataReceivedFromPeer(const char* data, size_t data_len) {\n    DCHECK(delegate_);\n    delegate_->OnPacketDataReceived(data, data_len);\n  }\n", "target": 0, "idx": 145428}
{"func": "WebMediaPlayer* RenderViewImpl::createMediaPlayer(\n    WebFrame* frame, const WebKit::WebURL& url, WebMediaPlayerClient* client) {\n  FOR_EACH_OBSERVER(\n      RenderViewObserver, observers_, WillCreateMediaPlayer(frame, client));\n\n  const CommandLine* cmd_line = CommandLine::ForCurrentProcess();\n#if defined(ENABLE_WEBRTC)\n  if (MediaStreamImpl::CheckMediaStream(url)) {\n    EnsureMediaStreamImpl();\n    return new webkit_media::WebMediaPlayerMS(\n        frame, client, AsWeakPtr(), media_stream_impl_, new RenderMediaLog());\n  }\n#endif\n\n#if defined(OS_ANDROID)\n  GpuChannelHost* gpu_channel_host =\n      RenderThreadImpl::current()->EstablishGpuChannelSync(\n          CAUSE_FOR_GPU_LAUNCH_VIDEODECODEACCELERATOR_INITIALIZE);\n  if (!gpu_channel_host) {\n    LOG(ERROR) << \"Failed to establish GPU channel for media player\";\n    return NULL;\n  }\n\n  scoped_refptr<cc::ContextProvider> context_provider =\n      RenderThreadImpl::current()->OffscreenContextProviderForMainThread();\n  if (!context_provider->InitializeOnMainThread() ||\n      !context_provider->BindToCurrentThread()) {\n    LOG(ERROR) << \"Failed to get context3d for media player\";\n    return NULL;\n  }\n\n  if (cmd_line->HasSwitch(switches::kInProcessWebGL)) {\n    if (!media_bridge_manager_.get()) {\n      media_bridge_manager_.reset(\n          new webkit_media::MediaPlayerBridgeManagerImpl(1));\n    }\n    return new webkit_media::WebMediaPlayerInProcessAndroid(\n        frame,\n        client,\n        cookieJar(frame),\n        media_player_manager_.get(),\n        media_bridge_manager_.get(),\n        new StreamTextureFactoryImpl(\n            context_provider->Context3d(), gpu_channel_host, routing_id_),\n        cmd_line->HasSwitch(switches::kDisableMediaHistoryLogging));\n  }\n  if (!media_player_proxy_) {\n    media_player_proxy_ = new WebMediaPlayerProxyImplAndroid(\n        this, media_player_manager_.get());\n  }\n  return new webkit_media::WebMediaPlayerImplAndroid(\n      frame,\n      client,\n      media_player_manager_.get(),\n      media_player_proxy_,\n      new StreamTextureFactoryImpl(\n          context_provider->Context3d(), gpu_channel_host, routing_id_));\n#endif\n\n  scoped_refptr<media::AudioRendererSink> sink;\n  if (!cmd_line->HasSwitch(switches::kDisableAudio)) {\n    if (!cmd_line->HasSwitch(switches::kDisableRendererSideMixing)) {\n      sink = RenderThreadImpl::current()->GetAudioRendererMixerManager()->\n          CreateInput(routing_id_);\n      DVLOG(1) << \"Using AudioRendererMixerManager-provided sink: \" << sink;\n    } else {\n      scoped_refptr<RendererAudioOutputDevice> device =\n          AudioDeviceFactory::NewOutputDevice();\n      device->SetSourceRenderView(routing_id_);\n      sink = device;\n      DVLOG(1) << \"Using AudioDeviceFactory-provided sink: \" << sink;\n    }\n  }\n\n  scoped_refptr<media::GpuVideoDecoder::Factories> gpu_factories;\n  WebGraphicsContext3DCommandBufferImpl* context3d = NULL;\n  if (!cmd_line->HasSwitch(switches::kDisableAcceleratedVideoDecode))\n    context3d = RenderThreadImpl::current()->GetGpuVDAContext3D();\n  if (context3d) {\n    scoped_refptr<base::MessageLoopProxy> factories_loop =\n        RenderThreadImpl::current()->compositor_message_loop_proxy();\n    if (!factories_loop)\n      factories_loop = base::MessageLoopProxy::current();\n    GpuChannelHost* gpu_channel_host =\n        RenderThreadImpl::current()->EstablishGpuChannelSync(\n            CAUSE_FOR_GPU_LAUNCH_VIDEODECODEACCELERATOR_INITIALIZE);\n    gpu_factories = new RendererGpuVideoDecoderFactories(\n        gpu_channel_host, factories_loop, context3d);\n  }\n\n  webkit_media::WebMediaPlayerParams params(\n      sink, gpu_factories, new RenderMediaLog());\n  WebMediaPlayer* media_player =\n      GetContentClient()->renderer()->OverrideCreateWebMediaPlayer(\n          this, frame, client, AsWeakPtr(), params);\n  if (!media_player) {\n    media_player = new webkit_media::WebMediaPlayerImpl(\n        frame, client, AsWeakPtr(), params);\n  }\n  return media_player;\n}\n", "target": 0, "idx": 123958}
{"func": "authentic_get_challenge(struct sc_card *card, unsigned char *rnd, size_t len)\n{\n\t/* 'GET CHALLENGE' returns always 24 bytes */\n\tunsigned char rbuf[0x18];\n\tsize_t out_len;\n\tint r;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tr = iso_ops->get_challenge(card, rbuf, sizeof rbuf);\n\tLOG_TEST_RET(card->ctx, r, \"GET CHALLENGE cmd failed\");\n\n\tif (len < (size_t) r) {\n\t\tout_len = len;\n\t} else {\n\t\tout_len = (size_t) r;\n\t}\n\tmemcpy(rnd, rbuf, out_len);\n\n\tLOG_FUNC_RETURN(card->ctx, out_len);\n}\n", "target": 0, "idx": 78186}
{"func": " horDiff8(TIFF* tif, uint8* cp0, tmsize_t cc)\n {\n \tTIFFPredictorState* sp = PredictorState(tif);\n \ttmsize_t stride = sp->stride;\n \tunsigned char* cp = (unsigned char*) cp0;\n \n\tassert((cc%stride)==0);\n \n \tif (cc > stride) {\n \t\tcc -= stride;\n\t\t/*\n\t\t * Pipeline the most common cases.\n\t\t */\n\t\tif (stride == 3) {\n\t\t\tunsigned int r1, g1, b1;\n\t\t\tunsigned int r2 = cp[0];\n\t\t\tunsigned int g2 = cp[1];\n\t\t\tunsigned  int b2 = cp[2];\n\t\t\tdo {\n\t\t\t\tr1 = cp[3]; cp[3] = (unsigned char)((r1-r2)&0xff); r2 = r1;\n\t\t\t\tg1 = cp[4]; cp[4] = (unsigned char)((g1-g2)&0xff); g2 = g1;\n\t\t\t\tb1 = cp[5]; cp[5] = (unsigned char)((b1-b2)&0xff); b2 = b1;\n\t\t\t\tcp += 3;\n\t\t\t} while ((cc -= 3) > 0);\n\t\t} else if (stride == 4) {\n\t\t\tunsigned int r1, g1, b1, a1;\n\t\t\tunsigned int r2 = cp[0];\n\t\t\tunsigned int g2 = cp[1];\n\t\t\tunsigned int b2 = cp[2];\n\t\t\tunsigned int a2 = cp[3];\n\t\t\tdo {\n\t\t\t\tr1 = cp[4]; cp[4] = (unsigned char)((r1-r2)&0xff); r2 = r1;\n\t\t\t\tg1 = cp[5]; cp[5] = (unsigned char)((g1-g2)&0xff); g2 = g1;\n\t\t\t\tb1 = cp[6]; cp[6] = (unsigned char)((b1-b2)&0xff); b2 = b1;\n\t\t\t\ta1 = cp[7]; cp[7] = (unsigned char)((a1-a2)&0xff); a2 = a1;\n\t\t\t\tcp += 4;\n\t\t\t} while ((cc -= 4) > 0);\n\t\t} else {\n\t\t\tcp += cc - 1;\n\t\t\tdo {\n\t\t\t\tREPEAT4(stride, cp[stride] = (unsigned char)((cp[stride] - cp[0])&0xff); cp--)\n \t\t\t} while ((cc -= stride) > 0);\n \t\t}\n \t}\n }\n", "target": 1, "idx": 180059}
{"func": "static inline int nfs4_lock_type(struct file_lock *fl, int block)\n{\n\tif ((fl->fl_type & (F_RDLCK|F_WRLCK|F_UNLCK)) == F_RDLCK)\n\t\treturn block ? NFS4_READW_LT : NFS4_READ_LT;\n\treturn block ? NFS4_WRITEW_LT : NFS4_WRITE_LT;\n}\n", "target": 0, "idx": 23095}
{"func": "PaletteTool::~PaletteTool() {}\n", "target": 0, "idx": 133313}
{"func": "bool WebPagePrivate::dispatchTouchPointAsMouseEventToFullScreenPlugin(PluginView* pluginView, const Platform::TouchPoint& point)\n{\n     NPEvent npEvent;\n     NPMouseEvent mouse;\n \n    switch (point.m_state) {\n     case Platform::TouchPoint::TouchPressed:\n         mouse.type = MOUSE_BUTTON_DOWN;\n         break;\n    case Platform::TouchPoint::TouchReleased:\n        mouse.type = MOUSE_BUTTON_UP;\n        break;\n    case Platform::TouchPoint::TouchMoved:\n        mouse.type = MOUSE_MOTION;\n        break;\n    case Platform::TouchPoint::TouchStationary:\n         return true;\n     }\n \n    mouse.x = point.m_screenPos.x();\n    mouse.y = point.m_screenPos.y();\n     mouse.button = mouse.type != MOUSE_BUTTON_UP;\n     mouse.flags = 0;\n     npEvent.type = NP_MouseEvent;\n    npEvent.data = &mouse;\n\n    pluginView->dispatchFullScreenNPEvent(npEvent);\n    return true;\n}\n", "target": 1, "idx": 184339}
{"func": "PassRefPtr<DocumentFragment> XSLTProcessor::transformToFragment(Node* sourceNode, Document* outputDoc)\n{\n    String resultMIMEType;\n    String resultString;\n    String resultEncoding;\n\n    if (outputDoc->isHTMLDocument())\n        resultMIMEType = \"text/html\";\n \n     if (!transformToString(sourceNode, resultMIMEType, resultString, resultEncoding))\n         return 0;\n    return createFragmentFromSource(resultString, resultMIMEType, outputDoc);\n }\n", "target": 1, "idx": 183902}
{"func": "static Mutex& threadSetMutex()\n{\n    AtomicallyInitializedStaticReference(Mutex, mutex, new Mutex);\n    return mutex;\n}\n", "target": 0, "idx": 138527}
{"func": " bool ChildProcessSecurityPolicyImpl::CanSetAsOriginHeader(int child_id,\n                                                           const GURL& url) {\n   if (!url.is_valid())\n    return false;  // Can't set invalid URLs as origin headers.\n\n  if (url == kAboutSrcDocURL)\n    return false;\n \n  if (CanCommitURL(child_id, url))\n     return true;\n \n  {\n    base::AutoLock lock(lock_);\n    if (base::ContainsKey(schemes_okay_to_appear_as_origin_headers_,\n                          url.scheme())) {\n      return true;\n    }\n  }\n  return false;\n}\n", "target": 1, "idx": 186588}
{"func": "StateChangeReason DiscardReasonToStateChangeReason(DiscardReason reason) {\n  switch (reason) {\n    case DiscardReason::kExternal:\n      return StateChangeReason::EXTENSION_INITIATED;\n    case DiscardReason::kProactive:\n      return StateChangeReason::BROWSER_INITIATED;\n    case DiscardReason::kUrgent:\n      return StateChangeReason::SYSTEM_MEMORY_PRESSURE;\n   }\n }\n", "target": 0, "idx": 144776}
{"func": "static void cmd_parse_status(struct ImapData *idata, char *s)\n{\n  char *value = NULL;\n  struct Buffy *inc = NULL;\n  struct ImapMbox mx;\n  struct ImapStatus *status = NULL;\n  unsigned int olduv, oldun;\n  unsigned int litlen;\n  short new = 0;\n  short new_msg_count = 0;\n\n  char *mailbox = imap_next_word(s);\n\n  /* We need a real tokenizer. */\n  if (imap_get_literal_count(mailbox, &litlen) == 0)\n  {\n    if (imap_cmd_step(idata) != IMAP_CMD_CONTINUE)\n    {\n       idata->status = IMAP_FATAL;\n       return;\n     }\n     mailbox = idata->buf;\n     s = mailbox + litlen;\n     *s = '\\0';\n    s++;\n    SKIPWS(s);\n  }\n  else\n  {\n    s = imap_next_word(mailbox);\n    *(s - 1) = '\\0';\n    imap_unmunge_mbox_name(idata, mailbox);\n  }\n\n  status = imap_mboxcache_get(idata, mailbox, 1);\n  olduv = status->uidvalidity;\n  oldun = status->uidnext;\n\n  if (*s++ != '(')\n  {\n    mutt_debug(1, \"Error parsing STATUS\\n\");\n    return;\n  }\n  while (*s && *s != ')')\n  {\n    value = imap_next_word(s);\n\n    errno = 0;\n    const unsigned long ulcount = strtoul(value, &value, 10);\n    if (((errno == ERANGE) && (ulcount == ULONG_MAX)) || ((unsigned int) ulcount != ulcount))\n    {\n      mutt_debug(1, \"Error parsing STATUS number\\n\");\n      return;\n    }\n    const unsigned int count = (unsigned int) ulcount;\n\n    if (mutt_str_strncmp(\"MESSAGES\", s, 8) == 0)\n    {\n      status->messages = count;\n      new_msg_count = 1;\n    }\n    else if (mutt_str_strncmp(\"RECENT\", s, 6) == 0)\n      status->recent = count;\n    else if (mutt_str_strncmp(\"UIDNEXT\", s, 7) == 0)\n      status->uidnext = count;\n    else if (mutt_str_strncmp(\"UIDVALIDITY\", s, 11) == 0)\n      status->uidvalidity = count;\n    else if (mutt_str_strncmp(\"UNSEEN\", s, 6) == 0)\n      status->unseen = count;\n\n    s = value;\n    if (*s && *s != ')')\n      s = imap_next_word(s);\n  }\n  mutt_debug(3, \"%s (UIDVALIDITY: %u, UIDNEXT: %u) %d messages, %d recent, %d unseen\\n\",\n             status->name, status->uidvalidity, status->uidnext,\n             status->messages, status->recent, status->unseen);\n\n  /* caller is prepared to handle the result herself */\n  if (idata->cmddata && idata->cmdtype == IMAP_CT_STATUS)\n  {\n    memcpy(idata->cmddata, status, sizeof(struct ImapStatus));\n    return;\n  }\n\n  mutt_debug(3, \"Running default STATUS handler\\n\");\n\n  /* should perhaps move this code back to imap_buffy_check */\n  for (inc = Incoming; inc; inc = inc->next)\n  {\n    if (inc->magic != MUTT_IMAP)\n      continue;\n\n    if (imap_parse_path(inc->path, &mx) < 0)\n    {\n      mutt_debug(1, \"Error parsing mailbox %s, skipping\\n\", inc->path);\n      continue;\n    }\n\n    if (imap_account_match(&idata->conn->account, &mx.account))\n    {\n      if (mx.mbox)\n      {\n        value = mutt_str_strdup(mx.mbox);\n        imap_fix_path(idata, mx.mbox, value, mutt_str_strlen(value) + 1);\n        FREE(&mx.mbox);\n      }\n      else\n        value = mutt_str_strdup(\"INBOX\");\n\n      if (value && (imap_mxcmp(mailbox, value) == 0))\n      {\n        mutt_debug(3, \"Found %s in buffy list (OV: %u ON: %u U: %d)\\n\", mailbox,\n                   olduv, oldun, status->unseen);\n\n        if (MailCheckRecent)\n        {\n          if (olduv && olduv == status->uidvalidity)\n          {\n            if (oldun < status->uidnext)\n              new = (status->unseen > 0);\n          }\n          else if (!olduv && !oldun)\n          {\n            /* first check per session, use recent. might need a flag for this. */\n            new = (status->recent > 0);\n          }\n          else\n            new = (status->unseen > 0);\n        }\n        else\n          new = (status->unseen > 0);\n\n#ifdef USE_SIDEBAR\n        if ((inc->new != new) || (inc->msg_count != status->messages) ||\n            (inc->msg_unread != status->unseen))\n        {\n          mutt_menu_set_current_redraw(REDRAW_SIDEBAR);\n        }\n#endif\n        inc->new = new;\n        if (new_msg_count)\n          inc->msg_count = status->messages;\n        inc->msg_unread = status->unseen;\n\n        if (inc->new)\n        {\n          /* force back to keep detecting new mail until the mailbox is\n             opened */\n          status->uidnext = oldun;\n        }\n\n        FREE(&value);\n        return;\n      }\n\n      FREE(&value);\n    }\n\n    FREE(&mx.mbox);\n  }\n}\n", "target": 1, "idx": 182310}
{"func": "void InspectorPageAgent::Did(const probe::UpdateLayout&) {\n  PageLayoutInvalidated(false);\n}\n", "target": 0, "idx": 151232}
{"func": "UpdateLibrary* CrosLibrary::GetUpdateLibrary() {\n  return update_lib_.GetDefaultImpl(use_stub_impl_);\n}\n", "target": 1, "idx": 184102}
{"func": "void FileSystemOperation::GetUsageAndQuotaThenRunTask(\n    const GURL& origin, FileSystemType type,\n    const base::Closure& task,\n    const base::Closure& error_callback) {\n  quota::QuotaManagerProxy* quota_manager_proxy =\n      file_system_context()->quota_manager_proxy();\n  if (!quota_manager_proxy ||\n      !file_system_context()->GetQuotaUtil(type)) {\n    operation_context_.set_allowed_bytes_growth(kint64max);\n    task.Run();\n    return;\n  }\n\n  TaskParamsForDidGetQuota params;\n  params.origin = origin;\n  params.type = type;\n  params.task = task;\n  params.error_callback = error_callback;\n\n  DCHECK(quota_manager_proxy);\n  DCHECK(quota_manager_proxy->quota_manager());\n  quota_manager_proxy->quota_manager()->GetUsageAndQuota(\n       origin,\n       FileSystemTypeToQuotaStorageType(type),\n       base::Bind(&FileSystemOperation::DidGetUsageAndQuotaAndRunTask,\n                 base::Unretained(this), params));\n }\n", "target": 1, "idx": 184336}
{"func": "void WallpaperManager::InitializeRegisteredDeviceWallpaper() {\n  if (user_manager::UserManager::Get()->IsUserLoggedIn())\n    return;\n\n  bool disable_boot_animation =\n      GetCommandLine()->HasSwitch(switches::kDisableBootAnimation);\n  bool show_users = true;\n  bool result = CrosSettings::Get()->GetBoolean(\n      kAccountsPrefShowUserNamesOnSignIn, &show_users);\n  DCHECK(result) << \"Unable to fetch setting \"\n                 << kAccountsPrefShowUserNamesOnSignIn;\n  const user_manager::UserList& users =\n      user_manager::UserManager::Get()->GetUsers();\n  int public_session_user_index = FindPublicSession(users);\n  if ((!show_users && public_session_user_index == -1) ||\n      !HasNonDeviceLocalAccounts(users)) {\n    if (!SetDeviceWallpaperIfApplicable(user_manager::SignInAccountId()))\n      SetDefaultWallpaperDelayed(user_manager::SignInAccountId());\n    return;\n  }\n\n  if (!disable_boot_animation) {\n    int index = public_session_user_index != -1 ? public_session_user_index : 0;\n    SetUserWallpaperDelayed(users[index]->GetAccountId());\n  }\n}\n", "target": 0, "idx": 138887}
{"func": "static struct l2cap_chan *l2cap_sock_new_connection_cb(struct l2cap_chan *chan)\n{\n\tstruct sock *sk, *parent = chan->data;\n\n\t/* Check for backlog size */\n\tif (sk_acceptq_is_full(parent)) {\n\t\tBT_DBG(\"backlog full %d\", parent->sk_ack_backlog);\n\t\treturn NULL;\n\t}\n\n\tsk = l2cap_sock_alloc(sock_net(parent), NULL, BTPROTO_L2CAP,\n\t\t\t\t\t\t\t\tGFP_ATOMIC);\n\tif (!sk)\n\t\treturn NULL;\n\n\tbt_sock_reclassify_lock(sk, BTPROTO_L2CAP);\n\n\tl2cap_sock_init(sk, parent);\n\n\treturn l2cap_pi(sk)->chan;\n}\n", "target": 0, "idx": 94528}
{"func": " ImageBitmapFactories::ImageBitmapLoader::ImageBitmapLoader(\n     ImageBitmapFactories& factory,\n     base::Optional<IntRect> crop_rect,\n     ScriptState* script_state,\n     const ImageBitmapOptions* options)\n    : loader_(\n           FileReaderLoader::Create(FileReaderLoader::kReadAsArrayBuffer, this)),\n       factory_(&factory),\n       resolver_(ScriptPromiseResolver::Create(script_state)),\n       crop_rect_(crop_rect),\n       options_(options) {}\n", "target": 1, "idx": 187051}
{"func": "  explicit FrameURLLoaderFactory(base::WeakPtr<RenderFrameImpl> frame)\n      : frame_(std::move(frame)) {}\n", "target": 0, "idx": 152321}
{"func": "OMX_ERRORTYPE  omx_video::allocate_input_buffer(\n        OMX_IN OMX_HANDLETYPE            hComp,\n        OMX_INOUT OMX_BUFFERHEADERTYPE** bufferHdr,\n        OMX_IN OMX_U32                   port,\n        OMX_IN OMX_PTR                   appData,\n        OMX_IN OMX_U32                   bytes)\n{\n (void)hComp, (void)port;\n    OMX_ERRORTYPE eRet = OMX_ErrorNone;\n unsigned   i = 0;\n\n    DEBUG_PRINT_HIGH(\"allocate_input_buffer()::\");\n if (bytes != m_sInPortDef.nBufferSize) {\n        DEBUG_PRINT_ERROR(\"ERROR: Buffer size mismatch error: bytes[%u] != nBufferSize[%u]\",\n (unsigned int)bytes, (unsigned int)m_sInPortDef.nBufferSize);\n return OMX_ErrorBadParameter;\n }\n\n if (!m_inp_mem_ptr) {\n        DEBUG_PRINT_HIGH(\"%s: size = %u, actual cnt %u\", __FUNCTION__,\n (unsigned int)m_sInPortDef.nBufferSize, (unsigned int)m_sInPortDef.nBufferCountActual);\n        m_inp_mem_ptr = (OMX_BUFFERHEADERTYPE*) \\\n                        calloc( (sizeof(OMX_BUFFERHEADERTYPE)), m_sInPortDef.nBufferCountActual);\n if (m_inp_mem_ptr == NULL) {\n            DEBUG_PRINT_ERROR(\"ERROR: calloc() Failed for m_inp_mem_ptr\");\n return OMX_ErrorInsufficientResources;\n }\n\n        DEBUG_PRINT_LOW(\"Successfully allocated m_inp_mem_ptr = %p\", m_inp_mem_ptr);\n        m_pInput_pmem = (struct pmem *) calloc(sizeof (struct pmem), m_sInPortDef.nBufferCountActual);\n\n if (m_pInput_pmem == NULL) {\n            DEBUG_PRINT_ERROR(\"ERROR: calloc() Failed for m_pInput_pmem\");\n return OMX_ErrorInsufficientResources;\n }\n#ifdef USE_ION\n        m_pInput_ion = (struct venc_ion *) calloc(sizeof (struct venc_ion), m_sInPortDef.nBufferCountActual);\n if (m_pInput_ion == NULL) {\n            DEBUG_PRINT_ERROR(\"ERROR: calloc() Failed for m_pInput_ion\");\n return OMX_ErrorInsufficientResources;\n }\n#endif\n for (i=0; i< m_sInPortDef.nBufferCountActual; i++) {\n            m_pInput_pmem[i].fd = -1;\n#ifdef USE_ION\n            m_pInput_ion[i].ion_device_fd =-1;\n            m_pInput_ion[i].fd_ion_data.fd =-1;\n            m_pInput_ion[i].ion_alloc_data.handle = 0;\n#endif\n }\n }\n\n for (i=0; i< m_sInPortDef.nBufferCountActual; i++) {\n if (BITMASK_ABSENT(&m_inp_bm_count,i)) {\n break;\n }\n }\n if (i < m_sInPortDef.nBufferCountActual) {\n\n *bufferHdr = (m_inp_mem_ptr + i);\n (*bufferHdr)->nSize             = sizeof(OMX_BUFFERHEADERTYPE);\n (*bufferHdr)->nVersion.nVersion = OMX_SPEC_VERSION;\n (*bufferHdr)->nAllocLen         = m_sInPortDef.nBufferSize;\n (*bufferHdr)->pAppPrivate       = appData;\n (*bufferHdr)->nInputPortIndex   = PORT_INDEX_IN;\n (*bufferHdr)->pInputPortPrivate = (OMX_PTR)&m_pInput_pmem[i];\n\n#ifdef USE_ION\n#ifdef _MSM8974_\n        m_pInput_ion[i].ion_device_fd = alloc_map_ion_memory(m_sInPortDef.nBufferSize,\n &m_pInput_ion[i].ion_alloc_data,\n &m_pInput_ion[i].fd_ion_data,0);\n#else\n        m_pInput_ion[i].ion_device_fd = alloc_map_ion_memory(m_sInPortDef.nBufferSize,\n &m_pInput_ion[i].ion_alloc_data,\n &m_pInput_ion[i].fd_ion_data,ION_FLAG_CACHED);\n#endif\n if (m_pInput_ion[i].ion_device_fd < 0) {\n            DEBUG_PRINT_ERROR(\"ERROR:ION device open() Failed\");\n return OMX_ErrorInsufficientResources;\n }\n\n        m_pInput_pmem[i].fd = m_pInput_ion[i].fd_ion_data.fd;\n#else\n        m_pInput_pmem[i].fd = open (MEM_DEVICE,O_RDWR);\n\n if (m_pInput_pmem[i].fd == 0) {\n            m_pInput_pmem[i].fd = open (MEM_DEVICE,O_RDWR);\n }\n\n if (m_pInput_pmem[i].fd < 0) {\n            DEBUG_PRINT_ERROR(\"ERROR: /dev/pmem_adsp open() Failed\");\n return OMX_ErrorInsufficientResources;\n }\n#endif\n        m_pInput_pmem[i].size = m_sInPortDef.nBufferSize;\n        m_pInput_pmem[i].offset = 0;\n\n        m_pInput_pmem[i].buffer = (OMX_U8 *)SECURE_BUFPTR;\n if(!secure_session) {\n            m_pInput_pmem[i].buffer = (unsigned char *)mmap(NULL,\n                m_pInput_pmem[i].size,PROT_READ|PROT_WRITE,\n                MAP_SHARED,m_pInput_pmem[i].fd,0);\n if (m_pInput_pmem[i].buffer == MAP_FAILED) {\n                DEBUG_PRINT_ERROR(\"ERROR: mmap FAILED= %d\", errno);\n            close(m_pInput_pmem[i].fd);\n#ifdef USE_ION\n            free_ion_memory(&m_pInput_ion[i]);\n#endif\n return OMX_ErrorInsufficientResources;\n }\n } else {\n\n             m_pInput_pmem[i].buffer = malloc(sizeof(OMX_U32) + sizeof(native_handle_t*));\n         }\n \n         (*bufferHdr)->pBuffer           = (OMX_U8 *)m_pInput_pmem[i].buffer;\n        DEBUG_PRINT_LOW(\"Virtual address in allocate buffer is %p\", m_pInput_pmem[i].buffer);\n        BITMASK_SET(&m_inp_bm_count,i);\n if (!mUseProxyColorFormat && (dev_use_buf(&m_pInput_pmem[i],PORT_INDEX_IN,i) != true)) {\n            DEBUG_PRINT_ERROR(\"ERROR: dev_use_buf FAILED for i/p buf\");\n return OMX_ErrorInsufficientResources;\n }\n } else {\n        DEBUG_PRINT_ERROR(\"ERROR: All i/p buffers are allocated, invalid allocate buf call\"\n \"for index [%d]\", i);\n        eRet = OMX_ErrorInsufficientResources;\n }\n\n return eRet;\n}\n", "target": 1, "idx": 187541}
{"func": "  WebsiteSettings* website_settings() {\n     if (!website_settings_.get()) {\n       website_settings_.reset(new WebsiteSettings(\n           mock_ui(), profile(), tab_specific_content_settings(),\n          infobar_service(), url(), ssl(), cert_store()));\n     }\n     return website_settings_.get();\n   }\n", "target": 1, "idx": 185659}
{"func": "rx_cache_insert(netdissect_options *ndo,\n                const u_char *bp, const struct ip *ip, int dport)\n{\n\tstruct rx_cache_entry *rxent;\n\tconst struct rx_header *rxh = (const struct rx_header *) bp;\n\n\tif (ndo->ndo_snapend - bp + 1 <= (int)(sizeof(struct rx_header) + sizeof(int32_t)))\n\t\treturn;\n\n\trxent = &rx_cache[rx_cache_next];\n\n\tif (++rx_cache_next >= RX_CACHE_SIZE)\n\t\trx_cache_next = 0;\n\n\trxent->callnum = EXTRACT_32BITS(&rxh->callNumber);\n \tUNALIGNED_MEMCPY(&rxent->client, &ip->ip_src, sizeof(uint32_t));\n \tUNALIGNED_MEMCPY(&rxent->server, &ip->ip_dst, sizeof(uint32_t));\n \trxent->dport = dport;\n\trxent->serviceId = EXTRACT_32BITS(&rxh->serviceId);\n \trxent->opcode = EXTRACT_32BITS(bp + sizeof(struct rx_header));\n }\n", "target": 1, "idx": 183018}
{"func": "get_endpoints(struct usbtest_dev *dev, struct usb_interface *intf)\n{\n\tint\t\t\t\ttmp;\n\tstruct usb_host_interface\t*alt;\n\tstruct usb_host_endpoint\t*in, *out;\n\tstruct usb_host_endpoint\t*iso_in, *iso_out;\n\tstruct usb_host_endpoint\t*int_in, *int_out;\n\tstruct usb_device\t\t*udev;\n\n\tfor (tmp = 0; tmp < intf->num_altsetting; tmp++) {\n\t\tunsigned\tep;\n\n\t\tin = out = NULL;\n\t\tiso_in = iso_out = NULL;\n\t\tint_in = int_out = NULL;\n\t\talt = intf->altsetting + tmp;\n\n\t\tif (override_alt >= 0 &&\n\t\t\t\toverride_alt != alt->desc.bAlternateSetting)\n\t\t\tcontinue;\n\n\t\t/* take the first altsetting with in-bulk + out-bulk;\n\t\t * ignore other endpoints and altsettings.\n\t\t */\n\t\tfor (ep = 0; ep < alt->desc.bNumEndpoints; ep++) {\n\t\t\tstruct usb_host_endpoint\t*e;\n\t\t\tint edi;\n\n\t\t\te = alt->endpoint + ep;\n\t\t\tedi = usb_endpoint_dir_in(&e->desc);\n\n\t\t\tswitch (usb_endpoint_type(&e->desc)) {\n\t\t\tcase USB_ENDPOINT_XFER_BULK:\n\t\t\t\tendpoint_update(edi, &in, &out, e);\n\t\t\t\tcontinue;\n\t\t\tcase USB_ENDPOINT_XFER_INT:\n\t\t\t\tif (dev->info->intr)\n\t\t\t\t\tendpoint_update(edi, &int_in, &int_out, e);\n\t\t\t\tcontinue;\n\t\t\tcase USB_ENDPOINT_XFER_ISOC:\n\t\t\t\tif (dev->info->iso)\n\t\t\t\t\tendpoint_update(edi, &iso_in, &iso_out, e);\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tdefault:\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif ((in && out)  ||  iso_in || iso_out || int_in || int_out)\n\t\t\tgoto found;\n\t}\n\treturn -EINVAL;\n\nfound:\n\tudev = testdev_to_usbdev(dev);\n\tdev->info->alt = alt->desc.bAlternateSetting;\n\tif (alt->desc.bAlternateSetting != 0) {\n\t\ttmp = usb_set_interface(udev,\n\t\t\t\talt->desc.bInterfaceNumber,\n\t\t\t\talt->desc.bAlternateSetting);\n\t\tif (tmp < 0)\n \t\t\treturn tmp;\n \t}\n \n\tif (in) {\n \t\tdev->in_pipe = usb_rcvbulkpipe(udev,\n \t\t\tin->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);\n \t\tdev->out_pipe = usb_sndbulkpipe(udev,\n \t\t\tout->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);\n\t}\n \tif (iso_in) {\n \t\tdev->iso_in = &iso_in->desc;\n \t\tdev->in_iso_pipe = usb_rcvisocpipe(udev,\n\t\t\t\tiso_in->desc.bEndpointAddress\n\t\t\t\t\t& USB_ENDPOINT_NUMBER_MASK);\n\t}\n\n\tif (iso_out) {\n\t\tdev->iso_out = &iso_out->desc;\n\t\tdev->out_iso_pipe = usb_sndisocpipe(udev,\n\t\t\t\tiso_out->desc.bEndpointAddress\n\t\t\t\t\t& USB_ENDPOINT_NUMBER_MASK);\n\t}\n\n\tif (int_in) {\n\t\tdev->int_in = &int_in->desc;\n\t\tdev->in_int_pipe = usb_rcvintpipe(udev,\n\t\t\t\tint_in->desc.bEndpointAddress\n\t\t\t\t\t& USB_ENDPOINT_NUMBER_MASK);\n\t}\n\n\tif (int_out) {\n\t\tdev->int_out = &int_out->desc;\n\t\tdev->out_int_pipe = usb_sndintpipe(udev,\n\t\t\t\tint_out->desc.bEndpointAddress\n\t\t\t\t\t& USB_ENDPOINT_NUMBER_MASK);\n\t}\n\treturn 0;\n}\n", "target": 1, "idx": 180850}
{"func": "bool GDataDirectory::FromProto(const GDataDirectoryProto& proto) {\n  DCHECK(proto.gdata_entry().file_info().is_directory());\n   DCHECK(!proto.gdata_entry().has_file_specific_info());\n \n   for (int i = 0; i < proto.child_files_size(); ++i) {\n    scoped_ptr<GDataFile> file(new GDataFile(NULL, directory_service_));\n     if (!file->FromProto(proto.child_files(i))) {\n       RemoveChildren();\n       return false;\n     }\n     AddEntry(file.release());\n   }\n   for (int i = 0; i < proto.child_directories_size(); ++i) {\n    scoped_ptr<GDataDirectory> dir(new GDataDirectory(NULL,\n                                                      directory_service_));\n     if (!dir->FromProto(proto.child_directories(i))) {\n       RemoveChildren();\n       return false;\n    }\n    AddEntry(dir.release());\n  }\n\n  if (!GDataEntry::FromProto(proto.gdata_entry()))\n    return false;\n\n  return true;\n}\n", "target": 1, "idx": 185190}
{"func": "void SoftHEVC::onQueueFilled(OMX_U32 portIndex) {\n    UNUSED(portIndex);\n\n if (mSignalledError) {\n return;\n }\n if (mOutputPortSettingsChange != NONE) {\n return;\n }\n\n if (NULL == mCodecCtx) {\n if (OK != initDecoder()) {\n return;\n }\n }\n if (outputBufferWidth() != mStride) {\n /* Set the run-time (dynamic) parameters */\n        mStride = outputBufferWidth();\n        setParams(mStride);\n }\n\n List<BufferInfo *> &inQueue = getPortQueue(kInputPortIndex);\n List<BufferInfo *> &outQueue = getPortQueue(kOutputPortIndex);\n\n /* If input EOS is seen and decoder is not in flush mode,\n     * set the decoder in flush mode.\n     * There can be a case where EOS is sent along with last picture data\n     * In that case, only after decoding that input data, decoder has to be\n     * put in flush. This case is handled here  */\n\n if (mReceivedEOS && !mIsInFlush) {\n        setFlushMode();\n }\n\n while (!outQueue.empty()) {\n BufferInfo *inInfo;\n        OMX_BUFFERHEADERTYPE *inHeader;\n\n BufferInfo *outInfo;\n        OMX_BUFFERHEADERTYPE *outHeader;\n size_t timeStampIx;\n\n        inInfo = NULL;\n        inHeader = NULL;\n\n if (!mIsInFlush) {\n if (!inQueue.empty()) {\n                inInfo = *inQueue.begin();\n                inHeader = inInfo->mHeader;\n } else {\n break;\n }\n }\n\n        outInfo = *outQueue.begin();\n        outHeader = outInfo->mHeader;\n        outHeader->nFlags = 0;\n        outHeader->nTimeStamp = 0;\n        outHeader->nOffset = 0;\n\n if (inHeader != NULL && (inHeader->nFlags & OMX_BUFFERFLAG_EOS)) {\n            mReceivedEOS = true;\n if (inHeader->nFilledLen == 0) {\n                inQueue.erase(inQueue.begin());\n                inInfo->mOwnedByUs = false;\n                notifyEmptyBufferDone(inHeader);\n                inHeader = NULL;\n                setFlushMode();\n }\n }\n\n /* Get a free slot in timestamp array to hold input timestamp */\n {\n size_t i;\n            timeStampIx = 0;\n for (i = 0; i < MAX_TIME_STAMPS; i++) {\n if (!mTimeStampsValid[i]) {\n                    timeStampIx = i;\n break;\n }\n }\n if (inHeader != NULL) {\n                mTimeStampsValid[timeStampIx] = true;\n                mTimeStamps[timeStampIx] = inHeader->nTimeStamp;\n }\n }\n\n {\n ivd_video_decode_ip_t s_dec_ip;\n ivd_video_decode_op_t s_dec_op;\n\n             WORD32 timeDelay, timeTaken;\n             size_t sizeY, sizeUV;\n \n            setDecodeArgs(&s_dec_ip, &s_dec_op, inHeader, outHeader, timeStampIx);\n \n             GETTIME(&mTimeStart, NULL);\n             /* Compute time elapsed between end of previous decode()\n             * to start of current decode() */\n            TIME_DIFF(mTimeEnd, mTimeStart, timeDelay);\n\n            IV_API_CALL_STATUS_T status;\n            status = ivdec_api_function(mCodecCtx, (void *)&s_dec_ip, (void *)&s_dec_op);\n\n bool resChanged = (IVD_RES_CHANGED == (s_dec_op.u4_error_code & 0xFF));\n\n            GETTIME(&mTimeEnd, NULL);\n /* Compute time taken for decode() */\n            TIME_DIFF(mTimeStart, mTimeEnd, timeTaken);\n\n            ALOGV(\"timeTaken=%6d delay=%6d numBytes=%6d\", timeTaken, timeDelay,\n                   s_dec_op.u4_num_bytes_consumed);\n if (s_dec_op.u4_frame_decoded_flag && !mFlushNeeded) {\n                mFlushNeeded = true;\n }\n\n if ((inHeader != NULL) && (1 != s_dec_op.u4_frame_decoded_flag)) {\n /* If the input did not contain picture data, then ignore\n                 * the associated timestamp */\n                mTimeStampsValid[timeStampIx] = false;\n }\n\n if (mChangingResolution && !s_dec_op.u4_output_present) {\n                mChangingResolution = false;\n                resetDecoder();\n                resetPlugin();\n continue;\n }\n\n if (resChanged) {\n                mChangingResolution = true;\n if (mFlushNeeded) {\n                    setFlushMode();\n }\n continue;\n }\n\n if ((0 < s_dec_op.u4_pic_wd) && (0 < s_dec_op.u4_pic_ht)) {\n uint32_t width = s_dec_op.u4_pic_wd;\n uint32_t height = s_dec_op.u4_pic_ht;\n bool portWillReset = false;\n                handlePortSettingsChange(&portWillReset, width, height);\n\n if (portWillReset) {\n                    resetDecoder();\n return;\n }\n }\n\n if (s_dec_op.u4_output_present) {\n                outHeader->nFilledLen = (outputBufferWidth() * outputBufferHeight() * 3) / 2;\n\n                outHeader->nTimeStamp = mTimeStamps[s_dec_op.u4_ts];\n                mTimeStampsValid[s_dec_op.u4_ts] = false;\n\n                outInfo->mOwnedByUs = false;\n                outQueue.erase(outQueue.begin());\n                outInfo = NULL;\n                notifyFillBufferDone(outHeader);\n                outHeader = NULL;\n } else {\n /* If in flush mode and no output is returned by the codec,\n                 * then come out of flush mode */\n                mIsInFlush = false;\n\n /* If EOS was recieved on input port and there is no output\n                 * from the codec, then signal EOS on output port */\n if (mReceivedEOS) {\n                    outHeader->nFilledLen = 0;\n                    outHeader->nFlags |= OMX_BUFFERFLAG_EOS;\n\n                    outInfo->mOwnedByUs = false;\n                    outQueue.erase(outQueue.begin());\n                    outInfo = NULL;\n                    notifyFillBufferDone(outHeader);\n                    outHeader = NULL;\n                    resetPlugin();\n }\n }\n }\n\n if (inHeader != NULL) {\n            inInfo->mOwnedByUs = false;\n            inQueue.erase(inQueue.begin());\n            inInfo = NULL;\n            notifyEmptyBufferDone(inHeader);\n            inHeader = NULL;\n }\n }\n}\n", "target": 1, "idx": 188203}
{"func": "cJSON *cJSON_CreateObject( void )\n{\n\tcJSON *item = cJSON_New_Item();\n\tif ( item )\n\t\titem->type = cJSON_Object;\n\treturn item;\n}\n", "target": 1, "idx": 180449}
{"func": " void ChromeContentRendererClient::RenderViewCreated(RenderView* render_view) {\n   ContentSettingsObserver* content_settings =\n       new ContentSettingsObserver(render_view);\n  new DevToolsAgent(render_view);\n   new ExtensionHelper(render_view, extension_dispatcher_.get());\n   new PageLoadHistograms(render_view, histogram_snapshots_.get());\n   new PrintWebViewHelper(render_view);\n  new SearchBox(render_view);\n  new SpellCheckProvider(render_view, spellcheck_.get());\n#if defined(ENABLE_SAFE_BROWSING)\n  safe_browsing::MalwareDOMDetails::Create(render_view);\n#endif\n\n#if defined(OS_MACOSX)\n  new TextInputClientObserver(render_view);\n#endif  // defined(OS_MACOSX)\n\n  PasswordAutofillManager* password_autofill_manager =\n      new PasswordAutofillManager(render_view);\n  AutofillAgent* autofill_agent = new AutofillAgent(render_view,\n                                                    password_autofill_manager);\n  PageClickTracker* page_click_tracker = new PageClickTracker(render_view);\n  page_click_tracker->AddListener(password_autofill_manager);\n  page_click_tracker->AddListener(autofill_agent);\n\n  TranslateHelper* translate = new TranslateHelper(render_view, autofill_agent);\n  new ChromeRenderViewObserver(\n      render_view, content_settings, extension_dispatcher_.get(), translate);\n\n  if (CommandLine::ForCurrentProcess()->HasSwitch(\n          switches::kDomAutomationController)) {\n    new AutomationRendererHelper(render_view);\n  }\n}\n", "target": 1, "idx": 183781}
{"func": "static void set_maintenance_mode(void *send_info, bool enable)\n{\n\tstruct smi_info   *smi_info = send_info;\n\n\tif (!enable)\n\t\tatomic_set(&smi_info->req_events, 0);\n}\n", "target": 0, "idx": 90246}
{"func": "static inline unsigned long perf_ip_adjust(struct pt_regs *regs)\n{\n\tunsigned long mmcra = regs->dsisr;\n\n\tif ((mmcra & MMCRA_SAMPLE_ENABLE) && !(ppmu->flags & PPMU_ALT_SIPR)) {\n\t\tunsigned long slot = (mmcra & MMCRA_SLOT) >> MMCRA_SLOT_SHIFT;\n\t\tif (slot > 1)\n\t\t\treturn 4 * (slot - 1);\n\t}\n\treturn 0;\n}\n", "target": 0, "idx": 22688}
{"func": "void gdImageLine (gdImagePtr im, int x1, int y1, int x2, int y2, int color)\n{\n\tint dx, dy, incr1, incr2, d, x, y, xend, yend, xdirflag, ydirflag;\n\tint wid;\n\tint w, wstart;\n \tint thick = im->thick;\n \n \tif (color == gdAntiAliased) {\n\t\t/* \n \t\t   gdAntiAliased passed as color: use the much faster, much cheaper\n \t\t   and equally attractive gdImageAALine implementation. That\n \t\t   clips too, so don't clip twice.\n \t\t   */\n\t\tgdImageAALine(im, x1, y1, x2, y2, im->AA_color); \n \t\treturn;\n \t}\n \n\t/* 2.0.10: Nick Atty: clip to edges of drawing rectangle, return if no points need to be drawn */\n\tif (!clip_1d(&x1,&y1,&x2,&y2,gdImageSX(im)) || !clip_1d(&y1,&x1,&y2,&x2,gdImageSY(im))) {\n\t\treturn;\n\t}\n\n\tdx = abs (x2 - x1);\n\tdy = abs (y2 - y1);\n\n\tif (dx == 0) {\n\t\tgdImageVLine(im, x1, y1, y2, color);\n\t\treturn;\n\t} else if (dy == 0) {\n\t\tgdImageHLine(im, y1, x1, x2, color);\n\t\treturn;\n\t}\n\n\tif (dy <= dx) {\n\t\t/* More-or-less horizontal. use wid for vertical stroke */\n\t\t/* Doug Claar: watch out for NaN in atan2 (2.0.5) */\n\t\tif ((dx == 0) && (dy == 0)) {\n\t\t\twid = 1;\n\t\t} else {\n\t\t\t/* 2.0.12: Michael Schwartz: divide rather than multiply;\nTBB: but watch out for /0! */\n\t\t\tdouble ac = cos (atan2 (dy, dx));\n\t\t\tif (ac != 0) {\n\t\t\t\twid = thick / ac;\n\t\t\t} else {\n\t\t\t\twid = 1;\n\t\t\t}\n\t\t\tif (wid == 0) {\n\t\t\t\twid = 1;\n\t\t\t}\n\t\t}\n\t\td = 2 * dy - dx;\n\t\tincr1 = 2 * dy;\n\t\tincr2 = 2 * (dy - dx);\n\t\tif (x1 > x2) {\n\t\t\tx = x2;\n\t\t\ty = y2;\n\t\t\tydirflag = (-1);\n\t\t\txend = x1;\n\t\t} else {\n\t\t\tx = x1;\n\t\t\ty = y1;\n\t\t\tydirflag = 1;\n\t\t\txend = x2;\n\t\t}\n\n\t\t/* Set up line thickness */\n\t\twstart = y - wid / 2;\n\t\tfor (w = wstart; w < wstart + wid; w++) {\n\t\t\tgdImageSetPixel(im, x, w, color);\n\t\t}\n\n\t\tif (((y2 - y1) * ydirflag) > 0) {\n\t\t\twhile (x < xend) {\n\t\t\t\tx++;\n\t\t\t\tif (d < 0) {\n\t\t\t\t\td += incr1;\n\t\t\t\t} else {\n\t\t\t\t\ty++;\n\t\t\t\t\td += incr2;\n\t\t\t\t}\n\t\t\t\twstart = y - wid / 2;\n\t\t\t\tfor (w = wstart; w < wstart + wid; w++) {\n\t\t\t\t\tgdImageSetPixel (im, x, w, color);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\twhile (x < xend) {\n\t\t\t\tx++;\n\t\t\t\tif (d < 0) {\n\t\t\t\t\td += incr1;\n\t\t\t\t} else {\n\t\t\t\t\ty--;\n\t\t\t\t\td += incr2;\n\t\t\t\t}\n\t\t\t\twstart = y - wid / 2;\n\t\t\t\tfor (w = wstart; w < wstart + wid; w++) {\n\t\t\t\t\tgdImageSetPixel (im, x, w, color);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* More-or-less vertical. use wid for horizontal stroke */\n\t\t/* 2.0.12: Michael Schwartz: divide rather than multiply;\n\t\t   TBB: but watch out for /0! */\n\t\tdouble as = sin (atan2 (dy, dx));\n\t\tif (as != 0) {\n\t\t\twid = thick / as;\n\t\t} else {\n\t\t\twid = 1;\n\t\t}\n\t\tif (wid == 0) {\n\t\t\twid = 1;\n\t\t}\n\n\t\td = 2 * dx - dy;\n\t\tincr1 = 2 * dx;\n\t\tincr2 = 2 * (dx - dy);\n\t\tif (y1 > y2) {\n\t\t\ty = y2;\n\t\t\tx = x2;\n\t\t\tyend = y1;\n\t\t\txdirflag = (-1);\n\t\t} else {\n\t\t\ty = y1;\n\t\t\tx = x1;\n\t\t\tyend = y2;\n\t\t\txdirflag = 1;\n\t\t}\n\n\t\t/* Set up line thickness */\n\t\twstart = x - wid / 2;\n\t\tfor (w = wstart; w < wstart + wid; w++) {\n\t\t\tgdImageSetPixel (im, w, y, color);\n\t\t}\n\n\t\tif (((x2 - x1) * xdirflag) > 0) {\n\t\t\twhile (y < yend) {\n\t\t\t\ty++;\n\t\t\t\tif (d < 0) {\n\t\t\t\t\td += incr1;\n\t\t\t\t} else {\n\t\t\t\t\tx++;\n\t\t\t\t\td += incr2;\n\t\t\t\t}\n\t\t\t\twstart = x - wid / 2;\n\t\t\t\tfor (w = wstart; w < wstart + wid; w++) {\n\t\t\t\t\tgdImageSetPixel (im, w, y, color);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\twhile (y < yend) {\n\t\t\t\ty++;\n\t\t\t\tif (d < 0) {\n\t\t\t\t\td += incr1;\n\t\t\t\t} else {\n\t\t\t\t\tx--;\n\t\t\t\t\td += incr2;\n\t\t\t\t}\n\t\t\t\twstart = x - wid / 2;\n\t\t\t\tfor (w = wstart; w < wstart + wid; w++) {\n\t\t\t\t\tgdImageSetPixel (im, w, y, color);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n", "target": 1, "idx": 180301}
{"func": "const SeekHead* Segment::GetSeekHead() const\n{\n    return m_pSeekHead;\n}\n", "target": 1, "idx": 188375}
{"func": "static void emulator_set_cached_descriptor(struct desc_struct *desc, int seg,\n\t\t\t\t\t   struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment var;\n\n\t/* needed to preserve selector */\n\tkvm_get_segment(vcpu, &var, seg);\n\n\tvar.base = get_desc_base(desc);\n\tvar.limit = get_desc_limit(desc);\n\tif (desc->g)\n\t\tvar.limit = (var.limit << 12) | 0xfff;\n\tvar.type = desc->type;\n\tvar.present = desc->p;\n\tvar.dpl = desc->dpl;\n\tvar.db = desc->d;\n\tvar.s = desc->s;\n\tvar.l = desc->l;\n\tvar.g = desc->g;\n\tvar.avl = desc->avl;\n\tvar.present = desc->p;\n\tvar.unusable = !var.present;\n\tvar.padding = 0;\n\n\tkvm_set_segment(vcpu, &var, seg);\n\treturn;\n}\n", "target": 0, "idx": 41337}
{"func": " void AppShortcutManager::OnceOffCreateShortcuts() {\n  bool was_enabled = prefs_->GetBoolean(prefs::kAppShortcutsHaveBeenCreated);\n#if defined(OS_MACOSX)\n  bool is_now_enabled = apps::IsAppShimsEnabled();\n#else\n  bool is_now_enabled = true;\n#endif  // defined(OS_MACOSX)\n  if (was_enabled != is_now_enabled)\n    prefs_->SetBoolean(prefs::kAppShortcutsHaveBeenCreated, is_now_enabled);\n  if (was_enabled || !is_now_enabled)\n     return;\n \n   extensions::ExtensionSystem* extension_system;\n  ExtensionServiceInterface* extension_service;\n  if (!(extension_system = extensions::ExtensionSystem::Get(profile_)) ||\n      !(extension_service = extension_system->extension_service()))\n    return;\n\n  const extensions::ExtensionSet* apps = extension_service->extensions();\n  for (extensions::ExtensionSet::const_iterator it = apps->begin();\n       it != apps->end(); ++it) {\n    if (ShouldCreateShortcutFor(profile_, it->get()))\n      CreateShortcutsInApplicationsMenu(profile_, it->get());\n  }\n}\n", "target": 1, "idx": 184838}
{"func": "static void get_timewait4_sock(struct inet_timewait_sock *tw,\n\t\t\t       struct seq_file *f, int i, int *len)\n{\n\t__be32 dest, src;\n\t__u16 destp, srcp;\n\tint ttd = tw->tw_ttd - jiffies;\n\n\tif (ttd < 0)\n\t\tttd = 0;\n\n\tdest  = tw->tw_daddr;\n\tsrc   = tw->tw_rcv_saddr;\n\tdestp = ntohs(tw->tw_dport);\n\tsrcp  = ntohs(tw->tw_sport);\n\n\tseq_printf(f, \"%4d: %08X:%04X %08X:%04X\"\n\t\t\" %02X %08X:%08X %02X:%08lX %08X %5d %8d %d %d %p%n\",\n\t\ti, src, srcp, dest, destp, tw->tw_substate, 0, 0,\n\t\t3, jiffies_to_clock_t(ttd), 0, 0, 0, 0,\n\t\tatomic_read(&tw->tw_refcnt), tw, len);\n}\n", "target": 0, "idx": 18995}
{"func": "    LineLayoutState(bool fullLayout, LayoutUnit& repaintLogicalTop, LayoutUnit& repaintLogicalBottom, RenderFlowThread* flowThread)\n        : m_lastFloat(0)\n        , m_endLine(0)\n        , m_floatIndex(0)\n        , m_endLineLogicalTop(0)\n        , m_endLineMatched(false)\n        , m_checkForFloatsFromLastLine(false)\n        , m_isFullLayout(fullLayout)\n        , m_repaintLogicalTop(repaintLogicalTop)\n        , m_repaintLogicalBottom(repaintLogicalBottom)\n        , m_adjustedLogicalLineTop(0)\n        , m_usesRepaintBounds(false)\n        , m_flowThread(flowThread)\n    { }\n", "target": 0, "idx": 119556}
{"func": "XFixesFetchRegionAndBounds (Display\t    *dpy,\n\t\t\t    XserverRegion   region,\n\t\t\t    int\t\t    *nrectanglesRet,\n\t\t\t    XRectangle\t    *bounds)\n{\n    XFixesExtDisplayInfo\t*info = XFixesFindDisplay (dpy);\n    xXFixesFetchRegionReq\t*req;\n    xXFixesFetchRegionReply\trep;\n    XRectangle\t\t\t*rects;\n    int    \t\t\tnrects;\n    long    \t\t\tnbytes;\n    long\t\t\tnread;\n\n    XFixesCheckExtension (dpy, info, NULL);\n    LockDisplay (dpy);\n    GetReq (XFixesFetchRegion, req);\n    req->reqType = info->codes->major_opcode;\n    req->xfixesReqType = X_XFixesFetchRegion;\n    req->region = region;\n    *nrectanglesRet = 0;\n    if (!_XReply (dpy, (xReply *) &rep, 0, xFalse))\n    {\n\tUnlockDisplay (dpy);\n\tSyncHandle ();\n\treturn NULL;\n    }\n    bounds->x = rep.x;\n    bounds->y = rep.y;\n     bounds->y = rep.y;\n     bounds->width = rep.width;\n     bounds->height = rep.height;\n    nbytes = (long) rep.length << 2;\n    nrects = rep.length >> 1;\n    rects = Xmalloc (nrects * sizeof (XRectangle));\n     if (!rects)\n     {\n \t_XEatDataWords(dpy, rep.length);\n\t_XEatData (dpy, (unsigned long) (nbytes - nread));\n    }\n    UnlockDisplay (dpy);\n    SyncHandle();\n    *nrectanglesRet = nrects;\n    return rects;\n}\n", "target": 1, "idx": 178094}
{"func": "ofproto_port_get_stp_stats(struct ofproto *ofproto, ofp_port_t ofp_port,\n                           struct ofproto_port_stp_stats *s)\n{\n    struct ofport *ofport = ofproto_get_port(ofproto, ofp_port);\n    if (!ofport) {\n        VLOG_WARN_RL(&rl, \"%s: cannot get STP stats on nonexistent \"\n                     \"port %\"PRIu32, ofproto->name, ofp_port);\n        return ENODEV;\n    }\n\n    return (ofproto->ofproto_class->get_stp_port_stats\n            ? ofproto->ofproto_class->get_stp_port_stats(ofport, s)\n            : EOPNOTSUPP);\n}\n", "target": 0, "idx": 77356}
{"func": "static void tun_net_init(struct net_device *dev)\n{\n\tstruct tun_struct *tun = netdev_priv(dev);\n\n\tswitch (tun->flags & TUN_TYPE_MASK) {\n\tcase TUN_TUN_DEV:\n\t\tdev->netdev_ops = &tun_netdev_ops;\n\n\t\t/* Point-to-Point TUN Device */\n\t\tdev->hard_header_len = 0;\n\t\tdev->addr_len = 0;\n\t\tdev->mtu = 1500;\n\n\t\t/* Zero header length */\n\t\tdev->type = ARPHRD_NONE;\n\t\tdev->flags = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST;\n\t\tdev->tx_queue_len = TUN_READQ_SIZE;  /* We prefer our own queue length */\n\t\tbreak;\n\n\tcase TUN_TAP_DEV:\n \t\tdev->netdev_ops = &tap_netdev_ops;\n \t\t/* Ethernet TAP Device */\n \t\tether_setup(dev);\n \n \t\trandom_ether_addr(dev->dev_addr);\n \n\t\tdev->tx_queue_len = TUN_READQ_SIZE;  /* We prefer our own queue length */\n\t\tbreak;\n\t}\n}\n", "target": 1, "idx": 178902}
{"func": "base::FilePath DownloadPathReservationTrackerTest::GetPathInDownloadsDirectory(\n    const base::FilePath::CharType* suffix) {\n  return default_download_path().Append(suffix).NormalizePathSeparators();\n}\n", "target": 0, "idx": 127162}
{"func": "    StateBase* writeBlob(v8::Handle<v8::Value> value, StateBase* next)\n    {\n        Blob* blob = V8Blob::toNative(value.As<v8::Object>());\n        if (!blob)\n            return 0;\n         if (blob->hasBeenClosed())\n             return handleError(DataCloneError, \"A Blob object has been closed, and could therefore not be cloned.\", next);\n         int blobIndex = -1;\n        m_blobDataHandles.add(blob->uuid(), blob->blobDataHandle());\n         if (appendBlobInfo(blob->uuid(), blob->type(), blob->size(), &blobIndex))\n             m_writer.writeBlobIndex(blobIndex);\n         else\n            m_writer.writeBlob(blob->uuid(), blob->type(), blob->size());\n        return 0;\n    }\n", "target": 1, "idx": 185354}
{"func": " int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)\n {\n \tu16 offset = sizeof(struct ipv6hdr);\n\tstruct ipv6_opt_hdr *exthdr =\n\t\t\t\t(struct ipv6_opt_hdr *)(ipv6_hdr(skb) + 1);\n \tunsigned int packet_len = skb_tail_pointer(skb) -\n \t\tskb_network_header(skb);\n \tint found_rhdr = 0;\n \t*nexthdr = &ipv6_hdr(skb)->nexthdr;\n \n\twhile (offset + 1 <= packet_len) {\n \n \t\tswitch (**nexthdr) {\n \n\t\tcase NEXTHDR_HOP:\n\t\t\tbreak;\n\t\tcase NEXTHDR_ROUTING:\n\t\t\tfound_rhdr = 1;\n\t\t\tbreak;\n\t\tcase NEXTHDR_DEST:\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\t\t\tif (ipv6_find_tlv(skb, offset, IPV6_TLV_HAO) >= 0)\n\t\t\t\tbreak;\n#endif\n\t\t\tif (found_rhdr)\n\t\t\t\treturn offset;\n\t\t\tbreak;\n\t\tdefault:\n \t\t\treturn offset;\n \t\t}\n \n\t\toffset += ipv6_optlen(exthdr);\n\t\t*nexthdr = &exthdr->nexthdr;\n \t\texthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +\n \t\t\t\t\t\t offset);\n \t}\n \n\treturn offset;\n }\n", "target": 1, "idx": 181304}
{"func": " void VarianceTest<VarianceFunctionType>::ZeroTest() {\n   for (int i = 0; i <= 255; ++i) {\n    memset(src_, i, block_size_);\n     for (int j = 0; j <= 255; ++j) {\n      memset(ref_, j, block_size_);\n       unsigned int sse;\n       unsigned int var;\n      REGISTER_STATE_CHECK(var = variance_(src_, width_, ref_, width_, &sse));\n      EXPECT_EQ(0u, var) << \"src values: \" << i << \"ref values: \" << j;\n     }\n   }\n }\n", "target": 1, "idx": 188615}
{"func": "ProcEstablishConnection(ClientPtr client)\n{\n    const char *reason;\n    char *auth_proto, *auth_string;\n    xConnClientPrefix *prefix;\n\n    REQUEST(xReq);\n\n     prefix = (xConnClientPrefix *) ((char *) stuff + sz_xReq);\n     auth_proto = (char *) prefix + sz_xConnClientPrefix;\n     auth_string = auth_proto + pad_to_int32(prefix->nbytesAuthProto);\n    if ((prefix->majorVersion != X_PROTOCOL) ||\n         (prefix->minorVersion != X_PROTOCOL_REVISION))\n         reason = \"Protocol version mismatch\";\n     else\n\n    return (SendConnSetup(client, reason));\n}\n", "target": 1, "idx": 178620}
{"func": "bool LayoutSVGTransformableContainer::calculateLocalTransform()\n {\n     SVGGraphicsElement* element = toSVGGraphicsElement(this->element());\n     ASSERT(element);\n\n    SVGUseElement* useElement = nullptr;\n    if (isSVGUseElement(*element)) {\n        useElement = toSVGUseElement(element);\n    } else if (isSVGGElement(*element) && toSVGGElement(element)->inUseShadowTree()) {\n        SVGElement* correspondingElement = element->correspondingElement();\n        if (isSVGUseElement(correspondingElement))\n            useElement = toSVGUseElement(correspondingElement);\n    }\n\n    if (useElement) {\n        SVGLengthContext lengthContext(useElement);\n         FloatSize translation(\n             useElement->x()->currentValue()->value(lengthContext),\n             useElement->y()->currentValue()->value(lengthContext));\n         if (translation != m_additionalTranslation)\n            m_needsTransformUpdate = true;\n         m_additionalTranslation = translation;\n     }\n \n     if (!m_needsTransformUpdate)\n        return false;\n \n     m_localTransform = element->calculateAnimatedLocalTransform();\n     m_localTransform.translate(m_additionalTranslation.width(), m_additionalTranslation.height());\n     m_needsTransformUpdate = false;\n    return true;\n }\n", "target": 1, "idx": 185370}
{"func": "static ZIPARCHIVE_METHOD(addEmptyDir)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tchar *dirname;\n\tsize_t   dirname_len;\n\tint idx;\n\tstruct zip_stat sb;\n\tchar *s;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s\",\n\t\t\t\t&dirname, &dirname_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (dirname_len<1) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (dirname[dirname_len-1] != '/') {\n\t\ts=(char *)emalloc(dirname_len+2);\n\t\tstrcpy(s, dirname);\n\t\ts[dirname_len] = '/';\n\t\ts[dirname_len+1] = '\\0';\n\t} else {\n\t\ts = dirname;\n\t}\n\n\tidx = zip_stat(intern, s, 0, &sb);\n\tif (idx >= 0) {\n\t\tRETVAL_FALSE;\n\t} else {\n\t\tif (zip_add_dir(intern, (const char *)s) == -1) {\n\t\t\tRETVAL_FALSE;\n\t\t}\n\t\tzip_error_clear(intern);\n\t\tRETVAL_TRUE;\n\t}\n\n\tif (s != dirname) {\n\t\tefree(s);\n\t}\n}\n", "target": 0, "idx": 54390}
{"func": "static int generate_key(DH *dh)\n{\n     int ok = 0;\n     int generate_new_key = 0;\n     unsigned l;\n    BN_CTX *ctx;\n     BN_MONT_CTX *mont = NULL;\n     BIGNUM *pub_key = NULL, *priv_key = NULL;\n \n     ctx = BN_CTX_new();\n     if (ctx == NULL)\n         goto err;\n        generate_new_key = 1;\n    } else\n", "target": 1, "idx": 178504}
{"func": "static int save_avio_options(AVFormatContext *s)\n{\n    HLSContext *c = s->priv_data;\n    static const char *opts[] = {\n        \"headers\", \"http_proxy\", \"user_agent\", \"user-agent\", \"cookies\", NULL };\n    const char **opt = opts;\n    uint8_t *buf;\n    int ret = 0;\n\n    while (*opt) {\n        if (av_opt_get(s->pb, *opt, AV_OPT_SEARCH_CHILDREN | AV_OPT_ALLOW_NULL, &buf) >= 0) {\n            ret = av_dict_set(&c->avio_opts, *opt, buf,\n                              AV_DICT_DONT_STRDUP_VAL);\n            if (ret < 0)\n                return ret;\n        }\n        opt++;\n    }\n\n    return ret;\n}\n", "target": 0, "idx": 61817}
{"func": "val_wrap_iov_args(\n    OM_uint32 *minor_status,\n    gss_ctx_id_t context_handle,\n    int conf_req_flag,\n    gss_qop_t qop_req,\n    int *conf_state,\n    gss_iov_buffer_desc *iov,\n    int iov_count)\n{\n\n    /* Initialize outputs. */\n\n    if (minor_status != NULL)\n\t*minor_status = 0;\n\n    /* Validate arguments. */\n\n    if (minor_status == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n\n    if (iov == GSS_C_NO_IOV_BUFFER)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ);\n\n    return (GSS_S_COMPLETE);\n}\n", "target": 0, "idx": 63356}
{"func": "static long ion_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct ion_client *client = filp->private_data;\n\tstruct ion_device *dev = client->dev;\n\tstruct ion_handle *cleanup_handle = NULL;\n\tint ret = 0;\n\tunsigned int dir;\n\n\tunion {\n\t\tstruct ion_fd_data fd;\n\t\tstruct ion_allocation_data allocation;\n\t\tstruct ion_handle_data handle;\n\t\tstruct ion_custom_data custom;\n\t} data;\n\n\tdir = ion_ioctl_dir(cmd);\n\n\tif (_IOC_SIZE(cmd) > sizeof(data))\n\t\treturn -EINVAL;\n\n\tif (dir & _IOC_WRITE)\n\t\tif (copy_from_user(&data, (void __user *)arg, _IOC_SIZE(cmd)))\n\t\t\treturn -EFAULT;\n\n\tswitch (cmd) {\n\tcase ION_IOC_ALLOC:\n\t{\n\t\tstruct ion_handle *handle;\n\n\t\thandle = ion_alloc(client, data.allocation.len,\n\t\t\t\t\t\tdata.allocation.align,\n\t\t\t\t\t\tdata.allocation.heap_id_mask,\n\t\t\t\t\t\tdata.allocation.flags);\n\t\tif (IS_ERR(handle))\n\t\t\treturn PTR_ERR(handle);\n\n\t\tdata.allocation.handle = handle->id;\n\n\t\tcleanup_handle = handle;\n\t\tbreak;\n\t}\n\tcase ION_IOC_FREE:\n \t{\n \t\tstruct ion_handle *handle;\n \n\t\thandle = ion_handle_get_by_id(client, data.handle.handle);\n\t\tif (IS_ERR(handle))\n \t\t\treturn PTR_ERR(handle);\n\t\tion_free(client, handle);\n\t\tion_handle_put(handle);\n \t\tbreak;\n \t}\n \tcase ION_IOC_SHARE:\n\tcase ION_IOC_MAP:\n\t{\n\t\tstruct ion_handle *handle;\n\n\t\thandle = ion_handle_get_by_id(client, data.handle.handle);\n\t\tif (IS_ERR(handle))\n\t\t\treturn PTR_ERR(handle);\n\t\tdata.fd.fd = ion_share_dma_buf_fd(client, handle);\n\t\tion_handle_put(handle);\n\t\tif (data.fd.fd < 0)\n\t\t\tret = data.fd.fd;\n\t\tbreak;\n\t}\n\tcase ION_IOC_IMPORT:\n\t{\n\t\tstruct ion_handle *handle;\n\n\t\thandle = ion_import_dma_buf_fd(client, data.fd.fd);\n\t\tif (IS_ERR(handle))\n\t\t\tret = PTR_ERR(handle);\n\t\telse\n\t\t\tdata.handle.handle = handle->id;\n\t\tbreak;\n\t}\n\tcase ION_IOC_SYNC:\n\t{\n\t\tret = ion_sync_for_device(client, data.fd.fd);\n\t\tbreak;\n\t}\n\tcase ION_IOC_CUSTOM:\n\t{\n\t\tif (!dev->custom_ioctl)\n\t\t\treturn -ENOTTY;\n\t\tret = dev->custom_ioctl(client, data.custom.cmd,\n\t\t\t\t\t\tdata.custom.arg);\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n\n\tif (dir & _IOC_READ) {\n\t\tif (copy_to_user((void __user *)arg, &data, _IOC_SIZE(cmd))) {\n\t\t\tif (cleanup_handle)\n\t\t\t\tion_free(client, cleanup_handle);\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\treturn ret;\n}\n", "target": 1, "idx": 180071}
{"func": "static void update_group_shares_cpu(struct task_group *tg, int cpu,\n\t\t\t\t    unsigned long sd_shares,\n\t\t\t\t    unsigned long sd_rq_weight,\n\t\t\t\t    unsigned long *usd_rq_weight)\n{\n\tunsigned long shares, rq_weight;\n\tint boost = 0;\n\n\trq_weight = usd_rq_weight[cpu];\n\tif (!rq_weight) {\n\t\tboost = 1;\n\t\trq_weight = NICE_0_LOAD;\n\t}\n\n\t/*\n\t *             \\Sum_j shares_j * rq_weight_i\n\t * shares_i =  -----------------------------\n\t *                  \\Sum_j rq_weight_j\n\t */\n\tshares = (sd_shares * rq_weight) / sd_rq_weight;\n\tshares = clamp_t(unsigned long, shares, MIN_SHARES, MAX_SHARES);\n\n\tif (abs(shares - tg->se[cpu]->load.weight) >\n\t\t\tsysctl_sched_shares_thresh) {\n\t\tstruct rq *rq = cpu_rq(cpu);\n\t\tunsigned long flags;\n\n\t\traw_spin_lock_irqsave(&rq->lock, flags);\n\t\ttg->cfs_rq[cpu]->rq_weight = boost ? 0 : rq_weight;\n\t\ttg->cfs_rq[cpu]->shares = boost ? 0 : shares;\n\t\t__set_se_shares(tg->se[cpu], shares);\n\t\traw_spin_unlock_irqrestore(&rq->lock, flags);\n\t}\n}\n", "target": 0, "idx": 22649}
{"func": "static void sample_hbp_handler(struct perf_event *bp, int nmi,\n \t\t\t       struct perf_sample_data *data,\n \t\t\t       struct pt_regs *regs)\n {\n\tprintk(KERN_INFO \"%s value is changed\\n\", ksym_name);\n\tdump_stack();\n\tprintk(KERN_INFO \"Dump stack from sample_hbp_handler\\n\");\n}\n", "target": 1, "idx": 179017}
{"func": "group_sched_in(struct perf_event *group_event,\n\t       struct perf_cpu_context *cpuctx,\n\t       struct perf_event_context *ctx)\n{\n\tstruct perf_event *event, *partial_group = NULL;\n\tstruct pmu *pmu = group_event->pmu;\n\tu64 now = ctx->time;\n\tbool simulate = false;\n\n\tif (group_event->state == PERF_EVENT_STATE_OFF)\n\t\treturn 0;\n\n\tpmu->start_txn(pmu);\n\n\tif (event_sched_in(group_event, cpuctx, ctx)) {\n\t\tpmu->cancel_txn(pmu);\n\t\treturn -EAGAIN;\n\t}\n\n\t/*\n\t * Schedule in siblings as one group (if any):\n\t */\n\tlist_for_each_entry(event, &group_event->sibling_list, group_entry) {\n\t\tif (event_sched_in(event, cpuctx, ctx)) {\n\t\t\tpartial_group = event;\n\t\t\tgoto group_error;\n\t\t}\n\t}\n\n\tif (!pmu->commit_txn(pmu))\n\t\treturn 0;\n\ngroup_error:\n\t/*\n\t * Groups can be scheduled in as one unit only, so undo any\n\t * partial group before returning:\n\t * The events up to the failed event are scheduled out normally,\n\t * tstamp_stopped will be updated.\n\t *\n\t * The failed events and the remaining siblings need to have\n\t * their timings updated as if they had gone thru event_sched_in()\n\t * and event_sched_out(). This is required to get consistent timings\n\t * across the group. This also takes care of the case where the group\n\t * could never be scheduled by ensuring tstamp_stopped is set to mark\n\t * the time the event was actually stopped, such that time delta\n\t * calculation in update_event_times() is correct.\n\t */\n\tlist_for_each_entry(event, &group_event->sibling_list, group_entry) {\n\t\tif (event == partial_group)\n\t\t\tsimulate = true;\n\n\t\tif (simulate) {\n\t\t\tevent->tstamp_running += now - event->tstamp_stopped;\n\t\t\tevent->tstamp_stopped = now;\n\t\t} else {\n\t\t\tevent_sched_out(event, cpuctx, ctx);\n\t\t}\n\t}\n\tevent_sched_out(group_event, cpuctx, ctx);\n\n\tpmu->cancel_txn(pmu);\n\n\treturn -EAGAIN;\n}\n", "target": 0, "idx": 26010}
{"func": "void TaskManagerTableModel::GetGroupRangeForItem(int item,\n                                                 views::GroupRange* range) {\n  TaskManagerModel::GroupRange range_pair =\n      model_->GetGroupRangeForResource(item);\n  range->start = range_pair.first;\n  range->length = range_pair.second;\n}\n", "target": 0, "idx": 114045}
{"func": " int mif_validate(jas_stream_t *in)\n {\n\tuchar buf[MIF_MAGICLEN];\n \tuint_fast32_t magic;\n \tint i;\n \tint n;\n\n\tassert(JAS_STREAM_MAXPUTBACK >= MIF_MAGICLEN);\n\n\t/* Read the validation data (i.e., the data used for detecting\n\t  the format). */\n\tif ((n = jas_stream_read(in, buf, MIF_MAGICLEN)) < 0) {\n\t\treturn -1;\n\t}\n\n\t/* Put the validation data back onto the stream, so that the\n\t  stream position will not be changed. */\n\tfor (i = n - 1; i >= 0; --i) {\n\t\tif (jas_stream_ungetc(in, buf[i]) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Was enough data read? */\n\tif (n < MIF_MAGICLEN) {\n\t\treturn -1;\n\t}\n\n\t/* Compute the signature value. */\n\tmagic = (JAS_CAST(uint_fast32_t, buf[0]) << 24) |\n\t  (JAS_CAST(uint_fast32_t, buf[1]) << 16) |\n\t  (JAS_CAST(uint_fast32_t, buf[2]) << 8) |\n\t  buf[3];\n\n\t/* Ensure that the signature is correct for this format. */\n\tif (magic != MIF_MAGIC) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n", "target": 1, "idx": 181897}
{"func": "static void logi_dj_recv_add_djhid_device(struct dj_receiver_dev *djrcv_dev,\n\t\t\t\t\t  struct dj_report *dj_report)\n{\n\t/* Called in delayed work context */\n\tstruct hid_device *djrcv_hdev = djrcv_dev->hdev;\n\tstruct usb_interface *intf = to_usb_interface(djrcv_hdev->dev.parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(intf);\n\tstruct hid_device *dj_hiddev;\n\tstruct dj_device *dj_dev;\n\n\t/* Device index goes from 1 to 6, we need 3 bytes to store the\n\t * semicolon, the index, and a null terminator\n\t */\n\tunsigned char tmpstr[3];\n\n\tif (dj_report->report_params[DEVICE_PAIRED_PARAM_SPFUNCTION] &\n\t    SPFUNCTION_DEVICE_LIST_EMPTY) {\n\t\tdbg_hid(\"%s: device list is empty\\n\", __func__);\n\t\tdjrcv_dev->querying_devices = false;\n \t\treturn;\n \t}\n \n\tif ((dj_report->device_index < DJ_DEVICE_INDEX_MIN) ||\n\t    (dj_report->device_index > DJ_DEVICE_INDEX_MAX)) {\n\t\tdev_err(&djrcv_hdev->dev, \"%s: invalid device index:%d\\n\",\n\t\t\t__func__, dj_report->device_index);\n\t\treturn;\n\t}\n \tif (djrcv_dev->paired_dj_devices[dj_report->device_index]) {\n \t\t/* The device is already known. No need to reallocate it. */\n \t\tdbg_hid(\"%s: device is already known\\n\", __func__);\n\t\treturn;\n\t}\n\n\tdj_hiddev = hid_allocate_device();\n\tif (IS_ERR(dj_hiddev)) {\n\t\tdev_err(&djrcv_hdev->dev, \"%s: hid_allocate_device failed\\n\",\n\t\t\t__func__);\n\t\treturn;\n\t}\n\n\tdj_hiddev->ll_driver = &logi_dj_ll_driver;\n\n\tdj_hiddev->dev.parent = &djrcv_hdev->dev;\n\tdj_hiddev->bus = BUS_USB;\n\tdj_hiddev->vendor = le16_to_cpu(usbdev->descriptor.idVendor);\n\tdj_hiddev->product = le16_to_cpu(usbdev->descriptor.idProduct);\n\tsnprintf(dj_hiddev->name, sizeof(dj_hiddev->name),\n\t\t\"Logitech Unifying Device. Wireless PID:%02x%02x\",\n\t\tdj_report->report_params[DEVICE_PAIRED_PARAM_EQUAD_ID_MSB],\n\t\tdj_report->report_params[DEVICE_PAIRED_PARAM_EQUAD_ID_LSB]);\n\n\tusb_make_path(usbdev, dj_hiddev->phys, sizeof(dj_hiddev->phys));\n\tsnprintf(tmpstr, sizeof(tmpstr), \":%d\", dj_report->device_index);\n\tstrlcat(dj_hiddev->phys, tmpstr, sizeof(dj_hiddev->phys));\n\n\tdj_dev = kzalloc(sizeof(struct dj_device), GFP_KERNEL);\n\n\tif (!dj_dev) {\n\t\tdev_err(&djrcv_hdev->dev, \"%s: failed allocating dj_device\\n\",\n\t\t\t__func__);\n\t\tgoto dj_device_allocate_fail;\n\t}\n\n\tdj_dev->reports_supported = get_unaligned_le32(\n\t\tdj_report->report_params + DEVICE_PAIRED_RF_REPORT_TYPE);\n\tdj_dev->hdev = dj_hiddev;\n\tdj_dev->dj_receiver_dev = djrcv_dev;\n\tdj_dev->device_index = dj_report->device_index;\n\tdj_hiddev->driver_data = dj_dev;\n\n\tdjrcv_dev->paired_dj_devices[dj_report->device_index] = dj_dev;\n\n\tif (hid_add_device(dj_hiddev)) {\n\t\tdev_err(&djrcv_hdev->dev, \"%s: failed adding dj_device\\n\",\n\t\t\t__func__);\n\t\tgoto hid_add_device_fail;\n\t}\n\n\treturn;\n\nhid_add_device_fail:\n\tdjrcv_dev->paired_dj_devices[dj_report->device_index] = NULL;\n\tkfree(dj_dev);\ndj_device_allocate_fail:\n\thid_destroy_device(dj_hiddev);\n}\n", "target": 1, "idx": 179550}
{"func": " pvscsi_ring_init_data(PVSCSIRingInfo *m, PVSCSICmdDescSetupRings *ri)\n {\n     int i;\n    uint32_t txr_len_log2, rxr_len_log2;\n     uint32_t req_ring_size, cmp_ring_size;\n     m->rs_pa = ri->ringsStatePPN << VMW_PAGE_SHIFT;\n \n    if ((ri->reqRingNumPages > PVSCSI_SETUP_RINGS_MAX_NUM_PAGES)\n        || (ri->cmpRingNumPages > PVSCSI_SETUP_RINGS_MAX_NUM_PAGES)) {\n        return -1;\n    }\n     req_ring_size = ri->reqRingNumPages * PVSCSI_MAX_NUM_REQ_ENTRIES_PER_PAGE;\n     cmp_ring_size = ri->cmpRingNumPages * PVSCSI_MAX_NUM_CMP_ENTRIES_PER_PAGE;\n     txr_len_log2 = pvscsi_log2(req_ring_size - 1);\n    }\n", "target": 1, "idx": 178109}
{"func": "bool HTMLMediaElement::HasClosedCaptions() const {\n  if (!text_tracks_)\n    return false;\n\n  for (unsigned i = 0; i < text_tracks_->length(); ++i) {\n    if (text_tracks_->AnonymousIndexedGetter(i)->CanBeRendered())\n      return true;\n  }\n\n  return false;\n}\n", "target": 0, "idx": 142807}
{"func": "static gboolean irssi_ssl_verify(SSL *ssl, SSL_CTX *ctx, X509 *cert)\n {\n \tif (SSL_get_verify_result(ssl) != X509_V_OK) {\n \t\tunsigned char md[EVP_MAX_MD_SIZE];\n\t\tunsigned int n;\n\t\tchar *str;\n\n\t\tg_warning(\"Could not verify SSL servers certificate:\");\n\t\tif ((str = X509_NAME_oneline(X509_get_subject_name(cert), 0, 0)) == NULL)\n\t\t\tg_warning(\"  Could not get subject-name from peer certificate\");\n\t\telse {\n\t\t\tg_warning(\"  Subject : %s\", str);\n\t\t\tfree(str);\n\t\t}\n\t\tif ((str = X509_NAME_oneline(X509_get_issuer_name(cert), 0, 0)) == NULL)\n\t\t\tg_warning(\"  Could not get issuer-name from peer certificate\");\n\t\telse {\n\t\t\tg_warning(\"  Issuer  : %s\", str);\n\t\t\tfree(str);\n\t\t}\n\t\tif (! X509_digest(cert, EVP_md5(), md, &n))\n\t\t\tg_warning(\"  Could not get fingerprint from peer certificate\");\n\t\telse {\n\t\t\tchar hex[] = \"0123456789ABCDEF\";\n\t\t\tchar fp[EVP_MAX_MD_SIZE*3];\n\t\t\tif (n < sizeof(fp)) {\n\t\t\t\tunsigned int i;\n\t\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\t\tfp[i*3+0] = hex[(md[i] >> 4) & 0xF];\n\t\t\t\t\tfp[i*3+1] = hex[(md[i] >> 0) & 0xF];\n\t\t\t\t\tfp[i*3+2] = i == n - 1 ? '\\0' : ':';\n\t\t\t\t}\n\t\t\t\tg_warning(\"  MD5 Fingerprint : %s\", fp);\n \t\t\t}\n \t\t}\n \t\treturn FALSE;\n \t}\n \treturn TRUE;\n }\n", "target": 1, "idx": 178690}
{"func": "MagickExport int ErrorBlob(const Image *image)\n{\n  BlobInfo\n    *magick_restrict blob_info;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->blob != (BlobInfo *) NULL);\n  assert(image->blob->type != UndefinedStream);\n  blob_info=image->blob;\n  switch (blob_info->type)\n  {\n    case UndefinedStream:\n    case StandardStream:\n      break;\n    case FileStream:\n    case PipeStream:\n    {\n      blob_info->error=ferror(blob_info->file_info.file);\n      break;\n    }\n    case ZipStream:\n    {\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n      (void) gzerror(blob_info->file_info.gzfile,&blob_info->error);\n#endif\n      break;\n    }\n    case BZipStream:\n    {\n#if defined(MAGICKCORE_BZLIB_DELEGATE)\n      (void) BZ2_bzerror(blob_info->file_info.bzfile,&blob_info->error);\n#endif\n      break;\n    }\n    case FifoStream:\n    {\n      blob_info->error=0;\n      break;\n    }\n    case BlobStream:\n      break;\n  }\n  return(blob_info->error);\n}\n", "target": 0, "idx": 88514}
{"func": "OMX_ERRORTYPE SimpleSoftOMXComponent::internalSetParameter(\n        OMX_INDEXTYPE index, const OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamPortDefinition:\n {\n\n             OMX_PARAM_PORTDEFINITIONTYPE *defParams =\n                 (OMX_PARAM_PORTDEFINITIONTYPE *)params;\n \n             if (defParams->nPortIndex >= mPorts.size()) {\n                 return OMX_ErrorBadPortIndex;\n             }\n if (defParams->nSize != sizeof(OMX_PARAM_PORTDEFINITIONTYPE)) {\n return OMX_ErrorUnsupportedSetting;\n }\n\n PortInfo *port =\n &mPorts.editItemAt(defParams->nPortIndex);\n\n if (defParams->nBufferSize > port->mDef.nBufferSize) {\n                port->mDef.nBufferSize = defParams->nBufferSize;\n }\n\n if (defParams->nBufferCountActual < port->mDef.nBufferCountMin) {\n                ALOGW(\"component requires at least %u buffers (%u requested)\",\n                        port->mDef.nBufferCountMin, defParams->nBufferCountActual);\n return OMX_ErrorUnsupportedSetting;\n }\n\n            port->mDef.nBufferCountActual = defParams->nBufferCountActual;\n return OMX_ErrorNone;\n }\n\n default:\n return OMX_ErrorUnsupportedIndex;\n }\n}\n", "target": 1, "idx": 188245}
{"func": "SYSCALL_DEFINE2(listen, int, fd, int, backlog)\n{\n\tstruct socket *sock;\n\tint err, fput_needed;\n\tint somaxconn;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (sock) {\n\t\tsomaxconn = sock_net(sock->sk)->core.sysctl_somaxconn;\n\t\tif ((unsigned int)backlog > somaxconn)\n\t\t\tbacklog = somaxconn;\n\n\t\terr = security_socket_listen(sock, backlog);\n\t\tif (!err)\n\t\t\terr = sock->ops->listen(sock, backlog);\n\n\t\tfput_light(sock->file, fput_needed);\n\t}\n\treturn err;\n}\n", "target": 0, "idx": 18608}
{"func": "static int nbd_negotiate_drop_sync(QIOChannel *ioc, size_t size)\n{\n    ssize_t ret;\n    uint8_t *buffer = g_malloc(MIN(65536, size));\n    while (size > 0) {\n        size_t count = MIN(65536, size);\n        ret = nbd_negotiate_read(ioc, buffer, count);\n        if (ret < 0) {\n            g_free(buffer);\n            return ret;\n        }\n        size -= count;\n    }\n    g_free(buffer);\n    return 0;\n}\n", "target": 1, "idx": 178625}
{"func": "void SelectionEditor::DidSplitTextNode(const Text& old_node) {\n  if (selection_.IsNone() || !old_node.isConnected()) {\n    DidFinishDOMMutation();\n    return;\n  }\n  const Position& new_base =\n      UpdatePostionAfterAdoptingTextNodeSplit(selection_.base_, old_node);\n  const Position& new_extent =\n      UpdatePostionAfterAdoptingTextNodeSplit(selection_.extent_, old_node);\n  DidFinishTextChange(new_base, new_extent);\n}\n", "target": 0, "idx": 135825}
{"func": "  int clear_count() const { return clear_count_; }\n", "target": 0, "idx": 167385}
{"func": "  bool IsMultiByteResponseExpected() {\n    return multibyte_response_expected_;\n  }\n", "target": 0, "idx": 98781}
{"func": "static int cypress_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tstruct cypress_private *priv = usb_get_serial_port_data(port);\n\tstruct usb_serial *serial = port->serial;\n\tunsigned long flags;\n\tint result = 0;\n\n\tif (!priv->comm_is_ok)\n\t\treturn -EIO;\n\n\t/* clear halts before open */\n\tusb_clear_halt(serial->dev, 0x81);\n\tusb_clear_halt(serial->dev, 0x02);\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\t/* reset read/write statistics */\n\tpriv->bytes_in = 0;\n\tpriv->bytes_out = 0;\n\tpriv->cmd_count = 0;\n\tpriv->rx_flags = 0;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\t/* Set termios */\n\tcypress_send(port);\n\n\tif (tty)\n \t\tcypress_set_termios(tty, port, &priv->tmp_termios);\n \n \t/* setup the port and start reading from the device */\n\tif (!port->interrupt_in_urb) {\n\t\tdev_err(&port->dev, \"%s - interrupt_in_urb is empty!\\n\",\n\t\t\t__func__);\n\t\treturn -1;\n\t}\n \tusb_fill_int_urb(port->interrupt_in_urb, serial->dev,\n \t\tusb_rcvintpipe(serial->dev, port->interrupt_in_endpointAddress),\n \t\tport->interrupt_in_urb->transfer_buffer,\n\t\tport->interrupt_in_urb->transfer_buffer_length,\n\t\tcypress_read_int_callback, port, priv->read_urb_interval);\n\tresult = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);\n\n\tif (result) {\n\t\tdev_err(&port->dev,\n\t\t\t\"%s - failed submitting read urb, error %d\\n\",\n\t\t\t\t\t\t\t__func__, result);\n\t\tcypress_set_dead(port);\n\t}\n\n\treturn result;\n} /* cypress_open */\n", "target": 1, "idx": 180532}
{"func": "static bool IsValidElementName(Document* document, const String& name) {\n  bool is_valid_dom_name = Document::IsValidName(name);\n  bool is_valid_html_name = IsValidElementNamePerHTMLParser(name);\n  if (UNLIKELY(is_valid_html_name != is_valid_dom_name)) {\n    UseCounter::Count(document,\n                      is_valid_dom_name\n                          ? WebFeature::kElementNameDOMValidHTMLParserInvalid\n                          : WebFeature::kElementNameDOMInvalidHTMLParserValid);\n  }\n  return is_valid_dom_name;\n}\n", "target": 0, "idx": 141140}
{"func": "static inline void removeElementPreservingChildren(PassRefPtr<DocumentFragment> fragment, HTMLElement* element)\n{\n    ExceptionCode ignoredExceptionCode;\n    RefPtr<Node> nextChild;\n    for (RefPtr<Node> child = element->firstChild(); child; child = nextChild) {\n        nextChild = child->nextSibling();\n        element->removeChild(child.get(), ignoredExceptionCode);\n        ASSERT(!ignoredExceptionCode);\n        fragment->insertBefore(child, element, ignoredExceptionCode);\n        ASSERT(!ignoredExceptionCode);\n    }\n    fragment->removeChild(element, ignoredExceptionCode);\n    ASSERT(!ignoredExceptionCode);\n}\n", "target": 1, "idx": 183893}
{"func": " pdf_show_image(fz_context *ctx, pdf_run_processor *pr, fz_image *image)\n {\n        pdf_gstate *gstate = pr->gstate + pr->gtop;\n        fz_matrix image_ctm;\n        fz_rect bbox;\n       softmask_save softmask = { NULL };\n \n        if (pr->super.hidden)\n                return;\n\t\t\tbreak;\n\t\tcase PDF_MAT_SHADE:\n\t\t\tif (gstate->fill.shade)\n\t\t\t{\n\t\t\t\tfz_clip_image_mask(ctx, pr->dev, image, &image_ctm, &bbox);\n        bbox = fz_unit_rect;\n        fz_transform_rect(&bbox, &image_ctm);\n \n       if (image->mask)\n        {\n                /* apply blend group even though we skip the soft mask */\n               if (gstate->blendmode)\n                       fz_begin_group(ctx, pr->dev, &bbox, NULL, 0, 0, gstate->blendmode, 1);\n               fz_clip_image_mask(ctx, pr->dev, image->mask, &image_ctm, &bbox);\n       }\n       else\n               gstate = pdf_begin_group(ctx, pr, &bbox, &softmask);\n \n       if (!image->colorspace)\n       {\n               switch (gstate->fill.kind)\n                {\n               case PDF_MAT_NONE:\n                       break;\n               case PDF_MAT_COLOR:\n                       fz_fill_image_mask(ctx, pr->dev, image, &image_ctm,\n                               gstate->fill.colorspace, gstate->fill.v, gstate->fill.alpha, &gstate->fill.color_params);\n                       break;\n               case PDF_MAT_PATTERN:\n                       if (gstate->fill.pattern)\n                       {\n                               fz_clip_image_mask(ctx, pr->dev, image, &image_ctm, &bbox);\n                               pdf_show_pattern(ctx, pr, gstate->fill.pattern, &pr->gstate[gstate->fill.gstate_num], &bbox, PDF_FILL);\n                               fz_pop_clip(ctx, pr->dev);\n                       }\n                       break;\n               case PDF_MAT_SHADE:\n                       if (gstate->fill.shade)\n                       {\n                               fz_clip_image_mask(ctx, pr->dev, image, &image_ctm, &bbox);\n                               fz_fill_shade(ctx, pr->dev, gstate->fill.shade, &pr->gstate[gstate->fill.gstate_num].ctm, gstate->fill.alpha, &gstate->fill.color_params);\n                               fz_pop_clip(ctx, pr->dev);\n                       }\n                       break;\n                }\n        }\n       else\n        {\n               fz_fill_image(ctx, pr->dev, image, &image_ctm, gstate->fill.alpha, &gstate->fill.color_params);\n        }\n       if (image->mask)\n        {\n               fz_pop_clip(ctx, pr->dev);\n               if (gstate->blendmode)\n                       fz_end_group(ctx, pr->dev);\n        }\n       else\n               pdf_end_group(ctx, pr, &softmask);\n }\n \n static void\n\n\t\tif (pr->clip)\n\t\t{\n\t\t\tgstate->clip_depth++;\n\t\t\tfz_clip_path(ctx, pr->dev, path, pr->clip_even_odd, &gstate->ctm, &bbox);\n\t\t\tpr->clip = 0;\n\t\t}\n\n\t\tif (pr->super.hidden)\n\t\t\tdostroke = dofill = 0;\n\n\t\tif (dofill || dostroke)\n\t\t\tgstate = pdf_begin_group(ctx, pr, &bbox, &softmask);\n\n\t\tif (dofill && dostroke)\n\t\t{\n\t\t\t/* We may need to push a knockout group */\n\t\t\tif (gstate->stroke.alpha == 0)\n\t\t\t{\n\t\t\t\t/* No need for group, as stroke won't do anything */\n\t\t\t}\n\t\t\telse if (gstate->stroke.alpha == 1.0f && gstate->blendmode == FZ_BLEND_NORMAL)\n\t\t\t{\n\t\t\t\t/* No need for group, as stroke won't show up */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tknockout_group = 1;\n\t\t\t\tfz_begin_group(ctx, pr->dev, &bbox, NULL, 0, 1, FZ_BLEND_NORMAL, 1);\n\t\t\t}\n\t\t}\n\n\t\tif (dofill)\n\t\t{\n\t\t\tswitch (gstate->fill.kind)\n\t\t\t{\n\t\t\tcase PDF_MAT_NONE:\n\t\t\t\tbreak;\n\t\t\tcase PDF_MAT_COLOR:\n\t\t\t\tfz_fill_path(ctx, pr->dev, path, even_odd, &gstate->ctm,\n\t\t\t\t\tgstate->fill.colorspace, gstate->fill.v, gstate->fill.alpha, &gstate->fill.color_params);\n\t\t\t\tbreak;\n\t\t\tcase PDF_MAT_PATTERN:\n\t\t\t\tif (gstate->fill.pattern)\n\t\t\t\t{\n\t\t\t\t\tfz_clip_path(ctx, pr->dev, path, even_odd, &gstate->ctm, &bbox);\n\t\t\t\t\tpdf_show_pattern(ctx, pr, gstate->fill.pattern, &pr->gstate[gstate->fill.gstate_num], &bbox, PDF_FILL);\n\t\t\t\t\tfz_pop_clip(ctx, pr->dev);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PDF_MAT_SHADE:\n\t\t\t\tif (gstate->fill.shade)\n\t\t\t\t{\n\t\t\t\t\tfz_clip_path(ctx, pr->dev, path, even_odd, &gstate->ctm, &bbox);\n\t\t\t\t\t/* The cluster and page 2 of patterns.pdf shows that fz_fill_shade should NOT be called with gstate->ctm. */\n\t\t\t\t\tfz_fill_shade(ctx, pr->dev, gstate->fill.shade, &pr->gstate[gstate->fill.gstate_num].ctm, gstate->fill.alpha, &gstate->fill.color_params);\n\t\t\t\t\tfz_pop_clip(ctx, pr->dev);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (dostroke)\n\t\t{\n\t\t\tswitch (gstate->stroke.kind)\n\t\t\t{\n\t\t\tcase PDF_MAT_NONE:\n\t\t\t\tbreak;\n\t\t\tcase PDF_MAT_COLOR:\n\t\t\t\tfz_stroke_path(ctx, pr->dev, path, gstate->stroke_state, &gstate->ctm,\n\t\t\t\t\tgstate->stroke.colorspace, gstate->stroke.v, gstate->stroke.alpha, &gstate->stroke.color_params);\n\t\t\t\tbreak;\n\t\t\tcase PDF_MAT_PATTERN:\n\t\t\t\tif (gstate->stroke.pattern)\n\t\t\t\t{\n\t\t\t\t\tfz_clip_stroke_path(ctx, pr->dev, path, gstate->stroke_state, &gstate->ctm, &bbox);\n\t\t\t\t\tpdf_show_pattern(ctx, pr, gstate->stroke.pattern, &pr->gstate[gstate->stroke.gstate_num], &bbox, PDF_STROKE);\n\t\t\t\t\tfz_pop_clip(ctx, pr->dev);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PDF_MAT_SHADE:\n\t\t\t\tif (gstate->stroke.shade)\n\t\t\t\t{\n\t\t\t\t\tfz_clip_stroke_path(ctx, pr->dev, path, gstate->stroke_state, &gstate->ctm, &bbox);\n\t\t\t\t\tfz_fill_shade(ctx, pr->dev, gstate->stroke.shade, &pr->gstate[gstate->stroke.gstate_num].ctm, gstate->stroke.alpha, &gstate->stroke.color_params);\n\t\t\t\t\tfz_pop_clip(ctx, pr->dev);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (knockout_group)\n\t\t\tfz_end_group(ctx, pr->dev);\n\n\t\tif (dofill || dostroke)\n\t\t\tpdf_end_group(ctx, pr, &softmask);\n\t}\n", "target": 1, "idx": 177752}
{"func": "psf_close (SF_PRIVATE *psf)\n{\tuint32_t k ;\n\tint\terror = 0 ;\n\n\tif (psf->codec_close)\n\t{\terror = psf->codec_close (psf) ;\n\t\t/* To prevent it being called in psf->container_close(). */\n\t\tpsf->codec_close = NULL ;\n\t\t} ;\n\n\tif (psf->container_close)\n\t\terror = psf->container_close (psf) ;\n\n\terror = psf_fclose (psf) ;\n \tpsf_close_rsrc (psf) ;\n \n \t/* For an ISO C compliant implementation it is ok to free a NULL pointer. */\n \tfree (psf->container_data) ;\n \tfree (psf->codec_data) ;\n \tfree (psf->interleave) ;\n\tfree (psf->dither) ;\n\tfree (psf->peak_info) ;\n\tfree (psf->broadcast_16k) ;\n\tfree (psf->loop_info) ;\n\tfree (psf->instrument) ;\n\tfree (psf->cues) ;\n\tfree (psf->channel_map) ;\n\tfree (psf->format_desc) ;\n\tfree (psf->strings.storage) ;\n\n\tif (psf->wchunks.chunks)\n\t\tfor (k = 0 ; k < psf->wchunks.used ; k++)\n\t\t\tfree (psf->wchunks.chunks [k].data) ;\n\tfree (psf->rchunks.chunks) ;\n\tfree (psf->wchunks.chunks) ;\n\tfree (psf->iterator) ;\n\tfree (psf->cart_16k) ;\n\n\tmemset (psf, 0, sizeof (SF_PRIVATE)) ;\n\tfree (psf) ;\n\n\treturn error ;\n} /* psf_close */\n", "target": 1, "idx": 183238}
{"func": "  _bdf_list_join( _bdf_list_t*    list,\n                  int             c,\n                  unsigned long  *alen )\n  {\n    unsigned long  i, j;\n    char           *fp, *dp;\n\n\n    *alen = 0;\n\n    if ( list == 0 || list->used == 0 )\n      return 0;\n\n    dp = list->field[0];\n    for ( i = j = 0; i < list->used; i++ )\n    {\n      fp = list->field[i];\n      while ( *fp )\n        dp[j++] = *fp++;\n\n      if ( i + 1 < list->used )\n        dp[j++] = (char)c;\n    }\n    if ( dp != empty )\n      dp[j] = 0;\n\n    *alen = j;\n    return dp;\n  }\n", "target": 0, "idx": 6511}
{"func": "  TestResultCallback()\n      : callback_(base::Bind(&TestResultCallback::SetResult,\n                             base::Unretained(this))) {}\n", "target": 1, "idx": 185855}
{"func": "static void set_rx_flow_off(struct caifsock *cf_sk)\n{\n\t clear_bit(RX_FLOW_ON_BIT,\n\t\t (void *) &cf_sk->flow_state);\n}\n", "target": 0, "idx": 30686}
{"func": " void EnableHighDPISupport() {\n   if (IsHighDPIEnabled() &&\n      (base::win::GetVersion() < base::win::VERSION_WIN8_1)) {\n    if (!SetProcessDpiAwarenessWrapper(PROCESS_SYSTEM_DPI_AWARE)) {\n      SetProcessDPIAwareWrapper();\n    }\n   }\n }\n", "target": 1, "idx": 185602}
{"func": "void bnep_net_setup(struct net_device *dev)\n{\n\n\tmemset(dev->broadcast, 0xff, ETH_ALEN);\n \tdev->addr_len = ETH_ALEN;\n \n \tether_setup(dev);\n \tdev->netdev_ops = &bnep_netdev_ops;\n \n \tdev->watchdog_timeo  = HZ * 2;\n}\n", "target": 1, "idx": 178909}
{"func": "static int cannotBeFunction(Parse *pParse, struct SrcList_item *pFrom){\n  if( pFrom->fg.isTabFunc ){\n    sqlite3ErrorMsg(pParse, \"'%s' is not a function\", pFrom->zName);\n    return 1;\n  }\n  return 0;\n}\n", "target": 0, "idx": 149043}
{"func": "IndexedDBTransaction::Operation IndexedDBTransaction::TaskQueue::pop() {\n  DCHECK(!queue_.empty());\n  Operation task = std::move(queue_.front());\n  queue_.pop();\n  return task;\n}\n", "target": 0, "idx": 168665}
{"func": "  void RunScrollbarThumbDragLatencyTest() {\n#if !defined(OS_ANDROID)\n    blink::WebFloatPoint scrollbar_thumb(795, 30);\n    blink::WebMouseEvent mouse_down = SyntheticWebMouseEventBuilder::Build(\n        blink::WebInputEvent::kMouseDown, scrollbar_thumb.x, scrollbar_thumb.y,\n        0);\n    mouse_down.button = blink::WebMouseEvent::Button::kLeft;\n    mouse_down.SetTimeStamp(base::TimeTicks::Now());\n    GetWidgetHost()->ForwardMouseEvent(mouse_down);\n    blink::WebMouseEvent mouse_move = SyntheticWebMouseEventBuilder::Build(\n        blink::WebInputEvent::kMouseMove, scrollbar_thumb.x,\n        scrollbar_thumb.y + 10, 0);\n    mouse_move.button = blink::WebMouseEvent::Button::kLeft;\n    mouse_move.SetTimeStamp(base::TimeTicks::Now());\n    GetWidgetHost()->ForwardMouseEvent(mouse_move);\n    RunUntilInputProcessed(GetWidgetHost());\n    mouse_move.SetPositionInWidget(scrollbar_thumb.x, scrollbar_thumb.y + 20);\n    mouse_move.SetPositionInScreen(scrollbar_thumb.x, scrollbar_thumb.y + 20);\n    GetWidgetHost()->ForwardMouseEvent(mouse_move);\n    RunUntilInputProcessed(GetWidgetHost());\n    blink::WebMouseEvent mouse_up = SyntheticWebMouseEventBuilder::Build(\n        blink::WebInputEvent::kMouseUp, scrollbar_thumb.x,\n        scrollbar_thumb.y + 20, 0);\n    mouse_up.button = blink::WebMouseEvent::Button::kLeft;\n    mouse_up.SetTimeStamp(base::TimeTicks::Now());\n    GetWidgetHost()->ForwardMouseEvent(mouse_up);\n    RunUntilInputProcessed(GetWidgetHost());\n    FetchHistogramsFromChildProcesses();\n    const std::string scroll_types[] = {\"ScrollBegin\", \"ScrollUpdate\"};\n    for (const std::string& scroll_type : scroll_types) {\n      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n          1, \"Event.Latency.\" + scroll_type +\n                 \".Scrollbar.TimeToScrollUpdateSwapBegin4\"));\n      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n          1, \"Event.Latency.\" + scroll_type +\n                 \".Scrollbar.RendererSwapToBrowserNotified2\"));\n      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n          1, \"Event.Latency.\" + scroll_type +\n                 \".Scrollbar.BrowserNotifiedToBeforeGpuSwap2\"));\n      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n          1, \"Event.Latency.\" + scroll_type + \".Scrollbar.GpuSwap2\"));\n      std::string thread_name =\n          DoesScrollbarScrollOnMainThread() ? \"Main\" : \"Impl\";\n      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n          1, \"Event.Latency.\" + scroll_type + \".Scrollbar.TimeToHandled2_\" +\n                 thread_name));\n      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n          1, \"Event.Latency.\" + scroll_type +\n                 \".Scrollbar.HandledToRendererSwap2_\" + thread_name));\n    }\n#endif  // !defined(OS_ANDROID)\n  }\n", "target": 1, "idx": 186397}
{"func": "init_ext2_xattr(void)\n {\n\text2_xattr_cache = mb_cache_create(\"ext2_xattr\", 6);\n\tif (!ext2_xattr_cache)\n\t\treturn -ENOMEM;\n\treturn 0;\n }\n", "target": 1, "idx": 183157}
{"func": "SpoolssRFFPCNEX_r(tvbuff_t *tvb, int offset,\n\t\t\t     packet_info *pinfo, proto_tree *tree,\n\t\t\t     dcerpc_info *di, guint8 *drep _U_)\n{\n\t/* Parse packet */\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n", "target": 0, "idx": 51973}
{"func": "virDomainPMWakeup(virDomainPtr dom,\n                  unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(dom, \"flags=%x\", flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    conn = dom->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainPMWakeup) {\n        int ret;\n        ret = conn->driver->domainPMWakeup(dom, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return -1;\n}\n", "target": 0, "idx": 93893}
{"func": "std::unique_ptr<service_manager::Service> CreateDataDecoderService() {\n  content::UtilityThread::Get()->EnsureBlinkInitialized();\n  return data_decoder::DataDecoderService::Create();\n}\n", "target": 0, "idx": 138390}
{"func": "\t\tvoid CWebServer::Cmd_AddSceneCode(WebEmSession & session, const request& req, Json::Value &root)\n\t\t{\n\t\t\tif (session.rights != 2)\n\t\t\t{\n\t\t\t\tsession.reply_status = reply::forbidden;\n\t\t\t\treturn; //Only admin user allowed\n\t\t\t}\n\n\t\t\tstd::string sceneidx = request::findValue(&req, \"sceneidx\");\n\t\t\tstd::string idx = request::findValue(&req, \"idx\");\n\t\t\tstd::string cmnd = request::findValue(&req, \"cmnd\");\n\t\t\tif (\n\t\t\t\t(sceneidx.empty()) ||\n\t\t\t\t(idx.empty()) ||\n\t\t\t\t(cmnd.empty())\n\t\t\t\t)\n\t\t\t\treturn;\n\t\t\troot[\"status\"] = \"OK\";\n\t\t\troot[\"title\"] = \"AddSceneCode\";\n\n\t\t\tstd::vector<std::vector<std::string> > result;\n\t\t\tresult = m_sql.safe_query(\"SELECT Activators, SceneType FROM Scenes WHERE (ID==%q)\", sceneidx.c_str());\n\t\t\tif (result.empty())\n\t\t\t\treturn;\n\t\t\tstd::string Activators = result[0][0];\n\t\t\tunsigned char scenetype = atoi(result[0][1].c_str());\n\n\t\t\tif (!Activators.empty())\n\t\t\t{\n\t\t\t\tstd::vector<std::string> arrayActivators;\n\t\t\t\tStringSplit(Activators, \";\", arrayActivators);\n\t\t\t\tfor (const auto & ittAct : arrayActivators)\n\t\t\t\t{\n\t\t\t\t\tstd::string sCodeCmd = ittAct;\n\n\t\t\t\t\tstd::vector<std::string> arrayCode;\n\t\t\t\t\tStringSplit(sCodeCmd, \":\", arrayCode);\n\n\t\t\t\t\tstd::string sID = arrayCode[0];\n\t\t\t\t\tstd::string sCode = \"\";\n\t\t\t\t\tif (arrayCode.size() == 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tsCode = arrayCode[1];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (sID == idx)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (scenetype == 1)\n\t\t\t\t\t\t\treturn; //Group does not work with separate codes, so already there\n\t\t\t\t\t\tif (sCode == cmnd)\n\t\t\t\t\t\t\treturn; //same code, already there!\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!Activators.empty())\n\t\t\t\tActivators += \";\";\n\t\t\tActivators += idx;\n\t\t\tif (scenetype == 0)\n\t\t\t{\n\t\t\t\tActivators += \":\" + cmnd;\n\t\t\t}\n\t\t\tm_sql.safe_query(\"UPDATE Scenes SET Activators='%q' WHERE (ID==%q)\", Activators.c_str(), sceneidx.c_str());\n\t\t}\n", "target": 0, "idx": 90967}
{"func": "static void tcp_v4_reqsk_destructor(struct request_sock *req)\n{\n\tkfree(inet_rsk(req)->opt);\n}\n", "target": 0, "idx": 19040}
{"func": "reread_byte(struct file *file)\n /* Read a byte when an error is not expected to happen because the byte has\n    * been read before without error.\n    */\n{\n int ch = getc(file->file);\n\n if (errno != 0)\n      file->read_errno = errno;\n\n if (ch < 0 || ch > 255)\n      stop(file, UNEXPECTED_ERROR_CODE, \"reread\");\n\n return (png_byte)ch;\n}\n", "target": 0, "idx": 173315}
{"func": "static int cine_read_probe(AVProbeData *p)\n{\n    int HeaderSize;\n    if (p->buf[0] == 'C' && p->buf[1] == 'I' &&  // Type\n        (HeaderSize = AV_RL16(p->buf + 2)) >= 0x2C &&  // HeaderSize\n        AV_RL16(p->buf + 4) <= CC_UNINT &&       // Compression\n        AV_RL16(p->buf + 6) <= 1 &&              // Version\n        AV_RL32(p->buf + 20) &&                  // ImageCount\n        AV_RL32(p->buf + 24) >= HeaderSize &&    // OffImageHeader\n        AV_RL32(p->buf + 28) >= HeaderSize &&    // OffSetup\n        AV_RL32(p->buf + 32) >= HeaderSize)      // OffImageOffsets\n        return AVPROBE_SCORE_MAX;\n    return 0;\n}\n", "target": 0, "idx": 61774}
{"func": "static int futex_wait_requeue_pi(u32 __user *uaddr, int fshared,\n\t\t\t\t u32 val, ktime_t *abs_time, u32 bitset,\n\t\t\t\t int clockrt, u32 __user *uaddr2)\n{\n\tstruct hrtimer_sleeper timeout, *to = NULL;\n\tstruct rt_mutex_waiter rt_waiter;\n\tstruct rt_mutex *pi_mutex = NULL;\n\tstruct futex_hash_bucket *hb;\n\tunion futex_key key2;\n\tstruct futex_q q;\n\tint res, ret;\n\n\tif (!bitset)\n\t\treturn -EINVAL;\n\n\tif (abs_time) {\n\t\tto = &timeout;\n\t\thrtimer_init_on_stack(&to->timer, clockrt ? CLOCK_REALTIME :\n\t\t\t\t      CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\t\thrtimer_init_sleeper(to, current);\n\t\thrtimer_set_expires_range_ns(&to->timer, *abs_time,\n\t\t\t\t\t     current->timer_slack_ns);\n\t}\n\n\t/*\n\t * The waiter is allocated on our stack, manipulated by the requeue\n\t * code while we sleep on uaddr.\n\t */\n\tdebug_rt_mutex_init_waiter(&rt_waiter);\n\trt_waiter.task = NULL;\n\n\tkey2 = FUTEX_KEY_INIT;\n\tret = get_futex_key(uaddr2, fshared, &key2);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\n\tq.pi_state = NULL;\n\tq.bitset = bitset;\n \tq.rt_waiter = &rt_waiter;\n \tq.requeue_pi_key = &key2;\n \n\t/* Prepare to wait on uaddr. */\n \tret = futex_wait_setup(uaddr, val, fshared, &q, &hb);\n \tif (ret)\n \t\tgoto out_key2;\n\n\t/* Queue the futex_q, drop the hb lock, wait for wakeup. */\n\tfutex_wait_queue_me(hb, &q, to);\n\n\tspin_lock(&hb->lock);\n\tret = handle_early_requeue_pi_wakeup(hb, &q, &key2, to);\n\tspin_unlock(&hb->lock);\n\tif (ret)\n\t\tgoto out_put_keys;\n\n\t/*\n \t * In order for us to be here, we know our q.key == key2, and since\n \t * we took the hb->lock above, we also know that futex_requeue() has\n \t * completed and we no longer have to concern ourselves with a wakeup\n\t * race with the atomic proxy lock acquition by the requeue code.\n \t */\n \n \t/* Check if the requeue code acquired the second futex for us. */\n\tif (!q.rt_waiter) {\n\t\t/*\n\t\t * Got the lock. We might not be the anticipated owner if we\n\t\t * did a lock-steal - fix up the PI-state in that case.\n\t\t */\n\t\tif (q.pi_state && (q.pi_state->owner != current)) {\n\t\t\tspin_lock(q.lock_ptr);\n\t\t\tret = fixup_pi_state_owner(uaddr2, &q, current,\n\t\t\t\t\t\t   fshared);\n\t\t\tspin_unlock(q.lock_ptr);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * We have been woken up by futex_unlock_pi(), a timeout, or a\n\t\t * signal.  futex_unlock_pi() will not destroy the lock_ptr nor\n\t\t * the pi_state.\n\t\t */\n\t\tWARN_ON(!&q.pi_state);\n\t\tpi_mutex = &q.pi_state->pi_mutex;\n\t\tret = rt_mutex_finish_proxy_lock(pi_mutex, to, &rt_waiter, 1);\n\t\tdebug_rt_mutex_free_waiter(&rt_waiter);\n\n\t\tspin_lock(q.lock_ptr);\n\t\t/*\n\t\t * Fixup the pi_state owner and possibly acquire the lock if we\n\t\t * haven't already.\n\t\t */\n\t\tres = fixup_owner(uaddr2, fshared, &q, !ret);\n\t\t/*\n\t\t * If fixup_owner() returned an error, proprogate that.  If it\n\t\t * acquired the lock, clear -ETIMEDOUT or -EINTR.\n\t\t */\n\t\tif (res)\n\t\t\tret = (res < 0) ? res : 0;\n\n\t\t/* Unqueue and drop the lock. */\n\t\tunqueue_me_pi(&q);\n\t}\n\n\t/*\n\t * If fixup_pi_state_owner() faulted and was unable to handle the\n\t * fault, unlock the rt_mutex and return the fault to userspace.\n\t */\n\tif (ret == -EFAULT) {\n\t\tif (rt_mutex_owner(pi_mutex) == current)\n\t\t\trt_mutex_unlock(pi_mutex);\n\t} else if (ret == -EINTR) {\n\t\t/*\n\t\t * We've already been requeued, but cannot restart by calling\n\t\t * futex_lock_pi() directly. We could restart this syscall, but\n\t\t * it would detect that the user space \"val\" changed and return\n\t\t * -EWOULDBLOCK.  Save the overhead of the restart and return\n\t\t * -EWOULDBLOCK directly.\n\t\t */\n\t\tret = -EWOULDBLOCK;\n\t}\n\nout_put_keys:\n\tput_futex_key(fshared, &q.key);\nout_key2:\n\tput_futex_key(fshared, &key2);\n\nout:\n\tif (to) {\n\t\thrtimer_cancel(&to->timer);\n\t\tdestroy_hrtimer_on_stack(&to->timer);\n\t}\n\treturn ret;\n}\n", "target": 1, "idx": 179622}
{"func": " void UserSelectionScreen::OnBeforeUserRemoved(const AccountId& account_id) {\n  for (user_manager::UserList::iterator it = users_.begin(); it != users_.end();\n       ++it) {\n     if ((*it)->GetAccountId() == account_id) {\n       users_.erase(it);\n       break;\n    }\n  }\n}\n", "target": 1, "idx": 186170}
{"func": "service_is_single_onion_poisoned(const rend_service_t *service)\n{\n  char *poison_fname = NULL;\n  file_status_t fstatus;\n\n  /* Passing a NULL service is a bug */\n  if (BUG(!service)) {\n    return 0;\n  }\n\n  if (rend_service_is_ephemeral(service)) {\n    return 0;\n  }\n\n  poison_fname = rend_service_sos_poison_path(service);\n\n  fstatus = file_status(poison_fname);\n  tor_free(poison_fname);\n\n  /* If this fname is occupied, the hidden service has been poisoned.\n   * fstatus can be FN_ERROR if the service directory does not exist, in that\n   * case, there is obviously no private key. */\n  if (fstatus == FN_FILE || fstatus == FN_EMPTY) {\n    return 1;\n  }\n\n  return 0;\n}\n", "target": 0, "idx": 69650}
{"func": "void SafeBrowsingBlockingPageV2::PopulateStringDictionary(\n    DictionaryValue* strings,\n    const string16& title,\n    const string16& headline,\n    const string16& description1,\n    const string16& description2,\n    const string16& description3) {\n  strings->SetString(\"title\", title);\n  strings->SetString(\"headLine\", headline);\n  strings->SetString(\"description1\", description1);\n  strings->SetString(\"description2\", description2);\n  strings->SetString(\"description3\", description3);\n  strings->SetBoolean(\"proceedDisabled\",\n                      IsPrefEnabled(prefs::kSafeBrowsingProceedAnywayDisabled));\n  strings->SetBoolean(\"isMainFrame\", is_main_frame_load_blocked_);\n  strings->SetBoolean(\"isPhishing\", interstitial_type_ == TYPE_PHISHING);\n\n  strings->SetString(\"back_button\",\n      l10n_util::GetStringUTF16(IDS_SAFE_BROWSING_MALWARE_BACK_BUTTON));\n  strings->SetString(\"seeMore\", l10n_util::GetStringUTF16(\n      IDS_SAFE_BROWSING_MALWARE_V2_SEE_MORE));\n  strings->SetString(\"proceed\",\n      l10n_util::GetStringUTF16(IDS_SAFE_BROWSING_MALWARE_V2_PROCEED_LINK));\n\n  URLDataSource::SetFontAndTextDirection(strings);\n}\n", "target": 0, "idx": 123495}
{"func": "  virtual void AddObserver(Observer* observer) {\n     if (!observers_.size()) {\n       observer->FirstObserverIsAdded(this);\n     }\n     observers_.AddObserver(observer);\n   }\n", "target": 1, "idx": 183933}
{"func": "static int check_func_call(struct bpf_verifier_env *env, struct bpf_insn *insn,\n\t\t\t   int *insn_idx)\n{\n\tstruct bpf_verifier_state *state = env->cur_state;\n\tstruct bpf_func_state *caller, *callee;\n\tint i, subprog, target_insn;\n\n\tif (state->curframe + 1 >= MAX_CALL_FRAMES) {\n\t\tverbose(env, \"the call stack of %d frames is too deep\\n\",\n\t\t\tstate->curframe + 2);\n\t\treturn -E2BIG;\n\t}\n\n\ttarget_insn = *insn_idx + insn->imm;\n\tsubprog = find_subprog(env, target_insn + 1);\n\tif (subprog < 0) {\n\t\tverbose(env, \"verifier bug. No program starts at insn %d\\n\",\n\t\t\ttarget_insn + 1);\n\t\treturn -EFAULT;\n\t}\n\n\tcaller = state->frame[state->curframe];\n\tif (state->frame[state->curframe + 1]) {\n\t\tverbose(env, \"verifier bug. Frame %d already allocated\\n\",\n\t\t\tstate->curframe + 1);\n\t\treturn -EFAULT;\n\t}\n\n\tcallee = kzalloc(sizeof(*callee), GFP_KERNEL);\n\tif (!callee)\n\t\treturn -ENOMEM;\n\tstate->frame[state->curframe + 1] = callee;\n\n\t/* callee cannot access r0, r6 - r9 for reading and has to write\n\t * into its own stack before reading from it.\n\t * callee can read/write into caller's stack\n\t */\n\tinit_func_state(env, callee,\n\t\t\t/* remember the callsite, it will be used by bpf_exit */\n\t\t\t*insn_idx /* callsite */,\n\t\t\tstate->curframe + 1 /* frameno within this callchain */,\n\t\t\tsubprog /* subprog number within this prog */);\n\n\t/* copy r1 - r5 args that callee can access */\n\tfor (i = BPF_REG_1; i <= BPF_REG_5; i++)\n\t\tcallee->regs[i] = caller->regs[i];\n\n\t/* after the call regsiters r0 - r5 were scratched */\n\tfor (i = 0; i < CALLER_SAVED_REGS; i++) {\n\t\tmark_reg_not_init(env, caller->regs, caller_saved[i]);\n\t\tcheck_reg_arg(env, caller_saved[i], DST_OP_NO_MARK);\n\t}\n\n\t/* only increment it after check_reg_arg() finished */\n\tstate->curframe++;\n\n\t/* and go analyze first insn of the callee */\n\t*insn_idx = target_insn;\n\n\tif (env->log.level) {\n\t\tverbose(env, \"caller:\\n\");\n\t\tprint_verifier_state(env, caller);\n\t\tverbose(env, \"callee:\\n\");\n\t\tprint_verifier_state(env, callee);\n\t}\n\treturn 0;\n}\n", "target": 0, "idx": 76371}
{"func": "DecodeNumberField(int len, char *str, int fmask,\n\t\t\t\t  int *tmask, struct tm * tm, fsec_t *fsec, int *is2digits)\n{\n\tchar\t   *cp;\n\n\t/*\n\t * Have a decimal point? Then this is a date or something with a seconds\n\t * field...\n\t */\n \tif ((cp = strchr(str, '.')) != NULL)\n \t{\n #ifdef HAVE_INT64_TIMESTAMP\n\t\tchar\t\tfstr[MAXDATELEN + 1];\n \n \t\t/*\n \t\t * OK, we have at most six digits to care about. Let's construct a\n\t\t * string and then do the conversion to an integer.\n \t\t */\n\t\tstrcpy(fstr, (cp + 1));\n\t\tstrcpy(fstr + strlen(fstr), \"000000\");\n\t\t*(fstr + 6) = '\\0';\n \t\t*fsec = strtol(fstr, NULL, 10);\n #else\n \t\t*fsec = strtod(cp, NULL);\n#endif\n\t\t*cp = '\\0';\n\t\tlen = strlen(str);\n\t}\n\t/* No decimal point and no complete date yet? */\n\telse if ((fmask & DTK_DATE_M) != DTK_DATE_M)\n\t{\n\t\t/* yyyymmdd? */\n\t\tif (len == 8)\n\t\t{\n\t\t\t*tmask = DTK_DATE_M;\n\n\t\t\ttm->tm_mday = atoi(str + 6);\n\t\t\t*(str + 6) = '\\0';\n\t\t\ttm->tm_mon = atoi(str + 4);\n\t\t\t*(str + 4) = '\\0';\n\t\t\ttm->tm_year = atoi(str + 0);\n\n\t\t\treturn DTK_DATE;\n\t\t}\n\t\t/* yymmdd? */\n\t\telse if (len == 6)\n\t\t{\n\t\t\t*tmask = DTK_DATE_M;\n\t\t\ttm->tm_mday = atoi(str + 4);\n\t\t\t*(str + 4) = '\\0';\n\t\t\ttm->tm_mon = atoi(str + 2);\n\t\t\t*(str + 2) = '\\0';\n\t\t\ttm->tm_year = atoi(str + 0);\n\t\t\t*is2digits = TRUE;\n\n\t\t\treturn DTK_DATE;\n\t\t}\n\t\t/* yyddd? */\n\t\telse if (len == 5)\n\t\t{\n\t\t\t*tmask = DTK_DATE_M;\n\t\t\ttm->tm_mday = atoi(str + 2);\n\t\t\t*(str + 2) = '\\0';\n\t\t\ttm->tm_mon = 1;\n\t\t\ttm->tm_year = atoi(str + 0);\n\t\t\t*is2digits = TRUE;\n\n\t\t\treturn DTK_DATE;\n\t\t}\n\t}\n\n\t/* not all time fields are specified? */\n\tif ((fmask & DTK_TIME_M) != DTK_TIME_M)\n\t{\n\t\t/* hhmmss */\n\t\tif (len == 6)\n\t\t{\n\t\t\t*tmask = DTK_TIME_M;\n\t\t\ttm->tm_sec = atoi(str + 4);\n\t\t\t*(str + 4) = '\\0';\n\t\t\ttm->tm_min = atoi(str + 2);\n\t\t\t*(str + 2) = '\\0';\n\t\t\ttm->tm_hour = atoi(str + 0);\n\n\t\t\treturn DTK_TIME;\n\t\t}\n\t\t/* hhmm? */\n\t\telse if (len == 4)\n\t\t{\n\t\t\t*tmask = DTK_TIME_M;\n\t\t\ttm->tm_sec = 0;\n\t\t\ttm->tm_min = atoi(str + 2);\n\t\t\t*(str + 2) = '\\0';\n\t\t\ttm->tm_hour = atoi(str + 0);\n\n\t\t\treturn DTK_TIME;\n\t\t}\n\t}\n\n\treturn -1;\n}\t/* DecodeNumberField() */\n", "target": 1, "idx": 179636}
{"func": "static uint64_t ahci_mem_read_32(void *opaque, hwaddr addr)\n{\n    AHCIState *s = opaque;\n    uint32_t val = 0;\n\n    if (addr < AHCI_GENERIC_HOST_CONTROL_REGS_MAX_ADDR) {\n        switch (addr) {\n        case HOST_CAP:\n            val = s->control_regs.cap;\n            break;\n        case HOST_CTL:\n            val = s->control_regs.ghc;\n            break;\n        case HOST_IRQ_STAT:\n            val = s->control_regs.irqstatus;\n            break;\n        case HOST_PORTS_IMPL:\n            val = s->control_regs.impl;\n            break;\n        case HOST_VERSION:\n            val = s->control_regs.version;\n            break;\n        }\n\n        DPRINTF(-1, \"(addr 0x%08X), val 0x%08X\\n\", (unsigned) addr, val);\n    } else if ((addr >= AHCI_PORT_REGS_START_ADDR) &&\n               (addr < (AHCI_PORT_REGS_START_ADDR +\n                (s->ports * AHCI_PORT_ADDR_OFFSET_LEN)))) {\n        val = ahci_port_read(s, (addr - AHCI_PORT_REGS_START_ADDR) >> 7,\n                             addr & AHCI_PORT_ADDR_OFFSET_MASK);\n    }\n\n    return val;\n}\n", "target": 0, "idx": 5870}
{"func": "PHP_FUNCTION(time_nanosleep)\n{\n\tlong tv_sec, tv_nsec;\n\tstruct timespec php_req, php_rem;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ll\", &tv_sec, &tv_nsec) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (tv_sec < 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"The seconds value must be greater than 0\");\n\t\tRETURN_FALSE;\n\t}\n\tif (tv_nsec < 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"The nanoseconds value must be greater than 0\");\n\t\tRETURN_FALSE;\n\t}\n\n\tphp_req.tv_sec = (time_t) tv_sec;\n\tphp_req.tv_nsec = tv_nsec;\n\tif (!nanosleep(&php_req, &php_rem)) {\n\t\tRETURN_TRUE;\n\t} else if (errno == EINTR) {\n\t\tarray_init(return_value);\n\t\tadd_assoc_long_ex(return_value, \"seconds\", sizeof(\"seconds\"), php_rem.tv_sec);\n\t\tadd_assoc_long_ex(return_value, \"nanoseconds\", sizeof(\"nanoseconds\"), php_rem.tv_nsec);\n\t\treturn;\n\t} else if (errno == EINVAL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"nanoseconds was not in the range 0 to 999 999 999 or seconds was negative\");\n\t}\n\n\tRETURN_FALSE;\n}\n", "target": 0, "idx": 4260}
{"func": "MagickExport void *DetachBlob(BlobInfo *blob_info)\n{\n  void\n    *data;\n\n  assert(blob_info != (BlobInfo *) NULL);\n  if (blob_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n   if (blob_info->mapped != MagickFalse)\n     {\n       (void) UnmapBlob(blob_info->data,blob_info->length);\n       RelinquishMagickResource(MapResource,blob_info->length);\n     }\n   blob_info->mapped=MagickFalse;\n  blob_info->length=0;\n  blob_info->offset=0;\n  blob_info->eof=MagickFalse;\n  blob_info->error=0;\n  blob_info->exempt=MagickFalse;\n  blob_info->type=UndefinedStream;\n  blob_info->file_info.file=(FILE *) NULL;\n  data=blob_info->data;\n  blob_info->data=(unsigned char *) NULL;\n  blob_info->stream=(StreamHandler) NULL;\n  blob_info->custom_stream=(CustomStreamInfo *) NULL;\n  return(data);\n}\n", "target": 1, "idx": 183362}
{"func": "aura::Window* PartialMagnificationController::GetCurrentRootWindow() {\n  aura::Window::Windows root_windows = Shell::GetAllRootWindows();\n  for (aura::Window::Windows::const_iterator iter = root_windows.begin();\n       iter != root_windows.end(); ++iter) {\n    aura::Window* root_window = *iter;\n    if (root_window->ContainsPointInRoot(\n            root_window->GetHost()->dispatcher()->GetLastMouseLocationInRoot()))\n      return root_window;\n  }\n  return NULL;\n}\n", "target": 1, "idx": 185512}
{"func": "void ShelfLayoutManager::ProcessGestureEventOfAutoHideShelf(\n    ui::GestureEvent* event,\n    aura::Window* target) {\n  const bool is_shelf_window = IsShelfWindow(target);\n  if (IsVisible() || in_shutdown_) {\n    if (!is_shelf_window && !IsStatusAreaWindow(target) &&\n        visibility_state() == SHELF_AUTO_HIDE &&\n        state_.auto_hide_state == SHELF_AUTO_HIDE_SHOWN &&\n        event->type() == ui::ET_GESTURE_TAP) {\n      UpdateAutoHideState();\n    }\n    return;\n  }\n\n  if (is_shelf_window) {\n    ui::GestureEvent event_in_screen(*event);\n    gfx::Point location_in_screen(event->location());\n    ::wm::ConvertPointToScreen(target, &location_in_screen);\n    event_in_screen.set_location(location_in_screen);\n    if (ProcessGestureEvent(event_in_screen))\n      event->StopPropagation();\n  }\n}\n", "target": 0, "idx": 142476}
{"func": "void TabStripModel::SelectNextTab() {\n  SelectRelativeTab(true);\n}\n", "target": 0, "idx": 102998}
{"func": "struct sk_buff **udp_gro_receive(struct sk_buff **head, struct sk_buff *skb,\n\t\t\t\t struct udphdr *uh)\n{\n\tstruct udp_offload_priv *uo_priv;\n\tstruct sk_buff *p, **pp = NULL;\n\tstruct udphdr *uh2;\n \tunsigned int off = skb_gro_offset(skb);\n \tint flush = 1;\n \n\tif (NAPI_GRO_CB(skb)->udp_mark ||\n \t    (skb->ip_summed != CHECKSUM_PARTIAL &&\n \t     NAPI_GRO_CB(skb)->csum_cnt == 0 &&\n \t     !NAPI_GRO_CB(skb)->csum_valid))\n \t\tgoto out;\n \n\t/* mark that this skb passed once through the udp gro layer */\n\tNAPI_GRO_CB(skb)->udp_mark = 1;\n \n \trcu_read_lock();\n \tuo_priv = rcu_dereference(udp_offload_base);\n\tfor (; uo_priv != NULL; uo_priv = rcu_dereference(uo_priv->next)) {\n\t\tif (net_eq(read_pnet(&uo_priv->net), dev_net(skb->dev)) &&\n\t\t    uo_priv->offload->port == uh->dest &&\n\t\t    uo_priv->offload->callbacks.gro_receive)\n\t\t\tgoto unflush;\n\t}\n\tgoto out_unlock;\n\nunflush:\n\tflush = 0;\n\n\tfor (p = *head; p; p = p->next) {\n\t\tif (!NAPI_GRO_CB(p)->same_flow)\n\t\t\tcontinue;\n\n\t\tuh2 = (struct udphdr   *)(p->data + off);\n\n\t\t/* Match ports and either checksums are either both zero\n\t\t * or nonzero.\n\t\t */\n\t\tif ((*(u32 *)&uh->source != *(u32 *)&uh2->source) ||\n\t\t    (!uh->check ^ !uh2->check)) {\n\t\t\tNAPI_GRO_CB(p)->same_flow = 0;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tskb_gro_pull(skb, sizeof(struct udphdr)); /* pull encapsulating udp header */\n\tskb_gro_postpull_rcsum(skb, uh, sizeof(struct udphdr));\n\tNAPI_GRO_CB(skb)->proto = uo_priv->offload->ipproto;\n\tpp = uo_priv->offload->callbacks.gro_receive(head, skb,\n\t\t\t\t\t\t     uo_priv->offload);\n\nout_unlock:\n\trcu_read_unlock();\nout:\n\tNAPI_GRO_CB(skb)->flush |= flush;\n\treturn pp;\n}\n", "target": 1, "idx": 180079}
{"func": "static ssize_t driver_override_show(struct device *dev,\n \t\t\t\t    struct device_attribute *attr, char *buf)\n {\n \tstruct platform_device *pdev = to_platform_device(dev);\n \n\treturn sprintf(buf, \"%s\\n\", pdev->driver_override);\n }\n", "target": 1, "idx": 181163}
{"func": "entry_guard_obeys_restriction(const entry_guard_t *guard,\n                              const entry_guard_restriction_t *rst)\n{\n  tor_assert(guard);\n   if (! rst)\n     return 1; // No restriction?  No problem.\n \n   return tor_memneq(guard->identity, rst->exclude_id, DIGEST_LEN);\n }\n", "target": 1, "idx": 181622}
{"func": "error::Error GLES2DecoderPassthroughImpl::DoScheduleCALayerCHROMIUM(\n    GLuint contents_texture_id,\n    const GLfloat* contents_rect,\n    GLuint background_color,\n    GLuint edge_aa_mask,\n    const GLfloat* bounds_rect) {\n  NOTIMPLEMENTED();\n  return error::kNoError;\n}\n", "target": 0, "idx": 154786}
{"func": "WebContentsImpl* WebContentsImpl::FromFrameTreeNode(\n    FrameTreeNode* frame_tree_node) {\n  return static_cast<WebContentsImpl*>(\n      WebContents::FromRenderFrameHost(frame_tree_node->current_frame_host()));\n}\n", "target": 0, "idx": 144506}
{"func": " void DataReductionProxySettings::InitDataReductionProxySettings(\n     PrefService* prefs,\n    DataReductionProxyIOData* io_data,\n    std::unique_ptr<DataReductionProxyService> data_reduction_proxy_service) {\n  DCHECK(thread_checker_.CalledOnValidThread());\n  DCHECK(prefs);\n  DCHECK(io_data);\n  DCHECK(io_data->config());\n  DCHECK(data_reduction_proxy_service);\n  prefs_ = prefs;\n   config_ = io_data->config();\n   data_reduction_proxy_service_ = std::move(data_reduction_proxy_service);\n   data_reduction_proxy_service_->AddObserver(this);\n  InitPrefMembers();\n   RecordDataReductionInit();\n \n #if defined(OS_ANDROID)\n  if (spdy_proxy_auth_enabled_.GetValue()) {\n     data_reduction_proxy_service_->compression_stats()\n         ->SetDataUsageReportingEnabled(true);\n   }\n#endif  // defined(OS_ANDROID)\n\n  for (auto& observer : observers_)\n    observer.OnSettingsInitialized();\n}\n", "target": 1, "idx": 186521}
{"func": "SYSCALL_DEFINE3(sendmsg, int, fd, struct msghdr __user *, msg, unsigned int, flags)\n{\n\tif (flags & MSG_CMSG_COMPAT)\n\t\treturn -EINVAL;\n\treturn __sys_sendmsg(fd, msg, flags);\n}\n", "target": 0, "idx": 40677}
{"func": "tgs_make_reply(krb5_context context,\n\t       krb5_kdc_configuration *config,\n\t       KDC_REQ_BODY *b,\n\t       krb5_const_principal tgt_name,\n\t       const EncTicketPart *tgt,\n\t       const krb5_keyblock *replykey,\n\t       int rk_is_subkey,\n\t       const EncryptionKey *serverkey,\n\t       const krb5_keyblock *sessionkey,\n\t       krb5_kvno kvno,\n\t       AuthorizationData *auth_data,\n\t       hdb_entry_ex *server,\n\t       krb5_principal server_principal,\n \t       const char *server_name,\n \t       hdb_entry_ex *client,\n \t       krb5_principal client_principal,\n \t       hdb_entry_ex *krbtgt,\n \t       krb5_enctype krbtgt_etype,\n \t       krb5_principals spp,\n\t       const krb5_data *rspac,\n\t       const METHOD_DATA *enc_pa_data,\n\t       const char **e_text,\n\t       krb5_data *reply)\n{\n    KDC_REP rep;\n    EncKDCRepPart ek;\n    EncTicketPart et;\n    KDCOptions f = b->kdc_options;\n    krb5_error_code ret;\n    int is_weak = 0;\n\n    memset(&rep, 0, sizeof(rep));\n    memset(&et, 0, sizeof(et));\n    memset(&ek, 0, sizeof(ek));\n\n    rep.pvno = 5;\n    rep.msg_type = krb_tgs_rep;\n\n    et.authtime = tgt->authtime;\n    _kdc_fix_time(&b->till);\n    et.endtime = min(tgt->endtime, *b->till);\n    ALLOC(et.starttime);\n    *et.starttime = kdc_time;\n\n    ret = check_tgs_flags(context, config, b, tgt, &et);\n    if(ret)\n\tgoto out;\n\n    /* We should check the transited encoding if:\n       1) the request doesn't ask not to be checked\n       2) globally enforcing a check\n       3) principal requires checking\n       4) we allow non-check per-principal, but principal isn't marked as allowing this\n       5) we don't globally allow this\n    */\n\n#define GLOBAL_FORCE_TRANSITED_CHECK\t\t\\\n    (config->trpolicy == TRPOLICY_ALWAYS_CHECK)\n#define GLOBAL_ALLOW_PER_PRINCIPAL\t\t\t\\\n    (config->trpolicy == TRPOLICY_ALLOW_PER_PRINCIPAL)\n#define GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK\t\t\t\\\n    (config->trpolicy == TRPOLICY_ALWAYS_HONOUR_REQUEST)\n\n/* these will consult the database in future release */\n#define PRINCIPAL_FORCE_TRANSITED_CHECK(P)\t\t0\n#define PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK(P)\t0\n\n    ret = fix_transited_encoding(context, config,\n\t\t\t\t !f.disable_transited_check ||\n\t\t\t\t GLOBAL_FORCE_TRANSITED_CHECK ||\n\t\t\t\t PRINCIPAL_FORCE_TRANSITED_CHECK(server) ||\n\t\t\t\t !((GLOBAL_ALLOW_PER_PRINCIPAL &&\n\t\t\t\t    PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK(server)) ||\n\t\t\t\t   GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK),\n \t\t\t\t &tgt->transited, &et,\n \t\t\t\t krb5_principal_get_realm(context, client_principal),\n \t\t\t\t krb5_principal_get_realm(context, server->entry.principal),\n\t\t\t\t krb5_principal_get_realm(context, krbtgt->entry.principal));\n     if(ret)\n \tgoto out;\n \n    copy_Realm(&server_principal->realm, &rep.ticket.realm);\n    _krb5_principal2principalname(&rep.ticket.sname, server_principal);\n    copy_Realm(&tgt_name->realm, &rep.crealm);\n/*\n    if (f.request_anonymous)\n\t_kdc_make_anonymous_principalname (&rep.cname);\n    else */\n\n    copy_PrincipalName(&tgt_name->name, &rep.cname);\n    rep.ticket.tkt_vno = 5;\n\n    ek.caddr = et.caddr;\n\n    {\n\ttime_t life;\n\tlife = et.endtime - *et.starttime;\n\tif(client && client->entry.max_life)\n\t    life = min(life, *client->entry.max_life);\n\tif(server->entry.max_life)\n\t    life = min(life, *server->entry.max_life);\n\tet.endtime = *et.starttime + life;\n    }\n    if(f.renewable_ok && tgt->flags.renewable &&\n       et.renew_till == NULL && et.endtime < *b->till &&\n       tgt->renew_till != NULL)\n    {\n\tet.flags.renewable = 1;\n\tALLOC(et.renew_till);\n\t*et.renew_till = *b->till;\n    }\n    if(et.renew_till){\n\ttime_t renew;\n\trenew = *et.renew_till - *et.starttime;\n\tif(client && client->entry.max_renew)\n\t    renew = min(renew, *client->entry.max_renew);\n\tif(server->entry.max_renew)\n\t    renew = min(renew, *server->entry.max_renew);\n\t*et.renew_till = *et.starttime + renew;\n    }\n\n    if(et.renew_till){\n\t*et.renew_till = min(*et.renew_till, *tgt->renew_till);\n\t*et.starttime = min(*et.starttime, *et.renew_till);\n\tet.endtime = min(et.endtime, *et.renew_till);\n    }\n\n    *et.starttime = min(*et.starttime, et.endtime);\n\n    if(*et.starttime == et.endtime){\n\tret = KRB5KDC_ERR_NEVER_VALID;\n\tgoto out;\n    }\n    if(et.renew_till && et.endtime == *et.renew_till){\n\tfree(et.renew_till);\n\tet.renew_till = NULL;\n\tet.flags.renewable = 0;\n    }\n\n    et.flags.pre_authent = tgt->flags.pre_authent;\n    et.flags.hw_authent  = tgt->flags.hw_authent;\n    et.flags.anonymous   = tgt->flags.anonymous;\n    et.flags.ok_as_delegate = server->entry.flags.ok_as_delegate;\n\n    if(rspac->length) {\n\t/*\n\t * No not need to filter out the any PAC from the\n\t * auth_data since it's signed by the KDC.\n\t */\n\tret = _kdc_tkt_add_if_relevant_ad(context, &et,\n\t\t\t\t\t  KRB5_AUTHDATA_WIN2K_PAC, rspac);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (auth_data) {\n\tunsigned int i = 0;\n\n\t/* XXX check authdata */\n\n\tif (et.authorization_data == NULL) {\n\t    et.authorization_data = calloc(1, sizeof(*et.authorization_data));\n\t    if (et.authorization_data == NULL) {\n\t\tret = ENOMEM;\n\t\tkrb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t\tgoto out;\n\t    }\n\t}\n\tfor(i = 0; i < auth_data->len ; i++) {\n\t    ret = add_AuthorizationData(et.authorization_data, &auth_data->val[i]);\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t\tgoto out;\n\t    }\n\t}\n\n\t/* Filter out type KRB5SignedPath */\n\tret = find_KRB5SignedPath(context, et.authorization_data, NULL);\n\tif (ret == 0) {\n\t    if (et.authorization_data->len == 1) {\n\t\tfree_AuthorizationData(et.authorization_data);\n\t\tfree(et.authorization_data);\n\t\tet.authorization_data = NULL;\n\t    } else {\n\t\tAuthorizationData *ad = et.authorization_data;\n\t\tfree_AuthorizationDataElement(&ad->val[ad->len - 1]);\n\t\tad->len--;\n\t    }\n\t}\n    }\n\n    ret = krb5_copy_keyblock_contents(context, sessionkey, &et.key);\n    if (ret)\n\tgoto out;\n    et.crealm = tgt_name->realm;\n    et.cname = tgt_name->name;\n\n    ek.key = et.key;\n    /* MIT must have at least one last_req */\n    ek.last_req.val = calloc(1, sizeof(*ek.last_req.val));\n    if (ek.last_req.val == NULL) {\n\tret = ENOMEM;\n\tgoto out;\n    }\n    ek.last_req.len = 1; /* set after alloc to avoid null deref on cleanup */\n    ek.nonce = b->nonce;\n    ek.flags = et.flags;\n    ek.authtime = et.authtime;\n    ek.starttime = et.starttime;\n    ek.endtime = et.endtime;\n    ek.renew_till = et.renew_till;\n    ek.srealm = rep.ticket.realm;\n    ek.sname = rep.ticket.sname;\n\n    _kdc_log_timestamp(context, config, \"TGS-REQ\", et.authtime, et.starttime,\n\t\t       et.endtime, et.renew_till);\n\n    /* Don't sign cross realm tickets, they can't be checked anyway */\n    {\n\tchar *r = get_krbtgt_realm(&ek.sname);\n\n\tif (r == NULL || strcmp(r, ek.srealm) == 0) {\n\t    ret = _kdc_add_KRB5SignedPath(context,\n\t\t\t\t\t  config,\n\t\t\t\t\t  krbtgt,\n\t\t\t\t\t  krbtgt_etype,\n\t\t\t\t\t  client_principal,\n\t\t\t\t\t  NULL,\n\t\t\t\t\t  spp,\n\t\t\t\t\t  &et);\n\t    if (ret)\n\t\tgoto out;\n\t}\n    }\n\n    if (enc_pa_data->len) {\n\trep.padata = calloc(1, sizeof(*rep.padata));\n\tif (rep.padata == NULL) {\n\t    ret = ENOMEM;\n\t    goto out;\n\t}\n\tret = copy_METHOD_DATA(enc_pa_data, rep.padata);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (krb5_enctype_valid(context, serverkey->keytype) != 0\n\t&& _kdc_is_weak_exception(server->entry.principal, serverkey->keytype))\n    {\n\tkrb5_enctype_enable(context, serverkey->keytype);\n\tis_weak = 1;\n    }\n\n\n    /* It is somewhat unclear where the etype in the following\n       encryption should come from. What we have is a session\n       key in the passed tgt, and a list of preferred etypes\n       *for the new ticket*. Should we pick the best possible\n       etype, given the keytype in the tgt, or should we look\n       at the etype list here as well?  What if the tgt\n       session key is DES3 and we want a ticket with a (say)\n       CAST session key. Should the DES3 etype be added to the\n       etype list, even if we don't want a session key with\n       DES3? */\n    ret = _kdc_encode_reply(context, config, NULL, 0,\n\t\t\t    &rep, &et, &ek, serverkey->keytype,\n\t\t\t    kvno,\n\t\t\t    serverkey, 0, replykey, rk_is_subkey,\n\t\t\t    e_text, reply);\n    if (is_weak)\n\tkrb5_enctype_disable(context, serverkey->keytype);\n\nout:\n    free_TGS_REP(&rep);\n    free_TransitedEncoding(&et.transited);\n    if(et.starttime)\n\tfree(et.starttime);\n    if(et.renew_till)\n\tfree(et.renew_till);\n    if(et.authorization_data) {\n\tfree_AuthorizationData(et.authorization_data);\n\tfree(et.authorization_data);\n    }\n    free_LastReq(&ek.last_req);\n    memset(et.key.keyvalue.data, 0, et.key.keyvalue.length);\n    free_EncryptionKey(&et.key);\n    return ret;\n}\n", "target": 1, "idx": 181499}
{"func": " static int em_syscall(struct x86_emulate_ctxt *ctxt)\n {\n \tstruct x86_emulate_ops *ops = ctxt->ops;\n\tstruct desc_struct cs, ss;\n\tu64 msr_data;\n\tu16 cs_sel, ss_sel;\n\tu64 efer = 0;\n\n\t/* syscall is not available in real mode */\n\tif (ctxt->mode == X86EMUL_MODE_REAL ||\n \t    ctxt->mode == X86EMUL_MODE_VM86)\n \t\treturn emulate_ud(ctxt);\n \n \tops->get_msr(ctxt, MSR_EFER, &efer);\n \tsetup_syscalls_segments(ctxt, &cs, &ss);\n \n \tops->get_msr(ctxt, MSR_STAR, &msr_data);\n \tmsr_data >>= 32;\n \tcs_sel = (u16)(msr_data & 0xfffc);\n\tss_sel = (u16)(msr_data + 8);\n\n\tif (efer & EFER_LMA) {\n\t\tcs.d = 0;\n\t\tcs.l = 1;\n\t}\n\tops->set_segment(ctxt, cs_sel, &cs, 0, VCPU_SREG_CS);\n\tops->set_segment(ctxt, ss_sel, &ss, 0, VCPU_SREG_SS);\n\n\tctxt->regs[VCPU_REGS_RCX] = ctxt->_eip;\n\tif (efer & EFER_LMA) {\n#ifdef CONFIG_X86_64\n\t\tctxt->regs[VCPU_REGS_R11] = ctxt->eflags & ~EFLG_RF;\n\n\t\tops->get_msr(ctxt,\n\t\t\t     ctxt->mode == X86EMUL_MODE_PROT64 ?\n\t\t\t     MSR_LSTAR : MSR_CSTAR, &msr_data);\n\t\tctxt->_eip = msr_data;\n\n\t\tops->get_msr(ctxt, MSR_SYSCALL_MASK, &msr_data);\n\t\tctxt->eflags &= ~(msr_data | EFLG_RF);\n#endif\n\t} else {\n\t\t/* legacy mode */\n\t\tops->get_msr(ctxt, MSR_STAR, &msr_data);\n\t\tctxt->_eip = (u32)msr_data;\n\n\t\tctxt->eflags &= ~(EFLG_VM | EFLG_IF | EFLG_RF);\n\t}\n\n\treturn X86EMUL_CONTINUE;\n}\n", "target": 1, "idx": 178826}
{"func": "bool WebstoreStandaloneInstaller::EnsureUniqueInstall(\n    webstore_install::Result* reason,\n    std::string* error) {\n  InstallTracker* tracker = InstallTracker::Get(profile_);\n  DCHECK(tracker);\n\n  const ActiveInstallData* existing_install_data =\n       tracker->GetActiveInstall(id_);\n   if (existing_install_data) {\n     *reason = webstore_install::INSTALL_IN_PROGRESS;\n    *error = kInstallInProgressError;\n     return false;\n   }\n \n  ActiveInstallData install_data(id_);\n  InitInstallData(&install_data);\n  scoped_active_install_.reset(new ScopedActiveInstall(tracker, install_data));\n  return true;\n}\n", "target": 1, "idx": 186050}
{"func": "IDNSpoofChecker::IDNSpoofChecker() {\n  UErrorCode status = U_ZERO_ERROR;\n  checker_ = uspoof_open(&status);\n  if (U_FAILURE(status)) {\n    checker_ = nullptr;\n    return;\n  }\n\n\n  uspoof_setRestrictionLevel(checker_, USPOOF_HIGHLY_RESTRICTIVE);\n\n  SetAllowedUnicodeSet(&status);\n\n  int32_t checks = uspoof_getChecks(checker_, &status) | USPOOF_AUX_INFO;\n  uspoof_setChecks(checker_, checks, &status);\n\n  deviation_characters_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u00df\\\\u03c2\\\\u200c\\\\u200d]\"), status);\n  deviation_characters_.freeze();\n\n  non_ascii_latin_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Latin:] - [a-zA-Z]]\"), status);\n  non_ascii_latin_letters_.freeze();\n\n  kana_letters_exceptions_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u3078-\\\\u307a\\\\u30d8-\\\\u30da\\\\u30fb-\\\\u30fe]\"),\n      status);\n  kana_letters_exceptions_.freeze();\n  combining_diacritics_exceptions_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[\\\\u0300-\\\\u0339]\"), status);\n  combining_diacritics_exceptions_.freeze();\n\n  cyrillic_letters_latin_alike_ = icu::UnicodeSet(\n      icu::UnicodeString::fromUTF8(\"[\u0430\u0441\u0501\u0435\u04bb\u0456\u0458\u04cf\u043e\u0440\u051b\u0455\u051d\u0445\u0443\u044a\u042c\u04bd\u043f\u0433\u0475\u0461]\"), status);\n  cyrillic_letters_latin_alike_.freeze();\n\n  cyrillic_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Cyrl:]]\"), status);\n  cyrillic_letters_.freeze();\n\n  DCHECK(U_SUCCESS(status));\n  lgc_letters_n_ascii_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[[:Latin:][:Greek:][:Cyrillic:][0-9\\\\u002e_\"\n                            \"\\\\u002d][\\\\u0300-\\\\u0339]]\"),\n      status);\n  lgc_letters_n_ascii_.freeze();\n\n  UParseError parse_error;\n  diacritic_remover_.reset(icu::Transliterator::createFromRules(\n      UNICODE_STRING_SIMPLE(\"DropAcc\"),\n      icu::UnicodeString::fromUTF8(\"::NFD; ::[:Nonspacing Mark:] Remove; ::NFC;\"\n                                   \" \u0142 > l; \u00f8 > o; \u0111 > d;\"),\n      UTRANS_FORWARD, parse_error, status));\n\n   extra_confusable_mapper_.reset(icu::Transliterator::createFromRules(\n       UNICODE_STRING_SIMPLE(\"ExtraConf\"),\n      icu::UnicodeString::fromUTF8(\"[\u00fe\u03fc\u048f] > p; [\u0127\u043d\u045b\u04a3\u04a5\u04c8\u04ca\u0527\u0529] > h;\"\n                                   \"[\u0138\u03ba\u043a\u049b\u049d\u049f\u04a1\u04c4\u051f] > k; [\u014b\u043f] > n; [\u0167\u0442\u04ad] > t;\"\n                                    \"[\u0185\u044c\u048d\u0432] > b;  [\u03c9\u0448\u0449\u0e1f] > w; [\u043c\u04ce] > m;\"\n                                   \"[\u0454\u04bd\u04bf\u1054] > e; \u0491 > r; \u0493 > f; [\u04ab\u1004] > c;\"\n                                    \"\u04b1 > y; [\u03c7\u04b3\u04fd\u04ff] > x;\"\n #if defined(OS_WIN)\n                                    \"\u04cf > i;\"\n #else\n                                    \"\u04cf > l;\"\n #endif\n                                   \"\u0503  > d; [\u050d\u100c] > g; [\u0d1f\u0e23] > s; \u1042 > j\"),\n       UTRANS_FORWARD, parse_error, status));\n   DCHECK(U_SUCCESS(status))\n       << \"Spoofchecker initalization failed due to an error: \"\n      << u_errorName(status);\n}\n", "target": 1, "idx": 186713}
{"func": "int perf_event_refresh(struct perf_event *event, int refresh)\n{\n\t/*\n\t * not supported on inherited events\n\t */\n\tif (event->attr.inherit || !is_sampling_event(event))\n\t\treturn -EINVAL;\n\n\tatomic_add(refresh, &event->event_limit);\n\tperf_event_enable(event);\n\n\treturn 0;\n}\n", "target": 0, "idx": 31951}
{"func": "static u16 b43_dmacontroller_base(enum b43_dmatype type, int controller_idx)\n{\n\tstatic const u16 map64[] = {\n\t\tB43_MMIO_DMA64_BASE0,\n\t\tB43_MMIO_DMA64_BASE1,\n\t\tB43_MMIO_DMA64_BASE2,\n\t\tB43_MMIO_DMA64_BASE3,\n\t\tB43_MMIO_DMA64_BASE4,\n\t\tB43_MMIO_DMA64_BASE5,\n\t};\n\tstatic const u16 map32[] = {\n\t\tB43_MMIO_DMA32_BASE0,\n\t\tB43_MMIO_DMA32_BASE1,\n\t\tB43_MMIO_DMA32_BASE2,\n\t\tB43_MMIO_DMA32_BASE3,\n\t\tB43_MMIO_DMA32_BASE4,\n\t\tB43_MMIO_DMA32_BASE5,\n\t};\n\n\tif (type == B43_DMA_64BIT) {\n\t\tB43_WARN_ON(!(controller_idx >= 0 &&\n\t\t\t      controller_idx < ARRAY_SIZE(map64)));\n\t\treturn map64[controller_idx];\n\t}\n\tB43_WARN_ON(!(controller_idx >= 0 &&\n\t\t      controller_idx < ARRAY_SIZE(map32)));\n\treturn map32[controller_idx];\n}\n", "target": 0, "idx": 24538}
{"func": "void SyncBackendHost::Core::RouteJsEvent(\n    const std::string& name, const JsEventDetails& details) {\n  host_->frontend_loop_->PostTask(\n      FROM_HERE, NewRunnableMethod(\n          this, &Core::RouteJsEventOnFrontendLoop, name, details));\n}\n", "target": 0, "idx": 106350}
{"func": "static int _nfs4_proc_access(struct inode *inode, struct nfs_access_entry *entry)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs4_accessargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.bitmask = server->attr_bitmask,\n\t};\n\tstruct nfs4_accessres res = {\n\t\t.server = server,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_ACCESS],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t\t.rpc_cred = entry->cred,\n\t};\n\tint mode = entry->mask;\n\tint status;\n\n\t/*\n\t * Determine which access bits we want to ask for...\n\t */\n\tif (mode & MAY_READ)\n\t\targs.access |= NFS4_ACCESS_READ;\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tif (mode & MAY_WRITE)\n\t\t\targs.access |= NFS4_ACCESS_MODIFY | NFS4_ACCESS_EXTEND | NFS4_ACCESS_DELETE;\n\t\tif (mode & MAY_EXEC)\n\t\t\targs.access |= NFS4_ACCESS_LOOKUP;\n\t} else {\n\t\tif (mode & MAY_WRITE)\n\t\t\targs.access |= NFS4_ACCESS_MODIFY | NFS4_ACCESS_EXTEND;\n\t\tif (mode & MAY_EXEC)\n\t\t\targs.access |= NFS4_ACCESS_EXECUTE;\n\t}\n\n\tres.fattr = nfs_alloc_fattr();\n\tif (res.fattr == NULL)\n\t\treturn -ENOMEM;\n\n\tstatus = nfs4_call_sync(server->client, server, &msg, &args.seq_args, &res.seq_res, 0);\n\tif (!status) {\n\t\tentry->mask = 0;\n\t\tif (res.access & NFS4_ACCESS_READ)\n\t\t\tentry->mask |= MAY_READ;\n\t\tif (res.access & (NFS4_ACCESS_MODIFY | NFS4_ACCESS_EXTEND | NFS4_ACCESS_DELETE))\n\t\t\tentry->mask |= MAY_WRITE;\n\t\tif (res.access & (NFS4_ACCESS_LOOKUP|NFS4_ACCESS_EXECUTE))\n\t\t\tentry->mask |= MAY_EXEC;\n\t\tnfs_refresh_inode(inode, res.fattr);\n\t}\n\tnfs_free_fattr(res.fattr);\n\treturn status;\n}\n", "target": 0, "idx": 23171}
{"func": "pdf_load_version(fz_context *ctx, pdf_document *doc)\n{\n\tchar buf[20];\n\n\tfz_seek(ctx, doc->file, 0, SEEK_SET);\n\tfz_read_line(ctx, doc->file, buf, sizeof buf);\n\tif (memcmp(buf, \"%PDF-\", 5) != 0)\n\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"cannot recognize version marker\");\n\n\tdoc->version = 10 * (fz_atof(buf+5) + 0.05f);\n\tif (doc->version < 10 || doc->version > 17)\n\t\tif (doc->version != 20)\n\t\t\tfz_warn(ctx, \"unknown PDF version: %d.%d\", doc->version / 10, doc->version % 10);\n}\n", "target": 0, "idx": 16711}
{"func": "timeval_equals(struct timeval * tv0, struct timeval * tv1)\n{\n    if ( tv0->tv_sec == tv1->tv_sec && tv0->tv_usec == tv1->tv_usec )\n\treturn 1;\n    else\n\treturn 0;\n}\n", "target": 0, "idx": 53456}
{"func": "void RenderFrameDevToolsAgentHost::DestroyOnRenderFrameGone() {\n   scoped_refptr<RenderFrameDevToolsAgentHost> protect(this);\n   if (IsAttached())\n     RevokePolicy();\n  ForceDetachAllClients();\n   frame_host_ = nullptr;\n   agent_ptr_.reset();\n   SetFrameTreeNode(nullptr);\n  Release();\n}\n", "target": 1, "idx": 187271}
{"func": "static unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len)\n{\n   unsigned s1 = adler & 0xffff;\n   unsigned s2 = (adler >> 16) & 0xffff;\n\n  while(len > 0)\n  {\n    /*at least 5550 sums can be done before the sums overflow, saving a lot of module divisions*/\n    unsigned amount = len > 5550 ? 5550 : len;\n    len -= amount;\n    while(amount > 0)\n    {\n      s1 += (*data++);\n      s2 += s1;\n      amount--;\n    }\n    s1 %= 65521;\n    s2 %= 65521;\n  }\n\n  return (s2 << 16) | s1;\n}\n", "target": 0, "idx": 87616}
{"func": "static void update_task_scan_period(struct task_struct *p,\n\t\t\tunsigned long shared, unsigned long private)\n{\n\tunsigned int period_slot;\n\tint lr_ratio, ps_ratio;\n\tint diff;\n\n\tunsigned long remote = p->numa_faults_locality[0];\n\tunsigned long local = p->numa_faults_locality[1];\n\n\t/*\n\t * If there were no record hinting faults then either the task is\n\t * completely idle or all activity is areas that are not of interest\n\t * to automatic numa balancing. Related to that, if there were failed\n\t * migration then it implies we are migrating too quickly or the local\n\t * node is overloaded. In either case, scan slower\n\t */\n\tif (local + shared == 0 || p->numa_faults_locality[2]) {\n\t\tp->numa_scan_period = min(p->numa_scan_period_max,\n\t\t\tp->numa_scan_period << 1);\n\n\t\tp->mm->numa_next_scan = jiffies +\n\t\t\tmsecs_to_jiffies(p->numa_scan_period);\n\n\t\treturn;\n\t}\n\n\t/*\n\t * Prepare to scale scan period relative to the current period.\n\t *\t == NUMA_PERIOD_THRESHOLD scan period stays the same\n\t *       <  NUMA_PERIOD_THRESHOLD scan period decreases (scan faster)\n\t *\t >= NUMA_PERIOD_THRESHOLD scan period increases (scan slower)\n\t */\n\tperiod_slot = DIV_ROUND_UP(p->numa_scan_period, NUMA_PERIOD_SLOTS);\n\tlr_ratio = (local * NUMA_PERIOD_SLOTS) / (local + remote);\n\tps_ratio = (private * NUMA_PERIOD_SLOTS) / (private + shared);\n\n\tif (ps_ratio >= NUMA_PERIOD_THRESHOLD) {\n\t\t/*\n\t\t * Most memory accesses are local. There is no need to\n\t\t * do fast NUMA scanning, since memory is already local.\n\t\t */\n\t\tint slot = ps_ratio - NUMA_PERIOD_THRESHOLD;\n\t\tif (!slot)\n\t\t\tslot = 1;\n\t\tdiff = slot * period_slot;\n\t} else if (lr_ratio >= NUMA_PERIOD_THRESHOLD) {\n\t\t/*\n\t\t * Most memory accesses are shared with other tasks.\n\t\t * There is no point in continuing fast NUMA scanning,\n\t\t * since other tasks may just move the memory elsewhere.\n\t\t */\n\t\tint slot = lr_ratio - NUMA_PERIOD_THRESHOLD;\n\t\tif (!slot)\n\t\t\tslot = 1;\n\t\tdiff = slot * period_slot;\n\t} else {\n\t\t/*\n\t\t * Private memory faults exceed (SLOTS-THRESHOLD)/SLOTS,\n\t\t * yet they are not on the local NUMA node. Speed up\n\t\t * NUMA scanning to get the memory moved over.\n\t\t */\n\t\tint ratio = max(lr_ratio, ps_ratio);\n\t\tdiff = -(NUMA_PERIOD_THRESHOLD - ratio) * period_slot;\n\t}\n\n\tp->numa_scan_period = clamp(p->numa_scan_period + diff,\n\t\t\ttask_scan_min(p), task_scan_max(p));\n\tmemset(p->numa_faults_locality, 0, sizeof(p->numa_faults_locality));\n}\n", "target": 0, "idx": 92779}
{"func": "PHP_FUNCTION(money_format)\n{\n\tsize_t format_len = 0;\n\tchar *format, *p, *e;\n\tdouble value;\n\tzend_bool check = 0;\n\tzend_string *str;\n\tssize_t res_len;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"sd\", &format, &format_len, &value) == FAILURE) {\n\t\treturn;\n\t}\n\n\tp = format;\n\te = p + format_len;\n\twhile ((p = memchr(p, '%', (e - p)))) {\n\t\tif (*(p + 1) == '%') {\n\t\t\tp += 2;\n\t\t} else if (!check) {\n\t\t\tcheck = 1;\n\t\t\tp++;\n\t\t} else {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"Only a single %%i or %%n token can be used\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\t}\n\n\tstr = zend_string_alloc(format_len + 1024, 0);\n\tif ((res_len = strfmon(ZSTR_VAL(str), ZSTR_LEN(str), format, value)) < 0) {\n\t\tzend_string_free(str);\n\t\tRETURN_FALSE;\n\t}\n\tZSTR_LEN(str) = (size_t)res_len;\n\tZSTR_VAL(str)[ZSTR_LEN(str)] = '\\0';\n\n\tRETURN_NEW_STR(zend_string_truncate(str, ZSTR_LEN(str), 0));\n}\n", "target": 0, "idx": 14661}
{"func": "static int dnxhd_decode_header(DNXHDContext *ctx, AVFrame *frame,\n                               const uint8_t *buf, int buf_size,\n                               int first_field)\n{\n    int i, cid, ret;\n    int old_bit_depth = ctx->bit_depth, bitdepth;\n    uint64_t header_prefix;\n    if (buf_size < 0x280) {\n        av_log(ctx->avctx, AV_LOG_ERROR,\n               \"buffer too small (%d < 640).\\n\", buf_size);\n        return AVERROR_INVALIDDATA;\n    }\n\n    header_prefix = ff_dnxhd_parse_header_prefix(buf);\n    if (header_prefix == 0) {\n        av_log(ctx->avctx, AV_LOG_ERROR,\n               \"unknown header 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X\\n\",\n               buf[0], buf[1], buf[2], buf[3], buf[4]);\n        return AVERROR_INVALIDDATA;\n    }\n    if (buf[5] & 2) { /* interlaced */\n        ctx->cur_field = buf[5] & 1;\n        frame->interlaced_frame = 1;\n        frame->top_field_first  = first_field ^ ctx->cur_field;\n        av_log(ctx->avctx, AV_LOG_DEBUG,\n               \"interlaced %d, cur field %d\\n\", buf[5] & 3, ctx->cur_field);\n    } else {\n        ctx->cur_field = 0;\n    }\n    ctx->mbaff = (buf[0x6] >> 5) & 1;\n\n    ctx->height = AV_RB16(buf + 0x18);\n    ctx->width  = AV_RB16(buf + 0x1a);\n\n    switch(buf[0x21] >> 5) {\n    case 1: bitdepth = 8; break;\n    case 2: bitdepth = 10; break;\n    case 3: bitdepth = 12; break;\n    default:\n        av_log(ctx->avctx, AV_LOG_ERROR,\n               \"Unknown bitdepth indicator (%d)\\n\", buf[0x21] >> 5);\n        return AVERROR_INVALIDDATA;\n    }\n\n    cid = AV_RB32(buf + 0x28);\n\n    ctx->avctx->profile = dnxhd_get_profile(cid);\n\n    if ((ret = dnxhd_init_vlc(ctx, cid, bitdepth)) < 0)\n        return ret;\n    if (ctx->mbaff && ctx->cid_table->cid != 1260)\n        av_log(ctx->avctx, AV_LOG_WARNING,\n               \"Adaptive MB interlace flag in an unsupported profile.\\n\");\n\n    ctx->act = buf[0x2C] & 7;\n    if (ctx->act && ctx->cid_table->cid != 1256 && ctx->cid_table->cid != 1270)\n        av_log(ctx->avctx, AV_LOG_WARNING,\n               \"Adaptive color transform in an unsupported profile.\\n\");\n\n    ctx->is_444 = (buf[0x2C] >> 6) & 1;\n    if (ctx->is_444) {\n        if (bitdepth == 8) {\n            avpriv_request_sample(ctx->avctx, \"4:4:4 8 bits\");\n            return AVERROR_INVALIDDATA;\n        } else if (bitdepth == 10) {\n            ctx->decode_dct_block = dnxhd_decode_dct_block_10_444;\n            ctx->pix_fmt = ctx->act ? AV_PIX_FMT_YUV444P10\n                                    : AV_PIX_FMT_GBRP10;\n        } else {\n            ctx->decode_dct_block = dnxhd_decode_dct_block_12_444;\n            ctx->pix_fmt = ctx->act ? AV_PIX_FMT_YUV444P12\n                                    : AV_PIX_FMT_GBRP12;\n        }\n    } else if (bitdepth == 12) {\n        ctx->decode_dct_block = dnxhd_decode_dct_block_12;\n        ctx->pix_fmt = AV_PIX_FMT_YUV422P12;\n    } else if (bitdepth == 10) {\n        if (ctx->avctx->profile == FF_PROFILE_DNXHR_HQX)\n            ctx->decode_dct_block = dnxhd_decode_dct_block_10_444;\n        else\n            ctx->decode_dct_block = dnxhd_decode_dct_block_10;\n        ctx->pix_fmt = AV_PIX_FMT_YUV422P10;\n    } else {\n        ctx->decode_dct_block = dnxhd_decode_dct_block_8;\n        ctx->pix_fmt = AV_PIX_FMT_YUV422P;\n    }\n\n    ctx->avctx->bits_per_raw_sample = ctx->bit_depth = bitdepth;\n    if (ctx->bit_depth != old_bit_depth) {\n        ff_blockdsp_init(&ctx->bdsp, ctx->avctx);\n        ff_idctdsp_init(&ctx->idsp, ctx->avctx);\n        ff_init_scantable(ctx->idsp.idct_permutation, &ctx->scantable,\n                          ff_zigzag_direct);\n    }\n\n    if (ctx->width != ctx->cid_table->width &&\n        ctx->cid_table->width != DNXHD_VARIABLE) {\n        av_reduce(&ctx->avctx->sample_aspect_ratio.num,\n                  &ctx->avctx->sample_aspect_ratio.den,\n                  ctx->width, ctx->cid_table->width, 255);\n        ctx->width = ctx->cid_table->width;\n    }\n\n    if (buf_size < ctx->cid_table->coding_unit_size) {\n        av_log(ctx->avctx, AV_LOG_ERROR, \"incorrect frame size (%d < %u).\\n\",\n               buf_size, ctx->cid_table->coding_unit_size);\n        return AVERROR_INVALIDDATA;\n    }\n\n    ctx->mb_width  = (ctx->width + 15)>> 4;\n    ctx->mb_height = AV_RB16(buf + 0x16c);\n\n    if ((ctx->height + 15) >> 4 == ctx->mb_height && frame->interlaced_frame)\n        ctx->height <<= 1;\n\n    av_log(ctx->avctx, AV_LOG_VERBOSE, \"%dx%d, 4:%s %d bits, MBAFF=%d ACT=%d\\n\",\n           ctx->width, ctx->height, ctx->is_444 ? \"4:4\" : \"2:2\",\n           ctx->bit_depth, ctx->mbaff, ctx->act);\n\n     if (ctx->mb_height > 68 && ff_dnxhd_check_header_prefix_hr(header_prefix)) {\n         ctx->data_offset = 0x170 + (ctx->mb_height << 2);\n     } else {\n        if (ctx->mb_height > 68 ||\n            (ctx->mb_height << frame->interlaced_frame) > (ctx->height + 15) >> 4) {\n             av_log(ctx->avctx, AV_LOG_ERROR,\n                    \"mb height too big: %d\\n\", ctx->mb_height);\n             return AVERROR_INVALIDDATA;\n         }\n         ctx->data_offset = 0x280;\n     }\n \n     if (buf_size < ctx->data_offset) {\n         av_log(ctx->avctx, AV_LOG_ERROR,\n               \"buffer too small (%d < %d).\\n\", buf_size, ctx->data_offset);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (ctx->mb_height > FF_ARRAY_ELEMS(ctx->mb_scan_index)) {\n        av_log(ctx->avctx, AV_LOG_ERROR,\n               \"mb_height too big (%d > %\"SIZE_SPECIFIER\").\\n\", ctx->mb_height, FF_ARRAY_ELEMS(ctx->mb_scan_index));\n        return AVERROR_INVALIDDATA;\n    }\n\n    for (i = 0; i < ctx->mb_height; i++) {\n        ctx->mb_scan_index[i] = AV_RB32(buf + 0x170 + (i << 2));\n        ff_dlog(ctx->avctx, \"mb scan index %d, pos %d: %\"PRIu32\"\\n\",\n                i, 0x170 + (i << 2), ctx->mb_scan_index[i]);\n        if (buf_size - ctx->data_offset < ctx->mb_scan_index[i]) {\n            av_log(ctx->avctx, AV_LOG_ERROR,\n                   \"invalid mb scan index (%\"PRIu32\" vs %u).\\n\",\n                   ctx->mb_scan_index[i], buf_size - ctx->data_offset);\n            return AVERROR_INVALIDDATA;\n        }\n    }\n\n    return 0;\n}\n", "target": 1, "idx": 181172}
{"func": "void AppCacheUpdateJob::HandleMasterEntryFetchCompleted(\n    URLFetcher* fetcher) {\n  DCHECK(internal_state_ == NO_UPDATE || internal_state_ == DOWNLOADING);\n\n\n  net::URLRequest* request = fetcher->request();\n  const GURL& url = request->original_url();\n  master_entry_fetches_.erase(url);\n  ++master_entries_completed_;\n\n  int response_code = request->status().is_success()\n      ? request->GetResponseCode() : -1;\n\n  PendingMasters::iterator found = pending_master_entries_.find(url);\n  DCHECK(found != pending_master_entries_.end());\n  PendingHosts& hosts = found->second;\n\n  if (response_code / 100 == 2) {\n    AppCache* cache = inprogress_cache_.get() ? inprogress_cache_.get()\n                                              : group_->newest_complete_cache();\n    DCHECK(fetcher->response_writer());\n    AppCacheEntry master_entry(AppCacheEntry::MASTER,\n                               fetcher->response_writer()->response_id(),\n                               fetcher->response_writer()->amount_written());\n    if (cache->AddOrModifyEntry(url, master_entry))\n      added_master_entries_.push_back(url);\n    else\n      duplicate_response_ids_.push_back(master_entry.response_id());\n\n    if (!inprogress_cache_.get()) {\n      DCHECK(cache == group_->newest_complete_cache());\n      for (PendingHosts::iterator host_it = hosts.begin();\n           host_it != hosts.end(); ++host_it) {\n        (*host_it)->AssociateCompleteCache(cache);\n      }\n    }\n  } else {\n    HostNotifier host_notifier;\n    for (PendingHosts::iterator host_it = hosts.begin();\n         host_it != hosts.end(); ++host_it) {\n      AppCacheHost* host = *host_it;\n      host_notifier.AddHost(host);\n\n      if (inprogress_cache_.get())\n        host->AssociateNoCache(GURL());\n\n      host->RemoveObserver(this);\n     }\n     hosts.clear();\n \n     const char* kFormatString = \"Manifest fetch failed (%d) %s\";\n     std::string message = FormatUrlErrorMessage(\n         kFormatString, request->url(), fetcher->result(), response_code);\n    host_notifier.SendErrorNotifications(\n        AppCacheErrorDetails(message,\n                     APPCACHE_MANIFEST_ERROR,\n                     request->url(),\n                     response_code,\n                     false /*is_cross_origin*/));\n\n    if (inprogress_cache_.get()) {\n      pending_master_entries_.erase(found);\n      --master_entries_completed_;\n\n      if (update_type_ == CACHE_ATTEMPT && pending_master_entries_.empty()) {\n        HandleCacheFailure(AppCacheErrorDetails(message,\n                                        APPCACHE_MANIFEST_ERROR,\n                                        request->url(),\n                                        response_code,\n                                        false /*is_cross_origin*/),\n                           fetcher->result(),\n                           GURL());\n        return;\n      }\n    }\n  }\n\n  DCHECK(internal_state_ != CACHE_FAILURE);\n  FetchMasterEntries();\n  MaybeCompleteUpdate();\n}\n", "target": 1, "idx": 185609}
{"func": "report_error (const char *format, ...)\n#else\nreport_error (format, va_alist)\n     const char *format;\n     va_dcl\n#endif\n{\n  va_list args;\n\n  error_prolog (1);\n\n  SH_VA_START (args, format);\n\n  vfprintf (stderr, format, args);\n  fprintf (stderr, \"\\n\");\n \n   va_end (args);\n   if (exit_immediately_on_error)\n    exit_shell (1);\n }\n", "target": 1, "idx": 178602}
{"func": "WebMouseEvent* BuildMouseEvent(const PP_InputEvent& event) {\n  WebMouseEvent* mouse_event = new WebMouseEvent();\n  switch (event.type) {\n    case PP_INPUTEVENT_TYPE_MOUSEDOWN:\n      mouse_event->type = WebInputEvent::MouseDown;\n      break;\n    case PP_INPUTEVENT_TYPE_MOUSEUP:\n      mouse_event->type = WebInputEvent::MouseUp;\n      break;\n    case PP_INPUTEVENT_TYPE_MOUSEMOVE:\n      mouse_event->type = WebInputEvent::MouseMove;\n      break;\n    case PP_INPUTEVENT_TYPE_MOUSEENTER:\n      mouse_event->type = WebInputEvent::MouseEnter;\n      break;\n     case PP_INPUTEVENT_TYPE_MOUSELEAVE:\n       mouse_event->type = WebInputEvent::MouseLeave;\n       break;\n     default:\n       NOTREACHED();\n   }\n  mouse_event->timeStampSeconds = event.time_stamp;\n  mouse_event->modifiers = event.u.mouse.modifier;\n  mouse_event->button =\n      static_cast<WebMouseEvent::Button>(event.u.mouse.button);\n  mouse_event->x = static_cast<int>(event.u.mouse.x);\n  mouse_event->y = static_cast<int>(event.u.mouse.y);\n  mouse_event->clickCount = event.u.mouse.click_count;\n  return mouse_event;\n}\n", "target": 1, "idx": 184074}
{"func": "static Image *ReadSCRImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n    char zxscr[6144];\n    char zxattr[768];\n    int octetnr;\n    int octetline;\n    int zoneline;\n    int zonenr;\n    int octet_val;\n    int attr_nr;\n    int pix;\n    int piy;\n    int binar[8];\n    int attrbin[8];\n    int *pbin;\n    int *abin;\n    int z;\n    int one_nr;\n    int ink;\n    int paper;\n    int bright;\n\n  unsigned char colour_palette[] = {\n      0,  0,  0,\n      0,  0,192,\n    192,  0,  0,\n    192,  0,192,\n      0,192,  0,\n      0,192,192,\n    192,192,  0,\n    192,192,192,\n      0,  0,  0,\n      0,  0,255,\n    255,  0,  0,\n    255,  0,255,\n      0,255,  0,\n      0,255,255,\n    255,255,  0,\n    255,255,255\n  };\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  register PixelPacket\n    *q;\n\n  ssize_t\n    count;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n     }\n   image->columns = 256;\n   image->rows = 192;\n   count=ReadBlob(image,6144,(unsigned char *) zxscr);\n   (void) count;\n   count=ReadBlob(image,768,(unsigned char *) zxattr);\n  for(zonenr=0;zonenr<3;zonenr++)\n  {\n      for(zoneline=0;zoneline<8;zoneline++)\n        {\n        for(octetline=0;octetline<8;octetline++)\n      {\n          for(octetnr=(zoneline*32);octetnr<((zoneline*32)+32);octetnr++)\n            {\n            octet_val = zxscr[octetnr+(256*octetline)+(zonenr*2048)];\n            attr_nr = zxattr[octetnr+(256*zonenr)];\n\n            pix = (((8*octetnr)-(256*zoneline)));\n            piy = ((octetline+(8*zoneline)+(zonenr*64)));\n\n            pbin = binar;\n            abin = attrbin;\n\n            one_nr=1;\n\n            for(z=0;z<8;z++)\n          {\n              if(octet_val&one_nr)\n            {\n                *pbin = 1;\n            } else {\n                *pbin = 0;\n            }\n              one_nr=one_nr*2;\n              pbin++;\n          }\n\n            one_nr = 1;\n\n            for(z=0;z<8;z++)\n          {\n              if(attr_nr&one_nr)\n            {\n                *abin = 1;\n            } else {\n                *abin = 0;\n            }\n              one_nr=one_nr*2;\n              abin++;\n          }\n\n            ink = (attrbin[0]+(2*attrbin[1])+(4*attrbin[2]));\n            paper = (attrbin[3]+(2*attrbin[4])+(4*attrbin[5]));\n            bright = attrbin[6];\n\n            if(bright) { ink=ink+8; paper=paper+8; }\n\n            for(z=7;z>-1;z--)\n          {\n              q=QueueAuthenticPixels(image,pix,piy,1,1,exception);\n              if (q == (PixelPacket *) NULL)\n                break;\n\n              if(binar[z])\n            {\n                SetPixelRed(q,ScaleCharToQuantum(\n                  colour_palette[3*ink]));\n                SetPixelGreen(q,ScaleCharToQuantum(\n                  colour_palette[1+(3*ink)]));\n                SetPixelBlue(q,ScaleCharToQuantum(\n                  colour_palette[2+(3*ink)]));\n            } else {\n                SetPixelRed(q,ScaleCharToQuantum(\n                  colour_palette[3*paper]));\n                SetPixelGreen(q,ScaleCharToQuantum(\n                  colour_palette[1+(3*paper)]));\n                SetPixelBlue(q,ScaleCharToQuantum(\n                  colour_palette[2+(3*paper)]));\n            }\n\n              pix++;\n          }\n        }\n      }\n    }\n  }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n", "target": 1, "idx": 181773}
{"func": "long long Segment::CreateInstance(\n    IMkvReader* pReader,\n    long long pos,\n    Segment*& pSegment)\n{\n    assert(pReader);\n    assert(pos >= 0);\n \n    pSegment = NULL;\n \n    long long total, available;\n \n    const long status = pReader->Length(&total, &available);\n \n    if (status < 0) //error\n        return status;\n \n    if (available < 0)\n         return -1;\n \n    if ((total >= 0) && (available > total))\n         return -1;\n \n \n    for (;;)\n    {\n        if ((total >= 0) && (pos >= total))\n            return E_FILE_FORMAT_INVALID;\n        long len;\n        long long result = GetUIntLength(pReader, pos, len);\n        if (result)  //error, or too few available bytes\n            return result;\n        if ((total >= 0) && ((pos + len) > total))\n            return E_FILE_FORMAT_INVALID;\n        if ((pos + len) > available)\n            return pos + len;\n        const long long idpos = pos;\n        const long long id = ReadUInt(pReader, pos, len);\n        if (id < 0)  //error\n            return id;\n        pos += len;  //consume ID\n        result = GetUIntLength(pReader, pos, len);\n        if (result)  //error, or too few available bytes\n            return result;\n        if ((total >= 0) && ((pos + len) > total))\n            return E_FILE_FORMAT_INVALID;\n        if ((pos + len) > available)\n            return pos + len;\n        long long size = ReadUInt(pReader, pos, len);\n        if (size < 0)  //error\n            return size;\n        pos += len;  //consume length of size of element\n        const long long unknown_size = (1LL << (7 * len)) - 1;\n        if (id == 0x08538067)  //Segment ID\n        {\n            if (size == unknown_size)\n                size = -1;\n            else if (total < 0)\n                size = -1;\n            else if ((pos + size) > total)\n                size = -1;\n            pSegment = new (std::nothrow) Segment(\n                                            pReader,\n                                            idpos,\n                                            pos,\n                                            size);\n            if (pSegment == 0)\n                return -1;  //generic error\n            return 0;    //success\n        }\n        if (size == unknown_size)\n            return E_FILE_FORMAT_INVALID;\n        if ((total >= 0) && ((pos + size) > total))\n            return E_FILE_FORMAT_INVALID;\n        if ((pos + size) > available)\n            return pos + size;\n        pos += size;  //consume payload\n    }\n}\n", "target": 1, "idx": 188281}
{"func": "void RenderView::printPage(WebFrame* frame) {\n  DCHECK(frame);\n  Print(frame, true);\n}\n", "target": 0, "idx": 98117}
{"func": "long get_user_pages_remote(struct task_struct *tsk, struct mm_struct *mm,\n\t\tunsigned long start, unsigned long nr_pages,\n\t\tint write, int force, struct page **pages,\n\t\tstruct vm_area_struct **vmas)\n{\n\treturn __get_user_pages_locked(tsk, mm, start, nr_pages, write, force,\n\t\t\t\t       pages, vmas, NULL, false,\n\t\t\t\t       FOLL_TOUCH | FOLL_REMOTE);\n}\n", "target": 0, "idx": 52109}
{"func": " void ResourcePrefetchPredictor::LearnOrigins(\n     const std::string& host,\n     const GURL& main_frame_origin,\n    const std::map<GURL, OriginRequestSummary>& summaries) {\n   DCHECK_CURRENTLY_ON(BrowserThread::UI);\n   if (host.size() > ResourcePrefetchPredictorTables::kMaxStringLength)\n     return;\n\n  OriginData data;\n  bool exists = origin_data_->TryGetData(host, &data);\n  if (!exists) {\n    data.set_host(host);\n    data.set_last_visit_time(base::Time::Now().ToInternalValue());\n    size_t origins_size = summaries.size();\n    auto ordered_origins =\n        std::vector<const OriginRequestSummary*>(origins_size);\n    for (const auto& kv : summaries) {\n      size_t index = kv.second.first_occurrence;\n      DCHECK_LT(index, origins_size);\n      ordered_origins[index] = &kv.second;\n    }\n\n    for (const OriginRequestSummary* summary : ordered_origins) {\n      auto* origin_to_add = data.add_origins();\n      InitializeOriginStatFromOriginRequestSummary(origin_to_add, *summary);\n    }\n   } else {\n     data.set_last_visit_time(base::Time::Now().ToInternalValue());\n \n    std::map<GURL, int> old_index;\n     int old_size = static_cast<int>(data.origins_size());\n     for (int i = 0; i < old_size; ++i) {\n       bool is_new =\n          old_index.insert({GURL(data.origins(i).origin()), i}).second;\n       DCHECK(is_new);\n     }\n \n     for (int i = 0; i < old_size; ++i) {\n       auto* old_origin = data.mutable_origins(i);\n      GURL origin(old_origin->origin());\n       auto it = summaries.find(origin);\n       if (it == summaries.end()) {\n        old_origin->set_number_of_misses(old_origin->number_of_misses() + 1);\n        old_origin->set_consecutive_misses(old_origin->consecutive_misses() +\n                                           1);\n      } else {\n        const auto& new_origin = it->second;\n        old_origin->set_always_access_network(new_origin.always_access_network);\n        old_origin->set_accessed_network(new_origin.accessed_network);\n\n        int position = new_origin.first_occurrence + 1;\n        int total =\n            old_origin->number_of_hits() + old_origin->number_of_misses();\n        old_origin->set_average_position(\n            ((old_origin->average_position() * total) + position) /\n            (total + 1));\n        old_origin->set_number_of_hits(old_origin->number_of_hits() + 1);\n        old_origin->set_consecutive_misses(0);\n      }\n    }\n\n    for (const auto& kv : summaries) {\n      if (old_index.find(kv.first) != old_index.end())\n        continue;\n\n      auto* origin_to_add = data.add_origins();\n      InitializeOriginStatFromOriginRequestSummary(origin_to_add, kv.second);\n    }\n  }\n\n  ResourcePrefetchPredictorTables::TrimOrigins(&data,\n                                               config_.max_consecutive_misses);\n  ResourcePrefetchPredictorTables::SortOrigins(&data, main_frame_origin.spec());\n  if (data.origins_size() > static_cast<int>(config_.max_origins_per_entry)) {\n    data.mutable_origins()->DeleteSubrange(\n        config_.max_origins_per_entry,\n        data.origins_size() - config_.max_origins_per_entry);\n  }\n\n  if (data.origins_size() == 0)\n    origin_data_->DeleteData({host});\n  else\n    origin_data_->UpdateData(host, data);\n}\n", "target": 1, "idx": 186348}
{"func": " static __u8 *ch_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n \t\tunsigned int *rsize)\n {\n\tif (*rsize >= 17 && rdesc[11] == 0x3c && rdesc[12] == 0x02) {\n \t\thid_info(hdev, \"fixing up Cherry Cymotion report descriptor\\n\");\n \t\trdesc[11] = rdesc[16] = 0xff;\n \t\trdesc[12] = rdesc[17] = 0x03;\n\t}\n\treturn rdesc;\n}\n", "target": 1, "idx": 179542}
{"func": "void TIFF_MetaHandler::ProcessXMP()\n{\n\n\tthis->processedXMP = true;\t// Make sure we only come through here once.\n\n\n\n\tbool found;\n\tbool readOnly = ((this->parent->openFlags & kXMPFiles_OpenForUpdate) == 0);\n\n\tif ( readOnly ) {\n\t\tthis->psirMgr = new PSIR_MemoryReader();\n\t\tthis->iptcMgr = new IPTC_Reader();\n\t} else {\n\t\tthis->psirMgr = new PSIR_FileWriter();\n\t\tthis->iptcMgr = new IPTC_Writer();\t// ! Parse it later.\n\t}\n\n\tTIFF_Manager & tiff = this->tiffMgr;\t// Give the compiler help in recognizing non-aliases.\n\tPSIR_Manager & psir = *this->psirMgr;\n\tIPTC_Manager & iptc = *this->iptcMgr;\n\n\tTIFF_Manager::TagInfo psirInfo;\n\tbool havePSIR = tiff.GetTag ( kTIFF_PrimaryIFD, kTIFF_PSIR, &psirInfo );\n\n\tif ( havePSIR ) {\t// ! Do the Photoshop 6 integration before other legacy analysis.\n\t\tpsir.ParseMemoryResources ( psirInfo.dataPtr, psirInfo.dataLen );\n\t\tPSIR_Manager::ImgRsrcInfo buriedExif;\n\t\tfound = psir.GetImgRsrc ( kPSIR_Exif, &buriedExif );\n\t\tif ( found ) {\n\t\t\ttiff.IntegrateFromPShop6 ( buriedExif.dataPtr, buriedExif.dataLen );\n\t\t\tif ( ! readOnly ) psir.DeleteImgRsrc ( kPSIR_Exif );\n\t\t}\n\t}\n\n\tTIFF_Manager::TagInfo iptcInfo;\n\tbool haveIPTC = tiff.GetTag ( kTIFF_PrimaryIFD, kTIFF_IPTC, &iptcInfo );\t// The TIFF IPTC tag.\n\tint iptcDigestState = kDigestMatches;\n\n\tif ( haveIPTC ) {\n\n\t\tbool haveDigest = false;\n\t\tPSIR_Manager::ImgRsrcInfo digestInfo;\n\t\tif ( havePSIR ) haveDigest = psir.GetImgRsrc ( kPSIR_IPTCDigest, &digestInfo );\n\t\tif ( digestInfo.dataLen != 16 ) haveDigest = false;\n\n\t\tif ( ! haveDigest ) {\n\n\t\t\tiptcDigestState = kDigestMissing;\n\n\t\t} else {\n\n \n \t\t\tiptcDigestState = PhotoDataUtils::CheckIPTCDigest ( iptcInfo.dataPtr, iptcInfo.dataLen, digestInfo.dataPtr );\n\t\t\tif ( (iptcDigestState == kDigestDiffers) && (kTIFF_TypeSizes[iptcInfo.type] > 1) ) {\n \t\t\t\tXMP_Uns8 * endPtr = (XMP_Uns8*)iptcInfo.dataPtr + iptcInfo.dataLen - 1;\n \t\t\t\tXMP_Uns8 * minPtr = endPtr - kTIFF_TypeSizes[iptcInfo.type] + 1;\n \t\t\t\twhile ( (endPtr >= minPtr) && (*endPtr == 0) ) --endPtr;\n\t\t\t\tiptcDigestState = PhotoDataUtils::CheckIPTCDigest ( iptcInfo.dataPtr, unpaddedLen, digestInfo.dataPtr );\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tXMP_OptionBits options = k2XMP_FileHadExif;\t// TIFF files are presumed to have Exif legacy.\n\tif ( haveIPTC ) options |= k2XMP_FileHadIPTC;\n\tif ( this->containsXMP ) options |= k2XMP_FileHadXMP;\n\n\n\tbool haveXMP = false;\n\n\tif ( ! this->xmpPacket.empty() ) {\n\t\tXMP_Assert ( this->containsXMP );\n\t\tXMP_StringPtr packetStr = this->xmpPacket.c_str();\n\t\tXMP_StringLen packetLen = (XMP_StringLen)this->xmpPacket.size();\n\t\ttry {\n\t\t\tthis->xmpObj.ParseFromBuffer ( packetStr, packetLen );\n\t\t} catch ( ... ) { /* Ignore parsing failures, someday we hope to get partial XMP back. */ }\n\t\thaveXMP = true;\n\t}\n\n\n\tif ( haveIPTC && (! haveXMP) && (iptcDigestState == kDigestMatches) ) iptcDigestState = kDigestMissing;\n\tbool parseIPTC = (iptcDigestState != kDigestMatches) || (! readOnly);\n\tif ( parseIPTC ) iptc.ParseMemoryDataSets ( iptcInfo.dataPtr, iptcInfo.dataLen );\n\tImportPhotoData ( tiff, iptc, psir, iptcDigestState, &this->xmpObj, options );\n\n\tthis->containsXMP = true;\t// Assume we now have something in the XMP.\n\n}\t// TIFF_MetaHandler::ProcessXMP\n", "target": 1, "idx": 178168}
{"func": "Vector<GLuint> WebGL2RenderingContextBase::getUniformIndices(\n    WebGLProgram* program,\n    const Vector<String>& uniform_names) {\n  Vector<GLuint> result;\n  if (isContextLost() || !ValidateWebGLObject(\"getUniformIndices\", program))\n    return result;\n\n  Vector<CString> keep_alive;  // Must keep these instances alive while looking\n  Vector<const char*> uniform_strings;\n  for (size_t i = 0; i < uniform_names.size(); ++i) {\n    keep_alive.push_back(uniform_names[i].Ascii());\n    uniform_strings.push_back(keep_alive.back().data());\n  }\n\n  result.resize(uniform_names.size());\n  ContextGL()->GetUniformIndices(ObjectOrZero(program), uniform_strings.size(),\n                                 uniform_strings.data(), result.data());\n  return result;\n}\n", "target": 0, "idx": 146110}
{"func": "do_setup_env(Session *s, const char *shell)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\tchar buf[256];\n\tu_int i, envsize;\n\tchar **env, *laddr;\n\tstruct passwd *pw = s->pw;\n#if !defined (HAVE_LOGIN_CAP) && !defined (HAVE_CYGWIN)\n\tchar *path = NULL;\n#endif\n\n\t/* Initialize the environment. */\n\tenvsize = 100;\n\tenv = xcalloc(envsize, sizeof(char *));\n\tenv[0] = NULL;\n\n#ifdef HAVE_CYGWIN\n\t/*\n\t * The Windows environment contains some setting which are\n\t * important for a running system. They must not be dropped.\n\t */\n\t{\n\t\tchar **p;\n\n\t\tp = fetch_windows_environment();\n\t\tcopy_environment(p, &env, &envsize);\n\t\tfree_windows_environment(p);\n\t}\n#endif\n\n#ifdef GSSAPI\n\t/* Allow any GSSAPI methods that we've used to alter\n\t * the childs environment as they see fit\n\t */\n\tssh_gssapi_do_child(&env, &envsize);\n#endif\n\n\tif (!options.use_login) {\n\t\t/* Set basic environment. */\n\t\tfor (i = 0; i < s->num_env; i++)\n\t\t\tchild_set_env(&env, &envsize, s->env[i].name,\n\t\t\t    s->env[i].val);\n\n\t\tchild_set_env(&env, &envsize, \"USER\", pw->pw_name);\n\t\tchild_set_env(&env, &envsize, \"LOGNAME\", pw->pw_name);\n#ifdef _AIX\n\t\tchild_set_env(&env, &envsize, \"LOGIN\", pw->pw_name);\n#endif\n\t\tchild_set_env(&env, &envsize, \"HOME\", pw->pw_dir);\n#ifdef HAVE_LOGIN_CAP\n\t\tif (setusercontext(lc, pw, pw->pw_uid, LOGIN_SETPATH) < 0)\n\t\t\tchild_set_env(&env, &envsize, \"PATH\", _PATH_STDPATH);\n\t\telse\n\t\t\tchild_set_env(&env, &envsize, \"PATH\", getenv(\"PATH\"));\n#else /* HAVE_LOGIN_CAP */\n# ifndef HAVE_CYGWIN\n\t\t/*\n\t\t * There's no standard path on Windows. The path contains\n\t\t * important components pointing to the system directories,\n\t\t * needed for loading shared libraries. So the path better\n\t\t * remains intact here.\n\t\t */\n#  ifdef HAVE_ETC_DEFAULT_LOGIN\n\t\tread_etc_default_login(&env, &envsize, pw->pw_uid);\n\t\tpath = child_get_env(env, \"PATH\");\n#  endif /* HAVE_ETC_DEFAULT_LOGIN */\n\t\tif (path == NULL || *path == '\\0') {\n\t\t\tchild_set_env(&env, &envsize, \"PATH\",\n\t\t\t    s->pw->pw_uid == 0 ?\n\t\t\t\tSUPERUSER_PATH : _PATH_STDPATH);\n\t\t}\n# endif /* HAVE_CYGWIN */\n#endif /* HAVE_LOGIN_CAP */\n\n\t\tsnprintf(buf, sizeof buf, \"%.200s/%.50s\",\n\t\t\t _PATH_MAILDIR, pw->pw_name);\n\t\tchild_set_env(&env, &envsize, \"MAIL\", buf);\n\n\t\t/* Normal systems set SHELL by default. */\n\t\tchild_set_env(&env, &envsize, \"SHELL\", shell);\n\t}\n\tif (getenv(\"TZ\"))\n\t\tchild_set_env(&env, &envsize, \"TZ\", getenv(\"TZ\"));\n\n\t/* Set custom environment options from RSA authentication. */\n\tif (!options.use_login) {\n\t\twhile (custom_environment) {\n\t\t\tstruct envstring *ce = custom_environment;\n\t\t\tchar *str = ce->s;\n\n\t\t\tfor (i = 0; str[i] != '=' && str[i]; i++)\n\t\t\t\t;\n\t\t\tif (str[i] == '=') {\n\t\t\t\tstr[i] = 0;\n\t\t\t\tchild_set_env(&env, &envsize, str, str + i + 1);\n\t\t\t}\n\t\t\tcustom_environment = ce->next;\n\t\t\tfree(ce->s);\n\t\t\tfree(ce);\n\t\t}\n\t}\n\n\t/* SSH_CLIENT deprecated */\n\tsnprintf(buf, sizeof buf, \"%.50s %d %d\",\n\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),\n\t    ssh_local_port(ssh));\n\tchild_set_env(&env, &envsize, \"SSH_CLIENT\", buf);\n\n\tladdr = get_local_ipaddr(packet_get_connection_in());\n\tsnprintf(buf, sizeof buf, \"%.50s %d %.50s %d\",\n\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),\n\t    laddr, ssh_local_port(ssh));\n\tfree(laddr);\n\tchild_set_env(&env, &envsize, \"SSH_CONNECTION\", buf);\n\n\tif (s->ttyfd != -1)\n\t\tchild_set_env(&env, &envsize, \"SSH_TTY\", s->tty);\n\tif (s->term)\n\t\tchild_set_env(&env, &envsize, \"TERM\", s->term);\n\tif (s->display)\n\t\tchild_set_env(&env, &envsize, \"DISPLAY\", s->display);\n\tif (original_command)\n\t\tchild_set_env(&env, &envsize, \"SSH_ORIGINAL_COMMAND\",\n\t\t    original_command);\n\n#ifdef _UNICOS\n\tif (cray_tmpdir[0] != '\\0')\n\t\tchild_set_env(&env, &envsize, \"TMPDIR\", cray_tmpdir);\n#endif /* _UNICOS */\n\n\t/*\n\t * Since we clear KRB5CCNAME at startup, if it's set now then it\n\t * must have been set by a native authentication method (eg AIX or\n\t * SIA), so copy it to the child.\n\t */\n\t{\n\t\tchar *cp;\n\n\t\tif ((cp = getenv(\"KRB5CCNAME\")) != NULL)\n\t\t\tchild_set_env(&env, &envsize, \"KRB5CCNAME\", cp);\n\t}\n\n#ifdef _AIX\n\t{\n\t\tchar *cp;\n\n\t\tif ((cp = getenv(\"AUTHSTATE\")) != NULL)\n\t\t\tchild_set_env(&env, &envsize, \"AUTHSTATE\", cp);\n\t\tread_environment_file(&env, &envsize, \"/etc/environment\");\n\t}\n#endif\n#ifdef KRB5\n\tif (s->authctxt->krb5_ccname)\n\t\tchild_set_env(&env, &envsize, \"KRB5CCNAME\",\n\t\t    s->authctxt->krb5_ccname);\n#endif\n#ifdef USE_PAM\n\t/*\n \t * Pull in any environment variables that may have\n \t * been set by PAM.\n \t */\n\tif (options.use_pam) {\n \t\tchar **p;\n \n \t\tp = fetch_pam_child_environment();\n\t\tcopy_environment(p, &env, &envsize);\n\t\tfree_pam_environment(p);\n\n\t\tp = fetch_pam_environment();\n\t\tcopy_environment(p, &env, &envsize);\n\t\tfree_pam_environment(p);\n\t}\n#endif /* USE_PAM */\n\n\tif (auth_sock_name != NULL)\n\t\tchild_set_env(&env, &envsize, SSH_AUTHSOCKET_ENV_NAME,\n\t\t    auth_sock_name);\n\n\t/* read $HOME/.ssh/environment. */\n\tif (options.permit_user_env && !options.use_login) {\n\t\tsnprintf(buf, sizeof buf, \"%.200s/.ssh/environment\",\n\t\t    strcmp(pw->pw_dir, \"/\") ? pw->pw_dir : \"\");\n\t\tread_environment_file(&env, &envsize, buf);\n\t}\n\tif (debug_flag) {\n\t\t/* dump the environment */\n\t\tfprintf(stderr, \"Environment:\\n\");\n\t\tfor (i = 0; env[i]; i++)\n\t\t\tfprintf(stderr, \"  %.200s\\n\", env[i]);\n\t}\n\treturn env;\n}\n", "target": 1, "idx": 178455}
{"func": "long Cluster::CreateBlock(\n    long long id,\n    long long pos,   //absolute pos of payload\n    long long size,\n    long long discard_padding)\n{\n    assert((id == 0x20) || (id == 0x23));  //BlockGroup or SimpleBlock\n    if (m_entries_count < 0)  //haven't parsed anything yet\n    {\n        assert(m_entries == NULL);\n        assert(m_entries_size == 0);\n        m_entries_size = 1024;\n        m_entries = new BlockEntry*[m_entries_size];\n        m_entries_count = 0;\n    }\n    else\n    {\n        assert(m_entries);\n        assert(m_entries_size > 0);\n        assert(m_entries_count <= m_entries_size);\n        if (m_entries_count >= m_entries_size)\n        {\n            const long entries_size = 2 * m_entries_size;\n            BlockEntry** const entries = new BlockEntry*[entries_size];\n            assert(entries);\n            BlockEntry** src = m_entries;\n            BlockEntry** const src_end = src + m_entries_count;\n            BlockEntry** dst = entries;\n            while (src != src_end)\n                *dst++ = *src++;\n            delete[] m_entries;\n            m_entries = entries;\n            m_entries_size = entries_size;\n        }\n     }\n \n    if (id == 0x20)  //BlockGroup ID\n        return CreateBlockGroup(pos, size, discard_padding);\n    else  //SimpleBlock ID\n        return CreateSimpleBlock(pos, size);\n }\n", "target": 1, "idx": 188279}
{"func": "int git_delta_apply(\n\tvoid **out,\n\tsize_t *out_len,\n\tconst unsigned char *base,\n\tsize_t base_len,\n\tconst unsigned char *delta,\n\tsize_t delta_len)\n{\n\tconst unsigned char *delta_end = delta + delta_len;\n\tsize_t base_sz, res_sz, alloc_sz;\n\tunsigned char *res_dp;\n\n\t*out = NULL;\n\t*out_len = 0;\n\n\t/*\n\t * Check that the base size matches the data we were given;\n\t * if not we would underflow while accessing data from the\n\t * base object, resulting in data corruption or segfault.\n\t */\n\tif ((hdr_sz(&base_sz, &delta, delta_end) < 0) || (base_sz != base_len)) {\n\t\tgiterr_set(GITERR_INVALID, \"failed to apply delta: base size does not match given data\");\n\t\treturn -1;\n\t}\n\n\tif (hdr_sz(&res_sz, &delta, delta_end) < 0) {\n\t\tgiterr_set(GITERR_INVALID, \"failed to apply delta: base size does not match given data\");\n\t\treturn -1;\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_sz, res_sz, 1);\n\tres_dp = git__malloc(alloc_sz);\n\tGITERR_CHECK_ALLOC(res_dp);\n\n\tres_dp[res_sz] = '\\0';\n\t*out = res_dp;\n\t*out_len = res_sz;\n\n\twhile (delta < delta_end) {\n\t\tunsigned char cmd = *delta++;\n\t\tif (cmd & 0x80) {\n \t\t\t/* cmd is a copy instruction; copy from the base. */\n \t\t\tsize_t off = 0, len = 0;\n \n\t\t\tif (cmd & 0x01) off = *delta++;\n\t\t\tif (cmd & 0x02) off |= *delta++ << 8UL;\n\t\t\tif (cmd & 0x04) off |= *delta++ << 16UL;\n\t\t\tif (cmd & 0x08) off |= ((unsigned) *delta++ << 24UL);\n\t\t\tif (cmd & 0x10) len = *delta++;\n\t\t\tif (cmd & 0x20) len |= *delta++ << 8UL;\n\t\t\tif (cmd & 0x40) len |= *delta++ << 16UL;\n \t\t\tif (!len)       len = 0x10000;\n \n \t\t\tif (base_len < off + len || res_sz < len)\n \t\t\t\tgoto fail;\n\t\t\tmemcpy(res_dp, base + off, len);\n\t\t\tres_dp += len;\n\t\t\tres_sz -= len;\n\n\t\t} else if (cmd) {\n\t\t\t/*\n\t\t\t * cmd is a literal insert instruction; copy from\n\t\t\t * the delta stream itself.\n\t\t\t */\n\t\t\tif (delta_end - delta < cmd || res_sz < cmd)\n\t\t\t\tgoto fail;\n\t\t\tmemcpy(res_dp, delta, cmd);\n\t\t\tdelta += cmd;\n\t\t\tres_dp += cmd;\n\t\t\tres_sz -= cmd;\n\n\t\t} else {\n\t\t\t/* cmd == 0 is reserved for future encodings. */\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (delta != delta_end || res_sz)\n\t\tgoto fail;\n\treturn 0;\n\nfail:\n\tgit__free(*out);\n\n\t*out = NULL;\n\t*out_len = 0;\n\n\tgiterr_set(GITERR_INVALID, \"failed to apply delta\");\n\treturn -1;\n}\n", "target": 1, "idx": 182416}
{"func": "static int sysMapFD(int fd, MemMapping* pMap)\n{\n off_t start;\n size_t length;\n void* memPtr;\n\n    assert(pMap != NULL);\n\n if (getFileStartAndLength(fd, &start, &length) < 0)\n return -1;\n\n    memPtr = mmap(NULL, length, PROT_READ, MAP_PRIVATE, fd, start);\n if (memPtr == MAP_FAILED) {\n        LOGW(\"mmap(%d, R, PRIVATE, %d, %d) failed: %s\\n\", (int) length,\n            fd, (int) start, strerror(errno));\n return -1;\n }\n\n    pMap->addr = memPtr;\n\n     pMap->length = length;\n     pMap->range_count = 1;\n     pMap->ranges = malloc(sizeof(MappedRange));\n     pMap->ranges[0].addr = memPtr;\n     pMap->ranges[0].length = length;\n \n return 0;\n}\n", "target": 1, "idx": 187926}
{"func": "void WebContentsImpl::UpdateRenderViewSizeForRenderManager(bool is_main_frame) {\n  gfx::Size size = GetSizeForNewRenderView(is_main_frame);\n  if (!size.IsEmpty())\n    view_->SizeContents(size);\n}\n", "target": 0, "idx": 157878}
{"func": "void WorkerProcessLauncher::Core::Send(IPC::Message* message) {\n  DCHECK(caller_task_runner_->BelongsToCurrentThread());\n\n  if (ipc_enabled_) {\n    launcher_delegate_->Send(message);\n  } else {\n    delete message;\n  }\n}\n", "target": 0, "idx": 127228}
{"func": "static void ept_set_mmio_spte_mask(void)\n{\n\t/*\n\t * EPT Misconfigurations can be generated if the value of bits 2:0\n\t * of an EPT paging-structure entry is 110b (write/execute).\n\t * Also, magic bits (0x3ull << 62) is set to quickly identify mmio\n\t * spte.\n\t */\n\tkvm_mmu_set_mmio_spte_mask((0x3ull << 62) | 0x6ull);\n}\n", "target": 0, "idx": 37041}
{"func": "void skb_queue_tail(struct sk_buff_head *list, struct sk_buff *newsk)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&list->lock, flags);\n\t__skb_queue_tail(list, newsk);\n\tspin_unlock_irqrestore(&list->lock, flags);\n}\n", "target": 0, "idx": 39914}
{"func": "static int proc_control_compat(struct usb_dev_state *ps,\n\t\t\t\tstruct usbdevfs_ctrltransfer32 __user *p32)\n{\n\tstruct usbdevfs_ctrltransfer __user *p;\n\t__u32 udata;\n\tp = compat_alloc_user_space(sizeof(*p));\n\tif (copy_in_user(p, p32, (sizeof(*p32) - sizeof(compat_caddr_t))) ||\n\t    get_user(udata, &p32->data) ||\n\t    put_user(compat_ptr(udata), &p->data))\n\t\treturn -EFAULT;\n\treturn proc_control(ps, p);\n}\n", "target": 0, "idx": 53219}
{"func": "analyze_stack(int cpu, struct task_struct *task, unsigned long *stack,\n\t      unsigned long **stack_end, unsigned long *irq_stack,\n\t      unsigned *used, char **id)\n{\n\tunsigned long addr;\n\n\taddr = ((unsigned long)stack & (~(THREAD_SIZE - 1)));\n\tif ((unsigned long)task_stack_page(task) == addr)\n\t\treturn STACK_IS_NORMAL;\n\n\t*stack_end = in_exception_stack(cpu, (unsigned long)stack,\n\t\t\t\t\tused, id);\n\tif (*stack_end)\n\t\treturn STACK_IS_EXCEPTION;\n\n\tif (!irq_stack)\n\t\treturn STACK_IS_NORMAL;\n\n\t*stack_end = irq_stack;\n\tirq_stack = irq_stack - irq_stack_size;\n\n\tif (in_irq_stack(stack, irq_stack, *stack_end))\n\t\treturn STACK_IS_IRQ;\n\n\treturn STACK_IS_UNKNOWN;\n}\n", "target": 0, "idx": 35399}
{"func": "void SoftMP3::onQueueFilled(OMX_U32 /* portIndex */) {\n if (mSignalledError || mOutputPortSettingsChange != NONE) {\n return;\n }\n\n List<BufferInfo *> &inQueue = getPortQueue(0);\n List<BufferInfo *> &outQueue = getPortQueue(1);\n\n while ((!inQueue.empty() || (mSawInputEos && !mSignalledOutputEos)) && !outQueue.empty()) {\n BufferInfo *inInfo = NULL;\n        OMX_BUFFERHEADERTYPE *inHeader = NULL;\n if (!inQueue.empty()) {\n            inInfo = *inQueue.begin();\n            inHeader = inInfo->mHeader;\n }\n\n BufferInfo *outInfo = *outQueue.begin();\n        OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;\n        outHeader->nFlags = 0;\n\n if (inHeader) {\n if (inHeader->nOffset == 0 && inHeader->nFilledLen) {\n                mAnchorTimeUs = inHeader->nTimeStamp;\n                mNumFramesOutput = 0;\n }\n\n if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {\n                mSawInputEos = true;\n }\n\n            mConfig->pInputBuffer =\n                inHeader->pBuffer + inHeader->nOffset;\n\n            mConfig->inputBufferCurrentLength = inHeader->nFilledLen;\n } else {\n            mConfig->pInputBuffer = NULL;\n            mConfig->inputBufferCurrentLength = 0;\n }\n        mConfig->inputBufferMaxLength = 0;\n\n         mConfig->inputBufferUsedLength = 0;\n \n         mConfig->outputFrameSize = kOutputBufferSize / sizeof(int16_t);\n \n         mConfig->pOutputBuffer =\n             reinterpret_cast<int16_t *>(outHeader->pBuffer);\n\n        ERROR_CODE decoderErr;\n if ((decoderErr = pvmp3_framedecoder(mConfig, mDecoderBuf))\n != NO_DECODING_ERROR) {\n            ALOGV(\"mp3 decoder returned error %d\", decoderErr);\n\n if (decoderErr != NO_ENOUGH_MAIN_DATA_ERROR\n && decoderErr != SIDE_INFO_ERROR) {\n                ALOGE(\"mp3 decoder returned error %d\", decoderErr);\n\n                notify(OMX_EventError, OMX_ErrorUndefined, decoderErr, NULL);\n                mSignalledError = true;\n return;\n }\n\n if (mConfig->outputFrameSize == 0) {\n                mConfig->outputFrameSize = kOutputBufferSize / sizeof(int16_t);\n }\n\n if (decoderErr == NO_ENOUGH_MAIN_DATA_ERROR && mSawInputEos) {\n if (!mIsFirst) {\n                    outHeader->nOffset = 0;\n                    outHeader->nFilledLen = kPVMP3DecoderDelay * mNumChannels * sizeof(int16_t);\n\n                    memset(outHeader->pBuffer, 0, outHeader->nFilledLen);\n }\n                outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n                mSignalledOutputEos = true;\n } else {\n\n                ALOGV_IF(mIsFirst, \"insufficient data for first frame, sending silence\");\n                memset(outHeader->pBuffer,\n 0,\n                       mConfig->outputFrameSize * sizeof(int16_t));\n\n if (inHeader) {\n                    mConfig->inputBufferUsedLength = inHeader->nFilledLen;\n }\n }\n } else if (mConfig->samplingRate != mSamplingRate\n || mConfig->num_channels != mNumChannels) {\n            mSamplingRate = mConfig->samplingRate;\n            mNumChannels = mConfig->num_channels;\n\n            notify(OMX_EventPortSettingsChanged, 1, 0, NULL);\n            mOutputPortSettingsChange = AWAITING_DISABLED;\n return;\n }\n\n if (mIsFirst) {\n            mIsFirst = false;\n            outHeader->nOffset =\n                kPVMP3DecoderDelay * mNumChannels * sizeof(int16_t);\n\n            outHeader->nFilledLen =\n                mConfig->outputFrameSize * sizeof(int16_t) - outHeader->nOffset;\n } else if (!mSignalledOutputEos) {\n            outHeader->nOffset = 0;\n            outHeader->nFilledLen = mConfig->outputFrameSize * sizeof(int16_t);\n }\n\n        outHeader->nTimeStamp =\n            mAnchorTimeUs + (mNumFramesOutput * 1000000ll) / mSamplingRate;\n\n if (inHeader) {\n            CHECK_GE(inHeader->nFilledLen, mConfig->inputBufferUsedLength);\n\n            inHeader->nOffset += mConfig->inputBufferUsedLength;\n            inHeader->nFilledLen -= mConfig->inputBufferUsedLength;\n\n\n if (inHeader->nFilledLen == 0) {\n                inInfo->mOwnedByUs = false;\n                inQueue.erase(inQueue.begin());\n                inInfo = NULL;\n                notifyEmptyBufferDone(inHeader);\n                inHeader = NULL;\n }\n }\n\n        mNumFramesOutput += mConfig->outputFrameSize / mNumChannels;\n\n        outInfo->mOwnedByUs = false;\n        outQueue.erase(outQueue.begin());\n        outInfo = NULL;\n        notifyFillBufferDone(outHeader);\n        outHeader = NULL;\n }\n}\n", "target": 1, "idx": 187799}
{"func": "void ObserverOnLogoAvailable(LogoObserver* observer,\n                             bool from_cache,\n                             LogoCallbackReason type,\n                             const base::Optional<Logo>& logo) {\n  switch (type) {\n    case LogoCallbackReason::DISABLED:\n    case LogoCallbackReason::CANCELED:\n    case LogoCallbackReason::FAILED:\n      break;\n    case LogoCallbackReason::REVALIDATED:\n      break;\n    case LogoCallbackReason::DETERMINED:\n      observer->OnLogoAvailable(logo ? &logo.value() : nullptr, from_cache);\n      break;\n  }\n  if (!from_cache) {\n    observer->OnObserverRemoved();\n  }\n}\n", "target": 1, "idx": 185834}
{"func": "static Position ComputePositionForChildrenRemoval(const Position& position,\n                                                  ContainerNode& container) {\n  Node* node = position.ComputeContainerNode();\n  if (container.ContainsIncludingHostElements(*node))\n    return Position::FirstPositionInNode(container);\n  return position;\n}\n", "target": 0, "idx": 135816}
{"func": "bool MdmEnrollmentEnabled() {\n  base::string16 mdm_url = GetMdmUrl();\n  return !mdm_url.empty();\n}\n", "target": 0, "idx": 142104}
{"func": " static inline ogg_uint32_t decode_packed_entry_number(codebook *book,\n\t\t\t\t\t\t      oggpack_buffer *b){\n   ogg_uint32_t chase=0;\n   int  read=book->dec_maxlength;\n   long lok = oggpack_look(b,read),i;\n\n while(lok<0 && read>1)\n    lok = oggpack_look(b, --read);\n\n if(lok<0){\n    oggpack_adv(b,1); /* force eop */\n return -1;\n }\n\n /* chase the tree with the bits we got */\n switch (book->dec_method)\n {\n case 0:\n {\n /* book->dec_nodeb==1, book->dec_leafw==1 */\n /* 8/8 - Used */\n\n       unsigned char *t=(unsigned char *)book->dec_table;\n \n       for(i=0;i<read;i++){\n\tchase=t[chase*2+((lok>>i)&1)];\n\tif(chase&0x80UL)break;\n       }\n       chase&=0x7fUL;\n       break;\n }\n case 1:\n {\n /* book->dec_nodeb==1, book->dec_leafw!=1 */\n\n       /* 8/16 - Used by infile2 */\n       unsigned char *t=(unsigned char *)book->dec_table;\n       for(i=0;i<read;i++){\n\tint bit=(lok>>i)&1;\n\tint next=t[chase+bit];\n\tif(next&0x80){\n\t  chase= (next<<8) | t[chase+bit+1+(!bit || t[chase]&0x80)];\n\t  break;\n\t}\n\tchase=next;\n       }\n       chase&=~0x8000UL;\n break;\n }\n case 2:\n {\n\n       /* book->dec_nodeb==2, book->dec_leafw==1 */\n       /* 16/16 - Used */\n       for(i=0;i<read;i++){\n\tchase=((ogg_uint16_t *)(book->dec_table))[chase*2+((lok>>i)&1)];\n\tif(chase&0x8000UL)break;\n       }\n       chase&=~0x8000UL;\n break;\n }\n case 3:\n {\n /* book->dec_nodeb==2, book->dec_leafw!=1 */\n\n       /* 16/32 - Used by infile2 */\n       ogg_uint16_t *t=(ogg_uint16_t *)book->dec_table;\n       for(i=0;i<read;i++){\n\tint bit=(lok>>i)&1;\n\tint next=t[chase+bit];\n\tif(next&0x8000){\n\t  chase= (next<<16) | t[chase+bit+1+(!bit || t[chase]&0x8000)];\n\t  break;\n\t}\n\tchase=next;\n       }\n       chase&=~0x80000000UL;\n break;\n }\n case 4:\n\n     {\n       for(i=0;i<read;i++){\n\tchase=((ogg_uint32_t *)(book->dec_table))[chase*2+((lok>>i)&1)];\n\tif(chase&0x80000000UL)break;\n       }\n       chase&=~0x80000000UL;\n break;\n }\n }\n\n if(i<read){\n    oggpack_adv(b,i+1);\n return chase;\n }\n  oggpack_adv(b,read+1);\n return(-1);\n}\n", "target": 1, "idx": 188006}
{"func": "process_open(u_int32_t id)\n{\n\tu_int32_t pflags;\n\tAttrib a;\n\tchar *name;\n\tint r, handle, fd, flags, mode, status = SSH2_FX_FAILURE;\n\n\tif ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0 ||\n\t    (r = sshbuf_get_u32(iqueue, &pflags)) != 0 || /* portable flags */\n\t    (r = decode_attrib(iqueue, &a)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"request %u: open flags %d\", id, pflags);\n\tflags = flags_from_portable(pflags);\n\tmode = (a.flags & SSH2_FILEXFER_ATTR_PERMISSIONS) ? a.perm : 0666;\n \tlogit(\"open \\\"%s\\\" flags %s mode 0%o\",\n \t    name, string_from_portable(pflags), mode);\n \tif (readonly &&\n\t    ((flags & O_ACCMODE) == O_WRONLY ||\n\t    (flags & O_ACCMODE) == O_RDWR)) {\n \t\tverbose(\"Refusing open request in read-only mode\");\n \t\tstatus = SSH2_FX_PERMISSION_DENIED;\n \t} else {\n\t\tfd = open(name, flags, mode);\n\t\tif (fd < 0) {\n\t\t\tstatus = errno_to_portable(errno);\n\t\t} else {\n\t\t\thandle = handle_new(HANDLE_FILE, name, fd, flags, NULL);\n\t\t\tif (handle < 0) {\n\t\t\t\tclose(fd);\n\t\t\t} else {\n\t\t\t\tsend_handle(id, handle);\n\t\t\t\tstatus = SSH2_FX_OK;\n\t\t\t}\n\t\t}\n\t}\n\tif (status != SSH2_FX_OK)\n\t\tsend_status(id, status);\n\tfree(name);\n}\n", "target": 1, "idx": 180887}
{"func": "ZEND_API void ZEND_FASTCALL _zend_hash_init(HashTable *ht, uint32_t nSize, dtor_func_t pDestructor, zend_bool persistent ZEND_FILE_LINE_DC)\n{\n \tGC_REFCOUNT(ht) = 1;\n \tGC_TYPE_INFO(ht) = IS_ARRAY;\n \tht->u.flags = (persistent ? HASH_FLAG_PERSISTENT : 0) | HASH_FLAG_APPLY_PROTECTION | HASH_FLAG_STATIC_KEYS;\n\tht->nTableSize = zend_hash_check_size(nSize);\n \tht->nTableMask = HT_MIN_MASK;\n \tHT_SET_DATA_ADDR(ht, &uninitialized_bucket);\n \tht->nNumUsed = 0;\n \tht->nNumOfElements = 0;\n \tht->nInternalPointer = HT_INVALID_IDX;\n \tht->nNextFreeElement = 0;\n \tht->pDestructor = pDestructor;\n }\n", "target": 1, "idx": 181582}
{"func": "void GfxPatternColorSpace::getRGB(GfxColor *color, GfxRGB *rgb) {\n  rgb->r = rgb->g = rgb->b = 0;\n}\n", "target": 0, "idx": 1070}
{"func": "static int snd_timer_user_open(struct inode *inode, struct file *file)\n{\n\tstruct snd_timer_user *tu;\n\tint err;\n\n\terr = nonseekable_open(inode, file);\n\tif (err < 0)\n\t\treturn err;\n\n\ttu = kzalloc(sizeof(*tu), GFP_KERNEL);\n\tif (tu == NULL)\n \t\treturn -ENOMEM;\n \tspin_lock_init(&tu->qlock);\n \tinit_waitqueue_head(&tu->qchange_sleep);\n\tmutex_init(&tu->tread_sem);\n \ttu->ticks = 1;\n \ttu->queue_size = 128;\n \ttu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),\n\t\t\t    GFP_KERNEL);\n\tif (tu->queue == NULL) {\n\t\tkfree(tu);\n\t\treturn -ENOMEM;\n\t}\n\tfile->private_data = tu;\n\treturn 0;\n}\n", "target": 1, "idx": 180577}
{"func": "int main(int argc, char **argv) {\n int frame_cnt = 0;\n FILE *outfile = NULL;\n vpx_codec_ctx_t codec;\n VpxVideoReader *reader = NULL;\n const VpxVideoInfo *info = NULL;\n const VpxInterface *decoder = NULL;\n\n  exec_name = argv[0];\n\n if (argc != 3)\n    die(\"Invalid number of arguments.\");\n\n  reader = vpx_video_reader_open(argv[1]);\n if (!reader)\n    die(\"Failed to open %s for reading.\", argv[1]);\n\n if (!(outfile = fopen(argv[2], \"wb\")))\n    die(\"Failed to open %s for writing.\", argv[2]);\n\n  info = vpx_video_reader_get_info(reader);\n\n  decoder = get_vpx_decoder_by_fourcc(info->codec_fourcc);\n\n   if (!decoder)\n     die(\"Unknown input codec.\");\n \n  printf(\"Using %s\\n\", vpx_codec_iface_name(decoder->interface()));\n \n  if (vpx_codec_dec_init(&codec, decoder->interface(), NULL, 0))\n     die_codec(&codec, \"Failed to initialize decoder\");\n \n   while (vpx_video_reader_read_frame(reader)) {\n vpx_codec_iter_t iter = NULL;\n vpx_image_t *img = NULL;\n size_t frame_size = 0;\n const unsigned char *frame = vpx_video_reader_get_frame(reader,\n &frame_size);\n if (vpx_codec_decode(&codec, frame, (unsigned int)frame_size, NULL, 0))\n      die_codec(&codec, \"Failed to decode frame\");\n\n while ((img = vpx_codec_get_frame(&codec, &iter)) != NULL) {\n unsigned char digest[16];\n\n      get_image_md5(img, digest);\n      print_md5(outfile, digest);\n      fprintf(outfile, \"  img-%dx%d-%04d.i420\\n\",\n              img->d_w, img->d_h, ++frame_cnt);\n }\n }\n\n  printf(\"Processed %d frames.\\n\", frame_cnt);\n if (vpx_codec_destroy(&codec))\n    die_codec(&codec, \"Failed to destroy codec.\");\n\n  vpx_video_reader_close(reader);\n\n  fclose(outfile);\n return EXIT_SUCCESS;\n}\n", "target": 1, "idx": 188496}
{"func": "void DistillerNativeJavaScript::BindFunctionToObject(\n    v8::Local<v8::Object> javascript_object,\n    const std::string& name,\n    const base::Callback<Sig> callback) {\n  v8::Isolate* isolate = javascript_object->GetIsolate();\n  javascript_object->Set(\n      gin::StringToSymbol(isolate, name),\n      gin::CreateFunctionTemplate(isolate, callback)->GetFunction());\n }\n", "target": 0, "idx": 129926}
{"func": "static int set_file_offset(stb_vorbis *f, unsigned int loc)\n{\n   #ifndef STB_VORBIS_NO_PUSHDATA_API\n   if (f->push_mode) return 0;\n   #endif\n   f->eof = 0;\n   if (USE_MEMORY(f)) {\n      if (f->stream_start + loc >= f->stream_end || f->stream_start + loc < f->stream_start) {\n         f->stream = f->stream_end;\n         f->eof = 1;\n         return 0;\n      } else {\n         f->stream = f->stream_start + loc;\n         return 1;\n      }\n   }\n   #ifndef STB_VORBIS_NO_STDIO\n   if (loc + f->f_start < loc || loc >= 0x80000000) {\n      loc = 0x7fffffff;\n      f->eof = 1;\n   } else {\n      loc += f->f_start;\n   }\n   if (!fseek(f->f, loc, SEEK_SET))\n      return 1;\n   f->eof = 1;\n   fseek(f->f, f->f_start, SEEK_END);\n   return 0;\n   #endif\n}\n", "target": 0, "idx": 75292}
{"func": " static int kvm_vm_ioctl_set_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)\n {\n \tint start = 0;\n \tu32 prev_legacy, cur_legacy;\n \tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n \tprev_legacy = kvm->arch.vpit->pit_state.flags & KVM_PIT_FLAGS_HPET_LEGACY;\n\tcur_legacy = ps->flags & KVM_PIT_FLAGS_HPET_LEGACY;\n\tif (!prev_legacy && cur_legacy)\n\t\tstart = 1;\n \tmemcpy(&kvm->arch.vpit->pit_state.channels, &ps->channels,\n \t       sizeof(kvm->arch.vpit->pit_state.channels));\n \tkvm->arch.vpit->pit_state.flags = ps->flags;\n\tkvm_pit_load_count(kvm, 0, kvm->arch.vpit->pit_state.channels[0].count, start);\n \tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n \treturn 0;\n }\n", "target": 1, "idx": 180733}
{"func": "INST_HANDLER (lac) {\t// LAC Z, Rd\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\n\t__generic_ld_st (op, \"ram\", 'z', 1, 0, 0, 0);\t// 0: Read (RAMPZ:Z)\n\tESIL_A (\"r%d,0xff,^,&,\", d);\t\t\t// 0: (Z) & ~Rd\n\tESIL_A (\"DUP,r%d,=,\", d);\t\t\t// Rd = [0]\n\t__generic_ld_st (op, \"ram\", 'z', 1, 0, 0, 1);\t// Store in RAM\n}\n", "target": 0, "idx": 82727}
{"func": "xmlXPathNextPrecedingInternal(xmlXPathParserContextPtr ctxt,\n                               xmlNodePtr cur)\n {\n     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);\n    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||\n\t(ctxt->context->node->type == XML_NAMESPACE_DECL))\n\treturn(NULL);\n     if (cur == NULL) {\n         cur = ctxt->context->node;\n         if (cur == NULL)\n             return (NULL);\n         ctxt->ancestor = cur->parent;\n     }\n     if ((cur->prev != NULL) && (cur->prev->type == XML_DTD_NODE))\n\tcur = cur->prev;\n    while (cur->prev == NULL) {\n        cur = cur->parent;\n        if (cur == NULL)\n            return (NULL);\n        if (cur == ctxt->context->doc->children)\n            return (NULL);\n        if (cur != ctxt->ancestor)\n            return (cur);\n        ctxt->ancestor = cur->parent;\n    }\n    cur = cur->prev;\n    while (cur->last != NULL)\n        cur = cur->last;\n    return (cur);\n}\n", "target": 1, "idx": 183429}
{"func": " ieee802_15_4_if_print(netdissect_options *ndo,\n                       const struct pcap_pkthdr *h, const u_char *p)\n {\n \tu_int caplen = h->caplen;\n\tint hdrlen;\n \tuint16_t fc;\n \tuint8_t seq;\n \n \tif (caplen < 3) {\n\t\tND_PRINT((ndo, \"[|802.15.4] %x\", caplen));\n \t\treturn caplen;\n \t}\n \n \tfc = EXTRACT_LE_16BITS(p);\n\thdrlen = extract_header_length(fc);\n \tseq = EXTRACT_LE_8BITS(p + 2);\n \n \tp += 3;\n \tcaplen -= 3;\n \n\tND_PRINT((ndo,\"IEEE 802.15.4 %s packet \", ftypes[fc & 0x7]));\n \tif (ndo->ndo_vflag)\n \t\tND_PRINT((ndo,\"seq %02x \", seq));\n\tif (hdrlen == -1) {\n\t\tND_PRINT((ndo,\"invalid! \"));\n\t\treturn caplen;\n\t}\n\tif (!ndo->ndo_vflag) {\n\t\tp+= hdrlen;\n\t\tcaplen -= hdrlen;\n\t} else {\n\t\tuint16_t panid = 0;\n \n\t\tswitch ((fc >> 10) & 0x3) {\n\t\tcase 0x00:\n \t\t\tND_PRINT((ndo,\"none \"));\n\t\t\tbreak;\n\t\tcase 0x01:\n \t\t\tND_PRINT((ndo,\"reserved destination addressing mode\"));\n\t\t\treturn 0;\n\t\tcase 0x02:\n\t\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\t\tp += 2;\n\t\t\tND_PRINT((ndo,\"%04x:%04x \", panid, EXTRACT_LE_16BITS(p)));\n\t\t\tp += 2;\n\t\t\tbreak;\n\t\tcase 0x03:\n\t\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\t\tp += 2;\n\t\t\tND_PRINT((ndo,\"%04x:%s \", panid, le64addr_string(ndo, p)));\n\t\t\tp += 8;\n\t\t\tbreak;\n \t\t}\n \t\tND_PRINT((ndo,\"< \"));\n \n\t\tswitch ((fc >> 14) & 0x3) {\n\t\tcase 0x00:\n \t\t\tND_PRINT((ndo,\"none \"));\n\t\t\tbreak;\n\t\tcase 0x01:\n \t\t\tND_PRINT((ndo,\"reserved source addressing mode\"));\n\t\t\treturn 0;\n\t\tcase 0x02:\n\t\t\tif (!(fc & (1 << 6))) {\n\t\t\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\t\t\tp += 2;\n \t\t\t}\n\t\t\tND_PRINT((ndo,\"%04x:%04x \", panid, EXTRACT_LE_16BITS(p)));\n \t\t\tp += 2;\n\t\t\tbreak;\n\t\tcase 0x03:\n\t\t\tif (!(fc & (1 << 6))) {\n\t\t\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\t\t\tp += 2;\n \t\t\t}\n                        ND_PRINT((ndo,\"%04x:%s \", panid, le64addr_string(ndo, p)));\n\t\t\tp += 8;\n\t\t\tbreak;\n \t\t}\n\t\tcaplen -= hdrlen;\n \t}\n \n \tif (!ndo->ndo_suppress_default_print)\n \t\tND_DEFAULTPRINT(p, caplen);\n \n\treturn 0;\n }\n", "target": 1, "idx": 183202}
{"func": "bool Textfield::GetTextRange(gfx::Range* range) const {\n  if (!ImeEditingAllowed())\n    return false;\n\n  model_->GetTextRange(range);\n  return true;\n}\n", "target": 0, "idx": 137220}
{"func": "static bool arg_type_is_refcounted(enum bpf_arg_type type)\n{\n\treturn type == ARG_PTR_TO_SOCKET;\n}\n", "target": 0, "idx": 91396}
{"func": "void AutofillManager::OnFormsSeen(const std::vector<FormData>& forms) {\n  bool enabled = IsAutofillEnabled();\n  if (!has_logged_autofill_enabled_) {\n    metric_logger_->LogIsAutofillEnabledAtPageLoad(enabled);\n    has_logged_autofill_enabled_ = true;\n  }\n\n  if (!enabled)\n    return;\n\n  ParseForms(forms);\n}\n", "target": 0, "idx": 105346}
{"func": "xfs_handlereq_to_dentry(\n\tstruct file\t\t*parfilp,\n\txfs_fsop_handlereq_t\t*hreq)\n{\n\treturn xfs_handle_to_dentry(parfilp, hreq->ihandle, hreq->ihandlen);\n}\n", "target": 0, "idx": 36914}
{"func": "static void ext2_put_super (struct super_block * sb)\n{\n\tint db_count;\n\tint i;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n \n \tdquot_disable(sb, -1, DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);\n \n\text2_xattr_put_super(sb);\n \tif (!(sb->s_flags & MS_RDONLY)) {\n \t\tstruct ext2_super_block *es = sbi->s_es;\n \n\t\tspin_lock(&sbi->s_lock);\n\t\tes->s_state = cpu_to_le16(sbi->s_mount_state);\n\t\tspin_unlock(&sbi->s_lock);\n\t\text2_sync_super(sb, es, 1);\n\t}\n\tdb_count = sbi->s_gdb_count;\n\tfor (i = 0; i < db_count; i++)\n\t\tif (sbi->s_group_desc[i])\n\t\t\tbrelse (sbi->s_group_desc[i]);\n\tkfree(sbi->s_group_desc);\n\tkfree(sbi->s_debts);\n\tpercpu_counter_destroy(&sbi->s_freeblocks_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tbrelse (sbi->s_sbh);\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\n\tkfree(sbi);\n}\n", "target": 1, "idx": 183146}
{"func": "void LinkChangeSerializerMarkupAccumulator::appendAttribute(StringBuilder& result, Element* element, const Attribute& attribute, Namespaces* namespaces)\n{\n    if (m_replaceLinks && element->isURLAttribute(attribute) && !element->isJavaScriptURLAttribute(attribute)) {\n        String completeURL = m_document->completeURL(attribute.value());\n        if (m_replaceLinks->contains(completeURL)) {\n            result.append(' ');\n            result.append(attribute.name().toString());\n            result.appendLiteral(\"=\\\"\");\n            if (!m_directoryName.isEmpty()) {\n                result.appendLiteral(\"./\");\n                result.append(m_directoryName);\n                result.append('/');\n            }\n            result.append(m_replaceLinks->get(completeURL));\n            result.appendLiteral(\"\\\"\");\n            return;\n        }\n    }\n    MarkupAccumulator::appendAttribute(result, element, attribute, namespaces);\n}\n", "target": 1, "idx": 185268}
{"func": "static int hci_sock_getname(struct socket *sock, struct sockaddr *addr,\n\t\t\t    int *addr_len, int peer)\n{\n\tstruct sockaddr_hci *haddr = (struct sockaddr_hci *) addr;\n\tstruct sock *sk = sock->sk;\n\tstruct hci_dev *hdev = hci_pi(sk)->hdev;\n\n\tBT_DBG(\"sock %p sk %p\", sock, sk);\n\n\tif (!hdev)\n\t\treturn -EBADFD;\n\n\tlock_sock(sk);\n\n \t*addr_len = sizeof(*haddr);\n \thaddr->hci_family = AF_BLUETOOTH;\n \thaddr->hci_dev    = hdev->id;\n \n \trelease_sock(sk);\n \treturn 0;\n}\n", "target": 1, "idx": 183072}
{"func": "void br_mdb_notify(struct net_device *dev, struct net_bridge_port *port,\n\t\t   struct br_ip *group, int type)\n {\n \tstruct br_mdb_entry entry;\n \n \tentry.ifindex = port->dev->ifindex;\n \tentry.addr.proto = group->proto;\n \tentry.addr.u.ip4 = group->u.ip4;\n#if IS_ENABLED(CONFIG_IPV6)\n\tentry.addr.u.ip6 = group->u.ip6;\n#endif\n\t__br_mdb_notify(dev, &entry, type);\n}\n", "target": 1, "idx": 179226}
{"func": "static void __update_nat_bits(struct f2fs_sb_info *sbi, nid_t start_nid,\n\t\t\t\t\t\tstruct page *page)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tunsigned int nat_index = start_nid / NAT_ENTRY_PER_BLOCK;\n\tstruct f2fs_nat_block *nat_blk = page_address(page);\n\tint valid = 0;\n\tint i;\n\n\tif (!enabled_nat_bits(sbi, NULL))\n\t\treturn;\n\n\tfor (i = 0; i < NAT_ENTRY_PER_BLOCK; i++) {\n\t\tif (start_nid == 0 && i == 0)\n\t\t\tvalid++;\n\t\tif (nat_blk->entries[i].block_addr)\n\t\t\tvalid++;\n\t}\n\tif (valid == 0) {\n\t\t__set_bit_le(nat_index, nm_i->empty_nat_bits);\n\t\t__clear_bit_le(nat_index, nm_i->full_nat_bits);\n\t\treturn;\n\t}\n\n\t__clear_bit_le(nat_index, nm_i->empty_nat_bits);\n\tif (valid == NAT_ENTRY_PER_BLOCK)\n\t\t__set_bit_le(nat_index, nm_i->full_nat_bits);\n\telse\n\t\t__clear_bit_le(nat_index, nm_i->full_nat_bits);\n}\n", "target": 0, "idx": 85247}
{"func": " const CuePoint* Cues::GetLast() const {\n  if (m_cue_points == NULL)\n     return NULL;\n \n  if (m_count <= 0)\n    return NULL;\n#if 0\n    LoadCuePoint();  //init cues\n    const size_t count = m_count + m_preload_count;\n    if (count == 0)  //weird\n        return NULL;\n    const size_t index = count - 1;\n    CuePoint* const* const pp = m_cue_points;\n    assert(pp);\n    CuePoint* const pCP = pp[index];\n    assert(pCP);\n    pCP->Load(m_pSegment->m_pReader);\n    assert(pCP->GetTimeCode() >= 0);\n#else\n   const long index = m_count - 1;\n \n   CuePoint* const* const pp = m_cue_points;\n  assert(pp);\n \n   CuePoint* const pCP = pp[index];\n  assert(pCP);\n  assert(pCP->GetTimeCode() >= 0);\n#endif\n \n   return pCP;\n }\n", "target": 1, "idx": 187842}
{"func": "xmlCtxtUseOptions(xmlParserCtxtPtr ctxt, int options)\n{\n   return(xmlCtxtUseOptionsInternal(ctxt, options, NULL));\n}\n", "target": 0, "idx": 59426}
{"func": "void PasswordAutofillAgent::UpdateStateForTextChange(\n    const WebInputElement& element) {\n  if (!element.IsTextField())\n    return;\n  WebInputElement mutable_element = element;  // We need a non-const.\n\n  const base::string16 element_value = element.Value().Utf16();\n  field_data_manager_.UpdateFieldDataMap(element, element_value,\n                                         FieldPropertiesFlags::USER_TYPED);\n\n  ProvisionallySavePassword(element.Form(), element, RESTRICTION_NONE);\n\n  if (element.IsPasswordFieldForAutofill()) {\n    auto iter = password_to_username_.find(element);\n    if (iter != password_to_username_.end()) {\n      web_input_to_password_info_[iter->second].password_was_edited_last = true;\n      mutable_element.SetAutofillState(WebAutofillState::kNotFilled);\n    }\n    GetPasswordManagerDriver()->UserModifiedPasswordField();\n  } else {\n    GetPasswordManagerDriver()->UserModifiedNonPasswordField(\n        element.UniqueRendererFormControlId(), element_value);\n  }\n}\n", "target": 0, "idx": 150343}
{"func": " void PartialMagnificationController::OnWindowDestroying(aura::Window* window) {\n   CloseMagnifierWindow();\n \n   aura::Window* new_root_window = GetCurrentRootWindow();\n   if (new_root_window != window)\n    SwitchTargetRootWindow(new_root_window);\n }\n", "target": 1, "idx": 185517}
{"func": "bool SendNativeKeyEventJSONRequest(\n    AutomationMessageSender* sender,\n    int browser_index,\n    int tab_index,\n    ui::KeyboardCode key_code,\n    int modifiers,\n    std::string* error_msg) {\n  DictionaryValue dict;\n  dict.SetString(\"command\", \"SendOSLevelKeyEventToTab\");\n  dict.SetInteger(\"windex\", browser_index);\n  dict.SetInteger(\"tab_index\", tab_index);\n  dict.SetInteger(\"keyCode\", key_code);\n  dict.SetInteger(\"modifiers\", modifiers);\n  DictionaryValue reply_dict;\n  return SendAutomationJSONRequest(sender, dict, &reply_dict, error_msg);\n}\n", "target": 0, "idx": 105557}
{"func": "bool RenderWidgetHostViewAura::NeedsMouseCapture() {\n#if defined(OS_LINUX) && !defined(OS_CHROMEOS)\n  return NeedsInputGrab();\n#endif\n  return false;\n}\n", "target": 0, "idx": 144938}
{"func": "static int udp_v6_push_pending_frames(struct sock *sk)\n{\n\tstruct sk_buff *skb;\n \tstruct udphdr *uh;\n \tstruct udp_sock  *up = udp_sk(sk);\n \tstruct inet_sock *inet = inet_sk(sk);\n\tstruct flowi6 *fl6 = &inet->cork.fl.u.ip6;\n \tint err = 0;\n \tint is_udplite = IS_UDPLITE(sk);\n \t__wsum csum = 0;\n \n \t/* Grab the skbuff where UDP header space exists. */\n \tif ((skb = skb_peek(&sk->sk_write_queue)) == NULL)\n \t\tgoto out;\n\n\t/*\n\t * Create a UDP header\n\t */\n\tuh = udp_hdr(skb);\n\tuh->source = fl6->fl6_sport;\n\tuh->dest = fl6->fl6_dport;\n\tuh->len = htons(up->len);\n\tuh->check = 0;\n\n\tif (is_udplite)\n\t\tcsum = udplite_csum_outgoing(sk, skb);\n\telse if (skb->ip_summed == CHECKSUM_PARTIAL) { /* UDP hardware csum */\n\t\tudp6_hwcsum_outgoing(sk, skb, &fl6->saddr, &fl6->daddr,\n\t\t\t\t     up->len);\n\t\tgoto send;\n\t} else\n\t\tcsum = udp_csum_outgoing(sk, skb);\n\n\t/* add protocol-dependent pseudo-header */\n\tuh->check = csum_ipv6_magic(&fl6->saddr, &fl6->daddr,\n\t\t\t\t    up->len, fl6->flowi6_proto, csum);\n\tif (uh->check == 0)\n\t\tuh->check = CSUM_MANGLED_0;\n\nsend:\n\terr = ip6_push_pending_frames(sk);\n\tif (err) {\n\t\tif (err == -ENOBUFS && !inet6_sk(sk)->recverr) {\n\t\t\tUDP6_INC_STATS_USER(sock_net(sk),\n\t\t\t\t\t    UDP_MIB_SNDBUFERRORS, is_udplite);\n\t\t\terr = 0;\n\t\t}\n\t} else\n\t\tUDP6_INC_STATS_USER(sock_net(sk),\n\t\t\t\t    UDP_MIB_OUTDATAGRAMS, is_udplite);\nout:\n\tup->len = 0;\n\tup->pending = 0;\n\treturn err;\n}\n", "target": 1, "idx": 179189}
{"func": "void MediaStreamManager::Aborted(MediaStreamType stream_type,\n                                 int capture_session_id) {\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n  DVLOG(1) << \"Aborted({stream_type = \" << stream_type << \"} \"\n           << \"{capture_session_id = \" << capture_session_id << \"})\";\n  StopDevice(stream_type, capture_session_id);\n}\n", "target": 0, "idx": 166191}
{"func": "int GetNetSSLVersion(SSL* ssl) {\n  switch (SSL_version(ssl)) {\n    case SSL2_VERSION:\n      return SSL_CONNECTION_VERSION_SSL2;\n    case SSL3_VERSION:\n      return SSL_CONNECTION_VERSION_SSL3;\n    case TLS1_VERSION:\n      return SSL_CONNECTION_VERSION_TLS1;\n    case 0x0302:\n      return SSL_CONNECTION_VERSION_TLS1_1;\n    case 0x0303:\n      return SSL_CONNECTION_VERSION_TLS1_2;\n    default:\n      return SSL_CONNECTION_VERSION_UNKNOWN;\n  }\n}\n", "target": 0, "idx": 133760}
{"func": "  void CancelUnlockOperation() { cancel_unlock_ = true; }\n", "target": 0, "idx": 133063}
{"func": "bool Vp9Parser::ParseUncompressedHeader(const uint8_t* stream,\n                                        off_t frame_size,\n                                        Vp9FrameHeader* fhdr) {\n  reader_.Initialize(stream, frame_size);\n  fhdr->data = stream;\n  fhdr->frame_size = frame_size;\n \n   if (reader_.ReadLiteral(2) != 0x2)\n    return false;\n\n  fhdr->profile = ReadProfile();\n  if (fhdr->profile >= kVp9MaxProfile) {\n    DVLOG(1) << \"Unsupported bitstream profile\";\n    return false;\n  }\n\n  fhdr->show_existing_frame = reader_.ReadBool();\n  if (fhdr->show_existing_frame) {\n    fhdr->frame_to_show = reader_.ReadLiteral(3);\n    fhdr->show_frame = true;\n\n    if (!reader_.IsValid()) {\n      DVLOG(1) << \"parser reads beyond the end of buffer\";\n      return false;\n    }\n    fhdr->uncompressed_header_size = reader_.GetBytesRead();\n    return true;\n  }\n\n  fhdr->frame_type = static_cast<Vp9FrameHeader::FrameType>(reader_.ReadBool());\n  fhdr->show_frame = reader_.ReadBool();\n  fhdr->error_resilient_mode = reader_.ReadBool();\n\n  if (fhdr->IsKeyframe()) {\n    if (!VerifySyncCode())\n      return false;\n\n     if (!ReadBitDepthColorSpaceSampling(fhdr))\n       return false;\n \n    fhdr->refresh_flags = 0xff;\n \n     ReadFrameSize(fhdr);\n     ReadDisplayFrameSize(fhdr);\n  } else {\n    if (!fhdr->show_frame)\n      fhdr->intra_only = reader_.ReadBool();\n\n    if (!fhdr->error_resilient_mode)\n      fhdr->reset_context = reader_.ReadLiteral(2);\n\n    if (fhdr->intra_only) {\n      if (!VerifySyncCode())\n        return false;\n\n      if (fhdr->profile > 0) {\n        if (!ReadBitDepthColorSpaceSampling(fhdr))\n          return false;\n      } else {\n        fhdr->bit_depth = 8;\n        fhdr->color_space = Vp9ColorSpace::BT_601;\n         fhdr->subsampling_x = fhdr->subsampling_y = 1;\n       }\n \n      fhdr->refresh_flags = reader_.ReadLiteral(8);\n       ReadFrameSize(fhdr);\n       ReadDisplayFrameSize(fhdr);\n     } else {\n      fhdr->refresh_flags = reader_.ReadLiteral(8);\n \n       for (size_t i = 0; i < kVp9NumRefsPerFrame; i++) {\n         fhdr->frame_refs[i] = reader_.ReadLiteral(kVp9NumRefFramesLog2);\n        fhdr->ref_sign_biases[i] = reader_.ReadBool();\n      }\n\n      if (!ReadFrameSizeFromRefs(fhdr))\n        return false;\n      ReadDisplayFrameSize(fhdr);\n\n      fhdr->allow_high_precision_mv = reader_.ReadBool();\n      fhdr->interp_filter = ReadInterpFilter();\n    }\n  }\n\n  if (fhdr->error_resilient_mode) {\n    fhdr->frame_parallel_decoding_mode = true;\n  } else {\n    fhdr->refresh_frame_context = reader_.ReadBool();\n    fhdr->frame_parallel_decoding_mode = reader_.ReadBool();\n  }\n \n   fhdr->frame_context_idx = reader_.ReadLiteral(2);\n \n  if (fhdr->IsKeyframe() || fhdr->intra_only)\n    SetupPastIndependence();\n  ReadLoopFilter();\n   ReadQuantization(&fhdr->quant_params);\n  ReadSegmentation();\n \n   ReadTiles(fhdr);\n \n  fhdr->first_partition_size = reader_.ReadLiteral(16);\n  if (fhdr->first_partition_size == 0) {\n    DVLOG(1) << \"invalid header size\";\n    return false;\n  }\n\n  if (!reader_.IsValid()) {\n    DVLOG(1) << \"parser reads beyond the end of buffer\";\n    return false;\n   }\n   fhdr->uncompressed_header_size = reader_.GetBytesRead();\n \n  SetupSegmentationDequant(fhdr->quant_params);\n  SetupLoopFilter();\n  UpdateSlots(fhdr);\n   return true;\n }\n", "target": 1, "idx": 183534}
{"func": "void Splash::scaleImageYdXd(SplashImageSource src, void *srcData,\n\t\t\t    SplashColorMode srcMode, int nComps,\n\t\t\t    GBool srcAlpha, int srcWidth, int srcHeight,\n\t\t\t    int scaledWidth, int scaledHeight,\n\t\t\t    SplashBitmap *dest) {\n  Guchar *lineBuf, *alphaLineBuf;\n  Guint *pixBuf, *alphaPixBuf;\n  Guint pix0, pix1, pix2;\n#if SPLASH_CMYK\n  Guint pix3;\n  Guint pix[SPOT_NCOMPS+4], cp;\n#endif\n  Guint alpha;\n  Guchar *destPtr, *destAlphaPtr;\n  int yp, yq, xp, xq, yt, y, yStep, xt, x, xStep, xx, xxa, d, d0, d1;\n  int i, j;\n\n  yp = srcHeight / scaledHeight;\n  yq = srcHeight % scaledHeight;\n\n  xp = srcWidth / scaledWidth;\n  xq = srcWidth % scaledWidth;\n\n  lineBuf = (Guchar *)gmallocn(srcWidth, nComps);\n  pixBuf = (Guint *)gmallocn(srcWidth, nComps * sizeof(int));\n  if (srcAlpha) {\n    alphaLineBuf = (Guchar *)gmalloc(srcWidth);\n    alphaPixBuf = (Guint *)gmallocn(srcWidth, sizeof(int));\n  } else {\n    alphaLineBuf = NULL;\n    alphaPixBuf = NULL;\n  }\n\n  yt = 0;\n\n  destPtr = dest->data;\n  destAlphaPtr = dest->alpha;\n  for (y = 0; y < scaledHeight; ++y) {\n\n    if ((yt += yq) >= scaledHeight) {\n      yt -= scaledHeight;\n      yStep = yp + 1;\n    } else {\n      yStep = yp;\n    }\n\n    memset(pixBuf, 0, srcWidth * nComps * sizeof(int));\n    if (srcAlpha) {\n      memset(alphaPixBuf, 0, srcWidth * sizeof(int));\n    }\n    for (i = 0; i < yStep; ++i) {\n      (*src)(srcData, lineBuf, alphaLineBuf);\n      for (j = 0; j < srcWidth * nComps; ++j) {\n\tpixBuf[j] += lineBuf[j];\n      }\n      if (srcAlpha) {\n\tfor (j = 0; j < srcWidth; ++j) {\n\t  alphaPixBuf[j] += alphaLineBuf[j];\n\t}\n      }\n    }\n\n    xt = 0;\n    d0 = (1 << 23) / (yStep * xp);\n    d1 = (1 << 23) / (yStep * (xp + 1));\n\n    xx = xxa = 0;\n    for (x = 0; x < scaledWidth; ++x) {\n\n      if ((xt += xq) >= scaledWidth) {\n\txt -= scaledWidth;\n\txStep = xp + 1;\n\td = d1;\n      } else {\n\txStep = xp;\n\td = d0;\n      }\n\n      switch (srcMode) {\n\n      case splashModeMono8:\n\n\tpix0 = 0;\n\tfor (i = 0; i < xStep; ++i) {\n\t  pix0 += pixBuf[xx++];\n\t}\n\tpix0 = (pix0 * d) >> 23;\n\n\t*destPtr++ = (Guchar)pix0;\n\tbreak;\n\n      case splashModeRGB8:\n\n\tpix0 = pix1 = pix2 = 0;\n\tfor (i = 0; i < xStep; ++i) {\n\t  pix0 += pixBuf[xx];\n\t  pix1 += pixBuf[xx+1];\n\t  pix2 += pixBuf[xx+2];\n\t  xx += 3;\n\t}\n\tpix0 = (pix0 * d) >> 23;\n\tpix1 = (pix1 * d) >> 23;\n\tpix2 = (pix2 * d) >> 23;\n\n\t*destPtr++ = (Guchar)pix0;\n\t*destPtr++ = (Guchar)pix1;\n\t*destPtr++ = (Guchar)pix2;\n\tbreak;\n\n      case splashModeXBGR8:\n\n\tpix0 = pix1 = pix2 = 0;\n\tfor (i = 0; i < xStep; ++i) {\n\t  pix0 += pixBuf[xx];\n\t  pix1 += pixBuf[xx+1];\n\t  pix2 += pixBuf[xx+2];\n\t  xx += 4;\n\t}\n\tpix0 = (pix0 * d) >> 23;\n\tpix1 = (pix1 * d) >> 23;\n\tpix2 = (pix2 * d) >> 23;\n\n\t*destPtr++ = (Guchar)pix2;\n\t*destPtr++ = (Guchar)pix1;\n\t*destPtr++ = (Guchar)pix0;\n\t*destPtr++ = (Guchar)255;\n\tbreak;\n\n      case splashModeBGR8:\n\n\tpix0 = pix1 = pix2 = 0;\n\tfor (i = 0; i < xStep; ++i) {\n\t  pix0 += pixBuf[xx];\n\t  pix1 += pixBuf[xx+1];\n\t  pix2 += pixBuf[xx+2];\n\t  xx += 3;\n\t}\n\tpix0 = (pix0 * d) >> 23;\n\tpix1 = (pix1 * d) >> 23;\n\tpix2 = (pix2 * d) >> 23;\n\n\t*destPtr++ = (Guchar)pix2;\n\t*destPtr++ = (Guchar)pix1;\n\t*destPtr++ = (Guchar)pix0;\n\tbreak;\n\n#if SPLASH_CMYK\n      case splashModeCMYK8:\n\n\tpix0 = pix1 = pix2 = pix3 = 0;\n\tfor (i = 0; i < xStep; ++i) {\n\t  pix0 += pixBuf[xx];\n\t  pix1 += pixBuf[xx+1];\n\t  pix2 += pixBuf[xx+2];\n\t  pix3 += pixBuf[xx+3];\n\t  xx += 4;\n\t}\n\tpix0 = (pix0 * d) >> 23;\n\tpix1 = (pix1 * d) >> 23;\n\tpix2 = (pix2 * d) >> 23;\n\tpix3 = (pix3 * d) >> 23;\n\n\t*destPtr++ = (Guchar)pix0;\n\t*destPtr++ = (Guchar)pix1;\n\t*destPtr++ = (Guchar)pix2;\n\t*destPtr++ = (Guchar)pix3;\n\tbreak;\n      case splashModeDeviceN8:\n\n  for (cp = 0; cp < SPOT_NCOMPS+4; cp++)\n    pix[cp] = 0;\n\tfor (i = 0; i < xStep; ++i) {\n    for (cp = 0; cp < SPOT_NCOMPS+4; cp++) {\n      pix[cp] += pixBuf[xx + cp];\n    }\n    xx += (SPOT_NCOMPS+4);\n\t}\n  for (cp = 0; cp < SPOT_NCOMPS+4; cp++)\n    pix[cp] = (pix[cp] * d) >> 23;\n\n  for (cp = 0; cp < SPOT_NCOMPS+4; cp++)\n    *destPtr++ = (Guchar)pix[cp];\n\tbreak;\n#endif\n\n\n      case splashModeMono1: // mono1 is not allowed\n      default:\n\tbreak;\n      }\n\n      if (srcAlpha) {\n\talpha = 0;\n\tfor (i = 0; i < xStep; ++i, ++xxa) {\n\t  alpha += alphaPixBuf[xxa];\n\t}\n\talpha = (alpha * d) >> 23;\n\t*destAlphaPtr++ = (Guchar)alpha;\n      }\n    }\n  }\n\n  gfree(alphaPixBuf);\n  gfree(alphaLineBuf);\n  gfree(pixBuf);\n  gfree(lineBuf);\n}\n", "target": 0, "idx": 4134}
{"func": "static int nl80211_valid_4addr(struct cfg80211_registered_device *rdev,\n\t\t\t       struct net_device *netdev, u8 use_4addr,\n\t\t\t       enum nl80211_iftype iftype)\n{\n\tif (!use_4addr) {\n\t\tif (netdev && (netdev->priv_flags & IFF_BRIDGE_PORT))\n\t\t\treturn -EBUSY;\n\t\treturn 0;\n\t}\n\n\tswitch (iftype) {\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tif (rdev->wiphy.flags & WIPHY_FLAG_4ADDR_AP)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (rdev->wiphy.flags & WIPHY_FLAG_4ADDR_STATION)\n\t\t\treturn 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n", "target": 0, "idx": 26781}
{"func": "encode_UNROLL_XLATE(const struct ofpact_unroll_xlate *unroll OVS_UNUSED,\n                    enum ofp_version ofp_version OVS_UNUSED,\n                    struct ofpbuf *out OVS_UNUSED)\n{\n    OVS_NOT_REACHED();\n}\n", "target": 0, "idx": 76908}
{"func": "static int jpeg_size(unsigned char* data, unsigned int data_size,\n                     int *width, int *height)\n{\n    int i = 0;\n    if (i + 3 < data_size && data[i] == 0xFF && data[i+1] == 0xD8 &&\n            data[i+2] == 0xFF && data[i+3] == 0xE0) {\n        i += 4;\n        if(i + 6 < data_size &&\n                data[i+2] == 'J' && data[i+3] == 'F' && data[i+4] == 'I' &&\n                data[i+5] == 'F' && data[i+6] == 0x00) {\n            unsigned short block_length = data[i] * 256 + data[i+1];\n            while(i<data_size) {\n                i+=block_length;\n                if((i + 1) >= data_size)\n                    return -1;\n                if(data[i] != 0xFF)\n                    return -1;\n                if(data[i+1] == 0xC0) {\n                    *height = data[i+5]*256 + data[i+6];\n                    *width = data[i+7]*256 + data[i+8];\n                     return 0;\n                 }\n                 i+=2;\n                block_length = data[i] * 256 + data[i+1];\n             }\n         }\n     }\n\n    return -1;\n}\n", "target": 1, "idx": 182407}
{"func": "static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env,\n\t\t\t\t      struct bpf_insn *insn,\n\t\t\t\t      struct bpf_reg_state *dst_reg,\n\t\t\t\t      struct bpf_reg_state src_reg)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tu8 opcode = BPF_OP(insn->code);\n\tbool src_known, dst_known;\n\ts64 smin_val, smax_val;\n\tu64 umin_val, umax_val;\n \n \tif (BPF_CLASS(insn->code) != BPF_ALU64) {\n \t\t/* 32-bit ALU ops are (32,32)->64 */\n\t\tcoerce_reg_to_32(dst_reg);\n\t\tcoerce_reg_to_32(&src_reg);\n \t}\n \tsmin_val = src_reg.smin_value;\n \tsmax_val = src_reg.smax_value;\n\tumin_val = src_reg.umin_value;\n\tumax_val = src_reg.umax_value;\n\tsrc_known = tnum_is_const(src_reg.var_off);\n\tdst_known = tnum_is_const(dst_reg->var_off);\n\n\tswitch (opcode) {\n\tcase BPF_ADD:\n\t\tif (signed_add_overflows(dst_reg->smin_value, smin_val) ||\n\t\t    signed_add_overflows(dst_reg->smax_value, smax_val)) {\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value += smin_val;\n\t\t\tdst_reg->smax_value += smax_val;\n\t\t}\n\t\tif (dst_reg->umin_value + umin_val < umin_val ||\n\t\t    dst_reg->umax_value + umax_val < umax_val) {\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\tdst_reg->umin_value += umin_val;\n\t\t\tdst_reg->umax_value += umax_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_add(dst_reg->var_off, src_reg.var_off);\n\t\tbreak;\n\tcase BPF_SUB:\n\t\tif (signed_sub_overflows(dst_reg->smin_value, smax_val) ||\n\t\t    signed_sub_overflows(dst_reg->smax_value, smin_val)) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value -= smax_val;\n\t\t\tdst_reg->smax_value -= smin_val;\n\t\t}\n\t\tif (dst_reg->umin_value < umax_val) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\t/* Cannot overflow (as long as bounds are consistent) */\n\t\t\tdst_reg->umin_value -= umax_val;\n\t\t\tdst_reg->umax_value -= umin_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_sub(dst_reg->var_off, src_reg.var_off);\n\t\tbreak;\n\tcase BPF_MUL:\n\t\tdst_reg->var_off = tnum_mul(dst_reg->var_off, src_reg.var_off);\n\t\tif (smin_val < 0 || dst_reg->smin_value < 0) {\n\t\t\t/* Ain't nobody got time to multiply that sign */\n\t\t\t__mark_reg_unbounded(dst_reg);\n\t\t\t__update_reg_bounds(dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* Both values are positive, so we can work with unsigned and\n\t\t * copy the result to signed (unless it exceeds S64_MAX).\n\t\t */\n\t\tif (umax_val > U32_MAX || dst_reg->umax_value > U32_MAX) {\n\t\t\t/* Potential overflow, we know nothing */\n\t\t\t__mark_reg_unbounded(dst_reg);\n\t\t\t/* (except what we can learn from the var_off) */\n\t\t\t__update_reg_bounds(dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\tdst_reg->umin_value *= umin_val;\n\t\tdst_reg->umax_value *= umax_val;\n\t\tif (dst_reg->umax_value > S64_MAX) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\tbreak;\n\tcase BPF_AND:\n\t\tif (src_known && dst_known) {\n\t\t\t__mark_reg_known(dst_reg, dst_reg->var_off.value &\n\t\t\t\t\t\t  src_reg.var_off.value);\n\t\t\tbreak;\n\t\t}\n\t\t/* We get our minimum from the var_off, since that's inherently\n\t\t * bitwise.  Our maximum is the minimum of the operands' maxima.\n\t\t */\n\t\tdst_reg->var_off = tnum_and(dst_reg->var_off, src_reg.var_off);\n\t\tdst_reg->umin_value = dst_reg->var_off.value;\n\t\tdst_reg->umax_value = min(dst_reg->umax_value, umax_val);\n\t\tif (dst_reg->smin_value < 0 || smin_val < 0) {\n\t\t\t/* Lose signed bounds when ANDing negative numbers,\n\t\t\t * ain't nobody got time for that.\n\t\t\t */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\t/* ANDing two positives gives a positive, so safe to\n\t\t\t * cast result into s64.\n\t\t\t */\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_OR:\n\t\tif (src_known && dst_known) {\n\t\t\t__mark_reg_known(dst_reg, dst_reg->var_off.value |\n\t\t\t\t\t\t  src_reg.var_off.value);\n\t\t\tbreak;\n\t\t}\n\t\t/* We get our maximum from the var_off, and our minimum is the\n\t\t * maximum of the operands' minima\n\t\t */\n\t\tdst_reg->var_off = tnum_or(dst_reg->var_off, src_reg.var_off);\n\t\tdst_reg->umin_value = max(dst_reg->umin_value, umin_val);\n\t\tdst_reg->umax_value = dst_reg->var_off.value |\n\t\t\t\t      dst_reg->var_off.mask;\n\t\tif (dst_reg->smin_value < 0 || smin_val < 0) {\n\t\t\t/* Lose signed bounds when ORing negative numbers,\n\t\t\t * ain't nobody got time for that.\n\t\t\t */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\t/* ORing two positives gives a positive, so safe to\n\t\t\t * cast result into s64.\n\t\t\t */\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_LSH:\n\t\tif (umax_val > 63) {\n\t\t\t/* Shifts greater than 63 are undefined.  This includes\n\t\t\t * shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* We lose all sign bit information (except what we can pick\n\t\t * up from var_off)\n\t\t */\n\t\tdst_reg->smin_value = S64_MIN;\n\t\tdst_reg->smax_value = S64_MAX;\n\t\t/* If we might shift our top bit out, then we know nothing */\n\t\tif (dst_reg->umax_value > 1ULL << (63 - umax_val)) {\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\tdst_reg->umin_value <<= umin_val;\n\t\t\tdst_reg->umax_value <<= umax_val;\n\t\t}\n\t\tif (src_known)\n\t\t\tdst_reg->var_off = tnum_lshift(dst_reg->var_off, umin_val);\n\t\telse\n\t\t\tdst_reg->var_off = tnum_lshift(tnum_unknown, umin_val);\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_RSH:\n\t\tif (umax_val > 63) {\n\t\t\t/* Shifts greater than 63 are undefined.  This includes\n\t\t\t * shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* BPF_RSH is an unsigned shift.  If the value in dst_reg might\n\t\t * be negative, then either:\n\t\t * 1) src_reg might be zero, so the sign bit of the result is\n\t\t *    unknown, so we lose our signed bounds\n\t\t * 2) it's known negative, thus the unsigned bounds capture the\n\t\t *    signed bounds\n\t\t * 3) the signed bounds cross zero, so they tell us nothing\n\t\t *    about the result\n\t\t * If the value in dst_reg is known nonnegative, then again the\n\t\t * unsigned bounts capture the signed bounds.\n\t\t * Thus, in all cases it suffices to blow away our signed bounds\n\t\t * and rely on inferring new ones from the unsigned bounds and\n\t\t * var_off of the result.\n\t\t */\n\t\tdst_reg->smin_value = S64_MIN;\n\t\tdst_reg->smax_value = S64_MAX;\n\t\tif (src_known)\n\t\t\tdst_reg->var_off = tnum_rshift(dst_reg->var_off,\n\t\t\t\t\t\t       umin_val);\n\t\telse\n\t\t\tdst_reg->var_off = tnum_rshift(tnum_unknown, umin_val);\n\t\tdst_reg->umin_value >>= umax_val;\n\t\tdst_reg->umax_value >>= umin_val;\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tdefault:\n\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\tbreak;\n\t}\n\n\t__reg_deduce_bounds(dst_reg);\n\t__reg_bound_offset(dst_reg);\n\treturn 0;\n}\n", "target": 1, "idx": 180829}
{"func": "bool VaapiVideoDecodeAccelerator::VaapiH264Accelerator::SubmitFrameMetadata(\n    const H264SPS* sps,\n    const H264PPS* pps,\n    const H264DPB& dpb,\n    const H264Picture::Vector& ref_pic_listp0,\n     const H264Picture::Vector& ref_pic_listb0,\n     const H264Picture::Vector& ref_pic_listb1,\n     const scoped_refptr<H264Picture>& pic) {\n   VAPictureParameterBufferH264 pic_param;\n   memset(&pic_param, 0, sizeof(pic_param));\n \n#define FROM_SPS_TO_PP(a) pic_param.a = sps->a\n#define FROM_SPS_TO_PP2(a, b) pic_param.b = sps->a\n  FROM_SPS_TO_PP2(pic_width_in_mbs_minus1, picture_width_in_mbs_minus1);\n  FROM_SPS_TO_PP2(pic_height_in_map_units_minus1, picture_height_in_mbs_minus1);\n  FROM_SPS_TO_PP(bit_depth_luma_minus8);\n  FROM_SPS_TO_PP(bit_depth_chroma_minus8);\n#undef FROM_SPS_TO_PP\n#undef FROM_SPS_TO_PP2\n\n#define FROM_SPS_TO_PP_SF(a) pic_param.seq_fields.bits.a = sps->a\n#define FROM_SPS_TO_PP_SF2(a, b) pic_param.seq_fields.bits.b = sps->a\n  FROM_SPS_TO_PP_SF(chroma_format_idc);\n  FROM_SPS_TO_PP_SF2(separate_colour_plane_flag,\n                     residual_colour_transform_flag);\n  FROM_SPS_TO_PP_SF(gaps_in_frame_num_value_allowed_flag);\n  FROM_SPS_TO_PP_SF(frame_mbs_only_flag);\n  FROM_SPS_TO_PP_SF(mb_adaptive_frame_field_flag);\n  FROM_SPS_TO_PP_SF(direct_8x8_inference_flag);\n  pic_param.seq_fields.bits.MinLumaBiPredSize8x8 = (sps->level_idc >= 31);\n  FROM_SPS_TO_PP_SF(log2_max_frame_num_minus4);\n  FROM_SPS_TO_PP_SF(pic_order_cnt_type);\n  FROM_SPS_TO_PP_SF(log2_max_pic_order_cnt_lsb_minus4);\n  FROM_SPS_TO_PP_SF(delta_pic_order_always_zero_flag);\n#undef FROM_SPS_TO_PP_SF\n#undef FROM_SPS_TO_PP_SF2\n\n#define FROM_PPS_TO_PP(a) pic_param.a = pps->a\n  FROM_PPS_TO_PP(pic_init_qp_minus26);\n  FROM_PPS_TO_PP(pic_init_qs_minus26);\n  FROM_PPS_TO_PP(chroma_qp_index_offset);\n  FROM_PPS_TO_PP(second_chroma_qp_index_offset);\n#undef FROM_PPS_TO_PP\n\n#define FROM_PPS_TO_PP_PF(a) pic_param.pic_fields.bits.a = pps->a\n#define FROM_PPS_TO_PP_PF2(a, b) pic_param.pic_fields.bits.b = pps->a\n  FROM_PPS_TO_PP_PF(entropy_coding_mode_flag);\n  FROM_PPS_TO_PP_PF(weighted_pred_flag);\n  FROM_PPS_TO_PP_PF(weighted_bipred_idc);\n  FROM_PPS_TO_PP_PF(transform_8x8_mode_flag);\n\n  pic_param.pic_fields.bits.field_pic_flag = 0;\n  FROM_PPS_TO_PP_PF(constrained_intra_pred_flag);\n  FROM_PPS_TO_PP_PF2(bottom_field_pic_order_in_frame_present_flag,\n                     pic_order_present_flag);\n  FROM_PPS_TO_PP_PF(deblocking_filter_control_present_flag);\n  FROM_PPS_TO_PP_PF(redundant_pic_cnt_present_flag);\n  pic_param.pic_fields.bits.reference_pic_flag = pic->ref;\n#undef FROM_PPS_TO_PP_PF\n#undef FROM_PPS_TO_PP_PF2\n\n  pic_param.frame_num = pic->frame_num;\n\n  InitVAPicture(&pic_param.CurrPic);\n  FillVAPicture(&pic_param.CurrPic, pic);\n\n  for (int i = 0; i < 16; ++i)\n    InitVAPicture(&pic_param.ReferenceFrames[i]);\n\n  FillVARefFramesFromDPB(dpb, pic_param.ReferenceFrames,\n                         arraysize(pic_param.ReferenceFrames));\n\n  pic_param.num_ref_frames = sps->max_num_ref_frames;\n\n  if (!vaapi_wrapper_->SubmitBuffer(VAPictureParameterBufferType,\n                                    sizeof(pic_param), &pic_param))\n    return false;\n\n  VAIQMatrixBufferH264 iq_matrix_buf;\n  memset(&iq_matrix_buf, 0, sizeof(iq_matrix_buf));\n\n  if (pps->pic_scaling_matrix_present_flag) {\n    for (int i = 0; i < 6; ++i) {\n      for (int j = 0; j < 16; ++j)\n        iq_matrix_buf.ScalingList4x4[i][kZigzagScan4x4[j]] =\n            pps->scaling_list4x4[i][j];\n    }\n\n    for (int i = 0; i < 2; ++i) {\n      for (int j = 0; j < 64; ++j)\n        iq_matrix_buf.ScalingList8x8[i][kZigzagScan8x8[j]] =\n            pps->scaling_list8x8[i][j];\n    }\n  } else {\n    for (int i = 0; i < 6; ++i) {\n      for (int j = 0; j < 16; ++j)\n        iq_matrix_buf.ScalingList4x4[i][kZigzagScan4x4[j]] =\n            sps->scaling_list4x4[i][j];\n    }\n\n    for (int i = 0; i < 2; ++i) {\n      for (int j = 0; j < 64; ++j)\n        iq_matrix_buf.ScalingList8x8[i][kZigzagScan8x8[j]] =\n            sps->scaling_list8x8[i][j];\n    }\n  }\n\n  return vaapi_wrapper_->SubmitBuffer(VAIQMatrixBufferType,\n                                      sizeof(iq_matrix_buf), &iq_matrix_buf);\n}\n", "target": 1, "idx": 186788}
{"func": "void RenderFrameImpl::FrameFocused() {\n  Send(new FrameHostMsg_FrameFocused(routing_id_));\n}\n", "target": 0, "idx": 152319}
{"func": "icmp_print(netdissect_options *ndo, const u_char *bp, u_int plen, const u_char *bp2,\n           int fragmented)\n{\n\tchar *cp;\n\tconst struct icmp *dp;\n        const struct icmp_ext_t *ext_dp;\n\tconst struct ip *ip;\n\tconst char *str, *fmt;\n\tconst struct ip *oip;\n\tconst struct udphdr *ouh;\n        const uint8_t *obj_tptr;\n        uint32_t raw_label;\n        const u_char *snapend_save;\n\tconst struct icmp_mpls_ext_object_header_t *icmp_mpls_ext_object_header;\n\tu_int hlen, dport, mtu, obj_tlen, obj_class_num, obj_ctype;\n\tchar buf[MAXHOSTNAMELEN + 100];\n\tstruct cksum_vec vec[1];\n\n\tdp = (const struct icmp *)bp;\n        ext_dp = (const struct icmp_ext_t *)bp;\n\tip = (const struct ip *)bp2;\n\tstr = buf;\n\n\tND_TCHECK(dp->icmp_code);\n\tswitch (dp->icmp_type) {\n\n\tcase ICMP_ECHO:\n\tcase ICMP_ECHOREPLY:\n\t\tND_TCHECK(dp->icmp_seq);\n\t\t(void)snprintf(buf, sizeof(buf), \"echo %s, id %u, seq %u\",\n                               dp->icmp_type == ICMP_ECHO ?\n                               \"request\" : \"reply\",\n                               EXTRACT_16BITS(&dp->icmp_id),\n                               EXTRACT_16BITS(&dp->icmp_seq));\n\t\tbreak;\n\n\tcase ICMP_UNREACH:\n\t\tND_TCHECK(dp->icmp_ip.ip_dst);\n\t\tswitch (dp->icmp_code) {\n\n\t\tcase ICMP_UNREACH_PROTOCOL:\n\t\t\tND_TCHECK(dp->icmp_ip.ip_p);\n\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t    \"%s protocol %d unreachable\",\n\t\t\t    ipaddr_string(ndo, &dp->icmp_ip.ip_dst),\n\t\t\t    dp->icmp_ip.ip_p);\n\t\t\tbreak;\n\n\t\tcase ICMP_UNREACH_PORT:\n\t\t\tND_TCHECK(dp->icmp_ip.ip_p);\n\t\t\toip = &dp->icmp_ip;\n\t\t\thlen = IP_HL(oip) * 4;\n\t\t\touh = (const struct udphdr *)(((const u_char *)oip) + hlen);\n\t\t\tND_TCHECK(ouh->uh_dport);\n\t\t\tdport = EXTRACT_16BITS(&ouh->uh_dport);\n\t\t\tswitch (oip->ip_p) {\n\n\t\t\tcase IPPROTO_TCP:\n\t\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t\t\t\"%s tcp port %s unreachable\",\n\t\t\t\t\tipaddr_string(ndo, &oip->ip_dst),\n\t\t\t\t\ttcpport_string(ndo, dport));\n\t\t\t\tbreak;\n\n\t\t\tcase IPPROTO_UDP:\n\t\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t\t\t\"%s udp port %s unreachable\",\n\t\t\t\t\tipaddr_string(ndo, &oip->ip_dst),\n\t\t\t\t\tudpport_string(ndo, dport));\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t\t\t\"%s protocol %d port %d unreachable\",\n\t\t\t\t\tipaddr_string(ndo, &oip->ip_dst),\n\t\t\t\t\toip->ip_p, dport);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ICMP_UNREACH_NEEDFRAG:\n\t\t    {\n\t\t\tregister const struct mtu_discovery *mp;\n\t\t\tmp = (const struct mtu_discovery *)(const u_char *)&dp->icmp_void;\n\t\t\tmtu = EXTRACT_16BITS(&mp->nexthopmtu);\n\t\t\tif (mtu) {\n\t\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t\t    \"%s unreachable - need to frag (mtu %d)\",\n\t\t\t\t    ipaddr_string(ndo, &dp->icmp_ip.ip_dst), mtu);\n\t\t\t} else {\n\t\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t\t    \"%s unreachable - need to frag\",\n\t\t\t\t    ipaddr_string(ndo, &dp->icmp_ip.ip_dst));\n\t\t\t}\n\t\t    }\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfmt = tok2str(unreach2str, \"#%d %%s unreachable\",\n\t\t\t    dp->icmp_code);\n\t\t\t(void)snprintf(buf, sizeof(buf), fmt,\n\t\t\t    ipaddr_string(ndo, &dp->icmp_ip.ip_dst));\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase ICMP_REDIRECT:\n\t\tND_TCHECK(dp->icmp_ip.ip_dst);\n\t\tfmt = tok2str(type2str, \"redirect-#%d %%s to net %%s\",\n\t\t    dp->icmp_code);\n\t\t(void)snprintf(buf, sizeof(buf), fmt,\n\t\t    ipaddr_string(ndo, &dp->icmp_ip.ip_dst),\n\t\t    ipaddr_string(ndo, &dp->icmp_gwaddr));\n\t\tbreak;\n\n\tcase ICMP_ROUTERADVERT:\n\t    {\n\t\tregister const struct ih_rdiscovery *ihp;\n\t\tregister const struct id_rdiscovery *idp;\n\t\tu_int lifetime, num, size;\n\n\t\t(void)snprintf(buf, sizeof(buf), \"router advertisement\");\n\t\tcp = buf + strlen(buf);\n\n\t\tihp = (const struct ih_rdiscovery *)&dp->icmp_void;\n\t\tND_TCHECK(*ihp);\n\t\t(void)strncpy(cp, \" lifetime \", sizeof(buf) - (cp - buf));\n\t\tcp = buf + strlen(buf);\n\t\tlifetime = EXTRACT_16BITS(&ihp->ird_lifetime);\n\t\tif (lifetime < 60) {\n\t\t\t(void)snprintf(cp, sizeof(buf) - (cp - buf), \"%u\",\n\t\t\t    lifetime);\n\t\t} else if (lifetime < 60 * 60) {\n\t\t\t(void)snprintf(cp, sizeof(buf) - (cp - buf), \"%u:%02u\",\n\t\t\t    lifetime / 60, lifetime % 60);\n\t\t} else {\n\t\t\t(void)snprintf(cp, sizeof(buf) - (cp - buf),\n\t\t\t    \"%u:%02u:%02u\",\n\t\t\t    lifetime / 3600,\n\t\t\t    (lifetime % 3600) / 60,\n\t\t\t    lifetime % 60);\n\t\t}\n\t\tcp = buf + strlen(buf);\n\n\t\tnum = ihp->ird_addrnum;\n\t\t(void)snprintf(cp, sizeof(buf) - (cp - buf), \" %d:\", num);\n\t\tcp = buf + strlen(buf);\n\n\t\tsize = ihp->ird_addrsiz;\n\t\tif (size != 2) {\n\t\t\t(void)snprintf(cp, sizeof(buf) - (cp - buf),\n\t\t\t    \" [size %d]\", size);\n\t\t\tbreak;\n\t\t}\n\t\tidp = (const struct id_rdiscovery *)&dp->icmp_data;\n\t\twhile (num-- > 0) {\n\t\t\tND_TCHECK(*idp);\n\t\t\t(void)snprintf(cp, sizeof(buf) - (cp - buf), \" {%s %u}\",\n\t\t\t    ipaddr_string(ndo, &idp->ird_addr),\n\t\t\t    EXTRACT_32BITS(&idp->ird_pref));\n\t\t\tcp = buf + strlen(buf);\n\t\t\t++idp;\n\t\t}\n\t    }\n\t\tbreak;\n\n\tcase ICMP_TIMXCEED:\n\t\tND_TCHECK(dp->icmp_ip.ip_dst);\n\t\tswitch (dp->icmp_code) {\n\n\t\tcase ICMP_TIMXCEED_INTRANS:\n\t\t\tstr = \"time exceeded in-transit\";\n\t\t\tbreak;\n\n\t\tcase ICMP_TIMXCEED_REASS:\n\t\t\tstr = \"ip reassembly time exceeded\";\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t(void)snprintf(buf, sizeof(buf), \"time exceeded-#%d\",\n\t\t\t    dp->icmp_code);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase ICMP_PARAMPROB:\n\t\tif (dp->icmp_code)\n\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t    \"parameter problem - code %d\", dp->icmp_code);\n\t\telse {\n\t\t\tND_TCHECK(dp->icmp_pptr);\n\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t    \"parameter problem - octet %d\", dp->icmp_pptr);\n\t\t}\n\t\tbreak;\n\n\tcase ICMP_MASKREPLY:\n\t\tND_TCHECK(dp->icmp_mask);\n\t\t(void)snprintf(buf, sizeof(buf), \"address mask is 0x%08x\",\n\t\t    EXTRACT_32BITS(&dp->icmp_mask));\n\t\tbreak;\n\n\tcase ICMP_TSTAMP:\n\t\tND_TCHECK(dp->icmp_seq);\n\t\t(void)snprintf(buf, sizeof(buf),\n\t\t    \"time stamp query id %u seq %u\",\n\t\t    EXTRACT_16BITS(&dp->icmp_id),\n\t\t    EXTRACT_16BITS(&dp->icmp_seq));\n\t\tbreak;\n\n\tcase ICMP_TSTAMPREPLY:\n\t\tND_TCHECK(dp->icmp_ttime);\n\t\t(void)snprintf(buf, sizeof(buf),\n\t\t    \"time stamp reply id %u seq %u: org %s\",\n                               EXTRACT_16BITS(&dp->icmp_id),\n                               EXTRACT_16BITS(&dp->icmp_seq),\n                               icmp_tstamp_print(EXTRACT_32BITS(&dp->icmp_otime)));\n\n                (void)snprintf(buf+strlen(buf),sizeof(buf)-strlen(buf),\", recv %s\",\n                         icmp_tstamp_print(EXTRACT_32BITS(&dp->icmp_rtime)));\n                (void)snprintf(buf+strlen(buf),sizeof(buf)-strlen(buf),\", xmit %s\",\n                         icmp_tstamp_print(EXTRACT_32BITS(&dp->icmp_ttime)));\n                break;\n\n\tdefault:\n\t\tstr = tok2str(icmp2str, \"type-#%d\", dp->icmp_type);\n\t\tbreak;\n\t}\n\tND_PRINT((ndo, \"ICMP %s, length %u\", str, plen));\n\tif (ndo->ndo_vflag && !fragmented) { /* don't attempt checksumming if this is a frag */\n\t\tuint16_t sum, icmp_sum;\n\n\t\tif (ND_TTEST2(*bp, plen)) {\n\t\t\tvec[0].ptr = (const uint8_t *)(const void *)dp;\n\t\t\tvec[0].len = plen;\n\t\t\tsum = in_cksum(vec, 1);\n\t\t\tif (sum != 0) {\n\t\t\t\ticmp_sum = EXTRACT_16BITS(&dp->icmp_cksum);\n\t\t\t\tND_PRINT((ndo, \" (wrong icmp cksum %x (->%x)!)\",\n\t\t\t\t\t     icmp_sum,\n\t\t\t\t\t     in_cksum_shouldbe(icmp_sum, sum)));\n\t\t\t}\n\t\t}\n\t}\n\n        /*\n         * print the remnants of the IP packet.\n         * save the snaplength as this may get overidden in the IP printer.\n         */\n\tif (ndo->ndo_vflag >= 1 && ICMP_ERRTYPE(dp->icmp_type)) {\n\t\tbp += 8;\n \t\tND_PRINT((ndo, \"\\n\\t\"));\n \t\tip = (const struct ip *)bp;\n                 snapend_save = ndo->ndo_snapend;\n \t\tip_print(ndo, bp, EXTRACT_16BITS(&ip->ip_len));\n                 ndo->ndo_snapend = snapend_save;\n \t}\n\n        /*\n         * Attempt to decode the MPLS extensions only for some ICMP types.\n         */\n        if (ndo->ndo_vflag >= 1 && plen > ICMP_EXTD_MINLEN && ICMP_MPLS_EXT_TYPE(dp->icmp_type)) {\n\n            ND_TCHECK(*ext_dp);\n\n            /*\n             * Check first if the mpls extension header shows a non-zero length.\n             * If the length field is not set then silently verify the checksum\n             * to check if an extension header is present. This is expedient,\n             * however not all implementations set the length field proper.\n             */\n            if (!ext_dp->icmp_length &&\n                ND_TTEST2(ext_dp->icmp_ext_version_res, plen - ICMP_EXTD_MINLEN)) {\n                vec[0].ptr = (const uint8_t *)(const void *)&ext_dp->icmp_ext_version_res;\n                vec[0].len = plen - ICMP_EXTD_MINLEN;\n                if (in_cksum(vec, 1)) {\n                    return;\n                }\n            }\n\n            ND_PRINT((ndo, \"\\n\\tMPLS extension v%u\",\n                   ICMP_MPLS_EXT_EXTRACT_VERSION(*(ext_dp->icmp_ext_version_res))));\n\n            /*\n             * Sanity checking of the header.\n             */\n            if (ICMP_MPLS_EXT_EXTRACT_VERSION(*(ext_dp->icmp_ext_version_res)) !=\n                ICMP_MPLS_EXT_VERSION) {\n                ND_PRINT((ndo, \" packet not supported\"));\n                return;\n            }\n\n            hlen = plen - ICMP_EXTD_MINLEN;\n            if (ND_TTEST2(ext_dp->icmp_ext_version_res, hlen)) {\n                vec[0].ptr = (const uint8_t *)(const void *)&ext_dp->icmp_ext_version_res;\n                vec[0].len = hlen;\n                ND_PRINT((ndo, \", checksum 0x%04x (%scorrect), length %u\",\n                       EXTRACT_16BITS(ext_dp->icmp_ext_checksum),\n                       in_cksum(vec, 1) ? \"in\" : \"\",\n                       hlen));\n            }\n\n            hlen -= 4; /* subtract common header size */\n            obj_tptr = (const uint8_t *)ext_dp->icmp_ext_data;\n\n            while (hlen > sizeof(struct icmp_mpls_ext_object_header_t)) {\n\n                icmp_mpls_ext_object_header = (const struct icmp_mpls_ext_object_header_t *)obj_tptr;\n                ND_TCHECK(*icmp_mpls_ext_object_header);\n                obj_tlen = EXTRACT_16BITS(icmp_mpls_ext_object_header->length);\n                obj_class_num = icmp_mpls_ext_object_header->class_num;\n                obj_ctype = icmp_mpls_ext_object_header->ctype;\n                obj_tptr += sizeof(struct icmp_mpls_ext_object_header_t);\n\n                ND_PRINT((ndo, \"\\n\\t  %s Object (%u), Class-Type: %u, length %u\",\n                       tok2str(icmp_mpls_ext_obj_values,\"unknown\",obj_class_num),\n                       obj_class_num,\n                       obj_ctype,\n                       obj_tlen));\n\n                hlen-=sizeof(struct icmp_mpls_ext_object_header_t); /* length field includes tlv header */\n\n                /* infinite loop protection */\n                if ((obj_class_num == 0) ||\n                    (obj_tlen < sizeof(struct icmp_mpls_ext_object_header_t))) {\n                    return;\n                }\n                obj_tlen-=sizeof(struct icmp_mpls_ext_object_header_t);\n\n                switch (obj_class_num) {\n                case 1:\n                    switch(obj_ctype) {\n                    case 1:\n                        ND_TCHECK2(*obj_tptr, 4);\n                        raw_label = EXTRACT_32BITS(obj_tptr);\n                        ND_PRINT((ndo, \"\\n\\t    label %u, exp %u\", MPLS_LABEL(raw_label), MPLS_EXP(raw_label)));\n                        if (MPLS_STACK(raw_label))\n                            ND_PRINT((ndo, \", [S]\"));\n                        ND_PRINT((ndo, \", ttl %u\", MPLS_TTL(raw_label)));\n                        break;\n                    default:\n                        print_unknown_data(ndo, obj_tptr, \"\\n\\t    \", obj_tlen);\n                    }\n                    break;\n\n               /*\n                *  FIXME those are the defined objects that lack a decoder\n                *  you are welcome to contribute code ;-)\n                */\n                case 2:\n                default:\n                    print_unknown_data(ndo, obj_tptr, \"\\n\\t    \", obj_tlen);\n                    break;\n                }\n                if (hlen < obj_tlen)\n                    break;\n                hlen -= obj_tlen;\n                obj_tptr += obj_tlen;\n            }\n        }\n\n\treturn;\ntrunc:\n\tND_PRINT((ndo, \"[|icmp]\"));\n}\n", "target": 1, "idx": 181054}
{"func": "static int raw_cmd_copyin(int cmd, void __user *param,\n\t\t\t\t struct floppy_raw_cmd **rcmd)\n{\n\tstruct floppy_raw_cmd *ptr;\n\tint ret;\n\tint i;\n\n\t*rcmd = NULL;\n\nloop:\n\tptr = kmalloc(sizeof(struct floppy_raw_cmd), GFP_USER);\n\tif (!ptr)\n \t\treturn -ENOMEM;\n \t*rcmd = ptr;\n \tret = copy_from_user(ptr, param, sizeof(*ptr));\n\tif (ret)\n\t\treturn -EFAULT;\n \tptr->next = NULL;\n \tptr->buffer_length = 0;\n \tparam += sizeof(struct floppy_raw_cmd);\n \tif (ptr->cmd_count > 33)\n \t\t\t/* the command may now also take up the space\n\t\t\t * initially intended for the reply & the\n\t\t\t * reply count. Needed for long 82078 commands\n\t\t\t * such as RESTORE, which takes ... 17 command\n\t\t\t * bytes. Murphy's law #137: When you reserve\n\t\t\t * 16 bytes for a structure, you'll one day\n\t\t\t * discover that you really need 17...\n\t\t\t */\n\t\treturn -EINVAL;\n\n \tfor (i = 0; i < 16; i++)\n \t\tptr->reply[i] = 0;\n \tptr->resultcode = 0;\n\tptr->kernel_data = NULL;\n \n \tif (ptr->flags & (FD_RAW_READ | FD_RAW_WRITE)) {\n \t\tif (ptr->length <= 0)\n\t\t\treturn -EINVAL;\n\t\tptr->kernel_data = (char *)fd_dma_mem_alloc(ptr->length);\n\t\tfallback_on_nodma_alloc(&ptr->kernel_data, ptr->length);\n\t\tif (!ptr->kernel_data)\n\t\t\treturn -ENOMEM;\n\t\tptr->buffer_length = ptr->length;\n\t}\n\tif (ptr->flags & FD_RAW_WRITE) {\n\t\tret = fd_copyin(ptr->data, ptr->kernel_data, ptr->length);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (ptr->flags & FD_RAW_MORE) {\n\t\trcmd = &(ptr->next);\n\t\tptr->rate &= 0x43;\n\t\tgoto loop;\n\t}\n\n\treturn 0;\n}\n", "target": 1, "idx": 179607}
{"func": "IDNConversionResult IDNToUnicodeWithAdjustmentsImpl(\n    base::StringPiece host,\n    base::OffsetAdjuster::Adjustments* adjustments,\n    bool enable_spoof_checks) {\n  if (adjustments)\n    adjustments->clear();\n  base::string16 input16;\n   input16.reserve(host.length());\n   input16.insert(input16.end(), host.begin(), host.end());\n \n  bool is_tld_ascii = true;\n   size_t last_dot = host.rfind('.');\n  if (last_dot != base::StringPiece::npos &&\n      host.substr(last_dot).starts_with(\".xn--\")) {\n    is_tld_ascii = false;\n   }\n \n   IDNConversionResult result;\n  base::string16 out16;\n  for (size_t component_start = 0, component_end;\n       component_start < input16.length();\n       component_start = component_end + 1) {\n    component_end = input16.find('.', component_start);\n    if (component_end == base::string16::npos)\n      component_end = input16.length();  // For getting the last component.\n    size_t component_length = component_end - component_start;\n    size_t new_component_start = out16.length();\n    bool converted_idn = false;\n    if (component_end > component_start) {\n       bool has_idn_component = false;\n       converted_idn = IDNToUnicodeOneComponent(\n          input16.data() + component_start, component_length, is_tld_ascii,\n           enable_spoof_checks, &out16, &has_idn_component);\n       result.has_idn_component |= has_idn_component;\n     }\n    size_t new_component_length = out16.length() - new_component_start;\n\n    if (converted_idn && adjustments) {\n      adjustments->push_back(base::OffsetAdjuster::Adjustment(\n          component_start, component_length, new_component_length));\n    }\n\n    if (component_end < input16.length())\n      out16.push_back('.');\n  }\n\n  result.result = out16;\n\n  if (result.has_idn_component) {\n    result.matching_top_domain =\n        g_idn_spoof_checker.Get().GetSimilarTopDomain(out16);\n    if (enable_spoof_checks && !result.matching_top_domain.domain.empty()) {\n      if (adjustments)\n        adjustments->clear();\n      result.result = input16;\n    }\n  }\n\n  return result;\n}\n", "target": 1, "idx": 186706}
{"func": "void DevToolsWindow::Inspect(scoped_refptr<content::DevToolsAgentHost> host) {\n  DevToolsWindow::OpenDevToolsWindow(host, profile_);\n}\n", "target": 0, "idx": 151077}
{"func": " void CastCastView::ButtonPressed(views::Button* sender,\n                                  const ui::Event& event) {\n   DCHECK(sender == stop_button_);\n  StopCast();\n }\n", "target": 1, "idx": 185326}
{"func": " chdlc_print(netdissect_options *ndo, register const u_char *p, u_int length)\n {\n \tu_int proto;\n \n \tproto = EXTRACT_16BITS(&p[2]);\n \tif (ndo->ndo_eflag) {\n                 ND_PRINT((ndo, \"%s, ethertype %s (0x%04x), length %u: \",\n                       tok2str(chdlc_cast_values, \"0x%02x\", p[0]),\n                       tok2str(ethertype_values, \"Unknown\", proto),\n                       proto,\n                       length));\n\t}\n\n\tlength -= CHDLC_HDRLEN;\n\tp += CHDLC_HDRLEN;\n\n\tswitch (proto) {\n\tcase ETHERTYPE_IP:\n\t\tip_print(ndo, p, length);\n\t\tbreak;\n\tcase ETHERTYPE_IPV6:\n\t\tip6_print(ndo, p, length);\n\t\tbreak;\n\tcase CHDLC_TYPE_SLARP:\n\t\tchdlc_slarp_print(ndo, p, length);\n\t\tbreak;\n#if 0\n\tcase CHDLC_TYPE_CDP:\n\t\tchdlc_cdp_print(p, length);\n\t\tbreak;\n#endif\n        case ETHERTYPE_MPLS:\n        case ETHERTYPE_MPLS_MULTI:\n                mpls_print(ndo, p, length);\n \t\tbreak;\n         case ETHERTYPE_ISO:\n                 /* is the fudge byte set ? lets verify by spotting ISO headers */\n                 if (*(p+1) == 0x81 ||\n                     *(p+1) == 0x82 ||\n                     *(p+1) == 0x83)\n                    isoclns_print(ndo, p + 1, length - 1, ndo->ndo_snapend - p - 1);\n                else\n                    isoclns_print(ndo, p, length, ndo->ndo_snapend - p);\n                break;\n\tdefault:\n                if (!ndo->ndo_eflag)\n                        ND_PRINT((ndo, \"unknown CHDLC protocol (0x%04x)\", proto));\n                break;\n \t}\n \n \treturn (CHDLC_HDRLEN);\n }\n", "target": 1, "idx": 183194}
{"func": "void WebContentsImpl::RenderViewForInterstitialPageCreated(\n    RenderViewHost* render_view_host) {\n  FOR_EACH_OBSERVER(WebContentsObserver, observers_,\n                    RenderViewForInterstitialPageCreated(render_view_host));\n}\n", "target": 0, "idx": 119012}
{"func": "bool UnprivilegedProcessDelegate::CreateConnectedIpcChannel(\n    const std::string& channel_name,\n    IPC::Listener* delegate,\n    ScopedHandle* client_out,\n    scoped_ptr<IPC::ChannelProxy>* server_out) {\n  scoped_ptr<IPC::ChannelProxy> server;\n  if (!CreateIpcChannel(channel_name, kDaemonIpcSecurityDescriptor,\n                        io_task_runner_, delegate, &server)) {\n    return false;\n  }\n  std::string pipe_name(kChromePipeNamePrefix);\n  pipe_name.append(channel_name);\n  SECURITY_ATTRIBUTES security_attributes;\n  security_attributes.nLength = sizeof(security_attributes);\n  security_attributes.lpSecurityDescriptor = NULL;\n  security_attributes.bInheritHandle = TRUE;\n  ScopedHandle client;\n  client.Set(CreateFile(UTF8ToUTF16(pipe_name).c_str(),\n                        GENERIC_READ | GENERIC_WRITE,\n                        0,\n                        &security_attributes,\n                        OPEN_EXISTING,\n                        SECURITY_SQOS_PRESENT | SECURITY_IDENTIFICATION |\n                            FILE_FLAG_OVERLAPPED,\n                        NULL));\n  if (!client.IsValid())\n    return false;\n  *client_out = client.Pass();\n  *server_out = server.Pass();\n  return true;\n}\n", "target": 1, "idx": 185247}
{"func": "static void rxrpc_destroy(struct key *key)\n{\n\trxrpc_free_token_list(key->payload.data);\n}\n", "target": 0, "idx": 69500}
{"func": "static int devicenrange(i_ctx_t * i_ctx_p, ref *space, float *ptr)\n{\n    int i, limit, code;\n    PS_colour_space_t *cspace;\n\n    ref altspace;\n\n    code = array_get(imemory, space, 1, &altspace);\n    if (code < 0)\n        return code;\n\n    code = get_space_object(i_ctx_p, &altspace, &cspace);\n    if (code < 0)\n        return code;\n\n    code = cspace->numcomponents(i_ctx_p, &altspace, &limit);\n    if (code < 0)\n        return code;\n\n    for (i = 0;i < limit * 2;i+=2) {\n        ptr[i] = 0;\n        ptr[i+1] = 1;\n    }\n    return 0;\n}\n", "target": 0, "idx": 3069}
{"func": "gboolean Shell::OnWindowDestroyed(GtkWidget* window) {\n  delete this;\n  return FALSE;  // Don't stop this message.\n}\n", "target": 0, "idx": 108596}
{"func": "rfc4106_set_hash_subkey(u8 *hash_subkey, const u8 *key, unsigned int key_len)\n{\n\tstruct crypto_ablkcipher *ctr_tfm;\n\tstruct ablkcipher_request *req;\n\tint ret = -EINVAL;\n\tstruct aesni_hash_subkey_req_data *req_data;\n\n\tctr_tfm = crypto_alloc_ablkcipher(\"ctr(aes)\", 0, 0);\n\tif (IS_ERR(ctr_tfm))\n\t\treturn PTR_ERR(ctr_tfm);\n\n\tcrypto_ablkcipher_clear_flags(ctr_tfm, ~0);\n\n\tret = crypto_ablkcipher_setkey(ctr_tfm, key, key_len);\n\tif (ret)\n\t\tgoto out_free_ablkcipher;\n\n\tret = -ENOMEM;\n\treq = ablkcipher_request_alloc(ctr_tfm, GFP_KERNEL);\n\tif (!req)\n\t\tgoto out_free_ablkcipher;\n\n\treq_data = kmalloc(sizeof(*req_data), GFP_KERNEL);\n\tif (!req_data)\n\t\tgoto out_free_request;\n\n\tmemset(req_data->iv, 0, sizeof(req_data->iv));\n\n\t/* Clear the data in the hash sub key container to zero.*/\n\t/* We want to cipher all zeros to create the hash sub key. */\n\tmemset(hash_subkey, 0, RFC4106_HASH_SUBKEY_SIZE);\n\n\tinit_completion(&req_data->result.completion);\n\tsg_init_one(&req_data->sg, hash_subkey, RFC4106_HASH_SUBKEY_SIZE);\n\tablkcipher_request_set_tfm(req, ctr_tfm);\n\tablkcipher_request_set_callback(req, CRYPTO_TFM_REQ_MAY_SLEEP |\n\t\t\t\t\tCRYPTO_TFM_REQ_MAY_BACKLOG,\n\t\t\t\t\trfc4106_set_hash_subkey_done,\n\t\t\t\t\t&req_data->result);\n\n\tablkcipher_request_set_crypt(req, &req_data->sg,\n\t\t&req_data->sg, RFC4106_HASH_SUBKEY_SIZE, req_data->iv);\n\n\tret = crypto_ablkcipher_encrypt(req);\n\tif (ret == -EINPROGRESS || ret == -EBUSY) {\n\t\tret = wait_for_completion_interruptible\n\t\t\t(&req_data->result.completion);\n\t\tif (!ret)\n\t\t\tret = req_data->result.err;\n\t}\n\tkfree(req_data);\nout_free_request:\n\tablkcipher_request_free(req);\nout_free_ablkcipher:\n\tcrypto_free_ablkcipher(ctr_tfm);\n\treturn ret;\n}\n", "target": 0, "idx": 43492}
{"func": "xmlXPathCompRelationalExpr(xmlXPathParserContextPtr ctxt) {\n    xmlXPathCompAdditiveExpr(ctxt);\n    CHECK_ERROR;\n    SKIP_BLANKS;\n    while ((CUR == '<') ||\n           (CUR == '>') ||\n           ((CUR == '<') && (NXT(1) == '=')) ||\n           ((CUR == '>') && (NXT(1) == '='))) {\n\tint inf, strict;\n\tint op1 = ctxt->comp->last;\n\n        if (CUR == '<') inf = 1;\n\telse inf = 0;\n\tif (NXT(1) == '=') strict = 0;\n\telse strict = 1;\n\tNEXT;\n\tif (!strict) NEXT;\n\tSKIP_BLANKS;\n        xmlXPathCompAdditiveExpr(ctxt);\n\tCHECK_ERROR;\n\tPUSH_BINARY_EXPR(XPATH_OP_CMP, op1, ctxt->comp->last, inf, strict);\n\tSKIP_BLANKS;\n    }\n}\n", "target": 0, "idx": 97616}
{"func": "int hugetlb_fault(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\t\tunsigned long address, unsigned int flags)\n{\n\tpte_t *ptep, entry;\n\tspinlock_t *ptl;\n\tint ret;\n\tu32 hash;\n\tpgoff_t idx;\n\tstruct page *page = NULL;\n\tstruct page *pagecache_page = NULL;\n\tstruct hstate *h = hstate_vma(vma);\n\tstruct address_space *mapping;\n\tint need_wait_lock = 0;\n\n\taddress &= huge_page_mask(h);\n\n\tptep = huge_pte_offset(mm, address, huge_page_size(h));\n\tif (ptep) {\n\t\tentry = huge_ptep_get(ptep);\n\t\tif (unlikely(is_hugetlb_entry_migration(entry))) {\n\t\t\tmigration_entry_wait_huge(vma, mm, ptep);\n\t\t\treturn 0;\n\t\t} else if (unlikely(is_hugetlb_entry_hwpoisoned(entry)))\n\t\t\treturn VM_FAULT_HWPOISON_LARGE |\n\t\t\t\tVM_FAULT_SET_HINDEX(hstate_index(h));\n\t} else {\n\t\tptep = huge_pte_alloc(mm, address, huge_page_size(h));\n\t\tif (!ptep)\n\t\t\treturn VM_FAULT_OOM;\n\t}\n\n\tmapping = vma->vm_file->f_mapping;\n\tidx = vma_hugecache_offset(h, vma, address);\n\n\t/*\n\t * Serialize hugepage allocation and instantiation, so that we don't\n\t * get spurious allocation failures if two CPUs race to instantiate\n\t * the same page in the page cache.\n\t */\n\thash = hugetlb_fault_mutex_hash(h, mm, vma, mapping, idx, address);\n\tmutex_lock(&hugetlb_fault_mutex_table[hash]);\n\n\tentry = huge_ptep_get(ptep);\n\tif (huge_pte_none(entry)) {\n\t\tret = hugetlb_no_page(mm, vma, mapping, idx, address, ptep, flags);\n\t\tgoto out_mutex;\n\t}\n\n\tret = 0;\n\n\t/*\n\t * entry could be a migration/hwpoison entry at this point, so this\n\t * check prevents the kernel from going below assuming that we have\n\t * a active hugepage in pagecache. This goto expects the 2nd page fault,\n\t * and is_hugetlb_entry_(migration|hwpoisoned) check will properly\n\t * handle it.\n\t */\n\tif (!pte_present(entry))\n\t\tgoto out_mutex;\n\n\t/*\n\t * If we are going to COW the mapping later, we examine the pending\n\t * reservations for this page now. This will ensure that any\n\t * allocations necessary to record that reservation occur outside the\n\t * spinlock. For private mappings, we also lookup the pagecache\n\t * page now as it is used to determine if a reservation has been\n\t * consumed.\n\t */\n\tif ((flags & FAULT_FLAG_WRITE) && !huge_pte_write(entry)) {\n\t\tif (vma_needs_reservation(h, vma, address) < 0) {\n\t\t\tret = VM_FAULT_OOM;\n\t\t\tgoto out_mutex;\n\t\t}\n\t\t/* Just decrements count, does not deallocate */\n\t\tvma_end_reservation(h, vma, address);\n\n\t\tif (!(vma->vm_flags & VM_MAYSHARE))\n\t\t\tpagecache_page = hugetlbfs_pagecache_page(h,\n\t\t\t\t\t\t\t\tvma, address);\n\t}\n\n\tptl = huge_pte_lock(h, mm, ptep);\n\n\t/* Check for a racing update before calling hugetlb_cow */\n\tif (unlikely(!pte_same(entry, huge_ptep_get(ptep))))\n\t\tgoto out_ptl;\n\n\t/*\n\t * hugetlb_cow() requires page locks of pte_page(entry) and\n\t * pagecache_page, so here we need take the former one\n\t * when page != pagecache_page or !pagecache_page.\n\t */\n\tpage = pte_page(entry);\n\tif (page != pagecache_page)\n\t\tif (!trylock_page(page)) {\n\t\t\tneed_wait_lock = 1;\n\t\t\tgoto out_ptl;\n\t\t}\n\n\tget_page(page);\n\n\tif (flags & FAULT_FLAG_WRITE) {\n\t\tif (!huge_pte_write(entry)) {\n\t\t\tret = hugetlb_cow(mm, vma, address, ptep,\n\t\t\t\t\t  pagecache_page, ptl);\n\t\t\tgoto out_put_page;\n\t\t}\n\t\tentry = huge_pte_mkdirty(entry);\n\t}\n\tentry = pte_mkyoung(entry);\n\tif (huge_ptep_set_access_flags(vma, address, ptep, entry,\n\t\t\t\t\t\tflags & FAULT_FLAG_WRITE))\n\t\tupdate_mmu_cache(vma, address, ptep);\nout_put_page:\n\tif (page != pagecache_page)\n\t\tunlock_page(page);\n\tput_page(page);\nout_ptl:\n\tspin_unlock(ptl);\n\n\tif (pagecache_page) {\n\t\tunlock_page(pagecache_page);\n\t\tput_page(pagecache_page);\n\t}\nout_mutex:\n\tmutex_unlock(&hugetlb_fault_mutex_table[hash]);\n\t/*\n\t * Generally it's safe to hold refcount during waiting page lock. But\n\t * here we just wait to defer the next page fault to avoid busy loop and\n\t * the page is not used after unlocked before returning from the current\n\t * page fault. So we are safe from accessing freed page, even if we wait\n\t * here without taking refcount.\n\t */\n\tif (need_wait_lock)\n\t\twait_on_page_locked(page);\n\treturn ret;\n}\n", "target": 0, "idx": 86373}
{"func": "int validate_camera_metadata_structure(const camera_metadata_t *metadata,\n const size_t *expected_size) {\n\n if (metadata == NULL) {\n        ALOGE(\"%s: metadata is null!\", __FUNCTION__);\n return ERROR;\n }\n\n {\n static const struct {\n const char *name;\n size_t alignment;\n } alignments[] = {\n {\n .name = \"camera_metadata\",\n .alignment = METADATA_ALIGNMENT\n },\n {\n .name = \"camera_metadata_buffer_entry\",\n .alignment = ENTRY_ALIGNMENT\n },\n {\n .name = \"camera_metadata_data\",\n .alignment = DATA_ALIGNMENT\n },\n };\n\n for (size_t i = 0; i < sizeof(alignments)/sizeof(alignments[0]); ++i) {\n uintptr_t aligned_ptr = ALIGN_TO(metadata, alignments[i].alignment);\n\n if ((uintptr_t)metadata != aligned_ptr) {\n                ALOGE(\"%s: Metadata pointer is not aligned (actual %p, \"\n \"expected %p) to type %s\",\n                      __FUNCTION__, metadata,\n (void*)aligned_ptr, alignments[i].name);\n return ERROR;\n }\n }\n }\n\n /**\n     * Check that the metadata contents are correct\n     */\n\n if (expected_size != NULL && metadata->size > *expected_size) {\n        ALOGE(\"%s: Metadata size (%\" PRIu32 \") should be <= expected size (%zu)\",\n              __FUNCTION__, metadata->size, *expected_size);\n return ERROR;\n }\n\n if (metadata->entry_count > metadata->entry_capacity) {\n        ALOGE(\"%s: Entry count (%\" PRIu32 \") should be <= entry capacity \"\n \"(%\" PRIu32 \")\",\n              __FUNCTION__, metadata->entry_count, metadata->entry_capacity);\n\n         return ERROR;\n     }\n \n    const metadata_uptrdiff_t entries_end =\n        metadata->entries_start + metadata->entry_capacity;\n     if (entries_end < metadata->entries_start || // overflow check\n         entries_end > metadata->data_start) {\n \n        ALOGE(\"%s: Entry start + capacity (%\" PRIu32 \") should be <= data start \"\n \"(%\" PRIu32 \")\",\n               __FUNCTION__,\n (metadata->entries_start + metadata->entry_capacity),\n              metadata->data_start);\n return ERROR;\n }\n\n const metadata_uptrdiff_t data_end =\n        metadata->data_start + metadata->data_capacity;\n if (data_end < metadata->data_start || // overflow check\n        data_end > metadata->size) {\n\n        ALOGE(\"%s: Data start + capacity (%\" PRIu32 \") should be <= total size \"\n \"(%\" PRIu32 \")\",\n               __FUNCTION__,\n (metadata->data_start + metadata->data_capacity),\n              metadata->size);\n return ERROR;\n }\n\n const metadata_size_t entry_count = metadata->entry_count;\n camera_metadata_buffer_entry_t *entries = get_entries(metadata);\n\n for (size_t i = 0; i < entry_count; ++i) {\n\n if ((uintptr_t)&entries[i] != ALIGN_TO(&entries[i], ENTRY_ALIGNMENT)) {\n            ALOGE(\"%s: Entry index %zu had bad alignment (address %p),\"\n \" expected alignment %zu\",\n                  __FUNCTION__, i, &entries[i], ENTRY_ALIGNMENT);\n return ERROR;\n }\n\n camera_metadata_buffer_entry_t entry = entries[i];\n\n if (entry.type >= NUM_TYPES) {\n            ALOGE(\"%s: Entry index %zu had a bad type %d\",\n                  __FUNCTION__, i, entry.type);\n return ERROR;\n }\n\n uint32_t tag_section = entry.tag >> 16;\n int tag_type = get_camera_metadata_tag_type(entry.tag);\n if (tag_type != (int)entry.type && tag_section < VENDOR_SECTION) {\n            ALOGE(\"%s: Entry index %zu had tag type %d, but the type was %d\",\n                  __FUNCTION__, i, tag_type, entry.type);\n return ERROR;\n }\n\n size_t data_size;\n if (validate_and_calculate_camera_metadata_entry_data_size(&data_size, entry.type,\n                entry.count) != OK) {\n            ALOGE(\"%s: Entry data size is invalid. type: %u count: %u\", __FUNCTION__, entry.type,\n                    entry.count);\n return ERROR;\n }\n\n if (data_size != 0) {\n camera_metadata_data_t *data =\n (camera_metadata_data_t*) (get_data(metadata) +\n                                               entry.data.offset);\n\n if ((uintptr_t)data != ALIGN_TO(data, DATA_ALIGNMENT)) {\n                ALOGE(\"%s: Entry index %zu had bad data alignment (address %p),\"\n \" expected align %zu, (tag name %s, data size %zu)\",\n                      __FUNCTION__, i, data, DATA_ALIGNMENT,\n                      get_camera_metadata_tag_name(entry.tag) ?: \"unknown\",\n                      data_size);\n return ERROR;\n }\n\n size_t data_entry_end = entry.data.offset + data_size;\n if (data_entry_end < entry.data.offset || // overflow check\n                data_entry_end > metadata->data_capacity) {\n\n                ALOGE(\"%s: Entry index %zu data ends (%zu) beyond the capacity \"\n \"%\" PRIu32, __FUNCTION__, i, data_entry_end,\n                      metadata->data_capacity);\n return ERROR;\n }\n\n } else if (entry.count == 0) {\n if (entry.data.offset != 0) {\n                ALOGE(\"%s: Entry index %zu had 0 items, but offset was non-0 \"\n \"(%\" PRIu32 \"), tag name: %s\", __FUNCTION__, i, entry.data.offset,\n                        get_camera_metadata_tag_name(entry.tag) ?: \"unknown\");\n return ERROR;\n }\n } // else data stored inline, so we look at value which can be anything.\n }\n\n return OK;\n}\n", "target": 1, "idx": 187419}
{"func": " static sk_sp<SkImage> unPremulSkImageToPremul(SkImage* input) {\n  SkImageInfo info = SkImageInfo::Make(input->width(), input->height(),\n                                       kN32_SkColorType, kPremul_SkAlphaType);\n  RefPtr<Uint8Array> dstPixels = copySkImageData(input, info);\n  if (!dstPixels)\n     return nullptr;\n   return newSkImageFromRaster(\n       info, std::move(dstPixels),\n      static_cast<size_t>(input->width()) * info.bytesPerPixel());\n }\n", "target": 1, "idx": 186476}
{"func": "static void __exit tcm_loop_fabric_exit(void)\n{\n\ttcm_loop_deregister_configfs();\n\ttcm_loop_release_core_bus();\n\tkmem_cache_destroy(tcm_loop_cmd_cache);\n}\n", "target": 0, "idx": 94127}
{"func": " bool GesturePoint::IsSecondClickInsideManhattanSquare(\n     const TouchEvent& event) const {\n   int manhattanDistance = abs(event.x() - last_tap_position_.x()) +\n                           abs(event.y() - last_tap_position_.y());\n  return manhattanDistance < kMaximumTouchMoveInPixelsForClick;\n }\n", "target": 1, "idx": 184738}
{"func": "static void didFinishLoadForFrame(WKPageRef page, WKFrameRef frame, WKTypeRef userData, const void* clientInfo)\n{\n    if (!WKFrameIsMainFrame(frame))\n        return;\n\n    webkitWebViewLoadChanged(WEBKIT_WEB_VIEW(clientInfo), WEBKIT_LOAD_FINISHED);\n}\n", "target": 0, "idx": 115337}
{"func": "static int __net_init nfnetlink_net_init(struct net *net)\n{\n\tstruct sock *nfnl;\n\tstruct netlink_kernel_cfg cfg = {\n\t\t.groups\t= NFNLGRP_MAX,\n\t\t.input\t= nfnetlink_rcv,\n#ifdef CONFIG_MODULES\n\t\t.bind\t= nfnetlink_bind,\n#endif\n\t};\n\n\tnfnl = netlink_kernel_create(net, NETLINK_NETFILTER, &cfg);\n\tif (!nfnl)\n\t\treturn -ENOMEM;\n\tnet->nfnl_stash = nfnl;\n\trcu_assign_pointer(net->nfnl, nfnl);\n\treturn 0;\n}\n", "target": 0, "idx": 49372}
{"func": "void HTMLFormControlElement::parseAttribute(const QualifiedName& name, const AtomicString& value)\n{\n    if (name == formAttr) {\n        formAttributeChanged();\n        UseCounter::count(document(), UseCounter::FormAttribute);\n    } else if (name == disabledAttr) {\n        bool oldDisabled = m_disabled;\n        m_disabled = !value.isNull();\n        if (oldDisabled != m_disabled)\n            disabledAttributeChanged();\n    } else if (name == readonlyAttr) {\n        bool wasReadOnly = m_isReadOnly;\n         m_isReadOnly = !value.isNull();\n         if (wasReadOnly != m_isReadOnly) {\n             setNeedsWillValidateCheck();\n            setNeedsStyleRecalc(SubtreeStyleChange, StyleChangeReasonForTracing::fromAttribute(name));\n             if (layoutObject())\n                 LayoutTheme::theme().controlStateChanged(*layoutObject(), ReadOnlyControlState);\n         }\n    } else if (name == requiredAttr) {\n        bool wasRequired = m_isRequired;\n        m_isRequired = !value.isNull();\n        if (wasRequired != m_isRequired)\n            requiredAttributeChanged();\n        UseCounter::count(document(), UseCounter::RequiredAttribute);\n    } else if (name == autofocusAttr) {\n        HTMLElement::parseAttribute(name, value);\n        UseCounter::count(document(), UseCounter::AutoFocusAttribute);\n    } else {\n        HTMLElement::parseAttribute(name, value);\n    }\n}\n", "target": 1, "idx": 185450}
{"func": " construct_command_line(struct manager_ctx *manager, struct server *server)\n {\n     static char cmd[BUF_SIZE];\n    char *method = manager->method;\n     int i;\n \n    build_config(working_dir, server);\n \n    if (server->method) method = server->method;\n     memset(cmd, 0, BUF_SIZE);\n     snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n \n     if (manager->acl != NULL) {\n         int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n    }\n    if (manager->timeout != NULL) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n    }\n#ifdef HAVE_SETRLIMIT\n    if (manager->nofile) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n    }\n#endif\n    if (manager->user != NULL) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n    }\n    if (manager->verbose) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n    }\n    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n    }\n    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n    }\n    if (server->fast_open[0] == 0 && manager->fast_open) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n    }\n    if (manager->ipv6first) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n    }\n    if (manager->mtu) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n    }\n    if (server->plugin == NULL && manager->plugin) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n    }\n    if (server->plugin_opts == NULL && manager->plugin_opts) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n    }\n    for (i = 0; i < manager->nameserver_num; i++) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n    }\n    for (i = 0; i < manager->host_num; i++) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n    }\n    {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n    }\n\n    if (verbose) {\n        LOGI(\"cmd: %s\", cmd);\n    }\n\n    return cmd;\n}\n", "target": 1, "idx": 180886}
{"func": "static bool check_underflow(const struct ip6t_entry *e)\n{\n \tconst struct xt_entry_target *t;\n \tunsigned int verdict;\n \n\tif (!unconditional(&e->ipv6))\n \t\treturn false;\n \tt = ip6t_get_target_c(e);\n \tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)\n\t\treturn false;\n\tverdict = ((struct xt_standard_target *)t)->verdict;\n\tverdict = -verdict - 1;\n\treturn verdict == NF_DROP || verdict == NF_ACCEPT;\n}\n", "target": 1, "idx": 180545}
{"func": "static void PerWorldBindingsRuntimeEnabledVoidMethodMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  TestObject* impl = V8TestObject::ToImpl(info.Holder());\n\n  impl->perWorldBindingsRuntimeEnabledVoidMethod();\n}\n", "target": 0, "idx": 147691}
{"func": "PaymentHandlerWebFlowViewController::CreateHeaderContentSeparatorView() {\n  if (show_progress_bar_)\n    return progress_bar_.get();\n  return separator_.get();\n}\n", "target": 0, "idx": 163939}
{"func": "static int __dn_setsockopt(struct socket *sock, int level,int optname, char __user *optval, unsigned int optlen, int flags)\n{\n\tstruct\tsock *sk = sock->sk;\n\tstruct dn_scp *scp = DN_SK(sk);\n\tlong timeo;\n\tunion {\n\t\tstruct optdata_dn opt;\n\t\tstruct accessdata_dn acc;\n\t\tint mode;\n\t\tunsigned long win;\n\t\tint val;\n\t\tunsigned char services;\n\t\tunsigned char info;\n\t} u;\n\tint err;\n\n\tif (optlen && !optval)\n\t\treturn -EINVAL;\n\n\tif (optlen > sizeof(u))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&u, optval, optlen))\n\t\treturn -EFAULT;\n\n\tswitch (optname) {\n\tcase DSO_CONDATA:\n\t\tif (sock->state == SS_CONNECTED)\n\t\t\treturn -EISCONN;\n\t\tif ((scp->state != DN_O) && (scp->state != DN_CR))\n\t\t\treturn -EINVAL;\n\n\t\tif (optlen != sizeof(struct optdata_dn))\n\t\t\treturn -EINVAL;\n\n\t\tif (le16_to_cpu(u.opt.opt_optl) > 16)\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(&scp->conndata_out, &u.opt, optlen);\n\t\tbreak;\n\n\tcase DSO_DISDATA:\n\t\tif (sock->state != SS_CONNECTED &&\n\t\t    scp->accept_mode == ACC_IMMED)\n\t\t\treturn -ENOTCONN;\n\n\t\tif (optlen != sizeof(struct optdata_dn))\n\t\t\treturn -EINVAL;\n\n\t\tif (le16_to_cpu(u.opt.opt_optl) > 16)\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(&scp->discdata_out, &u.opt, optlen);\n\t\tbreak;\n\n\tcase DSO_CONACCESS:\n\t\tif (sock->state == SS_CONNECTED)\n\t\t\treturn -EISCONN;\n\t\tif (scp->state != DN_O)\n\t\t\treturn -EINVAL;\n\n\t\tif (optlen != sizeof(struct accessdata_dn))\n\t\t\treturn -EINVAL;\n\n\t\tif ((u.acc.acc_accl > DN_MAXACCL) ||\n\t\t    (u.acc.acc_passl > DN_MAXACCL) ||\n\t\t    (u.acc.acc_userl > DN_MAXACCL))\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(&scp->accessdata, &u.acc, optlen);\n\t\tbreak;\n\n\tcase DSO_ACCEPTMODE:\n\t\tif (sock->state == SS_CONNECTED)\n\t\t\treturn -EISCONN;\n\t\tif (scp->state != DN_O)\n\t\t\treturn -EINVAL;\n\n\t\tif (optlen != sizeof(int))\n\t\t\treturn -EINVAL;\n\n\t\tif ((u.mode != ACC_IMMED) && (u.mode != ACC_DEFER))\n\t\t\treturn -EINVAL;\n\n\t\tscp->accept_mode = (unsigned char)u.mode;\n\t\tbreak;\n\n\tcase DSO_CONACCEPT:\n\t\tif (scp->state != DN_CR)\n\t\t\treturn -EINVAL;\n\t\ttimeo = sock_rcvtimeo(sk, 0);\n\t\terr = dn_confirm_accept(sk, &timeo, sk->sk_allocation);\n\t\treturn err;\n\n\tcase DSO_CONREJECT:\n\t\tif (scp->state != DN_CR)\n\t\t\treturn -EINVAL;\n\n\t\tscp->state = DN_DR;\n\t\tsk->sk_shutdown = SHUTDOWN_MASK;\n\t\tdn_nsp_send_disc(sk, 0x38, 0, sk->sk_allocation);\n\t\tbreak;\n\n\tdefault:\n#ifdef CONFIG_NETFILTER\n\t\treturn nf_setsockopt(sk, PF_DECnet, optname, optval, optlen);\n#endif\n\tcase DSO_LINKINFO:\n\tcase DSO_STREAM:\n\tcase DSO_SEQPACKET:\n\t\treturn -ENOPROTOOPT;\n\n\tcase DSO_MAXWINDOW:\n\t\tif (optlen != sizeof(unsigned long))\n\t\t\treturn -EINVAL;\n\t\tif (u.win > NSP_MAX_WINDOW)\n\t\t\tu.win = NSP_MAX_WINDOW;\n\t\tif (u.win == 0)\n\t\t\treturn -EINVAL;\n\t\tscp->max_window = u.win;\n\t\tif (scp->snd_window > u.win)\n\t\t\tscp->snd_window = u.win;\n\t\tbreak;\n\n\tcase DSO_NODELAY:\n\t\tif (optlen != sizeof(int))\n\t\t\treturn -EINVAL;\n\t\tif (scp->nonagle == 2)\n\t\t\treturn -EINVAL;\n\t\tscp->nonagle = (u.val == 0) ? 0 : 1;\n\t\t/* if (scp->nonagle == 1) { Push pending frames } */\n\t\tbreak;\n\n\tcase DSO_CORK:\n\t\tif (optlen != sizeof(int))\n\t\t\treturn -EINVAL;\n\t\tif (scp->nonagle == 1)\n\t\t\treturn -EINVAL;\n\t\tscp->nonagle = (u.val == 0) ? 0 : 2;\n\t\t/* if (scp->nonagle == 0) { Push pending frames } */\n\t\tbreak;\n\n\tcase DSO_SERVICES:\n\t\tif (optlen != sizeof(unsigned char))\n\t\t\treturn -EINVAL;\n\t\tif ((u.services & ~NSP_FC_MASK) != 0x01)\n\t\t\treturn -EINVAL;\n\t\tif ((u.services & NSP_FC_MASK) == NSP_FC_MASK)\n\t\t\treturn -EINVAL;\n\t\tscp->services_loc = u.services;\n\t\tbreak;\n\n\tcase DSO_INFO:\n\t\tif (optlen != sizeof(unsigned char))\n\t\t\treturn -EINVAL;\n\t\tif (u.info & 0xfc)\n\t\t\treturn -EINVAL;\n\t\tscp->info_loc = u.info;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n", "target": 0, "idx": 41466}
{"func": "get_princs_2_svc(gprincs_arg *arg, struct svc_req *rqstp)\n {\n     static gprincs_ret              ret;\n     char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n     OM_uint32                       minor_stat;\n     kadm5_server_handle_t           handle;\n     const char                      *errmsg = NULL;\n\n    xdr_free(xdr_gprincs_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->exp;\n    if (prime_arg == NULL)\n        prime_arg = \"*\";\n\n    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_LIST,\n                                                       NULL,\n                                                       NULL)) {\n        ret.code = KADM5_AUTH_LIST;\n        log_unauth(\"kadm5_get_principals\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code  = kadm5_get_principals((void *)handle,\n                                         arg->exp, &ret.princs,\n                                         &ret.count);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_get_principals\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n             krb5_free_error_message(handle->context, errmsg);\n \n     }\n     gss_release_buffer(&minor_stat, &client_name);\n     gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n     free_server_handle(handle);\n     return &ret;\n }\n", "target": 1, "idx": 180688}
{"func": "int kvm_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)\n{\n\tunsigned long old_cr4 = kvm_read_cr4(vcpu);\n\tunsigned long pdptr_bits = X86_CR4_PGE | X86_CR4_PSE |\n\t\t\t\t   X86_CR4_PAE | X86_CR4_SMEP;\n\tif (cr4 & CR4_RESERVED_BITS)\n\t\treturn 1;\n\n\tif (!guest_cpuid_has_xsave(vcpu) && (cr4 & X86_CR4_OSXSAVE))\n\t\treturn 1;\n\n\tif (!guest_cpuid_has_smep(vcpu) && (cr4 & X86_CR4_SMEP))\n\t\treturn 1;\n\n\tif (!guest_cpuid_has_fsgsbase(vcpu) && (cr4 & X86_CR4_RDWRGSFS))\n\t\treturn 1;\n\n\tif (is_long_mode(vcpu)) {\n\t\tif (!(cr4 & X86_CR4_PAE))\n\t\t\treturn 1;\n\t} else if (is_paging(vcpu) && (cr4 & X86_CR4_PAE)\n\t\t   && ((cr4 ^ old_cr4) & pdptr_bits)\n\t\t   && !load_pdptrs(vcpu, vcpu->arch.walk_mmu,\n\t\t\t\t   kvm_read_cr3(vcpu)))\n\t\treturn 1;\n\n\tif ((cr4 & X86_CR4_PCIDE) && !(old_cr4 & X86_CR4_PCIDE)) {\n\t\tif (!guest_cpuid_has_pcid(vcpu))\n\t\t\treturn 1;\n\n\t\t/* PCID can not be enabled when cr3[11:0]!=000H or EFER.LMA=0 */\n\t\tif ((kvm_read_cr3(vcpu) & X86_CR3_PCID_MASK) || !is_long_mode(vcpu))\n\t\t\treturn 1;\n\t}\n\n\tif (kvm_x86_ops->set_cr4(vcpu, cr4))\n\t\treturn 1;\n\n\tif (((cr4 ^ old_cr4) & pdptr_bits) ||\n\t    (!(cr4 & X86_CR4_PCIDE) && (old_cr4 & X86_CR4_PCIDE)))\n\t\tkvm_mmu_reset_context(vcpu);\n\n\tif ((cr4 ^ old_cr4) & X86_CR4_OSXSAVE)\n\t\tkvm_update_cpuid(vcpu);\n\n\treturn 0;\n}\n", "target": 0, "idx": 33287}
{"func": "static int mem_resize(jas_stream_memobj_t *m, int bufsize)\n {\n \tunsigned char *buf;\n \n\tassert(bufsize >= 0);\n \n\tJAS_DBGLOG(100, (\"mem_resize(%p, %d)\\n\", m, bufsize));\n \tif (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char))) &&\n \t  bufsize) {\n \t\tJAS_DBGLOG(100, (\"mem_resize realloc failed\\n\"));\n\t\treturn -1;\n\t}\n\tJAS_DBGLOG(100, (\"mem_resize realloc succeeded\\n\"));\n\tm->buf_ = buf;\n\tm->bufsize_ = bufsize;\n\treturn 0;\n}\n", "target": 1, "idx": 181922}
{"func": "Eina_Bool ewk_view_back(Evas_Object* ewkView)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, false);\n    return ewk_frame_back(smartData->main_frame);\n}\n", "target": 0, "idx": 107508}
{"func": "static void detach_task(struct task_struct *p, struct lb_env *env)\n{\n\tlockdep_assert_held(&env->src_rq->lock);\n\n\tp->on_rq = TASK_ON_RQ_MIGRATING;\n\tdeactivate_task(env->src_rq, p, DEQUEUE_NOCLOCK);\n\tset_task_cpu(p, env->dst_cpu);\n}\n", "target": 0, "idx": 92533}
{"func": "static int sctp_setsockopt_associnfo(struct sock *sk, char __user *optval, unsigned int optlen)\n{\n\n\tstruct sctp_assocparams assocparams;\n\tstruct sctp_association *asoc;\n\n\tif (optlen != sizeof(struct sctp_assocparams))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&assocparams, optval, optlen))\n\t\treturn -EFAULT;\n\n\tasoc = sctp_id2assoc(sk, assocparams.sasoc_assoc_id);\n\n\tif (!asoc && assocparams.sasoc_assoc_id && sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\t/* Set the values to the specific association */\n\tif (asoc) {\n\t\tif (assocparams.sasoc_asocmaxrxt != 0) {\n\t\t\t__u32 path_sum = 0;\n\t\t\tint   paths = 0;\n\t\t\tstruct sctp_transport *peer_addr;\n\n\t\t\tlist_for_each_entry(peer_addr, &asoc->peer.transport_addr_list,\n\t\t\t\t\ttransports) {\n\t\t\t\tpath_sum += peer_addr->pathmaxrxt;\n\t\t\t\tpaths++;\n\t\t\t}\n\n\t\t\t/* Only validate asocmaxrxt if we have more than\n\t\t\t * one path/transport.  We do this because path\n\t\t\t * retransmissions are only counted when we have more\n\t\t\t * then one path.\n\t\t\t */\n\t\t\tif (paths > 1 &&\n\t\t\t    assocparams.sasoc_asocmaxrxt > path_sum)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tasoc->max_retrans = assocparams.sasoc_asocmaxrxt;\n\t\t}\n\n\t\tif (assocparams.sasoc_cookie_life != 0) {\n\t\t\tasoc->cookie_life.tv_sec =\n\t\t\t\t\tassocparams.sasoc_cookie_life / 1000;\n\t\t\tasoc->cookie_life.tv_usec =\n\t\t\t\t\t(assocparams.sasoc_cookie_life % 1000)\n\t\t\t\t\t* 1000;\n\t\t}\n\t} else {\n\t\t/* Set the values to the endpoint */\n\t\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\t\tif (assocparams.sasoc_asocmaxrxt != 0)\n\t\t\tsp->assocparams.sasoc_asocmaxrxt =\n\t\t\t\t\t\tassocparams.sasoc_asocmaxrxt;\n\t\tif (assocparams.sasoc_cookie_life != 0)\n\t\t\tsp->assocparams.sasoc_cookie_life =\n\t\t\t\t\t\tassocparams.sasoc_cookie_life;\n\t}\n\treturn 0;\n}\n", "target": 0, "idx": 33038}
{"func": "   static void TearDownTestCase() {\n     vpx_free(input_ - 1);\n     input_ = NULL;\n     vpx_free(output_);\n     output_ = NULL;\n   }\n", "target": 1, "idx": 188529}
{"func": "void BlacklistAddOneDll(const wchar_t* module_name,\n                        bool check_in_browser,\n                        sandbox::TargetPolicy* policy) {\n  HMODULE module = check_in_browser ? ::GetModuleHandleW(module_name) : NULL;\n  if (!module) {\n    std::wstring name(module_name);\n    size_t period = name.rfind(L'.');\n    DCHECK_NE(std::string::npos, period);\n    DCHECK_LE(3U, (name.size() - period));\n    if (period <= 8)\n      return;\n    for (int ix = 0; ix < 3; ++ix) {\n      const wchar_t suffix[] = {'~', ('1' + ix), 0};\n      std::wstring alt_name = name.substr(0, 6) + suffix;\n      alt_name += name.substr(period, name.size());\n      if (check_in_browser) {\n        module = ::GetModuleHandleW(alt_name.c_str());\n        if (!module)\n          return;\n        if (!IsExpandedModuleName(module, module_name))\n          return;\n      }\n      policy->AddDllToUnload(alt_name.c_str());\n    }\n  }\n  policy->AddDllToUnload(module_name);\n  DVLOG(1) << \"dll to unload found: \" << module_name;\n  return;\n}\n", "target": 0, "idx": 113826}
{"func": " SendTabToSelfInfoBarDelegate::SendTabToSelfInfoBarDelegate(\n     const SendTabToSelfEntry* entry) {\n   entry_ = entry;\n }\n", "target": 1, "idx": 186511}
{"func": "ldp_pdu_print(netdissect_options *ndo,\n              register const u_char *pptr)\n{\n    const struct ldp_common_header *ldp_com_header;\n    const struct ldp_msg_header *ldp_msg_header;\n    const u_char *tptr,*msg_tptr;\n    u_short tlen;\n    u_short pdu_len,msg_len,msg_type,msg_tlen;\n    int hexdump,processed;\n\n    ldp_com_header = (const struct ldp_common_header *)pptr;\n    ND_TCHECK(*ldp_com_header);\n\n    /*\n     * Sanity checking of the header.\n     */\n    if (EXTRACT_16BITS(&ldp_com_header->version) != LDP_VERSION) {\n\tND_PRINT((ndo, \"%sLDP version %u packet not supported\",\n               (ndo->ndo_vflag < 1) ? \"\" : \"\\n\\t\",\n               EXTRACT_16BITS(&ldp_com_header->version)));\n\treturn 0;\n    }\n\n    pdu_len = EXTRACT_16BITS(&ldp_com_header->pdu_length);\n    if (pdu_len < sizeof(const struct ldp_common_header)-4) {\n        /* length too short */\n        ND_PRINT((ndo, \"%sLDP, pdu-length: %u (too short, < %u)\",\n               (ndo->ndo_vflag < 1) ? \"\" : \"\\n\\t\",\n               pdu_len,\n               (u_int)(sizeof(const struct ldp_common_header)-4)));\n        return 0;\n    }\n\n    /* print the LSR-ID, label-space & length */\n    ND_PRINT((ndo, \"%sLDP, Label-Space-ID: %s:%u, pdu-length: %u\",\n           (ndo->ndo_vflag < 1) ? \"\" : \"\\n\\t\",\n           ipaddr_string(ndo, &ldp_com_header->lsr_id),\n           EXTRACT_16BITS(&ldp_com_header->label_space),\n           pdu_len));\n\n    /* bail out if non-verbose */\n    if (ndo->ndo_vflag < 1)\n        return 0;\n\n    /* ok they seem to want to know everything - lets fully decode it */\n    tptr = pptr + sizeof(const struct ldp_common_header);\n    tlen = pdu_len - (sizeof(const struct ldp_common_header)-4);\t/* Type & Length fields not included */\n\n    while(tlen>0) {\n        /* did we capture enough for fully decoding the msg header ? */\n        ND_TCHECK2(*tptr, sizeof(struct ldp_msg_header));\n\n        ldp_msg_header = (const struct ldp_msg_header *)tptr;\n        msg_len=EXTRACT_16BITS(ldp_msg_header->length);\n        msg_type=LDP_MASK_MSG_TYPE(EXTRACT_16BITS(ldp_msg_header->type));\n\n        if (msg_len < sizeof(struct ldp_msg_header)-4) {\n            /* length too short */\n            /* FIXME vendor private / experimental check */\n            ND_PRINT((ndo, \"\\n\\t  %s Message (0x%04x), length: %u (too short, < %u)\",\n                   tok2str(ldp_msg_values,\n                           \"Unknown\",\n                           msg_type),\n                   msg_type,\n                   msg_len,\n                   (u_int)(sizeof(struct ldp_msg_header)-4)));\n            return 0;\n        }\n\n        /* FIXME vendor private / experimental check */\n        ND_PRINT((ndo, \"\\n\\t  %s Message (0x%04x), length: %u, Message ID: 0x%08x, Flags: [%s if unknown]\",\n               tok2str(ldp_msg_values,\n                       \"Unknown\",\n                       msg_type),\n               msg_type,\n               msg_len,\n               EXTRACT_32BITS(&ldp_msg_header->id),\n               LDP_MASK_U_BIT(EXTRACT_16BITS(&ldp_msg_header->type)) ? \"continue processing\" : \"ignore\"));\n\n        msg_tptr=tptr+sizeof(struct ldp_msg_header);\n        msg_tlen=msg_len-(sizeof(struct ldp_msg_header)-4); /* Type & Length fields not included */\n\n        /* did we capture enough for fully decoding the message ? */\n        ND_TCHECK2(*tptr, msg_len);\n        hexdump=FALSE;\n\n        switch(msg_type) {\n\n        case LDP_MSG_NOTIF:\n        case LDP_MSG_HELLO:\n        case LDP_MSG_INIT:\n        case LDP_MSG_KEEPALIVE:\n        case LDP_MSG_ADDRESS:\n        case LDP_MSG_LABEL_MAPPING:\n        case LDP_MSG_ADDRESS_WITHDRAW:\n        case LDP_MSG_LABEL_WITHDRAW:\n            while(msg_tlen >= 4) {\n                processed = ldp_tlv_print(ndo, msg_tptr, msg_tlen);\n                if (processed == 0)\n                    break;\n                msg_tlen-=processed;\n                msg_tptr+=processed;\n            }\n            break;\n\n        /*\n         *  FIXME those are the defined messages that lack a decoder\n         *  you are welcome to contribute code ;-)\n         */\n\n        case LDP_MSG_LABEL_REQUEST:\n        case LDP_MSG_LABEL_RELEASE:\n        case LDP_MSG_LABEL_ABORT_REQUEST:\n\n        default:\n            if (ndo->ndo_vflag <= 1)\n                print_unknown_data(ndo, msg_tptr, \"\\n\\t  \", msg_tlen);\n            break;\n        }\n        /* do we want to see an additionally hexdump ? */\n        if (ndo->ndo_vflag > 1 || hexdump==TRUE)\n            print_unknown_data(ndo, tptr+sizeof(struct ldp_msg_header), \"\\n\\t  \",\n                               msg_len);\n\n        tptr += msg_len+4;\n        tlen -= msg_len+4;\n     }\n     return pdu_len+4;\n trunc:\n    ND_PRINT((ndo, \"\\n\\t\\t packet exceeded snapshot\"));\n     return 0;\n }\n", "target": 1, "idx": 183024}
{"func": "v8::Handle<v8::Value> V8WebGLRenderingContext::getAttachedShadersCallback(const v8::Arguments& args)\n{\n     INC_STATS(\"DOM.WebGLRenderingContext.getAttachedShaders()\");\n \n     if (args.Length() < 1)\n        return V8Proxy::throwNotEnoughArgumentsError();\n \n     ExceptionCode ec = 0;\n     WebGLRenderingContext* context = V8WebGLRenderingContext::toNative(args.Holder());\n    if (args.Length() > 0 && !isUndefinedOrNull(args[0]) && !V8WebGLProgram::HasInstance(args[0])) {\n        V8Proxy::throwTypeError();\n        return notHandledByInterceptor();\n    }\n    WebGLProgram* program = V8WebGLProgram::HasInstance(args[0]) ? V8WebGLProgram::toNative(v8::Handle<v8::Object>::Cast(args[0])) : 0;\n    Vector<RefPtr<WebGLShader> > shaders;\n    bool succeed = context->getAttachedShaders(program, shaders, ec);\n    if (ec) {\n        V8Proxy::setDOMException(ec, args.GetIsolate());\n        return v8::Null();\n    }\n    if (!succeed)\n        return v8::Null();\n    v8::Local<v8::Array> array = v8::Array::New(shaders.size());\n    for (size_t ii = 0; ii < shaders.size(); ++ii)\n        array->Set(v8::Integer::New(ii), toV8(shaders[ii].get(), args.GetIsolate()));\n    return array;\n}\n", "target": 1, "idx": 184812}
{"func": "static int pn_recvmsg(struct kiocb *iocb, struct sock *sk,\n\t\t\tstruct msghdr *msg, size_t len, int noblock,\n\t\t\tint flags, int *addr_len)\n{\n\tstruct sk_buff *skb = NULL;\n\tstruct sockaddr_pn sa;\n\tint rval = -EOPNOTSUPP;\n\tint copylen;\n\n\tif (flags & ~(MSG_PEEK|MSG_TRUNC|MSG_DONTWAIT|MSG_NOSIGNAL|\n \t\t\tMSG_CMSG_COMPAT))\n \t\tgoto out_nofree;\n \n\tif (addr_len)\n\t\t*addr_len = sizeof(sa);\n \tskb = skb_recv_datagram(sk, flags, noblock, &rval);\n \tif (skb == NULL)\n \t\tgoto out_nofree;\n\n\tpn_skb_get_src_sockaddr(skb, &sa);\n\n\tcopylen = skb->len;\n\tif (len < copylen) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopylen = len;\n\t}\n\n\trval = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copylen);\n\tif (rval) {\n\t\trval = -EFAULT;\n\t\tgoto out;\n\t}\n \n \trval = (flags & MSG_TRUNC) ? skb->len : copylen;\n \n\tif (msg->msg_name != NULL)\n\t\tmemcpy(msg->msg_name, &sa, sizeof(struct sockaddr_pn));\n \n out:\n \tskb_free_datagram(sk, skb);\n\nout_nofree:\n\treturn rval;\n}\n", "target": 1, "idx": 179655}
{"func": "static int decode_frame_common(AVCodecContext *avctx, PNGDecContext *s,\n                               AVFrame *p, AVPacket *avpkt)\n{\n    AVDictionary *metadata  = NULL;\n    uint32_t tag, length;\n    int decode_next_dat = 0;\n    int ret;\n\n    for (;;) {\n        length = bytestream2_get_bytes_left(&s->gb);\n        if (length <= 0) {\n\n            if (avctx->codec_id == AV_CODEC_ID_PNG &&\n                avctx->skip_frame == AVDISCARD_ALL) {\n                av_frame_set_metadata(p, metadata);\n                return 0;\n            }\n\n            if (CONFIG_APNG_DECODER && avctx->codec_id == AV_CODEC_ID_APNG && length == 0) {\n                if (!(s->state & PNG_IDAT))\n                    return 0;\n                else\n                    goto exit_loop;\n            }\n            av_log(avctx, AV_LOG_ERROR, \"%d bytes left\\n\", length);\n            if (   s->state & PNG_ALLIMAGE\n                && avctx->strict_std_compliance <= FF_COMPLIANCE_NORMAL)\n                goto exit_loop;\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n\n        length = bytestream2_get_be32(&s->gb);\n        if (length > 0x7fffffff || length > bytestream2_get_bytes_left(&s->gb)) {\n            av_log(avctx, AV_LOG_ERROR, \"chunk too big\\n\");\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n        tag = bytestream2_get_le32(&s->gb);\n        if (avctx->debug & FF_DEBUG_STARTCODE)\n            av_log(avctx, AV_LOG_DEBUG, \"png: tag=%c%c%c%c length=%u\\n\",\n                (tag & 0xff),\n                ((tag >> 8) & 0xff),\n                ((tag >> 16) & 0xff),\n                ((tag >> 24) & 0xff), length);\n\n        if (avctx->codec_id == AV_CODEC_ID_PNG &&\n            avctx->skip_frame == AVDISCARD_ALL) {\n            switch(tag) {\n            case MKTAG('I', 'H', 'D', 'R'):\n            case MKTAG('p', 'H', 'Y', 's'):\n            case MKTAG('t', 'E', 'X', 't'):\n            case MKTAG('I', 'D', 'A', 'T'):\n            case MKTAG('t', 'R', 'N', 'S'):\n                break;\n            default:\n                goto skip_tag;\n            }\n        }\n\n        switch (tag) {\n        case MKTAG('I', 'H', 'D', 'R'):\n            if ((ret = decode_ihdr_chunk(avctx, s, length)) < 0)\n                goto fail;\n            break;\n        case MKTAG('p', 'H', 'Y', 's'):\n            if ((ret = decode_phys_chunk(avctx, s)) < 0)\n                goto fail;\n            break;\n        case MKTAG('f', 'c', 'T', 'L'):\n            if (!CONFIG_APNG_DECODER || avctx->codec_id != AV_CODEC_ID_APNG)\n                goto skip_tag;\n            if ((ret = decode_fctl_chunk(avctx, s, length)) < 0)\n                goto fail;\n            decode_next_dat = 1;\n            break;\n        case MKTAG('f', 'd', 'A', 'T'):\n            if (!CONFIG_APNG_DECODER || avctx->codec_id != AV_CODEC_ID_APNG)\n                goto skip_tag;\n            if (!decode_next_dat) {\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n            bytestream2_get_be32(&s->gb);\n            length -= 4;\n            /* fallthrough */\n        case MKTAG('I', 'D', 'A', 'T'):\n            if (CONFIG_APNG_DECODER && avctx->codec_id == AV_CODEC_ID_APNG && !decode_next_dat)\n                goto skip_tag;\n            if ((ret = decode_idat_chunk(avctx, s, length, p)) < 0)\n                goto fail;\n            break;\n        case MKTAG('P', 'L', 'T', 'E'):\n            if (decode_plte_chunk(avctx, s, length) < 0)\n                goto skip_tag;\n            break;\n        case MKTAG('t', 'R', 'N', 'S'):\n            if (decode_trns_chunk(avctx, s, length) < 0)\n                goto skip_tag;\n            break;\n        case MKTAG('t', 'E', 'X', 't'):\n            if (decode_text_chunk(s, length, 0, &metadata) < 0)\n                av_log(avctx, AV_LOG_WARNING, \"Broken tEXt chunk\\n\");\n            bytestream2_skip(&s->gb, length + 4);\n            break;\n        case MKTAG('z', 'T', 'X', 't'):\n            if (decode_text_chunk(s, length, 1, &metadata) < 0)\n                av_log(avctx, AV_LOG_WARNING, \"Broken zTXt chunk\\n\");\n            bytestream2_skip(&s->gb, length + 4);\n            break;\n        case MKTAG('s', 'T', 'E', 'R'): {\n            int mode = bytestream2_get_byte(&s->gb);\n            AVStereo3D *stereo3d = av_stereo3d_create_side_data(p);\n            if (!stereo3d)\n                goto fail;\n\n            if (mode == 0 || mode == 1) {\n                stereo3d->type  = AV_STEREO3D_SIDEBYSIDE;\n                stereo3d->flags = mode ? 0 : AV_STEREO3D_FLAG_INVERT;\n            } else {\n                 av_log(avctx, AV_LOG_WARNING,\n                        \"Unknown value in sTER chunk (%d)\\n\", mode);\n            }\n            bytestream2_skip(&s->gb, 4); /* crc */\n            break;\n        }\n        case MKTAG('I', 'E', 'N', 'D'):\n            if (!(s->state & PNG_ALLIMAGE))\n                av_log(avctx, AV_LOG_ERROR, \"IEND without all image\\n\");\n            if (!(s->state & (PNG_ALLIMAGE|PNG_IDAT))) {\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n            bytestream2_skip(&s->gb, 4); /* crc */\n            goto exit_loop;\n        default:\n            /* skip tag */\nskip_tag:\n            bytestream2_skip(&s->gb, length + 4);\n            break;\n        }\n    }\nexit_loop:\n    if (avctx->codec_id == AV_CODEC_ID_PNG &&\n        avctx->skip_frame == AVDISCARD_ALL) {\n        av_frame_set_metadata(p, metadata);\n        return 0;\n    }\n\n    if (s->bits_per_pixel <= 4)\n        handle_small_bpp(s, p);\n\n    /* apply transparency if needed */\n    if (s->has_trns && s->color_type != PNG_COLOR_TYPE_PALETTE) {\n        size_t byte_depth = s->bit_depth > 8 ? 2 : 1;\n         size_t raw_bpp = s->bpp - byte_depth;\n         unsigned x, y;\n \n         for (y = 0; y < s->height; ++y) {\n             uint8_t *row = &s->image_buf[s->image_linesize * y];\n \n            /* since we're updating in-place, we have to go from right to left */\n            for (x = s->width; x > 0; --x) {\n                uint8_t *pixel = &row[s->bpp * (x - 1)];\n                memmove(pixel, &row[raw_bpp * (x - 1)], raw_bpp);\n\n                if (!memcmp(pixel, s->transparent_color_be, raw_bpp)) {\n                    memset(&pixel[raw_bpp], 0, byte_depth);\n                } else {\n                    memset(&pixel[raw_bpp], 0xff, byte_depth);\n                }\n            }\n        }\n    }\n\n    /* handle P-frames only if a predecessor frame is available */\n    if (s->last_picture.f->data[0]) {\n        if (   !(avpkt->flags & AV_PKT_FLAG_KEY) && avctx->codec_tag != AV_RL32(\"MPNG\")\n            && s->last_picture.f->width == p->width\n            && s->last_picture.f->height== p->height\n            && s->last_picture.f->format== p->format\n         ) {\n            if (CONFIG_PNG_DECODER && avctx->codec_id != AV_CODEC_ID_APNG)\n                handle_p_frame_png(s, p);\n            else if (CONFIG_APNG_DECODER &&\n                     avctx->codec_id == AV_CODEC_ID_APNG &&\n                     (ret = handle_p_frame_apng(avctx, s, p)) < 0)\n                goto fail;\n        }\n    }\n    ff_thread_report_progress(&s->picture, INT_MAX, 0);\n    ff_thread_report_progress(&s->previous_picture, INT_MAX, 0);\n\n    av_frame_set_metadata(p, metadata);\n    metadata   = NULL;\n    return 0;\n\nfail:\n    av_dict_free(&metadata);\n    ff_thread_report_progress(&s->picture, INT_MAX, 0);\n    ff_thread_report_progress(&s->previous_picture, INT_MAX, 0);\n    return ret;\n}\n", "target": 1, "idx": 181419}
{"func": "static int update_open_stateid(struct nfs4_state *state, nfs4_stateid *open_stateid, nfs4_stateid *delegation, int open_flags)\n {\n \tstruct nfs_inode *nfsi = NFS_I(state->inode);\n \tstruct nfs_delegation *deleg_cur;\n \tint ret = 0;\n \n\topen_flags &= (FMODE_READ|FMODE_WRITE);\n \n \trcu_read_lock();\n \tdeleg_cur = rcu_dereference(nfsi->delegation);\n\tif (deleg_cur == NULL)\n\t\tgoto no_delegation;\n \n \tspin_lock(&deleg_cur->lock);\n \tif (nfsi->delegation != deleg_cur ||\n\t    (deleg_cur->type & open_flags) != open_flags)\n \t\tgoto no_delegation_unlock;\n \n \tif (delegation == NULL)\n\t\tdelegation = &deleg_cur->stateid;\n\telse if (memcmp(deleg_cur->stateid.data, delegation->data, NFS4_STATEID_SIZE) != 0)\n \t\tgoto no_delegation_unlock;\n \n \tnfs_mark_delegation_referenced(deleg_cur);\n\t__update_open_stateid(state, open_stateid, &deleg_cur->stateid, open_flags);\n \tret = 1;\n no_delegation_unlock:\n \tspin_unlock(&deleg_cur->lock);\n no_delegation:\n \trcu_read_unlock();\n \n \tif (!ret && open_stateid != NULL) {\n\t\t__update_open_stateid(state, open_stateid, NULL, open_flags);\n \t\tret = 1;\n \t}\n \n \treturn ret;\n }\n", "target": 1, "idx": 178880}
{"func": "  ~ConnectionFilterController() {}\n", "target": 0, "idx": 139236}
{"func": "static int set_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)\n {\n\treturn usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, 0),\n\t\t\t       RTL8150_REQ_SET_REGS, RTL8150_REQT_WRITE,\n\t\t\t       indx, 0, data, size, 500);\n }\n", "target": 1, "idx": 181387}
{"func": "void __init idt_setup_early_traps(void)\n{\n\tidt_setup_from_table(idt_table, early_idts, ARRAY_SIZE(early_idts),\n\t\t\t     true);\n\tload_idt(&idt_descr);\n}\n", "target": 0, "idx": 83477}
{"func": "void PPB_URLLoader_Impl::RunCallback(int32_t result) {\n  if (!pending_callback_.get()) {\n     CHECK(main_document_loader_);\n     return;\n   }\n   TrackedCallback::ClearAndRun(&pending_callback_, result);\n }\n", "target": 1, "idx": 184489}
{"func": "static void xen_netbk_tx_submit(struct xen_netbk *netbk)\n{\n\tstruct gnttab_copy *gop = netbk->tx_copy_ops;\n\tstruct sk_buff *skb;\n\n\twhile ((skb = __skb_dequeue(&netbk->tx_queue)) != NULL) {\n\t\tstruct xen_netif_tx_request *txp;\n\t\tstruct xenvif *vif;\n\t\tu16 pending_idx;\n\t\tunsigned data_len;\n\n\t\tpending_idx = *((u16 *)skb->data);\n\t\tvif = netbk->pending_tx_info[pending_idx].vif;\n\t\ttxp = &netbk->pending_tx_info[pending_idx].req;\n\n\t\t/* Check the remap error code. */\n\t\tif (unlikely(xen_netbk_tx_check_gop(netbk, skb, &gop))) {\n\t\t\tnetdev_dbg(vif->dev, \"netback grant failed.\\n\");\n\t\t\tskb_shinfo(skb)->nr_frags = 0;\n\t\t\tkfree_skb(skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdata_len = skb->len;\n\t\tmemcpy(skb->data,\n\t\t       (void *)(idx_to_kaddr(netbk, pending_idx)|txp->offset),\n\t\t       data_len);\n\t\tif (data_len < txp->size) {\n\t\t\t/* Append the packet payload as a fragment. */\n\t\t\ttxp->offset += data_len;\n\t\t\ttxp->size -= data_len;\n\t\t} else {\n\t\t\t/* Schedule a response immediately. */\n\t\t\txen_netbk_idx_release(netbk, pending_idx);\n\t\t}\n\n\t\tif (txp->flags & XEN_NETTXF_csum_blank)\n\t\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n\t\telse if (txp->flags & XEN_NETTXF_data_validated)\n\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\n\t\txen_netbk_fill_frags(netbk, skb);\n\n\t\t/*\n\t\t * If the initial fragment was < PKT_PROT_LEN then\n\t\t * pull through some bytes from the other fragments to\n\t\t * increase the linear region to PKT_PROT_LEN bytes.\n\t\t */\n\t\tif (skb_headlen(skb) < PKT_PROT_LEN && skb_is_nonlinear(skb)) {\n\t\t\tint target = min_t(int, skb->len, PKT_PROT_LEN);\n\t\t\t__pskb_pull_tail(skb, target - skb_headlen(skb));\n\t\t}\n\n\t\tskb->dev      = vif->dev;\n\t\tskb->protocol = eth_type_trans(skb, skb->dev);\n\n\t\tif (checksum_setup(vif, skb)) {\n\t\t\tnetdev_dbg(vif->dev,\n\t\t\t\t   \"Can't setup checksum in net_tx_action\\n\");\n\t\t\tkfree_skb(skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\tvif->dev->stats.rx_bytes += skb->len;\n\t\tvif->dev->stats.rx_packets++;\n\n\t\txenvif_receive_skb(vif, skb);\n\t}\n}\n", "target": 0, "idx": 34043}
{"func": "static int init_nss_hash(struct crypto_instance *instance)\n{\n\tPK11SlotInfo*\thash_slot = NULL;\n\tSECItem\t\thash_param;\n\n\tif (!hash_to_nss[instance->crypto_hash_type]) {\n\t\treturn 0;\n \t}\n \n \thash_param.type = siBuffer;\n\thash_param.data = 0;\n\thash_param.len = 0;\n \n \thash_slot = PK11_GetBestSlot(hash_to_nss[instance->crypto_hash_type], NULL);\n \tif (hash_slot == NULL) {\n\t\tlog_printf(instance->log_level_security, \"Unable to find security slot (err %d)\",\n\t\t\t   PR_GetError());\n\t\treturn -1;\n\t}\n\n\tinstance->nss_sym_key_sign = PK11_ImportSymKey(hash_slot,\n\t\t\t\t\t\t       hash_to_nss[instance->crypto_hash_type],\n\t\t\t\t\t\t       PK11_OriginUnwrap, CKA_SIGN,\n\t\t\t\t\t\t       &hash_param, NULL);\n\tif (instance->nss_sym_key_sign == NULL) {\n\t\tlog_printf(instance->log_level_security, \"Failure to import key into NSS (err %d)\",\n\t\t\t   PR_GetError());\n\t\treturn -1;\n\t}\n\n\tPK11_FreeSlot(hash_slot);\n\n\treturn 0;\n}\n", "target": 1, "idx": 179718}
{"func": "static void init_once(void *foo)\n{\n\tstruct ext4_inode_info *ei = (struct ext4_inode_info *) foo;\n\n \tINIT_LIST_HEAD(&ei->i_orphan);\n \tinit_rwsem(&ei->xattr_sem);\n \tinit_rwsem(&ei->i_data_sem);\n \tinode_init_once(&ei->vfs_inode);\n }\n", "target": 1, "idx": 180664}
{"func": "void ContainerNode::setFocus(bool received)\n{\n    if (ShadowRoot* root = containingShadowRoot()) {\n        if (root->type() != ShadowRootType::UserAgent)\n            shadowHost()->setFocus(received);\n    }\n\n    if (isElementNode() && document().focusedElement() && document().focusedElement() != this) {\n        if (toElement(this)->authorShadowRoot())\n            received = received && toElement(this)->authorShadowRoot()->delegatesFocus();\n    }\n\n    if (focused() == received)\n        return;\n\n    Node::setFocus(received);\n\n    focusStateChanged();\n\n    if (layoutObject() || received)\n        return;\n\n    if (isElementNode() && toElement(this)->childrenOrSiblingsAffectedByFocus() && styleChangeType() < SubtreeStyleChange)\n        document().styleEngine().pseudoStateChangedForElement(CSSSelector::PseudoFocus, *toElement(this));\n    else\n        setNeedsStyleRecalc(LocalStyleChange, StyleChangeReasonForTracing::createWithExtraData(StyleChangeReason::PseudoClass, StyleChangeExtraData::Focus));\n}\n", "target": 0, "idx": 135971}
{"func": "void ChromeDownloadManagerDelegate::RequestConfirmation(\n    DownloadItem* download,\n    const base::FilePath& suggested_path,\n    DownloadConfirmationReason reason,\n    const DownloadTargetDeterminerDelegate::ConfirmationCallback& callback) {\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n  DCHECK(!download->IsTransient());\n\n#if defined(OS_ANDROID)\n  switch (reason) {\n    case DownloadConfirmationReason::NONE:\n      NOTREACHED();\n      return;\n\n    case DownloadConfirmationReason::TARGET_PATH_NOT_WRITEABLE:\n      DownloadManagerService::OnDownloadCanceled(\n          download, DownloadController::CANCEL_REASON_NO_EXTERNAL_STORAGE);\n      callback.Run(DownloadConfirmationResult::CANCELED, base::FilePath());\n      return;\n\n    case DownloadConfirmationReason::NAME_TOO_LONG:\n    case DownloadConfirmationReason::TARGET_NO_SPACE:\n\n    case DownloadConfirmationReason::SAVE_AS:\n    case DownloadConfirmationReason::PREFERENCE:\n      callback.Run(DownloadConfirmationResult::CONTINUE_WITHOUT_CONFIRMATION,\n                   suggested_path);\n      return;\n\n    case DownloadConfirmationReason::TARGET_CONFLICT:\n      if (download->GetWebContents()) {\n        android::ChromeDuplicateDownloadInfoBarDelegate::Create(\n            InfoBarService::FromWebContents(download->GetWebContents()),\n            download, suggested_path, callback);\n        return;\n      }\n\n    case DownloadConfirmationReason::UNEXPECTED:\n      DownloadManagerService::OnDownloadCanceled(\n          download,\n          DownloadController::CANCEL_REASON_CANNOT_DETERMINE_DOWNLOAD_TARGET);\n      callback.Run(DownloadConfirmationResult::CANCELED, base::FilePath());\n      return;\n  }\n#else   // !OS_ANDROID\n  DownloadFilePicker::ShowFilePicker(download, suggested_path, callback);\n#endif  // !OS_ANDROID\n}\n", "target": 0, "idx": 159072}
{"func": "static int ip_error(struct sk_buff *skb)\n{\n\tstruct in_device *in_dev = __in_dev_get_rcu(skb->dev);\n\tstruct rtable *rt = skb_rtable(skb);\n\tstruct inet_peer *peer;\n\tunsigned long now;\n\tstruct net *net;\n\tbool send;\n\tint code;\n\n\t/* IP on this device is disabled. */\n\tif (!in_dev)\n\t\tgoto out;\n\n\tnet = dev_net(rt->dst.dev);\n\tif (!IN_DEV_FORWARD(in_dev)) {\n\t\tswitch (rt->dst.error) {\n\t\tcase EHOSTUNREACH:\n\t\t\t__IP_INC_STATS(net, IPSTATS_MIB_INADDRERRORS);\n\t\t\tbreak;\n\n\t\tcase ENETUNREACH:\n\t\t\t__IP_INC_STATS(net, IPSTATS_MIB_INNOROUTES);\n\t\t\tbreak;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tswitch (rt->dst.error) {\n\tcase EINVAL:\n\tdefault:\n\t\tgoto out;\n\tcase EHOSTUNREACH:\n\t\tcode = ICMP_HOST_UNREACH;\n\t\tbreak;\n\tcase ENETUNREACH:\n\t\tcode = ICMP_NET_UNREACH;\n\t\t__IP_INC_STATS(net, IPSTATS_MIB_INNOROUTES);\n\t\tbreak;\n\tcase EACCES:\n\t\tcode = ICMP_PKT_FILTERED;\n\t\tbreak;\n\t}\n\n\tpeer = inet_getpeer_v4(net->ipv4.peers, ip_hdr(skb)->saddr,\n\t\t\t       l3mdev_master_ifindex(skb->dev), 1);\n\n\tsend = true;\n\tif (peer) {\n\t\tnow = jiffies;\n\t\tpeer->rate_tokens += now - peer->rate_last;\n\t\tif (peer->rate_tokens > ip_rt_error_burst)\n\t\t\tpeer->rate_tokens = ip_rt_error_burst;\n\t\tpeer->rate_last = now;\n\t\tif (peer->rate_tokens >= ip_rt_error_cost)\n\t\t\tpeer->rate_tokens -= ip_rt_error_cost;\n\t\telse\n\t\t\tsend = false;\n\t\tinet_putpeer(peer);\n\t}\n\tif (send)\n\t\ticmp_send(skb, ICMP_DEST_UNREACH, code, 0);\n\nout:\tkfree_skb(skb);\n\treturn 0;\n}\n", "target": 0, "idx": 62050}
{"func": " lookup_bytestring(netdissect_options *ndo, register const u_char *bs,\n \t\t  const unsigned int nlen)\n {\n\tstruct enamemem *tp;\n \tregister u_int i, j, k;\n \n \tif (nlen >= 6) {\n\t\tk = (bs[0] << 8) | bs[1];\n\t\tj = (bs[2] << 8) | bs[3];\n\t\ti = (bs[4] << 8) | bs[5];\n\t} else if (nlen >= 4) {\n\t\tk = (bs[0] << 8) | bs[1];\n\t\tj = (bs[2] << 8) | bs[3];\n\t\ti = 0;\n\t} else\n \t\ti = j = k = 0;\n \n \ttp = &bytestringtable[(i ^ j) & (HASHNAMESIZE-1)];\n\twhile (tp->e_nxt)\n\t\tif (tp->e_addr0 == i &&\n\t\t    tp->e_addr1 == j &&\n\t\t    tp->e_addr2 == k &&\n\t\t    memcmp((const char *)bs, (const char *)(tp->e_bs), nlen) == 0)\n \t\t\treturn tp;\n \t\telse\n\t\t\ttp = tp->e_nxt;\n \n\ttp->e_addr0 = i;\n\ttp->e_addr1 = j;\n\ttp->e_addr2 = k;\n \n\ttp->e_bs = (u_char *) calloc(1, nlen + 1);\n\tif (tp->e_bs == NULL)\n \t\t(*ndo->ndo_error)(ndo, \"lookup_bytestring: calloc\");\n \n\tmemcpy(tp->e_bs, bs, nlen);\n\ttp->e_nxt = (struct enamemem *)calloc(1, sizeof(*tp));\n\tif (tp->e_nxt == NULL)\n \t\t(*ndo->ndo_error)(ndo, \"lookup_bytestring: calloc\");\n \n \treturn tp;\n}\n", "target": 1, "idx": 181132}
{"func": "static void checkListProperties(sqlite3 *db){\n  sqlite3 *p;\n  for(p=sqlite3BlockedList; p; p=p->pNextBlocked){\n    int seen = 0;\n    sqlite3 *p2;\n\n    /* Verify property (1) */\n    assert( p->pUnlockConnection || p->pBlockingConnection );\n\n    /* Verify property (2) */\n    for(p2=sqlite3BlockedList; p2!=p; p2=p2->pNextBlocked){\n      if( p2->xUnlockNotify==p->xUnlockNotify ) seen = 1;\n      assert( p2->xUnlockNotify==p->xUnlockNotify || !seen );\n      assert( db==0 || p->pUnlockConnection!=db );\n      assert( db==0 || p->pBlockingConnection!=db );\n    }\n  }\n}\n", "target": 0, "idx": 149061}
{"func": "static void raisesExceptionLongAttributeAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)\n{\n    TRACE_EVENT_SET_SAMPLING_STATE(\"Blink\", \"DOMGetter\");\n    TestObjectPythonV8Internal::raisesExceptionLongAttributeAttributeGetter(info);\n    TRACE_EVENT_SET_SAMPLING_STATE(\"V8\", \"V8Execution\");\n}\n", "target": 0, "idx": 131615}
{"func": " static void DeleteImpl(Handle<JSObject> obj, uint32_t entry) {\n Handle<SeededNumberDictionary> dict(\n SeededNumberDictionary::cast(obj->elements()));\n uint32_t index = GetIndexForEntryImpl(*dict, entry);\n Handle<Object> result = SeededNumberDictionary::DeleteProperty(dict, entry);\n    USE(result);\n    DCHECK(result->IsTrue(dict->GetIsolate()));\n Handle<FixedArray> new_elements =\n SeededNumberDictionary::Shrink(dict, index);\n    obj->set_elements(*new_elements);\n }\n", "target": 0, "idx": 176239}
{"func": "compute_nhash (uschar *subject, int value1, int value2, int *len)\n{\nuschar *s = subject;\nint i = 0;\nunsigned long int total = 0; /* no overflow */\n\nwhile (*s != 0)\n  {\n  if (i == 0) i = sizeof(prime)/sizeof(int) - 1;\n  total += prime[i--] * (unsigned int)(*s++);\n  }\n\n/* If value2 is unset, just compute one number */\n\nif (value2 < 0)\n  {\n  s = string_sprintf(\"%d\", total % value1);\n  }\n\n/* Otherwise do a div/mod hash */\n\nelse\n  {\n  total = total % (value1 * value2);\n  s = string_sprintf(\"%d/%d\", total/value2, total % value2);\n  }\n\n*len = Ustrlen(s);\nreturn s;\n}\n", "target": 0, "idx": 12644}
{"func": "bool RenderFrameImpl::ShouldDisplayErrorPageForFailedLoad(\n    int error_code,\n    const GURL& unreachable_url) {\n  if (error_code == net::ERR_ABORTED)\n    return false;\n\n  if (error_code == net::ERR_BLOCKED_BY_CLIENT &&\n      render_view_->renderer_preferences_.disable_client_blocked_error_page) {\n    return false;\n  }\n\n  if (GetContentClient()->renderer()->ShouldSuppressErrorPage(\n          this, unreachable_url)) {\n    return false;\n  }\n\n  if (RenderThreadImpl::current() &&\n      RenderThreadImpl::current()->layout_test_mode()) {\n    return false;\n  }\n\n  return true;\n}\n", "target": 0, "idx": 132271}
{"func": "format_STACK_POP(const struct ofpact_stack *a, struct ds *s)\n{\n    nxm_format_stack_pop(a, s);\n}\n", "target": 0, "idx": 76960}
{"func": "inline bool is_hsr_master(struct net_device *dev)\n{\n\treturn (dev->netdev_ops->ndo_start_xmit == hsr_dev_xmit);\n}\n", "target": 0, "idx": 87669}
{"func": "bool BookmarksGetFunction::RunImpl() {\n  scoped_ptr<bookmarks::GetRecent::Params> params(\n      bookmarks::GetRecent::Params::Create(*args_));\n  EXTENSION_FUNCTION_VALIDATE(params.get());\n  if (params->number_of_items < 1)\n    return false;\n\n  std::vector<const BookmarkNode*> nodes;\n  bookmark_utils::GetMostRecentlyAddedEntries(\n      BookmarkModelFactory::GetForProfile(profile()),\n      params->number_of_items,\n      &nodes);\n\n  std::vector<linked_ptr<BookmarkTreeNode> > tree_nodes;\n  std::vector<const BookmarkNode*>::iterator i = nodes.begin();\n  for (; i != nodes.end(); ++i) {\n    const BookmarkNode* node = *i;\n    bookmark_api_helpers::AddNode(node, &tree_nodes, false);\n  }\n\n  results_ = bookmarks::GetRecent::Results::Create(tree_nodes);\n  return true;\n}\n", "target": 0, "idx": 124048}
{"func": "int read_header_tga(gdIOCtx *ctx, oTga *tga)\n{\n\n\tunsigned char header[18];\n\n\tif (gdGetBuf(header, sizeof(header), ctx) < 18) {\n\t\tgd_error(\"fail to read header\");\n\t\treturn -1;\n\t}\n\n\ttga->identsize = header[0];\n\ttga->colormaptype = header[1];\n\ttga->imagetype = header[2];\n\ttga->colormapstart = header[3] + (header[4] << 8);\n\ttga->colormaplength = header[5] + (header[6] << 8);\n\ttga->colormapbits = header[7];\n\ttga->xstart = header[8] + (header[9] << 8);\n\ttga->ystart = header[10] + (header[11] << 8);\n\ttga->width = header[12] + (header[13] << 8);\n\ttga->height = header[14] + (header[15] << 8);\n\ttga->bits = header[16];\n\ttga->alphabits = header[17] & 0x0f;\n\ttga->fliph = (header[17] & 0x10) ? 1 : 0;\n\ttga->flipv = (header[17] & 0x20) ? 0 : 1;\n\n#if DEBUG\n\tprintf(\"format bps: %i\\n\", tga->bits);\n\tprintf(\"flip h/v: %i / %i\\n\", tga->fliph, tga->flipv);\n\tprintf(\"alpha: %i\\n\", tga->alphabits);\n \tprintf(\"wxh: %i %i\\n\", tga->width, tga->height);\n #endif\n \n\tswitch(tga->bits) {\n\tcase 8:\n\tcase 16:\n\tcase 24:\n\tcase 32:\n\t\tbreak;\n\tdefault:\n\t\tgd_error(\"bps %i not supported\", tga->bits);\n \t\treturn -1;\n\t\tbreak;\n \t}\n \n \ttga->ident = NULL;\n\n\tif (tga->identsize > 0) {\n\t\ttga->ident = (char *) gdMalloc(tga->identsize * sizeof(char));\n\t\tif(tga->ident == NULL) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tgdGetBuf(tga->ident, tga->identsize, ctx);\n\t}\n\n\treturn 1;\n}\n", "target": 1, "idx": 180177}
{"func": "void LoginDisplayHostWebUI::TryToPlayOobeStartupSound() {\n  if (is_voice_interaction_oobe_)\n    return;\n\n  if (oobe_startup_sound_played_ || login_prompt_visible_time_.is_null() ||\n      !CrasAudioHandler::Get()->GetPrimaryActiveOutputNode()) {\n    return;\n  }\n\n  oobe_startup_sound_played_ = true;\n\n  if (base::TimeTicks::Now() - login_prompt_visible_time_ >\n      base::TimeDelta::FromMilliseconds(kStartupSoundMaxDelayMs)) {\n    return;\n  }\n\n  AccessibilityManager::Get()->PlayEarcon(SOUND_STARTUP,\n                                          PlaySoundOption::ALWAYS);\n}\n", "target": 0, "idx": 144344}
{"func": "floor_at_intervals(int x, int step)\n{\n    int mo = x % step;\n    if (mo > 0)\n\tx -= mo;\n    else if (mo < 0)\n\tx += step - mo;\n    return x;\n}\n", "target": 0, "idx": 84627}
{"func": "acpi_os_create_cache(char *name, u16 size, u16 depth, acpi_cache_t ** cache)\n{\n\t*cache = kmem_cache_create(name, size, 0, 0, NULL);\n\tif (*cache == NULL)\n\t\treturn AE_ERROR;\n\telse\n\t\treturn AE_OK;\n}\n", "target": 0, "idx": 53834}
{"func": "GF_Err edts_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_EditBox *ptr = (GF_EditBox *)s;\n\n\tif (ptr->editList && gf_list_count(ptr->editList->entryList)) {\n\t\te = gf_isom_box_write_header(s, bs);\n\t\tif (e) return e;\n\t\te = gf_isom_box_write((GF_Box *) ptr->editList, bs);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n", "target": 0, "idx": 80080}
{"func": "void HTMLMediaElement::UpdateControlsVisibility() {\n  if (!isConnected())\n    return;\n\n  bool native_controls = ShouldShowControls(RecordMetricsBehavior::kDoRecord);\n\n  if (!RuntimeEnabledFeatures::LazyInitializeMediaControlsEnabled() ||\n      RuntimeEnabledFeatures::MediaCastOverlayButtonEnabled() ||\n      native_controls) {\n    EnsureMediaControls();\n\n    GetMediaControls()->Reset();\n  }\n\n  if (native_controls)\n    GetMediaControls()->MaybeShow();\n  else if (GetMediaControls())\n    GetMediaControls()->Hide();\n\n  if (web_media_player_)\n    web_media_player_->OnHasNativeControlsChanged(native_controls);\n}\n", "target": 0, "idx": 142935}
{"func": "void ExtensionInstallPrompt::ShowConfirmation() {\n  scoped_ptr<const PermissionSet> permissions_wrapper;\n  const PermissionSet* permissions_to_display = nullptr;\n  if (custom_permissions_.get()) {\n    permissions_to_display = custom_permissions_.get();\n  } else if (extension_) {\n    extensions::PermissionsUpdater(\n        profile_, extensions::PermissionsUpdater::INIT_FLAG_TRANSIENT)\n        .InitializePermissions(extension_);\n    permissions_to_display =\n        &extension_->permissions_data()->active_permissions();\n    if (prompt_->type() == DELEGATED_PERMISSIONS_PROMPT ||\n        prompt_->type() == DELEGATED_BUNDLE_PERMISSIONS_PROMPT) {\n      const PermissionSet& optional_permissions =\n          extensions::PermissionsParser::GetOptionalPermissions(extension_);\n      permissions_wrapper = PermissionSet::CreateUnion(*permissions_to_display,\n                                                       optional_permissions);\n      permissions_to_display = permissions_wrapper.get();\n    }\n  }\n\n  if (permissions_to_display &&\n      (!extension_ ||\n       !extensions::PermissionsData::ShouldSkipPermissionWarnings(\n           extension_->id()))) {\n    Manifest::Type type =\n        extension_ ? extension_->GetType() : Manifest::TYPE_UNKNOWN;\n    const extensions::PermissionMessageProvider* message_provider =\n        extensions::PermissionMessageProvider::Get();\n\n    prompt_->SetPermissions(message_provider->GetPermissionMessages(\n                                message_provider->GetAllPermissionIDs(\n                                    *permissions_to_display, type)),\n                            REGULAR_PERMISSIONS);\n\n    const PermissionSet* withheld =\n        extension_ ? &extension_->permissions_data()->withheld_permissions()\n                   : nullptr;\n    if (withheld && !withheld->IsEmpty()) {\n      prompt_->SetPermissions(\n          message_provider->GetPermissionMessages(\n              message_provider->GetAllPermissionIDs(*withheld, type)),\n          WITHHELD_PERMISSIONS);\n    }\n  }\n\n  switch (prompt_->type()) {\n    case PERMISSIONS_PROMPT:\n    case RE_ENABLE_PROMPT:\n    case INLINE_INSTALL_PROMPT:\n    case EXTERNAL_INSTALL_PROMPT:\n    case INSTALL_PROMPT:\n    case POST_INSTALL_PERMISSIONS_PROMPT:\n    case REMOTE_INSTALL_PROMPT:\n    case REPAIR_PROMPT:\n    case DELEGATED_PERMISSIONS_PROMPT: {\n      prompt_->set_extension(extension_);\n      break;\n    }\n    case BUNDLE_INSTALL_PROMPT:\n    case DELEGATED_BUNDLE_PERMISSIONS_PROMPT: {\n      prompt_->set_bundle(bundle_);\n      break;\n    }\n    case LAUNCH_PROMPT_DEPRECATED:\n    default:\n      NOTREACHED() << \"Unknown message\";\n      return;\n  }\n  prompt_->set_delegated_username(delegated_username_);\n  prompt_->set_icon(gfx::Image::CreateFrom1xBitmap(icon_));\n\n  g_last_prompt_type_for_tests = prompt_->type();\n\n  if (AutoConfirmPrompt(delegate_))\n    return;\n\n  if (show_params_->WasParentDestroyed()) {\n    delegate_->InstallUIAbort(false);\n    return;\n  }\n\n  if (show_dialog_callback_.is_null())\n    GetDefaultShowDialogCallback().Run(show_params_.get(), delegate_, prompt_);\n  else\n    show_dialog_callback_.Run(show_params_.get(), delegate_, prompt_);\n}\n", "target": 0, "idx": 144398}
{"func": "bool RenderFrameImpl::UniqueNameFrameAdapter::IsMainFrame() const {\n  return render_frame_->IsMainFrame();\n}\n", "target": 0, "idx": 152388}
{"func": "  T42_Open_Face( T42_Face  face )\n  {\n    T42_LoaderRec  loader;\n    T42_Parser     parser;\n    T1_Font        type1 = &face->type1;\n    FT_Memory      memory = face->root.memory;\n    FT_Error       error;\n\n    PSAux_Service  psaux  = (PSAux_Service)face->psaux;\n\n\n    t42_loader_init( &loader, face );\n\n    parser = &loader.parser;\n\n     if ( FT_ALLOC( face->ttf_data, 12 ) )\n       goto Exit;\n \n     error = t42_parser_init( parser,\n                              face->root.stream,\n                              memory,\n    if ( error )\n      goto Exit;\n\n    if ( type1->font_type != 42 )\n    {\n      FT_ERROR(( \"T42_Open_Face: cannot handle FontType %d\\n\",\n                 type1->font_type ));\n      error = FT_THROW( Unknown_File_Format );\n      goto Exit;\n    }\n\n    /* now, propagate the charstrings and glyphnames tables */\n    /* to the Type1 data                                    */\n    type1->num_glyphs = loader.num_glyphs;\n\n    if ( !loader.charstrings.init )\n    {\n      FT_ERROR(( \"T42_Open_Face: no charstrings array in face\\n\" ));\n      error = FT_THROW( Invalid_File_Format );\n    }\n\n    loader.charstrings.init  = 0;\n    type1->charstrings_block = loader.charstrings.block;\n    type1->charstrings       = loader.charstrings.elements;\n    type1->charstrings_len   = loader.charstrings.lengths;\n\n    /* we copy the glyph names `block' and `elements' fields; */\n    /* the `lengths' field must be released later             */\n    type1->glyph_names_block    = loader.glyph_names.block;\n    type1->glyph_names          = (FT_String**)loader.glyph_names.elements;\n    loader.glyph_names.block    = 0;\n    loader.glyph_names.elements = 0;\n\n    /* we must now build type1.encoding when we have a custom array */\n    if ( type1->encoding_type == T1_ENCODING_TYPE_ARRAY )\n    {\n      FT_Int    charcode, idx, min_char, max_char;\n      FT_Byte*  glyph_name;\n\n\n      /* OK, we do the following: for each element in the encoding   */\n      /* table, look up the index of the glyph having the same name  */\n      /* as defined in the CharStrings array.                        */\n      /* The index is then stored in type1.encoding.char_index, and  */\n      /* the name in type1.encoding.char_name                        */\n\n      min_char = 0;\n      max_char = 0;\n\n      charcode = 0;\n      for ( ; charcode < loader.encoding_table.max_elems; charcode++ )\n      {\n        FT_Byte*  char_name;\n\n\n        type1->encoding.char_index[charcode] = 0;\n        type1->encoding.char_name [charcode] = (char *)\".notdef\";\n\n        char_name = loader.encoding_table.elements[charcode];\n        if ( char_name )\n          for ( idx = 0; idx < type1->num_glyphs; idx++ )\n          {\n            glyph_name = (FT_Byte*)type1->glyph_names[idx];\n            if ( ft_strcmp( (const char*)char_name,\n                            (const char*)glyph_name ) == 0 )\n            {\n              type1->encoding.char_index[charcode] = (FT_UShort)idx;\n              type1->encoding.char_name [charcode] = (char*)glyph_name;\n\n              /* Change min/max encoded char only if glyph name is */\n              /* not /.notdef                                      */\n              if ( ft_strcmp( (const char*)\".notdef\",\n                              (const char*)glyph_name ) != 0 )\n              {\n                if ( charcode < min_char )\n                  min_char = charcode;\n                if ( charcode >= max_char )\n                  max_char = charcode + 1;\n              }\n              break;\n            }\n          }\n      }\n\n      type1->encoding.code_first = min_char;\n      type1->encoding.code_last  = max_char;\n      type1->encoding.num_chars  = loader.num_chars;\n    }\n\n  Exit:\n    t42_loader_done( &loader );\n    return error;\n  }\n", "target": 1, "idx": 178033}
{"func": " FrameImpl::FrameImpl(std::unique_ptr<content::WebContents> web_contents,\n                     chromium::web::FrameObserverPtr observer)\n    : web_contents_(std::move(web_contents)), observer_(std::move(observer)) {\n  Observe(web_contents.get());\n }\n", "target": 1, "idx": 186120}
{"func": "txid_snapshot_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tTxidSnapshot *snap;\n \ttxid\t\tlast = 0;\n \tint\t\t\tnxip;\n \tint\t\t\ti;\n\tint\t\t\tavail;\n\tint\t\t\texpect;\n \ttxid\t\txmin,\n \t\t\t\txmax;\n \n\t/*\n\t * load nxip and check for nonsense.\n\t *\n\t * (nxip > avail) check is against int overflows in 'expect'.\n\t */\n \tnxip = pq_getmsgint(buf, 4);\n\tavail = buf->len - buf->cursor;\n\texpect = 8 + 8 + nxip * 8;\n\tif (nxip < 0 || nxip > avail || expect > avail)\n \t\tgoto bad_format;\n \n \txmin = pq_getmsgint64(buf);\n\txmax = pq_getmsgint64(buf);\n\tif (xmin == 0 || xmax == 0 || xmin > xmax || xmax > MAX_TXID)\n\t\tgoto bad_format;\n\n\tsnap = palloc(TXID_SNAPSHOT_SIZE(nxip));\n\tsnap->xmin = xmin;\n\tsnap->xmax = xmax;\n\tsnap->nxip = nxip;\n\tSET_VARSIZE(snap, TXID_SNAPSHOT_SIZE(nxip));\n\n\tfor (i = 0; i < nxip; i++)\n\t{\n\t\ttxid\t\tcur = pq_getmsgint64(buf);\n\n\t\tif (cur <= last || cur < xmin || cur >= xmax)\n\t\t\tgoto bad_format;\n\t\tsnap->xip[i] = cur;\n\t\tlast = cur;\n\t}\n\tPG_RETURN_POINTER(snap);\n\nbad_format:\n\telog(ERROR, \"invalid snapshot data\");\n\treturn (Datum) NULL;\n}\n", "target": 1, "idx": 179588}
{"func": "static ssize_t eth_rx(NetClientState *nc, const uint8_t *buf, size_t size)\n{\n    struct xlx_ethlite *s = qemu_get_nic_opaque(nc);\n    unsigned int rxbase = s->rxbuf * (0x800 / 4);\n\n    /* DA filter.  */\n    if (!(buf[0] & 0x80) && memcmp(&s->conf.macaddr.a[0], buf, 6))\n        return size;\n\n    if (s->regs[rxbase + R_RX_CTRL0] & CTRL_S) {\n        D(qemu_log(\"ethlite lost packet %x\\n\", s->regs[R_RX_CTRL0]));\n        return -1;\n     }\n \n     D(qemu_log(\"%s %zd rxbase=%x\\n\", __func__, size, rxbase));\n     memcpy(&s->regs[rxbase + R_RX_BUF0], buf, size);\n \n     s->regs[rxbase + R_RX_CTRL0] |= CTRL_S;\n    /* If c_rx_pingpong was set flip buffers.  */\n    s->rxbuf ^= s->c_rx_pingpong;\n    return size;\n}\n", "target": 1, "idx": 178105}
{"func": "CSSStyleSheet* Document::createEmptyCSSStyleSheet(\n    ScriptState* script_state,\n    ExceptionState& exception_state) {\n  return Document::createEmptyCSSStyleSheet(\n      script_state, CSSStyleSheetInit::Create(), exception_state);\n}\n", "target": 0, "idx": 165470}
{"func": "static int parseOptions(int argc, char **argv) {\n    int i;\n\n    for (i = 1; i < argc; i++) {\n        int lastarg = i==argc-1;\n\n        if (!strcmp(argv[i],\"-h\") && !lastarg) {\n            sdsfree(config.hostip);\n            config.hostip = sdsnew(argv[++i]);\n        } else if (!strcmp(argv[i],\"-h\") && lastarg) {\n            usage();\n        } else if (!strcmp(argv[i],\"--help\")) {\n            usage();\n        } else if (!strcmp(argv[i],\"-x\")) {\n            config.stdinarg = 1;\n        } else if (!strcmp(argv[i],\"-p\") && !lastarg) {\n            config.hostport = atoi(argv[++i]);\n        } else if (!strcmp(argv[i],\"-s\") && !lastarg) {\n            config.hostsocket = argv[++i];\n        } else if (!strcmp(argv[i],\"-r\") && !lastarg) {\n            config.repeat = strtoll(argv[++i],NULL,10);\n        } else if (!strcmp(argv[i],\"-i\") && !lastarg) {\n            double seconds = atof(argv[++i]);\n            config.interval = seconds*1000000;\n        } else if (!strcmp(argv[i],\"-n\") && !lastarg) {\n            config.dbnum = atoi(argv[++i]);\n        } else if (!strcmp(argv[i],\"-a\") && !lastarg) {\n            fputs(\"Warning: Using a password with '-a' option on the command line interface may not be safe.\\n\", stderr);\n            config.auth = argv[++i];\n        } else if (!strcmp(argv[i],\"-u\") && !lastarg) {\n            parseRedisUri(argv[++i]);\n        } else if (!strcmp(argv[i],\"--raw\")) {\n            config.output = OUTPUT_RAW;\n        } else if (!strcmp(argv[i],\"--no-raw\")) {\n            config.output = OUTPUT_STANDARD;\n        } else if (!strcmp(argv[i],\"--csv\")) {\n            config.output = OUTPUT_CSV;\n        } else if (!strcmp(argv[i],\"--latency\")) {\n            config.latency_mode = 1;\n        } else if (!strcmp(argv[i],\"--latency-dist\")) {\n            config.latency_dist_mode = 1;\n        } else if (!strcmp(argv[i],\"--mono\")) {\n            spectrum_palette = spectrum_palette_mono;\n            spectrum_palette_size = spectrum_palette_mono_size;\n        } else if (!strcmp(argv[i],\"--latency-history\")) {\n            config.latency_mode = 1;\n            config.latency_history = 1;\n        } else if (!strcmp(argv[i],\"--lru-test\") && !lastarg) {\n            config.lru_test_mode = 1;\n            config.lru_test_sample_size = strtoll(argv[++i],NULL,10);\n        } else if (!strcmp(argv[i],\"--slave\")) {\n            config.slave_mode = 1;\n        } else if (!strcmp(argv[i],\"--stat\")) {\n            config.stat_mode = 1;\n        } else if (!strcmp(argv[i],\"--scan\")) {\n            config.scan_mode = 1;\n        } else if (!strcmp(argv[i],\"--pattern\") && !lastarg) {\n            config.pattern = argv[++i];\n        } else if (!strcmp(argv[i],\"--intrinsic-latency\") && !lastarg) {\n            config.intrinsic_latency_mode = 1;\n            config.intrinsic_latency_duration = atoi(argv[++i]);\n        } else if (!strcmp(argv[i],\"--rdb\") && !lastarg) {\n            config.getrdb_mode = 1;\n            config.rdb_filename = argv[++i];\n        } else if (!strcmp(argv[i],\"--pipe\")) {\n            config.pipe_mode = 1;\n        } else if (!strcmp(argv[i],\"--pipe-timeout\") && !lastarg) {\n            config.pipe_timeout = atoi(argv[++i]);\n        } else if (!strcmp(argv[i],\"--bigkeys\")) {\n            config.bigkeys = 1;\n        } else if (!strcmp(argv[i],\"--hotkeys\")) {\n            config.hotkeys = 1;\n        } else if (!strcmp(argv[i],\"--eval\") && !lastarg) {\n            config.eval = argv[++i];\n        } else if (!strcmp(argv[i],\"--ldb\")) {\n            config.eval_ldb = 1;\n            config.output = OUTPUT_RAW;\n        } else if (!strcmp(argv[i],\"--ldb-sync-mode\")) {\n            config.eval_ldb = 1;\n            config.eval_ldb_sync = 1;\n            config.output = OUTPUT_RAW;\n        } else if (!strcmp(argv[i],\"-c\")) {\n            config.cluster_mode = 1;\n        } else if (!strcmp(argv[i],\"-d\") && !lastarg) {\n            sdsfree(config.mb_delim);\n            config.mb_delim = sdsnew(argv[++i]);\n        } else if (!strcmp(argv[i],\"-v\") || !strcmp(argv[i], \"--version\")) {\n            sds version = cliVersion();\n            printf(\"redis-cli %s\\n\", version);\n            sdsfree(version);\n            exit(0);\n        } else {\n            if (argv[i][0] == '-') {\n                fprintf(stderr,\n                    \"Unrecognized option or bad number of args for: '%s'\\n\",\n                    argv[i]);\n                exit(1);\n            } else {\n                /* Likely the command name, stop here. */\n                break;\n            }\n        }\n    }\n\n    /* --ldb requires --eval. */\n    if (config.eval_ldb && config.eval == NULL) {\n        fprintf(stderr,\"Options --ldb and --ldb-sync-mode require --eval.\\n\");\n        fprintf(stderr,\"Try %s --help for more information.\\n\", argv[0]);\n        exit(1);\n    }\n    return i;\n}\n", "target": 0, "idx": 81977}
{"func": "bool RenderFrameHostManager::IsRendererTransferNeededForNavigation(\n    RenderFrameHostImpl* rfh,\n    const GURL& dest_url) {\n  if (!rfh->GetSiteInstance()->HasSite())\n    return false;\n\n  if (rfh->GetSiteInstance()->GetSiteURL().SchemeIs(kGuestScheme))\n    return false;\n\n  BrowserContext* context = rfh->GetSiteInstance()->GetBrowserContext();\n  if (IsCurrentlySameSite(rfh, dest_url)) {\n    return false;\n  }\n\n  if (rfh->GetSiteInstance()->RequiresDedicatedProcess() ||\n      SiteInstanceImpl::DoesSiteRequireDedicatedProcess(context,\n                                                        dest_url)) {\n    return true;\n  }\n\n  if (SiteIsolationPolicy::IsTopDocumentIsolationEnabled() &&\n      (!frame_tree_node_->IsMainFrame() ||\n       rfh->GetSiteInstance()->IsDefaultSubframeSiteInstance())) {\n    return true;\n  }\n\n  return false;\n}\n", "target": 0, "idx": 148893}
{"func": " rs_filter_graph(RSFilter *filter)\n {\n \tg_return_if_fail(RS_IS_FILTER(filter));\n \tGString *str = g_string_new(\"digraph G {\\n\");\n \n \trs_filter_graph_helper(str, filter);\n \n \tg_string_append_printf(str, \"}\\n\");\n\tg_file_set_contents(\"/tmp/rs-filter-graph\", str->str, str->len, NULL);\n \n\tif (0 != system(\"dot -Tpng >/tmp/rs-filter-graph.png </tmp/rs-filter-graph\"))\n \t\tg_warning(\"Calling dot failed\");\n\tif (0 != system(\"gnome-open /tmp/rs-filter-graph.png\"))\n \t\tg_warning(\"Calling gnome-open failed.\");\n \n \tg_string_free(str, TRUE);\n }\n", "target": 1, "idx": 182086}
{"func": "R_API int r_flag_rename(RFlag *f, RFlagItem *item, const char *name) {\n\tif (!f || !item || !name || !*name) {\n\t\treturn false;\n\t}\n#if 0\n\tut64 off = item->offset;\n\tint size = item->size;\n\tr_flag_unset (f, item);\n\tr_flag_set (f, name, off, size);\n\treturn true;\n#else\n\tht_delete (f->ht_name, item->name);\n\tif (!set_name (item, name)) {\n\t\treturn false;\n\t}\n\tht_insert (f->ht_name, item->name, item);\n#endif\n\treturn true;\n}\n", "target": 0, "idx": 60486}
{"func": "bool GLES2DecoderImpl::DoIsShader(GLuint client_id) {\n  return GetShaderInfo(client_id) != NULL;\n}\n", "target": 0, "idx": 104036}
{"func": "static int crypto_ccm_auth(struct aead_request *req, struct scatterlist *plain,\n\t\t\t   unsigned int cryptlen)\n{\n\tstruct crypto_ccm_req_priv_ctx *pctx = crypto_ccm_reqctx(req);\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\tstruct crypto_ccm_ctx *ctx = crypto_aead_ctx(aead);\n \tAHASH_REQUEST_ON_STACK(ahreq, ctx->mac);\n \tunsigned int assoclen = req->assoclen;\n \tstruct scatterlist sg[3];\n\tu8 odata[16];\n\tu8 idata[16];\n \tint ilen, err;\n \n \t/* format control data for input */\n\terr = format_input(odata, req, cryptlen);\n\tif (err)\n\t\tgoto out;\n\n\tsg_init_table(sg, 3);\n\tsg_set_buf(&sg[0], odata, 16);\n\n\t/* format associated data and compute into mac */\n\tif (assoclen) {\n\t\tilen = format_adata(idata, assoclen);\n\t\tsg_set_buf(&sg[1], idata, ilen);\n\t\tsg_chain(sg, 3, req->src);\n\t} else {\n\t\tilen = 0;\n\t\tsg_chain(sg, 2, req->src);\n\t}\n\n\tahash_request_set_tfm(ahreq, ctx->mac);\n\tahash_request_set_callback(ahreq, pctx->flags, NULL, NULL);\n\tahash_request_set_crypt(ahreq, sg, NULL, assoclen + ilen + 16);\n\terr = crypto_ahash_init(ahreq);\n\tif (err)\n\t\tgoto out;\n\terr = crypto_ahash_update(ahreq);\n\tif (err)\n\t\tgoto out;\n\n\t/* we need to pad the MAC input to a round multiple of the block size */\n\tilen = 16 - (assoclen + ilen) % 16;\n\tif (ilen < 16) {\n\t\tmemset(idata, 0, ilen);\n\t\tsg_init_table(sg, 2);\n\t\tsg_set_buf(&sg[0], idata, ilen);\n\t\tif (plain)\n\t\t\tsg_chain(sg, 2, plain);\n\t\tplain = sg;\n\t\tcryptlen += ilen;\n\t}\n\n\tahash_request_set_crypt(ahreq, plain, pctx->odata, cryptlen);\n\terr = crypto_ahash_finup(ahreq);\nout:\n\treturn err;\n}\n", "target": 1, "idx": 181393}
{"func": "mountpoint_last(struct nameidata *nd, struct path *path)\n{\n\tint error = 0;\n\tstruct dentry *dentry;\n\tstruct dentry *dir = nd->path.dentry;\n\n\t/* If we're in rcuwalk, drop out of it to handle last component */\n\tif (nd->flags & LOOKUP_RCU) {\n\t\tif (unlazy_walk(nd, NULL)) {\n\t\t\terror = -ECHILD;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tnd->flags &= ~LOOKUP_PARENT;\n\n\tif (unlikely(nd->last_type != LAST_NORM)) {\n\t\terror = handle_dots(nd, nd->last_type);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tdentry = dget(nd->path.dentry);\n\t\tgoto done;\n\t}\n\n\tmutex_lock(&dir->d_inode->i_mutex);\n\tdentry = d_lookup(dir, &nd->last);\n\tif (!dentry) {\n\t\t/*\n\t\t * No cached dentry. Mounted dentries are pinned in the cache,\n\t\t * so that means that this dentry is probably a symlink or the\n\t\t * path doesn't actually point to a mounted dentry.\n\t\t */\n\t\tdentry = d_alloc(dir, &nd->last);\n\t\tif (!dentry) {\n\t\t\terror = -ENOMEM;\n\t\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\t\t\tgoto out;\n\t\t}\n\t\tdentry = lookup_real(dir->d_inode, dentry, nd->flags);\n\t\terror = PTR_ERR(dentry);\n\t\tif (IS_ERR(dentry)) {\n\t\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\ndone:\n\tif (!dentry->d_inode || d_is_negative(dentry)) {\n\t\terror = -ENOENT;\n\t\tdput(dentry);\n \t\tgoto out;\n \t}\n \tpath->dentry = dentry;\n\tpath->mnt = mntget(nd->path.mnt);\n \tif (should_follow_link(dentry, nd->flags & LOOKUP_FOLLOW))\n \t\treturn 1;\n \tfollow_mount(path);\n \terror = 0;\n out:\n\tterminate_walk(nd);\n\treturn error;\n}\n", "target": 1, "idx": 179457}
{"func": "MagickExport PixelPacket *GetAuthenticPixelQueue(const Image *image)\n{\n  CacheInfo\n    *restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  if (cache_info->methods.get_authentic_pixels_from_handler !=\n       (GetAuthenticPixelsFromHandler) NULL)\n    return(cache_info->methods.get_authentic_pixels_from_handler(image));\n  assert(id < (int) cache_info->number_threads);\n  return(cache_info->nexus_info[id]->pixels);\n}\n", "target": 0, "idx": 73616}
{"func": "bool BaseSessionService::RestoreUpdateTabNavigationCommand(\n    const SessionCommand& command,\n    TabNavigation* navigation,\n    SessionID::id_type* tab_id) {\n  scoped_ptr<Pickle> pickle(command.PayloadAsPickle());\n  if (!pickle.get())\n    return false;\n  void* iterator = NULL;\n  std::string url_spec;\n  if (!pickle->ReadInt(&iterator, tab_id) ||\n      !pickle->ReadInt(&iterator, &(navigation->index_)) ||\n      !pickle->ReadString(&iterator, &url_spec) ||\n      !pickle->ReadString16(&iterator, &(navigation->title_)) ||\n      !pickle->ReadString(&iterator, &(navigation->state_)) ||\n      !pickle->ReadInt(&iterator,\n                       reinterpret_cast<int*>(&(navigation->transition_))))\n    return false;\n  bool has_type_mask = pickle->ReadInt(&iterator, &(navigation->type_mask_));\n\n  if (has_type_mask) {\n    std::string referrer_spec;\n    pickle->ReadString(&iterator, &referrer_spec);\n    int policy_int;\n    WebReferrerPolicy policy;\n    if (pickle->ReadInt(&iterator, &policy_int))\n      policy = static_cast<WebReferrerPolicy>(policy_int);\n    else\n      policy = WebKit::WebReferrerPolicyDefault;\n    navigation->referrer_ = content::Referrer(\n        referrer_spec.empty() ? GURL() : GURL(referrer_spec),\n         policy);\n \n     std::string content_state;\n     if (CompressDataHelper::ReadAndDecompressStringFromPickle(\n             *pickle.get(), &iterator, &content_state) &&\n         !content_state.empty()) {\n       navigation->state_ = content_state;\n     }\n   }\n \n   navigation->virtual_url_ = GURL(url_spec);\n  return true;\n}\n", "target": 1, "idx": 184742}
{"func": "void FrameSelection::MoveRangeSelection(const VisiblePosition& base_position,\n                                        const VisiblePosition& extent_position,\n                                        TextGranularity granularity) {\n  SelectionInDOMTree new_selection =\n      SelectionInDOMTree::Builder()\n           .SetBaseAndExtentDeprecated(base_position.DeepEquivalent(),\n                                       extent_position.DeepEquivalent())\n           .SetAffinity(base_position.Affinity())\n          .SetIsHandleVisible(IsHandleVisible())\n           .Build();\n \n   if (new_selection.IsNone())\n    return;\n\n  const VisibleSelection& visible_selection =\n      CreateVisibleSelectionWithGranularity(new_selection, granularity);\n  if (visible_selection.IsNone())\n    return;\n\n  SelectionInDOMTree::Builder builder;\n  if (visible_selection.IsBaseFirst()) {\n    builder.SetBaseAndExtent(visible_selection.Start(),\n                             visible_selection.End());\n  } else {\n    builder.SetBaseAndExtent(visible_selection.End(),\n                              visible_selection.Start());\n   }\n   builder.SetAffinity(visible_selection.Affinity());\n  builder.SetIsHandleVisible(IsHandleVisible());\n   SetSelection(builder.Build(), SetSelectionData::Builder()\n                                     .SetShouldCloseTyping(true)\n                                     .SetShouldClearTypingStyle(true)\n                                     .SetGranularity(granularity)\n                                     .Build());\n }\n", "target": 1, "idx": 185634}
{"func": " static size_t safecat(char *buffer, size_t bufsize, size_t pos,\n   PNG_CONST char *cat)\n {\n    while (pos < bufsize && cat != NULL && *cat != 0)\n       buffer[pos++] = *cat++;\n\n if (pos >= bufsize)\n      pos = bufsize-1;\n\n   buffer[pos] = 0;\n return pos;\n}\n", "target": 1, "idx": 187711}
{"func": "void StartupBrowserCreator::AddFirstRunTab(const GURL& url) {\n  first_run_tabs_.push_back(url);\n}\n", "target": 0, "idx": 150168}
{"func": "static int burl_normalize_2F_to_slash_fix (buffer *b, int qs, int i)\n{\n    char * const s = b->ptr;\n    const int blen = (int)buffer_string_length(b);\n    const int used = qs < 0 ? blen : qs;\n    int j = i;\n    for (; i < used; ++i, ++j) {\n        s[j] = s[i];\n        if (s[i] == '%' && s[i+1] == '2' && s[i+2] == 'F') {\n            s[j] = '/';\n            i+=2;\n         }\n     }\n     if (qs >= 0) {\n        memmove(s+j, s+qs, blen - qs);\n        j += blen - qs;\n     }\n     buffer_string_set_length(b, j);\n     return qs;\n}\n", "target": 1, "idx": 182881}
{"func": "void ExtensionTtsController::Stop() {\n  if (current_utterance_ && !current_utterance_->extension_id().empty()) {\n    current_utterance_->profile()->GetExtensionEventRouter()->\n        DispatchEventToExtension(\n            current_utterance_->extension_id(),\n            events::kOnStop,\n            \"[]\",\n            current_utterance_->profile(),\n            GURL());\n  } else {\n    GetPlatformImpl()->clear_error();\n    GetPlatformImpl()->StopSpeaking();\n   }\n \n  if (current_utterance_)\n    current_utterance_->set_error(kSpeechInterruptedError);\n  FinishCurrentUtterance();\n  ClearUtteranceQueue();\n}\n", "target": 1, "idx": 183848}
{"func": "base::PortProvider* BrowserChildProcessHost::GetPortProvider() {\n  return MachBroker::GetInstance();\n}\n", "target": 0, "idx": 162016}
{"func": "void HeapAllocator::backingFree(void* address) {\n  if (!address)\n    return;\n\n  ThreadState* state = ThreadState::current();\n  if (state->sweepForbidden())\n    return;\n  ASSERT(!state->isInGC());\n\n  BasePage* page = pageFromObject(address);\n  if (page->isLargeObjectPage() || page->arena()->getThreadState() != state)\n     return;\n \n   HeapObjectHeader* header = HeapObjectHeader::fromPayload(address);\n  ASSERT(header->checkHeader());\n   NormalPageArena* arena = static_cast<NormalPage*>(page)->arenaForNormalPage();\n   state->promptlyFreed(header->gcInfoIndex());\n   arena->promptlyFreeObject(header);\n}\n", "target": 1, "idx": 186683}
{"func": "void servers_init(void)\n{\n\tsettings_add_bool(\"server\", \"resolve_prefer_ipv6\", FALSE);\n\tsettings_add_bool(\"server\", \"resolve_reverse_lookup\", FALSE);\n\tlookup_servers = servers = NULL;\n\n\tsignal_add(\"chat protocol deinit\", (SIGNAL_FUNC) sig_chat_protocol_deinit);\n\n\tservers_reconnect_init();\n\tservers_setup_init();\n}\n", "target": 0, "idx": 18216}
{"func": "WebsiteSettingsPopupAndroid::~WebsiteSettingsPopupAndroid() {}\n", "target": 0, "idx": 136082}
{"func": "static int _gd2GetHeader(gdIOCtxPtr in, int *sx, int *sy, int *cs, int *vers, int *fmt, int *ncx, int *ncy, t_chunk_info ** chunkIdx)\n{\n\tint i;\n\tint ch;\n\tchar id[5];\n\tt_chunk_info *cidx;\n\tint sidx;\n\tint nc;\n\n\tGD2_DBG(php_gd_error(\"Reading gd2 header info\"));\n\n\tfor (i = 0; i < 4; i++) {\n\t\tch = gdGetC(in);\n\t\tif (ch == EOF) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tid[i] = ch;\n\t}\n\tid[4] = 0;\n\n\tGD2_DBG(php_gd_error(\"Got file code: %s\", id));\n\n\t/* Equiv. of 'magick'.  */\n\tif (strcmp(id, GD2_ID) != 0) {\n\t\tGD2_DBG(php_gd_error(\"Not a valid gd2 file\"));\n\t\tgoto fail1;\n\t}\n\n\t/* Version */\n\tif (gdGetWord(vers, in) != 1) {\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"Version: %d\", *vers));\n\n\tif ((*vers != 1) && (*vers != 2)) {\n\t\tGD2_DBG(php_gd_error(\"Bad version: %d\", *vers));\n\t\tgoto fail1;\n\t}\n\n\t/* Image Size */\n\tif (!gdGetWord(sx, in)) {\n\t\tGD2_DBG(php_gd_error(\"Could not get x-size\"));\n\t\tgoto fail1;\n\t}\n\tif (!gdGetWord(sy, in)) {\n\t\tGD2_DBG(php_gd_error(\"Could not get y-size\"));\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"Image is %dx%d\", *sx, *sy));\n\n\t/* Chunk Size (pixels, not bytes!) */\n\tif (gdGetWord(cs, in) != 1) {\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"ChunkSize: %d\", *cs));\n\n\tif ((*cs < GD2_CHUNKSIZE_MIN) || (*cs > GD2_CHUNKSIZE_MAX)) {\n\t\tGD2_DBG(php_gd_error(\"Bad chunk size: %d\", *cs));\n\t\tgoto fail1;\n\t}\n\n\t/* Data Format */\n\tif (gdGetWord(fmt, in) != 1) {\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"Format: %d\", *fmt));\n\n\tif ((*fmt != GD2_FMT_RAW) && (*fmt != GD2_FMT_COMPRESSED) && (*fmt != GD2_FMT_TRUECOLOR_RAW) && (*fmt != GD2_FMT_TRUECOLOR_COMPRESSED)) {\n\t\tGD2_DBG(php_gd_error(\"Bad data format: %d\", *fmt));\n\t\tgoto fail1;\n\t}\n\n\t/* # of chunks wide */\n\tif (gdGetWord(ncx, in) != 1) {\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"%d Chunks Wide\", *ncx));\n\n\t/* # of chunks high */\n\tif (gdGetWord(ncy, in) != 1) {\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"%d Chunks vertically\", *ncy));\n\n \tif (gd2_compressed(*fmt)) {\n \t\tnc = (*ncx) * (*ncy);\n \t\tGD2_DBG(php_gd_error(\"Reading %d chunk index entries\", nc));\n \t\tsidx = sizeof(t_chunk_info) * nc;\n \t\tif (sidx <= 0) {\n \t\t\tgoto fail1;\n \t\t}\n \t\tcidx = gdCalloc(sidx, 1);\n \t\tfor (i = 0; i < nc; i++) {\n \t\t\tif (gdGetInt(&cidx[i].offset, in) != 1) {\n \t\t\t\tgdFree(cidx);\n\t\t\t\tgoto fail1;\n\t\t\t}\n\t\t\tif (gdGetInt(&cidx[i].size, in) != 1) {\n\t\t\t\tgdFree(cidx);\n\t\t\t\tgoto fail1;\n\t\t\t}\n\t\t\tif (cidx[i].offset < 0 || cidx[i].size < 0) {\n\t\t\t\tgdFree(cidx);\n\t\t\t\tgoto fail1;\n\t\t\t}\n\t\t}\n\t\t*chunkIdx = cidx;\n\t}\n\n\tGD2_DBG(php_gd_error(\"gd2 header complete\"));\n\n\treturn 1;\n\nfail1:\n\treturn 0;\n}\n", "target": 1, "idx": 180303}
{"func": "static MagickBooleanType WriteTIFFImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  const char\n    *mode,\n    *option;\n\n  CompressionType\n    compression;\n\n  EndianType\n    endian_type;\n\n  MagickBooleanType\n    debug,\n    status;\n\n  MagickOffsetType\n    scene;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  register ssize_t\n    i;\n\n  size_t\n    length;\n\n  ssize_t\n    y;\n\n  TIFF\n    *tiff;\n\n  TIFFInfo\n    tiff_info;\n\n  uint16\n    bits_per_sample,\n    compress_tag,\n    endian,\n    photometric;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open TIFF file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) SetMagickThreadValue(tiff_exception,exception);\n  endian_type=UndefinedEndian;\n  option=GetImageOption(image_info,\"tiff:endian\");\n  if (option != (const char *) NULL)\n    {\n      if (LocaleNCompare(option,\"msb\",3) == 0)\n        endian_type=MSBEndian;\n      if (LocaleNCompare(option,\"lsb\",3) == 0)\n        endian_type=LSBEndian;;\n    }\n  switch (endian_type)\n  {\n    case LSBEndian: mode=\"wl\"; break;\n    case MSBEndian: mode=\"wb\"; break;\n    default: mode=\"w\"; break;\n  }\n#if defined(TIFF_VERSION_BIG)\n  if (LocaleCompare(image_info->magick,\"TIFF64\") == 0)\n    switch (endian_type)\n    {\n      case LSBEndian: mode=\"wl8\"; break;\n      case MSBEndian: mode=\"wb8\"; break;\n      default: mode=\"w8\"; break;\n    }\n#endif\n  tiff=TIFFClientOpen(image->filename,mode,(thandle_t) image,TIFFReadBlob,\n    TIFFWriteBlob,TIFFSeekBlob,TIFFCloseBlob,TIFFGetBlobSize,TIFFMapBlob,\n    TIFFUnmapBlob);\n  if (tiff == (TIFF *) NULL)\n    return(MagickFalse);\n  scene=0;\n  debug=IsEventLogging();\n  (void) debug;\n  do\n  {\n    /*\n      Initialize TIFF fields.\n    */\n    if ((image_info->type != UndefinedType) &&\n        (image_info->type != OptimizeType))\n      (void) SetImageType(image,image_info->type,exception);\n    compression=UndefinedCompression;\n    if (image->compression != JPEGCompression)\n      compression=image->compression;\n    if (image_info->compression != UndefinedCompression)\n      compression=image_info->compression;\n    switch (compression)\n    {\n      case FaxCompression:\n      case Group4Compression:\n      {\n        (void) SetImageType(image,BilevelType,exception);\n        (void) SetImageDepth(image,1,exception);\n        break;\n      }\n      case JPEGCompression:\n      {\n        (void) SetImageStorageClass(image,DirectClass,exception);\n        (void) SetImageDepth(image,8,exception);\n        break;\n      }\n      default:\n        break;\n    }\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if ((image->storage_class != PseudoClass) && (image->depth >= 32) &&\n        (quantum_info->format == UndefinedQuantumFormat) &&\n        (IsHighDynamicRangeImage(image,exception) != MagickFalse))\n      {\n        status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);\n        if (status == MagickFalse)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    if ((LocaleCompare(image_info->magick,\"PTIF\") == 0) &&\n        (GetPreviousImageInList(image) != (Image *) NULL))\n      (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_REDUCEDIMAGE);\n    if ((image->columns != (uint32) image->columns) ||\n        (image->rows != (uint32) image->rows))\n      ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n    (void) TIFFSetField(tiff,TIFFTAG_IMAGELENGTH,(uint32) image->rows);\n    (void) TIFFSetField(tiff,TIFFTAG_IMAGEWIDTH,(uint32) image->columns);\n    switch (compression)\n    {\n      case FaxCompression:\n      {\n        compress_tag=COMPRESSION_CCITTFAX3;\n        SetQuantumMinIsWhite(quantum_info,MagickTrue);\n        break;\n      }\n      case Group4Compression:\n      {\n        compress_tag=COMPRESSION_CCITTFAX4;\n        SetQuantumMinIsWhite(quantum_info,MagickTrue);\n        break;\n      }\n#if defined(COMPRESSION_JBIG)\n      case JBIG1Compression:\n      {\n        compress_tag=COMPRESSION_JBIG;\n        break;\n      }\n#endif\n      case JPEGCompression:\n      {\n        compress_tag=COMPRESSION_JPEG;\n        break;\n      }\n#if defined(COMPRESSION_LZMA)\n      case LZMACompression:\n      {\n        compress_tag=COMPRESSION_LZMA;\n        break;\n      }\n#endif\n      case LZWCompression:\n      {\n        compress_tag=COMPRESSION_LZW;\n        break;\n      }\n      case RLECompression:\n      {\n        compress_tag=COMPRESSION_PACKBITS;\n        break;\n      }\n      case ZipCompression:\n      {\n        compress_tag=COMPRESSION_ADOBE_DEFLATE;\n        break;\n      }\n      case NoCompression:\n      default:\n      {\n        compress_tag=COMPRESSION_NONE;\n        break;\n      }\n    }\n#if defined(MAGICKCORE_HAVE_TIFFISCODECCONFIGURED) || (TIFFLIB_VERSION > 20040919)\n    if ((compress_tag != COMPRESSION_NONE) &&\n        (TIFFIsCODECConfigured(compress_tag) == 0))\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\n          \"CompressionNotSupported\",\"`%s'\",CommandOptionToMnemonic(\n          MagickCompressOptions,(ssize_t) compression));\n        compress_tag=COMPRESSION_NONE;\n        compression=NoCompression;\n      }\n#else\n      switch (compress_tag)\n      {\n#if defined(CCITT_SUPPORT)\n        case COMPRESSION_CCITTFAX3:\n        case COMPRESSION_CCITTFAX4:\n#endif\n#if defined(YCBCR_SUPPORT) && defined(JPEG_SUPPORT)\n        case COMPRESSION_JPEG:\n#endif\n#if defined(LZMA_SUPPORT) && defined(COMPRESSION_LZMA)\n        case COMPRESSION_LZMA:\n#endif\n#if defined(LZW_SUPPORT)\n        case COMPRESSION_LZW:\n#endif\n#if defined(PACKBITS_SUPPORT)\n        case COMPRESSION_PACKBITS:\n#endif\n#if defined(ZIP_SUPPORT)\n        case COMPRESSION_ADOBE_DEFLATE:\n#endif\n        case COMPRESSION_NONE:\n          break;\n        default:\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\n            \"CompressionNotSupported\",\"`%s'\",CommandOptionToMnemonic(\n              MagickCompressOptions,(ssize_t) compression));\n          compress_tag=COMPRESSION_NONE;\n          compression=NoCompression;\n          break;\n        }\n      }\n#endif\n    if (image->colorspace == CMYKColorspace)\n      {\n        photometric=PHOTOMETRIC_SEPARATED;\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,4);\n        (void) TIFFSetField(tiff,TIFFTAG_INKSET,INKSET_CMYK);\n      }\n    else\n      {\n        /*\n          Full color TIFF raster.\n        */\n        if (image->colorspace == LabColorspace)\n          {\n            photometric=PHOTOMETRIC_CIELAB;\n            EncodeLabImage(image,exception);\n          }\n        else\n          if (image->colorspace == YCbCrColorspace)\n            {\n              photometric=PHOTOMETRIC_YCBCR;\n              (void) TIFFSetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,1,1);\n              (void) SetImageStorageClass(image,DirectClass,exception);\n              (void) SetImageDepth(image,8,exception);\n            }\n          else\n            photometric=PHOTOMETRIC_RGB;\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,3);\n        if ((image_info->type != TrueColorType) &&\n            (image_info->type != TrueColorAlphaType))\n          {\n            if ((image_info->type != PaletteType) &&\n                (SetImageGray(image,exception) != MagickFalse))\n              {\n                photometric=(uint16) (quantum_info->min_is_white !=\n                  MagickFalse ? PHOTOMETRIC_MINISWHITE :\n                  PHOTOMETRIC_MINISBLACK);\n                (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,1);\n                if ((image->depth == 1) &&\n                    (image->alpha_trait == UndefinedPixelTrait))\n                  SetImageMonochrome(image,exception);\n              }\n            else\n              if (image->storage_class == PseudoClass)\n                {\n                  size_t\n                    depth;\n\n                  /*\n                    Colormapped TIFF raster.\n                  */\n                  (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,1);\n                  photometric=PHOTOMETRIC_PALETTE;\n                  depth=1;\n                  while ((GetQuantumRange(depth)+1) < image->colors)\n                    depth<<=1;\n                  status=SetQuantumDepth(image,quantum_info,depth);\n                  if (status == MagickFalse)\n                    ThrowWriterException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                }\n          }\n      }\n    (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_FILLORDER,&endian);\n    if ((compress_tag == COMPRESSION_CCITTFAX3) &&\n        (photometric != PHOTOMETRIC_MINISWHITE))\n      {\n        compress_tag=COMPRESSION_NONE;\n        endian=FILLORDER_MSB2LSB;\n      }\n    else\n      if ((compress_tag == COMPRESSION_CCITTFAX4) &&\n         (photometric != PHOTOMETRIC_MINISWHITE))\n       {\n         compress_tag=COMPRESSION_NONE;\n         endian=FILLORDER_MSB2LSB;\n       }\n    option=GetImageOption(image_info,\"tiff:fill-order\");\n    if (option != (const char *) NULL)\n      {\n        if (LocaleNCompare(option,\"msb\",3) == 0)\n          endian=FILLORDER_MSB2LSB;\n        if (LocaleNCompare(option,\"lsb\",3) == 0)\n          endian=FILLORDER_LSB2MSB;\n      }\n    (void) TIFFSetField(tiff,TIFFTAG_COMPRESSION,compress_tag);\n    (void) TIFFSetField(tiff,TIFFTAG_FILLORDER,endian);\n    (void) TIFFSetField(tiff,TIFFTAG_BITSPERSAMPLE,quantum_info->depth);\n    if (image->alpha_trait != UndefinedPixelTrait)\n      {\n        uint16\n          extra_samples,\n          sample_info[1],\n          samples_per_pixel;\n\n        /*\n          TIFF has a matte channel.\n        */\n        extra_samples=1;\n        sample_info[0]=EXTRASAMPLE_UNASSALPHA;\n        option=GetImageOption(image_info,\"tiff:alpha\");\n        if (option != (const char *) NULL)\n          {\n            if (LocaleCompare(option,\"associated\") == 0)\n              sample_info[0]=EXTRASAMPLE_ASSOCALPHA;\n            else\n              if (LocaleCompare(option,\"unspecified\") == 0)\n                sample_info[0]=EXTRASAMPLE_UNSPECIFIED;\n          }\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLESPERPIXEL,\n          &samples_per_pixel);\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,samples_per_pixel+1);\n        (void) TIFFSetField(tiff,TIFFTAG_EXTRASAMPLES,extra_samples,\n          &sample_info);\n        if (sample_info[0] == EXTRASAMPLE_ASSOCALPHA)\n          SetQuantumAlphaType(quantum_info,AssociatedQuantumAlpha);\n      }\n    (void) TIFFSetField(tiff,TIFFTAG_PHOTOMETRIC,photometric);\n    switch (quantum_info->format)\n    {\n      case FloatingPointQuantumFormat:\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_IEEEFP);\n        (void) TIFFSetField(tiff,TIFFTAG_SMINSAMPLEVALUE,quantum_info->minimum);\n        (void) TIFFSetField(tiff,TIFFTAG_SMAXSAMPLEVALUE,quantum_info->maximum);\n        break;\n      }\n      case SignedQuantumFormat:\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_INT);\n        break;\n      }\n      case UnsignedQuantumFormat:\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_UINT);\n        break;\n      }\n      default:\n        break;\n    }\n    (void) TIFFSetField(tiff,TIFFTAG_ORIENTATION,ORIENTATION_TOPLEFT);\n    (void) TIFFSetField(tiff,TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);\n    if (photometric == PHOTOMETRIC_RGB)\n      if ((image_info->interlace == PlaneInterlace) ||\n          (image_info->interlace == PartitionInterlace))\n        (void) TIFFSetField(tiff,TIFFTAG_PLANARCONFIG,PLANARCONFIG_SEPARATE);\n    switch (compress_tag)\n    {\n      case COMPRESSION_JPEG:\n      {\n#if defined(JPEG_SUPPORT)\n        const char\n          *sampling_factor;\n\n        GeometryInfo\n          geometry_info;\n\n        MagickStatusType\n          flags;\n\n        if (image_info->quality != UndefinedCompressionQuality)\n          (void) TIFFSetField(tiff,TIFFTAG_JPEGQUALITY,image_info->quality);\n        (void) TIFFSetField(tiff,TIFFTAG_JPEGCOLORMODE,JPEGCOLORMODE_RAW);\n        if (IssRGBCompatibleColorspace(image->colorspace) != MagickFalse)\n          {\n            const char\n              *value;\n\n            (void) TIFFSetField(tiff,TIFFTAG_JPEGCOLORMODE,JPEGCOLORMODE_RGB);\n            sampling_factor=(const char *) NULL;\n            value=GetImageProperty(image,\"jpeg:sampling-factor\",exception);\n            if (value != (char *) NULL)\n              {\n                sampling_factor=value;\n                if (image->debug != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  Input sampling-factors=%s\",sampling_factor);\n              }\n            if (image_info->sampling_factor != (char *) NULL)\n              sampling_factor=image_info->sampling_factor;\n            if (sampling_factor != (const char *) NULL)\n              {\n                flags=ParseGeometry(sampling_factor,&geometry_info);\n                if ((flags & SigmaValue) == 0)\n                  geometry_info.sigma=geometry_info.rho;\n                if (image->colorspace == YCbCrColorspace)\n                  (void) TIFFSetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,(uint16)\n                    geometry_info.rho,(uint16) geometry_info.sigma);\n              }\n          }\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,\n          &bits_per_sample);\n        if (bits_per_sample == 12)\n          (void) TIFFSetField(tiff,TIFFTAG_JPEGTABLESMODE,JPEGTABLESMODE_QUANT);\n#endif\n        break;\n      }\n      case COMPRESSION_ADOBE_DEFLATE:\n      {\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,\n          &bits_per_sample);\n        if (((photometric == PHOTOMETRIC_RGB) ||\n             (photometric == PHOTOMETRIC_MINISBLACK)) &&\n            ((bits_per_sample == 8) || (bits_per_sample == 16)))\n          (void) TIFFSetField(tiff,TIFFTAG_PREDICTOR,PREDICTOR_HORIZONTAL);\n        (void) TIFFSetField(tiff,TIFFTAG_ZIPQUALITY,(long) (\n          image_info->quality == UndefinedCompressionQuality ? 7 :\n          MagickMin((ssize_t) image_info->quality/10,9)));\n        break;\n      }\n      case COMPRESSION_CCITTFAX3:\n      {\n        /*\n          Byte-aligned EOL.\n        */\n        (void) TIFFSetField(tiff,TIFFTAG_GROUP3OPTIONS,4);\n        break;\n      }\n      case COMPRESSION_CCITTFAX4:\n        break;\n#if defined(LZMA_SUPPORT) && defined(COMPRESSION_LZMA)\n      case COMPRESSION_LZMA:\n      {\n        if (((photometric == PHOTOMETRIC_RGB) ||\n             (photometric == PHOTOMETRIC_MINISBLACK)) &&\n            ((bits_per_sample == 8) || (bits_per_sample == 16)))\n          (void) TIFFSetField(tiff,TIFFTAG_PREDICTOR,PREDICTOR_HORIZONTAL);\n        (void) TIFFSetField(tiff,TIFFTAG_LZMAPRESET,(long) (\n          image_info->quality == UndefinedCompressionQuality ? 7 :\n          MagickMin((ssize_t) image_info->quality/10,9)));\n        break;\n      }\n#endif\n      case COMPRESSION_LZW:\n      {\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,\n          &bits_per_sample);\n        if (((photometric == PHOTOMETRIC_RGB) ||\n             (photometric == PHOTOMETRIC_MINISBLACK)) &&\n            ((bits_per_sample == 8) || (bits_per_sample == 16)))\n          (void) TIFFSetField(tiff,TIFFTAG_PREDICTOR,PREDICTOR_HORIZONTAL);\n        break;\n      }\n      default:\n        break;\n    }\n    if ((image->resolution.x != 0.0) && (image->resolution.y != 0.0))\n      {\n        unsigned short\n          units;\n\n        /*\n          Set image resolution.\n        */\n        units=RESUNIT_NONE;\n        if (image->units == PixelsPerInchResolution)\n          units=RESUNIT_INCH;\n        if (image->units == PixelsPerCentimeterResolution)\n          units=RESUNIT_CENTIMETER;\n        (void) TIFFSetField(tiff,TIFFTAG_RESOLUTIONUNIT,(uint16) units);\n        (void) TIFFSetField(tiff,TIFFTAG_XRESOLUTION,image->resolution.x);\n        (void) TIFFSetField(tiff,TIFFTAG_YRESOLUTION,image->resolution.y);\n        if ((image->page.x < 0) || (image->page.y < 0))\n          (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\n            \"TIFF: negative image positions unsupported\",\"%s\",image->filename);\n        if ((image->page.x > 0) && (image->resolution.x > 0.0))\n          {\n            /*\n              Set horizontal image position.\n            */\n            (void) TIFFSetField(tiff,TIFFTAG_XPOSITION,(float) image->page.x/\n              image->resolution.x);\n          }\n        if ((image->page.y > 0) && (image->resolution.y > 0.0))\n          {\n            /*\n              Set vertical image position.\n            */\n            (void) TIFFSetField(tiff,TIFFTAG_YPOSITION,(float) image->page.y/\n              image->resolution.y);\n          }\n      }\n    if (image->chromaticity.white_point.x != 0.0)\n      {\n        float\n          chromaticity[6];\n\n        /*\n          Set image chromaticity.\n        */\n        chromaticity[0]=(float) image->chromaticity.red_primary.x;\n        chromaticity[1]=(float) image->chromaticity.red_primary.y;\n        chromaticity[2]=(float) image->chromaticity.green_primary.x;\n        chromaticity[3]=(float) image->chromaticity.green_primary.y;\n        chromaticity[4]=(float) image->chromaticity.blue_primary.x;\n        chromaticity[5]=(float) image->chromaticity.blue_primary.y;\n        (void) TIFFSetField(tiff,TIFFTAG_PRIMARYCHROMATICITIES,chromaticity);\n        chromaticity[0]=(float) image->chromaticity.white_point.x;\n        chromaticity[1]=(float) image->chromaticity.white_point.y;\n        (void) TIFFSetField(tiff,TIFFTAG_WHITEPOINT,chromaticity);\n      }\n    if ((LocaleCompare(image_info->magick,\"PTIF\") != 0) &&\n        (image_info->adjoin != MagickFalse) && (GetImageListLength(image) > 1))\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_PAGE);\n        if (image->scene != 0)\n          (void) TIFFSetField(tiff,TIFFTAG_PAGENUMBER,(uint16) image->scene,\n            GetImageListLength(image));\n      }\n    if (image->orientation != UndefinedOrientation)\n      (void) TIFFSetField(tiff,TIFFTAG_ORIENTATION,(uint16) image->orientation);\n    (void) TIFFSetProfiles(tiff,image);\n    {\n      uint16\n        page,\n        pages;\n\n      page=(uint16) scene;\n      pages=(uint16) GetImageListLength(image);\n      if ((LocaleCompare(image_info->magick,\"PTIF\") != 0) &&\n          (image_info->adjoin != MagickFalse) && (pages > 1))\n        (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_PAGE);\n      (void) TIFFSetField(tiff,TIFFTAG_PAGENUMBER,page,pages);\n    }\n    (void) TIFFSetProperties(tiff,image_info,image,exception);\nDisableMSCWarning(4127)\n    if (0)\nRestoreMSCWarning\n      (void) TIFFSetEXIFProperties(tiff,image,exception);\n    /*\n      Write image scanlines.\n    */\n    if (GetTIFFInfo(image_info,tiff,&tiff_info) == MagickFalse)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    quantum_info->endian=LSBEndian;\n    pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n    tiff_info.scanline=(unsigned char *) GetQuantumPixels(quantum_info);\n    switch (photometric)\n    {\n      case PHOTOMETRIC_CIELAB:\n      case PHOTOMETRIC_YCBCR:\n      case PHOTOMETRIC_RGB:\n      {\n        /*\n          RGB TIFF image.\n        */\n        switch (image_info->interlace)\n        {\n          case NoInterlace:\n          default:\n          {\n            quantum_type=RGBQuantum;\n            if (image->alpha_trait != UndefinedPixelTrait)\n              quantum_type=RGBAQuantum;\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              register const Quantum\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                quantum_type,pixels,exception);\n              (void) length;\n              if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            break;\n          }\n          case PlaneInterlace:\n          case PartitionInterlace:\n          {\n            /*\n              Plane interlacing:  RRRRRR...GGGGGG...BBBBBB...\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              register const Quantum\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                RedQuantum,pixels,exception);\n              if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n                break;\n            }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,100,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              register const Quantum\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                GreenQuantum,pixels,exception);\n              if (TIFFWritePixels(tiff,&tiff_info,y,1,image) == -1)\n                break;\n            }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,200,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              register const Quantum\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                BlueQuantum,pixels,exception);\n              if (TIFFWritePixels(tiff,&tiff_info,y,2,image) == -1)\n                break;\n            }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,300,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            if (image->alpha_trait != UndefinedPixelTrait)\n              for (y=0; y < (ssize_t) image->rows; y++)\n              {\n                register const Quantum\n                  *magick_restrict p;\n\n                p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n                if (p == (const Quantum *) NULL)\n                  break;\n                length=ExportQuantumPixels(image,(CacheView *) NULL,\n                  quantum_info,AlphaQuantum,pixels,exception);\n                if (TIFFWritePixels(tiff,&tiff_info,y,3,image) == -1)\n                  break;\n              }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,400,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            break;\n          }\n        }\n        break;\n      }\n      case PHOTOMETRIC_SEPARATED:\n      {\n        /*\n          CMYK TIFF image.\n        */\n        quantum_type=CMYKQuantum;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          quantum_type=CMYKAQuantum;\n        if (image->colorspace != CMYKColorspace)\n          (void) TransformImageColorspace(image,CMYKColorspace,exception);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            quantum_type,pixels,exception);\n          if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case PHOTOMETRIC_PALETTE:\n      {\n        uint16\n          *blue,\n          *green,\n          *red;\n\n        /*\n          Colormapped TIFF image.\n        */\n        red=(uint16 *) AcquireQuantumMemory(65536,sizeof(*red));\n        green=(uint16 *) AcquireQuantumMemory(65536,sizeof(*green));\n        blue=(uint16 *) AcquireQuantumMemory(65536,sizeof(*blue));\n        if ((red == (uint16 *) NULL) || (green == (uint16 *) NULL) ||\n            (blue == (uint16 *) NULL))\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        /*\n          Initialize TIFF colormap.\n        */\n        (void) ResetMagickMemory(red,0,65536*sizeof(*red));\n        (void) ResetMagickMemory(green,0,65536*sizeof(*green));\n        (void) ResetMagickMemory(blue,0,65536*sizeof(*blue));\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          red[i]=ScaleQuantumToShort(image->colormap[i].red);\n          green[i]=ScaleQuantumToShort(image->colormap[i].green);\n          blue[i]=ScaleQuantumToShort(image->colormap[i].blue);\n        }\n        (void) TIFFSetField(tiff,TIFFTAG_COLORMAP,red,green,blue);\n        red=(uint16 *) RelinquishMagickMemory(red);\n        green=(uint16 *) RelinquishMagickMemory(green);\n        blue=(uint16 *) RelinquishMagickMemory(blue);\n      }\n      default:\n      {\n        /*\n          Convert PseudoClass packets to contiguous grayscale scanlines.\n        */\n        quantum_type=IndexQuantum;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          {\n            if (photometric != PHOTOMETRIC_PALETTE)\n              quantum_type=GrayAlphaQuantum;\n            else\n              quantum_type=IndexAlphaQuantum;\n           }\n         else\n           if (photometric != PHOTOMETRIC_PALETTE)\n             quantum_type=GrayQuantum;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            quantum_type,pixels,exception);\n          if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n    }\n    quantum_info=DestroyQuantumInfo(quantum_info);\n    if (image->colorspace == LabColorspace)\n      DecodeLabImage(image,exception);\n    DestroyTIFFInfo(&tiff_info);\nDisableMSCWarning(4127)\n    if (0 && (image_info->verbose != MagickFalse))\nRestoreMSCWarning\n      TIFFPrintDirectory(tiff,stdout,MagickFalse);\n    (void) TIFFWriteDirectory(tiff);\n    image=SyncNextImageInList(image);\n    if (image == (Image *) NULL)\n      break;\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  TIFFClose(tiff);\n  return(MagickTrue);\n}\n", "target": 0, "idx": 73243}
{"func": "NO_INLINE JsVar *jspeBlockOrStatement() {\n  if (lex->tk=='{') {\n    jspeBlock();\n    return 0;\n  } else {\n    JsVar *v = jspeStatement();\n    if (lex->tk==';') JSP_ASSERT_MATCH(';');\n    return v;\n  }\n}\n\n/** Parse using current lexer until we hit the end of\n * input or there was some problem. */\nNO_INLINE JsVar *jspParse() {\n  JsVar *v = 0;\n  while (!JSP_SHOULDNT_PARSE && lex->tk != LEX_EOF) {\n    jsvUnLock(v);\n    v = jspeBlockOrStatement();\n  }\n  return v;\n}\n\nNO_INLINE JsVar *jspeStatementVar() {\n  JsVar *lastDefined = 0;\n  /* variable creation. TODO - we need a better way of parsing the left\n   * hand side. Maybe just have a flag called can_create_var that we\n   * set and then we parse as if we're doing a normal equals.*/\n  assert(lex->tk==LEX_R_VAR || lex->tk==LEX_R_LET || lex->tk==LEX_R_CONST);\n  jslGetNextToken();\n  bool hasComma = true; // for first time in loop\n  while (hasComma && lex->tk == LEX_ID && !jspIsInterrupted()) {\n    JsVar *a = 0;\n    if (JSP_SHOULD_EXECUTE) {\n      a = jspeiFindOnTop(jslGetTokenValueAsString(lex), true);\n      if (!a) { // out of memory\n        jspSetError(false);\n        return lastDefined;\n      }\n    }\n    JSP_MATCH_WITH_CLEANUP_AND_RETURN(LEX_ID, jsvUnLock(a), lastDefined);\n    if (lex->tk == '=') {\n      JsVar *var;\n      JSP_MATCH_WITH_CLEANUP_AND_RETURN('=', jsvUnLock(a), lastDefined);\n      var = jsvSkipNameAndUnLock(jspeAssignmentExpression());\n      if (JSP_SHOULD_EXECUTE)\n        jsvReplaceWith(a, var);\n      jsvUnLock(var);\n    }\n    jsvUnLock(lastDefined);\n    lastDefined = a;\n    hasComma = lex->tk == ',';\n    if (hasComma) JSP_MATCH_WITH_RETURN(',', lastDefined);\n  }\n  return lastDefined;\n}\n\nNO_INLINE JsVar *jspeStatementIf() {\n  bool cond;\n  JsVar *var, *result = 0;\n  JSP_ASSERT_MATCH(LEX_R_IF);\n  JSP_MATCH('(');\n  var = jspeExpression();\n  if (JSP_SHOULDNT_PARSE) return var;\n  JSP_MATCH(')');\n  cond = JSP_SHOULD_EXECUTE && jsvGetBoolAndUnLock(jsvSkipName(var));\n  jsvUnLock(var);\n\n  JSP_SAVE_EXECUTE();\n  if (!cond) jspSetNoExecute();\n  JsVar *a = jspeBlockOrStatement();\n  if (!cond) {\n    jsvUnLock(a);\n    JSP_RESTORE_EXECUTE();\n  } else {\n    result = a;\n  }\n  if (lex->tk==LEX_R_ELSE) {\n    JSP_ASSERT_MATCH(LEX_R_ELSE);\n    JSP_SAVE_EXECUTE();\n    if (cond) jspSetNoExecute();\n    JsVar *a = jspeBlockOrStatement();\n    if (cond) {\n      jsvUnLock(a);\n      JSP_RESTORE_EXECUTE();\n    } else {\n      result = a;\n    }\n  }\n  return result;\n}\n\nNO_INLINE JsVar *jspeStatementSwitch() {\n  JSP_ASSERT_MATCH(LEX_R_SWITCH);\n  JSP_MATCH('(');\n  JsVar *switchOn = jspeExpression();\n  JSP_SAVE_EXECUTE();\n  bool execute = JSP_SHOULD_EXECUTE;\n  JSP_MATCH_WITH_CLEANUP_AND_RETURN(')', jsvUnLock(switchOn), 0);\n  if (!execute) { jsvUnLock(switchOn); jspeBlock(); return 0; }\n  JSP_MATCH_WITH_CLEANUP_AND_RETURN('{', jsvUnLock(switchOn), 0);\n\n  bool executeDefault = true;\n  if (execute) execInfo.execute=EXEC_NO|EXEC_IN_SWITCH;\n  while (lex->tk==LEX_R_CASE) {\n    JSP_MATCH_WITH_CLEANUP_AND_RETURN(LEX_R_CASE, jsvUnLock(switchOn), 0);\n    JsExecFlags oldFlags = execInfo.execute;\n    if (execute) execInfo.execute=EXEC_YES|EXEC_IN_SWITCH;\n    JsVar *test = jspeAssignmentExpression();\n    execInfo.execute = oldFlags|EXEC_IN_SWITCH;;\n    JSP_MATCH_WITH_CLEANUP_AND_RETURN(':', jsvUnLock2(switchOn, test), 0);\n    bool cond = false;\n    if (execute)\n      cond = jsvGetBoolAndUnLock(jsvMathsOpSkipNames(switchOn, test, LEX_TYPEEQUAL));\n    if (cond) executeDefault = false;\n    jsvUnLock(test);\n    if (cond && (execInfo.execute&EXEC_RUN_MASK)==EXEC_NO)\n      execInfo.execute=EXEC_YES|EXEC_IN_SWITCH;\n    while (!JSP_SHOULDNT_PARSE && lex->tk!=LEX_EOF && lex->tk!=LEX_R_CASE && lex->tk!=LEX_R_DEFAULT && lex->tk!='}')\n      jsvUnLock(jspeBlockOrStatement());\n    oldExecute |= execInfo.execute & (EXEC_ERROR_MASK|EXEC_RETURN); // copy across any errors/exceptions/returns\n  }\n  jsvUnLock(switchOn);\n  if (execute && (execInfo.execute&EXEC_RUN_MASK)==EXEC_BREAK) {\n    execInfo.execute=EXEC_YES|EXEC_IN_SWITCH;\n  } else {\n    executeDefault = true;\n  }\n  JSP_RESTORE_EXECUTE();\n\n  if (lex->tk==LEX_R_DEFAULT) {\n    JSP_ASSERT_MATCH(LEX_R_DEFAULT);\n    JSP_MATCH(':');\n    JSP_SAVE_EXECUTE();\n    if (!executeDefault) jspSetNoExecute();\n    else execInfo.execute |= EXEC_IN_SWITCH;\n    while (!JSP_SHOULDNT_PARSE && lex->tk!=LEX_EOF && lex->tk!='}')\n      jsvUnLock(jspeBlockOrStatement());\n    oldExecute |= execInfo.execute & (EXEC_ERROR_MASK|EXEC_RETURN); // copy across any errors/exceptions/returns\n    execInfo.execute = execInfo.execute & (JsExecFlags)~EXEC_BREAK;\n    JSP_RESTORE_EXECUTE();\n  }\n  JSP_MATCH('}');\n", "target": 0, "idx": 82344}
{"func": "const Chapters::Display* Chapters::Atom::GetDisplay(int index) const\n{\n    if (index < 0)\n        return NULL;\n    if (index >= m_displays_count)\n        return NULL;\n    return m_displays + index;\n}\n", "target": 1, "idx": 188326}
{"func": "static int gdImageTileGet (gdImagePtr im, int x, int y)\n{\n\tint srcx, srcy;\n\tint tileColor,p;\n\tif (!im->tile) {\n\t\treturn -1;\n\t}\n\tsrcx = x % gdImageSX(im->tile);\n\tsrcy = y % gdImageSY(im->tile);\n\tp = gdImageGetPixel(im->tile, srcx, srcy);\n\n\tif (im->trueColor) {\n\t\tif (im->tile->trueColor) {\n\t\t\ttileColor = p;\n\t\t} else {\n\t\t\ttileColor = gdTrueColorAlpha( gdImageRed(im->tile,p), gdImageGreen(im->tile,p), gdImageBlue (im->tile,p), gdImageAlpha (im->tile,p));\n\t\t}\n\t} else {\n\t\tif (im->tile->trueColor) {\n\t\t\ttileColor = gdImageColorResolveAlpha(im, gdTrueColorGetRed (p), gdTrueColorGetGreen (p), gdTrueColorGetBlue (p), gdTrueColorGetAlpha (p));\n\t\t} else {\n\t\t\ttileColor = p;\n\t\t\ttileColor = gdImageColorResolveAlpha(im, gdImageRed (im->tile,p), gdImageGreen (im->tile,p), gdImageBlue (im->tile,p), gdImageAlpha (im->tile,p));\n\t\t}\n\t}\n\treturn tileColor;\n}\n", "target": 0, "idx": 51460}
{"func": "ofputil_decode_port_stats(struct ofputil_port_stats *ps, struct ofpbuf *msg)\n{\n    enum ofperr error;\n    enum ofpraw raw;\n\n    memset(&(ps->stats), 0xFF, sizeof (ps->stats));\n\n    error = (msg->header ? ofpraw_decode(&raw, msg->header)\n             : ofpraw_pull(&raw, msg));\n    if (error) {\n        return error;\n    }\n\n    if (!msg->size) {\n        return EOF;\n    } else if (raw == OFPRAW_OFPST14_PORT_REPLY) {\n        return ofputil_pull_ofp14_port_stats(ps, msg);\n    } else if (raw == OFPRAW_OFPST13_PORT_REPLY) {\n        const struct ofp13_port_stats *ps13;\n        ps13 = ofpbuf_try_pull(msg, sizeof *ps13);\n        if (!ps13) {\n            goto bad_len;\n        }\n        return ofputil_port_stats_from_ofp13(ps, ps13);\n    } else if (raw == OFPRAW_OFPST11_PORT_REPLY) {\n        const struct ofp11_port_stats *ps11;\n\n        ps11 = ofpbuf_try_pull(msg, sizeof *ps11);\n        if (!ps11) {\n            goto bad_len;\n        }\n        return ofputil_port_stats_from_ofp11(ps, ps11);\n    } else if (raw == OFPRAW_OFPST10_PORT_REPLY) {\n        const struct ofp10_port_stats *ps10;\n\n        ps10 = ofpbuf_try_pull(msg, sizeof *ps10);\n        if (!ps10) {\n            goto bad_len;\n        }\n        return ofputil_port_stats_from_ofp10(ps, ps10);\n    } else {\n        OVS_NOT_REACHED();\n    }\n\n bad_len:\n    VLOG_WARN_RL(&bad_ofmsg_rl, \"OFPST_PORT reply has %\"PRIu32\" leftover \"\n                 \"bytes at end\", msg->size);\n    return OFPERR_OFPBRC_BAD_LEN;\n}\n", "target": 0, "idx": 77531}
{"func": "OMX_ERRORTYPE  omx_video::use_input_buffer(\n        OMX_IN OMX_HANDLETYPE            hComp,\n        OMX_INOUT OMX_BUFFERHEADERTYPE** bufferHdr,\n        OMX_IN OMX_U32                   port,\n        OMX_IN OMX_PTR                   appData,\n        OMX_IN OMX_U32                   bytes,\n        OMX_IN OMX_U8*                   buffer)\n{\n (void) hComp;\n    OMX_ERRORTYPE eRet = OMX_ErrorNone;\n\n unsigned   i = 0;\n unsigned char *buf_addr = NULL;\n\n    DEBUG_PRINT_HIGH(\"use_input_buffer: port = %u appData = %p bytes = %u buffer = %p\",(unsigned int)port,appData,(unsigned int)bytes,buffer);\n if (bytes != m_sInPortDef.nBufferSize) {\n        DEBUG_PRINT_ERROR(\"ERROR: use_input_buffer: Size Mismatch!! \"\n \"bytes[%u] != Port.nBufferSize[%u]\", (unsigned int)bytes, (unsigned int)m_sInPortDef.nBufferSize);\n return OMX_ErrorBadParameter;\n }\n\n if (!m_inp_mem_ptr) {\n        input_use_buffer = true;\n        m_inp_mem_ptr = (OMX_BUFFERHEADERTYPE*) \\\n                        calloc( (sizeof(OMX_BUFFERHEADERTYPE)), m_sInPortDef.nBufferCountActual);\n if (m_inp_mem_ptr == NULL) {\n            DEBUG_PRINT_ERROR(\"ERROR: calloc() Failed for m_inp_mem_ptr\");\n return OMX_ErrorInsufficientResources;\n }\n        DEBUG_PRINT_LOW(\"Successfully allocated m_inp_mem_ptr = %p\", m_inp_mem_ptr);\n\n\n        m_pInput_pmem = (struct pmem *) calloc(sizeof (struct pmem), m_sInPortDef.nBufferCountActual);\n if (m_pInput_pmem == NULL) {\n            DEBUG_PRINT_ERROR(\"ERROR: calloc() Failed for m_pInput_pmem\");\n return OMX_ErrorInsufficientResources;\n }\n#ifdef USE_ION\n        m_pInput_ion = (struct venc_ion *) calloc(sizeof (struct venc_ion), m_sInPortDef.nBufferCountActual);\n if (m_pInput_ion == NULL) {\n            DEBUG_PRINT_ERROR(\"ERROR: calloc() Failed for m_pInput_ion\");\n return OMX_ErrorInsufficientResources;\n }\n#endif\n\n for (i=0; i< m_sInPortDef.nBufferCountActual; i++) {\n            m_pInput_pmem[i].fd = -1;\n#ifdef USE_ION\n            m_pInput_ion[i].ion_device_fd =-1;\n            m_pInput_ion[i].fd_ion_data.fd =-1;\n            m_pInput_ion[i].ion_alloc_data.handle = 0;\n#endif\n }\n\n }\n\n for (i=0; i< m_sInPortDef.nBufferCountActual; i++) {\n if (BITMASK_ABSENT(&m_inp_bm_count,i)) {\n break;\n }\n }\n\n if (i < m_sInPortDef.nBufferCountActual) {\n\n *bufferHdr = (m_inp_mem_ptr + i);\n        BITMASK_SET(&m_inp_bm_count,i);\n\n (*bufferHdr)->pBuffer           = (OMX_U8 *)buffer;\n (*bufferHdr)->nSize             = sizeof(OMX_BUFFERHEADERTYPE);\n (*bufferHdr)->nVersion.nVersion = OMX_SPEC_VERSION;\n (*bufferHdr)->nAllocLen         = m_sInPortDef.nBufferSize;\n (*bufferHdr)->pAppPrivate       = appData;\n (*bufferHdr)->nInputPortIndex   = PORT_INDEX_IN;\n\n if (!m_use_input_pmem) {\n#ifdef USE_ION\n#ifdef _MSM8974_\n            m_pInput_ion[i].ion_device_fd = alloc_map_ion_memory(m_sInPortDef.nBufferSize,\n &m_pInput_ion[i].ion_alloc_data,\n &m_pInput_ion[i].fd_ion_data,0);\n#else\n            m_pInput_ion[i].ion_device_fd = alloc_map_ion_memory(m_sInPortDef.nBufferSize,\n &m_pInput_ion[i].ion_alloc_data,\n &m_pInput_ion[i].fd_ion_data,ION_FLAG_CACHED);\n#endif\n if (m_pInput_ion[i].ion_device_fd < 0) {\n                DEBUG_PRINT_ERROR(\"ERROR:ION device open() Failed\");\n return OMX_ErrorInsufficientResources;\n }\n            m_pInput_pmem[i].fd = m_pInput_ion[i].fd_ion_data.fd;\n#else\n            m_pInput_pmem[i].fd = open (MEM_DEVICE,O_RDWR);\n if (m_pInput_pmem[i].fd == 0) {\n                m_pInput_pmem[i].fd = open (MEM_DEVICE,O_RDWR);\n }\n\n if (m_pInput_pmem[i] .fd < 0) {\n                DEBUG_PRINT_ERROR(\"ERROR: /dev/pmem_adsp open() Failed\");\n return OMX_ErrorInsufficientResources;\n }\n#endif\n\n             m_pInput_pmem[i].size = m_sInPortDef.nBufferSize;\n             m_pInput_pmem[i].offset = 0;\n \n            m_pInput_pmem[i].buffer = (OMX_U8 *)SECURE_BUFPTR;\n             if(!secure_session) {\n                 m_pInput_pmem[i].buffer = (unsigned char *)mmap(\n                     NULL,m_pInput_pmem[i].size,PROT_READ|PROT_WRITE,\n                    MAP_SHARED,m_pInput_pmem[i].fd,0);\n\n \n             if (m_pInput_pmem[i].buffer == MAP_FAILED) {\n                     DEBUG_PRINT_ERROR(\"ERROR: mmap() Failed\");\n                 close(m_pInput_pmem[i].fd);\n #ifdef USE_ION\n                 free_ion_memory(&m_pInput_ion[i]);\n#endif\n return OMX_ErrorInsufficientResources;\n }\n }\n\n } else {\n            OMX_QCOM_PLATFORM_PRIVATE_PMEM_INFO *pParam = reinterpret_cast<OMX_QCOM_PLATFORM_PRIVATE_PMEM_INFO *>((*bufferHdr)->pAppPrivate);\n            DEBUG_PRINT_LOW(\"Inside qcom_ext with luma:(fd:%lu,offset:0x%x)\", pParam->pmem_fd, (unsigned)pParam->offset);\n\n if (pParam) {\n                m_pInput_pmem[i].fd = pParam->pmem_fd;\n                m_pInput_pmem[i].offset = pParam->offset;\n                m_pInput_pmem[i].size = m_sInPortDef.nBufferSize;\n                m_pInput_pmem[i].buffer = (unsigned char *)buffer;\n                DEBUG_PRINT_LOW(\"DBG:: pParam->pmem_fd = %u, pParam->offset = %u\",\n (unsigned int)pParam->pmem_fd, (unsigned int)pParam->offset);\n } else {\n                DEBUG_PRINT_ERROR(\"ERROR: Invalid AppData given for PMEM i/p UseBuffer case\");\n return OMX_ErrorBadParameter;\n }\n }\n\n        DEBUG_PRINT_LOW(\"use_inp:: bufhdr = %p, pBuffer = %p, m_pInput_pmem[i].buffer = %p\",\n (*bufferHdr), (*bufferHdr)->pBuffer, m_pInput_pmem[i].buffer);\n if ( dev_use_buf(&m_pInput_pmem[i],PORT_INDEX_IN,i) != true) {\n            DEBUG_PRINT_ERROR(\"ERROR: dev_use_buf() Failed for i/p buf\");\n return OMX_ErrorInsufficientResources;\n }\n } else {\n        DEBUG_PRINT_ERROR(\"ERROR: All buffers are already used, invalid use_buf call for \"\n \"index = %u\", i);\n        eRet = OMX_ErrorInsufficientResources;\n }\n\n return eRet;\n}\n", "target": 1, "idx": 187525}
{"func": "void ShelfWidget::DelegateView::UpdateOpaqueBackground() {\n  const gfx::Rect local_bounds = GetLocalBounds();\n  gfx::Rect opaque_background_bounds = local_bounds;\n\n  const Shelf* shelf = shelf_widget_->shelf();\n  const ShelfBackgroundType background_type =\n      shelf_widget_->GetBackgroundType();\n\n  if (background_type == SHELF_BACKGROUND_APP_LIST) {\n    opaque_background_.SetVisible(false);\n    UpdateBackgroundBlur();\n    return;\n  }\n\n  if (!opaque_background_.visible())\n    opaque_background_.SetVisible(true);\n\n  const int radius = kShelfRoundedCornerRadius;\n  const int safety_margin = 3 * radius;\n  opaque_background_bounds.Inset(\n      -shelf->SelectValueForShelfAlignment(0, safety_margin, 0), 0,\n       -shelf->SelectValueForShelfAlignment(0, 0, safety_margin),\n       -shelf->SelectValueForShelfAlignment(safety_margin, 0, 0));\n \n  if (background_type == SHELF_BACKGROUND_MAXIMIZED ||\n      background_type == SHELF_BACKGROUND_SPLIT_VIEW) {\n     mask_ = nullptr;\n     opaque_background_.SetMaskLayer(nullptr);\n   } else {\n    if (!mask_) {\n      mask_ = views::Painter::CreatePaintedLayer(\n          views::Painter::CreateSolidRoundRectPainter(SK_ColorBLACK, radius));\n      mask_->layer()->SetFillsBoundsOpaquely(false);\n      opaque_background_.SetMaskLayer(mask_->layer());\n    }\n    if (mask_->layer()->bounds() != opaque_background_bounds)\n      mask_->layer()->SetBounds(opaque_background_bounds);\n  }\n  opaque_background_.SetBounds(opaque_background_bounds);\n  UpdateBackgroundBlur();\n  SchedulePaint();\n}\n", "target": 1, "idx": 186044}
{"func": "static void unix_detach_fds(struct scm_cookie *scm, struct sk_buff *skb)\n{\n\tint i;\n\n\tscm->fp = UNIXCB(skb).fp;\n \tUNIXCB(skb).fp = NULL;\n \n \tfor (i = scm->fp->count-1; i >= 0; i--)\n\t\tunix_notinflight(scm->fp->fp[i]);\n }\n", "target": 1, "idx": 180567}
{"func": " static zval *xml_call_handler(xml_parser *parser, zval *handler, zend_function *function_ptr, int argc, zval **argv)\n {\n       int i;  \n        TSRMLS_FETCH();\n \n        if (parser && handler && !EG(exception)) {\n\t\tzval ***args;\n\t\tzval *retval;\n\t\tint result;\n\t\tzend_fcall_info fci;\n\n\t\targs = safe_emalloc(sizeof(zval **), argc, 0);\n                for (i = 0; i < argc; i++) {\n                        args[i] = &argv[i];\n                }\n                fci.size = sizeof(fci);\n                fci.function_table = EG(function_table);\n                fci.function_name = handler;\n\t\tfci.symbol_table = NULL;\n\t\tfci.object_ptr = parser->object;\n\t\tfci.retval_ptr_ptr = &retval;\n\t\tfci.param_count = argc;\n\t\tfci.params = args;\n\t\tfci.no_separation = 0;\n\t\t/*fci.function_handler_cache = &function_ptr;*/\n\n\t\tresult = zend_call_function(&fci, NULL TSRMLS_CC);\n\t\tif (result == FAILURE) {\n\t\t\tzval **method;\n\t\t\tzval **obj;\n\n\t\t\tif (Z_TYPE_P(handler) == IS_STRING) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to call handler %s()\", Z_STRVAL_P(handler));\n\t\t\t} else if (zend_hash_index_find(Z_ARRVAL_P(handler), 0, (void **) &obj) == SUCCESS &&\n\t\t\t\t\t   zend_hash_index_find(Z_ARRVAL_P(handler), 1, (void **) &method) == SUCCESS &&\n                                           Z_TYPE_PP(obj) == IS_OBJECT &&\n                                           Z_TYPE_PP(method) == IS_STRING) {\n                                php_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to call handler %s::%s()\", Z_OBJCE_PP(obj)->name, Z_STRVAL_PP(method));\n                       } else \n                                php_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to call handler\");\n                }\n \n\t\tfor (i = 0; i < argc; i++) {\n\t\t\tzval_ptr_dtor(args[i]);\n\t\t}\n\t\tefree(args);\n\n\t\tif (result == FAILURE) {\n\t\t\treturn NULL;\n\t\t} else {\n\t\t\treturn EG(exception) ? NULL : retval;\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < argc; i++) {\n\t\t\tzval_ptr_dtor(&argv[i]);\n\t\t}\n\t\treturn NULL;\n\t}\n}\n", "target": 1, "idx": 178218}
{"func": "  parse_cmdline( int*     argc,\n                 char***  argv )\n  {\n    char*  execname;\n    int    option;\n\n\n    execname = ft_basename( (*argv)[0] );\n\n    while ( 1 )\n    {\n      option = getopt( *argc, *argv, \"e:m:r:\" );\n\n      if ( option == -1 )\n        break;\n\n      switch ( option )\n      {\n      case 'e':\n        status.encoding = FTDemo_Make_Encoding_Tag( optarg );\n        break;\n\n      case 'r':\n        status.res = atoi( optarg );\n        if ( status.res < 1 )\n          usage( execname );\n        break;\n\n      case 'm':\n        if ( *argc < 3 )\n          usage( execname );\n        Text = optarg;\n        break;\n\n      default:\n        usage( execname );\n        break;\n      }\n    }\n\n    *argc -= optind;\n    *argv += optind;\n\n    if ( *argc <= 1 )\n      usage( execname );\n\n    status.ptsize = (int)(atof( *argv[0] ) * 64.0);\n    if ( status.ptsize == 0 )\n      status.ptsize = 64;\n\n    (*argc)--;\n    (*argv)++;\n  }\n", "target": 0, "idx": 10049}
{"func": "static int usb_enumerate_device_otg(struct usb_device *udev)\n{\n\tint err = 0;\n\n#ifdef\tCONFIG_USB_OTG\n\t/*\n\t * OTG-aware devices on OTG-capable root hubs may be able to use SRP,\n\t * to wake us after we've powered off VBUS; and HNP, switching roles\n\t * \"host\" to \"peripheral\".  The OTG descriptor helps figure this out.\n\t */\n\tif (!udev->bus->is_b_host\n\t\t\t&& udev->config\n\t\t\t&& udev->parent == udev->bus->root_hub) {\n\t\tstruct usb_otg_descriptor\t*desc = NULL;\n\t\tstruct usb_bus\t\t\t*bus = udev->bus;\n\t\tunsigned\t\t\tport1 = udev->portnum;\n\n \t\t/* descriptor may appear anywhere in config */\n \t\terr = __usb_get_extra_descriptor(udev->rawdescriptors[0],\n \t\t\t\tle16_to_cpu(udev->config[0].desc.wTotalLength),\n\t\t\t\tUSB_DT_OTG, (void **) &desc);\n \t\tif (err || !(desc->bmAttributes & USB_OTG_HNP))\n \t\t\treturn 0;\n \n\t\tdev_info(&udev->dev, \"Dual-Role OTG device on %sHNP port\\n\",\n\t\t\t\t\t(port1 == bus->otg_port) ? \"\" : \"non-\");\n\n\t\t/* enable HNP before suspend, it's simpler */\n\t\tif (port1 == bus->otg_port) {\n\t\t\tbus->b_hnp_enable = 1;\n\t\t\terr = usb_control_msg(udev,\n\t\t\t\tusb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_SET_FEATURE, 0,\n\t\t\t\tUSB_DEVICE_B_HNP_ENABLE,\n\t\t\t\t0, NULL, 0,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\t\t\tif (err < 0) {\n\t\t\t\t/*\n\t\t\t\t * OTG MESSAGE: report errors here,\n\t\t\t\t * customize to match your product.\n\t\t\t\t */\n\t\t\t\tdev_err(&udev->dev, \"can't set HNP mode: %d\\n\",\n\t\t\t\t\t\t\t\t\terr);\n\t\t\t\tbus->b_hnp_enable = 0;\n\t\t\t}\n\t\t} else if (desc->bLength == sizeof\n\t\t\t\t(struct usb_otg_descriptor)) {\n\t\t\t/* Set a_alt_hnp_support for legacy otg device */\n\t\t\terr = usb_control_msg(udev,\n\t\t\t\tusb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_SET_FEATURE, 0,\n\t\t\t\tUSB_DEVICE_A_ALT_HNP_SUPPORT,\n\t\t\t\t0, NULL, 0,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\t\t\tif (err < 0)\n\t\t\t\tdev_err(&udev->dev,\n\t\t\t\t\t\"set a_alt_hnp_support failed: %d\\n\",\n\t\t\t\t\terr);\n\t\t}\n\t}\n#endif\n\treturn err;\n}\n", "target": 1, "idx": 182131}
{"func": "int ext4_punch_hole(struct inode *inode, loff_t offset, loff_t length)\n{\n\tstruct super_block *sb = inode->i_sb;\n\text4_lblk_t first_block, stop_block;\n\tstruct address_space *mapping = inode->i_mapping;\n\tloff_t first_block_offset, last_block_offset;\n\thandle_t *handle;\n\tunsigned int credits;\n\tint ret = 0;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\n\ttrace_ext4_punch_hole(inode, offset, length, 0);\n\n\t/*\n\t * Write out all dirty pages to avoid race conditions\n\t * Then release them.\n\t */\n\tif (mapping->nrpages && mapping_tagged(mapping, PAGECACHE_TAG_DIRTY)) {\n\t\tret = filemap_write_and_wait_range(mapping, offset,\n\t\t\t\t\t\t   offset + length - 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tmutex_lock(&inode->i_mutex);\n\n\t/* No need to punch hole beyond i_size */\n\tif (offset >= inode->i_size)\n\t\tgoto out_mutex;\n\n\t/*\n\t * If the hole extends beyond i_size, set the hole\n\t * to end after the page that contains i_size\n\t */\n\tif (offset + length > inode->i_size) {\n\t\tlength = inode->i_size +\n\t\t   PAGE_CACHE_SIZE - (inode->i_size & (PAGE_CACHE_SIZE - 1)) -\n\t\t   offset;\n\t}\n\n\tif (offset & (sb->s_blocksize - 1) ||\n\t    (offset + length) & (sb->s_blocksize - 1)) {\n\t\t/*\n\t\t * Attach jinode to inode for jbd2 if we do any zeroing of\n\t\t * partial block\n\t\t */\n\t\tret = ext4_inode_attach_jinode(inode);\n\t\tif (ret < 0)\n\t\t\tgoto out_mutex;\n \n \t}\n \n \tfirst_block_offset = round_up(offset, sb->s_blocksize);\n \tlast_block_offset = round_down((offset + length), sb->s_blocksize) - 1;\n \n\t/* Now release the pages and zero block aligned part of pages*/\n\tif (last_block_offset > first_block_offset)\n \t\ttruncate_pagecache_range(inode, first_block_offset,\n \t\t\t\t\t last_block_offset);\n \n\t/* Wait all existing dio workers, newcomers will block on i_mutex */\n\text4_inode_block_unlocked_dio(inode);\n\tinode_dio_wait(inode);\n \tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n \t\tcredits = ext4_writepage_trans_blocks(inode);\n \telse\n\t\tcredits = ext4_blocks_for_truncate(inode);\n\thandle = ext4_journal_start(inode, EXT4_HT_TRUNCATE, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\text4_std_error(sb, ret);\n\t\tgoto out_dio;\n\t}\n\n\tret = ext4_zero_partial_blocks(handle, inode, offset,\n\t\t\t\t       length);\n\tif (ret)\n\t\tgoto out_stop;\n\n\tfirst_block = (offset + sb->s_blocksize - 1) >>\n\t\tEXT4_BLOCK_SIZE_BITS(sb);\n\tstop_block = (offset + length) >> EXT4_BLOCK_SIZE_BITS(sb);\n\n\t/* If there are no blocks to remove, return now */\n\tif (first_block >= stop_block)\n\t\tgoto out_stop;\n\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\text4_discard_preallocations(inode);\n\n\tret = ext4_es_remove_extent(inode, first_block,\n\t\t\t\t    stop_block - first_block);\n\tif (ret) {\n\t\tup_write(&EXT4_I(inode)->i_data_sem);\n\t\tgoto out_stop;\n\t}\n\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\tret = ext4_ext_remove_space(inode, first_block,\n\t\t\t\t\t    stop_block - 1);\n\telse\n\t\tret = ext4_ind_remove_space(handle, inode, first_block,\n\t\t\t\t\t    stop_block);\n\n\tup_write(&EXT4_I(inode)->i_data_sem);\n \tif (IS_SYNC(inode))\n \t\text4_handle_sync(handle);\n \n\t/* Now release the pages again to reduce race window */\n\tif (last_block_offset > first_block_offset)\n\t\ttruncate_pagecache_range(inode, first_block_offset,\n\t\t\t\t\t last_block_offset);\n \tinode->i_mtime = inode->i_ctime = ext4_current_time(inode);\n \text4_mark_inode_dirty(handle, inode);\n out_stop:\n \text4_journal_stop(handle);\n out_dio:\n \text4_inode_resume_unlocked_dio(inode);\n out_mutex:\n \tmutex_unlock(&inode->i_mutex);\n\treturn ret;\n}\n", "target": 1, "idx": 180662}
{"func": "int ldb_dn_set_component(struct ldb_dn *dn, int num,\n\t\t\t const char *name, const struct ldb_val val)\n{\n\tchar *n;\n\tstruct ldb_val v;\n\n\tif ( ! ldb_dn_validate(dn)) {\n\t\treturn LDB_ERR_OTHER;\n\t}\n\n\tif (num >= dn->comp_num) {\n\t\treturn LDB_ERR_OTHER;\n\t}\n\n\tn = talloc_strdup(dn, name);\n\tif ( ! n) {\n\t\treturn LDB_ERR_OTHER;\n\t}\n\n\tv.length = val.length;\n\tv.data = (uint8_t *)talloc_memdup(dn, val.data, v.length+1);\n\tif ( ! v.data) {\n\t\ttalloc_free(n);\n\t\treturn LDB_ERR_OTHER;\n\t}\n\n\ttalloc_free(dn->components[num].name);\n\ttalloc_free(dn->components[num].value.data);\n\tdn->components[num].name = n;\n\tdn->components[num].value = v;\n\n\tif (dn->valid_case) {\n\t\tunsigned int i;\n\t\tfor (i = 0; i < dn->comp_num; i++) {\n\t\t\tLDB_FREE(dn->components[i].cf_name);\n\t\t\tLDB_FREE(dn->components[i].cf_value.data);\n\t\t}\n\t\tdn->valid_case = false;\n\t}\n\tLDB_FREE(dn->casefold);\n\tLDB_FREE(dn->linearized);\n\n\t/* Wipe the ext_linearized DN,\n\t * the GUID and SID are almost certainly no longer valid */\n\tLDB_FREE(dn->ext_linearized);\n\tLDB_FREE(dn->ext_components);\n\tdn->ext_comp_num = 0;\n\n\treturn LDB_SUCCESS;\n}\n", "target": 0, "idx": 2361}
{"func": "Document* LocalDOMWindow::InstallNewDocument(const String& mime_type,\n                                             const DocumentInit& init,\n                                             bool force_xhtml) {\n  DCHECK_EQ(init.GetFrame(), GetFrame());\n\n  ClearDocument();\n\n  document_ = CreateDocument(mime_type, init, force_xhtml);\n  event_queue_ = DOMWindowEventQueue::Create(document_.Get());\n  document_->Initialize();\n\n  if (!GetFrame())\n    return document_;\n\n  GetFrame()->GetScriptController().UpdateDocument();\n  document_->UpdateViewportDescription();\n\n  if (GetFrame()->GetPage() && GetFrame()->View()) {\n    GetFrame()->GetPage()->GetChromeClient().InstallSupplements(*GetFrame());\n\n    if (ScrollingCoordinator* scrolling_coordinator =\n            GetFrame()->GetPage()->GetScrollingCoordinator()) {\n      scrolling_coordinator->ScrollableAreaScrollbarLayerDidChange(\n          GetFrame()->View(), kHorizontalScrollbar);\n      scrolling_coordinator->ScrollableAreaScrollbarLayerDidChange(\n          GetFrame()->View(), kVerticalScrollbar);\n      scrolling_coordinator->ScrollableAreaScrollLayerDidChange(\n          GetFrame()->View());\n     }\n   }\n \n  GetFrame()->Selection().UpdateSecureKeyboardEntryIfActive();\n   if (GetFrame()->IsCrossOriginSubframe())\n     document_->RecordDeferredLoadReason(WouldLoadReason::kCreated);\n \n  return document_;\n}\n", "target": 1, "idx": 185732}
{"func": " status_t SampleTable::setTimeToSampleParams(\n         off64_t data_offset, size_t data_size) {\n    if (!mTimeToSample.empty() || data_size < 8) {\n         return ERROR_MALFORMED;\n     }\n \n uint8_t header[8];\n if (mDataSource->readAt(\n                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {\n return ERROR_IO;\n }\n\n if (U32_AT(header) != 0) {\n return ERROR_MALFORMED;\n }\n\n    mTimeToSampleCount = U32_AT(&header[4]);\n if ((uint64_t)mTimeToSampleCount >\n (uint64_t)UINT32_MAX / (2 * sizeof(uint32_t))) {\n        ALOGE(\"  Error: Time-to-sample table size too large.\");\n\n return ERROR_OUT_OF_RANGE;\n }\n\n if (!mDataSource->getVector(data_offset + 8, &mTimeToSample,\n                                mTimeToSampleCount * 2)) {\n        ALOGE(\"  Error: Incomplete data read for time-to-sample table.\");\n return ERROR_IO;\n }\n\n\n     for (size_t i = 0; i < mTimeToSample.size(); ++i) {\n         mTimeToSample.editItemAt(i) = ntohl(mTimeToSample[i]);\n     }\n     return OK;\n }\n", "target": 1, "idx": 187795}
{"func": "standard_row_validate(standard_display *dp, png_const_structp pp,\n int iImage, int iDisplay, png_uint_32 y)\n{\n int where;\n   png_byte std[STANDARD_ROWMAX];\n\n /* The row must be pre-initialized to the magic number here for the size\n    * tests to pass:\n    */\n   memset(std, 178, sizeof std);\n   standard_row(pp, std, dp->id, y);\n\n /* At the end both the 'row' and 'display' arrays should end up identical.\n\n     * In earlier passes 'row' will be partially filled in, with only the pixels\n     * that have been read so far, but 'display' will have those pixels\n     * replicated to fill the unread pixels while reading an interlaced image.\n#if PNG_LIBPNG_VER < 10506\n    * The side effect inside the libpng sequential reader is that the 'row'\n    * array retains the correct values for unwritten pixels within the row\n    * bytes, while the 'display' array gets bits off the end of the image (in\n    * the last byte) trashed.  Unfortunately in the progressive reader the\n    * row bytes are always trashed, so we always do a pixel_cmp here even though\n    * a memcmp of all cbRow bytes will succeed for the sequential reader.\n#endif\n     */\n    if (iImage >= 0 &&\n       (where = pixel_cmp(std, store_image_row(dp->ps, pp, iImage, y),\n            dp->bit_width)) != 0)\n {\n char msg[64];\n      sprintf(msg, \"PNG image row[%lu][%d] changed from %.2x to %.2x\",\n (unsigned long)y, where-1, std[where-1],\n         store_image_row(dp->ps, pp, iImage, y)[where-1]);\n\n       png_error(pp, msg);\n    }\n \n#if PNG_LIBPNG_VER < 10506\n   /* In this case use pixel_cmp because we need to compare a partial\n    * byte at the end of the row if the row is not an exact multiple\n    * of 8 bits wide.  (This is fixed in libpng-1.5.6 and pixel_cmp is\n    * changed to match!)\n    */\n#endif\n    if (iDisplay >= 0 &&\n       (where = pixel_cmp(std, store_image_row(dp->ps, pp, iDisplay, y),\n          dp->bit_width)) != 0)\n    {\n       char msg[64];\n      sprintf(msg, \"display  row[%lu][%d] changed from %.2x to %.2x\",\n          (unsigned long)y, where-1, std[where-1],\n          store_image_row(dp->ps, pp, iDisplay, y)[where-1]);\n       png_error(pp, msg);\n }\n}\n", "target": 1, "idx": 187723}
{"func": " cleanup_pathname(struct archive_write_disk *a)\n{\n\tchar *dest, *src;\n\tchar separator = '\\0';\n\n\tdest = src = a->name;\n\tif (*src == '\\0') {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"Invalid empty pathname\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n#if defined(__CYGWIN__)\n \tcleanup_pathname_win(a);\n #endif\n \t/* Skip leading '/'. */\n\tif (*src == '/')\n \t\tseparator = *src++;\n \n \t/* Scan the pathname one element at a time. */\n \tfor (;;) {\n\t\t/* src points to first char after '/' */\n\t\tif (src[0] == '\\0') {\n\t\t\tbreak;\n\t\t} else if (src[0] == '/') {\n\t\t\t/* Found '//', ignore second one. */\n\t\t\tsrc++;\n\t\t\tcontinue;\n\t\t} else if (src[0] == '.') {\n\t\t\tif (src[1] == '\\0') {\n\t\t\t\t/* Ignore trailing '.' */\n\t\t\t\tbreak;\n\t\t\t} else if (src[1] == '/') {\n\t\t\t\t/* Skip './'. */\n\t\t\t\tsrc += 2;\n\t\t\t\tcontinue;\n\t\t\t} else if (src[1] == '.') {\n\t\t\t\tif (src[2] == '/' || src[2] == '\\0') {\n\t\t\t\t\t/* Conditionally warn about '..' */\n\t\t\t\t\tif (a->flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {\n\t\t\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t\t\t\t    \"Path contains '..'\");\n\t\t\t\t\t\treturn (ARCHIVE_FAILED);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Note: Under no circumstances do we\n\t\t\t\t * remove '..' elements.  In\n\t\t\t\t * particular, restoring\n\t\t\t\t * '/foo/../bar/' should create the\n\t\t\t\t * 'foo' dir as a side-effect.\n\t\t\t\t */\n\t\t\t}\n\t\t}\n\n\t\t/* Copy current element, including leading '/'. */\n\t\tif (separator)\n\t\t\t*dest++ = '/';\n\t\twhile (*src != '\\0' && *src != '/') {\n\t\t\t*dest++ = *src++;\n\t\t}\n\n\t\tif (*src == '\\0')\n\t\t\tbreak;\n\n\t\t/* Skip '/' separator. */\n\t\tseparator = *src++;\n\t}\n\t/*\n\t * We've just copied zero or more path elements, not including the\n\t * final '/'.\n\t */\n\tif (dest == a->name) {\n\t\t/*\n\t\t * Nothing got copied.  The path must have been something\n\t\t * like '.' or '/' or './' or '/././././/./'.\n\t\t */\n\t\tif (separator)\n\t\t\t*dest++ = '/';\n\t\telse\n\t\t\t*dest++ = '.';\n\t}\n\t/* Terminate the result. */\n\t*dest = '\\0';\n\treturn (ARCHIVE_OK);\n}\n", "target": 1, "idx": 179853}
{"func": "int BN_hex2bn(BIGNUM **bn, const char *a)\n{\n    BIGNUM *ret = NULL;\n    BN_ULONG l = 0;\n    int neg = 0, h, m, i, j, k, c;\n    int num;\n\n    if ((a == NULL) || (*a == '\\0'))\n        return (0);\n\n    if (*a == '-') {\n        neg = 1;\n        a++;\n         a++;\n     }\n \n    for (i = 0; isxdigit((unsigned char)a[i]); i++) ;\n \n     num = i + neg;\n     if (bn == NULL)\n            return (0);\n    } else {\n        ret = *bn;\n        BN_zero(ret);\n    }\n", "target": 1, "idx": 178422}
{"func": "WORD32 ih264d_mark_err_slice_skip(dec_struct_t * ps_dec,\n                                WORD32 num_mb_skip,\n                                UWORD8 u1_is_idr_slice,\n                                UWORD16 u2_frame_num,\n pocstruct_t *ps_cur_poc,\n                                WORD32 prev_slice_err)\n{\n    WORD32 i2_cur_mb_addr;\n    UWORD32 u1_num_mbs, u1_num_mbsNby2;\n    UWORD32 u1_mb_idx = ps_dec->u1_mb_idx;\n    UWORD32 i2_mb_skip_run;\n\n    UWORD32 u1_num_mbs_next, u1_end_of_row;\n const UWORD32 i2_pic_wdin_mbs = ps_dec->u2_frm_wd_in_mbs;\n    UWORD32 u1_slice_end;\n    UWORD32 u1_tfr_n_mb;\n    UWORD32 u1_decode_nmb;\n dec_bit_stream_t * const ps_bitstrm = ps_dec->ps_bitstrm;\n dec_slice_params_t * ps_slice = ps_dec->ps_cur_slice;\n    UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;\n    UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;\n deblk_mb_t *ps_cur_deblk_mb;\n dec_mb_info_t *ps_cur_mb_info;\n parse_pmbarams_t *ps_parse_mb_data;\n    UWORD32 u1_inter_mb_type;\n    UWORD32 u1_deblk_mb_type;\n    UWORD16 u2_total_mbs_coded;\n    UWORD32 u1_mbaff = ps_slice->u1_mbaff_frame_flag;\n parse_part_params_t *ps_part_info;\n    WORD32 ret;\n\n\n if(ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC)\n {\n        ih264d_err_pic_dispbuf_mgr(ps_dec);\n return 0;\n }\n\n if(prev_slice_err == 1)\n {\n /* first slice - missing/header corruption */\n        ps_dec->ps_cur_slice->u2_frame_num = u2_frame_num;\n\n\n if(!ps_dec->u1_first_slice_in_stream)\n {\n            ih264d_end_of_pic(ps_dec, u1_is_idr_slice,\n                ps_dec->ps_cur_slice->u2_frame_num);\n            ps_dec->s_cur_pic_poc.u2_frame_num =\n                ps_dec->ps_cur_slice->u2_frame_num;\n }\n\n {\n            WORD32 i, j, poc = 0;\n\n            ps_dec->ps_cur_slice->u2_first_mb_in_slice = 0;\n\n            ps_dec->pf_mvpred = ih264d_mvpred_nonmbaff;\n            ps_dec->p_form_mb_part_info = ih264d_form_mb_part_info_bp;\n            ps_dec->p_motion_compensate = ih264d_motion_compensate_bp;\n\n if(ps_dec->ps_cur_pic != NULL)\n                poc = ps_dec->ps_cur_pic->i4_poc + 2;\n\n            j = 0;\n for(i = 0; i < MAX_NUM_PIC_PARAMS; i++)\n if(ps_dec->ps_pps[i].u1_is_valid == TRUE)\n                       j = i;\n {\n                ret = ih264d_start_of_pic(ps_dec, poc, ps_cur_poc,\n                        ps_dec->ps_cur_slice->u2_frame_num,\n &ps_dec->ps_pps[j]);\n\n if(ret != OK)\n {\n return ret;\n }\n }\n\n            ps_dec->ps_ref_pic_buf_lx[0][0]->u1_pic_buf_id = 0;\n\n            ps_dec->u4_output_present = 0;\n\n {\n                ih264d_get_next_display_field(ps_dec,\n                                              ps_dec->ps_out_buffer,\n &(ps_dec->s_disp_op));\n /* If error code is non-zero then there is no buffer available for display,\n                 hence avoid format conversion */\n\n if(0 != ps_dec->s_disp_op.u4_error_code)\n {\n                    ps_dec->u4_fmt_conv_cur_row = ps_dec->s_disp_frame_info.u4_y_ht;\n }\n else\n                    ps_dec->u4_output_present = 1;\n }\n\n if(ps_dec->u1_separate_parse == 1)\n {\n if(ps_dec->u4_dec_thread_created == 0)\n {\n                    ithread_create(ps_dec->pv_dec_thread_handle, NULL,\n (void *)ih264d_decode_picture_thread,\n (void *)ps_dec);\n\n                    ps_dec->u4_dec_thread_created = 1;\n }\n\n if((ps_dec->u4_num_cores == 3) &&\n ((ps_dec->u4_app_disable_deblk_frm == 0) || ps_dec->i1_recon_in_thread3_flag)\n && (ps_dec->u4_bs_deblk_thread_created == 0))\n {\n                    ps_dec->u4_start_recon_deblk = 0;\n                    ithread_create(ps_dec->pv_bs_deblk_thread_handle, NULL,\n (void *)ih264d_recon_deblk_thread,\n (void *)ps_dec);\n                    ps_dec->u4_bs_deblk_thread_created = 1;\n }\n }\n }\n }\n else\n {\n\n dec_slice_struct_t *ps_parse_cur_slice;\n        ps_parse_cur_slice = ps_dec->ps_dec_slice_buf + ps_dec->u2_cur_slice_num;\n\n if(ps_dec->u1_slice_header_done\n && ps_parse_cur_slice == ps_dec->ps_parse_cur_slice)\n {\n            u1_num_mbs = ps_dec->u4_num_mbs_cur_nmb;\n\n if(u1_num_mbs)\n {\n                ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs - 1;\n }\n else\n {\n if(ps_dec->u1_separate_parse)\n {\n                    ps_cur_mb_info = ps_dec->ps_nmb_info - 1;\n }\n else\n {\n                    ps_cur_mb_info = ps_dec->ps_nmb_info\n + ps_dec->u4_num_mbs_prev_nmb - 1;\n }\n }\n\n            ps_dec->u2_mby = ps_cur_mb_info->u2_mby;\n            ps_dec->u2_mbx = ps_cur_mb_info->u2_mbx;\n\n            ps_dec->u1_mb_ngbr_availablity =\n                    ps_cur_mb_info->u1_mb_ngbr_availablity;\n\n            ps_dec->pv_parse_tu_coeff_data = ps_dec->pv_prev_mb_parse_tu_coeff_data;\n            ps_dec->u2_cur_mb_addr--;\n            ps_dec->i4_submb_ofst -= SUB_BLK_SIZE;\n\n if(u1_num_mbs)\n {\n if (ps_dec->u1_pr_sl_type == P_SLICE\n || ps_dec->u1_pr_sl_type == B_SLICE)\n {\n                    ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx,    u1_num_mbs);\n                    ps_dec->ps_part = ps_dec->ps_parse_part_params;\n }\n\n                u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;\n                u1_end_of_row = (!u1_num_mbs_next)\n && (!(u1_mbaff && (u1_num_mbs & 0x01)));\n                u1_slice_end = 1;\n                u1_tfr_n_mb = 1;\n                ps_cur_mb_info->u1_end_of_slice = u1_slice_end;\n\n if(ps_dec->u1_separate_parse)\n {\n                    ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n                            u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\n                    ps_dec->ps_nmb_info += u1_num_mbs;\n }\n else\n {\n\n                     ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n                             u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\n                 }\n                 ps_dec->u1_mb_idx = 0;\n                 ps_dec->u4_num_mbs_cur_nmb = 0;\n             }\n\n if(ps_dec->u2_total_mbs_coded\n >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n {\n                ps_dec->u1_pic_decode_done = 1;\n return 0;\n }\n\n            ps_dec->u2_cur_slice_num++;\n             ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;\n            ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;\n            ps_dec->ps_parse_cur_slice++;\n\n }\n else\n {\n            ps_dec->ps_parse_cur_slice = ps_dec->ps_dec_slice_buf\n + ps_dec->u2_cur_slice_num;\n }\n }\n\n /******************************************************/\n /* Initializations to new slice                       */\n /******************************************************/\n {\n        WORD32 num_entries;\n        WORD32 size;\n        UWORD8 *pu1_buf;\n\n        num_entries = MIN(MAX_FRAMES, ps_dec->u4_num_ref_frames_at_init);\n        num_entries = 2 * ((2 * num_entries) + 1);\n\n        size = num_entries * sizeof(void *);\n        size += PAD_MAP_IDX_POC * sizeof(void *);\n\n        pu1_buf = (UWORD8 *)ps_dec->pv_map_ref_idx_to_poc_buf;\n        pu1_buf += size * ps_dec->u2_cur_slice_num;\n        ps_dec->ps_parse_cur_slice->ppv_map_ref_idx_to_poc = (volatile void **)pu1_buf;\n }\n\n    ps_dec->ps_cur_slice->u2_first_mb_in_slice = ps_dec->u2_total_mbs_coded << u1_mbaff;\n if(ps_dec->ps_cur_slice->u1_field_pic_flag)\n        ps_dec->u2_prv_frame_num = ps_dec->ps_cur_slice->u2_frame_num;\n\n    ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice = ps_dec->u2_total_mbs_coded << u1_mbaff;\n    ps_dec->ps_parse_cur_slice->u2_log2Y_crwd =    ps_dec->ps_cur_slice->u2_log2Y_crwd;\n\n\n if(ps_dec->u1_separate_parse)\n {\n        ps_dec->ps_parse_cur_slice->pv_tu_coeff_data_start = ps_dec->pv_parse_tu_coeff_data;\n }\n else\n {\n        ps_dec->pv_proc_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;\n }\n\n /******************************************************/\n /* Initializations specific to P slice                */\n /******************************************************/\n    u1_inter_mb_type = P_MB;\n    u1_deblk_mb_type = D_INTER_MB;\n\n    ps_dec->ps_cur_slice->u1_slice_type = P_SLICE;\n    ps_dec->ps_parse_cur_slice->slice_type = P_SLICE;\n    ps_dec->pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb;\n    ps_dec->ps_part = ps_dec->ps_parse_part_params;\n\n /******************************************************/\n /* Parsing / decoding the slice                       */\n /******************************************************/\n    ps_dec->u1_slice_header_done = 2;\n    ps_dec->u1_qp = ps_slice->u1_slice_qp;\n    ih264d_update_qp(ps_dec, 0);\n    u1_mb_idx = ps_dec->u1_mb_idx;\n    ps_parse_mb_data = ps_dec->ps_parse_mb_data;\n    u1_num_mbs = u1_mb_idx;\n\n    u1_slice_end = 0;\n    u1_tfr_n_mb = 0;\n    u1_decode_nmb = 0;\n    u1_num_mbsNby2 = 0;\n    i2_cur_mb_addr = ps_dec->u2_total_mbs_coded;\n    i2_mb_skip_run = num_mb_skip;\n\n while(!u1_slice_end)\n {\n        UWORD8 u1_mb_type;\n\n if(i2_cur_mb_addr > ps_dec->ps_cur_sps->u2_max_mb_addr)\n break;\n\n        ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs;\n        ps_dec->u4_num_mbs_cur_nmb = u1_num_mbs;\n\n        ps_cur_mb_info->u1_Mux = 0;\n        ps_dec->u4_num_pmbair = (u1_num_mbs >> u1_mbaff);\n        ps_cur_deblk_mb = ps_dec->ps_deblk_mbn + u1_num_mbs;\n\n        ps_cur_mb_info->u1_end_of_slice = 0;\n\n /* Storing Default partition info */\n        ps_parse_mb_data->u1_num_part = 1;\n        ps_parse_mb_data->u1_isI_mb = 0;\n\n /**************************************************************/\n /* Get the required information for decoding of MB            */\n /**************************************************************/\n /* mb_x, mb_y, neighbor availablity, */\n if (u1_mbaff)\n            ih264d_get_mb_info_cavlc_mbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);\n else\n            ih264d_get_mb_info_cavlc_nonmbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);\n\n /* Set the deblocking parameters for this MB */\n if(ps_dec->u4_app_disable_deblk_frm == 0)\n {\n            ih264d_set_deblocking_parameters(ps_cur_deblk_mb, ps_slice,\n                                             ps_dec->u1_mb_ngbr_availablity,\n                                             ps_dec->u1_cur_mb_fld_dec_flag);\n }\n\n /* Set appropriate flags in ps_cur_mb_info and ps_dec */\n        ps_dec->i1_prev_mb_qp_delta = 0;\n        ps_dec->u1_sub_mb_num = 0;\n        ps_cur_mb_info->u1_mb_type = MB_SKIP;\n        ps_cur_mb_info->u1_mb_mc_mode = PRED_16x16;\n        ps_cur_mb_info->u1_cbp = 0;\n\n /* Storing Skip partition info */\n        ps_part_info = ps_dec->ps_part;\n        ps_part_info->u1_is_direct = PART_DIRECT_16x16;\n        ps_part_info->u1_sub_mb_num = 0;\n        ps_dec->ps_part++;\n\n /* Update Nnzs */\n        ih264d_update_nnz_for_skipmb(ps_dec, ps_cur_mb_info, CAVLC);\n\n        ps_cur_mb_info->ps_curmb->u1_mb_type = u1_inter_mb_type;\n        ps_cur_deblk_mb->u1_mb_type |= u1_deblk_mb_type;\n\n        i2_mb_skip_run--;\n\n        ps_cur_deblk_mb->u1_mb_qp = ps_dec->u1_qp;\n\n if (u1_mbaff)\n {\n            ih264d_update_mbaff_left_nnz(ps_dec, ps_cur_mb_info);\n }\n\n /**************************************************************/\n /* Get next Macroblock address                                */\n /**************************************************************/\n\n         i2_cur_mb_addr++;\n \n         u1_num_mbs++;\n        ps_dec->u2_total_mbs_coded++;\n         u1_num_mbsNby2++;\n         ps_parse_mb_data++;\n \n /****************************************************************/\n /* Check for End Of Row and other flags that determine when to  */\n /* do DMA setup for N/2-Mb, Decode for N-Mb, and Transfer for   */\n /* N-Mb                                                         */\n /****************************************************************/\n        u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;\n        u1_end_of_row = (!u1_num_mbs_next) && (!(u1_mbaff && (u1_num_mbs & 0x01)));\n        u1_slice_end = !i2_mb_skip_run;\n        u1_tfr_n_mb = (u1_num_mbs == ps_dec->u1_recon_mb_grp) || u1_end_of_row\n || u1_slice_end;\n        u1_decode_nmb = u1_tfr_n_mb || u1_slice_end;\n        ps_cur_mb_info->u1_end_of_slice = u1_slice_end;\n\n if(u1_decode_nmb)\n {\n            ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx, u1_num_mbs);\n            u1_num_mbsNby2 = 0;\n\n            ps_parse_mb_data = ps_dec->ps_parse_mb_data;\n            ps_dec->ps_part = ps_dec->ps_parse_part_params;\n\n if(ps_dec->u1_separate_parse)\n {\n                ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n                                     u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\n                ps_dec->ps_nmb_info +=  u1_num_mbs;\n }\n else\n {\n\n                 ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs, u1_num_mbs_next,\n                                             u1_tfr_n_mb, u1_end_of_row);\n             }\n             if(u1_tfr_n_mb)\n                 u1_num_mbs = 0;\n             u1_mb_idx = u1_num_mbs;\n            ps_dec->u1_mb_idx = u1_num_mbs;\n }\n }\n\n    ps_dec->u4_num_mbs_cur_nmb = 0;\n    ps_dec->ps_cur_slice->u4_mbs_in_slice = i2_cur_mb_addr\n - ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice;\n\n    H264_DEC_DEBUG_PRINT(\"Mbs in slice: %d\\n\", ps_dec->ps_cur_slice->u4_mbs_in_slice);\n\n    ps_dec->u2_cur_slice_num++;\n\n /* incremented here only if first slice is inserted */\n if(ps_dec->u4_first_slice_in_pic != 0)\n        ps_dec->ps_parse_cur_slice++;\n\n    ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;\n    ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;\n\n if(ps_dec->u2_total_mbs_coded\n >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n {\n        ps_dec->u1_pic_decode_done = 1;\n }\n\n return 0;\n\n}\n", "target": 1, "idx": 187977}
{"func": " void TestingPlatformSupport::cryptographicallyRandomValues(unsigned char* buffer, size_t length)\n {\n }\n", "target": 1, "idx": 186207}
{"func": "status_t OMXNodeInstance::useBuffer(\n        OMX_U32 portIndex, const sp<IMemory> &params,\n        OMX::buffer_id *buffer, OMX_U32 allottedSize) {\n if (params == NULL || buffer == NULL) {\n        ALOGE(\"b/25884056\");\n return BAD_VALUE;\n\n     }\n \n     Mutex::Autolock autoLock(mLock);\n    if (allottedSize > params->size()) {\n         return BAD_VALUE;\n     }\n \n    BufferMeta *buffer_meta = new BufferMeta(params, portIndex);\n \n     OMX_BUFFERHEADERTYPE *header;\n \n     OMX_ERRORTYPE err = OMX_UseBuffer(\n             mHandle, &header, portIndex, buffer_meta,\n            allottedSize, static_cast<OMX_U8 *>(params->pointer()));\n \n     if (err != OMX_ErrorNone) {\n         CLOG_ERROR(useBuffer, err, SIMPLE_BUFFER(\n                portIndex, (size_t)allottedSize, params->pointer()));\n \n         delete buffer_meta;\n         buffer_meta = NULL;\n\n *buffer = 0;\n\n return StatusFromOMXError(err);\n }\n\n    CHECK_EQ(header->pAppPrivate, buffer_meta);\n\n *buffer = makeBufferID(header);\n\n    addActiveBuffer(portIndex, *buffer);\n\n    sp<GraphicBufferSource> bufferSource(getGraphicBufferSource());\n if (bufferSource != NULL && portIndex == kPortIndexInput) {\n        bufferSource->addCodecBuffer(header);\n }\n\n    CLOG_BUFFER(useBuffer, NEW_BUFFER_FMT(\n *buffer, portIndex, \"%u(%zu)@%p\", allottedSize, params->size(), params->pointer()));\n return OK;\n}\n", "target": 1, "idx": 188165}
{"func": "xmlParseCDSect(xmlParserCtxtPtr ctxt) {\n    xmlChar *buf = NULL;\n    int len = 0;\n    int size = XML_PARSER_BUFFER_SIZE;\n    int r, rl;\n    int\ts, sl;\n    int cur, l;\n    int count = 0;\n\n    /* Check 2.6.0 was NXT(0) not RAW */\n    if (CMP9(CUR_PTR, '<', '!', '[', 'C', 'D', 'A', 'T', 'A', '[')) {\n\tSKIP(9);\n    } else\n        return;\n\n    ctxt->instate = XML_PARSER_CDATA_SECTION;\n    r = CUR_CHAR(rl);\n    if (!IS_CHAR(r)) {\n\txmlFatalErr(ctxt, XML_ERR_CDATA_NOT_FINISHED, NULL);\n\tctxt->instate = XML_PARSER_CONTENT;\n        return;\n    }\n    NEXTL(rl);\n    s = CUR_CHAR(sl);\n    if (!IS_CHAR(s)) {\n\txmlFatalErr(ctxt, XML_ERR_CDATA_NOT_FINISHED, NULL);\n\tctxt->instate = XML_PARSER_CONTENT;\n        return;\n    }\n    NEXTL(sl);\n    cur = CUR_CHAR(l);\n    buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));\n    if (buf == NULL) {\n\txmlErrMemory(ctxt, NULL);\n\treturn;\n    }\n    while (IS_CHAR(cur) &&\n           ((r != ']') || (s != ']') || (cur != '>'))) {\n\tif (len + 5 >= size) {\n\t    xmlChar *tmp;\n\n\t    size *= 2;\n\t    tmp = (xmlChar *) xmlRealloc(buf, size * sizeof(xmlChar));\n\t    if (tmp == NULL) {\n\t        xmlFree(buf);\n\t\txmlErrMemory(ctxt, NULL);\n\t\treturn;\n\t    }\n\t    buf = tmp;\n\t}\n\tCOPY_BUF(rl,buf,len,r);\n\tr = s;\n\trl = sl;\n\ts = cur;\n\tsl = l;\n \tcount++;\n \tif (count > 50) {\n \t    GROW;\n \t    count = 0;\n \t}\n \tNEXTL(l);\n\tcur = CUR_CHAR(l);\n    }\n    buf[len] = 0;\n    ctxt->instate = XML_PARSER_CONTENT;\n    if (cur != '>') {\n\txmlFatalErrMsgStr(ctxt, XML_ERR_CDATA_NOT_FINISHED,\n\t                     \"CData section not finished\\n%.50s\\n\", buf);\n\txmlFree(buf);\n        return;\n    }\n    NEXTL(l);\n\n    /*\n     * OK the buffer is to be consumed as cdata.\n     */\n    if ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {\n\tif (ctxt->sax->cdataBlock != NULL)\n\t    ctxt->sax->cdataBlock(ctxt->userData, buf, len);\n\telse if (ctxt->sax->characters != NULL)\n\t    ctxt->sax->characters(ctxt->userData, buf, len);\n    }\n    xmlFree(buf);\n}\n", "target": 1, "idx": 184965}
{"func": "void HWNDMessageHandler::Init(HWND parent, const gfx::Rect& bounds) {\n  TRACE_EVENT0(\"views\", \"HWNDMessageHandler::Init\");\n  GetMonitorAndRects(bounds.ToRECT(), &last_monitor_, &last_monitor_rect_,\n                     &last_work_area_);\n \n   WindowImpl::Init(parent, bounds);\n }\n", "target": 1, "idx": 185493}
{"func": " e1000e_ring_empty(E1000ECore *core, const E1000E_RingInfo *r)\n {\n    return core->mac[r->dh] == core->mac[r->dt];\n }\n", "target": 1, "idx": 177971}
{"func": " nm_ip4_config_commit (const NMIP4Config *config, int ifindex, guint32 default_route_metric)\n {\n \tNMIP4ConfigPrivate *priv = NM_IP4_CONFIG_GET_PRIVATE (config);\n\tguint32 mtu = nm_ip4_config_get_mtu (config);\n \tint i;\n \n \tg_return_val_if_fail (ifindex > 0, FALSE);\n\tg_return_val_if_fail (ifindex > 0, FALSE);\n\tg_return_val_if_fail (config != NULL, FALSE);\n\n\t/* Addresses */\n\tnm_platform_ip4_address_sync (ifindex, priv->addresses, default_route_metric);\n\n\t/* Routes */\n\t{\n\t\tint count = nm_ip4_config_get_num_routes (config);\n\t\tGArray *routes = g_array_sized_new (FALSE, FALSE, sizeof (NMPlatformIP4Route), count);\n\t\tconst NMPlatformIP4Route *route;\n\t\tgboolean success;\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\troute = nm_ip4_config_get_route (config, i);\n\n\t\t\t/* Don't add the route if it's more specific than one of the subnets\n\t\t\t * the device already has an IP address on.\n\t\t\t */\n\t\t\tif (   route->gateway == 0\n\t\t\t    && nm_ip4_config_destination_is_direct (config, route->network, route->plen))\n\t\t\t\tcontinue;\n\n\t\t\tg_array_append_vals (routes, route, 1);\n\t\t}\n\n\t\tsuccess = nm_route_manager_ip4_route_sync (nm_route_manager_get (), ifindex, routes);\n\t\tg_array_unref (routes);\n \t\t\treturn FALSE;\n \t}\n \n\t/* MTU */\n\tif (mtu && mtu != nm_platform_link_get_mtu (ifindex))\n\t\tnm_platform_link_set_mtu (ifindex, mtu);\n \treturn TRUE;\n }\n", "target": 1, "idx": 177987}
{"func": "void RenderWidgetHostViewAura::ExtendSelectionAndDelete(\n    size_t before, size_t after) {\n  RenderFrameHostImpl* rfh = GetFocusedFrame();\n  if (rfh)\n    rfh->ExtendSelectionAndDelete(before, after);\n}\n", "target": 0, "idx": 144900}
{"func": "static int sctp_wait_for_sndbuf(struct sctp_association *asoc, long *timeo_p,\n\t\t\t\tsize_t msg_len)\n{\n\tstruct sock *sk = asoc->base.sk;\n\tint err = 0;\n\tlong current_timeo = *timeo_p;\n\tDEFINE_WAIT(wait);\n\n\tpr_debug(\"%s: asoc:%p, timeo:%ld, msg_len:%zu\\n\", __func__, asoc,\n\t\t *timeo_p, msg_len);\n\n\t/* Increment the association's refcnt.  */\n\tsctp_association_hold(asoc);\n\n\t/* Wait on the association specific sndbuf space. */\n\tfor (;;) {\n\t\tprepare_to_wait_exclusive(&asoc->wait, &wait,\n\t\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (!*timeo_p)\n\t\t\tgoto do_nonblock;\n\t\tif (sk->sk_err || asoc->state >= SCTP_STATE_SHUTDOWN_PENDING ||\n\t\t    asoc->base.dead)\n\t\t\tgoto do_error;\n\t\tif (signal_pending(current))\n\t\t\tgoto do_interrupted;\n\t\tif (msg_len <= sctp_wspace(asoc))\n\t\t\tbreak;\n\n\t\t/* Let another process have a go.  Since we are going\n\t\t * to sleep anyway.\n \t\t */\n \t\trelease_sock(sk);\n \t\tcurrent_timeo = schedule_timeout(current_timeo);\n\t\tBUG_ON(sk != asoc->base.sk);\n \t\tlock_sock(sk);\n \n \t\t*timeo_p = current_timeo;\n\t}\n\nout:\n\tfinish_wait(&asoc->wait, &wait);\n\n\t/* Release the association's refcnt.  */\n\tsctp_association_put(asoc);\n\n\treturn err;\n\ndo_error:\n\terr = -EPIPE;\n\tgoto out;\n\ndo_interrupted:\n\terr = sock_intr_errno(*timeo_p);\n\tgoto out;\n\ndo_nonblock:\n\terr = -EAGAIN;\n\tgoto out;\n}\n", "target": 1, "idx": 181540}
{"func": "static int adjust_insn_aux_data(struct bpf_verifier_env *env, u32 prog_len,\n\t\t\t\tu32 off, u32 cnt)\n{\n\tstruct bpf_insn_aux_data *new_data, *old_data = env->insn_aux_data;\n\n\tif (cnt == 1)\n\t\treturn 0;\n\tnew_data = vzalloc(sizeof(struct bpf_insn_aux_data) * prog_len);\n\tif (!new_data)\n\t\treturn -ENOMEM;\n\tmemcpy(new_data, old_data, sizeof(struct bpf_insn_aux_data) * off);\n\tmemcpy(new_data + off + cnt - 1, old_data + off,\n\t       sizeof(struct bpf_insn_aux_data) * (prog_len - off - cnt + 1));\n\tenv->insn_aux_data = new_data;\n\tvfree(old_data);\n\treturn 0;\n}\n", "target": 0, "idx": 65025}
{"func": "static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,\n\t\t\t\t   size_t count, loff_t *offset)\n{\n\tstruct snd_timer_user *tu;\n\tlong result = 0, unit;\n\tint qhead;\n\tint err = 0;\n \n \ttu = file->private_data;\n \tunit = tu->tread ? sizeof(struct snd_timer_tread) : sizeof(struct snd_timer_read);\n \tspin_lock_irq(&tu->qlock);\n \twhile ((long)count - result >= unit) {\n \t\twhile (!tu->qused) {\n\t\t\twait_queue_t wait;\n\n\t\t\tif ((file->f_flags & O_NONBLOCK) != 0 || result > 0) {\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tgoto _error;\n\t\t\t}\n\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tinit_waitqueue_entry(&wait, current);\n \t\t\tadd_wait_queue(&tu->qchange_sleep, &wait);\n \n \t\t\tspin_unlock_irq(&tu->qlock);\n \t\t\tschedule();\n \t\t\tspin_lock_irq(&tu->qlock);\n \n \t\t\tremove_wait_queue(&tu->qchange_sleep, &wait);\n\n\t\t\tif (tu->disconnected) {\n\t\t\t\terr = -ENODEV;\n\t\t\t\tgoto _error;\n\t\t\t}\n\t\t\tif (signal_pending(current)) {\n\t\t\t\terr = -ERESTARTSYS;\n\t\t\t\tgoto _error;\n\t\t\t}\n\t\t}\n\n\t\tqhead = tu->qhead++;\n\t\ttu->qhead %= tu->queue_size;\n \t\ttu->qused--;\n \t\tspin_unlock_irq(&tu->qlock);\n \n\t\tmutex_lock(&tu->ioctl_lock);\n \t\tif (tu->tread) {\n \t\t\tif (copy_to_user(buffer, &tu->tqueue[qhead],\n \t\t\t\t\t sizeof(struct snd_timer_tread)))\n\t\t\t\terr = -EFAULT;\n\t\t} else {\n\t\t\tif (copy_to_user(buffer, &tu->queue[qhead],\n \t\t\t\t\t sizeof(struct snd_timer_read)))\n \t\t\t\terr = -EFAULT;\n \t\t}\n\t\tmutex_unlock(&tu->ioctl_lock);\n \n \t\tspin_lock_irq(&tu->qlock);\n \t\tif (err < 0)\n\t\t\tgoto _error;\n\t\tresult += unit;\n\t\tbuffer += unit;\n \t}\n  _error:\n \tspin_unlock_irq(&tu->qlock);\n \treturn result > 0 ? result : err;\n }\n", "target": 1, "idx": 183180}
{"func": "context_length_arg (char const *str, int *out)\n {\n  uintmax_t value;\n  if (! (xstrtoumax (str, 0, 10, &value, \"\") == LONGINT_OK\n         && 0 <= (*out = value)\n         && *out == value))\n     {\n       error (EXIT_TROUBLE, 0, \"%s: %s\", str,\n              _(\"invalid context length argument\"));\n     }\n   page size, unless a read yields a partial page.  */\n\nstatic char *buffer;\t\t/* Base of buffer. */\nstatic size_t bufalloc;\t\t/* Allocated buffer size, counting slop. */\n#define INITIAL_BUFSIZE 32768\t/* Initial buffer size, not counting slop. */\nstatic int bufdesc;\t\t/* File descriptor. */\nstatic char *bufbeg;\t\t/* Beginning of user-visible stuff. */\nstatic char *buflim;\t\t/* Limit of user-visible stuff. */\nstatic size_t pagesize;\t\t/* alignment of memory pages */\nstatic off_t bufoffset;\t\t/* Read offset; defined on regular files.  */\nstatic off_t after_last_match;\t/* Pointer after last matching line that\n                                   would have been output if we were\n                                   outputting characters. */\n\n/* Return VAL aligned to the next multiple of ALIGNMENT.  VAL can be\n   an integer or a pointer.  Both args must be free of side effects.  */\n#define ALIGN_TO(val, alignment) \\\n  ((size_t) (val) % (alignment) == 0 \\\n   ? (val) \\\n   : (val) + ((alignment) - (size_t) (val) % (alignment)))\n\n/* Reset the buffer for a new file, returning zero if we should skip it.\n   Initialize on the first time through. */\nstatic int\nreset (int fd, char const *file, struct stats *stats)\n{\n  if (! pagesize)\n    {\n      pagesize = getpagesize ();\n      if (pagesize == 0 || 2 * pagesize + 1 <= pagesize)\n        abort ();\n      bufalloc = ALIGN_TO (INITIAL_BUFSIZE, pagesize) + pagesize + 1;\n      buffer = xmalloc (bufalloc);\n    }\n\n  bufbeg = buflim = ALIGN_TO (buffer + 1, pagesize);\n  bufbeg[-1] = eolbyte;\n  bufdesc = fd;\n\n  if (S_ISREG (stats->stat.st_mode))\n    {\n      if (file)\n        bufoffset = 0;\n      else\n        {\n          bufoffset = lseek (fd, 0, SEEK_CUR);\n          if (bufoffset < 0)\n            {\n              suppressible_error (_(\"lseek failed\"), errno);\n              return 0;\n            }\n        }\n    }\n  return 1;\n}\n\n/* Read new stuff into the buffer, saving the specified\n   amount of old stuff.  When we're done, 'bufbeg' points\n   to the beginning of the buffer contents, and 'buflim'\n   points just after the end.  Return zero if there's an error.  */\nstatic int\nfillbuf (size_t save, struct stats const *stats)\n{\n  size_t fillsize = 0;\n  int cc = 1;\n  char *readbuf;\n  size_t readsize;\n\n  /* Offset from start of buffer to start of old stuff\n     that we want to save.  */\n  size_t saved_offset = buflim - save - buffer;\n\n  if (pagesize <= buffer + bufalloc - buflim)\n    {\n      readbuf = buflim;\n      bufbeg = buflim - save;\n    }\n  else\n    {\n      size_t minsize = save + pagesize;\n      size_t newsize;\n      size_t newalloc;\n      char *newbuf;\n\n      /* Grow newsize until it is at least as great as minsize.  */\n      for (newsize = bufalloc - pagesize - 1; newsize < minsize; newsize *= 2)\n        if (newsize * 2 < newsize || newsize * 2 + pagesize + 1 < newsize * 2)\n          xalloc_die ();\n\n      /* Try not to allocate more memory than the file size indicates,\n         as that might cause unnecessary memory exhaustion if the file\n         is large.  However, do not use the original file size as a\n         heuristic if we've already read past the file end, as most\n         likely the file is growing.  */\n      if (S_ISREG (stats->stat.st_mode))\n        {\n          off_t to_be_read = stats->stat.st_size - bufoffset;\n          off_t maxsize_off = save + to_be_read;\n          if (0 <= to_be_read && to_be_read <= maxsize_off\n              && maxsize_off == (size_t) maxsize_off\n              && minsize <= (size_t) maxsize_off\n              && (size_t) maxsize_off < newsize)\n            newsize = maxsize_off;\n        }\n\n      /* Add enough room so that the buffer is aligned and has room\n         for byte sentinels fore and aft.  */\n      newalloc = newsize + pagesize + 1;\n\n      newbuf = bufalloc < newalloc ? xmalloc (bufalloc = newalloc) : buffer;\n      readbuf = ALIGN_TO (newbuf + 1 + save, pagesize);\n      bufbeg = readbuf - save;\n      memmove (bufbeg, buffer + saved_offset, save);\n      bufbeg[-1] = eolbyte;\n      if (newbuf != buffer)\n        {\n          free (buffer);\n          buffer = newbuf;\n        }\n    }\n\n  readsize = buffer + bufalloc - readbuf;\n  readsize -= readsize % pagesize;\n\n  if (! fillsize)\n    {\n      ssize_t bytesread;\n      while ((bytesread = read (bufdesc, readbuf, readsize)) < 0\n             && errno == EINTR)\n        continue;\n      if (bytesread < 0)\n        cc = 0;\n      else\n        fillsize = bytesread;\n    }\n\n  bufoffset += fillsize;\n#if defined HAVE_DOS_FILE_CONTENTS\n  if (fillsize)\n    fillsize = undossify_input (readbuf, fillsize);\n#endif\n  buflim = readbuf + fillsize;\n  return cc;\n}\n\n/* Flags controlling the style of output. */\nstatic enum\n{\n  BINARY_BINARY_FILES,\n  TEXT_BINARY_FILES,\n  WITHOUT_MATCH_BINARY_FILES\n} binary_files;\t\t/* How to handle binary files.  */\n\nstatic int filename_mask;\t/* If zero, output nulls after filenames.  */\nstatic int out_quiet;\t\t/* Suppress all normal output. */\nstatic int out_invert;\t\t/* Print nonmatching stuff. */\nstatic int out_file;\t\t/* Print filenames. */\nstatic int out_line;\t\t/* Print line numbers. */\nstatic int out_byte;\t\t/* Print byte offsets. */\nstatic int out_before;\t\t/* Lines of leading context. */\nstatic int out_after;\t\t/* Lines of trailing context. */\n static int out_file;\t\t/* Print filenames. */\n static int out_line;\t\t/* Print line numbers. */\n static int out_byte;\t\t/* Print byte offsets. */\nstatic int out_before;\t\t/* Lines of leading context. */\nstatic int out_after;\t\t/* Lines of trailing context. */\n static int count_matches;\t/* Count matching lines.  */\n static int list_files;\t\t/* List matching files.  */\n static int no_filenames;\t/* Suppress file names.  */\nstatic off_t max_count;\t\t/* Stop after outputting this many\n                                    lines from an input file.  */\n static int line_buffered;       /* If nonzero, use line buffering, i.e.\n                                    fflush everyline out.  */\nstatic char const *lastnl;\t/* Pointer after last newline counted. */\nstatic char const *lastout;\t/* Pointer after last character output;\n                                   NULL if no character has been output\n                                   or if it's conceptually before bufbeg. */\nstatic uintmax_t totalnl;\t/* Total newline count before lastnl. */\nstatic off_t outleft;\t\t/* Maximum number of lines to be output.  */\nstatic int pending;\t\t/* Pending lines of output.\n                                    NULL if no character has been output\n                                    or if it's conceptually before bufbeg. */\n static uintmax_t totalnl;\t/* Total newline count before lastnl. */\nstatic off_t outleft;\t\t/* Maximum number of lines to be output.  */\nstatic int pending;\t\t/* Pending lines of output.\n                                    Always kept 0 if out_quiet is true.  */\n static int done_on_match;\t/* Stop scanning file on first match.  */\n static int exit_on_match;\t/* Exit on first match.  */\n/* Add two numbers that count input bytes or lines, and report an\n   error if the addition overflows.  */\nstatic uintmax_t\nadd_count (uintmax_t a, uintmax_t b)\n{\n  uintmax_t sum = a + b;\n  if (sum < a)\n    error (EXIT_TROUBLE, 0, _(\"input is too large to count\"));\n  return sum;\n}\n\nstatic void\nnlscan (char const *lim)\n{\n  size_t newlines = 0;\n  char const *beg;\n  for (beg = lastnl; beg < lim; beg++)\n    {\n      beg = memchr (beg, eolbyte, lim - beg);\n      if (!beg)\n        break;\n      newlines++;\n    }\n  totalnl = add_count (totalnl, newlines);\n  lastnl = lim;\n}\n\n/* Print the current filename.  */\nstatic void\nprint_filename (void)\n{\n  pr_sgr_start_if (filename_color);\n  fputs (filename, stdout);\n  pr_sgr_end_if (filename_color);\n}\n\n/* Print a character separator.  */\nstatic void\nprint_sep (char sep)\n{\n  pr_sgr_start_if (sep_color);\n  fputc (sep, stdout);\n  pr_sgr_end_if (sep_color);\n}\n\n/* Print a line number or a byte offset.  */\nstatic void\nprint_offset (uintmax_t pos, int min_width, const char *color)\n{\n  /* Do not rely on printf to print pos, since uintmax_t may be longer\n     than long, and long long is not portable.  */\n\n  char buf[sizeof pos * CHAR_BIT];\n  char *p = buf + sizeof buf;\n\n  do\n    {\n      *--p = '0' + pos % 10;\n      --min_width;\n    }\n  while ((pos /= 10) != 0);\n\n  /* Do this to maximize the probability of alignment across lines.  */\n  if (align_tabs)\n    while (--min_width >= 0)\n      *--p = ' ';\n\n  pr_sgr_start_if (color);\n  fwrite (p, 1, buf + sizeof buf - p, stdout);\n  pr_sgr_end_if (color);\n}\n\n/* Print a whole line head (filename, line, byte).  */\nstatic void\nprint_line_head (char const *beg, char const *lim, int sep)\n{\n  int pending_sep = 0;\n\n  if (out_file)\n    {\n      print_filename ();\n      if (filename_mask)\n        pending_sep = 1;\n      else\n        fputc (0, stdout);\n    }\n\n  if (out_line)\n    {\n      if (lastnl < lim)\n        {\n          nlscan (beg);\n          totalnl = add_count (totalnl, 1);\n          lastnl = lim;\n        }\n      if (pending_sep)\n        print_sep (sep);\n      print_offset (totalnl, 4, line_num_color);\n      pending_sep = 1;\n    }\n\n  if (out_byte)\n    {\n      uintmax_t pos = add_count (totalcc, beg - bufbeg);\n#if defined HAVE_DOS_FILE_CONTENTS\n      pos = dossified_pos (pos);\n#endif\n      if (pending_sep)\n        print_sep (sep);\n      print_offset (pos, 6, byte_num_color);\n      pending_sep = 1;\n    }\n\n  if (pending_sep)\n    {\n      /* This assumes sep is one column wide.\n         Try doing this any other way with Unicode\n         (and its combining and wide characters)\n         filenames and you're wasting your efforts.  */\n      if (align_tabs)\n        fputs (\"\\t\\b\", stdout);\n\n      print_sep (sep);\n    }\n}\n\nstatic const char *\nprint_line_middle (const char *beg, const char *lim,\n                   const char *line_color, const char *match_color)\n{\n  size_t match_size;\n  size_t match_offset;\n  const char *cur = beg;\n  const char *mid = NULL;\n\n  while (cur < lim\n         && ((match_offset = execute (beg, lim - beg, &match_size,\n                                      beg + (cur - beg))) != (size_t) -1))\n    {\n      char const *b = beg + match_offset;\n\n      /* Avoid matching the empty line at the end of the buffer. */\n      if (b == lim)\n        break;\n\n      /* Avoid hanging on grep --color \"\" foo */\n      if (match_size == 0)\n        {\n          /* Make minimal progress; there may be further non-empty matches.  */\n          /* XXX - Could really advance by one whole multi-octet character.  */\n          match_size = 1;\n          if (!mid)\n            mid = cur;\n        }\n      else\n        {\n          /* This function is called on a matching line only,\n             but is it selected or rejected/context?  */\n          if (only_matching)\n            print_line_head (b, lim, (out_invert ? SEP_CHAR_REJECTED\n                                      : SEP_CHAR_SELECTED));\n          else\n            {\n              pr_sgr_start (line_color);\n              if (mid)\n                {\n                  cur = mid;\n                  mid = NULL;\n                }\n              fwrite (cur, sizeof (char), b - cur, stdout);\n            }\n\n          pr_sgr_start_if (match_color);\n          fwrite (b, sizeof (char), match_size, stdout);\n          pr_sgr_end_if (match_color);\n          if (only_matching)\n            fputs (\"\\n\", stdout);\n        }\n      cur = b + match_size;\n    }\n\n  if (only_matching)\n    cur = lim;\n  else if (mid)\n    cur = mid;\n\n  return cur;\n}\n\nstatic const char *\nprint_line_tail (const char *beg, const char *lim, const char *line_color)\n{\n  size_t eol_size;\n  size_t tail_size;\n\n  eol_size   = (lim > beg && lim[-1] == eolbyte);\n  eol_size  += (lim - eol_size > beg && lim[-(1 + eol_size)] == '\\r');\n  tail_size  =  lim - eol_size - beg;\n\n  if (tail_size > 0)\n    {\n      pr_sgr_start (line_color);\n      fwrite (beg, 1, tail_size, stdout);\n      beg += tail_size;\n      pr_sgr_end (line_color);\n    }\n\n  return beg;\n}\n\nstatic void\nprline (char const *beg, char const *lim, int sep)\n{\n  int matching;\n  const char *line_color;\n  const char *match_color;\n\n  if (!only_matching)\n    print_line_head (beg, lim, sep);\n\n  matching = (sep == SEP_CHAR_SELECTED) ^ !!out_invert;\n\n  if (color_option)\n    {\n      line_color = (((sep == SEP_CHAR_SELECTED)\n                     ^ (out_invert && (color_option < 0)))\n                    ? selected_line_color  : context_line_color);\n      match_color = (sep == SEP_CHAR_SELECTED\n                     ? selected_match_color : context_match_color);\n    }\n  else\n    line_color = match_color = NULL; /* Shouldn't be used.  */\n\n  if ((only_matching && matching)\n      || (color_option  && (*line_color || *match_color)))\n    {\n      /* We already know that non-matching lines have no match (to colorize).  */\n      if (matching && (only_matching || *match_color))\n        beg = print_line_middle (beg, lim, line_color, match_color);\n\n      /* FIXME: this test may be removable.  */\n      if (!only_matching && *line_color)\n        beg = print_line_tail (beg, lim, line_color);\n    }\n\n  if (!only_matching && lim > beg)\n    fwrite (beg, 1, lim - beg, stdout);\n\n  if (ferror (stdout))\n    {\n      write_error_seen = 1;\n      error (EXIT_TROUBLE, 0, _(\"write error\"));\n    }\n\n  lastout = lim;\n\n  if (line_buffered)\n    fflush (stdout);\n}\n\n/* Print pending lines of trailing context prior to LIM. Trailing context ends\n   at the next matching line when OUTLEFT is 0.  */\nstatic void\nprpending (char const *lim)\n{\n  if (!lastout)\n    lastout = bufbeg;\n  while (pending > 0 && lastout < lim)\n    {\n      char const *nl = memchr (lastout, eolbyte, lim - lastout);\n      size_t match_size;\n      --pending;\n      if (outleft\n          || ((execute (lastout, nl + 1 - lastout,\n                        &match_size, NULL) == (size_t) -1)\n              == !out_invert))\n        prline (lastout, nl + 1, SEP_CHAR_REJECTED);\n      else\n        pending = 0;\n    }\n}\n\n/* Print the lines between BEG and LIM.  Deal with context crap.\n   If NLINESP is non-null, store a count of lines between BEG and LIM.  */\nstatic void\nprtext (char const *beg, char const *lim, int *nlinesp)\n{\n /* Print the lines between BEG and LIM.  Deal with context crap.\n    If NLINESP is non-null, store a count of lines between BEG and LIM.  */\n static void\nprtext (char const *beg, char const *lim, int *nlinesp)\n {\n   static int used;\t/* avoid printing SEP_STR_GROUP before any output */\n   char const *bp, *p;\n   char eol = eolbyte;\n  int i, n;\n \n   if (!out_quiet && pending > 0)\n     prpending (beg);\n      /* Deal with leading context crap. */\n\n      bp = lastout ? lastout : bufbeg;\n      for (i = 0; i < out_before; ++i)\n        if (p > bp)\n          do\n            --p;\n          while (p[-1] != eol);\n\n      /* We print the SEP_STR_GROUP separator only if our output is\n         discontiguous from the last output in the file. */\n      if ((out_before || out_after) && used && p != lastout && group_separator)\n        {\n          pr_sgr_start_if (sep_color);\n          fputs (group_separator, stdout);\n          pr_sgr_end_if (sep_color);\n          fputc ('\\n', stdout);\n        }\n\n      while (p < beg)\n        {\n          char const *nl = memchr (p, eol, beg - p);\n          nl++;\n          prline (p, nl, SEP_CHAR_REJECTED);\n          p = nl;\n        }\n    }\n\n  if (nlinesp)\n    {\n      /* Caller wants a line count. */\n      for (n = 0; p < lim && n < outleft; n++)\n        {\n          char const *nl = memchr (p, eol, lim - p);\n          nl++;\n          if (!out_quiet)\n            prline (p, nl, SEP_CHAR_SELECTED);\n          p = nl;\n        }\n      *nlinesp = n;\n\n      /* relying on it that this function is never called when outleft = 0.  */\n      after_last_match = bufoffset - (buflim - p);\n    }\n  else if (!out_quiet)\n    prline (beg, lim, SEP_CHAR_SELECTED);\n\n  pending = out_quiet ? 0 : out_after;\n  used = 1;\n}\n\nstatic size_t\ndo_execute (char const *buf, size_t size, size_t *match_size, char const *start_ptr)\n{\n  size_t result;\n  const char *line_next;\n\n  /* With the current implementation, using --ignore-case with a multi-byte\n     character set is very inefficient when applied to a large buffer\n     containing many matches.  We can avoid much of the wasted effort\n     by matching line-by-line.\n\n     FIXME: this is just an ugly workaround, and it doesn't really\n     belong here.  Also, PCRE is always using this same per-line\n     matching algorithm.  Either we fix -i, or we should refactor\n     this code---for example, we could add another function pointer\n     to struct matcher to split the buffer passed to execute.  It would\n     perform the memchr if line-by-line matching is necessary, or just\n     return buf + size otherwise.  */\n  if (MB_CUR_MAX == 1 || !match_icase)\n    return execute (buf, size, match_size, start_ptr);\n\n  for (line_next = buf; line_next < buf + size; )\n    {\n      const char *line_buf = line_next;\n      const char *line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);\n      if (line_end == NULL)\n        line_next = line_end = buf + size;\n      else\n        line_next = line_end + 1;\n\n      if (start_ptr && start_ptr >= line_end)\n        continue;\n\n      result = execute (line_buf, line_next - line_buf, match_size, start_ptr);\n      if (result != (size_t) -1)\n        return (line_buf - buf) + result;\n    }\n\n  return (size_t) -1;\n}\n\n/* Scan the specified portion of the buffer, matching lines (or\n   between matching lines if OUT_INVERT is true).  Return a count of\n   lines printed. */\nstatic int\ngrepbuf (char const *beg, char const *lim)\n /* Scan the specified portion of the buffer, matching lines (or\n    between matching lines if OUT_INVERT is true).  Return a count of\n    lines printed. */\nstatic int\n grepbuf (char const *beg, char const *lim)\n {\n  int nlines, n;\n   char const *p;\n   size_t match_offset;\n   size_t match_size;\n    {\n      char const *b = p + match_offset;\n      char const *endp = b + match_size;\n      /* Avoid matching the empty line at the end of the buffer. */\n      if (b == lim)\n        break;\n      if (!out_invert)\n        {\n          prtext (b, endp, (int *) 0);\n          nlines++;\n         break;\n       if (!out_invert)\n         {\n          prtext (b, endp, (int *) 0);\n           nlines++;\n           outleft--;\n           if (!outleft || done_on_match)\n            }\n        }\n      else if (p < b)\n        {\n          prtext (p, b, &n);\n          nlines += n;\n          outleft -= n;\n          if (!outleft)\n            return nlines;\n        }\n      p = endp;\n    }\n  if (out_invert && p < lim)\n    {\n      prtext (p, lim, &n);\n      nlines += n;\n      outleft -= n;\n    }\n  return nlines;\n}\n\n/* Search a given file.  Normally, return a count of lines printed;\n   but if the file is a directory and we search it recursively, then\n   return -2 if there was a match, and -1 otherwise.  */\nstatic int\ngrep (int fd, char const *file, struct stats *stats)\n /* Search a given file.  Normally, return a count of lines printed;\n    but if the file is a directory and we search it recursively, then\n    return -2 if there was a match, and -1 otherwise.  */\nstatic int\n grep (int fd, char const *file, struct stats *stats)\n {\n  int nlines, i;\n   int not_text;\n   size_t residue, save;\n   char oldc;\n    return 0;\n\n  if (file && directories == RECURSE_DIRECTORIES\n      && S_ISDIR (stats->stat.st_mode))\n    {\n      /* Close fd now, so that we don't open a lot of file descriptors\n         when we recurse deeply.  */\n      if (close (fd) != 0)\n        suppressible_error (file, errno);\n      return grepdir (file, stats) - 2;\n    }\n\n  totalcc = 0;\n  lastout = 0;\n  totalnl = 0;\n  outleft = max_count;\n  after_last_match = 0;\n  pending = 0;\n\n  nlines = 0;\n  residue = 0;\n  save = 0;\n\n  if (! fillbuf (save, stats))\n    {\n      suppressible_error (filename, errno);\n      return 0;\n    }\n\n  not_text = (((binary_files == BINARY_BINARY_FILES && !out_quiet)\n               || binary_files == WITHOUT_MATCH_BINARY_FILES)\n              && memchr (bufbeg, eol ? '\\0' : '\\200', buflim - bufbeg));\n  if (not_text && binary_files == WITHOUT_MATCH_BINARY_FILES)\n    return 0;\n  done_on_match += not_text;\n  out_quiet += not_text;\n\n  for (;;)\n    {\n      lastnl = bufbeg;\n      if (lastout)\n        lastout = bufbeg;\n\n      beg = bufbeg + save;\n\n      /* no more data to scan (eof) except for maybe a residue -> break */\n      if (beg == buflim)\n        break;\n\n      /* Determine new residue (the length of an incomplete line at the end of\n         the buffer, 0 means there is no incomplete last line).  */\n      oldc = beg[-1];\n      beg[-1] = eol;\n      for (lim = buflim; lim[-1] != eol; lim--)\n        continue;\n      beg[-1] = oldc;\n      if (lim == beg)\n        lim = beg - residue;\n      beg -= residue;\n      residue = buflim - lim;\n\n      if (beg < lim)\n        {\n          if (outleft)\n            nlines += grepbuf (beg, lim);\n          if (pending)\n            prpending (lim);\n          if ((!outleft && !pending) || (nlines && done_on_match && !out_invert))\n            goto finish_grep;\n        }\n\n      /* The last OUT_BEFORE lines at the end of the buffer will be needed as\n         leading context if there is a matching line at the begin of the\n         next data. Make beg point to their begin.  */\n      i = 0;\n      beg = lim;\n      while (i < out_before && beg > bufbeg && beg != lastout)\n        {\n          ++i;\n          do\n            --beg;\n          while (beg[-1] != eol);\n        }\n\n      /* detect if leading context is discontinuous from last printed line.  */\n      if (beg != lastout)\n        lastout = 0;\n\n      /* Handle some details and read more data to scan.  */\n      save = residue + lim - beg;\n      if (out_byte)\n        totalcc = add_count (totalcc, buflim - bufbeg - save);\n      if (out_line)\n        nlscan (beg);\n      if (! fillbuf (save, stats))\n        {\n          suppressible_error (filename, errno);\n          goto finish_grep;\n        }\n    }\n  if (residue)\n    {\n      *buflim++ = eol;\n      if (outleft)\n        nlines += grepbuf (bufbeg + save - residue, buflim);\n      if (pending)\n        prpending (buflim);\n    }\n\n finish_grep:\n  done_on_match -= not_text;\n  out_quiet -= not_text;\n  if ((not_text & ~out_quiet) && nlines != 0)\n    printf (_(\"Binary file %s matches\\n\"), filename);\n  return nlines;\n}\n\nstatic int\ngrepfile (char const *file, struct stats *stats)\n{\n  int desc;\n  int count;\n  int status;\n grepfile (char const *file, struct stats *stats)\n {\n   int desc;\n  int count;\n   int status;\n \n   filename = (file ? file : label ? label : _(\"(standard input)\"));\n      /* Don't open yet, since that might have side effects on a device.  */\n      desc = -1;\n    }\n  else\n    {\n      /* When skipping directories, don't worry about directories\n         that can't be opened.  */\n      desc = open (file, O_RDONLY);\n      if (desc < 0 && directories != SKIP_DIRECTORIES)\n        {\n          suppressible_error (file, errno);\n          return 1;\n        }\n    }\n\n  if (desc < 0\n      ? stat (file, &stats->stat) != 0\n      : fstat (desc, &stats->stat) != 0)\n    {\n      suppressible_error (filename, errno);\n      if (file)\n        close (desc);\n      return 1;\n    }\n\n  if ((directories == SKIP_DIRECTORIES && S_ISDIR (stats->stat.st_mode))\n      || (devices == SKIP_DEVICES && (S_ISCHR (stats->stat.st_mode)\n                                      || S_ISBLK (stats->stat.st_mode)\n                                      || S_ISSOCK (stats->stat.st_mode)\n                                      || S_ISFIFO (stats->stat.st_mode))))\n    {\n      if (file)\n        close (desc);\n      return 1;\n    }\n\n  /* If there is a regular file on stdout and the current file refers\n     to the same i-node, we have to report the problem and skip it.\n     Otherwise when matching lines from some other input reach the\n     disk before we open this file, we can end up reading and matching\n     those lines and appending them to the file from which we're reading.\n     Then we'd have what appears to be an infinite loop that'd terminate\n     only upon filling the output file system or reaching a quota.\n     However, there is no risk of an infinite loop if grep is generating\n     no output, i.e., with --silent, --quiet, -q.\n     Similarly, with any of these:\n       --max-count=N (-m) (for N >= 2)\n       --files-with-matches (-l)\n       --files-without-match (-L)\n     there is no risk of trouble.\n     For --max-count=1, grep stops after printing the first match,\n     so there is no risk of malfunction.  But even --max-count=2, with\n     input==output, while there is no risk of infloop, there is a race\n     condition that could result in \"alternate\" output.  */\n  if (!out_quiet && list_files == 0 && 1 < max_count\n      && S_ISREG (out_stat.st_mode) && out_stat.st_ino\n      && SAME_INODE (stats->stat, out_stat))\n    {\n      if (! suppress_errors)\n        error (0, 0, _(\"input file %s is also the output\"), quote (filename));\n      errseen = 1;\n      if (file)\n        close (desc);\n      return 1;\n    }\n\n  if (desc < 0)\n    {\n      desc = open (file, O_RDONLY);\n      if (desc < 0)\n        {\n          suppressible_error (file, errno);\n          return 1;\n        }\n    }\n\n#if defined SET_BINARY\n  /* Set input to binary mode.  Pipes are simulated with files\n     on DOS, so this includes the case of \"foo | grep bar\".  */\n  if (!isatty (desc))\n    SET_BINARY (desc);\n#endif\n\n  count = grep (desc, file, stats);\n  if (count < 0)\n    status = count + 2;\n  else\n    {\n      if (count_matches)\n        {\n          if (out_file)\n            {\n              print_filename ();\n              if (filename_mask)\n                print_sep (SEP_CHAR_SELECTED);\n              else\n                fputc (0, stdout);\n            }\n          printf (\"%d\\n\", count);\n        }\n               else\n                 fputc (0, stdout);\n             }\n          printf (\"%d\\n\", count);\n         }\n \n       status = !count;\n\n      if (! file)\n        {\n          off_t required_offset = outleft ? bufoffset : after_last_match;\n          if (required_offset != bufoffset\n              && lseek (desc, required_offset, SEEK_SET) < 0\n              && S_ISREG (stats->stat.st_mode))\n            suppressible_error (filename, errno);\n        }\n      else\n        while (close (desc) != 0)\n          if (errno != EINTR)\n            {\n              suppressible_error (file, errno);\n              break;\n            }\n    }\n", "target": 1, "idx": 177996}
{"func": "int __hid_register_driver(struct hid_driver *hdrv, struct module *owner,\n\t\tconst char *mod_name)\n{\n\tint ret;\n\n\thdrv->driver.name = hdrv->name;\n\thdrv->driver.bus = &hid_bus_type;\n\thdrv->driver.owner = owner;\n\thdrv->driver.mod_name = mod_name;\n\n\tINIT_LIST_HEAD(&hdrv->dyn_list);\n\tspin_lock_init(&hdrv->dyn_lock);\n\n\tret = driver_register(&hdrv->driver);\n\tif (ret)\n\t\treturn ret;\n\n\tret = driver_create_file(&hdrv->driver, &driver_attr_new_id);\n\tif (ret)\n\t\tdriver_unregister(&hdrv->driver);\n\n\treturn ret;\n}\n", "target": 0, "idx": 49472}
{"func": "SPL_METHOD(Array, unserialize)\n{\n\tspl_array_object *intern = (spl_array_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tchar *buf;\n\tint buf_len;\n\tconst unsigned char *p, *s;\n\tphp_unserialize_data_t var_hash;\n\tzval *pmembers, *pflags = NULL;\n\tHashTable *aht;\n\tlong flags;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &buf, &buf_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (buf_len == 0) {\n\t\treturn;\n\t}\n\n\taht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);\n\tif (aht->nApplyCount > 0) {\n\t\tzend_error(E_WARNING, \"Modification of ArrayObject during sorting is prohibited\");\n\t\treturn;\n\t}\n\n\t/* storage */\n\ts = p = (const unsigned char*)buf;\n\tPHP_VAR_UNSERIALIZE_INIT(var_hash);\n\n\tif (*p!= 'x' || *++p != ':') {\n\t\tgoto outexcept;\n\t}\n\t++p;\n\n\tALLOC_INIT_ZVAL(pflags);\n\tif (!php_var_unserialize(&pflags, &p, s + buf_len, &var_hash TSRMLS_CC) || Z_TYPE_P(pflags) != IS_LONG) {\n\t\tgoto outexcept;\n\t}\n\n\tvar_push_dtor(&var_hash, &pflags);\n\t--p; /* for ';' */\n\tflags = Z_LVAL_P(pflags);\n\t/* flags needs to be verified and we also need to verify whether the next\n\t * thing we get is ';'. After that we require an 'm' or somethign else\n\t * where 'm' stands for members and anything else should be an array. If\n\t * neither 'a' or 'm' follows we have an error. */\n\n\tif (*p != ';') {\n\t\tgoto outexcept;\n\t}\n\t++p;\n\n\tif (*p!='m') {\n\t\tif (*p!='a' && *p!='O' && *p!='C' && *p!='r') {\n\t\t\tgoto outexcept;\n\t\t}\n\t\tintern->ar_flags &= ~SPL_ARRAY_CLONE_MASK;\n \t\tintern->ar_flags |= flags & SPL_ARRAY_CLONE_MASK;\n \t\tzval_ptr_dtor(&intern->array);\n \t\tALLOC_INIT_ZVAL(intern->array);\n\t\tif (!php_var_unserialize(&intern->array, &p, s + buf_len, &var_hash TSRMLS_CC)) {\n \t\t\tgoto outexcept;\n \t\t}\n \t\tvar_push_dtor(&var_hash, &intern->array);\n\t}\n\tif (*p != ';') {\n\t\tgoto outexcept;\n\t}\n\t++p;\n\n\t/* members */\n\tif (*p!= 'm' || *++p != ':') {\n\t\tgoto outexcept;\n\t}\n\t++p;\n\n\tALLOC_INIT_ZVAL(pmembers);\n\tif (!php_var_unserialize(&pmembers, &p, s + buf_len, &var_hash TSRMLS_CC) || Z_TYPE_P(pmembers) != IS_ARRAY) {\n\t\tzval_ptr_dtor(&pmembers);\n\t\tgoto outexcept;\n\t}\n\n\tvar_push_dtor(&var_hash, &pmembers);\n\t/* copy members */\n\tif (!intern->std.properties) {\n\t\trebuild_object_properties(&intern->std);\n\t}\n\tzend_hash_copy(intern->std.properties, Z_ARRVAL_P(pmembers), (copy_ctor_func_t) zval_add_ref, (void *) NULL, sizeof(zval *));\n\tzval_ptr_dtor(&pmembers);\n\n\t/* done reading $serialized */\n\n\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\tif (pflags) {\n\t\tzval_ptr_dtor(&pflags);\n\t}\n\treturn;\n\noutexcept:\n\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\tif (pflags) {\n\t\tzval_ptr_dtor(&pflags);\n\t}\n\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Error at offset %ld of %d bytes\", (long)((char*)p - buf), buf_len);\n\treturn;\n\n} /* }}} */\n\n/* {{{ arginfo and function table */\n", "target": 1, "idx": 180102}
{"func": "void ImageCapture::UpdateMediaTrackCapabilities(\n    media::mojom::blink::PhotoStatePtr photo_state) {\n  if (!photo_state)\n    return;\n\n  WTF::Vector<WTF::String> supported_white_balance_modes;\n  supported_white_balance_modes.ReserveInitialCapacity(\n      photo_state->supported_white_balance_modes.size());\n  for (const auto& supported_mode : photo_state->supported_white_balance_modes)\n    supported_white_balance_modes.push_back(ToString(supported_mode));\n  if (!supported_white_balance_modes.IsEmpty()) {\n    capabilities_.setWhiteBalanceMode(std::move(supported_white_balance_modes));\n    settings_.setWhiteBalanceMode(\n        ToString(photo_state->current_white_balance_mode));\n  }\n\n  WTF::Vector<WTF::String> supported_exposure_modes;\n  supported_exposure_modes.ReserveInitialCapacity(\n      photo_state->supported_exposure_modes.size());\n  for (const auto& supported_mode : photo_state->supported_exposure_modes)\n    supported_exposure_modes.push_back(ToString(supported_mode));\n  if (!supported_exposure_modes.IsEmpty()) {\n    capabilities_.setExposureMode(std::move(supported_exposure_modes));\n    settings_.setExposureMode(ToString(photo_state->current_exposure_mode));\n  }\n\n  WTF::Vector<WTF::String> supported_focus_modes;\n  supported_focus_modes.ReserveInitialCapacity(\n      photo_state->supported_focus_modes.size());\n  for (const auto& supported_mode : photo_state->supported_focus_modes)\n    supported_focus_modes.push_back(ToString(supported_mode));\n  if (!supported_focus_modes.IsEmpty()) {\n    capabilities_.setFocusMode(std::move(supported_focus_modes));\n    settings_.setFocusMode(ToString(photo_state->current_focus_mode));\n  }\n\n  HeapVector<Point2D> current_points_of_interest;\n  if (!photo_state->points_of_interest.IsEmpty()) {\n    for (const auto& point : photo_state->points_of_interest) {\n      Point2D web_point;\n      web_point.setX(point->x);\n      web_point.setY(point->y);\n      current_points_of_interest.push_back(mojo::Clone(web_point));\n    }\n  }\n  settings_.setPointsOfInterest(std::move(current_points_of_interest));\n\n  if (photo_state->exposure_compensation->max !=\n      photo_state->exposure_compensation->min) {\n    capabilities_.setExposureCompensation(\n        MediaSettingsRange::Create(*photo_state->exposure_compensation));\n    settings_.setExposureCompensation(\n        photo_state->exposure_compensation->current);\n  }\n  if (photo_state->color_temperature->max !=\n      photo_state->color_temperature->min) {\n    capabilities_.setColorTemperature(\n        MediaSettingsRange::Create(*photo_state->color_temperature));\n    settings_.setColorTemperature(photo_state->color_temperature->current);\n  }\n  if (photo_state->iso->max != photo_state->iso->min) {\n    capabilities_.setIso(MediaSettingsRange::Create(*photo_state->iso));\n    settings_.setIso(photo_state->iso->current);\n  }\n\n  if (photo_state->brightness->max != photo_state->brightness->min) {\n    capabilities_.setBrightness(\n        MediaSettingsRange::Create(*photo_state->brightness));\n    settings_.setBrightness(photo_state->brightness->current);\n  }\n  if (photo_state->contrast->max != photo_state->contrast->min) {\n    capabilities_.setContrast(\n        MediaSettingsRange::Create(*photo_state->contrast));\n    settings_.setContrast(photo_state->contrast->current);\n  }\n  if (photo_state->saturation->max != photo_state->saturation->min) {\n    capabilities_.setSaturation(\n        MediaSettingsRange::Create(*photo_state->saturation));\n    settings_.setSaturation(photo_state->saturation->current);\n  }\n  if (photo_state->sharpness->max != photo_state->sharpness->min) {\n    capabilities_.setSharpness(\n        MediaSettingsRange::Create(*photo_state->sharpness));\n    settings_.setSharpness(photo_state->sharpness->current);\n  }\n\n  if (photo_state->zoom->max != photo_state->zoom->min) {\n    capabilities_.setZoom(MediaSettingsRange::Create(*photo_state->zoom));\n    settings_.setZoom(photo_state->zoom->current);\n  }\n\n  if (photo_state->supports_torch)\n    capabilities_.setTorch(photo_state->supports_torch);\n  if (photo_state->supports_torch)\n    settings_.setTorch(photo_state->torch);\n}\n", "target": 0, "idx": 163914}
{"func": "Chapters::Chapters(\n    Segment* pSegment,\n    long long payload_start,\n    long long payload_size,\n    long long element_start,\n    long long element_size) :\n    m_pSegment(pSegment),\n    m_start(payload_start),\n    m_size(payload_size),\n    m_element_start(element_start),\n    m_element_size(element_size),\n    m_editions(NULL),\n    m_editions_size(0),\n    m_editions_count(0)\n{\n}\n", "target": 1, "idx": 188265}
{"func": "DownloadManagerDelegate::ApplicationClientIdForFileScanning() const {\n  return std::string();\n}\n", "target": 0, "idx": 159280}
{"func": "int ff_mov_write_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    MOVMuxContext *mov = s->priv_data;\n    AVIOContext *pb = s->pb;\n    MOVTrack *trk = &mov->tracks[pkt->stream_index];\n    AVCodecParameters *par = trk->par;\n    unsigned int samples_in_chunk = 0;\n    int size = pkt->size, ret = 0;\n    uint8_t *reformatted_data = NULL;\n\n    ret = check_pkt(s, pkt);\n    if (ret < 0)\n        return ret;\n\n    if (mov->flags & FF_MOV_FLAG_FRAGMENT) {\n        int ret;\n        if (mov->moov_written || mov->flags & FF_MOV_FLAG_EMPTY_MOOV) {\n            if (mov->frag_interleave && mov->fragments > 0) {\n                if (trk->entry - trk->entries_flushed >= mov->frag_interleave) {\n                    if ((ret = mov_flush_fragment_interleaving(s, trk)) < 0)\n                        return ret;\n                }\n            }\n\n            if (!trk->mdat_buf) {\n                if ((ret = avio_open_dyn_buf(&trk->mdat_buf)) < 0)\n                    return ret;\n            }\n            pb = trk->mdat_buf;\n        } else {\n            if (!mov->mdat_buf) {\n                if ((ret = avio_open_dyn_buf(&mov->mdat_buf)) < 0)\n                    return ret;\n            }\n            pb = mov->mdat_buf;\n        }\n    }\n\n    if (par->codec_id == AV_CODEC_ID_AMR_NB) {\n        /* We must find out how many AMR blocks there are in one packet */\n        static const uint16_t packed_size[16] =\n            {13, 14, 16, 18, 20, 21, 27, 32, 6, 0, 0, 0, 0, 0, 0, 1};\n        int len = 0;\n\n        while (len < size && samples_in_chunk < 100) {\n            len += packed_size[(pkt->data[len] >> 3) & 0x0F];\n            samples_in_chunk++;\n        }\n        if (samples_in_chunk > 1) {\n            av_log(s, AV_LOG_ERROR, \"fatal error, input is not a single packet, implement a AVParser for it\\n\");\n            return -1;\n        }\n    } else if (par->codec_id == AV_CODEC_ID_ADPCM_MS ||\n               par->codec_id == AV_CODEC_ID_ADPCM_IMA_WAV) {\n        samples_in_chunk = trk->par->frame_size;\n    } else if (trk->sample_size)\n        samples_in_chunk = size / trk->sample_size;\n     else\n         samples_in_chunk = 1;\n \n     /* copy extradata if it exists */\n     if (trk->vos_len == 0 && par->extradata_size > 0 &&\n         !TAG_IS_AVCI(trk->tag) &&\n        (par->codec_id != AV_CODEC_ID_DNXHD)) {\n        trk->vos_len  = par->extradata_size;\n        trk->vos_data = av_malloc(trk->vos_len);\n        if (!trk->vos_data) {\n            ret = AVERROR(ENOMEM);\n            goto err;\n        }\n        memcpy(trk->vos_data, par->extradata, trk->vos_len);\n    }\n\n    if (par->codec_id == AV_CODEC_ID_AAC && pkt->size > 2 &&\n        (AV_RB16(pkt->data) & 0xfff0) == 0xfff0) {\n        if (!s->streams[pkt->stream_index]->nb_frames) {\n            av_log(s, AV_LOG_ERROR, \"Malformed AAC bitstream detected: \"\n                   \"use the audio bitstream filter 'aac_adtstoasc' to fix it \"\n                   \"('-bsf:a aac_adtstoasc' option with ffmpeg)\\n\");\n            return -1;\n        }\n        av_log(s, AV_LOG_WARNING, \"aac bitstream error\\n\");\n    }\n    if (par->codec_id == AV_CODEC_ID_H264 && trk->vos_len > 0 && *(uint8_t *)trk->vos_data != 1 && !TAG_IS_AVCI(trk->tag)) {\n        /* from x264 or from bytestream H.264 */\n        /* NAL reformatting needed */\n        if (trk->hint_track >= 0 && trk->hint_track < mov->nb_streams) {\n            ff_avc_parse_nal_units_buf(pkt->data, &reformatted_data,\n                                       &size);\n            avio_write(pb, reformatted_data, size);\n        } else {\n            if (trk->cenc.aes_ctr) {\n                size = ff_mov_cenc_avc_parse_nal_units(&trk->cenc, pb, pkt->data, size);\n                if (size < 0) {\n                    ret = size;\n                    goto err;\n                }\n            } else {\n                size = ff_avc_parse_nal_units(pb, pkt->data, pkt->size);\n            }\n        }\n    } else if (par->codec_id == AV_CODEC_ID_HEVC && trk->vos_len > 6 &&\n               (AV_RB24(trk->vos_data) == 1 || AV_RB32(trk->vos_data) == 1)) {\n        /* extradata is Annex B, assume the bitstream is too and convert it */\n        if (trk->hint_track >= 0 && trk->hint_track < mov->nb_streams) {\n            ff_hevc_annexb2mp4_buf(pkt->data, &reformatted_data, &size, 0, NULL);\n            avio_write(pb, reformatted_data, size);\n        } else {\n            size = ff_hevc_annexb2mp4(pb, pkt->data, pkt->size, 0, NULL);\n        }\n#if CONFIG_AC3_PARSER\n    } else if (par->codec_id == AV_CODEC_ID_EAC3) {\n        size = handle_eac3(mov, pkt, trk);\n        if (size < 0)\n            return size;\n        else if (!size)\n            goto end;\n        avio_write(pb, pkt->data, size);\n#endif\n    } else {\n        if (trk->cenc.aes_ctr) {\n            if (par->codec_id == AV_CODEC_ID_H264 && par->extradata_size > 4) {\n                int nal_size_length = (par->extradata[4] & 0x3) + 1;\n                ret = ff_mov_cenc_avc_write_nal_units(s, &trk->cenc, nal_size_length, pb, pkt->data, size);\n            } else {\n                ret = ff_mov_cenc_write_packet(&trk->cenc, pb, pkt->data, size);\n            }\n\n            if (ret) {\n                goto err;\n            }\n        } else {\n            avio_write(pb, pkt->data, size);\n        }\n    }\n\n    if ((par->codec_id == AV_CODEC_ID_DNXHD ||\n         par->codec_id == AV_CODEC_ID_AC3) && !trk->vos_len) {\n        /* copy frame to create needed atoms */\n        trk->vos_len  = size;\n        trk->vos_data = av_malloc(size);\n        if (!trk->vos_data) {\n            ret = AVERROR(ENOMEM);\n            goto err;\n        }\n        memcpy(trk->vos_data, pkt->data, size);\n    }\n\n    if (trk->entry >= trk->cluster_capacity) {\n        unsigned new_capacity = 2 * (trk->entry + MOV_INDEX_CLUSTER_SIZE);\n        if (av_reallocp_array(&trk->cluster, new_capacity,\n                              sizeof(*trk->cluster))) {\n            ret = AVERROR(ENOMEM);\n            goto err;\n        }\n        trk->cluster_capacity = new_capacity;\n    }\n\n    trk->cluster[trk->entry].pos              = avio_tell(pb) - size;\n    trk->cluster[trk->entry].samples_in_chunk = samples_in_chunk;\n    trk->cluster[trk->entry].chunkNum         = 0;\n    trk->cluster[trk->entry].size             = size;\n    trk->cluster[trk->entry].entries          = samples_in_chunk;\n    trk->cluster[trk->entry].dts              = pkt->dts;\n    trk->cluster[trk->entry].pts              = pkt->pts;\n    if (!trk->entry && trk->start_dts != AV_NOPTS_VALUE) {\n        if (!trk->frag_discont) {\n            /* First packet of a new fragment. We already wrote the duration\n             * of the last packet of the previous fragment based on track_duration,\n             * which might not exactly match our dts. Therefore adjust the dts\n             * of this packet to be what the previous packets duration implies. */\n            trk->cluster[trk->entry].dts = trk->start_dts + trk->track_duration;\n            /* We also may have written the pts and the corresponding duration\n             * in sidx/tfrf/tfxd tags; make sure the sidx pts and duration match up with\n             * the next fragment. This means the cts of the first sample must\n             * be the same in all fragments, unless end_pts was updated by\n             * the packet causing the fragment to be written. */\n            if ((mov->flags & FF_MOV_FLAG_DASH && !(mov->flags & FF_MOV_FLAG_GLOBAL_SIDX)) ||\n                mov->mode == MODE_ISM)\n                pkt->pts = pkt->dts + trk->end_pts - trk->cluster[trk->entry].dts;\n        } else {\n            /* New fragment, but discontinuous from previous fragments.\n             * Pretend the duration sum of the earlier fragments is\n             * pkt->dts - trk->start_dts. */\n            trk->frag_start = pkt->dts - trk->start_dts;\n            trk->end_pts = AV_NOPTS_VALUE;\n            trk->frag_discont = 0;\n        }\n    }\n\n    if (!trk->entry && trk->start_dts == AV_NOPTS_VALUE && !mov->use_editlist &&\n        s->avoid_negative_ts == AVFMT_AVOID_NEG_TS_MAKE_ZERO) {\n        /* Not using edit lists and shifting the first track to start from zero.\n         * If the other streams start from a later timestamp, we won't be able\n         * to signal the difference in starting time without an edit list.\n         * Thus move the timestamp for this first sample to 0, increasing\n         * its duration instead. */\n        trk->cluster[trk->entry].dts = trk->start_dts = 0;\n    }\n    if (trk->start_dts == AV_NOPTS_VALUE) {\n        trk->start_dts = pkt->dts;\n        if (trk->frag_discont) {\n            if (mov->use_editlist) {\n                /* Pretend the whole stream started at pts=0, with earlier fragments\n                 * already written. If the stream started at pts=0, the duration sum\n                 * of earlier fragments would have been pkt->pts. */\n                trk->frag_start = pkt->pts;\n                trk->start_dts  = pkt->dts - pkt->pts;\n            } else {\n                /* Pretend the whole stream started at dts=0, with earlier fragments\n                 * already written, with a duration summing up to pkt->dts. */\n                trk->frag_start = pkt->dts;\n                trk->start_dts  = 0;\n            }\n            trk->frag_discont = 0;\n        } else if (pkt->dts && mov->moov_written)\n            av_log(s, AV_LOG_WARNING,\n                   \"Track %d starts with a nonzero dts %\"PRId64\", while the moov \"\n                   \"already has been written. Set the delay_moov flag to handle \"\n                   \"this case.\\n\",\n                   pkt->stream_index, pkt->dts);\n    }\n    trk->track_duration = pkt->dts - trk->start_dts + pkt->duration;\n    trk->last_sample_is_subtitle_end = 0;\n\n    if (pkt->pts == AV_NOPTS_VALUE) {\n        av_log(s, AV_LOG_WARNING, \"pts has no value\\n\");\n        pkt->pts = pkt->dts;\n    }\n    if (pkt->dts != pkt->pts)\n        trk->flags |= MOV_TRACK_CTTS;\n    trk->cluster[trk->entry].cts   = pkt->pts - pkt->dts;\n    trk->cluster[trk->entry].flags = 0;\n    if (trk->start_cts == AV_NOPTS_VALUE)\n        trk->start_cts = pkt->pts - pkt->dts;\n    if (trk->end_pts == AV_NOPTS_VALUE)\n        trk->end_pts = trk->cluster[trk->entry].dts +\n                       trk->cluster[trk->entry].cts + pkt->duration;\n    else\n        trk->end_pts = FFMAX(trk->end_pts, trk->cluster[trk->entry].dts +\n                                           trk->cluster[trk->entry].cts +\n                                           pkt->duration);\n\n    if (par->codec_id == AV_CODEC_ID_VC1) {\n        mov_parse_vc1_frame(pkt, trk);\n    } else if (pkt->flags & AV_PKT_FLAG_KEY) {\n        if (mov->mode == MODE_MOV && par->codec_id == AV_CODEC_ID_MPEG2VIDEO &&\n            trk->entry > 0) { // force sync sample for the first key frame\n            mov_parse_mpeg2_frame(pkt, &trk->cluster[trk->entry].flags);\n            if (trk->cluster[trk->entry].flags & MOV_PARTIAL_SYNC_SAMPLE)\n                trk->flags |= MOV_TRACK_STPS;\n        } else {\n            trk->cluster[trk->entry].flags = MOV_SYNC_SAMPLE;\n        }\n        if (trk->cluster[trk->entry].flags & MOV_SYNC_SAMPLE)\n            trk->has_keyframes++;\n    }\n    if (pkt->flags & AV_PKT_FLAG_DISPOSABLE) {\n        trk->cluster[trk->entry].flags |= MOV_DISPOSABLE_SAMPLE;\n        trk->has_disposable++;\n    }\n    trk->entry++;\n    trk->sample_count += samples_in_chunk;\n    mov->mdat_size    += size;\n\n    if (trk->hint_track >= 0 && trk->hint_track < mov->nb_streams)\n        ff_mov_add_hinted_packet(s, pkt, trk->hint_track, trk->entry,\n                                 reformatted_data, size);\n\nend:\nerr:\n\n    av_free(reformatted_data);\n    return ret;\n}\n", "target": 1, "idx": 182290}
{"func": "static ssize_t ib_uverbs_comp_event_read(struct file *filp, char __user *buf,\n\t\t\t\t\t size_t count, loff_t *pos)\n{\n\tstruct ib_uverbs_completion_event_file *comp_ev_file =\n\t\tfilp->private_data;\n\n\treturn ib_uverbs_event_read(&comp_ev_file->ev_queue,\n\t\t\t\t    comp_ev_file->uobj.ufile, filp,\n\t\t\t\t    buf, count, pos,\n\t\t\t\t    sizeof(struct ib_uverbs_comp_event_desc));\n}\n", "target": 0, "idx": 90450}
{"func": "static void conditionalAttr1AttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)\n{\n    ExceptionState exceptionState(ExceptionState::SetterContext, \"conditionalAttr1\", \"TestObject\", info.Holder(), info.GetIsolate());\n    TestObject* imp = V8TestObject::toNative(info.Holder());\n    V8TRYCATCH_EXCEPTION_VOID(int, cppValue, toInt32(jsValue, exceptionState), exceptionState);\n    imp->setConditionalAttr1(cppValue);\n}\n", "target": 0, "idx": 130680}
{"func": "void ChromeInvalidationClient::ReissueRegistrations(\n    invalidation::InvalidationClient* client,\n     const std::string& prefix,\n     int prefix_length) {\n   DCHECK(CalledOnValidThread());\n   DVLOG(1) << \"AllRegistrationsLost\";\n   registration_manager_->MarkAllRegistrationsLost();\n }\n", "target": 1, "idx": 184517}
{"func": " bool MediaElementAudioSourceHandler::WouldTaintOrigin() {\n  if (MediaElement()->GetWebMediaPlayer()->DidPassCORSAccessCheck()) {\n    return false;\n  }\n  if (!MediaElement()->HasSingleSecurityOrigin()) {\n    return true;\n  }\n  return Context()->WouldTaintOrigin(MediaElement()->currentSrc());\n }\n", "target": 1, "idx": 186611}
{"func": "long ContentEncoding::ParseCompressionEntry(\n    long long start,\n    long long size,\n    IMkvReader* pReader,\n    ContentCompression* compression) {\n   assert(pReader);\n   assert(compression);\n \n long long pos = start;\n const long long stop = start + size;\n\n bool valid = false;\n\n \n   while (pos < stop) {\n     long long id, size;\n    const long status = ParseElementHeader(pReader,\n                                           pos,\n                                           stop,\n                                           id,\n                                           size);\n    if (status < 0)  //error\n       return status;\n \n     if (id == 0x254) {\n long long algo = UnserializeUInt(pReader, pos, size);\n if (algo < 0)\n return E_FILE_FORMAT_INVALID;\n      compression->algo = algo;\n      valid = true;\n } else if (id == 0x255) {\n if (size <= 0)\n return E_FILE_FORMAT_INVALID;\n\n const size_t buflen = static_cast<size_t>(size);\n typedef unsigned char* buf_t;\n const buf_t buf = new (std::nothrow) unsigned char[buflen];\n\n       if (buf == NULL)\n         return -1;\n \n      const int read_status = pReader->Read(pos, buflen, buf);\n       if (read_status) {\n        delete [] buf;\n         return status;\n       }\n \n      compression->settings = buf;\n\n       compression->settings_len = buflen;\n     }\n \n    pos += size;  //consume payload\n     assert(pos <= stop);\n   }\n \n if (!valid)\n return E_FILE_FORMAT_INVALID;\n\n\n   return 0;\n }\n", "target": 1, "idx": 188439}
{"func": "void AppLauncherHandler::FillAppDictionary(base::DictionaryValue* dictionary) {\n  base::AutoReset<bool> auto_reset(&ignore_changes_, true);\n\n  base::ListValue* list = new base::ListValue();\n  Profile* profile = Profile::FromWebUI(web_ui());\n  PrefService* prefs = profile->GetPrefs();\n\n  for (std::set<std::string>::iterator it = visible_apps_.begin();\n       it != visible_apps_.end(); ++it) {\n    const Extension* extension = extension_service_->GetInstalledExtension(*it);\n    if (extension && extensions::ui_util::ShouldDisplayInNewTabPage(\n            extension, profile)) {\n      base::DictionaryValue* app_info = GetAppInfo(extension);\n      list->Append(app_info);\n    }\n  }\n \n   dictionary->Set(\"apps\", list);\n \n#if defined(OS_MACOSX)\n  dictionary->SetBoolean(\"disableAppWindowLaunch\", true);\n  dictionary->SetBoolean(\"disableCreateAppShortcut\", true);\n#endif\n#if defined(OS_CHROMEOS)\n  dictionary->SetBoolean(\"disableCreateAppShortcut\", true);\n#endif\n   const base::ListValue* app_page_names =\n       prefs->GetList(prefs::kNtpAppPageNames);\n   if (!app_page_names || !app_page_names->GetSize()) {\n    ListPrefUpdate update(prefs, prefs::kNtpAppPageNames);\n    base::ListValue* list = update.Get();\n    list->Set(0, new base::StringValue(\n        l10n_util::GetStringUTF16(IDS_APP_DEFAULT_PAGE_NAME)));\n    dictionary->Set(\"appPageNames\",\n                    static_cast<base::ListValue*>(list->DeepCopy()));\n  } else {\n    dictionary->Set(\"appPageNames\",\n                    static_cast<base::ListValue*>(app_page_names->DeepCopy()));\n  }\n}\n", "target": 1, "idx": 184839}
{"func": "static int iwch_l2t_send(struct t3cdev *tdev, struct sk_buff *skb, struct l2t_entry *l2e)\n{\n\tint\terror = 0;\n\tstruct cxio_rdev *rdev;\n\n\trdev = (struct cxio_rdev *)tdev->ulp;\n\tif (cxio_fatal_error(rdev)) {\n\t\tkfree_skb(skb);\n\t\treturn -EIO;\n\t}\n \terror = l2t_send(tdev, skb, l2e);\n \tif (error < 0)\n \t\tkfree_skb(skb);\n\treturn error;\n }\n", "target": 1, "idx": 180668}
{"func": "void read_sequence_header(decoder_info_t *decoder_info, stream_t *stream) {\n   decoder_info->width = get_flc(16, stream);\n   decoder_info->height = get_flc(16, stream);\n   decoder_info->log2_sb_size = get_flc(3, stream);\n   decoder_info->pb_split = get_flc(1, stream);\n   decoder_info->tb_split_enable = get_flc(1, stream);\n   decoder_info->max_num_ref = get_flc(2, stream) + 1;\n  decoder_info->interp_ref = get_flc(2, stream);\n  decoder_info->max_delta_qp = get_flc(1, stream);\n  decoder_info->deblocking = get_flc(1, stream);\n  decoder_info->clpf = get_flc(1, stream);\n  decoder_info->use_block_contexts = get_flc(1, stream);\n  decoder_info->bipred = get_flc(2, stream);\n  decoder_info->qmtx = get_flc(1, stream);\n  if (decoder_info->qmtx) {\n    decoder_info->qmtx_offset = get_flc(6, stream) - 32;\n  }\n  decoder_info->subsample = get_flc(2, stream);\n    decoder_info->subsample = // 0: 400  1: 420  2: 422  3: 444\n    (decoder_info->subsample & 1) * 20 + (decoder_info->subsample & 2) * 22 +\n    ((decoder_info->subsample & 3) == 3) * 2 + 400;\n  decoder_info->num_reorder_pics = get_flc(4, stream);\n  if (decoder_info->subsample != 400) {\n    decoder_info->cfl_intra = get_flc(1, stream);\n    decoder_info->cfl_inter = get_flc(1, stream);\n  }\n  decoder_info->bitdepth = get_flc(1, stream) ? 10 : 8;\n  if (decoder_info->bitdepth == 10)\n    decoder_info->bitdepth += 2 * get_flc(1, stream);\n  decoder_info->input_bitdepth = get_flc(1, stream) ? 10 : 8;\n  if (decoder_info->input_bitdepth == 10)\n    decoder_info->input_bitdepth += 2 * get_flc(1, stream);\n}\n", "target": 1, "idx": 182539}
{"func": "     CCLayerTreeHostTest()\n         : m_beginning(false)\n         , m_endWhenBeginReturns(false)\n        , m_running(false)\n         , m_timedOut(false)\n     {\n         m_webThread = adoptPtr(webKitPlatformSupport()->createThread(\"CCLayerTreeHostTest\"));\n         WebCompositor::setThread(m_webThread.get());\n#if USE(THREADED_COMPOSITING)\n        m_settings.enableCompositorThread = true;\n#else\n        m_settings.enableCompositorThread = false;\n #endif\n     }\n", "target": 1, "idx": 183747}
{"func": "static int xfrm_exp_policy_notify(struct xfrm_policy *xp, int dir, const struct km_event *c)\n{\n\tstruct net *net = xp_net(xp);\n\tstruct sk_buff *skb;\n\n\tskb = nlmsg_new(xfrm_polexpire_msgsize(xp), GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tif (build_polexpire(skb, xp, dir, c) < 0)\n\t\tBUG();\n\n\treturn xfrm_nlmsg_multicast(net, skb, 0, XFRMNLGRP_EXPIRE);\n}\n", "target": 0, "idx": 59361}
{"func": "fn_printzp(netdissect_options *ndo,\n           register const u_char *s, register u_int n,\n           register const u_char *ep)\n{\n\tregister int ret;\n\tregister u_char c;\n\n\tret = 1;\t\t\t/* assume truncated */\n\twhile (n > 0 && (ep == NULL || s < ep)) {\n\t\tn--;\n\t\tc = *s++;\n\t\tif (c == '\\0') {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (!ND_ISASCII(c)) {\n\t\t\tc = ND_TOASCII(c);\n\t\t\tND_PRINT((ndo, \"M-\"));\n\t\t}\n\t\tif (!ND_ISPRINT(c)) {\n\t\t\tc ^= 0x40;\t/* DEL to ?, others to alpha */\n\t\t\tND_PRINT((ndo, \"^\"));\n\t\t}\n\t\tND_PRINT((ndo, \"%c\", c));\n\t}\n\treturn (n == 0) ? 0 : ret;\n}\n", "target": 0, "idx": 62383}
{"func": "  explicit TestWindowObserver(aura::Window* window_to_observe)\n      : window_(window_to_observe) {\n    window_->AddObserver(this);\n  }\n", "target": 0, "idx": 158469}
{"func": "lrmd_remote_listen(gpointer data)\n{\n    int csock = 0;\n    int flag = 0;\n    unsigned laddr = 0;\n    struct sockaddr addr;\n    gnutls_session_t *session = NULL;\n    crm_client_t *new_client = NULL;\n\n    static struct mainloop_fd_callbacks lrmd_remote_fd_cb = {\n        .dispatch = lrmd_remote_client_msg,\n        .destroy = lrmd_remote_client_destroy,\n    };\n\n    laddr = sizeof(addr);\n    memset(&addr, 0, sizeof(addr));\n    getsockname(ssock, &addr, &laddr);\n\n    /* accept the connection */\n\n    if (addr.sa_family == AF_INET6) {\n        struct sockaddr_in6 sa;\n        char addr_str[INET6_ADDRSTRLEN];\n\n        laddr = sizeof(sa);\n        memset(&sa, 0, sizeof(sa));\n        csock = accept(ssock, &sa, &laddr);\n        get_ip_str((struct sockaddr *)&sa, addr_str, INET6_ADDRSTRLEN);\n        crm_info(\"New remote connection from %s\", addr_str);\n\n    } else {\n        struct sockaddr_in sa;\n        char addr_str[INET_ADDRSTRLEN];\n\n        laddr = sizeof(sa);\n        memset(&sa, 0, sizeof(sa));\n        csock = accept(ssock, &sa, &laddr);\n        get_ip_str((struct sockaddr *)&sa, addr_str, INET_ADDRSTRLEN);\n        crm_info(\"New remote connection from %s\", addr_str);\n    }\n\n    if (csock == -1) {\n        crm_err(\"accept socket failed\");\n        return TRUE;\n    }\n\n    if ((flag = fcntl(csock, F_GETFL)) >= 0) {\n        if (fcntl(csock, F_SETFL, flag | O_NONBLOCK) < 0) {\n            crm_err(\"fcntl() write failed\");\n            close(csock);\n            return TRUE;\n        }\n    } else {\n        crm_err(\"fcntl() read failed\");\n        close(csock);\n        return TRUE;\n    }\n\n    session = create_psk_tls_session(csock, GNUTLS_SERVER, psk_cred_s);\n    if (session == NULL) {\n        crm_err(\"TLS session creation failed\");\n        close(csock);\n        return TRUE;\n    }\n\n    new_client = calloc(1, sizeof(crm_client_t));\n    new_client->remote = calloc(1, sizeof(crm_remote_t));\n    new_client->kind = CRM_CLIENT_TLS;\n    new_client->remote->tls_session = session;\n    new_client->id = crm_generate_uuid();\n    new_client->remote->auth_timeout =\n        g_timeout_add(LRMD_REMOTE_AUTH_TIMEOUT, lrmd_auth_timeout_cb, new_client);\n    crm_notice(\"LRMD client connection established. %p id: %s\", new_client, new_client->id);\n\n    new_client->remote->source =\n        mainloop_add_fd(\"lrmd-remote-client\", G_PRIORITY_DEFAULT, csock, new_client,\n                         &lrmd_remote_fd_cb);\n     g_hash_table_insert(client_connections, new_client->id, new_client);\n \n    /* Alert other clients of the new connection */\n    notify_of_new_client(new_client);\n     return TRUE;\n }\n", "target": 1, "idx": 181957}
{"func": "decode_NXAST_RAW_OUTPUT_REG(const struct nx_action_output_reg *naor,\n                            enum ofp_version ofp_version OVS_UNUSED,\n                            const struct vl_mff_map *vl_mff_map,\n                            uint64_t *tlv_bitmap, struct ofpbuf *out)\n{\n    struct ofpact_output_reg *output_reg;\n    enum ofperr error;\n\n    if (!is_all_zeros(naor->zero, sizeof naor->zero)) {\n        return OFPERR_OFPBAC_BAD_ARGUMENT;\n    }\n\n    output_reg = ofpact_put_OUTPUT_REG(out);\n    output_reg->ofpact.raw = NXAST_RAW_OUTPUT_REG;\n    output_reg->src.ofs = nxm_decode_ofs(naor->ofs_nbits);\n    output_reg->src.n_bits = nxm_decode_n_bits(naor->ofs_nbits);\n    output_reg->max_len = ntohs(naor->max_len);\n    error = mf_vl_mff_mf_from_nxm_header(ntohl(naor->src), vl_mff_map,\n                                         &output_reg->src.field, tlv_bitmap);\n    if (error) {\n        return error;\n    }\n\n    return mf_check_src(&output_reg->src, NULL);\n}\n", "target": 0, "idx": 76803}
{"func": "void SoftAMR::onQueueFilled(OMX_U32 /* portIndex */) {\n List<BufferInfo *> &inQueue = getPortQueue(0);\n List<BufferInfo *> &outQueue = getPortQueue(1);\n\n if (mSignalledError || mOutputPortSettingsChange != NONE) {\n return;\n }\n\n while (!inQueue.empty() && !outQueue.empty()) {\n BufferInfo *inInfo = *inQueue.begin();\n        OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;\n\n BufferInfo *outInfo = *outQueue.begin();\n        OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;\n\n if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {\n            inQueue.erase(inQueue.begin());\n            inInfo->mOwnedByUs = false;\n            notifyEmptyBufferDone(inHeader);\n\n            outHeader->nFilledLen = 0;\n            outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n\n            outQueue.erase(outQueue.begin());\n            outInfo->mOwnedByUs = false;\n            notifyFillBufferDone(outHeader);\n return;\n }\n\n if (inHeader->nOffset == 0) {\n            mAnchorTimeUs = inHeader->nTimeStamp;\n            mNumSamplesOutput = 0;\n }\n\n const uint8_t *inputPtr = inHeader->pBuffer + inHeader->nOffset;\n\n         int32_t numBytesRead;\n \n         if (mMode == MODE_NARROW) {\n             numBytesRead =\n                 AMRDecode(mState,\n                   (Frame_Type_3GPP)((inputPtr[0] >> 3) & 0x0f),\n (UWord8 *)&inputPtr[1],\n reinterpret_cast<int16_t *>(outHeader->pBuffer),\n                  MIME_IETF);\n\n if (numBytesRead == -1) {\n                ALOGE(\"PV AMR decoder AMRDecode() call failed\");\n\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                mSignalledError = true;\n\n return;\n }\n\n ++numBytesRead; // Include the frame type header byte.\n\n if (static_cast<size_t>(numBytesRead) > inHeader->nFilledLen) {\n\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                mSignalledError = true;\n\n\n                 return;\n             }\n         } else {\n             int16 mode = ((inputPtr[0] >> 3) & 0x0f);\n \n             if (mode >= 10 && mode <= 13) {\n                ALOGE(\"encountered illegal frame type %d in AMR WB content.\",\n                      mode);\n\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                mSignalledError = true;\n\n return;\n }\n\n size_t frameSize = getFrameSize(mode);\n            CHECK_GE(inHeader->nFilledLen, frameSize);\n\n int16_t *outPtr = (int16_t *)outHeader->pBuffer;\n\n if (mode >= 9) {\n                memset(outPtr, 0, kNumSamplesPerFrameWB * sizeof(int16_t));\n } else if (mode < 9) {\n int16 frameType;\n                RX_State_wb rx_state;\n                mime_unsorting(\n const_cast<uint8_t *>(&inputPtr[1]),\n                        mInputSampleBuffer,\n &frameType, &mode, 1, &rx_state);\n\n int16_t numSamplesOutput;\n                pvDecoder_AmrWb(\n                        mode, mInputSampleBuffer,\n                        outPtr,\n &numSamplesOutput,\n                        mDecoderBuf, frameType, mDecoderCookie);\n\n                CHECK_EQ((int)numSamplesOutput, (int)kNumSamplesPerFrameWB);\n\n for (int i = 0; i < kNumSamplesPerFrameWB; ++i) {\n /* Delete the 2 LSBs (14-bit output) */\n                    outPtr[i] &= 0xfffC;\n }\n }\n\n            numBytesRead = frameSize;\n }\n\n        inHeader->nOffset += numBytesRead;\n        inHeader->nFilledLen -= numBytesRead;\n\n        outHeader->nFlags = 0;\n        outHeader->nOffset = 0;\n\n if (mMode == MODE_NARROW) {\n            outHeader->nFilledLen = kNumSamplesPerFrameNB * sizeof(int16_t);\n\n            outHeader->nTimeStamp =\n                mAnchorTimeUs\n + (mNumSamplesOutput * 1000000ll) / kSampleRateNB;\n\n            mNumSamplesOutput += kNumSamplesPerFrameNB;\n } else {\n            outHeader->nFilledLen = kNumSamplesPerFrameWB * sizeof(int16_t);\n\n            outHeader->nTimeStamp =\n                mAnchorTimeUs\n + (mNumSamplesOutput * 1000000ll) / kSampleRateWB;\n\n            mNumSamplesOutput += kNumSamplesPerFrameWB;\n }\n\n if (inHeader->nFilledLen == 0) {\n            inInfo->mOwnedByUs = false;\n            inQueue.erase(inQueue.begin());\n            inInfo = NULL;\n            notifyEmptyBufferDone(inHeader);\n            inHeader = NULL;\n }\n\n        outInfo->mOwnedByUs = false;\n        outQueue.erase(outQueue.begin());\n        outInfo = NULL;\n        notifyFillBufferDone(outHeader);\n        outHeader = NULL;\n\n ++mInputBufferCount;\n }\n}\n", "target": 1, "idx": 187901}
{"func": "void ManualFillingControllerImpl::Hide(FillingSource source) {\n  if (source == FillingSource::AUTOFILL &&\n      !base::FeatureList::IsEnabled(\n          autofill::features::kAutofillKeyboardAccessory)) {\n    return;\n  }\n  visible_sources_.erase(source);\n  if (visible_sources_.empty())\n    view_->Hide();\n}\n", "target": 0, "idx": 142253}
{"func": "bool_t xdr_krb5_tl_data(XDR *xdrs, krb5_tl_data **tl_data_head)\n{\n     krb5_tl_data *tl, *tl2;\n     bool_t more;\n     unsigned int len;\n\n     switch (xdrs->x_op) {\n     case XDR_FREE:\n\t  tl = tl2 = *tl_data_head;\n\t  while (tl) {\n\t       tl2 = tl->tl_data_next;\n\t       free(tl->tl_data_contents);\n \t       free(tl);\n \t       tl = tl2;\n \t  }\n \t  break;\n \n      case XDR_ENCODE:\n\t  tl = *tl_data_head;\n\t  while (1) {\n\t       more = (tl != NULL);\n\t       if (!xdr_bool(xdrs, &more))\n\t\t    return FALSE;\n\t       if (tl == NULL)\n\t\t    break;\n\t       if (!xdr_krb5_int16(xdrs, &tl->tl_data_type))\n\t\t    return FALSE;\n\t       len = tl->tl_data_length;\n\t       if (!xdr_bytes(xdrs, (char **) &tl->tl_data_contents, &len, ~0))\n\t\t    return FALSE;\n\t       tl = tl->tl_data_next;\n\t  }\n\t  break;\n\n     case XDR_DECODE:\n\t  tl = NULL;\n\t  while (1) {\n\t       if (!xdr_bool(xdrs, &more))\n\t\t    return FALSE;\n\t       if (more == FALSE)\n\t\t    break;\n\t       tl2 = (krb5_tl_data *) malloc(sizeof(krb5_tl_data));\n\t       if (tl2 == NULL)\n\t\t    return FALSE;\n\t       memset(tl2, 0, sizeof(krb5_tl_data));\n\t       if (!xdr_krb5_int16(xdrs, &tl2->tl_data_type))\n\t\t    return FALSE;\n\t       if (!xdr_bytes(xdrs, (char **)&tl2->tl_data_contents, &len, ~0))\n\t\t    return FALSE;\n\t       tl2->tl_data_length = len;\n\n\t       tl2->tl_data_next = tl;\n\t       tl = tl2;\n\t  }\n\n\t  *tl_data_head = tl;\n\t  break;\n     }\n\n     return TRUE;\n}\n", "target": 1, "idx": 179963}
{"func": "static INLINE void check_resync(vpx_codec_alg_priv_t *const ctx,\n const VP9Decoder *const pbi) {\n if (ctx->need_resync == 1 && pbi->need_resync == 0 &&\n (pbi->common.intra_only || pbi->common.frame_type == KEY_FRAME))\n    ctx->need_resync = 0;\n}\n", "target": 0, "idx": 171430}
{"func": "static void renew_lease(const struct nfs_server *server, unsigned long timestamp)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\n\tif (!nfs4_has_session(clp))\n\t\tdo_renew_lease(clp, timestamp);\n}\n", "target": 0, "idx": 57276}
{"func": " void qemu_spice_create_host_primary(SimpleSpiceDisplay *ssd)\n {\n     QXLDevSurfaceCreate surface;\n \n     memset(&surface, 0, sizeof(surface));\n \n    dprint(1, \"%s/%d: %dx%d\\n\", __func__, ssd->qxl.id,\n           surface_width(ssd->ds), surface_height(ssd->ds));\n \n     surface.format     = SPICE_SURFACE_FMT_32_xRGB;\n     surface.width      = surface_width(ssd->ds);\n{\n    dprint(1, \"%s/%d:\\n\", __func__, ssd->qxl.id);\n\n    qemu_spice_destroy_primary_surface(ssd, 0, QXL_SYNC);\n}\n\nvoid qemu_spice_display_init_common(SimpleSpiceDisplay *ssd)\n{\n    qemu_mutex_init(&ssd->lock);\n    QTAILQ_INIT(&ssd->updates);\n    ssd->mouse_x = -1;\n    ssd->mouse_y = -1;\n    if (ssd->num_surfaces == 0) {\n        ssd->num_surfaces = 1024;\n    }\n    ssd->bufsize = (16 * 1024 * 1024);\n    ssd->buf = g_malloc(ssd->bufsize);\n}\n\n/* display listener callbacks */\n\nvoid qemu_spice_display_update(SimpleSpiceDisplay *ssd,\n                               int x, int y, int w, int h)\n{\n     if (ssd->num_surfaces == 0) {\n         ssd->num_surfaces = 1024;\n     }\n    ssd->bufsize = (16 * 1024 * 1024);\n    ssd->buf = g_malloc(ssd->bufsize);\n }\n \n /* display listener callbacks */\n    update_area.top = y;\n    update_area.bottom = y + h;\n\n    if (qemu_spice_rect_is_empty(&ssd->dirty)) {\n        ssd->notify++;\n    }\n    qemu_spice_rect_union(&ssd->dirty, &update_area);\n}\n", "target": 1, "idx": 178323}
{"func": "ftrace_regex_lseek(struct file *file, loff_t offset, int whence)\n {\n \tloff_t ret;\n \n\tif (file->f_mode & FMODE_READ)\n\t\tret = seq_lseek(file, offset, whence);\n\telse\n\t\tfile->f_pos = ret = 1;\n\n\treturn ret;\n}\n", "target": 1, "idx": 179199}
{"func": "static int xc2028_get_reg(struct xc2028_data *priv, u16 reg, u16 *val)\n{\n\tunsigned char buf[2];\n\tunsigned char ibuf[2];\n\n\ttuner_dbg(\"%s %04x called\\n\", __func__, reg);\n\n\tbuf[0] = reg >> 8;\n\tbuf[1] = (unsigned char) reg;\n\n\tif (i2c_send_recv(priv, buf, 2, ibuf, 2) != 2)\n\t\treturn -EIO;\n\n\t*val = (ibuf[1]) | (ibuf[0] << 8);\n\treturn 0;\n}\n", "target": 0, "idx": 49551}
{"func": "static void pcrypt_fini_padata(struct padata_pcrypt *pcrypt)\n{\n\tfree_cpumask_var(pcrypt->cb_cpumask->mask);\n\tkfree(pcrypt->cb_cpumask);\n\n\tpadata_stop(pcrypt->pinst);\n\tpadata_unregister_cpumask_notifier(pcrypt->pinst, &pcrypt->nblock);\n\tdestroy_workqueue(pcrypt->wq);\n\tpadata_free(pcrypt->pinst);\n}\n", "target": 0, "idx": 45881}
{"func": "static int coroutine_fn v9fs_do_readdir_with_stat(V9fsPDU *pdu,\n                                                  V9fsFidState *fidp,\n                                                  uint32_t max_count)\n{\n    V9fsPath path;\n    V9fsStat v9stat;\n    int len, err = 0;\n    int32_t count = 0;\n    struct stat stbuf;\n    off_t saved_dir_pos;\n    struct dirent *dent;\n\n    /* save the directory position */\n    saved_dir_pos = v9fs_co_telldir(pdu, fidp);\n    if (saved_dir_pos < 0) {\n        return saved_dir_pos;\n    }\n\n    while (1) {\n        v9fs_path_init(&path);\n\n        v9fs_readdir_lock(&fidp->fs.dir);\n\n        err = v9fs_co_readdir(pdu, fidp, &dent);\n        if (err || !dent) {\n            break;\n        }\n        err = v9fs_co_name_to_path(pdu, &fidp->path, dent->d_name, &path);\n        if (err < 0) {\n            break;\n        }\n        err = v9fs_co_lstat(pdu, &path, &stbuf);\n        if (err < 0) {\n            break;\n        }\n        err = stat_to_v9stat(pdu, &path, &stbuf, &v9stat);\n        if (err < 0) {\n            break;\n        }\n        /* 11 = 7 + 4 (7 = start offset, 4 = space for storing count) */\n        len = pdu_marshal(pdu, 11 + count, \"S\", &v9stat);\n\n        v9fs_readdir_unlock(&fidp->fs.dir);\n\n        if ((len != (v9stat.size + 2)) || ((count + len) > max_count)) {\n            /* Ran out of buffer. Set dir back to old position and return */\n            v9fs_co_seekdir(pdu, fidp, saved_dir_pos);\n            v9fs_stat_free(&v9stat);\n            v9fs_path_free(&path);\n            return count;\n        }\n        count += len;\n        v9fs_stat_free(&v9stat);\n        v9fs_path_free(&path);\n        saved_dir_pos = dent->d_off;\n    }\n\n    v9fs_readdir_unlock(&fidp->fs.dir);\n\n    v9fs_path_free(&path);\n    if (err < 0) {\n        return err;\n    }\n    return count;\n}\n", "target": 0, "idx": 7715}
{"func": "static void strictFunctionMethod(const v8::FunctionCallbackInfo<v8::Value>& info)\n{\n    ExceptionState exceptionState(ExceptionState::ExecutionContext, \"strictFunction\", \"TestObject\", info.Holder(), info.GetIsolate());\n    if (UNLIKELY(info.Length() < 3)) {\n        exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));\n        exceptionState.throwIfNeeded();\n        return;\n    }\n    TestObject* imp = V8TestObject::toNative(info.Holder());\n    V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID(V8StringResource<>, str, info[0]);\n    V8TRYCATCH_VOID(float, a, static_cast<float>(info[1]->NumberValue()));\n    V8TRYCATCH_EXCEPTION_VOID(int, b, toInt32(info[2], exceptionState), exceptionState);\n    bool result = imp->strictFunction(str, a, b, exceptionState);\n    if (exceptionState.throwIfNeeded())\n        return;\n    v8SetReturnValueBool(info, result);\n}\n", "target": 0, "idx": 131069}
{"func": "static int __follow_pte(struct mm_struct *mm, unsigned long address,\n\t\tpte_t **ptepp, spinlock_t **ptlp)\n{\n\tpgd_t *pgd;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *ptep;\n\n\tpgd = pgd_offset(mm, address);\n\tif (pgd_none(*pgd) || unlikely(pgd_bad(*pgd)))\n\t\tgoto out;\n\n\tpud = pud_offset(pgd, address);\n\tif (pud_none(*pud) || unlikely(pud_bad(*pud)))\n\t\tgoto out;\n\n\tpmd = pmd_offset(pud, address);\n\tVM_BUG_ON(pmd_trans_huge(*pmd));\n\tif (pmd_none(*pmd) || unlikely(pmd_bad(*pmd)))\n\t\tgoto out;\n\n\t/* We cannot handle huge page PFN maps. Luckily they don't exist. */\n\tif (pmd_huge(*pmd))\n\t\tgoto out;\n\n\tptep = pte_offset_map_lock(mm, pmd, address, ptlp);\n\tif (!ptep)\n\t\tgoto out;\n\tif (!pte_present(*ptep))\n\t\tgoto unlock;\n\t*ptepp = ptep;\n\treturn 0;\nunlock:\n\tpte_unmap_unlock(ptep, *ptlp);\nout:\n\treturn -EINVAL;\n}\n", "target": 0, "idx": 21188}
{"func": "void NavigationControllerImpl::ReloadInternal(bool check_for_repost,\n                                              ReloadType reload_type) {\n  if (transient_entry_index_ != -1) {\n    NavigationEntryImpl* active_entry =\n        NavigationEntryImpl::FromNavigationEntry(GetActiveEntry());\n    if (!active_entry)\n      return;\n    LoadURL(active_entry->GetURL(),\n            Referrer(),\n            PAGE_TRANSITION_RELOAD,\n            active_entry->extra_headers());\n    return;\n  }\n\n  NavigationEntryImpl* entry = NULL;\n  int current_index = -1;\n\n  if (IsInitialNavigation() && pending_entry_) {\n    entry = pending_entry_;\n    current_index = pending_entry_index_;\n  } else {\n    DiscardNonCommittedEntriesInternal();\n    current_index = GetCurrentEntryIndex();\n    if (current_index != -1) {\n      entry = NavigationEntryImpl::FromNavigationEntry(\n          GetEntryAtIndex(current_index));\n    }\n  }\n\n  if (!entry)\n    return;\n\n  if (g_check_for_repost && check_for_repost &&\n      entry->GetHasPostData()) {\n    web_contents_->NotifyBeforeFormRepostWarningShow();\n\n    pending_reload_ = reload_type;\n    web_contents_->Activate();\n    web_contents_->GetDelegate()->ShowRepostFormWarningDialog(web_contents_);\n  } else {\n    if (!IsInitialNavigation())\n      DiscardNonCommittedEntriesInternal();\n\n    SiteInstanceImpl* site_instance = entry->site_instance();\n    if (site_instance &&\n        site_instance->HasWrongProcessForURL(entry->GetURL())) {\n      NavigationEntryImpl* nav_entry = NavigationEntryImpl::FromNavigationEntry(\n          CreateNavigationEntry(\n              entry->GetURL(), entry->GetReferrer(), entry->GetTransitionType(),\n              false, entry->extra_headers(), browser_context_));\n\n      reload_type = NavigationController::NO_RELOAD;\n\n      nav_entry->set_should_replace_entry(true);\n      pending_entry_ = nav_entry;\n    } else {\n      pending_entry_ = entry;\n      pending_entry_index_ = current_index;\n\n      pending_entry_->SetTitle(string16());\n\n      pending_entry_->SetTransitionType(PAGE_TRANSITION_RELOAD);\n    }\n\n    NavigateToPendingEntry(reload_type);\n  }\n}\n", "target": 0, "idx": 119808}
{"func": "DefragReverseSimpleTest(void)\n{\n    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;\n    Packet *reassembled = NULL;\n    int id = 12;\n    int i;\n    int ret = 0;\n \n     DefragInit();\n \n    p1 = BuildTestPacket(id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n    p2 = BuildTestPacket(id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n    p3 = BuildTestPacket(id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n    if (Defrag(NULL, NULL, p3, NULL) != NULL)\n        goto end;\n    if (Defrag(NULL, NULL, p2, NULL) != NULL)\n        goto end;\n\n    reassembled = Defrag(NULL, NULL, p1, NULL);\n    if (reassembled == NULL)\n        goto end;\n\n    if (IPV4_GET_HLEN(reassembled) != 20)\n        goto end;\n    if (IPV4_GET_IPLEN(reassembled) != 39)\n        goto end;\n\n    /* 20 bytes in we should find 8 bytes of A. */\n    for (i = 20; i < 20 + 8; i++) {\n        if (GET_PKT_DATA(reassembled)[i] != 'A')\n            goto end;\n    }\n\n    /* 28 bytes in we should find 8 bytes of B. */\n    for (i = 28; i < 28 + 8; i++) {\n        if (GET_PKT_DATA(reassembled)[i] != 'B')\n            goto end;\n    }\n\n    /* And 36 bytes in we should find 3 bytes of C. */\n    for (i = 36; i < 36 + 3; i++) {\n        if (GET_PKT_DATA(reassembled)[i] != 'C')\n            goto end;\n    }\n\n    ret = 1;\nend:\n    if (p1 != NULL)\n        SCFree(p1);\n    if (p2 != NULL)\n        SCFree(p2);\n    if (p3 != NULL)\n        SCFree(p3);\n    if (reassembled != NULL)\n        SCFree(reassembled);\n\n    DefragDestroy();\n    return ret;\n}\n", "target": 1, "idx": 181474}
{"func": "static inline void account_numa_dequeue(struct rq *rq, struct task_struct *p)\n{\n}\n", "target": 0, "idx": 92455}
{"func": "static int find_hole(void)\n{\n   unsigned x;\n   int      y, z;\n   for (z = -1, y = INT_MAX, x = 0; x < FP_ENTRIES; x++) {\n       if (fp_cache[x].lru_count < y && fp_cache[x].lock == 0) {\n          z = x;\n          y = fp_cache[x].lru_count;\n       }\n   }\n\n   /* decrease all */\n   for (x = 0; x < FP_ENTRIES; x++) {\n      if (fp_cache[x].lru_count > 3) {\n         --(fp_cache[x].lru_count);\n      }\n   }\n\n   /* free entry z */\n   if (z >= 0 && fp_cache[z].g) {\n      mp_clear(&fp_cache[z].mu);\n      wc_ecc_del_point(fp_cache[z].g);\n      fp_cache[z].g  = NULL;\n      for (x = 0; x < (1U<<FP_LUT); x++) {\n         wc_ecc_del_point(fp_cache[z].LUT[x]);\n         fp_cache[z].LUT[x] = NULL;\n      }\n      fp_cache[z].lru_count = 0;\n   }\n   return z;\n}\n", "target": 0, "idx": 81842}
{"func": "String PresentationConnection::binaryType() const {\n  switch (m_binaryType) {\n    case BinaryTypeBlob:\n      return \"blob\";\n    case BinaryTypeArrayBuffer:\n      return \"arraybuffer\";\n  }\n  ASSERT_NOT_REACHED();\n  return String();\n}\n", "target": 0, "idx": 140898}
{"func": "void AXTableCell::columnIndexRange(std::pair<unsigned, unsigned>& columnRange) {\n  if (!m_layoutObject || !m_layoutObject->isTableCell())\n    return;\n\n  LayoutTableCell* cell = toLayoutTableCell(m_layoutObject);\n  columnRange.first = cell->table()->absoluteColumnToEffectiveColumn(\n      cell->absoluteColumnIndex());\n  columnRange.second = cell->table()->absoluteColumnToEffectiveColumn(\n                           cell->absoluteColumnIndex() + cell->colSpan()) -\n                       columnRange.first;\n}\n", "target": 0, "idx": 138297}
{"func": "sctp_disposition_t sctp_sf_ootb(struct net *net,\n\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\tvoid *arg,\n\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sk_buff *skb = chunk->skb;\n\tsctp_chunkhdr_t *ch;\n\tsctp_errhdr_t *err;\n\t__u8 *ch_end;\n\tint ootb_shut_ack = 0;\n\tint ootb_cookie_ack = 0;\n\n\tSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\n\n\tch = (sctp_chunkhdr_t *) chunk->chunk_hdr;\n\tdo {\n\t\t/* Report violation if the chunk is less then minimal */\n\t\tif (ntohs(ch->length) < sizeof(sctp_chunkhdr_t))\n \t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n \t\t\t\t\t\t  commands);\n \n \t\t/* Now that we know we at least have a chunk header,\n \t\t * do things that are type appropriate.\n \t\t */\n\t\tif (SCTP_CID_SHUTDOWN_ACK == ch->type)\n\t\t\tootb_shut_ack = 1;\n\n\t\t/* RFC 2960, Section 3.3.7\n\t\t *   Moreover, under any circumstances, an endpoint that\n\t\t *   receives an ABORT  MUST NOT respond to that ABORT by\n\t\t *   sending an ABORT of its own.\n\t\t */\n\t\tif (SCTP_CID_ABORT == ch->type)\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t\t/* RFC 8.4, 7) If the packet contains a \"Stale cookie\" ERROR\n\t\t * or a COOKIE ACK the SCTP Packet should be silently\n\t\t * discarded.\n\t\t */\n\n\t\tif (SCTP_CID_COOKIE_ACK == ch->type)\n\t\t\tootb_cookie_ack = 1;\n\n\t\tif (SCTP_CID_ERROR == ch->type) {\n\t\t\tsctp_walk_errors(err, ch) {\n\t\t\t\tif (SCTP_ERROR_STALE_COOKIE == err->cause) {\n\t\t\t\t\tootb_cookie_ack = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n \t\t\t}\n \t\t}\n \n\t\t/* Report violation if chunk len overflows */\n\t\tch_end = ((__u8 *)ch) + SCTP_PAD4(ntohs(ch->length));\n\t\tif (ch_end > skb_tail_pointer(skb))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n \t\tch = (sctp_chunkhdr_t *) ch_end;\n \t} while (ch_end < skb_tail_pointer(skb));\n \n\tif (ootb_shut_ack)\n\t\treturn sctp_sf_shut_8_4_5(net, ep, asoc, type, arg, commands);\n\telse if (ootb_cookie_ack)\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\telse\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n}\n", "target": 1, "idx": 180033}
{"func": "posix_acl_to_xattr(struct user_namespace *user_ns, const struct posix_acl *acl,\n\t\t   void *buffer, size_t size)\n{\n\tposix_acl_xattr_header *ext_acl = (posix_acl_xattr_header *)buffer;\n\tposix_acl_xattr_entry *ext_entry;\n\tint real_size, n;\n\n\treal_size = posix_acl_xattr_size(acl->a_count);\n\tif (!buffer)\n\t\treturn real_size;\n\tif (real_size > size)\n\t\treturn -ERANGE;\n\n\text_entry = ext_acl->a_entries;\n\text_acl->a_version = cpu_to_le32(POSIX_ACL_XATTR_VERSION);\n\n\tfor (n=0; n < acl->a_count; n++, ext_entry++) {\n\t\tconst struct posix_acl_entry *acl_e = &acl->a_entries[n];\n\t\text_entry->e_tag  = cpu_to_le16(acl_e->e_tag);\n\t\text_entry->e_perm = cpu_to_le16(acl_e->e_perm);\n\t\tswitch(acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\t\text_entry->e_id =\n\t\t\t\tcpu_to_le32(from_kuid(user_ns, acl_e->e_uid));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\text_entry->e_id =\n\t\t\t\tcpu_to_le32(from_kgid(user_ns, acl_e->e_gid));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\text_entry->e_id = cpu_to_le32(ACL_UNDEFINED_ID);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn real_size;\n}\n", "target": 0, "idx": 50388}
{"func": "status_t SampleTable::setTimeToSampleParams(\n off64_t data_offset, size_t data_size) {\n if (mTimeToSample != NULL || data_size < 8) {\n return ERROR_MALFORMED;\n }\n\n uint8_t header[8];\n if (mDataSource->readAt(\n                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {\n return ERROR_IO;\n }\n\n if (U32_AT(header) != 0) {\n return ERROR_MALFORMED;\n\n     }\n \n     mTimeToSampleCount = U32_AT(&header[4]);\n    uint64_t allocSize = mTimeToSampleCount * 2 * sizeof(uint32_t);\n     if (allocSize > SIZE_MAX) {\n         return ERROR_OUT_OF_RANGE;\n     }\n    mTimeToSample = new uint32_t[mTimeToSampleCount * 2];\n\n size_t size = sizeof(uint32_t) * mTimeToSampleCount * 2;\n if (mDataSource->readAt(\n                data_offset + 8, mTimeToSample, size) < (ssize_t)size) {\n return ERROR_IO;\n }\n\n for (uint32_t i = 0; i < mTimeToSampleCount * 2; ++i) {\n        mTimeToSample[i] = ntohl(mTimeToSample[i]);\n }\n\n return OK;\n}\n", "target": 1, "idx": 187361}
{"func": "static const char *default_charset(void)\n{\n# if defined HAVE_LIBCHARSET_H && defined HAVE_LOCALE_CHARSET\n\treturn locale_charset();\n# elif defined HAVE_LANGINFO_H && defined HAVE_NL_LANGINFO\n\treturn nl_langinfo(CODESET);\n# else\n\treturn \"\"; /* Works with (at the very least) gnu iconv... */\n# endif\n}\n", "target": 0, "idx": 689}
{"func": "static void coroutine_fn v9fs_link(void *opaque)\n{\n    V9fsPDU *pdu = opaque;\n    int32_t dfid, oldfid;\n    V9fsFidState *dfidp, *oldfidp;\n    V9fsString name;\n    size_t offset = 7;\n    int err = 0;\n\n    v9fs_string_init(&name);\n    err = pdu_unmarshal(pdu, offset, \"dds\", &dfid, &oldfid, &name);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_link(pdu->tag, pdu->id, dfid, oldfid, name.data);\n\n    if (name_is_illegal(name.data)) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n\n    if (!strcmp(\".\", name.data) || !strcmp(\"..\", name.data)) {\n        err = -EEXIST;\n        goto out_nofid;\n    }\n\n    dfidp = get_fid(pdu, dfid);\n    if (dfidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n\n    oldfidp = get_fid(pdu, oldfid);\n    if (oldfidp == NULL) {\n        err = -ENOENT;\n        goto out;\n    }\n    err = v9fs_co_link(pdu, oldfidp, dfidp, &name);\n     if (!err) {\n         err = offset;\n     }\n out:\n     put_fid(pdu, dfidp);\n out_nofid:\n    pdu_complete(pdu, err);\n}\n", "target": 1, "idx": 178079}
{"func": "dbus_object_create_path_vrrp(void)\n{\n\treturn g_strconcat(DBUS_VRRP_OBJECT_ROOT,\n#if HAVE_DECL_CLONE_NEWNET\n\t\t\t  global_data->network_namespace ? \"/\" : \"\", global_data->network_namespace ? global_data->network_namespace : \"\",\n#endif\n\t\t\t  global_data->instance_name ? \"/\" : \"\", global_data->instance_name ? global_data->instance_name : \"\",\n\n\t\t\t  \"/Vrrp\", NULL);\n}\n", "target": 0, "idx": 75950}
{"func": " void DOMStorageContextWrapper::Shutdown() {\n  DCHECK(context_.get());\n  mojo_task_runner_->PostTask(\n      FROM_HERE, base::BindOnce(&LocalStorageContextMojo::ShutdownAndDelete,\n                                base::Unretained(mojo_state_)));\n  mojo_state_ = nullptr;\n   if (mojo_session_state_) {\n     mojo_task_runner_->PostTask(\n         FROM_HERE, base::BindOnce(&SessionStorageContextMojo::ShutdownAndDelete,\n                                   base::Unretained(mojo_session_state_)));\n     mojo_session_state_ = nullptr;\n   }\n   memory_pressure_listener_.reset();\n  context_->task_runner()->PostShutdownBlockingTask(\n      FROM_HERE, DOMStorageTaskRunner::PRIMARY_SEQUENCE,\n      base::BindOnce(&DOMStorageContextImpl::Shutdown, context_));\n }\n", "target": 1, "idx": 187034}
{"func": "static inline void shmem_unacct_blocks(unsigned long flags, long pages)\n{\n\tif (flags & VM_NORESERVE)\n\t\tvm_unacct_memory(pages * VM_ACCT(PAGE_CACHE_SIZE));\n}\n", "target": 0, "idx": 33554}
{"func": "kex_input_kexinit(int type, u_int32_t seq, void *ctxt)\n{\n\tstruct ssh *ssh = ctxt;\n\tstruct kex *kex = ssh->kex;\n\tconst u_char *ptr;\n\tu_int i;\n\tsize_t dlen;\n\tint r;\n\n\tdebug(\"SSH2_MSG_KEXINIT received\");\n \tif (kex == NULL)\n \t\treturn SSH_ERR_INVALID_ARGUMENT;\n \n \tptr = sshpkt_ptr(ssh, &dlen);\n \tif ((r = sshbuf_put(kex->peer, ptr, dlen)) != 0)\n \t\treturn r;\n\n\t/* discard packet */\n\tfor (i = 0; i < KEX_COOKIE_LEN; i++)\n\t\tif ((r = sshpkt_get_u8(ssh, NULL)) != 0)\n\t\t\treturn r;\n\tfor (i = 0; i < PROPOSAL_MAX; i++)\n\t\tif ((r = sshpkt_get_string(ssh, NULL, NULL)) != 0)\n\t\t\treturn r;\n\t/*\n\t * XXX RFC4253 sec 7: \"each side MAY guess\" - currently no supported\n\t * KEX method has the server move first, but a server might be using\n\t * a custom method or one that we otherwise don't support. We should\n\t * be prepared to remember first_kex_follows here so we can eat a\n\t * packet later.\n\t * XXX2 - RFC4253 is kind of ambiguous on what first_kex_follows means\n\t * for cases where the server *doesn't* go first. I guess we should\n\t * ignore it when it is set for these cases, which is what we do now.\n\t */\n\tif ((r = sshpkt_get_u8(ssh, NULL)) != 0 ||\t/* first_kex_follows */\n\t    (r = sshpkt_get_u32(ssh, NULL)) != 0 ||\t/* reserved */\n\t    (r = sshpkt_get_end(ssh)) != 0)\n\t\t\treturn r;\n\n\tif (!(kex->flags & KEX_INIT_SENT))\n\t\tif ((r = kex_send_kexinit(ssh)) != 0)\n\t\t\treturn r;\n\tif ((r = kex_choose_conf(ssh)) != 0)\n\t\treturn r;\n\n\tif (kex->kex_type < KEX_MAX && kex->kex[kex->kex_type] != NULL)\n\t\treturn (kex->kex[kex->kex_type])(ssh);\n\n\treturn SSH_ERR_INTERNAL_ERROR;\n}\n", "target": 1, "idx": 180074}
{"func": "v8::Local<v8::Object> V8Console::createConsole(InspectedContext* inspectedContext, bool hasMemoryAttribute)\n{\n    v8::Local<v8::Context> context = inspectedContext->context();\n    v8::Context::Scope contextScope(context);\n    v8::Isolate* isolate = context->GetIsolate();\n     v8::MicrotasksScope microtasksScope(isolate, v8::MicrotasksScope::kDoNotRunMicrotasks);\n \n     v8::Local<v8::Object> console = v8::Object::New(isolate);\n \n     createBoundFunctionProperty(context, console, \"debug\", V8Console::debugCallback);\n     createBoundFunctionProperty(context, console, \"error\", V8Console::errorCallback);\n    createBoundFunctionProperty(context, console, \"info\", V8Console::infoCallback);\n    createBoundFunctionProperty(context, console, \"log\", V8Console::logCallback);\n    createBoundFunctionProperty(context, console, \"warn\", V8Console::warnCallback);\n    createBoundFunctionProperty(context, console, \"dir\", V8Console::dirCallback);\n    createBoundFunctionProperty(context, console, \"dirxml\", V8Console::dirxmlCallback);\n    createBoundFunctionProperty(context, console, \"table\", V8Console::tableCallback);\n    createBoundFunctionProperty(context, console, \"trace\", V8Console::traceCallback);\n    createBoundFunctionProperty(context, console, \"group\", V8Console::groupCallback);\n    createBoundFunctionProperty(context, console, \"groupCollapsed\", V8Console::groupCollapsedCallback);\n    createBoundFunctionProperty(context, console, \"groupEnd\", V8Console::groupEndCallback);\n    createBoundFunctionProperty(context, console, \"clear\", V8Console::clearCallback);\n    createBoundFunctionProperty(context, console, \"count\", V8Console::countCallback);\n    createBoundFunctionProperty(context, console, \"assert\", V8Console::assertCallback);\n    createBoundFunctionProperty(context, console, \"markTimeline\", V8Console::markTimelineCallback);\n    createBoundFunctionProperty(context, console, \"profile\", V8Console::profileCallback);\n    createBoundFunctionProperty(context, console, \"profileEnd\", V8Console::profileEndCallback);\n    createBoundFunctionProperty(context, console, \"timeline\", V8Console::timelineCallback);\n    createBoundFunctionProperty(context, console, \"timelineEnd\", V8Console::timelineEndCallback);\n    createBoundFunctionProperty(context, console, \"time\", V8Console::timeCallback);\n     createBoundFunctionProperty(context, console, \"timeEnd\", V8Console::timeEndCallback);\n     createBoundFunctionProperty(context, console, \"timeStamp\", V8Console::timeStampCallback);\n \n    bool success = console->SetPrototype(context, v8::Object::New(isolate)).FromMaybe(false);\n    DCHECK(success);\n     if (hasMemoryAttribute)\n         console->SetAccessorProperty(toV8StringInternalized(isolate, \"memory\"), V8_FUNCTION_NEW_REMOVE_PROTOTYPE(context, V8Console::memoryGetterCallback, console, 0).ToLocalChecked(), V8_FUNCTION_NEW_REMOVE_PROTOTYPE(context, V8Console::memorySetterCallback, v8::Local<v8::Value>(), 0).ToLocalChecked(), static_cast<v8::PropertyAttribute>(v8::None), v8::DEFAULT);\n \n    console->SetPrivate(context, inspectedContextPrivateKey(isolate), v8::External::New(isolate, inspectedContext));\n    return console;\n}\n", "target": 1, "idx": 185976}
{"func": "static void print_bpf_insn(struct bpf_insn *insn)\n {\n \tu8 class = BPF_CLASS(insn->code);\n \n\tif (class == BPF_ALU || class == BPF_ALU64) {\n\t\tif (BPF_SRC(insn->code) == BPF_X)\n\t\t\tverbose(\"(%02x) %sr%d %s %sr%d\\n\",\n\t\t\t\tinsn->code, class == BPF_ALU ? \"(u32) \" : \"\",\n\t\t\t\tinsn->dst_reg,\n\t\t\t\tbpf_alu_string[BPF_OP(insn->code) >> 4],\n\t\t\t\tclass == BPF_ALU ? \"(u32) \" : \"\",\n\t\t\t\tinsn->src_reg);\n\t\telse\n\t\t\tverbose(\"(%02x) %sr%d %s %s%d\\n\",\n\t\t\t\tinsn->code, class == BPF_ALU ? \"(u32) \" : \"\",\n\t\t\t\tinsn->dst_reg,\n\t\t\t\tbpf_alu_string[BPF_OP(insn->code) >> 4],\n\t\t\t\tclass == BPF_ALU ? \"(u32) \" : \"\",\n\t\t\t\tinsn->imm);\n\t} else if (class == BPF_STX) {\n\t\tif (BPF_MODE(insn->code) == BPF_MEM)\n\t\t\tverbose(\"(%02x) *(%s *)(r%d %+d) = r%d\\n\",\n\t\t\t\tinsn->code,\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->dst_reg,\n\t\t\t\tinsn->off, insn->src_reg);\n\t\telse if (BPF_MODE(insn->code) == BPF_XADD)\n\t\t\tverbose(\"(%02x) lock *(%s *)(r%d %+d) += r%d\\n\",\n\t\t\t\tinsn->code,\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->dst_reg, insn->off,\n\t\t\t\tinsn->src_reg);\n\t\telse\n\t\t\tverbose(\"BUG_%02x\\n\", insn->code);\n\t} else if (class == BPF_ST) {\n\t\tif (BPF_MODE(insn->code) != BPF_MEM) {\n\t\t\tverbose(\"BUG_st_%02x\\n\", insn->code);\n\t\t\treturn;\n\t\t}\n\t\tverbose(\"(%02x) *(%s *)(r%d %+d) = %d\\n\",\n\t\t\tinsn->code,\n\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\tinsn->dst_reg,\n\t\t\tinsn->off, insn->imm);\n\t} else if (class == BPF_LDX) {\n\t\tif (BPF_MODE(insn->code) != BPF_MEM) {\n\t\t\tverbose(\"BUG_ldx_%02x\\n\", insn->code);\n\t\t\treturn;\n\t\t}\n\t\tverbose(\"(%02x) r%d = *(%s *)(r%d %+d)\\n\",\n\t\t\tinsn->code, insn->dst_reg,\n\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\tinsn->src_reg, insn->off);\n\t} else if (class == BPF_LD) {\n\t\tif (BPF_MODE(insn->code) == BPF_ABS) {\n\t\t\tverbose(\"(%02x) r0 = *(%s *)skb[%d]\\n\",\n\t\t\t\tinsn->code,\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->imm);\n\t\t} else if (BPF_MODE(insn->code) == BPF_IND) {\n\t\t\tverbose(\"(%02x) r0 = *(%s *)skb[r%d + %d]\\n\",\n \t\t\t\tinsn->code,\n \t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n \t\t\t\tinsn->src_reg, insn->imm);\n\t\t} else if (BPF_MODE(insn->code) == BPF_IMM) {\n\t\t\tverbose(\"(%02x) r%d = 0x%x\\n\",\n\t\t\t\tinsn->code, insn->dst_reg, insn->imm);\n \t\t} else {\n \t\t\tverbose(\"BUG_ld_%02x\\n\", insn->code);\n \t\t\treturn;\n\t\t}\n\t} else if (class == BPF_JMP) {\n\t\tu8 opcode = BPF_OP(insn->code);\n\n\t\tif (opcode == BPF_CALL) {\n\t\t\tverbose(\"(%02x) call %s#%d\\n\", insn->code,\n\t\t\t\tfunc_id_name(insn->imm), insn->imm);\n\t\t} else if (insn->code == (BPF_JMP | BPF_JA)) {\n\t\t\tverbose(\"(%02x) goto pc%+d\\n\",\n\t\t\t\tinsn->code, insn->off);\n\t\t} else if (insn->code == (BPF_JMP | BPF_EXIT)) {\n\t\t\tverbose(\"(%02x) exit\\n\", insn->code);\n\t\t} else if (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tverbose(\"(%02x) if r%d %s r%d goto pc%+d\\n\",\n\t\t\t\tinsn->code, insn->dst_reg,\n\t\t\t\tbpf_jmp_string[BPF_OP(insn->code) >> 4],\n\t\t\t\tinsn->src_reg, insn->off);\n\t\t} else {\n\t\t\tverbose(\"(%02x) if r%d %s 0x%x goto pc%+d\\n\",\n\t\t\t\tinsn->code, insn->dst_reg,\n\t\t\t\tbpf_jmp_string[BPF_OP(insn->code) >> 4],\n\t\t\t\tinsn->imm, insn->off);\n\t\t}\n\t} else {\n\t\tverbose(\"(%02x) %s\\n\", insn->code, bpf_class_string[class]);\n\t}\n}\n", "target": 1, "idx": 181293}
{"func": "static int vapic_enter(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tstruct page *page;\n\tif (!apic || !apic->vapic_addr)\n\t\treturn 0;\n\tpage = gfn_to_page(vcpu->kvm, apic->vapic_addr >> PAGE_SHIFT);\n\tif (is_error_page(page))\n\t\treturn -EFAULT;\n\tvcpu->arch.apic->vapic_page = page;\n\treturn 0;\n}\n", "target": 1, "idx": 179121}
{"func": "void cJSON_AddItemReferenceToObject( cJSON *object, const char *string, cJSON *item )\n{\n\tcJSON_AddItemToObject( object, string, create_reference( item ) );\n}\n", "target": 1, "idx": 180438}
{"func": "static int out_open_pcm_devices(struct stream_out *out)\n{\n struct pcm_device *pcm_device;\n struct listnode *node;\n struct audio_device *adev = out->dev;\n int ret = 0;\n\n    list_for_each(node, &out->pcm_dev_list) {\n        pcm_device = node_to_item(node, struct pcm_device, stream_list_node);\n        ALOGV(\"%s: Opening PCM device card_id(%d) device_id(%d)\",\n              __func__, pcm_device->pcm_profile->card, pcm_device->pcm_profile->device);\n\n if (pcm_device->pcm_profile->dsp_name) {\n            pcm_device->dsp_context = cras_dsp_context_new(pcm_device->pcm_profile->config.rate,\n (adev->mode == AUDIO_MODE_IN_CALL || adev->mode == AUDIO_MODE_IN_COMMUNICATION)\n ? \"voice-comm\" : \"playback\");\n if (pcm_device->dsp_context) {\n                cras_dsp_set_variable(pcm_device->dsp_context, \"dsp_name\",\n                                      pcm_device->pcm_profile->dsp_name);\n                cras_dsp_load_pipeline(pcm_device->dsp_context);\n }\n }\n\n        pcm_device->pcm = pcm_open(pcm_device->pcm_profile->card, pcm_device->pcm_profile->device,\n                               PCM_OUT | PCM_MONOTONIC, &pcm_device->pcm_profile->config);\n\n if (pcm_device->pcm && !pcm_is_ready(pcm_device->pcm)) {\n            ALOGE(\"%s: %s\", __func__, pcm_get_error(pcm_device->pcm));\n            pcm_device->pcm = NULL;\n            ret = -EIO;\n goto error_open;\n }\n /*\n        * If the stream rate differs from the PCM rate, we need to\n        * create a resampler.\n        */\n if (out->sample_rate != pcm_device->pcm_profile->config.rate) {\n            ALOGV(\"%s: create_resampler(), pcm_device_card(%d), pcm_device_id(%d), \\\n                    out_rate(%d), device_rate(%d)\",__func__,\n                    pcm_device->pcm_profile->card, pcm_device->pcm_profile->device,\n                    out->sample_rate, pcm_device->pcm_profile->config.rate);\n            ret = create_resampler(out->sample_rate,\n                    pcm_device->pcm_profile->config.rate,\n                    audio_channel_count_from_out_mask(out->channel_mask),\n                    RESAMPLER_QUALITY_DEFAULT,\n                    NULL,\n &pcm_device->resampler);\n            pcm_device->res_byte_count = 0;\n            pcm_device->res_buffer = NULL;\n }\n }\n return ret;\n\nerror_open:\n    out_close_pcm_devices(out);\n return ret;\n}\n", "target": 0, "idx": 175489}
{"func": "CopyInterps(CompatInfo *info, bool needSymbol, enum xkb_match_operation pred,\n            struct collect *collect)\n{\n    SymInterpInfo *si;\n\n    darray_foreach(si, info->interps)\n        if (si->interp.match == pred &&\n            (si->interp.sym != XKB_KEY_NoSymbol) == needSymbol)\n            darray_append(collect->sym_interprets, si->interp);\n}\n", "target": 0, "idx": 78922}
{"func": "nm_setting_vpn_foreach_secret (NMSettingVPN *setting,\n                               NMVPNIterFunc func,\n                               gpointer user_data)\n{\n\tg_return_if_fail (setting != NULL);\n\tg_return_if_fail (NM_IS_SETTING_VPN (setting));\n\n\tforeach_item_helper (NM_SETTING_VPN_GET_PRIVATE (setting)->secrets, func, user_data);\n}\n", "target": 0, "idx": 2839}
{"func": "    ~AutoInstallCurrentThreadPlatformMock()\n    {\n        Platform::initialize(m_oldPlatform);\n    }\n", "target": 0, "idx": 145115}
{"func": "static void emitnumber(JF, double num)\n{\n\tif (num == 0) {\n\t\temit(J, F, OP_NUMBER_0);\n\t\tif (signbit(num))\n\t\t\temit(J, F, OP_NEG);\n\t} else if (num == 1) {\n\t\temit(J, F, OP_NUMBER_1);\n\t} else if (num == (js_Instruction)num) {\n\t\temit(J, F, OP_NUMBER_POS);\n\t\temitraw(J, F, (js_Instruction)num);\n\t} else if (num < 0 && -num == (js_Instruction)(-num)) {\n\t\temit(J, F, OP_NUMBER_NEG);\n\t\temitraw(J, F, (js_Instruction)(-num));\n\t} else {\n\t\temit(J, F, OP_NUMBER);\n\t\temitraw(J, F, addnumber(J, F, num));\n\t}\n}\n", "target": 0, "idx": 7930}
{"func": "static struct mount *clone_mnt(struct mount *old, struct dentry *root,\n\t\t\t\t\tint flag)\n{\n\tstruct super_block *sb = old->mnt.mnt_sb;\n\tstruct mount *mnt;\n\tint err;\n\n\tmnt = alloc_vfsmnt(old->mnt_devname);\n\tif (!mnt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (flag & (CL_SLAVE | CL_PRIVATE | CL_SHARED_TO_SLAVE))\n\t\tmnt->mnt_group_id = 0; /* not a peer of original */\n\telse\n\t\tmnt->mnt_group_id = old->mnt_group_id;\n\n\tif ((flag & CL_MAKE_SHARED) && !mnt->mnt_group_id) {\n\t\terr = mnt_alloc_group_id(mnt);\n\t\tif (err)\n\t\t\tgoto out_free;\n\t}\n \n \tmnt->mnt.mnt_flags = old->mnt.mnt_flags & ~(MNT_WRITE_HOLD|MNT_MARKED);\n \t/* Don't allow unprivileged users to change mount flags */\n\tif ((flag & CL_UNPRIVILEGED) && (mnt->mnt.mnt_flags & MNT_READONLY))\n\t\tmnt->mnt.mnt_flags |= MNT_LOCK_READONLY;\n \n \t/* Don't allow unprivileged users to reveal what is under a mount */\n \tif ((flag & CL_UNPRIVILEGED) && list_empty(&old->mnt_expire))\n\t\tmnt->mnt.mnt_flags |= MNT_LOCKED;\n\n\tatomic_inc(&sb->s_active);\n\tmnt->mnt.mnt_sb = sb;\n\tmnt->mnt.mnt_root = dget(root);\n\tmnt->mnt_mountpoint = mnt->mnt.mnt_root;\n\tmnt->mnt_parent = mnt;\n\tlock_mount_hash();\n\tlist_add_tail(&mnt->mnt_instance, &sb->s_mounts);\n\tunlock_mount_hash();\n\n\tif ((flag & CL_SLAVE) ||\n\t    ((flag & CL_SHARED_TO_SLAVE) && IS_MNT_SHARED(old))) {\n\t\tlist_add(&mnt->mnt_slave, &old->mnt_slave_list);\n\t\tmnt->mnt_master = old;\n\t\tCLEAR_MNT_SHARED(mnt);\n\t} else if (!(flag & CL_PRIVATE)) {\n\t\tif ((flag & CL_MAKE_SHARED) || IS_MNT_SHARED(old))\n\t\t\tlist_add(&mnt->mnt_share, &old->mnt_share);\n\t\tif (IS_MNT_SLAVE(old))\n\t\t\tlist_add(&mnt->mnt_slave, &old->mnt_slave);\n\t\tmnt->mnt_master = old->mnt_master;\n\t}\n\tif (flag & CL_MAKE_SHARED)\n\t\tset_mnt_shared(mnt);\n\n\t/* stick the duplicate mount on the same expiry list\n\t * as the original if that was on one */\n\tif (flag & CL_EXPIRE) {\n\t\tif (!list_empty(&old->mnt_expire))\n\t\t\tlist_add(&mnt->mnt_expire, &old->mnt_expire);\n\t}\n\n\treturn mnt;\n\n out_free:\n\tmnt_free_id(mnt);\n\tfree_vfsmnt(mnt);\n\treturn ERR_PTR(err);\n}\n", "target": 1, "idx": 179452}
{"func": " SPL_METHOD(SplFileObject, next)\n {\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n\n\tspl_filesystem_file_free_line(intern TSRMLS_CC);\n\tif (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_READ_AHEAD)) {\n\t\tspl_filesystem_file_read_line(getThis(), intern, 1 TSRMLS_CC);\n\t}\n\tintern->u.file.current_line_num++;\n} /* }}} */\n\n/* {{{ proto void SplFileObject::setFlags(int flags)\n", "target": 1, "idx": 180229}
{"func": "void GLES2DecoderImpl::DoScheduleCALayerInUseQueryCHROMIUM(\n    GLsizei count,\n    const volatile GLuint* textures) {\n  std::vector<gl::GLSurface::CALayerInUseQuery> queries;\n  queries.reserve(count);\n  for (GLsizei i = 0; i < count; ++i) {\n    gl::GLImage* image = nullptr;\n    GLuint texture_id = textures[i];\n    if (texture_id) {\n      TextureRef* ref = texture_manager()->GetTexture(texture_id);\n      if (!ref) {\n        LOCAL_SET_GL_ERROR(GL_INVALID_VALUE,\n                           \"glScheduleCALayerInUseQueryCHROMIUM\",\n                           \"unknown texture\");\n        return;\n      }\n      Texture::ImageState image_state;\n      image = ref->texture()->GetLevelImage(ref->texture()->target(), 0,\n                                            &image_state);\n    }\n    gl::GLSurface::CALayerInUseQuery query;\n    query.image = image;\n    query.texture = texture_id;\n    queries.push_back(query);\n  }\n\n  surface_->ScheduleCALayerInUseQuery(std::move(queries));\n}\n", "target": 0, "idx": 154062}
{"func": "static bool getCoverageFormat4(vector<uint32_t>& coverage, const uint8_t* data, size_t size) {\n const size_t kSegCountOffset = 6;\n const size_t kEndCountOffset = 14;\n const size_t kHeaderSize = 16;\n const size_t kSegmentSize = 8; // total size of array elements for one segment\n if (kEndCountOffset > size) {\n return false;\n }\n size_t segCount = readU16(data, kSegCountOffset) >> 1;\n if (kHeaderSize + segCount * kSegmentSize > size) {\n return false;\n }\n for (size_t i = 0; i < segCount; i++) {\n uint32_t end = readU16(data, kEndCountOffset + 2 * i);\n\n         uint32_t start = readU16(data, kHeaderSize + 2 * (segCount + i));\n         if (end < start) {\n             return false;\n         }\n         uint32_t rangeOffset = readU16(data, kHeaderSize + 2 * (3 * segCount + i));\n if (rangeOffset == 0) {\n uint32_t delta = readU16(data, kHeaderSize + 2 * (2 * segCount + i));\n if (((end + delta) & 0xffff) > end - start) {\n                addRange(coverage, start, end + 1);\n } else {\n for (uint32_t j = start; j < end + 1; j++) {\n if (((j + delta) & 0xffff) != 0) {\n                        addRange(coverage, j, j + 1);\n }\n }\n }\n } else {\n for (uint32_t j = start; j < end + 1; j++) {\n uint32_t actualRangeOffset = kHeaderSize + 6 * segCount + rangeOffset +\n (i + j - start) * 2;\n if (actualRangeOffset + 2 > size) {\n continue;\n }\n uint32_t glyphId = readU16(data, actualRangeOffset);\n if (glyphId != 0) {\n                    addRange(coverage, j, j + 1);\n }\n }\n }\n }\n return true;\n}\n", "target": 1, "idx": 187918}
{"func": "static void dispatchSimAuthentication(Parcel &p, RequestInfo *pRI)\n{\n    RIL_SimAuthentication pf;\n int32_t  t;\n status_t status;\n\n    memset(&pf, 0, sizeof(pf));\n\n    status = p.readInt32(&t);\n    pf.authContext = (int) t;\n    pf.authData = strdupReadString(p);\n    pf.aid = strdupReadString(p);\n\n    startRequest;\n    appendPrintBuf(\"authContext=%s, authData=%s, aid=%s\", pf.authContext, pf.authData, pf.aid);\n    closeRequest;\n    printRequest(pRI->token, pRI->pCI->requestNumber);\n\n if (status != NO_ERROR) {\n goto invalid;\n }\n    CALL_ONREQUEST(pRI->pCI->requestNumber, &pf, sizeof(pf), pRI, pRI->socket_id);\n\n#ifdef MEMSET_FREED\n    memsetString(pf.authData);\n    memsetString(pf.aid);\n#endif\n\n    free(pf.authData);\n    free(pf.aid);\n\n#ifdef MEMSET_FREED\n    memset(&pf, 0, sizeof(pf));\n#endif\n\n return;\ninvalid:\n    invalidCommandBlock(pRI);\n return;\n}\n", "target": 0, "idx": 175281}
{"func": "PHP_RSHUTDOWN_FUNCTION(phar) /* {{{ */\n{\n\tint i;\n\n\tPHAR_GLOBALS->request_ends = 1;\n\n\tif (PHAR_GLOBALS->request_init)\n\t{\n\t\tphar_release_functions(TSRMLS_C);\n\t\tzend_hash_destroy(&(PHAR_GLOBALS->phar_alias_map));\n\t\tPHAR_GLOBALS->phar_alias_map.arBuckets = NULL;\n\t\tzend_hash_destroy(&(PHAR_GLOBALS->phar_fname_map));\n\t\tPHAR_GLOBALS->phar_fname_map.arBuckets = NULL;\n\t\tzend_hash_destroy(&(PHAR_GLOBALS->phar_persist_map));\n\t\tPHAR_GLOBALS->phar_persist_map.arBuckets = NULL;\n\t\tPHAR_GLOBALS->phar_SERVER_mung_list = 0;\n\n\t\tif (PHAR_GLOBALS->cached_fp) {\n\t\t\tfor (i = 0; i < zend_hash_num_elements(&cached_phars); ++i) {\n\t\t\t\tif (PHAR_GLOBALS->cached_fp[i].fp) {\n\t\t\t\t\tphp_stream_close(PHAR_GLOBALS->cached_fp[i].fp);\n\t\t\t\t}\n\t\t\t\tif (PHAR_GLOBALS->cached_fp[i].ufp) {\n\t\t\t\t\tphp_stream_close(PHAR_GLOBALS->cached_fp[i].ufp);\n\t\t\t\t}\n\t\t\t\tefree(PHAR_GLOBALS->cached_fp[i].manifest);\n\t\t\t}\n\t\t\tefree(PHAR_GLOBALS->cached_fp);\n\t\t\tPHAR_GLOBALS->cached_fp = 0;\n\t\t}\n\n\t\tPHAR_GLOBALS->request_init = 0;\n\n\t\tif (PHAR_G(cwd)) {\n\t\t\tefree(PHAR_G(cwd));\n\t\t}\n\n\t\tPHAR_G(cwd) = NULL;\n\t\tPHAR_G(cwd_len) = 0;\n\t\tPHAR_G(cwd_init) = 0;\n\t}\n\n\tPHAR_GLOBALS->request_done = 1;\n\treturn SUCCESS;\n}\n/* }}} */\n", "target": 0, "idx": 4448}
{"func": "  virtual void Observe(NotificationType type,\n                       const NotificationSource& source,\n                       const NotificationDetails& details) {\n    if (type == NotificationType::NAV_LIST_PRUNED) {\n      notification_count_++;\n      details_ = *(Details<NavigationController::PrunedDetails>(details).ptr());\n    }\n  }\n", "target": 0, "idx": 104775}
{"func": "void DriveFileStreamReader::InitializeAfterGetFileContentByPathInitialized(\n    const base::FilePath& drive_file_path,\n    const InitializeCompletionCallback& callback,\n    FileError error,\n    scoped_ptr<DriveEntryProto> entry,\n    const base::FilePath& local_cache_file_path) {\n  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));\n\n  if (error != FILE_ERROR_OK) {\n    callback.Run(error, scoped_ptr<DriveEntryProto>());\n    return;\n  }\n  DCHECK(entry);\n\n  if (local_cache_file_path.empty()) {\n     reader_proxy_.reset(\n         new internal::NetworkReaderProxy(\n            entry->file_info().size(),\n             base::Bind(&internal::CancelGetFile,\n                        drive_file_system_getter_, drive_file_path)));\n     callback.Run(FILE_ERROR_OK, entry.Pass());\n    return;\n  }\n\n  scoped_ptr<net::FileStream> file_stream(new net::FileStream(NULL));\n  net::FileStream* file_stream_ptr = file_stream.get();\n  net::CompletionCallback open_completion_callback = base::Bind(\n      &DriveFileStreamReader::InitializeAfterLocalFileOpen,\n      weak_ptr_factory_.GetWeakPtr(),\n      callback,\n      base::Passed(&entry),\n      base::Passed(&file_stream));\n  int result = file_stream_ptr->Open(\n      local_cache_file_path,\n      base::PLATFORM_FILE_OPEN | base::PLATFORM_FILE_READ |\n      base::PLATFORM_FILE_ASYNC,\n      open_completion_callback);\n\n  if (result == net::ERR_IO_PENDING) {\n    return;\n  }\n\n  open_completion_callback.Run(result);\n}\n", "target": 1, "idx": 185003}
{"func": "static void __net_exit sctp_net_exit(struct net *net)\n {\n \t/* Free the local address list */\n \tsctp_free_addr_wq(net);\n \tsctp_free_local_addr_list(net);\n \n\t/* Free the control endpoint.  */\n\tinet_ctl_sock_destroy(net->sctp.ctl_sock);\n \tsctp_dbg_objcnt_exit(net);\n \n \tsctp_proc_exit(net);\n \tcleanup_sctp_mibs(net);\n \tsctp_sysctl_net_unregister(net);\n }\n", "target": 1, "idx": 179779}
{"func": "uint64_t esp_reg_read(ESPState *s, uint32_t saddr)\n{\n    uint32_t old_val;\n\n     trace_esp_mem_readb(saddr, s->rregs[saddr]);\n     switch (saddr) {\n     case ESP_FIFO:\n        if (s->ti_size > 0) {\n             s->ti_size--;\n            if ((s->rregs[ESP_RSTAT] & STAT_PIO_MASK) == 0) {\n                /* Data out.  */\n                qemu_log_mask(LOG_UNIMP,\n                              \"esp: PIO data read not implemented\\n\");\n                s->rregs[ESP_FIFO] = 0;\n            } else {\n                s->rregs[ESP_FIFO] = s->ti_buf[s->ti_rptr++];\n            }\n             esp_raise_irq(s);\n         }\n        if (s->ti_size == 0) {\n             s->ti_rptr = 0;\n             s->ti_wptr = 0;\n         }\n            s->ti_wptr = 0;\n        }\n        break;\n    case ESP_RINTR:\n        /* Clear sequence step, interrupt register and all status bits\n           except TC */\n        old_val = s->rregs[ESP_RINTR];\n        s->rregs[ESP_RINTR] = 0;\n        s->rregs[ESP_RSTAT] &= ~STAT_TC;\n        s->rregs[ESP_RSEQ] = SEQ_CD;\n        esp_lower_irq(s);\n\n        return old_val;\n    case ESP_TCHI:\n        /* Return the unique id if the value has never been written */\n        if (!s->tchi_written) {\n            return s->chip_id;\n        }\n    default:\n        break;\n    }\n", "target": 1, "idx": 178184}
{"func": "static void enforcedRangeByteAttrAttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)\n{\n    ExceptionState exceptionState(ExceptionState::SetterContext, \"enforcedRangeByteAttr\", \"TestObject\", info.Holder(), info.GetIsolate());\n    TestObject* imp = V8TestObject::toNative(info.Holder());\n    V8TRYCATCH_EXCEPTION_VOID(int, cppValue, toInt8(jsValue, EnforceRange, exceptionState), exceptionState);\n    imp->setEnforcedRangeByteAttr(cppValue);\n}\n", "target": 0, "idx": 130748}
{"func": "void __init early_trap_init(void)\n{\n\tset_intr_gate_ist(X86_TRAP_DB, &debug, DEBUG_STACK);\n\t/* int3 can be called from all */\n\tset_system_intr_gate_ist(X86_TRAP_BP, &int3, DEBUG_STACK);\n#ifdef CONFIG_X86_32\n\tset_intr_gate(X86_TRAP_PF, page_fault);\n#endif\n\tload_idt(&idt_descr);\n}\n", "target": 0, "idx": 35419}
{"func": "MagickExport const PixelPacket *GetVirtualPixelQueue(const Image *image)\n{\n  CacheInfo\n    *restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  if (cache_info->methods.get_virtual_pixels_handler !=\n       (GetVirtualPixelsHandler) NULL)\n    return(cache_info->methods.get_virtual_pixels_handler(image));\n  assert(id < (int) cache_info->number_threads);\n  return(GetVirtualPixelsNexus(cache_info,cache_info->nexus_info[id]));\n}\n", "target": 0, "idx": 73637}
{"func": "vips_foreign_load_gif_scan_image( VipsForeignLoadGif *gif ) \n {\n \tVipsObjectClass *class = VIPS_OBJECT_GET_CLASS( gif );\n \tGifFileType *file = gif->file;\n\tColorMapObject *map = file->Image.ColorMap ?\n\t\tfile->Image.ColorMap : file->SColorMap;\n \n \tGifByteType *extension;\n \n \tif( DGifGetImageDesc( gif->file ) == GIF_ERROR ) {\n\t\tvips_foreign_load_gif_error( gif ); \n\t\treturn( -1 );\n\t}\n\n\t/* Check that the frame looks sane. Perhaps giflib checks\n\t * this for us.\n\t */\n\tif( file->Image.Left < 0 ||\n\t\tfile->Image.Width < 1 ||\n\t\tfile->Image.Width > 10000 ||\n\t\tfile->Image.Left + file->Image.Width > file->SWidth ||\n\t\tfile->Image.Top < 0 ||\n\t\tfile->Image.Height < 1 ||\n\t\tfile->Image.Height > 10000 ||\n\t\tfile->Image.Top + file->Image.Height > file->SHeight ) {\n\t\tvips_error( class->nickname, \"%s\", _( \"bad frame size\" ) ); \n\t\treturn( -1 ); \n\t}\n \n \t/* Test for a non-greyscale colourmap for this frame.\n \t */\n \tif( !gif->has_colour &&\n \t\tmap ) {\n \t\tint i;\n\n\t\tfor( i = 0; i < map->ColorCount; i++ ) \n\t\t\tif( map->Colors[i].Red != map->Colors[i].Green ||\n\t\t\t\tmap->Colors[i].Green != map->Colors[i].Blue ) {\n\t\t\t\tgif->has_colour = TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\t/* Step over compressed image data.\n\t */\n\tdo {\n\t\tif( vips_foreign_load_gif_code_next( gif, &extension ) ) \n\t\t\treturn( -1 );\n\t} while( extension != NULL );\n\n\treturn( 0 );\n}\n", "target": 1, "idx": 182662}
{"func": "void InspectorOverlay::update()\n{\n    if (isEmpty()) {\n        m_client->hideHighlight();\n        return;\n    }\n\n    FrameView* view = m_page->mainFrame()->view();\n    if (!view)\n        return;\n    IntRect viewRect = view->visibleContentRect();\n    FrameView* overlayView = overlayPage()->mainFrame()->view();\n\n    IntSize frameViewFullSize = view->visibleContentRect(ScrollableArea::IncludeScrollbars).size();\n    IntSize size = m_size.isEmpty() ? frameViewFullSize : m_size;\n    size.scale(m_page->pageScaleFactor());\n    overlayView->resize(size);\n\n    reset(size, m_size.isEmpty() ? IntSize() : frameViewFullSize, viewRect.x(), viewRect.y());\n\n    drawGutter();\n    drawNodeHighlight();\n    drawQuadHighlight();\n     if (!m_inspectModeEnabled)\n         drawPausedInDebuggerMessage();\n     drawViewSize();\n    drawOverridesMessage();\n \n     overlayPage()->mainFrame()->document()->recalcStyle(Force);\n    if (overlayView->needsLayout())\n        overlayView->layout();\n\n    m_client->highlight();\n}\n", "target": 1, "idx": 184234}
{"func": "int sock_getsockopt(struct socket *sock, int level, int optname,\n\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\n\tunion {\n\t\tint val;\n\t\tstruct linger ling;\n\t\tstruct timeval tm;\n\t} v;\n\n\tint lv = sizeof(int);\n\tint len;\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (len < 0)\n\t\treturn -EINVAL;\n\n\tmemset(&v, 0, sizeof(v));\n\n\tswitch (optname) {\n\tcase SO_DEBUG:\n\t\tv.val = sock_flag(sk, SOCK_DBG);\n\t\tbreak;\n\n\tcase SO_DONTROUTE:\n\t\tv.val = sock_flag(sk, SOCK_LOCALROUTE);\n\t\tbreak;\n\n\tcase SO_BROADCAST:\n\t\tv.val = !!sock_flag(sk, SOCK_BROADCAST);\n\t\tbreak;\n\n\tcase SO_SNDBUF:\n\t\tv.val = sk->sk_sndbuf;\n\t\tbreak;\n\n\tcase SO_RCVBUF:\n\t\tv.val = sk->sk_rcvbuf;\n\t\tbreak;\n\n\tcase SO_REUSEADDR:\n\t\tv.val = sk->sk_reuse;\n\t\tbreak;\n\n\tcase SO_KEEPALIVE:\n\t\tv.val = !!sock_flag(sk, SOCK_KEEPOPEN);\n\t\tbreak;\n\n\tcase SO_TYPE:\n\t\tv.val = sk->sk_type;\n\t\tbreak;\n\n\tcase SO_PROTOCOL:\n\t\tv.val = sk->sk_protocol;\n\t\tbreak;\n\n\tcase SO_DOMAIN:\n\t\tv.val = sk->sk_family;\n\t\tbreak;\n\n\tcase SO_ERROR:\n\t\tv.val = -sock_error(sk);\n\t\tif (v.val == 0)\n\t\t\tv.val = xchg(&sk->sk_err_soft, 0);\n\t\tbreak;\n\n\tcase SO_OOBINLINE:\n\t\tv.val = !!sock_flag(sk, SOCK_URGINLINE);\n\t\tbreak;\n\n\tcase SO_NO_CHECK:\n\t\tv.val = sk->sk_no_check;\n\t\tbreak;\n\n\tcase SO_PRIORITY:\n\t\tv.val = sk->sk_priority;\n\t\tbreak;\n\n\tcase SO_LINGER:\n\t\tlv\t\t= sizeof(v.ling);\n\t\tv.ling.l_onoff\t= !!sock_flag(sk, SOCK_LINGER);\n\t\tv.ling.l_linger\t= sk->sk_lingertime / HZ;\n\t\tbreak;\n\n\tcase SO_BSDCOMPAT:\n\t\tsock_warn_obsolete_bsdism(\"getsockopt\");\n\t\tbreak;\n\n\tcase SO_TIMESTAMP:\n\t\tv.val = sock_flag(sk, SOCK_RCVTSTAMP) &&\n\t\t\t\t!sock_flag(sk, SOCK_RCVTSTAMPNS);\n\t\tbreak;\n\n\tcase SO_TIMESTAMPNS:\n\t\tv.val = sock_flag(sk, SOCK_RCVTSTAMPNS);\n\t\tbreak;\n\n\tcase SO_TIMESTAMPING:\n\t\tv.val = 0;\n\t\tif (sock_flag(sk, SOCK_TIMESTAMPING_TX_HARDWARE))\n\t\t\tv.val |= SOF_TIMESTAMPING_TX_HARDWARE;\n\t\tif (sock_flag(sk, SOCK_TIMESTAMPING_TX_SOFTWARE))\n\t\t\tv.val |= SOF_TIMESTAMPING_TX_SOFTWARE;\n\t\tif (sock_flag(sk, SOCK_TIMESTAMPING_RX_HARDWARE))\n\t\t\tv.val |= SOF_TIMESTAMPING_RX_HARDWARE;\n\t\tif (sock_flag(sk, SOCK_TIMESTAMPING_RX_SOFTWARE))\n\t\t\tv.val |= SOF_TIMESTAMPING_RX_SOFTWARE;\n\t\tif (sock_flag(sk, SOCK_TIMESTAMPING_SOFTWARE))\n\t\t\tv.val |= SOF_TIMESTAMPING_SOFTWARE;\n\t\tif (sock_flag(sk, SOCK_TIMESTAMPING_SYS_HARDWARE))\n\t\t\tv.val |= SOF_TIMESTAMPING_SYS_HARDWARE;\n\t\tif (sock_flag(sk, SOCK_TIMESTAMPING_RAW_HARDWARE))\n\t\t\tv.val |= SOF_TIMESTAMPING_RAW_HARDWARE;\n\t\tbreak;\n\n\tcase SO_RCVTIMEO:\n\t\tlv = sizeof(struct timeval);\n\t\tif (sk->sk_rcvtimeo == MAX_SCHEDULE_TIMEOUT) {\n\t\t\tv.tm.tv_sec = 0;\n\t\t\tv.tm.tv_usec = 0;\n\t\t} else {\n\t\t\tv.tm.tv_sec = sk->sk_rcvtimeo / HZ;\n\t\t\tv.tm.tv_usec = ((sk->sk_rcvtimeo % HZ) * 1000000) / HZ;\n\t\t}\n\t\tbreak;\n\n\tcase SO_SNDTIMEO:\n\t\tlv = sizeof(struct timeval);\n\t\tif (sk->sk_sndtimeo == MAX_SCHEDULE_TIMEOUT) {\n\t\t\tv.tm.tv_sec = 0;\n\t\t\tv.tm.tv_usec = 0;\n\t\t} else {\n\t\t\tv.tm.tv_sec = sk->sk_sndtimeo / HZ;\n\t\t\tv.tm.tv_usec = ((sk->sk_sndtimeo % HZ) * 1000000) / HZ;\n\t\t}\n\t\tbreak;\n\n\tcase SO_RCVLOWAT:\n\t\tv.val = sk->sk_rcvlowat;\n\t\tbreak;\n\n\tcase SO_SNDLOWAT:\n\t\tv.val = 1;\n \t\tbreak;\n \n \tcase SO_PASSCRED:\n\t\tv.val = test_bit(SOCK_PASSCRED, &sock->flags) ? 1 : 0;\n \t\tbreak;\n \n \tcase SO_PEERCRED:\n\t{\n\t\tstruct ucred peercred;\n\t\tif (len > sizeof(peercred))\n\t\t\tlen = sizeof(peercred);\n\t\tcred_to_ucred(sk->sk_peer_pid, sk->sk_peer_cred, &peercred);\n\t\tif (copy_to_user(optval, &peercred, len))\n\t\t\treturn -EFAULT;\n\t\tgoto lenout;\n\t}\n\n\tcase SO_PEERNAME:\n\t{\n\t\tchar address[128];\n\n\t\tif (sock->ops->getname(sock, (struct sockaddr *)address, &lv, 2))\n\t\t\treturn -ENOTCONN;\n\t\tif (lv < len)\n\t\t\treturn -EINVAL;\n\t\tif (copy_to_user(optval, address, len))\n\t\t\treturn -EFAULT;\n\t\tgoto lenout;\n\t}\n\n\t/* Dubious BSD thing... Probably nobody even uses it, but\n\t * the UNIX standard wants it for whatever reason... -DaveM\n\t */\n\tcase SO_ACCEPTCONN:\n\t\tv.val = sk->sk_state == TCP_LISTEN;\n \t\tbreak;\n \n \tcase SO_PASSSEC:\n\t\tv.val = test_bit(SOCK_PASSSEC, &sock->flags) ? 1 : 0;\n \t\tbreak;\n \n \tcase SO_PEERSEC:\n\t\treturn security_socket_getpeersec_stream(sock, optval, optlen, len);\n\n\tcase SO_MARK:\n\t\tv.val = sk->sk_mark;\n\t\tbreak;\n\n\tcase SO_RXQ_OVFL:\n\t\tv.val = !!sock_flag(sk, SOCK_RXQ_OVFL);\n\t\tbreak;\n\n\tcase SO_WIFI_STATUS:\n\t\tv.val = !!sock_flag(sk, SOCK_WIFI_STATUS);\n\t\tbreak;\n\n\tcase SO_PEEK_OFF:\n\t\tif (!sock->ops->set_peek_off)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tv.val = sk->sk_peek_off;\n\t\tbreak;\n\tcase SO_NOFCS:\n\t\tv.val = !!sock_flag(sk, SOCK_NOFCS);\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\n\tif (len > lv)\n\t\tlen = lv;\n\tif (copy_to_user(optval, &v, len))\n\t\treturn -EFAULT;\nlenout:\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n", "target": 1, "idx": 180780}
{"func": "__u32 secure_ipv6_id(const __be32 daddr[4])\n{\n\tconst struct keydata *keyptr;\n\t__u32 hash[4];\n\tkeyptr = get_keyptr();\n\thash[0] = (__force __u32)daddr[0];\n\thash[1] = (__force __u32)daddr[1];\n\thash[2] = (__force __u32)daddr[2];\n\thash[3] = (__force __u32)daddr[3];\n\treturn half_md4_transform(hash, keyptr->secret);\n}\n", "target": 1, "idx": 178938}
{"func": "static int compile_search(struct Context *ctx, const struct Pattern *pat, struct Buffer *buf)\n{\n  if (do_search(pat, 0) == 0)\n    return 0;\n\n  if (pat->not)\n    mutt_buffer_addstr(buf, \"NOT \");\n\n  if (pat->child)\n  {\n    int clauses;\n\n    clauses = do_search(pat->child, 1);\n    if (clauses > 0)\n    {\n      const struct Pattern *clause = pat->child;\n\n      mutt_buffer_addch(buf, '(');\n\n      while (clauses)\n      {\n        if (do_search(clause, 0))\n        {\n          if (pat->op == MUTT_OR && clauses > 1)\n            mutt_buffer_addstr(buf, \"OR \");\n          clauses--;\n\n          if (compile_search(ctx, clause, buf) < 0)\n            return -1;\n\n          if (clauses)\n            mutt_buffer_addch(buf, ' ');\n        }\n        clause = clause->next;\n      }\n\n      mutt_buffer_addch(buf, ')');\n    }\n  }\n  else\n  {\n    char term[STRING];\n    char *delim = NULL;\n\n    switch (pat->op)\n    {\n      case MUTT_HEADER:\n        mutt_buffer_addstr(buf, \"HEADER \");\n\n        /* extract header name */\n        delim = strchr(pat->p.str, ':');\n        if (!delim)\n        {\n          mutt_error(_(\"Header search without header name: %s\"), pat->p.str);\n           return -1;\n         }\n         *delim = '\\0';\n        imap_quote_string(term, sizeof(term), pat->p.str);\n         mutt_buffer_addstr(buf, term);\n         mutt_buffer_addch(buf, ' ');\n \n         /* and field */\n         *delim = ':';\n         delim++;\n         SKIPWS(delim);\n        imap_quote_string(term, sizeof(term), delim);\n         mutt_buffer_addstr(buf, term);\n         break;\n       case MUTT_BODY:\n         mutt_buffer_addstr(buf, \"BODY \");\n        imap_quote_string(term, sizeof(term), pat->p.str);\n         mutt_buffer_addstr(buf, term);\n         break;\n       case MUTT_WHOLE_MSG:\n         mutt_buffer_addstr(buf, \"TEXT \");\n        imap_quote_string(term, sizeof(term), pat->p.str);\n         mutt_buffer_addstr(buf, term);\n         break;\n       case MUTT_SERVERSEARCH:\n      {\n        struct ImapData *idata = ctx->data;\n        if (!mutt_bit_isset(idata->capabilities, X_GM_EXT1))\n        {\n          mutt_error(_(\"Server-side custom search not supported: %s\"), pat->p.str);\n          return -1;\n         }\n       }\n         mutt_buffer_addstr(buf, \"X-GM-RAW \");\n        imap_quote_string(term, sizeof(term), pat->p.str);\n         mutt_buffer_addstr(buf, term);\n         break;\n     }\n  }\n\n  return 0;\n}\n", "target": 1, "idx": 182307}
{"func": "IPV6DefragReverseSimpleTest(void)\n{\n    DefragContext *dc = NULL;\n    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;\n    Packet *reassembled = NULL;\n    int id = 12;\n    int i;\n    int ret = 0;\n\n    DefragInit();\n\n    dc = DefragContextNew();\n     if (dc == NULL)\n         goto end;\n \n    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n    if (Defrag(NULL, NULL, p3, NULL) != NULL)\n        goto end;\n    if (Defrag(NULL, NULL, p2, NULL) != NULL)\n        goto end;\n    reassembled = Defrag(NULL, NULL, p1, NULL);\n    if (reassembled == NULL)\n        goto end;\n\n    /* 40 bytes in we should find 8 bytes of A. */\n    for (i = 40; i < 40 + 8; i++) {\n        if (GET_PKT_DATA(reassembled)[i] != 'A')\n            goto end;\n    }\n\n    /* 28 bytes in we should find 8 bytes of B. */\n    for (i = 48; i < 48 + 8; i++) {\n        if (GET_PKT_DATA(reassembled)[i] != 'B')\n            goto end;\n    }\n\n    /* And 36 bytes in we should find 3 bytes of C. */\n    for (i = 56; i < 56 + 3; i++) {\n        if (GET_PKT_DATA(reassembled)[i] != 'C')\n            goto end;\n    }\n\n    ret = 1;\nend:\n    if (dc != NULL)\n        DefragContextDestroy(dc);\n    if (p1 != NULL)\n        SCFree(p1);\n    if (p2 != NULL)\n        SCFree(p2);\n    if (p3 != NULL)\n        SCFree(p3);\n    if (reassembled != NULL)\n        SCFree(reassembled);\n\n    DefragDestroy();\n    return ret;\n}\n", "target": 1, "idx": 181482}
{"func": "  void HandleMousePressEvent(int x, int y) {\n    WebMouseEvent event(\n        WebInputEvent::kMouseDown, WebFloatPoint(x, y), WebFloatPoint(x, y),\n        WebPointerProperties::Button::kLeft, 0,\n        WebInputEvent::Modifiers::kLeftButtonDown, CurrentTimeTicksInSeconds());\n    event.SetFrameScale(1);\n    GetEventHandler().HandleMousePressEvent(event);\n  }\n", "target": 0, "idx": 144868}
{"func": "static int br_mdb_add_group(struct net_bridge *br, struct net_bridge_port *port,\n\t\t\t    struct br_ip *group, unsigned char state)\n{\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tstruct net_bridge_mdb_htable *mdb;\n\tint err;\n\n\tmdb = mlock_dereference(br->mdb, br);\n\tmp = br_mdb_ip_get(mdb, group);\n\tif (!mp) {\n\t\tmp = br_multicast_new_group(br, port, group);\n\t\terr = PTR_ERR(mp);\n\t\tif (IS_ERR(mp))\n\t\t\treturn err;\n\t}\n\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (p->port == port)\n\t\t\treturn -EEXIST;\n\t\tif ((unsigned long)p->port < (unsigned long)port)\n\t\t\tbreak;\n\t}\n\n\tp = br_multicast_new_port_group(port, group, *pp, state);\n\tif (unlikely(!p))\n\t\treturn -ENOMEM;\n\trcu_assign_pointer(*pp, p);\n\n\tbr_mdb_notify(br->dev, port, group, RTM_NEWMDB);\n\treturn 0;\n}\n", "target": 0, "idx": 29974}
{"func": "void test_parser(void) {\n \tint i, retval;\n \tbzrtpPacket_t *zrtpPacket;\n \n\t/* Create zrtp Context to use H0-H3 chains and others */\n\tbzrtpContext_t *context87654321 = bzrtp_createBzrtpContext(0x87654321);\n\tbzrtpContext_t *context12345678 = bzrtp_createBzrtpContext(0x12345678);\n\n\n\t/* replace created H by the patterns one to be able to generate the correct packet */\n\tmemcpy (context12345678->channelContext[0]->selfH[0], H12345678[0], 32);\n\tmemcpy (context12345678->channelContext[0]->selfH[1], H12345678[1], 32);\n\tmemcpy (context12345678->channelContext[0]->selfH[2], H12345678[2], 32);\n\tmemcpy (context12345678->channelContext[0]->selfH[3], H12345678[3], 32);\n\tmemcpy (context87654321->channelContext[0]->selfH[0], H87654321[0], 32);\n\tmemcpy (context87654321->channelContext[0]->selfH[1], H87654321[1], 32);\n\tmemcpy (context87654321->channelContext[0]->selfH[2], H87654321[2], 32);\n\tmemcpy (context87654321->channelContext[0]->selfH[3], H87654321[3], 32);\n\n\t/* preset the key agreement algo in the contexts */\n\tcontext87654321->channelContext[0]->keyAgreementAlgo = ZRTP_KEYAGREEMENT_DH3k;\n\tcontext12345678->channelContext[0]->keyAgreementAlgo = ZRTP_KEYAGREEMENT_DH3k;\n\tcontext87654321->channelContext[0]->cipherAlgo = ZRTP_CIPHER_AES1;\n\tcontext12345678->channelContext[0]->cipherAlgo = ZRTP_CIPHER_AES1;\n\tcontext87654321->channelContext[0]->hashAlgo = ZRTP_HASH_S256;\n\tcontext12345678->channelContext[0]->hashAlgo = ZRTP_HASH_S256;\n\n\tupdateCryptoFunctionPointers(context87654321->channelContext[0]);\n\tupdateCryptoFunctionPointers(context12345678->channelContext[0]);\n\n\t/* set the zrtp and mac keys */\n\tcontext87654321->channelContext[0]->mackeyi = (uint8_t *)malloc(32);\n\tcontext12345678->channelContext[0]->mackeyi = (uint8_t *)malloc(32);\n\tcontext87654321->channelContext[0]->mackeyr = (uint8_t *)malloc(32);\n\tcontext12345678->channelContext[0]->mackeyr = (uint8_t *)malloc(32);\n\n\tcontext87654321->channelContext[0]->zrtpkeyi = (uint8_t *)malloc(16);\n\tcontext12345678->channelContext[0]->zrtpkeyi = (uint8_t *)malloc(16);\n\tcontext87654321->channelContext[0]->zrtpkeyr = (uint8_t *)malloc(16);\n\tcontext12345678->channelContext[0]->zrtpkeyr = (uint8_t *)malloc(16);\n\n\tmemcpy(context12345678->channelContext[0]->mackeyi, mackeyi, 32);\n\tmemcpy(context12345678->channelContext[0]->mackeyr, mackeyr, 32);\n\tmemcpy(context12345678->channelContext[0]->zrtpkeyi, zrtpkeyi, 16);\n\tmemcpy(context12345678->channelContext[0]->zrtpkeyr, zrtpkeyr, 16);\n\tmemcpy(context87654321->channelContext[0]->mackeyi, mackeyi, 32);\n\tmemcpy(context87654321->channelContext[0]->mackeyr, mackeyr, 32);\n\tmemcpy(context87654321->channelContext[0]->zrtpkeyi, zrtpkeyi, 16);\n\tmemcpy(context87654321->channelContext[0]->zrtpkeyr, zrtpkeyr, 16);\n\n\t/* set the role: 87654321 is initiator in our exchange pattern */\n\tcontext12345678->channelContext[0]->role = RESPONDER;\n\n\tfor (i=0; i<TEST_PACKET_NUMBER; i++) {\n\t\tuint8_t freePacketFlag = 1;\n \t\t/* parse a packet string from patterns */\n \t\tzrtpPacket = bzrtp_packetCheck(patternZRTPPackets[i], patternZRTPMetaData[i][0], (patternZRTPMetaData[i][1])-1, &retval);\n \t\tretval +=  bzrtp_packetParser((patternZRTPMetaData[i][2]==0x87654321)?context12345678:context87654321, (patternZRTPMetaData[i][2]==0x87654321)?context12345678->channelContext[0]:context87654321->channelContext[0], patternZRTPPackets[i], patternZRTPMetaData[i][0], zrtpPacket);\n\t\t/*printf(\"parsing Ret val is %x index is %d\\n\", retval, i);*/\n \t\t/* We must store some packets in the context if we want to be able to parse further packets */\n \t\tif (zrtpPacket->messageType==MSGTYPE_HELLO) {\n \t\t\tif (patternZRTPMetaData[i][2]==0x87654321) {\n \t\t\t\tcontext12345678->channelContext[0]->peerPackets[HELLO_MESSAGE_STORE_ID] = zrtpPacket;\n \t\t\t} else {\n \t\t\t\tcontext87654321->channelContext[0]->peerPackets[HELLO_MESSAGE_STORE_ID] = zrtpPacket;\n \t\t\t}\n \t\t\tfreePacketFlag = 0;\n \t\t}\n\t\tif (zrtpPacket->messageType==MSGTYPE_COMMIT) {\n\t\t\tif (patternZRTPMetaData[i][2]==0x87654321) {\n\t\t\t\tcontext12345678->channelContext[0]->peerPackets[COMMIT_MESSAGE_STORE_ID] = zrtpPacket;\n\t\t\t} else {\n\t\t\t\tcontext87654321->channelContext[0]->peerPackets[COMMIT_MESSAGE_STORE_ID] = zrtpPacket;\n\t\t\t}\n\t\t\tfreePacketFlag = 0;\n\t\t}\n\t\tif (zrtpPacket->messageType==MSGTYPE_DHPART1 || zrtpPacket->messageType==MSGTYPE_DHPART2) {\n\t\t\tif (patternZRTPMetaData[i][2]==0x87654321) {\n\t\t\t\tcontext12345678->channelContext[0]->peerPackets[DHPART_MESSAGE_STORE_ID] = zrtpPacket;\n\t\t\t} else {\n\t\t\t\tcontext87654321->channelContext[0]->peerPackets[DHPART_MESSAGE_STORE_ID] = zrtpPacket;\n\t\t\t}\n\t\t\tfreePacketFlag = 0;\n\t\t}\n\t\t/* free the packet string as will be created again by the packetBuild function and might have been copied by packetParser */\n\t\tfree(zrtpPacket->packetString);\n\t\t/* build a packet string from the parser packet*/\n\t\tretval = bzrtp_packetBuild((patternZRTPMetaData[i][2]==0x12345678)?context12345678:context87654321, (patternZRTPMetaData[i][2]==0x12345678)?context12345678->channelContext[0]:context87654321->channelContext[0], zrtpPacket, patternZRTPMetaData[i][1]);\n\t\t/* if (retval ==0) {\n\t\t\tpacketDump(zrtpPacket, 1);\n\t\t} else {\n\t\t\tbzrtp_message(\"Ret val is %x index is %d\\n\", retval, i);\n\t\t}*/\n\n\t\t/* check they are the same */\n\t\tif (zrtpPacket->packetString != NULL) {\n\t\t\tCU_ASSERT_TRUE(memcmp(zrtpPacket->packetString, patternZRTPPackets[i], patternZRTPMetaData[i][0]) == 0);\n\t\t} else {\n\t\t\tCU_FAIL(\"Unable to build packet\");\n\t\t}\n\n \t\tif (freePacketFlag == 1) {\n \t\t\tbzrtp_freeZrtpPacket(zrtpPacket);\n \t\t}\n \t}\n \n \tbzrtp_destroyBzrtpContext(context87654321, 0x87654321);\n \tbzrtp_destroyBzrtpContext(context12345678, 0x12345678);\n \n }\n", "target": 1, "idx": 182001}
{"func": "status_t MediaPlayerService::Client::setNextPlayer(const sp<IMediaPlayer>& player) {\n\n     ALOGV(\"setNextPlayer\");\n     Mutex::Autolock l(mLock);\n     sp<Client> c = static_cast<Client*>(player.get());\n     mNextClient = c;\n \n     if (c != NULL) {\n if (mAudioOutput != NULL) {\n            mAudioOutput->setNextOutput(c->mAudioOutput);\n } else if ((mPlayer != NULL) && !mPlayer->hardwareOutput()) {\n            ALOGE(\"no current audio output\");\n }\n\n if ((mPlayer != NULL) && (mNextClient->getPlayer() != NULL)) {\n            mPlayer->setNextPlayer(mNextClient->getPlayer());\n }\n }\n\n return OK;\n}\n", "target": 1, "idx": 187420}
{"func": "static void vmx_complete_nested_posted_interrupt(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tint max_irr;\n\tvoid *vapic_page;\n\tu16 status;\n\n\tif (!vmx->nested.pi_desc || !vmx->nested.pi_pending)\n\t\treturn;\n\n\tvmx->nested.pi_pending = false;\n\tif (!pi_test_and_clear_on(vmx->nested.pi_desc))\n\t\treturn;\n\n\tmax_irr = find_last_bit((unsigned long *)vmx->nested.pi_desc->pir, 256);\n\tif (max_irr != 256) {\n\t\tvapic_page = kmap(vmx->nested.virtual_apic_page);\n\t\t__kvm_apic_update_irr(vmx->nested.pi_desc->pir,\n\t\t\tvapic_page, &max_irr);\n\t\tkunmap(vmx->nested.virtual_apic_page);\n\n\t\tstatus = vmcs_read16(GUEST_INTR_STATUS);\n\t\tif ((u8)max_irr > ((u8)status & 0xff)) {\n\t\t\tstatus &= ~0xff;\n\t\t\tstatus |= (u8)max_irr;\n\t\t\tvmcs_write16(GUEST_INTR_STATUS, status);\n\t\t}\n\t}\n\n\tnested_mark_vmcs12_pages_dirty(vcpu);\n}\n", "target": 0, "idx": 81025}
{"func": "CuePoint::~CuePoint()\n{\n    delete[] m_track_positions;\n}\n", "target": 1, "idx": 188484}
{"func": "selRead(const char  *fname)\n{\nFILE  *fp;\nSEL   *sel;\n\n    PROCNAME(\"selRead\");\n\n    if (!fname)\n        return (SEL *)ERROR_PTR(\"fname not defined\", procName, NULL);\n\n    if ((fp = fopenReadStream(fname)) == NULL)\n        return (SEL *)ERROR_PTR(\"stream not opened\", procName, NULL);\n    if ((sel = selReadStream(fp)) == NULL) {\n        fclose(fp);\n        return (SEL *)ERROR_PTR(\"sela not returned\", procName, NULL);\n    }\n    fclose(fp);\n\n    return sel;\n}\n", "target": 0, "idx": 84221}
{"func": "iakerb_gss_delete_sec_context(OM_uint32 *minor_status,\n                               gss_ctx_id_t *context_handle,\n                               gss_buffer_t output_token)\n {\n    OM_uint32 major_status = GSS_S_COMPLETE;\n \n     if (output_token != GSS_C_NO_BUFFER) {\n         output_token->length = 0;\n         output_token->value = NULL;\n     }\n \n     *minor_status = 0;\n \n    if (*context_handle != GSS_C_NO_CONTEXT) {\n        iakerb_ctx_id_t iakerb_ctx = (iakerb_ctx_id_t)*context_handle;\n        if (iakerb_ctx->magic == KG_IAKERB_CONTEXT) {\n            iakerb_release_context(iakerb_ctx);\n            *context_handle = GSS_C_NO_CONTEXT;\n        } else {\n            assert(iakerb_ctx->magic == KG_CONTEXT);\n            major_status = krb5_gss_delete_sec_context(minor_status,\n                                                       context_handle,\n                                                       output_token);\n        }\n    }\n    return major_status;\n }\n", "target": 1, "idx": 179817}
{"func": "void dm_lock_md_type(struct mapped_device *md)\n{\n\tmutex_lock(&md->type_lock);\n}\n", "target": 0, "idx": 85914}
{"func": "add_range(fz_context *ctx, pdf_cmap *cmap, unsigned int low, unsigned int high, unsigned int out, int check_for_overlap, int many)\n{\n\tint current;\n\tcmap_splay *tree;\n\n\tif (low > high)\n\t{\n\t\tfz_warn(ctx, \"range limits out of range in cmap %s\", cmap->cmap_name);\n\t\treturn;\n\t}\n\n\ttree = cmap->tree;\n\n\tif (cmap->tlen)\n\t{\n\t\tunsigned int move = cmap->ttop;\n\t\tunsigned int gt = EMPTY;\n\t\tunsigned int lt = EMPTY;\n\t\tif (check_for_overlap)\n\t\t{\n\t\t\t/* Check for collision with the current node */\n\t\t\tdo\n\t\t\t{\n\t\t\t\tcurrent = move;\n\t\t\t\t/* Cases we might meet:\n\t\t\t\t * tree[i]:        <----->\n\t\t\t\t * case 0:     <->\n\t\t\t\t * case 1:     <------->\n\t\t\t\t * case 2:     <------------->\n\t\t\t\t * case 3:           <->\n\t\t\t\t * case 4:           <------->\n\t\t\t\t * case 5:                 <->\n\t\t\t\t */\n\t\t\t\tif (low <= tree[current].low && tree[current].low <= high)\n\t\t\t\t{\n\t\t\t\t\t/* case 1, reduces to case 0 */\n\t\t\t\t\t/* or case 2, deleting the node */\n\t\t\t\t\ttree[current].out += high + 1 - tree[current].low;\n\t\t\t\t\ttree[current].low = high + 1;\n\t\t\t\t\tif (tree[current].low > tree[current].high)\n\t\t\t\t\t{\n\t\t\t\t\t\tmove = delete_node(cmap, current);\n\t\t\t\t\t\tcurrent = EMPTY;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (low <= tree[current].high && tree[current].high <= high)\n\t\t\t\t{\n\t\t\t\t\t/* case 4, reduces to case 5 */\n\t\t\t\t\ttree[current].high = low - 1;\n\t\t\t\t\tassert(tree[current].low <= tree[current].high);\n\t\t\t\t}\n\t\t\t\telse if (tree[current].low < low && high < tree[current].high)\n\t\t\t\t{\n                                        /* case 3, reduces to case 5 */\n                                        int new_high = tree[current].high;\n                                        tree[current].high = low-1;\n                                       add_range(ctx, cmap, high+1, new_high, tree[current].out + high + 1 - tree[current].low, 0, many);\n                                }\n                                /* Now look for where to move to next (left for case 0, right for case 5) */\n                                if (tree[current].low > high) {\n\t\t\t\t\tmove = tree[current].left;\n\t\t\t\t\tgt = current;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmove = tree[current].right;\n\t\t\t\t\tlt = current;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (move != EMPTY);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdo\n\t\t\t{\n\t\t\t\tcurrent = move;\n\t\t\t\tif (tree[current].low > high)\n\t\t\t\t{\n\t\t\t\t\tmove = tree[current].left;\n\t\t\t\t\tgt = current;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmove = tree[current].right;\n\t\t\t\t\tlt = current;\n\t\t\t\t}\n\t\t\t} while (move != EMPTY);\n\t\t}\n\t\t/* current is now the node to which we would be adding the new node */\n\t\t/* lt is the last node we traversed which is lt the new node. */\n\t\t/* gt is the last node we traversed which is gt the new node. */\n\n\t\tif (!many)\n\t\t{\n\t\t\t/* Check for the 'merge' cases. */\n\t\t\tif (lt != EMPTY && !tree[lt].many && tree[lt].high == low-1 && tree[lt].out - tree[lt].low == out - low)\n\t\t\t{\n\t\t\t\ttree[lt].high = high;\n\t\t\t\tif (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)\n\t\t\t\t{\n\t\t\t\t\ttree[lt].high = tree[gt].high;\n\t\t\t\t\tdelete_node(cmap, gt);\n\t\t\t\t}\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tif (gt != EMPTY && !tree[gt].many && tree[gt].low == high+1 && tree[gt].out - tree[gt].low == out - low)\n\t\t\t{\n\t\t\t\ttree[gt].low = low;\n\t\t\t\ttree[gt].out = out;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t\tcurrent = EMPTY;\n\n\tif (cmap->tlen == cmap->tcap)\n\t{\n\t\tint new_cap = cmap->tcap ? cmap->tcap * 2 : 256;\n\t\ttree = cmap->tree = fz_resize_array(ctx, cmap->tree, new_cap, sizeof *cmap->tree);\n\t\tcmap->tcap = new_cap;\n\t}\n\ttree[cmap->tlen].low = low;\n\ttree[cmap->tlen].high = high;\n\ttree[cmap->tlen].out = out;\n\ttree[cmap->tlen].parent = current;\n\ttree[cmap->tlen].left = EMPTY;\n\ttree[cmap->tlen].right = EMPTY;\n\ttree[cmap->tlen].many = many;\n\tcmap->tlen++;\n\tif (current == EMPTY)\n\t\tcmap->ttop = 0;\n\telse if (tree[current].low > high)\n\t\ttree[current].left = cmap->tlen-1;\n\telse\n\t{\n\t\tassert(tree[current].high < low);\n\t\ttree[current].right = cmap->tlen-1;\n\t}\n\tmove_to_root(tree, cmap->tlen-1);\n\tcmap->ttop = cmap->tlen-1;\nexit:\n\t{}\n#ifdef CHECK_SPLAY\n\tcheck_splay(cmap->tree, cmap->ttop, 0);\n#endif\n#ifdef DUMP_SPLAY\n\tdump_splay(cmap->tree, cmap->ttop, 0, \"\");\n#endif\n}\n", "target": 1, "idx": 177751}
{"func": "static int rsa_builtin_keygen(RSA *rsa, int bits, BIGNUM *e_value,\n                              BN_GENCB *cb)\n{\n    BIGNUM *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *tmp;\n    BIGNUM local_r0, local_d, local_p;\n    BIGNUM *pr0, *d, *p;\n    int bitsp, bitsq, ok = -1, n = 0;\n    BN_CTX *ctx = NULL;\n    unsigned long error = 0;\n\n    /*\n     * When generating ridiculously small keys, we can get stuck\n     * continually regenerating the same prime values.\n     */\n    if (bits < 16) {\n        ok = 0;             /* we set our own err */\n        RSAerr(RSA_F_RSA_BUILTIN_KEYGEN, RSA_R_KEY_SIZE_TOO_SMALL);\n        goto err;\n    }\n\n    ctx = BN_CTX_new();\n    if (ctx == NULL)\n        goto err;\n    BN_CTX_start(ctx);\n    r0 = BN_CTX_get(ctx);\n    r1 = BN_CTX_get(ctx);\n    r2 = BN_CTX_get(ctx);\n    r3 = BN_CTX_get(ctx);\n    if (r3 == NULL)\n        goto err;\n\n    bitsp = (bits + 1) / 2;\n    bitsq = bits - bitsp;\n\n    /* We need the RSA components non-NULL */\n    if (!rsa->n && ((rsa->n = BN_new()) == NULL))\n        goto err;\n    if (!rsa->d && ((rsa->d = BN_new()) == NULL))\n        goto err;\n    if (!rsa->e && ((rsa->e = BN_new()) == NULL))\n        goto err;\n    if (!rsa->p && ((rsa->p = BN_new()) == NULL))\n        goto err;\n    if (!rsa->q && ((rsa->q = BN_new()) == NULL))\n        goto err;\n    if (!rsa->dmp1 && ((rsa->dmp1 = BN_new()) == NULL))\n        goto err;\n    if (!rsa->dmq1 && ((rsa->dmq1 = BN_new()) == NULL))\n        goto err;\n    if (!rsa->iqmp && ((rsa->iqmp = BN_new()) == NULL))\n        goto err;\n\n     if (BN_copy(rsa->e, e_value) == NULL)\n         goto err;\n \n     BN_set_flags(r2, BN_FLG_CONSTTIME);\n     /* generate p and q */\n     for (;;) {\n        if (!BN_sub(r2, rsa->p, BN_value_one()))\n            goto err;\n        ERR_set_mark();\n        if (BN_mod_inverse(r1, r2, rsa->e, ctx) != NULL) {\n            /* GCD == 1 since inverse exists */\n            break;\n        }\n        error = ERR_peek_last_error();\n        if (ERR_GET_LIB(error) == ERR_LIB_BN\n            && ERR_GET_REASON(error) == BN_R_NO_INVERSE) {\n            /* GCD != 1 */\n            ERR_pop_to_mark();\n        } else {\n            goto err;\n        }\n        if (!BN_GENCB_call(cb, 2, n++))\n            goto err;\n    }\n    if (!BN_GENCB_call(cb, 3, 0))\n        goto err;\n    for (;;) {\n        do {\n            if (!BN_generate_prime_ex(rsa->q, bitsq, 0, NULL, NULL, cb))\n                goto err;\n        } while (BN_cmp(rsa->p, rsa->q) == 0);\n        if (!BN_sub(r2, rsa->q, BN_value_one()))\n            goto err;\n        ERR_set_mark();\n        if (BN_mod_inverse(r1, r2, rsa->e, ctx) != NULL) {\n            /* GCD == 1 since inverse exists */\n            break;\n        }\n        error = ERR_peek_last_error();\n        if (ERR_GET_LIB(error) == ERR_LIB_BN\n            && ERR_GET_REASON(error) == BN_R_NO_INVERSE) {\n            /* GCD != 1 */\n            ERR_pop_to_mark();\n        } else {\n            goto err;\n        }\n        if (!BN_GENCB_call(cb, 2, n++))\n            goto err;\n    }\n    if (!BN_GENCB_call(cb, 3, 1))\n        goto err;\n    if (BN_cmp(rsa->p, rsa->q) < 0) {\n        tmp = rsa->p;\n        rsa->p = rsa->q;\n        rsa->q = tmp;\n    }\n\n    /* calculate n */\n    if (!BN_mul(rsa->n, rsa->p, rsa->q, ctx))\n        goto err;\n\n    /* calculate d */\n    if (!BN_sub(r1, rsa->p, BN_value_one()))\n        goto err;               /* p-1 */\n    if (!BN_sub(r2, rsa->q, BN_value_one()))\n        goto err;               /* q-1 */\n    if (!BN_mul(r0, r1, r2, ctx))\n        goto err;               /* (p-1)(q-1) */\n    if (!(rsa->flags & RSA_FLAG_NO_CONSTTIME)) {\n        pr0 = &local_r0;\n        BN_with_flags(pr0, r0, BN_FLG_CONSTTIME);\n    } else\n        pr0 = r0;\n    if (!BN_mod_inverse(rsa->d, rsa->e, pr0, ctx))\n        goto err;               /* d */\n\n    /* set up d for correct BN_FLG_CONSTTIME flag */\n    if (!(rsa->flags & RSA_FLAG_NO_CONSTTIME)) {\n        d = &local_d;\n        BN_with_flags(d, rsa->d, BN_FLG_CONSTTIME);\n    } else\n        d = rsa->d;\n\n    /* calculate d mod (p-1) */\n    if (!BN_mod(rsa->dmp1, d, r1, ctx))\n        goto err;\n\n    /* calculate d mod (q-1) */\n    if (!BN_mod(rsa->dmq1, d, r2, ctx))\n        goto err;\n\n    /* calculate inverse of q mod p */\n    if (!(rsa->flags & RSA_FLAG_NO_CONSTTIME)) {\n        p = &local_p;\n        BN_with_flags(p, rsa->p, BN_FLG_CONSTTIME);\n    } else\n        p = rsa->p;\n    if (!BN_mod_inverse(rsa->iqmp, rsa->q, p, ctx))\n        goto err;\n\n    ok = 1;\n err:\n    if (ok == -1) {\n        RSAerr(RSA_F_RSA_BUILTIN_KEYGEN, ERR_LIB_BN);\n        ok = 0;\n    }\n    if (ctx != NULL) {\n        BN_CTX_end(ctx);\n        BN_CTX_free(ctx);\n    }\n\n    return ok;\n}\n", "target": 1, "idx": 178500}
{"func": "static struct block_device *ext3_blkdev_get(dev_t dev, struct super_block *sb)\n{\n\tstruct block_device *bdev;\n\tchar b[BDEVNAME_SIZE];\n\n\tbdev = blkdev_get_by_dev(dev, FMODE_READ|FMODE_WRITE|FMODE_EXCL, sb);\n\tif (IS_ERR(bdev))\n\t\tgoto fail;\n \treturn bdev;\n \n fail:\n\text3_msg(sb, \"error: failed to open journal device %s: %ld\",\n \t\t__bdevname(dev, b), PTR_ERR(bdev));\n \n \treturn NULL;\n}\n", "target": 1, "idx": 179281}
{"func": "void SimulateTapWithModifiersAt(WebContents* web_contents,\n                                unsigned modifiers,\n                                const gfx::Point& point) {\n  blink::WebGestureEvent tap(blink::WebGestureEvent::kGestureTap, modifiers,\n                             ui::EventTimeForNow(),\n                             blink::kWebGestureDeviceTouchpad);\n  tap.SetPositionInWidget(gfx::PointF(point));\n  RenderWidgetHostImpl* widget_host = RenderWidgetHostImpl::From(\n      web_contents->GetRenderViewHost()->GetWidget());\n  widget_host->ForwardGestureEvent(tap);\n}\n", "target": 0, "idx": 169345}
{"func": "GF_Err tfdt_Read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_TFBaseMediaDecodeTimeBox *ptr = (GF_TFBaseMediaDecodeTimeBox *)s;\n\n\tif (ptr->version==1) {\n\t\tptr->baseMediaDecodeTime = gf_bs_read_u64(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t} else {\n\t\tptr->baseMediaDecodeTime = (u32) gf_bs_read_u32(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t}\n\treturn GF_OK;\n}\n", "target": 0, "idx": 80512}
{"func": "void PixelBufferRasterWorkerPool::CheckForCompletedUploads() {\n  RasterTaskDeque tasks_with_completed_uploads;\n\n  while (!tasks_with_pending_upload_.empty()) {\n    internal::RasterWorkerPoolTask* task =\n        tasks_with_pending_upload_.front().get();\n\n    if (!resource_provider()->DidSetPixelsComplete(task->resource()->id()))\n      break;\n\n    tasks_with_completed_uploads.push_back(task);\n    tasks_with_pending_upload_.pop_front();\n  }\n\n  DCHECK(client());\n  bool should_force_some_uploads_to_complete =\n      shutdown_ || client()->ShouldForceTasksRequiredForActivationToComplete();\n\n  if (should_force_some_uploads_to_complete) {\n    RasterTaskDeque tasks_with_uploads_to_force;\n    RasterTaskDeque::iterator it = tasks_with_pending_upload_.begin();\n    while (it != tasks_with_pending_upload_.end()) {\n      internal::RasterWorkerPoolTask* task = it->get();\n      DCHECK(pixel_buffer_tasks_.find(task) != pixel_buffer_tasks_.end());\n\n      if (shutdown_ || IsRasterTaskRequiredForActivation(task)) {\n        tasks_with_uploads_to_force.push_back(task);\n        tasks_with_completed_uploads.push_back(task);\n        it = tasks_with_pending_upload_.erase(it);\n        continue;\n      }\n\n      ++it;\n    }\n\n    for (RasterTaskDeque::reverse_iterator it =\n         tasks_with_uploads_to_force.rbegin();\n         it != tasks_with_uploads_to_force.rend(); ++it) {\n      resource_provider()->ForceSetPixelsToComplete((*it)->resource()->id());\n      has_performed_uploads_since_last_flush_ = true;\n    }\n  }\n\n  while (!tasks_with_completed_uploads.empty()) {\n    internal::RasterWorkerPoolTask* task =\n        tasks_with_completed_uploads.front().get();\n\n    resource_provider()->ReleasePixelBuffer(task->resource()->id());\n\n    bytes_pending_upload_ -= task->resource()->bytes();\n\n    task->DidRun(false);\n\n    DCHECK(std::find(completed_tasks_.begin(),\n                     completed_tasks_.end(),\n                     task) == completed_tasks_.end());\n    completed_tasks_.push_back(task);\n\n    tasks_required_for_activation_.erase(task);\n\n    tasks_with_completed_uploads.pop_front();\n  }\n}\n", "target": 0, "idx": 121066}
{"func": "mojom::FrameInputHandler* TestRenderFrame::GetFrameInputHandler() {\n  if (!frame_input_handler_) {\n    mojom::FrameInputHandlerRequest frame_input_handler_request =\n        mojo::MakeRequest(&frame_input_handler_);\n    FrameInputHandlerImpl::CreateMojoService(\n        weak_factory_.GetWeakPtr(), std::move(frame_input_handler_request));\n  }\n  return frame_input_handler_.get();\n}\n", "target": 0, "idx": 152601}
{"func": "static void copy_asoundrc(void) {\n\tchar *src = RUN_ASOUNDRC_FILE ;\n \tchar *dest;\n \tif (asprintf(&dest, \"%s/.asoundrc\", cfg.homedir) == -1)\n \t\terrExit(\"asprintf\");\n \tif (is_link(dest)) {\n \t\tfprintf(stderr, \"Error: %s is a symbolic link\\n\", dest);\n \t\texit(1);\n \t}\n \n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\tdrop_privs(0);\n\t\tint rv = copy_file(src, dest);\n\t\tif (rv)\n\t\t\tfprintf(stderr, \"Warning: cannot transfer .asoundrc in private home directory\\n\");\n\t\telse {\n\t\t\tfs_logger2(\"clone\", dest);\n\t\t}\n\t\t_exit(0);\n\t}\n\twaitpid(child, NULL, 0);\n\tif (chown(dest, getuid(), getgid()) < 0)\n\t\terrExit(\"chown\");\n\tif (chmod(dest, S_IRUSR | S_IWUSR) < 0)\n\t\terrExit(\"chmod\");\n \n \tunlink(src);\n}\n", "target": 1, "idx": 183268}
{"func": "static int __ptrace_may_access(struct task_struct *task, unsigned int mode)\n{\n\tconst struct cred *cred = current_cred(), *tcred;\n\n\t/* May we inspect the given task?\n\t * This check is used both for attaching with ptrace\n\t * and for allowing access to sensitive information in /proc.\n\t *\n\t * ptrace_attach denies several cases that /proc allows\n\t * because setting up the necessary parent/child relationship\n\t * or halting the specified task is impossible.\n\t */\n\tint dumpable = 0;\n\t/* Don't let security modules deny introspection */\n\tif (same_thread_group(task, current))\n\t\treturn 0;\n\trcu_read_lock();\n\ttcred = __task_cred(task);\n\tif (uid_eq(cred->uid, tcred->euid) &&\n\t    uid_eq(cred->uid, tcred->suid) &&\n\t    uid_eq(cred->uid, tcred->uid)  &&\n\t    gid_eq(cred->gid, tcred->egid) &&\n\t    gid_eq(cred->gid, tcred->sgid) &&\n\t    gid_eq(cred->gid, tcred->gid))\n\t\tgoto ok;\n\tif (ptrace_has_cap(tcred->user_ns, mode))\n\t\tgoto ok;\n\trcu_read_unlock();\n\treturn -EPERM;\nok:\n\trcu_read_unlock();\n\tsmp_rmb();\n \tif (task->mm)\n \t\tdumpable = get_dumpable(task->mm);\n \trcu_read_lock();\n\tif (!dumpable && !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {\n \t\trcu_read_unlock();\n \t\treturn -EPERM;\n \t}\n\trcu_read_unlock();\n\n\treturn security_ptrace_access_check(task, mode);\n}\n", "target": 1, "idx": 179221}
{"func": "static int auto_claim(struct libusb_transfer *transfer, int *interface_number, int api_type)\n{\n\tstruct libusb_context *ctx = DEVICE_CTX(transfer->dev_handle->dev);\n\tstruct windows_device_handle_priv *handle_priv = _device_handle_priv(\n\t\ttransfer->dev_handle);\n\tstruct windows_device_priv *priv = _device_priv(transfer->dev_handle->dev);\n\tint current_interface = *interface_number;\n\tint r = LIBUSB_SUCCESS;\n \n \tswitch(api_type) {\n \tcase USB_API_WINUSBX:\n\tcase USB_API_HID:\n \t\tbreak;\n \tdefault:\n \t\treturn LIBUSB_ERROR_INVALID_PARAM;\n\t}\n\n\tusbi_mutex_lock(&autoclaim_lock);\n\tif (current_interface < 0)\t// No serviceable interface was found\n\t{\n\t\tfor (current_interface=0; current_interface<USB_MAXINTERFACES; current_interface++) {\n\t\t\tif ( (priv->usb_interface[current_interface].apib->id == api_type)\n\t\t\t  && (libusb_claim_interface(transfer->dev_handle, current_interface) == LIBUSB_SUCCESS) ) {\n\t\t\t\tusbi_dbg(\"auto-claimed interface %d for control request\", current_interface);\n\t\t\t\tif (handle_priv->autoclaim_count[current_interface] != 0) {\n\t\t\t\t\tusbi_warn(ctx, \"program assertion failed - autoclaim_count was nonzero\");\n\t\t\t\t}\n\t\t\t\thandle_priv->autoclaim_count[current_interface]++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (current_interface == USB_MAXINTERFACES) {\n\t\t\tusbi_err(ctx, \"could not auto-claim any interface\");\n\t\t\tr = LIBUSB_ERROR_NOT_FOUND;\n\t\t}\n\t} else {\n\t\tif (handle_priv->autoclaim_count[current_interface] != 0) {\n\t\t\thandle_priv->autoclaim_count[current_interface]++;\n\t\t}\n\t}\n\tusbi_mutex_unlock(&autoclaim_lock);\n\n\t*interface_number = current_interface;\n\treturn r;\n\n}\n", "target": 1, "idx": 187220}
{"func": " void MediaInterfaceProxy::CreateCdm(\n     media::mojom::ContentDecryptionModuleRequest request) {\n   DCHECK(thread_checker_.CalledOnValidThread());\n  GetMediaInterfaceFactory()->CreateCdm(std::move(request));\n }\n", "target": 1, "idx": 185814}
{"func": "set_pwd ()\n{\n  SHELL_VAR *temp_var, *home_var;\n  char *temp_string, *home_string;\n\n  home_var = find_variable (\"HOME\");\n  home_string = home_var ? value_cell (home_var) : (char *)NULL;\n\n  temp_var = find_variable (\"PWD\");\n  if (temp_var && imported_p (temp_var) &&\n      (temp_string = value_cell (temp_var)) &&\n      same_file (temp_string, \".\", (struct stat *)NULL, (struct stat *)NULL))\n    set_working_directory (temp_string);\n  else if (home_string && interactive_shell && login_shell &&\n\t   same_file (home_string, \".\", (struct stat *)NULL, (struct stat *)NULL))\n    {\n      set_working_directory (home_string);\n      temp_var = bind_variable (\"PWD\", home_string, 0);\n      set_auto_export (temp_var);\n    }\n  else\n    {\n      temp_string = get_working_directory (\"shell-init\");\n      if (temp_string)\n\t{\n\t  temp_var = bind_variable (\"PWD\", temp_string, 0);\n\t  set_auto_export (temp_var);\n\t  free (temp_string);\n\t}\n    }\n\n  /* According to the Single Unix Specification, v2, $OLDPWD is an\n     `environment variable' and therefore should be auto-exported.\n     Make a dummy invisible variable for OLDPWD, and mark it as exported. */\n  temp_var = bind_variable (\"OLDPWD\", (char *)NULL, 0);\n  VSETATTR (temp_var, (att_exported | att_invisible));\n}\n", "target": 0, "idx": 17362}
{"func": "   void AddSimpleRectChunk(TestPaintArtifact& artifact) {\n    artifact\n        .Chunk(TransformPaintPropertyNode::Root(),\n               ClipPaintPropertyNode::Root(), EffectPaintPropertyNode::Root())\n         .RectDrawing(FloatRect(100, 100, 200, 100), Color::kBlack);\n   }\n", "target": 1, "idx": 185693}
{"func": "struct sctp_chunk *sctp_make_shutdown_ack(const struct sctp_association *asoc,\n\t\t\t\t     const struct sctp_chunk *chunk)\n{\n\tstruct sctp_chunk *retval;\n\n\tretval = sctp_make_control(asoc, SCTP_CID_SHUTDOWN_ACK, 0, 0);\n\n\t/* RFC 2960 6.4 Multi-homed SCTP Endpoints\n\t *\n\t * An endpoint SHOULD transmit reply chunks (e.g., SACK,\n\t * HEARTBEAT ACK, * etc.) to the same destination transport\n\t * address from which it * received the DATA or control chunk\n\t * to which it is replying.\n\t *\n\t * [ACK back to where the SHUTDOWN came from.]\n\t */\n\tif (retval && chunk)\n\t\tretval->transport = chunk->transport;\n\n\treturn retval;\n}\n", "target": 0, "idx": 35876}
{"func": "int tls1_set_server_sigalgs(SSL *s)\n{\n    int al;\n    size_t i;\n    /* Clear any shared sigtnature algorithms */\n     if (s->cert->shared_sigalgs) {\n         OPENSSL_free(s->cert->shared_sigalgs);\n         s->cert->shared_sigalgs = NULL;\n     }\n     /* Clear certificate digests and validity flags */\n     for (i = 0; i < SSL_PKEY_NUM; i++) {\n        s->cert->pkeys[i].valid_flags = 0;\n    }\n\n    /* If sigalgs received process it. */\n    if (s->cert->peer_sigalgs) {\n        if (!tls1_process_sigalgs(s)) {\n            SSLerr(SSL_F_TLS1_SET_SERVER_SIGALGS, ERR_R_MALLOC_FAILURE);\n            al = SSL_AD_INTERNAL_ERROR;\n            goto err;\n        }\n        /* Fatal error is no shared signature algorithms */\n        if (!s->cert->shared_sigalgs) {\n            SSLerr(SSL_F_TLS1_SET_SERVER_SIGALGS,\n                   SSL_R_NO_SHARED_SIGATURE_ALGORITHMS);\n            al = SSL_AD_ILLEGAL_PARAMETER;\n            goto err;\n        }\n    } else\n        ssl_cert_set_default_md(s->cert);\n    return 1;\n err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n    return 0;\n}\n", "target": 1, "idx": 177976}
{"func": "static void scsi_read_data(SCSIRequest *req)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    uint32_t n;\n\n    if (r->sector_count == (uint32_t)-1) {\n        DPRINTF(\"Read buf_len=%zd\\n\", r->iov.iov_len);\n        r->sector_count = 0;\n        scsi_req_data(&r->req, r->iov.iov_len);\n        return;\n    }\n    DPRINTF(\"Read sector_count=%d\\n\", r->sector_count);\n    if (r->sector_count == 0) {\n        /* This also clears the sense buffer for REQUEST SENSE.  */\n        scsi_req_complete(&r->req, GOOD);\n        return;\n    }\n\n    /* No data transfer may already be in progress */\n    assert(r->req.aiocb == NULL);\n\n    if (r->req.cmd.mode == SCSI_XFER_TO_DEV) {\n        DPRINTF(\"Data transfer direction invalid\\n\");\n        scsi_read_complete(r, -EINVAL);\n         return;\n     }\n \n    n = r->sector_count;\n    if (n > SCSI_DMA_BUF_SIZE / 512)\n        n = SCSI_DMA_BUF_SIZE / 512;\n     if (s->tray_open) {\n         scsi_read_complete(r, -ENOMEDIUM);\n     }\n    r->iov.iov_len = n * 512;\n    qemu_iovec_init_external(&r->qiov, &r->iov, 1);\n     bdrv_acct_start(s->bs, &r->acct, n * BDRV_SECTOR_SIZE, BDRV_ACCT_READ);\n     r->req.aiocb = bdrv_aio_readv(s->bs, r->sector, &r->qiov, n,\n                               scsi_read_complete, r);\n    if (r->req.aiocb == NULL) {\n        scsi_read_complete(r, -EIO);\n    }\n}\n", "target": 1, "idx": 183093}
{"func": "bool CanUseExistingResource(const net::HttpResponseInfo* http_info) {\n  if (!http_info->headers || http_info->headers->RequiresValidation(\n                                 http_info->request_time,\n                                 http_info->response_time, base::Time::Now())) {\n    return false;\n  }\n\n  std::string value;\n  size_t iter = 0;\n  while (http_info->headers->EnumerateHeader(&iter, \"vary\", &value)) {\n    if (!base::EqualsCaseInsensitiveASCII(value, \"Accept-Encoding\") &&\n        !base::EqualsCaseInsensitiveASCII(value, \"Origin\")) {\n      return false;\n    }\n  }\n  return true;\n}\n", "target": 0, "idx": 164235}
{"func": "bool ChromeContentUtilityClient::OnMessageReceived(\n    const IPC::Message& message) {\n  if (filter_messages_ && !ContainsKey(message_id_whitelist_, message.type()))\n    return false;\n\n  bool handled = true;\n  IPC_BEGIN_MESSAGE_MAP(ChromeContentUtilityClient, message)\n    IPC_MESSAGE_HANDLER(ChromeUtilityMsg_DecodeImage, OnDecodeImage)\n#if defined(OS_CHROMEOS)\n    IPC_MESSAGE_HANDLER(ChromeUtilityMsg_RobustJPEGDecodeImage,\n                        OnRobustJPEGDecodeImage)\n#endif  // defined(OS_CHROMEOS)\n    IPC_MESSAGE_HANDLER(ChromeUtilityMsg_PatchFileBsdiff,\n                        OnPatchFileBsdiff)\n    IPC_MESSAGE_HANDLER(ChromeUtilityMsg_PatchFileCourgette,\n                        OnPatchFileCourgette)\n    IPC_MESSAGE_HANDLER(ChromeUtilityMsg_StartupPing, OnStartupPing)\n #if defined(FULL_SAFE_BROWSING)\n     IPC_MESSAGE_HANDLER(ChromeUtilityMsg_AnalyzeZipFileForDownloadProtection,\n                         OnAnalyzeZipFileForDownloadProtection)\n #endif\n #if defined(ENABLE_EXTENSIONS)\n     IPC_MESSAGE_HANDLER(ChromeUtilityMsg_ParseMediaMetadata,\n                        OnParseMediaMetadata)\n#endif\n#if defined(OS_CHROMEOS)\n    IPC_MESSAGE_HANDLER(ChromeUtilityMsg_CreateZipFile, OnCreateZipFile)\n#endif\n    IPC_MESSAGE_UNHANDLED(handled = false)\n  IPC_END_MESSAGE_MAP()\n\n  for (Handlers::iterator it = handlers_.begin();\n       !handled && it != handlers_.end(); ++it) {\n    handled = (*it)->OnMessageReceived(message);\n  }\n\n  return handled;\n}\n", "target": 1, "idx": 185546}
{"func": "bool SendGoBackJSONRequest(\n    AutomationMessageSender* sender,\n    int browser_index,\n    int tab_index,\n    std::string* error_msg) {\n  DictionaryValue dict;\n  dict.SetString(\"command\", \"GoBack\");\n  dict.SetInteger(\"windex\", browser_index);\n  dict.SetInteger(\"tab_index\", tab_index);\n  DictionaryValue reply_dict;\n  return SendAutomationJSONRequest(sender, dict, &reply_dict, error_msg);\n}\n", "target": 0, "idx": 105548}
{"func": " MediaBuffer *readBuffer(FLAC__uint64 sample) {\n return readBuffer(true, sample);\n }\n", "target": 0, "idx": 175697}
{"func": " bool InputWindowInfo::frameContainsPoint(int32_t x, int32_t y) const {\n    return x >= frameLeft && x <= frameRight\n            && y >= frameTop && y <= frameBottom;\n }\n", "target": 1, "idx": 188191}
{"func": "  UpdateTemporaryGlobalQuotaTask(\n      QuotaManager* manager,\n      int64 new_quota,\n      QuotaCallback* callback)\n      : DatabaseTaskBase(manager),\n        new_quota_(new_quota),\n        callback_(callback) {\n    DCHECK_GE(new_quota, 0);\n  }\n", "target": 0, "idx": 101061}
{"func": " void EmbeddedWorkerContextClient::OnSendMessageToWorker(\n     int thread_id,\n     int embedded_worker_id,\n    int request_id,\n    const IPC::Message& message) {\n  if (!script_context_)\n    return;\n  DCHECK_EQ(embedded_worker_id_, embedded_worker_id);\n  script_context_->OnMessageReceived(request_id, message);\n}\n", "target": 0, "idx": 121731}
{"func": "   static void TearDownTestCase() {\n    vpx_free(source_data_);\n    source_data_ = NULL;\n    vpx_free(reference_data_);\n    reference_data_ = NULL;\n   }\n", "target": 1, "idx": 188601}
{"func": "static void br_multicast_del_pg(struct net_bridge *br,\n\t\t\t\tstruct net_bridge_port_group *pg)\n{\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\n\tmdb = mlock_dereference(br->mdb, br);\n\n\tmp = br_mdb_ip_get(mdb, &pg->addr);\n\tif (WARN_ON(!mp))\n\t\treturn;\n\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (p != pg)\n\t\t\tcontinue;\n\n\t\trcu_assign_pointer(*pp, p->next);\n\t\thlist_del_init(&p->mglist);\n \t\tdel_timer(&p->timer);\n \t\tcall_rcu_bh(&p->rcu, br_multicast_free_pg);\n \n\t\tif (!mp->ports && !mp->mglist &&\n \t\t    netif_running(br->dev))\n \t\t\tmod_timer(&mp->timer, jiffies);\n \n\t\treturn;\n\t}\n\n\tWARN_ON(1);\n}\n", "target": 1, "idx": 179191}
{"func": "void RenderFrameHostImpl::UpdateSubresourceLoaderFactories() {\n  DCHECK(base::FeatureList::IsEnabled(network::features::kNetworkService));\n  if (!has_committed_any_navigation_)\n    return;\n  DCHECK(!IsOutOfProcessNetworkService() ||\n         network_service_connection_error_handler_holder_.is_bound());\n\n  network::mojom::URLLoaderFactoryPtrInfo default_factory_info;\n  bool bypass_redirect_checks = false;\n  if (recreate_default_url_loader_factory_after_network_service_crash_) {\n    bypass_redirect_checks = CreateNetworkServiceDefaultFactoryAndObserve(\n        last_committed_origin_, mojo::MakeRequest(&default_factory_info));\n  }\n\n  std::unique_ptr<URLLoaderFactoryBundleInfo> subresource_loader_factories =\n      std::make_unique<URLLoaderFactoryBundleInfo>(\n          std::move(default_factory_info),\n          URLLoaderFactoryBundleInfo::SchemeMap(),\n          CreateInitiatorSpecificURLLoaderFactories(\n              initiators_requiring_separate_url_loader_factory_),\n          bypass_redirect_checks);\n  GetNavigationControl()->UpdateSubresourceLoaderFactories(\n      std::move(subresource_loader_factories));\n}\n", "target": 0, "idx": 166162}
{"func": "void ContentSecurityPolicy::BindToExecutionContext(\n    ExecutionContext* execution_context) {\n  execution_context_ = execution_context;\n  ApplyPolicySideEffectsToExecutionContext();\n}\n", "target": 0, "idx": 165501}
{"func": "static void JNI_WebApkUpdateManager_StoreWebApkUpdateRequestToFile(\n    JNIEnv* env,\n    const JavaParamRef<jstring>& java_update_request_path,\n    const JavaParamRef<jstring>& java_start_url,\n    const JavaParamRef<jstring>& java_scope,\n    const JavaParamRef<jstring>& java_name,\n    const JavaParamRef<jstring>& java_short_name,\n    const JavaParamRef<jstring>& java_primary_icon_url,\n    const JavaParamRef<jobject>& java_primary_icon_bitmap,\n    const JavaParamRef<jstring>& java_badge_icon_url,\n    const JavaParamRef<jobject>& java_badge_icon_bitmap,\n    const JavaParamRef<jobjectArray>& java_icon_urls,\n    const JavaParamRef<jobjectArray>& java_icon_hashes,\n    jint java_display_mode,\n     jint java_orientation,\n     jlong java_theme_color,\n     jlong java_background_color,\n     const JavaParamRef<jstring>& java_web_manifest_url,\n     const JavaParamRef<jstring>& java_webapk_package,\n     jint java_webapk_version,\n    jboolean java_is_manifest_stale,\n    jint java_update_reason,\n    const JavaParamRef<jobject>& java_callback) {\n  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n\n  std::string update_request_path =\n      ConvertJavaStringToUTF8(env, java_update_request_path);\n\n  ShortcutInfo info(GURL(ConvertJavaStringToUTF8(env, java_start_url)));\n  info.scope = GURL(ConvertJavaStringToUTF8(env, java_scope));\n  info.name = ConvertJavaStringToUTF16(env, java_name);\n  info.short_name = ConvertJavaStringToUTF16(env, java_short_name);\n  info.user_title = info.short_name;\n  info.display = static_cast<blink::WebDisplayMode>(java_display_mode);\n  info.orientation =\n      static_cast<blink::WebScreenOrientationLockType>(java_orientation);\n  info.theme_color = (int64_t)java_theme_color;\n  info.background_color = (int64_t)java_background_color;\n  info.best_primary_icon_url =\n      GURL(ConvertJavaStringToUTF8(env, java_primary_icon_url));\n  info.best_badge_icon_url =\n       GURL(ConvertJavaStringToUTF8(env, java_badge_icon_url));\n   info.manifest_url = GURL(ConvertJavaStringToUTF8(env, java_web_manifest_url));\n \n   base::android::AppendJavaStringArrayToStringVector(env, java_icon_urls,\n                                                      &info.icon_urls);\n \n  std::vector<std::string> icon_hashes;\n  base::android::AppendJavaStringArrayToStringVector(env, java_icon_hashes,\n                                                     &icon_hashes);\n\n  std::map<std::string, std::string> icon_url_to_murmur2_hash;\n  for (size_t i = 0; i < info.icon_urls.size(); ++i)\n    icon_url_to_murmur2_hash[info.icon_urls[i]] = icon_hashes[i];\n\n  gfx::JavaBitmap java_primary_icon_bitmap_lock(java_primary_icon_bitmap);\n  SkBitmap primary_icon =\n      gfx::CreateSkBitmapFromJavaBitmap(java_primary_icon_bitmap_lock);\n  primary_icon.setImmutable();\n\n  SkBitmap badge_icon;\n  if (!java_badge_icon_bitmap.is_null()) {\n    gfx::JavaBitmap java_badge_icon_bitmap_lock(java_badge_icon_bitmap);\n    gfx::CreateSkBitmapFromJavaBitmap(java_badge_icon_bitmap_lock);\n    badge_icon.setImmutable();\n  }\n\n  std::string webapk_package;\n  ConvertJavaStringToUTF8(env, java_webapk_package, &webapk_package);\n\n  WebApkUpdateReason update_reason =\n      static_cast<WebApkUpdateReason>(java_update_reason);\n\n  WebApkInstaller::StoreUpdateRequestToFile(\n      base::FilePath(update_request_path), info, primary_icon, badge_icon,\n      webapk_package, std::to_string(java_webapk_version),\n      icon_url_to_murmur2_hash, java_is_manifest_stale, update_reason,\n      base::BindOnce(&base::android::RunBooleanCallbackAndroid,\n                     ScopedJavaGlobalRef<jobject>(java_callback)));\n}\n", "target": 1, "idx": 185986}
{"func": "notify_setup(void)\n{\n\tif (pipe(notify_pipe) < 0) {\n\t\terror(\"pipe(notify_pipe) failed %s\", strerror(errno));\n\t} else if ((fcntl(notify_pipe[0], F_SETFD, FD_CLOEXEC) == -1) ||\n\t    (fcntl(notify_pipe[1], F_SETFD, FD_CLOEXEC) == -1)) {\n\t\terror(\"fcntl(notify_pipe, F_SETFD) failed %s\", strerror(errno));\n\t\tclose(notify_pipe[0]);\n\t\tclose(notify_pipe[1]);\n\t} else {\n\t\tset_nonblock(notify_pipe[0]);\n\t\tset_nonblock(notify_pipe[1]);\n\t\treturn;\n\t}\n\tnotify_pipe[0] = -1;\t/* read end */\n\tnotify_pipe[1] = -1;\t/* write end */\n}\n", "target": 0, "idx": 72321}
{"func": "static int edge_remove_sysfs_attrs(struct usb_serial_port *port)\n{\n\tdevice_remove_file(&port->dev, &dev_attr_uart_mode);\n\treturn 0;\n}\n", "target": 0, "idx": 33337}
{"func": " static inline void process_get_command(conn *c, token_t *tokens, size_t ntokens, bool return_cas) {\n     char *key;\n    size_t nkey;\n    int i = 0;\n    item *it;\n    token_t *key_token = &tokens[KEY_TOKEN];\n    char *suffix;\n    assert(c != NULL);\n\n    do {\n        while(key_token->length != 0) {\n\n            key = key_token->value;\n            nkey = key_token->length;\n\n            if(nkey > KEY_MAX_LENGTH) {\n                out_string(c, \"CLIENT_ERROR bad command line format\");\n                while (i-- > 0) {\n                    item_remove(*(c->ilist + i));\n                }\n                 return;\n             }\n \n            it = item_get(key, nkey, c, DO_UPDATE);\n             if (settings.detail_enabled) {\n                 stats_prefix_record_get(key, nkey, NULL != it);\n             }\n            if (it) {\n                if (i >= c->isize) {\n                    item **new_list = realloc(c->ilist, sizeof(item *) * c->isize * 2);\n                    if (new_list) {\n                        c->isize *= 2;\n                        c->ilist = new_list;\n                    } else {\n                        STATS_LOCK();\n                        stats.malloc_fails++;\n                        STATS_UNLOCK();\n                        item_remove(it);\n                        break;\n                    }\n                }\n\n                /*\n                 * Construct the response. Each hit adds three elements to the\n                 * outgoing data list:\n                 *   \"VALUE \"\n                 *   key\n                 *   \" \" + flags + \" \" + data length + \"\\r\\n\" + data (with \\r\\n)\n                 */\n\n                if (return_cas || !settings.inline_ascii_response)\n                {\n                  MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey,\n                                        it->nbytes, ITEM_get_cas(it));\n                  /* Goofy mid-flight realloc. */\n                  if (i >= c->suffixsize) {\n                    char **new_suffix_list = realloc(c->suffixlist,\n                                           sizeof(char *) * c->suffixsize * 2);\n                    if (new_suffix_list) {\n                        c->suffixsize *= 2;\n                        c->suffixlist  = new_suffix_list;\n                    } else {\n                        STATS_LOCK();\n                        stats.malloc_fails++;\n                        STATS_UNLOCK();\n                        item_remove(it);\n                        break;\n                    }\n                  }\n\n                  suffix = do_cache_alloc(c->thread->suffix_cache);\n                  if (suffix == NULL) {\n                      STATS_LOCK();\n                      stats.malloc_fails++;\n                      STATS_UNLOCK();\n                      out_of_memory(c, \"SERVER_ERROR out of memory making CAS suffix\");\n                      item_remove(it);\n                      while (i-- > 0) {\n                          item_remove(*(c->ilist + i));\n                      }\n                      return;\n                  }\n                  *(c->suffixlist + i) = suffix;\n                  int suffix_len = make_ascii_get_suffix(suffix, it, return_cas);\n                  if (add_iov(c, \"VALUE \", 6) != 0 ||\n                      add_iov(c, ITEM_key(it), it->nkey) != 0 ||\n                      (settings.inline_ascii_response && add_iov(c, ITEM_suffix(it), it->nsuffix - 2) != 0) ||\n                      add_iov(c, suffix, suffix_len) != 0)\n                      {\n                          item_remove(it);\n                          break;\n                      }\n                  if ((it->it_flags & ITEM_CHUNKED) == 0) {\n                      add_iov(c, ITEM_data(it), it->nbytes);\n                  } else if (add_chunked_item_iovs(c, it, it->nbytes) != 0) {\n                      item_remove(it);\n                      break;\n                  }\n                }\n                else\n                {\n                  MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey,\n                                        it->nbytes, ITEM_get_cas(it));\n                  if (add_iov(c, \"VALUE \", 6) != 0 ||\n                      add_iov(c, ITEM_key(it), it->nkey) != 0)\n                      {\n                          item_remove(it);\n                          break;\n                      }\n                  if ((it->it_flags & ITEM_CHUNKED) == 0)\n                      {\n                          if (add_iov(c, ITEM_suffix(it), it->nsuffix + it->nbytes) != 0)\n                          {\n                              item_remove(it);\n                              break;\n                          }\n                      } else if (add_iov(c, ITEM_suffix(it), it->nsuffix) != 0 ||\n                                 add_chunked_item_iovs(c, it, it->nbytes) != 0) {\n                          item_remove(it);\n                          break;\n                      }\n                }\n\n\n                if (settings.verbose > 1) {\n                    int ii;\n                    fprintf(stderr, \">%d sending key \", c->sfd);\n                    for (ii = 0; ii < it->nkey; ++ii) {\n                        fprintf(stderr, \"%c\", key[ii]);\n                    }\n                    fprintf(stderr, \"\\n\");\n                }\n\n                /* item_get() has incremented it->refcount for us */\n                pthread_mutex_lock(&c->thread->stats.mutex);\n                c->thread->stats.slab_stats[ITEM_clsid(it)].get_hits++;\n                c->thread->stats.get_cmds++;\n                pthread_mutex_unlock(&c->thread->stats.mutex);\n                *(c->ilist + i) = it;\n                i++;\n\n            } else {\n                pthread_mutex_lock(&c->thread->stats.mutex);\n                c->thread->stats.get_misses++;\n                c->thread->stats.get_cmds++;\n                pthread_mutex_unlock(&c->thread->stats.mutex);\n                MEMCACHED_COMMAND_GET(c->sfd, key, nkey, -1, 0);\n            }\n\n            key_token++;\n        }\n\n        /*\n         * If the command string hasn't been fully processed, get the next set\n         * of tokens.\n         */\n        if(key_token->value != NULL) {\n            ntokens = tokenize_command(key_token->value, tokens, MAX_TOKENS);\n            key_token = tokens;\n        }\n\n    } while(key_token->value != NULL);\n\n    c->icurr = c->ilist;\n    c->ileft = i;\n    if (return_cas || !settings.inline_ascii_response) {\n        c->suffixcurr = c->suffixlist;\n        c->suffixleft = i;\n    }\n\n    if (settings.verbose > 1)\n        fprintf(stderr, \">%d END\\n\", c->sfd);\n\n    /*\n        If the loop was terminated because of out-of-memory, it is not\n        reliable to add END\\r\\n to the buffer, because it might not end\n        in \\r\\n. So we send SERVER_ERROR instead.\n    */\n    if (key_token->value != NULL || add_iov(c, \"END\\r\\n\", 5) != 0\n        || (IS_UDP(c->transport) && build_udp_headers(c) != 0)) {\n        out_of_memory(c, \"SERVER_ERROR out of memory writing get response\");\n    }\n    else {\n        conn_set_state(c, conn_mwrite);\n        c->msgcurr = 0;\n    }\n}\n", "target": 1, "idx": 182115}
{"func": "void BrowserLauncherItemController::OnRemoved() {\n}\n", "target": 0, "idx": 126147}
{"func": "  std::unique_ptr<net::URLRequest> CreateAndExecuteRequest(const GURL& url) {\n    std::unique_ptr<net::URLRequest> request(context_.CreateRequest(\n        url, net::IDLE, &delegate_, TRAFFIC_ANNOTATION_FOR_TESTS));\n    request->Start();\n    drp_test_context_->RunUntilIdle();\n    return request;\n  }\n", "target": 0, "idx": 157544}
{"func": "unsigned long long Chapters::Atom::GetUID() const\n{\n    return m_uid;\n }\n", "target": 1, "idx": 188398}
{"func": "void GDataDirectoryService::SerializeToString(\n    std::string* serialized_proto) const {\n  GDataRootDirectoryProto proto;\n  root_->ToProto(proto.mutable_gdata_directory());\n  proto.set_largest_changestamp(largest_changestamp_);\n  proto.set_version(kProtoVersion);\n\n  const bool ok = proto.SerializeToString(serialized_proto);\n  DCHECK(ok);\n}\n", "target": 0, "idx": 125529}
{"func": "void RenderBlock::styleWillChange(StyleDifference diff, const RenderStyle& newStyle)\n{\n    RenderStyle* oldStyle = style();\n \n     setReplaced(newStyle.isDisplayInlineType());\n \n    if (oldStyle && parent() && diff == StyleDifferenceLayout && oldStyle->position() != newStyle.position()) {\n         if (newStyle.position() == StaticPosition)\n            removePositionedObjects(0, NewContainingBlock);\n        else if (oldStyle->position() == StaticPosition) {\n            RenderObject* cb = parent();\n            while (cb && (cb->style()->position() == StaticPosition || (cb->isInline() && !cb->isReplaced())) && !cb->isRenderView()) {\n                if (cb->style()->position() == RelativePosition && cb->isInline() && !cb->isReplaced()) {\n                    cb = cb->containingBlock();\n                    break;\n                }\n                cb = cb->parent();\n            }\n\n            if (cb->isRenderBlock())\n                toRenderBlock(cb)->removePositionedObjects(this, NewContainingBlock);\n        }\n    }\n\n    RenderBox::styleWillChange(diff, newStyle);\n}\n", "target": 1, "idx": 185159}
{"func": "void V8Window::namedPropertyGetterCustom(v8::Local<v8::Name> name, const v8::PropertyCallbackInfo<v8::Value>& info)\n{\n    if (!name->IsString())\n        return;\n\n    auto nameString = name.As<v8::String>();\n    LocalDOMWindow* window = toLocalDOMWindow(V8Window::toImpl(info.Holder()));\n    if (!window)\n        return;\n\n    LocalFrame* frame = window->frame();\n    if (!frame)\n        return;\n\n    AtomicString propName = toCoreAtomicString(nameString);\n    Frame* child = frame->tree().scopedChild(propName);\n    if (child) {\n        v8SetReturnValueFast(info, child->domWindow(), window);\n        return;\n    }\n\n     if (!info.Holder()->GetRealNamedProperty(nameString).IsEmpty())\n         return;\n \n     Document* doc = frame->document();\n \n    if (doc && doc->isHTMLDocument()) {\n        if (toHTMLDocument(doc)->hasNamedItem(propName) || doc->hasElementWithId(propName)) {\n            RefPtrWillBeRawPtr<HTMLCollection> items = doc->windowNamedItems(propName);\n            if (!items->isEmpty()) {\n                if (items->hasExactlyOneItem()) {\n                    v8SetReturnValueFast(info, items->item(0), window);\n                    return;\n                }\n                v8SetReturnValueFast(info, items.release(), window);\n                return;\n            }\n        }\n    }\n}\n", "target": 1, "idx": 185933}
{"func": "void CrosLibrary::TestApi::SetBrightnessLibrary(\n    BrightnessLibrary* library, bool own) {\n  library_->brightness_lib_.SetImpl(library, own);\n}\n", "target": 1, "idx": 184103}
{"func": "void RenderViewImpl::OnSelectPopupMenuItems(\n    bool canceled,\n    const std::vector<int>& selected_indices) {\n  if (!external_popup_menu_.get())\n    return;\n\n  external_popup_menu_->DidSelectItems(canceled, selected_indices);\n  external_popup_menu_.reset();\n}\n", "target": 0, "idx": 108966}
{"func": "void WebContentsImpl::AddDestructionObserver(WebContentsImpl* web_contents) {\n  if (!ContainsKey(destruction_observers_, web_contents)) {\n    destruction_observers_[web_contents] =\n        std::make_unique<DestructionObserver>(this, web_contents);\n  }\n}\n", "target": 0, "idx": 157714}
{"func": "static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid)\n\n {\n     const char *perm = \"add\";\n \n    if (uid >= AID_APP) {\n         return 0; /* Don't allow apps to register services */\n     }\n \n return check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0;\n}\n", "target": 1, "idx": 187425}
{"func": "list_item_verbose(struct cpio *cpio, struct archive_entry *entry)\n{\n\tchar\t\t\t size[32];\n\tchar\t\t\t date[32];\n\tchar\t\t\t uids[16], gids[16];\n\tconst char \t\t*uname, *gname;\n\tFILE\t\t\t*out = stdout;\n\tconst char\t\t*fmt;\n\ttime_t\t\t\t mtime;\n\tstatic time_t\t\t now;\n\n\tif (!now)\n\t\ttime(&now);\n\n\tif (cpio->option_numeric_uid_gid) {\n\t\t/* Format numeric uid/gid for display. */\n\t\tstrcpy(uids, cpio_i64toa(archive_entry_uid(entry)));\n\t\tuname = uids;\n\t\tstrcpy(gids, cpio_i64toa(archive_entry_gid(entry)));\n\t\tgname = gids;\n\t} else {\n\t\t/* Use uname if it's present, else lookup name from uid. */\n\t\tuname = archive_entry_uname(entry);\n\t\tif (uname == NULL)\n\t\t\tuname = lookup_uname(cpio, (uid_t)archive_entry_uid(entry));\n\t\t/* Use gname if it's present, else lookup name from gid. */\n\t\tgname = archive_entry_gname(entry);\n\t\tif (gname == NULL)\n\t\t\tgname = lookup_gname(cpio, (uid_t)archive_entry_gid(entry));\n\t}\n\n\t/* Print device number or file size. */\n\tif (archive_entry_filetype(entry) == AE_IFCHR\n\t    || archive_entry_filetype(entry) == AE_IFBLK) {\n\t\tsnprintf(size, sizeof(size), \"%lu,%lu\",\n\t\t    (unsigned long)archive_entry_rdevmajor(entry),\n\t\t    (unsigned long)archive_entry_rdevminor(entry));\n\t} else {\n\t\tstrcpy(size, cpio_i64toa(archive_entry_size(entry)));\n\t}\n\n\t/* Format the time using 'ls -l' conventions. */\n\tmtime = archive_entry_mtime(entry);\n#if defined(_WIN32) && !defined(__CYGWIN__)\n\t/* Windows' strftime function does not support %e format. */\n\tif (mtime - now > 365*86400/2\n\t\t|| mtime - now < -365*86400/2)\n\t\tfmt = cpio->day_first ? \"%d %b  %Y\" : \"%b %d  %Y\";\n\telse\n\t\tfmt = cpio->day_first ? \"%d %b %H:%M\" : \"%b %d %H:%M\";\n#else\n\tif (mtime - now > 365*86400/2\n\t\t|| mtime - now < -365*86400/2)\n\t\tfmt = cpio->day_first ? \"%e %b  %Y\" : \"%b %e  %Y\";\n\telse\n\t\tfmt = cpio->day_first ? \"%e %b %H:%M\" : \"%b %e %H:%M\";\n#endif\n\tstrftime(date, sizeof(date), fmt, localtime(&mtime));\n\n\tfprintf(out, \"%s%3d %-8s %-8s %8s %12s %s\",\n\t    archive_entry_strmode(entry),\n\t    archive_entry_nlink(entry),\n\t    uname, gname, size, date,\n\t    archive_entry_pathname(entry));\n\n\t/* Extra information for links. */\n\tif (archive_entry_hardlink(entry)) /* Hard link */\n\t\tfprintf(out, \" link to %s\", archive_entry_hardlink(entry));\n\telse if (archive_entry_symlink(entry)) /* Symbolic link */\n\t\tfprintf(out, \" -> %s\", archive_entry_symlink(entry));\n\tfprintf(out, \"\\n\");\n}\n", "target": 0, "idx": 43870}
{"func": "int import_iovec(int type, const struct iovec __user * uvector,\n\t\t unsigned nr_segs, unsigned fast_segs,\n\t\t struct iovec **iov, struct iov_iter *i)\n{\n\tssize_t n;\n\tstruct iovec *p;\n\tn = rw_copy_check_uvector(type, uvector, nr_segs, fast_segs,\n\t\t\t\t  *iov, &p);\n\tif (n < 0) {\n\t\tif (p != *iov)\n\t\t\tkfree(p);\n\t\t*iov = NULL;\n\t\treturn n;\n\t}\n\tiov_iter_init(i, type, p, nr_segs, n);\n\t*iov = p == *iov ? NULL : p;\n\treturn 0;\n}\n", "target": 0, "idx": 68732}
{"func": "native_handle* Parcel::readNativeHandle() const\n{\n int numFds, numInts;\n status_t err;\n    err = readInt32(&numFds);\n if (err != NO_ERROR) return 0;\n    err = readInt32(&numInts);\n if (err != NO_ERROR) return 0;\n\n    native_handle* h = native_handle_create(numFds, numInts);\n if (!h) {\n return 0;\n }\n\n \n     for (int i=0 ; err==NO_ERROR && i<numFds ; i++) {\n         h->data[i] = dup(readFileDescriptor());\n        if (h->data[i] < 0) err = BAD_VALUE;\n     }\n     err = read(h->data + numFds, sizeof(int)*numInts);\n     if (err != NO_ERROR) {\n        native_handle_close(h);\n        native_handle_delete(h);\n        h = 0;\n }\n return h;\n}\n", "target": 1, "idx": 187766}
{"func": "static int kill_something_info(int sig, struct siginfo *info, pid_t pid)\n{\n\tint ret;\n\n\tif (pid > 0) {\n\t\trcu_read_lock();\n\t\tret = kill_pid_info(sig, info, find_vpid(pid));\n\t\trcu_read_unlock();\n \t\treturn ret;\n \t}\n \n \tread_lock(&tasklist_lock);\n \tif (pid != -1) {\n \t\tret = __kill_pgrp_info(sig, info,\n\t\t\t\tpid ? find_vpid(-pid) : task_pgrp(current));\n\t} else {\n\t\tint retval = 0, count = 0;\n\t\tstruct task_struct * p;\n\n\t\tfor_each_process(p) {\n\t\t\tif (task_pid_vnr(p) > 1 &&\n\t\t\t\t\t!same_thread_group(p, current)) {\n\t\t\t\tint err = group_send_sig_info(sig, info, p);\n\t\t\t\t++count;\n\t\t\t\tif (err != -EPERM)\n\t\t\t\t\tretval = err;\n\t\t\t}\n\t\t}\n\t\tret = count ? retval : -ESRCH;\n\t}\n\tread_unlock(&tasklist_lock);\n\n\treturn ret;\n}\n", "target": 1, "idx": 182429}
{"func": "void OfflinePageModelTaskified::OnTaskQueueIsIdle() {}\n", "target": 0, "idx": 169021}
{"func": "int x86_decode_insn(struct x86_emulate_ctxt *ctxt, void *insn, int insn_len)\n{\n\tint rc = X86EMUL_CONTINUE;\n\tint mode = ctxt->mode;\n\tint def_op_bytes, def_ad_bytes, goffset, simd_prefix;\n\tbool op_prefix = false;\n\tbool has_seg_override = false;\n\tstruct opcode opcode;\n\n\tctxt->memop.type = OP_NONE;\n\tctxt->memopp = NULL;\n\tctxt->_eip = ctxt->eip;\n\tctxt->fetch.ptr = ctxt->fetch.data;\n\tctxt->fetch.end = ctxt->fetch.data + insn_len;\n\tctxt->opcode_len = 1;\n\tif (insn_len > 0)\n\t\tmemcpy(ctxt->fetch.data, insn, insn_len);\n\telse {\n\t\trc = __do_insn_fetch_bytes(ctxt, 1);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\treturn rc;\n\t}\n\n\tswitch (mode) {\n\tcase X86EMUL_MODE_REAL:\n\tcase X86EMUL_MODE_VM86:\n\tcase X86EMUL_MODE_PROT16:\n\t\tdef_op_bytes = def_ad_bytes = 2;\n\t\tbreak;\n\tcase X86EMUL_MODE_PROT32:\n\t\tdef_op_bytes = def_ad_bytes = 4;\n\t\tbreak;\n#ifdef CONFIG_X86_64\n\tcase X86EMUL_MODE_PROT64:\n\t\tdef_op_bytes = 4;\n\t\tdef_ad_bytes = 8;\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn EMULATION_FAILED;\n\t}\n\n\tctxt->op_bytes = def_op_bytes;\n\tctxt->ad_bytes = def_ad_bytes;\n\n\t/* Legacy prefixes. */\n\tfor (;;) {\n\t\tswitch (ctxt->b = insn_fetch(u8, ctxt)) {\n\t\tcase 0x66:\t/* operand-size override */\n\t\t\top_prefix = true;\n\t\t\t/* switch between 2/4 bytes */\n\t\t\tctxt->op_bytes = def_op_bytes ^ 6;\n\t\t\tbreak;\n\t\tcase 0x67:\t/* address-size override */\n\t\t\tif (mode == X86EMUL_MODE_PROT64)\n\t\t\t\t/* switch between 4/8 bytes */\n\t\t\t\tctxt->ad_bytes = def_ad_bytes ^ 12;\n\t\t\telse\n\t\t\t\t/* switch between 2/4 bytes */\n\t\t\t\tctxt->ad_bytes = def_ad_bytes ^ 6;\n\t\t\tbreak;\n\t\tcase 0x26:\t/* ES override */\n\t\tcase 0x2e:\t/* CS override */\n\t\tcase 0x36:\t/* SS override */\n\t\tcase 0x3e:\t/* DS override */\n\t\t\thas_seg_override = true;\n\t\t\tctxt->seg_override = (ctxt->b >> 3) & 3;\n\t\t\tbreak;\n\t\tcase 0x64:\t/* FS override */\n\t\tcase 0x65:\t/* GS override */\n\t\t\thas_seg_override = true;\n\t\t\tctxt->seg_override = ctxt->b & 7;\n\t\t\tbreak;\n\t\tcase 0x40 ... 0x4f: /* REX */\n\t\t\tif (mode != X86EMUL_MODE_PROT64)\n\t\t\t\tgoto done_prefixes;\n\t\t\tctxt->rex_prefix = ctxt->b;\n\t\t\tcontinue;\n\t\tcase 0xf0:\t/* LOCK */\n\t\t\tctxt->lock_prefix = 1;\n\t\t\tbreak;\n\t\tcase 0xf2:\t/* REPNE/REPNZ */\n\t\tcase 0xf3:\t/* REP/REPE/REPZ */\n\t\t\tctxt->rep_prefix = ctxt->b;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto done_prefixes;\n\t\t}\n\n\t\t/* Any legacy prefix after a REX prefix nullifies its effect. */\n\n\t\tctxt->rex_prefix = 0;\n\t}\n\ndone_prefixes:\n\n\t/* REX prefix. */\n\tif (ctxt->rex_prefix & 8)\n\t\tctxt->op_bytes = 8;\t/* REX.W */\n\n\t/* Opcode byte(s). */\n\topcode = opcode_table[ctxt->b];\n\t/* Two-byte opcode? */\n\tif (ctxt->b == 0x0f) {\n\t\tctxt->opcode_len = 2;\n\t\tctxt->b = insn_fetch(u8, ctxt);\n\t\topcode = twobyte_table[ctxt->b];\n\n\t\t/* 0F_38 opcode map */\n\t\tif (ctxt->b == 0x38) {\n\t\t\tctxt->opcode_len = 3;\n\t\t\tctxt->b = insn_fetch(u8, ctxt);\n\t\t\topcode = opcode_map_0f_38[ctxt->b];\n\t\t}\n\t}\n\tctxt->d = opcode.flags;\n\n\tif (ctxt->d & ModRM)\n\t\tctxt->modrm = insn_fetch(u8, ctxt);\n\n\t/* vex-prefix instructions are not implemented */\n\tif (ctxt->opcode_len == 1 && (ctxt->b == 0xc5 || ctxt->b == 0xc4) &&\n\t    (mode == X86EMUL_MODE_PROT64 ||\n\t    (mode >= X86EMUL_MODE_PROT16 && (ctxt->modrm & 0x80)))) {\n\t\tctxt->d = NotImpl;\n\t}\n\n\twhile (ctxt->d & GroupMask) {\n\t\tswitch (ctxt->d & GroupMask) {\n\t\tcase Group:\n\t\t\tgoffset = (ctxt->modrm >> 3) & 7;\n\t\t\topcode = opcode.u.group[goffset];\n\t\t\tbreak;\n\t\tcase GroupDual:\n\t\t\tgoffset = (ctxt->modrm >> 3) & 7;\n\t\t\tif ((ctxt->modrm >> 6) == 3)\n\t\t\t\topcode = opcode.u.gdual->mod3[goffset];\n\t\t\telse\n\t\t\t\topcode = opcode.u.gdual->mod012[goffset];\n\t\t\tbreak;\n\t\tcase RMExt:\n\t\t\tgoffset = ctxt->modrm & 7;\n\t\t\topcode = opcode.u.group[goffset];\n\t\t\tbreak;\n\t\tcase Prefix:\n\t\t\tif (ctxt->rep_prefix && op_prefix)\n\t\t\t\treturn EMULATION_FAILED;\n\t\t\tsimd_prefix = op_prefix ? 0x66 : ctxt->rep_prefix;\n\t\t\tswitch (simd_prefix) {\n\t\t\tcase 0x00: opcode = opcode.u.gprefix->pfx_no; break;\n\t\t\tcase 0x66: opcode = opcode.u.gprefix->pfx_66; break;\n\t\t\tcase 0xf2: opcode = opcode.u.gprefix->pfx_f2; break;\n\t\t\tcase 0xf3: opcode = opcode.u.gprefix->pfx_f3; break;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Escape:\n\t\t\tif (ctxt->modrm > 0xbf)\n\t\t\t\topcode = opcode.u.esc->high[ctxt->modrm - 0xc0];\n\t\t\telse\n\t\t\t\topcode = opcode.u.esc->op[(ctxt->modrm >> 3) & 7];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn EMULATION_FAILED;\n\t\t}\n\n\t\tctxt->d &= ~(u64)GroupMask;\n\t\tctxt->d |= opcode.flags;\n\t}\n\n\t/* Unrecognised? */\n\tif (ctxt->d == 0)\n\t\treturn EMULATION_FAILED;\n\n\tctxt->execute = opcode.u.execute;\n\n\tif (unlikely(ctxt->ud) && likely(!(ctxt->d & EmulateOnUD)))\n\t\treturn EMULATION_FAILED;\n\n\tif (unlikely(ctxt->d &\n\t\t     (NotImpl|Stack|Op3264|Sse|Mmx|Intercept|CheckPerm))) {\n\t\t/*\n\t\t * These are copied unconditionally here, and checked unconditionally\n\t\t * in x86_emulate_insn.\n\t\t */\n\t\tctxt->check_perm = opcode.check_perm;\n\t\tctxt->intercept = opcode.intercept;\n\n\t\tif (ctxt->d & NotImpl)\n\t\t\treturn EMULATION_FAILED;\n\n\t\tif (mode == X86EMUL_MODE_PROT64 && (ctxt->d & Stack))\n\t\t\tctxt->op_bytes = 8;\n\n\t\tif (ctxt->d & Op3264) {\n\t\t\tif (mode == X86EMUL_MODE_PROT64)\n\t\t\t\tctxt->op_bytes = 8;\n\t\t\telse\n\t\t\t\tctxt->op_bytes = 4;\n\t\t}\n\n\t\tif (ctxt->d & Sse)\n\t\t\tctxt->op_bytes = 16;\n\t\telse if (ctxt->d & Mmx)\n\t\t\tctxt->op_bytes = 8;\n\t}\n\n\t/* ModRM and SIB bytes. */\n\tif (ctxt->d & ModRM) {\n\t\trc = decode_modrm(ctxt, &ctxt->memop);\n\t\tif (!has_seg_override) {\n\t\t\thas_seg_override = true;\n\t\t\tctxt->seg_override = ctxt->modrm_seg;\n\t\t}\n\t} else if (ctxt->d & MemAbs)\n\t\trc = decode_abs(ctxt, &ctxt->memop);\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto done;\n\n\tif (!has_seg_override)\n\t\tctxt->seg_override = VCPU_SREG_DS;\n\n\tctxt->memop.addr.mem.seg = ctxt->seg_override;\n\n\t/*\n\t * Decode and fetch the source operand: register, memory\n\t * or immediate.\n\t */\n\trc = decode_operand(ctxt, &ctxt->src, (ctxt->d >> SrcShift) & OpMask);\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto done;\n\n\t/*\n\t * Decode and fetch the second source operand: register, memory\n\t * or immediate.\n\t */\n\trc = decode_operand(ctxt, &ctxt->src2, (ctxt->d >> Src2Shift) & OpMask);\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto done;\n\n \t/* Decode and fetch the destination operand: register or memory. */\n \trc = decode_operand(ctxt, &ctxt->dst, (ctxt->d >> DstShift) & OpMask);\n \ndone:\n \tif (ctxt->rip_relative)\n \t\tctxt->memopp->addr.mem.ea += ctxt->_eip;\n \n \treturn (rc != X86EMUL_CONTINUE) ? EMULATION_FAILED : EMULATION_OK;\n }\n", "target": 1, "idx": 179415}
{"func": "void PDFiumEngine::GetTextRunInfo(int page_index,\n                                  int start_char_index,\n                                  uint32_t* out_len,\n                                  double* out_font_size,\n                                  pp::FloatRect* out_bounds) {\n  DCHECK(PageIndexInBounds(page_index));\n  return pages_[page_index]->GetTextRunInfo(start_char_index, out_len,\n                                            out_font_size, out_bounds);\n}\n", "target": 0, "idx": 158957}
{"func": "static void irda_disconnect_indication(void *instance, void *sap,\n\t\t\t\t       LM_REASON reason, struct sk_buff *skb)\n{\n\tstruct irda_sock *self;\n\tstruct sock *sk;\n\n\tself = instance;\n\n\tpr_debug(\"%s(%p)\\n\", __func__, self);\n\n\t/* Don't care about it, but let's not leak it */\n\tif(skb)\n\t\tdev_kfree_skb(skb);\n\n\tsk = instance;\n\tif (sk == NULL) {\n\t\tpr_debug(\"%s(%p) : BUG : sk is NULL\\n\",\n\t\t\t __func__, self);\n\t\treturn;\n\t}\n\n\t/* Prevent race conditions with irda_release() and irda_shutdown() */\n\tbh_lock_sock(sk);\n\tif (!sock_flag(sk, SOCK_DEAD) && sk->sk_state != TCP_CLOSE) {\n\t\tsk->sk_state     = TCP_CLOSE;\n\t\tsk->sk_shutdown |= SEND_SHUTDOWN;\n\n\t\tsk->sk_state_change(sk);\n\n\t\t/* Close our TSAP.\n\t\t * If we leave it open, IrLMP put it back into the list of\n\t\t * unconnected LSAPs. The problem is that any incoming request\n\t\t * can then be matched to this socket (and it will be, because\n\t\t * it is at the head of the list). This would prevent any\n\t\t * listening socket waiting on the same TSAP to get those\n\t\t * requests. Some apps forget to close sockets, or hang to it\n\t\t * a bit too long, so we may stay in this dead state long\n\t\t * enough to be noticed...\n\t\t * Note : all socket function do check sk->sk_state, so we are\n\t\t * safe...\n\t\t * Jean II\n\t\t */\n\t\tif (self->tsap) {\n\t\t\tirttp_close_tsap(self->tsap);\n\t\t\tself->tsap = NULL;\n\t\t}\n\t}\n\tbh_unlock_sock(sk);\n\n\t/* Note : once we are there, there is not much you want to do\n\t * with the socket anymore, apart from closing it.\n\t * For example, bind() and connect() won't reset sk->sk_err,\n\t * sk->sk_shutdown and sk->sk_flags to valid values...\n\t * Jean II\n\t */\n}\n", "target": 0, "idx": 41580}
{"func": "static void readonlyWindowAttributeAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)\n{\n    TRACE_EVENT_SET_SAMPLING_STATE(\"Blink\", \"DOMGetter\");\n    TestObjectPythonV8Internal::readonlyWindowAttributeAttributeGetter(info);\n    TRACE_EVENT_SET_SAMPLING_STATE(\"V8\", \"V8Execution\");\n}\n", "target": 0, "idx": 131649}
{"func": "  void VerifyPrintPreviewInvalidPrinterSettings(bool settings_invalid) {\n    bool print_preview_invalid_printer_settings =\n        (render_thread_->sink().GetUniqueMessageMatching(\n            PrintHostMsg_PrintPreviewInvalidPrinterSettings::ID) != NULL);\n    EXPECT_EQ(settings_invalid, print_preview_invalid_printer_settings);\n  }\n", "target": 0, "idx": 112854}
{"func": "void QQuickWebViewPrivate::setNeedsDisplay()\n{\n    Q_Q(QQuickWebView);\n    if (renderToOffscreenBuffer()) {\n        QImage dummyImage(1, 1, QImage::Format_ARGB32);\n        QPainter painter(&dummyImage);\n        q->page()->d->paint(&painter);\n        return;\n    }\n\n    q->page()->update();\n}\n", "target": 0, "idx": 107071}
{"func": "cleanup_bmc_device(struct kref *ref)\n{\n\tstruct bmc_device *bmc = container_of(ref, struct bmc_device, usecount);\n\n\t/*\n\t * Remove the platform device in a work queue to avoid issues\n\t * with removing the device attributes while reading a device\n\t * attribute.\n\t */\n\tschedule_work(&bmc->remove_work);\n}\n", "target": 0, "idx": 91218}
{"func": "void IOThread::EnableSpdy(const std::string& mode) {\n  static const char kOff[] = \"off\";\n  static const char kSSL[] = \"ssl\";\n  static const char kDisableSSL[] = \"no-ssl\";\n  static const char kDisablePing[] = \"no-ping\";\n  static const char kExclude[] = \"exclude\";  // Hosts to exclude\n  static const char kDisableCompression[] = \"no-compress\";\n  static const char kDisableAltProtocols[] = \"no-alt-protocols\";\n  static const char kForceAltProtocols[] = \"force-alt-protocols\";\n  static const char kSingleDomain[] = \"single-domain\";\n\n  static const char kInitialMaxConcurrentStreams[] = \"init-max-streams\";\n\n  std::vector<std::string> spdy_options;\n  base::SplitString(mode, ',', &spdy_options);\n\n  for (std::vector<std::string>::iterator it = spdy_options.begin();\n       it != spdy_options.end(); ++it) {\n    const std::string& element = *it;\n    std::vector<std::string> name_value;\n    base::SplitString(element, '=', &name_value);\n    const std::string& option =\n        name_value.size() > 0 ? name_value[0] : std::string();\n    const std::string value =\n        name_value.size() > 1 ? name_value[1] : std::string();\n\n    if (option == kOff) {\n      net::HttpStreamFactory::set_spdy_enabled(false);\n    } else if (option == kDisableSSL) {\n      globals_->spdy_default_protocol.set(net::kProtoSPDY3);\n      net::HttpStreamFactory::set_force_spdy_over_ssl(false);\n      net::HttpStreamFactory::set_force_spdy_always(true);\n    } else if (option == kSSL) {\n      globals_->spdy_default_protocol.set(net::kProtoSPDY3);\n      net::HttpStreamFactory::set_force_spdy_over_ssl(true);\n      net::HttpStreamFactory::set_force_spdy_always(true);\n    } else if (option == kDisablePing) {\n      globals_->enable_spdy_ping_based_connection_checking.set(false);\n    } else if (option == kExclude) {\n      net::HttpStreamFactory::add_forced_spdy_exclusion(value);\n    } else if (option == kDisableCompression) {\n      globals_->enable_spdy_compression.set(false);\n    } else if (option == kDisableAltProtocols) {\n      net::HttpStreamFactory::set_use_alternate_protocols(false);\n    } else if (option == kForceAltProtocols) {\n      net::PortAlternateProtocolPair pair;\n      pair.port = 443;\n      pair.protocol = net::NPN_SPDY_3;\n      net::HttpServerPropertiesImpl::ForceAlternateProtocol(pair);\n    } else if (option == kSingleDomain) {\n      DVLOG(1) << \"FORCING SINGLE DOMAIN\";\n      globals_->force_spdy_single_domain.set(true);\n    } else if (option == kInitialMaxConcurrentStreams) {\n      int streams;\n      if (base::StringToInt(value, &streams))\n        globals_->initial_max_spdy_concurrent_streams.set(streams);\n    } else if (option.empty() && it == spdy_options.begin()) {\n      continue;\n    } else {\n      LOG(DFATAL) << \"Unrecognized spdy option: \" << option;\n    }\n  }\n}\n", "target": 0, "idx": 121854}
{"func": " void OffscreenCanvasFrameReceiverImpl::SubmitCompositorFrame(\n     const cc::SurfaceId& surface_id,\n     cc::CompositorFrame frame) {\n    cc::Surface* surface = GetSurfaceManager()->GetSurfaceForId(surface_id);\n    if (surface) {\n        surface->QueueFrame(std::move(frame), base::Closure());\n     }\n }\n", "target": 1, "idx": 185907}
{"func": "PassRefPtr<Node> Element::cloneNode(bool deep)\n{\n    return deep ? cloneElementWithChildren() : cloneElementWithoutChildren();\n}\n", "target": 0, "idx": 120486}
{"func": "   void FireInvalidateAll() {\n    invalidation::AckHandle ack_handle(\"fakedata\");\n    EXPECT_CALL(mock_invalidation_client_, Acknowledge(ack_handle));\n    client_.InvalidateAll(&mock_invalidation_client_, ack_handle);\n   }\n", "target": 1, "idx": 184521}
{"func": "GLboolean GLES2Implementation::UnmapBuffer(GLenum target) {\n  GPU_CLIENT_SINGLE_THREAD_CHECK();\n  GPU_CLIENT_LOG(\"[\" << GetLogPrefix() << \"] glUnmapBuffer(\"\n                     << GLES2Util::GetStringEnum(target) << \")\");\n  switch (target) {\n    case GL_ARRAY_BUFFER:\n    case GL_ATOMIC_COUNTER_BUFFER:\n    case GL_ELEMENT_ARRAY_BUFFER:\n    case GL_COPY_READ_BUFFER:\n    case GL_COPY_WRITE_BUFFER:\n    case GL_PIXEL_PACK_BUFFER:\n    case GL_PIXEL_UNPACK_BUFFER:\n    case GL_SHADER_STORAGE_BUFFER:\n    case GL_TRANSFORM_FEEDBACK_BUFFER:\n    case GL_UNIFORM_BUFFER:\n      break;\n    default:\n      SetGLError(GL_INVALID_ENUM, \"glUnmapBuffer\", \"invalid target\");\n      return GL_FALSE;\n  }\n  GLuint buffer = GetBoundBufferHelper(target);\n  if (buffer == 0) {\n    SetGLError(GL_INVALID_OPERATION, \"glUnmapBuffer\", \"no buffer bound\");\n    return GL_FALSE;\n  }\n  auto iter = mapped_buffer_range_map_.find(buffer);\n  if (iter == mapped_buffer_range_map_.end()) {\n    SetGLError(GL_INVALID_OPERATION, \"glUnmapBuffer\", \"buffer is unmapped\");\n    return GL_FALSE;\n  }\n\n  bool was_mapped_by_readback_tracker = false;\n  if (auto* buffer_object =\n          readback_buffer_shadow_tracker_->GetBuffer(buffer)) {\n    was_mapped_by_readback_tracker = buffer_object->UnmapReadbackShm();\n  }\n  if (!was_mapped_by_readback_tracker) {\n    helper_->UnmapBuffer(target);\n    InvalidateReadbackBufferShadowDataCHROMIUM(GetBoundBufferHelper(target));\n  }\n  RemoveMappedBufferRangeById(buffer);\n\n  GPU_CLIENT_LOG(\"  returned \" << GL_TRUE);\n  CheckGLError();\n  return GL_TRUE;\n}\n", "target": 0, "idx": 153841}
{"func": "void qeth_clear_thread_start_bit(struct qeth_card *card, unsigned long thread)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&card->thread_mask_lock, flags);\n\tcard->thread_start_mask &= ~thread;\n\tspin_unlock_irqrestore(&card->thread_mask_lock, flags);\n\twake_up(&card->wait_q);\n}\n", "target": 0, "idx": 28499}
{"func": "scan_file (GFile      *file,\n           SourceInfo *source_info,\n           CommonJob  *job,\n           GHashTable *scanned)\n{\n    GFileInfo *info;\n    GError *error;\n    GQueue *dirs;\n    GFile *dir;\n    char *primary;\n    char *secondary;\n    char *details;\n    int response;\n\n    dirs = g_queue_new ();\n\nretry:\n    error = NULL;\n    info = g_file_query_info (file,\n                              G_FILE_ATTRIBUTE_STANDARD_TYPE \",\"\n                              G_FILE_ATTRIBUTE_STANDARD_SIZE,\n                              G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                              job->cancellable,\n                              &error);\n\n    if (info)\n    {\n        g_autofree char *file_uri = NULL;\n\n        file_uri = g_file_get_uri (file);\n        if (!g_hash_table_contains (scanned, file_uri))\n        {\n            g_hash_table_add (scanned, g_strdup (file_uri));\n\n            count_file (info, job, source_info);\n\n            /* trashing operation doesn't recurse */\n            if (g_file_info_get_file_type (info) == G_FILE_TYPE_DIRECTORY &&\n                source_info->op != OP_KIND_TRASH)\n            {\n                g_queue_push_head (dirs, g_object_ref (file));\n            }\n        }\n        g_object_unref (info);\n    }\n    else if (job->skip_all_error)\n    {\n        g_error_free (error);\n        skip_file (job, file);\n    }\n    else if (IS_IO_ERROR (error, CANCELLED))\n    {\n        g_error_free (error);\n    }\n    else\n    {\n        primary = get_scan_primary (source_info->op);\n        details = NULL;\n\n        if (IS_IO_ERROR (error, PERMISSION_DENIED))\n        {\n            secondary = f (_(\"The file \u201c%B\u201d cannot be handled because you do not have \"\n                             \"permissions to read it.\"), file);\n        }\n        else\n        {\n            secondary = f (_(\"There was an error getting information about \u201c%B\u201d.\"), file);\n            details = error->message;\n        }\n        /* set show_all to TRUE here, as we don't know how many\n         * files we'll end up processing yet.\n         */\n        response = run_warning (job,\n                                primary,\n                                secondary,\n                                details,\n                                TRUE,\n                                CANCEL, SKIP_ALL, SKIP, RETRY,\n                                NULL);\n\n        g_error_free (error);\n\n        if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n        {\n            abort_job (job);\n        }\n        else if (response == 1 || response == 2)\n        {\n            if (response == 1)\n            {\n                job->skip_all_error = TRUE;\n            }\n            skip_file (job, file);\n        }\n        else if (response == 3)\n        {\n            goto retry;\n        }\n        else\n        {\n            g_assert_not_reached ();\n        }\n    }\n\n    while (!job_aborted (job) &&\n           (dir = g_queue_pop_head (dirs)) != NULL)\n    {\n        scan_dir (dir, source_info, job, dirs, scanned);\n        g_object_unref (dir);\n    }\n\n    /* Free all from queue if we exited early */\n    g_queue_foreach (dirs, (GFunc) g_object_unref, NULL);\n    g_queue_free (dirs);\n}\n", "target": 0, "idx": 61136}
{"func": "static inline void jmp_rel(struct x86_emulate_ctxt *ctxt, int rel)\n {\n\tassign_eip_near(ctxt, ctxt->_eip + rel);\n }\n", "target": 1, "idx": 183088}
{"func": "static int _6502_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len) {\n\tchar addrbuf[64];\n\tconst int buffsize = sizeof (addrbuf) - 1;\n\n\tmemset (op, '\\0', sizeof (RAnalOp));\n\top->size = snes_op_get_size (1, 1, &snes_op[data[0]]);\t//snes-arch is similiar to nes/6502\n\top->addr = addr;\n\top->type = R_ANAL_OP_TYPE_UNK;\n\top->id = data[0];\n\tr_strbuf_init (&op->esil);\n\tswitch (data[0]) {\n\tcase 0x02:\n\tcase 0x03:\n\tcase 0x04:\n\tcase 0x07:\n\tcase 0x0b:\n\tcase 0x0c:\n\tcase 0x0f:\n\tcase 0x12:\n\tcase 0x13:\n\tcase 0x14:\n\tcase 0x17:\n\tcase 0x1a:\n\tcase 0x1b:\n\tcase 0x1c:\n\tcase 0x1f:\n\tcase 0x22:\n\tcase 0x23:\n\tcase 0x27:\n\tcase 0x2b:\n\tcase 0x2f:\n\tcase 0x32:\n\tcase 0x33:\n\tcase 0x34:\n\tcase 0x37:\n\tcase 0x3a:\n\tcase 0x3b:\n\tcase 0x3c:\n\tcase 0x3f:\n\tcase 0x42:\n\tcase 0x43:\n\tcase 0x44:\n\tcase 0x47:\n\tcase 0x4b:\n\tcase 0x4f:\n\tcase 0x52:\n\tcase 0x53:\n\tcase 0x54:\n\tcase 0x57:\n\tcase 0x5a:\n\tcase 0x5b:\n\tcase 0x5c:\n\tcase 0x5f:\n\tcase 0x62:\n\tcase 0x63:\n\tcase 0x64:\n\tcase 0x67:\n\tcase 0x6b:\n\tcase 0x6f:\n\tcase 0x72:\n\tcase 0x73:\n\tcase 0x74:\n\tcase 0x77:\n\tcase 0x7a:\n\tcase 0x7b:\n\tcase 0x7c:\n\tcase 0x7f:\n\tcase 0x80:\n\tcase 0x82:\n\tcase 0x83:\n\tcase 0x87:\n\tcase 0x89:\n\tcase 0x8b:\n\tcase 0x8f:\n\tcase 0x92:\n\tcase 0x93:\n\tcase 0x97:\n\tcase 0x9b:\n\tcase 0x9c:\n\tcase 0x9e:\n\tcase 0x9f:\n\tcase 0xa3:\n\tcase 0xa7:\n\tcase 0xab:\n\tcase 0xaf:\n\tcase 0xb2:\n\tcase 0xb3:\n\tcase 0xb7:\n\tcase 0xbb:\n\tcase 0xbf:\n\tcase 0xc2:\n\tcase 0xc3:\n\tcase 0xc7:\n\tcase 0xcb:\n\tcase 0xcf:\n\tcase 0xd2:\n\tcase 0xd3:\n\tcase 0xd4:\n\tcase 0xd7:\n\tcase 0xda:\n\tcase 0xdb:\n\tcase 0xdc:\n\tcase 0xdf:\n\tcase 0xe2:\n\tcase 0xe3:\n\tcase 0xe7:\n\tcase 0xeb:\n\tcase 0xef:\n\tcase 0xf2:\n\tcase 0xf3:\n\tcase 0xf4:\n\tcase 0xf7:\n\tcase 0xfa:\n\tcase 0xfb:\n\tcase 0xfc:\n\tcase 0xff:\n\t\top->size = 1;\n\t\top->type = R_ANAL_OP_TYPE_ILL;\n\t\tbreak;\n\n\tcase 0x00: // brk\n\t\top->cycles = 7;\n\t\top->type = R_ANAL_OP_TYPE_SWI;\n\t\top->size = 1;\n\t\tr_strbuf_set (&op->esil, \",1,I,=,0,D,=,flags,0x10,|,0x100,sp,+,=[1],pc,1,+,0xfe,sp,+,=[2],3,sp,-=,0xfffe,[2],pc,=\");\n\t\tbreak;\n\n\tcase 0x78: // sei\n\tcase 0x58: // cli\n\tcase 0x38: // sec\n\tcase 0x18: // clc\n\tcase 0xf8: // sed\n\tcase 0xd8: // cld\n\tcase 0xb8: // clv\n\t\top->cycles = 2;\n\t\top->type = R_ANAL_OP_TYPE_NOP;\n\t\t_6502_anal_esil_flags (op, data[0]);\n\t\tbreak;\n\tcase 0x24: // bit $ff\n\tcase 0x2c: // bit $ffff\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\t_6502_anal_esil_get_addr_pattern3 (op, data, addrbuf, buffsize, 0);\n\t\tr_strbuf_setf (&op->esil, \"a,%s,[1],&,0x80,&,!,!,N,=,a,%s,[1],&,0x40,&,!,!,V,=,a,%s,[1],&,0xff,&,!,Z,=\",addrbuf, addrbuf, addrbuf);\n\t\tbreak;\n\tcase 0x69: // adc #$ff\n\tcase 0x65: // adc $ff\n\tcase 0x75: // adc $ff,x\n\tcase 0x6d: // adc $ffff\n\tcase 0x7d: // adc $ffff,x\n\tcase 0x79: // adc $ffff,y\n\tcase 0x61: // adc ($ff,x)\n\tcase 0x71: // adc ($ff,y)\n\t\top->type = R_ANAL_OP_TYPE_ADD;\n\t\t_6502_anal_esil_get_addr_pattern1 (op, data, addrbuf, buffsize);\n\t\tif (data[0] == 0x69) // immediate mode\n\t\t\tr_strbuf_setf (&op->esil, \"%s,a,+=,C,NUM,$c7,C,=,a,+=,$c7,C,|=\", addrbuf);\n\t\telse\tr_strbuf_setf (&op->esil, \"%s,[1],a,+=,C,NUM,$c7,C,=,a,+=,$c7,C,|=\", addrbuf);\n\t\t_6502_anal_update_flags (op, _6502_FLAGS_NZ);\n\t\tr_strbuf_append (&op->esil, \",a,a,=,$z,Z,=\");\n\t\tbreak;\n\tcase 0xe9: // sbc #$ff\n\tcase 0xe5: // sbc $ff\n\tcase 0xf5: // sbc $ff,x\n\tcase 0xed: // sbc $ffff\n\tcase 0xfd: // sbc $ffff,x\n\tcase 0xf9: // sbc $ffff,y\n\tcase 0xe1: // sbc ($ff,x)\n\tcase 0xf1: // sbc ($ff,y)\n\t\top->type = R_ANAL_OP_TYPE_SUB;\n\t\t_6502_anal_esil_get_addr_pattern1 (op, data, addrbuf, buffsize);\n\t\tif (data[0] == 0xe9) // immediate mode\n\t\t\tr_strbuf_setf (&op->esil, \"C,!,%s,+,a,-=\", addrbuf);\n\t\telse\tr_strbuf_setf (&op->esil, \"C,!,%s,[1],+,a,-=\", addrbuf);\n\t\t_6502_anal_update_flags (op, _6502_FLAGS_BNZ);\n\t\tr_strbuf_append (&op->esil, \",a,a,=,$z,Z,=,C,!=\");\n\t\tbreak;\n\tcase 0x09: // ora #$ff\n\tcase 0x05: // ora $ff\n\tcase 0x15: // ora $ff,x\n\tcase 0x0d: // ora $ffff\n\tcase 0x1d: // ora $ffff,x\n\tcase 0x19: // ora $ffff,y\n\tcase 0x01: // ora ($ff,x)\n\tcase 0x11: // ora ($ff),y\n\t\top->type = R_ANAL_OP_TYPE_OR;\n\t\t_6502_anal_esil_get_addr_pattern1 (op, data, addrbuf, buffsize);\n\t\tif (data[0] == 0x09) // immediate mode\n\t\t\tr_strbuf_setf (&op->esil, \"%s,a,|=\", addrbuf);\n\t\telse\tr_strbuf_setf (&op->esil, \"%s,[1],a,|=\", addrbuf);\n\t\t_6502_anal_update_flags (op, _6502_FLAGS_NZ);\n\t\tbreak;\n\tcase 0x29: // and #$ff\n\tcase 0x25: // and $ff\n\tcase 0x35: // and $ff,x\n\tcase 0x2d: // and $ffff\n\tcase 0x3d: // and $ffff,x\n\tcase 0x39: // and $ffff,y\n\tcase 0x21: // and ($ff,x)\n\tcase 0x31: // and ($ff),y\n\t\top->type = R_ANAL_OP_TYPE_AND;\n\t\t_6502_anal_esil_get_addr_pattern1 (op, data, addrbuf, buffsize);\n\t\tif (data[0] == 0x29) // immediate mode\n\t\t\tr_strbuf_setf (&op->esil, \"%s,a,&=\", addrbuf);\n\t\telse\tr_strbuf_setf (&op->esil, \"%s,[1],a,&=\", addrbuf);\n\t\t_6502_anal_update_flags (op, _6502_FLAGS_NZ);\n\t\tbreak;\n\tcase 0x49: // eor #$ff\n\tcase 0x45: // eor $ff\n\tcase 0x55: // eor $ff,x\n\tcase 0x4d: // eor $ffff\n\tcase 0x5d: // eor $ffff,x\n\tcase 0x59: // eor $ffff,y\n\tcase 0x41: // eor ($ff,x)\n\tcase 0x51: // eor ($ff),y\n\t\top->type = R_ANAL_OP_TYPE_XOR;\n\t\t_6502_anal_esil_get_addr_pattern1 (op, data, addrbuf, buffsize);\n\t\tif (data[0] == 0x49) // immediate mode\n\t\t\tr_strbuf_setf (&op->esil, \"%s,a,^=\", addrbuf);\n\t\telse\tr_strbuf_setf (&op->esil, \"%s,[1],a,^=\", addrbuf);\n\t\t_6502_anal_update_flags (op, _6502_FLAGS_NZ);\n\t\tbreak;\n\tcase 0x0a: // asl a\n\tcase 0x06: // asl $ff\n\tcase 0x16: // asl $ff,x\n\tcase 0x0e: // asl $ffff\n\tcase 0x1e: // asl $ffff,x\n\t\top->type = R_ANAL_OP_TYPE_SHL;\n\t\tif (data[0] == 0x0a) {\n\t\t\tr_strbuf_set (&op->esil, \"1,a,<<=,$c7,C,=,a,a,=\");\n\t\t} else  {\n\t\t\t_6502_anal_esil_get_addr_pattern2 (op, data, addrbuf, buffsize, 'x');\n\t\t\tr_strbuf_setf (&op->esil, \"1,%s,[1],<<,%s,=[1],$c7,C,=\", addrbuf, addrbuf);\n\t\t}\n\t\t_6502_anal_update_flags (op, _6502_FLAGS_NZ);\n\t\tbreak;\n\tcase 0x4a: // lsr a\n\tcase 0x46: // lsr $ff\n\tcase 0x56: // lsr $ff,x\n\tcase 0x4e: // lsr $ffff\n\tcase 0x5e: // lsr $ffff,x\n\t\top->type = R_ANAL_OP_TYPE_SHR;\n\t\tif (data[0] == 0x4a) {\n\t\t\tr_strbuf_set (&op->esil, \"1,a,&,C,=,1,a,>>=\");\n\t\t} else {\n\t\t\t_6502_anal_esil_get_addr_pattern2 (op, data, addrbuf, buffsize, 'x');\n\t\t\tr_strbuf_setf (&op->esil, \"1,%s,[1],&,C,=,1,%s,[1],>>,%s,=[1]\", addrbuf, addrbuf, addrbuf);\n\t\t}\n\t\t_6502_anal_update_flags (op, _6502_FLAGS_NZ);\n\t\tbreak;\n\tcase 0x2a: // rol a\n\tcase 0x26: // rol $ff\n\tcase 0x36: // rol $ff,x\n\tcase 0x2e: // rol $ffff\n\tcase 0x3e: // rol $ffff,x\n\t\top->type = R_ANAL_OP_TYPE_ROL;\n\t\tif (data[0] == 0x2a) {\n\t\t\tr_strbuf_set (&op->esil, \"1,a,<<,C,|,a,=,$c7,C,=,a,a,=\");\n\t\t} else {\n\t\t\t_6502_anal_esil_get_addr_pattern2 (op, data, addrbuf, buffsize, 'x');\n\t\t\tr_strbuf_setf (&op->esil, \"1,%s,[1],<<,C,|,%s,=[1],$c7,C,=\", addrbuf, addrbuf);\n\t\t}\n\t\t_6502_anal_update_flags (op, _6502_FLAGS_NZ);\n\t\tbreak;\n\tcase 0x6a: // ror a\n\tcase 0x66: // ror $ff\n\tcase 0x76: // ror $ff,x\n\tcase 0x6e: // ror $ffff\n\tcase 0x7e: // ror $ffff,x\n\t\top->type = R_ANAL_OP_TYPE_ROR;\n\t\tif (data[0] == 0x6a) {\n\t\t\tr_strbuf_set (&op->esil, \"C,N,=,1,a,&,C,=,1,a,>>,7,N,<<,|,a,=\");\n\t\t} else {\n\t\t\t_6502_anal_esil_get_addr_pattern2 (op, data, addrbuf, buffsize, 'x');\n\t\t\tr_strbuf_setf (&op->esil, \"C,N,=,1,%s,[1],&,C,=,1,%s,[1],>>,7,N,<<,|,%s,=[1]\", addrbuf, addrbuf, addrbuf);\n\t\t}\n\t\t_6502_anal_update_flags (op, _6502_FLAGS_NZ);\n\t\tbreak;\n\tcase 0xe6: // inc $ff\n\tcase 0xf6: // inc $ff,x\n\tcase 0xee: // inc $ffff\n\tcase 0xfe: // inc $ffff,x\n\t\top->type = R_ANAL_OP_TYPE_STORE;\n\t\t_6502_anal_esil_get_addr_pattern2 (op, data, addrbuf, buffsize, 'x');\n\t\tr_strbuf_setf (&op->esil, \"%s,++=[1]\", addrbuf);\n\t\t_6502_anal_update_flags (op, _6502_FLAGS_NZ);\n\t\tbreak;\n\tcase 0xc6: // dec $ff\n\tcase 0xd6: // dec $ff,x\n\tcase 0xce: // dec $ffff\n\tcase 0xde: // dec $ffff,x\n\t\top->type = R_ANAL_OP_TYPE_STORE;\n\t\t_6502_anal_esil_get_addr_pattern2 (op, data, addrbuf, buffsize, 'x');\n\t\tr_strbuf_setf (&op->esil, \"%s,--=[1]\", addrbuf);\n\t\t_6502_anal_update_flags (op, _6502_FLAGS_NZ);\n\t\tbreak;\n\tcase 0xe8: // inx\n\tcase 0xc8: // iny\n\t\top->cycles = 2;\n\t\top->type = R_ANAL_OP_TYPE_STORE;\n\t\t_6502_anal_esil_inc_reg (op, data[0], \"+\");\n\t\tbreak;\n\tcase 0xca: // dex\n\tcase 0x88: // dey\n\t\top->cycles = 2;\n\t\top->type = R_ANAL_OP_TYPE_STORE;\n\t\t_6502_anal_esil_inc_reg (op, data[0], \"-\");\n\t\tbreak;\n\tcase 0xc9: // cmp #$ff\n\tcase 0xc5: // cmp $ff\n\tcase 0xd5: // cmp $ff,x\n\tcase 0xcd: // cmp $ffff\n\tcase 0xdd: // cmp $ffff,x\n\tcase 0xd9: // cmp $ffff,y\n\tcase 0xc1: // cmp ($ff,x)\n\tcase 0xd1: // cmp ($ff),y\n\t\top->type = R_ANAL_OP_TYPE_CMP;\n\t\t_6502_anal_esil_get_addr_pattern1 (op, data, addrbuf, buffsize);\n\t\tif (data[0] == 0xc9) // immediate mode\n\t\t\tr_strbuf_setf (&op->esil, \"%s,a,==\", addrbuf);\n\t\telse\tr_strbuf_setf (&op->esil, \"%s,[1],a,==\", addrbuf);\n\t\t_6502_anal_update_flags (op, _6502_FLAGS_BNZ);\n\t\tr_strbuf_append (&op->esil, \",C,!,C,=\");\n\t\tbreak;\n\tcase 0xe0: // cpx #$ff\n\tcase 0xe4: // cpx $ff\n\tcase 0xec: // cpx $ffff\n\t\top->type = R_ANAL_OP_TYPE_CMP;\n\t\t_6502_anal_esil_get_addr_pattern3 (op, data, addrbuf, buffsize, 0);\n\t\tif (data[0] == 0xe0) // immediate mode\n\t\t\tr_strbuf_setf (&op->esil, \"%s,x,==\", addrbuf);\n\t\telse\tr_strbuf_setf (&op->esil, \"%s,[1],x,==\", addrbuf);\n\t\t_6502_anal_update_flags (op, _6502_FLAGS_BNZ);\n\t\tr_strbuf_append (&op->esil, \",C,!,C,=\");\n\t\tbreak;\n\tcase 0xc0: // cpy #$ff\n\tcase 0xc4: // cpy $ff\n\tcase 0xcc: // cpy $ffff\n\t\top->type = R_ANAL_OP_TYPE_CMP;\n\t\t_6502_anal_esil_get_addr_pattern3 (op, data, addrbuf, buffsize, 0);\n\t\tif (data[0] == 0xc0) // immediate mode\n\t\t\tr_strbuf_setf (&op->esil, \"%s,y,==\", addrbuf);\n\t\telse\tr_strbuf_setf (&op->esil, \"%s,[1],y,==\", addrbuf);\n\t\t_6502_anal_update_flags (op, _6502_FLAGS_BNZ);\n\t\tr_strbuf_append (&op->esil, \",C,!,C,=\");\n\t\tbreak;\n\tcase 0x10: // bpl $ffff\n\tcase 0x30: // bmi $ffff\n\tcase 0x50: // bvc $ffff\n\tcase 0x70: // bvs $ffff\n\tcase 0x90: // bcc $ffff\n\tcase 0xb0: // bcs $ffff\n\tcase 0xd0: // bne $ffff\n\tcase 0xf0: // beq $ffff\n \t\top->cycles = 2;\n \t\top->failcycles = 3;\n \t\top->type = R_ANAL_OP_TYPE_CJMP;\n\t\tif (data[1] <= 127)\n\t\t\top->jump = addr + data[1] + op->size;\n\t\telse\top->jump = addr - (256 - data[1]) + op->size;\n \t\top->fail = addr + op->size;\n\t\t_6502_anal_esil_ccall (op, data[0]);\n\t\tbreak;\n\tcase 0x20: // jsr $ffff\n\t\top->cycles = 6;\n\t\top->type = R_ANAL_OP_TYPE_CALL;\n\t\top->jump = data[1] | data[2] << 8;\n\t\top->stackop = R_ANAL_STACK_INC;\n\t\top->stackptr = 2;\n\t\tr_strbuf_setf (&op->esil, \"1,pc,-,0xff,sp,+,=[2],0x%04x,pc,=,2,sp,-=\", op->jump);\n\t\tbreak;\n\tcase 0x4c: // jmp $ffff\n\t\top->cycles = 3;\n\t\top->type = R_ANAL_OP_TYPE_JMP;\n\t\top->jump = data[1] | data[2] << 8;\n\t\tr_strbuf_setf (&op->esil, \"0x%04x,pc,=\", op->jump);\n\t\tbreak;\n\tcase 0x6c: // jmp ($ffff)\n\t\top->cycles = 5;\n\t\top->type = R_ANAL_OP_TYPE_UJMP;\n\t\tr_strbuf_setf (&op->esil, \"0x%04x,[2],pc,=\", data[1] | data[2] << 8);\n\t\tbreak;\n\tcase 0x60: // rts\n\t\top->eob = true;\n\t\top->type = R_ANAL_OP_TYPE_RET;\n\t\top->cycles = 6;\n\t\top->stackop = R_ANAL_STACK_INC;\n\t\top->stackptr = -2;\n\t\tr_strbuf_set (&op->esil, \"0x101,sp,+,[2],pc,=,pc,++=,2,sp,+=\");\n\t\tbreak;\n\tcase 0x40: // rti\n\t\top->eob = true;\n\t\top->type = R_ANAL_OP_TYPE_RET;\n\t\top->cycles = 6;\n\t\top->stackop = R_ANAL_STACK_INC;\n\t\top->stackptr = -3;\n\t\tr_strbuf_set (&op->esil, \"0x101,sp,+,[1],flags,=,0x102,sp,+,[2],pc,=,3,sp,+=\");\n\t\tbreak;\n\tcase 0xea: // nop\n\t\top->type = R_ANAL_OP_TYPE_NOP;\n\t\top->cycles = 2;\n\t\tbreak;\n\tcase 0xa9: // lda #$ff\n\tcase 0xa5: // lda $ff\n\tcase 0xb5: // lda $ff,x\n\tcase 0xad: // lda $ffff\n\tcase 0xbd: // lda $ffff,x\n\tcase 0xb9: // lda $ffff,y\n\tcase 0xa1: // lda ($ff,x)\n\tcase 0xb1: // lda ($ff),y\n\t\top->type = R_ANAL_OP_TYPE_LOAD;\n\t\t_6502_anal_esil_get_addr_pattern1 (op, data, addrbuf, buffsize);\n\t\tif (data[0] == 0xa9) // immediate mode\n\t\t\tr_strbuf_setf (&op->esil, \"%s,a,=\", addrbuf);\n\t\telse\tr_strbuf_setf (&op->esil, \"%s,[1],a,=\", addrbuf);\n\t\t_6502_anal_update_flags (op, _6502_FLAGS_NZ);\n\t\tbreak;\n\tcase 0xa2: // ldx #$ff\n\tcase 0xa6: // ldx $ff\n\tcase 0xb6: // ldx $ff,y\n\tcase 0xae: // ldx $ffff\n\tcase 0xbe: // ldx $ffff,y\n\t\top->type = R_ANAL_OP_TYPE_LOAD;\n\t\t_6502_anal_esil_get_addr_pattern2 (op, data, addrbuf, buffsize, 'y');\n\t\tif (data[0] == 0xa2) // immediate mode\n\t\t\tr_strbuf_setf (&op->esil, \"%s,x,=\", addrbuf);\n\t\telse\tr_strbuf_setf (&op->esil, \"%s,[1],x,=\", addrbuf);\n\t\t_6502_anal_update_flags (op, _6502_FLAGS_NZ);\n\t\tbreak;\n\tcase 0xa0: // ldy #$ff\n\tcase 0xa4: // ldy $ff\n\tcase 0xb4: // ldy $ff,x\n\tcase 0xac: // ldy $ffff\n\tcase 0xbc: // ldy $ffff,x\n\t\top->type = R_ANAL_OP_TYPE_LOAD;\n\t\t_6502_anal_esil_get_addr_pattern3 (op, data, addrbuf, buffsize, 'x');\n\t\tif (data[0] == 0xa0) // immediate mode\n\t\t\tr_strbuf_setf (&op->esil, \"%s,y,=\", addrbuf);\n\t\telse\tr_strbuf_setf (&op->esil, \"%s,[1],y,=\", addrbuf);\n\t\t_6502_anal_update_flags (op, _6502_FLAGS_NZ);\n\t\tbreak;\n\tcase 0x85: // sta $ff\n\tcase 0x95: // sta $ff,x\n\tcase 0x8d: // sta $ffff\n\tcase 0x9d: // sta $ffff,x\n\tcase 0x99: // sta $ffff,y\n\tcase 0x81: // sta ($ff,x)\n\tcase 0x91: // sta ($ff),y\n\t\top->type = R_ANAL_OP_TYPE_STORE;\n\t\t_6502_anal_esil_get_addr_pattern1 (op, data, addrbuf, buffsize);\n\t\tr_strbuf_setf (&op->esil, \"a,%s,=[1]\", addrbuf);\n\t\tbreak;\n\tcase 0x86: // stx $ff\n\tcase 0x96: // stx $ff,y\n\tcase 0x8e: // stx $ffff\n\t\top->type = R_ANAL_OP_TYPE_STORE;\n\t\t_6502_anal_esil_get_addr_pattern2 (op, data, addrbuf, buffsize, 'y');\n\t\tr_strbuf_setf (&op->esil, \"x,%s,=[1]\", addrbuf);\n\t\tbreak;\n\tcase 0x84: // sty $ff\n\tcase 0x94: // sty $ff,x\n\tcase 0x8c: // sty $ffff\n\t\top->type = R_ANAL_OP_TYPE_STORE;\n\t\t_6502_anal_esil_get_addr_pattern3 (op, data, addrbuf, buffsize, 'x');\n\t\tr_strbuf_setf (&op->esil, \"y,%s,=[1]\", addrbuf);\n\t\tbreak;\n\tcase 0x08: // php\n\tcase 0x48: // pha\n\t\top->type = R_ANAL_OP_TYPE_PUSH;\n\t\top->cycles = 3;\n\t\top->stackop = R_ANAL_STACK_INC;\n\t\top->stackptr = 1;\n\t\t_6502_anal_esil_push (op, data[0]);\n\t\tbreak;\n\tcase 0x28: // plp\n\tcase 0x68: // plp\n\t\top->type = R_ANAL_OP_TYPE_POP;\n\t\top->cycles = 4;\n\t\top->stackop = R_ANAL_STACK_INC;\n\t\top->stackptr = -1;\n\t\t_6502_anal_esil_pop (op, data[0]);\n\t\tbreak;\n\tcase 0xaa: // tax\n\tcase 0x8a: // txa\n\tcase 0xa8: // tay\n\tcase 0x98: // tya\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\top->cycles = 2;\n\t\t_6502_anal_esil_mov (op, data[0]);\n\t\tbreak;\n\tcase 0x9a: // txs\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\top->cycles = 2;\n\t\top->stackop = R_ANAL_STACK_SET;\n\t\t_6502_anal_esil_mov (op, data[0]);\n\t\tbreak;\n\tcase 0xba: // tsx\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\top->cycles = 2;\n\t\top->stackop = R_ANAL_STACK_GET;\n\t\t_6502_anal_esil_mov (op, data[0]);\n\t\tbreak;\n\t}\n\treturn op->size;\n}\n", "target": 1, "idx": 182369}
{"func": "build_config(char *prefix, struct server *server)\n {\n     char *path    = NULL;\n     int path_size = strlen(prefix) + strlen(server->port) + 20;\n\n    path = ss_malloc(path_size);\n    snprintf(path, path_size, \"%s/.shadowsocks_%s.conf\", prefix, server->port);\n    FILE *f = fopen(path, \"w+\");\n    if (f == NULL) {\n        if (verbose) {\n            LOGE(\"unable to open config file\");\n        }\n        ss_free(path);\n        return;\n    }\n     fprintf(f, \"{\\n\");\n     fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n     fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n     fprintf(f, \"\\n}\\n\");\n     fclose(f);\n     ss_free(path);\n}\n", "target": 1, "idx": 180885}
{"func": "void GpuCommandBufferStub::OnCommandProcessed() {\n  if (watchdog_)\n    watchdog_->CheckArmed();\n}\n", "target": 0, "idx": 114387}
{"func": "static int cdxl_decode_frame(AVCodecContext *avctx, void *data,\n                             int *got_frame, AVPacket *pkt)\n{\n    CDXLVideoContext *c = avctx->priv_data;\n    AVFrame * const p = data;\n    int ret, w, h, encoding, aligned_width, buf_size = pkt->size;\n    const uint8_t *buf = pkt->data;\n\n    if (buf_size < 32)\n        return AVERROR_INVALIDDATA;\n    encoding        = buf[1] & 7;\n    c->format       = buf[1] & 0xE0;\n    w               = AV_RB16(&buf[14]);\n    h               = AV_RB16(&buf[16]);\n    c->bpp          = buf[19];\n    c->palette_size = AV_RB16(&buf[20]);\n    c->palette      = buf + 32;\n    c->video        = c->palette + c->palette_size;\n    c->video_size   = buf_size - c->palette_size - 32;\n\n    if (c->palette_size > 512)\n        return AVERROR_INVALIDDATA;\n    if (buf_size < c->palette_size + 32)\n        return AVERROR_INVALIDDATA;\n    if (c->bpp < 1)\n        return AVERROR_INVALIDDATA;\n    if (c->format != BIT_PLANAR && c->format != BIT_LINE && c->format != CHUNKY) {\n        avpriv_request_sample(avctx, \"Pixel format 0x%0x\", c->format);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    if ((ret = ff_set_dimensions(avctx, w, h)) < 0)\n        return ret;\n\n    if (c->format == CHUNKY)\n        aligned_width = avctx->width;\n    else\n        aligned_width = FFALIGN(c->avctx->width, 16);\n    c->padded_bits  = aligned_width - c->avctx->width;\n    if (c->video_size < aligned_width * avctx->height * (int64_t)c->bpp / 8)\n         return AVERROR_INVALIDDATA;\n     if (!encoding && c->palette_size && c->bpp <= 8 && c->format != CHUNKY) {\n         avctx->pix_fmt = AV_PIX_FMT_PAL8;\n    } else if (encoding == 1 && (c->bpp == 6 || c->bpp == 8)) {\n         if (c->palette_size != (1 << (c->bpp - 1)))\n             return AVERROR_INVALIDDATA;\n         avctx->pix_fmt = AV_PIX_FMT_BGR24;\n    } else if (!encoding && c->bpp == 24 && c->format == CHUNKY &&\n               !c->palette_size) {\n        avctx->pix_fmt = AV_PIX_FMT_RGB24;\n    } else {\n        avpriv_request_sample(avctx, \"Encoding %d, bpp %d and format 0x%x\",\n                              encoding, c->bpp, c->format);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    if ((ret = ff_get_buffer(avctx, p, 0)) < 0)\n        return ret;\n    p->pict_type = AV_PICTURE_TYPE_I;\n\n    if (encoding) {\n        av_fast_padded_malloc(&c->new_video, &c->new_video_size,\n                              h * w + AV_INPUT_BUFFER_PADDING_SIZE);\n        if (!c->new_video)\n            return AVERROR(ENOMEM);\n        if (c->bpp == 8)\n            cdxl_decode_ham8(c, p);\n        else\n            cdxl_decode_ham6(c, p);\n    } else if (avctx->pix_fmt == AV_PIX_FMT_PAL8) {\n        cdxl_decode_rgb(c, p);\n    } else {\n        cdxl_decode_raw(c, p);\n    }\n    *got_frame = 1;\n\n    return buf_size;\n}\n", "target": 1, "idx": 181241}
{"func": "static int modify_raw_packet_qp_sq(struct mlx5_core_dev *dev,\n\t\t\t\t   struct mlx5_ib_sq *sq,\n\t\t\t\t   int new_state,\n\t\t\t\t   const struct mlx5_modify_raw_qp_param *raw_qp_param)\n{\n\tstruct mlx5_ib_qp *ibqp = sq->base.container_mibqp;\n\tstruct mlx5_rate_limit old_rl = ibqp->rl;\n\tstruct mlx5_rate_limit new_rl = old_rl;\n\tbool new_rate_added = false;\n\tu16 rl_index = 0;\n\tvoid *in;\n\tvoid *sqc;\n\tint inlen;\n\tint err;\n\n\tinlen = MLX5_ST_SZ_BYTES(modify_sq_in);\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\tMLX5_SET(modify_sq_in, in, sq_state, sq->state);\n\n\tsqc = MLX5_ADDR_OF(modify_sq_in, in, ctx);\n\tMLX5_SET(sqc, sqc, state, new_state);\n\n\tif (raw_qp_param->set_mask & MLX5_RAW_QP_RATE_LIMIT) {\n\t\tif (new_state != MLX5_SQC_STATE_RDY)\n\t\t\tpr_warn(\"%s: Rate limit can only be changed when SQ is moving to RDY\\n\",\n\t\t\t\t__func__);\n\t\telse\n\t\t\tnew_rl = raw_qp_param->rl;\n\t}\n\n\tif (!mlx5_rl_are_equal(&old_rl, &new_rl)) {\n\t\tif (new_rl.rate) {\n\t\t\terr = mlx5_rl_add_rate(dev, &rl_index, &new_rl);\n\t\t\tif (err) {\n\t\t\t\tpr_err(\"Failed configuring rate limit(err %d): \\\n\t\t\t\t       rate %u, max_burst_sz %u, typical_pkt_sz %u\\n\",\n\t\t\t\t       err, new_rl.rate, new_rl.max_burst_sz,\n\t\t\t\t       new_rl.typical_pkt_sz);\n\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tnew_rate_added = true;\n\t\t}\n\n\t\tMLX5_SET64(modify_sq_in, in, modify_bitmask, 1);\n\t\t/* index 0 means no limit */\n\t\tMLX5_SET(sqc, sqc, packet_pacing_rate_limit_index, rl_index);\n\t}\n\n\terr = mlx5_core_modify_sq(dev, sq->base.mqp.qpn, in, inlen);\n\tif (err) {\n\t\t/* Remove new rate from table if failed */\n\t\tif (new_rate_added)\n\t\t\tmlx5_rl_remove_rate(dev, &new_rl);\n\t\tgoto out;\n\t}\n\n\t/* Only remove the old rate after new rate was set */\n\tif ((old_rl.rate &&\n\t     !mlx5_rl_are_equal(&old_rl, &new_rl)) ||\n\t    (new_state != MLX5_SQC_STATE_RDY))\n\t\tmlx5_rl_remove_rate(dev, &old_rl);\n\n\tibqp->rl = new_rl;\n\tsq->state = new_state;\n\nout:\n\tkvfree(in);\n\treturn err;\n}\n", "target": 0, "idx": 92169}
{"func": "static inline void checkThrottle(struct airo_info *ai)\n{\n\tint i;\n/* Old hardware had a limit on encryption speed */\n\tif (ai->config.authType != AUTH_OPEN && maxencrypt) {\n\t\tfor(i=0; i<8; i++) {\n\t\t\tif (ai->config.rates[i] > maxencrypt) {\n\t\t\t\tai->config.rates[i] = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n", "target": 0, "idx": 24014}
{"func": " decompileAction(int n, SWF_ACTION *actions, int maxn)\n {\n\tif( n > maxn ) SWF_error(\"Action overflow!!\");\n \n #ifdef DEBUG\n \tfprintf(stderr,\"%d:\\tACTION[%3.3d]: %s\\n\",\n \t        actions[n].SWF_ACTIONRECORD.Offset, n, \n \t        actionName(actions[n].SWF_ACTIONRECORD.ActionCode));\n #endif\n \n\tswitch(actions[n].SWF_ACTIONRECORD.ActionCode)\n \t{\n \tcase SWFACTION_END:\n \t\treturn 0;\n\n\tcase SWFACTION_CONSTANTPOOL:\n\t\tdecompileCONSTANTPOOL(&actions[n]);\n\t\treturn 0;\n\n\tcase SWFACTION_GOTOLABEL:\n\t\treturn decompileGOTOFRAME(n, actions, maxn,1);\n\n\tcase SWFACTION_GOTOFRAME:\n\t\treturn decompileGOTOFRAME(n, actions, maxn,0);\n\n\tcase SWFACTION_GOTOFRAME2:\n\t\treturn decompileGOTOFRAME2(n, actions, maxn);\n\n\tcase SWFACTION_WAITFORFRAME:\n\t\tdecompileWAITFORFRAME(&actions[n]);\n\t\treturn 0;\n\n\tcase SWFACTION_GETURL2:\n\t\tdecompileGETURL2(&actions[n]);\n\t\treturn 0;\n\n\tcase SWFACTION_GETURL:\n\t\tdecompileGETURL(&actions[n]);\n\t\treturn 0;\n\n\tcase SWFACTION_PUSH:\n\t\tdecompilePUSH(&actions[n]);\n\t\treturn 0;\n\n\tcase SWFACTION_PUSHDUP:\n\t\tdecompilePUSHDUP(&actions[n]);\n\t\treturn 0;\n\n\tcase SWFACTION_STACKSWAP:\n\t\tdecompileSTACKSWAP(&actions[n]);\t\n\t\treturn 0;\n\n\tcase SWFACTION_SETPROPERTY:\n\t\tdecompileSETPROPERTY(n, actions, maxn);\n\t\treturn 0;\n\n\tcase SWFACTION_GETPROPERTY:\n\t\tdecompileGETPROPERTY(n, actions, maxn);\n\t\treturn 0;\n\n\tcase SWFACTION_GETTIME:\n\t\treturn decompileGETTIME(n, actions, maxn);\n\n\tcase SWFACTION_TRACE:\n\t\tdecompileTRACE(n, actions, maxn);\n\t\treturn 0;\n\n\tcase SWFACTION_CALLFRAME:\n\t\tdecompileCALLFRAME(n, actions, maxn);\n\t\treturn 0;\n\n\tcase SWFACTION_EXTENDS:\n\t\tdecompileEXTENDS(n, actions, maxn);\n\t\treturn 0;\n\n\tcase SWFACTION_INITOBJECT:\n\t\tdecompileINITOBJECT(n, actions, maxn);\n\t\treturn 0;\t        \n\n\tcase SWFACTION_NEWOBJECT:\n\t\tdecompileNEWOBJECT(n, actions, maxn);\n\t\treturn 0;\n\n\tcase SWFACTION_NEWMETHOD:\n\t\tdecompileNEWMETHOD(n, actions, maxn);\n\t\treturn 0;\n\n\tcase SWFACTION_GETMEMBER:\n\t\tdecompileGETMEMBER(n, actions, maxn);\n\t\treturn 0;\n\n\tcase SWFACTION_SETMEMBER:\n\t\tdecompileSETMEMBER(n, actions, maxn);\n\t\treturn 0;\n\n\tcase SWFACTION_GETVARIABLE:\n\t\tdecompileGETVARIABLE(n, actions, maxn);\n\t\treturn 0;\n\n\tcase SWFACTION_SETVARIABLE:\n\t\tdecompileSETVARIABLE(n, actions, maxn, 0);\n\t\treturn 0;\n\n\tcase SWFACTION_DEFINELOCAL:\n\t\tdecompileSETVARIABLE(n, actions, maxn, 1);\n\t\treturn 0;\n\n\tcase SWFACTION_DEFINELOCAL2:\n\t\tdecompileDEFINELOCAL2(n, actions, maxn);\n\t\treturn 0;\n\n\tcase SWFACTION_DECREMENT:\n\t\treturn decompileINCR_DECR(n, actions, maxn, 0);\n\n\tcase SWFACTION_INCREMENT:\n\t\treturn decompileINCR_DECR(n, actions, maxn,1);\n\n\tcase SWFACTION_STOREREGISTER:\n\t\tdecompileSTOREREGISTER(n, actions, maxn);\n\t\treturn 0;\n\n\tcase SWFACTION_JUMP:\n\t\treturn decompileJUMP(n, actions, maxn);\n\n\tcase SWFACTION_RETURN:\n\t\tdecompileRETURN(n, actions, maxn);\n\t\treturn 0;\n\n\tcase SWFACTION_LOGICALNOT:\n\t\treturn decompileLogicalNot(n, actions, maxn);\n\n\tcase SWFACTION_IF:\n\t\treturn decompileIF(n, actions, maxn);\n\n\tcase SWFACTION_WITH:\n\t\tdecompileWITH(n, actions, maxn);\n\t\treturn 0;\n\n\tcase SWFACTION_ENUMERATE:\n\t\treturn decompileENUMERATE(n, actions, maxn, 0);\n\n\tcase SWFACTION_ENUMERATE2 :\n\t\treturn decompileENUMERATE(n, actions, maxn,1);\n\n\tcase SWFACTION_INITARRAY:\n\t\treturn decompileINITARRAY(n, actions, maxn);\n\n\tcase SWFACTION_DEFINEFUNCTION:\t\n\t\treturn decompileDEFINEFUNCTION(n, actions, maxn,0);\n\n\tcase SWFACTION_DEFINEFUNCTION2:\n\t\treturn decompileDEFINEFUNCTION(n, actions, maxn,1);\n\n\tcase SWFACTION_CALLFUNCTION:\n\t\treturn decompileCALLFUNCTION(n, actions, maxn);\n\n\tcase SWFACTION_CALLMETHOD:\n\t\treturn decompileCALLMETHOD(n, actions, maxn);\n\n\tcase SWFACTION_INSTANCEOF:\n\tcase SWFACTION_SHIFTLEFT:\n\tcase SWFACTION_SHIFTRIGHT:\n\tcase SWFACTION_SHIFTRIGHT2:        \n\tcase SWFACTION_ADD:\n\tcase SWFACTION_ADD2:\n\tcase SWFACTION_SUBTRACT:\n\tcase SWFACTION_MULTIPLY:\n\tcase SWFACTION_DIVIDE:\n\tcase SWFACTION_MODULO:\n\tcase SWFACTION_BITWISEAND:\n\tcase SWFACTION_BITWISEOR:\n\tcase SWFACTION_BITWISEXOR:\n\tcase SWFACTION_EQUAL:\n\tcase SWFACTION_EQUALS2:\n\tcase SWFACTION_LESS2:\n\tcase SWFACTION_LOGICALAND:\n\tcase SWFACTION_LOGICALOR:\n\tcase SWFACTION_GREATER:\n\tcase SWFACTION_LESSTHAN:\n\tcase SWFACTION_STRINGEQ:\n\tcase SWFACTION_STRINGCOMPARE:\n\tcase SWFACTION_STRICTEQUALS:\n\t\treturn decompileArithmeticOp(n, actions, maxn);\n\n\tcase SWFACTION_POP:\n\t\tpop();\n\t\treturn 0;\n\n\tcase SWFACTION_STARTDRAG:\n\t\treturn decompileSTARTDRAG(n, actions, maxn);\n\n\tcase SWFACTION_DELETE:\n\t\treturn decompileDELETE(n, actions, maxn,0);\n\n\tcase SWFACTION_DELETE2:\n\t\treturn decompileDELETE(n, actions, maxn,1);\n\n\tcase SWFACTION_TARGETPATH:\n\t\treturn decompileSingleArgBuiltInFunctionCall(n, actions, maxn,\"targetPath\");\n\n\tcase SWFACTION_TYPEOF:\n\t\treturn decompileSingleArgBuiltInFunctionCall(n, actions, maxn,\"typeof\");\n\n\tcase SWFACTION_ORD:\n\t\treturn decompileSingleArgBuiltInFunctionCall(n, actions, maxn,\"ord\");\n\n\tcase SWFACTION_CHR:\n\t\treturn decompileSingleArgBuiltInFunctionCall(n, actions, maxn,\"chr\");\n\n\tcase SWFACTION_INT:\n\t\treturn decompileSingleArgBuiltInFunctionCall(n, actions, maxn,\"int\");\n\n\tcase SWFACTION_TOSTRING:\n\t\treturn decompileSingleArgBuiltInFunctionCall(n, actions, maxn,\"String\");     \n\n\tcase SWFACTION_TONUMBER:\n\t\treturn decompileSingleArgBuiltInFunctionCall(n, actions, maxn,\"Number\");\n\n\tcase SWFACTION_RANDOMNUMBER:\n\t\treturn decompileSingleArgBuiltInFunctionCall(n, actions, maxn,\"random\");\n\n\tcase SWFACTION_STRINGLENGTH:\n\t\treturn decompileSingleArgBuiltInFunctionCall(n, actions, maxn,\"length\");\n\n\tcase SWFACTION_PLAY:\n\t\treturn decompile_Null_ArgBuiltInFunctionCall(n, actions, maxn,\"play\");\n\n\tcase SWFACTION_STOP:\n\t\treturn decompile_Null_ArgBuiltInFunctionCall(n, actions, maxn,\"stop\");\n\n\tcase SWFACTION_NEXTFRAME:\n\t\treturn decompile_Null_ArgBuiltInFunctionCall(n, actions, maxn,\"nextFrame\");\n\n\tcase SWFACTION_PREVFRAME:\n\t\treturn decompile_Null_ArgBuiltInFunctionCall(n, actions, maxn,\"prevFrame\");\n\n\tcase SWFACTION_ENDDRAG:\n\t\treturn decompile_Null_ArgBuiltInFunctionCall(n, actions, maxn,\"stopDrag\");\n\n\tcase SWFACTION_STOPSOUNDS:\n\t\treturn decompile_Null_ArgBuiltInFunctionCall(n, actions, maxn,\"stopAllSounds\");   \n\n\tcase SWFACTION_TOGGLEQUALITY:\n\t\treturn decompile_Null_ArgBuiltInFunctionCall(n, actions, maxn,\"toggleHighQuality\");      \n\n\tcase SWFACTION_MBSUBSTRING:\n\tcase SWFACTION_SUBSTRING:\n\t\treturn decompileSUBSTRING(n, actions, maxn);\n\n\tcase SWFACTION_STRINGCONCAT:\n\t\treturn decompileSTRINGCONCAT(n, actions, maxn);\n\n\tcase SWFACTION_REMOVECLIP:\n\t\treturn decompileREMOVECLIP(n, actions, maxn);\n\n\tcase SWFACTION_DUPLICATECLIP:\n\t\treturn decompileDUPLICATECLIP(n, actions, maxn);\n\n\tcase SWFACTION_SETTARGET:\n\t\treturn decompileSETTARGET(n, actions, maxn,0);\n\n\tcase SWFACTION_SETTARGET2:\n\t\treturn decompileSETTARGET(n, actions, maxn,1);\n\n\tcase SWFACTION_IMPLEMENTSOP:\n\t\treturn decompileIMPLEMENTS(n, actions, maxn);\n\n\tcase SWFACTION_CASTOP:\n\t\treturn decompileCAST(n, actions, maxn);\n\n\tcase SWFACTION_THROW:\n\t\treturn decompileTHROW(n, actions, maxn);\n\n\tcase SWFACTION_TRY:\n\t\treturn decompileTRY(n, actions, maxn);\n\n\tdefault:\n\t\toutputSWF_ACTION(n,&actions[n]);\n\t\treturn 0;\n\t}\n}\n", "target": 1, "idx": 182818}
{"func": "static void sctp_v6_seq_dump_addr(struct seq_file *seq, union sctp_addr *addr)\n{\n\tseq_printf(seq, \"%pI6 \", &addr->v6.sin6_addr);\n}\n", "target": 0, "idx": 29652}
{"func": " FilePath ExtensionPrefs::GetExtensionPath(const std::string& extension_id) {\n   const DictionaryValue* dict = GetExtensionPref(extension_id);\n   std::string path;\n   if (!dict->GetString(kPrefPath, &path))\n     return FilePath();\n\n  return install_directory_.Append(FilePath::FromWStringHack(UTF8ToWide(path)));\n}\n", "target": 1, "idx": 183766}
{"func": "static int verify_newpolicy_info(struct xfrm_userpolicy_info *p)\n{\n\tswitch (p->share) {\n\tcase XFRM_SHARE_ANY:\n\tcase XFRM_SHARE_SESSION:\n\tcase XFRM_SHARE_USER:\n\tcase XFRM_SHARE_UNIQUE:\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (p->action) {\n\tcase XFRM_POLICY_ALLOW:\n\tcase XFRM_POLICY_BLOCK:\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (p->sel.family) {\n\tcase AF_INET:\n\t\tbreak;\n\n\tcase AF_INET6:\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tbreak;\n#else\n\t\treturn  -EAFNOSUPPORT;\n#endif\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn verify_policy_dir(p->dir);\n}\n", "target": 0, "idx": 33120}
{"func": "void WebSocketJob::OnConnected(\n    SocketStream* socket, int max_pending_send_allowed) {\n  if (state_ == CLOSED)\n    return;\n  DCHECK_EQ(CONNECTING, state_);\n  if (delegate_)\n    delegate_->OnConnected(socket, max_pending_send_allowed);\n}\n", "target": 0, "idx": 103252}
{"func": "bool f2fs_init_extent_tree(struct inode *inode, struct f2fs_extent *i_ext)\n {\n \tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n \tstruct extent_tree *et;\n\tstruct extent_node *en;\n\tstruct extent_info ei;\n\n\tif (!f2fs_may_extent_tree(inode)) {\n\t\t/* drop largest extent */\n\t\tif (i_ext && i_ext->len) {\n\t\t\ti_ext->len = 0;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tet = __grab_extent_tree(inode);\n\n\tif (!i_ext || !i_ext->len)\n\t\treturn false;\n\n\tget_extent_info(&ei, i_ext);\n\n\twrite_lock(&et->lock);\n\tif (atomic_read(&et->node_cnt))\n\t\tgoto out;\n\n\ten = __init_extent_tree(sbi, et, &ei);\n\tif (en) {\n\t\tspin_lock(&sbi->extent_lock);\n\t\tlist_add_tail(&en->list, &sbi->extent_list);\n\t\tspin_unlock(&sbi->extent_lock);\n\t}\nout:\n\twrite_unlock(&et->lock);\n \treturn false;\n }\n", "target": 1, "idx": 182588}
{"func": "void GLES2DecoderImpl::DoGetTexParameteriv(\n    GLenum target, GLenum pname, GLint* params) {\n  InitTextureMaxAnisotropyIfNeeded(target, pname);\n  glGetTexParameteriv(target, pname, params);\n}\n", "target": 0, "idx": 129291}
{"func": "void WallpaperManager::SetDefaultWallpaperPath(\n    const base::FilePath& default_small_wallpaper_file,\n    std::unique_ptr<gfx::ImageSkia> small_wallpaper_image,\n    const base::FilePath& default_large_wallpaper_file,\n    std::unique_ptr<gfx::ImageSkia> large_wallpaper_image) {\n  default_small_wallpaper_file_ = default_small_wallpaper_file;\n  default_large_wallpaper_file_ = default_large_wallpaper_file;\n\n  ash::WallpaperController* controller =\n      ash::Shell::Get()->wallpaper_controller();\n\n  const bool need_update_screen =\n      default_wallpaper_image_.get() &&\n      controller->WallpaperIsAlreadyLoaded(default_wallpaper_image_->image(),\n                                           false /* compare_layouts */,\n                                           wallpaper::WALLPAPER_LAYOUT_CENTER);\n\n  default_wallpaper_image_.reset();\n  if (GetAppropriateResolution() == WALLPAPER_RESOLUTION_SMALL) {\n    if (small_wallpaper_image) {\n      default_wallpaper_image_.reset(\n          new user_manager::UserImage(*small_wallpaper_image));\n      default_wallpaper_image_->set_file_path(default_small_wallpaper_file);\n    }\n  } else {\n    if (large_wallpaper_image) {\n      default_wallpaper_image_.reset(\n          new user_manager::UserImage(*large_wallpaper_image));\n      default_wallpaper_image_->set_file_path(default_large_wallpaper_file);\n     }\n   }\n \n  if (need_update_screen)\n    DoSetDefaultWallpaper(EmptyAccountId(), MovableOnDestroyCallbackHolder());\n }\n", "target": 1, "idx": 185848}
{"func": "  string cookie_value() {\n    return decoder_->cookie_value_;\n  }\n", "target": 0, "idx": 133681}
{"func": "static void __exit exit_ext3_fs(void)\n{\n\tunregister_filesystem(&ext3_fs_type);\n\tdestroy_inodecache();\n\texit_ext3_xattr();\n}\n", "target": 0, "idx": 32909}
{"func": "void ProcessCommitResponseCommand::ModelChangingExecuteImpl(\n    SyncSession* session) {\n  ProcessCommitResponse(session);\n  ExtensionsActivityMonitor* monitor = session->context()->extensions_monitor();\n  if (session->status_controller()->HasBookmarkCommitActivity() &&\n      session->status_controller()->syncer_status()\n          .num_successful_bookmark_commits == 0) {\n    monitor->PutRecords(session->extensions_activity());\n    session->mutable_extensions_activity()->clear();\n  }\n}\n", "target": 0, "idx": 101205}
{"func": "static bool interface_ready(void) {\n return bt_hal_cbacks != NULL;\n}\n", "target": 0, "idx": 172815}
{"func": "bool IsURLAllowedInIncognito(const GURL& url) {\n  return url.scheme() == chrome::kChromeUIScheme &&\n      (url.host() == chrome::kChromeUISettingsHost ||\n       url.host() == chrome::kChromeUIExtensionsHost ||\n       url.host() == chrome::kChromeUIBookmarksHost);\n}\n", "target": 0, "idx": 100657}
{"func": "IMPEG2D_ERROR_CODES_T impeg2d_vld_decode(\n dec_state_t *ps_dec,\n    WORD16      *pi2_outAddr, /*!< Address where decoded symbols will be stored */\n const UWORD8 *pu1_scan, /*!< Scan table to be used */\n    UWORD8      *pu1_pos, /*!< Scan table to be used */\n    UWORD16     u2_intra_flag, /*!< Intra Macroblock or not */\n    UWORD16     u2_chroma_flag, /*!< Chroma Block or not */\n    UWORD16     u2_d_picture, /*!< D Picture or not */\n    UWORD16     u2_intra_vlc_format, /*!< Intra VLC format */\n    UWORD16     u2_mpeg2, /*!< MPEG-2 or not */\n    WORD32      *pi4_num_coeffs /*!< Returns the number of coeffs in block */\n )\n{\n\n    UWORD32 u4_sym_len;\n\n    UWORD32 u4_decoded_value;\n    UWORD32 u4_level_first_byte;\n    WORD32  u4_level;\n    UWORD32 u4_run, u4_numCoeffs;\n    UWORD32 u4_buf;\n    UWORD32 u4_buf_nxt;\n    UWORD32 u4_offset;\n    UWORD32 *pu4_buf_aligned;\n    UWORD32 u4_bits;\n stream_t *ps_stream = &ps_dec->s_bit_stream;\n    WORD32  u4_pos;\n    UWORD32 u4_nz_cols;\n    UWORD32 u4_nz_rows;\n\n *pi4_num_coeffs = 0;\n\n    ps_dec->u4_non_zero_cols = 0;\n    ps_dec->u4_non_zero_rows = 0;\n    u4_nz_cols = ps_dec->u4_non_zero_cols;\n    u4_nz_rows = ps_dec->u4_non_zero_rows;\n\n    GET_TEMP_STREAM_DATA(u4_buf,u4_buf_nxt,u4_offset,pu4_buf_aligned,ps_stream)\n /**************************************************************************/\n /* Decode the DC coefficient in case of Intra block                       */\n /**************************************************************************/\n if(u2_intra_flag)\n {\n        WORD32 dc_size;\n        WORD32 dc_diff;\n        WORD32 maxLen;\n        WORD32 idx;\n\n\n        maxLen = MPEG2_DCT_DC_SIZE_LEN;\n        idx = 0;\n if(u2_chroma_flag != 0)\n {\n            maxLen += 1;\n            idx++;\n }\n\n\n {\n            WORD16  end = 0;\n            UWORD32 maxLen_tmp = maxLen;\n            UWORD16 m_iBit;\n\n\n /* Get the maximum number of bits needed to decode a symbol */\n            IBITS_NXT(u4_buf,u4_buf_nxt,u4_offset,u4_bits,maxLen)\n do\n {\n                maxLen_tmp--;\n /* Read one bit at a time from the variable to decode the huffman code */\n                m_iBit = (UWORD8)((u4_bits >> maxLen_tmp) & 0x1);\n\n /* Get the next node pointer or the symbol from the tree */\n                end = gai2_impeg2d_dct_dc_size[idx][end][m_iBit];\n }while(end > 0);\n            dc_size = end + MPEG2_DCT_DC_SIZE_OFFSET;\n\n /* Flush the appropriate number of bits from the stream */\n            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,(maxLen - maxLen_tmp),pu4_buf_aligned)\n\n }\n\n\n\n if (dc_size != 0)\n {\n            UWORD32 u4_bits;\n\n            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned, dc_size)\n            dc_diff = u4_bits;\n\n if ((dc_diff & (1 << (dc_size - 1))) == 0) //v Probably the prediction algo?\n                dc_diff -= (1 << dc_size) - 1;\n }\n else\n {\n            dc_diff = 0;\n }\n\n\n        pi2_outAddr[*pi4_num_coeffs] = dc_diff;\n /* This indicates the position of the coefficient. Since this is the DC\n         * coefficient, we put the position as 0.\n         */\n        pu1_pos[*pi4_num_coeffs] = pu1_scan[0];\n (*pi4_num_coeffs)++;\n\n if (0 != dc_diff)\n {\n            u4_nz_cols |= 0x01;\n            u4_nz_rows |= 0x01;\n }\n\n        u4_numCoeffs = 1;\n }\n /**************************************************************************/\n /* Decoding of first AC coefficient in case of non Intra block            */\n /**************************************************************************/\n else\n {\n /* First symbol can be 1s */\n        UWORD32 u4_bits;\n\n        IBITS_NXT(u4_buf,u4_buf_nxt,u4_offset,u4_bits,1)\n\n if(u4_bits == 1)\n {\n\n            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,1, pu4_buf_aligned)\n            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned, 1)\n if(u4_bits == 1)\n {\n                pi2_outAddr[*pi4_num_coeffs] = -1;\n }\n else\n {\n                pi2_outAddr[*pi4_num_coeffs] = 1;\n }\n\n /* This indicates the position of the coefficient. Since this is the DC\n             * coefficient, we put the position as 0.\n             */\n            pu1_pos[*pi4_num_coeffs] = pu1_scan[0];\n (*pi4_num_coeffs)++;\n            u4_numCoeffs = 1;\n\n            u4_nz_cols |= 0x01;\n            u4_nz_rows |= 0x01;\n }\n else\n {\n            u4_numCoeffs = 0;\n }\n }\n if (1 == u2_d_picture)\n {\n        PUT_TEMP_STREAM_DATA(u4_buf, u4_buf_nxt, u4_offset, pu4_buf_aligned, ps_stream)\n        ps_dec->u4_non_zero_cols  = u4_nz_cols;\n        ps_dec->u4_non_zero_rows  = u4_nz_rows;\n return ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE);\n }\n\n\n\n if (1 == u2_intra_vlc_format && u2_intra_flag)\n {\n\n while(1)\n {\n\n                UWORD32 lead_zeros;\n                WORD16 DecodedValue;\n\n                u4_sym_len = 17;\n                IBITS_NXT(u4_buf,u4_buf_nxt,u4_offset,u4_bits,u4_sym_len)\n\n DecodedValue = gau2_impeg2d_tab_one_1_9[u4_bits >> 8];\n                u4_sym_len = (DecodedValue & 0xf);\n                u4_level = DecodedValue >> 9;\n /* One table lookup */\n if(0 != u4_level)\n {\n                    u4_run = ((DecodedValue >> 4) & 0x1f);\n                    u4_numCoeffs       += u4_run;\n                    u4_pos             = pu1_scan[u4_numCoeffs++ & 63];\n                    pu1_pos[*pi4_num_coeffs] = u4_pos;\n\n                    FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)\n                    pi2_outAddr[*pi4_num_coeffs] = u4_level;\n\n (*pi4_num_coeffs)++;\n }\n else\n {\n if (DecodedValue == END_OF_BLOCK_ONE)\n {\n                        u4_sym_len = 4;\n\n break;\n }\n else\n {\n /*Second table lookup*/\n                        lead_zeros = CLZ(u4_bits) - 20;/* -16 since we are dealing with WORD32 */\n if (0 != lead_zeros)\n {\n\n                            u4_bits         = (u4_bits >> (6 - lead_zeros)) & 0x001F;\n\n /* Flush the number of bits */\n if (1 == lead_zeros)\n {\n                                u4_sym_len         = ((u4_bits & 0x18) >> 3) == 2 ? 11:10;\n }\n else\n {\n                                u4_sym_len         = 11 + lead_zeros;\n }\n /* flushing */\n                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)\n\n /* Calculate the address */\n                            u4_bits         = ((lead_zeros - 1) << 5) + u4_bits;\n\n DecodedValue = gau2_impeg2d_tab_one_10_16[u4_bits];\n\n                            u4_run = BITS(DecodedValue, 8,4);\n                            u4_level = ((WORD16) DecodedValue) >> 9;\n\n                            u4_numCoeffs       += u4_run;\n                            u4_pos             = pu1_scan[u4_numCoeffs++ & 63];\n                            pu1_pos[*pi4_num_coeffs] = u4_pos;\n                            pi2_outAddr[*pi4_num_coeffs] = u4_level;\n (*pi4_num_coeffs)++;\n }\n /*********************************************************************/\n /* MPEG2 Escape Code                                                 */\n /*********************************************************************/\n else if(u2_mpeg2 == 1)\n {\n                            u4_sym_len         = 6;\n                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)\n                                IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,18)\n                                u4_decoded_value    = u4_bits;\n                            u4_run             = (u4_decoded_value >> 12);\n                            u4_level           = (u4_decoded_value & 0x0FFF);\n\n if (u4_level)\n                                u4_level = (u4_level - ((u4_level & 0x0800) << 1));\n\n                            u4_numCoeffs       += u4_run;\n                            u4_pos             = pu1_scan[u4_numCoeffs++ & 63];\n                            pu1_pos[*pi4_num_coeffs] = u4_pos;\n                            pi2_outAddr[*pi4_num_coeffs] = u4_level;\n (*pi4_num_coeffs)++;\n }\n /*********************************************************************/\n /* MPEG1 Escape Code                                                 */\n /*********************************************************************/\n else\n {\n /*-----------------------------------------------------------\n                            * MPEG-1 Stream\n                            *\n                            * <See D.9.3 of MPEG-2> Run-level escape syntax\n                            * Run-level values that cannot be coded with a VLC are coded\n                            * by the escape code '0000 01' followed by\n                            * either a 14-bit FLC (127 <= level <= 127),\n                            * or a 22-bit FLC (255 <= level <= 255).\n                            * This is described in Annex B,B.5f of MPEG-1.standard\n                            *-----------------------------------------------------------*/\n\n /*-----------------------------------------------------------\n                            * First 6 bits are the value of the Run. Next is First 8 bits\n                            * of Level. These bits decide whether it is 14 bit FLC or\n                            * 22-bit FLC.\n                            *\n                            * If( first 8 bits of Level == '1000000' or '00000000')\n                            *      then its is 22-bit FLC.\n                            * else\n                            *      it is 14-bit FLC.\n                            *-----------------------------------------------------------*/\n                            u4_sym_len         = 6;\n                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)\n                                IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,14)\n                                u4_decoded_value     = u4_bits;\n                            u4_run              = (u4_decoded_value >> 8);\n                            u4_level_first_byte = (u4_decoded_value & 0x0FF);\n if(u4_level_first_byte & 0x7F)\n {\n /*-------------------------------------------------------\n                                * First 8 bits of level are neither 1000000 nor 00000000\n                                * Hence 14-bit FLC (Last 8 bits are used to get level)\n                                *\n                                *  Level = (msb of Level_First_Byte is 1)?\n                                *          Level_First_Byte - 256 : Level_First_Byte\n                                *-------------------------------------------------------*/\n                                u4_level = (u4_level_first_byte -\n ((u4_level_first_byte & 0x80) << 1));\n }\n else\n {\n /*-------------------------------------------------------\n                                * Next 8 bits are either 1000000 or 00000000\n                                * Hence 22-bit FLC (Last 16 bits are used to get level)\n                                *\n                                *  Level = (msb of Level_First_Byte is 1)?\n                                *          Level_Second_Byte - 256 : Level_Second_Byte\n                                *-------------------------------------------------------*/\n                                IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,8)\n                                    u4_level = u4_bits;\n                                u4_level = (u4_level - (u4_level_first_byte << 1));\n }\n                            u4_numCoeffs += u4_run;\n\n                            u4_pos = pu1_scan[u4_numCoeffs++ & 63];\n\n                            pu1_pos[*pi4_num_coeffs] = u4_pos;\n                            pi2_outAddr[*pi4_num_coeffs] = u4_level;\n (*pi4_num_coeffs)++;\n }\n }\n }\n\n\n                 u4_nz_cols |= 1 << (u4_pos & 0x7);\n                 u4_nz_rows |= 1 << (u4_pos >> 0x3);\n \n \n             }\n             IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,u4_sym_len)\n            if (u4_numCoeffs > 64)\n            {\n                return IMPEG2D_MB_TEX_DECODE_ERR;\n            }\n         }\n         else\n         {\n while(1)\n {\n\n                UWORD32 lead_zeros;\n                UWORD16 DecodedValue;\n\n                u4_sym_len = 17;\n                IBITS_NXT(u4_buf, u4_buf_nxt, u4_offset, u4_bits, u4_sym_len)\n\n\n DecodedValue = gau2_impeg2d_tab_zero_1_9[u4_bits >> 8];\n                u4_sym_len = BITS(DecodedValue, 3, 0);\n                u4_level = ((WORD16) DecodedValue) >> 9;\n\n if (0 != u4_level)\n {\n                    u4_run = BITS(DecodedValue, 8,4);\n\n                    u4_numCoeffs       += u4_run;\n\n                    u4_pos                 = pu1_scan[u4_numCoeffs++ & 63];\n                    pu1_pos[*pi4_num_coeffs] = u4_pos;\n\n                    FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)\n                    pi2_outAddr[*pi4_num_coeffs] = u4_level;\n (*pi4_num_coeffs)++;\n }\n else\n {\n if(DecodedValue == END_OF_BLOCK_ZERO)\n {\n                        u4_sym_len = 2;\n\n break;\n }\n else\n {\n                        lead_zeros = CLZ(u4_bits) - 20;/* -15 since we are dealing with WORD32 */\n /*Second table lookup*/\n if (0 != lead_zeros)\n {\n                            u4_bits         = (u4_bits >> (6 - lead_zeros)) & 0x001F;\n\n /* Flush the number of bits */\n                            u4_sym_len         = 11 + lead_zeros;\n\n /* Calculate the address */\n                            u4_bits         = ((lead_zeros - 1) << 5) + u4_bits;\n\n DecodedValue = gau2_impeg2d_tab_zero_10_16[u4_bits];\n\n                            u4_run = BITS(DecodedValue, 8,4);\n                            u4_level = ((WORD16) DecodedValue) >> 9;\n\n                            u4_numCoeffs       += u4_run;\n\n                            u4_pos                 = pu1_scan[u4_numCoeffs++ & 63];\n                            pu1_pos[*pi4_num_coeffs] = u4_pos;\n if (1 == lead_zeros)\n                                u4_sym_len--;\n /* flushing */\n                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)\n                            pi2_outAddr[*pi4_num_coeffs] = u4_level;\n\n (*pi4_num_coeffs)++;\n }\n /*Escape Sequence*/\n else if(u2_mpeg2 == 1)\n {\n                            u4_sym_len         = 6;\n                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)\n                            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,18)\n                            u4_decoded_value    = u4_bits;\n                            u4_run             = (u4_decoded_value >> 12);\n                            u4_level           = (u4_decoded_value & 0x0FFF);\n\n if (u4_level)\n                                u4_level = (u4_level - ((u4_level & 0x0800) << 1));\n\n                            u4_numCoeffs           += u4_run;\n\n                            u4_pos                 = pu1_scan[u4_numCoeffs++ & 63];\n                            pu1_pos[*pi4_num_coeffs] = u4_pos;\n                            pi2_outAddr[*pi4_num_coeffs] = u4_level;\n\n (*pi4_num_coeffs)++;\n }\n /*********************************************************************/\n /* MPEG1 Escape Code                                                 */\n /*********************************************************************/\n else\n {\n /*-----------------------------------------------------------\n                            * MPEG-1 Stream\n                            *\n                            * <See D.9.3 of MPEG-2> Run-level escape syntax\n                            * Run-level values that cannot be coded with a VLC are coded\n                            * by the escape code '0000 01' followed by\n                            * either a 14-bit FLC (127 <= level <= 127),\n                            * or a 22-bit FLC (255 <= level <= 255).\n                            * This is described in Annex B,B.5f of MPEG-1.standard\n                            *-----------------------------------------------------------*/\n\n /*-----------------------------------------------------------\n                            * First 6 bits are the value of the Run. Next is First 8 bits\n                            * of Level. These bits decide whether it is 14 bit FLC or\n                            * 22-bit FLC.\n                            *\n                            * If( first 8 bits of Level == '1000000' or '00000000')\n                            *      then its is 22-bit FLC.\n                            * else\n                            *      it is 14-bit FLC.\n                            *-----------------------------------------------------------*/\n                            u4_sym_len             = 6;\n                            FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)\n                            IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,14)\n                            u4_decoded_value        = u4_bits;\n                            u4_run                 = (u4_decoded_value >> 8);\n                            u4_level_first_byte    = (u4_decoded_value & 0x0FF);\n if(u4_level_first_byte & 0x7F)\n {\n /*-------------------------------------------------------\n                                * First 8 bits of level are neither 1000000 nor 00000000\n                                * Hence 14-bit FLC (Last 8 bits are used to get level)\n                                *\n                                *  Level = (msb of Level_First_Byte is 1)?\n                                *          Level_First_Byte - 256 : Level_First_Byte\n                                *-------------------------------------------------------*/\n                                u4_level = (u4_level_first_byte -\n ((u4_level_first_byte & 0x80) << 1));\n }\n else\n {\n /*-------------------------------------------------------\n                                * Next 8 bits are either 1000000 or 00000000\n                                * Hence 22-bit FLC (Last 16 bits are used to get level)\n                                *\n                                *  Level = (msb of Level_First_Byte is 1)?\n                                *          Level_Second_Byte - 256 : Level_Second_Byte\n                                *-------------------------------------------------------*/\n                                IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,8)\n                                u4_level = u4_bits;\n                                u4_level = (u4_level - (u4_level_first_byte << 1));\n }\n                            u4_numCoeffs           += u4_run;\n\n                            u4_pos                 = pu1_scan[u4_numCoeffs++ & 63];\n                            pu1_pos[*pi4_num_coeffs] = u4_pos;\n                            pi2_outAddr[*pi4_num_coeffs] = u4_level;\n\n (*pi4_num_coeffs)++;\n }\n }\n }\n\n \n                 u4_nz_cols |= 1 << (u4_pos & 0x7);\n                 u4_nz_rows |= 1 << (u4_pos >> 0x3);\n            }\n            if (u4_numCoeffs > 64)\n            {\n                return IMPEG2D_MB_TEX_DECODE_ERR;\n             }\n \n             IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,u4_sym_len)\n\n }\n\n        PUT_TEMP_STREAM_DATA(u4_buf, u4_buf_nxt, u4_offset, pu4_buf_aligned, ps_stream)\n\n        ps_dec->u4_non_zero_cols  = u4_nz_cols;\n        ps_dec->u4_non_zero_rows  = u4_nz_rows;\n\n return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;\n}\n", "target": 1, "idx": 187947}
{"func": " checked_xcalloc (size_t num, size_t size)\n {\n    alloc_limit_assert (\"checked_xcalloc\", (num *size));\n     return xcalloc (num, size);\n }\n", "target": 1, "idx": 181528}
{"func": "String HTMLDocument::designMode() const\n{\n    return inDesignMode() ? \"on\" : \"off\";\n}\n", "target": 0, "idx": 118729}
{"func": " static enum AVPixelFormat h263_get_format(AVCodecContext *avctx)\n {\n     /* MPEG-4 Studio Profile only, not supported by hardware */\n     if (avctx->bits_per_raw_sample > 8) {\n        av_assert1(avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO);\n         return avctx->pix_fmt;\n     }\n \n    if (avctx->codec->id == AV_CODEC_ID_MSS2)\n        return AV_PIX_FMT_YUV420P;\n\n    if (CONFIG_GRAY && (avctx->flags & AV_CODEC_FLAG_GRAY)) {\n        if (avctx->color_range == AVCOL_RANGE_UNSPECIFIED)\n            avctx->color_range = AVCOL_RANGE_MPEG;\n        return AV_PIX_FMT_GRAY8;\n    }\n\n    return avctx->pix_fmt = ff_get_format(avctx, avctx->codec->pix_fmts);\n}\n", "target": 1, "idx": 182328}
{"func": "static unsigned mounts_poll(struct file *file, poll_table *wait)\n{\n\tstruct proc_mounts *p = file->private_data;\n\tunsigned res = POLLIN | POLLRDNORM;\n\n\tpoll_wait(file, &p->ns->poll, wait);\n\tif (mnt_had_events(p))\n\t\tres |= POLLERR | POLLPRI;\n\n\treturn res;\n}\n", "target": 0, "idx": 26824}
{"func": "ACodec::UninitializedState::UninitializedState(ACodec *codec)\n : BaseState(codec) {\n}\n", "target": 0, "idx": 177195}
{"func": "static void end_packfile(void)\n{\n\tstatic int running;\n\n\tif (running || !pack_data)\n\t\treturn;\n\n\trunning = 1;\n\tclear_delta_base_cache();\n\tif (object_count) {\n\t\tstruct packed_git *new_p;\n\t\tunsigned char cur_pack_sha1[20];\n\t\tchar *idx_name;\n\t\tint i;\n\t\tstruct branch *b;\n\t\tstruct tag *t;\n\n\t\tclose_pack_windows(pack_data);\n\t\tsha1close(pack_file, cur_pack_sha1, 0);\n\t\tfixup_pack_header_footer(pack_data->pack_fd, pack_data->sha1,\n\t\t\t\t    pack_data->pack_name, object_count,\n\t\t\t\t    cur_pack_sha1, pack_size);\n\t\tclose(pack_data->pack_fd);\n\t\tidx_name = keep_pack(create_index());\n\n\t\t/* Register the packfile with core git's machinery. */\n\t\tnew_p = add_packed_git(idx_name, strlen(idx_name), 1);\n\t\tif (!new_p)\n\t\t\tdie(\"core git rejected index %s\", idx_name);\n\t\tall_packs[pack_id] = new_p;\n\t\tinstall_packed_git(new_p);\n\n\t\t/* Print the boundary */\n\t\tif (pack_edges) {\n\t\t\tfprintf(pack_edges, \"%s:\", new_p->pack_name);\n\t\t\tfor (i = 0; i < branch_table_sz; i++) {\n\t\t\t\tfor (b = branch_table[i]; b; b = b->table_next_branch) {\n\t\t\t\t\tif (b->pack_id == pack_id)\n\t\t\t\t\t\tfprintf(pack_edges, \" %s\", sha1_to_hex(b->sha1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (t = first_tag; t; t = t->next_tag) {\n\t\t\t\tif (t->pack_id == pack_id)\n\t\t\t\t\tfprintf(pack_edges, \" %s\", sha1_to_hex(t->sha1));\n\t\t\t}\n\t\t\tfputc('\\n', pack_edges);\n\t\t\tfflush(pack_edges);\n\t\t}\n\n\t\tpack_id++;\n\t}\n\telse {\n\t\tclose(pack_data->pack_fd);\n\t\tunlink_or_warn(pack_data->pack_name);\n\t}\n\tfree(pack_data);\n\tpack_data = NULL;\n\trunning = 0;\n\n\t/* We can't carry a delta across packfiles. */\n\tstrbuf_release(&last_blob.data);\n\tlast_blob.offset = 0;\n\tlast_blob.depth = 0;\n}\n", "target": 0, "idx": 55066}
{"func": "DateTimeFieldElement::DateTimeFieldElement(Document* document, FieldOwner& fieldOwner)\n    : HTMLElement(spanTag, document)\n    , m_fieldOwner(&fieldOwner)\n {\n     setAttribute(roleAttr, \"spinbutton\");\n }\n", "target": 1, "idx": 184296}
{"func": "  std::string GetRequestStringForPNACL(const std::string& fragment) const {\n    return RequestString(test_page_url_ + fragment, \"navigate\", \"include\") +\n           RequestString(GetURL(\"/pnacl_url_loader.nmf\"), \"same-origin\",\n                         \"same-origin\") +\n           RequestString(GetURL(\"/pnacl_url_loader_newlib_pnacl.pexe\"),\n                         \"same-origin\", \"same-origin\");\n  }\n", "target": 0, "idx": 160237}
{"func": "l2tp_avp_print(netdissect_options *ndo, const u_char *dat, int length)\n{\n\tu_int len;\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\tuint16_t attr_type;\n\tint hidden = FALSE;\n\n\tif (length <= 0) {\n\t\treturn;\n\t}\n\n\tND_PRINT((ndo, \" \"));\n\n\tND_TCHECK(*ptr);\t/* Flags & Length */\n\tlen = EXTRACT_16BITS(ptr) & L2TP_AVP_HDR_LEN_MASK;\n\n\t/* If it is not long enough to contain the header, we'll give up. */\n\tif (len < 6)\n\t\tgoto trunc;\n\n\t/* If it goes past the end of the remaining length of the packet,\n\t   we'll give up. */\n\tif (len > (u_int)length)\n\t\tgoto trunc;\n\n \t/* If it goes past the end of the remaining length of the captured\n \t   data, we'll give up. */\n \tND_TCHECK2(*ptr, len);\n\t/* After this point, no need to worry about truncation */\n \n \tif (EXTRACT_16BITS(ptr) & L2TP_AVP_HDR_FLAG_MANDATORY) {\n \t\tND_PRINT((ndo, \"*\"));\n\t}\n\tif (EXTRACT_16BITS(ptr) & L2TP_AVP_HDR_FLAG_HIDDEN) {\n\t\thidden = TRUE;\n\t\tND_PRINT((ndo, \"?\"));\n\t}\n\tptr++;\n\n\tif (EXTRACT_16BITS(ptr)) {\n\t\t/* Vendor Specific Attribute */\n\t        ND_PRINT((ndo, \"VENDOR%04x:\", EXTRACT_16BITS(ptr))); ptr++;\n\t\tND_PRINT((ndo, \"ATTR%04x\", EXTRACT_16BITS(ptr))); ptr++;\n\t\tND_PRINT((ndo, \"(\"));\n\t\tprint_octets(ndo, (const u_char *)ptr, len-6);\n\t\tND_PRINT((ndo, \")\"));\n\t} else {\n\t\t/* IETF-defined Attributes */\n\t\tptr++;\n\t\tattr_type = EXTRACT_16BITS(ptr); ptr++;\n\t\tND_PRINT((ndo, \"%s\", tok2str(l2tp_avp2str, \"AVP-#%u\", attr_type)));\n\t\tND_PRINT((ndo, \"(\"));\n\t\tif (hidden) {\n\t\t\tND_PRINT((ndo, \"???\"));\n \t\t} else {\n \t\t\tswitch (attr_type) {\n \t\t\tcase L2TP_AVP_MSGTYPE:\n\t\t\t\tl2tp_msgtype_print(ndo, (const u_char *)ptr);\n \t\t\t\tbreak;\n \t\t\tcase L2TP_AVP_RESULT_CODE:\n \t\t\t\tl2tp_result_code_print(ndo, (const u_char *)ptr, len-6);\n \t\t\t\tbreak;\n \t\t\tcase L2TP_AVP_PROTO_VER:\n\t\t\t\tl2tp_proto_ver_print(ndo, ptr);\n \t\t\t\tbreak;\n \t\t\tcase L2TP_AVP_FRAMING_CAP:\n\t\t\t\tl2tp_framing_cap_print(ndo, (const u_char *)ptr);\n \t\t\t\tbreak;\n \t\t\tcase L2TP_AVP_BEARER_CAP:\n\t\t\t\tl2tp_bearer_cap_print(ndo, (const u_char *)ptr);\n \t\t\t\tbreak;\n \t\t\tcase L2TP_AVP_TIE_BREAKER:\n \t\t\t\tprint_octets(ndo, (const u_char *)ptr, 8);\n \t\t\t\tbreak;\n \t\t\tcase L2TP_AVP_FIRM_VER:\n \t\t\tcase L2TP_AVP_ASSND_TUN_ID:\n \t\t\tcase L2TP_AVP_RECV_WIN_SIZE:\n \t\t\tcase L2TP_AVP_ASSND_SESS_ID:\n \t\t\t\tprint_16bits_val(ndo, ptr);\n \t\t\t\tbreak;\n \t\t\tcase L2TP_AVP_HOST_NAME:\n\t\t\tcase L2TP_AVP_VENDOR_NAME:\n\t\t\tcase L2TP_AVP_CALLING_NUMBER:\n\t\t\tcase L2TP_AVP_CALLED_NUMBER:\n\t\t\tcase L2TP_AVP_SUB_ADDRESS:\n\t\t\tcase L2TP_AVP_PROXY_AUTH_NAME:\n\t\t\tcase L2TP_AVP_PRIVATE_GRP_ID:\n\t\t\t\tprint_string(ndo, (const u_char *)ptr, len-6);\n\t\t\t\tbreak;\n\t\t\tcase L2TP_AVP_CHALLENGE:\n\t\t\tcase L2TP_AVP_INI_RECV_LCP:\n\t\t\tcase L2TP_AVP_LAST_SENT_LCP:\n\t\t\tcase L2TP_AVP_LAST_RECV_LCP:\n\t\t\tcase L2TP_AVP_PROXY_AUTH_CHAL:\n\t\t\tcase L2TP_AVP_PROXY_AUTH_RESP:\n\t\t\tcase L2TP_AVP_RANDOM_VECTOR:\n\t\t\t\tprint_octets(ndo, (const u_char *)ptr, len-6);\n\t\t\t\tbreak;\n\t\t\tcase L2TP_AVP_Q931_CC:\n \t\t\t\tl2tp_q931_cc_print(ndo, (const u_char *)ptr, len-6);\n \t\t\t\tbreak;\n \t\t\tcase L2TP_AVP_CHALLENGE_RESP:\n \t\t\t\tprint_octets(ndo, (const u_char *)ptr, 16);\n \t\t\t\tbreak;\n \t\t\tcase L2TP_AVP_CALL_SER_NUM:\n\t\t\tcase L2TP_AVP_MINIMUM_BPS:\n\t\t\tcase L2TP_AVP_MAXIMUM_BPS:\n \t\t\tcase L2TP_AVP_TX_CONN_SPEED:\n \t\t\tcase L2TP_AVP_PHY_CHANNEL_ID:\n \t\t\tcase L2TP_AVP_RX_CONN_SPEED:\n \t\t\t\tprint_32bits_val(ndo, (const uint32_t *)ptr);\n \t\t\t\tbreak;\n \t\t\tcase L2TP_AVP_BEARER_TYPE:\n\t\t\t\tl2tp_bearer_type_print(ndo, (const u_char *)ptr);\n \t\t\t\tbreak;\n \t\t\tcase L2TP_AVP_FRAMING_TYPE:\n\t\t\t\tl2tp_framing_type_print(ndo, (const u_char *)ptr);\n \t\t\t\tbreak;\n \t\t\tcase L2TP_AVP_PACKET_PROC_DELAY:\n \t\t\t\tl2tp_packet_proc_delay_print(ndo);\n \t\t\t\tbreak;\n \t\t\tcase L2TP_AVP_PROXY_AUTH_TYPE:\n\t\t\t\tl2tp_proxy_auth_type_print(ndo, (const u_char *)ptr);\n \t\t\t\tbreak;\n \t\t\tcase L2TP_AVP_PROXY_AUTH_ID:\n\t\t\t\tl2tp_proxy_auth_id_print(ndo, (const u_char *)ptr);\n \t\t\t\tbreak;\n \t\t\tcase L2TP_AVP_CALL_ERRORS:\n\t\t\t\tl2tp_call_errors_print(ndo, (const u_char *)ptr);\n \t\t\t\tbreak;\n \t\t\tcase L2TP_AVP_ACCM:\n\t\t\t\tl2tp_accm_print(ndo, (const u_char *)ptr);\n \t\t\t\tbreak;\n \t\t\tcase L2TP_AVP_SEQ_REQUIRED:\n \t\t\t\tbreak;\t/* No Attribute Value */\n\t\t\tcase L2TP_AVP_PPP_DISCON_CC:\n\t\t\t\tl2tp_ppp_discon_cc_print(ndo, (const u_char *)ptr, len-6);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tND_PRINT((ndo, \")\"));\n\t}\n\n\tl2tp_avp_print(ndo, dat+len, length-len);\n\treturn;\n\n trunc:\n\tND_PRINT((ndo, \"|...\"));\n}\n", "target": 1, "idx": 181062}
{"func": "static DetectTransaction GetDetectTx(const uint8_t ipproto, const AppProto alproto,\n        void *alstate, const uint64_t tx_id, void *tx_ptr, const int tx_end_state,\n        const uint8_t flow_flags)\n{\n    const uint64_t detect_flags = AppLayerParserGetTxDetectFlags(ipproto, alproto, tx_ptr, flow_flags);\n    if (detect_flags & APP_LAYER_TX_INSPECTED_FLAG) {\n        SCLogDebug(\"%\"PRIu64\" tx already fully inspected for %s. Flags %016\"PRIx64,\n                tx_id, flow_flags & STREAM_TOSERVER ? \"toserver\" : \"toclient\",\n                detect_flags);\n        DetectTransaction no_tx = { NULL, 0, NULL, 0, 0, 0, 0, 0, };\n        return no_tx;\n    }\n\n    const int tx_progress = AppLayerParserGetStateProgress(ipproto, alproto, tx_ptr, flow_flags);\n    const int dir_int = (flow_flags & STREAM_TOSERVER) ? 0 : 1;\n    DetectEngineState *tx_de_state = AppLayerParserGetTxDetectState(ipproto, alproto, tx_ptr);\n    DetectEngineStateDirection *tx_dir_state = tx_de_state ? &tx_de_state->dir_state[dir_int] : NULL;\n    uint64_t prefilter_flags = detect_flags & APP_LAYER_TX_PREFILTER_MASK;\n\n    DetectTransaction tx = {\n                            .tx_ptr = tx_ptr,\n                            .tx_id = tx_id,\n                            .de_state = tx_dir_state,\n                            .detect_flags = detect_flags,\n                            .prefilter_flags = prefilter_flags,\n                            .prefilter_flags_orig = prefilter_flags,\n                            .tx_progress = tx_progress,\n                            .tx_end_state = tx_end_state,\n                           };\n    return tx;\n}\n", "target": 0, "idx": 87013}
{"func": "std::wstring GetChromeChannelName() {\n  return InstallDetails::Get().channel();\n}\n", "target": 0, "idx": 165644}
{"func": " static void prefetch_dec(void)\n {\n   prefetch_table((const void *)&dec_tables, sizeof(dec_tables));\n }\n", "target": 1, "idx": 183385}
{"func": "static const char *set_async_filter(cmd_parms *cmd, void *dummy,\n                                             const char *arg)\n{\n    core_server_config *conf =\n    ap_get_core_module_config(cmd->server->module_config);\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);\n\n    if (err) {\n        return err;\n    }\n\n    if (ap_cstr_casecmp(arg, \"network\") == 0) {\n        conf->async_filter = AP_FTYPE_NETWORK;\n    }\n    else if (ap_cstr_casecmp(arg, \"connection\") == 0) {\n        conf->async_filter = AP_FTYPE_CONNECTION;\n    }\n    else if (ap_cstr_casecmp(arg, \"request\") == 0) {\n        conf->async_filter = 0;\n    }\n    else {\n        return \"AsyncFilter must be 'network', 'connection' or 'request'\";\n    }\n    conf->async_filter_set = 1;\n\n    return NULL;\n}\n", "target": 0, "idx": 64269}
{"func": "TabAppendedNotificationObserver::TabAppendedNotificationObserver(\n    Browser* parent,\n    AutomationProvider* automation,\n    IPC::Message* reply_message,\n    bool use_json_interface)\n    : TabStripNotificationObserver(chrome::NOTIFICATION_TAB_PARENTED,\n                                   automation),\n      parent_(parent),\n      reply_message_(reply_message),\n      use_json_interface_(use_json_interface) {\n}\n", "target": 0, "idx": 126053}
{"func": " Node::InsertionNotificationRequest HTMLBodyElement::insertedInto(ContainerNode* insertionPoint)\n {\n     HTMLElement::insertedInto(insertionPoint);\n    if (insertionPoint->inDocument()) {\n        Element* ownerElement = document().ownerElement();\n        if (isHTMLFrameElementBase(ownerElement)) {\n            HTMLFrameElementBase& ownerFrameElement = toHTMLFrameElementBase(*ownerElement);\n            int marginWidth = ownerFrameElement.marginWidth();\n            if (marginWidth != -1)\n                setIntegralAttribute(marginwidthAttr, marginWidth);\n            int marginHeight = ownerFrameElement.marginHeight();\n            if (marginHeight != -1)\n                setIntegralAttribute(marginheightAttr, marginHeight);\n        }\n    }\n    return InsertionDone;\n }\n", "target": 1, "idx": 185426}
{"func": "static inline bool isChildTypeAllowed(ContainerNode* newParent, Node* child)\n{\n    if (!child->isDocumentFragment())\n        return newParent->childTypeAllowed(child->nodeType());\n\n    for (Node* node = child->firstChild(); node; node = node->nextSibling()) {\n        if (!newParent->childTypeAllowed(node->nodeType()))\n            return false;\n    }\n    return true;\n}\n", "target": 0, "idx": 118768}
{"func": "XineramaXvShmPutImage(ClientPtr client)\n {\n     REQUEST(xvShmPutImageReq);\n     PanoramiXRes *draw, *gc, *port;\n    Bool send_event = stuff->send_event;\n     Bool isRoot;\n     int result, i, x, y;\n \n     REQUEST_SIZE_MATCH(xvShmPutImageReq);\n \n     result = dixLookupResourceByClass((void **) &draw, stuff->drawable,\n                                       XRC_DRAWABLE, client, DixWriteAccess);\n     if (result != Success)\n    result = dixLookupResourceByType((void **) &gc, stuff->gc,\n                                     XRT_GC, client, DixReadAccess);\n    if (result != Success)\n        return result;\n\n    result = dixLookupResourceByType((void **) &port, stuff->port,\n                                     XvXRTPort, client, DixReadAccess);\n    if (result != Success)\n        return result;\n\n    isRoot = (draw->type == XRT_WINDOW) && draw->u.win.root;\n\n    x = stuff->drw_x;\n    y = stuff->drw_y;\n\n    FOR_NSCREENS_BACKWARD(i) {\n        if (port->info[i].id) {\n            stuff->drawable = draw->info[i].id;\n            stuff->port = port->info[i].id;\n            stuff->gc = gc->info[i].id;\n            stuff->drw_x = x;\n            stuff->drw_y = y;\n            if (isRoot) {\n                stuff->drw_x -= screenInfo.screens[i]->x;\n                stuff->drw_y -= screenInfo.screens[i]->y;\n            }\n            stuff->send_event = (send_event && !i) ? 1 : 0;\n\n            result = ProcXvShmPutImage(client);\n        }\n    }\n    return result;\n}\n", "target": 1, "idx": 178608}
{"func": "  void Dispose() {\n    raw_data_ = nullptr;\n    delete this;\n  }\n", "target": 0, "idx": 151176}
{"func": "static enum test_return test_binary_replaceq(void) {\n    return test_binary_replace_impl(\"test_binary_replaceq\",\n                                    PROTOCOL_BINARY_CMD_REPLACEQ);\n}\n", "target": 0, "idx": 94276}
{"func": "ProfileKeyedAPIFactory<BookmarksAPI>* BookmarksAPI::GetFactoryInstance() {\n  return &g_factory.Get();\n}\n", "target": 0, "idx": 124035}
{"func": "void RenderView::OnFillPasswordForm(\n    const webkit_glue::PasswordFormFillData& form_data) {\n#if defined(WEBKIT_BUG_41283_IS_FIXED)\n  password_autocomplete_manager_.ReceivedPasswordFormFillData(webview(),\n                                                              form_data);\n#else\n  webkit_glue::FillPasswordForm(this->webview(), form_data);\n#endif\n}\n", "target": 0, "idx": 97954}
{"func": "bool OmniboxViewViews::IsImeShowingPopup() const {\n#if defined(OS_CHROMEOS)\n  return ime_candidate_window_open_;\n#else\n  const views::InputMethod* input_method = this->GetInputMethod();\n  return input_method && input_method->IsCandidatePopupOpen();\n#endif\n}\n", "target": 0, "idx": 134267}
{"func": "void sco_connect_cfm(struct hci_conn *hcon, __u8 status)\n{\n\tBT_DBG(\"hcon %p bdaddr %pMR status %d\", hcon, &hcon->dst, status);\n\tif (!status) {\n\t\tstruct sco_conn *conn;\n\n\t\tconn = sco_conn_add(hcon);\n\t\tif (conn)\n\t\t\tsco_conn_ready(conn);\n\t} else\n\t\tsco_conn_del(hcon, bt_to_errno(status));\n}\n", "target": 0, "idx": 30702}
{"func": "static int decode_v2_header(struct iwbmprcontext *rctx, const iw_byte *buf)\n{\n\tunsigned int nplanes;\n\n\trctx->width = iw_get_ui16le(&buf[4]);\n\trctx->height = iw_get_ui16le(&buf[6]);\n\tnplanes = iw_get_ui16le(&buf[8]);\n\tif(nplanes!=1) return 0;\n\trctx->bitcount = iw_get_ui16le(&buf[10]);\n\tif(rctx->bitcount!=1 && rctx->bitcount!=4 &&\n\t\trctx->bitcount!=8 && rctx->bitcount!=24)\n\t{\n\t\treturn 0;\n\t}\n\tif(rctx->bitcount<=8) {\n\t\tsize_t palette_start, palette_end;\n\n\t\trctx->palette_entries = 1<<rctx->bitcount;\n\t\trctx->palette_nbytes = 3*rctx->palette_entries;\n\n\t\tpalette_start = rctx->fileheader_size + rctx->infoheader_size;\n\t\tpalette_end = palette_start + rctx->palette_nbytes;\n\t\tif(rctx->bfOffBits >= palette_start+3 && rctx->bfOffBits < palette_end) {\n\t\t\trctx->palette_entries = (unsigned int)((rctx->bfOffBits - palette_start)/3);\n\t\t\trctx->palette_nbytes = 3*rctx->palette_entries;\n\t\t}\n\t}\n\treturn 1;\n}\n", "target": 0, "idx": 64853}
{"func": "  ft_smooth_render_generic( FT_Renderer       render,\n                            FT_GlyphSlot      slot,\n                            FT_Render_Mode    mode,\n                            const FT_Vector*  origin,\n                            FT_Render_Mode    required_mode )\n  {\n    FT_Error     error;\n    FT_Outline*  outline = NULL;\n    FT_BBox      cbox;\n    FT_UInt      width, height, height_org, width_org, pitch;\n    FT_Bitmap*   bitmap;\n    FT_Memory    memory;\n    FT_Int       hmul = mode == FT_RENDER_MODE_LCD;\n    FT_Int       vmul = mode == FT_RENDER_MODE_LCD_V;\n    FT_Pos       x_shift, y_shift, x_left, y_top;\n\n    FT_Raster_Params  params;\n\n\n    /* check glyph image format */\n    if ( slot->format != render->glyph_format )\n    {\n      error = Smooth_Err_Invalid_Argument;\n      goto Exit;\n    }\n\n    /* check mode */\n    if ( mode != required_mode )\n      return Smooth_Err_Cannot_Render_Glyph;\n\n    outline = &slot->outline;\n\n    /* translate the outline to the new origin if needed */\n    if ( origin )\n      FT_Outline_Translate( outline, origin->x, origin->y );\n\n    /* compute the control box, and grid fit it */\n    FT_Outline_Get_CBox( outline, &cbox );\n\n    cbox.xMin = FT_PIX_FLOOR( cbox.xMin );\n    cbox.yMin = FT_PIX_FLOOR( cbox.yMin );\n    cbox.xMax = FT_PIX_CEIL( cbox.xMax );\n    cbox.yMax = FT_PIX_CEIL( cbox.yMax );\n\n    width  = (FT_UInt)( ( cbox.xMax - cbox.xMin ) >> 6 );\n    height = (FT_UInt)( ( cbox.yMax - cbox.yMin ) >> 6 );\n    bitmap = &slot->bitmap;\n    memory = render->root.memory;\n\n    width_org  = width;\n    height_org = height;\n\n    /* release old bitmap buffer */\n    if ( slot->internal->flags & FT_GLYPH_OWN_BITMAP )\n    {\n      FT_FREE( bitmap->buffer );\n      slot->internal->flags &= ~FT_GLYPH_OWN_BITMAP;\n    }\n\n    /* allocate new one */\n    pitch = width;\n    if ( hmul )\n    {\n      width = width * 3;\n      pitch = FT_PAD_CEIL( width, 4 );\n    }\n\n    if ( vmul )\n      height *= 3;\n\n    x_shift = (FT_Int) cbox.xMin;\n    y_shift = (FT_Int) cbox.yMin;\n    x_left  = (FT_Int)( cbox.xMin >> 6 );\n    y_top   = (FT_Int)( cbox.yMax >> 6 );\n\n#ifdef FT_CONFIG_OPTION_SUBPIXEL_RENDERING\n\n    if ( slot->library->lcd_filter_func )\n    {\n      FT_Int  extra = slot->library->lcd_extra;\n\n\n      if ( hmul )\n      {\n        x_shift -= 64 * ( extra >> 1 );\n        width   += 3 * extra;\n        pitch    = FT_PAD_CEIL( width, 4 );\n        x_left  -= extra >> 1;\n      }\n\n      if ( vmul )\n      {\n        y_shift -= 64 * ( extra >> 1 );\n        height  += 3 * extra;\n        y_top   += extra >> 1;\n      }\n    }\n\n#endif\n\n#if FT_UINT_MAX > 0xFFFFU\n \n     /* Required check is ( pitch * height < FT_ULONG_MAX ),     */\n     /* but we care realistic cases only. Always pitch <= width. */\n    if ( width > 0xFFFFU || height > 0xFFFFU )\n     {\n       FT_ERROR(( \"ft_smooth_render_generic: glyph too large: %d x %d\\n\",\n                  width, height ));\n      return Smooth_Err_Raster_Overflow;\n    }\n\n#endif\n\n    bitmap->pixel_mode = FT_PIXEL_MODE_GRAY;\n    bitmap->num_grays  = 256;\n    bitmap->width      = width;\n    bitmap->rows       = height;\n    bitmap->pitch      = pitch;\n\n    /* translate outline to render it into the bitmap */\n    FT_Outline_Translate( outline, -x_shift, -y_shift );\n\n    if ( FT_ALLOC( bitmap->buffer, (FT_ULong)pitch * height ) )\n      goto Exit;\n\n    slot->internal->flags |= FT_GLYPH_OWN_BITMAP;\n\n    /* set up parameters */\n    params.target = bitmap;\n    params.source = outline;\n    params.flags  = FT_RASTER_FLAG_AA;\n\n#ifdef FT_CONFIG_OPTION_SUBPIXEL_RENDERING\n\n    /* implode outline if needed */\n    {\n      FT_Vector*  points     = outline->points;\n      FT_Vector*  points_end = points + outline->n_points;\n      FT_Vector*  vec;\n\n\n      if ( hmul )\n        for ( vec = points; vec < points_end; vec++ )\n          vec->x *= 3;\n\n      if ( vmul )\n        for ( vec = points; vec < points_end; vec++ )\n          vec->y *= 3;\n    }\n\n    /* render outline into the bitmap */\n    error = render->raster_render( render->raster, &params );\n\n    /* deflate outline if needed */\n    {\n      FT_Vector*  points     = outline->points;\n      FT_Vector*  points_end = points + outline->n_points;\n      FT_Vector*  vec;\n\n\n      if ( hmul )\n        for ( vec = points; vec < points_end; vec++ )\n          vec->x /= 3;\n\n      if ( vmul )\n        for ( vec = points; vec < points_end; vec++ )\n          vec->y /= 3;\n    }\n\n    if ( slot->library->lcd_filter_func )\n      slot->library->lcd_filter_func( bitmap, mode, slot->library );\n\n#else /* !FT_CONFIG_OPTION_SUBPIXEL_RENDERING */\n\n    /* render outline into bitmap */\n    error = render->raster_render( render->raster, &params );\n\n    /* expand it horizontally */\n    if ( hmul )\n    {\n      FT_Byte*  line = bitmap->buffer;\n      FT_UInt   hh;\n\n\n      for ( hh = height_org; hh > 0; hh--, line += pitch )\n      {\n        FT_UInt   xx;\n        FT_Byte*  end = line + width;\n\n\n        for ( xx = width_org; xx > 0; xx-- )\n        {\n          FT_UInt  pixel = line[xx-1];\n\n\n          end[-3] = (FT_Byte)pixel;\n          end[-2] = (FT_Byte)pixel;\n          end[-1] = (FT_Byte)pixel;\n          end    -= 3;\n        }\n      }\n    }\n\n    /* expand it vertically */\n    if ( vmul )\n    {\n      FT_Byte*  read  = bitmap->buffer + ( height - height_org ) * pitch;\n      FT_Byte*  write = bitmap->buffer;\n      FT_UInt   hh;\n\n\n      for ( hh = height_org; hh > 0; hh-- )\n      {\n        ft_memcpy( write, read, pitch );\n        write += pitch;\n\n        ft_memcpy( write, read, pitch );\n        write += pitch;\n\n        ft_memcpy( write, read, pitch );\n        write += pitch;\n        read  += pitch;\n      }\n    }\n\n#endif /* !FT_CONFIG_OPTION_SUBPIXEL_RENDERING */\n\n    FT_Outline_Translate( outline, x_shift, y_shift );\n\n    /*\n     * XXX: on 16bit system, we return an error for huge bitmap\n     * to prevent an overflow.\n     */\n    if ( x_left > FT_INT_MAX || y_top > FT_INT_MAX )\n      return Smooth_Err_Invalid_Pixel_Size;\n\n    if ( error )\n      goto Exit;\n\n    slot->format      = FT_GLYPH_FORMAT_BITMAP;\n    slot->bitmap_left = (FT_Int)x_left;\n    slot->bitmap_top  = (FT_Int)y_top;\n\n  Exit:\n    if ( outline && origin )\n      FT_Outline_Translate( outline, -origin->x, -origin->y );\n\n    return error;\n  }\n", "target": 1, "idx": 178177}
{"func": "void ih264d_init_decoder(void * ps_dec_params)\n{\n dec_struct_t * ps_dec = (dec_struct_t *)ps_dec_params;\n dec_slice_params_t *ps_cur_slice;\n pocstruct_t *ps_prev_poc, *ps_cur_poc;\n    WORD32 size;\n\n    size = sizeof(pred_info_t) * 2 * 32;\n    memset(ps_dec->ps_pred, 0 , size);\n\n    size = sizeof(disp_mgr_t);\n    memset(ps_dec->pv_disp_buf_mgr, 0 , size);\n\n    size = sizeof(buf_mgr_t) + ithread_get_mutex_lock_size();\n    memset(ps_dec->pv_pic_buf_mgr, 0, size);\n\n    size = sizeof(dec_err_status_t);\n    memset(ps_dec->ps_dec_err_status, 0, size);\n\n    size = sizeof(sei);\n    memset(ps_dec->ps_sei, 0, size);\n\n    size = sizeof(dpb_commands_t);\n    memset(ps_dec->ps_dpb_cmds, 0, size);\n\n    size = sizeof(dec_bit_stream_t);\n    memset(ps_dec->ps_bitstrm, 0, size);\n\n    size = sizeof(dec_slice_params_t);\n    memset(ps_dec->ps_cur_slice, 0, size);\n\n    size = MAX(sizeof(dec_seq_params_t), sizeof(dec_pic_params_t));\n    memset(ps_dec->pv_scratch_sps_pps, 0, size);\n\n    size = sizeof(ctxt_inc_mb_info_t);\n    memset(ps_dec->ps_left_mb_ctxt_info, 0, size);\n\n    size = (sizeof(neighbouradd_t) << 2);\n    memset(ps_dec->ps_left_mvpred_addr, 0 ,size);\n\n    size = sizeof(buf_mgr_t) + ithread_get_mutex_lock_size();\n    memset(ps_dec->pv_mv_buf_mgr, 0, size);\n\n /* Free any dynamic buffers that are allocated */\n    ih264d_free_dynamic_bufs(ps_dec);\n\n    ps_cur_slice = ps_dec->ps_cur_slice;\n    ps_dec->init_done = 0;\n\n    ps_dec->u4_num_cores = 1;\n\n    ps_dec->u2_pic_ht = ps_dec->u2_pic_wd = 0;\n\n    ps_dec->u1_separate_parse = DEFAULT_SEPARATE_PARSE;\n    ps_dec->u4_app_disable_deblk_frm = 0;\n    ps_dec->i4_degrade_type = 0;\n    ps_dec->i4_degrade_pics = 0;\n\n    ps_dec->i4_app_skip_mode = IVD_SKIP_NONE;\n    ps_dec->i4_dec_skip_mode = IVD_SKIP_NONE;\n\n    memset(ps_dec->ps_pps, 0,\n ((sizeof(dec_pic_params_t)) * MAX_NUM_PIC_PARAMS));\n    memset(ps_dec->ps_sps, 0,\n ((sizeof(dec_seq_params_t)) * MAX_NUM_SEQ_PARAMS));\n\n /* Initialization of function pointers ih264d_deblock_picture function*/\n\n    ps_dec->p_DeblockPicture[0] = ih264d_deblock_picture_non_mbaff;\n    ps_dec->p_DeblockPicture[1] = ih264d_deblock_picture_mbaff;\n\n    ps_dec->s_cab_dec_env.pv_codec_handle = ps_dec;\n\n    ps_dec->u4_num_fld_in_frm = 0;\n\n    ps_dec->ps_dpb_mgr->pv_codec_handle = ps_dec;\n\n /* Initialize the sei validity u4_flag with zero indiacting sei is not valid*/\n    ps_dec->ps_sei->u1_is_valid = 0;\n\n /* decParams Initializations */\n    ps_dec->ps_cur_pps = NULL;\n    ps_dec->ps_cur_sps = NULL;\n    ps_dec->u1_init_dec_flag = 0;\n    ps_dec->u1_first_slice_in_stream = 1;\n    ps_dec->u1_first_pb_nal_in_pic = 1;\n    ps_dec->u1_last_pic_not_decoded = 0;\n    ps_dec->u4_app_disp_width = 0;\n    ps_dec->i4_header_decoded = 0;\n    ps_dec->u4_total_frames_decoded = 0;\n\n    ps_dec->i4_error_code = 0;\n    ps_dec->i4_content_type = -1;\n    ps_dec->ps_cur_slice->u1_mbaff_frame_flag = 0;\n\n    ps_dec->ps_dec_err_status->u1_err_flag = ACCEPT_ALL_PICS; //REJECT_PB_PICS;\n    ps_dec->ps_dec_err_status->u1_cur_pic_type = PIC_TYPE_UNKNOWN;\n    ps_dec->ps_dec_err_status->u4_frm_sei_sync = SYNC_FRM_DEFAULT;\n    ps_dec->ps_dec_err_status->u4_cur_frm = INIT_FRAME;\n    ps_dec->ps_dec_err_status->u1_pic_aud_i = PIC_TYPE_UNKNOWN;\n\n    ps_dec->u1_pr_sl_type = 0xFF;\n    ps_dec->u2_mbx = 0xffff;\n    ps_dec->u2_mby = 0;\n    ps_dec->u2_total_mbs_coded = 0;\n\n /* POC initializations */\n    ps_prev_poc = &ps_dec->s_prev_pic_poc;\n    ps_cur_poc = &ps_dec->s_cur_pic_poc;\n    ps_prev_poc->i4_pic_order_cnt_lsb = ps_cur_poc->i4_pic_order_cnt_lsb = 0;\n    ps_prev_poc->i4_pic_order_cnt_msb = ps_cur_poc->i4_pic_order_cnt_msb = 0;\n    ps_prev_poc->i4_delta_pic_order_cnt_bottom =\n                    ps_cur_poc->i4_delta_pic_order_cnt_bottom = 0;\n    ps_prev_poc->i4_delta_pic_order_cnt[0] =\n                    ps_cur_poc->i4_delta_pic_order_cnt[0] = 0;\n    ps_prev_poc->i4_delta_pic_order_cnt[1] =\n                    ps_cur_poc->i4_delta_pic_order_cnt[1] = 0;\n    ps_prev_poc->u1_mmco_equalto5 = ps_cur_poc->u1_mmco_equalto5 = 0;\n    ps_prev_poc->i4_top_field_order_count = ps_cur_poc->i4_top_field_order_count =\n 0;\n    ps_prev_poc->i4_bottom_field_order_count =\n                    ps_cur_poc->i4_bottom_field_order_count = 0;\n    ps_prev_poc->u1_bot_field = ps_cur_poc->u1_bot_field = 0;\n    ps_prev_poc->u1_mmco_equalto5 = ps_cur_poc->u1_mmco_equalto5 = 0;\n    ps_prev_poc->i4_prev_frame_num_ofst = ps_cur_poc->i4_prev_frame_num_ofst = 0;\n    ps_cur_slice->u1_mmco_equalto5 = 0;\n    ps_cur_slice->u2_frame_num = 0;\n\n    ps_dec->i4_max_poc = 0;\n    ps_dec->i4_prev_max_display_seq = 0;\n    ps_dec->u1_recon_mb_grp = 4;\n\n /* Field PIC initializations */\n    ps_dec->u1_second_field = 0;\n    ps_dec->s_prev_seq_params.u1_eoseq_pending = 0;\n\n /* Set the cropping parameters as zero */\n    ps_dec->u2_crop_offset_y = 0;\n    ps_dec->u2_crop_offset_uv = 0;\n\n /* The Initial Frame Rate Info is not Present */\n    ps_dec->i4_vui_frame_rate = -1;\n    ps_dec->i4_pic_type = -1;\n    ps_dec->i4_frametype = -1;\n    ps_dec->i4_content_type = -1;\n\n    ps_dec->u1_res_changed = 0;\n\n\n    ps_dec->u1_frame_decoded_flag = 0;\n\n /* Set the default frame seek mask mode */\n    ps_dec->u4_skip_frm_mask = SKIP_NONE;\n\n /********************************************************/\n /* Initialize CAVLC residual decoding function pointers */\n /********************************************************/\n    ps_dec->pf_cavlc_4x4res_block[0] = ih264d_cavlc_4x4res_block_totalcoeff_1;\n    ps_dec->pf_cavlc_4x4res_block[1] =\n                    ih264d_cavlc_4x4res_block_totalcoeff_2to10;\n    ps_dec->pf_cavlc_4x4res_block[2] =\n                    ih264d_cavlc_4x4res_block_totalcoeff_11to16;\n\n    ps_dec->pf_cavlc_parse4x4coeff[0] = ih264d_cavlc_parse4x4coeff_n0to7;\n    ps_dec->pf_cavlc_parse4x4coeff[1] = ih264d_cavlc_parse4x4coeff_n8;\n\n    ps_dec->pf_cavlc_parse_8x8block[0] =\n                    ih264d_cavlc_parse_8x8block_none_available;\n    ps_dec->pf_cavlc_parse_8x8block[1] =\n                    ih264d_cavlc_parse_8x8block_left_available;\n    ps_dec->pf_cavlc_parse_8x8block[2] =\n                    ih264d_cavlc_parse_8x8block_top_available;\n    ps_dec->pf_cavlc_parse_8x8block[3] =\n                    ih264d_cavlc_parse_8x8block_both_available;\n\n /***************************************************************************/\n /* Initialize Bs calculation function pointers for P and B, 16x16/non16x16 */\n /***************************************************************************/\n    ps_dec->pf_fill_bs1[0][0] = ih264d_fill_bs1_16x16mb_pslice;\n    ps_dec->pf_fill_bs1[0][1] = ih264d_fill_bs1_non16x16mb_pslice;\n\n    ps_dec->pf_fill_bs1[1][0] = ih264d_fill_bs1_16x16mb_bslice;\n    ps_dec->pf_fill_bs1[1][1] = ih264d_fill_bs1_non16x16mb_bslice;\n\n    ps_dec->pf_fill_bs_xtra_left_edge[0] =\n                    ih264d_fill_bs_xtra_left_edge_cur_frm;\n    ps_dec->pf_fill_bs_xtra_left_edge[1] =\n                    ih264d_fill_bs_xtra_left_edge_cur_fld;\n\n /* Initialize Reference Pic Buffers */\n    ih264d_init_ref_bufs(ps_dec->ps_dpb_mgr);\n\n    ps_dec->u2_prv_frame_num = 0;\n    ps_dec->u1_top_bottom_decoded = 0;\n    ps_dec->u1_dangling_field = 0;\n\n    ps_dec->s_cab_dec_env.cabac_table = gau4_ih264d_cabac_table;\n\n    ps_dec->pu1_left_mv_ctxt_inc = ps_dec->u1_left_mv_ctxt_inc_arr[0];\n    ps_dec->pi1_left_ref_idx_ctxt_inc =\n &ps_dec->i1_left_ref_idx_ctx_inc_arr[0][0];\n    ps_dec->pu1_left_yuv_dc_csbp = &ps_dec->u1_yuv_dc_csbp_topmb;\n\n /* ! */\n /* Initializing flush frame u4_flag */\n    ps_dec->u1_flushfrm = 0;\n\n {\n        ps_dec->s_cab_dec_env.pv_codec_handle = (void*)ps_dec;\n        ps_dec->ps_bitstrm->pv_codec_handle = (void*)ps_dec;\n        ps_dec->ps_cur_slice->pv_codec_handle = (void*)ps_dec;\n        ps_dec->ps_dpb_mgr->pv_codec_handle = (void*)ps_dec;\n }\n\n    memset(ps_dec->disp_bufs, 0, (MAX_DISP_BUFS_NEW) * sizeof(disp_buf_t));\n    memset(ps_dec->u4_disp_buf_mapping, 0,\n\n            (MAX_DISP_BUFS_NEW) * sizeof(UWORD32));\n     memset(ps_dec->u4_disp_buf_to_be_freed, 0,\n            (MAX_DISP_BUFS_NEW) * sizeof(UWORD32));\n \n     ih264d_init_arch(ps_dec);\n     ih264d_init_function_ptr(ps_dec);\n    ps_dec->e_frm_out_mode = IVD_DISPLAY_FRAME_OUT;\n    ps_dec->init_done = 1;\n\n}\n", "target": 1, "idx": 187782}
{"func": "int dev_close(struct net_device *dev)\n{\n\tif (!(dev->flags & IFF_UP))\n\t\treturn 0;\n\n\t__dev_close(dev);\n\n\t/*\n\t * Tell people we are down\n\t */\n\trtmsg_ifinfo(RTM_NEWLINK, dev, IFF_UP|IFF_RUNNING);\n\tcall_netdevice_notifiers(NETDEV_DOWN, dev);\n\n\treturn 0;\n}\n", "target": 0, "idx": 32103}
{"func": "int SSLClientSocketOpenSSL::GetLocalAddress(IPEndPoint* addressList) const {\n  return transport_->socket()->GetLocalAddress(addressList);\n}\n", "target": 0, "idx": 133759}
{"func": "void ExtensionPrefs::SetExtensionPrefPermissionSet(\n    const std::string& extension_id,\n    const std::string& pref_key,\n    const ExtensionPermissionSet* new_value) {\n  ListValue* api_values = new ListValue();\n  ExtensionAPIPermissionSet apis = new_value->apis();\n  ExtensionPermissionsInfo* info = ExtensionPermissionsInfo::GetInstance();\n  std::string api_pref = JoinPrefs(pref_key, kPrefAPIs);\n  for (ExtensionAPIPermissionSet::const_iterator i = apis.begin();\n       i != apis.end(); ++i) {\n    ExtensionAPIPermission* perm = info->GetByID(*i);\n    if (perm)\n      api_values->Append(Value::CreateStringValue(perm->name()));\n  }\n  UpdateExtensionPref(extension_id, api_pref, api_values);\n\n  if (!new_value->explicit_hosts().is_empty()) {\n    SetExtensionPrefURLPatternSet(extension_id,\n                                  JoinPrefs(pref_key, kPrefExplicitHosts),\n                                  new_value->explicit_hosts());\n  }\n\n  if (!new_value->scriptable_hosts().is_empty()) {\n    SetExtensionPrefURLPatternSet(extension_id,\n                                  JoinPrefs(pref_key, kPrefScriptableHosts),\n                                  new_value->scriptable_hosts());\n  }\n}\n", "target": 0, "idx": 102327}
{"func": "void FrameSelection::MoveRangeSelectionExtent(const IntPoint& contents_point) {\n  if (ComputeVisibleSelectionInDOMTree().IsNone())\n    return;\n\n   SetSelection(\n       SelectionInDOMTree::Builder(\n           GetGranularityStrategy()->UpdateExtent(contents_point, frame_))\n          .SetIsHandleVisible(true)\n           .Build(),\n       SetSelectionData::Builder()\n           .SetShouldCloseTyping(true)\n           .SetShouldClearTypingStyle(true)\n           .SetDoNotClearStrategy(true)\n           .SetSetSelectionBy(SetSelectionBy::kUser)\n           .Build());\n }\n", "target": 1, "idx": 185635}
{"func": "static inline unsigned long hash_name(const char *name, unsigned int *hashp)\n{\n\tunsigned long hash = init_name_hash();\n\tunsigned long len = 0, c;\n\n\tc = (unsigned char)*name;\n\tdo {\n\t\tlen++;\n\t\thash = partial_name_hash(c, hash);\n\t\tc = (unsigned char)name[len];\n\t} while (c && c != '/');\n\t*hashp = end_name_hash(hash);\n\treturn len;\n}\n", "target": 0, "idx": 36329}
{"func": "void* sspi_SecureHandleGetLowerPointer(SecHandle* handle)\n {\n \tvoid* pointer;\n \n\tif (!handle)\n \t\treturn NULL;\n \n \tpointer = (void*) ~((size_t) handle->dwLower);\n\n\treturn pointer;\n}\n", "target": 1, "idx": 180776}
{"func": "InputImeEventRouter* GetInputImeEventRouter(Profile* profile) {\n   if (!profile)\n     return nullptr;\n   return extensions::InputImeEventRouterFactory::GetInstance()->GetRouter(\n      profile->GetOriginalProfile());\n }\n", "target": 1, "idx": 186623}
{"func": "int URI_FUNC(ComposeQueryEngine)(URI_CHAR * dest,\n\t\tconst URI_TYPE(QueryList) * queryList,\n\t\tint maxChars, int * charsWritten, int * charsRequired,\n\t\tUriBool spaceToPlus, UriBool normalizeBreaks) {\n\tUriBool firstItem = URI_TRUE;\n\tint ampersandLen = 0;  /* increased to 1 from second item on */\n\tURI_CHAR * write = dest;\n\n\t/* Subtract terminator */\n\tif (dest == NULL) {\n\t\t*charsRequired = 0;\n\t} else {\n\t\tmaxChars--;\n\t}\n\t\t\t\n\twhile (queryList != NULL) {\n\t\tconst URI_CHAR * const key = queryList->key;\n\t\tconst URI_CHAR * const value = queryList->value;\n\t\tconst int worstCase = (normalizeBreaks == URI_TRUE ? 6 : 3);\n\t\tconst int keyLen = (key == NULL) ? 0 : (int)URI_STRLEN(key);\n\t\tconst int keyRequiredChars = worstCase * keyLen;\n\t\tconst int valueLen = (value == NULL) ? 0 : (int)URI_STRLEN(value);\n\t\tconst int valueRequiredChars = worstCase * valueLen;\n\n\t\tif (dest == NULL) {\n\t\t\tif (firstItem == URI_TRUE) {\n\t\t\t\tampersandLen = 1;\n\t\t\t\tfirstItem = URI_FALSE;\n\t\t\t}\n\n\t\t\t(*charsRequired) += ampersandLen + keyRequiredChars + ((value == NULL)\n\t\t\t\t\t\t? 0\n\t\t\t\t\t\t: 1 + valueRequiredChars);\n\t\t} else {\n\t\t\tURI_CHAR * afterKey;\n\n\t\t\tif ((write - dest) + ampersandLen + keyRequiredChars > maxChars) {\n\t\t\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;\n\t\t\t}\n \n \t\t\t/* Copy key */\n \t\t\tif (firstItem == URI_TRUE) {\n \t\t\t\tfirstItem = URI_FALSE;\n \t\t\t} else {\n \t\t\t\twrite[0] = _UT('&');\n\t\t\t\twrite++;\n\t\t\t}\n\t\t\tafterKey = URI_FUNC(EscapeEx)(key, key + keyLen,\n\t\t\t\t\twrite, spaceToPlus, normalizeBreaks);\n\t\t\twrite += (afterKey - write);\n\n\t\t\tif (value != NULL) {\n\t\t\t\tURI_CHAR * afterValue;\n\n\t\t\t\tif ((write - dest) + 1 + valueRequiredChars > maxChars) {\n\t\t\t\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;\n\t\t\t\t}\n\n\t\t\t\t/* Copy value */\n\t\t\t\twrite[0] = _UT('=');\n\t\t\t\twrite++;\n\t\t\t\tafterValue = URI_FUNC(EscapeEx)(value, value + valueLen,\n\t\t\t\t\t\twrite, spaceToPlus, normalizeBreaks);\n\t\t\t\twrite += (afterValue - write);\n\t\t\t}\n\t\t}\n\n\t\tqueryList = queryList->next;\n\t}\n\n\tif (dest != NULL) {\n\t\twrite[0] = _UT('\\0');\n\t\tif (charsWritten != NULL) {\n\t\t\t*charsWritten = (int)(write - dest) + 1; /* .. for terminator */\n\t\t}\n\t}\n\n\treturn URI_SUCCESS;\n}\n", "target": 1, "idx": 182148}
{"func": "static int parse_token(char **name, char **value, char **cp)\n{\n\tchar *end;\n\n\tif (!name || !value || !cp)\n\t\treturn -BLKID_ERR_PARAM;\n\n\tif (!(*value = strchr(*cp, '=')))\n\t\treturn 0;\n\n\t**value = '\\0';\n\t*name = strip_line(*cp);\n \t*value = skip_over_blank(*value + 1);\n \n \tif (**value == '\"') {\n\t\tend = strchr(*value + 1, '\"');\n\t\tif (!end) {\n \t\t\tDBG(READ, ul_debug(\"unbalanced quotes at: %s\", *value));\n \t\t\t*cp = *value;\n \t\t\treturn -BLKID_ERR_CACHE;\n \t\t}\n \t\t(*value)++;\n \t\t*end = '\\0';\n\t\tend++;\n \t} else {\n \t\tend = skip_over_word(*value);\n \t\tif (*end) {\n\t\t\t*end = '\\0';\n\t\t\tend++;\n\t\t}\n\t}\n\t*cp = end;\n\n\treturn 1;\n}\n", "target": 1, "idx": 182081}
{"func": "  cff_decoder_init( CFF_Decoder*    decoder,\n                    TT_Face         face,\n                    CFF_Size        size,\n                    CFF_GlyphSlot   slot,\n                    FT_Bool         hinting,\n                    FT_Render_Mode  hint_mode )\n  {\n    CFF_Font  cff = (CFF_Font)face->extra.data;\n\n\n    /* clear everything */\n    FT_MEM_ZERO( decoder, sizeof ( *decoder ) );\n\n    /* initialize builder */\n    cff_builder_init( &decoder->builder, face, size, slot, hinting );\n\n    /* initialize Type2 decoder */\n    decoder->cff          = cff;\n    decoder->num_globals  = cff->global_subrs_index.count;\n    decoder->globals      = cff->global_subrs;\n    decoder->globals_bias = cff_compute_bias(\n                              cff->top_font.font_dict.charstring_type,\n                              decoder->num_globals );\n\n    decoder->hint_mode    = hint_mode;\n  }\n", "target": 0, "idx": 10356}
{"func": "void NetworkThrottleManagerImpl::RecomputeOutstanding() {\n  base::TimeTicks now(tick_clock_->NowTicks());\n  base::TimeDelta age_horizon(base::TimeDelta::FromMilliseconds((\n      kMedianLifetimeMultiple * lifetime_median_estimate_.current_estimate())));\n  while (!outstanding_throttles_.empty()) {\n    ThrottleImpl* throttle = *outstanding_throttles_.begin();\n    if (throttle->start_time() + age_horizon >= now)\n      break;\n\n    outstanding_throttles_.erase(outstanding_throttles_.begin());\n    throttle->SetAged();\n    throttle->set_queue_pointer(outstanding_throttles_.end());\n  }\n\n  if (outstanding_throttles_.empty())\n    return;\n\n  if (outstanding_recomputation_timer_->IsRunning())\n    return;\n\n  ThrottleImpl* first_throttle(*outstanding_throttles_.begin());\n  DCHECK_GE(first_throttle->start_time() + age_horizon, now);\n\n  outstanding_recomputation_timer_->Start(\n      FROM_HERE,\n      ((first_throttle->start_time() + age_horizon) - now +\n       base::TimeDelta::FromMilliseconds(kTimerFudgeInMs)),\n      base::Bind(&NetworkThrottleManagerImpl::MaybeUnblockThrottles,\n                 base::Unretained(this)));\n}\n", "target": 0, "idx": 169485}
{"func": "static inline bool shouldSetStrutOnBlock(const LayoutBlockFlow& block, const RootInlineBox& lineBox, LayoutUnit lineLogicalOffset, int lineIndex, LayoutUnit remainingLogicalHeight)\n{\n    bool wantsStrutOnBlock = false;\n    if (!block.style()->hasAutoOrphans() && block.style()->orphans() >= lineIndex) {\n        wantsStrutOnBlock = true;\n    } else if (lineBox == block.firstRootBox() && lineLogicalOffset == block.borderAndPaddingBefore()) {\n        LayoutUnit lineHeight = lineBox.lineBottomWithLeading() - lineBox.lineTopWithLeading();\n        LayoutUnit totalLogicalHeight = lineHeight + std::max<LayoutUnit>(0, lineLogicalOffset);\n        LayoutUnit pageLogicalHeightAtNewOffset = block.pageLogicalHeightForOffset(lineLogicalOffset + remainingLogicalHeight);\n         if (totalLogicalHeight < pageLogicalHeightAtNewOffset)\n             wantsStrutOnBlock = true;\n     }\n    if (!wantsStrutOnBlock || block.isOutOfFlowPositioned())\n        return false;\n    LayoutBlock* containingBlock = block.containingBlock();\n    return containingBlock && containingBlock->isLayoutBlockFlow();\n }\n", "target": 1, "idx": 185473}
{"func": "inf_gtk_certificate_manager_load_known_hosts(InfGtkCertificateManager* mgr,\n                                             GError** error)\n{\n  InfGtkCertificateManagerPrivate* priv;\n  GHashTable* table;\n  gchar* content;\n  gsize size;\n  GError* local_error;\n\n  gchar* out_buf;\n  gsize out_buf_len;\n  gchar* pos;\n  gchar* prev;\n  gchar* next;\n  gchar* sep;\n\n  gsize len;\n  gsize out_len;\n  gint base64_state;\n  guint base64_save;\n\n  gnutls_datum_t data;\n  gnutls_x509_crt_t cert;\n  int res;\n\n  priv = INF_GTK_CERTIFICATE_MANAGER_PRIVATE(mgr);\n\n  table = g_hash_table_new_full(\n    g_str_hash,\n    g_str_equal,\n    g_free,\n    (GDestroyNotify)gnutls_x509_crt_deinit\n  );\n\n  local_error = NULL;\n  g_file_get_contents(priv->known_hosts_file, &content, &size, &local_error);\n  if(local_error != NULL)\n  {\n    if(local_error->domain == G_FILE_ERROR &&\n       local_error->code == G_FILE_ERROR_NOENT)\n    {\n      return table;\n    }\n\n    g_propagate_prefixed_error(\n      error,\n      local_error,\n      _(\"Failed to open known hosts file \\\"%s\\\": \"),\n      priv->known_hosts_file\n    );\n\n    g_hash_table_destroy(table);\n    return NULL;\n  }\n\n  out_buf = NULL;\n  out_buf_len = 0;\n  prev = content;\n  for(prev = content; prev != NULL; prev = next)\n  {\n    pos = strchr(prev, '\\n');\n    next = NULL;\n\n    if(pos == NULL)\n      pos = content + size;\n    else\n      next = pos + 1;\n\n    sep = inf_gtk_certificate_manager_memrchr(prev, ':', pos - prev);\n    if(sep == NULL) continue; /* ignore line */\n\n    *sep = '\\0';\n    if(g_hash_table_lookup(table, prev) != NULL)\n    {\n      g_set_error(\n        error,\n        g_quark_from_static_string(\"INF_GTK_CERTIFICATE_MANAGER_ERROR\"),\n        INF_GTK_CERTIFICATE_MANAGER_ERROR_DUPLICATE_HOST_ENTRY,\n        _(\"Certificate for host \\\"%s\\\" appears twice in \"\n          \"known hosts file \\\"%s\\\"\"),\n        prev,\n        priv->known_hosts_file\n      );\n\n      g_hash_table_destroy(table);\n      g_free(out_buf);\n      g_free(content);\n      return NULL;\n    }\n\n    /* decode base64, import DER certificate */\n    len = (pos - (sep + 1));\n    out_len = len * 3 / 4;\n\n    if(out_len > out_buf_len)\n    {\n      out_buf = g_realloc(out_buf, out_len);\n      out_buf_len = out_len;\n    }\n\n    base64_state = 0;\n    base64_save = 0;\n\n    out_len = g_base64_decode_step(\n      sep + 1,\n      len,\n      out_buf,\n      &base64_state,\n      &base64_save\n    );\n\n    cert = NULL;\n    res = gnutls_x509_crt_init(&cert);\n    if(res == GNUTLS_E_SUCCESS)\n    {\n      data.data = out_buf;\n      data.size = out_len;\n      res = gnutls_x509_crt_import(cert, &data, GNUTLS_X509_FMT_DER);\n    }\n\n    if(res != GNUTLS_E_SUCCESS)\n    {\n      inf_gnutls_set_error(&local_error, res);\n\n      g_propagate_prefixed_error(\n        error,\n        local_error,\n        _(\"Failed to read certificate for host \\\"%s\\\" from \"\n          \"known hosts file \\\"%s\\\": \"),\n        prev,\n        priv->known_hosts_file\n      );\n\n      if(cert != NULL)\n        gnutls_x509_crt_deinit(cert);\n\n      g_hash_table_destroy(table);\n      g_free(out_buf);\n      g_free(content);\n      return NULL;\n    }\n\n    g_hash_table_insert(table, g_strdup(prev), cert);\n  }\n\n  g_free(out_buf);\n  g_free(content);\n  return table;\n}\n", "target": 0, "idx": 74327}
{"func": "pgm_print(netdissect_options *ndo,\n          register const u_char *bp, register u_int length,\n          register const u_char *bp2)\n{\n\tregister const struct pgm_header *pgm;\n\tregister const struct ip *ip;\n\tregister char ch;\n\tuint16_t sport, dport;\n\tu_int nla_afnum;\n\tchar nla_buf[INET6_ADDRSTRLEN];\n\tregister const struct ip6_hdr *ip6;\n\tuint8_t opt_type, opt_len;\n\tuint32_t seq, opts_len, len, offset;\n\n\tpgm = (const struct pgm_header *)bp;\n\tip = (const struct ip *)bp2;\n\tif (IP_V(ip) == 6)\n\t\tip6 = (const struct ip6_hdr *)bp2;\n\telse\n\t\tip6 = NULL;\n\tch = '\\0';\n\tif (!ND_TTEST(pgm->pgm_dport)) {\n\t\tif (ip6) {\n\t\t\tND_PRINT((ndo, \"%s > %s: [|pgm]\",\n\t\t\t\tip6addr_string(ndo, &ip6->ip6_src),\n\t\t\t\tip6addr_string(ndo, &ip6->ip6_dst)));\n\t\t\treturn;\n\t\t} else {\n\t\t\tND_PRINT((ndo, \"%s > %s: [|pgm]\",\n\t\t\t\tipaddr_string(ndo, &ip->ip_src),\n\t\t\t\tipaddr_string(ndo, &ip->ip_dst)));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tsport = EXTRACT_16BITS(&pgm->pgm_sport);\n\tdport = EXTRACT_16BITS(&pgm->pgm_dport);\n\n\tif (ip6) {\n\t\tif (ip6->ip6_nxt == IPPROTO_PGM) {\n\t\t\tND_PRINT((ndo, \"%s.%s > %s.%s: \",\n\t\t\t\tip6addr_string(ndo, &ip6->ip6_src),\n\t\t\t\ttcpport_string(ndo, sport),\n\t\t\t\tip6addr_string(ndo, &ip6->ip6_dst),\n\t\t\t\ttcpport_string(ndo, dport)));\n\t\t} else {\n\t\t\tND_PRINT((ndo, \"%s > %s: \",\n\t\t\t\ttcpport_string(ndo, sport), tcpport_string(ndo, dport)));\n\t\t}\n\t} else {\n\t\tif (ip->ip_p == IPPROTO_PGM) {\n\t\t\tND_PRINT((ndo, \"%s.%s > %s.%s: \",\n\t\t\t\tipaddr_string(ndo, &ip->ip_src),\n\t\t\t\ttcpport_string(ndo, sport),\n\t\t\t\tipaddr_string(ndo, &ip->ip_dst),\n\t\t\t\ttcpport_string(ndo, dport)));\n\t\t} else {\n\t\t\tND_PRINT((ndo, \"%s > %s: \",\n\t\t\t\ttcpport_string(ndo, sport), tcpport_string(ndo, dport)));\n\t\t}\n\t}\n\n\tND_TCHECK(*pgm);\n\n        ND_PRINT((ndo, \"PGM, length %u\", EXTRACT_16BITS(&pgm->pgm_length)));\n\n        if (!ndo->ndo_vflag)\n            return;\n\n\tND_PRINT((ndo, \" 0x%02x%02x%02x%02x%02x%02x \",\n\t\t     pgm->pgm_gsid[0],\n                     pgm->pgm_gsid[1],\n                     pgm->pgm_gsid[2],\n\t\t     pgm->pgm_gsid[3],\n                     pgm->pgm_gsid[4],\n                     pgm->pgm_gsid[5]));\n\tswitch (pgm->pgm_type) {\n\tcase PGM_SPM: {\n\t    const struct pgm_spm *spm;\n\n\t    spm = (const struct pgm_spm *)(pgm + 1);\n\t    ND_TCHECK(*spm);\n\t    bp = (const u_char *) (spm + 1);\n\n\t    switch (EXTRACT_16BITS(&spm->pgms_nla_afi)) {\n\t    case AFNUM_INET:\n\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n\t\taddrtostr(bp, nla_buf, sizeof(nla_buf));\n\t\tbp += sizeof(struct in_addr);\n\t\tbreak;\n\t    case AFNUM_INET6:\n\t\tND_TCHECK2(*bp, sizeof(struct in6_addr));\n\t\taddrtostr6(bp, nla_buf, sizeof(nla_buf));\n\t\tbp += sizeof(struct in6_addr);\n\t\tbreak;\n\t    default:\n\t\tgoto trunc;\n\t\tbreak;\n\t    }\n\n\t    ND_PRINT((ndo, \"SPM seq %u trail %u lead %u nla %s\",\n\t\t\t EXTRACT_32BITS(&spm->pgms_seq),\n                         EXTRACT_32BITS(&spm->pgms_trailseq),\n\t\t\t EXTRACT_32BITS(&spm->pgms_leadseq),\n                         nla_buf));\n\t    break;\n\t}\n\n\tcase PGM_POLL: {\n\t    const struct pgm_poll *poll_msg;\n\n\t    poll_msg = (const struct pgm_poll *)(pgm + 1);\n\t    ND_TCHECK(*poll_msg);\n\t    ND_PRINT((ndo, \"POLL seq %u round %u\",\n\t\t\t EXTRACT_32BITS(&poll_msg->pgmp_seq),\n                         EXTRACT_16BITS(&poll_msg->pgmp_round)));\n\t    bp = (const u_char *) (poll_msg + 1);\n\t    break;\n\t}\n\tcase PGM_POLR: {\n\t    const struct pgm_polr *polr;\n\t    uint32_t ivl, rnd, mask;\n\n\t    polr = (const struct pgm_polr *)(pgm + 1);\n\t    ND_TCHECK(*polr);\n\t    bp = (const u_char *) (polr + 1);\n\n\t    switch (EXTRACT_16BITS(&polr->pgmp_nla_afi)) {\n\t    case AFNUM_INET:\n\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n\t\taddrtostr(bp, nla_buf, sizeof(nla_buf));\n\t\tbp += sizeof(struct in_addr);\n\t\tbreak;\n\t    case AFNUM_INET6:\n\t\tND_TCHECK2(*bp, sizeof(struct in6_addr));\n\t\taddrtostr6(bp, nla_buf, sizeof(nla_buf));\n\t\tbp += sizeof(struct in6_addr);\n\t\tbreak;\n\t    default:\n\t\tgoto trunc;\n\t\tbreak;\n\t    }\n\n\t    ND_TCHECK2(*bp, sizeof(uint32_t));\n\t    ivl = EXTRACT_32BITS(bp);\n\t    bp += sizeof(uint32_t);\n\n\t    ND_TCHECK2(*bp, sizeof(uint32_t));\n\t    rnd = EXTRACT_32BITS(bp);\n\t    bp += sizeof(uint32_t);\n\n\t    ND_TCHECK2(*bp, sizeof(uint32_t));\n\t    mask = EXTRACT_32BITS(bp);\n\t    bp += sizeof(uint32_t);\n\n\t    ND_PRINT((ndo, \"POLR seq %u round %u nla %s ivl %u rnd 0x%08x \"\n\t\t\t \"mask 0x%08x\", EXTRACT_32BITS(&polr->pgmp_seq),\n\t\t\t EXTRACT_16BITS(&polr->pgmp_round), nla_buf, ivl, rnd, mask));\n\t    break;\n\t}\n\tcase PGM_ODATA: {\n\t    const struct pgm_data *odata;\n\n\t    odata = (const struct pgm_data *)(pgm + 1);\n\t    ND_TCHECK(*odata);\n\t    ND_PRINT((ndo, \"ODATA trail %u seq %u\",\n\t\t\t EXTRACT_32BITS(&odata->pgmd_trailseq),\n\t\t\t EXTRACT_32BITS(&odata->pgmd_seq)));\n\t    bp = (const u_char *) (odata + 1);\n\t    break;\n\t}\n\n\tcase PGM_RDATA: {\n\t    const struct pgm_data *rdata;\n\n\t    rdata = (const struct pgm_data *)(pgm + 1);\n\t    ND_TCHECK(*rdata);\n\t    ND_PRINT((ndo, \"RDATA trail %u seq %u\",\n\t\t\t EXTRACT_32BITS(&rdata->pgmd_trailseq),\n\t\t\t EXTRACT_32BITS(&rdata->pgmd_seq)));\n\t    bp = (const u_char *) (rdata + 1);\n\t    break;\n\t}\n\n\tcase PGM_NAK:\n\tcase PGM_NULLNAK:\n\tcase PGM_NCF: {\n\t    const struct pgm_nak *nak;\n\t    char source_buf[INET6_ADDRSTRLEN], group_buf[INET6_ADDRSTRLEN];\n\n\t    nak = (const struct pgm_nak *)(pgm + 1);\n\t    ND_TCHECK(*nak);\n\t    bp = (const u_char *) (nak + 1);\n\n\t    /*\n\t     * Skip past the source, saving info along the way\n\t     * and stopping if we don't have enough.\n\t     */\n\t    switch (EXTRACT_16BITS(&nak->pgmn_source_afi)) {\n\t    case AFNUM_INET:\n\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n\t\taddrtostr(bp, source_buf, sizeof(source_buf));\n\t\tbp += sizeof(struct in_addr);\n\t\tbreak;\n\t    case AFNUM_INET6:\n\t\tND_TCHECK2(*bp, sizeof(struct in6_addr));\n\t\taddrtostr6(bp, source_buf, sizeof(source_buf));\n\t\tbp += sizeof(struct in6_addr);\n\t\tbreak;\n\t    default:\n\t\tgoto trunc;\n\t\tbreak;\n\t    }\n\n\t    /*\n\t     * Skip past the group, saving info along the way\n\t     * and stopping if we don't have enough.\n\t     */\n\t    bp += (2 * sizeof(uint16_t));\n\t    switch (EXTRACT_16BITS(bp)) {\n\t    case AFNUM_INET:\n\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n\t\taddrtostr(bp, group_buf, sizeof(group_buf));\n\t\tbp += sizeof(struct in_addr);\n\t\tbreak;\n\t    case AFNUM_INET6:\n\t\tND_TCHECK2(*bp, sizeof(struct in6_addr));\n\t\taddrtostr6(bp, group_buf, sizeof(group_buf));\n\t\tbp += sizeof(struct in6_addr);\n\t\tbreak;\n\t    default:\n\t\tgoto trunc;\n\t\tbreak;\n\t    }\n\n\t    /*\n\t     * Options decoding can go here.\n\t     */\n\t    switch (pgm->pgm_type) {\n\t\tcase PGM_NAK:\n\t\t    ND_PRINT((ndo, \"NAK \"));\n\t\t    break;\n\t\tcase PGM_NULLNAK:\n\t\t    ND_PRINT((ndo, \"NNAK \"));\n\t\t    break;\n\t\tcase PGM_NCF:\n\t\t    ND_PRINT((ndo, \"NCF \"));\n\t\t    break;\n\t\tdefault:\n                    break;\n\t    }\n\t    ND_PRINT((ndo, \"(%s -> %s), seq %u\",\n\t\t\t source_buf, group_buf, EXTRACT_32BITS(&nak->pgmn_seq)));\n\t    break;\n\t}\n\n\tcase PGM_ACK: {\n\t    const struct pgm_ack *ack;\n\n\t    ack = (const struct pgm_ack *)(pgm + 1);\n\t    ND_TCHECK(*ack);\n\t    ND_PRINT((ndo, \"ACK seq %u\",\n\t\t\t EXTRACT_32BITS(&ack->pgma_rx_max_seq)));\n\t    bp = (const u_char *) (ack + 1);\n\t    break;\n\t}\n\n\tcase PGM_SPMR:\n\t    ND_PRINT((ndo, \"SPMR\"));\n\t    break;\n\n\tdefault:\n\t    ND_PRINT((ndo, \"UNKNOWN type 0x%02x\", pgm->pgm_type));\n\t    break;\n\n\t}\n\tif (pgm->pgm_options & PGM_OPT_BIT_PRESENT) {\n\n\t    /*\n\t     * make sure there's enough for the first option header\n\t     */\n\t    if (!ND_TTEST2(*bp, PGM_MIN_OPT_LEN)) {\n\t\tND_PRINT((ndo, \"[|OPT]\"));\n\t\treturn;\n\t    }\n\n\t    /*\n\t     * That option header MUST be an OPT_LENGTH option\n\t     * (see the first paragraph of section 9.1 in RFC 3208).\n\t     */\n\t    opt_type = *bp++;\n\t    if ((opt_type & PGM_OPT_MASK) != PGM_OPT_LENGTH) {\n\t\tND_PRINT((ndo, \"[First option bad, should be PGM_OPT_LENGTH, is %u]\", opt_type & PGM_OPT_MASK));\n\t\treturn;\n\t    }\n\t    opt_len = *bp++;\n\t    if (opt_len != 4) {\n\t\tND_PRINT((ndo, \"[Bad OPT_LENGTH option, length %u != 4]\", opt_len));\n\t\treturn;\n\t    }\n\t    opts_len = EXTRACT_16BITS(bp);\n\t    if (opts_len < 4) {\n\t\tND_PRINT((ndo, \"[Bad total option length %u < 4]\", opts_len));\n\t\treturn;\n\t    }\n\t    bp += sizeof(uint16_t);\n\t    ND_PRINT((ndo, \" OPTS LEN %d\", opts_len));\n\t    opts_len -= 4;\n\n\t    while (opts_len) {\n\t\tif (opts_len < PGM_MIN_OPT_LEN) {\n\t\t    ND_PRINT((ndo, \"[Total option length leaves no room for final option]\"));\n\t\t    return;\n\t\t}\n\t\tif (!ND_TTEST2(*bp, 2)) {\n\t\t    ND_PRINT((ndo, \" [|OPT]\"));\n\t\t    return;\n\t\t}\n\t\topt_type = *bp++;\n\t\topt_len = *bp++;\n\t\tif (opt_len < PGM_MIN_OPT_LEN) {\n\t\t    ND_PRINT((ndo, \"[Bad option, length %u < %u]\", opt_len,\n\t\t        PGM_MIN_OPT_LEN));\n\t\t    break;\n\t\t}\n\t\tif (opts_len < opt_len) {\n\t\t    ND_PRINT((ndo, \"[Total option length leaves no room for final option]\"));\n\t\t    return;\n\t\t}\n\t\tif (!ND_TTEST2(*bp, opt_len - 2)) {\n\t\t    ND_PRINT((ndo, \" [|OPT]\"));\n\t\t    return;\n\t\t}\n \n \t\tswitch (opt_type & PGM_OPT_MASK) {\n \t\tcase PGM_OPT_LENGTH:\n\t\t    if (opt_len != 4) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_LENGTH option, length %u != 4]\", opt_len));\n \t\t\treturn;\n \t\t    }\n \t\t    ND_PRINT((ndo, \" OPTS LEN (extra?) %d\", EXTRACT_16BITS(bp)));\n\t\t    bp += sizeof(uint16_t);\n\t\t    opts_len -= 4;\n \t\t    break;\n \n \t\tcase PGM_OPT_FRAGMENT:\n\t\t    if (opt_len != 16) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_FRAGMENT option, length %u != 16]\", opt_len));\n \t\t\treturn;\n \t\t    }\n \t\t    bp += 2;\n \t\t    seq = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n \t\t    offset = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n \t\t    len = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n \t\t    ND_PRINT((ndo, \" FRAG seq %u off %u len %u\", seq, offset, len));\n\t\t    opts_len -= 16;\n \t\t    break;\n \n \t\tcase PGM_OPT_NAK_LIST:\n \t\t    bp += 2;\n\t\t    opt_len -= sizeof(uint32_t);\t/* option header */\n \t\t    ND_PRINT((ndo, \" NAK LIST\"));\n \t\t    while (opt_len) {\n\t\t\tif (opt_len < sizeof(uint32_t)) {\n \t\t\t    ND_PRINT((ndo, \"[Option length not a multiple of 4]\"));\n \t\t\t    return;\n \t\t\t}\n\t\t\tND_TCHECK2(*bp, sizeof(uint32_t));\n \t\t\tND_PRINT((ndo, \" %u\", EXTRACT_32BITS(bp)));\n\t\t\tbp += sizeof(uint32_t);\n\t\t\topt_len -= sizeof(uint32_t);\n\t\t\topts_len -= sizeof(uint32_t);\n \t\t    }\n \t\t    break;\n \n \t\tcase PGM_OPT_JOIN:\n\t\t    if (opt_len != 8) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_JOIN option, length %u != 8]\", opt_len));\n \t\t\treturn;\n \t\t    }\n \t\t    bp += 2;\n \t\t    seq = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n \t\t    ND_PRINT((ndo, \" JOIN %u\", seq));\n\t\t    opts_len -= 8;\n \t\t    break;\n \n \t\tcase PGM_OPT_NAK_BO_IVL:\n\t\t    if (opt_len != 12) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_NAK_BO_IVL option, length %u != 12]\", opt_len));\n \t\t\treturn;\n \t\t    }\n \t\t    bp += 2;\n \t\t    offset = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n \t\t    seq = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n \t\t    ND_PRINT((ndo, \" BACKOFF ivl %u ivlseq %u\", offset, seq));\n\t\t    opts_len -= 12;\n \t\t    break;\n \n \t\tcase PGM_OPT_NAK_BO_RNG:\n\t\t    if (opt_len != 12) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_NAK_BO_RNG option, length %u != 12]\", opt_len));\n \t\t\treturn;\n \t\t    }\n \t\t    bp += 2;\n \t\t    offset = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n \t\t    seq = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n \t\t    ND_PRINT((ndo, \" BACKOFF max %u min %u\", offset, seq));\n\t\t    opts_len -= 12;\n \t\t    break;\n \n \t\tcase PGM_OPT_REDIRECT:\n \t\t    bp += 2;\n \t\t    nla_afnum = EXTRACT_16BITS(bp);\n\t\t    bp += (2 * sizeof(uint16_t));\n \t\t    switch (nla_afnum) {\n \t\t    case AFNUM_INET:\n\t\t\tif (opt_len != 4 + sizeof(struct in_addr)) {\n\t\t\t    ND_PRINT((ndo, \"[Bad OPT_REDIRECT option, length %u != 4 + address size]\", opt_len));\n \t\t\t    return;\n \t\t\t}\n \t\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n \t\t\taddrtostr(bp, nla_buf, sizeof(nla_buf));\n \t\t\tbp += sizeof(struct in_addr);\n\t\t\topts_len -= 4 + sizeof(struct in_addr);\n \t\t\tbreak;\n \t\t    case AFNUM_INET6:\n\t\t\tif (opt_len != 4 + sizeof(struct in6_addr)) {\n\t\t\t    ND_PRINT((ndo, \"[Bad OPT_REDIRECT option, length %u != 4 + address size]\", opt_len));\n \t\t\t    return;\n \t\t\t}\n \t\t\tND_TCHECK2(*bp, sizeof(struct in6_addr));\n \t\t\taddrtostr6(bp, nla_buf, sizeof(nla_buf));\n \t\t\tbp += sizeof(struct in6_addr);\n\t\t\topts_len -= 4 + sizeof(struct in6_addr);\n \t\t\tbreak;\n \t\t    default:\n \t\t\tgoto trunc;\n\t\t\tbreak;\n\t\t    }\n\n\t\t    ND_PRINT((ndo, \" REDIRECT %s\",  nla_buf));\n \t\t    break;\n \n \t\tcase PGM_OPT_PARITY_PRM:\n\t\t    if (opt_len != 8) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_PARITY_PRM option, length %u != 8]\", opt_len));\n \t\t\treturn;\n \t\t    }\n \t\t    bp += 2;\n \t\t    len = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n \t\t    ND_PRINT((ndo, \" PARITY MAXTGS %u\", len));\n\t\t    opts_len -= 8;\n \t\t    break;\n \n \t\tcase PGM_OPT_PARITY_GRP:\n\t\t    if (opt_len != 8) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_PARITY_GRP option, length %u != 8]\", opt_len));\n \t\t\treturn;\n \t\t    }\n \t\t    bp += 2;\n \t\t    seq = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n \t\t    ND_PRINT((ndo, \" PARITY GROUP %u\", seq));\n\t\t    opts_len -= 8;\n \t\t    break;\n \n \t\tcase PGM_OPT_CURR_TGSIZE:\n\t\t    if (opt_len != 8) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_CURR_TGSIZE option, length %u != 8]\", opt_len));\n \t\t\treturn;\n \t\t    }\n \t\t    bp += 2;\n \t\t    len = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n \t\t    ND_PRINT((ndo, \" PARITY ATGS %u\", len));\n\t\t    opts_len -= 8;\n \t\t    break;\n \n \t\tcase PGM_OPT_NBR_UNREACH:\n\t\t    if (opt_len != 4) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_NBR_UNREACH option, length %u != 4]\", opt_len));\n \t\t\treturn;\n \t\t    }\n \t\t    bp += 2;\n \t\t    ND_PRINT((ndo, \" NBR_UNREACH\"));\n\t\t    opts_len -= 4;\n \t\t    break;\n \n \t\tcase PGM_OPT_PATH_NLA:\n\t\t    ND_PRINT((ndo, \" PATH_NLA [%d]\", opt_len));\n\t\t    bp += opt_len;\n\t\t    opts_len -= opt_len;\n \t\t    break;\n \n \t\tcase PGM_OPT_SYN:\n\t\t    if (opt_len != 4) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_SYN option, length %u != 4]\", opt_len));\n \t\t\treturn;\n \t\t    }\n \t\t    bp += 2;\n \t\t    ND_PRINT((ndo, \" SYN\"));\n\t\t    opts_len -= 4;\n \t\t    break;\n \n \t\tcase PGM_OPT_FIN:\n\t\t    if (opt_len != 4) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_FIN option, length %u != 4]\", opt_len));\n \t\t\treturn;\n \t\t    }\n \t\t    bp += 2;\n \t\t    ND_PRINT((ndo, \" FIN\"));\n\t\t    opts_len -= 4;\n \t\t    break;\n \n \t\tcase PGM_OPT_RST:\n\t\t    if (opt_len != 4) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_RST option, length %u != 4]\", opt_len));\n \t\t\treturn;\n \t\t    }\n \t\t    bp += 2;\n \t\t    ND_PRINT((ndo, \" RST\"));\n\t\t    opts_len -= 4;\n \t\t    break;\n \n \t\tcase PGM_OPT_CR:\n\t\t    ND_PRINT((ndo, \" CR\"));\n\t\t    bp += opt_len;\n\t\t    opts_len -= opt_len;\n \t\t    break;\n \n \t\tcase PGM_OPT_CRQST:\n\t\t    if (opt_len != 4) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_CRQST option, length %u != 4]\", opt_len));\n \t\t\treturn;\n \t\t    }\n \t\t    bp += 2;\n \t\t    ND_PRINT((ndo, \" CRQST\"));\n\t\t    opts_len -= 4;\n \t\t    break;\n \n \t\tcase PGM_OPT_PGMCC_DATA:\n \t\t    bp += 2;\n \t\t    offset = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n \t\t    nla_afnum = EXTRACT_16BITS(bp);\n\t\t    bp += (2 * sizeof(uint16_t));\n \t\t    switch (nla_afnum) {\n \t\t    case AFNUM_INET:\n\t\t\tif (opt_len != 12 + sizeof(struct in_addr)) {\n\t\t\t    ND_PRINT((ndo, \"[Bad OPT_PGMCC_DATA option, length %u != 12 + address size]\", opt_len));\n \t\t\t    return;\n \t\t\t}\n \t\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n \t\t\taddrtostr(bp, nla_buf, sizeof(nla_buf));\n \t\t\tbp += sizeof(struct in_addr);\n\t\t\topts_len -= 12 + sizeof(struct in_addr);\n \t\t\tbreak;\n \t\t    case AFNUM_INET6:\n\t\t\tif (opt_len != 12 + sizeof(struct in6_addr)) {\n\t\t\t    ND_PRINT((ndo, \"[Bad OPT_PGMCC_DATA option, length %u != 12 + address size]\", opt_len));\n \t\t\t    return;\n \t\t\t}\n \t\t\tND_TCHECK2(*bp, sizeof(struct in6_addr));\n \t\t\taddrtostr6(bp, nla_buf, sizeof(nla_buf));\n \t\t\tbp += sizeof(struct in6_addr);\n\t\t\topts_len -= 12 + sizeof(struct in6_addr);\n \t\t\tbreak;\n \t\t    default:\n \t\t\tgoto trunc;\n\t\t\tbreak;\n\t\t    }\n\n\t\t    ND_PRINT((ndo, \" PGMCC DATA %u %s\", offset, nla_buf));\n \t\t    break;\n \n \t\tcase PGM_OPT_PGMCC_FEEDBACK:\n \t\t    bp += 2;\n \t\t    offset = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n \t\t    nla_afnum = EXTRACT_16BITS(bp);\n\t\t    bp += (2 * sizeof(uint16_t));\n \t\t    switch (nla_afnum) {\n \t\t    case AFNUM_INET:\n\t\t\tif (opt_len != 12 + sizeof(struct in_addr)) {\n\t\t\t    ND_PRINT((ndo, \"[Bad OPT_PGMCC_DATA option, length %u != 12 + address size]\", opt_len));\n \t\t\t    return;\n \t\t\t}\n \t\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n \t\t\taddrtostr(bp, nla_buf, sizeof(nla_buf));\n \t\t\tbp += sizeof(struct in_addr);\n\t\t\topts_len -= 12 + sizeof(struct in_addr);\n \t\t\tbreak;\n \t\t    case AFNUM_INET6:\n\t\t\tif (opt_len != 12 + sizeof(struct in6_addr)) {\n\t\t\t    ND_PRINT((ndo, \"[Bad OPT_PGMCC_DATA option, length %u != 12 + address size]\", opt_len));\n \t\t\t    return;\n \t\t\t}\n \t\t\tND_TCHECK2(*bp, sizeof(struct in6_addr));\n \t\t\taddrtostr6(bp, nla_buf, sizeof(nla_buf));\n \t\t\tbp += sizeof(struct in6_addr);\n\t\t\topts_len -= 12 + sizeof(struct in6_addr);\n \t\t\tbreak;\n \t\t    default:\n \t\t\tgoto trunc;\n\t\t\tbreak;\n\t\t    }\n\n\t\t    ND_PRINT((ndo, \" PGMCC FEEDBACK %u %s\", offset, nla_buf));\n\t\t    break;\n\n\t\tdefault:\n\t\t    ND_PRINT((ndo, \" OPT_%02X [%d] \", opt_type, opt_len));\n\t\t    bp += opt_len;\n\t\t    opts_len -= opt_len;\n\t\t    break;\n\t\t}\n\n\t\tif (opt_type & PGM_OPT_END)\n\t\t    break;\n\t     }\n\t}\n\n\tND_PRINT((ndo, \" [%u]\", length));\n\tif (ndo->ndo_packettype == PT_PGM_ZMTP1 &&\n\t    (pgm->pgm_type == PGM_ODATA || pgm->pgm_type == PGM_RDATA))\n\t\tzmtp1_print_datagram(ndo, bp, EXTRACT_16BITS(&pgm->pgm_length));\n\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \"[|pgm]\"));\n\tif (ch != '\\0')\n\t\tND_PRINT((ndo, \">\"));\n}\n", "target": 1, "idx": 181045}
{"func": "LockContentsView::UserState::UserState(AccountId account_id)\n    : account_id(account_id) {}\n", "target": 1, "idx": 186166}
{"func": "static int dev_get_valid_name(struct net *net, const char *name, char *buf,\n\t\t\t      bool fmt)\n{\n\tif (!dev_valid_name(name))\n\t\treturn -EINVAL;\n\n\tif (fmt && strchr(name, '%'))\n\t\treturn __dev_alloc_name(net, name, buf);\n\telse if (__dev_get_by_name(net, name))\n\t\treturn -EEXIST;\n\telse if (buf != name)\n\t\tstrlcpy(buf, name, IFNAMSIZ);\n\n\treturn 0;\n}\n", "target": 0, "idx": 32113}
{"func": "void ImageResource::ReloadIfLoFiOrPlaceholderImage(\n    ResourceFetcher* fetcher,\n    ReloadLoFiOrPlaceholderPolicy policy) {\n  if (policy == kReloadIfNeeded && !ShouldReloadBrokenPlaceholder())\n    return;\n\n  DCHECK(!IsLoaded() ||\n         HasServerLoFiResponseHeaders(GetResponse()) ==\n             static_cast<bool>(GetResourceRequest().GetPreviewsState() &\n                               WebURLRequest::kServerLoFiOn));\n\n  if (placeholder_option_ == PlaceholderOption::kDoNotReloadPlaceholder &&\n      !(GetResourceRequest().GetPreviewsState() & WebURLRequest::kServerLoFiOn))\n    return;\n\n  DCHECK(!is_scheduling_reload_);\n  is_scheduling_reload_ = true;\n\n  SetCachePolicyBypassingCache();\n\n  WebURLRequest::PreviewsState previews_state_for_reload =\n      WebURLRequest::kPreviewsNoTransform;\n  WebURLRequest::PreviewsState old_previews_state =\n      GetResourceRequest().GetPreviewsState();\n\n  if (policy == kReloadIfNeeded && (GetResourceRequest().GetPreviewsState() &\n                                    WebURLRequest::kClientLoFiOn)) {\n    previews_state_for_reload |= WebURLRequest::kClientLoFiAutoReload;\n  }\n  SetPreviewsState(previews_state_for_reload);\n\n  if (placeholder_option_ != PlaceholderOption::kDoNotReloadPlaceholder)\n    ClearRangeRequestHeader();\n\n  if (old_previews_state & WebURLRequest::kClientLoFiOn &&\n      policy != kReloadAlways) {\n    placeholder_option_ = PlaceholderOption::kShowAndDoNotReloadPlaceholder;\n  } else {\n    placeholder_option_ = PlaceholderOption::kDoNotReloadPlaceholder;\n  }\n\n  if (IsLoading()) {\n    Loader()->Cancel();\n  } else {\n    ClearData();\n    SetEncodedSize(0);\n    UpdateImage(nullptr, ImageResourceContent::kClearImageAndNotifyObservers,\n                false);\n  }\n\n  SetStatus(ResourceStatus::kNotStarted);\n\n  DCHECK(is_scheduling_reload_);\n  is_scheduling_reload_ = false;\n\n  fetcher->StartLoad(this);\n}\n", "target": 0, "idx": 162480}
{"func": "  void HandleCompleteLogin(const base::ListValue* args) {\n#if defined(OS_CHROMEOS)\n    oauth2_delegate_.reset(new InlineLoginUIOAuth2Delegate(web_ui()));\n    oauth2_token_fetcher_.reset(new chromeos::OAuth2TokenFetcher(\n        oauth2_delegate_.get(), profile_->GetRequestContext()));\n    oauth2_token_fetcher_->StartExchangeFromCookies();\n#elif !defined(OS_ANDROID)\n    const base::DictionaryValue* dict = NULL;\n    string16 email;\n    string16 password;\n    if (!args->GetDictionary(0, &dict) || !dict ||\n        !dict->GetString(\"email\", &email) ||\n        !dict->GetString(\"password\", &password)) {\n      NOTREACHED();\n      return;\n    }\n\n    new OneClickSigninSyncStarter(\n        profile_, NULL, \"0\" /* session_index 0 for the default user */,\n         UTF16ToASCII(email), UTF16ToASCII(password),\n         OneClickSigninSyncStarter::SYNC_WITH_DEFAULT_SETTINGS,\n         true /* force_same_tab_navigation */,\n        OneClickSigninSyncStarter::NO_CONFIRMATION);\n     web_ui()->CallJavascriptFunction(\"inline.login.closeDialog\");\n #endif\n   }\n", "target": 1, "idx": 184939}
{"func": "unsigned int __sk_run_filter(void *ctx, const struct sock_filter_int *insn)\n{\n\tu64 stack[MAX_BPF_STACK / sizeof(u64)];\n\tu64 regs[MAX_BPF_REG], tmp;\n\tvoid *ptr;\n\tint off;\n\n#define K  insn->imm\n#define A  regs[insn->a_reg]\n#define X  regs[insn->x_reg]\n#define R0 regs[0]\n\n#define CONT\t ({insn++; goto select_insn; })\n#define CONT_JMP ({insn++; goto select_insn; })\n\n\tstatic const void *jumptable[256] = {\n\t\t[0 ... 255] = &&default_label,\n\t\t/* Now overwrite non-defaults ... */\n#define DL(A, B, C)\t[A|B|C] = &&A##_##B##_##C\n\t\tDL(BPF_ALU, BPF_ADD, BPF_X),\n\t\tDL(BPF_ALU, BPF_ADD, BPF_K),\n\t\tDL(BPF_ALU, BPF_SUB, BPF_X),\n\t\tDL(BPF_ALU, BPF_SUB, BPF_K),\n\t\tDL(BPF_ALU, BPF_AND, BPF_X),\n\t\tDL(BPF_ALU, BPF_AND, BPF_K),\n\t\tDL(BPF_ALU, BPF_OR, BPF_X),\n\t\tDL(BPF_ALU, BPF_OR, BPF_K),\n\t\tDL(BPF_ALU, BPF_LSH, BPF_X),\n\t\tDL(BPF_ALU, BPF_LSH, BPF_K),\n\t\tDL(BPF_ALU, BPF_RSH, BPF_X),\n\t\tDL(BPF_ALU, BPF_RSH, BPF_K),\n\t\tDL(BPF_ALU, BPF_XOR, BPF_X),\n\t\tDL(BPF_ALU, BPF_XOR, BPF_K),\n\t\tDL(BPF_ALU, BPF_MUL, BPF_X),\n\t\tDL(BPF_ALU, BPF_MUL, BPF_K),\n\t\tDL(BPF_ALU, BPF_MOV, BPF_X),\n\t\tDL(BPF_ALU, BPF_MOV, BPF_K),\n\t\tDL(BPF_ALU, BPF_DIV, BPF_X),\n\t\tDL(BPF_ALU, BPF_DIV, BPF_K),\n\t\tDL(BPF_ALU, BPF_MOD, BPF_X),\n\t\tDL(BPF_ALU, BPF_MOD, BPF_K),\n\t\tDL(BPF_ALU, BPF_NEG, 0),\n\t\tDL(BPF_ALU, BPF_END, BPF_TO_BE),\n\t\tDL(BPF_ALU, BPF_END, BPF_TO_LE),\n\t\tDL(BPF_ALU64, BPF_ADD, BPF_X),\n\t\tDL(BPF_ALU64, BPF_ADD, BPF_K),\n\t\tDL(BPF_ALU64, BPF_SUB, BPF_X),\n\t\tDL(BPF_ALU64, BPF_SUB, BPF_K),\n\t\tDL(BPF_ALU64, BPF_AND, BPF_X),\n\t\tDL(BPF_ALU64, BPF_AND, BPF_K),\n\t\tDL(BPF_ALU64, BPF_OR, BPF_X),\n\t\tDL(BPF_ALU64, BPF_OR, BPF_K),\n\t\tDL(BPF_ALU64, BPF_LSH, BPF_X),\n\t\tDL(BPF_ALU64, BPF_LSH, BPF_K),\n\t\tDL(BPF_ALU64, BPF_RSH, BPF_X),\n\t\tDL(BPF_ALU64, BPF_RSH, BPF_K),\n\t\tDL(BPF_ALU64, BPF_XOR, BPF_X),\n\t\tDL(BPF_ALU64, BPF_XOR, BPF_K),\n\t\tDL(BPF_ALU64, BPF_MUL, BPF_X),\n\t\tDL(BPF_ALU64, BPF_MUL, BPF_K),\n\t\tDL(BPF_ALU64, BPF_MOV, BPF_X),\n\t\tDL(BPF_ALU64, BPF_MOV, BPF_K),\n\t\tDL(BPF_ALU64, BPF_ARSH, BPF_X),\n\t\tDL(BPF_ALU64, BPF_ARSH, BPF_K),\n\t\tDL(BPF_ALU64, BPF_DIV, BPF_X),\n\t\tDL(BPF_ALU64, BPF_DIV, BPF_K),\n\t\tDL(BPF_ALU64, BPF_MOD, BPF_X),\n\t\tDL(BPF_ALU64, BPF_MOD, BPF_K),\n\t\tDL(BPF_ALU64, BPF_NEG, 0),\n\t\tDL(BPF_JMP, BPF_CALL, 0),\n\t\tDL(BPF_JMP, BPF_JA, 0),\n\t\tDL(BPF_JMP, BPF_JEQ, BPF_X),\n\t\tDL(BPF_JMP, BPF_JEQ, BPF_K),\n\t\tDL(BPF_JMP, BPF_JNE, BPF_X),\n\t\tDL(BPF_JMP, BPF_JNE, BPF_K),\n\t\tDL(BPF_JMP, BPF_JGT, BPF_X),\n\t\tDL(BPF_JMP, BPF_JGT, BPF_K),\n\t\tDL(BPF_JMP, BPF_JGE, BPF_X),\n\t\tDL(BPF_JMP, BPF_JGE, BPF_K),\n\t\tDL(BPF_JMP, BPF_JSGT, BPF_X),\n\t\tDL(BPF_JMP, BPF_JSGT, BPF_K),\n\t\tDL(BPF_JMP, BPF_JSGE, BPF_X),\n\t\tDL(BPF_JMP, BPF_JSGE, BPF_K),\n\t\tDL(BPF_JMP, BPF_JSET, BPF_X),\n\t\tDL(BPF_JMP, BPF_JSET, BPF_K),\n\t\tDL(BPF_JMP, BPF_EXIT, 0),\n\t\tDL(BPF_STX, BPF_MEM, BPF_B),\n\t\tDL(BPF_STX, BPF_MEM, BPF_H),\n\t\tDL(BPF_STX, BPF_MEM, BPF_W),\n\t\tDL(BPF_STX, BPF_MEM, BPF_DW),\n\t\tDL(BPF_STX, BPF_XADD, BPF_W),\n\t\tDL(BPF_STX, BPF_XADD, BPF_DW),\n\t\tDL(BPF_ST, BPF_MEM, BPF_B),\n\t\tDL(BPF_ST, BPF_MEM, BPF_H),\n\t\tDL(BPF_ST, BPF_MEM, BPF_W),\n\t\tDL(BPF_ST, BPF_MEM, BPF_DW),\n\t\tDL(BPF_LDX, BPF_MEM, BPF_B),\n\t\tDL(BPF_LDX, BPF_MEM, BPF_H),\n\t\tDL(BPF_LDX, BPF_MEM, BPF_W),\n\t\tDL(BPF_LDX, BPF_MEM, BPF_DW),\n\t\tDL(BPF_LD, BPF_ABS, BPF_W),\n\t\tDL(BPF_LD, BPF_ABS, BPF_H),\n\t\tDL(BPF_LD, BPF_ABS, BPF_B),\n\t\tDL(BPF_LD, BPF_IND, BPF_W),\n\t\tDL(BPF_LD, BPF_IND, BPF_H),\n\t\tDL(BPF_LD, BPF_IND, BPF_B),\n#undef DL\n\t};\n\n\tregs[FP_REG]  = (u64) (unsigned long) &stack[ARRAY_SIZE(stack)];\n\tregs[ARG1_REG] = (u64) (unsigned long) ctx;\n\nselect_insn:\n\tgoto *jumptable[insn->code];\n\n\t/* ALU */\n#define ALU(OPCODE, OP)\t\t\t\\\n\tBPF_ALU64_##OPCODE##_BPF_X:\t\\\n\t\tA = A OP X;\t\t\\\n\t\tCONT;\t\t\t\\\n\tBPF_ALU_##OPCODE##_BPF_X:\t\\\n\t\tA = (u32) A OP (u32) X;\t\\\n\t\tCONT;\t\t\t\\\n\tBPF_ALU64_##OPCODE##_BPF_K:\t\\\n\t\tA = A OP K;\t\t\\\n\t\tCONT;\t\t\t\\\n\tBPF_ALU_##OPCODE##_BPF_K:\t\\\n\t\tA = (u32) A OP (u32) K;\t\\\n\t\tCONT;\n\n\tALU(BPF_ADD,  +)\n\tALU(BPF_SUB,  -)\n\tALU(BPF_AND,  &)\n\tALU(BPF_OR,   |)\n\tALU(BPF_LSH, <<)\n\tALU(BPF_RSH, >>)\n\tALU(BPF_XOR,  ^)\n\tALU(BPF_MUL,  *)\n#undef ALU\n\tBPF_ALU_BPF_NEG_0:\n\t\tA = (u32) -A;\n\t\tCONT;\n\tBPF_ALU64_BPF_NEG_0:\n\t\tA = -A;\n\t\tCONT;\n\tBPF_ALU_BPF_MOV_BPF_X:\n\t\tA = (u32) X;\n\t\tCONT;\n\tBPF_ALU_BPF_MOV_BPF_K:\n\t\tA = (u32) K;\n\t\tCONT;\n\tBPF_ALU64_BPF_MOV_BPF_X:\n\t\tA = X;\n\t\tCONT;\n\tBPF_ALU64_BPF_MOV_BPF_K:\n\t\tA = K;\n\t\tCONT;\n\tBPF_ALU64_BPF_ARSH_BPF_X:\n\t\t(*(s64 *) &A) >>= X;\n\t\tCONT;\n\tBPF_ALU64_BPF_ARSH_BPF_K:\n\t\t(*(s64 *) &A) >>= K;\n\t\tCONT;\n\tBPF_ALU64_BPF_MOD_BPF_X:\n\t\tif (unlikely(X == 0))\n\t\t\treturn 0;\n\t\ttmp = A;\n\t\tA = do_div(tmp, X);\n\t\tCONT;\n\tBPF_ALU_BPF_MOD_BPF_X:\n\t\tif (unlikely(X == 0))\n\t\t\treturn 0;\n\t\ttmp = (u32) A;\n\t\tA = do_div(tmp, (u32) X);\n\t\tCONT;\n\tBPF_ALU64_BPF_MOD_BPF_K:\n\t\ttmp = A;\n\t\tA = do_div(tmp, K);\n\t\tCONT;\n\tBPF_ALU_BPF_MOD_BPF_K:\n\t\ttmp = (u32) A;\n\t\tA = do_div(tmp, (u32) K);\n\t\tCONT;\n\tBPF_ALU64_BPF_DIV_BPF_X:\n\t\tif (unlikely(X == 0))\n\t\t\treturn 0;\n\t\tdo_div(A, X);\n\t\tCONT;\n\tBPF_ALU_BPF_DIV_BPF_X:\n\t\tif (unlikely(X == 0))\n\t\t\treturn 0;\n\t\ttmp = (u32) A;\n\t\tdo_div(tmp, (u32) X);\n\t\tA = (u32) tmp;\n\t\tCONT;\n\tBPF_ALU64_BPF_DIV_BPF_K:\n\t\tdo_div(A, K);\n\t\tCONT;\n\tBPF_ALU_BPF_DIV_BPF_K:\n\t\ttmp = (u32) A;\n\t\tdo_div(tmp, (u32) K);\n\t\tA = (u32) tmp;\n\t\tCONT;\n\tBPF_ALU_BPF_END_BPF_TO_BE:\n\t\tswitch (K) {\n\t\tcase 16:\n\t\t\tA = (__force u16) cpu_to_be16(A);\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tA = (__force u32) cpu_to_be32(A);\n\t\t\tbreak;\n\t\tcase 64:\n\t\t\tA = (__force u64) cpu_to_be64(A);\n\t\t\tbreak;\n\t\t}\n\t\tCONT;\n\tBPF_ALU_BPF_END_BPF_TO_LE:\n\t\tswitch (K) {\n\t\tcase 16:\n\t\t\tA = (__force u16) cpu_to_le16(A);\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tA = (__force u32) cpu_to_le32(A);\n\t\t\tbreak;\n\t\tcase 64:\n\t\t\tA = (__force u64) cpu_to_le64(A);\n\t\t\tbreak;\n\t\t}\n\t\tCONT;\n\n\t/* CALL */\n\tBPF_JMP_BPF_CALL_0:\n\t\t/* Function call scratches R1-R5 registers, preserves R6-R9,\n\t\t * and stores return value into R0.\n\t\t */\n\t\tR0 = (__bpf_call_base + insn->imm)(regs[1], regs[2], regs[3],\n\t\t\t\t\t\t   regs[4], regs[5]);\n\t\tCONT;\n\n\t/* JMP */\n\tBPF_JMP_BPF_JA_0:\n\t\tinsn += insn->off;\n\t\tCONT;\n\tBPF_JMP_BPF_JEQ_BPF_X:\n\t\tif (A == X) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tBPF_JMP_BPF_JEQ_BPF_K:\n\t\tif (A == K) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tBPF_JMP_BPF_JNE_BPF_X:\n\t\tif (A != X) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tBPF_JMP_BPF_JNE_BPF_K:\n\t\tif (A != K) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tBPF_JMP_BPF_JGT_BPF_X:\n\t\tif (A > X) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tBPF_JMP_BPF_JGT_BPF_K:\n\t\tif (A > K) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tBPF_JMP_BPF_JGE_BPF_X:\n\t\tif (A >= X) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tBPF_JMP_BPF_JGE_BPF_K:\n\t\tif (A >= K) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tBPF_JMP_BPF_JSGT_BPF_X:\n\t\tif (((s64)A) > ((s64)X)) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tBPF_JMP_BPF_JSGT_BPF_K:\n\t\tif (((s64)A) > ((s64)K)) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tBPF_JMP_BPF_JSGE_BPF_X:\n\t\tif (((s64)A) >= ((s64)X)) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tBPF_JMP_BPF_JSGE_BPF_K:\n\t\tif (((s64)A) >= ((s64)K)) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tBPF_JMP_BPF_JSET_BPF_X:\n\t\tif (A & X) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tBPF_JMP_BPF_JSET_BPF_K:\n\t\tif (A & K) {\n\t\t\tinsn += insn->off;\n\t\t\tCONT_JMP;\n\t\t}\n\t\tCONT;\n\tBPF_JMP_BPF_EXIT_0:\n\t\treturn R0;\n\n\t/* STX and ST and LDX*/\n#define LDST(SIZEOP, SIZE)\t\t\t\t\t\\\n\tBPF_STX_BPF_MEM_##SIZEOP:\t\t\t\t\\\n\t\t*(SIZE *)(unsigned long) (A + insn->off) = X;\t\\\n\t\tCONT;\t\t\t\t\t\t\\\n\tBPF_ST_BPF_MEM_##SIZEOP:\t\t\t\t\\\n\t\t*(SIZE *)(unsigned long) (A + insn->off) = K;\t\\\n\t\tCONT;\t\t\t\t\t\t\\\n\tBPF_LDX_BPF_MEM_##SIZEOP:\t\t\t\t\\\n\t\tA = *(SIZE *)(unsigned long) (X + insn->off);\t\\\n\t\tCONT;\n\n\tLDST(BPF_B,   u8)\n\tLDST(BPF_H,  u16)\n\tLDST(BPF_W,  u32)\n\tLDST(BPF_DW, u64)\n#undef LDST\n\tBPF_STX_BPF_XADD_BPF_W: /* lock xadd *(u32 *)(A + insn->off) += X */\n\t\tatomic_add((u32) X, (atomic_t *)(unsigned long)\n\t\t\t   (A + insn->off));\n\t\tCONT;\n\tBPF_STX_BPF_XADD_BPF_DW: /* lock xadd *(u64 *)(A + insn->off) += X */\n\t\tatomic64_add((u64) X, (atomic64_t *)(unsigned long)\n\t\t\t     (A + insn->off));\n\t\tCONT;\n\tBPF_LD_BPF_ABS_BPF_W: /* R0 = ntohl(*(u32 *) (skb->data + K)) */\n\t\toff = K;\nload_word:\n\t\t/* BPF_LD + BPD_ABS and BPF_LD + BPF_IND insns are only\n\t\t * appearing in the programs where ctx == skb. All programs\n\t\t * keep 'ctx' in regs[CTX_REG] == R6, sk_convert_filter()\n\t\t * saves it in R6, internal BPF verifier will check that\n\t\t * R6 == ctx.\n\t\t *\n\t\t * BPF_ABS and BPF_IND are wrappers of function calls, so\n\t\t * they scratch R1-R5 registers, preserve R6-R9, and store\n\t\t * return value into R0.\n\t\t *\n\t\t * Implicit input:\n\t\t *   ctx\n\t\t *\n\t\t * Explicit input:\n\t\t *   X == any register\n\t\t *   K == 32-bit immediate\n\t\t *\n\t\t * Output:\n\t\t *   R0 - 8/16/32-bit skb data converted to cpu endianness\n\t\t */\n\t\tptr = load_pointer((struct sk_buff *) ctx, off, 4, &tmp);\n\t\tif (likely(ptr != NULL)) {\n\t\t\tR0 = get_unaligned_be32(ptr);\n\t\t\tCONT;\n\t\t}\n\t\treturn 0;\n\tBPF_LD_BPF_ABS_BPF_H: /* R0 = ntohs(*(u16 *) (skb->data + K)) */\n\t\toff = K;\nload_half:\n\t\tptr = load_pointer((struct sk_buff *) ctx, off, 2, &tmp);\n\t\tif (likely(ptr != NULL)) {\n\t\t\tR0 = get_unaligned_be16(ptr);\n\t\t\tCONT;\n\t\t}\n\t\treturn 0;\n\tBPF_LD_BPF_ABS_BPF_B: /* R0 = *(u8 *) (ctx + K) */\n\t\toff = K;\nload_byte:\n\t\tptr = load_pointer((struct sk_buff *) ctx, off, 1, &tmp);\n\t\tif (likely(ptr != NULL)) {\n\t\t\tR0 = *(u8 *)ptr;\n\t\t\tCONT;\n\t\t}\n\t\treturn 0;\n\tBPF_LD_BPF_IND_BPF_W: /* R0 = ntohl(*(u32 *) (skb->data + X + K)) */\n\t\toff = K + X;\n\t\tgoto load_word;\n\tBPF_LD_BPF_IND_BPF_H: /* R0 = ntohs(*(u16 *) (skb->data + X + K)) */\n\t\toff = K + X;\n\t\tgoto load_half;\n\tBPF_LD_BPF_IND_BPF_B: /* R0 = *(u8 *) (skb->data + X + K) */\n\t\toff = K + X;\n\t\tgoto load_byte;\n\n\tdefault_label:\n\t\t/* If we ever reach this, we have a bug somewhere. */\n\t\tWARN_RATELIMIT(1, \"unknown opcode %02x\\n\", insn->code);\n\t\treturn 0;\n#undef CONT_JMP\n#undef CONT\n\n#undef R0\n#undef X\n#undef A\n#undef K\n}\n", "target": 0, "idx": 38237}
{"func": "static void cleanup_streams(h2_session *session)\n{\n    stream_sel_ctx ctx;\n    ctx.session = session;\n    ctx.candidate = NULL;\n    while (1) {\n        h2_mplx_stream_do(session->mplx, find_cleanup_stream, &ctx);\n        if (ctx.candidate) {\n            h2_session_stream_done(session, ctx.candidate);\n            ctx.candidate = NULL;\n        }\n        else {\n            break;\n        }\n    }\n}\n", "target": 0, "idx": 48631}
{"func": "void DataPipeProducerDispatcher::CancelTransit() {\n  base::AutoLock lock(lock_);\n  DCHECK(in_transit_);\n  in_transit_ = false;\n\n  HandleSignalsState state = GetHandleSignalsStateNoLock();\n  watchers_.NotifyState(state);\n}\n", "target": 0, "idx": 167491}
{"func": "static inline int ip6_ufo_append_data(struct sock *sk,\n\t\t\tint getfrag(void *from, char *to, int offset, int len,\n\t\t\tint odd, struct sk_buff *skb),\n\t\t\tvoid *from, int length, int hh_len, int fragheaderlen,\n\t\t\tint transhdrlen, int mtu,unsigned int flags,\n\t\t\tstruct rt6_info *rt)\n\n{\n\tstruct sk_buff *skb;\n\tint err;\n\n\t/* There is support for UDP large send offload by network\n\t * device, so create one single skb packet containing complete\n \t * udp datagram\n \t */\n \tif ((skb = skb_peek_tail(&sk->sk_write_queue)) == NULL) {\n \t\tskb = sock_alloc_send_skb(sk,\n \t\t\thh_len + fragheaderlen + transhdrlen + 20,\n \t\t\t(flags & MSG_DONTWAIT), &err);\n\t\tif (skb == NULL)\n\t\t\treturn err;\n\n\t\t/* reserve space for Hardware header */\n\t\tskb_reserve(skb, hh_len);\n\n\t\t/* create space for UDP/IP header */\n\t\tskb_put(skb,fragheaderlen + transhdrlen);\n\n\t\t/* initialize network header pointer */\n\t\tskb_reset_network_header(skb);\n\n\t\t/* initialize protocol header pointer */\n\t\tskb->transport_header = skb->network_header + fragheaderlen;\n\n \t\tskb->protocol = htons(ETH_P_IPV6);\n \t\tskb->ip_summed = CHECKSUM_PARTIAL;\n \t\tskb->csum = 0;\n\t}\n\terr = skb_append_datato_frags(sk,skb, getfrag, from,\n\t\t\t\t      (length - transhdrlen));\n\tif (!err) {\n\t\tstruct frag_hdr fhdr;\n \n \t\t/* Specify the length of each IPv6 datagram fragment.\n \t\t * It has to be a multiple of 8.\n\t\t */\n\t\tskb_shinfo(skb)->gso_size = (mtu - fragheaderlen -\n\t\t\t\t\t     sizeof(struct frag_hdr)) & ~7;\n\t\tskb_shinfo(skb)->gso_type = SKB_GSO_UDP;\n \t\tipv6_select_ident(&fhdr, rt);\n \t\tskb_shinfo(skb)->ip6_frag_id = fhdr.identification;\n \t\t__skb_queue_tail(&sk->sk_write_queue, skb);\n\t\treturn 0;\n \t}\n\t/* There is not enough support do UPD LSO,\n\t * so follow normal path\n\t */\n\tkfree_skb(skb);\n \n\treturn err;\n }\n", "target": 1, "idx": 179160}
{"func": "static int i2c_type_bootmode(struct edgeport_serial *serial)\n{\n\tstruct device *dev = &serial->serial->dev->dev;\n\tint status;\n\tu8 *data;\n\n\tdata = kmalloc(1, GFP_KERNEL);\n\tif (!data) {\n\t\tdev_err(dev, \"%s - out of memory\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Try to read type 2 */\n\tstatus = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,\n\t\t\t\tDTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);\n\tif (status)\n\t\tdev_dbg(dev, \"%s - read 2 status error = %d\\n\", __func__, status);\n\telse\n\t\tdev_dbg(dev, \"%s - read 2 data = 0x%x\\n\", __func__, *data);\n\tif ((!status) && (*data == UMP5152 || *data == UMP3410)) {\n\t\tdev_dbg(dev, \"%s - ROM_TYPE_II\\n\", __func__);\n\t\tserial->TI_I2C_Type = DTK_ADDR_SPACE_I2C_TYPE_II;\n\t\tgoto out;\n\t}\n\n\t/* Try to read type 3 */\n\tstatus = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,\n\t\t\t\tDTK_ADDR_SPACE_I2C_TYPE_III, 0,\tdata, 0x01);\n\tif (status)\n\t\tdev_dbg(dev, \"%s - read 3 status error = %d\\n\", __func__, status);\n\telse\n\t\tdev_dbg(dev, \"%s - read 2 data = 0x%x\\n\", __func__, *data);\n\tif ((!status) && (*data == UMP5152 || *data == UMP3410)) {\n\t\tdev_dbg(dev, \"%s - ROM_TYPE_III\\n\", __func__);\n\t\tserial->TI_I2C_Type = DTK_ADDR_SPACE_I2C_TYPE_III;\n\t\tgoto out;\n\t}\n\n\tdev_dbg(dev, \"%s - Unknown\\n\", __func__);\n\tserial->TI_I2C_Type = DTK_ADDR_SPACE_I2C_TYPE_II;\n\tstatus = -ENODEV;\nout:\n\tkfree(data);\n\treturn status;\n}\n", "target": 0, "idx": 33352}
{"func": "static int snd_seq_device_dev_free(struct snd_device *device)\n {\n \tstruct snd_seq_device *dev = device->device_data;\n \n \tput_device(&dev->dev);\n \treturn 0;\n }\n", "target": 1, "idx": 180854}
{"func": "static void LaunchDownloadOverwriteInfoBar(\n    JNIEnv* env,\n    const JavaParamRef<jclass>& clazz,\n    const JavaParamRef<jobject>& delegate,\n    const JavaParamRef<jobject>& tab,\n    const JavaParamRef<jobject>& download_info,\n    const JavaParamRef<jstring>& jfile_name,\n    const JavaParamRef<jstring>& jdir_name,\n    const JavaParamRef<jstring>& jdir_full_path) {\n  TabAndroid* tab_android = TabAndroid::GetNativeTab(env, tab);\n\n  std::string file_name =\n      base::android::ConvertJavaStringToUTF8(env, jfile_name);\n  std::string dir_name = base::android::ConvertJavaStringToUTF8(env, jdir_name);\n  std::string dir_full_path =\n      base::android::ConvertJavaStringToUTF8(env, jdir_full_path);\n\n  chrome::android::AndroidDownloadManagerOverwriteInfoBarDelegate::Create(\n      InfoBarService::FromWebContents(tab_android->web_contents()), file_name,\n      dir_name, dir_full_path, delegate, download_info);\n}\n", "target": 0, "idx": 137600}
{"func": "void RenderViewImpl::UpdateTitle(WebFrame* frame,\n                                 const string16& title,\n                                 WebTextDirection title_direction) {\n  if (frame->parent())\n    return;\n\n  string16 shortened_title = title.substr(0, content::kMaxTitleChars);\n  Send(new ViewHostMsg_UpdateTitle(routing_id_, page_id_, shortened_title,\n                                   title_direction));\n}\n", "target": 0, "idx": 109050}
{"func": "  void WaitForCopySourceReady() {\n    while (!GetRenderWidgetHostViewPort()->IsSurfaceAvailableForCopy())\n      GiveItSomeTime();\n  }\n", "target": 0, "idx": 134852}
{"func": "PHP_FUNCTION(imageaffinematrixget)\n{\n\tdouble affine[6];\n\tlong type;\n\tzval *options = NULL;\n\tzval **tmp;\n\tint res = GD_FALSE, i;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l|z\", &type, &options) == FAILURE)  {\n\t\treturn;\n\t}\n\n\tswitch((gdAffineStandardMatrix)type) {\n\t\tcase GD_AFFINE_TRANSLATE:\n\t\tcase GD_AFFINE_SCALE: {\n\t\t\tdouble x, y;\n\t\t\tif (!options || Z_TYPE_P(options) != IS_ARRAY) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Array expected as options\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tif (zend_hash_find(HASH_OF(options), \"x\", sizeof(\"x\"), (void **)&tmp) != FAILURE) {\n\t\t\t\tif (Z_TYPE_PP(tmp) != IS_DOUBLE) {\n\t\t\t\t\tzval dval;\n\t\t\t\t\tdval = **tmp;\n\t\t\t\t\tzval_copy_ctor(&dval);\n\t\t\t\t\tconvert_to_double(&dval);\n\t\t\t\t\tx = Z_DVAL(dval);\n\t\t\t\t} else {\n\t\t\t\t\tx = Z_DVAL_PP(tmp);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing x position\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\n\t\t\tif (zend_hash_find(HASH_OF(options), \"y\", sizeof(\"y\"), (void **)&tmp) != FAILURE) {\n\t\t\t\tif (Z_TYPE_PP(tmp) != IS_DOUBLE) {\n\t\t\t\t\tzval dval;\n\t\t\t\t\tdval = **tmp;\n\t\t\t\t\tzval_copy_ctor(&dval);\n\t\t\t\t\tconvert_to_double(&dval);\n\t\t\t\t\ty = Z_DVAL(dval);\n\t\t\t\t} else {\n\t\t\t\t\ty = Z_DVAL_PP(tmp);\n\t\t\t\t}\n\t\t\t} else {\n \t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing y position\");\n \t\t\t\tRETURN_FALSE;\n \t\t\t}\n \t\t\tif (type == GD_AFFINE_TRANSLATE) {\n \t\t\t\tres = gdAffineTranslate(affine, x, y);\n \t\t\t} else {\n\t\t\t\tres = gdAffineScale(affine, x, y);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase GD_AFFINE_ROTATE:\n\t\tcase GD_AFFINE_SHEAR_HORIZONTAL:\n\t\tcase GD_AFFINE_SHEAR_VERTICAL: {\n\t\t\tdouble angle;\n\n\t\t\tif (!options) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Number is expected as option\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tif(Z_TYPE_P(options) != IS_DOUBLE) {\n\t\t\t\tzval dval;\n\t\t\t\tdval = *options;\n\t\t\t\tzval_copy_ctor(&dval);\n\t\t\t\tconvert_to_double(&dval);\n\t\t\t\tangle = Z_DVAL(dval);\n\t\t\t} else {\n\t\t\t\tangle = Z_DVAL_P(options);\n\t\t\t}\n\n\t\t\tif (type == GD_AFFINE_SHEAR_HORIZONTAL) {\n\t\t\t\tres = gdAffineShearHorizontal(affine, angle);\n\t\t\t} else if (type == GD_AFFINE_SHEAR_VERTICAL) {\n\t\t\t\tres = gdAffineShearVertical(affine, angle);\n\t\t\t} else {\n\t\t\t\tres = gdAffineRotate(affine, angle);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tdefault:\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid type for element %li\", type);\n\t\t\tRETURN_FALSE;\n\t}\n\n\tif (res == GD_FALSE) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tarray_init(return_value);\n\t\tfor (i = 0; i < 6; i++) {\n\t\t\tadd_index_double(return_value, i, affine[i]);\n\t\t}\n\t}\n}\n", "target": 1, "idx": 180126}
{"func": "static int handle_emulation_failure(struct kvm_vcpu *vcpu)\n{\n\tint r = EMULATE_DONE;\n\n\t++vcpu->stat.insn_emulation_fail;\n\ttrace_kvm_emulate_insn_failed(vcpu);\n\tif (!is_guest_mode(vcpu)) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;\n\t\tvcpu->run->internal.ndata = 0;\n\t\tr = EMULATE_FAIL;\n\t}\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\n\treturn r;\n}\n", "target": 0, "idx": 20702}
{"func": "static void tg3_get_57780_nvram_info(struct tg3 *tp)\n{\n\tu32 nvcfg1;\n\n\tnvcfg1 = tr32(NVRAM_CFG1);\n\n\tswitch (nvcfg1 & NVRAM_CFG1_5752VENDOR_MASK) {\n\tcase FLASH_5787VENDOR_ATMEL_EEPROM_376KHZ:\n\tcase FLASH_5787VENDOR_MICRO_EEPROM_376KHZ:\n\t\ttp->nvram_jedecnum = JEDEC_ATMEL;\n\t\ttg3_flag_set(tp, NVRAM_BUFFERED);\n\t\ttp->nvram_pagesize = ATMEL_AT24C512_CHIP_SIZE;\n\n\t\tnvcfg1 &= ~NVRAM_CFG1_COMPAT_BYPASS;\n\t\ttw32(NVRAM_CFG1, nvcfg1);\n\t\treturn;\n\tcase FLASH_5752VENDOR_ATMEL_FLASH_BUFFERED:\n\tcase FLASH_57780VENDOR_ATMEL_AT45DB011D:\n\tcase FLASH_57780VENDOR_ATMEL_AT45DB011B:\n\tcase FLASH_57780VENDOR_ATMEL_AT45DB021D:\n\tcase FLASH_57780VENDOR_ATMEL_AT45DB021B:\n\tcase FLASH_57780VENDOR_ATMEL_AT45DB041D:\n\tcase FLASH_57780VENDOR_ATMEL_AT45DB041B:\n\t\ttp->nvram_jedecnum = JEDEC_ATMEL;\n\t\ttg3_flag_set(tp, NVRAM_BUFFERED);\n\t\ttg3_flag_set(tp, FLASH);\n\n\t\tswitch (nvcfg1 & NVRAM_CFG1_5752VENDOR_MASK) {\n\t\tcase FLASH_5752VENDOR_ATMEL_FLASH_BUFFERED:\n\t\tcase FLASH_57780VENDOR_ATMEL_AT45DB011D:\n\t\tcase FLASH_57780VENDOR_ATMEL_AT45DB011B:\n\t\t\ttp->nvram_size = TG3_NVRAM_SIZE_128KB;\n\t\t\tbreak;\n\t\tcase FLASH_57780VENDOR_ATMEL_AT45DB021D:\n\t\tcase FLASH_57780VENDOR_ATMEL_AT45DB021B:\n\t\t\ttp->nvram_size = TG3_NVRAM_SIZE_256KB;\n\t\t\tbreak;\n\t\tcase FLASH_57780VENDOR_ATMEL_AT45DB041D:\n\t\tcase FLASH_57780VENDOR_ATMEL_AT45DB041B:\n\t\t\ttp->nvram_size = TG3_NVRAM_SIZE_512KB;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase FLASH_5752VENDOR_ST_M45PE10:\n\tcase FLASH_5752VENDOR_ST_M45PE20:\n\tcase FLASH_5752VENDOR_ST_M45PE40:\n\t\ttp->nvram_jedecnum = JEDEC_ST;\n\t\ttg3_flag_set(tp, NVRAM_BUFFERED);\n\t\ttg3_flag_set(tp, FLASH);\n\n\t\tswitch (nvcfg1 & NVRAM_CFG1_5752VENDOR_MASK) {\n\t\tcase FLASH_5752VENDOR_ST_M45PE10:\n\t\t\ttp->nvram_size = TG3_NVRAM_SIZE_128KB;\n\t\t\tbreak;\n\t\tcase FLASH_5752VENDOR_ST_M45PE20:\n\t\t\ttp->nvram_size = TG3_NVRAM_SIZE_256KB;\n\t\t\tbreak;\n\t\tcase FLASH_5752VENDOR_ST_M45PE40:\n\t\t\ttp->nvram_size = TG3_NVRAM_SIZE_512KB;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\ttg3_flag_set(tp, NO_NVRAM);\n\t\treturn;\n\t}\n\n\ttg3_nvram_get_pagesize(tp, nvcfg1);\n\tif (tp->nvram_pagesize != 264 && tp->nvram_pagesize != 528)\n\t\ttg3_flag_set(tp, NO_NVRAM_ADDR_TRANS);\n}\n", "target": 0, "idx": 32548}
{"func": "GF_Err extr_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ExtraDataBox *ptr = (GF_ExtraDataBox *)s;\n\n\te = gf_isom_box_parse((GF_Box**) &ptr->feci, bs);\n\tif (e) return e;\n\tif (ptr->feci->size>ptr->size) return GF_ISOM_INVALID_MEDIA;\n\tptr->data_length = (u32) (ptr->size - ptr->feci->size);\n\tptr->data = gf_malloc(sizeof(char)*ptr->data_length);\n\tgf_bs_read_data(bs, ptr->data, ptr->data_length);\n\n\treturn GF_OK;\n}\n", "target": 0, "idx": 80100}
{"func": "void PrintWebViewHelper::UpdatePrintableSizeInPrintParameters(\n    WebFrame* frame,\n    WebNode* node,\n    ViewMsg_Print_Params* params) {\n  double content_width_in_points;\n  double content_height_in_points;\n  double margin_top_in_points;\n  double margin_right_in_points;\n  double margin_bottom_in_points;\n  double margin_left_in_points;\n  PrepareFrameAndViewForPrint prepare(*params, frame, node, frame->view());\n  PrintWebViewHelper::GetPageSizeAndMarginsInPoints(frame, 0, *params,\n      &content_width_in_points, &content_height_in_points,\n      &margin_top_in_points, &margin_right_in_points,\n      &margin_bottom_in_points, &margin_left_in_points);\n#if defined(OS_MACOSX)\n  int dpi = printing::kPointsPerInch;\n#else\n  int dpi = static_cast<int>(params->dpi);\n#endif  // defined(OS_MACOSX)\n  params->printable_size = gfx::Size(\n      static_cast<int>(ConvertUnitDouble(content_width_in_points,\n          printing::kPointsPerInch, dpi)),\n       static_cast<int>(ConvertUnitDouble(content_height_in_points,\n           printing::kPointsPerInch, dpi)));\n \n   params->page_size = gfx::Size(\n      static_cast<int>(ConvertUnitDouble(content_width_in_points +\n          margin_left_in_points + margin_right_in_points,\n          printing::kPointsPerInch, dpi)),\n      static_cast<int>(ConvertUnitDouble(content_height_in_points +\n          margin_top_in_points + margin_bottom_in_points,\n          printing::kPointsPerInch, dpi)));\n \n   params->margin_top = static_cast<int>(ConvertUnitDouble(\n       margin_top_in_points, printing::kPointsPerInch, dpi));\n  params->margin_left = static_cast<int>(ConvertUnitDouble(\n      margin_left_in_points, printing::kPointsPerInch, dpi));\n}\n", "target": 1, "idx": 184182}
{"func": " void BrowserPpapiHostImpl::DeleteInstance(PP_Instance instance) {\n   auto it = instance_map_.find(instance);\n  DCHECK(it != instance_map_.end());\n  for (auto& observer : it->second->observer_list)\n    observer.OnHostDestroyed();\n \n  instance_map_.erase(it);\n }\n", "target": 1, "idx": 186278}
{"func": "htmlInitParserCtxt(htmlParserCtxtPtr ctxt)\n{\n    htmlSAXHandler *sax;\n\n    if (ctxt == NULL) return(-1);\n    memset(ctxt, 0, sizeof(htmlParserCtxt));\n\n    ctxt->dict = xmlDictCreate();\n    if (ctxt->dict == NULL) {\n        htmlErrMemory(NULL, \"htmlInitParserCtxt: out of memory\\n\");\n\treturn(-1);\n    }\n    sax = (htmlSAXHandler *) xmlMalloc(sizeof(htmlSAXHandler));\n    if (sax == NULL) {\n        htmlErrMemory(NULL, \"htmlInitParserCtxt: out of memory\\n\");\n\treturn(-1);\n    }\n    else\n        memset(sax, 0, sizeof(htmlSAXHandler));\n\n    /* Allocate the Input stack */\n    ctxt->inputTab = (htmlParserInputPtr *)\n                      xmlMalloc(5 * sizeof(htmlParserInputPtr));\n    if (ctxt->inputTab == NULL) {\n        htmlErrMemory(NULL, \"htmlInitParserCtxt: out of memory\\n\");\n\tctxt->inputNr = 0;\n\tctxt->inputMax = 0;\n\tctxt->input = NULL;\n\treturn(-1);\n    }\n    ctxt->inputNr = 0;\n    ctxt->inputMax = 5;\n    ctxt->input = NULL;\n    ctxt->version = NULL;\n    ctxt->encoding = NULL;\n    ctxt->standalone = -1;\n    ctxt->instate = XML_PARSER_START;\n\n    /* Allocate the Node stack */\n    ctxt->nodeTab = (htmlNodePtr *) xmlMalloc(10 * sizeof(htmlNodePtr));\n    if (ctxt->nodeTab == NULL) {\n        htmlErrMemory(NULL, \"htmlInitParserCtxt: out of memory\\n\");\n\tctxt->nodeNr = 0;\n\tctxt->nodeMax = 0;\n\tctxt->node = NULL;\n\tctxt->inputNr = 0;\n\tctxt->inputMax = 0;\n\tctxt->input = NULL;\n\treturn(-1);\n    }\n    ctxt->nodeNr = 0;\n    ctxt->nodeMax = 10;\n    ctxt->node = NULL;\n\n    /* Allocate the Name stack */\n    ctxt->nameTab = (const xmlChar **) xmlMalloc(10 * sizeof(xmlChar *));\n    if (ctxt->nameTab == NULL) {\n        htmlErrMemory(NULL, \"htmlInitParserCtxt: out of memory\\n\");\n\tctxt->nameNr = 0;\n\tctxt->nameMax = 0;\n\tctxt->name = NULL;\n\tctxt->nodeNr = 0;\n\tctxt->nodeMax = 0;\n\tctxt->node = NULL;\n\tctxt->inputNr = 0;\n\tctxt->inputMax = 0;\n\tctxt->input = NULL;\n\treturn(-1);\n    }\n    ctxt->nameNr = 0;\n    ctxt->nameMax = 10;\n    ctxt->name = NULL;\n\n    ctxt->nodeInfoTab = NULL;\n    ctxt->nodeInfoNr  = 0;\n    ctxt->nodeInfoMax = 0;\n\n    if (sax == NULL) ctxt->sax = (xmlSAXHandlerPtr) &htmlDefaultSAXHandler;\n    else {\n        ctxt->sax = sax;\n\tmemcpy(sax, &htmlDefaultSAXHandler, sizeof(xmlSAXHandlerV1));\n    }\n    ctxt->userData = ctxt;\n    ctxt->myDoc = NULL;\n     ctxt->wellFormed = 1;\n     ctxt->replaceEntities = 0;\n     ctxt->linenumbers = xmlLineNumbersDefaultValue;\n     ctxt->html = 1;\n     ctxt->vctxt.finishDtd = XML_CTXT_FINISH_DTD_0;\n     ctxt->vctxt.userData = ctxt;\n    ctxt->vctxt.error = xmlParserValidityError;\n    ctxt->vctxt.warning = xmlParserValidityWarning;\n    ctxt->record_info = 0;\n    ctxt->validate = 0;\n    ctxt->nbChars = 0;\n    ctxt->checkIndex = 0;\n    ctxt->catalogs = NULL;\n    xmlInitNodeInfoSeq(&ctxt->node_seq);\n    return(0);\n}\n", "target": 1, "idx": 186923}
{"func": "WORD32 ih264d_parse_nal_unit(iv_obj_t *dec_hdl,\n ivd_video_decode_op_t *ps_dec_op,\n                          UWORD8 *pu1_buf,\n                          UWORD32 u4_length)\n{\n\n dec_bit_stream_t *ps_bitstrm;\n\n\n dec_struct_t *ps_dec = (dec_struct_t *)dec_hdl->pv_codec_handle;\n ivd_video_decode_ip_t *ps_dec_in =\n (ivd_video_decode_ip_t *)ps_dec->pv_dec_in;\n dec_slice_params_t * ps_cur_slice = ps_dec->ps_cur_slice;\n    UWORD8 u1_first_byte, u1_nal_ref_idc;\n    UWORD8 u1_nal_unit_type;\n    WORD32 i_status = OK;\n    ps_bitstrm = ps_dec->ps_bitstrm;\n\n if(pu1_buf)\n {\n if(u4_length)\n {\n            ps_dec_op->u4_frame_decoded_flag = 0;\n            ih264d_process_nal_unit(ps_dec->ps_bitstrm, pu1_buf,\n                                    u4_length);\n\n            SWITCHOFFTRACE;\n            u1_first_byte = ih264d_get_bits_h264(ps_bitstrm, 8);\n\n if(NAL_FORBIDDEN_BIT(u1_first_byte))\n {\n\n                 H264_DEC_DEBUG_PRINT(\"\\nForbidden bit set in Nal Unit, Let's try\\n\");\n             }\n             u1_nal_unit_type = NAL_UNIT_TYPE(u1_first_byte);\n             ps_dec->u1_nal_unit_type = u1_nal_unit_type;\n             u1_nal_ref_idc = (UWORD8)(NAL_REF_IDC(u1_first_byte));\n switch(u1_nal_unit_type)\n {\n case SLICE_DATA_PARTITION_A_NAL:\n case SLICE_DATA_PARTITION_B_NAL:\n case SLICE_DATA_PARTITION_C_NAL:\n if(!ps_dec->i4_decode_header)\n                        ih264d_parse_slice_partition(ps_dec, ps_bitstrm);\n\n break;\n\n case IDR_SLICE_NAL:\n case SLICE_NAL:\n\n /* ! */\n                    DEBUG_THREADS_PRINTF(\"Decoding  a slice NAL\\n\");\n if(!ps_dec->i4_decode_header)\n {\n if(ps_dec->i4_header_decoded == 3)\n {\n /* ! */\n                            ps_dec->u4_slice_start_code_found = 1;\n\n                            ih264d_rbsp_to_sodb(ps_dec->ps_bitstrm);\n\n                            i_status = ih264d_parse_decode_slice(\n (UWORD8)(u1_nal_unit_type\n == IDR_SLICE_NAL),\n                                            u1_nal_ref_idc, ps_dec);\n\n if((ps_dec->u4_first_slice_in_pic != 0)&&\n ((ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC) == 0))\n {\n /*  if the first slice header was not valid set to 1 */\n                                ps_dec->u4_first_slice_in_pic = 1;\n }\n\n if(i_status != OK)\n {\n return i_status;\n }\n }\n else\n {\n                            H264_DEC_DEBUG_PRINT(\n \"\\nSlice NAL Supplied but no header has been supplied\\n\");\n }\n }\n break;\n\n case SEI_NAL:\n if(!ps_dec->i4_decode_header)\n {\n                        ih264d_rbsp_to_sodb(ps_dec->ps_bitstrm);\n                        i_status = ih264d_parse_sei_message(ps_dec, ps_bitstrm);\n if(i_status != OK)\n return i_status;\n                        ih264d_parse_sei(ps_dec, ps_bitstrm);\n }\n break;\n case SEQ_PARAM_NAL:\n /* ! */\n                    ih264d_rbsp_to_sodb(ps_dec->ps_bitstrm);\n                    i_status = ih264d_parse_sps(ps_dec, ps_bitstrm);\n if(i_status == ERROR_INV_SPS_PPS_T)\n return i_status;\n if(!i_status)\n                        ps_dec->i4_header_decoded |= 0x1;\n break;\n\n case PIC_PARAM_NAL:\n /* ! */\n                    ih264d_rbsp_to_sodb(ps_dec->ps_bitstrm);\n                    i_status = ih264d_parse_pps(ps_dec, ps_bitstrm);\n if(i_status == ERROR_INV_SPS_PPS_T)\n return i_status;\n if(!i_status)\n                        ps_dec->i4_header_decoded |= 0x2;\n break;\n case ACCESS_UNIT_DELIMITER_RBSP:\n if(!ps_dec->i4_decode_header)\n {\n                        ih264d_access_unit_delimiter_rbsp(ps_dec);\n }\n break;\n case END_OF_STREAM_RBSP:\n if(!ps_dec->i4_decode_header)\n {\n                        ih264d_parse_end_of_stream(ps_dec);\n }\n break;\n case FILLER_DATA_NAL:\n if(!ps_dec->i4_decode_header)\n {\n                        ih264d_parse_filler_data(ps_dec, ps_bitstrm);\n }\n break;\n default:\n                    H264_DEC_DEBUG_PRINT(\"\\nUnknown NAL type %d\\n\", u1_nal_unit_type);\n break;\n }\n\n }\n\n }\n\n return i_status;\n\n}\n", "target": 1, "idx": 187564}
{"func": "static void put_unused_buffer(QEMUFile *f, void *pv, size_t size)\n{\n    static const uint8_t buf[1024];\n    int block_len;\n\n    while (size > 0) {\n        block_len = MIN(sizeof(buf), size);\n        size -= block_len;\n        qemu_put_buffer(f, buf, block_len);\n    }\n}\n", "target": 0, "idx": 15728}
{"func": " monitor_init(void)\n {\n\tstruct ssh *ssh = active_state;\t\t\t/* XXX */\n \tstruct monitor *mon;\n \n \tmon = xcalloc(1, sizeof(*mon));\n \tmonitor_openfds(mon, 1);\n \n\t/* Used to share zlib space across processes */\n\tif (options.compression) {\n\t\tmon->m_zback = mm_create(NULL, MM_MEMSIZE);\n\t\tmon->m_zlib = mm_create(mon->m_zback, 20 * MM_MEMSIZE);\n\t\t/* Compression needs to share state across borders */\n\t\tssh_packet_set_compress_hooks(ssh, mon->m_zlib,\n\t\t    (ssh_packet_comp_alloc_func *)mm_zalloc,\n\t\t    (ssh_packet_comp_free_func *)mm_zfree);\n\t}\n \treturn mon;\n }\n", "target": 1, "idx": 181821}
{"func": "brcmf_cfg80211_mgmt_tx(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t       struct cfg80211_mgmt_tx_params *params, u64 *cookie)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct ieee80211_channel *chan = params->chan;\n\tconst u8 *buf = params->buf;\n\tsize_t len = params->len;\n\tconst struct ieee80211_mgmt *mgmt;\n\tstruct brcmf_cfg80211_vif *vif;\n\ts32 err = 0;\n\ts32 ie_offset;\n\ts32 ie_len;\n\tstruct brcmf_fil_action_frame_le *action_frame;\n\tstruct brcmf_fil_af_params_le *af_params;\n\tbool ack;\n\ts32 chan_nr;\n\tu32 freq;\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\t*cookie = 0;\n\n\tmgmt = (const struct ieee80211_mgmt *)buf;\n\n\tif (!ieee80211_is_mgmt(mgmt->frame_control)) {\n\t\tbrcmf_err(\"Driver only allows MGMT packet type\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tvif = container_of(wdev, struct brcmf_cfg80211_vif, wdev);\n\n\tif (ieee80211_is_probe_resp(mgmt->frame_control)) {\n\t\t/* Right now the only reason to get a probe response */\n\t\t/* is for p2p listen response or for p2p GO from     */\n\t\t/* wpa_supplicant. Unfortunately the probe is send   */\n\t\t/* on primary ndev, while dongle wants it on the p2p */\n\t\t/* vif. Since this is only reason for a probe        */\n\t\t/* response to be sent, the vif is taken from cfg.   */\n\t\t/* If ever desired to send proberesp for non p2p     */\n\t\t/* response then data should be checked for          */\n\t\t/* \"DIRECT-\". Note in future supplicant will take    */\n\t\t/* dedicated p2p wdev to do this and then this 'hack'*/\n\t\t/* is not needed anymore.                            */\n\t\tie_offset =  DOT11_MGMT_HDR_LEN +\n\t\t\t     DOT11_BCN_PRB_FIXED_LEN;\n\t\tie_len = len - ie_offset;\n\t\tif (vif == cfg->p2p.bss_idx[P2PAPI_BSSCFG_PRIMARY].vif)\n\t\t\tvif = cfg->p2p.bss_idx[P2PAPI_BSSCFG_DEVICE].vif;\n\t\terr = brcmf_vif_set_mgmt_ie(vif,\n\t\t\t\t\t    BRCMF_VNDR_IE_PRBRSP_FLAG,\n\t\t\t\t\t    &buf[ie_offset],\n\t\t\t\t\t    ie_len);\n \t\tcfg80211_mgmt_tx_status(wdev, *cookie, buf, len, true,\n \t\t\t\t\tGFP_KERNEL);\n \t} else if (ieee80211_is_action(mgmt->frame_control)) {\n \t\taf_params = kzalloc(sizeof(*af_params), GFP_KERNEL);\n \t\tif (af_params == NULL) {\n \t\t\tbrcmf_err(\"unable to allocate frame\\n\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto exit;\n\t\t}\n\t\taction_frame = &af_params->action_frame;\n\t\t/* Add the packet Id */\n\t\taction_frame->packet_id = cpu_to_le32(*cookie);\n\t\t/* Add BSSID */\n\t\tmemcpy(&action_frame->da[0], &mgmt->da[0], ETH_ALEN);\n\t\tmemcpy(&af_params->bssid[0], &mgmt->bssid[0], ETH_ALEN);\n\t\t/* Add the length exepted for 802.11 header  */\n\t\taction_frame->len = cpu_to_le16(len - DOT11_MGMT_HDR_LEN);\n\t\t/* Add the channel. Use the one specified as parameter if any or\n\t\t * the current one (got from the firmware) otherwise\n\t\t */\n\t\tif (chan)\n\t\t\tfreq = chan->center_freq;\n\t\telse\n\t\t\tbrcmf_fil_cmd_int_get(vif->ifp, BRCMF_C_GET_CHANNEL,\n\t\t\t\t\t      &freq);\n\t\tchan_nr = ieee80211_frequency_to_channel(freq);\n\t\taf_params->channel = cpu_to_le32(chan_nr);\n\n\t\tmemcpy(action_frame->data, &buf[DOT11_MGMT_HDR_LEN],\n\t\t       le16_to_cpu(action_frame->len));\n\n\t\tbrcmf_dbg(TRACE, \"Action frame, cookie=%lld, len=%d, freq=%d\\n\",\n\t\t\t  *cookie, le16_to_cpu(action_frame->len), freq);\n\n\t\tack = brcmf_p2p_send_action_frame(cfg, cfg_to_ndev(cfg),\n\t\t\t\t\t\t  af_params);\n\n\t\tcfg80211_mgmt_tx_status(wdev, *cookie, buf, len, ack,\n\t\t\t\t\tGFP_KERNEL);\n\t\tkfree(af_params);\n\t} else {\n\t\tbrcmf_dbg(TRACE, \"Unhandled, fc=%04x!!\\n\", mgmt->frame_control);\n\t\tbrcmf_dbg_hex_dump(true, buf, len, \"payload, len=%zu\\n\", len);\n\t}\n\nexit:\n\treturn err;\n}\n", "target": 1, "idx": 181433}
{"func": "GahpClient::gt4_gram_client_job_status(const char * job_contact,\n\tchar ** job_status, char ** job_fault, int * exit_code)\n{\n\tstatic const char* command = \"GT4_GRAM_JOB_STATUS\";\n\n\tif  (server->m_commands_supported->contains_anycase(command)==FALSE) {\n\t\treturn GAHPCLIENT_COMMAND_NOT_SUPPORTED;\n\t}\n\n\tif (!job_contact) job_contact=NULLSTRING;\n\tstd::string reqline;\n\tint x = sprintf(reqline,\"%s\",escapeGahpString(job_contact));\n\tASSERT( x > 0 );\n\tconst char *buf = reqline.c_str();\n\n\tif ( !is_pending(command,buf) ) {\n\t\tif ( m_mode == results_only ) {\n\t\t\treturn GAHPCLIENT_COMMAND_NOT_SUBMITTED;\n\t\t}\n\t\tnow_pending(command,buf,normal_proxy);\n\t}\n\n\t\t\n\tGahp_Args* result = get_pending_result(command,buf);\n\tif ( result ) {\n\t\tif (result->argc != 6) {\n\t\t\tEXCEPT(\"Bad %s Result\",command);\n\t\t}\n\t\tint rc = atoi(result->argv[1]);\n\t\tif ( strcasecmp( result->argv[2], NULLSTRING ) ) {\n\t\t\t*job_status = strdup( result->argv[2] );\n\t\t} else {\n\t\t\t*job_status = NULL;\n\t\t}\n\t\tif ( strcasecmp( result->argv[3], NULLSTRING ) ) {\n\t\t\t*job_fault = strdup( result->argv[3] );\n\t\t} else {\n\t\t\t*job_fault = NULL;\n\t\t}\n\t\tif ( strcasecmp(result->argv[4], NULLSTRING) ) {\n\t\t\t*exit_code = atoi( result->argv[4] );\n\t\t} else {\n\t\t\t*exit_code = GT4_NO_EXIT_CODE;\n\t\t}\n\t\tif ( strcasecmp(result->argv[5], NULLSTRING) ) {\n\t\t\terror_string = result->argv[5];\n\t\t} else {\n\t\t\terror_string = \"\";\n\t\t}\n\t\tdelete result;\n\t\treturn rc;\n\t}\n\n\tif ( check_pending_timeout(command,buf) ) {\n\t\tsprintf( error_string, \"%s timed out\", command );\n\t\treturn GAHPCLIENT_COMMAND_TIMED_OUT;\n\t}\n\n\treturn GAHPCLIENT_COMMAND_PENDING;\n}\n", "target": 0, "idx": 16206}
{"func": "void close_all_sockets(atransport* t) {\n    asocket* s;\n\n\n     /* this is a little gross, but since s->close() *will* modify\n     ** the list out from under you, your options are limited.\n     */\n    adb_mutex_lock(&socket_list_lock);\n restart:\n     for (s = local_socket_list.next; s != &local_socket_list; s = s->next) {\n         if (s->transport == t || (s->peer && s->peer->transport == t)) {\n            local_socket_close_locked(s);\n             goto restart;\n         }\n     }\n    adb_mutex_unlock(&socket_list_lock);\n }\n", "target": 1, "idx": 188172}
{"func": "static int uvesafb_vbe_find_mode(struct uvesafb_par *par,\n\t\tint xres, int yres, int depth, unsigned char flags)\n{\n\tint i, match = -1, h = 0, d = 0x7fffffff;\n\n\tfor (i = 0; i < par->vbe_modes_cnt; i++) {\n\t\th = abs(par->vbe_modes[i].x_res - xres) +\n\t\t    abs(par->vbe_modes[i].y_res - yres) +\n\t\t    abs(depth - par->vbe_modes[i].depth);\n\n\t\t/*\n\t\t * We have an exact match in terms of resolution\n\t\t * and depth.\n\t\t */\n\t\tif (h == 0)\n\t\t\treturn i;\n\n\t\tif (h < d || (h == d && par->vbe_modes[i].depth > depth)) {\n\t\t\td = h;\n\t\t\tmatch = i;\n\t\t}\n\t}\n\ti = 1;\n\n\tif (flags & UVESAFB_EXACT_DEPTH &&\n\t\t\tpar->vbe_modes[match].depth != depth)\n\t\ti = 0;\n\n\tif (flags & UVESAFB_EXACT_RES && d > 24)\n\t\ti = 0;\n\n\tif (i != 0)\n\t\treturn match;\n\telse\n\t\treturn -1;\n}\n", "target": 0, "idx": 79800}
{"func": "void AudioHandler::PrintNodeCounts() {\n  fprintf(stderr, \"\\n\\n\");\n  fprintf(stderr, \"===========================\\n\");\n  fprintf(stderr, \"AudioNode: reference counts\\n\");\n  fprintf(stderr, \"===========================\\n\");\n\n  for (unsigned i = 0; i < kNodeTypeEnd; ++i)\n    fprintf(stderr, \"%2d: %d\\n\", i, node_count_[i]);\n\n  fprintf(stderr, \"===========================\\n\\n\\n\");\n}\n", "target": 0, "idx": 161631}
{"func": "static void sas_unregister_common_dev(struct asd_sas_port *port, struct domain_device *dev)\n{\n\tstruct sas_ha_struct *ha = port->ha;\n\n\tsas_notify_lldd_dev_gone(dev);\n\tif (!dev->parent)\n\t\tdev->port->port_dev = NULL;\n\telse\n\t\tlist_del_init(&dev->siblings);\n\n\tspin_lock_irq(&port->dev_list_lock);\n\tlist_del_init(&dev->dev_list_node);\n\tif (dev_is_sata(dev))\n\t\tsas_ata_end_eh(dev->sata_dev.ap);\n\tspin_unlock_irq(&port->dev_list_lock);\n\n\tspin_lock_irq(&ha->lock);\n\tif (dev->dev_type == SAS_END_DEVICE &&\n\t    !list_empty(&dev->ssp_dev.eh_list_node)) {\n\t\tlist_del_init(&dev->ssp_dev.eh_list_node);\n\t\tha->eh_active--;\n\t}\n\tspin_unlock_irq(&ha->lock);\n\n \tsas_put_device(dev);\n }\n", "target": 0, "idx": 85475}
{"func": "long Cluster::ParseSimpleBlock(long long block_size, long long& pos,\n long& len) {\n const long long block_start = pos;\n const long long block_stop = pos + block_size;\n\n IMkvReader* const pReader = m_pSegment->m_pReader;\n\n long long total, avail;\n\n long status = pReader->Length(&total, &avail);\n\n if (status < 0) // error\n return status;\n\n  assert((total < 0) || (avail <= total));\n\n\n if ((pos + 1) > avail) {\n    len = 1;\n return E_BUFFER_NOT_FULL;\n }\n\n long long result = GetUIntLength(pReader, pos, len);\n\n if (result < 0) // error\n return static_cast<long>(result);\n\n if (result > 0) // weird\n return E_BUFFER_NOT_FULL;\n\n if ((pos + len) > block_stop)\n return E_FILE_FORMAT_INVALID;\n\n if ((pos + len) > avail)\n return E_BUFFER_NOT_FULL;\n\n const long long track = ReadUInt(pReader, pos, len);\n\n if (track < 0) // error\n return static_cast<long>(track);\n\n\n   if (track == 0)\n     return E_FILE_FORMAT_INVALID;\n \n#if 0\n    const Tracks* const pTracks = m_pSegment->GetTracks();\n    assert(pTracks);\n    const long tn = static_cast<long>(track);\n    const Track* const pTrack = pTracks->GetTrackByNumber(tn);\n    if (pTrack == NULL)\n        return E_FILE_FORMAT_INVALID;\n#endif\n   pos += len;  // consume track number\n \n   if ((pos + 2) > block_stop)\n return E_FILE_FORMAT_INVALID;\n\n if ((pos + 2) > avail) {\n    len = 2;\n return E_BUFFER_NOT_FULL;\n }\n\n  pos += 2; // consume timecode\n\n if ((pos + 1) > block_stop)\n return E_FILE_FORMAT_INVALID;\n\n if ((pos + 1) > avail) {\n    len = 1;\n return E_BUFFER_NOT_FULL;\n }\n\n unsigned char flags;\n\n  status = pReader->Read(pos, 1, &flags);\n\n if (status < 0) { // error or underflow\n    len = 1;\n return status;\n }\n\n ++pos; // consume flags byte\n  assert(pos <= avail);\n\n if (pos >= block_stop)\n return E_FILE_FORMAT_INVALID;\n\n const int lacing = int(flags & 0x06) >> 1;\n\n if ((lacing != 0) && (block_stop > avail)) {\n    len = static_cast<long>(block_stop - pos);\n return E_BUFFER_NOT_FULL;\n }\n\n  status = CreateBlock(0x23, // simple block id\n                       block_start, block_size,\n 0); // DiscardPadding\n\n if (status != 0)\n return status;\n\n  m_pos = block_stop;\n\n return 0; // success\n}\n", "target": 1, "idx": 187880}
{"func": "make_bound_box(POLYGON *poly)\n{\n\tint\t\t\ti;\n\tdouble\t\tx1,\n\t\t\t\ty1,\n\t\t\t\tx2,\n\t\t\t\ty2;\n\n\tif (poly->npts > 0)\n\t{\n\t\tx2 = x1 = poly->p[0].x;\n\t\ty2 = y1 = poly->p[0].y;\n\t\tfor (i = 1; i < poly->npts; i++)\n\t\t{\n\t\t\tif (poly->p[i].x < x1)\n\t\t\t\tx1 = poly->p[i].x;\n\t\t\tif (poly->p[i].x > x2)\n\t\t\t\tx2 = poly->p[i].x;\n\t\t\tif (poly->p[i].y < y1)\n\t\t\t\ty1 = poly->p[i].y;\n\t\t\tif (poly->p[i].y > y2)\n\t\t\t\ty2 = poly->p[i].y;\n\t\t}\n\n\t\tbox_fill(&(poly->boundbox), x1, x2, y1, y2);\n\t}\n\telse\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot create bounding box for empty polygon\")));\n}\n", "target": 0, "idx": 38936}
{"func": "InterstitialPageImpl::~InterstitialPageImpl() {\n  frame_tree_.reset();\n}\n", "target": 0, "idx": 148823}
{"func": "status_t BnOMX::onTransact(\n uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {\n switch (code) {\n case LIVES_LOCALLY:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n            node_id node = (node_id)data.readInt32();\n pid_t pid = (pid_t)data.readInt32();\n            reply->writeInt32(livesLocally(node, pid));\n\n return OK;\n }\n\n case LIST_NODES:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n List<ComponentInfo> list;\n            listNodes(&list);\n\n            reply->writeInt32(list.size());\n for (List<ComponentInfo>::iterator it = list.begin();\n                 it != list.end(); ++it) {\n ComponentInfo &cur = *it;\n\n                reply->writeString8(cur.mName);\n                reply->writeInt32(cur.mRoles.size());\n for (List<String8>::iterator role_it = cur.mRoles.begin();\n                     role_it != cur.mRoles.end(); ++role_it) {\n                    reply->writeString8(*role_it);\n }\n }\n\n return NO_ERROR;\n }\n\n case ALLOCATE_NODE:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n const char *name = data.readCString();\n\n            sp<IOMXObserver> observer =\n                interface_cast<IOMXObserver>(data.readStrongBinder());\n\n            node_id node;\n\n status_t err = allocateNode(name, observer, &node);\n            reply->writeInt32(err);\n if (err == OK) {\n                reply->writeInt32((int32_t)node);\n }\n\n return NO_ERROR;\n }\n\n case FREE_NODE:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n\n            reply->writeInt32(freeNode(node));\n\n return NO_ERROR;\n }\n\n case SEND_COMMAND:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n\n            OMX_COMMANDTYPE cmd =\n static_cast<OMX_COMMANDTYPE>(data.readInt32());\n\n            OMX_S32 param = data.readInt32();\n            reply->writeInt32(sendCommand(node, cmd, param));\n\n return NO_ERROR;\n }\n\n case GET_PARAMETER:\n case SET_PARAMETER:\n case GET_CONFIG:\n case SET_CONFIG:\n case SET_INTERNAL_OPTION:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_INDEXTYPE index = static_cast<OMX_INDEXTYPE>(data.readInt32());\n\n size_t size = data.readInt64();\n\n status_t err = NOT_ENOUGH_DATA;\n\n             void *params = NULL;\n             size_t pageSize = 0;\n             size_t allocSize = 0;\n            if (code != SET_INTERNAL_OPTION && size < 8) {\n                 ALOGE(\"b/27207275 (%zu)\", size);\n                android_errorWriteLog(0x534e4554, \"27207275\");\n } else {\n                err = NO_MEMORY;\n                pageSize = (size_t) sysconf(_SC_PAGE_SIZE);\n if (size > SIZE_MAX - (pageSize * 2)) {\n                    ALOGE(\"requested param size too big\");\n } else {\n                    allocSize = (size + pageSize * 2) & ~(pageSize - 1);\n                    params = mmap(NULL, allocSize, PROT_READ | PROT_WRITE,\n                            MAP_PRIVATE | MAP_ANONYMOUS, -1 /* fd */, 0 /* offset */);\n }\n if (params != MAP_FAILED) {\n                    err = data.read(params, size);\n if (err != OK) {\n                        android_errorWriteLog(0x534e4554, \"26914474\");\n\n                     } else {\n                         err = NOT_ENOUGH_DATA;\n                         OMX_U32 declaredSize = *(OMX_U32*)params;\n                        if (code != SET_INTERNAL_OPTION && declaredSize > size) {\n                             ALOGE(\"b/27207275 (%u/%zu)\", declaredSize, size);\n                             android_errorWriteLog(0x534e4554, \"27207275\");\n } else {\n                            mprotect((char*)params + allocSize - pageSize, pageSize, PROT_NONE);\n switch (code) {\n case GET_PARAMETER:\n                                    err = getParameter(node, index, params, size);\n break;\n case SET_PARAMETER:\n                                    err = setParameter(node, index, params, size);\n break;\n case GET_CONFIG:\n                                    err = getConfig(node, index, params, size);\n break;\n case SET_CONFIG:\n                                    err = setConfig(node, index, params, size);\n break;\n case SET_INTERNAL_OPTION:\n {\n InternalOptionType type =\n (InternalOptionType)data.readInt32();\n\n                                    err = setInternalOption(node, index, type, params, size);\n break;\n }\n\n default:\n                                    TRESPASS();\n }\n }\n }\n } else {\n                    ALOGE(\"couldn't map: %s\", strerror(errno));\n }\n }\n\n            reply->writeInt32(err);\n\n if ((code == GET_PARAMETER || code == GET_CONFIG) && err == OK) {\n                reply->write(params, size);\n }\n\n if (params) {\n                munmap(params, allocSize);\n }\n            params = NULL;\n\n return NO_ERROR;\n }\n\n case GET_STATE:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_STATETYPE state = OMX_StateInvalid;\n\n status_t err = getState(node, &state);\n            reply->writeInt32(state);\n            reply->writeInt32(err);\n\n return NO_ERROR;\n }\n\n case ENABLE_GRAPHIC_BUFFERS:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            OMX_BOOL enable = (OMX_BOOL)data.readInt32();\n\n status_t err = enableGraphicBuffers(node, port_index, enable);\n            reply->writeInt32(err);\n\n return NO_ERROR;\n }\n\n case GET_GRAPHIC_BUFFER_USAGE:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n\n            OMX_U32 usage = 0;\n status_t err = getGraphicBufferUsage(node, port_index, &usage);\n            reply->writeInt32(err);\n            reply->writeInt32(usage);\n\n return NO_ERROR;\n }\n\n case USE_BUFFER:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            sp<IMemory> params =\n                interface_cast<IMemory>(data.readStrongBinder());\n            OMX_U32 allottedSize = data.readInt32();\n\n            buffer_id buffer;\n status_t err = useBuffer(node, port_index, params, &buffer, allottedSize);\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->writeInt32((int32_t)buffer);\n }\n\n return NO_ERROR;\n }\n\n case USE_GRAPHIC_BUFFER:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();\n            data.read(*graphicBuffer);\n\n            buffer_id buffer;\n status_t err = useGraphicBuffer(\n                    node, port_index, graphicBuffer, &buffer);\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->writeInt32((int32_t)buffer);\n }\n\n return NO_ERROR;\n }\n\n case UPDATE_GRAPHIC_BUFFER_IN_META:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();\n            data.read(*graphicBuffer);\n            buffer_id buffer = (buffer_id)data.readInt32();\n\n status_t err = updateGraphicBufferInMeta(\n                    node, port_index, graphicBuffer, buffer);\n            reply->writeInt32(err);\n\n return NO_ERROR;\n }\n\n case CREATE_INPUT_SURFACE:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n\n            sp<IGraphicBufferProducer> bufferProducer;\n MetadataBufferType type = kMetadataBufferTypeInvalid;\n status_t err = createInputSurface(node, port_index, &bufferProducer, &type);\n\n if ((err != OK) && (type == kMetadataBufferTypeInvalid)) {\n                android_errorWriteLog(0x534e4554, \"26324358\");\n }\n\n            reply->writeInt32(type);\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->writeStrongBinder(IInterface::asBinder(bufferProducer));\n }\n\n return NO_ERROR;\n }\n\n case CREATE_PERSISTENT_INPUT_SURFACE:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            sp<IGraphicBufferProducer> bufferProducer;\n            sp<IGraphicBufferConsumer> bufferConsumer;\n status_t err = createPersistentInputSurface(\n &bufferProducer, &bufferConsumer);\n\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->writeStrongBinder(IInterface::asBinder(bufferProducer));\n                reply->writeStrongBinder(IInterface::asBinder(bufferConsumer));\n }\n\n return NO_ERROR;\n }\n\n case SET_INPUT_SURFACE:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n\n            sp<IGraphicBufferConsumer> bufferConsumer =\n                    interface_cast<IGraphicBufferConsumer>(data.readStrongBinder());\n\n MetadataBufferType type = kMetadataBufferTypeInvalid;\n status_t err = setInputSurface(node, port_index, bufferConsumer, &type);\n\n if ((err != OK) && (type == kMetadataBufferTypeInvalid)) {\n                android_errorWriteLog(0x534e4554, \"26324358\");\n }\n\n            reply->writeInt32(type);\n            reply->writeInt32(err);\n return NO_ERROR;\n }\n\n case SIGNAL_END_OF_INPUT_STREAM:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n\n status_t err = signalEndOfInputStream(node);\n            reply->writeInt32(err);\n\n return NO_ERROR;\n }\n\n case STORE_META_DATA_IN_BUFFERS:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            OMX_BOOL enable = (OMX_BOOL)data.readInt32();\n\n MetadataBufferType type = kMetadataBufferTypeInvalid;\n status_t err = storeMetaDataInBuffers(node, port_index, enable, &type);\n\n            reply->writeInt32(type);\n            reply->writeInt32(err);\n\n return NO_ERROR;\n }\n\n case PREPARE_FOR_ADAPTIVE_PLAYBACK:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            OMX_BOOL enable = (OMX_BOOL)data.readInt32();\n            OMX_U32 max_width = data.readInt32();\n            OMX_U32 max_height = data.readInt32();\n\n status_t err = prepareForAdaptivePlayback(\n                    node, port_index, enable, max_width, max_height);\n            reply->writeInt32(err);\n\n return NO_ERROR;\n }\n\n case CONFIGURE_VIDEO_TUNNEL_MODE:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            OMX_BOOL tunneled = (OMX_BOOL)data.readInt32();\n            OMX_U32 audio_hw_sync = data.readInt32();\n\n native_handle_t *sideband_handle = NULL;\n status_t err = configureVideoTunnelMode(\n                    node, port_index, tunneled, audio_hw_sync, &sideband_handle);\n            reply->writeInt32(err);\n if(err == OK){\n                reply->writeNativeHandle(sideband_handle);\n }\n\n return NO_ERROR;\n }\n\n case ALLOC_BUFFER:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n if (!isSecure(node) || port_index != 0 /* kPortIndexInput */) {\n                ALOGE(\"b/24310423\");\n                reply->writeInt32(INVALID_OPERATION);\n return NO_ERROR;\n }\n\n size_t size = data.readInt64();\n\n            buffer_id buffer;\n void *buffer_data;\n status_t err = allocateBuffer(\n                    node, port_index, size, &buffer, &buffer_data);\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->writeInt32((int32_t)buffer);\n                reply->writeInt64((uintptr_t)buffer_data);\n }\n\n return NO_ERROR;\n }\n\n case ALLOC_BUFFER_WITH_BACKUP:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            sp<IMemory> params =\n                interface_cast<IMemory>(data.readStrongBinder());\n            OMX_U32 allottedSize = data.readInt32();\n\n            buffer_id buffer;\n status_t err = allocateBufferWithBackup(\n                    node, port_index, params, &buffer, allottedSize);\n\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->writeInt32((int32_t)buffer);\n }\n\n return NO_ERROR;\n }\n\n case FREE_BUFFER:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            OMX_U32 port_index = data.readInt32();\n            buffer_id buffer = (buffer_id)data.readInt32();\n            reply->writeInt32(freeBuffer(node, port_index, buffer));\n\n return NO_ERROR;\n }\n\n case FILL_BUFFER:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            buffer_id buffer = (buffer_id)data.readInt32();\n bool haveFence = data.readInt32();\n int fenceFd = haveFence ? ::dup(data.readFileDescriptor()) : -1;\n            reply->writeInt32(fillBuffer(node, buffer, fenceFd));\n\n return NO_ERROR;\n }\n\n case EMPTY_BUFFER:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n            buffer_id buffer = (buffer_id)data.readInt32();\n            OMX_U32 range_offset = data.readInt32();\n            OMX_U32 range_length = data.readInt32();\n            OMX_U32 flags = data.readInt32();\n            OMX_TICKS timestamp = data.readInt64();\n bool haveFence = data.readInt32();\n int fenceFd = haveFence ? ::dup(data.readFileDescriptor()) : -1;\n            reply->writeInt32(emptyBuffer(\n                    node, buffer, range_offset, range_length, flags, timestamp, fenceFd));\n\n return NO_ERROR;\n }\n\n case GET_EXTENSION_INDEX:\n {\n            CHECK_OMX_INTERFACE(IOMX, data, reply);\n\n            node_id node = (node_id)data.readInt32();\n const char *parameter_name = data.readCString();\n\n            OMX_INDEXTYPE index;\n status_t err = getExtensionIndex(node, parameter_name, &index);\n\n            reply->writeInt32(err);\n\n if (err == OK) {\n                reply->writeInt32(index);\n }\n\n return OK;\n }\n\n default:\n return BBinder::onTransact(code, data, reply, flags);\n }\n}\n", "target": 1, "idx": 187820}
{"func": "  void CreateOAuth2ServiceDelegate(\n       signin::AccountConsistencyMethod account_consistency) {\n    oauth2_service_delegate_.reset(new MutableProfileOAuth2TokenServiceDelegate(\n         client_.get(), &signin_error_controller_, &account_tracker_service_,\n         token_web_data_, account_consistency, revoke_all_tokens_on_load_,\n        true /* can_revoke_credantials */));\n     base::RunLoop().RunUntilIdle();\n     oauth2_service_delegate_->AddObserver(this);\n   }\n", "target": 1, "idx": 186543}
{"func": "static void pit_do_work(struct kthread_work *work)\n{\n\tstruct kvm_pit *pit = container_of(work, struct kvm_pit, expired);\n\tstruct kvm *kvm = pit->kvm;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\tstruct kvm_kpit_state *ps = &pit->pit_state;\n\tint inject = 0;\n\n\t/* Try to inject pending interrupts when\n\t * last one has been acked.\n\t */\n\tspin_lock(&ps->inject_lock);\n\tif (ps->irq_ack) {\n\t\tps->irq_ack = 0;\n\t\tinject = 1;\n\t}\n\tspin_unlock(&ps->inject_lock);\n\tif (inject) {\n\t\tkvm_set_irq(kvm, kvm->arch.vpit->irq_source_id, 0, 1, false);\n\t\tkvm_set_irq(kvm, kvm->arch.vpit->irq_source_id, 0, 0, false);\n\n\t\t/*\n\t\t * Provides NMI watchdog support via Virtual Wire mode.\n\t\t * The route is: PIT -> PIC -> LVT0 in NMI mode.\n\t\t *\n\t\t * Note: Our Virtual Wire implementation is simplified, only\n\t\t * propagating PIT interrupts to all VCPUs when they have set\n\t\t * LVT0 to NMI delivery. Other PIC interrupts are just sent to\n\t\t * VCPU0, and only if its LVT0 is in EXTINT mode.\n\t\t */\n\t\tif (kvm->arch.vapics_in_nmi_mode > 0)\n\t\t\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\t\t\tkvm_apic_nmi_wd_deliver(vcpu);\n\t}\n}\n", "target": 0, "idx": 37717}
{"func": "GtkPolicyType webkit_web_frame_get_horizontal_scrollbar_policy(WebKitWebFrame* frame)\n{\n    g_return_val_if_fail(WEBKIT_IS_WEB_FRAME(frame), GTK_POLICY_AUTOMATIC);\n\n    Frame* coreFrame = core(frame);\n    FrameView* view = coreFrame->view();\n    if (!view)\n        return GTK_POLICY_AUTOMATIC;\n\n    ScrollbarMode hMode = view->horizontalScrollbarMode();\n\n    if (hMode == ScrollbarAlwaysOn)\n        return GTK_POLICY_ALWAYS;\n\n    if (hMode == ScrollbarAlwaysOff)\n        return GTK_POLICY_NEVER;\n\n    return GTK_POLICY_AUTOMATIC;\n}\n", "target": 0, "idx": 98387}
{"func": "PrintingContextCairo::PrintingContextCairo(const std::string& app_locale)\n#if defined(OS_CHROMEOS)\n    : PrintingContext(app_locale) {\n#else\n    : PrintingContext(app_locale),\n      print_dialog_(NULL) {\n#endif\n}\n\nPrintingContextCairo::~PrintingContextCairo() {\n  ReleaseContext();\n\n#if !defined(OS_CHROMEOS)\n  if (print_dialog_)\n    print_dialog_->ReleaseDialog();\n#endif\n}\n\n#if !defined(OS_CHROMEOS)\nvoid PrintingContextCairo::SetCreatePrintDialogFunction(\n    PrintDialogGtkInterface* (*create_dialog_func)(\n        PrintingContextCairo* context)) {\n  DCHECK(create_dialog_func);\n  DCHECK(!create_dialog_func_);\n  create_dialog_func_ = create_dialog_func;\n}\n\nvoid PrintingContextCairo::PrintDocument(const Metafile* metafile) {\n  DCHECK(print_dialog_);\n  DCHECK(metafile);\n  print_dialog_->PrintDocument(metafile, document_name_);\n}\n#endif  // !defined(OS_CHROMEOS)\n\nvoid PrintingContextCairo::AskUserForSettings(\n    gfx::NativeView parent_view,\n    int max_pages,\n    bool has_selection,\n    PrintSettingsCallback* callback) {\n#if defined(OS_CHROMEOS)\n  callback->Run(OK);\n#else\n  print_dialog_->ShowDialog(callback);\n#endif  // defined(OS_CHROMEOS)\n}\n\nPrintingContext::Result PrintingContextCairo::UseDefaultSettings() {\n  DCHECK(!in_print_job_);\n\n  ResetSettings();\n#if defined(OS_CHROMEOS)\n  int dpi = 300;\n  gfx::Size physical_size_device_units;\n  gfx::Rect printable_area_device_units;\n  int32_t width = 0;\n  int32_t height = 0;\n  UErrorCode error = U_ZERO_ERROR;\n  ulocdata_getPaperSize(app_locale_.c_str(), &height, &width, &error);\n  if (error != U_ZERO_ERROR) {\n    LOG(WARNING) << \"ulocdata_getPaperSize failed, using 8.5 x 11, error: \"\n                 << error;\n    width = static_cast<int>(8.5 * dpi);\n    height = static_cast<int>(11 * dpi);\n  } else {\n    width = static_cast<int>(ConvertUnitDouble(width, 25.4, 1.0) * dpi);\n    height = static_cast<int>(ConvertUnitDouble(height, 25.4, 1.0) * dpi);\n  }\n\n  physical_size_device_units.SetSize(width, height);\n  printable_area_device_units.SetRect(\n      static_cast<int>(PrintSettingsInitializerGtk::kLeftMarginInInch * dpi),\n      static_cast<int>(PrintSettingsInitializerGtk::kTopMarginInInch * dpi),\n      width - (PrintSettingsInitializerGtk::kLeftMarginInInch +\n          PrintSettingsInitializerGtk::kRightMarginInInch) * dpi,\n      height - (PrintSettingsInitializerGtk::kTopMarginInInch +\n          PrintSettingsInitializerGtk::kBottomMarginInInch) * dpi);\n\n  settings_.set_dpi(dpi);\n  settings_.SetPrinterPrintableArea(physical_size_device_units,\n                                    printable_area_device_units,\n                                    dpi);\n#else\n  if (!print_dialog_) {\n    print_dialog_ = create_dialog_func_(this);\n    print_dialog_->AddRefToDialog();\n  }\n  print_dialog_->UseDefaultSettings();\n#endif  // defined(OS_CHROMEOS)\n\n  return OK;\n}\n\nPrintingContext::Result PrintingContextCairo::UpdatePrinterSettings(\n    const DictionaryValue& job_settings, const PageRanges& ranges) {\n#if defined(OS_CHROMEOS)\n  bool landscape = false;\n\n  if (!job_settings.GetBoolean(kSettingLandscape, &landscape))\n    return OnError();\n\n  settings_.SetOrientation(landscape);\n  settings_.ranges = ranges;\n\n  return OK;\n #else\n   DCHECK(!in_print_job_);\n \n   if (!print_dialog_->UpdateSettings(job_settings, ranges))\n     return OnError();\n \n  return OK;\n#endif\n}\n\nPrintingContext::Result PrintingContextCairo::InitWithSettings(\n    const PrintSettings& settings) {\n  DCHECK(!in_print_job_);\n\n  settings_ = settings;\n\n  return OK;\n}\n\nPrintingContext::Result PrintingContextCairo::NewDocument(\n    const string16& document_name) {\n  DCHECK(!in_print_job_);\n  in_print_job_ = true;\n\n#if !defined(OS_CHROMEOS)\n  document_name_ = document_name;\n#endif  // !defined(OS_CHROMEOS)\n\n  return OK;\n}\n\nPrintingContext::Result PrintingContextCairo::NewPage() {\n  if (abort_printing_)\n    return CANCEL;\n  DCHECK(in_print_job_);\n\n\n  return OK;\n}\n\nPrintingContext::Result PrintingContextCairo::PageDone() {\n  if (abort_printing_)\n    return CANCEL;\n  DCHECK(in_print_job_);\n\n\n  return OK;\n}\n\nPrintingContext::Result PrintingContextCairo::DocumentDone() {\n  if (abort_printing_)\n    return CANCEL;\n  DCHECK(in_print_job_);\n\n  ResetSettings();\n  return OK;\n}\n\nvoid PrintingContextCairo::Cancel() {\n  abort_printing_ = true;\n  in_print_job_ = false;\n}\n\nvoid PrintingContextCairo::ReleaseContext() {\n}\n\ngfx::NativeDrawingContext PrintingContextCairo::context() const {\n  return NULL;\n}\n\n}  // namespace printing\n", "target": 1, "idx": 183705}
{"func": "void SpeechSynthesis::trace(Visitor* visitor)\n{\n    visitor->trace(m_voiceList);\n    visitor->trace(m_utteranceQueue);\n}\n", "target": 0, "idx": 129906}
{"func": "long long Segment::ParseHeaders() {\n long long total, available;\n\n const int status = m_pReader->Length(&total, &available);\n\n\n   if (status < 0)  // error\n     return status;\n \n  assert((total < 0) || (available <= total));\n \n   const long long segment_stop = (m_size < 0) ? -1 : m_start + m_size;\n  assert((segment_stop < 0) || (total < 0) || (segment_stop <= total));\n  assert((segment_stop < 0) || (m_pos <= segment_stop));\n \n   for (;;) {\n     if ((total >= 0) && (m_pos >= total))\n break;\n\n if ((segment_stop >= 0) && (m_pos >= segment_stop))\n break;\n\n\n     long long pos = m_pos;\n     const long long element_start = pos;\n \n     if ((pos + 1) > available)\n       return (pos + 1);\n \n long len;\n long long result = GetUIntLength(m_pReader, pos, len);\n\n\n     if (result < 0)  // error\n       return result;\n \n    if (result > 0)  // underflow (weird)\n       return (pos + 1);\n \n     if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n       return E_FILE_FORMAT_INVALID;\n\n if ((pos + len) > available)\n\n       return pos + len;\n \n     const long long idpos = pos;\n    const long long id = ReadUInt(m_pReader, idpos, len);\n \n    if (id < 0)  // error\n      return id;\n \n     if (id == 0x0F43B675)  // Cluster ID\n       break;\n\n    pos += len; // consume ID\n\n if ((pos + 1) > available)\n return (pos + 1);\n\n    result = GetUIntLength(m_pReader, pos, len);\n\n\n     if (result < 0)  // error\n       return result;\n \n    if (result > 0)  // underflow (weird)\n       return (pos + 1);\n \n     if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n       return E_FILE_FORMAT_INVALID;\n\n if ((pos + len) > available)\n return pos + len;\n\n \n     const long long size = ReadUInt(m_pReader, pos, len);\n \n    if (size < 0)  // error\n       return size;\n \n     pos += len;  // consume length of size of element\n \n     const long long element_size = size + pos - element_start;\n \n\n if ((segment_stop >= 0) && ((pos + size) > segment_stop))\n return E_FILE_FORMAT_INVALID;\n\n\n if ((pos + size) > available)\n return pos + size;\n\n if (id == 0x0549A966) { // Segment Info ID\n if (m_pInfo)\n return E_FILE_FORMAT_INVALID;\n\n      m_pInfo = new (std::nothrow)\n SegmentInfo(this, pos, size, element_start, element_size);\n\n if (m_pInfo == NULL)\n return -1;\n\n const long status = m_pInfo->Parse();\n\n if (status)\n return status;\n } else if (id == 0x0654AE6B) { // Tracks ID\n if (m_pTracks)\n return E_FILE_FORMAT_INVALID;\n\n      m_pTracks = new (std::nothrow)\n Tracks(this, pos, size, element_start, element_size);\n\n if (m_pTracks == NULL)\n return -1;\n\n const long status = m_pTracks->Parse();\n\n if (status)\n return status;\n } else if (id == 0x0C53BB6B) { // Cues ID\n if (m_pCues == NULL) {\n        m_pCues = new (std::nothrow)\n Cues(this, pos, size, element_start, element_size);\n\n if (m_pCues == NULL)\n return -1;\n }\n } else if (id == 0x014D9B74) { // SeekHead ID\n if (m_pSeekHead == NULL) {\n        m_pSeekHead = new (std::nothrow)\n SeekHead(this, pos, size, element_start, element_size);\n\n if (m_pSeekHead == NULL)\n return -1;\n\n const long status = m_pSeekHead->Parse();\n\n if (status)\n return status;\n }\n } else if (id == 0x0043A770) { // Chapters ID\n if (m_pChapters == NULL) {\n        m_pChapters = new (std::nothrow)\n Chapters(this, pos, size, element_start, element_size);\n\n if (m_pChapters == NULL)\n return -1;\n\n const long status = m_pChapters->Parse();\n\n\n         if (status)\n           return status;\n       }\n     }\n \n     m_pos = pos + size;  // consume payload\n   }\n \n  assert((segment_stop < 0) || (m_pos <= segment_stop));\n \n   if (m_pInfo == NULL)  // TODO: liberalize this behavior\n     return E_FILE_FORMAT_INVALID;\n\n if (m_pTracks == NULL)\n return E_FILE_FORMAT_INVALID;\n\n return 0; // success\n}\n", "target": 1, "idx": 187878}
{"func": "l2tp_framing_type_print(netdissect_options *ndo, const u_char *dat)\n {\n \tconst uint32_t *ptr = (const uint32_t *)dat;\n \n \tif (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_TYPE_ASYNC_MASK) {\n \t\tND_PRINT((ndo, \"A\"));\n \t}\n\tif (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_TYPE_SYNC_MASK) {\n\t\tND_PRINT((ndo, \"S\"));\n\t}\n}\n", "target": 1, "idx": 181067}
{"func": "void GaiaCookieManagerService::ForceOnCookieChangedProcessing() {\n  GURL google_url = GaiaUrls::GetInstance()->google_url();\n  std::unique_ptr<net::CanonicalCookie> cookie(net::CanonicalCookie::Create(\n      google_url, kGaiaCookieName, std::string(), \".\" + google_url.host(),\n      std::string(), base::Time(), base::Time(), false, false,\n      net::CookieSameSite::DEFAULT_MODE, false, net::COOKIE_PRIORITY_DEFAULT));\n  OnCookieChanged(*cookie, net::CookieStore::ChangeCause::UNKNOWN_DELETION);\n}\n", "target": 0, "idx": 140173}
{"func": "gamma_component_validate(PNG_CONST char *name, PNG_CONST validate_info *vi,\n    PNG_CONST unsigned int id, PNG_CONST unsigned int od,\n    PNG_CONST double alpha /* <0 for the alpha channel itself */,\n    PNG_CONST double background /* component background value */)\n {\n   PNG_CONST unsigned int isbit = id >> vi->isbit_shift;\n   PNG_CONST unsigned int sbit_max = vi->sbit_max;\n   PNG_CONST unsigned int outmax = vi->outmax;\n   PNG_CONST int do_background = vi->do_background;\n \n    double i;\n \n /* First check on the 'perfect' result obtained from the digitized input\n    * value, id, and compare this against the actual digitized result, 'od'.\n    * 'i' is the input result in the range 0..1:\n    */\n   i = isbit; i /= sbit_max;\n\n /* Check for the fast route: if we don't do any background composition or if\n    * this is the alpha channel ('alpha' < 0) or if the pixel is opaque then\n    * just use the gamma_correction field to correct to the final output gamma.\n    */\n if (alpha == 1 /* opaque pixel component */ || !do_background\n#ifdef PNG_READ_ALPHA_MODE_SUPPORTED\n || do_background == ALPHA_MODE_OFFSET + PNG_ALPHA_PNG\n#endif\n || (alpha < 0 /* alpha channel */\n#ifdef PNG_READ_ALPHA_MODE_SUPPORTED\n && do_background != ALPHA_MODE_OFFSET + PNG_ALPHA_BROKEN\n#endif\n ))\n {\n /* Then get the gamma corrected version of 'i' and compare to 'od', any\n       * error less than .5 is insignificant - just quantization of the output\n       * value to the nearest digital value (nevertheless the error is still\n       * recorded - it's interesting ;-)\n       */\n double encoded_sample = i;\n double encoded_error;\n\n /* alpha less than 0 indicates the alpha channel, which is always linear\n       */\n if (alpha >= 0 && vi->gamma_correction > 0)\n         encoded_sample = pow(encoded_sample, vi->gamma_correction);\n      encoded_sample *= outmax;\n\n      encoded_error = fabs(od-encoded_sample);\n\n if (encoded_error > vi->dp->maxerrout)\n         vi->dp->maxerrout = encoded_error;\n\n if (encoded_error < vi->maxout_total && encoded_error < vi->outlog)\n return i;\n }\n\n /* The slow route - attempt to do linear calculations. */\n /* There may be an error, or background processing is required, so calculate\n    * the actual sample values - unencoded light intensity values.  Note that in\n    * practice these are not completely unencoded because they include a\n    * 'viewing correction' to decrease or (normally) increase the perceptual\n    * contrast of the image.  There's nothing we can do about this - we don't\n    * know what it is - so assume the unencoded value is perceptually linear.\n    */\n {\n double input_sample = i; /* In range 0..1 */\n double output, error, encoded_sample, encoded_error;\n double es_lo, es_hi;\n int compose = 0; /* Set to one if composition done */\n int output_is_encoded; /* Set if encoded to screen gamma */\n int log_max_error = 1; /* Check maximum error values */\n      png_const_charp pass = 0; /* Reason test passes (or 0 for fail) */\n\n /* Convert to linear light (with the above caveat.)  The alpha channel is\n       * already linear.\n       */\n if (alpha >= 0)\n {\n int tcompose;\n\n if (vi->file_inverse > 0)\n            input_sample = pow(input_sample, vi->file_inverse);\n\n /* Handle the compose processing: */\n         tcompose = 0;\n         input_sample = gamma_component_compose(do_background, input_sample,\n            alpha, background, &tcompose);\n\n if (tcompose)\n            compose = 1;\n }\n\n /* And similarly for the output value, but we need to check the background\n       * handling to linearize it correctly.\n       */\n      output = od;\n      output /= outmax;\n\n      output_is_encoded = vi->screen_gamma > 0;\n\n if (alpha < 0) /* The alpha channel */\n {\n#ifdef PNG_READ_ALPHA_MODE_SUPPORTED\n if (do_background != ALPHA_MODE_OFFSET + PNG_ALPHA_BROKEN)\n#endif\n {\n /* In all other cases the output alpha channel is linear already,\n             * don't log errors here, they are much larger in linear data.\n             */\n            output_is_encoded = 0;\n            log_max_error = 0;\n }\n }\n\n#ifdef PNG_READ_ALPHA_MODE_SUPPORTED\n else /* A component */\n {\n if (do_background == ALPHA_MODE_OFFSET + PNG_ALPHA_OPTIMIZED &&\n            alpha < 1) /* the optimized case - linear output */\n {\n if (alpha > 0) log_max_error = 0;\n            output_is_encoded = 0;\n }\n }\n#endif\n\n if (output_is_encoded)\n         output = pow(output, vi->screen_gamma);\n\n /* Calculate (or recalculate) the encoded_sample value and repeat the\n       * check above (unnecessary if we took the fast route, but harmless.)\n       */\n      encoded_sample = input_sample;\n if (output_is_encoded)\n         encoded_sample = pow(encoded_sample, vi->screen_inverse);\n      encoded_sample *= outmax;\n\n      encoded_error = fabs(od-encoded_sample);\n\n /* Don't log errors in the alpha channel, or the 'optimized' case,\n       * neither are significant to the overall perception.\n       */\n if (log_max_error && encoded_error > vi->dp->maxerrout)\n         vi->dp->maxerrout = encoded_error;\n\n if (encoded_error < vi->maxout_total)\n {\n if (encoded_error < vi->outlog)\n return i;\n\n /* Test passed but error is bigger than the log limit, record why the\n          * test passed:\n          */\n         pass = \"less than maxout:\\n\";\n }\n\n /* i: the original input value in the range 0..1\n       *\n       * pngvalid calculations:\n       *  input_sample: linear result; i linearized and composed, range 0..1\n       *  encoded_sample: encoded result; input_sample scaled to ouput bit depth\n       *\n       * libpng calculations:\n       *  output: linear result; od scaled to 0..1 and linearized\n       *  od: encoded result from libpng\n       */\n\n /* Now we have the numbers for real errors, both absolute values as as a\n       * percentage of the correct value (output):\n       */\n      error = fabs(input_sample-output);\n\n if (log_max_error && error > vi->dp->maxerrabs)\n         vi->dp->maxerrabs = error;\n\n /* The following is an attempt to ignore the tendency of quantization to\n       * dominate the percentage errors for lower result values:\n       */\n if (log_max_error && input_sample > .5)\n {\n double percentage_error = error/input_sample;\n if (percentage_error > vi->dp->maxerrpc)\n            vi->dp->maxerrpc = percentage_error;\n }\n\n /* Now calculate the digitization limits for 'encoded_sample' using the\n       * 'max' values.  Note that maxout is in the encoded space but maxpc and\n       * maxabs are in linear light space.\n       *\n       * First find the maximum error in linear light space, range 0..1:\n       */\n {\n double tmp = input_sample * vi->maxpc;\n if (tmp < vi->maxabs) tmp = vi->maxabs;\n /* If 'compose' is true the composition was done in linear space using\n          * integer arithmetic.  This introduces an extra error of +/- 0.5 (at\n          * least) in the integer space used.  'maxcalc' records this, taking\n          * into account the possibility that even for 16 bit output 8 bit space\n          * may have been used.\n          */\n if (compose && tmp < vi->maxcalc) tmp = vi->maxcalc;\n\n /* The 'maxout' value refers to the encoded result, to compare with\n          * this encode input_sample adjusted by the maximum error (tmp) above.\n          */\n         es_lo = encoded_sample - vi->maxout;\n\n if (es_lo > 0 && input_sample-tmp > 0)\n {\n double low_value = input_sample-tmp;\n if (output_is_encoded)\n               low_value = pow(low_value, vi->screen_inverse);\n            low_value *= outmax;\n if (low_value < es_lo) es_lo = low_value;\n\n /* Quantize this appropriately: */\n            es_lo = ceil(es_lo / vi->outquant - .5) * vi->outquant;\n }\n\n else\n            es_lo = 0;\n\n         es_hi = encoded_sample + vi->maxout;\n\n if (es_hi < outmax && input_sample+tmp < 1)\n {\n double high_value = input_sample+tmp;\n if (output_is_encoded)\n               high_value = pow(high_value, vi->screen_inverse);\n            high_value *= outmax;\n if (high_value > es_hi) es_hi = high_value;\n\n            es_hi = floor(es_hi / vi->outquant + .5) * vi->outquant;\n }\n\n else\n            es_hi = outmax;\n }\n\n /* The primary test is that the final encoded value returned by the\n       * library should be between the two limits (inclusive) that were\n       * calculated above.\n       */\n if (od >= es_lo && od <= es_hi)\n {\n /* The value passes, but we may need to log the information anyway. */\n if (encoded_error < vi->outlog)\n return i;\n\n if (pass == 0)\n            pass = \"within digitization limits:\\n\";\n }\n\n {\n /* There has been an error in processing, or we need to log this\n          * value.\n          */\n double is_lo, is_hi;\n\n /* pass is set at this point if either of the tests above would have\n          * passed.  Don't do these additional tests here - just log the\n          * original [es_lo..es_hi] values.\n          */\n if (pass == 0 && vi->use_input_precision && vi->dp->sbit)\n {\n /* Ok, something is wrong - this actually happens in current libpng\n             * 16-to-8 processing.  Assume that the input value (id, adjusted\n             * for sbit) can be anywhere between value-.5 and value+.5 - quite a\n             * large range if sbit is low.\n             *\n             * NOTE: at present because the libpng gamma table stuff has been\n             * changed to use a rounding algorithm to correct errors in 8-bit\n             * calculations the precise sbit calculation (a shift) has been\n             * lost.  This can result in up to a +/-1 error in the presence of\n             * an sbit less than the bit depth.\n             */\n#           if PNG_LIBPNG_VER < 10700\n#              define SBIT_ERROR .5\n#           else\n#              define SBIT_ERROR 1.\n#           endif\n double tmp = (isbit - SBIT_ERROR)/sbit_max;\n\n if (tmp <= 0)\n               tmp = 0;\n\n else if (alpha >= 0 && vi->file_inverse > 0 && tmp < 1)\n               tmp = pow(tmp, vi->file_inverse);\n\n            tmp = gamma_component_compose(do_background, tmp, alpha, background,\n               NULL);\n\n if (output_is_encoded && tmp > 0 && tmp < 1)\n               tmp = pow(tmp, vi->screen_inverse);\n\n            is_lo = ceil(outmax * tmp - vi->maxout_total);\n\n if (is_lo < 0)\n               is_lo = 0;\n\n            tmp = (isbit + SBIT_ERROR)/sbit_max;\n\n if (tmp >= 1)\n               tmp = 1;\n\n else if (alpha >= 0 && vi->file_inverse > 0 && tmp < 1)\n               tmp = pow(tmp, vi->file_inverse);\n\n            tmp = gamma_component_compose(do_background, tmp, alpha, background,\n               NULL);\n\n if (output_is_encoded && tmp > 0 && tmp < 1)\n               tmp = pow(tmp, vi->screen_inverse);\n\n            is_hi = floor(outmax * tmp + vi->maxout_total);\n\n if (is_hi > outmax)\n               is_hi = outmax;\n\n if (!(od < is_lo || od > is_hi))\n {\n if (encoded_error < vi->outlog)\n return i;\n\n               pass = \"within input precision limits:\\n\";\n }\n\n /* One last chance.  If this is an alpha channel and the 16to8\n             * option has been used and 'inaccurate' scaling is used then the\n             * bit reduction is obtained by simply using the top 8 bits of the\n             * value.\n             *\n             * This is only done for older libpng versions when the 'inaccurate'\n             * (chop) method of scaling was used.\n             */\n#           ifndef PNG_READ_16_TO_8_ACCURATE_SCALE_SUPPORTED\n#              if PNG_LIBPNG_VER < 10504\n /* This may be required for other components in the future,\n                   * but at present the presence of gamma correction effectively\n                   * prevents the errors in the component scaling (I don't quite\n                   * understand why, but since it's better this way I care not\n                   * to ask, JB 20110419.)\n                   */\n if (pass == 0 && alpha < 0 && vi->scale16 && vi->sbit > 8 &&\n                     vi->sbit + vi->isbit_shift == 16)\n {\n                     tmp = ((id >> 8) - .5)/255;\n\n if (tmp > 0)\n {\n                        is_lo = ceil(outmax * tmp - vi->maxout_total);\n if (is_lo < 0) is_lo = 0;\n }\n\n else\n                        is_lo = 0;\n\n                     tmp = ((id >> 8) + .5)/255;\n\n if (tmp < 1)\n {\n                        is_hi = floor(outmax * tmp + vi->maxout_total);\n if (is_hi > outmax) is_hi = outmax;\n }\n\n else\n                        is_hi = outmax;\n\n if (!(od < is_lo || od > is_hi))\n {\n if (encoded_error < vi->outlog)\n return i;\n\n                        pass = \"within 8 bit limits:\\n\";\n }\n }\n#              endif\n#           endif\n }\n else /* !use_input_precision */\n            is_lo = es_lo, is_hi = es_hi;\n\n /* Attempt to output a meaningful error/warning message: the message\n          * output depends on the background/composite operation being performed\n          * because this changes what parameters were actually used above.\n          */\n {\n size_t pos = 0;\n /* Need either 1/255 or 1/65535 precision here; 3 or 6 decimal\n             * places.  Just use outmax to work out which.\n             */\n int precision = (outmax >= 1000 ? 6 : 3);\n int use_input=1, use_background=0, do_compose=0;\n char msg[256];\n\n if (pass != 0)\n               pos = safecat(msg, sizeof msg, pos, \"\\n\\t\");\n\n /* Set up the various flags, the output_is_encoded flag above\n             * is also used below.  do_compose is just a double check.\n             */\n switch (do_background)\n {\n#           ifdef PNG_READ_BACKGROUND_SUPPORTED\n case PNG_BACKGROUND_GAMMA_SCREEN:\n case PNG_BACKGROUND_GAMMA_FILE:\n case PNG_BACKGROUND_GAMMA_UNIQUE:\n                  use_background = (alpha >= 0 && alpha < 1);\n /*FALL THROUGH*/\n#           endif\n#           ifdef PNG_READ_ALPHA_MODE_SUPPORTED\n case ALPHA_MODE_OFFSET + PNG_ALPHA_STANDARD:\n case ALPHA_MODE_OFFSET + PNG_ALPHA_BROKEN:\n case ALPHA_MODE_OFFSET + PNG_ALPHA_OPTIMIZED:\n#           endif /* ALPHA_MODE_SUPPORTED */\n               do_compose = (alpha > 0 && alpha < 1);\n               use_input = (alpha != 0);\n break;\n\n default:\n break;\n }\n\n /* Check the 'compose' flag */\n if (compose != do_compose)\n               png_error(vi->pp, \"internal error (compose)\");\n\n /* 'name' is the component name */\n            pos = safecat(msg, sizeof msg, pos, name);\n            pos = safecat(msg, sizeof msg, pos, \"(\");\n            pos = safecatn(msg, sizeof msg, pos, id);\n if (use_input || pass != 0/*logging*/)\n {\n if (isbit != id)\n {\n /* sBIT has reduced the precision of the input: */\n                  pos = safecat(msg, sizeof msg, pos, \", sbit(\");\n                  pos = safecatn(msg, sizeof msg, pos, vi->sbit);\n                  pos = safecat(msg, sizeof msg, pos, \"): \");\n                  pos = safecatn(msg, sizeof msg, pos, isbit);\n }\n               pos = safecat(msg, sizeof msg, pos, \"/\");\n /* The output is either \"id/max\" or \"id sbit(sbit): isbit/max\" */\n               pos = safecatn(msg, sizeof msg, pos, vi->sbit_max);\n }\n            pos = safecat(msg, sizeof msg, pos, \")\");\n\n /* A component may have been multiplied (in linear space) by the\n             * alpha value, 'compose' says whether this is relevant.\n             */\n if (compose || pass != 0)\n {\n /* If any form of composition is being done report our\n                * calculated linear value here (the code above doesn't record\n                * the input value before composition is performed, so what\n                * gets reported is the value after composition.)\n                */\n if (use_input || pass != 0)\n {\n if (vi->file_inverse > 0)\n {\n                     pos = safecat(msg, sizeof msg, pos, \"^\");\n                     pos = safecatd(msg, sizeof msg, pos, vi->file_inverse, 2);\n }\n\n else\n                     pos = safecat(msg, sizeof msg, pos, \"[linear]\");\n\n                  pos = safecat(msg, sizeof msg, pos, \"*(alpha)\");\n                  pos = safecatd(msg, sizeof msg, pos, alpha, precision);\n }\n\n /* Now record the *linear* background value if it was used\n                * (this function is not passed the original, non-linear,\n                * value but it is contained in the test name.)\n                */\n if (use_background)\n {\n                  pos = safecat(msg, sizeof msg, pos, use_input ? \"+\" : \" \");\n                  pos = safecat(msg, sizeof msg, pos, \"(background)\");\n                  pos = safecatd(msg, sizeof msg, pos, background, precision);\n                  pos = safecat(msg, sizeof msg, pos, \"*\");\n                  pos = safecatd(msg, sizeof msg, pos, 1-alpha, precision);\n }\n }\n\n /* Report the calculated value (input_sample) and the linearized\n             * libpng value (output) unless this is just a component gamma\n             * correction.\n             */\n if (compose || alpha < 0 || pass != 0)\n {\n               pos = safecat(msg, sizeof msg, pos,\n                  pass != 0 ? \" =\\n\\t\" : \" = \");\n               pos = safecatd(msg, sizeof msg, pos, input_sample, precision);\n               pos = safecat(msg, sizeof msg, pos, \" (libpng: \");\n               pos = safecatd(msg, sizeof msg, pos, output, precision);\n               pos = safecat(msg, sizeof msg, pos, \")\");\n\n /* Finally report the output gamma encoding, if any. */\n if (output_is_encoded)\n {\n                  pos = safecat(msg, sizeof msg, pos, \" ^\");\n                  pos = safecatd(msg, sizeof msg, pos, vi->screen_inverse, 2);\n                  pos = safecat(msg, sizeof msg, pos, \"(to screen) =\");\n }\n\n else\n                  pos = safecat(msg, sizeof msg, pos, \" [screen is linear] =\");\n }\n\n if ((!compose && alpha >= 0) || pass != 0)\n {\n if (pass != 0) /* logging */\n                  pos = safecat(msg, sizeof msg, pos, \"\\n\\t[overall:\");\n\n /* This is the non-composition case, the internal linear\n                * values are irrelevant (though the log below will reveal\n                * them.)  Output a much shorter warning/error message and report\n                * the overall gamma correction.\n                */\n if (vi->gamma_correction > 0)\n {\n                  pos = safecat(msg, sizeof msg, pos, \" ^\");\n                  pos = safecatd(msg, sizeof msg, pos, vi->gamma_correction, 2);\n                  pos = safecat(msg, sizeof msg, pos, \"(gamma correction) =\");\n }\n\n else\n                  pos = safecat(msg, sizeof msg, pos,\n \" [no gamma correction] =\");\n\n if (pass != 0)\n                  pos = safecat(msg, sizeof msg, pos, \"]\");\n }\n\n /* This is our calculated encoded_sample which should (but does\n             * not) match od:\n             */\n            pos = safecat(msg, sizeof msg, pos, pass != 0 ? \"\\n\\t\" : \" \");\n            pos = safecatd(msg, sizeof msg, pos, is_lo, 1);\n            pos = safecat(msg, sizeof msg, pos, \" < \");\n            pos = safecatd(msg, sizeof msg, pos, encoded_sample, 1);\n            pos = safecat(msg, sizeof msg, pos, \" (libpng: \");\n            pos = safecatn(msg, sizeof msg, pos, od);\n            pos = safecat(msg, sizeof msg, pos, \")\");\n            pos = safecat(msg, sizeof msg, pos, \"/\");\n            pos = safecatn(msg, sizeof msg, pos, outmax);\n            pos = safecat(msg, sizeof msg, pos, \" < \");\n            pos = safecatd(msg, sizeof msg, pos, is_hi, 1);\n\n if (pass == 0) /* The error condition */\n {\n#              ifdef PNG_WARNINGS_SUPPORTED\n                  png_warning(vi->pp, msg);\n#              else\n                  store_warning(vi->pp, msg);\n#              endif\n }\n\n else /* logging this value */\n               store_verbose(&vi->dp->pm->this, vi->pp, pass, msg);\n }\n }\n }\n\n return i;\n}\n", "target": 1, "idx": 187631}
{"func": "size_t ndp_msg_payload_len(struct ndp_msg *msg)\n{\n\treturn msg->len;\n}\n", "target": 0, "idx": 53945}
{"func": "long long mkvparser::ReadUInt(IMkvReader* pReader, long long pos, long& len) {\n  assert(pReader);\n  assert(pos >= 0);\n  int status;\n \n   len = 1;\n   unsigned char b;\n  status = pReader->Read(pos, 1, &b);\n \n   if (status < 0)  // error or underflow\n     return status;\n\n if (status > 0) // interpreted as \"underflow\"\n return E_BUFFER_NOT_FULL;\n\n if (b == 0) // we can't handle u-int values larger than 8 bytes\n return E_FILE_FORMAT_INVALID;\n\n unsigned char m = 0x80;\n\n while (!(b & m)) {\n    m >>= 1;\n\n     ++len;\n   }\n \n   long long result = b & (~m);\n   ++pos;\n \n for (int i = 1; i < len; ++i) {\n    status = pReader->Read(pos, 1, &b);\n\n if (status < 0) {\n      len = 1;\n return status;\n }\n\n if (status > 0) {\n      len = 1;\n return E_BUFFER_NOT_FULL;\n }\n\n    result <<= 8;\n    result |= b;\n\n ++pos;\n }\n\n\n   return result;\n }\n", "target": 1, "idx": 187884}
{"func": "static void do_pf_read(void)\n{\n\tps_set_intr(do_pf_read_start, NULL, 0, nice);\n}\n", "target": 0, "idx": 87993}
{"func": "void CheckNodeValue(const BaseNode& node, const DictionaryValue& value,\n                    bool is_detailed) {\n  ExpectInt64Value(node.GetId(), value, \"id\");\n  {\n    bool is_folder = false;\n    EXPECT_TRUE(value.GetBoolean(\"isFolder\", &is_folder));\n    EXPECT_EQ(node.GetIsFolder(), is_folder);\n  }\n  ExpectDictStringValue(node.GetTitle(), value, \"title\");\n  {\n    ModelType expected_model_type = node.GetModelType();\n    std::string type_str;\n    EXPECT_TRUE(value.GetString(\"type\", &type_str));\n    if (expected_model_type >= syncable::FIRST_REAL_MODEL_TYPE) {\n      ModelType model_type =\n          syncable::ModelTypeFromString(type_str);\n      EXPECT_EQ(expected_model_type, model_type);\n    } else if (expected_model_type == syncable::TOP_LEVEL_FOLDER) {\n      EXPECT_EQ(\"Top-level folder\", type_str);\n    } else if (expected_model_type == syncable::UNSPECIFIED) {\n      EXPECT_EQ(\"Unspecified\", type_str);\n    } else {\n      ADD_FAILURE();\n    }\n   }\n   if (is_detailed) {\n     ExpectInt64Value(node.GetParentId(), value, \"parentId\");\n    ExpectTimeValue(node.GetModificationTime(), value, \"modificationTime\");\n     ExpectInt64Value(node.GetExternalId(), value, \"externalId\");\n     ExpectInt64Value(node.GetPredecessorId(), value, \"predecessorId\");\n     ExpectInt64Value(node.GetSuccessorId(), value, \"successorId\");\n    ExpectInt64Value(node.GetFirstChildId(), value, \"firstChildId\");\n    {\n      scoped_ptr<DictionaryValue> expected_entry(node.GetEntry()->ToValue());\n      Value* entry = NULL;\n      EXPECT_TRUE(value.Get(\"entry\", &entry));\n      EXPECT_TRUE(Value::Equals(entry, expected_entry.get()));\n    }\n    EXPECT_EQ(11u, value.size());\n  } else {\n    EXPECT_EQ(4u, value.size());\n  }\n}\n", "target": 1, "idx": 183663}
{"func": "content::ColorChooser* ShowColorChooser(content::WebContents* web_contents,\n                                        SkColor initial_color) {\n#if defined(USE_ASH)\n  gfx::NativeView native_view = web_contents->GetView()->GetNativeView();\n  if (GetHostDesktopTypeForNativeView(native_view) == HOST_DESKTOP_TYPE_ASH)\n    return ColorChooserAura::Open(web_contents, initial_color);\n#endif\n  return ColorChooserWin::Open(web_contents, initial_color);\n}\n", "target": 0, "idx": 133532}
{"func": "static bool generic_pkt_to_tuple(const struct sk_buff *skb,\n\t\t\t\t unsigned int dataoff,\n\t\t\t\t struct nf_conntrack_tuple *tuple)\n{\n\ttuple->src.u.all = 0;\n\ttuple->dst.u.all = 0;\n\n\treturn true;\n}\n", "target": 0, "idx": 46222}
{"func": "static bool net_tx_pkt_do_sw_fragmentation(struct NetTxPkt *pkt,\n    NetClientState *nc)\n{\n    struct iovec fragment[NET_MAX_FRAG_SG_LIST];\n    size_t fragment_len = 0;\n    bool more_frags = false;\n\n    /* some pointers for shorter code */\n    void *l2_iov_base, *l3_iov_base;\n    size_t l2_iov_len, l3_iov_len;\n    int src_idx =  NET_TX_PKT_PL_START_FRAG, dst_idx;\n    size_t src_offset = 0;\n    size_t fragment_offset = 0;\n\n    l2_iov_base = pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_base;\n    l2_iov_len = pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len;\n    l3_iov_base = pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_base;\n    l3_iov_len = pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_len;\n\n    /* Copy headers */\n    fragment[NET_TX_PKT_FRAGMENT_L2_HDR_POS].iov_base = l2_iov_base;\n    fragment[NET_TX_PKT_FRAGMENT_L2_HDR_POS].iov_len = l2_iov_len;\n    fragment[NET_TX_PKT_FRAGMENT_L3_HDR_POS].iov_base = l3_iov_base;\n    fragment[NET_TX_PKT_FRAGMENT_L3_HDR_POS].iov_len = l3_iov_len;\n\n\n    /* Put as much data as possible and send */\n    do {\n        fragment_len = net_tx_pkt_fetch_fragment(pkt, &src_idx, &src_offset,\n            fragment, &dst_idx);\n\n        more_frags = (fragment_offset + fragment_len < pkt->payload_len);\n\n        eth_setup_ip4_fragmentation(l2_iov_base, l2_iov_len, l3_iov_base,\n            l3_iov_len, fragment_len, fragment_offset, more_frags);\n\n        eth_fix_ip4_checksum(l3_iov_base, l3_iov_len);\n\n        net_tx_pkt_sendv(pkt, nc, fragment, dst_idx);\n\n        fragment_offset += fragment_len;\n\n    } while (fragment_len && more_frags);\n\n    return true;\n}\n", "target": 0, "idx": 8955}
{"func": "_dbus_get_autolaunch_address (const char *scope, DBusString *address,\n                              DBusError *error)\n{\n  HANDLE mutex;\n  STARTUPINFOA si;\n  PROCESS_INFORMATION pi;\n  dbus_bool_t retval = FALSE;\n  LPSTR lpFile;\n  char dbus_exe_path[MAX_PATH];\n  char dbus_args[MAX_PATH * 2];\n  const char * daemon_name = DBUS_DAEMON_NAME \".exe\";\n  DBusString shm_name;\n\n  _DBUS_ASSERT_ERROR_IS_CLEAR (error);\n\n  if (!_dbus_get_shm_name(&shm_name,scope))\n    {\n        dbus_set_error_const (error, DBUS_ERROR_FAILED, \"could not determine shm name\");\n        return FALSE;\n    }\n\n  mutex = _dbus_global_lock ( cDBusAutolaunchMutex );\n\n  if (_dbus_daemon_already_runs(address,&shm_name,scope))\n    {\n        _dbus_verbose( \"found running dbus daemon at %s\\n\",\n                       _dbus_string_get_const_data (&shm_name) );\n        retval = TRUE;\n        goto out;\n    }\n\n  if (!SearchPathA(NULL, daemon_name, NULL, sizeof(dbus_exe_path), dbus_exe_path, &lpFile))\n    {\n      HMODULE hmod;\n      char dbus_module_path[MAX_PATH];\n      DWORD rc;\n\n      _dbus_verbose( \"did not found dbus daemon executable on default search path, \"\n            \"trying path where dbus shared library is located\");\n\n      hmod = _dbus_win_get_dll_hmodule();\n      rc = GetModuleFileNameA(hmod, dbus_module_path, sizeof(dbus_module_path));\n      if (rc <= 0)\n        {\n          dbus_set_error_const (error, DBUS_ERROR_FAILED, \"could not retrieve dbus shared library file name\");\n          retval = FALSE;\n          goto out;\n        }\n      else\n        {\n          char *ext_idx = strrchr(dbus_module_path, '\\\\');\n          if (ext_idx)\n          *ext_idx = '\\0';\n          if (!SearchPathA(dbus_module_path, daemon_name, NULL, sizeof(dbus_exe_path), dbus_exe_path, &lpFile))\n            {\n              dbus_set_error_const (error, DBUS_ERROR_FAILED, \"could not find dbus-daemon executable\");\n              retval = FALSE;\n              printf (\"please add the path to %s to your PATH environment variable\\n\", daemon_name);\n              printf (\"or start the daemon manually\\n\\n\");\n              goto out;\n            }\n          _dbus_verbose( \"found dbus daemon executable at %s\",dbus_module_path);\n        }\n    }\n\n\n  ZeroMemory( &si, sizeof(si) );\n  si.cb = sizeof(si);\n  ZeroMemory( &pi, sizeof(pi) );\n\n  _snprintf(dbus_args, sizeof(dbus_args) - 1, \"\\\"%s\\\" %s\", dbus_exe_path,  \" --session\");\n\n  if(CreateProcessA(dbus_exe_path, dbus_args, NULL, NULL, FALSE, CREATE_NO_WINDOW, NULL, NULL, &si, &pi))\n    {\n      CloseHandle (pi.hThread);\n      CloseHandle (pi.hProcess);\n      retval = _dbus_get_autolaunch_shm( address, &shm_name );\n      if (retval == FALSE)\n        dbus_set_error_const (error, DBUS_ERROR_FAILED, \"Failed to get autolaunch address from launched dbus-daemon\");\n    }\n  else\n    {\n      dbus_set_error_const (error, DBUS_ERROR_FAILED, \"Failed to launch dbus-daemon\");\n      retval = FALSE;\n    }\n\nout:\n  if (retval)\n    _DBUS_ASSERT_ERROR_IS_CLEAR (error);\n  else\n    _DBUS_ASSERT_ERROR_IS_SET (error);\n  \n  _dbus_global_unlock (mutex);\n\n  return retval;\n }\n", "target": 0, "idx": 3789}
{"func": "SYSCALL_DEFINE5(waitid, int, which, pid_t, upid, struct siginfo __user *,\n\t\tinfop, int, options, struct rusage __user *, ru)\n{\n\tstruct rusage r;\n \tstruct waitid_info info = {.status = 0};\n \tlong err = kernel_waitid(which, upid, &info, options, ru ? &r : NULL);\n \tint signo = 0;\n \tif (err > 0) {\n \t\tsigno = SIGCHLD;\n \t\terr = 0;\n\t}\n\tif (!err) {\n \t\tif (ru && copy_to_user(ru, &r, sizeof(struct rusage)))\n \t\t\treturn -EFAULT;\n \t}\n\tif (!infop)\n\t\treturn err;\n\n\tuser_access_begin();\n\tunsafe_put_user(signo, &infop->si_signo, Efault);\n\tunsafe_put_user(0, &infop->si_errno, Efault);\n\tunsafe_put_user(info.cause, &infop->si_code, Efault);\n\tunsafe_put_user(info.pid, &infop->si_pid, Efault);\n\tunsafe_put_user(info.uid, &infop->si_uid, Efault);\n\tunsafe_put_user(info.status, &infop->si_status, Efault);\n\tuser_access_end();\n\treturn err;\nEfault:\n\tuser_access_end();\n\treturn -EFAULT;\n}\n", "target": 1, "idx": 180915}
{"func": "static bool SniffForHTML(const char* content,\n                         size_t size,\n                         bool* have_enough_content,\n                         std::string* result) {\n  *have_enough_content &= TruncateSize(512, &size);\n\n  const char* const end = content + size;\n  const char* pos;\n  for (pos = content; pos < end; ++pos) {\n    if (!base::IsAsciiWhitespace(*pos))\n      break;\n  }\n  return CheckForMagicNumbers(pos, end - pos, kSniffableTags,\n                              arraysize(kSniffableTags), result);\n}\n", "target": 0, "idx": 161215}
{"func": "bool IsSensitiveURL(const GURL& url,\n                    bool is_request_from_browser_or_webui_renderer) {\n  bool sensitive_chrome_url = false;\n  const char kGoogleCom[] = \"google.com\";\n  const char kClient[] = \"clients\";\n  url::Origin origin = url::Origin::Create(url);\n  if (origin.DomainIs(kGoogleCom)) {\n    base::StringPiece host = url.host_piece();\n    while (host.ends_with(\".\"))\n      host.remove_suffix(1u);\n    if (is_request_from_browser_or_webui_renderer) {\n      base::StringPiece::size_type pos = host.rfind(kClient);\n      if (pos != base::StringPiece::npos) {\n        bool match = true;\n        if (pos > 0 && host[pos - 1] != '.') {\n          match = false;\n        } else {\n          for (base::StringPiece::const_iterator\n                   i = host.begin() + pos + strlen(kClient),\n                   end = host.end() - (strlen(kGoogleCom) + 1);\n               i != end; ++i) {\n            if (!isdigit(*i)) {\n              match = false;\n              break;\n            }\n          }\n        }\n        sensitive_chrome_url = sensitive_chrome_url || match;\n      }\n    }\n\n    sensitive_chrome_url = sensitive_chrome_url ||\n                           (url.DomainIs(\"chrome.google.com\") &&\n                             base::StartsWith(url.path_piece(), \"/webstore\",\n                                              base::CompareCase::SENSITIVE));\n   }\n   return sensitive_chrome_url || extension_urls::IsWebstoreUpdateUrl(url) ||\n          extension_urls::IsBlacklistUpdateUrl(url) ||\n          extension_urls::IsSafeBrowsingUrl(origin, url.path_piece());\n}\n", "target": 1, "idx": 186650}
{"func": "static OPJ_BOOL opj_pi_next_pcrl(opj_pi_iterator_t * pi)\n{\n    opj_pi_comp_t *comp = NULL;\n    opj_pi_resolution_t *res = NULL;\n    OPJ_UINT32 index = 0;\n\n    if (!pi->first) {\n        comp = &pi->comps[pi->compno];\n        goto LABEL_SKIP;\n    } else {\n        OPJ_UINT32 compno, resno;\n        pi->first = 0;\n        pi->dx = 0;\n        pi->dy = 0;\n        for (compno = 0; compno < pi->numcomps; compno++) {\n            comp = &pi->comps[compno];\n            for (resno = 0; resno < comp->numresolutions; resno++) {\n                OPJ_UINT32 dx, dy;\n                res = &comp->resolutions[resno];\n                dx = comp->dx * (1u << (res->pdx + comp->numresolutions - 1 - resno));\n                dy = comp->dy * (1u << (res->pdy + comp->numresolutions - 1 - resno));\n                pi->dx = !pi->dx ? dx : opj_uint_min(pi->dx, dx);\n                pi->dy = !pi->dy ? dy : opj_uint_min(pi->dy, dy);\n            }\n        }\n    }\n    if (!pi->tp_on) {\n        pi->poc.ty0 = pi->ty0;\n        pi->poc.tx0 = pi->tx0;\n        pi->poc.ty1 = pi->ty1;\n        pi->poc.tx1 = pi->tx1;\n    }\n    for (pi->y = pi->poc.ty0; pi->y < pi->poc.ty1;\n            pi->y += (OPJ_INT32)(pi->dy - (OPJ_UINT32)(pi->y % (OPJ_INT32)pi->dy))) {\n        for (pi->x = pi->poc.tx0; pi->x < pi->poc.tx1;\n                pi->x += (OPJ_INT32)(pi->dx - (OPJ_UINT32)(pi->x % (OPJ_INT32)pi->dx))) {\n            for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n                comp = &pi->comps[pi->compno];\n                for (pi->resno = pi->poc.resno0;\n                        pi->resno < opj_uint_min(pi->poc.resno1, comp->numresolutions); pi->resno++) {\n                    OPJ_UINT32 levelno;\n                    OPJ_INT32 trx0, try0;\n                    OPJ_INT32 trx1, try1;\n                    OPJ_UINT32 rpx, rpy;\n                    OPJ_INT32 prci, prcj;\n                    res = &comp->resolutions[pi->resno];\n                    levelno = comp->numresolutions - 1 - pi->resno;\n                    trx0 = opj_int_ceildiv(pi->tx0, (OPJ_INT32)(comp->dx << levelno));\n                    try0 = opj_int_ceildiv(pi->ty0, (OPJ_INT32)(comp->dy << levelno));\n                    trx1 = opj_int_ceildiv(pi->tx1, (OPJ_INT32)(comp->dx << levelno));\n                     try1 = opj_int_ceildiv(pi->ty1, (OPJ_INT32)(comp->dy << levelno));\n                     rpx = res->pdx + levelno;\n                     rpy = res->pdy + levelno;\n                     if (!((pi->y % (OPJ_INT32)(comp->dy << rpy) == 0) || ((pi->y == pi->ty0) &&\n                             ((try0 << levelno) % (1 << rpy))))) {\n                         continue;\n                    }\n                    if (!((pi->x % (OPJ_INT32)(comp->dx << rpx) == 0) || ((pi->x == pi->tx0) &&\n                            ((trx0 << levelno) % (1 << rpx))))) {\n                        continue;\n                    }\n\n                    if ((res->pw == 0) || (res->ph == 0)) {\n                        continue;\n                    }\n\n                    if ((trx0 == trx1) || (try0 == try1)) {\n                        continue;\n                    }\n\n                    prci = opj_int_floordivpow2(opj_int_ceildiv(pi->x,\n                                                (OPJ_INT32)(comp->dx << levelno)), (OPJ_INT32)res->pdx)\n                           - opj_int_floordivpow2(trx0, (OPJ_INT32)res->pdx);\n                    prcj = opj_int_floordivpow2(opj_int_ceildiv(pi->y,\n                                                (OPJ_INT32)(comp->dy << levelno)), (OPJ_INT32)res->pdy)\n                           - opj_int_floordivpow2(try0, (OPJ_INT32)res->pdy);\n                    pi->precno = (OPJ_UINT32)(prci + prcj * (OPJ_INT32)res->pw);\n                    for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n                        index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno *\n                                pi->step_c + pi->precno * pi->step_p;\n                        if (!pi->include[index]) {\n                            pi->include[index] = 1;\n                            return OPJ_TRUE;\n                        }\nLABEL_SKIP:\n                        ;\n                    }\n                }\n            }\n        }\n    }\n\n    return OPJ_FALSE;\n}\n", "target": 1, "idx": 181628}
{"func": " static void sgi_timer_get(struct k_itimer *timr, struct itimerspec *cur_setting)\n {\n\n\tif (timr->it.mmtimer.clock == TIMER_OFF) {\n\t\tcur_setting->it_interval.tv_nsec = 0;\n\t\tcur_setting->it_interval.tv_sec = 0;\n\t\tcur_setting->it_value.tv_nsec = 0;\n\t\tcur_setting->it_value.tv_sec =0;\n \t\treturn;\n \t}\n \n\tns_to_timespec(cur_setting->it_interval, timr->it.mmtimer.incr * sgi_clock_period);\n\tns_to_timespec(cur_setting->it_value, (timr->it.mmtimer.expires - rtc_time())* sgi_clock_period);\n\treturn;\n }\n", "target": 1, "idx": 178923}
{"func": "static int show_numa_map(struct seq_file *m, void *v, int is_pid)\n{\n\tstruct numa_maps_private *numa_priv = m->private;\n\tstruct proc_maps_private *proc_priv = &numa_priv->proc_maps;\n\tstruct vm_area_struct *vma = v;\n\tstruct numa_maps *md = &numa_priv->md;\n\tstruct file *file = vma->vm_file;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct mm_walk walk = {\n\t\t.hugetlb_entry = gather_hugetlb_stats,\n\t\t.pmd_entry = gather_pte_stats,\n\t\t.private = md,\n\t\t.mm = mm,\n\t};\n\tstruct mempolicy *pol;\n\tchar buffer[64];\n\tint nid;\n\n\tif (!mm)\n\t\treturn 0;\n\n\t/* Ensure we start with an empty set of numa_maps statistics. */\n\tmemset(md, 0, sizeof(*md));\n\n\tpol = __get_vma_policy(vma, vma->vm_start);\n\tif (pol) {\n\t\tmpol_to_str(buffer, sizeof(buffer), pol);\n\t\tmpol_cond_put(pol);\n\t} else {\n\t\tmpol_to_str(buffer, sizeof(buffer), proc_priv->task_mempolicy);\n\t}\n\n\tseq_printf(m, \"%08lx %s\", vma->vm_start, buffer);\n\n\tif (file) {\n\t\tseq_puts(m, \" file=\");\n\t\tseq_path(m, &file->f_path, \"\\n\\t= \");\n\t} else if (vma->vm_start <= mm->brk && vma->vm_end >= mm->start_brk) {\n\t\tseq_puts(m, \" heap\");\n\t} else {\n\t\tpid_t tid = pid_of_stack(proc_priv, vma, is_pid);\n\t\tif (tid != 0) {\n\t\t\t/*\n\t\t\t * Thread stack in /proc/PID/task/TID/maps or\n\t\t\t * the main process stack.\n\t\t\t */\n\t\t\tif (!is_pid || (vma->vm_start <= mm->start_stack &&\n\t\t\t    vma->vm_end >= mm->start_stack))\n\t\t\t\tseq_puts(m, \" stack\");\n\t\t\telse\n\t\t\t\tseq_printf(m, \" stack:%d\", tid);\n\t\t}\n\t}\n\n\tif (is_vm_hugetlb_page(vma))\n\t\tseq_puts(m, \" huge\");\n\n\t/* mmap_sem is held by m_start */\n\twalk_page_vma(vma, &walk);\n\n\tif (!md->pages)\n\t\tgoto out;\n\n\tif (md->anon)\n\t\tseq_printf(m, \" anon=%lu\", md->anon);\n\n\tif (md->dirty)\n\t\tseq_printf(m, \" dirty=%lu\", md->dirty);\n\n\tif (md->pages != md->anon && md->pages != md->dirty)\n\t\tseq_printf(m, \" mapped=%lu\", md->pages);\n\n\tif (md->mapcount_max > 1)\n\t\tseq_printf(m, \" mapmax=%lu\", md->mapcount_max);\n\n\tif (md->swapcache)\n\t\tseq_printf(m, \" swapcache=%lu\", md->swapcache);\n\n\tif (md->active < md->pages && !is_vm_hugetlb_page(vma))\n\t\tseq_printf(m, \" active=%lu\", md->active);\n\n\tif (md->writeback)\n\t\tseq_printf(m, \" writeback=%lu\", md->writeback);\n\n\tfor_each_node_state(nid, N_MEMORY)\n\t\tif (md->node[nid])\n\t\t\tseq_printf(m, \" N%d=%lu\", nid, md->node[nid]);\n\n\tseq_printf(m, \" kernelpagesize_kB=%lu\", vma_kernel_pagesize(vma) >> 10);\nout:\n\tseq_putc(m, '\\n');\n\tm_cache_vma(m, vma);\n\treturn 0;\n}\n", "target": 0, "idx": 55818}
{"func": "  virtual void Run() {\n    JSONStringValueSerializer deserializer(proxy_config_);\n    std::string error_msg;\n    scoped_ptr<Value> root(deserializer.Deserialize(NULL, &error_msg));\n    if (!root.get() || root->GetType() != Value::TYPE_DICTIONARY) {\n      DLOG(WARNING) << \"Received bad JSON string for ProxyConfig: \"\n                    << error_msg;\n      return;\n    }\n\n    scoped_ptr<DictionaryValue> dict(\n        static_cast<DictionaryValue*>(root.release()));\n    net::ProxyConfig pc;\n    PopulateProxyConfig(*dict.get(), &pc);\n\n    net::ProxyService* proxy_service =\n        request_context_getter_->GetURLRequestContext()->proxy_service();\n    DCHECK(proxy_service);\n    scoped_ptr<net::ProxyConfigService> proxy_config_service(\n        new net::ProxyConfigServiceFixed(pc));\n    proxy_service->ResetConfigService(proxy_config_service.release());\n  }\n", "target": 0, "idx": 107267}
{"func": "static struct vm_area_struct *vma_to_resize(unsigned long addr,\n\tunsigned long old_len, unsigned long new_len, unsigned long *p)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma = find_vma(mm, addr);\n\n\tif (!vma || vma->vm_start > addr)\n\t\tgoto Efault;\n\n\tif (is_vm_hugetlb_page(vma))\n\t\tgoto Einval;\n\n\t/* We can't remap across vm area boundaries */\n \tif (old_len > vma->vm_end - addr)\n \t\tgoto Efault;\n \n\tif (vma->vm_flags & (VM_DONTEXPAND | VM_PFNMAP)) {\n\t\tif (new_len > old_len)\n \t\t\tgoto Efault;\n \t}\n \n \tif (vma->vm_flags & VM_LOCKED) {\n\t\tunsigned long locked, lock_limit;\n\t\tlocked = mm->locked_vm << PAGE_SHIFT;\n\t\tlock_limit = rlimit(RLIMIT_MEMLOCK);\n\t\tlocked += new_len - old_len;\n\t\tif (locked > lock_limit && !capable(CAP_IPC_LOCK))\n\t\t\tgoto Eagain;\n\t}\n\n\tif (!may_expand_vm(mm, (new_len - old_len) >> PAGE_SHIFT))\n\t\tgoto Enomem;\n\n\tif (vma->vm_flags & VM_ACCOUNT) {\n\t\tunsigned long charged = (new_len - old_len) >> PAGE_SHIFT;\n\t\tif (security_vm_enough_memory(charged))\n\t\t\tgoto Efault;\n\t\t*p = charged;\n\t}\n\n\treturn vma;\n\nEfault:\t/* very odd choice for most of the cases, but... */\n\treturn ERR_PTR(-EFAULT);\nEinval:\n\treturn ERR_PTR(-EINVAL);\nEnomem:\n\treturn ERR_PTR(-ENOMEM);\nEagain:\n\treturn ERR_PTR(-EAGAIN);\n}\n", "target": 1, "idx": 179031}
{"func": "png_write_destroy(png_structp png_ptr)\n{\n#ifdef PNG_SETJMP_SUPPORTED\n   jmp_buf tmp_jmp; /* Save jump buffer */\n#endif\n   png_error_ptr error_fn;\n   png_error_ptr warning_fn;\n   png_voidp error_ptr;\n#ifdef PNG_USER_MEM_SUPPORTED\n   png_free_ptr free_fn;\n#endif\n\n   png_debug(1, \"in png_write_destroy\");\n\n   /* Free any memory zlib uses */\n   deflateEnd(&png_ptr->zstream);\n\n   /* Free our memory.  png_free checks NULL for us. */\n   png_free(png_ptr, png_ptr->zbuf);\n   png_free(png_ptr, png_ptr->row_buf);\n#ifdef PNG_WRITE_FILTER_SUPPORTED\n   png_free(png_ptr, png_ptr->prev_row);\n   png_free(png_ptr, png_ptr->sub_row);\n   png_free(png_ptr, png_ptr->up_row);\n   png_free(png_ptr, png_ptr->avg_row);\n   png_free(png_ptr, png_ptr->paeth_row);\n#endif\n\n#ifdef PNG_TIME_RFC1123_SUPPORTED\n    png_free(png_ptr, png_ptr->time_buffer);\n #endif\n \n#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED\n   png_free(png_ptr, png_ptr->prev_filters);\n   png_free(png_ptr, png_ptr->filter_weights);\n   png_free(png_ptr, png_ptr->inv_filter_weights);\n   png_free(png_ptr, png_ptr->filter_costs);\n   png_free(png_ptr, png_ptr->inv_filter_costs);\n#endif\n #ifdef PNG_SETJMP_SUPPORTED\n    /* Reset structure */\n    png_memcpy(tmp_jmp, png_ptr->jmpbuf, png_sizeof(jmp_buf));\n#endif\n\n   error_fn = png_ptr->error_fn;\n   warning_fn = png_ptr->warning_fn;\n   error_ptr = png_ptr->error_ptr;\n#ifdef PNG_USER_MEM_SUPPORTED\n   free_fn = png_ptr->free_fn;\n#endif\n\n   png_memset(png_ptr, 0, png_sizeof(png_struct));\n\n   png_ptr->error_fn = error_fn;\n   png_ptr->warning_fn = warning_fn;\n   png_ptr->error_ptr = error_ptr;\n#ifdef PNG_USER_MEM_SUPPORTED\n   png_ptr->free_fn = free_fn;\n#endif\n\n#ifdef PNG_SETJMP_SUPPORTED\n   png_memcpy(png_ptr->jmpbuf, tmp_jmp, png_sizeof(jmp_buf));\n#endif\n}\n", "target": 1, "idx": 186157}
{"func": " image_transform_png_set_expand_add(image_transform *this,\n    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)\n {\n    UNUSED(bit_depth)\n \n this->next = *that;\n *that = this;\n\n /* 'expand' should do nothing for RGBA or GA input - no tRNS and the bit\n    * depth is at least 8 already.\n    */\n return (colour_type & PNG_COLOR_MASK_ALPHA) == 0;\n}\n", "target": 1, "idx": 187651}
{"func": "  explicit DeleteCacheCompletionCallback(MockHttpCache* cache)\n      : cache_(cache),\n        ALLOW_THIS_IN_INITIALIZER_LIST(callback_(\n            base::Bind(&DeleteCacheCompletionCallback::OnComplete,\n                       base::Unretained(this)))) {\n  }\n", "target": 0, "idx": 116356}
{"func": " void ChromeMockRenderThread::OnMsgOpenChannelToExtension(\n    int routing_id, const std::string& source_extension_id,\n     const std::string& target_extension_id,\n    const std::string& channel_name, int* port_id) {\n   *port_id = 0;\n }\n", "target": 1, "idx": 184426}
{"func": "void FragmentPaintPropertyTreeBuilder::UpdateClipPathClip(\n    bool spv1_compositing_specific_pass) {\n  bool is_spv1_composited =\n      object_.HasLayer() &&\n      ToLayoutBoxModelObject(object_).Layer()->GetCompositedLayerMapping();\n  if (is_spv1_composited != spv1_compositing_specific_pass)\n    return;\n\n  if (NeedsPaintPropertyUpdate()) {\n    if (!NeedsClipPathClip(object_)) {\n      OnClearClip(properties_->ClearClipPathClip());\n    } else {\n      ClipPaintPropertyNode::State state;\n      state.local_transform_space = context_.current.transform;\n       state.clip_rect =\n           FloatRoundedRect(FloatRect(*fragment_data_.ClipPathBoundingBox()));\n       state.clip_path = fragment_data_.ClipPathPath();\n      OnUpdateClip(properties_->UpdateClipPathClip(context_.current.clip,\n                                                    std::move(state)));\n     }\n   }\n\n  if (properties_->ClipPathClip() && !spv1_compositing_specific_pass) {\n    context_.current.clip = context_.absolute_position.clip =\n        context_.fixed_position.clip = properties_->ClipPathClip();\n  }\n}\n", "target": 1, "idx": 185670}
{"func": "bool ProfileSyncService::IsSyncEnabledAndLoggedIn() {\n  if (IsManaged() || sync_prefs_.IsStartSuppressed())\n    return false;\n\n  return !signin_->GetAuthenticatedUsername().empty();\n}\n", "target": 0, "idx": 111900}
{"func": "int GetSystemMetricsInDIP(int metric) {\n  return static_cast<int>(GetSystemMetrics(metric) /\n      GetDeviceScaleFactor() + 0.5);\n}\n", "target": 0, "idx": 134865}
{"func": "int x86_emulate_insn(struct x86_emulate_ctxt *ctxt)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tint rc = X86EMUL_CONTINUE;\n\tint saved_dst_type = ctxt->dst.type;\n\n\tctxt->mem_read.pos = 0;\n\n\t/* LOCK prefix is allowed only with some instructions */\n\tif (ctxt->lock_prefix && (!(ctxt->d & Lock) || ctxt->dst.type != OP_MEM)) {\n\t\trc = emulate_ud(ctxt);\n\t\tgoto done;\n\t}\n\n\tif ((ctxt->d & SrcMask) == SrcMemFAddr && ctxt->src.type != OP_MEM) {\n\t\trc = emulate_ud(ctxt);\n\t\tgoto done;\n\t}\n\n\tif (unlikely(ctxt->d &\n\t\t     (No64|Undefined|Sse|Mmx|Intercept|CheckPerm|Priv|Prot|String))) {\n\t\tif ((ctxt->mode == X86EMUL_MODE_PROT64 && (ctxt->d & No64)) ||\n\t\t\t\t(ctxt->d & Undefined)) {\n\t\t\trc = emulate_ud(ctxt);\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (((ctxt->d & (Sse|Mmx)) && ((ops->get_cr(ctxt, 0) & X86_CR0_EM)))\n\t\t    || ((ctxt->d & Sse) && !(ops->get_cr(ctxt, 4) & X86_CR4_OSFXSR))) {\n\t\t\trc = emulate_ud(ctxt);\n\t\t\tgoto done;\n\t\t}\n\n\t\tif ((ctxt->d & (Sse|Mmx)) && (ops->get_cr(ctxt, 0) & X86_CR0_TS)) {\n\t\t\trc = emulate_nm(ctxt);\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (ctxt->d & Mmx) {\n\t\t\trc = flush_pending_x87_faults(ctxt);\n\t\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\t\tgoto done;\n\t\t\t/*\n\t\t\t * Now that we know the fpu is exception safe, we can fetch\n\t\t\t * operands from it.\n\t\t\t */\n\t\t\tfetch_possible_mmx_operand(ctxt, &ctxt->src);\n\t\t\tfetch_possible_mmx_operand(ctxt, &ctxt->src2);\n\t\t\tif (!(ctxt->d & Mov))\n\t\t\t\tfetch_possible_mmx_operand(ctxt, &ctxt->dst);\n\t\t}\n\n\t\tif (unlikely(ctxt->guest_mode) && (ctxt->d & Intercept)) {\n\t\t\trc = emulator_check_intercept(ctxt, ctxt->intercept,\n\t\t\t\t\t\t      X86_ICPT_PRE_EXCEPT);\n\t\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\t/* Privileged instruction can be executed only in CPL=0 */\n\t\tif ((ctxt->d & Priv) && ops->cpl(ctxt)) {\n\t\t\tif (ctxt->d & PrivUD)\n\t\t\t\trc = emulate_ud(ctxt);\n\t\t\telse\n\t\t\t\trc = emulate_gp(ctxt, 0);\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* Instruction can only be executed in protected mode */\n\t\tif ((ctxt->d & Prot) && ctxt->mode < X86EMUL_MODE_PROT16) {\n\t\t\trc = emulate_ud(ctxt);\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* Do instruction specific permission checks */\n\t\tif (ctxt->d & CheckPerm) {\n\t\t\trc = ctxt->check_perm(ctxt);\n\t\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\tif (unlikely(ctxt->guest_mode) && (ctxt->d & Intercept)) {\n\t\t\trc = emulator_check_intercept(ctxt, ctxt->intercept,\n\t\t\t\t\t\t      X86_ICPT_POST_EXCEPT);\n\t\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\tif (ctxt->rep_prefix && (ctxt->d & String)) {\n\t\t\t/* All REP prefixes have the same first termination condition */\n\t\t\tif (address_mask(ctxt, reg_read(ctxt, VCPU_REGS_RCX)) == 0) {\n\t\t\t\tctxt->eip = ctxt->_eip;\n\t\t\t\tctxt->eflags &= ~EFLG_RF;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ((ctxt->src.type == OP_MEM) && !(ctxt->d & NoAccess)) {\n\t\trc = segmented_read(ctxt, ctxt->src.addr.mem,\n\t\t\t\t    ctxt->src.valptr, ctxt->src.bytes);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\tgoto done;\n\t\tctxt->src.orig_val64 = ctxt->src.val64;\n\t}\n\n\tif (ctxt->src2.type == OP_MEM) {\n\t\trc = segmented_read(ctxt, ctxt->src2.addr.mem,\n\t\t\t\t    &ctxt->src2.val, ctxt->src2.bytes);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\tgoto done;\n\t}\n\n\tif ((ctxt->d & DstMask) == ImplicitOps)\n\t\tgoto special_insn;\n\n\n\tif ((ctxt->dst.type == OP_MEM) && !(ctxt->d & Mov)) {\n\t\t/* optimisation - avoid slow emulated read if Mov */\n\t\trc = segmented_read(ctxt, ctxt->dst.addr.mem,\n\t\t\t\t   &ctxt->dst.val, ctxt->dst.bytes);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\tgoto done;\n\t}\n\tctxt->dst.orig_val = ctxt->dst.val;\n\nspecial_insn:\n\n\tif (unlikely(ctxt->guest_mode) && (ctxt->d & Intercept)) {\n\t\trc = emulator_check_intercept(ctxt, ctxt->intercept,\n\t\t\t\t\t      X86_ICPT_POST_MEMACCESS);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\tgoto done;\n\t}\n\n\tif (ctxt->rep_prefix && (ctxt->d & String))\n\t\tctxt->eflags |= EFLG_RF;\n\telse\n\t\tctxt->eflags &= ~EFLG_RF;\n\n\tif (ctxt->execute) {\n\t\tif (ctxt->d & Fastop) {\n\t\t\tvoid (*fop)(struct fastop *) = (void *)ctxt->execute;\n\t\t\trc = fastop(ctxt, fop);\n\t\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\t\tgoto done;\n\t\t\tgoto writeback;\n\t\t}\n\t\trc = ctxt->execute(ctxt);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\tgoto done;\n\t\tgoto writeback;\n\t}\n\n\tif (ctxt->opcode_len == 2)\n\t\tgoto twobyte_insn;\n\telse if (ctxt->opcode_len == 3)\n\t\tgoto threebyte_insn;\n\n\tswitch (ctxt->b) {\n\tcase 0x63:\t\t/* movsxd */\n\t\tif (ctxt->mode != X86EMUL_MODE_PROT64)\n\t\t\tgoto cannot_emulate;\n\t\tctxt->dst.val = (s32) ctxt->src.val;\n \t\tbreak;\n \tcase 0x70 ... 0x7f: /* jcc (short) */\n \t\tif (test_cc(ctxt->b, ctxt->eflags))\n\t\t\tjmp_rel(ctxt, ctxt->src.val);\n \t\tbreak;\n \tcase 0x8d: /* lea r16/r32, m */\n \t\tctxt->dst.val = ctxt->src.addr.mem.ea;\n\t\tbreak;\n\tcase 0x90 ... 0x97: /* nop / xchg reg, rax */\n\t\tif (ctxt->dst.addr.reg == reg_rmw(ctxt, VCPU_REGS_RAX))\n\t\t\tctxt->dst.type = OP_NONE;\n\t\telse\n\t\t\trc = em_xchg(ctxt);\n\t\tbreak;\n\tcase 0x98: /* cbw/cwde/cdqe */\n\t\tswitch (ctxt->op_bytes) {\n\t\tcase 2: ctxt->dst.val = (s8)ctxt->dst.val; break;\n\t\tcase 4: ctxt->dst.val = (s16)ctxt->dst.val; break;\n\t\tcase 8: ctxt->dst.val = (s32)ctxt->dst.val; break;\n\t\t}\n\t\tbreak;\n\tcase 0xcc:\t\t/* int3 */\n\t\trc = emulate_int(ctxt, 3);\n\t\tbreak;\n\tcase 0xcd:\t\t/* int n */\n\t\trc = emulate_int(ctxt, ctxt->src.val);\n\t\tbreak;\n\tcase 0xce:\t\t/* into */\n\t\tif (ctxt->eflags & EFLG_OF)\n\t\t\trc = emulate_int(ctxt, 4);\n \t\tbreak;\n \tcase 0xe9: /* jmp rel */\n \tcase 0xeb: /* jmp rel short */\n\t\tjmp_rel(ctxt, ctxt->src.val);\n \t\tctxt->dst.type = OP_NONE; /* Disable writeback. */\n \t\tbreak;\n \tcase 0xf4:              /* hlt */\n\t\tctxt->ops->halt(ctxt);\n\t\tbreak;\n\tcase 0xf5:\t/* cmc */\n\t\t/* complement carry flag from eflags reg */\n\t\tctxt->eflags ^= EFLG_CF;\n\t\tbreak;\n\tcase 0xf8: /* clc */\n\t\tctxt->eflags &= ~EFLG_CF;\n\t\tbreak;\n\tcase 0xf9: /* stc */\n\t\tctxt->eflags |= EFLG_CF;\n\t\tbreak;\n\tcase 0xfc: /* cld */\n\t\tctxt->eflags &= ~EFLG_DF;\n\t\tbreak;\n\tcase 0xfd: /* std */\n\t\tctxt->eflags |= EFLG_DF;\n\t\tbreak;\n\tdefault:\n\t\tgoto cannot_emulate;\n\t}\n\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto done;\n\nwriteback:\n\tif (ctxt->d & SrcWrite) {\n\t\tBUG_ON(ctxt->src.type == OP_MEM || ctxt->src.type == OP_MEM_STR);\n\t\trc = writeback(ctxt, &ctxt->src);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\tgoto done;\n\t}\n\tif (!(ctxt->d & NoWrite)) {\n\t\trc = writeback(ctxt, &ctxt->dst);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\tgoto done;\n\t}\n\n\t/*\n\t * restore dst type in case the decoding will be reused\n\t * (happens for string instruction )\n\t */\n\tctxt->dst.type = saved_dst_type;\n\n\tif ((ctxt->d & SrcMask) == SrcSI)\n\t\tstring_addr_inc(ctxt, VCPU_REGS_RSI, &ctxt->src);\n\n\tif ((ctxt->d & DstMask) == DstDI)\n\t\tstring_addr_inc(ctxt, VCPU_REGS_RDI, &ctxt->dst);\n\n\tif (ctxt->rep_prefix && (ctxt->d & String)) {\n\t\tunsigned int count;\n\t\tstruct read_cache *r = &ctxt->io_read;\n\t\tif ((ctxt->d & SrcMask) == SrcSI)\n\t\t\tcount = ctxt->src.count;\n\t\telse\n\t\t\tcount = ctxt->dst.count;\n\t\tregister_address_increment(ctxt, reg_rmw(ctxt, VCPU_REGS_RCX),\n\t\t\t\t-count);\n\n\t\tif (!string_insn_completed(ctxt)) {\n\t\t\t/*\n\t\t\t * Re-enter guest when pio read ahead buffer is empty\n\t\t\t * or, if it is not used, after each 1024 iteration.\n\t\t\t */\n\t\t\tif ((r->end != 0 || reg_read(ctxt, VCPU_REGS_RCX) & 0x3ff) &&\n\t\t\t    (r->end == 0 || r->end != r->pos)) {\n\t\t\t\t/*\n\t\t\t\t * Reset read cache. Usually happens before\n\t\t\t\t * decode, but since instruction is restarted\n\t\t\t\t * we have to do it here.\n\t\t\t\t */\n\t\t\t\tctxt->mem_read.end = 0;\n\t\t\t\twriteback_registers(ctxt);\n\t\t\t\treturn EMULATION_RESTART;\n\t\t\t}\n\t\t\tgoto done; /* skip rip writeback */\n\t\t}\n\t\tctxt->eflags &= ~EFLG_RF;\n\t}\n\n\tctxt->eip = ctxt->_eip;\n\ndone:\n\tif (rc == X86EMUL_PROPAGATE_FAULT) {\n\t\tWARN_ON(ctxt->exception.vector > 0x1f);\n\t\tctxt->have_exception = true;\n\t}\n\tif (rc == X86EMUL_INTERCEPTED)\n\t\treturn EMULATION_INTERCEPTED;\n\n\tif (rc == X86EMUL_CONTINUE)\n\t\twriteback_registers(ctxt);\n\n\treturn (rc == X86EMUL_UNHANDLEABLE) ? EMULATION_FAILED : EMULATION_OK;\n\ntwobyte_insn:\n\tswitch (ctxt->b) {\n\tcase 0x09:\t\t/* wbinvd */\n\t\t(ctxt->ops->wbinvd)(ctxt);\n\t\tbreak;\n\tcase 0x08:\t\t/* invd */\n\tcase 0x0d:\t\t/* GrpP (prefetch) */\n\tcase 0x18:\t\t/* Grp16 (prefetch/nop) */\n\tcase 0x1f:\t\t/* nop */\n\t\tbreak;\n\tcase 0x20: /* mov cr, reg */\n\t\tctxt->dst.val = ops->get_cr(ctxt, ctxt->modrm_reg);\n\t\tbreak;\n\tcase 0x21: /* mov from dr to reg */\n\t\tops->get_dr(ctxt, ctxt->modrm_reg, &ctxt->dst.val);\n\t\tbreak;\n\tcase 0x40 ... 0x4f:\t/* cmov */\n\t\tif (test_cc(ctxt->b, ctxt->eflags))\n\t\t\tctxt->dst.val = ctxt->src.val;\n\t\telse if (ctxt->mode != X86EMUL_MODE_PROT64 ||\n\t\t\t ctxt->op_bytes != 4)\n\t\t\tctxt->dst.type = OP_NONE; /* no writeback */\n \t\tbreak;\n \tcase 0x80 ... 0x8f: /* jnz rel, etc*/\n \t\tif (test_cc(ctxt->b, ctxt->eflags))\n\t\t\tjmp_rel(ctxt, ctxt->src.val);\n \t\tbreak;\n \tcase 0x90 ... 0x9f:     /* setcc r/m8 */\n \t\tctxt->dst.val = test_cc(ctxt->b, ctxt->eflags);\n\t\tbreak;\n\tcase 0xae:              /* clflush */\n\t\tbreak;\n\tcase 0xb6 ... 0xb7:\t/* movzx */\n\t\tctxt->dst.bytes = ctxt->op_bytes;\n\t\tctxt->dst.val = (ctxt->src.bytes == 1) ? (u8) ctxt->src.val\n\t\t\t\t\t\t       : (u16) ctxt->src.val;\n\t\tbreak;\n\tcase 0xbe ... 0xbf:\t/* movsx */\n\t\tctxt->dst.bytes = ctxt->op_bytes;\n\t\tctxt->dst.val = (ctxt->src.bytes == 1) ? (s8) ctxt->src.val :\n\t\t\t\t\t\t\t(s16) ctxt->src.val;\n\t\tbreak;\n\tcase 0xc3:\t\t/* movnti */\n\t\tctxt->dst.bytes = ctxt->op_bytes;\n\t\tctxt->dst.val = (ctxt->op_bytes == 8) ? (u64) ctxt->src.val :\n\t\t\t\t\t\t\t(u32) ctxt->src.val;\n\t\tbreak;\n\tdefault:\n\t\tgoto cannot_emulate;\n\t}\n\nthreebyte_insn:\n\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto done;\n\n\tgoto writeback;\n\ncannot_emulate:\n\treturn EMULATION_FAILED;\n}\n", "target": 1, "idx": 183089}
{"func": "int wvlan_uil_put_info(struct uilreq *urq, struct wl_private *lp)\n{\n\tint                     result = 0;\n \tltv_t                   *pLtv;\n \tbool_t                  ltvAllocated = FALSE;\n \tENCSTRCT                sEncryption;\n \n #ifdef USE_WDS\n \thcf_16                  hcfPort  = HCF_PORT_0;\n#endif  /* USE_WDS */\n\t/*------------------------------------------------------------------------*/\n\tDBG_FUNC(\"wvlan_uil_put_info\");\n\tDBG_ENTER(DbgInfo);\n\n\n\tif (urq->hcfCtx == &(lp->hcfCtx)) {\n\t\tif (capable(CAP_NET_ADMIN)) {\n\t\t\tif ((urq->data != NULL) && (urq->len != 0)) {\n\t\t\t\t/* Make sure that we have at least a command and length to send. */\n\t\t\t\tif (urq->len < (sizeof(hcf_16) * 2)) {\n\t\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"No Length/Type in LTV!!!\\n\");\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_LEN\\n\");\n\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t/* Verify the user buffer */\n\t\t\t\tresult = verify_area(VERIFY_READ, urq->data, urq->len);\n\t\t\t\tif (result != 0) {\n\t\t\t\t\turq->result = UIL_FAILURE;\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"verify_area(), VERIFY_READ FAILED\\n\");\n\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t/* Get only the command and length information. */\n\t\t\t\tcopy_from_user(&(lp->ltvRecord), urq->data, sizeof(hcf_16) * 2);\n\n\t\t\t\t/* Make sure the incoming LTV record length is within the bounds of the\n\t\t\t\t   IOCTL length */\n\t\t\t\tif (((lp->ltvRecord.len + 1) * sizeof(hcf_16)) > urq->len) {\n\t\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_LEN\\n\");\n\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t/* If the requested length is greater than the size of our local\n\t\t\t\t   LTV record, try to allocate it from the kernel stack.\n\t\t\t\t   Otherwise, we just use our local LTV record. */\n\t\t\t\tif (urq->len > sizeof(lp->ltvRecord)) {\n\t\t\t\t\tpLtv = kmalloc(urq->len, GFP_KERNEL);\n\t\t\t\t\tif (pLtv != NULL) {\n\t\t\t\t\t\tltvAllocated = TRUE;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDBG_ERROR(DbgInfo, \"Alloc FAILED\\n\");\n\t\t\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\t\t\tresult = -ENOMEM;\n\t\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpLtv = &(lp->ltvRecord);\n\t\t\t\t}\n\n\t\t\t\t/* Copy the data from the user's buffer into the local LTV\n\t\t\t\t   record data area. */\n\t\t\t\tcopy_from_user(pLtv, urq->data, urq->len);\n\n\n\t\t\t\t/* We need to snoop the commands to see if there is anything we\n\t\t\t\t   need to store for the purposes of a reset or start/stop\n\t\t\t\t   sequence. Perform endian translation as needed */\n\t\t\t\tswitch (pLtv->typ) {\n\t\t\t\tcase CFG_CNF_PORT_TYPE:\n\t\t\t\t\tlp->PortType    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_OWN_MAC_ADDR:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_OWN_CHANNEL:\n\t\t\t\t\tlp->Channel     = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* CFG_CNF_OWN_SSID currently same as CNF_DESIRED_SSID. Do we\n\t\t\t\t   need separate storage for this? */\n\t\t\t\t/* case CFG_CNF_OWN_SSID: */\n\t\t\t\tcase CFG_CNF_OWN_ATIM_WINDOW:\n\t\t\t\t\tlp->atimWindow  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_SYSTEM_SCALE:\n\t\t\t\t\tlp->DistanceBetweenAPs  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\n\t\t\t\tcase CFG_CNF_MAX_DATA_LEN:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based\n\t\t\t\t\t   on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_PM_ENABLED:\n\t\t\t\t\tlp->PMEnabled   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_MCAST_RX:\n\t\t\t\t\tlp->MulticastReceive    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_MAX_SLEEP_DURATION:\n\t\t\t\t\tlp->MaxSleepDuration    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_HOLDOVER_DURATION:\n\t\t\t\t\tlp->holdoverDuration    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n \t\t\t\t\tbreak;\n \t\t\t\tcase CFG_CNF_OWN_NAME:\n \t\t\t\t\tmemset(lp->StationName, 0, sizeof(lp->StationName));\n\t\t\t\t\tmemcpy((void *)lp->StationName, (void *)&pLtv->u.u8[2], (size_t)pLtv->u.u16[0]);\n \t\t\t\t\tpLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n \t\t\t\t\tbreak;\n \t\t\t\tcase CFG_CNF_LOAD_BALANCING:\n\t\t\t\t\tlp->loadBalancing       = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_MEDIUM_DISTRIBUTION:\n\t\t\t\t\tlp->mediumDistribution  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_TX_POW_LVL:\n\t\t\t\t\tlp->txPowLevel          = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* case CFG_CNF_SHORT_RETRY_LIMIT: */ /* Short Retry Limit */\n\t\t\t\t/* case 0xFC33: */   /* Long Retry Limit */\n\t\t\t\tcase CFG_SUPPORTED_RATE_SET_CNTL:        /* Supported Rate Set Control */\n\t\t\t\t\tlp->srsc[0]             = pLtv->u.u16[0];\n\t\t\t\t\tlp->srsc[1]             = pLtv->u.u16[1];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[1]          = CNV_INT_TO_LITTLE(pLtv->u.u16[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_BASIC_RATE_SET_CNTL:        /* Basic Rate Set Control */\n\t\t\t\t\tlp->brsc[0]             = pLtv->u.u16[0];\n\t\t\t\t\tlp->brsc[1]             = pLtv->u.u16[1];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[1]          = CNV_INT_TO_LITTLE(pLtv->u.u16[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_CONNECTION_CNTL:\n\t\t\t\t\tlp->connectionControl   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* case CFG_PROBE_DATA_RATE: */\n#endif  /* HERMES25 */\n\n#if 1 /* ;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\n\t\t\t\tcase CFG_CNF_OWN_DTIM_PERIOD:\n\t\t\t\t\tlp->DTIMPeriod  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_OWN_BEACON_INTERVAL:        /* Own Beacon Interval */\n\t\t\t\t\tlp->ownBeaconInterval   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif /* WARP */\n\t\t\t\tcase CFG_COEXISTENSE_BEHAVIOUR:         /* Coexistence behavior */\n\t\t\t\t\tlp->coexistence         = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef USE_WDS\n\t\t\t\tcase CFG_CNF_WDS_ADDR1:\n\t\t\t\t\tmemcpy(&lp->wds_port[0].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR2:\n\t\t\t\t\tmemcpy(&lp->wds_port[1].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR3:\n\t\t\t\t\tmemcpy(&lp->wds_port[2].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR4:\n\t\t\t\t\tmemcpy(&lp->wds_port[3].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR5:\n\t\t\t\t\tmemcpy(&lp->wds_port[4].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR6:\n\t\t\t\t\tmemcpy(&lp->wds_port[5].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_6;\n\t\t\t\t\tbreak;\n#endif  /* USE_WDS */\n\n\t\t\t\tcase CFG_CNF_MCAST_PM_BUF:\n\t\t\t\t\tlp->multicastPMBuffering    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_REJECT_ANY:\n\t\t\t\t\tlp->RejectAny   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif\n\n\t\t\t\tcase CFG_CNF_ENCRYPTION:\n\t\t\t\t\tlp->EnableEncryption    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_AUTHENTICATION:\n\t\t\t\t\tlp->authentication  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#if 1 /* ;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\n\t\t\t\t/* case CFG_CNF_EXCL_UNENCRYPTED:\n\t\t\t\t\tlp->ExcludeUnencrypted  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak; */\n\t\t\t\tcase CFG_CNF_MCAST_RATE:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_INTRA_BSS_RELAY:\n\t\t\t\t\tlp->intraBSSRelay   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif\n\n\t\t\t\tcase CFG_CNF_MICRO_WAVE:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\t/*case CFG_CNF_LOAD_BALANCING:*/\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\t/* case CFG_CNF_MEDIUM_DISTRIBUTION: */\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\t/* case CFG_CNF_RX_ALL_GROUP_ADDRESS: */\n\t\t\t\t\t/*  TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\t/* case CFG_CNF_COUNTRY_INFO: */\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n\t\t\t\tcase CFG_CNF_OWN_SSID:\n\t\t\t\t/* case CNF_DESIRED_SSID: */\n\t\t\t\tcase CFG_DESIRED_SSID:\n\t\t\t\t\tmemset(lp->NetworkName, 0, sizeof(lp->NetworkName));\n\t\t\t\t\tmemcpy((void *)lp->NetworkName, (void *)&pLtv->u.u8[2], (size_t)pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\n\t\t\t\t\t/* take care of the special network name \"ANY\" case */\n\t\t\t\t\tif ((strlen(&pLtv->u.u8[2]) == 0) ||\n\t\t\t\t\t   (strcmp(&pLtv->u.u8[2], \"ANY\") == 0) ||\n\t\t\t\t\t   (strcmp(&pLtv->u.u8[2], \"any\") == 0)) {\n\t\t\t\t\t\t/* set the SSID_STRCT llen field (u16[0]) to zero, and the\n\t\t\t\t\t\teffectually null the string u8[2] */\n\t\t\t\t\t\tpLtv->u.u16[0] = 0;\n\t\t\t\t\t\tpLtv->u.u8[2]  = 0;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_GROUP_ADDR:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CREATE_IBSS:\n\t\t\t\t\tlp->CreateIBSS  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH:\n\t\t\t\t\tlp->RTSThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL:\n\t\t\t\t\tlp->TxRateControl[0]    = pLtv->u.u16[0];\n\t\t\t\t\tlp->TxRateControl[1]    = pLtv->u.u16[1];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[1]          = CNV_INT_TO_LITTLE(pLtv->u.u16[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_PROMISCUOUS_MODE:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\t/* case CFG_WAKE_ON_LAN: */\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\t/* break; */\n#if 1 /* ;? #if (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\t\t\t\tcase CFG_RTS_THRH0:\n\t\t\t\t\tlp->RTSThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL0:\n/*;?no idea what this should be, get going so comment it out\t\t\t\t\tlp->TxRateControl   = pLtv->u.u16[0];*/\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef USE_WDS\n\t\t\t\tcase CFG_RTS_THRH1:\n\t\t\t\t\tlp->wds_port[0].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH2:\n\t\t\t\t\tlp->wds_port[1].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH3:\n\t\t\t\t\tlp->wds_port[2].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH4:\n\t\t\t\t\tlp->wds_port[3].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH5:\n\t\t\t\t\tlp->wds_port[4].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_RTS_THRH6:\n\t\t\t\t\tlp->wds_port[5].rtsThreshold    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]                  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                         = HCF_PORT_6;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL1:\n\t\t\t\t\tlp->wds_port[0].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL2:\n\t\t\t\t\tlp->wds_port[1].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL3:\n\t\t\t\t\tlp->wds_port[2].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL4:\n\t\t\t\t\tlp->wds_port[3].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL5:\n\t\t\t\t\tlp->wds_port[4].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_RATE_CNTL6:\n\t\t\t\t\tlp->wds_port[5].txRateCntl  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\thcfPort                     = HCF_PORT_6;\n\t\t\t\t\tbreak;\n#endif  /* USE_WDS */\n#endif  /* (HCF_TYPE) & HCF_TYPE_AP */\n\n\t\t\t\tcase CFG_DEFAULT_KEYS:\n\t\t\t\t\t{\n\t\t\t\t\t\tCFG_DEFAULT_KEYS_STRCT *pKeys = (CFG_DEFAULT_KEYS_STRCT *)pLtv;\n\n\t\t\t\t\t\tpKeys->key[0].len = CNV_INT_TO_LITTLE(pKeys->key[0].len);\n\t\t\t\t\t\tpKeys->key[1].len = CNV_INT_TO_LITTLE(pKeys->key[1].len);\n\t\t\t\t\t\tpKeys->key[2].len = CNV_INT_TO_LITTLE(pKeys->key[2].len);\n\t\t\t\t\t\tpKeys->key[3].len = CNV_INT_TO_LITTLE(pKeys->key[3].len);\n\n\t\t\t\t\t\tmemcpy((void *)&(lp->DefaultKeys), (void *)pKeys,\n\t\t\t\t\t\t\t\tsizeof(CFG_DEFAULT_KEYS_STRCT));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TX_KEY_ID:\n\t\t\t\t\tlp->TransmitKeyID   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_SCAN_SSID:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_TICK_TIME:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\t/* these RIDS are Info RIDs, and should they be allowed for puts??? */\n\t\t\t\tcase CFG_MAX_LOAD_TIME:\n\t\t\t\tcase CFG_DL_BUF:\n\t\t\t\t/* case CFG_HSI_SUP_RANGE: */\n\t\t\t\tcase CFG_NIC_SERIAL_NUMBER:\n\t\t\t\tcase CFG_NIC_IDENTITY:\n\t\t\t\tcase CFG_NIC_MFI_SUP_RANGE:\n\t\t\t\tcase CFG_NIC_CFI_SUP_RANGE:\n\t\t\t\tcase CFG_NIC_TEMP_TYPE:\n\t\t\t\tcase CFG_NIC_PROFILE:\n\t\t\t\tcase CFG_FW_IDENTITY:\n\t\t\t\tcase CFG_FW_SUP_RANGE:\n\t\t\t\tcase CFG_MFI_ACT_RANGES_STA:\n\t\t\t\tcase CFG_CFI_ACT_RANGES_STA:\n\t\t\t\tcase CFG_PORT_STAT:\n\t\t\t\tcase CFG_CUR_SSID:\n\t\t\t\tcase CFG_CUR_BSSID:\n\t\t\t\tcase CFG_COMMS_QUALITY:\n\t\t\t\tcase CFG_CUR_TX_RATE:\n\t\t\t\tcase CFG_CUR_BEACON_INTERVAL:\n\t\t\t\tcase CFG_CUR_SCALE_THRH:\n\t\t\t\tcase CFG_PROTOCOL_RSP_TIME:\n\t\t\t\tcase CFG_CUR_SHORT_RETRY_LIMIT:\n\t\t\t\tcase CFG_CUR_LONG_RETRY_LIMIT:\n\t\t\t\tcase CFG_MAX_TX_LIFETIME:\n\t\t\t\tcase CFG_MAX_RX_LIFETIME:\n\t\t\t\tcase CFG_CF_POLLABLE:\n\t\t\t\tcase CFG_AUTHENTICATION_ALGORITHMS:\n\t\t\t\tcase CFG_PRIVACY_OPT_IMPLEMENTED:\n\t\t\t\t/* case CFG_CURRENT_REMOTE_RATES: */\n\t\t\t\t/* case CFG_CURRENT_USED_RATES: */\n\t\t\t\t/* case CFG_CURRENT_SYSTEM_SCALE: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE1: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE2: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE3: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE4: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE5: */\n\t\t\t\t/* case CFG_CURRENT_TX_RATE6: */\n\t\t\t\tcase CFG_NIC_MAC_ADDR:\n\t\t\t\tcase CFG_PCF_INFO:\n\t\t\t\t/* case CFG_CURRENT_COUNTRY_INFO: */\n\t\t\t\tcase CFG_PHY_TYPE:\n\t\t\t\tcase CFG_CUR_CHANNEL:\n\t\t\t\t/* case CFG_CURRENT_POWER_STATE: */\n\t\t\t\t/* case CFG_CCAMODE: */\n\t\t\t\tcase CFG_SUPPORTED_DATA_RATES:\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_AP_MODE:\n/*;?\t\t\t\tlp->DownloadFirmware = (pLtv->u.u16[0]) + 1; */\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"set CFG_AP_MODE no longer supported\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_ENCRYPT_STRING:\n\t\t\t\t\t/* TODO: ENDIAN TRANSLATION HERE??? */\n\t\t\t\t\tmemset(lp->szEncryption, 0, sizeof(lp->szEncryption));\n\t\t\t\t\tmemcpy((void *)lp->szEncryption,  (void *)&pLtv->u.u8[0],\n\t\t\t\t\t\t\t(pLtv->len * sizeof(hcf_16)));\n\t\t\t\t\twl_wep_decode(CRYPT_CODE, &sEncryption,\n\t\t\t\t\t\t\t\t    lp->szEncryption);\n\n\t\t\t\t\t/* the Linux driver likes to use 1-4 for the key IDs, and then\n\t\t\t\t\tconvert to 0-3 when sending to the card.  The Windows code\n\t\t\t\t\tbase used 0-3 in the API DLL, which was ported to Linux.  For\n\t\t\t\t\tthe sake of the user experience, we decided to keep 0-3 as the\n\t\t\t\t\tnumbers used in the DLL; and will perform the +1 conversion here.\n\t\t\t\t\tWe could have converted  the entire Linux driver, but this is\n\t\t\t\t\tless obtrusive.  This may be a \"todo\" to convert the whole driver */\n\t\t\t\t\tlp->TransmitKeyID    = sEncryption.wTxKeyID + 1;\n\t\t\t\t\tlp->EnableEncryption = sEncryption.wEnabled;\n\n\t\t\t\t\tmemcpy(&lp->DefaultKeys, &sEncryption.EncStr,\n\t\t\t\t\t\t\tsizeof(CFG_DEFAULT_KEYS_STRCT));\n\t\t\t\t\tbreak;\n\t\t\t\t/*case CFG_COUNTRY_STRING:\n\t\t\t\t\tmemset(lp->countryString, 0, sizeof(lp->countryString));\n\t\t\t\t\tmemcpy((void *)lp->countryString, (void *)&pLtv->u.u8[2], (size_t)pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t*/\n\n\t\t\t\tcase CFG_DRIVER_ENABLE:\n\t\t\t\t\tlp->driverEnable    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_WOLAS_ENABLE:\n\t\t\t\t\tlp->wolasEnable = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_SET_WPA_AUTH_KEY_MGMT_SUITE:\n\t\t\t\t\tlp->AuthKeyMgmtSuite = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_DISASSOCIATE_ADDR:\n\t\t\t\t\tpLtv->u.u16[ETH_ALEN / 2] = CNV_INT_TO_LITTLE(pLtv->u.u16[ETH_ALEN / 2]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_ADD_TKIP_DEFAULT_KEY:\n\t\t\t\tcase CFG_REMOVE_TKIP_DEFAULT_KEY:\n\t\t\t\t\t/* Endian convert the Tx Key Information */\n\t\t\t\t\tpLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_ADD_TKIP_MAPPED_KEY:\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_REMOVE_TKIP_MAPPED_KEY:\n\t\t\t\t\tbreak;\n\t\t\t\t/* some RIDs just can't be put */\n\t\t\t\tcase CFG_MB_INFO:\n\t\t\t\tcase CFG_IFB:\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* This code will prevent Static Configuration Entities from\n\t\t\t\t   being sent to the card, as they require a call to\n\t\t\t\t   UIL_ACT_APPLY to take effect. Dynamic Entities will be sent\n\t\t\t\t   immediately */\n\t\t\t\tswitch (pLtv->typ) {\n\t\t\t\tcase CFG_CNF_PORT_TYPE:\n\t\t\t\tcase CFG_CNF_OWN_MAC_ADDR:\n\t\t\t\tcase CFG_CNF_OWN_CHANNEL:\n\t\t\t\tcase CFG_CNF_OWN_SSID:\n\t\t\t\tcase CFG_CNF_OWN_ATIM_WINDOW:\n\t\t\t\tcase CFG_CNF_SYSTEM_SCALE:\n\t\t\t\tcase CFG_CNF_MAX_DATA_LEN:\n\t\t\t\tcase CFG_CNF_PM_ENABLED:\n\t\t\t\tcase CFG_CNF_MCAST_RX:\n\t\t\t\tcase CFG_CNF_MAX_SLEEP_DURATION:\n\t\t\t\tcase CFG_CNF_HOLDOVER_DURATION:\n\t\t\t\tcase CFG_CNF_OWN_NAME:\n\t\t\t\tcase CFG_CNF_LOAD_BALANCING:\n\t\t\t\tcase CFG_CNF_MEDIUM_DISTRIBUTION:\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_TX_POW_LVL:\n\t\t\t\tcase CFG_CNF_CONNECTION_CNTL:\n\t\t\t\t/*case CFG_PROBE_DATA_RATE: */\n#endif /* HERMES25 */\n#if 1 /*;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/*;?should we restore this to allow smaller memory footprint */\n\t\t\t\tcase CFG_CNF_OWN_DTIM_PERIOD:\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_OWN_BEACON_INTERVAL:                    /* Own Beacon Interval */\n#endif /* WARP */\n#ifdef USE_WDS\n\t\t\t\tcase CFG_CNF_WDS_ADDR1:\n\t\t\t\tcase CFG_CNF_WDS_ADDR2:\n\t\t\t\tcase CFG_CNF_WDS_ADDR3:\n\t\t\t\tcase CFG_CNF_WDS_ADDR4:\n\t\t\t\tcase CFG_CNF_WDS_ADDR5:\n\t\t\t\tcase CFG_CNF_WDS_ADDR6:\n#endif\n\t\t\t\tcase CFG_CNF_MCAST_PM_BUF:\n\t\t\t\tcase CFG_CNF_REJECT_ANY:\n#endif\n\n\t\t\t\tcase CFG_CNF_ENCRYPTION:\n\t\t\t\tcase CFG_CNF_AUTHENTICATION:\n#if 1 /* ;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\n\t\t\t\tcase CFG_CNF_EXCL_UNENCRYPTED:\n\t\t\t\tcase CFG_CNF_MCAST_RATE:\n\t\t\t\tcase CFG_CNF_INTRA_BSS_RELAY:\n#endif\n\n\t\t\t\tcase CFG_CNF_MICRO_WAVE:\n\t\t\t\t/* case CFG_CNF_LOAD_BALANCING: */\n\t\t\t\t/* case CFG_CNF_MEDIUM_DISTRIBUTION: */\n\t\t\t\t/* case CFG_CNF_RX_ALL_GROUP_ADDRESS: */\n\t\t\t\t/* case CFG_CNF_COUNTRY_INFO: */\n\t\t\t\t/* case CFG_COUNTRY_STRING: */\n\t\t\t\tcase CFG_AP_MODE:\n\t\t\t\tcase CFG_ENCRYPT_STRING:\n\t\t\t\t/* case CFG_DRIVER_ENABLE: */\n\t\t\t\tcase CFG_WOLAS_ENABLE:\n\t\t\t\tcase CFG_MB_INFO:\n\t\t\t\tcase CFG_IFB:\n\t\t\t\t\tbreak;\n\t\t\t\t/* Deal with this dynamic MSF RID, as it's required for WPA */\n\t\t\t\tcase CFG_DRIVER_ENABLE:\n\t\t\t\t\tif (lp->driverEnable) {\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_ENABLE | HCF_PORT_0);\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_CONNECT);\n\t\t\t\t\t} else {\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_DISABLE | HCF_PORT_0);\n\t\t\t\t\t\thcf_cntl(&(lp->hcfCtx), HCF_CNTL_DISCONNECT);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\twl_act_int_off(lp);\n\t\t\t\t\turq->result = hcf_put_info(&(lp->hcfCtx), (LTVP) pLtv);\n\t\t\t\t\twl_act_int_on(lp);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (ltvAllocated)\n\t\t\t\t\tkfree(pLtv);\n\t\t\t} else {\n\t\t\t\turq->result = UIL_FAILURE;\n\t\t\t}\n\t\t} else {\n\t\t\tDBG_ERROR(DbgInfo, \"EPERM\\n\");\n\t\t\turq->result = UIL_FAILURE;\n\t\t\tresult = -EPERM;\n\t\t}\n\t} else {\n\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_WRONG_IFB\\n\");\n\t\turq->result = UIL_ERR_WRONG_IFB;\n\t}\n\n\tDBG_LEAVE(DbgInfo);\n\treturn result;\n} /* wvlan_uil_put_info */\n", "target": 1, "idx": 179136}
{"func": "static int dev_ifconf(struct net *net, struct compat_ifconf __user *uifc32)\n{\n\tstruct compat_ifconf ifc32;\n\tstruct ifconf ifc;\n\tstruct ifconf __user *uifc;\n\tstruct compat_ifreq __user *ifr32;\n\tstruct ifreq __user *ifr;\n\tunsigned int i, j;\n\tint err;\n\n \tif (copy_from_user(&ifc32, uifc32, sizeof(struct compat_ifconf)))\n \t\treturn -EFAULT;\n \n \tif (ifc32.ifcbuf == 0) {\n \t\tifc32.ifc_len = 0;\n \t\tifc.ifc_len = 0;\n\t\tifc.ifc_req = NULL;\n\t\tuifc = compat_alloc_user_space(sizeof(struct ifconf));\n\t} else {\n\t\tsize_t len = ((ifc32.ifc_len / sizeof(struct compat_ifreq)) + 1) *\n\t\t\tsizeof(struct ifreq);\n\t\tuifc = compat_alloc_user_space(sizeof(struct ifconf) + len);\n\t\tifc.ifc_len = len;\n\t\tifr = ifc.ifc_req = (void __user *)(uifc + 1);\n\t\tifr32 = compat_ptr(ifc32.ifcbuf);\n\t\tfor (i = 0; i < ifc32.ifc_len; i += sizeof(struct compat_ifreq)) {\n\t\t\tif (copy_in_user(ifr, ifr32, sizeof(struct compat_ifreq)))\n\t\t\t\treturn -EFAULT;\n\t\t\tifr++;\n\t\t\tifr32++;\n\t\t}\n\t}\n\tif (copy_to_user(uifc, &ifc, sizeof(struct ifconf)))\n\t\treturn -EFAULT;\n\n\terr = dev_ioctl(net, SIOCGIFCONF, uifc);\n\tif (err)\n\t\treturn err;\n\n\tif (copy_from_user(&ifc, uifc, sizeof(struct ifconf)))\n\t\treturn -EFAULT;\n\n\tifr = ifc.ifc_req;\n\tifr32 = compat_ptr(ifc32.ifcbuf);\n\tfor (i = 0, j = 0;\n\t     i + sizeof(struct compat_ifreq) <= ifc32.ifc_len && j < ifc.ifc_len;\n\t     i += sizeof(struct compat_ifreq), j += sizeof(struct ifreq)) {\n\t\tif (copy_in_user(ifr32, ifr, sizeof(struct compat_ifreq)))\n\t\t\treturn -EFAULT;\n\t\tifr32++;\n\t\tifr++;\n\t}\n\n\tif (ifc32.ifcbuf == 0) {\n\t\t/* Translate from 64-bit structure multiple to\n\t\t * a 32-bit one.\n\t\t */\n\t\ti = ifc.ifc_len;\n\t\ti = ((i / sizeof(struct ifreq)) * sizeof(struct compat_ifreq));\n\t\tifc32.ifc_len = i;\n\t} else {\n\t\tifc32.ifc_len = i;\n\t}\n\tif (copy_to_user(uifc32, &ifc32, sizeof(struct compat_ifconf)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n", "target": 1, "idx": 179359}
{"func": "__checkparam_dl(const struct sched_attr *attr)\n{\n\treturn attr && attr->sched_deadline != 0 &&\n\t\t(attr->sched_period == 0 ||\n\t\t(s64)(attr->sched_period   - attr->sched_deadline) >= 0) &&\n\t\t(s64)(attr->sched_deadline - attr->sched_runtime ) >= 0  &&\n\t\tattr->sched_runtime >= (2 << (DL_SCALE - 1));\n}\n", "target": 0, "idx": 58112}
{"func": "int tcp_rcv_state_process(struct sock *sk, struct sk_buff *skb,\n\t\t\t  const struct tcphdr *th, unsigned int len)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tint queued = 0;\n\tint res;\n\n\ttp->rx_opt.saw_tstamp = 0;\n\n\tswitch (sk->sk_state) {\n\tcase TCP_CLOSE:\n\t\tgoto discard;\n\n\tcase TCP_LISTEN:\n\t\tif (th->ack)\n\t\t\treturn 1;\n\n\t\tif (th->rst)\n \t\t\tgoto discard;\n \n \t\tif (th->syn) {\n \t\t\tif (icsk->icsk_af_ops->conn_request(sk, skb) < 0)\n \t\t\t\treturn 1;\n \n\t\t\t/* Now we have several options: In theory there is\n\t\t\t * nothing else in the frame. KA9Q has an option to\n\t\t\t * send data with the syn, BSD accepts data with the\n\t\t\t * syn up to the [to be] advertised window and\n\t\t\t * Solaris 2.1 gives you a protocol error. For now\n\t\t\t * we just ignore it, that fits the spec precisely\n\t\t\t * and avoids incompatibilities. It would be nice in\n\t\t\t * future to drop through and process the data.\n\t\t\t *\n\t\t\t * Now that TTCP is starting to be used we ought to\n\t\t\t * queue this data.\n\t\t\t * But, this leaves one open to an easy denial of\n\t\t\t * service attack, and SYN cookies can't defend\n\t\t\t * against this problem. So, we drop the data\n\t\t\t * in the interest of security over speed unless\n\t\t\t * it's still in use.\n\t\t\t */\n\t\t\tkfree_skb(skb);\n\t\t\treturn 0;\n\t\t}\n\t\tgoto discard;\n\n\tcase TCP_SYN_SENT:\n\t\tqueued = tcp_rcv_synsent_state_process(sk, skb, th, len);\n\t\tif (queued >= 0)\n\t\t\treturn queued;\n\n\t\t/* Do step6 onward by hand. */\n\t\ttcp_urg(sk, skb, th);\n\t\t__kfree_skb(skb);\n\t\ttcp_data_snd_check(sk);\n\t\treturn 0;\n\t}\n\n\tres = tcp_validate_incoming(sk, skb, th, 0);\n\tif (res <= 0)\n\t\treturn -res;\n\n\t/* step 5: check the ACK field */\n\tif (th->ack) {\n\t\tint acceptable = tcp_ack(sk, skb, FLAG_SLOWPATH) > 0;\n\n\t\tswitch (sk->sk_state) {\n\t\tcase TCP_SYN_RECV:\n\t\t\tif (acceptable) {\n\t\t\t\ttp->copied_seq = tp->rcv_nxt;\n\t\t\t\tsmp_mb();\n\t\t\t\ttcp_set_state(sk, TCP_ESTABLISHED);\n\t\t\t\tsk->sk_state_change(sk);\n\n\t\t\t\t/* Note, that this wakeup is only for marginal\n\t\t\t\t * crossed SYN case. Passively open sockets\n\t\t\t\t * are not waked up, because sk->sk_sleep ==\n\t\t\t\t * NULL and sk->sk_socket == NULL.\n\t\t\t\t */\n\t\t\t\tif (sk->sk_socket)\n\t\t\t\t\tsk_wake_async(sk,\n\t\t\t\t\t\t      SOCK_WAKE_IO, POLL_OUT);\n\n\t\t\t\ttp->snd_una = TCP_SKB_CB(skb)->ack_seq;\n\t\t\t\ttp->snd_wnd = ntohs(th->window) <<\n\t\t\t\t\t      tp->rx_opt.snd_wscale;\n\t\t\t\ttcp_init_wl(tp, TCP_SKB_CB(skb)->seq);\n\n\t\t\t\tif (tp->rx_opt.tstamp_ok)\n\t\t\t\t\ttp->advmss -= TCPOLEN_TSTAMP_ALIGNED;\n\n\t\t\t\t/* Make sure socket is routed, for\n\t\t\t\t * correct metrics.\n\t\t\t\t */\n\t\t\t\ticsk->icsk_af_ops->rebuild_header(sk);\n\n\t\t\t\ttcp_init_metrics(sk);\n\n\t\t\t\ttcp_init_congestion_control(sk);\n\n\t\t\t\t/* Prevent spurious tcp_cwnd_restart() on\n\t\t\t\t * first data packet.\n\t\t\t\t */\n\t\t\t\ttp->lsndtime = tcp_time_stamp;\n\n\t\t\t\ttcp_mtup_init(sk);\n\t\t\t\ttcp_initialize_rcv_mss(sk);\n\t\t\t\ttcp_init_buffer_space(sk);\n\t\t\t\ttcp_fast_path_on(tp);\n\t\t\t} else {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TCP_FIN_WAIT1:\n\t\t\tif (tp->snd_una == tp->write_seq) {\n\t\t\t\ttcp_set_state(sk, TCP_FIN_WAIT2);\n\t\t\t\tsk->sk_shutdown |= SEND_SHUTDOWN;\n\t\t\t\tdst_confirm(__sk_dst_get(sk));\n\n\t\t\t\tif (!sock_flag(sk, SOCK_DEAD))\n\t\t\t\t\t/* Wake up lingering close() */\n\t\t\t\t\tsk->sk_state_change(sk);\n\t\t\t\telse {\n\t\t\t\t\tint tmo;\n\n\t\t\t\t\tif (tp->linger2 < 0 ||\n\t\t\t\t\t    (TCP_SKB_CB(skb)->end_seq != TCP_SKB_CB(skb)->seq &&\n\t\t\t\t\t     after(TCP_SKB_CB(skb)->end_seq - th->fin, tp->rcv_nxt))) {\n\t\t\t\t\t\ttcp_done(sk);\n\t\t\t\t\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPABORTONDATA);\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\n\t\t\t\t\ttmo = tcp_fin_time(sk);\n\t\t\t\t\tif (tmo > TCP_TIMEWAIT_LEN) {\n\t\t\t\t\t\tinet_csk_reset_keepalive_timer(sk, tmo - TCP_TIMEWAIT_LEN);\n\t\t\t\t\t} else if (th->fin || sock_owned_by_user(sk)) {\n\t\t\t\t\t\t/* Bad case. We could lose such FIN otherwise.\n\t\t\t\t\t\t * It is not a big problem, but it looks confusing\n\t\t\t\t\t\t * and not so rare event. We still can lose it now,\n\t\t\t\t\t\t * if it spins in bh_lock_sock(), but it is really\n\t\t\t\t\t\t * marginal case.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tinet_csk_reset_keepalive_timer(sk, tmo);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttcp_time_wait(sk, TCP_FIN_WAIT2, tmo);\n\t\t\t\t\t\tgoto discard;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TCP_CLOSING:\n\t\t\tif (tp->snd_una == tp->write_seq) {\n\t\t\t\ttcp_time_wait(sk, TCP_TIME_WAIT, 0);\n\t\t\t\tgoto discard;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TCP_LAST_ACK:\n\t\t\tif (tp->snd_una == tp->write_seq) {\n\t\t\t\ttcp_update_metrics(sk);\n\t\t\t\ttcp_done(sk);\n\t\t\t\tgoto discard;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t} else\n\t\tgoto discard;\n\n\t/* step 6: check the URG bit */\n\ttcp_urg(sk, skb, th);\n\n\t/* step 7: process the segment text */\n\tswitch (sk->sk_state) {\n\tcase TCP_CLOSE_WAIT:\n\tcase TCP_CLOSING:\n\tcase TCP_LAST_ACK:\n\t\tif (!before(TCP_SKB_CB(skb)->seq, tp->rcv_nxt))\n\t\t\tbreak;\n\tcase TCP_FIN_WAIT1:\n\tcase TCP_FIN_WAIT2:\n\t\t/* RFC 793 says to queue data in these states,\n\t\t * RFC 1122 says we MUST send a reset.\n\t\t * BSD 4.4 also does reset.\n\t\t */\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN) {\n\t\t\tif (TCP_SKB_CB(skb)->end_seq != TCP_SKB_CB(skb)->seq &&\n\t\t\t    after(TCP_SKB_CB(skb)->end_seq - th->fin, tp->rcv_nxt)) {\n\t\t\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPABORTONDATA);\n\t\t\t\ttcp_reset(sk);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\t/* Fall through */\n\tcase TCP_ESTABLISHED:\n\t\ttcp_data_queue(sk, skb);\n\t\tqueued = 1;\n\t\tbreak;\n\t}\n\n\t/* tcp_data could move socket to TIME-WAIT */\n\tif (sk->sk_state != TCP_CLOSE) {\n\t\ttcp_data_snd_check(sk);\n\t\ttcp_ack_snd_check(sk);\n\t}\n\n\tif (!queued) {\ndiscard:\n\t\t__kfree_skb(skb);\n\t}\n\treturn 0;\n}\n", "target": 1, "idx": 179721}
{"func": "GtkWidget* PageInfoWindowGtk::CreateSection(\n    const PageInfoModel::SectionInfo& section) {\n  GtkWidget* vbox = gtk_vbox_new(FALSE, gtk_util::kControlSpacing);\n  GtkWidget* label = gtk_label_new(UTF16ToUTF8(section.title).c_str());\n\n  PangoAttrList* attributes = pango_attr_list_new();\n  pango_attr_list_insert(attributes,\n                         pango_attr_weight_new(PANGO_WEIGHT_BOLD));\n  gtk_label_set_attributes(GTK_LABEL(label), attributes);\n  pango_attr_list_unref(attributes);\n  gtk_misc_set_alignment(GTK_MISC(label), 0, 0);\n  gtk_box_pack_start(GTK_BOX(vbox), label, FALSE, FALSE, 0);\n\n  GtkWidget* section_box = gtk_hbox_new(FALSE, 0);\n  ResourceBundle& rb = ResourceBundle::GetSharedInstance();\n  GtkWidget* image = gtk_image_new_from_pixbuf(section.state ?\n      rb.GetPixbufNamed(IDR_PAGEINFO_GOOD) :\n      rb.GetPixbufNamed(IDR_PAGEINFO_BAD));\n  gtk_box_pack_start(GTK_BOX(section_box), image, FALSE, FALSE,\n                     gtk_util::kControlSpacing);\n  gtk_misc_set_alignment(GTK_MISC(image), 0, 0);\n\n  GtkWidget* text_box = gtk_vbox_new(FALSE, gtk_util::kControlSpacing);\n  if (!section.head_line.empty()) {\n    label = gtk_label_new(UTF16ToUTF8(section.head_line).c_str());\n    gtk_misc_set_alignment(GTK_MISC(label), 0, 0);\n    gtk_box_pack_start(GTK_BOX(text_box), label, FALSE, FALSE, 0);\n  }\n   label = gtk_label_new(UTF16ToUTF8(section.description).c_str());\n   gtk_misc_set_alignment(GTK_MISC(label), 0, 0);\n   gtk_label_set_line_wrap(GTK_LABEL(label), TRUE);\n   gtk_box_pack_start(GTK_BOX(text_box), label, FALSE, FALSE, 0);\n   gtk_widget_set_size_request(label, 400, -1);\n \n  gtk_box_pack_start(GTK_BOX(section_box), text_box, TRUE, TRUE, 0);\n  gtk_box_pack_start(GTK_BOX(vbox), section_box, TRUE, TRUE, 0);\n\n  return vbox;\n}\n", "target": 1, "idx": 183492}
{"func": "static SUB_STATE_RETURN read_state_machine(SSL *s)\n{\n    OSSL_STATEM *st = &s->statem;\n    int ret, mt;\n    unsigned long len = 0;\n    int (*transition) (SSL *s, int mt);\n    PACKET pkt;\n    MSG_PROCESS_RETURN(*process_message) (SSL *s, PACKET *pkt);\n    WORK_STATE(*post_process_message) (SSL *s, WORK_STATE wst);\n    unsigned long (*max_message_size) (SSL *s);\n    void (*cb) (const SSL *ssl, int type, int val) = NULL;\n\n    cb = get_callback(s);\n\n    if (s->server) {\n        transition = ossl_statem_server_read_transition;\n        process_message = ossl_statem_server_process_message;\n        max_message_size = ossl_statem_server_max_message_size;\n        post_process_message = ossl_statem_server_post_process_message;\n    } else {\n        transition = ossl_statem_client_read_transition;\n        process_message = ossl_statem_client_process_message;\n        max_message_size = ossl_statem_client_max_message_size;\n        post_process_message = ossl_statem_client_post_process_message;\n    }\n\n    if (st->read_state_first_init) {\n        s->first_packet = 1;\n        st->read_state_first_init = 0;\n    }\n\n    while (1) {\n        switch (st->read_state) {\n        case READ_STATE_HEADER:\n            /* Get the state the peer wants to move to */\n            if (SSL_IS_DTLS(s)) {\n                /*\n                 * In DTLS we get the whole message in one go - header and body\n                 */\n                ret = dtls_get_message(s, &mt, &len);\n            } else {\n                ret = tls_get_message_header(s, &mt);\n            }\n\n            if (ret == 0) {\n                /* Could be non-blocking IO */\n                return SUB_STATE_ERROR;\n            }\n\n            if (cb != NULL) {\n                /* Notify callback of an impending state change */\n                if (s->server)\n                    cb(s, SSL_CB_ACCEPT_LOOP, 1);\n                else\n                    cb(s, SSL_CB_CONNECT_LOOP, 1);\n            }\n            /*\n             * Validate that we are allowed to move to the new state and move\n             * to that state if so\n             */\n            if (!transition(s, mt)) {\n                ossl_statem_set_error(s);\n                return SUB_STATE_ERROR;\n            }\n\n            if (s->s3->tmp.message_size > max_message_size(s)) {\n                ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_ILLEGAL_PARAMETER);\n                SSLerr(SSL_F_READ_STATE_MACHINE, SSL_R_EXCESSIVE_MESSAGE_SIZE);\n                 return SUB_STATE_ERROR;\n             }\n \n             st->read_state = READ_STATE_BODY;\n             /* Fall through */\n            if (!PACKET_buf_init(&pkt, s->init_msg, len)) {\n                ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);\n                SSLerr(SSL_F_READ_STATE_MACHINE, ERR_R_INTERNAL_ERROR);\n                return SUB_STATE_ERROR;\n            }\n            ret = process_message(s, &pkt);\n\n            /* Discard the packet data */\n            s->init_num = 0;\n\n            switch (ret) {\n            case MSG_PROCESS_ERROR:\n                return SUB_STATE_ERROR;\n\n            case MSG_PROCESS_FINISHED_READING:\n                if (SSL_IS_DTLS(s)) {\n                    dtls1_stop_timer(s);\n                }\n                return SUB_STATE_FINISHED;\n\n            case MSG_PROCESS_CONTINUE_PROCESSING:\n                st->read_state = READ_STATE_POST_PROCESS;\n                st->read_state_work = WORK_MORE_A;\n                break;\n\n            default:\n                st->read_state = READ_STATE_HEADER;\n                break;\n            }\n            break;\n\n        case READ_STATE_POST_PROCESS:\n            st->read_state_work = post_process_message(s, st->read_state_work);\n            switch (st->read_state_work) {\n            default:\n                return SUB_STATE_ERROR;\n\n            case WORK_FINISHED_CONTINUE:\n                st->read_state = READ_STATE_HEADER;\n                break;\n\n            case WORK_FINISHED_STOP:\n                if (SSL_IS_DTLS(s)) {\n                    dtls1_stop_timer(s);\n                }\n                return SUB_STATE_FINISHED;\n            }\n            break;\n\n        default:\n            /* Shouldn't happen */\n            ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);\n            SSLerr(SSL_F_READ_STATE_MACHINE, ERR_R_INTERNAL_ERROR);\n            ossl_statem_set_error(s);\n            return SUB_STATE_ERROR;\n        }\n    }\n}\n", "target": 1, "idx": 178134}
{"func": "static v8::Handle<v8::Value> convert4Callback(const v8::Arguments& args)\n {\n     INC_STATS(\"DOM.TestObj.convert4\");\n     if (args.Length() < 1)\n        return V8Proxy::throwNotEnoughArgumentsError();\n     TestObj* imp = V8TestObj::toNative(args.Holder());\n     EXCEPTION_BLOCK(d*, , V8d::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8d::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);\n     imp->convert4();\n    return v8::Handle<v8::Value>();\n}\n", "target": 1, "idx": 184772}
{"func": "acc_ctx_new(OM_uint32 *minor_status,\n\t    gss_buffer_t buf,\n\t    gss_ctx_id_t *ctx,\n\t    spnego_gss_cred_id_t spcred,\n\t    gss_buffer_t *mechToken,\n\t    gss_buffer_t *mechListMIC,\n\t    OM_uint32 *negState,\n\t    send_token_flag *return_token)\n{\n\tOM_uint32 tmpmin, ret, req_flags;\n\tgss_OID_set supported_mechSet, mechTypes;\n\tgss_buffer_desc der_mechTypes;\n\tgss_OID mech_wanted;\n\tspnego_gss_ctx_id_t sc = NULL;\n\n\tret = GSS_S_DEFECTIVE_TOKEN;\n\tder_mechTypes.length = 0;\n\tder_mechTypes.value = NULL;\n\t*mechToken = *mechListMIC = GSS_C_NO_BUFFER;\n\tsupported_mechSet = mechTypes = GSS_C_NO_OID_SET;\n\t*return_token = ERROR_TOKEN_SEND;\n\t*negState = REJECT;\n\t*minor_status = 0;\n\n\tret = get_negTokenInit(minor_status, buf, &der_mechTypes,\n\t\t\t       &mechTypes, &req_flags,\n\t\t\t       mechToken, mechListMIC);\n\tif (ret != GSS_S_COMPLETE) {\n\t\tgoto cleanup;\n\t}\n\tret = get_negotiable_mechs(minor_status, spcred, GSS_C_ACCEPT,\n\t\t\t\t   &supported_mechSet);\n\tif (ret != GSS_S_COMPLETE) {\n\t\t*return_token = NO_TOKEN_SEND;\n\t\tgoto cleanup;\n\t}\n\t/*\n\t * Select the best match between the list of mechs\n\t * that the initiator requested and the list that\n\t * the acceptor will support.\n\t */\n\tmech_wanted = negotiate_mech(supported_mechSet, mechTypes, negState);\n\tif (*negState == REJECT) {\n\t\tret = GSS_S_BAD_MECH;\n\t\tgoto cleanup;\n\t}\n\tsc = (spnego_gss_ctx_id_t)*ctx;\n\tif (sc != NULL) {\n \t\tgss_release_buffer(&tmpmin, &sc->DER_mechTypes);\n \t\tassert(mech_wanted != GSS_C_NO_OID);\n \t} else\n\t\tsc = create_spnego_ctx();\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\t*return_token = NO_TOKEN_SEND;\n\t\tgoto cleanup;\n\t}\n\tsc->mech_set = mechTypes;\n\tmechTypes = GSS_C_NO_OID_SET;\n\tsc->internal_mech = mech_wanted;\n\tsc->DER_mechTypes = der_mechTypes;\n\tder_mechTypes.length = 0;\n\tder_mechTypes.value = NULL;\n\n\tif (*negState == REQUEST_MIC)\n\t\tsc->mic_reqd = 1;\n\n\t*return_token = INIT_TOKEN_SEND;\n\tsc->firstpass = 1;\n\t*ctx = (gss_ctx_id_t)sc;\n\tret = GSS_S_COMPLETE;\ncleanup:\n\tgss_release_oid_set(&tmpmin, &mechTypes);\n\tgss_release_oid_set(&tmpmin, &supported_mechSet);\n\tif (der_mechTypes.length != 0)\n\t\tgss_release_buffer(&tmpmin, &der_mechTypes);\n\n\treturn ret;\n}\n", "target": 1, "idx": 179820}
{"func": "long arch_ptrace(struct task_struct *child, long request,\n\t\t unsigned long addr, unsigned long data)\n{\n\tint ret;\n\tunsigned long __user *datap = (unsigned long __user *) data;\n\n\tswitch (request) {\n\t\tcase PTRACE_PEEKUSR:\n\t\t\tret = ptrace_read_user(child, addr, datap);\n\t\t\tbreak;\n\n\t\tcase PTRACE_POKEUSR:\n\t\t\tret = ptrace_write_user(child, addr, data);\n\t\t\tbreak;\n\n\t\tcase PTRACE_GETREGS:\n\t\t\tret = copy_regset_to_user(child,\n\t\t\t\t\t\t  &user_arm_view, REGSET_GPR,\n\t\t\t\t\t\t  0, sizeof(struct pt_regs),\n\t\t\t\t\t\t  datap);\n\t\t\tbreak;\n\n\t\tcase PTRACE_SETREGS:\n\t\t\tret = copy_regset_from_user(child,\n\t\t\t\t\t\t    &user_arm_view, REGSET_GPR,\n\t\t\t\t\t\t    0, sizeof(struct pt_regs),\n\t\t\t\t\t\t    datap);\n\t\t\tbreak;\n\n\t\tcase PTRACE_GETFPREGS:\n\t\t\tret = copy_regset_to_user(child,\n\t\t\t\t\t\t  &user_arm_view, REGSET_FPR,\n\t\t\t\t\t\t  0, sizeof(union fp_state),\n\t\t\t\t\t\t  datap);\n\t\t\tbreak;\n\n\t\tcase PTRACE_SETFPREGS:\n\t\t\tret = copy_regset_from_user(child,\n\t\t\t\t\t\t    &user_arm_view, REGSET_FPR,\n\t\t\t\t\t\t    0, sizeof(union fp_state),\n\t\t\t\t\t\t    datap);\n\t\t\tbreak;\n\n#ifdef CONFIG_IWMMXT\n\t\tcase PTRACE_GETWMMXREGS:\n\t\t\tret = ptrace_getwmmxregs(child, datap);\n\t\t\tbreak;\n\n\t\tcase PTRACE_SETWMMXREGS:\n\t\t\tret = ptrace_setwmmxregs(child, datap);\n\t\t\tbreak;\n #endif\n \n \t\tcase PTRACE_GET_THREAD_AREA:\n\t\t\tret = put_user(task_thread_info(child)->tp_value,\n \t\t\t\t       datap);\n \t\t\tbreak;\n \n\t\tcase PTRACE_SET_SYSCALL:\n\t\t\ttask_thread_info(child)->syscall = data;\n\t\t\tret = 0;\n\t\t\tbreak;\n\n#ifdef CONFIG_CRUNCH\n\t\tcase PTRACE_GETCRUNCHREGS:\n\t\t\tret = ptrace_getcrunchregs(child, datap);\n\t\t\tbreak;\n\n\t\tcase PTRACE_SETCRUNCHREGS:\n\t\t\tret = ptrace_setcrunchregs(child, datap);\n\t\t\tbreak;\n#endif\n\n#ifdef CONFIG_VFP\n\t\tcase PTRACE_GETVFPREGS:\n\t\t\tret = copy_regset_to_user(child,\n\t\t\t\t\t\t  &user_arm_view, REGSET_VFP,\n\t\t\t\t\t\t  0, ARM_VFPREGS_SIZE,\n\t\t\t\t\t\t  datap);\n\t\t\tbreak;\n\n\t\tcase PTRACE_SETVFPREGS:\n\t\t\tret = copy_regset_from_user(child,\n\t\t\t\t\t\t    &user_arm_view, REGSET_VFP,\n\t\t\t\t\t\t    0, ARM_VFPREGS_SIZE,\n\t\t\t\t\t\t    datap);\n\t\t\tbreak;\n#endif\n\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\t\tcase PTRACE_GETHBPREGS:\n\t\t\tif (ptrace_get_breakpoints(child) < 0)\n\t\t\t\treturn -ESRCH;\n\n\t\t\tret = ptrace_gethbpregs(child, addr,\n\t\t\t\t\t\t(unsigned long __user *)data);\n\t\t\tptrace_put_breakpoints(child);\n\t\t\tbreak;\n\t\tcase PTRACE_SETHBPREGS:\n\t\t\tif (ptrace_get_breakpoints(child) < 0)\n\t\t\t\treturn -ESRCH;\n\n\t\t\tret = ptrace_sethbpregs(child, addr,\n\t\t\t\t\t\t(unsigned long __user *)data);\n\t\t\tptrace_put_breakpoints(child);\n\t\t\tbreak;\n#endif\n\n\t\tdefault:\n\t\t\tret = ptrace_request(child, request, addr, data);\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n", "target": 1, "idx": 180752}
{"func": "PHP_FUNCTION(pg_get_notify)\n{\n\tzval *pgsql_link;\n\tint id = -1;\n\tlong result_type = PGSQL_ASSOC;\n\tPGconn *pgsql;\n\tPGnotify *pgsql_notify;\n\n\tif (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, ZEND_NUM_ARGS() TSRMLS_CC, \"r|l\",\n\t\t\t\t\t\t\t\t &pgsql_link, &result_type) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, \"PostgreSQL link\", le_link, le_plink);\n\n\tif (!(result_type & PGSQL_BOTH)) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid result type\");\n\t\tRETURN_FALSE;\n\t}\n\n\tPQconsumeInput(pgsql);\n\tpgsql_notify = PQnotifies(pgsql);\n\tif (!pgsql_notify) {\n\t\t/* no notify message */\n\t\tRETURN_FALSE;\n\t}\n\tarray_init(return_value);\n\tif (result_type & PGSQL_NUM) {\n\t\tadd_index_string(return_value, 0, pgsql_notify->relname, 1);\n\t\tadd_index_long(return_value, 1, pgsql_notify->be_pid);\n#if HAVE_PQPROTOCOLVERSION && HAVE_PQPARAMETERSTATUS \n\t\tif (PQprotocolVersion(pgsql) >= 3 && atof(PQparameterStatus(pgsql, \"server_version\")) >= 9.0) {\n#else \n\t\tif (atof(PG_VERSION) >= 9.0) {\n#endif \n#if HAVE_PQPARAMETERSTATUS\n\t\t\tadd_index_string(return_value, 2, pgsql_notify->extra, 1);\n#endif\n\t\t}\n\t}\n\tif (result_type & PGSQL_ASSOC) {\n\t\tadd_assoc_string(return_value, \"message\", pgsql_notify->relname, 1);\n\t\tadd_assoc_long(return_value, \"pid\", pgsql_notify->be_pid);\n#if HAVE_PQPROTOCOLVERSION && HAVE_PQPARAMETERSTATUS \n\t\tif (PQprotocolVersion(pgsql) >= 3 && atof(PQparameterStatus(pgsql, \"server_version\")) >= 9.0) {\n#else \n\t\tif (atof(PG_VERSION) >= 9.0) {\n#endif \n#if HAVE_PQPARAMETERSTATUS\n\t\t\tadd_assoc_string(return_value, \"payload\", pgsql_notify->extra, 1);\n#endif\n\t\t}\n\t}\n\tPQfreemem(pgsql_notify);\n}\n/* }}} */\n\n/* {{{ proto int pg_get_pid([resource connection)\n   Get backend(server) pid */\nPHP_FUNCTION(pg_get_pid)\n{\n\tzval *pgsql_link;\n\tint id = -1;\n\tPGconn *pgsql;\n\n\tif (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, ZEND_NUM_ARGS() TSRMLS_CC, \"r\",\n\t\t\t\t\t\t\t\t &pgsql_link) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, \"PostgreSQL link\", le_link, le_plink);\n\n\tRETURN_LONG(PQbackendPID(pgsql));\n}\n/* }}} */\n\n/* {{{ php_pgsql_meta_data\n * TODO: Add meta_data cache for better performance\n */\nPHP_PGSQL_API int php_pgsql_meta_data(PGconn *pg_link, const char *table_name, zval *meta TSRMLS_DC) \n{\n\tPGresult *pg_result;\n\tchar *src, *tmp_name, *tmp_name2 = NULL;\n\tchar *escaped;\n\tsmart_str querystr = {0};\n\tsize_t new_len;\n\tint i, num_rows;\n\tzval *elem;\n\n\tif (!*table_name) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"The table name must be specified\");\n\t\treturn FAILURE;\n\t}\n \n        src = estrdup(table_name);\n        tmp_name = php_strtok_r(src, \".\", &tmp_name2);\n        if (!tmp_name2 || !*tmp_name2) {\n                /* Default schema */\n                tmp_name2 = tmp_name;\n\t\t\t\"SELECT a.attname, a.attnum, t.typname, a.attlen, a.attnotnull, a.atthasdef, a.attndims, t.typtype = 'e' \"\n\t\t\t\"FROM pg_class as c, pg_attribute a, pg_type t, pg_namespace n \"\n\t\t\t\"WHERE a.attnum > 0 AND a.attrelid = c.oid AND c.relname = '\");\n\tescaped = (char *)safe_emalloc(strlen(tmp_name2), 2, 1);\n\tnew_len = PQescapeStringConn(pg_link, escaped, tmp_name2, strlen(tmp_name2), NULL);\n\tif (new_len) {\n\t\tsmart_str_appendl(&querystr, escaped, new_len);\n\t}\n\tefree(escaped);\n\n\tsmart_str_appends(&querystr, \"' AND c.relnamespace = n.oid AND n.nspname = '\");\n\tescaped = (char *)safe_emalloc(strlen(tmp_name), 2, 1);\n\tnew_len = PQescapeStringConn(pg_link, escaped, tmp_name, strlen(tmp_name), NULL);\n\tif (new_len) {\n\t\tsmart_str_appendl(&querystr, escaped, new_len);\n\t}\n\tefree(escaped);\n\n\tsmart_str_appends(&querystr, \"' AND a.atttypid = t.oid ORDER BY a.attnum;\");\n\tsmart_str_0(&querystr);\n\tefree(src);\n\n\tpg_result = PQexec(pg_link, querystr.c);\n\tif (PQresultStatus(pg_result) != PGRES_TUPLES_OK || (num_rows = PQntuples(pg_result)) == 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Table '%s' doesn't exists\", table_name);\n\t\tsmart_str_free(&querystr);\n\t\tPQclear(pg_result);\n\t\treturn FAILURE;\n\t}\n\tsmart_str_free(&querystr);\n\n\tfor (i = 0; i < num_rows; i++) {\n\t\tchar *name;\n\t\tMAKE_STD_ZVAL(elem);\n\t\tarray_init(elem);\n\t\tadd_assoc_long(elem, \"num\", atoi(PQgetvalue(pg_result,i,1)));\n\t\tadd_assoc_string(elem, \"type\", PQgetvalue(pg_result,i,2), 1);\n\t\tadd_assoc_long(elem, \"len\", atoi(PQgetvalue(pg_result,i,3)));\n\t\tif (!strcmp(PQgetvalue(pg_result,i,4), \"t\")) {\n\t\t\tadd_assoc_bool(elem, \"not null\", 1);\n\t\t}\n\t\telse {\n\t\t\tadd_assoc_bool(elem, \"not null\", 0);\n\t\t}\n\t\tif (!strcmp(PQgetvalue(pg_result,i,5), \"t\")) {\n\t\t\tadd_assoc_bool(elem, \"has default\", 1);\n\t\t}\n\t\telse {\n\t\t\tadd_assoc_bool(elem, \"has default\", 0);\n\t\t}\n\t\tadd_assoc_long(elem, \"array dims\", atoi(PQgetvalue(pg_result,i,6)));\n\t\tif (!strcmp(PQgetvalue(pg_result,i,7), \"t\")) {\n\t\t\tadd_assoc_bool(elem, \"is enum\", 1);\n\t\t}\n\t\telse {\n\t\t\tadd_assoc_bool(elem, \"is enum\", 0);\n\t\t}\n\t\tname = PQgetvalue(pg_result,i,0);\n\t\tadd_assoc_zval(meta, name, elem);\n\t}\n\tPQclear(pg_result);\n\t\n\treturn SUCCESS;\n}\n\n/* }}} */\n", "target": 1, "idx": 178472}
{"func": "void GLES2DecoderTestBase::DoDeleteBuffer(\n    GLuint client_id, GLuint service_id) {\n  EXPECT_CALL(*gl_, DeleteBuffersARB(1, Pointee(service_id)))\n      .Times(1)\n      .RetiresOnSaturation();\n  DeleteBuffers cmd;\n  cmd.Init(1, shared_memory_id_, shared_memory_offset_);\n  memcpy(shared_memory_address_, &client_id, sizeof(client_id));\n  EXPECT_EQ(error::kNoError, ExecuteCmd(cmd));\n}\n", "target": 0, "idx": 108184}
{"func": "static void jffs2_iset_acl(struct inode *inode, struct posix_acl **i_acl, struct posix_acl *acl)\n{\n\tspin_lock(&inode->i_lock);\n\tif (*i_acl != JFFS2_ACL_NOT_CACHED)\n\t\tposix_acl_release(*i_acl);\n\t*i_acl = posix_acl_dup(acl);\n        spin_unlock(&inode->i_lock);\n }\n", "target": 0, "idx": 1813}
{"func": "bool ParamTraits<AudioParameters>::Read(const Message* m,\n                                        PickleIterator* iter,\n                                        AudioParameters* r) {\n  int format, channel_layout, sample_rate, bits_per_sample,\n      frames_per_buffer, channels;\n\n  if (!m->ReadInt(iter, &format) ||\n      !m->ReadInt(iter, &channel_layout) ||\n      !m->ReadInt(iter, &sample_rate) ||\n      !m->ReadInt(iter, &bits_per_sample) ||\n      !m->ReadInt(iter, &frames_per_buffer) ||\n      !m->ReadInt(iter, &channels))\n    return false;\n   r->Reset(static_cast<AudioParameters::Format>(format),\n            static_cast<ChannelLayout>(channel_layout),\n            sample_rate, bits_per_sample, frames_per_buffer);\n   return true;\n }\n", "target": 1, "idx": 185229}
{"func": "void RenderBlockFlow::styleDidChange(StyleDifference diff, const RenderStyle* oldStyle)\n{\n    RenderBlock::styleDidChange(diff, oldStyle);\n\n     bool canPropagateFloatIntoSibling = !isFloatingOrOutOfFlowPositioned() && !avoidsFloats();\n    if (diff == StyleDifferenceLayout && s_canPropagateFloatIntoSibling && !canPropagateFloatIntoSibling && hasOverhangingFloats()) {\n         RenderBlockFlow* parentBlockFlow = this;\n         const FloatingObjectSet& floatingObjectSet = m_floatingObjects->set();\n         FloatingObjectSetIterator end = floatingObjectSet.end();\n\n        for (RenderObject* curr = parent(); curr && !curr->isRenderView(); curr = curr->parent()) {\n            if (curr->isRenderBlockFlow()) {\n                RenderBlockFlow* currBlock = toRenderBlockFlow(curr);\n\n                if (currBlock->hasOverhangingFloats()) {\n                    for (FloatingObjectSetIterator it = floatingObjectSet.begin(); it != end; ++it) {\n                        RenderBox* renderer = (*it)->renderer();\n                        if (currBlock->hasOverhangingFloat(renderer)) {\n                            parentBlockFlow = currBlock;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        parentBlockFlow->markAllDescendantsWithFloatsForLayout();\n         parentBlockFlow->markSiblingsWithFloatsForLayout();\n     }\n \n    if (diff == StyleDifferenceLayout || !oldStyle)\n         createOrDestroyMultiColumnFlowThreadIfNeeded();\n }\n", "target": 1, "idx": 185160}
{"func": "struct edid *drm_load_edid_firmware(struct drm_connector *connector)\n{\n\tconst char *connector_name = connector->name;\n\tchar *edidname, *last, *colon, *fwstr, *edidstr, *fallback = NULL;\n\tstruct edid *edid;\n\n\tif (edid_firmware[0] == '\\0')\n\t\treturn ERR_PTR(-ENOENT);\n\n\t/*\n\t * If there are multiple edid files specified and separated\n\t * by commas, search through the list looking for one that\n\t * matches the connector.\n\t *\n\t * If there's one or more that doesn't specify a connector, keep\n \t * the last one found one as a fallback.\n \t */\n \tfwstr = kstrdup(edid_firmware, GFP_KERNEL);\n \tedidstr = fwstr;\n \n \twhile ((edidname = strsep(&edidstr, \",\"))) {\n\t\t\tif (strncmp(connector_name, edidname, colon - edidname))\n\t\t\t\tcontinue;\n\t\t\tedidname = colon + 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (*edidname != '\\0') /* corner case: multiple ',' */\n\t\t\tfallback = edidname;\n\t}\n", "target": 1, "idx": 177881}
{"func": "uint8_t CSPSourceList::hashAlgorithmsUsed() const\n{\n    return m_hashAlgorithmsUsed;\n}\n", "target": 0, "idx": 136255}
{"func": "void RenderFrameImpl::BubbleLogicalScrollInParentFrame(\n    blink::WebScrollDirection direction,\n    blink::WebScrollGranularity granularity) {\n  DCHECK(IsLocalRoot());\n  DCHECK(!IsMainFrame());\n  Send(new FrameHostMsg_BubbleLogicalScrollInParentFrame(routing_id_, direction,\n                                                         granularity));\n}\n", "target": 0, "idx": 152205}
{"func": "ExtensionPrefs* ExtensionService::extension_prefs() {\n  return extension_prefs_;\n}\n", "target": 0, "idx": 103543}
{"func": "double GetGPMFSampleRate(size_t handle, uint32_t fourcc, uint32_t flags)\n {\n \tmp4object *mp4 = (mp4object *)handle;\n \tif (mp4 == NULL) return 0.0;\n\n\tGPMF_stream metadata_stream, *ms = &metadata_stream;\n\tuint32_t teststart = 0;\n \tuint32_t testend = mp4->indexcount;\n \tdouble rate = 0.0;\n \n \tif (mp4->indexcount < 1)\n \t\treturn 0.0;\n \n\tif (mp4->indexcount > 3) // samples after first and before last are statistically the best, avoiding camera start up or shutdown anomollies. \n\t{\n\t\tteststart++;\n\t\ttestend--;\n\t}\n\tuint32_t *payload = GetPayload(handle, NULL, teststart); // second payload\n\tuint32_t payloadsize = GetPayloadSize(handle, teststart);\n\tint32_t ret = GPMF_Init(ms, payload, payloadsize);\n \n \tif (ret != GPMF_OK)\n \t\tgoto cleanup;\n \n \t{\n \t\tuint32_t startsamples = 0;\n \t\tuint32_t endsamples = 0;\n\t\tuint32_t missing_samples = 0;\n \n\t\twhile (ret == GPMF_OK && GPMF_OK != GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))\n \t\t{\n\t\t\tmissing_samples = 1;\n \t\t\tteststart++;\n \t\t\tpayload = GetPayload(handle, payload, teststart); // second last payload\n \t\t\tpayloadsize = GetPayloadSize(handle, teststart);\n \t\t\tret = GPMF_Init(ms, payload, payloadsize);\n \t\t}\n \n\t\tif (missing_samples)\n\t\t{\n\t\t\tteststart++;   //samples after sensor start are statistically the best\n\t\t\tpayload = GetPayload(handle, payload, teststart);\n\t\t\tpayloadsize = GetPayloadSize(handle, teststart);\n\t\t\tret = GPMF_Init(ms, payload, payloadsize);\n\t\t}\n\t\tif (ret == GPMF_OK)\n \t\t{\n\t\t\tuint32_t samples = GPMF_Repeat(ms);\n \t\t\tGPMF_stream find_stream;\n \t\t\tGPMF_CopyState(ms, &find_stream);\n \n\t\t\tif (!(flags & GPMF_SAMPLE_RATE_PRECISE) && GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))\n \t\t\t{\n\t\t\t\tstartsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream)) - samples;\n \n\t\t\t\tpayload = GetPayload(handle, payload, testend); // second last payload\n \t\t\t\tpayloadsize = GetPayloadSize(handle, testend);\n \t\t\t\tret = GPMF_Init(ms, payload, payloadsize);\n\t\t\t\tif (ret != GPMF_OK)\n\t\t\t\t\tgoto cleanup;\n \n\t\t\t\tif (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))\n \t\t\t\t{\n\t\t\t\t\tGPMF_CopyState(ms, &find_stream);\n\t\t\t\t\tif (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))\n \t\t\t\t\t{\n\t\t\t\t\t\tendsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream));\n\t\t\t\t\t\trate = (double)(endsamples - startsamples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);\n\t\t\t\t\t\tgoto cleanup;\n \t\t\t\t\t}\n \t\t\t\t}\n\t\t\t\trate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);\n \t\t\t}\n\t\t\telse // for increased precision, for older GPMF streams sometimes missing the total sample count \n \t\t\t{\n\t\t\t\tuint32_t payloadpos = 0, payloadcount = 0;\n\t\t\t\tdouble slope, top = 0.0, bot = 0.0, meanX = 0, meanY = 0;\n\t\t\t\tuint32_t *repeatarray = malloc(mp4->indexcount * 4 + 4);\n\t\t\t\tmemset(repeatarray, 0, mp4->indexcount * 4 + 4);\n \n\t\t\t\tsamples = 0;\n \n\t\t\t\tfor (payloadpos = teststart; payloadpos < testend; payloadcount++, payloadpos++)\n \t\t\t\t{\n\t\t\t\t\tpayload = GetPayload(handle, payload, payloadpos); // second last payload\n\t\t\t\t\tpayloadsize = GetPayloadSize(handle, payloadpos);\n\t\t\t\t\tret = GPMF_Init(ms, payload, payloadsize);\n \n\t\t\t\t\tif (ret != GPMF_OK)\n\t\t\t\t\t\tgoto cleanup;\n \n\t\t\t\t\tif (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))\n \t\t\t\t\t{\n\t\t\t\t\t\tGPMF_stream find_stream2;\n\t\t\t\t\t\tGPMF_CopyState(ms, &find_stream2);\n \n\t\t\t\t\t\tif (GPMF_OK == GPMF_FindNext(&find_stream2, fourcc, GPMF_CURRENT_LEVEL)) // Count the instances, not the repeats\n \t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (repeatarray)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfloat in, out;\n \n\t\t\t\t\t\t\t\tdo\n \t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tsamples++;\n\t\t\t\t\t\t\t\t} while (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_CURRENT_LEVEL));\n \n\t\t\t\t\t\t\t\trepeatarray[payloadpos] = samples;\n\t\t\t\t\t\t\t\tmeanY += (double)samples;\n \n\t\t\t\t\t\t\t\tGetPayloadTime(handle, payloadpos, &in, &out);\n\t\t\t\t\t\t\t\tmeanX += out;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tuint32_t repeat = GPMF_Repeat(ms);\n\t\t\t\t\t\t\tsamples += repeat;\n \n\t\t\t\t\t\t\tif (repeatarray)\n \t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfloat in, out;\n \n\t\t\t\t\t\t\t\trepeatarray[payloadpos] = samples;\n\t\t\t\t\t\t\t\tmeanY += (double)samples;\n \n\t\t\t\t\t\t\t\tGetPayloadTime(handle, payloadpos, &in, &out);\n\t\t\t\t\t\t\t\tmeanX += out;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (repeatarray)\n\t\t\t\t{\n\t\t\t\t\tmeanY /= (double)payloadcount;\n\t\t\t\t\tmeanX /= (double)payloadcount;\n \n\t\t\t\t\tfor (payloadpos = teststart; payloadpos < testend; payloadpos++)\n \t\t\t\t\t{\n\t\t\t\t\t\tfloat in, out;\n\t\t\t\t\t\tGetPayloadTime(handle, payloadpos, &in, &out);\n \n\t\t\t\t\t\ttop += ((double)out - meanX)*((double)repeatarray[payloadpos] - meanY);\n\t\t\t\t\t\tbot += ((double)out - meanX)*((double)out - meanX);\n\t\t\t\t\t}\n \n\t\t\t\t\tslope = top / bot;\n \n #if 0\n \t\t\t\t\t{\n\t\t\t\t\t\tdouble intercept;\n\t\t\t\t\t\tintercept = meanY - slope*meanX;\n\t\t\t\t\t\tprintf(\"%c%c%c%c start offset = %f (%.3fms)\\n\", PRINTF_4CC(fourcc), intercept, 1000.0 * intercept / slope);\n \t\t\t\t\t}\n#endif\n\t\t\t\t\trate = slope;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\trate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);\n\t\t\t\t}\n\t\t\t\tfree(repeatarray);\n \n\t\t\t\tgoto cleanup;\n \t\t\t}\n\t\t}\n\t}\n \ncleanup:\n\tif (payload) \n\t{\n\t\tFreePayload(payload);\n\t\tpayload = NULL;\n\t}\n\treturn rate;\n}\n", "target": 1, "idx": 182718}
{"func": "void ipv4_pktinfo_prepare(const struct sock *sk, struct sk_buff *skb)\n{\n\tstruct in_pktinfo *pktinfo = PKTINFO_SKB_CB(skb);\n\tbool prepare = (inet_sk(sk)->cmsg_flags & IP_CMSG_PKTINFO) ||\n\t\t       ipv6_sk_rxinfo(sk);\n\n\tif (prepare && skb_rtable(skb)) {\n\t\t/* skb->cb is overloaded: prior to this point it is IP{6}CB\n\t\t * which has interface index (iif) as the first member of the\n\t\t * underlying inet{6}_skb_parm struct. This code then overlays\n\t\t * PKTINFO_SKB_CB and in_pktinfo also has iif as the first\n\t\t * element so the iif is picked up from the prior IPCB. If iif\n\t\t * is the loopback interface, then return the sending interface\n\t\t * (e.g., process binds socket to eth0 for Tx which is\n\t\t * redirected to loopback in the rtable/dst).\n\t\t */\n\t\tif (pktinfo->ipi_ifindex == LOOPBACK_IFINDEX)\n\t\t\tpktinfo->ipi_ifindex = inet_iif(skb);\n\n\t\tpktinfo->ipi_spec_dst.s_addr = fib_compute_spec_dst(skb);\n\t} else {\n\t\tpktinfo->ipi_ifindex = 0;\n\t\tpktinfo->ipi_spec_dst.s_addr = 0;\n\t}\n\t/* We need to keep the dst for __ip_options_echo()\n\t * We could restrict the test to opt.ts_needtime || opt.srr,\n\t * but the following is good enough as IP options are not often used.\n\t */\n\tif (unlikely(IPCB(skb)->opt.optlen))\n\t\tskb_dst_force(skb);\n\telse\n\t\tskb_dst_drop(skb);\n}\n", "target": 0, "idx": 68179}
{"func": "void RenderFrameHostManager::CreateProxiesForNewRenderFrameHost(\n    SiteInstance* old_instance,\n    SiteInstance* new_instance) {\n  if (new_instance->IsRelatedSiteInstance(old_instance)) {\n    CreateOpenerProxies(new_instance, frame_tree_node_);\n  } else {\n    frame_tree_node_->frame_tree()->CreateProxiesForSiteInstance(\n        frame_tree_node_, new_instance);\n  }\n}\n", "target": 0, "idx": 159631}
{"func": "RenderWidgetHostViewAndroid::RenderWidgetHostViewAndroid(\n    RenderWidgetHostImpl* widget_host,\n    ContentViewCoreImpl* content_view_core)\n    : host_(widget_host),\n      is_layer_attached_(true),\n       content_view_core_(NULL),\n       ime_adapter_android_(ALLOW_THIS_IN_INITIALIZER_LIST(this)),\n       cached_background_color_(SK_ColorWHITE),\n      texture_id_in_layer_(0) {\n   if (CompositorImpl::UsesDirectGL()) {\n     surface_texture_transport_.reset(new SurfaceTextureTransportClient());\n     layer_ = surface_texture_transport_->Initialize();\n  } else {\n    texture_layer_ = cc::TextureLayer::create(0);\n    layer_ = texture_layer_;\n  }\n\n  layer_->setContentsOpaque(true);\n  layer_->setIsDrawable(true);\n\n  host_->SetView(this);\n  SetContentViewCore(content_view_core);\n}\n", "target": 1, "idx": 185068}
{"func": "void file_checksum(const char *fname, const STRUCT_STAT *st_p, char *sum)\n{\n\tstruct map_struct *buf;\n\tOFF_T i, len = st_p->st_size;\n\tmd_context m;\n\tint32 remainder;\n\tint fd;\n\n\tmemset(sum, 0, MAX_DIGEST_LEN);\n\n\tfd = do_open(fname, O_RDONLY, 0);\n\tif (fd == -1)\n\t\treturn;\n\n\tbuf = map_file(fd, len, MAX_MAP_SIZE, CSUM_CHUNK);\n\n\tswitch (checksum_type) {\n\t  case CSUM_MD5:\n\t\tmd5_begin(&m);\n\n\t\tfor (i = 0; i + CSUM_CHUNK <= len; i += CSUM_CHUNK) {\n\t\t\tmd5_update(&m, (uchar *)map_ptr(buf, i, CSUM_CHUNK),\n\t\t\t\t   CSUM_CHUNK);\n\t\t}\n\n\t\tremainder = (int32)(len - i);\n\t\tif (remainder > 0)\n\t\t\tmd5_update(&m, (uchar *)map_ptr(buf, i, remainder), remainder);\n\n\t\tmd5_result(&m, (uchar *)sum);\n\t\tbreak;\n\t  case CSUM_MD4:\n          case CSUM_MD4:\n          case CSUM_MD4_OLD:\n          case CSUM_MD4_BUSTED:\n                mdfour_begin(&m);\n \n                for (i = 0; i + CSUM_CHUNK <= len; i += CSUM_CHUNK) {\n\t\t}\n\n\t\t/* Prior to version 27 an incorrect MD4 checksum was computed\n\t\t * by failing to call mdfour_tail() for block sizes that\n\t\t * are multiples of 64.  This is fixed by calling mdfour_update()\n\t\t * even when there are no more bytes. */\n                 * are multiples of 64.  This is fixed by calling mdfour_update()\n                 * even when there are no more bytes. */\n                remainder = (int32)(len - i);\n               if (remainder > 0 || checksum_type != CSUM_MD4_BUSTED)\n                        mdfour_update(&m, (uchar *)map_ptr(buf, i, remainder), remainder);\n \n                mdfour_result(&m, (uchar *)sum);\n\t\trprintf(FERROR, \"invalid checksum-choice for the --checksum option (%d)\\n\", checksum_type);\n\t\texit_cleanup(RERR_UNSUPPORTED);\n\t}\n\n\tclose(fd);\n\tunmap_file(buf);\n}\n", "target": 1, "idx": 177815}
{"func": "juniper_pppoe_atm_print(netdissect_options *ndo,\n                        const struct pcap_pkthdr *h, register const u_char *p)\n{\n        struct juniper_l2info_t l2info;\n\tuint16_t extracted_ethertype;\n\n        l2info.pictype = DLT_JUNIPER_PPPOE_ATM;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n \n         p+=l2info.header_len;\n \n         extracted_ethertype = EXTRACT_16BITS(p);\n         /* this DLT contains nothing but raw PPPoE frames,\n          * prepended with a type field*/\n        if (ethertype_print(ndo, extracted_ethertype,\n                              p+ETHERTYPE_LEN,\n                              l2info.length-ETHERTYPE_LEN,\n                              l2info.caplen-ETHERTYPE_LEN,\n                              NULL, NULL) == 0)\n            /* ether_type not known, probably it wasn't one */\n             ND_PRINT((ndo, \"unknown ethertype 0x%04x\", extracted_ethertype));\n \n         return l2info.header_len;\n }\n", "target": 1, "idx": 181092}
{"func": "void EditorClientBlackBerry::willSetInputMethodState()\n{\n    notImplemented();\n}\n", "target": 0, "idx": 111736}
{"func": "static int mwifiex_update_vs_ie(const u8 *ies, int ies_len,\n\t\t\t\tstruct mwifiex_ie **ie_ptr, u16 mask,\n\t\t\t\tunsigned int oui, u8 oui_type)\n{\n\tstruct ieee_types_header *vs_ie;\n\tstruct mwifiex_ie *ie = *ie_ptr;\n\tconst u8 *vendor_ie;\n\n\tvendor_ie = cfg80211_find_vendor_ie(oui, oui_type, ies, ies_len);\n\tif (vendor_ie) {\n\t\tif (!*ie_ptr) {\n\t\t\t*ie_ptr = kzalloc(sizeof(struct mwifiex_ie),\n\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!*ie_ptr)\n\t\t\t\treturn -ENOMEM;\n\t\t\tie = *ie_ptr;\n \t\t}\n \n \t\tvs_ie = (struct ieee_types_header *)vendor_ie;\n \t\tmemcpy(ie->ie_buffer + le16_to_cpu(ie->ie_length),\n \t\t       vs_ie, vs_ie->len + 2);\n \t\tle16_unaligned_add_cpu(&ie->ie_length, vs_ie->len + 2);\n\t\tie->mgmt_subtype_mask = cpu_to_le16(mask);\n\t\tie->ie_index = cpu_to_le16(MWIFIEX_AUTO_IDX_MASK);\n\t}\n\n\t*ie_ptr = ie;\n\treturn 0;\n}\n", "target": 1, "idx": 182747}
{"func": "static void register_shm(struct thread_smc_args *smc_args,\n\t\t\t struct optee_msg_arg *arg, uint32_t num_params)\n{\n\targ->ret = TEE_ERROR_BAD_PARAMETERS;\n\tsmc_args->a0 = OPTEE_SMC_RETURN_OK;\n\n\tif (num_params != 1 ||\n\t    (arg->params[0].attr !=\n\t     (OPTEE_MSG_ATTR_TYPE_TMEM_OUTPUT | OPTEE_MSG_ATTR_NONCONTIG)))\n\t\treturn;\n\n\tstruct optee_msg_param_tmem *tmem = &arg->params[0].u.tmem;\n\tstruct mobj *mobj = msg_param_mobj_from_noncontig(tmem->buf_ptr,\n\t\t\t\t\t\t\t  tmem->size,\n\t\t\t\t\t\t\t  tmem->shm_ref, false);\n\n\tif (!mobj)\n\t\treturn;\n\n\tmobj_reg_shm_unguard(mobj);\n\targ->ret = TEE_SUCCESS;\n}\n", "target": 0, "idx": 87002}
{"func": "string16 ExtensionInstallUI::Prompt::GetHeading(std::string extension_name)\n    const {\n   if (type_ == INLINE_INSTALL_PROMPT) {\n     return UTF8ToUTF16(extension_name);\n   } else {\n    return l10n_util::GetStringFUTF16(\n        kHeadingIds[type_], UTF8ToUTF16(extension_name));\n  }\n}\n", "target": 1, "idx": 183639}
{"func": "GraphicsContext3D::GraphicsContext3D(GraphicsContext3D::Attributes attrs, HostWindow* hostWindow, GraphicsContext3D::RenderStyle renderStyle)\n    : m_currentWidth(0)\n    , m_currentHeight(0)\n    , m_compiler(isGLES2Compliant() ? SH_ESSL_OUTPUT : SH_GLSL_OUTPUT)\n    , m_attrs(attrs)\n    , m_renderStyle(renderStyle)\n    , m_texture(0)\n    , m_compositorTexture(0)\n    , m_fbo(0)\n#if USE(OPENGL_ES_2)\n    , m_depthBuffer(0)\n    , m_stencilBuffer(0)\n#endif\n    , m_depthStencilBuffer(0)\n    , m_layerComposited(false)\n    , m_internalColorFormat(0)\n    , m_boundFBO(0)\n    , m_activeTexture(GL_TEXTURE0)\n    , m_boundTexture0(0)\n    , m_multisampleFBO(0)\n    , m_multisampleDepthStencilBuffer(0)\n    , m_multisampleColorBuffer(0)\n    , m_private(adoptPtr(new GraphicsContext3DPrivate(this, hostWindow, renderStyle)))\n{\n    validateAttributes();\n\n    if (!m_private->m_surface) {\n        LOG_ERROR(\"GraphicsContext3D: QGLWidget initialization failed.\");\n        m_private = nullptr;\n        return;\n    }\n\n    static bool initialized = false;\n    static bool success = true;\n    if (!initialized) {\n        success = initializeOpenGLShims();\n        initialized = true;\n    }\n    if (!success) {\n        m_private = nullptr;\n        return;\n    }\n\n    if (renderStyle == RenderOffscreen)\n        m_private->createOffscreenBuffers();\n\n    m_private->initializeANGLE();\n\n#if !USE(OPENGL_ES_2)\n    glEnable(GL_POINT_SPRITE);\n    glEnable(GL_VERTEX_PROGRAM_POINT_SIZE);\n#endif\n\n    if (renderStyle != RenderToCurrentGLContext)\n        glClearColor(0.0, 0.0, 0.0, 0.0);\n}\n", "target": 0, "idx": 115132}
{"func": "static void tg3_read_vpd(struct tg3 *tp)\n{\n\tu8 *vpd_data;\n\tunsigned int block_end, rosize, len;\n\tu32 vpdlen;\n\tint j, i = 0;\n\n\tvpd_data = (u8 *)tg3_vpd_readblock(tp, &vpdlen);\n\tif (!vpd_data)\n\t\tgoto out_no_vpd;\n\n\ti = pci_vpd_find_tag(vpd_data, 0, vpdlen, PCI_VPD_LRDT_RO_DATA);\n\tif (i < 0)\n\t\tgoto out_not_found;\n\n\trosize = pci_vpd_lrdt_size(&vpd_data[i]);\n\tblock_end = i + PCI_VPD_LRDT_TAG_SIZE + rosize;\n\ti += PCI_VPD_LRDT_TAG_SIZE;\n\n\tif (block_end > vpdlen)\n\t\tgoto out_not_found;\n\n\tj = pci_vpd_find_info_keyword(vpd_data, i, rosize,\n\t\t\t\t      PCI_VPD_RO_KEYWORD_MFR_ID);\n\tif (j > 0) {\n\t\tlen = pci_vpd_info_field_size(&vpd_data[j]);\n\n\t\tj += PCI_VPD_INFO_FLD_HDR_SIZE;\n\t\tif (j + len > block_end || len != 4 ||\n\t\t    memcmp(&vpd_data[j], \"1028\", 4))\n\t\t\tgoto partno;\n\n\t\tj = pci_vpd_find_info_keyword(vpd_data, i, rosize,\n\t\t\t\t\t      PCI_VPD_RO_KEYWORD_VENDOR0);\n\t\tif (j < 0)\n\t\t\tgoto partno;\n\n\t\tlen = pci_vpd_info_field_size(&vpd_data[j]);\n\n\t\tj += PCI_VPD_INFO_FLD_HDR_SIZE;\n \t\tif (j + len > block_end)\n \t\t\tgoto partno;\n \n\t\tmemcpy(tp->fw_ver, &vpd_data[j], len);\n\t\tstrncat(tp->fw_ver, \" bc \", vpdlen - len - 1);\n \t}\n \n partno:\n\ti = pci_vpd_find_info_keyword(vpd_data, i, rosize,\n\t\t\t\t      PCI_VPD_RO_KEYWORD_PARTNO);\n\tif (i < 0)\n\t\tgoto out_not_found;\n\n\tlen = pci_vpd_info_field_size(&vpd_data[i]);\n\n\ti += PCI_VPD_INFO_FLD_HDR_SIZE;\n\tif (len > TG3_BPN_SIZE ||\n\t    (len + i) > vpdlen)\n\t\tgoto out_not_found;\n\n\tmemcpy(tp->board_part_number, &vpd_data[i], len);\n\nout_not_found:\n\tkfree(vpd_data);\n\tif (tp->board_part_number[0])\n\t\treturn;\n\nout_no_vpd:\n\tif (tg3_asic_rev(tp) == ASIC_REV_5717) {\n\t\tif (tp->pdev->device == TG3PCI_DEVICE_TIGON3_5717 ||\n\t\t    tp->pdev->device == TG3PCI_DEVICE_TIGON3_5717_C)\n\t\t\tstrcpy(tp->board_part_number, \"BCM5717\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_5718)\n\t\t\tstrcpy(tp->board_part_number, \"BCM5718\");\n\t\telse\n\t\t\tgoto nomatch;\n\t} else if (tg3_asic_rev(tp) == ASIC_REV_57780) {\n\t\tif (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57780)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57780\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57760)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57760\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57790)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57790\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57788)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57788\");\n\t\telse\n\t\t\tgoto nomatch;\n\t} else if (tg3_asic_rev(tp) == ASIC_REV_57765) {\n\t\tif (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57761)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57761\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57765)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57765\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57781)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57781\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57785)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57785\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57791)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57791\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57795)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57795\");\n\t\telse\n\t\t\tgoto nomatch;\n\t} else if (tg3_asic_rev(tp) == ASIC_REV_57766) {\n\t\tif (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57762)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57762\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57766)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57766\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57782)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57782\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57786)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57786\");\n\t\telse\n\t\t\tgoto nomatch;\n\t} else if (tg3_asic_rev(tp) == ASIC_REV_5906) {\n\t\tstrcpy(tp->board_part_number, \"BCM95906\");\n\t} else {\nnomatch:\n\t\tstrcpy(tp->board_part_number, \"none\");\n\t}\n}\n", "target": 1, "idx": 179273}
{"func": "static noinline void key_gc_unused_keys(struct list_head *keys)\n{\n\twhile (!list_empty(keys)) {\n\t\tstruct key *key =\n\t\t\tlist_entry(keys->next, struct key, graveyard_link);\n\t\tlist_del(&key->graveyard_link);\n\n\t\tkdebug(\"- %u\", key->serial);\n\t\tkey_check(key);\n\n\t\tsecurity_key_free(key);\n\n\t\t/* deal with the user's key tracking and quota */\n\t\tif (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\t\tspin_lock(&key->user->lock);\n\t\t\tkey->user->qnkeys--;\n\t\t\tkey->user->qnbytes -= key->quotalen;\n\t\t\tspin_unlock(&key->user->lock);\n\t\t}\n\n\t\tatomic_dec(&key->user->nkeys);\n \t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags))\n \t\t\tatomic_dec(&key->user->nikeys);\n \n\t\tkey_user_put(key->user);\n \t\t/* now throw away the key memory */\n \t\tif (key->type->destroy)\n \t\t\tkey->type->destroy(key);\n \n \t\tkfree(key->description);\n \n #ifdef KEY_DEBUGGING\n\t\tkey->magic = KEY_DEBUG_MAGIC_X;\n#endif\n\t\tkmem_cache_free(key_jar, key);\n\t}\n}\n", "target": 1, "idx": 179955}
{"func": "static void usb_net_reset_in_buf(USBNetState *s)\n{\n    s->in_ptr = s->in_len = 0;\n    qemu_flush_queued_packets(qemu_get_queue(s->nic));\n}\n", "target": 0, "idx": 12615}
{"func": "static int shm_fsync(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tstruct shm_file_data *sfd = shm_file_data(file);\n\n\tif (!sfd->file->f_op->fsync)\n\t\treturn -EINVAL;\n\treturn sfd->file->f_op->fsync(sfd->file, start, end, datasync);\n}\n", "target": 0, "idx": 27966}
{"func": " static void build_l4proto_sctp(const struct nf_conntrack *ct, struct nethdr *n)\n {\n\tct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,\n\t\t      sizeof(struct nfct_attr_grp_port));\n \tif (!nfct_attr_is_set(ct, ATTR_SCTP_STATE))\n \t\treturn;\n \n \tct_build_u8(ct, ATTR_SCTP_STATE, n, NTA_SCTP_STATE);\n \tct_build_u32(ct, ATTR_SCTP_VTAG_ORIG, n, NTA_SCTP_VTAG_ORIG);\n \tct_build_u32(ct, ATTR_SCTP_VTAG_REPL, n, NTA_SCTP_VTAG_REPL);\n}\n", "target": 1, "idx": 177803}
{"func": "void DecoderTest::RunLoop(CompressedVideoSource *video) {\n  vpx_codec_dec_cfg_t dec_cfg = {0};\n  Decoder* const decoder = codec_->CreateDecoder(dec_cfg, 0);\n   ASSERT_TRUE(decoder != NULL);\n \n  for (video->Begin(); video->cxdata(); video->Next()) {\n     PreDecodeFrameHook(*video, decoder);\n    vpx_codec_err_t res_dec = decoder->DecodeFrame(video->cxdata(),\n                                                   video->frame_size());\n    ASSERT_EQ(VPX_CODEC_OK, res_dec) << decoder->DecodeError();\n \n     DxDataIterator dec_iter = decoder->GetDxData();\n     const vpx_image_t *img = NULL;\n\n\n     while ((img = dec_iter.Next()))\n       DecompressedFrameHook(*img, video->frame_number());\n   }\n   delete decoder;\n }\n", "target": 1, "idx": 188557}
{"func": "mark_source_chains(const struct xt_table_info *newinfo,\n\t\t   unsigned int valid_hooks, void *entry0)\n{\n\tunsigned int hook;\n\n\t/* No recursion; use packet counter to save back ptrs (reset\n\t   to 0 as we leave), and comefrom to save source hook bitmask */\n\tfor (hook = 0; hook < NF_INET_NUMHOOKS; hook++) {\n\t\tunsigned int pos = newinfo->hook_entry[hook];\n\t\tstruct ipt_entry *e = (struct ipt_entry *)(entry0 + pos);\n\n\t\tif (!(valid_hooks & (1 << hook)))\n\t\t\tcontinue;\n\n\t\t/* Set initial back pointer. */\n\t\te->counters.pcnt = pos;\n\n\t\tfor (;;) {\n\t\t\tconst struct xt_standard_target *t\n\t\t\t\t= (void *)ipt_get_target_c(e);\n\t\t\tint visited = e->comefrom & (1 << hook);\n\n\t\t\tif (e->comefrom & (1 << NF_INET_NUMHOOKS)) {\n\t\t\t\tpr_err(\"iptables: loop hook %u pos %u %08X.\\n\",\n\t\t\t\t       hook, pos, e->comefrom);\n\t\t\t\treturn 0;\n\t\t\t}\n \t\t\te->comefrom |= ((1 << hook) | (1 << NF_INET_NUMHOOKS));\n \n \t\t\t/* Unconditional return/END. */\n\t\t\tif ((e->target_offset == sizeof(struct ipt_entry) &&\n \t\t\t     (strcmp(t->target.u.user.name,\n \t\t\t\t     XT_STANDARD_TARGET) == 0) &&\n\t\t\t     t->verdict < 0 && unconditional(&e->ip)) ||\n\t\t\t    visited) {\n \t\t\t\tunsigned int oldpos, size;\n \n \t\t\t\tif ((strcmp(t->target.u.user.name,\n\t\t\t\t\t    XT_STANDARD_TARGET) == 0) &&\n\t\t\t\t    t->verdict < -NF_MAX_VERDICT - 1) {\n\t\t\t\t\tduprintf(\"mark_source_chains: bad \"\n\t\t\t\t\t\t\"negative verdict (%i)\\n\",\n\t\t\t\t\t\t\t\tt->verdict);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\t/* Return: backtrack through the last\n\t\t\t\t   big jump. */\n\t\t\t\tdo {\n\t\t\t\t\te->comefrom ^= (1<<NF_INET_NUMHOOKS);\n#ifdef DEBUG_IP_FIREWALL_USER\n\t\t\t\t\tif (e->comefrom\n\t\t\t\t\t    & (1 << NF_INET_NUMHOOKS)) {\n\t\t\t\t\t\tduprintf(\"Back unset \"\n\t\t\t\t\t\t\t \"on hook %u \"\n\t\t\t\t\t\t\t \"rule %u\\n\",\n\t\t\t\t\t\t\t hook, pos);\n\t\t\t\t\t}\n#endif\n\t\t\t\t\toldpos = pos;\n\t\t\t\t\tpos = e->counters.pcnt;\n\t\t\t\t\te->counters.pcnt = 0;\n\n\t\t\t\t\t/* We're at the start. */\n\t\t\t\t\tif (pos == oldpos)\n\t\t\t\t\t\tgoto next;\n\n\t\t\t\t\te = (struct ipt_entry *)\n\t\t\t\t\t\t(entry0 + pos);\n\t\t\t\t} while (oldpos == pos + e->next_offset);\n\n\t\t\t\t/* Move along one */\n\t\t\t\tsize = e->next_offset;\n\t\t\t\te = (struct ipt_entry *)\n\t\t\t\t\t(entry0 + pos + size);\n\t\t\t\te->counters.pcnt = pos;\n\t\t\t\tpos += size;\n\t\t\t} else {\n\t\t\t\tint newpos = t->verdict;\n\n\t\t\t\tif (strcmp(t->target.u.user.name,\n\t\t\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t\t\t    newpos >= 0) {\n\t\t\t\t\tif (newpos > newinfo->size -\n\t\t\t\t\t\tsizeof(struct ipt_entry)) {\n\t\t\t\t\t\tduprintf(\"mark_source_chains: \"\n\t\t\t\t\t\t\t\"bad verdict (%i)\\n\",\n\t\t\t\t\t\t\t\tnewpos);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\t/* This a jump; chase it. */\n\t\t\t\t\tduprintf(\"Jump rule %u -> %u\\n\",\n\t\t\t\t\t\t pos, newpos);\n\t\t\t\t} else {\n\t\t\t\t\t/* ... this is a fallthru */\n\t\t\t\t\tnewpos = pos + e->next_offset;\n\t\t\t\t}\n\t\t\t\te = (struct ipt_entry *)\n\t\t\t\t\t(entry0 + newpos);\n\t\t\t\te->counters.pcnt = pos;\n\t\t\t\tpos = newpos;\n\t\t\t}\n\t\t}\nnext:\n\t\tduprintf(\"Finished chain %u\\n\", hook);\n\t}\n\treturn 1;\n}\n", "target": 1, "idx": 180542}
{"func": "static Image *ReadWPGImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  typedef struct\n  {\n    size_t FileId;\n    MagickOffsetType DataOffset;\n    unsigned int ProductType;\n    unsigned int FileType;\n    unsigned char MajorVersion;\n    unsigned char MinorVersion;\n    unsigned int EncryptKey;\n    unsigned int Reserved;\n  } WPGHeader;\n\n  typedef struct\n  {\n    unsigned char RecType;\n    size_t RecordLength;\n  } WPGRecord;\n\n  typedef struct\n  {\n    unsigned char Class;\n    unsigned char RecType;\n    size_t Extension;\n    size_t RecordLength;\n  } WPG2Record;\n\n  typedef struct\n  {\n    unsigned  HorizontalUnits;\n    unsigned  VerticalUnits;\n    unsigned char PosSizePrecision;\n  } WPG2Start;\n\n  typedef struct\n  {\n    unsigned int Width;\n    unsigned int Height;\n    unsigned int Depth;\n    unsigned int HorzRes;\n    unsigned int VertRes;\n  } WPGBitmapType1;\n\n  typedef struct\n  {\n    unsigned int Width;\n    unsigned int Height;\n    unsigned char Depth;\n    unsigned char Compression;\n  } WPG2BitmapType1;\n\n  typedef struct\n  {\n    unsigned int RotAngle;\n    unsigned int LowLeftX;\n    unsigned int LowLeftY;\n    unsigned int UpRightX;\n    unsigned int UpRightY;\n    unsigned int Width;\n    unsigned int Height;\n    unsigned int Depth;\n    unsigned int HorzRes;\n    unsigned int VertRes;\n  } WPGBitmapType2;\n\n  typedef struct\n  {\n    unsigned int StartIndex;\n    unsigned int NumOfEntries;\n  } WPGColorMapRec;\n\n  /*\n  typedef struct {\n    size_t PS_unknown1;\n    unsigned int PS_unknown2;\n    unsigned int PS_unknown3;\n  } WPGPSl1Record;  \n  */\n\n  Image\n    *image;\n\n  unsigned int\n    status;\n\n  WPGHeader\n    Header;\n\n  WPGRecord\n    Rec;\n\n  WPG2Record\n    Rec2;\n\n  WPG2Start StartWPG;\n\n  WPGBitmapType1\n    BitmapHeader1;\n\n  WPG2BitmapType1\n    Bitmap2Header1;\n\n  WPGBitmapType2\n    BitmapHeader2;\n\n  WPGColorMapRec\n    WPG_Palette;\n\n  int\n    i,\n    bpp,\n    WPG2Flags;\n\n  ssize_t\n    ldblk;\n\n  size_t\n    one;\n\n  unsigned char\n    *BImgBuff;\n\n  tCTM CTM;         /*current transform matrix*/\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  one=1;\n  image=AcquireImage(image_info,exception);\n  image->depth=8;\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read WPG image.\n  */\n  Header.FileId=ReadBlobLSBLong(image);\n  Header.DataOffset=(MagickOffsetType) ReadBlobLSBLong(image);\n  Header.ProductType=ReadBlobLSBShort(image);\n  Header.FileType=ReadBlobLSBShort(image);\n  Header.MajorVersion=ReadBlobByte(image);\n  Header.MinorVersion=ReadBlobByte(image);\n  Header.EncryptKey=ReadBlobLSBShort(image);\n  Header.Reserved=ReadBlobLSBShort(image);\n\n  if (Header.FileId!=0x435057FF || (Header.ProductType>>8)!=0x16)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (Header.EncryptKey!=0)\n    ThrowReaderException(CoderError,\"EncryptedWPGImageFileNotSupported\");\n\n  image->columns = 1;\n  image->rows = 1;\n  image->colors = 0;\n  bpp=0;\n  BitmapHeader2.RotAngle=0;\n\n  switch(Header.FileType)\n    {\n    case 1:     /* WPG level 1 */\n      while(!EOFBlob(image)) /* object parser loop */\n        {\n          (void) SeekBlob(image,Header.DataOffset,SEEK_SET);\n          if(EOFBlob(image))\n            break;\n\n          Rec.RecType=(i=ReadBlobByte(image));\n          if(i==EOF)\n            break;\n          Rd_WP_DWORD(image,&Rec.RecordLength);\n          if(EOFBlob(image))\n            break;\n\n          Header.DataOffset=TellBlob(image)+Rec.RecordLength;\n\n          switch(Rec.RecType)\n            {\n            case 0x0B: /* bitmap type 1 */\n              BitmapHeader1.Width=ReadBlobLSBShort(image);\n              BitmapHeader1.Height=ReadBlobLSBShort(image);\n              if ((BitmapHeader1.Width == 0) || (BitmapHeader1.Height == 0))\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              BitmapHeader1.Depth=ReadBlobLSBShort(image);\n              BitmapHeader1.HorzRes=ReadBlobLSBShort(image);\n              BitmapHeader1.VertRes=ReadBlobLSBShort(image);\n\n              if(BitmapHeader1.HorzRes && BitmapHeader1.VertRes)\n                {\n                  image->units=PixelsPerCentimeterResolution;\n                  image->resolution.x=BitmapHeader1.HorzRes/470.0;\n                  image->resolution.y=BitmapHeader1.VertRes/470.0;\n                }\n              image->columns=BitmapHeader1.Width;\n              image->rows=BitmapHeader1.Height;\n              bpp=BitmapHeader1.Depth;\n\n              goto UnpackRaster;\n\n            case 0x0E:  /*Color palette */\n              WPG_Palette.StartIndex=ReadBlobLSBShort(image);\n              WPG_Palette.NumOfEntries=ReadBlobLSBShort(image);\n\n              image->colors=WPG_Palette.NumOfEntries;\n              if (!AcquireImageColormap(image,image->colors,exception))\n                goto NoMemory;\n              for (i=WPG_Palette.StartIndex;\n                   i < (int)WPG_Palette.NumOfEntries; i++)\n                {\n                  image->colormap[i].red=ScaleCharToQuantum((unsigned char)\n                    ReadBlobByte(image));\n                  image->colormap[i].green=ScaleCharToQuantum((unsigned char)\n                    ReadBlobByte(image));\n                  image->colormap[i].blue=ScaleCharToQuantum((unsigned char)\n                    ReadBlobByte(image));\n                }\n              break;\n     \n            case 0x11:  /* Start PS l1 */\n              if(Rec.RecordLength > 8)\n                image=ExtractPostscript(image,image_info,\n                  TellBlob(image)+8,   /* skip PS header in the wpg */\n                  (ssize_t) Rec.RecordLength-8,exception);\n              break;     \n\n            case 0x14:  /* bitmap type 2 */\n              BitmapHeader2.RotAngle=ReadBlobLSBShort(image);\n              BitmapHeader2.LowLeftX=ReadBlobLSBShort(image);\n              BitmapHeader2.LowLeftY=ReadBlobLSBShort(image);\n              BitmapHeader2.UpRightX=ReadBlobLSBShort(image);\n              BitmapHeader2.UpRightY=ReadBlobLSBShort(image);\n              BitmapHeader2.Width=ReadBlobLSBShort(image);\n              BitmapHeader2.Height=ReadBlobLSBShort(image);\n              if ((BitmapHeader2.Width == 0) || (BitmapHeader2.Height == 0))\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              BitmapHeader2.Depth=ReadBlobLSBShort(image);\n              BitmapHeader2.HorzRes=ReadBlobLSBShort(image);\n              BitmapHeader2.VertRes=ReadBlobLSBShort(image);\n\n              image->units=PixelsPerCentimeterResolution;\n              image->page.width=(unsigned int)\n                ((BitmapHeader2.LowLeftX-BitmapHeader2.UpRightX)/470.0);\n              image->page.height=(unsigned int)\n                ((BitmapHeader2.LowLeftX-BitmapHeader2.UpRightY)/470.0);\n              image->page.x=(int) (BitmapHeader2.LowLeftX/470.0);\n              image->page.y=(int) (BitmapHeader2.LowLeftX/470.0);\n              if(BitmapHeader2.HorzRes && BitmapHeader2.VertRes)\n                {\n                  image->resolution.x=BitmapHeader2.HorzRes/470.0;\n                  image->resolution.y=BitmapHeader2.VertRes/470.0;\n                }\n              image->columns=BitmapHeader2.Width;\n              image->rows=BitmapHeader2.Height;\n              bpp=BitmapHeader2.Depth;\n\n            UnpackRaster:      \n              status=SetImageExtent(image,image->columns,image->rows,exception);\n              if (status == MagickFalse)\n                break;\n              if ((image->colors == 0) && (bpp != 24))\n                {\n                  image->colors=one << bpp;\n                  if (!AcquireImageColormap(image,image->colors,exception))\n                    {\n                    NoMemory:\n                      ThrowReaderException(ResourceLimitError,\n                        \"MemoryAllocationFailed\");\n                    }\n                  /* printf(\"Load default colormap \\n\"); */\n                  for (i=0; (i < (int) image->colors) && (i < 256); i++)\n                    {               \n                      image->colormap[i].red=ScaleCharToQuantum(WPG1_Palette[i].Red);\n                      image->colormap[i].green=ScaleCharToQuantum(WPG1_Palette[i].Green);\n                      image->colormap[i].blue=ScaleCharToQuantum(WPG1_Palette[i].Blue);\n                    }\n                }\n              else\n                {\n                  if (bpp < 24)\n                    if ( (image->colors < (one << bpp)) && (bpp != 24) )\n                      image->colormap=(PixelInfo *) ResizeQuantumMemory(\n                        image->colormap,(size_t) (one << bpp),\n                        sizeof(*image->colormap));\n                }\n          \n              if (bpp == 1)\n                {\n                  if(image->colormap[0].red==0 &&\n                     image->colormap[0].green==0 &&\n                     image->colormap[0].blue==0 &&\n                     image->colormap[1].red==0 &&\n                     image->colormap[1].green==0 &&\n                     image->colormap[1].blue==0)\n                    {  /* fix crippled monochrome palette */\n                      image->colormap[1].red =\n                        image->colormap[1].green =\n                        image->colormap[1].blue = QuantumRange;\n                    }\n                }      \n\n              if(UnpackWPGRaster(image,bpp,exception) < 0)\n                /* The raster cannot be unpacked */\n                {\n                DecompressionFailed:\n                  ThrowReaderException(CoderError,\"UnableToDecompressImage\");\n                    }\n\n              if(Rec.RecType==0x14 && BitmapHeader2.RotAngle!=0 && !image_info->ping)\n                {  \n                  /* flop command */\n                  if(BitmapHeader2.RotAngle & 0x8000)\n                    {\n                      Image\n                        *flop_image;\n\n                      flop_image = FlopImage(image, exception);\n                      if (flop_image != (Image *) NULL) {\n                        DuplicateBlob(flop_image,image);\n                        (void) RemoveLastImageFromList(&image);\n                        AppendImageToList(&image,flop_image);\n                      }\n                    }\n                  /* flip command */\n                  if(BitmapHeader2.RotAngle & 0x2000)\n                    {\n                      Image\n                        *flip_image;\n\n                      flip_image = FlipImage(image, exception);\n                      if (flip_image != (Image *) NULL) {\n                        DuplicateBlob(flip_image,image);\n                        (void) RemoveLastImageFromList(&image);\n                        AppendImageToList(&image,flip_image);\n                      }\n                    }\n                  /* rotate command */\n                  if(BitmapHeader2.RotAngle & 0x0FFF)\n                    {\n                      Image\n                        *rotate_image;\n\n                      rotate_image=RotateImage(image,(BitmapHeader2.RotAngle &\n                        0x0FFF), exception);\n                      if (rotate_image != (Image *) NULL) {\n                        DuplicateBlob(rotate_image,image);\n                        (void) RemoveLastImageFromList(&image);\n                        AppendImageToList(&image,rotate_image);\n                      }\n                    }\n                }\n\n              /* Allocate next image structure. */\n              AcquireNextImage(image_info,image,exception);\n              image->depth=8;\n              if (image->next == (Image *) NULL)\n                goto Finish;\n              image=SyncNextImageInList(image);\n              image->columns=image->rows=1;\n              image->colors=0;\n              break;\n\n            case 0x1B:  /* Postscript l2 */\n              if(Rec.RecordLength>0x3C)\n                image=ExtractPostscript(image,image_info,\n                  TellBlob(image)+0x3C,   /* skip PS l2 header in the wpg */\n                  (ssize_t) Rec.RecordLength-0x3C,exception);\n              break;\n            }\n        }\n      break;\n\n    case 2:  /* WPG level 2 */\n      (void) memset(CTM,0,sizeof(CTM));\n      StartWPG.PosSizePrecision = 0;\n      while(!EOFBlob(image)) /* object parser loop */\n        {\n          (void) SeekBlob(image,Header.DataOffset,SEEK_SET);\n          if(EOFBlob(image))\n            break;\n\n          Rec2.Class=(i=ReadBlobByte(image));\n          if(i==EOF)\n            break;\n          Rec2.RecType=(i=ReadBlobByte(image));\n          if(i==EOF)\n            break;\n          Rd_WP_DWORD(image,&Rec2.Extension);\n          Rd_WP_DWORD(image,&Rec2.RecordLength);\n          if(EOFBlob(image))\n            break;\n\n          Header.DataOffset=TellBlob(image)+Rec2.RecordLength;\n\n          switch(Rec2.RecType)\n            {\n      case 1:\n              StartWPG.HorizontalUnits=ReadBlobLSBShort(image);\n              StartWPG.VerticalUnits=ReadBlobLSBShort(image);\n              StartWPG.PosSizePrecision=ReadBlobByte(image);\n              break;\n            case 0x0C:    /* Color palette */\n              WPG_Palette.StartIndex=ReadBlobLSBShort(image);\n              WPG_Palette.NumOfEntries=ReadBlobLSBShort(image);\n\n              image->colors=WPG_Palette.NumOfEntries;\n              if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              for (i=WPG_Palette.StartIndex;\n                   i < (int)WPG_Palette.NumOfEntries; i++)\n                {\n                  image->colormap[i].red=ScaleCharToQuantum((char)\n                    ReadBlobByte(image));\n                  image->colormap[i].green=ScaleCharToQuantum((char)\n                    ReadBlobByte(image));\n                  image->colormap[i].blue=ScaleCharToQuantum((char)\n                    ReadBlobByte(image));\n                  (void) ReadBlobByte(image);   /*Opacity??*/\n                }\n              break;\n            case 0x0E:\n              Bitmap2Header1.Width=ReadBlobLSBShort(image);\n              Bitmap2Header1.Height=ReadBlobLSBShort(image);\n              if ((Bitmap2Header1.Width == 0) || (Bitmap2Header1.Height == 0))\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              Bitmap2Header1.Depth=ReadBlobByte(image);\n              Bitmap2Header1.Compression=ReadBlobByte(image);\n\n              if(Bitmap2Header1.Compression > 1)\n                continue; /*Unknown compression method */\n              switch(Bitmap2Header1.Depth)\n                {\n                case 1:\n                  bpp=1;\n                  break;\n                case 2:\n                  bpp=2;\n                  break;\n                case 3:\n                  bpp=4;\n                  break;\n                case 4:\n                  bpp=8;\n                  break;\n                case 8:\n                  bpp=24;\n                  break;\n                default:\n                  continue;  /*Ignore raster with unknown depth*/\n                }\n              image->columns=Bitmap2Header1.Width;\n              image->rows=Bitmap2Header1.Height;\n               status=SetImageExtent(image,image->columns,image->rows,exception);\n               if (status == MagickFalse)\n                 break;\n               if ((image->colors == 0) && (bpp != 24))\n                 {\n                   size_t\n                    one;\n\n                  one=1;\n                  image->colors=one << bpp;\n                  if (!AcquireImageColormap(image,image->colors,exception))\n                    goto NoMemory;\n                }\n              else\n                {\n                  if(bpp < 24)\n                    if( image->colors<(one << bpp) && bpp!=24 )\n                      image->colormap=(PixelInfo *) ResizeQuantumMemory(\n                       image->colormap,(size_t) (one << bpp),\n                       sizeof(*image->colormap));\n                }\n\n\n              switch(Bitmap2Header1.Compression)\n                {\n                case 0:    /*Uncompressed raster*/\n                  {\n                    ldblk=(ssize_t) ((bpp*image->columns+7)/8);\n                    BImgBuff=(unsigned char *) AcquireQuantumMemory((size_t)\n                      ldblk+1,sizeof(*BImgBuff));\n                    if (BImgBuff == (unsigned char *) NULL)\n                      goto NoMemory;\n\n                    for(i=0; i< (ssize_t) image->rows; i++)\n                      {\n                        (void) ReadBlob(image,ldblk,BImgBuff);\n                        InsertRow(image,BImgBuff,i,bpp,exception);\n                      }\n\n                    if(BImgBuff)\n                      BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);\n                    break;\n                  }\n                case 1:    /*RLE for WPG2 */\n                  {\n                    if( UnpackWPG2Raster(image,bpp,exception) < 0)\n                      goto DecompressionFailed;\n                    break;\n                  }   \n                }\n\n              if(CTM[0][0]<0 && !image_info->ping)\n                {    /*?? RotAngle=360-RotAngle;*/\n                  Image\n                    *flop_image;\n\n                  flop_image = FlopImage(image, exception);\n                  if (flop_image != (Image *) NULL) {\n                    DuplicateBlob(flop_image,image);\n                    (void) RemoveLastImageFromList(&image);\n                    AppendImageToList(&image,flop_image);\n                  }\n                  /* Try to change CTM according to Flip - I am not sure, must be checked.\n                     Tx(0,0)=-1;      Tx(1,0)=0;   Tx(2,0)=0;\n                     Tx(0,1)= 0;      Tx(1,1)=1;   Tx(2,1)=0;\n                     Tx(0,2)=(WPG._2Rect.X_ur+WPG._2Rect.X_ll);\n                     Tx(1,2)=0;   Tx(2,2)=1; */\n                }\n              if(CTM[1][1]<0 && !image_info->ping)\n                {    /*?? RotAngle=360-RotAngle;*/\n                  Image\n                    *flip_image;\n\n                   flip_image = FlipImage(image, exception);\n                   if (flip_image != (Image *) NULL) {\n                     DuplicateBlob(flip_image,image);\n                     (void) RemoveLastImageFromList(&image);\n                     AppendImageToList(&image,flip_image);\n                    }\n                  /* Try to change CTM according to Flip - I am not sure, must be checked.\n                     float_matrix Tx(3,3);\n                     Tx(0,0)= 1;   Tx(1,0)= 0;   Tx(2,0)=0;\n                     Tx(0,1)= 0;   Tx(1,1)=-1;   Tx(2,1)=0;\n                     Tx(0,2)= 0;   Tx(1,2)=(WPG._2Rect.Y_ur+WPG._2Rect.Y_ll);\n                     Tx(2,2)=1; */\n              }\n\n\n              /* Allocate next image structure. */\n              AcquireNextImage(image_info,image,exception);\n              image->depth=8;\n              if (image->next == (Image *) NULL)\n                goto Finish;\n              image=SyncNextImageInList(image);\n              image->columns=image->rows=1;\n              image->colors=0;\n              break;\n\n            case 0x12:  /* Postscript WPG2*/\n        i=ReadBlobLSBShort(image);\n              if(Rec2.RecordLength > (unsigned int) i)\n                image=ExtractPostscript(image,image_info,\n                  TellBlob(image)+i,    /*skip PS header in the wpg2*/\n                  (ssize_t) (Rec2.RecordLength-i-2),exception);\n              break;\n\n      case 0x1B:          /*bitmap rectangle*/\n              WPG2Flags = LoadWPG2Flags(image,StartWPG.PosSizePrecision,NULL,&CTM);\n              (void) WPG2Flags;\n              break;\n            }\n        }\n\n      break;\n\n    default:\n      {\n         ThrowReaderException(CoderError,\"DataEncodingSchemeIsNotSupported\");\n      }\n   }\n\n Finish:\n  (void) CloseBlob(image);\n\n  {\n    Image\n      *p;\n\n    ssize_t\n      scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n    /*\n      Fix scene numbers.\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=(size_t) scene++;\n  }\n  if (image == (Image *) NULL)\n    ThrowReaderException(CorruptImageError,\n      \"ImageFileDoesNotContainAnyImageData\");\n  return(image);\n}\n", "target": 1, "idx": 183133}
{"func": "PrintPreviewHandler::PrintPreviewHandler()\n    : print_backend_(printing::PrintBackend::CreateInstance(NULL)),\n      regenerate_preview_request_count_(0),\n      manage_printers_dialog_request_count_(0),\n      manage_cloud_printers_dialog_request_count_(0),\n      reported_failed_preview_(false),\n      has_logged_printers_count_(false) {\n  ReportUserActionHistogram(PREVIEW_STARTED);\n}\n", "target": 0, "idx": 112766}
{"func": "static int rose_getsockopt(struct socket *sock, int level, int optname,\n\tchar __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rose_sock *rose = rose_sk(sk);\n\tint val = 0;\n\tint len;\n\n\tif (level != SOL_ROSE)\n\t\treturn -ENOPROTOOPT;\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tif (len < 0)\n\t\treturn -EINVAL;\n\n\tswitch (optname) {\n\tcase ROSE_DEFER:\n\t\tval = rose->defer;\n\t\tbreak;\n\n\tcase ROSE_T1:\n\t\tval = rose->t1 / HZ;\n\t\tbreak;\n\n\tcase ROSE_T2:\n\t\tval = rose->t2 / HZ;\n\t\tbreak;\n\n\tcase ROSE_T3:\n\t\tval = rose->t3 / HZ;\n\t\tbreak;\n\n\tcase ROSE_HOLDBACK:\n\t\tval = rose->hb / HZ;\n\t\tbreak;\n\n\tcase ROSE_IDLE:\n\t\tval = rose->idle / (60 * HZ);\n\t\tbreak;\n\n\tcase ROSE_QBITINCL:\n\t\tval = rose->qbitincl;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\n\tlen = min_t(unsigned int, len, sizeof(int));\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\n\treturn copy_to_user(optval, &val, len) ? -EFAULT : 0;\n}\n", "target": 0, "idx": 22202}
{"func": "long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\n\t/* find the key first */\n\tkey_ref = lookup_user_key(keyid, 0, 0);\n\tif (IS_ERR(key_ref)) {\n\t\tret = -ENOKEY;\n\t\tgoto error;\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\n\t/* see if we can read it directly */\n\tret = key_permission(key_ref, KEY_NEED_READ);\n\tif (ret == 0)\n\t\tgoto can_read_key;\n\tif (ret != -EACCES)\n\t\tgoto error;\n\n\t/* we can't; see if it's searchable from this process's keyrings\n\t * - we automatically take account of the fact that it may be\n\t *   dangling off an instantiation key\n\t */\n\tif (!is_key_possessed(key_ref)) {\n\t\tret = -EACCES;\n\t\tgoto error2;\n\t}\n \n \t/* the key is probably readable - now try to read it */\n can_read_key:\n\tret = key_validate(key);\n\tif (ret == 0) {\n\t\tret = -EOPNOTSUPP;\n\t\tif (key->type->read) {\n\t\t\t/* read the data with the semaphore held (since we\n\t\t\t * might sleep) */\n\t\t\tdown_read(&key->sem);\n \t\t\tret = key->type->read(key, buffer, buflen);\n\t\t\tup_read(&key->sem);\n\t\t}\n \t}\n \n error2:\n\tkey_put(key);\nerror:\n\treturn ret;\n}\n", "target": 1, "idx": 180730}
{"func": "ssh_packet_get_compress_state(struct sshbuf *m, struct ssh *ssh)\n{\n\tstruct session_state *state = ssh->state;\n\tstruct sshbuf *b;\n\tint r;\n\tif ((b = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif (state->compression_in_started) {\n\t\tif ((r = sshbuf_put_string(b, &state->compression_in_stream,\n\t\t    sizeof(state->compression_in_stream))) != 0)\n\t\t\tgoto out;\n\t} else if ((r = sshbuf_put_string(b, NULL, 0)) != 0)\n\t\tgoto out;\n\tif (state->compression_out_started) {\n\t\tif ((r = sshbuf_put_string(b, &state->compression_out_stream,\n\t\t    sizeof(state->compression_out_stream))) != 0)\n\t\t\tgoto out;\n\t} else if ((r = sshbuf_put_string(b, NULL, 0)) != 0)\n\t\tgoto out;\n\tr = sshbuf_put_stringb(m, b);\n out:\n\tsshbuf_free(b);\n\treturn r;\n}\n", "target": 1, "idx": 181824}
{"func": "void RenderViewHostImpl::OnTargetDropACK() {\n  NotificationService::current()->Notify(\n      NOTIFICATION_RENDER_VIEW_HOST_DID_RECEIVE_DRAG_TARGET_DROP_ACK,\n      Source<RenderViewHost>(this),\n      NotificationService::NoDetails());\n}\n", "target": 0, "idx": 125692}
{"func": "seamless_process(STREAM s)\n {\n \tunsigned int pkglen;\n \tchar *buf;\n \n \tpkglen = s->end - s->p;\n \t/* str_handle_lines requires null terminated strings */\n\tbuf = xmalloc(pkglen + 1);\n\tSTRNCPY(buf, (char *) s->p, pkglen + 1);\n\tstr_handle_lines(buf, &seamless_rest, seamless_line_handler, NULL);\n\n\txfree(buf);\n}\n", "target": 1, "idx": 182980}
{"func": "static int ps_files_valid_key(const char *key)\n{\n       size_t len;\n       const char *p;\n       char c;\n       int ret = 1;\n       for (p = key; (c = *p); p++) {\n               /* valid characters are a..z,A..Z,0..9 */\n               if (!((c >= 'a' && c <= 'z')\n                               || (c >= 'A' && c <= 'Z')\n                               || (c >= '0' && c <= '9')\n                               || c == ','\n                               || c == '-')) {\n                       ret = 0;\n                       break;\n               }\n       }\n       len = p - key;\n       /* Somewhat arbitrary length limit here, but should be way more than\n          anyone needs and avoids file-level warnings later on if we exceed MAX_PATH */\n       if (len == 0 || len > 128) {\n               ret = 0;\n       }\n       return ret;\n}\n", "target": 1, "idx": 178043}
{"func": "int svc_rdma_map_xdr(struct svcxprt_rdma *xprt,\n\t\t     struct xdr_buf *xdr,\n\t\t     struct svc_rdma_req_map *vec,\n\t\t     bool write_chunk_present)\n {\n\tint sge_no;\n\tu32 sge_bytes;\n\tu32 page_bytes;\n\tu32 page_off;\n\tint page_no;\n\tif (xdr->len !=\n\t    (xdr->head[0].iov_len + xdr->page_len + xdr->tail[0].iov_len)) {\n\t\tpr_err(\"svcrdma: %s: XDR buffer length error\\n\", __func__);\n\t\treturn -EIO;\n\t}\n \n\t/* Skip the first sge, this is for the RPCRDMA header */\n\tsge_no = 1;\n \n\t/* Head SGE */\n\tvec->sge[sge_no].iov_base = xdr->head[0].iov_base;\n\tvec->sge[sge_no].iov_len = xdr->head[0].iov_len;\n\tsge_no++;\n\t/* pages SGE */\n\tpage_no = 0;\n\tpage_bytes = xdr->page_len;\n\tpage_off = xdr->page_base;\n\twhile (page_bytes) {\n\t\tvec->sge[sge_no].iov_base =\n\t\t\tpage_address(xdr->pages[page_no]) + page_off;\n\t\tsge_bytes = min_t(u32, page_bytes, (PAGE_SIZE - page_off));\n\t\tpage_bytes -= sge_bytes;\n\t\tvec->sge[sge_no].iov_len = sge_bytes;\n\t\tsge_no++;\n\t\tpage_no++;\n\t\tpage_off = 0; /* reset for next time through loop */\n \t}\n \n\t/* Tail SGE */\n\tif (xdr->tail[0].iov_len) {\n\t\tunsigned char *base = xdr->tail[0].iov_base;\n\t\tsize_t len = xdr->tail[0].iov_len;\n\t\tu32 xdr_pad = xdr_padsize(xdr->page_len);\n \n\t\tif (write_chunk_present && xdr_pad) {\n\t\t\tbase += xdr_pad;\n\t\t\tlen -= xdr_pad;\n\t\t}\n \n\t\tif (len) {\n\t\t\tvec->sge[sge_no].iov_base = base;\n\t\t\tvec->sge[sge_no].iov_len = len;\n\t\t\tsge_no++;\n \t\t}\n\t}\n \n\tdprintk(\"svcrdma: %s: sge_no %d page_no %d \"\n\t\t\"page_base %u page_len %u head_len %zu tail_len %zu\\n\",\n\t\t__func__, sge_no, page_no, xdr->page_base, xdr->page_len,\n\t\txdr->head[0].iov_len, xdr->tail[0].iov_len);\n \n\tvec->count = sge_no;\n\treturn 0;\n }\n", "target": 1, "idx": 181345}
{"func": " struct bpf_map *bpf_map_get_with_uref(u32 ufd)\n{\n\tstruct fd f = fdget(ufd);\n\tstruct bpf_map *map;\n\n\tmap = __bpf_map_get(f);\n \tif (IS_ERR(map))\n \t\treturn map;\n \n\tbpf_map_inc(map, true);\n \tfdput(f);\n \n \treturn map;\n}\n", "target": 1, "idx": 180424}
{"func": "static int fuzzerTests(U32 seed, U32 nbTests, unsigned startTest, U32 const maxDurationS, double compressibility, int bigTests)\n{\n    static const U32 maxSrcLog = 23;\n    static const U32 maxSampleLog = 22;\n    size_t const srcBufferSize = (size_t)1<<maxSrcLog;\n    size_t const dstBufferSize = (size_t)1<<maxSampleLog;\n    size_t const cBufferSize   = ZSTD_compressBound(dstBufferSize);\n    BYTE* cNoiseBuffer[5];\n    BYTE* const cBuffer = (BYTE*) malloc (cBufferSize);\n    BYTE* const dstBuffer = (BYTE*) malloc (dstBufferSize);\n    BYTE* const mirrorBuffer = (BYTE*) malloc (dstBufferSize);\n    ZSTD_CCtx* const refCtx = ZSTD_createCCtx();\n    ZSTD_CCtx* const ctx = ZSTD_createCCtx();\n    ZSTD_DCtx* const dctx = ZSTD_createDCtx();\n    U32 result = 0;\n    U32 testNb = 0;\n    U32 coreSeed = seed;\n    UTIL_time_t const startClock = UTIL_getTime();\n    U64 const maxClockSpan = maxDurationS * SEC_TO_MICRO;\n    int const cLevelLimiter = bigTests ? 3 : 2;\n\n    /* allocation */\n    cNoiseBuffer[0] = (BYTE*)malloc (srcBufferSize);\n    cNoiseBuffer[1] = (BYTE*)malloc (srcBufferSize);\n    cNoiseBuffer[2] = (BYTE*)malloc (srcBufferSize);\n    cNoiseBuffer[3] = (BYTE*)malloc (srcBufferSize);\n    cNoiseBuffer[4] = (BYTE*)malloc (srcBufferSize);\n    CHECK (!cNoiseBuffer[0] || !cNoiseBuffer[1] || !cNoiseBuffer[2] || !cNoiseBuffer[3] || !cNoiseBuffer[4]\n           || !dstBuffer || !mirrorBuffer || !cBuffer || !refCtx || !ctx || !dctx,\n           \"Not enough memory, fuzzer tests cancelled\");\n\n    /* Create initial samples */\n    RDG_genBuffer(cNoiseBuffer[0], srcBufferSize, 0.00, 0., coreSeed);    /* pure noise */\n    RDG_genBuffer(cNoiseBuffer[1], srcBufferSize, 0.05, 0., coreSeed);    /* barely compressible */\n    RDG_genBuffer(cNoiseBuffer[2], srcBufferSize, compressibility, 0., coreSeed);\n    RDG_genBuffer(cNoiseBuffer[3], srcBufferSize, 0.95, 0., coreSeed);    /* highly compressible */\n    RDG_genBuffer(cNoiseBuffer[4], srcBufferSize, 1.00, 0., coreSeed);    /* sparse content */\n\n    /* catch up testNb */\n    for (testNb=1; testNb < startTest; testNb++) FUZ_rand(&coreSeed);\n\n    /* main test loop */\n    for ( ; (testNb <= nbTests) || (UTIL_clockSpanMicro(startClock) < maxClockSpan); testNb++ ) {\n        BYTE* srcBuffer;   /* jumping pointer */\n        U32 lseed;\n        size_t sampleSize, maxTestSize, totalTestSize;\n        size_t cSize, totalCSize, totalGenSize;\n        U64 crcOrig;\n        BYTE* sampleBuffer;\n        const BYTE* dict;\n        size_t dictSize;\n\n        /* notification */\n        if (nbTests >= testNb) { DISPLAYUPDATE(2, \"\\r%6u/%6u    \", testNb, nbTests); }\n        else { DISPLAYUPDATE(2, \"\\r%6u          \", testNb); }\n\n        FUZ_rand(&coreSeed);\n        { U32 const prime1 = 2654435761U; lseed = coreSeed ^ prime1; }\n\n        /* srcBuffer selection [0-4] */\n        {   U32 buffNb = FUZ_rand(&lseed) & 0x7F;\n            if (buffNb & 7) buffNb=2;   /* most common : compressible (P) */\n            else {\n                buffNb >>= 3;\n                if (buffNb & 7) {\n                    const U32 tnb[2] = { 1, 3 };   /* barely/highly compressible */\n                    buffNb = tnb[buffNb >> 3];\n                } else {\n                    const U32 tnb[2] = { 0, 4 };   /* not compressible / sparse */\n                    buffNb = tnb[buffNb >> 3];\n            }   }\n            srcBuffer = cNoiseBuffer[buffNb];\n        }\n\n        /* select src segment */\n        sampleSize = FUZ_randomLength(&lseed, maxSampleLog);\n\n        /* create sample buffer (to catch read error with valgrind & sanitizers)  */\n        sampleBuffer = (BYTE*)malloc(sampleSize);\n        CHECK(sampleBuffer==NULL, \"not enough memory for sample buffer\");\n        { size_t const sampleStart = FUZ_rand(&lseed) % (srcBufferSize - sampleSize);\n          memcpy(sampleBuffer, srcBuffer + sampleStart, sampleSize); }\n        crcOrig = XXH64(sampleBuffer, sampleSize, 0);\n\n        /* compression tests */\n        {   int const cLevelPositive =\n                    ( FUZ_rand(&lseed) %\n                     (ZSTD_maxCLevel() - (FUZ_highbit32((U32)sampleSize) / cLevelLimiter)) )\n                    + 1;\n            int const cLevel = ((FUZ_rand(&lseed) & 15) == 3) ?\n                             - (int)((FUZ_rand(&lseed) & 7) + 1) :   /* test negative cLevel */\n                             cLevelPositive;\n            DISPLAYLEVEL(5, \"fuzzer t%u: Simple compression test (level %i) \\n\", testNb, cLevel);\n            cSize = ZSTD_compressCCtx(ctx, cBuffer, cBufferSize, sampleBuffer, sampleSize, cLevel);\n             CHECK(ZSTD_isError(cSize), \"ZSTD_compressCCtx failed : %s\", ZSTD_getErrorName(cSize));\n \n             /* compression failure test : too small dest buffer */\n            if (cSize > 3) {\n                const size_t missing = (FUZ_rand(&lseed) % (cSize-2)) + 1;   /* no problem, as cSize > 4 (frameHeaderSizer) */\n                 const size_t tooSmallSize = cSize - missing;\n                 const U32 endMark = 0x4DC2B1A9;\n                 memcpy(dstBuffer+tooSmallSize, &endMark, 4);\n                 { size_t const errorCode = ZSTD_compressCCtx(ctx, dstBuffer, tooSmallSize, sampleBuffer, sampleSize, cLevel);\n                   CHECK(!ZSTD_isError(errorCode), \"ZSTD_compressCCtx should have failed ! (buffer too small : %u < %u)\", (U32)tooSmallSize, (U32)cSize); }\n                 { U32 endCheck; memcpy(&endCheck, dstBuffer+tooSmallSize, 4);\n                  CHECK(endCheck != endMark, \"ZSTD_compressCCtx : dst buffer overflow\"); }\n         }   }\n \n         /* frame header decompression test */\n        {   ZSTD_frameHeader zfh;\n            CHECK_Z( ZSTD_getFrameHeader(&zfh, cBuffer, cSize) );\n            CHECK(zfh.frameContentSize != sampleSize, \"Frame content size incorrect\");\n        }\n\n        /* Decompressed size test */\n        {   unsigned long long const rSize = ZSTD_findDecompressedSize(cBuffer, cSize);\n            CHECK(rSize != sampleSize, \"decompressed size incorrect\");\n        }\n\n        /* successful decompression test */\n        DISPLAYLEVEL(5, \"fuzzer t%u: simple decompression test \\n\", testNb);\n        {   size_t const margin = (FUZ_rand(&lseed) & 1) ? 0 : (FUZ_rand(&lseed) & 31) + 1;\n            size_t const dSize = ZSTD_decompress(dstBuffer, sampleSize + margin, cBuffer, cSize);\n            CHECK(dSize != sampleSize, \"ZSTD_decompress failed (%s) (srcSize : %u ; cSize : %u)\", ZSTD_getErrorName(dSize), (U32)sampleSize, (U32)cSize);\n            {   U64 const crcDest = XXH64(dstBuffer, sampleSize, 0);\n                CHECK(crcOrig != crcDest, \"decompression result corrupted (pos %u / %u)\", (U32)findDiff(sampleBuffer, dstBuffer, sampleSize), (U32)sampleSize);\n        }   }\n\n        free(sampleBuffer);   /* no longer useful after this point */\n\n        /* truncated src decompression test */\n        DISPLAYLEVEL(5, \"fuzzer t%u: decompression of truncated source \\n\", testNb);\n        {   size_t const missing = (FUZ_rand(&lseed) % (cSize-2)) + 1;   /* no problem, as cSize > 4 (frameHeaderSizer) */\n            size_t const tooSmallSize = cSize - missing;\n            void* cBufferTooSmall = malloc(tooSmallSize);   /* valgrind will catch read overflows */\n            CHECK(cBufferTooSmall == NULL, \"not enough memory !\");\n            memcpy(cBufferTooSmall, cBuffer, tooSmallSize);\n            { size_t const errorCode = ZSTD_decompress(dstBuffer, dstBufferSize, cBufferTooSmall, tooSmallSize);\n              CHECK(!ZSTD_isError(errorCode), \"ZSTD_decompress should have failed ! (truncated src buffer)\"); }\n            free(cBufferTooSmall);\n        }\n\n        /* too small dst decompression test */\n        DISPLAYLEVEL(5, \"fuzzer t%u: decompress into too small dst buffer \\n\", testNb);\n        if (sampleSize > 3) {\n            size_t const missing = (FUZ_rand(&lseed) % (sampleSize-2)) + 1;   /* no problem, as cSize > 4 (frameHeaderSizer) */\n            size_t const tooSmallSize = sampleSize - missing;\n            static const BYTE token = 0xA9;\n            dstBuffer[tooSmallSize] = token;\n            { size_t const errorCode = ZSTD_decompress(dstBuffer, tooSmallSize, cBuffer, cSize);\n              CHECK(!ZSTD_isError(errorCode), \"ZSTD_decompress should have failed : %u > %u (dst buffer too small)\", (U32)errorCode, (U32)tooSmallSize); }\n            CHECK(dstBuffer[tooSmallSize] != token, \"ZSTD_decompress : dst buffer overflow\");\n        }\n\n        /* noisy src decompression test */\n        if (cSize > 6) {\n            /* insert noise into src */\n            {   U32 const maxNbBits = FUZ_highbit32((U32)(cSize-4));\n                size_t pos = 4;   /* preserve magic number (too easy to detect) */\n                for (;;) {\n                    /* keep some original src */\n                    {   U32 const nbBits = FUZ_rand(&lseed) % maxNbBits;\n                        size_t const mask = (1<<nbBits) - 1;\n                        size_t const skipLength = FUZ_rand(&lseed) & mask;\n                        pos += skipLength;\n                    }\n                    if (pos >= cSize) break;\n                    /* add noise */\n                    {   U32 const nbBitsCodes = FUZ_rand(&lseed) % maxNbBits;\n                        U32 const nbBits = nbBitsCodes ? nbBitsCodes-1 : 0;\n                        size_t const mask = (1<<nbBits) - 1;\n                        size_t const rNoiseLength = (FUZ_rand(&lseed) & mask) + 1;\n                        size_t const noiseLength = MIN(rNoiseLength, cSize-pos);\n                        size_t const noiseStart = FUZ_rand(&lseed) % (srcBufferSize - noiseLength);\n                        memcpy(cBuffer + pos, srcBuffer + noiseStart, noiseLength);\n                        pos += noiseLength;\n            }   }   }\n\n            /* decompress noisy source */\n            DISPLAYLEVEL(5, \"fuzzer t%u: decompress noisy source \\n\", testNb);\n            {   U32 const endMark = 0xA9B1C3D6;\n                memcpy(dstBuffer+sampleSize, &endMark, 4);\n                {   size_t const decompressResult = ZSTD_decompress(dstBuffer, sampleSize, cBuffer, cSize);\n                    /* result *may* be an unlikely success, but even then, it must strictly respect dst buffer boundaries */\n                    CHECK((!ZSTD_isError(decompressResult)) && (decompressResult>sampleSize),\n                          \"ZSTD_decompress on noisy src : result is too large : %u > %u (dst buffer)\", (U32)decompressResult, (U32)sampleSize);\n                }\n                {   U32 endCheck; memcpy(&endCheck, dstBuffer+sampleSize, 4);\n                    CHECK(endMark!=endCheck, \"ZSTD_decompress on noisy src : dst buffer overflow\");\n        }   }   }   /* noisy src decompression test */\n\n        /*=====   Bufferless streaming compression test, scattered segments and dictionary   =====*/\n        DISPLAYLEVEL(5, \"fuzzer t%u: Bufferless streaming compression test \\n\", testNb);\n        {   U32 const testLog = FUZ_rand(&lseed) % maxSrcLog;\n            U32 const dictLog = FUZ_rand(&lseed) % maxSrcLog;\n            int const cLevel = (FUZ_rand(&lseed) %\n                                (ZSTD_maxCLevel() -\n                                 (MAX(testLog, dictLog) / cLevelLimiter))) +\n                               1;\n            maxTestSize = FUZ_rLogLength(&lseed, testLog);\n            if (maxTestSize >= dstBufferSize) maxTestSize = dstBufferSize-1;\n\n            dictSize = FUZ_rLogLength(&lseed, dictLog);   /* needed also for decompression */\n            dict = srcBuffer + (FUZ_rand(&lseed) % (srcBufferSize - dictSize));\n\n            DISPLAYLEVEL(6, \"fuzzer t%u: Compressing up to <=%u bytes at level %i with dictionary size %u \\n\",\n                            testNb, (U32)maxTestSize, cLevel, (U32)dictSize);\n\n            if (FUZ_rand(&lseed) & 0xF) {\n                CHECK_Z ( ZSTD_compressBegin_usingDict(refCtx, dict, dictSize, cLevel) );\n            } else {\n                ZSTD_compressionParameters const cPar = ZSTD_getCParams(cLevel, ZSTD_CONTENTSIZE_UNKNOWN, dictSize);\n                ZSTD_frameParameters const fPar = { FUZ_rand(&lseed)&1 /* contentSizeFlag */,\n                                                    !(FUZ_rand(&lseed)&3) /* contentChecksumFlag*/,\n                                                    0 /*NodictID*/ };   /* note : since dictionary is fake, dictIDflag has no impact */\n                ZSTD_parameters const p = FUZ_makeParams(cPar, fPar);\n                CHECK_Z ( ZSTD_compressBegin_advanced(refCtx, dict, dictSize, p, 0) );\n            }\n            CHECK_Z( ZSTD_copyCCtx(ctx, refCtx, 0) );\n        }\n\n        {   U32 const nbChunks = (FUZ_rand(&lseed) & 127) + 2;\n            U32 n;\n            XXH64_state_t xxhState;\n            XXH64_reset(&xxhState, 0);\n            for (totalTestSize=0, cSize=0, n=0 ; n<nbChunks ; n++) {\n                size_t const segmentSize = FUZ_randomLength(&lseed, maxSampleLog);\n                size_t const segmentStart = FUZ_rand(&lseed) % (srcBufferSize - segmentSize);\n\n                if (cBufferSize-cSize < ZSTD_compressBound(segmentSize)) break;   /* avoid invalid dstBufferTooSmall */\n                if (totalTestSize+segmentSize > maxTestSize) break;\n\n                {   size_t const compressResult = ZSTD_compressContinue(ctx, cBuffer+cSize, cBufferSize-cSize, srcBuffer+segmentStart, segmentSize);\n                    CHECK (ZSTD_isError(compressResult), \"multi-segments compression error : %s\", ZSTD_getErrorName(compressResult));\n                    cSize += compressResult;\n                }\n                XXH64_update(&xxhState, srcBuffer+segmentStart, segmentSize);\n                memcpy(mirrorBuffer + totalTestSize, srcBuffer+segmentStart, segmentSize);\n                totalTestSize += segmentSize;\n            }\n\n            {   size_t const flushResult = ZSTD_compressEnd(ctx, cBuffer+cSize, cBufferSize-cSize, NULL, 0);\n                CHECK (ZSTD_isError(flushResult), \"multi-segments epilogue error : %s\", ZSTD_getErrorName(flushResult));\n                cSize += flushResult;\n            }\n            crcOrig = XXH64_digest(&xxhState);\n        }\n\n        /* streaming decompression test */\n        DISPLAYLEVEL(5, \"fuzzer t%u: Bufferless streaming decompression test \\n\", testNb);\n        /* ensure memory requirement is good enough (should always be true) */\n        {   ZSTD_frameHeader zfh;\n            CHECK( ZSTD_getFrameHeader(&zfh, cBuffer, ZSTD_frameHeaderSize_max),\n                  \"ZSTD_getFrameHeader(): error retrieving frame information\");\n            {   size_t const roundBuffSize = ZSTD_decodingBufferSize_min(zfh.windowSize, zfh.frameContentSize);\n                CHECK_Z(roundBuffSize);\n                CHECK((roundBuffSize > totalTestSize) && (zfh.frameContentSize!=ZSTD_CONTENTSIZE_UNKNOWN),\n                      \"ZSTD_decodingBufferSize_min() requires more memory (%u) than necessary (%u)\",\n                      (U32)roundBuffSize, (U32)totalTestSize );\n        }   }\n        if (dictSize<8) dictSize=0, dict=NULL;   /* disable dictionary */\n        CHECK_Z( ZSTD_decompressBegin_usingDict(dctx, dict, dictSize) );\n        totalCSize = 0;\n        totalGenSize = 0;\n        while (totalCSize < cSize) {\n            size_t const inSize = ZSTD_nextSrcSizeToDecompress(dctx);\n            size_t const genSize = ZSTD_decompressContinue(dctx, dstBuffer+totalGenSize, dstBufferSize-totalGenSize, cBuffer+totalCSize, inSize);\n            CHECK (ZSTD_isError(genSize), \"ZSTD_decompressContinue error : %s\", ZSTD_getErrorName(genSize));\n            totalGenSize += genSize;\n            totalCSize += inSize;\n        }\n        CHECK (ZSTD_nextSrcSizeToDecompress(dctx) != 0, \"frame not fully decoded\");\n        CHECK (totalGenSize != totalTestSize, \"streaming decompressed data : wrong size\")\n        CHECK (totalCSize != cSize, \"compressed data should be fully read\")\n        {   U64 const crcDest = XXH64(dstBuffer, totalTestSize, 0);\n            CHECK(crcOrig != crcDest, \"streaming decompressed data corrupted (pos %u / %u)\",\n                (U32)findDiff(mirrorBuffer, dstBuffer, totalTestSize), (U32)totalTestSize);\n        }\n    }   /* for ( ; (testNb <= nbTests) */\n    DISPLAY(\"\\r%u fuzzer tests completed   \\n\", testNb-1);\n\n_cleanup:\n    ZSTD_freeCCtx(refCtx);\n    ZSTD_freeCCtx(ctx);\n    ZSTD_freeDCtx(dctx);\n    free(cNoiseBuffer[0]);\n    free(cNoiseBuffer[1]);\n    free(cNoiseBuffer[2]);\n    free(cNoiseBuffer[3]);\n    free(cNoiseBuffer[4]);\n    free(cBuffer);\n    free(dstBuffer);\n    free(mirrorBuffer);\n    return result;\n\n_output_error:\n    result = 1;\n    goto _cleanup;\n}\n", "target": 1, "idx": 182847}
{"func": "bool AutofillDownloadManager::StartUploadRequest(\n    const FormStructure& form,\n    bool form_was_autofilled,\n    const FieldTypeSet& available_field_types) {\n  if (next_upload_request_ > base::Time::Now()) {\n    VLOG(1) << \"AutofillDownloadManager: Upload request is throttled.\";\n    return false;\n  }\n\n   double upload_rate = form_was_autofilled ? GetPositiveUploadRate() :\n                                              GetNegativeUploadRate();\n  if (base::RandDouble() > upload_rate) {\n     VLOG(1) << \"AutofillDownloadManager: Upload request is ignored.\";\n     return false;\n  }\n\n  std::string form_xml;\n  if (!form.EncodeUploadRequest(available_field_types, form_was_autofilled,\n                                &form_xml))\n    return false;\n\n  FormRequestData request_data;\n  request_data.form_signatures.push_back(form.FormSignature());\n  request_data.request_type = AutofillDownloadManager::REQUEST_UPLOAD;\n\n  return StartRequest(form_xml, request_data);\n}\n", "target": 1, "idx": 183903}
{"func": "static uint32 SelectSamplesPerPacket(AudioParameters params) {\n  int samples = kMinSamplesPerHardwarePacket;\n  while (samples <= kMaxSamplesPerHardwarePacket &&\n         samples * base::Time::kMillisecondsPerSecond <\n         params.sample_rate * kMillisecondsPerHardwarePacket) {\n    samples *= 2;\n  }\n  return samples;\n}\n", "target": 0, "idx": 108383}
{"func": "   void SetManualFallbacksForFilling(bool enabled) {\n     if (enabled) {\n       scoped_feature_list_.InitAndEnableFeature(\n          password_manager::features::kEnableManualFallbacksFilling);\n     } else {\n       scoped_feature_list_.InitAndDisableFeature(\n          password_manager::features::kEnableManualFallbacksFilling);\n     }\n   }\n", "target": 1, "idx": 185627}
{"func": "OMX_ERRORTYPE OMXNodeInstance::OnFillBufferDone(\n        OMX_IN OMX_HANDLETYPE /* hComponent */,\n        OMX_IN OMX_PTR pAppData,\n        OMX_IN OMX_BUFFERHEADERTYPE* pBuffer) {\n OMXNodeInstance *instance = static_cast<OMXNodeInstance *>(pAppData);\n if (instance->mDying) {\n return OMX_ErrorNone;\n }\n return instance->owner()->OnFillBufferDone(instance->nodeID(),\n            instance->findBufferID(pBuffer), pBuffer);\n}\n", "target": 0, "idx": 170716}
{"func": "ftp_genlist(ftpbuf_t *ftp, const char *cmd, const char *path TSRMLS_DC)\n{\n\tphp_stream\t*tmpstream = NULL;\n\tdatabuf_t\t*data = NULL;\n\tchar\t\t*ptr;\n\tint\t\tch, lastch;\n\tsize_t\t\tsize, rcvd;\n\tsize_t\t\tlines;\n\tchar\t\t**ret = NULL;\n\tchar\t\t**entry;\n\tchar\t\t*text;\n\n\n\tif ((tmpstream = php_stream_fopen_tmpfile()) == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to create temporary file.  Check permissions in temporary files directory.\");\n\t\treturn NULL;\n\t}\n\n\tif (!ftp_type(ftp, FTPTYPE_ASCII)) {\n\t\tgoto bail;\n\t}\n\n\tif ((data = ftp_getdata(ftp TSRMLS_CC)) == NULL) {\n\t\tgoto bail;\n\t}\n\tftp->data = data;\n\n\tif (!ftp_putcmd(ftp, cmd, path)) {\n\t\tgoto bail;\n\t}\n\tif (!ftp_getresp(ftp) || (ftp->resp != 150 && ftp->resp != 125 && ftp->resp != 226)) {\n\t\tgoto bail;\n\t}\n\n\t/* some servers don't open a ftp-data connection if the directory is empty */\n\tif (ftp->resp == 226) {\n\t\tftp->data = data_close(ftp, data);\n\t\tphp_stream_close(tmpstream);\n\t\treturn ecalloc(1, sizeof(char*));\n\t}\n\n\t/* pull data buffer into tmpfile */\n\tif ((data = data_accept(data, ftp TSRMLS_CC)) == NULL) {\n\t\tgoto bail;\n\t}\n\tsize = 0;\n\tlines = 0;\n\tlastch = 0;\n\twhile ((rcvd = my_recv(ftp, data->fd, data->buf, FTP_BUFSIZE))) {\n\t\tif (rcvd == -1 || rcvd > ((size_t)(-1))-size) {\n\t\t\tgoto bail;\n\t\t}\n\n\t\tphp_stream_write(tmpstream, data->buf, rcvd);\n\n\t\tsize += rcvd;\n                for (ptr = data->buf; rcvd; rcvd--, ptr++) {\n                        if (*ptr == '\\n' && lastch == '\\r') {\n                                lines++;\n                       } else {\n                               size++;\n                        }\n                        lastch = *ptr;\n                }\n\t\t\tlastch = *ptr;\n\t\t}\n\t}\n", "target": 1, "idx": 178473}
{"func": "static void ip6mr_destroy_unres(struct mr6_table *mrt, struct mfc6_cache *c)\n{\n\tstruct net *net = read_pnet(&mrt->net);\n\tstruct sk_buff *skb;\n\n\tatomic_dec(&mrt->cache_resolve_queue_len);\n\n\twhile ((skb = skb_dequeue(&c->mfc_un.unres.unresolved)) != NULL) {\n\t\tif (ipv6_hdr(skb)->version == 0) {\n\t\t\tstruct nlmsghdr *nlh = (struct nlmsghdr *)skb_pull(skb, sizeof(struct ipv6hdr));\n\t\t\tnlh->nlmsg_type = NLMSG_ERROR;\n\t\t\tnlh->nlmsg_len = nlmsg_msg_size(sizeof(struct nlmsgerr));\n\t\t\tskb_trim(skb, nlh->nlmsg_len);\n\t\t\t((struct nlmsgerr *)nlmsg_data(nlh))->error = -ETIMEDOUT;\n\t\t\trtnl_unicast(skb, net, NETLINK_CB(skb).portid);\n\t\t} else\n\t\t\tkfree_skb(skb);\n\t}\n\n\tip6mr_cache_free(c);\n}\n", "target": 0, "idx": 93523}
{"func": "  void GoBackCrossSite() {\n     NavigationEntry* entry = contents()->controller().GetEntryAtOffset(-1);\n     ASSERT_TRUE(entry);\n     contents()->controller().GoBack();\n \n    contents()->TestDidNavigate(\n        contents()->pending_rvh(), entry->page_id(), GURL(entry->url()),\n        content::PAGE_TRANSITION_TYPED);\n   }\n", "target": 1, "idx": 184660}
{"func": "u32 secure_ipv4_port_ephemeral(__be32 saddr, __be32 daddr, __be16 dport)\n{\n\tstruct keydata *keyptr = get_keyptr();\n\tu32 hash[4];\n\t/*\n\t *  Pick a unique starting offset for each ephemeral port search\n\t *  (saddr, daddr, dport) and 48bits of random data.\n\t */\n\thash[0] = (__force u32)saddr;\n\thash[1] = (__force u32)daddr;\n\thash[2] = (__force u32)dport ^ keyptr->secret[10];\n\thash[3] = keyptr->secret[11];\n\treturn half_md4_transform(hash, keyptr->secret);\n}\n", "target": 1, "idx": 178937}
{"func": "void iov_iter_pipe(struct iov_iter *i, int direction,\n\t\t\tstruct pipe_inode_info *pipe,\n \t\t\tsize_t count)\n {\n \tBUG_ON(direction != ITER_PIPE);\n \ti->type = direction;\n \ti->pipe = pipe;\n \ti->idx = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);\n\ti->iov_offset = 0;\n\ti->count = count;\n}\n", "target": 1, "idx": 181559}
{"func": "SIZED_STRING* yr_re_ast_extract_literal(\n    RE_AST* re_ast)\n{\n  SIZED_STRING* string;\n  RE_NODE* node = re_ast->root_node;\n\n  int i, length = 0;\n  char tmp;\n\n  while (node != NULL)\n  {\n    length++;\n\n    if (node->type == RE_NODE_LITERAL)\n      break;\n\n    if (node->type != RE_NODE_CONCAT)\n      return NULL;\n\n    if (node->right == NULL ||\n        node->right->type != RE_NODE_LITERAL)\n      return NULL;\n\n    node = node->left;\n  }\n\n  string = (SIZED_STRING*) yr_malloc(sizeof(SIZED_STRING) + length);\n\n  if (string == NULL)\n    return NULL;\n\n  string->length = 0;\n\n  node = re_ast->root_node;\n\n  while (node->type == RE_NODE_CONCAT)\n  {\n    string->c_string[string->length++] = node->right->value;\n    node = node->left;\n  }\n\n  string->c_string[string->length++] = node->value;\n\n\n  for (i = 0; i < length / 2; i++)\n  {\n    tmp = string->c_string[i];\n    string->c_string[i] = string->c_string[length - i - 1];\n    string->c_string[length - i - 1] = tmp;\n  }\n\n  return string;\n}\n", "target": 0, "idx": 64571}
{"func": "static inline void write_s3row_data(\n\tconst entity_stage3_row *r,\n\tunsigned orig_cp,\n\tenum entity_charset charset,\n\tzval *arr)\n{\n\tchar key[9] = \"\"; /* two unicode code points in UTF-8 */\n\tchar entity[LONGEST_ENTITY_LENGTH + 2] = {'&'};\n\tsize_t written_k1;\n\n\twritten_k1 = write_octet_sequence(key, charset, orig_cp);\n\n\tif (!r->ambiguous) {\n\t\tsize_t l = r->data.ent.entity_len;\n\t\tmemcpy(&entity[1], r->data.ent.entity, l);\n\t\tentity[l + 1] = ';';\n\t\tadd_assoc_stringl_ex(arr, key, written_k1 + 1, entity, l + 2, 1);\n\t} else {\n\t\tunsigned i,\n\t\t\t     num_entries;\n\t\tconst entity_multicodepoint_row *mcpr = r->data.multicodepoint_table;\n\n\t\tif (mcpr[0].leading_entry.default_entity != NULL) {\n\t\t\tsize_t l = mcpr[0].leading_entry.default_entity_len;\n\t\t\tmemcpy(&entity[1], mcpr[0].leading_entry.default_entity, l);\n\t\t\tentity[l + 1] = ';';\n\t\t\tadd_assoc_stringl_ex(arr, key, written_k1 + 1, entity, l + 2, 1);\n\t\t}\n\t\tnum_entries = mcpr[0].leading_entry.size;\n\t\tfor (i = 1; i <= num_entries; i++) {\n\t\t\tsize_t   l,\n\t\t\t\t     written_k2;\n\t\t\tunsigned uni_cp,\n\t\t\t\t\t spe_cp;\n\n\t\t\tuni_cp = mcpr[i].normal_entry.second_cp;\n\t\t\tl = mcpr[i].normal_entry.entity_len;\n\n\t\t\tif (!CHARSET_UNICODE_COMPAT(charset)) {\n\t\t\t\tif (map_from_unicode(uni_cp, charset, &spe_cp) == FAILURE)\n\t\t\t\t\tcontinue; /* non representable in this charset */\n \t\t\t} else {\n \t\t\t\tspe_cp = uni_cp;\n \t\t\t}\n \t\t\twritten_k2 = write_octet_sequence(&key[written_k1], charset, spe_cp);\n \t\t\tmemcpy(&entity[1], mcpr[i].normal_entry.entity, l);\n \t\t\tentity[l + 1] = ';';\n\t\t\tentity[l + 1] = '\\0';\n\t\t\tadd_assoc_stringl_ex(arr, key, written_k1 + written_k2 + 1, entity, l + 1, 1);\n\t\t}\n\t}\n}\n", "target": 1, "idx": 180353}
{"func": "xmlParseEntityRef(xmlParserCtxtPtr ctxt) {\n    const xmlChar *name;\n     xmlEntityPtr ent = NULL;\n \n     GROW;\n \n     if (RAW != '&')\n         return(NULL);\n    NEXT;\n    name = xmlParseName(ctxt);\n    if (name == NULL) {\n\txmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n\t\t       \"xmlParseEntityRef: no name\\n\");\n        return(NULL);\n    }\n    if (RAW != ';') {\n\txmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL);\n\treturn(NULL);\n    }\n    NEXT;\n\n    /*\n     * Predefined entites override any extra definition\n     */\n    if ((ctxt->options & XML_PARSE_OLDSAX) == 0) {\n        ent = xmlGetPredefinedEntity(name);\n        if (ent != NULL)\n            return(ent);\n    }\n\n    /*\n     * Increate the number of entity references parsed\n     */\n    ctxt->nbentities++;\n\n    /*\n     * Ask first SAX for entity resolution, otherwise try the\n     * entities which may have stored in the parser context.\n     */\n    if (ctxt->sax != NULL) {\n\tif (ctxt->sax->getEntity != NULL)\n\t    ent = ctxt->sax->getEntity(ctxt->userData, name);\n\tif ((ctxt->wellFormed == 1 ) && (ent == NULL) && \n\t    (ctxt->options & XML_PARSE_OLDSAX))\n\t    ent = xmlGetPredefinedEntity(name);\n\tif ((ctxt->wellFormed == 1 ) && (ent == NULL) &&\n\t    (ctxt->userData==ctxt)) {\n \t    ent = xmlSAX2GetEntity(ctxt, name);\n \t}\n     }\n     /*\n      * [ WFC: Entity Declared ]\n      * In a document without any DTD, a document with only an\n     * internal DTD subset which contains no parameter entity\n     * references, or a document with \"standalone='yes'\", the\n     * Name given in the entity reference must match that in an\n     * entity declaration, except that well-formed documents\n     * need not declare any of the following entities: amp, lt,\n     * gt, apos, quot.\n     * The declaration of a parameter entity must precede any\n     * reference to it.\n     * Similarly, the declaration of a general entity must\n     * precede any reference to it which appears in a default\n     * value in an attribute-list declaration. Note that if\n     * entities are declared in the external subset or in\n     * external parameter entities, a non-validating processor\n     * is not obligated to read and process their declarations;\n     * for such documents, the rule that an entity must be\n     * declared is a well-formedness constraint only if\n     * standalone='yes'.\n     */\n    if (ent == NULL) {\n\tif ((ctxt->standalone == 1) ||\n\t    ((ctxt->hasExternalSubset == 0) &&\n\t     (ctxt->hasPErefs == 0))) {\n\t    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,\n\t\t     \"Entity '%s' not defined\\n\", name);\n\t} else {\n\t    xmlErrMsgStr(ctxt, XML_WAR_UNDECLARED_ENTITY,\n\t\t     \"Entity '%s' not defined\\n\", name);\n\t    if ((ctxt->inSubset == 0) &&\n\t\t(ctxt->sax != NULL) &&\n\t\t(ctxt->sax->reference != NULL)) {\n\t\tctxt->sax->reference(ctxt->userData, name);\n\t    }\n\t}\n\tctxt->valid = 0;\n    }\n\n    /*\n     * [ WFC: Parsed Entity ]\n     * An entity reference must not contain the name of an\n     * unparsed entity\n     */\n    else if (ent->etype == XML_EXTERNAL_GENERAL_UNPARSED_ENTITY) {\n\txmlFatalErrMsgStr(ctxt, XML_ERR_UNPARSED_ENTITY,\n\t\t \"Entity reference to unparsed entity %s\\n\", name);\n    }\n\n    /*\n     * [ WFC: No External Entity References ]\n     * Attribute values cannot contain direct or indirect\n     * entity references to external entities.\n     */\n    else if ((ctxt->instate == XML_PARSER_ATTRIBUTE_VALUE) &&\n\t     (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)) {\n\txmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_IS_EXTERNAL,\n\t     \"Attribute references external entity '%s'\\n\", name);\n    }\n    /*\n     * [ WFC: No < in Attribute Values ]\n     * The replacement text of any entity referred to directly or\n     * indirectly in an attribute value (other than \"&lt;\") must\n     * not contain a <. \n     */\n    else if ((ctxt->instate == XML_PARSER_ATTRIBUTE_VALUE) &&\n\t     (ent != NULL) && (ent->content != NULL) &&\n\t     (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n\t     (xmlStrchr(ent->content, '<'))) {\n\txmlFatalErrMsgStr(ctxt, XML_ERR_LT_IN_ATTRIBUTE,\n    \"'<' in entity '%s' is not allowed in attributes values\\n\", name);\n    }\n\n    /*\n     * Internal check, no parameter entities here ...\n     */\n    else {\n\tswitch (ent->etype) {\n\t    case XML_INTERNAL_PARAMETER_ENTITY:\n\t    case XML_EXTERNAL_PARAMETER_ENTITY:\n\t    xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_IS_PARAMETER,\n\t     \"Attempt to reference the parameter entity '%s'\\n\",\n\t\t\t      name);\n\t    break;\n\t    default:\n\t    break;\n\t}\n    }\n\n    /*\n     * [ WFC: No Recursion ]\n     * A parsed entity must not contain a recursive reference\n     * to itself, either directly or indirectly. \n     * Done somewhere else\n     */\n    return(ent);\n}\n", "target": 1, "idx": 184981}
{"func": "void LockContentsView::RemoveUser(bool is_primary) {\n  if (Shell::Get()->login_screen_controller()->IsAuthenticating())\n    return;\n\n  LoginBigUserView* to_remove =\n      is_primary ? primary_big_view_ : opt_secondary_big_view_;\n  DCHECK(to_remove->GetCurrentUser()->can_remove);\n  AccountId user = to_remove->GetCurrentUser()->basic_user_info->account_id;\n\n  Shell::Get()->login_screen_controller()->RemoveUser(user);\n\n  std::vector<mojom::LoginUserInfoPtr> new_users;\n  if (!is_primary)\n    new_users.push_back(primary_big_view_->GetCurrentUser()->Clone());\n  if (is_primary && opt_secondary_big_view_)\n    new_users.push_back(opt_secondary_big_view_->GetCurrentUser()->Clone());\n  if (users_list_) {\n    for (int i = 0; i < users_list_->user_count(); ++i) {\n      new_users.push_back(\n          users_list_->user_view_at(i)->current_user()->Clone());\n    }\n  }\n  data_dispatcher_->NotifyUsers(new_users);\n}\n", "target": 0, "idx": 144215}
{"func": "static __always_inline ssize_t __mcopy_atomic_hugetlb(struct mm_struct *dst_mm,\n\t\t\t\t\t      struct vm_area_struct *dst_vma,\n\t\t\t\t\t      unsigned long dst_start,\n\t\t\t\t\t      unsigned long src_start,\n\t\t\t\t\t      unsigned long len,\n\t\t\t\t\t      bool zeropage)\n{\n\tint vm_alloc_shared = dst_vma->vm_flags & VM_SHARED;\n\tint vm_shared = dst_vma->vm_flags & VM_SHARED;\n\tssize_t err;\n\tpte_t *dst_pte;\n\tunsigned long src_addr, dst_addr;\n\tlong copied;\n\tstruct page *page;\n\tstruct hstate *h;\n\tunsigned long vma_hpagesize;\n\tpgoff_t idx;\n\tu32 hash;\n\tstruct address_space *mapping;\n\n\t/*\n\t * There is no default zero huge page for all huge page sizes as\n\t * supported by hugetlb.  A PMD_SIZE huge pages may exist as used\n\t * by THP.  Since we can not reliably insert a zero page, this\n\t * feature is not supported.\n\t */\n\tif (zeropage) {\n\t\tup_read(&dst_mm->mmap_sem);\n\t\treturn -EINVAL;\n\t}\n\n\tsrc_addr = src_start;\n\tdst_addr = dst_start;\n\tcopied = 0;\n\tpage = NULL;\n\tvma_hpagesize = vma_kernel_pagesize(dst_vma);\n\n\t/*\n\t * Validate alignment based on huge page size\n\t */\n\terr = -EINVAL;\n\tif (dst_start & (vma_hpagesize - 1) || len & (vma_hpagesize - 1))\n\t\tgoto out_unlock;\n\nretry:\n\t/*\n\t * On routine entry dst_vma is set.  If we had to drop mmap_sem and\n\t * retry, dst_vma will be set to NULL and we must lookup again.\n\t */\n\tif (!dst_vma) {\n\t\terr = -ENOENT;\n\t\tdst_vma = find_vma(dst_mm, dst_start);\n \t\tif (!dst_vma || !is_vm_hugetlb_page(dst_vma))\n \t\t\tgoto out_unlock;\n \t\t/*\n\t\t * Only allow __mcopy_atomic_hugetlb on userfaultfd\n\t\t * registered ranges.\n \t\t */\n \t\tif (!dst_vma->vm_userfaultfd_ctx.ctx)\n \t\t\tgoto out_unlock;\n\n\t\tif (dst_start < dst_vma->vm_start ||\n\t\t    dst_start + len > dst_vma->vm_end)\n\t\t\tgoto out_unlock;\n\n\t\terr = -EINVAL;\n\t\tif (vma_hpagesize != vma_kernel_pagesize(dst_vma))\n\t\t\tgoto out_unlock;\n\n\t\tvm_shared = dst_vma->vm_flags & VM_SHARED;\n\t}\n\n\tif (WARN_ON(dst_addr & (vma_hpagesize - 1) ||\n\t\t    (len - copied) & (vma_hpagesize - 1)))\n\t\tgoto out_unlock;\n\n\t/*\n\t * If not shared, ensure the dst_vma has a anon_vma.\n\t */\n\terr = -ENOMEM;\n\tif (!vm_shared) {\n\t\tif (unlikely(anon_vma_prepare(dst_vma)))\n\t\t\tgoto out_unlock;\n\t}\n\n\th = hstate_vma(dst_vma);\n\n\twhile (src_addr < src_start + len) {\n\t\tpte_t dst_pteval;\n\n\t\tBUG_ON(dst_addr >= dst_start + len);\n\t\tVM_BUG_ON(dst_addr & ~huge_page_mask(h));\n\n\t\t/*\n\t\t * Serialize via hugetlb_fault_mutex\n\t\t */\n\t\tidx = linear_page_index(dst_vma, dst_addr);\n\t\tmapping = dst_vma->vm_file->f_mapping;\n\t\thash = hugetlb_fault_mutex_hash(h, dst_mm, dst_vma, mapping,\n\t\t\t\t\t\t\t\tidx, dst_addr);\n\t\tmutex_lock(&hugetlb_fault_mutex_table[hash]);\n\n\t\terr = -ENOMEM;\n\t\tdst_pte = huge_pte_alloc(dst_mm, dst_addr, huge_page_size(h));\n\t\tif (!dst_pte) {\n\t\t\tmutex_unlock(&hugetlb_fault_mutex_table[hash]);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\terr = -EEXIST;\n\t\tdst_pteval = huge_ptep_get(dst_pte);\n\t\tif (!huge_pte_none(dst_pteval)) {\n\t\t\tmutex_unlock(&hugetlb_fault_mutex_table[hash]);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\terr = hugetlb_mcopy_atomic_pte(dst_mm, dst_pte, dst_vma,\n\t\t\t\t\t\tdst_addr, src_addr, &page);\n\n\t\tmutex_unlock(&hugetlb_fault_mutex_table[hash]);\n\t\tvm_alloc_shared = vm_shared;\n\n\t\tcond_resched();\n\n\t\tif (unlikely(err == -ENOENT)) {\n\t\t\tup_read(&dst_mm->mmap_sem);\n\t\t\tBUG_ON(!page);\n\n\t\t\terr = copy_huge_page_from_user(page,\n\t\t\t\t\t\t(const void __user *)src_addr,\n\t\t\t\t\t\tpages_per_huge_page(h), true);\n\t\t\tif (unlikely(err)) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tdown_read(&dst_mm->mmap_sem);\n\n\t\t\tdst_vma = NULL;\n\t\t\tgoto retry;\n\t\t} else\n\t\t\tBUG_ON(page);\n\n\t\tif (!err) {\n\t\t\tdst_addr += vma_hpagesize;\n\t\t\tsrc_addr += vma_hpagesize;\n\t\t\tcopied += vma_hpagesize;\n\n\t\t\tif (fatal_signal_pending(current))\n\t\t\t\terr = -EINTR;\n\t\t}\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\nout_unlock:\n\tup_read(&dst_mm->mmap_sem);\nout:\n\tif (page) {\n\t\t/*\n\t\t * We encountered an error and are about to free a newly\n\t\t * allocated huge page.\n\t\t *\n\t\t * Reservation handling is very subtle, and is different for\n\t\t * private and shared mappings.  See the routine\n\t\t * restore_reserve_on_error for details.  Unfortunately, we\n\t\t * can not call restore_reserve_on_error now as it would\n\t\t * require holding mmap_sem.\n\t\t *\n\t\t * If a reservation for the page existed in the reservation\n\t\t * map of a private mapping, the map was modified to indicate\n\t\t * the reservation was consumed when the page was allocated.\n\t\t * We clear the PagePrivate flag now so that the global\n\t\t * reserve count will not be incremented in free_huge_page.\n\t\t * The reservation map will still indicate the reservation\n\t\t * was consumed and possibly prevent later page allocation.\n\t\t * This is better than leaking a global reservation.  If no\n\t\t * reservation existed, it is still safe to clear PagePrivate\n\t\t * as no adjustments to reservation counts were made during\n\t\t * allocation.\n\t\t *\n\t\t * The reservation map for shared mappings indicates which\n\t\t * pages have reservations.  When a huge page is allocated\n\t\t * for an address with a reservation, no change is made to\n\t\t * the reserve map.  In this case PagePrivate will be set\n\t\t * to indicate that the global reservation count should be\n\t\t * incremented when the page is freed.  This is the desired\n\t\t * behavior.  However, when a huge page is allocated for an\n\t\t * address without a reservation a reservation entry is added\n\t\t * to the reservation map, and PagePrivate will not be set.\n\t\t * When the page is freed, the global reserve count will NOT\n\t\t * be incremented and it will appear as though we have leaked\n\t\t * reserved page.  In this case, set PagePrivate so that the\n\t\t * global reserve count will be incremented to match the\n\t\t * reservation map entry which was created.\n\t\t *\n\t\t * Note that vm_alloc_shared is based on the flags of the vma\n\t\t * for which the page was originally allocated.  dst_vma could\n\t\t * be different or NULL on error.\n\t\t */\n\t\tif (vm_alloc_shared)\n\t\t\tSetPagePrivate(page);\n\t\telse\n\t\t\tClearPagePrivate(page);\n\t\tput_page(page);\n\t}\n\tBUG_ON(copied < 0);\n\tBUG_ON(err > 0);\n\tBUG_ON(!copied && !err);\n\treturn copied ? copied : err;\n}\n", "target": 1, "idx": 182180}
{"func": "static AppProto AppLayerProtoDetectPPGetProto(Flow *f,\n                                              uint8_t *buf, uint32_t buflen,\n                                              uint8_t ipproto, uint8_t direction)\n{\n    const AppLayerProtoDetectProbingParserPort *pp_port_dp = NULL;\n    const AppLayerProtoDetectProbingParserPort *pp_port_sp = NULL;\n    const AppLayerProtoDetectProbingParserElement *pe = NULL;\n    const AppLayerProtoDetectProbingParserElement *pe1 = NULL;\n    const AppLayerProtoDetectProbingParserElement *pe2 = NULL;\n    AppProto alproto = ALPROTO_UNKNOWN;\n    uint32_t *alproto_masks;\n    uint32_t mask = 0;\n\n    const uint16_t dp = f->protodetect_dp ? f->protodetect_dp : f->dp;\n    const uint16_t sp = f->sp;\n\n    if (direction & STREAM_TOSERVER) {\n        /* first try the destination port */\n        pp_port_dp = AppLayerProtoDetectGetProbingParsers(alpd_ctx.ctx_pp, ipproto, dp);\n        alproto_masks = &f->probing_parser_toserver_alproto_masks;\n        if (pp_port_dp != NULL) {\n            SCLogDebug(\"toserver - Probing parser found for destination port %\"PRIu16, dp);\n\n            /* found based on destination port, so use dp registration */\n            pe1 = pp_port_dp->dp;\n        } else {\n            SCLogDebug(\"toserver - No probing parser registered for dest port %\"PRIu16, dp);\n        }\n\n        pp_port_sp = AppLayerProtoDetectGetProbingParsers(alpd_ctx.ctx_pp, ipproto, sp);\n        if (pp_port_sp != NULL) {\n            SCLogDebug(\"toserver - Probing parser found for source port %\"PRIu16, sp);\n\n            /* found based on source port, so use sp registration */\n            pe2 = pp_port_sp->sp;\n        } else {\n            SCLogDebug(\"toserver - No probing parser registered for source port %\"PRIu16, sp);\n        }\n    } else {\n        /* first try the destination port */\n        pp_port_dp = AppLayerProtoDetectGetProbingParsers(alpd_ctx.ctx_pp, ipproto, dp);\n        alproto_masks = &f->probing_parser_toclient_alproto_masks;\n        if (pp_port_dp != NULL) {\n            SCLogDebug(\"toclient - Probing parser found for destination port %\"PRIu16, dp);\n\n            /* found based on destination port, so use dp registration */\n            pe1 = pp_port_dp->dp;\n        } else {\n            SCLogDebug(\"toclient - No probing parser registered for dest port %\"PRIu16, dp);\n        }\n\n        pp_port_sp = AppLayerProtoDetectGetProbingParsers(alpd_ctx.ctx_pp, ipproto, sp);\n        if (pp_port_sp != NULL) {\n            SCLogDebug(\"toclient - Probing parser found for source port %\"PRIu16, sp);\n\n            pe2 = pp_port_sp->sp;\n        } else {\n            SCLogDebug(\"toclient - No probing parser registered for source port %\"PRIu16, sp);\n        }\n    }\n\n    if (pe1 == NULL && pe2 == NULL) {\n        SCLogDebug(\"%s - No probing parsers found for either port\",\n                (direction & STREAM_TOSERVER) ? \"toserver\":\"toclient\");\n        FLOW_SET_PP_DONE(f, direction);\n        goto end;\n    }\n\n    /* run the parser(s) */\n    pe = pe1;\n    while (pe != NULL) {\n        if ((buflen < pe->min_depth)  ||\n            (alproto_masks[0] & pe->alproto_mask)) {\n            pe = pe->next;\n            continue;\n        }\n\n        if (direction & STREAM_TOSERVER && pe->ProbingParserTs != NULL) {\n            alproto = pe->ProbingParserTs(f, buf, buflen);\n        } else if (pe->ProbingParserTc != NULL) {\n            alproto = pe->ProbingParserTc(f, buf, buflen);\n        }\n        if (alproto != ALPROTO_UNKNOWN && alproto != ALPROTO_FAILED)\n            goto end;\n        if (alproto == ALPROTO_FAILED ||\n            (pe->max_depth != 0 && buflen > pe->max_depth)) {\n            alproto_masks[0] |= pe->alproto_mask;\n        }\n        pe = pe->next;\n    }\n    pe = pe2;\n    while (pe != NULL) {\n        if ((buflen < pe->min_depth)  ||\n            (alproto_masks[0] & pe->alproto_mask)) {\n            pe = pe->next;\n            continue;\n        }\n\n        if (direction & STREAM_TOSERVER && pe->ProbingParserTs != NULL) {\n            alproto = pe->ProbingParserTs(f, buf, buflen);\n        } else if (pe->ProbingParserTc != NULL) {\n            alproto = pe->ProbingParserTc(f, buf, buflen);\n        }\n        if (alproto != ALPROTO_UNKNOWN && alproto != ALPROTO_FAILED)\n            goto end;\n        if (alproto == ALPROTO_FAILED ||\n            (pe->max_depth != 0 && buflen > pe->max_depth)) {\n            alproto_masks[0] |= pe->alproto_mask;\n        }\n        pe = pe->next;\n    }\n\n    /* get the mask we need for this direction */\n    if (pp_port_dp && pp_port_sp)\n        mask = pp_port_dp->alproto_mask|pp_port_sp->alproto_mask;\n    else if (pp_port_dp)\n        mask = pp_port_dp->alproto_mask;\n    else if (pp_port_sp)\n        mask = pp_port_sp->alproto_mask;\n\n    if (alproto_masks[0] == mask) {\n        FLOW_SET_PP_DONE(f, direction);\n        SCLogDebug(\"%s, mask is now %08x, needed %08x, so done\",\n                (direction & STREAM_TOSERVER) ? \"toserver\":\"toclient\", alproto_masks[0], mask);\n    } else {\n        SCLogDebug(\"%s, mask is now %08x, need %08x\",\n                (direction & STREAM_TOSERVER) ? \"toserver\":\"toclient\", alproto_masks[0], mask);\n    }\n\n end:\n    SCLogDebug(\"%s, mask is now %08x\",\n            (direction & STREAM_TOSERVER) ? \"toserver\":\"toclient\", alproto_masks[0]);\n    SCReturnUInt(alproto);\n}\n", "target": 0, "idx": 96489}
{"func": "    FinishCompleteLoginParams::~FinishCompleteLoginParams() {}\n", "target": 0, "idx": 156006}
{"func": "void RenderWidgetHostImpl::DidNavigate(uint32_t next_source_id) {\n  current_content_source_id_ = next_source_id;\n  did_receive_first_frame_after_navigation_ = false;\n\n  if (enable_surface_synchronization_) {\n     visual_properties_ack_pending_ = false;\n    viz::LocalSurfaceId old_surface_id = view_->GetLocalSurfaceId();\n     if (view_)\n       view_->DidNavigate();\n    viz::LocalSurfaceId new_surface_id = view_->GetLocalSurfaceId();\n    if (old_surface_id == new_surface_id)\n      return;\n   } else {\n    if (last_received_content_source_id_ >= current_content_source_id_)\n      return;\n  }\n\n  if (!new_content_rendering_timeout_)\n    return;\n\n  new_content_rendering_timeout_->Start(new_content_rendering_delay_);\n}\n", "target": 1, "idx": 186631}
{"func": "static int tun_set_iff(struct net *net, struct file *file, struct ifreq *ifr)\n{\n\tstruct tun_struct *tun;\n\tstruct tun_file *tfile = file->private_data;\n\tstruct net_device *dev;\n\tint err;\n\n\tif (tfile->detached)\n\t\treturn -EINVAL;\n\n\tdev = __dev_get_by_name(net, ifr->ifr_name);\n\tif (dev) {\n\t\tif (ifr->ifr_flags & IFF_TUN_EXCL)\n\t\t\treturn -EBUSY;\n\t\tif ((ifr->ifr_flags & IFF_TUN) && dev->netdev_ops == &tun_netdev_ops)\n\t\t\ttun = netdev_priv(dev);\n\t\telse if ((ifr->ifr_flags & IFF_TAP) && dev->netdev_ops == &tap_netdev_ops)\n\t\t\ttun = netdev_priv(dev);\n\t\telse\n\t\t\treturn -EINVAL;\n\n\t\tif (!!(ifr->ifr_flags & IFF_MULTI_QUEUE) !=\n\t\t    !!(tun->flags & IFF_MULTI_QUEUE))\n\t\t\treturn -EINVAL;\n\n\t\tif (tun_not_capable(tun))\n\t\t\treturn -EPERM;\n\t\terr = security_tun_dev_open(tun->security);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = tun_attach(tun, file, ifr->ifr_flags & IFF_NOFILTER);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (tun->flags & IFF_MULTI_QUEUE &&\n\t\t    (tun->numqueues + tun->numdisabled > 1)) {\n\t\t\t/* One or more queue has already been attached, no need\n\t\t\t * to initialize the device again.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\telse {\n\t\tchar *name;\n\t\tunsigned long flags = 0;\n\t\tint queues = ifr->ifr_flags & IFF_MULTI_QUEUE ?\n\t\t\t     MAX_TAP_QUEUES : 1;\n\n\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\terr = security_tun_dev_create();\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t/* Set dev type */\n\t\tif (ifr->ifr_flags & IFF_TUN) {\n\t\t\t/* TUN device */\n\t\t\tflags |= IFF_TUN;\n\t\t\tname = \"tun%d\";\n\t\t} else if (ifr->ifr_flags & IFF_TAP) {\n\t\t\t/* TAP device */\n\t\t\tflags |= IFF_TAP;\n\t\t\tname = \"tap%d\";\n\t\t} else\n\t\t\treturn -EINVAL;\n\n\t\tif (*ifr->ifr_name)\n\t\t\tname = ifr->ifr_name;\n\n\t\tdev = alloc_netdev_mqs(sizeof(struct tun_struct), name,\n\t\t\t\t       NET_NAME_UNKNOWN, tun_setup, queues,\n\t\t\t\t       queues);\n\n \t\tif (!dev)\n \t\t\treturn -ENOMEM;\n \t\terr = dev_get_valid_name(net, dev, name);\n\t\tif (err)\n \t\t\tgoto err_free_dev;\n \n \t\tdev_net_set(dev, net);\n\t\tdev->rtnl_link_ops = &tun_link_ops;\n\t\tdev->ifindex = tfile->ifindex;\n\t\tdev->sysfs_groups[0] = &tun_attr_group;\n\n\t\ttun = netdev_priv(dev);\n\t\ttun->dev = dev;\n\t\ttun->flags = flags;\n\t\ttun->txflt.count = 0;\n\t\ttun->vnet_hdr_sz = sizeof(struct virtio_net_hdr);\n\n\t\ttun->align = NET_SKB_PAD;\n\t\ttun->filter_attached = false;\n\t\ttun->sndbuf = tfile->socket.sk->sk_sndbuf;\n\t\ttun->rx_batched = 0;\n\n\t\ttun->pcpu_stats = netdev_alloc_pcpu_stats(struct tun_pcpu_stats);\n\t\tif (!tun->pcpu_stats) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_free_dev;\n\t\t}\n\n\t\tspin_lock_init(&tun->lock);\n\n\t\terr = security_tun_dev_alloc_security(&tun->security);\n\t\tif (err < 0)\n\t\t\tgoto err_free_stat;\n\n\t\ttun_net_init(dev);\n\t\ttun_flow_init(tun);\n\n\t\tdev->hw_features = NETIF_F_SG | NETIF_F_FRAGLIST |\n\t\t\t\t   TUN_USER_FEATURES | NETIF_F_HW_VLAN_CTAG_TX |\n\t\t\t\t   NETIF_F_HW_VLAN_STAG_TX;\n\t\tdev->features = dev->hw_features | NETIF_F_LLTX;\n\t\tdev->vlan_features = dev->features &\n\t\t\t\t     ~(NETIF_F_HW_VLAN_CTAG_TX |\n\t\t\t\t       NETIF_F_HW_VLAN_STAG_TX);\n\n\t\tINIT_LIST_HEAD(&tun->disabled);\n\t\terr = tun_attach(tun, file, false);\n\t\tif (err < 0)\n\t\t\tgoto err_free_flow;\n\n\t\terr = register_netdevice(tun->dev);\n\t\tif (err < 0)\n\t\t\tgoto err_detach;\n\t}\n\n\tnetif_carrier_on(tun->dev);\n\n\ttun_debug(KERN_INFO, tun, \"tun_set_iff\\n\");\n\n\ttun->flags = (tun->flags & ~TUN_FEATURES) |\n\t\t(ifr->ifr_flags & TUN_FEATURES);\n\n\t/* Make sure persistent devices do not get stuck in\n\t * xoff state.\n\t */\n\tif (netif_running(tun->dev))\n\t\tnetif_tx_wake_all_queues(tun->dev);\n\n\tstrcpy(ifr->ifr_name, tun->dev->name);\n\treturn 0;\n\nerr_detach:\n\ttun_detach_all(dev);\n\t/* register_netdevice() already called tun_free_netdev() */\n\tgoto err_free_dev;\n\nerr_free_flow:\n\ttun_flow_uninit(tun);\n\tsecurity_tun_dev_free_security(tun->security);\nerr_free_stat:\n\tfree_percpu(tun->pcpu_stats);\nerr_free_dev:\n\tfree_netdev(dev);\n\treturn err;\n}\n", "target": 1, "idx": 183419}
{"func": "RenderProcessHostImpl::TakeMetricsAllocator() {\n  return std::move(metrics_allocator_);\n}\n", "target": 0, "idx": 139229}
{"func": "gpgsm_reset (void *engine)\n{\n  engine_gpgsm_t gpgsm = engine;\n\n  /* IF we have an active connection we must send a reset because we\n     need to reset the list of signers.  Note that RESET does not\n     reset OPTION commands. */\n  return (gpgsm->assuan_ctx\n          ? gpgsm_assuan_simple_command (gpgsm->assuan_ctx, \"RESET\",\n                                         NULL, NULL)\n          : 0);\n}\n", "target": 0, "idx": 12280}
{"func": "void UkmPageLoadMetricsObserver::RecordTimingMetrics(\n     const page_load_metrics::mojom::PageLoadTiming& timing,\n     const page_load_metrics::PageLoadExtraInfo& info) {\n   ukm::builders::PageLoad builder(info.source_id);\n  bool is_user_initiated_navigation =\n      info.user_initiated_info.browser_initiated ||\n      timing.input_to_navigation_start;\n  builder.SetExperimental_Navigation_UserInitiated(\n      is_user_initiated_navigation);\n   if (timing.input_to_navigation_start) {\n     builder.SetExperimental_InputToNavigationStart(\n         timing.input_to_navigation_start.value().InMilliseconds());\n  }\n  if (timing.parse_timing->parse_start) {\n    builder.SetParseTiming_NavigationToParseStart(\n        timing.parse_timing->parse_start.value().InMilliseconds());\n  }\n  if (timing.document_timing->dom_content_loaded_event_start) {\n    builder.SetDocumentTiming_NavigationToDOMContentLoadedEventFired(\n        timing.document_timing->dom_content_loaded_event_start.value()\n            .InMilliseconds());\n  }\n  if (timing.document_timing->load_event_start) {\n    builder.SetDocumentTiming_NavigationToLoadEventFired(\n        timing.document_timing->load_event_start.value().InMilliseconds());\n  }\n  if (timing.paint_timing->first_paint) {\n    builder.SetPaintTiming_NavigationToFirstPaint(\n        timing.paint_timing->first_paint.value().InMilliseconds());\n  }\n  if (timing.paint_timing->first_contentful_paint) {\n    builder.SetPaintTiming_NavigationToFirstContentfulPaint(\n        timing.paint_timing->first_contentful_paint.value().InMilliseconds());\n  }\n  if (timing.paint_timing->first_meaningful_paint) {\n    builder.SetExperimental_PaintTiming_NavigationToFirstMeaningfulPaint(\n        timing.paint_timing->first_meaningful_paint.value().InMilliseconds());\n  }\n  if (timing.paint_timing->largest_image_paint.has_value() &&\n      WasStartedInForegroundOptionalEventInForeground(\n          timing.paint_timing->largest_image_paint, info)) {\n    builder.SetExperimental_PaintTiming_NavigationToLargestImagePaint(\n        timing.paint_timing->largest_image_paint.value().InMilliseconds());\n  }\n  if (timing.paint_timing->last_image_paint.has_value() &&\n      WasStartedInForegroundOptionalEventInForeground(\n          timing.paint_timing->last_image_paint, info)) {\n    builder.SetExperimental_PaintTiming_NavigationToLastImagePaint(\n        timing.paint_timing->last_image_paint.value().InMilliseconds());\n  }\n  if (timing.paint_timing->largest_text_paint.has_value() &&\n      WasStartedInForegroundOptionalEventInForeground(\n          timing.paint_timing->largest_text_paint, info)) {\n    builder.SetExperimental_PaintTiming_NavigationToLargestTextPaint(\n        timing.paint_timing->largest_text_paint.value().InMilliseconds());\n  }\n  if (timing.paint_timing->last_text_paint.has_value() &&\n      WasStartedInForegroundOptionalEventInForeground(\n          timing.paint_timing->last_text_paint, info)) {\n    builder.SetExperimental_PaintTiming_NavigationToLastTextPaint(\n        timing.paint_timing->last_text_paint.value().InMilliseconds());\n  }\n  base::Optional<base::TimeDelta> largest_content_paint_time;\n  uint64_t largest_content_paint_size;\n  AssignTimeAndSizeForLargestContentfulPaint(largest_content_paint_time,\n                                             largest_content_paint_size,\n                                             timing.paint_timing);\n  if (largest_content_paint_size > 0 &&\n      WasStartedInForegroundOptionalEventInForeground(\n          largest_content_paint_time, info)) {\n    builder.SetExperimental_PaintTiming_NavigationToLargestContentPaint(\n        largest_content_paint_time.value().InMilliseconds());\n  }\n  if (timing.interactive_timing->interactive) {\n    base::TimeDelta time_to_interactive =\n        timing.interactive_timing->interactive.value();\n    if (!timing.interactive_timing->first_invalidating_input ||\n        timing.interactive_timing->first_invalidating_input.value() >\n            time_to_interactive) {\n      builder.SetExperimental_NavigationToInteractive(\n          time_to_interactive.InMilliseconds());\n    }\n  }\n  if (timing.interactive_timing->first_input_delay) {\n    base::TimeDelta first_input_delay =\n        timing.interactive_timing->first_input_delay.value();\n    builder.SetInteractiveTiming_FirstInputDelay2(\n        first_input_delay.InMilliseconds());\n  }\n  if (timing.interactive_timing->first_input_timestamp) {\n    base::TimeDelta first_input_timestamp =\n        timing.interactive_timing->first_input_timestamp.value();\n    builder.SetInteractiveTiming_FirstInputTimestamp2(\n        first_input_timestamp.InMilliseconds());\n  }\n\n  if (timing.interactive_timing->longest_input_delay) {\n    base::TimeDelta longest_input_delay =\n        timing.interactive_timing->longest_input_delay.value();\n    builder.SetInteractiveTiming_LongestInputDelay2(\n        longest_input_delay.InMilliseconds());\n  }\n  if (timing.interactive_timing->longest_input_timestamp) {\n    base::TimeDelta longest_input_timestamp =\n        timing.interactive_timing->longest_input_timestamp.value();\n    builder.SetInteractiveTiming_LongestInputTimestamp2(\n        longest_input_timestamp.InMilliseconds());\n  }\n\n  builder.SetNet_CacheBytes(ukm::GetExponentialBucketMin(cache_bytes_, 1.3));\n  builder.SetNet_NetworkBytes(\n      ukm::GetExponentialBucketMin(network_bytes_, 1.3));\n\n  if (main_frame_timing_)\n    ReportMainResourceTimingMetrics(timing, &builder);\n\n  builder.Record(ukm::UkmRecorder::Get());\n}\n", "target": 1, "idx": 186466}
{"func": "void V8TestObject::Uint8ArrayMethodMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), \"Blink_TestObject_uint8ArrayMethod\");\n\n  test_object_v8_internal::Uint8ArrayMethodMethod(info);\n}\n", "target": 0, "idx": 147945}
{"func": "void PrintWebViewHelper::ShowScriptedPrintPreview() {\n  if (is_scripted_preview_delayed_) {\n    is_scripted_preview_delayed_ = false;\n    Send(new PrintHostMsg_ShowScriptedPrintPreview(\n        routing_id(), print_preview_context_.IsModifiable()));\n  }\n}\n", "target": 0, "idx": 137577}
{"func": "my_object_str_hash_len (MyObject *obj, GHashTable *table, guint *len, GError **error)\n{\n  *len = 0;\n  g_hash_table_foreach (table, hash_foreach, len);\n  return TRUE;\n}\n", "target": 1, "idx": 178293}
{"func": " static void copyStereo8(\n         short *dst,\n        const int *const *src,\n         unsigned nSamples,\n         unsigned /* nChannels */) {\n     for (unsigned i = 0; i < nSamples; ++i) {\n *dst++ = src[0][i] << 8;\n *dst++ = src[1][i] << 8;\n\n     }\n }\n", "target": 1, "idx": 188045}
{"func": "void SyncBackendHost::Core::DoShutdown(bool sync_disabled) {\n  DCHECK(MessageLoop::current() == host_->core_thread_.message_loop());\n\n  save_changes_timer_.Stop();\n  syncapi_->Shutdown();  // Stops the SyncerThread.\n  syncapi_->RemoveObserver(this);\n  DisconnectChildJsEventRouter();\n  host_->ui_worker()->OnSyncerShutdownComplete();\n\n  if (sync_disabled)\n    DeleteSyncDataFolder();\n\n  host_ = NULL;\n}\n", "target": 0, "idx": 106309}
{"func": "void V8TestObject::SizeAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), \"Blink_TestObject_size_Getter\");\n\n  test_object_v8_internal::SizeAttributeGetter(info);\n}\n", "target": 0, "idx": 147851}
{"func": "int register_socket(int in, int out, struct sockaddr *addr, struct sockaddr *mask, void (*cb)(int sd))\n{\n\tstruct ifsock *ifs;\n\tstruct sockaddr_in *address = (struct sockaddr_in *)addr;\n\tstruct sockaddr_in *netmask = (struct sockaddr_in *)mask;\n\n\tifs = calloc(1, sizeof(*ifs));\n\tif (!ifs) {\n\t\tchar *host = inet_ntoa(address->sin_addr);\n\n\t\tlogit(LOG_ERR, \"Failed registering host %s socket: %s\", host, strerror(errno));\n\t\treturn -1;\n\t}\n\n\tifs->in   = in;\n\tifs->out  = out;\n\tifs->mod  = 1;\n\tifs->cb   = cb;\n\tifs->addr = *address;\n\tif (mask)\n\t\tifs->mask = *netmask;\n\tLIST_INSERT_HEAD(&il, ifs, link);\n\n\treturn 0;\n}\n", "target": 0, "idx": 88805}
{"func": "static void PNGType(png_bytep p,const png_byte *type)\n{\n  (void) memcpy(p,type,4*sizeof(png_byte));\n}\n", "target": 0, "idx": 77942}
{"func": "void FS_ClearPakReferences( int flags ) {\n\tsearchpath_t *search;\n\n\tif ( !flags ) {\n\t\tflags = -1;\n\t}\n\tfor ( search = fs_searchpaths; search; search = search->next ) {\n\t\tif ( search->pack ) {\n\t\t\tsearch->pack->referenced &= ~flags;\n\t\t}\n\t}\n}\n", "target": 0, "idx": 95762}
{"func": " void TranslateInfoBarBase::Layout() {\n  InfoBar::Layout();\n \n   gfx::Size icon_ps = icon_->GetPreferredSize();\n  icon_->SetBounds(InfoBar::kHorizontalPadding, InfoBar::OffsetY(this, icon_ps),\n      icon_ps.width(), icon_ps.height());\n }\n", "target": 1, "idx": 184199}
{"func": "string16 ExtensionGlobalError::GenerateMessageSection(\n    const ExtensionIdSet* extensions,\n    int template_message_id) {\n  CHECK(extensions);\n  CHECK(template_message_id);\n  string16 message;\n\n   for (ExtensionIdSet::const_iterator iter = extensions->begin();\n        iter != extensions->end(); ++iter) {\n     const Extension* e = extension_service_->GetExtensionById(*iter, true);\n    message += l10n_util::GetStringFUTF16(\n        template_message_id,\n        string16(ASCIIToUTF16(e->name())),\n        l10n_util::GetStringUTF16(IDS_SHORT_PRODUCT_NAME));\n   }\n   return message;\n }\n", "target": 1, "idx": 184672}
{"func": "GesturePoint::GesturePoint()\n     : first_touch_time_(0.0),\n       last_touch_time_(0.0),\n       last_tap_time_(0.0),\n      velocity_calculator_(kBufferedPoints) {\n }\n", "target": 1, "idx": 184733}
{"func": "void xdr_init_encode(struct xdr_stream *xdr, struct xdr_buf *buf, __be32 *p)\n{\n\tstruct kvec *iov = buf->head;\n\tint scratch_len = buf->buflen - buf->page_len - buf->tail[0].iov_len;\n\n\tBUG_ON(scratch_len < 0);\n\txdr->buf = buf;\n\txdr->iov = iov;\n\txdr->p = (__be32 *)((char *)iov->iov_base + iov->iov_len);\n\txdr->end = (__be32 *)((char *)iov->iov_base + scratch_len);\n\tBUG_ON(iov->iov_len > scratch_len);\n\n\tif (p != xdr->p && p != NULL) {\n\t\tsize_t len;\n\n\t\tBUG_ON(p < xdr->p || p > xdr->end);\n\t\tlen = (char *)p - (char *)xdr->p;\n\t\txdr->p = p;\n\t\tbuf->len += len;\n\t\tiov->iov_len += len;\n\t}\n}\n", "target": 0, "idx": 23529}
{"func": "PHP_FUNCTION(mb_ereg_replace)\n{\n\t_php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0, 0);\n}\n", "target": 0, "idx": 51378}
{"func": "void RenderBox::panScroll(const IntPoint& source)\n{\n    if (layer())\n        layer()->panScrollFromPoint(source);\n}\n", "target": 0, "idx": 106912}
{"func": "local_wcsnlen (const wchar_t *s, size_t maxlen)\n{\n  const wchar_t *ptr;\n\n  for (ptr = s; maxlen > 0 && *ptr != (wchar_t) 0; ptr++, maxlen--)\n    ;\n  return ptr - s;\n}\n", "target": 0, "idx": 76543}
{"func": "n_tty_receive_buf_closing(struct tty_struct *tty, const unsigned char *cp,\n\t\t\t  char *fp, int count)\n{\n\tchar flag = TTY_NORMAL;\n\n\twhile (count--) {\n\t\tif (fp)\n\t\t\tflag = *fp++;\n\t\tif (likely(flag == TTY_NORMAL))\n\t\t\tn_tty_receive_char_closing(tty, *cp++);\n\t\telse\n\t\t\tn_tty_receive_char_flagged(tty, *cp++, flag);\n\t}\n}\n", "target": 0, "idx": 39813}
{"func": "int rds_sendmsg(struct socket *sock, struct msghdr *msg, size_t payload_len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rds_sock *rs = rds_sk_to_rs(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_in *, usin, msg->msg_name);\n\t__be32 daddr;\n\t__be16 dport;\n\tstruct rds_message *rm = NULL;\n\tstruct rds_connection *conn;\n\tint ret = 0;\n\tint queued = 0, allocated_mr = 0;\n\tint nonblock = msg->msg_flags & MSG_DONTWAIT;\n\tlong timeo = sock_sndtimeo(sk, nonblock);\n\n\t/* Mirror Linux UDP mirror of BSD error message compatibility */\n\t/* XXX: Perhaps MSG_MORE someday */\n\tif (msg->msg_flags & ~(MSG_DONTWAIT | MSG_CMSG_COMPAT)) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tif (msg->msg_namelen) {\n\t\t/* XXX fail non-unicast destination IPs? */\n\t\tif (msg->msg_namelen < sizeof(*usin) || usin->sin_family != AF_INET) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tdaddr = usin->sin_addr.s_addr;\n\t\tdport = usin->sin_port;\n\t} else {\n\t\t/* We only care about consistency with ->connect() */\n\t\tlock_sock(sk);\n\t\tdaddr = rs->rs_conn_addr;\n\t\tdport = rs->rs_conn_port;\n \t\trelease_sock(sk);\n \t}\n \n\t/* racing with another thread binding seems ok here */\n \tif (daddr == 0 || rs->rs_bound_addr == 0) {\n \t\tret = -ENOTCONN; /* XXX not a great errno */\n \t\tgoto out;\n \t}\n \n \tif (payload_len > rds_sk_sndbuf(rs)) {\n \t\tret = -EMSGSIZE;\n\t\tgoto out;\n\t}\n\n\t/* size of rm including all sgs */\n\tret = rds_rm_size(msg, payload_len);\n\tif (ret < 0)\n\t\tgoto out;\n\n\trm = rds_message_alloc(ret, GFP_KERNEL);\n\tif (!rm) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/* Attach data to the rm */\n\tif (payload_len) {\n\t\trm->data.op_sg = rds_message_alloc_sgs(rm, ceil(payload_len, PAGE_SIZE));\n\t\tif (!rm->data.op_sg) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = rds_message_copy_from_user(rm, &msg->msg_iter);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\trm->data.op_active = 1;\n\n\trm->m_daddr = daddr;\n\n\t/* rds_conn_create has a spinlock that runs with IRQ off.\n\t * Caching the conn in the socket helps a lot. */\n\tif (rs->rs_conn && rs->rs_conn->c_faddr == daddr)\n\t\tconn = rs->rs_conn;\n\telse {\n\t\tconn = rds_conn_create_outgoing(sock_net(sock->sk),\n\t\t\t\t\t\trs->rs_bound_addr, daddr,\n\t\t\t\t\trs->rs_transport,\n\t\t\t\t\tsock->sk->sk_allocation);\n\t\tif (IS_ERR(conn)) {\n\t\t\tret = PTR_ERR(conn);\n\t\t\tgoto out;\n\t\t}\n\t\trs->rs_conn = conn;\n\t}\n\n\t/* Parse any control messages the user may have included. */\n\tret = rds_cmsg_send(rs, rm, msg, &allocated_mr);\n\tif (ret)\n\t\tgoto out;\n\n\tif (rm->rdma.op_active && !conn->c_trans->xmit_rdma) {\n\t\tprintk_ratelimited(KERN_NOTICE \"rdma_op %p conn xmit_rdma %p\\n\",\n\t\t\t       &rm->rdma, conn->c_trans->xmit_rdma);\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tif (rm->atomic.op_active && !conn->c_trans->xmit_atomic) {\n\t\tprintk_ratelimited(KERN_NOTICE \"atomic_op %p conn xmit_atomic %p\\n\",\n\t\t\t       &rm->atomic, conn->c_trans->xmit_atomic);\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\trds_conn_connect_if_down(conn);\n\n\tret = rds_cong_wait(conn->c_fcong, dport, nonblock, rs);\n\tif (ret) {\n\t\trs->rs_seen_congestion = 1;\n\t\tgoto out;\n\t}\n\n\twhile (!rds_send_queue_rm(rs, conn, rm, rs->rs_bound_port,\n\t\t\t\t  dport, &queued)) {\n\t\trds_stats_inc(s_send_queue_full);\n\n\t\tif (nonblock) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\n\t\ttimeo = wait_event_interruptible_timeout(*sk_sleep(sk),\n\t\t\t\t\trds_send_queue_rm(rs, conn, rm,\n\t\t\t\t\t\t\t  rs->rs_bound_port,\n\t\t\t\t\t\t\t  dport,\n\t\t\t\t\t\t\t  &queued),\n\t\t\t\t\ttimeo);\n\t\trdsdebug(\"sendmsg woke queued %d timeo %ld\\n\", queued, timeo);\n\t\tif (timeo > 0 || timeo == MAX_SCHEDULE_TIMEOUT)\n\t\t\tcontinue;\n\n\t\tret = timeo;\n\t\tif (ret == 0)\n\t\t\tret = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * By now we've committed to the send.  We reuse rds_send_worker()\n\t * to retry sends in the rds thread if the transport asks us to.\n\t */\n\trds_stats_inc(s_send_queued);\n\n\tret = rds_send_xmit(conn);\n\tif (ret == -ENOMEM || ret == -EAGAIN)\n\t\tqueue_delayed_work(rds_wq, &conn->c_send_w, 1);\n\n\trds_message_put(rm);\n\treturn payload_len;\n\nout:\n\t/* If the user included a RDMA_MAP cmsg, we allocated a MR on the fly.\n\t * If the sendmsg goes through, we keep the MR. If it fails with EAGAIN\n\t * or in any other way, we need to destroy the MR again */\n\tif (allocated_mr)\n\t\trds_rdma_unuse(rs, rds_rdma_cookie_key(rm->m_rdma_cookie), 1);\n\n\tif (rm)\n\t\trds_message_put(rm);\n\treturn ret;\n}\n", "target": 1, "idx": 179745}
{"func": "MagickExport MagickBooleanType IsMonochromeImage(const Image *image,\n  ExceptionInfo *exception)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->type == BilevelType)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n", "target": 0, "idx": 73384}
{"func": "void XSSAuditor::init(Document* document, XSSAuditorDelegate* auditorDelegate)\n{\n    const size_t miniumLengthForSuffixTree = 512; // FIXME: Tune this parameter.\n    const int suffixTreeDepth = 5;\n\n    ASSERT(isMainThread());\n    if (m_state != Uninitialized)\n        return;\n    m_state = FilteringTokens;\n\n    if (Settings* settings = document->settings())\n        m_isEnabled = settings->xssAuditorEnabled();\n\n    if (!m_isEnabled)\n        return;\n\n    m_documentURL = document->url().copy();\n\n    if (!document->frame()) {\n        m_isEnabled = false;\n        return;\n    }\n\n    if (m_documentURL.isEmpty()) {\n        m_isEnabled = false;\n        return;\n    }\n\n    if (m_documentURL.protocolIsData()) {\n        m_isEnabled = false;\n        return;\n    }\n\n    if (document->encoding().isValid())\n        m_encoding = document->encoding();\n\n    m_decodedURL = fullyDecodeString(m_documentURL.string(), m_encoding);\n    if (m_decodedURL.find(isRequiredForInjection) == kNotFound)\n        m_decodedURL = String();\n\n    String httpBodyAsString;\n    if (DocumentLoader* documentLoader = document->frame()->loader().documentLoader()) {\n        DEFINE_STATIC_LOCAL(const AtomicString, XSSProtectionHeader, (\"X-XSS-Protection\", AtomicString::ConstructFromLiteral));\n        const AtomicString& headerValue = documentLoader->response().httpHeaderField(XSSProtectionHeader);\n        String errorDetails;\n        unsigned errorPosition = 0;\n        String reportURL;\n        KURL xssProtectionReportURL;\n\n        ReflectedXSSDisposition xssProtectionHeader = parseXSSProtectionHeader(headerValue, errorDetails, errorPosition, reportURL);\n        m_didSendValidXSSProtectionHeader = xssProtectionHeader != ReflectedXSSUnset && xssProtectionHeader != ReflectedXSSInvalid;\n        if ((xssProtectionHeader == FilterReflectedXSS || xssProtectionHeader == BlockReflectedXSS) && !reportURL.isEmpty()) {\n            xssProtectionReportURL = document->completeURL(reportURL);\n            if (MixedContentChecker::isMixedContent(document->securityOrigin(), xssProtectionReportURL)) {\n                errorDetails = \"insecure reporting URL for secure page\";\n                xssProtectionHeader = ReflectedXSSInvalid;\n                xssProtectionReportURL = KURL();\n            }\n        }\n        if (xssProtectionHeader == ReflectedXSSInvalid)\n            document->addConsoleMessage(SecurityMessageSource, ErrorMessageLevel, \"Error parsing header X-XSS-Protection: \" + headerValue + \": \"  + errorDetails + \" at character position \" + String::format(\"%u\", errorPosition) + \". The default protections will be applied.\");\n\n        ReflectedXSSDisposition cspHeader = document->contentSecurityPolicy()->reflectedXSSDisposition();\n        m_didSendValidCSPHeader = cspHeader != ReflectedXSSUnset && cspHeader != ReflectedXSSInvalid;\n\n        m_xssProtection = combineXSSProtectionHeaderAndCSP(xssProtectionHeader, cspHeader);\n         if (auditorDelegate)\n             auditorDelegate->setReportURL(xssProtectionReportURL.copy());\n        FormData* httpBody = documentLoader->originalRequest().httpBody();\n         if (httpBody && !httpBody->isEmpty()) {\n             httpBodyAsString = httpBody->flattenToString();\n             if (!httpBodyAsString.isEmpty()) {\n                m_decodedHTTPBody = fullyDecodeString(httpBodyAsString, m_encoding);\n                if (m_decodedHTTPBody.find(isRequiredForInjection) == kNotFound)\n                    m_decodedHTTPBody = String();\n                if (m_decodedHTTPBody.length() >= miniumLengthForSuffixTree)\n                    m_decodedHTTPBodySuffixTree = adoptPtr(new SuffixTree<ASCIICodebook>(m_decodedHTTPBody, suffixTreeDepth));\n            }\n        }\n    }\n\n    if (m_decodedURL.isEmpty() && m_decodedHTTPBody.isEmpty()) {\n        m_isEnabled = false;\n        return;\n    }\n}\n", "target": 1, "idx": 185538}
{"func": "pvscsi_init_msi(PVSCSIState *s)\n{\n    int res;\n    PCIDevice *d = PCI_DEVICE(s);\n\n    res = msi_init(d, PVSCSI_MSI_OFFSET(s), PVSCSI_MSIX_NUM_VECTORS,\n                   PVSCSI_USE_64BIT, PVSCSI_PER_VECTOR_MASK, NULL);\n    if (res < 0) {\n        trace_pvscsi_init_msi_fail(res);\n        s->msi_used = false;\n    } else {\n        s->msi_used = true;\n    }\n}\n", "target": 0, "idx": 8416}
{"func": "int lxc_clear_environment(struct lxc_conf *c)\n{\n\tstruct lxc_list *it,*next;\n\n\tlxc_list_for_each_safe(it, &c->environment, next) {\n\t\tlxc_list_del(it);\n\t\tfree(it->elem);\n\t\tfree(it);\n\t}\n\treturn 0;\n}\n", "target": 0, "idx": 44585}
{"func": "cmsBool  Type_MLU_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsMLU* mlu =(cmsMLU*) Ptr;\n    cmsUInt32Number HeaderSize;\n    cmsUInt32Number  Len, Offset;\n    cmsUInt32Number i;\n\n    if (Ptr == NULL) {\n\n          if (!_cmsWriteUInt32Number(io, 0)) return FALSE;\n          if (!_cmsWriteUInt32Number(io, 12)) return FALSE;\n          return TRUE;\n    }\n\n    if (!_cmsWriteUInt32Number(io, mlu ->UsedEntries)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, 12)) return FALSE;\n\n    HeaderSize = 12 * mlu ->UsedEntries + sizeof(_cmsTagBase);\n\n    for (i=0; i < mlu ->UsedEntries; i++) {\n\n        Len    =  mlu ->Entries[i].Len;\n        Offset =  mlu ->Entries[i].StrW;\n\n        Len    = (Len * sizeof(cmsUInt16Number)) / sizeof(wchar_t);\n        Offset = (Offset * sizeof(cmsUInt16Number)) / sizeof(wchar_t) + HeaderSize + 8;\n\n        if (!_cmsWriteUInt16Number(io, mlu ->Entries[i].Language)) return FALSE;\n        if (!_cmsWriteUInt16Number(io, mlu ->Entries[i].Country))  return FALSE;\n        if (!_cmsWriteUInt32Number(io, Len)) return FALSE;\n        if (!_cmsWriteUInt32Number(io, Offset)) return FALSE;\n    }\n\n    if (!_cmsWriteWCharArray(io, mlu ->PoolUsed / sizeof(wchar_t), (wchar_t*)  mlu ->MemPool)) return FALSE;\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n    cmsUNUSED_PARAMETER(self);\n}\n", "target": 0, "idx": 71013}
{"func": " int res_inverse(vorbis_dsp_state *vd,vorbis_info_residue *info,\n\t\togg_int32_t **in,int *nonzero,int ch){\n \n   int i,j,k,s,used=0;\n   codec_setup_info     *ci=(codec_setup_info *)vd->vi->codec_setup;\n  codebook *phrasebook=ci->book_param+info->groupbook;\n int samples_per_partition=info->grouping;\n int partitions_per_word=phrasebook->dim;\n int pcmend=ci->blocksizes[vd->W];\n\n if(info->type<2){\n int max=pcmend>>1;\n int end=(info->end<max?info->end:max);\n int n=end-info->begin;\n\n if(n>0){\n int partvals=n/samples_per_partition;\n\n       int partwords=(partvals+partitions_per_word-1)/partitions_per_word;\n \n       for(i=0;i<ch;i++)\n\tif(nonzero[i])\n\t  in[used++]=in[i];\n       ch=used;\n \n       if(used){\n \n\tchar **partword=(char **)alloca(ch*sizeof(*partword));\n\tfor(j=0;j<ch;j++)\n\t  partword[j]=(char *)alloca(partwords*partitions_per_word*\n\t\t\t\t     sizeof(*partword[j]));\n \n\tfor(s=0;s<info->stages;s++){\n \n\t  for(i=0;i<partvals;){\n\t    if(s==0){\n\t      /* fetch the partition word for each channel */\n \n\t      partword[0][i+partitions_per_word-1]=1;\n\t      for(k=partitions_per_word-2;k>=0;k--)\n\t\tpartword[0][i+k]=partword[0][i+k+1]*info->partitions;\n \n\t      for(j=1;j<ch;j++)\n\t\tfor(k=partitions_per_word-1;k>=0;k--)\n\t\t  partword[j][i+k]=partword[j-1][i+k];\n \n\t      for(j=0;j<ch;j++){\n\t\tint temp=vorbis_book_decode(phrasebook,&vd->opb);\n\t\tif(temp==-1)goto eopbreak;\n \n\t\t/* this can be done quickly in assembly due to the quotient\n\t\t   always being at most six bits */\n\t\tfor(k=0;k<partitions_per_word;k++){\n\t\t  ogg_uint32_t div=partword[j][i+k];\n\t\t  partword[j][i+k]=temp/div;\n\t\t  temp-=partword[j][i+k]*div;\n\t\t}\n \n\t      }\n\t    }\n \n\t    /* now we decode residual values for the partitions */\n\t    for(k=0;k<partitions_per_word && i<partvals;k++,i++)\n\t      for(j=0;j<ch;j++){\n\t\tlong offset=info->begin+i*samples_per_partition;\n\t\tif(info->stagemasks[(int)partword[j][i]]&(1<<s)){\n\t\t  codebook *stagebook=ci->book_param+\n\t\t    info->stagebooks[(partword[j][i]<<3)+s];\n\t\t  if(info->type){\n\t\t    if(vorbis_book_decodev_add(stagebook,in[j]+offset,&vd->opb,\n\t\t\t\t\t       samples_per_partition,-8)==-1)\n\t\t      goto eopbreak;\n\t\t  }else{\n\t\t    if(vorbis_book_decodevs_add(stagebook,in[j]+offset,&vd->opb,\n\t\t\t\t\t\tsamples_per_partition,-8)==-1)\n\t\t      goto eopbreak;\n\t\t  }\n\t\t}\n\t      }\n\t  }\n\t}\n       }\n     }\n   }else{\n int max=(pcmend*ch)>>1;\n int end=(info->end<max?info->end:max);\n int n=end-info->begin;\n\n if(n>0){\n int partvals=n/samples_per_partition;\n\n       int partwords=(partvals+partitions_per_word-1)/partitions_per_word;\n \n       char *partword=\n\t(char *)alloca(partwords*partitions_per_word*sizeof(*partword));\n       int beginoff=info->begin/ch;\n \n       for(i=0;i<ch;i++)if(nonzero[i])break;\n if(i==ch)return(0); /* no nonzero vectors */\n\n      samples_per_partition/=ch;\n\n for(s=0;s<info->stages;s++){\n for(i=0;i<partvals;){\n\n if(s==0){\n int temp;\n\t    partword[i+partitions_per_word-1]=1;\n for(k=partitions_per_word-2;k>=0;k--)\n\t      partword[i+k]=partword[i+k+1]*info->partitions;\n\n /* fetch the partition word */\n\t    temp=vorbis_book_decode(phrasebook,&vd->opb);\n if(temp==-1)goto eopbreak;\n\n /* this can be done quickly in assembly due to the quotient\n\t       always being at most six bits */\n for(k=0;k<partitions_per_word;k++){\n ogg_uint32_t div=partword[i+k];\n\t      partword[i+k]=temp/div;\n\t      temp-=partword[i+k]*div;\n }\n }\n\n /* now we decode residual values for the partitions */\n for(k=0;k<partitions_per_word && i<partvals;k++,i++)\n if(info->stagemasks[(int)partword[i]]&(1<<s)){\n\t      codebook *stagebook=ci->book_param+\n\t\tinfo->stagebooks[(partword[i]<<3)+s];\n if(vorbis_book_decodevv_add(stagebook,in,\n\t\t\t\t\t  i*samples_per_partition+beginoff,ch,\n &vd->opb,\n\t\t\t\t\t  samples_per_partition,-8)==-1)\n goto eopbreak;\n }\n }\n }\n }\n }\n eopbreak:\n\n return 0;\n}\n", "target": 1, "idx": 187583}
{"func": "void WebSettingsImpl::setExperimentalNotificationsEnabled(bool enabled)\n{\n    m_settings->setExperimentalNotificationsEnabled(enabled);\n}\n", "target": 1, "idx": 183620}
{"func": "void sum_update(const char *p, int32 len)\n{\n\tswitch (cursum_type) {\n\t  case CSUM_MD5:\n\t\tmd5_update(&md, (uchar *)p, len);\n\t\tbreak;\n          case CSUM_MD4:\n          case CSUM_MD4_OLD:\n          case CSUM_MD4_BUSTED:\n                if (len + sumresidue < CSUM_CHUNK) {\n                        memcpy(md.buffer + sumresidue, p, len);\n                        sumresidue += len;\n\t\t}\n\n\t\tif (sumresidue) {\n\t\t\tint32 i = CSUM_CHUNK - sumresidue;\n\t\t\tmemcpy(md.buffer + sumresidue, p, i);\n\t\t\tmdfour_update(&md, (uchar *)md.buffer, CSUM_CHUNK);\n\t\t\tlen -= i;\n\t\t\tp += i;\n\t\t}\n\n\t\twhile (len >= CSUM_CHUNK) {\n\t\t\tmdfour_update(&md, (uchar *)p, CSUM_CHUNK);\n\t\t\tlen -= CSUM_CHUNK;\n\t\t\tp += CSUM_CHUNK;\n\t\t}\n\n\t\tsumresidue = len;\n\t\tif (sumresidue)\n\t\t\tmemcpy(md.buffer, p, sumresidue);\n\t\tbreak;\n\t  case CSUM_NONE:\n\t\tbreak;\n\t}\n}\n", "target": 1, "idx": 177812}
{"func": "format_DEBUG_RECIRC(const struct ofpact_null *a OVS_UNUSED, struct ds *s)\n{\n    ds_put_format(s, \"%sdebug_recirc%s\", colors.value, colors.end);\n}\n", "target": 0, "idx": 76920}
{"func": "CJSON_PUBLIC(cJSON *) cJSON_CreateIntArray(const int *numbers, int count)\n{\n    size_t i = 0;\n    cJSON *n = NULL;\n    cJSON *p = NULL;\n    cJSON *a = NULL;\n\n    if ((count < 0) || (numbers == NULL))\n    {\n        return NULL;\n    }\n\n    a = cJSON_CreateArray();\n    for(i = 0; a && (i < (size_t)count); i++)\n    {\n        n = cJSON_CreateNumber(numbers[i]);\n        if (!n)\n        {\n            cJSON_Delete(a);\n            return NULL;\n        }\n        if(!i)\n        {\n            a->child = n;\n        }\n        else\n        {\n            suffix_object(p, n);\n        }\n        p = n;\n    }\n\n    return a;\n}\n", "target": 0, "idx": 87106}
{"func": "WebContents* TabsCaptureVisibleTabFunction::GetWebContentsForID(\n    int window_id,\n    std::string* error) {\n  Browser* browser = NULL;\n  if (!GetBrowserFromWindowID(chrome_details_, window_id, &browser, error))\n    return nullptr;\n\n  WebContents* contents = browser->tab_strip_model()->GetActiveWebContents();\n  if (!contents) {\n    *error = \"No active web contents to capture\";\n    return nullptr;\n  }\n \n   if (!extension()->permissions_data()->CanCaptureVisiblePage(\n           contents->GetLastCommittedURL(),\n          SessionTabHelper::IdForTab(contents).id(), error)) {\n     return nullptr;\n   }\n   return contents;\n}\n", "target": 1, "idx": 186983}
{"func": "TransportDIB::TransportDIB()\n    : address_(kInvalidAddress),\n      x_shm_(0),\n      display_(NULL),\n      size_(0) {\n}\n", "target": 0, "idx": 127661}
{"func": "void RenderBlock::finishDelayUpdateScrollInfo()\n{\n    --gDelayUpdateScrollInfo;\n    ASSERT(gDelayUpdateScrollInfo >= 0);\n    if (gDelayUpdateScrollInfo == 0) {\n        ASSERT(gDelayedUpdateScrollInfoSet);\n\n        OwnPtr<DelayedUpdateScrollInfoSet> infoSet(adoptPtr(gDelayedUpdateScrollInfoSet));\n        gDelayedUpdateScrollInfoSet = 0;\n\n        for (DelayedUpdateScrollInfoSet::iterator it = infoSet->begin(); it != infoSet->end(); ++it) {\n            RenderBlock* block = *it;\n            if (block->hasOverflowClip()) {\n                block->layer()->scrollableArea()->updateAfterLayout();\n            }\n        }\n    }\n}\n", "target": 0, "idx": 124544}
{"func": " void WebGL2RenderingContextBase::deleteVertexArray(\n     WebGLVertexArrayObject* vertex_array) {\n  if (isContextLost() || !vertex_array)\n     return;\n \n   if (!vertex_array->IsDefaultObject() &&\n      vertex_array == bound_vertex_array_object_)\n    SetBoundVertexArrayObject(nullptr);\n\n  vertex_array->DeleteObject(ContextGL());\n}\n", "target": 1, "idx": 187108}
{"func": "void RenderFrameImpl::didLoadResourceFromMemoryCache(\n    blink::WebLocalFrame* frame,\n    const blink::WebURLRequest& request,\n    const blink::WebURLResponse& response) {\n  DCHECK(!frame_ || frame_ == frame);\n  GURL url(request.url());\n  if (url.SchemeIs(url::kDataScheme))\n    return;\n\n  render_view_->Send(new ViewHostMsg_DidLoadResourceFromMemoryCache(\n      render_view_->GetRoutingID(),\n      url,\n      response.securityInfo(),\n      request.httpMethod().utf8(),\n      response.mimeType().utf8(),\n      WebURLRequestToResourceType(request)));\n}\n", "target": 0, "idx": 132313}
{"func": " accept_ice_connection (GIOChannel           *source,\n                        GIOCondition          condition,\n                        GsmIceConnectionData *data)\n {\n        IceListenObj    listener;\n         IceConn         ice_conn;\n         IceAcceptStatus status;\n        GsmClient      *client;\n        GsmXsmpServer  *server;\n        listener = data->listener;\n        server = data->server;\n \n         g_debug (\"GsmXsmpServer: accept_ice_connection()\");\n \n        ice_conn = IceAcceptConnection (listener, &status);\n         if (status != IceAcceptSuccess) {\n                 g_debug (\"GsmXsmpServer: IceAcceptConnection returned %d\", status);\n                 return TRUE;\n         }\n \n        client = gsm_xsmp_client_new (ice_conn);\n        ice_conn->context = client;\n        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));\n        /* the store will own the ref */\n        g_object_unref (client);\n \n         return TRUE;\n }\n", "target": 1, "idx": 181224}
{"func": "double json_real_value(const json_t *json)\n{\n    if(!json_is_real(json))\n        return 0;\n\n    return json_to_real(json)->value;\n}\n", "target": 0, "idx": 40930}
{"func": "XIQueryDevice(Display *dpy, int deviceid, int *ndevices_return)\n{\n    XIDeviceInfo        *info = NULL;\n    xXIQueryDeviceReq   *req;\n     xXIQueryDeviceReq   *req;\n     xXIQueryDeviceReply reply;\n     char                *ptr;\n     int                 i;\n     char                *buf;\n \n    LockDisplay(dpy);\n    if (_XiCheckExtInit(dpy, XInput_2_0, extinfo) == -1)\n        goto error_unlocked;\n\n    GetReq(XIQueryDevice, req);\n    req->reqType  = extinfo->codes->major_opcode;\n    req->ReqType  = X_XIQueryDevice;\n    req->deviceid = deviceid;\n\n    if (!_XReply(dpy, (xReply*) &reply, 0, xFalse))\n        goto error;\n     if (!_XReply(dpy, (xReply*) &reply, 0, xFalse))\n         goto error;\n \n    *ndevices_return = reply.num_devices;\n    info = Xmalloc((reply.num_devices + 1) * sizeof(XIDeviceInfo));\n     if (!info)\n         goto error;\n \n     buf = Xmalloc(reply.length * 4);\n     _XRead(dpy, buf, reply.length * 4);\n     ptr = buf;\n \n     /* info is a null-terminated array */\n     info[reply.num_devices].name = NULL;\n        nclasses         = wire->num_classes;\n\n        ptr += sizeof(xXIDeviceInfo);\n\n        lib->name = Xcalloc(wire->name_len + 1, 1);\n         XIDeviceInfo    *lib = &info[i];\n         xXIDeviceInfo   *wire = (xXIDeviceInfo*)ptr;\n \n         lib->deviceid    = wire->deviceid;\n         lib->use         = wire->use;\n         lib->attachment  = wire->attachment;\n\n    Xfree(buf);\n \n         ptr += sizeof(xXIDeviceInfo);\n \n         lib->name = Xcalloc(wire->name_len + 1, 1);\n         strncpy(lib->name, ptr, wire->name_len);\n         ptr += ((wire->name_len + 3)/4) * 4;\n \n         sz = size_classes((xXIAnyInfo*)ptr, nclasses);\n         lib->classes = Xmalloc(sz);\n         ptr += copy_classes(lib, (xXIAnyInfo*)ptr, &nclasses);\n         /* We skip over unused classes */\n         lib->num_classes = nclasses;\n}\n", "target": 1, "idx": 178092}
{"func": "static char *rfc2047_decode_word(const char *s, size_t len, enum ContentEncoding enc)\n{\n  const char *it = s;\n  const char *end = s + len;\n\n  if (enc == ENCQUOTEDPRINTABLE)\n  {\n    struct Buffer buf = { 0 };\n    for (; it < end; ++it)\n    {\n      if (*it == '_')\n      {\n        mutt_buffer_addch(&buf, ' ');\n      }\n      else if ((*it == '=') && (!(it[1] & ~127) && hexval(it[1]) != -1) &&\n               (!(it[2] & ~127) && hexval(it[2]) != -1))\n      {\n        mutt_buffer_addch(&buf, (hexval(it[1]) << 4) | hexval(it[2]));\n        it += 2;\n      }\n      else\n      {\n        mutt_buffer_addch(&buf, *it);\n      }\n    }\n    mutt_buffer_addch(&buf, '\\0');\n    return buf.data;\n   }\n   else if (enc == ENCBASE64)\n   {\n    char *out = mutt_mem_malloc(3 * len / 4 + 1);\n    int dlen = mutt_b64_decode(out, it);\n     if (dlen == -1)\n     {\n       FREE(&out);\n      return NULL;\n    }\n    out[dlen] = '\\0';\n    return out;\n  }\n\n  assert(0); /* The enc parameter has an invalid value */\n  return NULL;\n}\n", "target": 1, "idx": 182301}
{"func": "DOMHandler::DOMHandler()\n     : DevToolsDomainHandler(DOM::Metainfo::domainName),\n      host_(nullptr) {\n}\n", "target": 1, "idx": 187096}
{"func": "static int hid_abort_transfers(int sub_api, struct usbi_transfer *itransfer)\n{\n\tstruct libusb_transfer *transfer = USBI_TRANSFER_TO_LIBUSB_TRANSFER(itransfer);\n\tstruct windows_transfer_priv *transfer_priv = (struct windows_transfer_priv*)usbi_transfer_get_os_priv(itransfer);\n\tstruct windows_device_handle_priv *handle_priv = _device_handle_priv(transfer->dev_handle);\n\tHANDLE hid_handle;\n\tint current_interface;\n\tCHECK_HID_AVAILABLE;\n\tcurrent_interface = transfer_priv->interface_number;\n\thid_handle = handle_priv->interface_handle[current_interface].api_handle;\n\tCancelIo(hid_handle);\n\treturn LIBUSB_SUCCESS;\n}\n", "target": 1, "idx": 187224}
{"func": "static int emulate_store_desc_ptr(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t  void (*get)(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t\t      struct desc_ptr *ptr))\n{\n\tstruct desc_ptr desc_ptr;\n\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\tctxt->op_bytes = 8;\n\tget(ctxt, &desc_ptr);\n\tif (ctxt->op_bytes == 2) {\n\t\tctxt->op_bytes = 4;\n\t\tdesc_ptr.address &= 0x00ffffff;\n \t}\n \t/* Disable writeback. */\n \tctxt->dst.type = OP_NONE;\n\treturn segmented_write(ctxt, ctxt->dst.addr.mem,\n\t\t\t       &desc_ptr, 2 + ctxt->op_bytes);\n }\n", "target": 1, "idx": 181618}
{"func": "chash_start(int type, void *base)\n{\nif (type == HMAC_MD5)\n  md5_start((md5 *)base);\nelse\n  sha1_start((sha1 *)base);\n}\n", "target": 0, "idx": 12640}
{"func": "void CompositorImpl::DidInitializeLayerTreeFrameSink() {\n  layer_tree_frame_sink_request_pending_ = false;\n  has_layer_tree_frame_sink_ = true;\n  for (auto& frame_sink_id : pending_child_frame_sink_ids_)\n    AddChildFrameSink(frame_sink_id);\n\n  pending_child_frame_sink_ids_.clear();\n}\n", "target": 0, "idx": 143491}
{"func": " PrintPreviewUI::PrintPreviewUI(content::WebUI* web_ui)\n     : ConstrainedWebDialogUI(web_ui),\n       initial_preview_start_time_(base::TimeTicks::Now()),\n       handler_(NULL),\n       source_is_modifiable_(true),\n       tab_closed_(false) {\n  Profile* profile = Profile::FromWebUI(web_ui);\n  ChromeURLDataManager::AddDataSource(profile, new PrintPreviewDataSource());\n\n   handler_ = new PrintPreviewHandler();\n   web_ui->AddMessageHandler(handler_);\n \n  preview_ui_addr_str_ = GetPrintPreviewUIAddress();\n  g_print_preview_request_id_map.Get().Set(preview_ui_addr_str_, -1);\n }\n", "target": 1, "idx": 184415}
{"func": "void vsock_enqueue_accept(struct sock *listener, struct sock *connected)\n{\n\tstruct vsock_sock *vlistener;\n\tstruct vsock_sock *vconnected;\n\n\tvlistener = vsock_sk(listener);\n\tvconnected = vsock_sk(connected);\n\n\tsock_hold(connected);\n\tsock_hold(listener);\n\tlist_add_tail(&vconnected->accept_queue, &vlistener->accept_queue);\n}\n", "target": 0, "idx": 30338}
{"func": "bool Plugin::LoadNaClModuleCommon(nacl::DescWrapper* wrapper,\n                                  NaClSubprocess* subprocess,\n                                  const Manifest* manifest,\n                                  bool should_report_uma,\n                                  ErrorInfo* error_info,\n                                  pp::CompletionCallback init_done_cb,\n                                  pp::CompletionCallback crash_cb) {\n  ServiceRuntime* new_service_runtime =\n      new ServiceRuntime(this, manifest, should_report_uma, init_done_cb,\n                         crash_cb);\n  subprocess->set_service_runtime(new_service_runtime);\n  PLUGIN_PRINTF((\"Plugin::LoadNaClModuleCommon (service_runtime=%p)\\n\",\n                 static_cast<void*>(new_service_runtime)));\n  if (NULL == new_service_runtime) {\n    error_info->SetReport(ERROR_SEL_LDR_INIT,\n                          \"sel_ldr init failure \" + subprocess->description());\n    return false;\n   }\n \n   bool service_runtime_started =\n      new_service_runtime->Start(wrapper,\n                                 error_info,\n                                 manifest_base_url());\n   PLUGIN_PRINTF((\"Plugin::LoadNaClModuleCommon (service_runtime_started=%d)\\n\",\n                  service_runtime_started));\n   if (!service_runtime_started) {\n     return false;\n   }\n  const PPB_NaCl_Private* ppb_nacl = GetNaclInterface();\n  if (ppb_nacl->StartPpapiProxy(pp_instance())) {\n    using_ipc_proxy_ = true;\n    CHECK(init_done_cb.pp_completion_callback().func != NULL);\n    PLUGIN_PRINTF((\"Plugin::LoadNaClModuleCommon, started ipc proxy.\\n\"));\n    pp::Module::Get()->core()->CallOnMainThread(0, init_done_cb, PP_OK);\n  }\n   return true;\n }\n", "target": 1, "idx": 184316}
{"func": "ContentSettingsClient* FrameFetchContext::GetContentSettingsClient() const {\n  if (IsDetached())\n    return nullptr;\n  return GetFrame()->GetContentSettingsClient();\n}\n", "target": 0, "idx": 151420}
{"func": " static struct nfs4_opendata *nfs4_opendata_alloc(struct path *path,\n\t\tstruct nfs4_state_owner *sp, int flags,\n \t\tconst struct iattr *attrs)\n {\n \tstruct dentry *parent = dget_parent(path->dentry);\n\tstruct inode *dir = parent->d_inode;\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tstruct nfs4_opendata *p;\n\n\tp = kzalloc(sizeof(*p), GFP_KERNEL);\n\tif (p == NULL)\n\t\tgoto err;\n\tp->o_arg.seqid = nfs_alloc_seqid(&sp->so_seqid);\n\tif (p->o_arg.seqid == NULL)\n\t\tgoto err_free;\n\tp->path.mnt = mntget(path->mnt);\n\tp->path.dentry = dget(path->dentry);\n\tp->dir = parent;\n \tp->owner = sp;\n \tatomic_inc(&sp->so_count);\n \tp->o_arg.fh = NFS_FH(dir);\n\tp->o_arg.open_flags = flags,\n \tp->o_arg.clientid = server->nfs_client->cl_clientid;\n \tp->o_arg.id = sp->so_owner_id.id;\n \tp->o_arg.name = &p->path.dentry->d_name;\n\tp->o_arg.server = server;\n\tp->o_arg.bitmask = server->attr_bitmask;\n\tp->o_arg.claim = NFS4_OPEN_CLAIM_NULL;\n\tif (flags & O_EXCL) {\n\t\tu32 *s = (u32 *) p->o_arg.u.verifier.data;\n\t\ts[0] = jiffies;\n\t\ts[1] = current->pid;\n\t} else if (flags & O_CREAT) {\n\t\tp->o_arg.u.attrs = &p->attrs;\n\t\tmemcpy(&p->attrs, attrs, sizeof(p->attrs));\n\t}\n\tp->c_arg.fh = &p->o_res.fh;\n\tp->c_arg.stateid = &p->o_res.stateid;\n\tp->c_arg.seqid = p->o_arg.seqid;\n\tnfs4_init_opendata_res(p);\n\tkref_init(&p->kref);\n\treturn p;\nerr_free:\n\tkfree(p);\nerr:\n\tdput(parent);\n\treturn NULL;\n}\n", "target": 1, "idx": 178872}
{"func": "static void request_gathered_write(h2o_http2_conn_t *conn)\n{\n    assert(conn->state < H2O_HTTP2_CONN_STATE_IS_CLOSING);\n    if (conn->_write.buf_in_flight == NULL) {\n        if (!h2o_timeout_is_linked(&conn->_write.timeout_entry))\n            h2o_timeout_link(conn->super.ctx->loop, &conn->super.ctx->zero_timeout, &conn->_write.timeout_entry);\n    }\n}\n", "target": 0, "idx": 52577}
{"func": " void __ip_select_ident(struct iphdr *iph, int segs)\n {\n \tstatic u32 ip_idents_hashrnd __read_mostly;\n \tu32 hash, id;\n \n \tnet_get_random_once(&ip_idents_hashrnd, sizeof(ip_idents_hashrnd));\n \n \thash = jhash_3words((__force u32)iph->daddr,\n \t\t\t    (__force u32)iph->saddr,\n\t\t\t    iph->protocol,\n \t\t\t    ip_idents_hashrnd);\n \tid = ip_idents_reserve(hash, segs);\n \tiph->id = htons(id);\n}\n", "target": 1, "idx": 183409}
{"func": "png_get_filter_type(png_structp png_ptr, png_infop info_ptr)\n{\n   if (png_ptr != NULL && info_ptr != NULL)\n      return info_ptr->filter_type;\n\n   return (0);\n}\n", "target": 0, "idx": 143957}
{"func": "GDataEntry* GDataEntry::FromDocumentEntry(\n    GDataDirectory* parent,\n    DocumentEntry* doc,\n    GDataDirectoryService* directory_service) {\n  DCHECK(doc);\n  if (doc->is_folder())\n    return GDataDirectory::FromDocumentEntry(parent, doc, directory_service);\n  else if (doc->is_hosted_document() || doc->is_file())\n    return GDataFile::FromDocumentEntry(parent, doc, directory_service);\n  return NULL;\n}\n", "target": 1, "idx": 185187}
{"func": " void LocalFileSystem::fileSystemNotAllowedInternal(\n     PassRefPtrWillBeRawPtr<ExecutionContext> context,\n    PassRefPtr<CallbackWrapper> callbacks)\n {\n     context->postTask(createCrossThreadTask(&reportFailure, callbacks->release(), FileError::ABORT_ERR));\n }\n", "target": 1, "idx": 185125}
{"func": "get_control(png_const_structrp png_ptr)\n{\n\n    /* This just returns the (file*).  The chunk and idat control structures\n     * don't always exist.\n     */\n   struct control *control = png_voidcast(struct control*,\n       png_get_error_ptr(png_ptr));\n    return &control->file;\n }\n", "target": 1, "idx": 187754}
{"func": "ovsinst_bitmap_to_openflow(uint32_t ovsinst_bitmap, enum ofp_version version)\n{\n    uint32_t ofpit_bitmap = 0;\n    const struct ovsinst_map *x;\n\n    for (x = get_ovsinst_map(version); x->ofpit >= 0; x++) {\n        if (ovsinst_bitmap & (1u << x->ovsinst)) {\n            ofpit_bitmap |= 1u << x->ofpit;\n        }\n    }\n    return htonl(ofpit_bitmap);\n}\n", "target": 0, "idx": 77038}
{"func": "read_pri(unsigned int *pri, const char *buf, char **end)\n{\n    char *tend;\n    unsigned int tpri;\n\n    errno = 0;\n    while (buf[0] == ' ') buf++;\n    if (!isdigit(buf[0])) return -1;\n    tpri = strtoul(buf, &tend, 10);\n    if (tend == buf) return -1;\n    if (errno && errno != ERANGE) return -1;\n    if (!end && tend[0] != '\\0') return -1;\n\n    if (pri) *pri = tpri;\n    if (end) *end = tend;\n    return 0;\n}\n", "target": 0, "idx": 18164}
{"func": "static int rose_create(struct net *net, struct socket *sock, int protocol,\n\t\t       int kern)\n{\n\tstruct sock *sk;\n\tstruct rose_sock *rose;\n\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\n\tif (sock->type != SOCK_SEQPACKET || protocol != 0)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tsk = sk_alloc(net, PF_ROSE, GFP_ATOMIC, &rose_proto);\n\tif (sk == NULL)\n\t\treturn -ENOMEM;\n\n\trose = rose_sk(sk);\n\n\tsock_init_data(sock, sk);\n\n\tskb_queue_head_init(&rose->ack_queue);\n#ifdef M_BIT\n\tskb_queue_head_init(&rose->frag_queue);\n\trose->fraglen    = 0;\n#endif\n\n\tsock->ops    = &rose_proto_ops;\n\tsk->sk_protocol = protocol;\n\n\tinit_timer(&rose->timer);\n\tinit_timer(&rose->idletimer);\n\n\trose->t1   = msecs_to_jiffies(sysctl_rose_call_request_timeout);\n\trose->t2   = msecs_to_jiffies(sysctl_rose_reset_request_timeout);\n\trose->t3   = msecs_to_jiffies(sysctl_rose_clear_request_timeout);\n\trose->hb   = msecs_to_jiffies(sysctl_rose_ack_hold_back_timeout);\n\trose->idle = msecs_to_jiffies(sysctl_rose_no_activity_timeout);\n\n\trose->state = ROSE_STATE_0;\n\n\treturn 0;\n}\n", "target": 0, "idx": 22194}
{"func": "int udp_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n\t\tsize_t len, int noblock, int flags, int *addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;\n\tstruct sk_buff *skb;\n\tunsigned int ulen, copied;\n\tint peeked, off = 0;\n\tint err;\n \tint is_udplite = IS_UDPLITE(sk);\n \tbool slow;\n \n\t/*\n\t *\tCheck any passed addresses\n\t */\n\tif (addr_len)\n\t\t*addr_len = sizeof(*sin);\n \tif (flags & MSG_ERRQUEUE)\n \t\treturn ip_recv_error(sk, msg, len);\n \ntry_again:\n\tskb = __skb_recv_datagram(sk, flags | (noblock ? MSG_DONTWAIT : 0),\n\t\t\t\t  &peeked, &off, &err);\n\tif (!skb)\n\t\tgoto out;\n\n\tulen = skb->len - sizeof(struct udphdr);\n\tcopied = len;\n\tif (copied > ulen)\n\t\tcopied = ulen;\n\telse if (copied < ulen)\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\n\t/*\n\t * If checksum is needed at all, try to do it while copying the\n\t * data.  If the data is truncated, or if we only want a partial\n\t * coverage checksum (UDP-Lite), do it before the copy.\n\t */\n\n\tif (copied < ulen || UDP_SKB_CB(skb)->partial_cov) {\n\t\tif (udp_lib_checksum_complete(skb))\n\t\t\tgoto csum_copy_err;\n\t}\n\n\tif (skb_csum_unnecessary(skb))\n\t\terr = skb_copy_datagram_iovec(skb, sizeof(struct udphdr),\n\t\t\t\t\t      msg->msg_iov, copied);\n\telse {\n\t\terr = skb_copy_and_csum_datagram_iovec(skb,\n\t\t\t\t\t\t       sizeof(struct udphdr),\n\t\t\t\t\t\t       msg->msg_iov);\n\n\t\tif (err == -EINVAL)\n\t\t\tgoto csum_copy_err;\n\t}\n\n\tif (unlikely(err)) {\n\t\ttrace_kfree_skb(skb, udp_recvmsg);\n\t\tif (!peeked) {\n\t\t\tatomic_inc(&sk->sk_drops);\n\t\t\tUDP_INC_STATS_USER(sock_net(sk),\n\t\t\t\t\t   UDP_MIB_INERRORS, is_udplite);\n\t\t}\n\t\tgoto out_free;\n\t}\n\n\tif (!peeked)\n\t\tUDP_INC_STATS_USER(sock_net(sk),\n\t\t\t\tUDP_MIB_INDATAGRAMS, is_udplite);\n\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\n\t/* Copy the address. */\n\tif (sin) {\n\t\tsin->sin_family = AF_INET;\n \t\tsin->sin_port = udp_hdr(skb)->source;\n \t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n \t\tmemset(sin->sin_zero, 0, sizeof(sin->sin_zero));\n \t}\n \tif (inet->cmsg_flags)\n \t\tip_cmsg_recv(msg, skb);\n\n\terr = copied;\n\tif (flags & MSG_TRUNC)\n\t\terr = ulen;\n\nout_free:\n\tskb_free_datagram_locked(sk, skb);\nout:\n\treturn err;\n\ncsum_copy_err:\n\tslow = lock_sock_fast(sk);\n\tif (!skb_kill_datagram(sk, skb, flags)) {\n\t\tUDP_INC_STATS_USER(sock_net(sk), UDP_MIB_CSUMERRORS, is_udplite);\n\t\tUDP_INC_STATS_USER(sock_net(sk), UDP_MIB_INERRORS, is_udplite);\n\t}\n\tunlock_sock_fast(sk, slow);\n\n\tif (noblock)\n\t\treturn -EAGAIN;\n\n\t/* starting over for a new packet */\n\tmsg->msg_flags &= ~MSG_TRUNC;\n\tgoto try_again;\n}\n", "target": 1, "idx": 179651}
{"func": "void RenderWidgetHostImpl::ForwardGestureEventWithLatencyInfo(\n    const blink::WebGestureEvent& gesture_event,\n    const ui::LatencyInfo& ui_latency) {\n  TRACE_EVENT0(\"input\", \"RenderWidgetHostImpl::ForwardGestureEvent\");\n  if (ShouldDropInputEvents())\n    return;\n\n  if (gesture_event.type == blink::WebInputEvent::GestureScrollBegin) {\n    DCHECK(!is_in_gesture_scroll_);\n    is_in_gesture_scroll_ = true;\n  } else if (gesture_event.type == blink::WebInputEvent::GestureScrollEnd ||\n             gesture_event.type == blink::WebInputEvent::GestureFlingStart) {\n    DCHECK(is_in_gesture_scroll_ ||\n           (gesture_event.type == blink::WebInputEvent::GestureFlingStart &&\n            gesture_event.sourceDevice ==\n                blink::WebGestureDevice::WebGestureDeviceTouchpad));\n    is_in_gesture_scroll_ = false;\n  }\n\n  bool scroll_update_needs_wrapping =\n      gesture_event.type == blink::WebInputEvent::GestureScrollUpdate &&\n      gesture_event.resendingPluginId != -1 && !is_in_gesture_scroll_;\n\n  if (scroll_update_needs_wrapping) {\n    ForwardGestureEventWithLatencyInfo(\n        CreateScrollBeginForWrapping(gesture_event), ui::LatencyInfo());\n  }\n\n  if (delegate_->PreHandleGestureEvent(gesture_event))\n    return;\n\n  GestureEventWithLatencyInfo gesture_with_latency(gesture_event, ui_latency);\n  latency_tracker_.OnInputEvent(gesture_event, &gesture_with_latency.latency);\n  input_router_->SendGestureEvent(gesture_with_latency);\n\n  if (scroll_update_needs_wrapping) {\n    ForwardGestureEventWithLatencyInfo(\n        CreateScrollEndForWrapping(gesture_event), ui::LatencyInfo());\n  }\n}\n", "target": 0, "idx": 143621}
{"func": "status_t BufferQueueConsumer::disconnect() {\n    ATRACE_CALL();\n\n    BQ_LOGV(\"disconnect(C)\");\n\n Mutex::Autolock lock(mCore->mMutex);\n\n if (mCore->mConsumerListener == NULL) {\n        BQ_LOGE(\"disconnect(C): no consumer is connected\");\n return BAD_VALUE;\n }\n\n    mCore->mIsAbandoned = true;\n    mCore->mConsumerListener = NULL;\n    mCore->mQueue.clear();\n    mCore->freeAllBuffersLocked();\n    mCore->mDequeueCondition.broadcast();\n return NO_ERROR;\n}\n", "target": 0, "idx": 174500}
{"func": "fbCombineConjointOutPart (CARD8 a, CARD8 b)\n{\n    /* max (1-b/a,0) */\n    /* = 1-min(b/a,1) */\n\n    /* min (1, (1-b) / a) */\n\n    if (b >= a)\t\t    /* b >= a -> b/a >= 1 */\n\treturn 0x00;\t    /* 0 */\n    return ~FbIntDiv(b,a);   /* 1 - b/a */\n}\n", "target": 0, "idx": 11349}
{"func": "static void checkAppendMsg(\n  IntegrityCk *pCheck,\n  const char *zFormat,\n  ...\n){\n  va_list ap;\n  if( !pCheck->mxErr ) return;\n  pCheck->mxErr--;\n  pCheck->nErr++;\n  va_start(ap, zFormat);\n  if( pCheck->errMsg.nChar ){\n    sqlite3StrAccumAppend(&pCheck->errMsg, \"\\n\", 1);\n  }\n  if( pCheck->zPfx ){\n    sqlite3XPrintf(&pCheck->errMsg, pCheck->zPfx, pCheck->v1, pCheck->v2);\n  }\n  sqlite3VXPrintf(&pCheck->errMsg, zFormat, ap);\n  va_end(ap);\n  if( pCheck->errMsg.accError==STRACCUM_NOMEM ){\n    pCheck->mallocFailed = 1;\n  }\n}\n", "target": 0, "idx": 149057}
{"func": "BOOL IsVolumeClassFilterRegistered ()\n{\n\tUNICODE_STRING name;\n\tNTSTATUS status;\n\tBOOL registered = FALSE;\n\n\tPKEY_VALUE_PARTIAL_INFORMATION data;\n\n\tRtlInitUnicodeString (&name, L\"\\\\REGISTRY\\\\MACHINE\\\\SYSTEM\\\\CurrentControlSet\\\\Control\\\\Class\\\\{71A27CDD-812A-11D0-BEC7-08002BE2092F}\");\n\tstatus = TCReadRegistryKey (&name, L\"UpperFilters\", &data);\n\n\tif (NT_SUCCESS (status))\n\t{\n\t\tif (data->Type == REG_MULTI_SZ && data->DataLength >= 9 * sizeof (wchar_t))\n\t\t{\n\t\t\tULONG i;\n\t\t\tfor (i = 0; i <= data->DataLength - 9 * sizeof (wchar_t); ++i)\n\t\t\t{\n\t\t\t\tif (memcmp (data->Data + i, L\"veracrypt\", 9 * sizeof (wchar_t)) == 0)\n\t\t\t\t{\n\t\t\t\t\tDump (\"Volume class filter active\\n\");\n\t\t\t\t\tregistered = TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tTCfree (data);\n\t}\n\n\treturn registered;\n}\n", "target": 0, "idx": 87184}
{"func": "dcputs(const char *s)\n{\n\tint len=strlen(s);\n\tdcchkstr(len);\n\tstrcat(dcptr,s);\n\tdcptr+=len;\n\tstrsize+=len;\n}\n", "target": 0, "idx": 89481}
{"func": " SPL_METHOD(SplFileObject, valid)\n {\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n\n\tif (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_READ_AHEAD)) {\n\t\tRETURN_BOOL(intern->u.file.current_line || intern->u.file.current_zval);\n\t} else {\n\t\tRETVAL_BOOL(!php_stream_eof(intern->u.file.stream));\n\t}\n} /* }}} */\n\n/* {{{ proto string SplFileObject::fgets()\n", "target": 1, "idx": 180225}
{"func": "static unsigned long klsi_105_status2linestate(const __u16 status)\n{\n\tunsigned long res = 0;\n\n\tres =   ((status & KL5KUSB105A_DSR) ? TIOCM_DSR : 0)\n\t      | ((status & KL5KUSB105A_CTS) ? TIOCM_CTS : 0)\n\t      ;\n\n\treturn res;\n}\n", "target": 0, "idx": 68761}
{"func": "static bool tcp_prune_ofo_queue(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tbool res = false;\n\n\tif (!skb_queue_empty(&tp->out_of_order_queue)) {\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_OFOPRUNED);\n\t\t__skb_queue_purge(&tp->out_of_order_queue);\n\n\t\t/* Reset SACK state.  A conforming SACK implementation will\n\t\t * do the same at a timeout based retransmit.  When a connection\n\t\t * is in a sad state like this, we care only about integrity\n\t\t * of the connection not performance.\n\t\t */\n\t\tif (tp->rx_opt.sack_ok)\n\t\t\ttcp_sack_reset(&tp->rx_opt);\n\t\tsk_mem_reclaim(sk);\n\t\tres = true;\n\t}\n\treturn res;\n}\n", "target": 0, "idx": 51585}
{"func": "static int spl_filesystem_file_is_empty_line(spl_filesystem_object *intern TSRMLS_DC) /* {{{ */\n{\n\tif (intern->u.file.current_line) {\n\t\treturn intern->u.file.current_line_len == 0;\n\t} else if (intern->u.file.current_zval) {\n\t\tswitch(Z_TYPE_P(intern->u.file.current_zval)) {\n\t\tcase IS_STRING:\n\t\t\treturn Z_STRLEN_P(intern->u.file.current_zval) == 0;\n\t\tcase IS_ARRAY:\n \t\t\tif (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_READ_CSV)\n \t\t\t&& zend_hash_num_elements(Z_ARRVAL_P(intern->u.file.current_zval)) == 1) {\n \t\t\t\tzval ** first = Z_ARRVAL_P(intern->u.file.current_zval)->pListHead->pData;\n \t\t\t\treturn Z_TYPE_PP(first) == IS_STRING && Z_STRLEN_PP(first) == 0;\n \t\t\t}\n \t\t\treturn zend_hash_num_elements(Z_ARRVAL_P(intern->u.file.current_zval)) == 0;\n\t\tcase IS_NULL:\n\t\t\treturn 1;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\treturn 1;\n\t}\n}\n/* }}} */\n", "target": 1, "idx": 180246}
{"func": "png_inflate(png_structp png_ptr, const png_byte *data, png_size_t size,\n        png_bytep output, png_size_t output_size)\n{\n   png_size_t count = 0;\n\n   png_ptr->zstream.next_in = (png_bytep)data; /* const_cast: VALID */\n   png_ptr->zstream.avail_in = size;\n\n   while (1)\n   {\n      int ret, avail;\n\n      /* Reset the output buffer each time round - we empty it\n       * after every inflate call.\n       */\n      png_ptr->zstream.next_out = png_ptr->zbuf;\n      png_ptr->zstream.avail_out = png_ptr->zbuf_size;\n\n      ret = inflate(&png_ptr->zstream, Z_NO_FLUSH);\n      avail = png_ptr->zbuf_size - png_ptr->zstream.avail_out;\n\n      /* First copy/count any new output - but only if we didn't\n       * get an error code.\n       */\n      if ((ret == Z_OK || ret == Z_STREAM_END) && avail > 0)\n       {\n          if (output != 0 && output_size > count)\n          {\n            int copy = output_size - count;\n            if (avail < copy) copy = avail;\n             png_memcpy(output + count, png_ptr->zbuf, copy);\n          }\n          count += avail;\n      }\n\n      if (ret == Z_OK)\n         continue;\n\n      /* Termination conditions - always reset the zstream, it\n       * must be left in inflateInit state.\n       */\n      png_ptr->zstream.avail_in = 0;\n      inflateReset(&png_ptr->zstream);\n\n      if (ret == Z_STREAM_END)\n         return count; /* NOTE: may be zero. */\n\n      /* Now handle the error codes - the API always returns 0\n       * and the error message is dumped into the uncompressed\n       * buffer if available.\n       */\n      {\n         PNG_CONST char *msg;\n         if (png_ptr->zstream.msg != 0)\n            msg = png_ptr->zstream.msg;\n         else\n         {\n#if defined(PNG_STDIO_SUPPORTED) && !defined(_WIN32_WCE)\n            char umsg[52];\n\n            switch (ret)\n            {\n               case Z_BUF_ERROR:\n                  msg = \"Buffer error in compressed datastream in %s chunk\";\n                  break;\n               case Z_DATA_ERROR:\n                  msg = \"Data error in compressed datastream in %s chunk\";\n                  break;\n               default:\n                  msg = \"Incomplete compressed datastream in %s chunk\";\n                  break;\n            }\n\n            png_snprintf(umsg, sizeof umsg, msg, png_ptr->chunk_name);\n            msg = umsg;\n#else\n            msg = \"Damaged compressed datastream in chunk other than IDAT\";\n#endif\n         }\n\n         png_warning(png_ptr, msg);\n      }\n\n      /* 0 means an error - notice that this code simple ignores\n       * zero length compressed chunks as a result.\n       */\n      return 0;\n   }\n}\n", "target": 1, "idx": 184753}
{"func": "void ewk_view_scroll(Evas_Object* ewkView, Evas_Coord deltaX, Evas_Coord deltaY, Evas_Coord scrollX, Evas_Coord scrollY, Evas_Coord scrollWidth, Evas_Coord scrollHeight, Evas_Coord centerX, Evas_Coord centerY, Evas_Coord centerWidth, Evas_Coord centerHeight, bool mainFrame)\n{\n    DBG(\"ewkView=%p, delta: %d,%d, scroll: %d,%d+%dx%d, clip: %d,%d+%dx%d\",\n        ewkView, deltaX, deltaY, scrollX, scrollY, scrollWidth, scrollHeight, centerX, centerY, centerWidth, centerHeight);\n\n    if ((scrollX != centerX) || (scrollY != centerY) || (scrollWidth != centerWidth) || (scrollHeight != centerHeight))\n        WRN(\"scroll region and clip are different! %d,%d+%dx%d and %d,%d+%dx%d\",\n            scrollX, scrollY, scrollWidth, scrollHeight, centerX, centerY, centerWidth, centerHeight);\n\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData);\n    EWK_VIEW_PRIV_GET_OR_RETURN(smartData, priv);\n    EINA_SAFETY_ON_TRUE_RETURN(!deltaX && !deltaY);\n\n    _ewk_view_scroll_add(priv, deltaX, deltaY, scrollX, scrollY, scrollWidth, scrollHeight, mainFrame);\n\n    _ewk_view_smart_changed(smartData);\n}\n", "target": 0, "idx": 107602}
{"func": "static void setup_remaining_vcs(int src_fd, unsigned src_idx, bool utf8) {\n        struct console_font_op cfo = {\n                .op = KD_FONT_OP_GET,\n                .width = UINT_MAX, .height = UINT_MAX,\n                .charcount = UINT_MAX,\n        };\n        struct unimapinit adv = {};\n        struct unimapdesc unimapd;\n        _cleanup_free_ struct unipair* unipairs = NULL;\n        _cleanup_free_ void *fontbuf = NULL;\n        unsigned i;\n        int r;\n\n        unipairs = new(struct unipair, USHRT_MAX);\n        if (!unipairs) {\n                log_oom();\n                return;\n        }\n\n        /* get metadata of the current font (width, height, count) */\n        r = ioctl(src_fd, KDFONTOP, &cfo);\n        if (r < 0)\n                log_warning_errno(errno, \"KD_FONT_OP_GET failed while trying to get the font metadata: %m\");\n        else {\n                /* verify parameter sanity first */\n                if (cfo.width > 32 || cfo.height > 32 || cfo.charcount > 512)\n                        log_warning(\"Invalid font metadata - width: %u (max 32), height: %u (max 32), count: %u (max 512)\",\n                                    cfo.width, cfo.height, cfo.charcount);\n                else {\n                        /*\n                         * Console fonts supported by the kernel are limited in size to 32 x 32 and maximum 512\n                         * characters. Thus with 1 bit per pixel it requires up to 65536 bytes. The height always\n                         * requires 32 per glyph, regardless of the actual height - see the comment above #define\n                         * max_font_size 65536 in drivers/tty/vt/vt.c for more details.\n                         */\n                        fontbuf = malloc_multiply((cfo.width + 7) / 8 * 32, cfo.charcount);\n                        if (!fontbuf) {\n                                log_oom();\n                                return;\n                        }\n                        /* get fonts from the source console */\n                        cfo.data = fontbuf;\n                        r = ioctl(src_fd, KDFONTOP, &cfo);\n                        if (r < 0)\n                                log_warning_errno(errno, \"KD_FONT_OP_GET failed while trying to read the font data: %m\");\n                        else {\n                                unimapd.entries  = unipairs;\n                                unimapd.entry_ct = USHRT_MAX;\n                                r = ioctl(src_fd, GIO_UNIMAP, &unimapd);\n                                if (r < 0)\n                                        log_warning_errno(errno, \"GIO_UNIMAP failed while trying to read unicode mappings: %m\");\n                                else\n                                        cfo.op = KD_FONT_OP_SET;\n                        }\n                }\n        }\n\n        if (cfo.op != KD_FONT_OP_SET)\n                log_warning(\"Fonts will not be copied to remaining consoles\");\n\n        for (i = 1; i <= 63; i++) {\n                char ttyname[sizeof(\"/dev/tty63\")];\n                _cleanup_close_ int fd_d = -1;\n\n                if (i == src_idx || verify_vc_allocation(i) < 0)\n                        continue;\n\n                /* try to open terminal */\n                xsprintf(ttyname, \"/dev/tty%u\", i);\n                fd_d = open_terminal(ttyname, O_RDWR|O_CLOEXEC|O_NOCTTY);\n                if (fd_d < 0) {\n                        log_warning_errno(fd_d, \"Unable to open tty%u, fonts will not be copied: %m\", i);\n                         continue;\n                 }\n \n                if (verify_vc_kbmode(fd_d) < 0)\n                         continue;\n \n                 toggle_utf8(ttyname, fd_d, utf8);\n\n                if (cfo.op != KD_FONT_OP_SET)\n                        continue;\n\n                r = ioctl(fd_d, KDFONTOP, &cfo);\n                if (r < 0) {\n                        int last_errno, mode;\n\n                        /* The fonts couldn't have been copied. It might be due to the\n                         * terminal being in graphical mode. In this case the kernel\n                         * returns -EINVAL which is too generic for distinguishing this\n                         * specific case. So we need to retrieve the terminal mode and if\n                         * the graphical mode is in used, let's assume that something else\n                         * is using the terminal and the failure was expected as we\n                         * shouldn't have tried to copy the fonts. */\n\n                        last_errno = errno;\n                        if (ioctl(fd_d, KDGETMODE, &mode) >= 0 && mode != KD_TEXT)\n                                log_debug(\"KD_FONT_OP_SET skipped: tty%u is not in text mode\", i);\n                        else\n                                log_warning_errno(last_errno, \"KD_FONT_OP_SET failed, fonts will not be copied to tty%u: %m\", i);\n\n                        continue;\n                }\n\n                /*\n                 * copy unicode translation table unimapd is a ushort count and a pointer\n                 * to an array of struct unipair { ushort, ushort }\n                 */\n                r = ioctl(fd_d, PIO_UNIMAPCLR, &adv);\n                if (r < 0) {\n                        log_warning_errno(errno, \"PIO_UNIMAPCLR failed, unimaps might be incorrect for tty%u: %m\", i);\n                        continue;\n                }\n\n                r = ioctl(fd_d, PIO_UNIMAP, &unimapd);\n                if (r < 0) {\n                        log_warning_errno(errno, \"PIO_UNIMAP failed, unimaps might be incorrect for tty%u: %m\", i);\n                        continue;\n                }\n\n                log_debug(\"Font and unimap successfully copied to %s\", ttyname);\n        }\n}\n", "target": 1, "idx": 182950}
{"func": " int re_yyget_lineno  (yyscan_t yyscanner)\n {\n     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n         if (! YY_CURRENT_BUFFER)\n             return 0;\n     \n    return yylineno;\n}\n", "target": 1, "idx": 181656}
{"func": " bool MessageLoop::DoDelayedWork(TimeTicks* next_delayed_work_time) {\n  if (!nestable_tasks_allowed_ ||\n       !SweepDelayedWorkQueueAndReturnTrueIfStillHasWork()) {\n     recent_time_ = *next_delayed_work_time = TimeTicks();\n     return false;\n  }\n\n\n  TimeTicks next_run_time = delayed_work_queue_.top().delayed_run_time;\n  if (next_run_time > recent_time_) {\n    recent_time_ = TimeTicks::Now();  // Get a better view of Now();\n    if (next_run_time > recent_time_) {\n      *next_delayed_work_time = next_run_time;\n      return false;\n    }\n  }\n\n  PendingTask pending_task =\n      std::move(const_cast<PendingTask&>(delayed_work_queue_.top()));\n  delayed_work_queue_.pop();\n\n  if (SweepDelayedWorkQueueAndReturnTrueIfStillHasWork())\n    *next_delayed_work_time = delayed_work_queue_.top().delayed_run_time;\n\n  return DeferOrRunPendingTask(std::move(pending_task));\n}\n", "target": 1, "idx": 185741}
{"func": "static int cfg_keys(struct cryp_ctx *ctx)\n{\n\tint i;\n\tint num_of_regs = ctx->keylen / 8;\n\tu32 swapped_key[CRYP_MAX_KEY_SIZE / 4];\n\tint cryp_error = 0;\n\n\tdev_dbg(ctx->device->dev, \"[%s]\", __func__);\n\n\tif (mode_is_aes(ctx->config.algomode)) {\n\t\tswap_words_in_key_and_bits_in_byte((u8 *)ctx->key,\n\t\t\t\t\t\t   (u8 *)swapped_key,\n\t\t\t\t\t\t   ctx->keylen);\n\t} else {\n\t\tfor (i = 0; i < ctx->keylen / 4; i++)\n\t\t\tswapped_key[i] = uint8p_to_uint32_be(ctx->key + i*4);\n\t}\n\n\tfor (i = 0; i < num_of_regs; i++) {\n\t\tcryp_error = set_key(ctx->device,\n\t\t\t\t     *(((u32 *)swapped_key)+i*2),\n\t\t\t\t     *(((u32 *)swapped_key)+i*2+1),\n\t\t\t\t     (enum cryp_key_reg_index) i);\n\n\t\tif (cryp_error != 0) {\n\t\t\tdev_err(ctx->device->dev, \"[%s]: set_key() failed!\",\n\t\t\t\t\t__func__);\n\t\t\treturn cryp_error;\n\t\t}\n\t}\n\treturn cryp_error;\n}\n", "target": 0, "idx": 47484}
{"func": "status_t OMXNodeInstance::allocateBufferWithBackup(\n        OMX_U32 portIndex, const sp<IMemory> &params,\n        OMX::buffer_id *buffer, OMX_U32 allottedSize) {\n Mutex::Autolock autoLock(mLock);\n if (allottedSize > params->size()) {\n\n         return BAD_VALUE;\n     }\n \n    BufferMeta *buffer_meta = new BufferMeta(params, true);\n \n     OMX_BUFFERHEADERTYPE *header;\n \n    OMX_ERRORTYPE err = OMX_AllocateBuffer(\n            mHandle, &header, portIndex, buffer_meta, allottedSize);\n if (err != OMX_ErrorNone) {\n        CLOG_ERROR(allocateBufferWithBackup, err,\n                SIMPLE_BUFFER(portIndex, (size_t)allottedSize, params->pointer()));\n delete buffer_meta;\n        buffer_meta = NULL;\n\n *buffer = 0;\n\n return StatusFromOMXError(err);\n }\n\n    CHECK_EQ(header->pAppPrivate, buffer_meta);\n\n *buffer = makeBufferID(header);\n\n    addActiveBuffer(portIndex, *buffer);\n\n    sp<GraphicBufferSource> bufferSource(getGraphicBufferSource());\n if (bufferSource != NULL && portIndex == kPortIndexInput) {\n        bufferSource->addCodecBuffer(header);\n }\n\n    CLOG_BUFFER(allocateBufferWithBackup, NEW_BUFFER_FMT(*buffer, portIndex, \"%zu@%p :> %u@%p\",\n            params->size(), params->pointer(), allottedSize, header->pBuffer));\n\n return OK;\n}\n", "target": 1, "idx": 187547}
{"func": "void SplitString(const std::wstring& str,\n                 wchar_t c,\n                 std::vector<std::wstring>* r) {\n  SplitStringT(str, c, true, r);\n}\n", "target": 1, "idx": 184012}
{"func": "void RenderWidgetHostViewAura::UpdateExternalTexture() {\n  if (accelerated_compositing_state_changed_)\n    accelerated_compositing_state_changed_ = false;\n\n  bool is_compositing_active = host_->is_accelerated_compositing_active();\n  if (is_compositing_active && current_surface_.get()) {\n    window_->layer()->SetExternalTexture(current_surface_.get());\n    current_frame_size_ = ConvertSizeToDIP(\n        current_surface_->device_scale_factor(), current_surface_->size());\n    CheckResizeLock();\n    software_frame_manager_->DiscardCurrentFrame();\n  } else if (is_compositing_active &&\n             software_frame_manager_->HasCurrentFrame()) {\n    cc::TextureMailbox mailbox;\n    scoped_ptr<cc::SingleReleaseCallback> callback;\n    software_frame_manager_->GetCurrentFrameMailbox(&mailbox, &callback);\n    window_->layer()->SetTextureMailbox(mailbox,\n                                        callback.Pass(),\n                                        last_swapped_surface_scale_factor_);\n    current_frame_size_ = ConvertSizeToDIP(last_swapped_surface_scale_factor_,\n                                           mailbox.shared_memory_size());\n    CheckResizeLock();\n  } else {\n    window_->layer()->SetShowPaintedContent();\n    resize_lock_.reset();\n    host_->WasResized();\n    software_frame_manager_->DiscardCurrentFrame();\n  }\n}\n", "target": 0, "idx": 133053}
{"func": "device_constructor (GType type,\n                    guint n_construct_properties,\n                    GObjectConstructParam *construct_properties)\n{\n  Device *device;\n  DeviceClass *klass;\n\n  klass = DEVICE_CLASS (g_type_class_peek (TYPE_DEVICE));\n\n  device = DEVICE (G_OBJECT_CLASS (device_parent_class)->constructor (type,\n                                                                      n_construct_properties,\n                                                                      construct_properties));\n  return G_OBJECT (device);\n}\n", "target": 0, "idx": 11610}
{"func": "void RTCPeerConnection::setRemoteDescription(PassRefPtr<RTCSessionDescription> prpSessionDescription, PassRefPtr<VoidCallback> successCallback, PassRefPtr<RTCErrorCallback> errorCallback, ExceptionCode& ec)\n{\n    if (m_readyState == ReadyStateClosing || m_readyState == ReadyStateClosed) {\n        ec = INVALID_STATE_ERR;\n        return;\n    }\n    RefPtr<RTCSessionDescription> sessionDescription = prpSessionDescription;\n    if (!sessionDescription) {\n        ec = TYPE_MISMATCH_ERR;\n        return;\n    }\n    RefPtr<RTCVoidRequestImpl> request = RTCVoidRequestImpl::create(scriptExecutionContext(), successCallback, errorCallback);\n    m_peerHandler->setRemoteDescription(request.release(), sessionDescription->descriptor());\n}\n", "target": 1, "idx": 183796}
{"func": "GpuProcessHost::GpuProcessHost(int host_id, GpuProcessKind kind)\n    : host_id_(host_id),\n      valid_(true),\n      in_process_(false),\n      software_rendering_(false),\n      kind_(kind),\n      process_launched_(false) {\n  if (CommandLine::ForCurrentProcess()->HasSwitch(switches::kSingleProcess) ||\n      CommandLine::ForCurrentProcess()->HasSwitch(switches::kInProcessGPU))\n    in_process_ = true;\n\n  DCHECK(!in_process_ || g_gpu_process_hosts[kind] == NULL);\n\n  g_gpu_process_hosts[kind] = this;\n\n  BrowserThread::PostTask(\n      BrowserThread::UI,\n      FROM_HERE,\n      base::Bind(base::IgnoreResult(&GpuProcessHostUIShim::Create), host_id));\n\n  process_.reset(new BrowserChildProcessHostImpl(PROCESS_TYPE_GPU, this));\n}\n", "target": 0, "idx": 122791}
{"func": "static MagickBooleanType ReadPSDChannelPixels(Image *image,\n  const size_t channels,const ssize_t row,const ssize_t type,\n  const unsigned char *pixels,ExceptionInfo *exception)\n{\n  Quantum\n    pixel;\n\n  register const unsigned char\n    *p;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    x;\n\n  size_t\n    packet_size;\n\n  p=pixels;\n  q=GetAuthenticPixels(image,0,row,image->columns,1,exception);\n  if (q == (Quantum *) NULL)\n    return MagickFalse;\n  packet_size=GetPSDPacketSize(image);\n  for (x=0; x < (ssize_t) image->columns; x++)\n  {\n    if (packet_size == 1)\n      pixel=ScaleCharToQuantum(*p++);\n    else if (packet_size == 2)\n      {\n        unsigned short\n          nibble;\n\n        p=PushShortPixel(MSBEndian,p,&nibble);\n        pixel=ScaleShortToQuantum(nibble);\n      }\n    else\n      {\n        MagickFloatType\n          nibble;\n\n        p=PushFloatPixel(MSBEndian,p,&nibble);\n        pixel=ClampToQuantum((MagickRealType)QuantumRange*nibble);\n      }\n    if (image->depth > 1)\n      {\n        SetPSDPixel(image,channels,type,packet_size,pixel,q,exception);\n        q+=GetPixelChannels(image);\n      }\n    else\n      {\n        ssize_t\n          bit,\n          number_bits;\n\n        number_bits=(ssize_t) image->columns-x;\n        if (number_bits > 8)\n          number_bits=8;\n        for (bit = 0; bit < (ssize_t) number_bits; bit++)\n        {\n          SetPSDPixel(image,channels,type,packet_size,(((unsigned char) pixel)\n            & (0x01 << (7-bit))) != 0 ? 0 : QuantumRange,q,exception);\n          q+=GetPixelChannels(image);\n          x++;\n        }\n        if (x != (ssize_t) image->columns)\n          x--;\n        continue;\n      }\n  }\n  return(SyncAuthenticPixels(image,exception));\n}\n", "target": 0, "idx": 91368}
{"func": "static int dnxhd_find_frame_end(DNXHDParserContext *dctx,\n                                const uint8_t *buf, int buf_size)\n{\n    ParseContext *pc = &dctx->pc;\n    uint64_t state = pc->state64;\n    int pic_found = pc->frame_start_found;\n    int i = 0;\n\n    if (!pic_found) {\n        for (i = 0; i < buf_size; i++) {\n            state = (state << 8) | buf[i];\n            if (ff_dnxhd_check_header_prefix(state & 0xffffffffff00LL) != 0) {\n                i++;\n                pic_found = 1;\n                dctx->cur_byte = 0;\n                dctx->remaining = 0;\n                break;\n            }\n        }\n    }\n\n    if (pic_found && !dctx->remaining) {\n        if (!buf_size) /* EOF considered as end of frame */\n            return 0;\n        for (; i < buf_size; i++) {\n            dctx->cur_byte++;\n            state = (state << 8) | buf[i];\n\n            if (dctx->cur_byte == 24) {\n                dctx->h = (state >> 32) & 0xFFFF;\n            } else if (dctx->cur_byte == 26) {\n                 dctx->w = (state >> 32) & 0xFFFF;\n             } else if (dctx->cur_byte == 42) {\n                 int cid = (state >> 32) & 0xFFFFFFFF;\n \n                 if (cid <= 0)\n                     continue;\n \n                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);\n                if (dctx->remaining <= 0) {\n                    dctx->remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);\n                    if (dctx->remaining <= 0)\n                        return dctx->remaining;\n                 }\n                 if (buf_size - i + 47 >= dctx->remaining) {\n                     int remaining = dctx->remaining;\n \n                    pc->frame_start_found = 0;\n                    pc->state64 = -1;\n                    dctx->cur_byte = 0;\n                    dctx->remaining = 0;\n                    return remaining;\n                } else {\n                    dctx->remaining -= buf_size;\n                }\n            }\n        }\n    } else if (pic_found) {\n        if (dctx->remaining > buf_size) {\n            dctx->remaining -= buf_size;\n        } else {\n            int remaining = dctx->remaining;\n\n            pc->frame_start_found = 0;\n            pc->state64 = -1;\n            dctx->cur_byte = 0;\n            dctx->remaining = 0;\n            return remaining;\n        }\n    }\n    pc->frame_start_found = pic_found;\n    pc->state64 = state;\n    return END_NOT_FOUND;\n}\n", "target": 1, "idx": 183218}
{"func": " rename_principal_2_svc(rprinc_arg *arg, struct svc_req *rqstp)\n {\n     static generic_ret          ret;\n    char                        *prime_arg1,\n        *prime_arg2;\n    gss_buffer_desc             client_name,\n        service_name;\n     OM_uint32                   minor_stat;\n     kadm5_server_handle_t       handle;\n     restriction_t               *rp;\n    const char                  *errmsg = NULL;\n    size_t                      tlen1, tlen2, clen, slen;\n    char                        *tdots1, *tdots2, *cdots, *sdots;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->src, &prime_arg1) ||\n        krb5_unparse_name(handle->context, arg->dest, &prime_arg2)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n    tlen1 = strlen(prime_arg1);\n    trunc_name(&tlen1, &tdots1);\n    tlen2 = strlen(prime_arg2);\n    trunc_name(&tlen2, &tdots2);\n    clen = client_name.length;\n    trunc_name(&clen, &cdots);\n    slen = service_name.length;\n    trunc_name(&slen, &sdots);\n\n    ret.code = KADM5_OK;\n    if (! CHANGEPW_SERVICE(rqstp)) {\n        if (!kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                                ACL_DELETE, arg->src, NULL))\n            ret.code = KADM5_AUTH_DELETE;\n        /* any restrictions at all on the ADD kills the RENAME */\n        if (!kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                                ACL_ADD, arg->dest, &rp) || rp) {\n            if (ret.code == KADM5_AUTH_DELETE)\n                ret.code = KADM5_AUTH_INSUFFICIENT;\n            else\n                ret.code = KADM5_AUTH_ADD;\n        }\n    } else\n        ret.code = KADM5_AUTH_INSUFFICIENT;\n    if (ret.code != KADM5_OK) {\n        /* okay to cast lengths to int because trunc_name limits max value */\n        krb5_klog_syslog(LOG_NOTICE,\n                         _(\"Unauthorized request: kadm5_rename_principal, \"\n                           \"%.*s%s to %.*s%s, \"\n                           \"client=%.*s%s, service=%.*s%s, addr=%s\"),\n                         (int)tlen1, prime_arg1, tdots1,\n                         (int)tlen2, prime_arg2, tdots2,\n                         (int)clen, (char *)client_name.value, cdots,\n                         (int)slen, (char *)service_name.value, sdots,\n                         client_addr(rqstp->rq_xprt));\n    } else {\n        ret.code = kadm5_rename_principal((void *)handle, arg->src,\n                                          arg->dest);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        /* okay to cast lengths to int because trunc_name limits max value */\n        krb5_klog_syslog(LOG_NOTICE,\n                         _(\"Request: kadm5_rename_principal, \"\n                           \"%.*s%s to %.*s%s, %s, \"\n                           \"client=%.*s%s, service=%.*s%s, addr=%s\"),\n                         (int)tlen1, prime_arg1, tdots1,\n                         (int)tlen2, prime_arg2, tdots2,\n                         errmsg ? errmsg : _(\"success\"),\n                         (int)clen, (char *)client_name.value, cdots,\n                         (int)slen, (char *)service_name.value, sdots,\n                         client_addr(rqstp->rq_xprt));\n\n        if (errmsg != NULL)\n             krb5_free_error_message(handle->context, errmsg);\n \n     }\n     free(prime_arg1);\n     free(prime_arg2);\n     gss_release_buffer(&minor_stat, &client_name);\n     gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n     free_server_handle(handle);\n     return &ret;\n }\n", "target": 1, "idx": 180695}
{"func": " v8::Local<v8::Value> V8Debugger::functionLocation(v8::Local<v8::Context> context, v8::Local<v8::Function> function)\n{\n    int scriptId = function->ScriptId();\n    if (scriptId == v8::UnboundScript::kNoScriptId)\n        return v8::Null(m_isolate);\n    int lineNumber = function->GetScriptLineNumber();\n    int columnNumber = function->GetScriptColumnNumber();\n     if (lineNumber == v8::Function::kLineOffsetNotFound || columnNumber == v8::Function::kLineOffsetNotFound)\n         return v8::Null(m_isolate);\n     v8::Local<v8::Object> location = v8::Object::New(m_isolate);\n     if (!location->Set(context, toV8StringInternalized(m_isolate, \"scriptId\"), toV8String(m_isolate, String16::fromInteger(scriptId))).FromMaybe(false))\n         return v8::Null(m_isolate);\n     if (!location->Set(context, toV8StringInternalized(m_isolate, \"lineNumber\"), v8::Integer::New(m_isolate, lineNumber)).FromMaybe(false))\n        return v8::Null(m_isolate);\n    if (!location->Set(context, toV8StringInternalized(m_isolate, \"columnNumber\"), v8::Integer::New(m_isolate, columnNumber)).FromMaybe(false))\n        return v8::Null(m_isolate);\n    if (!markAsInternal(context, location, V8InternalValueType::kLocation))\n        return v8::Null(m_isolate);\n    return location;\n}\n", "target": 1, "idx": 185978}
{"func": "static void *eval_map_start(struct seq_file *m, loff_t *pos)\n{\n\tunion trace_eval_map_item *v;\n\tloff_t l = 0;\n\n\tmutex_lock(&trace_eval_mutex);\n\n\tv = trace_eval_maps;\n\tif (v)\n\t\tv++;\n\n\twhile (v && l < *pos) {\n\t\tv = eval_map_next(m, v, &l);\n\t}\n\n\treturn v;\n}\n", "target": 0, "idx": 81272}
{"func": " bool Extension::HasAPIPermission(const std::string& function_name) const {\n   base::AutoLock auto_lock(runtime_data_lock_);\n   return runtime_data_.GetActivePermissions()->\n      HasAccessToFunction(function_name);\n }\n", "target": 1, "idx": 185049}
{"func": "static int opfiadd(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tif ( op->operands[0].type & OT_WORD ) {\n\t\t\t\tdata[l++] = 0xde;\n\t\t\t\tdata[l++] = 0x00 | op->operands[0].regs[0];\n\t\t\t} else if ( op->operands[0].type & OT_DWORD ) {\n\t\t\t\tdata[l++] = 0xda;\n\t\t\t\tdata[l++] = 0x00 | op->operands[0].regs[0];\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n", "target": 0, "idx": 75395}
{"func": "WebMediaPlayer::DisplayType HTMLMediaElement::DisplayType() const {\n  return IsFullscreen() ? WebMediaPlayer::DisplayType::kFullscreen\n                        : WebMediaPlayer::DisplayType::kInline;\n}\n", "target": 0, "idx": 142781}
{"func": "expand_string_internal(uschar *string, BOOL ket_ends, uschar **left,\n  BOOL skipping, BOOL honour_dollar, BOOL *resetok_p)\n{\nint ptr = 0;\nint size = Ustrlen(string)+ 64;\nint item_type;\nuschar *yield = store_get(size);\nuschar *s = string;\nuschar *save_expand_nstring[EXPAND_MAXN+1];\nint save_expand_nlength[EXPAND_MAXN+1];\nBOOL resetok = TRUE;\n\nexpand_string_forcedfail = FALSE;\nexpand_string_message = US\"\";\n\nwhile (*s != 0)\n  {\n  uschar *value;\n  uschar name[256];\n\n  /* \\ escapes the next character, which must exist, or else\n  the expansion fails. There's a special escape, \\N, which causes\n  copying of the subject verbatim up to the next \\N. Otherwise,\n  the escapes are the standard set. */\n\n  if (*s == '\\\\')\n    {\n    if (s[1] == 0)\n      {\n      expand_string_message = US\"\\\\ at end of string\";\n      goto EXPAND_FAILED;\n      }\n\n    if (s[1] == 'N')\n      {\n      uschar *t = s + 2;\n      for (s = t; *s != 0; s++) if (*s == '\\\\' && s[1] == 'N') break;\n      yield = string_cat(yield, &size, &ptr, t, s - t);\n      if (*s != 0) s += 2;\n      }\n\n    else\n      {\n      uschar ch[1];\n      ch[0] = string_interpret_escape(&s);\n      s++;\n      yield = string_cat(yield, &size, &ptr, ch, 1);\n      }\n\n    continue;\n    }\n\n  /*{*/\n  /* Anything other than $ is just copied verbatim, unless we are\n  looking for a terminating } character. */\n\n  /*{*/\n  if (ket_ends && *s == '}') break;\n\n  if (*s != '$' || !honour_dollar)\n    {\n    yield = string_cat(yield, &size, &ptr, s++, 1);\n    continue;\n    }\n\n  /* No { after the $ - must be a plain name or a number for string\n  match variable. There has to be a fudge for variables that are the\n  names of header fields preceded by \"$header_\" because header field\n  names can contain any printing characters except space and colon.\n  For those that don't like typing this much, \"$h_\" is a synonym for\n  \"$header_\". A non-existent header yields a NULL value; nothing is\n  inserted. */\t/*}*/\n\n  if (isalpha((*(++s))))\n    {\n    int len;\n    int newsize = 0;\n\n    s = read_name(name, sizeof(name), s, US\"_\");\n\n    /* If this is the first thing to be expanded, release the pre-allocated\n    buffer. */\n\n    if (ptr == 0 && yield != NULL)\n      {\n      if (resetok) store_reset(yield);\n      yield = NULL;\n      size = 0;\n      }\n\n    /* Header */\n\n    if (Ustrncmp(name, \"h_\", 2) == 0 ||\n        Ustrncmp(name, \"rh_\", 3) == 0 ||\n        Ustrncmp(name, \"bh_\", 3) == 0 ||\n        Ustrncmp(name, \"header_\", 7) == 0 ||\n        Ustrncmp(name, \"rheader_\", 8) == 0 ||\n        Ustrncmp(name, \"bheader_\", 8) == 0)\n      {\n      BOOL want_raw = (name[0] == 'r')? TRUE : FALSE;\n      uschar *charset = (name[0] == 'b')? NULL : headers_charset;\n      s = read_header_name(name, sizeof(name), s);\n      value = find_header(name, FALSE, &newsize, want_raw, charset);\n\n      /* If we didn't find the header, and the header contains a closing brace\n      character, this may be a user error where the terminating colon\n      has been omitted. Set a flag to adjust the error message in this case.\n      But there is no error here - nothing gets inserted. */\n\n      if (value == NULL)\n        {\n        if (Ustrchr(name, '}') != NULL) malformed_header = TRUE;\n        continue;\n        }\n      }\n\n    /* Variable */\n\n    else\n      {\n      value = find_variable(name, FALSE, skipping, &newsize);\n      if (value == NULL)\n        {\n        expand_string_message =\n          string_sprintf(\"unknown variable name \\\"%s\\\"\", name);\n          check_variable_error_message(name);\n        goto EXPAND_FAILED;\n        }\n      }\n\n    /* If the data is known to be in a new buffer, newsize will be set to the\n    size of that buffer. If this is the first thing in an expansion string,\n    yield will be NULL; just point it at the new store instead of copying. Many\n    expansion strings contain just one reference, so this is a useful\n    optimization, especially for humungous headers. */\n\n    len = Ustrlen(value);\n    if (yield == NULL && newsize != 0)\n      {\n      yield = value;\n      size = newsize;\n      ptr = len;\n      }\n    else yield = string_cat(yield, &size, &ptr, value, len);\n\n    continue;\n    }\n\n  if (isdigit(*s))\n    {\n    int n;\n    s = read_number(&n, s);\n    if (n >= 0 && n <= expand_nmax)\n      yield = string_cat(yield, &size, &ptr, expand_nstring[n],\n        expand_nlength[n]);\n    continue;\n    }\n\n  /* Otherwise, if there's no '{' after $ it's an error. */\t\t/*}*/\n\n  if (*s != '{')\t\t\t\t\t\t\t/*}*/\n    {\n    expand_string_message = US\"$ not followed by letter, digit, or {\";\t/*}*/\n    goto EXPAND_FAILED;\n    }\n\n  /* After { there can be various things, but they all start with\n  an initial word, except for a number for a string match variable. */\n\n  if (isdigit((*(++s))))\n    {\n    int n;\n    s = read_number(&n, s);\t\t/*{*/\n    if (*s++ != '}')\n      {\t\t\t\t\t/*{*/\n      expand_string_message = US\"} expected after number\";\n      goto EXPAND_FAILED;\n      }\n    if (n >= 0 && n <= expand_nmax)\n      yield = string_cat(yield, &size, &ptr, expand_nstring[n],\n        expand_nlength[n]);\n    continue;\n    }\n\n  if (!isalpha(*s))\n    {\n    expand_string_message = US\"letter or digit expected after ${\";\t/*}*/\n    goto EXPAND_FAILED;\n    }\n\n  /* Allow \"-\" in names to cater for substrings with negative\n  arguments. Since we are checking for known names after { this is\n  OK. */\n\n  s = read_name(name, sizeof(name), s, US\"_-\");\n  item_type = chop_match(name, item_table, sizeof(item_table)/sizeof(uschar *));\n\n  switch(item_type)\n    {\n    /* Call an ACL from an expansion.  We feed data in via $acl_arg1 - $acl_arg9.\n    If the ACL returns accept or reject we return content set by \"message =\"\n    There is currently no limit on recursion; this would have us call\n    acl_check_internal() directly and get a current level from somewhere.\n    See also the acl expansion condition ECOND_ACL and the traditional\n    acl modifier ACLC_ACL.\n    Assume that the function has side-effects on the store that must be preserved.\n    */\n\n    case EITEM_ACL:\n      /* ${acl {name} {arg1}{arg2}...} */\n      {\n      uschar *sub[10];\t/* name + arg1-arg9 (which must match number of acl_arg[]) */\n      uschar *user_msg;\n\n      switch(read_subs(sub, 10, 1, &s, skipping, TRUE, US\"acl\", &resetok))\n        {\n        case 1: goto EXPAND_FAILED_CURLY;\n        case 2:\n        case 3: goto EXPAND_FAILED;\n        }\n      if (skipping) continue;\n\n      resetok = FALSE;\n      switch(eval_acl(sub, sizeof(sub)/sizeof(*sub), &user_msg))\n\t{\n\tcase OK:\n\tcase FAIL:\n\t  DEBUG(D_expand)\n\t    debug_printf(\"acl expansion yield: %s\\n\", user_msg);\n\t  if (user_msg)\n            yield = string_cat(yield, &size, &ptr, user_msg, Ustrlen(user_msg));\n\t  continue;\n\n\tcase DEFER:\n          expand_string_forcedfail = TRUE;\n\tdefault:\n          expand_string_message = string_sprintf(\"error from acl \\\"%s\\\"\", sub[0]);\n\t  goto EXPAND_FAILED;\n\t}\n      }\n\n    /* Handle conditionals - preserve the values of the numerical expansion\n    variables in case they get changed by a regular expression match in the\n    condition. If not, they retain their external settings. At the end\n    of this \"if\" section, they get restored to their previous values. */\n\n    case EITEM_IF:\n      {\n      BOOL cond = FALSE;\n      uschar *next_s;\n      int save_expand_nmax =\n        save_expand_strings(save_expand_nstring, save_expand_nlength);\n\n      while (isspace(*s)) s++;\n      next_s = eval_condition(s, &resetok, skipping? NULL : &cond);\n      if (next_s == NULL) goto EXPAND_FAILED;  /* message already set */\n\n      DEBUG(D_expand)\n        debug_printf(\"condition: %.*s\\n   result: %s\\n\", (int)(next_s - s), s,\n          cond? \"true\" : \"false\");\n\n      s = next_s;\n\n      /* The handling of \"yes\" and \"no\" result strings is now in a separate\n      function that is also used by ${lookup} and ${extract} and ${run}. */\n\n      switch(process_yesno(\n               skipping,                     /* were previously skipping */\n               cond,                         /* success/failure indicator */\n               lookup_value,                 /* value to reset for string2 */\n               &s,                           /* input pointer */\n               &yield,                       /* output pointer */\n               &size,                        /* output size */\n               &ptr,                         /* output current point */\n               US\"if\",                       /* condition type */\n\t       &resetok))\n        {\n        case 1: goto EXPAND_FAILED;          /* when all is well, the */\n        case 2: goto EXPAND_FAILED_CURLY;    /* returned value is 0 */\n        }\n\n      /* Restore external setting of expansion variables for continuation\n      at this level. */\n\n      restore_expand_strings(save_expand_nmax, save_expand_nstring,\n        save_expand_nlength);\n      continue;\n      }\n\n    /* Handle database lookups unless locked out. If \"skipping\" is TRUE, we are\n    expanding an internal string that isn't actually going to be used. All we\n    need to do is check the syntax, so don't do a lookup at all. Preserve the\n    values of the numerical expansion variables in case they get changed by a\n    partial lookup. If not, they retain their external settings. At the end\n    of this \"lookup\" section, they get restored to their previous values. */\n\n    case EITEM_LOOKUP:\n      {\n      int stype, partial, affixlen, starflags;\n      int expand_setup = 0;\n      int nameptr = 0;\n      uschar *key, *filename, *affix;\n      uschar *save_lookup_value = lookup_value;\n      int save_expand_nmax =\n        save_expand_strings(save_expand_nstring, save_expand_nlength);\n\n      if ((expand_forbid & RDO_LOOKUP) != 0)\n        {\n        expand_string_message = US\"lookup expansions are not permitted\";\n        goto EXPAND_FAILED;\n        }\n\n      /* Get the key we are to look up for single-key+file style lookups.\n      Otherwise set the key NULL pro-tem. */\n\n      while (isspace(*s)) s++;\n      if (*s == '{')\t\t\t\t\t/*}*/\n        {\n        key = expand_string_internal(s+1, TRUE, &s, skipping, TRUE, &resetok);\n        if (key == NULL) goto EXPAND_FAILED;\t\t/*{*/\n        if (*s++ != '}') goto EXPAND_FAILED_CURLY;\n        while (isspace(*s)) s++;\n        }\n      else key = NULL;\n\n      /* Find out the type of database */\n\n      if (!isalpha(*s))\n        {\n        expand_string_message = US\"missing lookup type\";\n        goto EXPAND_FAILED;\n        }\n\n      /* The type is a string that may contain special characters of various\n      kinds. Allow everything except space or { to appear; the actual content\n      is checked by search_findtype_partial. */\t\t/*}*/\n\n      while (*s != 0 && *s != '{' && !isspace(*s))\t/*}*/\n        {\n        if (nameptr < sizeof(name) - 1) name[nameptr++] = *s;\n        s++;\n        }\n      name[nameptr] = 0;\n      while (isspace(*s)) s++;\n\n      /* Now check for the individual search type and any partial or default\n      options. Only those types that are actually in the binary are valid. */\n\n      stype = search_findtype_partial(name, &partial, &affix, &affixlen,\n        &starflags);\n      if (stype < 0)\n        {\n        expand_string_message = search_error_message;\n        goto EXPAND_FAILED;\n        }\n\n      /* Check that a key was provided for those lookup types that need it,\n      and was not supplied for those that use the query style. */\n\n      if (!mac_islookup(stype, lookup_querystyle|lookup_absfilequery))\n        {\n        if (key == NULL)\n          {\n          expand_string_message = string_sprintf(\"missing {key} for single-\"\n            \"key \\\"%s\\\" lookup\", name);\n          goto EXPAND_FAILED;\n          }\n        }\n      else\n        {\n        if (key != NULL)\n          {\n          expand_string_message = string_sprintf(\"a single key was given for \"\n            \"lookup type \\\"%s\\\", which is not a single-key lookup type\", name);\n          goto EXPAND_FAILED;\n          }\n        }\n\n      /* Get the next string in brackets and expand it. It is the file name for\n      single-key+file lookups, and the whole query otherwise. In the case of\n      queries that also require a file name (e.g. sqlite), the file name comes\n      first. */\n\n      if (*s != '{') goto EXPAND_FAILED_CURLY;\n      filename = expand_string_internal(s+1, TRUE, &s, skipping, TRUE, &resetok);\n      if (filename == NULL) goto EXPAND_FAILED;\n      if (*s++ != '}') goto EXPAND_FAILED_CURLY;\n      while (isspace(*s)) s++;\n\n      /* If this isn't a single-key+file lookup, re-arrange the variables\n      to be appropriate for the search_ functions. For query-style lookups,\n      there is just a \"key\", and no file name. For the special query-style +\n      file types, the query (i.e. \"key\") starts with a file name. */\n\n      if (key == NULL)\n        {\n        while (isspace(*filename)) filename++;\n        key = filename;\n\n        if (mac_islookup(stype, lookup_querystyle))\n          {\n          filename = NULL;\n          }\n        else\n          {\n          if (*filename != '/')\n            {\n            expand_string_message = string_sprintf(\n              \"absolute file name expected for \\\"%s\\\" lookup\", name);\n            goto EXPAND_FAILED;\n            }\n          while (*key != 0 && !isspace(*key)) key++;\n          if (*key != 0) *key++ = 0;\n          }\n        }\n\n      /* If skipping, don't do the next bit - just lookup_value == NULL, as if\n      the entry was not found. Note that there is no search_close() function.\n      Files are left open in case of re-use. At suitable places in higher logic,\n      search_tidyup() is called to tidy all open files. This can save opening\n      the same file several times. However, files may also get closed when\n      others are opened, if too many are open at once. The rule is that a\n      handle should not be used after a second search_open().\n\n      Request that a partial search sets up $1 and maybe $2 by passing\n      expand_setup containing zero. If its value changes, reset expand_nmax,\n      since new variables will have been set. Note that at the end of this\n      \"lookup\" section, the old numeric variables are restored. */\n\n      if (skipping)\n        lookup_value = NULL;\n      else\n        {\n        void *handle = search_open(filename, stype, 0, NULL, NULL);\n        if (handle == NULL)\n          {\n          expand_string_message = search_error_message;\n          goto EXPAND_FAILED;\n          }\n        lookup_value = search_find(handle, filename, key, partial, affix,\n          affixlen, starflags, &expand_setup);\n        if (search_find_defer)\n          {\n          expand_string_message =\n            string_sprintf(\"lookup of \\\"%s\\\" gave DEFER: %s\",\n              string_printing2(key, FALSE), search_error_message);\n          goto EXPAND_FAILED;\n          }\n        if (expand_setup > 0) expand_nmax = expand_setup;\n        }\n\n      /* The handling of \"yes\" and \"no\" result strings is now in a separate\n      function that is also used by ${if} and ${extract}. */\n\n      switch(process_yesno(\n               skipping,                     /* were previously skipping */\n               lookup_value != NULL,         /* success/failure indicator */\n               save_lookup_value,            /* value to reset for string2 */\n               &s,                           /* input pointer */\n               &yield,                       /* output pointer */\n               &size,                        /* output size */\n               &ptr,                         /* output current point */\n               US\"lookup\",                   /* condition type */\n\t       &resetok))\n        {\n        case 1: goto EXPAND_FAILED;          /* when all is well, the */\n        case 2: goto EXPAND_FAILED_CURLY;    /* returned value is 0 */\n        }\n\n      /* Restore external setting of expansion variables for carrying on\n      at this level, and continue. */\n\n      restore_expand_strings(save_expand_nmax, save_expand_nstring,\n        save_expand_nlength);\n      continue;\n      }\n\n    /* If Perl support is configured, handle calling embedded perl subroutines,\n    unless locked out at this time. Syntax is ${perl{sub}} or ${perl{sub}{arg}}\n    or ${perl{sub}{arg1}{arg2}} or up to a maximum of EXIM_PERL_MAX_ARGS\n    arguments (defined below). */\n\n    #define EXIM_PERL_MAX_ARGS 8\n\n    case EITEM_PERL:\n    #ifndef EXIM_PERL\n    expand_string_message = US\"\\\"${perl\\\" encountered, but this facility \"\t/*}*/\n      \"is not included in this binary\";\n    goto EXPAND_FAILED;\n\n    #else   /* EXIM_PERL */\n      {\n      uschar *sub_arg[EXIM_PERL_MAX_ARGS + 2];\n      uschar *new_yield;\n\n      if ((expand_forbid & RDO_PERL) != 0)\n        {\n        expand_string_message = US\"Perl calls are not permitted\";\n        goto EXPAND_FAILED;\n        }\n\n      switch(read_subs(sub_arg, EXIM_PERL_MAX_ARGS + 1, 1, &s, skipping, TRUE,\n           US\"perl\", &resetok))\n        {\n        case 1: goto EXPAND_FAILED_CURLY;\n        case 2:\n        case 3: goto EXPAND_FAILED;\n        }\n\n      /* If skipping, we don't actually do anything */\n\n      if (skipping) continue;\n\n      /* Start the interpreter if necessary */\n\n      if (!opt_perl_started)\n        {\n        uschar *initerror;\n        if (opt_perl_startup == NULL)\n          {\n          expand_string_message = US\"A setting of perl_startup is needed when \"\n            \"using the Perl interpreter\";\n          goto EXPAND_FAILED;\n          }\n        DEBUG(D_any) debug_printf(\"Starting Perl interpreter\\n\");\n        initerror = init_perl(opt_perl_startup);\n        if (initerror != NULL)\n          {\n          expand_string_message =\n            string_sprintf(\"error in perl_startup code: %s\\n\", initerror);\n          goto EXPAND_FAILED;\n          }\n        opt_perl_started = TRUE;\n        }\n\n      /* Call the function */\n\n      sub_arg[EXIM_PERL_MAX_ARGS + 1] = NULL;\n      new_yield = call_perl_cat(yield, &size, &ptr, &expand_string_message,\n        sub_arg[0], sub_arg + 1);\n\n      /* NULL yield indicates failure; if the message pointer has been set to\n      NULL, the yield was undef, indicating a forced failure. Otherwise the\n      message will indicate some kind of Perl error. */\n\n      if (new_yield == NULL)\n        {\n        if (expand_string_message == NULL)\n          {\n          expand_string_message =\n            string_sprintf(\"Perl subroutine \\\"%s\\\" returned undef to force \"\n              \"failure\", sub_arg[0]);\n          expand_string_forcedfail = TRUE;\n          }\n        goto EXPAND_FAILED;\n        }\n\n      /* Yield succeeded. Ensure forcedfail is unset, just in case it got\n      set during a callback from Perl. */\n\n      expand_string_forcedfail = FALSE;\n      yield = new_yield;\n      continue;\n      }\n    #endif /* EXIM_PERL */\n\n    /* Transform email address to \"prvs\" scheme to use\n       as BATV-signed return path */\n\n    case EITEM_PRVS:\n      {\n      uschar *sub_arg[3];\n      uschar *p,*domain;\n\n      switch(read_subs(sub_arg, 3, 2, &s, skipping, TRUE, US\"prvs\", &resetok))\n        {\n        case 1: goto EXPAND_FAILED_CURLY;\n        case 2:\n        case 3: goto EXPAND_FAILED;\n        }\n\n      /* If skipping, we don't actually do anything */\n      if (skipping) continue;\n\n      /* sub_arg[0] is the address */\n      domain = Ustrrchr(sub_arg[0],'@');\n      if ( (domain == NULL) || (domain == sub_arg[0]) || (Ustrlen(domain) == 1) )\n        {\n        expand_string_message = US\"prvs first argument must be a qualified email address\";\n        goto EXPAND_FAILED;\n        }\n\n      /* Calculate the hash. The second argument must be a single-digit\n      key number, or unset. */\n\n      if (sub_arg[2] != NULL &&\n          (!isdigit(sub_arg[2][0]) || sub_arg[2][1] != 0))\n        {\n        expand_string_message = US\"prvs second argument must be a single digit\";\n        goto EXPAND_FAILED;\n        }\n\n      p = prvs_hmac_sha1(sub_arg[0],sub_arg[1],sub_arg[2],prvs_daystamp(7));\n      if (p == NULL)\n        {\n        expand_string_message = US\"prvs hmac-sha1 conversion failed\";\n        goto EXPAND_FAILED;\n        }\n\n      /* Now separate the domain from the local part */\n      *domain++ = '\\0';\n\n      yield = string_cat(yield,&size,&ptr,US\"prvs=\",5);\n      string_cat(yield,&size,&ptr,(sub_arg[2] != NULL) ? sub_arg[2] : US\"0\", 1);\n      string_cat(yield,&size,&ptr,prvs_daystamp(7),3);\n      string_cat(yield,&size,&ptr,p,6);\n      string_cat(yield,&size,&ptr,US\"=\",1);\n      string_cat(yield,&size,&ptr,sub_arg[0],Ustrlen(sub_arg[0]));\n      string_cat(yield,&size,&ptr,US\"@\",1);\n      string_cat(yield,&size,&ptr,domain,Ustrlen(domain));\n\n      continue;\n      }\n\n    /* Check a prvs-encoded address for validity */\n\n    case EITEM_PRVSCHECK:\n      {\n      uschar *sub_arg[3];\n      int mysize = 0, myptr = 0;\n      const pcre *re;\n      uschar *p;\n\n      /* TF: Ugliness: We want to expand parameter 1 first, then set\n         up expansion variables that are used in the expansion of\n         parameter 2. So we clone the string for the first\n         expansion, where we only expand parameter 1.\n\n         PH: Actually, that isn't necessary. The read_subs() function is\n         designed to work this way for the ${if and ${lookup expansions. I've\n         tidied the code.\n      */\n\n      /* Reset expansion variables */\n      prvscheck_result = NULL;\n      prvscheck_address = NULL;\n      prvscheck_keynum = NULL;\n\n      switch(read_subs(sub_arg, 1, 1, &s, skipping, FALSE, US\"prvs\", &resetok))\n        {\n        case 1: goto EXPAND_FAILED_CURLY;\n        case 2:\n        case 3: goto EXPAND_FAILED;\n        }\n\n      re = regex_must_compile(US\"^prvs\\\\=([0-9])([0-9]{3})([A-F0-9]{6})\\\\=(.+)\\\\@(.+)$\",\n                              TRUE,FALSE);\n\n      if (regex_match_and_setup(re,sub_arg[0],0,-1))\n        {\n        uschar *local_part = string_copyn(expand_nstring[4],expand_nlength[4]);\n        uschar *key_num = string_copyn(expand_nstring[1],expand_nlength[1]);\n        uschar *daystamp = string_copyn(expand_nstring[2],expand_nlength[2]);\n        uschar *hash = string_copyn(expand_nstring[3],expand_nlength[3]);\n        uschar *domain = string_copyn(expand_nstring[5],expand_nlength[5]);\n\n        DEBUG(D_expand) debug_printf(\"prvscheck localpart: %s\\n\", local_part);\n        DEBUG(D_expand) debug_printf(\"prvscheck key number: %s\\n\", key_num);\n        DEBUG(D_expand) debug_printf(\"prvscheck daystamp: %s\\n\", daystamp);\n        DEBUG(D_expand) debug_printf(\"prvscheck hash: %s\\n\", hash);\n        DEBUG(D_expand) debug_printf(\"prvscheck domain: %s\\n\", domain);\n\n        /* Set up expansion variables */\n        prvscheck_address = string_cat(NULL, &mysize, &myptr, local_part, Ustrlen(local_part));\n        string_cat(prvscheck_address,&mysize,&myptr,US\"@\",1);\n        string_cat(prvscheck_address,&mysize,&myptr,domain,Ustrlen(domain));\n        prvscheck_address[myptr] = '\\0';\n        prvscheck_keynum = string_copy(key_num);\n\n        /* Now expand the second argument */\n        switch(read_subs(sub_arg, 1, 1, &s, skipping, FALSE, US\"prvs\", &resetok))\n          {\n          case 1: goto EXPAND_FAILED_CURLY;\n          case 2:\n          case 3: goto EXPAND_FAILED;\n          }\n\n        /* Now we have the key and can check the address. */\n\n        p = prvs_hmac_sha1(prvscheck_address, sub_arg[0], prvscheck_keynum,\n          daystamp);\n\n        if (p == NULL)\n          {\n          expand_string_message = US\"hmac-sha1 conversion failed\";\n          goto EXPAND_FAILED;\n          }\n\n        DEBUG(D_expand) debug_printf(\"prvscheck: received hash is %s\\n\", hash);\n        DEBUG(D_expand) debug_printf(\"prvscheck:      own hash is %s\\n\", p);\n\n        if (Ustrcmp(p,hash) == 0)\n          {\n          /* Success, valid BATV address. Now check the expiry date. */\n          uschar *now = prvs_daystamp(0);\n          unsigned int inow = 0,iexpire = 1;\n\n          (void)sscanf(CS now,\"%u\",&inow);\n          (void)sscanf(CS daystamp,\"%u\",&iexpire);\n\n          /* When \"iexpire\" is < 7, a \"flip\" has occured.\n             Adjust \"inow\" accordingly. */\n          if ( (iexpire < 7) && (inow >= 993) ) inow = 0;\n\n          if (iexpire >= inow)\n            {\n            prvscheck_result = US\"1\";\n            DEBUG(D_expand) debug_printf(\"prvscheck: success, $pvrs_result set to 1\\n\");\n            }\n            else\n            {\n            prvscheck_result = NULL;\n            DEBUG(D_expand) debug_printf(\"prvscheck: signature expired, $pvrs_result unset\\n\");\n            }\n          }\n        else\n          {\n          prvscheck_result = NULL;\n          DEBUG(D_expand) debug_printf(\"prvscheck: hash failure, $pvrs_result unset\\n\");\n          }\n\n        /* Now expand the final argument. We leave this till now so that\n        it can include $prvscheck_result. */\n\n        switch(read_subs(sub_arg, 1, 0, &s, skipping, TRUE, US\"prvs\", &resetok))\n          {\n          case 1: goto EXPAND_FAILED_CURLY;\n          case 2:\n          case 3: goto EXPAND_FAILED;\n          }\n\n        if (sub_arg[0] == NULL || *sub_arg[0] == '\\0')\n          yield = string_cat(yield,&size,&ptr,prvscheck_address,Ustrlen(prvscheck_address));\n        else\n          yield = string_cat(yield,&size,&ptr,sub_arg[0],Ustrlen(sub_arg[0]));\n\n        /* Reset the \"internal\" variables afterwards, because they are in\n        dynamic store that will be reclaimed if the expansion succeeded. */\n\n        prvscheck_address = NULL;\n        prvscheck_keynum = NULL;\n        }\n      else\n        {\n        /* Does not look like a prvs encoded address, return the empty string.\n           We need to make sure all subs are expanded first, so as to skip over\n           the entire item. */\n\n        switch(read_subs(sub_arg, 2, 1, &s, skipping, TRUE, US\"prvs\", &resetok))\n          {\n          case 1: goto EXPAND_FAILED_CURLY;\n          case 2:\n          case 3: goto EXPAND_FAILED;\n          }\n        }\n\n      continue;\n      }\n\n    /* Handle \"readfile\" to insert an entire file */\n\n    case EITEM_READFILE:\n      {\n      FILE *f;\n      uschar *sub_arg[2];\n\n      if ((expand_forbid & RDO_READFILE) != 0)\n        {\n        expand_string_message = US\"file insertions are not permitted\";\n        goto EXPAND_FAILED;\n        }\n\n      switch(read_subs(sub_arg, 2, 1, &s, skipping, TRUE, US\"readfile\", &resetok))\n        {\n        case 1: goto EXPAND_FAILED_CURLY;\n        case 2:\n        case 3: goto EXPAND_FAILED;\n        }\n\n      /* If skipping, we don't actually do anything */\n\n      if (skipping) continue;\n\n      /* Open the file and read it */\n\n      f = Ufopen(sub_arg[0], \"rb\");\n      if (f == NULL)\n        {\n        expand_string_message = string_open_failed(errno, \"%s\", sub_arg[0]);\n        goto EXPAND_FAILED;\n        }\n\n      yield = cat_file(f, yield, &size, &ptr, sub_arg[1]);\n      (void)fclose(f);\n      continue;\n      }\n\n    /* Handle \"readsocket\" to insert data from a Unix domain socket */\n\n    case EITEM_READSOCK:\n      {\n      int fd;\n      int timeout = 5;\n      int save_ptr = ptr;\n      FILE *f;\n      struct sockaddr_un sockun;         /* don't call this \"sun\" ! */\n      uschar *arg;\n      uschar *sub_arg[4];\n\n      if ((expand_forbid & RDO_READSOCK) != 0)\n        {\n        expand_string_message = US\"socket insertions are not permitted\";\n        goto EXPAND_FAILED;\n        }\n\n      /* Read up to 4 arguments, but don't do the end of item check afterwards,\n      because there may be a string for expansion on failure. */\n\n      switch(read_subs(sub_arg, 4, 2, &s, skipping, FALSE, US\"readsocket\", &resetok))\n        {\n        case 1: goto EXPAND_FAILED_CURLY;\n        case 2:                             /* Won't occur: no end check */\n        case 3: goto EXPAND_FAILED;\n        }\n\n      /* Sort out timeout, if given */\n\n      if (sub_arg[2] != NULL)\n        {\n        timeout = readconf_readtime(sub_arg[2], 0, FALSE);\n        if (timeout < 0)\n          {\n          expand_string_message = string_sprintf(\"bad time value %s\",\n            sub_arg[2]);\n          goto EXPAND_FAILED;\n          }\n        }\n      else sub_arg[3] = NULL;                     /* No eol if no timeout */\n\n      /* If skipping, we don't actually do anything. Otherwise, arrange to\n      connect to either an IP or a Unix socket. */\n\n      if (!skipping)\n        {\n        /* Handle an IP (internet) domain */\n\n        if (Ustrncmp(sub_arg[0], \"inet:\", 5) == 0)\n          {\n          int port;\n          uschar *server_name = sub_arg[0] + 5;\n          uschar *port_name = Ustrrchr(server_name, ':');\n\n          /* Sort out the port */\n\n          if (port_name == NULL)\n            {\n            expand_string_message =\n              string_sprintf(\"missing port for readsocket %s\", sub_arg[0]);\n            goto EXPAND_FAILED;\n            }\n          *port_name++ = 0;           /* Terminate server name */\n\n          if (isdigit(*port_name))\n            {\n            uschar *end;\n            port = Ustrtol(port_name, &end, 0);\n            if (end != port_name + Ustrlen(port_name))\n              {\n              expand_string_message =\n                string_sprintf(\"invalid port number %s\", port_name);\n              goto EXPAND_FAILED;\n              }\n            }\n          else\n            {\n            struct servent *service_info = getservbyname(CS port_name, \"tcp\");\n            if (service_info == NULL)\n              {\n              expand_string_message = string_sprintf(\"unknown port \\\"%s\\\"\",\n                port_name);\n              goto EXPAND_FAILED;\n              }\n            port = ntohs(service_info->s_port);\n            }\n\n\t  if ((fd = ip_connectedsocket(SOCK_STREAM, server_name, port, port,\n\t\t  timeout, NULL, &expand_string_message)) < 0)\n              goto SOCK_FAIL;\n          }\n\n        /* Handle a Unix domain socket */\n\n        else\n          {\n          int rc;\n          if ((fd = socket(PF_UNIX, SOCK_STREAM, 0)) == -1)\n            {\n            expand_string_message = string_sprintf(\"failed to create socket: %s\",\n              strerror(errno));\n            goto SOCK_FAIL;\n            }\n\n          sockun.sun_family = AF_UNIX;\n          sprintf(sockun.sun_path, \"%.*s\", (int)(sizeof(sockun.sun_path)-1),\n            sub_arg[0]);\n\n          sigalrm_seen = FALSE;\n          alarm(timeout);\n          rc = connect(fd, (struct sockaddr *)(&sockun), sizeof(sockun));\n          alarm(0);\n          if (sigalrm_seen)\n            {\n            expand_string_message = US \"socket connect timed out\";\n            goto SOCK_FAIL;\n            }\n          if (rc < 0)\n            {\n            expand_string_message = string_sprintf(\"failed to connect to socket \"\n              \"%s: %s\", sub_arg[0], strerror(errno));\n            goto SOCK_FAIL;\n            }\n          }\n\n        DEBUG(D_expand) debug_printf(\"connected to socket %s\\n\", sub_arg[0]);\n\n\t/* Allow sequencing of test actions */\n\tif (running_in_test_harness) millisleep(100);\n\n        /* Write the request string, if not empty */\n\n        if (sub_arg[1][0] != 0)\n          {\n          int len = Ustrlen(sub_arg[1]);\n          DEBUG(D_expand) debug_printf(\"writing \\\"%s\\\" to socket\\n\",\n            sub_arg[1]);\n          if (write(fd, sub_arg[1], len) != len)\n            {\n            expand_string_message = string_sprintf(\"request write to socket \"\n              \"failed: %s\", strerror(errno));\n            goto SOCK_FAIL;\n            }\n          }\n\n        /* Shut down the sending side of the socket. This helps some servers to\n        recognise that it is their turn to do some work. Just in case some\n        system doesn't have this function, make it conditional. */\n\n        #ifdef SHUT_WR\n        shutdown(fd, SHUT_WR);\n        #endif\n\n\tif (running_in_test_harness) millisleep(100);\n\n        /* Now we need to read from the socket, under a timeout. The function\n        that reads a file can be used. */\n\n        f = fdopen(fd, \"rb\");\n        sigalrm_seen = FALSE;\n        alarm(timeout);\n        yield = cat_file(f, yield, &size, &ptr, sub_arg[3]);\n        alarm(0);\n        (void)fclose(f);\n\n        /* After a timeout, we restore the pointer in the result, that is,\n        make sure we add nothing from the socket. */\n\n        if (sigalrm_seen)\n          {\n          ptr = save_ptr;\n          expand_string_message = US \"socket read timed out\";\n          goto SOCK_FAIL;\n          }\n        }\n\n      /* The whole thing has worked (or we were skipping). If there is a\n      failure string following, we need to skip it. */\n\n      if (*s == '{')\n        {\n        if (expand_string_internal(s+1, TRUE, &s, TRUE, TRUE, &resetok) == NULL)\n          goto EXPAND_FAILED;\n        if (*s++ != '}') goto EXPAND_FAILED_CURLY;\n        while (isspace(*s)) s++;\n        }\n      if (*s++ != '}') goto EXPAND_FAILED_CURLY;\n      continue;\n\n      /* Come here on failure to create socket, connect socket, write to the\n      socket, or timeout on reading. If another substring follows, expand and\n      use it. Otherwise, those conditions give expand errors. */\n\n      SOCK_FAIL:\n      if (*s != '{') goto EXPAND_FAILED;\n      DEBUG(D_any) debug_printf(\"%s\\n\", expand_string_message);\n      arg = expand_string_internal(s+1, TRUE, &s, FALSE, TRUE, &resetok);\n      if (arg == NULL) goto EXPAND_FAILED;\n      yield = string_cat(yield, &size, &ptr, arg, Ustrlen(arg));\n      if (*s++ != '}') goto EXPAND_FAILED_CURLY;\n      while (isspace(*s)) s++;\n      if (*s++ != '}') goto EXPAND_FAILED_CURLY;\n      continue;\n      }\n\n    /* Handle \"run\" to execute a program. */\n\n    case EITEM_RUN:\n      {\n      FILE *f;\n      uschar *arg;\n      uschar **argv;\n      pid_t pid;\n      int fd_in, fd_out;\n      int lsize = 0;\n      int lptr = 0;\n\n      if ((expand_forbid & RDO_RUN) != 0)\n        {\n        expand_string_message = US\"running a command is not permitted\";\n        goto EXPAND_FAILED;\n        }\n\n      while (isspace(*s)) s++;\n      if (*s != '{') goto EXPAND_FAILED_CURLY;\n      arg = expand_string_internal(s+1, TRUE, &s, skipping, TRUE, &resetok);\n      if (arg == NULL) goto EXPAND_FAILED;\n      while (isspace(*s)) s++;\n      if (*s++ != '}') goto EXPAND_FAILED_CURLY;\n\n      if (skipping)   /* Just pretend it worked when we're skipping */\n        {\n        runrc = 0;\n        }\n      else\n        {\n        if (!transport_set_up_command(&argv,    /* anchor for arg list */\n            arg,                                /* raw command */\n            FALSE,                              /* don't expand the arguments */\n            0,                                  /* not relevant when... */\n            NULL,                               /* no transporting address */\n            US\"${run} expansion\",               /* for error messages */\n            &expand_string_message))            /* where to put error message */\n          {\n          goto EXPAND_FAILED;\n          }\n\n        /* Create the child process, making it a group leader. */\n\n        pid = child_open(argv, NULL, 0077, &fd_in, &fd_out, TRUE);\n\n        if (pid < 0)\n          {\n          expand_string_message =\n            string_sprintf(\"couldn't create child process: %s\", strerror(errno));\n          goto EXPAND_FAILED;\n          }\n\n        /* Nothing is written to the standard input. */\n\n        (void)close(fd_in);\n\n        /* Read the pipe to get the command's output into $value (which is kept\n        in lookup_value). Read during execution, so that if the output exceeds\n        the OS pipe buffer limit, we don't block forever. */\n\n        f = fdopen(fd_out, \"rb\");\n        sigalrm_seen = FALSE;\n        alarm(60);\n        lookup_value = cat_file(f, lookup_value, &lsize, &lptr, NULL);\n        alarm(0);\n        (void)fclose(f);\n\n        /* Wait for the process to finish, applying the timeout, and inspect its\n        return code for serious disasters. Simple non-zero returns are passed on.\n        */\n\n        if (sigalrm_seen == TRUE || (runrc = child_close(pid, 30)) < 0)\n          {\n          if (sigalrm_seen == TRUE || runrc == -256)\n            {\n            expand_string_message = string_sprintf(\"command timed out\");\n            killpg(pid, SIGKILL);       /* Kill the whole process group */\n            }\n\n          else if (runrc == -257)\n            expand_string_message = string_sprintf(\"wait() failed: %s\",\n              strerror(errno));\n\n          else\n            expand_string_message = string_sprintf(\"command killed by signal %d\",\n              -runrc);\n\n          goto EXPAND_FAILED;\n          }\n        }\n\n      /* Process the yes/no strings; $value may be useful in both cases */\n\n      switch(process_yesno(\n               skipping,                     /* were previously skipping */\n               runrc == 0,                   /* success/failure indicator */\n               lookup_value,                 /* value to reset for string2 */\n               &s,                           /* input pointer */\n               &yield,                       /* output pointer */\n               &size,                        /* output size */\n               &ptr,                         /* output current point */\n               US\"run\",                      /* condition type */\n\t       &resetok))\n        {\n        case 1: goto EXPAND_FAILED;          /* when all is well, the */\n        case 2: goto EXPAND_FAILED_CURLY;    /* returned value is 0 */\n        }\n\n      continue;\n      }\n\n    /* Handle character translation for \"tr\" */\n\n    case EITEM_TR:\n      {\n      int oldptr = ptr;\n      int o2m;\n      uschar *sub[3];\n\n      switch(read_subs(sub, 3, 3, &s, skipping, TRUE, US\"tr\", &resetok))\n        {\n        case 1: goto EXPAND_FAILED_CURLY;\n        case 2:\n        case 3: goto EXPAND_FAILED;\n        }\n\n      yield = string_cat(yield, &size, &ptr, sub[0], Ustrlen(sub[0]));\n      o2m = Ustrlen(sub[2]) - 1;\n\n      if (o2m >= 0) for (; oldptr < ptr; oldptr++)\n        {\n        uschar *m = Ustrrchr(sub[1], yield[oldptr]);\n        if (m != NULL)\n          {\n          int o = m - sub[1];\n          yield[oldptr] = sub[2][(o < o2m)? o : o2m];\n          }\n        }\n\n      continue;\n      }\n\n    /* Handle \"hash\", \"length\", \"nhash\", and \"substr\" when they are given with\n    expanded arguments. */\n\n    case EITEM_HASH:\n    case EITEM_LENGTH:\n    case EITEM_NHASH:\n    case EITEM_SUBSTR:\n      {\n      int i;\n      int len;\n      uschar *ret;\n      int val[2] = { 0, -1 };\n      uschar *sub[3];\n\n      /* \"length\" takes only 2 arguments whereas the others take 2 or 3.\n      Ensure that sub[2] is set in the ${length } case. */\n\n      sub[2] = NULL;\n      switch(read_subs(sub, (item_type == EITEM_LENGTH)? 2:3, 2, &s, skipping,\n             TRUE, name, &resetok))\n        {\n        case 1: goto EXPAND_FAILED_CURLY;\n        case 2:\n        case 3: goto EXPAND_FAILED;\n        }\n\n      /* Juggle the arguments if there are only two of them: always move the\n      string to the last position and make ${length{n}{str}} equivalent to\n      ${substr{0}{n}{str}}. See the defaults for val[] above. */\n\n      if (sub[2] == NULL)\n        {\n        sub[2] = sub[1];\n        sub[1] = NULL;\n        if (item_type == EITEM_LENGTH)\n          {\n          sub[1] = sub[0];\n          sub[0] = NULL;\n          }\n        }\n\n      for (i = 0; i < 2; i++)\n        {\n        if (sub[i] == NULL) continue;\n        val[i] = (int)Ustrtol(sub[i], &ret, 10);\n        if (*ret != 0 || (i != 0 && val[i] < 0))\n          {\n          expand_string_message = string_sprintf(\"\\\"%s\\\" is not a%s number \"\n            \"(in \\\"%s\\\" expansion)\", sub[i], (i != 0)? \" positive\" : \"\", name);\n          goto EXPAND_FAILED;\n          }\n        }\n\n      ret =\n        (item_type == EITEM_HASH)?\n          compute_hash(sub[2], val[0], val[1], &len) :\n        (item_type == EITEM_NHASH)?\n          compute_nhash(sub[2], val[0], val[1], &len) :\n          extract_substr(sub[2], val[0], val[1], &len);\n\n      if (ret == NULL) goto EXPAND_FAILED;\n      yield = string_cat(yield, &size, &ptr, ret, len);\n      continue;\n      }\n\n    /* Handle HMAC computation: ${hmac{<algorithm>}{<secret>}{<text>}}\n    This code originally contributed by Steve Haslam. It currently supports\n    the use of MD5 and SHA-1 hashes.\n\n    We need some workspace that is large enough to handle all the supported\n    hash types. Use macros to set the sizes rather than be too elaborate. */\n\n    #define MAX_HASHLEN      20\n    #define MAX_HASHBLOCKLEN 64\n\n    case EITEM_HMAC:\n      {\n      uschar *sub[3];\n      md5 md5_base;\n      sha1 sha1_base;\n      void *use_base;\n      int type, i;\n      int hashlen;      /* Number of octets for the hash algorithm's output */\n      int hashblocklen; /* Number of octets the hash algorithm processes */\n      uschar *keyptr, *p;\n      unsigned int keylen;\n\n      uschar keyhash[MAX_HASHLEN];\n      uschar innerhash[MAX_HASHLEN];\n      uschar finalhash[MAX_HASHLEN];\n      uschar finalhash_hex[2*MAX_HASHLEN];\n      uschar innerkey[MAX_HASHBLOCKLEN];\n      uschar outerkey[MAX_HASHBLOCKLEN];\n\n      switch (read_subs(sub, 3, 3, &s, skipping, TRUE, name, &resetok))\n        {\n        case 1: goto EXPAND_FAILED_CURLY;\n        case 2:\n        case 3: goto EXPAND_FAILED;\n        }\n\n      if (Ustrcmp(sub[0], \"md5\") == 0)\n        {\n        type = HMAC_MD5;\n        use_base = &md5_base;\n        hashlen = 16;\n        hashblocklen = 64;\n        }\n      else if (Ustrcmp(sub[0], \"sha1\") == 0)\n        {\n        type = HMAC_SHA1;\n        use_base = &sha1_base;\n        hashlen = 20;\n        hashblocklen = 64;\n        }\n      else\n        {\n        expand_string_message =\n          string_sprintf(\"hmac algorithm \\\"%s\\\" is not recognised\", sub[0]);\n        goto EXPAND_FAILED;\n        }\n\n      keyptr = sub[1];\n      keylen = Ustrlen(keyptr);\n\n      /* If the key is longer than the hash block length, then hash the key\n      first */\n\n      if (keylen > hashblocklen)\n        {\n        chash_start(type, use_base);\n        chash_end(type, use_base, keyptr, keylen, keyhash);\n        keyptr = keyhash;\n        keylen = hashlen;\n        }\n\n      /* Now make the inner and outer key values */\n\n      memset(innerkey, 0x36, hashblocklen);\n      memset(outerkey, 0x5c, hashblocklen);\n\n      for (i = 0; i < keylen; i++)\n        {\n        innerkey[i] ^= keyptr[i];\n        outerkey[i] ^= keyptr[i];\n        }\n\n      /* Now do the hashes */\n\n      chash_start(type, use_base);\n      chash_mid(type, use_base, innerkey);\n      chash_end(type, use_base, sub[2], Ustrlen(sub[2]), innerhash);\n\n      chash_start(type, use_base);\n      chash_mid(type, use_base, outerkey);\n      chash_end(type, use_base, innerhash, hashlen, finalhash);\n\n      /* Encode the final hash as a hex string */\n\n      p = finalhash_hex;\n      for (i = 0; i < hashlen; i++)\n        {\n        *p++ = hex_digits[(finalhash[i] & 0xf0) >> 4];\n        *p++ = hex_digits[finalhash[i] & 0x0f];\n        }\n\n      DEBUG(D_any) debug_printf(\"HMAC[%s](%.*s,%.*s)=%.*s\\n\", sub[0],\n        (int)keylen, keyptr, Ustrlen(sub[2]), sub[2], hashlen*2, finalhash_hex);\n\n      yield = string_cat(yield, &size, &ptr, finalhash_hex, hashlen*2);\n      }\n\n    continue;\n\n    /* Handle global substitution for \"sg\" - like Perl's s/xxx/yyy/g operator.\n    We have to save the numerical variables and restore them afterwards. */\n\n    case EITEM_SG:\n      {\n      const pcre *re;\n      int moffset, moffsetextra, slen;\n      int roffset;\n      int emptyopt;\n      const uschar *rerror;\n      uschar *subject;\n      uschar *sub[3];\n      int save_expand_nmax =\n        save_expand_strings(save_expand_nstring, save_expand_nlength);\n\n      switch(read_subs(sub, 3, 3, &s, skipping, TRUE, US\"sg\", &resetok))\n        {\n        case 1: goto EXPAND_FAILED_CURLY;\n        case 2:\n        case 3: goto EXPAND_FAILED;\n        }\n\n      /* Compile the regular expression */\n\n      re = pcre_compile(CS sub[1], PCRE_COPT, (const char **)&rerror, &roffset,\n        NULL);\n\n      if (re == NULL)\n        {\n        expand_string_message = string_sprintf(\"regular expression error in \"\n          \"\\\"%s\\\": %s at offset %d\", sub[1], rerror, roffset);\n        goto EXPAND_FAILED;\n        }\n\n      /* Now run a loop to do the substitutions as often as necessary. It ends\n      when there are no more matches. Take care over matches of the null string;\n      do the same thing as Perl does. */\n\n      subject = sub[0];\n      slen = Ustrlen(sub[0]);\n      moffset = moffsetextra = 0;\n      emptyopt = 0;\n\n      for (;;)\n        {\n        int ovector[3*(EXPAND_MAXN+1)];\n        int n = pcre_exec(re, NULL, CS subject, slen, moffset + moffsetextra,\n          PCRE_EOPT | emptyopt, ovector, sizeof(ovector)/sizeof(int));\n        int nn;\n        uschar *insert;\n\n        /* No match - if we previously set PCRE_NOTEMPTY after a null match, this\n        is not necessarily the end. We want to repeat the match from one\n        character further along, but leaving the basic offset the same (for\n        copying below). We can't be at the end of the string - that was checked\n        before setting PCRE_NOTEMPTY. If PCRE_NOTEMPTY is not set, we are\n        finished; copy the remaining string and end the loop. */\n\n        if (n < 0)\n          {\n          if (emptyopt != 0)\n            {\n            moffsetextra = 1;\n            emptyopt = 0;\n            continue;\n            }\n          yield = string_cat(yield, &size, &ptr, subject+moffset, slen-moffset);\n          break;\n          }\n\n        /* Match - set up for expanding the replacement. */\n\n        if (n == 0) n = EXPAND_MAXN + 1;\n        expand_nmax = 0;\n        for (nn = 0; nn < n*2; nn += 2)\n          {\n          expand_nstring[expand_nmax] = subject + ovector[nn];\n          expand_nlength[expand_nmax++] = ovector[nn+1] - ovector[nn];\n          }\n        expand_nmax--;\n\n        /* Copy the characters before the match, plus the expanded insertion. */\n\n        yield = string_cat(yield, &size, &ptr, subject + moffset,\n          ovector[0] - moffset);\n        insert = expand_string(sub[2]);\n        if (insert == NULL) goto EXPAND_FAILED;\n        yield = string_cat(yield, &size, &ptr, insert, Ustrlen(insert));\n\n        moffset = ovector[1];\n        moffsetextra = 0;\n        emptyopt = 0;\n\n        /* If we have matched an empty string, first check to see if we are at\n        the end of the subject. If so, the loop is over. Otherwise, mimic\n        what Perl's /g options does. This turns out to be rather cunning. First\n        we set PCRE_NOTEMPTY and PCRE_ANCHORED and try the match a non-empty\n        string at the same point. If this fails (picked up above) we advance to\n        the next character. */\n\n        if (ovector[0] == ovector[1])\n          {\n          if (ovector[0] == slen) break;\n          emptyopt = PCRE_NOTEMPTY | PCRE_ANCHORED;\n          }\n        }\n\n      /* All done - restore numerical variables. */\n\n      restore_expand_strings(save_expand_nmax, save_expand_nstring,\n        save_expand_nlength);\n      continue;\n      }\n\n    /* Handle keyed and numbered substring extraction. If the first argument\n    consists entirely of digits, then a numerical extraction is assumed. */\n\n    case EITEM_EXTRACT:\n      {\n      int i;\n      int j = 2;\n      int field_number = 1;\n      BOOL field_number_set = FALSE;\n      uschar *save_lookup_value = lookup_value;\n      uschar *sub[3];\n      int save_expand_nmax =\n        save_expand_strings(save_expand_nstring, save_expand_nlength);\n\n      /* Read the arguments */\n\n      for (i = 0; i < j; i++)\n        {\n        while (isspace(*s)) s++;\n        if (*s == '{') \t\t\t\t\t\t/*}*/\n          {\n          sub[i] = expand_string_internal(s+1, TRUE, &s, skipping, TRUE, &resetok);\n          if (sub[i] == NULL) goto EXPAND_FAILED;\t\t/*{*/\n          if (*s++ != '}') goto EXPAND_FAILED_CURLY;\n\n          /* After removal of leading and trailing white space, the first\n          argument must not be empty; if it consists entirely of digits\n          (optionally preceded by a minus sign), this is a numerical\n          extraction, and we expect 3 arguments. */\n\n          if (i == 0)\n            {\n            int len;\n            int x = 0;\n            uschar *p = sub[0];\n\n            while (isspace(*p)) p++;\n            sub[0] = p;\n\n            len = Ustrlen(p);\n            while (len > 0 && isspace(p[len-1])) len--;\n            p[len] = 0;\n\n            if (*p == 0 && !skipping)\n              {\n              expand_string_message = US\"first argument of \\\"extract\\\" must \"\n                \"not be empty\";\n              goto EXPAND_FAILED;\n              }\n\n            if (*p == '-')\n              {\n              field_number = -1;\n              p++;\n              }\n            while (*p != 0 && isdigit(*p)) x = x * 10 + *p++ - '0';\n            if (*p == 0)\n              {\n              field_number *= x;\n              j = 3;               /* Need 3 args */\n              field_number_set = TRUE;\n              }\n            }\n          }\n        else goto EXPAND_FAILED_CURLY;\n        }\n\n      /* Extract either the numbered or the keyed substring into $value. If\n      skipping, just pretend the extraction failed. */\n\n      lookup_value = skipping? NULL : field_number_set?\n        expand_gettokened(field_number, sub[1], sub[2]) :\n        expand_getkeyed(sub[0], sub[1]);\n\n      /* If no string follows, $value gets substituted; otherwise there can\n      be yes/no strings, as for lookup or if. */\n\n      switch(process_yesno(\n               skipping,                     /* were previously skipping */\n               lookup_value != NULL,         /* success/failure indicator */\n               save_lookup_value,            /* value to reset for string2 */\n               &s,                           /* input pointer */\n               &yield,                       /* output pointer */\n               &size,                        /* output size */\n               &ptr,                         /* output current point */\n               US\"extract\",                  /* condition type */\n\t       &resetok))\n        {\n        case 1: goto EXPAND_FAILED;          /* when all is well, the */\n        case 2: goto EXPAND_FAILED_CURLY;    /* returned value is 0 */\n        }\n\n      /* All done - restore numerical variables. */\n\n      restore_expand_strings(save_expand_nmax, save_expand_nstring,\n        save_expand_nlength);\n\n      continue;\n      }\n\n    /* return the Nth item from a list */\n\n    case EITEM_LISTEXTRACT:\n      {\n      int i;\n      int field_number = 1;\n      uschar *save_lookup_value = lookup_value;\n      uschar *sub[2];\n      int save_expand_nmax =\n        save_expand_strings(save_expand_nstring, save_expand_nlength);\n\n      /* Read the field & list arguments */\n\n      for (i = 0; i < 2; i++)\n        {\n        while (isspace(*s)) s++;\n        if (*s != '{')\t\t\t\t\t/*}*/\n\t  goto EXPAND_FAILED_CURLY;\n\n\tsub[i] = expand_string_internal(s+1, TRUE, &s, skipping, TRUE, &resetok);\n\tif (!sub[i])     goto EXPAND_FAILED;\t\t/*{*/\n\tif (*s++ != '}') goto EXPAND_FAILED_CURLY;\n\n\t/* After removal of leading and trailing white space, the first\n\targument must be numeric and nonempty. */\n\n\tif (i == 0)\n\t  {\n\t  int len;\n\t  int x = 0;\n\t  uschar *p = sub[0];\n\n\t  while (isspace(*p)) p++;\n\t  sub[0] = p;\n\n\t  len = Ustrlen(p);\n\t  while (len > 0 && isspace(p[len-1])) len--;\n\t  p[len] = 0;\n\n\t  if (!*p && !skipping)\n\t    {\n\t    expand_string_message = US\"first argument of \\\"listextract\\\" must \"\n\t      \"not be empty\";\n\t    goto EXPAND_FAILED;\n\t    }\n\n\t  if (*p == '-')\n\t    {\n\t    field_number = -1;\n\t    p++;\n\t    }\n\t  while (*p && isdigit(*p)) x = x * 10 + *p++ - '0';\n\t  if (*p)\n\t    {\n\t    expand_string_message = US\"first argument of \\\"listextract\\\" must \"\n\t      \"be numeric\";\n\t    goto EXPAND_FAILED;\n\t    }\n\t  field_number *= x;\n\t  }\n        }\n\n      /* Extract the numbered element into $value. If\n      skipping, just pretend the extraction failed. */\n\n      lookup_value = skipping? NULL : expand_getlistele(field_number, sub[1]);\n\n      /* If no string follows, $value gets substituted; otherwise there can\n      be yes/no strings, as for lookup or if. */\n\n      switch(process_yesno(\n               skipping,                     /* were previously skipping */\n               lookup_value != NULL,         /* success/failure indicator */\n               save_lookup_value,            /* value to reset for string2 */\n               &s,                           /* input pointer */\n               &yield,                       /* output pointer */\n               &size,                        /* output size */\n               &ptr,                         /* output current point */\n               US\"extract\",                  /* condition type */\n\t       &resetok))\n        {\n        case 1: goto EXPAND_FAILED;          /* when all is well, the */\n        case 2: goto EXPAND_FAILED_CURLY;    /* returned value is 0 */\n        }\n\n      /* All done - restore numerical variables. */\n\n      restore_expand_strings(save_expand_nmax, save_expand_nstring,\n        save_expand_nlength);\n\n      continue;\n      }\n\n#ifdef SUPPORT_TLS\n    case EITEM_CERTEXTRACT:\n      {\n      uschar *save_lookup_value = lookup_value;\n      uschar *sub[2];\n      int save_expand_nmax =\n        save_expand_strings(save_expand_nstring, save_expand_nlength);\n\n      /* Read the field argument */\n      while (isspace(*s)) s++;\n      if (*s != '{')\t\t\t\t\t/*}*/\n\tgoto EXPAND_FAILED_CURLY;\n      sub[0] = expand_string_internal(s+1, TRUE, &s, skipping, TRUE, &resetok);\n      if (!sub[0])     goto EXPAND_FAILED;\t\t/*{*/\n      if (*s++ != '}') goto EXPAND_FAILED_CURLY;\n      /* strip spaces fore & aft */\n      {\n      int len;\n      uschar *p = sub[0];\n\n      while (isspace(*p)) p++;\n      sub[0] = p;\n\n      len = Ustrlen(p);\n      while (len > 0 && isspace(p[len-1])) len--;\n      p[len] = 0;\n      }\n\n      /* inspect the cert argument */\n      while (isspace(*s)) s++;\n      if (*s != '{')\t\t\t\t\t/*}*/\n\tgoto EXPAND_FAILED_CURLY;\n      if (*++s != '$')\n        {\n\texpand_string_message = US\"second argument of \\\"certextract\\\" must \"\n\t  \"be a certificate variable\";\n\tgoto EXPAND_FAILED;\n\t}\n      sub[1] = expand_string_internal(s+1, TRUE, &s, skipping, FALSE, &resetok);\n      if (!sub[1])     goto EXPAND_FAILED;\t\t/*{*/\n      if (*s++ != '}') goto EXPAND_FAILED_CURLY;\n\n      if (skipping)\n\tlookup_value = NULL;\n      else\n\t{\n\tlookup_value = expand_getcertele(sub[0], sub[1]);\n\tif (*expand_string_message) goto EXPAND_FAILED;\n\t}\n      switch(process_yesno(\n               skipping,                     /* were previously skipping */\n               lookup_value != NULL,         /* success/failure indicator */\n               save_lookup_value,            /* value to reset for string2 */\n               &s,                           /* input pointer */\n               &yield,                       /* output pointer */\n               &size,                        /* output size */\n               &ptr,                         /* output current point */\n               US\"extract\",                  /* condition type */\n\t       &resetok))\n        {\n        case 1: goto EXPAND_FAILED;          /* when all is well, the */\n        case 2: goto EXPAND_FAILED_CURLY;    /* returned value is 0 */\n        }\n\n      restore_expand_strings(save_expand_nmax, save_expand_nstring,\n        save_expand_nlength);\n      continue;\n      }\n#endif\t/*SUPPORT_TLS*/\n\n    /* Handle list operations */\n\n    case EITEM_FILTER:\n    case EITEM_MAP:\n    case EITEM_REDUCE:\n      {\n      int sep = 0;\n      int save_ptr = ptr;\n      uschar outsep[2] = { '\\0', '\\0' };\n      uschar *list, *expr, *temp;\n      uschar *save_iterate_item = iterate_item;\n      uschar *save_lookup_value = lookup_value;\n\n      while (isspace(*s)) s++;\n      if (*s++ != '{') goto EXPAND_FAILED_CURLY;\n\n      list = expand_string_internal(s, TRUE, &s, skipping, TRUE, &resetok);\n      if (list == NULL) goto EXPAND_FAILED;\n      if (*s++ != '}') goto EXPAND_FAILED_CURLY;\n\n      if (item_type == EITEM_REDUCE)\n        {\n        while (isspace(*s)) s++;\n        if (*s++ != '{') goto EXPAND_FAILED_CURLY;\n        temp = expand_string_internal(s, TRUE, &s, skipping, TRUE, &resetok);\n        if (temp == NULL) goto EXPAND_FAILED;\n        lookup_value = temp;\n        if (*s++ != '}') goto EXPAND_FAILED_CURLY;\n        }\n\n      while (isspace(*s)) s++;\n      if (*s++ != '{') goto EXPAND_FAILED_CURLY;\n\n      expr = s;\n\n      /* For EITEM_FILTER, call eval_condition once, with result discarded (as\n      if scanning a \"false\" part). This allows us to find the end of the\n      condition, because if the list is empty, we won't actually evaluate the\n      condition for real. For EITEM_MAP and EITEM_REDUCE, do the same, using\n      the normal internal expansion function. */\n\n      if (item_type == EITEM_FILTER)\n        {\n        temp = eval_condition(expr, &resetok, NULL);\n        if (temp != NULL) s = temp;\n        }\n      else\n        {\n        temp = expand_string_internal(s, TRUE, &s, TRUE, TRUE, &resetok);\n        }\n\n      if (temp == NULL)\n        {\n        expand_string_message = string_sprintf(\"%s inside \\\"%s\\\" item\",\n          expand_string_message, name);\n        goto EXPAND_FAILED;\n        }\n\n      while (isspace(*s)) s++;\n      if (*s++ != '}')\n        {\t\t\t\t\t\t/*{*/\n        expand_string_message = string_sprintf(\"missing } at end of condition \"\n          \"or expression inside \\\"%s\\\"\", name);\n        goto EXPAND_FAILED;\n        }\n\n      while (isspace(*s)) s++;\t\t\t\t/*{*/\n      if (*s++ != '}')\n        {\t\t\t\t\t\t/*{*/\n        expand_string_message = string_sprintf(\"missing } at end of \\\"%s\\\"\",\n          name);\n        goto EXPAND_FAILED;\n        }\n\n      /* If we are skipping, we can now just move on to the next item. When\n      processing for real, we perform the iteration. */\n\n      if (skipping) continue;\n      while ((iterate_item = string_nextinlist(&list, &sep, NULL, 0)) != NULL)\n        {\n        *outsep = (uschar)sep;      /* Separator as a string */\n\n        DEBUG(D_expand) debug_printf(\"%s: $item = \\\"%s\\\"\\n\", name, iterate_item);\n\n        if (item_type == EITEM_FILTER)\n          {\n          BOOL condresult;\n          if (eval_condition(expr, &resetok, &condresult) == NULL)\n            {\n            iterate_item = save_iterate_item;\n            lookup_value = save_lookup_value;\n            expand_string_message = string_sprintf(\"%s inside \\\"%s\\\" condition\",\n              expand_string_message, name);\n            goto EXPAND_FAILED;\n            }\n          DEBUG(D_expand) debug_printf(\"%s: condition is %s\\n\", name,\n            condresult? \"true\":\"false\");\n          if (condresult)\n            temp = iterate_item;    /* TRUE => include this item */\n          else\n            continue;               /* FALSE => skip this item */\n          }\n\n        /* EITEM_MAP and EITEM_REDUCE */\n\n        else\n          {\n          temp = expand_string_internal(expr, TRUE, NULL, skipping, TRUE, &resetok);\n          if (temp == NULL)\n            {\n            iterate_item = save_iterate_item;\n            expand_string_message = string_sprintf(\"%s inside \\\"%s\\\" item\",\n              expand_string_message, name);\n            goto EXPAND_FAILED;\n            }\n          if (item_type == EITEM_REDUCE)\n            {\n            lookup_value = temp;      /* Update the value of $value */\n            continue;                 /* and continue the iteration */\n            }\n          }\n\n        /* We reach here for FILTER if the condition is true, always for MAP,\n        and never for REDUCE. The value in \"temp\" is to be added to the output\n        list that is being created, ensuring that any occurrences of the\n        separator character are doubled. Unless we are dealing with the first\n        item of the output list, add in a space if the new item begins with the\n        separator character, or is an empty string. */\n\n        if (ptr != save_ptr && (temp[0] == *outsep || temp[0] == 0))\n          yield = string_cat(yield, &size, &ptr, US\" \", 1);\n\n        /* Add the string in \"temp\" to the output list that we are building,\n        This is done in chunks by searching for the separator character. */\n\n        for (;;)\n          {\n          size_t seglen = Ustrcspn(temp, outsep);\n            yield = string_cat(yield, &size, &ptr, temp, seglen + 1);\n\n          /* If we got to the end of the string we output one character\n          too many; backup and end the loop. Otherwise arrange to double the\n          separator. */\n\n          if (temp[seglen] == '\\0') { ptr--; break; }\n          yield = string_cat(yield, &size, &ptr, outsep, 1);\n          temp += seglen + 1;\n          }\n\n        /* Output a separator after the string: we will remove the redundant\n        final one at the end. */\n\n        yield = string_cat(yield, &size, &ptr, outsep, 1);\n        }   /* End of iteration over the list loop */\n\n      /* REDUCE has generated no output above: output the final value of\n      $value. */\n\n      if (item_type == EITEM_REDUCE)\n        {\n        yield = string_cat(yield, &size, &ptr, lookup_value,\n          Ustrlen(lookup_value));\n        lookup_value = save_lookup_value;  /* Restore $value */\n        }\n\n      /* FILTER and MAP generate lists: if they have generated anything, remove\n      the redundant final separator. Even though an empty item at the end of a\n      list does not count, this is tidier. */\n\n      else if (ptr != save_ptr) ptr--;\n\n      /* Restore preserved $item */\n\n      iterate_item = save_iterate_item;\n      continue;\n      }\n\n\n    /* If ${dlfunc } support is configured, handle calling dynamically-loaded\n    functions, unless locked out at this time. Syntax is ${dlfunc{file}{func}}\n    or ${dlfunc{file}{func}{arg}} or ${dlfunc{file}{func}{arg1}{arg2}} or up to\n    a maximum of EXPAND_DLFUNC_MAX_ARGS arguments (defined below). */\n\n    #define EXPAND_DLFUNC_MAX_ARGS 8\n\n    case EITEM_DLFUNC:\n    #ifndef EXPAND_DLFUNC\n    expand_string_message = US\"\\\"${dlfunc\\\" encountered, but this facility \"\t/*}*/\n      \"is not included in this binary\";\n    goto EXPAND_FAILED;\n\n    #else   /* EXPAND_DLFUNC */\n      {\n      tree_node *t;\n      exim_dlfunc_t *func;\n      uschar *result;\n      int status, argc;\n      uschar *argv[EXPAND_DLFUNC_MAX_ARGS + 3];\n\n      if ((expand_forbid & RDO_DLFUNC) != 0)\n        {\n        expand_string_message =\n          US\"dynamically-loaded functions are not permitted\";\n        goto EXPAND_FAILED;\n        }\n\n      switch(read_subs(argv, EXPAND_DLFUNC_MAX_ARGS + 2, 2, &s, skipping,\n           TRUE, US\"dlfunc\", &resetok))\n        {\n        case 1: goto EXPAND_FAILED_CURLY;\n        case 2:\n        case 3: goto EXPAND_FAILED;\n        }\n\n      /* If skipping, we don't actually do anything */\n\n      if (skipping) continue;\n\n      /* Look up the dynamically loaded object handle in the tree. If it isn't\n      found, dlopen() the file and put the handle in the tree for next time. */\n\n      t = tree_search(dlobj_anchor, argv[0]);\n      if (t == NULL)\n        {\n        void *handle = dlopen(CS argv[0], RTLD_LAZY);\n        if (handle == NULL)\n          {\n          expand_string_message = string_sprintf(\"dlopen \\\"%s\\\" failed: %s\",\n            argv[0], dlerror());\n          log_write(0, LOG_MAIN|LOG_PANIC, \"%s\", expand_string_message);\n          goto EXPAND_FAILED;\n          }\n        t = store_get_perm(sizeof(tree_node) + Ustrlen(argv[0]));\n        Ustrcpy(t->name, argv[0]);\n        t->data.ptr = handle;\n        (void)tree_insertnode(&dlobj_anchor, t);\n        }\n\n      /* Having obtained the dynamically loaded object handle, look up the\n      function pointer. */\n\n      func = (exim_dlfunc_t *)dlsym(t->data.ptr, CS argv[1]);\n      if (func == NULL)\n        {\n        expand_string_message = string_sprintf(\"dlsym \\\"%s\\\" in \\\"%s\\\" failed: \"\n          \"%s\", argv[1], argv[0], dlerror());\n        log_write(0, LOG_MAIN|LOG_PANIC, \"%s\", expand_string_message);\n        goto EXPAND_FAILED;\n        }\n\n      /* Call the function and work out what to do with the result. If it\n      returns OK, we have a replacement string; if it returns DEFER then\n      expansion has failed in a non-forced manner; if it returns FAIL then\n      failure was forced; if it returns ERROR or any other value there's a\n      problem, so panic slightly. In any case, assume that the function has\n      side-effects on the store that must be preserved. */\n\n      resetok = FALSE;\n      result = NULL;\n      for (argc = 0; argv[argc] != NULL; argc++);\n      status = func(&result, argc - 2, &argv[2]);\n      if(status == OK)\n        {\n        if (result == NULL) result = US\"\";\n        yield = string_cat(yield, &size, &ptr, result, Ustrlen(result));\n        continue;\n        }\n      else\n        {\n        expand_string_message = result == NULL ? US\"(no message)\" : result;\n        if(status == FAIL_FORCED) expand_string_forcedfail = TRUE;\n          else if(status != FAIL)\n            log_write(0, LOG_MAIN|LOG_PANIC, \"dlfunc{%s}{%s} failed (%d): %s\",\n              argv[0], argv[1], status, expand_string_message);\n        goto EXPAND_FAILED;\n        }\n      }\n    #endif /* EXPAND_DLFUNC */\n    }\t/* EITEM_* switch */\n\n  /* Control reaches here if the name is not recognized as one of the more\n  complicated expansion items. Check for the \"operator\" syntax (name terminated\n  by a colon). Some of the operators have arguments, separated by _ from the\n  name. */\n\n  if (*s == ':')\n    {\n    int c;\n    uschar *arg = NULL;\n    uschar *sub;\n    var_entry *vp = NULL;\n\n    /* Owing to an historical mis-design, an underscore may be part of the\n    operator name, or it may introduce arguments.  We therefore first scan the\n    table of names that contain underscores. If there is no match, we cut off\n    the arguments and then scan the main table. */\n\n    if ((c = chop_match(name, op_table_underscore,\n\tsizeof(op_table_underscore)/sizeof(uschar *))) < 0)\n      {\n      arg = Ustrchr(name, '_');\n      if (arg != NULL) *arg = 0;\n      c = chop_match(name, op_table_main,\n        sizeof(op_table_main)/sizeof(uschar *));\n      if (c >= 0) c += sizeof(op_table_underscore)/sizeof(uschar *);\n      if (arg != NULL) *arg++ = '_';   /* Put back for error messages */\n      }\n\n    /* Deal specially with operators that might take a certificate variable\n    as we do not want to do the usual expansion. For most, expand the string.*/\n    switch(c)\n      {\n#ifdef SUPPORT_TLS\n      case EOP_MD5:\n      case EOP_SHA1:\n      case EOP_SHA256:\n\tif (s[1] == '$')\n\t  {\n\t  uschar * s1 = s;\n\t  sub = expand_string_internal(s+2, TRUE, &s1, skipping,\n\t\t  FALSE, &resetok);\n\t  if (!sub)       goto EXPAND_FAILED;\t\t/*{*/\n\t  if (*s1 != '}') goto EXPAND_FAILED_CURLY;\n\t  if ((vp = find_var_ent(sub)) && vp->type == vtype_cert)\n\t    {\n\t    s = s1+1;\n\t    break;\n\t    }\n\t  vp = NULL;\n\t  }\n        /*FALLTHROUGH*/\n#endif\n      default:\n\tsub = expand_string_internal(s+1, TRUE, &s, skipping, TRUE, &resetok);\n\tif (!sub) goto EXPAND_FAILED;\n\ts++;\n\tbreak;\n      }\n\n    /* If we are skipping, we don't need to perform the operation at all.\n    This matters for operations like \"mask\", because the data may not be\n    in the correct format when skipping. For example, the expression may test\n    for the existence of $sender_host_address before trying to mask it. For\n    other operations, doing them may not fail, but it is a waste of time. */\n\n    if (skipping && c >= 0) continue;\n\n    /* Otherwise, switch on the operator type */\n\n    switch(c)\n      {\n      case EOP_BASE62:\n        {\n        uschar *t;\n        unsigned long int n = Ustrtoul(sub, &t, 10);\n        if (*t != 0)\n          {\n          expand_string_message = string_sprintf(\"argument for base62 \"\n            \"operator is \\\"%s\\\", which is not a decimal number\", sub);\n          goto EXPAND_FAILED;\n          }\n        t = string_base62(n);\n        yield = string_cat(yield, &size, &ptr, t, Ustrlen(t));\n        continue;\n        }\n\n      /* Note that for Darwin and Cygwin, BASE_62 actually has the value 36 */\n\n      case EOP_BASE62D:\n        {\n        uschar buf[16];\n        uschar *tt = sub;\n        unsigned long int n = 0;\n        while (*tt != 0)\n          {\n          uschar *t = Ustrchr(base62_chars, *tt++);\n          if (t == NULL)\n            {\n            expand_string_message = string_sprintf(\"argument for base62d \"\n              \"operator is \\\"%s\\\", which is not a base %d number\", sub,\n              BASE_62);\n            goto EXPAND_FAILED;\n            }\n          n = n * BASE_62 + (t - base62_chars);\n          }\n        (void)sprintf(CS buf, \"%ld\", n);\n        yield = string_cat(yield, &size, &ptr, buf, Ustrlen(buf));\n        continue;\n        }\n\n      case EOP_EXPAND:\n        {\n        uschar *expanded = expand_string_internal(sub, FALSE, NULL, skipping, TRUE, &resetok);\n        if (expanded == NULL)\n          {\n          expand_string_message =\n            string_sprintf(\"internal expansion of \\\"%s\\\" failed: %s\", sub,\n              expand_string_message);\n          goto EXPAND_FAILED;\n          }\n        yield = string_cat(yield, &size, &ptr, expanded, Ustrlen(expanded));\n        continue;\n        }\n\n      case EOP_LC:\n        {\n        int count = 0;\n        uschar *t = sub - 1;\n        while (*(++t) != 0) { *t = tolower(*t); count++; }\n        yield = string_cat(yield, &size, &ptr, sub, count);\n        continue;\n        }\n\n      case EOP_UC:\n        {\n        int count = 0;\n        uschar *t = sub - 1;\n        while (*(++t) != 0) { *t = toupper(*t); count++; }\n        yield = string_cat(yield, &size, &ptr, sub, count);\n        continue;\n        }\n\n      case EOP_MD5:\n#ifdef SUPPORT_TLS\n\tif (vp && *(void **)vp->value)\n\t  {\n\t  uschar * cp = tls_cert_fprt_md5(*(void **)vp->value);\n\t  yield = string_cat(yield, &size, &ptr, cp, Ustrlen(cp));\n\t  }\n\telse\n#endif\n\t  {\n\t  md5 base;\n\t  uschar digest[16];\n\t  int j;\n\t  char st[33];\n\t  md5_start(&base);\n\t  md5_end(&base, sub, Ustrlen(sub), digest);\n\t  for(j = 0; j < 16; j++) sprintf(st+2*j, \"%02x\", digest[j]);\n\t  yield = string_cat(yield, &size, &ptr, US st, (int)strlen(st));\n\t  }\n        continue;\n\n      case EOP_SHA1:\n#ifdef SUPPORT_TLS\n\tif (vp && *(void **)vp->value)\n\t  {\n\t  uschar * cp = tls_cert_fprt_sha1(*(void **)vp->value);\n\t  yield = string_cat(yield, &size, &ptr, cp, Ustrlen(cp));\n\t  }\n\telse\n#endif\n\t  {\n\t  sha1 base;\n\t  uschar digest[20];\n\t  int j;\n\t  char st[41];\n\t  sha1_start(&base);\n\t  sha1_end(&base, sub, Ustrlen(sub), digest);\n\t  for(j = 0; j < 20; j++) sprintf(st+2*j, \"%02X\", digest[j]);\n\t  yield = string_cat(yield, &size, &ptr, US st, (int)strlen(st));\n\t  }\n        continue;\n\n      case EOP_SHA256:\n#ifdef SUPPORT_TLS\n\tif (vp && *(void **)vp->value)\n\t  {\n\t  uschar * cp = tls_cert_fprt_sha256(*(void **)vp->value);\n\t  yield = string_cat(yield, &size, &ptr, cp, (int)Ustrlen(cp));\n\t  }\n\telse\n#endif\n\t  expand_string_message = US\"sha256 only supported for certificates\";\n        continue;\n\n      /* Convert hex encoding to base64 encoding */\n\n      case EOP_HEX2B64:\n        {\n        int c = 0;\n        int b = -1;\n        uschar *in = sub;\n        uschar *out = sub;\n        uschar *enc;\n\n        for (enc = sub; *enc != 0; enc++)\n          {\n          if (!isxdigit(*enc))\n            {\n            expand_string_message = string_sprintf(\"\\\"%s\\\" is not a hex \"\n              \"string\", sub);\n            goto EXPAND_FAILED;\n            }\n          c++;\n          }\n\n        if ((c & 1) != 0)\n          {\n          expand_string_message = string_sprintf(\"\\\"%s\\\" contains an odd \"\n            \"number of characters\", sub);\n          goto EXPAND_FAILED;\n          }\n\n        while ((c = *in++) != 0)\n          {\n          if (isdigit(c)) c -= '0';\n          else c = toupper(c) - 'A' + 10;\n          if (b == -1)\n            {\n            b = c << 4;\n            }\n          else\n            {\n            *out++ = b | c;\n            b = -1;\n            }\n          }\n\n        enc = auth_b64encode(sub, out - sub);\n        yield = string_cat(yield, &size, &ptr, enc, Ustrlen(enc));\n        continue;\n        }\n\n      /* Convert octets outside 0x21..0x7E to \\xXX form */\n\n      case EOP_HEXQUOTE:\n\t{\n        uschar *t = sub - 1;\n        while (*(++t) != 0)\n          {\n          if (*t < 0x21 || 0x7E < *t)\n            yield = string_cat(yield, &size, &ptr,\n\t      string_sprintf(\"\\\\x%02x\", *t), 4);\n\t  else\n\t    yield = string_cat(yield, &size, &ptr, t, 1);\n          }\n\tcontinue;\n\t}\n\n      /* count the number of list elements */\n\n      case EOP_LISTCOUNT:\n        {\n\tint cnt = 0;\n\tint sep = 0;\n\tuschar * cp;\n\tuschar buffer[256];\n\n\twhile (string_nextinlist(&sub, &sep, buffer, sizeof(buffer)) != NULL) cnt++;\n\tcp = string_sprintf(\"%d\", cnt);\n        yield = string_cat(yield, &size, &ptr, cp, Ustrlen(cp));\n        continue;\n        }\n\n      /* expand a named list given the name */\n      /* handles nested named lists; requotes as colon-sep list */\n\n      case EOP_LISTNAMED:\n\t{\n\ttree_node *t = NULL;\n\tuschar * list;\n\tint sep = 0;\n\tuschar * item;\n\tuschar * suffix = US\"\";\n\tBOOL needsep = FALSE;\n\tuschar buffer[256];\n\n\tif (*sub == '+') sub++;\n\tif (arg == NULL)\t/* no-argument version */\n\t  {\n\t  if (!(t = tree_search(addresslist_anchor, sub)) &&\n\t      !(t = tree_search(domainlist_anchor,  sub)) &&\n\t      !(t = tree_search(hostlist_anchor,    sub)))\n\t    t = tree_search(localpartlist_anchor, sub);\n\t  }\n\telse switch(*arg)\t/* specific list-type version */\n\t  {\n\t  case 'a': t = tree_search(addresslist_anchor,   sub); suffix = US\"_a\"; break;\n\t  case 'd': t = tree_search(domainlist_anchor,    sub); suffix = US\"_d\"; break;\n\t  case 'h': t = tree_search(hostlist_anchor,      sub); suffix = US\"_h\"; break;\n\t  case 'l': t = tree_search(localpartlist_anchor, sub); suffix = US\"_l\"; break;\n\t  default:\n            expand_string_message = string_sprintf(\"bad suffix on \\\"list\\\" operator\");\n\t    goto EXPAND_FAILED;\n\t  }\n\n\tif(!t)\n\t  {\n          expand_string_message = string_sprintf(\"\\\"%s\\\" is not a %snamed list\",\n            sub, !arg?\"\"\n\t      : *arg=='a'?\"address \"\n\t      : *arg=='d'?\"domain \"\n\t      : *arg=='h'?\"host \"\n\t      : *arg=='l'?\"localpart \"\n\t      : 0);\n\t  goto EXPAND_FAILED;\n\t  }\n\n\tlist = ((namedlist_block *)(t->data.ptr))->string;\n\n\twhile ((item = string_nextinlist(&list, &sep, buffer, sizeof(buffer))) != NULL)\n\t  {\n\t  uschar * buf = US\" : \";\n\t  if (needsep)\n\t    yield = string_cat(yield, &size, &ptr, buf, 3);\n\t  else\n\t    needsep = TRUE;\n\n\t  if (*item == '+')\t/* list item is itself a named list */\n\t    {\n\t    uschar * sub = string_sprintf(\"${listnamed%s:%s}\", suffix, item);\n\t    item = expand_string_internal(sub, FALSE, NULL, FALSE, TRUE, &resetok);\n\t    }\n\t  else if (sep != ':')\t/* item from non-colon-sep list, re-quote for colon list-separator */\n\t    {\n\t    char * cp;\n\t    char tok[3];\n\t    tok[0] = sep; tok[1] = ':'; tok[2] = 0;\n\t    while ((cp= strpbrk((const char *)item, tok)))\n\t      {\n              yield = string_cat(yield, &size, &ptr, item, cp-(char *)item);\n\t      if (*cp++ == ':')\t/* colon in a non-colon-sep list item, needs doubling */\n\t        {\n                yield = string_cat(yield, &size, &ptr, US\"::\", 2);\n\t        item = (uschar *)cp;\n\t\t}\n\t      else\t\t/* sep in item; should already be doubled; emit once */\n\t        {\n                yield = string_cat(yield, &size, &ptr, (uschar *)tok, 1);\n\t\tif (*cp == sep) cp++;\n\t        item = (uschar *)cp;\n\t\t}\n\t      }\n\t    }\n          yield = string_cat(yield, &size, &ptr, item, Ustrlen(item));\n\t  }\n        continue;\n\t}\n\n      /* mask applies a mask to an IP address; for example the result of\n      ${mask:131.111.10.206/28} is 131.111.10.192/28. */\n\n      case EOP_MASK:\n        {\n        int count;\n        uschar *endptr;\n        int binary[4];\n        int mask, maskoffset;\n        int type = string_is_ip_address(sub, &maskoffset);\n        uschar buffer[64];\n\n        if (type == 0)\n          {\n          expand_string_message = string_sprintf(\"\\\"%s\\\" is not an IP address\",\n           sub);\n          goto EXPAND_FAILED;\n          }\n\n        if (maskoffset == 0)\n          {\n          expand_string_message = string_sprintf(\"missing mask value in \\\"%s\\\"\",\n            sub);\n          goto EXPAND_FAILED;\n          }\n\n        mask = Ustrtol(sub + maskoffset + 1, &endptr, 10);\n\n        if (*endptr != 0 || mask < 0 || mask > ((type == 4)? 32 : 128))\n          {\n          expand_string_message = string_sprintf(\"mask value too big in \\\"%s\\\"\",\n            sub);\n          goto EXPAND_FAILED;\n          }\n\n        /* Convert the address to binary integer(s) and apply the mask */\n\n        sub[maskoffset] = 0;\n        count = host_aton(sub, binary);\n        host_mask(count, binary, mask);\n\n        /* Convert to masked textual format and add to output. */\n\n        yield = string_cat(yield, &size, &ptr, buffer,\n          host_nmtoa(count, binary, mask, buffer, '.'));\n        continue;\n        }\n\n      case EOP_ADDRESS:\n      case EOP_LOCAL_PART:\n      case EOP_DOMAIN:\n        {\n        uschar *error;\n        int start, end, domain;\n        uschar *t = parse_extract_address(sub, &error, &start, &end, &domain,\n          FALSE);\n        if (t != NULL)\n          {\n          if (c != EOP_DOMAIN)\n            {\n            if (c == EOP_LOCAL_PART && domain != 0) end = start + domain - 1;\n            yield = string_cat(yield, &size, &ptr, sub+start, end-start);\n            }\n          else if (domain != 0)\n            {\n            domain += start;\n            yield = string_cat(yield, &size, &ptr, sub+domain, end-domain);\n            }\n          }\n        continue;\n        }\n\n      case EOP_ADDRESSES:\n        {\n        uschar outsep[2] = { ':', '\\0' };\n        uschar *address, *error;\n        int save_ptr = ptr;\n        int start, end, domain;  /* Not really used */\n\n        while (isspace(*sub)) sub++;\n        if (*sub == '>') { *outsep = *++sub; ++sub; }\n        parse_allow_group = TRUE;\n\n        for (;;)\n          {\n          uschar *p = parse_find_address_end(sub, FALSE);\n          uschar saveend = *p;\n          *p = '\\0';\n          address = parse_extract_address(sub, &error, &start, &end, &domain,\n            FALSE);\n          *p = saveend;\n\n          /* Add the address to the output list that we are building. This is\n          done in chunks by searching for the separator character. At the\n          start, unless we are dealing with the first address of the output\n          list, add in a space if the new address begins with the separator\n          character, or is an empty string. */\n\n          if (address != NULL)\n            {\n            if (ptr != save_ptr && address[0] == *outsep)\n              yield = string_cat(yield, &size, &ptr, US\" \", 1);\n\n            for (;;)\n              {\n              size_t seglen = Ustrcspn(address, outsep);\n              yield = string_cat(yield, &size, &ptr, address, seglen + 1);\n\n              /* If we got to the end of the string we output one character\n              too many. */\n\n              if (address[seglen] == '\\0') { ptr--; break; }\n              yield = string_cat(yield, &size, &ptr, outsep, 1);\n              address += seglen + 1;\n              }\n\n            /* Output a separator after the string: we will remove the\n            redundant final one at the end. */\n\n            yield = string_cat(yield, &size, &ptr, outsep, 1);\n            }\n\n          if (saveend == '\\0') break;\n          sub = p + 1;\n          }\n\n        /* If we have generated anything, remove the redundant final\n        separator. */\n\n        if (ptr != save_ptr) ptr--;\n        parse_allow_group = FALSE;\n        continue;\n        }\n\n\n      /* quote puts a string in quotes if it is empty or contains anything\n      other than alphamerics, underscore, dot, or hyphen.\n\n      quote_local_part puts a string in quotes if RFC 2821/2822 requires it to\n      be quoted in order to be a valid local part.\n\n      In both cases, newlines and carriage returns are converted into \\n and \\r\n      respectively */\n\n      case EOP_QUOTE:\n      case EOP_QUOTE_LOCAL_PART:\n      if (arg == NULL)\n        {\n        BOOL needs_quote = (*sub == 0);      /* TRUE for empty string */\n        uschar *t = sub - 1;\n\n        if (c == EOP_QUOTE)\n          {\n          while (!needs_quote && *(++t) != 0)\n            needs_quote = !isalnum(*t) && !strchr(\"_-.\", *t);\n          }\n        else  /* EOP_QUOTE_LOCAL_PART */\n          {\n          while (!needs_quote && *(++t) != 0)\n            needs_quote = !isalnum(*t) &&\n              strchr(\"!#$%&'*+-/=?^_`{|}~\", *t) == NULL &&\n              (*t != '.' || t == sub || t[1] == 0);\n          }\n\n        if (needs_quote)\n          {\n          yield = string_cat(yield, &size, &ptr, US\"\\\"\", 1);\n          t = sub - 1;\n          while (*(++t) != 0)\n            {\n            if (*t == '\\n')\n              yield = string_cat(yield, &size, &ptr, US\"\\\\n\", 2);\n            else if (*t == '\\r')\n              yield = string_cat(yield, &size, &ptr, US\"\\\\r\", 2);\n            else\n              {\n              if (*t == '\\\\' || *t == '\"')\n                yield = string_cat(yield, &size, &ptr, US\"\\\\\", 1);\n              yield = string_cat(yield, &size, &ptr, t, 1);\n              }\n            }\n          yield = string_cat(yield, &size, &ptr, US\"\\\"\", 1);\n          }\n        else yield = string_cat(yield, &size, &ptr, sub, Ustrlen(sub));\n        continue;\n        }\n\n      /* quote_lookuptype does lookup-specific quoting */\n\n      else\n        {\n        int n;\n        uschar *opt = Ustrchr(arg, '_');\n\n        if (opt != NULL) *opt++ = 0;\n\n        n = search_findtype(arg, Ustrlen(arg));\n        if (n < 0)\n          {\n          expand_string_message = search_error_message;\n          goto EXPAND_FAILED;\n          }\n\n        if (lookup_list[n]->quote != NULL)\n          sub = (lookup_list[n]->quote)(sub, opt);\n        else if (opt != NULL) sub = NULL;\n\n        if (sub == NULL)\n          {\n          expand_string_message = string_sprintf(\n            \"\\\"%s\\\" unrecognized after \\\"${quote_%s\\\"\",\n            opt, arg);\n          goto EXPAND_FAILED;\n          }\n\n        yield = string_cat(yield, &size, &ptr, sub, Ustrlen(sub));\n        continue;\n        }\n\n      /* rx quote sticks in \\ before any non-alphameric character so that\n      the insertion works in a regular expression. */\n\n      case EOP_RXQUOTE:\n        {\n        uschar *t = sub - 1;\n        while (*(++t) != 0)\n          {\n          if (!isalnum(*t))\n            yield = string_cat(yield, &size, &ptr, US\"\\\\\", 1);\n          yield = string_cat(yield, &size, &ptr, t, 1);\n          }\n        continue;\n        }\n\n      /* RFC 2047 encodes, assuming headers_charset (default ISO 8859-1) as\n      prescribed by the RFC, if there are characters that need to be encoded */\n\n      case EOP_RFC2047:\n        {\n        uschar buffer[2048];\n        uschar *string = parse_quote_2047(sub, Ustrlen(sub), headers_charset,\n          buffer, sizeof(buffer), FALSE);\n        yield = string_cat(yield, &size, &ptr, string, Ustrlen(string));\n        continue;\n        }\n\n      /* RFC 2047 decode */\n\n      case EOP_RFC2047D:\n        {\n        int len;\n        uschar *error;\n        uschar *decoded = rfc2047_decode(sub, check_rfc2047_length,\n          headers_charset, '?', &len, &error);\n        if (error != NULL)\n          {\n          expand_string_message = error;\n          goto EXPAND_FAILED;\n          }\n        yield = string_cat(yield, &size, &ptr, decoded, len);\n        continue;\n        }\n\n      /* from_utf8 converts UTF-8 to 8859-1, turning non-existent chars into\n      underscores */\n\n      case EOP_FROM_UTF8:\n        {\n        while (*sub != 0)\n          {\n          int c;\n          uschar buff[4];\n          GETUTF8INC(c, sub);\n          if (c > 255) c = '_';\n          buff[0] = c;\n          yield = string_cat(yield, &size, &ptr, buff, 1);\n          }\n        continue;\n        }\n\n\t  /* replace illegal UTF-8 sequences by replacement character  */\n\t  \n      #define UTF8_REPLACEMENT_CHAR US\"?\"\n\n      case EOP_UTF8CLEAN:\n        {\n        int seq_len, index = 0;\n        int bytes_left = 0;\n        uschar seq_buff[4];\t\t\t/* accumulate utf-8 here */\n        \n        while (*sub != 0)\n\t  {\n\t  int complete;\n\t  long codepoint;\n\t  uschar c;\n\n\t  complete = 0;\n\t  c = *sub++;\n\t  if (bytes_left)\n\t    {\n\t    if ((c & 0xc0) != 0x80)\n\t      {\n\t\t    /* wrong continuation byte; invalidate all bytes */\n\t      complete = 1; /* error */\n\t      }\n\t    else\n\t      {\n\t      codepoint = (codepoint << 6) | (c & 0x3f);\n\t      seq_buff[index++] = c;\n\t      if (--bytes_left == 0)\t\t/* codepoint complete */\n\t\t{\n\t\tif(codepoint > 0x10FFFF)\t/* is it too large? */\n\t\t  complete = -1;\t/* error */\n\t\telse\n\t\t  {\t\t/* finished; output utf-8 sequence */\n\t\t  yield = string_cat(yield, &size, &ptr, seq_buff, seq_len);\n\t\t  index = 0;\n\t\t  }\n\t\t}\n\t      }\n\t    }\n\t  else\t/* no bytes left: new sequence */\n\t    {\n\t    if((c & 0x80) == 0)\t/* 1-byte sequence, US-ASCII, keep it */\n\t      {\n\t      yield = string_cat(yield, &size, &ptr, &c, 1);\n\t      continue;\n\t      }\n\t    if((c & 0xe0) == 0xc0)\t\t/* 2-byte sequence */\n\t      {\n\t      if(c == 0xc0 || c == 0xc1)\t/* 0xc0 and 0xc1 are illegal */\n\t\tcomplete = -1;\n\t      else\n\t\t{\n\t\t  bytes_left = 1;\n\t\t  codepoint = c & 0x1f;\n\t\t}\n\t      }\n\t    else if((c & 0xf0) == 0xe0)\t\t/* 3-byte sequence */\n\t      {\n\t      bytes_left = 2;\n\t      codepoint = c & 0x0f;\n\t      }\n\t    else if((c & 0xf8) == 0xf0)\t\t/* 4-byte sequence */\n\t      {\n\t      bytes_left = 3;\n\t      codepoint = c & 0x07;\n\t      }\n\t    else\t/* invalid or too long (RFC3629 allows only 4 bytes) */\n\t      complete = -1;\n\n\t    seq_buff[index++] = c;\n\t    seq_len = bytes_left + 1;\n\t    }\t\t/* if(bytes_left) */\n\n\t  if (complete != 0)\n\t    {\n\t    bytes_left = index = 0;\n\t    yield = string_cat(yield, &size, &ptr, UTF8_REPLACEMENT_CHAR, 1);\n\t    }\n\t  if ((complete == 1) && ((c & 0x80) == 0))\n\t    { /* ASCII character follows incomplete sequence */\n\t      yield = string_cat(yield, &size, &ptr, &c, 1);\n\t    }\n\t  }\n        continue;\n        }\n\n      /* escape turns all non-printing characters into escape sequences. */\n\n      case EOP_ESCAPE:\n        {\n        uschar *t = string_printing(sub);\n        yield = string_cat(yield, &size, &ptr, t, Ustrlen(t));\n        continue;\n        }\n\n      /* Handle numeric expression evaluation */\n\n      case EOP_EVAL:\n      case EOP_EVAL10:\n        {\n        uschar *save_sub = sub;\n        uschar *error = NULL;\n        int_eximarith_t n = eval_expr(&sub, (c == EOP_EVAL10), &error, FALSE);\n        if (error != NULL)\n          {\n          expand_string_message = string_sprintf(\"error in expression \"\n            \"evaluation: %s (after processing \\\"%.*s\\\")\", error, sub-save_sub,\n              save_sub);\n          goto EXPAND_FAILED;\n          }\n        sprintf(CS var_buffer, PR_EXIM_ARITH, n);\n        yield = string_cat(yield, &size, &ptr, var_buffer, Ustrlen(var_buffer));\n        continue;\n        }\n\n      /* Handle time period formating */\n\n      case EOP_TIME_EVAL:\n        {\n        int n = readconf_readtime(sub, 0, FALSE);\n        if (n < 0)\n          {\n          expand_string_message = string_sprintf(\"string \\\"%s\\\" is not an \"\n            \"Exim time interval in \\\"%s\\\" operator\", sub, name);\n          goto EXPAND_FAILED;\n          }\n        sprintf(CS var_buffer, \"%d\", n);\n        yield = string_cat(yield, &size, &ptr, var_buffer, Ustrlen(var_buffer));\n        continue;\n        }\n\n      case EOP_TIME_INTERVAL:\n        {\n        int n;\n        uschar *t = read_number(&n, sub);\n        if (*t != 0) /* Not A Number*/\n          {\n          expand_string_message = string_sprintf(\"string \\\"%s\\\" is not a \"\n            \"positive number in \\\"%s\\\" operator\", sub, name);\n          goto EXPAND_FAILED;\n          }\n        t = readconf_printtime(n);\n        yield = string_cat(yield, &size, &ptr, t, Ustrlen(t));\n        continue;\n        }\n\n      /* Convert string to base64 encoding */\n\n      case EOP_STR2B64:\n        {\n        uschar *encstr = auth_b64encode(sub, Ustrlen(sub));\n        yield = string_cat(yield, &size, &ptr, encstr, Ustrlen(encstr));\n        continue;\n        }\n\n      /* strlen returns the length of the string */\n\n      case EOP_STRLEN:\n        {\n        uschar buff[24];\n        (void)sprintf(CS buff, \"%d\", Ustrlen(sub));\n        yield = string_cat(yield, &size, &ptr, buff, Ustrlen(buff));\n        continue;\n        }\n\n      /* length_n or l_n takes just the first n characters or the whole string,\n      whichever is the shorter;\n\n      substr_m_n, and s_m_n take n characters from offset m; negative m take\n      from the end; l_n is synonymous with s_0_n. If n is omitted in substr it\n      takes the rest, either to the right or to the left.\n\n      hash_n or h_n makes a hash of length n from the string, yielding n\n      characters from the set a-z; hash_n_m makes a hash of length n, but\n      uses m characters from the set a-zA-Z0-9.\n\n      nhash_n returns a single number between 0 and n-1 (in text form), while\n      nhash_n_m returns a div/mod hash as two numbers \"a/b\". The first lies\n      between 0 and n-1 and the second between 0 and m-1. */\n\n      case EOP_LENGTH:\n      case EOP_L:\n      case EOP_SUBSTR:\n      case EOP_S:\n      case EOP_HASH:\n      case EOP_H:\n      case EOP_NHASH:\n      case EOP_NH:\n        {\n        int sign = 1;\n        int value1 = 0;\n        int value2 = -1;\n        int *pn;\n        int len;\n        uschar *ret;\n\n        if (arg == NULL)\n          {\n          expand_string_message = string_sprintf(\"missing values after %s\",\n            name);\n          goto EXPAND_FAILED;\n          }\n\n        /* \"length\" has only one argument, effectively being synonymous with\n        substr_0_n. */\n\n        if (c == EOP_LENGTH || c == EOP_L)\n          {\n          pn = &value2;\n          value2 = 0;\n          }\n\n        /* The others have one or two arguments; for \"substr\" the first may be\n        negative. The second being negative means \"not supplied\". */\n\n        else\n          {\n          pn = &value1;\n          if (name[0] == 's' && *arg == '-') { sign = -1; arg++; }\n          }\n\n        /* Read up to two numbers, separated by underscores */\n\n        ret = arg;\n        while (*arg != 0)\n          {\n          if (arg != ret && *arg == '_' && pn == &value1)\n            {\n            pn = &value2;\n            value2 = 0;\n            if (arg[1] != 0) arg++;\n            }\n          else if (!isdigit(*arg))\n            {\n            expand_string_message =\n              string_sprintf(\"non-digit after underscore in \\\"%s\\\"\", name);\n            goto EXPAND_FAILED;\n            }\n          else *pn = (*pn)*10 + *arg++ - '0';\n          }\n        value1 *= sign;\n\n        /* Perform the required operation */\n\n        ret =\n          (c == EOP_HASH || c == EOP_H)?\n             compute_hash(sub, value1, value2, &len) :\n          (c == EOP_NHASH || c == EOP_NH)?\n             compute_nhash(sub, value1, value2, &len) :\n             extract_substr(sub, value1, value2, &len);\n\n        if (ret == NULL) goto EXPAND_FAILED;\n        yield = string_cat(yield, &size, &ptr, ret, len);\n        continue;\n        }\n\n      /* Stat a path */\n\n      case EOP_STAT:\n        {\n        uschar *s;\n        uschar smode[12];\n        uschar **modetable[3];\n        int i;\n        mode_t mode;\n        struct stat st;\n\n        if ((expand_forbid & RDO_EXISTS) != 0)\n          {\n          expand_string_message = US\"Use of the stat() expansion is not permitted\";\n          goto EXPAND_FAILED;\n          }\n\n        if (stat(CS sub, &st) < 0)\n          {\n          expand_string_message = string_sprintf(\"stat(%s) failed: %s\",\n            sub, strerror(errno));\n          goto EXPAND_FAILED;\n          }\n        mode = st.st_mode;\n        switch (mode & S_IFMT)\n          {\n          case S_IFIFO: smode[0] = 'p'; break;\n          case S_IFCHR: smode[0] = 'c'; break;\n          case S_IFDIR: smode[0] = 'd'; break;\n          case S_IFBLK: smode[0] = 'b'; break;\n          case S_IFREG: smode[0] = '-'; break;\n          default: smode[0] = '?'; break;\n          }\n\n        modetable[0] = ((mode & 01000) == 0)? mtable_normal : mtable_sticky;\n        modetable[1] = ((mode & 02000) == 0)? mtable_normal : mtable_setid;\n        modetable[2] = ((mode & 04000) == 0)? mtable_normal : mtable_setid;\n\n        for (i = 0; i < 3; i++)\n          {\n          memcpy(CS(smode + 7 - i*3), CS(modetable[i][mode & 7]), 3);\n          mode >>= 3;\n          }\n\n        smode[10] = 0;\n        s = string_sprintf(\"mode=%04lo smode=%s inode=%ld device=%ld links=%ld \"\n          \"uid=%ld gid=%ld size=\" OFF_T_FMT \" atime=%ld mtime=%ld ctime=%ld\",\n          (long)(st.st_mode & 077777), smode, (long)st.st_ino,\n          (long)st.st_dev, (long)st.st_nlink, (long)st.st_uid,\n          (long)st.st_gid, st.st_size, (long)st.st_atime,\n          (long)st.st_mtime, (long)st.st_ctime);\n        yield = string_cat(yield, &size, &ptr, s, Ustrlen(s));\n        continue;\n        }\n\n      /* vaguely random number less than N */\n\n      case EOP_RANDINT:\n        {\n         int_eximarith_t max;\n         uschar *s;\n \n        max = expand_string_integer(sub, TRUE);\n         if (expand_string_message != NULL)\n           goto EXPAND_FAILED;\n         s = string_sprintf(\"%d\", vaguely_random_number((int)max));\n        yield = string_cat(yield, &size, &ptr, s, Ustrlen(s));\n        continue;\n        }\n\n      /* Reverse IP, including IPv6 to dotted-nibble */\n\n      case EOP_REVERSE_IP:\n        {\n        int family, maskptr;\n        uschar reversed[128];\n\n        family = string_is_ip_address(sub, &maskptr);\n        if (family == 0)\n          {\n          expand_string_message = string_sprintf(\n              \"reverse_ip() not given an IP address [%s]\", sub);\n          goto EXPAND_FAILED;\n          }\n        invert_address(reversed, sub);\n        yield = string_cat(yield, &size, &ptr, reversed, Ustrlen(reversed));\n        continue;\n        }\n\n      /* Unknown operator */\n\n      default:\n      expand_string_message =\n        string_sprintf(\"unknown expansion operator \\\"%s\\\"\", name);\n      goto EXPAND_FAILED;\n      }\n    }\n\n  /* Handle a plain name. If this is the first thing in the expansion, release\n  the pre-allocated buffer. If the result data is known to be in a new buffer,\n  newsize will be set to the size of that buffer, and we can just point at that\n  store instead of copying. Many expansion strings contain just one reference,\n  so this is a useful optimization, especially for humungous headers\n  ($message_headers). */\n\t\t\t\t\t\t/*{*/\n  if (*s++ == '}')\n    {\n    int len;\n    int newsize = 0;\n    if (ptr == 0)\n      {\n      if (resetok) store_reset(yield);\n      yield = NULL;\n      size = 0;\n      }\n    value = find_variable(name, FALSE, skipping, &newsize);\n    if (value == NULL)\n      {\n      expand_string_message =\n        string_sprintf(\"unknown variable in \\\"${%s}\\\"\", name);\n      check_variable_error_message(name);\n      goto EXPAND_FAILED;\n      }\n    len = Ustrlen(value);\n    if (yield == NULL && newsize != 0)\n      {\n      yield = value;\n      size = newsize;\n      ptr = len;\n      }\n    else yield = string_cat(yield, &size, &ptr, value, len);\n    continue;\n    }\n\n  /* Else there's something wrong */\n\n  expand_string_message =\n    string_sprintf(\"\\\"${%s\\\" is not a known operator (or a } is missing \"\n    \"in a variable reference)\", name);\n  goto EXPAND_FAILED;\n  }\n\n/* If we hit the end of the string when ket_ends is set, there is a missing\nterminating brace. */\n\nif (ket_ends && *s == 0)\n  {\n  expand_string_message = malformed_header?\n    US\"missing } at end of string - could be header name not terminated by colon\"\n    :\n    US\"missing } at end of string\";\n  goto EXPAND_FAILED;\n  }\n\n/* Expansion succeeded; yield may still be NULL here if nothing was actually\nadded to the string. If so, set up an empty string. Add a terminating zero. If\nleft != NULL, return a pointer to the terminator. */\n\nif (yield == NULL) yield = store_get(1);\nyield[ptr] = 0;\nif (left != NULL) *left = s;\n\n/* Any stacking store that was used above the final string is no longer needed.\nIn many cases the final string will be the first one that was got and so there\nwill be optimal store usage. */\n\nif (resetok) store_reset(yield + ptr + 1);\nelse if (resetok_p) *resetok_p = FALSE;\n\nDEBUG(D_expand)\n  {\n  debug_printf(\"expanding: %.*s\\n   result: %s\\n\", (int)(s - string), string,\n    yield);\n  if (skipping) debug_printf(\"skipping: result is not used\\n\");\n  }\nreturn yield;\n\n/* This is the failure exit: easiest to program with a goto. We still need\nto update the pointer to the terminator, for cases of nested calls with \"fail\".\n*/\n\nEXPAND_FAILED_CURLY:\nexpand_string_message = malformed_header?\n  US\"missing or misplaced { or } - could be header name not terminated by colon\"\n  :\n  US\"missing or misplaced { or }\";\n\n/* At one point, Exim reset the store to yield (if yield was not NULL), but\nthat is a bad idea, because expand_string_message is in dynamic store. */\n\nEXPAND_FAILED:\nif (left != NULL) *left = s;\nDEBUG(D_expand)\n  {\n  debug_printf(\"failed to expand: %s\\n\", string);\n  debug_printf(\"   error message: %s\\n\", expand_string_message);\n  if (expand_string_forcedfail) debug_printf(\"failure was forced\\n\");\n  }\nif (resetok_p) *resetok_p = resetok;\nreturn NULL;\n}\n", "target": 1, "idx": 178364}
{"func": "WandExport MagickBooleanType MogrifyImageList(ImageInfo *image_info,\n  const int argc,const char **argv,Image **images,ExceptionInfo *exception)\n{\n  const char\n    *option;\n\n  ImageInfo\n    *mogrify_info;\n\n  MagickStatusType\n    status;\n\n  PixelInterpolateMethod\n   interpolate_method;\n\n  QuantizeInfo\n    *quantize_info;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count,\n    index;\n\n  /*\n    Apply options to the image list.\n  */\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(images != (Image **) NULL);\n  assert((*images)->previous == (Image *) NULL);\n  assert((*images)->signature == MagickCoreSignature);\n  if ((*images)->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      (*images)->filename);\n  if ((argc <= 0) || (*argv == (char *) NULL))\n    return(MagickTrue);\n  interpolate_method=UndefinedInterpolatePixel;\n  mogrify_info=CloneImageInfo(image_info);\n  quantize_info=AcquireQuantizeInfo(mogrify_info);\n  status=MagickTrue;\n  for (i=0; i < (ssize_t) argc; i++)\n  {\n    if (*images == (Image *) NULL)\n      break;\n    option=argv[i];\n    if (IsCommandOption(option) == MagickFalse)\n      continue;\n    count=ParseCommandOption(MagickCommandOptions,MagickFalse,option);\n    count=MagickMax(count,0L);\n    if ((i+count) >= (ssize_t) argc)\n      break;\n    status=MogrifyImageInfo(mogrify_info,(int) count+1,argv+i,exception);\n    switch (*(option+1))\n    {\n      case 'a':\n      {\n        if (LocaleCompare(\"affinity\",option+1) == 0)\n          {\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            if (*option == '+')\n              {\n                (void) RemapImages(quantize_info,*images,(Image *) NULL,\n                  exception);\n                break;\n              }\n            i++;\n            break;\n          }\n        if (LocaleCompare(\"append\",option+1) == 0)\n          {\n            Image\n              *append_image;\n\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            append_image=AppendImages(*images,*option == '-' ? MagickTrue :\n              MagickFalse,exception);\n            if (append_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=append_image;\n            break;\n          }\n        if (LocaleCompare(\"average\",option+1) == 0)\n          {\n            Image\n              *average_image;\n\n            /*\n              Average an image sequence (deprecated).\n            */\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            average_image=EvaluateImages(*images,MeanEvaluateOperator,\n              exception);\n            if (average_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=average_image;\n            break;\n          }\n        break;\n      }\n      case 'c':\n      {\n        if (LocaleCompare(\"channel-fx\",option+1) == 0)\n          {\n            Image\n              *channel_image;\n\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            channel_image=ChannelFxImage(*images,argv[i+1],exception);\n            if (channel_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=channel_image;\n            break;\n          }\n        if (LocaleCompare(\"clut\",option+1) == 0)\n          {\n            Image\n              *clut_image,\n              *image;\n\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            image=RemoveFirstImageFromList(images);\n            clut_image=RemoveFirstImageFromList(images);\n            if (clut_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            (void) ClutImage(image,clut_image,interpolate_method,exception);\n            clut_image=DestroyImage(clut_image);\n            *images=DestroyImageList(*images);\n            *images=image;\n            break;\n          }\n        if (LocaleCompare(\"coalesce\",option+1) == 0)\n          {\n            Image\n              *coalesce_image;\n\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            coalesce_image=CoalesceImages(*images,exception);\n            if (coalesce_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=coalesce_image;\n            break;\n          }\n        if (LocaleCompare(\"combine\",option+1) == 0)\n          {\n            ColorspaceType\n              colorspace;\n\n            Image\n              *combine_image;\n\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            colorspace=(*images)->colorspace;\n            if ((*images)->number_channels < GetImageListLength(*images))\n              colorspace=sRGBColorspace;\n            if (*option == '+')\n              colorspace=(ColorspaceType) ParseCommandOption(\n                MagickColorspaceOptions,MagickFalse,argv[i+1]);\n            combine_image=CombineImages(*images,colorspace,exception);\n            if (combine_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=combine_image;\n            break;\n          }\n        if (LocaleCompare(\"compare\",option+1) == 0)\n          {\n            double\n              distortion;\n\n            Image\n              *difference_image,\n              *image,\n              *reconstruct_image;\n\n            MetricType\n              metric;\n\n            /*\n              Mathematically and visually annotate the difference between an\n              image and its reconstruction.\n            */\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            image=RemoveFirstImageFromList(images);\n            reconstruct_image=RemoveFirstImageFromList(images);\n            if (reconstruct_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            metric=UndefinedErrorMetric;\n            option=GetImageOption(mogrify_info,\"metric\");\n            if (option != (const char *) NULL)\n              metric=(MetricType) ParseCommandOption(MagickMetricOptions,\n                MagickFalse,option);\n            difference_image=CompareImages(image,reconstruct_image,metric,\n               &distortion,exception);\n             if (difference_image == (Image *) NULL)\n               break;\n             if (*images != (Image *) NULL)\n               *images=DestroyImageList(*images);\n             *images=difference_image;\n            break;\n          }\n        if (LocaleCompare(\"complex\",option+1) == 0)\n          {\n            ComplexOperator\n              op;\n\n            Image\n              *complex_images;\n\n            (void) SyncImageSettings(mogrify_info,*images,exception);\n            op=(ComplexOperator) ParseCommandOption(MagickComplexOptions,\n              MagickFalse,argv[i+1]);\n            complex_images=ComplexImages(*images,op,exception);\n            if (complex_images == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=complex_images;\n            break;\n          }\n        if (LocaleCompare(\"composite\",option+1) == 0)\n          {\n            CompositeOperator\n              compose;\n\n            const char*\n              value;\n\n            MagickBooleanType\n              clip_to_self;\n\n            Image\n              *mask_image,\n              *new_images,\n              *source_image;\n\n            RectangleInfo\n              geometry;\n\n            /* Compose value from \"-compose\" option only */\n            (void) SyncImageSettings(mogrify_info,*images,exception);\n            value=GetImageOption(mogrify_info,\"compose\");\n            if (value == (const char *) NULL)\n              compose=OverCompositeOp;  /* use Over not source_image->compose */\n            else\n              compose=(CompositeOperator) ParseCommandOption(\n                MagickComposeOptions,MagickFalse,value);\n\n            /* Get \"clip-to-self\" expert setting (false is normal) */\n            clip_to_self=GetCompositeClipToSelf(compose);\n            value=GetImageOption(mogrify_info,\"compose:clip-to-self\");\n            if (value != (const char *) NULL)\n              clip_to_self=IsStringTrue(value);\n            value=GetImageOption(mogrify_info,\"compose:outside-overlay\");\n            if (value != (const char *) NULL)\n              clip_to_self=IsStringFalse(value);  /* deprecated */\n\n            new_images=RemoveFirstImageFromList(images);\n            source_image=RemoveFirstImageFromList(images);\n            if (source_image == (Image *) NULL)\n              break; /* FUTURE - produce Exception, rather than silent fail */\n\n            /* FUTURE: this should not be here! - should be part of -geometry */\n            if (source_image->geometry != (char *) NULL)\n              {\n                RectangleInfo\n                  resize_geometry;\n\n                (void) ParseRegionGeometry(source_image,source_image->geometry,\n                  &resize_geometry,exception);\n                if ((source_image->columns != resize_geometry.width) ||\n                    (source_image->rows != resize_geometry.height))\n                  {\n                    Image\n                      *resize_image;\n\n                    resize_image=ResizeImage(source_image,resize_geometry.width,\n                      resize_geometry.height,source_image->filter,exception);\n                    if (resize_image != (Image *) NULL)\n                      {\n                        source_image=DestroyImage(source_image);\n                        source_image=resize_image;\n                      }\n                  }\n              }\n            SetGeometry(source_image,&geometry);\n            (void) ParseAbsoluteGeometry(source_image->geometry,&geometry);\n            GravityAdjustGeometry(new_images->columns,new_images->rows,\n              new_images->gravity,&geometry);\n            mask_image=RemoveFirstImageFromList(images);\n            if (mask_image == (Image *) NULL)\n              status&=CompositeImage(new_images,source_image,compose,\n                clip_to_self,geometry.x,geometry.y,exception);\n            else\n              {\n                if ((compose == DisplaceCompositeOp) ||\n                    (compose == DistortCompositeOp))\n                  {\n                    status&=CompositeImage(source_image,mask_image,\n                      CopyGreenCompositeOp,MagickTrue,0,0,exception);\n                    status&=CompositeImage(new_images,source_image,compose,\n                      clip_to_self,geometry.x,geometry.y,exception);\n                  }\n                else\n                  {\n                    Image\n                      *clone_image;\n\n                    clone_image=CloneImage(new_images,0,0,MagickTrue,exception);\n                    if (clone_image == (Image *) NULL)\n                      break;\n                    status&=CompositeImage(new_images,source_image,compose,\n                      clip_to_self,geometry.x,geometry.y,exception);\n                    status&=CompositeImage(new_images,mask_image,\n                      CopyAlphaCompositeOp,MagickTrue,0,0,exception);\n                    status&=CompositeImage(clone_image,new_images,\n                      OverCompositeOp,clip_to_self,0,0,exception);\n                    new_images=DestroyImageList(new_images);\n                    new_images=clone_image;\n                  }\n                mask_image=DestroyImage(mask_image);\n              }\n            source_image=DestroyImage(source_image);\n            *images=DestroyImageList(*images);\n            *images=new_images;\n            break;\n          }\n        if (LocaleCompare(\"copy\",option+1) == 0)\n          {\n            Image\n              *source_image;\n\n            OffsetInfo\n              offset;\n\n            RectangleInfo\n              geometry;\n\n            /*\n              Copy image pixels.\n            */\n            (void) SyncImageSettings(mogrify_info,*images,exception);\n            (void) ParsePageGeometry(*images,argv[i+2],&geometry,exception);\n            offset.x=geometry.x;\n            offset.y=geometry.y;\n            source_image=(*images);\n            if (source_image->next != (Image *) NULL)\n              source_image=source_image->next;\n            (void) ParsePageGeometry(source_image,argv[i+1],&geometry,\n              exception);\n            status=CopyImagePixels(*images,source_image,&geometry,&offset,\n              exception);\n            break;\n          }\n        break;\n      }\n      case 'd':\n      {\n        if (LocaleCompare(\"deconstruct\",option+1) == 0)\n          {\n            Image\n              *deconstruct_image;\n\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            deconstruct_image=CompareImagesLayers(*images,CompareAnyLayer,\n              exception);\n            if (deconstruct_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=deconstruct_image;\n            break;\n          }\n        if (LocaleCompare(\"delete\",option+1) == 0)\n          {\n            if (*option == '+')\n              DeleteImages(images,\"-1\",exception);\n            else\n              DeleteImages(images,argv[i+1],exception);\n            break;\n          }\n        if (LocaleCompare(\"dither\",option+1) == 0)\n          {\n            if (*option == '+')\n              {\n                quantize_info->dither_method=NoDitherMethod;\n                break;\n              }\n            quantize_info->dither_method=(DitherMethod) ParseCommandOption(\n              MagickDitherOptions,MagickFalse,argv[i+1]);\n            break;\n          }\n        if (LocaleCompare(\"duplicate\",option+1) == 0)\n          {\n            Image\n              *duplicate_images;\n\n            if (*option == '+')\n              duplicate_images=DuplicateImages(*images,1,\"-1\",exception);\n            else\n              {\n                const char\n                  *p;\n\n                size_t\n                  number_duplicates;\n\n                number_duplicates=(size_t) StringToLong(argv[i+1]);\n                p=strchr(argv[i+1],',');\n                if (p == (const char *) NULL)\n                  duplicate_images=DuplicateImages(*images,number_duplicates,\n                    \"-1\",exception);\n                else\n                  duplicate_images=DuplicateImages(*images,number_duplicates,p,\n                    exception);\n              }\n            AppendImageToList(images, duplicate_images);\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            break;\n          }\n        break;\n      }\n      case 'e':\n      {\n        if (LocaleCompare(\"evaluate-sequence\",option+1) == 0)\n          {\n            Image\n              *evaluate_image;\n\n            MagickEvaluateOperator\n              op;\n\n            (void) SyncImageSettings(mogrify_info,*images,exception);\n            op=(MagickEvaluateOperator) ParseCommandOption(\n              MagickEvaluateOptions,MagickFalse,argv[i+1]);\n            evaluate_image=EvaluateImages(*images,op,exception);\n            if (evaluate_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=evaluate_image;\n            break;\n          }\n        break;\n      }\n      case 'f':\n      {\n        if (LocaleCompare(\"fft\",option+1) == 0)\n          {\n            Image\n              *fourier_image;\n\n            /*\n              Implements the discrete Fourier transform (DFT).\n            */\n            (void) SyncImageSettings(mogrify_info,*images,exception);\n            fourier_image=ForwardFourierTransformImage(*images,*option == '-' ?\n              MagickTrue : MagickFalse,exception);\n            if (fourier_image == (Image *) NULL)\n              break;\n            *images=DestroyImageList(*images);\n            *images=fourier_image;\n            break;\n          }\n        if (LocaleCompare(\"flatten\",option+1) == 0)\n          {\n            Image\n              *flatten_image;\n\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            flatten_image=MergeImageLayers(*images,FlattenLayer,exception);\n            if (flatten_image == (Image *) NULL)\n              break;\n            *images=DestroyImageList(*images);\n            *images=flatten_image;\n            break;\n          }\n        if (LocaleCompare(\"fx\",option+1) == 0)\n          {\n            Image\n              *fx_image;\n\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            fx_image=FxImage(*images,argv[i+1],exception);\n            if (fx_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=fx_image;\n            break;\n          }\n        break;\n      }\n      case 'h':\n      {\n        if (LocaleCompare(\"hald-clut\",option+1) == 0)\n          {\n            Image\n              *hald_image,\n              *image;\n\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            image=RemoveFirstImageFromList(images);\n            hald_image=RemoveFirstImageFromList(images);\n            if (hald_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            (void) HaldClutImage(image,hald_image,exception);\n            hald_image=DestroyImage(hald_image);\n            if (*images != (Image *) NULL)\n              *images=DestroyImageList(*images);\n            *images=image;\n            break;\n          }\n        break;\n      }\n      case 'i':\n      {\n        if (LocaleCompare(\"ift\",option+1) == 0)\n          {\n            Image\n              *fourier_image,\n              *magnitude_image,\n              *phase_image;\n\n            /*\n              Implements the inverse fourier discrete Fourier transform (DFT).\n            */\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            magnitude_image=RemoveFirstImageFromList(images);\n            phase_image=RemoveFirstImageFromList(images);\n            if (phase_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            fourier_image=InverseFourierTransformImage(magnitude_image,\n              phase_image,*option == '-' ? MagickTrue : MagickFalse,exception);\n            if (fourier_image == (Image *) NULL)\n              break;\n            if (*images != (Image *) NULL)\n              *images=DestroyImageList(*images);\n            *images=fourier_image;\n            break;\n          }\n        if (LocaleCompare(\"insert\",option+1) == 0)\n          {\n            Image\n              *p,\n              *q;\n\n            index=0;\n            if (*option != '+')\n              index=(ssize_t) StringToLong(argv[i+1]);\n            p=RemoveLastImageFromList(images);\n            if (p == (Image *) NULL)\n              {\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  OptionError,\"NoSuchImage\",\"`%s'\",argv[i+1]);\n                status=MagickFalse;\n                break;\n              }\n            q=p;\n            if (index == 0)\n              PrependImageToList(images,q);\n            else\n              if (index == (ssize_t) GetImageListLength(*images))\n                AppendImageToList(images,q);\n              else\n                {\n                    q=GetImageFromList(*images,index-1);\n                    if (q == (Image *) NULL)\n                      {\n                        (void) ThrowMagickException(exception,GetMagickModule(),\n                          OptionError,\"NoSuchImage\",\"`%s'\",argv[i+1]);\n                        status=MagickFalse;\n                       break;\n                     }\n                  InsertImageInList(&q,p);\n                }\n            *images=GetFirstImageInList(q);\n            break;\n          }\n        if (LocaleCompare(\"interpolate\",option+1) == 0)\n          {\n            interpolate_method=(PixelInterpolateMethod) ParseCommandOption(\n              MagickInterpolateOptions,MagickFalse,argv[i+1]);\n            break;\n          }\n        break;\n      }\n      case 'l':\n      {\n        if (LocaleCompare(\"layers\",option+1) == 0)\n          {\n            Image\n              *layers;\n\n            LayerMethod\n              method;\n\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            layers=(Image *) NULL;\n            method=(LayerMethod) ParseCommandOption(MagickLayerOptions,\n              MagickFalse,argv[i+1]);\n            switch (method)\n            {\n              case CoalesceLayer:\n              {\n                layers=CoalesceImages(*images,exception);\n                break;\n              }\n              case CompareAnyLayer:\n              case CompareClearLayer:\n              case CompareOverlayLayer:\n              default:\n              {\n                layers=CompareImagesLayers(*images,method,exception);\n                break;\n              }\n              case MergeLayer:\n              case FlattenLayer:\n              case MosaicLayer:\n              case TrimBoundsLayer:\n              {\n                layers=MergeImageLayers(*images,method,exception);\n                break;\n              }\n              case DisposeLayer:\n              {\n                layers=DisposeImages(*images,exception);\n                break;\n              }\n              case OptimizeImageLayer:\n              {\n                layers=OptimizeImageLayers(*images,exception);\n                break;\n              }\n              case OptimizePlusLayer:\n              {\n                layers=OptimizePlusImageLayers(*images,exception);\n                break;\n              }\n              case OptimizeTransLayer:\n              {\n                OptimizeImageTransparency(*images,exception);\n                break;\n              }\n              case RemoveDupsLayer:\n              {\n                RemoveDuplicateLayers(images,exception);\n                break;\n              }\n              case RemoveZeroLayer:\n              {\n                RemoveZeroDelayLayers(images,exception);\n                break;\n              }\n              case OptimizeLayer:\n              {\n                /*\n                  General Purpose, GIF Animation Optimizer.\n                */\n                layers=CoalesceImages(*images,exception);\n                if (layers == (Image *) NULL)\n                  {\n                    status=MagickFalse;\n                    break;\n                  }\n                *images=DestroyImageList(*images);\n                *images=layers;\n                layers=OptimizeImageLayers(*images,exception);\n                if (layers == (Image *) NULL)\n                  {\n                    status=MagickFalse;\n                    break;\n                  }\n                *images=DestroyImageList(*images);\n                *images=layers;\n                layers=(Image *) NULL;\n                OptimizeImageTransparency(*images,exception);\n                (void) RemapImages(quantize_info,*images,(Image *) NULL,\n                  exception);\n                break;\n              }\n              case CompositeLayer:\n              {\n                CompositeOperator\n                  compose;\n\n                Image\n                  *source;\n\n                RectangleInfo\n                  geometry;\n\n                /*\n                  Split image sequence at the first 'NULL:' image.\n                */\n                source=(*images);\n                while (source != (Image *) NULL)\n                {\n                  source=GetNextImageInList(source);\n                  if ((source != (Image *) NULL) &&\n                      (LocaleCompare(source->magick,\"NULL\") == 0))\n                    break;\n                }\n                if (source != (Image *) NULL)\n                  {\n                    if ((GetPreviousImageInList(source) == (Image *) NULL) ||\n                        (GetNextImageInList(source) == (Image *) NULL))\n                      source=(Image *) NULL;\n                    else\n                      {\n                        /*\n                          Separate the two lists, junk the null: image.\n                        */\n                        source=SplitImageList(source->previous);\n                        DeleteImageFromList(&source);\n                      }\n                  }\n                if (source == (Image *) NULL)\n                  {\n                    (void) ThrowMagickException(exception,GetMagickModule(),\n                      OptionError,\"MissingNullSeparator\",\"layers Composite\");\n                    status=MagickFalse;\n                    break;\n                  }\n                /*\n                  Adjust offset with gravity and virtual canvas.\n                */\n                SetGeometry(*images,&geometry);\n                (void) ParseAbsoluteGeometry((*images)->geometry,&geometry);\n                geometry.width=source->page.width != 0 ?\n                  source->page.width : source->columns;\n                geometry.height=source->page.height != 0 ?\n                 source->page.height : source->rows;\n                GravityAdjustGeometry((*images)->page.width != 0 ?\n                  (*images)->page.width : (*images)->columns,\n                  (*images)->page.height != 0 ? (*images)->page.height :\n                  (*images)->rows,(*images)->gravity,&geometry);\n                compose=OverCompositeOp;\n                option=GetImageOption(mogrify_info,\"compose\");\n                if (option != (const char *) NULL)\n                  compose=(CompositeOperator) ParseCommandOption(\n                    MagickComposeOptions,MagickFalse,option);\n                CompositeLayers(*images,compose,source,geometry.x,geometry.y,\n                  exception);\n                source=DestroyImageList(source);\n                break;\n              }\n            }\n            if (layers == (Image *) NULL)\n              break;\n            *images=DestroyImageList(*images);\n            *images=layers;\n            break;\n          }\n        break;\n      }\n      case 'm':\n      {\n        if (LocaleCompare(\"map\",option+1) == 0)\n          {\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            if (*option == '+')\n              {\n                (void) RemapImages(quantize_info,*images,(Image *) NULL,\n                  exception);\n                break;\n              }\n            i++;\n            break;\n          }\n        if (LocaleCompare(\"maximum\",option+1) == 0)\n          {\n            Image\n              *maximum_image;\n\n            /*\n              Maximum image sequence (deprecated).\n            */\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            maximum_image=EvaluateImages(*images,MaxEvaluateOperator,exception);\n            if (maximum_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=maximum_image;\n            break;\n          }\n        if (LocaleCompare(\"minimum\",option+1) == 0)\n          {\n            Image\n              *minimum_image;\n\n            /*\n              Minimum image sequence (deprecated).\n            */\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            minimum_image=EvaluateImages(*images,MinEvaluateOperator,exception);\n            if (minimum_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=minimum_image;\n            break;\n          }\n        if (LocaleCompare(\"morph\",option+1) == 0)\n          {\n            Image\n              *morph_image;\n\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            morph_image=MorphImages(*images,StringToUnsignedLong(argv[i+1]),\n              exception);\n            if (morph_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=morph_image;\n            break;\n          }\n        if (LocaleCompare(\"mosaic\",option+1) == 0)\n          {\n            Image\n              *mosaic_image;\n\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            mosaic_image=MergeImageLayers(*images,MosaicLayer,exception);\n            if (mosaic_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=mosaic_image;\n            break;\n          }\n        break;\n      }\n      case 'p':\n      {\n        if (LocaleCompare(\"poly\",option+1) == 0)\n          {\n            char\n              *args,\n              token[MagickPathExtent];\n\n            const char\n              *p;\n\n            double\n              *arguments;\n\n            Image\n              *polynomial_image;\n\n            register ssize_t\n              x;\n\n            size_t\n              number_arguments;\n\n            /*\n              Polynomial image.\n            */\n            (void) SyncImageSettings(mogrify_info,*images,exception);\n            args=InterpretImageProperties(mogrify_info,*images,argv[i+1],\n              exception);\n            if (args == (char *) NULL)\n              break;\n            p=(char *) args;\n            for (x=0; *p != '\\0'; x++)\n            {\n              GetNextToken(p,&p,MagickPathExtent,token);\n              if (*token == ',')\n                GetNextToken(p,&p,MagickPathExtent,token);\n            }\n            number_arguments=(size_t) x;\n            arguments=(double *) AcquireQuantumMemory(number_arguments,\n              sizeof(*arguments));\n            if (arguments == (double *) NULL)\n              ThrowWandFatalException(ResourceLimitFatalError,\n                \"MemoryAllocationFailed\",(*images)->filename);\n            (void) memset(arguments,0,number_arguments*\n              sizeof(*arguments));\n            p=(char *) args;\n            for (x=0; (x < (ssize_t) number_arguments) && (*p != '\\0'); x++)\n            {\n              GetNextToken(p,&p,MagickPathExtent,token);\n              if (*token == ',')\n                GetNextToken(p,&p,MagickPathExtent,token);\n              arguments[x]=StringToDouble(token,(char **) NULL);\n            }\n            args=DestroyString(args);\n            polynomial_image=PolynomialImage(*images,number_arguments >> 1,\n              arguments,exception);\n            arguments=(double *) RelinquishMagickMemory(arguments);\n            if (polynomial_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=polynomial_image;\n          }\n        if (LocaleCompare(\"print\",option+1) == 0)\n          {\n            char\n              *string;\n\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            string=InterpretImageProperties(mogrify_info,*images,argv[i+1],\n              exception);\n            if (string == (char *) NULL)\n              break;\n            (void) FormatLocaleFile(stdout,\"%s\",string);\n            string=DestroyString(string);\n          }\n        if (LocaleCompare(\"process\",option+1) == 0)\n          {\n            char\n              **arguments;\n\n            int\n              j,\n              number_arguments;\n\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            arguments=StringToArgv(argv[i+1],&number_arguments);\n            if (arguments == (char **) NULL)\n              break;\n            if ((argc > 1) && (strchr(arguments[1],'=') != (char *) NULL))\n              {\n                char\n                  breaker,\n                  quote,\n                  *token;\n\n                const char\n                  *argument;\n\n                int\n                  next,\n                  token_status;\n\n                size_t\n                  length;\n\n                TokenInfo\n                  *token_info;\n\n                /*\n                  Support old style syntax, filter=\"-option arg\".\n                */\n                length=strlen(argv[i+1]);\n                token=(char *) NULL;\n                if (~length >= (MagickPathExtent-1))\n                  token=(char *) AcquireQuantumMemory(length+MagickPathExtent,\n                    sizeof(*token));\n                if (token == (char *) NULL)\n                  break;\n                next=0;\n                argument=argv[i+1];\n                token_info=AcquireTokenInfo();\n                token_status=Tokenizer(token_info,0,token,length,argument,\"\",\n                  \"=\",\"\\\"\",'\\0',&breaker,&next,&quote);\n                token_info=DestroyTokenInfo(token_info);\n                if (token_status == 0)\n                  {\n                    const char\n                      *arg;\n\n                    arg=(&(argument[next]));\n                    (void) InvokeDynamicImageFilter(token,&(*images),1,&arg,\n                      exception);\n                  }\n                token=DestroyString(token);\n                break;\n              }\n            (void) SubstituteString(&arguments[1],\"-\",\"\");\n            (void) InvokeDynamicImageFilter(arguments[1],&(*images),\n              number_arguments-2,(const char **) arguments+2,exception);\n            for (j=0; j < number_arguments; j++)\n              arguments[j]=DestroyString(arguments[j]);\n            arguments=(char **) RelinquishMagickMemory(arguments);\n            break;\n          }\n        break;\n      }\n      case 'r':\n      {\n        if (LocaleCompare(\"reverse\",option+1) == 0)\n          {\n            ReverseImageList(images);\n            break;\n          }\n        break;\n      }\n      case 's':\n      {\n        if (LocaleCompare(\"smush\",option+1) == 0)\n          {\n            Image\n              *smush_image;\n\n            ssize_t\n              offset;\n\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            offset=(ssize_t) StringToLong(argv[i+1]);\n            smush_image=SmushImages(*images,*option == '-' ? MagickTrue :\n              MagickFalse,offset,exception);\n            if (smush_image == (Image *) NULL)\n              {\n                status=MagickFalse;\n                break;\n              }\n            *images=DestroyImageList(*images);\n            *images=smush_image;\n            break;\n          }\n        if (LocaleCompare(\"swap\",option+1) == 0)\n          {\n            Image\n              *p,\n              *q,\n              *u,\n              *v;\n\n            ssize_t\n              swap_index;\n\n            index=(-1);\n            swap_index=(-2);\n            if (*option != '+')\n              {\n                GeometryInfo\n                  geometry_info;\n\n                MagickStatusType\n                  flags;\n\n                swap_index=(-1);\n                flags=ParseGeometry(argv[i+1],&geometry_info);\n                index=(ssize_t) geometry_info.rho;\n                if ((flags & SigmaValue) != 0)\n                  swap_index=(ssize_t) geometry_info.sigma;\n              }\n            p=GetImageFromList(*images,index);\n            q=GetImageFromList(*images,swap_index);\n            if ((p == (Image *) NULL) || (q == (Image *) NULL))\n              {\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  OptionError,\"NoSuchImage\",\"`%s'\",(*images)->filename);\n                status=MagickFalse;\n                break;\n              }\n            if (p == q)\n              break;\n            u=CloneImage(p,0,0,MagickTrue,exception);\n            if (u == (Image *) NULL)\n              break;\n            v=CloneImage(q,0,0,MagickTrue,exception);\n            if (v == (Image *) NULL)\n              {\n                u=DestroyImage(u);\n                break;\n              }\n            ReplaceImageInList(&p,v);\n            ReplaceImageInList(&q,u);\n            *images=GetFirstImageInList(q);\n            break;\n          }\n        break;\n      }\n      case 'w':\n      {\n        if (LocaleCompare(\"write\",option+1) == 0)\n          {\n            char\n              key[MagickPathExtent];\n\n            Image\n              *write_images;\n\n            ImageInfo\n              *write_info;\n\n            (void) SyncImagesSettings(mogrify_info,*images,exception);\n            (void) FormatLocaleString(key,MagickPathExtent,\"cache:%s\",\n              argv[i+1]);\n            (void) DeleteImageRegistry(key);\n            write_images=(*images);\n            if (*option == '+')\n              write_images=CloneImageList(*images,exception);\n            write_info=CloneImageInfo(mogrify_info);\n            status&=WriteImages(write_info,write_images,argv[i+1],exception);\n            write_info=DestroyImageInfo(write_info);\n            if (*option == '+')\n              write_images=DestroyImageList(write_images);\n            break;\n          }\n        break;\n      }\n      default:\n        break;\n    }\n    i+=count;\n  }\n  quantize_info=DestroyQuantizeInfo(quantize_info);\n  mogrify_info=DestroyImageInfo(mogrify_info);\n  status&=MogrifyImageInfo(image_info,argc,argv,exception);\n  return(status != 0 ? MagickTrue : MagickFalse);\n}\n", "target": 1, "idx": 183369}
{"func": " static inline void set_socket_blocking(int s, int blocking)\n {\n     int opts;\n    opts = fcntl(s, F_GETFL);\n     if (opts<0) APPL_TRACE_ERROR(\"set blocking (%s)\", strerror(errno));\n     if(blocking)\n         opts &= ~O_NONBLOCK;\n     else opts |= O_NONBLOCK;\n    if (fcntl(s, F_SETFL, opts) < 0)\n         APPL_TRACE_ERROR(\"set blocking (%s)\", strerror(errno));\n }\n", "target": 1, "idx": 187488}
{"func": "void PaintLayerScrollableArea::UpdateCompositingLayersAfterScroll() {\n  PaintLayerCompositor* compositor = GetLayoutBox()->View()->Compositor();\n  if (!compositor->InCompositingMode())\n    return;\n\n  if (UsesCompositedScrolling()) {\n     DCHECK(Layer()->HasCompositedLayerMapping());\n     ScrollingCoordinator* scrolling_coordinator = GetScrollingCoordinator();\n     bool handled_scroll =\n        Layer()->IsRootLayer() && scrolling_coordinator &&\n         scrolling_coordinator->UpdateCompositedScrollOffset(this);\n \n     if (!handled_scroll) {\n      if (!RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) {\n        Layer()->GetCompositedLayerMapping()->SetNeedsGraphicsLayerUpdate(\n            kGraphicsLayerUpdateSubtree);\n      }\n      compositor->SetNeedsCompositingUpdate(\n          kCompositingUpdateAfterGeometryChange);\n    }\n\n    if (Layer()->IsRootLayer()) {\n      LocalFrame* frame = GetLayoutBox()->GetFrame();\n      if (frame && frame->View() &&\n          frame->View()->HasViewportConstrainedObjects()) {\n        Layer()->SetNeedsCompositingInputsUpdate();\n      }\n    }\n  } else {\n    Layer()->SetNeedsCompositingInputsUpdate();\n  }\n}\n", "target": 1, "idx": 185960}
{"func": " std::string MasterPreferences::GetCompressedVariationsSeed() const {\n  return ExtractPrefString(prefs::kVariationsCompressedSeed);\n }\n", "target": 1, "idx": 185419}
{"func": "void BrowserWindowGtk::ShowOneClickSigninBubble(\n      const StartSyncCallback& start_sync_callback) {\n  new OneClickSigninBubbleGtk(this, start_sync_callback);\n}\n", "target": 0, "idx": 126436}
{"func": "static void ipa_device_begin(wmfAPI * API)\n{\n  char\n    comment[MaxTextExtent];\n\n  wmf_magick_t\n    *ddata = WMF_MAGICK_GetData(API);\n\n  /* Make SVG output happy */\n  (void) PushDrawingWand(WmfDrawingWand);\n\n  DrawSetViewbox(WmfDrawingWand, 0, 0, ddata->image->columns, ddata->image->rows );\n\n  (void) FormatLocaleString(comment,MaxTextExtent,\"Created by ImageMagick %s\",\n    GetMagickVersion((size_t *) NULL));\n  DrawComment(WmfDrawingWand,comment);\n\n  /* Scale width and height to image */\n  DrawScale(WmfDrawingWand, ddata->scale_x, ddata->scale_y);\n\n  /* Translate to TL corner of bounding box */\n  DrawTranslate(WmfDrawingWand, ddata->translate_x, ddata->translate_y);\n\n  /* Apply rotation */\n  DrawRotate(WmfDrawingWand, ddata->rotate);\n\n  if (ddata->image_info->texture == NULL)\n    {\n      PixelWand\n        *background_color;\n\n      /* Draw rectangle in background color */\n      background_color=NewPixelWand();\n      PixelSetQuantumColor(background_color,&ddata->image->background_color);\n      DrawSetFillColor(WmfDrawingWand,background_color);\n      background_color=DestroyPixelWand(background_color);\n      DrawRectangle(WmfDrawingWand,\n                     XC(ddata->bbox.TL.x),YC(ddata->bbox.TL.y),\n                     XC(ddata->bbox.BR.x),YC(ddata->bbox.BR.y));\n    }\n  else\n    {\n      /* Draw rectangle with texture image the SVG way */\n      Image\n        *image;\n\n      ImageInfo\n        *image_info;\n\n      ExceptionInfo\n        *exception;\n\n      exception=AcquireExceptionInfo();\n\n      image_info = CloneImageInfo((ImageInfo *) 0);\n      (void) CopyMagickString(image_info->filename,ddata->image_info->texture,\n        MaxTextExtent);\n      if ( ddata->image_info->size )\n        CloneString(&image_info->size,ddata->image_info->size);\n\n      image = ReadImage(image_info,exception);\n      image_info=DestroyImageInfo(image_info);\n      if (image)\n        {\n          char\n            pattern_id[30];\n\n          MagickWand\n            *magick_wand;\n\n          (void) CopyMagickString(image->magick,\"MIFF\",MaxTextExtent);\n          DrawPushDefs(WmfDrawingWand);\n          draw_pattern_push(API,ddata->pattern_id,image->columns,image->rows);\n          magick_wand=NewMagickWandFromImage(image);\n          (void) DrawComposite(WmfDrawingWand,CopyCompositeOp,0,0,\n            image->columns,image->rows,magick_wand);\n          magick_wand=DestroyMagickWand(magick_wand);\n          (void) DrawPopPattern(WmfDrawingWand);\n          DrawPopDefs(WmfDrawingWand);\n          (void) FormatLocaleString(pattern_id,MaxTextExtent,\"#brush_%lu\",\n            ddata->pattern_id);\n          (void) DrawSetFillPatternURL(WmfDrawingWand,pattern_id);\n          ++ddata->pattern_id;\n\n          DrawRectangle(WmfDrawingWand,\n                         XC(ddata->bbox.TL.x),YC(ddata->bbox.TL.y),\n                         XC(ddata->bbox.BR.x),YC(ddata->bbox.BR.y));\n          image=DestroyImageList(image);\n        }\n      else\n        {\n          LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"reading texture image failed!\");\n          InheritException(&ddata->image->exception,exception);\n        }\n      (void) DestroyExceptionInfo(exception);\n    }\n\n  DrawSetClipRule(WmfDrawingWand,EvenOddRule); /* Default for WMF is ALTERNATE polygon fill mode */\n  draw_fill_color_string(WmfDrawingWand,\"none\"); /* Default brush is WHITE_BRUSH */\n  draw_stroke_color_string(WmfDrawingWand,\"none\"); /* Default pen is BLACK_PEN */\n  DrawSetStrokeLineCap(WmfDrawingWand,ButtCap); /* Default linecap is PS_ENDCAP_FLAT */\n  DrawSetStrokeLineJoin(WmfDrawingWand,MiterJoin); /* Default linejoin is PS_JOIN_MITER */\n  draw_under_color_string(WmfDrawingWand,\"white\"); /* Default text box is white */\n}\n", "target": 0, "idx": 71817}
{"func": "bool AutocompleteEditModel::AcceptCurrentInstantPreview() {\n  return InstantController::CommitIfCurrent(controller_->GetInstant());\n}\n", "target": 0, "idx": 110770}
{"func": "SplashPath *Splash::makeDashedPath(SplashPath *path) {\n  SplashPath *dPath;\n  SplashCoord lineDashTotal;\n  SplashCoord lineDashStartPhase, lineDashDist, segLen;\n  SplashCoord x0, y0, x1, y1, xa, ya;\n  GBool lineDashStartOn, lineDashOn, newPath;\n  int lineDashStartIdx, lineDashIdx;\n  int i, j, k;\n\n  lineDashTotal = 0;\n  for (i = 0; i < state->lineDashLength; ++i) {\n    lineDashTotal += state->lineDash[i];\n  }\n  if (lineDashTotal == 0) {\n    return new SplashPath();\n  }\n  lineDashStartPhase = state->lineDashPhase;\n  i = splashFloor(lineDashStartPhase / lineDashTotal);\n  lineDashStartPhase -= (SplashCoord)i * lineDashTotal;\n   lineDashStartOn = gTrue;\n   lineDashStartIdx = 0;\n   if (lineDashStartPhase > 0) {\n    while (lineDashStartPhase >= state->lineDash[lineDashStartIdx]) {\n       lineDashStartOn = !lineDashStartOn;\n       lineDashStartPhase -= state->lineDash[lineDashStartIdx];\n       ++lineDashStartIdx;\n     }\n   }\n \n   dPath = new SplashPath();\n  while (i < path->length) {\n\n    for (j = i;\n\t j < path->length - 1 && !(path->flags[j] & splashPathLast);\n\t ++j) ;\n\n    lineDashOn = lineDashStartOn;\n    lineDashIdx = lineDashStartIdx;\n    lineDashDist = state->lineDash[lineDashIdx] - lineDashStartPhase;\n\n    newPath = gTrue;\n    for (k = i; k < j; ++k) {\n\n      x0 = path->pts[k].x;\n      y0 = path->pts[k].y;\n      x1 = path->pts[k+1].x;\n      y1 = path->pts[k+1].y;\n      segLen = splashDist(x0, y0, x1, y1);\n\n      while (segLen > 0) {\n\n\tif (lineDashDist >= segLen) {\n\t  if (lineDashOn) {\n\t    if (newPath) {\n\t      dPath->moveTo(x0, y0);\n\t      newPath = gFalse;\n\t    }\n\t    dPath->lineTo(x1, y1);\n\t  }\n\t  lineDashDist -= segLen;\n\t  segLen = 0;\n\n\t} else {\n\t  xa = x0 + (lineDashDist / segLen) * (x1 - x0);\n\t  ya = y0 + (lineDashDist / segLen) * (y1 - y0);\n\t  if (lineDashOn) {\n\t    if (newPath) {\n\t      dPath->moveTo(x0, y0);\n\t      newPath = gFalse;\n\t    }\n\t    dPath->lineTo(xa, ya);\n\t  }\n\t  x0 = xa;\n\t  y0 = ya;\n\t  segLen -= lineDashDist;\n\t  lineDashDist = 0;\n\t}\n\n\tif (lineDashDist <= 0) {\n\t  lineDashOn = !lineDashOn;\n\t  if (++lineDashIdx == state->lineDashLength) {\n\t    lineDashIdx = 0;\n\t  }\n\t  lineDashDist = state->lineDash[lineDashIdx];\n\t  newPath = gTrue;\n\t}\n      }\n    }\n    i = j + 1;\n  }\n  \n  if (dPath->length == 0) {\n    GBool allSame = gTrue;\n    for (int i = 0; allSame && i < path->length - 1; ++i) {\n      allSame = path->pts[i].x == path->pts[i + 1].x && path->pts[i].y == path->pts[i + 1].y;\n    }\n    if (allSame) {\n      x0 = path->pts[0].x;\n      y0 = path->pts[0].y;\n      dPath->moveTo(x0, y0);\n      dPath->lineTo(x0, y0);\n    }\n  }\n\n  return dPath;\n}\n", "target": 1, "idx": 177906}
{"func": "bool RendererPermissionsPolicyDelegate::IsRestrictedUrl(\n    const GURL& document_url,\n    std::string* error) {\n  if (dispatcher_->IsExtensionActive(kWebStoreAppId)) {\n    if (error)\n      *error = errors::kCannotScriptGallery;\n     return true;\n   }\n \n  if (SearchBouncer::GetInstance()->IsNewTabPage(document_url)) {\n     if (error)\n       *error = errors::kCannotScriptNtp;\n     return true;\n  }\n\n  return false;\n}\n", "target": 1, "idx": 187201}
{"func": "  void ProcessControlLaunched() {\n     base::ScopedAllowBlockingForTesting allow_blocking;\n     base::ProcessId service_pid;\n     EXPECT_TRUE(GetServiceProcessData(NULL, &service_pid));\n    EXPECT_NE(static_cast<base::ProcessId>(0), service_pid);\n#if defined(OS_WIN)\n    service_process_ =\n        base::Process::OpenWithAccess(service_pid,\n                                      SYNCHRONIZE | PROCESS_QUERY_INFORMATION);\n#else\n     service_process_ = base::Process::Open(service_pid);\n #endif\n     EXPECT_TRUE(service_process_.IsValid());\n    base::ThreadTaskRunnerHandle::Get()->PostTask(\n        FROM_HERE, base::RunLoop::QuitCurrentWhenIdleClosureDeprecated());\n   }\n", "target": 1, "idx": 185966}
{"func": "launch_login(struct passwd *pw, const char *hostname)\n{\n\t/* Launch login(1). */\n\n\texecl(LOGIN_PROGRAM, \"login\", \"-h\", hostname,\n#ifdef xxxLOGIN_NEEDS_TERM\n\t\t    (s->term ? s->term : \"unknown\"),\n#endif /* LOGIN_NEEDS_TERM */\n#ifdef LOGIN_NO_ENDOPT\n\t    \"-p\", \"-f\", pw->pw_name, (char *)NULL);\n#else\n\t    \"-p\", \"-f\", \"--\", pw->pw_name, (char *)NULL);\n#endif\n\n\t/* Login couldn't be executed, die. */\n\n\tperror(\"login\");\n\texit(1);\n}\n", "target": 0, "idx": 14397}
{"func": "int EC_POINT_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *g_scalar,\n                 const EC_POINT *point, const BIGNUM *p_scalar, BN_CTX *ctx)\n{\n    /* just a convenient interface to EC_POINTs_mul() */\n\n    const EC_POINT *points[1];\n    const BIGNUM *scalars[1];\n\n    points[0] = point;\n    scalars[0] = p_scalar;\n\n    return EC_POINTs_mul(group, r, g_scalar,\n                         (point != NULL\n                          && p_scalar != NULL), points, scalars, ctx);\n}\n", "target": 0, "idx": 12084}
{"func": "status_t Camera3Device::createDefaultRequest(int templateId,\n\n         CameraMetadata *request) {\n     ATRACE_CALL();\n     ALOGV(\"%s: for template %d\", __FUNCTION__, templateId);\n     Mutex::Autolock il(mInterfaceLock);\n     Mutex::Autolock l(mLock);\n \n switch (mStatus) {\n case STATUS_ERROR:\n            CLOGE(\"Device has encountered a serious error\");\n return INVALID_OPERATION;\n case STATUS_UNINITIALIZED:\n            CLOGE(\"Device is not initialized!\");\n return INVALID_OPERATION;\n case STATUS_UNCONFIGURED:\n case STATUS_CONFIGURED:\n case STATUS_ACTIVE:\n break;\n default:\n            SET_ERR_L(\"Unexpected status: %d\", mStatus);\n return INVALID_OPERATION;\n }\n\n if (!mRequestTemplateCache[templateId].isEmpty()) {\n *request = mRequestTemplateCache[templateId];\n return OK;\n }\n\n const camera_metadata_t *rawRequest;\n    ATRACE_BEGIN(\"camera3->construct_default_request_settings\");\n    rawRequest = mHal3Device->ops->construct_default_request_settings(\n        mHal3Device, templateId);\n    ATRACE_END();\n if (rawRequest == NULL) {\n        ALOGI(\"%s: template %d is not supported on this camera device\",\n              __FUNCTION__, templateId);\n return BAD_VALUE;\n }\n *request = rawRequest;\n    mRequestTemplateCache[templateId] = rawRequest;\n\n return OK;\n}\n", "target": 1, "idx": 187905}
{"func": "bool ResourceTracker::UnrefResource(PP_Resource res) {\n  DLOG_IF(ERROR, !CheckIdType(res, PP_ID_TYPE_RESOURCE))\n      << res << \" is not a PP_Resource.\";\n  ResourceMap::iterator i = live_resources_.find(res);\n  if (i != live_resources_.end()) {\n    if (!--i->second.second) {\n      Resource* to_release = i->second.first;\n       PP_Instance instance = to_release->instance()->pp_instance();\n      to_release->LastPluginRefWasDeleted(false);\n \n      instance_map_[instance]->resources.erase(res);\n       live_resources_.erase(i);\n     }\n     return true;\n  } else {\n    return false;\n  }\n}\n", "target": 1, "idx": 183876}
{"func": "v8::Handle<v8::Value> V8Proxy::throwNotEnoughArgumentsError()\n {\n    return throwError(TypeError, \"Not enough arguments\");\n }\n", "target": 1, "idx": 184802}
{"func": "static const wbxml_decoding *get_wbxml_decoding_from_content_type (\n\t\t\t\t\t\t\t\t   const char *content_type, tvbuff_t *tvb, guint32 offset)\n{\n\tconst wbxml_decoding *map = NULL;\n\n\tDebugLog((\"get_wbxml_decoding_from_content_type: content_type = [%s]\\n\",\n\t\t  content_type));\n\tif (content_type && content_type[0]) {\n\t\tconst wbxml_literal_list *item = content_type_list;\n\n\t\twhile (item && item->content_type) {\n\t\t\tif (g_ascii_strcasecmp(content_type, item->content_type) == 0) {\n\t\t\t\t/* Try the discriminator */\n\t\t\t\tif (item->discriminator != NULL) {\n\t\t\t\t\tmap = item->discriminator(tvb, offset);\n\t\t\t\t}\n\t\t\t\tif (map == NULL) {\n\t\t\t\t\tmap = item->map;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\titem++;\n\t\t}\n\t}\n\treturn map;\n}\n", "target": 0, "idx": 51709}
{"func": "OMX_ERRORTYPE SoftRaw::internalGetParameter(\n        OMX_INDEXTYPE index, OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamAudioPcm:\n {\n\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex != 0 && pcmParams->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            pcmParams->eNumData = OMX_NumericalDataSigned;\n            pcmParams->eEndian = OMX_EndianBig;\n            pcmParams->bInterleaved = OMX_TRUE;\n            pcmParams->nBitPerSample = 16;\n            pcmParams->ePCMMode = OMX_AUDIO_PCMModeLinear;\n            pcmParams->eChannelMapping[0] = OMX_AUDIO_ChannelLF;\n            pcmParams->eChannelMapping[1] = OMX_AUDIO_ChannelRF;\n\n            pcmParams->nChannels = mChannelCount;\n            pcmParams->nSamplingRate = mSampleRate;\n\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalGetParameter(index, params);\n }\n}\n", "target": 1, "idx": 188240}
{"func": " do_prefetch_tables (const void *gcmM, size_t gcmM_size)\n {\n   prefetch_table(gcmM, gcmM_size);\n  prefetch_table(gcmR, sizeof(gcmR));\n }\n", "target": 1, "idx": 182822}
{"func": "static void perf_swevent_del(struct perf_event *event, int flags)\n{\n\thlist_del_rcu(&event->hlist_entry);\n}\n", "target": 0, "idx": 26166}
{"func": " InterstitialPage* WebContentsImpl::GetInterstitialPage() const {\n  return GetRenderManager()->interstitial_page();\n }\n", "target": 1, "idx": 186297}
{"func": "static void save_nonewprivs(void) {\n\tif (arg_nonewprivs == 0)\n\t\treturn;\n\n\tFILE *fp = fopen(RUN_NONEWPRIVS_CFG, \"wxe\");\n\tif (fp) {\n\t\tfprintf(fp, \"\\n\");\n\t\tSET_PERMS_STREAM(fp, 0, 0, 0644); // assume mode 0644\n\t\tfclose(fp);\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: cannot save nonewprivs state\\n\");\n\t\texit(1);\n\t}\n}\n", "target": 0, "idx": 89765}
{"func": "void PPB_Buffer_Proxy::OnMsgCreate(\n    PP_Instance instance,\n    uint32_t size,\n    HostResource* result_resource,\n    ppapi::proxy::SerializedHandle* result_shm_handle) {\n  result_shm_handle->set_null_shmem();\n   HostDispatcher* dispatcher = HostDispatcher::GetForInstance(instance);\n   if (!dispatcher)\n     return;\n \n   thunk::EnterResourceCreation enter(instance);\n   if (enter.failed())\n    return;\n  PP_Resource local_buffer_resource = enter.functions()->CreateBuffer(instance,\n                                                                      size);\n  if (local_buffer_resource == 0)\n    return;\n\n  thunk::EnterResourceNoLock<thunk::PPB_BufferTrusted_API> trusted_buffer(\n      local_buffer_resource, false);\n  if (trusted_buffer.failed())\n    return;\n  int local_fd;\n  if (trusted_buffer.object()->GetSharedMemory(&local_fd) != PP_OK)\n    return;\n\n  result_resource->SetHostResource(instance, local_buffer_resource);\n\n  base::PlatformFile platform_file =\n#if defined(OS_WIN)\n      reinterpret_cast<HANDLE>(static_cast<intptr_t>(local_fd));\n#elif defined(OS_POSIX)\n      local_fd;\n#else\n  #error Not implemented.\n#endif\n  result_shm_handle->set_shmem(\n      dispatcher->ShareHandleWithRemote(platform_file, false), size);\n}\n", "target": 1, "idx": 185039}
{"func": " long Segment::ParseCues(long long off, long long& pos, long& len) {\n   if (m_pCues)\n     return 0;  // success\n\n if (off < 0)\n return -1;\n\n long long total, avail;\n\n const int status = m_pReader->Length(&total, &avail);\n\n if (status < 0) // error\n return status;\n\n  assert((total < 0) || (avail <= total));\n\n  pos = m_start + off;\n\n if ((total < 0) || (pos >= total))\n return 1; // don't bother parsing cues\n\n const long long element_start = pos;\n const long long segment_stop = (m_size < 0) ? -1 : m_start + m_size;\n\n if ((pos + 1) > avail) {\n    len = 1;\n return E_BUFFER_NOT_FULL;\n }\n\n long long result = GetUIntLength(m_pReader, pos, len);\n\n if (result < 0) // error\n return static_cast<long>(result);\n\n if (result > 0) // underflow (weird)\n {\n    len = 1;\n return E_BUFFER_NOT_FULL;\n }\n\n if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n return E_FILE_FORMAT_INVALID;\n\n if ((pos + len) > avail)\n return E_BUFFER_NOT_FULL;\n\n \n   const long long idpos = pos;\n \n  const long long id = ReadUInt(m_pReader, idpos, len);\n \n   if (id != 0x0C53BB6B)  // Cues ID\n     return E_FILE_FORMAT_INVALID;\n\n  pos += len; // consume ID\n  assert((segment_stop < 0) || (pos <= segment_stop));\n\n\n if ((pos + 1) > avail) {\n    len = 1;\n return E_BUFFER_NOT_FULL;\n }\n\n  result = GetUIntLength(m_pReader, pos, len);\n\n if (result < 0) // error\n return static_cast<long>(result);\n\n if (result > 0) // underflow (weird)\n {\n    len = 1;\n return E_BUFFER_NOT_FULL;\n }\n\n if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n return E_FILE_FORMAT_INVALID;\n\n if ((pos + len) > avail)\n return E_BUFFER_NOT_FULL;\n\n const long long size = ReadUInt(m_pReader, pos, len);\n\n if (size < 0) // error\n return static_cast<long>(size);\n\n if (size == 0) // weird, although technically not illegal\n return 1; // done\n\n  pos += len; // consume length of size of element\n  assert((segment_stop < 0) || (pos <= segment_stop));\n\n\n const long long element_stop = pos + size;\n\n if ((segment_stop >= 0) && (element_stop > segment_stop))\n return E_FILE_FORMAT_INVALID;\n\n if ((total >= 0) && (element_stop > total))\n return 1; // don't bother parsing anymore\n\n  len = static_cast<long>(size);\n\n if (element_stop > avail)\n return E_BUFFER_NOT_FULL;\n\n const long long element_size = element_stop - element_start;\n\n \n   m_pCues =\n       new (std::nothrow) Cues(this, pos, size, element_start, element_size);\n  assert(m_pCues);  // TODO\n \n   return 0;  // success\n }\n", "target": 1, "idx": 187874}
{"func": "size_t compile_tree(struct filter_op **fop)\n{\n   int i = 1;\n    struct filter_op *array = NULL;\n    struct unfold_elm *ue;\n \n   BUG_IF(tree_root == NULL);\n   \n    fprintf(stdout, \" Unfolding the meta-tree \");\n    fflush(stdout);\n     \n   /* start the recursion on the tree */\n   unfold_blk(&tree_root);\n\n   fprintf(stdout, \" done.\\n\\n\");\n\n   /* substitute the virtual labels with real offsets */\n   labels_to_offsets();\n   \n   /* convert the tailq into an array */\n   TAILQ_FOREACH(ue, &unfolded_tree, next) {\n\n      /* label == 0 means a real instruction */\n      if (ue->label == 0) {\n         SAFE_REALLOC(array, i * sizeof(struct filter_op));\n         memcpy(&array[i - 1], &ue->fop, sizeof(struct filter_op));\n         i++;\n      }\n   }\n   \n   /* always append the exit function to a script */\n   SAFE_REALLOC(array, i * sizeof(struct filter_op));\n   array[i - 1].opcode = FOP_EXIT;\n   \n   /* return the pointer to the array */\n   *fop = array;\n   \n   return (i);\n}\n", "target": 1, "idx": 181508}
{"func": "ssh_packet_backup_state(struct ssh *ssh,\n    struct ssh *backup_state)\n{\n\tstruct ssh *tmp;\n\n\tclose(ssh->state->connection_in);\n\tssh->state->connection_in = -1;\n\tclose(ssh->state->connection_out);\n\tssh->state->connection_out = -1;\n\tif (backup_state)\n\t\ttmp = backup_state;\n\telse\n\t\ttmp = ssh_alloc_session_state();\n\tbackup_state = ssh;\n\tssh = tmp;\n}\n", "target": 0, "idx": 12949}
{"func": "static unsigned int readuint(FILE * f, int bigendian)\n{\n    unsigned char c1, c2, c3, c4;\n    if (!fread(&c1, 1, 1, f)) {\n        fprintf(stderr,\n                \"\\nError: fread return a number of element different from the expected.\\n\");\n        return 0;\n    }\n    if (!fread(&c2, 1, 1, f)) {\n        fprintf(stderr,\n                \"\\nError: fread return a number of element different from the expected.\\n\");\n        return 0;\n    }\n    if (!fread(&c3, 1, 1, f)) {\n        fprintf(stderr,\n                \"\\nError: fread return a number of element different from the expected.\\n\");\n        return 0;\n    }\n    if (!fread(&c4, 1, 1, f)) {\n        fprintf(stderr,\n                \"\\nError: fread return a number of element different from the expected.\\n\");\n        return 0;\n    }\n    if (bigendian) {\n        return (unsigned int)(c1 << 24) + (unsigned int)(c2 << 16) + (unsigned int)(\n                   c3 << 8) + c4;\n    } else {\n        return (unsigned int)(c4 << 24) + (unsigned int)(c3 << 16) + (unsigned int)(\n                   c2 << 8) + c1;\n    }\n}\n", "target": 0, "idx": 61898}
{"func": " static int getStrrtokenPos(char* str, int savedPos)\n {\n \tint result =-1;\n \tint i;\n \tfor(i=savedPos-1; i>=0; i--) {\n \t\tif(isIDSeparator(*(str+i)) ){\n \t\t\t/* delimiter found; check for singleton */\n\t\t\tif(i>=2 && isIDSeparator(*(str+i-2)) ){\n\t\t\t\t/* a singleton; so send the position of token before the singleton */\n\t\t\t\tresult = i-2;\n\t\t\t} else {\n\t\t\t\tresult = i;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(result < 1){\n\t\t/* Just in case inavlid locale e.g. '-x-xyz' or '-sl_Latn' */\n\t\tresult =-1;\n\t}\n\treturn result;\n}\n", "target": 1, "idx": 180375}
{"func": "void ExtensionService::SyncExtensionChangeIfNeeded(const Extension& extension) {\n  SyncBundle* sync_bundle = GetSyncBundleForExtension(extension);\n  if (sync_bundle) {\n    ExtensionSyncData extension_sync_data(extension,\n                                          IsExtensionEnabled(extension.id()),\n                                          IsIncognitoEnabled(extension.id()));\n\n    SyncChangeList sync_change_list(1, extension_sync_data.GetSyncChange(\n        sync_bundle->HasExtensionId(extension.id()) ?\n            SyncChange::ACTION_UPDATE : SyncChange::ACTION_ADD));\n    sync_bundle->sync_processor->ProcessSyncChanges(\n        FROM_HERE, sync_change_list);\n    sync_bundle->synced_extensions.insert(extension.id());\n    sync_bundle->pending_sync_data.erase(extension.id());\n  }\n}\n", "target": 0, "idx": 103527}
{"func": "void smp_send_pair_fail(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n  p_cb->status = p_data->status;\n  p_cb->failure = p_data->status;\n\n  SMP_TRACE_DEBUG(\"%s: status=%d failure=%d \", __func__, p_cb->status,\n                  p_cb->failure);\n\n if (p_cb->status <= SMP_MAX_FAIL_RSN_PER_SPEC &&\n      p_cb->status != SMP_SUCCESS) {\n    smp_send_cmd(SMP_OPCODE_PAIRING_FAILED, p_cb);\n    p_cb->wait_for_authorization_complete = true;\n }\n}\n", "target": 0, "idx": 175956}
{"func": "static void charstring_end(void)\n{\n  byte *bp;\n\n  sprintf(line, \"%d \", (int) (charstring_bp - charstring_buf));\n  eexec_string(line);\n  sprintf(line, \"%s \", cs_start);\n  eexec_string(line);\n  for (bp = charstring_buf; bp < charstring_bp; bp++)\n    eexec_byte(*bp);\n}\n", "target": 0, "idx": 43217}
{"func": "int ssl3_send_alert(SSL *s, int level, int desc)\n{\n    /* Map tls/ssl alert value to correct one */\n    desc = s->method->ssl3_enc->alert_value(desc);\n    if (s->version == SSL3_VERSION && desc == SSL_AD_PROTOCOL_VERSION)\n        desc = SSL_AD_HANDSHAKE_FAILURE; /* SSL 3.0 does not have\n                                          * protocol_version alerts */\n                                           * protocol_version alerts */\n     if (desc < 0)\n         return -1;\n    /* If a fatal one, remove from cache */\n    if ((level == 2) && (s->session != NULL))\n        SSL_CTX_remove_session(s->session_ctx, s->session);\n \n     s->s3->alert_dispatch = 1;\n     s->s3->send_alert[0] = level;\n     * else data is still being written out, we will get written some time in\n     * the future\n     */\n    return -1;\n}\n", "target": 1, "idx": 178313}
{"func": "bool GLES2DecoderImpl::DoBindOrCopyTexImageIfNeeded(Texture* texture,\n                                                    GLenum textarget,\n                                                    GLuint texture_unit) {\n  if (texture && !texture->IsAttachedToFramebuffer()) {\n    Texture::ImageState image_state;\n    gl::GLImage* image = texture->GetLevelImage(textarget, 0, &image_state);\n    if (image && image_state == Texture::UNBOUND) {\n      ScopedGLErrorSuppressor suppressor(\n          \"GLES2DecoderImpl::DoBindOrCopyTexImageIfNeeded\", GetErrorState());\n      if (texture_unit)\n        api()->glActiveTextureFn(texture_unit);\n      api()->glBindTextureFn(textarget, texture->service_id());\n      if (image->BindTexImage(textarget)) {\n        image_state = Texture::BOUND;\n      } else {\n        DoCopyTexImage(texture, textarget, image);\n      }\n      if (!texture_unit) {\n        RestoreCurrentTextureBindings(&state_, textarget,\n                                      state_.active_texture_unit);\n        return false;\n      }\n      return true;\n    }\n  }\n  return false;\n}\n", "target": 0, "idx": 158672}
{"func": "static inline long decode_twos_comp(ulong c, int prec)\n {\n \tlong result;\n \tassert(prec >= 2);\n\tjas_eprintf(\"warning: support for signed data is untested\\n\");\n\tresult = (c & ((1 << (prec - 1)) - 1)) - (c & (1 << (prec - 1)));\n \treturn result;\n }\n", "target": 1, "idx": 181863}
{"func": "     ~OffScreenRootWindow()\n     {\n         if (!--refCount) {\n#if PLATFORM(QT)\n            delete window;\n            window = 0;\n#elif PLATFORM(EFL)\n             XUnmapWindow(display, window);\n             XDestroyWindow(display, window);\n#endif\n         }\n     }\n", "target": 1, "idx": 183715}
{"func": "String HTMLInputElement::accept() const\n{\n    return fastGetAttribute(acceptAttr);\n}\n", "target": 0, "idx": 121112}
{"func": "static int hex(char c)\n{\n\tchar lc = tolower(c);\n\n\tif (isdigit(lc))\n\t\treturn lc - '0';\n\tif (isxdigit(lc))\n\t\treturn lc - 'a' + 10;\n\treturn -1;\n}\n", "target": 0, "idx": 86939}
{"func": "lmp_print(netdissect_options *ndo,\n          register const u_char *pptr, register u_int len)\n{\n    const struct lmp_common_header *lmp_com_header;\n    const struct lmp_object_header *lmp_obj_header;\n    const u_char *tptr,*obj_tptr;\n    u_int tlen,lmp_obj_len,lmp_obj_ctype,obj_tlen;\n    int hexdump, ret;\n    u_int offset;\n    u_int link_type;\n\n    union { /* int to float conversion buffer */\n        float f;\n        uint32_t i;\n    } bw;\n\n    tptr=pptr;\n    lmp_com_header = (const struct lmp_common_header *)pptr;\n    ND_TCHECK(*lmp_com_header);\n\n    /*\n     * Sanity checking of the header.\n     */\n    if (LMP_EXTRACT_VERSION(lmp_com_header->version_res[0]) != LMP_VERSION) {\n\tND_PRINT((ndo, \"LMP version %u packet not supported\",\n               LMP_EXTRACT_VERSION(lmp_com_header->version_res[0])));\n\treturn;\n    }\n\n    /* in non-verbose mode just lets print the basic Message Type*/\n    if (ndo->ndo_vflag < 1) {\n        ND_PRINT((ndo, \"LMPv%u %s Message, length: %u\",\n               LMP_EXTRACT_VERSION(lmp_com_header->version_res[0]),\n               tok2str(lmp_msg_type_values, \"unknown (%u)\",lmp_com_header->msg_type),\n               len));\n        return;\n    }\n\n    /* ok they seem to want to know everything - lets fully decode it */\n\n    tlen=EXTRACT_16BITS(lmp_com_header->length);\n\n    ND_PRINT((ndo, \"\\n\\tLMPv%u, msg-type: %s, Flags: [%s], length: %u\",\n           LMP_EXTRACT_VERSION(lmp_com_header->version_res[0]),\n           tok2str(lmp_msg_type_values, \"unknown, type: %u\",lmp_com_header->msg_type),\n           bittok2str(lmp_header_flag_values,\"none\",lmp_com_header->flags),\n           tlen));\n    if (tlen < sizeof(const struct lmp_common_header)) {\n        ND_PRINT((ndo, \" (too short)\"));\n        return;\n    }\n    if (tlen > len) {\n        ND_PRINT((ndo, \" (too long)\"));\n        tlen = len;\n    }\n\n    tptr+=sizeof(const struct lmp_common_header);\n    tlen-=sizeof(const struct lmp_common_header);\n\n    while(tlen>0) {\n        /* did we capture enough for fully decoding the object header ? */\n        ND_TCHECK2(*tptr, sizeof(struct lmp_object_header));\n\n        lmp_obj_header = (const struct lmp_object_header *)tptr;\n        lmp_obj_len=EXTRACT_16BITS(lmp_obj_header->length);\n        lmp_obj_ctype=(lmp_obj_header->ctype)&0x7f;\n\n        ND_PRINT((ndo, \"\\n\\t  %s Object (%u), Class-Type: %s (%u) Flags: [%snegotiable], length: %u\",\n               tok2str(lmp_obj_values,\n                       \"Unknown\",\n                       lmp_obj_header->class_num),\n               lmp_obj_header->class_num,\n               tok2str(lmp_ctype_values,\n                       \"Unknown\",\n                       ((lmp_obj_header->class_num)<<8)+lmp_obj_ctype),\n               lmp_obj_ctype,\n               (lmp_obj_header->ctype)&0x80 ? \"\" : \"non-\",\n               lmp_obj_len));\n\n        if (lmp_obj_len < 4) {\n            ND_PRINT((ndo, \" (too short)\"));\n            return;\n        }\n        if ((lmp_obj_len % 4) != 0) {\n            ND_PRINT((ndo, \" (not a multiple of 4)\"));\n            return;\n        }\n\n        obj_tptr=tptr+sizeof(struct lmp_object_header);\n        obj_tlen=lmp_obj_len-sizeof(struct lmp_object_header);\n\n        /* did we capture enough for fully decoding the object ? */\n        ND_TCHECK2(*tptr, lmp_obj_len);\n        hexdump=FALSE;\n\n        switch(lmp_obj_header->class_num) {\n\n        case LMP_OBJ_CC_ID:\n            switch(lmp_obj_ctype) {\n            case LMP_CTYPE_LOC:\n            case LMP_CTYPE_RMT:\n                if (obj_tlen != 4) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n                ND_PRINT((ndo, \"\\n\\t    Control Channel ID: %u (0x%08x)\",\n                       EXTRACT_32BITS(obj_tptr),\n                       EXTRACT_32BITS(obj_tptr)));\n                break;\n\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case LMP_OBJ_LINK_ID:\n        case LMP_OBJ_INTERFACE_ID:\n            switch(lmp_obj_ctype) {\n            case LMP_CTYPE_IPV4_LOC:\n            case LMP_CTYPE_IPV4_RMT:\n                if (obj_tlen != 4) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n                ND_PRINT((ndo, \"\\n\\t    IPv4 Link ID: %s (0x%08x)\",\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_32BITS(obj_tptr)));\n                break;\n            case LMP_CTYPE_IPV6_LOC:\n            case LMP_CTYPE_IPV6_RMT:\n                if (obj_tlen != 16) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n                ND_PRINT((ndo, \"\\n\\t    IPv6 Link ID: %s (0x%08x)\",\n                       ip6addr_string(ndo, obj_tptr),\n                       EXTRACT_32BITS(obj_tptr)));\n                break;\n            case LMP_CTYPE_UNMD_LOC:\n            case LMP_CTYPE_UNMD_RMT:\n                if (obj_tlen != 4) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n                ND_PRINT((ndo, \"\\n\\t    Link ID: %u (0x%08x)\",\n                       EXTRACT_32BITS(obj_tptr),\n                       EXTRACT_32BITS(obj_tptr)));\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case LMP_OBJ_MESSAGE_ID:\n            switch(lmp_obj_ctype) {\n            case LMP_CTYPE_1:\n                if (obj_tlen != 4) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n                ND_PRINT((ndo, \"\\n\\t    Message ID: %u (0x%08x)\",\n                       EXTRACT_32BITS(obj_tptr),\n                       EXTRACT_32BITS(obj_tptr)));\n                break;\n            case LMP_CTYPE_2:\n                if (obj_tlen != 4) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n                ND_PRINT((ndo, \"\\n\\t    Message ID Ack: %u (0x%08x)\",\n                       EXTRACT_32BITS(obj_tptr),\n                       EXTRACT_32BITS(obj_tptr)));\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case LMP_OBJ_NODE_ID:\n            switch(lmp_obj_ctype) {\n            case LMP_CTYPE_LOC:\n            case LMP_CTYPE_RMT:\n                if (obj_tlen != 4) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n                ND_PRINT((ndo, \"\\n\\t    Node ID: %s (0x%08x)\",\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_32BITS(obj_tptr)));\n                break;\n\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case LMP_OBJ_CONFIG:\n            switch(lmp_obj_ctype) {\n            case LMP_CTYPE_HELLO_CONFIG:\n                if (obj_tlen != 4) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n                ND_PRINT((ndo, \"\\n\\t    Hello Interval: %u\\n\\t    Hello Dead Interval: %u\",\n                       EXTRACT_16BITS(obj_tptr),\n                       EXTRACT_16BITS(obj_tptr+2)));\n                break;\n\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case LMP_OBJ_HELLO:\n            switch(lmp_obj_ctype) {\n\t    case LMP_CTYPE_HELLO:\n                if (obj_tlen != 8) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n                ND_PRINT((ndo, \"\\n\\t    Tx Seq: %u, Rx Seq: %u\",\n                       EXTRACT_32BITS(obj_tptr),\n                       EXTRACT_32BITS(obj_tptr+4)));\n                break;\n\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case LMP_OBJ_TE_LINK:\n\t    switch(lmp_obj_ctype) {\n\t    case LMP_CTYPE_IPV4:\n                if (obj_tlen != 12) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n\t\tND_PRINT((ndo, \"\\n\\t    Flags: [%s]\",\n\t\t    bittok2str(lmp_obj_te_link_flag_values,\n\t\t\t\"none\",\n\t\t\tEXTRACT_8BITS(obj_tptr))));\n\n\t\tND_PRINT((ndo, \"\\n\\t    Local Link-ID: %s (0x%08x)\"\n\t\t       \"\\n\\t    Remote Link-ID: %s (0x%08x)\",\n                       ipaddr_string(ndo, obj_tptr+4),\n                       EXTRACT_32BITS(obj_tptr+4),\n                       ipaddr_string(ndo, obj_tptr+8),\n                       EXTRACT_32BITS(obj_tptr+8)));\n\t\tbreak;\n\n\t    case LMP_CTYPE_IPV6:\n                if (obj_tlen != 36) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n\t\tND_PRINT((ndo, \"\\n\\t    Flags: [%s]\",\n\t\t    bittok2str(lmp_obj_te_link_flag_values,\n\t\t\t\"none\",\n\t\t\tEXTRACT_8BITS(obj_tptr))));\n\n\t\tND_PRINT((ndo, \"\\n\\t    Local Link-ID: %s (0x%08x)\"\n\t\t       \"\\n\\t    Remote Link-ID: %s (0x%08x)\",\n                       ip6addr_string(ndo, obj_tptr+4),\n                       EXTRACT_32BITS(obj_tptr+4),\n                       ip6addr_string(ndo, obj_tptr+20),\n                       EXTRACT_32BITS(obj_tptr+20)));\n                break;\n\n\t    case LMP_CTYPE_UNMD:\n                if (obj_tlen != 12) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n\t\tND_PRINT((ndo, \"\\n\\t    Flags: [%s]\",\n\t\t    bittok2str(lmp_obj_te_link_flag_values,\n\t\t\t\"none\",\n\t\t\tEXTRACT_8BITS(obj_tptr))));\n\n\t\tND_PRINT((ndo, \"\\n\\t    Local Link-ID: %u (0x%08x)\"\n\t\t       \"\\n\\t    Remote Link-ID: %u (0x%08x)\",\n                       EXTRACT_32BITS(obj_tptr+4),\n                       EXTRACT_32BITS(obj_tptr+4),\n                       EXTRACT_32BITS(obj_tptr+8),\n                       EXTRACT_32BITS(obj_tptr+8)));\n\t\tbreak;\n\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case LMP_OBJ_DATA_LINK:\n\t    switch(lmp_obj_ctype) {\n\t    case LMP_CTYPE_IPV4:\n                if (obj_tlen < 12) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n\t        ND_PRINT((ndo, \"\\n\\t    Flags: [%s]\",\n\t\t    bittok2str(lmp_obj_data_link_flag_values,\n\t\t\t\"none\",\n\t\t\tEXTRACT_8BITS(obj_tptr))));\n                ND_PRINT((ndo, \"\\n\\t    Local Interface ID: %s (0x%08x)\"\n                       \"\\n\\t    Remote Interface ID: %s (0x%08x)\",\n                       ipaddr_string(ndo, obj_tptr+4),\n                       EXTRACT_32BITS(obj_tptr+4),\n                       ipaddr_string(ndo, obj_tptr+8),\n                       EXTRACT_32BITS(obj_tptr+8)));\n\n\t\tret = lmp_print_data_link_subobjs(ndo, obj_tptr, obj_tlen - 12, 12);\n\t\tif (ret == -1)\n\t\t    goto trunc;\n\t\tif (ret == TRUE)\n\t\t    hexdump=TRUE;\n\t\tbreak;\n\n\t    case LMP_CTYPE_IPV6:\n                if (obj_tlen < 36) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n\t        ND_PRINT((ndo, \"\\n\\t    Flags: [%s]\",\n\t\t    bittok2str(lmp_obj_data_link_flag_values,\n\t\t\t\"none\",\n\t\t\tEXTRACT_8BITS(obj_tptr))));\n                ND_PRINT((ndo, \"\\n\\t    Local Interface ID: %s (0x%08x)\"\n                       \"\\n\\t    Remote Interface ID: %s (0x%08x)\",\n                       ip6addr_string(ndo, obj_tptr+4),\n                       EXTRACT_32BITS(obj_tptr+4),\n                       ip6addr_string(ndo, obj_tptr+20),\n                       EXTRACT_32BITS(obj_tptr+20)));\n\n\t\tret = lmp_print_data_link_subobjs(ndo, obj_tptr, obj_tlen - 36, 36);\n\t\tif (ret == -1)\n\t\t    goto trunc;\n\t\tif (ret == TRUE)\n\t\t    hexdump=TRUE;\n\t\tbreak;\n\n\t    case LMP_CTYPE_UNMD:\n                if (obj_tlen < 12) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n\t        ND_PRINT((ndo, \"\\n\\t    Flags: [%s]\",\n\t\t    bittok2str(lmp_obj_data_link_flag_values,\n\t\t\t\"none\",\n\t\t\tEXTRACT_8BITS(obj_tptr))));\n                ND_PRINT((ndo, \"\\n\\t    Local Interface ID: %u (0x%08x)\"\n                       \"\\n\\t    Remote Interface ID: %u (0x%08x)\",\n                       EXTRACT_32BITS(obj_tptr+4),\n                       EXTRACT_32BITS(obj_tptr+4),\n                       EXTRACT_32BITS(obj_tptr+8),\n                       EXTRACT_32BITS(obj_tptr+8)));\n\n\t\tret = lmp_print_data_link_subobjs(ndo, obj_tptr, obj_tlen - 12, 12);\n\t\tif (ret == -1)\n\t\t    goto trunc;\n\t\tif (ret == TRUE)\n\t\t    hexdump=TRUE;\n\t\tbreak;\n\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case LMP_OBJ_VERIFY_BEGIN:\n\t    switch(lmp_obj_ctype) {\n            case LMP_CTYPE_1:\n                if (obj_tlen != 20) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n\t\tND_PRINT((ndo, \"\\n\\t    Flags: %s\",\n\t\tbittok2str(lmp_obj_begin_verify_flag_values,\n\t\t\t\"none\",\n\t\t\tEXTRACT_16BITS(obj_tptr))));\n\t\tND_PRINT((ndo, \"\\n\\t    Verify Interval: %u\",\n\t\t\tEXTRACT_16BITS(obj_tptr+2)));\n\t\tND_PRINT((ndo, \"\\n\\t    Data links: %u\",\n\t\t\tEXTRACT_32BITS(obj_tptr+4)));\n                ND_PRINT((ndo, \"\\n\\t    Encoding type: %s\",\n\t\t\ttok2str(gmpls_encoding_values, \"Unknown\", *(obj_tptr+8))));\n                ND_PRINT((ndo, \"\\n\\t    Verify Transport Mechanism: %u (0x%x)%s\",\n\t\t\tEXTRACT_16BITS(obj_tptr+10),\n\t\t\tEXTRACT_16BITS(obj_tptr+10),\n\t\t\tEXTRACT_16BITS(obj_tptr+10)&8000 ? \" (Payload test messages capable)\" : \"\"));\n                bw.i = EXTRACT_32BITS(obj_tptr+12);\n\t\tND_PRINT((ndo, \"\\n\\t    Transmission Rate: %.3f Mbps\",bw.f*8/1000000));\n\t\tND_PRINT((ndo, \"\\n\\t    Wavelength: %u\",\n\t\t\tEXTRACT_32BITS(obj_tptr+16)));\n\t\tbreak;\n\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case LMP_OBJ_VERIFY_BEGIN_ACK:\n\t    switch(lmp_obj_ctype) {\n            case LMP_CTYPE_1:\n                if (obj_tlen != 4) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n                ND_PRINT((ndo, \"\\n\\t    Verify Dead Interval: %u\"\n                       \"\\n\\t    Verify Transport Response: %u\",\n                       EXTRACT_16BITS(obj_tptr),\n                       EXTRACT_16BITS(obj_tptr+2)));\n                break;\n\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n\tcase LMP_OBJ_VERIFY_ID:\n\t    switch(lmp_obj_ctype) {\n            case LMP_CTYPE_1:\n                if (obj_tlen != 4) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n                ND_PRINT((ndo, \"\\n\\t    Verify ID: %u\",\n                       EXTRACT_32BITS(obj_tptr)));\n                break;\n\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n\tcase LMP_OBJ_CHANNEL_STATUS:\n            switch(lmp_obj_ctype) {\n\t    case LMP_CTYPE_IPV4:\n\t\toffset = 0;\n\t\t/* Decode pairs: <Interface_ID (4 bytes), Channel_status (4 bytes)> */\n\t\twhile (offset+8 <= obj_tlen) {\n\t\t\tND_PRINT((ndo, \"\\n\\t    Interface ID: %s (0x%08x)\",\n\t\t\tipaddr_string(ndo, obj_tptr+offset),\n\t\t\tEXTRACT_32BITS(obj_tptr+offset)));\n\n\t\t\tND_PRINT((ndo, \"\\n\\t\\t    Active: %s (%u)\",\n\t\t\t\t(EXTRACT_32BITS(obj_tptr+offset+4)>>31) ?\n\t\t\t\t\t\t\"Allocated\" : \"Non-allocated\",\n\t\t\t\t(EXTRACT_32BITS(obj_tptr+offset+4)>>31)));\n\n\t\t\tND_PRINT((ndo, \"\\n\\t\\t    Direction: %s (%u)\",\n\t\t\t\t(EXTRACT_32BITS(obj_tptr+offset+4)>>30)&0x1 ?\n\t\t\t\t\t\t\"Transmit\" : \"Receive\",\n\t\t\t\t(EXTRACT_32BITS(obj_tptr+offset+4)>>30)&0x1));\n\n\t\t\tND_PRINT((ndo, \"\\n\\t\\t    Channel Status: %s (%u)\",\n\t\t\t\t\ttok2str(lmp_obj_channel_status_values,\n\t\t\t \t\t\"Unknown\",\n\t\t\t\t\tEXTRACT_32BITS(obj_tptr+offset+4)&0x3FFFFFF),\n\t\t\tEXTRACT_32BITS(obj_tptr+offset+4)&0x3FFFFFF));\n\t\t\toffset+=8;\n\t\t}\n                break;\n\n\t    case LMP_CTYPE_IPV6:\n\t\toffset = 0;\n\t\t/* Decode pairs: <Interface_ID (16 bytes), Channel_status (4 bytes)> */\n\t\twhile (offset+20 <= obj_tlen) {\n\t\t\tND_PRINT((ndo, \"\\n\\t    Interface ID: %s (0x%08x)\",\n\t\t\tip6addr_string(ndo, obj_tptr+offset),\n\t\t\tEXTRACT_32BITS(obj_tptr+offset)));\n\n\t\t\tND_PRINT((ndo, \"\\n\\t\\t    Active: %s (%u)\",\n\t\t\t\t(EXTRACT_32BITS(obj_tptr+offset+16)>>31) ?\n\t\t\t\t\t\t\"Allocated\" : \"Non-allocated\",\n\t\t\t\t(EXTRACT_32BITS(obj_tptr+offset+16)>>31)));\n\n\t\t\tND_PRINT((ndo, \"\\n\\t\\t    Direction: %s (%u)\",\n\t\t\t\t(EXTRACT_32BITS(obj_tptr+offset+16)>>30)&0x1 ?\n\t\t\t\t\t\t\"Transmit\" : \"Receive\",\n\t\t\t\t(EXTRACT_32BITS(obj_tptr+offset+16)>>30)&0x1));\n\n\t\t\tND_PRINT((ndo, \"\\n\\t\\t    Channel Status: %s (%u)\",\n\t\t\t\t\ttok2str(lmp_obj_channel_status_values,\n\t\t\t\t\t\"Unknown\",\n\t\t\t\t\tEXTRACT_32BITS(obj_tptr+offset+16)&0x3FFFFFF),\n\t\t\tEXTRACT_32BITS(obj_tptr+offset+16)&0x3FFFFFF));\n\t\t\toffset+=20;\n\t\t}\n                break;\n\n\t    case LMP_CTYPE_UNMD:\n\t\toffset = 0;\n\t\t/* Decode pairs: <Interface_ID (4 bytes), Channel_status (4 bytes)> */\n\t\twhile (offset+8 <= obj_tlen) {\n\t\t\tND_PRINT((ndo, \"\\n\\t    Interface ID: %u (0x%08x)\",\n\t\t\tEXTRACT_32BITS(obj_tptr+offset),\n\t\t\tEXTRACT_32BITS(obj_tptr+offset)));\n\n\t\t\tND_PRINT((ndo, \"\\n\\t\\t    Active: %s (%u)\",\n\t\t\t\t(EXTRACT_32BITS(obj_tptr+offset+4)>>31) ?\n\t\t\t\t\t\t\"Allocated\" : \"Non-allocated\",\n\t\t\t\t(EXTRACT_32BITS(obj_tptr+offset+4)>>31)));\n\n\t\t\tND_PRINT((ndo, \"\\n\\t\\t    Direction: %s (%u)\",\n\t\t\t\t(EXTRACT_32BITS(obj_tptr+offset+4)>>30)&0x1 ?\n\t\t\t\t\t\t\"Transmit\" : \"Receive\",\n\t\t\t\t(EXTRACT_32BITS(obj_tptr+offset+4)>>30)&0x1));\n\n\t\t\tND_PRINT((ndo, \"\\n\\t\\t    Channel Status: %s (%u)\",\n\t\t\t\t\ttok2str(lmp_obj_channel_status_values,\n\t\t\t\t\t\"Unknown\",\n\t\t\t\t\tEXTRACT_32BITS(obj_tptr+offset+4)&0x3FFFFFF),\n\t\t\tEXTRACT_32BITS(obj_tptr+offset+4)&0x3FFFFFF));\n\t\t\toffset+=8;\n\t\t}\n                break;\n\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n\tcase LMP_OBJ_CHANNEL_STATUS_REQ:\n            switch(lmp_obj_ctype) {\n\t    case LMP_CTYPE_IPV4:\n\t\toffset = 0;\n\t\twhile (offset+4 <= obj_tlen) {\n\t\t\tND_PRINT((ndo, \"\\n\\t    Interface ID: %s (0x%08x)\",\n\t\t\tipaddr_string(ndo, obj_tptr+offset),\n\t\t\tEXTRACT_32BITS(obj_tptr+offset)));\n\t\t\toffset+=4;\n\t\t}\n                break;\n\n\t    case LMP_CTYPE_IPV6:\n\t\toffset = 0;\n\t\twhile (offset+16 <= obj_tlen) {\n\t\t\tND_PRINT((ndo, \"\\n\\t    Interface ID: %s (0x%08x)\",\n\t\t\tip6addr_string(ndo, obj_tptr+offset),\n\t\t\tEXTRACT_32BITS(obj_tptr+offset)));\n\t\t\toffset+=16;\n\t\t}\n                break;\n\n\t    case LMP_CTYPE_UNMD:\n\t\toffset = 0;\n\t\twhile (offset+4 <= obj_tlen) {\n\t\t\tND_PRINT((ndo, \"\\n\\t    Interface ID: %u (0x%08x)\",\n\t\t\tEXTRACT_32BITS(obj_tptr+offset),\n\t\t\tEXTRACT_32BITS(obj_tptr+offset)));\n\t\t\toffset+=4;\n\t\t}\n                break;\n\n\t    default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case LMP_OBJ_ERROR_CODE:\n\t    switch(lmp_obj_ctype) {\n            case LMP_CTYPE_BEGIN_VERIFY_ERROR:\n                if (obj_tlen != 4) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n\t\tND_PRINT((ndo, \"\\n\\t    Error Code: %s\",\n\t\tbittok2str(lmp_obj_begin_verify_error_values,\n\t\t\t\"none\",\n\t\t\tEXTRACT_32BITS(obj_tptr))));\n                break;\n\n            case LMP_CTYPE_LINK_SUMMARY_ERROR:\n                if (obj_tlen != 4) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n\t\tND_PRINT((ndo, \"\\n\\t    Error Code: %s\",\n\t\tbittok2str(lmp_obj_link_summary_error_values,\n\t\t\t\"none\",\n\t\t\tEXTRACT_32BITS(obj_tptr))));\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n\tcase LMP_OBJ_SERVICE_CONFIG:\n\t    switch (lmp_obj_ctype) {\n\t    case LMP_CTYPE_SERVICE_CONFIG_SP:\n                if (obj_tlen != 4) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n\t\tND_PRINT((ndo, \"\\n\\t Flags: %s\",\n\t\t       bittok2str(lmp_obj_service_config_sp_flag_values,\n\t\t\t\t  \"none\",\n\t\t\t\t  EXTRACT_8BITS(obj_tptr))));\n\n\t\tND_PRINT((ndo, \"\\n\\t  UNI Version: %u\",\n\t\t       EXTRACT_8BITS(obj_tptr + 1)));\n\n\t\tbreak;\n\n            case LMP_CTYPE_SERVICE_CONFIG_CPSA:\n                if (obj_tlen != 16) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n\n\t\tlink_type = EXTRACT_8BITS(obj_tptr);\n\n\t\tND_PRINT((ndo, \"\\n\\t Link Type: %s (%u)\",\n\t\t       tok2str(lmp_sd_service_config_cpsa_link_type_values,\n\t\t\t       \"Unknown\", link_type),\n\t\t       link_type));\n\n\t\tswitch (link_type) {\n\t\tcase LMP_SD_SERVICE_CONFIG_CPSA_LINK_TYPE_SDH:\n\t\t    ND_PRINT((ndo, \"\\n\\t Signal Type: %s (%u)\",\n\t\t\t   tok2str(lmp_sd_service_config_cpsa_signal_type_sdh_values,\n\t\t\t\t   \"Unknown\",\n\t\t\t\t   EXTRACT_8BITS(obj_tptr + 1)),\n\t\t\t\t   EXTRACT_8BITS(obj_tptr + 1)));\n\t\t    break;\n\n\t\tcase LMP_SD_SERVICE_CONFIG_CPSA_LINK_TYPE_SONET:\n\t\t    ND_PRINT((ndo, \"\\n\\t Signal Type: %s (%u)\",\n\t\t\t   tok2str(lmp_sd_service_config_cpsa_signal_type_sonet_values,\n\t\t\t\t   \"Unknown\",\n\t\t\t\t   EXTRACT_8BITS(obj_tptr + 1)),\n\t\t\t\t   EXTRACT_8BITS(obj_tptr + 1)));\n\t\t    break;\n\t\t}\n\n\t\tND_PRINT((ndo, \"\\n\\t Transparency: %s\",\n\t\t       bittok2str(lmp_obj_service_config_cpsa_tp_flag_values,\n\t\t\t\t  \"none\",\n\t\t\t\t  EXTRACT_8BITS(obj_tptr + 2))));\n\n\t\tND_PRINT((ndo, \"\\n\\t Contiguous Concatenation Types: %s\",\n\t\t       bittok2str(lmp_obj_service_config_cpsa_cct_flag_values,\n\t\t\t\t  \"none\",\n\t\t\t\t  EXTRACT_8BITS(obj_tptr + 3))));\n\n\t\tND_PRINT((ndo, \"\\n\\t Minimum NCC: %u\",\n\t\t       EXTRACT_16BITS(obj_tptr+4)));\n\n\t\tND_PRINT((ndo, \"\\n\\t Maximum NCC: %u\",\n\t\t       EXTRACT_16BITS(obj_tptr+6)));\n\n\t\tND_PRINT((ndo, \"\\n\\t Minimum NVC:%u\",\n\t\t       EXTRACT_16BITS(obj_tptr+8)));\n\n\t\tND_PRINT((ndo, \"\\n\\t Maximum NVC:%u\",\n\t\t       EXTRACT_16BITS(obj_tptr+10)));\n\n\t\tND_PRINT((ndo, \"\\n\\t    Local Interface ID: %s (0x%08x)\",\n\t\t       ipaddr_string(ndo, obj_tptr+12),\n\t\t       EXTRACT_32BITS(obj_tptr+12)));\n\n\t\tbreak;\n\n\t    case LMP_CTYPE_SERVICE_CONFIG_TRANSPARENCY_TCM:\n                if (obj_tlen != 8) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n\n\t\tND_PRINT((ndo, \"\\n\\t Transparency Flags: %s\",\n\t\t       bittok2str(\n\t\t\t   lmp_obj_service_config_nsa_transparency_flag_values,\n\t\t\t   \"none\",\n\t\t\t   EXTRACT_32BITS(obj_tptr))));\n\n\t\tND_PRINT((ndo, \"\\n\\t TCM Monitoring Flags: %s\",\n\t\t       bittok2str(\n\t\t\t   lmp_obj_service_config_nsa_tcm_flag_values,\n\t\t\t   \"none\",\n\t\t\t   EXTRACT_8BITS(obj_tptr + 7))));\n\n\t\tbreak;\n\n\t    case LMP_CTYPE_SERVICE_CONFIG_NETWORK_DIVERSITY:\n                if (obj_tlen != 4) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n\n\t\tND_PRINT((ndo, \"\\n\\t Diversity: Flags: %s\",\n\t\t       bittok2str(\n\t\t\t   lmp_obj_service_config_nsa_network_diversity_flag_values,\n\t\t\t   \"none\",\n\t\t\t   EXTRACT_8BITS(obj_tptr + 3))));\n\t\tbreak;\n\n\t    default:\n\t\thexdump = TRUE;\n\t    }\n\n\tbreak;\n\n        default:\n            if (ndo->ndo_vflag <= 1)\n                print_unknown_data(ndo,obj_tptr,\"\\n\\t    \",obj_tlen);\n            break;\n        }\n        /* do we want to see an additionally hexdump ? */\n        if (ndo->ndo_vflag > 1 || hexdump==TRUE)\n            print_unknown_data(ndo,tptr+sizeof(struct lmp_object_header),\"\\n\\t    \",\n                               lmp_obj_len-sizeof(struct lmp_object_header));\n\n        tptr+=lmp_obj_len;\n        tlen-=lmp_obj_len;\n     }\n     return;\n trunc:\n    ND_PRINT((ndo, \"\\n\\t\\t packet exceeded snapshot\"));\n }\n", "target": 1, "idx": 182709}
{"func": "void Editor::ChangeSelectionAfterCommand(\n    const SelectionInDOMTree& new_selection,\n    const SetSelectionData& options) {\n  if (new_selection.IsNone())\n    return;\n\n   bool selection_did_not_change_dom_position =\n       new_selection == GetFrame().Selection().GetSelectionInDOMTree();\n   GetFrame().Selection().SetSelection(\n      SelectionInDOMTree::Builder(new_selection)\n          .SetIsHandleVisible(GetFrame().Selection().IsHandleVisible())\n          .Build(),\n      options);\n \n  if (selection_did_not_change_dom_position) {\n    Client().RespondToChangedSelection(\n        frame_, GetFrame().Selection().GetSelectionInDOMTree().Type());\n  }\n}\n", "target": 1, "idx": 185630}
{"func": "static int addrconf_ifid_gre(u8 *eui, struct net_device *dev)\n{\n\treturn __ipv6_isatap_ifid(eui, *(__be32 *)dev->dev_addr);\n}\n", "target": 0, "idx": 41776}
{"func": "static int arcmsr_hbaA_handle_isr(struct AdapterControlBlock *acb)\n{\n\tuint32_t outbound_intstatus;\n\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\toutbound_intstatus = readl(&reg->outbound_intstatus) &\n\t\tacb->outbound_int_enable;\n\tif (!(outbound_intstatus & ARCMSR_MU_OUTBOUND_HANDLE_INT))\n\t\treturn IRQ_NONE;\n\tdo {\n\t\twritel(outbound_intstatus, &reg->outbound_intstatus);\n\t\tif (outbound_intstatus & ARCMSR_MU_OUTBOUND_DOORBELL_INT)\n\t\t\tarcmsr_hbaA_doorbell_isr(acb);\n\t\tif (outbound_intstatus & ARCMSR_MU_OUTBOUND_POSTQUEUE_INT)\n\t\t\tarcmsr_hbaA_postqueue_isr(acb);\n\t\tif (outbound_intstatus & ARCMSR_MU_OUTBOUND_MESSAGE0_INT)\n\t\t\tarcmsr_hbaA_message_isr(acb);\n\t\toutbound_intstatus = readl(&reg->outbound_intstatus) &\n\t\t\tacb->outbound_int_enable;\n\t} while (outbound_intstatus & (ARCMSR_MU_OUTBOUND_DOORBELL_INT\n\t\t| ARCMSR_MU_OUTBOUND_POSTQUEUE_INT\n\t\t| ARCMSR_MU_OUTBOUND_MESSAGE0_INT));\n\treturn IRQ_HANDLED;\n}\n", "target": 0, "idx": 49763}
{"func": "static void callWithScriptStateExecutionContextVoidMethodMethod(const v8::FunctionCallbackInfo<v8::Value>& info)\n{\n    TestObjectPython* imp = V8TestObjectPython::toNative(info.Holder());\n    ScriptState* currentState = ScriptState::current();\n    if (!currentState)\n        return;\n    ScriptState& state = *currentState;\n    ExecutionContext* scriptContext = currentExecutionContext(info.GetIsolate());\n    imp->callWithScriptStateExecutionContextVoidMethod(&state, scriptContext);\n    if (state.hadException()) {\n        v8::Local<v8::Value> exception = state.exception();\n        state.clearException();\n        throwError(exception, info.GetIsolate());\n        return;\n    }\n}\n", "target": 0, "idx": 131259}
{"func": "  StatisticsCB NewStatisticsCB() {\n    return base::Bind(&MockStatisticsCB::OnStatistics,\n                      base::Unretained(&statistics_cb_));\n   }\n", "target": 0, "idx": 113331}
{"func": " static void ReconfigureImpl(Handle<JSObject> object,\n Handle<FixedArrayBase> store, uint32_t entry,\n Handle<Object> value,\n PropertyAttributes attributes) {\n    UNREACHABLE();\n }\n", "target": 0, "idx": 176337}
{"func": "void RenderThread::EnsureWebKitInitialized() {\n  if (webkit_client_.get())\n    return;\n\n  v8::V8::SetCounterFunction(base::StatsTable::FindLocation);\n  v8::V8::SetCreateHistogramFunction(CreateHistogram);\n  v8::V8::SetAddHistogramSampleFunction(AddHistogramSample);\n\n  webkit_client_.reset(new RendererWebKitClientImpl);\n  WebKit::initialize(webkit_client_.get());\n\n  WebScriptController::enableV8SingleThreadMode();\n\n  const CommandLine& command_line = *CommandLine::ForCurrentProcess();\n\n  webkit_glue::EnableWebCoreLogChannels(\n      command_line.GetSwitchValueASCII(switches::kWebCoreLogChannels));\n\n  if (command_line.HasSwitch(switches::kEnableBenchmarking))\n    RegisterExtension(extensions_v8::BenchmarkingExtension::Get());\n\n  if (command_line.HasSwitch(switches::kPlaybackMode) ||\n      command_line.HasSwitch(switches::kRecordMode) ||\n      command_line.HasSwitch(switches::kNoJsRandomness)) {\n    RegisterExtension(extensions_v8::PlaybackExtension::Get());\n  }\n\n  web_database_observer_impl_.reset(new WebDatabaseObserverImpl(this));\n  WebKit::WebDatabase::setObserver(web_database_observer_impl_.get());\n\n  WebRuntimeFeatures::enableSockets(\n      !command_line.HasSwitch(switches::kDisableWebSockets));\n\n  WebRuntimeFeatures::enableDatabase(\n      !command_line.HasSwitch(switches::kDisableDatabases));\n\n  WebRuntimeFeatures::enableDataTransferItems(\n      !command_line.HasSwitch(switches::kDisableDataTransferItems));\n\n  WebRuntimeFeatures::enableApplicationCache(\n      !command_line.HasSwitch(switches::kDisableApplicationCache));\n\n  WebRuntimeFeatures::enableNotifications(\n      !command_line.HasSwitch(switches::kDisableDesktopNotifications));\n\n  WebRuntimeFeatures::enableLocalStorage(\n      !command_line.HasSwitch(switches::kDisableLocalStorage));\n  WebRuntimeFeatures::enableSessionStorage(\n      !command_line.HasSwitch(switches::kDisableSessionStorage));\n\n  WebRuntimeFeatures::enableIndexedDatabase(\n      !command_line.HasSwitch(switches::kDisableIndexedDatabase));\n\n  WebRuntimeFeatures::enableGeolocation(\n      !command_line.HasSwitch(switches::kDisableGeolocation));\n\n  WebKit::WebRuntimeFeatures::enableMediaStream(\n      command_line.HasSwitch(switches::kEnableMediaStream));\n\n#if defined(OS_CHROMEOS)\n  WebRuntimeFeatures::enableWebAudio(false);\n#else\n  WebRuntimeFeatures::enableWebAudio(\n      !command_line.HasSwitch(switches::kDisableWebAudio));\n#endif\n\n  WebRuntimeFeatures::enablePushState(true);\n\n#ifdef TOUCH_UI\n  WebRuntimeFeatures::enableTouch(true);\n#else\n  WebRuntimeFeatures::enableTouch(false);\n#endif\n\n  WebRuntimeFeatures::enableDeviceMotion(\n      command_line.HasSwitch(switches::kEnableDeviceMotion));\n\n  WebRuntimeFeatures::enableDeviceOrientation(\n      !command_line.HasSwitch(switches::kDisableDeviceOrientation));\n\n  WebRuntimeFeatures::enableSpeechInput(\n      !command_line.HasSwitch(switches::kDisableSpeechInput));\n\n  WebRuntimeFeatures::enableFileSystem(\n      !command_line.HasSwitch(switches::kDisableFileSystem));\n\n  WebRuntimeFeatures::enableJavaScriptI18NAPI(\n      !command_line.HasSwitch(switches::kDisableJavaScriptI18NAPI));\n\n  WebRuntimeFeatures::enableQuota(true);\n\n  FOR_EACH_OBSERVER(RenderProcessObserver, observers_, WebKitInitialized());\n}\n", "target": 0, "idx": 103749}
{"func": "void NormalPageArena::AllocatePage() {\n  GetThreadState()->Heap().address_cache()->MarkDirty();\n  PageMemory* page_memory =\n      GetThreadState()->Heap().GetFreePagePool()->Take(ArenaIndex());\n\n  if (!page_memory) {\n    PageMemoryRegion* region = PageMemoryRegion::AllocateNormalPages(\n        GetThreadState()->Heap().GetRegionTree());\n\n    for (size_t i = 0; i < kBlinkPagesPerRegion; ++i) {\n      PageMemory* memory = PageMemory::SetupPageMemoryInRegion(\n          region, i * kBlinkPageSize, BlinkPagePayloadSize());\n      if (!page_memory) {\n        bool result = memory->Commit();\n        CHECK(result);\n        page_memory = memory;\n      } else {\n        GetThreadState()->Heap().GetFreePagePool()->Add(ArenaIndex(), memory);\n      }\n    }\n  }\n  NormalPage* page =\n      new (page_memory->WritableStart()) NormalPage(page_memory, this);\n  page->Link(&first_page_);\n\n  GetThreadState()->Heap().HeapStats().IncreaseAllocatedSpace(page->size());\n#if DCHECK_IS_ON() || defined(LEAK_SANITIZER) || defined(ADDRESS_SANITIZER)\n  ASAN_UNPOISON_MEMORY_REGION(page->Payload(), page->PayloadSize());\n  Address address = page->Payload();\n  for (size_t i = 0; i < page->PayloadSize(); i++)\n    address[i] = kReuseAllowedZapValue;\n  ASAN_POISON_MEMORY_REGION(page->Payload(), page->PayloadSize());\n#endif\n  AddToFreeList(page->Payload(), page->PayloadSize());\n}\n", "target": 0, "idx": 166721}
{"func": "static v8::Handle<v8::Value> enabledAtRuntimeMethod2Callback(const v8::Arguments& args)\n {\n     INC_STATS(\"DOM.TestObj.enabledAtRuntimeMethod2\");\n     if (args.Length() < 1)\n        return V8Proxy::throwNotEnoughArgumentsError();\n     TestObj* imp = V8TestObj::toNative(args.Holder());\n     EXCEPTION_BLOCK(int, intArg, V8int::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8int::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);\n     imp->enabledAtRuntimeMethod2(intArg);\n    return v8::Handle<v8::Value>();\n}\n", "target": 1, "idx": 184775}
{"func": "conv_swap4bytes(const UChar* s, const UChar* end, UChar* conv)\n{\n  while (s < end) {\n    *conv++ = s[3];\n    *conv++ = s[2];\n    *conv++ = s[1];\n    *conv++ = s[0];\n    s += 4;\n  }\n}\n", "target": 0, "idx": 89251}
{"func": "static struct svc_serv *nfs_callback_create_svc(int minorversion)\n{\n\tstruct nfs_callback_data *cb_info = &nfs_callback_info[minorversion];\n\tstruct svc_serv *serv;\n\tstruct svc_serv_ops *sv_ops;\n\n\t/*\n\t * Check whether we're already up and running.\n\t */\n\tif (cb_info->serv) {\n\t\t/*\n\t\t * Note: increase service usage, because later in case of error\n\t\t * svc_destroy() will be called.\n\t\t */\n\t\tsvc_get(cb_info->serv);\n\t\treturn cb_info->serv;\n\t}\n\n\tswitch (minorversion) {\n\tcase 0:\n\t\tsv_ops = nfs4_cb_sv_ops[0];\n\t\tbreak;\n\tdefault:\n\t\tsv_ops = nfs4_cb_sv_ops[1];\n\t}\n\n\tif (sv_ops == NULL)\n\t\treturn ERR_PTR(-ENOTSUPP);\n\n\t/*\n\t * Sanity check: if there's no task,\n\t * we should be the first user ...\n\t */\n\tif (cb_info->users)\n \t\tprintk(KERN_WARNING \"nfs_callback_create_svc: no kthread, %d users??\\n\",\n \t\t\tcb_info->users);\n \n\tserv = svc_create(&nfs4_callback_program, NFS4_CALLBACK_BUFSIZE, sv_ops);\n \tif (!serv) {\n \t\tprintk(KERN_ERR \"nfs_callback_create_svc: create service failed\\n\");\n \t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tcb_info->serv = serv;\n\t/* As there is only one thread we need to over-ride the\n\t * default maximum of 80 connections\n\t */\n\tserv->sv_maxconn = 1024;\n\tdprintk(\"nfs_callback_create_svc: service created\\n\");\n\treturn serv;\n}\n", "target": 1, "idx": 181311}
{"func": "static void die_if_data_is_missing(GHashTable *problem_info)\n{\n    gboolean missing_data = FALSE;\n    gchar **pstring;\n    static const gchar *const needed[] = {\n        FILENAME_TYPE,\n        FILENAME_REASON,\n        /* FILENAME_BACKTRACE, - ECC errors have no such elements */\n        /* FILENAME_EXECUTABLE, */\n        NULL\n    };\n\n    for (pstring = (gchar**) needed; *pstring; pstring++)\n    {\n        if (!g_hash_table_lookup(problem_info, *pstring))\n        {\n            error_msg(\"Element '%s' is missing\", *pstring);\n            missing_data = TRUE;\n        }\n    }\n\n    if (missing_data)\n        error_msg_and_die(\"Some data is missing, aborting\");\n}\n", "target": 0, "idx": 96381}
{"func": "atm_if_print(netdissect_options *ndo,\n             const struct pcap_pkthdr *h, const u_char *p)\n{\n\tu_int caplen = h->caplen;\n\tu_int length = h->len;\n\tuint32_t llchdr;\n\tu_int hdrlen = 0;\n\n\tif (caplen < 1 || length < 1) {\n\t\tND_PRINT((ndo, \"%s\", tstr));\n\t\treturn (caplen);\n\t}\n\n        /* Cisco Style NLPID ? */\n         if (*p == LLC_UI) {\n             if (ndo->ndo_eflag)\n                 ND_PRINT((ndo, \"CNLPID \"));\n            isoclns_print(ndo, p + 1, length - 1, caplen - 1);\n             return hdrlen;\n         }\n \n\t/*\n\t * Must have at least a DSAP, an SSAP, and the first byte of the\n\t * control field.\n\t */\n\tif (caplen < 3 || length < 3) {\n\t\tND_PRINT((ndo, \"%s\", tstr));\n\t\treturn (caplen);\n\t}\n\n\t/*\n\t * Extract the presumed LLC header into a variable, for quick\n\t * testing.\n\t * Then check for a header that's neither a header for a SNAP\n\t * packet nor an RFC 2684 routed NLPID-formatted PDU nor\n\t * an 802.2-but-no-SNAP IP packet.\n\t */\n\tllchdr = EXTRACT_24BITS(p);\n\tif (llchdr != LLC_UI_HDR(LLCSAP_SNAP) &&\n\t    llchdr != LLC_UI_HDR(LLCSAP_ISONS) &&\n\t    llchdr != LLC_UI_HDR(LLCSAP_IP)) {\n\t\t/*\n\t\t * XXX - assume 802.6 MAC header from Fore driver.\n\t\t *\n\t\t * Unfortunately, the above list doesn't check for\n\t\t * all known SAPs, doesn't check for headers where\n\t\t * the source and destination SAP aren't the same,\n\t\t * and doesn't check for non-UI frames.  It also\n\t\t * runs the risk of an 802.6 MAC header that happens\n\t\t * to begin with one of those values being\n\t\t * incorrectly treated as an 802.2 header.\n\t\t *\n\t\t * So is that Fore driver still around?  And, if so,\n\t\t * is it still putting 802.6 MAC headers on ATM\n\t\t * packets?  If so, could it be changed to use a\n\t\t * new DLT_IEEE802_6 value if we added it?\n\t\t */\n\t\tif (caplen < 20 || length < 20) {\n\t\t\tND_PRINT((ndo, \"%s\", tstr));\n\t\t\treturn (caplen);\n\t\t}\n\t\tif (ndo->ndo_eflag)\n\t\t\tND_PRINT((ndo, \"%08x%08x %08x%08x \",\n\t\t\t       EXTRACT_32BITS(p),\n\t\t\t       EXTRACT_32BITS(p+4),\n\t\t\t       EXTRACT_32BITS(p+8),\n\t\t\t       EXTRACT_32BITS(p+12)));\n\t\tp += 20;\n\t\tlength -= 20;\n\t\tcaplen -= 20;\n\t\thdrlen += 20;\n\t}\n\thdrlen += atm_llc_print(ndo, p, length, caplen);\n\treturn (hdrlen);\n}\n", "target": 1, "idx": 181114}
{"func": "unsigned long ring_buffer_size(struct ring_buffer *buffer, int cpu)\n{\n\t/*\n\t * Earlier, this method returned\n\t *\tBUF_PAGE_SIZE * buffer->nr_pages\n\t * Since the nr_pages field is now removed, we have converted this to\n\t * return the per cpu buffer value.\n\t */\n\tif (!cpumask_test_cpu(cpu, buffer->cpumask))\n\t\treturn 0;\n\n\treturn BUF_PAGE_SIZE * buffer->buffers[cpu]->nr_pages;\n}\n", "target": 0, "idx": 72633}
{"func": "void WebContentsImpl::DidFailProvisionalLoadWithError(\n    RenderViewHost* render_view_host,\n    const ViewHostMsg_DidFailProvisionalLoadWithError_Params& params) {\n  VLOG(1) << \"Failed Provisional Load: \" << params.url.possibly_invalid_spec()\n          << \", error_code: \" << params.error_code\n          << \", error_description: \" << params.error_description\n          << \", is_main_frame: \" << params.is_main_frame\n          << \", showing_repost_interstitial: \" <<\n            params.showing_repost_interstitial\n          << \", frame_id: \" << params.frame_id;\n  GURL validated_url(params.url);\n  RenderProcessHost* render_process_host =\n      render_view_host->GetProcess();\n  RenderViewHost::FilterURL(render_process_host, false, &validated_url);\n\n  if (net::ERR_ABORTED == params.error_code) {\n    if (ShowingInterstitialPage()) {\n      LOG(WARNING) << \"Discarding message during interstitial.\";\n       return;\n     }\n \n     render_manager_.RendererAbortedProvisionalLoad(render_view_host);\n   }\n \n   FOR_EACH_OBSERVER(WebContentsObserver,\n                     observers_,\n                     DidFailProvisionalLoad(params.frame_id,\n                                           params.is_main_frame,\n                                           validated_url,\n                                           params.error_code,\n                                           params.error_description,\n                                           render_view_host));\n}\n", "target": 1, "idx": 184881}
{"func": "condor_auth_config(int is_daemon)\n{\n#if !defined(SKIP_AUTHENTICATION) && defined(HAVE_EXT_GLOBUS)\n\n\tif ( is_daemon ) {\n\t\tUnsetEnv( \"X509_USER_PROXY\" );\n\t}\n\n\n\tchar *pbuf = 0;\n\tchar *proxy_buf = 0;\n\tchar *cert_buf = 0;\n\tchar *key_buf = 0;\n\tchar *trustedca_buf = 0;\n\tchar *mapfile_buf = 0;\n\n\tMyString buffer;\n\n\n\n\tpbuf = param( STR_GSI_DAEMON_DIRECTORY );\n\ttrustedca_buf = param( STR_GSI_DAEMON_TRUSTED_CA_DIR );\n\tmapfile_buf = param( STR_GSI_MAPFILE );\n\tif( is_daemon ) {\n\t\tproxy_buf = param( STR_GSI_DAEMON_PROXY );\n\t\tcert_buf = param( STR_GSI_DAEMON_CERT );\n\t\tkey_buf = param( STR_GSI_DAEMON_KEY );\n\t}\n\n\tif (pbuf) {\n\n\t\tif( !trustedca_buf) {\n\t\t\tbuffer.sprintf( \"%s%ccertificates\", pbuf, DIR_DELIM_CHAR);\n\t\t\tSetEnv( STR_GSI_CERT_DIR, buffer.Value() );\n\t\t}\n\n\t\tif (!mapfile_buf ) {\n\t\t\tbuffer.sprintf( \"%s%cgrid-mapfile\", pbuf, DIR_DELIM_CHAR);\n\t\t\tSetEnv( STR_GSI_MAPFILE, buffer.Value() );\n\t\t}\n\n\t\tif( is_daemon ) {\n\t\t\tif( !cert_buf ) {\n\t\t\t\tbuffer.sprintf( \"%s%chostcert.pem\", pbuf, DIR_DELIM_CHAR);\n\t\t\t\tSetEnv( STR_GSI_USER_CERT, buffer.Value() );\n\t\t\t}\n\t\n\t\t\tif (!key_buf ) {\n\t\t\t\tbuffer.sprintf( \"%s%chostkey.pem\", pbuf, DIR_DELIM_CHAR);\n\t\t\t\tSetEnv( STR_GSI_USER_KEY, buffer.Value() );\n\t\t\t}\n\t\t}\n\n\t\tfree( pbuf );\n\t}\n\n\tif(trustedca_buf) {\n\t\tSetEnv( STR_GSI_CERT_DIR, trustedca_buf );\n\t\tfree(trustedca_buf);\n\t}\n\n\tif (mapfile_buf) {\n\t\tSetEnv( STR_GSI_MAPFILE, mapfile_buf );\n\t\tfree(mapfile_buf);\n\t}\n\n\tif( is_daemon ) {\n\t\tif(proxy_buf) {\n\t\t\tSetEnv( STR_GSI_USER_PROXY, proxy_buf );\n\t\t\tfree(proxy_buf);\n\t\t}\n\n\t\tif(cert_buf) {\n\t\t\tSetEnv( STR_GSI_USER_CERT, cert_buf );\n\t\t\tfree(cert_buf);\n\t\t}\n\n\t\tif(key_buf) {\n\t\t\tSetEnv( STR_GSI_USER_KEY, key_buf );\n\t\t\tfree(key_buf);\n\t\t}\n\t}\n\n#else\n\t(void) is_daemon;\t// Quiet 'unused parameter' warnings\n#endif\n}\n", "target": 0, "idx": 16488}
{"func": "void *load_device_tree(const char *filename_path, int *sizep)\n{\n    int dt_size;\n    int dt_file_load_size;\n    int ret;\n    void *fdt = NULL;\n\n    *sizep = 0;\n    dt_size = get_image_size(filename_path);\n    if (dt_size < 0) {\n        error_report(\"Unable to get size of device tree file '%s'\",\n                     filename_path);\n        goto fail;\n    }\n\n    /* Expand to 2x size to give enough room for manipulation.  */\n    dt_size += 10000;\n    dt_size *= 2;\n     /* First allocate space in qemu for device tree */\n     fdt = g_malloc0(dt_size);\n \n    dt_file_load_size = load_image(filename_path, fdt);\n     if (dt_file_load_size < 0) {\n         error_report(\"Unable to open device tree file '%s'\",\n                      filename_path);\n        goto fail;\n    }\n\n    ret = fdt_open_into(fdt, fdt, dt_size);\n    if (ret) {\n        error_report(\"Unable to copy device tree in memory\");\n        goto fail;\n    }\n\n    /* Check sanity of device tree */\n    if (fdt_check_header(fdt)) {\n        error_report(\"Device tree file loaded into memory is invalid: %s\",\n                     filename_path);\n        goto fail;\n    }\n    *sizep = dt_size;\n    return fdt;\n\nfail:\n    g_free(fdt);\n    return NULL;\n}\n", "target": 1, "idx": 178394}
{"func": "static int packet_recv_error(struct sock *sk, struct msghdr *msg, int len)\n{\n\tstruct sock_exterr_skb *serr;\n\tstruct sk_buff *skb, *skb2;\n\tint copied, err;\n\n\terr = -EAGAIN;\n\tskb = skb_dequeue(&sk->sk_error_queue);\n\tif (skb == NULL)\n\t\tgoto out;\n\n\tcopied = skb->len;\n\tif (copied > len) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err)\n\t\tgoto out_free_skb;\n\n\tsock_recv_timestamp(msg, sk, skb);\n\n\tserr = SKB_EXT_ERR(skb);\n\tput_cmsg(msg, SOL_PACKET, PACKET_TX_TIMESTAMP,\n\t\t sizeof(serr->ee), &serr->ee);\n\n\tmsg->msg_flags |= MSG_ERRQUEUE;\n\terr = copied;\n\n\t/* Reset and regenerate socket error */\n\tspin_lock_bh(&sk->sk_error_queue.lock);\n\tsk->sk_err = 0;\n\tif ((skb2 = skb_peek(&sk->sk_error_queue)) != NULL) {\n\t\tsk->sk_err = SKB_EXT_ERR(skb2)->ee.ee_errno;\n\t\tspin_unlock_bh(&sk->sk_error_queue.lock);\n\t\tsk->sk_error_report(sk);\n\t} else\n\t\tspin_unlock_bh(&sk->sk_error_queue.lock);\n\nout_free_skb:\n\tkfree_skb(skb);\nout:\n\treturn err;\n}\n", "target": 0, "idx": 26568}
{"func": "void Editor::replaceSelectionWithText(const String& text,\n                                      bool selectReplacement,\n                                      bool smartReplace,\n                                      InputEvent::InputType inputType) {\n  replaceSelectionWithFragment(createFragmentFromText(selectedRange(), text),\n                               selectReplacement, smartReplace, true,\n                               inputType);\n}\n", "target": 0, "idx": 140359}
{"func": "static CallInfo *growCI (lua_State *L) {\n  if (L->size_ci > LUAI_MAXCALLS)  /* overflow while handling overflow? */\n    luaD_throw(L, LUA_ERRERR);\n  else {\n    luaD_reallocCI(L, 2*L->size_ci);\n    if (L->size_ci > LUAI_MAXCALLS)\n      luaG_runerror(L, \"stack overflow\");\n  }\n  return ++L->ci;\n}\n", "target": 0, "idx": 43043}
{"func": "static inline void pcnet_tmd_load(PCNetState *s, struct pcnet_TMD *tmd,\n                                  hwaddr addr)\n{\n    if (!BCR_SSIZE32(s)) {\n        struct {\n            uint32_t tbadr;\n            int16_t length;\n            int16_t status;\n\t} xda;\n        s->phys_mem_read(s->dma_opaque, addr, (void *)&xda, sizeof(xda), 0);\n        tmd->tbadr = le32_to_cpu(xda.tbadr) & 0xffffff;\n        tmd->length = le16_to_cpu(xda.length);\n        tmd->status = (le32_to_cpu(xda.tbadr) >> 16) & 0xff00;\n        tmd->misc = le16_to_cpu(xda.status) << 16;\n        tmd->res = 0;\n    } else {\n        s->phys_mem_read(s->dma_opaque, addr, (void *)tmd, sizeof(*tmd), 0);\n        le32_to_cpus(&tmd->tbadr);\n        le16_to_cpus((uint16_t *)&tmd->length);\n        le16_to_cpus((uint16_t *)&tmd->status);\n        le32_to_cpus(&tmd->misc);\n        le32_to_cpus(&tmd->res);\n        if (BCR_SWSTYLE(s) == 3) {\n            uint32_t tmp = tmd->tbadr;\n            tmd->tbadr = tmd->misc;\n            tmd->misc = tmp;\n        }\n    }\n}\n", "target": 0, "idx": 14533}
{"func": "void* ipc_alloc(int size)\n {\n\tvoid* out;\n \tif(size > PAGE_SIZE)\n \t\tout = vmalloc(size);\n \telse\n\t\tout = kmalloc(size, GFP_KERNEL);\n\treturn out;\n}\n", "target": 1, "idx": 179154}
{"func": "status_t SampleTable::setCompositionTimeToSampleParams(\n off64_t data_offset, size_t data_size) {\n    ALOGI(\"There are reordered frames present.\");\n\n if (mCompositionTimeDeltaEntries != NULL || data_size < 8) {\n return ERROR_MALFORMED;\n }\n\n uint8_t header[8];\n if (mDataSource->readAt(\n                data_offset, header, sizeof(header))\n < (ssize_t)sizeof(header)) {\n return ERROR_IO;\n }\n\n if (U32_AT(header) != 0) {\n return ERROR_MALFORMED;\n }\n\n size_t numEntries = U32_AT(&header[4]);\n\n if (data_size != (numEntries + 1) * 8) {\n return ERROR_MALFORMED;\n\n     }\n \n     mNumCompositionTimeDeltaEntries = numEntries;\n     mCompositionTimeDeltaEntries = new uint32_t[2 * numEntries];\n \n     if (mDataSource->readAt(\n                data_offset + 8, mCompositionTimeDeltaEntries, numEntries * 8)\n < (ssize_t)numEntries * 8) {\n delete[] mCompositionTimeDeltaEntries;\n        mCompositionTimeDeltaEntries = NULL;\n\n return ERROR_IO;\n }\n\n for (size_t i = 0; i < 2 * numEntries; ++i) {\n        mCompositionTimeDeltaEntries[i] = ntohl(mCompositionTimeDeltaEntries[i]);\n }\n\n    mCompositionDeltaLookup->setEntries(\n            mCompositionTimeDeltaEntries, mNumCompositionTimeDeltaEntries);\n\n return OK;\n}\n", "target": 1, "idx": 187397}
{"func": "xmlParseNameComplex(xmlParserCtxtPtr ctxt) {\n    int len = 0, l;\n    int c;\n    int count = 0;\n\n#ifdef DEBUG\n    nbParseNameComplex++;\n#endif\n\n    /*\n      * Handler for more complex cases\n      */\n     GROW;\n     c = CUR_CHAR(l);\n     if ((ctxt->options & XML_PARSE_OLD10) == 0) {\n         /*\n\t * Use the new checks of production [4] [4a] amd [5] of the\n\t * Update 5 of XML-1.0\n\t */\n\tif ((c == ' ') || (c == '>') || (c == '/') || /* accelerators */\n\t    (!(((c >= 'a') && (c <= 'z')) ||\n\t       ((c >= 'A') && (c <= 'Z')) ||\n\t       (c == '_') || (c == ':') ||\n\t       ((c >= 0xC0) && (c <= 0xD6)) ||\n\t       ((c >= 0xD8) && (c <= 0xF6)) ||\n\t       ((c >= 0xF8) && (c <= 0x2FF)) ||\n\t       ((c >= 0x370) && (c <= 0x37D)) ||\n\t       ((c >= 0x37F) && (c <= 0x1FFF)) ||\n\t       ((c >= 0x200C) && (c <= 0x200D)) ||\n\t       ((c >= 0x2070) && (c <= 0x218F)) ||\n\t       ((c >= 0x2C00) && (c <= 0x2FEF)) ||\n\t       ((c >= 0x3001) && (c <= 0xD7FF)) ||\n\t       ((c >= 0xF900) && (c <= 0xFDCF)) ||\n\t       ((c >= 0xFDF0) && (c <= 0xFFFD)) ||\n\t       ((c >= 0x10000) && (c <= 0xEFFFF))))) {\n\t    return(NULL);\n\t}\n\tlen += l;\n\tNEXTL(l);\n\tc = CUR_CHAR(l);\n\twhile ((c != ' ') && (c != '>') && (c != '/') && /* accelerators */\n\t       (((c >= 'a') && (c <= 'z')) ||\n\t        ((c >= 'A') && (c <= 'Z')) ||\n\t        ((c >= '0') && (c <= '9')) || /* !start */\n\t        (c == '_') || (c == ':') ||\n\t        (c == '-') || (c == '.') || (c == 0xB7) || /* !start */\n\t        ((c >= 0xC0) && (c <= 0xD6)) ||\n\t        ((c >= 0xD8) && (c <= 0xF6)) ||\n\t        ((c >= 0xF8) && (c <= 0x2FF)) ||\n\t        ((c >= 0x300) && (c <= 0x36F)) || /* !start */\n\t        ((c >= 0x370) && (c <= 0x37D)) ||\n\t        ((c >= 0x37F) && (c <= 0x1FFF)) ||\n\t        ((c >= 0x200C) && (c <= 0x200D)) ||\n\t        ((c >= 0x203F) && (c <= 0x2040)) || /* !start */\n\t        ((c >= 0x2070) && (c <= 0x218F)) ||\n\t        ((c >= 0x2C00) && (c <= 0x2FEF)) ||\n\t        ((c >= 0x3001) && (c <= 0xD7FF)) ||\n\t        ((c >= 0xF900) && (c <= 0xFDCF)) ||\n\t        ((c >= 0xFDF0) && (c <= 0xFFFD)) ||\n\t        ((c >= 0x10000) && (c <= 0xEFFFF))\n\t\t)) {\n \t    if (count++ > 100) {\n \t\tcount = 0;\n \t\tGROW;\n \t    }\n \t    len += l;\n \t    NEXTL(l);\n\t    c = CUR_CHAR(l);\n\t}\n    } else {\n\tif ((c == ' ') || (c == '>') || (c == '/') || /* accelerators */\n\t    (!IS_LETTER(c) && (c != '_') &&\n\t     (c != ':'))) {\n\t    return(NULL);\n\t}\n\tlen += l;\n\tNEXTL(l);\n\tc = CUR_CHAR(l);\n\n\twhile ((c != ' ') && (c != '>') && (c != '/') && /* test bigname.xml */\n\t       ((IS_LETTER(c)) || (IS_DIGIT(c)) ||\n\t\t(c == '.') || (c == '-') ||\n\t\t(c == '_') || (c == ':') || \n\t\t(IS_COMBINING(c)) ||\n\t\t(IS_EXTENDER(c)))) {\n \t    if (count++ > 100) {\n \t\tcount = 0;\n \t\tGROW;\n \t    }\n \t    len += l;\n \t    NEXTL(l);\n\t    c = CUR_CHAR(l);\n\t}\n    }\n    if ((*ctxt->input->cur == '\\n') && (ctxt->input->cur[-1] == '\\r'))\n        return(xmlDictLookup(ctxt->dict, ctxt->input->cur - (len + 1), len));\n    return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len));\n}\n", "target": 1, "idx": 184989}
{"func": "   virtual void SetUp() {\n    fwd_txfm_ = GET_PARAM(0);\n\n     inv_txfm_ = GET_PARAM(1);\n     version_  = GET_PARAM(2);  // 0: high precision forward transform\n   }\n", "target": 1, "idx": 188553}
{"func": "static int crypto_authenc_verify(struct aead_request *req,\n\t\t\t\t authenc_ahash_t authenc_ahash_fn)\n{\n\tstruct crypto_aead *authenc = crypto_aead_reqtfm(req);\n\tstruct authenc_request_ctx *areq_ctx = aead_request_ctx(req);\n\tu8 *ohash;\n\tu8 *ihash;\n\tunsigned int authsize;\n\n\tareq_ctx->complete = authenc_verify_ahash_done;\n\tareq_ctx->update_complete = authenc_verify_ahash_update_done;\n\n\tohash = authenc_ahash_fn(req, CRYPTO_TFM_REQ_MAY_SLEEP);\n\tif (IS_ERR(ohash))\n\t\treturn PTR_ERR(ohash);\n\n\tauthsize = crypto_aead_authsize(authenc);\n\tihash = ohash + authsize;\n\tscatterwalk_map_and_copy(ihash, areq_ctx->sg, areq_ctx->cryptlen,\n\t\t\t\t authsize, 0);\n\treturn crypto_memneq(ihash, ohash, authsize) ? -EBADMSG : 0;\n}\n", "target": 0, "idx": 45533}
{"func": "omx_vdec::omx_vdec(): m_error_propogated(false),\n    m_state(OMX_StateInvalid),\n    m_app_data(NULL),\n    m_inp_mem_ptr(NULL),\n    m_out_mem_ptr(NULL),\n    input_flush_progress (false),\n    output_flush_progress (false),\n    input_use_buffer (false),\n    output_use_buffer (false),\n    ouput_egl_buffers(false),\n    m_use_output_pmem(OMX_FALSE),\n    m_out_mem_region_smi(OMX_FALSE),\n    m_out_pvt_entry_pmem(OMX_FALSE),\n    pending_input_buffers(0),\n    pending_output_buffers(0),\n    m_out_bm_count(0),\n    m_inp_bm_count(0),\n    m_inp_bPopulated(OMX_FALSE),\n    m_out_bPopulated(OMX_FALSE),\n    m_flags(0),\n#ifdef _ANDROID_\n    m_heap_ptr(NULL),\n#endif\n    m_inp_bEnabled(OMX_TRUE),\n    m_out_bEnabled(OMX_TRUE),\n    m_in_alloc_cnt(0),\n    m_platform_list(NULL),\n    m_platform_entry(NULL),\n    m_pmem_info(NULL),\n    h264_parser(NULL),\n    arbitrary_bytes (true),\n    psource_frame (NULL),\n    pdest_frame (NULL),\n    m_inp_heap_ptr (NULL),\n    m_phdr_pmem_ptr(NULL),\n    m_heap_inp_bm_count (0),\n    codec_type_parse ((codec_type)0),\n    first_frame_meta (true),\n    frame_count (0),\n    nal_count (0),\n    nal_length(0),\n    look_ahead_nal (false),\n    first_frame(0),\n    first_buffer(NULL),\n    first_frame_size (0),\n    m_device_file_ptr(NULL),\n    m_vc1_profile((vc1_profile_type)0),\n    h264_last_au_ts(LLONG_MAX),\n    h264_last_au_flags(0),\n    m_disp_hor_size(0),\n    m_disp_vert_size(0),\n    prev_ts(LLONG_MAX),\n    rst_prev_ts(true),\n    frm_int(0),\n    in_reconfig(false),\n    m_display_id(NULL),\n    client_extradata(0),\n    m_reject_avc_1080p_mp (0),\n#ifdef _ANDROID_\n    m_enable_android_native_buffers(OMX_FALSE),\n    m_use_android_native_buffers(OMX_FALSE),\n    iDivXDrmDecrypt(NULL),\n#endif\n    m_desc_buffer_ptr(NULL),\n    secure_mode(false),\n    m_other_extradata(NULL),\n    m_profile(0),\n    client_set_fps(false),\n    m_last_rendered_TS(-1),\n    m_queued_codec_config_count(0),\n    secure_scaling_to_non_secure_opb(false)\n{\n /* Assumption is that , to begin with , we have all the frames with decoder */\n    DEBUG_PRINT_HIGH(\"In %u bit OMX vdec Constructor\", (unsigned int)sizeof(long) * 8);\n    memset(&m_debug,0,sizeof(m_debug));\n#ifdef _ANDROID_\n char property_value[PROPERTY_VALUE_MAX] = {0};\n    property_get(\"vidc.debug.level\", property_value, \"1\");\n    debug_level = atoi(property_value);\n    property_value[0] = '\\0';\n\n    DEBUG_PRINT_HIGH(\"In OMX vdec Constructor\");\n\n    property_get(\"vidc.dec.debug.perf\", property_value, \"0\");\n    perf_flag = atoi(property_value);\n if (perf_flag) {\n        DEBUG_PRINT_HIGH(\"vidc.dec.debug.perf is %d\", perf_flag);\n        dec_time.start();\n        proc_frms = latency = 0;\n }\n    prev_n_filled_len = 0;\n    property_value[0] = '\\0';\n    property_get(\"vidc.dec.debug.ts\", property_value, \"0\");\n    m_debug_timestamp = atoi(property_value);\n    DEBUG_PRINT_HIGH(\"vidc.dec.debug.ts value is %d\",m_debug_timestamp);\n if (m_debug_timestamp) {\n        time_stamp_dts.set_timestamp_reorder_mode(true);\n        time_stamp_dts.enable_debug_print(true);\n }\n\n    property_value[0] = '\\0';\n    property_get(\"vidc.dec.debug.concealedmb\", property_value, \"0\");\n    m_debug_concealedmb = atoi(property_value);\n    DEBUG_PRINT_HIGH(\"vidc.dec.debug.concealedmb value is %d\",m_debug_concealedmb);\n\n    property_value[0] = '\\0';\n    property_get(\"vidc.dec.profile.check\", property_value, \"0\");\n    m_reject_avc_1080p_mp = atoi(property_value);\n    DEBUG_PRINT_HIGH(\"vidc.dec.profile.check value is %d\",m_reject_avc_1080p_mp);\n\n    property_value[0] = '\\0';\n    property_get(\"vidc.dec.log.in\", property_value, \"0\");\n    m_debug.in_buffer_log = atoi(property_value);\n\n    property_value[0] = '\\0';\n    property_get(\"vidc.dec.log.out\", property_value, \"0\");\n    m_debug.out_buffer_log = atoi(property_value);\n    sprintf(m_debug.log_loc, \"%s\", BUFFER_LOG_LOC);\n\n    property_value[0] = '\\0';\n    property_get(\"vidc.log.loc\", property_value, \"\");\n if (*property_value)\n        strlcpy(m_debug.log_loc, property_value, PROPERTY_VALUE_MAX);\n\n    property_value[0] = '\\0';\n    property_get(\"vidc.dec.120fps.enabled\", property_value, \"0\");\n\n if(atoi(property_value)) {\n        DEBUG_PRINT_LOW(\"feature 120 FPS decode enabled\");\n        m_last_rendered_TS = 0;\n }\n\n    property_value[0] = '\\0';\n    property_get(\"vidc.dec.debug.dyn.disabled\", property_value, \"0\");\n    m_disable_dynamic_buf_mode = atoi(property_value);\n    DEBUG_PRINT_HIGH(\"vidc.dec.debug.dyn.disabled value is %d\",m_disable_dynamic_buf_mode);\n\n#endif\n    memset(&m_cmp,0,sizeof(m_cmp));\n    memset(&m_cb,0,sizeof(m_cb));\n    memset (&drv_ctx,0,sizeof(drv_ctx));\n    memset (&h264_scratch,0,sizeof (OMX_BUFFERHEADERTYPE));\n    memset (m_hwdevice_name,0,sizeof(m_hwdevice_name));\n    memset(m_demux_offsets, 0, ( sizeof(OMX_U32) * 8192) );\n    memset(&m_custom_buffersize, 0, sizeof(m_custom_buffersize));\n    m_demux_entries = 0;\n    msg_thread_id = 0;\n    async_thread_id = 0;\n    msg_thread_created = false;\n    async_thread_created = false;\n#ifdef _ANDROID_ICS_\n    memset(&native_buffer, 0 ,(sizeof(struct nativebuffer) * MAX_NUM_INPUT_OUTPUT_BUFFERS));\n#endif\n    memset(&drv_ctx.extradata_info, 0, sizeof(drv_ctx.extradata_info));\n\n /* invalidate m_frame_pack_arrangement */\n    memset(&m_frame_pack_arrangement, 0, sizeof(OMX_QCOM_FRAME_PACK_ARRANGEMENT));\n    m_frame_pack_arrangement.cancel_flag = 1;\n\n    drv_ctx.timestamp_adjust = false;\n    drv_ctx.video_driver_fd = -1;\n\n     m_vendor_config.pData = NULL;\n     pthread_mutex_init(&m_lock, NULL);\n     pthread_mutex_init(&c_lock, NULL);\n     sem_init(&m_cmd_lock,0,0);\n     sem_init(&m_safe_flush, 0, 0);\n     streaming[CAPTURE_PORT] =\n        streaming[OUTPUT_PORT] = false;\n#ifdef _ANDROID_\n char extradata_value[PROPERTY_VALUE_MAX] = {0};\n    property_get(\"vidc.dec.debug.extradata\", extradata_value, \"0\");\n    m_debug_extradata = atoi(extradata_value);\n    DEBUG_PRINT_HIGH(\"vidc.dec.debug.extradata value is %d\",m_debug_extradata);\n#endif\n    m_fill_output_msg = OMX_COMPONENT_GENERATE_FTB;\n    client_buffers.set_vdec_client(this);\n    dynamic_buf_mode = false;\n    out_dynamic_list = NULL;\n    is_down_scalar_enabled = false;\n    m_smoothstreaming_mode = false;\n    m_smoothstreaming_width = 0;\n    m_smoothstreaming_height = 0;\n    is_q6_platform = false;\n}\n", "target": 1, "idx": 187775}
{"func": "void ScreenRecorder::DoAddConnection(\n    scoped_refptr<ConnectionToClient> connection) {\n  DCHECK(network_loop_->BelongsToCurrentThread());\n  connections_.push_back(connection);\n}\n", "target": 1, "idx": 184649}
{"func": "  psh_glyph_find_blue_points( PSH_Blues  blues,\n                              PSH_Glyph  glyph )\n  {\n    PSH_Blue_Table  table;\n    PSH_Blue_Zone   zone;\n    FT_UInt         glyph_count = glyph->num_points;\n    FT_UInt         blue_count;\n    PSH_Point       point = glyph->points;\n\n\n    for ( ; glyph_count > 0; glyph_count--, point++ )\n    {\n      FT_Pos  y;\n\n\n      /* check tangents */\n      if ( !PSH_DIR_COMPARE( point->dir_in,  PSH_DIR_HORIZONTAL ) &&\n           !PSH_DIR_COMPARE( point->dir_out, PSH_DIR_HORIZONTAL ) )\n        continue;\n\n      /* skip strong points */\n      if ( psh_point_is_strong( point ) )\n        continue;\n\n      y = point->org_u;\n\n      /* look up top zones */\n      table      = &blues->normal_top;\n      blue_count = table->count;\n      zone       = table->zones;\n\n      for ( ; blue_count > 0; blue_count--, zone++ )\n      {\n        FT_Pos  delta = y - zone->org_bottom;\n\n\n        if ( delta < -blues->blue_fuzz )\n          break;\n\n        if ( y <= zone->org_top + blues->blue_fuzz )\n          if ( blues->no_overshoots || delta <= blues->blue_threshold )\n          {\n            point->cur_u = zone->cur_bottom;\n            psh_point_set_strong( point );\n            psh_point_set_fitted( point );\n          }\n      }\n\n      /* look up bottom zones */\n      table      = &blues->normal_bottom;\n      blue_count = table->count;\n      zone       = table->zones + blue_count - 1;\n\n      for ( ; blue_count > 0; blue_count--, zone-- )\n      {\n        FT_Pos  delta = zone->org_top - y;\n\n\n        if ( delta < -blues->blue_fuzz )\n          break;\n\n        if ( y >= zone->org_bottom - blues->blue_fuzz )\n          if ( blues->no_overshoots || delta < blues->blue_threshold )\n          {\n            point->cur_u = zone->cur_top;\n            psh_point_set_strong( point );\n            psh_point_set_fitted( point );\n          }\n      }\n    }\n  }\n", "target": 0, "idx": 10330}
{"func": "jas_matrix_t *jas_seq2d_create(int xstart, int ystart, int xend, int yend)\n {\n \tjas_matrix_t *matrix;\n \tassert(xstart <= xend && ystart <= yend);\n\tif (!(matrix = jas_matrix_create(yend - ystart, xend - xstart))) {\n\t\treturn 0;\n\t}\n\tmatrix->xstart_ = xstart;\n\tmatrix->ystart_ = ystart;\n\tmatrix->xend_ = xend;\n\tmatrix->yend_ = yend;\n \treturn matrix;\n }\n", "target": 1, "idx": 181881}
{"func": "long long BlockGroup::GetNextTimeCode() const\n{\n    return m_next;\n}\n", "target": 1, "idx": 188370}
{"func": "static int protocol_client_msg(VncState *vs, uint8_t *data, size_t len)\n{\n    int i;\n    uint16_t limit;\n    VncDisplay *vd = vs->vd;\n\n    if (data[0] > 3) {\n        update_displaychangelistener(&vd->dcl, VNC_REFRESH_INTERVAL_BASE);\n    }\n\n    switch (data[0]) {\n    case VNC_MSG_CLIENT_SET_PIXEL_FORMAT:\n        if (len == 1)\n            return 20;\n\n        set_pixel_format(vs, read_u8(data, 4), read_u8(data, 5),\n                         read_u8(data, 6), read_u8(data, 7),\n                         read_u16(data, 8), read_u16(data, 10),\n                         read_u16(data, 12), read_u8(data, 14),\n                         read_u8(data, 15), read_u8(data, 16));\n        break;\n    case VNC_MSG_CLIENT_SET_ENCODINGS:\n        if (len == 1)\n            return 4;\n\n        if (len == 4) {\n            limit = read_u16(data, 2);\n            if (limit > 0)\n                return 4 + (limit * 4);\n        } else\n            limit = read_u16(data, 2);\n\n        for (i = 0; i < limit; i++) {\n            int32_t val = read_s32(data, 4 + (i * 4));\n            memcpy(data + 4 + (i * 4), &val, sizeof(val));\n        }\n\n        set_encodings(vs, (int32_t *)(data + 4), limit);\n        break;\n    case VNC_MSG_CLIENT_FRAMEBUFFER_UPDATE_REQUEST:\n        if (len == 1)\n            return 10;\n\n        framebuffer_update_request(vs,\n                                   read_u8(data, 1), read_u16(data, 2), read_u16(data, 4),\n                                   read_u16(data, 6), read_u16(data, 8));\n        break;\n    case VNC_MSG_CLIENT_KEY_EVENT:\n        if (len == 1)\n            return 8;\n\n        key_event(vs, read_u8(data, 1), read_u32(data, 4));\n        break;\n    case VNC_MSG_CLIENT_POINTER_EVENT:\n        if (len == 1)\n            return 6;\n\n        pointer_event(vs, read_u8(data, 1), read_u16(data, 2), read_u16(data, 4));\n        break;\n    case VNC_MSG_CLIENT_CUT_TEXT:\n        if (len == 1) {\n            return 8;\n        }\n        if (len == 8) {\n            uint32_t dlen = read_u32(data, 4);\n            if (dlen > (1 << 20)) {\n                error_report(\"vnc: client_cut_text msg payload has %u bytes\"\n                             \" which exceeds our limit of 1MB.\", dlen);\n                vnc_client_error(vs);\n                break;\n            }\n            if (dlen > 0) {\n                return 8 + dlen;\n            }\n        }\n\n        client_cut_text(vs, read_u32(data, 4), data + 8);\n        break;\n    case VNC_MSG_CLIENT_QEMU:\n        if (len == 1)\n            return 2;\n\n        switch (read_u8(data, 1)) {\n        case VNC_MSG_CLIENT_QEMU_EXT_KEY_EVENT:\n            if (len == 2)\n                return 12;\n\n            ext_key_event(vs, read_u16(data, 2),\n                          read_u32(data, 4), read_u32(data, 8));\n            break;\n        case VNC_MSG_CLIENT_QEMU_AUDIO:\n            if (len == 2)\n                return 4;\n\n            switch (read_u16 (data, 2)) {\n            case VNC_MSG_CLIENT_QEMU_AUDIO_ENABLE:\n                audio_add(vs);\n                break;\n            case VNC_MSG_CLIENT_QEMU_AUDIO_DISABLE:\n                audio_del(vs);\n                break;\n            case VNC_MSG_CLIENT_QEMU_AUDIO_SET_FORMAT:\n                if (len == 4)\n                    return 10;\n                switch (read_u8(data, 4)) {\n                case 0: vs->as.fmt = AUD_FMT_U8; break;\n                case 1: vs->as.fmt = AUD_FMT_S8; break;\n                case 2: vs->as.fmt = AUD_FMT_U16; break;\n                case 3: vs->as.fmt = AUD_FMT_S16; break;\n                case 4: vs->as.fmt = AUD_FMT_U32; break;\n                case 5: vs->as.fmt = AUD_FMT_S32; break;\n                default:\n                    printf(\"Invalid audio format %d\\n\", read_u8(data, 4));\n                    vnc_client_error(vs);\n                    break;\n                }\n                vs->as.nchannels = read_u8(data, 5);\n                if (vs->as.nchannels != 1 && vs->as.nchannels != 2) {\n                    printf(\"Invalid audio channel coount %d\\n\",\n                           read_u8(data, 5));\n                    vnc_client_error(vs);\n                    break;\n                }\n                vs->as.freq = read_u32(data, 6);\n                break;\n            default:\n                printf (\"Invalid audio message %d\\n\", read_u8(data, 4));\n                vnc_client_error(vs);\n                break;\n            }\n            break;\n\n        default:\n            printf(\"Msg: %d\\n\", read_u16(data, 0));\n            vnc_client_error(vs);\n            break;\n        }\n        break;\n    default:\n        printf(\"Msg: %d\\n\", data[0]);\n        vnc_client_error(vs);\n        break;\n    }\n\n    vnc_read_when(vs, protocol_client_msg, 1);\n    return 0;\n}\n", "target": 0, "idx": 7974}
{"func": "void kvm_vcpu_reset(struct kvm_vcpu *vcpu)\n{\n\tatomic_set(&vcpu->arch.nmi_queued, 0);\n\tvcpu->arch.nmi_pending = 0;\n\tvcpu->arch.nmi_injected = false;\n\n\tmemset(vcpu->arch.db, 0, sizeof(vcpu->arch.db));\n\tvcpu->arch.dr6 = DR6_FIXED_1;\n\tvcpu->arch.dr7 = DR7_FIXED_1;\n\tkvm_update_dr7(vcpu);\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\tvcpu->arch.apf.msr_val = 0;\n\tvcpu->arch.st.msr_val = 0;\n\n\tkvmclock_reset(vcpu);\n\n\tkvm_clear_async_pf_completion_queue(vcpu);\n\tkvm_async_pf_hash_reset(vcpu);\n\tvcpu->arch.apf.halted = false;\n\n\tkvm_pmu_reset(vcpu);\n\n\tmemset(vcpu->arch.regs, 0, sizeof(vcpu->arch.regs));\n\tvcpu->arch.regs_avail = ~0;\n\tvcpu->arch.regs_dirty = ~0;\n\n\tkvm_x86_ops->vcpu_reset(vcpu);\n}\n", "target": 0, "idx": 28903}
{"func": "size_t CancelableFileOperation(Function operation,\n                               HANDLE file,\n                               BufferType* buffer,\n                               size_t length,\n                               WaitableEvent* io_event,\n                               WaitableEvent* cancel_event,\n                               CancelableSyncSocket* socket,\n                               DWORD timeout_in_ms) {\n  ThreadRestrictions::AssertIOAllowed();\n  COMPILE_ASSERT(sizeof(buffer[0]) == sizeof(char), incorrect_buffer_type);\n  DCHECK_GT(length, 0u);\n  DCHECK_LE(length, kMaxMessageLength);\n  DCHECK_NE(file, SyncSocket::kInvalidHandle);\n\n  TimeTicks current_time, finish_time;\n  if (timeout_in_ms != INFINITE) {\n    current_time = TimeTicks::Now();\n    finish_time =\n        current_time + base::TimeDelta::FromMilliseconds(timeout_in_ms);\n  }\n\n  size_t count = 0;\n  do {\n    OVERLAPPED ol = { 0 };\n    ol.hEvent = io_event->handle();\n\n    const DWORD chunk = GetNextChunkSize(count, length);\n    DWORD len = 0;\n    const BOOL operation_ok = operation(\n        file, static_cast<BufferType*>(buffer) + count, chunk, &len, &ol);\n    if (!operation_ok) {\n       if (::GetLastError() == ERROR_IO_PENDING) {\n         HANDLE events[] = { io_event->handle(), cancel_event->handle() };\n         const int wait_result = WaitForMultipleObjects(\n            ARRAYSIZE_UNSAFE(events), events, FALSE,\n             timeout_in_ms == INFINITE ?\n                 timeout_in_ms :\n                 static_cast<DWORD>(\n                    (finish_time - current_time).InMilliseconds()));\n        if (wait_result != WAIT_OBJECT_0 + 0) {\n          CancelIo(file);\n        }\n\n        if (!GetOverlappedResult(file, &ol, &len, TRUE))\n          len = 0;\n\n        if (wait_result == WAIT_OBJECT_0 + 1) {\n          DVLOG(1) << \"Shutdown was signaled. Closing socket.\";\n          socket->Close();\n          return count;\n        }\n\n        DCHECK(wait_result == WAIT_OBJECT_0 + 0 || wait_result == WAIT_TIMEOUT);\n      } else {\n        break;\n      }\n    }\n\n    count += len;\n\n    if (len != chunk)\n      break;\n\n    if (timeout_in_ms != INFINITE && count < length)\n      current_time = base::TimeTicks::Now();\n  } while (count < length &&\n           (timeout_in_ms == INFINITE || current_time < finish_time));\n\n  return count;\n}\n", "target": 1, "idx": 184855}
{"func": "start_input_bmp(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  bmp_source_ptr source = (bmp_source_ptr)sinfo;\n  U_CHAR bmpfileheader[14];\n  U_CHAR bmpinfoheader[64];\n\n#define GET_2B(array, offset) \\\n  ((unsigned short)UCH(array[offset]) + \\\n   (((unsigned short)UCH(array[offset + 1])) << 8))\n#define GET_4B(array, offset) \\\n  ((unsigned int)UCH(array[offset]) + \\\n   (((unsigned int)UCH(array[offset + 1])) << 8) + \\\n   (((unsigned int)UCH(array[offset + 2])) << 16) + \\\n   (((unsigned int)UCH(array[offset + 3])) << 24))\n\n  unsigned int bfOffBits;\n  unsigned int headerSize;\n  int biWidth;\n  int biHeight;\n  unsigned short biPlanes;\n  unsigned int biCompression;\n  int biXPelsPerMeter, biYPelsPerMeter;\n  unsigned int biClrUsed = 0;\n  int mapentrysize = 0;         /* 0 indicates no colormap */\n  int bPad;\n  JDIMENSION row_width = 0;\n\n  /* Read and verify the bitmap file header */\n  if (!ReadOK(source->pub.input_file, bmpfileheader, 14))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  if (GET_2B(bmpfileheader, 0) != 0x4D42) /* 'BM' */\n    ERREXIT(cinfo, JERR_BMP_NOT);\n  bfOffBits = GET_4B(bmpfileheader, 10);\n  /* We ignore the remaining fileheader fields */\n\n  /* The infoheader might be 12 bytes (OS/2 1.x), 40 bytes (Windows),\n   * or 64 bytes (OS/2 2.x).  Check the first 4 bytes to find out which.\n   */\n  if (!ReadOK(source->pub.input_file, bmpinfoheader, 4))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  headerSize = GET_4B(bmpinfoheader, 0);\n  if (headerSize < 12 || headerSize > 64)\n    ERREXIT(cinfo, JERR_BMP_BADHEADER);\n  if (!ReadOK(source->pub.input_file, bmpinfoheader + 4, headerSize - 4))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n\n  switch (headerSize) {\n  case 12:\n    /* Decode OS/2 1.x header (Microsoft calls this a BITMAPCOREHEADER) */\n    biWidth = (int)GET_2B(bmpinfoheader, 4);\n    biHeight = (int)GET_2B(bmpinfoheader, 6);\n    biPlanes = GET_2B(bmpinfoheader, 8);\n    source->bits_per_pixel = (int)GET_2B(bmpinfoheader, 10);\n\n    switch (source->bits_per_pixel) {\n    case 8:                     /* colormapped image */\n      mapentrysize = 3;         /* OS/2 uses RGBTRIPLE colormap */\n      TRACEMS2(cinfo, 1, JTRC_BMP_OS2_MAPPED, biWidth, biHeight);\n      break;\n    case 24:                    /* RGB image */\n      TRACEMS2(cinfo, 1, JTRC_BMP_OS2, biWidth, biHeight);\n      break;\n    default:\n      ERREXIT(cinfo, JERR_BMP_BADDEPTH);\n      break;\n    }\n    break;\n  case 40:\n  case 64:\n    /* Decode Windows 3.x header (Microsoft calls this a BITMAPINFOHEADER) */\n    /* or OS/2 2.x header, which has additional fields that we ignore */\n    biWidth = (int)GET_4B(bmpinfoheader, 4);\n    biHeight = (int)GET_4B(bmpinfoheader, 8);\n    biPlanes = GET_2B(bmpinfoheader, 12);\n    source->bits_per_pixel = (int)GET_2B(bmpinfoheader, 14);\n    biCompression = GET_4B(bmpinfoheader, 16);\n    biXPelsPerMeter = (int)GET_4B(bmpinfoheader, 24);\n    biYPelsPerMeter = (int)GET_4B(bmpinfoheader, 28);\n    biClrUsed = GET_4B(bmpinfoheader, 32);\n    /* biSizeImage, biClrImportant fields are ignored */\n\n    switch (source->bits_per_pixel) {\n    case 8:                     /* colormapped image */\n      mapentrysize = 4;         /* Windows uses RGBQUAD colormap */\n      TRACEMS2(cinfo, 1, JTRC_BMP_MAPPED, biWidth, biHeight);\n      break;\n    case 24:                    /* RGB image */\n      TRACEMS2(cinfo, 1, JTRC_BMP, biWidth, biHeight);\n      break;\n    case 32:                    /* RGB image + Alpha channel */\n      TRACEMS2(cinfo, 1, JTRC_BMP, biWidth, biHeight);\n      break;\n    default:\n      ERREXIT(cinfo, JERR_BMP_BADDEPTH);\n      break;\n    }\n    if (biCompression != 0)\n      ERREXIT(cinfo, JERR_BMP_COMPRESSED);\n\n    if (biXPelsPerMeter > 0 && biYPelsPerMeter > 0) {\n      /* Set JFIF density parameters from the BMP data */\n      cinfo->X_density = (UINT16)(biXPelsPerMeter / 100); /* 100 cm per meter */\n      cinfo->Y_density = (UINT16)(biYPelsPerMeter / 100);\n      cinfo->density_unit = 2;  /* dots/cm */\n    }\n    break;\n  default:\n    ERREXIT(cinfo, JERR_BMP_BADHEADER);\n    return;\n  }\n\n  if (biWidth <= 0 || biHeight <= 0)\n    ERREXIT(cinfo, JERR_BMP_EMPTY);\n  if (biPlanes != 1)\n    ERREXIT(cinfo, JERR_BMP_BADPLANES);\n\n  /* Compute distance to bitmap data --- will adjust for colormap below */\n  bPad = bfOffBits - (headerSize + 14);\n\n  /* Read the colormap, if any */\n  if (mapentrysize > 0) {\n    if (biClrUsed <= 0)\n      biClrUsed = 256;          /* assume it's 256 */\n    else if (biClrUsed > 256)\n      ERREXIT(cinfo, JERR_BMP_BADCMAP);\n     /* Allocate space to store the colormap */\n     source->colormap = (*cinfo->mem->alloc_sarray)\n       ((j_common_ptr)cinfo, JPOOL_IMAGE, (JDIMENSION)biClrUsed, (JDIMENSION)3);\n     /* and read it from the file */\n     read_colormap(source, (int)biClrUsed, mapentrysize);\n     /* account for size of colormap */\n    bPad -= biClrUsed * mapentrysize;\n  }\n\n  /* Skip any remaining pad bytes */\n  if (bPad < 0)                 /* incorrect bfOffBits value? */\n    ERREXIT(cinfo, JERR_BMP_BADHEADER);\n  while (--bPad >= 0) {\n    (void)read_byte(source);\n  }\n\n  /* Compute row width in file, including padding to 4-byte boundary */\n  switch (source->bits_per_pixel) {\n  case 8:\n    if (cinfo->in_color_space == JCS_UNKNOWN)\n      cinfo->in_color_space = JCS_EXT_RGB;\n    if (IsExtRGB(cinfo->in_color_space))\n      cinfo->input_components = rgb_pixelsize[cinfo->in_color_space];\n    else if (cinfo->in_color_space == JCS_GRAYSCALE)\n      cinfo->input_components = 1;\n    else if (cinfo->in_color_space == JCS_CMYK)\n      cinfo->input_components = 4;\n    else\n      ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);\n    row_width = (JDIMENSION)biWidth;\n    break;\n  case 24:\n    if (cinfo->in_color_space == JCS_UNKNOWN)\n      cinfo->in_color_space = JCS_EXT_BGR;\n    if (IsExtRGB(cinfo->in_color_space))\n      cinfo->input_components = rgb_pixelsize[cinfo->in_color_space];\n    else if (cinfo->in_color_space == JCS_CMYK)\n      cinfo->input_components = 4;\n    else\n      ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);\n    row_width = (JDIMENSION)(biWidth * 3);\n    break;\n  case 32:\n    if (cinfo->in_color_space == JCS_UNKNOWN)\n      cinfo->in_color_space = JCS_EXT_BGRA;\n    if (IsExtRGB(cinfo->in_color_space))\n      cinfo->input_components = rgb_pixelsize[cinfo->in_color_space];\n    else if (cinfo->in_color_space == JCS_CMYK)\n      cinfo->input_components = 4;\n    else\n      ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);\n    row_width = (JDIMENSION)(biWidth * 4);\n    break;\n  default:\n    ERREXIT(cinfo, JERR_BMP_BADDEPTH);\n  }\n  while ((row_width & 3) != 0) row_width++;\n  source->row_width = row_width;\n\n  if (source->use_inversion_array) {\n    /* Allocate space for inversion array, prepare for preload pass */\n    source->whole_image = (*cinfo->mem->request_virt_sarray)\n      ((j_common_ptr)cinfo, JPOOL_IMAGE, FALSE,\n       row_width, (JDIMENSION)biHeight, (JDIMENSION)1);\n    source->pub.get_pixel_rows = preload_image;\n    if (cinfo->progress != NULL) {\n      cd_progress_ptr progress = (cd_progress_ptr)cinfo->progress;\n      progress->total_extra_passes++; /* count file input as separate pass */\n    }\n  } else {\n    source->iobuffer = (U_CHAR *)\n      (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE, row_width);\n    switch (source->bits_per_pixel) {\n    case 8:\n      source->pub.get_pixel_rows = get_8bit_row;\n      break;\n    case 24:\n      source->pub.get_pixel_rows = get_24bit_row;\n      break;\n    case 32:\n      source->pub.get_pixel_rows = get_32bit_row;\n      break;\n    default:\n      ERREXIT(cinfo, JERR_BMP_BADDEPTH);\n    }\n  }\n\n  /* Ensure that biWidth * cinfo->input_components doesn't exceed the maximum\n     value of the JDIMENSION type.  This is only a danger with BMP files, since\n     their width and height fields are 32-bit integers. */\n  if ((unsigned long long)biWidth *\n      (unsigned long long)cinfo->input_components > 0xFFFFFFFFULL)\n    ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);\n  /* Allocate one-row buffer for returned data */\n  source->pub.buffer = (*cinfo->mem->alloc_sarray)\n    ((j_common_ptr)cinfo, JPOOL_IMAGE,\n     (JDIMENSION)(biWidth * cinfo->input_components), (JDIMENSION)1);\n  source->pub.buffer_height = 1;\n\n  cinfo->data_precision = 8;\n  cinfo->image_width = (JDIMENSION)biWidth;\n  cinfo->image_height = (JDIMENSION)biHeight;\n}\n", "target": 1, "idx": 183009}
{"func": "static int task_switch_16(struct x86_emulate_ctxt *ctxt,\n\t\t\t  u16 tss_selector, u16 old_tss_sel,\n\t\t\t  ulong old_tss_base, struct desc_struct *new_desc)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tstruct tss_segment_16 tss_seg;\n\tint ret;\n\tu32 new_tss_base = get_desc_base(new_desc);\n\n\tret = ops->read_std(ctxt, old_tss_base, &tss_seg, sizeof tss_seg,\n\t\t\t    &ctxt->exception);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\tsave_state_to_tss16(ctxt, &tss_seg);\n\n\tret = ops->write_std(ctxt, old_tss_base, &tss_seg, sizeof tss_seg,\n\t\t\t     &ctxt->exception);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\tret = ops->read_std(ctxt, new_tss_base, &tss_seg, sizeof tss_seg,\n\t\t\t    &ctxt->exception);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\tif (old_tss_sel != 0xffff) {\n\t\ttss_seg.prev_task_link = old_tss_sel;\n\n\t\tret = ops->write_std(ctxt, new_tss_base,\n\t\t\t\t     &tss_seg.prev_task_link,\n\t\t\t\t     sizeof tss_seg.prev_task_link,\n\t\t\t\t     &ctxt->exception);\n\t\tif (ret != X86EMUL_CONTINUE)\n\t\t\treturn ret;\n\t}\n\n\treturn load_state_from_tss16(ctxt, &tss_seg);\n}\n", "target": 0, "idx": 45041}
{"func": "fz_keep_link_key(fz_context *ctx, void *key_)\n{\n\tfz_link_key *key = (fz_link_key *)key_;\n\treturn fz_keep_imp(ctx, key, &key->refs);\n}\n", "target": 0, "idx": 387}
{"func": "void __update_tlb(struct vm_area_struct *vma, unsigned long address, pte_t pte)\n{\n}\n", "target": 0, "idx": 25627}
{"func": "static NOINLINE char *xmalloc_optname_optval(uint8_t *option, const struct dhcp_optflag *optflag, const char *opt_name)\n{\n\tunsigned upper_length;\n\tint len, type, optlen;\n\tchar *dest, *ret;\n\n\t/* option points to OPT_DATA, need to go back to get OPT_LEN */\n\tlen = option[-OPT_DATA + OPT_LEN];\n\n \ttype = optflag->flags & OPTION_TYPE_MASK;\n \toptlen = dhcp_option_lengths[type];\n \tupper_length = len_of_option_as_string[type]\n\t\t* ((unsigned)(len + optlen - 1) / (unsigned)optlen);\n \n \tdest = ret = xmalloc(upper_length + strlen(opt_name) + 2);\n \tdest += sprintf(ret, \"%s=\", opt_name);\n\n\twhile (len >= optlen) {\n\t\tswitch (type) {\n\t\tcase OPTION_IP:\n\t\tcase OPTION_IP_PAIR:\n\t\t\tdest += sprint_nip(dest, \"\", option);\n\t\t\tif (type == OPTION_IP)\n\t\t\t\tbreak;\n\t\t\tdest += sprint_nip(dest, \"/\", option + 4);\n\t\t\tbreak;\n\t\tcase OPTION_U8:\n\t\t\tdest += sprintf(dest, \"%u\", *option);\n\t\t\tbreak;\n\t\tcase OPTION_U16: {\n\t\t\tuint16_t val_u16;\n\t\t\tmove_from_unaligned16(val_u16, option);\n\t\t\tdest += sprintf(dest, \"%u\", ntohs(val_u16));\n\t\t\tbreak;\n\t\t}\n\t\tcase OPTION_S32:\n\t\tcase OPTION_U32: {\n\t\t\tuint32_t val_u32;\n\t\t\tmove_from_unaligned32(val_u32, option);\n\t\t\tdest += sprintf(dest, type == OPTION_U32 ? \"%lu\" : \"%ld\", (unsigned long) ntohl(val_u32));\n\t\t\tbreak;\n\t\t}\n\t\t/* Note: options which use 'return' instead of 'break'\n\t\t * (for example, OPTION_STRING) skip the code which handles\n\t\t * the case of list of options.\n\t\t */\n\t\tcase OPTION_STRING:\n\t\tcase OPTION_STRING_HOST:\n\t\t\tmemcpy(dest, option, len);\n\t\t\tdest[len] = '\\0';\n\t\t\tif (type == OPTION_STRING_HOST && !good_hostname(dest))\n\t\t\t\tsafe_strncpy(dest, \"bad\", len);\n\t\t\treturn ret;\n\t\tcase OPTION_STATIC_ROUTES: {\n\t\t\t/* Option binary format:\n\t\t\t * mask [one byte, 0..32]\n\t\t\t * ip [big endian, 0..4 bytes depending on mask]\n\t\t\t * router [big endian, 4 bytes]\n\t\t\t * may be repeated\n\t\t\t *\n\t\t\t * We convert it to a string \"IP/MASK ROUTER IP2/MASK2 ROUTER2\"\n\t\t\t */\n\t\t\tconst char *pfx = \"\";\n\n\t\t\twhile (len >= 1 + 4) { /* mask + 0-byte ip + router */\n\t\t\t\tuint32_t nip;\n\t\t\t\tuint8_t *p;\n\t\t\t\tunsigned mask;\n\t\t\t\tint bytes;\n\n\t\t\t\tmask = *option++;\n\t\t\t\tif (mask > 32)\n\t\t\t\t\tbreak;\n\t\t\t\tlen--;\n\n\t\t\t\tnip = 0;\n\t\t\t\tp = (void*) &nip;\n\t\t\t\tbytes = (mask + 7) / 8; /* 0 -> 0, 1..8 -> 1, 9..16 -> 2 etc */\n\t\t\t\twhile (--bytes >= 0) {\n\t\t\t\t\t*p++ = *option++;\n\t\t\t\t\tlen--;\n\t\t\t\t}\n\t\t\t\tif (len < 4)\n\t\t\t\t\tbreak;\n\n\t\t\t\t/* print ip/mask */\n\t\t\t\tdest += sprint_nip(dest, pfx, (void*) &nip);\n\t\t\t\tpfx = \" \";\n\t\t\t\tdest += sprintf(dest, \"/%u \", mask);\n\t\t\t\t/* print router */\n\t\t\t\tdest += sprint_nip(dest, \"\", option);\n\t\t\t\toption += 4;\n\t\t\t\tlen -= 4;\n\t\t\t}\n\n\t\t\treturn ret;\n\t\t}\n\t\tcase OPTION_6RD:\n\t\t\t/* Option binary format (see RFC 5969):\n\t\t\t *  0                   1                   2                   3\n\t\t\t *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\t\t\t * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t\t\t * |  OPTION_6RD   | option-length |  IPv4MaskLen  |  6rdPrefixLen |\n\t\t\t * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t\t\t * |                           6rdPrefix                           |\n\t\t\t * ...                        (16 octets)                        ...\n\t\t\t * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t\t\t * ...                   6rdBRIPv4Address(es)                    ...\n\t\t\t * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t\t\t * We convert it to a string\n\t\t\t * \"IPv4MaskLen 6rdPrefixLen 6rdPrefix 6rdBRIPv4Address...\"\n\t\t\t *\n\t\t\t * Sanity check: ensure that our length is at least 22 bytes, that\n\t\t\t * IPv4MaskLen <= 32,\n\t\t\t * 6rdPrefixLen <= 128,\n\t\t\t * 6rdPrefixLen + (32 - IPv4MaskLen) <= 128\n\t\t\t * (2nd condition need no check - it follows from 1st and 3rd).\n\t\t\t * Else, return envvar with empty value (\"optname=\")\n\t\t\t */\n\t\t\tif (len >= (1 + 1 + 16 + 4)\n\t\t\t && option[0] <= 32\n\t\t\t && (option[1] + 32 - option[0]) <= 128\n\t\t\t) {\n\t\t\t\t/* IPv4MaskLen */\n\t\t\t\tdest += sprintf(dest, \"%u \", *option++);\n\t\t\t\t/* 6rdPrefixLen */\n\t\t\t\tdest += sprintf(dest, \"%u \", *option++);\n\t\t\t\t/* 6rdPrefix */\n\t\t\t\tdest += sprint_nip6(dest, /* \"\", */ option);\n\t\t\t\toption += 16;\n\t\t\t\tlen -= 1 + 1 + 16 + 4;\n\t\t\t\t/* \"+ 4\" above corresponds to the length of IPv4 addr\n\t\t\t\t * we consume in the loop below */\n\t\t\t\twhile (1) {\n\t\t\t\t\t/* 6rdBRIPv4Address(es) */\n\t\t\t\t\tdest += sprint_nip(dest, \" \", option);\n\t\t\t\t\toption += 4;\n\t\t\t\t\tlen -= 4; /* do we have yet another 4+ bytes? */\n\t\t\t\t\tif (len < 0)\n\t\t\t\t\t\tbreak; /* no */\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn ret;\n#if ENABLE_FEATURE_UDHCP_RFC3397\n\t\tcase OPTION_DNS_STRING:\n\t\t\t/* unpack option into dest; use ret for prefix (i.e., \"optname=\") */\n\t\t\tdest = dname_dec(option, len, ret);\n\t\t\tif (dest) {\n\t\t\t\tfree(ret);\n\t\t\t\treturn dest;\n\t\t\t}\n\t\t\t/* error. return \"optname=\" string */\n\t\t\treturn ret;\n\t\tcase OPTION_SIP_SERVERS:\n\t\t\t/* Option binary format:\n\t\t\t * type: byte\n\t\t\t * type=0: domain names, dns-compressed\n\t\t\t * type=1: IP addrs\n\t\t\t */\n\t\t\toption++;\n\t\t\tlen--;\n\t\t\tif (option[-1] == 0) {\n\t\t\t\tdest = dname_dec(option, len, ret);\n\t\t\t\tif (dest) {\n\t\t\t\t\tfree(ret);\n\t\t\t\t\treturn dest;\n\t\t\t\t}\n\t\t\t} else\n\t\t\tif (option[-1] == 1) {\n\t\t\t\tconst char *pfx = \"\";\n\t\t\t\twhile (1) {\n\t\t\t\t\tlen -= 4;\n\t\t\t\t\tif (len < 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdest += sprint_nip(dest, pfx, option);\n\t\t\t\t\tpfx = \" \";\n\t\t\t\t\toption += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n#endif\n\t\t} /* switch */\n\n\t\t/* If we are here, try to format any remaining data\n\t\t * in the option as another, similarly-formatted option\n\t\t */\n\t\toption += optlen;\n\t\tlen -= optlen;\n\t\tif (len < optlen /* || !(optflag->flags & OPTION_LIST) */)\n\t\t\tbreak;\n\t\t*dest++ = ' ';\n\t\t*dest = '\\0';\n\t} /* while */\n\n\treturn ret;\n}\n", "target": 1, "idx": 178521}
{"func": "static MagickBooleanType SyncExifProfile(Image *image, StringInfo *profile)\n{\n#define MaxDirectoryStack  16\n#define EXIF_DELIMITER  \"\\n\"\n#define EXIF_NUM_FORMATS  12\n#define TAG_EXIF_OFFSET  0x8769\n#define TAG_INTEROP_OFFSET  0xa005\n\n  typedef struct _DirectoryInfo\n  {\n    unsigned char\n      *directory;\n\n    size_t\n      entry;\n  } DirectoryInfo;\n\n  DirectoryInfo\n    directory_stack[MaxDirectoryStack];\n\n  EndianType\n    endian;\n\n  size_t\n    entry,\n    length,\n    number_entries;\n\n  SplayTreeInfo\n    *exif_resources;\n\n  ssize_t\n    id,\n    level,\n    offset;\n\n  static int\n    format_bytes[] = {0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8};\n\n  unsigned char\n    *directory,\n    *exif;\n\n  /*\n    Set EXIF resolution tag.\n  */\n  length=GetStringInfoLength(profile);\n  exif=GetStringInfoDatum(profile);\n  if (length < 16)\n    return(MagickFalse);\n  id=(ssize_t) ReadProfileShort(LSBEndian,exif);\n  if ((id != 0x4949) && (id != 0x4D4D))\n    {\n      while (length != 0)\n      {\n        if (ReadProfileByte(&exif,&length) != 0x45)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x78)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x69)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x66)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x00)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x00)\n          continue;\n        break;\n      }\n      if (length < 16)\n        return(MagickFalse);\n      id=(ssize_t) ReadProfileShort(LSBEndian,exif);\n    }\n  endian=LSBEndian;\n  if (id == 0x4949)\n    endian=LSBEndian;\n  else\n    if (id == 0x4D4D)\n      endian=MSBEndian;\n    else\n      return(MagickFalse);\n  if (ReadProfileShort(endian,exif+2) != 0x002a)\n    return(MagickFalse);\n  /*\n    This the offset to the first IFD.\n  */\n  offset=(ssize_t) ReadProfileLong(endian,exif+4);\n  if ((offset < 0) || ((size_t) offset >= length))\n    return(MagickFalse);\n  directory=exif+offset;\n  level=0;\n  entry=0;\n  exif_resources=NewSplayTree((int (*)(const void *,const void *)) NULL,\n    (void *(*)(void *)) NULL,(void *(*)(void *)) NULL);\n  do\n  {\n    if (level > 0)\n      {\n        level--;\n        directory=directory_stack[level].directory;\n        entry=directory_stack[level].entry;\n      }\n    if ((directory < exif) || (directory > (exif+length-2)))\n      break;\n    /*\n      Determine how many entries there are in the current IFD.\n    */\n    number_entries=ReadProfileShort(endian,directory);\n    for ( ; entry < number_entries; entry++)\n    {\n      register unsigned char\n        *p,\n        *q;\n\n      size_t\n        number_bytes;\n\n      ssize_t\n        components,\n        format,\n        tag_value;\n\n      q=(unsigned char *) (directory+2+(12*entry));\n      if (q > (exif+length-12))\n        break;  /* corrupt EXIF */\n      if (GetValueFromSplayTree(exif_resources,q) == q)\n        break;\n      (void) AddValueToSplayTree(exif_resources,q,q);\n      tag_value=(ssize_t) ReadProfileShort(endian,q);\n      format=(ssize_t) ReadProfileShort(endian,q+2);\n      if ((format < 0) || ((format-1) >= EXIF_NUM_FORMATS))\n        break;\n      components=(ssize_t) ReadProfileLong(endian,q+4);\n      if (components < 0)\n        break;  /* corrupt EXIF */\n      number_bytes=(size_t) components*format_bytes[format];\n      if ((ssize_t) number_bytes < components)\n        break;  /* prevent overflow */\n      if (number_bytes <= 4)\n        p=q+8;\n      else\n        {\n          /*\n             The directory entry contains an offset.\n           */\n           offset=(ssize_t) ReadProfileLong(endian,q+8);\n          if ((ssize_t) (offset+number_bytes) < offset)\n            continue;  /* prevent overflow */\n          if ((size_t) (offset+number_bytes) > length)\n             continue;\n           p=(unsigned char *) (exif+offset);\n         }\n       switch (tag_value)\n      {\n        case 0x011a:\n        {\n          (void) WriteProfileLong(endian,(size_t) (image->x_resolution+0.5),p);\n          (void) WriteProfileLong(endian,1UL,p+4);\n          break;\n        }\n        case 0x011b:\n        {\n          (void) WriteProfileLong(endian,(size_t) (image->y_resolution+0.5),p);\n          (void) WriteProfileLong(endian,1UL,p+4);\n          break;\n        }\n        case 0x0112:\n        {\n          if (number_bytes == 4)\n            {\n              (void) WriteProfileLong(endian,(size_t) image->orientation,p);\n              break;\n            }\n          (void) WriteProfileShort(endian,(unsigned short) image->orientation,\n            p);\n          break;\n        }\n        case 0x0128:\n        {\n          if (number_bytes == 4)\n            {\n              (void) WriteProfileLong(endian,(size_t) (image->units+1),p);\n              break;\n            }\n          (void) WriteProfileShort(endian,(unsigned short) (image->units+1),p);\n          break;\n        }\n        default:\n          break;\n      }\n      if ((tag_value == TAG_EXIF_OFFSET) || (tag_value == TAG_INTEROP_OFFSET))\n        {\n          offset=(ssize_t) ReadProfileLong(endian,p);\n          if (((size_t) offset < length) && (level < (MaxDirectoryStack-2)))\n            {\n              directory_stack[level].directory=directory;\n              entry++;\n              directory_stack[level].entry=entry;\n              level++;\n              directory_stack[level].directory=exif+offset;\n              directory_stack[level].entry=0;\n              level++;\n              if ((directory+2+(12*number_entries)) > (exif+length))\n                break;\n              offset=(ssize_t) ReadProfileLong(endian,directory+2+(12*\n                number_entries));\n              if ((offset != 0) && ((size_t) offset < length) &&\n                  (level < (MaxDirectoryStack-2)))\n                {\n                  directory_stack[level].directory=exif+offset;\n                  directory_stack[level].entry=0;\n                  level++;\n                }\n            }\n          break;\n        }\n    }\n  } while (level > 0);\n  exif_resources=DestroySplayTree(exif_resources);\n  return(MagickTrue);\n}\n", "target": 1, "idx": 181581}
{"func": "   virtual bool InputMethodIsActivated(const std::string& input_method_id) {\n    scoped_ptr<InputMethodDescriptors> active_input_method_descriptors(\n        GetActiveInputMethods());\n     for (size_t i = 0; i < active_input_method_descriptors->size(); ++i) {\n       if (active_input_method_descriptors->at(i).id == input_method_id) {\n         return true;\n      }\n    }\n    return false;\n  }\n", "target": 1, "idx": 183953}
{"func": "static int ne2000_buffer_full(NE2000State *s)\n {\n     int avail, index, boundary;\n \n     index = s->curpag << 8;\n     boundary = s->boundary << 8;\n     if (index < boundary)\n        return 1;\n    return 0;\n}\n", "target": 1, "idx": 178356}
{"func": "static ps_sd *ps_sd_new(ps_mm *data, const char *key)\n{\n\tphp_uint32 hv, slot;\n\tps_sd *sd;\n\tint keylen;\n\n\tkeylen = strlen(key);\n\n\tsd = mm_malloc(data->mm, sizeof(ps_sd) + keylen);\n        if (!sd) {\n                TSRMLS_FETCH();\n \n               php_error_docref(NULL TSRMLS_CC, E_WARNING, \"mm_malloc failed, avail %d, err %s\", mm_available(data->mm), mm_error());\n                return NULL;\n        }\n \n\thv = ps_sd_hash(key, keylen);\n\tslot = hv & data->hash_max;\n\n\tsd->ctime = 0;\n\tsd->hv = hv;\n\tsd->data = NULL;\n\tsd->alloclen = sd->datalen = 0;\n\n\tmemcpy(sd->key, key, keylen + 1);\n\n\tsd->next = data->hash[slot];\n\tdata->hash[slot] = sd;\n\n\tdata->hash_cnt++;\n\n\tif (!sd->next) {\n\t\tif (data->hash_cnt >= data->hash_max) {\n\t\t\thash_split(data);\n\t\t}\n\t}\n\n\tps_mm_debug((\"inserting %s(%p) into slot %d\\n\", key, sd, slot));\n\n\treturn sd;\n}\n", "target": 1, "idx": 178044}
{"func": "des3_encrypt_ecb(const unsigned char *key, int keysize,\n\t\tconst unsigned char *input, int length, unsigned char *output)\n{\n\tunsigned char iv[EVP_MAX_IV_LENGTH] = { 0 };\n\tunsigned char bKey[24] = { 0 };\n\n\tif (keysize == 16) {\n\t\tmemcpy(&bKey[0], key, 16);\n\t\tmemcpy(&bKey[16], key, 8);\n\t}\n\telse {\n\t\tmemcpy(&bKey[0], key, 24);\n\t}\n\n\treturn openssl_enc(EVP_des_ede3(), bKey, iv, input, length, output);\n}\n", "target": 0, "idx": 78376}
{"func": "_tiffUnmapProc(thandle_t fd, void* base, toff_t size)\n{\n\t(void) fd;\n\t(void) size;\n\tUnmapViewOfFile(base);\n}\n", "target": 0, "idx": 86813}
{"func": "  FT_Bitmap_Embolden( FT_Library  library,\n                      FT_Bitmap*  bitmap,\n                      FT_Pos      xStrength,\n                      FT_Pos      yStrength )\n   {\n     FT_Error        error;\n     unsigned char*  p;\n    FT_Int          i, x, y, pitch;\n     FT_Int          xstr, ystr;\n \n \n      return FT_THROW( Invalid_Library_Handle );\n\n    if ( !bitmap || !bitmap->buffer )\n      return FT_THROW( Invalid_Argument );\n\n    if ( ( ( FT_PIX_ROUND( xStrength ) >> 6 ) > FT_INT_MAX ) ||\n         ( ( FT_PIX_ROUND( yStrength ) >> 6 ) > FT_INT_MAX ) )\n      return FT_THROW( Invalid_Argument );\n\n    xstr = (FT_Int)FT_PIX_ROUND( xStrength ) >> 6;\n    ystr = (FT_Int)FT_PIX_ROUND( yStrength ) >> 6;\n\n    if ( xstr == 0 && ystr == 0 )\n      return FT_Err_Ok;\n    else if ( xstr < 0 || ystr < 0 )\n      return FT_THROW( Invalid_Argument );\n\n    switch ( bitmap->pixel_mode )\n    {\n    case FT_PIXEL_MODE_GRAY2:\n    case FT_PIXEL_MODE_GRAY4:\n      {\n        FT_Bitmap  tmp;\n\n\n        /* convert to 8bpp */\n        FT_Bitmap_New( &tmp );\n        error = FT_Bitmap_Convert( library, bitmap, &tmp, 1 );\n        if ( error )\n          return error;\n\n        FT_Bitmap_Done( library, bitmap );\n        *bitmap = tmp;\n      }\n      break;\n\n    case FT_PIXEL_MODE_MONO:\n      if ( xstr > 8 )\n        xstr = 8;\n      break;\n\n    case FT_PIXEL_MODE_LCD:\n      xstr *= 3;\n      break;\n\n    case FT_PIXEL_MODE_LCD_V:\n      ystr *= 3;\n      break;\n\n    case FT_PIXEL_MODE_BGRA:\n      /* We don't embolden color glyphs. */\n      return FT_Err_Ok;\n    }\n\n    error = ft_bitmap_assure_buffer( library->memory, bitmap, xstr, ystr );\n    if ( error )\n      return error;\n\n    /* take care of bitmap flow */\n    pitch = bitmap->pitch;\n    if ( pitch > 0 )\n      p = bitmap->buffer + pitch * ystr;\n    else\n    {\n      pitch = -pitch;\n      p = bitmap->buffer + pitch * ( bitmap->rows - 1 );\n    }\n\n    /* for each row */\n    for ( y = 0; y < bitmap->rows ; y++ )\n    {\n      /*\n       * Horizontally:\n       *\n       * From the last pixel on, make each pixel or'ed with the\n       * `xstr' pixels before it.\n       */\n      for ( x = pitch - 1; x >= 0; x-- )\n      {\n        unsigned char  tmp;\n\n\n        tmp = p[x];\n        for ( i = 1; i <= xstr; i++ )\n        {\n          if ( bitmap->pixel_mode == FT_PIXEL_MODE_MONO )\n          {\n            p[x] |= tmp >> i;\n\n            /* the maximum value of 8 for `xstr' comes from here */\n            if ( x > 0 )\n              p[x] |= p[x - 1] << ( 8 - i );\n\n#if 0\n            if ( p[x] == 0xff )\n              break;\n#endif\n          }\n          else\n          {\n            if ( x - i >= 0 )\n            {\n              if ( p[x] + p[x - i] > bitmap->num_grays - 1 )\n              {\n                p[x] = (unsigned char)( bitmap->num_grays - 1 );\n                break;\n              }\n              else\n              {\n                p[x] = (unsigned char)( p[x] + p[x - i] );\n                if ( p[x] == bitmap->num_grays - 1 )\n                  break;\n              }\n            }\n            else\n              break;\n          }\n        }\n      }\n\n      /*\n       * Vertically:\n       *\n       * Make the above `ystr' rows or'ed with it.\n       */\n      for ( x = 1; x <= ystr; x++ )\n      {\n        unsigned char*  q;\n\n\n        q = p - bitmap->pitch * x;\n        for ( i = 0; i < pitch; i++ )\n          q[i] |= p[i];\n      }\n\n      p += bitmap->pitch;\n    }\n\n    bitmap->width += xstr;\n    bitmap->rows += ystr;\n\n    return FT_Err_Ok;\n  }\n", "target": 1, "idx": 178021}
{"func": "Chunk::Chunk(Container* parent, WEBP_MetaHandler* handler)\n{\n    this->needsRewrite = (parent) ? parent->needsRewrite : false;\n    this->parent = parent;\n\n    XMP_IO* file = handler->parent->ioRef;\n    this->pos = file->Offset();\n\n    this->tag = XIO::ReadUns32_LE(file);\n\n    this->size = XIO::ReadUns32_LE(file);\n\n    if ((this->pos + this->size + 8) > handler->initialFileSize) {\n        XMP_Throw(\"Bad RIFF chunk size\", kXMPErr_BadFileFormat);\n    }\n\n    this->data.reserve((XMP_Int32) this->size);\n    this->data.assign((XMP_Int32) this->size, '\\0');\n    file->ReadAll((void*)this->data.data(), (XMP_Int32) this->size);\n\n    if (this->size & 1) {\n        file->Seek(1, kXMP_SeekFromCurrent);\n    }\n}\n", "target": 0, "idx": 9951}
{"func": "void RunCallbacksWithDisabled(LogoCallbacks callbacks) {\n  if (callbacks.on_cached_encoded_logo_available) {\n    std::move(callbacks.on_cached_encoded_logo_available)\n        .Run(LogoCallbackReason::DISABLED, base::nullopt);\n  }\n  if (callbacks.on_cached_decoded_logo_available) {\n    std::move(callbacks.on_cached_decoded_logo_available)\n        .Run(LogoCallbackReason::DISABLED, base::nullopt);\n  }\n  if (callbacks.on_fresh_encoded_logo_available) {\n    std::move(callbacks.on_fresh_encoded_logo_available)\n        .Run(LogoCallbackReason::DISABLED, base::nullopt);\n  }\n  if (callbacks.on_fresh_decoded_logo_available) {\n    std::move(callbacks.on_fresh_decoded_logo_available)\n        .Run(LogoCallbackReason::DISABLED, base::nullopt);\n  }\n}\n", "target": 1, "idx": 185836}
{"func": " void *arm_dma_alloc(struct device *dev, size_t size, dma_addr_t *handle,\n \t\t    gfp_t gfp, struct dma_attrs *attrs)\n {\n\tpgprot_t prot = __get_dma_pgprot(attrs, pgprot_kernel);\n \tvoid *memory;\n \n \tif (dma_alloc_from_coherent(dev, size, handle, &memory))\n\t\treturn memory;\n\n\treturn __dma_alloc(dev, size, handle, gfp, prot, false,\n\t\t\t   __builtin_return_address(0));\n}\n", "target": 1, "idx": 180750}
{"func": "SMB2_logoff(const unsigned int xid, struct cifs_ses *ses)\n{\n\tstruct smb2_logoff_req *req; /* response is also trivial struct */\n\tint rc = 0;\n\tstruct TCP_Server_Info *server;\n\n\tcifs_dbg(FYI, \"disconnect session %p\\n\", ses);\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\t/* no need to send SMB logoff if uid already closed due to reconnect */\n\tif (ses->need_reconnect)\n\t\tgoto smb2_session_already_dead;\n\n\trc = small_smb2_init(SMB2_LOGOFF, NULL, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\t /* since no tcon, smb2_init can not do this, so do here */\n\treq->hdr.SessionId = ses->Suid;\n\tif (server->sign)\n\t\treq->hdr.Flags |= SMB2_FLAGS_SIGNED;\n\n\trc = SendReceiveNoRsp(xid, ses, (char *) &req->hdr, 0);\n\t/*\n\t * No tcon so can't do\n\t * cifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_fail[SMB2...]);\n\t */\n\nsmb2_session_already_dead:\n\treturn rc;\n}\n", "target": 0, "idx": 35977}
{"func": " virtual void unsetHeap(int32_t seqNum) {\n Parcel data, reply;\n        data.writeInterfaceToken(ICrypto::getInterfaceDescriptor());\n        data.writeInt32(seqNum);\n        remote()->transact(UNSET_HEAP, data, &reply);\n return;\n }\n", "target": 0, "idx": 176098}
{"func": " static void toggle_fpga_eeprom_bus(bool cpu_own)\n {\n\tqrio_gpio_direction_output(GPIO_A, PROM_SEL_L, !cpu_own);\n }\n", "target": 1, "idx": 182806}
{"func": "unsigned long long task_sched_runtime(struct task_struct *p)\n{\n\tunsigned long flags;\n\tstruct rq *rq;\n\tu64 ns = 0;\n\n\trq = task_rq_lock(p, &flags);\n\tns = p->se.sum_exec_runtime + do_task_delta_exec(p, rq);\n\ttask_rq_unlock(rq, p, &flags);\n\n\treturn ns;\n}\n", "target": 0, "idx": 26354}
{"func": "static ZIPARCHIVE_METHOD(open)\n{\n\tstruct zip *intern;\n\tchar *filename;\n\tint filename_len;\n\tint err = 0;\n\tlong flags = 0;\n\tchar resolved_path[MAXPATHLEN];\n\n\tzval *this = getThis();\n\tze_zip_object *ze_obj = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p|l\", &filename, &filename_len, &flags) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (this) {\n\t\t/* We do not use ZIP_FROM_OBJECT, zip init function here */\n\t\tze_obj = (ze_zip_object*) zend_object_store_get_object(this TSRMLS_CC);\n\t}\n\n\tif (filename_len == 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Empty string as source\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (ZIP_OPENBASEDIR_CHECKPATH(filename)) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (!expand_filepath(filename, resolved_path TSRMLS_CC)) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (ze_obj->za) {\n\t\t/* we already have an opened zip, free it */\n\t\tif (zip_close(ze_obj->za) != 0) {\n\t\t\t_zip_free(ze_obj->za);\n\t\t}\n\t\tze_obj->za = NULL;\n\t}\n\tif (ze_obj->filename) {\n\t\tefree(ze_obj->filename);\n\t\tze_obj->filename = NULL;\n\t}\n\n\tintern = zip_open(resolved_path, flags, &err);\n\tif (!intern || err) {\n\t\tRETURN_LONG((long)err);\n\t}\n\tze_obj->filename = estrdup(resolved_path);\n\tze_obj->filename_len = strlen(resolved_path);\n\tze_obj->za = intern;\n\tRETURN_TRUE;\n}\n", "target": 0, "idx": 51257}
{"func": " void GpuVideoDecodeAccelerator::Initialize(\n     const media::VideoCodecProfile profile,\n    IPC::Message* init_done_msg,\n    base::ProcessHandle renderer_process) {\n   DCHECK(!video_decode_accelerator_.get());\n   DCHECK(!init_done_msg_);\n   DCHECK(init_done_msg);\n  init_done_msg_ = init_done_msg;\n\n#if (defined(OS_CHROMEOS) && defined(ARCH_CPU_ARMEL)) || defined(OS_WIN)\n  DCHECK(stub_ && stub_->decoder());\n#if defined(OS_WIN)\n  if (base::win::GetVersion() < base::win::VERSION_WIN7) {\n    NOTIMPLEMENTED() << \"HW video decode acceleration not available.\";\n    NotifyError(media::VideoDecodeAccelerator::PLATFORM_FAILURE);\n    return;\n   }\n   DLOG(INFO) << \"Initializing DXVA HW decoder for windows.\";\n   DXVAVideoDecodeAccelerator* video_decoder =\n      new DXVAVideoDecodeAccelerator(this, renderer_process);\n #else  // OS_WIN\n   OmxVideoDecodeAccelerator* video_decoder =\n       new OmxVideoDecodeAccelerator(this);\n  video_decoder->SetEglState(\n      gfx::GLSurfaceEGL::GetHardwareDisplay(),\n      stub_->decoder()->GetGLContext()->GetHandle());\n#endif  // OS_WIN\n  video_decode_accelerator_ = video_decoder;\n  if (!video_decode_accelerator_->Initialize(profile))\n    NotifyError(media::VideoDecodeAccelerator::PLATFORM_FAILURE);\n#else  // Update RenderViewImpl::createMediaPlayer when adding clauses.\n  NOTIMPLEMENTED() << \"HW video decode acceleration not available.\";\n  NotifyError(media::VideoDecodeAccelerator::PLATFORM_FAILURE);\n#endif  // defined(OS_CHROMEOS) && defined(ARCH_CPU_ARMEL)\n}\n", "target": 1, "idx": 184569}
{"func": "GF_Err nmhd_Write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_full_box_write(s, bs);\n}\n", "target": 0, "idx": 80290}
{"func": " void TextTrack::addCue(TextTrackCue* cue) {\n   DCHECK(cue);\n \n  if (std::isnan(cue->startTime()) || std::isnan(cue->endTime()) ||\n      cue->startTime() < 0 || cue->endTime() < 0)\n     return;\n \n\n\n\n  if (TextTrack* cue_track = cue->track())\n    cue_track->removeCue(cue, ASSERT_NO_EXCEPTION);\n\n  cue->SetTrack(this);\n  EnsureTextTrackCueList()->Add(cue);\n\n  if (GetCueTimeline() && mode_ != DisabledKeyword())\n    GetCueTimeline()->AddCue(this, cue);\n}\n", "target": 1, "idx": 185645}
{"func": "static int sctp_send_asconf_del_ip(struct sock\t\t*sk,\n\t\t\t\t   struct sockaddr\t*addrs,\n\t\t\t\t   int\t\t\taddrcnt)\n{\n\tstruct sctp_sock\t*sp;\n\tstruct sctp_endpoint\t*ep;\n\tstruct sctp_association\t*asoc;\n\tstruct sctp_transport\t*transport;\n\tstruct sctp_bind_addr\t*bp;\n\tstruct sctp_chunk\t*chunk;\n\tunion sctp_addr\t\t*laddr;\n\tvoid\t\t\t*addr_buf;\n\tstruct sctp_af\t\t*af;\n\tstruct list_head\t*pos, *pos1;\n\tstruct sctp_sockaddr_entry *saddr;\n\tint \t\t\ti;\n\tint \t\t\tretval = 0;\n\n\tif (!sctp_addip_enable)\n\t\treturn retval;\n\n\tsp = sctp_sk(sk);\n\tep = sp->ep;\n\n\tSCTP_DEBUG_PRINTK(\"%s: (sk: %p, addrs: %p, addrcnt: %d)\\n\",\n\t\t\t  __FUNCTION__, sk, addrs, addrcnt);\n\n\tlist_for_each(pos, &ep->asocs) {\n\t\tasoc = list_entry(pos, struct sctp_association, asocs);\n\n\t\tif (!asoc->peer.asconf_capable)\n\t\t\tcontinue;\n\n\t\tif (asoc->peer.addip_disabled_mask & SCTP_PARAM_DEL_IP)\n\t\t\tcontinue;\n\n\t\tif (!sctp_state(asoc, ESTABLISHED))\n\t\t\tcontinue;\n\n\t\t/* Check if any address in the packed array of addresses is\n\t\t * not present in the bind address list of the association.\n\t\t * If so, do not send the asconf chunk to its peer, but\n\t\t * continue with other associations.\n\t\t */\n\t\taddr_buf = addrs;\n\t\tfor (i = 0; i < addrcnt; i++) {\n\t\t\tladdr = (union sctp_addr *)addr_buf;\n\t\t\taf = sctp_get_af_specific(laddr->v4.sin_family);\n\t\t\tif (!af) {\n\t\t\t\tretval = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (!sctp_assoc_lookup_laddr(asoc, laddr))\n\t\t\t\tbreak;\n\n\t\t\taddr_buf += af->sockaddr_len;\n\t\t}\n\t\tif (i < addrcnt)\n\t\t\tcontinue;\n\n\t\t/* Find one address in the association's bind address list\n\t\t * that is not in the packed array of addresses. This is to\n\t\t * make sure that we do not delete all the addresses in the\n\t\t * association.\n\t\t */\n\t\tsctp_read_lock(&asoc->base.addr_lock);\n\t\tbp = &asoc->base.bind_addr;\n\t\tladdr = sctp_find_unmatch_addr(bp, (union sctp_addr *)addrs,\n\t\t\t\t\t       addrcnt, sp);\n\t\tsctp_read_unlock(&asoc->base.addr_lock);\n\t\tif (!laddr)\n\t\t\tcontinue;\n\n\t\tchunk = sctp_make_asconf_update_ip(asoc, laddr, addrs, addrcnt,\n\t\t\t\t\t\t   SCTP_PARAM_DEL_IP);\n\t\tif (!chunk) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Reset use_as_src flag for the addresses in the bind address\n\t\t * list that are to be deleted.\n\t\t */\n\t\tsctp_local_bh_disable();\n\t\tsctp_write_lock(&asoc->base.addr_lock);\n\t\taddr_buf = addrs;\n\t\tfor (i = 0; i < addrcnt; i++) {\n\t\t\tladdr = (union sctp_addr *)addr_buf;\n\t\t\taf = sctp_get_af_specific(laddr->v4.sin_family);\n\t\t\tlist_for_each(pos1, &bp->address_list) {\n\t\t\t\tsaddr = list_entry(pos1,\n\t\t\t\t\t\t   struct sctp_sockaddr_entry,\n\t\t\t\t\t\t   list);\n\t\t\t\tif (sctp_cmp_addr_exact(&saddr->a, laddr))\n\t\t\t\t\tsaddr->use_as_src = 0;\n\t\t\t}\n\t\t\taddr_buf += af->sockaddr_len;\n\t\t}\n\t\tsctp_write_unlock(&asoc->base.addr_lock);\n\t\tsctp_local_bh_enable();\n\n\t\t/* Update the route and saddr entries for all the transports\n\t\t * as some of the addresses in the bind address list are\n\t\t * about to be deleted and cannot be used as source addresses.\n\t\t */\n\t\tlist_for_each(pos1, &asoc->peer.transport_addr_list) {\n\t\t\ttransport = list_entry(pos1, struct sctp_transport,\n\t\t\t\t\t       transports);\n\t\t\tdst_release(transport->dst);\n\t\t\tsctp_transport_route(transport, NULL,\n\t\t\t\t\t     sctp_sk(asoc->base.sk));\n\t\t}\n\n\t\tretval = sctp_send_asconf(asoc, chunk);\n\t}\nout:\n\treturn retval;\n}\n", "target": 0, "idx": 35034}
{"func": " GURL GetURLFromCookiePair(\n    const net::CookieMonster::CookieListPair& cookie_pair) {\n  const std::string& domain_key = cookie_pair.first;\n  const net::CookieMonster::CanonicalCookie& cookie = cookie_pair.second;\n  const std::string scheme =\n      cookie.IsSecure() ? chrome::kHttpsScheme : chrome::kHttpScheme;\n  const std::string host =\n      domain_key.find('.') != 0 ? domain_key : domain_key.substr(1);\n  return GURL(scheme + chrome::kStandardSchemeSeparator + host + \"/\");\n}\n", "target": 0, "idx": 98833}
{"func": "jp2_box_t *jp2_box_get(jas_stream_t *in)\n{\n\tjp2_box_t *box;\n\tjp2_boxinfo_t *boxinfo;\n\tjas_stream_t *tmpstream;\n\tuint_fast32_t len;\n\tuint_fast64_t extlen;\n\tbool dataflag;\n\n\tbox = 0;\n\ttmpstream = 0;\n\n \tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n \t\tgoto error;\n \t}\n \tbox->ops = &jp2_boxinfo_unk.ops;\n \tif (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {\n \t\tgoto error;\n \t}\n \tboxinfo = jp2_boxinfolookup(box->type);\n \tbox->info = boxinfo;\n\tbox->ops = &boxinfo->ops;\n \tbox->len = len;\n \tJAS_DBGLOG(10, (\n \t  \"preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\\n\",\n\t  '\"', boxinfo->name, '\"', box->type, box->len\n\t  ));\n\tif (box->len == 1) {\n\t\tif (jp2_getuint64(in, &extlen)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (extlen > 0xffffffffUL) {\n\t\t\tjas_eprintf(\"warning: cannot handle large 64-bit box length\\n\");\n\t\t\textlen = 0xffffffffUL;\n\t\t}\n\t\tbox->len = extlen;\n\t\tbox->datalen = extlen - JP2_BOX_HDRLEN(true);\n\t} else {\n\t\tbox->datalen = box->len - JP2_BOX_HDRLEN(false);\n\t}\n\tif (box->len != 0 && box->len < 8) {\n\t\tgoto error;\n\t}\n\n\tdataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));\n\n\tif (dataflag) {\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n \t\t\tgoto error;\n \t\t}\n \t\tif (jas_stream_copy(tmpstream, in, box->datalen)) {\n\t\t\tbox->ops = &jp2_boxinfo_unk.ops;\n \t\t\tjas_eprintf(\"cannot copy box data\\n\");\n \t\t\tgoto error;\n \t\t}\n \t\tjas_stream_rewind(tmpstream);\n \n \t\tif (box->ops->getdata) {\n \t\t\tif ((*box->ops->getdata)(box, tmpstream)) {\n \t\t\t\tjas_eprintf(\"cannot parse box data\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tjas_stream_close(tmpstream);\n\t}\n\n\tif (jas_getdbglevel() >= 1) {\n\t\tjp2_box_dump(box, stderr);\n\t}\n\n\treturn box;\n\nerror:\n\tif (box) {\n\t\tjp2_box_destroy(box);\n\t}\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn 0;\n}\n", "target": 1, "idx": 181645}
{"func": "static int read_int32_info (WavpackStream *wps, WavpackMetadata *wpmd)\n{\n    int bytecnt = wpmd->byte_length;\n    char *byteptr = (char *)wpmd->data;\n\n    if (bytecnt != 4)\n        return FALSE;\n\n    wps->int32_sent_bits = *byteptr++;\n    wps->int32_zeros = *byteptr++;\n    wps->int32_ones = *byteptr++;\n    wps->int32_dups = *byteptr;\n\n    return TRUE;\n}\n", "target": 0, "idx": 75630}
{"func": "asmlinkage void do_sparc_fault(struct pt_regs *regs, int text_fault, int write,\n\t\t\t       unsigned long address)\n{\n\tstruct vm_area_struct *vma;\n\tstruct task_struct *tsk = current;\n\tstruct mm_struct *mm = tsk->mm;\n\tunsigned int fixup;\n\tunsigned long g2;\n\tint from_user = !(regs->psr & PSR_PS);\n\tint fault, code;\n\n\tif(text_fault)\n\t\taddress = regs->pc;\n\n\t/*\n\t * We fault-in kernel-space virtual memory on-demand. The\n\t * 'reference' page table is init_mm.pgd.\n\t *\n\t * NOTE! We MUST NOT take any locks for this case. We may\n\t * be in an interrupt or a critical region, and should\n\t * only copy the information from the master page table,\n\t * nothing more.\n\t */\n\tcode = SEGV_MAPERR;\n\tif (!ARCH_SUN4C && address >= TASK_SIZE)\n\t\tgoto vmalloc_fault;\n\n\t/*\n\t * If we're in an interrupt or have no user\n\t * context, we must not take the fault..\n\t */\n         if (in_atomic() || !mm)\n                 goto no_context;\n \n\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, 0, regs, address);\n \n \tdown_read(&mm->mmap_sem);\n \n\t/*\n\t * The kernel referencing a bad kernel pointer can lock up\n\t * a sun4c machine completely, so we must attempt recovery.\n\t */\n\tif(!from_user && address >= PAGE_OFFSET)\n\t\tgoto bad_area;\n\n\tvma = find_vma(mm, address);\n\tif(!vma)\n\t\tgoto bad_area;\n\tif(vma->vm_start <= address)\n\t\tgoto good_area;\n\tif(!(vma->vm_flags & VM_GROWSDOWN))\n\t\tgoto bad_area;\n\tif(expand_stack(vma, address))\n\t\tgoto bad_area;\n\t/*\n\t * Ok, we have a good vm_area for this memory access, so\n\t * we can handle it..\n\t */\ngood_area:\n\tcode = SEGV_ACCERR;\n\tif(write) {\n\t\tif(!(vma->vm_flags & VM_WRITE))\n\t\t\tgoto bad_area;\n\t} else {\n\t\t/* Allow reads even for write-only mappings */\n\t\tif(!(vma->vm_flags & (VM_READ | VM_EXEC)))\n\t\t\tgoto bad_area;\n\t}\n\n\t/*\n\t * If for any reason at all we couldn't handle the fault,\n\t * make sure we exit gracefully rather than endlessly redo\n\t * the fault.\n\t */\n\tfault = handle_mm_fault(mm, vma, address, write ? FAULT_FLAG_WRITE : 0);\n\tif (unlikely(fault & VM_FAULT_ERROR)) {\n\t\tif (fault & VM_FAULT_OOM)\n\t\t\tgoto out_of_memory;\n\t\telse if (fault & VM_FAULT_SIGBUS)\n\t\t\tgoto do_sigbus;\n\t\tBUG();\n \t}\n \tif (fault & VM_FAULT_MAJOR) {\n \t\tcurrent->maj_flt++;\n\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, 0,\n\t\t\t      regs, address);\n \t} else {\n \t\tcurrent->min_flt++;\n\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, 0,\n\t\t\t      regs, address);\n \t}\n \tup_read(&mm->mmap_sem);\n \treturn;\n\n\t/*\n\t * Something tried to access memory that isn't in our memory map..\n\t * Fix it, but check if it's kernel or user first..\n\t */\nbad_area:\n\tup_read(&mm->mmap_sem);\n\nbad_area_nosemaphore:\n\t/* User mode accesses just cause a SIGSEGV */\n\tif (from_user) {\n\t\tdo_fault_siginfo(code, SIGSEGV, regs, text_fault);\n\t\treturn;\n\t}\n\n\t/* Is this in ex_table? */\nno_context:\n\tg2 = regs->u_regs[UREG_G2];\n\tif (!from_user) {\n\t\tfixup = search_extables_range(regs->pc, &g2);\n\t\tif (fixup > 10) { /* Values below are reserved for other things */\n\t\t\textern const unsigned __memset_start[];\n\t\t\textern const unsigned __memset_end[];\n\t\t\textern const unsigned __csum_partial_copy_start[];\n\t\t\textern const unsigned __csum_partial_copy_end[];\n\n#ifdef DEBUG_EXCEPTIONS\n\t\t\tprintk(\"Exception: PC<%08lx> faddr<%08lx>\\n\", regs->pc, address);\n\t\t\tprintk(\"EX_TABLE: insn<%08lx> fixup<%08x> g2<%08lx>\\n\",\n\t\t\t\tregs->pc, fixup, g2);\n#endif\n\t\t\tif ((regs->pc >= (unsigned long)__memset_start &&\n\t\t\t     regs->pc < (unsigned long)__memset_end) ||\n\t\t\t    (regs->pc >= (unsigned long)__csum_partial_copy_start &&\n\t\t\t     regs->pc < (unsigned long)__csum_partial_copy_end)) {\n\t\t\t        regs->u_regs[UREG_I4] = address;\n\t\t\t\tregs->u_regs[UREG_I5] = regs->pc;\n\t\t\t}\n\t\t\tregs->u_regs[UREG_G2] = g2;\n\t\t\tregs->pc = fixup;\n\t\t\tregs->npc = regs->pc + 4;\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tunhandled_fault (address, tsk, regs);\n\tdo_exit(SIGKILL);\n\n/*\n * We ran out of memory, or some other thing happened to us that made\n * us unable to handle the page fault gracefully.\n */\nout_of_memory:\n\tup_read(&mm->mmap_sem);\n\tif (from_user) {\n\t\tpagefault_out_of_memory();\n\t\treturn;\n\t}\n\tgoto no_context;\n\ndo_sigbus:\n\tup_read(&mm->mmap_sem);\n\tdo_fault_siginfo(BUS_ADRERR, SIGBUS, regs, text_fault);\n\tif (!from_user)\n\t\tgoto no_context;\n\nvmalloc_fault:\n\t{\n\t\t/*\n\t\t * Synchronize this task's top level page-table\n\t\t * with the 'reference' page table.\n\t\t */\n\t\tint offset = pgd_index(address);\n\t\tpgd_t *pgd, *pgd_k;\n\t\tpmd_t *pmd, *pmd_k;\n\n\t\tpgd = tsk->active_mm->pgd + offset;\n\t\tpgd_k = init_mm.pgd + offset;\n\n\t\tif (!pgd_present(*pgd)) {\n\t\t\tif (!pgd_present(*pgd_k))\n\t\t\t\tgoto bad_area_nosemaphore;\n\t\t\tpgd_val(*pgd) = pgd_val(*pgd_k);\n\t\t\treturn;\n\t\t}\n\n\t\tpmd = pmd_offset(pgd, address);\n\t\tpmd_k = pmd_offset(pgd_k, address);\n\n\t\tif (pmd_present(*pmd) || !pmd_present(*pmd_k))\n\t\t\tgoto bad_area_nosemaphore;\n\t\t*pmd = *pmd_k;\n\t\treturn;\n\t}\n}\n", "target": 1, "idx": 178988}
{"func": " long ssl_get_algorithm2(SSL *s)\n        {\n        long alg2 = s->s3->tmp.new_cipher->algorithm2;\n       if (TLS1_get_version(s) >= TLS1_2_VERSION &&\n            alg2 == (SSL_HANDSHAKE_MAC_DEFAULT|TLS1_PRF))\n                return SSL_HANDSHAKE_MAC_SHA256 | TLS1_PRF_SHA256;\n        return alg2;\n\t}\n", "target": 1, "idx": 177739}
{"func": "static void php_wddx_process_data(void *user_data, const XML_Char *s, int len)\n{\n\tst_entry *ent;\n\twddx_stack *stack = (wddx_stack *)user_data;\n\tTSRMLS_FETCH();\n\n\tif (!wddx_stack_is_empty(stack) && !stack->done) {\n\t\twddx_stack_top(stack, (void**)&ent);\n\t\tswitch (ent->type) {\n\t\t\tcase ST_STRING:\n\t\t\t\tif (Z_STRLEN_P(ent->data) == 0) {\n\t\t\t\t\tSTR_FREE(Z_STRVAL_P(ent->data));\n\t\t\t\t\tZ_STRVAL_P(ent->data) = estrndup(s, len);\n\t\t\t\t\tZ_STRLEN_P(ent->data) = len;\n\t\t\t\t} else {\n\t\t\t\t\tZ_STRVAL_P(ent->data) = erealloc(Z_STRVAL_P(ent->data), Z_STRLEN_P(ent->data) + len + 1);\n\t\t\t\t\tmemcpy(Z_STRVAL_P(ent->data) + Z_STRLEN_P(ent->data), s, len);\n\t\t\t\t\tZ_STRLEN_P(ent->data) += len;\n\t\t\t\t\tZ_STRVAL_P(ent->data)[Z_STRLEN_P(ent->data)] = '\\0';\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase ST_BINARY:\n\t\t\t\tif (Z_STRLEN_P(ent->data) == 0) {\n\t\t\t\t\tSTR_FREE(Z_STRVAL_P(ent->data));\n\t\t\t\t\tZ_STRVAL_P(ent->data) = estrndup(s, len + 1);\n\t\t\t\t} else {\n\t\t\t\t\tZ_STRVAL_P(ent->data) = erealloc(Z_STRVAL_P(ent->data), Z_STRLEN_P(ent->data) + len + 1);\n\t\t\t\t\tmemcpy(Z_STRVAL_P(ent->data) + Z_STRLEN_P(ent->data), s, len);\n\t\t\t\t}\n\t\t\t\tZ_STRLEN_P(ent->data) += len;\n\t\t\t\tZ_STRVAL_P(ent->data)[Z_STRLEN_P(ent->data)] = '\\0';\n\t\t\t\tbreak;\n\n\t\t\tcase ST_NUMBER:\n\t\t\t\tZ_TYPE_P(ent->data) = IS_STRING;\n\t\t\t\tZ_STRLEN_P(ent->data) = len;\n\t\t\t\tZ_STRVAL_P(ent->data) = estrndup(s, len);\n\t\t\t\tconvert_scalar_to_number(ent->data TSRMLS_CC);\n\t\t\t\tbreak;\n\n\t\t\tcase ST_BOOLEAN:\n\t\t\t\tif(!ent->data) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!strcmp(s, \"true\")) {\n\t\t\t\t\tZ_LVAL_P(ent->data) = 1;\n\t\t\t\t} else if (!strcmp(s, \"false\")) {\n\t\t\t\t\tZ_LVAL_P(ent->data) = 0;\n\t\t\t\t} else {\n\t\t\t\t\tzval_ptr_dtor(&ent->data);\n\t\t\t\t\tif (ent->varname) {\n\t\t\t\t\t\tefree(ent->varname);\n\t\t\t\t\t\tent->varname = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tent->data = NULL;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n \t\t\tcase ST_DATETIME: {\n \t\t\t\tchar *tmp;\n \n\t\t\t\ttmp = emalloc(len + 1);\n\t\t\t\tmemcpy(tmp, s, len);\n \t\t\t\ttmp[len] = '\\0';\n \n \t\t\t\tZ_LVAL_P(ent->data) = php_parse_date(tmp, NULL);\n \t\t\t\t/* date out of range < 1969 or > 2038 */\n \t\t\t\tif (Z_LVAL_P(ent->data) == -1) {\n\t\t\t\t\tZ_TYPE_P(ent->data) = IS_STRING;\n\t\t\t\t\tZ_STRLEN_P(ent->data) = len;\n\t\t\t\t\tZ_STRVAL_P(ent->data) = estrndup(s, len);\n \t\t\t\t}\n\t\t\t\tefree(tmp);\n \t\t\t}\n \t\t\t\tbreak;\n \n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n", "target": 1, "idx": 180123}
{"func": "static void DumpStackTraceSignalHandler(int signal) {\n  base::debug::StackTrace().PrintBacktrace();\n  _exit(128 + signal);\n}\n", "target": 0, "idx": 117683}
{"func": "  write_message( RenderState  state )\n  {\n    ADisplay  adisplay = (ADisplay)state->display.disp;\n\n\n    if ( state->message == NULL )\n    {\n      FontFace  face = &state->faces[state->face_index];\n      int       idx, total;\n\n\n      idx   = face->index;\n      total = 1;\n      while ( total + state->face_index < state->num_faces &&\n              face[total].filepath == face[0].filepath     )\n        total++;\n\n      total += idx;\n \n       state->message = state->message0;\n       if ( total > 1 )\n        sprintf( state->message0, \"%s %d/%d @ %5.1fpt\",\n                  state->filename, idx + 1, total,\n                  state->char_size );\n       else\n        sprintf( state->message0, \"%s @ %5.1fpt\",\n                  state->filename,\n                  state->char_size );\n     }\n\n    grWriteCellString( adisplay->bitmap, 0, DIM_Y - 10, state->message,\n                       adisplay->fore_color );\n\n    state->message = NULL;\n  }\n", "target": 1, "idx": 178169}
{"func": " int kvm_iommu_map_pages(struct kvm *kvm, struct kvm_memory_slot *slot)\n {\n \tgfn_t gfn, end_gfn;\n\tpfn_t pfn;\n\tint r = 0;\n\tstruct iommu_domain *domain = kvm->arch.iommu_domain;\n\tint flags;\n\n\t/* check if iommu exists and in use */\n\tif (!domain)\n\t\treturn 0;\n\n\tgfn     = slot->base_gfn;\n\tend_gfn = gfn + slot->npages;\n\n\tflags = IOMMU_READ;\n\tif (!(slot->flags & KVM_MEM_READONLY))\n\t\tflags |= IOMMU_WRITE;\n\tif (!kvm->arch.iommu_noncoherent)\n\t\tflags |= IOMMU_CACHE;\n\n\n\twhile (gfn < end_gfn) {\n\t\tunsigned long page_size;\n\n\t\t/* Check if already mapped */\n\t\tif (iommu_iova_to_phys(domain, gfn_to_gpa(gfn))) {\n\t\t\tgfn += 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Get the page size we could use to map */\n\t\tpage_size = kvm_host_page_size(kvm, gfn);\n\n\t\t/* Make sure the page_size does not exceed the memslot */\n\t\twhile ((gfn + (page_size >> PAGE_SHIFT)) > end_gfn)\n\t\t\tpage_size >>= 1;\n\n\t\t/* Make sure gfn is aligned to the page size we want to map */\n\t\twhile ((gfn << PAGE_SHIFT) & (page_size - 1))\n\t\t\tpage_size >>= 1;\n\n\t\t/* Make sure hva is aligned to the page size we want to map */\n\t\twhile (__gfn_to_hva_memslot(slot, gfn) & (page_size - 1))\n\t\t\tpage_size >>= 1;\n\n\t\t/*\n\t\t * Pin all pages we are about to map in memory. This is\n\t\t * important because we unmap and unpin in 4kb steps later.\n\t\t */\n\t\tpfn = kvm_pin_pages(slot, gfn, page_size);\n\t\tif (is_error_noslot_pfn(pfn)) {\n\t\t\tgfn += 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Map into IO address space */\n\t\tr = iommu_map(domain, gfn_to_gpa(gfn), pfn_to_hpa(pfn),\n\t\t\t      page_size, flags);\n \t\tif (r) {\n \t\t\tprintk(KERN_ERR \"kvm_iommu_map_address:\"\n \t\t\t       \"iommu failed to map pfn=%llx\\n\", pfn);\n \t\t\tgoto unmap_pages;\n \t\t}\n \n\t\tgfn += page_size >> PAGE_SHIFT;\n\n\n\t}\n\n \treturn 0;\n \n unmap_pages:\n\tkvm_iommu_put_pages(kvm, slot->base_gfn, gfn);\n \treturn r;\n }\n", "target": 1, "idx": 179523}
{"func": "void SoftMPEG4Encoder::initPorts() {\n    OMX_PARAM_PORTDEFINITIONTYPE def;\n InitOMXParams(&def);\n\n const size_t kInputBufferSize = (mVideoWidth * mVideoHeight * 3) >> 1;\n\n const size_t kOutputBufferSize =\n (kInputBufferSize > 256 * 1024)\n ? kInputBufferSize: 256 * 1024;\n\n    def.nPortIndex = 0;\n    def.eDir = OMX_DirInput;\n    def.nBufferCountMin = kNumBuffers;\n    def.nBufferCountActual = def.nBufferCountMin;\n    def.nBufferSize = kInputBufferSize;\n    def.bEnabled = OMX_TRUE;\n    def.bPopulated = OMX_FALSE;\n    def.eDomain = OMX_PortDomainVideo;\n    def.bBuffersContiguous = OMX_FALSE;\n    def.nBufferAlignment = 1;\n\n    def.format.video.cMIMEType = const_cast<char *>(\"video/raw\");\n\n    def.format.video.eCompressionFormat = OMX_VIDEO_CodingUnused;\n    def.format.video.eColorFormat = OMX_COLOR_FormatYUV420Planar;\n    def.format.video.xFramerate = (mVideoFrameRate << 16); // Q16 format\n    def.format.video.nBitrate = mVideoBitRate;\n    def.format.video.nFrameWidth = mVideoWidth;\n    def.format.video.nFrameHeight = mVideoHeight;\n    def.format.video.nStride = mVideoWidth;\n    def.format.video.nSliceHeight = mVideoHeight;\n\n    addPort(def);\n\n    def.nPortIndex = 1;\n    def.eDir = OMX_DirOutput;\n    def.nBufferCountMin = kNumBuffers;\n    def.nBufferCountActual = def.nBufferCountMin;\n    def.nBufferSize = kOutputBufferSize;\n    def.bEnabled = OMX_TRUE;\n    def.bPopulated = OMX_FALSE;\n    def.eDomain = OMX_PortDomainVideo;\n    def.bBuffersContiguous = OMX_FALSE;\n    def.nBufferAlignment = 2;\n\n    def.format.video.cMIMEType =\n (mEncodeMode == COMBINE_MODE_WITH_ERR_RES)\n ? const_cast<char *>(MEDIA_MIMETYPE_VIDEO_MPEG4)\n : const_cast<char *>(MEDIA_MIMETYPE_VIDEO_H263);\n\n    def.format.video.eCompressionFormat =\n (mEncodeMode == COMBINE_MODE_WITH_ERR_RES)\n ? OMX_VIDEO_CodingMPEG4\n : OMX_VIDEO_CodingH263;\n\n    def.format.video.eColorFormat = OMX_COLOR_FormatUnused;\n    def.format.video.xFramerate = (0 << 16); // Q16 format\n    def.format.video.nBitrate = mVideoBitRate;\n    def.format.video.nFrameWidth = mVideoWidth;\n    def.format.video.nFrameHeight = mVideoHeight;\n    def.format.video.nStride = mVideoWidth;\n    def.format.video.nSliceHeight = mVideoHeight;\n\n    addPort(def);\n}\n", "target": 0, "idx": 175653}
{"func": "tTcpIpPacketParsingResult ParaNdis_CheckSumVerify(\n                                                tCompletePhysicalAddress *pDataPages,\n                                                ULONG ulDataLength,\n                                                ULONG ulStartOffset,\n                                                ULONG flags,\n                                                LPCSTR caller)\n{\n     IPHeader *pIpHeader = (IPHeader *) RtlOffsetToPointer(pDataPages[0].Virtual, ulStartOffset);\n \n     tTcpIpPacketParsingResult res = QualifyIpPacket(pIpHeader, ulDataLength);\n     if (res.ipStatus == ppresIPV4)\n     {\n         if (flags & pcrIpChecksum)\n            res = VerifyIpChecksum(&pIpHeader->v4, res, (flags & pcrFixIPChecksum) != 0);\n        if(res.xxpStatus == ppresXxpKnown)\n        {\n            if (res.TcpUdp == ppresIsTCP) /* TCP */\n            {\n                if(flags & pcrTcpV4Checksum)\n                {\n                    res = VerifyTcpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixTcpV4Checksum));\n                }\n            }\n            else /* UDP */\n            {\n                if (flags & pcrUdpV4Checksum)\n                {\n                    res = VerifyUdpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixUdpV4Checksum));\n                }\n            }\n        }\n    }\n    else if (res.ipStatus == ppresIPV6)\n    {\n        if(res.xxpStatus == ppresXxpKnown)\n        {\n            if (res.TcpUdp == ppresIsTCP) /* TCP */\n            {\n                if(flags & pcrTcpV6Checksum)\n                {\n                    res = VerifyTcpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixTcpV6Checksum));\n                }\n            }\n            else /* UDP */\n            {\n                if (flags & pcrUdpV6Checksum)\n                {\n                    res = VerifyUdpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixUdpV6Checksum));\n                }\n            }\n        }\n    }\n    PrintOutParsingResult(res, 1, caller);\n    return res;\n}\n", "target": 1, "idx": 182060}
{"func": "static ssize_t ib_ucm_send_rep(struct ib_ucm_file *file,\n\t\t\t       const char __user *inbuf,\n\t\t\t       int in_len, int out_len)\n{\n\tstruct ib_cm_rep_param param;\n\tstruct ib_ucm_context *ctx;\n\tstruct ib_ucm_rep cmd;\n\tint result;\n\n\tparam.private_data = NULL;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tresult = ib_ucm_alloc_data(&param.private_data, cmd.data, cmd.len);\n\tif (result)\n\t\treturn result;\n\n\tparam.qp_num              = cmd.qpn;\n\tparam.starting_psn        = cmd.psn;\n\tparam.private_data_len    = cmd.len;\n\tparam.responder_resources = cmd.responder_resources;\n\tparam.initiator_depth     = cmd.initiator_depth;\n\tparam.failover_accepted   = cmd.failover_accepted;\n\tparam.flow_control        = cmd.flow_control;\n\tparam.rnr_retry_count     = cmd.rnr_retry_count;\n\tparam.srq                 = cmd.srq;\n\n\tctx = ib_ucm_ctx_get(file, cmd.id);\n\tif (!IS_ERR(ctx)) {\n\t\tctx->uid = cmd.uid;\n\t\tresult = ib_send_cm_rep(ctx->cm_id, &param);\n\t\tib_ucm_ctx_put(ctx);\n\t} else\n\t\tresult = PTR_ERR(ctx);\n\n\tkfree(param.private_data);\n\treturn result;\n}\n", "target": 0, "idx": 52815}
{"func": "  LocalSiteCharacteristicsWebContentsObserver* observer() {\n    return observer_.get();\n   }\n", "target": 0, "idx": 144771}
{"func": "static int read_request_line(request_rec *r, apr_bucket_brigade *bb)\n{\n    const char *ll;\n    const char *uri;\n    const char *pro;\n\n    unsigned int major = 1, minor = 0;   /* Assume HTTP/1.0 if non-\"HTTP\" protocol */\n    char http[5];\n    apr_size_t len;\n    int num_blank_lines = 0;\n    int max_blank_lines = r->server->limit_req_fields;\n    core_server_config *conf = ap_get_core_module_config(r->server->module_config);\n    int strict = conf->http_conformance & AP_HTTP_CONFORMANCE_STRICT;\n    int enforce_strict = !(conf->http_conformance & AP_HTTP_CONFORMANCE_LOGONLY);\n\n    if (max_blank_lines <= 0) {\n        max_blank_lines = DEFAULT_LIMIT_REQUEST_FIELDS;\n    }\n\n    /* Read past empty lines until we get a real request line,\n     * a read error, the connection closes (EOF), or we timeout.\n     *\n     * We skip empty lines because browsers have to tack a CRLF on to the end\n     * of POSTs to support old CERN webservers.  But note that we may not\n     * have flushed any previous response completely to the client yet.\n     * We delay the flush as long as possible so that we can improve\n     * performance for clients that are pipelining requests.  If a request\n     * is pipelined then we won't block during the (implicit) read() below.\n     * If the requests aren't pipelined, then the client is still waiting\n     * for the final buffer flush from us, and we will block in the implicit\n     * read().  B_SAFEREAD ensures that the BUFF layer flushes if it will\n     * have to block during a read.\n     */\n\n    do {\n        apr_status_t rv;\n\n        /* ensure ap_rgetline allocates memory each time thru the loop\n         * if there are empty lines\n         */\n        r->the_request = NULL;\n        rv = ap_rgetline(&(r->the_request), (apr_size_t)(r->server->limit_req_line + 2),\n                         &len, r, 0, bb);\n\n        if (rv != APR_SUCCESS) {\n            r->request_time = apr_time_now();\n\n            /* ap_rgetline returns APR_ENOSPC if it fills up the\n             * buffer before finding the end-of-line.  This is only going to\n             * happen if it exceeds the configured limit for a request-line.\n              */\n             if (APR_STATUS_IS_ENOSPC(rv)) {\n                 r->status    = HTTP_REQUEST_URI_TOO_LARGE;\n                r->proto_num = HTTP_VERSION(1,0);\n                r->protocol  = apr_pstrdup(r->pool, \"HTTP/1.0\");\n             }\n             else if (APR_STATUS_IS_TIMEUP(rv)) {\n                 r->status = HTTP_REQUEST_TIME_OUT;\n             }\n             else if (APR_STATUS_IS_EINVAL(rv)) {\n                 r->status = HTTP_BAD_REQUEST;\n             }\n             return 0;\n         }\n     } while ((len <= 0) && (++num_blank_lines < max_blank_lines));\n\n    if (APLOGrtrace5(r)) {\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE5, 0, r,\n                      \"Request received from client: %s\",\n                      ap_escape_logitem(r->pool, r->the_request));\n    }\n\n    r->request_time = apr_time_now();\n    ll = r->the_request;\n    r->method = ap_getword_white(r->pool, &ll);\n\n    uri = ap_getword_white(r->pool, &ll);\n\n    /* Provide quick information about the request method as soon as known */\n\n    r->method_number = ap_method_number_of(r->method);\n    if (r->method_number == M_GET && r->method[0] == 'H') {\n        r->header_only = 1;\n    }\n\n    ap_parse_uri(r, uri);\n\n    if (ll[0]) {\n        r->assbackwards = 0;\n        pro = ll;\n        len = strlen(ll);\n    } else {\n        r->assbackwards = 1;\n        pro = \"HTTP/0.9\";\n        len = 8;\n        if (conf->http09_enable == AP_HTTP09_DISABLE) {\n                r->status = HTTP_VERSION_NOT_SUPPORTED;\n                r->protocol = apr_pstrmemdup(r->pool, pro, len);\n                /* If we deny 0.9, send error message with 1.x */\n                r->assbackwards = 0;\n                r->proto_num = HTTP_VERSION(0, 9);\n                r->connection->keepalive = AP_CONN_CLOSE;\n                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02401)\n                              \"HTTP/0.9 denied by server configuration\");\n                return 0;\n        }\n    }\n    r->protocol = apr_pstrmemdup(r->pool, pro, len);\n\n    /* Avoid sscanf in the common case */\n    if (len == 8\n        && pro[0] == 'H' && pro[1] == 'T' && pro[2] == 'T' && pro[3] == 'P'\n        && pro[4] == '/' && apr_isdigit(pro[5]) && pro[6] == '.'\n        && apr_isdigit(pro[7])) {\n        r->proto_num = HTTP_VERSION(pro[5] - '0', pro[7] - '0');\n    }\n    else {\n        if (strict) {\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02418)\n                          \"Invalid protocol '%s'\", r->protocol);\n            if (enforce_strict) {\n                r->status = HTTP_BAD_REQUEST;\n                return 0;\n            }\n        }\n        if (3 == sscanf(r->protocol, \"%4s/%u.%u\", http, &major, &minor)\n            && (strcasecmp(\"http\", http) == 0)\n            && (minor < HTTP_VERSION(1, 0)) ) { /* don't allow HTTP/0.1000 */\n            r->proto_num = HTTP_VERSION(major, minor);\n        }\n        else {\n            r->proto_num = HTTP_VERSION(1, 0);\n        }\n    }\n\n    if (strict) {\n        int err = 0;\n        if (ap_has_cntrl(r->the_request)) {\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02420)\n                          \"Request line must not contain control characters\");\n            err = HTTP_BAD_REQUEST;\n        }\n        if (r->parsed_uri.fragment) {\n            /* RFC3986 3.5: no fragment */\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02421)\n                          \"URI must not contain a fragment\");\n            err = HTTP_BAD_REQUEST;\n        }\n        else if (r->parsed_uri.user || r->parsed_uri.password) {\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02422)\n                          \"URI must not contain a username/password\");\n            err = HTTP_BAD_REQUEST;\n        }\n        else if (r->method_number == M_INVALID) {\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02423)\n                          \"Invalid HTTP method string: %s\", r->method);\n            err = HTTP_NOT_IMPLEMENTED;\n        }\n        else if (r->assbackwards == 0 && r->proto_num < HTTP_VERSION(1, 0)) {\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02424)\n                          \"HTTP/0.x does not take a protocol\");\n            err = HTTP_BAD_REQUEST;\n        }\n\n        if (err && enforce_strict) {\n            r->status = err;\n            return 0;\n        }\n    }\n\n    return 1;\n}\n", "target": 1, "idx": 179913}
{"func": "SPL_METHOD(SplFileObject, seek)\n {\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n \tlong line_pos;\n \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &line_pos) == FAILURE) {\n \t\treturn;\n \t}\n \tif (line_pos < 0) {\n \t\tzend_throw_exception_ex(spl_ce_LogicException, 0 TSRMLS_CC, \"Can't seek file %s to negative line %ld\", intern->file_name, line_pos);\n\t\tRETURN_FALSE;\t\t\n \t}\n \tspl_filesystem_file_rewind(getThis(), intern TSRMLS_CC);\n \twhile(intern->u.file.current_line_num < line_pos) {\n \t\tif (spl_filesystem_file_read_line(getThis(), intern, 1 TSRMLS_CC) == FAILURE) {\n \t\t\tbreak;\n\t\t}\n\t}\n} /* }}} */\n\n/* {{{ Function/Class/Method definitions */\n", "target": 1, "idx": 180240}
{"func": " base::string16 GetApplicationNameForProtocol(const GURL& url) {\n  base::string16 application_name;\n   if (base::win::GetVersion() >= base::win::VERSION_WIN8) {\n    application_name = GetAppForProtocolUsingAssocQuery(url);\n     if (!application_name.empty())\n       return application_name;\n   }\n\n  return GetAppForProtocolUsingRegistry(url);\n}\n", "target": 1, "idx": 186614}
{"func": "static char *EscapeParenthesis(const char *source)\n{\n  char\n    *destination;\n\n  register char\n    *q;\n\n  register const char\n    *p;\n\n  size_t\n    length;\n\n  assert(source != (const char *) NULL);\n  length=0;\n  for (p=source; *p != '\\0'; p++)\n  {\n    if ((*p == '\\\\') || (*p == '(') || (*p == ')'))\n      {\n        if (~length < 1)\n          ThrowFatalException(ResourceLimitFatalError,\"UnableToEscapeString\");\n        length++;\n      }\n    length++;\n  }\n  destination=(char *) NULL;\n  if (~length >= (MagickPathExtent-1))\n    destination=(char *) AcquireQuantumMemory(length+MagickPathExtent,\n      sizeof(*destination));\n  if (destination == (char *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"UnableToEscapeString\");\n  *destination='\\0';\n  q=destination;\n  for (p=source; *p != '\\0'; p++)\n  {\n    if ((*p == '\\\\') || (*p == '(') || (*p == ')'))\n      *q++='\\\\';\n    *q++=(*p);\n  }\n  *q='\\0';\n  return(destination);\n}\n", "target": 0, "idx": 88974}
{"func": "static ssize_t map_write(struct file *file, const char __user *buf,\n\t\t\t size_t count, loff_t *ppos,\n\t\t\t int cap_setid,\n\t\t\t struct uid_gid_map *map,\n\t\t\t struct uid_gid_map *parent_map)\n{\n\tstruct seq_file *seq = file->private_data;\n\tstruct user_namespace *ns = seq->private;\n\tstruct uid_gid_map new_map;\n\tunsigned idx;\n\tstruct uid_gid_extent *extent = NULL;\n\tunsigned long page = 0;\n\tchar *kbuf, *pos, *next_line;\n\tssize_t ret = -EINVAL;\n\n\t/*\n\t * The id_map_mutex serializes all writes to any given map.\n\t *\n\t * Any map is only ever written once.\n\t *\n\t * An id map fits within 1 cache line on most architectures.\n\t *\n\t * On read nothing needs to be done unless you are on an\n\t * architecture with a crazy cache coherency model like alpha.\n\t *\n\t * There is a one time data dependency between reading the\n\t * count of the extents and the values of the extents.  The\n\t * desired behavior is to see the values of the extents that\n\t * were written before the count of the extents.\n\t *\n\t * To achieve this smp_wmb() is used on guarantee the write\n\t * order and smp_read_barrier_depends() is guaranteed that we\n\t * don't have crazy architectures returning stale data.\n\t *\n\t */\n\tmutex_lock(&id_map_mutex);\n\n\tret = -EPERM;\n\t/* Only allow one successful write to the map */\n\tif (map->nr_extents != 0)\n\t\tgoto out;\n\n\t/*\n\t * Adjusting namespace settings requires capabilities on the target.\n\t */\n\tif (cap_valid(cap_setid) && !file_ns_capable(file, ns, CAP_SYS_ADMIN))\n\t\tgoto out;\n\n\t/* Get a buffer */\n\tret = -ENOMEM;\n\tpage = __get_free_page(GFP_TEMPORARY);\n\tkbuf = (char *) page;\n\tif (!page)\n\t\tgoto out;\n\n\t/* Only allow <= page size writes at the beginning of the file */\n\tret = -EINVAL;\n\tif ((*ppos != 0) || (count >= PAGE_SIZE))\n\t\tgoto out;\n\n\t/* Slurp in the user data */\n\tret = -EFAULT;\n\tif (copy_from_user(kbuf, buf, count))\n\t\tgoto out;\n\tkbuf[count] = '\\0';\n\n\t/* Parse the user data */\n\tret = -EINVAL;\n\tpos = kbuf;\n\tnew_map.nr_extents = 0;\n\tfor (;pos; pos = next_line) {\n\t\textent = &new_map.extent[new_map.nr_extents];\n\n\t\t/* Find the end of line and ensure I don't look past it */\n\t\tnext_line = strchr(pos, '\\n');\n\t\tif (next_line) {\n\t\t\t*next_line = '\\0';\n\t\t\tnext_line++;\n\t\t\tif (*next_line == '\\0')\n\t\t\t\tnext_line = NULL;\n\t\t}\n\n\t\tpos = skip_spaces(pos);\n\t\textent->first = simple_strtoul(pos, &pos, 10);\n\t\tif (!isspace(*pos))\n\t\t\tgoto out;\n\n\t\tpos = skip_spaces(pos);\n\t\textent->lower_first = simple_strtoul(pos, &pos, 10);\n\t\tif (!isspace(*pos))\n\t\t\tgoto out;\n\n\t\tpos = skip_spaces(pos);\n\t\textent->count = simple_strtoul(pos, &pos, 10);\n\t\tif (*pos && !isspace(*pos))\n\t\t\tgoto out;\n\n\t\t/* Verify there is not trailing junk on the line */\n\t\tpos = skip_spaces(pos);\n\t\tif (*pos != '\\0')\n\t\t\tgoto out;\n\n\t\t/* Verify we have been given valid starting values */\n\t\tif ((extent->first == (u32) -1) ||\n\t\t    (extent->lower_first == (u32) -1 ))\n\t\t\tgoto out;\n\n\t\t/* Verify count is not zero and does not cause the extent to wrap */\n\t\tif ((extent->first + extent->count) <= extent->first)\n\t\t\tgoto out;\n\t\tif ((extent->lower_first + extent->count) <= extent->lower_first)\n\t\t\tgoto out;\n\n\t\t/* Do the ranges in extent overlap any previous extents? */\n\t\tif (mappings_overlap(&new_map, extent))\n\t\t\tgoto out;\n\n\t\tnew_map.nr_extents++;\n\n\t\t/* Fail if the file contains too many extents */\n\t\tif ((new_map.nr_extents == UID_GID_MAP_MAX_EXTENTS) &&\n\t\t    (next_line != NULL))\n\t\t\tgoto out;\n\t}\n\t/* Be very certaint the new map actually exists */\n\tif (new_map.nr_extents == 0)\n\t\tgoto out;\n\n\tret = -EPERM;\n\t/* Validate the user is allowed to use user id's mapped to. */\n\tif (!new_idmap_permitted(file, ns, cap_setid, &new_map))\n\t\tgoto out;\n\n\t/* Map the lower ids from the parent user namespace to the\n\t * kernel global id space.\n\t */\n\tfor (idx = 0; idx < new_map.nr_extents; idx++) {\n\t\tu32 lower_first;\n\t\textent = &new_map.extent[idx];\n\n\t\tlower_first = map_id_range_down(parent_map,\n\t\t\t\t\t\textent->lower_first,\n\t\t\t\t\t\textent->count);\n\n\t\t/* Fail if we can not map the specified extent to\n\t\t * the kernel global id space.\n\t\t */\n\t\tif (lower_first == (u32) -1)\n\t\t\tgoto out;\n\n\t\textent->lower_first = lower_first;\n\t}\n\n\t/* Install the map */\n\tmemcpy(map->extent, new_map.extent,\n\t\tnew_map.nr_extents*sizeof(new_map.extent[0]));\n\tsmp_wmb();\n\tmap->nr_extents = new_map.nr_extents;\n\n\t*ppos = count;\n\tret = count;\nout:\n\tmutex_unlock(&id_map_mutex);\n\tif (page)\n\t\tfree_page(page);\n\treturn ret;\n}\n", "target": 0, "idx": 29911}
{"func": "static jboolean enableNative(JNIEnv* env, jobject obj) {\n     ALOGV(\"%s:\",__FUNCTION__);\n \n     jboolean result = JNI_FALSE;\n     if (!sBluetoothInterface) return result;\n    int ret = sBluetoothInterface->enable();\n     result = (ret == BT_STATUS_SUCCESS || ret == BT_STATUS_DONE) ? JNI_TRUE : JNI_FALSE;\n     return result;\n }\n", "target": 1, "idx": 188183}
{"func": "void RenderFrameImpl::DidChangeCpuTiming(base::TimeDelta time) {\n  for (auto& observer : observers_)\n    observer.DidChangeCpuTiming(time);\n}\n", "target": 0, "idx": 152249}
{"func": " static opj_bool pi_next_lrcp(opj_pi_iterator_t * pi)\n {\n     opj_pi_comp_t *comp = NULL;\n    opj_pi_resolution_t *res = NULL;\n    long index = 0;\n\n    if (!pi->first) {\n        comp = &pi->comps[pi->compno];\n        res = &comp->resolutions[pi->resno];\n        goto LABEL_SKIP;\n    } else {\n        pi->first = 0;\n    }\n\n    for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n        for (pi->resno = pi->poc.resno0; pi->resno < pi->poc.resno1;\n                pi->resno++) {\n            for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n                comp = &pi->comps[pi->compno];\n                if (pi->resno >= comp->numresolutions) {\n                    continue;\n                }\n                res = &comp->resolutions[pi->resno];\n                if (!pi->tp_on) {\n                    pi->poc.precno1 = res->pw * res->ph;\n                }\n                 for (pi->precno = pi->poc.precno0; pi->precno < pi->poc.precno1; pi->precno++) {\n                     index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno *\n                             pi->step_c + pi->precno * pi->step_p;\n                     if (!pi->include[index]) {\n                         pi->include[index] = 1;\n                         return OPJ_TRUE;\n                    }\nLABEL_SKIP:\n                    ;\n                }\n            }\n        }\n    }\n\n    return OPJ_FALSE;\n}\n", "target": 1, "idx": 182940}
{"func": "static enum s_alloc __visit_domain_allocation_hell(struct s_data *d,\n\t\t\t\t\t\t   const struct cpumask *cpu_map)\n{\n#ifdef CONFIG_NUMA\n\tif (!alloc_cpumask_var(&d->domainspan, GFP_KERNEL))\n\t\treturn sa_none;\n\tif (!alloc_cpumask_var(&d->covered, GFP_KERNEL))\n\t\treturn sa_domainspan;\n\tif (!alloc_cpumask_var(&d->notcovered, GFP_KERNEL))\n\t\treturn sa_covered;\n\t/* Allocate the per-node list of sched groups */\n\td->sched_group_nodes = kcalloc(nr_node_ids,\n\t\t\t\t      sizeof(struct sched_group *), GFP_KERNEL);\n\tif (!d->sched_group_nodes) {\n\t\tprintk(KERN_WARNING \"Can not alloc sched group node list\\n\");\n\t\treturn sa_notcovered;\n\t}\n\tsched_group_nodes_bycpu[cpumask_first(cpu_map)] = d->sched_group_nodes;\n#endif\n\tif (!alloc_cpumask_var(&d->nodemask, GFP_KERNEL))\n\t\treturn sa_sched_group_nodes;\n\tif (!alloc_cpumask_var(&d->this_sibling_map, GFP_KERNEL))\n\t\treturn sa_nodemask;\n\tif (!alloc_cpumask_var(&d->this_core_map, GFP_KERNEL))\n\t\treturn sa_this_sibling_map;\n\tif (!alloc_cpumask_var(&d->this_book_map, GFP_KERNEL))\n\t\treturn sa_this_core_map;\n\tif (!alloc_cpumask_var(&d->send_covered, GFP_KERNEL))\n\t\treturn sa_this_book_map;\n\tif (!alloc_cpumask_var(&d->tmpmask, GFP_KERNEL))\n\t\treturn sa_send_covered;\n\td->rd = alloc_rootdomain();\n\tif (!d->rd) {\n\t\tprintk(KERN_WARNING \"Cannot alloc root domain\\n\");\n\t\treturn sa_tmpmask;\n\t}\n\treturn sa_rootdomain;\n}\n", "target": 0, "idx": 22314}
{"func": "void ExtensionOptionsGuest::DidNavigateMainFrame(\n    const content::LoadCommittedDetails& details,\n    const content::FrameNavigateParams& params) {\n  if (attached()) {\n    auto guest_zoom_controller =\n        ui_zoom::ZoomController::FromWebContents(web_contents());\n    guest_zoom_controller->SetZoomMode(\n         ui_zoom::ZoomController::ZOOM_MODE_ISOLATED);\n     SetGuestZoomLevelToMatchEmbedder();\n \n    if (params.url.GetOrigin() != options_page_.GetOrigin()) {\n       bad_message::ReceivedBadMessage(web_contents()->GetRenderProcessHost(),\n                                       bad_message::EOG_BAD_ORIGIN);\n     }\n  }\n}\n", "target": 1, "idx": 186250}
{"func": "static int accept_server_socket(int sfd)\n{\n struct sockaddr_un remote;\n struct pollfd pfd;\n int fd;\n socklen_t len = sizeof(struct sockaddr_un);\n\n    BTIF_TRACE_EVENT(\"accept fd %d\", sfd);\n\n /* make sure there is data to process */\n\n     pfd.fd = sfd;\n     pfd.events = POLLIN;\n \n    if (poll(&pfd, 1, 0) == 0)\n     {\n         BTIF_TRACE_EVENT(\"accept poll timeout\");\n         return -1;\n }\n\n \n \n    if ((fd = accept(sfd, (struct sockaddr *)&remote, &len)) == -1)\n     {\n          BTIF_TRACE_ERROR(\"sock accept failed (%s)\", strerror(errno));\n          return -1;\n }\n\n\n return fd;\n}\n", "target": 1, "idx": 187517}
{"func": " int main(int argc, char **argv)\n {\n     int         i, n_valid, do_write, do_scrub;\n    char       *c, *dname, *name;\n    DIR        *dir;\n    FILE       *fp;\n    pdf_t      *pdf;\n    pdf_flag_t  flags;\n\n    if (argc < 2)\n      usage();\n\n    /* Args */\n    do_write = do_scrub = flags = 0;\n    name = NULL;\n    for (i=1; i<argc; i++)\n    {\n        if (strncmp(argv[i], \"-w\", 2) == 0)\n          do_write = 1;\n        else if (strncmp(argv[i], \"-i\", 2) == 0)\n          flags |= PDF_FLAG_DISP_CREATOR;\n        else if (strncmp(argv[i], \"-q\", 2) == 0)\n          flags |= PDF_FLAG_QUIET;\n        else if (strncmp(argv[i], \"-s\", 2) == 0)\n          do_scrub = 1;\n        else if (argv[i][0] != '-')\n          name = argv[i];\n        else if (argv[i][0] == '-')\n          usage();\n    }\n\n    if (!name)\n      usage();\n\n    if (!(fp = fopen(name, \"r\")))\n    {\n        ERR(\"Could not open file '%s'\\n\", argv[1]);\n        return -1;\n    }\n    else if (!pdf_is_pdf(fp))\n    {\n        ERR(\"'%s' specified is not a valid PDF\\n\", name);\n        fclose(fp);\n        return -1;\n    }\n\n    /* Load PDF */\n    if (!(pdf = init_pdf(fp, name)))\n    {\n        fclose(fp);\n        return -1;\n    }\n\n    /* Count valid xrefs */\n    for (i=0, n_valid=0; i<pdf->n_xrefs; i++)\n      if (pdf->xrefs[i].version)\n        ++n_valid;\n\n    /* Bail if we only have 1 valid */\n    if (n_valid < 2)\n    {\n        if (!(flags & (PDF_FLAG_QUIET | PDF_FLAG_DISP_CREATOR)))\n          printf(\"%s: There is only one version of this PDF\\n\", pdf->name);\n\n        if (do_write)\n        {\n            fclose(fp);\n            pdf_delete(pdf);\n            return 0;\n        }\n    }\n\n    dname = NULL;\n    if (do_write)\n    {\n        /* Create directory to place the various versions in */\n        if ((c = strrchr(name, '/')))\n          name = c + 1;\n\n         if ((c = strrchr(name, '.')))\n           *c = '\\0';\n \n        dname = malloc(strlen(name) + 16);\n         sprintf(dname, \"%s-versions\", name);\n         if (!(dir = opendir(dname)))\n           mkdir(dname, S_IRWXU);\n        else\n        {\n            ERR(\"This directory already exists, PDF version extraction will \"\n                \"not occur.\\n\");\n            fclose(fp);\n            closedir(dir);\n            free(dname);\n            pdf_delete(pdf);\n            return -1;\n        }\n    \n        /* Write the pdf as a pervious version */\n        for (i=0; i<pdf->n_xrefs; i++)\n          if (pdf->xrefs[i].version)\n            write_version(fp, name, dname, &pdf->xrefs[i]);\n    }\n\n    /* Generate a per-object summary */\n    pdf_summarize(fp, pdf, dname, flags);\n\n    /* Have we been summoned to scrub history from this PDF */\n    if (do_scrub)\n      scrub_document(fp, pdf);\n\n    /* Display extra information */\n    if (flags & PDF_FLAG_DISP_CREATOR)\n      display_creator(fp, pdf);\n\n    fclose(fp);\n    free(dname);\n    pdf_delete(pdf);\n\n    return 0;\n}\n", "target": 1, "idx": 182736}
{"func": "static int hash_recvmsg(struct kiocb *unused, struct socket *sock,\n\t\t\tstruct msghdr *msg, size_t len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct hash_ctx *ctx = ask->private;\n\tunsigned ds = crypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req));\n\tint err;\n\n\tif (len > ds)\n\t\tlen = ds;\n \telse if (len < ds)\n \t\tmsg->msg_flags |= MSG_TRUNC;\n \n\tmsg->msg_namelen = 0;\n \tlock_sock(sk);\n \tif (ctx->more) {\n \t\tctx->more = 0;\n\t\tahash_request_set_crypt(&ctx->req, NULL, ctx->result, 0);\n\t\terr = af_alg_wait_for_completion(crypto_ahash_final(&ctx->req),\n\t\t\t\t\t\t &ctx->completion);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t}\n\n\terr = memcpy_toiovec(msg->msg_iov, ctx->result, len);\n\nunlock:\n\trelease_sock(sk);\n\n\treturn err ?: len;\n}\n", "target": 1, "idx": 179656}
{"func": "bool WebRtcAudioRenderer::Initialize(WebRtcAudioRendererSource* source) {\n  base::AutoLock auto_lock(lock_);\n  DCHECK_EQ(state_, UNINITIALIZED);\n  DCHECK(source);\n  DCHECK(!sink_);\n  DCHECK(!source_);\n\n  sink_ = AudioDeviceFactory::NewOutputDevice();\n  DCHECK(sink_);\n\n  int sample_rate = GetAudioOutputSampleRate();\n  DVLOG(1) << \"Audio output hardware sample rate: \" << sample_rate;\n  UMA_HISTOGRAM_ENUMERATION(\"WebRTC.AudioOutputSampleRate\",\n                            sample_rate, media::kUnexpectedAudioSampleRate);\n\n  if (std::find(&kValidOutputRates[0],\n                &kValidOutputRates[0] + arraysize(kValidOutputRates),\n                sample_rate) ==\n                    &kValidOutputRates[arraysize(kValidOutputRates)]) {\n    DLOG(ERROR) << sample_rate << \" is not a supported output rate.\";\n    return false;\n  }\n\n  media::ChannelLayout channel_layout = media::CHANNEL_LAYOUT_STEREO;\n\n  int buffer_size = 0;\n\n#if defined(OS_WIN)\n  channel_layout = media::CHANNEL_LAYOUT_STEREO;\n\n\n  if (sample_rate == 96000 || sample_rate == 48000) {\n    buffer_size = (sample_rate / 100);\n  } else {\n    buffer_size = 2 * 440;\n  }\n\n  if (base::win::GetVersion() < base::win::VERSION_VISTA) {\n    buffer_size = 3 * buffer_size;\n    DLOG(WARNING) << \"Extending the output buffer size by a factor of three \"\n                  << \"since Windows XP has been detected.\";\n  }\n#elif defined(OS_MACOSX)\n  channel_layout = media::CHANNEL_LAYOUT_MONO;\n \n \n  if (sample_rate == 48000) {\n    buffer_size = 480;\n   } else {\n    buffer_size = 440;\n  }\n#elif defined(OS_LINUX) || defined(OS_OPENBSD)\n  channel_layout = media::CHANNEL_LAYOUT_MONO;\n\n  buffer_size = 480;\n#else\n  DLOG(ERROR) << \"Unsupported platform\";\n  return false;\n#endif\n\n  params_.Reset(media::AudioParameters::AUDIO_PCM_LOW_LATENCY, channel_layout,\n                sample_rate, 16, buffer_size);\n\n  buffer_.reset(new int16[params_.frames_per_buffer() * params_.channels()]);\n\n  source_ = source;\n  source->SetRenderFormat(params_);\n\n  sink_->Initialize(params_, this);\n  sink_->SetSourceRenderView(source_render_view_id_);\n  sink_->Start();\n\n  state_ = PAUSED;\n\n  UMA_HISTOGRAM_ENUMERATION(\"WebRTC.AudioOutputChannelLayout\",\n                            channel_layout, media::CHANNEL_LAYOUT_MAX);\n  UMA_HISTOGRAM_ENUMERATION(\"WebRTC.AudioOutputFramesPerBuffer\",\n                            buffer_size, kUnexpectedAudioBufferSize);\n  AddHistogramFramesPerBuffer(buffer_size);\n\n  return true;\n}\n", "target": 1, "idx": 185205}
{"func": "int ssl3_send_server_key_exchange(SSL *s)\n{\n#ifndef OPENSSL_NO_RSA\n    unsigned char *q;\n    int j, num;\n    RSA *rsa;\n    unsigned char md_buf[MD5_DIGEST_LENGTH + SHA_DIGEST_LENGTH];\n    unsigned int u;\n#endif\n#ifndef OPENSSL_NO_DH\n    DH *dh = NULL, *dhp;\n#endif\n#ifndef OPENSSL_NO_ECDH\n    EC_KEY *ecdh = NULL, *ecdhp;\n    unsigned char *encodedPoint = NULL;\n    int encodedlen = 0;\n    int curve_id = 0;\n    BN_CTX *bn_ctx = NULL;\n#endif\n    EVP_PKEY *pkey;\n    const EVP_MD *md = NULL;\n    unsigned char *p, *d;\n    int al, i;\n    unsigned long type;\n    int n;\n    CERT *cert;\n    BIGNUM *r[4];\n    int nr[4], kn;\n    BUF_MEM *buf;\n    EVP_MD_CTX md_ctx;\n\n    EVP_MD_CTX_init(&md_ctx);\n    if (s->state == SSL3_ST_SW_KEY_EXCH_A) {\n        type = s->s3->tmp.new_cipher->algorithm_mkey;\n        cert = s->cert;\n\n        buf = s->init_buf;\n\n        r[0] = r[1] = r[2] = r[3] = NULL;\n        n = 0;\n#ifndef OPENSSL_NO_RSA\n        if (type & SSL_kRSA) {\n            rsa = cert->rsa_tmp;\n            if ((rsa == NULL) && (s->cert->rsa_tmp_cb != NULL)) {\n                rsa = s->cert->rsa_tmp_cb(s,\n                                          SSL_C_IS_EXPORT(s->s3->\n                                                          tmp.new_cipher),\n                                          SSL_C_EXPORT_PKEYLENGTH(s->s3->\n                                                                  tmp.new_cipher));\n                if (rsa == NULL) {\n                    al = SSL_AD_HANDSHAKE_FAILURE;\n                    SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,\n                           SSL_R_ERROR_GENERATING_TMP_RSA_KEY);\n                    goto f_err;\n                }\n                RSA_up_ref(rsa);\n                cert->rsa_tmp = rsa;\n            }\n            if (rsa == NULL) {\n                al = SSL_AD_HANDSHAKE_FAILURE;\n                SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,\n                       SSL_R_MISSING_TMP_RSA_KEY);\n                goto f_err;\n            }\n            r[0] = rsa->n;\n            r[1] = rsa->e;\n            s->s3->tmp.use_rsa_tmp = 1;\n        } else\n#endif\n#ifndef OPENSSL_NO_DH\n        if (type & SSL_kEDH) {\n            dhp = cert->dh_tmp;\n            if ((dhp == NULL) && (s->cert->dh_tmp_cb != NULL))\n                dhp = s->cert->dh_tmp_cb(s,\n                                         SSL_C_IS_EXPORT(s->s3->\n                                                         tmp.new_cipher),\n                                         SSL_C_EXPORT_PKEYLENGTH(s->s3->\n                                                                 tmp.new_cipher));\n            if (dhp == NULL) {\n                al = SSL_AD_HANDSHAKE_FAILURE;\n                SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,\n                       SSL_R_MISSING_TMP_DH_KEY);\n                goto f_err;\n            }\n\n            if (s->s3->tmp.dh != NULL) {\n                SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,\n                       ERR_R_INTERNAL_ERROR);\n                goto err;\n            }\n\n            if ((dh = DHparams_dup(dhp)) == NULL) {\n                SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE, ERR_R_DH_LIB);\n                goto err;\n             }\n \n             s->s3->tmp.dh = dh;\n            if ((dhp->pub_key == NULL ||\n                 dhp->priv_key == NULL ||\n                 (s->options & SSL_OP_SINGLE_DH_USE))) {\n                if (!DH_generate_key(dh)) {\n                    SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE, ERR_R_DH_LIB);\n                    goto err;\n                }\n            } else {\n                dh->pub_key = BN_dup(dhp->pub_key);\n                dh->priv_key = BN_dup(dhp->priv_key);\n                if ((dh->pub_key == NULL) || (dh->priv_key == NULL)) {\n                    SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE, ERR_R_DH_LIB);\n                    goto err;\n                }\n             }\n             r[0] = dh->p;\n             r[1] = dh->g;\n                }\n            } else {\n                dh->pub_key = BN_dup(dhp->pub_key);\n                dh->priv_key = BN_dup(dhp->priv_key);\n                if ((dh->pub_key == NULL) || (dh->priv_key == NULL)) {\n                    SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE, ERR_R_DH_LIB);\n                    goto err;\n                }\n            }\n            r[0] = dh->p;\n            r[1] = dh->g;\n            r[2] = dh->pub_key;\n        } else\n", "target": 1, "idx": 178429}
{"func": "static void perf_cgroup_attach(struct cgroup_taskset *tset)\n{\n\tstruct task_struct *task;\n\tstruct cgroup_subsys_state *css;\n\n\tcgroup_taskset_for_each(task, css, tset)\n\t\ttask_function_call(task, __perf_cgroup_move, task);\n}\n", "target": 0, "idx": 68340}
{"func": "void SkiaOutputSurfaceImpl::Reshape(const gfx::Size& size,\n                                    float device_scale_factor,\n                                    const gfx::ColorSpace& color_space,\n                                    bool has_alpha,\n                                    bool use_stencil) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (initialize_waitable_event_) {\n     initialize_waitable_event_->Wait();\n    initialize_waitable_event_ = nullptr;\n   }\n \n   SkSurfaceCharacterization* characterization = nullptr;\n   if (characterization_.isValid()) {\n    characterization_ =\n        characterization_.createResized(size.width(), size.height());\n     RecreateRootRecorder();\n   } else {\n     characterization = &characterization_;\n    initialize_waitable_event_ = std::make_unique<base::WaitableEvent>(\n        base::WaitableEvent::ResetPolicy::MANUAL,\n        base::WaitableEvent::InitialState::NOT_SIGNALED);\n  }\n \n  auto callback = base::BindOnce(\n      &SkiaOutputSurfaceImplOnGpu::Reshape,\n      base::Unretained(impl_on_gpu_.get()), size, device_scale_factor,\n      std::move(color_space), has_alpha, use_stencil, pre_transform_,\n      characterization, initialize_waitable_event_.get());\n  ScheduleGpuTask(std::move(callback), std::vector<gpu::SyncToken>());\n }\n", "target": 1, "idx": 186285}
{"func": "        ~CreateFileResult()\n        {\n        }\n", "target": 1, "idx": 185114}
{"func": "EffectPaintPropertyNode* EffectPaintPropertyNode::Root() {\n  DEFINE_STATIC_REF(EffectPaintPropertyNode, root,\n                    (EffectPaintPropertyNode::Create(\n                        nullptr, State{TransformPaintPropertyNode::Root(),\n                                       ClipPaintPropertyNode::Root()})));\n   return root;\n }\n", "target": 1, "idx": 185711}
{"func": "static void echo_set_canon_col(struct n_tty_data *ldata)\n{\n\tadd_echo_byte(ECHO_OP_START, ldata);\n\tadd_echo_byte(ECHO_OP_SET_CANON_COL, ldata);\n}\n", "target": 0, "idx": 39789}
{"func": "void dtls1_hm_fragment_free(hm_fragment *frag)\n{\n    if (!frag)\n        return;\n    if (frag->msg_header.is_ccs) {\n        EVP_CIPHER_CTX_free(frag->msg_header.\n                            saved_retransmit_state.enc_write_ctx);\n        EVP_MD_CTX_free(frag->msg_header.saved_retransmit_state.write_hash);\n    }\n    OPENSSL_free(frag->fragment);\n    OPENSSL_free(frag->reassembly);\n    OPENSSL_free(frag);\n}\n", "target": 0, "idx": 9368}
{"func": "static void oz_usb_handle_ep_data(struct oz_usb_ctx *usb_ctx,\n\tstruct oz_usb_hdr *usb_hdr, int len)\n{\n\tstruct oz_data *data_hdr = (struct oz_data *)usb_hdr;\n\n\tswitch (data_hdr->format) {\n\tcase OZ_DATA_F_MULTIPLE_FIXED: {\n \t\t\tstruct oz_multiple_fixed *body =\n \t\t\t\t(struct oz_multiple_fixed *)data_hdr;\n \t\t\tu8 *data = body->data;\n\t\t\tint n = (len - sizeof(struct oz_multiple_fixed)+1)\n \t\t\t\t/ body->unit_size;\n \t\t\twhile (n--) {\n \t\t\t\toz_hcd_data_ind(usb_ctx->hport, body->endpoint,\n\t\t\t\t\tdata, body->unit_size);\n\t\t\t\tdata += body->unit_size;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase OZ_DATA_F_ISOC_FIXED: {\n\t\t\tstruct oz_isoc_fixed *body =\n\t\t\t\t(struct oz_isoc_fixed *)data_hdr;\n\t\t\tint data_len = len-sizeof(struct oz_isoc_fixed)+1;\n\t\t\tint unit_size = body->unit_size;\n\t\t\tu8 *data = body->data;\n\t\t\tint count;\n\t\t\tint i;\n\n\t\t\tif (!unit_size)\n\t\t\t\tbreak;\n\t\t\tcount = data_len/unit_size;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\toz_hcd_data_ind(usb_ctx->hport,\n\t\t\t\t\tbody->endpoint, data, unit_size);\n\t\t\t\tdata += unit_size;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n}\n", "target": 1, "idx": 179789}
{"func": "const base::FilePath& DriveFsHost::GetMountPath() const {\n  DCHECK(IsMounted());\n  return mount_state_->mount_path();\n}\n", "target": 0, "idx": 134953}
{"func": "upnp_redirect(const char * rhost, unsigned short eport,\n              const char * iaddr, unsigned short iport,\n              const char * protocol, const char * desc,\n              unsigned int leaseduration)\n{\n\tint proto, r;\n\tchar iaddr_old[32];\n\tchar rhost_old[32];\n\tunsigned short iport_old;\n\tstruct in_addr address;\n\tunsigned int timestamp;\n\n\tproto = proto_atoi(protocol);\n\tif(inet_aton(iaddr, &address) <= 0) {\n\t\tsyslog(LOG_ERR, \"inet_aton(%s) FAILED\", iaddr);\n\t\treturn -1;\n\t}\n\n\tif(!check_upnp_rule_against_permissions(upnppermlist, num_upnpperm,\n\t                                        eport, address, iport)) {\n\t\tsyslog(LOG_INFO, \"redirection permission check failed for \"\n \t\t                 \"%hu->%s:%hu %s\", eport, iaddr, iport, protocol);\n \t\treturn -3;\n \t}\n \t/* IGDv1 (WANIPConnection:1 Service Template Version 1.01 / Nov 12, 2001)\n \t * - 2.2.20.PortMappingDescription :\n \t *  Overwriting Previous / Existing Port Mappings:\n\t * If the RemoteHost, ExternalPort, PortMappingProtocol and InternalClient\n\t * are exactly the same as an existing mapping, the existing mapping values\n\t * for InternalPort, PortMappingDescription, PortMappingEnabled and\n\t * PortMappingLeaseDuration are overwritten.\n\t *  Rejecting a New Port Mapping:\n\t * In cases where the RemoteHost, ExternalPort and PortMappingProtocol\n\t * are the same as an existing mapping, but the InternalClient is\n\t * different, the action is rejected with an appropriate error.\n\t *  Add or Reject New Port Mapping behavior based on vendor implementation:\n\t * In cases where the ExternalPort, PortMappingProtocol and InternalClient\n\t * are the same, but RemoteHost is different, the vendor can choose to\n\t * support both mappings simultaneously, or reject the second mapping\n\t * with an appropriate error.\n\t *\n\t * - 2.4.16.AddPortMapping\n\t * This action creates a new port mapping or overwrites an existing\n\t * mapping with the same internal client. If the ExternalPort and\n\t * PortMappingProtocol pair is already mapped to another internal client,\n\t * an error is returned.\n\t *\n\t * IGDv2 (WANIPConnection:2 Service Standardized DCP (SDCP) Sep 10, 2010)\n\t * Protocol ExternalPort RemoteHost InternalClient Result\n\t *     =         =           \u2260           \u2260         Failure\n\t *     =         =           \u2260           =         Failure or success\n\t *                                                 (vendor specific)\n\t *     =         =           =           \u2260         Failure\n\t *     =         =           =           =         Success (overwrite)\n\t */\n\trhost_old[0] = '\\0';\n\tr = get_redirect_rule(ext_if_name, eport, proto,\n\t                      iaddr_old, sizeof(iaddr_old), &iport_old, 0, 0,\n\t                      rhost_old, sizeof(rhost_old),\n\t                      &timestamp, 0, 0);\n\tif(r == 0) {\n\t\tif(strcmp(iaddr, iaddr_old)==0 &&\n\t\t   ((rhost == NULL && rhost_old[0]=='\\0') ||\n\t\t    (rhost && (strcmp(rhost, \"*\") == 0) && rhost_old[0]=='\\0') ||\n\t\t    (rhost && (strcmp(rhost, rhost_old) == 0)))) {\n\t\t\tsyslog(LOG_INFO, \"updating existing port mapping %hu %s (rhost '%s') => %s:%hu\",\n\t\t\t\teport, protocol, rhost_old, iaddr_old, iport_old);\n\t\t\ttimestamp = (leaseduration > 0) ? upnp_time() + leaseduration : 0;\n\t\t\tif(iport != iport_old) {\n\t\t\t\tr = update_portmapping(ext_if_name, eport, proto, iport, desc, timestamp);\n\t\t\t} else {\n\t\t\t\tr = update_portmapping_desc_timestamp(ext_if_name, eport, proto, desc, timestamp);\n\t\t\t}\n#ifdef ENABLE_LEASEFILE\n\t\t\tif(r == 0) {\n\t\t\t\tlease_file_remove(eport, proto);\n\t\t\t\tlease_file_add(eport, iaddr, iport, proto, desc, timestamp);\n\t\t\t}\n#endif /* ENABLE_LEASEFILE */\n\t\t\treturn r;\n\t\t} else {\n\t\t\tsyslog(LOG_INFO, \"port %hu %s (rhost '%s') already redirected to %s:%hu\",\n\t\t\t\teport, protocol, rhost_old, iaddr_old, iport_old);\n\t\t\treturn -2;\n\t\t}\n#ifdef CHECK_PORTINUSE\n\t} else if (port_in_use(ext_if_name, eport, proto, iaddr, iport) > 0) {\n\t\tsyslog(LOG_INFO, \"port %hu protocol %s already in use\",\n\t\t       eport, protocol);\n\t\treturn -4;\n#endif /* CHECK_PORTINUSE */\n\t} else {\n\t\ttimestamp = (leaseduration > 0) ? upnp_time() + leaseduration : 0;\n\t\tsyslog(LOG_INFO, \"redirecting port %hu to %s:%hu protocol %s for: %s\",\n\t\t\teport, iaddr, iport, protocol, desc);\n\t\treturn upnp_redirect_internal(rhost, eport, iaddr, iport, proto,\n\t\t                              desc, timestamp);\n\t}\n}\n", "target": 1, "idx": 182838}
{"func": "DefragTimeoutTest(void)\n{\n    int i;\n    int ret = 0;\n\n    /* Setup a small numberr of trackers. */\n    if (ConfSet(\"defrag.trackers\", \"16\") != 1) {\n        printf(\"ConfSet failed: \");\n        goto end;\n    }\n\n    DefragInit();\n \n     /* Load in 16 packets. */\n     for (i = 0; i < 16; i++) {\n        Packet *p = BuildTestPacket(i, 0, 1, 'A' + i, 16);\n         if (p == NULL)\n             goto end;\n \n        Packet *tp = Defrag(NULL, NULL, p, NULL);\n\n        SCFree(p);\n\n        if (tp != NULL) {\n            SCFree(tp);\n            goto end;\n        }\n    }\n \n     /* Build a new packet but push the timestamp out by our timeout.\n      * This should force our previous fragments to be timed out. */\n    Packet *p = BuildTestPacket(99, 0, 1, 'A' + i, 16);\n     if (p == NULL)\n         goto end;\n \n    p->ts.tv_sec += (defrag_context->timeout + 1);\n    Packet *tp = Defrag(NULL, NULL, p, NULL);\n\n    if (tp != NULL) {\n        SCFree(tp);\n        goto end;\n    }\n\n    DefragTracker *tracker = DefragLookupTrackerFromHash(p);\n    if (tracker == NULL)\n        goto end;\n\n    if (tracker->id != 99)\n        goto end;\n\n    SCFree(p);\n\n    ret = 1;\nend:\n    DefragDestroy();\n    return ret;\n}\n", "target": 1, "idx": 181475}
{"func": "std::wstring DetermineChannel(const InstallConstants& mode,\n                              bool system_level,\n                              bool from_binaries,\n                              std::wstring* update_ap,\n                              std::wstring* update_cohort_name) {\n  if (!kUseGoogleUpdateIntegration)\n    return std::wstring();\n\n  std::wstring client_state(from_binaries\n                                ? GetBinariesClientStateKeyPath()\n                                : GetClientStateKeyPath(mode.app_guid));\n  std::wstring ap_value;\n  nt::QueryRegValueSZ(system_level ? nt::HKLM : nt::HKCU, nt::WOW6432,\n                      client_state.c_str(), kRegValueAp, &ap_value);\n  if (update_ap)\n    *update_ap = ap_value;\n\n  if (update_cohort_name) {\n    nt::QueryRegValueSZ(system_level ? nt::HKLM : nt::HKCU, nt::WOW6432,\n                        client_state.append(L\"\\\\cohort\").c_str(), kRegValueName,\n                        update_cohort_name);\n  }\n\n  switch (mode.channel_strategy) {\n    case ChannelStrategy::UNSUPPORTED:\n      assert(false);\n      break;\n    case ChannelStrategy::ADDITIONAL_PARAMETERS:\n      return ChannelFromAdditionalParameters(mode, ap_value);\n    case ChannelStrategy::FIXED:\n      return mode.default_channel_name;\n  }\n\n  return std::wstring();\n}\n", "target": 0, "idx": 165637}
{"func": "int svc_rdma_xdr_encode_error(struct svcxprt_rdma *xprt,\n\t\t\t      struct rpcrdma_msg *rmsgp,\n\t\t\t      enum rpcrdma_errcode err, __be32 *va)\n{\n\t__be32 *startp = va;\n\t*va++ = rmsgp->rm_xid;\n\t*va++ = rmsgp->rm_vers;\n\t*va++ = xprt->sc_fc_credits;\n\t*va++ = rdma_error;\n\t*va++ = cpu_to_be32(err);\n\tif (err == ERR_VERS) {\n\t\t*va++ = rpcrdma_version;\n\t\t*va++ = rpcrdma_version;\n\t}\n\treturn (int)((unsigned long)va - (unsigned long)startp);\n}\n", "target": 1, "idx": 181332}
{"func": "static int parse_timeout(const char *target)\n{\n    QemuOptsList *list;\n    QemuOpts *opts;\n    const char *timeout;\n\n    list = qemu_find_opts(\"iscsi\");\n    if (list) {\n        opts = qemu_opts_find(list, target);\n        if (!opts) {\n            opts = QTAILQ_FIRST(&list->head);\n        }\n        if (opts) {\n            timeout = qemu_opt_get(opts, \"timeout\");\n            if (timeout) {\n                return atoi(timeout);\n            }\n        }\n    }\n\n    return 0;\n}\n", "target": 0, "idx": 10534}
{"func": "   void RemoveClientSession() {\n    context_.network_message_loop()->PostTask(\n        FROM_HERE, base::Bind(\n            &ClientSession::OnConnectionClosed, client_, connection_));\n   }\n", "target": 1, "idx": 184638}
{"func": "static bool name_is_in_groupnames(char *name, char **groupnames)\n{\n\twhile (groupnames != NULL) {\n\t\tif (strcmp(name, *groupnames) == 0)\n\t\t\treturn true;\n\t\tgroupnames++;\n\t}\n\treturn false;\n}\n", "target": 0, "idx": 68461}
{"func": " void *Sys_LoadDll(const char *name, qboolean useSystemLib)\n {\n \tvoid *dllhandle;\n \t\n \tif(useSystemLib)\n \t\tCom_Printf(\"Trying to load \\\"%s\\\"...\\n\", name);\n\t\n\tif(!useSystemLib || !(dllhandle = Sys_LoadLibrary(name)))\n\t{\n\t\tconst char *topDir;\n\t\tchar libPath[MAX_OSPATH];\n\n\t\ttopDir = Sys_BinaryPath();\n\n\t\tif(!*topDir)\n\t\t\ttopDir = \".\";\n\n\t\tCom_Printf(\"Trying to load \\\"%s\\\" from \\\"%s\\\"...\\n\", name, topDir);\n\t\tCom_sprintf(libPath, sizeof(libPath), \"%s%c%s\", topDir, PATH_SEP, name);\n\n\t\tif(!(dllhandle = Sys_LoadLibrary(libPath)))\n\t\t{\n\t\t\tconst char *basePath = Cvar_VariableString(\"fs_basepath\");\n\t\t\t\n\t\t\tif(!basePath || !*basePath)\n\t\t\t\tbasePath = \".\";\n\t\t\t\n\t\t\tif(FS_FilenameCompare(topDir, basePath))\n\t\t\t{\n\t\t\t\tCom_Printf(\"Trying to load \\\"%s\\\" from \\\"%s\\\"...\\n\", name, basePath);\n\t\t\t\tCom_sprintf(libPath, sizeof(libPath), \"%s%c%s\", basePath, PATH_SEP, name);\n\t\t\t\tdllhandle = Sys_LoadLibrary(libPath);\n\t\t\t}\n\t\t\t\n\t\t\tif(!dllhandle)\n\t\t\t\tCom_Printf(\"Loading \\\"%s\\\" failed\\n\", name);\n\t\t}\n\t}\n\t\n\treturn dllhandle;\n}\n", "target": 1, "idx": 183256}
{"func": "IDNSpoofChecker::IDNSpoofChecker() {\n  UErrorCode status = U_ZERO_ERROR;\n  checker_ = uspoof_open(&status);\n  if (U_FAILURE(status)) {\n    checker_ = nullptr;\n    return;\n  }\n\n\n  uspoof_setRestrictionLevel(checker_, USPOOF_HIGHLY_RESTRICTIVE);\n\n  SetAllowedUnicodeSet(&status);\n\n  int32_t checks = uspoof_getChecks(checker_, &status) | USPOOF_AUX_INFO;\n  uspoof_setChecks(checker_, checks, &status);\n\n  deviation_characters_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u00df\\\\u03c2\\\\u200c\\\\u200d]\"), status);\n  deviation_characters_.freeze();\n\n  non_ascii_latin_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Latin:] - [a-zA-Z]]\"), status);\n  non_ascii_latin_letters_.freeze();\n\n  kana_letters_exceptions_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u3078-\\\\u307a\\\\u30d8-\\\\u30da\\\\u30fb-\\\\u30fe]\"),\n      status);\n  kana_letters_exceptions_.freeze();\n  combining_diacritics_exceptions_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[\\\\u0300-\\\\u0339]\"), status);\n  combining_diacritics_exceptions_.freeze();\n\n  cyrillic_letters_latin_alike_ = icu::UnicodeSet(\n      icu::UnicodeString::fromUTF8(\"[\u0430\u0441\u0501\u0435\u04bb\u0456\u0458\u04cf\u043e\u0440\u051b\u0455\u051d\u0445\u0443\u044a\u042c\u04bd\u043f\u0433\u0475\u0461]\"), status);\n  cyrillic_letters_latin_alike_.freeze();\n\n  cyrillic_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Cyrl:]]\"), status);\n  cyrillic_letters_.freeze();\n\n  DCHECK(U_SUCCESS(status));\n  lgc_letters_n_ascii_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[[:Latin:][:Greek:][:Cyrillic:][0-9\\\\u002e_\"\n                            \"\\\\u002d][\\\\u0300-\\\\u0339]]\"),\n      status);\n  lgc_letters_n_ascii_.freeze();\n\n  UParseError parse_error;\n  diacritic_remover_.reset(icu::Transliterator::createFromRules(\n      UNICODE_STRING_SIMPLE(\"DropAcc\"),\n      icu::UnicodeString::fromUTF8(\"::NFD; ::[:Nonspacing Mark:] Remove; ::NFC;\"\n                                   \" \u0142 > l; \u00f8 > o; \u0111 > d;\"),\n      UTRANS_FORWARD, parse_error, status));\n\n      UNICODE_STRING_SIMPLE(\"ExtraConf\"),\n       icu::UnicodeString::fromUTF8(\"[\u00fe\u03fc\u048f] > p; [\u0127\u043d\u045b\u04a3\u04a5\u04c8\u0527\u0529] > h;\"\n                                    \"[\u0138\u03ba\u043a\u049b\u049d\u049f\u04a1\u04c4\u051f] > k; [\u0167\u0442\u04ad] > t;\"\n                                    \"[\u0185\u044c\u048d\u0432] > b;  [\u03c9\u0448\u0449] > w; [\u043c\u04ce] > m;\"\n                                   \"\u043f > n; \u045b > h; \u0491 > r; \u0493 > f; \u04ab > c;\"\n                                   \"\u04b1 > y; [\u03c7\u04b3\u04fd\u04ff] > x; [\u04bd\u04bf] > e;\"\n #if defined(OS_WIN)\n                                    \"\u04cf > i;\"\n #else\n                                   \"\u04cf > l;\"\n#endif\n                                   \"\u0503  > d; \u050d > g; \u0d1f > s\"),\n      UTRANS_FORWARD, parse_error, status));\n  DCHECK(U_SUCCESS(status))\n      << \"Spoofchecker initalization failed due to an error: \"\n      << u_errorName(status);\n}\n", "target": 1, "idx": 186714}
{"func": "static void lsi_bad_selection(LSIState *s, uint32_t id)\n{\n    trace_lsi_bad_selection(id);\n    lsi_script_scsi_interrupt(s, 0, LSI_SIST1_STO);\n    lsi_disconnect(s);\n}\n", "target": 0, "idx": 3674}
{"func": " SoftMPEG4Encoder::~SoftMPEG4Encoder() {\n     ALOGV(\"Destruct SoftMPEG4Encoder\");\n     releaseEncoder();\n     List<BufferInfo *> &outQueue = getPortQueue(1);\n     List<BufferInfo *> &inQueue = getPortQueue(0);\n    CHECK(outQueue.empty());\n    CHECK(inQueue.empty());\n}\n", "target": 1, "idx": 188033}
{"func": "static int asymmetric_key_match(const struct key *key,\n\t\t\t\tconst struct key_match_data *match_data)\n {\n \tconst struct asymmetric_key_subtype *subtype = asymmetric_key_subtype(key);\n \tconst char *description = match_data->raw_data;\n\tconst char *spec = description;\n\tconst char *id;\n\tptrdiff_t speclen;\n\n\tif (!subtype || !spec || !*spec)\n\t\treturn 0;\n\n\t/* See if the full key description matches as is */\n\tif (key->description && strcmp(key->description, description) == 0)\n\t\treturn 1;\n\n\t/* All tests from here on break the criterion description into a\n\t * specifier, a colon and then an identifier.\n\t */\n\tid = strchr(spec, ':');\n\tif (!id)\n\t\treturn 0;\n\n\tspeclen = id - spec;\n\tid++;\n\n\tif (speclen == 2 && memcmp(spec, \"id\", 2) == 0)\n\t\treturn asymmetric_keyid_match(asymmetric_key_id(key), id);\n\n\tif (speclen == subtype->name_len &&\n\t    memcmp(spec, subtype->name, speclen) == 0)\n\t\treturn 1;\n\n\treturn 0;\n}\n", "target": 1, "idx": 181608}
{"func": "static void mk_request_premature_close(int http_status, struct client_session *cs)\n{\n    struct session_request *sr;\n    struct mk_list *sr_list = &cs->request_list;\n    struct mk_list *host_list = &config->hosts;\n\n    /*\n     * If the connection is too premature, we need to allocate a temporal session_request\n     * to do not break the plugins stages\n     */\n    if (mk_list_is_empty(sr_list) == 0) {\n        sr = &cs->sr_fixed;\n        memset(sr, 0, sizeof(struct session_request));\n        mk_request_init(sr);\n        mk_list_add(&sr->_head, &cs->request_list);\n    }\n    else {\n        sr = mk_list_entry_first(sr_list, struct session_request, _head);\n    }\n\n    /* Raise error */\n    if (http_status > 0) {\n        if (!sr->host_conf) {\n            sr->host_conf = mk_list_entry_first(host_list, struct host, _head);\n        }\n        mk_request_error(http_status, cs, sr);\n\n        /* STAGE_40, request has ended */\n        mk_plugin_stage_run(MK_PLUGIN_STAGE_40, cs->socket,\n                            NULL, cs, sr);\n    }\n\n    /* STAGE_50, connection closed  and remove client_session*/\n    mk_plugin_stage_run(MK_PLUGIN_STAGE_50, cs->socket, NULL, NULL, NULL);\n    mk_session_remove(cs->socket);\n}\n", "target": 0, "idx": 36160}
{"func": "static void didSameDocumentNavigationForFrame(WKPageRef page, WKFrameRef frame, WKSameDocumentNavigationType, WKTypeRef, const void* clientInfo)\n{\n    if (!WKFrameIsMainFrame(frame))\n        return;\n\n    webkitWebViewUpdateURI(WEBKIT_WEB_VIEW(clientInfo));\n}\n", "target": 0, "idx": 115342}
{"func": "DevToolsWindow* DevToolsWindow::ToggleDevToolsWindow(\n    content::RenderViewHost* inspected_rvh,\n    bool force_open,\n    const DevToolsToggleAction& action) {\n  scoped_refptr<DevToolsAgentHost> agent(\n      DevToolsAgentHost::GetOrCreateFor(inspected_rvh));\n  content::DevToolsManager* manager = content::DevToolsManager::GetInstance();\n  DevToolsWindow* window = FindDevToolsWindow(agent.get());\n  bool do_open = force_open;\n  if (!window) {\n    Profile* profile = Profile::FromBrowserContext(\n        inspected_rvh->GetProcess()->GetBrowserContext());\n    DevToolsDockSide dock_side = GetDockSideFromPrefs(profile);\n    content::RecordAction(\n        content::UserMetricsAction(\"DevTools_InspectRenderer\"));\n    window = Create(profile, GURL(), inspected_rvh, dock_side, false, false);\n    manager->RegisterDevToolsClientHostFor(agent.get(),\n                                           window->frontend_host_.get());\n    do_open = true;\n  }\n\n  window->UpdateBrowserToolbar();\n\n  if (window->dock_side_ == DEVTOOLS_DOCK_SIDE_MINIMIZED)\n    window->Restore();\n  else if (!window->IsDocked() || do_open)\n    window->Show(action);\n  else\n    window->CloseWindow();\n\n  return window;\n}\n", "target": 0, "idx": 121470}
{"func": " void FileBrowserHandlerCustomBindings::GetExternalFileEntry(\n    const v8::FunctionCallbackInfo<v8::Value>& args) {\n//// TODO(zelidrag): Make this magic work on other platforms when file browser\n//// matures enough on ChromeOS.\n #if defined(OS_CHROMEOS)\n     CHECK(args.Length() == 1);\n     CHECK(args[0]->IsObject());\n    v8::Local<v8::Object> file_def = args[0]->ToObject();\n    std::string file_system_name(\n        *v8::String::Utf8Value(file_def->Get(\n            v8::String::NewFromUtf8(args.GetIsolate(), \"fileSystemName\"))));\n    GURL file_system_root(\n        *v8::String::Utf8Value(file_def->Get(\n            v8::String::NewFromUtf8(args.GetIsolate(), \"fileSystemRoot\"))));\n    std::string file_full_path(\n        *v8::String::Utf8Value(file_def->Get(\n            v8::String::NewFromUtf8(args.GetIsolate(), \"fileFullPath\"))));\n    bool is_directory = file_def->Get(v8::String::NewFromUtf8(\n        args.GetIsolate(), \"fileIsDirectory\"))->ToBoolean()->Value();\n    blink::WebDOMFileSystem::EntryType entry_type =\n         is_directory ? blink::WebDOMFileSystem::EntryTypeDirectory\n                      : blink::WebDOMFileSystem::EntryTypeFile;\n     blink::WebLocalFrame* webframe =\n        blink::WebLocalFrame::frameForContext(context()->v8_context());\n     args.GetReturnValue().Set(\n         blink::WebDOMFileSystem::create(\n             webframe,\n            blink::WebFileSystemTypeExternal,\n            blink::WebString::fromUTF8(file_system_name),\n            file_system_root)\n            .createV8Entry(blink::WebString::fromUTF8(file_full_path),\n                           entry_type,\n                           args.Holder(),\n                           args.GetIsolate()));\n #endif\n }\n", "target": 1, "idx": 187295}
{"func": "static void decode_sce_lfe(NeAACDecStruct *hDecoder,\n                           NeAACDecFrameInfo *hInfo, bitfile *ld,\n                           uint8_t id_syn_ele)\n{\n    uint8_t channels = hDecoder->fr_channels;\n    uint8_t tag = 0;\n\n    if (channels+1 > MAX_CHANNELS)\n    {\n        hInfo->error = 12;\n        return;\n    }\n    if (hDecoder->fr_ch_ele+1 > MAX_SYNTAX_ELEMENTS)\n    {\n        hInfo->error = 13;\n        return;\n    }\n\n    /* for SCE hDecoder->element_output_channels[] is not set here because this\n       can become 2 when some form of Parametric Stereo coding is used\n    */\n\n    if (hDecoder->frame && hDecoder->element_id[hDecoder->fr_ch_ele] != id_syn_ele) {\n        /* element inconsistency */\n        hInfo->error = 21;\n        return;\n    }\n\n    /* save the syntax element id */\n    hDecoder->element_id[hDecoder->fr_ch_ele] = id_syn_ele;\n\n    /* decode the element */\n    hInfo->error = single_lfe_channel_element(hDecoder, ld, channels, &tag);\n\n    /* map output channels position to internal data channels */\n    if (hDecoder->element_output_channels[hDecoder->fr_ch_ele] == 2)\n    {\n        /* this might be faulty when pce_set is true */\n        hDecoder->internal_channel[channels] = channels;\n        hDecoder->internal_channel[channels+1] = channels+1;\n    } else {\n        if (hDecoder->pce_set)\n            hDecoder->internal_channel[hDecoder->pce.sce_channel[tag]] = channels;\n        else\n            hDecoder->internal_channel[channels] = channels;\n    }\n\n    hDecoder->fr_channels += hDecoder->element_output_channels[hDecoder->fr_ch_ele];\n    hDecoder->fr_ch_ele++;\n}\n", "target": 0, "idx": 88376}
{"func": "PageInfoUI::GetSecurityDescription(const IdentityInfo& identity_info) const {\n   std::unique_ptr<PageInfoUI::SecurityDescription> security_description(\n       new PageInfoUI::SecurityDescription());\n \n  switch (identity_info.safe_browsing_status) {\n    case PageInfo::SAFE_BROWSING_STATUS_NONE:\n      break;\n    case PageInfo::SAFE_BROWSING_STATUS_MALWARE:\n      return CreateSecurityDescription(SecuritySummaryColor::RED,\n                                       IDS_PAGE_INFO_MALWARE_SUMMARY,\n                                       IDS_PAGE_INFO_MALWARE_DETAILS);\n    case PageInfo::SAFE_BROWSING_STATUS_SOCIAL_ENGINEERING:\n      return CreateSecurityDescription(\n          SecuritySummaryColor::RED, IDS_PAGE_INFO_SOCIAL_ENGINEERING_SUMMARY,\n          IDS_PAGE_INFO_SOCIAL_ENGINEERING_DETAILS);\n    case PageInfo::SAFE_BROWSING_STATUS_UNWANTED_SOFTWARE:\n      return CreateSecurityDescription(SecuritySummaryColor::RED,\n                                       IDS_PAGE_INFO_UNWANTED_SOFTWARE_SUMMARY,\n                                       IDS_PAGE_INFO_UNWANTED_SOFTWARE_DETAILS);\n    case PageInfo::SAFE_BROWSING_STATUS_SIGN_IN_PASSWORD_REUSE:\n#if defined(FULL_SAFE_BROWSING)\n      return CreateSecurityDescriptionForPasswordReuse(\n          /*is_enterprise_password=*/false);\n#endif\n      NOTREACHED();\n      break;\n    case PageInfo::SAFE_BROWSING_STATUS_ENTERPRISE_PASSWORD_REUSE:\n#if defined(FULL_SAFE_BROWSING)\n      return CreateSecurityDescriptionForPasswordReuse(\n          /*is_enterprise_password=*/true);\n#endif\n      NOTREACHED();\n      break;\n    case PageInfo::SAFE_BROWSING_STATUS_BILLING:\n      return CreateSecurityDescription(SecuritySummaryColor::RED,\n                                       IDS_PAGE_INFO_BILLING_SUMMARY,\n                                       IDS_PAGE_INFO_BILLING_DETAILS);\n  }\n   switch (identity_info.identity_status) {\n     case PageInfo::SITE_IDENTITY_STATUS_INTERNAL_PAGE:\n #if defined(OS_ANDROID)\n      return CreateSecurityDescription(SecuritySummaryColor::GREEN,\n                                       IDS_PAGE_INFO_INTERNAL_PAGE,\n                                       IDS_PAGE_INFO_INTERNAL_PAGE);\n#else\n      NOTREACHED();\n      FALLTHROUGH;\n#endif\n    case PageInfo::SITE_IDENTITY_STATUS_EV_CERT:\n      FALLTHROUGH;\n    case PageInfo::SITE_IDENTITY_STATUS_CERT:\n      FALLTHROUGH;\n    case PageInfo::SITE_IDENTITY_STATUS_CERT_REVOCATION_UNKNOWN:\n      FALLTHROUGH;\n    case PageInfo::SITE_IDENTITY_STATUS_ADMIN_PROVIDED_CERT:\n      switch (identity_info.connection_status) {\n        case PageInfo::SITE_CONNECTION_STATUS_INSECURE_ACTIVE_SUBRESOURCE:\n          return CreateSecurityDescription(SecuritySummaryColor::RED,\n                                           IDS_PAGE_INFO_NOT_SECURE_SUMMARY,\n                                           IDS_PAGE_INFO_NOT_SECURE_DETAILS);\n        case PageInfo::SITE_CONNECTION_STATUS_INSECURE_FORM_ACTION:\n          return CreateSecurityDescription(SecuritySummaryColor::RED,\n                                           IDS_PAGE_INFO_MIXED_CONTENT_SUMMARY,\n                                           IDS_PAGE_INFO_NOT_SECURE_DETAILS);\n        case PageInfo::SITE_CONNECTION_STATUS_INSECURE_PASSIVE_SUBRESOURCE:\n          return CreateSecurityDescription(SecuritySummaryColor::RED,\n                                           IDS_PAGE_INFO_MIXED_CONTENT_SUMMARY,\n                                           IDS_PAGE_INFO_MIXED_CONTENT_DETAILS);\n        default:\n          return CreateSecurityDescription(SecuritySummaryColor::GREEN,\n                                            IDS_PAGE_INFO_SECURE_SUMMARY,\n                                            IDS_PAGE_INFO_SECURE_DETAILS);\n       }\n     case PageInfo::SITE_IDENTITY_STATUS_DEPRECATED_SIGNATURE_ALGORITHM:\n     case PageInfo::SITE_IDENTITY_STATUS_UNKNOWN:\n     case PageInfo::SITE_IDENTITY_STATUS_NO_CERT:\n    default:\n      return CreateSecurityDescription(SecuritySummaryColor::RED,\n                                       IDS_PAGE_INFO_NOT_SECURE_SUMMARY,\n                                       IDS_PAGE_INFO_NOT_SECURE_DETAILS);\n  }\n}\n", "target": 1, "idx": 186408}
{"func": "fbStore_x1r5g5b5 (FbBits *bits, const CARD32 *values, int x, int width, miIndexedPtr indexed)\n{\n    int i;\n    CARD16  *pixel = ((CARD16 *) bits) + x;\n    for (i = 0; i < width; ++i) {\n        Split(READ(values + i));\n        WRITE(pixel++, ((r << 7) & 0x7c00) |\n\t      ((g << 2) & 0x03e0) |\n\t      ((b >> 3)         ));\n    }\n}\n", "target": 0, "idx": 11490}
{"func": "coolkey_v1_get_attribute_record_len(const u8 *attr, size_t buf_len)\n{\n\tsize_t attribute_len = sizeof(coolkey_attribute_header_t);\n\tsize_t len = 0;\n\tint r;\n\n\tr = coolkey_v1_get_attribute_len(attr, buf_len, &len, 1);\n\tif (r < 0) {\n\t\treturn buf_len; /* skip to the end, ignore the rest of the record */\n\t}\n\n\treturn MIN(buf_len,attribute_len+len);\n}\n", "target": 0, "idx": 78325}
{"func": "struct net_bridge_mdb_entry *br_mdb_get(struct net_bridge *br,\n\t\t\t\t\tstruct sk_buff *skb, u16 vid)\n{\n\tstruct net_bridge_mdb_htable *mdb = rcu_dereference(br->mdb);\n\tstruct br_ip ip;\n\n\tif (br->multicast_disabled)\n\t\treturn NULL;\n\n\tif (BR_INPUT_SKB_CB(skb)->igmp)\n\t\treturn NULL;\n\n\tip.proto = skb->protocol;\n\tip.vid = vid;\n\n\tswitch (skb->protocol) {\n\tcase htons(ETH_P_IP):\n\t\tip.u.ip4 = ip_hdr(skb)->daddr;\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase htons(ETH_P_IPV6):\n\t\tip.u.ip6 = ipv6_hdr(skb)->daddr;\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn NULL;\n\t}\n\n\treturn br_mdb_ip_get(mdb, &ip);\n}\n", "target": 0, "idx": 30002}
{"func": "xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,\n const char *msg,\n const xmlChar * info1, const xmlChar * info2,\n const xmlChar * info3)\n{\n if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&\n (ctxt->instate == XML_PARSER_EOF))\n return;\n if (ctxt != NULL)\n\tctxt->errNo = error;\n    __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_NAMESPACE, error,\n                    XML_ERR_ERROR, NULL, 0, (const char *) info1,\n (const char *) info2, (const char *) info3, 0, 0, msg,\n                    info1, info2, info3);\n if (ctxt != NULL)\n\tctxt->nsWellFormed = 0;\n}\n", "target": 0, "idx": 176598}
{"func": "LIBOPENMPT_MODPLUG_API void ModPlug_UnloadMixerCallback(ModPlugFile* file)\n{\n\tif(!file) return;\n\tfile->mixerproc = NULL;\n\tif(file->mixerbuf){\n\t\tfree(file->mixerbuf);\n\t\tfile->mixerbuf = NULL;\n\t}\n}\n", "target": 0, "idx": 87651}
{"func": "hook_process_child (struct t_hook *hook_process)\n{\n    char *exec_args[4] = { \"sh\", \"-c\", NULL, NULL };\n    \n    /*\n     * close stdin, so that process will fail to read stdin (process reading\n     * stdin should not be run inside WeeChat!)\n     */\n    close (STDIN_FILENO);\n    \n    /* redirect stdout/stderr to pipe (so that father process can read them) */\n    close (HOOK_PROCESS(hook_process, child_read[HOOK_PROCESS_STDOUT]));\n    close (HOOK_PROCESS(hook_process, child_read[HOOK_PROCESS_STDERR]));\n    if (dup2 (HOOK_PROCESS(hook_process, child_write[HOOK_PROCESS_STDOUT]),\n              STDOUT_FILENO) < 0)\n    {\n        _exit (EXIT_FAILURE);\n    }\n    if (dup2 (HOOK_PROCESS(hook_process, child_write[HOOK_PROCESS_STDERR]),\n              STDERR_FILENO) < 0)\n    {\n        _exit (EXIT_FAILURE);\n    }\n    \n    /* launch command */\n    exec_args[2] = HOOK_PROCESS(hook_process, command);\n    execvp (exec_args[0], exec_args);\n    \n    /* should not be executed if execvp was ok */\n    fprintf (stderr, \"Error with command '%s'\\n\",\n             HOOK_PROCESS(hook_process, command));\n    _exit (EXIT_FAILURE);\n}\n", "target": 0, "idx": 3429}
{"func": "void FrameLoader::loadArchive(PassRefPtr<Archive> prpArchive)\n{\n    RefPtr<Archive> archive = prpArchive;\n    \n    ArchiveResource* mainResource = archive->mainResource();\n    ASSERT(mainResource);\n    if (!mainResource)\n        return;\n        \n    SubstituteData substituteData(mainResource->data(), mainResource->mimeType(), mainResource->textEncoding(), KURL());\n    \n    ResourceRequest request(mainResource->url());\n#if PLATFORM(MAC)\n    request.applyWebArchiveHackForMail();\n#endif\n\n    RefPtr<DocumentLoader> documentLoader = m_client->createDocumentLoader(request, substituteData);\n    documentLoader->addAllArchiveResources(archive.get());\n    load(documentLoader.get());\n}\n", "target": 0, "idx": 97435}
{"func": "void SkiaOutputSurfaceImplTest::UnblockMainThread() {\n  DCHECK(!wait_.IsSignaled());\n  wait_.Signal();\n}\n", "target": 0, "idx": 148687}
{"func": "void UnloadController::TabDetachedAt(TabContents* contents, int index) {\n   TabDetachedImpl(contents);\n }\n", "target": 1, "idx": 185222}
{"func": "AddLedMap(CompatInfo *info, LedInfo *new, bool same_file)\n{\n    enum led_field collide;\n    const int verbosity = xkb_context_get_log_verbosity(info->ctx);\n    const bool report = (same_file && verbosity > 0) || verbosity > 9;\n\n    for (xkb_led_index_t i = 0; i < info->num_leds; i++) {\n        LedInfo *old = &info->leds[i];\n\n        if (old->led.name != new->led.name)\n            continue;\n\n        if (old->led.mods.mods == new->led.mods.mods &&\n            old->led.groups == new->led.groups &&\n            old->led.ctrls == new->led.ctrls &&\n            old->led.which_mods == new->led.which_mods &&\n            old->led.which_groups == new->led.which_groups) {\n            old->defined |= new->defined;\n            return true;\n        }\n\n        if (new->merge == MERGE_REPLACE) {\n            if (report)\n                log_warn(info->ctx,\n                         \"Map for indicator %s redefined; \"\n                         \"Earlier definition ignored\\n\",\n                         xkb_atom_text(info->ctx, old->led.name));\n            *old = *new;\n            return true;\n        }\n\n        collide = 0;\n        if (UseNewLEDField(LED_FIELD_MODS, old, new, report, &collide)) {\n            old->led.which_mods = new->led.which_mods;\n            old->led.mods = new->led.mods;\n            old->defined |= LED_FIELD_MODS;\n        }\n        if (UseNewLEDField(LED_FIELD_GROUPS, old, new, report, &collide)) {\n            old->led.which_groups = new->led.which_groups;\n            old->led.groups = new->led.groups;\n            old->defined |= LED_FIELD_GROUPS;\n        }\n        if (UseNewLEDField(LED_FIELD_CTRLS, old, new, report, &collide)) {\n            old->led.ctrls = new->led.ctrls;\n            old->defined |= LED_FIELD_CTRLS;\n        }\n\n        if (collide) {\n            log_warn(info->ctx,\n                     \"Map for indicator %s redefined; \"\n                     \"Using %s definition for duplicate fields\\n\",\n                     xkb_atom_text(info->ctx, old->led.name),\n                     (new->merge == MERGE_AUGMENT ? \"first\" : \"last\"));\n        }\n\n        return true;\n    }\n\n    if (info->num_leds >= XKB_MAX_LEDS) {\n        log_err(info->ctx,\n                \"Too many LEDs defined (maximum %d)\\n\",\n                XKB_MAX_LEDS);\n        return false;\n    }\n    info->leds[info->num_leds++] = *new;\n    return true;\n}\n", "target": 0, "idx": 78918}
{"func": "int fix_log_file_owner(uid_t uid, gid_t gid)\n{\n\tint r1 = 0, r2 = 0;\n\n\tif (!(log_fp = open_log_file()))\n\t\treturn -1;\n\tr1 = fchown(fileno(log_fp), uid, gid);\n\n\tif (open_debug_log() != OK)\n\t\treturn -1;\n\tif (debug_file_fp)\n\t\tr2 = fchown(fileno(debug_file_fp), uid, gid);\n\n\t/* return 0 if both are 0 and otherwise < 0 */\n\treturn r1 < r2 ? r1 : r2;\n}\n", "target": 0, "idx": 48161}
{"func": " void HTMLImportsController::Dispose() {\n  for (const auto& loader : loaders_)\n    loader->Dispose();\n  loaders_.clear();\n \n   if (root_) {\n     root_->Dispose();\n    root_.Clear();\n  }\n}\n", "target": 1, "idx": 186640}
{"func": "bool isJavaPackageName(const StringPiece16& str) {\n if (str.empty()) {\n return false;\n }\n\n size_t pieces = 0;\n for (const StringPiece16& piece : tokenize(str, u'.')) {\n        pieces++;\n if (piece.empty()) {\n return false;\n }\n\n if (piece.data()[0] == u'_' || piece.data()[piece.size() - 1] == u'_') {\n return false;\n }\n\n if (findNonAlphaNumericAndNotInSet(piece, u\"_\") != piece.end()) {\n return false;\n }\n }\n return pieces >= 1;\n}\n", "target": 0, "idx": 176820}
{"func": "resetLppTransposer (HANDLE_SBR_LPP_TRANS hLppTrans, /*!< Handle of lpp transposer  */\n                    UCHAR  highBandStartSb, /*!< High band area: start subband */\n                    UCHAR *v_k_master, /*!< Master table */\n                    UCHAR  numMaster, /*!< Valid entries in master table */\n                    UCHAR *noiseBandTable, /*!< Mapping of SBR noise bands to QMF bands */\n                    UCHAR  noNoiseBands, /*!< Number of noise bands */\n                    UCHAR  usb, /*!< High band area: stop subband */\n                    UINT   fs                        /*!< SBR output sampling frequency */\n )\n{\n  TRANSPOSER_SETTINGS *pSettings = hLppTrans->pSettings;\n  PATCH_PARAM  *patchParam = pSettings->patchParam;\n\n int i, patch;\n int targetStopBand;\n int sourceStartBand;\n int patchDistance;\n int numBandsInPatch;\n\n int lsb = v_k_master[0]; /* Start subband expressed in \"non-critical\" sampling terms*/\n int xoverOffset = highBandStartSb - lsb; /* Calculate distance in QMF bands between k0 and kx */\n int startFreqHz;\n\n int desiredBorder;\n\n  usb = fixMin(usb, v_k_master[numMaster]); /* Avoid endless loops (compare with float code). */\n\n /*\n   * Plausibility check\n   */\n\n if ( lsb - SHIFT_START_SB < 4 ) {\n return SBRDEC_UNSUPPORTED_CONFIG;\n }\n\n\n /*\n   * Initialize the patching parameter\n   */\n /* ISO/IEC 14496-3 (Figure 4.48): goalSb = round( 2.048e6 / fs ) */\n  desiredBorder    = (((2048000*2) / fs) + 1) >> 1;\n\n  desiredBorder = findClosestEntry(desiredBorder, v_k_master, numMaster, 1); /* Adapt region to master-table */\n\n /* First patch */\n  sourceStartBand = SHIFT_START_SB + xoverOffset;\n  targetStopBand = lsb + xoverOffset; /* upperBand */\n\n /* Even (odd) numbered channel must be patched to even (odd) numbered channel */\n  patch = 0;\n while(targetStopBand < usb) {\n\n /* Too many patches?\n       Allow MAX_NUM_PATCHES+1 patches here.\n       we need to check later again, since patch might be the highest patch\n       AND contain less than 3 bands => actual number of patches will be reduced by 1.\n    */\n if (patch > MAX_NUM_PATCHES) {\n return SBRDEC_UNSUPPORTED_CONFIG;\n }\n\n    patchParam[patch].guardStartBand = targetStopBand;\n    patchParam[patch].targetStartBand = targetStopBand;\n\n    numBandsInPatch = desiredBorder - targetStopBand; /* Get the desired range of the patch */\n\n if ( numBandsInPatch >= lsb - sourceStartBand ) {\n /* Desired number bands are not available -> patch whole source range */\n      patchDistance   = targetStopBand - sourceStartBand; /* Get the targetOffset */\n      patchDistance   = patchDistance & ~1; /* Rounding off odd numbers and make all even */\n      numBandsInPatch = lsb - (targetStopBand - patchDistance); /* Update number of bands to be patched */\n      numBandsInPatch = findClosestEntry(targetStopBand + numBandsInPatch, v_k_master, numMaster, 0) -\n                        targetStopBand; /* Adapt region to master-table */\n }\n\n /* Desired number bands are available -> get the minimal even patching distance */\n    patchDistance   = numBandsInPatch + targetStopBand - lsb; /* Get minimal distance */\n    patchDistance   = (patchDistance + 1) & ~1; /* Rounding up odd numbers and make all even */\n\n if (numBandsInPatch > 0) {\n      patchParam[patch].sourceStartBand = targetStopBand - patchDistance;\n      patchParam[patch].targetBandOffs  = patchDistance;\n      patchParam[patch].numBandsInPatch = numBandsInPatch;\n      patchParam[patch].sourceStopBand  = patchParam[patch].sourceStartBand + numBandsInPatch;\n\n      targetStopBand += patchParam[patch].numBandsInPatch;\n      patch++;\n }\n\n /* All patches but first */\n    sourceStartBand = SHIFT_START_SB;\n\n /* Check if we are close to desiredBorder */\n if( desiredBorder - targetStopBand < 3) /* MPEG doc */\n {\n      desiredBorder = usb;\n }\n\n }\n\n  patch--;\n\n /* If highest patch contains less than three subband: skip it */\n if ( (patch>0) && (patchParam[patch].numBandsInPatch < 3) ) {\n    patch--;\n    targetStopBand = patchParam[patch].targetStartBand + patchParam[patch].numBandsInPatch;\n }\n\n /* now check if we don't have one too many */\n if (patch >= MAX_NUM_PATCHES) {\n return SBRDEC_UNSUPPORTED_CONFIG;\n }\n\n  pSettings->noOfPatches = patch + 1;\n\n /* Check lowest and highest source subband */\n  pSettings->lbStartPatching = targetStopBand;\n  pSettings->lbStopPatching  = 0;\n for ( patch = 0; patch < pSettings->noOfPatches; patch++ ) {\n    pSettings->lbStartPatching = fixMin( pSettings->lbStartPatching, patchParam[patch].sourceStartBand );\n    pSettings->lbStopPatching  = fixMax( pSettings->lbStopPatching, patchParam[patch].sourceStopBand );\n }\n\n\n   for(i = 0 ; i < noNoiseBands; i++){\n     pSettings->bwBorders[i] = noiseBandTable[i+1];\n   }\n \n   /*\n    * Choose whitening factors\n   */\n\n  startFreqHz = ( (lsb + xoverOffset)*fs ) >> 7; /* Shift does a division by 2*(64) */\n\n for( i = 1; i < NUM_WHFACTOR_TABLE_ENTRIES; i++ )\n {\n if( startFreqHz < FDK_sbrDecoder_sbr_whFactorsIndex[i])\n break;\n }\n  i--;\n\n  pSettings->whFactors.off = FDK_sbrDecoder_sbr_whFactorsTable[i][0];\n  pSettings->whFactors.transitionLevel = FDK_sbrDecoder_sbr_whFactorsTable[i][1];\n  pSettings->whFactors.lowLevel = FDK_sbrDecoder_sbr_whFactorsTable[i][2];\n  pSettings->whFactors.midLevel = FDK_sbrDecoder_sbr_whFactorsTable[i][3];\n  pSettings->whFactors.highLevel = FDK_sbrDecoder_sbr_whFactorsTable[i][4];\n\n return SBRDEC_OK;\n}\n", "target": 1, "idx": 188136}
{"func": "int fib6_add(struct fib6_node *root, struct rt6_info *rt, struct nl_info *info)\n{\n\tstruct fib6_node *fn, *pn = NULL;\n\tint err = -ENOMEM;\n\tint allow_create = 1;\n\tint replace_required = 0;\n\n\tif (info->nlh) {\n\t\tif (!(info->nlh->nlmsg_flags & NLM_F_CREATE))\n\t\t\tallow_create = 0;\n\t\tif (info->nlh->nlmsg_flags & NLM_F_REPLACE)\n\t\t\treplace_required = 1;\n\t}\n\tif (!allow_create && !replace_required)\n\t\tpr_warn(\"RTM_NEWROUTE with no NLM_F_CREATE or NLM_F_REPLACE\\n\");\n\n\tfn = fib6_add_1(root, &rt->rt6i_dst.addr, sizeof(struct in6_addr),\n\t\t\trt->rt6i_dst.plen, offsetof(struct rt6_info, rt6i_dst),\n\t\t\tallow_create, replace_required);\n\n\tif (IS_ERR(fn)) {\n\t\terr = PTR_ERR(fn);\n\t\tgoto out;\n\t}\n\n\tpn = fn;\n\n#ifdef CONFIG_IPV6_SUBTREES\n\tif (rt->rt6i_src.plen) {\n\t\tstruct fib6_node *sn;\n\n\t\tif (!fn->subtree) {\n\t\t\tstruct fib6_node *sfn;\n\n\t\t\t/*\n\t\t\t * Create subtree.\n\t\t\t *\n\t\t\t *\t\tfn[main tree]\n\t\t\t *\t\t|\n\t\t\t *\t\tsfn[subtree root]\n\t\t\t *\t\t   \\\n\t\t\t *\t\t    sn[new leaf node]\n\t\t\t */\n\n\t\t\t/* Create subtree root node */\n\t\t\tsfn = node_alloc();\n\t\t\tif (!sfn)\n\t\t\t\tgoto st_failure;\n\n\t\t\tsfn->leaf = info->nl_net->ipv6.ip6_null_entry;\n\t\t\tatomic_inc(&info->nl_net->ipv6.ip6_null_entry->rt6i_ref);\n\t\t\tsfn->fn_flags = RTN_ROOT;\n\t\t\tsfn->fn_sernum = fib6_new_sernum();\n\n\t\t\t/* Now add the first leaf node to new subtree */\n\n\t\t\tsn = fib6_add_1(sfn, &rt->rt6i_src.addr,\n\t\t\t\t\tsizeof(struct in6_addr), rt->rt6i_src.plen,\n\t\t\t\t\toffsetof(struct rt6_info, rt6i_src),\n\t\t\t\t\tallow_create, replace_required);\n\n\t\t\tif (IS_ERR(sn)) {\n\t\t\t\t/* If it is failed, discard just allocated\n\t\t\t\t   root, and then (in st_failure) stale node\n\t\t\t\t   in main tree.\n\t\t\t\t */\n\t\t\t\tnode_free(sfn);\n\t\t\t\terr = PTR_ERR(sn);\n\t\t\t\tgoto st_failure;\n\t\t\t}\n\n\t\t\t/* Now link new subtree to main tree */\n\t\t\tsfn->parent = fn;\n\t\t\tfn->subtree = sfn;\n\t\t} else {\n\t\t\tsn = fib6_add_1(fn->subtree, &rt->rt6i_src.addr,\n\t\t\t\t\tsizeof(struct in6_addr), rt->rt6i_src.plen,\n\t\t\t\t\toffsetof(struct rt6_info, rt6i_src),\n\t\t\t\t\tallow_create, replace_required);\n\n\t\t\tif (IS_ERR(sn)) {\n\t\t\t\terr = PTR_ERR(sn);\n\t\t\t\tgoto st_failure;\n\t\t\t}\n\t\t}\n\n\t\tif (!fn->leaf) {\n\t\t\tfn->leaf = rt;\n\t\t\tatomic_inc(&rt->rt6i_ref);\n\t\t}\n\t\tfn = sn;\n\t}\n#endif\n\n\terr = fib6_add_rt2node(fn, rt, info);\n\tif (!err) {\n\t\tfib6_start_gc(info->nl_net, rt);\n\t\tif (!(rt->rt6i_flags & RTF_CACHE))\n\t\t\tfib6_prune_clones(info->nl_net, pn, rt);\n\t}\n\nout:\n\tif (err) {\n#ifdef CONFIG_IPV6_SUBTREES\n\t\t/*\n\t\t * If fib6_add_1 has cleared the old leaf pointer in the\n\t\t * super-tree leaf node we have to find a new one for it.\n\t\t */\n\t\tif (pn != fn && pn->leaf == rt) {\n\t\t\tpn->leaf = NULL;\n\t\t\tatomic_dec(&rt->rt6i_ref);\n\t\t}\n\t\tif (pn != fn && !pn->leaf && !(pn->fn_flags & RTN_RTINFO)) {\n\t\t\tpn->leaf = fib6_find_prefix(info->nl_net, pn);\n#if RT6_DEBUG >= 2\n\t\t\tif (!pn->leaf) {\n\t\t\t\tWARN_ON(pn->leaf == NULL);\n\t\t\t\tpn->leaf = info->nl_net->ipv6.ip6_null_entry;\n\t\t\t}\n#endif\n\t\t\tatomic_inc(&pn->leaf->rt6i_ref);\n\t\t}\n#endif\n\t\tdst_free(&rt->dst);\n\t}\n\treturn err;\n\n#ifdef CONFIG_IPV6_SUBTREES\n\t/* Subtree creation failed, probably main tree node\n\t   is orphan. If it is, shoot it.\n\t */\nst_failure:\n\tif (fn && !(fn->fn_flags & (RTN_RTINFO|RTN_ROOT)))\n\t\tfib6_repair_tree(info->nl_net, fn);\n\tdst_free(&rt->dst);\n\treturn err;\n#endif\n}\n", "target": 0, "idx": 30065}
{"func": "static void queue_release_one_tty(struct kref *kref)\n{\n\tstruct tty_struct *tty = container_of(kref, struct tty_struct, kref);\n\n\t/* The hangup queue is now free so we can reuse it rather than\n\t   waste a chunk of memory for each port */\n\tINIT_WORK(&tty->hangup_work, release_one_tty);\n\tschedule_work(&tty->hangup_work);\n}\n", "target": 0, "idx": 55878}
{"func": "int ssl_cert_type(const X509 *x, const EVP_PKEY *pk)\n{\n    if (pk == NULL && (pk = X509_get0_pubkey(x)) == NULL)\n        return -1;\n\n    switch (EVP_PKEY_id(pk)) {\n    default:\n        return -1;\n    case EVP_PKEY_RSA:\n        return SSL_PKEY_RSA_ENC;\n    case EVP_PKEY_DSA:\n        return SSL_PKEY_DSA_SIGN;\n#ifndef OPENSSL_NO_EC\n    case EVP_PKEY_EC:\n        return SSL_PKEY_ECC;\n#endif\n#ifndef OPENSSL_NO_GOST\n    case NID_id_GostR3410_2001:\n        return SSL_PKEY_GOST01;\n    case NID_id_GostR3410_2012_256:\n        return SSL_PKEY_GOST12_256;\n    case NID_id_GostR3410_2012_512:\n        return SSL_PKEY_GOST12_512;\n#endif\n    }\n}\n", "target": 0, "idx": 12717}
{"func": "HTMLElement* HTMLInputElement::innerBlockElement() const\n{\n    return m_inputType->innerBlockElement();\n}\n", "target": 0, "idx": 121162}
{"func": "static int decode_create(struct xdr_stream *xdr, struct nfs4_change_info *cinfo)\n{\n\t__be32 *p;\n\tuint32_t bmlen;\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_CREATE);\n\tif (status)\n\t\treturn status;\n\tif ((status = decode_change_info(xdr, cinfo)))\n\t\treturn status;\n\tREAD_BUF(4);\n\tREAD32(bmlen);\n\tREAD_BUF(bmlen << 2);\n\treturn 0;\n}\n", "target": 0, "idx": 23014}
{"func": "vips_tracked_malloc( size_t size )\n{\n        void *buf;\n\n\tvips_tracked_init(); \n\n\t/* Need an extra sizeof(size_t) bytes to track \n\t * size of this block. Ask for an extra 16 to make sure we don't break\n\t * alignment rules.\n \t */\n \tsize += 16;\n \n        if( !(buf = g_try_malloc( size )) ) {\n #ifdef DEBUG\n \t\tg_assert_not_reached();\n #endif /*DEBUG*/\n\n\t\tvips_error( \"vips_tracked\", \n\t\t\t_( \"out of memory --- size == %dMB\" ), \n\t\t\t(int) (size / (1024.0 * 1024.0))  );\n\t\tg_warning( _( \"out of memory --- size == %dMB\" ), \n\t\t\t(int) (size / (1024.0 * 1024.0))  );\n\n                return( NULL );\n\t}\n\n\tg_mutex_lock( vips_tracked_mutex );\n\n\t*((size_t *)buf) = size;\n\tbuf = (void *) ((char *)buf + 16);\n\n\tvips_tracked_mem += size;\n\tif( vips_tracked_mem > vips_tracked_mem_highwater ) \n\t\tvips_tracked_mem_highwater = vips_tracked_mem;\n\tvips_tracked_allocs += 1;\n\n#ifdef DEBUG_VERBOSE\n\tprintf( \"vips_tracked_malloc: %p, %zd bytes\\n\", buf, size ); \n#endif /*DEBUG_VERBOSE*/\n\n\tg_mutex_unlock( vips_tracked_mutex );\n\n\tVIPS_GATE_MALLOC( size ); \n\n        return( buf );\n}\n", "target": 1, "idx": 182912}
{"func": "struct sctp_association *sctp_id2assoc(struct sock *sk, sctp_assoc_t id)\n{\n\tstruct sctp_association *asoc = NULL;\n\n\t/* If this is not a UDP-style socket, assoc id should be ignored. */\n\tif (!sctp_style(sk, UDP)) {\n\t\t/* Return NULL if the socket state is not ESTABLISHED. It\n\t\t * could be a TCP-style listening socket or a socket which\n\t\t * hasn't yet called connect() to establish an association.\n\t\t */\n\t\tif (!sctp_sstate(sk, ESTABLISHED) && !sctp_sstate(sk, CLOSING))\n\t\t\treturn NULL;\n\n\t\t/* Get the first and the only association from the list. */\n\t\tif (!list_empty(&sctp_sk(sk)->ep->asocs))\n\t\t\tasoc = list_entry(sctp_sk(sk)->ep->asocs.next,\n\t\t\t\t\t  struct sctp_association, asocs);\n\t\treturn asoc;\n\t}\n\n\t/* Otherwise this is a UDP-style socket. */\n\tif (!id || (id == (sctp_assoc_t)-1))\n\t\treturn NULL;\n\n\tspin_lock_bh(&sctp_assocs_id_lock);\n\tasoc = (struct sctp_association *)idr_find(&sctp_assocs_id, (int)id);\n\tspin_unlock_bh(&sctp_assocs_id_lock);\n\n\tif (!asoc || (asoc->base.sk != sk) || asoc->base.dead)\n\t\treturn NULL;\n\n\treturn asoc;\n}\n", "target": 0, "idx": 60679}
{"func": "int phar_get_entry_data(phar_entry_data **ret, char *fname, int fname_len, char *path, int path_len, char *mode, char allow_dir, char **error, int security TSRMLS_DC) /* {{{ */\n{\n\tphar_archive_data *phar;\n\tphar_entry_info *entry;\n\tint for_write  = mode[0] != 'r' || mode[1] == '+';\n\tint for_append = mode[0] == 'a';\n\tint for_create = mode[0] != 'r';\n\tint for_trunc  = mode[0] == 'w';\n\n\tif (!ret) {\n\t\treturn FAILURE;\n\t}\n\n\t*ret = NULL;\n\n\tif (error) {\n\t\t*error = NULL;\n\t}\n\n\tif (FAILURE == phar_get_archive(&phar, fname, fname_len, NULL, 0, error TSRMLS_CC)) {\n\t\treturn FAILURE;\n\t}\n\n\tif (for_write && PHAR_G(readonly) && !phar->is_data) {\n\t\tif (error) {\n\t\t\tspprintf(error, 4096, \"phar error: file \\\"%s\\\" in phar \\\"%s\\\" cannot be opened for writing, disabled by ini setting\", path, fname);\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tif (!path_len) {\n\t\tif (error) {\n\t\t\tspprintf(error, 4096, \"phar error: file \\\"\\\" in phar \\\"%s\\\" cannot be empty\", fname);\n\t\t}\n\t\treturn FAILURE;\n\t}\nreally_get_entry:\n\tif (allow_dir) {\n\t\tif ((entry = phar_get_entry_info_dir(phar, path, path_len, allow_dir, for_create && !PHAR_G(readonly) && !phar->is_data ? NULL : error, security TSRMLS_CC)) == NULL) {\n\t\t\tif (for_create && (!PHAR_G(readonly) || phar->is_data)) {\n\t\t\t\treturn SUCCESS;\n\t\t\t}\n\t\t\treturn FAILURE;\n\t\t}\n\t} else {\n\t\tif ((entry = phar_get_entry_info(phar, path, path_len, for_create && !PHAR_G(readonly) && !phar->is_data ? NULL : error, security TSRMLS_CC)) == NULL) {\n\t\t\tif (for_create && (!PHAR_G(readonly) || phar->is_data)) {\n\t\t\t\treturn SUCCESS;\n\t\t\t}\n\t\t\treturn FAILURE;\n\t\t}\n\t}\n\n\tif (for_write && phar->is_persistent) {\n\t\tif (FAILURE == phar_copy_on_write(&phar TSRMLS_CC)) {\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 4096, \"phar error: file \\\"%s\\\" in phar \\\"%s\\\" cannot be opened for writing, could not make cached phar writeable\", path, fname);\n\t\t\t}\n\t\t\treturn FAILURE;\n\t\t} else {\n\t\t\tgoto really_get_entry;\n\t\t}\n\t}\n\n\tif (entry->is_modified && !for_write) {\n\t\tif (error) {\n\t\t\tspprintf(error, 4096, \"phar error: file \\\"%s\\\" in phar \\\"%s\\\" cannot be opened for reading, writable file pointers are open\", path, fname);\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tif (entry->fp_refcount && for_write) {\n\t\tif (error) {\n\t\t\tspprintf(error, 4096, \"phar error: file \\\"%s\\\" in phar \\\"%s\\\" cannot be opened for writing, readable file pointers are open\", path, fname);\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tif (entry->is_deleted) {\n\t\tif (!for_create) {\n\t\t\treturn FAILURE;\n\t\t}\n\t\tentry->is_deleted = 0;\n\t}\n\n\tif (entry->is_dir) {\n\t\t*ret = (phar_entry_data *) emalloc(sizeof(phar_entry_data));\n\t\t(*ret)->position = 0;\n\t\t(*ret)->fp = NULL;\n\t\t(*ret)->phar = phar;\n\t\t(*ret)->for_write = for_write;\n\t\t(*ret)->internal_file = entry;\n\t\t(*ret)->is_zip = entry->is_zip;\n\t\t(*ret)->is_tar = entry->is_tar;\n\n\t\tif (!phar->is_persistent) {\n\t\t\t++(entry->phar->refcount);\n\t\t\t++(entry->fp_refcount);\n\t\t}\n\n\t\treturn SUCCESS;\n\t}\n\n\tif (entry->fp_type == PHAR_MOD) {\n\t\tif (for_trunc) {\n\t\t\tif (FAILURE == phar_create_writeable_entry(phar, entry, error TSRMLS_CC)) {\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t} else if (for_append) {\n\t\t\tphar_seek_efp(entry, 0, SEEK_END, 0, 0 TSRMLS_CC);\n\t\t}\n\t} else {\n\t\tif (for_write) {\n\t\t\tif (entry->link) {\n\t\t\t\tefree(entry->link);\n\t\t\t\tentry->link = NULL;\n\t\t\t\tentry->tar_type = (entry->is_tar ? TAR_FILE : '\\0');\n\t\t\t}\n\n\t\t\tif (for_trunc) {\n\t\t\t\tif (FAILURE == phar_create_writeable_entry(phar, entry, error TSRMLS_CC)) {\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (FAILURE == phar_separate_entry_fp(entry, error TSRMLS_CC)) {\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (FAILURE == phar_open_entry_fp(entry, error, 1 TSRMLS_CC)) {\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\t}\n\n\t*ret = (phar_entry_data *) emalloc(sizeof(phar_entry_data));\n\t(*ret)->position = 0;\n\t(*ret)->phar = phar;\n\t(*ret)->for_write = for_write;\n\t(*ret)->internal_file = entry;\n\t(*ret)->is_zip = entry->is_zip;\n        (*ret)->is_tar = entry->is_tar;\n        (*ret)->fp = phar_get_efp(entry, 1 TSRMLS_CC);\n        if (entry->link) {\n               (*ret)->zero = phar_get_fp_offset(phar_get_link_source(entry TSRMLS_CC) TSRMLS_CC);\n        } else {\n                (*ret)->zero = phar_get_fp_offset(entry TSRMLS_CC);\n        }\n\t}\n\n\treturn SUCCESS;\n}\n/* }}} */\n\n/**\n * Create a new dummy file slot within a writeable phar for a newly created file\n */\nphar_entry_data *phar_get_or_create_entry_data(char *fname, int fname_len, char *path, int path_len, char *mode, char allow_dir, char **error, int security TSRMLS_DC) /* {{{ */\n{\n\tphar_archive_data *phar;\n\tphar_entry_info *entry, etemp;\n\tphar_entry_data *ret;\n\tconst char *pcr_error;\n\tchar is_dir;\n\n#ifdef PHP_WIN32\n\tphar_unixify_path_separators(path, path_len);\n#endif\n\n\tis_dir = (path_len && path[path_len - 1] == '/') ? 1 : 0;\n\n\tif (FAILURE == phar_get_archive(&phar, fname, fname_len, NULL, 0, error TSRMLS_CC)) {\n\t\treturn NULL;\n\t}\n\n\tif (FAILURE == phar_get_entry_data(&ret, fname, fname_len, path, path_len, mode, allow_dir, error, security TSRMLS_CC)) {\n\t\treturn NULL;\n\t} else if (ret) {\n\t\treturn ret;\n\t}\n\n\tif (phar_path_check(&path, &path_len, &pcr_error) > pcr_is_ok) {\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"phar error: invalid path \\\"%s\\\" contains %s\", path, pcr_error);\n\t\t}\n\t\treturn NULL;\n\t}\n\n\tif (phar->is_persistent && FAILURE == phar_copy_on_write(&phar TSRMLS_CC)) {\n\t\tif (error) {\n\t\t\tspprintf(error, 4096, \"phar error: file \\\"%s\\\" in phar \\\"%s\\\" cannot be created, could not make cached phar writeable\", path, fname);\n\t\t}\n\t\treturn NULL;\n\t}\n\n\t/* create a new phar data holder */\n\tret = (phar_entry_data *) emalloc(sizeof(phar_entry_data));\n\n\t/* create an entry, this is a new file */\n\tmemset(&etemp, 0, sizeof(phar_entry_info));\n\tetemp.filename_len = path_len;\n\tetemp.fp_type = PHAR_MOD;\n\tetemp.fp = php_stream_fopen_tmpfile();\n\n\tif (!etemp.fp) {\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"phar error: unable to create temporary file\");\n\t\t}\n\t\tefree(ret);\n\t\treturn NULL;\n\t}\n\n\tetemp.fp_refcount = 1;\n\n\tif (allow_dir == 2) {\n\t\tetemp.is_dir = 1;\n\t\tetemp.flags = etemp.old_flags = PHAR_ENT_PERM_DEF_DIR;\n\t} else {\n\t\tetemp.flags = etemp.old_flags = PHAR_ENT_PERM_DEF_FILE;\n\t}\n\tif (is_dir) {\n\t\tetemp.filename_len--; /* strip trailing / */\n\t\tpath_len--;\n\t}\n\n\tphar_add_virtual_dirs(phar, path, path_len TSRMLS_CC);\n\tetemp.is_modified = 1;\n\tetemp.timestamp = time(0);\n\tetemp.is_crc_checked = 1;\n\tetemp.phar = phar;\n\tetemp.filename = estrndup(path, path_len);\n\tetemp.is_zip = phar->is_zip;\n\n\tif (phar->is_tar) {\n\t\tetemp.is_tar = phar->is_tar;\n\t\tetemp.tar_type = etemp.is_dir ? TAR_DIR : TAR_FILE;\n\t}\n\n\tif (FAILURE == zend_hash_add(&phar->manifest, etemp.filename, path_len, (void*)&etemp, sizeof(phar_entry_info), (void **) &entry)) {\n\t\tphp_stream_close(etemp.fp);\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"phar error: unable to add new entry \\\"%s\\\" to phar \\\"%s\\\"\", etemp.filename, phar->fname);\n\t\t}\n\t\tefree(ret);\n\t\tefree(etemp.filename);\n\t\treturn NULL;\n\t}\n\n\tif (!entry) {\n\t\tphp_stream_close(etemp.fp);\n\t\tefree(etemp.filename);\n\t\tefree(ret);\n\t\treturn NULL;\n\t}\n\n\t++(phar->refcount);\n\tret->phar = phar;\n\tret->fp = entry->fp;\n\tret->position = ret->zero = 0;\n\tret->for_write = 1;\n\tret->is_zip = entry->is_zip;\n\tret->is_tar = entry->is_tar;\n\tret->internal_file = entry;\n\n\treturn ret;\n}\n/* }}} */\n\n/* initialize a phar_archive_data's read-only fp for existing phar data */\nint phar_open_archive_fp(phar_archive_data *phar TSRMLS_DC) /* {{{ */\n{\n\tif (phar_get_pharfp(phar TSRMLS_CC)) {\n\t\treturn SUCCESS;\n\t}\n\n\tif (php_check_open_basedir(phar->fname TSRMLS_CC)) {\n\t\treturn FAILURE;\n\t}\n\n\tphar_set_pharfp(phar, php_stream_open_wrapper(phar->fname, \"rb\", IGNORE_URL|STREAM_MUST_SEEK|0, NULL) TSRMLS_CC);\n\n\tif (!phar_get_pharfp(phar TSRMLS_CC)) {\n\t\treturn FAILURE;\n\t}\n\n\treturn SUCCESS;\n}\n/* }}} */\n\n/* copy file data from an existing to a new phar_entry_info that is not in the manifest */\nint phar_copy_entry_fp(phar_entry_info *source, phar_entry_info *dest, char **error TSRMLS_DC) /* {{{ */\n{\n\tphar_entry_info *link;\n\n\tif (FAILURE == phar_open_entry_fp(source, error, 1 TSRMLS_CC)) {\n\t\treturn FAILURE;\n\t}\n\n\tif (dest->link) {\n\t\tefree(dest->link);\n\t\tdest->link = NULL;\n\t\tdest->tar_type = (dest->is_tar ? TAR_FILE : '\\0');\n\t}\n\n\tdest->fp_type = PHAR_MOD;\n\tdest->offset = 0;\n\tdest->is_modified = 1;\n\tdest->fp = php_stream_fopen_tmpfile();\n\tif (dest->fp == NULL) {\n\t\tspprintf(error, 0, \"phar error: unable to create temporary file\");\n\t\treturn EOF;\n\t}\n\tphar_seek_efp(source, 0, SEEK_SET, 0, 1 TSRMLS_CC);\n\tlink = phar_get_link_source(source TSRMLS_CC);\n\n\tif (!link) {\n\t\tlink = source;\n\t}\n\n\tif (SUCCESS != phar_stream_copy_to_stream(phar_get_efp(link, 0 TSRMLS_CC), dest->fp, link->uncompressed_filesize, NULL)) {\n\t\tphp_stream_close(dest->fp);\n\t\tdest->fp_type = PHAR_FP;\n\t\tif (error) {\n\t\t\tspprintf(error, 4096, \"phar error: unable to copy contents of file \\\"%s\\\" to \\\"%s\\\" in phar archive \\\"%s\\\"\", source->filename, dest->filename, source->phar->fname);\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\treturn SUCCESS;\n}\n/* }}} */\n\n/* open and decompress a compressed phar entry\n */\nint phar_open_entry_fp(phar_entry_info *entry, char **error, int follow_links TSRMLS_DC) /* {{{ */\n{\n\tphp_stream_filter *filter;\n\tphar_archive_data *phar = entry->phar;\n\tchar *filtername;\n\toff_t loc;\n\tphp_stream *ufp;\n\tphar_entry_data dummy;\n\n\tif (follow_links && entry->link) {\n\t\tphar_entry_info *link_entry = phar_get_link_source(entry TSRMLS_CC);\n\t\tif (link_entry && link_entry != entry) {\n\t\t\treturn phar_open_entry_fp(link_entry, error, 1 TSRMLS_CC);\n\t\t}\n\t}\n\n\tif (entry->is_modified) {\n\t\treturn SUCCESS;\n\t}\n\n\tif (entry->fp_type == PHAR_TMP) {\n\t\tif (!entry->fp) {\n\t\t\tentry->fp = php_stream_open_wrapper(entry->tmp, \"rb\", STREAM_MUST_SEEK|0, NULL);\n\t\t}\n\t\treturn SUCCESS;\n\t}\n\n\tif (entry->fp_type != PHAR_FP) {\n\t\t/* either newly created or already modified */\n\t\treturn SUCCESS;\n\t}\n\n\tif (!phar_get_pharfp(phar TSRMLS_CC)) {\n\t\tif (FAILURE == phar_open_archive_fp(phar TSRMLS_CC)) {\n\t\t\tspprintf(error, 4096, \"phar error: Cannot open phar archive \\\"%s\\\" for reading\", phar->fname);\n\t\t\treturn FAILURE;\n\t\t}\n\t}\n\n\tif ((entry->old_flags && !(entry->old_flags & PHAR_ENT_COMPRESSION_MASK)) || !(entry->flags & PHAR_ENT_COMPRESSION_MASK)) {\n\t\tdummy.internal_file = entry;\n\t\tdummy.phar = phar;\n\t\tdummy.zero = entry->offset;\n\t\tdummy.fp = phar_get_pharfp(phar TSRMLS_CC);\n\t\tif (FAILURE == phar_postprocess_file(&dummy, entry->crc32, error, 1 TSRMLS_CC)) {\n\t\t\treturn FAILURE;\n\t\t}\n\t\treturn SUCCESS;\n\t}\n\n\tif (!phar_get_entrypufp(entry TSRMLS_CC)) {\n\t\tphar_set_entrypufp(entry, php_stream_fopen_tmpfile() TSRMLS_CC);\n\t\tif (!phar_get_entrypufp(entry TSRMLS_CC)) {\n\t\t\tspprintf(error, 4096, \"phar error: Cannot open temporary file for decompressing phar archive \\\"%s\\\" file \\\"%s\\\"\", phar->fname, entry->filename);\n\t\t\treturn FAILURE;\n\t\t}\n\t}\n\n\tdummy.internal_file = entry;\n\tdummy.phar = phar;\n\tdummy.zero = entry->offset;\n\tdummy.fp = phar_get_pharfp(phar TSRMLS_CC);\n\tif (FAILURE == phar_postprocess_file(&dummy, entry->crc32, error, 1 TSRMLS_CC)) {\n\t\treturn FAILURE;\n\t}\n\n\tufp = phar_get_entrypufp(entry TSRMLS_CC);\n\n\tif ((filtername = phar_decompress_filter(entry, 0)) != NULL) {\n\t\tfilter = php_stream_filter_create(filtername, NULL, 0 TSRMLS_CC);\n\t} else {\n\t\tfilter = NULL;\n\t}\n\n\tif (!filter) {\n\t\tspprintf(error, 4096, \"phar error: unable to read phar \\\"%s\\\" (cannot create %s filter while decompressing file \\\"%s\\\")\", phar->fname, phar_decompress_filter(entry, 1), entry->filename);\n\t\treturn FAILURE;\n\t}\n\n\t/* now we can safely use proper decompression */\n\t/* save the new offset location within ufp */\n\tphp_stream_seek(ufp, 0, SEEK_END);\n\tloc = php_stream_tell(ufp);\n\tphp_stream_filter_append(&ufp->writefilters, filter);\n\tphp_stream_seek(phar_get_entrypfp(entry TSRMLS_CC), phar_get_fp_offset(entry TSRMLS_CC), SEEK_SET);\n\n\tif (entry->uncompressed_filesize) {\n\t\tif (SUCCESS != phar_stream_copy_to_stream(phar_get_entrypfp(entry TSRMLS_CC), ufp, entry->compressed_filesize, NULL)) {\n\t\t\tspprintf(error, 4096, \"phar error: internal corruption of phar \\\"%s\\\" (actual filesize mismatch on file \\\"%s\\\")\", phar->fname, entry->filename);\n\t\t\tphp_stream_filter_remove(filter, 1 TSRMLS_CC);\n\t\t\treturn FAILURE;\n\t\t}\n\t}\n\n\tphp_stream_filter_flush(filter, 1);\n\tphp_stream_flush(ufp);\n\tphp_stream_filter_remove(filter, 1 TSRMLS_CC);\n\n\tif (php_stream_tell(ufp) - loc != (off_t) entry->uncompressed_filesize) {\n\t\tspprintf(error, 4096, \"phar error: internal corruption of phar \\\"%s\\\" (actual filesize mismatch on file \\\"%s\\\")\", phar->fname, entry->filename);\n\t\treturn FAILURE;\n\t}\n\n\tentry->old_flags = entry->flags;\n\n\t/* this is now the new location of the file contents within this fp */\n\tphar_set_fp_type(entry, PHAR_UFP, loc TSRMLS_CC);\n\tdummy.zero = entry->offset;\n\tdummy.fp = ufp;\n\tif (FAILURE == phar_postprocess_file(&dummy, entry->crc32, error, 0 TSRMLS_CC)) {\n\t\treturn FAILURE;\n\t}\n\treturn SUCCESS;\n}\n/* }}} */\n\nint phar_create_writeable_entry(phar_archive_data *phar, phar_entry_info *entry, char **error TSRMLS_DC) /* {{{ */\n{\n\tif (entry->fp_type == PHAR_MOD) {\n\t\t/* already newly created, truncate */\n\t\tphp_stream_truncate_set_size(entry->fp, 0);\n\n\t\tentry->old_flags = entry->flags;\n\t\tentry->is_modified = 1;\n\t\tphar->is_modified = 1;\n\t\t/* reset file size */\n\t\tentry->uncompressed_filesize = 0;\n\t\tentry->compressed_filesize = 0;\n\t\tentry->crc32 = 0;\n\t\tentry->flags = PHAR_ENT_PERM_DEF_FILE;\n\t\tentry->fp_type = PHAR_MOD;\n\t\tentry->offset = 0;\n\t\treturn SUCCESS;\n\t}\n\n\tif (error) {\n\t\t*error = NULL;\n\t}\n\n\t/* open a new temp file for writing */\n\tif (entry->link) {\n\t\tefree(entry->link);\n\t\tentry->link = NULL;\n\t\tentry->tar_type = (entry->is_tar ? TAR_FILE : '\\0');\n\t}\n\n\tentry->fp = php_stream_fopen_tmpfile();\n\n\tif (!entry->fp) {\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"phar error: unable to create temporary file\");\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tentry->old_flags = entry->flags;\n\tentry->is_modified = 1;\n\tphar->is_modified = 1;\n\t/* reset file size */\n\tentry->uncompressed_filesize = 0;\n\tentry->compressed_filesize = 0;\n\tentry->crc32 = 0;\n\tentry->flags = PHAR_ENT_PERM_DEF_FILE;\n\tentry->fp_type = PHAR_MOD;\n\tentry->offset = 0;\n\treturn SUCCESS;\n}\n/* }}} */\n\nint phar_separate_entry_fp(phar_entry_info *entry, char **error TSRMLS_DC) /* {{{ */\n{\n\tphp_stream *fp;\n\tphar_entry_info *link;\n\n\tif (FAILURE == phar_open_entry_fp(entry, error, 1 TSRMLS_CC)) {\n\t\treturn FAILURE;\n\t}\n\n\tif (entry->fp_type == PHAR_MOD) {\n\t\treturn SUCCESS;\n\t}\n\n\tfp = php_stream_fopen_tmpfile();\n\tif (fp == NULL) {\n\t\tspprintf(error, 0, \"phar error: unable to create temporary file\");\n\t\treturn FAILURE;\n\t}\n\tphar_seek_efp(entry, 0, SEEK_SET, 0, 1 TSRMLS_CC);\n\tlink = phar_get_link_source(entry TSRMLS_CC);\n\n\tif (!link) {\n\t\tlink = entry;\n\t}\n\n\tif (SUCCESS != phar_stream_copy_to_stream(phar_get_efp(link, 0 TSRMLS_CC), fp, link->uncompressed_filesize, NULL)) {\n\t\tif (error) {\n\t\t\tspprintf(error, 4096, \"phar error: cannot separate entry file \\\"%s\\\" contents in phar archive \\\"%s\\\" for write access\", entry->filename, entry->phar->fname);\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tif (entry->link) {\n\t\tefree(entry->link);\n\t\tentry->link = NULL;\n\t\tentry->tar_type = (entry->is_tar ? TAR_FILE : '\\0');\n\t}\n\n\tentry->offset = 0;\n\tentry->fp = fp;\n\tentry->fp_type = PHAR_MOD;\n\tentry->is_modified = 1;\n\treturn SUCCESS;\n}\n/* }}} */\n\n/**\n * helper function to open an internal file's fp just-in-time\n */\nphar_entry_info * phar_open_jit(phar_archive_data *phar, phar_entry_info *entry, char **error TSRMLS_DC) /* {{{ */\n{\n\tif (error) {\n\t\t*error = NULL;\n\t}\n\t/* seek to start of internal file and read it */\n\tif (FAILURE == phar_open_entry_fp(entry, error, 1 TSRMLS_CC)) {\n\t\treturn NULL;\n\t}\n\tif (-1 == phar_seek_efp(entry, 0, SEEK_SET, 0, 1 TSRMLS_CC)) {\n\t\tspprintf(error, 4096, \"phar error: cannot seek to start of file \\\"%s\\\" in phar \\\"%s\\\"\", entry->filename, phar->fname);\n\t\treturn NULL;\n\t}\n\treturn entry;\n}\n/* }}} */\n\nPHP_PHAR_API int phar_resolve_alias(char *alias, int alias_len, char **filename, int *filename_len TSRMLS_DC) /* {{{ */ {\n\tphar_archive_data **fd_ptr;\n\tif (PHAR_GLOBALS->phar_alias_map.arBuckets\n\t\t\t&& SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void**)&fd_ptr)) {\n\t\t*filename = (*fd_ptr)->fname;\n\t\t*filename_len = (*fd_ptr)->fname_len;\n\t\treturn SUCCESS;\n\t}\n\treturn FAILURE;\n}\n/* }}} */\n\nint phar_free_alias(phar_archive_data *phar, char *alias, int alias_len TSRMLS_DC) /* {{{ */\n{\n\tif (phar->refcount || phar->is_persistent) {\n\t\treturn FAILURE;\n\t}\n\n\t/* this archive has no open references, so emit an E_STRICT and remove it */\n\tif (zend_hash_del(&(PHAR_GLOBALS->phar_fname_map), phar->fname, phar->fname_len) != SUCCESS) {\n\t\treturn FAILURE;\n\t}\n\n\t/* invalidate phar cache */\n\tPHAR_G(last_phar) = NULL;\n\tPHAR_G(last_phar_name) = PHAR_G(last_alias) = NULL;\n\n\treturn SUCCESS;\n}\n/* }}} */\n\n/**\n * Looks up a phar archive in the filename map, connecting it to the alias\n * (if any) or returns null\n */\nint phar_get_archive(phar_archive_data **archive, char *fname, int fname_len, char *alias, int alias_len, char **error TSRMLS_DC) /* {{{ */\n{\n\tphar_archive_data *fd, **fd_ptr;\n\tchar *my_realpath, *save;\n\tint save_len;\n\tulong fhash, ahash = 0;\n\n\tphar_request_initialize(TSRMLS_C);\n\n\tif (error) {\n\t\t*error = NULL;\n\t}\n\n\t*archive = NULL;\n\n\tif (PHAR_G(last_phar) && fname_len == PHAR_G(last_phar_name_len) && !memcmp(fname, PHAR_G(last_phar_name), fname_len)) {\n\t\t*archive = PHAR_G(last_phar);\n\t\tif (alias && alias_len) {\n\n\t\t\tif (!PHAR_G(last_phar)->is_temporary_alias && (alias_len != PHAR_G(last_phar)->alias_len || memcmp(PHAR_G(last_phar)->alias, alias, alias_len))) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"alias \\\"%s\\\" is already used for archive \\\"%s\\\" cannot be overloaded with \\\"%s\\\"\", alias, PHAR_G(last_phar)->fname, fname);\n\t\t\t\t}\n\t\t\t\t*archive = NULL;\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\tif (PHAR_G(last_phar)->alias_len && SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_alias_map), PHAR_G(last_phar)->alias, PHAR_G(last_phar)->alias_len, (void**)&fd_ptr)) {\n\t\t\t\tzend_hash_del(&(PHAR_GLOBALS->phar_alias_map), PHAR_G(last_phar)->alias, PHAR_G(last_phar)->alias_len);\n\t\t\t}\n\n\t\t\tzend_hash_add(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void*)&(*archive), sizeof(phar_archive_data*), NULL);\n\t\t\tPHAR_G(last_alias) = alias;\n\t\t\tPHAR_G(last_alias_len) = alias_len;\n\t\t}\n\n\t\treturn SUCCESS;\n\t}\n\n\tif (alias && alias_len && PHAR_G(last_phar) && alias_len == PHAR_G(last_alias_len) && !memcmp(alias, PHAR_G(last_alias), alias_len)) {\n\t\tfd = PHAR_G(last_phar);\n\t\tfd_ptr = &fd;\n\t\tgoto alias_success;\n\t}\n\n\tif (alias && alias_len) {\n\t\tahash = zend_inline_hash_func(alias, alias_len);\n\t\tif (SUCCESS == zend_hash_quick_find(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, ahash, (void**)&fd_ptr)) {\nalias_success:\n\t\t\tif (fname && (fname_len != (*fd_ptr)->fname_len || strncmp(fname, (*fd_ptr)->fname, fname_len))) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"alias \\\"%s\\\" is already used for archive \\\"%s\\\" cannot be overloaded with \\\"%s\\\"\", alias, (*fd_ptr)->fname, fname);\n\t\t\t\t}\n\t\t\t\tif (SUCCESS == phar_free_alias(*fd_ptr, alias, alias_len TSRMLS_CC)) {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tefree(*error);\n\t\t\t\t\t\t*error = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\t*archive = *fd_ptr;\n\t\t\tfd = *fd_ptr;\n\t\t\tPHAR_G(last_phar) = fd;\n\t\t\tPHAR_G(last_phar_name) = fd->fname;\n\t\t\tPHAR_G(last_phar_name_len) = fd->fname_len;\n\t\t\tPHAR_G(last_alias) = alias;\n\t\t\tPHAR_G(last_alias_len) = alias_len;\n\n\t\t\treturn SUCCESS;\n\t\t}\n\n\t\tif (PHAR_G(manifest_cached) && SUCCESS == zend_hash_quick_find(&cached_alias, alias, alias_len, ahash, (void **)&fd_ptr)) {\n\t\t\tgoto alias_success;\n\t\t}\n\t}\n\n\tfhash = zend_inline_hash_func(fname, fname_len);\n\tmy_realpath = NULL;\n\tsave = fname;\n\tsave_len = fname_len;\n\n\tif (fname && fname_len) {\n\t\tif (SUCCESS == zend_hash_quick_find(&(PHAR_GLOBALS->phar_fname_map), fname, fname_len, fhash, (void**)&fd_ptr)) {\n\t\t\t*archive = *fd_ptr;\n\t\t\tfd = *fd_ptr;\n\n\t\t\tif (alias && alias_len) {\n\t\t\t\tif (!fd->is_temporary_alias && (alias_len != fd->alias_len || memcmp(fd->alias, alias, alias_len))) {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 0, \"alias \\\"%s\\\" is already used for archive \\\"%s\\\" cannot be overloaded with \\\"%s\\\"\", alias, (*fd_ptr)->fname, fname);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tif (fd->alias_len && SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_alias_map), fd->alias, fd->alias_len, (void**)&fd_ptr)) {\n\t\t\t\t\tzend_hash_del(&(PHAR_GLOBALS->phar_alias_map), fd->alias, fd->alias_len);\n\t\t\t\t}\n\n\t\t\t\tzend_hash_quick_add(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, ahash, (void*)&fd, sizeof(phar_archive_data*), NULL);\n\t\t\t}\n\n\t\t\tPHAR_G(last_phar) = fd;\n\t\t\tPHAR_G(last_phar_name) = fd->fname;\n\t\t\tPHAR_G(last_phar_name_len) = fd->fname_len;\n\t\t\tPHAR_G(last_alias) = fd->alias;\n\t\t\tPHAR_G(last_alias_len) = fd->alias_len;\n\n\t\t\treturn SUCCESS;\n\t\t}\n\n\t\tif (PHAR_G(manifest_cached) && SUCCESS == zend_hash_quick_find(&cached_phars, fname, fname_len, fhash, (void**)&fd_ptr)) {\n\t\t\t*archive = *fd_ptr;\n\t\t\tfd = *fd_ptr;\n\n\t\t\t/* this could be problematic - alias should never be different from manifest alias\n\t\t\t   for cached phars */\n\t\t\tif (!fd->is_temporary_alias && alias && alias_len) {\n\t\t\t\tif (alias_len != fd->alias_len || memcmp(fd->alias, alias, alias_len)) {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 0, \"alias \\\"%s\\\" is already used for archive \\\"%s\\\" cannot be overloaded with \\\"%s\\\"\", alias, (*fd_ptr)->fname, fname);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tPHAR_G(last_phar) = fd;\n\t\t\tPHAR_G(last_phar_name) = fd->fname;\n\t\t\tPHAR_G(last_phar_name_len) = fd->fname_len;\n\t\t\tPHAR_G(last_alias) = fd->alias;\n\t\t\tPHAR_G(last_alias_len) = fd->alias_len;\n\n\t\t\treturn SUCCESS;\n\t\t}\n\n\t\tif (SUCCESS == zend_hash_quick_find(&(PHAR_GLOBALS->phar_alias_map), save, save_len, fhash, (void**)&fd_ptr)) {\n\t\t\tfd = *archive = *fd_ptr;\n\n\t\t\tPHAR_G(last_phar) = fd;\n\t\t\tPHAR_G(last_phar_name) = fd->fname;\n\t\t\tPHAR_G(last_phar_name_len) = fd->fname_len;\n\t\t\tPHAR_G(last_alias) = fd->alias;\n\t\t\tPHAR_G(last_alias_len) = fd->alias_len;\n\n\t\t\treturn SUCCESS;\n\t\t}\n\n\t\tif (PHAR_G(manifest_cached) && SUCCESS == zend_hash_quick_find(&cached_alias, save, save_len, fhash, (void**)&fd_ptr)) {\n\t\t\tfd = *archive = *fd_ptr;\n\n\t\t\tPHAR_G(last_phar) = fd;\n\t\t\tPHAR_G(last_phar_name) = fd->fname;\n\t\t\tPHAR_G(last_phar_name_len) = fd->fname_len;\n\t\t\tPHAR_G(last_alias) = fd->alias;\n\t\t\tPHAR_G(last_alias_len) = fd->alias_len;\n\n\t\t\treturn SUCCESS;\n\t\t}\n\n\t\t/* not found, try converting \\ to / */\n\t\tmy_realpath = expand_filepath(fname, my_realpath TSRMLS_CC);\n\n\t\tif (my_realpath) {\n\t\t\tfname_len = strlen(my_realpath);\n\t\t\tfname = my_realpath;\n\t\t} else {\n\t\t\treturn FAILURE;\n\t\t}\n#ifdef PHP_WIN32\n\t\tphar_unixify_path_separators(fname, fname_len);\n#endif\n\t\tfhash = zend_inline_hash_func(fname, fname_len);\n\n\t\tif (SUCCESS == zend_hash_quick_find(&(PHAR_GLOBALS->phar_fname_map), fname, fname_len, fhash, (void**)&fd_ptr)) {\nrealpath_success:\n\t\t\t*archive = *fd_ptr;\n\t\t\tfd = *fd_ptr;\n\n\t\t\tif (alias && alias_len) {\n\t\t\t\tzend_hash_quick_add(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, ahash, (void*)&fd, sizeof(phar_archive_data*), NULL);\n\t\t\t}\n\n\t\t\tefree(my_realpath);\n\n\t\t\tPHAR_G(last_phar) = fd;\n\t\t\tPHAR_G(last_phar_name) = fd->fname;\n\t\t\tPHAR_G(last_phar_name_len) = fd->fname_len;\n\t\t\tPHAR_G(last_alias) = fd->alias;\n\t\t\tPHAR_G(last_alias_len) = fd->alias_len;\n\n\t\t\treturn SUCCESS;\n\t\t}\n\n\t\tif (PHAR_G(manifest_cached) && SUCCESS == zend_hash_quick_find(&cached_phars, fname, fname_len, fhash, (void**)&fd_ptr)) {\n\t\t\tgoto realpath_success;\n\t\t}\n\n\t\tefree(my_realpath);\n\t}\n\n\treturn FAILURE;\n}\n/* }}} */\n\n/**\n * Determine which stream compression filter (if any) we need to read this file\n */\nchar * phar_compress_filter(phar_entry_info * entry, int return_unknown) /* {{{ */\n{\n\tswitch (entry->flags & PHAR_ENT_COMPRESSION_MASK) {\n\tcase PHAR_ENT_COMPRESSED_GZ:\n\t\treturn \"zlib.deflate\";\n\tcase PHAR_ENT_COMPRESSED_BZ2:\n\t\treturn \"bzip2.compress\";\n\tdefault:\n\t\treturn return_unknown ? \"unknown\" : NULL;\n\t}\n}\n/* }}} */\n\n/**\n * Determine which stream decompression filter (if any) we need to read this file\n */\nchar * phar_decompress_filter(phar_entry_info * entry, int return_unknown) /* {{{ */\n{\n\tphp_uint32 flags;\n\n\tif (entry->is_modified) {\n\t\tflags = entry->old_flags;\n\t} else {\n\t\tflags = entry->flags;\n\t}\n\n\tswitch (flags & PHAR_ENT_COMPRESSION_MASK) {\n\t\tcase PHAR_ENT_COMPRESSED_GZ:\n\t\t\treturn \"zlib.inflate\";\n\t\tcase PHAR_ENT_COMPRESSED_BZ2:\n\t\t\treturn \"bzip2.decompress\";\n\t\tdefault:\n\t\t\treturn return_unknown ? \"unknown\" : NULL;\n\t}\n}\n/* }}} */\n\n/**\n * retrieve information on a file contained within a phar, or null if it ain't there\n */\nphar_entry_info *phar_get_entry_info(phar_archive_data *phar, char *path, int path_len, char **error, int security TSRMLS_DC) /* {{{ */\n{\n\treturn phar_get_entry_info_dir(phar, path, path_len, 0, error, security TSRMLS_CC);\n}\n/* }}} */\n/**\n * retrieve information on a file or directory contained within a phar, or null if none found\n * allow_dir is 0 for none, 1 for both empty directories in the phar and temp directories, and 2 for only\n * valid pre-existing empty directory entries\n */\nphar_entry_info *phar_get_entry_info_dir(phar_archive_data *phar, char *path, int path_len, char dir, char **error, int security TSRMLS_DC) /* {{{ */\n{\n\tconst char *pcr_error;\n\tphar_entry_info *entry;\n\tint is_dir;\n\n#ifdef PHP_WIN32\n\tphar_unixify_path_separators(path, path_len);\n#endif\n\n\tis_dir = (path_len && (path[path_len - 1] == '/')) ? 1 : 0;\n\n\tif (error) {\n\t\t*error = NULL;\n\t}\n\n\tif (security && path_len >= sizeof(\".phar\")-1 && !memcmp(path, \".phar\", sizeof(\".phar\")-1)) {\n\t\tif (error) {\n\t\t\tspprintf(error, 4096, \"phar error: cannot directly access magic \\\".phar\\\" directory or files within it\");\n\t\t}\n\t\treturn NULL;\n\t}\n\n\tif (!path_len && !dir) {\n\t\tif (error) {\n\t\t\tspprintf(error, 4096, \"phar error: invalid path \\\"%s\\\" must not be empty\", path);\n\t\t}\n\t\treturn NULL;\n\t}\n\n\tif (phar_path_check(&path, &path_len, &pcr_error) > pcr_is_ok) {\n\t\tif (error) {\n\t\t\tspprintf(error, 4096, \"phar error: invalid path \\\"%s\\\" contains %s\", path, pcr_error);\n\t\t}\n\t\treturn NULL;\n\t}\n\n\tif (!phar->manifest.arBuckets) {\n\t\treturn NULL;\n\t}\n\n\tif (is_dir) {\n\t\tif (!path_len || path_len == 1) {\n\t\t\treturn NULL;\n\t\t}\n\t\tpath_len--;\n\t}\n\n\tif (SUCCESS == zend_hash_find(&phar->manifest, path, path_len, (void**)&entry)) {\n\t\tif (entry->is_deleted) {\n\t\t\t/* entry is deleted, but has not been flushed to disk yet */\n\t\t\treturn NULL;\n\t\t}\n\t\tif (entry->is_dir && !dir) {\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 4096, \"phar error: path \\\"%s\\\" is a directory\", path);\n\t\t\t}\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!entry->is_dir && dir == 2) {\n\t\t\t/* user requested a directory, we must return one */\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 4096, \"phar error: path \\\"%s\\\" exists and is a not a directory\", path);\n\t\t\t}\n\t\t\treturn NULL;\n\t\t}\n\t\treturn entry;\n\t}\n\n\tif (dir) {\n\t\tif (zend_hash_exists(&phar->virtual_dirs, path, path_len)) {\n\t\t\t/* a file or directory exists in a sub-directory of this path */\n\t\t\tentry = (phar_entry_info *) ecalloc(1, sizeof(phar_entry_info));\n\t\t\t/* this next line tells PharFileInfo->__destruct() to efree the filename */\n\t\t\tentry->is_temp_dir = entry->is_dir = 1;\n\t\t\tentry->filename = (char *) estrndup(path, path_len + 1);\n\t\t\tentry->filename_len = path_len;\n\t\t\tentry->phar = phar;\n\t\t\treturn entry;\n\t\t}\n\t}\n\n\tif (phar->mounted_dirs.arBuckets && zend_hash_num_elements(&phar->mounted_dirs)) {\n\t\tphar_zstr key;\n\t\tchar *str_key;\n\t\tulong unused;\n\t\tuint keylen;\n\n\t\tzend_hash_internal_pointer_reset(&phar->mounted_dirs);\n\t\twhile (FAILURE != zend_hash_has_more_elements(&phar->mounted_dirs)) {\n\t\t\tif (HASH_KEY_NON_EXISTENT == zend_hash_get_current_key_ex(&phar->mounted_dirs, &key, &keylen, &unused, 0, NULL)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tPHAR_STR(key, str_key);\n\n\t\t\tif ((int)keylen >= path_len || strncmp(str_key, path, keylen)) {\n\t\t\t\tPHAR_STR_FREE(str_key);\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tchar *test;\n\t\t\t\tint test_len;\n\t\t\t\tphp_stream_statbuf ssb;\n\n\t\t\t\tif (SUCCESS != zend_hash_find(&phar->manifest, str_key, keylen, (void **) &entry)) {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 4096, \"phar internal error: mounted path \\\"%s\\\" could not be retrieved from manifest\", str_key);\n\t\t\t\t\t}\n\t\t\t\t\tPHAR_STR_FREE(str_key);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\n\t\t\t\tif (!entry->tmp || !entry->is_mounted) {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 4096, \"phar internal error: mounted path \\\"%s\\\" is not properly initialized as a mounted path\", str_key);\n\t\t\t\t\t}\n\t\t\t\t\tPHAR_STR_FREE(str_key);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tPHAR_STR_FREE(str_key);\n\n\t\t\t\ttest_len = spprintf(&test, MAXPATHLEN, \"%s%s\", entry->tmp, path + keylen);\n\n\t\t\t\tif (SUCCESS != php_stream_stat_path(test, &ssb)) {\n\t\t\t\t\tefree(test);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\n\t\t\t\tif (ssb.sb.st_mode & S_IFDIR && !dir) {\n\t\t\t\t\tefree(test);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 4096, \"phar error: path \\\"%s\\\" is a directory\", path);\n\t\t\t\t\t}\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\n\t\t\t\tif ((ssb.sb.st_mode & S_IFDIR) == 0 && dir) {\n\t\t\t\t\tefree(test);\n\t\t\t\t\t/* user requested a directory, we must return one */\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 4096, \"phar error: path \\\"%s\\\" exists and is a not a directory\", path);\n\t\t\t\t\t}\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\n\t\t\t\t/* mount the file just in time */\n\t\t\t\tif (SUCCESS != phar_mount_entry(phar, test, test_len, path, path_len TSRMLS_CC)) {\n\t\t\t\t\tefree(test);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 4096, \"phar error: path \\\"%s\\\" exists as file \\\"%s\\\" and could not be mounted\", path, test);\n\t\t\t\t\t}\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\n\t\t\t\tefree(test);\n\n\t\t\t\tif (SUCCESS != zend_hash_find(&phar->manifest, path, path_len, (void**)&entry)) {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 4096, \"phar error: path \\\"%s\\\" exists as file \\\"%s\\\" and could not be retrieved after being mounted\", path, test);\n\t\t\t\t\t}\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\treturn entry;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn NULL;\n}\n/* }}} */\n\nstatic const char hexChars[] = \"0123456789ABCDEF\";\n\nstatic int phar_hex_str(const char *digest, size_t digest_len, char **signature TSRMLS_DC) /* {{{ */\n{\n\tint pos = -1;\n\tsize_t len = 0;\n\n\t*signature = (char*)safe_pemalloc(digest_len, 2, 1, PHAR_G(persist));\n\n\tfor (; len < digest_len; ++len) {\n\t\t(*signature)[++pos] = hexChars[((const unsigned char *)digest)[len] >> 4];\n\t\t(*signature)[++pos] = hexChars[((const unsigned char *)digest)[len] & 0x0F];\n\t}\n\t(*signature)[++pos] = '\\0';\n\treturn pos;\n}\n/* }}} */\n\n#ifndef PHAR_HAVE_OPENSSL\nstatic int phar_call_openssl_signverify(int is_sign, php_stream *fp, off_t end, char *key, int key_len, char **signature, int *signature_len TSRMLS_DC) /* {{{ */\n{\n\tzend_fcall_info fci;\n\tzend_fcall_info_cache fcc;\n\tzval *zdata, *zsig, *zkey, *retval_ptr, **zp[3], *openssl;\n\n\tMAKE_STD_ZVAL(zdata);\n\tMAKE_STD_ZVAL(openssl);\n\tZVAL_STRINGL(openssl, is_sign ? \"openssl_sign\" : \"openssl_verify\", is_sign ? sizeof(\"openssl_sign\")-1 : sizeof(\"openssl_verify\")-1, 1);\n\tMAKE_STD_ZVAL(zsig);\n\tZVAL_STRINGL(zsig, *signature, *signature_len, 1);\n\tMAKE_STD_ZVAL(zkey);\n\tZVAL_STRINGL(zkey, key, key_len, 1);\n\tzp[0] = &zdata;\n\tzp[1] = &zsig;\n\tzp[2] = &zkey;\n\n\tphp_stream_rewind(fp);\n\tZ_TYPE_P(zdata) = IS_STRING;\n\tZ_STRLEN_P(zdata) = end;\n\n\tif (end != (off_t) php_stream_copy_to_mem(fp, &(Z_STRVAL_P(zdata)), (size_t) end, 0)) {\n\t\tzval_dtor(zdata);\n\t\tzval_dtor(zsig);\n\t\tzval_dtor(zkey);\n\t\tzval_dtor(openssl);\n\t\tefree(openssl);\n\t\tefree(zdata);\n\t\tefree(zkey);\n\t\tefree(zsig);\n\t\treturn FAILURE;\n\t}\n\n\tif (FAILURE == zend_fcall_info_init(openssl, 0, &fci, &fcc, NULL, NULL TSRMLS_CC)) {\n\t\tzval_dtor(zdata);\n\t\tzval_dtor(zsig);\n\t\tzval_dtor(zkey);\n\t\tzval_dtor(openssl);\n\t\tefree(openssl);\n\t\tefree(zdata);\n\t\tefree(zkey);\n\t\tefree(zsig);\n\t\treturn FAILURE;\n\t}\n\n\tfci.param_count = 3;\n\tfci.params = zp;\n\tZ_ADDREF_P(zdata);\n\tif (is_sign) {\n\t\tZ_SET_ISREF_P(zsig);\n\t} else {\n\t\tZ_ADDREF_P(zsig);\n\t}\n\tZ_ADDREF_P(zkey);\n\n\tfci.retval_ptr_ptr = &retval_ptr;\n\n\tif (FAILURE == zend_call_function(&fci, &fcc TSRMLS_CC)) {\n\t\tzval_dtor(zdata);\n\t\tzval_dtor(zsig);\n\t\tzval_dtor(zkey);\n\t\tzval_dtor(openssl);\n\t\tefree(openssl);\n\t\tefree(zdata);\n\t\tefree(zkey);\n\t\tefree(zsig);\n\t\treturn FAILURE;\n\t}\n\n\tzval_dtor(openssl);\n\tefree(openssl);\n\tZ_DELREF_P(zdata);\n\n\tif (is_sign) {\n\t\tZ_UNSET_ISREF_P(zsig);\n\t} else {\n\t\tZ_DELREF_P(zsig);\n\t}\n\tZ_DELREF_P(zkey);\n\n\tzval_dtor(zdata);\n\tefree(zdata);\n\tzval_dtor(zkey);\n\tefree(zkey);\n\n\tswitch (Z_TYPE_P(retval_ptr)) {\n\t\tdefault:\n\t\tcase IS_LONG:\n\t\t\tzval_dtor(zsig);\n\t\t\tefree(zsig);\n\t\t\tif (1 == Z_LVAL_P(retval_ptr)) {\n\t\t\t\tefree(retval_ptr);\n\t\t\t\treturn SUCCESS;\n\t\t\t}\n\t\t\tefree(retval_ptr);\n\t\t\treturn FAILURE;\n\t\tcase IS_BOOL:\n\t\t\tefree(retval_ptr);\n\t\t\tif (Z_BVAL_P(retval_ptr)) {\n\t\t\t\t*signature = estrndup(Z_STRVAL_P(zsig), Z_STRLEN_P(zsig));\n\t\t\t\t*signature_len = Z_STRLEN_P(zsig);\n\t\t\t\tzval_dtor(zsig);\n\t\t\t\tefree(zsig);\n\t\t\t\treturn SUCCESS;\n\t\t\t}\n\t\t\tzval_dtor(zsig);\n\t\t\tefree(zsig);\n\t\t\treturn FAILURE;\n\t}\n}\n/* }}} */\n#endif /* #ifndef PHAR_HAVE_OPENSSL */\n\nint phar_verify_signature(php_stream *fp, size_t end_of_phar, php_uint32 sig_type, char *sig, int sig_len, char *fname, char **signature, int *signature_len, char **error TSRMLS_DC) /* {{{ */\n{\n\tint read_size, len;\n\toff_t read_len;\n\tunsigned char buf[1024];\n\n\tphp_stream_rewind(fp);\n\n\tswitch (sig_type) {\n\t\tcase PHAR_SIG_OPENSSL: {\n#ifdef PHAR_HAVE_OPENSSL\n\t\t\tBIO *in;\n\t\t\tEVP_PKEY *key;\n\t\t\tEVP_MD *mdtype = (EVP_MD *) EVP_sha1();\n\t\t\tEVP_MD_CTX md_ctx;\n#else\n\t\t\tint tempsig;\n#endif\n\t\t\tphp_uint32 pubkey_len;\n\t\t\tchar *pubkey = NULL, *pfile;\n\t\t\tphp_stream *pfp;\n#ifndef PHAR_HAVE_OPENSSL\n\t\t\tif (!zend_hash_exists(&module_registry, \"openssl\", sizeof(\"openssl\"))) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"openssl not loaded\");\n\t\t\t\t}\n\t\t\t\treturn FAILURE;\n\t\t\t}\n#endif\n\t\t\t/* use __FILE__ . '.pubkey' for public key file */\n\t\t\tspprintf(&pfile, 0, \"%s.pubkey\", fname);\n\t\t\tpfp = php_stream_open_wrapper(pfile, \"rb\", 0, NULL);\n\t\t\tefree(pfile);\n\n#if PHP_MAJOR_VERSION > 5\n\t\t\tif (!pfp || !(pubkey_len = php_stream_copy_to_mem(pfp, (void **) &pubkey, PHP_STREAM_COPY_ALL, 0)) || !pubkey) {\n#else\n\t\t\tif (!pfp || !(pubkey_len = php_stream_copy_to_mem(pfp, &pubkey, PHP_STREAM_COPY_ALL, 0)) || !pubkey) {\n#endif\n\t\t\t\tif (pfp) {\n\t\t\t\t\tphp_stream_close(pfp);\n\t\t\t\t}\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"openssl public key could not be read\");\n\t\t\t\t}\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\tphp_stream_close(pfp);\n#ifndef PHAR_HAVE_OPENSSL\n\t\t\ttempsig = sig_len;\n\n\t\t\tif (FAILURE == phar_call_openssl_signverify(0, fp, end_of_phar, pubkey, pubkey_len, &sig, &tempsig TSRMLS_CC)) {\n\t\t\t\tif (pubkey) {\n\t\t\t\t\tefree(pubkey);\n\t\t\t\t}\n\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"openssl signature could not be verified\");\n\t\t\t\t}\n\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\tif (pubkey) {\n\t\t\t\tefree(pubkey);\n\t\t\t}\n\n\t\t\tsig_len = tempsig;\n#else\n\t\t\tin = BIO_new_mem_buf(pubkey, pubkey_len);\n\n\t\t\tif (NULL == in) {\n\t\t\t\tefree(pubkey);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"openssl signature could not be processed\");\n\t\t\t\t}\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\tkey = PEM_read_bio_PUBKEY(in, NULL,NULL, NULL);\n\t\t\tBIO_free(in);\n\t\t\tefree(pubkey);\n\n\t\t\tif (NULL == key) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"openssl signature could not be processed\");\n\t\t\t\t}\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\tEVP_VerifyInit(&md_ctx, mdtype);\n\t\t\tread_len = end_of_phar;\n\n\t\t\tif (read_len > sizeof(buf)) {\n\t\t\t\tread_size = sizeof(buf);\n\t\t\t} else {\n\t\t\t\tread_size = (int)read_len;\n\t\t\t}\n\n\t\t\tphp_stream_seek(fp, 0, SEEK_SET);\n\n\t\t\twhile (read_size && (len = php_stream_read(fp, (char*)buf, read_size)) > 0) {\n\t\t\t\tEVP_VerifyUpdate (&md_ctx, buf, len);\n\t\t\t\tread_len -= (off_t)len;\n\n\t\t\t\tif (read_len < read_size) {\n\t\t\t\t\tread_size = (int)read_len;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (EVP_VerifyFinal(&md_ctx, (unsigned char *)sig, sig_len, key) != 1) {\n\t\t\t\t/* 1: signature verified, 0: signature does not match, -1: failed signature operation */\n\t\t\t\tEVP_MD_CTX_cleanup(&md_ctx);\n\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"broken openssl signature\");\n\t\t\t\t}\n\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\tEVP_MD_CTX_cleanup(&md_ctx);\n#endif\n\n\t\t\t*signature_len = phar_hex_str((const char*)sig, sig_len, signature TSRMLS_CC);\n\t\t}\n\t\tbreak;\n#ifdef PHAR_HASH_OK\n\t\tcase PHAR_SIG_SHA512: {\n\t\t\tunsigned char digest[64];\n\t\t\tPHP_SHA512_CTX context;\n\n\t\t\tPHP_SHA512Init(&context);\n\t\t\tread_len = end_of_phar;\n\n\t\t\tif (read_len > sizeof(buf)) {\n\t\t\t\tread_size = sizeof(buf);\n\t\t\t} else {\n\t\t\t\tread_size = (int)read_len;\n\t\t\t}\n\n\t\t\twhile ((len = php_stream_read(fp, (char*)buf, read_size)) > 0) {\n\t\t\t\tPHP_SHA512Update(&context, buf, len);\n\t\t\t\tread_len -= (off_t)len;\n\t\t\t\tif (read_len < read_size) {\n\t\t\t\t\tread_size = (int)read_len;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tPHP_SHA512Final(digest, &context);\n\n\t\t\tif (memcmp(digest, sig, sizeof(digest))) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"broken signature\");\n\t\t\t\t}\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\t*signature_len = phar_hex_str((const char*)digest, sizeof(digest), signature TSRMLS_CC);\n\t\t\tbreak;\n\t\t}\n\t\tcase PHAR_SIG_SHA256: {\n\t\t\tunsigned char digest[32];\n\t\t\tPHP_SHA256_CTX context;\n\n\t\t\tPHP_SHA256Init(&context);\n\t\t\tread_len = end_of_phar;\n\n\t\t\tif (read_len > sizeof(buf)) {\n\t\t\t\tread_size = sizeof(buf);\n\t\t\t} else {\n\t\t\t\tread_size = (int)read_len;\n\t\t\t}\n\n\t\t\twhile ((len = php_stream_read(fp, (char*)buf, read_size)) > 0) {\n\t\t\t\tPHP_SHA256Update(&context, buf, len);\n\t\t\t\tread_len -= (off_t)len;\n\t\t\t\tif (read_len < read_size) {\n\t\t\t\t\tread_size = (int)read_len;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tPHP_SHA256Final(digest, &context);\n\n\t\t\tif (memcmp(digest, sig, sizeof(digest))) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"broken signature\");\n\t\t\t\t}\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\t*signature_len = phar_hex_str((const char*)digest, sizeof(digest), signature TSRMLS_CC);\n\t\t\tbreak;\n\t\t}\n#else\n\t\tcase PHAR_SIG_SHA512:\n\t\tcase PHAR_SIG_SHA256:\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"unsupported signature\");\n\t\t\t}\n\t\t\treturn FAILURE;\n#endif\n\t\tcase PHAR_SIG_SHA1: {\n\t\t\tunsigned char digest[20];\n\t\t\tPHP_SHA1_CTX  context;\n\n\t\t\tPHP_SHA1Init(&context);\n\t\t\tread_len = end_of_phar;\n\n\t\t\tif (read_len > sizeof(buf)) {\n\t\t\t\tread_size = sizeof(buf);\n\t\t\t} else {\n\t\t\t\tread_size = (int)read_len;\n\t\t\t}\n\n\t\t\twhile ((len = php_stream_read(fp, (char*)buf, read_size)) > 0) {\n\t\t\t\tPHP_SHA1Update(&context, buf, len);\n\t\t\t\tread_len -= (off_t)len;\n\t\t\t\tif (read_len < read_size) {\n\t\t\t\t\tread_size = (int)read_len;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tPHP_SHA1Final(digest, &context);\n\n\t\t\tif (memcmp(digest, sig, sizeof(digest))) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"broken signature\");\n\t\t\t\t}\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\t*signature_len = phar_hex_str((const char*)digest, sizeof(digest), signature TSRMLS_CC);\n\t\t\tbreak;\n\t\t}\n\t\tcase PHAR_SIG_MD5: {\n\t\t\tunsigned char digest[16];\n\t\t\tPHP_MD5_CTX   context;\n\n\t\t\tPHP_MD5Init(&context);\n\t\t\tread_len = end_of_phar;\n\n\t\t\tif (read_len > sizeof(buf)) {\n\t\t\t\tread_size = sizeof(buf);\n\t\t\t} else {\n\t\t\t\tread_size = (int)read_len;\n\t\t\t}\n\n\t\t\twhile ((len = php_stream_read(fp, (char*)buf, read_size)) > 0) {\n\t\t\t\tPHP_MD5Update(&context, buf, len);\n\t\t\t\tread_len -= (off_t)len;\n\t\t\t\tif (read_len < read_size) {\n\t\t\t\t\tread_size = (int)read_len;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tPHP_MD5Final(digest, &context);\n\n\t\t\tif (memcmp(digest, sig, sizeof(digest))) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"broken signature\");\n\t\t\t\t}\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\t*signature_len = phar_hex_str((const char*)digest, sizeof(digest), signature TSRMLS_CC);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"broken or unsupported signature\");\n\t\t\t}\n\t\t\treturn FAILURE;\n\t}\n\treturn SUCCESS;\n}\n/* }}} */\n", "target": 1, "idx": 177745}
{"func": "receive_carbon(void **state)\n{\n    prof_input(\"/carbons on\");\n\n    prof_connect();\n    assert_true(stbbr_received(\n        \"<iq id='*' type='set'><enable xmlns='urn:xmpp:carbons:2'/></iq>\"\n    ));\n\n    stbbr_send(\n        \"<presence to='stabber@localhost' from='buddy1@localhost/mobile'>\"\n            \"<priority>10</priority>\"\n            \"<status>On my mobile</status>\"\n        \"</presence>\"\n    );\n    assert_true(prof_output_exact(\"Buddy1 (mobile) is online, \\\"On my mobile\\\"\"));\n    prof_input(\"/msg Buddy1\");\n     assert_true(prof_output_exact(\"unencrypted\"));\n \n     stbbr_send(\n        \"<message type='chat' to='stabber@localhost/profanity' from='buddy1@localhost'>\"\n             \"<received xmlns='urn:xmpp:carbons:2'>\"\n                 \"<forwarded xmlns='urn:xmpp:forward:0'>\"\n                     \"<message id='prof_msg_7' xmlns='jabber:client' type='chat' lang='en' to='stabber@localhost/profanity' from='buddy1@localhost/mobile'>\"\n                        \"<body>test carbon from recipient</body>\"\n                    \"</message>\"\n                \"</forwarded>\"\n            \"</received>\"\n        \"</message>\"\n    );\n\n    assert_true(prof_output_regex(\"Buddy1/mobile: .+test carbon from recipient\"));\n}\n", "target": 1, "idx": 181555}
{"func": "void SpeechSynthesis::handleSpeakingCompleted(SpeechSynthesisUtterance* utterance, bool errorOccurred)\n {\n     ASSERT(utterance);\n \n     bool didJustFinishCurrentUtterance = false;\n    if (utterance == currentSpeechUtterance()) {\n        m_utteranceQueue.removeFirst();\n        didJustFinishCurrentUtterance = true;\n    }\n\n    fireEvent(errorOccurred ? EventTypeNames::error : EventTypeNames::end, utterance, 0, String());\n\n    if (didJustFinishCurrentUtterance && !m_utteranceQueue.isEmpty())\n        startSpeakingImmediately();\n}\n", "target": 1, "idx": 185386}
{"func": " void WebPagePrivate::didComposite()\n {\n     if (!m_page->settings()->developerExtrasEnabled())\n         return;\n    InspectorInstrumentation::didComposite(m_page);\n }\n", "target": 1, "idx": 184485}
{"func": "void sched_destroy_group(struct task_group *tg)\n{\n\tunsigned long flags;\n\tint i;\n\n\t/* end participation in shares distribution */\n\tfor_each_possible_cpu(i)\n\t\tunregister_fair_sched_group(tg, i);\n\n\tspin_lock_irqsave(&task_group_lock, flags);\n\tlist_del_rcu(&tg->list);\n\tlist_del_rcu(&tg->siblings);\n\tspin_unlock_irqrestore(&task_group_lock, flags);\n\n\t/* wait for possible concurrent references to cfs_rqs complete */\n\tcall_rcu(&tg->rcu, free_sched_group_rcu);\n}\n", "target": 0, "idx": 26323}
{"func": "NDIS_STATUS ParaNdis6_ReceivePauseRestart(\n    PARANDIS_ADAPTER *pContext,\n    BOOLEAN bPause,\n    ONPAUSECOMPLETEPROC Callback\n    )\n{\n    NDIS_STATUS status = NDIS_STATUS_SUCCESS;\n\n    if (bPause)\n    {\n        CNdisPassiveWriteAutoLock tLock(pContext->m_PauseLock);\n\n        ParaNdis_DebugHistory(pContext, hopInternalReceivePause, NULL, 1, 0, 0);\n        if (pContext->m_upstreamPacketPending != 0)\n        {\n            pContext->ReceiveState = srsPausing;\n            pContext->ReceivePauseCompletionProc = Callback;\n            status = NDIS_STATUS_PENDING;\n        }\n        else\n        {\n            ParaNdis_DebugHistory(pContext, hopInternalReceivePause, NULL, 0, 0, 0);\n            pContext->ReceiveState = srsDisabled;\n        }\n    }\n    else\n    {\n        ParaNdis_DebugHistory(pContext, hopInternalReceiveResume, NULL, 0, 0, 0);\n        pContext->ReceiveState = srsEnabled;\n    }\n    return status;\n}\n", "target": 0, "idx": 96359}
{"func": "void gdImageCopyMerge (gdImagePtr dst, gdImagePtr src, int dstX, int dstY, int srcX, int srcY, int w, int h, int pct)\n{\n\tint c, dc;\n\tint x, y;\n \tint tox, toy;\n \tint ncR, ncG, ncB;\n \ttoy = dstY;\n \tfor (y = srcY; y < (srcY + h); y++) {\n \t\ttox = dstX;\n \t\tfor (x = srcX; x < (srcX + w); x++) {\n\t\t\tint nc;\n\t\t\tc = gdImageGetPixel(src, x, y);\n\t\t\t/* Added 7/24/95: support transparent copies */\n\t\t\tif (gdImageGetTransparent(src) == c) {\n\t\t\t\ttox++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* If it's the same image, mapping is trivial */\n\t\t\tif (dst == src) {\n\t\t\t\tnc = c;\n\t\t\t} else {\n\t\t\t\tdc = gdImageGetPixel(dst, tox, toy);\n\n \t\t\t\tncR = (int)(gdImageRed (src, c) * (pct / 100.0) + gdImageRed (dst, dc) * ((100 - pct) / 100.0));\n \t\t\t\tncG = (int)(gdImageGreen (src, c) * (pct / 100.0) + gdImageGreen (dst, dc) * ((100 - pct) / 100.0));\n \t\t\t\tncB = (int)(gdImageBlue (src, c) * (pct / 100.0) + gdImageBlue (dst, dc) * ((100 - pct) / 100.0));\n\n\t\t\t\t/* Find a reasonable color */\n\t\t\t\tnc = gdImageColorResolve (dst, ncR, ncG, ncB);\n\t\t\t}\n\t\t\tgdImageSetPixel (dst, tox, toy, nc);\n\t\t\ttox++;\n\t\t}\n\t\ttoy++;\n\t}\n}\n", "target": 1, "idx": 180297}
{"func": "void Tab::OnMouseReleased(const ui::MouseEvent& event) {\n  controller_->OnMouseEventInTab(this, event);\n\n  if (controller_->EndDrag(END_DRAG_COMPLETE))\n    return;\n\n  if (event.IsMiddleMouseButton()) {\n    if (HitTestPoint(event.location())) {\n      controller_->CloseTab(this, CLOSE_TAB_FROM_MOUSE);\n    } else if (closing_) {\n      gfx::Point location_in_parent = event.location();\n      ConvertPointToTarget(this, parent(), &location_in_parent);\n      Tab* closest_tab = controller_->GetTabAt(location_in_parent);\n      if (closest_tab)\n        controller_->CloseTab(closest_tab, CLOSE_TAB_FROM_MOUSE);\n    }\n  } else if (event.IsOnlyLeftMouseButton() && !event.IsShiftDown() &&\n             !IsSelectionModifierDown(event)) {\n    controller_->SelectTab(this, event);\n  }\n}\n", "target": 0, "idx": 153344}
{"func": "bool IsGoogleDomainUrl(const GURL& url,\n                       SubdomainPermission subdomain_permission,\n                       PortPermission port_permission) {\n  return IsValidURL(url, port_permission) &&\n         IsCanonicalHostGoogleHostname(url.host_piece(), subdomain_permission);\n}\n", "target": 0, "idx": 156079}
{"func": "static int aes_xts_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\n                          const unsigned char *in, size_t len)\n{\n    EVP_AES_XTS_CTX *xctx = EVP_C_DATA(EVP_AES_XTS_CTX,ctx);\n    if (!xctx->xts.key1 || !xctx->xts.key2)\n        return 0;\n    if (!out || !in || len < AES_BLOCK_SIZE)\n        return 0;\n    if (xctx->stream)\n        (*xctx->stream) (in, out, len,\n                         xctx->xts.key1, xctx->xts.key2,\n                         EVP_CIPHER_CTX_iv_noconst(ctx));\n    else if (CRYPTO_xts128_encrypt(&xctx->xts, EVP_CIPHER_CTX_iv_noconst(ctx),\n                                   in, out, len,\n                                   EVP_CIPHER_CTX_encrypting(ctx)))\n        return 0;\n    return 1;\n}\n", "target": 0, "idx": 69340}
{"func": "static __always_inline int __do_follow_link(struct path *path, struct nameidata *nd)\n{\n\tint error;\n\tvoid *cookie;\n\tstruct dentry *dentry = path->dentry;\n\n\ttouch_atime(path->mnt, dentry);\n\tnd_set_link(nd, NULL);\n\n\tif (path->mnt != nd->path.mnt) {\n\t\tpath_to_nameidata(path, nd);\n \t\tdget(dentry);\n \t}\n \tmntget(path->mnt);\n \tcookie = dentry->d_inode->i_op->follow_link(dentry, nd);\n \terror = PTR_ERR(cookie);\n \tif (!IS_ERR(cookie)) {\n\t\tchar *s = nd_get_link(nd);\n\t\terror = 0;\n\t\tif (s)\n\t\t\terror = __vfs_follow_link(nd, s);\n\t\telse if (nd->last_type == LAST_BIND) {\n\t\t\terror = force_reval_path(&nd->path, nd);\n\t\t\tif (error)\n\t\t\t\tpath_put(&nd->path);\n\t\t}\n\t\tif (dentry->d_inode->i_op->put_link)\n\t\t\tdentry->d_inode->i_op->put_link(dentry, nd, cookie);\n\t}\n\treturn error;\n}\n", "target": 1, "idx": 179626}
{"func": "void SSLClientSocketOpenSSL::OnSendComplete(int result) {\n  if (next_handshake_state_ == STATE_HANDSHAKE) {\n    OnHandshakeIOComplete(result);\n    return;\n  }\n\n  int rv_read = ERR_IO_PENDING;\n  int rv_write = ERR_IO_PENDING;\n  bool network_moved;\n  do {\n    if (user_read_buf_.get())\n      rv_read = DoPayloadRead();\n    if (user_write_buf_.get())\n      rv_write = DoPayloadWrite();\n    network_moved = DoTransportIO();\n  } while (rv_read == ERR_IO_PENDING && rv_write == ERR_IO_PENDING &&\n           (user_read_buf_.get() || user_write_buf_.get()) && network_moved);\n\n  base::WeakPtr<SSLClientSocketOpenSSL> guard(weak_factory_.GetWeakPtr());\n  if (user_read_buf_.get() && rv_read != ERR_IO_PENDING)\n    DoReadCallback(rv_read);\n\n  if (!guard.get())\n    return;\n\n  if (user_write_buf_.get() && rv_write != ERR_IO_PENDING)\n    DoWriteCallback(rv_write);\n}\n", "target": 0, "idx": 133775}
{"func": "static inline int rt_scope(int ifa_scope)\n{\n\tif (ifa_scope & IFA_HOST)\n\t\treturn RT_SCOPE_HOST;\n\telse if (ifa_scope & IFA_LINK)\n\t\treturn RT_SCOPE_LINK;\n\telse if (ifa_scope & IFA_SITE)\n\t\treturn RT_SCOPE_SITE;\n\telse\n\t\treturn RT_SCOPE_UNIVERSE;\n}\n", "target": 0, "idx": 41885}
{"func": " virtual bool DnsResolveEx(const std::string& host,\n                            std::string* ip_address_list) {\n    dns_resolves_ex.push_back(host);\n *ip_address_list = dns_resolve_ex_result;\n return !dns_resolve_ex_result.empty();\n }\n", "target": 0, "idx": 177726}
{"func": " set_text_distance(gs_point *pdist, double dx, double dy, const gs_matrix *pmat)\n {\n    int code = gs_distance_transform_inverse(dx, dy, pmat, pdist);\n     double rounded;\n \n     if (code == gs_error_undefinedresult) {\n         /* The CTM is degenerate.\n            Can't know the distance in user space.\n    } else if (code < 0)\n        return code;\n    /* If the distance is very close to integers, round it. */\n    if (fabs(pdist->x - (rounded = floor(pdist->x + 0.5))) < 0.0005)\n        pdist->x = rounded;\n    if (fabs(pdist->y - (rounded = floor(pdist->y + 0.5))) < 0.0005)\n        pdist->y = rounded;\n    return 0;\n}\n", "target": 1, "idx": 178070}
{"func": "int Textfield::OnDragUpdated(const ui::DropTargetEvent& event) {\n  DCHECK(CanDrop(event.data()));\n  gfx::RenderText* render_text = GetRenderText();\n  const gfx::Range& selection = render_text->selection();\n  drop_cursor_position_ = render_text->FindCursorPosition(event.location());\n  bool in_selection =\n      !selection.is_empty() &&\n      selection.Contains(gfx::Range(drop_cursor_position_.caret_pos()));\n  drop_cursor_visible_ = !in_selection;\n  OnCaretBoundsChanged();\n  SchedulePaint();\n\n  StopBlinkingCursor();\n\n  if (initiating_drag_) {\n    if (in_selection)\n      return ui::DragDropTypes::DRAG_NONE;\n    return event.IsControlDown() ? ui::DragDropTypes::DRAG_COPY\n                                 : ui::DragDropTypes::DRAG_MOVE;\n  }\n  return ui::DragDropTypes::DRAG_COPY | ui::DragDropTypes::DRAG_MOVE;\n}\n", "target": 0, "idx": 137253}
{"func": "Node* Range::pastLastNode() const\n{\n    if (!m_start.container() || !m_end.container())\n        return 0;\n    if (m_end.container()->offsetInCharacters())\n        return m_end.container()->traverseNextSibling();\n    if (Node* child = m_end.container()->childNode(m_end.offset()))\n        return child;\n    return m_end.container()->traverseNextSibling();\n}\n", "target": 0, "idx": 105136}
{"func": "RenderWidgetHostView* RenderWidgetHostImpl::GetView() const {\n  return view_;\n}\n", "target": 0, "idx": 122975}
{"func": "void ResourceDispatcherHostImpl::OnSSLCertificateError(\n    net::URLRequest* request,\n    const net::SSLInfo& ssl_info,\n    bool is_hsts_host) {\n  DCHECK(request);\n  ResourceRequestInfoImpl* info = ResourceRequestInfoImpl::ForRequest(request);\n  DCHECK(info);\n  GlobalRequestID request_id(info->GetChildID(), info->GetRequestID());\n  int render_process_id;\n   int render_view_id;\n   if(!info->GetAssociatedRenderView(&render_process_id, &render_view_id))\n     NOTREACHED();\n  SSLManager::OnSSLCertificateError(ssl_delegate_weak_factory_.GetWeakPtr(),\n      request_id, info->GetResourceType(), request->url(), render_process_id,\n      render_view_id, ssl_info, is_hsts_host);\n }\n", "target": 1, "idx": 184681}
{"func": "static void tg3_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\n{\n\tstruct tg3 *tp = netdev_priv(dev);\n\n\tstrlcpy(info->driver, DRV_MODULE_NAME, sizeof(info->driver));\n\tstrlcpy(info->version, DRV_MODULE_VERSION, sizeof(info->version));\n\tstrlcpy(info->fw_version, tp->fw_ver, sizeof(info->fw_version));\n\tstrlcpy(info->bus_info, pci_name(tp->pdev), sizeof(info->bus_info));\n}\n", "target": 0, "idx": 32555}
{"func": "static int ghash_final(struct shash_desc *desc, u8 *dst)\n{\n\tstruct ghash_desc_ctx *dctx = shash_desc_ctx(desc);\n \tstruct ghash_ctx *ctx = crypto_shash_ctx(desc->tfm);\n \tu8 *buf = dctx->buffer;\n \n \tghash_flush(ctx, dctx);\n \tmemcpy(dst, buf, GHASH_BLOCK_SIZE);\n \n\treturn 0;\n}\n", "target": 1, "idx": 178914}
{"func": "Platform::IntPoint InRegionScrollableArea::calculateMaximumScrollPosition(const Platform::IntSize& viewportSize, const Platform::IntSize& contentsSize, float overscrollLimitFactor) const\n{\n    ASSERT(!allowsOverscroll());\n    return Platform::IntPoint(std::max(contentsSize.width() - viewportSize.width(), 0) + overscrollLimitFactor,\n                              std::max(contentsSize.height() - viewportSize.height(), 0) + overscrollLimitFactor);\n}\n", "target": 1, "idx": 183889}
{"func": "RenderSandboxHostLinux::~RenderSandboxHostLinux() {\n  if (init_) {\n    if (HANDLE_EINTR(close(renderer_socket_)) < 0)\n      PLOG(ERROR) << \"close\";\n    if (HANDLE_EINTR(close(childs_lifeline_fd_)) < 0)\n      PLOG(ERROR) << \"close\";\n  }\n}\n", "target": 0, "idx": 99412}
{"func": "  void Initialize(ChannelLayout channel_layout, int bits_per_channel) {\n     AudioParameters params(\n         media::AudioParameters::AUDIO_PCM_LINEAR, channel_layout,\n        kSamplesPerSecond, bits_per_channel, kRawDataSize);\n \n     algorithm_.Initialize(1, params, base::Bind(\n         &AudioRendererAlgorithmTest::EnqueueData, base::Unretained(this)));\n    EnqueueData();\n  }\n", "target": 1, "idx": 185237}
{"func": "static v8::Handle<v8::Value> methodWithNonOptionalArgAndOptionalArgCallback(const v8::Arguments& args)\n {\n     INC_STATS(\"DOM.TestObj.methodWithNonOptionalArgAndOptionalArg\");\n     if (args.Length() < 1)\n        return V8Proxy::throwNotEnoughArgumentsError();\n     TestObj* imp = V8TestObj::toNative(args.Holder());\n     EXCEPTION_BLOCK(int, nonOpt, toInt32(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));\n     if (args.Length() <= 1) {\n        imp->methodWithNonOptionalArgAndOptionalArg(nonOpt);\n        return v8::Handle<v8::Value>();\n    }\n    EXCEPTION_BLOCK(int, opt, toInt32(MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined)));\n    imp->methodWithNonOptionalArgAndOptionalArg(nonOpt, opt);\n    return v8::Handle<v8::Value>();\n}\n", "target": 1, "idx": 184782}
{"func": "static inline bool match_option(const char *arg, int arglen, const char *opt)\n{\n\tint len = strlen(opt);\n\n\treturn len == arglen && !strncmp(arg, opt, len);\n}\n", "target": 0, "idx": 79077}
{"func": "int NaClIPCAdapter::RewrittenMessage::Read(char* dest_buffer,\n                                           size_t dest_buffer_size) {\n  CHECK(data_len_ >= data_read_cursor_);\n  size_t bytes_to_write = std::min(dest_buffer_size,\n                                   data_len_ - data_read_cursor_);\n  if (bytes_to_write == 0)\n    return 0;\n\n  memcpy(dest_buffer, &data_[data_read_cursor_], bytes_to_write);\n  data_read_cursor_ += bytes_to_write;\n  return static_cast<int>(bytes_to_write);\n}\n", "target": 0, "idx": 110251}
{"func": " static void php_snmp_object_free_storage(void *object TSRMLS_DC)\n {\n        php_snmp_object *intern = (php_snmp_object *)object;\n        if (!intern) {\n                return;\n        }\n\n        netsnmp_session_free(&(intern->session));\n \n        zend_object_std_dtor(&intern->zo TSRMLS_CC);\n        efree(intern);\n }\n", "target": 1, "idx": 178149}
{"func": "static void cfundecs(JF, js_Ast *list)\n{\n\twhile (list) {\n\t\tjs_Ast *stm = list->a;\n\t\tif (stm->type == AST_FUNDEC) {\n\t\t\temitline(J, F, stm);\n\t\t\temitfunction(J, F, newfun(J, stm->line, stm->a, stm->b, stm->c, 0, F->strict));\n\t\t\temitline(J, F, stm);\n\t\t\temit(J, F, OP_SETLOCAL);\n\t\t\temitarg(J, F, addlocal(J, F, stm->a, 0));\n\t\t\temit(J, F, OP_POP);\n\t\t}\n\t\tlist = list->b;\n\t}\n}\n", "target": 0, "idx": 90717}
{"func": " int SoundPool::load(int fd, int64_t offset, int64_t length, int priority __unused)\n {\n     ALOGV(\"load: fd=%d, offset=%\" PRId64 \", length=%\" PRId64 \", priority=%d\",\n             fd, offset, length, priority);\n    Mutex::Autolock lock(&mLock);\n    sp<Sample> sample = new Sample(++mNextSampleID, fd, offset, length);\n    mSamples.add(sample->sampleID(), sample);\n    doLoad(sample);\n    return sample->sampleID();\n}\n", "target": 1, "idx": 187984}
{"func": "void mp_decode_to_lua_array(lua_State *L, mp_cur *c, size_t len) {\n    assert(len <= UINT_MAX);\n     int index = 1;\n \n     lua_newtable(L);\n     while(len--) {\n         lua_pushnumber(L,index++);\n         mp_decode_to_lua_type(L,c);\n        if (c->err) return;\n        lua_settable(L,-3);\n    }\n}\n", "target": 1, "idx": 182410}
{"func": "static int ssl_parse_server_key_exchange( mbedtls_ssl_context *ssl )\n{\n    int ret;\n    const mbedtls_ssl_ciphersuite_t *ciphersuite_info =\n        ssl->transform_negotiate->ciphersuite_info;\n    unsigned char *p = NULL, *end = NULL;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> parse server key exchange\" ) );\n\n#if defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= skip parse server key exchange\" ) );\n        ssl->state++;\n        return( 0 );\n    }\n    ((void) p);\n    ((void) end);\n#endif\n\n#if defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) || \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_RSA ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA )\n    {\n        if( ( ret = ssl_get_ecdh_params_from_cert( ssl ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"ssl_get_ecdh_params_from_cert\", ret );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n            return( ret );\n        }\n\n        MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= skip parse server key exchange\" ) );\n        ssl->state++;\n        return( 0 );\n    }\n    ((void) p);\n    ((void) end);\n#endif /* MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED */\n\n    if( ( ret = mbedtls_ssl_read_record( ssl ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_read_record\", ret );\n        return( ret );\n    }\n\n    if( ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE );\n        return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );\n    }\n\n    /*\n     * ServerKeyExchange may be skipped with PSK and RSA-PSK when the server\n     * doesn't use a psk_identity_hint\n     */\n    if( ssl->in_msg[0] != MBEDTLS_SSL_HS_SERVER_KEY_EXCHANGE )\n    {\n        if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||\n            ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK )\n        {\n            /* Current message is probably either\n             * CertificateRequest or ServerHelloDone */\n            ssl->keep_current_message = 1;\n            goto exit;\n        }\n\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"server key exchange message must \"\n                                    \"not be skipped\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE );\n\n        return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );\n    }\n\n    p   = ssl->in_msg + mbedtls_ssl_hs_hdr_len( ssl );\n    end = ssl->in_msg + ssl->in_hslen;\n    MBEDTLS_SSL_DEBUG_BUF( 3,   \"server key exchange\", p, end - p );\n\n#if defined(MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK )\n    {\n        if( ssl_parse_server_psk_hint( ssl, &p, end ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\n            return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n        }\n    } /* FALLTROUGH */\n#endif /* MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED */\n\n#if defined(MBEDTLS_KEY_EXCHANGE_PSK_ENABLED) ||                       \\\n    defined(MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK )\n        ; /* nothing more to do */\n    else\n#endif /* MBEDTLS_KEY_EXCHANGE_PSK_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED */\n#if defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED) ||                       \\\n    defined(MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_RSA ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK )\n    {\n        if( ssl_parse_server_dh_params( ssl, &p, end ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\n            return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n        }\n    }\n    else\n#endif /* MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED */\n#if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) ||                     \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED) ||                     \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_RSA ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA )\n    {\n        if( ssl_parse_server_ecdh_params( ssl, &p, end ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\n            return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n        }\n    }\n    else\n#endif /* MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED */\n#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE )\n    {\n        ret = mbedtls_ecjpake_read_round_two( &ssl->handshake->ecjpake_ctx,\n                                              p, end - p );\n        if( ret != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ecjpake_read_round_two\", ret );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\n            return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n        }\n    }\n    else\n#endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n        return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n    }\n\n#if defined(MBEDTLS_KEY_EXCHANGE__WITH_SERVER_SIGNATURE__ENABLED)\n    if( mbedtls_ssl_ciphersuite_uses_server_signature( ciphersuite_info ) )\n    {\n        size_t sig_len, hashlen;\n        unsigned char hash[64];\n        mbedtls_md_type_t md_alg = MBEDTLS_MD_NONE;\n        mbedtls_pk_type_t pk_alg = MBEDTLS_PK_NONE;\n        unsigned char *params = ssl->in_msg + mbedtls_ssl_hs_hdr_len( ssl );\n        size_t params_len = p - params;\n\n        /*\n         * Handle the digitally-signed structure\n         */\n#if defined(MBEDTLS_SSL_PROTO_TLS1_2)\n        if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )\n        {\n            if( ssl_parse_signature_algorithm( ssl, &p, end,\n                                               &md_alg, &pk_alg ) != 0 )\n            {\n                MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\n                mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                                MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\n                return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n            }\n\n            if( pk_alg != mbedtls_ssl_get_ciphersuite_sig_pk_alg( ciphersuite_info ) )\n            {\n                MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\n                mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                                MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\n                return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n            }\n        }\n        else\n#endif /* MBEDTLS_SSL_PROTO_TLS1_2 */\n#if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \\\n    defined(MBEDTLS_SSL_PROTO_TLS1_1)\n        if( ssl->minor_ver < MBEDTLS_SSL_MINOR_VERSION_3 )\n        {\n            pk_alg = mbedtls_ssl_get_ciphersuite_sig_pk_alg( ciphersuite_info );\n\n            /* Default hash for ECDSA is SHA-1 */\n            if( pk_alg == MBEDTLS_PK_ECDSA && md_alg == MBEDTLS_MD_NONE )\n                md_alg = MBEDTLS_MD_SHA1;\n        }\n        else\n#endif\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n            return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n        }\n\n         /*\n          * Read signature\n          */\n         sig_len = ( p[0] << 8 ) | p[1];\n         p += 2;\n \n        if( end != p + sig_len )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n            return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n        }\n\n        MBEDTLS_SSL_DEBUG_BUF( 3, \"signature\", p, sig_len );\n\n        /*\n         * Compute the hash that has been signed\n         */\n#if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \\\n    defined(MBEDTLS_SSL_PROTO_TLS1_1)\n        if( md_alg == MBEDTLS_MD_NONE )\n        {\n            hashlen = 36;\n            ret = mbedtls_ssl_get_key_exchange_md_ssl_tls( ssl, hash, params,\n                                                           params_len );\n            if( ret != 0 )\n                return( ret );\n        }\n        else\n#endif /* MBEDTLS_SSL_PROTO_SSL3 || MBEDTLS_SSL_PROTO_TLS1 || \\\n          MBEDTLS_SSL_PROTO_TLS1_1 */\n#if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1) || \\\n    defined(MBEDTLS_SSL_PROTO_TLS1_2)\n        if( md_alg != MBEDTLS_MD_NONE )\n        {\n            /* Info from md_alg will be used instead */\n            hashlen = 0;\n            ret = mbedtls_ssl_get_key_exchange_md_tls1_2( ssl, hash, params,\n                                                          params_len, md_alg );\n            if( ret != 0 )\n                return( ret );\n        }\n        else\n#endif /* MBEDTLS_SSL_PROTO_TLS1 || MBEDTLS_SSL_PROTO_TLS1_1 || \\\n          MBEDTLS_SSL_PROTO_TLS1_2 */\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n            return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n        }\n\n        MBEDTLS_SSL_DEBUG_BUF( 3, \"parameters hash\", hash, hashlen != 0 ? hashlen :\n            (unsigned int) ( mbedtls_md_get_size( mbedtls_md_info_from_type( md_alg ) ) ) );\n\n        if( ssl->session_negotiate->peer_cert == NULL )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 2, ( \"certificate required\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n            return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );\n        }\n\n        /*\n         * Verify signature\n         */\n        if( ! mbedtls_pk_can_do( &ssl->session_negotiate->peer_cert->pk, pk_alg ) )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n            return( MBEDTLS_ERR_SSL_PK_TYPE_MISMATCH );\n        }\n\n        if( ( ret = mbedtls_pk_verify( &ssl->session_negotiate->peer_cert->pk,\n                               md_alg, hash, hashlen, p, sig_len ) ) != 0 )\n        {\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_DECRYPT_ERROR );\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_pk_verify\", ret );\n            return( ret );\n        }\n    }\n#endif /* MBEDTLS_KEY_EXCHANGE__WITH_SERVER_SIGNATURE__ENABLED */\n\nexit:\n    ssl->state++;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= parse server key exchange\" ) );\n\n    return( 0 );\n}\n", "target": 1, "idx": 182438}
{"func": "void DraggedTabGtk::SetContainerColorMap() {\n  GdkScreen* screen = gtk_widget_get_screen(container_);\n  GdkColormap* colormap = gdk_screen_get_rgba_colormap(screen);\n\n  if (!colormap)\n    colormap = gdk_screen_get_rgb_colormap(screen);\n\n  gtk_widget_set_colormap(container_, colormap);\n}\n", "target": 0, "idx": 98599}
{"func": "static int futex_wait_requeue_pi(u32 __user *uaddr, unsigned int flags,\n\t\t\t\t u32 val, ktime_t *abs_time, u32 bitset,\n\t\t\t\t u32 __user *uaddr2)\n{\n\tstruct hrtimer_sleeper timeout, *to = NULL;\n\tstruct rt_mutex_waiter rt_waiter;\n\tstruct rt_mutex *pi_mutex = NULL;\n\tstruct futex_hash_bucket *hb;\n\tunion futex_key key2 = FUTEX_KEY_INIT;\n \tstruct futex_q q = futex_q_init;\n \tint res, ret;\n \n \tif (!bitset)\n \t\treturn -EINVAL;\n \n\tif (abs_time) {\n\t\tto = &timeout;\n\t\thrtimer_init_on_stack(&to->timer, (flags & FLAGS_CLOCKRT) ?\n\t\t\t\t      CLOCK_REALTIME : CLOCK_MONOTONIC,\n\t\t\t\t      HRTIMER_MODE_ABS);\n\t\thrtimer_init_sleeper(to, current);\n\t\thrtimer_set_expires_range_ns(&to->timer, *abs_time,\n\t\t\t\t\t     current->timer_slack_ns);\n\t}\n\n\t/*\n\t * The waiter is allocated on our stack, manipulated by the requeue\n\t * code while we sleep on uaddr.\n\t */\n\tdebug_rt_mutex_init_waiter(&rt_waiter);\n\trt_waiter.task = NULL;\n\n\tret = get_futex_key(uaddr2, flags & FLAGS_SHARED, &key2, VERIFY_WRITE);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\n\tq.bitset = bitset;\n\tq.rt_waiter = &rt_waiter;\n\tq.requeue_pi_key = &key2;\n\n\t/*\n\t * Prepare to wait on uaddr. On success, increments q.key (key1) ref\n\t * count.\n\t */\n\tret = futex_wait_setup(uaddr, val, flags, &q, &hb);\n\tif (ret)\n\t\tgoto out_key2;\n\n\t/* Queue the futex_q, drop the hb lock, wait for wakeup. */\n\tfutex_wait_queue_me(hb, &q, to);\n\n\tspin_lock(&hb->lock);\n\tret = handle_early_requeue_pi_wakeup(hb, &q, &key2, to);\n\tspin_unlock(&hb->lock);\n\tif (ret)\n\t\tgoto out_put_keys;\n\n\t/*\n\t * In order for us to be here, we know our q.key == key2, and since\n\t * we took the hb->lock above, we also know that futex_requeue() has\n\t * completed and we no longer have to concern ourselves with a wakeup\n\t * race with the atomic proxy lock acquisition by the requeue code. The\n\t * futex_requeue dropped our key1 reference and incremented our key2\n\t * reference count.\n\t */\n\n\t/* Check if the requeue code acquired the second futex for us. */\n\tif (!q.rt_waiter) {\n\t\t/*\n\t\t * Got the lock. We might not be the anticipated owner if we\n\t\t * did a lock-steal - fix up the PI-state in that case.\n\t\t */\n\t\tif (q.pi_state && (q.pi_state->owner != current)) {\n\t\t\tspin_lock(q.lock_ptr);\n\t\t\tret = fixup_pi_state_owner(uaddr2, &q, current);\n\t\t\tspin_unlock(q.lock_ptr);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * We have been woken up by futex_unlock_pi(), a timeout, or a\n\t\t * signal.  futex_unlock_pi() will not destroy the lock_ptr nor\n\t\t * the pi_state.\n\t\t */\n\t\tWARN_ON(!q.pi_state);\n\t\tpi_mutex = &q.pi_state->pi_mutex;\n\t\tret = rt_mutex_finish_proxy_lock(pi_mutex, to, &rt_waiter, 1);\n\t\tdebug_rt_mutex_free_waiter(&rt_waiter);\n\n\t\tspin_lock(q.lock_ptr);\n\t\t/*\n\t\t * Fixup the pi_state owner and possibly acquire the lock if we\n\t\t * haven't already.\n\t\t */\n\t\tres = fixup_owner(uaddr2, &q, !ret);\n\t\t/*\n\t\t * If fixup_owner() returned an error, proprogate that.  If it\n\t\t * acquired the lock, clear -ETIMEDOUT or -EINTR.\n\t\t */\n\t\tif (res)\n\t\t\tret = (res < 0) ? res : 0;\n\n\t\t/* Unqueue and drop the lock. */\n\t\tunqueue_me_pi(&q);\n\t}\n\n\t/*\n\t * If fixup_pi_state_owner() faulted and was unable to handle the\n\t * fault, unlock the rt_mutex and return the fault to userspace.\n\t */\n\tif (ret == -EFAULT) {\n\t\tif (pi_mutex && rt_mutex_owner(pi_mutex) == current)\n\t\t\trt_mutex_unlock(pi_mutex);\n\t} else if (ret == -EINTR) {\n\t\t/*\n\t\t * We've already been requeued, but cannot restart by calling\n\t\t * futex_lock_pi() directly. We could restart this syscall, but\n\t\t * it would detect that the user space \"val\" changed and return\n\t\t * -EWOULDBLOCK.  Save the overhead of the restart and return\n\t\t * -EWOULDBLOCK directly.\n\t\t */\n\t\tret = -EWOULDBLOCK;\n\t}\n\nout_put_keys:\n\tput_futex_key(&q.key);\nout_key2:\n\tput_futex_key(&key2);\n\nout:\n\tif (to) {\n\t\thrtimer_cancel(&to->timer);\n\t\tdestroy_hrtimer_on_stack(&to->timer);\n\t}\n\treturn ret;\n}\n", "target": 1, "idx": 179720}
{"func": "void SyncBackendHost::StartConfiguration(Callback0::Type* callback) {\n  core_thread_.message_loop()->PostTask(FROM_HERE, NewRunnableMethod(\n    core_.get(),&SyncBackendHost::Core::DoStartConfiguration, callback));\n}\n", "target": 0, "idx": 106360}
{"func": "static void __netdev_adjacent_dev_unlink_neighbour(struct net_device *dev,\n\t\t\t\t\t\t   struct net_device *upper_dev)\n{\n\t__netdev_adjacent_dev_unlink_lists(dev, upper_dev, 1,\n\t\t\t\t\t   &dev->adj_list.upper,\n\t\t\t\t\t   &upper_dev->adj_list.lower);\n}\n", "target": 0, "idx": 93353}
{"func": "static int parse_report(transport_smart *transport, git_push *push)\n{\n\tgit_pkt *pkt = NULL;\n\tconst char *line_end = NULL;\n\tgitno_buffer *buf = &transport->buffer;\n\tint error, recvd;\n\tgit_buf data_pkt_buf = GIT_BUF_INIT;\n\n\tfor (;;) {\n\t\tif (buf->offset > 0)\n\t\t\terror = git_pkt_parse_line(&pkt, buf->data,\n\t\t\t\t\t\t   &line_end, buf->offset);\n\t\telse\n\t\t\terror = GIT_EBUFS;\n\n\t\tif (error < 0 && error != GIT_EBUFS) {\n\t\t\terror = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (error == GIT_EBUFS) {\n\t\t\tif ((recvd = gitno_recv(buf)) < 0) {\n\t\t\t\terror = recvd;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (recvd == 0) {\n\t\t\t\tgiterr_set(GITERR_NET, \"early EOF\");\n\t\t\t\terror = GIT_EEOF;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tgitno_consume(buf, line_end);\n \n \t\terror = 0;\n \n\t\tif (pkt == NULL)\n\t\t\tcontinue;\n \t\tswitch (pkt->type) {\n \t\t\tcase GIT_PKT_DATA:\n \t\t\t\t/* This is a sideband packet which contains other packets */\n\t\t\t\terror = add_push_report_sideband_pkt(push, (git_pkt_data *)pkt, &data_pkt_buf);\n\t\t\t\tbreak;\n\t\t\tcase GIT_PKT_ERR:\n\t\t\t\tgiterr_set(GITERR_NET, \"report-status: Error reported: %s\",\n\t\t\t\t\t((git_pkt_err *)pkt)->error);\n\t\t\t\terror = -1;\n\t\t\t\tbreak;\n\t\t\tcase GIT_PKT_PROGRESS:\n\t\t\t\tif (transport->progress_cb) {\n\t\t\t\t\tgit_pkt_progress *p = (git_pkt_progress *) pkt;\n\t\t\t\t\terror = transport->progress_cb(p->data, p->len, transport->message_cb_payload);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terror = add_push_report_pkt(push, pkt);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tgit_pkt_free(pkt);\n\n\t\t/* add_push_report_pkt returns GIT_ITEROVER when it receives a flush */\n\t\tif (error == GIT_ITEROVER) {\n\t\t\terror = 0;\n\t\t\tif (data_pkt_buf.size > 0) {\n\t\t\t\t/* If there was data remaining in the pack data buffer,\n\t\t\t\t * then the server sent a partial pkt-line */\n\t\t\t\tgiterr_set(GITERR_NET, \"Incomplete pack data pkt-line\");\n\t\t\t\terror = GIT_ERROR;\n\t\t\t}\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (error < 0) {\n\t\t\tgoto done;\n\t\t}\n\t}\ndone:\n\tgit_buf_free(&data_pkt_buf);\n\treturn error;\n}\n", "target": 1, "idx": 181701}
{"func": "static Image *ReadJNGImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    logging,\n    status;\n\n  MngInfo\n    *mng_info;\n\n  char\n    magic_number[MaxTextExtent];\n\n  size_t\n    count;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\"Enter ReadJNGImage()\");\n  image=AcquireImage(image_info);\n  mng_info=(MngInfo *) NULL;\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n\n  if (status == MagickFalse)\n    return((Image *) NULL);\n\n  if (LocaleCompare(image_info->magick,\"JNG\") != 0)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  /* Verify JNG signature.  */\n\n  count=(size_t) ReadBlob(image,8,(unsigned char *) magic_number);\n\n   if (count < 8 || memcmp(magic_number,\"\\213JNG\\r\\n\\032\\n\",8) != 0)\n     ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n \n   /* Allocate a MngInfo structure.  */\n \n   mng_info=(MngInfo *) AcquireMagickMemory(sizeof(*mng_info));\n\n  if (mng_info == (MngInfo *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  /* Initialize members of the MngInfo structure.  */\n\n  (void) ResetMagickMemory(mng_info,0,sizeof(MngInfo));\n\n  mng_info->image=image;\n  image=ReadOneJNGImage(mng_info,image_info,exception);\n  mng_info=MngInfoFreeStruct(mng_info);\n\n  if (image == (Image *) NULL)\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"exit ReadJNGImage() with error\");\n\n      return((Image *) NULL);\n    }\n  (void) CloseBlob(image);\n\n  if (image->columns == 0 || image->rows == 0)\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"exit ReadJNGImage() with error\");\n\n      ThrowReaderException(CorruptImageError,\"CorruptImage\");\n    }\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"exit ReadJNGImage()\");\n\n  return(image);\n}\n", "target": 1, "idx": 180983}
{"func": "static int unix_accept(struct socket *sock, struct socket *newsock, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sock *tsk;\n\tstruct sk_buff *skb;\n\tint err;\n\n\terr = -EOPNOTSUPP;\n\tif (sock->type != SOCK_STREAM && sock->type != SOCK_SEQPACKET)\n\t\tgoto out;\n\n\terr = -EINVAL;\n\tif (sk->sk_state != TCP_LISTEN)\n\t\tgoto out;\n\n\t/* If socket state is TCP_LISTEN it cannot change (for now...),\n\t * so that no locks are necessary.\n\t */\n\n\tskb = skb_recv_datagram(sk, 0, flags&O_NONBLOCK, &err);\n\tif (!skb) {\n\t\t/* This means receive shutdown. */\n\t\tif (err == 0)\n\t\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttsk = skb->sk;\n\tskb_free_datagram(sk, skb);\n\twake_up_interruptible(&unix_sk(sk)->peer_wait);\n\n\t/* attach accepted sock to socket */\n\tunix_state_lock(tsk);\n\tnewsock->state = SS_CONNECTED;\n\tsock_graft(tsk, newsock);\n\tunix_state_unlock(tsk);\n\treturn 0;\n\nout:\n\treturn err;\n}\n", "target": 0, "idx": 19283}
{"func": "WORD32 ih264d_video_decode(iv_obj_t *dec_hdl, void *pv_api_ip, void *pv_api_op)\n{\n /* ! */\n\n dec_struct_t * ps_dec = (dec_struct_t *)(dec_hdl->pv_codec_handle);\n\n    WORD32 i4_err_status = 0;\n    UWORD8 *pu1_buf = NULL;\n    WORD32 buflen;\n    UWORD32 u4_max_ofst, u4_length_of_start_code = 0;\n\n    UWORD32 bytes_consumed = 0;\n    UWORD32 cur_slice_is_nonref = 0;\n    UWORD32 u4_next_is_aud;\n    UWORD32 u4_first_start_code_found = 0;\n    WORD32 ret = 0,api_ret_value = IV_SUCCESS;\n    WORD32 header_data_left = 0,frame_data_left = 0;\n    UWORD8 *pu1_bitstrm_buf;\n ivd_video_decode_ip_t *ps_dec_ip;\n ivd_video_decode_op_t *ps_dec_op;\n\n    ithread_set_name((void*)\"Parse_thread\");\n\n    ps_dec_ip = (ivd_video_decode_ip_t *)pv_api_ip;\n    ps_dec_op = (ivd_video_decode_op_t *)pv_api_op;\n\n {\n        UWORD32 u4_size;\n        u4_size = ps_dec_op->u4_size;\n        memset(ps_dec_op, 0, sizeof(ivd_video_decode_op_t));\n        ps_dec_op->u4_size = u4_size;\n }\n\n    ps_dec->pv_dec_out = ps_dec_op;\n if(ps_dec->init_done != 1)\n {\n return IV_FAIL;\n }\n\n /*Data memory barries instruction,so that bitstream write by the application is complete*/\n    DATA_SYNC();\n\n if(0 == ps_dec->u1_flushfrm)\n {\n if(ps_dec_ip->pv_stream_buffer == NULL)\n {\n            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n            ps_dec_op->u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL;\n return IV_FAIL;\n }\n if(ps_dec_ip->u4_num_Bytes <= 0)\n {\n            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n            ps_dec_op->u4_error_code |= IVD_DEC_NUMBYTES_INV;\n return IV_FAIL;\n\n }\n }\n    ps_dec->u1_pic_decode_done = 0;\n\n    ps_dec_op->u4_num_bytes_consumed = 0;\n\n    ps_dec->ps_out_buffer = NULL;\n\n if(ps_dec_ip->u4_size\n >= offsetof(ivd_video_decode_ip_t, s_out_buffer))\n        ps_dec->ps_out_buffer = &ps_dec_ip->s_out_buffer;\n\n    ps_dec->u4_fmt_conv_cur_row = 0;\n\n    ps_dec->u4_output_present = 0;\n    ps_dec->s_disp_op.u4_error_code = 1;\n    ps_dec->u4_fmt_conv_num_rows = FMT_CONV_NUM_ROWS;\n if(0 == ps_dec->u4_share_disp_buf\n && ps_dec->i4_decode_header == 0)\n {\n        UWORD32 i;\n if(ps_dec->ps_out_buffer->u4_num_bufs == 0)\n {\n            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n            ps_dec_op->u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS;\n return IV_FAIL;\n }\n\n for(i = 0; i < ps_dec->ps_out_buffer->u4_num_bufs; i++)\n {\n if(ps_dec->ps_out_buffer->pu1_bufs[i] == NULL)\n {\n                ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n                ps_dec_op->u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL;\n return IV_FAIL;\n }\n\n if(ps_dec->ps_out_buffer->u4_min_out_buf_size[i] == 0)\n {\n                ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n                ps_dec_op->u4_error_code |=\n                                IVD_DISP_FRM_ZERO_OP_BUF_SIZE;\n return IV_FAIL;\n }\n }\n }\n\n if(ps_dec->u4_total_frames_decoded >= NUM_FRAMES_LIMIT)\n {\n        ps_dec_op->u4_error_code = ERROR_FRAME_LIMIT_OVER;\n return IV_FAIL;\n }\n\n /* ! */\n    ps_dec->u4_ts = ps_dec_ip->u4_ts;\n\n    ps_dec_op->u4_error_code = 0;\n    ps_dec_op->e_pic_type = -1;\n    ps_dec_op->u4_output_present = 0;\n    ps_dec_op->u4_frame_decoded_flag = 0;\n\n    ps_dec->i4_frametype = -1;\n    ps_dec->i4_content_type = -1;\n /*\n     * For field pictures, set the bottom and top picture decoded u4_flag correctly.\n     */\n {\n if((TOP_FIELD_ONLY | BOT_FIELD_ONLY) == ps_dec->u1_top_bottom_decoded)\n {\n            ps_dec->u1_top_bottom_decoded = 0;\n }\n }\n    ps_dec->u4_slice_start_code_found = 0;\n\n /* In case the deocder is not in flush mode(in shared mode),\n     then decoder has to pick up a buffer to write current frame.\n     Check if a frame is available in such cases */\n\n if(ps_dec->u1_init_dec_flag == 1 && ps_dec->u4_share_disp_buf == 1\n && ps_dec->u1_flushfrm == 0)\n {\n        UWORD32 i;\n\n        WORD32 disp_avail = 0, free_id;\n\n /* Check if at least one buffer is available with the codec */\n /* If not then return to application with error */\n for(i = 0; i < ps_dec->u1_pic_bufs; i++)\n {\n if(0 == ps_dec->u4_disp_buf_mapping[i]\n || 1 == ps_dec->u4_disp_buf_to_be_freed[i])\n {\n                disp_avail = 1;\n break;\n }\n\n }\n\n if(0 == disp_avail)\n {\n /* If something is queued for display wait for that buffer to be returned */\n\n            ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;\n            ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);\n return (IV_FAIL);\n }\n\n while(1)\n {\n pic_buffer_t *ps_pic_buf;\n            ps_pic_buf = (pic_buffer_t *)ih264_buf_mgr_get_next_free(\n (buf_mgr_t *)ps_dec->pv_pic_buf_mgr, &free_id);\n\n if(ps_pic_buf == NULL)\n {\n                UWORD32 i, display_queued = 0;\n\n /* check if any buffer was given for display which is not returned yet */\n for(i = 0; i < (MAX_DISP_BUFS_NEW); i++)\n {\n if(0 != ps_dec->u4_disp_buf_mapping[i])\n {\n                        display_queued = 1;\n break;\n }\n }\n /* If some buffer is queued for display, then codec has to singal an error and wait\n                 for that buffer to be returned.\n                 If nothing is queued for display then codec has ownership of all display buffers\n                 and it can reuse any of the existing buffers and continue decoding */\n\n if(1 == display_queued)\n {\n /* If something is queued for display wait for that buffer to be returned */\n                    ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;\n                    ps_dec_op->u4_error_code |= (1\n << IVD_UNSUPPORTEDPARAM);\n return (IV_FAIL);\n }\n }\n else\n {\n /* If the buffer is with display, then mark it as in use and then look for a buffer again */\n if(1 == ps_dec->u4_disp_buf_mapping[free_id])\n {\n                    ih264_buf_mgr_set_status(\n (buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n                                    free_id,\n                                    BUF_MGR_IO);\n }\n else\n {\n /**\n                     *  Found a free buffer for present call. Release it now.\n                     *  Will be again obtained later.\n                     */\n                    ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n                                          free_id,\n                                          BUF_MGR_IO);\n break;\n }\n }\n }\n\n }\n\n if(ps_dec->u1_flushfrm && ps_dec->u1_init_dec_flag)\n {\n\n        ih264d_get_next_display_field(ps_dec, ps_dec->ps_out_buffer,\n &(ps_dec->s_disp_op));\n if(0 == ps_dec->s_disp_op.u4_error_code)\n {\n            ps_dec->u4_fmt_conv_cur_row = 0;\n            ps_dec->u4_fmt_conv_num_rows = ps_dec->s_disp_frame_info.u4_y_ht;\n            ih264d_format_convert(ps_dec, &(ps_dec->s_disp_op),\n                                  ps_dec->u4_fmt_conv_cur_row,\n                                  ps_dec->u4_fmt_conv_num_rows);\n            ps_dec->u4_fmt_conv_cur_row += ps_dec->u4_fmt_conv_num_rows;\n            ps_dec->u4_output_present = 1;\n\n }\n        ih264d_release_display_field(ps_dec, &(ps_dec->s_disp_op));\n\n        ps_dec_op->u4_pic_wd = (UWORD32)ps_dec->u2_disp_width;\n        ps_dec_op->u4_pic_ht = (UWORD32)ps_dec->u2_disp_height;\n\n        ps_dec_op->u4_new_seq = 0;\n\n        ps_dec_op->u4_output_present = ps_dec->u4_output_present;\n        ps_dec_op->u4_progressive_frame_flag =\n                        ps_dec->s_disp_op.u4_progressive_frame_flag;\n        ps_dec_op->e_output_format =\n                        ps_dec->s_disp_op.e_output_format;\n        ps_dec_op->s_disp_frm_buf = ps_dec->s_disp_op.s_disp_frm_buf;\n        ps_dec_op->e4_fld_type = ps_dec->s_disp_op.e4_fld_type;\n        ps_dec_op->u4_ts = ps_dec->s_disp_op.u4_ts;\n        ps_dec_op->u4_disp_buf_id = ps_dec->s_disp_op.u4_disp_buf_id;\n\n /*In the case of flush ,since no frame is decoded set pic type as invalid*/\n        ps_dec_op->u4_is_ref_flag = -1;\n        ps_dec_op->e_pic_type = IV_NA_FRAME;\n        ps_dec_op->u4_frame_decoded_flag = 0;\n\n if(0 == ps_dec->s_disp_op.u4_error_code)\n {\n return (IV_SUCCESS);\n }\n else\n return (IV_FAIL);\n\n }\n if(ps_dec->u1_res_changed == 1)\n {\n /*if resolution has changed and all buffers have been flushed, reset decoder*/\n        ih264d_init_decoder(ps_dec);\n }\n\n    ps_dec->u4_prev_nal_skipped = 0;\n\n    ps_dec->u2_cur_mb_addr = 0;\n    ps_dec->u2_total_mbs_coded = 0;\n    ps_dec->u2_cur_slice_num = 0;\n    ps_dec->cur_dec_mb_num = 0;\n    ps_dec->cur_recon_mb_num = 0;\n    ps_dec->u4_first_slice_in_pic = 2;\n    ps_dec->u1_slice_header_done = 0;\n    ps_dec->u1_dangling_field = 0;\n\n\n     ps_dec->u4_dec_thread_created = 0;\n     ps_dec->u4_bs_deblk_thread_created = 0;\n     ps_dec->u4_cur_bs_mb_num = 0;\n \n     DEBUG_THREADS_PRINTF(\" Starting process call\\n\");\n \n\n    ps_dec->u4_pic_buf_got = 0;\n\n do\n {\n        WORD32 buf_size;\n\n        pu1_buf = (UWORD8*)ps_dec_ip->pv_stream_buffer\n + ps_dec_op->u4_num_bytes_consumed;\n\n        u4_max_ofst = ps_dec_ip->u4_num_Bytes\n - ps_dec_op->u4_num_bytes_consumed;\n\n /* If dynamic bitstream buffer is not allocated and\n         * header decode is done, then allocate dynamic bitstream buffer\n         */\n if((NULL == ps_dec->pu1_bits_buf_dynamic) &&\n (ps_dec->i4_header_decoded & 1))\n {\n            WORD32 size;\n\n void *pv_buf;\n void *pv_mem_ctxt = ps_dec->pv_mem_ctxt;\n            size = MAX(256000, ps_dec->u2_pic_wd * ps_dec->u2_pic_ht * 3 / 2);\n            pv_buf = ps_dec->pf_aligned_alloc(pv_mem_ctxt, 128, size);\n            RETURN_IF((NULL == pv_buf), IV_FAIL);\n            ps_dec->pu1_bits_buf_dynamic = pv_buf;\n            ps_dec->u4_dynamic_bits_buf_size = size;\n }\n\n if(ps_dec->pu1_bits_buf_dynamic)\n {\n            pu1_bitstrm_buf = ps_dec->pu1_bits_buf_dynamic;\n            buf_size = ps_dec->u4_dynamic_bits_buf_size;\n }\n else\n {\n            pu1_bitstrm_buf = ps_dec->pu1_bits_buf_static;\n            buf_size = ps_dec->u4_static_bits_buf_size;\n }\n\n        u4_next_is_aud = 0;\n\n        buflen = ih264d_find_start_code(pu1_buf, 0, u4_max_ofst,\n &u4_length_of_start_code,\n &u4_next_is_aud);\n\n if(buflen == -1)\n            buflen = 0;\n /* Ignore bytes beyond the allocated size of intermediate buffer */\n        buflen = MIN(buflen, buf_size);\n\n        bytes_consumed = buflen + u4_length_of_start_code;\n        ps_dec_op->u4_num_bytes_consumed += bytes_consumed;\n\n {\n            UWORD8 u1_firstbyte, u1_nal_ref_idc;\n\n if(ps_dec->i4_app_skip_mode == IVD_SKIP_B)\n {\n                u1_firstbyte = *(pu1_buf + u4_length_of_start_code);\n                u1_nal_ref_idc = (UWORD8)(NAL_REF_IDC(u1_firstbyte));\n if(u1_nal_ref_idc == 0)\n {\n /*skip non reference frames*/\n                    cur_slice_is_nonref = 1;\n continue;\n }\n else\n {\n if(1 == cur_slice_is_nonref)\n {\n /*We have encountered a referenced frame,return to app*/\n                        ps_dec_op->u4_num_bytes_consumed -=\n                                        bytes_consumed;\n                        ps_dec_op->e_pic_type = IV_B_FRAME;\n                        ps_dec_op->u4_error_code =\n                                        IVD_DEC_FRM_SKIPPED;\n                        ps_dec_op->u4_error_code |= (1\n << IVD_UNSUPPORTEDPARAM);\n                        ps_dec_op->u4_frame_decoded_flag = 0;\n                        ps_dec_op->u4_size =\n sizeof(ivd_video_decode_op_t);\n /*signal the decode thread*/\n                        ih264d_signal_decode_thread(ps_dec);\n /* close deblock thread if it is not closed yet*/\n if(ps_dec->u4_num_cores == 3)\n {\n                            ih264d_signal_bs_deblk_thread(ps_dec);\n }\n\n return (IV_FAIL);\n }\n }\n\n }\n\n }\n\n\n if(buflen)\n {\n            memcpy(pu1_bitstrm_buf, pu1_buf + u4_length_of_start_code,\n                   buflen);\n /* Decoder may read extra 8 bytes near end of the frame */\n if((buflen + 8) < buf_size)\n {\n                memset(pu1_bitstrm_buf + buflen, 0, 8);\n }\n            u4_first_start_code_found = 1;\n\n }\n else\n {\n /*start code not found*/\n\n if(u4_first_start_code_found == 0)\n {\n /*no start codes found in current process call*/\n\n                ps_dec->i4_error_code = ERROR_START_CODE_NOT_FOUND;\n                ps_dec_op->u4_error_code |= 1 << IVD_INSUFFICIENTDATA;\n\n if(ps_dec->u4_pic_buf_got == 0)\n {\n\n                    ih264d_fill_output_struct_from_context(ps_dec,\n                                                           ps_dec_op);\n\n                    ps_dec_op->u4_error_code = ps_dec->i4_error_code;\n                    ps_dec_op->u4_frame_decoded_flag = 0;\n\n return (IV_FAIL);\n }\n else\n {\n                    ps_dec->u1_pic_decode_done = 1;\n continue;\n }\n }\n else\n {\n /* a start code has already been found earlier in the same process call*/\n                frame_data_left = 0;\n continue;\n }\n\n }\n\n        ps_dec->u4_return_to_app = 0;\n        ret = ih264d_parse_nal_unit(dec_hdl, ps_dec_op,\n                              pu1_bitstrm_buf, buflen);\n if(ret != OK)\n {\n            UWORD32 error =  ih264d_map_error(ret);\n            ps_dec_op->u4_error_code = error | ret;\n            api_ret_value = IV_FAIL;\n\n if((ret == IVD_RES_CHANGED)\n || (ret == IVD_MEM_ALLOC_FAILED)\n || (ret == ERROR_UNAVAIL_PICBUF_T)\n || (ret == ERROR_UNAVAIL_MVBUF_T))\n {\n break;\n }\n\n if((ret == ERROR_INCOMPLETE_FRAME) || (ret == ERROR_DANGLING_FIELD_IN_PIC))\n {\n                ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;\n                api_ret_value = IV_FAIL;\n break;\n }\n\n if(ret == ERROR_IN_LAST_SLICE_OF_PIC)\n {\n                api_ret_value = IV_FAIL;\n break;\n }\n\n }\n\n if(ps_dec->u4_return_to_app)\n {\n /*We have encountered a referenced frame,return to app*/\n            ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;\n            ps_dec_op->u4_error_code = IVD_DEC_FRM_SKIPPED;\n            ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);\n            ps_dec_op->u4_frame_decoded_flag = 0;\n            ps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);\n /*signal the decode thread*/\n            ih264d_signal_decode_thread(ps_dec);\n /* close deblock thread if it is not closed yet*/\n if(ps_dec->u4_num_cores == 3)\n {\n                ih264d_signal_bs_deblk_thread(ps_dec);\n }\n return (IV_FAIL);\n\n }\n\n\n\n        header_data_left = ((ps_dec->i4_decode_header == 1)\n && (ps_dec->i4_header_decoded != 3)\n && (ps_dec_op->u4_num_bytes_consumed\n < ps_dec_ip->u4_num_Bytes));\n        frame_data_left = (((ps_dec->i4_decode_header == 0)\n && ((ps_dec->u1_pic_decode_done == 0)\n || (u4_next_is_aud == 1)))\n && (ps_dec_op->u4_num_bytes_consumed\n < ps_dec_ip->u4_num_Bytes));\n }\n while(( header_data_left == 1)||(frame_data_left == 1));\n\n if((ps_dec->u4_slice_start_code_found == 1)\n && (ret != IVD_MEM_ALLOC_FAILED)\n && ps_dec->u2_total_mbs_coded < ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n {\n        WORD32 num_mb_skipped;\n        WORD32 prev_slice_err;\n pocstruct_t temp_poc;\n        WORD32 ret1;\n\n        num_mb_skipped = (ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n - ps_dec->u2_total_mbs_coded;\n\n if(ps_dec->u4_first_slice_in_pic && (ps_dec->u4_pic_buf_got == 0))\n            prev_slice_err = 1;\n else\n            prev_slice_err = 2;\n\n        ret1 = ih264d_mark_err_slice_skip(ps_dec, num_mb_skipped, ps_dec->u1_nal_unit_type == IDR_SLICE_NAL, ps_dec->ps_cur_slice->u2_frame_num,\n &temp_poc, prev_slice_err);\n\n if((ret1 == ERROR_UNAVAIL_PICBUF_T) || (ret1 == ERROR_UNAVAIL_MVBUF_T))\n {\n return IV_FAIL;\n }\n }\n\n if((ret == IVD_RES_CHANGED)\n || (ret == IVD_MEM_ALLOC_FAILED)\n || (ret == ERROR_UNAVAIL_PICBUF_T)\n || (ret == ERROR_UNAVAIL_MVBUF_T))\n {\n\n /* signal the decode thread */\n        ih264d_signal_decode_thread(ps_dec);\n /* close deblock thread if it is not closed yet */\n if(ps_dec->u4_num_cores == 3)\n {\n            ih264d_signal_bs_deblk_thread(ps_dec);\n }\n /* dont consume bitstream for change in resolution case */\n if(ret == IVD_RES_CHANGED)\n {\n            ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;\n }\n return IV_FAIL;\n }\n\n\n if(ps_dec->u1_separate_parse)\n {\n /* If Format conversion is not complete,\n         complete it here */\n if(ps_dec->u4_num_cores == 2)\n {\n\n /*do deblocking of all mbs*/\n if((ps_dec->u4_nmb_deblk == 0) &&(ps_dec->u4_start_recon_deblk == 1) && (ps_dec->ps_cur_sps->u1_mb_aff_flag == 0))\n {\n                UWORD32 u4_num_mbs,u4_max_addr;\n tfr_ctxt_t s_tfr_ctxt;\n tfr_ctxt_t *ps_tfr_cxt = &s_tfr_ctxt;\n pad_mgr_t *ps_pad_mgr = &ps_dec->s_pad_mgr;\n\n /*BS is done for all mbs while parsing*/\n                u4_max_addr = (ps_dec->u2_frm_wd_in_mbs * ps_dec->u2_frm_ht_in_mbs) - 1;\n                ps_dec->u4_cur_bs_mb_num = u4_max_addr + 1;\n\n\n                ih264d_init_deblk_tfr_ctxt(ps_dec, ps_pad_mgr, ps_tfr_cxt,\n                                           ps_dec->u2_frm_wd_in_mbs, 0);\n\n\n                u4_num_mbs = u4_max_addr\n - ps_dec->u4_cur_deblk_mb_num + 1;\n\n                DEBUG_PERF_PRINTF(\"mbs left for deblocking= %d \\n\",u4_num_mbs);\n\n if(u4_num_mbs != 0)\n                    ih264d_check_mb_map_deblk(ps_dec, u4_num_mbs,\n                                                   ps_tfr_cxt,1);\n\n                ps_dec->u4_start_recon_deblk  = 0;\n\n }\n\n }\n\n /*signal the decode thread*/\n        ih264d_signal_decode_thread(ps_dec);\n /* close deblock thread if it is not closed yet*/\n if(ps_dec->u4_num_cores == 3)\n {\n            ih264d_signal_bs_deblk_thread(ps_dec);\n }\n }\n\n\n    DATA_SYNC();\n\n\n if((ps_dec_op->u4_error_code & 0xff)\n != ERROR_DYNAMIC_RESOLUTION_NOT_SUPPORTED)\n {\n        ps_dec_op->u4_pic_wd = (UWORD32)ps_dec->u2_disp_width;\n        ps_dec_op->u4_pic_ht = (UWORD32)ps_dec->u2_disp_height;\n }\n\n if(ps_dec->i4_header_decoded != 3)\n {\n        ps_dec_op->u4_error_code |= (1 << IVD_INSUFFICIENTDATA);\n\n }\n\n if(ps_dec->i4_decode_header == 1 && ps_dec->i4_header_decoded != 3)\n {\n        ps_dec_op->u4_error_code |= (1 << IVD_INSUFFICIENTDATA);\n\n }\n if(ps_dec->u4_prev_nal_skipped)\n {\n /*We have encountered a referenced frame,return to app*/\n        ps_dec_op->u4_error_code = IVD_DEC_FRM_SKIPPED;\n        ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);\n        ps_dec_op->u4_frame_decoded_flag = 0;\n        ps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);\n /* close deblock thread if it is not closed yet*/\n if(ps_dec->u4_num_cores == 3)\n {\n            ih264d_signal_bs_deblk_thread(ps_dec);\n }\n return (IV_FAIL);\n\n }\n\n if((ps_dec->u4_slice_start_code_found == 1)\n && (ERROR_DANGLING_FIELD_IN_PIC != i4_err_status))\n {\n /*\n         * For field pictures, set the bottom and top picture decoded u4_flag correctly.\n         */\n\n if(ps_dec->ps_cur_slice->u1_field_pic_flag)\n {\n if(1 == ps_dec->ps_cur_slice->u1_bottom_field_flag)\n {\n                ps_dec->u1_top_bottom_decoded |= BOT_FIELD_ONLY;\n }\n else\n {\n                ps_dec->u1_top_bottom_decoded |= TOP_FIELD_ONLY;\n }\n }\n\n /* if new frame in not found (if we are still getting slices from previous frame)\n         * ih264d_deblock_display is not called. Such frames will not be added to reference /display\n         */\n if((ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC) == 0)\n {\n /* Calling Function to deblock Picture and Display */\n            ret = ih264d_deblock_display(ps_dec);\n if(ret != 0)\n {\n return IV_FAIL;\n }\n }\n\n\n /*set to complete ,as we dont support partial frame decode*/\n if(ps_dec->i4_header_decoded == 3)\n {\n            ps_dec->u2_total_mbs_coded = ps_dec->ps_cur_sps->u2_max_mb_addr + 1;\n }\n\n /*Update the i4_frametype at the end of picture*/\n if(ps_dec->ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL)\n {\n            ps_dec->i4_frametype = IV_IDR_FRAME;\n }\n else if(ps_dec->i4_pic_type == B_SLICE)\n {\n            ps_dec->i4_frametype = IV_B_FRAME;\n }\n else if(ps_dec->i4_pic_type == P_SLICE)\n {\n            ps_dec->i4_frametype = IV_P_FRAME;\n }\n else if(ps_dec->i4_pic_type == I_SLICE)\n {\n            ps_dec->i4_frametype = IV_I_FRAME;\n }\n else\n {\n            H264_DEC_DEBUG_PRINT(\"Shouldn't come here\\n\");\n }\n\n        ps_dec->i4_content_type = ps_dec->ps_cur_slice->u1_field_pic_flag;\n\n        ps_dec->u4_total_frames_decoded = ps_dec->u4_total_frames_decoded + 2;\n        ps_dec->u4_total_frames_decoded = ps_dec->u4_total_frames_decoded\n - ps_dec->ps_cur_slice->u1_field_pic_flag;\n\n }\n\n /* close deblock thread if it is not closed yet*/\n if(ps_dec->u4_num_cores == 3)\n {\n        ih264d_signal_bs_deblk_thread(ps_dec);\n }\n\n\n {\n /* In case the decoder is configured to run in low delay mode,\n         * then get display buffer and then format convert.\n         * Note in this mode, format conversion does not run paralelly in a thread and adds to the codec cycles\n         */\n\n if((IVD_DECODE_FRAME_OUT == ps_dec->e_frm_out_mode)\n && ps_dec->u1_init_dec_flag)\n {\n\n            ih264d_get_next_display_field(ps_dec, ps_dec->ps_out_buffer,\n &(ps_dec->s_disp_op));\n if(0 == ps_dec->s_disp_op.u4_error_code)\n {\n                ps_dec->u4_fmt_conv_cur_row = 0;\n                ps_dec->u4_output_present = 1;\n }\n }\n\n        ih264d_fill_output_struct_from_context(ps_dec, ps_dec_op);\n\n /* If Format conversion is not complete,\n         complete it here */\n if(ps_dec->u4_output_present &&\n (ps_dec->u4_fmt_conv_cur_row < ps_dec->s_disp_frame_info.u4_y_ht))\n {\n            ps_dec->u4_fmt_conv_num_rows = ps_dec->s_disp_frame_info.u4_y_ht\n - ps_dec->u4_fmt_conv_cur_row;\n            ih264d_format_convert(ps_dec, &(ps_dec->s_disp_op),\n                                  ps_dec->u4_fmt_conv_cur_row,\n                                  ps_dec->u4_fmt_conv_num_rows);\n            ps_dec->u4_fmt_conv_cur_row += ps_dec->u4_fmt_conv_num_rows;\n }\n\n        ih264d_release_display_field(ps_dec, &(ps_dec->s_disp_op));\n }\n\n if(ps_dec->i4_decode_header == 1 && (ps_dec->i4_header_decoded & 1) == 1)\n {\n        ps_dec_op->u4_progressive_frame_flag = 1;\n if((NULL != ps_dec->ps_cur_sps) && (1 == (ps_dec->ps_cur_sps->u1_is_valid)))\n {\n if((0 == ps_dec->ps_sps->u1_frame_mbs_only_flag)\n && (0 == ps_dec->ps_sps->u1_mb_aff_flag))\n                ps_dec_op->u4_progressive_frame_flag = 0;\n\n }\n }\n\n /*Data memory barrier instruction,so that yuv write by the library is complete*/\n    DATA_SYNC();\n\n    H264_DEC_DEBUG_PRINT(\"The num bytes consumed: %d\\n\",\n                         ps_dec_op->u4_num_bytes_consumed);\n return api_ret_value;\n}\n", "target": 1, "idx": 187563}
{"func": "static void ssl_write_encrypt_then_mac_ext( mbedtls_ssl_context *ssl,\n                                            unsigned char *buf,\n                                            size_t *olen )\n{\n    unsigned char *p = buf;\n    const mbedtls_ssl_ciphersuite_t *suite = NULL;\n    const mbedtls_cipher_info_t *cipher = NULL;\n\n    if( ssl->session_negotiate->encrypt_then_mac == MBEDTLS_SSL_EXTENDED_MS_DISABLED ||\n        ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )\n    {\n        *olen = 0;\n        return;\n    }\n\n    /*\n     * RFC 7366: \"If a server receives an encrypt-then-MAC request extension\n     * from a client and then selects a stream or Authenticated Encryption\n     * with Associated Data (AEAD) ciphersuite, it MUST NOT send an\n     * encrypt-then-MAC response extension back to the client.\"\n     */\n    if( ( suite = mbedtls_ssl_ciphersuite_from_id(\n                    ssl->session_negotiate->ciphersuite ) ) == NULL ||\n        ( cipher = mbedtls_cipher_info_from_type( suite->cipher ) ) == NULL ||\n        cipher->mode != MBEDTLS_MODE_CBC )\n    {\n        *olen = 0;\n        return;\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"server hello, adding encrypt then mac extension\" ) );\n\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_ENCRYPT_THEN_MAC >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_ENCRYPT_THEN_MAC      ) & 0xFF );\n\n    *p++ = 0x00;\n    *p++ = 0x00;\n\n    *olen = 4;\n}\n", "target": 0, "idx": 86143}
{"func": " bool AudioHandler::VerifyMixerConnection() {\n  PulseAudioMixer::State mixer_state = mixer_->CheckState();\n  if (mixer_state == PulseAudioMixer::READY)\n     return true;\n   if (connected_) {\n     connected_ = false;\n    LOG(ERROR) << \"Lost connection to PulseAudio\";\n   } else {\n     LOG(ERROR) << \"Mixer not valid\";\n   }\n \n  if ((mixer_state == PulseAudioMixer::INITIALIZING) ||\n      (mixer_state == PulseAudioMixer::SHUTTING_DOWN))\n     return false;\n \n   if (reconnect_tries_ < kMaxReconnectTries) {\n     reconnect_tries_++;\n    VLOG(1) << \"Re-connecting to PulseAudio attempt \" << reconnect_tries_ << \"/\"\n             << kMaxReconnectTries;\n    mixer_.reset(new PulseAudioMixer());\n    connected_ = mixer_->InitSync();\n     if (connected_) {\n       reconnect_tries_ = 0;\n       return true;\n     }\n    LOG(ERROR) << \"Unable to re-connect to PulseAudio\";\n   }\n   return false;\n }\n", "target": 1, "idx": 184145}
{"func": "static int skt_write(int fd, const void *p, size_t len)\n{\n int sent;\n struct pollfd pfd;\n\n    FNLOG();\n\n    pfd.fd = fd;\n    pfd.events = POLLOUT;\n\n\n     /* poll for 500 ms */\n \n     /* send time out */\n    if (poll(&pfd, 1, 500) == 0)\n         return 0;\n \n     ts_log(\"skt_write\", len, NULL);\n \n    if ((sent = send(fd, p, len, MSG_NOSIGNAL)) == -1)\n     {\n         ERROR(\"write failed with errno=%d\\n\", errno);\n         return -1;\n }\n\n return sent;\n}\n", "target": 1, "idx": 187451}
{"func": "static int ccid3_hc_rx_init(struct ccid *ccid, struct sock *sk)\n{\n\tstruct ccid3_hc_rx_sock *hc = ccid_priv(ccid);\n\n\thc->rx_state = TFRC_RSTATE_NO_DATA;\n\ttfrc_lh_init(&hc->rx_li_hist);\n\treturn tfrc_rx_hist_alloc(&hc->rx_hist);\n}\n", "target": 0, "idx": 34150}
{"func": "UserCloudPolicyManagerChromeOS::UserCloudPolicyManagerChromeOS(\n    scoped_ptr<CloudPolicyStore> store,\n    scoped_ptr<CloudExternalDataManager> external_data_manager,\n    const base::FilePath& component_policy_cache_path,\n    bool wait_for_policy_fetch,\n    base::TimeDelta initial_policy_fetch_timeout,\n    const scoped_refptr<base::SequencedTaskRunner>& task_runner,\n    const scoped_refptr<base::SequencedTaskRunner>& file_task_runner,\n    const scoped_refptr<base::SequencedTaskRunner>& io_task_runner)\n    : CloudPolicyManager(\n          PolicyNamespaceKey(dm_protocol::kChromeUserPolicyType, std::string()),\n          store.get(),\n          task_runner,\n          file_task_runner,\n          io_task_runner),\n      store_(store.Pass()),\n      external_data_manager_(external_data_manager.Pass()),\n      component_policy_cache_path_(component_policy_cache_path),\n       wait_for_policy_fetch_(wait_for_policy_fetch),\n       policy_fetch_timeout_(false, false) {\n   time_init_started_ = base::Time::Now();\n  if (wait_for_policy_fetch_) {\n     policy_fetch_timeout_.Start(\n         FROM_HERE,\n         initial_policy_fetch_timeout,\n        base::Bind(&UserCloudPolicyManagerChromeOS::OnBlockingFetchTimeout,\n                   base::Unretained(this)));\n  }\n}\n", "target": 1, "idx": 184841}
{"func": "static int decode_nal_unit(HEVCContext *s, const H2645NAL *nal)\n{\n    HEVCLocalContext *lc = s->HEVClc;\n    GetBitContext *gb    = &lc->gb;\n    int ctb_addr_ts, ret;\n\n    *gb              = nal->gb;\n    s->nal_unit_type = nal->type;\n    s->temporal_id   = nal->temporal_id;\n\n    switch (s->nal_unit_type) {\n    case HEVC_NAL_VPS:\n        if (s->avctx->hwaccel && s->avctx->hwaccel->decode_params) {\n            ret = s->avctx->hwaccel->decode_params(s->avctx,\n                                                   nal->type,\n                                                   nal->raw_data,\n                                                   nal->raw_size);\n            if (ret < 0)\n                goto fail;\n        }\n        ret = ff_hevc_decode_nal_vps(gb, s->avctx, &s->ps);\n        if (ret < 0)\n            goto fail;\n        break;\n    case HEVC_NAL_SPS:\n        if (s->avctx->hwaccel && s->avctx->hwaccel->decode_params) {\n            ret = s->avctx->hwaccel->decode_params(s->avctx,\n                                                   nal->type,\n                                                   nal->raw_data,\n                                                   nal->raw_size);\n            if (ret < 0)\n                goto fail;\n        }\n        ret = ff_hevc_decode_nal_sps(gb, s->avctx, &s->ps,\n                                     s->apply_defdispwin);\n        if (ret < 0)\n            goto fail;\n        break;\n    case HEVC_NAL_PPS:\n        if (s->avctx->hwaccel && s->avctx->hwaccel->decode_params) {\n            ret = s->avctx->hwaccel->decode_params(s->avctx,\n                                                   nal->type,\n                                                   nal->raw_data,\n                                                   nal->raw_size);\n            if (ret < 0)\n                goto fail;\n        }\n        ret = ff_hevc_decode_nal_pps(gb, s->avctx, &s->ps);\n        if (ret < 0)\n            goto fail;\n        break;\n    case HEVC_NAL_SEI_PREFIX:\n    case HEVC_NAL_SEI_SUFFIX:\n        if (s->avctx->hwaccel && s->avctx->hwaccel->decode_params) {\n            ret = s->avctx->hwaccel->decode_params(s->avctx,\n                                                   nal->type,\n                                                   nal->raw_data,\n                                                   nal->raw_size);\n            if (ret < 0)\n                goto fail;\n        }\n        ret = ff_hevc_decode_nal_sei(gb, s->avctx, &s->sei, &s->ps, s->nal_unit_type);\n        if (ret < 0)\n            goto fail;\n        break;\n    case HEVC_NAL_TRAIL_R:\n    case HEVC_NAL_TRAIL_N:\n    case HEVC_NAL_TSA_N:\n    case HEVC_NAL_TSA_R:\n    case HEVC_NAL_STSA_N:\n    case HEVC_NAL_STSA_R:\n    case HEVC_NAL_BLA_W_LP:\n    case HEVC_NAL_BLA_W_RADL:\n    case HEVC_NAL_BLA_N_LP:\n    case HEVC_NAL_IDR_W_RADL:\n    case HEVC_NAL_IDR_N_LP:\n    case HEVC_NAL_CRA_NUT:\n    case HEVC_NAL_RADL_N:\n    case HEVC_NAL_RADL_R:\n    case HEVC_NAL_RASL_N:\n    case HEVC_NAL_RASL_R:\n         ret = hls_slice_header(s);\n         if (ret < 0)\n             return ret;\n \n         if (\n             (s->avctx->skip_frame >= AVDISCARD_BIDIR && s->sh.slice_type == HEVC_SLICE_B) ||\n            (s->avctx->skip_frame >= AVDISCARD_NONINTRA && s->sh.slice_type != HEVC_SLICE_I) ||\n            (s->avctx->skip_frame >= AVDISCARD_NONKEY && !IS_IRAP(s))) {\n            break;\n         }\n \n         if (s->sh.first_slice_in_pic_flag) {\n            if (s->ref) {\n                av_log(s->avctx, AV_LOG_ERROR, \"Two slices reporting being the first in the same frame.\\n\");\n                goto fail;\n            }\n             if (s->max_ra == INT_MAX) {\n                 if (s->nal_unit_type == HEVC_NAL_CRA_NUT || IS_BLA(s)) {\n                     s->max_ra = s->poc;\n                } else {\n                    if (IS_IDR(s))\n                        s->max_ra = INT_MIN;\n                }\n            }\n\n            if ((s->nal_unit_type == HEVC_NAL_RASL_R || s->nal_unit_type == HEVC_NAL_RASL_N) &&\n                s->poc <= s->max_ra) {\n                s->is_decoded = 0;\n                break;\n            } else {\n                if (s->nal_unit_type == HEVC_NAL_RASL_R && s->poc > s->max_ra)\n                    s->max_ra = INT_MIN;\n            }\n\n            s->overlap ++;\n            ret = hevc_frame_start(s);\n            if (ret < 0)\n                return ret;\n        } else if (!s->ref) {\n            av_log(s->avctx, AV_LOG_ERROR, \"First slice in a frame missing.\\n\");\n            goto fail;\n        }\n\n        if (s->nal_unit_type != s->first_nal_type) {\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \"Non-matching NAL types of the VCL NALUs: %d %d\\n\",\n                   s->first_nal_type, s->nal_unit_type);\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (!s->sh.dependent_slice_segment_flag &&\n            s->sh.slice_type != HEVC_SLICE_I) {\n            ret = ff_hevc_slice_rpl(s);\n            if (ret < 0) {\n                av_log(s->avctx, AV_LOG_WARNING,\n                       \"Error constructing the reference lists for the current slice.\\n\");\n                goto fail;\n            }\n        }\n\n        if (s->sh.first_slice_in_pic_flag && s->avctx->hwaccel) {\n            ret = s->avctx->hwaccel->start_frame(s->avctx, NULL, 0);\n            if (ret < 0)\n                goto fail;\n        }\n\n        if (s->avctx->hwaccel) {\n            ret = s->avctx->hwaccel->decode_slice(s->avctx, nal->raw_data, nal->raw_size);\n            if (ret < 0)\n                goto fail;\n        } else {\n            if (s->threads_number > 1 && s->sh.num_entry_point_offsets > 0)\n                ctb_addr_ts = hls_slice_data_wpp(s, nal);\n            else\n                ctb_addr_ts = hls_slice_data(s);\n            if (ctb_addr_ts >= (s->ps.sps->ctb_width * s->ps.sps->ctb_height)) {\n                s->is_decoded = 1;\n            }\n\n            if (ctb_addr_ts < 0) {\n                ret = ctb_addr_ts;\n                goto fail;\n            }\n        }\n        break;\n    case HEVC_NAL_EOS_NUT:\n    case HEVC_NAL_EOB_NUT:\n        s->seq_decode = (s->seq_decode + 1) & 0xff;\n        s->max_ra     = INT_MAX;\n        break;\n    case HEVC_NAL_AUD:\n    case HEVC_NAL_FD_NUT:\n        break;\n    default:\n        av_log(s->avctx, AV_LOG_INFO,\n               \"Skipping NAL unit %d\\n\", s->nal_unit_type);\n    }\n\n    return 0;\nfail:\n    if (s->avctx->err_recognition & AV_EF_EXPLODE)\n        return ret;\n    return 0;\n}\n", "target": 1, "idx": 182878}
{"func": "MagickExport Image *CloneImage(const Image *image,const size_t columns,\n  const size_t rows,const MagickBooleanType detach,ExceptionInfo *exception)\n{\n  double\n    scale;\n\n  Image\n    *clone_image;\n\n  size_t\n    length;\n\n  /*\n    Clone the image.\n  */\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  if ((image->columns == 0) || (image->rows == 0))\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,\n        \"NegativeOrZeroImageSize\",\"`%s'\",image->filename);\n      return((Image *) NULL);\n    }\n  clone_image=(Image *) AcquireMagickMemory(sizeof(*clone_image));\n  if (clone_image == (Image *) NULL)\n    ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(clone_image,0,sizeof(*clone_image));\n  clone_image->signature=MagickSignature;\n  clone_image->storage_class=image->storage_class;\n  clone_image->channels=image->channels;\n  clone_image->colorspace=image->colorspace;\n  clone_image->matte=image->matte;\n  clone_image->columns=image->columns;\n  clone_image->rows=image->rows;\n  clone_image->dither=image->dither;\n  if (image->colormap != (PixelPacket *) NULL)\n    {\n      /*\n        Allocate and copy the image colormap.\n      */\n      clone_image->colors=image->colors;\n      length=(size_t) image->colors;\n      clone_image->colormap=(PixelPacket *) AcquireQuantumMemory(length,\n         sizeof(*clone_image->colormap));\n       if (clone_image->colormap == (PixelPacket *) NULL)\n         {\n          clone_image=DestroyImage(clone_image);\n           ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\");\n         }\n       (void) CopyMagickMemory(clone_image->colormap,image->colormap,length*\n        sizeof(*clone_image->colormap));\n    }\n  (void) CloneImageProfiles(clone_image,image);\n  (void) CloneImageProperties(clone_image,image);\n  (void) CloneImageArtifacts(clone_image,image);\n  GetTimerInfo(&clone_image->timer);\n  InitializeExceptionInfo(&clone_image->exception);\n  InheritException(&clone_image->exception,&image->exception);\n  if (image->ascii85 != (void *) NULL)\n    Ascii85Initialize(clone_image);\n  clone_image->magick_columns=image->magick_columns;\n  clone_image->magick_rows=image->magick_rows;\n  clone_image->type=image->type;\n  (void) CopyMagickString(clone_image->magick_filename,image->magick_filename,\n    MaxTextExtent);\n  (void) CopyMagickString(clone_image->magick,image->magick,MaxTextExtent);\n  (void) CopyMagickString(clone_image->filename,image->filename,MaxTextExtent);\n  clone_image->progress_monitor=image->progress_monitor;\n  clone_image->client_data=image->client_data;\n  clone_image->reference_count=1;\n  clone_image->next=image->next;\n  clone_image->previous=image->previous;\n  clone_image->list=NewImageList();\n  clone_image->clip_mask=NewImageList();\n  clone_image->mask=NewImageList();\n  if (detach == MagickFalse)\n    clone_image->blob=ReferenceBlob(image->blob);\n  else\n    {\n      clone_image->next=NewImageList();\n      clone_image->previous=NewImageList();\n      clone_image->blob=CloneBlobInfo((BlobInfo *) NULL);\n    }\n  clone_image->ping=image->ping;\n  clone_image->debug=IsEventLogging();\n  clone_image->semaphore=AllocateSemaphoreInfo();\n  if ((columns == 0) || (rows == 0))\n    {\n      if (image->montage != (char *) NULL)\n        (void) CloneString(&clone_image->montage,image->montage);\n      if (image->directory != (char *) NULL)\n        (void) CloneString(&clone_image->directory,image->directory);\n      if (image->clip_mask != (Image *) NULL)\n        clone_image->clip_mask=CloneImage(image->clip_mask,0,0,MagickTrue,\n          exception);\n      if (image->mask != (Image *) NULL)\n        clone_image->mask=CloneImage(image->mask,0,0,MagickTrue,exception);\n      clone_image->cache=ReferencePixelCache(image->cache);\n      return(clone_image);\n    }\n  if ((columns == image->columns) && (rows == image->rows))\n    {\n      if (image->clip_mask != (Image *) NULL)\n        clone_image->clip_mask=CloneImage(image->clip_mask,0,0,MagickTrue,\n          exception);\n      if (image->mask != (Image *) NULL)\n        clone_image->mask=CloneImage(image->mask,0,0,MagickTrue,exception);\n    }\n  scale=1.0;\n  if (image->columns != 0)\n    scale=(double) columns/(double) image->columns;\n  clone_image->page.width=(size_t) floor(scale*image->page.width+0.5);\n  clone_image->page.x=(ssize_t) ceil(scale*image->page.x-0.5);\n  clone_image->tile_offset.x=(ssize_t) ceil(scale*image->tile_offset.x-0.5);\n  scale=1.0;\n  if (image->rows != 0)\n    scale=(double) rows/(double) image->rows;\n  clone_image->page.height=(size_t) floor(scale*image->page.height+0.5);\n  clone_image->page.y=(ssize_t) ceil(scale*image->page.y-0.5);\n  clone_image->tile_offset.y=(ssize_t) ceil(scale*image->tile_offset.y-0.5);\n  clone_image->cache=ClonePixelCache(image->cache);\n  if (SetImageExtent(clone_image,columns,rows) == MagickFalse)\n    {\n      InheritException(exception,&clone_image->exception);\n      clone_image=DestroyImage(clone_image);\n    }\n  return(clone_image);\n}\n", "target": 1, "idx": 181268}
{"func": "static ssize_t sched_mc_power_savings_show(struct sysdev_class *class,\n\t\t\t\t\t   struct sysdev_class_attribute *attr,\n\t\t\t\t\t   char *page)\n{\n\treturn sprintf(page, \"%u\\n\", sched_mc_power_savings);\n}\n", "target": 0, "idx": 22559}
{"func": "xps_parse_arc_segment(fz_context *doc, fz_path *path, fz_xml *root, int stroking, int *skipped_stroke)\n{\n\t/* ArcSegment pretty much follows the SVG algorithm for converting an\n\t * arc in endpoint representation to an arc in centerpoint\n\t * representation. Once in centerpoint it can be given to the\n\t * graphics library in the form of a postscript arc. */\n\n\tfloat rotation_angle;\n\tint is_large_arc, is_clockwise;\n\tfloat point_x, point_y;\n\tfloat size_x, size_y;\n\tint is_stroked;\n\n\tchar *point_att = fz_xml_att(root, \"Point\");\n\tchar *size_att = fz_xml_att(root, \"Size\");\n\tchar *rotation_angle_att = fz_xml_att(root, \"RotationAngle\");\n\tchar *is_large_arc_att = fz_xml_att(root, \"IsLargeArc\");\n\tchar *sweep_direction_att = fz_xml_att(root, \"SweepDirection\");\n\tchar *is_stroked_att = fz_xml_att(root, \"IsStroked\");\n\n\tif (!point_att || !size_att || !rotation_angle_att || !is_large_arc_att || !sweep_direction_att)\n\t{\n\t\tfz_warn(doc, \"ArcSegment element is missing attributes\");\n\t\treturn;\n\t}\n\n\tis_stroked = 1;\n\tif (is_stroked_att && !strcmp(is_stroked_att, \"false\"))\n\t\t\tis_stroked = 0;\n\tif (!is_stroked)\n\t\t*skipped_stroke = 1;\n\n\tpoint_x = point_y = 0;\n\tsize_x = size_y = 0;\n\n\txps_parse_point(point_att, &point_x, &point_y);\n\txps_parse_point(size_att, &size_x, &size_y);\n\trotation_angle = fz_atof(rotation_angle_att);\n\tis_large_arc = !strcmp(is_large_arc_att, \"true\");\n\tis_clockwise = !strcmp(sweep_direction_att, \"Clockwise\");\n\n\tif (stroking && !is_stroked)\n\t{\n\t\tfz_moveto(doc, path, point_x, point_y);\n\t\treturn;\n\t}\n\n\txps_draw_arc(doc, path, size_x, size_y, rotation_angle, is_large_arc, is_clockwise, point_x, point_y);\n}\n", "target": 0, "idx": 13186}
{"func": "static int pagemap_pmd_range(pmd_t *pmdp, unsigned long addr, unsigned long end,\n\t\t\t     struct mm_walk *walk)\n{\n\tstruct vm_area_struct *vma = walk->vma;\n\tstruct pagemapread *pm = walk->private;\n\tspinlock_t *ptl;\n\tpte_t *pte, *orig_pte;\n\tint err = 0;\n\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tptl = pmd_trans_huge_lock(pmdp, vma);\n\tif (ptl) {\n\t\tu64 flags = 0, frame = 0;\n\t\tpmd_t pmd = *pmdp;\n\t\tstruct page *page = NULL;\n\n\t\tif (vma->vm_flags & VM_SOFTDIRTY)\n\t\t\tflags |= PM_SOFT_DIRTY;\n\n\t\tif (pmd_present(pmd)) {\n\t\t\tpage = pmd_page(pmd);\n\n\t\t\tflags |= PM_PRESENT;\n\t\t\tif (pmd_soft_dirty(pmd))\n\t\t\t\tflags |= PM_SOFT_DIRTY;\n\t\t\tif (pm->show_pfn)\n\t\t\t\tframe = pmd_pfn(pmd) +\n\t\t\t\t\t((addr & ~PMD_MASK) >> PAGE_SHIFT);\n\t\t}\n#ifdef CONFIG_ARCH_ENABLE_THP_MIGRATION\n\t\telse if (is_swap_pmd(pmd)) {\n\t\t\tswp_entry_t entry = pmd_to_swp_entry(pmd);\n\t\t\tunsigned long offset;\n\n\t\t\tif (pm->show_pfn) {\n\t\t\t\toffset = swp_offset(entry) +\n\t\t\t\t\t((addr & ~PMD_MASK) >> PAGE_SHIFT);\n\t\t\t\tframe = swp_type(entry) |\n\t\t\t\t\t(offset << MAX_SWAPFILES_SHIFT);\n\t\t\t}\n\t\t\tflags |= PM_SWAP;\n\t\t\tif (pmd_swp_soft_dirty(pmd))\n\t\t\t\tflags |= PM_SOFT_DIRTY;\n\t\t\tVM_BUG_ON(!is_pmd_migration_entry(pmd));\n\t\t\tpage = migration_entry_to_page(entry);\n\t\t}\n#endif\n\n\t\tif (page && page_mapcount(page) == 1)\n\t\t\tflags |= PM_MMAP_EXCLUSIVE;\n\n\t\tfor (; addr != end; addr += PAGE_SIZE) {\n\t\t\tpagemap_entry_t pme = make_pme(frame, flags);\n\n\t\t\terr = add_to_pagemap(addr, &pme, pm);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (pm->show_pfn) {\n\t\t\t\tif (flags & PM_PRESENT)\n\t\t\t\t\tframe++;\n\t\t\t\telse if (flags & PM_SWAP)\n\t\t\t\t\tframe += (1 << MAX_SWAPFILES_SHIFT);\n\t\t\t}\n\t\t}\n\t\tspin_unlock(ptl);\n\t\treturn err;\n\t}\n\n\tif (pmd_trans_unstable(pmdp))\n\t\treturn 0;\n#endif /* CONFIG_TRANSPARENT_HUGEPAGE */\n\n\t/*\n\t * We can assume that @vma always points to a valid one and @end never\n\t * goes beyond vma->vm_end.\n\t */\n\torig_pte = pte = pte_offset_map_lock(walk->mm, pmdp, addr, &ptl);\n\tfor (; addr < end; pte++, addr += PAGE_SIZE) {\n\t\tpagemap_entry_t pme;\n\n\t\tpme = pte_to_pagemap_entry(pm, vma, addr, *pte);\n\t\terr = add_to_pagemap(addr, &pme, pm);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\tpte_unmap_unlock(orig_pte, ptl);\n\n\tcond_resched();\n\n\treturn err;\n}\n", "target": 0, "idx": 90493}
{"func": " void WebPluginDelegateImpl::SendJavaScriptStream(const GURL& url,\n                                                  const std::string& result,\n                                                  bool success,\n                                                 bool notify_needed,\n                                                 intptr_t notify_data) {\n  instance()->SendJavaScriptStream(url, result, success, notify_needed,\n                                   notify_data);\n }\n", "target": 1, "idx": 183595}
{"func": "static void kvm_unpin_pages(struct kvm *kvm, pfn_t pfn, unsigned long npages)\n{\n\tunsigned long i;\n\tfor (i = 0; i < npages; ++i)\n\t\tkvm_release_pfn_clean(pfn + i);\n}\n", "target": 1, "idx": 179524}
{"func": "static inline bool use_goto_tb(DisasContext *s, target_ulong pc)\n{\n#ifndef CONFIG_USER_ONLY\n    return (pc & TARGET_PAGE_MASK) == (s->tb->pc & TARGET_PAGE_MASK) ||\n           (pc & TARGET_PAGE_MASK) == (s->pc_start & TARGET_PAGE_MASK);\n#else\n    return true;\n#endif\n}\n", "target": 0, "idx": 66432}
{"func": "bool HpackDecoder::DecodeNextIndexedHeader(HpackInputStream* input_stream) {\n  uint32 index = 0;\n  if (!input_stream->DecodeNextUint32(&index))\n    return false;\n\n  HpackEntry* entry = header_table_.GetByIndex(index);\n   if (entry == NULL)\n     return false;\n \n  HandleHeaderRepresentation(entry->name(), entry->value());\n  return true;\n }\n", "target": 1, "idx": 185533}
{"func": "hcom_client_init\n(\n\t\tOUT\tp_hsm_com_client_hdl_t\t*p_hdl,\n\tIN\t\tchar\t\t\t\t\t*server_path,\n\tIN\t\tchar\t\t\t\t\t*client_path,\n\tIN\t\tint\t\t\t\t\t\tmax_data_len\n)\n{\n\thsm_com_client_hdl_t\t*hdl = NULL;\n\thsm_com_errno_t\t\t\tres = HSM_COM_OK;\n\t\n\n\tif((strlen(server_path) > (HSM_COM_SVR_MAX_PATH - 1)) ||\n\t   (strlen(server_path) == 0)){\n\t\tres = HSM_COM_PATH_ERR;\n\t\tgoto cleanup;\n\t}\n\n\tif((strlen(client_path) > (HSM_COM_SVR_MAX_PATH - 1)) ||\n\t   (strlen(client_path) == 0)){\n\t\tres = HSM_COM_PATH_ERR;\n\t\tgoto cleanup;\n\t}\n\n\n\tif((hdl = calloc(1,sizeof(hsm_com_client_hdl_t))) == NULL)\n\t{\n\t\tres = HSM_COM_NO_MEM;\n\t\tgoto cleanup;\n\t}\n\n\tif((hdl->scr.scratch = malloc(max_data_len)) == NULL) \n\t{\n\t\tres = HSM_COM_NO_MEM;\n\t\tgoto cleanup;\n\t}\n\n\tif((hdl->recv_buf = malloc(max_data_len)) == NULL) \n\t{\n\t\tres = HSM_COM_NO_MEM;\n\t\tgoto cleanup;\n\t}\n\n\tif((hdl->send_buf = malloc(max_data_len)) == NULL) \n\t{\n\t\tres = HSM_COM_NO_MEM;\n\t\tgoto cleanup;\n\t}\n\n\thdl->scr.scratch_fill = 0;\n\thdl->scr.scratch_len = max_data_len;\n\thdl->buf_len = max_data_len;\n\thdl->trans_id = 1;\n\n\n \tstrcpy(hdl->s_path,server_path);\n \tstrcpy(hdl->c_path,client_path);\n \n \n \thdl->client_state = HSM_COM_C_STATE_IN;\n \n\t*p_hdl = hdl;\n\n\treturn res;\n\ncleanup:\n\tif(hdl)\n\t{\n\t\tif (hdl->scr.scratch) {\n\t\t\tfree(hdl->scr.scratch);\n\t\t}\n\t\tif (hdl->recv_buf) {\n\t\t\tfree(hdl->recv_buf);\n\t\t}\n\t\tfree(hdl);\n\t}\n\n\treturn res;\n\n}\n", "target": 1, "idx": 183301}
{"func": "blink::ParsedFeaturePolicy CreateFPHeaderMatchesAll(\n    blink::mojom::FeaturePolicyFeature feature) {\n  blink::ParsedFeaturePolicy result(1);\n  result[0].feature = feature;\n  result[0].matches_all_origins = true;\n  return result;\n}\n", "target": 0, "idx": 156647}
{"func": "void ClientControlledShellSurface::OnBoundsChangeEvent(\n    ash::WindowStateType current_state,\n    ash::WindowStateType requested_state,\n     int64_t display_id,\n     const gfx::Rect& window_bounds,\n     int bounds_change) {\n  if (!geometry().IsEmpty() && !window_bounds.IsEmpty() &&\n      (!widget_->IsMinimized() ||\n       requested_state != ash::WindowStateType::kMinimized) &&\n      bounds_changed_callback_) {\n    ash::NonClientFrameViewAsh* frame_view = GetFrameView();\n\n    const bool becoming_snapped =\n        requested_state == ash::WindowStateType::kLeftSnapped ||\n        requested_state == ash::WindowStateType::kRightSnapped;\n    const bool is_tablet_mode =\n        WMHelper::GetInstance()->IsTabletModeWindowManagerEnabled();\n    gfx::Rect client_bounds =\n        becoming_snapped && is_tablet_mode\n            ? window_bounds\n            : frame_view->GetClientBoundsForWindowBounds(window_bounds);\n    gfx::Size current_size = frame_view->GetBoundsForClientView().size();\n    bool is_resize = client_bounds.size() != current_size &&\n                     !widget_->IsMaximized() && !widget_->IsFullscreen();\n\n    bounds_changed_callback_.Run(current_state, requested_state, display_id,\n                                 client_bounds, is_resize, bounds_change);\n\n    auto* window_state = GetWindowState();\n    if (server_reparent_window_ &&\n        window_state->GetDisplay().id() != display_id) {\n      ScopedSetBoundsLocally scoped_set_bounds(this);\n      int container_id = window_state->window()->parent()->id();\n      aura::Window* new_parent =\n          ash::Shell::GetRootWindowControllerWithDisplayId(display_id)\n              ->GetContainer(container_id);\n      new_parent->AddChild(window_state->window());\n    }\n  }\n}\n", "target": 1, "idx": 186376}
{"func": "xmlStringLenDecodeEntities(xmlParserCtxtPtr ctxt, const xmlChar *str, int len,\n\t\t      int what, xmlChar end, xmlChar  end2, xmlChar end3) {\n    xmlChar *buffer = NULL;\n    int buffer_size = 0;\n\n    xmlChar *current = NULL;\n    xmlChar *rep = NULL;\n    const xmlChar *last;\n    xmlEntityPtr ent;\n    int c,l;\n    int nbchars = 0;\n\n    if ((ctxt == NULL) || (str == NULL) || (len < 0))\n\treturn(NULL);\n    last = str + len;\n\n    if (((ctxt->depth > 40) &&\n         ((ctxt->options & XML_PARSE_HUGE) == 0)) ||\n\t(ctxt->depth > 1024)) {\n\txmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);\n\treturn(NULL);\n    }\n\n    /*\n     * allocate a translation buffer.\n     */\n    buffer_size = XML_PARSER_BIG_BUFFER_SIZE;\n    buffer = (xmlChar *) xmlMallocAtomic(buffer_size * sizeof(xmlChar));\n    if (buffer == NULL) goto mem_error;\n\n    /*\n     * OK loop until we reach one of the ending char or a size limit.\n     * we are operating on already parsed values.\n     */\n    if (str < last)\n\tc = CUR_SCHAR(str, l);\n    else\n        c = 0;\n    while ((c != 0) && (c != end) && /* non input consuming loop */\n\t   (c != end2) && (c != end3)) {\n\n\tif (c == 0) break;\n        if ((c == '&') && (str[1] == '#')) {\n\t    int val = xmlParseStringCharRef(ctxt, &str);\n\t    if (val != 0) {\n\t\tCOPY_BUF(0,buffer,nbchars,val);\n\t    }\n\t    if (nbchars > buffer_size - XML_PARSER_BUFFER_SIZE) {\n\t        growBuffer(buffer, XML_PARSER_BUFFER_SIZE);\n\t    }\n\t} else if ((c == '&') && (what & XML_SUBSTITUTE_REF)) {\n\t    if (xmlParserDebugEntities)\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"String decoding Entity Reference: %.30s\\n\",\n\t\t\tstr);\n\t    ent = xmlParseStringEntityRef(ctxt, &str);\n\t    if ((ctxt->lastError.code == XML_ERR_ENTITY_LOOP) ||\n\t        (ctxt->lastError.code == XML_ERR_INTERNAL_ERROR))\n\t        goto int_error;\n\t    if (ent != NULL)\n\t        ctxt->nbentities += ent->checked;\n\t    if ((ent != NULL) &&\n\t\t(ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n\t\tif (ent->content != NULL) {\n\t\t    COPY_BUF(0,buffer,nbchars,ent->content[0]);\n\t\t    if (nbchars > buffer_size - XML_PARSER_BUFFER_SIZE) {\n\t\t\tgrowBuffer(buffer, XML_PARSER_BUFFER_SIZE);\n\t\t    }\n\t\t} else {\n\t\t    xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR,\n\t\t\t    \"predefined entity has no content\\n\");\n\t\t}\n\t    } else if ((ent != NULL) && (ent->content != NULL)) {\n\t\tctxt->depth++;\n\t\trep = xmlStringDecodeEntities(ctxt, ent->content, what,\n\t\t\t                      0, 0, 0);\n\t\tctxt->depth--;\n\n\t\tif (rep != NULL) {\n\t\t    current = rep;\n\t\t    while (*current != 0) { /* non input consuming loop */\n\t\t\tbuffer[nbchars++] = *current++;\n\t\t\tif (nbchars >\n\t\t            buffer_size - XML_PARSER_BUFFER_SIZE) {\n\t\t\t    if (xmlParserEntityCheck(ctxt, nbchars, ent))\n\t\t\t\tgoto int_error;\n\t\t\t    growBuffer(buffer, XML_PARSER_BUFFER_SIZE);\n\t\t\t}\n\t\t    }\n\t\t    xmlFree(rep);\n\t\t    rep = NULL;\n\t\t}\n\t    } else if (ent != NULL) {\n\t\tint i = xmlStrlen(ent->name);\n\t\tconst xmlChar *cur = ent->name;\n \n \t\tbuffer[nbchars++] = '&';\n \t\tif (nbchars > buffer_size - i - XML_PARSER_BUFFER_SIZE) {\n\t\t    growBuffer(buffer, XML_PARSER_BUFFER_SIZE);\n \t\t}\n \t\tfor (;i > 0;i--)\n \t\t    buffer[nbchars++] = *cur++;\n\t\tbuffer[nbchars++] = ';';\n\t    }\n\t} else if (c == '%' && (what & XML_SUBSTITUTE_PEREF)) {\n\t    if (xmlParserDebugEntities)\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"String decoding PE Reference: %.30s\\n\", str);\n\t    ent = xmlParseStringPEReference(ctxt, &str);\n\t    if (ctxt->lastError.code == XML_ERR_ENTITY_LOOP)\n\t        goto int_error;\n\t    if (ent != NULL)\n\t        ctxt->nbentities += ent->checked;\n\t    if (ent != NULL) {\n                if (ent->content == NULL) {\n\t\t    xmlLoadEntityContent(ctxt, ent);\n\t\t}\n\t\tctxt->depth++;\n\t\trep = xmlStringDecodeEntities(ctxt, ent->content, what,\n\t\t\t                      0, 0, 0);\n\t\tctxt->depth--;\n\t\tif (rep != NULL) {\n\t\t    current = rep;\n\t\t    while (*current != 0) { /* non input consuming loop */\n\t\t\tbuffer[nbchars++] = *current++;\n\t\t\tif (nbchars >\n\t\t            buffer_size - XML_PARSER_BUFFER_SIZE) {\n\t\t\t    if (xmlParserEntityCheck(ctxt, nbchars, ent))\n\t\t\t        goto int_error;\n\t\t\t    growBuffer(buffer, XML_PARSER_BUFFER_SIZE);\n\t\t\t}\n\t\t    }\n\t\t    xmlFree(rep);\n\t\t    rep = NULL;\n\t\t}\n\t    }\n\t} else {\n\t    COPY_BUF(l,buffer,nbchars,c);\n\t    str += l;\n\t    if (nbchars > buffer_size - XML_PARSER_BUFFER_SIZE) {\n\t      growBuffer(buffer, XML_PARSER_BUFFER_SIZE);\n\t    }\n\t}\n\tif (str < last)\n\t    c = CUR_SCHAR(str, l);\n\telse\n\t    c = 0;\n    }\n    buffer[nbchars] = 0;\n    return(buffer);\n\nmem_error:\n    xmlErrMemory(ctxt, NULL);\nint_error:\n    if (rep != NULL)\n        xmlFree(rep);\n    if (buffer != NULL)\n        xmlFree(buffer);\n    return(NULL);\n}\n", "target": 1, "idx": 184668}
{"func": "ResourceDispatcherHost::~ResourceDispatcherHost() {\n  AsyncResourceHandler::GlobalCleanup();\n   STLDeleteValues(&pending_requests_);\n \n   user_script_listener_->ShutdownMainThread();\n  std::set<ProcessRouteIDs> ids;\n  for (BlockedRequestMap::const_iterator iter = blocked_requests_map_.begin();\n       iter != blocked_requests_map_.end(); ++iter) {\n    std::pair<std::set<ProcessRouteIDs>::iterator, bool> result =\n        ids.insert(iter->first);\n    DCHECK(result.second);\n  }\n  for (std::set<ProcessRouteIDs>::const_iterator iter = ids.begin();\n       iter != ids.end(); ++iter) {\n    CancelBlockedRequestsForRoute(iter->first, iter->second);\n  }\n }\n", "target": 1, "idx": 183495}
{"func": "static int crypto_report_akcipher(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_akcipher rakcipher;\n \n\tstrlcpy(rakcipher.type, \"akcipher\", sizeof(rakcipher.type));\n \n \tif (nla_put(skb, CRYPTOCFGA_REPORT_AKCIPHER,\n \t\t    sizeof(struct crypto_report_akcipher), &rakcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n", "target": 1, "idx": 182136}
{"func": "PHP_METHOD(Phar, extractTo)\n{\n\tchar *error = NULL;\n\tphp_stream *fp;\n\tphp_stream_statbuf ssb;\n\tphar_entry_info *entry;\n\tchar *pathto, *filename;\n\tsize_t pathto_len, filename_len;\n\tint ret, i;\n\tint nelems;\n\tzval *zval_files = NULL;\n\tzend_bool overwrite = 0;\n \n        PHAR_ARCHIVE_OBJECT();\n \n       if (zend_parse_parameters(ZEND_NUM_ARGS(), \"s|z!b\", &pathto, &pathto_len, &zval_files, &overwrite) == FAILURE) {\n                return;\n        }\n \n\tfp = php_stream_open_wrapper(phar_obj->archive->fname, \"rb\", IGNORE_URL|STREAM_MUST_SEEK, NULL);\n\n\tif (!fp) {\n\t\tzend_throw_exception_ex(spl_ce_InvalidArgumentException, 0,\n\t\t\t\"Invalid argument, %s cannot be found\", phar_obj->archive->fname);\n\t\treturn;\n\t}\n\n\tphp_stream_close(fp);\n\n\tif (pathto_len < 1) {\n\t\tzend_throw_exception_ex(spl_ce_InvalidArgumentException, 0,\n\t\t\t\"Invalid argument, extraction path must be non-zero length\");\n\t\treturn;\n\t}\n\n\tif (pathto_len >= MAXPATHLEN) {\n\t\tchar *tmp = estrndup(pathto, 50);\n\t\t/* truncate for error message */\n\t\tzend_throw_exception_ex(spl_ce_InvalidArgumentException, 0, \"Cannot extract to \\\"%s...\\\", destination directory is too long for filesystem\", tmp);\n\t\tefree(tmp);\n\t\treturn;\n\t}\n\n\tif (php_stream_stat_path(pathto, &ssb) < 0) {\n\t\tret = php_stream_mkdir(pathto, 0777,  PHP_STREAM_MKDIR_RECURSIVE, NULL);\n\t\tif (!ret) {\n\t\t\tzend_throw_exception_ex(spl_ce_RuntimeException, 0,\n\t\t\t\t\"Unable to create path \\\"%s\\\" for extraction\", pathto);\n\t\t\treturn;\n\t\t}\n\t} else if (!(ssb.sb.st_mode & S_IFDIR)) {\n\t\tzend_throw_exception_ex(spl_ce_RuntimeException, 0,\n\t\t\t\"Unable to use path \\\"%s\\\" for extraction, it is a file, must be a directory\", pathto);\n\t\treturn;\n\t}\n\n\tif (zval_files) {\n\t\tswitch (Z_TYPE_P(zval_files)) {\n\t\t\tcase IS_NULL:\n\t\t\t\tgoto all_files;\n\t\t\tcase IS_STRING:\n\t\t\t\tfilename = Z_STRVAL_P(zval_files);\n\t\t\t\tfilename_len = Z_STRLEN_P(zval_files);\n\t\t\t\tbreak;\n\t\t\tcase IS_ARRAY:\n\t\t\t\tnelems = zend_hash_num_elements(Z_ARRVAL_P(zval_files));\n\t\t\t\tif (nelems == 0 ) {\n\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < nelems; i++) {\n\t\t\t\t\tzval *zval_file;\n\t\t\t\t\tif ((zval_file = zend_hash_index_find(Z_ARRVAL_P(zval_files), i)) != NULL) {\n\t\t\t\t\t\tswitch (Z_TYPE_P(zval_file)) {\n\t\t\t\t\t\t\tcase IS_STRING:\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tzend_throw_exception_ex(spl_ce_InvalidArgumentException, 0,\n\t\t\t\t\t\t\t\t\t\"Invalid argument, array of filenames to extract contains non-string value\");\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (NULL == (entry = zend_hash_find_ptr(&phar_obj->archive->manifest, Z_STR_P(zval_file)))) {\n\t\t\t\t\t\t\tzend_throw_exception_ex(phar_ce_PharException, 0,\n\t\t\t\t\t\t\t\t\"Phar Error: attempted to extract non-existent file \\\"%s\\\" from phar \\\"%s\\\"\", Z_STRVAL_P(zval_file), phar_obj->archive->fname);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (FAILURE == phar_extract_file(overwrite, entry, pathto, pathto_len, &error)) {\n\t\t\t\t\t\t\tzend_throw_exception_ex(phar_ce_PharException, 0,\n\t\t\t\t\t\t\t\t\"Extraction from phar \\\"%s\\\" failed: %s\", phar_obj->archive->fname, error);\n\t\t\t\t\t\t\tefree(error);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tRETURN_TRUE;\n\t\t\tdefault:\n\t\t\t\tzend_throw_exception_ex(spl_ce_InvalidArgumentException, 0,\n\t\t\t\t\t\"Invalid argument, expected a filename (string) or array of filenames\");\n\t\t\t\treturn;\n\t\t}\n\n\t\tif (NULL == (entry = zend_hash_str_find_ptr(&phar_obj->archive->manifest, filename, filename_len))) {\n\t\t\tzend_throw_exception_ex(phar_ce_PharException, 0,\n\t\t\t\t\"Phar Error: attempted to extract non-existent file \\\"%s\\\" from phar \\\"%s\\\"\", filename, phar_obj->archive->fname);\n\t\t\treturn;\n\t\t}\n\n\t\tif (FAILURE == phar_extract_file(overwrite, entry, pathto, pathto_len, &error)) {\n\t\t\tzend_throw_exception_ex(phar_ce_PharException, 0,\n\t\t\t\t\"Extraction from phar \\\"%s\\\" failed: %s\", phar_obj->archive->fname, error);\n\t\t\tefree(error);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tphar_archive_data *phar;\nall_files:\n\t\tphar = phar_obj->archive;\n\t\t/* Extract all files */\n\t\tif (!zend_hash_num_elements(&(phar->manifest))) {\n\t\t\tRETURN_TRUE;\n\t\t}\n\n\t\tZEND_HASH_FOREACH_PTR(&phar->manifest, entry) {\n\t\t\tif (FAILURE == phar_extract_file(overwrite, entry, pathto, pathto_len, &error)) {\n\t\t\t\tzend_throw_exception_ex(phar_ce_PharException, 0,\n\t\t\t\t\t\"Extraction from phar \\\"%s\\\" failed: %s\", phar->fname, error);\n\t\t\t\tefree(error);\n\t\t\t\treturn;\n\t\t\t}\n\t\t} ZEND_HASH_FOREACH_END();\n\t}\n\tRETURN_TRUE;\n}\n", "target": 1, "idx": 178244}
{"func": "static void Sp_search(js_State *J)\n{\n\tjs_Regexp *re;\n\tconst char *text;\n\tResub m;\n\n\ttext = checkstring(J, 0);\n\n\tif (js_isregexp(J, 1))\n\t\tjs_copy(J, 1);\n\telse if (js_isundefined(J, 1))\n\t\tjs_newregexp(J, \"\", 0);\n\telse\n\t\tjs_newregexp(J, js_tostring(J, 1), 0);\n \n \tre = js_toregexp(J, -1);\n \n\tif (!js_regexec(re->prog, text, &m, 0))\n \t\tjs_pushnumber(J, js_utfptrtoidx(text, m.sub[0].sp));\n \telse\n \t\tjs_pushnumber(J, -1);\n}\n", "target": 1, "idx": 182872}
{"func": " bool GesturePoint::IsInSecondClickTimeWindow() const {\n   double duration =  last_touch_time_ - last_tap_time_;\n  return duration < kMaximumSecondsBetweenDoubleClick;\n }\n", "target": 1, "idx": 184735}
{"func": "void V8TestObject::ActivityLoggingAccessForIsolatedWorldsPerWorldBindingsLongAttributeAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), \"Blink_TestObject_activityLoggingAccessForIsolatedWorldsPerWorldBindingsLongAttribute_Getter\");\n\n  ScriptState* script_state = ScriptState::ForRelevantRealm(info);\n  V8PerContextData* context_data = script_state->PerContextData();\n  if (context_data && context_data->ActivityLogger()) {\n    context_data->ActivityLogger()->LogGetter(\"TestObject.activityLoggingAccessForIsolatedWorldsPerWorldBindingsLongAttribute\");\n  }\n\n  test_object_v8_internal::ActivityLoggingAccessForIsolatedWorldsPerWorldBindingsLongAttributeAttributeGetter(info);\n}\n", "target": 0, "idx": 147150}
{"func": "bootp_print(netdissect_options *ndo,\n\t    register const u_char *cp, u_int length)\n{\n\tregister const struct bootp *bp;\n\tstatic const u_char vm_cmu[4] = VM_CMU;\n\tstatic const u_char vm_rfc1048[4] = VM_RFC1048;\n\n\tbp = (const struct bootp *)cp;\n\tND_TCHECK(bp->bp_op);\n\n\tND_PRINT((ndo, \"BOOTP/DHCP, %s\",\n\t\t  tok2str(bootp_op_values, \"unknown (0x%02x)\", bp->bp_op)));\n\n\tND_TCHECK(bp->bp_hlen);\n\tif (bp->bp_htype == 1 && bp->bp_hlen == 6 && bp->bp_op == BOOTPREQUEST) {\n\t\tND_TCHECK2(bp->bp_chaddr[0], 6);\n\t\tND_PRINT((ndo, \" from %s\", etheraddr_string(ndo, bp->bp_chaddr)));\n\t}\n\n\tND_PRINT((ndo, \", length %u\", length));\n\n\tif (!ndo->ndo_vflag)\n\t\treturn;\n\n\tND_TCHECK(bp->bp_secs);\n\n\t/* The usual hardware address type is 1 (10Mb Ethernet) */\n\tif (bp->bp_htype != 1)\n\t\tND_PRINT((ndo, \", htype %d\", bp->bp_htype));\n\n\t/* The usual length for 10Mb Ethernet address is 6 bytes */\n\tif (bp->bp_htype != 1 || bp->bp_hlen != 6)\n\t\tND_PRINT((ndo, \", hlen %d\", bp->bp_hlen));\n\n\t/* Only print interesting fields */\n\tif (bp->bp_hops)\n\t\tND_PRINT((ndo, \", hops %d\", bp->bp_hops));\n\tif (EXTRACT_32BITS(&bp->bp_xid))\n\t\tND_PRINT((ndo, \", xid 0x%x\", EXTRACT_32BITS(&bp->bp_xid)));\n \tif (EXTRACT_16BITS(&bp->bp_secs))\n \t\tND_PRINT((ndo, \", secs %d\", EXTRACT_16BITS(&bp->bp_secs)));\n \n \tND_PRINT((ndo, \", Flags [%s]\",\n \t\t  bittok2str(bootp_flag_values, \"none\", EXTRACT_16BITS(&bp->bp_flags))));\n \tif (ndo->ndo_vflag > 1)\n\t\tND_PRINT((ndo, \" (0x%04x)\", EXTRACT_16BITS(&bp->bp_flags)));\n\n\t/* Client's ip address */\n\tND_TCHECK(bp->bp_ciaddr);\n\tif (EXTRACT_32BITS(&bp->bp_ciaddr.s_addr))\n\t\tND_PRINT((ndo, \"\\n\\t  Client-IP %s\", ipaddr_string(ndo, &bp->bp_ciaddr)));\n\n\t/* 'your' ip address (bootp client) */\n\tND_TCHECK(bp->bp_yiaddr);\n\tif (EXTRACT_32BITS(&bp->bp_yiaddr.s_addr))\n\t\tND_PRINT((ndo, \"\\n\\t  Your-IP %s\", ipaddr_string(ndo, &bp->bp_yiaddr)));\n\n\t/* Server's ip address */\n\tND_TCHECK(bp->bp_siaddr);\n\tif (EXTRACT_32BITS(&bp->bp_siaddr.s_addr))\n\t\tND_PRINT((ndo, \"\\n\\t  Server-IP %s\", ipaddr_string(ndo, &bp->bp_siaddr)));\n\n\t/* Gateway's ip address */\n\tND_TCHECK(bp->bp_giaddr);\n\tif (EXTRACT_32BITS(&bp->bp_giaddr.s_addr))\n\t\tND_PRINT((ndo, \"\\n\\t  Gateway-IP %s\", ipaddr_string(ndo, &bp->bp_giaddr)));\n\n\t/* Client's Ethernet address */\n\tif (bp->bp_htype == 1 && bp->bp_hlen == 6) {\n\t\tND_TCHECK2(bp->bp_chaddr[0], 6);\n\t\tND_PRINT((ndo, \"\\n\\t  Client-Ethernet-Address %s\", etheraddr_string(ndo, bp->bp_chaddr)));\n\t}\n\n\tND_TCHECK2(bp->bp_sname[0], 1);\t\t/* check first char only */\n\tif (*bp->bp_sname) {\n\t\tND_PRINT((ndo, \"\\n\\t  sname \\\"\"));\n\t\tif (fn_printztn(ndo, bp->bp_sname, (u_int)sizeof bp->bp_sname,\n\t\t    ndo->ndo_snapend)) {\n\t\t\tND_PRINT((ndo, \"\\\"\"));\n\t\t\tND_PRINT((ndo, \"%s\", tstr + 1));\n\t\t\treturn;\n\t\t}\n\t\tND_PRINT((ndo, \"\\\"\"));\n\t}\n\tND_TCHECK2(bp->bp_file[0], 1);\t\t/* check first char only */\n\tif (*bp->bp_file) {\n\t\tND_PRINT((ndo, \"\\n\\t  file \\\"\"));\n\t\tif (fn_printztn(ndo, bp->bp_file, (u_int)sizeof bp->bp_file,\n\t\t    ndo->ndo_snapend)) {\n\t\t\tND_PRINT((ndo, \"\\\"\"));\n\t\t\tND_PRINT((ndo, \"%s\", tstr + 1));\n\t\t\treturn;\n\t\t}\n\t\tND_PRINT((ndo, \"\\\"\"));\n\t}\n\n\t/* Decode the vendor buffer */\n\tND_TCHECK(bp->bp_vend[0]);\n\tif (memcmp((const char *)bp->bp_vend, vm_rfc1048,\n\t\t    sizeof(uint32_t)) == 0)\n\t\trfc1048_print(ndo, bp->bp_vend);\n\telse if (memcmp((const char *)bp->bp_vend, vm_cmu,\n\t\t\tsizeof(uint32_t)) == 0)\n\t\tcmu_print(ndo, bp->bp_vend);\n\telse {\n\t\tuint32_t ul;\n\n\t\tul = EXTRACT_32BITS(&bp->bp_vend);\n\t\tif (ul != 0)\n\t\t\tND_PRINT((ndo, \"\\n\\t  Vendor-#0x%x\", ul));\n\t}\n\n\treturn;\ntrunc:\n\tND_PRINT((ndo, \"%s\", tstr));\n}\n", "target": 1, "idx": 183199}
{"func": "void smp_proc_sec_req(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n  tBTM_LE_AUTH_REQ auth_req = *(tBTM_LE_AUTH_REQ*)p_data;\n  tBTM_BLE_SEC_REQ_ACT sec_req_act;\n\n  SMP_TRACE_DEBUG(\"%s: auth_req=0x%x\", __func__, auth_req);\n\n  p_cb->cb_evt = 0;\n\n  btm_ble_link_sec_check(p_cb->pairing_bda, auth_req, &sec_req_act);\n\n  SMP_TRACE_DEBUG(\"%s: sec_req_act=0x%x\", __func__, sec_req_act);\n\n switch (sec_req_act) {\n case BTM_BLE_SEC_REQ_ACT_ENCRYPT:\n      SMP_TRACE_DEBUG(\"%s: BTM_BLE_SEC_REQ_ACT_ENCRYPT\", __func__);\n      smp_sm_event(p_cb, SMP_ENC_REQ_EVT, NULL);\n break;\n\n case BTM_BLE_SEC_REQ_ACT_PAIR:\n      p_cb->secure_connections_only_mode_required =\n (btm_cb.security_mode == BTM_SEC_MODE_SC) ? true : false;\n\n /* respond to non SC pairing request as failure in SC only mode */\n if (p_cb->secure_connections_only_mode_required &&\n (auth_req & SMP_SC_SUPPORT_BIT) == 0) {\n        tSMP_INT_DATA smp_int_data;\n        smp_int_data.status = SMP_PAIR_AUTH_FAIL;\n        smp_sm_event(p_cb, SMP_AUTH_CMPL_EVT, &smp_int_data);\n } else {\n /* initialize local i/r key to be default keys */\n        p_cb->peer_auth_req = auth_req;\n        p_cb->local_r_key = p_cb->local_i_key = SMP_SEC_DEFAULT_KEY;\n        p_cb->cb_evt = SMP_SEC_REQUEST_EVT;\n }\n break;\n\n case BTM_BLE_SEC_REQ_ACT_DISCARD:\n      p_cb->discard_sec_req = true;\n break;\n\n default:\n /* do nothing */\n break;\n }\n}\n", "target": 0, "idx": 175936}
{"func": "void HTMLTextAreaElement::setNonDirtyValue(const String& value)\n{\n    setValueCommon(value);\n    m_isDirty = false;\n    setNeedsValidityCheck();\n}\n", "target": 0, "idx": 122449}
{"func": "GooString *JBIG2Stream::getPSFilter(int psLevel, char *indent) {\n  return NULL;\n}\n", "target": 0, "idx": 1182}
{"func": "void AppControllerImpl::BindRequest(mojom::AppControllerRequest request) {\n   bindings_.AddBinding(this, std::move(request));\n }\n", "target": 1, "idx": 185993}
{"func": "void SpeechRecognitionManagerImpl::RecognitionAllowedCallback(int session_id,\n                                                              bool ask_user,\n                                                              bool is_allowed) {\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n\n  auto iter = sessions_.find(session_id);\n  if (iter == sessions_.end())\n    return;\n\n  Session* session = iter->second.get();\n\n  if (session->abort_requested)\n    return;\n\n   if (ask_user) {\n     SpeechRecognitionSessionContext& context = session->context;\n     context.label = media_stream_manager_->MakeMediaAccessRequest(\n        context.render_process_id, context.render_frame_id, session_id,\n        StreamControls(true, false), context.security_origin,\n         base::BindOnce(\n             &SpeechRecognitionManagerImpl::MediaRequestPermissionCallback,\n             weak_factory_.GetWeakPtr(), session_id));\n    return;\n  }\n\n  if (is_allowed) {\n    base::ThreadTaskRunnerHandle::Get()->PostTask(\n        FROM_HERE,\n        base::BindOnce(&SpeechRecognitionManagerImpl::DispatchEvent,\n                       weak_factory_.GetWeakPtr(), session_id, EVENT_START));\n  } else {\n    OnRecognitionError(\n        session_id, blink::mojom::SpeechRecognitionError(\n                        blink::mojom::SpeechRecognitionErrorCode::kNotAllowed,\n                        blink::mojom::SpeechAudioErrorDetails::kNone));\n    base::ThreadTaskRunnerHandle::Get()->PostTask(\n        FROM_HERE,\n        base::BindOnce(&SpeechRecognitionManagerImpl::DispatchEvent,\n                       weak_factory_.GetWeakPtr(), session_id, EVENT_ABORT));\n  }\n}\n", "target": 1, "idx": 187094}
{"func": "SProcRenderCreateRadialGradient (ClientPtr client)\n{\n    register int n;\n    int len;\n    REQUEST (xRenderCreateRadialGradientReq);\n    REQUEST_AT_LEAST_SIZE (xRenderCreateRadialGradientReq);\n\n    swaps(&stuff->length, n);\n    swapl(&stuff->pid, n);\n    swapl(&stuff->inner.x, n);\n    swapl(&stuff->inner.y, n);\n    swapl(&stuff->outer.x, n);\n    swapl(&stuff->outer.y, n);\n    swapl(&stuff->inner_radius, n);\n    swapl(&stuff->outer_radius, n);\n    swapl(&stuff->nStops, n);\n\n    len = (client->req_len << 2) - sizeof(xRenderCreateRadialGradientReq);\n    if (stuff->nStops > UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))\n\treturn BadLength;\n    if (len != stuff->nStops*(sizeof(xFixed) + sizeof(xRenderColor)))\n        return BadLength;\n\n    swapStops(stuff+1, stuff->nStops);\n\n    return (*ProcRenderVector[stuff->renderReqType]) (client);\n}\n", "target": 0, "idx": 14104}
{"func": "  tt_cmap12_init( TT_CMap12  cmap,\n                  FT_Byte*   table )\n  {\n    cmap->cmap.data  = table;\n\n    table           += 12;\n    cmap->num_groups = FT_PEEK_ULONG( table );\n\n    cmap->valid      = 0;\n\n    return SFNT_Err_Ok;\n  }\n", "target": 0, "idx": 4178}
{"func": "MagickExport Image *ComplexImages(const Image *images,const ComplexOperator op,\n  ExceptionInfo *exception)\n{\n#define ComplexImageTag  \"Complex/Image\"\n\n  CacheView\n    *Ai_view,\n    *Ar_view,\n    *Bi_view,\n    *Br_view,\n    *Ci_view,\n    *Cr_view;\n\n  const char\n    *artifact;\n\n  const Image\n    *Ai_image,\n    *Ar_image,\n    *Bi_image,\n    *Br_image;\n\n  double\n    snr;\n\n  Image\n    *Ci_image,\n    *complex_images,\n    *Cr_image,\n    *image;\n\n  MagickBooleanType\n    status;\n\n   MagickOffsetType\n     progress;\n \n   ssize_t\n     y;\n \n  assert(images != (Image *) NULL);\n  assert(images->signature == MagickCoreSignature);\n  if (images->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",images->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if (images->next == (Image *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ImageSequenceRequired\",\"`%s'\",images->filename);\n      return((Image *) NULL);\n    }\n  image=CloneImage(images,0,0,MagickTrue,exception);\n  if (image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return(image);\n    }\n  image->depth=32UL;\n  complex_images=NewImageList();\n  AppendImageToList(&complex_images,image);\n  image=CloneImage(images,0,0,MagickTrue,exception);\n  if (image == (Image *) NULL)\n    {\n      complex_images=DestroyImageList(complex_images);\n      return(complex_images);\n    }\n  AppendImageToList(&complex_images,image);\n  /*\n    Apply complex mathematics to image pixels.\n  */\n  artifact=GetImageArtifact(image,\"complex:snr\");\n  snr=0.0;\n  if (artifact != (const char *) NULL)\n    snr=StringToDouble(artifact,(char **) NULL);\n  Ar_image=images;\n  Ai_image=images->next;\n  Br_image=images;\n  Bi_image=images->next;\n  if ((images->next->next != (Image *) NULL) &&\n      (images->next->next->next != (Image *) NULL))\n    {\n      Br_image=images->next->next;\n      Bi_image=images->next->next->next;\n     }\n   Cr_image=complex_images;\n   Ci_image=complex_images->next;\n   Ar_view=AcquireVirtualCacheView(Ar_image,exception);\n   Ai_view=AcquireVirtualCacheView(Ai_image,exception);\n   Br_view=AcquireVirtualCacheView(Br_image,exception);\n  Bi_view=AcquireVirtualCacheView(Bi_image,exception);\n  Cr_view=AcquireAuthenticCacheView(Cr_image,exception);\n  Ci_view=AcquireAuthenticCacheView(Ci_image,exception);\n  status=MagickTrue;\n  progress=0;\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(Cr_image,complex_images,Cr_image->rows,1L)\n#endif\n  for (y=0; y < (ssize_t) Cr_image->rows; y++)\n  {\n    register const Quantum\n      *magick_restrict Ai,\n      *magick_restrict Ar,\n      *magick_restrict Bi,\n      *magick_restrict Br;\n\n    register Quantum\n      *magick_restrict Ci,\n      *magick_restrict Cr;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    Ar=GetCacheViewVirtualPixels(Ar_view,0,y,Cr_image->columns,1,exception);\n    Ai=GetCacheViewVirtualPixels(Ai_view,0,y,Cr_image->columns,1,exception);\n    Br=GetCacheViewVirtualPixels(Br_view,0,y,Cr_image->columns,1,exception);\n    Bi=GetCacheViewVirtualPixels(Bi_view,0,y,Cr_image->columns,1,exception);\n    Cr=QueueCacheViewAuthenticPixels(Cr_view,0,y,Cr_image->columns,1,exception);\n    Ci=QueueCacheViewAuthenticPixels(Ci_view,0,y,Ci_image->columns,1,exception);\n    if ((Ar == (const Quantum *) NULL) || (Ai == (const Quantum *) NULL) || \n        (Br == (const Quantum *) NULL) || (Bi == (const Quantum *) NULL) ||\n        (Cr == (Quantum *) NULL) || (Ci == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) Cr_image->columns; x++)\n    {\n       register ssize_t\n         i;\n \n      for (i=0; i < (ssize_t) GetPixelChannels(Cr_image); i++)\n       {\n         switch (op)\n         {\n          case AddComplexOperator:\n          {\n            Cr[i]=Ar[i]+Br[i];\n            Ci[i]=Ai[i]+Bi[i];\n            break;\n          }\n          case ConjugateComplexOperator:\n          default:\n          {\n            Cr[i]=Ar[i];\n            Ci[i]=(-Bi[i]);\n            break;\n          }\n          case DivideComplexOperator:\n          {\n            double\n              gamma;\n\n            gamma=PerceptibleReciprocal((double) Br[i]*Br[i]+Bi[i]*Bi[i]+snr);\n            Cr[i]=gamma*((double) Ar[i]*Br[i]+(double) Ai[i]*Bi[i]);\n            Ci[i]=gamma*((double) Ai[i]*Br[i]-(double) Ar[i]*Bi[i]);\n            break;\n          }\n          case MagnitudePhaseComplexOperator:\n          {\n            Cr[i]=sqrt((double) Ar[i]*Ar[i]+(double) Ai[i]*Ai[i]);\n            Ci[i]=atan2((double) Ai[i],(double) Ar[i])/(2.0*MagickPI)+0.5;\n            break;\n          }\n          case MultiplyComplexOperator:\n          {\n            Cr[i]=QuantumScale*((double) Ar[i]*Br[i]-(double) Ai[i]*Bi[i]);\n            Ci[i]=QuantumScale*((double) Ai[i]*Br[i]+(double) Ar[i]*Bi[i]);\n            break;\n          }\n          case RealImaginaryComplexOperator:\n          {\n            Cr[i]=Ar[i]*cos(2.0*MagickPI*(Ai[i]-0.5));\n            Ci[i]=Ar[i]*sin(2.0*MagickPI*(Ai[i]-0.5));\n            break;\n          }\n          case SubtractComplexOperator:\n          {\n            Cr[i]=Ar[i]-Br[i];\n            Ci[i]=Ai[i]-Bi[i];\n            break;\n          }\n        }\n      }\n      Ar+=GetPixelChannels(Ar_image);\n      Ai+=GetPixelChannels(Ai_image);\n      Br+=GetPixelChannels(Br_image);\n      Bi+=GetPixelChannels(Bi_image);\n      Cr+=GetPixelChannels(Cr_image);\n      Ci+=GetPixelChannels(Ci_image);\n    }\n    if (SyncCacheViewAuthenticPixels(Ci_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (SyncCacheViewAuthenticPixels(Cr_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (images->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n#endif\n        progress++;\n        proceed=SetImageProgress(images,ComplexImageTag,progress,images->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  Cr_view=DestroyCacheView(Cr_view);\n  Ci_view=DestroyCacheView(Ci_view);\n  Br_view=DestroyCacheView(Br_view);\n  Bi_view=DestroyCacheView(Bi_view);\n  Ar_view=DestroyCacheView(Ar_view);\n  Ai_view=DestroyCacheView(Ai_view);\n  if (status == MagickFalse)\n    complex_images=DestroyImageList(complex_images);\n  return(complex_images);\n}\n", "target": 1, "idx": 182771}
{"func": "void ChromeClientImpl::AttachRootGraphicsLayer(GraphicsLayer* root_layer,\n                                               LocalFrame* local_frame) {\n  DCHECK(!RuntimeEnabledFeatures::SlimmingPaintV2Enabled());\n  WebLocalFrameImpl* web_frame =\n      WebLocalFrameImpl::FromFrame(local_frame)->LocalRoot();\n\n  DCHECK(web_frame->FrameWidget() || !root_layer);\n  if (web_frame->FrameWidget())\n    web_frame->FrameWidget()->SetRootGraphicsLayer(root_layer);\n}\n", "target": 0, "idx": 160928}
{"func": "int Browser::GetContentRestrictionsForSelectedTab() {\n  int content_restrictions = 0;\n  TabContents* current_tab = GetSelectedTabContents();\n  if (current_tab) {\n    content_restrictions = current_tab->content_restrictions();\n    NavigationEntry* active_entry = current_tab->controller().GetActiveEntry();\n    if (!SavePackage::IsSavableURL(active_entry ? active_entry->url() : GURL()))\n      content_restrictions |= CONTENT_RESTRICTION_SAVE;\n  }\n  return content_restrictions;\n}\n", "target": 0, "idx": 101656}
{"func": "static void ProxyLocaltimeCallToBrowser(time_t input, struct tm* output,\n                                        char* timezone_out,\n                                        size_t timezone_out_len) {\n  base::Pickle request;\n  request.WriteInt(LinuxSandbox::METHOD_LOCALTIME);\n   request.WriteString(\n       std::string(reinterpret_cast<char*>(&input), sizeof(input)));\n \n   uint8_t reply_buf[512];\n   const ssize_t r = base::UnixDomainSocket::SendRecvMsg(\n       GetSandboxFD(), reply_buf, sizeof(reply_buf), NULL, request);\n   if (r == -1) {\n    memset(output, 0, sizeof(struct tm));\n     return;\n   }\n \n   base::Pickle reply(reinterpret_cast<char*>(reply_buf), r);\n   base::PickleIterator iter(reply);\n  std::string result;\n  std::string timezone;\n  if (!iter.ReadString(&result) ||\n      !iter.ReadString(&timezone) ||\n      result.size() != sizeof(struct tm)) {\n     memset(output, 0, sizeof(struct tm));\n    return;\n  }\n  memcpy(output, result.data(), sizeof(struct tm));\n  if (timezone_out_len) {\n    const size_t copy_len = std::min(timezone_out_len - 1, timezone.size());\n    memcpy(timezone_out, timezone.data(), copy_len);\n    timezone_out[copy_len] = 0;\n    output->tm_zone = timezone_out;\n  } else {\n    base::AutoLock lock(g_timezones_lock.Get());\n    auto ret_pair = g_timezones.Get().insert(timezone);\n    output->tm_zone = ret_pair.first->c_str();\n   }\n }\n", "target": 1, "idx": 186903}
{"func": "void MojoJpegDecodeAccelerator::Decode(\n    const BitstreamBuffer& bitstream_buffer,\n    const scoped_refptr<VideoFrame>& video_frame) {\n  DCHECK(io_task_runner_->BelongsToCurrentThread());\n  DCHECK(jpeg_decoder_.is_bound());\n\n  DCHECK(\n      base::SharedMemory::IsHandleValid(video_frame->shared_memory_handle()));\n\n  base::SharedMemoryHandle output_handle =\n      base::SharedMemory::DuplicateHandle(video_frame->shared_memory_handle());\n  if (!base::SharedMemory::IsHandleValid(output_handle)) {\n    DLOG(ERROR) << \"Failed to duplicate handle of VideoFrame\";\n    return;\n  }\n\n   size_t output_buffer_size = VideoFrame::AllocationSize(\n       video_frame->format(), video_frame->coded_size());\n   mojo::ScopedSharedBufferHandle output_frame_handle =\n      mojo::WrapSharedMemoryHandle(output_handle, output_buffer_size,\n                                   false /* read_only */);\n \n   jpeg_decoder_->Decode(bitstream_buffer, video_frame->coded_size(),\n                        std::move(output_frame_handle),\n                        base::checked_cast<uint32_t>(output_buffer_size),\n                        base::Bind(&MojoJpegDecodeAccelerator::OnDecodeAck,\n                                   base::Unretained(this)));\n}\n", "target": 1, "idx": 186849}
{"func": "add_cipher_name_to_ary(const OBJ_NAME *name, VALUE ary)\n{\n    rb_ary_push(ary, rb_str_new2(name->name));\n    return NULL;\n}\n", "target": 0, "idx": 73405}
{"func": "  std::string GetBody(Browser* browser) {\n    std::string body;\n    EXPECT_TRUE(content::ExecuteScriptAndExtractString(\n        browser->tab_strip_model()->GetActiveWebContents(),\n        \"window.domAutomationController.send(document.body.textContent);\",\n        &body));\n    return body;\n  }\n", "target": 0, "idx": 150519}
{"func": "WORD32 ih264d_read_mmco_commands(struct _DecStruct * ps_dec)\n{\n dec_bit_stream_t *ps_bitstrm = ps_dec->ps_bitstrm;\n dpb_commands_t *ps_dpb_cmds = ps_dec->ps_dpb_cmds;\n dec_slice_params_t * ps_slice = ps_dec->ps_cur_slice;\n    WORD32 j;\n    UWORD8 u1_buf_mode;\n struct MMCParams *ps_mmc_params;\n    UWORD32 *pu4_bitstrm_buf = ps_dec->ps_bitstrm->pu4_buffer;\n    UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;\n    UWORD32 u4_bit_ofst = ps_dec->ps_bitstrm->u4_ofst;\n\n    ps_slice->u1_mmco_equalto5 = 0;\n {\n if(ps_dec->u1_nal_unit_type == IDR_SLICE_NAL)\n {\n            ps_slice->u1_no_output_of_prior_pics_flag =\n                            ih264d_get_bit_h264(ps_bitstrm);\n            COPYTHECONTEXT(\"SH: no_output_of_prior_pics_flag\",\n                            ps_slice->u1_no_output_of_prior_pics_flag);\n            ps_slice->u1_long_term_reference_flag = ih264d_get_bit_h264(\n                            ps_bitstrm);\n            COPYTHECONTEXT(\"SH: long_term_reference_flag\",\n                            ps_slice->u1_long_term_reference_flag);\n            ps_dpb_cmds->u1_idr_pic = 1;\n            ps_dpb_cmds->u1_no_output_of_prior_pics_flag =\n                            ps_slice->u1_no_output_of_prior_pics_flag;\n            ps_dpb_cmds->u1_long_term_reference_flag =\n                            ps_slice->u1_long_term_reference_flag;\n }\n else\n {\n            u1_buf_mode = ih264d_get_bit_h264(ps_bitstrm); //0 - sliding window; 1 - arbitrary\n            COPYTHECONTEXT(\"SH: adaptive_ref_pic_buffering_flag\", u1_buf_mode);\n            ps_dpb_cmds->u1_buf_mode = u1_buf_mode;\n            j = 0;\n\n if(u1_buf_mode == 1)\n {\n                UWORD32 u4_mmco;\n                UWORD32 u4_diff_pic_num;\n                UWORD32 u4_lt_idx, u4_max_lt_idx;\n\n                u4_mmco = ih264d_uev(pu4_bitstrm_ofst,\n\n                                      pu4_bitstrm_buf);\n                 while(u4_mmco != END_OF_MMCO)\n                 {\n                     ps_mmc_params = &ps_dpb_cmds->as_mmc_params[j];\n                     ps_mmc_params->u4_mmco = u4_mmco;\n                     switch(u4_mmco)\n {\n case MARK_ST_PICNUM_AS_NONREF:\n                            u4_diff_pic_num = ih264d_uev(pu4_bitstrm_ofst,\n                                                         pu4_bitstrm_buf);\n                            ps_mmc_params->u4_diff_pic_num = u4_diff_pic_num;\n break;\n\n case MARK_LT_INDEX_AS_NONREF:\n                            u4_lt_idx = ih264d_uev(pu4_bitstrm_ofst,\n                                                   pu4_bitstrm_buf);\n                            ps_mmc_params->u4_lt_idx = u4_lt_idx;\n break;\n\n case MARK_ST_PICNUM_AS_LT_INDEX:\n                            u4_diff_pic_num = ih264d_uev(pu4_bitstrm_ofst,\n                                                         pu4_bitstrm_buf);\n                            ps_mmc_params->u4_diff_pic_num = u4_diff_pic_num;\n                            u4_lt_idx = ih264d_uev(pu4_bitstrm_ofst,\n                                                   pu4_bitstrm_buf);\n                            ps_mmc_params->u4_lt_idx = u4_lt_idx;\n break;\n\n case SET_MAX_LT_INDEX:\n {\n                            u4_max_lt_idx = ih264d_uev(pu4_bitstrm_ofst,\n                                                       pu4_bitstrm_buf);\n                            ps_mmc_params->u4_max_lt_idx_plus1 = u4_max_lt_idx;\n break;\n }\n case RESET_REF_PICTURES:\n {\n                            ps_slice->u1_mmco_equalto5 = 1;\n break;\n }\n\n case SET_LT_INDEX:\n                            u4_lt_idx = ih264d_uev(pu4_bitstrm_ofst,\n                                                   pu4_bitstrm_buf);\n                            ps_mmc_params->u4_lt_idx = u4_lt_idx;\n break;\n\n default:\n break;\n }\n                    u4_mmco = ih264d_uev(pu4_bitstrm_ofst,\n                                         pu4_bitstrm_buf);\n\n                    j++;\n }\n                ps_dpb_cmds->u1_num_of_commands = j;\n\n }\n }\n        ps_dpb_cmds->u1_dpb_commands_read = 1;\n        ps_dpb_cmds->u1_dpb_commands_read_slc = 1;\n\n }\n    u4_bit_ofst = ps_dec->ps_bitstrm->u4_ofst - u4_bit_ofst;\n return u4_bit_ofst;\n}\n", "target": 1, "idx": 187929}
{"func": "const std::string& WebContentsImpl::GetUserAgentOverride() const {\n  return renderer_preferences_.user_agent_override;\n}\n", "target": 0, "idx": 118928}
{"func": "RTCVoidRequestImpl::~RTCVoidRequestImpl()\n{\n}\n", "target": 0, "idx": 104264}
{"func": "static const ut8 *r_bin_dwarf_parse_comp_unit(Sdb *s, const ut8 *obuf,\n\t\tRBinDwarfCompUnit *cu, const RBinDwarfDebugAbbrev *da,\n\t\tsize_t offset, const ut8 *debug_str, size_t debug_str_len) {\n\tconst ut8 *buf = obuf, *buf_end = obuf + (cu->hdr.length - 7);\n\tut64 abbr_code;\n\tsize_t i;\n\t\n\tif (cu->hdr.length > debug_str_len) {\n\t\treturn NULL;\n\t}\n\twhile (buf && buf < buf_end && buf >= obuf) {\n\t\tif (cu->length && cu->capacity == cu->length) {\n\t\t\tr_bin_dwarf_expand_cu (cu);\n\t\t}\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &abbr_code);\n\t\tif (abbr_code > da->length || !buf) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tr_bin_dwarf_init_die (&cu->dies[cu->length]);\n\t\tif (!abbr_code) {\n\t\t\tcu->dies[cu->length].abbrev_code = 0;\n\t\t\tcu->length++;\n\t\t\tbuf++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcu->dies[cu->length].abbrev_code = abbr_code;\n\t\tcu->dies[cu->length].tag = da->decls[abbr_code - 1].tag;\n\t\tabbr_code += offset;\n\n\t\tif (da->capacity < abbr_code) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tfor (i = 0; i < da->decls[abbr_code - 1].length; i++) {\n\t\t\tif (cu->dies[cu->length].length == cu->dies[cu->length].capacity) {\n\t\t\t\tr_bin_dwarf_expand_die (&cu->dies[cu->length]);\n\t\t\t}\n\t\t\tif (i >= cu->dies[cu->length].capacity || i >= da->decls[abbr_code - 1].capacity) {\n \t\t\t\teprintf (\"Warning: malformed dwarf attribute capacity doesn't match length\\n\");\n \t\t\t\tbreak;\n \t\t\t}\n\t\t\tmemset (&cu->dies[cu->length].attr_values[i], 0, sizeof\n\t\t\t\t\t(cu->dies[cu->length].attr_values[i]));\n \t\t\tbuf = r_bin_dwarf_parse_attr_value (buf, buf_end - buf,\n \t\t\t\t\t&da->decls[abbr_code - 1].specs[i],\n \t\t\t\t\t&cu->dies[cu->length].attr_values[i],\n\t\t\t\t\t&cu->hdr, debug_str, debug_str_len);\n\t\t\tif (cu->dies[cu->length].attr_values[i].name == DW_AT_comp_dir) {\n\t\t\t\tconst char *name = cu->dies[cu->length].attr_values[i].encoding.str_struct.string;\n\t\t\t\tsdb_set (s, \"DW_AT_comp_dir\", name, 0);\n\t\t\t}\n\t\t\tcu->dies[cu->length].length++;\n\t\t}\n\t\tcu->length++;\n\t}\n\treturn buf;\n}\n", "target": 1, "idx": 180842}
{"func": "bool ChromotingInstance::Init(uint32_t argc,\n                              const char* argn[],\n                              const char* argv[]) {\n  CHECK(!initialized_);\n  initialized_ = true;\n\n  VLOG(1) << \"Started ChromotingInstance::Init\";\n\n  if (!media::IsMediaLibraryInitialized()) {\n    LOG(ERROR) << \"Media library not initialized.\";\n     return false;\n   }\n \n  net::EnableSSLServerSockets();\n\n  context_.Start();\n\n  scoped_refptr<FrameConsumerProxy> consumer_proxy =\n      new FrameConsumerProxy(plugin_task_runner_);\n  rectangle_decoder_ = new RectangleUpdateDecoder(context_.main_task_runner(),\n                                                  context_.decode_task_runner(),\n                                                  consumer_proxy);\n  view_.reset(new PepperView(this, &context_, rectangle_decoder_.get()));\n  consumer_proxy->Attach(view_->AsWeakPtr());\n\n  return true;\n}\n", "target": 1, "idx": 184222}
{"func": "int __dev_addr_add(struct dev_addr_list **list, int *count,\n\t\t   void *addr, int alen, int glbl)\n{\n\tstruct dev_addr_list *da;\n\n\tfor (da = *list; da != NULL; da = da->next) {\n\t\tif (memcmp(da->da_addr, addr, da->da_addrlen) == 0 &&\n\t\t    da->da_addrlen == alen) {\n\t\t\tif (glbl) {\n\t\t\t\tint old_glbl = da->da_gusers;\n\t\t\t\tda->da_gusers = 1;\n\t\t\t\tif (old_glbl)\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tda->da_users++;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tda = kzalloc(sizeof(*da), GFP_ATOMIC);\n\tif (da == NULL)\n\t\treturn -ENOMEM;\n\tmemcpy(da->da_addr, addr, alen);\n\tda->da_addrlen = alen;\n\tda->da_users = 1;\n\tda->da_gusers = glbl ? 1 : 0;\n\tda->next = *list;\n\t*list = da;\n\t(*count)++;\n\treturn 0;\n}\n", "target": 0, "idx": 32052}
{"func": "apprentice_load(struct magic_set *ms, const char *fn, int action)\n{\n\tint errs = 0;\n\tuint32_t i, j;\n\tsize_t files = 0, maxfiles = 0;\n\tchar **filearr = NULL;\n\tstruct stat st;\n\tstruct magic_map *map;\n\tstruct magic_entry_set mset[MAGIC_SETS];\n\tphp_stream *dir;\n\tphp_stream_dirent d;\n \n\tTSRMLS_FETCH();\n\n\tmemset(mset, 0, sizeof(mset));\n\tms->flags |= MAGIC_CHECK;\t/* Enable checks for parsed files */\n\n\n\tif ((map = CAST(struct magic_map *, ecalloc(1, sizeof(*map)))) == NULL)\n\t{\n\t\tfile_oomem(ms, sizeof(*map));\n\t\treturn NULL;\n\t}\n\n\t/* print silly verbose header for USG compat. */\n\tif (action == FILE_CHECK)\n\t\t(void)fprintf(stderr, \"%s\\n\", usg_hdr);\n\n\t/* load directory or file */\n\t/* FIXME: Read file names and sort them to prevent\n\t   non-determinism. See Debian bug #488562. */\n\tif (php_sys_stat(fn, &st) == 0 && S_ISDIR(st.st_mode)) {\n\t\tint mflen;\n\t\tchar mfn[MAXPATHLEN];\n\n\t\tdir = php_stream_opendir((char *)fn, REPORT_ERRORS, NULL);\n\t\tif (!dir) {\n\t\t\terrs++;\n\t\t\tgoto out;\n\t\t}\n\t\twhile (php_stream_readdir(dir, &d)) {\n\t\t\tif ((mflen = snprintf(mfn, sizeof(mfn), \"%s/%s\", fn, d.d_name)) < 0) {\n\t\t\t\tfile_oomem(ms,\n\t\t\t\tstrlen(fn) + strlen(d.d_name) + 2);\n\t\t\t\terrs++;\n\t\t\t\tphp_stream_closedir(dir);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (stat(mfn, &st) == -1 || !S_ISREG(st.st_mode)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (files >= maxfiles) {\n\t\t\t\tsize_t mlen;\n\t\t\t\tmaxfiles = (maxfiles + 1) * 2;\n\t\t\t\tmlen = maxfiles * sizeof(*filearr);\n                                if ((filearr = CAST(char **,\n                                    erealloc(filearr, mlen))) == NULL) {\n                                        file_oomem(ms, mlen);\n                                       efree(mfn);\n                                        php_stream_closedir(dir);\n                                        errs++;\n                                        goto out;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfilearr[files++] = estrndup(mfn, (mflen > sizeof(mfn) - 1)? sizeof(mfn) - 1: mflen);\n\t\t}\n\t\tphp_stream_closedir(dir);\n\t\tqsort(filearr, files, sizeof(*filearr), cmpstrp);\n\t\tfor (i = 0; i < files; i++) {\n\t\t\tload_1(ms, action, filearr[i], &errs, mset);\n\t\t\tefree(filearr[i]);\n\t\t}\n\t\tefree(filearr);\n\t} else\n\t\tload_1(ms, action, fn, &errs, mset);\n\tif (errs)\n\t\tgoto out;\n\n\tfor (j = 0; j < MAGIC_SETS; j++) {\n\t\t/* Set types of tests */\n\t\tfor (i = 0; i < mset[j].count; ) {\n\t\t\tif (mset[j].me[i].mp->cont_level != 0) {\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti = set_text_binary(ms, mset[j].me, mset[j].count, i);\n\t\t}\n\t\tqsort(mset[j].me, mset[j].count, sizeof(*mset[j].me),\n\t\t    apprentice_sort);\n\n\t\t/*\n\t\t * Make sure that any level 0 \"default\" line is last\n\t\t * (if one exists).\n\t\t */\n\t\tset_last_default(ms, mset[j].me, mset[j].count);\n\n\t\t/* coalesce per file arrays into a single one */\n\t\tif (coalesce_entries(ms, mset[j].me, mset[j].count,\n\t\t    &map->magic[j], &map->nmagic[j]) == -1) {\n\t\t\terrs++;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tfor (j = 0; j < MAGIC_SETS; j++)\n\t\tmagic_entry_free(mset[j].me, mset[j].count);\n\n\tif (errs) {\n\t\tfor (j = 0; j < MAGIC_SETS; j++) {\n\t\t\tif (map->magic[j])\n\t\t\t\tefree(map->magic[j]);\n\t\t}\n\t\tefree(map);\n\t\treturn NULL;\n\t}\n\treturn map;\n}\n", "target": 1, "idx": 178054}
{"func": "llc_print(netdissect_options *ndo, const u_char *p, u_int length, u_int caplen,\n\t  const struct lladdr_info *src, const struct lladdr_info *dst)\n{\n\tuint8_t dsap_field, dsap, ssap_field, ssap;\n\tuint16_t control;\n\tint hdrlen;\n\tint is_u;\n\n\tif (caplen < 3) {\n\t\tND_PRINT((ndo, \"[|llc]\"));\n\t\tND_DEFAULTPRINT((const u_char *)p, caplen);\n\t\treturn (caplen);\n\t}\n\tif (length < 3) {\n\t\tND_PRINT((ndo, \"[|llc]\"));\n\t\tND_DEFAULTPRINT((const u_char *)p, caplen);\n\t\treturn (length);\n\t}\n\n\tdsap_field = *p;\n\tssap_field = *(p + 1);\n\n\t/*\n\t * OK, what type of LLC frame is this?  The length\n\t * of the control field depends on that - I frames\n\t * have a two-byte control field, and U frames have\n\t * a one-byte control field.\n\t */\n\tcontrol = *(p + 2);\n\tif ((control & LLC_U_FMT) == LLC_U_FMT) {\n\t\t/*\n\t\t * U frame.\n\t\t */\n\t\tis_u = 1;\n\t\thdrlen = 3;\t/* DSAP, SSAP, 1-byte control field */\n\t} else {\n\t\t/*\n\t\t * The control field in I and S frames is\n\t\t * 2 bytes...\n\t\t */\n\t\tif (caplen < 4) {\n\t\t\tND_PRINT((ndo, \"[|llc]\"));\n\t\t\tND_DEFAULTPRINT((const u_char *)p, caplen);\n\t\t\treturn (caplen);\n\t\t}\n\t\tif (length < 4) {\n\t\t\tND_PRINT((ndo, \"[|llc]\"));\n\t\t\tND_DEFAULTPRINT((const u_char *)p, caplen);\n\t\t\treturn (length);\n\t\t}\n\n\t\t/*\n\t\t * ...and is little-endian.\n\t\t */\n\t\tcontrol = EXTRACT_LE_16BITS(p + 2);\n\t\tis_u = 0;\n\t\thdrlen = 4;\t/* DSAP, SSAP, 2-byte control field */\n\t}\n\n\tif (ssap_field == LLCSAP_GLOBAL && dsap_field == LLCSAP_GLOBAL) {\n\t\t/*\n\t\t * This is an Ethernet_802.3 IPX frame; it has an\n\t\t * 802.3 header (i.e., an Ethernet header where the\n\t\t * type/length field is <= ETHERMTU, i.e. it's a length\n\t\t * field, not a type field), but has no 802.2 header -\n\t\t * the IPX packet starts right after the Ethernet header,\n\t\t * with a signature of two bytes of 0xFF (which is\n\t\t * LLCSAP_GLOBAL).\n\t\t *\n\t\t * (It might also have been an Ethernet_802.3 IPX at\n\t\t * one time, but got bridged onto another network,\n\t\t * such as an 802.11 network; this has appeared in at\n\t\t * least one capture file.)\n\t\t */\n\n            if (ndo->ndo_eflag)\n\t\tND_PRINT((ndo, \"IPX 802.3: \"));\n\n            ipx_print(ndo, p, length);\n            return (0);\t\t/* no LLC header */\n\t}\n\n\tdsap = dsap_field & ~LLC_IG;\n\tssap = ssap_field & ~LLC_GSAP;\n\n\tif (ndo->ndo_eflag) {\n                ND_PRINT((ndo, \"LLC, dsap %s (0x%02x) %s, ssap %s (0x%02x) %s\",\n                       tok2str(llc_values, \"Unknown\", dsap),\n                       dsap,\n                       tok2str(llc_ig_flag_values, \"Unknown\", dsap_field & LLC_IG),\n                       tok2str(llc_values, \"Unknown\", ssap),\n                       ssap,\n                       tok2str(llc_flag_values, \"Unknown\", ssap_field & LLC_GSAP)));\n\n\t\tif (is_u) {\n\t\t\tND_PRINT((ndo, \", ctrl 0x%02x: \", control));\n\t\t} else {\n\t\t\tND_PRINT((ndo, \", ctrl 0x%04x: \", control));\n\t\t}\n\t}\n\n\t/*\n\t * Skip LLC header.\n\t */\n\tp += hdrlen;\n\tlength -= hdrlen;\n\tcaplen -= hdrlen;\n\n\tif (ssap == LLCSAP_SNAP && dsap == LLCSAP_SNAP\n\t    && control == LLC_UI) {\n\t\t/*\n\t\t * XXX - what *is* the right bridge pad value here?\n\t\t * Does anybody ever bridge one form of LAN traffic\n\t\t * over a networking type that uses 802.2 LLC?\n\t\t */\n\t\tif (!snap_print(ndo, p, length, caplen, src, dst, 2)) {\n\t\t\t/*\n\t\t\t * Unknown packet type; tell our caller, by\n\t\t\t * returning a negative value, so they\n\t\t\t * can print the raw packet.\n\t\t\t */\n\t\t\treturn (-(hdrlen + 5));\t/* include LLC and SNAP header */\n\t\t} else\n\t\t\treturn (hdrlen + 5);\t/* include LLC and SNAP header */\n\t}\n\n\tif (ssap == LLCSAP_8021D && dsap == LLCSAP_8021D &&\n\t    control == LLC_UI) {\n\t\tstp_print(ndo, p, length);\n\t\treturn (hdrlen);\n\t}\n\n\tif (ssap == LLCSAP_IP && dsap == LLCSAP_IP &&\n\t    control == LLC_UI) {\n\t\t/*\n\t\t * This is an RFC 948-style IP packet, with\n\t\t * an 802.3 header and an 802.2 LLC header\n\t\t * with the source and destination SAPs being\n\t\t * the IP SAP.\n\t\t */\n\t\tip_print(ndo, p, length);\n\t\treturn (hdrlen);\n\t}\n\n\tif (ssap == LLCSAP_IPX && dsap == LLCSAP_IPX &&\n\t    control == LLC_UI) {\n\t\t/*\n\t\t * This is an Ethernet_802.2 IPX frame, with an 802.3\n\t\t * header and an 802.2 LLC header with the source and\n\t\t * destination SAPs being the IPX SAP.\n\t\t */\n                if (ndo->ndo_eflag)\n                        ND_PRINT((ndo, \"IPX 802.2: \"));\n\n\t\tipx_print(ndo, p, length);\n\t\treturn (hdrlen);\n\t}\n\n#ifdef ENABLE_SMB\n\tif (ssap == LLCSAP_NETBEUI && dsap == LLCSAP_NETBEUI\n\t    && (!(control & LLC_S_FMT) || control == LLC_U_FMT)) {\n\t\t/*\n\t\t * we don't actually have a full netbeui parser yet, but the\n\t\t * smb parser can handle many smb-in-netbeui packets, which\n\t\t * is very useful, so we call that\n\t\t *\n\t\t * We don't call it for S frames, however, just I frames\n\t\t * (which are frames that don't have the low-order bit,\n\t\t * LLC_S_FMT, set in the first byte of the control field)\n\t\t * and UI frames (whose control field is just 3, LLC_U_FMT).\n\t\t */\n\t\tnetbeui_print(ndo, control, p, length);\n\t\treturn (hdrlen);\n\t}\n #endif\n \tif (ssap == LLCSAP_ISONS && dsap == LLCSAP_ISONS\n \t    && control == LLC_UI) {\n\t\tisoclns_print(ndo, p, length, caplen);\n \t\treturn (hdrlen);\n \t}\n \n\tif (!ndo->ndo_eflag) {\n\t\tif (ssap == dsap) {\n\t\t\tif (src == NULL || dst == NULL)\n\t\t\t\tND_PRINT((ndo, \"%s \", tok2str(llc_values, \"Unknown DSAP 0x%02x\", dsap)));\n\t\t\telse\n\t\t\t\tND_PRINT((ndo, \"%s > %s %s \",\n\t\t\t\t\t\t(src->addr_string)(ndo, src->addr),\n\t\t\t\t\t\t(dst->addr_string)(ndo, dst->addr),\n\t\t\t\t\t\ttok2str(llc_values, \"Unknown DSAP 0x%02x\", dsap)));\n\t\t} else {\n\t\t\tif (src == NULL || dst == NULL)\n\t\t\t\tND_PRINT((ndo, \"%s > %s \",\n                                        tok2str(llc_values, \"Unknown SSAP 0x%02x\", ssap),\n\t\t\t\t\ttok2str(llc_values, \"Unknown DSAP 0x%02x\", dsap)));\n\t\t\telse\n\t\t\t\tND_PRINT((ndo, \"%s %s > %s %s \",\n\t\t\t\t\t(src->addr_string)(ndo, src->addr),\n                                        tok2str(llc_values, \"Unknown SSAP 0x%02x\", ssap),\n\t\t\t\t\t(dst->addr_string)(ndo, dst->addr),\n\t\t\t\t\ttok2str(llc_values, \"Unknown DSAP 0x%02x\", dsap)));\n\t\t}\n\t}\n\n\tif (is_u) {\n\t\tND_PRINT((ndo, \"Unnumbered, %s, Flags [%s], length %u\",\n                       tok2str(llc_cmd_values, \"%02x\", LLC_U_CMD(control)),\n                       tok2str(llc_flag_values,\"?\",(ssap_field & LLC_GSAP) | (control & LLC_U_POLL)),\n                       length + hdrlen));\n\n\t\tif ((control & ~LLC_U_POLL) == LLC_XID) {\n\t\t\tif (length == 0) {\n\t\t\t\t/*\n\t\t\t\t * XID with no payload.\n\t\t\t\t * This could, for example, be an SNA\n\t\t\t\t * \"short form\" XID.\n                                 */\n\t\t\t\treturn (hdrlen);\n\t\t\t}\n\t\t\tif (caplen < 1) {\n\t\t\t\tND_PRINT((ndo, \"[|llc]\"));\n\t\t\t\tif (caplen > 0)\n\t\t\t\t\tND_DEFAULTPRINT((const u_char *)p, caplen);\n\t\t\t\treturn (hdrlen);\n\t\t\t}\n\t\t\tif (*p == LLC_XID_FI) {\n\t\t\t\tif (caplen < 3 || length < 3) {\n\t\t\t\t\tND_PRINT((ndo, \"[|llc]\"));\n\t\t\t\t\tif (caplen > 0)\n\t\t\t\t\t\tND_DEFAULTPRINT((const u_char *)p, caplen);\n\t\t\t\t} else\n\t\t\t\t\tND_PRINT((ndo, \": %02x %02x\", p[1], p[2]));\n\t\t\t\treturn (hdrlen);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif ((control & LLC_S_FMT) == LLC_S_FMT) {\n\t\t\tND_PRINT((ndo, \"Supervisory, %s, rcv seq %u, Flags [%s], length %u\",\n\t\t\t\ttok2str(llc_supervisory_values,\"?\",LLC_S_CMD(control)),\n\t\t\t\tLLC_IS_NR(control),\n\t\t\t\ttok2str(llc_flag_values,\"?\",(ssap_field & LLC_GSAP) | (control & LLC_IS_POLL)),\n                                length + hdrlen));\n\t\t\treturn (hdrlen);\t/* no payload to print */\n\t\t} else {\n\t\t\tND_PRINT((ndo, \"Information, send seq %u, rcv seq %u, Flags [%s], length %u\",\n\t\t\t\tLLC_I_NS(control),\n\t\t\t\tLLC_IS_NR(control),\n\t\t\t\ttok2str(llc_flag_values,\"?\",(ssap_field & LLC_GSAP) | (control & LLC_IS_POLL)),\n                                length + hdrlen));\n\t\t}\n\t}\n\treturn (-hdrlen);\n}\n", "target": 1, "idx": 181125}
{"func": "void AutocompleteProvider::AddProviderInfo(\n    ProvidersInfo* provider_info) const {\n}\n", "target": 1, "idx": 184473}
{"func": " BaseRenderingContext2D::BaseRenderingContext2D()\n    : clip_antialiasing_(kNotAntiAliased) {\n   state_stack_.push_back(CanvasRenderingContext2DState::Create());\n }\n", "target": 1, "idx": 186881}
{"func": "bt_status_t btif_storage_add_bonded_device(bt_bdaddr_t *remote_bd_addr,\n                                           LINK_KEY link_key,\n uint8_t key_type,\n uint8_t pin_length)\n{\n bdstr_t bdstr;\n    bdaddr_to_string(remote_bd_addr, bdstr, sizeof(bdstr));\n\n     int ret = btif_config_set_int(bdstr, \"LinkKeyType\", (int)key_type);\n     ret &= btif_config_set_int(bdstr, \"PinLength\", (int)pin_length);\n     ret &= btif_config_set_bin(bdstr, \"LinkKey\", link_key, sizeof(LINK_KEY));\n     /* write bonded info immediately */\n     btif_config_flush();\n     return ret ? BT_STATUS_SUCCESS : BT_STATUS_FAIL;\n}\n", "target": 1, "idx": 187576}
{"func": "GF_Err grpl_dump(GF_Box *a, FILE * trace)\n{\n\tgf_isom_box_dump_start(a, \"GroupListBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"GroupListBox\", a, trace);\n\treturn GF_OK;\n}\n", "target": 0, "idx": 80753}
{"func": "static int bin_trycatch(RCore *core, int mode) {\n\tRBinFile *bf = r_bin_cur (core->bin);\n\tRListIter *iter;\n\tRBinTrycatch *tc;\n\tRList *trycatch = r_bin_file_get_trycatch (bf);\n\tint idx = 0;\n\tr_list_foreach (trycatch, iter, tc) {\n\t\tr_cons_printf (\"f try.%d.%\"PFMT64x\".from=0x%08\"PFMT64x\"\\n\", idx, tc->source, tc->from);\n\t\tr_cons_printf (\"f try.%d.%\"PFMT64x\".to=0x%08\"PFMT64x\"\\n\", idx, tc->source, tc->to);\n\t\tr_cons_printf (\"f try.%d.%\"PFMT64x\".catch=0x%08\"PFMT64x\"\\n\", idx, tc->source, tc->handler);\n\t\tidx++;\n\t}\n\treturn true;\n}\n", "target": 0, "idx": 96617}
{"func": "void WebProcessProxy::addExistingWebPage(WebPageProxy* webPage, uint64_t pageID)\n{\n     m_pageMap.set(pageID, webPage);\n     globalPageMap().set(pageID, webPage);\n #if PLATFORM(MAC)\n    if (pageIsProcessSuppressible(webPage));\n         m_processSuppressiblePages.add(pageID);\n     updateProcessSuppressionState();\n #endif\n}\n", "target": 1, "idx": 184482}
{"func": "create_filesystem_object(struct archive_write_disk *a)\n{\n\t/* Create the entry. */\n \tconst char *linkname;\n \tmode_t final_mode, mode;\n \tint r;\n \n \t/* We identify hard/symlinks according to the link names. */\n \t/* Since link(2) and symlink(2) don't handle modes, we're done here. */\n\tlinkname = archive_entry_hardlink(a->entry);\n\tif (linkname != NULL) {\n #if !HAVE_LINK\n \t\treturn (EPERM);\n #else\n \t\tr = link(linkname, a->name) ? errno : 0;\n \t\t/*\n \t\t * New cpio and pax formats allow hardlink entries\n\t\t * to carry data, so we may have to open the file\n\t\t * for hardlink entries.\n\t\t *\n\t\t * If the hardlink was successfully created and\n\t\t * the archive doesn't have carry data for it,\n\t\t * consider it to be non-authoritative for meta data.\n\t\t * This is consistent with GNU tar and BSD pax.\n\t\t * If the hardlink does carry data, let the last\n\t\t * archive entry decide ownership.\n\t\t */\n\t\tif (r == 0 && a->filesize <= 0) {\n\t\t\ta->todo = 0;\n\t\t\ta->deferred = 0;\n\t\t} else if (r == 0 && a->filesize > 0) {\n\t\t\ta->fd = open(a->name,\n\t\t\t\t     O_WRONLY | O_TRUNC | O_BINARY | O_CLOEXEC);\n\t\t\t__archive_ensure_cloexec_flag(a->fd);\n\t\t\tif (a->fd < 0)\n\t\t\t\tr = errno;\n\t\t}\n\t\treturn (r);\n#endif\n\t}\n\tlinkname = archive_entry_symlink(a->entry);\n\tif (linkname != NULL) {\n#if HAVE_SYMLINK\n\t\treturn symlink(linkname, a->name) ? errno : 0;\n#else\n\t\treturn (EPERM);\n#endif\n\t}\n\n\t/*\n\t * The remaining system calls all set permissions, so let's\n\t * try to take advantage of that to avoid an extra chmod()\n\t * call.  (Recall that umask is set to zero right now!)\n\t */\n\n\t/* Mode we want for the final restored object (w/o file type bits). */\n\tfinal_mode = a->mode & 07777;\n\t/*\n\t * The mode that will actually be restored in this step.  Note\n\t * that SUID, SGID, etc, require additional work to ensure\n\t * security, so we never restore them at this point.\n\t */\n\tmode = final_mode & 0777 & ~a->user_umask;\n\n\tswitch (a->mode & AE_IFMT) {\n\tdefault:\n\t\t/* POSIX requires that we fall through here. */\n\t\t/* FALLTHROUGH */\n\tcase AE_IFREG:\n\t\ta->fd = open(a->name,\n\t\t    O_WRONLY | O_CREAT | O_EXCL | O_BINARY | O_CLOEXEC, mode);\n\t\t__archive_ensure_cloexec_flag(a->fd);\n\t\tr = (a->fd < 0);\n\t\tbreak;\n\tcase AE_IFCHR:\n#ifdef HAVE_MKNOD\n\t\t/* Note: we use AE_IFCHR for the case label, and\n\t\t * S_IFCHR for the mknod() call.  This is correct.  */\n\t\tr = mknod(a->name, mode | S_IFCHR,\n\t\t    archive_entry_rdev(a->entry));\n\t\tbreak;\n#else\n\t\t/* TODO: Find a better way to warn about our inability\n\t\t * to restore a char device node. */\n\t\treturn (EINVAL);\n#endif /* HAVE_MKNOD */\n\tcase AE_IFBLK:\n#ifdef HAVE_MKNOD\n\t\tr = mknod(a->name, mode | S_IFBLK,\n\t\t    archive_entry_rdev(a->entry));\n\t\tbreak;\n#else\n\t\t/* TODO: Find a better way to warn about our inability\n\t\t * to restore a block device node. */\n\t\treturn (EINVAL);\n#endif /* HAVE_MKNOD */\n\tcase AE_IFDIR:\n\t\tmode = (mode | MINIMUM_DIR_MODE) & MAXIMUM_DIR_MODE;\n\t\tr = mkdir(a->name, mode);\n\t\tif (r == 0) {\n\t\t\t/* Defer setting dir times. */\n\t\t\ta->deferred |= (a->todo & TODO_TIMES);\n\t\t\ta->todo &= ~TODO_TIMES;\n\t\t\t/* Never use an immediate chmod(). */\n\t\t\t/* We can't avoid the chmod() entirely if EXTRACT_PERM\n\t\t\t * because of SysV SGID inheritance. */\n\t\t\tif ((mode != final_mode)\n\t\t\t    || (a->flags & ARCHIVE_EXTRACT_PERM))\n\t\t\t\ta->deferred |= (a->todo & TODO_MODE);\n\t\t\ta->todo &= ~TODO_MODE;\n\t\t}\n\t\tbreak;\n\tcase AE_IFIFO:\n#ifdef HAVE_MKFIFO\n\t\tr = mkfifo(a->name, mode);\n\t\tbreak;\n#else\n\t\t/* TODO: Find a better way to warn about our inability\n\t\t * to restore a fifo. */\n\t\treturn (EINVAL);\n#endif /* HAVE_MKFIFO */\n\t}\n\n\t/* All the system calls above set errno on failure. */\n\tif (r)\n\t\treturn (errno);\n\n\t/* If we managed to set the final mode, we've avoided a chmod(). */\n\tif (mode == final_mode)\n\t\ta->todo &= ~TODO_MODE;\n\treturn (0);\n}\n", "target": 1, "idx": 180309}
{"func": "int32_t WriteEntireBuffer(PP_Instance instance,\n                          pp::FileIO* file_io,\n                          int32_t offset,\n                          const std::string& data,\n                          CallbackType callback_type) {\n  TestCompletionCallback callback(instance, callback_type);\n  int32_t write_offset = offset;\n  const char* buf = data.c_str();\n  int32_t size = static_cast<int32_t>(data.size());\n\n  while (write_offset < offset + size) {\n    callback.WaitForResult(file_io->Write(write_offset,\n                                          &buf[write_offset - offset],\n                                          size - write_offset + offset,\n                                          callback.GetCallback()));\n    if (callback.result() < 0)\n      return callback.result();\n    if (callback.result() == 0)\n      return PP_ERROR_FAILED;\n    write_offset += callback.result();\n  }\n\n  return PP_OK;\n}\n", "target": 0, "idx": 169643}
{"func": "void WallpaperManager::OnWallpaperDecoded(\n    const AccountId& account_id,\n    const wallpaper::WallpaperInfo& info,\n    bool update_wallpaper,\n    MovableOnDestroyCallbackHolder on_finish,\n    std::unique_ptr<user_manager::UserImage> user_image) {\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n  TRACE_EVENT_ASYNC_END0(\"ui\", \"LoadAndDecodeWallpaper\", this);\n\n  if (user_image->image().isNull()) {\n    wallpaper::WallpaperInfo default_info(\n         \"\", wallpaper::WALLPAPER_LAYOUT_CENTER_CROPPED, wallpaper::DEFAULT,\n         base::Time::Now().LocalMidnight());\n     SetUserWallpaperInfo(account_id, default_info, true);\n    if (update_wallpaper)\n      DoSetDefaultWallpaper(account_id, std::move(on_finish));\n     return;\n   }\n \n  wallpaper_cache_[account_id].second = user_image->image();\n\n  if (update_wallpaper)\n    SetWallpaper(user_image->image(), info);\n}\n", "target": 1, "idx": 185846}
{"func": "int BackendImpl::CheckAllEntries() {\n  int num_dirty = 0;\n  int num_entries = 0;\n  DCHECK(mask_ < std::numeric_limits<uint32_t>::max());\n  for (unsigned int i = 0; i <= mask_; i++) {\n    Addr address(data_->table[i]);\n    if (!address.is_initialized())\n      continue;\n    for (;;) {\n      scoped_refptr<EntryImpl> cache_entry;\n      int ret = NewEntry(address, &cache_entry);\n      if (ret) {\n        STRESS_NOTREACHED();\n        return ret;\n      }\n\n      if (cache_entry->dirty())\n        num_dirty++;\n      else if (CheckEntry(cache_entry.get()))\n        num_entries++;\n      else\n        return ERR_INVALID_ENTRY;\n\n      DCHECK_EQ(i, cache_entry->entry()->Data()->hash & mask_);\n      address.set_value(cache_entry->GetNextAddress());\n      if (!address.is_initialized())\n        break;\n    }\n  }\n\n  Trace(\"CheckAllEntries End\");\n  if (num_entries + num_dirty != data_->header.num_entries) {\n    LOG(ERROR) << \"Number of entries \" << num_entries << \" \" << num_dirty <<\n                  \" \" << data_->header.num_entries;\n    DCHECK_LT(num_entries, data_->header.num_entries);\n    return ERR_NUM_ENTRIES_MISMATCH;\n  }\n\n  return num_dirty;\n}\n", "target": 0, "idx": 160007}
{"func": "error::Error GLES2DecoderPassthroughImpl::DoBeginQueryEXT(\n    GLenum target,\n    GLuint id,\n    int32_t sync_shm_id,\n    uint32_t sync_shm_offset) {\n  GLuint service_id = GetQueryServiceID(id, &query_id_map_);\n  QueryInfo* query_info = &query_info_map_[service_id];\n\n  scoped_refptr<gpu::Buffer> buffer = GetSharedMemoryBuffer(sync_shm_id);\n  if (!buffer)\n    return error::kInvalidArguments;\n  QuerySync* sync = static_cast<QuerySync*>(\n      buffer->GetDataAddress(sync_shm_offset, sizeof(QuerySync)));\n   if (!sync)\n     return error::kOutOfBounds;\n \n   if (IsEmulatedQueryTarget(target)) {\n     if (active_queries_.find(target) != active_queries_.end()) {\n       InsertError(GL_INVALID_OPERATION, \"Query already active on target.\");\n      return error::kNoError;\n    }\n\n    if (id == 0) {\n      InsertError(GL_INVALID_OPERATION, \"Query id is 0.\");\n      return error::kNoError;\n    }\n\n    if (query_info->type != GL_NONE && query_info->type != target) {\n      InsertError(GL_INVALID_OPERATION,\n                  \"Query type does not match the target.\");\n      return error::kNoError;\n    }\n  } else {\n    CheckErrorCallbackState();\n\n    api()->glBeginQueryFn(target, service_id);\n\n    if (CheckErrorCallbackState()) {\n      return error::kNoError;\n    }\n  }\n\n  query_info->type = target;\n\n  RemovePendingQuery(service_id);\n\n  ActiveQuery query;\n  query.service_id = service_id;\n  query.shm = std::move(buffer);\n  query.sync = sync;\n  active_queries_[target] = std::move(query);\n\n  return error::kNoError;\n}\n", "target": 1, "idx": 186501}
{"func": "static int search_old_relocation(struct reloc_struct_t *reloc_table, ut32 addr_to_patch, int n_reloc) {\n \tint i;\n \tfor (i = 0; i < n_reloc; i++) {\n \t\tif (addr_to_patch == reloc_table[i].data_offset) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n", "target": 1, "idx": 181537}
{"func": "static int do_new_mount(struct path *path, const char *fstype, int flags,\n\t\t\tint mnt_flags, const char *name, void *data)\n{\n\tstruct file_system_type *type;\n\tstruct user_namespace *user_ns = current->nsproxy->mnt_ns->user_ns;\n\tstruct vfsmount *mnt;\n\tint err;\n\n\tif (!fstype)\n\t\treturn -EINVAL;\n\n\ttype = get_fs_type(fstype);\n\tif (!type)\n\t\treturn -ENODEV;\n\n\tif (user_ns != &init_user_ns) {\n\t\tif (!(type->fs_flags & FS_USERNS_MOUNT)) {\n\t\t\tput_filesystem(type);\n\t\t\treturn -EPERM;\n\t\t}\n\t\t/* Only in special cases allow devices from mounts\n\t\t * created outside the initial user namespace.\n \t\t */\n \t\tif (!(type->fs_flags & FS_USERNS_DEV_MOUNT)) {\n \t\t\tflags |= MS_NODEV;\n\t\t\tmnt_flags |= MNT_NODEV;\n \t\t}\n \t}\n \n\tmnt = vfs_kern_mount(type, flags, name, data);\n\tif (!IS_ERR(mnt) && (type->fs_flags & FS_HAS_SUBTYPE) &&\n\t    !mnt->mnt_sb->s_subtype)\n\t\tmnt = fs_set_subtype(mnt, fstype);\n\n\tput_filesystem(type);\n\tif (IS_ERR(mnt))\n\t\treturn PTR_ERR(mnt);\n\n\terr = do_add_mount(real_mount(mnt), path, mnt_flags);\n\tif (err)\n\t\tmntput(mnt);\n\treturn err;\n}\n", "target": 1, "idx": 179453}
{"func": " static uint32_t readU32(const uint8_t* data, size_t offset) {\n    return data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3];\n }\n", "target": 1, "idx": 187989}
{"func": "PassRefPtrWillBeRawPtr<DocumentParser> Document::implicitOpen(ParserSynchronizationPolicy parserSyncPolicy)\n{\n    detachParser();\n\n    removeChildren();\n    ASSERT(!m_focusedElement);\n\n    setCompatibilityMode(NoQuirksMode);\n\n    if (!threadedParsingEnabledForTesting())\n        parserSyncPolicy = ForceSynchronousParsing;\n\n    m_parserSyncPolicy = parserSyncPolicy;\n    m_parser = createParser();\n    setParsingState(Parsing);\n    setReadyState(Loading);\n\n    return m_parser;\n}\n", "target": 0, "idx": 135271}
{"func": "int user_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct user_key_payload *upayload, *zap;\n\tsize_t datalen = prep->datalen;\n\tint ret;\n\n\tret = -EINVAL;\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\tgoto error;\n\n\t/* construct a replacement payload */\n\tret = -ENOMEM;\n\tupayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);\n\tif (!upayload)\n\t\tgoto error;\n\n\tupayload->datalen = datalen;\n\tmemcpy(upayload->data, prep->data, datalen);\n\n\t/* check the quota and attach the new data */\n\tzap = upayload;\n\n\tret = key_payload_reserve(key, datalen);\n \n \tif (ret == 0) {\n \t\t/* attach the new data, displacing the old */\n\t\tzap = key->payload.data[0];\n \t\trcu_assign_keypointer(key, upayload);\n \t\tkey->expiry = 0;\n \t}\n\n\tif (zap)\n\t\tkfree_rcu(zap, rcu);\n\nerror:\n\treturn ret;\n}\n", "target": 1, "idx": 180707}
{"func": "static void svc_rdma_destroy_maps(struct svcxprt_rdma *xprt)\n{\n\twhile (!list_empty(&xprt->sc_maps)) {\n\t\tstruct svc_rdma_req_map *map;\n\t\tmap = list_first_entry(&xprt->sc_maps,\n\t\t\t\t       struct svc_rdma_req_map, free);\n\t\tlist_del(&map->free);\n\t\tkfree(map);\n\t}\n}\n", "target": 1, "idx": 181352}
{"func": "void flush_tlb_mm_range(struct mm_struct *mm, unsigned long start,\n\t\t\t\tunsigned long end, unsigned long vmflag)\n{\n\tunsigned long addr;\n\t/* do a global flush by default */\n \tunsigned long base_pages_to_flush = TLB_FLUSH_ALL;\n \n \tpreempt_disable();\n\tif (current->active_mm != mm)\n \t\tgoto out;\n \n \tif (!current->mm) {\n \t\tleave_mm(smp_processor_id());\n \t\tgoto out;\n \t}\n \n \tif ((end != TLB_FLUSH_ALL) && !(vmflag & VM_HUGETLB))\n \t\tbase_pages_to_flush = (end - start) >> PAGE_SHIFT;\n \n \tif (base_pages_to_flush > tlb_single_page_flush_ceiling) {\n \t\tbase_pages_to_flush = TLB_FLUSH_ALL;\n \t\tcount_vm_tlb_event(NR_TLB_LOCAL_FLUSH_ALL);\n\t\tlocal_flush_tlb();\n\t} else {\n\t\t/* flush range by one by one 'invlpg' */\n\t\tfor (addr = start; addr < end;\taddr += PAGE_SIZE) {\n\t\t\tcount_vm_tlb_event(NR_TLB_LOCAL_FLUSH_ONE);\n\t\t\t__flush_tlb_single(addr);\n\t\t}\n\t}\n\ttrace_tlb_flush(TLB_LOCAL_MM_SHOOTDOWN, base_pages_to_flush);\nout:\n\tif (base_pages_to_flush == TLB_FLUSH_ALL) {\n\t\tstart = 0UL;\n\t\tend = TLB_FLUSH_ALL;\n\t}\n\tif (cpumask_any_but(mm_cpumask(mm), smp_processor_id()) < nr_cpu_ids)\n\t\tflush_tlb_others(mm_cpumask(mm), mm, start, end);\n\tpreempt_enable();\n}\n", "target": 1, "idx": 180612}
{"func": " void SSLManager::OnSSLCertificateError(\n    base::WeakPtr<SSLErrorHandler::Delegate> delegate,\n     const content::GlobalRequestID& id,\n     const ResourceType::Type resource_type,\n     const GURL& url,\n    int render_process_id,\n    int render_view_id,\n    const net::SSLInfo& ssl_info,\n    bool fatal) {\n  DCHECK(delegate);\n  DVLOG(1) << \"OnSSLCertificateError() cert_error: \"\n           << net::MapCertStatusToNetError(ssl_info.cert_status)\n           << \" id: \" << id.child_id << \",\" << id.request_id\n           << \" resource_type: \" << resource_type\n           << \" url: \" << url.spec()\n           << \" render_process_id: \" << render_process_id\n           << \" render_view_id: \" << render_view_id\n           << \" cert_status: \" << std::hex << ssl_info.cert_status;\n\n  BrowserThread::PostTask(\n      BrowserThread::UI, FROM_HERE,\n      base::Bind(&SSLCertErrorHandler::Dispatch,\n                 new SSLCertErrorHandler(delegate,\n                                         id,\n                                         resource_type,\n                                         url,\n                                         render_process_id,\n                                         render_view_id,\n                                         ssl_info,\n                                         fatal)));\n}\n", "target": 1, "idx": 184688}
{"func": "static void efx_fill_test(unsigned int test_index,\n\t\t\t  struct ethtool_string *strings, u64 *data,\n\t\t\t  int *test, const char *unit_format, int unit_id,\n\t\t\t  const char *test_format, const char *test_id)\n{\n\tstruct ethtool_string unit_str, test_str;\n\n\t/* Fill data value, if applicable */\n\tif (data)\n\t\tdata[test_index] = *test;\n\n\t/* Fill string, if applicable */\n\tif (strings) {\n\t\tif (strchr(unit_format, '%'))\n\t\t\tsnprintf(unit_str.name, sizeof(unit_str.name),\n\t\t\t\t unit_format, unit_id);\n\t\telse\n\t\t\tstrcpy(unit_str.name, unit_format);\n\t\tsnprintf(test_str.name, sizeof(test_str.name),\n\t\t\t test_format, test_id);\n\t\tsnprintf(strings[test_index].name,\n\t\t\t sizeof(strings[test_index].name),\n\t\t\t \"%-6s %-24s\", unit_str.name, test_str.name);\n\t}\n}\n", "target": 0, "idx": 19471}
{"func": "void HTMLInputElement::setSize(unsigned size)\n{\n    setAttribute(sizeAttr, String::number(size));\n}\n", "target": 0, "idx": 121258}
{"func": "void __detach_mounts(struct dentry *dentry)\n{\n\tstruct mountpoint *mp;\n\tstruct mount *mnt;\n\n\tnamespace_lock();\n\tmp = lookup_mountpoint(dentry);\n\tif (IS_ERR_OR_NULL(mp))\n\t\tgoto out_unlock;\n\n\tlock_mount_hash();\n\twhile (!hlist_empty(&mp->m_list)) {\n\t\tmnt = hlist_entry(mp->m_list.first, struct mount, mnt_mp_list);\n\t\tif (mnt->mnt.mnt_flags & MNT_UMOUNT) {\n\t\t\tstruct mount *p, *tmp;\n\t\t\tlist_for_each_entry_safe(p, tmp, &mnt->mnt_mounts,  mnt_child) {\n\t\t\t\thlist_add_head(&p->mnt_umount.s_list, &unmounted);\n \t\t\t\tumount_mnt(p);\n \t\t\t}\n \t\t}\n\t\telse umount_tree(mnt, 0);\n \t}\n \tunlock_mount_hash();\n \tput_mountpoint(mp);\nout_unlock:\n\tnamespace_unlock();\n}\n", "target": 1, "idx": 180736}
{"func": "static int filter_frame(AVFilterLink *inlink, AVFrame *in)\n{\n    AVFilterContext *ctx = inlink->dst;\n    LutContext *s = ctx->priv;\n    AVFilterLink *outlink = ctx->outputs[0];\n    AVFrame *out;\n    uint8_t *inrow, *outrow, *inrow0, *outrow0;\n    int i, j, plane, direct = 0;\n\n    if (av_frame_is_writable(in)) {\n        direct = 1;\n        out = in;\n    } else {\n        out = ff_get_video_buffer(outlink, outlink->w, outlink->h);\n        if (!out) {\n            av_frame_free(&in);\n            return AVERROR(ENOMEM);\n        }\n        av_frame_copy_props(out, in);\n    }\n\n    if (s->is_rgb) {\n        /* packed */\n        inrow0  = in ->data[0];\n        outrow0 = out->data[0];\n\n        for (i = 0; i < in->height; i ++) {\n            int w = inlink->w;\n            const uint8_t (*tab)[256] = (const uint8_t (*)[256])s->lut;\n            inrow  = inrow0;\n            outrow = outrow0;\n            for (j = 0; j < w; j++) {\n                switch (s->step) {\n                case 4:  outrow[3] = tab[3][inrow[3]]; // Fall-through\n                case 3:  outrow[2] = tab[2][inrow[2]]; // Fall-through\n                case 2:  outrow[1] = tab[1][inrow[1]]; // Fall-through\n                default: outrow[0] = tab[0][inrow[0]];\n                }\n                outrow += s->step;\n                inrow  += s->step;\n            }\n            inrow0  += in ->linesize[0];\n            outrow0 += out->linesize[0];\n         }\n     } else {\n         /* planar */\n        for (plane = 0; plane < 4 && in->data[plane]; plane++) {\n             int vsub = plane == 1 || plane == 2 ? s->vsub : 0;\n             int hsub = plane == 1 || plane == 2 ? s->hsub : 0;\n             int h = FF_CEIL_RSHIFT(inlink->h, vsub);\n            int w = FF_CEIL_RSHIFT(inlink->w, hsub);\n\n            inrow  = in ->data[plane];\n            outrow = out->data[plane];\n\n            for (i = 0; i < h; i++) {\n                const uint8_t *tab = s->lut[plane];\n                for (j = 0; j < w; j++)\n                    outrow[j] = tab[inrow[j]];\n                inrow  += in ->linesize[plane];\n                outrow += out->linesize[plane];\n            }\n        }\n    }\n\n    if (!direct)\n        av_frame_free(&in);\n\n    return ff_filter_frame(outlink, out);\n}\n", "target": 1, "idx": 179176}
{"func": "void RootWindowHostWin::SetCapture() {\n  if (!has_capture_) {\n    has_capture_ = true;\n    ::SetCapture(hwnd());\n  }\n}\n", "target": 0, "idx": 110984}
{"func": " TemplateURLRef::SearchTermsArgs::ContextualSearchParams::ContextualSearchParams(\n     int version,\n     const std::string& selection,\n     const std::string& base_page_url,\n    int now_on_tap_version)\n     : version(version),\n       start(base::string16::npos),\n       end(base::string16::npos),\n       selection(selection),\n       base_page_url(base_page_url),\n      now_on_tap_version(now_on_tap_version) {}\n", "target": 1, "idx": 185349}
{"func": "void Document::setCompatibilityMode(CompatibilityMode mode)\n{\n    if (m_compatibilityModeLocked || mode == m_compatibilityMode)\n        return;\n    bool wasInQuirksMode = inQuirksMode();\n    m_compatibilityMode = mode;\n    selectorQueryCache()->invalidate();\n    if (inQuirksMode() != wasInQuirksMode) {\n        m_styleSheetCollection->clearPageUserSheet();\n        m_styleSheetCollection->invalidateInjectedStyleSheetCache();\n    }\n}\n", "target": 0, "idx": 112552}
{"func": "BOOL license_read_scope_list(wStream* s, SCOPE_LIST* scopeList)\n{\n\tUINT32 i;\n\tUINT32 scopeCount;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n \n \tStream_Read_UINT32(s, scopeCount); /* ScopeCount (4 bytes) */\n \n \tscopeList->count = scopeCount;\n \tscopeList->array = (LICENSE_BLOB*) malloc(sizeof(LICENSE_BLOB) * scopeCount);\n \n\t/* ScopeArray */\n\tfor (i = 0; i < scopeCount; i++)\n\t{\n\t\tscopeList->array[i].type = BB_SCOPE_BLOB;\n\n\t\tif (!license_read_binary_blob(s, &scopeList->array[i]))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n", "target": 1, "idx": 179612}
{"func": "_exsltDateAdd (exsltDateValPtr dt, exsltDateValPtr dur)\n{\n    exsltDateValPtr ret;\n    long carry, tempdays, temp;\n    exsltDateValDatePtr r, d;\n    exsltDateValDurationPtr u;\n\n    if ((dt == NULL) || (dur == NULL))\n        return NULL;\n\n    ret = exsltDateCreateDate(dt->type);\n    if (ret == NULL)\n        return NULL;\n\n    r = &(ret->value.date);\n     d = &(dt->value.date);\n     u = &(dur->value.dur);\n \n    /* normalization */\n    if (d->mon == 0)\n        d->mon = 1;\n     /* normalize for time zone offset */\n     u->sec -= (d->tzo * 60);\t/* changed from + to - (bug 153000) */\n     d->tzo = 0;\n \n    /* normalization */\n    if (d->day == 0)\n        d->day = 1;\n     /* month */\n     carry  = d->mon + u->mon;\n     r->mon = (unsigned int)MODULO_RANGE(carry, 1, 13);\n    carry  = (long)FQUOTIENT_RANGE(carry, 1, 13);\n\n    /* year (may be modified later) */\n    r->year = d->year + carry;\n    if (r->year == 0) {\n        if (d->year > 0)\n            r->year--;\n        else\n            r->year++;\n    }\n\n    /* time zone */\n    r->tzo     = d->tzo;\n    r->tz_flag = d->tz_flag;\n\n    /* seconds */\n    r->sec = d->sec + u->sec;\n    carry  = (long)FQUOTIENT((long)r->sec, 60);\n    if (r->sec != 0.0) {\n        r->sec = MODULO(r->sec, 60.0);\n    }\n\n    /* minute */\n    carry += d->min;\n    r->min = (unsigned int)MODULO(carry, 60);\n    carry  = (long)FQUOTIENT(carry, 60);\n\n    /* hours */\n    carry  += d->hour;\n    r->hour = (unsigned int)MODULO(carry, 24);\n    carry   = (long)FQUOTIENT(carry, 24);\n\n    /*\n     * days\n     * Note we use tempdays because the temporary values may need more\n     * than 5 bits\n     */\n    if ((VALID_YEAR(r->year)) && (VALID_MONTH(r->mon)) &&\n                  (d->day > MAX_DAYINMONTH(r->year, r->mon)))\n        tempdays = MAX_DAYINMONTH(r->year, r->mon);\n    else if (d->day < 1)\n        tempdays = 1;\n    else\n        tempdays = d->day;\n\n    tempdays += u->day + carry;\n\n    while (1) {\n        if (tempdays < 1) {\n            long tmon = (long)MODULO_RANGE((int)r->mon-1, 1, 13);\n            long tyr  = r->year + (long)FQUOTIENT_RANGE((int)r->mon-1, 1, 13);\n            if (tyr == 0)\n                tyr--;\n\t    /*\n\t     * Coverity detected an overrun in daysInMonth\n\t     * of size 12 at position 12 with index variable \"((r)->mon - 1)\"\n\t     */\n\t    if (tmon < 0)\n\t        tmon = 0;\n\t    if (tmon > 12)\n\t        tmon = 12;\n            tempdays += MAX_DAYINMONTH(tyr, tmon);\n            carry = -1;\n        } else if (tempdays > (long)MAX_DAYINMONTH(r->year, r->mon)) {\n            tempdays = tempdays - MAX_DAYINMONTH(r->year, r->mon);\n            carry = 1;\n        } else\n            break;\n\n        temp = r->mon + carry;\n        r->mon = (unsigned int)MODULO_RANGE(temp, 1, 13);\n        r->year = r->year + (long)FQUOTIENT_RANGE(temp, 1, 13);\n        if (r->year == 0) {\n            if (temp < 1)\n                r->year--;\n            else\n                r->year++;\n\t}\n    }\n\n    r->day = tempdays;\n\n    /*\n     * adjust the date/time type to the date values\n     */\n    if (ret->type != XS_DATETIME) {\n        if ((r->hour) || (r->min) || (r->sec))\n            ret->type = XS_DATETIME;\n        else if (ret->type != XS_DATE) {\n            if (r->day != 1)\n                ret->type = XS_DATE;\n            else if ((ret->type != XS_GYEARMONTH) && (r->mon != 1))\n                ret->type = XS_GYEARMONTH;\n        }\n    }\n\n    return ret;\n}\n", "target": 1, "idx": 187311}
{"func": " void BufferQueueConsumer::dump(String8& result, const char* prefix) const {\n    mCore->dump(result, prefix);\n }\n", "target": 1, "idx": 188254}
{"func": "WORD32 ih264d_parse_islice_data_cavlc(dec_struct_t * ps_dec,\n dec_slice_params_t * ps_slice,\n                                      UWORD16 u2_first_mb_in_slice)\n{\n    UWORD8 uc_more_data_flag;\n    UWORD8 u1_num_mbs, u1_mb_idx;\n dec_mb_info_t *ps_cur_mb_info;\n deblk_mb_t *ps_cur_deblk_mb;\n dec_bit_stream_t * const ps_bitstrm = ps_dec->ps_bitstrm;\n    UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;\n    UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;\n    UWORD16 i2_pic_wdin_mbs = ps_dec->u2_frm_wd_in_mbs;\n    WORD16 i2_cur_mb_addr;\n    UWORD8 u1_mbaff;\n    UWORD8 u1_num_mbs_next, u1_end_of_row, u1_tfr_n_mb;\n    WORD32 ret = OK;\n\n    ps_dec->u1_qp = ps_slice->u1_slice_qp;\n    ih264d_update_qp(ps_dec, 0);\n    u1_mbaff = ps_slice->u1_mbaff_frame_flag;\n\n /* initializations */\n    u1_mb_idx = ps_dec->u1_mb_idx;\n    u1_num_mbs = u1_mb_idx;\n\n    uc_more_data_flag = 1;\n    i2_cur_mb_addr = u2_first_mb_in_slice << u1_mbaff;\n\n do\n {\n        UWORD8 u1_mb_type;\n\n        ps_dec->pv_prev_mb_parse_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;\n\n if(i2_cur_mb_addr > ps_dec->ps_cur_sps->u2_max_mb_addr)\n {\n            ret = ERROR_MB_ADDRESS_T;\n break;\n }\n\n        ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs;\n        ps_dec->u4_num_mbs_cur_nmb = u1_num_mbs;\n        ps_dec->u4_num_pmbair = (u1_num_mbs >> u1_mbaff);\n\n        ps_cur_mb_info->u1_end_of_slice = 0;\n\n /***************************************************************/\n /* Get the required information for decoding of MB             */\n /* mb_x, mb_y , neighbour availablity,                         */\n /***************************************************************/\n        ps_dec->pf_get_mb_info(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, 0);\n\n /***************************************************************/\n /* Set the deblocking parameters for this MB                   */\n /***************************************************************/\n        ps_cur_deblk_mb = ps_dec->ps_deblk_mbn + u1_num_mbs;\n\n if(ps_dec->u4_app_disable_deblk_frm == 0)\n            ih264d_set_deblocking_parameters(ps_cur_deblk_mb, ps_slice,\n                                             ps_dec->u1_mb_ngbr_availablity,\n                                             ps_dec->u1_cur_mb_fld_dec_flag);\n\n        ps_cur_deblk_mb->u1_mb_type = ps_cur_deblk_mb->u1_mb_type | D_INTRA_MB;\n\n /**************************************************************/\n /* Macroblock Layer Begins, Decode the u1_mb_type                */\n /**************************************************************/\n {\n            UWORD32 u4_bitstream_offset = *pu4_bitstrm_ofst;\n            UWORD32 u4_word, u4_ldz, u4_temp;\n\n /***************************************************************/\n /* Find leading zeros in next 32 bits                          */\n /***************************************************************/\n            NEXTBITS_32(u4_word, u4_bitstream_offset, pu4_bitstrm_buf);\n            u4_ldz = CLZ(u4_word);\n /* Flush the ps_bitstrm */\n            u4_bitstream_offset += (u4_ldz + 1);\n /* Read the suffix from the ps_bitstrm */\n            u4_word = 0;\n if(u4_ldz)\n                GETBITS(u4_word, u4_bitstream_offset, pu4_bitstrm_buf,\n                        u4_ldz);\n *pu4_bitstrm_ofst = u4_bitstream_offset;\n            u4_temp = ((1 << u4_ldz) + u4_word - 1);\n if(u4_temp > 25)\n return ERROR_MB_TYPE;\n            u1_mb_type = u4_temp;\n\n }\n        ps_cur_mb_info->u1_mb_type = u1_mb_type;\n        COPYTHECONTEXT(\"u1_mb_type\", u1_mb_type);\n\n /**************************************************************/\n /* Parse Macroblock data                                      */\n /**************************************************************/\n if(25 == u1_mb_type)\n {\n /* I_PCM_MB */\n            ps_cur_mb_info->ps_curmb->u1_mb_type = I_PCM_MB;\n            ret = ih264d_parse_ipcm_mb(ps_dec, ps_cur_mb_info, u1_num_mbs);\n if(ret != OK)\n return ret;\n            ps_cur_deblk_mb->u1_mb_qp = 0;\n }\n else\n {\n            ret = ih264d_parse_imb_cavlc(ps_dec, ps_cur_mb_info, u1_num_mbs, u1_mb_type);\n if(ret != OK)\n return ret;\n            ps_cur_deblk_mb->u1_mb_qp = ps_dec->u1_qp;\n }\n\n\n         if(u1_mbaff)\n         {\n             ih264d_update_mbaff_left_nnz(ps_dec, ps_cur_mb_info);\n         }\n         /**************************************************************/\n         /* Get next Macroblock address                                */\n /**************************************************************/\n\n        i2_cur_mb_addr++;\n        uc_more_data_flag = MORE_RBSP_DATA(ps_bitstrm);\n\n /* Store the colocated information */\n {\n mv_pred_t *ps_mv_nmb_start = ps_dec->ps_mv_cur + (u1_num_mbs << 4);\n\n mv_pred_t s_mvPred =\n {\n { 0, 0, 0, 0 },\n { -1, -1 }, 0, 0};\n            ih264d_rep_mv_colz(ps_dec, &s_mvPred, ps_mv_nmb_start, 0,\n (UWORD8)(ps_dec->u1_cur_mb_fld_dec_flag << 1), 4,\n 4);\n }\n\n /*if num _cores is set to 3,compute bs will be done in another thread*/\n if(ps_dec->u4_num_cores < 3)\n {\n if(ps_dec->u4_app_disable_deblk_frm == 0)\n                ps_dec->pf_compute_bs(ps_dec, ps_cur_mb_info,\n (UWORD16)(u1_num_mbs >> u1_mbaff));\n }\n        u1_num_mbs++;\n\n /****************************************************************/\n /* Check for End Of Row                                         */\n /****************************************************************/\n        u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;\n        u1_end_of_row = (!u1_num_mbs_next) && (!(u1_mbaff && (u1_num_mbs & 0x01)));\n        u1_tfr_n_mb = (u1_num_mbs == ps_dec->u1_recon_mb_grp) || u1_end_of_row\n || (!uc_more_data_flag);\n        ps_cur_mb_info->u1_end_of_slice = (!uc_more_data_flag);\n\n /*H264_DEC_DEBUG_PRINT(\"Pic: %d Mb_X=%d Mb_Y=%d\",\n         ps_slice->i4_poc >> ps_slice->u1_field_pic_flag,\n         ps_dec->u2_mbx,ps_dec->u2_mby + (1 - ps_cur_mb_info->u1_topmb));\n         H264_DEC_DEBUG_PRINT(\"u1_tfr_n_mb || (!uc_more_data_flag): %d\", u1_tfr_n_mb || (!uc_more_data_flag));*/\n if(u1_tfr_n_mb || (!uc_more_data_flag))\n {\n\n if(ps_dec->u1_separate_parse)\n {\n                ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n                                     u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\n                ps_dec->ps_nmb_info +=  u1_num_mbs;\n }\n else\n {\n                ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n                                            u1_num_mbs_next, u1_tfr_n_mb,\n                                            u1_end_of_row);\n }\n            ps_dec->u2_total_mbs_coded += u1_num_mbs;\n if(u1_tfr_n_mb)\n                u1_num_mbs = 0;\n            u1_mb_idx = u1_num_mbs;\n            ps_dec->u1_mb_idx = u1_num_mbs;\n\n }\n }\n while(uc_more_data_flag);\n\n    ps_dec->u4_num_mbs_cur_nmb = 0;\n    ps_dec->ps_cur_slice->u4_mbs_in_slice = i2_cur_mb_addr\n\n - (u2_first_mb_in_slice << u1_mbaff);\n\n return ret;\n}\n", "target": 1, "idx": 188067}
{"func": "int imap_buffy_check(int check_stats)\n{\n  struct ImapData *idata = NULL;\n  struct ImapData *lastdata = NULL;\n  struct Buffy *mailbox = NULL;\n  char name[LONG_STRING];\n  char command[LONG_STRING];\n  char munged[LONG_STRING];\n  int buffies = 0;\n\n  for (mailbox = Incoming; mailbox; mailbox = mailbox->next)\n  {\n    /* Init newly-added mailboxes */\n    if (!mailbox->magic)\n    {\n      if (mx_is_imap(mailbox->path))\n        mailbox->magic = MUTT_IMAP;\n    }\n\n    if (mailbox->magic != MUTT_IMAP)\n      continue;\n\n    if (get_mailbox(mailbox->path, &idata, name, sizeof(name)) < 0)\n    {\n      mailbox->new = false;\n      continue;\n    }\n\n    /* Don't issue STATUS on the selected mailbox, it will be NOOPed or\n     * IDLEd elsewhere.\n     * idata->mailbox may be NULL for connections other than the current\n     * mailbox's, and shouldn't expand to INBOX in that case. #3216. */\n    if (idata->mailbox && (imap_mxcmp(name, idata->mailbox) == 0))\n    {\n      mailbox->new = false;\n      continue;\n    }\n\n    if (!mutt_bit_isset(idata->capabilities, IMAP4REV1) &&\n        !mutt_bit_isset(idata->capabilities, STATUS))\n    {\n      mutt_debug(2, \"Server doesn't support STATUS\\n\");\n      continue;\n    }\n\n    if (lastdata && idata != lastdata)\n    {\n      /* Send commands to previous server. Sorting the buffy list\n       * may prevent some infelicitous interleavings */\n      if (imap_exec(lastdata, NULL, IMAP_CMD_FAIL_OK | IMAP_CMD_POLL) == -1)\n        mutt_debug(1, \"#1 Error polling mailboxes\\n\");\n\n      lastdata = NULL;\n    }\n\n    if (!lastdata)\n      lastdata = idata;\n\n    imap_munge_mbox_name(idata, munged, sizeof(munged), name);\n    if (check_stats)\n    {\n      snprintf(command, sizeof(command),\n               \"STATUS %s (UIDNEXT UIDVALIDITY UNSEEN RECENT MESSAGES)\", munged);\n    }\n    else\n    {\n      snprintf(command, sizeof(command),\n               \"STATUS %s (UIDNEXT UIDVALIDITY UNSEEN RECENT)\", munged);\n    }\n\n    if (imap_exec(idata, command, IMAP_CMD_QUEUE | IMAP_CMD_POLL) < 0)\n    {\n      mutt_debug(1, \"Error queueing command\\n\");\n      return 0;\n    }\n  }\n\n  if (lastdata && (imap_exec(lastdata, NULL, IMAP_CMD_FAIL_OK | IMAP_CMD_POLL) == -1))\n  {\n    mutt_debug(1, \"#2 Error polling mailboxes\\n\");\n    return 0;\n  }\n\n  /* collect results */\n  for (mailbox = Incoming; mailbox; mailbox = mailbox->next)\n  {\n    if (mailbox->magic == MUTT_IMAP && mailbox->new)\n      buffies++;\n  }\n\n  return buffies;\n}\n", "target": 0, "idx": 79580}
{"func": "static void checkPtrmap(\n  IntegrityCk *pCheck,   /* Integrity check context */\n  Pgno iChild,           /* Child page number */\n  u8 eType,              /* Expected pointer map type */\n  Pgno iParent           /* Expected pointer map parent page number */\n){\n  int rc;\n  u8 ePtrmapType;\n  Pgno iPtrmapParent;\n\n  rc = ptrmapGet(pCheck->pBt, iChild, &ePtrmapType, &iPtrmapParent);\n  if( rc!=SQLITE_OK ){\n    if( rc==SQLITE_NOMEM || rc==SQLITE_IOERR_NOMEM ) pCheck->mallocFailed = 1;\n    checkAppendMsg(pCheck, \"Failed to read ptrmap key=%d\", iChild);\n    return;\n  }\n\n  if( ePtrmapType!=eType || iPtrmapParent!=iParent ){\n    checkAppendMsg(pCheck,\n      \"Bad ptr map entry key=%d expected=(%d,%d) got=(%d,%d)\", \n      iChild, eType, iParent, ePtrmapType, iPtrmapParent);\n  }\n}\n", "target": 0, "idx": 149063}
{"func": "void ObjectBackedNativeHandler::Router(\n    const v8::FunctionCallbackInfo<v8::Value>& args) {\n  v8::Isolate* isolate = args.GetIsolate();\n  v8::HandleScope handle_scope(isolate);\n  v8::Local<v8::Object> data = args.Data().As<v8::Object>();\n  v8::Local<v8::Context> context = isolate->GetCurrentContext();\n\n  v8::Local<v8::Value> handler_function_value;\n  v8::Local<v8::Value> feature_name_value;\n  if (!GetPrivate(context, data, kHandlerFunction, &handler_function_value) ||\n      handler_function_value->IsUndefined() ||\n      !GetPrivate(context, data, kFeatureName, &feature_name_value) ||\n      !feature_name_value->IsString()) {\n    ScriptContext* script_context =\n        ScriptContextSet::GetContextByV8Context(context);\n    console::Error(script_context ? script_context->GetRenderFrame() : nullptr,\n                   \"Extension view no longer exists\");\n    return;\n  }\n\n  if (content::WorkerThread::GetCurrentId() == 0) {\n    ScriptContext* script_context =\n        ScriptContextSet::GetContextByV8Context(context);\n    v8::Local<v8::String> feature_name_string =\n        feature_name_value->ToString(context).ToLocalChecked();\n     std::string feature_name = *v8::String::Utf8Value(feature_name_string);\n    if (script_context &&\n        !feature_name.empty() &&\n        !script_context->GetAvailability(feature_name).is_available()) {\n      return;\n     }\n   }\n  CHECK(handler_function_value->IsExternal());\n  static_cast<HandlerFunction*>(\n      handler_function_value.As<v8::External>()->Value())->Run(args);\n\n  v8::ReturnValue<v8::Value> ret = args.GetReturnValue();\n  v8::Local<v8::Value> ret_value = ret.Get();\n  if (ret_value->IsObject() && !ret_value->IsNull() &&\n      !ContextCanAccessObject(context, v8::Local<v8::Object>::Cast(ret_value),\n                              true)) {\n    NOTREACHED() << \"Insecure return value\";\n    ret.SetUndefined();\n  }\n}\n", "target": 1, "idx": 186219}
{"func": "static gboolean nbd_negotiate_continue(QIOChannel *ioc,\n                                       GIOCondition condition,\n                                       void *opaque)\n{\n    qemu_coroutine_enter(opaque);\n    return TRUE;\n}\n", "target": 1, "idx": 178624}
{"func": "string16 GetUrlWithLang(const GURL& url) {\n  return ASCIIToUTF16(google_util::AppendGoogleLocaleParam(url).spec());\n}\n", "target": 0, "idx": 116046}
{"func": "void bdt_enable(void)\n{\n    bdt_log(\"ENABLE BT\");\n if (bt_enabled) {\n\n         bdt_log(\"Bluetooth is already enabled\");\n         return;\n     }\n    status = sBtInterface->enable();\n \n     check_return_status(status);\n }\n", "target": 1, "idx": 187577}
{"func": "static void ahci_restart(IDEDMA *dma)\n{\n    AHCIDevice *ad = DO_UPCAST(AHCIDevice, dma, dma);\n    int i;\n\n    for (i = 0; i < AHCI_MAX_CMDS; i++) {\n        NCQTransferState *ncq_tfs = &ad->ncq_tfs[i];\n        if (ncq_tfs->halt) {\n            execute_ncq_command(ncq_tfs);\n        }\n    }\n}\n", "target": 0, "idx": 5878}
{"func": "static struct dentry *udf_fh_to_parent(struct super_block *sb,\n\t\t\t\t       struct fid *fid, int fh_len, int fh_type)\n{\n\tif (fh_len != 5 || fh_type != FILEID_UDF_WITH_PARENT)\n\t\treturn NULL;\n\n\treturn udf_nfs_get_inode(sb, fid->udf.parent_block,\n\t\t\t\t fid->udf.parent_partref,\n\t\t\t\t fid->udf.parent_generation);\n}\n", "target": 0, "idx": 34079}
{"func": "int xt_compat_check_entry_offsets(const void *base,\n \t\t\t\t  unsigned int target_offset,\n \t\t\t\t  unsigned int next_offset)\n {\n \tconst struct compat_xt_entry_target *t;\n \tconst char *e = base;\n \n \tif (target_offset + sizeof(*t) > next_offset)\n \t\treturn -EINVAL;\n \n\tt = (void *)(e + target_offset);\n\tif (t->u.target_size < sizeof(*t))\n\t\treturn -EINVAL;\n\n\tif (target_offset + t->u.target_size > next_offset)\n\t\treturn -EINVAL;\n\n\tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) == 0 &&\n\t    target_offset + sizeof(struct compat_xt_standard_target) != next_offset)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n", "target": 1, "idx": 180394}
{"func": "ZEND_API void zend_objects_store_del_ref_by_handle_ex(zend_object_handle handle, const zend_object_handlers *handlers TSRMLS_DC) /* {{{ */\n{\n\tstruct _store_object *obj;\n\tint failure = 0;\n\n\tif (!EG(objects_store).object_buckets) {\n\t\treturn;\n\t}\n\n\tobj = &EG(objects_store).object_buckets[handle].bucket.obj;\n\n\t/*\tMake sure we hold a reference count during the destructor call\n\t\totherwise, when the destructor ends the storage might be freed\n\t\twhen the refcount reaches 0 a second time\n\t */\n\tif (EG(objects_store).object_buckets[handle].valid) {\n\t\tif (obj->refcount == 1) {\n\t\t\tif (!EG(objects_store).object_buckets[handle].destructor_called) {\n\t\t\t\tEG(objects_store).object_buckets[handle].destructor_called = 1;\n\n\t\t\t\tif (obj->dtor) {\n\t\t\t\t\tif (handlers && !obj->handlers) {\n\t\t\t\t\t\tobj->handlers = handlers;\n\t\t\t\t\t}\n\t\t\t\t\tzend_try {\n\t\t\t\t\t\tobj->dtor(obj->object, handle TSRMLS_CC);\n\t\t\t\t\t} zend_catch {\n\t\t\t\t\t\tfailure = 1;\n \t\t\t\t\t} zend_end_try();\n \t\t\t\t}\n \t\t\t}\n \t\t\t/* re-read the object from the object store as the store might have been reallocated in the dtor */\n \t\t\tobj = &EG(objects_store).object_buckets[handle].bucket.obj;\n \n\t\t\tif (obj->refcount == 1) {\n\t\t\t\tGC_REMOVE_ZOBJ_FROM_BUFFER(obj);\n\t\t\t\tif (obj->free_storage) {\n\t\t\t\t\tzend_try {\n\t\t\t\t\t\tobj->free_storage(obj->object TSRMLS_CC);\n\t\t\t\t\t} zend_catch {\n\t\t\t\t\t\tfailure = 1;\n\t\t\t\t\t} zend_end_try();\n\t\t\t\t}\n\t\t\t\tZEND_OBJECTS_STORE_ADD_TO_FREE_LIST();\n\t\t\t}\n\t\t}\n\t}\n\n\tobj->refcount--;\n\n#if ZEND_DEBUG_OBJECTS\n\tif (obj->refcount == 0) {\n\t\tfprintf(stderr, \"Deallocated object id #%d\\n\", handle);\n\t} else {\n\t\tfprintf(stderr, \"Decreased refcount of object id #%d\\n\", handle);\n\t}\n#endif\n\tif (failure) {\n\t\tzend_bailout();\n\t}\n}\n/* }}} */\n", "target": 1, "idx": 180111}
{"func": "print_decnet_ctlmsg(netdissect_options *ndo,\n                     register const union routehdr *rhp, u_int length,\n                     u_int caplen)\n {\n \tint mflags = EXTRACT_LE_8BITS(rhp->rh_short.sh_flags);\n \tregister const union controlmsg *cmp = (const union controlmsg *)rhp;\n \tint src, dst, info, blksize, eco, ueco, hello, other, vers;\n\tetheraddr srcea, rtea;\n\tint priority;\n\tconst char *rhpx = (const char *)rhp;\n\tint ret;\n\n\tswitch (mflags & RMF_CTLMASK) {\n\tcase RMF_INIT:\n\t    ND_PRINT((ndo, \"init \"));\n\t    if (length < sizeof(struct initmsg))\n\t\tgoto trunc;\n\t    ND_TCHECK(cmp->cm_init);\n\t    src = EXTRACT_LE_16BITS(cmp->cm_init.in_src);\n\t    info = EXTRACT_LE_8BITS(cmp->cm_init.in_info);\n\t    blksize = EXTRACT_LE_16BITS(cmp->cm_init.in_blksize);\n\t    vers = EXTRACT_LE_8BITS(cmp->cm_init.in_vers);\n\t    eco = EXTRACT_LE_8BITS(cmp->cm_init.in_eco);\n\t    ueco = EXTRACT_LE_8BITS(cmp->cm_init.in_ueco);\n\t    hello = EXTRACT_LE_16BITS(cmp->cm_init.in_hello);\n\t    print_t_info(ndo, info);\n\t    ND_PRINT((ndo,\n\t\t\"src %sblksize %d vers %d eco %d ueco %d hello %d\",\n\t\t\tdnaddr_string(ndo, src), blksize, vers, eco, ueco,\n\t\t\thello));\n\t    ret = 1;\n\t    break;\n\tcase RMF_VER:\n\t    ND_PRINT((ndo, \"verification \"));\n\t    if (length < sizeof(struct verifmsg))\n\t\tgoto trunc;\n\t    ND_TCHECK(cmp->cm_ver);\n\t    src = EXTRACT_LE_16BITS(cmp->cm_ver.ve_src);\n\t    other = EXTRACT_LE_8BITS(cmp->cm_ver.ve_fcnval);\n\t    ND_PRINT((ndo, \"src %s fcnval %o\", dnaddr_string(ndo, src), other));\n\t    ret = 1;\n\t    break;\n\tcase RMF_TEST:\n\t    ND_PRINT((ndo, \"test \"));\n\t    if (length < sizeof(struct testmsg))\n\t\tgoto trunc;\n\t    ND_TCHECK(cmp->cm_test);\n\t    src = EXTRACT_LE_16BITS(cmp->cm_test.te_src);\n\t    other = EXTRACT_LE_8BITS(cmp->cm_test.te_data);\n\t    ND_PRINT((ndo, \"src %s data %o\", dnaddr_string(ndo, src), other));\n\t    ret = 1;\n\t    break;\n\tcase RMF_L1ROUT:\n\t    ND_PRINT((ndo, \"lev-1-routing \"));\n\t    if (length < sizeof(struct l1rout))\n\t\tgoto trunc;\n\t    ND_TCHECK(cmp->cm_l1rou);\n\t    src = EXTRACT_LE_16BITS(cmp->cm_l1rou.r1_src);\n\t    ND_PRINT((ndo, \"src %s \", dnaddr_string(ndo, src)));\n\t    ret = print_l1_routes(ndo, &(rhpx[sizeof(struct l1rout)]),\n\t\t\t\tlength - sizeof(struct l1rout));\n\t    break;\n\tcase RMF_L2ROUT:\n\t    ND_PRINT((ndo, \"lev-2-routing \"));\n\t    if (length < sizeof(struct l2rout))\n\t\tgoto trunc;\n\t    ND_TCHECK(cmp->cm_l2rout);\n\t    src = EXTRACT_LE_16BITS(cmp->cm_l2rout.r2_src);\n\t    ND_PRINT((ndo, \"src %s \", dnaddr_string(ndo, src)));\n\t    ret = print_l2_routes(ndo, &(rhpx[sizeof(struct l2rout)]),\n\t\t\t\tlength - sizeof(struct l2rout));\n\t    break;\n\tcase RMF_RHELLO:\n\t    ND_PRINT((ndo, \"router-hello \"));\n\t    if (length < sizeof(struct rhellomsg))\n\t\tgoto trunc;\n\t    ND_TCHECK(cmp->cm_rhello);\n\t    vers = EXTRACT_LE_8BITS(cmp->cm_rhello.rh_vers);\n\t    eco = EXTRACT_LE_8BITS(cmp->cm_rhello.rh_eco);\n\t    ueco = EXTRACT_LE_8BITS(cmp->cm_rhello.rh_ueco);\n\t    memcpy((char *)&srcea, (const char *)&(cmp->cm_rhello.rh_src),\n\t\tsizeof(srcea));\n\t    src = EXTRACT_LE_16BITS(srcea.dne_remote.dne_nodeaddr);\n\t    info = EXTRACT_LE_8BITS(cmp->cm_rhello.rh_info);\n\t    blksize = EXTRACT_LE_16BITS(cmp->cm_rhello.rh_blksize);\n\t    priority = EXTRACT_LE_8BITS(cmp->cm_rhello.rh_priority);\n\t    hello = EXTRACT_LE_16BITS(cmp->cm_rhello.rh_hello);\n\t    print_i_info(ndo, info);\n\t    ND_PRINT((ndo,\n\t    \"vers %d eco %d ueco %d src %s blksize %d pri %d hello %d\",\n\t\t\tvers, eco, ueco, dnaddr_string(ndo, src),\n\t\t\tblksize, priority, hello));\n\t    ret = print_elist(&(rhpx[sizeof(struct rhellomsg)]),\n\t\t\t\tlength - sizeof(struct rhellomsg));\n\t    break;\n\tcase RMF_EHELLO:\n\t    ND_PRINT((ndo, \"endnode-hello \"));\n\t    if (length < sizeof(struct ehellomsg))\n\t\tgoto trunc;\n\t    ND_TCHECK(cmp->cm_ehello);\n\t    vers = EXTRACT_LE_8BITS(cmp->cm_ehello.eh_vers);\n\t    eco = EXTRACT_LE_8BITS(cmp->cm_ehello.eh_eco);\n\t    ueco = EXTRACT_LE_8BITS(cmp->cm_ehello.eh_ueco);\n\t    memcpy((char *)&srcea, (const char *)&(cmp->cm_ehello.eh_src),\n\t\tsizeof(srcea));\n\t    src = EXTRACT_LE_16BITS(srcea.dne_remote.dne_nodeaddr);\n\t    info = EXTRACT_LE_8BITS(cmp->cm_ehello.eh_info);\n\t    blksize = EXTRACT_LE_16BITS(cmp->cm_ehello.eh_blksize);\n\t    /*seed*/\n\t    memcpy((char *)&rtea, (const char *)&(cmp->cm_ehello.eh_router),\n\t\tsizeof(rtea));\n\t    dst = EXTRACT_LE_16BITS(rtea.dne_remote.dne_nodeaddr);\n\t    hello = EXTRACT_LE_16BITS(cmp->cm_ehello.eh_hello);\n\t    other = EXTRACT_LE_8BITS(cmp->cm_ehello.eh_data);\n\t    print_i_info(ndo, info);\n\t    ND_PRINT((ndo,\n\t\"vers %d eco %d ueco %d src %s blksize %d rtr %s hello %d data %o\",\n\t\t\tvers, eco, ueco, dnaddr_string(ndo, src),\n\t\t\tblksize, dnaddr_string(ndo, dst), hello, other));\n\t    ret = 1;\n\t    break;\n\n\tdefault:\n\t    ND_PRINT((ndo, \"unknown control message\"));\n\t    ND_DEFAULTPRINT((const u_char *)rhp, min(length, caplen));\n\t    ret = 1;\n\t    break;\n\t}\n\treturn (ret);\n\ntrunc:\n\treturn (0);\n}\n", "target": 1, "idx": 183206}
{"func": "GURL DecorateFrontendURL(const GURL& base_url) {\n  std::string frontend_url = base_url.spec();\n  std::string url_string(\n      frontend_url +\n      ((frontend_url.find(\"?\") == std::string::npos) ? \"?\" : \"&\") +\n      \"dockSide=undocked\"); // TODO(dgozman): remove this support in M38.\n  base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();\n  if (command_line->HasSwitch(switches::kEnableDevToolsExperiments))\n     url_string += \"&experiments=true\";\n \n   if (command_line->HasSwitch(switches::kDevToolsFlags)) {\n    std::string flags = command_line->GetSwitchValueASCII(\n                            switches::kDevToolsFlags);\n    flags = net::EscapeQueryParamValue(flags, false);\n    url_string += \"&flags=\" + flags;\n   }\n \n #if defined(DEBUG_DEVTOOLS)\n  url_string += \"&debugFrontend=true\";\n#endif  // defined(DEBUG_DEVTOOLS)\n\n  return GURL(url_string);\n}\n", "target": 1, "idx": 186477}
{"func": "cdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h,\n    uint32_t offs, cdf_property_info_t **info, size_t *count, size_t *maxcount)\n{\n\tconst cdf_section_header_t *shp;\n\tcdf_section_header_t sh;\n\tconst uint8_t *p, *q, *e;\n\tint16_t s16;\n\tint32_t s32;\n\tuint32_t u32;\n\tint64_t s64;\n\tuint64_t u64;\n\tcdf_timestamp_t tp;\n\tsize_t i, o, o4, nelements, j;\n\tcdf_property_info_t *inp;\n\n\tif (offs > UINT32_MAX / 4) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tshp = CAST(const cdf_section_header_t *, (const void *)\n\t    ((const char *)sst->sst_tab + offs));\n\tif (cdf_check_stream_offset(sst, h, shp, sizeof(*shp), __LINE__) == -1)\n\t\tgoto out;\n\tsh.sh_len = CDF_TOLE4(shp->sh_len);\n#define CDF_SHLEN_LIMIT (UINT32_MAX / 8)\n\tif (sh.sh_len > CDF_SHLEN_LIMIT) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tsh.sh_properties = CDF_TOLE4(shp->sh_properties);\n#define CDF_PROP_LIMIT (UINT32_MAX / (4 * sizeof(*inp)))\n\tif (sh.sh_properties > CDF_PROP_LIMIT)\n\t\tgoto out;\n\tDPRINTF((\"section len: %u properties %u\\n\", sh.sh_len,\n\t    sh.sh_properties));\n\tif (*maxcount) {\n\t\tif (*maxcount > CDF_PROP_LIMIT)\n\t\t\tgoto out;\n\t\t*maxcount += sh.sh_properties;\n\t\tinp = CAST(cdf_property_info_t *,\n\t\t    realloc(*info, *maxcount * sizeof(*inp)));\n\t} else {\n\t\t*maxcount = sh.sh_properties;\n\t\tinp = CAST(cdf_property_info_t *,\n\t\t    malloc(*maxcount * sizeof(*inp)));\n\t}\n\tif (inp == NULL)\n\t\tgoto out;\n\t*info = inp;\n\tinp += *count;\n\t*count += sh.sh_properties;\n\tp = CAST(const uint8_t *, (const void *)\n\t    ((const char *)(const void *)sst->sst_tab +\n\t    offs + sizeof(sh)));\n\te = CAST(const uint8_t *, (const void *)\n\t    (((const char *)(const void *)shp) + sh.sh_len));\n \tif (cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1)\n \t\tgoto out;\n \tfor (i = 0; i < sh.sh_properties; i++) {\n\t\tsize_t ofs = CDF_GETUINT32(p, (i << 1) + 1);\n \t\tq = (const uint8_t *)(const void *)\n \t\t    ((const char *)(const void *)p + ofs\n \t\t    - 2 * sizeof(uint32_t));\n\t\tif (q > e) {\n\t\t\tDPRINTF((\"Ran of the end %p > %p\\n\", q, e));\n\t\t\tgoto out;\n\t\t}\n\t\tinp[i].pi_id = CDF_GETUINT32(p, i << 1);\n\t\tinp[i].pi_type = CDF_GETUINT32(q, 0);\n\t\tDPRINTF((\"%\" SIZE_T_FORMAT \"u) id=%x type=%x offs=0x%tx,0x%x\\n\",\n\t\t    i, inp[i].pi_id, inp[i].pi_type, q - p, offs));\n\t\tif (inp[i].pi_type & CDF_VECTOR) {\n\t\t\tnelements = CDF_GETUINT32(q, 1);\n\t\t\tif (nelements == 0) {\n\t\t\t\tDPRINTF((\"CDF_VECTOR with nelements == 0\\n\"));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\to = 2;\n\t\t} else {\n\t\t\tnelements = 1;\n\t\t\to = 1;\n\t\t}\n\t\to4 = o * sizeof(uint32_t);\n\t\tif (inp[i].pi_type & (CDF_ARRAY|CDF_BYREF|CDF_RESERVED))\n\t\t\tgoto unknown;\n\t\tswitch (inp[i].pi_type & CDF_TYPEMASK) {\n\t\tcase CDF_NULL:\n\t\tcase CDF_EMPTY:\n\t\t\tbreak;\n\t\tcase CDF_SIGNED16:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s16, &q[o4], sizeof(s16));\n\t\t\tinp[i].pi_s16 = CDF_TOLE2(s16);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED32:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s32, &q[o4], sizeof(s32));\n\t\t\tinp[i].pi_s32 = CDF_TOLE4((uint32_t)s32);\n\t\t\tbreak;\n\t\tcase CDF_BOOL:\n\t\tcase CDF_UNSIGNED32:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u32, &q[o4], sizeof(u32));\n\t\t\tinp[i].pi_u32 = CDF_TOLE4(u32);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED64:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s64, &q[o4], sizeof(s64));\n\t\t\tinp[i].pi_s64 = CDF_TOLE8((uint64_t)s64);\n\t\t\tbreak;\n\t\tcase CDF_UNSIGNED64:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u64, &q[o4], sizeof(u64));\n\t\t\tinp[i].pi_u64 = CDF_TOLE8((uint64_t)u64);\n\t\t\tbreak;\n\t\tcase CDF_FLOAT:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u32, &q[o4], sizeof(u32));\n\t\t\tu32 = CDF_TOLE4(u32);\n\t\t\tmemcpy(&inp[i].pi_f, &u32, sizeof(inp[i].pi_f));\n\t\t\tbreak;\n\t\tcase CDF_DOUBLE:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u64, &q[o4], sizeof(u64));\n\t\t\tu64 = CDF_TOLE8((uint64_t)u64);\n\t\t\tmemcpy(&inp[i].pi_d, &u64, sizeof(inp[i].pi_d));\n\t\t\tbreak;\n\t\tcase CDF_LENGTH32_STRING:\n\t\tcase CDF_LENGTH32_WSTRING:\n\t\t\tif (nelements > 1) {\n\t\t\t\tsize_t nelem = inp - *info;\n\t\t\t\tif (*maxcount > CDF_PROP_LIMIT\n\t\t\t\t    || nelements > CDF_PROP_LIMIT)\n\t\t\t\t\tgoto out;\n\t\t\t\t*maxcount += nelements;\n\t\t\t\tinp = CAST(cdf_property_info_t *,\n\t\t\t\t    realloc(*info, *maxcount * sizeof(*inp)));\n\t\t\t\tif (inp == NULL)\n\t\t\t\t\tgoto out;\n\t\t\t\t*info = inp;\n\t\t\t\tinp = *info + nelem;\n\t\t\t}\n\t\t\tDPRINTF((\"nelements = %\" SIZE_T_FORMAT \"u\\n\",\n\t\t\t    nelements));\n\t\t\tfor (j = 0; j < nelements && i < sh.sh_properties;\n\t\t\t    j++, i++)\n\t\t\t{\n\t\t\t\tuint32_t l = CDF_GETUINT32(q, o);\n\t\t\t\tinp[i].pi_str.s_len = l;\n\t\t\t\tinp[i].pi_str.s_buf = (const char *)\n\t\t\t\t    (const void *)(&q[o4 + sizeof(l)]);\n\t\t\t\tDPRINTF((\"l = %d, r = %\" SIZE_T_FORMAT\n\t\t\t\t    \"u, s = %s\\n\", l,\n\t\t\t\t    CDF_ROUND(l, sizeof(l)),\n\t\t\t\t    inp[i].pi_str.s_buf));\n\t\t\t\tif (l & 1)\n\t\t\t\t\tl++;\n\t\t\t\to += l >> 1;\n\t\t\t\tif (q + o >= e)\n\t\t\t\t\tgoto out;\n\t\t\t\to4 = o * sizeof(uint32_t);\n\t\t\t}\n\t\t\ti--;\n\t\t\tbreak;\n\t\tcase CDF_FILETIME:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&tp, &q[o4], sizeof(tp));\n\t\t\tinp[i].pi_tp = CDF_TOLE8((uint64_t)tp);\n\t\t\tbreak;\n\t\tcase CDF_CLIPBOARD:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tdefault:\n\t\tunknown:\n\t\t\tDPRINTF((\"Don't know how to deal with %x\\n\",\n\t\t\t    inp[i].pi_type));\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\nout:\n\tfree(*info);\n\treturn -1;\n}\n", "target": 1, "idx": 179536}
{"func": "print_bacp_config_options(netdissect_options *ndo,\n                          const u_char *p, int length)\n{\n\tint len, opt;\n\n\tif (length < 2)\n\t\treturn 0;\n\tND_TCHECK2(*p, 2);\n\tlen = p[1];\n\topt = p[0];\n\tif (length < len)\n\t\treturn 0;\n\tif (len < 2) {\n\t\tND_PRINT((ndo, \"\\n\\t  %s Option (0x%02x), length %u (length bogus, should be >= 2)\",\n\t\t          tok2str(bacconfopts_values, \"Unknown\", opt),\n\t\t          opt,\n\t\t          len));\n\t\treturn 0;\n\t}\n\n\tND_PRINT((ndo, \"\\n\\t  %s Option (0x%02x), length %u\",\n\t          tok2str(bacconfopts_values, \"Unknown\", opt),\n\t          opt,\n\t          len));\n\n\tswitch (opt) {\n\tcase BACPOPT_FPEER:\n\t\tif (len != 6) {\n \t\t\tND_PRINT((ndo, \" (length bogus, should be = 6)\"));\n \t\t\treturn len;\n \t\t}\n\t\tND_TCHECK2(*(p + 2), 4);\n \t\tND_PRINT((ndo, \": Magic-Num 0x%08x\", EXTRACT_32BITS(p + 2)));\n \t\tbreak;\n \tdefault:\n\t\t/*\n\t\t * Unknown option; dump it as raw bytes now if we're\n\t\t * not going to do so below.\n\t\t */\n\t\tif (ndo->ndo_vflag < 2)\n\t\t\tprint_unknown_data(ndo, &p[2], \"\\n\\t    \", len - 2);\n\t\tbreak;\n\t}\n\tif (ndo->ndo_vflag > 1)\n\t\tprint_unknown_data(ndo, &p[2], \"\\n\\t    \", len - 2); /* exclude TLV header */\n\n\treturn len;\n\ntrunc:\n\tND_PRINT((ndo, \"[|bacp]\"));\n\treturn 0;\n}\n", "target": 1, "idx": 181031}
{"func": "static int proc_key_users_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &proc_key_users_ops);\n}\n", "target": 0, "idx": 60269}
{"func": "void comps_objmrtree_unite(COMPS_ObjMRTree *rt1, COMPS_ObjMRTree *rt2) {\n    COMPS_HSList *tmplist, *tmp_subnodes;\n    COMPS_HSListItem *it;\n    COMPS_ObjListIt *it2;\n     struct Pair {\n         COMPS_HSList * subnodes;\n         char * key;\n        char added;\n     } *pair, *parent_pair;\n \n     pair = malloc(sizeof(struct Pair));\n    pair->subnodes = rt2->subnodes;\n    pair->key = NULL;\n\n    tmplist = comps_hslist_create();\n    comps_hslist_init(tmplist, NULL, NULL, &free);\n    comps_hslist_append(tmplist, pair, 0);\n\n    while (tmplist->first != NULL) {\n        it = tmplist->first;\n        comps_hslist_remove(tmplist, tmplist->first);\n        tmp_subnodes = ((struct Pair*)it->data)->subnodes;\n         parent_pair = (struct Pair*) it->data;\n         free(it);\n \n        pair->added = 0;\n         for (it = tmp_subnodes->first; it != NULL; it=it->next) {\n             pair = malloc(sizeof(struct Pair));\n             pair->subnodes = ((COMPS_ObjMRTreeData*)it->data)->subnodes;\n\n            if (parent_pair->key != NULL) {\n                pair->key =\n                    malloc(sizeof(char)\n                           * (strlen(((COMPS_ObjMRTreeData*)it->data)->key)\n                           + strlen(parent_pair->key) + 1));\n                memcpy(pair->key, parent_pair->key,\n                       sizeof(char) * strlen(parent_pair->key));\n                memcpy(pair->key+strlen(parent_pair->key),\n                       ((COMPS_ObjMRTreeData*)it->data)->key,\n                       sizeof(char)*(strlen(((COMPS_ObjMRTreeData*)it->data)->key)+1));\n            } else {\n                pair->key = malloc(sizeof(char)*\n                                (strlen(((COMPS_ObjMRTreeData*)it->data)->key) +\n                                1));\n                memcpy(pair->key, ((COMPS_ObjMRTreeData*)it->data)->key,\n                       sizeof(char)*(strlen(((COMPS_ObjMRTreeData*)it->data)->key)+1));\n            }\n            /* current node has data */\n            if (((COMPS_ObjMRTreeData*)it->data)->data->first != NULL) {\n                for (it2 = ((COMPS_ObjMRTreeData*)it->data)->data->first;\n                     it2 != NULL; it2 = it2->next) {\n                    comps_objmrtree_set(rt1, pair->key, it2->comps_obj);\n                }\n\n                if (((COMPS_ObjMRTreeData*)it->data)->subnodes->first) {\n                    comps_hslist_append(tmplist, pair, 0);\n                } else {\n                    free(pair->key);\n                    free(pair);\n                }\n            /* current node hasn't data */\n            } else {\n                if (((COMPS_ObjMRTreeData*)it->data)->subnodes->first) {\n                    comps_hslist_append(tmplist, pair, 0);\n                } else {\n                    free(pair->key);\n                    free(pair);\n                }\n            }\n        }\n        free(parent_pair->key);\n        free(parent_pair);\n    }\n    comps_hslist_destroy(&tmplist);\n}\n", "target": 1, "idx": 182923}
{"func": "static int des_setkey(struct crypto_tfm *tfm, const u8 *key,\n\t\t      unsigned int keylen)\n{\n\tstruct des_ctx *dctx = crypto_tfm_ctx(tfm);\n\tu32 *flags = &tfm->crt_flags;\n\tu32 tmp[DES_EXPKEY_WORDS];\n\tint ret;\n\n\t/* Expand to tmp */\n\tret = des_ekey(tmp, key);\n\n\tif (unlikely(ret == 0) && (*flags & CRYPTO_TFM_REQ_WEAK_KEY)) {\n\t\t*flags |= CRYPTO_TFM_RES_WEAK_KEY;\n\t\treturn -EINVAL;\n\t}\n\n\t/* Copy to output */\n\tmemcpy(dctx->expkey, tmp, sizeof(dctx->expkey));\n\n\treturn 0;\n}\n", "target": 0, "idx": 47240}
{"func": "FFmpegVideoDecodeEngine::FFmpegVideoDecodeEngine()\n    : codec_context_(NULL),\n      event_handler_(NULL),\n      frame_rate_numerator_(0),\n      frame_rate_denominator_(0),\n      pending_input_buffers_(0),\n      pending_output_buffers_(0),\n      output_eos_reached_(false),\n      flush_pending_(false) {\n}\n", "target": 0, "idx": 103232}
{"func": "add_code_range_to_buf(BBuf** pbuf, OnigCodePoint from, OnigCodePoint to)\n{\n  int r, inc_n, pos;\n  int low, high, bound, x;\n  OnigCodePoint n, *data;\n  BBuf* bbuf;\n\n  if (from > to) {\n    n = from; from = to; to = n;\n  }\n\n  if (IS_NULL(*pbuf)) {\n    r = new_code_range(pbuf);\n    if (r) return r;\n    bbuf = *pbuf;\n    n = 0;\n  }\n  else {\n    bbuf = *pbuf;\n    GET_CODE_POINT(n, bbuf->p);\n  }\n  data = (OnigCodePoint* )(bbuf->p);\n  data++;\n\n  for (low = 0, bound = n; low < bound; ) {\n    x = (low + bound) >> 1;\n    if (from > data[x*2 + 1])\n      low = x + 1;\n    else\n      bound = x;\n  }\n\n  high = (to == ~((OnigCodePoint )0)) ? n : low;\n  for (bound = n; high < bound; ) {\n    x = (high + bound) >> 1;\n    if (to + 1 >= data[x*2])\n      high = x + 1;\n    else\n      bound = x;\n  }\n\n  inc_n = low + 1 - high;\n  if (n + inc_n > ONIG_MAX_MULTI_BYTE_RANGES_NUM)\n    return ONIGERR_TOO_MANY_MULTI_BYTE_RANGES;\n\n  if (inc_n != 1) {\n    if (from > data[low*2])\n      from = data[low*2];\n    if (to < data[(high - 1)*2 + 1])\n      to = data[(high - 1)*2 + 1];\n  }\n\n  if (inc_n != 0 && (OnigCodePoint )high < n) {\n    int from_pos = SIZE_CODE_POINT * (1 + high * 2);\n    int to_pos   = SIZE_CODE_POINT * (1 + (low + 1) * 2);\n    int size = (n - high) * 2 * SIZE_CODE_POINT;\n\n    if (inc_n > 0) {\n      BBUF_MOVE_RIGHT(bbuf, from_pos, to_pos, size);\n    }\n    else {\n      BBUF_MOVE_LEFT_REDUCE(bbuf, from_pos, to_pos);\n    }\n  }\n\n  pos = SIZE_CODE_POINT * (1 + low * 2);\n  BBUF_ENSURE_SIZE(bbuf, pos + SIZE_CODE_POINT * 2);\n  BBUF_WRITE_CODE_POINT(bbuf, pos, from);\n  BBUF_WRITE_CODE_POINT(bbuf, pos + SIZE_CODE_POINT, to);\n  n += inc_n;\n  BBUF_WRITE_CODE_POINT(bbuf, 0, n);\n\n  return 0;\n}\n", "target": 0, "idx": 64698}
{"func": " image_transform_png_set_scale_16_add(image_transform *this,\n    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)\n {\n    UNUSED(colour_type)\n \n this->next = *that;\n *that = this;\n\n return bit_depth > 8;\n}\n", "target": 1, "idx": 187667}
{"func": "ssize_t rawexpread(off_t a, char *buf, size_t len, CLIENT *client) {\n\tint fhandle;\n\toff_t foffset;\n\tsize_t maxbytes;\n\n\tif(get_filepos(client->export, a, &fhandle, &foffset, &maxbytes))\n\t\treturn -1;\n\tif(maxbytes && len > maxbytes)\n\t\tlen = maxbytes;\n\n\tDEBUG(\"(READ from fd %d offset %llu len %u), \", fhandle, (long long unsigned int)foffset, (unsigned int)len);\n\n\tmyseek(fhandle, foffset);\n\treturn read(fhandle, buf, len);\n}\n", "target": 0, "idx": 46580}
{"func": "static int b43_dma_set_mask(struct b43_wldev *dev, u64 mask)\n{\n\tu64 orig_mask = mask;\n\tbool fallback = 0;\n\tint err;\n\n\t/* Try to set the DMA mask. If it fails, try falling back to a\n\t * lower mask, as we can always also support a lower one. */\n\twhile (1) {\n\t\terr = dma_set_mask(dev->dev->dma_dev, mask);\n\t\tif (!err) {\n\t\t\terr = dma_set_coherent_mask(dev->dev->dma_dev, mask);\n\t\t\tif (!err)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (mask == DMA_BIT_MASK(64)) {\n\t\t\tmask = DMA_BIT_MASK(32);\n\t\t\tfallback = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (mask == DMA_BIT_MASK(32)) {\n\t\t\tmask = DMA_BIT_MASK(30);\n\t\t\tfallback = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tb43err(dev->wl, \"The machine/kernel does not support \"\n\t\t       \"the required %u-bit DMA mask\\n\",\n\t\t       (unsigned int)dma_mask_to_engine_type(orig_mask));\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (fallback) {\n\t\tb43info(dev->wl, \"DMA mask fallback from %u-bit to %u-bit\\n\",\n\t\t\t(unsigned int)dma_mask_to_engine_type(orig_mask),\n\t\t\t(unsigned int)dma_mask_to_engine_type(mask));\n\t}\n\n\treturn 0;\n}\n", "target": 0, "idx": 24532}
{"func": "int hashtable_set(hashtable_t *hashtable,\n                  const char *key, size_t serial,\n                  json_t *value)\n{\n    pair_t *pair;\n    bucket_t *bucket;\n     size_t hash, index;\n \n     /* rehash if the load ratio exceeds 1 */\n    if(hashtable->size >= num_buckets(hashtable))\n         if(hashtable_do_rehash(hashtable))\n             return -1;\n \n     hash = hash_str(key);\n    index = hash % num_buckets(hashtable);\n     bucket = &hashtable->buckets[index];\n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n \n    if(pair)\n    {\n        json_decref(pair->value);\n        pair->value = value;\n    }\n    else\n    {\n        /* offsetof(...) returns the size of pair_t without the last,\n           flexible member. This way, the correct amount is\n           allocated. */\n        pair = jsonp_malloc(offsetof(pair_t, key) + strlen(key) + 1);\n        if(!pair)\n            return -1;\n\n        pair->hash = hash;\n        pair->serial = serial;\n        strcpy(pair->key, key);\n        pair->value = value;\n        list_init(&pair->list);\n\n        insert_to_bucket(hashtable, bucket, &pair->list);\n\n        hashtable->size++;\n    }\n    return 0;\n}\n", "target": 1, "idx": 179705}
{"func": " SchedulerObject::_continue(std::string key, std::string &/*reason*/, std::string &text)\n {\n        PROC_ID id = getProcByString(key.c_str());\n       if (id.cluster < 0 || id.proc < 0) {\n                dprintf(D_FULLDEBUG, \"Remove: Failed to parse id: %s\\n\", key.c_str());\n                text = \"Invalid Id\";\n                return false;\n\t}\n\n\tscheduler.enqueueActOnJobMyself(id,JA_CONTINUE_JOBS,true);\n\n\treturn true;\n}\n", "target": 1, "idx": 178003}
{"func": "GURL DevToolsWindow::GetDevToolsURL(Profile* profile,\n                                    const GURL& base_url,\n                                    bool shared_worker_frontend,\n                                    bool v8_only_frontend,\n                                    const std::string& remote_frontend,\n                                    bool can_dock) {\n  if (base_url.SchemeIs(\"data\"))\n    return base_url;\n\n  std::string frontend_url(\n      !remote_frontend.empty() ?\n          remote_frontend :\n          base_url.is_empty() ? chrome::kChromeUIDevToolsURL : base_url.spec());\n  std::string url_string(\n      frontend_url +\n      ((frontend_url.find(\"?\") == std::string::npos) ? \"?\" : \"&\"));\n  if (shared_worker_frontend)\n    url_string += \"&isSharedWorker=true\";\n  if (v8_only_frontend)\n    url_string += \"&v8only=true\";\n  if (remote_frontend.size()) {\n    url_string += \"&remoteFrontend=true\";\n  } else {\n    url_string += \"&remoteBase=\" + DevToolsUI::GetRemoteBaseURL().spec();\n   }\n   if (can_dock)\n     url_string += \"&can_dock=true\";\n  return GURL(url_string);\n }\n", "target": 1, "idx": 186478}
{"func": "virDomainGetJobInfo(virDomainPtr domain, virDomainJobInfoPtr info)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"info=%p\", info);\n\n    virResetLastError();\n\n    if (info)\n        memset(info, 0, sizeof(*info));\n\n    virCheckDomainReturn(domain, -1);\n    virCheckNonNullArgGoto(info, error);\n\n    conn = domain->conn;\n\n    if (conn->driver->domainGetJobInfo) {\n        int ret;\n        ret = conn->driver->domainGetJobInfo(domain, info);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n", "target": 0, "idx": 93809}
{"func": "mac_init (digest_hd_st * td, gnutls_mac_algorithm_t mac, opaque * secret,\n          int secret_size, int ver)\n{\n  int ret = 0;\n\n  if (mac == GNUTLS_MAC_NULL)\n    {\n      return GNUTLS_E_HASH_FAILED;\n    }\n\n  if (ver == GNUTLS_SSL3)\n    {                           /* SSL 3.0 */\n      ret = _gnutls_mac_init_ssl3 (td, mac, secret, secret_size);\n    }\n  else\n    {                           /* TLS 1.x */\n      ret = _gnutls_hmac_init (td, mac, secret, secret_size);\n    }\n\n  return ret;\n}\n", "target": 0, "idx": 11316}
{"func": "static void llc_sap_rcv(struct llc_sap *sap, struct sk_buff *skb,\n\t\t\tstruct sock *sk)\n{\n\tstruct llc_sap_state_ev *ev = llc_sap_ev(skb);\n \n \tev->type   = LLC_SAP_EV_TYPE_PDU;\n \tev->reason = 0;\n \tskb->sk = sk;\n \tllc_sap_state_process(sap, skb);\n }\n", "target": 1, "idx": 181521}
{"func": "void d_instantiate(struct dentry *entry, struct inode * inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\tif (inode) {\n\t\tsecurity_d_instantiate(entry, inode);\n\t\tspin_lock(&inode->i_lock);\n\t\t__d_instantiate(entry, inode);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n}\n", "target": 0, "idx": 67306}
{"func": "static zend_always_inline uint32_t zend_array_dup_elements(HashTable *source, HashTable *target, int static_keys, int with_holes)\n{\n\tuint32_t idx = 0;\n\tBucket *p = source->arData;\n\tBucket *q = target->arData;\n\tBucket *end = p + source->nNumUsed;\n\n\tdo {\n\t\tif (!zend_array_dup_element(source, target, idx, p, q, 0, static_keys, with_holes)) {\n\t\t\tuint32_t target_idx = idx;\n\n\t\t\tidx++; p++;\n\t\t\twhile (p != end) {\n\t\t\t\tif (zend_array_dup_element(source, target, target_idx, p, q, 0, static_keys, with_holes)) {\n\t\t\t\t\tif (source->nInternalPointer == idx) {\n\t\t\t\t\t\ttarget->nInternalPointer = target_idx;\n\t\t\t\t\t}\n\t\t\t\t\ttarget_idx++; q++;\n\t\t\t\t}\n\t\t\t\tidx++; p++;\n\t\t\t}\n\t\t\treturn target_idx;\n\t\t}\n\t\tidx++; p++; q++;\n\t} while (p != end);\n\treturn idx;\n}\n", "target": 0, "idx": 69158}
{"func": "SpoolssSetPrinter_q(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t       proto_tree *tree, dcerpc_info *di, guint8 *drep _U_)\n{\n\tguint32 level;\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tFALSE, FALSE);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_level, &level);\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", level %d\", level);\n\n\toffset = dissect_SPOOL_PRINTER_INFO(\n\t\ttvb, offset, pinfo, tree, di, drep);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\thf_setprinter_cmd, NULL);\n\n\treturn offset;\n}\n", "target": 0, "idx": 51991}
{"func": " static void array_cleanup( char* arr[] , int arr_size)\n {\n \tint i=0;\n\tfor( i=0; i< arr_size; i++ ){ \n \t\tif( arr[i*2] ){\n \t\t\tefree( arr[i*2]);\n \t\t}\n\t}\n\tefree(arr);\n}\n", "target": 1, "idx": 180372}
{"func": "bool XSSAuditor::filterFrameToken(const FilterTokenRequest& request)\n{\n    ASSERT(request.token.type() == HTMLToken::StartTag);\n    ASSERT(hasName(request.token, iframeTag) || hasName(request.token, frameTag));\n\n    bool didBlockScript = eraseAttributeIfInjected(request, srcdocAttr, String(), ScriptLikeAttribute);\n    if (isContainedInRequest(decodedSnippetForName(request)))\n        didBlockScript |= eraseAttributeIfInjected(request, srcAttr, String(), SrcLikeAttribute);\n\n    return didBlockScript;\n}\n", "target": 0, "idx": 133704}
{"func": "int udp_v4_get_port(struct sock *sk, unsigned short snum)\n{\n\tunsigned int hash2_nulladdr =\n\t\tudp4_portaddr_hash(sock_net(sk), htonl(INADDR_ANY), snum);\n\tunsigned int hash2_partial =\n\t\tudp4_portaddr_hash(sock_net(sk), inet_sk(sk)->inet_rcv_saddr, 0);\n\n\t/* precompute partial secondary hash */\n\tudp_sk(sk)->udp_portaddr_hash = hash2_partial;\n\treturn udp_lib_get_port(sk, snum, ipv4_rcv_saddr_equal, hash2_nulladdr);\n}\n", "target": 0, "idx": 19110}
{"func": "static void detect_allow_debuggers(int argc, char **argv) {\n\tint i;\n\t\n \tfor (i = 1; i < argc; i++) {\n \t\tif (strcmp(argv[i], \"--allow-debuggers\") == 0) {\n \t\t\targ_allow_debuggers = 1;\n \t\t\tbreak;\n \t\t}\n\t\t\n\t\tif (strcmp(argv[i], \"--\") == 0)\n\t\t\tbreak;\n\t\tif (strncmp(argv[i], \"--\", 2) != 0)\n\t\t\tbreak;\n\t}\n}\n", "target": 1, "idx": 181591}
{"func": "static void h2_session_ev_no_io(h2_session *session, int arg, const char *msg)\n{\n    switch (session->state) {\n        case H2_SESSION_ST_BUSY:\n            /* Nothing to READ, nothing to WRITE on the master connection.\n             * Possible causes:\n             * - we wait for the client to send us sth\n             * - we wait for started tasks to produce output\n             * - we have finished all streams and the client has sent GO_AWAY\n             */\n            ap_log_cerror(APLOG_MARK, APLOG_TRACE2, 0, session->c,\n                          \"h2_session(%ld): NO_IO event, %d streams open\", \n                          session->id, session->open_streams);\n            h2_conn_io_flush(&session->io);\n            if (session->open_streams > 0) {\n                if (h2_mplx_awaits_data(session->mplx)) {\n                    /* waiting for at least one stream to produce data */\n                    transit(session, \"no io\", H2_SESSION_ST_WAIT);\n                }\n                else {\n                    /* we have streams open, and all are submitted and none\n                     * is suspended. The only thing keeping us from WRITEing\n                     * more must be the flow control.\n                     * This means we only wait for WINDOW_UPDATE from the \n                     * client and can block on READ. */\n                    transit(session, \"no io (flow wait)\", H2_SESSION_ST_IDLE);\n                    session->idle_until = apr_time_now() + session->s->timeout;\n                    session->keep_sync_until = session->idle_until;\n                    /* Make sure we have flushed all previously written output\n                     * so that the client will react. */\n                    if (h2_conn_io_flush(&session->io) != APR_SUCCESS) {\n                        dispatch_event(session, H2_SESSION_EV_CONN_ERROR, 0, NULL);\n                        return;\n                    }\n                }\n            }\n            else if (session->local.accepting) {\n                /* When we have no streams, but accept new, switch to idle */\n                apr_time_t now = apr_time_now();\n                transit(session, \"no io (keepalive)\", H2_SESSION_ST_IDLE);\n                session->idle_until = (session->remote.emitted_count? \n                                       session->s->keep_alive_timeout : \n                                       session->s->timeout) + now;\n                session->keep_sync_until = now + apr_time_from_sec(1);\n            }\n            else {\n                /* We are no longer accepting new streams and there are\n                 * none left. Time to leave. */\n                h2_session_shutdown(session, arg, msg, 0);\n                transit(session, \"no io\", H2_SESSION_ST_DONE);\n            }\n            break;\n        default:\n            /* nop */\n            break;\n    }\n}\n", "target": 0, "idx": 48646}
{"func": "     virtual void scheduleBeginFrameAndCommit()\n     {\n        CCMainThread::postTask(m_proxy->createBeginFrameAndCommitTaskOnCCThread());\n     }\n", "target": 1, "idx": 183745}
{"func": "static struct sk_buff *inet_rtm_getroute_build_skb(__be32 src, __be32 dst,\n\t\t\t\t\t\t   u8 ip_proto, __be16 sport,\n\t\t\t\t\t\t   __be16 dport)\n{\n\tstruct sk_buff *skb;\n\tstruct iphdr *iph;\n\n\tskb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!skb)\n\t\treturn NULL;\n\n\t/* Reserve room for dummy headers, this skb can pass\n\t * through good chunk of routing engine.\n\t */\n\tskb_reset_mac_header(skb);\n\tskb_reset_network_header(skb);\n\tskb->protocol = htons(ETH_P_IP);\n\tiph = skb_put(skb, sizeof(struct iphdr));\n\tiph->protocol = ip_proto;\n\tiph->saddr = src;\n\tiph->daddr = dst;\n\tiph->version = 0x4;\n\tiph->frag_off = 0;\n\tiph->ihl = 0x5;\n\tskb_set_transport_header(skb, skb->len);\n\n\tswitch (iph->protocol) {\n\tcase IPPROTO_UDP: {\n\t\tstruct udphdr *udph;\n\n\t\tudph = skb_put_zero(skb, sizeof(struct udphdr));\n\t\tudph->source = sport;\n\t\tudph->dest = dport;\n\t\tudph->len = sizeof(struct udphdr);\n\t\tudph->check = 0;\n\t\tbreak;\n\t}\n\tcase IPPROTO_TCP: {\n\t\tstruct tcphdr *tcph;\n\n\t\ttcph = skb_put_zero(skb, sizeof(struct tcphdr));\n\t\ttcph->source\t= sport;\n\t\ttcph->dest\t= dport;\n\t\ttcph->doff\t= sizeof(struct tcphdr) / 4;\n\t\ttcph->rst = 1;\n\t\ttcph->check = ~tcp_v4_check(sizeof(struct tcphdr),\n\t\t\t\t\t    src, dst, 0);\n\t\tbreak;\n\t}\n\tcase IPPROTO_ICMP: {\n\t\tstruct icmphdr *icmph;\n\n\t\ticmph = skb_put_zero(skb, sizeof(struct icmphdr));\n\t\ticmph->type = ICMP_ECHO;\n\t\ticmph->code = 0;\n\t}\n\t}\n\n\treturn skb;\n}\n", "target": 0, "idx": 91117}
{"func": "static inline void advance(struct pt_regs *regs)\n{\n\tregs->tpc   = regs->tnpc;\n\tregs->tnpc += 4;\n\tif (test_thread_flag(TIF_32BIT)) {\n\t\tregs->tpc &= 0xffffffff;\n\t\tregs->tnpc &= 0xffffffff;\n\t}\n}\n", "target": 0, "idx": 25694}
{"func": "static int rle_patch_file_size(struct iwbmpwcontext *wctx,size_t rlesize)\n{\n\tiw_byte buf[4];\n\tsize_t fileheader_size;\n\tint ret;\n\n\tif(!wctx->iodescr->seek_fn) {\n\t\tiw_set_error(wctx->ctx,\"Writing compressed BMP requires a seek function\");\n\t\treturn 0;\n\t}\n\n\tif(wctx->include_file_header) {\n\t\tret=(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,2,SEEK_SET);\n\t\tif(!ret) return 0;\n\t\tiw_set_ui32le(buf,(unsigned int)(14+wctx->header_size+wctx->bitfields_size+wctx->palsize+rlesize));\n\t\tiwbmp_write(wctx,buf,4);\n\t\tfileheader_size = 14;\n\t}\n\telse {\n\t\tfileheader_size = 0;\n\t}\n\n\tret=(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,fileheader_size+20,SEEK_SET);\n\tif(!ret) return 0;\n\tiw_set_ui32le(buf,(unsigned int)rlesize);\n\tiwbmp_write(wctx,buf,4);\n\n\t(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,0,SEEK_END);\n\treturn 1;\n}\n", "target": 0, "idx": 64892}
{"func": "void* iwpvt_default_malloc(void *userdata, unsigned int flags, size_t n)\n{\n\tif(flags & IW_MALLOCFLAG_ZEROMEM) {\n\t\treturn calloc(n,1);\n\t}\n\treturn malloc(n);\n}\n", "target": 0, "idx": 66301}
{"func": "Chapters::Display::~Display()\n{\n}\n", "target": 1, "idx": 188486}
{"func": "bool Block::IsInvisible() const\n{\n    return bool(int(m_flags & 0x08) != 0);\n }\n", "target": 1, "idx": 188413}
{"func": "struct sk_buff *skb_segment(struct sk_buff *head_skb,\n\t\t\t    netdev_features_t features)\n{\n\tstruct sk_buff *segs = NULL;\n\tstruct sk_buff *tail = NULL;\n\tstruct sk_buff *list_skb = skb_shinfo(head_skb)->frag_list;\n \tskb_frag_t *frag = skb_shinfo(head_skb)->frags;\n \tunsigned int mss = skb_shinfo(head_skb)->gso_size;\n \tunsigned int doffset = head_skb->data - skb_mac_header(head_skb);\n \tunsigned int offset = doffset;\n \tunsigned int tnl_hlen = skb_tnl_header_len(head_skb);\n \tunsigned int headroom;\n\tunsigned int len;\n\t__be16 proto;\n\tbool csum;\n\tint sg = !!(features & NETIF_F_SG);\n\tint nfrags = skb_shinfo(head_skb)->nr_frags;\n\tint err = -ENOMEM;\n\tint i = 0;\n\tint pos;\n\n\tproto = skb_network_protocol(head_skb);\n\tif (unlikely(!proto))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tcsum = !!can_checksum_protocol(features, proto);\n\t__skb_push(head_skb, doffset);\n\theadroom = skb_headroom(head_skb);\n\tpos = skb_headlen(head_skb);\n\n\tdo {\n\t\tstruct sk_buff *nskb;\n\t\tskb_frag_t *nskb_frag;\n\t\tint hsize;\n\t\tint size;\n\n\t\tlen = head_skb->len - offset;\n\t\tif (len > mss)\n\t\t\tlen = mss;\n\n\t\thsize = skb_headlen(head_skb) - offset;\n\t\tif (hsize < 0)\n\t\t\thsize = 0;\n\t\tif (hsize > len || !sg)\n\t\t\thsize = len;\n\n\t\tif (!hsize && i >= nfrags && skb_headlen(list_skb) &&\n\t\t    (skb_headlen(list_skb) == len || sg)) {\n\t\t\tBUG_ON(skb_headlen(list_skb) > len);\n\n \t\t\ti = 0;\n \t\t\tnfrags = skb_shinfo(list_skb)->nr_frags;\n \t\t\tfrag = skb_shinfo(list_skb)->frags;\n \t\t\tpos += skb_headlen(list_skb);\n \n \t\t\twhile (pos < offset + len) {\n\t\t\t\tBUG_ON(i >= nfrags);\n\n\t\t\t\tsize = skb_frag_size(frag);\n\t\t\t\tif (pos + size > offset + len)\n\t\t\t\t\tbreak;\n\n\t\t\t\ti++;\n\t\t\t\tpos += size;\n\t\t\t\tfrag++;\n\t\t\t}\n\n\t\t\tnskb = skb_clone(list_skb, GFP_ATOMIC);\n\t\t\tlist_skb = list_skb->next;\n\n\t\t\tif (unlikely(!nskb))\n\t\t\t\tgoto err;\n\n\t\t\tif (unlikely(pskb_trim(nskb, len))) {\n\t\t\t\tkfree_skb(nskb);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\thsize = skb_end_offset(nskb);\n\t\t\tif (skb_cow_head(nskb, doffset + headroom)) {\n\t\t\t\tkfree_skb(nskb);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tnskb->truesize += skb_end_offset(nskb) - hsize;\n\t\t\tskb_release_head_state(nskb);\n\t\t\t__skb_push(nskb, doffset);\n\t\t} else {\n\t\t\tnskb = __alloc_skb(hsize + doffset + headroom,\n\t\t\t\t\t   GFP_ATOMIC, skb_alloc_rx_flag(head_skb),\n\t\t\t\t\t   NUMA_NO_NODE);\n\n\t\t\tif (unlikely(!nskb))\n\t\t\t\tgoto err;\n\n\t\t\tskb_reserve(nskb, headroom);\n\t\t\t__skb_put(nskb, doffset);\n\t\t}\n\n\t\tif (segs)\n\t\t\ttail->next = nskb;\n\t\telse\n\t\t\tsegs = nskb;\n\t\ttail = nskb;\n\n\t\t__copy_skb_header(nskb, head_skb);\n\t\tnskb->mac_len = head_skb->mac_len;\n\n\t\tskb_headers_offset_update(nskb, skb_headroom(nskb) - headroom);\n\n\t\tskb_copy_from_linear_data_offset(head_skb, -tnl_hlen,\n\t\t\t\t\t\t nskb->data - tnl_hlen,\n\t\t\t\t\t\t doffset + tnl_hlen);\n\n\t\tif (nskb->len == len + doffset)\n\t\t\tgoto perform_csum_check;\n\n\t\tif (!sg) {\n\t\t\tnskb->ip_summed = CHECKSUM_NONE;\n\t\t\tnskb->csum = skb_copy_and_csum_bits(head_skb, offset,\n\t\t\t\t\t\t\t    skb_put(nskb, len),\n\t\t\t\t\t\t\t    len, 0);\n\t\t\tcontinue;\n\t\t}\n\n\t\tnskb_frag = skb_shinfo(nskb)->frags;\n\n\t\tskb_copy_from_linear_data_offset(head_skb, offset,\n\t\t\t\t\t\t skb_put(nskb, hsize), hsize);\n\n\t\tskb_shinfo(nskb)->tx_flags = skb_shinfo(head_skb)->tx_flags &\n\t\t\tSKBTX_SHARED_FRAG;\n\n\t\twhile (pos < offset + len) {\n\t\t\tif (i >= nfrags) {\n\t\t\t\tBUG_ON(skb_headlen(list_skb));\n\n \t\t\t\ti = 0;\n \t\t\t\tnfrags = skb_shinfo(list_skb)->nr_frags;\n \t\t\t\tfrag = skb_shinfo(list_skb)->frags;\n \n \t\t\t\tBUG_ON(!nfrags);\n \n\t\t\t\tlist_skb = list_skb->next;\n\t\t\t}\n\n\t\t\tif (unlikely(skb_shinfo(nskb)->nr_frags >=\n\t\t\t\t     MAX_SKB_FRAGS)) {\n\t\t\t\tnet_warn_ratelimited(\n\t\t\t\t\t\"skb_segment: too many frags: %u %u\\n\",\n\t\t\t\t\tpos, mss);\n \t\t\t\tgoto err;\n \t\t\t}\n \n \t\t\t*nskb_frag = *frag;\n \t\t\t__skb_frag_ref(nskb_frag);\n \t\t\tsize = skb_frag_size(nskb_frag);\n\n\t\t\tif (pos < offset) {\n\t\t\t\tnskb_frag->page_offset += offset - pos;\n\t\t\t\tskb_frag_size_sub(nskb_frag, offset - pos);\n\t\t\t}\n\n\t\t\tskb_shinfo(nskb)->nr_frags++;\n\n\t\t\tif (pos + size <= offset + len) {\n\t\t\t\ti++;\n\t\t\t\tfrag++;\n\t\t\t\tpos += size;\n\t\t\t} else {\n\t\t\t\tskb_frag_size_sub(nskb_frag, pos + size - (offset + len));\n\t\t\t\tgoto skip_fraglist;\n\t\t\t}\n\n\t\t\tnskb_frag++;\n\t\t}\n\nskip_fraglist:\n\t\tnskb->data_len = len - hsize;\n\t\tnskb->len += nskb->data_len;\n\t\tnskb->truesize += nskb->data_len;\n\nperform_csum_check:\n\t\tif (!csum) {\n\t\t\tnskb->csum = skb_checksum(nskb, doffset,\n\t\t\t\t\t\t  nskb->len - doffset, 0);\n\t\t\tnskb->ip_summed = CHECKSUM_NONE;\n\t\t}\n\t} while ((offset += len) < head_skb->len);\n\n\treturn segs;\n\nerr:\n\tkfree_skb_list(segs);\n\treturn ERR_PTR(err);\n}\n", "target": 1, "idx": 179630}
{"func": "static long futex_wait_restart(struct restart_block *restart)\n{\n\tu32 __user *uaddr = (u32 __user *)restart->futex.uaddr;\n\tint fshared = 0;\n\tktime_t t, *tp = NULL;\n\n\tif (restart->futex.flags & FLAGS_HAS_TIMEOUT) {\n\t\tt.tv64 = restart->futex.time;\n\t\ttp = &t;\n\t}\n\trestart->fn = do_no_restart_syscall;\n\tif (restart->futex.flags & FLAGS_SHARED)\n\t\tfshared = 1;\n\treturn (long)futex_wait(uaddr, fshared, restart->futex.val, tp,\n\t\t\t\trestart->futex.bitset,\n\t\t\t\trestart->futex.flags & FLAGS_CLOCKRT);\n}\n", "target": 0, "idx": 39636}
{"func": "void VideoRendererBase::AttemptRead_Locked() {\n  lock_.AssertAcquired();\n  DCHECK_NE(kEnded, state_);\n\n  if (pending_read_ ||\n      NumFrames_Locked() == limits::kMaxVideoFrames ||\n      (!ready_frames_.empty() && ready_frames_.back()->IsEndOfStream()) ||\n      state_ == kFlushingDecoder ||\n      state_ == kFlushing) {\n    return;\n  }\n\n  pending_read_ = true;\n  decoder_->Read(base::Bind(&VideoRendererBase::FrameReady, this));\n}\n", "target": 0, "idx": 113348}
{"func": "static struct sock *tcp_v6_syn_recv_sock(const struct sock *sk, struct sk_buff *skb,\n\t\t\t\t\t struct request_sock *req,\n\t\t\t\t\t struct dst_entry *dst,\n\t\t\t\t\t struct request_sock *req_unhash,\n\t\t\t\t\t bool *own_req)\n{\n \tstruct inet_request_sock *ireq;\n \tstruct ipv6_pinfo *newnp;\n \tconst struct ipv6_pinfo *np = inet6_sk(sk);\n \tstruct tcp6_sock *newtcp6sk;\n \tstruct inet_sock *newinet;\n \tstruct tcp_sock *newtp;\n\tstruct sock *newsk;\n#ifdef CONFIG_TCP_MD5SIG\n\tstruct tcp_md5sig_key *key;\n#endif\n\tstruct flowi6 fl6;\n\n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\t/*\n\t\t *\tv6 mapped\n\t\t */\n\n\t\tnewsk = tcp_v4_syn_recv_sock(sk, skb, req, dst,\n\t\t\t\t\t     req_unhash, own_req);\n\n\t\tif (!newsk)\n\t\t\treturn NULL;\n\n\t\tnewtcp6sk = (struct tcp6_sock *)newsk;\n\t\tinet_sk(newsk)->pinet6 = &newtcp6sk->inet6;\n\n\t\tnewinet = inet_sk(newsk);\n\t\tnewnp = inet6_sk(newsk);\n\t\tnewtp = tcp_sk(newsk);\n\n\t\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\t\tnewnp->saddr = newsk->sk_v6_rcv_saddr;\n\n\t\tinet_csk(newsk)->icsk_af_ops = &ipv6_mapped;\n\t\tnewsk->sk_backlog_rcv = tcp_v4_do_rcv;\n#ifdef CONFIG_TCP_MD5SIG\n\t\tnewtp->af_specific = &tcp_sock_ipv6_mapped_specific;\n#endif\n\n\t\tnewnp->ipv6_ac_list = NULL;\n\t\tnewnp->ipv6_fl_list = NULL;\n\t\tnewnp->pktoptions  = NULL;\n\t\tnewnp->opt\t   = NULL;\n\t\tnewnp->mcast_oif   = tcp_v6_iif(skb);\n\t\tnewnp->mcast_hops  = ipv6_hdr(skb)->hop_limit;\n\t\tnewnp->rcv_flowinfo = ip6_flowinfo(ipv6_hdr(skb));\n\t\tif (np->repflow)\n\t\t\tnewnp->flow_label = ip6_flowlabel(ipv6_hdr(skb));\n\n\t\t/*\n\t\t * No need to charge this sock to the relevant IPv6 refcnt debug socks count\n\t\t * here, tcp_create_openreq_child now does this for us, see the comment in\n\t\t * that function for the gory details. -acme\n\t\t */\n\n\t\t/* It is tricky place. Until this moment IPv4 tcp\n\t\t   worked with IPv6 icsk.icsk_af_ops.\n\t\t   Sync it now.\n\t\t */\n\t\ttcp_sync_mss(newsk, inet_csk(newsk)->icsk_pmtu_cookie);\n\n\t\treturn newsk;\n\t}\n\n\tireq = inet_rsk(req);\n\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto out_overflow;\n\n\tif (!dst) {\n\t\tdst = inet6_csk_route_req(sk, &fl6, req, IPPROTO_TCP);\n\t\tif (!dst)\n\t\t\tgoto out;\n\t}\n\n\tnewsk = tcp_create_openreq_child(sk, req, skb);\n\tif (!newsk)\n\t\tgoto out_nonewsk;\n\n\t/*\n\t * No need to charge this sock to the relevant IPv6 refcnt debug socks\n\t * count here, tcp_create_openreq_child now does this for us, see the\n\t * comment in that function for the gory details. -acme\n\t */\n\n\tnewsk->sk_gso_type = SKB_GSO_TCPV6;\n\t__ip6_dst_store(newsk, dst, NULL, NULL);\n\tinet6_sk_rx_dst_set(newsk, skb);\n\n\tnewtcp6sk = (struct tcp6_sock *)newsk;\n\tinet_sk(newsk)->pinet6 = &newtcp6sk->inet6;\n\n\tnewtp = tcp_sk(newsk);\n\tnewinet = inet_sk(newsk);\n\tnewnp = inet6_sk(newsk);\n\n\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\tnewsk->sk_v6_daddr = ireq->ir_v6_rmt_addr;\n\tnewnp->saddr = ireq->ir_v6_loc_addr;\n\tnewsk->sk_v6_rcv_saddr = ireq->ir_v6_loc_addr;\n\tnewsk->sk_bound_dev_if = ireq->ir_iif;\n\n\t/* Now IPv6 options...\n\n\t   First: no IPv4 options.\n\t */\n\tnewinet->inet_opt = NULL;\n\tnewnp->ipv6_ac_list = NULL;\n\tnewnp->ipv6_fl_list = NULL;\n\n\t/* Clone RX bits */\n\tnewnp->rxopt.all = np->rxopt.all;\n\n\tnewnp->pktoptions = NULL;\n\tnewnp->opt\t  = NULL;\n\tnewnp->mcast_oif  = tcp_v6_iif(skb);\n\tnewnp->mcast_hops = ipv6_hdr(skb)->hop_limit;\n\tnewnp->rcv_flowinfo = ip6_flowinfo(ipv6_hdr(skb));\n\tif (np->repflow)\n\t\tnewnp->flow_label = ip6_flowlabel(ipv6_hdr(skb));\n\n\t/* Clone native IPv6 options from listening socket (if any)\n\n\t   Yes, keeping reference count would be much more clever,\n \t   but we make one more one thing there: reattach optmem\n \t   to newsk.\n \t */\n\tif (np->opt)\n\t\tnewnp->opt = ipv6_dup_options(newsk, np->opt);\n \tinet_csk(newsk)->icsk_ext_hdr_len = 0;\n\tif (newnp->opt)\n\t\tinet_csk(newsk)->icsk_ext_hdr_len = (newnp->opt->opt_nflen +\n\t\t\t\t\t\t     newnp->opt->opt_flen);\n \n \ttcp_ca_openreq_child(newsk, dst);\n \n\ttcp_sync_mss(newsk, dst_mtu(dst));\n\tnewtp->advmss = dst_metric_advmss(dst);\n\tif (tcp_sk(sk)->rx_opt.user_mss &&\n\t    tcp_sk(sk)->rx_opt.user_mss < newtp->advmss)\n\t\tnewtp->advmss = tcp_sk(sk)->rx_opt.user_mss;\n\n\ttcp_initialize_rcv_mss(newsk);\n\n\tnewinet->inet_daddr = newinet->inet_saddr = LOOPBACK4_IPV6;\n\tnewinet->inet_rcv_saddr = LOOPBACK4_IPV6;\n\n#ifdef CONFIG_TCP_MD5SIG\n\t/* Copy over the MD5 key from the original socket */\n\tkey = tcp_v6_md5_do_lookup(sk, &newsk->sk_v6_daddr);\n\tif (key) {\n\t\t/* We're using one, so create a matching key\n\t\t * on the newsk structure. If we fail to get\n\t\t * memory, then we end up not copying the key\n\t\t * across. Shucks.\n\t\t */\n\t\ttcp_md5_do_add(newsk, (union tcp_md5_addr *)&newsk->sk_v6_daddr,\n\t\t\t       AF_INET6, key->key, key->keylen,\n\t\t\t       sk_gfp_atomic(sk, GFP_ATOMIC));\n\t}\n#endif\n\n\tif (__inet_inherit_port(sk, newsk) < 0) {\n\t\tinet_csk_prepare_forced_close(newsk);\n\t\ttcp_done(newsk);\n\t\tgoto out;\n\t}\n\t*own_req = inet_ehash_nolisten(newsk, req_to_sk(req_unhash));\n\tif (*own_req) {\n\t\ttcp_move_syn(newtp, req);\n\n\t\t/* Clone pktoptions received with SYN, if we own the req */\n\t\tif (ireq->pktopts) {\n\t\t\tnewnp->pktoptions = skb_clone(ireq->pktopts,\n\t\t\t\t\t\t      sk_gfp_atomic(sk, GFP_ATOMIC));\n\t\t\tconsume_skb(ireq->pktopts);\n\t\t\tireq->pktopts = NULL;\n\t\t\tif (newnp->pktoptions)\n\t\t\t\tskb_set_owner_r(newnp->pktoptions, newsk);\n\t\t}\n\t}\n\n\treturn newsk;\n\nout_overflow:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nout_nonewsk:\n\tdst_release(dst);\nout:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS);\n\treturn NULL;\n}\n", "target": 1, "idx": 180514}
{"func": " static int sgi_clock_set(clockid_t clockid, struct timespec *tp)\n {\n \n \tu64 nsec;\n\tu64 rem;\n \n \tnsec = rtc_time() * sgi_clock_period;\n \n\tsgi_clock_offset.tv_sec = tp->tv_sec - div_long_long_rem(nsec, NSEC_PER_SEC, &rem);\n \n \tif (rem <= tp->tv_nsec)\n \t\tsgi_clock_offset.tv_nsec = tp->tv_sec - rem;\n\telse {\n\t\tsgi_clock_offset.tv_nsec = tp->tv_sec + NSEC_PER_SEC - rem;\n\t\tsgi_clock_offset.tv_sec--;\n\t}\n\treturn 0;\n}\n", "target": 1, "idx": 178922}
{"func": " void SyncManager::SyncInternal::OnIPAddressChangedImpl() {\n   DCHECK(thread_checker_.CalledOnValidThread());\n  connection_manager()->CheckServerReachable();\n }\n", "target": 1, "idx": 183718}
{"func": "static int map_str_to_val(const struct aiptek_map *map, const char *str, size_t count)\n{\n\tconst struct aiptek_map *p;\n\n\tif (str[count - 1] == '\\n')\n\t\tcount--;\n\n\tfor (p = map; p->string; p++)\n\t        if (!strncmp(str, p->string, count))\n\t\t\treturn p->value;\n\n\treturn AIPTEK_INVALID_VALUE;\n}\n", "target": 0, "idx": 57627}
{"func": "static void aes_encrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)\n{\n\tstruct crypto_sparc64_aes_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tctx->ops->encrypt(&ctx->key[0], (const u32 *) src, (u32 *) dst);\n}\n", "target": 0, "idx": 46728}
{"func": " image_transform_png_set_strip_16_add(image_transform *this,\n    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)\n {\n    UNUSED(colour_type)\n \n this->next = *that;\n *that = this;\n\n return bit_depth > 8;\n}\n", "target": 1, "idx": 187670}
{"func": "void CL_Init( void ) {\n\tCom_Printf( \"----- Client Initialization -----\\n\" );\n\n\tCon_Init ();\n\n\tif(!com_fullyInitialized)\n\t{\n\t\tCL_ClearState();\n\t\tclc.state = CA_DISCONNECTED;\t// no longer CA_UNINITIALIZED\n\t\tcl_oldGameSet = qfalse;\n\t}\n\n\tcls.realtime = 0;\n\n\tCL_InitInput ();\n\n\tcl_noprint = Cvar_Get( \"cl_noprint\", \"0\", 0 );\n#ifdef UPDATE_SERVER_NAME\n\tcl_motd = Cvar_Get (\"cl_motd\", \"1\", 0);\n#endif\n\n\tcl_timeout = Cvar_Get (\"cl_timeout\", \"200\", 0);\n\n\tcl_timeNudge = Cvar_Get (\"cl_timeNudge\", \"0\", CVAR_TEMP );\n\tcl_shownet = Cvar_Get (\"cl_shownet\", \"0\", CVAR_TEMP );\n\tcl_showSend = Cvar_Get (\"cl_showSend\", \"0\", CVAR_TEMP );\n\tcl_showTimeDelta = Cvar_Get (\"cl_showTimeDelta\", \"0\", CVAR_TEMP );\n\tcl_freezeDemo = Cvar_Get (\"cl_freezeDemo\", \"0\", CVAR_TEMP );\n\trcon_client_password = Cvar_Get (\"rconPassword\", \"\", CVAR_TEMP );\n\tcl_activeAction = Cvar_Get( \"activeAction\", \"\", CVAR_TEMP );\n\n\tcl_timedemo = Cvar_Get (\"timedemo\", \"0\", 0);\n\tcl_timedemoLog = Cvar_Get (\"cl_timedemoLog\", \"\", CVAR_ARCHIVE);\n\tcl_autoRecordDemo = Cvar_Get (\"cl_autoRecordDemo\", \"0\", CVAR_ARCHIVE);\n\tcl_aviFrameRate = Cvar_Get (\"cl_aviFrameRate\", \"25\", CVAR_ARCHIVE);\n\tcl_aviMotionJpeg = Cvar_Get (\"cl_aviMotionJpeg\", \"1\", CVAR_ARCHIVE);\n\tcl_forceavidemo = Cvar_Get (\"cl_forceavidemo\", \"0\", 0);\n\n\trconAddress = Cvar_Get (\"rconAddress\", \"\", 0);\n\n\tcl_yawspeed = Cvar_Get (\"cl_yawspeed\", \"140\", CVAR_ARCHIVE);\n\tcl_pitchspeed = Cvar_Get (\"cl_pitchspeed\", \"140\", CVAR_ARCHIVE);\n\tcl_anglespeedkey = Cvar_Get (\"cl_anglespeedkey\", \"1.5\", 0);\n\n\tcl_maxpackets = Cvar_Get (\"cl_maxpackets\", \"30\", CVAR_ARCHIVE );\n\tcl_packetdup = Cvar_Get (\"cl_packetdup\", \"1\", CVAR_ARCHIVE );\n\n\tcl_run = Cvar_Get (\"cl_run\", \"1\", CVAR_ARCHIVE);\n\tcl_sensitivity = Cvar_Get (\"sensitivity\", \"5\", CVAR_ARCHIVE);\n\tcl_mouseAccel = Cvar_Get (\"cl_mouseAccel\", \"0\", CVAR_ARCHIVE);\n\tcl_freelook = Cvar_Get( \"cl_freelook\", \"1\", CVAR_ARCHIVE );\n\n\tcl_mouseAccelStyle = Cvar_Get( \"cl_mouseAccelStyle\", \"0\", CVAR_ARCHIVE );\n\tcl_mouseAccelOffset = Cvar_Get( \"cl_mouseAccelOffset\", \"5\", CVAR_ARCHIVE );\n\tCvar_CheckRange(cl_mouseAccelOffset, 0.001f, 50000.0f, qfalse);\n\n\tcl_showMouseRate = Cvar_Get (\"cl_showmouserate\", \"0\", 0);\n \n \tcl_allowDownload = Cvar_Get (\"cl_allowDownload\", \"0\", CVAR_ARCHIVE);\n #ifdef USE_CURL_DLOPEN\n\tcl_cURLLib = Cvar_Get(\"cl_cURLLib\", DEFAULT_CURL_LIB, CVAR_ARCHIVE);\n #endif\n \n \tcl_conXOffset = Cvar_Get (\"cl_conXOffset\", \"0\", 0);\n#ifdef __APPLE__\n\tcl_inGameVideo = Cvar_Get (\"r_inGameVideo\", \"0\", CVAR_ARCHIVE);\n#else\n\tcl_inGameVideo = Cvar_Get (\"r_inGameVideo\", \"1\", CVAR_ARCHIVE);\n#endif\n\n\tcl_serverStatusResendTime = Cvar_Get (\"cl_serverStatusResendTime\", \"750\", 0);\n\n\tCvar_Get (\"cg_autoswitch\", \"1\", CVAR_ARCHIVE);\n\n\tm_pitch = Cvar_Get (\"m_pitch\", \"0.022\", CVAR_ARCHIVE);\n\tm_yaw = Cvar_Get (\"m_yaw\", \"0.022\", CVAR_ARCHIVE);\n\tm_forward = Cvar_Get (\"m_forward\", \"0.25\", CVAR_ARCHIVE);\n\tm_side = Cvar_Get (\"m_side\", \"0.25\", CVAR_ARCHIVE);\n#ifdef __APPLE__\n\tm_filter = Cvar_Get (\"m_filter\", \"1\", CVAR_ARCHIVE);\n#else\n\tm_filter = Cvar_Get (\"m_filter\", \"0\", CVAR_ARCHIVE);\n#endif\n\n\tj_pitch =        Cvar_Get (\"j_pitch\",        \"0.022\", CVAR_ARCHIVE);\n\tj_yaw =          Cvar_Get (\"j_yaw\",          \"-0.022\", CVAR_ARCHIVE);\n\tj_forward =      Cvar_Get (\"j_forward\",      \"-0.25\", CVAR_ARCHIVE);\n\tj_side =         Cvar_Get (\"j_side\",         \"0.25\", CVAR_ARCHIVE);\n\tj_up =           Cvar_Get (\"j_up\",           \"0\", CVAR_ARCHIVE);\n\n\tj_pitch_axis =   Cvar_Get (\"j_pitch_axis\",   \"3\", CVAR_ARCHIVE);\n\tj_yaw_axis =     Cvar_Get (\"j_yaw_axis\",     \"2\", CVAR_ARCHIVE);\n\tj_forward_axis = Cvar_Get (\"j_forward_axis\", \"1\", CVAR_ARCHIVE);\n\tj_side_axis =    Cvar_Get (\"j_side_axis\",    \"0\", CVAR_ARCHIVE);\n\tj_up_axis =      Cvar_Get (\"j_up_axis\",      \"4\", CVAR_ARCHIVE);\n\n\tCvar_CheckRange(j_pitch_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);\n\tCvar_CheckRange(j_yaw_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);\n\tCvar_CheckRange(j_forward_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);\n\tCvar_CheckRange(j_side_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);\n\tCvar_CheckRange(j_up_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue);\n\n\tcl_motdString = Cvar_Get( \"cl_motdString\", \"\", CVAR_ROM );\n\n\tCvar_Get( \"cl_maxPing\", \"800\", CVAR_ARCHIVE );\n\n\tcl_lanForcePackets = Cvar_Get (\"cl_lanForcePackets\", \"1\", CVAR_ARCHIVE);\n\n\tcl_guidServerUniq = Cvar_Get (\"cl_guidServerUniq\", \"1\", CVAR_ARCHIVE);\n\n\tcl_consoleKeys = Cvar_Get( \"cl_consoleKeys\", \"~ ` 0x7e 0x60\", CVAR_ARCHIVE);\n\n\tCvar_Get (\"name\", \"UnnamedPlayer\", CVAR_USERINFO | CVAR_ARCHIVE );\n\tcl_rate = Cvar_Get (\"rate\", \"25000\", CVAR_USERINFO | CVAR_ARCHIVE );\n\tCvar_Get (\"snaps\", \"20\", CVAR_USERINFO | CVAR_ARCHIVE );\n\tCvar_Get (\"model\", \"sarge\", CVAR_USERINFO | CVAR_ARCHIVE );\n\tCvar_Get (\"headmodel\", \"sarge\", CVAR_USERINFO | CVAR_ARCHIVE );\n\tCvar_Get (\"team_model\", \"james\", CVAR_USERINFO | CVAR_ARCHIVE );\n\tCvar_Get (\"team_headmodel\", \"*james\", CVAR_USERINFO | CVAR_ARCHIVE );\n\tCvar_Get (\"g_redTeam\", \"Stroggs\", CVAR_SERVERINFO | CVAR_ARCHIVE);\n\tCvar_Get (\"g_blueTeam\", \"Pagans\", CVAR_SERVERINFO | CVAR_ARCHIVE);\n\tCvar_Get (\"color1\",  \"4\", CVAR_USERINFO | CVAR_ARCHIVE );\n\tCvar_Get (\"color2\", \"5\", CVAR_USERINFO | CVAR_ARCHIVE );\n\tCvar_Get (\"handicap\", \"100\", CVAR_USERINFO | CVAR_ARCHIVE );\n\tCvar_Get (\"teamtask\", \"0\", CVAR_USERINFO );\n\tCvar_Get (\"sex\", \"male\", CVAR_USERINFO | CVAR_ARCHIVE );\n\tCvar_Get (\"cl_anonymous\", \"0\", CVAR_USERINFO | CVAR_ARCHIVE );\n\n\tCvar_Get (\"password\", \"\", CVAR_USERINFO);\n\tCvar_Get (\"cg_predictItems\", \"1\", CVAR_USERINFO | CVAR_ARCHIVE );\n\n#ifdef USE_MUMBLE\n\tcl_useMumble = Cvar_Get (\"cl_useMumble\", \"0\", CVAR_ARCHIVE | CVAR_LATCH);\n\tcl_mumbleScale = Cvar_Get (\"cl_mumbleScale\", \"0.0254\", CVAR_ARCHIVE);\n#endif\n\n#ifdef USE_VOIP\n\tcl_voipSend = Cvar_Get (\"cl_voipSend\", \"0\", 0);\n\tcl_voipSendTarget = Cvar_Get (\"cl_voipSendTarget\", \"spatial\", 0);\n\tcl_voipGainDuringCapture = Cvar_Get (\"cl_voipGainDuringCapture\", \"0.2\", CVAR_ARCHIVE);\n\tcl_voipCaptureMult = Cvar_Get (\"cl_voipCaptureMult\", \"2.0\", CVAR_ARCHIVE);\n\tcl_voipUseVAD = Cvar_Get (\"cl_voipUseVAD\", \"0\", CVAR_ARCHIVE);\n\tcl_voipVADThreshold = Cvar_Get (\"cl_voipVADThreshold\", \"0.25\", CVAR_ARCHIVE);\n\tcl_voipShowMeter = Cvar_Get (\"cl_voipShowMeter\", \"1\", CVAR_ARCHIVE);\n\n\tcl_voip = Cvar_Get (\"cl_voip\", \"1\", CVAR_ARCHIVE);\n\tCvar_CheckRange( cl_voip, 0, 1, qtrue );\n\tcl_voipProtocol = Cvar_Get (\"cl_voipProtocol\", cl_voip->integer ? \"opus\" : \"\", CVAR_USERINFO | CVAR_ROM);\n#endif\n\n\n\tCvar_Get (\"cg_viewsize\", \"100\", CVAR_ARCHIVE );\n\tCvar_Get (\"cg_stereoSeparation\", \"0\", CVAR_ROM);\n\n\tCmd_AddCommand (\"cmd\", CL_ForwardToServer_f);\n\tCmd_AddCommand (\"configstrings\", CL_Configstrings_f);\n\tCmd_AddCommand (\"clientinfo\", CL_Clientinfo_f);\n\tCmd_AddCommand (\"snd_restart\", CL_Snd_Restart_f);\n\tCmd_AddCommand (\"vid_restart\", CL_Vid_Restart_f);\n\tCmd_AddCommand (\"disconnect\", CL_Disconnect_f);\n\tCmd_AddCommand (\"record\", CL_Record_f);\n\tCmd_AddCommand (\"demo\", CL_PlayDemo_f);\n\tCmd_SetCommandCompletionFunc( \"demo\", CL_CompleteDemoName );\n\tCmd_AddCommand (\"cinematic\", CL_PlayCinematic_f);\n\tCmd_AddCommand (\"stoprecord\", CL_StopRecord_f);\n\tCmd_AddCommand (\"connect\", CL_Connect_f);\n\tCmd_AddCommand (\"reconnect\", CL_Reconnect_f);\n\tCmd_AddCommand (\"localservers\", CL_LocalServers_f);\n\tCmd_AddCommand (\"globalservers\", CL_GlobalServers_f);\n\tCmd_AddCommand (\"rcon\", CL_Rcon_f);\n\tCmd_SetCommandCompletionFunc( \"rcon\", CL_CompleteRcon );\n\tCmd_AddCommand (\"ping\", CL_Ping_f );\n\tCmd_AddCommand (\"serverstatus\", CL_ServerStatus_f );\n\tCmd_AddCommand (\"showip\", CL_ShowIP_f );\n\tCmd_AddCommand (\"fs_openedList\", CL_OpenedPK3List_f );\n\tCmd_AddCommand (\"fs_referencedList\", CL_ReferencedPK3List_f );\n\tCmd_AddCommand (\"model\", CL_SetModel_f );\n\tCmd_AddCommand (\"video\", CL_Video_f );\n\tCmd_AddCommand (\"stopvideo\", CL_StopVideo_f );\n\tif( !com_dedicated->integer ) {\n\t\tCmd_AddCommand (\"sayto\", CL_Sayto_f );\n\t\tCmd_SetCommandCompletionFunc( \"sayto\", CL_CompletePlayerName );\n\t}\n\tCL_InitRef();\n\n\tSCR_Init ();\n\n\n\tCvar_Set( \"cl_running\", \"1\" );\n\n\tCL_GenerateQKey();\n\tCvar_Get( \"cl_guid\", \"\", CVAR_USERINFO | CVAR_ROM );\n\tCL_UpdateGUID( NULL, 0 );\n\n\tCom_Printf( \"----- Client Initialization Complete -----\\n\" );\n}\n", "target": 1, "idx": 183260}
{"func": "void update_rate_histogram(struct rate_hist *hist,\n const vpx_codec_enc_cfg_t *cfg,\n const vpx_codec_cx_pkt_t *pkt) {\n int i;\n int64_t then = 0;\n int64_t avg_bitrate = 0;\n int64_t sum_sz = 0;\n const int64_t now = pkt->data.frame.pts * 1000 *\n (uint64_t)cfg->g_timebase.num /\n (uint64_t)cfg->g_timebase.den;\n\n int idx = hist->frames++ % hist->samples;\n  hist->pts[idx] = now;\n  hist->sz[idx] = (int)pkt->data.frame.sz;\n\n\n   if (now < cfg->rc_buf_initial_sz)\n     return;\n \n   then = now;\n \n   /* Sum the size over the past rc_buf_sz ms */\n for (i = hist->frames; i > 0 && hist->frames - i < hist->samples; i--) {\n const int i_idx = (i - 1) % hist->samples;\n\n    then = hist->pts[i_idx];\n if (now - then > cfg->rc_buf_sz)\n break;\n    sum_sz += hist->sz[i_idx];\n }\n\n if (now == then)\n return;\n\n  avg_bitrate = sum_sz * 8 * 1000 / (now - then);\n  idx = (int)(avg_bitrate * (RATE_BINS / 2) / (cfg->rc_target_bitrate * 1000));\n if (idx < 0)\n    idx = 0;\n if (idx > RATE_BINS - 1)\n    idx = RATE_BINS - 1;\n if (hist->bucket[idx].low > avg_bitrate)\n    hist->bucket[idx].low = (int)avg_bitrate;\n if (hist->bucket[idx].high < avg_bitrate)\n    hist->bucket[idx].high = (int)avg_bitrate;\n  hist->bucket[idx].count++;\n  hist->total++;\n}\n", "target": 1, "idx": 188522}
{"func": "static void vapic_exit(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tint idx;\n\tif (!apic || !apic->vapic_addr)\n\t\treturn;\n\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\tkvm_release_page_dirty(apic->vapic_page);\n\tmark_page_dirty(vcpu->kvm, apic->vapic_addr >> PAGE_SHIFT);\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n}\n", "target": 1, "idx": 179122}
{"func": "parse_instruction_ids(struct ofpbuf *payload, bool loose, uint32_t *insts)\n{\n    *insts = 0;\n    while (payload->size > 0) {\n        enum ovs_instruction_type inst;\n        enum ofperr error;\n        uint64_t ofpit;\n\n        /* OF1.3 and OF1.4 aren't clear about padding in the instruction IDs.\n         * It seems clear that they aren't padded to 8 bytes, though, because\n         * both standards say that \"non-experimenter instructions are 4 bytes\"\n         * and do not mention any padding before the first instruction ID.\n         * (There wouldn't be any point in padding to 8 bytes if the IDs were\n         * aligned on an odd 4-byte boundary.)\n         *\n         * Anyway, we just assume they're all glommed together on byte\n         * boundaries. */\n        error = ofpprop_pull__(payload, NULL, 1, 0x10000, &ofpit);\n        if (error) {\n            return error;\n        }\n\n        error = ovs_instruction_type_from_inst_type(&inst, ofpit);\n        if (!error) {\n            *insts |= 1u << inst;\n        } else if (!loose) {\n            return error;\n        }\n    }\n    return 0;\n}\n", "target": 0, "idx": 77723}
{"func": "RenderProcessHost* RenderProcessHostImpl::CreateRenderProcessHost(\n    BrowserContext* browser_context,\n    StoragePartitionImpl* storage_partition_impl,\n    SiteInstance* site_instance,\n    bool is_for_guests_only) {\n  if (g_render_process_host_factory_) {\n    return g_render_process_host_factory_->CreateRenderProcessHost(\n        browser_context, site_instance);\n  }\n\n  if (!storage_partition_impl) {\n    storage_partition_impl = static_cast<StoragePartitionImpl*>(\n        BrowserContext::GetStoragePartition(browser_context, site_instance));\n  }\n  if (is_for_guests_only && site_instance &&\n      storage_partition_impl->site_for_service_worker().is_empty()) {\n    storage_partition_impl->set_site_for_service_worker(\n        site_instance->GetSiteURL());\n  }\n\n  return new RenderProcessHostImpl(browser_context, storage_partition_impl,\n                                   is_for_guests_only);\n}\n", "target": 0, "idx": 162067}
{"func": "void PrintNativeHandler::Print(\n    const v8::FunctionCallbackInfo<v8::Value>& args) {\n  if (args.Length() < 1)\n    return;\n\n  std::vector<std::string> components;\n  for (int i = 0; i < args.Length(); ++i)\n    components.push_back(*v8::String::Utf8Value(args[i]));\n\n  LOG(ERROR) << base::JoinString(components, \",\");\n}\n", "target": 0, "idx": 145303}
{"func": "static inline int mk_vhost_fdt_open(int id, unsigned int hash,\n                                    struct session_request *sr)\n{\n    int i;\n    int fd;\n    struct vhost_fdt_hash_table *ht = NULL;\n    struct vhost_fdt_hash_chain *hc;\n\n    if (config->fdt == MK_FALSE) {\n        return open(sr->real_path.data, sr->file_info.flags_read_only);\n    }\n\n    ht = mk_vhost_fdt_table_lookup(id, sr->host_conf);\n    if (mk_unlikely(!ht)) {\n        return open(sr->real_path.data, sr->file_info.flags_read_only);\n    }\n\n    /* We got the hash table, now look around the chains array */\n    hc = mk_vhost_fdt_chain_lookup(hash, ht);\n    if (hc) {\n        /* Increment the readers and return the shared FD */\n        hc->readers++;\n        return hc->fd;\n    }\n\n    /*\n     * Get here means that no entry exists in the hash table for the\n     * requested file descriptor and hash, we must try to open the file\n     * and register the entry in the table.\n     */\n    fd = open(sr->real_path.data, sr->file_info.flags_read_only);\n    if (fd == -1) {\n        return -1;\n    }\n\n    /* If chains are full, just return the new FD, bad luck... */\n    if (ht->av_slots <= 0) {\n        return fd;\n    }\n\n    /* Register the new entry in an available slot */\n    for (i = 0; i < VHOST_FDT_HASHTABLE_CHAINS; i++) {\n        hc = &ht->chain[i];\n        if (hc->fd == -1) {\n            hc->fd   = fd;\n            hc->hash = hash;\n            hc->readers++;\n            ht->av_slots--;\n \n             sr->vhost_fdt_id   = id;\n             sr->vhost_fdt_hash = hash;\n \n             return fd;\n         }\n    }\n\n    return -1;\n}\n", "target": 1, "idx": 179451}
{"func": "vhost_scsi_send_evt(struct vhost_scsi *vs,\n\t\t   struct vhost_scsi_tpg *tpg,\n\t\t   struct se_lun *lun,\n\t\t   u32 event,\n\t\t   u32 reason)\n{\n\tstruct vhost_scsi_evt *evt;\n\n\tevt = vhost_scsi_allocate_evt(vs, event, reason);\n\tif (!evt)\n\t\treturn;\n\n\tif (tpg && lun) {\n\t\t/* TODO: share lun setup code with virtio-scsi.ko */\n\t\t/*\n\t\t * Note: evt->event is zeroed when we allocate it and\n \t\t * lun[4-7] need to be zero according to virtio-scsi spec.\n \t\t */\n \t\tevt->event.lun[0] = 0x01;\n\t\tevt->event.lun[1] = tpg->tport_tpgt & 0xFF;\n \t\tif (lun->unpacked_lun >= 256)\n \t\t\tevt->event.lun[2] = lun->unpacked_lun >> 8 | 0x40 ;\n \t\tevt->event.lun[3] = lun->unpacked_lun & 0xFF;\n\t}\n\n\tllist_add(&evt->list, &vs->vs_event_list);\n\tvhost_work_queue(&vs->dev, &vs->vs_event_work);\n}\n", "target": 1, "idx": 179788}
{"func": "static int sctp_getsockopt_peer_addr_params(struct sock *sk, int len,\n\t\t\t\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct sctp_paddrparams  params;\n\tstruct sctp_transport   *trans = NULL;\n\tstruct sctp_association *asoc = NULL;\n\tstruct sctp_sock        *sp = sctp_sk(sk);\n\n\tif (len < sizeof(struct sctp_paddrparams))\n\t\treturn -EINVAL;\n\tlen = sizeof(struct sctp_paddrparams);\n\tif (copy_from_user(&params, optval, len))\n\t\treturn -EFAULT;\n\n\t/* If an address other than INADDR_ANY is specified, and\n\t * no transport is found, then the request is invalid.\n\t */\n\tif (!sctp_is_any(sk, (union sctp_addr *)&params.spp_address)) {\n\t\ttrans = sctp_addr_id2transport(sk, &params.spp_address,\n\t\t\t\t\t       params.spp_assoc_id);\n\t\tif (!trans) {\n\t\t\tpr_debug(\"%s: failed no transport\\n\", __func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* Get association, if assoc_id != 0 and the socket is a one\n\t * to many style socket, and an association was not found, then\n\t * the id was invalid.\n\t */\n\tasoc = sctp_id2assoc(sk, params.spp_assoc_id);\n\tif (!asoc && params.spp_assoc_id && sctp_style(sk, UDP)) {\n\t\tpr_debug(\"%s: failed no association\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (trans) {\n\t\t/* Fetch transport values. */\n\t\tparams.spp_hbinterval = jiffies_to_msecs(trans->hbinterval);\n\t\tparams.spp_pathmtu    = trans->pathmtu;\n\t\tparams.spp_pathmaxrxt = trans->pathmaxrxt;\n\t\tparams.spp_sackdelay  = jiffies_to_msecs(trans->sackdelay);\n\n\t\t/*draft-11 doesn't say what to return in spp_flags*/\n\t\tparams.spp_flags      = trans->param_flags;\n\t} else if (asoc) {\n\t\t/* Fetch association values. */\n\t\tparams.spp_hbinterval = jiffies_to_msecs(asoc->hbinterval);\n\t\tparams.spp_pathmtu    = asoc->pathmtu;\n\t\tparams.spp_pathmaxrxt = asoc->pathmaxrxt;\n\t\tparams.spp_sackdelay  = jiffies_to_msecs(asoc->sackdelay);\n\n\t\t/*draft-11 doesn't say what to return in spp_flags*/\n\t\tparams.spp_flags      = asoc->param_flags;\n\t} else {\n\t\t/* Fetch socket values. */\n\t\tparams.spp_hbinterval = sp->hbinterval;\n\t\tparams.spp_pathmtu    = sp->pathmtu;\n\t\tparams.spp_sackdelay  = sp->sackdelay;\n\t\tparams.spp_pathmaxrxt = sp->pathmaxrxt;\n\n\t\t/*draft-11 doesn't say what to return in spp_flags*/\n\t\tparams.spp_flags      = sp->param_flags;\n\t}\n\n\tif (copy_to_user(optval, &params, len))\n\t\treturn -EFAULT;\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n", "target": 0, "idx": 43545}
{"func": "dissect_spoolss_keybuffer(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t  proto_tree *tree, dcerpc_info *di, guint8 *drep)\n{\n\tguint32 size;\n\tint end_offset;\n\n\tif (di->conformant_run)\n\t\treturn offset;\n\n\t/* Dissect size and data */\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\n\t\t\t\t    hf_keybuffer_size, &size);\n\n\tend_offset = offset + (size*2);\n\tif (end_offset < offset) {\n\t\t/*\n\t\t * Overflow - make the end offset one past the end of\n\t\t * the packet data, so we throw an exception (as the\n\t\t * size is almost certainly too big).\n\t\t */\n \t\tend_offset = tvb_reported_length_remaining(tvb, offset) + 1;\n \t}\n \n\twhile (offset < end_offset)\n \t\toffset = dissect_spoolss_uint16uni(\n \t\t\ttvb, offset, pinfo, tree, drep, NULL, hf_keybuffer);\n \n \treturn offset;\n }\n", "target": 1, "idx": 180331}
{"func": "static void TestObjectConstructorGetter(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)\n{\n    v8::Handle<v8::Value> data = info.Data();\n    ASSERT(data->IsExternal());\n    V8PerContextData* perContextData = V8PerContextData::from(info.Holder()->CreationContext());\n    if (!perContextData)\n        return;\n    v8SetReturnValue(info, perContextData->constructorForType(WrapperTypeInfo::unwrap(data)));\n}\n", "target": 0, "idx": 130556}
{"func": "OMX::OMX()\n : mMaster(new OMXMaster),\n      mNodeCounter(0) {\n}\n", "target": 0, "idx": 174131}
{"func": " void PartialMagnificationController::OnWidgetDestroying(views::Widget* widget) {\n  DCHECK_EQ(widget, zoom_widget_);\n   RemoveZoomWidgetObservers();\n  zoom_widget_ = NULL;\n }\n", "target": 1, "idx": 185516}
{"func": "compile_string_raw_node(StrNode* sn, regex_t* reg)\n{\n  if (sn->end <= sn->s)\n    return 0;\n\n  return add_compile_string(sn->s, 1 /* sb */, (int )(sn->end - sn->s), reg, 0);\n}\n", "target": 0, "idx": 89138}
{"func": "ShelfLayoutManager* GetShelfLayoutManager() {\n  return AshTestBase::GetPrimaryShelf()->shelf_layout_manager();\n}\n", "target": 0, "idx": 142507}
{"func": "sector_t swapdev_block(int type, pgoff_t offset)\n{\n\tstruct block_device *bdev;\n\n\tif ((unsigned int)type >= nr_swapfiles)\n\t\treturn 0;\n\tif (!(swap_info[type]->flags & SWP_WRITEOK))\n\t\treturn 0;\n\treturn map_swap_entry(swp_entry(type, offset), &bdev);\n}\n", "target": 0, "idx": 21416}
{"func": "static int sha256_sparc64_export(struct shash_desc *desc, void *out)\n{\n\tstruct sha256_state *sctx = shash_desc_ctx(desc);\n\n\tmemcpy(out, sctx, sizeof(*sctx));\n\treturn 0;\n}\n", "target": 0, "idx": 46798}
{"func": "  void Wait() {\n    message_loop_runner_->Run();\n  }\n", "target": 0, "idx": 158156}
{"func": " bool IsTraceEventArgsWhitelisted(const char* category_group_name,\n                                 const char* event_name) {\n   if (base::MatchPattern(category_group_name, \"toplevel\") &&\n       base::MatchPattern(event_name, \"*\")) {\n     return true;\n   }\n \n   return false;\n }\n", "target": 1, "idx": 185383}
{"func": "unsigned venc_dev::venc_flush( unsigned port)\n{\n struct v4l2_encoder_cmd enc;\n    DEBUG_PRINT_LOW(\"in %s\", __func__);\n\n    enc.cmd = V4L2_ENC_QCOM_CMD_FLUSH;\n    enc.flags = V4L2_QCOM_CMD_FLUSH_OUTPUT | V4L2_QCOM_CMD_FLUSH_CAPTURE;\n\n if (ioctl(m_nDriver_fd, VIDIOC_ENCODER_CMD, &enc)) {\n        DEBUG_PRINT_ERROR(\"Flush Port (%d) Failed \", port);\n return -1;\n }\n\n return 0;\n\n}\n", "target": 0, "idx": 172432}
{"func": "PasswordAutofillAgent::PasswordAutofillAgent(content::RenderFrame* render_frame)\n     : content::RenderFrameObserver(render_frame),\n       logging_state_active_(false),\n       was_username_autofilled_(false),\n      was_password_autofilled_(false),\n      weak_ptr_factory_(this) {\n   Send(new AutofillHostMsg_PasswordAutofillAgentConstructed(routing_id()));\n }\n", "target": 1, "idx": 187356}
{"func": "static vpx_codec_err_t vp8_decode(vpx_codec_alg_priv_t *ctx,\n const uint8_t *data,\n unsigned int            data_sz,\n void *user_priv,\n long                    deadline)\n{\n vpx_codec_err_t res = VPX_CODEC_OK;\n unsigned int resolution_change = 0;\n unsigned int w, h;\n\n if (!ctx->fragments.enabled && (data == NULL && data_sz == 0))\n {\n return 0;\n }\n\n /* Update the input fragment data */\n if(update_fragments(ctx, data, data_sz, &res) <= 0)\n return res;\n\n /* Determine the stream parameters. Note that we rely on peek_si to\n     * validate that we have a buffer that does not wrap around the top\n     * of the heap.\n     */\n    w = ctx->si.w;\n    h = ctx->si.h;\n\n    res = vp8_peek_si_internal(ctx->fragments.ptrs[0], ctx->fragments.sizes[0],\n &ctx->si, ctx->decrypt_cb, ctx->decrypt_state);\n\n if((res == VPX_CODEC_UNSUP_BITSTREAM) && !ctx->si.is_kf)\n {\n /* the peek function returns an error for non keyframes, however for\n         * this case, it is not an error */\n        res = VPX_CODEC_OK;\n }\n\n if(!ctx->decoder_init && !ctx->si.is_kf)\n        res = VPX_CODEC_UNSUP_BITSTREAM;\n\n if ((ctx->si.h != h) || (ctx->si.w != w))\n        resolution_change = 1;\n\n /* Initialize the decoder instance on the first frame*/\n if (!res && !ctx->decoder_init)\n {\n      VP8D_CONFIG oxcf;\n\n      oxcf.Width = ctx->si.w;\n      oxcf.Height = ctx->si.h;\n      oxcf.Version = 9;\n      oxcf.postprocess = 0;\n      oxcf.max_threads = ctx->cfg.threads;\n      oxcf.error_concealment =\n (ctx->base.init_flags & VPX_CODEC_USE_ERROR_CONCEALMENT);\n\n /* If postprocessing was enabled by the application and a\n       * configuration has not been provided, default it.\n       */\n if (!ctx->postproc_cfg_set\n && (ctx->base.init_flags & VPX_CODEC_USE_POSTPROC)) {\n         ctx->postproc_cfg.post_proc_flag =\n             VP8_DEBLOCK | VP8_DEMACROBLOCK | VP8_MFQE;\n         ctx->postproc_cfg.deblocking_level = 4;\n         ctx->postproc_cfg.noise_level = 0;\n }\n\n       res = vp8_create_decoder_instances(&ctx->yv12_frame_buffers, &oxcf);\n       ctx->decoder_init = 1;\n }\n\n /* Set these even if already initialized.  The caller may have changed the\n     * decrypt config between frames.\n     */\n if (ctx->decoder_init) {\n      ctx->yv12_frame_buffers.pbi[0]->decrypt_cb = ctx->decrypt_cb;\n      ctx->yv12_frame_buffers.pbi[0]->decrypt_state = ctx->decrypt_state;\n }\n\n if (!res)\n {\n        VP8D_COMP *pbi = ctx->yv12_frame_buffers.pbi[0];\n if (resolution_change)\n {\n            VP8_COMMON *const pc = & pbi->common;\n            MACROBLOCKD *const xd  = & pbi->mb;\n#if CONFIG_MULTITHREAD\n int i;\n#endif\n            pc->Width = ctx->si.w;\n            pc->Height = ctx->si.h;\n {\n int prev_mb_rows = pc->mb_rows;\n\n\n                 if (setjmp(pbi->common.error.jmp))\n                 {\n                     pbi->common.error.setjmp = 0;\n                     vp8_clear_system_state();\n                     /* same return value as used in vp8dx_receive_compressed_data */\n                     return -1;\n }\n\n                pbi->common.error.setjmp = 1;\n\n if (pc->Width <= 0)\n {\n                    pc->Width = w;\n                    vpx_internal_error(&pc->error, VPX_CODEC_CORRUPT_FRAME,\n \"Invalid frame width\");\n }\n\n if (pc->Height <= 0)\n {\n                    pc->Height = h;\n                    vpx_internal_error(&pc->error, VPX_CODEC_CORRUPT_FRAME,\n \"Invalid frame height\");\n }\n\n if (vp8_alloc_frame_buffers(pc, pc->Width, pc->Height))\n                    vpx_internal_error(&pc->error, VPX_CODEC_MEM_ERROR,\n \"Failed to allocate frame buffers\");\n\n                xd->pre = pc->yv12_fb[pc->lst_fb_idx];\n                xd->dst = pc->yv12_fb[pc->new_fb_idx];\n\n#if CONFIG_MULTITHREAD\n for (i = 0; i < pbi->allocated_decoding_thread_count; i++)\n {\n                    pbi->mb_row_di[i].mbd.dst = pc->yv12_fb[pc->new_fb_idx];\n                    vp8_build_block_doffsets(&pbi->mb_row_di[i].mbd);\n }\n#endif\n                vp8_build_block_doffsets(&pbi->mb);\n\n /* allocate memory for last frame MODE_INFO array */\n#if CONFIG_ERROR_CONCEALMENT\n\n if (pbi->ec_enabled)\n {\n /* old prev_mip was released by vp8_de_alloc_frame_buffers()\n                     * called in vp8_alloc_frame_buffers() */\n                    pc->prev_mip = vpx_calloc(\n (pc->mb_cols + 1) * (pc->mb_rows + 1),\n sizeof(MODE_INFO));\n\n if (!pc->prev_mip)\n {\n                        vp8_de_alloc_frame_buffers(pc);\n                        vpx_internal_error(&pc->error, VPX_CODEC_MEM_ERROR,\n \"Failed to allocate\"\n \"last frame MODE_INFO array\");\n }\n\n                    pc->prev_mi = pc->prev_mip + pc->mode_info_stride + 1;\n\n if (vp8_alloc_overlap_lists(pbi))\n                        vpx_internal_error(&pc->error, VPX_CODEC_MEM_ERROR,\n \"Failed to allocate overlap lists \"\n \"for error concealment\");\n }\n\n#endif\n\n#if CONFIG_MULTITHREAD\n if (pbi->b_multithreaded_rd)\n                    vp8mt_alloc_temp_buffers(pbi, pc->Width, prev_mb_rows);\n#else\n (void)prev_mb_rows;\n#endif\n }\n\n            pbi->common.error.setjmp = 0;\n\n /* required to get past the first get_free_fb() call */\n            pbi->common.fb_idx_ref_cnt[0] = 0;\n }\n\n /* update the pbi fragment data */\n        pbi->fragments = ctx->fragments;\n\n        ctx->user_priv = user_priv;\n if (vp8dx_receive_compressed_data(pbi, data_sz, data, deadline))\n {\n            res = update_error_state(ctx, &pbi->common.error);\n }\n\n /* get ready for the next series of fragments */\n        ctx->fragments.count = 0;\n }\n\n return res;\n}\n", "target": 1, "idx": 187404}
{"func": "int\tFS_GetModList( char *listbuf, int bufsize ) {\n\tint\t\tnMods, i, j, nTotal, nLen, nPaks, nPotential, nDescLen;\n\tchar **pFiles = NULL;\n\tchar **pPaks = NULL;\n\tchar *name, *path;\n\tchar description[MAX_OSPATH];\n\n\tint dummy;\n\tchar **pFiles0 = NULL;\n\tchar **pFiles1 = NULL;\n#ifndef STANDALONE\n\tchar **pFiles2 = NULL;\n\tchar **pFiles3 = NULL;\n#endif\n\n\tqboolean bDrop = qfalse;\n\n\t*listbuf = 0;\n\tnMods = nTotal = 0;\n\n\tpFiles0 = Sys_ListFiles( fs_homepath->string, NULL, NULL, &dummy, qtrue );\n\tpFiles1 = Sys_ListFiles( fs_basepath->string, NULL, NULL, &dummy, qtrue );\n#ifndef STANDALONE\n\tpFiles2 = Sys_ListFiles( fs_steampath->string, NULL, NULL, &dummy, qtrue );\n#endif\n#ifndef STANDALONE\n\tpFiles3 = Sys_ConcatenateFileLists( pFiles0, pFiles1 );\n\tpFiles = Sys_ConcatenateFileLists( pFiles2, pFiles3 );\n#else\n\tpFiles = Sys_ConcatenateFileLists( pFiles0, pFiles1 );\n#endif\n\n\tnPotential = Sys_CountFileList(pFiles);\n\n\tfor ( i = 0 ; i < nPotential ; i++ ) {\n\t\tname = pFiles[i];\n\t\tif (i!=0) {\n\t\t\tbDrop = qfalse;\n\t\t\tfor(j=0; j<i; j++)\n\t\t\t{\n\t\t\t\tif (Q_stricmp(pFiles[j],name)==0) {\n\t\t\t\t\tbDrop = qtrue;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (bDrop) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (Q_stricmp(name, com_basegame->string) && Q_stricmpn(name, \".\", 1)) {\n\t\t\tpath = FS_BuildOSPath( fs_basepath->string, name, \"\" );\n\t\t\tnPaks = 0;\n\t\t\tpPaks = Sys_ListFiles(path, \".pk3\", NULL, &nPaks, qfalse); \n\t\t\tSys_FreeFileList( pPaks ); // we only use Sys_ListFiles to check wether .pk3 files are present\n\n\t\t\t/* try on home path */\n\t\t\tif ( nPaks <= 0 )\n\t\t\t{\n\t\t\t\tpath = FS_BuildOSPath( fs_homepath->string, name, \"\" );\n\t\t\t\tnPaks = 0;\n\t\t\t\tpPaks = Sys_ListFiles( path, \".pk3\", NULL, &nPaks, qfalse );\n\t\t\t\tSys_FreeFileList( pPaks );\n\t\t\t}\n\n#ifndef STANDALONE\n\t\t\t/* try on steam path */\n\t\t\tif ( nPaks <= 0 )\n\t\t\t{\n\t\t\t\tpath = FS_BuildOSPath( fs_steampath->string, name, \"\" );\n\t\t\t\tnPaks = 0;\n\t\t\t\tpPaks = Sys_ListFiles( path, \".pk3\", NULL, &nPaks, qfalse );\n\t\t\t\tSys_FreeFileList( pPaks );\n\t\t\t}\n#endif\n\n\t\t\tif (nPaks > 0) {\n\t\t\t\tnLen = strlen(name) + 1;\n\t\t\t\tFS_GetModDescription( name, description, sizeof( description ) );\n\t\t\t\tnDescLen = strlen(description) + 1;\n\n\t\t\t\tif (nTotal + nLen + 1 + nDescLen + 1 < bufsize) {\n\t\t\t\t\tstrcpy(listbuf, name);\n\t\t\t\t\tlistbuf += nLen;\n\t\t\t\t\tstrcpy(listbuf, description);\n\t\t\t\t\tlistbuf += nDescLen;\n\t\t\t\t\tnTotal += nLen + nDescLen;\n\t\t\t\t\tnMods++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tSys_FreeFileList( pFiles );\n\n\treturn nMods;\n}\n", "target": 0, "idx": 95791}
{"func": "static int llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t  int *uaddrlen, int peer)\n{\n \tstruct sockaddr_llc sllc;\n \tstruct sock *sk = sock->sk;\n \tstruct llc_sock *llc = llc_sk(sk);\n\tint rc = 0;\n \n \tmemset(&sllc, 0, sizeof(sllc));\n \tlock_sock(sk);\n \tif (sock_flag(sk, SOCK_ZAPPED))\n \t\tgoto out;\n \t*uaddrlen = sizeof(sllc);\n\tmemset(uaddr, 0, *uaddrlen);\n \tif (peer) {\n \t\trc = -ENOTCONN;\n \t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out;\n\t\tif(llc->dev)\n\t\t\tsllc.sllc_arphrd = llc->dev->type;\n\t\tsllc.sllc_sap = llc->daddr.lsap;\n\t\tmemcpy(&sllc.sllc_mac, &llc->daddr.mac, IFHWADDRLEN);\n\t} else {\n\t\trc = -EINVAL;\n\t\tif (!llc->sap)\n\t\t\tgoto out;\n\t\tsllc.sllc_sap = llc->sap->laddr.lsap;\n\n\t\tif (llc->dev) {\n\t\t\tsllc.sllc_arphrd = llc->dev->type;\n\t\t\tmemcpy(&sllc.sllc_mac, llc->dev->dev_addr,\n\t\t\t       IFHWADDRLEN);\n\t\t}\n\t}\n\trc = 0;\n\tsllc.sllc_family = AF_LLC;\n\tmemcpy(uaddr, &sllc, sizeof(sllc));\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\n", "target": 1, "idx": 179356}
{"func": "static pixman_format_code_t get_pixman_format(uint32_t virtio_gpu_format)\n{\n    switch (virtio_gpu_format) {\n#ifdef HOST_WORDS_BIGENDIAN\n    case VIRTIO_GPU_FORMAT_B8G8R8X8_UNORM:\n        return PIXMAN_b8g8r8x8;\n    case VIRTIO_GPU_FORMAT_B8G8R8A8_UNORM:\n        return PIXMAN_b8g8r8a8;\n    case VIRTIO_GPU_FORMAT_X8R8G8B8_UNORM:\n        return PIXMAN_x8r8g8b8;\n    case VIRTIO_GPU_FORMAT_A8R8G8B8_UNORM:\n        return PIXMAN_a8r8g8b8;\n    case VIRTIO_GPU_FORMAT_R8G8B8X8_UNORM:\n        return PIXMAN_r8g8b8x8;\n    case VIRTIO_GPU_FORMAT_R8G8B8A8_UNORM:\n        return PIXMAN_r8g8b8a8;\n    case VIRTIO_GPU_FORMAT_X8B8G8R8_UNORM:\n        return PIXMAN_x8b8g8r8;\n    case VIRTIO_GPU_FORMAT_A8B8G8R8_UNORM:\n        return PIXMAN_a8b8g8r8;\n#else\n    case VIRTIO_GPU_FORMAT_B8G8R8X8_UNORM:\n        return PIXMAN_x8r8g8b8;\n    case VIRTIO_GPU_FORMAT_B8G8R8A8_UNORM:\n        return PIXMAN_a8r8g8b8;\n    case VIRTIO_GPU_FORMAT_X8R8G8B8_UNORM:\n        return PIXMAN_b8g8r8x8;\n    case VIRTIO_GPU_FORMAT_A8R8G8B8_UNORM:\n        return PIXMAN_b8g8r8a8;\n    case VIRTIO_GPU_FORMAT_R8G8B8X8_UNORM:\n        return PIXMAN_x8b8g8r8;\n    case VIRTIO_GPU_FORMAT_R8G8B8A8_UNORM:\n        return PIXMAN_a8b8g8r8;\n    case VIRTIO_GPU_FORMAT_X8B8G8R8_UNORM:\n        return PIXMAN_r8g8b8x8;\n    case VIRTIO_GPU_FORMAT_A8B8G8R8_UNORM:\n        return PIXMAN_r8g8b8a8;\n#endif\n    default:\n        return 0;\n    }\n}\n", "target": 0, "idx": 6227}
{"func": " static void prefetch_enc(void)\n {\n  prefetch_table((const void *)encT, sizeof(encT));\n }\n", "target": 1, "idx": 183386}
{"func": "void WebPageProxy::printFrame(uint64_t frameID)\n{\n    ASSERT(!m_isPerformingDOMPrintOperation);\n    m_isPerformingDOMPrintOperation = true;\n\n    WebFrameProxy* frame = process()->webFrame(frameID);\n    MESSAGE_CHECK(frame);\n\n    m_uiClient.printFrame(this, frame);\n\n    m_isPerformingDOMPrintOperation = false;\n}\n", "target": 0, "idx": 106589}
{"func": "static void php_wddx_pop_element(void *user_data, const XML_Char *name)\n{\n\tst_entry \t\t\t*ent1, *ent2;\n\twddx_stack \t\t\t*stack = (wddx_stack *)user_data;\n\tHashTable \t\t\t*target_hash;\n\tzend_class_entry \t**pce;\n\tzval\t\t\t\t*obj;\n\tzval\t\t\t\t*tmp;\n\tTSRMLS_FETCH();\n\n/* OBJECTS_FIXME */\n\tif (stack->top == 0) {\n\t\treturn;\n\t}\n\n\tif (!strcmp(name, EL_STRING) || !strcmp(name, EL_NUMBER) ||\n\t\t!strcmp(name, EL_BOOLEAN) || !strcmp(name, EL_NULL) ||\n\t  \t!strcmp(name, EL_ARRAY) || !strcmp(name, EL_STRUCT) ||\n\t\t!strcmp(name, EL_RECORDSET) || !strcmp(name, EL_BINARY) ||\n\t\t!strcmp(name, EL_DATETIME)) {\n\t\twddx_stack_top(stack, (void**)&ent1);\n\n \t\tif (!ent1->data) {\n \t\t\tif (stack->top > 1) {\n \t\t\t\tstack->top--;\n \t\t\t} else {\n \t\t\t\tstack->done = 1;\n \t\t\t}\n\t\t\tefree(ent1);\n \t\t\treturn;\n \t\t}\n \n\t\tif (!strcmp(name, EL_BINARY)) {\n\t\t\tint new_len=0;\n\t\t\tunsigned char *new_str;\n\n\t\t\tnew_str = php_base64_decode(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data), &new_len);\n\t\t\tSTR_FREE(Z_STRVAL_P(ent1->data));\n\t\t\tif (new_str) {\n\t\t\t\tZ_STRVAL_P(ent1->data) = new_str;\n\t\t\t\tZ_STRLEN_P(ent1->data) = new_len;\n\t\t\t} else {\n\t\t\t\tZVAL_EMPTY_STRING(ent1->data);\n\t\t\t}\n\t\t}\n\n\t\t/* Call __wakeup() method on the object. */\n\t\tif (Z_TYPE_P(ent1->data) == IS_OBJECT) {\n\t\t\tzval *fname, *retval = NULL;\n\n\t\t\tMAKE_STD_ZVAL(fname);\n\t\t\tZVAL_STRING(fname, \"__wakeup\", 1);\n\n\t\t\tcall_user_function_ex(NULL, &ent1->data, fname, &retval, 0, 0, 0, NULL TSRMLS_CC);\n\n\t\t\tzval_dtor(fname);\n\t\t\tFREE_ZVAL(fname);\n\t\t\tif (retval) {\n\t\t\t\tzval_ptr_dtor(&retval);\n\t\t\t}\n\t\t}\n\n\t\tif (stack->top > 1) {\n\t\t\tstack->top--;\n \t\t\twddx_stack_top(stack, (void**)&ent2);\n \n \t\t\t/* if non-existent field */\n\t\t\tif (ent2->type == ST_FIELD && ent2->data == NULL) {\n \t\t\t\tzval_ptr_dtor(&ent1->data);\n \t\t\t\tefree(ent1);\n \t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (Z_TYPE_P(ent2->data) == IS_ARRAY || Z_TYPE_P(ent2->data) == IS_OBJECT) {\n\t\t\t\ttarget_hash = HASH_OF(ent2->data);\n\n\t\t\t\tif (ent1->varname) {\n\t\t\t\t\tif (!strcmp(ent1->varname, PHP_CLASS_NAME_VAR) &&\n\t\t\t\t\t\tZ_TYPE_P(ent1->data) == IS_STRING && Z_STRLEN_P(ent1->data) &&\n\t\t\t\t\t\tent2->type == ST_STRUCT && Z_TYPE_P(ent2->data) == IS_ARRAY) {\n\t\t\t\t\t\tzend_bool incomplete_class = 0;\n\n\t\t\t\t\t\tzend_str_tolower(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));\n\t\t\t\t\t\tif (zend_hash_find(EG(class_table), Z_STRVAL_P(ent1->data),\n\t\t\t\t\t\t\t\t\t\t   Z_STRLEN_P(ent1->data)+1, (void **) &pce)==FAILURE) {\n\t\t\t\t\t\t\tincomplete_class = 1;\n\t\t\t\t\t\t\tpce = &PHP_IC_ENTRY;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* Initialize target object */\n\t\t\t\t\t\tMAKE_STD_ZVAL(obj);\n\t\t\t\t\t\tobject_init_ex(obj, *pce);\n\n\t\t\t\t\t\t/* Merge current hashtable with object's default properties */\n\t\t\t\t\t\tzend_hash_merge(Z_OBJPROP_P(obj),\n\t\t\t\t\t\t\t\t\t\tZ_ARRVAL_P(ent2->data),\n\t\t\t\t\t\t\t\t\t\t(void (*)(void *)) zval_add_ref,\n\t\t\t\t\t\t\t\t\t\t(void *) &tmp, sizeof(zval *), 0);\n\n\t\t\t\t\t\tif (incomplete_class) {\n\t\t\t\t\t\t\tphp_store_class_name(obj, Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* Clean up old array entry */\n\t\t\t\t\t\tzval_ptr_dtor(&ent2->data);\n\n\t\t\t\t\t\t/* Set stack entry to point to the newly created object */\n\t\t\t\t\t\tent2->data = obj;\n\n\t\t\t\t\t\t/* Clean up class name var entry */\n\t\t\t\t\t\tzval_ptr_dtor(&ent1->data);\n\t\t\t\t\t} else if (Z_TYPE_P(ent2->data) == IS_OBJECT) {\n\t\t\t\t\t\tzend_class_entry *old_scope = EG(scope);\n\n\t\t\t\t\t\tEG(scope) = Z_OBJCE_P(ent2->data);\n\t\t\t\t\t\tZ_DELREF_P(ent1->data);\n\t\t\t\t\t\tadd_property_zval(ent2->data, ent1->varname, ent1->data);\n\t\t\t\t\t\tEG(scope) = old_scope;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tzend_symtable_update(target_hash, ent1->varname, strlen(ent1->varname)+1, &ent1->data, sizeof(zval *), NULL);\n\t\t\t\t\t}\n\t\t\t\t\tefree(ent1->varname);\n\t\t\t\t} else\t{\n\t\t\t\t\tzend_hash_next_index_insert(target_hash, &ent1->data, sizeof(zval *), NULL);\n\t\t\t\t}\n\t\t\t}\n\t\t\tefree(ent1);\n\t\t} else {\n\t\t\tstack->done = 1;\n\t\t}\n\t} else if (!strcmp(name, EL_VAR) && stack->varname) {\n\t\tefree(stack->varname);\n\t\tstack->varname = NULL;\n\t} else if (!strcmp(name, EL_FIELD)) {\n\t\tst_entry *ent;\n\t\twddx_stack_top(stack, (void **)&ent);\n\t\tefree(ent);\n\t\tstack->top--;\n\t}\n}\n", "target": 1, "idx": 180121}
{"func": "void MediaControlsProgressView::HandleSeeking(\n    const gfx::Point& location_in_bar) {\n   double seek_to_progress =\n       static_cast<double>(location_in_bar.x()) / progress_bar_->width();\n   seek_callback_.Run(seek_to_progress);\n}\n", "target": 1, "idx": 186313}
{"func": "static int x509_check_wildcard( const char *cn, mbedtls_x509_buf *name )\n{\n    size_t i;\n    size_t cn_idx = 0, cn_len = strlen( cn );\n\n    if( name->len < 3 || name->p[0] != '*' || name->p[1] != '.' )\n        return( 0 );\n\n    for( i = 0; i < cn_len; ++i )\n    {\n        if( cn[i] == '.' )\n        {\n            cn_idx = i;\n            break;\n        }\n    }\n\n    if( cn_idx == 0 )\n        return( -1 );\n\n    if( cn_len - cn_idx == name->len - 1 &&\n        x509_memcasecmp( name->p + 1, cn + cn_idx, name->len - 1 ) == 0 )\n    {\n        return( 0 );\n    }\n\n    return( -1 );\n}\n", "target": 0, "idx": 61923}
{"func": "static int cipso_v4_map_cat_rbm_valid(const struct cipso_v4_doi *doi_def,\n\t\t\t\t      const unsigned char *bitmap,\n\t\t\t\t      u32 bitmap_len)\n{\n\tint cat = -1;\n\tu32 bitmap_len_bits = bitmap_len * 8;\n\tu32 cipso_cat_size;\n\tu32 *cipso_array;\n\n\tswitch (doi_def->type) {\n\tcase CIPSO_V4_MAP_PASS:\n\t\treturn 0;\n\tcase CIPSO_V4_MAP_TRANS:\n\t\tcipso_cat_size = doi_def->map.std->cat.cipso_size;\n\t\tcipso_array = doi_def->map.std->cat.cipso;\n\t\tfor (;;) {\n\t\t\tcat = cipso_v4_bitmap_walk(bitmap,\n\t\t\t\t\t\t   bitmap_len_bits,\n\t\t\t\t\t\t   cat + 1,\n\t\t\t\t\t\t   1);\n\t\t\tif (cat < 0)\n\t\t\t\tbreak;\n\t\t\tif (cat >= cipso_cat_size ||\n\t\t\t    cipso_array[cat] >= CIPSO_V4_INV_CAT)\n\t\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tif (cat == -1)\n\t\t\treturn 0;\n\t\tbreak;\n\t}\n\n\treturn -EFAULT;\n}\n", "target": 0, "idx": 18836}
{"func": "static void __net_exit sysctl_net_exit(struct net *net)\n{\n\tretire_sysctl_set(&net->sysctls);\n}\n", "target": 0, "idx": 29694}
{"func": "static void fpm_child_free(struct fpm_child_s *child) /* {{{ */\n{\n\tfree(child);\n}\n/* }}} */\n", "target": 0, "idx": 86606}
{"func": "error::Error GLES2DecoderPassthroughImpl::DoUniform1i(GLint location, GLint x) {\n  api()->glUniform1iFn(location, x);\n  return error::kNoError;\n}\n", "target": 0, "idx": 154831}
{"func": "loadImage(TIFF* in, struct image_data *image, struct dump_opts *dump, unsigned char **read_ptr)\n   {\n   uint32   i;\n   float    xres = 0.0, yres = 0.0;\n  uint16   nstrips = 0, ntiles = 0, planar = 0;\n   uint16   bps = 0, spp = 0, res_unit = 0;\n   uint16   orientation = 0;\n   uint16   input_compression = 0, input_photometric = 0;\n  uint16   subsampling_horiz, subsampling_vert;\n  uint32   width = 0, length = 0;\n  uint32   stsize = 0, tlsize = 0, buffsize = 0, scanlinesize = 0;\n  uint32   tw = 0, tl = 0;       /* Tile width and length */\n  uint32   tile_rowsize = 0;\n  unsigned char *read_buff = NULL;\n  unsigned char *new_buff  = NULL;\n  int      readunit = 0;\n  static   uint32  prev_readsize = 0;\n\n  TIFFGetFieldDefaulted(in, TIFFTAG_BITSPERSAMPLE, &bps);\n  TIFFGetFieldDefaulted(in, TIFFTAG_SAMPLESPERPIXEL, &spp);\n  TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &planar);\n  TIFFGetFieldDefaulted(in, TIFFTAG_ORIENTATION, &orientation);\n  if (! TIFFGetFieldDefaulted(in, TIFFTAG_PHOTOMETRIC, &input_photometric))\n    TIFFError(\"loadImage\",\"Image lacks Photometric interpreation tag\");\n  if (! TIFFGetField(in, TIFFTAG_IMAGEWIDTH,  &width))\n    TIFFError(\"loadimage\",\"Image lacks image width tag\");\n  if(! TIFFGetField(in, TIFFTAG_IMAGELENGTH, &length))\n    TIFFError(\"loadimage\",\"Image lacks image length tag\");\n  TIFFGetFieldDefaulted(in, TIFFTAG_XRESOLUTION, &xres);\n  TIFFGetFieldDefaulted(in, TIFFTAG_YRESOLUTION, &yres);\n  if (!TIFFGetFieldDefaulted(in, TIFFTAG_RESOLUTIONUNIT, &res_unit))\n    res_unit = RESUNIT_INCH;\n  if (!TIFFGetField(in, TIFFTAG_COMPRESSION, &input_compression))\n    input_compression = COMPRESSION_NONE;\n\n#ifdef DEBUG2\n  char compressionid[16];\n\n  switch (input_compression)\n    {\n    case COMPRESSION_NONE:\t/* 1  dump mode */\n\t strcpy (compressionid, \"None/dump\");\n         break;         \n    case COMPRESSION_CCITTRLE:\t  /* 2 CCITT modified Huffman RLE */\n\t strcpy (compressionid, \"Huffman RLE\");\n         break;         \n    case COMPRESSION_CCITTFAX3:\t  /* 3 CCITT Group 3 fax encoding */\n\t strcpy (compressionid, \"Group3 Fax\");\n         break;         \n    case COMPRESSION_CCITTFAX4:\t  /* 4 CCITT Group 4 fax encoding */\n\t strcpy (compressionid, \"Group4 Fax\");\n         break;         \n    case COMPRESSION_LZW:\t  /* 5 Lempel-Ziv  & Welch */\n\t strcpy (compressionid, \"LZW\");\n         break;         \n    case COMPRESSION_OJPEG:\t  /* 6 !6.0 JPEG */\n\t strcpy (compressionid, \"Old Jpeg\");\n         break;         \n    case COMPRESSION_JPEG:\t  /* 7 %JPEG DCT compression */\n\t strcpy (compressionid, \"New Jpeg\");\n         break;         \n    case COMPRESSION_NEXT:\t  /* 32766 NeXT 2-bit RLE */\n\t strcpy (compressionid, \"Next RLE\");\n         break;         \n    case COMPRESSION_CCITTRLEW:   /* 32771 #1 w/ word alignment */\n\t strcpy (compressionid, \"CITTRLEW\");\n         break;         \n    case COMPRESSION_PACKBITS:\t  /* 32773 Macintosh RLE */\n\t strcpy (compressionid, \"Mac Packbits\");\n         break;         \n    case COMPRESSION_THUNDERSCAN: /* 32809 ThunderScan RLE */\n\t strcpy (compressionid, \"Thunderscan\");\n         break;         \n    case COMPRESSION_IT8CTPAD:\t  /* 32895 IT8 CT w/padding */\n\t strcpy (compressionid, \"IT8 padded\");\n         break;         \n    case COMPRESSION_IT8LW:\t  /* 32896 IT8 Linework RLE */\n\t strcpy (compressionid, \"IT8 RLE\");\n         break;         \n    case COMPRESSION_IT8MP:\t  /* 32897 IT8 Monochrome picture */\n\t strcpy (compressionid, \"IT8 mono\");\n         break;         \n    case COMPRESSION_IT8BL:\t  /* 32898 IT8 Binary line art */\n\t strcpy (compressionid, \"IT8 lineart\");\n         break;         \n    case COMPRESSION_PIXARFILM:\t  /* 32908 Pixar companded 10bit LZW */\n\t strcpy (compressionid, \"Pixar 10 bit\");\n         break;         \n    case COMPRESSION_PIXARLOG:\t  /* 32909 Pixar companded 11bit ZIP */\n\t strcpy (compressionid, \"Pixar 11bit\");\n         break;         \n    case COMPRESSION_DEFLATE:\t  /* 32946 Deflate compression */\n\t strcpy (compressionid, \"Deflate\");\n         break;         \n    case COMPRESSION_ADOBE_DEFLATE: /* 8 Deflate compression */\n\t strcpy (compressionid, \"Adobe deflate\");\n         break;         \n    default:\n\t strcpy (compressionid, \"None/unknown\");\n         break;         \n    }\n  TIFFError(\"loadImage\", \"Input compression %s\", compressionid);\n#endif\n\n  scanlinesize = TIFFScanlineSize(in);\n  image->bps = bps;\n  image->spp = spp;\n  image->planar = planar;\n  image->width = width;\n  image->length = length;\n  image->xres = xres;\n  image->yres = yres;\n  image->res_unit = res_unit;\n  image->compression = input_compression;\n  image->photometric = input_photometric;\n#ifdef DEBUG2\n  char photometricid[12];\n\n  switch (input_photometric)\n    {\n    case PHOTOMETRIC_MINISWHITE:\n         strcpy (photometricid, \"MinIsWhite\");\n         break;\n    case PHOTOMETRIC_MINISBLACK:\n         strcpy (photometricid, \"MinIsBlack\");\n         break;\n    case PHOTOMETRIC_RGB:\n         strcpy (photometricid, \"RGB\");\n         break;\n    case PHOTOMETRIC_PALETTE:\n         strcpy (photometricid, \"Palette\");\n         break;\n    case PHOTOMETRIC_MASK:\n         strcpy (photometricid, \"Mask\");\n         break;\n    case PHOTOMETRIC_SEPARATED:\n         strcpy (photometricid, \"Separated\");\n         break;\n    case PHOTOMETRIC_YCBCR:\n         strcpy (photometricid, \"YCBCR\");\n         break;\n    case PHOTOMETRIC_CIELAB:\n         strcpy (photometricid, \"CIELab\");\n         break;\n    case PHOTOMETRIC_ICCLAB:\n         strcpy (photometricid, \"ICCLab\");\n         break;\n    case PHOTOMETRIC_ITULAB:\n         strcpy (photometricid, \"ITULab\");\n         break;\n    case PHOTOMETRIC_LOGL:\n         strcpy (photometricid, \"LogL\");\n         break;\n    case PHOTOMETRIC_LOGLUV:\n         strcpy (photometricid, \"LOGLuv\");\n         break;\n    default:\n         strcpy (photometricid, \"Unknown\");\n         break;\n    }\n  TIFFError(\"loadImage\", \"Input photometric interpretation %s\", photometricid);\n\n#endif\n  image->orientation = orientation;\n  switch (orientation)\n    {\n    case 0:\n    case ORIENTATION_TOPLEFT:\n         image->adjustments = 0;\n\t break;\n    case ORIENTATION_TOPRIGHT:\n         image->adjustments = MIRROR_HORIZ;\n\t break;\n    case ORIENTATION_BOTRIGHT:\n         image->adjustments = ROTATECW_180;\n\t break;\n    case ORIENTATION_BOTLEFT:\n         image->adjustments = MIRROR_VERT; \n\t break;\n    case ORIENTATION_LEFTTOP:\n         image->adjustments = MIRROR_VERT | ROTATECW_90;\n\t break;\n    case ORIENTATION_RIGHTTOP:\n         image->adjustments = ROTATECW_90;\n\t break;\n    case ORIENTATION_RIGHTBOT:\n         image->adjustments = MIRROR_VERT | ROTATECW_270;\n\t break; \n    case ORIENTATION_LEFTBOT:\n         image->adjustments = ROTATECW_270;\n\t break;\n    default:\n         image->adjustments = 0;\n         image->orientation = ORIENTATION_TOPLEFT;\n   }\n\n  if ((bps == 0) || (spp == 0))\n    {\n    TIFFError(\"loadImage\", \"Invalid samples per pixel (%d) or bits per sample (%d)\",\n\t       spp, bps);\n    return (-1);\n    }\n\n  if (TIFFIsTiled(in))\n    {\n    readunit = TILE;\n    tlsize = TIFFTileSize(in);\n    ntiles = TIFFNumberOfTiles(in);\n    TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);\n    TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);\n\n    tile_rowsize  = TIFFTileRowSize(in);      \n    if (ntiles == 0 || tlsize == 0 || tile_rowsize == 0)\n    {\n\tTIFFError(\"loadImage\", \"File appears to be tiled, but the number of tiles, tile size, or tile rowsize is zero.\");\n\texit(-1);\n    }\n    buffsize = tlsize * ntiles;\n    if (tlsize != (buffsize / ntiles))\n    {\n\tTIFFError(\"loadImage\", \"Integer overflow when calculating buffer size\");\n\texit(-1);\n    }\n\n    if (buffsize < (uint32)(ntiles * tl * tile_rowsize))\n      {\n      buffsize = ntiles * tl * tile_rowsize;\n      if (ntiles != (buffsize / tl / tile_rowsize))\n      {\n\tTIFFError(\"loadImage\", \"Integer overflow when calculating buffer size\");\n\texit(-1);\n      }\n      \n#ifdef DEBUG2\n      TIFFError(\"loadImage\",\n\t        \"Tilesize %u is too small, using ntiles * tilelength * tilerowsize %lu\",\n                tlsize, (unsigned long)buffsize);\n#endif\n      }\n    \n    if (dump->infile != NULL)\n      dump_info (dump->infile, dump->format, \"\", \n                 \"Tilesize: %u, Number of Tiles: %u, Tile row size: %u\",\n                 tlsize, ntiles, tile_rowsize);\n    }\n  else\n    {\n    uint32 buffsize_check;\n    readunit = STRIP;\n    TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    stsize = TIFFStripSize(in);\n    nstrips = TIFFNumberOfStrips(in);\n    if (nstrips == 0 || stsize == 0)\n    {\n\tTIFFError(\"loadImage\", \"File appears to be striped, but the number of stipes or stripe size is zero.\");\n\texit(-1);\n    }\n\n    buffsize = stsize * nstrips;\n    if (stsize != (buffsize / nstrips))\n    {\n\tTIFFError(\"loadImage\", \"Integer overflow when calculating buffer size\");\n\texit(-1);\n    }\n    buffsize_check = ((length * width * spp * bps) + 7);\n    if (length != ((buffsize_check - 7) / width / spp / bps))\n    {\n\tTIFFError(\"loadImage\", \"Integer overflow detected.\");\n\texit(-1);\n    }\n    if (buffsize < (uint32) (((length * width * spp * bps) + 7) / 8))\n      {\n      buffsize =  ((length * width * spp * bps) + 7) / 8;\n#ifdef DEBUG2\n      TIFFError(\"loadImage\",\n\t        \"Stripsize %u is too small, using imagelength * width * spp * bps / 8 = %lu\",\n                stsize, (unsigned long)buffsize);\n#endif\n      }\n    \n    if (dump->infile != NULL)\n      dump_info (dump->infile, dump->format, \"\",\n                 \"Stripsize: %u, Number of Strips: %u, Rows per Strip: %u, Scanline size: %u\",\n\t\t stsize, nstrips, rowsperstrip, scanlinesize);\n    }\n  \n  if (input_compression == COMPRESSION_JPEG)\n    {  /* Force conversion to RGB */\n    jpegcolormode = JPEGCOLORMODE_RGB;\n    TIFFSetField(in, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n    }\n  /* The clause up to the read statement is taken from Tom Lane's tiffcp patch */\n  else \n    {   /* Otherwise, can't handle subsampled input */\n    if (input_photometric == PHOTOMETRIC_YCBCR)\n      {\n      TIFFGetFieldDefaulted(in, TIFFTAG_YCBCRSUBSAMPLING,\n \t\t           &subsampling_horiz, &subsampling_vert);\n      if (subsampling_horiz != 1 || subsampling_vert != 1)\n        {\n\tTIFFError(\"loadImage\", \n\t\t\"Can't copy/convert subsampled image with subsampling %d horiz %d vert\",\n                subsampling_horiz, subsampling_vert);\n        return (-1);\n        }\n\t}\n    }\n \n  read_buff = *read_ptr;\n   /* +3 : add a few guard bytes since reverseSamples16bits() can read a bit */\n   /* outside buffer */\n   if (!read_buff)\n     read_buff = (unsigned char *)_TIFFmalloc(buffsize+3);\n   else\n     {\n     if (prev_readsize < buffsize)\n       {\n       new_buff = _TIFFrealloc(read_buff, buffsize+3);\n       if (!new_buff)\n         {\n\tfree (read_buff);\n        read_buff = (unsigned char *)_TIFFmalloc(buffsize+3);\n        }\n      else\n        read_buff = new_buff;\n      }\n    }\n  if (!read_buff)\n    {\n    TIFFError(\"loadImage\", \"Unable to allocate/reallocate read buffer\");\n    return (-1);\n    }\n\n  read_buff[buffsize] = 0;\n  read_buff[buffsize+1] = 0;\n  read_buff[buffsize+2] = 0;\n\n  prev_readsize = buffsize;\n  *read_ptr = read_buff;\n\n  /* N.B. The read functions used copy separate plane data into a buffer as interleaved\n   * samples rather than separate planes so the same logic works to extract regions\n   * regardless of the way the data are organized in the input file.\n   */\n  switch (readunit) {\n    case STRIP:\n         if (planar == PLANARCONFIG_CONTIG)\n           {\n\t     if (!(readContigStripsIntoBuffer(in, read_buff)))\n\t     {\n\t     TIFFError(\"loadImage\", \"Unable to read contiguous strips into buffer\");\n\t     return (-1);\n             }\n           }\n         else\n           {\n\t   if (!(readSeparateStripsIntoBuffer(in, read_buff, length, width, spp, dump)))\n\t     {\n\t     TIFFError(\"loadImage\", \"Unable to read separate strips into buffer\");\n\t     return (-1);\n             }\n           }\n         break;\n\n    case TILE:\n         if (planar == PLANARCONFIG_CONTIG)\n           {\n\t   if (!(readContigTilesIntoBuffer(in, read_buff, length, width, tw, tl, spp, bps)))\n\t     {\n\t     TIFFError(\"loadImage\", \"Unable to read contiguous tiles into buffer\");\n\t     return (-1);\n             }\n           }\n         else\n           {\n\t   if (!(readSeparateTilesIntoBuffer(in, read_buff, length, width, tw, tl, spp, bps)))\n\t     {\n\t     TIFFError(\"loadImage\", \"Unable to read separate tiles into buffer\");\n\t     return (-1);\n             }\n           }\n         break;\n    default: TIFFError(\"loadImage\", \"Unsupported image file format\");\n          return (-1);\n          break;\n    }\n  if ((dump->infile != NULL) && (dump->level == 2))\n    {\n    dump_info  (dump->infile, dump->format, \"loadImage\", \n                \"Image width %d, length %d, Raw image data, %4d bytes\",\n                width, length,  buffsize);\n    dump_info  (dump->infile, dump->format, \"\", \n                \"Bits per sample %d, Samples per pixel %d\", bps, spp);\n\n    for (i = 0; i < length; i++)\n      dump_buffer(dump->infile, dump->format, 1, scanlinesize, \n                  i, read_buff + (i * scanlinesize));\n    }\n  return (0);\n  }   /* end loadImage */\n", "target": 1, "idx": 180046}
{"func": "int security_transition_sid(u32 ssid, u32 tsid, u16 tclass,\n\t\t\t    const struct qstr *qstr, u32 *out_sid)\n{\n\treturn security_compute_sid(ssid, tsid, tclass, AVTAB_TRANSITION,\n\t\t\t\t    qstr ? qstr->name : NULL, out_sid, true);\n}\n", "target": 0, "idx": 39299}
{"func": "krb5_gss_inquire_sec_context_by_oid (OM_uint32 *minor_status,\n                                     const gss_ctx_id_t context_handle,\n                                     const gss_OID desired_object,\n                                     gss_buffer_set_t *data_set)\n{\n    krb5_gss_ctx_id_rec *ctx;\n    size_t i;\n\n    if (minor_status == NULL)\n        return GSS_S_CALL_INACCESSIBLE_WRITE;\n\n    *minor_status = 0;\n\n    if (desired_object == GSS_C_NO_OID)\n        return GSS_S_CALL_INACCESSIBLE_READ;\n\n    if (data_set == NULL)\n        return GSS_S_CALL_INACCESSIBLE_WRITE;\n\n    *data_set = GSS_C_NO_BUFFER_SET;\n \n     ctx = (krb5_gss_ctx_id_rec *) context_handle;\n \n    if (!ctx->established)\n         return GSS_S_NO_CONTEXT;\n \n     for (i = 0; i < sizeof(krb5_gss_inquire_sec_context_by_oid_ops)/\n             sizeof(krb5_gss_inquire_sec_context_by_oid_ops[0]); i++) {\n        if (g_OID_prefix_equal(desired_object, &krb5_gss_inquire_sec_context_by_oid_ops[i].oid)) {\n            return (*krb5_gss_inquire_sec_context_by_oid_ops[i].func)(minor_status,\n                                                                      context_handle,\n                                                                      desired_object,\n                                                                      data_set);\n        }\n    }\n\n    *minor_status = EINVAL;\n\n    return GSS_S_UNAVAILABLE;\n}\n", "target": 1, "idx": 179987}
{"func": " SPL_METHOD(FilesystemIterator, current)\n {\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n\n\tif (SPL_FILE_DIR_CURRENT(intern, SPL_FILE_DIR_CURRENT_AS_PATHNAME)) {\n\t\tspl_filesystem_object_get_file_name(intern TSRMLS_CC);\n\t\tRETURN_STRINGL(intern->file_name, intern->file_name_len, 1);\n\t} else if (SPL_FILE_DIR_CURRENT(intern, SPL_FILE_DIR_CURRENT_AS_FILEINFO)) {\n\t\tspl_filesystem_object_get_file_name(intern TSRMLS_CC);\n\t\tspl_filesystem_object_create_type(0, intern, SPL_FS_INFO, NULL, return_value TSRMLS_CC);\n\t} else {\n\t\tRETURN_ZVAL(getThis(), 1, 0);\n\t\t/*RETURN_STRING(intern->u.dir.entry.d_name, 1);*/\n\t}\n}\n", "target": 1, "idx": 180208}
{"func": "freeimage(Image *image)\n{\n   freebuffer(image);\n   png_image_free(&image->image);\n\n if (image->input_file != NULL)\n {\n      fclose(image->input_file);\n      image->input_file = NULL;\n }\n\n if (image->input_memory != NULL)\n {\n      free(image->input_memory);\n      image->input_memory = NULL;\n      image->input_memory_size = 0;\n }\n\n \n    if (image->tmpfile_name[0] != 0 && (image->opts & KEEP_TMPFILES) == 0)\n    {\n      remove(image->tmpfile_name);\n       image->tmpfile_name[0] = 0;\n    }\n }\n", "target": 1, "idx": 187616}
{"func": "check_1_6_dummy(kadm5_principal_ent_t entry, long mask,\n                int n_ks_tuple, krb5_key_salt_tuple *ks_tuple, char **passptr)\n{\n    int i;\n     char *password = *passptr;\n \n     /* Old-style randkey operations disallowed tickets to start. */\n    if (!(mask & KADM5_ATTRIBUTES) ||\n         !(entry->attributes & KRB5_KDB_DISALLOW_ALL_TIX))\n         return;\n \n    /* The 1.6 dummy password was the octets 1..255. */\n    for (i = 0; (unsigned char) password[i] == i + 1; i++);\n    if (password[i] != '\\0' || i != 255)\n        return;\n\n    /* This will make the caller use a random password instead. */\n    *passptr = NULL;\n}\n", "target": 1, "idx": 178818}
{"func": "l2tp_accm_print(netdissect_options *ndo, const u_char *dat)\n {\n \tconst uint16_t *ptr = (const uint16_t *)dat;\n \tuint16_t val_h, val_l;\n \n \tptr++;\t\t/* skip \"Reserved\" */\n \n\tval_h = EXTRACT_16BITS(ptr); ptr++;\n\tval_l = EXTRACT_16BITS(ptr); ptr++;\n \tND_PRINT((ndo, \"send=%08x \", (val_h<<16) + val_l));\n \n \tval_h = EXTRACT_16BITS(ptr); ptr++;\n \tval_l = EXTRACT_16BITS(ptr); ptr++;\n \tND_PRINT((ndo, \"recv=%08x \", (val_h<<16) + val_l));\n}\n", "target": 1, "idx": 181061}
{"func": "static void CacheThru_abort(HTStream *me, HTError e)\n{\n    if (me->fp)\n\tLYCloseTempFP(me->fp);\n    if (LYCacheSourceForAborted == SOURCE_CACHE_FOR_ABORTED_DROP) {\n\tif (me->filename) {\n\t    CTRACE((tfp, \"SourceCacheWriter: Removing active file %s\\n\",\n\t\t    me->filename));\n\t    (void) LYRemoveTemp(me->filename);\n\t    FREE(me->filename);\n\t}\n\tif (me->chunk) {\n\t    CTRACE((tfp,\n\t\t    \"SourceCacheWriter: Removing active memory chunk %p\\n\",\n\t\t    (void *) me->chunk));\n\t    HTChunkFree(me->chunk);\n\t}\n    } else {\n\tme->status = HT_OK;\t/*fake it */\n\tCacheThru_do_free(me);\n    }\n    (*me->actions->_abort) (me->target, e);\n    FREE(me);\n}\n", "target": 0, "idx": 58991}
{"func": " static void add_bytes_c(uint8_t *dst, uint8_t *src, int w){\n     long i;\n    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){\n         long a = *(long*)(src+i);\n         long b = *(long*)(dst+i);\n         *(long*)(dst+i) = ((a&pb_7f) + (b&pb_7f)) ^ ((a^b)&pb_80);\n    }\n    for(; i<w; i++)\n        dst[i+0] += src[i+0];\n}\n", "target": 1, "idx": 179101}
{"func": "void GpuProcessHostUIShim::OnAcceleratedSurfaceNew(\n    const GpuHostMsg_AcceleratedSurfaceNew_Params& params) {\n  RenderWidgetHostViewPort* view = GetRenderWidgetHostViewFromSurfaceID(\n       params.surface_id);\n   if (!view)\n     return;\n   view->AcceleratedSurfaceNew(\n      params.width, params.height, params.surface_handle);\n }\n", "target": 1, "idx": 185056}
{"func": "static int hfsplus_readdir(struct file *filp, void *dirent, filldir_t filldir)\n{\n\tstruct inode *inode = filp->f_path.dentry->d_inode;\n\tstruct super_block *sb = inode->i_sb;\n\tint len, err;\n\tchar strbuf[HFSPLUS_MAX_STRLEN + 1];\n\thfsplus_cat_entry entry;\n\tstruct hfs_find_data fd;\n\tstruct hfsplus_readdir_data *rd;\n\tu16 type;\n\n\tif (filp->f_pos >= inode->i_size)\n\t\treturn 0;\n\n\terr = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &fd);\n\tif (err)\n\t\treturn err;\n\thfsplus_cat_build_key(sb, fd.search_key, inode->i_ino, NULL);\n\terr = hfs_brec_find(&fd);\n\tif (err)\n\t\tgoto out;\n\n\tswitch ((u32)filp->f_pos) {\n\tcase 0:\n\t\t/* This is completely artificial... */\n\t\tif (filldir(dirent, \".\", 1, 0, inode->i_ino, DT_DIR))\n\t\t\tgoto out;\n \t\tfilp->f_pos++;\n \t\t/* fall through */\n \tcase 1:\n \t\thfs_bnode_read(fd.bnode, &entry, fd.entryoffset,\n \t\t\tfd.entrylength);\n \t\tif (be16_to_cpu(entry.type) != HFSPLUS_FOLDER_THREAD) {\n\t\t\tprintk(KERN_ERR \"hfs: bad catalog folder thread\\n\");\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tif (fd.entrylength < HFSPLUS_MIN_THREAD_SZ) {\n\t\t\tprintk(KERN_ERR \"hfs: truncated catalog thread\\n\");\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tif (filldir(dirent, \"..\", 2, 1,\n\t\t\t    be32_to_cpu(entry.thread.parentID), DT_DIR))\n\t\t\tgoto out;\n\t\tfilp->f_pos++;\n\t\t/* fall through */\n\tdefault:\n\t\tif (filp->f_pos >= inode->i_size)\n\t\t\tgoto out;\n\t\terr = hfs_brec_goto(&fd, filp->f_pos - 1);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tfor (;;) {\n\t\tif (be32_to_cpu(fd.key->cat.parent) != inode->i_ino) {\n\t\t\tprintk(KERN_ERR \"hfs: walked past end of dir\\n\");\n \t\t\terr = -EIO;\n \t\t\tgoto out;\n \t\t}\n \t\thfs_bnode_read(fd.bnode, &entry, fd.entryoffset,\n \t\t\tfd.entrylength);\n \t\ttype = be16_to_cpu(entry.type);\n\t\tlen = HFSPLUS_MAX_STRLEN;\n\t\terr = hfsplus_uni2asc(sb, &fd.key->cat.name, strbuf, &len);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (type == HFSPLUS_FOLDER) {\n\t\t\tif (fd.entrylength <\n\t\t\t\t\tsizeof(struct hfsplus_cat_folder)) {\n\t\t\t\tprintk(KERN_ERR \"hfs: small dir entry\\n\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (HFSPLUS_SB(sb)->hidden_dir &&\n\t\t\t    HFSPLUS_SB(sb)->hidden_dir->i_ino ==\n\t\t\t\t\tbe32_to_cpu(entry.folder.id))\n\t\t\t\tgoto next;\n\t\t\tif (filldir(dirent, strbuf, len, filp->f_pos,\n\t\t\t\t    be32_to_cpu(entry.folder.id), DT_DIR))\n\t\t\t\tbreak;\n\t\t} else if (type == HFSPLUS_FILE) {\n\t\t\tif (fd.entrylength < sizeof(struct hfsplus_cat_file)) {\n\t\t\t\tprintk(KERN_ERR \"hfs: small file entry\\n\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (filldir(dirent, strbuf, len, filp->f_pos,\n\t\t\t\t    be32_to_cpu(entry.file.id), DT_REG))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tprintk(KERN_ERR \"hfs: bad catalog entry type\\n\");\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\nnext:\n\t\tfilp->f_pos++;\n\t\tif (filp->f_pos >= inode->i_size)\n\t\t\tgoto out;\n\t\terr = hfs_brec_goto(&fd, 1);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\trd = filp->private_data;\n\tif (!rd) {\n\t\trd = kmalloc(sizeof(struct hfsplus_readdir_data), GFP_KERNEL);\n\t\tif (!rd) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tfilp->private_data = rd;\n\t\trd->file = filp;\n\t\tlist_add(&rd->list, &HFSPLUS_I(inode)->open_dir_list);\n\t}\n\tmemcpy(&rd->key, fd.key, sizeof(struct hfsplus_cat_key));\nout:\n\thfs_find_exit(&fd);\n\treturn err;\n}\n", "target": 1, "idx": 178772}
{"func": " String InspectorPageAgent::CachedResourceTypeJson(\n     const Resource& cached_resource) {\n  return ResourceTypeJson(CachedResourceType(cached_resource));\n }\n", "target": 1, "idx": 186438}
{"func": "static int AppLayerProtoDetectTest16(void)\n{\n    int result = 0;\n    Flow *f = NULL;\n    HtpState *http_state = NULL;\n    uint8_t http_buf1[] = \"POST /one HTTP/1.0\\r\\n\"\n        \"User-Agent: Mozilla/1.0\\r\\n\"\n        \"Cookie: hellocatch\\r\\n\\r\\n\";\n    uint32_t http_buf1_len = sizeof(http_buf1) - 1;\n    TcpSession ssn;\n    Packet *p = NULL;\n    Signature *s = NULL;\n    ThreadVars tv;\n    DetectEngineThreadCtx *det_ctx = NULL;\n    DetectEngineCtx *de_ctx = NULL;\n    AppLayerParserThreadCtx *alp_tctx = AppLayerParserThreadCtxAlloc();\n\n    memset(&tv, 0, sizeof(ThreadVars));\n    memset(&ssn, 0, sizeof(TcpSession));\n\n    p = UTHBuildPacket(NULL, 0, IPPROTO_TCP);\n    if (p == NULL) {\n        printf(\"packet setup failed: \");\n        goto end;\n    }\n\n    f = UTHBuildFlow(AF_INET, \"1.1.1.1\", \"2.2.2.2\", 1024, 80);\n    if (f == NULL) {\n        printf(\"flow setup failed: \");\n        goto end;\n    }\n    f->protoctx = &ssn;\n    f->proto = IPPROTO_TCP;\n    p->flow = f;\n\n    p->flowflags |= FLOW_PKT_TOSERVER;\n    p->flowflags |= FLOW_PKT_ESTABLISHED;\n    p->flags |= PKT_HAS_FLOW|PKT_STREAM_EST;\n\n    f->alproto = ALPROTO_HTTP;\n\n    StreamTcpInitConfig(TRUE);\n\n    de_ctx = DetectEngineCtxInit();\n    if (de_ctx == NULL) {\n        goto end;\n    }\n    de_ctx->flags |= DE_QUIET;\n\n    s = de_ctx->sig_list = SigInit(de_ctx, \"alert http any any -> any any \"\n                                   \"(msg:\\\"Test content option\\\"; \"\n                                   \"sid:1;)\");\n    if (s == NULL) {\n        goto end;\n    }\n\n    SigGroupBuild(de_ctx);\n    DetectEngineThreadCtxInit(&tv, (void *)de_ctx, (void *)&det_ctx);\n\n    FLOWLOCK_WRLOCK(f);\n    int r = AppLayerParserParse(NULL, alp_tctx, f, ALPROTO_HTTP,\n                                STREAM_TOSERVER, http_buf1, http_buf1_len);\n    if (r != 0) {\n        printf(\"toserver chunk 1 returned %\" PRId32 \", expected 0: \", r);\n        FLOWLOCK_UNLOCK(f);\n        goto end;\n    }\n    FLOWLOCK_UNLOCK(f);\n\n    http_state = f->alstate;\n    if (http_state == NULL) {\n        printf(\"no http state: \");\n        goto end;\n    }\n\n    /* do detect */\n    SigMatchSignatures(&tv, de_ctx, det_ctx, p);\n\n    if (!PacketAlertCheck(p, 1)) {\n        printf(\"sig 1 didn't alert, but it should: \");\n        goto end;\n    }\n    result = 1;\n end:\n    if (alp_tctx != NULL)\n        AppLayerParserThreadCtxFree(alp_tctx);\n    if (det_ctx != NULL)\n        DetectEngineThreadCtxDeinit(&tv, det_ctx);\n    if (de_ctx != NULL)\n        SigGroupCleanup(de_ctx);\n    if (de_ctx != NULL)\n        DetectEngineCtxFree(de_ctx);\n\n    StreamTcpFreeConfig(TRUE);\n\n    UTHFreePackets(&p, 1);\n    UTHFreeFlow(f);\n    return result;\n}\n", "target": 0, "idx": 96526}
{"func": "void RenderFrameHostImpl::SetCommitCallbackInterceptorForTesting(\n    CommitCallbackInterceptor* interceptor) {\n  DCHECK(!commit_callback_interceptor_ || !interceptor);\n  commit_callback_interceptor_ = interceptor;\n}\n", "target": 0, "idx": 152085}
{"func": "static int __init big_key_crypto_init(void)\n{\n\tint ret = -EINVAL;\n \n\t/* init RNG */\n\tbig_key_rng = crypto_alloc_rng(big_key_rng_name, 0, 0);\n\tif (IS_ERR(big_key_rng)) {\n\t\tbig_key_rng = NULL;\n\t\treturn -EFAULT;\n \t}\n \n \t/* seed RNG */\n\tret = crypto_rng_reset(big_key_rng, NULL, crypto_rng_seedsize(big_key_rng));\n\tif (ret)\n\t\tgoto error;\n \n \t/* init block cipher */\n\tbig_key_skcipher = crypto_alloc_skcipher(big_key_alg_name,\n\t\t\t\t\t\t 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(big_key_skcipher)) {\n\t\tbig_key_skcipher = NULL;\n\t\tret = -EFAULT;\n\t\tgoto error;\n \t}\n \n \treturn 0;\n \nerror:\n \tcrypto_free_rng(big_key_rng);\n\tbig_key_rng = NULL;\n \treturn ret;\n }\n", "target": 1, "idx": 180065}
{"func": " void gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)\n {\n \tgdImagePtr pim = 0, tim = im;\n \tint interlace, BitsPerPixel;\n\tinterlace = im->interlace;\n\tif (im->trueColor) {\n\t\t/* Expensive, but the only way that produces an\n\t\t\tacceptable result: mix down to a palette\n \t\t\tbased temporary image. */\n \t\tpim = gdImageCreatePaletteFromTrueColor(im, 1, 256);\n \t\tif (!pim) {\n\t\t\treturn;\n \t\t}\n \t\ttim = pim;\n \t}\n\tBitsPerPixel = colorstobpp(tim->colorsTotal);\n\t/* All set, let's do it. */\n\tGIFEncode(\n\t\tout, tim->sx, tim->sy, tim->interlace, 0, tim->transparent, BitsPerPixel,\n\t\ttim->red, tim->green, tim->blue, tim);\n\tif (pim) {\n \t\t/* Destroy palette based temporary image. */\n \t\tgdImageDestroy(\tpim);\n \t}\n }\n", "target": 1, "idx": 182905}
{"func": "void* NPN_GetJavaEnv() {\n  DLOG(INFO) << \"NPN_GetJavaEnv is not implemented.\";\n  return NULL;\n}\n", "target": 0, "idx": 99905}
{"func": " static bool HasEntryImpl(Isolate* isolate, FixedArrayBase* backing_store,\n uint32_t entry) {\n return !BackingStore::cast(backing_store)->is_the_hole(isolate, entry);\n }\n", "target": 0, "idx": 176306}
{"func": "static enum integrity_status evm_verify_hmac(struct dentry *dentry,\n\t\t\t\t\t     const char *xattr_name,\n\t\t\t\t\t     char *xattr_value,\n\t\t\t\t\t     size_t xattr_value_len,\n\t\t\t\t\t     struct integrity_iint_cache *iint)\n{\n\tstruct evm_ima_xattr_data *xattr_data = NULL;\n\tstruct evm_ima_xattr_data calc;\n\tenum integrity_status evm_status = INTEGRITY_PASS;\n\tint rc, xattr_len;\n\n\tif (iint && iint->evm_status == INTEGRITY_PASS)\n\t\treturn iint->evm_status;\n\n\t/* if status is not PASS, try to check again - against -ENOMEM */\n\n\t/* first need to know the sig type */\n\trc = vfs_getxattr_alloc(dentry, XATTR_NAME_EVM, (char **)&xattr_data, 0,\n\t\t\t\tGFP_NOFS);\n\tif (rc <= 0) {\n\t\tevm_status = INTEGRITY_FAIL;\n\t\tif (rc == -ENODATA) {\n\t\t\trc = evm_find_protected_xattrs(dentry);\n\t\t\tif (rc > 0)\n\t\t\t\tevm_status = INTEGRITY_NOLABEL;\n\t\t\telse if (rc == 0)\n\t\t\t\tevm_status = INTEGRITY_NOXATTRS; /* new file */\n\t\t} else if (rc == -EOPNOTSUPP) {\n\t\t\tevm_status = INTEGRITY_UNKNOWN;\n\t\t}\n\t\tgoto out;\n\t}\n\n\txattr_len = rc;\n\n\t/* check value type */\n\tswitch (xattr_data->type) {\n\tcase EVM_XATTR_HMAC:\n\t\trc = evm_calc_hmac(dentry, xattr_name, xattr_value,\n \t\t\t\t   xattr_value_len, calc.digest);\n \t\tif (rc)\n \t\t\tbreak;\n\t\trc = memcmp(xattr_data->digest, calc.digest,\n \t\t\t    sizeof(calc.digest));\n \t\tif (rc)\n \t\t\trc = -EINVAL;\n\t\tbreak;\n\tcase EVM_IMA_XATTR_DIGSIG:\n\t\trc = evm_calc_hash(dentry, xattr_name, xattr_value,\n\t\t\t\txattr_value_len, calc.digest);\n\t\tif (rc)\n\t\t\tbreak;\n\t\trc = integrity_digsig_verify(INTEGRITY_KEYRING_EVM,\n\t\t\t\t\t(const char *)xattr_data, xattr_len,\n\t\t\t\t\tcalc.digest, sizeof(calc.digest));\n\t\tif (!rc) {\n\t\t\t/* Replace RSA with HMAC if not mounted readonly and\n\t\t\t * not immutable\n\t\t\t */\n\t\t\tif (!IS_RDONLY(d_backing_inode(dentry)) &&\n\t\t\t    !IS_IMMUTABLE(d_backing_inode(dentry)))\n\t\t\t\tevm_update_evmxattr(dentry, xattr_name,\n\t\t\t\t\t\t    xattr_value,\n\t\t\t\t\t\t    xattr_value_len);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\trc = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (rc)\n\t\tevm_status = (rc == -ENODATA) ?\n\t\t\t\tINTEGRITY_NOXATTRS : INTEGRITY_FAIL;\nout:\n\tif (iint)\n\t\tiint->evm_status = evm_status;\n\tkfree(xattr_data);\n\treturn evm_status;\n}\n", "target": 1, "idx": 180609}
{"func": "void f2fs_wait_discard_bios(struct f2fs_sb_info *sbi)\n {\n \t__issue_discard_cmd(sbi, false);\n \t__drop_discard_cmd(sbi);\n\t__wait_discard_cmd(sbi, false);\n }\n", "target": 1, "idx": 182586}
{"func": "static int i8042_start(struct serio *serio)\n {\n \tstruct i8042_port *port = serio->port_data;\n \n \tport->exists = true;\n\tmb();\n \treturn 0;\n }\n", "target": 1, "idx": 182594}
{"func": "Condor_Auth_SSL::decrypt(unsigned char* input, int input_len, \n\t\t\t\t\t\t\tunsigned char* & output, int& output_len)\n{\n\treturn encrypt_or_decrypt(false,input,input_len,output,output_len);\n}\n", "target": 0, "idx": 16248}
{"func": "fst_get_iface(struct fst_card_info *card, struct fst_port_info *port,\n\t      struct ifreq *ifr)\n{\n\tsync_serial_settings sync;\n\tint i;\n\n\t/* First check what line type is set, we'll default to reporting X.21\n\t * if nothing is set as IF_IFACE_SYNC_SERIAL implies it can't be\n\t * changed\n\t */\n\tswitch (port->hwif) {\n\tcase E1:\n\t\tifr->ifr_settings.type = IF_IFACE_E1;\n\t\tbreak;\n\tcase T1:\n\t\tifr->ifr_settings.type = IF_IFACE_T1;\n\t\tbreak;\n\tcase V35:\n\t\tifr->ifr_settings.type = IF_IFACE_V35;\n\t\tbreak;\n\tcase V24:\n\t\tifr->ifr_settings.type = IF_IFACE_V24;\n\t\tbreak;\n\tcase X21D:\n\t\tifr->ifr_settings.type = IF_IFACE_X21D;\n\t\tbreak;\n\tcase X21:\n\tdefault:\n\t\tifr->ifr_settings.type = IF_IFACE_X21;\n\t\tbreak;\n\t}\n\tif (ifr->ifr_settings.size == 0) {\n\t\treturn 0;\t/* only type requested */\n\t}\n\tif (ifr->ifr_settings.size < sizeof (sync)) {\n\t\treturn -ENOMEM;\n \t}\n \n \ti = port->index;\n \tsync.clock_rate = FST_RDL(card, portConfig[i].lineSpeed);\n \t/* Lucky card and linux use same encoding here */\n \tsync.clock_type = FST_RDB(card, portConfig[i].internalClock) ==\n\t    INTCLK ? CLOCK_INT : CLOCK_EXT;\n\tsync.loopback = 0;\n\n\tif (copy_to_user(ifr->ifr_settings.ifs_ifsu.sync, &sync, sizeof (sync))) {\n\t\treturn -EFAULT;\n\t}\n\n\tifr->ifr_settings.size = sizeof (sync);\n\treturn 0;\n}\n", "target": 1, "idx": 179611}
{"func": "void GDataFileSystem::OnCloseFileFinished(\n    const FilePath& file_path,\n    const FileOperationCallback& callback,\n    GDataFileError result) {\n  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));\n\n  open_files_.erase(file_path);\n\n  if (!callback.is_null())\n    callback.Run(result);\n}\n", "target": 0, "idx": 125391}
{"func": "cmsUInt32Number CMSEXPORT cmsMLUgetWide(const cmsMLU* mlu,\n                                      const char LanguageCode[3], const char CountryCode[3],\n                                      wchar_t* Buffer, cmsUInt32Number BufferSize)\n{\n    const wchar_t *Wide;\n    cmsUInt32Number  StrLen = 0;\n\n    cmsUInt16Number Lang  = _cmsAdjustEndianess16(*(cmsUInt16Number*) LanguageCode);\n    cmsUInt16Number Cntry = _cmsAdjustEndianess16(*(cmsUInt16Number*) CountryCode);\n\n    if (mlu == NULL) return 0;\n\n    Wide = _cmsMLUgetWide(mlu, &StrLen, Lang, Cntry, NULL, NULL);\n    if (Wide == NULL) return 0;\n\n    if (Buffer == NULL) return StrLen + sizeof(wchar_t);\n\n    if (BufferSize <= 0) return 0;\n\n    if (BufferSize < StrLen + sizeof(wchar_t))\n        StrLen = BufferSize - + sizeof(wchar_t);\n\n    memmove(Buffer, Wide, StrLen);\n    Buffer[StrLen / sizeof(wchar_t)] = 0;\n\n    return StrLen + sizeof(wchar_t);\n}\n", "target": 0, "idx": 40998}
{"func": "static int vrend_decode_create_rasterizer(struct vrend_decode_ctx *ctx, uint32_t handle, uint16_t length)\n{\n   struct pipe_rasterizer_state *rs_state;\n   uint32_t tmp;\n\n   if (length != VIRGL_OBJ_RS_SIZE)\n      return EINVAL;\n\n   rs_state = CALLOC_STRUCT(pipe_rasterizer_state);\n   if (!rs_state)\n      return ENOMEM;\n\n   tmp = get_buf_entry(ctx, VIRGL_OBJ_RS_S0);\n#define ebit(name, bit) rs_state->name = (tmp >> bit) & 0x1\n#define emask(name, bit, mask) rs_state->name = (tmp >> bit) & mask\n\n   ebit(flatshade, 0);\n   ebit(depth_clip, 1);\n   ebit(clip_halfz, 2);\n   ebit(rasterizer_discard, 3);\n   ebit(flatshade_first, 4);\n   ebit(light_twoside, 5);\n   ebit(sprite_coord_mode, 6);\n   ebit(point_quad_rasterization, 7);\n   emask(cull_face, 8, 0x3);\n   emask(fill_front, 10, 0x3);\n   emask(fill_back, 12, 0x3);\n   ebit(scissor, 14);\n   ebit(front_ccw, 15);\n   ebit(clamp_vertex_color, 16);\n   ebit(clamp_fragment_color, 17);\n   ebit(offset_line, 18);\n   ebit(offset_point, 19);\n   ebit(offset_tri, 20);\n   ebit(poly_smooth, 21);\n   ebit(poly_stipple_enable, 22);\n   ebit(point_smooth, 23);\n   ebit(point_size_per_vertex, 24);\n   ebit(multisample, 25);\n   ebit(line_smooth, 26);\n   ebit(line_stipple_enable, 27);\n   ebit(line_last_pixel, 28);\n   ebit(half_pixel_center, 29);\n   ebit(bottom_edge_rule, 30);\n   rs_state->point_size = uif(get_buf_entry(ctx, VIRGL_OBJ_RS_POINT_SIZE));\n   rs_state->sprite_coord_enable = get_buf_entry(ctx, VIRGL_OBJ_RS_SPRITE_COORD_ENABLE);\n   tmp = get_buf_entry(ctx, VIRGL_OBJ_RS_S3);\n   emask(line_stipple_pattern, 0, 0xffff);\n   emask(line_stipple_factor, 16, 0xff);\n   emask(clip_plane_enable, 24, 0xff);\n\n   rs_state->line_width = uif(get_buf_entry(ctx, VIRGL_OBJ_RS_LINE_WIDTH));\n   rs_state->offset_units = uif(get_buf_entry(ctx, VIRGL_OBJ_RS_OFFSET_UNITS));\n   rs_state->offset_scale = uif(get_buf_entry(ctx, VIRGL_OBJ_RS_OFFSET_SCALE));\n   rs_state->offset_clamp = uif(get_buf_entry(ctx, VIRGL_OBJ_RS_OFFSET_CLAMP));\n\n   tmp = vrend_renderer_object_insert(ctx->grctx, rs_state, sizeof(struct pipe_rasterizer_state), handle,\n                                      VIRGL_OBJECT_RASTERIZER);\n   if (tmp == 0) {\n      FREE(rs_state);\n      return ENOMEM;\n   }\n   return 0;\n}\n", "target": 0, "idx": 9097}
{"func": "unsigned long iov_iter_alignment(const struct iov_iter *i)\n{\n\tconst struct iovec *iov = i->iov;\n\tunsigned long res;\n\tsize_t size = i->count;\n\tsize_t n;\n\n\tif (!size)\n\t\treturn 0;\n\n\tres = (unsigned long)iov->iov_base + i->iov_offset;\n\tn = iov->iov_len - i->iov_offset;\n\tif (n >= size)\n\t\treturn res | size;\n\tsize -= n;\n\tres |= n;\n\twhile (size > (++iov)->iov_len) {\n\t\tres |= (unsigned long)iov->iov_base | iov->iov_len;\n\t\tsize -= iov->iov_len;\n\t}\n\tres |= (unsigned long)iov->iov_base | size;\n\treturn res;\n}\n", "target": 0, "idx": 44164}
{"func": "static int get_min_max_with_quirks(struct usb_mixer_elem_info *cval,\n\t\t\t\t   int default_min, struct snd_kcontrol *kctl)\n{\n\t/* for failsafe */\n\tcval->min = default_min;\n\tcval->max = cval->min + 1;\n\tcval->res = 1;\n\tcval->dBmin = cval->dBmax = 0;\n\n\tif (cval->val_type == USB_MIXER_BOOLEAN ||\n\t    cval->val_type == USB_MIXER_INV_BOOLEAN) {\n\t\tcval->initialized = 1;\n\t} else {\n\t\tint minchn = 0;\n\t\tif (cval->cmask) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < MAX_CHANNELS; i++)\n\t\t\t\tif (cval->cmask & (1 << i)) {\n\t\t\t\t\tminchn = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t\tif (get_ctl_value(cval, UAC_GET_MAX, (cval->control << 8) | minchn, &cval->max) < 0 ||\n\t\t    get_ctl_value(cval, UAC_GET_MIN, (cval->control << 8) | minchn, &cval->min) < 0) {\n\t\t\tusb_audio_err(cval->head.mixer->chip,\n\t\t\t\t      \"%d:%d: cannot get min/max values for control %d (id %d)\\n\",\n\t\t\t\t   cval->head.id, snd_usb_ctrl_intf(cval->head.mixer->chip),\n\t\t\t\t\t\t\t       cval->control, cval->head.id);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (get_ctl_value(cval, UAC_GET_RES,\n\t\t\t\t  (cval->control << 8) | minchn,\n\t\t\t\t  &cval->res) < 0) {\n\t\t\tcval->res = 1;\n\t\t} else {\n\t\t\tint last_valid_res = cval->res;\n\n\t\t\twhile (cval->res > 1) {\n\t\t\t\tif (snd_usb_mixer_set_ctl_value(cval, UAC_SET_RES,\n\t\t\t\t\t\t\t\t(cval->control << 8) | minchn,\n\t\t\t\t\t\t\t\tcval->res / 2) < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tcval->res /= 2;\n\t\t\t}\n\t\t\tif (get_ctl_value(cval, UAC_GET_RES,\n\t\t\t\t\t  (cval->control << 8) | minchn, &cval->res) < 0)\n\t\t\t\tcval->res = last_valid_res;\n\t\t}\n\t\tif (cval->res == 0)\n\t\t\tcval->res = 1;\n\n\t\t/* Additional checks for the proper resolution\n\t\t *\n\t\t * Some devices report smaller resolutions than actually\n\t\t * reacting.  They don't return errors but simply clip\n\t\t * to the lower aligned value.\n\t\t */\n\t\tif (cval->min + cval->res < cval->max) {\n\t\t\tint last_valid_res = cval->res;\n\t\t\tint saved, test, check;\n\t\t\tget_cur_mix_raw(cval, minchn, &saved);\n\t\t\tfor (;;) {\n\t\t\t\ttest = saved;\n\t\t\t\tif (test < cval->max)\n\t\t\t\t\ttest += cval->res;\n\t\t\t\telse\n\t\t\t\t\ttest -= cval->res;\n\t\t\t\tif (test < cval->min || test > cval->max ||\n\t\t\t\t    snd_usb_set_cur_mix_value(cval, minchn, 0, test) ||\n\t\t\t\t    get_cur_mix_raw(cval, minchn, &check)) {\n\t\t\t\t\tcval->res = last_valid_res;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (test == check)\n\t\t\t\t\tbreak;\n\t\t\t\tcval->res *= 2;\n\t\t\t}\n\t\t\tsnd_usb_set_cur_mix_value(cval, minchn, 0, saved);\n\t\t}\n\n\t\tcval->initialized = 1;\n\t}\n\n\tif (kctl)\n\t\tvolume_control_quirks(cval, kctl);\n\n\t/* USB descriptions contain the dB scale in 1/256 dB unit\n\t * while ALSA TLV contains in 1/100 dB unit\n\t */\n\tcval->dBmin = (convert_signed_value(cval, cval->min) * 100) / 256;\n\tcval->dBmax = (convert_signed_value(cval, cval->max) * 100) / 256;\n\tif (cval->dBmin > cval->dBmax) {\n\t\t/* something is wrong; assume it's either from/to 0dB */\n\t\tif (cval->dBmin < 0)\n\t\t\tcval->dBmax = 0;\n\t\telse if (cval->dBmin > 0)\n\t\t\tcval->dBmin = 0;\n\t\tif (cval->dBmin > cval->dBmax) {\n\t\t\t/* totally crap, return an error */\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n", "target": 0, "idx": 59976}
{"func": "int OpenAndConfPCPv6Socket(void)\n{\n\tint s;\n\tint i = 1;\n\tstruct sockaddr_in6 addr;\n\ts = socket(PF_INET6, SOCK_DGRAM, 0/*IPPROTO_UDP*/);\n\tif(s < 0) {\n\t\tsyslog(LOG_ERR, \"%s: socket(): %m\", \"OpenAndConfPCPv6Socket\");\n\t\treturn -1;\n\t}\n\tif(setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &i, sizeof(i)) < 0) {\n\t\tsyslog(LOG_WARNING, \"%s: setsockopt(SO_REUSEADDR): %m\",\n\t\t       \"OpenAndConfPCPv6Socket\");\n\t}\n#ifdef IPV6_V6ONLY\n\t/* force IPV6 only for IPV6 socket.\n\t * see http://www.ietf.org/rfc/rfc3493.txt section 5.3 */\n\tif(setsockopt(s, IPPROTO_IPV6, IPV6_V6ONLY, &i, sizeof(i)) < 0) {\n\t\tsyslog(LOG_WARNING, \"%s: setsockopt(IPV6_V6ONLY): %m\",\n\t\t       \"OpenAndConfPCPv6Socket\");\n\t}\n#endif\n#ifdef IPV6_RECVPKTINFO\n\t/* see RFC3542 */\n\tif(setsockopt(s, IPPROTO_IPV6, IPV6_RECVPKTINFO, &i, sizeof(i)) < 0) {\n\t\tsyslog(LOG_WARNING, \"%s: setsockopt(IPV6_RECVPKTINFO): %m\",\n\t\t       \"OpenAndConfPCPv6Socket\");\n\t}\n#endif\n\tif(!set_non_blocking(s)) {\n\t\tsyslog(LOG_WARNING, \"%s: set_non_blocking(): %m\",\n\t\t       \"OpenAndConfPCPv6Socket\");\n\t}\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.sin6_family = AF_INET6;\n\taddr.sin6_port = htons(NATPMP_PORT);\n\taddr.sin6_addr = ipv6_bind_addr;\n\tif(bind(s, (struct sockaddr *)&addr, sizeof(addr)) < 0) {\n\t\tsyslog(LOG_ERR, \"%s: bind(): %m\", \"OpenAndConfPCPv6Socket\");\n\t\tclose(s);\n\t\treturn -1;\n\t}\n\treturn s;\n}\n", "target": 0, "idx": 89807}
{"func": "static int __linearize(struct x86_emulate_ctxt *ctxt,\n\t\t     struct segmented_address addr,\n\t\t     unsigned size, bool write, bool fetch,\n\t\t     ulong *linear)\n{\n\tstruct desc_struct desc;\n\tbool usable;\n\tulong la;\n\tu32 lim;\n\tu16 sel;\n\tunsigned cpl;\n\n\tla = seg_base(ctxt, addr.seg) + addr.ea;\n\tswitch (ctxt->mode) {\n\tcase X86EMUL_MODE_PROT64:\n\t\tif (((signed long)la << 16) >> 16 != la)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tbreak;\n\tdefault:\n\t\tusable = ctxt->ops->get_segment(ctxt, &sel, &desc, NULL,\n\t\t\t\t\t\taddr.seg);\n\t\tif (!usable)\n\t\t\tgoto bad;\n\t\t/* code segment in protected mode or read-only data segment */\n\t\tif ((((ctxt->mode != X86EMUL_MODE_REAL) && (desc.type & 8))\n\t\t\t\t\t|| !(desc.type & 2)) && write)\n\t\t\tgoto bad;\n\t\t/* unreadable code segment */\n\t\tif (!fetch && (desc.type & 8) && !(desc.type & 2))\n\t\t\tgoto bad;\n\t\tlim = desc_limit_scaled(&desc);\n\t\tif ((ctxt->mode == X86EMUL_MODE_REAL) && !fetch &&\n\t\t    (ctxt->d & NoBigReal)) {\n\t\t\t/* la is between zero and 0xffff */\n\t\t\tif (la > 0xffff || (u32)(la + size - 1) > 0xffff)\n\t\t\t\tgoto bad;\n\t\t} else if ((desc.type & 8) || !(desc.type & 4)) {\n\t\t\t/* expand-up segment */\n\t\t\tif (addr.ea > lim || (u32)(addr.ea + size - 1) > lim)\n\t\t\t\tgoto bad;\n\t\t} else {\n\t\t\t/* expand-down segment */\n\t\t\tif (addr.ea <= lim || (u32)(addr.ea + size - 1) <= lim)\n\t\t\t\tgoto bad;\n\t\t\tlim = desc.d ? 0xffffffff : 0xffff;\n\t\t\tif (addr.ea > lim || (u32)(addr.ea + size - 1) > lim)\n\t\t\t\tgoto bad;\n\t\t}\n\t\tcpl = ctxt->ops->cpl(ctxt);\n\t\tif (!(desc.type & 8)) {\n\t\t\t/* data segment */\n\t\t\tif (cpl > desc.dpl)\n\t\t\t\tgoto bad;\n\t\t} else if ((desc.type & 8) && !(desc.type & 4)) {\n\t\t\t/* nonconforming code segment */\n\t\t\tif (cpl != desc.dpl)\n\t\t\t\tgoto bad;\n\t\t} else if ((desc.type & 8) && (desc.type & 4)) {\n\t\t\t/* conforming code segment */\n\t\t\tif (cpl < desc.dpl)\n\t\t\t\tgoto bad;\n\t\t}\n\t\tbreak;\n\t}\n\tif (fetch ? ctxt->mode != X86EMUL_MODE_PROT64 : ctxt->ad_bytes != 8)\n\t\tla &= (u32)-1;\n\tif (insn_aligned(ctxt, size) && ((la & (size - 1)) != 0))\n\t\treturn emulate_gp(ctxt, 0);\n\t*linear = la;\n\treturn X86EMUL_CONTINUE;\nbad:\n\tif (addr.seg == VCPU_SREG_SS)\n\t\treturn emulate_ss(ctxt, sel);\n\telse\n\t\treturn emulate_gp(ctxt, sel);\n}\n", "target": 0, "idx": 35501}
{"func": "void ExtensionServiceBackend::LoadSingleExtension(const FilePath& path_in) {\n  CHECK(BrowserThread::CurrentlyOn(BrowserThread::FILE));\n\n  FilePath extension_path = path_in;\n  file_util::AbsolutePath(&extension_path);\n\n  int flags = Extension::ShouldAlwaysAllowFileAccess(Extension::LOAD) ?\n      Extension::ALLOW_FILE_ACCESS : Extension::NO_FLAGS;\n  if (Extension::ShouldDoStrictErrorChecking(Extension::LOAD))\n    flags |= Extension::STRICT_ERROR_CHECKS;\n  std::string error;\n  scoped_refptr<const Extension> extension(extension_file_util::LoadExtension(\n      extension_path,\n      Extension::LOAD,\n      flags,\n      &error));\n\n  if (!extension) {\n    if (!BrowserThread::PostTask(\n            BrowserThread::UI, FROM_HERE,\n            NewRunnableMethod(\n                this,\n                &ExtensionServiceBackend::ReportExtensionLoadError,\n                extension_path, error)))\n      NOTREACHED() << error;\n    return;\n  }\n\n  if (!BrowserThread::PostTask(\n           BrowserThread::UI, FROM_HERE,\n           NewRunnableMethod(\n               this,\n              &ExtensionServiceBackend::OnExtensionInstalled,\n               extension)))\n     NOTREACHED();\n }\n", "target": 1, "idx": 183864}
{"func": "int socket_create(uint16_t port)\n{\n\tint sfd = -1;\n\tint yes = 1;\n#ifdef WIN32\n\tWSADATA wsa_data;\n\tif (!wsa_init) {\n\t\tif (WSAStartup(MAKEWORD(2,2), &wsa_data) != ERROR_SUCCESS) {\n\t\t\tfprintf(stderr, \"WSAStartup failed!\\n\");\n\t\t\tExitProcess(-1);\n\t\t}\n\t\twsa_init = 1;\n\t}\n#endif\n\tstruct sockaddr_in saddr;\n\n\tif (0 > (sfd = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP))) {\n\t\tperror(\"socket()\");\n\t\treturn -1;\n\t}\n\n\tif (setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void*)&yes, sizeof(int)) == -1) {\n\t\tperror(\"setsockopt()\");\n\t\tsocket_close(sfd);\n\t\treturn -1;\n\t}\n \n \tmemset((void *) &saddr, 0, sizeof(saddr));\n \tsaddr.sin_family = AF_INET;\n\tsaddr.sin_addr.s_addr = htonl(INADDR_ANY);\n \tsaddr.sin_port = htons(port);\n \n \tif (0 > bind(sfd, (struct sockaddr *) &saddr, sizeof(saddr))) {\n\t\tperror(\"bind()\");\n\t\tsocket_close(sfd);\n\t\treturn -1;\n\t}\n\n\tif (listen(sfd, 1) == -1) {\n\t\tperror(\"listen()\");\n\t\tsocket_close(sfd);\n\t\treturn -1;\n\t}\n\n\treturn sfd;\n}\n", "target": 1, "idx": 180338}
{"func": "bool ParseRequestInfo(const struct mg_request_info* const request_info,\n                      std::string* method,\n                      std::vector<std::string>* path_segments,\n                      DictionaryValue** parameters,\n                      Response* const response) {\n  *method = request_info->request_method;\n  if (*method == \"HEAD\")\n    *method = \"GET\";\n  else if (*method == \"PUT\")\n    *method = \"POST\";\n\n  std::string uri(request_info->uri);\n  SessionManager* manager = SessionManager::GetInstance();\n  uri = uri.substr(manager->url_base().length());\n\n   base::SplitString(uri, '/', path_segments);\n \n   if (*method == \"POST\" && request_info->post_data_len > 0) {\n    VLOG(1) << \"...parsing request body\";\n     std::string json(request_info->post_data, request_info->post_data_len);\n    std::string error;\n    if (!ParseJSONDictionary(json, parameters, &error)) {\n       response->SetError(new Error(\n           kBadRequest,\n          \"Failed to parse command data: \" + error + \"\\n  Data: \" + json));\n       return false;\n     }\n   }\n  VLOG(1) << \"Parsed \" << method << \" \" << uri\n        << std::string(request_info->post_data, request_info->post_data_len);\n   return true;\n }\n", "target": 1, "idx": 183913}
{"func": "static int attach_child_main(void* data)\n {\n \tstruct attach_clone_payload* payload = (struct attach_clone_payload*)data;\n \tint ipc_socket = payload->ipc_socket;\n\tint procfd = payload->procfd;\n \tlxc_attach_options_t* options = payload->options;\n \tstruct lxc_proc_context_info* init_ctx = payload->init_ctx;\n #if HAVE_SYS_PERSONALITY_H\n\tlong new_personality;\n#endif\n\tint ret;\n\tint status;\n \tint expected;\n \tlong flags;\n \tint fd;\n \tuid_t new_uid;\n \tgid_t new_gid;\n \n\t/* wait for the initial thread to signal us that it's ready\n\t * for us to start initializing\n\t */\n\texpected = 0;\n \tstatus = -1;\n \tret = lxc_read_nointr_expect(ipc_socket, &status, sizeof(status), &expected);\n \tif (ret <= 0) {\n\t\tERROR(\"error using IPC to receive notification from initial process (0)\");\n \t\tshutdown(ipc_socket, SHUT_RDWR);\n \t\trexit(-1);\n \t}\n\n\t/* A description of the purpose of this functionality is\n\t * provided in the lxc-attach(1) manual page. We have to\n\t * remount here and not in the parent process, otherwise\n\t * /proc may not properly reflect the new pid namespace.\n\t */\n\tif (!(options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_REMOUNT_PROC_SYS)) {\n\t\tret = lxc_attach_remount_sys_proc();\n\t\tif (ret < 0) {\n\t\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\t\trexit(-1);\n\t\t}\n\t}\n\n\t/* now perform additional attachments*/\n#if HAVE_SYS_PERSONALITY_H\n\tif (options->personality < 0)\n\t\tnew_personality = init_ctx->personality;\n\telse\n\t\tnew_personality = options->personality;\n\n\tif (options->attach_flags & LXC_ATTACH_SET_PERSONALITY) {\n\t\tret = personality(new_personality);\n\t\tif (ret < 0) {\n\t\t\tSYSERROR(\"could not ensure correct architecture\");\n\t\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\t\trexit(-1);\n\t\t}\n\t}\n#endif\n\n\tif (options->attach_flags & LXC_ATTACH_DROP_CAPABILITIES) {\n\t\tret = lxc_attach_drop_privs(init_ctx);\n\t\tif (ret < 0) {\n\t\t\tERROR(\"could not drop privileges\");\n\t\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\t\trexit(-1);\n\t\t}\n\t}\n\n\t/* always set the environment (specify (LXC_ATTACH_KEEP_ENV, NULL, NULL) if you want this to be a no-op) */\n\tret = lxc_attach_set_environment(options->env_policy, options->extra_env_vars, options->extra_keep_env);\n\tif (ret < 0) {\n\t\tERROR(\"could not set initial environment for attached process\");\n\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\trexit(-1);\n\t}\n\n\t/* set user / group id */\n\tnew_uid = 0;\n\tnew_gid = 0;\n\t/* ignore errors, we will fall back to root in that case\n\t * (/proc was not mounted etc.)\n\t */\n\tif (options->namespaces & CLONE_NEWUSER)\n\t\tlxc_attach_get_init_uidgid(&new_uid, &new_gid);\n\n\tif (options->uid != (uid_t)-1)\n\t\tnew_uid = options->uid;\n\tif (options->gid != (gid_t)-1)\n\t\tnew_gid = options->gid;\n\n\t/* setup the control tty */\n\tif (options->stdin_fd && isatty(options->stdin_fd)) {\n\t\tif (setsid() < 0) {\n\t\t\tSYSERROR(\"unable to setsid\");\n\t\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\t\trexit(-1);\n\t\t}\n\n\t\tif (ioctl(options->stdin_fd, TIOCSCTTY, (char *)NULL) < 0) {\n\t\t\tSYSERROR(\"unable to TIOCSTTY\");\n\t\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\t\trexit(-1);\n\t\t}\n\t}\n\n\t/* try to set the uid/gid combination */\n\tif ((new_gid != 0 || options->namespaces & CLONE_NEWUSER)) {\n\t\tif (setgid(new_gid) || setgroups(0, NULL)) {\n\t\t\tSYSERROR(\"switching to container gid\");\n\t\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\t\trexit(-1);\n\t\t}\n\t}\n\tif ((new_uid != 0 || options->namespaces & CLONE_NEWUSER) && setuid(new_uid)) {\n\t\tSYSERROR(\"switching to container uid\");\n\t\tshutdown(ipc_socket, SHUT_RDWR);\n\t\trexit(-1);\n\t}\n\n\t/* tell initial process it may now put us into the cgroups */\n \tstatus = 1;\n \tret = lxc_write_nointr(ipc_socket, &status, sizeof(status));\n \tif (ret != sizeof(status)) {\n\t\tERROR(\"error using IPC to notify initial process for initialization (1)\");\n \t\tshutdown(ipc_socket, SHUT_RDWR);\n \t\trexit(-1);\n \t}\n\n\t/* wait for the initial thread to signal us that it has done\n\t * everything for us when it comes to cgroups etc.\n\t */\n\texpected = 2;\n \tstatus = -1;\n \tret = lxc_read_nointr_expect(ipc_socket, &status, sizeof(status), &expected);\n \tif (ret <= 0) {\n\t\tERROR(\"error using IPC to receive final notification from initial process (2)\");\n \t\tshutdown(ipc_socket, SHUT_RDWR);\n \t\trexit(-1);\n \t}\n \n\tshutdown(ipc_socket, SHUT_RDWR);\n\tclose(ipc_socket);\n \tif ((init_ctx->container && init_ctx->container->lxc_conf &&\n \t     init_ctx->container->lxc_conf->no_new_privs) ||\n \t    (options->attach_flags & LXC_ATTACH_NO_NEW_PRIVS)) {\n \t\tif (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) < 0) {\n \t\t\tSYSERROR(\"PR_SET_NO_NEW_PRIVS could not be set. \"\n \t\t\t\t \"Process can use execve() gainable \"\n \t\t\t\t \"privileges.\");\n \t\t\trexit(-1);\n \t\t}\n \t\tINFO(\"PR_SET_NO_NEW_PRIVS is set. Process cannot use execve() \"\n \t\t     \"gainable privileges.\");\n \t}\n \n\t/* set new apparmor profile/selinux context */\n \tif ((options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_LSM) && init_ctx->lsm_label) {\n \t\tint on_exec;\n \n \t\ton_exec = options->attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0;\n\t\tif (lsm_set_label_at(procfd, on_exec, init_ctx->lsm_label) < 0) {\n \t\t\trexit(-1);\n \t\t}\n \t}\n \tif (init_ctx->container && init_ctx->container->lxc_conf &&\n \t    init_ctx->container->lxc_conf->seccomp &&\n \t    (lxc_seccomp_load(init_ctx->container->lxc_conf) != 0)) {\n \t\tERROR(\"Loading seccomp policy\");\n \t\trexit(-1);\n \t}\n \tlxc_proc_put_context_info(init_ctx);\n \n \t/* The following is done after the communication socket is\n\t * shut down. That way, all errors that might (though\n\t * unlikely) occur up until this point will have their messages\n\t * printed to the original stderr (if logging is so configured)\n\t * and not the fd the user supplied, if any.\n\t */\n\n\t/* fd handling for stdin, stdout and stderr;\n\t * ignore errors here, user may want to make sure\n\t * the fds are closed, for example */\n\tif (options->stdin_fd >= 0 && options->stdin_fd != 0)\n\t\tdup2(options->stdin_fd, 0);\n\tif (options->stdout_fd >= 0 && options->stdout_fd != 1)\n\t\tdup2(options->stdout_fd, 1);\n\tif (options->stderr_fd >= 0 && options->stderr_fd != 2)\n\t\tdup2(options->stderr_fd, 2);\n\n\t/* close the old fds */\n\tif (options->stdin_fd > 2)\n\t\tclose(options->stdin_fd);\n\tif (options->stdout_fd > 2)\n\t\tclose(options->stdout_fd);\n\tif (options->stderr_fd > 2)\n\t\tclose(options->stderr_fd);\n\n\t/* try to remove CLOEXEC flag from stdin/stdout/stderr,\n\t * but also here, ignore errors */\n\tfor (fd = 0; fd <= 2; fd++) {\n\t\tflags = fcntl(fd, F_GETFL);\n\t\tif (flags < 0)\n\t\t\tcontinue;\n\t\tif (flags & FD_CLOEXEC)\n\t\t\tif (fcntl(fd, F_SETFL, flags & ~FD_CLOEXEC) < 0)\n \t\t\t\tSYSERROR(\"Unable to clear CLOEXEC from fd\");\n \t}\n \n\t/* we don't need proc anymore */\n\tclose(procfd);\n \t/* we're done, so we can now do whatever the user intended us to do */\n \trexit(payload->exec_function(payload->exec_payload));\n }\n", "target": 1, "idx": 181942}
{"func": "static int open_and_lock(char *path)\n{\n\tint fd;\n\tstruct flock lk;\n\n\tfd = open(path, O_RDWR|O_CREAT, S_IWUSR | S_IRUSR);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Failed to open %s: %s\\n\",\n\t\t\tpath, strerror(errno));\n\t\treturn(fd);\n\t}\n\n\tlk.l_type = F_WRLCK;\n\tlk.l_whence = SEEK_SET;\n\tlk.l_start = 0;\n\tlk.l_len = 0;\n\tif (fcntl(fd, F_SETLKW, &lk) < 0) {\n\t\tfprintf(stderr, \"Failed to lock %s: %s\\n\",\n\t\t\tpath, strerror(errno));\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}\n", "target": 0, "idx": 68463}
{"func": " bool PluginInstance::Start(const GURL& url,\n                            char** const param_names,\n                            char** const param_values,\n                           int param_count,\n                           bool load_manually) {\n  load_manually_ = load_manually;\n  unsigned short mode = load_manually_ ? NP_FULL : NP_EMBED;\n  npp_->ndata = this;\n\n  NPError err = NPP_New(mode, param_count,\n      const_cast<char **>(param_names), const_cast<char **>(param_values));\n  return err == NPERR_NO_ERROR;\n}\n", "target": 0, "idx": 99963}
{"func": "rdpdr_process(STREAM s)\n{\n\tuint32 handle;\n \tuint16 vmin;\n \tuint16 component;\n \tuint16 pakid;\n \n \tlogger(Protocol, Debug, \"rdpdr_process()\");\n \t/* hexdump(s->p, s->end - s->p); */\n\n\tin_uint16(s, component);\n\tin_uint16(s, pakid);\n\n\tif (component == RDPDR_CTYP_CORE)\n\t{\n\t\tswitch (pakid)\n\t\t{\n\t\t\tcase PAKID_CORE_DEVICE_IOREQUEST:\n\t\t\t\trdpdr_process_irp(s);\n\t\t\t\tbreak;\n\n\t\t\tcase PAKID_CORE_SERVER_ANNOUNCE:\n \t\t\t\t/* DR_CORE_SERVER_ANNOUNCE_REQ */\n \t\t\t\tin_uint8s(s, 2);\t/* skip versionMajor */\n \t\t\t\tin_uint16_le(s, vmin);\t/* VersionMinor */\n \t\t\t\tin_uint32_le(s, g_client_id);\t/* ClientID */\n \n \t\t\t\t/* The RDP client is responsibility to provide a random client id\n \t\t\t\t   if server version is < 12 */\n \t\t\t\tif (vmin < 0x000c)\n\t\t\t\t\tg_client_id = 0x815ed39d;\t/* IP address (use 127.0.0.1) 0x815ed39d */\n\t\t\t\tg_epoch++;\n\n#if WITH_SCARD\n\t\t\t\t/*\n\t\t\t\t * We need to release all SCARD contexts to end all\n\t\t\t\t * current transactions and pending calls\n\t\t\t\t */\n\t\t\t\tscard_release_all_contexts();\n\n\t\t\t\t/*\n\t\t\t\t * According to [MS-RDPEFS] 3.2.5.1.2:\n\t\t\t\t *\n\t\t\t\t * If this packet appears after a sequence of other packets,\n\t\t\t\t * it is a signal that the server has reconnected to a new session\n\t\t\t\t * and the whole sequence has been reset. The client MUST treat\n\t\t\t\t * this packet as the beginning of a new sequence.\n\t\t\t\t * The client MUST also cancel all outstanding requests and release\n\t\t\t\t * previous references to all devices.\n\t\t\t\t *\n\t\t\t\t * If any problem arises in the future, please, pay attention to the\n\t\t\t\t * \"If this packet appears after a sequence of other packets\" part\n\t\t\t\t *\n\t\t\t\t */\n\n#endif\n\n\t\t\t\trdpdr_send_client_announce_reply();\n\t\t\t\trdpdr_send_client_name_request();\n\t\t\t\tbreak;\n\n\t\t\tcase PAKID_CORE_CLIENTID_CONFIRM:\n\t\t\t\trdpdr_send_client_device_list_announce();\n\t\t\t\tbreak;\n\n\t\t\tcase PAKID_CORE_DEVICE_REPLY:\n\t\t\t\tin_uint32(s, handle);\n\t\t\t\tlogger(Protocol, Debug,\n\t\t\t\t       \"rdpdr_process(), server connected to resource %d\", handle);\n\t\t\t\tbreak;\n\n\t\t\tcase PAKID_CORE_SERVER_CAPABILITY:\n\t\t\t\trdpdr_send_client_capability_response();\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tlogger(Protocol, Debug,\n\t\t\t\t       \"rdpdr_process(), pakid 0x%x of component 0x%x\", pakid,\n\t\t\t\t       component);\n\t\t\t\tbreak;\n\n\t\t}\n\t}\n\telse if (component == RDPDR_CTYP_PRN)\n\t{\n\t\tif (pakid == PAKID_PRN_CACHE_DATA)\n\t\t\tprintercache_process(s);\n\t}\n\telse\n\t\tlogger(Protocol, Warning, \"rdpdr_process(), unhandled component 0x%x\", component);\n}\n", "target": 1, "idx": 182977}
{"func": "void bta_av_rc_browse_close(tBTA_AV_CB* p_cb, tBTA_AV_DATA* p_data) {\n  APPL_TRACE_WARNING(\"%s: empty placeholder does nothing!\", __func__);\n}\n", "target": 0, "idx": 176021}
{"func": "void BrightnessObserver::BrightnessChanged(int level, bool user_initiated) {\n  if (user_initiated)\n    BrightnessBubble::GetInstance()->ShowBubble(level, true);\n  else\n    BrightnessBubble::GetInstance()->UpdateWithoutShowingBubble(level, true);\n\n  VolumeBubble::GetInstance()->HideBubble();\n}\n", "target": 0, "idx": 117547}
{"func": "void CameraSource::signalBufferReturned(MediaBuffer *buffer) {\n    ALOGV(\"signalBufferReturned: %p\", buffer->data());\n Mutex::Autolock autoLock(mLock);\n\n     for (List<sp<IMemory> >::iterator it = mFramesBeingEncoded.begin();\n          it != mFramesBeingEncoded.end(); ++it) {\n         if ((*it)->pointer() ==  buffer->data()) {\n             releaseOneRecordingFrame((*it));\n             mFramesBeingEncoded.erase(it);\n             ++mNumFramesEncoded;\n            buffer->setObserver(0);\n            buffer->release();\n            mFrameCompleteCondition.signal();\n return;\n }\n }\n    CHECK(!\"signalBufferReturned: bogus buffer\");\n}\n", "target": 1, "idx": 187532}
{"func": "static void LongOrNullAttributeAttributeSetter(\n    v8::Local<v8::Value> v8_value, const v8::FunctionCallbackInfo<v8::Value>& info) {\n  v8::Isolate* isolate = info.GetIsolate();\n  ALLOW_UNUSED_LOCAL(isolate);\n\n  v8::Local<v8::Object> holder = info.Holder();\n  ALLOW_UNUSED_LOCAL(holder);\n\n  TestObject* impl = V8TestObject::ToImpl(holder);\n \n   ExceptionState exception_state(isolate, ExceptionState::kSetterContext, \"TestObject\", \"longOrNullAttribute\");\n \n  int32_t cpp_value = NativeValueTraits<IDLLong>::NativeValue(info.GetIsolate(), v8_value, exception_state);\n   if (exception_state.HadException())\n     return;\n \n  bool is_null = IsUndefinedOrNull(v8_value);\n   impl->setLongOrNullAttribute(cpp_value, is_null);\n }\n", "target": 1, "idx": 186273}
{"func": "void WebGL2RenderingContextBase::texImage2D(GLenum target,\n                                            GLint level,\n                                            GLint internalformat,\n                                            GLsizei width,\n                                            GLsizei height,\n                                            GLint border,\n                                            GLenum format,\n                                            GLenum type,\n                                            GLintptr offset) {\n  if (isContextLost())\n    return;\n  if (!ValidateTexture2DBinding(\"texImage2D\", target))\n    return;\n  if (!bound_pixel_unpack_buffer_) {\n    SynthesizeGLError(GL_INVALID_OPERATION, \"texImage2D\",\n                       \"no bound PIXEL_UNPACK_BUFFER\");\n     return;\n   }\n   if (!ValidateTexFunc(\"texImage2D\", kTexImage, kSourceUnpackBuffer, target,\n                        level, internalformat, width, height, 1, border, format,\n                        type, 0, 0, 0))\n    return;\n  if (!ValidateValueFitNonNegInt32(\"texImage2D\", \"offset\", offset))\n    return;\n\n  ContextGL()->TexImage2D(\n      target, level, ConvertTexInternalFormat(internalformat, type), width,\n      height, border, format, type, reinterpret_cast<const void*>(offset));\n}\n", "target": 1, "idx": 186651}
{"func": "static void ep_rbtree_insert(struct eventpoll *ep, struct epitem *epi)\n{\n\tint kcmp;\n\tstruct rb_node **p = &ep->rbr.rb_node, *parent = NULL;\n\tstruct epitem *epic;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tepic = rb_entry(parent, struct epitem, rbn);\n\t\tkcmp = ep_cmp_ffd(&epi->ffd, &epic->ffd);\n\t\tif (kcmp > 0)\n\t\t\tp = &parent->rb_right;\n\t\telse\n\t\t\tp = &parent->rb_left;\n\t}\n\trb_link_node(&epi->rbn, parent, p);\n\trb_insert_color(&epi->rbn, &ep->rbr);\n}\n", "target": 0, "idx": 19579}
{"func": "    DictionaryValue* ToValue() const {\n      DictionaryValue* value = new DictionaryValue();\n      value->SetInteger(\"totalCount\", total_count);\n      value->SetString(\"payload\", payload);\n      return value;\n    }\n", "target": 0, "idx": 102200}
{"func": "static u16 rtnl_calcit(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct net_device *dev;\n\tstruct nlattr *tb[IFLA_MAX+1];\n\tu32 ext_filter_mask = 0;\n\tu16 min_ifinfo_dump_size = 0;\n\tint hdrlen;\n\n\t/* Same kernel<->userspace interface hack as in rtnl_dump_ifinfo. */\n\thdrlen = nlmsg_len(nlh) < sizeof(struct ifinfomsg) ?\n\t\t sizeof(struct rtgenmsg) : sizeof(struct ifinfomsg);\n\n\tif (nlmsg_parse(nlh, hdrlen, tb, IFLA_MAX, ifla_policy) >= 0) {\n\t\tif (tb[IFLA_EXT_MASK])\n\t\t\text_filter_mask = nla_get_u32(tb[IFLA_EXT_MASK]);\n\t}\n\n\tif (!ext_filter_mask)\n\t\treturn NLMSG_GOODSIZE;\n\t/*\n\t * traverse the list of net devices and compute the minimum\n\t * buffer size based upon the filter mask.\n\t */\n\tlist_for_each_entry(dev, &net->dev_base_head, dev_list) {\n\t\tmin_ifinfo_dump_size = max_t(u16, min_ifinfo_dump_size,\n\t\t\t\t\t     if_nlmsg_size(dev,\n\t\t\t\t\t\t           ext_filter_mask));\n\t}\n\n\treturn min_ifinfo_dump_size;\n}\n", "target": 0, "idx": 53145}
{"func": "static int cx24116_send_diseqc_msg(struct dvb_frontend *fe,\n\tstruct dvb_diseqc_master_cmd *d)\n{\n \tstruct cx24116_state *state = fe->demodulator_priv;\n \tint i, ret;\n \n \t/* Dump DiSEqC message */\n \tif (debug) {\n \t\tprintk(KERN_INFO \"cx24116: %s(\", __func__);\n\t\tfor (i = 0 ; i < d->msg_len ;) {\n\t\t\tprintk(KERN_INFO \"0x%02x\", d->msg[i]);\n\t\t\tif (++i < d->msg_len)\n\t\t\t\tprintk(KERN_INFO \", \");\n\t\t}\n \t\tprintk(\") toneburst=%d\\n\", toneburst);\n \t}\n \n\t/* Validate length */\n\tif (d->msg_len > (CX24116_ARGLEN - CX24116_DISEQC_MSGOFS))\n\t\treturn -EINVAL;\n \t/* DiSEqC message */\n \tfor (i = 0; i < d->msg_len; i++)\n \t\tstate->dsec_cmd.args[CX24116_DISEQC_MSGOFS + i] = d->msg[i];\n\n\t/* DiSEqC message length */\n\tstate->dsec_cmd.args[CX24116_DISEQC_MSGLEN] = d->msg_len;\n\n\t/* Command length */\n\tstate->dsec_cmd.len = CX24116_DISEQC_MSGOFS +\n\t\tstate->dsec_cmd.args[CX24116_DISEQC_MSGLEN];\n\n\t/* DiSEqC toneburst */\n\tif (toneburst == CX24116_DISEQC_MESGCACHE)\n\t\t/* Message is cached */\n\t\treturn 0;\n\n\telse if (toneburst == CX24116_DISEQC_TONEOFF)\n\t\t/* Message is sent without burst */\n\t\tstate->dsec_cmd.args[CX24116_DISEQC_BURST] = 0;\n\n\telse if (toneburst == CX24116_DISEQC_TONECACHE) {\n\t\t/*\n\t\t * Message is sent with derived else cached burst\n\t\t *\n\t\t * WRITE PORT GROUP COMMAND 38\n\t\t *\n\t\t * 0/A/A: E0 10 38 F0..F3\n\t\t * 1/B/B: E0 10 38 F4..F7\n\t\t * 2/C/A: E0 10 38 F8..FB\n\t\t * 3/D/B: E0 10 38 FC..FF\n\t\t *\n\t\t * databyte[3]= 8421:8421\n\t\t *              ABCD:WXYZ\n\t\t *              CLR :SET\n\t\t *\n\t\t *              WX= PORT SELECT 0..3    (X=TONEBURST)\n\t\t *              Y = VOLTAGE             (0=13V, 1=18V)\n\t\t *              Z = BAND                (0=LOW, 1=HIGH(22K))\n\t\t */\n\t\tif (d->msg_len >= 4 && d->msg[2] == 0x38)\n\t\t\tstate->dsec_cmd.args[CX24116_DISEQC_BURST] =\n\t\t\t\t((d->msg[3] & 4) >> 2);\n\t\tif (debug)\n\t\t\tdprintk(\"%s burst=%d\\n\", __func__,\n\t\t\t\tstate->dsec_cmd.args[CX24116_DISEQC_BURST]);\n\t}\n\n\t/* Wait for LNB ready */\n\tret = cx24116_wait_for_lnb(fe);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t/* Wait for voltage/min repeat delay */\n\tmsleep(100);\n\n\t/* Command */\n\tret = cx24116_cmd_execute(fe, &state->dsec_cmd);\n\tif (ret != 0)\n\t\treturn ret;\n\t/*\n\t * Wait for send\n\t *\n\t * Eutelsat spec:\n\t * >15ms delay          + (XXX determine if FW does this, see set_tone)\n\t *  13.5ms per byte     +\n\t * >15ms delay          +\n\t *  12.5ms burst        +\n\t * >15ms delay            (XXX determine if FW does this, see set_tone)\n\t */\n\tmsleep((state->dsec_cmd.args[CX24116_DISEQC_MSGLEN] << 4) +\n\t\t((toneburst == CX24116_DISEQC_TONEOFF) ? 30 : 60));\n\n\treturn 0;\n}\n", "target": 1, "idx": 183039}
{"func": "static int auth_count_scoreboard(cmd_rec *cmd, char *user) {\n  char *key;\n  void *v;\n  pr_scoreboard_entry_t *score = NULL;\n  long cur = 0, hcur = 0, ccur = 0, hostsperuser = 1, usersessions = 0;\n  config_rec *c = NULL, *maxc = NULL;\n\n  /* First, check to see which Max* directives are configured.  If none\n   * are configured, then there is no need for us to needlessly scan the\n   * ScoreboardFile.\n   */\n  if (have_client_limits(cmd) == FALSE) {\n    return 0;\n  }\n\n  /* Determine how many users are currently connected. */\n\n  /* We use this call to get the possibly-changed user name. */\n  (void) pr_auth_get_anon_config(cmd->tmp_pool, &user, NULL, NULL);\n\n  /* Gather our statistics. */\n  if (user) {\n    char curr_server_addr[80] = {'\\0'};\n\n    snprintf(curr_server_addr, sizeof(curr_server_addr), \"%s:%d\",\n      pr_netaddr_get_ipstr(session.c->local_addr), main_server->ServerPort);\n    curr_server_addr[sizeof(curr_server_addr)-1] = '\\0';\n\n    if (pr_rewind_scoreboard() < 0) {\n      pr_log_pri(PR_LOG_NOTICE, \"error rewinding scoreboard: %s\",\n        strerror(errno));\n    }\n\n    while ((score = pr_scoreboard_entry_read()) != NULL) {\n      unsigned char same_host = FALSE;\n\n      pr_signals_handle();\n\n      /* Make sure it matches our current server. */\n      if (strcmp(score->sce_server_addr, curr_server_addr) == 0) {\n\n        if ((c && c->config_type == CONF_ANON &&\n            !strcmp(score->sce_user, user)) || !c) {\n\n          /* This small hack makes sure that cur is incremented properly\n           * when dealing with anonymous logins (the timing of anonymous\n           * login updates to the scoreboard makes this...odd).\n           */\n          if (c && c->config_type == CONF_ANON && cur == 0)\n              cur = 1;\n\n          /* Only count authenticated clients, as per the documentation. */\n          if (strncmp(score->sce_user, \"(none)\", 7) == 0)\n            continue;\n\n          cur++;\n\n          /* Count up sessions on a per-host basis. */\n\n          if (!strcmp(score->sce_client_addr,\n              pr_netaddr_get_ipstr(session.c->remote_addr))) {\n            same_host = TRUE;\n\n            /* This small hack makes sure that hcur is incremented properly\n             * when dealing with anonymous logins (the timing of anonymous\n             * login updates to the scoreboard makes this...odd).\n             */\n            if (c && c->config_type == CONF_ANON && hcur == 0)\n              hcur = 1;\n\n            hcur++;\n          }\n\n          /* Take a per-user count of connections. */\n          if (strcmp(score->sce_user, user) == 0) {\n            usersessions++;\n\n            /* Count up unique hosts. */\n            if (!same_host)\n              hostsperuser++;\n          }\n        }\n\n        if (session.conn_class != NULL &&\n            strcasecmp(score->sce_class, session.conn_class->cls_name) == 0) {\n          ccur++;\n        }\n      }\n    }\n    pr_restore_scoreboard();\n    PRIVS_RELINQUISH\n  }\n\n  key = \"client-count\";\n  (void) pr_table_remove(session.notes, key, NULL);\n  v = palloc(session.pool, sizeof(unsigned int));\n  *((unsigned int *) v) = cur;\n\n  if (pr_table_add(session.notes, key, v, sizeof(unsigned int)) < 0) {\n    if (errno != EEXIST) {\n      pr_log_pri(PR_LOG_WARNING,\n        \"warning: error stashing '%s': %s\", key, strerror(errno));\n    }\n  }\n\n  if (session.conn_class != NULL) {\n    key = \"class-client-count\";\n    (void) pr_table_remove(session.notes, key, NULL);\n    v = palloc(session.pool, sizeof(unsigned int));\n    *((unsigned int *) v) = ccur;\n\n    if (pr_table_add(session.notes, key, v, sizeof(unsigned int)) < 0) {\n      if (errno != EEXIST) {\n        pr_log_pri(PR_LOG_WARNING,\n          \"warning: error stashing '%s': %s\", key, strerror(errno));\n      }\n    }\n  }\n\n  /* Try to determine what MaxClients/MaxHosts limits apply to this session\n   * (if any) and count through the runtime file to see if this limit would\n   * be exceeded.\n   */\n\n  maxc = find_config(cmd->server->conf, CONF_PARAM, \"MaxClientsPerClass\",\n    FALSE);\n  while (session.conn_class != NULL && maxc) {\n    char *maxstr = \"Sorry, the maximum number of clients (%m) from your class \"\n      \"are already connected.\";\n    unsigned int *max = maxc->argv[1];\n\n    if (strcmp(maxc->argv[0], session.conn_class->cls_name) != 0) {\n      maxc = find_config_next(maxc, maxc->next, CONF_PARAM,\n        \"MaxClientsPerClass\", FALSE);\n      continue;\n    }\n\n    if (maxc->argc > 2)\n      maxstr = maxc->argv[2];\n\n    if (*max &&\n        ccur > *max) {\n      char maxn[20] = {'\\0'};\n\n      pr_event_generate(\"mod_auth.max-clients-per-class\",\n        session.conn_class->cls_name);\n\n      snprintf(maxn, sizeof(maxn), \"%u\", *max);\n      pr_response_send(R_530, \"%s\", sreplace(cmd->tmp_pool, maxstr, \"%m\", maxn,\n        NULL));\n      (void) pr_cmd_dispatch_phase(cmd, LOG_CMD_ERR, 0);\n\n      pr_log_auth(PR_LOG_NOTICE,\n        \"Connection refused (MaxClientsPerClass %s %u)\",\n        session.conn_class->cls_name, *max);\n      pr_session_disconnect(&auth_module, PR_SESS_DISCONNECT_CONFIG_ACL,\n        \"Denied by MaxClientsPerClass\");\n    }\n\n    break;\n  }\n\n  maxc = find_config(TOPLEVEL_CONF, CONF_PARAM, \"MaxClientsPerHost\", FALSE);\n  if (maxc) {\n    char *maxstr = \"Sorry, the maximum number of clients (%m) from your host \"\n      \"are already connected.\";\n    unsigned int *max = maxc->argv[0];\n\n    if (maxc->argc > 1)\n      maxstr = maxc->argv[1];\n\n    if (*max && hcur > *max) {\n      char maxn[20] = {'\\0'};\n\n      pr_event_generate(\"mod_auth.max-clients-per-host\", session.c);\n\n      snprintf(maxn, sizeof(maxn), \"%u\", *max);\n      pr_response_send(R_530, \"%s\", sreplace(cmd->tmp_pool, maxstr, \"%m\", maxn,\n        NULL));\n      (void) pr_cmd_dispatch_phase(cmd, LOG_CMD_ERR, 0);\n\n      pr_log_auth(PR_LOG_NOTICE,\n        \"Connection refused (MaxClientsPerHost %u)\", *max);\n      pr_session_disconnect(&auth_module, PR_SESS_DISCONNECT_CONFIG_ACL,\n        \"Denied by MaxClientsPerHost\");\n    }\n  }\n\n  /* Check for any configured MaxClientsPerUser. */\n  maxc = find_config(TOPLEVEL_CONF, CONF_PARAM, \"MaxClientsPerUser\", FALSE);\n  if (maxc) {\n    char *maxstr = \"Sorry, the maximum number of clients (%m) for this user \"\n      \"are already connected.\";\n    unsigned int *max = maxc->argv[0];\n\n    if (maxc->argc > 1)\n      maxstr = maxc->argv[1];\n\n    if (*max && usersessions > *max) {\n      char maxn[20] = {'\\0'};\n\n      pr_event_generate(\"mod_auth.max-clients-per-user\", user);\n\n      snprintf(maxn, sizeof(maxn), \"%u\", *max);\n      pr_response_send(R_530, \"%s\", sreplace(cmd->tmp_pool, maxstr, \"%m\", maxn,\n        NULL));\n      (void) pr_cmd_dispatch_phase(cmd, LOG_CMD_ERR, 0);\n\n      pr_log_auth(PR_LOG_NOTICE,\n        \"Connection refused (MaxClientsPerUser %u)\", *max);\n      pr_session_disconnect(&auth_module, PR_SESS_DISCONNECT_CONFIG_ACL,\n        \"Denied by MaxClientsPerUser\");\n    }\n  }\n\n  maxc = find_config(TOPLEVEL_CONF, CONF_PARAM, \"MaxClients\", FALSE);\n  if (maxc) {\n    char *maxstr = \"Sorry, the maximum number of allowed clients (%m) are \"\n      \"already connected.\";\n    unsigned int *max = maxc->argv[0];\n\n    if (maxc->argc > 1)\n      maxstr = maxc->argv[1];\n\n    if (*max && cur > *max) {\n      char maxn[20] = {'\\0'};\n\n      pr_event_generate(\"mod_auth.max-clients\", NULL);\n\n      snprintf(maxn, sizeof(maxn), \"%u\", *max);\n      pr_response_send(R_530, \"%s\", sreplace(cmd->tmp_pool, maxstr, \"%m\", maxn,\n        NULL));\n      (void) pr_cmd_dispatch_phase(cmd, LOG_CMD_ERR, 0);\n\n      pr_log_auth(PR_LOG_NOTICE, \"Connection refused (MaxClients %u)\", *max);\n      pr_session_disconnect(&auth_module, PR_SESS_DISCONNECT_CONFIG_ACL,\n        \"Denied by MaxClients\");\n    }\n  }\n\n  maxc = find_config(TOPLEVEL_CONF, CONF_PARAM, \"MaxHostsPerUser\", FALSE);\n  if (maxc) {\n    char *maxstr = \"Sorry, the maximum number of hosts (%m) for this user are \"\n      \"already connected.\";\n    unsigned int *max = maxc->argv[0];\n\n    if (maxc->argc > 1)\n      maxstr = maxc->argv[1];\n\n    if (*max && hostsperuser > *max) {\n      char maxn[20] = {'\\0'};\n\n      pr_event_generate(\"mod_auth.max-hosts-per-user\", user);\n\n      snprintf(maxn, sizeof(maxn), \"%u\", *max);\n      pr_response_send(R_530, \"%s\", sreplace(cmd->tmp_pool, maxstr, \"%m\", maxn,\n        NULL));\n      (void) pr_cmd_dispatch_phase(cmd, LOG_CMD_ERR, 0);\n\n      pr_log_auth(PR_LOG_NOTICE, \"Connection refused (MaxHostsPerHost %u)\",\n        *max);\n      pr_session_disconnect(&auth_module, PR_SESS_DISCONNECT_CONFIG_ACL,\n        \"Denied by MaxHostsPerUser\");\n    }\n  }\n\n  return 0;\n}\n", "target": 0, "idx": 95395}
{"func": "xfs_perag_set_reclaim_tag(\n\tstruct xfs_perag\t*pag)\n{\n\tstruct xfs_mount\t*mp = pag->pag_mount;\n\n\tlockdep_assert_held(&pag->pag_ici_lock);\n\tif (pag->pag_ici_reclaimable++)\n\t\treturn;\n\n\t/* propagate the reclaim tag up into the perag radix tree */\n\tspin_lock(&mp->m_perag_lock);\n\tradix_tree_tag_set(&mp->m_perag_tree, pag->pag_agno,\n\t\t\t   XFS_ICI_RECLAIM_TAG);\n\tspin_unlock(&mp->m_perag_lock);\n\n\t/* schedule periodic background inode reclaim */\n\txfs_reclaim_work_queue(mp);\n\n\ttrace_xfs_perag_set_reclaim(mp, pag->pag_agno, -1, _RET_IP_);\n}\n", "target": 0, "idx": 79974}
{"func": " void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n     JNIEnv* env,\n    mojo::ScopedSharedBufferMapping mapping,\n     const CreateSensorCallback& callback) {\n   ScopedJavaLocalRef<jobject> sensor = Java_PlatformSensorProvider_createSensor(\n       env, j_object_,\n       static_cast<jint>(mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION));\n \n   if (sensor.obj()) {\n     auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, std::move(mapping),\n         this, sensor);\n \n     callback.Run(concrete_sensor);\n  } else {\n    auto sensor_fusion_algorithm =\n        std::make_unique<OrientationQuaternionFusionAlgorithmUsingEulerAngles>(\n            true /* absolute */);\n \n    PlatformSensorFusion::Create(std::move(mapping), this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n", "target": 1, "idx": 186812}
{"func": "NO_INLINE JsVar *jspeArrowFunction(JsVar *funcVar, JsVar *a) {\n  assert(!a || jsvIsName(a));\n  JSP_ASSERT_MATCH(LEX_ARROW_FUNCTION);\n  funcVar = jspeAddNamedFunctionParameter(funcVar, a);\n\n  bool expressionOnly = lex->tk!='{';\n  jspeFunctionDefinitionInternal(funcVar, expressionOnly);\n  if (execInfo.thisVar) {\n    jsvObjectSetChild(funcVar, JSPARSE_FUNCTION_THIS_NAME, execInfo.thisVar);\n  }\n  return funcVar;\n}\n\nNO_INLINE JsVar *jspeExpressionOrArrowFunction() {\n  JsVar *a = 0;\n  JsVar *funcVar = 0;\n  bool allNames = true;\n  while (lex->tk!=')' && !JSP_SHOULDNT_PARSE) {\n    if (allNames && a) {\n      funcVar = jspeAddNamedFunctionParameter(funcVar, a);\n    }\n    jsvUnLock(a);\n    a = jspeAssignmentExpression();\n    if (!(jsvIsName(a) && jsvIsString(a))) allNames = false;\n    if (lex->tk!=')') JSP_MATCH_WITH_CLEANUP_AND_RETURN(',', jsvUnLock2(a,funcVar), 0);\n  }\n  JSP_MATCH_WITH_CLEANUP_AND_RETURN(')', jsvUnLock2(a,funcVar), 0);\n  if (allNames && lex->tk==LEX_ARROW_FUNCTION) {\n    funcVar = jspeArrowFunction(funcVar, a);\n    jsvUnLock(a);\n    return funcVar;\n  } else {\n    jsvUnLock(funcVar);\n    return a;\n  }\n}\n\nNO_INLINE JsVar *jspeClassDefinition(bool parseNamedClass) {\n  JsVar *classFunction = 0;\n  JsVar *classPrototype = 0;\n  JsVar *classInternalName = 0;\n\n  bool actuallyCreateClass = JSP_SHOULD_EXECUTE;\n  if (actuallyCreateClass)\n    classFunction = jsvNewWithFlags(JSV_FUNCTION);\n\n  if (parseNamedClass && lex->tk==LEX_ID) {\n    if (classFunction)\n      classInternalName = jslGetTokenValueAsVar(lex);\n    JSP_ASSERT_MATCH(LEX_ID);\n  }\n  if (classFunction) {\n    JsVar *prototypeName = jsvFindChildFromString(classFunction, JSPARSE_PROTOTYPE_VAR, true);\n    jspEnsureIsPrototype(classFunction, prototypeName); // make sure it's an object\n    classPrototype = jsvSkipName(prototypeName);\n    jsvUnLock(prototypeName);\n  }\n  if (lex->tk==LEX_R_EXTENDS) {\n    JSP_ASSERT_MATCH(LEX_R_EXTENDS);\n    JsVar *extendsFrom = actuallyCreateClass ? jsvSkipNameAndUnLock(jspGetNamedVariable(jslGetTokenValueAsString(lex))) : 0;\n    JSP_MATCH_WITH_CLEANUP_AND_RETURN(LEX_ID,jsvUnLock4(extendsFrom,classFunction,classInternalName,classPrototype),0);\n    if (classPrototype) {\n      if (jsvIsFunction(extendsFrom)) {\n        jsvObjectSetChild(classPrototype, JSPARSE_INHERITS_VAR, extendsFrom);\n        jsvObjectSetChildAndUnLock(classFunction, JSPARSE_FUNCTION_CODE_NAME, jsvNewFromString(\"if(this.__proto__.__proto__)this.__proto__.__proto__.apply(this,arguments)\"));\n      } else\n        jsExceptionHere(JSET_SYNTAXERROR, \"'extends' argument should be a function, got %t\", extendsFrom);\n    }\n    jsvUnLock(extendsFrom);\n  }\n  JSP_MATCH_WITH_CLEANUP_AND_RETURN('{',jsvUnLock3(classFunction,classInternalName,classPrototype),0);\n\n  while ((lex->tk==LEX_ID || lex->tk==LEX_R_STATIC) && !jspIsInterrupted()) {\n    bool isStatic = lex->tk==LEX_R_STATIC;\n    if (isStatic) JSP_ASSERT_MATCH(LEX_R_STATIC);\n\n    JsVar *funcName = jslGetTokenValueAsVar(lex);\n    JSP_MATCH_WITH_CLEANUP_AND_RETURN(LEX_ID,jsvUnLock3(classFunction,classInternalName,classPrototype),0);\n    JsVar *method = jspeFunctionDefinition(false);\n    if (classFunction && classPrototype) {\n      if (jsvIsStringEqual(funcName, \"get\") || jsvIsStringEqual(funcName, \"set\")) {\n        jsExceptionHere(JSET_SYNTAXERROR, \"'get' and 'set' and not supported in Espruino\");\n      } else if (jsvIsStringEqual(funcName, \"constructor\")) {\n        jswrap_function_replaceWith(classFunction, method);\n      } else {\n        funcName = jsvMakeIntoVariableName(funcName, 0);\n        jsvSetValueOfName(funcName, method);\n        jsvAddName(isStatic ? classFunction : classPrototype, funcName);\n      }\n    }\n    jsvUnLock2(method,funcName);\n  }\n  jsvUnLock(classPrototype);\n  if (classInternalName)\n    jsvObjectSetChildAndUnLock(classFunction, JSPARSE_FUNCTION_NAME_NAME, classInternalName);\n\n  JSP_MATCH_WITH_CLEANUP_AND_RETURN('}',jsvUnLock(classFunction),0);\n  return classFunction;\n}\n\n#endif\n\nNO_INLINE JsVar *jspeFactor() {\n  if (lex->tk==LEX_ID) {\n    JsVar *a = jspGetNamedVariable(jslGetTokenValueAsString(lex));\n    JSP_ASSERT_MATCH(LEX_ID);\n#ifndef SAVE_ON_FLASH\n    if (lex->tk==LEX_TEMPLATE_LITERAL)\n      jsExceptionHere(JSET_SYNTAXERROR, \"Tagged template literals not supported\");\n    else if (lex->tk==LEX_ARROW_FUNCTION && jsvIsName(a)) {\n      JsVar *funcVar = jspeArrowFunction(0,a);\n      jsvUnLock(a);\n      a=funcVar;\n    }\n#endif\n    return a;\n  } else if (lex->tk==LEX_INT) {\n    JsVar *v = 0;\n    if (JSP_SHOULD_EXECUTE) {\n      v = jsvNewFromLongInteger(stringToInt(jslGetTokenValueAsString(lex)));\n    }\n    JSP_ASSERT_MATCH(LEX_INT);\n    return v;\n  } else if (lex->tk==LEX_FLOAT) {\n    JsVar *v = 0;\n    if (JSP_SHOULD_EXECUTE) {\n      v = jsvNewFromFloat(stringToFloat(jslGetTokenValueAsString(lex)));\n    }\n    JSP_ASSERT_MATCH(LEX_FLOAT);\n    return v;\n  } else if (lex->tk=='(') {\n    JSP_ASSERT_MATCH('(');\n    if (!jspCheckStackPosition()) return 0;\n#ifdef SAVE_ON_FLASH\n    JsVar *a = jspeExpression();\n    if (!JSP_SHOULDNT_PARSE) JSP_MATCH_WITH_RETURN(')',a);\n    return a;\n#else\n    return jspeExpressionOrArrowFunction();\n#endif\n\n  } else if (lex->tk==LEX_R_TRUE) {\n    JSP_ASSERT_MATCH(LEX_R_TRUE);\n    return JSP_SHOULD_EXECUTE ? jsvNewFromBool(true) : 0;\n  } else if (lex->tk==LEX_R_FALSE) {\n    JSP_ASSERT_MATCH(LEX_R_FALSE);\n    return JSP_SHOULD_EXECUTE ? jsvNewFromBool(false) : 0;\n  } else if (lex->tk==LEX_R_NULL) {\n    JSP_ASSERT_MATCH(LEX_R_NULL);\n    return JSP_SHOULD_EXECUTE ? jsvNewWithFlags(JSV_NULL) : 0;\n  } else if (lex->tk==LEX_R_UNDEFINED) {\n    JSP_ASSERT_MATCH(LEX_R_UNDEFINED);\n    return 0;\n  } else if (lex->tk==LEX_STR) {\n    JsVar *a = 0;\n    if (JSP_SHOULD_EXECUTE)\n      a = jslGetTokenValueAsVar(lex);\n    JSP_ASSERT_MATCH(LEX_STR);\n    return a;\n#ifndef SAVE_ON_FLASH\n  } else if (lex->tk==LEX_TEMPLATE_LITERAL) {\n    return jspeTemplateLiteral();\n#endif\n  } else if (lex->tk==LEX_REGEX) {\n    JsVar *a = 0;\n#ifdef SAVE_ON_FLASH\n    jsExceptionHere(JSET_SYNTAXERROR, \"RegEx are not supported in this version of Espruino\\n\");\n#else\n    JsVar *regex = jslGetTokenValueAsVar(lex);\n    size_t regexEnd = 0, regexLen = 0;\n    JsvStringIterator it;\n    jsvStringIteratorNew(&it, regex, 0);\n    while (jsvStringIteratorHasChar(&it)) {\n      regexLen++;\n      if (jsvStringIteratorGetChar(&it)=='/')\n        regexEnd = regexLen;\n      jsvStringIteratorNext(&it);\n    }\n    jsvStringIteratorFree(&it);\n    JsVar *flags = 0;\n    if (regexEnd < regexLen)\n      flags = jsvNewFromStringVar(regex, regexEnd, JSVAPPENDSTRINGVAR_MAXLENGTH);\n    JsVar *regexSource = jsvNewFromStringVar(regex, 1, regexEnd-2);\n    a = jswrap_regexp_constructor(regexSource, flags);\n    jsvUnLock3(regex, flags, regexSource);\n#endif\n    JSP_ASSERT_MATCH(LEX_REGEX);\n    return a;\n  } else if (lex->tk=='{') {\n    if (!jspCheckStackPosition()) return 0;\n    return jspeFactorObject();\n  } else if (lex->tk=='[') {\n    if (!jspCheckStackPosition()) return 0;\n    return jspeFactorArray();\n  } else if (lex->tk==LEX_R_FUNCTION) {\n    if (!jspCheckStackPosition()) return 0;\n    JSP_ASSERT_MATCH(LEX_R_FUNCTION);\n    return jspeFunctionDefinition(true);\n#ifndef SAVE_ON_FLASH\n  } else if (lex->tk==LEX_R_CLASS) {\n    if (!jspCheckStackPosition()) return 0;\n    JSP_ASSERT_MATCH(LEX_R_CLASS);\n    return jspeClassDefinition(true);\n  } else if (lex->tk==LEX_R_SUPER) {\n    JSP_ASSERT_MATCH(LEX_R_SUPER);\n    /* This is kind of nasty, since super appears to do\n      three different things.\n\n      * In the constructor it references the extended class's constructor\n      * in a method it references the constructor's prototype.\n      * in a static method it references the extended class's constructor (but this is different)\n     */\n\n    if (jsvIsObject(execInfo.thisVar)) {\n      JsVar *proto1 = jsvObjectGetChild(execInfo.thisVar, JSPARSE_INHERITS_VAR, 0); // if we're in a method, get __proto__ first\n      JsVar *proto2 = jsvIsObject(proto1) ? jsvObjectGetChild(proto1, JSPARSE_INHERITS_VAR, 0) : 0; // still in method, get __proto__.__proto__\n      jsvUnLock(proto1);\n      if (!proto2) {\n        jsExceptionHere(JSET_SYNTAXERROR, \"Calling 'super' outside of class\");\n        return 0;\n      }\n      if (lex->tk=='(') return proto2; // eg. used in a constructor\n      JsVar *proto3 = jsvIsFunction(proto2) ? jsvObjectGetChild(proto2, JSPARSE_PROTOTYPE_VAR, 0) : 0;\n      jsvUnLock(proto2);\n      return proto3;\n    } else if (jsvIsFunction(execInfo.thisVar)) {\n      JsVar *proto1 = jsvObjectGetChild(execInfo.thisVar, JSPARSE_PROTOTYPE_VAR, 0);\n      JsVar *proto2 = jsvIsObject(proto1) ? jsvObjectGetChild(proto1, JSPARSE_INHERITS_VAR, 0) : 0;\n      jsvUnLock(proto1);\n      if (!proto2) {\n        jsExceptionHere(JSET_SYNTAXERROR, \"Calling 'super' outside of class\");\n        return 0;\n      }\n      return proto2;\n    }\n    jsExceptionHere(JSET_SYNTAXERROR, \"Calling 'super' outside of class\");\n    return 0;\n#endif\n  } else if (lex->tk==LEX_R_THIS) {\n    JSP_ASSERT_MATCH(LEX_R_THIS);\n    return jsvLockAgain( execInfo.thisVar ? execInfo.thisVar : execInfo.root );\n  } else if (lex->tk==LEX_R_DELETE) {\n    if (!jspCheckStackPosition()) return 0;\n    return jspeFactorDelete();\n  } else if (lex->tk==LEX_R_TYPEOF) {\n    if (!jspCheckStackPosition()) return 0;\n    return jspeFactorTypeOf();\n  } else if (lex->tk==LEX_R_VOID) {\n    if (!jspCheckStackPosition()) return 0;\n    JSP_ASSERT_MATCH(LEX_R_VOID);\n    jsvUnLock(jspeUnaryExpression());\n    return 0;\n  }\n  JSP_MATCH(LEX_EOF);\n  jsExceptionHere(JSET_SYNTAXERROR, \"Unexpected end of Input\\n\");\n  return 0;\n}\n\nNO_INLINE JsVar *__jspePostfixExpression(JsVar *a) {\n  while (lex->tk==LEX_PLUSPLUS || lex->tk==LEX_MINUSMINUS) {\n    int op = lex->tk;\n    JSP_ASSERT_MATCH(op);\n    if (JSP_SHOULD_EXECUTE) {\n      JsVar *one = jsvNewFromInteger(1);\n      JsVar *oldValue = jsvAsNumberAndUnLock(jsvSkipName(a)); // keep the old value (but convert to number)\n      JsVar *res = jsvMathsOpSkipNames(oldValue, one, op==LEX_PLUSPLUS ? '+' : '-');\n      jsvUnLock(one);\n\n      jspReplaceWith(a, res);\n      jsvUnLock(res);\n      jsvUnLock(a);\n      a = oldValue;\n    }\n  }\n  return a;\n}\n\nNO_INLINE JsVar *jspePostfixExpression() {\n  JsVar *a;\n  if (lex->tk==LEX_PLUSPLUS || lex->tk==LEX_MINUSMINUS) {\n    int op = lex->tk;\n    JSP_ASSERT_MATCH(op);\n    a = jspePostfixExpression();\n    if (JSP_SHOULD_EXECUTE) {\n      JsVar *one = jsvNewFromInteger(1);\n      JsVar *res = jsvMathsOpSkipNames(a, one, op==LEX_PLUSPLUS ? '+' : '-');\n      jsvUnLock(one);\n      jspReplaceWith(a, res);\n      jsvUnLock(res);\n    }\n  } else\n    a = jspeFactorFunctionCall();\n  return __jspePostfixExpression(a);\n}\n\nNO_INLINE JsVar *jspeUnaryExpression() {\n  if (lex->tk=='!' || lex->tk=='~' || lex->tk=='-' || lex->tk=='+') {\n    short tk = lex->tk;\n    JSP_ASSERT_MATCH(tk);\n    if (!JSP_SHOULD_EXECUTE) {\n      return jspeUnaryExpression();\n    }\n    if (tk=='!') { // logical not\n      return jsvNewFromBool(!jsvGetBoolAndUnLock(jsvSkipNameAndUnLock(jspeUnaryExpression())));\n    } else if (tk=='~') { // bitwise not\n      return jsvNewFromInteger(~jsvGetIntegerAndUnLock(jsvSkipNameAndUnLock(jspeUnaryExpression())));\n    } else if (tk=='-') { // unary minus\n      return jsvNegateAndUnLock(jspeUnaryExpression()); // names already skipped\n    }  else if (tk=='+') { // unary plus (convert to number)\n      JsVar *v = jsvSkipNameAndUnLock(jspeUnaryExpression());\n      JsVar *r = jsvAsNumber(v); // names already skipped\n      jsvUnLock(v);\n      return r;\n    }\n    assert(0);\n    return 0;\n  } else\n    return jspePostfixExpression();\n}\n\n\nunsigned int jspeGetBinaryExpressionPrecedence(int op) {\n  switch (op) {\n  case LEX_OROR: return 1; break;\n  case LEX_ANDAND: return 2; break;\n  case '|' : return 3; break;\n  case '^' : return 4; break;\n  case '&' : return 5; break;\n  case LEX_EQUAL:\n  case LEX_NEQUAL:\n  case LEX_TYPEEQUAL:\n  case LEX_NTYPEEQUAL: return 6;\n  case LEX_LEQUAL:\n  case LEX_GEQUAL:\n  case '<':\n  case '>':\n  case LEX_R_INSTANCEOF: return 7;\n  case LEX_R_IN: return (execInfo.execute&EXEC_FOR_INIT)?0:7;\n  case LEX_LSHIFT:\n  case LEX_RSHIFT:\n  case LEX_RSHIFTUNSIGNED: return 8;\n  case '+':\n  case '-': return 9;\n  case '*':\n  case '/':\n  case '%': return 10;\n  default: return 0;\n  }\n}\n\nNO_INLINE JsVar *__jspeBinaryExpression(JsVar *a, unsigned int lastPrecedence) {\n  /* This one's a bit strange. Basically all the ops have their own precedence, it's not\n   * like & and | share the same precedence. We don't want to recurse for each one,\n   * so instead we do this.\n   *\n   * We deal with an expression in recursion ONLY if it's of higher precedence\n   * than the current one, otherwise we stick in the while loop.\n   */\n  unsigned int precedence = jspeGetBinaryExpressionPrecedence(lex->tk);\n  while (precedence && precedence>lastPrecedence) {\n    int op = lex->tk;\n    JSP_ASSERT_MATCH(op);\n\n    if (op==LEX_ANDAND || op==LEX_OROR) {\n      bool aValue = jsvGetBoolAndUnLock(jsvSkipName(a));\n      if ((!aValue && op==LEX_ANDAND) ||\n          (aValue && op==LEX_OROR)) {\n        JSP_SAVE_EXECUTE();\n        jspSetNoExecute();\n        jsvUnLock(__jspeBinaryExpression(jspeUnaryExpression(),precedence));\n        JSP_RESTORE_EXECUTE();\n      } else {\n        jsvUnLock(a);\n        a = __jspeBinaryExpression(jspeUnaryExpression(),precedence);\n      }\n    } else { // else it's a more 'normal' logical expression - just use Maths\n      JsVar *b = __jspeBinaryExpression(jspeUnaryExpression(),precedence);\n      if (JSP_SHOULD_EXECUTE) {\n        if (op==LEX_R_IN) {\n          JsVar *av = jsvSkipName(a); // needle\n          JsVar *bv = jsvSkipName(b); // haystack\n          if (jsvIsArray(bv) || jsvIsObject(bv)) { // search keys, NOT values\n            av = jsvAsArrayIndexAndUnLock(av);\n            JsVar *varFound = jspGetVarNamedField( bv, av, true);\n            jsvUnLock(a);\n            a = jsvNewFromBool(varFound!=0);\n            jsvUnLock(varFound);\n          } else {// else it will be undefined\n            jsExceptionHere(JSET_ERROR, \"Cannot use 'in' operator to search a %t\", bv);\n            jsvUnLock(a);\n            a = 0;\n          }\n          jsvUnLock2(av, bv);\n        } else if (op==LEX_R_INSTANCEOF) {\n          bool inst = false;\n          JsVar *av = jsvSkipName(a);\n          JsVar *bv = jsvSkipName(b);\n          if (!jsvIsFunction(bv)) {\n            jsExceptionHere(JSET_ERROR, \"Expecting a function on RHS in instanceof check, got %t\", bv);\n          } else {\n            if (jsvIsObject(av) || jsvIsFunction(av)) {\n              JsVar *bproto = jspGetNamedField(bv, JSPARSE_PROTOTYPE_VAR, false);\n              JsVar *proto = jsvObjectGetChild(av, JSPARSE_INHERITS_VAR, 0);\n              while (proto) {\n                if (proto == bproto) inst=true;\n                JsVar *childProto = jsvObjectGetChild(proto, JSPARSE_INHERITS_VAR, 0);\n                jsvUnLock(proto);\n                proto = childProto;\n              }\n              if (jspIsConstructor(bv, \"Object\")) inst = true;\n              jsvUnLock(bproto);\n            }\n            if (!inst) {\n              const char *name = jswGetBasicObjectName(av);\n              if (name) {\n                inst = jspIsConstructor(bv, name);\n              }\n              if (!inst && (jsvIsArray(av) || jsvIsArrayBuffer(av)) &&\n                  jspIsConstructor(bv, \"Object\"))\n                inst = true;\n            }\n          }\n          jsvUnLock3(av, bv, a);\n          a = jsvNewFromBool(inst);\n        } else {  // --------------------------------------------- NORMAL\n          JsVar *res = jsvMathsOpSkipNames(a, b, op);\n          jsvUnLock(a); a = res;\n        }\n      }\n      jsvUnLock(b);\n    }\n    precedence = jspeGetBinaryExpressionPrecedence(lex->tk);\n  }\n  return a;\n}\n\nJsVar *jspeBinaryExpression() {\n  return __jspeBinaryExpression(jspeUnaryExpression(),0);\n}\n\nNO_INLINE JsVar *__jspeConditionalExpression(JsVar *lhs) {\n  if (lex->tk=='?') {\n    JSP_ASSERT_MATCH('?');\n    if (!JSP_SHOULD_EXECUTE) {\n      jsvUnLock(jspeAssignmentExpression());\n      JSP_MATCH(':');\n      jsvUnLock(jspeAssignmentExpression());\n    } else {\n      bool first = jsvGetBoolAndUnLock(jsvSkipName(lhs));\n      jsvUnLock(lhs);\n      if (first) {\n        lhs = jspeAssignmentExpression();\n        JSP_MATCH(':');\n        JSP_SAVE_EXECUTE();\n        jspSetNoExecute();\n        jsvUnLock(jspeAssignmentExpression());\n        JSP_RESTORE_EXECUTE();\n      } else {\n        JSP_SAVE_EXECUTE();\n        jspSetNoExecute();\n        jsvUnLock(jspeAssignmentExpression());\n        JSP_RESTORE_EXECUTE();\n        JSP_MATCH(':');\n        lhs = jspeAssignmentExpression();\n      }\n    }\n  }\n\n  return lhs;\n}\n\nJsVar *jspeConditionalExpression() {\n  return __jspeConditionalExpression(jspeBinaryExpression());\n}\n\nNO_INLINE JsVar *__jspeAssignmentExpression(JsVar *lhs) {\n  if (lex->tk=='=' || lex->tk==LEX_PLUSEQUAL || lex->tk==LEX_MINUSEQUAL ||\n      lex->tk==LEX_MULEQUAL || lex->tk==LEX_DIVEQUAL || lex->tk==LEX_MODEQUAL ||\n      lex->tk==LEX_ANDEQUAL || lex->tk==LEX_OREQUAL ||\n      lex->tk==LEX_XOREQUAL || lex->tk==LEX_RSHIFTEQUAL ||\n      lex->tk==LEX_LSHIFTEQUAL || lex->tk==LEX_RSHIFTUNSIGNEDEQUAL) {\n    JsVar *rhs;\n\n    int op = lex->tk;\n    JSP_ASSERT_MATCH(op);\n    rhs = jspeAssignmentExpression();\n    rhs = jsvSkipNameAndUnLock(rhs); // ensure we get rid of any references on the RHS\n \n     if (JSP_SHOULD_EXECUTE && lhs) {\n       if (op=='=') {\n        /* If we're assigning to this and we don't have a parent,\n         * add it to the symbol table root */\n        if (!jsvGetRefs(lhs) && jsvIsName(lhs)) {\n          if (!jsvIsArrayBufferName(lhs) && !jsvIsNewChild(lhs))\n            jsvAddName(execInfo.root, lhs);\n        }\n        jspReplaceWith(lhs, rhs);\n       } else {\n         if (op==LEX_PLUSEQUAL) op='+';\n         else if (op==LEX_MINUSEQUAL) op='-';\n        else if (op==LEX_MULEQUAL) op='*';\n        else if (op==LEX_DIVEQUAL) op='/';\n        else if (op==LEX_MODEQUAL) op='%';\n        else if (op==LEX_ANDEQUAL) op='&';\n        else if (op==LEX_OREQUAL) op='|';\n        else if (op==LEX_XOREQUAL) op='^';\n        else if (op==LEX_RSHIFTEQUAL) op=LEX_RSHIFT;\n        else if (op==LEX_LSHIFTEQUAL) op=LEX_LSHIFT;\n        else if (op==LEX_RSHIFTUNSIGNEDEQUAL) op=LEX_RSHIFTUNSIGNED;\n        if (op=='+' && jsvIsName(lhs)) {\n          JsVar *currentValue = jsvSkipName(lhs);\n          if (jsvIsString(currentValue) && !jsvIsFlatString(currentValue) && jsvGetRefs(currentValue)==1 && rhs!=currentValue) {\n            /* A special case for string += where this is the only use of the string\n             * and we're not appending to ourselves. In this case we can do a\n             * simple append (rather than clone + append)*/\n            JsVar *str = jsvAsString(rhs, false);\n            jsvAppendStringVarComplete(currentValue, str);\n            jsvUnLock(str);\n            op = 0;\n          }\n          jsvUnLock(currentValue);\n        }\n        if (op) {\n          /* Fallback which does a proper add */\n          JsVar *res = jsvMathsOpSkipNames(lhs,rhs,op);\n          jspReplaceWith(lhs, res);\n          jsvUnLock(res);\n        }\n      }\n    }\n    jsvUnLock(rhs);\n  }\n  return lhs;\n}\n\n\nJsVar *jspeAssignmentExpression() {\n  return __jspeAssignmentExpression(jspeConditionalExpression());\n}\n\nNO_INLINE JsVar *jspeExpression() {\n  while (!JSP_SHOULDNT_PARSE) {\n    JsVar *a = jspeAssignmentExpression();\n    if (lex->tk!=',') return a;\n    jsvCheckReferenceError(a);\n    jsvUnLock(a);\n    JSP_ASSERT_MATCH(',');\n  }\n  return 0;\n}\n\n/** Parse a block `{ ... }` but assume brackets are already parsed */\nNO_INLINE void jspeBlockNoBrackets() {\n  if (JSP_SHOULD_EXECUTE) {\n    while (lex->tk && lex->tk!='}') {\n      JsVar *a = jspeStatement();\n      jsvCheckReferenceError(a);\n      jsvUnLock(a);\n      if (JSP_HAS_ERROR) {\n        if (lex && !(execInfo.execute&EXEC_ERROR_LINE_REPORTED)) {\n          execInfo.execute = (JsExecFlags)(execInfo.execute | EXEC_ERROR_LINE_REPORTED);\n          JsVar *stackTrace = jsvObjectGetChild(execInfo.hiddenRoot, JSPARSE_STACKTRACE_VAR, JSV_STRING_0);\n          if (stackTrace) {\n            jsvAppendPrintf(stackTrace, \"at \");\n            jspAppendStackTrace(stackTrace);\n            jsvUnLock(stackTrace);\n          }\n        }\n      }\n      if (JSP_SHOULDNT_PARSE)\n        return;\n    }\n  } else {\n    int brackets = 0;\n    while (lex->tk && (brackets || lex->tk != '}')) {\n      if (lex->tk == '{') brackets++;\n      if (lex->tk == '}') brackets--;\n      JSP_ASSERT_MATCH(lex->tk);\n    }\n  }\n  return;\n}\n", "target": 1, "idx": 182380}
{"func": "static int muscle_card_extract_key(sc_card_t *card, sc_cardctl_muscle_key_info_t *info)\n{\n\t/* CURRENTLY DONT SUPPORT EXTRACTING PRIVATE KEYS... */\n\tswitch(info->keyType) {\n\tcase 1: /* RSA */\n\t\treturn msc_extract_rsa_public_key(card,\n\t\t\tinfo->keyLocation,\n\t\t\t&info->modLength,\n\t\t\t&info->modValue,\n\t\t\t&info->expLength,\n\t\t\t&info->expValue);\n\tdefault:\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t}\n}\n", "target": 0, "idx": 78746}
{"func": "void LocalFileSystem::deleteFileSystem(ExecutionContext* context, FileSystemType type, PassOwnPtr<AsyncFileSystemCallbacks> callbacks)\n{\n    RefPtrWillBeRawPtr<ExecutionContext> contextPtr(context);\n     ASSERT(context);\n     ASSERT_WITH_SECURITY_IMPLICATION(context->isDocument());\n \n    RefPtr<CallbackWrapper> wrapper = adoptRef(new CallbackWrapper(callbacks));\n     requestFileSystemAccessInternal(context,\n         bind(&LocalFileSystem::deleteFileSystemInternal, this, contextPtr, type, wrapper),\n         bind(&LocalFileSystem::fileSystemNotAllowedInternal, this, contextPtr, wrapper));\n}\n", "target": 1, "idx": 185122}
{"func": "IW_IMPL(void) iw_vsnprintf(char *buf, size_t buflen, const char *fmt, va_list ap)\n{\n#ifdef IW_WINDOWS\n\tStringCchVPrintfA(buf,buflen,fmt,ap);\n#else\n\tvsnprintf(buf,buflen,fmt,ap);\n\tbuf[buflen-1]='\\0';\n#endif\n}\n", "target": 0, "idx": 66298}
{"func": "void V8TestObject::VoidMethodStringArgVariadicStringArgMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), \"Blink_TestObject_voidMethodStringArgVariadicStringArg\");\n\n  test_object_v8_internal::VoidMethodStringArgVariadicStringArgMethod(info);\n}\n", "target": 0, "idx": 148158}
{"func": "  Load_SBit_Png( FT_GlyphSlot     slot,\n                 FT_Int           x_offset,\n                 FT_Int           y_offset,\n                 FT_Int           pix_bits,\n                 TT_SBit_Metrics  metrics,\n                 FT_Memory        memory,\n                 FT_Byte*         data,\n                 FT_UInt          png_len,\n                 FT_Bool          populate_map_and_metrics )\n  {\n    FT_Bitmap    *map   = &slot->bitmap;\n    FT_Error      error = FT_Err_Ok;\n    FT_StreamRec  stream;\n\n    png_structp  png;\n    png_infop    info;\n    png_uint_32  imgWidth, imgHeight;\n\n    int         bitdepth, color_type, interlace;\n    FT_Int      i;\n    png_byte*  *rows = NULL; /* pacify compiler */\n\n\n    if ( x_offset < 0 ||\n         y_offset < 0 )\n    {\n      error = FT_THROW( Invalid_Argument );\n       goto Exit;\n     }\n \n    if ( !populate_map_and_metrics                   &&\n         ( x_offset + metrics->width  > map->width ||\n           y_offset + metrics->height > map->rows  ||\n           pix_bits != 32                          ||\n           map->pixel_mode != FT_PIXEL_MODE_BGRA   ) )\n     {\n       error = FT_THROW( Invalid_Argument );\n       goto Exit;\n    }\n\n    FT_Stream_OpenMemory( &stream, data, png_len );\n\n    png = png_create_read_struct( PNG_LIBPNG_VER_STRING,\n                                  &error,\n                                  error_callback,\n                                  warning_callback );\n    if ( !png )\n    {\n      error = FT_THROW( Out_Of_Memory );\n      goto Exit;\n    }\n\n    info = png_create_info_struct( png );\n    if ( !info )\n    {\n      error = FT_THROW( Out_Of_Memory );\n      png_destroy_read_struct( &png, NULL, NULL );\n      goto Exit;\n    }\n\n    if ( ft_setjmp( png_jmpbuf( png ) ) )\n    {\n      error = FT_THROW( Invalid_File_Format );\n      goto DestroyExit;\n    }\n\n    png_set_read_fn( png, &stream, read_data_from_FT_Stream );\n\n    png_read_info( png, info );\n    png_get_IHDR( png, info,\n                  &imgWidth, &imgHeight,\n                  &bitdepth, &color_type, &interlace,\n                  NULL, NULL );\n\n    if ( error                                        ||\n         ( !populate_map_and_metrics                &&\n           ( (FT_Int)imgWidth  != metrics->width  ||\n             (FT_Int)imgHeight != metrics->height ) ) )\n      goto DestroyExit;\n\n    if ( populate_map_and_metrics )\n    {\n      FT_Long  size;\n\n\n      metrics->width  = (FT_Int)imgWidth;\n      metrics->height = (FT_Int)imgHeight;\n\n      map->width      = metrics->width;\n      map->rows       = metrics->height;\n      map->pixel_mode = FT_PIXEL_MODE_BGRA;\n      map->pitch      = map->width * 4;\n      map->num_grays  = 256;\n\n      /* reject too large bitmaps similarly to the rasterizer */\n      if ( map->rows > 0x7FFF || map->width > 0x7FFF )\n      {\n        error = FT_THROW( Array_Too_Large );\n        goto DestroyExit;\n      }\n\n      size = map->rows * map->pitch;\n\n      error = ft_glyphslot_alloc_bitmap( slot, size );\n      if ( error )\n        goto DestroyExit;\n    }\n\n    /* convert palette/gray image to rgb */\n    if ( color_type == PNG_COLOR_TYPE_PALETTE )\n      png_set_palette_to_rgb( png );\n\n    /* expand gray bit depth if needed */\n    if ( color_type == PNG_COLOR_TYPE_GRAY )\n    {\n#if PNG_LIBPNG_VER >= 10209\n      png_set_expand_gray_1_2_4_to_8( png );\n#else\n      png_set_gray_1_2_4_to_8( png );\n#endif\n    }\n\n    /* transform transparency to alpha */\n    if ( png_get_valid(png, info, PNG_INFO_tRNS ) )\n      png_set_tRNS_to_alpha( png );\n\n    if ( bitdepth == 16 )\n      png_set_strip_16( png );\n\n    if ( bitdepth < 8 )\n      png_set_packing( png );\n\n    /* convert grayscale to RGB */\n    if ( color_type == PNG_COLOR_TYPE_GRAY       ||\n         color_type == PNG_COLOR_TYPE_GRAY_ALPHA )\n      png_set_gray_to_rgb( png );\n\n    if ( interlace != PNG_INTERLACE_NONE )\n      png_set_interlace_handling( png );\n\n    png_set_filler( png, 0xFF, PNG_FILLER_AFTER );\n\n    /* recheck header after setting EXPAND options */\n    png_read_update_info(png, info );\n    png_get_IHDR( png, info,\n                  &imgWidth, &imgHeight,\n                  &bitdepth, &color_type, &interlace,\n                  NULL, NULL );\n\n    if ( bitdepth != 8                              ||\n        !( color_type == PNG_COLOR_TYPE_RGB       ||\n           color_type == PNG_COLOR_TYPE_RGB_ALPHA ) )\n    {\n      error = FT_THROW( Invalid_File_Format );\n      goto DestroyExit;\n    }\n\n    switch ( color_type )\n    {\n    default:\n      /* Shouldn't happen, but fall through. */\n\n    case PNG_COLOR_TYPE_RGB_ALPHA:\n      png_set_read_user_transform_fn( png, premultiply_data );\n      break;\n\n    case PNG_COLOR_TYPE_RGB:\n      /* Humm, this smells.  Carry on though. */\n      png_set_read_user_transform_fn( png, convert_bytes_to_data );\n      break;\n    }\n\n    if ( FT_NEW_ARRAY( rows, imgHeight ) )\n    {\n      error = FT_THROW( Out_Of_Memory );\n      goto DestroyExit;\n    }\n\n    for ( i = 0; i < (FT_Int)imgHeight; i++ )\n      rows[i] = map->buffer + ( y_offset + i ) * map->pitch + x_offset * 4;\n\n    png_read_image( png, rows );\n\n    FT_FREE( rows );\n\n    png_read_end( png, info );\n\n  DestroyExit:\n    png_destroy_read_struct( &png, &info, NULL );\n    FT_Stream_Close( &stream );\n\n  Exit:\n    return error;\n  }\n", "target": 1, "idx": 178026}
{"func": " int PDFiumEngine::GetVisiblePageIndex(FPDF_PAGE page) {\n  for (int page_index : visible_pages_) {\n     if (pages_[page_index]->GetPage() == page)\n       return page_index;\n   }\n  return -1;\n}\n", "target": 1, "idx": 186678}
{"func": "static void chase_port(struct edgeport_port *port, unsigned long timeout,\n\t\t\t\t\t\t\t\tint flush)\n{\n\tint baud_rate;\n\tstruct tty_struct *tty = tty_port_tty_get(&port->port->port);\n\tstruct usb_serial *serial = port->port->serial;\n \twait_queue_t wait;\n \tunsigned long flags;\n \n \tif (!timeout)\n \t\ttimeout = (HZ * EDGE_CLOSING_WAIT)/100;\n \n\t/* wait for data to drain from the buffer */\n\tspin_lock_irqsave(&port->ep_lock, flags);\n\tinit_waitqueue_entry(&wait, current);\n\tadd_wait_queue(&tty->write_wait, &wait);\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (kfifo_len(&port->write_fifo) == 0\n\t\t|| timeout == 0 || signal_pending(current)\n\t\t|| serial->disconnected)\n\t\t\t/* disconnect */\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&port->ep_lock, flags);\n\t\ttimeout = schedule_timeout(timeout);\n\t\tspin_lock_irqsave(&port->ep_lock, flags);\n\t}\n\tset_current_state(TASK_RUNNING);\n\tremove_wait_queue(&tty->write_wait, &wait);\n\tif (flush)\n\t\tkfifo_reset_out(&port->write_fifo);\n\tspin_unlock_irqrestore(&port->ep_lock, flags);\n\ttty_kref_put(tty);\n\n\t/* wait for data to drain from the device */\n\ttimeout += jiffies;\n\twhile ((long)(jiffies - timeout) < 0 && !signal_pending(current)\n\t\t\t\t\t\t&& !serial->disconnected) {\n\t\t/* not disconnected */\n\t\tif (!tx_active(port))\n\t\t\tbreak;\n\t\tmsleep(10);\n\t}\n\n\t/* disconnected */\n\tif (serial->disconnected)\n\t\treturn;\n\n\t/* wait one more character time, based on baud rate */\n\t/* (tx_active doesn't seem to wait for the last byte) */\n\tbaud_rate = port->baud_rate;\n\tif (baud_rate == 0)\n\t\tbaud_rate = 50;\n\tmsleep(max(1, DIV_ROUND_UP(10000, baud_rate)));\n}\n", "target": 1, "idx": 179294}
{"func": "void WebRuntimeFeatures::enableNotifications(bool enable)\n{\n    RuntimeEnabledFeatures::setNotificationsEnabled(enable);\n}\n", "target": 0, "idx": 124437}
{"func": "static struct key *request_master_key(struct encrypted_key_payload *epayload,\n\t\t\t\t      u8 **master_key, size_t *master_keylen)\n{\n\tstruct key *mkey = NULL;\n\n\tif (!strncmp(epayload->master_desc, KEY_TRUSTED_PREFIX,\n\t\t     KEY_TRUSTED_PREFIX_LEN)) {\n\t\tmkey = request_trusted_key(epayload->master_desc +\n\t\t\t\t\t   KEY_TRUSTED_PREFIX_LEN,\n\t\t\t\t\t   master_key, master_keylen);\n\t} else if (!strncmp(epayload->master_desc, KEY_USER_PREFIX,\n\t\t\t    KEY_USER_PREFIX_LEN)) {\n\t\tmkey = request_user_key(epayload->master_desc +\n\t\t\t\t\tKEY_USER_PREFIX_LEN,\n\t\t\t\t\tmaster_key, master_keylen);\n\t} else\n\t\tgoto out;\n\n\tif (IS_ERR(mkey)) {\n\t\tint ret = PTR_ERR(mkey);\n\n\t\tif (ret == -ENOTSUPP)\n\t\t\tpr_info(\"encrypted_key: key %s not supported\",\n\t\t\t\tepayload->master_desc);\n\t\telse\n\t\t\tpr_info(\"encrypted_key: key %s not found\",\n\t\t\t\tepayload->master_desc);\n\t\tgoto out;\n\t}\n\n\tdump_master_key(*master_key, *master_keylen);\nout:\n\treturn mkey;\n}\n", "target": 0, "idx": 69534}
{"func": "static int m_show(struct seq_file *m, void *v)\n{\n\tstruct proc_mounts *p = proc_mounts(m);\n\tstruct mount *r = list_entry(v, struct mount, mnt_list);\n\treturn p->show(m, &r->mnt);\n}\n", "target": 0, "idx": 32369}
{"func": "GpuChannelHost* RenderThreadImpl::EstablishGpuChannelSync(\n    content::CauseForGpuLaunch cause_for_gpu_launch) {\n  if (gpu_channel_.get()) {\n    if (gpu_channel_->state() == GpuChannelHost::kUnconnected ||\n        gpu_channel_->state() == GpuChannelHost::kConnected)\n      return GetGpuChannel();\n\n    gpu_channel_ = NULL;\n  }\n\n   int client_id = 0;\n   IPC::ChannelHandle channel_handle;\n  base::ProcessHandle renderer_process_for_gpu;\n   content::GPUInfo gpu_info;\n   if (!Send(new GpuHostMsg_EstablishGpuChannel(cause_for_gpu_launch,\n                                                &client_id,\n                                                &channel_handle,\n                                               &renderer_process_for_gpu,\n                                                &gpu_info)) ||\n      channel_handle.name.empty() ||\n #if defined(OS_POSIX)\n       channel_handle.socket.fd == -1 ||\n #endif\n      renderer_process_for_gpu == base::kNullProcessHandle) {\n     gpu_channel_ = NULL;\n     return NULL;\n  }\n\n  gpu_channel_ = new GpuChannelHost(this, 0, client_id);\n  gpu_channel_->set_gpu_info(gpu_info);\n   content::GetContentClient()->SetGpuInfo(gpu_info);\n \n  gpu_channel_->Connect(channel_handle, renderer_process_for_gpu);\n \n   return GetGpuChannel();\n }\n", "target": 1, "idx": 184581}
{"func": "bool XSSAuditor::FilterInputToken(const FilterTokenRequest& request) {\n  DCHECK_EQ(request.token.GetType(), HTMLToken::kStartTag);\n  DCHECK(HasName(request.token, inputTag));\n\n  return EraseAttributeIfInjected(request, formactionAttr, kURLWithUniqueOrigin,\n                                  kSrcLikeAttributeTruncation);\n}\n", "target": 0, "idx": 159803}
{"func": "static struct rtable *__mkroute_output(const struct fib_result *res,\n\t\t\t\t       const struct flowi4 *fl4, int orig_oif,\n\t\t\t\t       struct net_device *dev_out,\n\t\t\t\t       unsigned int flags)\n{\n\tstruct fib_info *fi = res->fi;\n\tstruct fib_nh_exception *fnhe;\n\tstruct in_device *in_dev;\n\tu16 type = res->type;\n\tstruct rtable *rth;\n\tbool do_cache;\n\n\tin_dev = __in_dev_get_rcu(dev_out);\n\tif (!in_dev)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (likely(!IN_DEV_ROUTE_LOCALNET(in_dev)))\n\t\tif (ipv4_is_loopback(fl4->saddr) &&\n\t\t    !(dev_out->flags & IFF_LOOPBACK) &&\n\t\t    !netif_is_l3_master(dev_out))\n\t\t\treturn ERR_PTR(-EINVAL);\n\n\tif (ipv4_is_lbcast(fl4->daddr))\n\t\ttype = RTN_BROADCAST;\n\telse if (ipv4_is_multicast(fl4->daddr))\n\t\ttype = RTN_MULTICAST;\n\telse if (ipv4_is_zeronet(fl4->daddr))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (dev_out->flags & IFF_LOOPBACK)\n\t\tflags |= RTCF_LOCAL;\n\n\tdo_cache = true;\n\tif (type == RTN_BROADCAST) {\n\t\tflags |= RTCF_BROADCAST | RTCF_LOCAL;\n\t\tfi = NULL;\n\t} else if (type == RTN_MULTICAST) {\n\t\tflags |= RTCF_MULTICAST | RTCF_LOCAL;\n\t\tif (!ip_check_mc_rcu(in_dev, fl4->daddr, fl4->saddr,\n\t\t\t\t     fl4->flowi4_proto))\n\t\t\tflags &= ~RTCF_LOCAL;\n\t\telse\n\t\t\tdo_cache = false;\n\t\t/* If multicast route do not exist use\n\t\t * default one, but do not gateway in this case.\n\t\t * Yes, it is hack.\n\t\t */\n\t\tif (fi && res->prefixlen < 4)\n\t\t\tfi = NULL;\n\t} else if ((type == RTN_LOCAL) && (orig_oif != 0) &&\n\t\t   (orig_oif != dev_out->ifindex)) {\n\t\t/* For local routes that require a particular output interface\n\t\t * we do not want to cache the result.  Caching the result\n\t\t * causes incorrect behaviour when there are multiple source\n\t\t * addresses on the interface, the end result being that if the\n\t\t * intended recipient is waiting on that interface for the\n\t\t * packet he won't receive it because it will be delivered on\n\t\t * the loopback interface and the IP_PKTINFO ipi_ifindex will\n\t\t * be set to the loopback interface as well.\n\t\t */\n\t\tdo_cache = false;\n\t}\n\n\tfnhe = NULL;\n\tdo_cache &= fi != NULL;\n\tif (fi) {\n\t\tstruct rtable __rcu **prth;\n\t\tstruct fib_nh *nh = &FIB_RES_NH(*res);\n\n\t\tfnhe = find_exception(nh, fl4->daddr);\n\t\tif (!do_cache)\n\t\t\tgoto add;\n\t\tif (fnhe) {\n\t\t\tprth = &fnhe->fnhe_rth_output;\n\t\t} else {\n\t\t\tif (unlikely(fl4->flowi4_flags &\n\t\t\t\t     FLOWI_FLAG_KNOWN_NH &&\n\t\t\t\t     !(nh->nh_gw &&\n\t\t\t\t       nh->nh_scope == RT_SCOPE_LINK))) {\n\t\t\t\tdo_cache = false;\n\t\t\t\tgoto add;\n\t\t\t}\n\t\t\tprth = raw_cpu_ptr(nh->nh_pcpu_rth_output);\n\t\t}\n\t\trth = rcu_dereference(*prth);\n\t\tif (rt_cache_valid(rth) && dst_hold_safe(&rth->dst))\n\t\t\treturn rth;\n\t}\n\nadd:\n\trth = rt_dst_alloc(dev_out, flags, type,\n\t\t\t   IN_DEV_CONF_GET(in_dev, NOPOLICY),\n\t\t\t   IN_DEV_CONF_GET(in_dev, NOXFRM),\n\t\t\t   do_cache);\n\tif (!rth)\n\t\treturn ERR_PTR(-ENOBUFS);\n\n\trth->rt_iif = orig_oif;\n\n\tRT_CACHE_STAT_INC(out_slow_tot);\n\n\tif (flags & (RTCF_BROADCAST | RTCF_MULTICAST)) {\n\t\tif (flags & RTCF_LOCAL &&\n\t\t    !(dev_out->flags & IFF_LOOPBACK)) {\n\t\t\trth->dst.output = ip_mc_output;\n\t\t\tRT_CACHE_STAT_INC(out_slow_mc);\n\t\t}\n#ifdef CONFIG_IP_MROUTE\n\t\tif (type == RTN_MULTICAST) {\n\t\t\tif (IN_DEV_MFORWARD(in_dev) &&\n\t\t\t    !ipv4_is_local_multicast(fl4->daddr)) {\n\t\t\t\trth->dst.input = ip_mr_input;\n\t\t\t\trth->dst.output = ip_mc_output;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\n\trt_set_nexthop(rth, fl4->daddr, res, fnhe, fi, type, 0, do_cache);\n\tlwtunnel_set_redirect(&rth->dst);\n\n\treturn rth;\n}\n", "target": 0, "idx": 91112}
{"func": "static int shutdown_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_run *kvm_run = svm->vcpu.run;\n\n\t/*\n\t * VMCB is undefined after a SHUTDOWN intercept\n\t * so reinitialize it.\n\t */\n\tclear_page(svm->vmcb);\n\tinit_vmcb(svm);\n\n\tkvm_run->exit_reason = KVM_EXIT_SHUTDOWN;\n\treturn 0;\n}\n", "target": 0, "idx": 37818}
{"func": "kdc_process_for_user(kdc_realm_t *kdc_active_realm,\n                     krb5_pa_data *pa_data,\n                     krb5_keyblock *tgs_session,\n                     krb5_pa_s4u_x509_user **s4u_x509_user,\n                     const char **status)\n{\n    krb5_error_code             code;\n    krb5_pa_for_user            *for_user;\n    krb5_data                   req_data;\n\n    req_data.length = pa_data->length;\n     req_data.data = (char *)pa_data->contents;\n \n     code = decode_krb5_pa_for_user(&req_data, &for_user);\n    if (code)\n         return code;\n \n     code = verify_for_user_checksum(kdc_context, tgs_session, for_user);\n     if (code) {\n        *status = \"INVALID_S4U2SELF_CHECKSUM\";\n        krb5_free_pa_for_user(kdc_context, for_user);\n        return code;\n    }\n\n    *s4u_x509_user = calloc(1, sizeof(krb5_pa_s4u_x509_user));\n    if (*s4u_x509_user == NULL) {\n        krb5_free_pa_for_user(kdc_context, for_user);\n        return ENOMEM;\n    }\n\n    (*s4u_x509_user)->user_id.user = for_user->user;\n    for_user->user = NULL;\n    krb5_free_pa_for_user(kdc_context, for_user);\n\n    return 0;\n}\n", "target": 1, "idx": 181213}
{"func": "store_image_check(PNG_CONST png_store* ps, png_const_structp pp, int iImage)\n {\n    png_const_bytep image = ps->image;\n \n if (image[-1] != 0xed || image[ps->cb_image] != 0xfe)\n      png_error(pp, \"image overwrite\");\n else\n {\n png_size_t cbRow = ps->cb_row;\n      png_uint_32 rows = ps->image_h;\n\n      image += iImage * (cbRow+5) * ps->image_h;\n\n      image += 2; /* skip image first row markers */\n\n while (rows-- > 0)\n {\n if (image[-2] != 190 || image[-1] != 239)\n            png_error(pp, \"row start overwritten\");\n\n if (image[cbRow] != 222 || image[cbRow+1] != 173 ||\n            image[cbRow+2] != 17)\n            png_error(pp, \"row end overwritten\");\n\n         image += cbRow+5;\n }\n }\n}\n", "target": 1, "idx": 187726}
{"func": "void WebPluginDelegateProxy::CopyFromTransportToBacking(const gfx::Rect& rect) {\n  if (!backing_store_canvas_.get()) {\n    return;\n  }\n\n#if defined(OS_MACOSX)\n  const size_t stride =\n      skia::PlatformCanvas::StrideForWidth(plugin_rect_.width());\n  const size_t chunk_size = 4 * rect.width();\n  uint8* source_data = static_cast<uint8*>(transport_store_->memory()) +\n                       rect.y() * stride + 4 * rect.x();\n  int dest_starting_row = plugin_rect_.height() - rect.y() - 1;\n  DCHECK(backing_store_.size() > 0);\n  uint8* target_data = &(backing_store_[0]) + dest_starting_row * stride +\n                       4 * rect.x();\n  for (int row = 0; row < rect.height(); ++row) {\n    memcpy(target_data, source_data, chunk_size);\n    source_data += stride;\n    target_data -= stride;\n  }\n#else\n  BlitCanvasToCanvas(backing_store_canvas_.get(), rect,\n                     transport_store_canvas_.get(), rect.origin());\n#endif\n  backing_store_painted_ = backing_store_painted_.Union(rect);\n}\n", "target": 0, "idx": 98755}
{"func": "std::string SanitizeRevision(const std::string& revision) {\n  for (size_t i = 0; i < revision.length(); i++) {\n    if (!(revision[i] == '@' && i == 0)\n        && !(revision[i] >= '0' && revision[i] <= '9')\n        && !(revision[i] >= 'a' && revision[i] <= 'z')\n        && !(revision[i] >= 'A' && revision[i] <= 'Z')) {\n      return std::string();\n    }\n  }\n  return revision;\n}\n", "target": 1, "idx": 186432}
{"func": "void Vp9Parser::ReadSegmentation() {\n  segmentation_.update_map = false;\n  segmentation_.update_data = false;\n \n  segmentation_.enabled = reader_.ReadBool();\n  if (!segmentation_.enabled)\n     return;\n \n  segmentation_.update_map = reader_.ReadBool();\n  if (segmentation_.update_map)\n    ReadSegmentationMap();\n \n  segmentation_.update_data = reader_.ReadBool();\n  if (segmentation_.update_data)\n    ReadSegmentationData();\n }\n", "target": 1, "idx": 183537}
{"func": "static int show_traces_open(struct inode *inode, struct file *file)\n{\n\tstruct trace_array *tr = inode->i_private;\n\tstruct seq_file *m;\n\tint ret;\n\n\tif (tracing_disabled)\n\t\treturn -ENODEV;\n\n\tret = seq_open(file, &show_traces_seq_ops);\n\tif (ret)\n\t\treturn ret;\n\n\tm = file->private_data;\n\tm->private = tr;\n\n\treturn 0;\n}\n", "target": 0, "idx": 81353}
{"func": "static void yy_flex_strncpy (char* s1, yyconst char * s2, int n , yyscan_t yyscanner)\n{\n\tstruct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\t(void)yyg;\n\n\tint i;\n\tfor ( i = 0; i < n; ++i )\n\t\ts1[i] = s2[i];\n}\n", "target": 0, "idx": 70509}
{"func": "static float CL_DemoFrameDurationSDev( void )\n{\n\tint i;\n\tint numFrames;\n\tfloat mean = 0.0f;\n\tfloat variance = 0.0f;\n\n\tif( ( clc.timeDemoFrames - 1 ) > MAX_TIMEDEMO_DURATIONS )\n\t\tnumFrames = MAX_TIMEDEMO_DURATIONS;\n\telse\n\t\tnumFrames = clc.timeDemoFrames - 1;\n\n\tfor( i = 0; i < numFrames; i++ )\n\t\tmean += clc.timeDemoDurations[ i ];\n\tmean /= numFrames;\n\n\tfor( i = 0; i < numFrames; i++ )\n\t{\n\t\tfloat x = clc.timeDemoDurations[ i ];\n\n\t\tvariance += ( ( x - mean ) * ( x - mean ) );\n\t}\n\tvariance /= numFrames;\n\n\treturn sqrt( variance );\n}\n", "target": 0, "idx": 95665}
{"func": "static void xfer_recover(struct xfer_header *xfer)\n{\n    struct xfer_item *item;\n    int r;\n\n    syslog(LOG_INFO, \"XFER: recovering\");\n\n    /* Backout any changes - we stop on first untouched mailbox */\n    for (item = xfer->items; item && item->state; item = item->next) {\n        switch (item->state) {\n        case XFER_UNDUMPED:\n        case XFER_LOCAL_MOVING:\n            /* Unset mailbox as MOVING on local server */\n            r = mboxlist_update(item->mbentry, 1);\n\n            if (r) {\n                syslog(LOG_ERR,\n                       \"Could not back out MOVING flag during move of %s (%s)\",\n                       item->mbentry->name, error_message(r));\n            }\n\n        case XFER_REMOTE_CREATED:\n            if (!xfer->use_replication) {\n                /* Delete remote mailbox */\n                prot_printf(xfer->be->out,\n                            \"LD1 LOCALDELETE {\" SIZE_T_FMT \"+}\\r\\n%s\\r\\n\",\n                            strlen(item->extname), item->extname);\n                r = getresult(xfer->be->in, \"LD1\");\n                if (r) {\n                    syslog(LOG_ERR,\n                        \"Could not back out remote mailbox during move of %s (%s)\",\n                        item->mbentry->name, error_message(r));\n                }\n            }\n\n        case XFER_DEACTIVATED:\n            /* Tell murder it's back here and active */\n            r = xfer_mupdate(1, item->mbentry->name, item->mbentry->partition,\n                             config_servername, item->mbentry->acl);\n            if (r) {\n                syslog(LOG_ERR,\n                       \"Could not back out mupdate during move of %s (%s)\",\n                       item->mbentry->name, error_message(r));\n            }\n        }\n    }\n}\n", "target": 0, "idx": 95283}
{"func": "void DevToolsDownloadManagerDelegate::OnDownloadPathGenerated(\n    uint32_t download_id,\n    const content::DownloadTargetCallback& callback,\n    const base::FilePath& suggested_path) {\n  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n \n   callback.Run(suggested_path,\n                content::DownloadItem::TARGET_DISPOSITION_OVERWRITE,\n               download::DOWNLOAD_DANGER_TYPE_NOT_DANGEROUS,\n                suggested_path.AddExtension(FILE_PATH_LITERAL(\".crdownload\")),\n                content::DOWNLOAD_INTERRUPT_REASON_NONE);\n }\n", "target": 1, "idx": 187159}
{"func": "v8::Local<v8::Value> V8Debugger::generatorObjectLocation(v8::Local<v8::Object> object)\n {\n     if (!enabled()) {\n         NOTREACHED();\n         return v8::Null(m_isolate);\n     }\n     v8::Local<v8::Value> argv[] = { object };\n     v8::Local<v8::Value> location = callDebuggerMethod(\"getGeneratorObjectLocation\", 1, argv).ToLocalChecked();\n    if (!location->IsObject())\n         return v8::Null(m_isolate);\n    v8::Local<v8::Context> context = m_debuggerContext.Get(m_isolate);\n    if (!markAsInternal(context, v8::Local<v8::Object>::Cast(location), V8InternalValueType::kLocation))\n         return v8::Null(m_isolate);\n    return location;\n }\n", "target": 1, "idx": 185980}
{"func": " views::View* LauncherView::GetAppListButtonView() const {\n   for (int i = 0; i < model_->item_count(); ++i) {\n     if (model_->items()[i].type == TYPE_APP_LIST)\n      return view_model_->view_at(i);\n  }\n\n  NOTREACHED() << \"Applist button not found\";\n  return NULL;\n}\n", "target": 0, "idx": 113179}
{"func": " PHP_FUNCTION(mcrypt_module_is_block_algorithm_mode)\n {\n \tMCRYPT_GET_MODE_DIR_ARGS(modes_dir)\n \tif (mcrypt_module_is_block_algorithm_mode(module, dir) == 1) {\n \t\tRETURN_TRUE;\n \t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n", "target": 1, "idx": 180268}
{"func": "static void skel(const char *homedir, uid_t u, gid_t g) {\n\tchar *fname;\n\n\tif (!arg_shell_none && (strcmp(cfg.shell,\"/usr/bin/zsh\") == 0 || strcmp(cfg.shell,\"/bin/zsh\") == 0)) {\n\t\tif (asprintf(&fname, \"%s/.zshrc\", homedir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tstruct stat s;\n \t\tif (stat(fname, &s) == 0)\n \t\t\treturn;\n \t\tif (stat(\"/etc/skel/.zshrc\", &s) == 0) {\n\t\t\tcopy_file(\"/etc/skel/.zshrc\", fname, u, g, 0644);\n \t\t\tfs_logger(\"clone /etc/skel/.zshrc\");\n \t\t}\n \t\telse {\n\t\t\ttouch_file_as_user(fname, u, g, 0644);\n\t\t\tfs_logger2(\"touch\", fname);\n\t\t}\n\t\tfree(fname);\n\t}\n\telse if (!arg_shell_none && strcmp(cfg.shell,\"/bin/csh\") == 0) {\n\t\tif (asprintf(&fname, \"%s/.cshrc\", homedir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tstruct stat s;\n \t\tif (stat(fname, &s) == 0)\n \t\t\treturn;\n \t\tif (stat(\"/etc/skel/.cshrc\", &s) == 0) {\n\t\t\tcopy_file(\"/etc/skel/.cshrc\", fname, u, g, 0644);\n \t\t\tfs_logger(\"clone /etc/skel/.cshrc\");\n \t\t}\n \t\telse {\n\t\t\ttouch_file_as_user(fname, u, g, 0644);\n\t\t\tfs_logger2(\"touch\", fname);\n\t\t}\n\t\tfree(fname);\n\t}\n\telse {\n\t\tif (asprintf(&fname, \"%s/.bashrc\", homedir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tstruct stat s;\n \t\tif (stat(fname, &s) == 0) \n \t\t\treturn;\n \t\tif (stat(\"/etc/skel/.bashrc\", &s) == 0) {\n\t\t\tcopy_file(\"/etc/skel/.bashrc\", fname, u, g, 0644);\n \t\t\tfs_logger(\"clone /etc/skel/.bashrc\");\n \t\t}\n \t\tfree(fname);\n\t}\n}\n", "target": 1, "idx": 181543}
{"func": "void CloseFds(const std::vector<int>& fds) {\n  for (const auto& it : fds) {\n    PCHECK(0 == IGNORE_EINTR(close(it)));\n  }\n}\n", "target": 0, "idx": 163067}
{"func": "static irqreturn_t armv7pmu_handle_irq(int irq_num, void *dev)\n{\n\tunsigned long pmnc;\n\tstruct perf_sample_data data;\n\tstruct cpu_hw_events *cpuc;\n\tstruct pt_regs *regs;\n\tint idx;\n\n\t/*\n\t * Get and reset the IRQ flags\n\t */\n\tpmnc = armv7_pmnc_getreset_flags();\n\n\t/*\n\t * Did an overflow occur?\n\t */\n\tif (!armv7_pmnc_has_overflowed(pmnc))\n\t\treturn IRQ_NONE;\n\n\t/*\n\t * Handle the counter(s) overflow(s)\n\t */\n\tregs = get_irq_regs();\n\n\tperf_sample_data_init(&data, 0);\n\n\tcpuc = &__get_cpu_var(cpu_hw_events);\n\tfor (idx = 0; idx <= armpmu->num_events; ++idx) {\n\t\tstruct perf_event *event = cpuc->events[idx];\n\t\tstruct hw_perf_event *hwc;\n\n\t\tif (!test_bit(idx, cpuc->active_mask))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * We have a single interrupt for all counters. Check that\n\t\t * each counter has overflowed before we process it.\n\t\t */\n\t\tif (!armv7_pmnc_counter_has_overflowed(pmnc, idx))\n\t\t\tcontinue;\n\n\t\thwc = &event->hw;\n\t\tarmpmu_event_update(event, hwc, idx, 1);\n\t\tdata.period = event->hw.last_period;\n \t\tif (!armpmu_event_set_period(event, hwc, idx))\n \t\t\tcontinue;\n \n\t\tif (perf_event_overflow(event, 0, &data, regs))\n \t\t\tarmpmu->disable(hwc, idx);\n \t}\n \n\t/*\n\t * Handle the pending perf events.\n\t *\n\t * Note: this call *must* be run with interrupts disabled. For\n\t * platforms that can have the PMU interrupts raised as an NMI, this\n\t * will not work.\n\t */\n\tirq_work_run();\n\n\treturn IRQ_HANDLED;\n}\n", "target": 1, "idx": 178946}
{"func": "bool ScrollAnchor::FindAnchorRecursive(LayoutObject* candidate) {\n  ExamineResult result = Examine(candidate);\n  if (result.viable) {\n    anchor_object_ = candidate;\n    corner_ = result.corner;\n  }\n\n  if (result.status == kReturn)\n    return true;\n\n  if (result.status == kSkip)\n    return false;\n\n  for (LayoutObject* child = candidate->SlowFirstChild(); child;\n       child = child->NextSibling()) {\n    if (FindAnchorRecursive(child))\n      return true;\n  }\n\n  if (auto* layouy_block = DynamicTo<LayoutBlock>(candidate)) {\n    if (TrackedLayoutBoxListHashSet* positioned_descendants =\n            layouy_block->PositionedObjects()) {\n      for (LayoutBox* descendant : *positioned_descendants) {\n        if (descendant->Parent() != candidate) {\n          if (FindAnchorRecursive(descendant))\n            return true;\n        }\n      }\n    }\n  }\n\n  if (result.status == kConstrain)\n    return true;\n\n  DCHECK_EQ(result.status, kContinue);\n  return false;\n}\n", "target": 0, "idx": 149660}
{"func": " static void perf_swevent_overflow(struct perf_event *event, u64 overflow,\n\t\t\t\t    int nmi, struct perf_sample_data *data,\n \t\t\t\t    struct pt_regs *regs)\n {\n \tstruct hw_perf_event *hwc = &event->hw;\n\tint throttle = 0;\n\n\tdata->period = event->hw.last_period;\n\tif (!overflow)\n\t\toverflow = perf_swevent_set_period(event);\n\n\tif (hwc->interrupts == MAX_INTERRUPTS)\n \t\treturn;\n \n \tfor (; overflow; overflow--) {\n\t\tif (__perf_event_overflow(event, nmi, throttle,\n \t\t\t\t\t    data, regs)) {\n \t\t\t/*\n \t\t\t * We inhibit the overflow from happening when\n\t\t\t * hwc->interrupts == MAX_INTERRUPTS.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t\tthrottle = 1;\n\t}\n }\n", "target": 1, "idx": 179011}
{"func": "void\tFS_Flush( fileHandle_t f ) {\n\tfflush(fsh[f].handleFiles.file.o);\n}\n", "target": 0, "idx": 96026}
{"func": "xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {\n    xmlChar limit = 0;\n    xmlChar *buf = NULL;\n    xmlChar *rep = NULL;\n    int len = 0;\n    int buf_size = 0;\n    int c, l, in_space = 0;\n    xmlChar *current = NULL;\n    xmlEntityPtr ent;\n\n    if (NXT(0) == '\"') {\n\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n\tlimit = '\"';\n        NEXT;\n    } else if (NXT(0) == '\\'') {\n\tlimit = '\\'';\n\tctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n        NEXT;\n    } else {\n\txmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n\treturn(NULL);\n    }\n\n    /*\n     * allocate a translation buffer.\n     */\n    buf_size = XML_PARSER_BUFFER_SIZE;\n    buf = (xmlChar *) xmlMallocAtomic(buf_size * sizeof(xmlChar));\n    if (buf == NULL) goto mem_error;\n\n    /*\n      * OK loop until we reach one of the ending char or a size limit.\n      */\n     c = CUR_CHAR(l);\n    while ((NXT(0) != limit) && /* checked */\n           (IS_CHAR(c)) && (c != '<')) {\n \tif (c == 0) break;\n \tif (c == '&') {\n \t    in_space = 0;\n\t    if (NXT(1) == '#') {\n\t\tint val = xmlParseCharRef(ctxt);\n\n\t\tif (val == '&') {\n\t\t    if (ctxt->replaceEntities) {\n\t\t\tif (len > buf_size - 10) {\n\t\t\t    growBuffer(buf, 10);\n\t\t\t}\n\t\t\tbuf[len++] = '&';\n\t\t    } else {\n\t\t\t/*\n\t\t\t * The reparsing will be done in xmlStringGetNodeList()\n\t\t\t * called by the attribute() function in SAX.c\n\t\t\t */\n\t\t\tif (len > buf_size - 10) {\n\t\t\t    growBuffer(buf, 10);\n\t\t\t}\n\t\t\tbuf[len++] = '&';\n\t\t\tbuf[len++] = '#';\n\t\t\tbuf[len++] = '3';\n\t\t\tbuf[len++] = '8';\n\t\t\tbuf[len++] = ';';\n\t\t    }\n\t\t} else if (val != 0) {\n\t\t    if (len > buf_size - 10) {\n\t\t\tgrowBuffer(buf, 10);\n\t\t    }\n\t\t    len += xmlCopyChar(0, &buf[len], val);\n\t\t}\n\t    } else {\n\t\tent = xmlParseEntityRef(ctxt);\n\t\tctxt->nbentities++;\n\t\tif (ent != NULL)\n\t\t    ctxt->nbentities += ent->owner;\n\t\tif ((ent != NULL) &&\n\t\t    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n\t\t    if (len > buf_size - 10) {\n\t\t\tgrowBuffer(buf, 10);\n\t\t    }\n\t\t    if ((ctxt->replaceEntities == 0) &&\n\t\t        (ent->content[0] == '&')) {\n\t\t\tbuf[len++] = '&';\n\t\t\tbuf[len++] = '#';\n\t\t\tbuf[len++] = '3';\n\t\t\tbuf[len++] = '8';\n\t\t\tbuf[len++] = ';';\n\t\t    } else {\n\t\t\tbuf[len++] = ent->content[0];\n\t\t    }\n\t\t} else if ((ent != NULL) && \n\t\t           (ctxt->replaceEntities != 0)) {\n\t\t    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n\t\t\t\t\t\t      XML_SUBSTITUTE_REF,\n\t\t\t\t\t\t      0, 0, 0);\n\t\t\tif (rep != NULL) {\n\t\t\t    current = rep;\n\t\t\t    while (*current != 0) { /* non input consuming */\n                                if ((*current == 0xD) || (*current == 0xA) ||\n                                    (*current == 0x9)) {\n                                    buf[len++] = 0x20;\n                                    current++;\n                                } else\n                                    buf[len++] = *current++;\n\t\t\t\tif (len > buf_size - 10) {\n\t\t\t\t    growBuffer(buf, 10);\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    xmlFree(rep);\n\t\t\t    rep = NULL;\n\t\t\t}\n\t\t    } else {\n\t\t\tif (len > buf_size - 10) {\n\t\t\t    growBuffer(buf, 10);\n\t\t\t}\n\t\t\tif (ent->content != NULL)\n\t\t\t    buf[len++] = ent->content[0];\n\t\t    }\n\t\t} else if (ent != NULL) {\n\t\t    int i = xmlStrlen(ent->name);\n\t\t    const xmlChar *cur = ent->name;\n\n\t\t    /*\n\t\t     * This may look absurd but is needed to detect\n\t\t     * entities problems\n\t\t     */\n\t\t    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n\t\t\t(ent->content != NULL)) {\n\t\t\trep = xmlStringDecodeEntities(ctxt, ent->content,\n\t\t\t\t\t\t  XML_SUBSTITUTE_REF, 0, 0, 0);\n\t\t\tif (rep != NULL) {\n\t\t\t    xmlFree(rep);\n\t\t\t    rep = NULL;\n\t\t\t}\n\t\t    }\n\n\t\t    /*\n\t\t     * Just output the reference\n\t\t     */\n\t\t    buf[len++] = '&';\n\t\t    while (len > buf_size - i - 10) {\n\t\t\tgrowBuffer(buf, i + 10);\n\t\t    }\n\t\t    for (;i > 0;i--)\n\t\t\tbuf[len++] = *cur++;\n\t\t    buf[len++] = ';';\n\t\t}\n\t    }\n\t} else {\n\t    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n\t        if ((len != 0) || (!normalize)) {\n\t\t    if ((!normalize) || (!in_space)) {\n\t\t\tCOPY_BUF(l,buf,len,0x20);\n\t\t\twhile (len > buf_size - 10) {\n\t\t\t    growBuffer(buf, 10);\n\t\t\t}\n\t\t    }\n\t\t    in_space = 1;\n\t\t}\n\t    } else {\n\t        in_space = 0;\n\t\tCOPY_BUF(l,buf,len,c);\n\t\tif (len > buf_size - 10) {\n\t\t    growBuffer(buf, 10);\n\t\t}\n\t    }\n\t    NEXTL(l);\n\t}\n \tGROW;\n \tc = CUR_CHAR(l);\n     }\n     if ((in_space) && (normalize)) {\n         while ((len > 0) && (buf[len - 1] == 0x20)) len--;\n     }\n    buf[len] = 0;\n    if (RAW == '<') {\n\txmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n    } else if (RAW != limit) {\n\tif ((c != 0) && (!IS_CHAR(c))) {\n\t    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n\t\t\t   \"invalid character in attribute value\\n\");\n\t} else {\n\t    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n\t\t\t   \"AttValue: ' expected\\n\");\n        }\n    } else\n\tNEXT;\n    if (attlen != NULL) *attlen = len;\n    return(buf);\n \n mem_error:\n     xmlErrMemory(ctxt, NULL);\n     if (buf != NULL)\n         xmlFree(buf);\n     if (rep != NULL)\n        xmlFree(rep);\n    return(NULL);\n}\n", "target": 1, "idx": 184962}
{"func": "void OomInterventionImpl::ReportMemoryStats(\n    OomInterventionMetrics& current_memory) {\n  UMA_HISTOGRAM_MEMORY_MB(\n      \"Memory.Experimental.OomIntervention.RendererBlinkUsage\",\n      current_memory.current_blink_usage_kb / 1024);\n  UMA_HISTOGRAM_MEMORY_LARGE_MB(\n      \"Memory.Experimental.OomIntervention.\"\n      \"RendererPrivateMemoryFootprint\",\n      current_memory.current_private_footprint_kb / 1024);\n  UMA_HISTOGRAM_MEMORY_MB(\n      \"Memory.Experimental.OomIntervention.RendererSwapFootprint\",\n      current_memory.current_swap_kb / 1024);\n  UMA_HISTOGRAM_MEMORY_LARGE_MB(\n      \"Memory.Experimental.OomIntervention.RendererVmSize\",\n      current_memory.current_vm_size_kb / 1024);\n\n  CrashMemoryMetricsReporterImpl::Instance().WriteIntoSharedMemory(\n      current_memory);\n}\n", "target": 0, "idx": 143587}
{"func": "void ResourcePrefetchPredictor::Shutdown() {\n  history_service_observer_.RemoveAll();\n}\n", "target": 0, "idx": 149634}
{"func": "dispatchCdmaSmsAck(Parcel &p, RequestInfo *pRI) {\n    RIL_CDMA_SMS_Ack rcsa;\n int32_t  t;\n status_t status;\n int32_t digitCount;\n\n    RLOGD(\"dispatchCdmaSmsAck\");\n    memset(&rcsa, 0, sizeof(rcsa));\n\n    status = p.readInt32(&t);\n    rcsa.uErrorClass = (RIL_CDMA_SMS_ErrorClass) t;\n\n    status = p.readInt32(&t);\n    rcsa.uSMSCauseCode = (int) t;\n\n if (status != NO_ERROR) {\n goto invalid;\n }\n\n    startRequest;\n    appendPrintBuf(\"%suErrorClass=%d, uTLStatus=%d, \",\n            printBuf, rcsa.uErrorClass, rcsa.uSMSCauseCode);\n    closeRequest;\n\n    printRequest(pRI->token, pRI->pCI->requestNumber);\n\n    CALL_ONREQUEST(pRI->pCI->requestNumber, &rcsa, sizeof(rcsa),pRI, pRI->socket_id);\n\n#ifdef MEMSET_FREED\n    memset(&rcsa, 0, sizeof(rcsa));\n#endif\n\n return;\n\ninvalid:\n    invalidCommandBlock(pRI);\n return;\n}\n", "target": 0, "idx": 175263}
{"func": "WebMediaPlayer* RenderView::createMediaPlayer(\n    WebFrame* frame, WebMediaPlayerClient* client) {\n  FOR_EACH_OBSERVER(\n      RenderViewObserver, observers_, WillCreateMediaPlayer(frame, client));\n\n  scoped_ptr<media::MessageLoopFactory> message_loop_factory(\n      new media::MessageLoopFactoryImpl());\n  scoped_ptr<media::FilterCollection> collection(\n      new media::FilterCollection());\n\n  const CommandLine* cmd_line = CommandLine::ForCurrentProcess();\n  if (!cmd_line->HasSwitch(switches::kDisableAudio)) {\n    collection->AddAudioRenderer(new AudioRendererImpl());\n  }\n\n  scoped_refptr<webkit_glue::WebVideoRenderer> video_renderer;\n  bool pts_logging = cmd_line->HasSwitch(switches::kEnableVideoLogging);\n  scoped_refptr<webkit_glue::VideoRendererImpl> renderer(\n      new webkit_glue::VideoRendererImpl(pts_logging));\n  collection->AddVideoRenderer(renderer);\n  video_renderer = renderer;\n\n  scoped_ptr<webkit_glue::WebMediaPlayerImpl> result(\n      new webkit_glue::WebMediaPlayerImpl(client,\n                                          collection.release(),\n                                          message_loop_factory.release(),\n                                          media_stream_impl_.get()));\n  if (!result->Initialize(frame,\n                          cmd_line->HasSwitch(switches::kSimpleDataSource),\n                          video_renderer)) {\n    return NULL;\n  }\n  return result.release();\n}\n", "target": 0, "idx": 103865}
{"func": "static u64 vmac(unsigned char m[], unsigned int mbytes,\n\t\t\tconst unsigned char n[16], u64 *tagl,\n\t\t\tstruct vmac_ctx_t *ctx)\n{\n\tu64 *in_n, *out_p;\n\tu64 p, h;\n\tint i;\n\n\tin_n = ctx->__vmac_ctx.cached_nonce;\n\tout_p = ctx->__vmac_ctx.cached_aes;\n\n\ti = n[15] & 1;\n\tif ((*(u64 *)(n+8) != in_n[1]) || (*(u64 *)(n) != in_n[0])) {\n\t\tin_n[0] = *(u64 *)(n);\n\t\tin_n[1] = *(u64 *)(n+8);\n\t\t((unsigned char *)in_n)[15] &= 0xFE;\n\t\tcrypto_cipher_encrypt_one(ctx->child,\n\t\t\t(unsigned char *)out_p, (unsigned char *)in_n);\n\n\t\t((unsigned char *)in_n)[15] |= (unsigned char)(1-i);\n\t}\n\tp = be64_to_cpup(out_p + i);\n\th = vhash(m, mbytes, (u64 *)0, &ctx->__vmac_ctx);\n\treturn le64_to_cpu(p + h);\n}\n", "target": 0, "idx": 45906}
{"func": "static int msg_cache_check(const char *id, struct BodyCache *bcache, void *data)\n{\n  struct Context *ctx = (struct Context *) data;\n  if (!ctx)\n    return -1;\n  struct PopData *pop_data = (struct PopData *) ctx->data;\n  if (!pop_data)\n    return -1;\n\n#ifdef USE_HCACHE\n  /* keep hcache file if hcache == bcache */\n  if (strcmp(HC_FNAME \".\" HC_FEXT, id) == 0)\n    return 0;\n#endif\n\n  for (int i = 0; i < ctx->msgcount; i++)\n  {\n    /* if the id we get is known for a header: done (i.e. keep in cache) */\n    if (ctx->hdrs[i]->data && (mutt_str_strcmp(ctx->hdrs[i]->data, id) == 0))\n      return 0;\n  }\n\n   /* message not found in context -> remove it from cache\n    * return the result of bcache, so we stop upon its first error\n    */\n  return mutt_bcache_del(bcache, id);\n }\n", "target": 1, "idx": 182292}
{"func": "bool TabsCaptureVisibleTabFunction::RunImpl() {\n  PrefService* service = profile()->GetPrefs();\n  if (service->GetBoolean(prefs::kDisableScreenshots)) {\n    error_ = keys::kScreenshotsDisabled;\n    return false;\n  }\n\n  WebContents* web_contents = NULL;\n  if (!GetTabToCapture(&web_contents))\n    return false;\n\n  image_format_ = FORMAT_JPEG;  // Default format is JPEG.\n  image_quality_ = kDefaultQuality;  // Default quality setting.\n\n  if (HasOptionalArgument(1)) {\n    DictionaryValue* options = NULL;\n    EXTENSION_FUNCTION_VALIDATE(args_->GetDictionary(1, &options));\n\n    if (options->HasKey(keys::kFormatKey)) {\n      std::string format;\n      EXTENSION_FUNCTION_VALIDATE(\n          options->GetString(keys::kFormatKey, &format));\n\n      if (format == keys::kFormatValueJpeg) {\n        image_format_ = FORMAT_JPEG;\n      } else if (format == keys::kFormatValuePng) {\n        image_format_ = FORMAT_PNG;\n      } else {\n        EXTENSION_FUNCTION_VALIDATE(0);\n      }\n    }\n\n    if (options->HasKey(keys::kQualityKey)) {\n      EXTENSION_FUNCTION_VALIDATE(\n          options->GetInteger(keys::kQualityKey, &image_quality_));\n     }\n   }\n \n  if (!GetExtension()->CanCaptureVisiblePage(\n        web_contents->GetURL(),\n        SessionID::IdForTab(web_contents),\n        &error_)) {\n     return false;\n   }\n \n  RenderViewHost* render_view_host = web_contents->GetRenderViewHost();\n  content::RenderWidgetHostView* view = render_view_host->GetView();\n  if (!view) {\n    error_ = keys::kInternalVisibleTabCaptureError;\n    return false;\n  }\n  render_view_host->CopyFromBackingStore(\n      gfx::Rect(),\n      view->GetViewBounds().size(),\n      base::Bind(&TabsCaptureVisibleTabFunction::CopyFromBackingStoreComplete,\n                 this));\n  return true;\n}\n", "target": 1, "idx": 184960}
{"func": "void op_addAvxRoundingMode(MCInst *MI, int v)\n{\n\tif (MI->csh->detail) {\n\t\tMI->flat_insn->detail->x86.avx_rm = v;\n\t}\n}\n", "target": 0, "idx": 94032}
{"func": "static unsigned next_desc(struct vhost_virtqueue *vq, struct vring_desc *desc)\n{\n\tunsigned int next;\n\n\t/* If this descriptor says it doesn't chain, we're done. */\n\tif (!(desc->flags & cpu_to_vhost16(vq, VRING_DESC_F_NEXT)))\n\t\treturn -1U;\n\n\t/* Check they're not leading us off end of descriptors. */\n\tnext = vhost16_to_cpu(vq, desc->next);\n\t/* Make sure compiler knows to grab that: we don't want it changing! */\n\t/* We will use the result as an index in an array, so most\n\t * architectures only need a compiler barrier here. */\n\tread_barrier_depends();\n\n\treturn next;\n}\n", "target": 0, "idx": 42204}
{"func": "cifs_sb_master_tlink(struct cifs_sb_info *cifs_sb)\n{\n\treturn cifs_sb->master_tlink;\n}\n", "target": 0, "idx": 24500}
{"func": "xmlParseTryOrFinish(xmlParserCtxtPtr ctxt, int terminate) {\n    int ret = 0;\n    int avail, tlen;\n    xmlChar cur, next;\n    const xmlChar *lastlt, *lastgt;\n\n    if (ctxt->input == NULL)\n        return(0);\n\n#ifdef DEBUG_PUSH\n    switch (ctxt->instate) {\n\tcase XML_PARSER_EOF:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try EOF\\n\"); break;\n\tcase XML_PARSER_START:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try START\\n\"); break;\n\tcase XML_PARSER_MISC:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try MISC\\n\");break;\n\tcase XML_PARSER_COMMENT:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try COMMENT\\n\");break;\n\tcase XML_PARSER_PROLOG:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try PROLOG\\n\");break;\n\tcase XML_PARSER_START_TAG:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try START_TAG\\n\");break;\n\tcase XML_PARSER_CONTENT:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try CONTENT\\n\");break;\n\tcase XML_PARSER_CDATA_SECTION:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try CDATA_SECTION\\n\");break;\n\tcase XML_PARSER_END_TAG:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try END_TAG\\n\");break;\n\tcase XML_PARSER_ENTITY_DECL:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try ENTITY_DECL\\n\");break;\n\tcase XML_PARSER_ENTITY_VALUE:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try ENTITY_VALUE\\n\");break;\n\tcase XML_PARSER_ATTRIBUTE_VALUE:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try ATTRIBUTE_VALUE\\n\");break;\n\tcase XML_PARSER_DTD:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try DTD\\n\");break;\n\tcase XML_PARSER_EPILOG:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try EPILOG\\n\");break;\n\tcase XML_PARSER_PI:\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try PI\\n\");break;\n        case XML_PARSER_IGNORE:\n            xmlGenericError(xmlGenericErrorContext,\n\t\t    \"PP: try IGNORE\\n\");break;\n    }\n#endif\n\n    if ((ctxt->input != NULL) &&\n        (ctxt->input->cur - ctxt->input->base > 4096)) {\n\txmlSHRINK(ctxt);\n\tctxt->checkIndex = 0;\n    }\n    xmlParseGetLasts(ctxt, &lastlt, &lastgt);\n\n    while (1) {\n\tif ((ctxt->errNo != XML_ERR_OK) && (ctxt->disableSAX == 1))\n\t    return(0);\n\n        \n\t/*\n\t * Pop-up of finished entities.\n\t */\n\twhile ((RAW == 0) && (ctxt->inputNr > 1))\n\t    xmlPopInput(ctxt);\n\n\tif (ctxt->input == NULL) break;\n\tif (ctxt->input->buf == NULL)\n\t    avail = ctxt->input->length -\n\t            (ctxt->input->cur - ctxt->input->base);\n\telse {\n\t    /*\n\t     * If we are operating on converted input, try to flush\n\t     * remainng chars to avoid them stalling in the non-converted\n\t     * buffer.\n\t     */\n\t    if ((ctxt->input->buf->raw != NULL) &&\n\t\t(ctxt->input->buf->raw->use > 0)) {\n\t\tint base = ctxt->input->base -\n\t\t           ctxt->input->buf->buffer->content;\n\t\tint current = ctxt->input->cur - ctxt->input->base;\n\n\t\txmlParserInputBufferPush(ctxt->input->buf, 0, \"\");\n\t\tctxt->input->base = ctxt->input->buf->buffer->content + base;\n\t\tctxt->input->cur = ctxt->input->base + current;\n\t\tctxt->input->end =\n\t\t    &ctxt->input->buf->buffer->content[\n\t\t                       ctxt->input->buf->buffer->use];\n\t    }\n\t    avail = ctxt->input->buf->buffer->use -\n\t\t    (ctxt->input->cur - ctxt->input->base);\n\t}\n        if (avail < 1)\n\t    goto done;\n        switch (ctxt->instate) {\n            case XML_PARSER_EOF:\n\t        /*\n\t\t * Document parsing is done !\n\t\t */\n\t        goto done;\n            case XML_PARSER_START:\n\t\tif (ctxt->charset == XML_CHAR_ENCODING_NONE) {\n\t\t    xmlChar start[4];\n\t\t    xmlCharEncoding enc;\n\n\t\t    /*\n\t\t     * Very first chars read from the document flow.\n\t\t     */\n\t\t    if (avail < 4)\n\t\t\tgoto done;\n\n\t\t    /* \n\t\t     * Get the 4 first bytes and decode the charset\n\t\t     * if enc != XML_CHAR_ENCODING_NONE\n\t\t     * plug some encoding conversion routines,\n\t\t     * else xmlSwitchEncoding will set to (default)\n\t\t     * UTF8.\n\t\t     */\n\t\t    start[0] = RAW;\n\t\t    start[1] = NXT(1);\n\t\t    start[2] = NXT(2);\n\t\t    start[3] = NXT(3);\n\t\t    enc = xmlDetectCharEncoding(start, 4);\n\t\t    xmlSwitchEncoding(ctxt, enc);\n\t\t    break;\n\t\t}\n\n\t\tif (avail < 2)\n\t\t    goto done;\n\t\tcur = ctxt->input->cur[0];\n\t\tnext = ctxt->input->cur[1];\n\t\tif (cur == 0) {\n\t\t    if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))\n\t\t\tctxt->sax->setDocumentLocator(ctxt->userData,\n\t\t\t\t\t\t      &xmlDefaultSAXLocator);\n\t\t    xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);\n\t\t    ctxt->instate = XML_PARSER_EOF;\n#ifdef DEBUG_PUSH\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PP: entering EOF\\n\");\n#endif\n\t\t    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\n\t\t\tctxt->sax->endDocument(ctxt->userData);\n\t\t    goto done;\n\t\t}\n\t        if ((cur == '<') && (next == '?')) {\n\t\t    /* PI or XML decl */\n\t\t    if (avail < 5) return(ret);\n\t\t    if ((!terminate) &&\n\t\t        (xmlParseLookupSequence(ctxt, '?', '>', 0) < 0))\n\t\t\treturn(ret);\n\t\t    if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))\n\t\t\tctxt->sax->setDocumentLocator(ctxt->userData,\n\t\t\t\t\t\t      &xmlDefaultSAXLocator);\n\t\t    if ((ctxt->input->cur[2] == 'x') &&\n\t\t\t(ctxt->input->cur[3] == 'm') &&\n\t\t\t(ctxt->input->cur[4] == 'l') &&\n\t\t\t(IS_BLANK_CH(ctxt->input->cur[5]))) {\n\t\t\tret += 5;\n#ifdef DEBUG_PUSH\n\t\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\t\"PP: Parsing XML Decl\\n\");\n#endif\n\t\t\txmlParseXMLDecl(ctxt);\n\t\t\tif (ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) {\n\t\t\t    /*\n\t\t\t     * The XML REC instructs us to stop parsing right\n\t\t\t     * here\n\t\t\t     */\n\t\t\t    ctxt->instate = XML_PARSER_EOF;\n\t\t\t    return(0);\n\t\t\t}\n\t\t\tctxt->standalone = ctxt->input->standalone;\n\t\t\tif ((ctxt->encoding == NULL) &&\n\t\t\t    (ctxt->input->encoding != NULL))\n\t\t\t    ctxt->encoding = xmlStrdup(ctxt->input->encoding);\n\t\t\tif ((ctxt->sax) && (ctxt->sax->startDocument) &&\n\t\t\t    (!ctxt->disableSAX))\n\t\t\t    ctxt->sax->startDocument(ctxt->userData);\n\t\t\tctxt->instate = XML_PARSER_MISC;\n#ifdef DEBUG_PUSH\n\t\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\t\"PP: entering MISC\\n\");\n#endif\n\t\t    } else {\n\t\t\tctxt->version = xmlCharStrdup(XML_DEFAULT_VERSION);\n\t\t\tif ((ctxt->sax) && (ctxt->sax->startDocument) &&\n\t\t\t    (!ctxt->disableSAX))\n\t\t\t    ctxt->sax->startDocument(ctxt->userData);\n\t\t\tctxt->instate = XML_PARSER_MISC;\n#ifdef DEBUG_PUSH\n\t\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\t\"PP: entering MISC\\n\");\n#endif\n\t\t    }\n\t\t} else {\n\t\t    if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))\n\t\t\tctxt->sax->setDocumentLocator(ctxt->userData,\n\t\t\t\t\t\t      &xmlDefaultSAXLocator);\n\t\t    ctxt->version = xmlCharStrdup(XML_DEFAULT_VERSION);\n\t\t    if (ctxt->version == NULL) {\n\t\t        xmlErrMemory(ctxt, NULL);\n\t\t\tbreak;\n\t\t    }\n\t\t    if ((ctxt->sax) && (ctxt->sax->startDocument) &&\n\t\t        (!ctxt->disableSAX))\n\t\t\tctxt->sax->startDocument(ctxt->userData);\n\t\t    ctxt->instate = XML_PARSER_MISC;\n#ifdef DEBUG_PUSH\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PP: entering MISC\\n\");\n#endif\n\t\t}\n\t\tbreak;\n            case XML_PARSER_START_TAG: {\n\t        const xmlChar *name;\n\t\tconst xmlChar *prefix = NULL;\n\t\tconst xmlChar *URI = NULL;\n\t\tint nsNr = ctxt->nsNr;\n\n\t\tif ((avail < 2) && (ctxt->inputNr == 1))\n\t\t    goto done;\n\t\tcur = ctxt->input->cur[0];\n\t        if (cur != '<') {\n\t\t    xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);\n\t\t    ctxt->instate = XML_PARSER_EOF;\n\t\t    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\n\t\t\tctxt->sax->endDocument(ctxt->userData);\n\t\t    goto done;\n\t\t}\n\t\tif (!terminate) {\n\t\t    if (ctxt->progressive) {\n\t\t        /* > can be found unescaped in attribute values */\n\t\t        if ((lastgt == NULL) || (ctxt->input->cur >= lastgt))\n\t\t\t    goto done;\n\t\t    } else if (xmlParseLookupSequence(ctxt, '>', 0, 0) < 0) {\n\t\t\tgoto done;\n\t\t    }\n\t\t}\n\t\tif (ctxt->spaceNr == 0)\n\t\t    spacePush(ctxt, -1);\n\t\telse if (*ctxt->space == -2)\n\t\t    spacePush(ctxt, -1);\n\t\telse\n\t\t    spacePush(ctxt, *ctxt->space);\n#ifdef LIBXML_SAX1_ENABLED\n\t\tif (ctxt->sax2)\n#endif /* LIBXML_SAX1_ENABLED */\n\t\t    name = xmlParseStartTag2(ctxt, &prefix, &URI, &tlen);\n#ifdef LIBXML_SAX1_ENABLED\n \t\telse\n \t\t    name = xmlParseStartTag(ctxt);\n #endif /* LIBXML_SAX1_ENABLED */\n \t\tif (name == NULL) {\n \t\t    spacePop(ctxt);\n \t\t    ctxt->instate = XML_PARSER_EOF;\n\t\t    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\n\t\t\tctxt->sax->endDocument(ctxt->userData);\n\t\t    goto done;\n\t\t}\n#ifdef LIBXML_VALID_ENABLED\n\t\t/*\n\t\t * [ VC: Root Element Type ]\n\t\t * The Name in the document type declaration must match\n\t\t * the element type of the root element. \n\t\t */\n\t\tif (ctxt->validate && ctxt->wellFormed && ctxt->myDoc &&\n\t\t    ctxt->node && (ctxt->node == ctxt->myDoc->children))\n\t\t    ctxt->valid &= xmlValidateRoot(&ctxt->vctxt, ctxt->myDoc);\n#endif /* LIBXML_VALID_ENABLED */\n\n\t\t/*\n\t\t * Check for an Empty Element.\n\t\t */\n\t\tif ((RAW == '/') && (NXT(1) == '>')) {\n\t\t    SKIP(2);\n\n\t\t    if (ctxt->sax2) {\n\t\t\tif ((ctxt->sax != NULL) &&\n\t\t\t    (ctxt->sax->endElementNs != NULL) &&\n\t\t\t    (!ctxt->disableSAX))\n\t\t\t    ctxt->sax->endElementNs(ctxt->userData, name,\n\t\t\t                            prefix, URI);\n\t\t\tif (ctxt->nsNr - nsNr > 0)\n\t\t\t    nsPop(ctxt, ctxt->nsNr - nsNr);\n#ifdef LIBXML_SAX1_ENABLED\n\t\t    } else {\n\t\t\tif ((ctxt->sax != NULL) &&\n\t\t\t    (ctxt->sax->endElement != NULL) &&\n\t\t\t    (!ctxt->disableSAX))\n\t\t\t    ctxt->sax->endElement(ctxt->userData, name);\n#endif /* LIBXML_SAX1_ENABLED */\n\t\t    }\n\t\t    spacePop(ctxt);\n\t\t    if (ctxt->nameNr == 0) {\n\t\t\tctxt->instate = XML_PARSER_EPILOG;\n\t\t    } else {\n\t\t\tctxt->instate = XML_PARSER_CONTENT;\n\t\t    }\n\t\t    break;\n\t\t}\n\t\tif (RAW == '>') {\n\t\t    NEXT;\n\t\t} else {\n\t\t    xmlFatalErrMsgStr(ctxt, XML_ERR_GT_REQUIRED,\n\t\t\t\t\t \"Couldn't find end of Start Tag %s\\n\",\n\t\t\t\t\t name);\n\t\t    nodePop(ctxt);\n\t\t    spacePop(ctxt);\n\t\t}\n\t\tif (ctxt->sax2)\n\t\t    nameNsPush(ctxt, name, prefix, URI, ctxt->nsNr - nsNr);\n#ifdef LIBXML_SAX1_ENABLED\n\t\telse\n\t\t    namePush(ctxt, name);\n#endif /* LIBXML_SAX1_ENABLED */\n\n\t\tctxt->instate = XML_PARSER_CONTENT;\n                break;\n\t    }\n            case XML_PARSER_CONTENT: {\n\t\tconst xmlChar *test;\n\t\tunsigned int cons;\n\t\tif ((avail < 2) && (ctxt->inputNr == 1))\n\t\t    goto done;\n\t\tcur = ctxt->input->cur[0];\n\t\tnext = ctxt->input->cur[1];\n\n\t\ttest = CUR_PTR;\n\t        cons = ctxt->input->consumed;\n\t\tif ((cur == '<') && (next == '/')) {\n\t\t    ctxt->instate = XML_PARSER_END_TAG;\n\t\t    break;\n\t        } else if ((cur == '<') && (next == '?')) {\n\t\t    if ((!terminate) &&\n\t\t        (xmlParseLookupSequence(ctxt, '?', '>', 0) < 0))\n\t\t\tgoto done;\n\t\t    xmlParsePI(ctxt);\n\t\t} else if ((cur == '<') && (next != '!')) {\n\t\t    ctxt->instate = XML_PARSER_START_TAG;\n\t\t    break;\n\t\t} else if ((cur == '<') && (next == '!') &&\n\t\t           (ctxt->input->cur[2] == '-') &&\n\t\t\t   (ctxt->input->cur[3] == '-')) {\n\t\t    int term;\n\n\t            if (avail < 4)\n\t\t        goto done;\n\t\t    ctxt->input->cur += 4;\n\t\t    term = xmlParseLookupSequence(ctxt, '-', '-', '>');\n\t\t    ctxt->input->cur -= 4;\n\t\t    if ((!terminate) && (term < 0))\n\t\t\tgoto done;\n\t\t    xmlParseComment(ctxt);\n\t\t    ctxt->instate = XML_PARSER_CONTENT;\n\t\t} else if ((cur == '<') && (ctxt->input->cur[1] == '!') &&\n\t\t    (ctxt->input->cur[2] == '[') &&\n\t\t    (ctxt->input->cur[3] == 'C') &&\n\t\t    (ctxt->input->cur[4] == 'D') &&\n\t\t    (ctxt->input->cur[5] == 'A') &&\n\t\t    (ctxt->input->cur[6] == 'T') &&\n\t\t    (ctxt->input->cur[7] == 'A') &&\n\t\t    (ctxt->input->cur[8] == '[')) {\n\t\t    SKIP(9);\n\t\t    ctxt->instate = XML_PARSER_CDATA_SECTION;\n\t\t    break;\n\t\t} else if ((cur == '<') && (next == '!') &&\n\t\t           (avail < 9)) {\n\t\t    goto done;\n\t\t} else if (cur == '&') {\n\t\t    if ((!terminate) &&\n\t\t        (xmlParseLookupSequence(ctxt, ';', 0, 0) < 0))\n\t\t\tgoto done;\n\t\t    xmlParseReference(ctxt);\n\t\t} else {\n\t\t    /* TODO Avoid the extra copy, handle directly !!! */\n\t\t    /*\n\t\t     * Goal of the following test is:\n\t\t     *  - minimize calls to the SAX 'character' callback\n\t\t     *    when they are mergeable\n\t\t     *  - handle an problem for isBlank when we only parse\n\t\t     *    a sequence of blank chars and the next one is\n\t\t     *    not available to check against '<' presence.\n\t\t     *  - tries to homogenize the differences in SAX\n\t\t     *    callbacks between the push and pull versions\n\t\t     *    of the parser.\n\t\t     */\n\t\t    if ((ctxt->inputNr == 1) &&\n\t\t        (avail < XML_PARSER_BIG_BUFFER_SIZE)) {\n\t\t\tif (!terminate) {\n\t\t\t    if (ctxt->progressive) {\n\t\t\t\tif ((lastlt == NULL) ||\n\t\t\t\t    (ctxt->input->cur > lastlt))\n\t\t\t\t    goto done;\n\t\t\t    } else if (xmlParseLookupSequence(ctxt,\n\t\t\t                                      '<', 0, 0) < 0) {\n\t\t\t\tgoto done;\n\t\t\t    }\n\t\t\t}\n                    }\n\t\t    ctxt->checkIndex = 0;\n\t\t    xmlParseCharData(ctxt, 0);\n\t\t}\n\t\t/*\n\t\t * Pop-up of finished entities.\n\t\t */\n\t\twhile ((RAW == 0) && (ctxt->inputNr > 1))\n\t\t    xmlPopInput(ctxt);\n\t\tif ((cons == ctxt->input->consumed) && (test == CUR_PTR)) {\n\t\t    xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,\n\t\t                \"detected an error in element content\\n\");\n\t\t    ctxt->instate = XML_PARSER_EOF;\n\t\t    break;\n\t\t}\n\t\tbreak;\n\t    }\n            case XML_PARSER_END_TAG:\n\t\tif (avail < 2)\n\t\t    goto done;\n\t\tif (!terminate) {\n\t\t    if (ctxt->progressive) {\n\t\t        /* > can be found unescaped in attribute values */\n\t\t        if ((lastgt == NULL) || (ctxt->input->cur >= lastgt))\n\t\t\t    goto done;\n\t\t    } else if (xmlParseLookupSequence(ctxt, '>', 0, 0) < 0) {\n\t\t\tgoto done;\n\t\t    }\n\t\t}\n\t\tif (ctxt->sax2) {\n\t\t    xmlParseEndTag2(ctxt,\n\t\t           (void *) ctxt->pushTab[ctxt->nameNr * 3 - 3],\n\t\t           (void *) ctxt->pushTab[ctxt->nameNr * 3 - 2], 0,\n\t\t       (int) (long) ctxt->pushTab[ctxt->nameNr * 3 - 1], 0);\n\t\t    nameNsPop(ctxt);\n\t\t}\n#ifdef LIBXML_SAX1_ENABLED\n \t\t  else\n \t\t    xmlParseEndTag1(ctxt, 0);\n #endif /* LIBXML_SAX1_ENABLED */\n\t\tif (ctxt->nameNr == 0) {\n \t\t    ctxt->instate = XML_PARSER_EPILOG;\n \t\t} else {\n \t\t    ctxt->instate = XML_PARSER_CONTENT;\n\t\t}\n\t\tbreak;\n            case XML_PARSER_CDATA_SECTION: {\n\t        /*\n\t\t * The Push mode need to have the SAX callback for \n\t\t * cdataBlock merge back contiguous callbacks.\n\t\t */\n\t\tint base;\n\n\t\tbase = xmlParseLookupSequence(ctxt, ']', ']', '>');\n\t\tif (base < 0) {\n\t\t    if (avail >= XML_PARSER_BIG_BUFFER_SIZE + 2) {\n\t\t        int tmp;\n\n\t\t\ttmp = xmlCheckCdataPush(ctxt->input->cur, \n\t\t\t                        XML_PARSER_BIG_BUFFER_SIZE);\n\t\t\tif (tmp < 0) {\n\t\t\t    tmp = -tmp;\n\t\t\t    ctxt->input->cur += tmp;\n\t\t\t    goto encoding_error;\n\t\t\t}\n\t\t\tif ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {\n\t\t\t    if (ctxt->sax->cdataBlock != NULL)\n\t\t\t\tctxt->sax->cdataBlock(ctxt->userData,\n\t\t\t\t                      ctxt->input->cur, tmp);\n\t\t\t    else if (ctxt->sax->characters != NULL)\n\t\t\t\tctxt->sax->characters(ctxt->userData,\n\t\t\t\t                      ctxt->input->cur, tmp);\n\t\t\t}\n\t\t\tSKIPL(tmp);\n\t\t\tctxt->checkIndex = 0;\n\t\t    }\n\t\t    goto done;\n\t\t} else {\n\t\t    int tmp;\n\n\t\t    tmp = xmlCheckCdataPush(ctxt->input->cur, base);\n\t\t    if ((tmp < 0) || (tmp != base)) {\n\t\t\ttmp = -tmp;\n\t\t\tctxt->input->cur += tmp;\n\t\t\tgoto encoding_error;\n\t\t    }\n\t\t    if ((ctxt->sax != NULL) && (base == 0) &&\n\t\t        (ctxt->sax->cdataBlock != NULL) &&\n\t\t        (!ctxt->disableSAX)) {\n\t\t\t/*\n\t\t\t * Special case to provide identical behaviour\n\t\t\t * between pull and push parsers on enpty CDATA\n\t\t\t * sections\n\t\t\t */\n\t\t\t if ((ctxt->input->cur - ctxt->input->base >= 9) &&\n\t\t\t     (!strncmp((const char *)&ctxt->input->cur[-9],\n\t\t\t               \"<![CDATA[\", 9)))\n\t\t\t     ctxt->sax->cdataBlock(ctxt->userData,\n\t\t\t                           BAD_CAST \"\", 0);\n\t\t    } else if ((ctxt->sax != NULL) && (base > 0) &&\n\t\t\t(!ctxt->disableSAX)) {\n\t\t\tif (ctxt->sax->cdataBlock != NULL)\n\t\t\t    ctxt->sax->cdataBlock(ctxt->userData,\n\t\t\t\t\t\t  ctxt->input->cur, base);\n\t\t\telse if (ctxt->sax->characters != NULL)\n\t\t\t    ctxt->sax->characters(ctxt->userData,\n\t\t\t\t\t\t  ctxt->input->cur, base);\n\t\t    }\n\t\t    SKIPL(base + 3);\n\t\t    ctxt->checkIndex = 0;\n\t\t    ctxt->instate = XML_PARSER_CONTENT;\n#ifdef DEBUG_PUSH\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PP: entering CONTENT\\n\");\n#endif\n\t\t}\n\t\tbreak;\n\t    }\n            case XML_PARSER_MISC:\n\t\tSKIP_BLANKS;\n\t\tif (ctxt->input->buf == NULL)\n\t\t    avail = ctxt->input->length -\n\t\t            (ctxt->input->cur - ctxt->input->base);\n\t\telse\n\t\t    avail = ctxt->input->buf->buffer->use -\n\t\t            (ctxt->input->cur - ctxt->input->base);\n\t\tif (avail < 2)\n\t\t    goto done;\n\t\tcur = ctxt->input->cur[0];\n\t\tnext = ctxt->input->cur[1];\n\t        if ((cur == '<') && (next == '?')) {\n\t\t    if ((!terminate) &&\n\t\t        (xmlParseLookupSequence(ctxt, '?', '>', 0) < 0))\n\t\t\tgoto done;\n#ifdef DEBUG_PUSH\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PP: Parsing PI\\n\");\n#endif\n\t\t    xmlParsePI(ctxt);\n\t\t    ctxt->checkIndex = 0;\n\t\t} else if ((cur == '<') && (next == '!') &&\n\t\t    (ctxt->input->cur[2] == '-') &&\n\t\t    (ctxt->input->cur[3] == '-')) {\n\t\t    if ((!terminate) &&\n\t\t        (xmlParseLookupSequence(ctxt, '-', '-', '>') < 0))\n\t\t\tgoto done;\n#ifdef DEBUG_PUSH\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PP: Parsing Comment\\n\");\n#endif\n\t\t    xmlParseComment(ctxt);\n\t\t    ctxt->instate = XML_PARSER_MISC;\n\t\t    ctxt->checkIndex = 0;\n\t\t} else if ((cur == '<') && (next == '!') &&\n\t\t    (ctxt->input->cur[2] == 'D') &&\n\t\t    (ctxt->input->cur[3] == 'O') &&\n\t\t    (ctxt->input->cur[4] == 'C') &&\n\t\t    (ctxt->input->cur[5] == 'T') &&\n\t\t    (ctxt->input->cur[6] == 'Y') &&\n\t\t    (ctxt->input->cur[7] == 'P') &&\n\t\t    (ctxt->input->cur[8] == 'E')) {\n\t\t    if ((!terminate) &&\n\t\t        (xmlParseLookupSequence(ctxt, '>', 0, 0) < 0))\n\t\t\tgoto done;\n#ifdef DEBUG_PUSH\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PP: Parsing internal subset\\n\");\n#endif\n\t\t    ctxt->inSubset = 1;\n\t\t    xmlParseDocTypeDecl(ctxt);\n\t\t    if (RAW == '[') {\n\t\t\tctxt->instate = XML_PARSER_DTD;\n#ifdef DEBUG_PUSH\n\t\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\t\"PP: entering DTD\\n\");\n#endif\n\t\t    } else {\n\t\t\t/*\n\t\t\t * Create and update the external subset.\n\t\t\t */\n\t\t\tctxt->inSubset = 2;\n\t\t\tif ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&\n\t\t\t    (ctxt->sax->externalSubset != NULL))\n\t\t\t    ctxt->sax->externalSubset(ctxt->userData,\n\t\t\t\t    ctxt->intSubName, ctxt->extSubSystem,\n\t\t\t\t    ctxt->extSubURI);\n\t\t\tctxt->inSubset = 0;\n\t\t\txmlCleanSpecialAttr(ctxt);\n\t\t\tctxt->instate = XML_PARSER_PROLOG;\n#ifdef DEBUG_PUSH\n\t\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\t\"PP: entering PROLOG\\n\");\n#endif\n\t\t    }\n\t\t} else if ((cur == '<') && (next == '!') &&\n\t\t           (avail < 9)) {\n\t\t    goto done;\n\t\t} else {\n\t\t    ctxt->instate = XML_PARSER_START_TAG;\n\t\t    ctxt->progressive = 1;\n\t\t    xmlParseGetLasts(ctxt, &lastlt, &lastgt);\n#ifdef DEBUG_PUSH\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PP: entering START_TAG\\n\");\n#endif\n\t\t}\n\t\tbreak;\n            case XML_PARSER_PROLOG:\n\t\tSKIP_BLANKS;\n\t\tif (ctxt->input->buf == NULL)\n\t\t    avail = ctxt->input->length - (ctxt->input->cur - ctxt->input->base);\n\t\telse\n\t\t    avail = ctxt->input->buf->buffer->use - (ctxt->input->cur - ctxt->input->base);\n\t\tif (avail < 2) \n\t\t    goto done;\n\t\tcur = ctxt->input->cur[0];\n\t\tnext = ctxt->input->cur[1];\n\t        if ((cur == '<') && (next == '?')) {\n\t\t    if ((!terminate) &&\n\t\t        (xmlParseLookupSequence(ctxt, '?', '>', 0) < 0))\n\t\t\tgoto done;\n#ifdef DEBUG_PUSH\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PP: Parsing PI\\n\");\n#endif\n\t\t    xmlParsePI(ctxt);\n\t\t} else if ((cur == '<') && (next == '!') &&\n\t\t    (ctxt->input->cur[2] == '-') && (ctxt->input->cur[3] == '-')) {\n\t\t    if ((!terminate) &&\n\t\t        (xmlParseLookupSequence(ctxt, '-', '-', '>') < 0))\n\t\t\tgoto done;\n#ifdef DEBUG_PUSH\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PP: Parsing Comment\\n\");\n#endif\n\t\t    xmlParseComment(ctxt);\n\t\t    ctxt->instate = XML_PARSER_PROLOG;\n\t\t} else if ((cur == '<') && (next == '!') &&\n\t\t           (avail < 4)) {\n\t\t    goto done;\n\t\t} else {\n\t\t    ctxt->instate = XML_PARSER_START_TAG;\n\t\t    if (ctxt->progressive == 0)\n\t\t\tctxt->progressive = 1;\n\t\t    xmlParseGetLasts(ctxt, &lastlt, &lastgt);\n#ifdef DEBUG_PUSH\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PP: entering START_TAG\\n\");\n#endif\n\t\t}\n\t\tbreak;\n            case XML_PARSER_EPILOG:\n\t\tSKIP_BLANKS;\n\t\tif (ctxt->input->buf == NULL)\n\t\t    avail = ctxt->input->length - (ctxt->input->cur - ctxt->input->base);\n\t\telse\n\t\t    avail = ctxt->input->buf->buffer->use - (ctxt->input->cur - ctxt->input->base);\n\t\tif (avail < 2)\n\t\t    goto done;\n\t\tcur = ctxt->input->cur[0];\n\t\tnext = ctxt->input->cur[1];\n\t        if ((cur == '<') && (next == '?')) {\n\t\t    if ((!terminate) &&\n\t\t        (xmlParseLookupSequence(ctxt, '?', '>', 0) < 0))\n\t\t\tgoto done;\n#ifdef DEBUG_PUSH\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PP: Parsing PI\\n\");\n#endif\n\t\t    xmlParsePI(ctxt);\n\t\t    ctxt->instate = XML_PARSER_EPILOG;\n\t\t} else if ((cur == '<') && (next == '!') &&\n\t\t    (ctxt->input->cur[2] == '-') && (ctxt->input->cur[3] == '-')) {\n\t\t    if ((!terminate) &&\n\t\t        (xmlParseLookupSequence(ctxt, '-', '-', '>') < 0))\n\t\t\tgoto done;\n#ifdef DEBUG_PUSH\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PP: Parsing Comment\\n\");\n#endif\n\t\t    xmlParseComment(ctxt);\n\t\t    ctxt->instate = XML_PARSER_EPILOG;\n\t\t} else if ((cur == '<') && (next == '!') &&\n\t\t           (avail < 4)) {\n\t\t    goto done;\n\t\t} else {\n\t\t    xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL);\n\t\t    ctxt->instate = XML_PARSER_EOF;\n#ifdef DEBUG_PUSH\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PP: entering EOF\\n\");\n#endif\n\t\t    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\n\t\t\tctxt->sax->endDocument(ctxt->userData);\n\t\t    goto done;\n\t\t}\n\t\tbreak;\n            case XML_PARSER_DTD: {\n\t        /*\n\t\t * Sorry but progressive parsing of the internal subset\n\t\t * is not expected to be supported. We first check that\n\t\t * the full content of the internal subset is available and\n\t\t * the parsing is launched only at that point.\n\t\t * Internal subset ends up with \"']' S? '>'\" in an unescaped\n\t\t * section and not in a ']]>' sequence which are conditional\n\t\t * sections (whoever argued to keep that crap in XML deserve\n\t\t * a place in hell !).\n\t\t */\n\t\tint base, i;\n\t\txmlChar *buf;\n\t        xmlChar quote = 0;\n\n\t\tbase = ctxt->input->cur - ctxt->input->base;\n\t\tif (base < 0) return(0);\n\t\tif (ctxt->checkIndex > base)\n\t\t    base = ctxt->checkIndex;\n\t\tbuf = ctxt->input->buf->buffer->content;\n\t\tfor (;(unsigned int) base < ctxt->input->buf->buffer->use;\n\t\t     base++) {\n\t\t    if (quote != 0) {\n\t\t        if (buf[base] == quote)\n\t\t\t    quote = 0;\n\t\t\tcontinue;    \n\t\t    }\n\t\t    if ((quote == 0) && (buf[base] == '<')) {\n\t\t        int found  = 0;\n\t\t\t/* special handling of comments */\n\t\t        if (((unsigned int) base + 4 <\n\t\t\t     ctxt->input->buf->buffer->use) &&\n\t\t\t    (buf[base + 1] == '!') &&\n\t\t\t    (buf[base + 2] == '-') &&\n\t\t\t    (buf[base + 3] == '-')) {\n\t\t\t    for (;(unsigned int) base + 3 <\n\t\t\t          ctxt->input->buf->buffer->use; base++) {\n\t\t\t\tif ((buf[base] == '-') &&\n\t\t\t\t    (buf[base + 1] == '-') &&\n\t\t\t\t    (buf[base + 2] == '>')) {\n\t\t\t\t    found = 1;\n\t\t\t\t    base += 2;\n\t\t\t\t    break;\n\t\t\t\t}\n\t\t            }\n\t\t\t    if (!found) {\n#if 0\n\t\t\t        fprintf(stderr, \"unfinished comment\\n\");\n#endif\n\t\t\t        break; /* for */\n\t\t            }\n\t\t            continue;\n\t\t\t}\n\t\t    }\n\t\t    if (buf[base] == '\"') {\n\t\t        quote = '\"';\n\t\t\tcontinue;\n\t\t    }\n\t\t    if (buf[base] == '\\'') {\n\t\t        quote = '\\'';\n\t\t\tcontinue;\n\t\t    }\n\t\t    if (buf[base] == ']') {\n#if 0\n\t\t        fprintf(stderr, \"%c%c%c%c: \", buf[base],\n\t\t\t        buf[base + 1], buf[base + 2], buf[base + 3]);\n#endif\n\t\t        if ((unsigned int) base +1 >=\n\t\t            ctxt->input->buf->buffer->use)\n\t\t\t    break;\n\t\t\tif (buf[base + 1] == ']') {\n\t\t\t    /* conditional crap, skip both ']' ! */\n\t\t\t    base++;\n\t\t\t    continue;\n\t\t\t}\n\t\t        for (i = 1;\n\t\t     (unsigned int) base + i < ctxt->input->buf->buffer->use;\n\t\t             i++) {\n\t\t\t    if (buf[base + i] == '>') {\n#if 0\n\t\t\t        fprintf(stderr, \"found\\n\");\n#endif\n\t\t\t        goto found_end_int_subset;\n\t\t\t    }\n\t\t\t    if (!IS_BLANK_CH(buf[base + i])) {\n#if 0\n\t\t\t        fprintf(stderr, \"not found\\n\");\n#endif\n\t\t\t        goto not_end_of_int_subset;\n\t\t\t    }\n\t\t\t}\n#if 0\n\t\t\tfprintf(stderr, \"end of stream\\n\");\n#endif\n\t\t        break;\n                        \n\t\t    }\nnot_end_of_int_subset:\n                    continue; /* for */\n\t\t}\n\t\t/*\n\t\t * We didn't found the end of the Internal subset\n\t\t */\n#ifdef DEBUG_PUSH\n\t\tif (next == 0)\n\t\t    xmlGenericError(xmlGenericErrorContext,\n\t\t\t    \"PP: lookup of int subset end filed\\n\");\n#endif\n\t        goto done;\n\nfound_end_int_subset:\n\t\txmlParseInternalSubset(ctxt);\n\t\tctxt->inSubset = 2;\n\t\tif ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&\n\t\t    (ctxt->sax->externalSubset != NULL))\n\t\t    ctxt->sax->externalSubset(ctxt->userData, ctxt->intSubName,\n\t\t\t    ctxt->extSubSystem, ctxt->extSubURI);\n\t\tctxt->inSubset = 0;\n\t\txmlCleanSpecialAttr(ctxt);\n\t\tctxt->instate = XML_PARSER_PROLOG;\n\t\tctxt->checkIndex = 0;\n#ifdef DEBUG_PUSH\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: entering PROLOG\\n\");\n#endif\n                break;\n\t    }\n            case XML_PARSER_COMMENT:\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: internal error, state == COMMENT\\n\");\n\t\tctxt->instate = XML_PARSER_CONTENT;\n#ifdef DEBUG_PUSH\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: entering CONTENT\\n\");\n#endif\n\t\tbreak;\n            case XML_PARSER_IGNORE:\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: internal error, state == IGNORE\");\n\t        ctxt->instate = XML_PARSER_DTD;\n#ifdef DEBUG_PUSH\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: entering DTD\\n\");\n#endif\n\t        break;\n            case XML_PARSER_PI:\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: internal error, state == PI\\n\");\n\t\tctxt->instate = XML_PARSER_CONTENT;\n#ifdef DEBUG_PUSH\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: entering CONTENT\\n\");\n#endif\n\t\tbreak;\n            case XML_PARSER_ENTITY_DECL:\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: internal error, state == ENTITY_DECL\\n\");\n\t\tctxt->instate = XML_PARSER_DTD;\n#ifdef DEBUG_PUSH\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: entering DTD\\n\");\n#endif\n\t\tbreak;\n            case XML_PARSER_ENTITY_VALUE:\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: internal error, state == ENTITY_VALUE\\n\");\n\t\tctxt->instate = XML_PARSER_CONTENT;\n#ifdef DEBUG_PUSH\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: entering DTD\\n\");\n#endif\n\t\tbreak;\n            case XML_PARSER_ATTRIBUTE_VALUE:\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: internal error, state == ATTRIBUTE_VALUE\\n\");\n\t\tctxt->instate = XML_PARSER_START_TAG;\n#ifdef DEBUG_PUSH\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: entering START_TAG\\n\");\n#endif\n\t\tbreak;\n            case XML_PARSER_SYSTEM_LITERAL:\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: internal error, state == SYSTEM_LITERAL\\n\");\n\t\tctxt->instate = XML_PARSER_START_TAG;\n#ifdef DEBUG_PUSH\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: entering START_TAG\\n\");\n#endif\n\t\tbreak;\n            case XML_PARSER_PUBLIC_LITERAL:\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: internal error, state == PUBLIC_LITERAL\\n\");\n\t\tctxt->instate = XML_PARSER_START_TAG;\n#ifdef DEBUG_PUSH\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"PP: entering START_TAG\\n\");\n#endif\n\t\tbreak;\n\t}\n    }\ndone:    \n#ifdef DEBUG_PUSH\n    xmlGenericError(xmlGenericErrorContext, \"PP: done %d\\n\", ret);\n#endif\n    return(ret);\nencoding_error:\n    {\n        char buffer[150];\n\n\tsnprintf(buffer, 149, \"Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n\",\n\t\t\tctxt->input->cur[0], ctxt->input->cur[1],\n\t\t\tctxt->input->cur[2], ctxt->input->cur[3]);\n\t__xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,\n\t\t     \"Input is not proper UTF-8, indicate encoding !\\n%s\",\n\t\t     BAD_CAST buffer, NULL);\n    }\n    return(0);\n}\n", "target": 1, "idx": 183634}
{"func": "on_unregister_handler(TCMUService1HandlerManager1 *interface,\n\t\t      GDBusMethodInvocation *invocation,\n\t\t      gchar *subtype,\n\t\t      gpointer user_data)\n{\n\tstruct tcmur_handler *handler = find_handler_by_subtype(subtype);\n\tstruct dbus_info *info = handler ? handler->opaque : NULL;\n\n\tif (!handler) {\n\t\tg_dbus_method_invocation_return_value(invocation,\n\t\t\tg_variant_new(\"(bs)\", FALSE,\n \t\t\t\t      \"unknown subtype\"));\n \t\treturn TRUE;\n \t}\n \tdbus_unexport_handler(handler);\n\ttcmur_unregister_handler(handler);\n \tg_bus_unwatch_name(info->watcher_id);\n \tg_free(info);\n \tg_free(handler);\n\tg_dbus_method_invocation_return_value(invocation,\n\t\tg_variant_new(\"(bs)\", TRUE, \"succeeded\"));\n\treturn TRUE;\n}\n", "target": 1, "idx": 180806}
{"func": " static void unregisterBlobURLTask(void* context)\n {\n     OwnPtr<BlobRegistryContext> blobRegistryContext = adoptPtr(static_cast<BlobRegistryContext*>(context));\n    blobRegistry().unregisterBlobURL(blobRegistryContext->url);\n }\n", "target": 1, "idx": 184265}
{"func": "static int tight_fill_palette(VncState *vs, int x, int y,\n                              size_t count, uint32_t *bg, uint32_t *fg,\n                              VncPalette **palette)\n{\n    int max;\n\n    max = count / tight_conf[vs->tight.compression].idx_max_colors_divisor;\n    if (max < 2 &&\n        count >= tight_conf[vs->tight.compression].mono_min_rect_size) {\n        max = 2;\n    }\n    if (max >= 256) {\n         max = 256;\n     }\n \n    switch(vs->clientds.pf.bytes_per_pixel) {\n     case 4:\n         return tight_fill_palette32(vs, x, y, max, count, bg, fg, palette);\n     case 2:\n        return tight_fill_palette16(vs, x, y, max, count, bg, fg, palette);\n    default:\n        max = 2;\n        return tight_fill_palette8(vs, x, y, max, count, bg, fg, palette);\n    }\n    return 0;\n}\n", "target": 1, "idx": 178638}
{"func": "int lxc_clear_config_network(struct lxc_conf *c)\n{\n\tstruct lxc_list *it,*next;\n\tlxc_list_for_each_safe(it, &c->network, next) {\n\t\tlxc_remove_nic(it);\n\t}\n\treturn 0;\n}\n", "target": 0, "idx": 44584}
{"func": "void ArcVoiceInteractionFrameworkService::ToggleSessionFromUserInteraction() {\n  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n\n  if (!InitiateUserInteraction(true /* is_toggle */))\n    return;\n\n  mojom::VoiceInteractionFrameworkInstance* framework_instance =\n      ARC_GET_INSTANCE_FOR_METHOD(\n          arc_bridge_service_->voice_interaction_framework(),\n          ToggleVoiceInteractionSession);\n  DCHECK(framework_instance);\n  framework_instance->ToggleVoiceInteractionSession(IsHomescreenActive());\n}\n", "target": 0, "idx": 165239}
{"func": "static int ext4_write_end(struct file *file,\n\t\t\t  struct address_space *mapping,\n\t\t\t  loff_t pos, unsigned len, unsigned copied,\n\t\t\t  struct page *page, void *fsdata)\n{\n\thandle_t *handle = ext4_journal_current_handle();\n\tstruct inode *inode = mapping->host;\n\tloff_t old_size = inode->i_size;\n\tint ret = 0, ret2;\n \tint i_size_changed = 0;\n \n \ttrace_ext4_write_end(inode, pos, len, copied);\n\tif (ext4_test_inode_state(inode, EXT4_STATE_ORDERED_MODE)) {\n\t\tret = ext4_jbd2_file_inode(handle, inode);\n\t\tif (ret) {\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tgoto errout;\n\t\t}\n\t}\n \tif (ext4_has_inline_data(inode)) {\n \t\tret = ext4_write_inline_data_end(inode, pos, len,\n \t\t\t\t\t\t copied, page);\n\t\tif (ret < 0)\n\t\t\tgoto errout;\n\t\tcopied = ret;\n\t} else\n\t\tcopied = block_write_end(file, mapping, pos,\n\t\t\t\t\t len, copied, page, fsdata);\n\t/*\n\t * it's important to update i_size while still holding page lock:\n\t * page writeout could otherwise come in and zero beyond i_size.\n\t */\n\ti_size_changed = ext4_update_inode_size(inode, pos + copied);\n\tunlock_page(page);\n\tput_page(page);\n\n\tif (old_size < pos)\n\t\tpagecache_isize_extended(inode, old_size, pos);\n\t/*\n\t * Don't mark the inode dirty under page lock. First, it unnecessarily\n\t * makes the holding time of page lock longer. Second, it forces lock\n\t * ordering of page lock and transaction start for journaling\n\t * filesystems.\n\t */\n\tif (i_size_changed)\n\t\text4_mark_inode_dirty(handle, inode);\n\n\tif (pos + len > inode->i_size && ext4_can_truncate(inode))\n\t\t/* if we have allocated more blocks and copied\n\t\t * less. We will have blocks allocated outside\n\t\t * inode->i_size. So truncate them\n\t\t */\n\t\text4_orphan_add(handle, inode);\nerrout:\n\tret2 = ext4_journal_stop(handle);\n\tif (!ret)\n\t\tret = ret2;\n\n\tif (pos + len > inode->i_size) {\n\t\text4_truncate_failed_write(inode);\n\t\t/*\n\t\t * If truncate failed early the inode might still be\n\t\t * on the orphan list; we need to make sure the inode\n\t\t * is removed from the orphan list in that case.\n\t\t */\n\t\tif (inode->i_nlink)\n\t\t\text4_orphan_del(NULL, inode);\n\t}\n\n\treturn ret ? ret : copied;\n}\n", "target": 1, "idx": 181443}
{"func": "static boolean parse_identifier( const char **pcur, char *ret )\n {\n    const char *cur = *pcur;\n    int i = 0;\n    if (is_alpha_underscore( cur )) {\n       ret[i++] = *cur++;\n      while (is_alpha_underscore( cur ) || is_digit( cur ))\n          ret[i++] = *cur++;\n       ret[i++] = '\\0';\n       *pcur = cur;\n       return TRUE;\n\n/* Parse floating point.\n */\nstatic boolean parse_float( const char **pcur, float *val )\n{\n   const char *cur = *pcur;\n   boolean integral_part = FALSE;\n   boolean fractional_part = FALSE;\n\n   if (*cur == '0' && *(cur + 1) == 'x') {\n      union fi fi;\n      fi.ui = strtoul(cur, NULL, 16);\n      *val = fi.f;\n      cur += 10;\n      goto out;\n   }\n\n   *val = (float) atof( cur );\n   if (*cur == '-' || *cur == '+')\n      cur++;\n   if (is_digit( cur )) {\n      cur++;\n      integral_part = TRUE;\n      while (is_digit( cur ))\n         cur++;\n   }\n   if (*cur == '.') {\n      cur++;\n      if (is_digit( cur )) {\n         cur++;\n         fractional_part = TRUE;\n         while (is_digit( cur ))\n            cur++;\n      }\n   }\n   if (!integral_part && !fractional_part)\n      return FALSE;\n   if (uprcase( *cur ) == 'E') {\n      cur++;\n      if (*cur == '-' || *cur == '+')\n         cur++;\n      if (is_digit( cur )) {\n         cur++;\n         while (is_digit( cur ))\n            cur++;\n      }\n      else\n         return FALSE;\n   }\n\nout:\n   *pcur = cur;\n   return TRUE;\n}\n\nstatic boolean parse_double( const char **pcur, uint32_t *val0, uint32_t *val1)\n{\n   const char *cur = *pcur;\n   union {\n      double dval;\n      uint32_t uval[2];\n   } v;\n\n   v.dval = strtod(cur, (char**)pcur);\n   if (*pcur == cur)\n      return FALSE;\n\n   *val0 = v.uval[0];\n   *val1 = v.uval[1];\n\n   return TRUE;\n}\n\nstruct translate_ctx\n{\n   const char *text;\n   const char *cur;\n   struct tgsi_token *tokens;\n   struct tgsi_token *tokens_cur;\n   struct tgsi_token *tokens_end;\n   struct tgsi_header *header;\n   unsigned processor : 4;\n   unsigned implied_array_size : 6;\n   unsigned num_immediates;\n};\n\nstatic void report_error(struct translate_ctx *ctx, const char *format, ...)\n{\n   va_list args;\n   int line = 1;\n   int column = 1;\n   const char *itr = ctx->text;\n\n   debug_printf(\"\\nTGSI asm error: \");\n\n   va_start(args, format);\n   _debug_vprintf(format, args);\n   va_end(args);\n\n   while (itr != ctx->cur) {\n      if (*itr == '\\n') {\n         column = 1;\n         ++line;\n      }\n      ++column;\n      ++itr;\n   }\n\n   debug_printf(\" [%d : %d] \\n\", line, column);\n}\n\n/* Parse shader header.\n * Return TRUE for one of the following headers.\n *    FRAG\n *    GEOM\n *    VERT\n */\nstatic boolean parse_header( struct translate_ctx *ctx )\n{\n   uint processor;\n\n   if (str_match_nocase_whole( &ctx->cur, \"FRAG\" ))\n      processor = TGSI_PROCESSOR_FRAGMENT;\n   else if (str_match_nocase_whole( &ctx->cur, \"VERT\" ))\n      processor = TGSI_PROCESSOR_VERTEX;\n   else if (str_match_nocase_whole( &ctx->cur, \"GEOM\" ))\n      processor = TGSI_PROCESSOR_GEOMETRY;\n   else if (str_match_nocase_whole( &ctx->cur, \"TESS_CTRL\" ))\n      processor = TGSI_PROCESSOR_TESS_CTRL;\n   else if (str_match_nocase_whole( &ctx->cur, \"TESS_EVAL\" ))\n      processor = TGSI_PROCESSOR_TESS_EVAL;\n   else if (str_match_nocase_whole( &ctx->cur, \"COMP\" ))\n      processor = TGSI_PROCESSOR_COMPUTE;\n   else {\n      report_error( ctx, \"Unknown header\" );\n      return FALSE;\n   }\n\n   if (ctx->tokens_cur >= ctx->tokens_end)\n      return FALSE;\n   ctx->header = (struct tgsi_header *) ctx->tokens_cur++;\n   *ctx->header = tgsi_build_header();\n\n   if (ctx->tokens_cur >= ctx->tokens_end)\n      return FALSE;\n   *(struct tgsi_processor *) ctx->tokens_cur++ = tgsi_build_processor( processor, ctx->header );\n   ctx->processor = processor;\n\n   return TRUE;\n}\n\nstatic boolean parse_label( struct translate_ctx *ctx, uint *val )\n{\n   const char *cur = ctx->cur;\n\n   if (parse_uint( &cur, val )) {\n      eat_opt_white( &cur );\n      if (*cur == ':') {\n         cur++;\n         ctx->cur = cur;\n         return TRUE;\n      }\n   }\n   return FALSE;\n}\n\nstatic boolean\nparse_file( const char **pcur, uint *file )\n{\n   uint i;\n\n   for (i = 0; i < TGSI_FILE_COUNT; i++) {\n      const char *cur = *pcur;\n\n      if (str_match_nocase_whole( &cur, tgsi_file_name(i) )) {\n         *pcur = cur;\n         *file = i;\n         return TRUE;\n      }\n   }\n   return FALSE;\n}\n\nstatic boolean\nparse_opt_writemask(\n   struct translate_ctx *ctx,\n   uint *writemask )\n{\n   const char *cur;\n\n   cur = ctx->cur;\n   eat_opt_white( &cur );\n   if (*cur == '.') {\n      cur++;\n      *writemask = TGSI_WRITEMASK_NONE;\n      eat_opt_white( &cur );\n      if (uprcase( *cur ) == 'X') {\n         cur++;\n         *writemask |= TGSI_WRITEMASK_X;\n      }\n      if (uprcase( *cur ) == 'Y') {\n         cur++;\n         *writemask |= TGSI_WRITEMASK_Y;\n      }\n      if (uprcase( *cur ) == 'Z') {\n         cur++;\n         *writemask |= TGSI_WRITEMASK_Z;\n      }\n      if (uprcase( *cur ) == 'W') {\n         cur++;\n         *writemask |= TGSI_WRITEMASK_W;\n      }\n\n      if (*writemask == TGSI_WRITEMASK_NONE) {\n         report_error( ctx, \"Writemask expected\" );\n         return FALSE;\n      }\n\n      ctx->cur = cur;\n   }\n   else {\n      *writemask = TGSI_WRITEMASK_XYZW;\n   }\n   return TRUE;\n}\n\n\n/* <register_file_bracket> ::= <file> `['\n */\nstatic boolean\nparse_register_file_bracket(\n   struct translate_ctx *ctx,\n   uint *file )\n{\n   if (!parse_file( &ctx->cur, file )) {\n      report_error( ctx, \"Unknown register file\" );\n      return FALSE;\n   }\n   eat_opt_white( &ctx->cur );\n   if (*ctx->cur != '[') {\n      report_error( ctx, \"Expected `['\" );\n      return FALSE;\n   }\n   ctx->cur++;\n   return TRUE;\n}\n\n/* <register_file_bracket_index> ::= <register_file_bracket> <uint>\n */\nstatic boolean\nparse_register_file_bracket_index(\n   struct translate_ctx *ctx,\n   uint *file,\n   int *index )\n{\n   uint uindex;\n\n   if (!parse_register_file_bracket( ctx, file ))\n      return FALSE;\n   eat_opt_white( &ctx->cur );\n   if (!parse_uint( &ctx->cur, &uindex )) {\n      report_error( ctx, \"Expected literal unsigned integer\" );\n      return FALSE;\n   }\n   *index = (int) uindex;\n   return TRUE;\n}\n\n/* Parse simple 1d register operand.\n *    <register_dst> ::= <register_file_bracket_index> `]'\n */\nstatic boolean\nparse_register_1d(struct translate_ctx *ctx,\n                  uint *file,\n                  int *index )\n{\n   if (!parse_register_file_bracket_index( ctx, file, index ))\n      return FALSE;\n   eat_opt_white( &ctx->cur );\n   if (*ctx->cur != ']') {\n      report_error( ctx, \"Expected `]'\" );\n      return FALSE;\n   }\n   ctx->cur++;\n   return TRUE;\n}\n\nstruct parsed_bracket {\n   int index;\n\n   uint ind_file;\n   int ind_index;\n   uint ind_comp;\n   uint ind_array;\n};\n\n\nstatic boolean\nparse_register_bracket(\n   struct translate_ctx *ctx,\n   struct parsed_bracket *brackets)\n{\n   const char *cur;\n   uint uindex;\n\n   memset(brackets, 0, sizeof(struct parsed_bracket));\n\n   eat_opt_white( &ctx->cur );\n\n   cur = ctx->cur;\n   if (parse_file( &cur, &brackets->ind_file )) {\n      if (!parse_register_1d( ctx, &brackets->ind_file,\n                              &brackets->ind_index ))\n         return FALSE;\n      eat_opt_white( &ctx->cur );\n\n      if (*ctx->cur == '.') {\n         ctx->cur++;\n         eat_opt_white(&ctx->cur);\n\n         switch (uprcase(*ctx->cur)) {\n         case 'X':\n            brackets->ind_comp = TGSI_SWIZZLE_X;\n            break;\n         case 'Y':\n            brackets->ind_comp = TGSI_SWIZZLE_Y;\n            break;\n         case 'Z':\n            brackets->ind_comp = TGSI_SWIZZLE_Z;\n            break;\n         case 'W':\n            brackets->ind_comp = TGSI_SWIZZLE_W;\n            break;\n         default:\n            report_error(ctx, \"Expected indirect register swizzle component `x', `y', `z' or `w'\");\n            return FALSE;\n         }\n         ctx->cur++;\n         eat_opt_white(&ctx->cur);\n      }\n\n      if (*ctx->cur == '+' || *ctx->cur == '-')\n         parse_int( &ctx->cur, &brackets->index );\n      else\n         brackets->index = 0;\n   }\n   else {\n      if (!parse_uint( &ctx->cur, &uindex )) {\n         report_error( ctx, \"Expected literal unsigned integer\" );\n         return FALSE;\n      }\n      brackets->index = (int) uindex;\n      brackets->ind_file = TGSI_FILE_NULL;\n      brackets->ind_index = 0;\n   }\n   eat_opt_white( &ctx->cur );\n   if (*ctx->cur != ']') {\n      report_error( ctx, \"Expected `]'\" );\n      return FALSE;\n   }\n   ctx->cur++;\n   if (*ctx->cur == '(') {\n      ctx->cur++;\n      eat_opt_white( &ctx->cur );\n      if (!parse_uint( &ctx->cur, &brackets->ind_array )) {\n         report_error( ctx, \"Expected literal unsigned integer\" );\n         return FALSE;\n      }\n      eat_opt_white( &ctx->cur );\n      if (*ctx->cur != ')') {\n         report_error( ctx, \"Expected `)'\" );\n         return FALSE;\n      }\n      ctx->cur++;\n   }\n   return TRUE;\n}\n\nstatic boolean\nparse_opt_register_src_bracket(\n   struct translate_ctx *ctx,\n   struct parsed_bracket *brackets,\n   int *parsed_brackets)\n{\n   const char *cur = ctx->cur;\n\n   *parsed_brackets = 0;\n\n   eat_opt_white( &cur );\n   if (cur[0] == '[') {\n      ++cur;\n      ctx->cur = cur;\n\n      if (!parse_register_bracket(ctx, brackets))\n         return FALSE;\n\n      *parsed_brackets = 1;\n   }\n\n   return TRUE;\n}\n\n\n/* Parse source register operand.\n *    <register_src> ::= <register_file_bracket_index> `]' |\n *                       <register_file_bracket> <register_dst> [`.' (`x' | `y' | `z' | `w')] `]' |\n *                       <register_file_bracket> <register_dst> [`.' (`x' | `y' | `z' | `w')] `+' <uint> `]' |\n *                       <register_file_bracket> <register_dst> [`.' (`x' | `y' | `z' | `w')] `-' <uint> `]'\n */\nstatic boolean\nparse_register_src(\n   struct translate_ctx *ctx,\n   uint *file,\n   struct parsed_bracket *brackets)\n{\n   brackets->ind_comp = TGSI_SWIZZLE_X;\n   if (!parse_register_file_bracket( ctx, file ))\n      return FALSE;\n   if (!parse_register_bracket( ctx, brackets ))\n       return FALSE;\n\n   return TRUE;\n}\n\nstruct parsed_dcl_bracket {\n   uint first;\n   uint last;\n};\n\nstatic boolean\nparse_register_dcl_bracket(\n   struct translate_ctx *ctx,\n   struct parsed_dcl_bracket *bracket)\n{\n   uint uindex;\n   memset(bracket, 0, sizeof(struct parsed_dcl_bracket));\n\n   eat_opt_white( &ctx->cur );\n\n   if (!parse_uint( &ctx->cur, &uindex )) {\n      /* it can be an empty bracket [] which means its range\n       * is from 0 to some implied size */\n      if (ctx->cur[0] == ']' && ctx->implied_array_size != 0) {\n         bracket->first = 0;\n         bracket->last = ctx->implied_array_size - 1;\n         goto cleanup;\n      }\n      report_error( ctx, \"Expected literal unsigned integer\" );\n      return FALSE;\n   }\n   bracket->first = uindex;\n\n   eat_opt_white( &ctx->cur );\n\n   if (ctx->cur[0] == '.' && ctx->cur[1] == '.') {\n      uint uindex;\n\n      ctx->cur += 2;\n      eat_opt_white( &ctx->cur );\n      if (!parse_uint( &ctx->cur, &uindex )) {\n         report_error( ctx, \"Expected literal integer\" );\n         return FALSE;\n      }\n      bracket->last = (int) uindex;\n      eat_opt_white( &ctx->cur );\n   }\n   else {\n      bracket->last = bracket->first;\n   }\n\ncleanup:\n   if (*ctx->cur != ']') {\n      report_error( ctx, \"Expected `]' or `..'\" );\n      return FALSE;\n   }\n   ctx->cur++;\n   return TRUE;\n}\n\n/* Parse register declaration.\n *    <register_dcl> ::= <register_file_bracket_index> `]' |\n *                       <register_file_bracket_index> `..' <index> `]'\n */\nstatic boolean\nparse_register_dcl(\n   struct translate_ctx *ctx,\n   uint *file,\n   struct parsed_dcl_bracket *brackets,\n   int *num_brackets)\n{\n   const char *cur;\n\n   *num_brackets = 0;\n\n   if (!parse_register_file_bracket( ctx, file ))\n      return FALSE;\n   if (!parse_register_dcl_bracket( ctx, &brackets[0] ))\n      return FALSE;\n\n   *num_brackets = 1;\n\n   cur = ctx->cur;\n   eat_opt_white( &cur );\n\n   if (cur[0] == '[') {\n      bool is_in = *file == TGSI_FILE_INPUT;\n      bool is_out = *file == TGSI_FILE_OUTPUT;\n\n      ++cur;\n      ctx->cur = cur;\n      if (!parse_register_dcl_bracket( ctx, &brackets[1] ))\n         return FALSE;\n      /* for geometry shader we don't really care about\n       * the first brackets it's always the size of the\n       * input primitive. so we want to declare just\n       * the index relevant to the semantics which is in\n       * the second bracket */\n\n      /* tessellation has similar constraints to geometry shader */\n      if ((ctx->processor == TGSI_PROCESSOR_GEOMETRY && is_in) ||\n          (ctx->processor == TGSI_PROCESSOR_TESS_EVAL && is_in) ||\n          (ctx->processor == TGSI_PROCESSOR_TESS_CTRL && (is_in || is_out))) {\n         brackets[0] = brackets[1];\n         *num_brackets = 1;\n      } else {\n         *num_brackets = 2;\n      }\n   }\n\n   return TRUE;\n}\n\n\n/* Parse destination register operand.*/\nstatic boolean\nparse_register_dst(\n   struct translate_ctx *ctx,\n   uint *file,\n   struct parsed_bracket *brackets)\n{\n   brackets->ind_comp = TGSI_SWIZZLE_X;\n   if (!parse_register_file_bracket( ctx, file ))\n      return FALSE;\n   if (!parse_register_bracket( ctx, brackets ))\n       return FALSE;\n\n   return TRUE;\n}\n\nstatic boolean\nparse_dst_operand(\n   struct translate_ctx *ctx,\n   struct tgsi_full_dst_register *dst )\n{\n   uint file;\n   uint writemask;\n   const char *cur;\n   struct parsed_bracket bracket[2];\n   int parsed_opt_brackets;\n\n   if (!parse_register_dst( ctx, &file, &bracket[0] ))\n      return FALSE;\n   if (!parse_opt_register_src_bracket(ctx, &bracket[1], &parsed_opt_brackets))\n      return FALSE;\n\n   cur = ctx->cur;\n   eat_opt_white( &cur );\n\n   if (!parse_opt_writemask( ctx, &writemask ))\n      return FALSE;\n\n   dst->Register.File = file;\n   if (parsed_opt_brackets) {\n      dst->Register.Dimension = 1;\n      dst->Dimension.Indirect = 0;\n      dst->Dimension.Dimension = 0;\n      dst->Dimension.Index = bracket[0].index;\n\n      if (bracket[0].ind_file != TGSI_FILE_NULL) {\n         dst->Dimension.Indirect = 1;\n         dst->DimIndirect.File = bracket[0].ind_file;\n         dst->DimIndirect.Index = bracket[0].ind_index;\n         dst->DimIndirect.Swizzle = bracket[0].ind_comp;\n         dst->DimIndirect.ArrayID = bracket[0].ind_array;\n      }\n      bracket[0] = bracket[1];\n   }\n   dst->Register.Index = bracket[0].index;\n   dst->Register.WriteMask = writemask;\n   if (bracket[0].ind_file != TGSI_FILE_NULL) {\n      dst->Register.Indirect = 1;\n      dst->Indirect.File = bracket[0].ind_file;\n      dst->Indirect.Index = bracket[0].ind_index;\n      dst->Indirect.Swizzle = bracket[0].ind_comp;\n      dst->Indirect.ArrayID = bracket[0].ind_array;\n   }\n   return TRUE;\n}\n\nstatic boolean\nparse_optional_swizzle(\n   struct translate_ctx *ctx,\n   uint *swizzle,\n   boolean *parsed_swizzle,\n   int components)\n{\n   const char *cur = ctx->cur;\n\n   *parsed_swizzle = FALSE;\n\n   eat_opt_white( &cur );\n   if (*cur == '.') {\n      uint i;\n\n      cur++;\n      eat_opt_white( &cur );\n      for (i = 0; i < components; i++) {\n         if (uprcase( *cur ) == 'X')\n            swizzle[i] = TGSI_SWIZZLE_X;\n         else if (uprcase( *cur ) == 'Y')\n            swizzle[i] = TGSI_SWIZZLE_Y;\n         else if (uprcase( *cur ) == 'Z')\n            swizzle[i] = TGSI_SWIZZLE_Z;\n         else if (uprcase( *cur ) == 'W')\n            swizzle[i] = TGSI_SWIZZLE_W;\n         else {\n\t    report_error( ctx, \"Expected register swizzle component `x', `y', `z' or `w'\" );\n\t    return FALSE;\n         }\n         cur++;\n      }\n      *parsed_swizzle = TRUE;\n      ctx->cur = cur;\n   }\n   return TRUE;\n}\n\nstatic boolean\nparse_src_operand(\n   struct translate_ctx *ctx,\n   struct tgsi_full_src_register *src )\n{\n   uint file;\n   uint swizzle[4];\n   boolean parsed_swizzle;\n   struct parsed_bracket bracket[2];\n   int parsed_opt_brackets;\n\n   if (*ctx->cur == '-') {\n      ctx->cur++;\n      eat_opt_white( &ctx->cur );\n      src->Register.Negate = 1;\n   }\n\n   if (*ctx->cur == '|') {\n      ctx->cur++;\n      eat_opt_white( &ctx->cur );\n      src->Register.Absolute = 1;\n   }\n\n   if (!parse_register_src(ctx, &file, &bracket[0]))\n      return FALSE;\n   if (!parse_opt_register_src_bracket(ctx, &bracket[1], &parsed_opt_brackets))\n      return FALSE;\n\n   src->Register.File = file;\n   if (parsed_opt_brackets) {\n      src->Register.Dimension = 1;\n      src->Dimension.Indirect = 0;\n      src->Dimension.Dimension = 0;\n      src->Dimension.Index = bracket[0].index;\n      if (bracket[0].ind_file != TGSI_FILE_NULL) {\n         src->Dimension.Indirect = 1;\n         src->DimIndirect.File = bracket[0].ind_file;\n         src->DimIndirect.Index = bracket[0].ind_index;\n         src->DimIndirect.Swizzle = bracket[0].ind_comp;\n         src->DimIndirect.ArrayID = bracket[0].ind_array;\n      }\n      bracket[0] = bracket[1];\n   }\n   src->Register.Index = bracket[0].index;\n   if (bracket[0].ind_file != TGSI_FILE_NULL) {\n      src->Register.Indirect = 1;\n      src->Indirect.File = bracket[0].ind_file;\n      src->Indirect.Index = bracket[0].ind_index;\n      src->Indirect.Swizzle = bracket[0].ind_comp;\n      src->Indirect.ArrayID = bracket[0].ind_array;\n   }\n\n   /* Parse optional swizzle.\n    */\n   if (parse_optional_swizzle( ctx, swizzle, &parsed_swizzle, 4 )) {\n      if (parsed_swizzle) {\n         src->Register.SwizzleX = swizzle[0];\n         src->Register.SwizzleY = swizzle[1];\n         src->Register.SwizzleZ = swizzle[2];\n         src->Register.SwizzleW = swizzle[3];\n      }\n   }\n\n   if (src->Register.Absolute) {\n      eat_opt_white( &ctx->cur );\n      if (*ctx->cur != '|') {\n         report_error( ctx, \"Expected `|'\" );\n         return FALSE;\n      }\n      ctx->cur++;\n   }\n\n\n   return TRUE;\n}\n\nstatic boolean\nparse_texoffset_operand(\n   struct translate_ctx *ctx,\n   struct tgsi_texture_offset *src )\n{\n   uint file;\n   uint swizzle[3];\n   boolean parsed_swizzle;\n   struct parsed_bracket bracket;\n\n   if (!parse_register_src(ctx, &file, &bracket))\n      return FALSE;\n\n   src->File = file;\n   src->Index = bracket.index;\n\n   /* Parse optional swizzle.\n    */\n   if (parse_optional_swizzle( ctx, swizzle, &parsed_swizzle, 3 )) {\n      if (parsed_swizzle) {\n         src->SwizzleX = swizzle[0];\n         src->SwizzleY = swizzle[1];\n         src->SwizzleZ = swizzle[2];\n      }\n   }\n\n   return TRUE;\n}\n\nstatic boolean\nmatch_inst(const char **pcur,\n           unsigned *saturate,\n           const struct tgsi_opcode_info *info)\n{\n   const char *cur = *pcur;\n\n   /* simple case: the whole string matches the instruction name */\n   if (str_match_nocase_whole(&cur, info->mnemonic)) {\n      *pcur = cur;\n      *saturate = 0;\n      return TRUE;\n   }\n\n   if (str_match_no_case(&cur, info->mnemonic)) {\n      /* the instruction has a suffix, figure it out */\n      if (str_match_nocase_whole(&cur, \"_SAT\")) {\n         *pcur = cur;\n         *saturate = 1;\n         return TRUE;\n      }\n   }\n\n   return FALSE;\n}\n\nstatic boolean\nparse_instruction(\n   struct translate_ctx *ctx,\n   boolean has_label )\n{\n   uint i;\n   uint saturate = 0;\n   const struct tgsi_opcode_info *info;\n   struct tgsi_full_instruction inst;\n   const char *cur;\n   uint advance;\n\n   inst = tgsi_default_full_instruction();\n\n   /* Parse predicate.\n    */\n   eat_opt_white( &ctx->cur );\n   if (*ctx->cur == '(') {\n      uint file;\n      int index;\n      uint swizzle[4];\n      boolean parsed_swizzle;\n\n      inst.Instruction.Predicate = 1;\n\n      ctx->cur++;\n      if (*ctx->cur == '!') {\n         ctx->cur++;\n         inst.Predicate.Negate = 1;\n      }\n\n      if (!parse_register_1d( ctx, &file, &index ))\n         return FALSE;\n\n      if (parse_optional_swizzle( ctx, swizzle, &parsed_swizzle, 4 )) {\n         if (parsed_swizzle) {\n            inst.Predicate.SwizzleX = swizzle[0];\n            inst.Predicate.SwizzleY = swizzle[1];\n            inst.Predicate.SwizzleZ = swizzle[2];\n            inst.Predicate.SwizzleW = swizzle[3];\n         }\n      }\n\n      if (*ctx->cur != ')') {\n         report_error( ctx, \"Expected `)'\" );\n         return FALSE;\n      }\n\n      ctx->cur++;\n   }\n\n   /* Parse instruction name.\n    */\n   eat_opt_white( &ctx->cur );\n   for (i = 0; i < TGSI_OPCODE_LAST; i++) {\n      cur = ctx->cur;\n\n      info = tgsi_get_opcode_info( i );\n      if (match_inst(&cur, &saturate, info)) {\n         if (info->num_dst + info->num_src + info->is_tex == 0) {\n            ctx->cur = cur;\n            break;\n         }\n         else if (*cur == '\\0' || eat_white( &cur )) {\n            ctx->cur = cur;\n            break;\n         }\n      }\n   }\n   if (i == TGSI_OPCODE_LAST) {\n      if (has_label)\n         report_error( ctx, \"Unknown opcode\" );\n      else\n         report_error( ctx, \"Expected `DCL', `IMM' or a label\" );\n      return FALSE;\n   }\n\n   inst.Instruction.Opcode = i;\n   inst.Instruction.Saturate = saturate;\n   inst.Instruction.NumDstRegs = info->num_dst;\n   inst.Instruction.NumSrcRegs = info->num_src;\n\n   if (i >= TGSI_OPCODE_SAMPLE && i <= TGSI_OPCODE_GATHER4) {\n      /*\n       * These are not considered tex opcodes here (no additional\n       * target argument) however we're required to set the Texture\n       * bit so we can set the number of tex offsets.\n       */\n      inst.Instruction.Texture = 1;\n      inst.Texture.Texture = TGSI_TEXTURE_UNKNOWN;\n   }\n\n   /* Parse instruction operands.\n    */\n   for (i = 0; i < info->num_dst + info->num_src + info->is_tex; i++) {\n      if (i > 0) {\n         eat_opt_white( &ctx->cur );\n         if (*ctx->cur != ',') {\n            report_error( ctx, \"Expected `,'\" );\n            return FALSE;\n         }\n         ctx->cur++;\n         eat_opt_white( &ctx->cur );\n      }\n\n      if (i < info->num_dst) {\n         if (!parse_dst_operand( ctx, &inst.Dst[i] ))\n            return FALSE;\n      }\n      else if (i < info->num_dst + info->num_src) {\n         if (!parse_src_operand( ctx, &inst.Src[i - info->num_dst] ))\n            return FALSE;\n      }\n      else {\n         uint j;\n\n         for (j = 0; j < TGSI_TEXTURE_COUNT; j++) {\n            if (str_match_nocase_whole( &ctx->cur, tgsi_texture_names[j] )) {\n               inst.Instruction.Texture = 1;\n               inst.Texture.Texture = j;\n               break;\n            }\n         }\n         if (j == TGSI_TEXTURE_COUNT) {\n            report_error( ctx, \"Expected texture target\" );\n            return FALSE;\n         }\n      }\n   }\n\n   cur = ctx->cur;\n   eat_opt_white( &cur );\n   for (i = 0; inst.Instruction.Texture && *cur == ','; i++) {\n         cur++;\n         eat_opt_white( &cur );\n         ctx->cur = cur;\n         if (!parse_texoffset_operand( ctx, &inst.TexOffsets[i] ))\n            return FALSE;\n         cur = ctx->cur;\n         eat_opt_white( &cur );\n   }\n   inst.Texture.NumOffsets = i;\n\n   cur = ctx->cur;\n   eat_opt_white( &cur );\n   if (info->is_branch && *cur == ':') {\n      uint target;\n\n      cur++;\n      eat_opt_white( &cur );\n      if (!parse_uint( &cur, &target )) {\n         report_error( ctx, \"Expected a label\" );\n         return FALSE;\n      }\n      inst.Instruction.Label = 1;\n      inst.Label.Label = target;\n      ctx->cur = cur;\n   }\n\n   advance = tgsi_build_full_instruction(\n      &inst,\n      ctx->tokens_cur,\n      ctx->header,\n      (uint) (ctx->tokens_end - ctx->tokens_cur) );\n   if (advance == 0)\n      return FALSE;\n   ctx->tokens_cur += advance;\n\n   return TRUE;\n}\n\n/* parses a 4-touple of the form {x, y, z, w}\n * where x, y, z, w are numbers */\nstatic boolean parse_immediate_data(struct translate_ctx *ctx, unsigned type,\n                                    union tgsi_immediate_data *values)\n{\n   unsigned i;\n   int ret;\n\n   eat_opt_white( &ctx->cur );\n   if (*ctx->cur != '{') {\n      report_error( ctx, \"Expected `{'\" );\n      return FALSE;\n   }\n   ctx->cur++;\n   for (i = 0; i < 4; i++) {\n      eat_opt_white( &ctx->cur );\n      if (i > 0) {\n         if (*ctx->cur != ',') {\n            report_error( ctx, \"Expected `,'\" );\n            return FALSE;\n         }\n         ctx->cur++;\n         eat_opt_white( &ctx->cur );\n      }\n\n      switch (type) {\n      case TGSI_IMM_FLOAT64:\n         ret = parse_double(&ctx->cur, &values[i].Uint, &values[i+1].Uint);\n         i++;\n         break;\n      case TGSI_IMM_FLOAT32:\n         ret = parse_float(&ctx->cur, &values[i].Float);\n         break;\n      case TGSI_IMM_UINT32:\n         ret = parse_uint(&ctx->cur, &values[i].Uint);\n         break;\n      case TGSI_IMM_INT32:\n         ret = parse_int(&ctx->cur, &values[i].Int);\n         break;\n      default:\n         assert(0);\n         ret = FALSE;\n         break;\n      }\n\n      if (!ret) {\n         report_error( ctx, \"Expected immediate constant\" );\n         return FALSE;\n      }\n   }\n   eat_opt_white( &ctx->cur );\n   if (*ctx->cur != '}') {\n      report_error( ctx, \"Expected `}'\" );\n      return FALSE;\n   }\n   ctx->cur++;\n\n   return TRUE;\n}\n\nstatic boolean parse_declaration( struct translate_ctx *ctx )\n{\n   struct tgsi_full_declaration decl;\n   uint file;\n   struct parsed_dcl_bracket brackets[2];\n   int num_brackets;\n   uint writemask;\n   const char *cur, *cur2;\n   uint advance;\n   boolean is_vs_input;\n\n   if (!eat_white( &ctx->cur )) {\n      report_error( ctx, \"Syntax error\" );\n      return FALSE;\n   }\n   if (!parse_register_dcl( ctx, &file, brackets, &num_brackets))\n      return FALSE;\n   if (!parse_opt_writemask( ctx, &writemask ))\n      return FALSE;\n\n   decl = tgsi_default_full_declaration();\n   decl.Declaration.File = file;\n   decl.Declaration.UsageMask = writemask;\n\n   if (num_brackets == 1) {\n      decl.Range.First = brackets[0].first;\n      decl.Range.Last = brackets[0].last;\n   } else {\n      decl.Range.First = brackets[1].first;\n      decl.Range.Last = brackets[1].last;\n\n      decl.Declaration.Dimension = 1;\n      decl.Dim.Index2D = brackets[0].first;\n   }\n\n   is_vs_input = (file == TGSI_FILE_INPUT &&\n                  ctx->processor == TGSI_PROCESSOR_VERTEX);\n\n   cur = ctx->cur;\n   eat_opt_white( &cur );\n   if (*cur == ',') {\n      cur2 = cur;\n      cur2++;\n      eat_opt_white( &cur2 );\n      if (str_match_nocase_whole( &cur2, \"ARRAY\" )) {\n         int arrayid;\n         if (*cur2 != '(') {\n            report_error( ctx, \"Expected `('\" );\n            return FALSE;\n         }\n         cur2++;\n         eat_opt_white( &cur2 );\n         if (!parse_int( &cur2, &arrayid )) {\n            report_error( ctx, \"Expected `,'\" );\n            return FALSE;\n         }\n         eat_opt_white( &cur2 );\n         if (*cur2 != ')') {\n            report_error( ctx, \"Expected `)'\" );\n            return FALSE;\n         }\n         cur2++;\n         decl.Declaration.Array = 1;\n         decl.Array.ArrayID = arrayid;\n         ctx->cur = cur = cur2;\n      }\n   }\n\n   if (*cur == ',' && !is_vs_input) {\n      uint i, j;\n\n      cur++;\n      eat_opt_white( &cur );\n      if (file == TGSI_FILE_RESOURCE) {\n         for (i = 0; i < TGSI_TEXTURE_COUNT; i++) {\n            if (str_match_nocase_whole(&cur, tgsi_texture_names[i])) {\n               decl.Resource.Resource = i;\n               break;\n            }\n         }\n         if (i == TGSI_TEXTURE_COUNT) {\n            report_error(ctx, \"Expected texture target\");\n            return FALSE;\n         }\n\n         cur2 = cur;\n         eat_opt_white(&cur2);\n         while (*cur2 == ',') {\n            cur2++;\n            eat_opt_white(&cur2);\n            if (str_match_nocase_whole(&cur2, \"RAW\")) {\n               decl.Resource.Raw = 1;\n\n            } else if (str_match_nocase_whole(&cur2, \"WR\")) {\n               decl.Resource.Writable = 1;\n\n            } else {\n               break;\n            }\n            cur = cur2;\n            eat_opt_white(&cur2);\n         }\n\n         ctx->cur = cur;\n\n      } else if (file == TGSI_FILE_SAMPLER_VIEW) {\n         for (i = 0; i < TGSI_TEXTURE_COUNT; i++) {\n            if (str_match_nocase_whole(&cur, tgsi_texture_names[i])) {\n               decl.SamplerView.Resource = i;\n               break;\n            }\n         }\n         if (i == TGSI_TEXTURE_COUNT) {\n            report_error(ctx, \"Expected texture target\");\n            return FALSE;\n         }\n         eat_opt_white( &cur );\n         if (*cur != ',') {\n            report_error( ctx, \"Expected `,'\" );\n            return FALSE;\n         }\n         ++cur;\n         eat_opt_white( &cur );\n         for (j = 0; j < 4; ++j) {\n            for (i = 0; i < TGSI_RETURN_TYPE_COUNT; ++i) {\n               if (str_match_nocase_whole(&cur, tgsi_return_type_names[i])) {\n                  switch (j) {\n                  case 0:\n                     decl.SamplerView.ReturnTypeX = i;\n                     break;\n                  case 1:\n                     decl.SamplerView.ReturnTypeY = i;\n                     break;\n                  case 2:\n                     decl.SamplerView.ReturnTypeZ = i;\n                     break;\n                  case 3:\n                     decl.SamplerView.ReturnTypeW = i;\n                     break;\n                  default:\n                     assert(0);\n                  }\n                  break;\n               }\n            }\n            if (i == TGSI_RETURN_TYPE_COUNT) {\n               if (j == 0 || j >  2) {\n                  report_error(ctx, \"Expected type name\");\n                  return FALSE;\n               }\n               break;\n            } else {\n               cur2 = cur;\n               eat_opt_white( &cur2 );\n               if (*cur2 == ',') {\n                  cur2++;\n                  eat_opt_white( &cur2 );\n                  cur = cur2;\n                  continue;\n               } else\n                  break;\n            }\n         }\n         if (j < 4) {\n            decl.SamplerView.ReturnTypeY =\n               decl.SamplerView.ReturnTypeZ =\n               decl.SamplerView.ReturnTypeW =\n               decl.SamplerView.ReturnTypeX;\n         }\n         ctx->cur = cur;\n      } else {\n         if (str_match_nocase_whole(&cur, \"LOCAL\")) {\n            decl.Declaration.Local = 1;\n            ctx->cur = cur;\n         }\n\n         cur = ctx->cur;\n         eat_opt_white( &cur );\n         if (*cur == ',') {\n            cur++;\n            eat_opt_white( &cur );\n\n            for (i = 0; i < TGSI_SEMANTIC_COUNT; i++) {\n               if (str_match_nocase_whole(&cur, tgsi_semantic_names[i])) {\n                  uint index;\n\n                  cur2 = cur;\n                  eat_opt_white( &cur2 );\n                  if (*cur2 == '[') {\n                     cur2++;\n                     eat_opt_white( &cur2 );\n                     if (!parse_uint( &cur2, &index )) {\n                        report_error( ctx, \"Expected literal integer\" );\n                        return FALSE;\n                     }\n                     eat_opt_white( &cur2 );\n                     if (*cur2 != ']') {\n                        report_error( ctx, \"Expected `]'\" );\n                        return FALSE;\n                     }\n                     cur2++;\n\n                     decl.Semantic.Index = index;\n\n                     cur = cur2;\n                  }\n\n                  decl.Declaration.Semantic = 1;\n                  decl.Semantic.Name = i;\n\n                  ctx->cur = cur;\n                  break;\n               }\n            }\n         }\n      }\n   }\n\n   cur = ctx->cur;\n   eat_opt_white( &cur );\n   if (*cur == ',' && !is_vs_input) {\n      uint i;\n\n      cur++;\n      eat_opt_white( &cur );\n      for (i = 0; i < TGSI_INTERPOLATE_COUNT; i++) {\n         if (str_match_nocase_whole( &cur, tgsi_interpolate_names[i] )) {\n            decl.Declaration.Interpolate = 1;\n            decl.Interp.Interpolate = i;\n\n            ctx->cur = cur;\n            break;\n         }\n      }\n      if (i == TGSI_INTERPOLATE_COUNT) {\n         report_error( ctx, \"Expected semantic or interpolate attribute\" );\n         return FALSE;\n      }\n   }\n\n   cur = ctx->cur;\n   eat_opt_white( &cur );\n   if (*cur == ',' && !is_vs_input) {\n      uint i;\n\n      cur++;\n      eat_opt_white( &cur );\n      for (i = 0; i < TGSI_INTERPOLATE_LOC_COUNT; i++) {\n         if (str_match_nocase_whole( &cur, tgsi_interpolate_locations[i] )) {\n            decl.Interp.Location = i;\n\n            ctx->cur = cur;\n            break;\n         }\n      }\n   }\n\n   advance = tgsi_build_full_declaration(\n      &decl,\n      ctx->tokens_cur,\n      ctx->header,\n      (uint) (ctx->tokens_end - ctx->tokens_cur) );\n\n   if (advance == 0)\n      return FALSE;\n   ctx->tokens_cur += advance;\n\n   return TRUE;\n}\n\nstatic boolean parse_immediate( struct translate_ctx *ctx )\n{\n   struct tgsi_full_immediate imm;\n   uint advance;\n   int type;\n\n   if (*ctx->cur == '[') {\n      uint uindex;\n\n      ++ctx->cur;\n\n      eat_opt_white( &ctx->cur );\n      if (!parse_uint( &ctx->cur, &uindex )) {\n         report_error( ctx, \"Expected literal unsigned integer\" );\n         return FALSE;\n      }\n\n      if (uindex != ctx->num_immediates) {\n         report_error( ctx, \"Immediates must be sorted\" );\n         return FALSE;\n      }\n\n      eat_opt_white( &ctx->cur );\n      if (*ctx->cur != ']') {\n         report_error( ctx, \"Expected `]'\" );\n         return FALSE;\n      }\n\n      ctx->cur++;\n   }\n\n   if (!eat_white( &ctx->cur )) {\n      report_error( ctx, \"Syntax error\" );\n      return FALSE;\n   }\n   for (type = 0; type < Elements(tgsi_immediate_type_names); ++type) {\n      if (str_match_nocase_whole(&ctx->cur, tgsi_immediate_type_names[type]))\n         break;\n   }\n   if (type == Elements(tgsi_immediate_type_names)) {\n      report_error( ctx, \"Expected immediate type\" );\n      return FALSE;\n   }\n\n   imm = tgsi_default_full_immediate();\n   imm.Immediate.NrTokens += 4;\n   imm.Immediate.DataType = type;\n   parse_immediate_data(ctx, type, imm.u);\n\n   advance = tgsi_build_full_immediate(\n      &imm,\n      ctx->tokens_cur,\n      ctx->header,\n      (uint) (ctx->tokens_end - ctx->tokens_cur) );\n   if (advance == 0)\n      return FALSE;\n   ctx->tokens_cur += advance;\n\n   ctx->num_immediates++;\n\n   return TRUE;\n}\n\nstatic boolean\nparse_primitive( const char **pcur, uint *primitive )\n{\n   uint i;\n\n   for (i = 0; i < PIPE_PRIM_MAX; i++) {\n      const char *cur = *pcur;\n\n      if (str_match_nocase_whole( &cur, tgsi_primitive_names[i])) {\n         *primitive = i;\n         *pcur = cur;\n         return TRUE;\n      }\n   }\n   return FALSE;\n}\n\nstatic boolean\nparse_fs_coord_origin( const char **pcur, uint *fs_coord_origin )\n{\n   uint i;\n\n   for (i = 0; i < Elements(tgsi_fs_coord_origin_names); i++) {\n      const char *cur = *pcur;\n\n      if (str_match_nocase_whole( &cur, tgsi_fs_coord_origin_names[i])) {\n         *fs_coord_origin = i;\n         *pcur = cur;\n         return TRUE;\n      }\n   }\n   return FALSE;\n}\n\nstatic boolean\nparse_fs_coord_pixel_center( const char **pcur, uint *fs_coord_pixel_center )\n{\n   uint i;\n\n   for (i = 0; i < Elements(tgsi_fs_coord_pixel_center_names); i++) {\n      const char *cur = *pcur;\n\n      if (str_match_nocase_whole( &cur, tgsi_fs_coord_pixel_center_names[i])) {\n         *fs_coord_pixel_center = i;\n         *pcur = cur;\n         return TRUE;\n      }\n   }\n   return FALSE;\n}\n\n\nstatic boolean parse_property( struct translate_ctx *ctx )\n{\n   struct tgsi_full_property prop;\n   uint property_name;\n   uint values[8];\n   uint advance;\n   char id[64];\n\n   if (!eat_white( &ctx->cur )) {\n      report_error( ctx, \"Syntax error\" );\n      return FALSE;\n   }\n       report_error( ctx, \"Syntax error\" );\n       return FALSE;\n    }\n   if (!parse_identifier( &ctx->cur, id )) {\n       report_error( ctx, \"Syntax error\" );\n       return FALSE;\n    }\n         break;\n      }\n   }\n", "target": 1, "idx": 178123}
{"func": "GLsync GLES2DecoderImpl::DoFenceSync(GLenum condition, GLbitfield flags) {\n  const char* function_name = \"glFenceSync\";\n  if (condition != GL_SYNC_GPU_COMMANDS_COMPLETE) {\n    LOCAL_SET_GL_ERROR(GL_INVALID_ENUM, function_name, \"invalid condition\");\n    return 0;\n  }\n  if (flags != 0) {\n    LOCAL_SET_GL_ERROR(GL_INVALID_VALUE, function_name, \"invalid flags\");\n    return 0;\n  }\n  return api()->glFenceSyncFn(condition, flags);\n}\n", "target": 0, "idx": 153996}
{"func": "void Textfield::SetColor(SkColor value) {\n  GetRenderText()->SetColor(value);\n  cursor_view_.layer()->SetColor(value);\n  SchedulePaint();\n}\n", "target": 0, "idx": 137283}
{"func": "static void CompressClusterFit(const size_t count,\n  const DDSVector4 *points, const ssize_t *map, const DDSVector3 principle,\n  const DDSVector4 metric, DDSVector3 *start, DDSVector3 *end,\n  unsigned char *indices)\n{\n  DDSVector3\n    axis;\n\n  DDSVector4\n    grid,\n    gridrcp,\n    half,\n    onethird_onethird2,\n    pointsWeights[16],\n    two,\n    twonineths,\n    twothirds_twothirds2,\n    xSumwSum;\n\n  float\n    bestError = 1e+37f;\n\n  size_t\n    bestIteration = 0,\n    besti = 0,\n    bestj = 0,\n    bestk = 0,\n    iterationIndex;\n\n  ssize_t\n    i;\n\n  unsigned char\n    *o,\n    order[128],\n    unordered[16];\n\n  VectorInit(half,0.5f);\n  VectorInit(two,2.0f);\n\n  VectorInit(onethird_onethird2,1.0f/3.0f);\n  onethird_onethird2.w = 1.0f/9.0f;\n  VectorInit(twothirds_twothirds2,2.0f/3.0f);\n  twothirds_twothirds2.w = 4.0f/9.0f;\n  VectorInit(twonineths,2.0f/9.0f);\n\n  grid.x = 31.0f;\n  grid.y = 63.0f;\n  grid.z = 31.0f;\n  grid.w = 0.0f;\n\n  gridrcp.x = 1.0f/31.0f;\n  gridrcp.y = 1.0f/63.0f;\n  gridrcp.z = 1.0f/31.0f;\n  gridrcp.w = 0.0f;\n\n  xSumwSum.x = 0.0f;\n  xSumwSum.y = 0.0f;\n  xSumwSum.z = 0.0f;\n  xSumwSum.w = 0.0f;\n\n  ConstructOrdering(count,points,principle,pointsWeights,&xSumwSum,order,0);\n\n  for (iterationIndex = 0;;)\n  {\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(dynamic,1) \\\n    num_threads(GetMagickResourceLimit(ThreadResource))\n#endif\n    for (i=0; i < (ssize_t) count; i++)\n    {\n      DDSVector4\n        part0,\n        part1,\n        part2;\n\n      size_t\n        ii,\n        j,\n        k,\n        kmin;\n\n      VectorInit(part0,0.0f);\n      for(ii=0; ii < (size_t) i; ii++)\n        VectorAdd(pointsWeights[ii],part0,&part0);\n\n      VectorInit(part1,0.0f);\n      for (j=(size_t) i;;)\n      {\n        if (j == 0)\n          {\n            VectorCopy44(pointsWeights[0],&part2);\n            kmin = 1;\n          }\n          else\n          {\n            VectorInit(part2,0.0f);\n            kmin = j;\n          }\n\n        for (k=kmin;;)\n        {\n          DDSVector4\n            a,\n            alpha2_sum,\n            alphax_sum,\n            alphabeta_sum,\n            b,\n            beta2_sum,\n            betax_sum,\n            e1,\n            e2,\n            factor,\n            part3;\n\n          float\n            error;\n\n          VectorSubtract(xSumwSum,part2,&part3);\n          VectorSubtract(part3,part1,&part3);\n          VectorSubtract(part3,part0,&part3);\n\n          VectorMultiplyAdd(part1,twothirds_twothirds2,part0,&alphax_sum);\n          VectorMultiplyAdd(part2,onethird_onethird2,alphax_sum,&alphax_sum);\n          VectorInit(alpha2_sum,alphax_sum.w);\n\n          VectorMultiplyAdd(part2,twothirds_twothirds2,part3,&betax_sum);\n          VectorMultiplyAdd(part1,onethird_onethird2,betax_sum,&betax_sum);\n          VectorInit(beta2_sum,betax_sum.w);\n\n          VectorAdd(part1,part2,&alphabeta_sum);\n          VectorInit(alphabeta_sum,alphabeta_sum.w);\n          VectorMultiply(twonineths,alphabeta_sum,&alphabeta_sum);\n\n          VectorMultiply(alpha2_sum,beta2_sum,&factor);\n          VectorNegativeMultiplySubtract(alphabeta_sum,alphabeta_sum,factor,\n            &factor);\n          VectorReciprocal(factor,&factor);\n\n          VectorMultiply(alphax_sum,beta2_sum,&a);\n          VectorNegativeMultiplySubtract(betax_sum,alphabeta_sum,a,&a);\n          VectorMultiply(a,factor,&a);\n\n          VectorMultiply(betax_sum,alpha2_sum,&b);\n          VectorNegativeMultiplySubtract(alphax_sum,alphabeta_sum,b,&b);\n          VectorMultiply(b,factor,&b);\n\n          VectorClamp(&a);\n          VectorMultiplyAdd(grid,a,half,&a);\n          VectorTruncate(&a);\n          VectorMultiply(a,gridrcp,&a);\n\n          VectorClamp(&b);\n          VectorMultiplyAdd(grid,b,half,&b);\n          VectorTruncate(&b);\n          VectorMultiply(b,gridrcp,&b);\n\n          VectorMultiply(b,b,&e1);\n          VectorMultiply(e1,beta2_sum,&e1);\n          VectorMultiply(a,a,&e2);\n          VectorMultiplyAdd(e2,alpha2_sum,e1,&e1);\n\n          VectorMultiply(a,b,&e2);\n          VectorMultiply(e2,alphabeta_sum,&e2);\n          VectorNegativeMultiplySubtract(a,alphax_sum,e2,&e2);\n          VectorNegativeMultiplySubtract(b,betax_sum,e2,&e2);\n          VectorMultiplyAdd(two,e2,e1,&e2);\n          VectorMultiply(e2,metric,&e2);\n\n          error = e2.x + e2.y + e2.z;\n\n          if (error < bestError)\n            {\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n              #pragma omp critical (DDS_CompressClusterFit)\n#endif\n              {\n                if (error < bestError)\n                  {\n                    VectorCopy43(a,start);\n                    VectorCopy43(b,end);\n                    bestError = error;\n                    besti = i;\n                    bestj = j;\n                    bestk = k;\n                    bestIteration = iterationIndex;\n                  }\n              }\n            }\n\n          if (k == count)\n            break;\n\n          VectorAdd(pointsWeights[k],part2,&part2);\n          k++;\n        }\n\n        if (j == count)\n          break;\n\n        VectorAdd(pointsWeights[j],part1,&part1);\n        j++;\n      }\n    }\n\n    if (bestIteration != iterationIndex)\n      break;\n\n    iterationIndex++;\n    if (iterationIndex == 8)\n      break;\n\n    VectorSubtract3(*end,*start,&axis);\n    if (ConstructOrdering(count,points,axis,pointsWeights,&xSumwSum,order,\n      iterationIndex) == MagickFalse)\n      break;\n  }\n\n  o = order + (16*bestIteration);\n\n  for (i=0; i < (ssize_t) besti; i++)\n    unordered[o[i]] = 0;\n  for (i=besti; i < (ssize_t) bestj; i++)\n    unordered[o[i]] = 2;\n  for (i=bestj; i < (ssize_t) bestk; i++)\n    unordered[o[i]] = 3;\n  for (i=bestk; i < (ssize_t) count; i++)\n    unordered[o[i]] = 1;\n\n  RemapIndices(map,unordered,indices);\n}\n", "target": 0, "idx": 65095}
{"func": "static int xts_decrypt(struct blkcipher_desc *desc, struct scatterlist *dst,\n\t\t       struct scatterlist *src, unsigned int nbytes)\n{\n\tstruct twofish_xts_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);\n\n\treturn glue_xts_crypt_128bit(&twofish_dec_xts, desc, dst, src, nbytes,\n\t\t\t\t     XTS_TWEAK_CAST(twofish_enc_blk),\n\t\t\t\t     &ctx->tweak_ctx, &ctx->crypt_ctx);\n}\n", "target": 0, "idx": 47075}
{"func": "struct import_t* MACH0_(get_imports)(struct MACH0_(obj_t)* bin) {\n\tstruct import_t *imports;\n \tint i, j, idx, stridx;\n \tconst char *symstr;\n \n\tif (!bin->symtab || !bin->symstr || !bin->sects || !bin->indirectsyms)\n \t\treturn NULL;\n \tif (bin->dysymtab.nundefsym < 1 || bin->dysymtab.nundefsym > 0xfffff) {\n \t\treturn NULL;\n \t}\n\tif (!(imports = malloc ((bin->dysymtab.nundefsym + 1) * sizeof (struct import_t)))) {\n\t\treturn NULL;\n\t}\n\tfor (i = j = 0; i < bin->dysymtab.nundefsym; i++) {\n\t\tidx = bin->dysymtab.iundefsym + i;\n\t\tif (idx < 0 || idx >= bin->nsymtab) {\n\t\t\tbprintf (\"WARNING: Imports index out of bounds. Ignoring relocs\\n\");\n\t\t\tfree (imports);\n\t\t\treturn NULL;\n\t\t}\n\t\tstridx = bin->symtab[idx].n_strx;\n\t\tif (stridx >= 0 && stridx < bin->symstrlen) {\n\t\t\tsymstr = (char *)bin->symstr + stridx;\n\t\t} else {\n\t\t\tsymstr = \"\";\n\t\t}\n\t\tif (!*symstr) {\n\t\t\tcontinue;\n\t\t}\n\t\t{\n\t\t\tint i = 0;\n\t\t\tint len = 0;\n\t\t\tchar *symstr_dup = NULL;\n\t\t\tlen = bin->symstrlen - stridx;\n\t\t\timports[j].name[0] = 0;\n\t\t\tif (len > 0) {\n\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\tif ((unsigned char)symstr[i] == 0xff || !symstr[i]) {\n\t\t\t\t\t\tlen = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsymstr_dup = r_str_ndup (symstr, len);\n\t\t\t\tif (symstr_dup) {\n\t\t\t\t\tr_str_ncpy (imports[j].name, symstr_dup, R_BIN_MACH0_STRING_LENGTH);\n\t\t\t\t\tr_str_filter (imports[j].name, - 1);\n\t\t\t\t\timports[j].name[R_BIN_MACH0_STRING_LENGTH - 2] = 0;\n\t\t\t\t\tfree (symstr_dup);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\timports[j].ord = i;\n\t\timports[j++].last = 0;\n\t}\n\timports[j].last = 1;\n\n\tif (!bin->imports_by_ord_size) {\n\t\tif (j > 0) {\n\t\t\tbin->imports_by_ord_size = j;\n\t\t\tbin->imports_by_ord = (RBinImport**)calloc (j, sizeof (RBinImport*));\n\t\t} else {\n\t\t\tbin->imports_by_ord_size = 0;\n\t\t\tbin->imports_by_ord = NULL;\n\t\t}\n\t}\n\n\treturn imports;\n}\n", "target": 1, "idx": 182397}
{"func": "static int32_t NPN_IntFromIdentifier(NPIdentifier identifier)\n{\n    return static_cast<IdentifierRep*>(identifier)->number();\n}\n", "target": 0, "idx": 99496}
{"func": "scoped_refptr<NGLayoutResult> NGFlexLayoutAlgorithm::Layout() {\n  DCHECK(!NeedMinMaxSize(ConstraintSpace(), Style()))\n      << \"Don't support that yet\";\n\n  borders_ = ComputeBorders(ConstraintSpace(), Style());\n  padding_ = ComputePadding(ConstraintSpace(), Style());\n  border_box_size_ = CalculateBorderBoxSize(ConstraintSpace(), Node());\n  border_scrollbar_padding_ =\n      CalculateBorderScrollbarPadding(ConstraintSpace(), Node());\n  content_box_size_ =\n      ShrinkAvailableSize(border_box_size_, border_scrollbar_padding_);\n\n  const LayoutUnit line_break_length = MainAxisContentExtent(LayoutUnit::Max());\n  FlexLayoutAlgorithm algorithm(&Style(), line_break_length);\n  bool is_column = Style().IsColumnFlexDirection();\n  bool is_horizontal_flow = algorithm.IsHorizontalFlow();\n\n  for (NGLayoutInputNode generic_child = Node().FirstChild(); generic_child;\n       generic_child = generic_child.NextSibling()) {\n    NGBlockNode child = ToNGBlockNode(generic_child);\n    if (child.IsOutOfFlowPositioned())\n      continue;\n\n    const ComputedStyle& child_style = child.Style();\n    NGConstraintSpaceBuilder space_builder(ConstraintSpace(),\n                                           child_style.GetWritingMode(),\n                                           /* is_new_fc */ true);\n    SetOrthogonalFallbackInlineSizeIfNeeded(Style(), child, &space_builder);\n\n    NGConstraintSpace child_space =\n        space_builder.SetAvailableSize(content_box_size_)\n            .SetPercentageResolutionSize(content_box_size_)\n            .ToConstraintSpace();\n\n    NGBoxStrut border_padding_in_child_writing_mode =\n        ComputeBorders(child_space, child_style) +\n        ComputePadding(child_space, child_style);\n    NGPhysicalBoxStrut physical_border_padding(\n        border_padding_in_child_writing_mode.ConvertToPhysical(\n            child_style.GetWritingMode(), child_style.Direction()));\n    LayoutUnit main_axis_border_and_padding =\n        is_horizontal_flow ? physical_border_padding.HorizontalSum()\n                           : physical_border_padding.VerticalSum();\n\n    MinMaxSizeInput zero_input;\n    MinMaxSize min_max_sizes_border_box = child.ComputeMinMaxSize(\n        ConstraintSpace().GetWritingMode(), zero_input, &child_space);\n    scoped_refptr<NGLayoutResult> layout_result =\n        child.Layout(child_space, nullptr /*break token*/);\n    NGFragment fragment_in_child_writing_mode(\n        child_style.GetWritingMode(), *layout_result->PhysicalFragment());\n\n    LayoutUnit flex_base_border_box;\n    Length length_in_main_axis =\n        is_horizontal_flow ? child_style.Width() : child_style.Height();\n    if (child_style.FlexBasis().IsAuto() && length_in_main_axis.IsAuto()) {\n      if (MainAxisIsInlineAxis(child))\n        flex_base_border_box = min_max_sizes_border_box.max_size;\n      else\n        flex_base_border_box = fragment_in_child_writing_mode.BlockSize();\n    } else {\n      Length length_to_resolve = child_style.FlexBasis();\n      if (length_to_resolve.IsAuto())\n        length_to_resolve = length_in_main_axis;\n      DCHECK(!length_to_resolve.IsAuto());\n\n      if (MainAxisIsInlineAxis(child)) {\n        flex_base_border_box = ResolveInlineLength(\n            child_space, child_style, min_max_sizes_border_box,\n            length_to_resolve, LengthResolveType::kContentSize,\n            LengthResolvePhase::kLayout);\n      } else {\n        flex_base_border_box = ResolveBlockLength(\n            child_space, child_style, length_to_resolve,\n            fragment_in_child_writing_mode.BlockSize(),\n            LengthResolveType::kContentSize, LengthResolvePhase::kLayout);\n      }\n    }\n\n    LayoutUnit flex_base_content_size =\n        flex_base_border_box - main_axis_border_and_padding;\n\n    NGPhysicalBoxStrut physical_child_margins =\n        ComputePhysicalMargins(child_space, child_style);\n    LayoutUnit main_axis_margin = is_horizontal_flow\n                                      ? physical_child_margins.HorizontalSum()\n                                      : physical_child_margins.VerticalSum();\n\n    MinMaxSize min_max_sizes_in_main_axis_direction{LayoutUnit(),\n                                                    LayoutUnit::Max()};\n    algorithm\n        .emplace_back(child.GetLayoutBox(), flex_base_content_size,\n                      min_max_sizes_in_main_axis_direction,\n                      main_axis_border_and_padding, main_axis_margin)\n        .ng_input_node = child;\n  }\n\n  LayoutUnit main_axis_offset = border_scrollbar_padding_.inline_start;\n  LayoutUnit cross_axis_offset = border_scrollbar_padding_.block_start;\n  if (is_column) {\n    main_axis_offset = border_scrollbar_padding_.block_start;\n    cross_axis_offset = border_scrollbar_padding_.inline_start;\n  }\n  FlexLine* line;\n  LayoutUnit max_main_axis_extent;\n  while ((line = algorithm.ComputeNextFlexLine(border_box_size_.inline_size))) {\n    line->SetContainerMainInnerSize(\n        MainAxisContentExtent(line->sum_hypothetical_main_size));\n    line->FreezeInflexibleItems();\n    while (!line->ResolveFlexibleLengths()) {\n      continue;\n    }\n    for (wtf_size_t i = 0; i < line->line_items.size(); ++i) {\n       FlexItem& flex_item = line->line_items[i];\n \n       WritingMode child_writing_mode =\n          flex_item.box->StyleRef().GetWritingMode();\n       NGConstraintSpaceBuilder space_builder(ConstraintSpace(),\n                                              child_writing_mode,\n                                              /* is_new_fc */ true);\n      SetOrthogonalFallbackInlineSizeIfNeeded(Style(), flex_item.ng_input_node,\n                                              &space_builder);\n\n      NGLogicalSize available_size;\n      if (is_column) {\n        available_size.inline_size = content_box_size_.inline_size;\n        available_size.block_size = flex_item.flexed_content_size +\n                                    flex_item.main_axis_border_and_padding;\n        space_builder.SetIsFixedSizeBlock(true);\n      } else {\n        available_size.inline_size = flex_item.flexed_content_size +\n                                     flex_item.main_axis_border_and_padding;\n        available_size.block_size = content_box_size_.block_size;\n        space_builder.SetIsFixedSizeInline(true);\n      }\n      space_builder.SetAvailableSize(available_size);\n       space_builder.SetPercentageResolutionSize(content_box_size_);\n       NGConstraintSpace child_space = space_builder.ToConstraintSpace();\n       flex_item.layout_result =\n          ToNGBlockNode(flex_item.ng_input_node)\n              .Layout(child_space, nullptr /*break token*/);\n       flex_item.cross_axis_size =\n           is_horizontal_flow\n               ? flex_item.layout_result->PhysicalFragment()->Size().height\n              : flex_item.layout_result->PhysicalFragment()->Size().width;\n      flex_item.cross_axis_intrinsic_size = flex_item.cross_axis_size;\n    }\n    line->ComputeLineItemsPosition(main_axis_offset, cross_axis_offset);\n    max_main_axis_extent =\n        std::max(max_main_axis_extent, line->main_axis_extent);\n  }\n  LayoutUnit intrinsic_block_content_size = cross_axis_offset;\n  if (is_column)\n    intrinsic_block_content_size = max_main_axis_extent;\n  LayoutUnit intrinsic_block_size =\n      intrinsic_block_content_size + border_scrollbar_padding_.BlockSum();\n  LayoutUnit block_size = ComputeBlockSizeForFragment(\n      ConstraintSpace(), Style(), intrinsic_block_size);\n\n  LayoutUnit final_content_cross_size =\n      block_size - border_scrollbar_padding_.BlockSum();\n  if (is_column) {\n    final_content_cross_size =\n        border_box_size_.inline_size - border_scrollbar_padding_.InlineSum();\n  }\n  if (!algorithm.IsMultiline() && !algorithm.FlexLines().IsEmpty())\n    algorithm.FlexLines()[0].cross_axis_extent = final_content_cross_size;\n\n  for (FlexLine& line_context : algorithm.FlexLines()) {\n    for (wtf_size_t child_number = 0;\n         child_number < line_context.line_items.size(); ++child_number) {\n      FlexItem& flex_item = line_context.line_items[child_number];\n      if (flex_item.Alignment() == ItemPosition::kStretch) {\n         flex_item.ComputeStretchedSize();\n \n         WritingMode child_writing_mode =\n            flex_item.box->StyleRef().GetWritingMode();\n         NGConstraintSpaceBuilder space_builder(ConstraintSpace(),\n                                                child_writing_mode,\n                                                /* is_new_fc */ true);\n        SetOrthogonalFallbackInlineSizeIfNeeded(\n            Style(), flex_item.ng_input_node, &space_builder);\n\n        NGLogicalSize available_size(flex_item.flexed_content_size +\n                                         flex_item.main_axis_border_and_padding,\n                                     flex_item.cross_axis_size);\n        if (is_column)\n          available_size.Flip();\n        space_builder.SetAvailableSize(available_size);\n        space_builder.SetPercentageResolutionSize(content_box_size_);\n         space_builder.SetIsFixedSizeInline(true);\n         space_builder.SetIsFixedSizeBlock(true);\n         NGConstraintSpace child_space = space_builder.ToConstraintSpace();\n        flex_item.layout_result =\n            ToNGBlockNode(flex_item.ng_input_node)\n                .Layout(child_space, /* break_token */ nullptr);\n       }\n       container_builder_.AddChild(\n           *flex_item.layout_result,\n          {flex_item.desired_location.X(), flex_item.desired_location.Y()});\n    }\n  }\n\n  container_builder_.SetBlockSize(block_size);\n  container_builder_.SetInlineSize(border_box_size_.inline_size);\n  container_builder_.SetBorders(ComputeBorders(ConstraintSpace(), Style()));\n  container_builder_.SetPadding(ComputePadding(ConstraintSpace(), Style()));\n  return container_builder_.ToBoxFragment();\n}\n", "target": 1, "idx": 186055}
{"func": "int TabStripModel::GetIndexOfTabContents(\n    const TabContentsWrapper* contents) const {\n  int index = 0;\n  TabContentsDataVector::const_iterator iter = contents_data_.begin();\n  for (; iter != contents_data_.end(); ++iter, ++index) {\n    if ((*iter)->contents == contents)\n      return index;\n  }\n  return kNoTab;\n}\n", "target": 0, "idx": 102965}
{"func": "static int midi_setup_channel_pressure(struct _mdi *mdi, uint8_t channel,\n                                       uint8_t pressure) {\n    MIDI_EVENT_DEBUG(__FUNCTION__,channel, pressure);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_channel_pressure;\n    mdi->events[mdi->event_count].event_data.channel = channel;\n    mdi->events[mdi->event_count].event_data.data.value = pressure;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}\n", "target": 0, "idx": 63273}
{"func": "static void die(const char *fmt, ...) {\n    va_list ap;\n    va_start(ap, fmt);\n    vprintf(fmt, ap);\n    if(fmt[strlen(fmt)-1] != '\\n')\n        printf(\"\\n\");\n    exit(EXIT_FAILURE);\n}\n", "target": 1, "idx": 188517}
{"func": "void HTMLMediaElement::SourceWasRemoved(HTMLSourceElement* source) {\n  BLINK_MEDIA_LOG << \"sourceWasRemoved(\" << (void*)this << \", \" << source\n                  << \")\";\n\n  KURL url = source->GetNonEmptyURLAttribute(kSrcAttr);\n  BLINK_MEDIA_LOG << \"sourceWasRemoved(\" << (void*)this << \") - 'src' is \"\n                  << UrlForLoggingMedia(url);\n\n  if (source != current_source_node_ && source != next_child_node_to_consider_)\n    return;\n\n  if (source == next_child_node_to_consider_) {\n    if (current_source_node_)\n      next_child_node_to_consider_ = current_source_node_->nextSibling();\n    BLINK_MEDIA_LOG << \"sourceWasRemoved(\" << (void*)this\n                    << \") - next_child_node_to_consider_ set to \"\n                    << next_child_node_to_consider_.Get();\n  } else if (source == current_source_node_) {\n    current_source_node_ = nullptr;\n    BLINK_MEDIA_LOG << \"SourceWasRemoved(\" << (void*)this\n                    << \") - current_source_node_ set to 0\";\n  }\n}\n", "target": 0, "idx": 142915}
{"func": "qedi_dbg_notice(struct qedi_dbg_ctx *qedi, const char *func, u32 line,\n\t\tconst char *fmt, ...)\n {\n \tva_list va;\n \tstruct va_format vaf;\n\tchar nfunc[32];\n\tmemset(nfunc, 0, sizeof(nfunc));\n\tmemcpy(nfunc, func, sizeof(nfunc) - 1);\n \n \tva_start(va, fmt);\n \n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\n\tif (!(qedi_dbg_log & QEDI_LOG_NOTICE))\n\t\tgoto ret;\n \n \tif (likely(qedi) && likely(qedi->pdev))\n \t\tpr_notice(\"[%s]:[%s:%d]:%d: %pV\",\n\t\t\t  dev_name(&qedi->pdev->dev), nfunc, line,\n \t\t\t  qedi->host_no, &vaf);\n \telse\n\t\tpr_notice(\"[0000:00:00.0]:[%s:%d]: %pV\", nfunc, line, &vaf);\n \n ret:\n \tva_end(va);\n}\n", "target": 1, "idx": 182732}
{"func": "   void RunMemCheck() {\n     ACMRandom rnd(ACMRandom::DeterministicSeed());\n     const int count_test_block = 5000;\n    DECLARE_ALIGNED_ARRAY(16, int16_t, input_block, kNumCoeffs);\n    DECLARE_ALIGNED_ARRAY(16, int16_t, input_extreme_block, kNumCoeffs);\n    DECLARE_ALIGNED_ARRAY(16, int16_t, output_ref_block, kNumCoeffs);\n    DECLARE_ALIGNED_ARRAY(16, int16_t, output_block, kNumCoeffs);\n \n     for (int i = 0; i < count_test_block; ++i) {\n       for (int j = 0; j < kNumCoeffs; ++j) {\n        input_block[j] = rnd.Rand8() - rnd.Rand8();\n        input_extreme_block[j] = rnd.Rand8() % 2 ? 255 : -255;\n       }\n      if (i == 0)\n         for (int j = 0; j < kNumCoeffs; ++j)\n          input_extreme_block[j] = 255;\n      if (i == 1)\n         for (int j = 0; j < kNumCoeffs; ++j)\n          input_extreme_block[j] = -255;\n \n       fwd_txfm_ref(input_extreme_block, output_ref_block, pitch_, tx_type_);\n      REGISTER_STATE_CHECK(RunFwdTxfm(input_extreme_block,\n                                      output_block, pitch_));\n \n       for (int j = 0; j < kNumCoeffs; ++j) {\n         EXPECT_EQ(output_block[j], output_ref_block[j]);\n        EXPECT_GE(4 * DCT_MAX_VALUE, abs(output_block[j]))\n            << \"Error: 16x16 FDCT has coefficient larger than 4*DCT_MAX_VALUE\";\n       }\n     }\n   }\n", "target": 1, "idx": 188576}
{"func": "void Document::InitContentSecurityPolicy(\n    ContentSecurityPolicy* csp,\n    const ContentSecurityPolicy* policy_to_inherit,\n    const ContentSecurityPolicy* previous_document_csp) {\n   SetContentSecurityPolicy(csp ? csp : ContentSecurityPolicy::Create());\n \n   GetContentSecurityPolicy()->BindToExecutionContext(this);\n \n  if (policy_to_inherit) {\n     GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);\n  } else {\n    if (frame_) {\n       Frame* inherit_from = frame_->Tree().Parent()\n                                 ? frame_->Tree().Parent()\n                                 : frame_->Client()->Opener();\n       if (inherit_from && frame_ != inherit_from) {\n         DCHECK(inherit_from->GetSecurityContext() &&\n                inherit_from->GetSecurityContext()->GetContentSecurityPolicy());\n        policy_to_inherit =\n            inherit_from->GetSecurityContext()->GetContentSecurityPolicy();\n       }\n     }\n    if (!policy_to_inherit)\n      policy_to_inherit = previous_document_csp;\n    if (policy_to_inherit &&\n        (url_.IsEmpty() || url_.ProtocolIsAbout() || url_.ProtocolIsData() ||\n         url_.ProtocolIs(\"blob\") || url_.ProtocolIs(\"filesystem\")))\n      GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);\n  }\n  if (policy_to_inherit && IsPluginDocument())\n    GetContentSecurityPolicy()->CopyPluginTypesFrom(policy_to_inherit);\n }\n", "target": 1, "idx": 187036}
{"func": "static void br_multicast_group_expired(unsigned long data)\n{\n\tstruct net_bridge_mdb_entry *mp = (void *)data;\n\tstruct net_bridge *br = mp->br;\n\tstruct net_bridge_mdb_htable *mdb;\n\n\tspin_lock(&br->multicast_lock);\n\tif (!netif_running(br->dev) || timer_pending(&mp->timer))\n\t\tgoto out;\n\n\tif (!hlist_unhashed(&mp->mglist))\n\t\thlist_del_init(&mp->mglist);\n\n\tif (mp->ports)\n\t\tgoto out;\n\n\tmdb = mlock_dereference(br->mdb, br);\n\n\thlist_del_rcu(&mp->hlist[mdb->ver]);\n\tmdb->size--;\n\n\tdel_timer(&mp->query_timer);\n\tcall_rcu_bh(&mp->rcu, br_multicast_free_group);\n\nout:\n\tspin_unlock(&br->multicast_lock);\n}\n", "target": 0, "idx": 27817}
{"func": "bool GLES2DecoderImpl::ClearLevel(\n    unsigned service_id,\n    unsigned bind_target,\n    unsigned target,\n    int level,\n    unsigned format,\n    unsigned type,\n    int width,\n    int height,\n    bool is_texture_immutable) {\n  uint32 channels = GLES2Util::GetChannelsForFormat(format);\n  if (IsAngle() && (channels & GLES2Util::kDepth) != 0) {\n    GLuint fb = 0;\n    glGenFramebuffersEXT(1, &fb);\n    glBindFramebufferEXT(GL_DRAW_FRAMEBUFFER_EXT, fb);\n\n    bool have_stencil = (channels & GLES2Util::kStencil) != 0;\n    GLenum attachment = have_stencil ? GL_DEPTH_STENCIL_ATTACHMENT :\n                                       GL_DEPTH_ATTACHMENT;\n\n    glFramebufferTexture2DEXT(\n        GL_DRAW_FRAMEBUFFER_EXT, attachment, target, service_id, level);\n    if (glCheckFramebufferStatusEXT(GL_DRAW_FRAMEBUFFER_EXT) !=\n        GL_FRAMEBUFFER_COMPLETE) {\n      return false;\n    }\n    glClearStencil(0);\n    glStencilMask(-1);\n    glClearDepth(1.0f);\n    glDepthMask(true);\n    glDisable(GL_SCISSOR_TEST);\n    glClear(GL_DEPTH_BUFFER_BIT | (have_stencil ? GL_STENCIL_BUFFER_BIT : 0));\n\n    RestoreClearState();\n\n    glDeleteFramebuffersEXT(1, &fb);\n    FramebufferManager::FramebufferInfo* framebuffer =\n        GetFramebufferInfoForTarget(GL_DRAW_FRAMEBUFFER_EXT);\n    GLuint fb_service_id =\n        framebuffer ? framebuffer->service_id() : GetBackbufferServiceId();\n    glBindFramebufferEXT(GL_DRAW_FRAMEBUFFER_EXT, fb_service_id);\n    return true;\n  }\n\n  static const uint32 kMaxZeroSize = 1024 * 1024 * 4;\n\n  uint32 size;\n  uint32 padded_row_size;\n  if (!GLES2Util::ComputeImageDataSizes(\n          width, height, format, type, unpack_alignment_, &size,\n          NULL, &padded_row_size)) {\n    return false;\n  }\n\n  TRACE_EVENT1(\"gpu\", \"GLES2DecoderImpl::ClearLevel\", \"size\", size);\n\n  int tile_height;\n\n  if (size > kMaxZeroSize) {\n    if (kMaxZeroSize < padded_row_size) {\n        return false;\n    }\n    DCHECK_GT(padded_row_size, 0U);\n    tile_height = kMaxZeroSize / padded_row_size;\n    if (!GLES2Util::ComputeImageDataSizes(\n            width, tile_height, format, type, unpack_alignment_, &size, NULL,\n            NULL)) {\n      return false;\n    }\n  } else {\n    tile_height = height;\n  }\n\n  scoped_array<char> zero(new char[size]);\n  memset(zero.get(), 0, size);\n  glBindTexture(bind_target, service_id);\n\n  GLint y = 0;\n  while (y < height) {\n    GLint h = y + tile_height > height ? height - y : tile_height;\n    if (is_texture_immutable || h != height) {\n      glTexSubImage2D(target, level, 0, y, width, h, format, type, zero.get());\n    } else {\n      WrappedTexImage2D(\n          target, level, format, width, h, 0, format, type, zero.get());\n    }\n    y += tile_height;\n  }\n  TextureManager::TextureInfo* info = GetTextureInfoForTarget(bind_target);\n  glBindTexture(bind_target, info ? info->service_id() : 0);\n  return true;\n}\n", "target": 0, "idx": 110436}
{"func": "SharedQuadState* CreateSharedQuadState(RenderPass* render_pass) {\n  gfx::Transform quad_transform = gfx::Transform(1.0, 0.0, 0.5, 1.0, 0.5, 0.0);\n  gfx::Size content_bounds(26, 28);\n  gfx::Rect visible_content_rect(10, 12, 14, 16);\n  gfx::Rect clip_rect(19, 21, 23, 25);\n  bool is_clipped = false;\n  float opacity = 1.f;\n  int sorting_context_id = 65536;\n  SkXfermode::Mode blend_mode = SkXfermode::kSrcOver_Mode;\n\n  SharedQuadState* state = render_pass->CreateAndAppendSharedQuadState();\n  state->SetAll(quad_transform,\n                content_bounds,\n                visible_content_rect,\n                clip_rect,\n                is_clipped,\n                opacity,\n                blend_mode,\n                sorting_context_id);\n  return state;\n}\n", "target": 0, "idx": 132895}
{"func": "void Gfx::opShFill(Object args[], int numArgs) {\n  GfxShading *shading;\n  GfxPath *savedPath;\n  double xMin, yMin, xMax, yMax;\n\n  if (!(shading = res->lookupShading(args[0].getName(), this))) {\n    return;\n  }\n\n  savedPath = state->getPath()->copy();\n  saveState();\n\n  if (shading->getHasBBox()) {\n    shading->getBBox(&xMin, &yMin, &xMax, &yMax);\n    state->moveTo(xMin, yMin);\n    state->lineTo(xMax, yMin);\n    state->lineTo(xMax, yMax);\n    state->lineTo(xMin, yMax);\n    state->closePath();\n    state->clip();\n    out->clip(state);\n    state->clearPath();\n  }\n\n  state->setFillColorSpace(shading->getColorSpace()->copy());\n  out->updateFillColorSpace(state);\n\n#if 1 //~tmp: turn off anti-aliasing temporarily\n  GBool vaa = out->getVectorAntialias();\n  if (vaa) {\n    out->setVectorAntialias(gFalse);\n  }\n#endif\n\n  switch (shading->getType()) {\n  case 1:\n    doFunctionShFill((GfxFunctionShading *)shading);\n    break;\n  case 2:\n    doAxialShFill((GfxAxialShading *)shading);\n    break;\n  case 3:\n    doRadialShFill((GfxRadialShading *)shading);\n    break;\n  case 4:\n  case 5:\n    doGouraudTriangleShFill((GfxGouraudTriangleShading *)shading);\n    break;\n  case 6:\n  case 7:\n    doPatchMeshShFill((GfxPatchMeshShading *)shading);\n    break;\n  }\n\n#if 1 //~tmp: turn off anti-aliasing temporarily\n  if (vaa) {\n    out->setVectorAntialias(gTrue);\n  }\n#endif\n\n  restoreState();\n  state->setPath(savedPath);\n\n  delete shading;\n}\n", "target": 0, "idx": 8167}
{"func": "static unsigned writeSignature(ucvector* out)\n{\n  /*8 bytes PNG signature, aka the magic bytes*/\n  if (!ucvector_push_back(out, 137)) return 83;\n  if (!ucvector_push_back(out, 80)) return 83;\n  if (!ucvector_push_back(out, 78)) return 83;\n  if (!ucvector_push_back(out, 71)) return 83;\n  if (!ucvector_push_back(out, 13)) return 83;\n  if (!ucvector_push_back(out, 10)) return 83;\n  if (!ucvector_push_back(out, 26)) return 83;\n  if (!ucvector_push_back(out, 10)) return 83;\n\n  return 0;\n}\n", "target": 0, "idx": 87618}
{"func": "void ath_tx_aggr_sleep(struct ieee80211_sta *sta, struct ath_softc *sc,\n\t\t       struct ath_node *an)\n{\n\tstruct ath_atx_tid *tid;\n\tstruct ath_atx_ac *ac;\n\tstruct ath_txq *txq;\n\tbool buffered;\n\tint tidno;\n\n \tfor (tidno = 0, tid = &an->tid[tidno];\n \t     tidno < IEEE80211_NUM_TIDS; tidno++, tid++) {\n \n\t\tif (!tid->sched)\n\t\t\tcontinue;\n \t\tac = tid->ac;\n \t\ttxq = ac->txq;\n \n \t\tath_txq_lock(sc, txq);\n \n \t\tbuffered = ath_tid_has_buffered(tid);\n \n \t\ttid->sched = false;\n\t\tlist_del(&tid->list);\n\n\t\tif (ac->sched) {\n\t\t\tac->sched = false;\n\t\t\tlist_del(&ac->list);\n\t\t}\n\n\t\tath_txq_unlock(sc, txq);\n\n\t\tieee80211_sta_set_buffered(sta, tidno, buffered);\n\t}\n}\n", "target": 1, "idx": 179567}
{"func": "FileTransfer::AddDownloadFilenameRemap(char const *source_name,char const *target_name) {\n\tif(!download_filename_remaps.IsEmpty()) {\n\t\tdownload_filename_remaps += \";\";\n\t}\n\tdownload_filename_remaps += source_name;\n\tdownload_filename_remaps += \"=\";\n\tdownload_filename_remaps += target_name;\n}\n", "target": 0, "idx": 16560}
{"func": "void PlatformSensorProviderLinux::FreeResources() {\n  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n  DCHECK(file_task_runner_);\n  Shutdown();\n  file_task_runner_->PostTask(\n      FROM_HERE, base::Bind(&PlatformSensorProviderLinux::StopPollingThread,\n                            base::Unretained(this)));\n}\n", "target": 0, "idx": 161798}
{"func": "static ssize_t ReadBlobBlock(Image *image,unsigned char *data)\n{\n  ssize_t\n    count;\n\n  unsigned char\n    block_count;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(data != (unsigned char *) NULL);\n  count=ReadBlob(image,1,&block_count);\n  if (count != 1)\n    return(0);\n  count=ReadBlob(image,(size_t) block_count,data);\n  if (count != (ssize_t) block_count)\n    return(0);\n  return(count);\n}\n", "target": 0, "idx": 71557}
{"func": "bgp_capabilities_print(netdissect_options *ndo,\n                       const u_char *opt, int caps_len)\n{\n\tint cap_type, cap_len, tcap_len, cap_offset;\n        int i = 0;\n\n        while (i < caps_len) {\n                ND_TCHECK2(opt[i], BGP_CAP_HEADER_SIZE);\n                cap_type=opt[i];\n                cap_len=opt[i+1];\n                tcap_len=cap_len;\n                ND_PRINT((ndo, \"\\n\\t      %s (%u), length: %u\",\n                       tok2str(bgp_capcode_values, \"Unknown\",\n                                  cap_type),\n                       cap_type,\n                       cap_len));\n                ND_TCHECK2(opt[i+2], cap_len);\n                switch (cap_type) {\n                case BGP_CAPCODE_MP:\n                    ND_PRINT((ndo, \"\\n\\t\\tAFI %s (%u), SAFI %s (%u)\",\n                           tok2str(af_values, \"Unknown\",\n                                      EXTRACT_16BITS(opt+i+2)),\n                           EXTRACT_16BITS(opt+i+2),\n                           tok2str(bgp_safi_values, \"Unknown\",\n                                      opt[i+5]),\n                           opt[i+5]));\n                    break;\n                case BGP_CAPCODE_RESTART:\n                    ND_PRINT((ndo, \"\\n\\t\\tRestart Flags: [%s], Restart Time %us\",\n                           ((opt[i+2])&0x80) ? \"R\" : \"none\",\n                           EXTRACT_16BITS(opt+i+2)&0xfff));\n                    tcap_len-=2;\n                    cap_offset=4;\n                    while(tcap_len>=4) {\n                        ND_PRINT((ndo, \"\\n\\t\\t  AFI %s (%u), SAFI %s (%u), Forwarding state preserved: %s\",\n                               tok2str(af_values,\"Unknown\",\n                                          EXTRACT_16BITS(opt+i+cap_offset)),\n                               EXTRACT_16BITS(opt+i+cap_offset),\n                               tok2str(bgp_safi_values,\"Unknown\",\n                                          opt[i+cap_offset+2]),\n                               opt[i+cap_offset+2],\n                               ((opt[i+cap_offset+3])&0x80) ? \"yes\" : \"no\" ));\n                        tcap_len-=4;\n                        cap_offset+=4;\n                    }\n                    break;\n                case BGP_CAPCODE_RR:\n                case BGP_CAPCODE_RR_CISCO:\n                    break;\n                case BGP_CAPCODE_AS_NEW:\n\n                    /*\n                     * Extract the 4 byte AS number encoded.\n                     */\n                    if (cap_len == 4) {\n                        ND_PRINT((ndo, \"\\n\\t\\t 4 Byte AS %s\",\n                            as_printf(ndo, astostr, sizeof(astostr),\n                            EXTRACT_32BITS(opt + i + 2))));\n                    }\n                    break;\n                case BGP_CAPCODE_ADD_PATH:\n                    cap_offset=2;\n                    if (tcap_len == 0) {\n                        ND_PRINT((ndo, \" (bogus)\")); /* length */\n                        break;\n                    }\n                    while (tcap_len > 0) {\n                        if (tcap_len < 4) {\n                            ND_PRINT((ndo, \"\\n\\t\\t(invalid)\"));\n                            break;\n                        }\n                        ND_PRINT((ndo, \"\\n\\t\\tAFI %s (%u), SAFI %s (%u), Send/Receive: %s\",\n                                  tok2str(af_values,\"Unknown\",EXTRACT_16BITS(opt+i+cap_offset)),\n                                  EXTRACT_16BITS(opt+i+cap_offset),\n                                  tok2str(bgp_safi_values,\"Unknown\",opt[i+cap_offset+2]),\n                                  opt[i+cap_offset+2],\n                                  tok2str(bgp_add_path_recvsend,\"Bogus (0x%02x)\",opt[i+cap_offset+3])\n                        ));\n                        tcap_len-=4;\n                        cap_offset+=4;\n                    }\n                    break;\n                default:\n                    ND_PRINT((ndo, \"\\n\\t\\tno decoder for Capability %u\",\n                           cap_type));\n                    if (ndo->ndo_vflag <= 1)\n                        print_unknown_data(ndo, &opt[i+2], \"\\n\\t\\t\", cap_len);\n                    break;\n                }\n                if (ndo->ndo_vflag > 1 && cap_len > 0) {\n                    print_unknown_data(ndo, &opt[i+2], \"\\n\\t\\t\", cap_len);\n                }\n                i += BGP_CAP_HEADER_SIZE + cap_len;\n        }\n        return;\n\ntrunc:\n\tND_PRINT((ndo, \"[|BGP]\"));\n}\n", "target": 0, "idx": 62245}
{"func": "static int tty_open(struct inode *inode, struct file *filp)\n{\n\tstruct tty_struct *tty = NULL;\n\tint noctty, retval;\n\tstruct tty_driver *driver;\n\tint index;\n\tdev_t device = inode->i_rdev;\n\tunsigned saved_flags = filp->f_flags;\n\n\tnonseekable_open(inode, filp);\n\nretry_open:\n\tnoctty = filp->f_flags & O_NOCTTY;\n\tindex  = -1;\n\tretval = 0;\n\n\tmutex_lock(&tty_mutex);\n\ttty_lock();\n\n\tif (device == MKDEV(TTYAUX_MAJOR, 0)) {\n\t\ttty = get_current_tty();\n\t\tif (!tty) {\n\t\t\ttty_unlock();\n\t\t\tmutex_unlock(&tty_mutex);\n\t\t\treturn -ENXIO;\n\t\t}\n\t\tdriver = tty_driver_kref_get(tty->driver);\n\t\tindex = tty->index;\n\t\tfilp->f_flags |= O_NONBLOCK; /* Don't let /dev/tty block */\n\t\t/* noctty = 1; */\n\t\t/* FIXME: Should we take a driver reference ? */\n\t\ttty_kref_put(tty);\n\t\tgoto got_driver;\n\t}\n#ifdef CONFIG_VT\n\tif (device == MKDEV(TTY_MAJOR, 0)) {\n\t\textern struct tty_driver *console_driver;\n\t\tdriver = tty_driver_kref_get(console_driver);\n\t\tindex = fg_console;\n\t\tnoctty = 1;\n\t\tgoto got_driver;\n\t}\n#endif\n\tif (device == MKDEV(TTYAUX_MAJOR, 1)) {\n\t\tstruct tty_driver *console_driver = console_device(&index);\n\t\tif (console_driver) {\n\t\t\tdriver = tty_driver_kref_get(console_driver);\n\t\t\tif (driver) {\n\t\t\t\t/* Don't let /dev/console block */\n\t\t\t\tfilp->f_flags |= O_NONBLOCK;\n\t\t\t\tnoctty = 1;\n\t\t\t\tgoto got_driver;\n\t\t\t}\n\t\t}\n\t\ttty_unlock();\n\t\tmutex_unlock(&tty_mutex);\n\t\treturn -ENODEV;\n\t}\n\n\tdriver = get_tty_driver(device, &index);\n\tif (!driver) {\n\t\ttty_unlock();\n\t\tmutex_unlock(&tty_mutex);\n\t\treturn -ENODEV;\n\t}\ngot_driver:\n\tif (!tty) {\n\t\t/* check whether we're reopening an existing tty */\n\t\ttty = tty_driver_lookup_tty(driver, inode, index);\n\n \t\tif (IS_ERR(tty)) {\n \t\t\ttty_unlock();\n \t\t\tmutex_unlock(&tty_mutex);\n \t\t\treturn PTR_ERR(tty);\n \t\t}\n \t}\n\n\tif (tty) {\n\t\tretval = tty_reopen(tty);\n\t\tif (retval)\n\t\t\ttty = ERR_PTR(retval);\n\t} else\n\t\ttty = tty_init_dev(driver, index, 0);\n\n\tmutex_unlock(&tty_mutex);\n\ttty_driver_kref_put(driver);\n\tif (IS_ERR(tty)) {\n\t\ttty_unlock();\n\t\treturn PTR_ERR(tty);\n\t}\n\n\tretval = tty_add_file(tty, filp);\n\tif (retval) {\n\t\ttty_unlock();\n\t\ttty_release(inode, filp);\n\t\treturn retval;\n\t}\n\n\tcheck_tty_count(tty, \"tty_open\");\n\tif (tty->driver->type == TTY_DRIVER_TYPE_PTY &&\n\t    tty->driver->subtype == PTY_TYPE_MASTER)\n\t\tnoctty = 1;\n#ifdef TTY_DEBUG_HANGUP\n\tprintk(KERN_DEBUG \"opening %s...\", tty->name);\n#endif\n\tif (tty->ops->open)\n\t\tretval = tty->ops->open(tty, filp);\n\telse\n\t\tretval = -ENODEV;\n\tfilp->f_flags = saved_flags;\n\n\tif (!retval && test_bit(TTY_EXCLUSIVE, &tty->flags) &&\n\t\t\t\t\t\t!capable(CAP_SYS_ADMIN))\n\t\tretval = -EBUSY;\n\n\tif (retval) {\n#ifdef TTY_DEBUG_HANGUP\n\t\tprintk(KERN_DEBUG \"error %d in opening %s...\", retval,\n\t\t       tty->name);\n#endif\n\t\ttty_unlock(); /* need to call tty_release without BTM */\n\t\ttty_release(inode, filp);\n\t\tif (retval != -ERESTARTSYS)\n\t\t\treturn retval;\n\n\t\tif (signal_pending(current))\n\t\t\treturn retval;\n\n\t\tschedule();\n\t\t/*\n\t\t * Need to reset f_op in case a hangup happened.\n\t\t */\n\t\ttty_lock();\n\t\tif (filp->f_op == &hung_up_tty_fops)\n\t\t\tfilp->f_op = &tty_fops;\n\t\ttty_unlock();\n\t\tgoto retry_open;\n\t}\n\ttty_unlock();\n\n\n\tmutex_lock(&tty_mutex);\n\ttty_lock();\n\tspin_lock_irq(&current->sighand->siglock);\n\tif (!noctty &&\n\t    current->signal->leader &&\n\t    !current->signal->tty &&\n\t    tty->session == NULL)\n\t\t__proc_set_tty(current, tty);\n\tspin_unlock_irq(&current->sighand->siglock);\n\ttty_unlock();\n\tmutex_unlock(&tty_mutex);\n\treturn 0;\n}\n", "target": 1, "idx": 180788}
{"func": "  sfnt_init_face( FT_Stream      stream,\n                  TT_Face        face,\n                  FT_Int         face_instance_index,\n                  FT_Int         num_params,\n                  FT_Parameter*  params )\n  {\n    FT_Error      error;\n    FT_Memory     memory = face->root.memory;\n    FT_Library    library = face->root.driver->root.library;\n    SFNT_Service  sfnt;\n    FT_Int        face_index;\n\n\n    /* for now, parameters are unused */\n    FT_UNUSED( num_params );\n    FT_UNUSED( params );\n\n\n    sfnt = (SFNT_Service)face->sfnt;\n    if ( !sfnt )\n    {\n      sfnt = (SFNT_Service)FT_Get_Module_Interface( library, \"sfnt\" );\n      if ( !sfnt )\n      {\n        FT_ERROR(( \"sfnt_init_face: cannot access `sfnt' module\\n\" ));\n        return FT_THROW( Missing_Module );\n      }\n\n      face->sfnt       = sfnt;\n      face->goto_table = sfnt->goto_table;\n    }\n\n    FT_FACE_FIND_GLOBAL_SERVICE( face, face->psnames, POSTSCRIPT_CMAPS );\n\n#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n    if ( !face->mm )\n    {\n      /* we want the MM interface from the `truetype' module only */\n      FT_Module  tt_module = FT_Get_Module( library, \"truetype\" );\n\n\n      face->mm = ft_module_get_service( tt_module,\n                                        FT_SERVICE_ID_MULTI_MASTERS,\n                                        0 );\n    }\n\n    if ( !face->var )\n    {\n      /* we want the metrics variations interface */\n      /* from the `truetype' module only          */\n      FT_Module  tt_module = FT_Get_Module( library, \"truetype\" );\n\n\n      face->var = ft_module_get_service( tt_module,\n                                         FT_SERVICE_ID_METRICS_VARIATIONS,\n                                         0 );\n    }\n#endif\n\n    FT_TRACE2(( \"SFNT driver\\n\" ));\n\n    error = sfnt_open_font( stream, face );\n    if ( error )\n      return error;\n\n    /* Stream may have changed in sfnt_open_font. */\n    stream = face->root.stream;\n\n    FT_TRACE2(( \"sfnt_init_face: %08p, %d\\n\", face, face_instance_index ));\n\n    face_index = FT_ABS( face_instance_index ) & 0xFFFF;\n\n    /* value -(N+1) requests information on index N */\n    if ( face_instance_index < 0 )\n      face_index--;\n\n    if ( face_index >= face->ttc_header.count )\n    {\n      if ( face_instance_index >= 0 )\n        return FT_THROW( Invalid_Argument );\n      else\n        face_index = 0;\n    }\n\n    if ( FT_STREAM_SEEK( face->ttc_header.offsets[face_index] ) )\n      return error;\n\n    /* check whether we have a valid TrueType file */\n    error = sfnt->load_font_dir( face, stream );\n    if ( error )\n      return error;\n\n#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n    {\n      FT_ULong  fvar_len;\n\n      FT_ULong  version;\n      FT_ULong  offset;\n\n      FT_UShort  num_axes;\n      FT_UShort  axis_size;\n      FT_UShort  num_instances;\n      FT_UShort  instance_size;\n\n      FT_Int  instance_index;\n\n      FT_Byte*  default_values  = NULL;\n      FT_Byte*  instance_values = NULL;\n\n\n      face->is_default_instance = 1;\n\n      instance_index = FT_ABS( face_instance_index ) >> 16;\n\n      /* test whether current face is a GX font with named instances */\n      if ( face->goto_table( face, TTAG_fvar, stream, &fvar_len ) ||\n           fvar_len < 20                                          ||\n           FT_READ_ULONG( version )                               ||\n           FT_READ_USHORT( offset )                               ||\n           FT_STREAM_SKIP( 2 ) /* reserved */                     ||\n           FT_READ_USHORT( num_axes )                             ||\n           FT_READ_USHORT( axis_size )                            ||\n           FT_READ_USHORT( num_instances )                        ||\n           FT_READ_USHORT( instance_size )                        )\n      {\n        version       = 0;\n        offset        = 0;\n        num_axes      = 0;\n        axis_size     = 0;\n        num_instances = 0;\n        instance_size = 0;\n      }\n\n      /* check that the data is bound by the table length */\n      if ( version != 0x00010000UL                    ||\n           axis_size != 20                            ||\n           num_axes == 0                              ||\n           /* `num_axes' limit implied by 16-bit `instance_size' */\n           num_axes > 0x3FFE                          ||\n           !( instance_size == 4 + 4 * num_axes ||\n              instance_size == 6 + 4 * num_axes )     ||\n           /* `num_instances' limit implied by limited range of name IDs */\n           num_instances > 0x7EFF                     ||\n           offset                          +\n             axis_size * num_axes          +\n             instance_size * num_instances > fvar_len )\n        num_instances = 0;\n      else\n        face->variation_support |= TT_FACE_FLAG_VAR_FVAR;\n\n      /*\n       *  As documented in the OpenType specification, an entry for the\n       *  default instance may be omitted in the named instance table.  In\n       *  particular this means that even if there is no named instance\n       *  table in the font we actually do have a named instance, namely the\n       *  default instance.\n       *\n       *  For consistency, we always want the default instance in our list\n       *  of named instances.  If it is missing, we try to synthesize it\n       *  later on.  Here, we have to adjust `num_instances' accordingly.\n       */\n\n      if ( !( FT_ALLOC( default_values, num_axes * 2 )  ||\n              FT_ALLOC( instance_values, num_axes * 2 ) ) )\n      {\n        /* the current stream position is 16 bytes after the table start */\n        FT_ULong  array_start = FT_STREAM_POS() - 16 + offset;\n        FT_ULong  default_value_offset, instance_offset;\n\n        FT_Byte*  p;\n        FT_UInt   i;\n\n\n        default_value_offset = array_start + 8;\n        p                    = default_values;\n\n        for ( i = 0; i < num_axes; i++ )\n        {\n          (void)FT_STREAM_READ_AT( default_value_offset, p, 2 );\n\n          default_value_offset += axis_size;\n          p                    += 2;\n        }\n\n        instance_offset = array_start + axis_size * num_axes + 4;\n\n        for ( i = 0; i < num_instances; i++ )\n        {\n          (void)FT_STREAM_READ_AT( instance_offset,\n                                   instance_values,\n                                   num_axes * 2 );\n\n          if ( !ft_memcmp( default_values, instance_values, num_axes * 2 ) )\n            break;\n\n          instance_offset += instance_size;\n        }\n\n        if ( i == num_instances )\n        {\n          /* no default instance in named instance table; */\n          /* we thus have to synthesize it                */\n          num_instances++;\n        }\n      }\n\n       FT_FREE( default_values );\n       FT_FREE( instance_values );\n \n      /* we don't support Multiple Master CFFs yet */\n       if ( face->goto_table( face, TTAG_glyf, stream, 0 ) &&\n            !face->goto_table( face, TTAG_CFF, stream, 0 ) )\n         num_instances = 0;\n      if ( instance_index > num_instances )\n      {\n        if ( face_instance_index >= 0 )\n          return FT_THROW( Invalid_Argument );\n        else\n          num_instances = 0;\n      }\n\n      face->root.style_flags = (FT_Long)num_instances << 16;\n    }\n#endif\n\n    face->root.num_faces  = face->ttc_header.count;\n    face->root.face_index = face_instance_index;\n\n    return error;\n  }\n", "target": 1, "idx": 178060}
{"func": "TIFFFdOpen(int fd, const char* name, const char* mode)\n{\n\tTIFF* tif;\n\n\ttif = TIFFClientOpen(name, mode,  ddd\n\t    (thandle_t) fd,\n\t    _tiffReadProc, _tiffWriteProc, _tiffSeekProc, _tiffCloseProc,\n\t    _tiffSizeProc, _tiffMapProc, _tiffUnmapProc);\n\tif (tif)\n\t\ttif->tif_fd = fd;\n\treturn (tif);\n}\n", "target": 0, "idx": 86780}
{"func": "doshn(struct magic_set *ms, int clazz, int swap, int fd, off_t off, int num,\n    size_t size, off_t fsize, int *flags, int mach, int strtab)\n{\n \tElf32_Shdr sh32;\n \tElf64_Shdr sh64;\n \tint stripped = 1;\n \tvoid *nbuf;\n \toff_t noff, coff, name_off;\n \tuint64_t cap_hw1 = 0;\t/* SunOS 5.x hardware capabilites */\n\tuint64_t cap_sf1 = 0;\t/* SunOS 5.x software capabilites */\n\tchar name[50];\n\n\tif (size != xsh_sizeof) {\n\t\tif (file_printf(ms, \", corrupted section header size\") == -1)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\n\t/* Read offset of name section to be able to read section names later */\n\tif (pread(fd, xsh_addr, xsh_sizeof, off + size * strtab) == -1) {\n\t\tfile_badread(ms);\n\t\treturn -1;\n\t}\n\tname_off = xsh_offset;\n\n\tfor ( ; num; num--) {\n\t\t/* Read the name of this section. */\n\t\tif (pread(fd, name, sizeof(name), name_off + xsh_name) == -1) {\n\t\t\tfile_badread(ms);\n\t\t\treturn -1;\n\t\t}\n\t\tname[sizeof(name) - 1] = '\\0';\n\t\tif (strcmp(name, \".debug_info\") == 0)\n\t\t\tstripped = 0;\n\n\t\tif (pread(fd, xsh_addr, xsh_sizeof, off) == -1) {\n\t\t\tfile_badread(ms);\n\t\t\treturn -1;\n\t\t}\n\t\toff += size;\n\n\t\t/* Things we can determine before we seek */\n\t\tswitch (xsh_type) {\n\t\tcase SHT_SYMTAB:\n#if 0\n\t\tcase SHT_DYNSYM:\n#endif\n\t\t\tstripped = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (xsh_offset > fsize) {\n\t\t\t\t/* Perhaps warn here */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Things we can determine when we seek */\n\t\tswitch (xsh_type) {\n\t\tcase SHT_NOTE:\n\t\t\tif ((nbuf = malloc(xsh_size)) == NULL) {\n\t\t\t\tfile_error(ms, errno, \"Cannot allocate memory\"\n\t\t\t\t    \" for note\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (pread(fd, nbuf, xsh_size, xsh_offset) == -1) {\n\t\t\t\tfile_badread(ms);\n\t\t\t\tfree(nbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tnoff = 0;\n\t\t\tfor (;;) {\n\t\t\t\tif (noff >= (off_t)xsh_size)\n\t\t\t\t\tbreak;\n\t\t\t\tnoff = donote(ms, nbuf, (size_t)noff,\n\t\t\t\t    xsh_size, clazz, swap, 4, flags);\n\t\t\t\tif (noff == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfree(nbuf);\n\t\t\tbreak;\n\t\tcase SHT_SUNW_cap:\n\t\t\tswitch (mach) {\n\t\t\tcase EM_SPARC:\n\t\t\tcase EM_SPARCV9:\n\t\t\tcase EM_IA_64:\n\t\t\tcase EM_386:\n\t\t\tcase EM_AMD64:\n\t\t\t\tbreak;\n\t\t\tdefault:\n \t\t\t\tgoto skip;\n \t\t\t}\n \n \t\t\tif (lseek(fd, xsh_offset, SEEK_SET) == (off_t)-1) {\n \t\t\t\tfile_badseek(ms);\n \t\t\t\treturn -1;\n\t\t\t}\n\t\t\tcoff = 0;\n\t\t\tfor (;;) {\n\t\t\t\tElf32_Cap cap32;\n\t\t\t\tElf64_Cap cap64;\n\t\t\t\tchar cbuf[/*CONSTCOND*/\n\t\t\t\t    MAX(sizeof cap32, sizeof cap64)];\n\t\t\t\tif ((coff += xcap_sizeof) > (off_t)xsh_size)\n\t\t\t\t\tbreak;\n\t\t\t\tif (read(fd, cbuf, (size_t)xcap_sizeof) !=\n\t\t\t\t    (ssize_t)xcap_sizeof) {\n\t\t\t\t\tfile_badread(ms);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (cbuf[0] == 'A') {\n#ifdef notyet\n\t\t\t\t\tchar *p = cbuf + 1;\n\t\t\t\t\tuint32_t len, tag;\n\t\t\t\t\tmemcpy(&len, p, sizeof(len));\n\t\t\t\t\tp += 4;\n\t\t\t\t\tlen = getu32(swap, len);\n\t\t\t\t\tif (memcmp(\"gnu\", p, 3) != 0) {\n\t\t\t\t\t    if (file_printf(ms,\n\t\t\t\t\t\t\", unknown capability %.3s\", p)\n\t\t\t\t\t\t== -1)\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t    break;\n\t\t\t\t\t}\n\t\t\t\t\tp += strlen(p) + 1;\n\t\t\t\t\ttag = *p++;\n\t\t\t\t\tmemcpy(&len, p, sizeof(len));\n\t\t\t\t\tp += 4;\n\t\t\t\t\tlen = getu32(swap, len);\n\t\t\t\t\tif (tag != 1) {\n\t\t\t\t\t    if (file_printf(ms, \", unknown gnu\"\n\t\t\t\t\t\t\" capability tag %d\", tag)\n\t\t\t\t\t\t== -1)\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t    break;\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t(void)memcpy(xcap_addr, cbuf, xcap_sizeof);\n\t\t\t\tswitch (xcap_tag) {\n\t\t\t\tcase CA_SUNW_NULL:\n\t\t\t\t\tbreak;\n\t\t\t\tcase CA_SUNW_HW_1:\n\t\t\t\t\tcap_hw1 |= xcap_val;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CA_SUNW_SF_1:\n\t\t\t\t\tcap_sf1 |= xcap_val;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (file_printf(ms,\n\t\t\t\t\t    \", with unknown capability \"\n\t\t\t\t\t    \"0x%\" INT64_T_FORMAT \"x = 0x%\"\n\t\t\t\t\t    INT64_T_FORMAT \"x\",\n \t\t\t\t\t    (unsigned long long)xcap_tag,\n \t\t\t\t\t    (unsigned long long)xcap_val) == -1)\n \t\t\t\t\t\treturn -1;\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t}\n\t\t\t/*FALLTHROUGH*/\n\t\tskip:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (file_printf(ms, \", %sstripped\", stripped ? \"\" : \"not \") == -1)\n\t\treturn -1;\n\tif (cap_hw1) {\n\t\tconst cap_desc_t *cdp;\n\t\tswitch (mach) {\n\t\tcase EM_SPARC:\n\t\tcase EM_SPARC32PLUS:\n\t\tcase EM_SPARCV9:\n\t\t\tcdp = cap_desc_sparc;\n\t\t\tbreak;\n\t\tcase EM_386:\n\t\tcase EM_IA_64:\n\t\tcase EM_AMD64:\n\t\t\tcdp = cap_desc_386;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcdp = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (file_printf(ms, \", uses\") == -1)\n\t\t\treturn -1;\n\t\tif (cdp) {\n\t\t\twhile (cdp->cd_name) {\n\t\t\t\tif (cap_hw1 & cdp->cd_mask) {\n\t\t\t\t\tif (file_printf(ms,\n\t\t\t\t\t    \" %s\", cdp->cd_name) == -1)\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\tcap_hw1 &= ~cdp->cd_mask;\n\t\t\t\t}\n\t\t\t\t++cdp;\n\t\t\t}\n\t\t\tif (cap_hw1)\n\t\t\t\tif (file_printf(ms,\n\t\t\t\t    \" unknown hardware capability 0x%\"\n\t\t\t\t    INT64_T_FORMAT \"x\",\n\t\t\t\t    (unsigned long long)cap_hw1) == -1)\n\t\t\t\t\treturn -1;\n\t\t} else {\n\t\t\tif (file_printf(ms,\n\t\t\t    \" hardware capability 0x%\" INT64_T_FORMAT \"x\",\n\t\t\t    (unsigned long long)cap_hw1) == -1)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\tif (cap_sf1) {\n\t\tif (cap_sf1 & SF1_SUNW_FPUSED) {\n\t\t\tif (file_printf(ms,\n\t\t\t    (cap_sf1 & SF1_SUNW_FPKNWN)\n\t\t\t    ? \", uses frame pointer\"\n\t\t\t    : \", not known to use frame pointer\") == -1)\n\t\t\t\treturn -1;\n\t\t}\n\t\tcap_sf1 &= ~SF1_SUNW_MASK;\n\t\tif (cap_sf1)\n\t\t\tif (file_printf(ms,\n\t\t\t    \", with unknown software capability 0x%\"\n\t\t\t    INT64_T_FORMAT \"x\",\n\t\t\t    (unsigned long long)cap_sf1) == -1)\n\t\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n", "target": 1, "idx": 179421}
{"func": " pimv1_print(netdissect_options *ndo,\n             register const u_char *bp, register u_int len)\n {\n\tregister const u_char *ep;\n \tregister u_char type;\n \n\tep = (const u_char *)ndo->ndo_snapend;\n\tif (bp >= ep)\n\t\treturn;\n \tND_TCHECK(bp[1]);\n \ttype = bp[1];\n \n\tND_PRINT((ndo, \" %s\", tok2str(pimv1_type_str, \"[type %u]\", type)));\n\tswitch (type) {\n\tcase PIMV1_TYPE_QUERY:\n\t\tif (ND_TTEST(bp[8])) {\n\t\t\tswitch (bp[8] >> 4) {\n\t\t\tcase 0:\n\t\t\t\tND_PRINT((ndo, \" Dense-mode\"));\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tND_PRINT((ndo, \" Sparse-mode\"));\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tND_PRINT((ndo, \" Sparse-Dense-mode\"));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tND_PRINT((ndo, \" mode-%d\", bp[8] >> 4));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ndo->ndo_vflag) {\n\t\t\tND_TCHECK2(bp[10],2);\n\t\t\tND_PRINT((ndo, \" (Hold-time \"));\n\t\t\tunsigned_relts_print(ndo, EXTRACT_16BITS(&bp[10]));\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t}\n\t\tbreak;\n\n\tcase PIMV1_TYPE_REGISTER:\n\t\tND_TCHECK2(bp[8], 20);\t\t\t/* ip header */\n\t\tND_PRINT((ndo, \" for %s > %s\", ipaddr_string(ndo, &bp[20]),\n\t\t    ipaddr_string(ndo, &bp[24])));\n\t\tbreak;\n\tcase PIMV1_TYPE_REGISTER_STOP:\n\t\tND_TCHECK2(bp[12], sizeof(struct in_addr));\n\t\tND_PRINT((ndo, \" for %s > %s\", ipaddr_string(ndo, &bp[8]),\n\t\t    ipaddr_string(ndo, &bp[12])));\n\t\tbreak;\n\tcase PIMV1_TYPE_RP_REACHABILITY:\n\t\tif (ndo->ndo_vflag) {\n\t\t\tND_TCHECK2(bp[22], 2);\n\t\t\tND_PRINT((ndo, \" group %s\", ipaddr_string(ndo, &bp[8])));\n\t\t\tif (EXTRACT_32BITS(&bp[12]) != 0xffffffff)\n\t\t\t\tND_PRINT((ndo, \"/%s\", ipaddr_string(ndo, &bp[12])));\n\t\t\tND_PRINT((ndo, \" RP %s hold \", ipaddr_string(ndo, &bp[16])));\n\t\t\tunsigned_relts_print(ndo, EXTRACT_16BITS(&bp[22]));\n\t\t}\n\t\tbreak;\n\tcase PIMV1_TYPE_ASSERT:\n\t\tND_TCHECK2(bp[16], sizeof(struct in_addr));\n\t\tND_PRINT((ndo, \" for %s > %s\", ipaddr_string(ndo, &bp[16]),\n\t\t    ipaddr_string(ndo, &bp[8])));\n\t\tif (EXTRACT_32BITS(&bp[12]) != 0xffffffff)\n\t\t\tND_PRINT((ndo, \"/%s\", ipaddr_string(ndo, &bp[12])));\n\t\tND_TCHECK2(bp[24], 4);\n\t\tND_PRINT((ndo, \" %s pref %d metric %d\",\n\t\t    (bp[20] & 0x80) ? \"RP-tree\" : \"SPT\",\n\t\tEXTRACT_32BITS(&bp[20]) & 0x7fffffff,\n\t\tEXTRACT_32BITS(&bp[24])));\n\t\tbreak;\n \tcase PIMV1_TYPE_JOIN_PRUNE:\n \tcase PIMV1_TYPE_GRAFT:\n \tcase PIMV1_TYPE_GRAFT_ACK:\n\t\tif (ndo->ndo_vflag)\n \t\t\tpimv1_join_prune_print(ndo, &bp[8], len - 8);\n \t\tbreak;\n \t}\n \tND_TCHECK(bp[4]);\n\tif ((bp[4] >> 4) != 1)\n\t\tND_PRINT((ndo, \" [v%d]\", bp[4] >> 4));\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \"[|pim]\"));\n\treturn;\n}\n", "target": 1, "idx": 181028}
{"func": "frag6_print(netdissect_options *ndo, register const u_char *bp, register const u_char *bp2)\n{\n\tregister const struct ip6_frag *dp;\n\tregister const struct ip6_hdr *ip6;\n\n \tdp = (const struct ip6_frag *)bp;\n \tip6 = (const struct ip6_hdr *)bp2;\n \n\tND_TCHECK(dp->ip6f_offlg);\n \n \tif (ndo->ndo_vflag) {\n \t\tND_PRINT((ndo, \"frag (0x%08x:%d|%ld)\",\n\t\t       EXTRACT_32BITS(&dp->ip6f_ident),\n\t\t       EXTRACT_16BITS(&dp->ip6f_offlg) & IP6F_OFF_MASK,\n\t\t       sizeof(struct ip6_hdr) + EXTRACT_16BITS(&ip6->ip6_plen) -\n\t\t\t       (long)(bp - bp2) - sizeof(struct ip6_frag)));\n\t} else {\n\t\tND_PRINT((ndo, \"frag (%d|%ld)\",\n\t\t       EXTRACT_16BITS(&dp->ip6f_offlg) & IP6F_OFF_MASK,\n\t\t       sizeof(struct ip6_hdr) + EXTRACT_16BITS(&ip6->ip6_plen) -\n\t\t\t       (long)(bp - bp2) - sizeof(struct ip6_frag)));\n\t}\n\n\t/* it is meaningless to decode non-first fragment */\n\tif ((EXTRACT_16BITS(&dp->ip6f_offlg) & IP6F_OFF_MASK) != 0)\n\t\treturn -1;\n\telse\n\t{\n\t\tND_PRINT((ndo, \" \"));\n\t\treturn sizeof(struct ip6_frag);\n\t}\ntrunc:\n\tND_PRINT((ndo, \"[|frag]\"));\n\treturn -1;\n}\n", "target": 1, "idx": 181024}
{"func": "timeval_to_jiffies(const struct timeval *value)\n{\n\tunsigned long sec = value->tv_sec;\n\tlong usec = value->tv_usec;\n\n\tif (sec >= MAX_SEC_IN_JIFFIES){\n\t\tsec = MAX_SEC_IN_JIFFIES;\n\t\tusec = 0;\n\t}\n\treturn (((u64)sec * SEC_CONVERSION) +\n\t\t(((u64)usec * USEC_CONVERSION + USEC_ROUND) >>\n\t\t (USEC_JIFFIE_SC - SEC_JIFFIE_SC))) >> SEC_JIFFIE_SC;\n}\n", "target": 0, "idx": 24727}
{"func": "static void anyAttributeAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)\n{\n    TestObjectPython* imp = V8TestObjectPython::toNative(info.Holder());\n    v8SetReturnValue(info, imp->anyAttribute().v8Value());\n}\n", "target": 0, "idx": 131212}
{"func": "void impeg2d_dec_pic_data_thread(dec_state_t *ps_dec)\n{\n    WORD32 i4_continue_decode;\n\n    WORD32 i4_cur_row, temp;\n    UWORD32 u4_bits_read;\n    WORD32 i4_dequeue_job;\n    IMPEG2D_ERROR_CODES_T e_error;\n\n    i4_cur_row = ps_dec->u2_mb_y + 1;\n\n    i4_continue_decode = 1;\n\n    i4_dequeue_job = 1;\n do\n {\n if(i4_cur_row > ps_dec->u2_num_vert_mb)\n {\n            i4_continue_decode = 0;\n break;\n }\n\n {\n if((ps_dec->i4_num_cores> 1) && (i4_dequeue_job))\n {\n job_t s_job;\n                IV_API_CALL_STATUS_T e_ret;\n                UWORD8 *pu1_buf;\n\n                e_ret = impeg2_jobq_dequeue(ps_dec->pv_jobq, &s_job, sizeof(s_job), 1, 1);\n if(e_ret != IV_SUCCESS)\n break;\n\n if(CMD_PROCESS == s_job.i4_cmd)\n {\n                    pu1_buf = ps_dec->pu1_inp_bits_buf + s_job.i4_bistream_ofst;\n                    impeg2d_bit_stream_init(&(ps_dec->s_bit_stream), pu1_buf,\n (ps_dec->u4_num_inp_bytes - s_job.i4_bistream_ofst) + 8);\n                    i4_cur_row      = s_job.i2_start_mb_y;\n                    ps_dec->i4_start_mb_y = s_job.i2_start_mb_y;\n                    ps_dec->i4_end_mb_y = s_job.i2_end_mb_y;\n                    ps_dec->u2_mb_x = 0;\n                    ps_dec->u2_mb_y = ps_dec->i4_start_mb_y;\n                    ps_dec->u2_num_mbs_left = (ps_dec->i4_end_mb_y - ps_dec->i4_start_mb_y) * ps_dec->u2_num_horiz_mb;\n\n }\n else\n {\n                    WORD32 start_row;\n                    WORD32 num_rows;\n                    start_row = s_job.i2_start_mb_y << 4;\n                    num_rows = MIN((s_job.i2_end_mb_y << 4), ps_dec->u2_vertical_size);\n                    num_rows -= start_row;\n                    impeg2d_format_convert(ps_dec, ps_dec->ps_disp_pic,\n                                        ps_dec->ps_disp_frm_buf,\n                                        start_row, num_rows);\n break;\n\n }\n\n }\n            e_error = impeg2d_dec_slice(ps_dec);\n\n if ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE != e_error)\n {\n                impeg2d_next_start_code(ps_dec);\n }\n }\n\n /* Detecting next slice start code */\n while(1)\n {\n            u4_bits_read = impeg2d_bit_stream_nxt(&ps_dec->s_bit_stream,START_CODE_LEN);\n\n             temp = u4_bits_read & 0xFF;\n             i4_continue_decode = (((u4_bits_read >> 8) == 0x01) && (temp) && (temp <= 0xAF));\n \n             if(i4_continue_decode)\n             {\n                 /* If the slice is from the same row, then continue decoding without dequeue */\n if((temp - 1) == i4_cur_row)\n {\n                    i4_dequeue_job = 0;\n break;\n }\n\n if(temp < ps_dec->i4_end_mb_y)\n {\n                    i4_cur_row = ps_dec->u2_mb_y;\n }\n else\n {\n                    i4_dequeue_job = 1;\n }\n break;\n\n }\n else\n break;\n }\n\n }while(i4_continue_decode);\n if(ps_dec->i4_num_cores > 1)\n {\n while(1)\n {\n job_t s_job;\n            IV_API_CALL_STATUS_T e_ret;\n\n            e_ret = impeg2_jobq_dequeue(ps_dec->pv_jobq, &s_job, sizeof(s_job), 1, 1);\n if(e_ret != IV_SUCCESS)\n break;\n if(CMD_FMTCONV == s_job.i4_cmd)\n {\n                WORD32 start_row;\n                WORD32 num_rows;\n                start_row = s_job.i2_start_mb_y << 4;\n                num_rows = MIN((s_job.i2_end_mb_y << 4), ps_dec->u2_vertical_size);\n                num_rows -= start_row;\n                impeg2d_format_convert(ps_dec, ps_dec->ps_disp_pic,\n                                    ps_dec->ps_disp_frm_buf,\n                                    start_row, num_rows);\n }\n }\n }\n else\n {\n if((NULL != ps_dec->ps_disp_pic) && ((0 == ps_dec->u4_share_disp_buf) || (IV_YUV_420P != ps_dec->i4_chromaFormat)))\n            impeg2d_format_convert(ps_dec, ps_dec->ps_disp_pic,\n                            ps_dec->ps_disp_frm_buf,\n 0, ps_dec->u2_vertical_size);\n }\n}\n", "target": 1, "idx": 187948}
{"func": "t_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct trace_array *tr = m->private;\n\tstruct tracer *t = v;\n\n\t(*pos)++;\n\n\tif (t)\n\t\tt = get_tracer_for_array(tr, t->next);\n\n\treturn t;\n}\n", "target": 0, "idx": 81356}
{"func": "static int oidc_discovery(request_rec *r, oidc_cfg *cfg) {\n\n\toidc_debug(r, \"enter\");\n\n\t/* obtain the URL we're currently accessing, to be stored in the state/session */\n\tchar *current_url = oidc_get_current_url(r);\n\tconst char *method = oidc_original_request_method(r, cfg, FALSE);\n\n\t/* generate CSRF token */\n\tchar *csrf = NULL;\n\tif (oidc_proto_generate_nonce(r, &csrf, 8) == FALSE)\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\n\tchar *path_scopes = oidc_dir_cfg_path_scope(r);\n\tchar *path_auth_request_params = oidc_dir_cfg_path_auth_request_params(r);\n\n\tchar *discover_url = oidc_cfg_dir_discover_url(r);\n\t/* see if there's an external discovery page configured */\n\tif (discover_url != NULL) {\n\n\t\t/* yes, assemble the parameters for external discovery */\n\t\tchar *url = apr_psprintf(r->pool, \"%s%s%s=%s&%s=%s&%s=%s&%s=%s\",\n\t\t\t\tdiscover_url,\n\t\t\t\tstrchr(discover_url, OIDC_CHAR_QUERY) != NULL ?\n\t\t\t\t\t\tOIDC_STR_AMP :\n\t\t\t\t\t\tOIDC_STR_QUERY,\n\t\t\t\t\t\tOIDC_DISC_RT_PARAM, oidc_util_escape_string(r, current_url),\n\t\t\t\t\t\tOIDC_DISC_RM_PARAM, method,\n\t\t\t\t\t\tOIDC_DISC_CB_PARAM,\n\t\t\t\t\t\toidc_util_escape_string(r, oidc_get_redirect_uri(r, cfg)),\n\t\t\t\t\t\tOIDC_CSRF_NAME, oidc_util_escape_string(r, csrf));\n\n\t\tif (path_scopes != NULL)\n\t\t\turl = apr_psprintf(r->pool, \"%s&%s=%s\", url, OIDC_DISC_SC_PARAM,\n\t\t\t\t\toidc_util_escape_string(r, path_scopes));\n\t\tif (path_auth_request_params != NULL)\n\t\t\turl = apr_psprintf(r->pool, \"%s&%s=%s\", url, OIDC_DISC_AR_PARAM,\n\t\t\t\t\toidc_util_escape_string(r, path_auth_request_params));\n\n\t\t/* log what we're about to do */\n\t\toidc_debug(r, \"redirecting to external discovery page: %s\", url);\n\n\t\t/* set CSRF cookie */\n\t\toidc_util_set_cookie(r, OIDC_CSRF_NAME, csrf, -1,\n\t\t\t\tcfg->cookie_same_site ?\n\t\t\t\t\t\tOIDC_COOKIE_EXT_SAME_SITE_STRICT :\n\t\t\t\t\t\tNULL);\n\n\t\t/* see if we need to preserve POST parameters through Javascript/HTML5 storage */\n\t\tif (oidc_post_preserve_javascript(r, url, NULL, NULL) == TRUE)\n\t\t\treturn DONE;\n\n\t\t/* do the actual redirect to an external discovery page */\n\t\toidc_util_hdr_out_location_set(r, url);\n\n\t\treturn HTTP_MOVED_TEMPORARILY;\n\t}\n\n\t/* get a list of all providers configured in the metadata directory */\n\tapr_array_header_t *arr = NULL;\n\tif (oidc_metadata_list(r, cfg, &arr) == FALSE)\n\t\treturn oidc_util_html_send_error(r, cfg->error_template,\n\t\t\t\t\"Configuration Error\",\n\t\t\t\t\"No configured providers found, contact your administrator\",\n\t\t\t\tHTTP_UNAUTHORIZED);\n\n\t/* assemble a where-are-you-from IDP discovery HTML page */\n\tconst char *s = \"\t\t\t<h3>Select your OpenID Connect Identity Provider</h3>\\n\";\n\n\t/* list all configured providers in there */\n\tint i;\n\tfor (i = 0; i < arr->nelts; i++) {\n\n\t\tconst char *issuer = ((const char**) arr->elts)[i];\n\n\t\tchar *href = apr_psprintf(r->pool,\n\t\t\t\t\"%s?%s=%s&amp;%s=%s&amp;%s=%s&amp;%s=%s\",\n\t\t\t\toidc_get_redirect_uri(r, cfg), OIDC_DISC_OP_PARAM,\n\t\t\t\toidc_util_escape_string(r, issuer),\n\t\t\t\tOIDC_DISC_RT_PARAM, oidc_util_escape_string(r, current_url),\n\t\t\t\tOIDC_DISC_RM_PARAM, method,\n\t\t\t\tOIDC_CSRF_NAME, csrf);\n\n\t\tif (path_scopes != NULL)\n\t\t\thref = apr_psprintf(r->pool, \"%s&amp;%s=%s\", href,\n\t\t\t\t\tOIDC_DISC_SC_PARAM, oidc_util_escape_string(r, path_scopes));\n\t\tif (path_auth_request_params != NULL)\n\t\t\thref = apr_psprintf(r->pool, \"%s&amp;%s=%s\", href,\n\t\t\t\t\tOIDC_DISC_AR_PARAM,\n\t\t\t\t\toidc_util_escape_string(r, path_auth_request_params));\n\n\t\tchar *display =\n\t\t\t\t(strstr(issuer, \"https://\") == NULL) ?\n\t\t\t\t\t\tapr_pstrdup(r->pool, issuer) :\n\t\t\t\t\t\tapr_pstrdup(r->pool, issuer + strlen(\"https://\"));\n\n\t\t/* strip port number */\n\t\t/* point back to the redirect_uri, where the selection is handled, with an IDP selection and return_to URL */\n\t\ts = apr_psprintf(r->pool, \"%s<p><a href=\\\"%s\\\">%s</a></p>\\n\", s, href,\n\t\t\t\tdisplay);\n\t}\n\n\t/* add an option to enter an account or issuer name for dynamic OP discovery */\n\ts = apr_psprintf(r->pool, \"%s<form method=\\\"get\\\" action=\\\"%s\\\">\\n\", s,\n\t\t\toidc_get_redirect_uri(r, cfg));\n\ts = apr_psprintf(r->pool,\n\t\t\t\"%s<p><input type=\\\"hidden\\\" name=\\\"%s\\\" value=\\\"%s\\\"><p>\\n\", s,\n\t\t\tOIDC_DISC_RT_PARAM, current_url);\n\ts = apr_psprintf(r->pool,\n\t\t\t\"%s<p><input type=\\\"hidden\\\" name=\\\"%s\\\" value=\\\"%s\\\"><p>\\n\", s,\n\t\t\tOIDC_DISC_RM_PARAM, method);\n\ts = apr_psprintf(r->pool,\n\t\t\t\"%s<p><input type=\\\"hidden\\\" name=\\\"%s\\\" value=\\\"%s\\\"><p>\\n\", s,\n\t\t\tOIDC_CSRF_NAME, csrf);\n\n\tif (path_scopes != NULL)\n\t\ts = apr_psprintf(r->pool,\n\t\t\t\t\"%s<p><input type=\\\"hidden\\\" name=\\\"%s\\\" value=\\\"%s\\\"><p>\\n\", s,\n\t\t\t\tOIDC_DISC_SC_PARAM, path_scopes);\n\tif (path_auth_request_params != NULL)\n\t\ts = apr_psprintf(r->pool,\n\t\t\t\t\"%s<p><input type=\\\"hidden\\\" name=\\\"%s\\\" value=\\\"%s\\\"><p>\\n\", s,\n\t\t\t\tOIDC_DISC_AR_PARAM, path_auth_request_params);\n\n\ts =\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"%s<p>Or enter your account name (eg. &quot;mike@seed.gluu.org&quot;, or an IDP identifier (eg. &quot;mitreid.org&quot;):</p>\\n\",\n\t\t\t\t\ts);\n\ts = apr_psprintf(r->pool,\n\t\t\t\"%s<p><input type=\\\"text\\\" name=\\\"%s\\\" value=\\\"%s\\\"></p>\\n\", s,\n\t\t\tOIDC_DISC_OP_PARAM, \"\");\n\ts = apr_psprintf(r->pool,\n\t\t\t\"%s<p><input type=\\\"submit\\\" value=\\\"Submit\\\"></p>\\n\", s);\n\ts = apr_psprintf(r->pool, \"%s</form>\\n\", s);\n\n\toidc_util_set_cookie(r, OIDC_CSRF_NAME, csrf, -1,\n\t\t\tcfg->cookie_same_site ? OIDC_COOKIE_EXT_SAME_SITE_STRICT : NULL);\n\n\tchar *javascript = NULL, *javascript_method = NULL;\n\tchar *html_head =\n\t\t\t\"<style type=\\\"text/css\\\">body {text-align: center}</style>\";\n\tif (oidc_post_preserve_javascript(r, NULL, &javascript,\n\t\t\t&javascript_method) == TRUE)\n\t\thtml_head = apr_psprintf(r->pool, \"%s%s\", html_head, javascript);\n\n\t/* now send the HTML contents to the user agent */\n\treturn oidc_util_html_send(r, \"OpenID Connect Provider Discovery\",\n\t\t\thtml_head, javascript_method, s, DONE);\n}\n", "target": 0, "idx": 87064}
{"func": "int udpv6_sendmsg(struct kiocb *iocb, struct sock *sk,\n\t\t  struct msghdr *msg, size_t len)\n{\n\tstruct ipv6_txoptions opt_space;\n\tstruct udp_sock *up = udp_sk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sockaddr_in6 *sin6 = (struct sockaddr_in6 *) msg->msg_name;\n\tstruct in6_addr *daddr, *final_p, final;\n\tstruct ipv6_txoptions *opt = NULL;\n\tstruct ip6_flowlabel *flowlabel = NULL;\n\tstruct flowi6 fl6;\n\tstruct dst_entry *dst;\n\tint addr_len = msg->msg_namelen;\n\tint ulen = len;\n\tint hlimit = -1;\n\tint tclass = -1;\n\tint dontfrag = -1;\n\tint corkreq = up->corkflag || msg->msg_flags&MSG_MORE;\n\tint err;\n\tint connected = 0;\n\tint is_udplite = IS_UDPLITE(sk);\n\tint (*getfrag)(void *, char *, int, int, int, struct sk_buff *);\n\n\t/* destination address check */\n\tif (sin6) {\n\t\tif (addr_len < offsetof(struct sockaddr, sa_data))\n\t\t\treturn -EINVAL;\n\n\t\tswitch (sin6->sin6_family) {\n\t\tcase AF_INET6:\n\t\t\tif (addr_len < SIN6_LEN_RFC2133)\n\t\t\t\treturn -EINVAL;\n\t\t\tdaddr = &sin6->sin6_addr;\n\t\t\tbreak;\n\t\tcase AF_INET:\n\t\t\tgoto do_udp_sendmsg;\n\t\tcase AF_UNSPEC:\n\t\t\tmsg->msg_name = sin6 = NULL;\n\t\t\tmsg->msg_namelen = addr_len = 0;\n\t\t\tdaddr = NULL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (!up->pending) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -EDESTADDRREQ;\n\t\tdaddr = &sk->sk_v6_daddr;\n\t} else\n\t\tdaddr = NULL;\n\n\tif (daddr) {\n\t\tif (ipv6_addr_v4mapped(daddr)) {\n\t\t\tstruct sockaddr_in sin;\n\t\t\tsin.sin_family = AF_INET;\n\t\t\tsin.sin_port = sin6 ? sin6->sin6_port : inet->inet_dport;\n\t\t\tsin.sin_addr.s_addr = daddr->s6_addr32[3];\n\t\t\tmsg->msg_name = &sin;\n\t\t\tmsg->msg_namelen = sizeof(sin);\ndo_udp_sendmsg:\n\t\t\tif (__ipv6_only_sock(sk))\n\t\t\t\treturn -ENETUNREACH;\n\t\t\treturn udp_sendmsg(iocb, sk, msg, len);\n\t\t}\n\t}\n\n\tif (up->pending == AF_INET)\n\t\treturn udp_sendmsg(iocb, sk, msg, len);\n\n\t/* Rough check on arithmetic overflow,\n\t   better check is made in ip6_append_data().\n\t   */\n\tif (len > INT_MAX - sizeof(struct udphdr))\n\t\treturn -EMSGSIZE;\n\n\tif (up->pending) {\n\t\t/*\n\t\t * There are pending frames.\n\t\t * The socket lock must be held while it's corked.\n\t\t */\n\t\tlock_sock(sk);\n\t\tif (likely(up->pending)) {\n\t\t\tif (unlikely(up->pending != AF_INET6)) {\n\t\t\t\trelease_sock(sk);\n\t\t\t\treturn -EAFNOSUPPORT;\n\t\t\t}\n\t\t\tdst = NULL;\n\t\t\tgoto do_append_data;\n\t\t}\n\t\trelease_sock(sk);\n\t}\n\tulen += sizeof(struct udphdr);\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\n\tif (sin6) {\n\t\tif (sin6->sin6_port == 0)\n\t\t\treturn -EINVAL;\n\n\t\tfl6.fl6_dport = sin6->sin6_port;\n\t\tdaddr = &sin6->sin6_addr;\n\n\t\tif (np->sndflow) {\n\t\t\tfl6.flowlabel = sin6->sin6_flowinfo&IPV6_FLOWINFO_MASK;\n\t\t\tif (fl6.flowlabel&IPV6_FLOWLABEL_MASK) {\n\t\t\t\tflowlabel = fl6_sock_lookup(sk, fl6.flowlabel);\n\t\t\t\tif (flowlabel == NULL)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tdaddr = &flowlabel->dst;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Otherwise it will be difficult to maintain\n\t\t * sk->sk_dst_cache.\n\t\t */\n\t\tif (sk->sk_state == TCP_ESTABLISHED &&\n\t\t    ipv6_addr_equal(daddr, &sk->sk_v6_daddr))\n\t\t\tdaddr = &sk->sk_v6_daddr;\n\n\t\tif (addr_len >= sizeof(struct sockaddr_in6) &&\n\t\t    sin6->sin6_scope_id &&\n\t\t    __ipv6_addr_needs_scope_id(__ipv6_addr_type(daddr)))\n\t\t\tfl6.flowi6_oif = sin6->sin6_scope_id;\n\t} else {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -EDESTADDRREQ;\n\n\t\tfl6.fl6_dport = inet->inet_dport;\n\t\tdaddr = &sk->sk_v6_daddr;\n\t\tfl6.flowlabel = np->flow_label;\n\t\tconnected = 1;\n\t}\n\n\tif (!fl6.flowi6_oif)\n\t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\n\tif (!fl6.flowi6_oif)\n\t\tfl6.flowi6_oif = np->sticky_pktinfo.ipi6_ifindex;\n\n\tfl6.flowi6_mark = sk->sk_mark;\n\n\tif (msg->msg_controllen) {\n\t\topt = &opt_space;\n\t\tmemset(opt, 0, sizeof(struct ipv6_txoptions));\n\t\topt->tot_len = sizeof(*opt);\n\n\t\terr = ip6_datagram_send_ctl(sock_net(sk), sk, msg, &fl6, opt,\n\t\t\t\t\t    &hlimit, &tclass, &dontfrag);\n\t\tif (err < 0) {\n\t\t\tfl6_sock_release(flowlabel);\n\t\t\treturn err;\n\t\t}\n\t\tif ((fl6.flowlabel&IPV6_FLOWLABEL_MASK) && !flowlabel) {\n\t\t\tflowlabel = fl6_sock_lookup(sk, fl6.flowlabel);\n\t\t\tif (flowlabel == NULL)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!(opt->opt_nflen|opt->opt_flen))\n\t\t\topt = NULL;\n\t\tconnected = 0;\n\t}\n\tif (opt == NULL)\n\t\topt = np->opt;\n\tif (flowlabel)\n\t\topt = fl6_merge_options(&opt_space, flowlabel, opt);\n\topt = ipv6_fixup_options(&opt_space, opt);\n\n\tfl6.flowi6_proto = sk->sk_protocol;\n\tif (!ipv6_addr_any(daddr))\n\t\tfl6.daddr = *daddr;\n\telse\n\t\tfl6.daddr.s6_addr[15] = 0x1; /* :: means loopback (BSD'ism) */\n\tif (ipv6_addr_any(&fl6.saddr) && !ipv6_addr_any(&np->saddr))\n\t\tfl6.saddr = np->saddr;\n\tfl6.fl6_sport = inet->inet_sport;\n\n\tfinal_p = fl6_update_dst(&fl6, opt, &final);\n\tif (final_p)\n\t\tconnected = 0;\n\n\tif (!fl6.flowi6_oif && ipv6_addr_is_multicast(&fl6.daddr)) {\n\t\tfl6.flowi6_oif = np->mcast_oif;\n\t\tconnected = 0;\n\t} else if (!fl6.flowi6_oif)\n\t\tfl6.flowi6_oif = np->ucast_oif;\n\n\tsecurity_sk_classify_flow(sk, flowi6_to_flowi(&fl6));\n\n\tdst = ip6_sk_dst_lookup_flow(sk, &fl6, final_p, true);\n\tif (IS_ERR(dst)) {\n\t\terr = PTR_ERR(dst);\n\t\tdst = NULL;\n\t\tgoto out;\n\t}\n\n\tif (hlimit < 0) {\n\t\tif (ipv6_addr_is_multicast(&fl6.daddr))\n\t\t\thlimit = np->mcast_hops;\n\t\telse\n\t\t\thlimit = np->hop_limit;\n\t\tif (hlimit < 0)\n\t\t\thlimit = ip6_dst_hoplimit(dst);\n\t}\n\n\tif (tclass < 0)\n\t\ttclass = np->tclass;\n\n\tif (msg->msg_flags&MSG_CONFIRM)\n\t\tgoto do_confirm;\nback_from_confirm:\n\n\tlock_sock(sk);\n\tif (unlikely(up->pending)) {\n\t\t/* The socket is already corked while preparing it. */\n\t\t/* ... which is an evident application bug. --ANK */\n\t\trelease_sock(sk);\n\n\t\tLIMIT_NETDEBUG(KERN_DEBUG \"udp cork app bug 2\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tup->pending = AF_INET6;\n\ndo_append_data:\n\tif (dontfrag < 0)\n\t\tdontfrag = np->dontfrag;\n\tup->len += ulen;\n\tgetfrag  =  is_udplite ?  udplite_getfrag : ip_generic_getfrag;\n\terr = ip6_append_data(sk, getfrag, msg->msg_iov, ulen,\n\t\tsizeof(struct udphdr), hlimit, tclass, opt, &fl6,\n\t\t(struct rt6_info*)dst,\n\t\tcorkreq ? msg->msg_flags|MSG_MORE : msg->msg_flags, dontfrag);\n\tif (err)\n\t\tudp_v6_flush_pending_frames(sk);\n\telse if (!corkreq)\n\t\terr = udp_v6_push_pending_frames(sk);\n\telse if (unlikely(skb_queue_empty(&sk->sk_write_queue)))\n\t\tup->pending = 0;\n\n\tif (dst) {\n\t\tif (connected) {\n\t\t\tip6_dst_store(sk, dst,\n\t\t\t\t      ipv6_addr_equal(&fl6.daddr, &sk->sk_v6_daddr) ?\n\t\t\t\t      &sk->sk_v6_daddr : NULL,\n#ifdef CONFIG_IPV6_SUBTREES\n\t\t\t\t      ipv6_addr_equal(&fl6.saddr, &np->saddr) ?\n\t\t\t\t      &np->saddr :\n#endif\n\t\t\t\t      NULL);\n\t\t} else {\n\t\t\tdst_release(dst);\n\t\t}\n\t\tdst = NULL;\n\t}\n\n\tif (err > 0)\n\t\terr = np->recverr ? net_xmit_errno(err) : 0;\n\trelease_sock(sk);\nout:\n\tdst_release(dst);\n\tfl6_sock_release(flowlabel);\n\tif (!err)\n\t\treturn len;\n\t/*\n\t * ENOBUFS = no kernel mem, SOCK_NOSPACE = no sndbuf space.  Reporting\n\t * ENOBUFS might not be good (it's not tunable per se), but otherwise\n\t * we don't have a good statistic (IpOutDiscards but it can be too many\n\t * things).  We could add another new stat but at least for now that\n\t * seems like overkill.\n\t */\n\tif (err == -ENOBUFS || test_bit(SOCK_NOSPACE, &sk->sk_socket->flags)) {\n\t\tUDP6_INC_STATS_USER(sock_net(sk),\n\t\t\t\tUDP_MIB_SNDBUFERRORS, is_udplite);\n\t}\n\treturn err;\n\ndo_confirm:\n\tdst_confirm(dst);\n\tif (!(msg->msg_flags&MSG_PROBE) || len)\n\t\tgoto back_from_confirm;\n\terr = 0;\n\tgoto out;\n}\n", "target": 0, "idx": 40225}
{"func": "w3m_exit(int i)\n{\n#ifdef USE_MIGEMO\n    init_migemo();\t\t/* close pipe to migemo */\n#endif\n    stopDownload();\n    deleteFiles();\n#ifdef USE_SSL\n    free_ssl_ctx();\n#endif\n    disconnectFTP();\n#ifdef USE_NNTP\n    disconnectNews();\n #endif\n #ifdef __MINGW32_VERSION\n     WSACleanup();\n #endif\n     exit(i);\n }\n", "target": 1, "idx": 182517}
{"func": "static void nested_vmx_abort(struct kvm_vcpu *vcpu, u32 indicator)\n{\n\t/* TODO: not to reset guest simply here. */\n\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\tpr_debug_ratelimited(\"kvm: nested vmx abort, indicator %d\\n\", indicator);\n}\n", "target": 0, "idx": 48072}
{"func": " void CoordinatorImpl::RequestGlobalMemoryDumpAndAppendToTrace(\n     MemoryDumpType dump_type,\n     MemoryDumpLevelOfDetail level_of_detail,\n     const RequestGlobalMemoryDumpAndAppendToTraceCallback& callback) {\n   auto adapter =\n       [](const RequestGlobalMemoryDumpAndAppendToTraceCallback& callback,\n         bool success, uint64_t dump_guid,\n         mojom::GlobalMemoryDumpPtr) { callback.Run(success, dump_guid); };\n\n  QueuedRequest::Args args(dump_type, level_of_detail, {},\n                           true /* add_to_trace */, base::kNullProcessId);\n  RequestGlobalMemoryDumpInternal(args, base::BindRepeating(adapter, callback));\n}\n", "target": 1, "idx": 186893}
{"func": " virtual void SetUp() {\n    video_ = new libvpx_test::WebMVideoSource(kVP9TestFile);\n    ASSERT_TRUE(video_ != NULL);\n\n     video_->Init();\n     video_->Begin();\n \n    vpx_codec_dec_cfg_t cfg = {0};\n     decoder_ = new libvpx_test::VP9Decoder(cfg, 0);\n     ASSERT_TRUE(decoder_ != NULL);\n   }\n", "target": 1, "idx": 188568}
{"func": "static ZIPARCHIVE_METHOD(unchangeArchive)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zip_unchange_archive(intern) != 0) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_TRUE;\n\t}\n}\n", "target": 0, "idx": 54415}
{"func": "static void ikev2_parent_inI2outR2_continue(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\t    struct pluto_crypto_req *r,\n\t\t\t\t\t    err_t ugh)\n{\n\tstruct dh_continuation *dh = (struct dh_continuation *)pcrc;\n\tstruct msg_digest *md = dh->md;\n\tstruct state *const st = md->st;\n\tstf_status e;\n\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\"ikev2 parent inI2outR2: calculating g^{xy}, sending R2\"));\n\n\tif (st == NULL) {\n\t\tloglog(RC_LOG_SERIOUS,\n\t\t       \"%s: Request was disconnected from state\",\n\t\t       __FUNCTION__);\n\t\tif (dh->md)\n\t\t\trelease_md(dh->md);\n\t\treturn;\n\t}\n\n\t/* XXX should check out ugh */\n\tpassert(ugh == NULL);\n\tpassert(cur_state == NULL);\n\tpassert(st != NULL);\n\n\tpassert(st->st_suspended_md == dh->md);\n\tset_suspended(st, NULL); /* no longer connected or suspended */\n\n\tset_cur_state(st);\n\n\tst->st_calculating = FALSE;\n\n\te = ikev2_parent_inI2outR2_tail(pcrc, r);\n\tif ( e > STF_FAIL) {\n\t\t/* we do not send a notify because we are the initiator that could be responding to an error notification */\n\t\tint v2_notify_num = e - STF_FAIL;\n\t\tDBG_log(\n\t\t\t\"ikev2_parent_inI2outR2_tail returned STF_FAIL with %s\",\n\t\t\tenum_name(&ikev2_notify_names, v2_notify_num));\n\t} else if ( e != STF_OK) {\n\t\tDBG_log(\"ikev2_parent_inI2outR2_tail returned %s\",\n\t\t\tenum_name(&stfstatus_name, e));\n\t}\n\n\tif (dh->md != NULL) {\n\t\tcomplete_v2_state_transition(&dh->md, e);\n\t\tif (dh->md)\n \t\t\trelease_md(dh->md);\n \t}\n \treset_globals();\n\tpassert(GLOBALS_ARE_RESET());\n }\n", "target": 1, "idx": 179643}
{"func": "    StateBase* handleError(Status errorStatus, const String& message, StateBase* state)\n    {\n        ASSERT(errorStatus != Success);\n        m_status = errorStatus;\n        m_errorMessage = message;\n        while (state) {\n            StateBase* tmp = state->nextState();\n            delete state;\n            state = tmp;\n        }\n        return new ErrorState;\n    }\n", "target": 0, "idx": 128951}
{"func": "void RenderBox::paintRootBoxFillLayers(const PaintInfo& paintInfo)\n{\n    if (paintInfo.skipRootBackground())\n        return;\n\n    RenderObject* rootBackgroundRenderer = rendererForRootBackground();\n\n    const FillLayer* bgLayer = rootBackgroundRenderer->style()->backgroundLayers();\n    Color bgColor = rootBackgroundRenderer->resolveColor(CSSPropertyBackgroundColor);\n\n    paintFillLayers(paintInfo, bgColor, bgLayer, view()->backgroundRect(this), BackgroundBleedNone, CompositeSourceOver, rootBackgroundRenderer);\n}\n", "target": 0, "idx": 124922}
{"func": "kadm5_modify_principal(void *server_handle,\n                       kadm5_principal_ent_t entry, long mask)\n{\n    int                     ret, ret2, i;\n    kadm5_policy_ent_rec    pol;\n    krb5_boolean            have_pol = FALSE;\n    krb5_db_entry           *kdb;\n    krb5_tl_data            *tl_data_orig;\n    osa_princ_ent_rec       adb;\n    kadm5_server_handle_t handle = server_handle;\n\n    CHECK_HANDLE(server_handle);\n \n     krb5_clear_error_message(handle->context);\n \n     if((mask & KADM5_PRINCIPAL) || (mask & KADM5_LAST_PWD_CHANGE) ||\n        (mask & KADM5_MOD_TIME) || (mask & KADM5_MOD_NAME) ||\n        (mask & KADM5_MKVNO) || (mask & KADM5_AUX_ATTRIBUTES) ||\n       (mask & KADM5_KEY_DATA) || (mask & KADM5_LAST_SUCCESS) ||\n       (mask & KADM5_LAST_FAILED))\n         return KADM5_BAD_MASK;\n     if((mask & ~ALL_PRINC_MASK))\n         return KADM5_BAD_MASK;\n     if((mask & KADM5_POLICY) && (mask & KADM5_POLICY_CLR))\n         return KADM5_BAD_MASK;\n    if(entry == (kadm5_principal_ent_t) NULL)\n        return EINVAL;\n     if (mask & KADM5_TL_DATA) {\n         tl_data_orig = entry->tl_data;\n         while (tl_data_orig) {\n            if (tl_data_orig->tl_data_type < 256)\n                return KADM5_BAD_TL_TYPE;\n            tl_data_orig = tl_data_orig->tl_data_next;\n        }\n    }\n\n    ret = kdb_get_entry(handle, entry->principal, &kdb, &adb);\n    if (ret)\n        return(ret);\n\n    /*\n     * This is pretty much the same as create ...\n     */\n\n    if ((mask & KADM5_POLICY)) {\n        ret = get_policy(handle, entry->policy, &pol, &have_pol);\n        if (ret)\n            goto done;\n\n        /* set us up to use the new policy */\n        adb.aux_attributes |= KADM5_POLICY;\n        if (adb.policy)\n            free(adb.policy);\n        adb.policy = strdup(entry->policy);\n    }\n    if (have_pol) {\n        /* set pw_max_life based on new policy */\n        if (pol.pw_max_life) {\n            ret = krb5_dbe_lookup_last_pwd_change(handle->context, kdb,\n                                                  &(kdb->pw_expiration));\n            if (ret)\n                goto done;\n            kdb->pw_expiration += pol.pw_max_life;\n        } else {\n            kdb->pw_expiration = 0;\n        }\n    }\n\n    if ((mask & KADM5_POLICY_CLR) && (adb.aux_attributes & KADM5_POLICY)) {\n        free(adb.policy);\n        adb.policy = NULL;\n        adb.aux_attributes &= ~KADM5_POLICY;\n        kdb->pw_expiration = 0;\n    }\n\n    if ((mask & KADM5_ATTRIBUTES))\n        kdb->attributes = entry->attributes;\n    if ((mask & KADM5_MAX_LIFE))\n        kdb->max_life = entry->max_life;\n    if ((mask & KADM5_PRINC_EXPIRE_TIME))\n        kdb->expiration = entry->princ_expire_time;\n    if (mask & KADM5_PW_EXPIRATION)\n        kdb->pw_expiration = entry->pw_expiration;\n    if (mask & KADM5_MAX_RLIFE)\n        kdb->max_renewable_life = entry->max_renewable_life;\n\n    if((mask & KADM5_KVNO)) {\n        for (i = 0; i < kdb->n_key_data; i++)\n            kdb->key_data[i].key_data_kvno = entry->kvno;\n    }\n\n    if (mask & KADM5_TL_DATA) {\n        krb5_tl_data *tl;\n\n        /* may have to change the version number of the API. Updates the list with the given tl_data rather than over-writting */\n\n        for (tl = entry->tl_data; tl;\n             tl = tl->tl_data_next)\n        {\n            ret = krb5_dbe_update_tl_data(handle->context, kdb, tl);\n            if( ret )\n            {\n                goto done;\n            }\n        }\n    }\n\n    /*\n     * Setting entry->fail_auth_count to 0 can be used to manually unlock\n     * an account. It is not possible to set fail_auth_count to any other\n     * value using kadmin.\n     */\n    if (mask & KADM5_FAIL_AUTH_COUNT) {\n        if (entry->fail_auth_count != 0) {\n            ret = KADM5_BAD_SERVER_PARAMS;\n            goto done;\n        }\n\n        kdb->fail_auth_count = 0;\n    }\n\n    /* let the mask propagate to the database provider */\n    kdb->mask = mask;\n\n    ret = k5_kadm5_hook_modify(handle->context, handle->hook_handles,\n                               KADM5_HOOK_STAGE_PRECOMMIT, entry, mask);\n    if (ret)\n        goto done;\n\n    ret = kdb_put_entry(handle, kdb, &adb);\n    if (ret) goto done;\n    (void) k5_kadm5_hook_modify(handle->context, handle->hook_handles,\n                                KADM5_HOOK_STAGE_POSTCOMMIT, entry, mask);\n\n    ret = KADM5_OK;\ndone:\n    if (have_pol) {\n        ret2 = kadm5_free_policy_ent(handle->lhandle, &pol);\n        ret = ret ? ret : ret2;\n    }\n    kdb_free_entry(handle, kdb, &adb);\n    return ret;\n}\n", "target": 1, "idx": 180701}
{"func": "OMX_ERRORTYPE SoftG711::internalSetParameter(\n        OMX_INDEXTYPE index, const OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamAudioPcm:\n {\n\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex != 0 && pcmParams->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n if (pcmParams->nChannels < 1 || pcmParams->nChannels > 2) {\n return OMX_ErrorUndefined;\n }\n\n if(pcmParams->nPortIndex == 0) {\n                mNumChannels = pcmParams->nChannels;\n }\n\n            mSamplingRate = pcmParams->nSamplingRate;\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamStandardComponentRole:\n {\n\n             const OMX_PARAM_COMPONENTROLETYPE *roleParams =\n                 (const OMX_PARAM_COMPONENTROLETYPE *)params;\n \n             if (mIsMLaw) {\n                 if (strncmp((const char *)roleParams->cRole,\n                             \"audio_decoder.g711mlaw\",\n                            OMX_MAX_STRINGNAME_SIZE - 1)) {\n return OMX_ErrorUndefined;\n }\n } else {\n if (strncmp((const char *)roleParams->cRole,\n \"audio_decoder.g711alaw\",\n                            OMX_MAX_STRINGNAME_SIZE - 1)) {\n return OMX_ErrorUndefined;\n }\n }\n\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalSetParameter(index, params);\n }\n}\n", "target": 1, "idx": 188228}
{"func": "void rose_add_loopback_neigh(void)\n{\n\tstruct rose_neigh *sn;\n\n\trose_loopback_neigh = kmalloc(sizeof(struct rose_neigh), GFP_KERNEL);\n\tif (!rose_loopback_neigh)\n\t\treturn;\n\tsn = rose_loopback_neigh;\n\n\tsn->callsign  = null_ax25_address;\n\tsn->digipeat  = NULL;\n\tsn->ax25      = NULL;\n\tsn->dev       = NULL;\n\tsn->count     = 0;\n\tsn->use       = 0;\n\tsn->dce_mode  = 1;\n\tsn->loopback  = 1;\n\tsn->number    = rose_neigh_no++;\n\tsn->restarted = 1;\n\n\tskb_queue_head_init(&sn->queue);\n\n\tinit_timer(&sn->ftimer);\n\tinit_timer(&sn->t0timer);\n\n\tspin_lock_bh(&rose_neigh_list_lock);\n\tsn->next = rose_neigh_list;\n\trose_neigh_list           = sn;\n\tspin_unlock_bh(&rose_neigh_list_lock);\n}\n", "target": 0, "idx": 22230}
{"func": "static MenuCacheItem* read_item(GDataInputStream* f, MenuCache* cache,\n                                MenuCacheFileDir** all_used_files, int n_all_used_files)\n{\n    MenuCacheItem* item;\n    char *line;\n    gsize len;\n    gint idx;\n\n    /* desktop/menu id */\n    line = g_data_input_stream_read_line(f, &len, cache->cancellable, NULL);\n    if(G_UNLIKELY(line == NULL))\n        return NULL;\n\n    if( G_LIKELY(len >= 1) )\n    {\n        if( line[0] == '+' ) /* menu dir */\n        {\n            item = (MenuCacheItem*)g_slice_new0( MenuCacheDir );\n            item->n_ref = 1;\n            item->type = MENU_CACHE_TYPE_DIR;\n        }\n        else if( line[0] == '-' ) /* menu item */\n        {\n            item = (MenuCacheItem*)g_slice_new0( MenuCacheApp );\n            item->n_ref = 1;\n            if( G_LIKELY( len > 1 ) ) /* application item */\n                item->type = MENU_CACHE_TYPE_APP;\n            else /* separator */\n            {\n                item->type = MENU_CACHE_TYPE_SEP;\n                return item;\n            }\n        }\n        else\n            return NULL;\n\n        item->id = g_strndup( line + 1, len - 1 );\n        g_free(line);\n    }\n    else\n    {\n        g_free(line);\n        return NULL;\n    }\n\n    /* name */\n    line = g_data_input_stream_read_line(f, &len, cache->cancellable, NULL);\n    if(G_UNLIKELY(line == NULL))\n        goto _fail;\n    if(G_LIKELY(len > 0))\n        item->name = _unescape_lf(line);\n    else\n        g_free(line);\n\n    /* comment */\n    line = g_data_input_stream_read_line(f, &len, cache->cancellable, NULL);\n    if(G_UNLIKELY(line == NULL))\n        goto _fail;\n    if(G_LIKELY(len > 0))\n        item->comment = _unescape_lf(line);\n    else\n        g_free(line);\n\n    /* icon */\n    line = g_data_input_stream_read_line(f, &len, cache->cancellable, NULL);\n    if(G_UNLIKELY(line == NULL))\n        goto _fail;\n    if(G_LIKELY(len > 0))\n        item->icon = line;\n    else\n        g_free(line);\n\n    /* file dir/basename */\n\n    /* file name */\n    line = g_data_input_stream_read_line(f, &len, cache->cancellable, NULL);\n    if(G_UNLIKELY(line == NULL))\n        goto _fail;\n    if(G_LIKELY(len > 0))\n        item->file_name = line;\n    else if( item->type == MENU_CACHE_TYPE_APP )\n    {\n        /* When file name is the same as desktop_id, which is\n         * quite common in desktop files, we use this trick to\n         * save memory usage. */\n        item->file_name = item->id;\n        g_free(line);\n    }\n    else\n        g_free(line);\n\n    /* desktop file dir */\n    line = g_data_input_stream_read_line(f, &len, cache->cancellable, NULL);\n    if(G_UNLIKELY(line == NULL))\n    {\n_fail:\n        g_free(item->id);\n        g_free(item->name);\n        g_free(item->comment);\n        g_free(item->icon);\n        if(item->file_name && item->file_name != item->id)\n            g_free(item->file_name);\n        if(item->type == MENU_CACHE_TYPE_DIR)\n            g_slice_free(MenuCacheDir, MENU_CACHE_DIR(item));\n        else\n            g_slice_free(MenuCacheApp, MENU_CACHE_APP(item));\n        return NULL;\n    }\n    idx = atoi( line );\n    g_free(line);\n    if( G_LIKELY( idx >=0 && idx < n_all_used_files ) )\n    {\n        item->file_dir = all_used_files[ idx ];\n        g_atomic_int_inc(&item->file_dir->n_ref);\n    }\n\n    if( item->type == MENU_CACHE_TYPE_DIR )\n        read_dir( f, MENU_CACHE_DIR(item), cache, all_used_files, n_all_used_files );\n    else if( item->type == MENU_CACHE_TYPE_APP )\n        read_app( f, MENU_CACHE_APP(item), cache );\n\n    return item;\n}\n", "target": 0, "idx": 6461}
{"func": "int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)\n{\n\tstruct sctp_association *asoc = sctp_id2assoc(sk, id);\n\tstruct sctp_sock *sp = sctp_sk(sk);\n \tstruct socket *sock;\n \tint err = 0;\n \n \tif (!asoc)\n \t\treturn -EINVAL;\n \n\t/* If there is a thread waiting on more sndbuf space for\n\t * sending on this asoc, it cannot be peeled.\n\t */\n\tif (waitqueue_active(&asoc->wait))\n\t\treturn -EBUSY;\n\n\t/* An association cannot be branched off from an already peeled-off\n\t * socket, nor is this supported for tcp style sockets.\n\t */\n\tif (!sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\t/* Create a new socket.  */\n\terr = sock_create(sk->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock);\n\tif (err < 0)\n\t\treturn err;\n\n\tsctp_copy_sock(sock->sk, sk, asoc);\n\n\t/* Make peeled-off sockets more like 1-1 accepted sockets.\n\t * Set the daddr and initialize id to something more random\n\t */\n\tsp->pf->to_sk_daddr(&asoc->peer.primary_addr, sk);\n\n\t/* Populate the fields of the newsk from the oldsk and migrate the\n\t * asoc to the newsk.\n\t */\n\tsctp_sock_migrate(sk, sock->sk, asoc, SCTP_SOCKET_UDP_HIGH_BANDWIDTH);\n\n\t*sockp = sock;\n\n\treturn err;\n}\n", "target": 1, "idx": 180908}
{"func": "int arpt_register_table(struct net *net,\n\t\t\tconst struct xt_table *table,\n\t\t\tconst struct arpt_replace *repl,\n\t\t\tconst struct nf_hook_ops *ops,\n\t\t\tstruct xt_table **res)\n{\n\tint ret;\n\tstruct xt_table_info *newinfo;\n\tstruct xt_table_info bootstrap = {0};\n\tvoid *loc_cpu_entry;\n\tstruct xt_table *new_table;\n\n\tnewinfo = xt_alloc_table_info(repl->size);\n\tif (!newinfo)\n\t\treturn -ENOMEM;\n\n\tloc_cpu_entry = newinfo->entries;\n\tmemcpy(loc_cpu_entry, repl->entries, repl->size);\n\n\tret = translate_table(newinfo, loc_cpu_entry, repl);\n\tduprintf(\"arpt_register_table: translate table gives %d\\n\", ret);\n\tif (ret != 0)\n\t\tgoto out_free;\n\n\tnew_table = xt_register_table(net, table, &bootstrap, newinfo);\n\tif (IS_ERR(new_table)) {\n\t\tret = PTR_ERR(new_table);\n\t\tgoto out_free;\n\t}\n\n\t/* set res now, will see skbs right after nf_register_net_hooks */\n\tWRITE_ONCE(*res, new_table);\n\n\tret = nf_register_net_hooks(net, ops, hweight32(table->valid_hooks));\n\tif (ret != 0) {\n\t\t__arpt_unregister_table(new_table);\n\t\t*res = NULL;\n\t}\n\n\treturn ret;\n\nout_free:\n\txt_free_table_info(newinfo);\n\treturn ret;\n}\n", "target": 0, "idx": 52234}
{"func": "spnego_gss_wrap_iov(OM_uint32 *minor_status,\n\t\t    gss_ctx_id_t context_handle,\n\t\t    int conf_req_flag,\n\t\t    gss_qop_t qop_req,\n\t\t    int *conf_state,\n\t\t    gss_iov_buffer_desc *iov,\n \t\t    int iov_count)\n {\n \tOM_uint32 ret;\n \tret = gss_wrap_iov(minor_status,\n\t\t\t   context_handle,\n \t\t\t   conf_req_flag,\n \t\t\t   qop_req,\n \t\t\t   conf_state,\n\t\t\t   iov,\n\t\t\t   iov_count);\n\treturn (ret);\n}\n", "target": 1, "idx": 179845}
{"func": " ptaReadStream(FILE  *fp)\n {\nchar       typestr[128];\n l_int32    i, n, ix, iy, type, version;\n l_float32  x, y;\n PTA       *pta;\n\n    PROCNAME(\"ptaReadStream\");\n\n    if (!fp)\n        return (PTA *)ERROR_PTR(\"stream not defined\", procName, NULL);\n\n    if (fscanf(fp, \"\\n Pta Version %d\\n\", &version) != 1)\n         return (PTA *)ERROR_PTR(\"not a pta file\", procName, NULL);\n     if (version != PTA_VERSION_NUMBER)\n         return (PTA *)ERROR_PTR(\"invalid pta version\", procName, NULL);\n    if (fscanf(fp, \" Number of pts = %d; format = %s\\n\", &n, typestr) != 2)\n         return (PTA *)ERROR_PTR(\"not a pta file\", procName, NULL);\n     if (!strcmp(typestr, \"float\"))\n         type = 0;\n    else  /* typestr is \"integer\" */\n        type = 1;\n\n    if ((pta = ptaCreate(n)) == NULL)\n        return (PTA *)ERROR_PTR(\"pta not made\", procName, NULL);\n    for (i = 0; i < n; i++) {\n        if (type == 0) {  /* data is float */\n            if (fscanf(fp, \"   (%f, %f)\\n\", &x, &y) != 2) {\n                ptaDestroy(&pta);\n                return (PTA *)ERROR_PTR(\"error reading floats\", procName, NULL);\n            }\n            ptaAddPt(pta, x, y);\n        } else {   /* data is integer */\n            if (fscanf(fp, \"   (%d, %d)\\n\", &ix, &iy) != 2) {\n                ptaDestroy(&pta);\n                return (PTA *)ERROR_PTR(\"error reading ints\", procName, NULL);\n            }\n            ptaAddPt(pta, ix, iy);\n        }\n    }\n\n    return pta;\n}\n", "target": 1, "idx": 182500}
{"func": "bool WebMediaPlayerMS::HasSingleSecurityOrigin() const {\n  DCHECK(thread_checker_.CalledOnValidThread());\n  return true;\n}\n", "target": 1, "idx": 186599}
{"func": "void InspectorResourceAgent::markResourceAsCached(unsigned long identifier)\n{\n    m_frontend->requestServedFromCache(IdentifiersFactory::requestId(identifier));\n}\n", "target": 0, "idx": 109386}
{"func": "static bool is_valid(const char *test_name) {\n for (size_t i = 0; i < sanity_suite_size; ++i) {\n if (!strcmp(test_name, sanity_suite[i].function_name)) {\n return true;\n }\n }\n for (size_t i = 0; i < test_suite_size; ++i) {\n if (!strcmp(test_name, test_suite[i].function_name)) {\n return true;\n }\n }\n return false;\n}\n", "target": 0, "idx": 172917}
{"func": " void CachingPermutedEntropyProvider::RegisterPrefs(\n     PrefRegistrySimple* registry) {\n  registry->RegisterStringPref(prefs::kVariationsPermutedEntropyCache,\n                               std::string());\n }\n", "target": 1, "idx": 185424}
{"func": "static int __videobuf_iolock (struct videobuf_queue* q,\n\t\t\t      struct videobuf_buffer *vb,\n\t\t\t      struct v4l2_framebuffer *fbuf)\n{\n\tint pages;\n\n\tstruct videbuf_vmalloc_memory *mem=vb->priv;\n\n\n\tBUG_ON(!mem);\n\n\tMAGIC_CHECK(mem->magic,MAGIC_VMAL_MEM);\n\n\tpages = PAGE_ALIGN(vb->size) >> PAGE_SHIFT;\n\n\t/* Currently, doesn't support V4L2_MEMORY_OVERLAY */\n\tif ((vb->memory != V4L2_MEMORY_MMAP) &&\n\t\t\t\t(vb->memory != V4L2_MEMORY_USERPTR) ) {\n\t\tprintk(KERN_ERR \"Method currently unsupported.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* FIXME: should be tested with kernel mmap mem */\n\tmem->vmalloc=vmalloc_user (PAGE_ALIGN(vb->size));\n\tif (NULL == mem->vmalloc) {\n\t\tprintk(KERN_ERR \"vmalloc (%d pages) failed\\n\",pages);\n\t\treturn -ENOMEM;\n\t}\n\n\tdprintk(1,\"vmalloc is at addr 0x%08lx, size=%d\\n\",\n\t\t\t\t(unsigned long)mem->vmalloc,\n\t\t\t\tpages << PAGE_SHIFT);\n\n\t/* It seems that some kernel versions need to do remap *after*\n\t   the mmap() call\n\t */\n\tif (mem->vma) {\n\t\tint retval=remap_vmalloc_range(mem->vma, mem->vmalloc,0);\n\t\tkfree(mem->vma);\n\t\tmem->vma=NULL;\n\t\tif (retval<0) {\n\t\t\tdprintk(1,\"mmap app bug: remap_vmalloc_range area %p error %d\\n\",\n\t\t\t\tmem->vmalloc,retval);\n\t\t\treturn retval;\n\t\t}\n\t}\n\n\treturn 0;\n}\n", "target": 0, "idx": 74706}
{"func": "static int load_state_from_tss32(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t struct tss_segment_32 *tss)\n{\n\tint ret;\n\tu8 cpl;\n\n\tif (ctxt->ops->set_cr(ctxt, 3, tss->cr3))\n\t\treturn emulate_gp(ctxt, 0);\n\tctxt->_eip = tss->eip;\n\tctxt->eflags = tss->eflags | 2;\n\n\t/* General purpose registers */\n\t*reg_write(ctxt, VCPU_REGS_RAX) = tss->eax;\n\t*reg_write(ctxt, VCPU_REGS_RCX) = tss->ecx;\n\t*reg_write(ctxt, VCPU_REGS_RDX) = tss->edx;\n\t*reg_write(ctxt, VCPU_REGS_RBX) = tss->ebx;\n\t*reg_write(ctxt, VCPU_REGS_RSP) = tss->esp;\n\t*reg_write(ctxt, VCPU_REGS_RBP) = tss->ebp;\n\t*reg_write(ctxt, VCPU_REGS_RSI) = tss->esi;\n\t*reg_write(ctxt, VCPU_REGS_RDI) = tss->edi;\n\n\t/*\n\t * SDM says that segment selectors are loaded before segment\n\t * descriptors.  This is important because CPL checks will\n\t * use CS.RPL.\n\t */\n\tset_segment_selector(ctxt, tss->ldt_selector, VCPU_SREG_LDTR);\n\tset_segment_selector(ctxt, tss->es, VCPU_SREG_ES);\n\tset_segment_selector(ctxt, tss->cs, VCPU_SREG_CS);\n\tset_segment_selector(ctxt, tss->ss, VCPU_SREG_SS);\n\tset_segment_selector(ctxt, tss->ds, VCPU_SREG_DS);\n\tset_segment_selector(ctxt, tss->fs, VCPU_SREG_FS);\n\tset_segment_selector(ctxt, tss->gs, VCPU_SREG_GS);\n\n\t/*\n\t * If we're switching between Protected Mode and VM86, we need to make\n\t * sure to update the mode before loading the segment descriptors so\n\t * that the selectors are interpreted correctly.\n\t */\n\tif (ctxt->eflags & X86_EFLAGS_VM) {\n\t\tctxt->mode = X86EMUL_MODE_VM86;\n\t\tcpl = 3;\n\t} else {\n\t\tctxt->mode = X86EMUL_MODE_PROT32;\n\t\tcpl = tss->cs & 3;\n\t}\n\n\t/*\n \t * Now load segment descriptors. If fault happenes at this stage\n \t * it is handled in a context of new task\n \t */\n\tret = __load_segment_descriptor(ctxt, tss->ldt_selector, VCPU_SREG_LDTR, cpl, true);\n \tif (ret != X86EMUL_CONTINUE)\n \t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->es, VCPU_SREG_ES, cpl, true);\n \tif (ret != X86EMUL_CONTINUE)\n \t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->cs, VCPU_SREG_CS, cpl, true);\n \tif (ret != X86EMUL_CONTINUE)\n \t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->ss, VCPU_SREG_SS, cpl, true);\n \tif (ret != X86EMUL_CONTINUE)\n \t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->ds, VCPU_SREG_DS, cpl, true);\n \tif (ret != X86EMUL_CONTINUE)\n \t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->fs, VCPU_SREG_FS, cpl, true);\n \tif (ret != X86EMUL_CONTINUE)\n \t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->gs, VCPU_SREG_GS, cpl, true);\n \tif (ret != X86EMUL_CONTINUE)\n \t\treturn ret;\n \n\treturn X86EMUL_CONTINUE;\n}\n", "target": 1, "idx": 179515}
{"func": "static void update_open_stateflags(struct nfs4_state *state, mode_t open_flags)\n {\n\tswitch (open_flags) {\n \t\tcase FMODE_WRITE:\n \t\t\tstate->n_wronly++;\n \t\t\tbreak;\n\t\tcase FMODE_READ:\n\t\t\tstate->n_rdonly++;\n\t\t\tbreak;\n \t\tcase FMODE_READ|FMODE_WRITE:\n \t\t\tstate->n_rdwr++;\n \t}\n\tnfs4_state_set_mode_locked(state, state->state | open_flags);\n }\n", "target": 1, "idx": 178879}
{"func": "rdpsnddbg_process(STREAM s)\n{\n\tunsigned int pkglen;\n \tstatic char *rest = NULL;\n \tchar *buf;\n \n \tpkglen = s->end - s->p;\n \t/* str_handle_lines requires null terminated strings */\n \tbuf = (char *) xmalloc(pkglen + 1);\n\tSTRNCPY(buf, (char *) s->p, pkglen + 1);\n\n\tstr_handle_lines(buf, &rest, rdpsnddbg_line_handler, NULL);\n\n\txfree(buf);\n}\n", "target": 1, "idx": 182979}
{"func": "bittok2str(register const struct tok *lp, register const char *fmt,\n\t   register u_int v)\n{\n    return (bittok2str_internal(lp, fmt, v, \", \"));\n}\n", "target": 0, "idx": 62377}
{"func": "static Image *ReadWMFImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  double\n    bounding_height,\n    bounding_width,\n    image_height,\n    image_height_inch,\n    image_width,\n    image_width_inch,\n    resolution_y,\n    resolution_x,\n    units_per_inch;\n\n  float\n    wmf_width,\n    wmf_height;\n\n   Image\n     *image;\n \n   unsigned long\n     wmf_options_flags = 0;\n \n  wmf_error_t\n    wmf_error;\n\n  wmf_magick_t\n    *ddata = 0;\n\n  wmfAPI\n    *API = 0;\n\n  wmfAPI_Options\n    wmf_api_options;\n\n  wmfD_Rect\n    bbox;\n\n  image=AcquireImage(image_info);\n  if (OpenBlob(image_info,image,ReadBinaryBlobMode,exception) == MagickFalse)\n    {\n      if (image->debug != MagickFalse)\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  OpenBlob failed\");\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"leave ReadWMFImage()\");\n        }\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n\n  /*\n   * Create WMF API\n   *\n   */\n\n  /* Register callbacks */\n  wmf_options_flags |= WMF_OPT_FUNCTION;\n  (void) ResetMagickMemory(&wmf_api_options, 0, sizeof(wmf_api_options));\n  wmf_api_options.function = ipa_functions;\n\n  /* Ignore non-fatal errors */\n  wmf_options_flags |= WMF_OPT_IGNORE_NONFATAL;\n\n  wmf_error = wmf_api_create(&API, wmf_options_flags, &wmf_api_options);\n  if (wmf_error != wmf_E_None)\n    {\n      if (API)\n        wmf_api_destroy(API);\n      if (image->debug != MagickFalse)\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  wmf_api_create failed\");\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"leave ReadWMFImage()\");\n        }\n      ThrowReaderException(DelegateError,\"UnableToInitializeWMFLibrary\");\n    }\n\n  /* Register progress monitor */\n  wmf_status_function(API,image,magick_progress_callback);\n\n  ddata=WMF_MAGICK_GetData(API);\n  ddata->image=image;\n  ddata->image_info=image_info;\n  ddata->draw_info=CloneDrawInfo(image_info,(const DrawInfo *) NULL);\n  ddata->draw_info->font=(char *)\n    RelinquishMagickMemory(ddata->draw_info->font);\n  ddata->draw_info->text=(char *)\n    RelinquishMagickMemory(ddata->draw_info->text);\n\n#if defined(MAGICKCORE_WMFLITE_DELEGATE)\n  /* Must initialize font subystem for WMFlite interface */\n  lite_font_init (API,&wmf_api_options); /* similar to wmf_ipa_font_init in src/font.c */\n  /* wmf_arg_fontdirs (API,options); */ /* similar to wmf_arg_fontdirs in src/wmf.c */\n\n#endif\n\n  /*\n   * Open BLOB input via libwmf API\n   *\n   */\n  wmf_error = wmf_bbuf_input(API,ipa_blob_read,ipa_blob_seek,\n    ipa_blob_tell,(void*)image);\n  if (wmf_error != wmf_E_None)\n    {\n      wmf_api_destroy(API);\n      if (image->debug != MagickFalse)\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  wmf_bbuf_input failed\");\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"leave ReadWMFImage()\");\n        }\n      ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",\n        image->filename);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n\n  /*\n   * Scan WMF file\n   *\n   */\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Scanning WMF to obtain bounding box\");\n  wmf_error=wmf_scan(API, 0, &bbox);\n  if (wmf_error != wmf_E_None)\n    {\n      wmf_api_destroy(API);\n      if (image->debug != MagickFalse)\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  wmf_scan failed with wmf_error %d\", wmf_error);\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"leave ReadWMFImage()\");\n        }\n      ThrowReaderException(DelegateError,\"FailedToScanFile\");\n    }\n\n  /*\n   * Compute dimensions and scale factors\n   *\n   */\n\n  ddata->bbox=bbox;\n\n  /* User specified resolution */\n  resolution_y=DefaultResolution;\n  if (image->y_resolution != 0.0)\n    {\n      resolution_y = image->y_resolution;\n      if (image->units == PixelsPerCentimeterResolution)\n        resolution_y *= CENTIMETERS_PER_INCH;\n    }\n  resolution_x=DefaultResolution;\n  if (image->x_resolution != 0.0)\n    {\n      resolution_x = image->x_resolution;\n      if (image->units == PixelsPerCentimeterResolution)\n        resolution_x *= CENTIMETERS_PER_INCH;\n    }\n\n  /* Obtain output size expressed in metafile units */\n  wmf_error=wmf_size(API,&wmf_width,&wmf_height);\n  if (wmf_error != wmf_E_None)\n    {\n      wmf_api_destroy(API);\n      if (image->debug != MagickFalse)\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  wmf_size failed with wmf_error %d\", wmf_error);\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"leave ReadWMFImage()\");\n        }\n      ThrowReaderException(DelegateError,\"FailedToComputeOutputSize\");\n    }\n\n  /* Obtain (or guess) metafile units */\n  if ((API)->File->placeable)\n    units_per_inch=(API)->File->pmh->Inch;\n  else if ( (wmf_width*wmf_height) < 1024*1024)\n    units_per_inch=POINTS_PER_INCH;  /* MM_TEXT */\n  else\n    units_per_inch=TWIPS_PER_INCH;  /* MM_TWIPS */\n\n  /* Calculate image width and height based on specified DPI\n     resolution */\n  image_width_inch  = (double) wmf_width / units_per_inch;\n  image_height_inch = (double) wmf_height / units_per_inch;\n  image_width       = image_width_inch * resolution_x;\n  image_height      = image_height_inch * resolution_y;\n\n  /* Compute bounding box scale factors and origin translations\n   *\n   * This all just a hack since libwmf does not currently seem to\n   * provide the mapping between LOGICAL coordinates and DEVICE\n   * coordinates. This mapping is necessary in order to know\n   * where to place the logical bounding box within the image.\n   *\n   */\n\n  bounding_width  = bbox.BR.x - bbox.TL.x;\n  bounding_height = bbox.BR.y - bbox.TL.y;\n\n  ddata->scale_x = image_width/bounding_width;\n  ddata->translate_x = 0-bbox.TL.x;\n  ddata->rotate = 0;\n\n  /* Heuristic: guess that if the vertical coordinates mostly span\n     negative values, then the image must be inverted. */\n  if ( fabs(bbox.BR.y) > fabs(bbox.TL.y) )\n    {\n      /* Normal (Origin at top left of image) */\n      ddata->scale_y = (image_height/bounding_height);\n      ddata->translate_y = 0-bbox.TL.y;\n    }\n  else\n    {\n      /* Inverted (Origin at bottom left of image) */\n      ddata->scale_y = (-image_height/bounding_height);\n      ddata->translate_y = 0-bbox.BR.y;\n    }\n\n  if (image->debug != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n         \"  Placeable metafile:          %s\",\n         (API)->File->placeable ? \"Yes\" : \"No\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Size in metafile units:      %gx%g\",wmf_width,wmf_height);\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Metafile units/inch:         %g\",units_per_inch);\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Size in inches:              %gx%g\",\n        image_width_inch,image_height_inch);\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Bounding Box:                %g,%g %g,%g\",\n        bbox.TL.x, bbox.TL.y, bbox.BR.x, bbox.BR.y);\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Bounding width x height:     %gx%g\",bounding_width,\n        bounding_height);\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Output resolution:           %gx%g\",resolution_x,resolution_y);\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Image size:                  %gx%g\",image_width,image_height);\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Bounding box scale factor:   %g,%g\",ddata->scale_x,\n        ddata->scale_y);\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Translation:                 %g,%g\",\n        ddata->translate_x, ddata->translate_y);\n    }\n\n#if 0\n#if 0\n  {\n    typedef struct _wmfPlayer_t wmfPlayer_t;\n    struct _wmfPlayer_t\n    {\n      wmfPen   default_pen;\n      wmfBrush default_brush;\n      wmfFont  default_font;\n\n      wmfDC* dc; /* current dc */\n    };\n\n    wmfDC\n      *dc;\n\n#define WMF_ELICIT_DC(API) (((wmfPlayer_t*)((API)->player_data))->dc)\n\n    dc = WMF_ELICIT_DC(API);\n\n    printf(\"dc->Window.Ox     = %d\\n\", dc->Window.Ox);\n    printf(\"dc->Window.Oy     = %d\\n\", dc->Window.Oy);\n    printf(\"dc->Window.width  = %d\\n\", dc->Window.width);\n    printf(\"dc->Window.height = %d\\n\", dc->Window.height);\n    printf(\"dc->pixel_width   = %g\\n\", dc->pixel_width);\n    printf(\"dc->pixel_height  = %g\\n\", dc->pixel_height);\n#if defined(MAGICKCORE_WMFLITE_DELEGATE)  /* Only in libwmf 0.3 */\n    printf(\"dc->Ox            = %.d\\n\", dc->Ox);\n    printf(\"dc->Oy            = %.d\\n\", dc->Oy);\n    printf(\"dc->width         = %.d\\n\", dc->width);\n    printf(\"dc->height        = %.d\\n\", dc->height);\n#endif\n\n  }\n#endif\n\n#endif\n\n  /*\n   * Create canvas image\n   *\n   */\n  image->rows=(unsigned long) ceil(image_height);\n  image->columns=(unsigned long) ceil(image_width);\n\n  if (image_info->ping != MagickFalse)\n    {\n      wmf_api_destroy(API);\n      (void) CloseBlob(image);\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"leave ReadWMFImage()\");\n       return(GetFirstImageInList(image));\n     }\n   if (image->debug != MagickFalse)\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Creating canvas image with size %lux%lu\",(unsigned long) image->rows,\n       (unsigned long) image->columns);\n\n  /*\n   * Set solid background color\n   */\n  {\n    image->background_color = image_info->background_color;\n    if (image->background_color.opacity != OpaqueOpacity)\n      image->matte = MagickTrue;\n    (void) SetImageBackgroundColor(image);\n  }\n  /*\n   * Play file to generate Vector drawing commands\n   *\n   */\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Playing WMF to prepare vectors\");\n\n  wmf_error = wmf_play(API, 0, &bbox);\n  if (wmf_error != wmf_E_None)\n    {\n      wmf_api_destroy(API);\n      if (image->debug != MagickFalse)\n        {\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Playing WMF failed with wmf_error %d\", wmf_error);\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"leave ReadWMFImage()\");\n        }\n      ThrowReaderException(DelegateError,\"FailedToRenderFile\");\n    }\n\n  /*\n   * Scribble on canvas image\n   *\n   */\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Rendering WMF vectors\");\n  DrawRender(ddata->draw_wand);\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"leave ReadWMFImage()\");\n\n  /* Cleanup allocated data */\n  wmf_api_destroy(API);\n  (void) CloseBlob(image);\n\n  /* Return image */\n  return image;\n}\n", "target": 1, "idx": 181793}
{"func": "void WebLocalFrameImpl::ReplaceSelection(const WebString& text) {\n  GetFrame()->GetDocument()->UpdateStyleAndLayoutIgnorePendingStylesheets();\n\n  GetFrame()->GetEditor().ReplaceSelection(text);\n}\n", "target": 0, "idx": 147051}
{"func": "xmlParse3986RelativeRef(xmlURIPtr uri, const char *str) {\n int ret;\n\n if ((*str == '/') && (*(str + 1) == '/')) {\n        str += 2;\n\tret = xmlParse3986Authority(uri, &str);\n if (ret != 0) return(ret);\n\tret = xmlParse3986PathAbEmpty(uri, &str);\n if (ret != 0) return(ret);\n } else if (*str == '/') {\n\tret = xmlParse3986PathAbsolute(uri, &str);\n if (ret != 0) return(ret);\n } else if (ISA_PCHAR(str)) {\n        ret = xmlParse3986PathNoScheme(uri, &str);\n if (ret != 0) return(ret);\n } else {\n /* path-empty is effectively empty */\n if (uri != NULL) {\n if (uri->path != NULL) xmlFree(uri->path);\n\t    uri->path = NULL;\n }\n }\n\n if (*str == '?') {\n\tstr++;\n\tret = xmlParse3986Query(uri, &str);\n if (ret != 0) return(ret);\n }\n if (*str == '#') {\n\tstr++;\n\tret = xmlParse3986Fragment(uri, &str);\n if (ret != 0) return(ret);\n }\n if (*str != 0) {\n\txmlCleanURI(uri);\n return(1);\n }\n return(0);\n}\n", "target": 0, "idx": 176525}
{"func": "  std::unique_ptr<content::WebContents> CreateAndNavigateWebContents() {\n    std::unique_ptr<content::WebContents> web_contents =\n        CreateTestWebContents();\n    ResourceCoordinatorTabHelper::CreateForWebContents(web_contents.get());\n    content::WebContentsTester::For(web_contents.get())\n        ->NavigateAndCommit(GURL(\"https://www.example.com\"));\n    return web_contents;\n  }\n", "target": 0, "idx": 144810}
{"func": "static void withActiveWindowAndFirstWindowAttributeAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)\n{\n    TRACE_EVENT_SET_SAMPLING_STATE(\"Blink\", \"DOMGetter\");\n    TestObjectV8Internal::withActiveWindowAndFirstWindowAttributeAttributeGetter(info);\n    TRACE_EVENT_SET_SAMPLING_STATE(\"V8\", \"V8Execution\");\n}\n", "target": 0, "idx": 131123}
{"func": "  uint64_t received_page_id() const { return received_page_id_; }\n", "target": 0, "idx": 150538}
{"func": "gfx::Size ScaleSizeToFitView(const gfx::Size& size,\n                             const gfx::Size& view_size) {\n  if ((size.width() > view_size.width() ||\n       size.height() > view_size.height()) ||\n      (size.width() < view_size.width() &&\n       size.height() < view_size.height())) {\n    const float scale =\n        std::min(view_size.width() / static_cast<float>(size.width()),\n                 view_size.height() / static_cast<float>(size.height()));\n    return gfx::ScaleToFlooredSize(size, scale);\n  }\n\n  return size;\n}\n", "target": 0, "idx": 149182}
{"func": "void GLES2DecoderImpl::DoVertexAttribI4iv(GLuint index,\n                                          const volatile GLint* v) {\n  GLint t[4] = {v[0], v[1], v[2], v[3]};\n  if (SetVertexAttribValue(\"glVertexAttribI4iv\", index, t)) {\n    state_.SetGenericVertexAttribBaseType(\n        index, SHADER_VARIABLE_INT);\n    api()->glVertexAttribI4ivFn(index, t);\n  }\n}\n", "target": 0, "idx": 154108}
{"func": "IW_IMPL(void) iw_set_apply_bkgd_2(struct iw_context *ctx, const struct iw_color *clr)\n{\n\tctx->req.bkgd_valid=1;\n\tctx->req.bkgd = *clr;\n}\n", "target": 0, "idx": 64983}
{"func": "long long BlockGroup::GetPrevTimeCode() const\n{\n    return m_prev;\n}\n", "target": 1, "idx": 188373}
{"func": " static int sh_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len) {\n \tut8 op_MSB,op_LSB;\n \tint ret;\n\tif (!data)\n \t\treturn 0;\n \tmemset (op, '\\0', sizeof (RAnalOp));\n \top->addr = addr;\n \top->type = R_ANAL_OP_TYPE_UNK;\n\top->jump = op->fail = -1;\n\top->ptr = op->val = -1;\n\n\top->size = 2;\n\n\top_MSB = anal->big_endian? data[0]: data[1];\n\top_LSB = anal->big_endian? data[1]: data[0];\n\tret =  first_nibble_decode[(op_MSB>>4) & 0x0F](anal, op, (ut16)(op_MSB<<8 | op_LSB));\n\treturn ret;\n}\n", "target": 1, "idx": 182393}
{"func": "error::Error GLES2DecoderPassthroughImpl::DoGetUniformiv(GLuint program,\n                                                         GLint location,\n                                                         GLsizei bufsize,\n                                                         GLsizei* length,\n                                                         GLint* params) {\n  api()->glGetUniformivRobustANGLEFn(GetProgramServiceID(program, resources_),\n                                     location, bufsize * sizeof(*params),\n                                     length, params);\n  return error::kNoError;\n}\n", "target": 0, "idx": 154720}
{"func": "SAPI_API int sapi_add_header_ex(char *header_line, uint header_line_len, zend_bool duplicate, zend_bool replace TSRMLS_DC)\n{\n\tsapi_header_line ctr = {0};\n\tint r;\n\t\n\tctr.line = header_line;\n\tctr.line_len = header_line_len;\n\n\tr = sapi_header_op(replace ? SAPI_HEADER_REPLACE : SAPI_HEADER_ADD,\n\t\t\t&ctr TSRMLS_CC);\n\n\tif (!duplicate)\n\t\tefree(header_line);\n\n\treturn r;\n}\n", "target": 0, "idx": 56265}
{"func": "int ceph_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint ret = 0, size = 0;\n\tconst char *name = NULL;\n\tchar *value = NULL;\n\tstruct iattr newattrs;\n\tumode_t new_mode = inode->i_mode, old_mode = inode->i_mode;\n\n\tswitch (type) {\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n\t\t\tret = posix_acl_equiv_mode(acl, &new_mode);\n\t\t\tif (ret < 0)\n \t\t\t\tgoto out;\n\t\t\tif (ret == 0)\n\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:\n\t\tif (!S_ISDIR(inode->i_mode)) {\n\t\t\tret = acl ? -EINVAL : 0;\n\t\t\tgoto out;\n\t\t}\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmalloc(size, GFP_NOFS);\n\t\tif (!value) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (ret < 0)\n\t\t\tgoto out_free;\n\t}\n\n\tif (new_mode != old_mode) {\n\t\tnewattrs.ia_mode = new_mode;\n\t\tnewattrs.ia_valid = ATTR_MODE;\n\t\tret = __ceph_setattr(inode, &newattrs);\n\t\tif (ret)\n\t\t\tgoto out_free;\n\t}\n\n\tret = __ceph_setxattr(inode, name, value, size, 0);\n\tif (ret) {\n\t\tif (new_mode != old_mode) {\n\t\t\tnewattrs.ia_mode = old_mode;\n\t\t\tnewattrs.ia_valid = ATTR_MODE;\n\t\t\t__ceph_setattr(inode, &newattrs);\n\t\t}\n\t\tgoto out_free;\n\t}\n\n\tceph_set_cached_acl(inode, type, acl);\n\nout_free:\n\tkfree(value);\nout:\n\treturn ret;\n}\n", "target": 1, "idx": 180140}
{"func": "void AllocateDataSet(cmsIT8* it8)\n{\n    TABLE* t = GetTable(it8);\n\n    if (t -> Data) return;    // Already allocated\n\n     t-> nSamples   = atoi(cmsIT8GetProperty(it8, \"NUMBER_OF_FIELDS\"));\n     t-> nPatches   = atoi(cmsIT8GetProperty(it8, \"NUMBER_OF_SETS\"));\n \n    t-> Data = (char**)AllocChunk (it8, ((cmsUInt32Number) t->nSamples + 1) * ((cmsUInt32Number) t->nPatches + 1) *sizeof (char*));\n    if (t->Data == NULL) {\n \n        SynError(it8, \"AllocateDataSet: Unable to allocate data array\");\n     }\n \n }\n", "target": 1, "idx": 182217}
{"func": "sec_reset_state(void)\n{\n\tg_server_rdp_version = 0;\n\tg_sec_encrypt_use_count = 0;\n\tg_sec_decrypt_use_count = 0;\n\tg_licence_issued = 0;\n\tg_licence_error_result = 0;\n\tmcs_reset_state();\n}\n", "target": 0, "idx": 93115}
{"func": "static void put_mspel8_mc32_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\n{\n    uint8_t halfH[88];\n    uint8_t halfV[64];\n    uint8_t halfHV[64];\n    wmv2_mspel8_h_lowpass(halfH, src-stride, 8, stride, 11);\n    wmv2_mspel8_v_lowpass(halfV, src+1, 8, stride, 8);\n    wmv2_mspel8_v_lowpass(halfHV, halfH+8, 8, 8, 8);\n    put_pixels8_l2_8(dst, halfV, halfHV, stride, 8, 8, 8);\n}\n", "target": 0, "idx": 28163}
{"func": "void Browser::SaveWindowPlacement(const gfx::Rect& bounds,\n                                  ui::WindowShowState show_state) {\n  SessionService* session_service =\n      SessionServiceFactory::GetForProfileIfExisting(profile());\n  if (session_service)\n    session_service->SetWindowBounds(session_id_, bounds, show_state);\n}\n", "target": 0, "idx": 101794}
{"func": "static void *__alloc_from_pool(size_t size, struct page **ret_page, gfp_t flags)\n{\n\tunsigned long val;\n\tvoid *ptr = NULL;\n\n\tif (!atomic_pool) {\n\t\tWARN(1, \"coherent pool not initialised!\\n\");\n\t\treturn NULL;\n\t}\n\n\tval = gen_pool_alloc(atomic_pool, size);\n\tif (val) {\n\t\tphys_addr_t phys = gen_pool_virt_to_phys(atomic_pool, val);\n \n \t\t*ret_page = phys_to_page(phys);\n \t\tptr = (void *)val;\n\t\tif (flags & __GFP_ZERO)\n\t\t\tmemset(ptr, 0, size);\n \t}\n \n \treturn ptr;\n}\n", "target": 1, "idx": 180642}
{"func": "xfs_acl_from_disk(struct xfs_acl *aclp)\n{\n\tstruct posix_acl_entry *acl_e;\n\tstruct posix_acl *acl;\n\tstruct xfs_acl_entry *ace;\n \tint count, i;\n \n \tcount = be32_to_cpu(aclp->acl_cnt);\n \n \tacl = posix_acl_alloc(count, GFP_KERNEL);\n \tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (i = 0; i < count; i++) {\n\t\tacl_e = &acl->a_entries[i];\n\t\tace = &aclp->acl_entry[i];\n\n\t\t/*\n\t\t * The tag is 32 bits on disk and 16 bits in core.\n\t\t *\n\t\t * Because every access to it goes through the core\n\t\t * format first this is not a problem.\n\t\t */\n\t\tacl_e->e_tag = be32_to_cpu(ace->ae_tag);\n\t\tacl_e->e_perm = be16_to_cpu(ace->ae_perm);\n\n\t\tswitch (acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\tcase ACL_GROUP:\n\t\t\tacl_e->e_id = be32_to_cpu(ace->ae_id);\n\t\t\tbreak;\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\tacl_e->e_id = ACL_UNDEFINED_ID;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn acl;\n\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}\n", "target": 1, "idx": 178828}
{"func": " void CheckTMPrediction() const {\n for (int p = 0; p < num_planes_; p++)\n for (int y = 0; y < block_size_; y++)\n for (int x = 0; x < block_size_; x++) {\n const int expected = ClipByte(data_ptr_[p][x - stride_]\n + data_ptr_[p][stride_ * y - 1]\n - data_ptr_[p][-1 - stride_]);\n          ASSERT_EQ(expected, data_ptr_[p][y * stride_ + x]);\n }\n }\n", "target": 0, "idx": 177637}
{"func": " FileEntrySync* DirectoryEntrySync::getFile(const String& path, const Dictionary& options, ExceptionState& exceptionState)\n {\n     FileSystemFlags flags(options);\n    RefPtr<EntrySyncCallbackHelper> helper = EntrySyncCallbackHelper::create();\n     m_fileSystem->getFile(this, path, flags, helper->successCallback(), helper->errorCallback(), DOMFileSystemBase::Synchronous);\n     return static_cast<FileEntrySync*>(helper->getResult(exceptionState));\n }\n", "target": 1, "idx": 185116}
{"func": "int ipmi_get_my_LUN(struct ipmi_user *user,\n\t\t    unsigned int  channel,\n\t\t    unsigned char *address)\n{\n\tint index, rv = 0;\n\n\tuser = acquire_ipmi_user(user, &index);\n\tif (!user)\n\t\treturn -ENODEV;\n\n\tif (channel >= IPMI_MAX_CHANNELS) {\n\t\trv = -EINVAL;\n\t} else {\n\t\tchannel = array_index_nospec(channel, IPMI_MAX_CHANNELS);\n\t\t*address = user->intf->addrinfo[channel].lun;\n\t}\n\trelease_ipmi_user(user, index);\n\n\treturn rv;\n}\n", "target": 0, "idx": 91274}
{"func": "static int on_headers_complete(http_parser *parser)\n{\n\tparser_context *ctx = (parser_context *) parser->data;\n\thttp_subtransport *t = ctx->t;\n\thttp_stream *s = ctx->s;\n\tgit_buf buf = GIT_BUF_INIT;\n\tint error = 0, no_callback = 0, allowed_auth_types = 0;\n\n\t/* Both parse_header_name and parse_header_value are populated\n\t * and ready for consumption. */\n\tif (VALUE == t->last_cb)\n\t\tif (on_header_ready(t) < 0)\n\t\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\n\t/* Capture authentication headers which may be a 401 (authentication\n\t * is not complete) or a 200 (simply informing us that auth *is*\n\t * complete.)\n\t */\n\tif (parse_authenticate_response(&t->www_authenticate, t,\n\t\t\t&allowed_auth_types) < 0)\n\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\n\t/* Check for an authentication failure. */\n\tif (parser->status_code == 401 && get_verb == s->verb) {\n\t\tif (!t->owner->cred_acquire_cb) {\n\t\t\tno_callback = 1;\n\t\t} else {\n\t\t\tif (allowed_auth_types) {\n\t\t\t\tif (t->cred) {\n\t\t\t\t\tt->cred->free(t->cred);\n\t\t\t\t\tt->cred = NULL;\n\t\t\t\t}\n\n\t\t\t\terror = t->owner->cred_acquire_cb(&t->cred,\n\t\t\t\t\t\t\t\t  t->owner->url,\n\t\t\t\t\t\t\t\t  t->connection_data.user,\n\t\t\t\t\t\t\t\t  allowed_auth_types,\n\t\t\t\t\t\t\t\t  t->owner->cred_acquire_payload);\n\n\t\t\t\tif (error == GIT_PASSTHROUGH) {\n\t\t\t\t\tno_callback = 1;\n\t\t\t\t} else if (error < 0) {\n\t\t\t\t\tt->error = error;\n\t\t\t\t\treturn t->parse_error = PARSE_ERROR_EXT;\n\t\t\t\t} else {\n\t\t\t\t\tassert(t->cred);\n\n\t\t\t\t\tif (!(t->cred->credtype & allowed_auth_types)) {\n\t\t\t\t\t\tgiterr_set(GITERR_NET, \"credentials callback returned an invalid cred type\");\n\t\t\t\t\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Successfully acquired a credential. */\n\t\t\t\t\tt->parse_error = PARSE_ERROR_REPLAY;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (no_callback) {\n\t\t\tgiterr_set(GITERR_NET, \"authentication required but no callback set\");\n\t\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\t\t}\n\t}\n\n\t/* Check for a redirect.\n\t * Right now we only permit a redirect to the same hostname. */\n\tif ((parser->status_code == 301 ||\n\t     parser->status_code == 302 ||\n\t     (parser->status_code == 303 && get_verb == s->verb) ||\n\t     parser->status_code == 307) &&\n\t    t->location) {\n\n\t\tif (s->redirect_count >= 7) {\n\t\t\tgiterr_set(GITERR_NET, \"Too many redirects\");\n\t\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\t\t}\n\n\t\tif (gitno_connection_data_from_url(&t->connection_data, t->location, s->service_url) < 0)\n\t\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\n\t\t/* Set the redirect URL on the stream. This is a transfer of\n\t\t * ownership of the memory. */\n\t\tif (s->redirect_url)\n\t\t\tgit__free(s->redirect_url);\n\n\t\ts->redirect_url = t->location;\n\t\tt->location = NULL;\n\n\t\tt->connected = 0;\n\t\ts->redirect_count++;\n\n\t\tt->parse_error = PARSE_ERROR_REPLAY;\n\t\treturn 0;\n\t}\n\n\t/* Check for a 200 HTTP status code. */\n\tif (parser->status_code != 200) {\n\t\tgiterr_set(GITERR_NET,\n\t\t\t\"Unexpected HTTP status code: %d\",\n\t\t\tparser->status_code);\n\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\t}\n\n\t/* The response must contain a Content-Type header. */\n\tif (!t->content_type) {\n\t\tgiterr_set(GITERR_NET, \"No Content-Type header in response\");\n\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\t}\n\n\t/* The Content-Type header must match our expectation. */\n\tif (get_verb == s->verb)\n\t\tgit_buf_printf(&buf,\n\t\t\t\"application/x-git-%s-advertisement\",\n\t\t\tctx->s->service);\n\telse\n\t\tgit_buf_printf(&buf,\n\t\t\t\"application/x-git-%s-result\",\n\t\t\tctx->s->service);\n\n\tif (git_buf_oom(&buf))\n\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\n\tif (strcmp(t->content_type, git_buf_cstr(&buf))) {\n\t\tgit_buf_free(&buf);\n\t\tgiterr_set(GITERR_NET,\n\t\t\t\"Invalid Content-Type: %s\",\n\t\t\tt->content_type);\n\t\treturn t->parse_error = PARSE_ERROR_GENERIC;\n\t}\n\n\tgit_buf_free(&buf);\n\n\treturn 0;\n}\n", "target": 0, "idx": 71338}
{"func": "static int mpage_prepare_extent_to_map(struct mpage_da_data *mpd)\n{\n\tstruct address_space *mapping = mpd->inode->i_mapping;\n\tstruct pagevec pvec;\n\tunsigned int nr_pages;\n\tlong left = mpd->wbc->nr_to_write;\n\tpgoff_t index = mpd->first_page;\n\tpgoff_t end = mpd->last_page;\n\tint tag;\n\tint i, err = 0;\n\tint blkbits = mpd->inode->i_blkbits;\n\text4_lblk_t lblk;\n\tstruct buffer_head *head;\n\n\tif (mpd->wbc->sync_mode == WB_SYNC_ALL || mpd->wbc->tagged_writepages)\n\t\ttag = PAGECACHE_TAG_TOWRITE;\n\telse\n\t\ttag = PAGECACHE_TAG_DIRTY;\n\n\tpagevec_init(&pvec, 0);\n\tmpd->map.m_len = 0;\n\tmpd->next_page = index;\n\twhile (index <= end) {\n\t\tnr_pages = pagevec_lookup_tag(&pvec, mapping, &index, tag,\n\t\t\t      min(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1);\n\t\tif (nr_pages == 0)\n\t\t\tgoto out;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\t/*\n\t\t\t * At this point, the page may be truncated or\n\t\t\t * invalidated (changing page->mapping to NULL), or\n\t\t\t * even swizzled back from swapper_space to tmpfs file\n\t\t\t * mapping. However, page->index will not change\n\t\t\t * because we have a reference on the page.\n\t\t\t */\n\t\t\tif (page->index > end)\n\t\t\t\tgoto out;\n\n\t\t\t/*\n\t\t\t * Accumulated enough dirty pages? This doesn't apply\n\t\t\t * to WB_SYNC_ALL mode. For integrity sync we have to\n\t\t\t * keep going because someone may be concurrently\n\t\t\t * dirtying pages, and we might have synced a lot of\n\t\t\t * newly appeared dirty pages, but have not synced all\n\t\t\t * of the old dirty pages.\n\t\t\t */\n\t\t\tif (mpd->wbc->sync_mode == WB_SYNC_NONE && left <= 0)\n\t\t\t\tgoto out;\n\n\t\t\t/* If we can't merge this page, we are done. */\n\t\t\tif (mpd->map.m_len > 0 && mpd->next_page != page->index)\n\t\t\t\tgoto out;\n\n\t\t\tlock_page(page);\n\t\t\t/*\n\t\t\t * If the page is no longer dirty, or its mapping no\n\t\t\t * longer corresponds to inode we are writing (which\n\t\t\t * means it has been truncated or invalidated), or the\n\t\t\t * page is already under writeback and we are not doing\n\t\t\t * a data integrity writeback, skip the page\n\t\t\t */\n\t\t\tif (!PageDirty(page) ||\n\t\t\t    (PageWriteback(page) &&\n\t\t\t     (mpd->wbc->sync_mode == WB_SYNC_NONE)) ||\n\t\t\t    unlikely(page->mapping != mapping)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\twait_on_page_writeback(page);\n\t\t\tBUG_ON(PageWriteback(page));\n\n\t\t\tif (mpd->map.m_len == 0)\n\t\t\t\tmpd->first_page = page->index;\n\t\t\tmpd->next_page = page->index + 1;\n\t\t\t/* Add all dirty buffers to mpd */\n\t\t\tlblk = ((ext4_lblk_t)page->index) <<\n\t\t\t\t(PAGE_SHIFT - blkbits);\n\t\t\thead = page_buffers(page);\n\t\t\terr = mpage_process_page_bufs(mpd, head, head, lblk);\n\t\t\tif (err <= 0)\n\t\t\t\tgoto out;\n\t\t\terr = 0;\n\t\t\tleft--;\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n\treturn 0;\nout:\n\tpagevec_release(&pvec);\n\treturn err;\n}\n", "target": 0, "idx": 67548}
{"func": "void MediaRecorder::ScheduleDispatchEvent(Event* event) {\n  scheduled_events_.push_back(event);\n\n  dispatch_scheduled_event_runner_->RunAsync();\n}\n", "target": 0, "idx": 156323}
{"func": " std::string GetUploadData(const std::string& brand) {\n   DCHECK(!brand.empty());\n  std::string data(kPostXml);\n  const std::string placeholder(\"__BRANDCODE_PLACEHOLDER__\");\n  size_t placeholder_pos = data.find(placeholder);\n  DCHECK(placeholder_pos != std::string::npos);\n  data.replace(placeholder_pos, placeholder.size(), brand);\n  return data;\n }\n", "target": 1, "idx": 186246}
{"func": "static inline int pix_abs16_c(void *v, uint8_t *pix1, uint8_t *pix2, int line_size, int h)\n{\n    int s, i;\n\n    s = 0;\n    for(i=0;i<h;i++) {\n        s += abs(pix1[0] - pix2[0]);\n        s += abs(pix1[1] - pix2[1]);\n        s += abs(pix1[2] - pix2[2]);\n        s += abs(pix1[3] - pix2[3]);\n        s += abs(pix1[4] - pix2[4]);\n        s += abs(pix1[5] - pix2[5]);\n        s += abs(pix1[6] - pix2[6]);\n        s += abs(pix1[7] - pix2[7]);\n        s += abs(pix1[8] - pix2[8]);\n        s += abs(pix1[9] - pix2[9]);\n        s += abs(pix1[10] - pix2[10]);\n        s += abs(pix1[11] - pix2[11]);\n        s += abs(pix1[12] - pix2[12]);\n        s += abs(pix1[13] - pix2[13]);\n        s += abs(pix1[14] - pix2[14]);\n        s += abs(pix1[15] - pix2[15]);\n        pix1 += line_size;\n        pix2 += line_size;\n    }\n    return s;\n}\n", "target": 0, "idx": 28147}
{"func": "void MediaElementAudioSourceHandler::Process(size_t number_of_frames) {\n  AudioBus* output_bus = Output(0).Bus();\n\n  MutexTryLocker try_locker(process_lock_);\n  if (try_locker.Locked()) {\n    if (!MediaElement() || !source_sample_rate_) {\n      output_bus->Zero();\n      return;\n    }\n\n    if (source_number_of_channels_ != output_bus->NumberOfChannels()) {\n      output_bus->Zero();\n      return;\n    }\n\n    AudioSourceProvider& provider = MediaElement()->GetAudioSourceProvider();\n    if (multi_channel_resampler_.get()) {\n      DCHECK_NE(source_sample_rate_, Context()->sampleRate());\n      multi_channel_resampler_->Process(&provider, output_bus,\n                                        number_of_frames);\n    } else {\n      DCHECK_EQ(source_sample_rate_, Context()->sampleRate());\n       provider.ProvideInput(output_bus, number_of_frames);\n     }\n    if (!PassesCORSAccessCheck()) {\n      if (maybe_print_cors_message_) {\n        maybe_print_cors_message_ = false;\n        PostCrossThreadTask(\n            *task_runner_, FROM_HERE,\n            CrossThreadBind(&MediaElementAudioSourceHandler::PrintCORSMessage,\n                            WrapRefCounted(this), current_src_string_));\n      }\n       output_bus->Zero();\n     }\n   } else {\n    output_bus->Zero();\n  }\n}\n", "target": 1, "idx": 187133}
{"func": "static int decode_frame(AVCodecContext *avctx,\n                        void *data, int *got_frame,\n                        AVPacket *avpkt)\n{\n    PicContext *s = avctx->priv_data;\n    AVFrame *frame = data;\n    uint32_t *palette;\n    int bits_per_plane, bpp, etype, esize, npal, pos_after_pal;\n    int i, x, y, plane, tmp, ret, val;\n\n    bytestream2_init(&s->g, avpkt->data, avpkt->size);\n\n    if (bytestream2_get_bytes_left(&s->g) < 11)\n        return AVERROR_INVALIDDATA;\n\n    if (bytestream2_get_le16u(&s->g) != 0x1234)\n        return AVERROR_INVALIDDATA;\n\n    s->width       = bytestream2_get_le16u(&s->g);\n    s->height      = bytestream2_get_le16u(&s->g);\n    bytestream2_skip(&s->g, 4);\n    tmp            = bytestream2_get_byteu(&s->g);\n    bits_per_plane = tmp & 0xF;\n    s->nb_planes   = (tmp >> 4) + 1;\n    bpp            = bits_per_plane * s->nb_planes;\n    if (bits_per_plane > 8 || bpp < 1 || bpp > 32) {\n        avpriv_request_sample(avctx, \"Unsupported bit depth\");\n        return AVERROR_PATCHWELCOME;\n    }\n\n    if (bytestream2_peek_byte(&s->g) == 0xFF || bpp == 1 || bpp == 4 || bpp == 8) {\n        bytestream2_skip(&s->g, 2);\n        etype = bytestream2_get_le16(&s->g);\n        esize = bytestream2_get_le16(&s->g);\n        if (bytestream2_get_bytes_left(&s->g) < esize)\n            return AVERROR_INVALIDDATA;\n    } else {\n        etype = -1;\n        esize = 0;\n    }\n\n    avctx->pix_fmt = AV_PIX_FMT_PAL8;\n \n     if (av_image_check_size(s->width, s->height, 0, avctx) < 0)\n         return -1;\n    if (s->width != avctx->width && s->height != avctx->height) {\n         ret = ff_set_dimensions(avctx, s->width, s->height);\n         if (ret < 0)\n             return ret;\n    }\n\n    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)\n        return ret;\n    memset(frame->data[0], 0, s->height * frame->linesize[0]);\n    frame->pict_type           = AV_PICTURE_TYPE_I;\n    frame->palette_has_changed = 1;\n\n    pos_after_pal = bytestream2_tell(&s->g) + esize;\n    palette = (uint32_t*)frame->data[1];\n    if (etype == 1 && esize > 1 && bytestream2_peek_byte(&s->g) < 6) {\n        int idx = bytestream2_get_byte(&s->g);\n        npal = 4;\n        for (i = 0; i < npal; i++)\n            palette[i] = ff_cga_palette[ cga_mode45_index[idx][i] ];\n    } else if (etype == 2) {\n        npal = FFMIN(esize, 16);\n        for (i = 0; i < npal; i++) {\n            int pal_idx = bytestream2_get_byte(&s->g);\n            palette[i]  = ff_cga_palette[FFMIN(pal_idx, 15)];\n        }\n    } else if (etype == 3) {\n        npal = FFMIN(esize, 16);\n        for (i = 0; i < npal; i++) {\n            int pal_idx = bytestream2_get_byte(&s->g);\n            palette[i]  = ff_ega_palette[FFMIN(pal_idx, 63)];\n        }\n    } else if (etype == 4 || etype == 5) {\n        npal = FFMIN(esize / 3, 256);\n        for (i = 0; i < npal; i++) {\n            palette[i] = bytestream2_get_be24(&s->g) << 2;\n            palette[i] |= 0xFFU << 24 | palette[i] >> 6 & 0x30303;\n        }\n    } else {\n        if (bpp == 1) {\n            npal = 2;\n            palette[0] = 0xFF000000;\n            palette[1] = 0xFFFFFFFF;\n        } else if (bpp == 2) {\n            npal = 4;\n            for (i = 0; i < npal; i++)\n                palette[i] = ff_cga_palette[ cga_mode45_index[0][i] ];\n        } else {\n            npal = 16;\n            memcpy(palette, ff_cga_palette, npal * 4);\n        }\n    }\n    memset(palette + npal, 0, AVPALETTE_SIZE - npal * 4);\n    bytestream2_seek(&s->g, pos_after_pal, SEEK_SET);\n\n    val = 0;\n    y = s->height - 1;\n    if (bytestream2_get_le16(&s->g)) {\n        x = 0;\n        plane = 0;\n        while (bytestream2_get_bytes_left(&s->g) >= 6) {\n            int stop_size, marker, t1, t2;\n\n            t1        = bytestream2_get_bytes_left(&s->g);\n            t2        = bytestream2_get_le16(&s->g);\n            stop_size = t1 - FFMIN(t1, t2);\n            bytestream2_skip(&s->g, 2);\n            marker    = bytestream2_get_byte(&s->g);\n\n            while (plane < s->nb_planes &&\n                   bytestream2_get_bytes_left(&s->g) > stop_size) {\n                int run = 1;\n                val = bytestream2_get_byte(&s->g);\n                if (val == marker) {\n                    run = bytestream2_get_byte(&s->g);\n                    if (run == 0)\n                        run = bytestream2_get_le16(&s->g);\n                    val = bytestream2_get_byte(&s->g);\n                }\n                if (!bytestream2_get_bytes_left(&s->g))\n                    break;\n\n                if (bits_per_plane == 8) {\n                    picmemset_8bpp(s, frame, val, run, &x, &y);\n                    if (y < 0)\n                        goto finish;\n                } else {\n                    picmemset(s, frame, val, run, &x, &y, &plane, bits_per_plane);\n                }\n            }\n        }\n\n        if (x < avctx->width) {\n            int run = (y + 1) * avctx->width - x;\n            if (bits_per_plane == 8)\n                picmemset_8bpp(s, frame, val, run, &x, &y);\n            else\n                picmemset(s, frame, val, run / (8 / bits_per_plane), &x, &y, &plane, bits_per_plane);\n        }\n    } else {\n        while (y >= 0 && bytestream2_get_bytes_left(&s->g) > 0) {\n            memcpy(frame->data[0] + y * frame->linesize[0], s->g.buffer, FFMIN(avctx->width, bytestream2_get_bytes_left(&s->g)));\n            bytestream2_skip(&s->g, avctx->width);\n            y--;\n        }\n    }\nfinish:\n\n    *got_frame      = 1;\n    return avpkt->size;\n}\n", "target": 1, "idx": 181421}
{"func": "struct http_req_action_kw *action_http_req_custom(const char *kw)\n{\n\tif (!LIST_ISEMPTY(&http_req_keywords.list)) {\n\t\tstruct http_req_action_kw_list *kw_list;\n\t\tint i;\n\n\t\tlist_for_each_entry(kw_list, &http_req_keywords.list, list) {\n\t\t\tfor (i = 0; kw_list->kw[i].kw != NULL; i++) {\n\t\t\t\tif (!strcmp(kw, kw_list->kw[i].kw))\n\t\t\t\t\treturn &kw_list->kw[i];\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n", "target": 0, "idx": 9764}
{"func": "u32 ip_mtu_from_fib_result(struct fib_result *res, __be32 daddr)\n{\n\tstruct fib_info *fi = res->fi;\n\tstruct fib_nh *nh = &fi->fib_nh[res->nh_sel];\n\tstruct net_device *dev = nh->nh_dev;\n\tu32 mtu = 0;\n\n\tif (dev_net(dev)->ipv4.sysctl_ip_fwd_use_pmtu ||\n\t    fi->fib_metrics->metrics[RTAX_LOCK - 1] & (1 << RTAX_MTU))\n\t\tmtu = fi->fib_mtu;\n\n\tif (likely(!mtu)) {\n\t\tstruct fib_nh_exception *fnhe;\n\n\t\tfnhe = find_exception(nh, daddr);\n\t\tif (fnhe && !time_after_eq(jiffies, fnhe->fnhe_expires))\n\t\t\tmtu = fnhe->fnhe_pmtu;\n\t}\n\n\tif (likely(!mtu))\n\t\tmtu = min(READ_ONCE(dev->mtu), IP_MAX_MTU);\n\n\treturn mtu - lwtunnel_headroom(nh->nh_lwtstate, mtu);\n}\n", "target": 0, "idx": 91124}
{"func": "static plist_t parse_array_node(struct bplist_data *bplist, const char** bnode, uint64_t size)\n{\n    uint64_t j;\n    uint64_t str_j = 0;\n    uint64_t index1;\n    plist_data_t data = plist_new_plist_data();\n    const char *index1_ptr = NULL;\n\n    data->type = PLIST_ARRAY;\n    data->length = size;\n\n    plist_t node = node_create(NULL, data);\n\n    for (j = 0; j < data->length; j++) {\n        str_j = j * bplist->ref_size;\n        index1_ptr = (*bnode) + str_j;\n\n        if (index1_ptr < bplist->data || index1_ptr + bplist->ref_size > bplist->offset_table) {\n            plist_free(node);\n            PLIST_BIN_ERR(\"%s: array item %\" PRIu64 \" is outside of valid range\\n\", __func__, j);\n            return NULL;\n        }\n\n        index1 = UINT_TO_HOST(index1_ptr, bplist->ref_size);\n\n        if (index1 >= bplist->num_objects) {\n            plist_free(node);\n            PLIST_BIN_ERR(\"%s: array item %\" PRIu64 \" object index (%\" PRIu64 \") must be smaller than the number of objects (%\" PRIu64 \")\\n\", __func__, j, index1, bplist->num_objects);\n            return NULL;\n        }\n\n        /* process value node */\n        plist_t val = parse_bin_node_at_index(bplist, index1);\n        if (!val) {\n            plist_free(node);\n            return NULL;\n        }\n\n        node_attach(node, val);\n    }\n\n    return node;\n}\n", "target": 0, "idx": 68023}
{"func": "\t\tvoid CWebServer::Cmd_SetUnused(WebEmSession & session, const request& req, Json::Value &root)\n\t\t{\n\t\t\tif (session.rights != 2)\n\t\t\t{\n\t\t\t\tsession.reply_status = reply::forbidden;\n\t\t\t\treturn; //Only admin user allowed\n\t\t\t}\n\n\t\t\tstd::string sidx = request::findValue(&req, \"idx\");\n\t\t\tif (sidx.empty())\n\t\t\t\treturn;\n\t\t\tint idx = atoi(sidx.c_str());\n\t\t\troot[\"status\"] = \"OK\";\n\t\t\troot[\"title\"] = \"SetUnused\";\n\t\t\tm_sql.safe_query(\"UPDATE DeviceStatus SET Used=0 WHERE (ID == %d)\", idx);\n\t\t\tif (m_sql.m_bEnableEventSystem)\n\t\t\t\tm_mainworker.m_eventsystem.RemoveSingleState(idx, m_mainworker.m_eventsystem.REASON_DEVICE);\n\n#ifdef ENABLE_PYTHON\n\t\t\tm_mainworker.m_pluginsystem.DeviceModified(idx);\n#endif\n\t\t}\n", "target": 0, "idx": 91017}
{"func": "static void iwjpeg_scan_exif(struct iwjpegrcontext *rctx,\n\t\tconst iw_byte *d, size_t d_len)\n{\n\tstruct iw_exif_state e;\n\tiw_uint32 ifd;\n\n\tif(d_len<8) return;\n\n\tiw_zeromem(&e,sizeof(struct iw_exif_state));\n\te.d = d;\n\te.d_len = d_len;\n \n \te.endian = d[0]=='I' ? IW_ENDIAN_LITTLE : IW_ENDIAN_BIG;\n \n\tifd = iw_get_ui32_e(&d[4],e.endian);\n \n \tiwjpeg_scan_exif_ifd(rctx,&e,ifd);\n }\n", "target": 1, "idx": 181287}
{"func": " void InfoBarContainer::ChangeTabContents(TabContents* contents) {\n   registrar_.RemoveAll();\n   RemoveAllChildViews(false);\n   tab_contents_ = contents;\n   if (tab_contents_) {\n    UpdateInfoBars();\n    Source<TabContents> tc_source(tab_contents_);\n    registrar_.Add(this, NotificationType::TAB_CONTENTS_INFOBAR_ADDED,\n                   tc_source);\n    registrar_.Add(this, NotificationType::TAB_CONTENTS_INFOBAR_REMOVED,\n                   tc_source);\n    registrar_.Add(this, NotificationType::TAB_CONTENTS_INFOBAR_REPLACED,\n                   tc_source);\n  }\n}\n", "target": 1, "idx": 184195}
{"func": "void set_fat(DOS_FS * fs, uint32_t cluster, int32_t new)\n{\n    unsigned char *data = NULL;\n    int size;\n    loff_t offs;\n\n    if (new == -1)\n\tnew = FAT_EOF(fs);\n    else if ((long)new == -2)\n\tnew = FAT_BAD(fs);\n    switch (fs->fat_bits) {\n    case 12:\n\tdata = fs->fat + cluster * 3 / 2;\n\toffs = fs->fat_start + cluster * 3 / 2;\n\tif (cluster & 1) {\n\t    FAT_ENTRY prevEntry;\n\t    get_fat(&prevEntry, fs->fat, cluster - 1, fs);\n\t    data[0] = ((new & 0xf) << 4) | (prevEntry.value >> 8);\n \t    data[1] = new >> 4;\n \t} else {\n \t    FAT_ENTRY subseqEntry;\n\t    if (cluster != fs->clusters - 1)\n \t\tget_fat(&subseqEntry, fs->fat, cluster + 1, fs);\n \t    else\n \t\tsubseqEntry.value = 0;\n\t    data[0] = new & 0xff;\n\t    data[1] = (new >> 8) | ((0xff & subseqEntry.value) << 4);\n\t}\n\tsize = 2;\n\tbreak;\n    case 16:\n\tdata = fs->fat + cluster * 2;\n\toffs = fs->fat_start + cluster * 2;\n\t*(unsigned short *)data = htole16(new);\n\tsize = 2;\n\tbreak;\n    case 32:\n\t{\n\t    FAT_ENTRY curEntry;\n\t    get_fat(&curEntry, fs->fat, cluster, fs);\n\n\t    data = fs->fat + cluster * 4;\n\t    offs = fs->fat_start + cluster * 4;\n\t    /* According to M$, the high 4 bits of a FAT32 entry are reserved and\n\t     * are not part of the cluster number. So we never touch them. */\n\t    *(uint32_t *)data = htole32((new & 0xfffffff) |\n\t\t\t\t\t     (curEntry.reserved << 28));\n\t    size = 4;\n\t}\n\tbreak;\n    default:\n\tdie(\"Bad FAT entry size: %d bits.\", fs->fat_bits);\n    }\n    fs_write(offs, size, data);\n    if (fs->nfats > 1) {\n\tfs_write(offs + fs->fat_size, size, data);\n    }\n}\n", "target": 1, "idx": 180646}
{"func": " void SecureProxyChecker::CheckIfSecureProxyIsAllowed(\n     SecureProxyCheckerCallback fetcher_callback) {\n   net::NetworkTrafficAnnotationTag traffic_annotation =\n       net::DefineNetworkTrafficAnnotation(\n           \"data_reduction_proxy_secure_proxy_check\", R\"(\n            semantics {\n              sender: \"Data Reduction Proxy\"\n              description:\n                \"Sends a request to the Data Reduction Proxy server. Proceeds \"\n                \"with using a secure connection to the proxy only if the \"\n                \"response is not blocked or modified by an intermediary.\"\n              trigger:\n                \"A request can be sent whenever the browser is determining how \"\n                \"to configure its connection to the data reduction proxy. This \"\n                \"happens on startup and network changes.\"\n              data: \"A specific URL, not related to user data.\"\n              destination: GOOGLE_OWNED_SERVICE\n            }\n            policy {\n              cookies_allowed: NO\n              setting:\n                \"Users can control Data Saver on Android via the 'Data Saver' \"\n                \"setting. Data Saver is not available on iOS, and on desktop \"\n                \"it is enabled by installing the Data Saver extension.\"\n              policy_exception_justification: \"Not implemented.\"\n            })\");\n  auto resource_request = std::make_unique<network::ResourceRequest>();\n  resource_request->url = params::GetSecureProxyCheckURL();\n  resource_request->load_flags =\n      net::LOAD_DISABLE_CACHE | net::LOAD_BYPASS_PROXY;\n  resource_request->allow_credentials = false;\n  url_loader_ = network::SimpleURLLoader::Create(std::move(resource_request),\n                                                 traffic_annotation);\n\n  static const int kMaxRetries = 5;\n  url_loader_->SetRetryOptions(\n      kMaxRetries, network::SimpleURLLoader::RETRY_ON_NETWORK_CHANGE |\n                       network::SimpleURLLoader::RETRY_ON_5XX);\n  url_loader_->SetOnRedirectCallback(base::BindRepeating(\n      &SecureProxyChecker::OnURLLoaderRedirect, base::Unretained(this)));\n\n  fetcher_callback_ = fetcher_callback;\n  secure_proxy_check_start_time_ = base::Time::Now();\n\n  url_loader_->DownloadToStringOfUnboundedSizeUntilCrashAndDie(\n      url_loader_factory_.get(),\n      base::BindOnce(&SecureProxyChecker::OnURLLoadComplete,\n                     base::Unretained(this)));\n}\n", "target": 1, "idx": 186390}
{"func": "static int netlink_recvmsg(struct kiocb *kiocb, struct socket *sock,\n\t\t\t   struct msghdr *msg, size_t len,\n\t\t\t   int flags)\n{\n\tstruct sock_iocb *siocb = kiocb_to_siocb(kiocb);\n\tstruct scm_cookie scm;\n\tstruct sock *sk = sock->sk;\n\tstruct netlink_sock *nlk = nlk_sk(sk);\n\tint noblock = flags&MSG_DONTWAIT;\n\tsize_t copied;\n\tstruct sk_buff *skb, *data_skb;\n\tint err, ret;\n\n\tif (flags&MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tcopied = 0;\n\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (skb == NULL)\n\t\tgoto out;\n\n\tdata_skb = skb;\n\n#ifdef CONFIG_COMPAT_NETLINK_MESSAGES\n\tif (unlikely(skb_shinfo(skb)->frag_list)) {\n\t\t/*\n\t\t * If this skb has a frag_list, then here that means that we\n\t\t * will have to use the frag_list skb's data for compat tasks\n\t\t * and the regular skb's data for normal (non-compat) tasks.\n\t\t *\n\t\t * If we need to send the compat skb, assign it to the\n\t\t * 'data_skb' variable so that it will be used below for data\n\t\t * copying. We keep 'skb' for everything else, including\n\t\t * freeing both later.\n\t\t */\n\t\tif (flags & MSG_CMSG_COMPAT)\n\t\t\tdata_skb = skb_shinfo(skb)->frag_list;\n \t}\n #endif\n \n\tmsg->msg_namelen = 0;\n \tcopied = data_skb->len;\n \tif (len < copied) {\n \t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\tskb_reset_transport_header(data_skb);\n\terr = skb_copy_datagram_iovec(data_skb, 0, msg->msg_iov, copied);\n\n\tif (msg->msg_name) {\n\t\tstruct sockaddr_nl *addr = (struct sockaddr_nl *)msg->msg_name;\n\t\taddr->nl_family = AF_NETLINK;\n\t\taddr->nl_pad    = 0;\n\t\taddr->nl_pid\t= NETLINK_CB(skb).portid;\n\t\taddr->nl_groups\t= netlink_group_mask(NETLINK_CB(skb).dst_group);\n\t\tmsg->msg_namelen = sizeof(*addr);\n\t}\n\n\tif (nlk->flags & NETLINK_RECV_PKTINFO)\n\t\tnetlink_cmsg_recv_pktinfo(msg, skb);\n\n\tif (NULL == siocb->scm) {\n\t\tmemset(&scm, 0, sizeof(scm));\n\t\tsiocb->scm = &scm;\n\t}\n\tsiocb->scm->creds = *NETLINK_CREDS(skb);\n\tif (flags & MSG_TRUNC)\n\t\tcopied = data_skb->len;\n\n\tskb_free_datagram(sk, skb);\n\n\tif (nlk->cb_running &&\n\t    atomic_read(&sk->sk_rmem_alloc) <= sk->sk_rcvbuf / 2) {\n\t\tret = netlink_dump(sk);\n\t\tif (ret) {\n\t\t\tsk->sk_err = ret;\n\t\t\tsk->sk_error_report(sk);\n\t\t}\n\t}\n\n\tscm_recv(sock, msg, siocb->scm, flags);\nout:\n\tnetlink_rcv_wake(sk);\n\treturn err ? : copied;\n}\n", "target": 1, "idx": 179679}
{"func": "MagickPrivate ssize_t FormatLocaleStringList(char *magick_restrict string,\n  const size_t length,const char *magick_restrict format,va_list operands)\n{\n  ssize_t\n    n;\n\n#if defined(MAGICKCORE_LOCALE_SUPPORT) && defined(MAGICKCORE_HAVE_VSNPRINTF_L)\n  {\n    locale_t\n      locale;\n\n    locale=AcquireCLocale();\n    if (locale == (locale_t) NULL)\n      n=(ssize_t) vsnprintf(string,length,format,operands);\n    else\n#if defined(MAGICKCORE_WINDOWS_SUPPORT)\n      n=(ssize_t) vsnprintf_l(string,length,format,locale,operands);\n#else\n      n=(ssize_t) vsnprintf_l(string,length,locale,format,operands);\n#endif\n  }\n#elif defined(MAGICKCORE_HAVE_VSNPRINTF)\n#if defined(MAGICKCORE_LOCALE_SUPPORT) && defined(MAGICKCORE_HAVE_USELOCALE)\n  {\n    locale_t\n      locale,\n      previous_locale;\n\n    locale=AcquireCLocale();\n    if (locale == (locale_t) NULL)\n      n=(ssize_t) vsnprintf(string,length,format,operands);\n    else\n      {\n        previous_locale=uselocale(locale);\n        n=(ssize_t) vsnprintf(string,length,format,operands);\n        uselocale(previous_locale);\n      }\n  }\n#else\n  n=(ssize_t) vsnprintf(string,length,format,operands);\n#endif\n#else\n  n=(ssize_t) vsprintf(string,format,operands);\n#endif\n  if (n < 0)\n    string[length-1]='\\0';\n  return(n);\n}\n", "target": 0, "idx": 90885}
{"func": " SProcXFixesQueryVersion(ClientPtr client)\n {\n     REQUEST(xXFixesQueryVersionReq);\n \n     swaps(&stuff->length);\n     swapl(&stuff->majorVersion);\n    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);\n}\n", "target": 1, "idx": 178616}
{"func": "static void tcp_send_challenge_ack(struct sock *sk, const struct sk_buff *skb)\n{\n\t/* unprotected vars, we dont care of overwrites */\n \tstatic u32 challenge_timestamp;\n \tstatic unsigned int challenge_count;\n \tstruct tcp_sock *tp = tcp_sk(sk);\n\tu32 now;\n \n \t/* First check our per-socket dupack rate limit. */\n \tif (tcp_oow_rate_limited(sock_net(sk), skb,\n \t\t\t\t LINUX_MIB_TCPACKSKIPPEDCHALLENGE,\n \t\t\t\t &tp->last_oow_ack_time))\n \t\treturn;\n \n\t/* Then check the check host-wide RFC 5961 rate limit. */\n \tnow = jiffies / HZ;\n \tif (now != challenge_timestamp) {\n \t\tchallenge_timestamp = now;\n\t\tchallenge_count = 0;\n \t}\n\tif (++challenge_count <= sysctl_tcp_challenge_ack_limit) {\n \t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPCHALLENGEACK);\n \t\ttcp_send_ack(sk);\n \t}\n}\n", "target": 1, "idx": 180305}
{"func": "atol10(const char *p, size_t char_cnt)\n{\n \tuint64_t l;\n \tint digit;\n \n \tl = 0;\n \tdigit = *p - '0';\n \twhile (digit >= 0 && digit < 10  && char_cnt-- > 0) {\n\t\tl = (l * 10) + digit;\n\t\tdigit = *++p - '0';\n\t}\n\treturn (l);\n}\n", "target": 1, "idx": 180939}
{"func": "static void save_text_if_changed(const char *name, const char *new_value)\n{\n    /* a text value can't be change if the file is not loaded */\n    /* returns NULL if the name is not found; otherwise nonzero */\n    if (!g_hash_table_lookup(g_loaded_texts, name))\n        return;\n\n    const char *old_value = g_cd ? problem_data_get_content_or_NULL(g_cd, name) : \"\";\n    if (!old_value)\n        old_value = \"\";\n    if (strcmp(new_value, old_value) != 0)\n    {\n        struct dump_dir *dd = wizard_open_directory_for_writing(g_dump_dir_name);\n        if (dd)\n            dd_save_text(dd, name, new_value);\n \n         dd_close(dd);\n        problem_data_reload_from_dump_dir();\n        update_gui_state_from_problem_data(/* don't update selected event */ 0);\n     }\n }\n", "target": 1, "idx": 179774}
{"func": "xfs_attr3_leaf_clearflag(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n#ifdef DEBUG\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\txfs_attr_leaf_name_local_t *name_loc;\n\tint namelen;\n\tchar *name;\n#endif /* DEBUG */\n\n\ttrace_xfs_attr_leaf_clearflag(args);\n\t/*\n\t * Set up the operation.\n\t */\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\n\tif (error)\n\t\treturn(error);\n\n\tleaf = bp->b_addr;\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\tASSERT(entry->flags & XFS_ATTR_INCOMPLETE);\n\n#ifdef DEBUG\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tASSERT(args->index < ichdr.count);\n\tASSERT(args->index >= 0);\n\n\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, args->index);\n\t\tnamelen = name_loc->namelen;\n\t\tname = (char *)name_loc->nameval;\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tnamelen = name_rmt->namelen;\n\t\tname = (char *)name_rmt->name;\n\t}\n\tASSERT(be32_to_cpu(entry->hashval) == args->hashval);\n\tASSERT(namelen == args->namelen);\n\tASSERT(memcmp(name, args->name, namelen) == 0);\n#endif /* DEBUG */\n\n\tentry->flags &= ~XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, entry, sizeof(*entry)));\n\n\tif (args->rmtblkno) {\n \t\tASSERT((entry->flags & XFS_ATTR_LOCAL) == 0);\n \t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n \t\tname_rmt->valueblk = cpu_to_be32(args->rmtblkno);\n\t\tname_rmt->valuelen = cpu_to_be32(args->valuelen);\n \t\txfs_trans_log_buf(args->trans, bp,\n \t\t\t XFS_DA_LOGRANGE(leaf, name_rmt, sizeof(*name_rmt)));\n \t}\n\n\t/*\n\t * Commit the flag value change and start the next trans in series.\n\t */\n\treturn xfs_trans_roll(&args->trans, args->dp);\n}\n", "target": 1, "idx": 179906}
{"func": "static void webkit_web_view_update_settings(WebKitWebView* webView)\n{\n    WebKitWebViewPrivate* priv = webView->priv;\n    WebKitWebSettings* webSettings = priv->webSettings.get();\n    Settings* settings = core(webView)->settings();\n\n    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;\n    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,\n        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,\n        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,\n        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,\n        javaScriptCanAccessClipboard, enableOfflineWebAppCache,\n         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,\n         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,\n         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,\n        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;\n \n     WebKitEditingBehavior editingBehavior;\n \n    g_object_get(webSettings,\n                 \"default-encoding\", &defaultEncoding,\n                 \"cursive-font-family\", &cursiveFontFamily,\n                 \"default-font-family\", &defaultFontFamily,\n                 \"fantasy-font-family\", &fantasyFontFamily,\n                 \"monospace-font-family\", &monospaceFontFamily,\n                 \"sans-serif-font-family\", &sansSerifFontFamily,\n                 \"serif-font-family\", &serifFontFamily,\n                 \"auto-load-images\", &autoLoadImages,\n                 \"auto-shrink-images\", &autoShrinkImages,\n                 \"print-backgrounds\", &printBackgrounds,\n                 \"enable-scripts\", &enableScripts,\n                 \"enable-plugins\", &enablePlugins,\n                 \"resizable-text-areas\", &resizableTextAreas,\n                 \"user-stylesheet-uri\", &userStylesheetUri,\n                 \"enable-developer-extras\", &enableDeveloperExtras,\n                 \"enable-private-browsing\", &enablePrivateBrowsing,\n                 \"enable-caret-browsing\", &enableCaretBrowsing,\n                 \"enable-html5-database\", &enableHTML5Database,\n                 \"enable-html5-local-storage\", &enableHTML5LocalStorage,\n                 \"enable-xss-auditor\", &enableXSSAuditor,\n                 \"enable-spatial-navigation\", &enableSpatialNavigation,\n                 \"enable-frame-flattening\", &enableFrameFlattening,\n                 \"javascript-can-open-windows-automatically\", &javascriptCanOpenWindows,\n                 \"javascript-can-access-clipboard\", &javaScriptCanAccessClipboard,\n                 \"enable-offline-web-application-cache\", &enableOfflineWebAppCache,\n                 \"editing-behavior\", &editingBehavior,\n                 \"enable-universal-access-from-file-uris\", &enableUniversalAccessFromFileURI,\n                 \"enable-file-access-from-file-uris\", &enableFileAccessFromFileURI,\n                 \"enable-dom-paste\", &enableDOMPaste,\n                 \"tab-key-cycles-through-elements\", &tabKeyCyclesThroughElements,\n                 \"enable-site-specific-quirks\", &enableSiteSpecificQuirks,\n                  \"enable-page-cache\", &usePageCache,\n                  \"enable-java-applet\", &enableJavaApplet,\n                  \"enable-hyperlink-auditing\", &enableHyperlinkAuditing,\n                  \"spell-checking-languages\", &defaultSpellCheckingLanguages,\n                  \"enable-fullscreen\", &enableFullscreen,\n                  \"enable-dns-prefetching\", &enableDNSPrefetching,\n                 \"enable-webgl\", &enableWebGL,\n                 NULL);\n\n    settings->setDefaultTextEncodingName(defaultEncoding);\n    settings->setCursiveFontFamily(cursiveFontFamily);\n    settings->setStandardFontFamily(defaultFontFamily);\n    settings->setFantasyFontFamily(fantasyFontFamily);\n    settings->setFixedFontFamily(monospaceFontFamily);\n    settings->setSansSerifFontFamily(sansSerifFontFamily);\n    settings->setSerifFontFamily(serifFontFamily);\n    settings->setLoadsImagesAutomatically(autoLoadImages);\n    settings->setShrinksStandaloneImagesToFit(autoShrinkImages);\n    settings->setShouldPrintBackgrounds(printBackgrounds);\n    settings->setJavaScriptEnabled(enableScripts);\n    settings->setPluginsEnabled(enablePlugins);\n    settings->setTextAreasAreResizable(resizableTextAreas);\n    settings->setUserStyleSheetLocation(KURL(KURL(), userStylesheetUri));\n    settings->setDeveloperExtrasEnabled(enableDeveloperExtras);\n    settings->setPrivateBrowsingEnabled(enablePrivateBrowsing);\n    settings->setCaretBrowsingEnabled(enableCaretBrowsing);\n#if ENABLE(DATABASE)\n    AbstractDatabase::setIsAvailable(enableHTML5Database);\n#endif\n    settings->setLocalStorageEnabled(enableHTML5LocalStorage);\n    settings->setXSSAuditorEnabled(enableXSSAuditor);\n    settings->setSpatialNavigationEnabled(enableSpatialNavigation);\n    settings->setFrameFlatteningEnabled(enableFrameFlattening);\n    settings->setJavaScriptCanOpenWindowsAutomatically(javascriptCanOpenWindows);\n    settings->setJavaScriptCanAccessClipboard(javaScriptCanAccessClipboard);\n    settings->setOfflineWebApplicationCacheEnabled(enableOfflineWebAppCache);\n    settings->setEditingBehaviorType(static_cast<WebCore::EditingBehaviorType>(editingBehavior));\n    settings->setAllowUniversalAccessFromFileURLs(enableUniversalAccessFromFileURI);\n    settings->setAllowFileAccessFromFileURLs(enableFileAccessFromFileURI);\n    settings->setDOMPasteAllowed(enableDOMPaste);\n    settings->setNeedsSiteSpecificQuirks(enableSiteSpecificQuirks);\n    settings->setUsesPageCache(usePageCache);\n    settings->setJavaEnabled(enableJavaApplet);\n    settings->setHyperlinkAuditingEnabled(enableHyperlinkAuditing);\n    settings->setDNSPrefetchingEnabled(enableDNSPrefetching);\n\n#if ENABLE(FULLSCREEN_API)\n    settings->setFullScreenEnabled(enableFullscreen);\n #endif\n \n #if ENABLE(SPELLCHECK)\n    WebKit::EditorClient* client = static_cast<WebKit::EditorClient*>(core(webView)->editorClient());\n    static_cast<WebKit::TextCheckerClientEnchant*>(client->textChecker())->updateSpellCheckingLanguage(defaultSpellCheckingLanguages);\n #endif\n \n #if ENABLE(WEBGL)\n    settings->setWebGLEnabled(enableWebGL);\n#endif\n\n    Page* page = core(webView);\n    if (page)\n        page->setTabKeyCyclesThroughElements(tabKeyCyclesThroughElements);\n\n    g_free(defaultEncoding);\n    g_free(cursiveFontFamily);\n    g_free(defaultFontFamily);\n    g_free(fantasyFontFamily);\n    g_free(monospaceFontFamily);\n    g_free(sansSerifFontFamily);\n    g_free(serifFontFamily);\n    g_free(userStylesheetUri);\n\n    webkit_web_view_screen_changed(GTK_WIDGET(webView), NULL);\n}\n", "target": 1, "idx": 183907}
{"func": "static MagickOffsetType TIFFSeekCustomStream(const MagickOffsetType offset,\n  const int whence,void *user_data)\n{\n  PhotoshopProfile\n    *profile;\n\n  profile=(PhotoshopProfile *) user_data;\n  switch (whence)\n  {\n    case SEEK_SET:\n    default:\n    {\n      if (offset < 0)\n        return(-1);\n      profile->offset=offset;\n      break;\n     }\n     case SEEK_CUR:\n     {\n       if ((profile->offset+offset) < 0)\n         return(-1);\n       profile->offset+=offset;\n      break;\n    }\n    case SEEK_END:\n    {\n      if (((MagickOffsetType) profile->length+offset) < 0)\n        return(-1);\n      profile->offset=profile->length+offset;\n      break;\n    }\n  }\n\n  return(profile->offset);\n}\n", "target": 1, "idx": 182792}
{"func": "ssh_packet_read_poll2(struct ssh *ssh, u_char *typep, u_int32_t *seqnr_p)\n{\n\tstruct session_state *state = ssh->state;\n\tu_int padlen, need;\n\tu_char *cp;\n\tu_int maclen, aadlen = 0, authlen = 0, block_size;\n\tstruct sshenc *enc   = NULL;\n\tstruct sshmac *mac   = NULL;\n\tstruct sshcomp *comp = NULL;\n\tint r;\n\n\t*typep = SSH_MSG_NONE;\n\n\tif (state->packet_discard)\n\t\treturn 0;\n\n\tif (state->newkeys[MODE_IN] != NULL) {\n\t\tenc  = &state->newkeys[MODE_IN]->enc;\n\t\tmac  = &state->newkeys[MODE_IN]->mac;\n\t\tcomp = &state->newkeys[MODE_IN]->comp;\n\t\t/* disable mac for authenticated encryption */\n\t\tif ((authlen = cipher_authlen(enc->cipher)) != 0)\n\t\t\tmac = NULL;\n\t}\n\tmaclen = mac && mac->enabled ? mac->mac_len : 0;\n\tblock_size = enc ? enc->block_size : 8;\n\taadlen = (mac && mac->enabled && mac->etm) || authlen ? 4 : 0;\n\n\tif (aadlen && state->packlen == 0) {\n\t\tif (cipher_get_length(state->receive_context,\n\t\t    &state->packlen, state->p_read.seqnr,\n\t\t    sshbuf_ptr(state->input), sshbuf_len(state->input)) != 0)\n\t\t\treturn 0;\n\t\tif (state->packlen < 1 + 4 ||\n\t\t    state->packlen > PACKET_MAX_SIZE) {\n#ifdef PACKET_DEBUG\n\t\t\tsshbuf_dump(state->input, stderr);\n#endif\n\t\t\tlogit(\"Bad packet length %u.\", state->packlen);\n\t\t\tif ((r = sshpkt_disconnect(ssh, \"Packet corrupt\")) != 0)\n\t\t\t\treturn r;\n\t\t\treturn SSH_ERR_CONN_CORRUPT;\n\t\t}\n\t\tsshbuf_reset(state->incoming_packet);\n\t} else if (state->packlen == 0) {\n\t\t/*\n\t\t * check if input size is less than the cipher block size,\n\t\t * decrypt first block and extract length of incoming packet\n\t\t */\n\t\tif (sshbuf_len(state->input) < block_size)\n\t\t\treturn 0;\n\t\tsshbuf_reset(state->incoming_packet);\n\t\tif ((r = sshbuf_reserve(state->incoming_packet, block_size,\n\t\t    &cp)) != 0)\n\t\t\tgoto out;\n\t\tif ((r = cipher_crypt(state->receive_context,\n\t\t    state->p_send.seqnr, cp, sshbuf_ptr(state->input),\n\t\t    block_size, 0, 0)) != 0)\n\t\t\tgoto out;\n\t\tstate->packlen = PEEK_U32(sshbuf_ptr(state->incoming_packet));\n\t\tif (state->packlen < 1 + 4 ||\n\t\t    state->packlen > PACKET_MAX_SIZE) {\n#ifdef PACKET_DEBUG\n\t\t\tfprintf(stderr, \"input: \\n\");\n\t\t\tsshbuf_dump(state->input, stderr);\n\t\t\tfprintf(stderr, \"incoming_packet: \\n\");\n\t\t\tsshbuf_dump(state->incoming_packet, stderr);\n#endif\n\t\t\tlogit(\"Bad packet length %u.\", state->packlen);\n\t\t\treturn ssh_packet_start_discard(ssh, enc, mac, 0,\n\t\t\t    PACKET_MAX_SIZE);\n\t\t}\n\t\tif ((r = sshbuf_consume(state->input, block_size)) != 0)\n\t\t\tgoto out;\n\t}\n\tDBG(debug(\"input: packet len %u\", state->packlen+4));\n\n\tif (aadlen) {\n\t\t/* only the payload is encrypted */\n\t\tneed = state->packlen;\n\t} else {\n\t\t/*\n\t\t * the payload size and the payload are encrypted, but we\n\t\t * have a partial packet of block_size bytes\n\t\t */\n\t\tneed = 4 + state->packlen - block_size;\n\t}\n\tDBG(debug(\"partial packet: block %d, need %d, maclen %d, authlen %d,\"\n\t    \" aadlen %d\", block_size, need, maclen, authlen, aadlen));\n\tif (need % block_size != 0) {\n\t\tlogit(\"padding error: need %d block %d mod %d\",\n\t\t    need, block_size, need % block_size);\n\t\treturn ssh_packet_start_discard(ssh, enc, mac, 0,\n\t\t    PACKET_MAX_SIZE - block_size);\n\t}\n\t/*\n\t * check if the entire packet has been received and\n\t * decrypt into incoming_packet:\n\t * 'aadlen' bytes are unencrypted, but authenticated.\n\t * 'need' bytes are encrypted, followed by either\n\t * 'authlen' bytes of authentication tag or\n\t * 'maclen' bytes of message authentication code.\n\t */\n\tif (sshbuf_len(state->input) < aadlen + need + authlen + maclen)\n\t\treturn 0; /* packet is incomplete */\n#ifdef PACKET_DEBUG\n\tfprintf(stderr, \"read_poll enc/full: \");\n\tsshbuf_dump(state->input, stderr);\n#endif\n\t/* EtM: check mac over encrypted input */\n\tif (mac && mac->enabled && mac->etm) {\n\t\tif ((r = mac_check(mac, state->p_read.seqnr,\n\t\t    sshbuf_ptr(state->input), aadlen + need,\n\t\t    sshbuf_ptr(state->input) + aadlen + need + authlen,\n\t\t    maclen)) != 0) {\n\t\t\tif (r == SSH_ERR_MAC_INVALID)\n\t\t\t\tlogit(\"Corrupted MAC on input.\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif ((r = sshbuf_reserve(state->incoming_packet, aadlen + need,\n\t    &cp)) != 0)\n\t\tgoto out;\n\tif ((r = cipher_crypt(state->receive_context, state->p_read.seqnr, cp,\n\t    sshbuf_ptr(state->input), need, aadlen, authlen)) != 0)\n\t\tgoto out;\n\tif ((r = sshbuf_consume(state->input, aadlen + need + authlen)) != 0)\n\t\tgoto out;\n\tif (mac && mac->enabled) {\n\t\t/* Not EtM: check MAC over cleartext */\n\t\tif (!mac->etm && (r = mac_check(mac, state->p_read.seqnr,\n\t\t    sshbuf_ptr(state->incoming_packet),\n\t\t    sshbuf_len(state->incoming_packet),\n\t\t    sshbuf_ptr(state->input), maclen)) != 0) {\n\t\t\tif (r != SSH_ERR_MAC_INVALID)\n\t\t\t\tgoto out;\n\t\t\tlogit(\"Corrupted MAC on input.\");\n\t\t\tif (need > PACKET_MAX_SIZE)\n\t\t\t\treturn SSH_ERR_INTERNAL_ERROR;\n\t\t\treturn ssh_packet_start_discard(ssh, enc, mac,\n\t\t\t    sshbuf_len(state->incoming_packet),\n\t\t\t    PACKET_MAX_SIZE - need);\n\t\t}\n\t\t/* Remove MAC from input buffer */\n\t\tDBG(debug(\"MAC #%d ok\", state->p_read.seqnr));\n\t\tif ((r = sshbuf_consume(state->input, mac->mac_len)) != 0)\n\t\t\tgoto out;\n\t}\n\tif (seqnr_p != NULL)\n\t\t*seqnr_p = state->p_read.seqnr;\n\tif (++state->p_read.seqnr == 0)\n\t\tlogit(\"incoming seqnr wraps around\");\n\tif (++state->p_read.packets == 0)\n\t\tif (!(ssh->compat & SSH_BUG_NOREKEY))\n\t\t\treturn SSH_ERR_NEED_REKEY;\n\tstate->p_read.blocks += (state->packlen + 4) / block_size;\n\tstate->p_read.bytes += state->packlen + 4;\n\n\t/* get padlen */\n\tpadlen = sshbuf_ptr(state->incoming_packet)[4];\n\tDBG(debug(\"input: padlen %d\", padlen));\n\tif (padlen < 4)\t{\n\t\tif ((r = sshpkt_disconnect(ssh,\n\t\t    \"Corrupted padlen %d on input.\", padlen)) != 0 ||\n\t\t    (r = ssh_packet_write_wait(ssh)) != 0)\n\t\t\treturn r;\n\t\treturn SSH_ERR_CONN_CORRUPT;\n\t}\n\n\t/* skip packet size + padlen, discard padding */\n\tif ((r = sshbuf_consume(state->incoming_packet, 4 + 1)) != 0 ||\n\t    ((r = sshbuf_consume_end(state->incoming_packet, padlen)) != 0))\n\t\tgoto out;\n\n\tDBG(debug(\"input: len before de-compress %zd\",\n\t    sshbuf_len(state->incoming_packet)));\n\tif (comp && comp->enabled) {\n\t\tsshbuf_reset(state->compression_buffer);\n\t\tif ((r = uncompress_buffer(ssh, state->incoming_packet,\n\t\t    state->compression_buffer)) != 0)\n\t\t\tgoto out;\n\t\tsshbuf_reset(state->incoming_packet);\n\t\tif ((r = sshbuf_putb(state->incoming_packet,\n\t\t    state->compression_buffer)) != 0)\n\t\t\tgoto out;\n\t\tDBG(debug(\"input: len after de-compress %zd\",\n\t\t    sshbuf_len(state->incoming_packet)));\n\t}\n\t/*\n\t * get packet type, implies consume.\n\t * return length of payload (without type field)\n\t */\n\tif ((r = sshbuf_get_u8(state->incoming_packet, typep)) != 0)\n\t\tgoto out;\n\tif (ssh_packet_log_type(*typep))\n\t\tdebug3(\"receive packet: type %u\", *typep);\n\tif (*typep < SSH2_MSG_MIN || *typep >= SSH2_MSG_LOCAL_MIN) {\n\t\tif ((r = sshpkt_disconnect(ssh,\n\t\t    \"Invalid ssh2 packet type: %d\", *typep)) != 0 ||\n\t\t    (r = ssh_packet_write_wait(ssh)) != 0)\n \t\t\treturn r;\n \t\treturn SSH_ERR_PROTOCOL_ERROR;\n \t}\n\tif (*typep == SSH2_MSG_NEWKEYS)\n\t\tr = ssh_set_newkeys(ssh, MODE_IN);\n\telse if (*typep == SSH2_MSG_USERAUTH_SUCCESS && !state->server_side)\n \t\tr = ssh_packet_enable_delayed_compress(ssh);\n \telse\n \t\tr = 0;\n\telse\n\t\tr = 0;\n#ifdef PACKET_DEBUG\n\tfprintf(stderr, \"read/plain[%d]:\\r\\n\", *typep);\n\tsshbuf_dump(state->incoming_packet, stderr);\n#endif\n\t/* reset for next packet */\n\tstate->packlen = 0;\n\n\t/* do we need to rekey? */\n\tif (ssh_packet_need_rekeying(ssh, 0)) {\n\t\tdebug3(\"%s: rekex triggered\", __func__);\n\t\tif ((r = kex_start_rekex(ssh)) != 0)\n\t\t\treturn r;\n\t}\n out:\n\treturn r;\n}\n", "target": 1, "idx": 178656}
{"func": "  virtual void SetUpCommandLine(CommandLine* command_line) {\n    GpuFeatureTest::SetUpCommandLine(command_line);\n    command_line->AppendSwitch(switches::kEnableThreadedCompositing);\n  }\n", "target": 1, "idx": 184586}
{"func": "bt_status_t btif_hh_execute_service(BOOLEAN b_enable)\n{\n if (b_enable)\n {\n /* Enable and register with BTA-HH */\n          BTA_HhEnable(BTUI_HH_SECURITY, bte_hh_evt);\n }\n else {\n /* Disable HH */\n         BTA_HhDisable();\n }\n return BT_STATUS_SUCCESS;\n}\n", "target": 0, "idx": 171805}
{"func": "const base::Time& BaseNode::GetModificationTime() const {\n   return GetEntry()->Get(syncable::MTIME);\n }\n", "target": 1, "idx": 183662}
{"func": "void streamFreeCG(streamCG *cg) {\n    raxFreeWithCallback(cg->pel,(void(*)(void*))streamFreeNACK);\n    raxFreeWithCallback(cg->consumers,(void(*)(void*))streamFreeConsumer);\n    zfree(cg);\n}\n", "target": 0, "idx": 81792}
{"func": "asmlinkage void __kprobes do_page_fault(struct pt_regs *regs, unsigned long write,\n\t\t\t      unsigned long address)\n{\n\tstruct vm_area_struct * vma = NULL;\n\tstruct task_struct *tsk = current;\n\tstruct mm_struct *mm = tsk->mm;\n\tconst int field = sizeof(unsigned long) * 2;\n\tsiginfo_t info;\n\tint fault;\n\n#if 0\n\tprintk(\"Cpu%d[%s:%d:%0*lx:%ld:%0*lx]\\n\", raw_smp_processor_id(),\n\t       current->comm, current->pid, field, address, write,\n\t       field, regs->cp0_epc);\n#endif\n\n#ifdef CONFIG_KPROBES\n\t/*\n\t * This is to notify the fault handler of the kprobes.  The\n\t * exception code is redundant as it is also carried in REGS,\n\t * but we pass it anyhow.\n\t */\n\tif (notify_die(DIE_PAGE_FAULT, \"page fault\", regs, -1,\n\t\t       (regs->cp0_cause >> 2) & 0x1f, SIGSEGV) == NOTIFY_STOP)\n\t\treturn;\n#endif\n\n\tinfo.si_code = SEGV_MAPERR;\n\n\t/*\n\t * We fault-in kernel-space virtual memory on-demand. The\n\t * 'reference' page table is init_mm.pgd.\n\t *\n\t * NOTE! We MUST NOT take any locks for this case. We may\n\t * be in an interrupt or a critical region, and should\n\t * only copy the information from the master page table,\n\t * nothing more.\n\t */\n#ifdef CONFIG_64BIT\n# define VMALLOC_FAULT_TARGET no_context\n#else\n# define VMALLOC_FAULT_TARGET vmalloc_fault\n#endif\n\n\tif (unlikely(address >= VMALLOC_START && address <= VMALLOC_END))\n\t\tgoto VMALLOC_FAULT_TARGET;\n#ifdef MODULE_START\n\tif (unlikely(address >= MODULE_START && address < MODULE_END))\n\t\tgoto VMALLOC_FAULT_TARGET;\n#endif\n\n\t/*\n\t * If we're in an interrupt or have no user\n\t * context, we must not take the fault..\n\t */\n\tif (in_atomic() || !mm)\n\t\tgoto bad_area_nosemaphore;\n\n\tdown_read(&mm->mmap_sem);\n\tvma = find_vma(mm, address);\n\tif (!vma)\n\t\tgoto bad_area;\n\tif (vma->vm_start <= address)\n\t\tgoto good_area;\n\tif (!(vma->vm_flags & VM_GROWSDOWN))\n\t\tgoto bad_area;\n\tif (expand_stack(vma, address))\n\t\tgoto bad_area;\n/*\n * Ok, we have a good vm_area for this memory access, so\n * we can handle it..\n */\ngood_area:\n\tinfo.si_code = SEGV_ACCERR;\n\n\tif (write) {\n\t\tif (!(vma->vm_flags & VM_WRITE))\n\t\t\tgoto bad_area;\n\t} else {\n\t\tif (kernel_uses_smartmips_rixi) {\n\t\t\tif (address == regs->cp0_epc && !(vma->vm_flags & VM_EXEC)) {\n#if 0\n\t\t\t\tpr_notice(\"Cpu%d[%s:%d:%0*lx:%ld:%0*lx] XI violation\\n\",\n\t\t\t\t\t  raw_smp_processor_id(),\n\t\t\t\t\t  current->comm, current->pid,\n\t\t\t\t\t  field, address, write,\n\t\t\t\t\t  field, regs->cp0_epc);\n#endif\n\t\t\t\tgoto bad_area;\n\t\t\t}\n\t\t\tif (!(vma->vm_flags & VM_READ)) {\n#if 0\n\t\t\t\tpr_notice(\"Cpu%d[%s:%d:%0*lx:%ld:%0*lx] RI violation\\n\",\n\t\t\t\t\t  raw_smp_processor_id(),\n\t\t\t\t\t  current->comm, current->pid,\n\t\t\t\t\t  field, address, write,\n\t\t\t\t\t  field, regs->cp0_epc);\n#endif\n\t\t\t\tgoto bad_area;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!(vma->vm_flags & (VM_READ | VM_WRITE | VM_EXEC)))\n\t\t\t\tgoto bad_area;\n\t\t}\n\t}\n\n\t/*\n\t * If for any reason at all we couldn't handle the fault,\n\t * make sure we exit gracefully rather than endlessly redo\n \t * the fault.\n \t */\n \tfault = handle_mm_fault(mm, vma, address, write ? FAULT_FLAG_WRITE : 0);\n\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, 0, regs, address);\n \tif (unlikely(fault & VM_FAULT_ERROR)) {\n \t\tif (fault & VM_FAULT_OOM)\n \t\t\tgoto out_of_memory;\n\t\telse if (fault & VM_FAULT_SIGBUS)\n\t\t\tgoto do_sigbus;\n \t\tBUG();\n \t}\n \tif (fault & VM_FAULT_MAJOR) {\n\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ,\n\t\t\t\t1, 0, regs, address);\n \t\ttsk->maj_flt++;\n \t} else {\n\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN,\n\t\t\t\t1, 0, regs, address);\n \t\ttsk->min_flt++;\n \t}\n \n\tup_read(&mm->mmap_sem);\n\treturn;\n\n/*\n * Something tried to access memory that isn't in our memory map..\n * Fix it, but check if it's kernel or user first..\n */\nbad_area:\n\tup_read(&mm->mmap_sem);\n\nbad_area_nosemaphore:\n\t/* User mode accesses just cause a SIGSEGV */\n\tif (user_mode(regs)) {\n\t\ttsk->thread.cp0_badvaddr = address;\n\t\ttsk->thread.error_code = write;\n#if 0\n\t\tprintk(\"do_page_fault() #2: sending SIGSEGV to %s for \"\n\t\t       \"invalid %s\\n%0*lx (epc == %0*lx, ra == %0*lx)\\n\",\n\t\t       tsk->comm,\n\t\t       write ? \"write access to\" : \"read access from\",\n\t\t       field, address,\n\t\t       field, (unsigned long) regs->cp0_epc,\n\t\t       field, (unsigned long) regs->regs[31]);\n#endif\n\t\tinfo.si_signo = SIGSEGV;\n\t\tinfo.si_errno = 0;\n\t\t/* info.si_code has been set above */\n\t\tinfo.si_addr = (void __user *) address;\n\t\tforce_sig_info(SIGSEGV, &info, tsk);\n\t\treturn;\n\t}\n\nno_context:\n\t/* Are we prepared to handle this kernel fault?  */\n\tif (fixup_exception(regs)) {\n\t\tcurrent->thread.cp0_baduaddr = address;\n\t\treturn;\n\t}\n\n\t/*\n\t * Oops. The kernel tried to access some bad page. We'll have to\n\t * terminate things with extreme prejudice.\n\t */\n\tbust_spinlocks(1);\n\n\tprintk(KERN_ALERT \"CPU %d Unable to handle kernel paging request at \"\n\t       \"virtual address %0*lx, epc == %0*lx, ra == %0*lx\\n\",\n\t       raw_smp_processor_id(), field, address, field, regs->cp0_epc,\n\t       field,  regs->regs[31]);\n\tdie(\"Oops\", regs);\n\nout_of_memory:\n\t/*\n\t * We ran out of memory, call the OOM killer, and return the userspace\n\t * (which will retry the fault, or kill us if we got oom-killed).\n\t */\n\tup_read(&mm->mmap_sem);\n\tpagefault_out_of_memory();\n\treturn;\n\ndo_sigbus:\n\tup_read(&mm->mmap_sem);\n\n\t/* Kernel mode? Handle exceptions or die */\n\tif (!user_mode(regs))\n\t\tgoto no_context;\n\telse\n\t/*\n\t * Send a sigbus, regardless of whether we were in kernel\n\t * or user mode.\n\t */\n#if 0\n\t\tprintk(\"do_page_fault() #3: sending SIGBUS to %s for \"\n\t\t       \"invalid %s\\n%0*lx (epc == %0*lx, ra == %0*lx)\\n\",\n\t\t       tsk->comm,\n\t\t       write ? \"write access to\" : \"read access from\",\n\t\t       field, address,\n\t\t       field, (unsigned long) regs->cp0_epc,\n\t\t       field, (unsigned long) regs->regs[31]);\n#endif\n\ttsk->thread.cp0_badvaddr = address;\n\tinfo.si_signo = SIGBUS;\n\tinfo.si_errno = 0;\n\tinfo.si_code = BUS_ADRERR;\n\tinfo.si_addr = (void __user *) address;\n\tforce_sig_info(SIGBUS, &info, tsk);\n\n\treturn;\n#ifndef CONFIG_64BIT\nvmalloc_fault:\n\t{\n\t\t/*\n\t\t * Synchronize this task's top level page-table\n\t\t * with the 'reference' page table.\n\t\t *\n\t\t * Do _not_ use \"tsk\" here. We might be inside\n\t\t * an interrupt in the middle of a task switch..\n\t\t */\n\t\tint offset = __pgd_offset(address);\n\t\tpgd_t *pgd, *pgd_k;\n\t\tpud_t *pud, *pud_k;\n\t\tpmd_t *pmd, *pmd_k;\n\t\tpte_t *pte_k;\n\n\t\tpgd = (pgd_t *) pgd_current[raw_smp_processor_id()] + offset;\n\t\tpgd_k = init_mm.pgd + offset;\n\n\t\tif (!pgd_present(*pgd_k))\n\t\t\tgoto no_context;\n\t\tset_pgd(pgd, *pgd_k);\n\n\t\tpud = pud_offset(pgd, address);\n\t\tpud_k = pud_offset(pgd_k, address);\n\t\tif (!pud_present(*pud_k))\n\t\t\tgoto no_context;\n\n\t\tpmd = pmd_offset(pud, address);\n\t\tpmd_k = pmd_offset(pud_k, address);\n\t\tif (!pmd_present(*pmd_k))\n\t\t\tgoto no_context;\n\t\tset_pmd(pmd, *pmd_k);\n\n\t\tpte_k = pte_offset_kernel(pmd_k, address);\n\t\tif (!pte_present(*pte_k))\n\t\t\tgoto no_context;\n\t\treturn;\n\t}\n#endif\n}\n", "target": 1, "idx": 178959}
{"func": "void avcc_del(GF_Box *s)\n{\n\tGF_AVCConfigurationBox *ptr = (GF_AVCConfigurationBox *)s;\n\tif (ptr->config) gf_odf_avc_cfg_del(ptr->config);\n\tgf_free(ptr);\n}\n", "target": 0, "idx": 83992}
{"func": "static cJSON *get_object_item(const cJSON * const object, const char * const name, const cJSON_bool case_sensitive)\n{\n    cJSON *current_element = NULL;\n\n    if ((object == NULL) || (name == NULL))\n    {\n        return NULL;\n    }\n\n     current_element = object->child;\n     if (case_sensitive)\n     {\n        while ((current_element != NULL) && (strcmp(name, current_element->string) != 0))\n         {\n             current_element = current_element->next;\n         }\n    }\n    else\n    {\n        while ((current_element != NULL) && (case_insensitive_strcmp((const unsigned char*)name, (const unsigned char*)(current_element->string)) != 0))\n        {\n            current_element = current_element->next;\n         }\n     }\n \n     return current_element;\n }\n", "target": 1, "idx": 182652}
{"func": "METHODDEF(JDIMENSION)\nget_raw_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading raw-byte-format files with maxval = MAXJSAMPLE.\n * In this case we just read right into the JSAMPLE buffer!\n * Note that same code works for PPM and PGM files.\n */\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  return 1;\n}\n", "target": 0, "idx": 93218}
{"func": "void GLES2Implementation::DeleteTransferCacheEntry(uint32_t type, uint32_t id) {\n  NOTREACHED();\n}\n", "target": 0, "idx": 153623}
{"func": "image_transform_png_set_background_set(PNG_CONST image_transform *this,\n     transform_display *that, png_structp pp, png_infop pi)\n {\n    png_byte colour_type, bit_depth;\n   png_byte random_bytes[8]; /* 8 bytes - 64 bits - the biggest pixel */\n int expand;\n   png_color_16 back;\n\n /* We need a background colour, because we don't know exactly what transforms\n    * have been set we have to supply the colour in the original file format and\n    * so we need to know what that is!  The background colour is stored in the\n    * transform_display.\n    */\n   RANDOMIZE(random_bytes);\n\n /* Read the random value, for colour type 3 the background colour is actually\n    * expressed as a 24bit rgb, not an index.\n    */\n   colour_type = that->this.colour_type;\n if (colour_type == 3)\n {\n      colour_type = PNG_COLOR_TYPE_RGB;\n      bit_depth = 8;\n      expand = 0; /* passing in an RGB not a pixel index */\n }\n\n \n    else\n    {\n       bit_depth = that->this.bit_depth;\n       expand = 1;\n    }\n \n    image_pixel_init(&data, random_bytes, colour_type,\n      bit_depth, 0/*x*/, 0/*unused: palette*/);\n \n    /* Extract the background colour from this image_pixel, but make sure the\n     * unused fields of 'back' are garbage.\n    */\n   RANDOMIZE(back);\n\n if (colour_type & PNG_COLOR_MASK_COLOR)\n {\n      back.red = (png_uint_16)data.red;\n      back.green = (png_uint_16)data.green;\n      back.blue = (png_uint_16)data.blue;\n }\n\n else\n      back.gray = (png_uint_16)data.red;\n\n#  ifdef PNG_FLOATING_POINT_SUPPORTED\n      png_set_background(pp, &back, PNG_BACKGROUND_GAMMA_FILE, expand, 0);\n#  else\n      png_set_background_fixed(pp, &back, PNG_BACKGROUND_GAMMA_FILE, expand, 0);\n#  endif\n\n this->next->set(this->next, that, pp, pi);\n\n }\n", "target": 1, "idx": 187647}
{"func": "void BackgroundContentsService::Observe(\n    int type,\n    const content::NotificationSource& source,\n    const content::NotificationDetails& details) {\n  switch (type) {\n    case chrome::NOTIFICATION_EXTENSIONS_READY:\n      LoadBackgroundContentsFromManifests(\n          content::Source<Profile>(source).ptr());\n      LoadBackgroundContentsFromPrefs(content::Source<Profile>(source).ptr());\n      break;\n    case chrome::NOTIFICATION_BACKGROUND_CONTENTS_DELETED:\n      BackgroundContentsShutdown(\n          content::Details<BackgroundContents>(details).ptr());\n      break;\n    case chrome::NOTIFICATION_BACKGROUND_CONTENTS_CLOSED:\n      DCHECK(IsTracked(content::Details<BackgroundContents>(details).ptr()));\n      UnregisterBackgroundContents(\n          content::Details<BackgroundContents>(details).ptr());\n      break;\n    case chrome::NOTIFICATION_BACKGROUND_CONTENTS_NAVIGATED: {\n      DCHECK(IsTracked(content::Details<BackgroundContents>(details).ptr()));\n\n      BackgroundContents* bgcontents =\n          content::Details<BackgroundContents>(details).ptr();\n      Profile* profile = content::Source<Profile>(source).ptr();\n      const string16& appid = GetParentApplicationId(bgcontents);\n      ExtensionService* extension_service = profile->GetExtensionService();\n       if (extension_service) {\n         const Extension* extension =\n             extension_service->GetExtensionById(UTF16ToUTF8(appid), false);\n        if (extension && extension->background_url().is_valid())\n           break;\n       }\n       RegisterBackgroundContents(bgcontents);\n      break;\n    }\n    case chrome::NOTIFICATION_EXTENSION_LOADED: {\n      const Extension* extension =\n           content::Details<const Extension>(details).ptr();\n       Profile* profile = content::Source<Profile>(source).ptr();\n       if (extension->is_hosted_app() &&\n          extension->background_url().is_valid()) {\n         ShutdownAssociatedBackgroundContents(ASCIIToUTF16(extension->id()));\n\n        ExtensionService* service = profile->GetExtensionService();\n        if (service && service->is_ready()) {\n          LoadBackgroundContents(profile, extension->background_url(),\n               ASCIIToUTF16(\"background\"), UTF8ToUTF16(extension->id()));\n         }\n       }\n\n      ScheduleCloseBalloon(extension->id());\n      break;\n    }\n    case chrome::NOTIFICATION_EXTENSION_PROCESS_TERMINATED:\n    case chrome::NOTIFICATION_BACKGROUND_CONTENTS_TERMINATED: {\n      Profile* profile = content::Source<Profile>(source).ptr();\n      const Extension* extension = NULL;\n      if (type == chrome::NOTIFICATION_BACKGROUND_CONTENTS_TERMINATED) {\n        BackgroundContents* bg =\n            content::Details<BackgroundContents>(details).ptr();\n        std::string extension_id = UTF16ToASCII(\n            BackgroundContentsServiceFactory::GetForProfile(profile)->\n                GetParentApplicationId(bg));\n        extension =\n          profile->GetExtensionService()->GetExtensionById(extension_id, false);\n      } else {\n        ExtensionHost* extension_host =\n            content::Details<ExtensionHost>(details).ptr();\n        extension = extension_host->extension();\n      }\n      if (!extension)\n        break;\n\n      MessageLoop::current()->PostTask(\n          FROM_HERE, base::Bind(&ShowBalloon, extension, profile));\n      break;\n    }\n    case chrome::NOTIFICATION_EXTENSION_UNLOADED:\n      switch (content::Details<UnloadedExtensionInfo>(details)->reason) {\n        case extension_misc::UNLOAD_REASON_DISABLE:    // Fall through.\n        case extension_misc::UNLOAD_REASON_TERMINATE:  // Fall through.\n        case extension_misc::UNLOAD_REASON_UNINSTALL:\n          ShutdownAssociatedBackgroundContents(\n              ASCIIToUTF16(content::Details<UnloadedExtensionInfo>(details)->\n                  extension->id()));\n          break;\n        case extension_misc::UNLOAD_REASON_UPDATE: {\n           const Extension* extension =\n               content::Details<UnloadedExtensionInfo>(details)->extension;\n          if (extension->background_url().is_valid())\n             ShutdownAssociatedBackgroundContents(ASCIIToUTF16(extension->id()));\n           break;\n         }\n        default:\n          NOTREACHED();\n          ShutdownAssociatedBackgroundContents(\n              ASCIIToUTF16(content::Details<UnloadedExtensionInfo>(details)->\n                  extension->id()));\n          break;\n      }\n      break;\n\n    case chrome::NOTIFICATION_EXTENSION_UNINSTALLED: {\n      ScheduleCloseBalloon(*content::Details<const std::string>(details).ptr());\n      break;\n    }\n\n    default:\n      NOTREACHED();\n      break;\n  }\n}\n", "target": 1, "idx": 184592}
{"func": "static int ppp_gidle(unsigned int fd, unsigned int cmd,\n\t\tstruct ppp_idle32 __user *idle32)\n{\n\tstruct ppp_idle __user *idle;\n\t__kernel_time_t xmit, recv;\n\tint err;\n\n\tidle = compat_alloc_user_space(sizeof(*idle));\n\n\terr = sys_ioctl(fd, PPPIOCGIDLE, (unsigned long) idle);\n\n\tif (!err) {\n\t\tif (get_user(xmit, &idle->xmit_idle) ||\n\t\t    get_user(recv, &idle->recv_idle) ||\n\t\t    put_user(xmit, &idle32->xmit_idle) ||\n\t\t    put_user(recv, &idle32->recv_idle))\n\t\t\terr = -EFAULT;\n\t}\n\treturn err;\n}\n", "target": 0, "idx": 32823}
{"func": "ofproto_type_run(const char *datapath_type)\n{\n    const struct ofproto_class *class;\n    int error;\n\n    datapath_type = ofproto_normalize_type(datapath_type);\n    class = ofproto_class_find__(datapath_type);\n\n    error = class->type_run ? class->type_run(datapath_type) : 0;\n    if (error && error != EAGAIN) {\n        VLOG_ERR_RL(&rl, \"%s: type_run failed (%s)\",\n                    datapath_type, ovs_strerror(error));\n    }\n    return error;\n}\n", "target": 0, "idx": 77399}
{"func": "void NavigationController::GoToIndex(int index) {\n  if (index < 0 || index >= static_cast<int>(entries_.size())) {\n    NOTREACHED();\n    return;\n  }\n\n  if (transient_entry_index_ != -1) {\n    if (index == transient_entry_index_) {\n      return;\n    }\n    if (index > transient_entry_index_) {\n      index--;\n     }\n   }\n \n  if (tab_contents_->interstitial_page()) {\n    if (index == GetCurrentEntryIndex() - 1) {\n      tab_contents_->interstitial_page()->DontProceed();\n      return;\n    } else {\n      tab_contents_->interstitial_page()->CancelForNavigation();\n    }\n  }\n   DiscardNonCommittedEntries();\n \n   pending_entry_index_ = index;\n  entries_[pending_entry_index_]->set_transition_type(\n      content::PageTransitionFromInt(\n          entries_[pending_entry_index_]->transition_type() |\n          content::PAGE_TRANSITION_FORWARD_BACK));\n  NavigateToPendingEntry(NO_RELOAD);\n}\n", "target": 1, "idx": 184663}
{"func": "int x86_set_memory_region(struct kvm *kvm, int id, gpa_t gpa, u32 size)\n{\n\tint r;\n\n\tmutex_lock(&kvm->slots_lock);\n\tr = __x86_set_memory_region(kvm, id, gpa, size);\n\tmutex_unlock(&kvm->slots_lock);\n\n\treturn r;\n}\n", "target": 0, "idx": 57810}
{"func": "void TabStrip::SetDropArrow(\n    const base::Optional<BrowserRootView::DropIndex>& index) {\n  if (!index) {\n    controller_->OnDropIndexUpdate(-1, false);\n    drop_arrow_.reset();\n    return;\n  }\n\n  controller_->OnDropIndexUpdate(index->value, index->drop_before);\n\n  if (drop_arrow_ && (index == drop_arrow_->index))\n    return;\n\n  bool is_beneath;\n  gfx::Rect drop_bounds =\n      GetDropBounds(index->value, index->drop_before, &is_beneath);\n\n  if (!drop_arrow_) {\n    drop_arrow_ = std::make_unique<DropArrow>(*index, !is_beneath, GetWidget());\n  } else {\n    drop_arrow_->index = *index;\n    if (is_beneath == drop_arrow_->point_down) {\n      drop_arrow_->point_down = !is_beneath;\n      drop_arrow_->arrow_view->SetImage(\n          GetDropArrowImage(drop_arrow_->point_down));\n    }\n  }\n\n  drop_arrow_->arrow_window->SetBounds(drop_bounds);\n  drop_arrow_->arrow_window->Show();\n}\n", "target": 0, "idx": 153466}
{"func": " static void skcipher_release(void *private)\n {\n\tcrypto_free_skcipher(private);\n }\n", "target": 1, "idx": 180628}
{"func": "gsicc_new_devicen(gsicc_manager_t *icc_manager)\n{\n/* Allocate a new deviceN ICC profile entry in the deviceN list */\n    gsicc_devicen_entry_t *device_n_entry =\n        gs_alloc_struct(icc_manager->memory, gsicc_devicen_entry_t,\n                &st_gsicc_devicen_entry, \"gsicc_new_devicen\");\n    if (device_n_entry == NULL)\n        return gs_throw(gs_error_VMerror, \"insufficient memory to allocate device n profile\");\n    device_n_entry->next = NULL;\n    device_n_entry->iccprofile = NULL;\n/* Check if we already have one in the manager */\n    if ( icc_manager->device_n == NULL ) {\n        /* First one.  Need to allocate the DeviceN main object */\n        icc_manager->device_n = gs_alloc_struct(icc_manager->memory,\n            gsicc_devicen_t, &st_gsicc_devicen, \"gsicc_new_devicen\");\n\n        if (icc_manager->device_n == NULL)\n            return gs_throw(gs_error_VMerror, \"insufficient memory to allocate device n profile\");\n\n        icc_manager->device_n->head = device_n_entry;\n        icc_manager->device_n->final = device_n_entry;\n        icc_manager->device_n->count = 1;\n        return 0;\n    } else {\n        /* We have one or more in the list. */\n        icc_manager->device_n->final->next = device_n_entry;\n        icc_manager->device_n->final = device_n_entry;\n        icc_manager->device_n->count++;\n        return 0;\n    }\n}\n", "target": 0, "idx": 13983}
{"func": "void HTMLSelectElement::accessKeySetSelectedIndex(int index)\n{    \n    if (!focused())\n        accessKeyAction(false);\n    \n    const Vector<HTMLElement*>& items = listItems();\n    int listIndex = optionToListIndex(index);\n    if (listIndex >= 0) {\n        HTMLElement* element = items[listIndex];\n        if (element->hasTagName(optionTag)) {\n            if (toHTMLOptionElement(element)->selected())\n                toHTMLOptionElement(element)->setSelectedState(false);\n            else\n                selectOption(index, DispatchChangeEvent | UserDriven);\n        }\n    }\n\n    if (usesMenuList())\n        dispatchChangeEventForMenuList();\n    else\n        listBoxOnChange();\n\n    scrollToSelection();\n}\n", "target": 0, "idx": 109994}
{"func": "void ApiTestEnvironment::RunPromisesAgain() {\n  env()->isolate()->RunMicrotasks();\n  base::MessageLoop::current()->PostTask(\n      FROM_HERE, base::Bind(&ApiTestEnvironment::RunPromisesAgain,\n                            base::Unretained(this)));\n}\n", "target": 0, "idx": 145716}
{"func": "static void xfrm6_tunnel_spi_fini(void)\n{\n\tkmem_cache_destroy(xfrm6_tunnel_spi_kmem);\n}\n", "target": 1, "idx": 179053}
{"func": "ResourceFetcher::DetermineRevalidationPolicyInternal(\n    Resource::Type type,\n    const FetchParameters& fetch_params,\n    const Resource& existing_resource,\n    bool is_static_data) const {\n  const ResourceRequest& request = fetch_params.GetResourceRequest();\n\n  if (IsDownloadOrStreamRequest(request))\n    return kReload;\n\n  if (IsImageResourceDisallowedToBeReused(existing_resource))\n    return kReload;\n\n  if (existing_resource.Loader() &&\n      existing_resource.Loader()->Fetcher() != this) {\n    return kReload;\n  }\n\n  if ((fetch_params.IsLinkPreload() || fetch_params.IsSpeculativePreload()) &&\n      existing_resource.IsUnusedPreload()) {\n    return kReload;\n  }\n\n  if (existing_resource.MustRefetchDueToIntegrityMetadata(fetch_params)) {\n    return kReload;\n  }\n\n  if (existing_resource.GetType() != type) {\n    RESOURCE_LOADING_DVLOG(1) << \"ResourceFetcher::DetermineRevalidationPolicy \"\n                                 \"reloading due to type mismatch.\";\n    return kReload;\n  }\n\n  if (is_static_data)\n    return kUse;\n\n  if (!existing_resource.CanReuse(fetch_params)) {\n    RESOURCE_LOADING_DVLOG(1) << \"ResourceFetcher::DetermineRevalidationPolicy \"\n                                 \"reloading due to Resource::CanReuse() \"\n                                 \"returning false.\";\n    return kReload;\n  }\n\n  if (allow_stale_resources_)\n    return kUse;\n\n  if (request.GetCachePolicy() == WebCachePolicy::kReturnCacheDataElseLoad)\n    return kUse;\n\n  if (existing_resource.HasCacheControlNoStoreHeader()) {\n    RESOURCE_LOADING_DVLOG(1) << \"ResourceFetcher::DetermineRevalidationPolicy \"\n                                 \"reloading due to Cache-control: no-store.\";\n    return kReload;\n  }\n\n  if (type != Resource::kRaw) {\n    if (!Context().IsLoadComplete() &&\n        cached_resources_map_.Contains(\n            MemoryCache::RemoveFragmentIdentifierIfNeeded(\n                existing_resource.Url())))\n      return kUse;\n    if (existing_resource.IsLoading())\n      return kUse;\n  }\n\n  if (request.GetCachePolicy() == WebCachePolicy::kBypassingCache) {\n    RESOURCE_LOADING_DVLOG(1) << \"ResourceFetcher::DetermineRevalidationPolicy \"\n                                 \"reloading due to \"\n                                 \"WebCachePolicy::BypassingCache.\";\n    return kReload;\n  }\n\n  if (existing_resource.ErrorOccurred()) {\n    RESOURCE_LOADING_DVLOG(1) << \"ResourceFetcher::DetermineRevalidationPolicy \"\n                                 \"reloading due to resource being in the error \"\n                                 \"state\";\n    return kReload;\n  }\n\n  if (type == Resource::kImage &&\n      &existing_resource == CachedResource(request.Url())) {\n    return kUse;\n  }\n\n  if (existing_resource.MustReloadDueToVaryHeader(request))\n    return kReload;\n\n  if (!existing_resource.CanReuseRedirectChain()) {\n    RESOURCE_LOADING_DVLOG(1) << \"ResourceFetcher::DetermineRevalidationPolicy \"\n                                 \"reloading due to an uncacheable redirect\";\n    return kReload;\n  }\n\n  if (request.GetCachePolicy() == WebCachePolicy::kValidatingCacheData ||\n      existing_resource.MustRevalidateDueToCacheHeaders() ||\n      request.CacheControlContainsNoCache()) {\n    if (existing_resource.IsUnusedPreload())\n      return kReload;\n\n    if (existing_resource.CanUseCacheValidator() &&\n        !Context().IsControlledByServiceWorker()) {\n      if (existing_resource.IsCacheValidator()) {\n        DCHECK(existing_resource.StillNeedsLoad());\n        return kUse;\n      }\n      return kRevalidate;\n    }\n\n    RESOURCE_LOADING_DVLOG(1) << \"ResourceFetcher::DetermineRevalidationPolicy \"\n                                 \"reloading due to missing cache validators.\";\n    return kReload;\n  }\n\n  return kUse;\n}\n", "target": 0, "idx": 151557}
{"func": "static TEE_Result op_attr_bignum_from_user(void *attr, const void *buffer,\n\t\t\t\t\t   size_t size)\n{\n\tstruct bignum **bn = attr;\n\n\treturn crypto_bignum_bin2bn(buffer, size, *bn);\n}\n", "target": 0, "idx": 86841}
{"func": "PHP_FUNCTION(pg_lo_write)\n{\n  \tzval *pgsql_id;\n  \tchar *str;\n  \tzend_long z_len;\n\tsize_t str_len, nbytes;\n\tsize_t len;\n\tpgLofp *pgsql;\n\tint argc = ZEND_NUM_ARGS();\n\n\tif (zend_parse_parameters(argc, \"rs|l\", &pgsql_id, &str, &str_len, &z_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (argc > 2) {\n\t\tif (z_len > (zend_long)str_len) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"Cannot write more than buffer size %d. Tried to write %pd\", str_len, z_len);\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tif (z_len < 0) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"Buffer size must be larger than 0, but %pd was specified\", z_len);\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tlen = z_len;\n\t}\n\telse {\n\t\tlen = str_len;\n\t}\n\n\tZEND_FETCH_RESOURCE(pgsql, pgLofp *, pgsql_id, -1, \"PostgreSQL large object\", le_lofp);\n\n\tif ((nbytes = lo_write((PGconn *)pgsql->conn, pgsql->lofd, str, len)) == -1) {\n\t\tRETURN_FALSE;\n\t}\n\n\tRETURN_LONG(nbytes);\n}\n", "target": 0, "idx": 5162}
{"func": "static int dccp_packet(struct nf_conn *ct, const struct sk_buff *skb,\n\t\t       unsigned int dataoff, enum ip_conntrack_info ctinfo,\n\t\t       u_int8_t pf, unsigned int hooknum,\n\t\t       unsigned int *timeouts)\n{\n\tstruct net *net = nf_ct_net(ct);\n\tenum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);\n\tstruct dccp_hdr _dh, *dh;\n \tu_int8_t type, old_state, new_state;\n \tenum ct_dccp_roles role;\n \n\tdh = skb_header_pointer(skb, dataoff, sizeof(_dh), &dh);\n \tBUG_ON(dh == NULL);\n \ttype = dh->dccph_type;\n \n\tif (type == DCCP_PKT_RESET &&\n\t    !test_bit(IPS_SEEN_REPLY_BIT, &ct->status)) {\n\t\t/* Tear down connection immediately if only reply is a RESET */\n\t\tnf_ct_kill_acct(ct, ctinfo, skb);\n\t\treturn NF_ACCEPT;\n\t}\n\n\tspin_lock_bh(&ct->lock);\n\n\trole = ct->proto.dccp.role[dir];\n\told_state = ct->proto.dccp.state;\n\tnew_state = dccp_state_table[role][type][old_state];\n\n\tswitch (new_state) {\n\tcase CT_DCCP_REQUEST:\n\t\tif (old_state == CT_DCCP_TIMEWAIT &&\n\t\t    role == CT_DCCP_ROLE_SERVER) {\n\t\t\t/* Reincarnation in the reverse direction: reopen and\n\t\t\t * reverse client/server roles. */\n\t\t\tct->proto.dccp.role[dir] = CT_DCCP_ROLE_CLIENT;\n\t\t\tct->proto.dccp.role[!dir] = CT_DCCP_ROLE_SERVER;\n\t\t}\n\t\tbreak;\n\tcase CT_DCCP_RESPOND:\n\t\tif (old_state == CT_DCCP_REQUEST)\n\t\t\tct->proto.dccp.handshake_seq = dccp_hdr_seq(dh);\n\t\tbreak;\n\tcase CT_DCCP_PARTOPEN:\n\t\tif (old_state == CT_DCCP_RESPOND &&\n\t\t    type == DCCP_PKT_ACK &&\n\t\t    dccp_ack_seq(dh) == ct->proto.dccp.handshake_seq)\n\t\t\tset_bit(IPS_ASSURED_BIT, &ct->status);\n\t\tbreak;\n\tcase CT_DCCP_IGNORE:\n\t\t/*\n\t\t * Connection tracking might be out of sync, so we ignore\n\t\t * packets that might establish a new connection and resync\n\t\t * if the server responds with a valid Response.\n\t\t */\n\t\tif (ct->proto.dccp.last_dir == !dir &&\n\t\t    ct->proto.dccp.last_pkt == DCCP_PKT_REQUEST &&\n\t\t    type == DCCP_PKT_RESPONSE) {\n\t\t\tct->proto.dccp.role[!dir] = CT_DCCP_ROLE_CLIENT;\n\t\t\tct->proto.dccp.role[dir] = CT_DCCP_ROLE_SERVER;\n\t\t\tct->proto.dccp.handshake_seq = dccp_hdr_seq(dh);\n\t\t\tnew_state = CT_DCCP_RESPOND;\n\t\t\tbreak;\n\t\t}\n\t\tct->proto.dccp.last_dir = dir;\n\t\tct->proto.dccp.last_pkt = type;\n\n\t\tspin_unlock_bh(&ct->lock);\n\t\tif (LOG_INVALID(net, IPPROTO_DCCP))\n\t\t\tnf_log_packet(net, pf, 0, skb, NULL, NULL, NULL,\n\t\t\t\t      \"nf_ct_dccp: invalid packet ignored \");\n\t\treturn NF_ACCEPT;\n\tcase CT_DCCP_INVALID:\n\t\tspin_unlock_bh(&ct->lock);\n\t\tif (LOG_INVALID(net, IPPROTO_DCCP))\n\t\t\tnf_log_packet(net, pf, 0, skb, NULL, NULL, NULL,\n\t\t\t\t      \"nf_ct_dccp: invalid state transition \");\n\t\treturn -NF_ACCEPT;\n\t}\n\n\tct->proto.dccp.last_dir = dir;\n\tct->proto.dccp.last_pkt = type;\n\tct->proto.dccp.state = new_state;\n\tspin_unlock_bh(&ct->lock);\n\n\tif (new_state != old_state)\n\t\tnf_conntrack_event_cache(IPCT_PROTOINFO, ct);\n\n\tnf_ct_refresh_acct(ct, ctinfo, skb, timeouts[new_state]);\n\n\treturn NF_ACCEPT;\n}\n", "target": 1, "idx": 179594}
{"func": "inline bool SearchBuffer::isBadMatch(const UChar* match, size_t matchLength) const\n{\n    if (!m_targetRequiresKanaWorkaround)\n        return false;\n\n    normalizeCharacters(match, matchLength, m_normalizedMatch);\n\n    const UChar* a = m_normalizedTarget.begin();\n    const UChar* aEnd = m_normalizedTarget.end();\n\n    const UChar* b = m_normalizedMatch.begin();\n    const UChar* bEnd = m_normalizedMatch.end();\n\n    while (true) {\n        while (a != aEnd && !isKanaLetter(*a))\n            ++a;\n        while (b != bEnd && !isKanaLetter(*b))\n            ++b;\n\n        if (a == aEnd || b == bEnd) {\n            ASSERT(a == aEnd);\n            ASSERT(b == bEnd);\n            return false;\n        }\n\n        if (isSmallKanaLetter(*a) != isSmallKanaLetter(*b))\n            return true;\n        if (composedVoicedSoundMark(*a) != composedVoicedSoundMark(*b))\n            return true;\n        ++a;\n        ++b;\n\n        while (1) {\n            if (!(a != aEnd && isCombiningVoicedSoundMark(*a))) {\n                if (b != bEnd && isCombiningVoicedSoundMark(*b))\n                    return true;\n                break;\n            }\n            if (!(b != bEnd && isCombiningVoicedSoundMark(*b)))\n                return true;\n            if (*a != *b)\n                return true;\n            ++a;\n            ++b;\n        }\n    }\n}\n", "target": 0, "idx": 121609}
{"func": "_exsltDateTruncateDate (exsltDateValPtr dt, exsltDateType type)\n{\n    if (dt == NULL)\n        return 1;\n\n    if ((type & XS_TIME) != XS_TIME) {\n        dt->value.date.hour = 0;\n        dt->value.date.min  = 0;\n        dt->value.date.sec  = 0.0;\n     }\n \n     if ((type & XS_GDAY) != XS_GDAY)\n        dt->value.date.day = 0;\n \n     if ((type & XS_GMONTH) != XS_GMONTH)\n        dt->value.date.mon = 0;\n \n     if ((type & XS_GYEAR) != XS_GYEAR)\n         dt->value.date.year = 0;\n\n    dt->type = type;\n\n    return 0;\n}\n", "target": 1, "idx": 187312}
{"func": "long Chapters::Atom::ParseDisplay(\n    IMkvReader* pReader,\n    long long pos,\n    long long size)\n{\n    if (!ExpandDisplaysArray())\n        return -1;\n    Display& d = m_displays[m_displays_count++];\n    d.Init();\n    return d.Parse(pReader, pos, size);\n}\n", "target": 1, "idx": 188444}
{"func": "static Image *ReadSTEGANOImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n#define GetBit(alpha,i) MagickMin((((size_t) (alpha) >> (size_t) \\\n  (i)) & 0x01),16)\n#define SetBit(indexes,i,set) SetPixelIndex(indexes,((set) != 0 ? \\\n  (size_t) GetPixelIndex(indexes) | (one << (size_t) (i)) : (size_t) \\\n  GetPixelIndex(indexes) & ~(one << (size_t) (i))))\n\n  Image\n    *image,\n    *watermark;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c;\n\n  MagickBooleanType\n    status;\n\n  PixelPacket\n    pixel;\n\n  register IndexPacket\n    *indexes;\n\n  register PixelPacket\n    *q;\n\n  register ssize_t\n    x;\n\n  size_t\n    depth,\n    one;\n\n  ssize_t\n    i,\n    j,\n    k,\n    y;\n\n  /*\n    Initialize Image structure.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  one=1;\n  image=AcquireImage(image_info);\n  if ((image->columns == 0) || (image->rows == 0))\n    ThrowReaderException(OptionError,\"MustSpecifyImageSize\");\n  read_info=CloneImageInfo(image_info);\n  SetImageInfoBlob(read_info,(void *) NULL,0);\n  *read_info->magick='\\0';\n  watermark=ReadImage(read_info,exception);\n  read_info=DestroyImageInfo(read_info);\n  if (watermark == (Image *) NULL)\n    return((Image *) NULL);\n  watermark->depth=MAGICKCORE_QUANTUM_DEPTH;\n  if (AcquireImageColormap(image,MaxColormapSize) == MagickFalse)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  if (image_info->ping != MagickFalse)\n    {\n       (void) CloseBlob(image);\n       return(GetFirstImageInList(image));\n     }\n   /*\n     Get hidden watermark from low-order bits of image.\n   */\n  c=0;\n  i=0;\n  j=0;\n  i=(ssize_t) (watermark->depth-1);\n  depth=watermark->depth;\n  for (k=image->offset; (i >= 0) && (j < (ssize_t) depth); i--)\n  {\n    for (y=0; (y < (ssize_t) image->rows) && (j < (ssize_t) depth); y++)\n    {\n      x=0;\n      for ( ; (x < (ssize_t) image->columns) && (j < (ssize_t) depth); x++)\n      {\n        if ((k/(ssize_t) watermark->columns) >= (ssize_t) watermark->rows)\n          break;\n        (void) GetOneVirtualPixel(watermark,k % (ssize_t) watermark->columns,\n          k/(ssize_t) watermark->columns,&pixel,exception);\n        q=GetAuthenticPixels(image,x,y,1,1,exception);\n        if (q == (PixelPacket *) NULL)\n          break;\n        indexes=GetAuthenticIndexQueue(image);\n        switch (c)\n        {\n          case 0:\n          {\n            SetBit(indexes,i,GetBit(pixel.red,j));\n            break;\n          }\n          case 1:\n          {\n            SetBit(indexes,i,GetBit(pixel.green,j));\n            break;\n          }\n          case 2:\n          {\n            SetBit(indexes,i,GetBit(pixel.blue,j));\n            break;\n          }\n        }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        c++;\n        if (c == 3)\n          c=0;\n        k++;\n        if (k == (ssize_t) (watermark->columns*watermark->columns))\n          k=0;\n        if (k == image->offset)\n          j++;\n      }\n    }\n    status=SetImageProgress(image,LoadImagesTag,(MagickOffsetType) i,depth);\n    if (status == MagickFalse)\n      break;\n  }\n  watermark=DestroyImage(watermark);\n  (void) SyncImage(image);\n  return(GetFirstImageInList(image));\n}\n", "target": 1, "idx": 181777}
{"func": "  void CallbackAndDie(bool succeeded) {\n    v8::Isolate* isolate = context_->isolate();\n    v8::HandleScope handle_scope(isolate);\n    v8::Local<v8::Value> args[] = {v8::Boolean::New(isolate, succeeded)};\n    context_->CallFunction(v8::Local<v8::Function>::New(isolate, callback_),\n                           arraysize(args), args);\n     delete this;\n   }\n", "target": 1, "idx": 186112}
{"func": "void GpuCommandBufferStub::OnCreateTransferBuffer(int32 size,\n                                                   int32 id_request,\n                                                   IPC::Message* reply_message) {\n   TRACE_EVENT0(\"gpu\", \"GpuCommandBufferStub::OnCreateTransferBuffer\");\n  if (command_buffer_.get()) {\n    int32 id = command_buffer_->CreateTransferBuffer(size, id_request);\n    GpuCommandBufferMsg_CreateTransferBuffer::WriteReplyParams(\n        reply_message, id);\n  } else {\n    reply_message->set_reply_error();\n  }\n  Send(reply_message);\n}\n", "target": 1, "idx": 185103}
{"func": "ZEND_METHOD(CURLFile, getMimeType)\n{\n\tcurlfile_get_property(\"mime\", INTERNAL_FUNCTION_PARAM_PASSTHRU);\n}\n", "target": 0, "idx": 13861}
{"func": "int ParseDsdiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)\n{\n    int64_t infilesize, total_samples;\n    DFFFileHeader dff_file_header;\n    DFFChunkHeader dff_chunk_header;\n    uint32_t bcount;\n\n    infilesize = DoGetFileSize (infile);\n    memcpy (&dff_file_header, fourcc, 4);\n\n    if ((!DoReadFile (infile, ((char *) &dff_file_header) + 4, sizeof (DFFFileHeader) - 4, &bcount) ||\n        bcount != sizeof (DFFFileHeader) - 4) || strncmp (dff_file_header.formType, \"DSD \", 4)) {\n            error_line (\"%s is not a valid .DFF file!\", infilename);\n            return WAVPACK_SOFT_ERROR;\n    }\n    else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n        !WavpackAddWrapper (wpc, &dff_file_header, sizeof (DFFFileHeader))) {\n            error_line (\"%s\", WavpackGetErrorMessage (wpc));\n            return WAVPACK_SOFT_ERROR;\n    }\n\n#if 1   // this might be a little too picky...\n    WavpackBigEndianToNative (&dff_file_header, DFFFileHeaderFormat);\n\n    if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) &&\n        dff_file_header.ckDataSize && dff_file_header.ckDataSize + 1 && dff_file_header.ckDataSize + 12 != infilesize) {\n            error_line (\"%s is not a valid .DFF file (by total size)!\", infilename);\n            return WAVPACK_SOFT_ERROR;\n    }\n\n    if (debug_logging_mode)\n        error_line (\"file header indicated length = %lld\", dff_file_header.ckDataSize);\n\n#endif\n\n\n    while (1) {\n        if (!DoReadFile (infile, &dff_chunk_header, sizeof (DFFChunkHeader), &bcount) ||\n            bcount != sizeof (DFFChunkHeader)) {\n                error_line (\"%s is not a valid .DFF file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n        }\n        else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n            !WavpackAddWrapper (wpc, &dff_chunk_header, sizeof (DFFChunkHeader))) {\n                error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                return WAVPACK_SOFT_ERROR;\n        }\n\n        WavpackBigEndianToNative (&dff_chunk_header, DFFChunkHeaderFormat);\n\n        if (debug_logging_mode)\n            error_line (\"chunk header indicated length = %lld\", dff_chunk_header.ckDataSize);\n\n        if (!strncmp (dff_chunk_header.ckID, \"FVER\", 4)) {\n            uint32_t version;\n\n            if (dff_chunk_header.ckDataSize != sizeof (version) ||\n                !DoReadFile (infile, &version, sizeof (version), &bcount) ||\n                bcount != sizeof (version)) {\n                    error_line (\"%s is not a valid .DFF file!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, &version, sizeof (version))) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            WavpackBigEndianToNative (&version, \"L\");\n\n            if (debug_logging_mode)\n                error_line (\"dsdiff file version = 0x%08x\", version);\n        }\n        else if (!strncmp (dff_chunk_header.ckID, \"PROP\", 4)) {\n            char *prop_chunk;\n\n            if (dff_chunk_header.ckDataSize < 4 || dff_chunk_header.ckDataSize > 1024) {\n                error_line (\"%s is not a valid .DFF file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            if (debug_logging_mode)\n                error_line (\"got PROP chunk of %d bytes total\", (int) dff_chunk_header.ckDataSize);\n\n            prop_chunk = malloc ((size_t) dff_chunk_header.ckDataSize);\n\n            if (!DoReadFile (infile, prop_chunk, (uint32_t) dff_chunk_header.ckDataSize, &bcount) ||\n                bcount != dff_chunk_header.ckDataSize) {\n                    error_line (\"%s is not a valid .DFF file!\", infilename);\n                    free (prop_chunk);\n                    return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, prop_chunk, (uint32_t) dff_chunk_header.ckDataSize)) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    free (prop_chunk);\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            if (!strncmp (prop_chunk, \"SND \", 4)) {\n                char *cptr = prop_chunk + 4, *eptr = prop_chunk + dff_chunk_header.ckDataSize;\n                uint16_t numChannels, chansSpecified, chanMask = 0;\n                uint32_t sampleRate;\n\n                while (eptr - cptr >= sizeof (dff_chunk_header)) {\n                    memcpy (&dff_chunk_header, cptr, sizeof (dff_chunk_header));\n                    cptr += sizeof (dff_chunk_header);\n                    WavpackBigEndianToNative (&dff_chunk_header, DFFChunkHeaderFormat);\n\n                    if (eptr - cptr >= dff_chunk_header.ckDataSize) {\n                        if (!strncmp (dff_chunk_header.ckID, \"FS  \", 4) && dff_chunk_header.ckDataSize == 4) {\n                            memcpy (&sampleRate, cptr, sizeof (sampleRate));\n                            WavpackBigEndianToNative (&sampleRate, \"L\");\n                            cptr += dff_chunk_header.ckDataSize;\n\n                            if (debug_logging_mode)\n                                error_line (\"got sample rate of %u Hz\", sampleRate);\n                        }\n                        else if (!strncmp (dff_chunk_header.ckID, \"CHNL\", 4) && dff_chunk_header.ckDataSize >= 2) {\n                            memcpy (&numChannels, cptr, sizeof (numChannels));\n                            WavpackBigEndianToNative (&numChannels, \"S\");\n                            cptr += sizeof (numChannels);\n\n                            chansSpecified = (int)(dff_chunk_header.ckDataSize - sizeof (numChannels)) / 4;\n\n                            while (chansSpecified--) {\n                                if (!strncmp (cptr, \"SLFT\", 4) || !strncmp (cptr, \"MLFT\", 4))\n                                    chanMask |= 0x1;\n                                else if (!strncmp (cptr, \"SRGT\", 4) || !strncmp (cptr, \"MRGT\", 4))\n                                    chanMask |= 0x2;\n                                else if (!strncmp (cptr, \"LS  \", 4))\n                                    chanMask |= 0x10;\n                                else if (!strncmp (cptr, \"RS  \", 4))\n                                    chanMask |= 0x20;\n                                else if (!strncmp (cptr, \"C   \", 4))\n                                    chanMask |= 0x4;\n                                else if (!strncmp (cptr, \"LFE \", 4))\n                                    chanMask |= 0x8;\n                                else\n                                    if (debug_logging_mode)\n                                        error_line (\"undefined channel ID %c%c%c%c\", cptr [0], cptr [1], cptr [2], cptr [3]);\n\n                                cptr += 4;\n                            }\n\n                            if (debug_logging_mode)\n                                error_line (\"%d channels, mask = 0x%08x\", numChannels, chanMask);\n                        }\n                        else if (!strncmp (dff_chunk_header.ckID, \"CMPR\", 4) && dff_chunk_header.ckDataSize >= 4) {\n                            if (strncmp (cptr, \"DSD \", 4)) {\n                                error_line (\"DSDIFF files must be uncompressed, not \\\"%c%c%c%c\\\"!\",\n                                    cptr [0], cptr [1], cptr [2], cptr [3]);\n                                free (prop_chunk);\n                                return WAVPACK_SOFT_ERROR;\n                            }\n\n                            cptr += dff_chunk_header.ckDataSize;\n                        }\n                        else {\n                            if (debug_logging_mode)\n                                error_line (\"got PROP/SND chunk type \\\"%c%c%c%c\\\" of %d bytes\", dff_chunk_header.ckID [0],\n                                    dff_chunk_header.ckID [1], dff_chunk_header.ckID [2], dff_chunk_header.ckID [3], dff_chunk_header.ckDataSize);\n\n                            cptr += dff_chunk_header.ckDataSize;\n                        }\n                    }\n                    else {\n                        error_line (\"%s is not a valid .DFF file!\", infilename);\n                        free (prop_chunk);\n                        return WAVPACK_SOFT_ERROR;\n                    }\n                }\n\n                if (chanMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) {\n                    error_line (\"this DSDIFF file already has channel order information!\");\n                    free (prop_chunk);\n                    return WAVPACK_SOFT_ERROR;\n                }\n                else if (chanMask)\n                    config->channel_mask = chanMask;\n\n                config->bits_per_sample = 8;\n                config->bytes_per_sample = 1;\n                config->num_channels = numChannels;\n                config->sample_rate = sampleRate / 8;\n                config->qmode |= QMODE_DSD_MSB_FIRST;\n            }\n            else if (debug_logging_mode)\n                error_line (\"got unknown PROP chunk type \\\"%c%c%c%c\\\" of %d bytes\",\n                    prop_chunk [0], prop_chunk [1], prop_chunk [2], prop_chunk [3], dff_chunk_header.ckDataSize);\n\n            free (prop_chunk);\n        }\n        else if (!strncmp (dff_chunk_header.ckID, \"DSD \", 4)) {\n            total_samples = dff_chunk_header.ckDataSize / config->num_channels;\n            break;\n        }\n         else {          // just copy unknown chunks to output file\n \n             int bytes_to_copy = (int)(((dff_chunk_header.ckDataSize) + 1) & ~(int64_t)1);\n            char *buff = malloc (bytes_to_copy);\n \n             if (debug_logging_mode)\n                 error_line (\"extra unknown chunk \\\"%c%c%c%c\\\" of %d bytes\",\n                    dff_chunk_header.ckID [0], dff_chunk_header.ckID [1], dff_chunk_header.ckID [2],\n                    dff_chunk_header.ckID [3], dff_chunk_header.ckDataSize);\n\n            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||\n                bcount != bytes_to_copy ||\n                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    free (buff);\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            free (buff);\n        }\n    }\n\n    if (debug_logging_mode)\n        error_line (\"setting configuration with %lld samples\", total_samples);\n\n    if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) {\n        error_line (\"%s: %s\", infilename, WavpackGetErrorMessage (wpc));\n        return WAVPACK_SOFT_ERROR;\n    }\n\n    return WAVPACK_NO_ERROR;\n}\n", "target": 1, "idx": 182421}
{"func": " void AppCacheGroup::RemoveCache(AppCache* cache) {\n   DCHECK(cache->associated_hosts().empty());\n   if (cache == newest_complete_cache_) {\n    CancelUpdate();\n     AppCache* tmp_cache = newest_complete_cache_;\n     newest_complete_cache_ = nullptr;\n     tmp_cache->set_owning_group(nullptr);  // may cause this group to be deleted\n   } else {\n     scoped_refptr<AppCacheGroup> protect(this);\n\n    Caches::iterator it =\n        std::find(old_caches_.begin(), old_caches_.end(), cache);\n    if (it != old_caches_.end()) {\n      AppCache* tmp_cache = *it;\n      old_caches_.erase(it);\n      tmp_cache->set_owning_group(nullptr);  // may cause group to be released\n    }\n\n    if (!is_obsolete() && old_caches_.empty() &&\n        !newly_deletable_response_ids_.empty()) {\n      storage_->DeleteResponses(manifest_url_, newly_deletable_response_ids_);\n      newly_deletable_response_ids_.clear();\n    }\n  }\n}\n", "target": 1, "idx": 186630}
{"func": "OMX_ERRORTYPE  omx_vdec::get_config(OMX_IN OMX_HANDLETYPE      hComp,\n        OMX_IN OMX_INDEXTYPE configIndex,\n        OMX_INOUT OMX_PTR     configData)\n{\n (void) hComp;\n    OMX_ERRORTYPE eRet = OMX_ErrorNone;\n\n if (m_state == OMX_StateInvalid) {\n        DEBUG_PRINT_ERROR(\"Get Config in Invalid State\");\n return OMX_ErrorInvalidState;\n }\n\n \n     switch ((unsigned long)configIndex) {\n         case OMX_QcomIndexConfigInterlaced: {\n                                 OMX_QCOM_CONFIG_INTERLACETYPE *configFmt =\n                                     (OMX_QCOM_CONFIG_INTERLACETYPE *) configData;\n                                 if (configFmt->nPortIndex == 1) {\n if (configFmt->nIndex == 0) {\n                                        configFmt->eInterlaceType = OMX_QCOM_InterlaceFrameProgressive;\n } else if (configFmt->nIndex == 1) {\n                                        configFmt->eInterlaceType =\n                                            OMX_QCOM_InterlaceInterleaveFrameTopFieldFirst;\n } else if (configFmt->nIndex == 2) {\n                                        configFmt->eInterlaceType =\n                                            OMX_QCOM_InterlaceInterleaveFrameBottomFieldFirst;\n } else {\n                                        DEBUG_PRINT_ERROR(\"get_config: OMX_QcomIndexConfigInterlaced:\"\n \" NoMore Interlaced formats\");\n                                        eRet = OMX_ErrorNoMore;\n }\n\n } else {\n                                    DEBUG_PRINT_ERROR(\"get_config: Bad port index %d queried on only o/p port\",\n (int)configFmt->nPortIndex);\n                                    eRet = OMX_ErrorBadPortIndex;\n }\n\n                                 break;\n                             }\n         case OMX_QcomIndexQueryNumberOfVideoDecInstance: {\n                                      QOMX_VIDEO_QUERY_DECODER_INSTANCES *decoderinstances =\n                                          (QOMX_VIDEO_QUERY_DECODER_INSTANCES*)configData;\n                                      decoderinstances->nNumOfInstances = 16;\n /*TODO: How to handle this case */\n break;\n\n                                  }\n         case OMX_QcomIndexConfigVideoFramePackingArrangement: {\n                                           if (drv_ctx.decoder_format == VDEC_CODECTYPE_H264) {\n                                               OMX_QCOM_FRAME_PACK_ARRANGEMENT *configFmt =\n                                                   (OMX_QCOM_FRAME_PACK_ARRANGEMENT *) configData;\n                                               memcpy(configFmt, &m_frame_pack_arrangement,\n sizeof(OMX_QCOM_FRAME_PACK_ARRANGEMENT));\n } else {\n                                              DEBUG_PRINT_ERROR(\"get_config: Framepack data not supported for non H264 codecs\");\n }\n\n                                           break;\n                                       }\n         case OMX_IndexConfigCommonOutputCrop: {\n                                   OMX_CONFIG_RECTTYPE *rect = (OMX_CONFIG_RECTTYPE *) configData;\n                                   memcpy(rect, &rectangle, sizeof(OMX_CONFIG_RECTTYPE));\n                                   DEBUG_PRINT_HIGH(\"get_config: crop info: L: %u, T: %u, R: %u, B: %u\",\n                                        rectangle.nLeft, rectangle.nTop,\n                                        rectangle.nWidth, rectangle.nHeight);\n\n                                   break;\n                               }\n         case OMX_QcomIndexConfigPerfLevel: {\n                 struct v4l2_control control;\n                 OMX_QCOM_VIDEO_CONFIG_PERF_LEVEL *perf =\n                         (OMX_QCOM_VIDEO_CONFIG_PERF_LEVEL *)configData;\n\n                control.id = V4L2_CID_MPEG_VIDC_SET_PERF_LEVEL;\n if (ioctl(drv_ctx.video_driver_fd, VIDIOC_G_CTRL, &control) < 0) {\n                    DEBUG_PRINT_ERROR(\"Failed getting performance level: %d\", errno);\n                    eRet = OMX_ErrorHardware;\n }\n\n if (eRet == OMX_ErrorNone) {\n switch (control.value) {\n case V4L2_CID_MPEG_VIDC_PERF_LEVEL_TURBO:\n                            perf->ePerfLevel = OMX_QCOM_PerfLevelTurbo;\n break;\n default:\n                            DEBUG_PRINT_HIGH(\"Unknown perf level %d, reporting Nominal instead\", control.value);\n /* Fall through */\n case V4L2_CID_MPEG_VIDC_PERF_LEVEL_NOMINAL:\n                            perf->ePerfLevel = OMX_QCOM_PerfLevelNominal;\n break;\n }\n\n                 }\n \n                                   break;\n                              }\n         default: {\n                  DEBUG_PRINT_ERROR(\"get_config: unknown param %d\",configIndex);\n                  eRet = OMX_ErrorBadParameter;\n }\n\n }\n\n return eRet;\n}\n", "target": 1, "idx": 187810}
{"func": "void TabStripGtk::TabDetachedAt(TabContents* contents, int index) {\n   GenerateIdealBounds();\n  StartRemoveTabAnimation(index, contents->web_contents());\n  GetTabAt(index)->set_closing(true);\n}\n", "target": 1, "idx": 185219}
{"func": "int nfs4_proc_fs_locations(struct rpc_clnt *client, struct inode *dir,\n\t\t\t   const struct qstr *name,\n\t\t\t   struct nfs4_fs_locations *fs_locations,\n\t\t\t   struct page *page)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = _nfs4_proc_fs_locations(client, dir, name,\n\t\t\t\tfs_locations, page);\n\t\ttrace_nfs4_get_fs_locations(dir, name, err);\n\t\terr = nfs4_handle_exception(NFS_SERVER(dir), err,\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n", "target": 0, "idx": 57188}
{"func": "xfs_attr3_leaf_to_shortform(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args,\n\tint\t\t\tforkoff)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_local *name_loc;\n\tstruct xfs_da_args\tnargs;\n\tstruct xfs_inode\t*dp = args->dp;\n\tchar\t\t\t*tmpbuffer;\n\tint\t\t\terror;\n\tint\t\t\ti;\n\n\ttrace_xfs_attr_leaf_to_sf(args);\n\n\ttmpbuffer = kmem_alloc(XFS_LBSIZE(dp->i_mount), KM_SLEEP);\n\tif (!tmpbuffer)\n\t\treturn ENOMEM;\n\n\tmemcpy(tmpbuffer, bp->b_addr, XFS_LBSIZE(dp->i_mount));\n\n\tleaf = (xfs_attr_leafblock_t *)tmpbuffer;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tentry = xfs_attr3_leaf_entryp(leaf);\n\n\t/* XXX (dgc): buffer is about to be marked stale - why zero it? */\n\tmemset(bp->b_addr, 0, XFS_LBSIZE(dp->i_mount));\n\n\t/*\n\t * Clean out the prior contents of the attribute list.\n\t */\n\terror = xfs_da_shrink_inode(args, 0, bp);\n\tif (error)\n\t\tgoto out;\n\n\tif (forkoff == -1) {\n\t\tASSERT(dp->i_mount->m_flags & XFS_MOUNT_ATTR2);\n\t\tASSERT(dp->i_d.di_format != XFS_DINODE_FMT_BTREE);\n\t\txfs_attr_fork_reset(dp, args->trans);\n\t\tgoto out;\n\t}\n\n\txfs_attr_shortform_create(args);\n\n\t/*\n\t * Copy the attributes\n\t */\n\tmemset((char *)&nargs, 0, sizeof(nargs));\n\tnargs.dp = dp;\n\tnargs.firstblock = args->firstblock;\n\tnargs.flist = args->flist;\n\tnargs.total = args->total;\n\tnargs.whichfork = XFS_ATTR_FORK;\n\tnargs.trans = args->trans;\n\tnargs.op_flags = XFS_DA_OP_OKNOENT;\n\n\tfor (i = 0; i < ichdr.count; entry++, i++) {\n\t\tif (entry->flags & XFS_ATTR_INCOMPLETE)\n\t\t\tcontinue;\t/* don't copy partial entries */\n\t\tif (!entry->nameidx)\n\t\t\tcontinue;\n\t\tASSERT(entry->flags & XFS_ATTR_LOCAL);\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, i);\n\t\tnargs.name = name_loc->nameval;\n\t\tnargs.namelen = name_loc->namelen;\n\t\tnargs.value = &name_loc->nameval[nargs.namelen];\n\t\tnargs.valuelen = be16_to_cpu(name_loc->valuelen);\n\t\tnargs.hashval = be32_to_cpu(entry->hashval);\n\t\tnargs.flags = XFS_ATTR_NSP_ONDISK_TO_ARGS(entry->flags);\n\t\txfs_attr_shortform_add(&nargs, forkoff);\n\t}\n\terror = 0;\n\nout:\n\tkmem_free(tmpbuffer);\n\treturn error;\n}\n", "target": 0, "idx": 44941}
{"func": "void NuPlayer::GenericSource::setDrmPlaybackStatusIfNeeded(int playbackStatus, int64_t position) {\n if (mDecryptHandle != NULL) {\n        mDrmManagerClient->setPlaybackStatus(mDecryptHandle, playbackStatus, position);\n }\n    mSubtitleTrack.mPackets = new AnotherPacketSource(NULL);\n    mTimedTextTrack.mPackets = new AnotherPacketSource(NULL);\n}\n", "target": 0, "idx": 173613}
{"func": "static int check_alu_op(struct bpf_verifier_env *env, struct bpf_insn *insn)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tu8 opcode = BPF_OP(insn->code);\n\tint err;\n\n\tif (opcode == BPF_END || opcode == BPF_NEG) {\n\t\tif (opcode == BPF_NEG) {\n\t\t\tif (BPF_SRC(insn->code) != 0 ||\n\t\t\t    insn->src_reg != BPF_REG_0 ||\n\t\t\t    insn->off != 0 || insn->imm != 0) {\n\t\t\t\tverbose(env, \"BPF_NEG uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tif (insn->src_reg != BPF_REG_0 || insn->off != 0 ||\n\t\t\t    (insn->imm != 16 && insn->imm != 32 && insn->imm != 64) ||\n\t\t\t    BPF_CLASS(insn->code) == BPF_ALU64) {\n\t\t\t\tverbose(env, \"BPF_END uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check src operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, SRC_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (is_pointer_value(env, insn->dst_reg)) {\n\t\t\tverbose(env, \"R%d pointer arithmetic prohibited\\n\",\n\t\t\t\tinsn->dst_reg);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\t/* check dest operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, DST_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t} else if (opcode == BPF_MOV) {\n\n\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tif (insn->imm != 0 || insn->off != 0) {\n\t\t\t\tverbose(env, \"BPF_MOV uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\t/* check src operand */\n\t\t\terr = check_reg_arg(env, insn->src_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\tif (insn->src_reg != BPF_REG_0 || insn->off != 0) {\n\t\t\t\tverbose(env, \"BPF_MOV uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check dest operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, DST_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64) {\n\t\t\t\t/* case: R1 = R2\n\t\t\t\t * copy register state to dest reg\n\t\t\t\t */\n\t\t\t\tregs[insn->dst_reg] = regs[insn->src_reg];\n\t\t\t\tregs[insn->dst_reg].live |= REG_LIVE_WRITTEN;\n\t\t\t} else {\n\t\t\t\t/* R1 = (u32) R2 */\n\t\t\t\tif (is_pointer_value(env, insn->src_reg)) {\n\t\t\t\t\tverbose(env,\n\t\t\t\t\t\t\"R%d partial copy of pointer\\n\",\n\t\t\t\t\t\tinsn->src_reg);\n \t\t\t\t\treturn -EACCES;\n \t\t\t\t}\n \t\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\t\t/* high 32 bits are known zero. */\n\t\t\t\tregs[insn->dst_reg].var_off = tnum_cast(\n\t\t\t\t\t\tregs[insn->dst_reg].var_off, 4);\n\t\t\t\t__update_reg_bounds(&regs[insn->dst_reg]);\n \t\t\t}\n \t\t} else {\n \t\t\t/* case: R = imm\n\t\t\t * remember the value we stored into this reg\n\t\t\t */\n\t\t\tregs[insn->dst_reg].type = SCALAR_VALUE;\n\t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64) {\n\t\t\t\t__mark_reg_known(regs + insn->dst_reg,\n\t\t\t\t\t\t insn->imm);\n\t\t\t} else {\n\t\t\t\t__mark_reg_known(regs + insn->dst_reg,\n\t\t\t\t\t\t (u32)insn->imm);\n\t\t\t}\n\t\t}\n\n\t} else if (opcode > BPF_END) {\n\t\tverbose(env, \"invalid BPF_ALU opcode %x\\n\", opcode);\n\t\treturn -EINVAL;\n\n\t} else {\t/* all other ALU ops: and, sub, xor, add, ... */\n\n\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tif (insn->imm != 0 || insn->off != 0) {\n\t\t\t\tverbose(env, \"BPF_ALU uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t/* check src1 operand */\n\t\t\terr = check_reg_arg(env, insn->src_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\tif (insn->src_reg != BPF_REG_0 || insn->off != 0) {\n\t\t\t\tverbose(env, \"BPF_ALU uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check src2 operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, SRC_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif ((opcode == BPF_MOD || opcode == BPF_DIV) &&\n\t\t    BPF_SRC(insn->code) == BPF_K && insn->imm == 0) {\n\t\t\tverbose(env, \"div by zero\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif ((opcode == BPF_LSH || opcode == BPF_RSH ||\n\t\t     opcode == BPF_ARSH) && BPF_SRC(insn->code) == BPF_K) {\n\t\t\tint size = BPF_CLASS(insn->code) == BPF_ALU64 ? 64 : 32;\n\n\t\t\tif (insn->imm < 0 || insn->imm >= size) {\n\t\t\t\tverbose(env, \"invalid shift %d\\n\", insn->imm);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check dest operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, DST_OP_NO_MARK);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\treturn adjust_reg_min_max_vals(env, insn);\n\t}\n\n\treturn 0;\n}\n", "target": 1, "idx": 180830}
{"func": "int __remove_suid(struct dentry *dentry, int kill)\n{\n\tstruct iattr newattrs;\n\n\tnewattrs.ia_valid = ATTR_FORCE | kill;\n\treturn notify_change(dentry, &newattrs);\n}\n", "target": 0, "idx": 58789}
{"func": "status_t OMXNodeInstance::emptyBuffer(\n        OMX::buffer_id buffer,\n        OMX_U32 rangeOffset, OMX_U32 rangeLength,\n\n         OMX_U32 flags, OMX_TICKS timestamp, int fenceFd) {\n     Mutex::Autolock autoLock(mLock);\n \n     OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer, kPortIndexInput);\n     if (header == NULL) {\n         ALOGE(\"b/25884056\");\n return BAD_VALUE;\n }\n BufferMeta *buffer_meta =\n static_cast<BufferMeta *>(header->pAppPrivate);\n    sp<ABuffer> backup = buffer_meta->getBuffer(header, true /* backup */, false /* limit */);\n    sp<ABuffer> codec = buffer_meta->getBuffer(header, false /* backup */, false /* limit */);\n\n if (mMetadataType[kPortIndexInput] == kMetadataBufferTypeGrallocSource\n && backup->capacity() >= sizeof(VideoNativeMetadata)\n && codec->capacity() >= sizeof(VideoGrallocMetadata)\n && ((VideoNativeMetadata *)backup->base())->eType\n == kMetadataBufferTypeANWBuffer) {\n VideoNativeMetadata &backupMeta = *(VideoNativeMetadata *)backup->base();\n VideoGrallocMetadata &codecMeta = *(VideoGrallocMetadata *)codec->base();\n        CLOG_BUFFER(emptyBuffer, \"converting ANWB %p to handle %p\",\n                backupMeta.pBuffer, backupMeta.pBuffer->handle);\n        codecMeta.pHandle = backupMeta.pBuffer != NULL ? backupMeta.pBuffer->handle : NULL;\n        codecMeta.eType = kMetadataBufferTypeGrallocSource;\n        header->nFilledLen = rangeLength ? sizeof(codecMeta) : 0;\n        header->nOffset = 0;\n } else {\n if (rangeOffset > header->nAllocLen\n || rangeLength > header->nAllocLen - rangeOffset) {\n            CLOG_ERROR(emptyBuffer, OMX_ErrorBadParameter, FULL_BUFFER(NULL, header, fenceFd));\n if (fenceFd >= 0) {\n ::close(fenceFd);\n }\n return BAD_VALUE;\n }\n        header->nFilledLen = rangeLength;\n        header->nOffset = rangeOffset;\n\n        buffer_meta->CopyToOMX(header);\n }\n\n return emptyBuffer_l(header, flags, timestamp, (intptr_t)buffer, fenceFd);\n}\n", "target": 1, "idx": 188155}
{"func": "static void _out_result(conn_t out, nad_t nad) {\n    int attr;\n    jid_t from, to;\n    char *rkey;\n    int rkeylen;\n\n    attr = nad_find_attr(nad, 0, -1, \"from\", NULL);\n    if(attr < 0 || (from = jid_new(NAD_AVAL(nad, attr), NAD_AVAL_L(nad, attr))) == NULL) {\n        log_debug(ZONE, \"missing or invalid from on db result packet\");\n        nad_free(nad);\n        return;\n    }\n\n    attr = nad_find_attr(nad, 0, -1, \"to\", NULL);\n    if(attr < 0 || (to = jid_new(NAD_AVAL(nad, attr), NAD_AVAL_L(nad, attr))) == NULL) {\n        log_debug(ZONE, \"missing or invalid to on db result packet\");\n        jid_free(from);\n        nad_free(nad);\n        return;\n    }\n\n    rkey = s2s_route_key(NULL, to->domain, from->domain);\n     rkeylen = strlen(rkey);\n \n     /* key is valid */\n    if(nad_find_attr(nad, 0, -1, \"type\", \"valid\") >= 0) {\n         log_write(out->s2s->log, LOG_NOTICE, \"[%d] [%s, port=%d] outgoing route '%s' is now valid%s%s\", out->fd->fd, out->ip, out->port, rkey, (out->s->flags & SX_SSL_WRAPPER) ? \", TLS negotiated\" : \"\", out->s->compressed ? \", ZLIB compression enabled\" : \"\");\n \n         xhash_put(out->states, pstrdup(xhash_pool(out->states), rkey), (void *) conn_VALID);    /* !!! small leak here */\n\n        log_debug(ZONE, \"%s valid, flushing queue\", rkey);\n\n        /* flush the queue */\n        out_flush_route_queue(out->s2s, rkey, rkeylen);\n\n        free(rkey);\n\n        jid_free(from);\n        jid_free(to);\n\n        nad_free(nad);\n\n        return;\n    }\n\n    /* invalid */\n    log_write(out->s2s->log, LOG_NOTICE, \"[%d] [%s, port=%d] outgoing route '%s' is now invalid\", out->fd->fd, out->ip, out->port, rkey);\n\n    /* close connection */\n    log_write(out->s2s->log, LOG_NOTICE, \"[%d] [%s, port=%d] closing connection\", out->fd->fd, out->ip, out->port);\n\n    /* report stream error */\n    sx_error(out->s, stream_err_INVALID_ID, \"dialback negotiation failed\");\n\n    /* close the stream */\n    sx_close(out->s);\n\n    /* bounce queue */\n    out_bounce_route_queue(out->s2s, rkey, rkeylen, stanza_err_SERVICE_UNAVAILABLE);\n\n    free(rkey);\n\n    jid_free(from);\n    jid_free(to);\n\n    nad_free(nad);\n}\n", "target": 1, "idx": 178748}
{"func": "void NavigationRequest::OnRequestRedirected(\n    const net::RedirectInfo& redirect_info,\n    const scoped_refptr<network::ResourceResponse>& response) {\n  response_ = response;\n  ssl_info_ = response->head.ssl_info;\n#if defined(OS_ANDROID)\n  base::WeakPtr<NavigationRequest> this_ptr(weak_factory_.GetWeakPtr());\n\n  bool should_override_url_loading = false;\n  if (!GetContentClient()->browser()->ShouldOverrideUrlLoading(\n          frame_tree_node_->frame_tree_node_id(), browser_initiated_,\n          redirect_info.new_url, redirect_info.new_method,\n          false, true, frame_tree_node_->IsMainFrame(),\n          common_params_.transition, &should_override_url_loading)) {\n    return;\n  }\n\n  if (!this_ptr)\n    return;\n\n  if (should_override_url_loading) {\n    navigation_handle_->set_net_error_code(net::ERR_ABORTED);\n    common_params_.url = redirect_info.new_url;\n    common_params_.method = redirect_info.new_method;\n    navigation_handle_->UpdateStateFollowingRedirect(\n        GURL(redirect_info.new_referrer),\n        base::Bind(&NavigationRequest::OnRedirectChecksComplete,\n                   base::Unretained(this)));\n    frame_tree_node_->ResetNavigationRequest(false, true);\n    return;\n  }\n#endif\n  if (!ChildProcessSecurityPolicyImpl::GetInstance()->CanRedirectToURL(\n           redirect_info.new_url)) {\n     DVLOG(1) << \"Denied redirect for \"\n              << redirect_info.new_url.possibly_invalid_spec();\n    navigation_handle_->set_net_error_code(net::ERR_UNSAFE_REDIRECT);\n    frame_tree_node_->ResetNavigationRequest(false, true);\n     return;\n   }\n \n  if (!browser_initiated_ && source_site_instance() &&\n      !ChildProcessSecurityPolicyImpl::GetInstance()->CanRequestURL(\n          source_site_instance()->GetProcess()->GetID(),\n           redirect_info.new_url)) {\n     DVLOG(1) << \"Denied unauthorized redirect for \"\n              << redirect_info.new_url.possibly_invalid_spec();\n    navigation_handle_->set_net_error_code(net::ERR_UNSAFE_REDIRECT);\n    frame_tree_node_->ResetNavigationRequest(false, true);\n     return;\n   }\n \n  if (redirect_info.new_method != \"POST\")\n    common_params_.post_data = nullptr;\n\n  if (commit_params_.navigation_timing.redirect_start.is_null()) {\n    commit_params_.navigation_timing.redirect_start =\n        commit_params_.navigation_timing.fetch_start;\n  }\n  commit_params_.navigation_timing.redirect_end = base::TimeTicks::Now();\n  commit_params_.navigation_timing.fetch_start = base::TimeTicks::Now();\n\n  commit_params_.redirect_response.push_back(response->head);\n  commit_params_.redirect_infos.push_back(redirect_info);\n\n  if (commit_params_.origin_to_commit)\n    commit_params_.origin_to_commit.reset();\n\n  commit_params_.redirects.push_back(common_params_.url);\n  common_params_.url = redirect_info.new_url;\n  common_params_.method = redirect_info.new_method;\n  common_params_.referrer.url = GURL(redirect_info.new_referrer);\n  common_params_.referrer =\n      Referrer::SanitizeForRequest(common_params_.url, common_params_.referrer);\n\n  net::Error net_error =\n      CheckContentSecurityPolicy(true /* has_followed_redirect */,\n                                 redirect_info.insecure_scheme_was_upgraded,\n                                 false /* is_response_check */);\n  if (net_error != net::OK) {\n    OnRequestFailedInternal(\n        network::URLLoaderCompletionStatus(net_error), false /*skip_throttles*/,\n        base::nullopt /*error_page_content*/, false /*collapse_frame*/);\n\n    return;\n  }\n\n  if (CheckCredentialedSubresource() ==\n          CredentialedSubresourceCheckResult::BLOCK_REQUEST ||\n      CheckLegacyProtocolInSubresource() ==\n          LegacyProtocolInSubresourceCheckResult::BLOCK_REQUEST) {\n    OnRequestFailedInternal(\n        network::URLLoaderCompletionStatus(net::ERR_ABORTED),\n        false /*skip_throttles*/, base::nullopt /*error_page_content*/,\n        false /*collapse_frame*/);\n\n    return;\n  }\n\n  scoped_refptr<SiteInstance> site_instance =\n      frame_tree_node_->render_manager()->GetSiteInstanceForNavigationRequest(\n          *this);\n  speculative_site_instance_ =\n      site_instance->HasProcess() ? site_instance : nullptr;\n\n  if (!site_instance->HasProcess()) {\n    RenderProcessHostImpl::NotifySpareManagerAboutRecentlyUsedBrowserContext(\n        site_instance->GetBrowserContext());\n  }\n\n  common_params_.previews_state =\n      GetContentClient()->browser()->DetermineAllowedPreviews(\n          common_params_.previews_state, navigation_handle_.get(),\n          common_params_.url);\n\n  RenderProcessHost* expected_process =\n      site_instance->HasProcess() ? site_instance->GetProcess() : nullptr;\n\n  navigation_handle_->WillRedirectRequest(\n      common_params_.referrer.url, expected_process,\n      base::Bind(&NavigationRequest::OnRedirectChecksComplete,\n                 base::Unretained(this)));\n}\n", "target": 1, "idx": 187014}
{"func": "int ext4_orphan_del(handle_t *handle, struct inode *inode)\n{\n\tstruct list_head *prev;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi;\n\t__u32 ino_next;\n \tstruct ext4_iloc iloc;\n \tint err = 0;\n \n\tif (!EXT4_SB(inode->i_sb)->s_journal)\n \t\treturn 0;\n \n \tmutex_lock(&EXT4_SB(inode->i_sb)->s_orphan_lock);\n\tif (list_empty(&ei->i_orphan))\n\t\tgoto out;\n\n\tino_next = NEXT_ORPHAN(inode);\n\tprev = ei->i_orphan.prev;\n\tsbi = EXT4_SB(inode->i_sb);\n\n\tjbd_debug(4, \"remove inode %lu from orphan list\\n\", inode->i_ino);\n\n\tlist_del_init(&ei->i_orphan);\n\n\t/* If we're on an error path, we may not have a valid\n\t * transaction handle with which to update the orphan list on\n\t * disk, but we still need to remove the inode from the linked\n\t * list in memory. */\n\tif (!handle)\n\t\tgoto out;\n\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out_err;\n\n\tif (prev == &sbi->s_orphan) {\n\t\tjbd_debug(4, \"superblock will point to %u\\n\", ino_next);\n\t\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\t\tif (err)\n\t\t\tgoto out_brelse;\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(ino_next);\n\t\terr = ext4_handle_dirty_super(handle, inode->i_sb);\n\t} else {\n\t\tstruct ext4_iloc iloc2;\n\t\tstruct inode *i_prev =\n\t\t\t&list_entry(prev, struct ext4_inode_info, i_orphan)->vfs_inode;\n\n\t\tjbd_debug(4, \"orphan inode %lu will point to %u\\n\",\n\t\t\t  i_prev->i_ino, ino_next);\n\t\terr = ext4_reserve_inode_write(handle, i_prev, &iloc2);\n\t\tif (err)\n\t\t\tgoto out_brelse;\n\t\tNEXT_ORPHAN(i_prev) = ino_next;\n\t\terr = ext4_mark_iloc_dirty(handle, i_prev, &iloc2);\n\t}\n\tif (err)\n\t\tgoto out_brelse;\n\tNEXT_ORPHAN(inode) = 0;\n\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\nout_err:\n\text4_std_error(inode->i_sb, err);\nout:\n\tmutex_unlock(&EXT4_SB(inode->i_sb)->s_orphan_lock);\n\treturn err;\n\nout_brelse:\n\tbrelse(iloc.bh);\n\tgoto out_err;\n}\n", "target": 1, "idx": 179262}
{"func": "SECURITY_STATUS SEC_ENTRY ApplyControlToken(PCtxtHandle phContext, PSecBufferDesc pInput)\n{\n\treturn SEC_E_OK;\n}\n", "target": 0, "idx": 58573}
{"func": "SProcXFixesCreatePointerBarrier(ClientPtr client)\n{\n    REQUEST(xXFixesCreatePointerBarrierReq);\n    int i;\n     int i;\n     CARD16 *in_devices = (CARD16 *) &stuff[1];\n \n     swaps(&stuff->length);\n     swaps(&stuff->num_devices);\n     REQUEST_FIXED_SIZE(xXFixesCreatePointerBarrierReq, pad_to_int32(stuff->num_devices));\n    swaps(&stuff->x1);\n    swaps(&stuff->y1);\n    swaps(&stuff->x2);\n    swaps(&stuff->y2);\n    swapl(&stuff->directions);\n    for (i = 0; i < stuff->num_devices; i++) {\n        swaps(in_devices + i);\n    }\n\n    return ProcXFixesVector[stuff->xfixesReqType] (client);\n}\n", "target": 1, "idx": 178612}
{"func": "WebPlugin* RenderView::CreateNPAPIPlugin(\n    WebFrame* frame,\n    const WebPluginParams& params,\n    const FilePath& path,\n    const std::string& mime_type) {\n  return new webkit::npapi::WebPluginImpl(\n      frame, params, path, mime_type, AsWeakPtr());\n}\n", "target": 0, "idx": 103776}
{"func": "void CCLayerTreeHostTest::endTest()\n {\n     if (!isMainThread())\n        CCMainThread::postTask(createMainThreadTask(this, &CCLayerTreeHostTest::endTest));\n     else {\n        if (m_beginning)\n            m_endWhenBeginReturns = true;\n        else\n            onEndTest(static_cast<void*>(this));\n    }\n}\n", "target": 1, "idx": 183750}
{"func": "mrb_class_get_under(mrb_state *mrb, struct RClass *outer, const char *name)\n{\n  return class_from_sym(mrb, outer, mrb_intern_cstr(mrb, name));\n}\n", "target": 0, "idx": 82069}
{"func": " static int crypto_report_one(struct crypto_alg *alg,\n \t\t\t     struct crypto_user_alg *ualg, struct sk_buff *skb)\n {\n\tstrlcpy(ualg->cru_name, alg->cra_name, sizeof(ualg->cru_name));\n\tstrlcpy(ualg->cru_driver_name, alg->cra_driver_name,\n \t\tsizeof(ualg->cru_driver_name));\n\tstrlcpy(ualg->cru_module_name, module_name(alg->cra_module),\n \t\tsizeof(ualg->cru_module_name));\n \n \tualg->cru_type = 0;\n\tualg->cru_mask = 0;\n\tualg->cru_flags = alg->cra_flags;\n\tualg->cru_refcnt = refcount_read(&alg->cra_refcnt);\n\n\tif (nla_put_u32(skb, CRYPTOCFGA_PRIORITY_VAL, alg->cra_priority))\n\t\tgoto nla_put_failure;\n \tif (alg->cra_flags & CRYPTO_ALG_LARVAL) {\n \t\tstruct crypto_report_larval rl;\n \n\t\tstrlcpy(rl.type, \"larval\", sizeof(rl.type));\n \t\tif (nla_put(skb, CRYPTOCFGA_REPORT_LARVAL,\n \t\t\t    sizeof(struct crypto_report_larval), &rl))\n \t\t\tgoto nla_put_failure;\n\t\tgoto out;\n\t}\n\n\tif (alg->cra_type && alg->cra_type->report) {\n\t\tif (alg->cra_type->report(skb, alg))\n\t\t\tgoto nla_put_failure;\n\n\t\tgoto out;\n\t}\n\n\tswitch (alg->cra_flags & (CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_LARVAL)) {\n\tcase CRYPTO_ALG_TYPE_CIPHER:\n\t\tif (crypto_report_cipher(skb, alg))\n\t\t\tgoto nla_put_failure;\n\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_COMPRESS:\n\t\tif (crypto_report_comp(skb, alg))\n\t\t\tgoto nla_put_failure;\n\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_ACOMPRESS:\n\t\tif (crypto_report_acomp(skb, alg))\n\t\t\tgoto nla_put_failure;\n\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_AKCIPHER:\n\t\tif (crypto_report_akcipher(skb, alg))\n\t\t\tgoto nla_put_failure;\n\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_KPP:\n\t\tif (crypto_report_kpp(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\t}\n\nout:\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n", "target": 1, "idx": 182140}
{"func": "static int handle_vmptrst(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tu32 vmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);\n\tgva_t vmcs_gva;\n\tstruct x86_exception e;\n\n\tif (!nested_vmx_check_permission(vcpu))\n\t\treturn 1;\n\n \tif (get_vmx_mem_address(vcpu, exit_qualification,\n \t\t\tvmx_instruction_info, true, &vmcs_gva))\n \t\treturn 1;\n\t/* ok to use *_system, as hardware has verified cpl=0 */\n \tif (kvm_write_guest_virt_system(&vcpu->arch.emulate_ctxt, vmcs_gva,\n \t\t\t\t (void *)&to_vmx(vcpu)->nested.current_vmptr,\n \t\t\t\t sizeof(u64), &e)) {\n\t\tkvm_inject_page_fault(vcpu, &e);\n\t\treturn 1;\n\t}\n\tnested_vmx_succeed(vcpu);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\n", "target": 1, "idx": 182346}
{"func": "PanoramiXRenderSetPictureClipRectangles(ClientPtr client)\n{\n    REQUEST(xRenderSetPictureClipRectanglesReq);\n    int result = Success, j;\n    PanoramiXRes *pict;\n\n    REQUEST_AT_LEAST_SIZE(xRenderSetPictureClipRectanglesReq);\n\n    VERIFY_XIN_PICTURE(pict, stuff->picture, client, DixWriteAccess);\n\n    FOR_NSCREENS_BACKWARD(j) {\n        stuff->picture = pict->info[j].id;\n        result =\n            (*PanoramiXSaveRenderVector[X_RenderSetPictureClipRectangles])\n            (client);\n        if (result != Success)\n            break;\n    }\n\n    return result;\n}\n", "target": 0, "idx": 17562}
{"func": " void EncoderTest::InitializeConfig() {\n   const vpx_codec_err_t res = codec_->DefaultEncoderConfig(&cfg_, 0);\n   ASSERT_EQ(VPX_CODEC_OK, res);\n }\n", "target": 1, "idx": 188560}
{"func": "static int dcbnl_getstate(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t  u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\t/* if (!tb[DCB_ATTR_STATE] || !netdev->dcbnl_ops->getstate) */\n\tif (!netdev->dcbnl_ops->getstate)\n\t\treturn -EOPNOTSUPP;\n\n\treturn nla_put_u8(skb, DCB_ATTR_STATE,\n\t\t\t  netdev->dcbnl_ops->getstate(netdev));\n}\n", "target": 0, "idx": 31100}
{"func": "static bool valid_cr(int nr)\n{\n\tswitch (nr) {\n\tcase 0:\n\tcase 2 ... 4:\n\tcase 8:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n", "target": 0, "idx": 21850}
{"func": " void BlobURLRegistry::unregisterURL(const KURL& url)\n {\n    ThreadableBlobRegistry::unregisterBlobURL(url);\n }\n", "target": 1, "idx": 184252}
{"func": "void imap_cachepath(struct ImapData *idata, const char *mailbox, char *dest, size_t dlen)\n{\n  char *s = NULL;\n  const char *p = mailbox;\n\n  for (s = dest; p && *p && dlen; dlen--)\n  {\n    if (*p == idata->delim)\n    {\n      *s = '/';\n      /* simple way to avoid collisions with UIDs */\n      if (*(p + 1) >= '0' && *(p + 1) <= '9')\n      {\n        if (--dlen)\n          *++s = '_';\n      }\n    }\n    else\n      *s = *p;\n    p++;\n    s++;\n  }\n  *s = '\\0';\n}\n", "target": 0, "idx": 79617}
{"func": "void TextAutosizer::processCluster(RenderBlock* cluster, RenderBlock* container, RenderObject* subtreeRoot, const TextAutosizingWindowInfo& windowInfo)\n{\n    ASSERT(isAutosizingCluster(cluster));\n\n    RenderBlock* lowestCommonAncestor = cluster;\n    float commonAncestorWidth = lowestCommonAncestor->contentLogicalWidth();\n\n    float multiplier = 1;\n    if (clusterShouldBeAutosized(lowestCommonAncestor, commonAncestorWidth)) {\n        int logicalWindowWidth = cluster->isHorizontalWritingMode() ? windowInfo.windowSize.width() : windowInfo.windowSize.height();\n        int logicalLayoutWidth = cluster->isHorizontalWritingMode() ? windowInfo.minLayoutSize.width() : windowInfo.minLayoutSize.height();\n        float logicalClusterWidth = std::min<float>(commonAncestorWidth, logicalLayoutWidth);\n\n        multiplier = logicalClusterWidth / logicalWindowWidth;\n        multiplier *= m_document->settings()->textAutosizingFontScaleFactor();\n        multiplier = std::max(1.0f, multiplier);\n    }\n\n    processContainer(multiplier, container, subtreeRoot, windowInfo);\n}\n", "target": 0, "idx": 100646}
{"func": "VOID NBLSet8021QInfo(PPARANDIS_ADAPTER pContext, PNET_BUFFER_LIST pNBL, PNET_PACKET_INFO pPacketInfo)\n{\n    NDIS_NET_BUFFER_LIST_8021Q_INFO qInfo;\n    qInfo.Value = NULL;\n\n    if (IsPrioritySupported(pContext))\n        qInfo.TagHeader.UserPriority = pPacketInfo->Vlan.UserPriority;\n\n    if (IsVlanSupported(pContext))\n        qInfo.TagHeader.VlanId = pPacketInfo->Vlan.VlanId;\n\n    if(qInfo.Value != NULL)\n        pContext->extraStatistics.framesRxPriority++;\n\n    NET_BUFFER_LIST_INFO(pNBL, Ieee8021QNetBufferListInfo) = qInfo.Value;\n}\n", "target": 0, "idx": 96355}
{"func": "DrawingBuffer::DrawingBuffer(\n    std::unique_ptr<WebGraphicsContext3DProvider> context_provider,\n    std::unique_ptr<Extensions3DUtil> extensions_util,\n    Client* client,\n    bool discard_framebuffer_supported,\n     bool want_alpha_channel,\n     bool premultiplied_alpha,\n     PreserveDrawingBuffer preserve,\n    WebGLVersion web_gl_version,\n     bool want_depth,\n     bool want_stencil,\n     ChromiumImageUsage chromium_image_usage,\n     const CanvasColorParams& color_params)\n     : client_(client),\n       preserve_drawing_buffer_(preserve),\n      web_gl_version_(web_gl_version),\n       context_provider_(WTF::WrapUnique(new WebGraphicsContext3DProviderWrapper(\n           std::move(context_provider)))),\n       gl_(this->ContextProvider()->ContextGL()),\n      extensions_util_(std::move(extensions_util)),\n      discard_framebuffer_supported_(discard_framebuffer_supported),\n      want_alpha_channel_(want_alpha_channel),\n      premultiplied_alpha_(premultiplied_alpha),\n      software_rendering_(this->ContextProvider()->IsSoftwareRendering()),\n      want_depth_(want_depth),\n      want_stencil_(want_stencil),\n      color_space_(color_params.GetGfxColorSpace()),\n      chromium_image_usage_(chromium_image_usage) {\n  TRACE_EVENT_INSTANT0(\"test_gpu\", \"DrawingBufferCreation\",\n                       TRACE_EVENT_SCOPE_GLOBAL);\n}\n", "target": 1, "idx": 186259}
{"func": "static int prepare_vmcs02(struct kvm_vcpu *vcpu, struct vmcs12 *vmcs12,\n\t\t\t  bool from_vmentry, u32 *entry_failure_code)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 exec_control, vmcs12_exec_ctrl;\n\n\tvmcs_write16(GUEST_ES_SELECTOR, vmcs12->guest_es_selector);\n\tvmcs_write16(GUEST_CS_SELECTOR, vmcs12->guest_cs_selector);\n\tvmcs_write16(GUEST_SS_SELECTOR, vmcs12->guest_ss_selector);\n\tvmcs_write16(GUEST_DS_SELECTOR, vmcs12->guest_ds_selector);\n\tvmcs_write16(GUEST_FS_SELECTOR, vmcs12->guest_fs_selector);\n\tvmcs_write16(GUEST_GS_SELECTOR, vmcs12->guest_gs_selector);\n\tvmcs_write16(GUEST_LDTR_SELECTOR, vmcs12->guest_ldtr_selector);\n\tvmcs_write16(GUEST_TR_SELECTOR, vmcs12->guest_tr_selector);\n\tvmcs_write32(GUEST_ES_LIMIT, vmcs12->guest_es_limit);\n\tvmcs_write32(GUEST_CS_LIMIT, vmcs12->guest_cs_limit);\n\tvmcs_write32(GUEST_SS_LIMIT, vmcs12->guest_ss_limit);\n\tvmcs_write32(GUEST_DS_LIMIT, vmcs12->guest_ds_limit);\n\tvmcs_write32(GUEST_FS_LIMIT, vmcs12->guest_fs_limit);\n\tvmcs_write32(GUEST_GS_LIMIT, vmcs12->guest_gs_limit);\n\tvmcs_write32(GUEST_LDTR_LIMIT, vmcs12->guest_ldtr_limit);\n\tvmcs_write32(GUEST_TR_LIMIT, vmcs12->guest_tr_limit);\n\tvmcs_write32(GUEST_GDTR_LIMIT, vmcs12->guest_gdtr_limit);\n\tvmcs_write32(GUEST_IDTR_LIMIT, vmcs12->guest_idtr_limit);\n\tvmcs_write32(GUEST_ES_AR_BYTES, vmcs12->guest_es_ar_bytes);\n\tvmcs_write32(GUEST_CS_AR_BYTES, vmcs12->guest_cs_ar_bytes);\n\tvmcs_write32(GUEST_SS_AR_BYTES, vmcs12->guest_ss_ar_bytes);\n\tvmcs_write32(GUEST_DS_AR_BYTES, vmcs12->guest_ds_ar_bytes);\n\tvmcs_write32(GUEST_FS_AR_BYTES, vmcs12->guest_fs_ar_bytes);\n\tvmcs_write32(GUEST_GS_AR_BYTES, vmcs12->guest_gs_ar_bytes);\n\tvmcs_write32(GUEST_LDTR_AR_BYTES, vmcs12->guest_ldtr_ar_bytes);\n\tvmcs_write32(GUEST_TR_AR_BYTES, vmcs12->guest_tr_ar_bytes);\n\tvmcs_writel(GUEST_ES_BASE, vmcs12->guest_es_base);\n\tvmcs_writel(GUEST_CS_BASE, vmcs12->guest_cs_base);\n\tvmcs_writel(GUEST_SS_BASE, vmcs12->guest_ss_base);\n\tvmcs_writel(GUEST_DS_BASE, vmcs12->guest_ds_base);\n\tvmcs_writel(GUEST_FS_BASE, vmcs12->guest_fs_base);\n\tvmcs_writel(GUEST_GS_BASE, vmcs12->guest_gs_base);\n\tvmcs_writel(GUEST_LDTR_BASE, vmcs12->guest_ldtr_base);\n\tvmcs_writel(GUEST_TR_BASE, vmcs12->guest_tr_base);\n\tvmcs_writel(GUEST_GDTR_BASE, vmcs12->guest_gdtr_base);\n\tvmcs_writel(GUEST_IDTR_BASE, vmcs12->guest_idtr_base);\n\n\tif (from_vmentry &&\n\t    (vmcs12->vm_entry_controls & VM_ENTRY_LOAD_DEBUG_CONTROLS)) {\n\t\tkvm_set_dr(vcpu, 7, vmcs12->guest_dr7);\n\t\tvmcs_write64(GUEST_IA32_DEBUGCTL, vmcs12->guest_ia32_debugctl);\n\t} else {\n\t\tkvm_set_dr(vcpu, 7, vcpu->arch.dr7);\n\t\tvmcs_write64(GUEST_IA32_DEBUGCTL, vmx->nested.vmcs01_debugctl);\n\t}\n\tif (from_vmentry) {\n\t\tvmcs_write32(VM_ENTRY_INTR_INFO_FIELD,\n\t\t\t     vmcs12->vm_entry_intr_info_field);\n\t\tvmcs_write32(VM_ENTRY_EXCEPTION_ERROR_CODE,\n\t\t\t     vmcs12->vm_entry_exception_error_code);\n\t\tvmcs_write32(VM_ENTRY_INSTRUCTION_LEN,\n\t\t\t     vmcs12->vm_entry_instruction_len);\n\t\tvmcs_write32(GUEST_INTERRUPTIBILITY_INFO,\n\t\t\t     vmcs12->guest_interruptibility_info);\n\t\tvmx->loaded_vmcs->nmi_known_unmasked =\n\t\t\t!(vmcs12->guest_interruptibility_info & GUEST_INTR_STATE_NMI);\n\t} else {\n\t\tvmcs_write32(VM_ENTRY_INTR_INFO_FIELD, 0);\n\t}\n\tvmcs_write32(GUEST_SYSENTER_CS, vmcs12->guest_sysenter_cs);\n\tvmx_set_rflags(vcpu, vmcs12->guest_rflags);\n\tvmcs_writel(GUEST_PENDING_DBG_EXCEPTIONS,\n\t\tvmcs12->guest_pending_dbg_exceptions);\n\tvmcs_writel(GUEST_SYSENTER_ESP, vmcs12->guest_sysenter_esp);\n\tvmcs_writel(GUEST_SYSENTER_EIP, vmcs12->guest_sysenter_eip);\n\n\tif (nested_cpu_has_xsaves(vmcs12))\n\t\tvmcs_write64(XSS_EXIT_BITMAP, vmcs12->xss_exit_bitmap);\n\tvmcs_write64(VMCS_LINK_POINTER, -1ull);\n\n\texec_control = vmcs12->pin_based_vm_exec_control;\n\n\t/* Preemption timer setting is only taken from vmcs01.  */\n\texec_control &= ~PIN_BASED_VMX_PREEMPTION_TIMER;\n\texec_control |= vmcs_config.pin_based_exec_ctrl;\n\tif (vmx->hv_deadline_tsc == -1)\n\t\texec_control &= ~PIN_BASED_VMX_PREEMPTION_TIMER;\n\n\t/* Posted interrupts setting is only taken from vmcs12.  */\n\tif (nested_cpu_has_posted_intr(vmcs12)) {\n\t\tvmx->nested.posted_intr_nv = vmcs12->posted_intr_nv;\n\t\tvmx->nested.pi_pending = false;\n\t\tvmcs_write16(POSTED_INTR_NV, POSTED_INTR_NESTED_VECTOR);\n\t} else {\n\t\texec_control &= ~PIN_BASED_POSTED_INTR;\n\t}\n\n\tvmcs_write32(PIN_BASED_VM_EXEC_CONTROL, exec_control);\n\n\tvmx->nested.preemption_timer_expired = false;\n\tif (nested_cpu_has_preemption_timer(vmcs12))\n\t\tvmx_start_preemption_timer(vcpu);\n\n\t/*\n\t * Whether page-faults are trapped is determined by a combination of\n\t * 3 settings: PFEC_MASK, PFEC_MATCH and EXCEPTION_BITMAP.PF.\n\t * If enable_ept, L0 doesn't care about page faults and we should\n\t * set all of these to L1's desires. However, if !enable_ept, L0 does\n\t * care about (at least some) page faults, and because it is not easy\n\t * (if at all possible?) to merge L0 and L1's desires, we simply ask\n\t * to exit on each and every L2 page fault. This is done by setting\n\t * MASK=MATCH=0 and (see below) EB.PF=1.\n\t * Note that below we don't need special code to set EB.PF beyond the\n\t * \"or\"ing of the EB of vmcs01 and vmcs12, because when enable_ept,\n\t * vmcs01's EB.PF is 0 so the \"or\" will take vmcs12's value, and when\n\t * !enable_ept, EB.PF is 1, so the \"or\" will always be 1.\n\t */\n\tvmcs_write32(PAGE_FAULT_ERROR_CODE_MASK,\n\t\tenable_ept ? vmcs12->page_fault_error_code_mask : 0);\n\tvmcs_write32(PAGE_FAULT_ERROR_CODE_MATCH,\n\t\tenable_ept ? vmcs12->page_fault_error_code_match : 0);\n\n\tif (cpu_has_secondary_exec_ctrls()) {\n\t\texec_control = vmx->secondary_exec_control;\n\n\t\t/* Take the following fields only from vmcs12 */\n\t\texec_control &= ~(SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES |\n\t\t\t\t  SECONDARY_EXEC_ENABLE_INVPCID |\n\t\t\t\t  SECONDARY_EXEC_RDTSCP |\n\t\t\t\t  SECONDARY_EXEC_XSAVES |\n\t\t\t\t  SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY |\n\t\t\t\t  SECONDARY_EXEC_APIC_REGISTER_VIRT |\n\t\t\t\t  SECONDARY_EXEC_ENABLE_VMFUNC);\n\t\tif (nested_cpu_has(vmcs12,\n\t\t\t\t   CPU_BASED_ACTIVATE_SECONDARY_CONTROLS)) {\n\t\t\tvmcs12_exec_ctrl = vmcs12->secondary_vm_exec_control &\n\t\t\t\t~SECONDARY_EXEC_ENABLE_PML;\n\t\t\texec_control |= vmcs12_exec_ctrl;\n\t\t}\n\n\t\t/* All VMFUNCs are currently emulated through L0 vmexits.  */\n\t\tif (exec_control & SECONDARY_EXEC_ENABLE_VMFUNC)\n\t\t\tvmcs_write64(VM_FUNCTION_CONTROL, 0);\n\n\t\tif (exec_control & SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY) {\n\t\t\tvmcs_write64(EOI_EXIT_BITMAP0,\n\t\t\t\tvmcs12->eoi_exit_bitmap0);\n\t\t\tvmcs_write64(EOI_EXIT_BITMAP1,\n\t\t\t\tvmcs12->eoi_exit_bitmap1);\n\t\t\tvmcs_write64(EOI_EXIT_BITMAP2,\n\t\t\t\tvmcs12->eoi_exit_bitmap2);\n\t\t\tvmcs_write64(EOI_EXIT_BITMAP3,\n\t\t\t\tvmcs12->eoi_exit_bitmap3);\n\t\t\tvmcs_write16(GUEST_INTR_STATUS,\n\t\t\t\tvmcs12->guest_intr_status);\n\t\t}\n\n\t\t/*\n\t\t * Write an illegal value to APIC_ACCESS_ADDR. Later,\n\t\t * nested_get_vmcs12_pages will either fix it up or\n\t\t * remove the VM execution control.\n\t\t */\n\t\tif (exec_control & SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES)\n\t\t\tvmcs_write64(APIC_ACCESS_ADDR, -1ull);\n\n\t\tvmcs_write32(SECONDARY_VM_EXEC_CONTROL, exec_control);\n\t}\n\n\n\t/*\n\t * Set host-state according to L0's settings (vmcs12 is irrelevant here)\n\t * Some constant fields are set here by vmx_set_constant_host_state().\n\t * Other fields are different per CPU, and will be set later when\n\t * vmx_vcpu_load() is called, and when vmx_save_host_state() is called.\n\t */\n\tvmx_set_constant_host_state(vmx);\n\n\t/*\n\t * Set the MSR load/store lists to match L0's settings.\n\t */\n\tvmcs_write32(VM_EXIT_MSR_STORE_COUNT, 0);\n\tvmcs_write32(VM_EXIT_MSR_LOAD_COUNT, vmx->msr_autoload.nr);\n\tvmcs_write64(VM_EXIT_MSR_LOAD_ADDR, __pa(vmx->msr_autoload.host));\n\tvmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, vmx->msr_autoload.nr);\n\tvmcs_write64(VM_ENTRY_MSR_LOAD_ADDR, __pa(vmx->msr_autoload.guest));\n\n\t/*\n\t * HOST_RSP is normally set correctly in vmx_vcpu_run() just before\n\t * entry, but only if the current (host) sp changed from the value\n\t * we wrote last (vmx->host_rsp). This cache is no longer relevant\n\t * if we switch vmcs, and rather than hold a separate cache per vmcs,\n\t * here we just force the write to happen on entry.\n\t */\n\tvmx->host_rsp = 0;\n\n\texec_control = vmx_exec_control(vmx); /* L0's desires */\n\texec_control &= ~CPU_BASED_VIRTUAL_INTR_PENDING;\n\texec_control &= ~CPU_BASED_VIRTUAL_NMI_PENDING;\n\texec_control &= ~CPU_BASED_TPR_SHADOW;\n\texec_control |= vmcs12->cpu_based_vm_exec_control;\n\n\t/*\n\t * Write an illegal value to VIRTUAL_APIC_PAGE_ADDR. Later, if\n\t * nested_get_vmcs12_pages can't fix it up, the illegal value\n\t * will result in a VM entry failure.\n\t */\n \tif (exec_control & CPU_BASED_TPR_SHADOW) {\n \t\tvmcs_write64(VIRTUAL_APIC_PAGE_ADDR, -1ull);\n \t\tvmcs_write32(TPR_THRESHOLD, vmcs12->tpr_threshold);\n \t}\n \n \t/*\n\t * Merging of IO bitmap not currently supported.\n\t * Rather, exit every time.\n\t */\n\texec_control &= ~CPU_BASED_USE_IO_BITMAPS;\n\texec_control |= CPU_BASED_UNCOND_IO_EXITING;\n\n\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL, exec_control);\n\n\t/* EXCEPTION_BITMAP and CR0_GUEST_HOST_MASK should basically be the\n\t * bitwise-or of what L1 wants to trap for L2, and what we want to\n\t * trap. Note that CR0.TS also needs updating - we do this later.\n\t */\n\tupdate_exception_bitmap(vcpu);\n\tvcpu->arch.cr0_guest_owned_bits &= ~vmcs12->cr0_guest_host_mask;\n\tvmcs_writel(CR0_GUEST_HOST_MASK, ~vcpu->arch.cr0_guest_owned_bits);\n\n\t/* L2->L1 exit controls are emulated - the hardware exit is to L0 so\n\t * we should use its exit controls. Note that VM_EXIT_LOAD_IA32_EFER\n\t * bits are further modified by vmx_set_efer() below.\n\t */\n\tvmcs_write32(VM_EXIT_CONTROLS, vmcs_config.vmexit_ctrl);\n\n\t/* vmcs12's VM_ENTRY_LOAD_IA32_EFER and VM_ENTRY_IA32E_MODE are\n\t * emulated by vmx_set_efer(), below.\n\t */\n\tvm_entry_controls_init(vmx, \n\t\t(vmcs12->vm_entry_controls & ~VM_ENTRY_LOAD_IA32_EFER &\n\t\t\t~VM_ENTRY_IA32E_MODE) |\n\t\t(vmcs_config.vmentry_ctrl & ~VM_ENTRY_IA32E_MODE));\n\n\tif (from_vmentry &&\n\t    (vmcs12->vm_entry_controls & VM_ENTRY_LOAD_IA32_PAT)) {\n\t\tvmcs_write64(GUEST_IA32_PAT, vmcs12->guest_ia32_pat);\n\t\tvcpu->arch.pat = vmcs12->guest_ia32_pat;\n\t} else if (vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_PAT) {\n\t\tvmcs_write64(GUEST_IA32_PAT, vmx->vcpu.arch.pat);\n\t}\n\n\tset_cr4_guest_host_mask(vmx);\n\n\tif (from_vmentry &&\n\t    vmcs12->vm_entry_controls & VM_ENTRY_LOAD_BNDCFGS)\n\t\tvmcs_write64(GUEST_BNDCFGS, vmcs12->guest_bndcfgs);\n\n\tif (vmcs12->cpu_based_vm_exec_control & CPU_BASED_USE_TSC_OFFSETING)\n\t\tvmcs_write64(TSC_OFFSET,\n\t\t\tvcpu->arch.tsc_offset + vmcs12->tsc_offset);\n\telse\n\t\tvmcs_write64(TSC_OFFSET, vcpu->arch.tsc_offset);\n\tif (kvm_has_tsc_control)\n\t\tdecache_tsc_multiplier(vmx);\n\n\tif (enable_vpid) {\n\t\t/*\n\t\t * There is no direct mapping between vpid02 and vpid12, the\n\t\t * vpid02 is per-vCPU for L0 and reused while the value of\n\t\t * vpid12 is changed w/ one invvpid during nested vmentry.\n\t\t * The vpid12 is allocated by L1 for L2, so it will not\n\t\t * influence global bitmap(for vpid01 and vpid02 allocation)\n\t\t * even if spawn a lot of nested vCPUs.\n\t\t */\n\t\tif (nested_cpu_has_vpid(vmcs12) && vmx->nested.vpid02) {\n\t\t\tvmcs_write16(VIRTUAL_PROCESSOR_ID, vmx->nested.vpid02);\n\t\t\tif (vmcs12->virtual_processor_id != vmx->nested.last_vpid) {\n\t\t\t\tvmx->nested.last_vpid = vmcs12->virtual_processor_id;\n\t\t\t\t__vmx_flush_tlb(vcpu, to_vmx(vcpu)->nested.vpid02);\n\t\t\t}\n\t\t} else {\n\t\t\tvmcs_write16(VIRTUAL_PROCESSOR_ID, vmx->vpid);\n\t\t\tvmx_flush_tlb(vcpu);\n\t\t}\n\n\t}\n\n\tif (enable_pml) {\n\t\t/*\n\t\t * Conceptually we want to copy the PML address and index from\n\t\t * vmcs01 here, and then back to vmcs01 on nested vmexit. But,\n\t\t * since we always flush the log on each vmexit, this happens\n\t\t * to be equivalent to simply resetting the fields in vmcs02.\n\t\t */\n\t\tASSERT(vmx->pml_pg);\n\t\tvmcs_write64(PML_ADDRESS, page_to_phys(vmx->pml_pg));\n\t\tvmcs_write16(GUEST_PML_INDEX, PML_ENTITY_NUM - 1);\n\t}\n\n\tif (nested_cpu_has_ept(vmcs12)) {\n\t\tif (nested_ept_init_mmu_context(vcpu)) {\n\t\t\t*entry_failure_code = ENTRY_FAIL_DEFAULT;\n\t\t\treturn 1;\n\t\t}\n\t} else if (nested_cpu_has2(vmcs12,\n\t\t\t\t   SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES)) {\n\t\tvmx_flush_tlb_ept_only(vcpu);\n\t}\n\n\t/*\n\t * This sets GUEST_CR0 to vmcs12->guest_cr0, possibly modifying those\n\t * bits which we consider mandatory enabled.\n\t * The CR0_READ_SHADOW is what L2 should have expected to read given\n\t * the specifications by L1; It's not enough to take\n\t * vmcs12->cr0_read_shadow because on our cr0_guest_host_mask we we\n\t * have more bits than L1 expected.\n\t */\n\tvmx_set_cr0(vcpu, vmcs12->guest_cr0);\n\tvmcs_writel(CR0_READ_SHADOW, nested_read_cr0(vmcs12));\n\n\tvmx_set_cr4(vcpu, vmcs12->guest_cr4);\n\tvmcs_writel(CR4_READ_SHADOW, nested_read_cr4(vmcs12));\n\n\tif (from_vmentry &&\n\t    (vmcs12->vm_entry_controls & VM_ENTRY_LOAD_IA32_EFER))\n\t\tvcpu->arch.efer = vmcs12->guest_ia32_efer;\n\telse if (vmcs12->vm_entry_controls & VM_ENTRY_IA32E_MODE)\n\t\tvcpu->arch.efer |= (EFER_LMA | EFER_LME);\n\telse\n\t\tvcpu->arch.efer &= ~(EFER_LMA | EFER_LME);\n\t/* Note: modifies VM_ENTRY/EXIT_CONTROLS and GUEST/HOST_IA32_EFER */\n\tvmx_set_efer(vcpu, vcpu->arch.efer);\n\n\t/* Shadow page tables on either EPT or shadow page tables. */\n\tif (nested_vmx_load_cr3(vcpu, vmcs12->guest_cr3, nested_cpu_has_ept(vmcs12),\n\t\t\t\tentry_failure_code))\n\t\treturn 1;\n\n\tif (!enable_ept)\n\t\tvcpu->arch.walk_mmu->inject_page_fault = vmx_inject_page_fault_nested;\n\n\t/*\n\t * L1 may access the L2's PDPTR, so save them to construct vmcs12\n\t */\n\tif (enable_ept) {\n\t\tvmcs_write64(GUEST_PDPTR0, vmcs12->guest_pdptr0);\n\t\tvmcs_write64(GUEST_PDPTR1, vmcs12->guest_pdptr1);\n\t\tvmcs_write64(GUEST_PDPTR2, vmcs12->guest_pdptr2);\n\t\tvmcs_write64(GUEST_PDPTR3, vmcs12->guest_pdptr3);\n\t}\n\n\tkvm_register_write(vcpu, VCPU_REGS_RSP, vmcs12->guest_rsp);\n\tkvm_register_write(vcpu, VCPU_REGS_RIP, vmcs12->guest_rip);\n\treturn 0;\n}\n", "target": 1, "idx": 181162}
{"func": "static long sock_do_ioctl(struct net *net, struct socket *sock,\n\t\t\t\t unsigned int cmd, unsigned long arg)\n{\n\tint err;\n\tvoid __user *argp = (void __user *)arg;\n\n\terr = sock->ops->ioctl(sock, cmd, arg);\n\n\t/*\n\t * If this ioctl is unknown try to hand it down\n\t * to the NIC driver.\n\t */\n\tif (err != -ENOIOCTLCMD)\n\t\treturn err;\n\n\tif (cmd == SIOCGIFCONF) {\n\t\tstruct ifconf ifc;\n\t\tif (copy_from_user(&ifc, argp, sizeof(struct ifconf)))\n\t\t\treturn -EFAULT;\n\t\trtnl_lock();\n\t\terr = dev_ifconf(net, &ifc, sizeof(struct ifreq));\n\t\trtnl_unlock();\n\t\tif (!err && copy_to_user(argp, &ifc, sizeof(struct ifconf)))\n\t\t\terr = -EFAULT;\n\t} else {\n\t\tstruct ifreq ifr;\n\t\tbool need_copyout;\n\t\tif (copy_from_user(&ifr, argp, sizeof(struct ifreq)))\n\t\t\treturn -EFAULT;\n\t\terr = dev_ioctl(net, cmd, &ifr, &need_copyout);\n\t\tif (!err && need_copyout)\n\t\t\tif (copy_to_user(argp, &ifr, sizeof(struct ifreq)))\n\t\t\t\treturn -EFAULT;\n\t}\n\treturn err;\n}\n", "target": 0, "idx": 82270}
{"func": " htmlParseElementInternal(htmlParserCtxtPtr ctxt) {\n     const xmlChar *name;\n     const htmlElemDesc * info;\n    htmlParserNodeInfo node_info = { 0, };\n     int failed;\n \n     if ((ctxt == NULL) || (ctxt->input == NULL)) {\n\thtmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\n\t\t     \"htmlParseElementInternal: context error\\n\", NULL, NULL);\n\treturn;\n    }\n\n    if (ctxt->instate == XML_PARSER_EOF)\n        return;\n\n    /* Capture start position */\n    if (ctxt->record_info) {\n        node_info.begin_pos = ctxt->input->consumed +\n                          (CUR_PTR - ctxt->input->base);\n\tnode_info.begin_line = ctxt->input->line;\n    }\n\n    failed = htmlParseStartTag(ctxt);\n    name = ctxt->name;\n    if ((failed == -1) || (name == NULL)) {\n\tif (CUR == '>')\n\t    NEXT;\n        return;\n    }\n\n    /*\n     * Lookup the info for that element.\n     */\n    info = htmlTagLookup(name);\n    if (info == NULL) {\n\thtmlParseErr(ctxt, XML_HTML_UNKNOWN_TAG,\n\t             \"Tag %s invalid\\n\", name, NULL);\n    }\n\n    /*\n     * Check for an Empty Element labeled the XML/SGML way\n     */\n    if ((CUR == '/') && (NXT(1) == '>')) {\n        SKIP(2);\n\tif ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL))\n\t    ctxt->sax->endElement(ctxt->userData, name);\n\thtmlnamePop(ctxt);\n\treturn;\n    }\n\n    if (CUR == '>') {\n        NEXT;\n    } else {\n\thtmlParseErr(ctxt, XML_ERR_GT_REQUIRED,\n\t             \"Couldn't find end of Start Tag %s\\n\", name, NULL);\n\n\t/*\n\t * end of parsing of this node.\n\t */\n\tif (xmlStrEqual(name, ctxt->name)) {\n\t    nodePop(ctxt);\n\t    htmlnamePop(ctxt);\n\t}\n\n        if (ctxt->record_info)\n            htmlNodeInfoPush(ctxt, &node_info);\n        htmlParserFinishElementParsing(ctxt);\n\treturn;\n    }\n\n    /*\n     * Check for an Empty Element from DTD definition\n     */\n    if ((info != NULL) && (info->empty)) {\n\tif ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL))\n\t    ctxt->sax->endElement(ctxt->userData, name);\n\thtmlnamePop(ctxt);\n\treturn;\n    }\n\n    if (ctxt->record_info)\n        htmlNodeInfoPush(ctxt, &node_info);\n}\n", "target": 1, "idx": 186924}
{"func": "nm_ip4_config_get_ifindex (const NMIP4Config *config)\n{\n\treturn NM_IP4_CONFIG_GET_PRIVATE (config)->ifindex;\n}\n", "target": 0, "idx": 6352}
{"func": "static int parse_sliteral(char **c, char **dst)\n{\n\tstruct token t;\n\tchar *s = *c;\n\n\tget_token(c, &t, L_SLITERAL);\n\n\tif (t.type != T_STRING) {\n\t\tprintf(\"Expected string literal: %.*s\\n\", (int)(*c - s), s);\n\t\treturn -EINVAL;\n\t}\n\n\t*dst = t.val;\n\n\treturn 1;\n}\n", "target": 0, "idx": 89352}
{"func": "cmsPipeline* DefaultICCintents(cmsContext       ContextID,\n                               cmsUInt32Number  nProfiles,\n                               cmsUInt32Number  TheIntents[],\n                               cmsHPROFILE      hProfiles[],\n                               cmsBool          BPC[],\n                               cmsFloat64Number AdaptationStates[],\n                               cmsUInt32Number  dwFlags)\n{\n    cmsPipeline* Lut = NULL;\n    cmsPipeline* Result;\n    cmsHPROFILE hProfile;\n    cmsMAT3 m;\n    cmsVEC3 off;\n    cmsColorSpaceSignature ColorSpaceIn, ColorSpaceOut, CurrentColorSpace;\n    cmsProfileClassSignature ClassSig;\n    cmsUInt32Number  i, Intent;\n\n    if (nProfiles == 0) return NULL;\n\n    Result = cmsPipelineAlloc(ContextID, 0, 0);\n    if (Result == NULL) return NULL;\n\n    CurrentColorSpace = cmsGetColorSpace(hProfiles[0]);\n\n    for (i=0; i < nProfiles; i++) {\n\n        cmsBool  lIsDeviceLink, lIsInput;\n\n        hProfile      = hProfiles[i];\n        ClassSig      = cmsGetDeviceClass(hProfile);\n        lIsDeviceLink = (ClassSig == cmsSigLinkClass || ClassSig == cmsSigAbstractClass );\n\n        if ((i == 0) && !lIsDeviceLink) {\n            lIsInput = TRUE;\n        }\n        else {\n        lIsInput      = (CurrentColorSpace != cmsSigXYZData) &&\n                        (CurrentColorSpace != cmsSigLabData);\n        }\n\n        Intent        = TheIntents[i];\n\n        if (lIsInput || lIsDeviceLink) {\n\n            ColorSpaceIn    = cmsGetColorSpace(hProfile);\n            ColorSpaceOut   = cmsGetPCS(hProfile);\n        }\n        else {\n\n            ColorSpaceIn    = cmsGetPCS(hProfile);\n            ColorSpaceOut   = cmsGetColorSpace(hProfile);\n        }\n\n        if (!ColorSpaceIsCompatible(ColorSpaceIn, CurrentColorSpace)) {\n\n            cmsSignalError(ContextID, cmsERROR_COLORSPACE_CHECK, \"ColorSpace mismatch\");\n            goto Error;\n        }\n\n        if (lIsDeviceLink || ((ClassSig == cmsSigNamedColorClass) && (nProfiles == 1))) {\n\n            Lut = _cmsReadDevicelinkLUT(hProfile, Intent);\n            if (Lut == NULL) goto Error;\n\n             if (ClassSig == cmsSigAbstractClass && i > 0) {\n                if (!ComputeConversion(i, hProfiles, Intent, BPC[i], AdaptationStates[i], &m, &off)) goto Error;\n             }\n             else {\n                _cmsMAT3identity(&m);\n                _cmsVEC3init(&off, 0, 0, 0);\n             }\n\n\n            if (!AddConversion(Result, CurrentColorSpace, ColorSpaceIn, &m, &off)) goto Error;\n\n        }\n        else {\n\n            if (lIsInput) {\n                Lut = _cmsReadInputLUT(hProfile, Intent);\n                if (Lut == NULL) goto Error;\n            }\n            else {\n\n                Lut = _cmsReadOutputLUT(hProfile, Intent);\n                if (Lut == NULL) goto Error;\n\n\n                if (!ComputeConversion(i, hProfiles, Intent, BPC[i], AdaptationStates[i], &m, &off)) goto Error;\n                if (!AddConversion(Result, CurrentColorSpace, ColorSpaceIn, &m, &off)) goto Error;\n\n            }\n        }\n\n         if (!cmsPipelineCat(Result, Lut))\n             goto Error;\n         cmsPipelineFree(Lut);\n \n         CurrentColorSpace = ColorSpaceOut;\n    }\n\n    return Result;\n \n Error:\n \n    cmsPipelineFree(Lut);\n     if (Result != NULL) cmsPipelineFree(Result);\n     return NULL;\n \n    cmsUNUSED_PARAMETER(dwFlags);\n}\n", "target": 1, "idx": 180764}
{"func": "void CuePoint::TrackPosition::Parse(IMkvReader* pReader, long long start_,\n                                     long long size_) {\n   const long long stop = start_ + size_;\n   long long pos = start_;\n\n  m_track = -1;\n  m_pos = -1;\n  m_block = 1; // default\n\n\n   while (pos < stop) {\n     long len;\n \n    const long long id = ReadUInt(pReader, pos, len);\n    assert(id >= 0);  // TODO\n    assert((pos + len) <= stop);\n \n     pos += len;  // consume ID\n \n     const long long size = ReadUInt(pReader, pos, len);\n    assert(size >= 0);\n    assert((pos + len) <= stop);\n \n     pos += len;  // consume Size field\n    assert((pos + size) <= stop);\n \n     if (id == 0x77)  // CueTrack ID\n       m_track = UnserializeUInt(pReader, pos, size);\n\n else if (id == 0x71) // CueClusterPos ID\n      m_pos = UnserializeUInt(pReader, pos, size);\n\n else if (id == 0x1378) // CueBlockNumber\n\n       m_block = UnserializeUInt(pReader, pos, size);\n \n     pos += size;  // consume payload\n    assert(pos <= stop);\n   }\n \n  assert(m_pos >= 0);\n  assert(m_track > 0);\n }\n", "target": 1, "idx": 187859}
{"func": " void RenderViewImpl::EnsureMediaStreamImpl() {\n  if (!RenderThreadImpl::current())  // Will be NULL during unit tests.\n    return;\n\n#if defined(ENABLE_WEBRTC)\n  if (!media_stream_dispatcher_)\n    media_stream_dispatcher_ = new MediaStreamDispatcher(this);\n\n  if (!media_stream_impl_) {\n    media_stream_impl_ = new MediaStreamImpl(\n        this,\n        media_stream_dispatcher_,\n        RenderThreadImpl::current()->video_capture_impl_manager(),\n        RenderThreadImpl::current()->GetMediaStreamDependencyFactory());\n  }\n#endif\n}\n", "target": 0, "idx": 108861}
{"func": "static int irda_discover_daddr_and_lsap_sel(struct irda_sock *self, char *name)\n{\n\tdiscinfo_t *discoveries;\t/* Copy of the discovery log */\n\tint\tnumber;\t\t\t/* Number of nodes in the log */\n\tint\ti;\n\tint\terr = -ENETUNREACH;\n\t__u32\tdaddr = DEV_ADDR_ANY;\t/* Address we found the service on */\n\t__u8\tdtsap_sel = 0x0;\t/* TSAP associated with it */\n\n\tIRDA_DEBUG(2, \"%s(), name=%s\\n\", __func__, name);\n\n\t/* Ask lmp for the current discovery log\n\t * Note : we have to use irlmp_get_discoveries(), as opposed\n\t * to play with the cachelog directly, because while we are\n\t * making our ias query, le log might change... */\n\tdiscoveries = irlmp_get_discoveries(&number, self->mask.word,\n\t\t\t\t\t    self->nslots);\n\t/* Check if the we got some results */\n\tif (discoveries == NULL)\n\t\treturn -ENETUNREACH;\t/* No nodes discovered */\n\n\t/*\n\t * Now, check all discovered devices (if any), and connect\n\t * client only about the services that the client is\n\t * interested in...\n\t */\n\tfor(i = 0; i < number; i++) {\n\t\t/* Try the address in the log */\n\t\tself->daddr = discoveries[i].daddr;\n\t\tself->saddr = 0x0;\n\t\tIRDA_DEBUG(1, \"%s(), trying daddr = %08x\\n\",\n\t\t\t   __func__, self->daddr);\n\n\t\t/* Query remote LM-IAS for this service */\n\t\terr = irda_find_lsap_sel(self, name);\n\t\tswitch (err) {\n\t\tcase 0:\n\t\t\t/* We found the requested service */\n\t\t\tif(daddr != DEV_ADDR_ANY) {\n\t\t\t\tIRDA_DEBUG(1, \"%s(), discovered service ''%s'' in two different devices !!!\\n\",\n\t\t\t\t\t   __func__, name);\n\t\t\t\tself->daddr = DEV_ADDR_ANY;\n\t\t\t\tkfree(discoveries);\n\t\t\t\treturn -ENOTUNIQ;\n\t\t\t}\n\t\t\t/* First time we found that one, save it ! */\n\t\t\tdaddr = self->daddr;\n\t\t\tdtsap_sel = self->dtsap_sel;\n\t\t\tbreak;\n\t\tcase -EADDRNOTAVAIL:\n\t\t\t/* Requested service simply doesn't exist on this node */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* Something bad did happen :-( */\n\t\t\tIRDA_DEBUG(0, \"%s(), unexpected IAS query failure\\n\", __func__);\n\t\t\tself->daddr = DEV_ADDR_ANY;\n\t\t\tkfree(discoveries);\n\t\t\treturn -EHOSTUNREACH;\n\t\t\tbreak;\n\t\t}\n\t}\n\t/* Cleanup our copy of the discovery log */\n\tkfree(discoveries);\n\n\t/* Check out what we found */\n\tif(daddr == DEV_ADDR_ANY) {\n\t\tIRDA_DEBUG(1, \"%s(), cannot discover service ''%s'' in any device !!!\\n\",\n\t\t\t   __func__, name);\n\t\tself->daddr = DEV_ADDR_ANY;\n\t\treturn -EADDRNOTAVAIL;\n\t}\n\n\t/* Revert back to discovered device & service */\n\tself->daddr = daddr;\n\tself->saddr = 0x0;\n\tself->dtsap_sel = dtsap_sel;\n\n\tIRDA_DEBUG(1, \"%s(), discovered requested service ''%s'' at address %08x\\n\",\n\t\t   __func__, name, self->daddr);\n\n\treturn 0;\n}\n", "target": 0, "idx": 30642}
{"func": "void RenderFrameHostImpl::ExecuteJavaScriptInIsolatedWorld(\n    const base::string16& javascript,\n    const JavaScriptResultCallback& callback,\n    int world_id) {\n  if (world_id <= ISOLATED_WORLD_ID_GLOBAL ||\n      world_id > ISOLATED_WORLD_ID_MAX) {\n    NOTREACHED();\n    return;\n  }\n\n  int key = 0;\n  bool request_reply = false;\n  if (!callback.is_null()) {\n    request_reply = true;\n    key = g_next_javascript_callback_id++;\n    javascript_callbacks_.insert(std::make_pair(key, callback));\n  }\n\n  Send(new FrameMsg_JavaScriptExecuteRequestInIsolatedWorld(\n      routing_id_, javascript, key, request_reply, world_id));\n}\n", "target": 0, "idx": 138672}
{"func": "BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n \tif (out == NULL) {\n \t\treturn NULL;\n \t}\n\tgdImageWebpCtx(im, out, quality);\n\trv = gdDPExtractData(out, size);\n \tout->gd_free(out);\n \treturn rv;\n }\n", "target": 1, "idx": 181992}
{"func": "static void start_unregistering(struct ctl_table_header *p)\n{\n\t/*\n\t * if p->used is 0, nobody will ever touch that entry again;\n\t * we'll eliminate all paths to it before dropping sysctl_lock\n\t */\n\tif (unlikely(p->used)) {\n\t\tstruct completion wait;\n\t\tinit_completion(&wait);\n\t\tp->unregistering = &wait;\n\t\tspin_unlock(&sysctl_lock);\n\t\twait_for_completion(&wait);\n\t\tspin_lock(&sysctl_lock);\n\t} else {\n\t\t/* anything non-NULL; we'll never dereference it */\n\t\tp->unregistering = ERR_PTR(-EINVAL);\n\t}\n\t/*\n\t * do not remove from the list until nobody holds it; walking the\n\t * list in do_sysctl() relies on that.\n\t */\n\terase_header(p);\n}\n", "target": 0, "idx": 48498}
{"func": "static void sock_spd_release(struct splice_pipe_desc *spd, unsigned int i)\n{\n\tput_page(spd->pages[i]);\n}\n", "target": 0, "idx": 39939}
{"func": "struct sas_phy *sas_get_local_phy(struct domain_device *dev)\n{\n\tstruct sas_ha_struct *ha = dev->port->ha;\n\tstruct sas_phy *phy;\n\tunsigned long flags;\n\n\t/* a published domain device always has a valid phy, it may be\n\t * stale, but it is never NULL\n\t */\n\tBUG_ON(!dev->phy);\n\n\tspin_lock_irqsave(&ha->phy_port_lock, flags);\n\tphy = dev->phy;\n\tget_device(&phy->dev);\n\tspin_unlock_irqrestore(&ha->phy_port_lock, flags);\n\n\treturn phy;\n}\n", "target": 0, "idx": 83264}
{"func": "void Browser::FindInPage(bool find_next, bool forward_direction) {\n  ShowFindBar();\n  if (find_next) {\n    string16 find_text;\n#if defined(OS_MACOSX)\n     find_text = GetFindPboardText();\n #endif\n     GetSelectedTabContentsWrapper()->\n        GetFindManager()->StartFinding(find_text,\n                                       forward_direction,\n                                       false);  // Not case sensitive.\n   }\n }\n", "target": 1, "idx": 184124}
{"func": "INST_HANDLER (sleep) {\t// SLEEP\n\tESIL_A (\"BREAK\");\n}\n", "target": 0, "idx": 82761}
{"func": "void SplashOutputDev::clipToStrokePath(GfxState *state) {\n  SplashPath *path, *path2;\n\n  path = convertPath(state, state->getPath());\n  path2 = splash->makeStrokePath(path);\n  delete path;\n  splash->clipToPath(path2, gFalse);\n  delete path2;\n}\n", "target": 0, "idx": 825}
{"func": "blink::WebPlugin* RenderFrameImpl::CreatePlugin(\n    const blink::WebPluginParams& params) {\n  blink::WebPlugin* plugin = nullptr;\n  if (GetContentClient()->renderer()->OverrideCreatePlugin(this, params,\n                                                           &plugin)) {\n    return plugin;\n  }\n\n  if (params.mime_type.ContainsOnlyASCII() &&\n      params.mime_type.Ascii() == kBrowserPluginMimeType) {\n    BrowserPluginDelegate* delegate =\n        GetContentClient()->renderer()->CreateBrowserPluginDelegate(\n            this, WebPluginInfo(), kBrowserPluginMimeType, GURL(params.url));\n    return BrowserPluginManager::Get()->CreateBrowserPlugin(\n        this, delegate->GetWeakPtr());\n  }\n\n#if BUILDFLAG(ENABLE_PLUGINS)\n  WebPluginInfo info;\n  std::string mime_type;\n  bool found = false;\n  Send(new FrameHostMsg_GetPluginInfo(\n      routing_id_, params.url, frame_->Top()->GetSecurityOrigin(),\n      params.mime_type.Utf8(), &found, &info, &mime_type));\n  if (!found)\n    return nullptr;\n\n  WebPluginParams params_to_use = params;\n  params_to_use.mime_type = WebString::FromUTF8(mime_type);\n  return CreatePlugin(info, params_to_use, nullptr /* throttler */);\n#else\n  return nullptr;\n#endif  // BUILDFLAG(ENABLE_PLUGINS)\n}\n", "target": 0, "idx": 152235}
{"func": "SchedulerHelper::SchedulerHelper(\n    scoped_refptr<NestableSingleThreadTaskRunner> main_task_runner,\n    const char* tracing_category,\n    const char* disabled_by_default_tracing_category,\n    size_t total_task_queue_count)\n    : task_queue_selector_(new PrioritizingTaskQueueSelector()),\n      task_queue_manager_(\n          new TaskQueueManager(total_task_queue_count,\n                               main_task_runner,\n                               task_queue_selector_.get(),\n                               disabled_by_default_tracing_category)),\n      quiescence_monitored_task_queue_mask_(\n          ((1ull << total_task_queue_count) - 1ull) &\n          ~(1ull << QueueId::CONTROL_TASK_QUEUE) &\n          ~(1ull << QueueId::CONTROL_TASK_AFTER_WAKEUP_QUEUE)),\n      control_task_runner_(\n          task_queue_manager_->TaskRunnerForQueue(QueueId::CONTROL_TASK_QUEUE)),\n      control_after_wakeup_task_runner_(task_queue_manager_->TaskRunnerForQueue(\n           QueueId::CONTROL_TASK_AFTER_WAKEUP_QUEUE)),\n       default_task_runner_(\n           task_queue_manager_->TaskRunnerForQueue(QueueId::DEFAULT_TASK_QUEUE)),\n      time_source_(new TimeSource),\n       tracing_category_(tracing_category),\n       disabled_by_default_tracing_category_(\n           disabled_by_default_tracing_category) {\n  DCHECK_GE(total_task_queue_count,\n            static_cast<size_t>(QueueId::TASK_QUEUE_COUNT));\n  task_queue_selector_->SetQueuePriority(\n      QueueId::CONTROL_TASK_QUEUE,\n      PrioritizingTaskQueueSelector::CONTROL_PRIORITY);\n  task_queue_manager_->SetWakeupPolicy(\n      QueueId::CONTROL_TASK_QUEUE,\n      TaskQueueManager::WakeupPolicy::DONT_WAKE_OTHER_QUEUES);\n\n  task_queue_selector_->SetQueuePriority(\n      QueueId::CONTROL_TASK_AFTER_WAKEUP_QUEUE,\n      PrioritizingTaskQueueSelector::CONTROL_PRIORITY);\n  task_queue_manager_->SetPumpPolicy(\n      QueueId::CONTROL_TASK_AFTER_WAKEUP_QUEUE,\n      TaskQueueManager::PumpPolicy::AFTER_WAKEUP);\n  task_queue_manager_->SetWakeupPolicy(\n      QueueId::CONTROL_TASK_AFTER_WAKEUP_QUEUE,\n      TaskQueueManager::WakeupPolicy::DONT_WAKE_OTHER_QUEUES);\n\n  for (size_t i = 0; i < TASK_QUEUE_COUNT; i++) {\n    task_queue_manager_->SetQueueName(\n        i, TaskQueueIdToString(static_cast<QueueId>(i)));\n  }\n\n  task_queue_manager_->SetWorkBatchSize(1);\n}\n", "target": 1, "idx": 185498}
{"func": "void ContextState::RestoreRenderbufferBindings() {\n  bound_renderbuffer_valid = false;\n}\n", "target": 0, "idx": 162816}
{"func": "void BluetoothDeviceChromeOS::RequestPinCode(\n    const dbus::ObjectPath& device_path,\n    const PinCodeCallback& callback) {\n  DCHECK(agent_.get());\n  DCHECK(device_path == object_path_);\n  VLOG(1) << object_path_.value() << \": RequestPinCode\";\n  UMA_HISTOGRAM_ENUMERATION(\"Bluetooth.PairingMethod\",\n                            UMA_PAIRING_METHOD_REQUEST_PINCODE,\n                            UMA_PAIRING_METHOD_COUNT);\n  DCHECK(pairing_delegate_);\n  DCHECK(pincode_callback_.is_null());\n  pincode_callback_ = callback;\n  pairing_delegate_->RequestPinCode(this);\n  pairing_delegate_used_ = true;\n}\n", "target": 1, "idx": 184929}
{"func": "PHP_FUNCTION(openssl_pkcs12_export_to_file)\n{\n\tX509 * cert = NULL;\n\tBIO * bio_out = NULL;\n\tPKCS12 * p12 = NULL;\n\tchar * filename;\n\tchar * friendly_name = NULL;\n\tint filename_len;\n\tchar * pass;\n\tint pass_len;\n\tzval **zcert = NULL, *zpkey = NULL, *args = NULL;\n\tEVP_PKEY *priv_key = NULL;\n\tlong certresource, keyresource;\n\tzval ** item;\n\tSTACK_OF(X509) *ca = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"Zpzs|a\", &zcert, &filename, &filename_len, &zpkey, &pass, &pass_len, &args) == FAILURE)\n\t\treturn;\n\n\tRETVAL_FALSE;\n\t\n\tcert = php_openssl_x509_from_zval(zcert, 0, &certresource TSRMLS_CC);\n\tif (cert == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"cannot get cert from parameter 1\");\n\t\treturn;\n\t}\n\tpriv_key = php_openssl_evp_from_zval(&zpkey, 0, \"\", 1, &keyresource TSRMLS_CC);\n\tif (priv_key == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"cannot get private key from parameter 3\");\n\t\tgoto cleanup;\n\t}\n\tif (cert && !X509_check_private_key(cert, priv_key)) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"private key does not correspond to cert\");\n\t\tgoto cleanup;\n\t}\n\tif (php_openssl_open_base_dir_chk(filename TSRMLS_CC)) {\n\t\tgoto cleanup;\n\t}\n\n\t/* parse extra config from args array, promote this to an extra function */\n\tif (args && zend_hash_find(Z_ARRVAL_P(args), \"friendly_name\", sizeof(\"friendly_name\"), (void**)&item) == SUCCESS && Z_TYPE_PP(item) == IS_STRING)\n\t\tfriendly_name = Z_STRVAL_PP(item);\n\t/* certpbe (default RC2-40)\n\t   keypbe (default 3DES)\n\t   friendly_caname\n\t*/\n\n\tif (args && zend_hash_find(Z_ARRVAL_P(args), \"extracerts\", sizeof(\"extracerts\"), (void**)&item) == SUCCESS)\n\t\tca = php_array_to_X509_sk(item TSRMLS_CC);\n\t/* end parse extra config */\n\n\t/*PKCS12 *PKCS12_create(char *pass, char *name, EVP_PKEY *pkey, X509 *cert, STACK_OF(X509) *ca,\n                                       int nid_key, int nid_cert, int iter, int mac_iter, int keytype);*/\n\n\tp12 = PKCS12_create(pass, friendly_name, priv_key, cert, ca, 0, 0, 0, 0, 0);\n\n\tbio_out = BIO_new_file(filename, \"w\"); \n\tif (bio_out) {\n\t\t\n\t\ti2d_PKCS12_bio(bio_out, p12);\n\n\t\tRETVAL_TRUE;\n\t} else {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"error opening file %s\", filename);\n\t}\n\n\tBIO_free(bio_out);\n\tPKCS12_free(p12);\n\tphp_sk_X509_free(ca);\n\t\ncleanup:\n\n\tif (keyresource == -1 && priv_key) {\n\t\tEVP_PKEY_free(priv_key);\n\t}\n\tif (certresource == -1 && cert) { \n\t\tX509_free(cert);\n\t}\n}\n", "target": 0, "idx": 4652}
{"func": "status_t DRMSource::start(MetaData *params) {\n int32_t val;\n if (params && params->findInt32(kKeyWantsNALFragments, &val)\n && val != 0) {\n        mWantsNALFragments = true;\n } else {\n        mWantsNALFragments = false;\n }\n\n return mOriginalMediaSource->start(params);\n}\n", "target": 0, "idx": 173639}
{"func": "void RenderFrameImpl::WillSendRequest(blink::WebURLRequest& request) {\n  if (committing_main_request_ &&\n      request.GetFrameType() !=\n          network::mojom::RequestContextFrameType::kNone) {\n    return;\n  }\n\n  if (render_view_->renderer_preferences_.enable_do_not_track)\n    request.SetHTTPHeaderField(blink::WebString::FromUTF8(kDoNotTrackHeader),\n                               \"1\");\n\n  WebDocumentLoader* provisional_document_loader =\n      frame_->GetProvisionalDocumentLoader();\n  WebDocumentLoader* document_loader = provisional_document_loader\n                                           ? provisional_document_loader\n                                           : frame_->GetDocumentLoader();\n  InternalDocumentStateData* internal_data =\n      InternalDocumentStateData::FromDocumentLoader(document_loader);\n  NavigationState* navigation_state = internal_data->navigation_state();\n  ui::PageTransition transition_type =\n      GetTransitionType(document_loader, frame_, false /* loading */);\n  if (provisional_document_loader &&\n      provisional_document_loader->IsClientRedirect()) {\n    transition_type = ui::PageTransitionFromInt(\n        transition_type | ui::PAGE_TRANSITION_CLIENT_REDIRECT);\n  }\n\n  ApplyFilePathAlias(&request);\n  GURL new_url;\n  bool attach_same_site_cookies = false;\n  base::Optional<url::Origin> initiator_origin =\n      request.RequestorOrigin().IsNull()\n          ? base::Optional<url::Origin>()\n          : base::Optional<url::Origin>(request.RequestorOrigin());\n  GetContentClient()->renderer()->WillSendRequest(\n      frame_, transition_type, request.Url(),\n      base::OptionalOrNullptr(initiator_origin), &new_url,\n      &attach_same_site_cookies);\n  if (!new_url.is_empty())\n    request.SetURL(WebURL(new_url));\n\n  if (internal_data->is_cache_policy_override_set())\n    request.SetCacheMode(internal_data->cache_policy_override());\n\n  WebString custom_user_agent;\n  std::unique_ptr<NavigationResponseOverrideParameters> response_override;\n  if (request.GetExtraData()) {\n    RequestExtraData* old_extra_data =\n        static_cast<RequestExtraData*>(request.GetExtraData());\n\n    custom_user_agent = old_extra_data->custom_user_agent();\n    if (!custom_user_agent.IsNull()) {\n      if (custom_user_agent.IsEmpty())\n        request.ClearHTTPHeaderField(\"User-Agent\");\n      else\n        request.SetHTTPHeaderField(\"User-Agent\", custom_user_agent);\n    }\n    response_override =\n        old_extra_data->TakeNavigationResponseOverrideOwnership();\n  }\n\n  request.SetHTTPOriginIfNeeded(WebSecurityOrigin::CreateUnique());\n\n  WebFrame* parent = frame_->Parent();\n\n  ResourceType resource_type = WebURLRequestToResourceType(request);\n  WebDocument frame_document = frame_->GetDocument();\n  if (!request.GetExtraData())\n    request.SetExtraData(std::make_unique<RequestExtraData>());\n  auto* extra_data = static_cast<RequestExtraData*>(request.GetExtraData());\n  extra_data->set_is_preprerendering(\n      GetContentClient()->renderer()->IsPrerenderingFrame(this));\n  extra_data->set_custom_user_agent(custom_user_agent);\n  extra_data->set_render_frame_id(routing_id_);\n  extra_data->set_is_main_frame(!parent);\n  extra_data->set_allow_download(IsNavigationDownloadAllowed(\n      navigation_state->common_params().download_policy));\n  extra_data->set_transition_type(transition_type);\n  extra_data->set_navigation_response_override(std::move(response_override));\n  bool is_for_no_state_prefetch =\n      GetContentClient()->renderer()->IsPrefetchOnly(this, request);\n  extra_data->set_is_for_no_state_prefetch(is_for_no_state_prefetch);\n  extra_data->set_initiated_in_secure_context(frame_document.IsSecureContext());\n  extra_data->set_attach_same_site_cookies(attach_same_site_cookies);\n  extra_data->set_frame_request_blocker(frame_request_blocker_);\n\n  request.SetDownloadToNetworkCacheOnly(\n      is_for_no_state_prefetch && resource_type != RESOURCE_TYPE_MAIN_FRAME);\n\n  RenderThreadImpl* render_thread = RenderThreadImpl::current();\n  if (render_thread && render_thread->url_loader_throttle_provider()) {\n    extra_data->set_url_loader_throttles(\n        render_thread->url_loader_throttle_provider()->CreateThrottles(\n            routing_id_, request, resource_type));\n  }\n\n  if (request.GetPreviewsState() == WebURLRequest::kPreviewsUnspecified) {\n    if (is_main_frame_ && !navigation_state->request_committed()) {\n      request.SetPreviewsState(static_cast<WebURLRequest::PreviewsState>(\n          navigation_state->common_params().previews_state));\n    } else {\n      WebURLRequest::PreviewsState request_previews_state =\n          static_cast<WebURLRequest::PreviewsState>(previews_state_);\n\n      request_previews_state &= ~(WebURLRequest::kClientLoFiOn);\n      request_previews_state &= ~(WebURLRequest::kLazyImageLoadDeferred);\n      if (request_previews_state == WebURLRequest::kPreviewsUnspecified)\n        request_previews_state = WebURLRequest::kPreviewsOff;\n\n      request.SetPreviewsState(request_previews_state);\n    }\n  }\n\n  request.SetRequestorID(render_view_->GetRoutingID());\n  request.SetHasUserGesture(\n      WebUserGestureIndicator::IsProcessingUserGesture(frame_));\n\n  if (!render_view_->renderer_preferences_.enable_referrers)\n    request.SetHTTPReferrer(WebString(),\n                            network::mojom::ReferrerPolicy::kDefault);\n}\n", "target": 0, "idx": 165942}
{"func": "void BluetoothDeviceChromeOS::UnregisterAgent() {\n  if (!agent_.get())\n    return;\n  DCHECK(pairing_delegate_);\n  DCHECK(pincode_callback_.is_null());\n  DCHECK(passkey_callback_.is_null());\n  DCHECK(confirmation_callback_.is_null());\n  pairing_delegate_->DismissDisplayOrConfirm();\n  pairing_delegate_ = NULL;\n  agent_.reset();\n  VLOG(1) << object_path_.value() << \": Unregistering pairing agent\";\n  DBusThreadManager::Get()->GetBluetoothAgentManagerClient()->\n      UnregisterAgent(\n          dbus::ObjectPath(kAgentPath),\n          base::Bind(&base::DoNothing),\n          base::Bind(&BluetoothDeviceChromeOS::OnUnregisterAgentError,\n                     weak_ptr_factory_.GetWeakPtr()));\n}\n", "target": 1, "idx": 184933}
{"func": "void V8LazyEventListener::prepareListenerObject(ExecutionContext* executionContext)\n{\n    if (!executionContext)\n        return;\n\n    v8::HandleScope handleScope(toIsolate(executionContext));\n    v8::Local<v8::Context> v8Context = toV8Context(executionContext, world());\n    if (v8Context.IsEmpty())\n        return;\n    ScriptState* scriptState = ScriptState::from(v8Context);\n     if (!scriptState->contextIsValid())\n         return;\n \n    if (executionContext->isDocument() && !toDocument(executionContext)->allowInlineEventHandlers(m_node, this, m_sourceURL, m_position.m_line)) {\n         clearListenerObject();\n         return;\n     }\n \n     if (hasExistingListenerObject())\n         return;\n \n    ASSERT(executionContext->isDocument());\n     ScriptState::Scope scope(scriptState);\n     String listenerSource =  InspectorInstrumentation::preprocessEventListener(toDocument(executionContext)->frame(), m_code, m_sourceURL, m_functionName);\n \n    String code = \"(function() {\"\n        \"with (this[2]) {\"\n        \"with (this[1]) {\"\n        \"with (this[0]) {\"\n            \"return function(\" + m_eventParameterName + \") {\" +\n                listenerSource + \"\\n\" // Insert '\\n' otherwise //-style comments could break the handler.\n            \"};\"\n        \"}}}})\";\n\n    v8::Handle<v8::String> codeExternalString = v8String(isolate(), code);\n\n    v8::Local<v8::Value> result = V8ScriptRunner::compileAndRunInternalScript(codeExternalString, isolate(), m_sourceURL, m_position);\n    if (result.IsEmpty())\n         return;\n \n    ASSERT(result->IsFunction());\n     v8::Local<v8::Function> intermediateFunction = result.As<v8::Function>();\n \n     HTMLFormElement* formElement = 0;\n    if (m_node && m_node->isHTMLElement())\n        formElement = toHTMLElement(m_node)->formOwner();\n\n    v8::Handle<v8::Object> nodeWrapper = toObjectWrapper<Node>(m_node, scriptState);\n    v8::Handle<v8::Object> formWrapper = toObjectWrapper<HTMLFormElement>(formElement, scriptState);\n    v8::Handle<v8::Object> documentWrapper = toObjectWrapper<Document>(m_node ? m_node->ownerDocument() : 0, scriptState);\n\n    v8::Local<v8::Object> thisObject = v8::Object::New(isolate());\n    if (thisObject.IsEmpty())\n        return;\n    if (!thisObject->ForceSet(v8::Integer::New(isolate(), 0), nodeWrapper))\n        return;\n    if (!thisObject->ForceSet(v8::Integer::New(isolate(), 1), formWrapper))\n        return;\n    if (!thisObject->ForceSet(v8::Integer::New(isolate(), 2), documentWrapper))\n        return;\n\n    v8::Local<v8::Value> innerValue = V8ScriptRunner::callInternalFunction(intermediateFunction, thisObject, 0, 0, isolate());\n    if (innerValue.IsEmpty() || !innerValue->IsFunction())\n        return;\n\n    v8::Local<v8::Function> wrappedFunction = innerValue.As<v8::Function>();\n\n    v8::Local<v8::Function> toStringFunction = v8::Function::New(isolate(), V8LazyEventListenerToString);\n    ASSERT(!toStringFunction.IsEmpty());\n    String toStringString = \"function \" + m_functionName + \"(\" + m_eventParameterName + \") {\\n  \" + m_code + \"\\n}\";\n    V8HiddenValue::setHiddenValue(isolate(), wrappedFunction, V8HiddenValue::toStringString(isolate()), v8String(isolate(), toStringString));\n    wrappedFunction->Set(v8AtomicString(isolate(), \"toString\"), toStringFunction);\n    wrappedFunction->SetName(v8String(isolate(), m_functionName));\n\n\n    setListenerObject(wrappedFunction);\n}\n", "target": 1, "idx": 185934}
{"func": "static int shmem_remount_fs(struct super_block *sb, int *flags, char *data)\n{\n\tstruct shmem_sb_info *sbinfo = SHMEM_SB(sb);\n\tstruct shmem_sb_info config = *sbinfo;\n \tunsigned long inodes;\n \tint error = -EINVAL;\n \n \tif (shmem_parse_options(data, &config, true))\n \t\treturn error;\n \n\tspin_lock(&sbinfo->stat_lock);\n\tinodes = sbinfo->max_inodes - sbinfo->free_inodes;\n\tif (percpu_counter_compare(&sbinfo->used_blocks, config.max_blocks) > 0)\n\t\tgoto out;\n\tif (config.max_inodes < inodes)\n\t\tgoto out;\n\t/*\n\t * Those tests disallow limited->unlimited while any are in use;\n\t * but we must separately disallow unlimited->limited, because\n\t * in that case we have no record of how much is already in use.\n\t */\n\tif (config.max_blocks && !sbinfo->max_blocks)\n\t\tgoto out;\n\tif (config.max_inodes && !sbinfo->max_inodes)\n\t\tgoto out;\n\n\terror = 0;\n\tsbinfo->max_blocks  = config.max_blocks;\n \tsbinfo->max_inodes  = config.max_inodes;\n \tsbinfo->free_inodes = config.max_inodes - inodes;\n \n\tmpol_put(sbinfo->mpol);\n\tsbinfo->mpol        = config.mpol;\t/* transfers initial ref */\n out:\n \tspin_unlock(&sbinfo->stat_lock);\n \treturn error;\n}\n", "target": 1, "idx": 179299}
{"func": "int DecodeTeredo(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p, uint8_t *pkt, uint16_t len, PacketQueue *pq)\n{\n    if (!g_teredo_enabled)\n        return TM_ECODE_FAILED;\n\n    uint8_t *start = pkt;\n\n    /* Is this packet to short to contain an IPv6 packet ? */\n    if (len < IPV6_HEADER_LEN)\n        return TM_ECODE_FAILED;\n\n    /* Teredo encapsulate IPv6 in UDP and can add some custom message\n     * part before the IPv6 packet. In our case, we just want to get\n     * over an ORIGIN indication. So we just make one offset if needed. */\n    if (start[0] == 0x0) {\n        switch (start[1]) {\n            /* origin indication: compatible with tunnel */\n            case 0x0:\n                /* offset is coherent with len and presence of an IPv6 header */\n                if (len >= TEREDO_ORIG_INDICATION_LENGTH + IPV6_HEADER_LEN)\n                    start += TEREDO_ORIG_INDICATION_LENGTH;\n                else\n                    return TM_ECODE_FAILED;\n                break;\n            /* authentication: negotiation not real tunnel */\n            case 0x1:\n                return TM_ECODE_FAILED;\n            /* this case is not possible in Teredo: not that protocol */\n            default:\n                return TM_ECODE_FAILED;\n        }\n    }\n\n     /* There is no specific field that we can check to prove that the packet\n      * is a Teredo packet. We've zapped here all the possible Teredo header\n      * and we should have an IPv6 packet at the start pointer.\n     * We then can only do two checks before sending the encapsulated packets\n      * to decoding:\n      *  - The packet has a protocol version which is IPv6.\n      *  - The IPv6 length of the packet matches what remains in buffer.\n      */\n     if (IP_GET_RAW_VER(start) == 6) {\n         IPV6Hdr *thdr = (IPV6Hdr *)start;\n         if (len ==  IPV6_HEADER_LEN +\n                 IPV6_GET_RAW_PLEN(thdr) + (start - pkt)) {\n             if (pq != NULL) {\n                 int blen = len - (start - pkt);\n                 /* spawn off tunnel packet */\n                 Packet *tp = PacketTunnelPktSetup(tv, dtv, p, start, blen,\n                                                  DECODE_TUNNEL_IPV6, pq);\n                 if (tp != NULL) {\n                     PKT_SET_SRC(tp, PKT_SRC_DECODER_TEREDO);\n                     /* add the tp to the packet queue. */\n                    PacketEnqueue(pq,tp);\n                    StatsIncr(tv, dtv->counter_teredo);\n                    return TM_ECODE_OK;\n                }\n            }\n        }\n        return TM_ECODE_FAILED;\n    }\n\n    return TM_ECODE_FAILED;\n}\n", "target": 1, "idx": 182649}
{"func": "cJSON *cJSON_CreateString( const char *string )\n{\n\tcJSON *item = cJSON_New_Item();\n\tif ( item ) {\n\t\titem->type = cJSON_String;\n\t\titem->valuestring = cJSON_strdup( string );\n\t}\n\treturn item;\n}\n", "target": 1, "idx": 180450}
{"func": "ssize_t pcnet_receive(NetClientState *nc, const uint8_t *buf, size_t size_)\n{\n    PCNetState *s = qemu_get_nic_opaque(nc);\n    int is_padr = 0, is_bcast = 0, is_ladr = 0;\n    uint8_t buf1[60];\n    int remaining;\n    int crc_err = 0;\n    int size = size_;\n\n    if (CSR_DRX(s) || CSR_STOP(s) || CSR_SPND(s) || !size ||\n        (CSR_LOOP(s) && !s->looptest)) {\n        return -1;\n    }\n#ifdef PCNET_DEBUG\n    printf(\"pcnet_receive size=%d\\n\", size);\n#endif\n\n    /* if too small buffer, then expand it */\n    if (size < MIN_BUF_SIZE) {\n        memcpy(buf1, buf, size);\n        memset(buf1 + size, 0, MIN_BUF_SIZE - size);\n        buf = buf1;\n        size = MIN_BUF_SIZE;\n    }\n\n    if (CSR_PROM(s)\n        || (is_padr=padr_match(s, buf, size))\n        || (is_bcast=padr_bcast(s, buf, size))\n        || (is_ladr=ladr_match(s, buf, size))) {\n\n        pcnet_rdte_poll(s);\n\n        if (!(CSR_CRST(s) & 0x8000) && s->rdra) {\n            struct pcnet_RMD rmd;\n            int rcvrc = CSR_RCVRC(s)-1,i;\n            hwaddr nrda;\n            for (i = CSR_RCVRL(s)-1; i > 0; i--, rcvrc--) {\n                if (rcvrc <= 1)\n                    rcvrc = CSR_RCVRL(s);\n                nrda = s->rdra +\n                    (CSR_RCVRL(s) - rcvrc) *\n                    (BCR_SWSTYLE(s) ? 16 : 8 );\n                RMDLOAD(&rmd, nrda);\n                if (GET_FIELD(rmd.status, RMDS, OWN)) {\n#ifdef PCNET_DEBUG_RMD\n                    printf(\"pcnet - scan buffer: RCVRC=%d PREV_RCVRC=%d\\n\",\n                                rcvrc, CSR_RCVRC(s));\n#endif\n                    CSR_RCVRC(s) = rcvrc;\n                    pcnet_rdte_poll(s);\n                    break;\n                }\n            }\n        }\n\n        if (!(CSR_CRST(s) & 0x8000)) {\n#ifdef PCNET_DEBUG_RMD\n            printf(\"pcnet - no buffer: RCVRC=%d\\n\", CSR_RCVRC(s));\n#endif\n            s->csr[0] |= 0x1000; /* Set MISS flag */\n            CSR_MISSC(s)++;\n        } else {\n            uint8_t *src = s->buffer;\n            hwaddr crda = CSR_CRDA(s);\n            struct pcnet_RMD rmd;\n             int pktcount = 0;\n \n             if (!s->looptest) {\n                 memcpy(src, buf, size);\n                 /* no need to compute the CRC */\n                 src[size] = 0;\n                uint32_t fcs = ~0;\n                uint8_t *p = src;\n\n                while (p != &src[size])\n                    CRC(fcs, *p++);\n                *(uint32_t *)p = htonl(fcs);\n                size += 4;\n            } else {\n                uint32_t fcs = ~0;\n                uint8_t *p = src;\n\n                while (p != &src[size])\n                    CRC(fcs, *p++);\n                crc_err = (*(uint32_t *)p != htonl(fcs));\n            }\n\n#ifdef PCNET_DEBUG_MATCH\n            PRINT_PKTHDR(buf);\n#endif\n\n            RMDLOAD(&rmd, PHYSADDR(s,crda));\n            /*if (!CSR_LAPPEN(s))*/\n                SET_FIELD(&rmd.status, RMDS, STP, 1);\n\n#define PCNET_RECV_STORE() do {                                 \\\n    int count = MIN(4096 - GET_FIELD(rmd.buf_length, RMDL, BCNT),remaining); \\\n    hwaddr rbadr = PHYSADDR(s, rmd.rbadr);          \\\n    s->phys_mem_write(s->dma_opaque, rbadr, src, count, CSR_BSWP(s)); \\\n    src += count; remaining -= count;                           \\\n    SET_FIELD(&rmd.status, RMDS, OWN, 0);                       \\\n    RMDSTORE(&rmd, PHYSADDR(s,crda));                           \\\n    pktcount++;                                                 \\\n} while (0)\n\n            remaining = size;\n            PCNET_RECV_STORE();\n            if ((remaining > 0) && CSR_NRDA(s)) {\n                hwaddr nrda = CSR_NRDA(s);\n#ifdef PCNET_DEBUG_RMD\n                PRINT_RMD(&rmd);\n#endif\n                RMDLOAD(&rmd, PHYSADDR(s,nrda));\n                if (GET_FIELD(rmd.status, RMDS, OWN)) {\n                    crda = nrda;\n                    PCNET_RECV_STORE();\n#ifdef PCNET_DEBUG_RMD\n                    PRINT_RMD(&rmd);\n#endif\n                    if ((remaining > 0) && (nrda=CSR_NNRD(s))) {\n                        RMDLOAD(&rmd, PHYSADDR(s,nrda));\n                        if (GET_FIELD(rmd.status, RMDS, OWN)) {\n                            crda = nrda;\n                            PCNET_RECV_STORE();\n                        }\n                    }\n                }\n            }\n\n#undef PCNET_RECV_STORE\n\n            RMDLOAD(&rmd, PHYSADDR(s,crda));\n            if (remaining == 0) {\n                SET_FIELD(&rmd.msg_length, RMDM, MCNT, size);\n                SET_FIELD(&rmd.status, RMDS, ENP, 1);\n                SET_FIELD(&rmd.status, RMDS, PAM, !CSR_PROM(s) && is_padr);\n                SET_FIELD(&rmd.status, RMDS, LFAM, !CSR_PROM(s) && is_ladr);\n                SET_FIELD(&rmd.status, RMDS, BAM, !CSR_PROM(s) && is_bcast);\n                if (crc_err) {\n                    SET_FIELD(&rmd.status, RMDS, CRC, 1);\n                    SET_FIELD(&rmd.status, RMDS, ERR, 1);\n                }\n            } else {\n                SET_FIELD(&rmd.status, RMDS, OFLO, 1);\n                SET_FIELD(&rmd.status, RMDS, BUFF, 1);\n                SET_FIELD(&rmd.status, RMDS, ERR, 1);\n            }\n            RMDSTORE(&rmd, PHYSADDR(s,crda));\n            s->csr[0] |= 0x0400;\n\n#ifdef PCNET_DEBUG\n            printf(\"RCVRC=%d CRDA=0x%08x BLKS=%d\\n\",\n                CSR_RCVRC(s), PHYSADDR(s,CSR_CRDA(s)), pktcount);\n#endif\n#ifdef PCNET_DEBUG_RMD\n            PRINT_RMD(&rmd);\n#endif\n\n            while (pktcount--) {\n                if (CSR_RCVRC(s) <= 1)\n                    CSR_RCVRC(s) = CSR_RCVRL(s);\n                else\n                    CSR_RCVRC(s)--;\n            }\n\n            pcnet_rdte_poll(s);\n\n        }\n    }\n\n    pcnet_poll(s);\n    pcnet_update_irq(s);\n\n    return size_;\n}\n", "target": 1, "idx": 178458}
{"func": "void skip_input_data(j_decompress_ptr jd, long num_bytes)\n{\n    decoder_source_mgr *src = (decoder_source_mgr *)jd->src;\n    src->decoder->skipBytes(num_bytes);\n}\n", "target": 0, "idx": 127507}
{"func": "bool Browser::IsPopup(const TabContents* source) const {\n  return !!(type() & TYPE_POPUP);\n}\n", "target": 0, "idx": 103126}
{"func": "void FillMiscNavigationParams(const CommonNavigationParams& common_params,\n                              const CommitNavigationParams& commit_params,\n                              blink::WebNavigationParams* navigation_params) {\n  navigation_params->navigation_timings = BuildNavigationTimings(\n      common_params.navigation_start, commit_params.navigation_timing,\n      common_params.input_start);\n\n  navigation_params->is_user_activated =\n      commit_params.was_activated == WasActivatedOption::kYes;\n\n  if (commit_params.origin_to_commit) {\n    navigation_params->origin_to_commit =\n        commit_params.origin_to_commit.value();\n  }\n}\n", "target": 0, "idx": 152308}
{"func": "AirPDcapDecryptWPABroadcastKey(const EAPOL_RSN_KEY *pEAPKey, guint8 *decryption_key, PAIRPDCAP_SEC_ASSOCIATION sa, guint eapol_len)\n{\n    guint8 key_version;\n    guint8 *key_data;\n    guint8  *szEncryptedKey;\n    guint16 key_bytes_len = 0; /* Length of the total key data field */\n    guint16 key_len;           /* Actual group key length */\n    static AIRPDCAP_KEY_ITEM dummy_key; /* needed in case AirPDcapRsnaMng() wants the key structure */\n    AIRPDCAP_SEC_ASSOCIATION *tmp_sa;\n\n    /* We skip verifying the MIC of the key. If we were implementing a WPA supplicant we'd want to verify, but for a sniffer it's not needed. */\n\n    /* Preparation for decrypting the group key -  determine group key data length */\n    /* depending on whether the pairwise key is TKIP or AES encryption key */\n    key_version = AIRPDCAP_EAP_KEY_DESCR_VER(pEAPKey->key_information[1]);\n    if (key_version == AIRPDCAP_WPA_KEY_VER_NOT_CCMP){\n        /* TKIP */\n        key_bytes_len = pntoh16(pEAPKey->key_length);\n    }else if (key_version == AIRPDCAP_WPA_KEY_VER_AES_CCMP){\n        /* AES */\n        key_bytes_len = pntoh16(pEAPKey->key_data_len);\n\n        /* AES keys must be at least 128 bits = 16 bytes. */\n        if (key_bytes_len < 16) {\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n         }\n     }\n \n    if (key_bytes_len < GROUP_KEY_MIN_LEN || key_bytes_len > eapol_len - sizeof(EAPOL_RSN_KEY)) {\n         return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n     }\n \n    /* Encrypted key is in the information element field of the EAPOL key packet */\n    key_data = (guint8 *)pEAPKey + sizeof(EAPOL_RSN_KEY);\n    szEncryptedKey = (guint8 *)g_memdup(key_data, key_bytes_len);\n\n    DEBUG_DUMP(\"Encrypted Broadcast key:\", szEncryptedKey, key_bytes_len);\n    DEBUG_DUMP(\"KeyIV:\", pEAPKey->key_iv, 16);\n    DEBUG_DUMP(\"decryption_key:\", decryption_key, 16);\n\n    /* We are rekeying, save old sa */\n    tmp_sa=(AIRPDCAP_SEC_ASSOCIATION *)g_malloc(sizeof(AIRPDCAP_SEC_ASSOCIATION));\n    memcpy(tmp_sa, sa, sizeof(AIRPDCAP_SEC_ASSOCIATION));\n    sa->next=tmp_sa;\n\n    /* As we have no concept of the prior association request at this point, we need to deduce the     */\n    /* group key cipher from the length of the key bytes. In WPA this is straightforward as the        */\n    /* keybytes just contain the GTK, and the GTK is only in the group handshake, NOT the M3.          */\n    /* In WPA2 its a little more tricky as the M3 keybytes contain an RSN_IE, but the group handshake  */\n    /* does not. Also there are other (variable length) items in the keybytes which we need to account */\n    /* for to determine the true key length, and thus the group cipher.                                */\n\n    if (key_version == AIRPDCAP_WPA_KEY_VER_NOT_CCMP){\n        guint8 new_key[32];\n        guint8 dummy[256];\n        /* TKIP key */\n        /* Per 802.11i, Draft 3.0 spec, section 8.5.2, p. 97, line 4-8, */\n        /* group key is decrypted using RC4.  Concatenate the IV with the 16 byte EK (PTK+16) to get the decryption key */\n\n        rc4_state_struct rc4_state;\n\n        /* The WPA group key just contains the GTK bytes so deducing the type is straightforward   */\n        /* Note - WPA M3 doesn't contain a group key so we'll only be here for the group handshake */\n        sa->wpa.key_ver = (key_bytes_len >=TKIP_GROUP_KEY_LEN)?AIRPDCAP_WPA_KEY_VER_NOT_CCMP:AIRPDCAP_WPA_KEY_VER_AES_CCMP;\n\n        /* Build the full decryption key based on the IV and part of the pairwise key */\n        memcpy(new_key, pEAPKey->key_iv, 16);\n        memcpy(new_key+16, decryption_key, 16);\n        DEBUG_DUMP(\"FullDecrKey:\", new_key, 32);\n\n        crypt_rc4_init(&rc4_state, new_key, sizeof(new_key));\n\n        /* Do dummy 256 iterations of the RC4 algorithm (per 802.11i, Draft 3.0, p. 97 line 6) */\n        crypt_rc4(&rc4_state, dummy, 256);\n        crypt_rc4(&rc4_state, szEncryptedKey, key_bytes_len);\n\n    } else if (key_version == AIRPDCAP_WPA_KEY_VER_AES_CCMP){\n        /* AES CCMP key */\n\n        guint8 key_found;\n        guint8 key_length;\n        guint16 key_index;\n        guint8 *decrypted_data;\n\n        /* Unwrap the key; the result is key_bytes_len in length */\n        decrypted_data = AES_unwrap(decryption_key, 16, szEncryptedKey,  key_bytes_len);\n\n        /* With WPA2 what we get after Broadcast Key decryption is an actual RSN structure.\n           The key itself is stored as a GTK KDE\n           WPA2 IE (1 byte) id = 0xdd, length (1 byte), GTK OUI (4 bytes), key index (1 byte) and 1 reserved byte. Thus we have to\n           pass pointer to the actual key with 8 bytes offset */\n\n        key_found = FALSE;\n        key_index = 0;\n\n        /* Parse Key data until we found GTK KDE */\n        /* GTK KDE = 00-0F-AC 01 */\n        while(key_index < (key_bytes_len - 6) && !key_found){\n            guint8 rsn_id;\n            guint32 type;\n\n            /* Get RSN ID */\n            rsn_id = decrypted_data[key_index];\n            type = ((decrypted_data[key_index + 2] << 24) +\n                    (decrypted_data[key_index + 3] << 16) +\n                    (decrypted_data[key_index + 4] << 8) +\n                     (decrypted_data[key_index + 5]));\n\n            if (rsn_id == 0xdd && type == 0x000fac01) {\n                key_found = TRUE;\n            } else {\n                key_index += decrypted_data[key_index+1]+2;\n            }\n        }\n\n        if (key_found){\n            key_length = decrypted_data[key_index+1] - 6;\n\n            if (key_index+8 >= key_bytes_len ||\n                key_length > key_bytes_len - key_index - 8) {\n                g_free(decrypted_data);\n                g_free(szEncryptedKey);\n                return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n            }\n\n            /* Skip over the GTK header info, and don't copy past the end of the encrypted data */\n            memcpy(szEncryptedKey, decrypted_data+key_index+8, key_length);\n        } else {\n            g_free(decrypted_data);\n            g_free(szEncryptedKey);\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n\n        if (key_length == TKIP_GROUP_KEY_LEN)\n            sa->wpa.key_ver = AIRPDCAP_WPA_KEY_VER_NOT_CCMP;\n        else\n            sa->wpa.key_ver = AIRPDCAP_WPA_KEY_VER_AES_CCMP;\n\n        g_free(decrypted_data);\n    }\n\n    key_len = (sa->wpa.key_ver==AIRPDCAP_WPA_KEY_VER_NOT_CCMP)?TKIP_GROUP_KEY_LEN:CCMP_GROUP_KEY_LEN;\n    if (key_len > key_bytes_len) {\n        /* the key required for this protocol is longer than the key that we just calculated */\n        g_free(szEncryptedKey);\n        return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n    }\n\n    /* Decrypted key is now in szEncryptedKey with len of key_len */\n    DEBUG_DUMP(\"Broadcast key:\", szEncryptedKey, key_len);\n\n    /* Load the proper key material info into the SA */\n    sa->key = &dummy_key;  /* we just need key to be not null because it is checked in AirPDcapRsnaMng().  The WPA key materials are actually in the .wpa structure */\n    sa->validKey = TRUE;\n\n    /* Since this is a GTK and its size is only 32 bytes (vs. the 64 byte size of a PTK), we fake it and put it in at a 32-byte offset so the  */\n    /* AirPDcapRsnaMng() function will extract the right piece of the GTK for decryption. (The first 16 bytes of the GTK are used for decryption.) */\n    memset(sa->wpa.ptk, 0, sizeof(sa->wpa.ptk));\n    memcpy(sa->wpa.ptk+32, szEncryptedKey, key_len);\n    g_free(szEncryptedKey);\n    return AIRPDCAP_RET_SUCCESS_HANDSHAKE;\n}\n", "target": 1, "idx": 180329}
{"func": "  DEFINE_INLINE_TRACE() { visitor->trace(arrayBuffer); }\n", "target": 0, "idx": 140890}
{"func": "static int firm_report_tx_done(struct usb_serial_port *port)\n{\n\tstruct whiteheat_simple close_command;\n\n\tclose_command.port = port->port_number + 1;\n\treturn firm_send_command(port, WHITEHEAT_REPORT_TX_DONE,\n\t\t\t(__u8 *)&close_command, sizeof(close_command));\n}\n", "target": 0, "idx": 38087}
{"func": "bool CanRendererHandleEvent(const ui::MouseEvent* event) {\n  if (event->type() == ui::ET_MOUSE_CAPTURE_CHANGED)\n    return false;\n\n#if defined(OS_WIN)\n  switch (event->native_event().message) {\n    case WM_XBUTTONDOWN:\n    case WM_XBUTTONUP:\n     case WM_XBUTTONDBLCLK:\n     case WM_NCMOUSELEAVE:\n     case WM_NCMOUSEMOVE:\n     case WM_NCXBUTTONDOWN:\n     case WM_NCXBUTTONUP:\n     case WM_NCXBUTTONDBLCLK:\n      return false;\n    default:\n      break;\n  }\n#endif\n  return true;\n}\n", "target": 1, "idx": 185491}
{"func": " write_png(const char **name, FILE *fp, int color_type, int bit_depth,\n    volatile png_fixed_point gamma, chunk_insert * volatile insert,\n   unsigned int filters, unsigned int *colors)\n {\n    png_structp png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING,\n       name, makepng_error, makepng_warning);\n volatile png_infop info_ptr = NULL;\n volatile png_bytep row = NULL;\n\n if (png_ptr == NULL)\n {\n      fprintf(stderr, \"makepng: OOM allocating write structure\\n\");\n return 1;\n }\n\n if (setjmp(png_jmpbuf(png_ptr)))\n {\n      png_structp nv_ptr = png_ptr;\n      png_infop nv_info = info_ptr;\n\n      png_ptr = NULL;\n      info_ptr = NULL;\n      png_destroy_write_struct(&nv_ptr, &nv_info);\n if (row != NULL) free(row);\n return 1;\n }\n\n \n    /* Allow benign errors so that we can write PNGs with errors */\n    png_set_benign_errors(png_ptr, 1/*allowed*/);\n    png_init_io(png_ptr, fp);\n \n    info_ptr = png_create_info_struct(png_ptr);\n if (info_ptr == NULL)\n\n       png_error(png_ptr, \"OOM allocating info structure\");\n \n    {\n      unsigned int size = image_size_of_type(color_type, bit_depth, colors);\n       png_fixed_point real_gamma = 45455; /* For sRGB */\n       png_byte gamma_table[256];\n       double conv;\n \n       /* This function uses the libpng values used on read to carry extra\n        * information about the gamma:\n        */\n if (gamma == PNG_GAMMA_MAC_18)\n         gamma = 65909;\n\n else if (gamma > 0 && gamma < 1000)\n         gamma = PNG_FP_1;\n\n if (gamma > 0)\n         real_gamma = gamma;\n\n {\n unsigned int i;\n\n if (real_gamma == 45455) for (i=0; i<256; ++i)\n {\n            gamma_table[i] = (png_byte)i;\n            conv = 1.;\n }\n\n else\n {\n /* Convert 'i' from sRGB (45455) to real_gamma, this makes\n             * the images look the same regardless of the gAMA chunk.\n             */\n            conv = real_gamma;\n            conv /= 45455;\n\n\n             gamma_table[0] = 0;\n \n             for (i=1; i<255; ++i)\n               gamma_table[i] = (png_byte)floor(pow(i/255.,conv) * 255 + .5);\n \n             gamma_table[255] = 255;\n          }\n       }\n \n      png_set_IHDR(png_ptr, info_ptr, size, size, bit_depth, color_type,\n          PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);\n \n       if (color_type & PNG_COLOR_MASK_PALETTE)\n {\n int npalette;\n         png_color palette[256];\n         png_byte trans[256];\n\n\n          npalette = generate_palette(palette, trans, bit_depth, gamma_table,\n             colors);\n          png_set_PLTE(png_ptr, info_ptr, palette, npalette);\n         png_set_tRNS(png_ptr, info_ptr, trans, npalette-1,\n            NULL/*transparent color*/);\n \n          /* Reset gamma_table to prevent the image rows being changed */\n          for (npalette=0; npalette<256; ++npalette)\n             gamma_table[npalette] = (png_byte)npalette;\n       }\n \n       if (gamma == PNG_DEFAULT_sRGB)\n          png_set_sRGB(png_ptr, info_ptr, PNG_sRGB_INTENT_ABSOLUTE);\n \n else if (gamma > 0) /* Else don't set color space information */\n {\n         png_set_gAMA_fixed(png_ptr, info_ptr, real_gamma);\n\n /* Just use the sRGB values here. */\n         png_set_cHRM_fixed(png_ptr, info_ptr,\n /* color      x       y */\n /* white */ 31270, 32900,\n /* red   */ 64000, 33000,\n /* green */ 30000, 60000,\n /* blue  */ 15000, 6000\n );\n }\n\n /* Insert extra information. */\n while (insert != NULL)\n {\n         insert->insert(png_ptr, info_ptr, insert->nparams, insert->parameters);\n         insert = insert->next;\n }\n\n /* Write the file header. */\n      png_write_info(png_ptr, info_ptr);\n\n /* Restrict the filters */\n\n       png_set_filter(png_ptr, PNG_FILTER_TYPE_BASE, filters);\n \n       {\n         int passes = png_set_interlace_handling(png_ptr);\n          int pass;\n          png_size_t rowbytes = png_get_rowbytes(png_ptr, info_ptr);\n \n         row = malloc(rowbytes);\n\n if (row == NULL)\n            png_error(png_ptr, \"OOM allocating row buffer\");\n\n for (pass = 0; pass < passes; ++pass)\n\n          {\n             unsigned int y;\n \n            for (y=0; y<size; ++y)\n             {\n               generate_row(row, rowbytes, y, color_type, bit_depth,\n                  gamma_table, conv, colors);\n                png_write_row(png_ptr, row);\n             }\n          }\n }\n }\n\n /* Finish writing the file. */\n   png_write_end(png_ptr, info_ptr);\n\n {\n      png_structp nv_ptr = png_ptr;\n      png_infop nv_info = info_ptr;\n\n      png_ptr = NULL;\n      info_ptr = NULL;\n      png_destroy_write_struct(&nv_ptr, &nv_info);\n }\n   free(row);\n return 0;\n}\n", "target": 1, "idx": 187608}
{"func": "generate_many_bodies (DBusMessageDataIter   *iter,\n                      DBusString            *data,\n                      DBusValidity          *expected_validity)\n{\n  return generate_outer (iter, data, expected_validity,\n                         generate_many_bodies_inner);\n}\n", "target": 0, "idx": 7491}
{"func": " void InputMethodBase::OnInputMethodChanged() const {\n   TextInputClient* client = GetTextInputClient();\n  if (client && client->GetTextInputType() != TEXT_INPUT_TYPE_NONE)\n     client->OnInputMethodChanged();\n }\n", "target": 1, "idx": 184754}
{"func": " WebPluginResourceClient* WebPluginDelegateImpl::CreateResourceClient(\n    unsigned long resource_id, const GURL& url, bool notify_needed,\n    intptr_t notify_data, intptr_t existing_stream) {\n  if (existing_stream) {\n    NPAPI::PluginStream* plugin_stream =\n        reinterpret_cast<NPAPI::PluginStream*>(existing_stream);\n    return plugin_stream->AsResourceClient();\n  }\n \n  std::string mime_type;\n  NPAPI::PluginStreamUrl *stream = instance()->CreateStream(\n      resource_id, url, mime_type, notify_needed,\n      reinterpret_cast<void*>(notify_data));\n  return stream;\n }\n", "target": 1, "idx": 183593}
{"func": "ExtensionsGuestViewMessageFilter::FrameNavigationHelper::FrameNavigationHelper(\n    RenderFrameHost* plugin_rfh,\n    int32_t guest_instance_id,\n    int32_t element_instance_id,\n    bool is_full_page_plugin,\n    ExtensionsGuestViewMessageFilter* filter)\n    : content::WebContentsObserver(\n          content::WebContents::FromRenderFrameHost(plugin_rfh)),\n      frame_tree_node_id_(plugin_rfh->GetFrameTreeNodeId()),\n      guest_instance_id_(guest_instance_id),\n      element_instance_id_(element_instance_id),\n      is_full_page_plugin_(is_full_page_plugin),\n      filter_(filter),\n      parent_site_instance_(plugin_rfh->GetParent()->GetSiteInstance()),\n      weak_factory_(this) {\n  DCHECK(GetGuestView());\n  NavigateToAboutBlank();\n  base::PostDelayedTaskWithTraits(\n      FROM_HERE, {BrowserThread::UI},\n      base::BindOnce(&ExtensionsGuestViewMessageFilter::FrameNavigationHelper::\n                         CancelPendingTask,\n                     weak_factory_.GetWeakPtr()),\n      base::TimeDelta::FromMilliseconds(kAttachFailureDelayMS));\n}\n", "target": 1, "idx": 187021}
{"func": "void IndexedDBDatabase::Clear(IndexedDBTransaction* transaction,\n                              int64_t object_store_id,\n                              scoped_refptr<IndexedDBCallbacks> callbacks) {\n  DCHECK(transaction);\n  IDB_TRACE1(\"IndexedDBDatabase::Clear\", \"txn.id\", transaction->id());\n  DCHECK_NE(transaction->mode(), blink::mojom::IDBTransactionMode::ReadOnly);\n\n  if (!ValidateObjectStoreId(object_store_id))\n    return;\n\n  transaction->ScheduleTask(base::BindOnce(&IndexedDBDatabase::ClearOperation,\n                                           this, object_store_id, callbacks));\n}\n", "target": 0, "idx": 164602}
{"func": "void WebDevToolsAgentImpl::didNavigate()\n{\n    ClientMessageLoopAdapter::didNavigate();\n}\n", "target": 0, "idx": 122550}
{"func": " RenderFrameObserverNatives::RenderFrameObserverNatives(ScriptContext* context)\n    : ObjectBackedNativeHandler(context) {\n   RouteFunction(\n       \"OnDocumentElementCreated\",\n       base::Bind(&RenderFrameObserverNatives::OnDocumentElementCreated,\n                  base::Unretained(this)));\n }\n", "target": 1, "idx": 186115}
{"func": " cdf_file_summary_info(struct magic_set *ms, const cdf_header_t *h,\n    const cdf_stream_t *sst, const uint64_t clsid[2])\n {\n         cdf_summary_info_header_t si;\n         cdf_property_info_t *info;\n        size_t count;\n        int m;\n\n        if (cdf_unpack_summary_info(sst, h, &si, &info, &count) == -1)\n                return -1;\n\n        if (NOTMIME(ms)) {\n\t\tconst char *str;\n\n                if (file_printf(ms, \"Composite Document File V2 Document\")\n\t\t    == -1)\n                        return -1;\n\n                if (file_printf(ms, \", %s Endian\",\n                    si.si_byte_order == 0xfffe ?  \"Little\" : \"Big\") == -1)\n                        return -2;\n                switch (si.si_os) {\n                case 2:\n                        if (file_printf(ms, \", Os: Windows, Version %d.%d\",\n                            si.si_os_version & 0xff,\n                            (uint32_t)si.si_os_version >> 8) == -1)\n                                return -2;\n                        break;\n                case 1:\n                        if (file_printf(ms, \", Os: MacOS, Version %d.%d\",\n                            (uint32_t)si.si_os_version >> 8,\n                            si.si_os_version & 0xff) == -1)\n                                return -2;\n                        break;\n                default:\n                        if (file_printf(ms, \", Os %d, Version: %d.%d\", si.si_os,\n                            si.si_os_version & 0xff,\n                            (uint32_t)si.si_os_version >> 8) == -1)\n                                 return -2;\n                         break;\n                 }\n\t\tstr = cdf_clsid_to_mime(clsid, clsid2desc);\n\t\tif (str)\n                        if (file_printf(ms, \", %s\", str) == -1)\n\t\t\t\treturn -2;\n        }\n \n        m = cdf_file_property_info(ms, info, count, clsid);\n         free(info);\n \n         return m == -1 ? -2 : m;\n}\n", "target": 1, "idx": 179618}
{"func": "static int decode_attr_group(struct xdr_stream *xdr, uint32_t *bitmap, struct nfs_client *clp, uint32_t *gid)\n{\n\tuint32_t len;\n\t__be32 *p;\n\n\t*gid = -2;\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_OWNER_GROUP - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[1] & FATTR4_WORD1_OWNER_GROUP)) {\n\t\tREAD_BUF(4);\n\t\tREAD32(len);\n\t\tREAD_BUF(len);\n\t\tif (len < XDR_MAX_NETOBJ) {\n\t\t\tif (nfs_map_group_to_gid(clp, (char *)p, len, gid) != 0)\n\t\t\t\tdprintk(\"%s: nfs_map_group_to_gid failed!\\n\",\n\t\t\t\t\t\t__func__);\n\t\t} else\n\t\t\tdprintk(\"%s: name too long (%u)!\\n\",\n\t\t\t\t\t__func__, len);\n\t\tbitmap[1] &= ~FATTR4_WORD1_OWNER_GROUP;\n\t}\n\tdprintk(\"%s: gid=%d\\n\", __func__, (int)*gid);\n\treturn 0;\n}\n", "target": 0, "idx": 22986}
{"func": "static inline void vmxnet3_ring_init(PCIDevice *d,\n\t\t\t\t     Vmxnet3Ring *ring,\n                                     hwaddr pa,\n                                     size_t size,\n                                     size_t cell_size,\n                                     bool zero_region)\n{\n    ring->pa = pa;\n    ring->size = size;\n    ring->cell_size = cell_size;\n    ring->gen = VMXNET3_INIT_GEN;\n    ring->next = 0;\n\n    if (zero_region) {\n        vmw_shmem_set(d, pa, 0, size * cell_size);\n    }\n}\n", "target": 0, "idx": 9054}
{"func": "OMXNodeInstance::OMXNodeInstance(\n        OMX *owner, const sp<IOMXObserver> &observer, const char *name)\n : mOwner(owner),\n      mNodeID(0),\n\n       mHandle(NULL),\n       mObserver(observer),\n       mDying(false),\n       mBufferIDCount(0)\n {\n     mName = ADebug::GetDebugName(name);\n    DEBUG = ADebug::GetDebugLevelFromProperty(name, \"debug.stagefright.omx-debug\");\n    ALOGV(\"debug level for %s is %d\", name, DEBUG);\n    DEBUG_BUMP = DEBUG;\n    mNumPortBuffers[0] = 0;\n    mNumPortBuffers[1] = 0;\n    mDebugLevelBumpPendingBuffers[0] = 0;\n    mDebugLevelBumpPendingBuffers[1] = 0;\n    mMetadataType[0] = kMetadataBufferTypeInvalid;\n    mMetadataType[1] = kMetadataBufferTypeInvalid;\n    mSecureBufferType[0] = kSecureBufferTypeUnknown;\n    mSecureBufferType[1] = kSecureBufferTypeUnknown;\n    mIsSecure = AString(name).endsWith(\".secure\");\n}\n", "target": 1, "idx": 188151}
{"func": " void WallpaperManager::DoSetDefaultWallpaper(\n     const AccountId& account_id,\n     MovableOnDestroyCallbackHolder on_finish) {\n   if (user_manager::UserManager::Get()->IsLoggedInAsKioskApp())\n    return;\n  wallpaper_cache_.erase(account_id);\n\n  WallpaperResolution resolution = GetAppropriateResolution();\n  const bool use_small = (resolution == WALLPAPER_RESOLUTION_SMALL);\n\n  const base::FilePath* file = NULL;\n\n  const user_manager::User* user =\n      user_manager::UserManager::Get()->FindUser(account_id);\n\n  if (user_manager::UserManager::Get()->IsLoggedInAsGuest()) {\n    file =\n        use_small ? &guest_small_wallpaper_file_ : &guest_large_wallpaper_file_;\n  } else if (user && user->GetType() == user_manager::USER_TYPE_CHILD) {\n    file =\n        use_small ? &child_small_wallpaper_file_ : &child_large_wallpaper_file_;\n  } else {\n    file = use_small ? &default_small_wallpaper_file_\n                     : &default_large_wallpaper_file_;\n  }\n  wallpaper::WallpaperLayout layout =\n      use_small ? wallpaper::WALLPAPER_LAYOUT_CENTER\n                : wallpaper::WALLPAPER_LAYOUT_CENTER_CROPPED;\n  DCHECK(file);\n  if (!default_wallpaper_image_.get() ||\n      default_wallpaper_image_->file_path() != *file) {\n     default_wallpaper_image_.reset();\n     if (!file->empty()) {\n       loaded_wallpapers_for_test_++;\n      StartLoadAndSetDefaultWallpaper(*file, layout, std::move(on_finish),\n                                       &default_wallpaper_image_);\n       return;\n     }\n \n     CreateSolidDefaultWallpaper();\n   }\n  if (default_wallpaper_image_->image().width() == 1 &&\n      default_wallpaper_image_->image().height() == 1)\n    layout = wallpaper::WALLPAPER_LAYOUT_STRETCH;\n  WallpaperInfo info(default_wallpaper_image_->file_path().value(), layout,\n                     wallpaper::DEFAULT, base::Time::Now().LocalMidnight());\n  SetWallpaper(default_wallpaper_image_->image(), info);\n }\n", "target": 1, "idx": 185844}
{"func": "isdn_net_bind_channel(isdn_net_local * lp, int idx)\n{\n\tlp->flags |= ISDN_NET_CONNECTED;\n\tlp->isdn_device = dev->drvmap[idx];\n\tlp->isdn_channel = dev->chanmap[idx];\n\tdev->rx_netdev[idx] = lp->netdev;\n\tdev->st_netdev[idx] = lp->netdev;\n}\n", "target": 0, "idx": 23621}
{"func": " void jas_matrix_divpow2(jas_matrix_t *matrix, int n)\n {\n\tint i;\n\tint j;\n \tjas_seqent_t *rowstart;\n\tint rowstep;\n \tjas_seqent_t *data;\n \n \tif (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {\n\t\tassert(matrix->rows_);\n\t\trowstep = jas_matrix_rowstep(matrix);\n\t\tfor (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i,\n\t\t  rowstart += rowstep) {\n\t\t\tfor (j = matrix->numcols_, data = rowstart; j > 0; --j,\n\t\t\t  ++data) {\n\t\t\t\t*data = (*data >= 0) ? ((*data) >> n) :\n\t\t\t\t  (-((-(*data)) >> n));\n\t\t\t}\n\t\t}\n\t}\n}\n", "target": 1, "idx": 181876}
{"func": "WebsiteSettingsPopupAndroid::WebsiteSettingsPopupAndroid(\n    JNIEnv* env,\n    jobject java_website_settings_pop,\n    content::WebContents* web_contents) {\n  content::NavigationEntry* nav_entry =\n      web_contents->GetController().GetVisibleEntry();\n  if (nav_entry == NULL)\n    return;\n\n  url_ = nav_entry->GetURL();\n\n  popup_jobject_.Reset(env, java_website_settings_pop);\n\n  presenter_.reset(new WebsiteSettings(\n       this,\n       Profile::FromBrowserContext(web_contents->GetBrowserContext()),\n       TabSpecificContentSettings::FromWebContents(web_contents),\n      InfoBarService::FromWebContents(web_contents),\n       nav_entry->GetURL(),\n       nav_entry->GetSSL(),\n       content::CertStore::GetInstance()));\n}\n", "target": 1, "idx": 185655}
{"func": "void CompileFromResponseCallback(\n    const v8::FunctionCallbackInfo<v8::Value>& args) {\n  ExceptionState exception_state(args.GetIsolate(),\n                                 ExceptionState::kExecutionContext,\n                                  \"WebAssembly\", \"compile\");\n   ExceptionToRejectPromiseScope reject_promise_scope(args, exception_state);\n \n  ScriptState* script_state = ScriptState::ForRelevantRealm(args);\n   if (!ExecutionContext::From(script_state)) {\n     V8SetReturnValue(args, ScriptPromise().V8Value());\n     return;\n  }\n\n  if (args.Length() < 1 || !args[0]->IsObject() ||\n      !V8Response::hasInstance(args[0], args.GetIsolate())) {\n    V8SetReturnValue(\n        args,\n         ScriptPromise::Reject(\n             script_state, V8ThrowException::CreateTypeError(\n                               script_state->GetIsolate(),\n                              \"An argument must be provided, which must be a\"\n                               \"Response or Promise<Response> object\"))\n             .V8Value());\n     return;\n  }\n\n  Response* response = V8Response::ToImpl(v8::Local<v8::Object>::Cast(args[0]));\n  if (response->MimeType() != \"application/wasm\") {\n    V8SetReturnValue(\n        args,\n        ScriptPromise::Reject(\n            script_state,\n            V8ThrowException::CreateTypeError(\n                script_state->GetIsolate(),\n                \"Incorrect response MIME type. Expected 'application/wasm'.\"))\n            .V8Value());\n    return;\n  }\n  v8::Local<v8::Value> promise;\n  if (response->IsBodyLocked() || response->bodyUsed()) {\n    promise = ScriptPromise::Reject(script_state,\n                                    V8ThrowException::CreateTypeError(\n                                        script_state->GetIsolate(),\n                                        \"Cannot compile WebAssembly.Module \"\n                                        \"from an already read Response\"))\n                  .V8Value();\n  } else {\n    if (response->BodyBuffer()) {\n      FetchDataLoaderAsWasmModule* loader =\n          new FetchDataLoaderAsWasmModule(script_state);\n\n      promise = loader->GetPromise();\n      response->BodyBuffer()->StartLoading(loader, new WasmDataLoaderClient());\n    } else {\n      promise = ScriptPromise::Reject(script_state,\n                                      V8ThrowException::CreateTypeError(\n                                          script_state->GetIsolate(),\n                                          \"Response object has a null body.\"))\n                    .V8Value();\n    }\n  }\n  V8SetReturnValue(args, promise);\n}\n", "target": 1, "idx": 186915}
{"func": "static void print_errors(void)\n{\n\tDPRINT(\"\");\n\tif (ST0 & ST0_ECE) {\n\t\tpr_cont(\"Recalibrate failed!\");\n\t} else if (ST2 & ST2_CRC) {\n\t\tpr_cont(\"data CRC error\");\n\t\ttell_sector();\n\t} else if (ST1 & ST1_CRC) {\n\t\tpr_cont(\"CRC error\");\n\t\ttell_sector();\n\t} else if ((ST1 & (ST1_MAM | ST1_ND)) ||\n\t\t   (ST2 & ST2_MAM)) {\n\t\tif (!probing) {\n\t\t\tpr_cont(\"sector not found\");\n\t\t\ttell_sector();\n\t\t} else\n\t\t\tpr_cont(\"probe failed...\");\n\t} else if (ST2 & ST2_WC) {\t/* seek error */\n\t\tpr_cont(\"wrong cylinder\");\n\t} else if (ST2 & ST2_BC) {\t/* cylinder marked as bad */\n\t\tpr_cont(\"bad cylinder\");\n\t} else {\n\t\tpr_cont(\"unknown error. ST[0..2] are: 0x%x 0x%x 0x%x\",\n\t\t\tST0, ST1, ST2);\n\t\ttell_sector();\n\t}\n\tpr_cont(\"\\n\");\n}\n", "target": 0, "idx": 39406}
{"func": "void ContentSecurityPolicy::usesStyleHashAlgorithms(uint8_t algorithms) {\n  m_styleHashAlgorithmsUsed |= algorithms;\n}\n", "target": 0, "idx": 149493}
{"func": " bool PrintPreviewMessageHandler::OnMessageReceived(\n     const IPC::Message& message) {\n   bool handled = true;\n  IPC_BEGIN_MESSAGE_MAP(PrintPreviewMessageHandler, message)\n    IPC_MESSAGE_HANDLER(PrintHostMsg_RequestPrintPreview,\n                        OnRequestPrintPreview)\n    IPC_MESSAGE_HANDLER(PrintHostMsg_DidGetPreviewPageCount,\n                        OnDidGetPreviewPageCount)\n    IPC_MESSAGE_HANDLER(PrintHostMsg_DidPreviewPage,\n                        OnDidPreviewPage)\n    IPC_MESSAGE_HANDLER(PrintHostMsg_MetafileReadyForPrinting,\n                        OnMetafileReadyForPrinting)\n    IPC_MESSAGE_HANDLER(PrintHostMsg_PrintPreviewFailed,\n                        OnPrintPreviewFailed)\n    IPC_MESSAGE_HANDLER(PrintHostMsg_DidGetDefaultPageLayout,\n                        OnDidGetDefaultPageLayout)\n    IPC_MESSAGE_HANDLER(PrintHostMsg_PrintPreviewCancelled,\n                         OnPrintPreviewCancelled)\n     IPC_MESSAGE_HANDLER(PrintHostMsg_PrintPreviewInvalidPrinterSettings,\n                         OnInvalidPrinterSettings)\n     IPC_MESSAGE_UNHANDLED(handled = false)\n   IPC_END_MESSAGE_MAP()\n   return handled;\n}\n", "target": 1, "idx": 184497}
{"func": "static void TIFFReadPhotoshopLayers(Image* image,const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  const char\n    *option;\n\n  const StringInfo\n    *layer_info;\n\n  Image\n    *layers;\n\n  PSDInfo\n    info;\n\n  register ssize_t\n    i;\n\n  if (GetImageListLength(image) != 1)\n    return;\n  if ((image_info->number_scenes == 1) && (image_info->scene == 0))\n    return;\n  option=GetImageOption(image_info,\"tiff:ignore-layers\");\n  if (option != (const char * ) NULL)\n    return;\n  layer_info=GetImageProfile(image,\"tiff:37724\");\n  if (layer_info == (const StringInfo *) NULL)\n    return;\n  for (i=0; i < (ssize_t) layer_info->length-8; i++)\n  {\n    if (LocaleNCompare((const char *) (layer_info->datum+i),\n        image->endian == MSBEndian ? \"8BIM\" : \"MIB8\",4) != 0)\n      continue;\n    i+=4;\n    if ((LocaleNCompare((const char *) (layer_info->datum+i),\n         image->endian == MSBEndian ? \"Layr\" : \"ryaL\",4) == 0) ||\n        (LocaleNCompare((const char *) (layer_info->datum+i),\n         image->endian == MSBEndian ? \"LMsk\" : \"ksML\",4) == 0) ||\n        (LocaleNCompare((const char *) (layer_info->datum+i),\n         image->endian == MSBEndian ? \"Lr16\" : \"61rL\",4) == 0) ||\n        (LocaleNCompare((const char *) (layer_info->datum+i),\n         image->endian == MSBEndian ? \"Lr32\" : \"23rL\",4) == 0))\n      break;\n  }\n  i+=4;\n  if (i >= (ssize_t) (layer_info->length-8))\n    return;\n  layers=CloneImage(image,image->columns,image->rows,MagickTrue,exception);\n  (void) DeleteImageProfile(layers,\"tiff:37724\");\n  AttachBlob(layers->blob,layer_info->datum,layer_info->length);\n  SeekBlob(layers,(MagickOffsetType) i,SEEK_SET);\n  info.version=1;\n  info.columns=layers->columns;\n  info.rows=layers->rows;\n  info.channels=(unsigned short) layers->number_channels;\n  /* Setting the mode to a value that won't change the colorspace */\n  info.mode=10;\n  ReadPSDLayers(layers,image_info,&info,MagickFalse,exception);\n  DeleteImageFromList(&layers);\n  if (layers != (Image *) NULL)\n    {\n      SetImageArtifact(image,\"tiff:has-layers\",\"true\");\n      AppendImageToList(&image,layers);\n      while (layers != (Image *) NULL)\n      {\n        SetImageArtifact(layers,\"tiff:has-layers\",\"true\");\n        DetachBlob(layers->blob);\n        layers=GetNextImageInList(layers);\n      }\n    }\n}\n", "target": 0, "idx": 71903}
{"func": "static void op32_tx_suspend(struct b43_dmaring *ring)\n{\n\tb43_dma_write(ring, B43_DMA32_TXCTL, b43_dma_read(ring, B43_DMA32_TXCTL)\n\t\t      | B43_DMA32_TXSUSPEND);\n}\n", "target": 0, "idx": 24562}
{"func": "XGetModifierMapping(register Display *dpy)\n{\n    xGetModifierMappingReply rep;\n    register xReq *req;\n    unsigned long nbytes;\n    XModifierKeymap *res;\n\n    LockDisplay(dpy);\n     GetEmptyReq(GetModifierMapping, req);\n     (void) _XReply (dpy, (xReply *)&rep, 0, xFalse);\n \n    if (rep.length < (INT_MAX >> 2)) {\n \tnbytes = (unsigned long)rep.length << 2;\n \tres = Xmalloc(sizeof (XModifierKeymap));\n \tif (res)\n    } else\n\tres = NULL;\n    if ((! res) || (! res->modifiermap)) {\n\tXfree(res);\n\tres = (XModifierKeymap *) NULL;\n\t_XEatDataWords(dpy, rep.length);\n    } else {\n\t_XReadPad(dpy, (char *) res->modifiermap, (long) nbytes);\n\tres->max_keypermod = rep.numKeyPerModifier;\n    }\n\n    UnlockDisplay(dpy);\n    SyncHandle();\n    return (res);\n}\n", "target": 1, "idx": 178096}
{"func": "static struct page *follow_pud_mask(struct vm_area_struct *vma,\n\t\t\t\t    unsigned long address, p4d_t *p4dp,\n\t\t\t\t    unsigned int flags,\n\t\t\t\t    struct follow_page_context *ctx)\n{\n\tpud_t *pud;\n\tspinlock_t *ptl;\n\tstruct page *page;\n\tstruct mm_struct *mm = vma->vm_mm;\n\n\tpud = pud_offset(p4dp, address);\n\tif (pud_none(*pud))\n\t\treturn no_page_table(vma, flags);\n\tif (pud_huge(*pud) && vma->vm_flags & VM_HUGETLB) {\n\t\tpage = follow_huge_pud(mm, address, pud, flags);\n\t\tif (page)\n\t\t\treturn page;\n\t\treturn no_page_table(vma, flags);\n\t}\n\tif (is_hugepd(__hugepd(pud_val(*pud)))) {\n\t\tpage = follow_huge_pd(vma, address,\n\t\t\t\t      __hugepd(pud_val(*pud)), flags,\n\t\t\t\t      PUD_SHIFT);\n\t\tif (page)\n\t\t\treturn page;\n\t\treturn no_page_table(vma, flags);\n\t}\n\tif (pud_devmap(*pud)) {\n\t\tptl = pud_lock(mm, pud);\n\t\tpage = follow_devmap_pud(vma, address, pud, flags, &ctx->pgmap);\n\t\tspin_unlock(ptl);\n\t\tif (page)\n\t\t\treturn page;\n\t}\n\tif (unlikely(pud_bad(*pud)))\n\t\treturn no_page_table(vma, flags);\n\n\treturn follow_pmd_mask(vma, address, pud, flags, ctx);\n}\n", "target": 0, "idx": 96952}
{"func": "GF_Err mvhd_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MovieHeaderBox *ptr = (GF_MovieHeaderBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\tif (ptr->version == 1) {\n\t\tptr->creationTime = gf_bs_read_u64(bs);\n\t\tptr->modificationTime = gf_bs_read_u64(bs);\n\t\tptr->timeScale = gf_bs_read_u32(bs);\n\t\tptr->duration = gf_bs_read_u64(bs);\n\t} else {\n\t\tptr->creationTime = gf_bs_read_u32(bs);\n\t\tptr->modificationTime = gf_bs_read_u32(bs);\n\t\tptr->timeScale = gf_bs_read_u32(bs);\n\t\tptr->duration = gf_bs_read_u32(bs);\n\t}\n\tif (!ptr->timeScale) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Movie header timescale is invalid (0) - defaulting to 600\\n\" ));\n\t\tptr->timeScale = 600;\n\t}\n\tptr->preferredRate = gf_bs_read_u32(bs);\n\tptr->preferredVolume = gf_bs_read_u16(bs);\n\tgf_bs_read_data(bs, ptr->reserved, 10);\n\tptr->matrixA = gf_bs_read_u32(bs);\n\tptr->matrixB = gf_bs_read_u32(bs);\n\tptr->matrixU = gf_bs_read_u32(bs);\n\tptr->matrixC = gf_bs_read_u32(bs);\n\tptr->matrixD = gf_bs_read_u32(bs);\n\tptr->matrixV = gf_bs_read_u32(bs);\n\tptr->matrixX = gf_bs_read_u32(bs);\n\tptr->matrixY = gf_bs_read_u32(bs);\n\tptr->matrixW = gf_bs_read_u32(bs);\n\tptr->previewTime = gf_bs_read_u32(bs);\n\tptr->previewDuration = gf_bs_read_u32(bs);\n\tptr->posterTime = gf_bs_read_u32(bs);\n\tptr->selectionTime = gf_bs_read_u32(bs);\n\tptr->selectionDuration = gf_bs_read_u32(bs);\n\tptr->currentTime = gf_bs_read_u32(bs);\n\tptr->nextTrackID = gf_bs_read_u32(bs);\n\tptr->original_duration = ptr->duration;\n\treturn GF_OK;\n}\n", "target": 0, "idx": 80278}
{"func": "static void parse_input(h2o_http2_conn_t *conn)\n {\n     size_t http2_max_concurrent_requests_per_connection = conn->super.ctx->globalconf->http2.max_concurrent_requests_per_connection;\n     int perform_early_exit = 0;\n\n    if (conn->num_streams.pull.half_closed + conn->num_streams.push.half_closed != http2_max_concurrent_requests_per_connection)\n        perform_early_exit = 1;\n\n    /* handle the input */\n    while (conn->state < H2O_HTTP2_CONN_STATE_IS_CLOSING && conn->sock->input->size != 0) {\n        if (perform_early_exit == 1 &&\n            conn->num_streams.pull.half_closed + conn->num_streams.push.half_closed == http2_max_concurrent_requests_per_connection)\n            goto EarlyExit;\n        /* process a frame */\n        const char *err_desc = NULL;\n        ssize_t ret = conn->_read_expect(conn, (uint8_t *)conn->sock->input->bytes, conn->sock->input->size, &err_desc);\n        if (ret == H2O_HTTP2_ERROR_INCOMPLETE) {\n            break;\n        } else if (ret < 0) {\n            if (ret != H2O_HTTP2_ERROR_PROTOCOL_CLOSE_IMMEDIATELY) {\n                 enqueue_goaway(conn, (int)ret,\n                                err_desc != NULL ? (h2o_iovec_t){(char *)err_desc, strlen(err_desc)} : (h2o_iovec_t){});\n             }\n            close_connection(conn);\n            return;\n         }\n         /* advance to the next frame */\n         h2o_buffer_consume(&conn->sock->input, ret);\n     }\n \n     if (!h2o_socket_is_reading(conn->sock))\n         h2o_socket_read_start(conn->sock, on_read);\n    return;\n \n EarlyExit:\n     if (h2o_socket_is_reading(conn->sock))\n         h2o_socket_read_stop(conn->sock);\n }\n", "target": 1, "idx": 180399}
{"func": "static void kvm_update_dr0123(struct kvm_vcpu *vcpu)\n{\n\tint i;\n\n\tif (!(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)) {\n\t\tfor (i = 0; i < KVM_NR_DB_REGS; i++)\n\t\t\tvcpu->arch.eff_db[i] = vcpu->arch.db[i];\n\t\tvcpu->arch.switch_db_regs |= KVM_DEBUGREG_RELOAD;\n\t}\n}\n", "target": 0, "idx": 57760}
{"func": "static int load_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n \t\t\t\t   u16 selector, int seg)\n {\n \tu8 cpl = ctxt->ops->cpl(ctxt);\n \treturn __load_segment_descriptor(ctxt, selector, seg, cpl,\n \t\t\t\t\t X86_TRANSFER_NONE, NULL);\n }\n", "target": 1, "idx": 181620}
{"func": " LIBOPENMPT_MODPLUG_API ModPlugNote* ModPlug_GetPattern(ModPlugFile* file, int pattern, unsigned int* numrows)\n{\n\tint c;\n\tint r;\n\tint numr;\n\tint numc;\n\tModPlugNote note;\n\tif(!file) return NULL;\n\tif(numrows){\n\t\t*numrows = openmpt_module_get_pattern_num_rows(file->mod,pattern);\n\t}\n\tif(pattern<0||pattern>=openmpt_module_get_num_patterns(file->mod)){\n\t\treturn NULL;\n\t}\n\tif(!file->patterns){\n\t\tfile->patterns = malloc(sizeof(ModPlugNote*)*openmpt_module_get_pattern_num_rows(file->mod,pattern));\n\t\tif(!file->patterns) return NULL;\n\t\tmemset(file->patterns,0,sizeof(ModPlugNote*)*openmpt_module_get_pattern_num_rows(file->mod,pattern));\n\t}\n\tif(!file->patterns[pattern]){\n\t\tfile->patterns[pattern] = malloc(sizeof(ModPlugNote)*openmpt_module_get_pattern_num_rows(file->mod,pattern)*openmpt_module_get_num_channels(file->mod));\n\t\tif(!file->patterns[pattern]) return NULL;\n\t\tmemset(file->patterns[pattern],0,sizeof(ModPlugNote)*openmpt_module_get_pattern_num_rows(file->mod,pattern)*openmpt_module_get_num_channels(file->mod));\n\t}\n\tnumr = openmpt_module_get_pattern_num_rows(file->mod,pattern);\n\tnumc = openmpt_module_get_num_channels(file->mod);\n\tfor(r=0;r<numr;r++){\n\t\tfor(c=0;c<numc;c++){\n\t\t\tmemset(&note,0,sizeof(ModPlugNote));\n\t\t\tnote.Note = openmpt_module_get_pattern_row_channel_command(file->mod,pattern,r,c,OPENMPT_MODULE_COMMAND_NOTE);\n\t\t\tnote.Instrument = openmpt_module_get_pattern_row_channel_command(file->mod,pattern,r,c,OPENMPT_MODULE_COMMAND_INSTRUMENT);\n\t\t\tnote.VolumeEffect = openmpt_module_get_pattern_row_channel_command(file->mod,pattern,r,c,OPENMPT_MODULE_COMMAND_VOLUMEEFFECT);\n\t\t\tnote.Effect = openmpt_module_get_pattern_row_channel_command(file->mod,pattern,r,c,OPENMPT_MODULE_COMMAND_EFFECT);\n\t\t\tnote.Volume = openmpt_module_get_pattern_row_channel_command(file->mod,pattern,r,c,OPENMPT_MODULE_COMMAND_VOLUME);\n\t\t\tnote.Parameter = openmpt_module_get_pattern_row_channel_command(file->mod,pattern,r,c,OPENMPT_MODULE_COMMAND_PARAMETER);\n\t\t\tmemcpy(&file->patterns[pattern][r*numc+c],&note,sizeof(ModPlugNote));\n\t\t}\n\t}\n\treturn file->patterns[pattern];\n}\n", "target": 0, "idx": 87637}
{"func": "GahpClient::clear_pending()\n{\n\tif ( pending_reqid ) {\n\t\tif (server->requestTable->remove(pending_reqid) == 0) {\n\t\t\tserver->requestTable->insert(pending_reqid,NULL);\n\t\t}\n\t}\n\tpending_reqid = 0;\n\tif (pending_result) delete pending_result;\n\tpending_result = NULL;\n\tfree(pending_command);\n\tpending_command = NULL;\n\tif (pending_args) free(pending_args);\n\tpending_args = NULL;\n\tpending_timeout = 0;\n\tif (pending_submitted_to_gahp) {\n\t\tserver->num_pending_requests--;\n\t}\n\tpending_submitted_to_gahp = false;\n\tif ( pending_timeout_tid != -1 ) {\n\t\tdaemonCore->Cancel_Timer(pending_timeout_tid);\n\t\tpending_timeout_tid = -1;\n\t}\n}\n", "target": 0, "idx": 16133}
{"func": "  TestBrowsingInstance(BrowserContext* browser_context, int* delete_counter)\n      : BrowsingInstance(browser_context),\n        delete_counter_(delete_counter) {\n  }\n", "target": 0, "idx": 125077}
{"func": "bool ParamTraits<base::PlatformFileInfo>::Read(const Message* m,\n                                               PickleIterator* iter,\n                                               param_type* p) {\n  double last_modified;\n  double last_accessed;\n  double creation_time;\n  bool result =\n      ReadParam(m, iter, &p->size) &&\n      ReadParam(m, iter, &p->is_directory) &&\n      ReadParam(m, iter, &last_modified) &&\n      ReadParam(m, iter, &last_accessed) &&\n      ReadParam(m, iter, &creation_time);\n  if (result) {\n    p->last_modified = base::Time::FromDoubleT(last_modified);\n    p->last_accessed = base::Time::FromDoubleT(last_accessed);\n    p->creation_time = base::Time::FromDoubleT(creation_time);\n  }\n  return result;\n}\n", "target": 0, "idx": 125809}
{"func": "bool CheckBasicProxyAuth(const AuthChallengeInfo* auth_challenge) {\n  if (!auth_challenge)\n    return false;\n  EXPECT_TRUE(auth_challenge->is_proxy);\n  EXPECT_EQ(\"myproxy:70\", auth_challenge->challenger.ToString());\n  EXPECT_EQ(\"MyRealm1\", auth_challenge->realm);\n  EXPECT_EQ(\"basic\", auth_challenge->scheme);\n  return true;\n}\n", "target": 0, "idx": 140444}
{"func": "RenderFrameHost* InterstitialPageImpl::GetMainFrame() const {\n  return render_view_host_->GetMainFrame();\n}\n", "target": 0, "idx": 148778}
{"func": "    StringCapturingFunction(ScriptState* scriptState, String* value)\n        : ScriptFunction(scriptState)\n        , m_value(value)\n    {\n    }\n", "target": 0, "idx": 128778}
{"func": "  virtual void SetUp() {\n    dir_maker_.SetUp();\n    mock_server_.reset(new MockConnectionManager(directory()));\n    EnableDatatype(syncable::BOOKMARKS);\n    EnableDatatype(syncable::NIGORI);\n    EnableDatatype(syncable::PREFERENCES);\n    EnableDatatype(syncable::NIGORI);\n    worker_ = new FakeModelWorker(GROUP_PASSIVE);\n    std::vector<SyncEngineEventListener*> listeners;\n    listeners.push_back(this);\n    context_.reset(\n        new SyncSessionContext(\n            mock_server_.get(), directory(), this,\n            &extensions_activity_monitor_, listeners, NULL,\n            &traffic_recorder_));\n    ASSERT_FALSE(context_->resolver());\n    syncer_ = new Syncer();\n    session_.reset(MakeSession());\n\n    ReadTransaction trans(FROM_HERE, directory());\n    syncable::Directory::ChildHandles children;\n    directory()->GetChildHandlesById(&trans, trans.root_id(), &children);\n    ASSERT_EQ(0u, children.size());\n    saw_syncer_event_ = false;\n    root_id_ = TestIdFactory::root();\n    parent_id_ = ids_.MakeServer(\"parent id\");\n    child_id_ = ids_.MakeServer(\"child id\");\n  }\n", "target": 0, "idx": 112054}
{"func": "ssh_session(void)\n{\n\tint type;\n\tint interactive = 0;\n\tint have_tty = 0;\n \tstruct winsize ws;\n \tchar *cp;\n \tconst char *display;\n \n \t/* Enable compression if requested. */\n \tif (options.compression) {\n\t\t    options.compression_level);\n\n\t\tif (options.compression_level < 1 ||\n\t\t    options.compression_level > 9)\n\t\t\tfatal(\"Compression level must be from 1 (fast) to \"\n\t\t\t    \"9 (slow, best).\");\n\n\t\t/* Send the request. */\n\t\tpacket_start(SSH_CMSG_REQUEST_COMPRESSION);\n\t\tpacket_put_int(options.compression_level);\n\t\tpacket_send();\n\t\tpacket_write_wait();\n\t\ttype = packet_read();\n\t\tif (type == SSH_SMSG_SUCCESS)\n\t\t\tpacket_start_compression(options.compression_level);\n\t\telse if (type == SSH_SMSG_FAILURE)\n\t\t\tlogit(\"Warning: Remote host refused compression.\");\n\t\telse\n\t\t\tpacket_disconnect(\"Protocol error waiting for \"\n\t\t\t    \"compression response.\");\n\t}\n\t/* Allocate a pseudo tty if appropriate. */\n\tif (tty_flag) {\n\t\tdebug(\"Requesting pty.\");\n\n\t\t/* Start the packet. */\n\t\tpacket_start(SSH_CMSG_REQUEST_PTY);\n\n\t\t/* Store TERM in the packet.  There is no limit on the\n\t\t   length of the string. */\n\t\tcp = getenv(\"TERM\");\n\t\tif (!cp)\n\t\t\tcp = \"\";\n\t\tpacket_put_cstring(cp);\n\n\t\t/* Store window size in the packet. */\n\t\tif (ioctl(fileno(stdin), TIOCGWINSZ, &ws) < 0)\n\t\t\tmemset(&ws, 0, sizeof(ws));\n\t\tpacket_put_int((u_int)ws.ws_row);\n\t\tpacket_put_int((u_int)ws.ws_col);\n\t\tpacket_put_int((u_int)ws.ws_xpixel);\n\t\tpacket_put_int((u_int)ws.ws_ypixel);\n\n\t\t/* Store tty modes in the packet. */\n\t\ttty_make_modes(fileno(stdin), NULL);\n\n\t\t/* Send the packet, and wait for it to leave. */\n\t\tpacket_send();\n\t\tpacket_write_wait();\n\n\t\t/* Read response from the server. */\n\t\ttype = packet_read();\n\t\tif (type == SSH_SMSG_SUCCESS) {\n\t\t\tinteractive = 1;\n\t\t\thave_tty = 1;\n\t\t} else if (type == SSH_SMSG_FAILURE)\n\t\t\tlogit(\"Warning: Remote host failed or refused to \"\n\t\t\t    \"allocate a pseudo tty.\");\n\t\telse\n\t\t\tpacket_disconnect(\"Protocol error waiting for pty \"\n\t\t\t    \"request response.\");\n\t}\n\t/* Request X11 forwarding if enabled and DISPLAY is set. */\n\tdisplay = getenv(\"DISPLAY\");\n \tdisplay = getenv(\"DISPLAY\");\n \tif (display == NULL && options.forward_x11)\n \t\tdebug(\"X11 forwarding requested but DISPLAY not set\");\n\tif (options.forward_x11 && display != NULL) {\n\t\tchar *proto, *data;\n\t\t/* Get reasonable local authentication information. */\n\t\tclient_x11_get_proto(display, options.xauth_location,\n\t\t    options.forward_x11_trusted,\n\t\t    options.forward_x11_timeout,\n\t\t    &proto, &data);\n \t\t/* Request forwarding with authentication spoofing. */\n \t\tdebug(\"Requesting X11 forwarding with authentication \"\n \t\t    \"spoofing.\");\n\t\t/* Request forwarding with authentication spoofing. */\n\t\tdebug(\"Requesting X11 forwarding with authentication \"\n\t\t    \"spoofing.\");\n\t\tx11_request_forwarding_with_spoofing(0, display, proto,\n\t\t    data, 0);\n\t\t/* Read response from the server. */\n\t\ttype = packet_read();\n\t\tif (type == SSH_SMSG_SUCCESS) {\n\t\t\tinteractive = 1;\n\t\t} else if (type == SSH_SMSG_FAILURE) {\n\t\t\tlogit(\"Warning: Remote host denied X11 forwarding.\");\n\t\t} else {\n\t\t\tpacket_disconnect(\"Protocol error waiting for X11 \"\n\t\t\t    \"forwarding\");\n\t\t}\n\t}\n\t/* Tell the packet module whether this is an interactive session. */\n\tpacket_set_interactive(interactive,\n\t    options.ip_qos_interactive, options.ip_qos_bulk);\n\n\t/* Request authentication agent forwarding if appropriate. */\n\tcheck_agent_present();\n\n\tif (options.forward_agent) {\n\t\tdebug(\"Requesting authentication agent forwarding.\");\n\t\tauth_request_forwarding();\n\n\t\t/* Read response from the server. */\n\t\ttype = packet_read();\n\t\tpacket_check_eom();\n\t\tif (type != SSH_SMSG_SUCCESS)\n\t\t\tlogit(\"Warning: Remote host denied authentication agent forwarding.\");\n\t}\n\n\t/* Initiate port forwardings. */\n\tssh_init_stdio_forwarding();\n\tssh_init_forwarding();\n\n\t/* Execute a local command */\n\tif (options.local_command != NULL &&\n\t    options.permit_local_command)\n\t\tssh_local_cmd(options.local_command);\n\n\t/*\n\t * If requested and we are not interested in replies to remote\n\t * forwarding requests, then let ssh continue in the background.\n\t */\n\tif (fork_after_authentication_flag) {\n\t\tif (options.exit_on_forward_failure &&\n\t\t    options.num_remote_forwards > 0) {\n\t\t\tdebug(\"deferring postauth fork until remote forward \"\n\t\t\t    \"confirmation received\");\n\t\t} else\n\t\t\tfork_postauth();\n\t}\n\n\t/*\n\t * If a command was specified on the command line, execute the\n\t * command now. Otherwise request the server to start a shell.\n\t */\n\tif (buffer_len(&command) > 0) {\n\t\tint len = buffer_len(&command);\n\t\tif (len > 900)\n\t\t\tlen = 900;\n\t\tdebug(\"Sending command: %.*s\", len,\n\t\t    (u_char *)buffer_ptr(&command));\n\t\tpacket_start(SSH_CMSG_EXEC_CMD);\n\t\tpacket_put_string(buffer_ptr(&command), buffer_len(&command));\n\t\tpacket_send();\n\t\tpacket_write_wait();\n\t} else {\n\t\tdebug(\"Requesting shell.\");\n\t\tpacket_start(SSH_CMSG_EXEC_SHELL);\n\t\tpacket_send();\n\t\tpacket_write_wait();\n\t}\n\n\t/* Enter the interactive session. */\n\treturn client_loop(have_tty, tty_flag ?\n\t    options.escape_char : SSH_ESCAPECHAR_NONE, 0);\n}\n", "target": 1, "idx": 178525}
{"func": "static int hash_sendmsg(struct kiocb *unused, struct socket *sock,\n\t\t\tstruct msghdr *msg, size_t ignored)\n{\n\tint limit = ALG_MAX_PAGES * PAGE_SIZE;\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct hash_ctx *ctx = ask->private;\n\tunsigned long iovlen;\n\tstruct iovec *iov;\n\tlong copied = 0;\n\tint err;\n\n\tif (limit > sk->sk_sndbuf)\n\t\tlimit = sk->sk_sndbuf;\n\n\tlock_sock(sk);\n\tif (!ctx->more) {\n\t\terr = crypto_ahash_init(&ctx->req);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t}\n\n\tctx->more = 0;\n\n\tfor (iov = msg->msg_iov, iovlen = msg->msg_iovlen; iovlen > 0;\n\t     iovlen--, iov++) {\n\t\tunsigned long seglen = iov->iov_len;\n\t\tchar __user *from = iov->iov_base;\n\n\t\twhile (seglen) {\n\t\t\tint len = min_t(unsigned long, seglen, limit);\n\t\t\tint newlen;\n\n\t\t\tnewlen = af_alg_make_sg(&ctx->sgl, from, len, 0);\n\t\t\tif (newlen < 0) {\n\t\t\t\terr = copied ? 0 : newlen;\n\t\t\t\tgoto unlock;\n\t\t\t}\n\n\t\t\tahash_request_set_crypt(&ctx->req, ctx->sgl.sg, NULL,\n\t\t\t\t\t\tnewlen);\n\n\t\t\terr = af_alg_wait_for_completion(\n\t\t\t\tcrypto_ahash_update(&ctx->req),\n\t\t\t\t&ctx->completion);\n\n\t\t\taf_alg_free_sg(&ctx->sgl);\n\n\t\t\tif (err)\n\t\t\t\tgoto unlock;\n\n\t\t\tseglen -= newlen;\n\t\t\tfrom += newlen;\n\t\t\tcopied += newlen;\n\t\t}\n\t}\n\n\terr = 0;\n\n\tctx->more = msg->msg_flags & MSG_MORE;\n\tif (!ctx->more) {\n\t\tahash_request_set_crypt(&ctx->req, NULL, ctx->result, 0);\n\t\terr = af_alg_wait_for_completion(crypto_ahash_final(&ctx->req),\n\t\t\t\t\t\t &ctx->completion);\n\t}\n\nunlock:\n\trelease_sock(sk);\n\n\treturn err ?: copied;\n}\n", "target": 0, "idx": 30840}
{"func": "MagickExport ssize_t WriteBlobMSBSignedShort(Image *image,\n  const signed short value)\n{\n  union\n  {\n    unsigned short\n      unsigned_value;\n\n    signed short\n      signed_value;\n  } quantum;\n\n  unsigned char\n    buffer[2];\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  quantum.signed_value=value;\n  buffer[0]=(unsigned char) (quantum.unsigned_value >> 8);\n  buffer[1]=(unsigned char) quantum.unsigned_value;\n  return(WriteBlobStream(image,2,buffer));\n}\n", "target": 0, "idx": 88576}
{"func": "sg_common_write(Sg_fd * sfp, Sg_request * srp,\n\t\tunsigned char *cmnd, int timeout, int blocking)\n{\n\tint k, at_head;\n\tSg_device *sdp = sfp->parentdp;\n\tsg_io_hdr_t *hp = &srp->header;\n\n\tsrp->data.cmd_opcode = cmnd[0];\t/* hold opcode of command */\n\thp->status = 0;\n\thp->masked_status = 0;\n\thp->msg_status = 0;\n\thp->info = 0;\n\thp->host_status = 0;\n\thp->driver_status = 0;\n\thp->resid = 0;\n\tSCSI_LOG_TIMEOUT(4, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\t\"sg_common_write:  scsi opcode=0x%02x, cmd_size=%d\\n\",\n\t\t\t(int) cmnd[0], (int) hp->cmd_len));\n\n\tk = sg_start_req(srp, cmnd);\n\tif (k) {\n\t\tSCSI_LOG_TIMEOUT(1, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\t\"sg_common_write: start_req err=%d\\n\", k));\n\t\tsg_finish_rem_req(srp);\n \t\treturn k;\t/* probably out of space --> ENOMEM */\n \t}\n \tif (atomic_read(&sdp->detaching)) {\n\t\tif (srp->bio)\n \t\t\tblk_end_request_all(srp->rq, -EIO);\n \t\tsg_finish_rem_req(srp);\n \t\treturn -ENODEV;\n \t}\n\n\thp->duration = jiffies_to_msecs(jiffies);\n\tif (hp->interface_id != '\\0' &&\t/* v3 (or later) interface */\n\t    (SG_FLAG_Q_AT_TAIL & hp->flags))\n\t\tat_head = 0;\n\telse\n\t\tat_head = 1;\n\n\tsrp->rq->timeout = timeout;\n\tkref_get(&sfp->f_ref); /* sg_rq_end_io() does kref_put(). */\n\tblk_execute_rq_nowait(sdp->device->request_queue, sdp->disk,\n\t\t\t      srp->rq, at_head, sg_rq_end_io);\n\treturn 0;\n}\n", "target": 1, "idx": 180636}
{"func": "bool smb2cli_conn_req_possible(struct smbXcli_conn *conn, uint32_t *max_dyn_len)\n{\n\tuint16_t credits = 1;\n\n\tif (conn->smb2.cur_credits == 0) {\n\t\tif (max_dyn_len != NULL) {\n\t\t\t*max_dyn_len = 0;\n\t\t}\n\t\treturn false;\n\t}\n\n\tif (conn->smb2.server.capabilities & SMB2_CAP_LARGE_MTU) {\n\t\tcredits = conn->smb2.cur_credits;\n\t}\n\n\tif (max_dyn_len != NULL) {\n\t\t*max_dyn_len = credits * 65536;\n\t}\n\n\treturn true;\n}\n", "target": 0, "idx": 2436}
{"func": "int proc_doulongvec_minmax(struct ctl_table *table, int write,\n\t\t    void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}\n", "target": 0, "idx": 24434}
{"func": "void cpu_load_update_nohz_start(void)\n{\n\tstruct rq *this_rq = this_rq();\n\n\t/*\n\t * This is all lockless but should be fine. If weighted_cpuload changes\n\t * concurrently we'll exit nohz. And cpu_load write can race with\n\t * cpu_load_update_idle() but both updater would be writing the same.\n\t */\n\tthis_rq->cpu_load[0] = weighted_cpuload(this_rq);\n}\n", "target": 0, "idx": 92514}
{"func": "static void addr_hash_set(u32 *mask, const u8 *addr)\n{\n\tint n = ether_crc(ETH_ALEN, addr) >> 26;\n\tmask[n >> 5] |= (1 << (n & 31));\n}\n", "target": 0, "idx": 23836}
{"func": "std::string GLES2Util::GetQualifiedEnumString(const EnumToString* table,\n                                              size_t count,\n                                              uint32_t value) {\n  for (const EnumToString* end = table + count; table < end; ++table) {\n    if (table->value == value) {\n      return table->name;\n    }\n  }\n  return GetStringEnum(value);\n}\n", "target": 0, "idx": 166395}
{"func": "unsigned long FrameLoader::loadResourceSynchronously(const ResourceRequest& request, StoredCredentials storedCredentials, ResourceError& error, ResourceResponse& response, Vector<char>& data)\n{\n    String referrer = m_outgoingReferrer;\n    if (SecurityOrigin::shouldHideReferrer(request.url(), referrer))\n        referrer = String();\n    \n    ResourceRequest initialRequest = request;\n    initialRequest.setTimeoutInterval(10);\n    \n    if (initialRequest.isConditional())\n        initialRequest.setCachePolicy(ReloadIgnoringCacheData);\n    else\n        initialRequest.setCachePolicy(documentLoader()->request().cachePolicy());\n    \n    if (!referrer.isEmpty())\n        initialRequest.setHTTPReferrer(referrer);\n    addHTTPOriginIfNeeded(initialRequest, outgoingOrigin());\n\n    if (Page* page = m_frame->page())\n        initialRequest.setFirstPartyForCookies(page->mainFrame()->loader()->documentLoader()->request().url());\n    initialRequest.setHTTPUserAgent(client()->userAgent(request.url()));\n\n    unsigned long identifier = 0;    \n    ResourceRequest newRequest(initialRequest);\n    requestFromDelegate(newRequest, identifier, error);\n\n    if (error.isNull()) {\n        ASSERT(!newRequest.isNull());\n        \n#if ENABLE(OFFLINE_WEB_APPLICATIONS)\n        if (!documentLoader()->applicationCacheHost()->maybeLoadSynchronously(newRequest, error, response, data)) {\n#endif\n            ResourceHandle::loadResourceSynchronously(newRequest, storedCredentials, error, response, data, m_frame);\n#if ENABLE(OFFLINE_WEB_APPLICATIONS)\n            documentLoader()->applicationCacheHost()->maybeLoadFallbackSynchronously(newRequest, error, response, data);\n        }\n#endif\n    }\n\n    notifier()->sendRemainingDelegateMessages(m_documentLoader.get(), identifier, response, data.size(), error);\n    return identifier;\n}\n", "target": 0, "idx": 97442}
