{"func": "bool GLES2DecoderImpl::SimulateAttrib0(\n    GLuint max_vertex_accessed, bool* simulated) {\n  DCHECK(simulated);\n  *simulated = false;\n\n  if (gfx::GetGLImplementation() == gfx::kGLImplementationEGLGLES2)\n    return true;\n\n  const VertexAttribManager::VertexAttribInfo* info =\n      vertex_attrib_manager_->GetVertexAttribInfo(0);\n  bool attrib_0_used = current_program_->GetAttribInfoByLocation(0) != NULL;\n  if (info->enabled() && attrib_0_used) {\n    return true;\n  }\n\n  typedef VertexAttribManager::VertexAttribInfo::Vec4 Vec4;\n\n  GLuint num_vertices = max_vertex_accessed + 1;\n  GLuint size_needed = 0;\n\n  if (num_vertices == 0 ||\n      !SafeMultiply(num_vertices, static_cast<GLuint>(sizeof(Vec4)),\n                    &size_needed) ||\n      size_needed > 0x7FFFFFFFU) {\n    SetGLError(GL_OUT_OF_MEMORY, \"glDrawXXX: Simulating attrib 0\");\n    return false;\n  }\n\n   CopyRealGLErrorsToWrapper();\n   glBindBuffer(GL_ARRAY_BUFFER, attrib_0_buffer_id_);\n \n  if (static_cast<GLsizei>(size_needed) > attrib_0_size_) {\n     glBufferData(GL_ARRAY_BUFFER, size_needed, NULL, GL_DYNAMIC_DRAW);\n     GLenum error = glGetError();\n     if (error != GL_NO_ERROR) {\n       SetGLError(GL_OUT_OF_MEMORY, \"glDrawXXX: Simulating attrib 0\");\n       return false;\n     }\n    attrib_0_buffer_matches_value_ = false;\n  }\n  if (attrib_0_used &&\n      (!attrib_0_buffer_matches_value_ ||\n       (info->value().v[0] != attrib_0_value_.v[0] ||\n        info->value().v[1] != attrib_0_value_.v[1] ||\n        info->value().v[2] != attrib_0_value_.v[2] ||\n        info->value().v[3] != attrib_0_value_.v[3]))) {\n     std::vector<Vec4> temp(num_vertices, info->value());\n     glBufferSubData(GL_ARRAY_BUFFER, 0, size_needed, &temp[0].v[0]);\n     attrib_0_buffer_matches_value_ = true;\n    attrib_0_value_ = info->value();\n    attrib_0_size_ = size_needed;\n  }\n\n  glVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, 0, NULL);\n\n  if (info->divisor())\n    glVertexAttribDivisorANGLE(0, 0);\n\n  *simulated = true;\n  return true;\n}\n", "target": 1, "idx": 184750}
{"func": "void CLASS parse_mos (int offset)\n{\n  char data[40];\n  int skip, from, i, c, neut[4], planes=0, frot=0;\n  static const char *mod[] =\n  { \"\",\"DCB2\",\"Volare\",\"Cantare\",\"CMost\",\"Valeo 6\",\"Valeo 11\",\"Valeo 22\",\n    \"Valeo 11p\",\"Valeo 17\",\"\",\"Aptus 17\",\"Aptus 22\",\"Aptus 75\",\"Aptus 65\",\n    \"Aptus 54S\",\"Aptus 65S\",\"Aptus 75S\",\"AFi 5\",\"AFi 6\",\"AFi 7\",\n    \"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"AFi-II 12\" };\n  float romm_cam[3][3];\n\n  fseek (ifp, offset, SEEK_SET);\n  while (1) {\n    if (get4() != 0x504b5453) break;\n    get4();\n    fread (data, 1, 40, ifp);\n    skip = get4();\n    from = ftell(ifp);\n    if (!strcmp(data,\"JPEG_preview_data\")) {\n      thumb_offset = from;\n      thumb_length = skip;\n    }\n    if (!strcmp(data,\"icc_camera_profile\")) {\n      profile_offset = from;\n      profile_length = skip;\n    }\n    if (!strcmp(data,\"ShootObj_back_type\")) {\n      fscanf (ifp, \"%d\", &i);\n      if ((unsigned) i < sizeof mod / sizeof (*mod))\n\tstrcpy (model, mod[i]);\n    }\n    if (!strcmp(data,\"icc_camera_to_tone_matrix\")) {\n      for (i=0; i < 9; i++)\n\tromm_cam[0][i] = int_to_float(get4());\n      romm_coeff (romm_cam);\n    }\n    if (!strcmp(data,\"CaptProf_color_matrix\")) {\n      for (i=0; i < 9; i++)\n\tfscanf (ifp, \"%f\", &romm_cam[0][i]);\n      romm_coeff (romm_cam);\n    }\n    if (!strcmp(data,\"CaptProf_number_of_planes\"))\n      fscanf (ifp, \"%d\", &planes);\n    if (!strcmp(data,\"CaptProf_raw_data_rotation\"))\n      fscanf (ifp, \"%d\", &flip);\n    if (!strcmp(data,\"CaptProf_mosaic_pattern\"))\n      FORC4 {\n\tfscanf (ifp, \"%d\", &i);\n\tif (i == 1) frot = c ^ (c >> 1);\n      }\n    if (!strcmp(data,\"ImgProf_rotation_angle\")) {\n      fscanf (ifp, \"%d\", &i);\n      flip = i - flip;\n    }\n    if (!strcmp(data,\"NeutObj_neutrals\") && !cam_mul[0]) {\n      FORC4 fscanf (ifp, \"%d\", neut+c);\n      FORC3 cam_mul[c] = (float) neut[0] / neut[c+1];\n    }\n    if (!strcmp(data,\"Rows_data\"))\n      load_flags = get4();\n    parse_mos (from);\n    fseek (ifp, skip+from, SEEK_SET);\n  }\n  if (planes)\n    filters = (planes == 1) * 0x01010101 *\n\t(uchar) \"\\x94\\x61\\x16\\x49\"[(flip/90 + frot) & 3];\n}\n", "target": 0, "idx": 43344}
{"func": "void RenderViewImpl::OnCopyToFindPboard() {\n  if (!webview())\n    return;\n\n  WebFrame* frame = webview()->focusedFrame();\n  if (frame->hasSelection()) {\n    string16 selection = frame->selectionAsText();\n    RenderThread::Get()->Send(\n        new ClipboardHostMsg_FindPboardWriteStringAsync(selection));\n  }\n}\n", "target": 0, "idx": 108920}
{"func": "ZSTD_reset_matchState(ZSTD_matchState_t* ms,\n                      void* ptr,\n                const ZSTD_compressionParameters* cParams,\n                      ZSTD_compResetPolicy_e const crp, U32 const forCCtx)\n{\n    size_t const chainSize = (cParams->strategy == ZSTD_fast) ? 0 : ((size_t)1 << cParams->chainLog);\n    size_t const hSize = ((size_t)1) << cParams->hashLog;\n    U32    const hashLog3 = (forCCtx && cParams->searchLength==3) ? MIN(ZSTD_HASHLOG3_MAX, cParams->windowLog) : 0;\n    size_t const h3Size = ((size_t)1) << hashLog3;\n    size_t const tableSpace = (chainSize + hSize + h3Size) * sizeof(U32);\n\n    assert(((size_t)ptr & 3) == 0);\n\n    ms->hashLog3 = hashLog3;\n    memset(&ms->window, 0, sizeof(ms->window));\n    ms->window.dictLimit = 1;    /* start from 1, so that 1st position is valid */\n    ms->window.lowLimit = 1;     /* it ensures first and later CCtx usages compress the same */\n    ms->window.nextSrc = ms->window.base + 1;   /* see issue #1241 */\n    ZSTD_invalidateMatchState(ms);\n\n    /* opt parser space */\n    if (forCCtx && ((cParams->strategy == ZSTD_btopt) | (cParams->strategy == ZSTD_btultra))) {\n        DEBUGLOG(4, \"reserving optimal parser space\");\n        ms->opt.litFreq = (U32*)ptr;\n        ms->opt.litLengthFreq = ms->opt.litFreq + (1<<Litbits);\n        ms->opt.matchLengthFreq = ms->opt.litLengthFreq + (MaxLL+1);\n        ms->opt.offCodeFreq = ms->opt.matchLengthFreq + (MaxML+1);\n        ptr = ms->opt.offCodeFreq + (MaxOff+1);\n        ms->opt.matchTable = (ZSTD_match_t*)ptr;\n        ptr = ms->opt.matchTable + ZSTD_OPT_NUM+1;\n        ms->opt.priceTable = (ZSTD_optimal_t*)ptr;\n        ptr = ms->opt.priceTable + ZSTD_OPT_NUM+1;\n    }\n\n    /* table Space */\n    DEBUGLOG(4, \"reset table : %u\", crp!=ZSTDcrp_noMemset);\n    assert(((size_t)ptr & 3) == 0);  /* ensure ptr is properly aligned */\n    if (crp!=ZSTDcrp_noMemset) memset(ptr, 0, tableSpace);   /* reset tables only */\n    ms->hashTable = (U32*)(ptr);\n    ms->chainTable = ms->hashTable + hSize;\n    ms->hashTable3 = ms->chainTable + chainSize;\n    ptr = ms->hashTable3 + h3Size;\n\n    ms->cParams = *cParams;\n\n    assert(((size_t)ptr & 3) == 0);\n    return ptr;\n}\n", "target": 0, "idx": 90113}
{"func": "static void hns_xgmac_pma_fec_enable(struct mac_driver *drv, u32 tx_value,\n\t\t\t\t     u32 rx_value)\n{\n\tu32 origin = dsaf_read_dev(drv, XGMAC_PMA_FEC_CONTROL_REG);\n\n\tdsaf_set_bit(origin, XGMAC_PMA_FEC_CTL_TX_B, !!tx_value);\n\tdsaf_set_bit(origin, XGMAC_PMA_FEC_CTL_RX_B, !!rx_value);\n\tdsaf_write_dev(drv, XGMAC_PMA_FEC_CONTROL_REG, origin);\n}\n", "target": 0, "idx": 85644}
{"func": "void KeyboardUI::RemoveObserver(KeyboardUIObserver* observer) {\n  observers_.RemoveObserver(observer);\n}\n", "target": 0, "idx": 138556}
{"func": "static void initializeHolderIfNeeded(ScriptState* scriptState, v8::Local<v8::Object> classObject, v8::Local<v8::Value> holder)\n{\n    RELEASE_ASSERT(!holder.IsEmpty());\n    RELEASE_ASSERT(holder->IsObject());\n    v8::Local<v8::Object> holderObject = v8::Local<v8::Object>::Cast(holder);\n    v8::Isolate* isolate = scriptState->isolate();\n    v8::Local<v8::Context> context = scriptState->context();\n    auto privateIsInitialized = V8PrivateProperty::getPrivateScriptRunnerIsInitialized(isolate);\n    if (privateIsInitialized.hasValue(context, holderObject))\n        return; // Already initialized.\n\n    v8::TryCatch block(isolate);\n    v8::Local<v8::Value> initializeFunction;\n     if (classObject->Get(scriptState->context(), v8String(isolate, \"initialize\")).ToLocal(&initializeFunction) && initializeFunction->IsFunction()) {\n         v8::TryCatch block(isolate);\n         v8::Local<v8::Value> result;\n        if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(initializeFunction), scriptState->getExecutionContext(), holder, 0, 0, isolate).ToLocal(&result)) {\n             fprintf(stderr, \"Private script error: Object constructor threw an exception.\\n\");\n             dumpV8Message(context, block.Message());\n             RELEASE_NOTREACHED();\n        }\n    }\n\n    if (classObject->GetPrototype() != holderObject->GetPrototype()) {\n        if (!v8CallBoolean(classObject->SetPrototype(context, holderObject->GetPrototype()))) {\n            fprintf(stderr, \"Private script error: SetPrototype failed.\\n\");\n            dumpV8Message(context, block.Message());\n            RELEASE_NOTREACHED();\n        }\n    }\n    if (!v8CallBoolean(holderObject->SetPrototype(context, classObject))) {\n        fprintf(stderr, \"Private script error: SetPrototype failed.\\n\");\n        dumpV8Message(context, block.Message());\n        RELEASE_NOTREACHED();\n    }\n\n    privateIsInitialized.set(context, holderObject, v8Boolean(true, isolate));\n}\n", "target": 1, "idx": 185987}
{"func": "void mbedtls_strerror( int ret, char *buf, size_t buflen )\n{\n    size_t len;\n    int use_ret;\n\n    if( buflen == 0 )\n        return;\n\n    memset( buf, 0x00, buflen );\n\n    if( ret < 0 )\n        ret = -ret;\n\n    if( ret & 0xFF80 )\n    {\n        use_ret = ret & 0xFF80;\n\n#if defined(MBEDTLS_CIPHER_C)\n        if( use_ret == -(MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE) )\n            mbedtls_snprintf( buf, buflen, \"CIPHER - The selected feature is not available\" );\n        if( use_ret == -(MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA) )\n            mbedtls_snprintf( buf, buflen, \"CIPHER - Bad input parameters to function\" );\n        if( use_ret == -(MBEDTLS_ERR_CIPHER_ALLOC_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"CIPHER - Failed to allocate memory\" );\n        if( use_ret == -(MBEDTLS_ERR_CIPHER_INVALID_PADDING) )\n            mbedtls_snprintf( buf, buflen, \"CIPHER - Input data contains invalid padding and is rejected\" );\n        if( use_ret == -(MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED) )\n            mbedtls_snprintf( buf, buflen, \"CIPHER - Decryption of block requires a full block\" );\n        if( use_ret == -(MBEDTLS_ERR_CIPHER_AUTH_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"CIPHER - Authentication failed (for AEAD modes)\" );\n        if( use_ret == -(MBEDTLS_ERR_CIPHER_INVALID_CONTEXT) )\n            mbedtls_snprintf( buf, buflen, \"CIPHER - The context is invalid, eg because it was free()ed\" );\n#endif /* MBEDTLS_CIPHER_C */\n\n#if defined(MBEDTLS_DHM_C)\n        if( use_ret == -(MBEDTLS_ERR_DHM_BAD_INPUT_DATA) )\n            mbedtls_snprintf( buf, buflen, \"DHM - Bad input parameters to function\" );\n        if( use_ret == -(MBEDTLS_ERR_DHM_READ_PARAMS_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"DHM - Reading of the DHM parameters failed\" );\n        if( use_ret == -(MBEDTLS_ERR_DHM_MAKE_PARAMS_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"DHM - Making of the DHM parameters failed\" );\n        if( use_ret == -(MBEDTLS_ERR_DHM_READ_PUBLIC_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"DHM - Reading of the public values failed\" );\n        if( use_ret == -(MBEDTLS_ERR_DHM_MAKE_PUBLIC_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"DHM - Making of the public value failed\" );\n        if( use_ret == -(MBEDTLS_ERR_DHM_CALC_SECRET_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"DHM - Calculation of the DHM secret failed\" );\n        if( use_ret == -(MBEDTLS_ERR_DHM_INVALID_FORMAT) )\n            mbedtls_snprintf( buf, buflen, \"DHM - The ASN.1 data is not formatted correctly\" );\n        if( use_ret == -(MBEDTLS_ERR_DHM_ALLOC_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"DHM - Allocation of memory failed\" );\n        if( use_ret == -(MBEDTLS_ERR_DHM_FILE_IO_ERROR) )\n            mbedtls_snprintf( buf, buflen, \"DHM - Read/write of file failed\" );\n#endif /* MBEDTLS_DHM_C */\n\n#if defined(MBEDTLS_ECP_C)\n        if( use_ret == -(MBEDTLS_ERR_ECP_BAD_INPUT_DATA) )\n            mbedtls_snprintf( buf, buflen, \"ECP - Bad input parameters to function\" );\n        if( use_ret == -(MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL) )\n            mbedtls_snprintf( buf, buflen, \"ECP - The buffer is too small to write to\" );\n        if( use_ret == -(MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE) )\n            mbedtls_snprintf( buf, buflen, \"ECP - Requested curve not available\" );\n        if( use_ret == -(MBEDTLS_ERR_ECP_VERIFY_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"ECP - The signature is not valid\" );\n        if( use_ret == -(MBEDTLS_ERR_ECP_ALLOC_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"ECP - Memory allocation failed\" );\n        if( use_ret == -(MBEDTLS_ERR_ECP_RANDOM_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"ECP - Generation of random value, such as (ephemeral) key, failed\" );\n        if( use_ret == -(MBEDTLS_ERR_ECP_INVALID_KEY) )\n            mbedtls_snprintf( buf, buflen, \"ECP - Invalid private or public key\" );\n        if( use_ret == -(MBEDTLS_ERR_ECP_SIG_LEN_MISMATCH) )\n            mbedtls_snprintf( buf, buflen, \"ECP - Signature is valid but shorter than the user-supplied length\" );\n#endif /* MBEDTLS_ECP_C */\n\n#if defined(MBEDTLS_MD_C)\n        if( use_ret == -(MBEDTLS_ERR_MD_FEATURE_UNAVAILABLE) )\n            mbedtls_snprintf( buf, buflen, \"MD - The selected feature is not available\" );\n        if( use_ret == -(MBEDTLS_ERR_MD_BAD_INPUT_DATA) )\n            mbedtls_snprintf( buf, buflen, \"MD - Bad input parameters to function\" );\n        if( use_ret == -(MBEDTLS_ERR_MD_ALLOC_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"MD - Failed to allocate memory\" );\n        if( use_ret == -(MBEDTLS_ERR_MD_FILE_IO_ERROR) )\n            mbedtls_snprintf( buf, buflen, \"MD - Opening or reading of file failed\" );\n#endif /* MBEDTLS_MD_C */\n\n#if defined(MBEDTLS_PEM_PARSE_C) || defined(MBEDTLS_PEM_WRITE_C)\n        if( use_ret == -(MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT) )\n            mbedtls_snprintf( buf, buflen, \"PEM - No PEM header or footer found\" );\n        if( use_ret == -(MBEDTLS_ERR_PEM_INVALID_DATA) )\n            mbedtls_snprintf( buf, buflen, \"PEM - PEM string is not as expected\" );\n        if( use_ret == -(MBEDTLS_ERR_PEM_ALLOC_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"PEM - Failed to allocate memory\" );\n        if( use_ret == -(MBEDTLS_ERR_PEM_INVALID_ENC_IV) )\n            mbedtls_snprintf( buf, buflen, \"PEM - RSA IV is not in hex-format\" );\n        if( use_ret == -(MBEDTLS_ERR_PEM_UNKNOWN_ENC_ALG) )\n            mbedtls_snprintf( buf, buflen, \"PEM - Unsupported key encryption algorithm\" );\n        if( use_ret == -(MBEDTLS_ERR_PEM_PASSWORD_REQUIRED) )\n            mbedtls_snprintf( buf, buflen, \"PEM - Private key password can't be empty\" );\n        if( use_ret == -(MBEDTLS_ERR_PEM_PASSWORD_MISMATCH) )\n            mbedtls_snprintf( buf, buflen, \"PEM - Given private key password does not allow for correct decryption\" );\n        if( use_ret == -(MBEDTLS_ERR_PEM_FEATURE_UNAVAILABLE) )\n            mbedtls_snprintf( buf, buflen, \"PEM - Unavailable feature, e.g. hashing/encryption combination\" );\n        if( use_ret == -(MBEDTLS_ERR_PEM_BAD_INPUT_DATA) )\n            mbedtls_snprintf( buf, buflen, \"PEM - Bad input parameters to function\" );\n#endif /* MBEDTLS_PEM_PARSE_C || MBEDTLS_PEM_WRITE_C */\n\n#if defined(MBEDTLS_PK_C)\n        if( use_ret == -(MBEDTLS_ERR_PK_ALLOC_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"PK - Memory allocation failed\" );\n        if( use_ret == -(MBEDTLS_ERR_PK_TYPE_MISMATCH) )\n            mbedtls_snprintf( buf, buflen, \"PK - Type mismatch, eg attempt to encrypt with an ECDSA key\" );\n        if( use_ret == -(MBEDTLS_ERR_PK_BAD_INPUT_DATA) )\n            mbedtls_snprintf( buf, buflen, \"PK - Bad input parameters to function\" );\n        if( use_ret == -(MBEDTLS_ERR_PK_FILE_IO_ERROR) )\n            mbedtls_snprintf( buf, buflen, \"PK - Read/write of file failed\" );\n        if( use_ret == -(MBEDTLS_ERR_PK_KEY_INVALID_VERSION) )\n            mbedtls_snprintf( buf, buflen, \"PK - Unsupported key version\" );\n        if( use_ret == -(MBEDTLS_ERR_PK_KEY_INVALID_FORMAT) )\n            mbedtls_snprintf( buf, buflen, \"PK - Invalid key tag or value\" );\n        if( use_ret == -(MBEDTLS_ERR_PK_UNKNOWN_PK_ALG) )\n            mbedtls_snprintf( buf, buflen, \"PK - Key algorithm is unsupported (only RSA and EC are supported)\" );\n        if( use_ret == -(MBEDTLS_ERR_PK_PASSWORD_REQUIRED) )\n            mbedtls_snprintf( buf, buflen, \"PK - Private key password can't be empty\" );\n        if( use_ret == -(MBEDTLS_ERR_PK_PASSWORD_MISMATCH) )\n            mbedtls_snprintf( buf, buflen, \"PK - Given private key password does not allow for correct decryption\" );\n        if( use_ret == -(MBEDTLS_ERR_PK_INVALID_PUBKEY) )\n            mbedtls_snprintf( buf, buflen, \"PK - The pubkey tag or value is invalid (only RSA and EC are supported)\" );\n        if( use_ret == -(MBEDTLS_ERR_PK_INVALID_ALG) )\n            mbedtls_snprintf( buf, buflen, \"PK - The algorithm tag or value is invalid\" );\n        if( use_ret == -(MBEDTLS_ERR_PK_UNKNOWN_NAMED_CURVE) )\n            mbedtls_snprintf( buf, buflen, \"PK - Elliptic curve is unsupported (only NIST curves are supported)\" );\n        if( use_ret == -(MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE) )\n            mbedtls_snprintf( buf, buflen, \"PK - Unavailable feature, e.g. RSA disabled for RSA key\" );\n        if( use_ret == -(MBEDTLS_ERR_PK_SIG_LEN_MISMATCH) )\n            mbedtls_snprintf( buf, buflen, \"PK - The signature is valid but its length is less than expected\" );\n#endif /* MBEDTLS_PK_C */\n\n#if defined(MBEDTLS_PKCS12_C)\n        if( use_ret == -(MBEDTLS_ERR_PKCS12_BAD_INPUT_DATA) )\n            mbedtls_snprintf( buf, buflen, \"PKCS12 - Bad input parameters to function\" );\n        if( use_ret == -(MBEDTLS_ERR_PKCS12_FEATURE_UNAVAILABLE) )\n            mbedtls_snprintf( buf, buflen, \"PKCS12 - Feature not available, e.g. unsupported encryption scheme\" );\n        if( use_ret == -(MBEDTLS_ERR_PKCS12_PBE_INVALID_FORMAT) )\n            mbedtls_snprintf( buf, buflen, \"PKCS12 - PBE ASN.1 data not as expected\" );\n        if( use_ret == -(MBEDTLS_ERR_PKCS12_PASSWORD_MISMATCH) )\n            mbedtls_snprintf( buf, buflen, \"PKCS12 - Given private key password does not allow for correct decryption\" );\n#endif /* MBEDTLS_PKCS12_C */\n\n#if defined(MBEDTLS_PKCS5_C)\n        if( use_ret == -(MBEDTLS_ERR_PKCS5_BAD_INPUT_DATA) )\n            mbedtls_snprintf( buf, buflen, \"PKCS5 - Bad input parameters to function\" );\n        if( use_ret == -(MBEDTLS_ERR_PKCS5_INVALID_FORMAT) )\n            mbedtls_snprintf( buf, buflen, \"PKCS5 - Unexpected ASN.1 data\" );\n        if( use_ret == -(MBEDTLS_ERR_PKCS5_FEATURE_UNAVAILABLE) )\n            mbedtls_snprintf( buf, buflen, \"PKCS5 - Requested encryption or digest alg not available\" );\n        if( use_ret == -(MBEDTLS_ERR_PKCS5_PASSWORD_MISMATCH) )\n            mbedtls_snprintf( buf, buflen, \"PKCS5 - Given private key password does not allow for correct decryption\" );\n#endif /* MBEDTLS_PKCS5_C */\n\n#if defined(MBEDTLS_RSA_C)\n        if( use_ret == -(MBEDTLS_ERR_RSA_BAD_INPUT_DATA) )\n            mbedtls_snprintf( buf, buflen, \"RSA - Bad input parameters to function\" );\n        if( use_ret == -(MBEDTLS_ERR_RSA_INVALID_PADDING) )\n            mbedtls_snprintf( buf, buflen, \"RSA - Input data contains invalid padding and is rejected\" );\n        if( use_ret == -(MBEDTLS_ERR_RSA_KEY_GEN_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"RSA - Something failed during generation of a key\" );\n        if( use_ret == -(MBEDTLS_ERR_RSA_KEY_CHECK_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"RSA - Key failed to pass the library's validity check\" );\n        if( use_ret == -(MBEDTLS_ERR_RSA_PUBLIC_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"RSA - The public key operation failed\" );\n        if( use_ret == -(MBEDTLS_ERR_RSA_PRIVATE_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"RSA - The private key operation failed\" );\n        if( use_ret == -(MBEDTLS_ERR_RSA_VERIFY_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"RSA - The PKCS#1 verification failed\" );\n        if( use_ret == -(MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE) )\n            mbedtls_snprintf( buf, buflen, \"RSA - The output buffer for decryption is not large enough\" );\n        if( use_ret == -(MBEDTLS_ERR_RSA_RNG_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"RSA - The random generator failed to generate non-zeros\" );\n#endif /* MBEDTLS_RSA_C */\n\n#if defined(MBEDTLS_SSL_TLS_C)\n        if( use_ret == -(MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE) )\n            mbedtls_snprintf( buf, buflen, \"SSL - The requested feature is not available\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_INPUT_DATA) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Bad input parameters to function\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_INVALID_MAC) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Verification of the message MAC failed\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_INVALID_RECORD) )\n            mbedtls_snprintf( buf, buflen, \"SSL - An invalid SSL record was received\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_CONN_EOF) )\n            mbedtls_snprintf( buf, buflen, \"SSL - The connection indicated an EOF\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_UNKNOWN_CIPHER) )\n            mbedtls_snprintf( buf, buflen, \"SSL - An unknown cipher was received\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_NO_CIPHER_CHOSEN) )\n            mbedtls_snprintf( buf, buflen, \"SSL - The server has no ciphersuites in common with the client\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_NO_RNG) )\n            mbedtls_snprintf( buf, buflen, \"SSL - No RNG was provided to the SSL module\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_NO_CLIENT_CERTIFICATE) )\n            mbedtls_snprintf( buf, buflen, \"SSL - No client certification received from the client, but required by the authentication mode\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_CERTIFICATE_TOO_LARGE) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Our own certificate(s) is/are too large to send in an SSL message\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_CERTIFICATE_REQUIRED) )\n            mbedtls_snprintf( buf, buflen, \"SSL - The own certificate is not set, but needed by the server\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED) )\n            mbedtls_snprintf( buf, buflen, \"SSL - The own private key or pre-shared key is not set, but needed\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_CA_CHAIN_REQUIRED) )\n            mbedtls_snprintf( buf, buflen, \"SSL - No CA Chain is set, but required to operate\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE) )\n            mbedtls_snprintf( buf, buflen, \"SSL - An unexpected message was received from our peer\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_FATAL_ALERT_MESSAGE) )\n        {\n            mbedtls_snprintf( buf, buflen, \"SSL - A fatal alert message was received from our peer\" );\n            return;\n        }\n        if( use_ret == -(MBEDTLS_ERR_SSL_PEER_VERIFY_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Verification of our peer failed\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_PEER_CLOSE_NOTIFY) )\n            mbedtls_snprintf( buf, buflen, \"SSL - The peer notified us that the connection is going to be closed\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Processing of the ClientHello handshake message failed\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Processing of the ServerHello handshake message failed\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Processing of the Certificate handshake message failed\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_REQUEST) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Processing of the CertificateRequest handshake message failed\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Processing of the ServerKeyExchange handshake message failed\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO_DONE) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Processing of the ServerHelloDone handshake message failed\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Processing of the ClientKeyExchange handshake message failed\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE_RP) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Processing of the ClientKeyExchange handshake message failed in DHM / ECDH Read Public\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE_CS) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Processing of the ClientKeyExchange handshake message failed in DHM / ECDH Calculate Secret\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_VERIFY) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Processing of the CertificateVerify handshake message failed\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_CHANGE_CIPHER_SPEC) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Processing of the ChangeCipherSpec handshake message failed\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_FINISHED) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Processing of the Finished handshake message failed\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_ALLOC_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Memory allocation failed\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_HW_ACCEL_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Hardware acceleration function returned with error\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_HW_ACCEL_FALLTHROUGH) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Hardware acceleration function skipped / left alone data\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_COMPRESSION_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Processing of the compression / decompression failed\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_PROTOCOL_VERSION) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Handshake protocol not within min/max boundaries\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_BAD_HS_NEW_SESSION_TICKET) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Processing of the NewSessionTicket handshake message failed\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_SESSION_TICKET_EXPIRED) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Session ticket has expired\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_PK_TYPE_MISMATCH) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Public key type mismatch (eg, asked for RSA key exchange and presented EC key)\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Unknown identity received (eg, PSK identity)\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_INTERNAL_ERROR) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Internal error (eg, unexpected failure in lower-level module)\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_COUNTER_WRAPPING) )\n            mbedtls_snprintf( buf, buflen, \"SSL - A counter would wrap (eg, too many messages exchanged)\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_WAITING_SERVER_HELLO_RENEGO) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Unexpected message at ServerHello in renegotiation\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED) )\n            mbedtls_snprintf( buf, buflen, \"SSL - DTLS client must retry for hello verification\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL) )\n            mbedtls_snprintf( buf, buflen, \"SSL - A buffer is too small to receive or write a message\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_NO_USABLE_CIPHERSUITE) )\n            mbedtls_snprintf( buf, buflen, \"SSL - None of the common ciphersuites is usable (eg, no suitable certificate, see debug messages)\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_WANT_READ) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Connection requires a read call\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_WANT_WRITE) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Connection requires a write call\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_TIMEOUT) )\n            mbedtls_snprintf( buf, buflen, \"SSL - The operation timed out\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_CLIENT_RECONNECT) )\n            mbedtls_snprintf( buf, buflen, \"SSL - The client initiated a reconnect from the same port\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_UNEXPECTED_RECORD) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Record header looks valid but is not expected\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_NON_FATAL) )\n            mbedtls_snprintf( buf, buflen, \"SSL - The alert message received indicates a non-fatal error\" );\n        if( use_ret == -(MBEDTLS_ERR_SSL_INVALID_VERIFY_HASH) )\n            mbedtls_snprintf( buf, buflen, \"SSL - Couldn't set the hash for verifying CertificateVerify\" );\n#endif /* MBEDTLS_SSL_TLS_C */\n\n#if defined(MBEDTLS_X509_USE_C) || defined(MBEDTLS_X509_CREATE_C)\n        if( use_ret == -(MBEDTLS_ERR_X509_FEATURE_UNAVAILABLE) )\n            mbedtls_snprintf( buf, buflen, \"X509 - Unavailable feature, e.g. RSA hashing/encryption combination\" );\n        if( use_ret == -(MBEDTLS_ERR_X509_UNKNOWN_OID) )\n            mbedtls_snprintf( buf, buflen, \"X509 - Requested OID is unknown\" );\n        if( use_ret == -(MBEDTLS_ERR_X509_INVALID_FORMAT) )\n            mbedtls_snprintf( buf, buflen, \"X509 - The CRT/CRL/CSR format is invalid, e.g. different type expected\" );\n        if( use_ret == -(MBEDTLS_ERR_X509_INVALID_VERSION) )\n            mbedtls_snprintf( buf, buflen, \"X509 - The CRT/CRL/CSR version element is invalid\" );\n        if( use_ret == -(MBEDTLS_ERR_X509_INVALID_SERIAL) )\n            mbedtls_snprintf( buf, buflen, \"X509 - The serial tag or value is invalid\" );\n        if( use_ret == -(MBEDTLS_ERR_X509_INVALID_ALG) )\n            mbedtls_snprintf( buf, buflen, \"X509 - The algorithm tag or value is invalid\" );\n        if( use_ret == -(MBEDTLS_ERR_X509_INVALID_NAME) )\n            mbedtls_snprintf( buf, buflen, \"X509 - The name tag or value is invalid\" );\n        if( use_ret == -(MBEDTLS_ERR_X509_INVALID_DATE) )\n            mbedtls_snprintf( buf, buflen, \"X509 - The date tag or value is invalid\" );\n        if( use_ret == -(MBEDTLS_ERR_X509_INVALID_SIGNATURE) )\n            mbedtls_snprintf( buf, buflen, \"X509 - The signature tag or value invalid\" );\n        if( use_ret == -(MBEDTLS_ERR_X509_INVALID_EXTENSIONS) )\n            mbedtls_snprintf( buf, buflen, \"X509 - The extension tag or value is invalid\" );\n        if( use_ret == -(MBEDTLS_ERR_X509_UNKNOWN_VERSION) )\n            mbedtls_snprintf( buf, buflen, \"X509 - CRT/CRL/CSR has an unsupported version number\" );\n        if( use_ret == -(MBEDTLS_ERR_X509_UNKNOWN_SIG_ALG) )\n            mbedtls_snprintf( buf, buflen, \"X509 - Signature algorithm (oid) is unsupported\" );\n        if( use_ret == -(MBEDTLS_ERR_X509_SIG_MISMATCH) )\n            mbedtls_snprintf( buf, buflen, \"X509 - Signature algorithms do not match. (see \\\\c ::mbedtls_x509_crt sig_oid)\" );\n        if( use_ret == -(MBEDTLS_ERR_X509_CERT_VERIFY_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"X509 - Certificate verification failed, e.g. CRL, CA or signature check failed\" );\n        if( use_ret == -(MBEDTLS_ERR_X509_CERT_UNKNOWN_FORMAT) )\n            mbedtls_snprintf( buf, buflen, \"X509 - Format not recognized as DER or PEM\" );\n        if( use_ret == -(MBEDTLS_ERR_X509_BAD_INPUT_DATA) )\n            mbedtls_snprintf( buf, buflen, \"X509 - Input invalid\" );\n        if( use_ret == -(MBEDTLS_ERR_X509_ALLOC_FAILED) )\n            mbedtls_snprintf( buf, buflen, \"X509 - Allocation of memory failed\" );\n        if( use_ret == -(MBEDTLS_ERR_X509_FILE_IO_ERROR) )\n             mbedtls_snprintf( buf, buflen, \"X509 - Read/write of file failed\" );\n         if( use_ret == -(MBEDTLS_ERR_X509_BUFFER_TOO_SMALL) )\n             mbedtls_snprintf( buf, buflen, \"X509 - Destination buffer is too small\" );\n #endif /* MBEDTLS_X509_USE_C || MBEDTLS_X509_CREATE_C */\n \n        if( strlen( buf ) == 0 )\n            mbedtls_snprintf( buf, buflen, \"UNKNOWN ERROR CODE (%04X)\", use_ret );\n    }\n\n    use_ret = ret & ~0xFF80;\n\n    if( use_ret == 0 )\n        return;\n\n    len = strlen( buf );\n\n    if( len > 0 )\n    {\n        if( buflen - len < 5 )\n            return;\n\n        mbedtls_snprintf( buf + len, buflen - len, \" : \" );\n\n        buf += len + 3;\n        buflen -= len + 3;\n    }\n\n#if defined(MBEDTLS_AES_C)\n    if( use_ret == -(MBEDTLS_ERR_AES_INVALID_KEY_LENGTH) )\n        mbedtls_snprintf( buf, buflen, \"AES - Invalid key length\" );\n    if( use_ret == -(MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH) )\n        mbedtls_snprintf( buf, buflen, \"AES - Invalid data input length\" );\n#endif /* MBEDTLS_AES_C */\n\n#if defined(MBEDTLS_ASN1_PARSE_C)\n    if( use_ret == -(MBEDTLS_ERR_ASN1_OUT_OF_DATA) )\n        mbedtls_snprintf( buf, buflen, \"ASN1 - Out of data when parsing an ASN1 data structure\" );\n    if( use_ret == -(MBEDTLS_ERR_ASN1_UNEXPECTED_TAG) )\n        mbedtls_snprintf( buf, buflen, \"ASN1 - ASN1 tag was of an unexpected value\" );\n    if( use_ret == -(MBEDTLS_ERR_ASN1_INVALID_LENGTH) )\n        mbedtls_snprintf( buf, buflen, \"ASN1 - Error when trying to determine the length or invalid length\" );\n    if( use_ret == -(MBEDTLS_ERR_ASN1_LENGTH_MISMATCH) )\n        mbedtls_snprintf( buf, buflen, \"ASN1 - Actual length differs from expected length\" );\n    if( use_ret == -(MBEDTLS_ERR_ASN1_INVALID_DATA) )\n        mbedtls_snprintf( buf, buflen, \"ASN1 - Data is invalid. (not used)\" );\n    if( use_ret == -(MBEDTLS_ERR_ASN1_ALLOC_FAILED) )\n        mbedtls_snprintf( buf, buflen, \"ASN1 - Memory allocation failed\" );\n    if( use_ret == -(MBEDTLS_ERR_ASN1_BUF_TOO_SMALL) )\n        mbedtls_snprintf( buf, buflen, \"ASN1 - Buffer too small when writing ASN.1 data structure\" );\n#endif /* MBEDTLS_ASN1_PARSE_C */\n\n#if defined(MBEDTLS_BASE64_C)\n    if( use_ret == -(MBEDTLS_ERR_BASE64_BUFFER_TOO_SMALL) )\n        mbedtls_snprintf( buf, buflen, \"BASE64 - Output buffer too small\" );\n    if( use_ret == -(MBEDTLS_ERR_BASE64_INVALID_CHARACTER) )\n        mbedtls_snprintf( buf, buflen, \"BASE64 - Invalid character in input\" );\n#endif /* MBEDTLS_BASE64_C */\n\n#if defined(MBEDTLS_BIGNUM_C)\n    if( use_ret == -(MBEDTLS_ERR_MPI_FILE_IO_ERROR) )\n        mbedtls_snprintf( buf, buflen, \"BIGNUM - An error occurred while reading from or writing to a file\" );\n    if( use_ret == -(MBEDTLS_ERR_MPI_BAD_INPUT_DATA) )\n        mbedtls_snprintf( buf, buflen, \"BIGNUM - Bad input parameters to function\" );\n    if( use_ret == -(MBEDTLS_ERR_MPI_INVALID_CHARACTER) )\n        mbedtls_snprintf( buf, buflen, \"BIGNUM - There is an invalid character in the digit string\" );\n    if( use_ret == -(MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL) )\n        mbedtls_snprintf( buf, buflen, \"BIGNUM - The buffer is too small to write to\" );\n    if( use_ret == -(MBEDTLS_ERR_MPI_NEGATIVE_VALUE) )\n        mbedtls_snprintf( buf, buflen, \"BIGNUM - The input arguments are negative or result in illegal output\" );\n    if( use_ret == -(MBEDTLS_ERR_MPI_DIVISION_BY_ZERO) )\n        mbedtls_snprintf( buf, buflen, \"BIGNUM - The input argument for division is zero, which is not allowed\" );\n    if( use_ret == -(MBEDTLS_ERR_MPI_NOT_ACCEPTABLE) )\n        mbedtls_snprintf( buf, buflen, \"BIGNUM - The input arguments are not acceptable\" );\n    if( use_ret == -(MBEDTLS_ERR_MPI_ALLOC_FAILED) )\n        mbedtls_snprintf( buf, buflen, \"BIGNUM - Memory allocation failed\" );\n#endif /* MBEDTLS_BIGNUM_C */\n\n#if defined(MBEDTLS_BLOWFISH_C)\n    if( use_ret == -(MBEDTLS_ERR_BLOWFISH_INVALID_KEY_LENGTH) )\n        mbedtls_snprintf( buf, buflen, \"BLOWFISH - Invalid key length\" );\n    if( use_ret == -(MBEDTLS_ERR_BLOWFISH_INVALID_INPUT_LENGTH) )\n        mbedtls_snprintf( buf, buflen, \"BLOWFISH - Invalid data input length\" );\n#endif /* MBEDTLS_BLOWFISH_C */\n\n#if defined(MBEDTLS_CAMELLIA_C)\n    if( use_ret == -(MBEDTLS_ERR_CAMELLIA_INVALID_KEY_LENGTH) )\n        mbedtls_snprintf( buf, buflen, \"CAMELLIA - Invalid key length\" );\n    if( use_ret == -(MBEDTLS_ERR_CAMELLIA_INVALID_INPUT_LENGTH) )\n        mbedtls_snprintf( buf, buflen, \"CAMELLIA - Invalid data input length\" );\n#endif /* MBEDTLS_CAMELLIA_C */\n\n#if defined(MBEDTLS_CCM_C)\n    if( use_ret == -(MBEDTLS_ERR_CCM_BAD_INPUT) )\n        mbedtls_snprintf( buf, buflen, \"CCM - Bad input parameters to function\" );\n    if( use_ret == -(MBEDTLS_ERR_CCM_AUTH_FAILED) )\n        mbedtls_snprintf( buf, buflen, \"CCM - Authenticated decryption failed\" );\n#endif /* MBEDTLS_CCM_C */\n\n#if defined(MBEDTLS_CTR_DRBG_C)\n    if( use_ret == -(MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED) )\n        mbedtls_snprintf( buf, buflen, \"CTR_DRBG - The entropy source failed\" );\n    if( use_ret == -(MBEDTLS_ERR_CTR_DRBG_REQUEST_TOO_BIG) )\n        mbedtls_snprintf( buf, buflen, \"CTR_DRBG - Too many random requested in single call\" );\n    if( use_ret == -(MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG) )\n        mbedtls_snprintf( buf, buflen, \"CTR_DRBG - Input too large (Entropy + additional)\" );\n    if( use_ret == -(MBEDTLS_ERR_CTR_DRBG_FILE_IO_ERROR) )\n        mbedtls_snprintf( buf, buflen, \"CTR_DRBG - Read/write error in file\" );\n#endif /* MBEDTLS_CTR_DRBG_C */\n\n#if defined(MBEDTLS_DES_C)\n    if( use_ret == -(MBEDTLS_ERR_DES_INVALID_INPUT_LENGTH) )\n        mbedtls_snprintf( buf, buflen, \"DES - The data input has an invalid length\" );\n#endif /* MBEDTLS_DES_C */\n\n#if defined(MBEDTLS_ENTROPY_C)\n    if( use_ret == -(MBEDTLS_ERR_ENTROPY_SOURCE_FAILED) )\n        mbedtls_snprintf( buf, buflen, \"ENTROPY - Critical entropy source failure\" );\n    if( use_ret == -(MBEDTLS_ERR_ENTROPY_MAX_SOURCES) )\n        mbedtls_snprintf( buf, buflen, \"ENTROPY - No more sources can be added\" );\n    if( use_ret == -(MBEDTLS_ERR_ENTROPY_NO_SOURCES_DEFINED) )\n        mbedtls_snprintf( buf, buflen, \"ENTROPY - No sources have been added to poll\" );\n    if( use_ret == -(MBEDTLS_ERR_ENTROPY_NO_STRONG_SOURCE) )\n        mbedtls_snprintf( buf, buflen, \"ENTROPY - No strong sources have been added to poll\" );\n    if( use_ret == -(MBEDTLS_ERR_ENTROPY_FILE_IO_ERROR) )\n        mbedtls_snprintf( buf, buflen, \"ENTROPY - Read/write error in file\" );\n#endif /* MBEDTLS_ENTROPY_C */\n\n#if defined(MBEDTLS_GCM_C)\n    if( use_ret == -(MBEDTLS_ERR_GCM_AUTH_FAILED) )\n        mbedtls_snprintf( buf, buflen, \"GCM - Authenticated decryption failed\" );\n    if( use_ret == -(MBEDTLS_ERR_GCM_BAD_INPUT) )\n        mbedtls_snprintf( buf, buflen, \"GCM - Bad input parameters to function\" );\n#endif /* MBEDTLS_GCM_C */\n\n#if defined(MBEDTLS_HMAC_DRBG_C)\n    if( use_ret == -(MBEDTLS_ERR_HMAC_DRBG_REQUEST_TOO_BIG) )\n        mbedtls_snprintf( buf, buflen, \"HMAC_DRBG - Too many random requested in single call\" );\n    if( use_ret == -(MBEDTLS_ERR_HMAC_DRBG_INPUT_TOO_BIG) )\n        mbedtls_snprintf( buf, buflen, \"HMAC_DRBG - Input too large (Entropy + additional)\" );\n    if( use_ret == -(MBEDTLS_ERR_HMAC_DRBG_FILE_IO_ERROR) )\n        mbedtls_snprintf( buf, buflen, \"HMAC_DRBG - Read/write error in file\" );\n    if( use_ret == -(MBEDTLS_ERR_HMAC_DRBG_ENTROPY_SOURCE_FAILED) )\n        mbedtls_snprintf( buf, buflen, \"HMAC_DRBG - The entropy source failed\" );\n#endif /* MBEDTLS_HMAC_DRBG_C */\n\n#if defined(MBEDTLS_NET_C)\n    if( use_ret == -(MBEDTLS_ERR_NET_SOCKET_FAILED) )\n        mbedtls_snprintf( buf, buflen, \"NET - Failed to open a socket\" );\n    if( use_ret == -(MBEDTLS_ERR_NET_CONNECT_FAILED) )\n        mbedtls_snprintf( buf, buflen, \"NET - The connection to the given server / port failed\" );\n    if( use_ret == -(MBEDTLS_ERR_NET_BIND_FAILED) )\n        mbedtls_snprintf( buf, buflen, \"NET - Binding of the socket failed\" );\n    if( use_ret == -(MBEDTLS_ERR_NET_LISTEN_FAILED) )\n        mbedtls_snprintf( buf, buflen, \"NET - Could not listen on the socket\" );\n    if( use_ret == -(MBEDTLS_ERR_NET_ACCEPT_FAILED) )\n        mbedtls_snprintf( buf, buflen, \"NET - Could not accept the incoming connection\" );\n    if( use_ret == -(MBEDTLS_ERR_NET_RECV_FAILED) )\n        mbedtls_snprintf( buf, buflen, \"NET - Reading information from the socket failed\" );\n    if( use_ret == -(MBEDTLS_ERR_NET_SEND_FAILED) )\n        mbedtls_snprintf( buf, buflen, \"NET - Sending information through the socket failed\" );\n    if( use_ret == -(MBEDTLS_ERR_NET_CONN_RESET) )\n        mbedtls_snprintf( buf, buflen, \"NET - Connection was reset by peer\" );\n    if( use_ret == -(MBEDTLS_ERR_NET_UNKNOWN_HOST) )\n        mbedtls_snprintf( buf, buflen, \"NET - Failed to get an IP address for the given hostname\" );\n    if( use_ret == -(MBEDTLS_ERR_NET_BUFFER_TOO_SMALL) )\n        mbedtls_snprintf( buf, buflen, \"NET - Buffer is too small to hold the data\" );\n    if( use_ret == -(MBEDTLS_ERR_NET_INVALID_CONTEXT) )\n        mbedtls_snprintf( buf, buflen, \"NET - The context is invalid, eg because it was free()ed\" );\n#endif /* MBEDTLS_NET_C */\n\n#if defined(MBEDTLS_OID_C)\n    if( use_ret == -(MBEDTLS_ERR_OID_NOT_FOUND) )\n        mbedtls_snprintf( buf, buflen, \"OID - OID is not found\" );\n    if( use_ret == -(MBEDTLS_ERR_OID_BUF_TOO_SMALL) )\n        mbedtls_snprintf( buf, buflen, \"OID - output buffer is too small\" );\n#endif /* MBEDTLS_OID_C */\n\n#if defined(MBEDTLS_PADLOCK_C)\n    if( use_ret == -(MBEDTLS_ERR_PADLOCK_DATA_MISALIGNED) )\n        mbedtls_snprintf( buf, buflen, \"PADLOCK - Input data should be aligned\" );\n#endif /* MBEDTLS_PADLOCK_C */\n\n#if defined(MBEDTLS_THREADING_C)\n    if( use_ret == -(MBEDTLS_ERR_THREADING_FEATURE_UNAVAILABLE) )\n        mbedtls_snprintf( buf, buflen, \"THREADING - The selected feature is not available\" );\n    if( use_ret == -(MBEDTLS_ERR_THREADING_BAD_INPUT_DATA) )\n        mbedtls_snprintf( buf, buflen, \"THREADING - Bad input parameters to function\" );\n    if( use_ret == -(MBEDTLS_ERR_THREADING_MUTEX_ERROR) )\n        mbedtls_snprintf( buf, buflen, \"THREADING - Locking / unlocking / free failed with error code\" );\n#endif /* MBEDTLS_THREADING_C */\n\n#if defined(MBEDTLS_XTEA_C)\n    if( use_ret == -(MBEDTLS_ERR_XTEA_INVALID_INPUT_LENGTH) )\n        mbedtls_snprintf( buf, buflen, \"XTEA - The data input has an invalid length\" );\n#endif /* MBEDTLS_XTEA_C */\n\n    if( strlen( buf ) != 0 )\n        return;\n\n    mbedtls_snprintf( buf, buflen, \"UNKNOWN ERROR CODE (%04X)\", use_ret );\n}\n", "target": 1, "idx": 183190}
{"func": "ImageBitmapFactories::ImageBitmapLoader::ImageBitmapLoader(ImageBitmapFactories& factory, PassRefPtr<ScriptPromiseResolver> resolver, const IntRect& cropRect)\n    : m_scriptState(ScriptState::current())\n    , m_loader(FileReaderLoader::ReadAsArrayBuffer, this)\n    , m_factory(&factory)\n    , m_resolver(resolver)\n    , m_cropRect(cropRect)\n{\n}\n", "target": 0, "idx": 123451}
{"func": "void GfxPatternColorSpace::getGray(GfxColor *color, GfxGray *gray) {\n  *gray = 0;\n}\n", "target": 0, "idx": 1054}
{"func": "void ntlm_write_message_fields_buffer(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n {\n \tif (fields->Len > 0)\n \t{\n\t\tStream_SetPosition(s, fields->BufferOffset);\n\t\tStream_Write(s, fields->Buffer, fields->Len);\n \t}\n }\n", "target": 1, "idx": 182452}
{"func": "  ImageTransportClientTexture(\n      WebKit::WebGraphicsContext3D* host_context,\n      const gfx::Size& size,\n      float device_scale_factor,\n      uint64 surface_id)\n          : ui::Texture(true, size, device_scale_factor),\n            host_context_(host_context),\n            texture_id_(surface_id) {\n  }\n", "target": 1, "idx": 185060}
{"func": "int ParseWave64HeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)\n{\n    int64_t total_samples = 0, infilesize;\n    Wave64ChunkHeader chunk_header;\n    Wave64FileHeader filehdr;\n    WaveHeader WaveHeader;\n     int format_chunk = 0;\n     uint32_t bcount;\n \n     infilesize = DoGetFileSize (infile);\n     memcpy (&filehdr, fourcc, 4);\n \n    if (!DoReadFile (infile, ((char *) &filehdr) + 4, sizeof (Wave64FileHeader) - 4, &bcount) ||\n        bcount != sizeof (Wave64FileHeader) - 4 || memcmp (filehdr.ckID, riff_guid, sizeof (riff_guid)) ||\n        memcmp (filehdr.formType, wave_guid, sizeof (wave_guid))) {\n            error_line (\"%s is not a valid .W64 file!\", infilename);\n            return WAVPACK_SOFT_ERROR;\n    }\n    else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n        !WavpackAddWrapper (wpc, &filehdr, sizeof (filehdr))) {\n            error_line (\"%s\", WavpackGetErrorMessage (wpc));\n            return WAVPACK_SOFT_ERROR;\n    }\n\n#if 1   // this might be a little too picky...\n    WavpackLittleEndianToNative (&filehdr, Wave64ChunkHeaderFormat);\n\n    if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) &&\n        filehdr.ckSize && filehdr.ckSize + 1 && filehdr.ckSize != infilesize) {\n            error_line (\"%s is not a valid .W64 file!\", infilename);\n            return WAVPACK_SOFT_ERROR;\n    }\n#endif\n\n\n    while (1) {\n        if (!DoReadFile (infile, &chunk_header, sizeof (Wave64ChunkHeader), &bcount) ||\n            bcount != sizeof (Wave64ChunkHeader)) {\n                error_line (\"%s is not a valid .W64 file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n        }\n        else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n            !WavpackAddWrapper (wpc, &chunk_header, sizeof (Wave64ChunkHeader))) {\n                error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                return WAVPACK_SOFT_ERROR;\n        }\n\n        WavpackLittleEndianToNative (&chunk_header, Wave64ChunkHeaderFormat);\n        chunk_header.ckSize -= sizeof (chunk_header);\n\n\n        if (!memcmp (chunk_header.ckID, fmt_guid, sizeof (fmt_guid))) {\n            int supported = TRUE, format;\n\n            if (format_chunk++) {\n                error_line (\"%s is not a valid .W64 file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            chunk_header.ckSize = (chunk_header.ckSize + 7) & ~7L;\n\n            if (chunk_header.ckSize < 16 || chunk_header.ckSize > sizeof (WaveHeader) ||\n                !DoReadFile (infile, &WaveHeader, (uint32_t) chunk_header.ckSize, &bcount) ||\n                bcount != chunk_header.ckSize) {\n                    error_line (\"%s is not a valid .W64 file!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, &WaveHeader, (uint32_t) chunk_header.ckSize)) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            WavpackLittleEndianToNative (&WaveHeader, WaveHeaderFormat);\n\n            if (debug_logging_mode) {\n                error_line (\"format tag size = %d\", chunk_header.ckSize);\n                error_line (\"FormatTag = %x, NumChannels = %d, BitsPerSample = %d\",\n                    WaveHeader.FormatTag, WaveHeader.NumChannels, WaveHeader.BitsPerSample);\n                error_line (\"BlockAlign = %d, SampleRate = %d, BytesPerSecond = %d\",\n                    WaveHeader.BlockAlign, WaveHeader.SampleRate, WaveHeader.BytesPerSecond);\n\n                if (chunk_header.ckSize > 16)\n                    error_line (\"cbSize = %d, ValidBitsPerSample = %d\", WaveHeader.cbSize,\n                        WaveHeader.ValidBitsPerSample);\n\n                if (chunk_header.ckSize > 20)\n                    error_line (\"ChannelMask = %x, SubFormat = %d\",\n                        WaveHeader.ChannelMask, WaveHeader.SubFormat);\n            }\n\n            if (chunk_header.ckSize > 16 && WaveHeader.cbSize == 2)\n                config->qmode |= QMODE_ADOBE_MODE;\n\n            format = (WaveHeader.FormatTag == 0xfffe && chunk_header.ckSize == 40) ?\n                WaveHeader.SubFormat : WaveHeader.FormatTag;\n\n            config->bits_per_sample = (chunk_header.ckSize == 40 && WaveHeader.ValidBitsPerSample) ?\n                WaveHeader.ValidBitsPerSample : WaveHeader.BitsPerSample;\n\n            if (format != 1 && format != 3)\n                supported = FALSE;\n\n            if (format == 3 && config->bits_per_sample != 32)\n                supported = FALSE;\n\n            if (!WaveHeader.NumChannels || WaveHeader.NumChannels > 256 ||\n                WaveHeader.BlockAlign / WaveHeader.NumChannels < (config->bits_per_sample + 7) / 8 ||\n                WaveHeader.BlockAlign / WaveHeader.NumChannels > 4 ||\n                WaveHeader.BlockAlign % WaveHeader.NumChannels)\n                    supported = FALSE;\n\n            if (config->bits_per_sample < 1 || config->bits_per_sample > 32)\n                supported = FALSE;\n\n            if (!supported) {\n                error_line (\"%s is an unsupported .W64 format!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            if (chunk_header.ckSize < 40) {\n                if (!config->channel_mask && !(config->qmode & QMODE_CHANS_UNASSIGNED)) {\n                    if (WaveHeader.NumChannels <= 2)\n                        config->channel_mask = 0x5 - WaveHeader.NumChannels;\n                    else if (WaveHeader.NumChannels <= 18)\n                        config->channel_mask = (1 << WaveHeader.NumChannels) - 1;\n                    else\n                        config->channel_mask = 0x3ffff;\n                }\n            }\n            else if (WaveHeader.ChannelMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) {\n                error_line (\"this W64 file already has channel order information!\");\n                return WAVPACK_SOFT_ERROR;\n            }\n            else if (WaveHeader.ChannelMask)\n                config->channel_mask = WaveHeader.ChannelMask;\n\n            if (format == 3)\n                config->float_norm_exp = 127;\n            else if ((config->qmode & QMODE_ADOBE_MODE) &&\n                WaveHeader.BlockAlign / WaveHeader.NumChannels == 4) {\n                    if (WaveHeader.BitsPerSample == 24)\n                        config->float_norm_exp = 127 + 23;\n                    else if (WaveHeader.BitsPerSample == 32)\n                        config->float_norm_exp = 127 + 15;\n            }\n\n            if (debug_logging_mode) {\n                if (config->float_norm_exp == 127)\n                    error_line (\"data format: normalized 32-bit floating point\");\n                else\n                    error_line (\"data format: %d-bit integers stored in %d byte(s)\",\n                        config->bits_per_sample, WaveHeader.BlockAlign / WaveHeader.NumChannels);\n            }\n        }\n        else if (!memcmp (chunk_header.ckID, data_guid, sizeof (data_guid))) { // on the data chunk, get size and exit loop\n\n            if (!WaveHeader.NumChannels) {          // make sure we saw \"fmt\" chunk\n                error_line (\"%s is not a valid .W64 file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            if ((config->qmode & QMODE_IGNORE_LENGTH) || chunk_header.ckSize <= 0) {\n                config->qmode |= QMODE_IGNORE_LENGTH;\n\n                if (infilesize && DoGetFilePosition (infile) != -1)\n                    total_samples = (infilesize - DoGetFilePosition (infile)) / WaveHeader.BlockAlign;\n                else\n                    total_samples = -1;\n            }\n            else {\n                if (infilesize && infilesize - chunk_header.ckSize > 16777216) {\n                    error_line (\"this .W64 file has over 16 MB of extra RIFF data, probably is corrupt!\");\n                    return WAVPACK_SOFT_ERROR;\n                }\n\n                total_samples = chunk_header.ckSize / WaveHeader.BlockAlign;\n\n                if (!total_samples) {\n                    error_line (\"this .W64 file has no audio samples, probably is corrupt!\");\n                    return WAVPACK_SOFT_ERROR;\n                }\n\n                if (total_samples > MAX_WAVPACK_SAMPLES) {\n                    error_line (\"%s has too many samples for WavPack!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n                }\n            }\n\n            config->bytes_per_sample = WaveHeader.BlockAlign / WaveHeader.NumChannels;\n            config->num_channels = WaveHeader.NumChannels;\n            config->sample_rate = WaveHeader.SampleRate;\n            break;\n        }\n        else {          // just copy unknown chunks to output file\n            int bytes_to_copy = (chunk_header.ckSize + 7) & ~7L;\n            char *buff;\n\n            if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {\n                error_line (\"%s is not a valid .W64 file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            buff = malloc (bytes_to_copy);\n\n            if (debug_logging_mode)\n                error_line (\"extra unknown chunk \\\"%c%c%c%c\\\" of %d bytes\",\n                    chunk_header.ckID [0], chunk_header.ckID [1], chunk_header.ckID [2],\n                    chunk_header.ckID [3], chunk_header.ckSize);\n\n            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||\n                bcount != bytes_to_copy ||\n                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    free (buff);\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            free (buff);\n        }\n    }\n\n    if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) {\n        error_line (\"%s: %s\", infilename, WavpackGetErrorMessage (wpc));\n        return WAVPACK_SOFT_ERROR;\n    }\n\n    return WAVPACK_NO_ERROR;\n}\n", "target": 1, "idx": 182633}
{"func": "static int sco_sock_getsockopt_old(struct socket *sock, int optname, char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sco_options opts;\n\tstruct sco_conninfo cinfo;\n\tint len, err = 0;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase SCO_OPTIONS:\n\t\tif (sk->sk_state != BT_CONNECTED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tbreak;\n\t\t}\n\n\t\topts.mtu = sco_pi(sk)->conn->mtu;\n\n\t\tBT_DBG(\"mtu %d\", opts.mtu);\n\n\t\tlen = min_t(unsigned int, len, sizeof(opts));\n\t\tif (copy_to_user(optval, (char *)&opts, len))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase SCO_CONNINFO:\n\t\tif (sk->sk_state != BT_CONNECTED) {\n\t\t\terr = -ENOTCONN;\n \t\t\tbreak;\n \t\t}\n \n \t\tcinfo.hci_handle = sco_pi(sk)->conn->hcon->handle;\n \t\tmemcpy(cinfo.dev_class, sco_pi(sk)->conn->hcon->dev_class, 3);\n \n\t\tlen = min_t(unsigned int, len, sizeof(cinfo));\n\t\tif (copy_to_user(optval, (char *)&cinfo, len))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n", "target": 1, "idx": 179070}
{"func": "int uinput_create(char *name)\n{\n struct uinput_dev dev;\n int fd, x = 0;\n\n \n     for(x=0; x < MAX_UINPUT_PATHS; x++)\n     {\n        fd = open(uinput_dev_path[x], O_RDWR);\n         if (fd < 0)\n             continue;\n         break;\n }\n if (x == MAX_UINPUT_PATHS) {\n        BTIF_TRACE_ERROR(\"%s ERROR: uinput device open failed\", __FUNCTION__);\n return -1;\n }\n    memset(&dev, 0, sizeof(dev));\n if (name)\n        strncpy(dev.name, name, UINPUT_MAX_NAME_SIZE-1);\n\n    dev.id.bustype = BUS_BLUETOOTH;\n    dev.id.vendor  = 0x0000;\n\n     dev.id.product = 0x0000;\n     dev.id.version = 0x0000;\n \n    if (write(fd, &dev, sizeof(dev)) < 0) {\n         BTIF_TRACE_ERROR(\"%s Unable to write device information\", __FUNCTION__);\n         close(fd);\n         return -1;\n     }\n \n    ioctl(fd, UI_SET_EVBIT, EV_KEY);\n    ioctl(fd, UI_SET_EVBIT, EV_REL);\n    ioctl(fd, UI_SET_EVBIT, EV_SYN);\n \n     for (x = 0; key_map[x].name != NULL; x++)\n        ioctl(fd, UI_SET_KEYBIT, key_map[x].mapped_id);\n \n    if (ioctl(fd, UI_DEV_CREATE, NULL) < 0) {\n         BTIF_TRACE_ERROR(\"%s Unable to create uinput device\", __FUNCTION__);\n         close(fd);\n         return -1;\n }\n return fd;\n}\n", "target": 1, "idx": 187474}
{"func": "FrameBuffer::FrameBuffer(GLES2DecoderImpl* decoder)\n    : decoder_(decoder),\n      id_(0) {\n}\n", "target": 0, "idx": 104074}
{"func": "image_pixel_add_alpha(image_pixel *this, PNG_CONST standard_display *display)\n {\n    if (this->colour_type == PNG_COLOR_TYPE_PALETTE)\n       image_pixel_convert_PLTE(this);\n\n if ((this->colour_type & PNG_COLOR_MASK_ALPHA) == 0)\n\n    {\n       if (this->colour_type == PNG_COLOR_TYPE_GRAY)\n       {\n         if (this->bit_depth < 8)\n            this->bit_depth = 8;\n \n          if (this->have_tRNS)\n          {\n             this->have_tRNS = 0;\n \n             /* Check the input, original, channel value here against the\n             * original tRNS gray chunk valie.\n             */\n if (this->red == display->transparent.red)\n this->alphaf = 0;\n else\n this->alphaf = 1;\n }\n else\n this->alphaf = 1;\n\n this->colour_type = PNG_COLOR_TYPE_GRAY_ALPHA;\n }\n\n else if (this->colour_type == PNG_COLOR_TYPE_RGB)\n {\n if (this->have_tRNS)\n {\n this->have_tRNS = 0;\n\n /* Again, check the exact input values, not the current transformed\n             * value!\n             */\n if (this->red == display->transparent.red &&\n this->green == display->transparent.green &&\n this->blue == display->transparent.blue)\n\n                this->alphaf = 0;\n             else\n                this->alphaf = 1;\n            this->colour_type = PNG_COLOR_TYPE_RGB_ALPHA;\n          }\n       }\n \n       /* The error in the alpha is zero and the sBIT value comes from the\n       * original sBIT data (actually it will always be the original bit depth).\n       */\n this->alphae = 0;\n\n       this->alpha_sBIT = display->alpha_sBIT;\n    }\n }\n", "target": 1, "idx": 187638}
{"func": "static void xfrm6_tunnel_destroy(struct xfrm_state *x)\n{\n\txfrm6_tunnel_free_spi((xfrm_address_t *)&x->props.saddr);\n}\n", "target": 0, "idx": 20910}
{"func": "static int vhost_net_open(struct inode *inode, struct file *f)\n{\n\tstruct vhost_net *n = kmalloc(sizeof *n, GFP_KERNEL);\n\tstruct vhost_dev *dev;\n\tstruct vhost_virtqueue **vqs;\n\tint i;\n\n\tif (!n)\n\t\treturn -ENOMEM;\n\tvqs = kmalloc(VHOST_NET_VQ_MAX * sizeof(*vqs), GFP_KERNEL);\n\tif (!vqs) {\n\t\tkfree(n);\n\t\treturn -ENOMEM;\n\t}\n\n\tdev = &n->dev;\n\tvqs[VHOST_NET_VQ_TX] = &n->vqs[VHOST_NET_VQ_TX].vq;\n\tvqs[VHOST_NET_VQ_RX] = &n->vqs[VHOST_NET_VQ_RX].vq;\n\tn->vqs[VHOST_NET_VQ_TX].vq.handle_kick = handle_tx_kick;\n\tn->vqs[VHOST_NET_VQ_RX].vq.handle_kick = handle_rx_kick;\n\tfor (i = 0; i < VHOST_NET_VQ_MAX; i++) {\n\t\tn->vqs[i].ubufs = NULL;\n\t\tn->vqs[i].ubuf_info = NULL;\n\t\tn->vqs[i].upend_idx = 0;\n\t\tn->vqs[i].done_idx = 0;\n\t\tn->vqs[i].vhost_hlen = 0;\n\t\tn->vqs[i].sock_hlen = 0;\n\t}\n\tvhost_dev_init(dev, vqs, VHOST_NET_VQ_MAX);\n\n\tvhost_poll_init(n->poll + VHOST_NET_VQ_TX, handle_tx_net, POLLOUT, dev);\n\tvhost_poll_init(n->poll + VHOST_NET_VQ_RX, handle_rx_net, POLLIN, dev);\n\n\tf->private_data = n;\n\n\treturn 0;\n}\n", "target": 0, "idx": 39949}
{"func": " void WebstoreStandaloneInstaller::OnWebstoreResponseParseSuccess(\n    std::unique_ptr<base::DictionaryValue> webstore_data) {\n  OnWebStoreDataFetcherDone();\n\n  if (!CheckRequestorAlive()) {\n    CompleteInstall(webstore_install::ABORTED, std::string());\n    return;\n  }\n\n  std::string error;\n\n  if (!CheckInlineInstallPermitted(*webstore_data, &error)) {\n    CompleteInstall(webstore_install::NOT_PERMITTED, error);\n    return;\n  }\n\n  if (!CheckRequestorPermitted(*webstore_data, &error)) {\n    CompleteInstall(webstore_install::NOT_PERMITTED, error);\n    return;\n  }\n\n  std::string manifest;\n  if (!webstore_data->GetString(kManifestKey, &manifest) ||\n      !webstore_data->GetString(kUsersKey, &localized_user_count_) ||\n       !webstore_data->GetDouble(kAverageRatingKey, &average_rating_) ||\n       !webstore_data->GetInteger(kRatingCountKey, &rating_count_)) {\n     CompleteInstall(webstore_install::INVALID_WEBSTORE_RESPONSE,\n                    kInvalidWebstoreResponseError);\n     return;\n   }\n \n  show_user_count_ = true;\n  webstore_data->GetBoolean(kShowUserCountKey, &show_user_count_);\n\n   if (average_rating_ < ExtensionInstallPrompt::kMinExtensionRating ||\n       average_rating_ > ExtensionInstallPrompt::kMaxExtensionRating) {\n     CompleteInstall(webstore_install::INVALID_WEBSTORE_RESPONSE,\n                    kInvalidWebstoreResponseError);\n     return;\n   }\n \n  if ((webstore_data->HasKey(kLocalizedNameKey) &&\n      !webstore_data->GetString(kLocalizedNameKey, &localized_name_)) ||\n      (webstore_data->HasKey(kLocalizedDescriptionKey) &&\n       !webstore_data->GetString(\n           kLocalizedDescriptionKey, &localized_description_))) {\n     CompleteInstall(webstore_install::INVALID_WEBSTORE_RESPONSE,\n                    kInvalidWebstoreResponseError);\n     return;\n   }\n \n  GURL icon_url;\n  if (webstore_data->HasKey(kIconUrlKey)) {\n     std::string icon_url_string;\n     if (!webstore_data->GetString(kIconUrlKey, &icon_url_string)) {\n       CompleteInstall(webstore_install::INVALID_WEBSTORE_RESPONSE,\n                      kInvalidWebstoreResponseError);\n       return;\n     }\n     icon_url = GURL(extension_urls::GetWebstoreLaunchURL()).Resolve(\n         icon_url_string);\n     if (!icon_url.is_valid()) {\n       CompleteInstall(webstore_install::INVALID_WEBSTORE_RESPONSE,\n                      kInvalidWebstoreResponseError);\n       return;\n     }\n   }\n\n  webstore_data_ = std::move(webstore_data);\n\n  scoped_refptr<WebstoreInstallHelper> helper =\n      new WebstoreInstallHelper(this,\n                                id_,\n                                manifest,\n                                icon_url,\n                                profile_->GetRequestContext());\n  helper->Start();\n}\n", "target": 1, "idx": 186053}
{"func": "set_machine_vars ()\n{\n  SHELL_VAR *temp_var;\n\n  temp_var = set_if_not (\"HOSTTYPE\", HOSTTYPE);\n  temp_var = set_if_not (\"OSTYPE\", OSTYPE);\n  temp_var = set_if_not (\"MACHTYPE\", MACHTYPE);\n\n  temp_var = set_if_not (\"HOSTNAME\", current_host_name);\n}\n", "target": 0, "idx": 17360}
{"func": "void FetchManager::Loader::PerformNetworkError(const String& message) {\n  Failed(message);\n}\n", "target": 0, "idx": 167271}
{"func": " Node::InsertionNotificationRequest SVGStyleElement::InsertedInto(\n     ContainerNode* insertion_point) {\n   SVGElement::InsertedInto(insertion_point);\n  return kInsertionShouldCallDidNotifySubtreeInsertions;\n}\n", "target": 1, "idx": 187163}
{"func": "static bool ldm_frag_add (const u8 *data, int size, struct list_head *frags)\n{\n\tstruct frag *f;\n\tstruct list_head *item;\n\tint rec, num, group;\n\n\tBUG_ON (!data || !frags);\n\n\tif (size < 2 * VBLK_SIZE_HEAD) {\n\t\tldm_error(\"Value of size is to small.\");\n\t\treturn false;\n\t}\n\n\tgroup = get_unaligned_be32(data + 0x08);\n\trec   = get_unaligned_be16(data + 0x0C);\n\tnum   = get_unaligned_be16(data + 0x0E);\n\tif ((num < 1) || (num > 4)) {\n\t\tldm_error (\"A VBLK claims to have %d parts.\", num);\n\t\treturn false;\n\t}\n\tif (rec >= num) {\n\t\tldm_error(\"REC value (%d) exceeds NUM value (%d)\", rec, num);\n\t\treturn false;\n\t}\n\n\tlist_for_each (item, frags) {\n\t\tf = list_entry (item, struct frag, list);\n\t\tif (f->group == group)\n\t\t\tgoto found;\n\t}\n\n\tf = kmalloc (sizeof (*f) + size*num, GFP_KERNEL);\n\tif (!f) {\n\t\tldm_crit (\"Out of memory.\");\n\t\treturn false;\n\t}\n\n\tf->group = group;\n\tf->num   = num;\n\tf->rec   = rec;\n\tf->map   = 0xFF << num;\n \n \tlist_add_tail (&f->list, frags);\n found:\n \tif (f->map & (1 << rec)) {\n \t\tldm_error (\"Duplicate VBLK, part %d.\", rec);\n \t\tf->map &= 0x7F;\t\t\t/* Mark the group as broken */\n\t\treturn false;\n\t}\n\n\tf->map |= (1 << rec);\n\n\tdata += VBLK_SIZE_HEAD;\n\tsize -= VBLK_SIZE_HEAD;\n\n\tmemcpy (f->data+rec*(size-VBLK_SIZE_HEAD)+VBLK_SIZE_HEAD, data, size);\n\n\treturn true;\n}\n", "target": 1, "idx": 179044}
{"func": "WarmupURLFetcher::WarmupURLFetcher(\n    CreateCustomProxyConfigCallback create_custom_proxy_config_callback,\n    WarmupURLFetcherCallback callback,\n    GetHttpRttCallback get_http_rtt_callback,\n    scoped_refptr<base::SingleThreadTaskRunner> ui_task_runner,\n    const std::string& user_agent)\n    : is_fetch_in_flight_(false),\n      previous_attempt_counts_(0),\n      create_custom_proxy_config_callback_(create_custom_proxy_config_callback),\n      callback_(callback),\n      get_http_rtt_callback_(get_http_rtt_callback),\n       user_agent_(user_agent),\n       ui_task_runner_(ui_task_runner) {\n   DCHECK(create_custom_proxy_config_callback);\n }\n", "target": 1, "idx": 186394}
{"func": "dissect_ac_if_output_terminal(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,\n        proto_tree *tree, usb_conv_info_t *usb_conv_info _U_)\n{\n    gint     offset_start;\n    offset_start = offset;\n\n    proto_tree_add_item(tree, hf_ac_if_output_terminalid, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    proto_tree_add_item(tree, hf_ac_if_output_terminaltype, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n    offset += 2;\n\n    proto_tree_add_item(tree, hf_ac_if_output_assocterminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    proto_tree_add_item(tree, hf_ac_if_output_sourceid, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    proto_tree_add_item(tree, hf_ac_if_output_terminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    return offset-offset_start;\n}\n", "target": 0, "idx": 51802}
{"func": " base::TimeTicks SchedulerHelper::Now() const {\n  return time_source_->Now();\n }\n", "target": 1, "idx": 185497}
{"func": "void ServiceWorkerDevToolsAgentHost::AttachSession(DevToolsSession* session) {\n   if (state_ == WORKER_READY) {\n     if (sessions().size() == 1) {\n       BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,\n                              base::BindOnce(&SetDevToolsAttachedOnIO,\n                                             context_weak_, version_id_, true));\n    }\n    session->SetRenderer(worker_process_id_, nullptr);\n    session->AttachToAgent(agent_ptr_);\n  }\n   session->AddHandler(base::WrapUnique(new protocol::InspectorHandler()));\n   session->AddHandler(base::WrapUnique(new protocol::NetworkHandler(GetId())));\n   session->AddHandler(base::WrapUnique(new protocol::SchemaHandler()));\n }\n", "target": 1, "idx": 187273}
{"func": "static int megasas_handle_dcmd(MegasasState *s, MegasasCmd *cmd)\n{\n    int opcode, len;\n    int retval = 0;\n    const struct dcmd_cmd_tbl_t *cmdptr = dcmd_cmd_tbl;\n\n    opcode = le32_to_cpu(cmd->frame->dcmd.opcode);\n    trace_megasas_handle_dcmd(cmd->index, opcode);\n    len = megasas_map_dcmd(s, cmd);\n    if (len < 0) {\n        return MFI_STAT_MEMORY_NOT_AVAILABLE;\n    }\n    while (cmdptr->opcode != -1 && cmdptr->opcode != opcode) {\n        cmdptr++;\n    }\n    if (cmdptr->opcode == -1) {\n        trace_megasas_dcmd_unhandled(cmd->index, opcode, len);\n        retval = megasas_dcmd_dummy(s, cmd);\n    } else {\n        trace_megasas_dcmd_enter(cmd->index, cmdptr->desc, len);\n        retval = cmdptr->func(s, cmd);\n    }\n    if (retval != MFI_STAT_INVALID_STATUS) {\n        megasas_finish_dcmd(cmd, len);\n    }\n    return retval;\n}\n", "target": 0, "idx": 10451}
{"func": "json_bool lh_table_lookup_ex(struct lh_table* t, const void* k, void **v)\n{\n\tstruct lh_entry *e = lh_table_lookup_entry(t, k);\n\tif (e != NULL) {\n\t\tif (v != NULL) *v = (void *)e->v;\n\t\treturn TRUE; /* key found */\n\t}\n\tif (v != NULL) *v = NULL;\n\treturn FALSE; /* key not found */\n}\n", "target": 0, "idx": 40967}
{"func": "OMX_ERRORTYPE  omx_video::free_buffer(OMX_IN OMX_HANDLETYPE         hComp,\n        OMX_IN OMX_U32                 port,\n        OMX_IN OMX_BUFFERHEADERTYPE* buffer)\n{\n (void)hComp;\n    OMX_ERRORTYPE eRet = OMX_ErrorNone;\n unsigned int nPortIndex;\n\n    DEBUG_PRINT_LOW(\"In for encoder free_buffer\");\n\n if (m_state == OMX_StateIdle &&\n (BITMASK_PRESENT(&m_flags ,OMX_COMPONENT_LOADING_PENDING))) {\n        DEBUG_PRINT_LOW(\" free buffer while Component in Loading pending\");\n } else if ((m_sInPortDef.bEnabled == OMX_FALSE && port == PORT_INDEX_IN)||\n (m_sOutPortDef.bEnabled == OMX_FALSE && port == PORT_INDEX_OUT)) {\n        DEBUG_PRINT_LOW(\"Free Buffer while port %u disabled\", (unsigned int)port);\n } else if (m_state == OMX_StateExecuting || m_state == OMX_StatePause) {\n        DEBUG_PRINT_ERROR(\"ERROR: Invalid state to free buffer,ports need to be disabled\");\n        post_event(OMX_EventError,\n                OMX_ErrorPortUnpopulated,\n                OMX_COMPONENT_GENERATE_EVENT);\n return eRet;\n } else {\n        DEBUG_PRINT_ERROR(\"ERROR: Invalid state to free buffer,port lost Buffers\");\n        post_event(OMX_EventError,\n                OMX_ErrorPortUnpopulated,\n                OMX_COMPONENT_GENERATE_EVENT);\n }\n\n if (port == PORT_INDEX_IN) {\n        nPortIndex = buffer - ((!meta_mode_enable)?m_inp_mem_ptr:meta_buffer_hdr);\n\n \n         DEBUG_PRINT_LOW(\"free_buffer on i/p port - Port idx %u, actual cnt %u\",\n                 nPortIndex, (unsigned int)m_sInPortDef.nBufferCountActual);\n        if (nPortIndex < m_sInPortDef.nBufferCountActual) {\n             BITMASK_CLEAR(&m_inp_bm_count,nPortIndex);\n             free_input_buffer (buffer);\n            m_sInPortDef.bPopulated = OMX_FALSE;\n\n /*Free the Buffer Header*/\n if (release_input_done()\n#ifdef _ANDROID_ICS_\n && !meta_mode_enable\n#endif\n ) {\n                input_use_buffer = false;\n if (m_inp_mem_ptr) {\n                    DEBUG_PRINT_LOW(\"Freeing m_inp_mem_ptr\");\n                    free (m_inp_mem_ptr);\n                    m_inp_mem_ptr = NULL;\n }\n if (m_pInput_pmem) {\n                    DEBUG_PRINT_LOW(\"Freeing m_pInput_pmem\");\n                    free(m_pInput_pmem);\n                    m_pInput_pmem = NULL;\n }\n#ifdef USE_ION\n if (m_pInput_ion) {\n                    DEBUG_PRINT_LOW(\"Freeing m_pInput_ion\");\n                    free(m_pInput_ion);\n                    m_pInput_ion = NULL;\n }\n#endif\n }\n } else {\n            DEBUG_PRINT_ERROR(\"ERROR: free_buffer ,Port Index Invalid\");\n            eRet = OMX_ErrorBadPortIndex;\n }\n\n if (BITMASK_PRESENT((&m_flags),OMX_COMPONENT_INPUT_DISABLE_PENDING)\n && release_input_done()) {\n            DEBUG_PRINT_LOW(\"MOVING TO DISABLED STATE\");\n            BITMASK_CLEAR((&m_flags),OMX_COMPONENT_INPUT_DISABLE_PENDING);\n            post_event(OMX_CommandPortDisable,\n                    PORT_INDEX_IN,\n                    OMX_COMPONENT_GENERATE_EVENT);\n }\n } else if (port == PORT_INDEX_OUT) {\n        nPortIndex = buffer - (OMX_BUFFERHEADERTYPE*)m_out_mem_ptr;\n\n \n         DEBUG_PRINT_LOW(\"free_buffer on o/p port - Port idx %u, actual cnt %u\",\n                 nPortIndex, (unsigned int)m_sOutPortDef.nBufferCountActual);\n        if (nPortIndex < m_sOutPortDef.nBufferCountActual) {\n             BITMASK_CLEAR(&m_out_bm_count,nPortIndex);\n             m_sOutPortDef.bPopulated = OMX_FALSE;\n            free_output_buffer (buffer);\n\n if (release_output_done()) {\n                output_use_buffer = false;\n if (m_out_mem_ptr) {\n                    DEBUG_PRINT_LOW(\"Freeing m_out_mem_ptr\");\n                    free (m_out_mem_ptr);\n                    m_out_mem_ptr = NULL;\n }\n if (m_pOutput_pmem) {\n                    DEBUG_PRINT_LOW(\"Freeing m_pOutput_pmem\");\n                    free(m_pOutput_pmem);\n                    m_pOutput_pmem = NULL;\n }\n#ifdef USE_ION\n if (m_pOutput_ion) {\n                    DEBUG_PRINT_LOW(\"Freeing m_pOutput_ion\");\n                    free(m_pOutput_ion);\n                    m_pOutput_ion = NULL;\n }\n#endif\n }\n } else {\n            DEBUG_PRINT_ERROR(\"ERROR: free_buffer , Port Index Invalid\");\n            eRet = OMX_ErrorBadPortIndex;\n }\n if (BITMASK_PRESENT((&m_flags),OMX_COMPONENT_OUTPUT_DISABLE_PENDING)\n && release_output_done() ) {\n            DEBUG_PRINT_LOW(\"FreeBuffer : If any Disable event pending,post it\");\n\n            DEBUG_PRINT_LOW(\"MOVING TO DISABLED STATE\");\n            BITMASK_CLEAR((&m_flags),OMX_COMPONENT_OUTPUT_DISABLE_PENDING);\n            post_event(OMX_CommandPortDisable,\n                    PORT_INDEX_OUT,\n                    OMX_COMPONENT_GENERATE_EVENT);\n\n }\n } else {\n        eRet = OMX_ErrorBadPortIndex;\n }\n if ((eRet == OMX_ErrorNone) &&\n (BITMASK_PRESENT(&m_flags ,OMX_COMPONENT_LOADING_PENDING))) {\n if (release_done()) {\n if (dev_stop() != 0) {\n                DEBUG_PRINT_ERROR(\"ERROR: dev_stop() FAILED\");\n                eRet = OMX_ErrorHardware;\n }\n            BITMASK_CLEAR((&m_flags),OMX_COMPONENT_LOADING_PENDING);\n            post_event(OMX_CommandStateSet, OMX_StateLoaded,\n                    OMX_COMPONENT_GENERATE_EVENT);\n } else {\n            DEBUG_PRINT_HIGH(\"in free buffer, release not done, need to free more buffers input %\" PRIx64\" output %\" PRIx64,\n                    m_out_bm_count, m_inp_bm_count);\n }\n }\n\n return eRet;\n}\n", "target": 1, "idx": 187802}
{"func": "std::string PrintPreviewUI::GetPrintPreviewUIAddress() const {\n  char preview_ui_addr[2 + (2 * sizeof(this)) + 1];\n  base::snprintf(preview_ui_addr, sizeof(preview_ui_addr), \"%p\", this);\n  return preview_ui_addr;\n }\n", "target": 1, "idx": 184409}
{"func": "void lbs_debugfs_init_one(struct lbs_private *priv, struct net_device *dev)\n{\n\tint i;\n\tconst struct lbs_debugfs_files *files;\n\tif (!lbs_dir)\n\t\tgoto exit;\n\n\tpriv->debugfs_dir = debugfs_create_dir(dev->name, lbs_dir);\n\tif (!priv->debugfs_dir)\n\t\tgoto exit;\n\n\tfor (i=0; i<ARRAY_SIZE(debugfs_files); i++) {\n\t\tfiles = &debugfs_files[i];\n\t\tpriv->debugfs_files[i] = debugfs_create_file(files->name,\n\t\t\t\t\t\t\t     files->perm,\n\t\t\t\t\t\t\t     priv->debugfs_dir,\n\t\t\t\t\t\t\t     priv,\n\t\t\t\t\t\t\t     &files->fops);\n\t}\n\n\tpriv->events_dir = debugfs_create_dir(\"subscribed_events\", priv->debugfs_dir);\n\tif (!priv->events_dir)\n\t\tgoto exit;\n\n\tfor (i=0; i<ARRAY_SIZE(debugfs_events_files); i++) {\n\t\tfiles = &debugfs_events_files[i];\n\t\tpriv->debugfs_events_files[i] = debugfs_create_file(files->name,\n\t\t\t\t\t\t\t     files->perm,\n\t\t\t\t\t\t\t     priv->events_dir,\n\t\t\t\t\t\t\t     priv,\n\t\t\t\t\t\t\t     &files->fops);\n\t}\n\n\tpriv->regs_dir = debugfs_create_dir(\"registers\", priv->debugfs_dir);\n\tif (!priv->regs_dir)\n\t\tgoto exit;\n\n\tfor (i=0; i<ARRAY_SIZE(debugfs_regs_files); i++) {\n\t\tfiles = &debugfs_regs_files[i];\n\t\tpriv->debugfs_regs_files[i] = debugfs_create_file(files->name,\n\t\t\t\t\t\t\t     files->perm,\n\t\t\t\t\t\t\t     priv->regs_dir,\n\t\t\t\t\t\t\t     priv,\n\t\t\t\t\t\t\t     &files->fops);\n\t}\n\n#ifdef PROC_DEBUG\n\tlbs_debug_init(priv);\n#endif\nexit:\n\treturn;\n}\n", "target": 0, "idx": 28675}
{"func": " void LocalFileSystem::fileSystemNotAvailable(\n     PassRefPtrWillBeRawPtr<ExecutionContext> context,\n    PassRefPtr<CallbackWrapper> callbacks)\n {\n     context->postTask(createCrossThreadTask(&reportFailure, callbacks->release(), FileError::ABORT_ERR));\n }\n", "target": 1, "idx": 185126}
{"func": "server_request_direct_streamlocal(void)\n{\n\tChannel *c = NULL;\n\tchar *target, *originator;\n\tu_short originator_port;\n\n\ttarget = packet_get_string(NULL);\n\toriginator = packet_get_string(NULL);\n\toriginator_port = packet_get_int();\n\tpacket_check_eom();\n\n\tdebug(\"server_request_direct_streamlocal: originator %s port %d, target %s\",\n\t    originator, originator_port, target);\n \n \t/* XXX fine grained permissions */\n \tif ((options.allow_streamlocal_forwarding & FORWARD_LOCAL) != 0 &&\n\t    !no_port_forwarding_flag && !options.disable_forwarding) {\n \t\tc = channel_connect_to_path(target,\n \t\t    \"direct-streamlocal@openssh.com\", \"direct-streamlocal\");\n \t} else {\n\t\tlogit(\"refused streamlocal port forward: \"\n\t\t    \"originator %s port %d, target %s\",\n\t\t    originator, originator_port, target);\n\t}\n\n\tfree(originator);\n\tfree(target);\n\n\treturn c;\n}\n", "target": 1, "idx": 181834}
{"func": "PassOwnPtr<CCLayerTreeHostImpl> CCLayerTreeHost::createLayerTreeHostImpl()\n{\n    return CCLayerTreeHostImpl::create(m_settings);\n}\n", "target": 0, "idx": 102681}
{"func": "Resource* CachedResource(LocalFrame* frame,\n                         const KURL& url,\n                         InspectorResourceContentLoader* loader) {\n  Document* document = frame->GetDocument();\n  if (!document)\n    return nullptr;\n  Resource* cached_resource = document->Fetcher()->CachedResource(url);\n  if (!cached_resource) {\n    HeapVector<Member<Document>> all_imports =\n        InspectorPageAgent::ImportsForFrame(frame);\n    for (Document* import : all_imports) {\n      cached_resource = import->Fetcher()->CachedResource(url);\n      if (cached_resource)\n        break;\n    }\n  }\n  if (!cached_resource) {\n    cached_resource = GetMemoryCache()->ResourceForURL(\n        url, document->Fetcher()->GetCacheIdentifier());\n  }\n  if (!cached_resource)\n    cached_resource = loader->ResourceForURL(url);\n  return cached_resource;\n}\n", "target": 0, "idx": 151226}
{"func": "void DownloadItemImpl::DestinationUpdate(\n    int64_t bytes_so_far,\n    int64_t bytes_per_sec,\n    const std::vector<DownloadItem::ReceivedSlice>& received_slices) {\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n  DCHECK(state_ == TARGET_PENDING_INTERNAL || state_ == IN_PROGRESS_INTERNAL);\n\n  DCHECK_EQ(deferred_interrupt_reason_, DOWNLOAD_INTERRUPT_REASON_NONE);\n\n  DVLOG(20) << __func__ << \"() so_far=\" << bytes_so_far\n            << \" per_sec=\" << bytes_per_sec\n            << \" download=\" << DebugString(true);\n\n  UpdateProgress(bytes_so_far, bytes_per_sec);\n  received_slices_ = received_slices;\n  TRACE_EVENT_INSTANT1(\"download\", \"DownloadItemUpdated\",\n                       TRACE_EVENT_SCOPE_THREAD, \"bytes_so_far\",\n                       GetReceivedBytes());\n\n  UpdateObservers();\n}\n", "target": 0, "idx": 159107}
{"func": "static int sysMapBlockFile(FILE* mapf, MemMapping* pMap)\n{\n\n     char block_dev[PATH_MAX+1];\n     size_t size;\n     unsigned int blksize;\n    unsigned int blocks;\n     unsigned int range_count;\n     unsigned int i;\n \n if (fgets(block_dev, sizeof(block_dev), mapf) == NULL) {\n        LOGW(\"failed to read block device from header\\n\");\n return -1;\n }\n for (i = 0; i < sizeof(block_dev); ++i) {\n if (block_dev[i] == '\\n') {\n            block_dev[i] = 0;\n break;\n }\n }\n\n if (fscanf(mapf, \"%zu %u\\n%u\\n\", &size, &blksize, &range_count) != 3) {\n\n         LOGW(\"failed to parse block map header\\n\");\n         return -1;\n     }\n    blocks = ((size-1) / blksize) + 1;\n \n     pMap->range_count = range_count;\n    pMap->ranges = malloc(range_count * sizeof(MappedRange));\n    memset(pMap->ranges, 0, range_count * sizeof(MappedRange));\n \n     unsigned char* reserve;\n     reserve = mmap64(NULL, blocks * blksize, PROT_NONE, MAP_PRIVATE | MAP_ANON, -1, 0);\n     if (reserve == MAP_FAILED) {\n         LOGW(\"failed to reserve address space: %s\\n\", strerror(errno));\n         return -1;\n     }\n \n    pMap->ranges[range_count-1].addr = reserve;\n    pMap->ranges[range_count-1].length = blocks * blksize;\n     int fd = open(block_dev, O_RDONLY);\n     if (fd < 0) {\n         LOGW(\"failed to open block device %s: %s\\n\", block_dev, strerror(errno));\n         return -1;\n     }\n \n     unsigned char* next = reserve;\n     for (i = 0; i < range_count; ++i) {\n        int start, end;\n        if (fscanf(mapf, \"%d %d\\n\", &start, &end) != 2) {\n             LOGW(\"failed to parse range %d in block map\\n\", i);\n            return -1;\n         }\n \n        void* addr = mmap64(next, (end-start)*blksize, PROT_READ, MAP_PRIVATE | MAP_FIXED, fd, ((off64_t)start)*blksize);\n         if (addr == MAP_FAILED) {\n             LOGW(\"failed to map block %d: %s\\n\", i, strerror(errno));\n            return -1;\n         }\n         pMap->ranges[i].addr = addr;\n        pMap->ranges[i].length = (end-start)*blksize;\n \n        next += pMap->ranges[i].length;\n     }\n \n     pMap->addr = reserve;\n     pMap->length = size;\n \n    LOGI(\"mmapped %d ranges\\n\", range_count);\n\n return 0;\n}\n", "target": 1, "idx": 187925}
{"func": "static int __init boot_delay_setup(char *str)\n{\n\tunsigned long lpj;\n\n\tlpj = preset_lpj ? preset_lpj : 1000000;\t/* some guess */\n\tloops_per_msec = (unsigned long long)lpj / 1000 * HZ;\n\n\tget_option(&str, &boot_delay);\n\tif (boot_delay > 10 * 1000)\n\t\tboot_delay = 0;\n\n\tpr_debug(\"boot_delay: %u, preset_lpj: %ld, lpj: %lu, \"\n\t\t\"HZ: %d, loops_per_msec: %llu\\n\",\n\t\tboot_delay, preset_lpj, lpj, HZ, loops_per_msec);\n\treturn 1;\n}\n", "target": 0, "idx": 33431}
{"func": "void WebsiteSettingsPopupView::SetIdentityInfo(\n    const IdentityInfo& identity_info) {\n  base::string16 identity_status_text = identity_info.GetSecuritySummary();\n  header_->SetIdentityName(base::UTF8ToUTF16(identity_info.site_identity));\n  header_->SetIdentityStatus(identity_status_text, SK_ColorBLACK);\n\n  base::string16 headline;\n  if (identity_info.cert_id) {\n    cert_id_ = identity_info.cert_id;\n\n    certificate_dialog_link_ = new views::Link(\n        l10n_util::GetStringUTF16(IDS_PAGEINFO_CERT_INFO_BUTTON));\n    certificate_dialog_link_->set_listener(this);\n\n    if (identity_info.show_ssl_decision_revoke_button) {\n      reset_decisions_button_ = new views::LabelButton(\n          this,\n          l10n_util::GetStringUTF16(\n              IDS_PAGEINFO_RESET_INVALID_CERTIFICATE_DECISIONS_BUTTON));\n      reset_decisions_button_->SetStyle(views::Button::STYLE_BUTTON);\n    }\n\n    headline = base::UTF8ToUTF16(identity_info.site_identity);\n  }\n  ResetConnectionSection(\n      identity_info_content_,\n      WebsiteSettingsUI::GetIdentityIcon(identity_info.identity_status),\n      base::string16(),  // The identity section has no headline.\n      base::UTF8ToUTF16(identity_info.identity_status_description),\n      certificate_dialog_link_,\n      reset_decisions_button_);\n\n  ResetConnectionSection(\n      connection_info_content_,\n      WebsiteSettingsUI::GetConnectionIcon(identity_info.connection_status),\n      base::string16(),  // The connection section has no headline.\n      base::UTF8ToUTF16(identity_info.connection_status_description),\n      nullptr,\n      nullptr);\n\n  connection_tab_->InvalidateLayout();\n  Layout();\n  SizeToContents();\n}\n", "target": 0, "idx": 136098}
{"func": "static void spl_filesystem_tree_it_rewind(zend_object_iterator *iter TSRMLS_DC)\n {\n \tspl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;\n \tspl_filesystem_object   *object   = spl_filesystem_iterator_to_object(iterator);\n \tobject->u.dir.index = 0;\n \tif (object->u.dir.dirp) {\n \t\tphp_stream_rewinddir(object->u.dir.dirp);\n\t}\n\tdo {\n\t\tspl_filesystem_dir_read(object TSRMLS_CC);\n\t} while (spl_filesystem_is_dot(object->u.dir.entry.d_name));\n\tif (iterator->current) {\n\t\tzval_ptr_dtor(&iterator->current);\n\t\titerator->current = NULL;\n\t}\n}\n", "target": 1, "idx": 180260}
{"func": "static BROTLI_NOINLINE BrotliResult SafeProcessCommands(BrotliState* s) {\n  return ProcessCommandsInternal(1, s);\n}\n", "target": 0, "idx": 145811}
{"func": "queryin(char *buf)\n{\n\tQPRS_STATE\tstate;\n\tint32\t\ti;\n\tltxtquery  *query;\n\tint32\t\tcommonlen;\n\tITEM\t   *ptr;\n\tNODE\t   *tmp;\n\tint32\t\tpos = 0;\n\n#ifdef BS_DEBUG\n\tchar\t\tpbuf[16384],\n\t\t\t   *cur;\n#endif\n\n\t/* init state */\n\tstate.buf = buf;\n\tstate.state = WAITOPERAND;\n\tstate.count = 0;\n\tstate.num = 0;\n\tstate.str = NULL;\n\n\t/* init list of operand */\n\tstate.sumlen = 0;\n\tstate.lenop = 64;\n\tstate.curop = state.op = (char *) palloc(state.lenop);\n\t*(state.curop) = '\\0';\n\n\t/* parse query & make polish notation (postfix, but in reverse order) */\n\tmakepol(&state);\n\tif (!state.num)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n \t\t\t\t errmsg(\"syntax error\"),\n \t\t\t\t errdetail(\"Empty query.\")));\n \n\t/* make finish struct */\n \tcommonlen = COMPUTESIZE(state.num, state.sumlen);\n \tquery = (ltxtquery *) palloc(commonlen);\n \tSET_VARSIZE(query, commonlen);\n \tquery->size = state.num;\n\tptr = GETQUERY(query);\n\n\t/* set item in polish notation */\n\tfor (i = 0; i < state.num; i++)\n\t{\n\t\tptr[i].type = state.str->type;\n\t\tptr[i].val = state.str->val;\n\t\tptr[i].distance = state.str->distance;\n\t\tptr[i].length = state.str->length;\n\t\tptr[i].flag = state.str->flag;\n\t\ttmp = state.str->next;\n\t\tpfree(state.str);\n\t\tstate.str = tmp;\n\t}\n\n\t/* set user friendly-operand view */\n\tmemcpy((void *) GETOPERAND(query), (void *) state.op, state.sumlen);\n\tpfree(state.op);\n\n\t/* set left operand's position for every operator */\n\tpos = 0;\n\tfindoprnd(ptr, &pos);\n\n\treturn query;\n}\n", "target": 1, "idx": 179580}
{"func": "int phar_parse_zipfile(php_stream *fp, char *fname, int fname_len, char *alias, int alias_len, phar_archive_data** pphar, char **error TSRMLS_DC) /* {{{ */\n{\n\tphar_zip_dir_end locator;\n\tchar buf[sizeof(locator) + 65536];\n\tlong size;\n\tphp_uint16 i;\n\tphar_archive_data *mydata = NULL;\n\tphar_entry_info entry = {0};\n\tchar *p = buf, *ext, *actual_alias = NULL;\n\tchar *metadata = NULL;\n\n\tsize = php_stream_tell(fp);\n\n\tif (size > sizeof(locator) + 65536) {\n\t\t/* seek to max comment length + end of central directory record */\n\t\tsize = sizeof(locator) + 65536;\n\t\tif (FAILURE == php_stream_seek(fp, -size, SEEK_END)) {\n\t\t\tphp_stream_close(fp);\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 4096, \"phar error: unable to search for end of central directory in zip-based phar \\\"%s\\\"\", fname);\n\t\t\t}\n\t\t\treturn FAILURE;\n\t\t}\n\t} else {\n\t\tphp_stream_seek(fp, 0, SEEK_SET);\n\t}\n\n\tif (!php_stream_read(fp, buf, size)) {\n\t\tphp_stream_close(fp);\n\t\tif (error) {\n\t\t\tspprintf(error, 4096, \"phar error: unable to read in data to search for end of central directory in zip-based phar \\\"%s\\\"\", fname);\n\t\t}\n\t\treturn FAILURE;\n        }\n \n        while ((p=(char *) memchr(p + 1, 'P', (size_t) (size - (p + 1 - buf)))) != NULL) {\n               if (!memcmp(p + 1, \"K\\5\\6\", 3)) {\n                        memcpy((void *)&locator, (void *) p, sizeof(locator));\n                        if (PHAR_GET_16(locator.centraldisk) != 0 || PHAR_GET_16(locator.disknumber) != 0) {\n                                /* split archives not handled */\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: split archives spanning multiple zips cannot be processed in zip-based phar \\\"%s\\\"\", fname);\n\t\t\t\t}\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\tif (PHAR_GET_16(locator.counthere) != PHAR_GET_16(locator.count)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: corrupt zip archive, conflicting file count in end of central directory record in zip-based phar \\\"%s\\\"\", fname);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\tmydata = pecalloc(1, sizeof(phar_archive_data), PHAR_G(persist));\n\t\t\tmydata->is_persistent = PHAR_G(persist);\n\n\t\t\t/* read in archive comment, if any */\n\t\t\tif (PHAR_GET_16(locator.comment_len)) {\n\n\t\t\t\tmetadata = p + sizeof(locator);\n\n\t\t\t\tif (PHAR_GET_16(locator.comment_len) != size - (metadata - buf)) {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 4096, \"phar error: corrupt zip archive, zip file comment truncated in zip-based phar \\\"%s\\\"\", fname);\n\t\t\t\t\t}\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tpefree(mydata, mydata->is_persistent);\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tmydata->metadata_len = PHAR_GET_16(locator.comment_len);\n\n\t\t\t\tif (phar_parse_metadata(&metadata, &mydata->metadata, PHAR_GET_16(locator.comment_len) TSRMLS_CC) == FAILURE) {\n\t\t\t\t\tmydata->metadata_len = 0;\n\t\t\t\t\t/* if not valid serialized data, it is a regular string */\n\n\t\t\t\t\tif (entry.is_persistent) {\n\t\t\t\t\t\tALLOC_PERMANENT_ZVAL(mydata->metadata);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tALLOC_ZVAL(mydata->metadata);\n\t\t\t\t\t}\n\n\t\t\t\t\tINIT_ZVAL(*mydata->metadata);\n\t\t\t\t\tmetadata = pestrndup(metadata, PHAR_GET_16(locator.comment_len), mydata->is_persistent);\n\t\t\t\t\tZVAL_STRINGL(mydata->metadata, metadata, PHAR_GET_16(locator.comment_len), 0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmydata->metadata = NULL;\n\t\t\t}\n\n\t\t\tgoto foundit;\n\t\t}\n\t}\n\n\tphp_stream_close(fp);\n\n\tif (error) {\n\t\tspprintf(error, 4096, \"phar error: end of central directory not found in zip-based phar \\\"%s\\\"\", fname);\n\t}\n\n\treturn FAILURE;\nfoundit:\n\tmydata->fname = pestrndup(fname, fname_len, mydata->is_persistent);\n#ifdef PHP_WIN32\n\tphar_unixify_path_separators(mydata->fname, fname_len);\n#endif\n\tmydata->is_zip = 1;\n\tmydata->fname_len = fname_len;\n\text = strrchr(mydata->fname, '/');\n\n\tif (ext) {\n\t\tmydata->ext = memchr(ext, '.', (mydata->fname + fname_len) - ext);\n\t\tif (mydata->ext == ext) {\n\t\t\tmydata->ext = memchr(ext + 1, '.', (mydata->fname + fname_len) - ext - 1);\n\t\t}\n\t\tif (mydata->ext) {\n\t\t\tmydata->ext_len = (mydata->fname + fname_len) - mydata->ext;\n\t\t}\n\t}\n\n\t/* clean up on big-endian systems */\n\t/* seek to central directory */\n\tphp_stream_seek(fp, PHAR_GET_32(locator.cdir_offset), SEEK_SET);\n\t/* read in central directory */\n\tzend_hash_init(&mydata->manifest, PHAR_GET_16(locator.count),\n\t\tzend_get_hash_value, destroy_phar_manifest_entry, (zend_bool)mydata->is_persistent);\n\tzend_hash_init(&mydata->mounted_dirs, 5,\n\t\tzend_get_hash_value, NULL, (zend_bool)mydata->is_persistent);\n\tzend_hash_init(&mydata->virtual_dirs, PHAR_GET_16(locator.count) * 2,\n\t\tzend_get_hash_value, NULL, (zend_bool)mydata->is_persistent);\n\tentry.phar = mydata;\n\tentry.is_zip = 1;\n\tentry.fp_type = PHAR_FP;\n\tentry.is_persistent = mydata->is_persistent;\n#define PHAR_ZIP_FAIL_FREE(errmsg, save) \\\n\t\t\tzend_hash_destroy(&mydata->manifest); \\\n\t\t\tmydata->manifest.arBuckets = 0; \\\n\t\t\tzend_hash_destroy(&mydata->mounted_dirs); \\\n\t\t\tmydata->mounted_dirs.arBuckets = 0; \\\n\t\t\tzend_hash_destroy(&mydata->virtual_dirs); \\\n\t\t\tmydata->virtual_dirs.arBuckets = 0; \\\n\t\t\tphp_stream_close(fp); \\\n\t\t\tif (mydata->metadata) { \\\n\t\t\t\tzval_dtor(mydata->metadata); \\\n\t\t\t} \\\n\t\t\tif (mydata->signature) { \\\n\t\t\t\tefree(mydata->signature); \\\n\t\t\t} \\\n\t\t\tif (error) { \\\n\t\t\t\tspprintf(error, 4096, \"phar error: %s in zip-based phar \\\"%s\\\"\", errmsg, mydata->fname); \\\n\t\t\t} \\\n\t\t\tpefree(mydata->fname, mydata->is_persistent); \\\n\t\t\tif (mydata->alias) { \\\n\t\t\t\tpefree(mydata->alias, mydata->is_persistent); \\\n\t\t\t} \\\n\t\t\tpefree(mydata, mydata->is_persistent); \\\n\t\t\tefree(save); \\\n\t\t\treturn FAILURE;\n#define PHAR_ZIP_FAIL(errmsg) \\\n\t\t\tzend_hash_destroy(&mydata->manifest); \\\n\t\t\tmydata->manifest.arBuckets = 0; \\\n\t\t\tzend_hash_destroy(&mydata->mounted_dirs); \\\n\t\t\tmydata->mounted_dirs.arBuckets = 0; \\\n\t\t\tzend_hash_destroy(&mydata->virtual_dirs); \\\n\t\t\tmydata->virtual_dirs.arBuckets = 0; \\\n\t\t\tphp_stream_close(fp); \\\n\t\t\tif (mydata->metadata) { \\\n\t\t\t\tzval_dtor(mydata->metadata); \\\n\t\t\t} \\\n\t\t\tif (mydata->signature) { \\\n\t\t\t\tefree(mydata->signature); \\\n\t\t\t} \\\n\t\t\tif (error) { \\\n\t\t\t\tspprintf(error, 4096, \"phar error: %s in zip-based phar \\\"%s\\\"\", errmsg, mydata->fname); \\\n\t\t\t} \\\n\t\t\tpefree(mydata->fname, mydata->is_persistent); \\\n\t\t\tif (mydata->alias) { \\\n\t\t\t\tpefree(mydata->alias, mydata->is_persistent); \\\n\t\t\t} \\\n\t\t\tpefree(mydata, mydata->is_persistent); \\\n\t\t\treturn FAILURE;\n\n\t/* add each central directory item to the manifest */\n\tfor (i = 0; i < PHAR_GET_16(locator.count); ++i) {\n\t\tphar_zip_central_dir_file zipentry;\n\t\toff_t beforeus = php_stream_tell(fp);\n\n\t\tif (sizeof(zipentry) != php_stream_read(fp, (char *) &zipentry, sizeof(zipentry))) {\n\t\t\tPHAR_ZIP_FAIL(\"unable to read central directory entry, truncated\");\n\t\t}\n\n\t\t/* clean up for bigendian systems */\n\t\tif (memcmp(\"PK\\1\\2\", zipentry.signature, 4)) {\n\t\t\t/* corrupted entry */\n\t\t\tPHAR_ZIP_FAIL(\"corrupted central directory entry, no magic signature\");\n\t\t}\n\n\t\tif (entry.is_persistent) {\n\t\t\tentry.manifest_pos = i;\n\t\t}\n\n\t\tentry.compressed_filesize = PHAR_GET_32(zipentry.compsize);\n\t\tentry.uncompressed_filesize = PHAR_GET_32(zipentry.uncompsize);\n\t\tentry.crc32 = PHAR_GET_32(zipentry.crc32);\n\t\t/* do not PHAR_GET_16 either on the next line */\n\t\tentry.timestamp = phar_zip_d2u_time(zipentry.timestamp, zipentry.datestamp);\n\t\tentry.flags = PHAR_ENT_PERM_DEF_FILE;\n\t\tentry.header_offset = PHAR_GET_32(zipentry.offset);\n\t\tentry.offset = entry.offset_abs = PHAR_GET_32(zipentry.offset) + sizeof(phar_zip_file_header) + PHAR_GET_16(zipentry.filename_len) +\n\t\t\tPHAR_GET_16(zipentry.extra_len);\n\n\t\tif (PHAR_GET_16(zipentry.flags) & PHAR_ZIP_FLAG_ENCRYPTED) {\n\t\t\tPHAR_ZIP_FAIL(\"Cannot process encrypted zip files\");\n\t\t}\n\n\t\tif (!PHAR_GET_16(zipentry.filename_len)) {\n\t\t\tPHAR_ZIP_FAIL(\"Cannot process zips created from stdin (zero-length filename)\");\n\t\t}\n\n\t\tentry.filename_len = PHAR_GET_16(zipentry.filename_len);\n\t\tentry.filename = (char *) pemalloc(entry.filename_len + 1, entry.is_persistent);\n\n\t\tif (entry.filename_len != php_stream_read(fp, entry.filename, entry.filename_len)) {\n\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\tPHAR_ZIP_FAIL(\"unable to read in filename from central directory, truncated\");\n\t\t}\n\n\t\tentry.filename[entry.filename_len] = '\\0';\n\n\t\tif (entry.filename[entry.filename_len - 1] == '/') {\n\t\t\tentry.is_dir = 1;\n\t\t\tif(entry.filename_len > 1) {\n\t\t\t\tentry.filename_len--;\n\t\t\t}\n\t\t\tentry.flags |= PHAR_ENT_PERM_DEF_DIR;\n\t\t} else {\n\t\t\tentry.is_dir = 0;\n\t\t}\n\n\t\tif (entry.filename_len == sizeof(\".phar/signature.bin\")-1 && !strncmp(entry.filename, \".phar/signature.bin\", sizeof(\".phar/signature.bin\")-1)) {\n\t\t\tsize_t read;\n\t\t\tphp_stream *sigfile;\n\t\t\toff_t now;\n\t\t\tchar *sig;\n\n\t\t\tnow = php_stream_tell(fp);\n\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\tsigfile = php_stream_fopen_tmpfile();\n\t\t\tif (!sigfile) {\n\t\t\t\tPHAR_ZIP_FAIL(\"couldn't open temporary file\");\n\t\t\t}\n\n\t\t\tphp_stream_seek(fp, 0, SEEK_SET);\n\t\t\t/* copy file contents + local headers and zip comment, if any, to be hashed for signature */\n\t\t\tphar_stream_copy_to_stream(fp, sigfile, entry.header_offset, NULL);\n\t\t\t/* seek to central directory */\n\t\t\tphp_stream_seek(fp, PHAR_GET_32(locator.cdir_offset), SEEK_SET);\n\t\t\t/* copy central directory header */\n\t\t\tphar_stream_copy_to_stream(fp, sigfile, beforeus - PHAR_GET_32(locator.cdir_offset), NULL);\n\t\t\tif (metadata) {\n\t\t\t\tphp_stream_write(sigfile, metadata, PHAR_GET_16(locator.comment_len));\n\t\t\t}\n\t\t\tphp_stream_seek(fp, sizeof(phar_zip_file_header) + entry.header_offset + entry.filename_len + PHAR_GET_16(zipentry.extra_len), SEEK_SET);\n\t\t\tsig = (char *) emalloc(entry.uncompressed_filesize);\n\t\t\tread = php_stream_read(fp, sig, entry.uncompressed_filesize);\n\t\t\tif (read != entry.uncompressed_filesize) {\n\t\t\t\tphp_stream_close(sigfile);\n\t\t\t\tefree(sig);\n\t\t\t\tPHAR_ZIP_FAIL(\"signature cannot be read\");\n\t\t\t}\n\t\t\tmydata->sig_flags = PHAR_GET_32(sig);\n\t\t\tif (FAILURE == phar_verify_signature(sigfile, php_stream_tell(sigfile), mydata->sig_flags, sig + 8, entry.uncompressed_filesize - 8, fname, &mydata->signature, &mydata->sig_len, error TSRMLS_CC)) {\n\t\t\t\tefree(sig);\n\t\t\t\tif (error) {\n\t\t\t\t\tchar *save;\n\t\t\t\t\tphp_stream_close(sigfile);\n\t\t\t\t\tspprintf(&save, 4096, \"signature cannot be verified: %s\", *error);\n\t\t\t\t\tefree(*error);\n\t\t\t\t\tPHAR_ZIP_FAIL_FREE(save, save);\n\t\t\t\t} else {\n\t\t\t\t\tphp_stream_close(sigfile);\n\t\t\t\t\tPHAR_ZIP_FAIL(\"signature cannot be verified\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tphp_stream_close(sigfile);\n\t\t\tefree(sig);\n\t\t\t/* signature checked out, let's ensure this is the last file in the phar */\n\t\t\tif (i != PHAR_GET_16(locator.count) - 1) {\n\t\t\t\tPHAR_ZIP_FAIL(\"entries exist after signature, invalid phar\");\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tphar_add_virtual_dirs(mydata, entry.filename, entry.filename_len TSRMLS_CC);\n\n\t\tif (PHAR_GET_16(zipentry.extra_len)) {\n\t\t\toff_t loc = php_stream_tell(fp);\n\t\t\tif (FAILURE == phar_zip_process_extra(fp, &entry, PHAR_GET_16(zipentry.extra_len) TSRMLS_CC)) {\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"Unable to process extra field header for file in central directory\");\n\t\t\t}\n\t\t\tphp_stream_seek(fp, loc + PHAR_GET_16(zipentry.extra_len), SEEK_SET);\n\t\t}\n\n\t\tswitch (PHAR_GET_16(zipentry.compressed)) {\n\t\t\tcase PHAR_ZIP_COMP_NONE :\n\t\t\t\t/* compression flag already set */\n\t\t\t\tbreak;\n\t\t\tcase PHAR_ZIP_COMP_DEFLATE :\n\t\t\t\tentry.flags |= PHAR_ENT_COMPRESSED_GZ;\n\t\t\t\tif (!PHAR_G(has_zlib)) {\n\t\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\t\tPHAR_ZIP_FAIL(\"zlib extension is required\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PHAR_ZIP_COMP_BZIP2 :\n\t\t\t\tentry.flags |= PHAR_ENT_COMPRESSED_BZ2;\n\t\t\t\tif (!PHAR_G(has_bz2)) {\n\t\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\t\tPHAR_ZIP_FAIL(\"bzip2 extension is required\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 1 :\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (Shrunk) used in this zip\");\n\t\t\tcase 2 :\n\t\t\tcase 3 :\n\t\t\tcase 4 :\n\t\t\tcase 5 :\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (Reduce) used in this zip\");\n\t\t\tcase 6 :\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (Implode) used in this zip\");\n\t\t\tcase 7 :\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (Tokenize) used in this zip\");\n\t\t\tcase 9 :\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (Deflate64) used in this zip\");\n\t\t\tcase 10 :\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (PKWare Implode/old IBM TERSE) used in this zip\");\n\t\t\tcase 14 :\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (LZMA) used in this zip\");\n\t\t\tcase 18 :\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (IBM TERSE) used in this zip\");\n\t\t\tcase 19 :\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (IBM LZ77) used in this zip\");\n\t\t\tcase 97 :\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (WavPack) used in this zip\");\n\t\t\tcase 98 :\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (PPMd) used in this zip\");\n\t\t\tdefault :\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (unknown) used in this zip\");\n\t\t}\n\n\t\t/* get file metadata */\n\t\tif (PHAR_GET_16(zipentry.comment_len)) {\n\t\t\tif (PHAR_GET_16(zipentry.comment_len) != php_stream_read(fp, buf, PHAR_GET_16(zipentry.comment_len))) {\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"unable to read in file comment, truncated\");\n\t\t\t}\n\n\t\t\tp = buf;\n\t\t\tentry.metadata_len = PHAR_GET_16(zipentry.comment_len);\n\n\t\t\tif (phar_parse_metadata(&p, &(entry.metadata), PHAR_GET_16(zipentry.comment_len) TSRMLS_CC) == FAILURE) {\n\t\t\t\tentry.metadata_len = 0;\n\t\t\t\t/* if not valid serialized data, it is a regular string */\n\n\t\t\t\tif (entry.is_persistent) {\n\t\t\t\t\tALLOC_PERMANENT_ZVAL(entry.metadata);\n\t\t\t\t} else {\n\t\t\t\t\tALLOC_ZVAL(entry.metadata);\n\t\t\t\t}\n\n\t\t\t\tINIT_ZVAL(*entry.metadata);\n\t\t\t\tZVAL_STRINGL(entry.metadata, pestrndup(buf, PHAR_GET_16(zipentry.comment_len), entry.is_persistent), PHAR_GET_16(zipentry.comment_len), 0);\n\t\t\t}\n\t\t} else {\n\t\t\tentry.metadata = NULL;\n\t\t}\n\n\t\tif (!actual_alias && entry.filename_len == sizeof(\".phar/alias.txt\")-1 && !strncmp(entry.filename, \".phar/alias.txt\", sizeof(\".phar/alias.txt\")-1)) {\n\t\t\tphp_stream_filter *filter;\n\t\t\toff_t saveloc;\n\t\t\t/* verify local file header */\n\t\t\tphar_zip_file_header local;\n\n\t\t\t/* archive alias found */\n\t\t\tsaveloc = php_stream_tell(fp);\n\t\t\tphp_stream_seek(fp, PHAR_GET_32(zipentry.offset), SEEK_SET);\n\n\t\t\tif (sizeof(local) != php_stream_read(fp, (char *) &local, sizeof(local))) {\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"phar error: internal corruption of zip-based phar (cannot read local file header for alias)\");\n\t\t\t}\n\n\t\t\t/* verify local header */\n\t\t\tif (entry.filename_len != PHAR_GET_16(local.filename_len) || entry.crc32 != PHAR_GET_32(local.crc32) || entry.uncompressed_filesize != PHAR_GET_32(local.uncompsize) || entry.compressed_filesize != PHAR_GET_32(local.compsize)) {\n\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\tPHAR_ZIP_FAIL(\"phar error: internal corruption of zip-based phar (local header of alias does not match central directory)\");\n\t\t\t}\n\n\t\t\t/* construct actual offset to file start - local extra_len can be different from central extra_len */\n\t\t\tentry.offset = entry.offset_abs =\n\t\t\t\tsizeof(local) + entry.header_offset + PHAR_GET_16(local.filename_len) + PHAR_GET_16(local.extra_len);\n\t\t\tphp_stream_seek(fp, entry.offset, SEEK_SET);\n\t\t\t/* these next lines should be for php < 5.2.6 after 5.3 filters are fixed */\n\t\t\tfp->writepos = 0;\n\t\t\tfp->readpos = 0;\n\t\t\tphp_stream_seek(fp, entry.offset, SEEK_SET);\n\t\t\tfp->writepos = 0;\n\t\t\tfp->readpos = 0;\n\t\t\t/* the above lines should be for php < 5.2.6 after 5.3 filters are fixed */\n\n\t\t\tmydata->alias_len = entry.uncompressed_filesize;\n\n\t\t\tif (entry.flags & PHAR_ENT_COMPRESSED_GZ) {\n\t\t\t\tfilter = php_stream_filter_create(\"zlib.inflate\", NULL, php_stream_is_persistent(fp) TSRMLS_CC);\n\n\t\t\t\tif (!filter) {\n\t\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\t\tPHAR_ZIP_FAIL(\"unable to decompress alias, zlib filter creation failed\");\n\t\t\t\t}\n\n\t\t\t\tphp_stream_filter_append(&fp->readfilters, filter);\n\n\t\t\t\tif (!(entry.uncompressed_filesize = php_stream_copy_to_mem(fp, &actual_alias, entry.uncompressed_filesize, 0)) || !actual_alias) {\n\t\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\t\tPHAR_ZIP_FAIL(\"unable to read in alias, truncated\");\n\t\t\t\t}\n\n\t\t\t\tphp_stream_filter_flush(filter, 1);\n\t\t\t\tphp_stream_filter_remove(filter, 1 TSRMLS_CC);\n\n\t\t\t} else if (entry.flags & PHAR_ENT_COMPRESSED_BZ2) {\n\t\t\t\tfilter = php_stream_filter_create(\"bzip2.decompress\", NULL, php_stream_is_persistent(fp) TSRMLS_CC);\n\n\t\t\t\tif (!filter) {\n\t\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\t\tPHAR_ZIP_FAIL(\"unable to read in alias, bzip2 filter creation failed\");\n\t\t\t\t}\n\n\t\t\t\tphp_stream_filter_append(&fp->readfilters, filter);\n\n\t\t\t\tif (!(entry.uncompressed_filesize = php_stream_copy_to_mem(fp, &actual_alias, entry.uncompressed_filesize, 0)) || !actual_alias) {\n\t\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\t\tPHAR_ZIP_FAIL(\"unable to read in alias, truncated\");\n\t\t\t\t}\n\n\t\t\t\tphp_stream_filter_flush(filter, 1);\n\t\t\t\tphp_stream_filter_remove(filter, 1 TSRMLS_CC);\n\t\t\t} else {\n\t\t\t\tif (!(entry.uncompressed_filesize = php_stream_copy_to_mem(fp, &actual_alias, entry.uncompressed_filesize, 0)) || !actual_alias) {\n\t\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\t\tPHAR_ZIP_FAIL(\"unable to read in alias, truncated\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* return to central directory parsing */\n\t\t\tphp_stream_seek(fp, saveloc, SEEK_SET);\n\t\t}\n\n\t\tphar_set_inode(&entry TSRMLS_CC);\n\t\tzend_hash_add(&mydata->manifest, entry.filename, entry.filename_len, (void *)&entry,sizeof(phar_entry_info), NULL);\n\t}\n\n\tmydata->fp = fp;\n\n\tif (zend_hash_exists(&(mydata->manifest), \".phar/stub.php\", sizeof(\".phar/stub.php\")-1)) {\n\t\tmydata->is_data = 0;\n\t} else {\n\t\tmydata->is_data = 1;\n\t}\n\n\tzend_hash_add(&(PHAR_GLOBALS->phar_fname_map), mydata->fname, fname_len, (void*)&mydata, sizeof(phar_archive_data*), NULL);\n\n\tif (actual_alias) {\n\t\tphar_archive_data **fd_ptr;\n\n\t\tif (!phar_validate_alias(actual_alias, mydata->alias_len)) {\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 4096, \"phar error: invalid alias \\\"%s\\\" in zip-based phar \\\"%s\\\"\", actual_alias, fname);\n\t\t\t}\n\t\t\tefree(actual_alias);\n\t\t\tzend_hash_del(&(PHAR_GLOBALS->phar_fname_map), mydata->fname, fname_len);\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\tmydata->is_temporary_alias = 0;\n\n\t\tif (SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_alias_map), actual_alias, mydata->alias_len, (void **)&fd_ptr)) {\n\t\t\tif (SUCCESS != phar_free_alias(*fd_ptr, actual_alias, mydata->alias_len TSRMLS_CC)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: Unable to add zip-based phar \\\"%s\\\" with implicit alias, alias is already in use\", fname);\n\t\t\t\t}\n\t\t\t\tefree(actual_alias);\n\t\t\t\tzend_hash_del(&(PHAR_GLOBALS->phar_fname_map), mydata->fname, fname_len);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\n\t\tmydata->alias = entry.is_persistent ? pestrndup(actual_alias, mydata->alias_len, 1) : actual_alias;\n\n\t\tif (entry.is_persistent) {\n\t\t\tefree(actual_alias);\n\t\t}\n\n\t\tzend_hash_add(&(PHAR_GLOBALS->phar_alias_map), actual_alias, mydata->alias_len, (void*)&mydata, sizeof(phar_archive_data*), NULL);\n\t} else {\n\t\tphar_archive_data **fd_ptr;\n\n\t\tif (alias_len) {\n\t\t\tif (SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void **)&fd_ptr)) {\n\t\t\t\tif (SUCCESS != phar_free_alias(*fd_ptr, alias, alias_len TSRMLS_CC)) {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 4096, \"phar error: Unable to add zip-based phar \\\"%s\\\" with explicit alias, alias is already in use\", fname);\n\t\t\t\t\t}\n\t\t\t\t\tzend_hash_del(&(PHAR_GLOBALS->phar_fname_map), mydata->fname, fname_len);\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tzend_hash_add(&(PHAR_GLOBALS->phar_alias_map), actual_alias, mydata->alias_len, (void*)&mydata, sizeof(phar_archive_data*), NULL);\n\t\t\tmydata->alias = pestrndup(alias, alias_len, mydata->is_persistent);\n\t\t\tmydata->alias_len = alias_len;\n\t\t} else {\n\t\t\tmydata->alias = pestrndup(mydata->fname, fname_len, mydata->is_persistent);\n\t\t\tmydata->alias_len = fname_len;\n\t\t}\n\n\t\tmydata->is_temporary_alias = 1;\n\t}\n\n\tif (pphar) {\n\t\t*pphar = mydata;\n\t}\n\n\treturn SUCCESS;\n}\n/* }}} */\n", "target": 1, "idx": 178335}
{"func": "void bta_av_disable(tBTA_AV_CB* p_cb, UNUSED_ATTR tBTA_AV_DATA* p_data) {\n  BT_HDR hdr;\n uint16_t xx;\n\n  p_cb->disabling = true;\n\n  bta_av_close_all_rc(p_cb);\n\n  osi_free_and_reset((void**)&p_cb->p_disc_db);\n\n /* disable audio/video - de-register all channels,\n   * expect BTA_AV_DEREG_COMP_EVT when deregister is complete */\n for (xx = 0; xx < BTA_AV_NUM_STRS; xx++) {\n if (p_cb->p_scb[xx] != NULL) {\n      hdr.layer_specific = xx + 1;\n      bta_av_api_deregister((tBTA_AV_DATA*)&hdr);\n }\n }\n\n  alarm_free(p_cb->link_signalling_timer);\n  p_cb->link_signalling_timer = NULL;\n  alarm_free(p_cb->accept_signalling_timer);\n  p_cb->accept_signalling_timer = NULL;\n}\n", "target": 0, "idx": 176014}
{"func": "HeapVector<NotificationAction> Notification::actions() const\n{\n    HeapVector<NotificationAction> actions;\n    actions.grow(m_data.actions.size());\n\n     for (size_t i = 0; i < m_data.actions.size(); ++i) {\n         actions[i].setAction(m_data.actions[i].action);\n         actions[i].setTitle(m_data.actions[i].title);\n     }\n \n     return actions;\n}\n", "target": 1, "idx": 185336}
{"func": "void RenderFrameImpl::DidChangeSelection(bool is_empty_selection) {\n  if (!GetRenderWidget()->input_handler().handling_input_event() &&\n      !handling_select_range_)\n    return;\n\n  if (is_empty_selection)\n    selection_text_.clear();\n\n  GetRenderWidget()->UpdateTextInputState();\n  SyncSelectionIfRequired();\n}\n", "target": 0, "idx": 160577}
{"func": "EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionMethodThatRequiresAllArgsAndThrows(ExecState* exec)\n{\n    JSValue thisValue = exec->hostThisValue();\n    if (!thisValue.inherits(&JSTestObj::s_info))\n        return throwVMTypeError(exec);\n    JSTestObj* castedThis = jsCast<JSTestObj*>(asObject(thisValue));\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\n     TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n     if (exec->argumentCount() < 2)\n        return throwVMError(exec, createTypeError(exec, \"Not enough arguments\"));\n     ExceptionCode ec = 0;\n     const String& strArg(ustringToString(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).isEmpty() ? UString() : MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toString(exec)->value(exec)));\n     if (exec->hadException())\n        return JSValue::encode(jsUndefined());\n    TestObj* objArg(toTestObj(MAYBE_MISSING_PARAMETER(exec, 1, DefaultIsUndefined)));\n    if (exec->hadException())\n        return JSValue::encode(jsUndefined());\n\n    JSC::JSValue result = toJS(exec, castedThis->globalObject(), WTF::getPtr(impl->methodThatRequiresAllArgsAndThrows(strArg, objArg, ec)));\n    setDOMException(exec, ec);\n    return JSValue::encode(result);\n}\n", "target": 1, "idx": 184048}
{"func": "status_t Parcel::readString16(String16* pArg) const\n{\n size_t len;\n const char16_t* str = readString16Inplace(&len);\n if (str) {\n        pArg->setTo(str, len);\n return 0;\n } else {\n *pArg = String16();\n return UNEXPECTED_NULL;\n }\n}\n", "target": 0, "idx": 176758}
{"func": "LayoutUnit RenderFlexibleBox::crossAxisExtent() const\n{\n    return isHorizontalFlow() ? height() : width();\n}\n", "target": 0, "idx": 125000}
{"func": "FLAC_API FLAC__bool FLAC__stream_decoder_seek_absolute(FLAC__StreamDecoder *decoder, FLAC__uint64 sample)\n{\n\tFLAC__uint64 length;\n\n\tFLAC__ASSERT(0 != decoder);\n\n if(\n\t\tdecoder->protected_->state != FLAC__STREAM_DECODER_SEARCH_FOR_METADATA &&\n\t\tdecoder->protected_->state != FLAC__STREAM_DECODER_READ_METADATA &&\n\t\tdecoder->protected_->state != FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC &&\n\t\tdecoder->protected_->state != FLAC__STREAM_DECODER_READ_FRAME &&\n\t\tdecoder->protected_->state != FLAC__STREAM_DECODER_END_OF_STREAM\n )\n return false;\n\n if(0 == decoder->private_->seek_callback)\n return false;\n\n\tFLAC__ASSERT(decoder->private_->seek_callback);\n\tFLAC__ASSERT(decoder->private_->tell_callback);\n\tFLAC__ASSERT(decoder->private_->length_callback);\n\tFLAC__ASSERT(decoder->private_->eof_callback);\n\n if(FLAC__stream_decoder_get_total_samples(decoder) > 0 && sample >= FLAC__stream_decoder_get_total_samples(decoder))\n return false;\n\n\tdecoder->private_->is_seeking = true;\n\n /* turn off md5 checking if a seek is attempted */\n\tdecoder->private_->do_md5_checking = false;\n\n /* get the file length (currently our algorithm needs to know the length so it's also an error to get FLAC__STREAM_DECODER_LENGTH_STATUS_UNSUPPORTED) */\n if(decoder->private_->length_callback(decoder, &length, decoder->private_->client_data) != FLAC__STREAM_DECODER_LENGTH_STATUS_OK) {\n\t\tdecoder->private_->is_seeking = false;\n return false;\n }\n\n /* if we haven't finished processing the metadata yet, do that so we have the STREAMINFO, SEEK_TABLE, and first_frame_offset */\n if(\n\t\tdecoder->protected_->state == FLAC__STREAM_DECODER_SEARCH_FOR_METADATA ||\n\t\tdecoder->protected_->state == FLAC__STREAM_DECODER_READ_METADATA\n ) {\n if(!FLAC__stream_decoder_process_until_end_of_metadata(decoder)) {\n /* above call sets the state for us */\n\t\t\tdecoder->private_->is_seeking = false;\n return false;\n }\n /* check this again in case we didn't know total_samples the first time */\n if(FLAC__stream_decoder_get_total_samples(decoder) > 0 && sample >= FLAC__stream_decoder_get_total_samples(decoder)) {\n\t\t\tdecoder->private_->is_seeking = false;\n return false;\n }\n }\n\n {\n const FLAC__bool ok =\n#if FLAC__HAS_OGG\n\t\t\tdecoder->private_->is_ogg?\n\t\t\tseek_to_absolute_sample_ogg_(decoder, length, sample) :\n#endif\n\t\t\tseek_to_absolute_sample_(decoder, length, sample)\n ;\n\t\tdecoder->private_->is_seeking = false;\n return ok;\n }\n}\n", "target": 0, "idx": 174377}
{"func": "error::Error GLES2DecoderPassthroughImpl::DoProduceTextureDirectCHROMIUM(\n    GLuint texture_client_id,\n    const volatile GLbyte* mailbox) {\n  scoped_refptr<TexturePassthrough> texture = nullptr;\n  if (!resources_->texture_object_map.GetServiceID(texture_client_id,\n                                                   &texture) ||\n      texture == nullptr) {\n    InsertError(GL_INVALID_OPERATION, \"Unknown texture.\");\n    return error::kNoError;\n  }\n\n  const Mailbox& mb = Mailbox::FromVolatile(\n      *reinterpret_cast<const volatile Mailbox*>(mailbox));\n  mailbox_manager_->ProduceTexture(mb, texture.get());\n  return error::kNoError;\n}\n", "target": 0, "idx": 154765}
{"func": " void ImageTokenizer::finish()\n {\n    if (!m_parserStopped) {\n         CachedImage* cachedImage = m_imageElement->cachedImage();\n         Vector<char>& buffer = cachedImage->bufferData(0, 0, 0);\n         cachedImage->data(buffer, true);\n\n#if PLATFORM(MAC)\n        finishImageLoad(m_doc, cachedImage, buffer.data(), buffer.size());\n#endif\n    }\n\n    m_doc->finishedParsing();\n}\n", "target": 1, "idx": 183508}
{"func": "static int macvtap_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t   struct msghdr *m, size_t total_len,\n\t\t\t   int flags)\n{\n\tstruct macvtap_queue *q = container_of(sock, struct macvtap_queue, sock);\n\tint ret;\n\tif (flags & ~(MSG_DONTWAIT|MSG_TRUNC))\n\t\treturn -EINVAL;\n\tret = macvtap_do_read(q, iocb, m->msg_iov, total_len,\n\t\t\t  flags & MSG_DONTWAIT);\n\tif (ret > total_len) {\n\t\tm->msg_flags |= MSG_TRUNC;\n\t\tret = flags & MSG_TRUNC ? ret : total_len;\n\t}\n\treturn ret;\n}\n", "target": 0, "idx": 34575}
{"func": "void Browser::Observe(NotificationType type,\n                      const NotificationSource& source,\n                      const NotificationDetails& details) {\n  switch (type.value) {\n    case NotificationType::TAB_CONTENTS_DISCONNECTED:\n      if (is_attempting_to_close_browser_) {\n        ClearUnloadState(Source<TabContents>(source).ptr(), false);\n      }\n      break;\n\n    case NotificationType::SSL_VISIBLE_STATE_CHANGED:\n      if (GetSelectedTabContents() &&\n          &GetSelectedTabContents()->controller() ==\n          Source<NavigationController>(source).ptr())\n        UpdateToolbar(false);\n      break;\n\n    case NotificationType::EXTENSION_UPDATE_DISABLED: {\n      Profile* profile = Source<Profile>(source).ptr();\n      if (profile_->IsSameProfile(profile)) {\n        ExtensionService* service = profile->GetExtensionService();\n        DCHECK(service);\n        const Extension* extension = Details<const Extension>(details).ptr();\n        if (service->extension_prefs()->DidExtensionEscalatePermissions(\n                extension->id()))\n          ShowExtensionDisabledUI(service, profile_, extension);\n      }\n      break;\n    }\n\n    case NotificationType::EXTENSION_UNLOADED: {\n      window()->GetLocationBar()->UpdatePageActions();\n\n      const Extension* extension =\n          Details<UnloadedExtensionInfo>(details)->extension;\n      TabStripModel* model = tab_handler_->GetTabStripModel();\n      for (int i = model->count() - 1; i >= 0; --i) {\n        TabContents* tc = model->GetTabContentsAt(i)->tab_contents();\n        if (tc->GetURL().SchemeIs(chrome::kExtensionScheme) &&\n            tc->GetURL().host() == extension->id()) {\n          CloseTabContents(tc);\n        }\n      }\n\n      break;\n    }\n\n    case NotificationType::EXTENSION_PROCESS_TERMINATED: {\n      window()->GetLocationBar()->InvalidatePageActions();\n      break;\n    }\n\n    case NotificationType::EXTENSION_UNINSTALLED:\n    case NotificationType::EXTENSION_LOADED:\n      window()->GetLocationBar()->UpdatePageActions();\n      break;\n\n    case NotificationType::BROWSER_THEME_CHANGED:\n      window()->UserChangedTheme();\n      break;\n\n    case NotificationType::EXTENSION_READY_FOR_INSTALL: {\n      if (BrowserList::FindBrowserWithType(profile(),\n                                           Browser::TYPE_NORMAL,\n                                           true) != this)\n        break;\n\n      GURL download_url = *(Details<GURL>(details).ptr());\n      if (ExtensionService::IsDownloadFromMiniGallery(download_url))\n        window()->ShowThemeInstallBubble();\n      break;\n    }\n\n    case NotificationType::PREF_CHANGED: {\n      const std::string& pref_name = *Details<std::string>(details).ptr();\n      if (pref_name == prefs::kUseVerticalTabs) {\n        UseVerticalTabsChanged();\n      } else if (pref_name == prefs::kPrintingEnabled) {\n        UpdatePrintingState(GetContentRestrictionsForSelectedTab());\n      } else if (pref_name == prefs::kInstantEnabled) {\n        if (!InstantController::IsEnabled(profile())) {\n          if (instant()) {\n            instant()->DestroyPreviewContents();\n            instant_.reset();\n            instant_unload_handler_.reset();\n          }\n        } else {\n          CreateInstantIfNecessary();\n        }\n      } else if (pref_name == prefs::kDevToolsDisabled) {\n        UpdateCommandsForDevTools();\n        if (dev_tools_disabled_.GetValue())\n          g_browser_process->devtools_manager()->CloseAllClientHosts();\n      } else if (pref_name == prefs::kIncognitoEnabled) {\n        break;  // No further action is required.\n      } else if (pref_name == prefs::kEditBookmarksEnabled) {\n        UpdateCommandsForBookmarkEditing();\n      } else {\n        NOTREACHED();\n      }\n      break;\n    }\n\n    default:\n      NOTREACHED() << \"Got a notification we didn't register for.\";\n  }\n}\n", "target": 0, "idx": 103134}
{"func": "static __u8 *lg_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tstruct lg_drv_data *drv_data = hid_get_drvdata(hdev);\n \tstruct usb_device_descriptor *udesc;\n \t__u16 bcdDevice, rev_maj, rev_min;\n \n\tif ((drv_data->quirks & LG_RDESC) && *rsize >= 90 && rdesc[83] == 0x26 &&\n \t\t\trdesc[84] == 0x8c && rdesc[85] == 0x02) {\n \t\thid_info(hdev,\n \t\t\t \"fixing up Logitech keyboard report descriptor\\n\");\n \t\trdesc[84] = rdesc[89] = 0x4d;\n \t\trdesc[85] = rdesc[90] = 0x10;\n \t}\n\tif ((drv_data->quirks & LG_RDESC_REL_ABS) && *rsize >= 50 &&\n \t\t\trdesc[32] == 0x81 && rdesc[33] == 0x06 &&\n \t\t\trdesc[49] == 0x81 && rdesc[50] == 0x06) {\n \t\thid_info(hdev,\n\t\t\t \"fixing up rel/abs in Logitech report descriptor\\n\");\n\t\trdesc[33] = rdesc[50] = 0x02;\n\t}\n\n\tswitch (hdev->product) {\n\n\t/* Several wheels report as this id when operating in emulation mode. */\n\tcase USB_DEVICE_ID_LOGITECH_WHEEL:\n\t\tudesc = &(hid_to_usb_dev(hdev)->descriptor);\n\t\tif (!udesc) {\n\t\t\thid_err(hdev, \"NULL USB device descriptor\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tbcdDevice = le16_to_cpu(udesc->bcdDevice);\n\t\trev_maj = bcdDevice >> 8;\n\t\trev_min = bcdDevice & 0xff;\n\n\t\t/* Update the report descriptor for only the Driving Force wheel */\n\t\tif (rev_maj == 1 && rev_min == 2 &&\n\t\t\t\t*rsize == DF_RDESC_ORIG_SIZE) {\n\t\t\thid_info(hdev,\n\t\t\t\t\"fixing up Logitech Driving Force report descriptor\\n\");\n\t\t\trdesc = df_rdesc_fixed;\n\t\t\t*rsize = sizeof(df_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\n\tcase USB_DEVICE_ID_LOGITECH_MOMO_WHEEL:\n\t\tif (*rsize == MOMO_RDESC_ORIG_SIZE) {\n\t\t\thid_info(hdev,\n\t\t\t\t\"fixing up Logitech Momo Force (Red) report descriptor\\n\");\n\t\t\trdesc = momo_rdesc_fixed;\n\t\t\t*rsize = sizeof(momo_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\n\tcase USB_DEVICE_ID_LOGITECH_MOMO_WHEEL2:\n\t\tif (*rsize == MOMO2_RDESC_ORIG_SIZE) {\n\t\t\thid_info(hdev,\n\t\t\t\t\"fixing up Logitech Momo Racing Force (Black) report descriptor\\n\");\n\t\t\trdesc = momo2_rdesc_fixed;\n\t\t\t*rsize = sizeof(momo2_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\n\tcase USB_DEVICE_ID_LOGITECH_VIBRATION_WHEEL:\n\t\tif (*rsize == FV_RDESC_ORIG_SIZE) {\n\t\t\thid_info(hdev,\n\t\t\t\t\"fixing up Logitech Formula Vibration report descriptor\\n\");\n\t\t\trdesc = fv_rdesc_fixed;\n\t\t\t*rsize = sizeof(fv_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\n\tcase USB_DEVICE_ID_LOGITECH_DFP_WHEEL:\n\t\tif (*rsize == DFP_RDESC_ORIG_SIZE) {\n\t\t\thid_info(hdev,\n\t\t\t\t\"fixing up Logitech Driving Force Pro report descriptor\\n\");\n\t\t\trdesc = dfp_rdesc_fixed;\n\t\t\t*rsize = sizeof(dfp_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\n\tcase USB_DEVICE_ID_LOGITECH_WII_WHEEL:\n\t\tif (*rsize >= 101 && rdesc[41] == 0x95 && rdesc[42] == 0x0B &&\n\t\t\t\trdesc[47] == 0x05 && rdesc[48] == 0x09) {\n\t\t\thid_info(hdev, \"fixing up Logitech Speed Force Wireless report descriptor\\n\");\n\t\t\trdesc[41] = 0x05;\n\t\t\trdesc[42] = 0x09;\n\t\t\trdesc[47] = 0x95;\n\t\t\trdesc[48] = 0x0B;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn rdesc;\n}\n", "target": 1, "idx": 179544}
{"func": "int handle(int s, unsigned char* data, int len, struct sockaddr_in *s_in)\n{\n\tchar buf[2048];\n\tunsigned short *cmd = (unsigned short *)buf;\n\tint plen;\n\tstruct in_addr *addr = &s_in->sin_addr;\n\tunsigned short *pid = (unsigned short*) data;\n\n\t/* inet check */\n\tif (len == S_HELLO_LEN && memcmp(data, \"sorbo\", 5) == 0) {\n\t\tunsigned short *id = (unsigned short*) (data+5);\n\t\tint x = 2+4+2;\n\n\t\t*cmd = htons(S_CMD_INET_CHECK);\n\t\tmemcpy(cmd+1, addr, 4);\n\t\tmemcpy(cmd+1+2, id, 2);\n\n\t\tprintf(\"Inet check by %s %d\\n\",\n\t\t       inet_ntoa(*addr), ntohs(*id));\n\t\tif (send(s, buf, x, 0) != x)\n\t\t\treturn 1;\n\n\t\treturn 0;\n\t}\n\n \t*cmd++ = htons(S_CMD_PACKET);\n \t*cmd++ = *pid;\n \tplen = len - 2;\n \n \tlast_id = ntohs(*pid);\n \tif (last_id > 20000)\n\t\twrap = 1;\n\tif (wrap && last_id < 100) {\n\t\twrap = 0;\n\t\tmemset(ids, 0, sizeof(ids));\n\t}\n\n\tprintf(\"Got packet %d %d\", last_id, plen);\n\tif (is_dup(last_id)) {\n\t\tprintf(\" (DUP)\\n\");\n\t\treturn 0;\n\t}\n\tprintf(\"\\n\");\n\n\t*cmd++ = htons(plen);\n\tmemcpy(cmd, data+2, plen);\n\n\tplen += 2 + 2 + 2;\n\tassert(plen <= (int) sizeof(buf));\n\tif (send(s, buf, plen, 0) != plen)\n\t\treturn 1;\n\n\treturn 0;\n}\n", "target": 1, "idx": 182085}
{"func": "static Image *ReadICONImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  IconFile\n    icon_file;\n\n  IconInfo\n    icon_info;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i,\n    x;\n\n  register Quantum\n    *q;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bit,\n    byte,\n    bytes_per_line,\n    one,\n    scanline_pad;\n\n  ssize_t\n    count,\n    offset,\n    y;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"%s\",image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  icon_file.reserved=(short) ReadBlobLSBShort(image);\n  icon_file.resource_type=(short) ReadBlobLSBShort(image);\n  icon_file.count=(short) ReadBlobLSBShort(image);\n  if ((icon_file.reserved != 0) ||\n      ((icon_file.resource_type != 1) && (icon_file.resource_type != 2)) ||\n      (icon_file.count > MaxIcons))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  for (i=0; i < icon_file.count; i++)\n  {\n    icon_file.directory[i].width=(unsigned char) ReadBlobByte(image);\n    icon_file.directory[i].height=(unsigned char) ReadBlobByte(image);\n    icon_file.directory[i].colors=(unsigned char) ReadBlobByte(image);\n    icon_file.directory[i].reserved=(unsigned char) ReadBlobByte(image);\n    icon_file.directory[i].planes=(unsigned short) ReadBlobLSBShort(image);\n    icon_file.directory[i].bits_per_pixel=(unsigned short)\n      ReadBlobLSBShort(image);\n    icon_file.directory[i].size=ReadBlobLSBLong(image);\n    icon_file.directory[i].offset=ReadBlobLSBLong(image);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n  }\n  one=1;\n  for (i=0; i < icon_file.count; i++)\n  {\n    /*\n      Verify Icon identifier.\n    */\n    offset=(ssize_t) SeekBlob(image,(MagickOffsetType)\n      icon_file.directory[i].offset,SEEK_SET);\n    if (offset < 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    icon_info.size=ReadBlobLSBLong(image);\n    icon_info.width=(unsigned char) ((int) ReadBlobLSBLong(image));\n    icon_info.height=(unsigned char) ((int) ReadBlobLSBLong(image)/2);\n    icon_info.planes=ReadBlobLSBShort(image);\n    icon_info.bits_per_pixel=ReadBlobLSBShort(image);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    if (((icon_info.planes == 18505) && (icon_info.bits_per_pixel == 21060)) || \n        (icon_info.size == 0x474e5089))\n      {\n        Image\n          *icon_image;\n\n        ImageInfo\n          *read_info;\n\n        size_t\n          length;\n\n        unsigned char\n          *png;\n\n        /*\n           Icon image encoded as a compressed PNG image.\n         */\n         length=icon_file.directory[i].size;\n         png=(unsigned char *) AcquireQuantumMemory(length+16,sizeof(*png));\n         if (png == (unsigned char *) NULL)\n           ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) CopyMagickMemory(png,\"\\211PNG\\r\\n\\032\\n\\000\\000\\000\\015\",12);\n        png[12]=(unsigned char) icon_info.planes;\n        png[13]=(unsigned char) (icon_info.planes >> 8);\n        png[14]=(unsigned char) icon_info.bits_per_pixel;\n        png[15]=(unsigned char) (icon_info.bits_per_pixel >> 8);\n        count=ReadBlob(image,length-16,png+16);\n        icon_image=(Image *) NULL;\n        if (count > 0)\n          {\n            read_info=CloneImageInfo(image_info);\n            (void) CopyMagickString(read_info->magick,\"PNG\",MagickPathExtent);\n            icon_image=BlobToImage(read_info,png,length+16,exception);\n            read_info=DestroyImageInfo(read_info);\n          }\n        png=(unsigned char *) RelinquishMagickMemory(png);\n        if (icon_image == (Image *) NULL)\n          {\n            if (count != (ssize_t) (length-16))\n              ThrowReaderException(CorruptImageError,\n                \"InsufficientImageDataInFile\");\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        DestroyBlob(icon_image);\n        icon_image->blob=ReferenceBlob(image->blob);\n        ReplaceImageInList(&image,icon_image);\n      }\n    else\n      {\n        if (icon_info.bits_per_pixel > 32)\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        icon_info.compression=ReadBlobLSBLong(image);\n        icon_info.image_size=ReadBlobLSBLong(image);\n        icon_info.x_pixels=ReadBlobLSBLong(image);\n        icon_info.y_pixels=ReadBlobLSBLong(image);\n        icon_info.number_colors=ReadBlobLSBLong(image);\n        icon_info.colors_important=ReadBlobLSBLong(image);\n        image->alpha_trait=BlendPixelTrait;\n        image->columns=(size_t) icon_file.directory[i].width;\n        if ((ssize_t) image->columns > icon_info.width)\n          image->columns=(size_t) icon_info.width;\n        if (image->columns == 0)\n          image->columns=256;\n        image->rows=(size_t) icon_file.directory[i].height;\n        if ((ssize_t) image->rows > icon_info.height)\n          image->rows=(size_t) icon_info.height;\n        if (image->rows == 0)\n          image->rows=256;\n        image->depth=icon_info.bits_per_pixel;\n        if (image->debug != MagickFalse)\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \" scene    = %.20g\",(double) i);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"   size   = %.20g\",(double) icon_info.size);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"   width  = %.20g\",(double) icon_file.directory[i].width);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"   height = %.20g\",(double) icon_file.directory[i].height);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"   colors = %.20g\",(double ) icon_info.number_colors);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"   planes = %.20g\",(double) icon_info.planes);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"   bpp    = %.20g\",(double) icon_info.bits_per_pixel);\n          }\n      if ((icon_info.number_colors != 0) || (icon_info.bits_per_pixel <= 16U))\n        {\n          image->storage_class=PseudoClass;\n          image->colors=icon_info.number_colors;\n          if (image->colors == 0)\n            image->colors=one << icon_info.bits_per_pixel;\n        }\n      if (image->storage_class == PseudoClass)\n        {\n          register ssize_t\n            i;\n\n          unsigned char\n            *icon_colormap;\n\n          /*\n            Read Icon raster colormap.\n          */\n          if (AcquireImageColormap(image,image->colors,exception) ==\n              MagickFalse)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          icon_colormap=(unsigned char *) AcquireQuantumMemory((size_t)\n            image->colors,4UL*sizeof(*icon_colormap));\n          if (icon_colormap == (unsigned char *) NULL)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          count=ReadBlob(image,(size_t) (4*image->colors),icon_colormap);\n          if (count != (ssize_t) (4*image->colors))\n            ThrowReaderException(CorruptImageError,\n              \"InsufficientImageDataInFile\");\n          p=icon_colormap;\n          for (i=0; i < (ssize_t) image->colors; i++)\n          {\n            image->colormap[i].blue=(Quantum) ScaleCharToQuantum(*p++);\n            image->colormap[i].green=(Quantum) ScaleCharToQuantum(*p++);\n            image->colormap[i].red=(Quantum) ScaleCharToQuantum(*p++);\n            p++;\n          }\n          icon_colormap=(unsigned char *) RelinquishMagickMemory(icon_colormap);\n        }\n        /*\n          Convert Icon raster image to pixel packets.\n        */\n        if ((image_info->ping != MagickFalse) &&\n            (image_info->number_scenes != 0))\n          if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n            break;\n        status=SetImageExtent(image,image->columns,image->rows,exception);\n        if (status == MagickFalse)\n          return(DestroyImageList(image));\n        bytes_per_line=(((image->columns*icon_info.bits_per_pixel)+31) &\n          ~31) >> 3;\n        (void) bytes_per_line;\n        scanline_pad=((((image->columns*icon_info.bits_per_pixel)+31) & ~31)-\n          (image->columns*icon_info.bits_per_pixel)) >> 3;\n        switch (icon_info.bits_per_pixel)\n        {\n          case 1:\n          {\n            /*\n              Convert bitmap scanline.\n            */\n            for (y=(ssize_t) image->rows-1; y >= 0; y--)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) (image->columns-7); x+=8)\n              {\n                byte=(size_t) ReadBlobByte(image);\n                for (bit=0; bit < 8; bit++)\n                {\n                  SetPixelIndex(image,((byte & (0x80 >> bit)) != 0 ? 0x01 :\n                    0x00),q);\n                  q+=GetPixelChannels(image);\n                }\n              }\n              if ((image->columns % 8) != 0)\n                {\n                  byte=(size_t) ReadBlobByte(image);\n                  for (bit=0; bit < (image->columns % 8); bit++)\n                  {\n                    SetPixelIndex(image,((byte & (0x80 >> bit)) != 0 ? 0x01 :\n                      0x00),q);\n                    q+=GetPixelChannels(image);\n                  }\n                }\n              for (x=0; x < (ssize_t) scanline_pad; x++)\n                (void) ReadBlobByte(image);\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,image->rows-y-1,\n                    image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            break;\n          }\n          case 4:\n          {\n            /*\n              Read 4-bit Icon scanline.\n            */\n            for (y=(ssize_t) image->rows-1; y >= 0; y--)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < ((ssize_t) image->columns-1); x+=2)\n              {\n                byte=(size_t) ReadBlobByte(image);\n                SetPixelIndex(image,((byte >> 4) & 0xf),q);\n                q+=GetPixelChannels(image);\n                SetPixelIndex(image,((byte) & 0xf),q);\n                q+=GetPixelChannels(image);\n              }\n              if ((image->columns % 2) != 0)\n                {\n                  byte=(size_t) ReadBlobByte(image);\n                  SetPixelIndex(image,((byte >> 4) & 0xf),q);\n                  q+=GetPixelChannels(image);\n                }\n              for (x=0; x < (ssize_t) scanline_pad; x++)\n                (void) ReadBlobByte(image);\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,image->rows-y-1,\n                    image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            break;\n          }\n          case 8:\n          {\n            /*\n              Convert PseudoColor scanline.\n            */\n            for (y=(ssize_t) image->rows-1; y >= 0; y--)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                byte=(size_t) ReadBlobByte(image);\n                SetPixelIndex(image,byte,q);\n                q+=GetPixelChannels(image);\n              }\n              for (x=0; x < (ssize_t) scanline_pad; x++)\n                (void) ReadBlobByte(image);\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,image->rows-y-1,\n                    image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            break;\n          }\n          case 16:\n          {\n            /*\n              Convert PseudoColor scanline.\n            */\n            for (y=(ssize_t) image->rows-1; y >= 0; y--)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                byte=(size_t) ReadBlobByte(image);\n                byte|=(size_t) (ReadBlobByte(image) << 8);\n                SetPixelIndex(image,byte,q);\n                q+=GetPixelChannels(image);\n              }\n              for (x=0; x < (ssize_t) scanline_pad; x++)\n                (void) ReadBlobByte(image);\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,image->rows-y-1,\n                    image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            break;\n          }\n          case 24:\n          case 32:\n          {\n            /*\n              Convert DirectColor scanline.\n            */\n            for (y=(ssize_t) image->rows-1; y >= 0; y--)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                SetPixelBlue(image,ScaleCharToQuantum((unsigned char)\n                  ReadBlobByte(image)),q);\n                SetPixelGreen(image,ScaleCharToQuantum((unsigned char)\n                  ReadBlobByte(image)),q);\n                SetPixelRed(image,ScaleCharToQuantum((unsigned char)\n                  ReadBlobByte(image)),q);\n                if (icon_info.bits_per_pixel == 32)\n                  SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)\n                    ReadBlobByte(image)),q);\n                q+=GetPixelChannels(image);\n              }\n              if (icon_info.bits_per_pixel == 24)\n                for (x=0; x < (ssize_t) scanline_pad; x++)\n                  (void) ReadBlobByte(image);\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,image->rows-y-1,\n                    image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            break;\n          }\n          default:\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        }\n        if (image_info->ping == MagickFalse)\n          (void) SyncImage(image,exception);\n        if (icon_info.bits_per_pixel != 32)\n          {\n            /*\n              Read the ICON alpha mask.\n            */\n            image->storage_class=DirectClass;\n            for (y=(ssize_t) image->rows-1; y >= 0; y--)\n            {\n              q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n              {\n                byte=(size_t) ReadBlobByte(image);\n                for (bit=0; bit < 8; bit++)\n                {\n                  SetPixelAlpha(image,(((byte & (0x80 >> bit)) != 0) ?\n                    TransparentAlpha : OpaqueAlpha),q);\n                  q+=GetPixelChannels(image);\n                }\n              }\n              if ((image->columns % 8) != 0)\n                {\n                  byte=(size_t) ReadBlobByte(image);\n                  for (bit=0; bit < (image->columns % 8); bit++)\n                  {\n                    SetPixelAlpha(image,(((byte & (0x80 >> bit)) != 0) ?\n                      TransparentAlpha : OpaqueAlpha),q);\n                    q+=GetPixelChannels(image);\n                  }\n                }\n              if ((image->columns % 32) != 0)\n                for (x=0; x < (ssize_t) ((32-(image->columns % 32))/8); x++)\n                  (void) ReadBlobByte(image);\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n            }\n          }\n        if (EOFBlob(image) != MagickFalse)\n          {\n            ThrowFileException(exception,CorruptImageError,\n              \"UnexpectedEndOfFile\",image->filename);\n            break;\n          }\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if (i < (ssize_t) (icon_file.count-1))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n", "target": 1, "idx": 182035}
{"func": " OMX_ERRORTYPE  omx_vdec::fill_this_buffer(OMX_IN OMX_HANDLETYPE  hComp,\n         OMX_IN OMX_BUFFERHEADERTYPE* buffer)\n {\n     unsigned nPortIndex = 0;\n     if (dynamic_buf_mode) {\n         private_handle_t *handle = NULL;\n struct VideoDecoderOutputMetaData *meta;\n unsigned int nPortIndex = 0;\n\n if (!buffer || !buffer->pBuffer) {\n            DEBUG_PRINT_ERROR(\"%s: invalid params: %p\", __FUNCTION__, buffer);\n return OMX_ErrorBadParameter;\n }\n\n        meta = (struct VideoDecoderOutputMetaData *)buffer->pBuffer;\n        handle = (private_handle_t *)meta->pHandle;\n        DEBUG_PRINT_LOW(\"FTB: metabuf: %p buftype: %d bufhndl: %p \", meta, meta->eType, meta->pHandle);\n\n if (!handle) {\n            DEBUG_PRINT_ERROR(\"FTB: Error: IL client passed an invalid buf handle - %p\", handle);\n return OMX_ErrorBadParameter;\n }\n\n        nPortIndex = buffer-((OMX_BUFFERHEADERTYPE *)client_buffers.get_il_buf_hdr());\n        drv_ctx.ptr_outputbuffer[nPortIndex].pmem_fd = handle->fd;\n        drv_ctx.ptr_outputbuffer[nPortIndex].bufferaddr = (OMX_U8*) buffer;\n\n        native_buffer[nPortIndex].privatehandle = handle;\n        native_buffer[nPortIndex].nativehandle = handle;\n\n        buffer->nFilledLen = 0;\n\n         buffer->nAllocLen = handle->size;\n     }\n \n    if (m_state == OMX_StateInvalid) {\n        DEBUG_PRINT_ERROR(\"FTB in Invalid State\");\n        return OMX_ErrorInvalidState;\n    }\n    if (!m_out_bEnabled) {\n        DEBUG_PRINT_ERROR(\"ERROR:FTB incorrect state operation, output port is disabled.\");\n        return OMX_ErrorIncorrectStateOperation;\n    }\n     nPortIndex = buffer - client_buffers.get_il_buf_hdr();\n     if (buffer == NULL ||\n             (nPortIndex >= drv_ctx.op_buf.actualcount)) {\n        DEBUG_PRINT_ERROR(\"FTB: ERROR: invalid buffer index, nPortIndex %u bufCount %u\",\n            nPortIndex, drv_ctx.op_buf.actualcount);\n return OMX_ErrorBadParameter;\n }\n\n if (buffer->nOutputPortIndex != OMX_CORE_OUTPUT_PORT_INDEX) {\n        DEBUG_PRINT_ERROR(\"ERROR:FTB invalid port in header %u\", (unsigned int)buffer->nOutputPortIndex);\n return OMX_ErrorBadPortIndex;\n }\n\n    DEBUG_PRINT_LOW(\"[FTB] bufhdr = %p, bufhdr->pBuffer = %p\", buffer, buffer->pBuffer);\n    post_event((unsigned long) hComp, (unsigned long)buffer, m_fill_output_msg);\n return OMX_ErrorNone;\n}\n", "target": 1, "idx": 187773}
{"func": " void WebPluginDelegateProxy::OnInitiateHTTPRangeRequest(\n    const std::string& url, const std::string& range_info,\n    intptr_t existing_stream, bool notify_needed, intptr_t notify_data) {\n  plugin_->InitiateHTTPRangeRequest(url.c_str(), range_info.c_str(),\n                                    existing_stream, notify_needed,\n                                    notify_data);\n }\n", "target": 1, "idx": 183578}
{"func": "string16 ConfirmEmailDialogDelegate::GetTitle() {\n  return l10n_util::GetStringUTF16(\n      IDS_ONE_CLICK_SIGNIN_CONFIRM_EMAIL_DIALOG_TITLE);\n}\n", "target": 0, "idx": 118080}
{"func": "void BrowserViewRenderer::ScrollTo(gfx::Vector2d scroll_offset) {\n   gfx::Vector2d max_offset = max_scroll_offset();\n   gfx::Vector2dF scroll_offset_dip;\n  if (max_offset.x()) {\n    scroll_offset_dip.set_x((scroll_offset.x() * max_scroll_offset_dip_.x()) /\n                            max_offset.x());\n  }\n  if (max_offset.y()) {\n    scroll_offset_dip.set_y((scroll_offset.y() * max_scroll_offset_dip_.y()) /\n                            max_offset.y());\n  }\n\n  DCHECK_LE(0.f, scroll_offset_dip.x());\n  DCHECK_LE(0.f, scroll_offset_dip.y());\n  DCHECK(scroll_offset_dip.x() < max_scroll_offset_dip_.x() ||\n         scroll_offset_dip.x() - max_scroll_offset_dip_.x() < kEpsilon)\n      << scroll_offset_dip.x() << \" \" << max_scroll_offset_dip_.x();\n  DCHECK(scroll_offset_dip.y() < max_scroll_offset_dip_.y() ||\n         scroll_offset_dip.y() - max_scroll_offset_dip_.y() < kEpsilon)\n      << scroll_offset_dip.y() << \" \" << max_scroll_offset_dip_.y();\n\n  if (scroll_offset_dip_ == scroll_offset_dip)\n    return;\n\n  scroll_offset_dip_ = scroll_offset_dip;\n\n  TRACE_EVENT_INSTANT2(\"android_webview\",\n               \"BrowserViewRenderer::ScrollTo\",\n               TRACE_EVENT_SCOPE_THREAD,\n               \"x\",\n               scroll_offset_dip.x(),\n               \"y\",\n               scroll_offset_dip.y());\n\n  if (compositor_) {\n    compositor_->DidChangeRootLayerScrollOffset(\n        gfx::ScrollOffset(scroll_offset_dip_));\n  }\n}\n", "target": 1, "idx": 185317}
{"func": "static u16 get_segment_reg(struct task_struct *task, unsigned long offset)\n{\n\t/*\n\t * Returning the value truncates it to 16 bits.\n\t */\n\tunsigned int seg;\n\n\tswitch (offset) {\n\tcase offsetof(struct user_regs_struct, fs):\n\t\tif (task == current) {\n\t\t\t/* Older gas can't assemble movq %?s,%r?? */\n\t\t\tasm(\"movl %%fs,%0\" : \"=r\" (seg));\n\t\t\treturn seg;\n\t\t}\n\t\treturn task->thread.fsindex;\n\tcase offsetof(struct user_regs_struct, gs):\n\t\tif (task == current) {\n\t\t\tasm(\"movl %%gs,%0\" : \"=r\" (seg));\n\t\t\treturn seg;\n\t\t}\n\t\treturn task->thread.gsindex;\n\tcase offsetof(struct user_regs_struct, ds):\n\t\tif (task == current) {\n\t\t\tasm(\"movl %%ds,%0\" : \"=r\" (seg));\n\t\t\treturn seg;\n\t\t}\n\t\treturn task->thread.ds;\n\tcase offsetof(struct user_regs_struct, es):\n\t\tif (task == current) {\n\t\t\tasm(\"movl %%es,%0\" : \"=r\" (seg));\n\t\t\treturn seg;\n\t\t}\n\t\treturn task->thread.es;\n\n\tcase offsetof(struct user_regs_struct, cs):\n\tcase offsetof(struct user_regs_struct, ss):\n\t\tbreak;\n\t}\n\treturn *pt_regs_access(task_pt_regs(task), offset);\n}\n", "target": 0, "idx": 25896}
{"func": "VisiblePosition WebLocalFrameImpl::VisiblePositionForViewportPoint(\n    const WebPoint& point_in_viewport) {\n  return VisiblePositionForContentsPoint(\n      GetFrame()->View()->ViewportToFrame(point_in_viewport), GetFrame());\n}\n", "target": 0, "idx": 158592}
{"func": " FileManagerPrivateCustomBindings::FileManagerPrivateCustomBindings(\n     ScriptContext* context)\n     : ObjectBackedNativeHandler(context) {\n   RouteFunction(\n      \"GetFileSystem\",\n       base::Bind(&FileManagerPrivateCustomBindings::GetFileSystem,\n                  base::Unretained(this)));\n }\n", "target": 1, "idx": 187296}
{"func": "  void DiscardAndExplicitlyReloadTest(DiscardReason reason) {\n    LifecycleUnit* background_lifecycle_unit = nullptr;\n    LifecycleUnit* foreground_lifecycle_unit = nullptr;\n    CreateTwoTabs(true /* focus_tab_strip */, &background_lifecycle_unit,\n                  &foreground_lifecycle_unit);\n    content::WebContents* initial_web_contents =\n        tab_strip_model_->GetWebContentsAt(0);\n\n     EXPECT_EQ(LifecycleUnitState::ACTIVE,\n               background_lifecycle_unit->GetState());\n    EXPECT_CALL(tab_observer_, OnDiscardedStateChange(testing::_, true));\n     background_lifecycle_unit->Discard(reason);\n    testing::Mock::VerifyAndClear(&tab_observer_);\n \n     TransitionFromPendingDiscardToDiscardedIfNeeded(reason,\n                                                     background_lifecycle_unit);\n\n    EXPECT_NE(initial_web_contents, tab_strip_model_->GetWebContentsAt(0));\n    EXPECT_FALSE(tab_strip_model_->GetWebContentsAt(0)\n                     ->GetController()\n                      .GetPendingEntry());\n \n    EXPECT_CALL(tab_observer_, OnDiscardedStateChange(testing::_, false));\n     tab_strip_model_->GetWebContentsAt(0)->GetController().Reload(\n         content::ReloadType::NORMAL, false);\n    testing::Mock::VerifyAndClear(&tab_observer_);\n     EXPECT_EQ(LifecycleUnitState::ACTIVE,\n               background_lifecycle_unit->GetState());\n     EXPECT_TRUE(tab_strip_model_->GetWebContentsAt(0)\n                    ->GetController()\n                    .GetPendingEntry());\n  }\n", "target": 1, "idx": 186193}
{"func": "parse_elements(netdissect_options *ndo,\n               struct mgmt_body_t *pbody, const u_char *p, int offset,\n               u_int length)\n{\n\tu_int elementlen;\n\tstruct ssid_t ssid;\n\tstruct challenge_t challenge;\n\tstruct rates_t rates;\n\tstruct ds_t ds;\n\tstruct cf_t cf;\n\tstruct tim_t tim;\n\n\t/*\n\t * We haven't seen any elements yet.\n\t */\n\tpbody->challenge_present = 0;\n\tpbody->ssid_present = 0;\n\tpbody->rates_present = 0;\n\tpbody->ds_present = 0;\n\tpbody->cf_present = 0;\n\tpbody->tim_present = 0;\n\n\twhile (length != 0) {\n\t\t/* Make sure we at least have the element ID and length. */\n\t\tif (!ND_TTEST2(*(p + offset), 2))\n\t\t\treturn 0;\n\t\tif (length < 2)\n\t\t\treturn 0;\n\t\telementlen = *(p + offset + 1);\n\n\t\t/* Make sure we have the entire element. */\n\t\tif (!ND_TTEST2(*(p + offset + 2), elementlen))\n\t\t\treturn 0;\n\t\tif (length < elementlen + 2)\n\t\t\treturn 0;\n\n\t\tswitch (*(p + offset)) {\n\t\tcase E_SSID:\n\t\t\tmemcpy(&ssid, p + offset, 2);\n\t\t\toffset += 2;\n\t\t\tlength -= 2;\n\t\t\tif (ssid.length != 0) {\n\t\t\t\tif (ssid.length > sizeof(ssid.ssid) - 1)\n\t\t\t\t\treturn 0;\n\t\t\t\tif (!ND_TTEST2(*(p + offset), ssid.length))\n\t\t\t\t\treturn 0;\n\t\t\t\tif (length < ssid.length)\n\t\t\t\t\treturn 0;\n\t\t\t\tmemcpy(&ssid.ssid, p + offset, ssid.length);\n\t\t\t\toffset += ssid.length;\n\t\t\t\tlength -= ssid.length;\n\t\t\t}\n\t\t\tssid.ssid[ssid.length] = '\\0';\n\t\t\t/*\n\t\t\t * Present and not truncated.\n\t\t\t *\n\t\t\t * If we haven't already seen an SSID IE,\n\t\t\t * copy this one, otherwise ignore this one,\n\t\t\t * so we later report the first one we saw.\n\t\t\t */\n\t\t\tif (!pbody->ssid_present) {\n\t\t\t\tpbody->ssid = ssid;\n\t\t\t\tpbody->ssid_present = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase E_CHALLENGE:\n\t\t\tmemcpy(&challenge, p + offset, 2);\n\t\t\toffset += 2;\n\t\t\tlength -= 2;\n\t\t\tif (challenge.length != 0) {\n\t\t\t\tif (challenge.length >\n\t\t\t\t    sizeof(challenge.text) - 1)\n\t\t\t\t\treturn 0;\n\t\t\t\tif (!ND_TTEST2(*(p + offset), challenge.length))\n\t\t\t\t\treturn 0;\n\t\t\t\tif (length < challenge.length)\n\t\t\t\t\treturn 0;\n\t\t\t\tmemcpy(&challenge.text, p + offset,\n\t\t\t\t    challenge.length);\n\t\t\t\toffset += challenge.length;\n\t\t\t\tlength -= challenge.length;\n\t\t\t}\n\t\t\tchallenge.text[challenge.length] = '\\0';\n\t\t\t/*\n\t\t\t * Present and not truncated.\n\t\t\t *\n\t\t\t * If we haven't already seen a challenge IE,\n\t\t\t * copy this one, otherwise ignore this one,\n\t\t\t * so we later report the first one we saw.\n\t\t\t */\n\t\t\tif (!pbody->challenge_present) {\n\t\t\t\tpbody->challenge = challenge;\n\t\t\t\tpbody->challenge_present = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase E_RATES:\n\t\t\tmemcpy(&rates, p + offset, 2);\n\t\t\toffset += 2;\n\t\t\tlength -= 2;\n\t\t\tif (rates.length != 0) {\n\t\t\t\tif (rates.length > sizeof rates.rate)\n\t\t\t\t\treturn 0;\n\t\t\t\tif (!ND_TTEST2(*(p + offset), rates.length))\n\t\t\t\t\treturn 0;\n\t\t\t\tif (length < rates.length)\n\t\t\t\t\treturn 0;\n\t\t\t\tmemcpy(&rates.rate, p + offset, rates.length);\n\t\t\t\toffset += rates.length;\n\t\t\t\tlength -= rates.length;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Present and not truncated.\n\t\t\t *\n\t\t\t * If we haven't already seen a rates IE,\n\t\t\t * copy this one if it's not zero-length,\n\t\t\t * otherwise ignore this one, so we later\n\t\t\t * report the first one we saw.\n\t\t\t *\n\t\t\t * We ignore zero-length rates IEs as some\n\t\t\t * devices seem to put a zero-length rates\n\t\t\t * IE, followed by an SSID IE, followed by\n\t\t\t * a non-zero-length rates IE into frames,\n\t\t\t * even though IEEE Std 802.11-2007 doesn't\n\t\t\t * seem to indicate that a zero-length rates\n\t\t\t * IE is valid.\n\t\t\t */\n\t\t\tif (!pbody->rates_present && rates.length != 0) {\n\t\t\t\tpbody->rates = rates;\n\t\t\t\tpbody->rates_present = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase E_DS:\n\t\t\tmemcpy(&ds, p + offset, 2);\n\t\t\toffset += 2;\n\t\t\tlength -= 2;\n\t\t\tif (ds.length != 1) {\n\t\t\t\toffset += ds.length;\n\t\t\t\tlength -= ds.length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tds.channel = *(p + offset);\n\t\t\toffset += 1;\n\t\t\tlength -= 1;\n\t\t\t/*\n\t\t\t * Present and not truncated.\n\t\t\t *\n\t\t\t * If we haven't already seen a DS IE,\n\t\t\t * copy this one, otherwise ignore this one,\n\t\t\t * so we later report the first one we saw.\n\t\t\t */\n\t\t\tif (!pbody->ds_present) {\n\t\t\t\tpbody->ds = ds;\n\t\t\t\tpbody->ds_present = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase E_CF:\n\t\t\tmemcpy(&cf, p + offset, 2);\n\t\t\toffset += 2;\n\t\t\tlength -= 2;\n\t\t\tif (cf.length != 6) {\n\t\t\t\toffset += cf.length;\n\t\t\t\tlength -= cf.length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(&cf.count, p + offset, 6);\n\t\t\toffset += 6;\n\t\t\tlength -= 6;\n\t\t\t/*\n\t\t\t * Present and not truncated.\n\t\t\t *\n\t\t\t * If we haven't already seen a CF IE,\n\t\t\t * copy this one, otherwise ignore this one,\n\t\t\t * so we later report the first one we saw.\n\t\t\t */\n\t\t\tif (!pbody->cf_present) {\n\t\t\t\tpbody->cf = cf;\n\t\t\t\tpbody->cf_present = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase E_TIM:\n\t\t\tmemcpy(&tim, p + offset, 2);\n\t\t\toffset += 2;\n\t\t\tlength -= 2;\n\t\t\tif (tim.length <= 3) {\n\t\t\t\toffset += tim.length;\n\t\t\t\tlength -= tim.length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (tim.length - 3 > (int)sizeof tim.bitmap)\n\t\t\t\treturn 0;\n\t\t\tmemcpy(&tim.count, p + offset, 3);\n \t\t\toffset += 3;\n \t\t\tlength -= 3;\n \n\t\t\tmemcpy(tim.bitmap, p + (tim.length - 3),\n\t\t\t    (tim.length - 3));\n \t\t\toffset += tim.length - 3;\n \t\t\tlength -= tim.length - 3;\n \t\t\t/*\n\t\t\t * Present and not truncated.\n\t\t\t *\n\t\t\t * If we haven't already seen a TIM IE,\n\t\t\t * copy this one, otherwise ignore this one,\n\t\t\t * so we later report the first one we saw.\n\t\t\t */\n\t\t\tif (!pbody->tim_present) {\n\t\t\t\tpbody->tim = tim;\n\t\t\t\tpbody->tim_present = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n#if 0\n\t\t\tND_PRINT((ndo, \"(1) unhandled element_id (%d)  \",\n\t\t\t    *(p + offset)));\n#endif\n\t\t\toffset += 2 + elementlen;\n\t\t\tlength -= 2 + elementlen;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* No problems found. */\n\treturn 1;\n}\n", "target": 1, "idx": 183204}
{"func": "options_for_tty()\n{\n    char *dev, *path, *p;\n    int ret;\n    size_t pl;\n\n    dev = devnam;\n    if ((p = strstr(dev, \"/dev/\")) != NULL)\n\tdev = p + 5;\n    if (dev[0] == 0 || strcmp(dev, \"tty\") == 0)\n\treturn 1;\t\t/* don't look for /etc/ppp/options.tty */\n    pl = strlen(_PATH_TTYOPT) + strlen(dev) + 1;\n    path = malloc(pl);\n    if (path == NULL)\n\tnovm(\"tty init file name\");\n    slprintf(path, pl, \"%s%s\", _PATH_TTYOPT, dev);\n    /* Turn slashes into dots, for Solaris case (e.g. /dev/term/a) */\n    for (p = path + strlen(_PATH_TTYOPT); *p != 0; ++p)\n\tif (*p == '/')\n\t    *p = '.';\n    option_priority = OPRIO_CFGFILE;\n    ret = options_from_file(path, 0, 0, 1);\n    free(path);\n    return ret;\n}\n", "target": 0, "idx": 38162}
{"func": "int effect_command(effect_handle_t self, uint32_t cmdCode, uint32_t cmdSize,\n void *pCmdData, uint32_t *replySize, void *pReplyData)\n{\n\n effect_context_t * context = (effect_context_t *)self;\n int retsize;\n int status = 0;\n\n    pthread_mutex_lock(&lock);\n\n if (!effect_exists(context)) {\n        status = -ENOSYS;\n goto exit;\n }\n\n if (context == NULL || context->state == EFFECT_STATE_UNINITIALIZED) {\n        status = -ENOSYS;\n goto exit;\n }\n\n switch (cmdCode) {\n case EFFECT_CMD_INIT:\n if (pReplyData == NULL || *replySize != sizeof(int)) {\n            status = -EINVAL;\n goto exit;\n }\n if (context->ops.init)\n *(int *) pReplyData = context->ops.init(context);\n else\n *(int *) pReplyData = 0;\n break;\n case EFFECT_CMD_SET_CONFIG:\n if (pCmdData == NULL || cmdSize != sizeof(effect_config_t)\n || pReplyData == NULL || *replySize != sizeof(int)) {\n            status = -EINVAL;\n goto exit;\n }\n *(int *) pReplyData = set_config(context, (effect_config_t *) pCmdData);\n break;\n case EFFECT_CMD_GET_CONFIG:\n if (pReplyData == NULL ||\n *replySize != sizeof(effect_config_t)) {\n            status = -EINVAL;\n goto exit;\n }\n if (!context->offload_enabled) {\n            status = -EINVAL;\n goto exit;\n }\n\n        get_config(context, (effect_config_t *)pReplyData);\n break;\n case EFFECT_CMD_RESET:\n if (context->ops.reset)\n            context->ops.reset(context);\n break;\n case EFFECT_CMD_ENABLE:\n if (pReplyData == NULL || *replySize != sizeof(int)) {\n            status = -EINVAL;\n goto exit;\n }\n if (context->state != EFFECT_STATE_INITIALIZED) {\n            status = -ENOSYS;\n goto exit;\n }\n        context->state = EFFECT_STATE_ACTIVE;\n if (context->ops.enable)\n            context->ops.enable(context);\n        ALOGV(\"%s EFFECT_CMD_ENABLE\", __func__);\n *(int *)pReplyData = 0;\n break;\n case EFFECT_CMD_DISABLE:\n if (pReplyData == NULL || *replySize != sizeof(int)) {\n            status = -EINVAL;\n goto exit;\n }\n if (context->state != EFFECT_STATE_ACTIVE) {\n            status = -ENOSYS;\n goto exit;\n }\n        context->state = EFFECT_STATE_INITIALIZED;\n if (context->ops.disable)\n            context->ops.disable(context);\n        ALOGV(\"%s EFFECT_CMD_DISABLE\", __func__);\n *(int *)pReplyData = 0;\n break;\n case EFFECT_CMD_GET_PARAM: {\n\n         if (pCmdData == NULL ||\n             cmdSize < (int)(sizeof(effect_param_t) + sizeof(uint32_t)) ||\n             pReplyData == NULL ||\n            *replySize < (int)(sizeof(effect_param_t) + sizeof(uint32_t) +\n                               sizeof(uint16_t))) {\n             status = -EINVAL;\n             ALOGV(\"EFFECT_CMD_GET_PARAM invalid command cmdSize %d *replySize %d\",\n                   cmdSize, *replySize);\n goto exit;\n }\n if (!context->offload_enabled) {\n            status = -EINVAL;\n goto exit;\n }\n effect_param_t *q = (effect_param_t *)pCmdData;\n        memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + q->psize);\n effect_param_t *p = (effect_param_t *)pReplyData;\n if (context->ops.get_parameter)\n            context->ops.get_parameter(context, p, replySize);\n } break;\n case EFFECT_CMD_SET_PARAM: {\n if (pCmdData == NULL ||\n            cmdSize < (int)(sizeof(effect_param_t) + sizeof(uint32_t) +\n sizeof(uint16_t)) ||\n            pReplyData == NULL || *replySize != sizeof(int32_t)) {\n            status = -EINVAL;\n            ALOGV(\"EFFECT_CMD_SET_PARAM invalid command cmdSize %d *replySize %d\",\n                  cmdSize, *replySize);\n goto exit;\n }\n *(int32_t *)pReplyData = 0;\n effect_param_t *p = (effect_param_t *)pCmdData;\n if (context->ops.set_parameter)\n *(int32_t *)pReplyData = context->ops.set_parameter(context, p,\n *replySize);\n\n } break;\n case EFFECT_CMD_SET_DEVICE: {\n uint32_t device;\n        ALOGV(\"\\t EFFECT_CMD_SET_DEVICE start\");\n if (pCmdData == NULL || cmdSize < sizeof(uint32_t)) {\n            status = -EINVAL;\n            ALOGV(\"EFFECT_CMD_SET_DEVICE invalid command cmdSize %d\", cmdSize);\n goto exit;\n }\n        device = *(uint32_t *)pCmdData;\n if (context->ops.set_device)\n            context->ops.set_device(context, device);\n } break;\n case EFFECT_CMD_SET_VOLUME:\n case EFFECT_CMD_SET_AUDIO_MODE:\n break;\n\n case EFFECT_CMD_OFFLOAD: {\n output_context_t *out_ctxt;\n\n if (cmdSize != sizeof(effect_offload_param_t) || pCmdData == NULL\n || pReplyData == NULL || *replySize != sizeof(int)) {\n            ALOGV(\"%s EFFECT_CMD_OFFLOAD bad format\", __func__);\n            status = -EINVAL;\n break;\n }\n\n effect_offload_param_t* offload_param = (effect_offload_param_t*)pCmdData;\n\n        ALOGV(\"%s EFFECT_CMD_OFFLOAD offload %d output %d\", __func__,\n              offload_param->isOffload, offload_param->ioHandle);\n\n *(int *)pReplyData = 0;\n\n        context->offload_enabled = offload_param->isOffload;\n if (context->out_handle == offload_param->ioHandle)\n break;\n\n        out_ctxt = get_output(context->out_handle);\n if (out_ctxt != NULL)\n            remove_effect_from_output(out_ctxt, context);\n\n        context->out_handle = offload_param->ioHandle;\n        out_ctxt = get_output(context->out_handle);\n if (out_ctxt != NULL)\n            add_effect_to_output(out_ctxt, context);\n\n } break;\n\n\n default:\n if (cmdCode >= EFFECT_CMD_FIRST_PROPRIETARY && context->ops.command)\n            status = context->ops.command(context, cmdCode, cmdSize,\n                                          pCmdData, replySize, pReplyData);\n else {\n            ALOGW(\"%s invalid command %d\", __func__, cmdCode);\n            status = -EINVAL;\n }\n break;\n }\n\nexit:\n    pthread_mutex_unlock(&lock);\n\n return status;\n}\n", "target": 1, "idx": 187777}
{"func": "static MagickBooleanType InverseFourierTransformChannel(\n  const Image *magnitude_image,const Image *phase_image,\n  const PixelChannel channel,const MagickBooleanType modulus,\n  Image *fourier_image,ExceptionInfo *exception)\n{\n  fftw_complex\n    *inverse_pixels;\n\n  FourierInfo\n    fourier_info;\n\n  MagickBooleanType\n    status;\n\n  MemoryInfo\n    *inverse_info;\n\n  fourier_info.width=magnitude_image->columns;\n  fourier_info.height=magnitude_image->rows;\n  if ((magnitude_image->columns != magnitude_image->rows) ||\n      ((magnitude_image->columns % 2) != 0) ||\n      ((magnitude_image->rows % 2) != 0))\n    {\n      size_t extent=magnitude_image->columns < magnitude_image->rows ?\n        magnitude_image->rows : magnitude_image->columns;\n      fourier_info.width=(extent & 0x01) == 1 ? extent+1UL : extent;\n    }\n  fourier_info.height=fourier_info.width;\n  fourier_info.center=(ssize_t) (fourier_info.width/2L)+1L;\n  fourier_info.channel=channel;\n  fourier_info.modulus=modulus;\n  inverse_info=AcquireVirtualMemory((size_t) fourier_info.width,\n    (fourier_info.height/2+1)*sizeof(*inverse_pixels));\n  if (inverse_info == (MemoryInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\n        magnitude_image->filename);\n      return(MagickFalse);\n    }\n  inverse_pixels=(fftw_complex *) GetVirtualMemoryBlob(inverse_info);\n  status=InverseFourier(&fourier_info,magnitude_image,phase_image,\n    inverse_pixels,exception);\n  if (status != MagickFalse)\n    status=InverseFourierTransform(&fourier_info,inverse_pixels,fourier_image,\n      exception);\n  inverse_info=RelinquishVirtualMemory(inverse_info);\n  return(status);\n}\n", "target": 0, "idx": 88969}
{"func": "char* _single_string_alloc_and_copy( LPCWSTR in )\n{\n    char *chr;\n    int len = 0;\n \n     if ( !in )\n     {\n        return in;\n     }\n \n     while ( in[ len ] != 0 )\n    {\n        len ++;\n    }\n\n    chr = malloc( len + 1 );\n\n    len = 0;\n    while ( in[ len ] != 0 )\n    {\n        chr[ len ] = 0xFF & in[ len ];\n        len ++;\n    }\n    chr[ len ++ ] = '\\0';\n\n    return chr;\n}\n", "target": 1, "idx": 182487}
{"func": "void *sctp_addto_chunk(struct sctp_chunk *chunk, int len, const void *data)\n{\n\tvoid *target;\n\tvoid *padding;\n\tint chunklen = ntohs(chunk->chunk_hdr->length);\n\tint padlen = WORD_ROUND(chunklen) - chunklen;\n\n\tpadding = skb_put(chunk->skb, padlen);\n\ttarget = skb_put(chunk->skb, len);\n\n\tmemset(padding, 0, padlen);\n\tmemcpy(target, data, len);\n\n\t/* Adjust the chunk length field.  */\n\tchunk->chunk_hdr->length = htons(chunklen + padlen + len);\n\tchunk->chunk_end = skb_tail_pointer(chunk->skb);\n\n\treturn target;\n}\n", "target": 0, "idx": 35831}
{"func": "int mbedtls_ecdsa_sign_det( mbedtls_ecp_group *grp, mbedtls_mpi *r, mbedtls_mpi *s,\n                    const mbedtls_mpi *d, const unsigned char *buf, size_t blen,\n                    mbedtls_md_type_t md_alg )\n {\n     int ret;\n     mbedtls_hmac_drbg_context rng_ctx;\n     unsigned char data[2 * MBEDTLS_ECP_MAX_BYTES];\n     size_t grp_len = ( grp->nbits + 7 ) / 8;\n     const mbedtls_md_info_t *md_info;\n     mbedtls_mpi h;\n \n     if( ( md_info = mbedtls_md_info_from_type( md_alg ) ) == NULL )\n         return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );\n \n     mbedtls_mpi_init( &h );\n     mbedtls_hmac_drbg_init( &rng_ctx );\n \n     /* Use private key and message hash (reduced) to initialize HMAC_DRBG */\n     MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( d, data, grp_len ) );\n     MBEDTLS_MPI_CHK( derive_mpi( grp, &h, buf, blen ) );\n     MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &h, data + grp_len, grp_len ) );\n     mbedtls_hmac_drbg_seed_buf( &rng_ctx, md_info, data, 2 * grp_len );\n \n    ret = mbedtls_ecdsa_sign( grp, r, s, d, buf, blen,\n                      mbedtls_hmac_drbg_random, &rng_ctx );\n \n cleanup:\n     mbedtls_hmac_drbg_free( &rng_ctx );\n     mbedtls_mpi_free( &h );\n \n     return( ret );\n }\n", "target": 1, "idx": 183353}
{"func": "static int asf_read_marker(AVFormatContext *s, int64_t size)\n{\n    AVIOContext *pb = s->pb;\n    ASFContext *asf = s->priv_data;\n    int i, count, name_len, ret;\n    char name[1024];\n\n    avio_rl64(pb);            // reserved 16 bytes\n    avio_rl64(pb);            // ...\n     count = avio_rl32(pb);    // markers count\n     avio_rl16(pb);            // reserved 2 bytes\n     name_len = avio_rl16(pb); // name length\n    for (i = 0; i < name_len; i++)\n        avio_r8(pb); // skip the name\n \n     for (i = 0; i < count; i++) {\n         int64_t pres_time;\n         int name_len;\n \n         avio_rl64(pb);             // offset, 8 bytes\n         pres_time = avio_rl64(pb); // presentation time\n         pres_time -= asf->hdr.preroll * 10000;\n        avio_rl16(pb);             // entry length\n        avio_rl32(pb);             // send time\n        avio_rl32(pb);             // flags\n        name_len = avio_rl32(pb);  // name length\n        if ((ret = avio_get_str16le(pb, name_len * 2, name,\n                                    sizeof(name))) < name_len)\n            avio_skip(pb, name_len - ret);\n        avpriv_new_chapter(s, i, (AVRational) { 1, 10000000 }, pres_time,\n                           AV_NOPTS_VALUE, name);\n    }\n\n    return 0;\n}\n", "target": 1, "idx": 180947}
{"func": "std::string ChromeContentBrowserClient::GetStoragePartitionIdForSite(\n    content::BrowserContext* browser_context,\n    const GURL& site) {\n  std::string partition_id;\n\n  if (site.SchemeIs(content::kGuestScheme))\n    partition_id = site.spec();\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n  else if (site.SchemeIs(extensions::kExtensionScheme) &&\n           extensions::util::SiteHasIsolatedStorage(site, browser_context))\n    partition_id = site.spec();\n#endif\n\n  DCHECK(IsValidStoragePartitionId(browser_context, partition_id));\n  return partition_id;\n}\n", "target": 0, "idx": 155371}
{"func": "static int dccp_v6_rcv(struct sk_buff *skb)\n{\n\tconst struct dccp_hdr *dh;\n\tbool refcounted;\n\tstruct sock *sk;\n\tint min_cov;\n\n\t/* Step 1: Check header basics */\n\n\tif (dccp_invalid_packet(skb))\n\t\tgoto discard_it;\n\n\t/* Step 1: If header checksum is incorrect, drop packet and return. */\n\tif (dccp_v6_csum_finish(skb, &ipv6_hdr(skb)->saddr,\n\t\t\t\t     &ipv6_hdr(skb)->daddr)) {\n\t\tDCCP_WARN(\"dropped packet with invalid checksum\\n\");\n\t\tgoto discard_it;\n\t}\n\n\tdh = dccp_hdr(skb);\n\n\tDCCP_SKB_CB(skb)->dccpd_seq  = dccp_hdr_seq(dh);\n\tDCCP_SKB_CB(skb)->dccpd_type = dh->dccph_type;\n\n\tif (dccp_packet_without_ack(skb))\n\t\tDCCP_SKB_CB(skb)->dccpd_ack_seq = DCCP_PKT_WITHOUT_ACK_SEQ;\n\telse\n\t\tDCCP_SKB_CB(skb)->dccpd_ack_seq = dccp_hdr_ack_seq(skb);\n\nlookup:\n\tsk = __inet6_lookup_skb(&dccp_hashinfo, skb, __dccp_hdr_len(dh),\n\t\t\t        dh->dccph_sport, dh->dccph_dport,\n\t\t\t\tinet6_iif(skb), &refcounted);\n\tif (!sk) {\n\t\tdccp_pr_debug(\"failed to look up flow ID in table and \"\n\t\t\t      \"get corresponding socket\\n\");\n\t\tgoto no_dccp_socket;\n\t}\n\n\t/*\n\t * Step 2:\n\t *\t... or S.state == TIMEWAIT,\n\t *\t\tGenerate Reset(No Connection) unless P.type == Reset\n\t *\t\tDrop packet and return\n\t */\n\tif (sk->sk_state == DCCP_TIME_WAIT) {\n\t\tdccp_pr_debug(\"sk->sk_state == DCCP_TIME_WAIT: do_time_wait\\n\");\n\t\tinet_twsk_put(inet_twsk(sk));\n\t\tgoto no_dccp_socket;\n\t}\n\n\tif (sk->sk_state == DCCP_NEW_SYN_RECV) {\n\t\tstruct request_sock *req = inet_reqsk(sk);\n\t\tstruct sock *nsk;\n\n\t\tsk = req->rsk_listener;\n\t\tif (unlikely(sk->sk_state != DCCP_LISTEN)) {\n\t\t\tinet_csk_reqsk_queue_drop_and_put(sk, req);\n\t\t\tgoto lookup;\n\t\t}\n\t\tsock_hold(sk);\n\t\trefcounted = true;\n\t\tnsk = dccp_check_req(sk, skb, req);\n\t\tif (!nsk) {\n\t\t\treqsk_put(req);\n\t\t\tgoto discard_and_relse;\n\t\t}\n\t\tif (nsk == sk) {\n\t\t\treqsk_put(req);\n\t\t} else if (dccp_child_process(sk, nsk, skb)) {\n\t\t\tdccp_v6_ctl_send_reset(sk, skb);\n\t\t\tgoto discard_and_relse;\n\t\t} else {\n\t\t\tsock_put(sk);\n\t\t\treturn 0;\n\t\t}\n\t}\n\t/*\n\t * RFC 4340, sec. 9.2.1: Minimum Checksum Coverage\n\t *\to if MinCsCov = 0, only packets with CsCov = 0 are accepted\n\t *\to if MinCsCov > 0, also accept packets with CsCov >= MinCsCov\n\t */\n\tmin_cov = dccp_sk(sk)->dccps_pcrlen;\n\tif (dh->dccph_cscov  &&  (min_cov == 0 || dh->dccph_cscov < min_cov))  {\n\t\tdccp_pr_debug(\"Packet CsCov %d does not satisfy MinCsCov %d\\n\",\n\t\t\t      dh->dccph_cscov, min_cov);\n\t\t/* FIXME: send Data Dropped option (see also dccp_v4_rcv) */\n\t\tgoto discard_and_relse;\n\t}\n\n\tif (!xfrm6_policy_check(sk, XFRM_POLICY_IN, skb))\n\t\tgoto discard_and_relse;\n\n\treturn __sk_receive_skb(sk, skb, 1, dh->dccph_doff * 4,\n\t\t\t\trefcounted) ? -1 : 0;\n\nno_dccp_socket:\n\tif (!xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb))\n\t\tgoto discard_it;\n\t/*\n\t * Step 2:\n\t *\tIf no socket ...\n\t *\t\tGenerate Reset(No Connection) unless P.type == Reset\n\t *\t\tDrop packet and return\n\t */\n\tif (dh->dccph_type != DCCP_PKT_RESET) {\n\t\tDCCP_SKB_CB(skb)->dccpd_reset_code =\n\t\t\t\t\tDCCP_RESET_CODE_NO_CONNECTION;\n\t\tdccp_v6_ctl_send_reset(sk, skb);\n\t}\n\ndiscard_it:\n\tkfree_skb(skb);\n\treturn 0;\n\ndiscard_and_relse:\n\tif (refcounted)\n\t\tsock_put(sk);\n\tgoto discard_it;\n}\n", "target": 0, "idx": 65141}
{"func": "static int protocol_client_auth(VncState *vs, uint8_t *data, size_t len)\n{\n    /* We only advertise 1 auth scheme at a time, so client\n     * must pick the one we sent. Verify this */\n    if (data[0] != vs->auth) { /* Reject auth */\n       VNC_DEBUG(\"Reject auth %d because it didn't match advertized\\n\", (int)data[0]);\n       vnc_write_u32(vs, 1);\n       if (vs->minor >= 8) {\n           static const char err[] = \"Authentication failed\";\n           vnc_write_u32(vs, sizeof(err));\n           vnc_write(vs, err, sizeof(err));\n       }\n       vnc_client_error(vs);\n    } else { /* Accept requested auth */\n       VNC_DEBUG(\"Client requested auth %d\\n\", (int)data[0]);\n       switch (vs->auth) {\n       case VNC_AUTH_NONE:\n           VNC_DEBUG(\"Accept auth none\\n\");\n           if (vs->minor >= 8) {\n               vnc_write_u32(vs, 0); /* Accept auth completion */\n               vnc_flush(vs);\n           }\n           start_client_init(vs);\n           break;\n\n       case VNC_AUTH_VNC:\n           VNC_DEBUG(\"Start VNC auth\\n\");\n           start_auth_vnc(vs);\n           break;\n\n#ifdef CONFIG_VNC_TLS\n       case VNC_AUTH_VENCRYPT:\n           VNC_DEBUG(\"Accept VeNCrypt auth\\n\");\n           start_auth_vencrypt(vs);\n           break;\n#endif /* CONFIG_VNC_TLS */\n\n#ifdef CONFIG_VNC_SASL\n       case VNC_AUTH_SASL:\n           VNC_DEBUG(\"Accept SASL auth\\n\");\n           start_auth_sasl(vs);\n           break;\n#endif /* CONFIG_VNC_SASL */\n\n       default: /* Should not be possible, but just in case */\n           VNC_DEBUG(\"Reject auth %d server code bug\\n\", vs->auth);\n           vnc_write_u8(vs, 1);\n           if (vs->minor >= 8) {\n               static const char err[] = \"Authentication failed\";\n               vnc_write_u32(vs, sizeof(err));\n               vnc_write(vs, err, sizeof(err));\n           }\n           vnc_client_error(vs);\n       }\n    }\n    return 0;\n}\n", "target": 0, "idx": 7971}
{"func": "gfx::Insets ScrollableShelfView::CalculatePaddingForDisplayCentering() const {\n  const int icons_size = shelf_view_->GetSizeOfAppIcons(\n      shelf_view_->number_of_visible_apps(), false);\n  const gfx::Rect display_bounds =\n      screen_util::GetDisplayBoundsWithShelf(GetWidget()->GetNativeWindow());\n  const int display_size_primary = GetShelf()->PrimaryAxisValue(\n      display_bounds.width(), display_bounds.height());\n  const int gap = (display_size_primary - icons_size) / 2;\n \n   const gfx::Rect screen_bounds = GetBoundsInScreen();\n  const int left_padding = gap - GetShelf()->PrimaryAxisValue(\n                                     screen_bounds.x() - display_bounds.x(),\n                                     screen_bounds.y() - display_bounds.y());\n  const int right_padding =\n       gap - GetShelf()->PrimaryAxisValue(\n                 display_bounds.right() - screen_bounds.right(),\n                 display_bounds.bottom() - screen_bounds.bottom());\n \n  return gfx::Insets(0, left_padding, 0, right_padding);\n }\n", "target": 1, "idx": 187152}
{"func": "enum ImapAuthRes imap_auth_login(struct ImapData *idata, const char *method)\n{\n  char q_user[SHORT_STRING], q_pass[SHORT_STRING];\n  char buf[STRING];\n  int rc;\n\n  if (mutt_bit_isset(idata->capabilities, LOGINDISABLED))\n  {\n    mutt_message(_(\"LOGIN disabled on this server.\"));\n    return IMAP_AUTH_UNAVAIL;\n  }\n\n  if (mutt_account_getuser(&idata->conn->account) < 0)\n    return IMAP_AUTH_FAILURE;\n  if (mutt_account_getpass(&idata->conn->account) < 0)\n    return IMAP_AUTH_FAILURE;\n \n   mutt_message(_(\"Logging in...\"));\n \n  imap_quote_string(q_user, sizeof(q_user), idata->conn->account.user);\n  imap_quote_string(q_pass, sizeof(q_pass), idata->conn->account.pass);\n \n   /* don't print the password unless we're at the ungodly debugging level\n    * of 5 or higher */\n\n  if (DebugLevel < IMAP_LOG_PASS)\n    mutt_debug(2, \"Sending LOGIN command for %s...\\n\", idata->conn->account.user);\n\n  snprintf(buf, sizeof(buf), \"LOGIN %s %s\", q_user, q_pass);\n  rc = imap_exec(idata, buf, IMAP_CMD_FAIL_OK | IMAP_CMD_PASS);\n\n  if (!rc)\n  {\n    mutt_clear_error(); /* clear \"Logging in...\".  fixes #3524 */\n    return IMAP_AUTH_SUCCESS;\n  }\n\n  mutt_error(_(\"Login failed.\"));\n  return IMAP_AUTH_FAILURE;\n}\n", "target": 1, "idx": 182305}
{"func": "validate_event(struct pmu_hw_events *hw_events,\n\t       struct perf_event *event)\n {\n\tstruct arm_pmu *armpmu = to_arm_pmu(event->pmu);\n \tstruct hw_perf_event fake_event = event->hw;\n \tstruct pmu *leader_pmu = event->group_leader->pmu;\n \n \tif (is_software_event(event))\n \t\treturn 1;\n \n \tif (event->pmu != leader_pmu || event->state < PERF_EVENT_STATE_OFF)\n \t\treturn 1;\n \n \tif (event->state == PERF_EVENT_STATE_OFF && !event->attr.enable_on_exec)\n \t\treturn 1;\n \n \treturn armpmu->get_event_idx(hw_events, &fake_event) >= 0;\n }\n", "target": 1, "idx": 180639}
{"func": "void XMLHttpRequest::internalAbort(DropProtection async)\n{\n    m_error = true;\n\n    m_receivedLength = 0;\n    m_decoder = 0;\n\n    InspectorInstrumentation::didFailXHRLoading(scriptExecutionContext(), this);\n\n    if (m_responseStream && m_state != DONE)\n        m_responseStream->abort();\n\n    if (!m_loader)\n        return;\n\n    m_loader->cancel();\n    m_loader = 0;\n\n    if (async == DropProtectionAsync)\n        dropProtectionSoon();\n    else\n        dropProtection();\n}\n", "target": 0, "idx": 119178}
{"func": " static uint32_t GetMaxNumberOfEntries(JSObject* holder,\n FixedArrayBase* backing_store) {\n FixedArray* parameter_map = FixedArray::cast(backing_store);\n FixedArrayBase* arguments = FixedArrayBase::cast(parameter_map->get(1));\n return parameter_map->length() - 2 +\n ArgumentsAccessor::GetMaxNumberOfEntries(holder, arguments);\n }\n", "target": 0, "idx": 176291}
{"func": "parse_SAMPLE(char *arg, struct ofpbuf *ofpacts,\n             enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    struct ofpact_sample *os = ofpact_put_SAMPLE(ofpacts);\n    os->sampling_port = OFPP_NONE;\n    os->direction = NX_ACTION_SAMPLE_DEFAULT;\n\n    char *key, *value;\n    while (ofputil_parse_key_value(&arg, &key, &value)) {\n        char *error = NULL;\n\n        if (!strcmp(key, \"probability\")) {\n            error = str_to_u16(value, \"probability\", &os->probability);\n            if (!error && os->probability == 0) {\n                error = xasprintf(\"invalid probability value \\\"%s\\\"\", value);\n            }\n        } else if (!strcmp(key, \"collector_set_id\")) {\n            error = str_to_u32(value, &os->collector_set_id);\n        } else if (!strcmp(key, \"obs_domain_id\")) {\n            error = str_to_u32(value, &os->obs_domain_id);\n        } else if (!strcmp(key, \"obs_point_id\")) {\n            error = str_to_u32(value, &os->obs_point_id);\n        } else if (!strcmp(key, \"sampling_port\")) {\n            if (!ofputil_port_from_string(value, &os->sampling_port)) {\n                error = xasprintf(\"%s: unknown port\", value);\n            }\n        } else if (!strcmp(key, \"ingress\")) {\n            os->direction = NX_ACTION_SAMPLE_INGRESS;\n        } else if (!strcmp(key, \"egress\")) {\n            os->direction = NX_ACTION_SAMPLE_EGRESS;\n        } else {\n            error = xasprintf(\"invalid key \\\"%s\\\" in \\\"sample\\\" argument\",\n                              key);\n        }\n        if (error) {\n            return error;\n        }\n    }\n    if (os->probability == 0) {\n        return xstrdup(\"non-zero \\\"probability\\\" must be specified on sample\");\n    }\n\n    return NULL;\n}\n", "target": 0, "idx": 77064}
{"func": "   void AddChunk(sk_sp<PaintRecord> record,\n                const TransformPaintPropertyNode* t,\n                const ClipPaintPropertyNode* c,\n                const EffectPaintPropertyNode* e,\n                 const FloatRect& bounds = FloatRect(0, 0, 100, 100)) {\n     size_t i = items.size();\n     items.AllocateAndConstruct<DrawingDisplayItem>(\n         DefaultId().client, DefaultId().type, std::move(record));\n    chunks.emplace_back(i, i + 1, DefaultId(), PropertyTreeState(t, c, e));\n     chunks.back().bounds = bounds;\n   }\n", "target": 1, "idx": 185703}
{"func": "static int disable(void) {\n if (!interface_ready())\n return BT_STATUS_NOT_READY;\n\n  stack_manager_get_interface()->shut_down_stack_async();\n return BT_STATUS_SUCCESS;\n}\n", "target": 0, "idx": 172802}
{"func": "void GDataFileSystem::OnGetModifiedFileInfoCompleteForCloseFile(\n    const FilePath& file_path,\n    base::PlatformFileInfo* file_info,\n    bool* get_file_info_result,\n    const FileOperationCallback& callback) {\n  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));\n\n  if (!*get_file_info_result) {\n    if (!callback.is_null())\n      callback.Run(GDATA_FILE_ERROR_NOT_FOUND);\n    return;\n  }\n\n  FindEntryByPathAsyncOnUIThread(\n      file_path,\n      base::Bind(&GDataFileSystem::OnGetEntryCompleteForCloseFile,\n                 ui_weak_ptr_,\n                 file_path,\n                 *file_info,\n                 callback));\n}\n", "target": 0, "idx": 125417}
{"func": "double Histogram::GetPeakBucketSize(const SampleVector& samples) const {\n  double max = 0;\n  for (uint32_t i = 0; i < bucket_count() ; ++i) {\n    double current_size = GetBucketSize(samples.GetCountAtIndex(i), i);\n    if (current_size > max)\n      max = current_size;\n  }\n  return max;\n}\n", "target": 0, "idx": 152730}
{"func": "std::unique_ptr<PDFEngine> PDFEngine::Create(PDFEngine::Client* client) {\n  return std::make_unique<PDFiumEngine>(client);\n}\n", "target": 0, "idx": 158906}
{"func": "HRESULT DataObjectImpl::GetDataHere(FORMATETC* format_etc,\n                                    STGMEDIUM* medium) {\n  return DATA_E_FORMATETC;\n}\n", "target": 0, "idx": 130256}
{"func": "void inode_add_lru(struct inode *inode)\n{\n\tif (!(inode->i_state & (I_DIRTY | I_SYNC | I_FREEING | I_WILL_FREE)) &&\n\t    !atomic_read(&inode->i_count) && inode->i_sb->s_flags & MS_ACTIVE)\n\t\tinode_lru_list_add(inode);\n}\n", "target": 0, "idx": 36863}
{"func": "long keyctl_describe_key(key_serial_t keyid,\n\t\t\t char __user *buffer,\n\t\t\t size_t buflen)\n{\n\tstruct key *key, *instkey;\n\tkey_ref_t key_ref;\n\tchar *infobuf;\n\tlong ret;\n\tint desclen, infolen;\n\n\tkey_ref = lookup_user_key(keyid, KEY_LOOKUP_PARTIAL, KEY_NEED_VIEW);\n\tif (IS_ERR(key_ref)) {\n\t\t/* viewing a key under construction is permitted if we have the\n\t\t * authorisation token handy */\n\t\tif (PTR_ERR(key_ref) == -EACCES) {\n\t\t\tinstkey = key_get_instantiation_authkey(keyid);\n\t\t\tif (!IS_ERR(instkey)) {\n\t\t\t\tkey_put(instkey);\n\t\t\t\tkey_ref = lookup_user_key(keyid,\n\t\t\t\t\t\t\t  KEY_LOOKUP_PARTIAL,\n\t\t\t\t\t\t\t  0);\n\t\t\t\tif (!IS_ERR(key_ref))\n\t\t\t\t\tgoto okay;\n\t\t\t}\n\t\t}\n\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error;\n\t}\n\nokay:\n\tkey = key_ref_to_ptr(key_ref);\n\tdesclen = strlen(key->description);\n\n\t/* calculate how much information we're going to return */\n\tret = -ENOMEM;\n\tinfobuf = kasprintf(GFP_KERNEL,\n\t\t\t    \"%s;%d;%d;%08x;\",\n\t\t\t    key->type->name,\n\t\t\t    from_kuid_munged(current_user_ns(), key->uid),\n\t\t\t    from_kgid_munged(current_user_ns(), key->gid),\n\t\t\t    key->perm);\n\tif (!infobuf)\n\t\tgoto error2;\n\tinfolen = strlen(infobuf);\n\tret = infolen + desclen + 1;\n\n\t/* consider returning the data */\n\tif (buffer && buflen >= ret) {\n\t\tif (copy_to_user(buffer, infobuf, infolen) != 0 ||\n\t\t    copy_to_user(buffer + infolen, key->description,\n\t\t\t\t desclen + 1) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\n\tkfree(infobuf);\nerror2:\n\tkey_ref_put(key_ref);\nerror:\n\treturn ret;\n}\n", "target": 0, "idx": 57598}
{"func": "iasecc_emulate_fcp(struct sc_context *ctx, struct sc_apdu *apdu)\n{\n\tunsigned char dummy_df_fcp[] = {\n\t\t0x62,0xFF,\n\t\t\t0x82,0x01,0x38,\n\t\t\t0x8A,0x01,0x05,\n\t\t\t0xA1,0x04,0x8C,0x02,0x02,0x00,\n\t\t\t0x84,0xFF,\n\t\t\t\t0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n\t\t\t\t0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF\n\t};\n\n\tLOG_FUNC_CALLED(ctx);\n\n\tif (apdu->p1 != 0x04)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"FCP emulation supported only for the DF-NAME selection type\");\n\tif (apdu->datalen > 16)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_DATA, \"Invalid DF-NAME length\");\n\tif (apdu->resplen < apdu->datalen + 16)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_BUFFER_TOO_SMALL, \"not enough space for FCP data\");\n\n\tmemcpy(dummy_df_fcp + 16, apdu->data, apdu->datalen);\n\tdummy_df_fcp[15] = apdu->datalen;\n\tdummy_df_fcp[1] = apdu->datalen + 14;\n\tmemcpy(apdu->resp, dummy_df_fcp, apdu->datalen + 16);\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n", "target": 0, "idx": 78483}
{"func": "int phar_verify_signature(php_stream *fp, size_t end_of_phar, php_uint32 sig_type, char *sig, int sig_len, char *fname, char **signature, int *signature_len, char **error) /* {{{ */\n{\n\tint read_size, len;\n\tzend_off_t read_len;\n\tunsigned char buf[1024];\n\n\tphp_stream_rewind(fp);\n\n\tswitch (sig_type) {\n\t\tcase PHAR_SIG_OPENSSL: {\n#ifdef PHAR_HAVE_OPENSSL\n\t\t\tBIO *in;\n\t\t\tEVP_PKEY *key;\n\t\t\tEVP_MD *mdtype = (EVP_MD *) EVP_sha1();\n\t\t\tEVP_MD_CTX md_ctx;\n#else\n\t\t\tint tempsig;\n#endif\n\t\t\tzend_string *pubkey = NULL;\n\t\t\tchar *pfile;\n\t\t\tphp_stream *pfp;\n#ifndef PHAR_HAVE_OPENSSL\n\t\t\tif (!zend_hash_str_exists(&module_registry, \"openssl\", sizeof(\"openssl\")-1)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"openssl not loaded\");\n\t\t\t\t}\n\t\t\t\treturn FAILURE;\n\t\t\t}\n#endif\n\t\t\t/* use __FILE__ . '.pubkey' for public key file */\n\t\t\tspprintf(&pfile, 0, \"%s.pubkey\", fname);\n\t\t\tpfp = php_stream_open_wrapper(pfile, \"rb\", 0, NULL);\n\t\t\tefree(pfile);\n\n\t\t\tif (!pfp || !(pubkey = php_stream_copy_to_mem(pfp, PHP_STREAM_COPY_ALL, 0)) || !ZSTR_LEN(pubkey)) {\n\t\t\t\tif (pfp) {\n\t\t\t\t\tphp_stream_close(pfp);\n\t\t\t\t}\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"openssl public key could not be read\");\n\t\t\t\t}\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\tphp_stream_close(pfp);\n#ifndef PHAR_HAVE_OPENSSL\n\t\t\ttempsig = sig_len;\n\n\t\t\tif (FAILURE == phar_call_openssl_signverify(0, fp, end_of_phar, pubkey ? ZSTR_VAL(pubkey) : NULL, pubkey ? ZSTR_LEN(pubkey) : 0, &sig, &tempsig)) {\n\t\t\t\tif (pubkey) {\n\t\t\t\t\tzend_string_release(pubkey);\n\t\t\t\t}\n\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"openssl signature could not be verified\");\n\t\t\t\t}\n\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\tif (pubkey) {\n\t\t\t\tzend_string_release(pubkey);\n\t\t\t}\n\n\t\t\tsig_len = tempsig;\n#else\n\t\t\tin = BIO_new_mem_buf(pubkey ? ZSTR_VAL(pubkey) : NULL, pubkey ? ZSTR_LEN(pubkey) : 0);\n\n\t\t\tif (NULL == in) {\n\t\t\t\tzend_string_release(pubkey);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"openssl signature could not be processed\");\n\t\t\t\t}\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\tkey = PEM_read_bio_PUBKEY(in, NULL,NULL, NULL);\n\t\t\tBIO_free(in);\n\t\t\tzend_string_release(pubkey);\n\n\t\t\tif (NULL == key) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"openssl signature could not be processed\");\n\t\t\t\t}\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\tEVP_VerifyInit(&md_ctx, mdtype);\n\t\t\tread_len = end_of_phar;\n\n\t\t\tif (read_len > sizeof(buf)) {\n\t\t\t\tread_size = sizeof(buf);\n\t\t\t} else {\n\t\t\t\tread_size = (int)read_len;\n\t\t\t}\n\n\t\t\tphp_stream_seek(fp, 0, SEEK_SET);\n\n\t\t\twhile (read_size && (len = php_stream_read(fp, (char*)buf, read_size)) > 0) {\n\t\t\t\tEVP_VerifyUpdate (&md_ctx, buf, len);\n\t\t\t\tread_len -= (zend_off_t)len;\n\n\t\t\t\tif (read_len < read_size) {\n\t\t\t\t\tread_size = (int)read_len;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (EVP_VerifyFinal(&md_ctx, (unsigned char *)sig, sig_len, key) != 1) {\n\t\t\t\t/* 1: signature verified, 0: signature does not match, -1: failed signature operation */\n\t\t\t\tEVP_MD_CTX_cleanup(&md_ctx);\n\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"broken openssl signature\");\n\t\t\t\t}\n\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\tEVP_MD_CTX_cleanup(&md_ctx);\n#endif\n\n\t\t\t*signature_len = phar_hex_str((const char*)sig, sig_len, signature);\n\t\t}\n\t\tbreak;\n#ifdef PHAR_HASH_OK\n\t\tcase PHAR_SIG_SHA512: {\n \t\t\tunsigned char digest[64];\n \t\t\tPHP_SHA512_CTX context;\n \n \t\t\tPHP_SHA512Init(&context);\n \t\t\tread_len = end_of_phar;\n \n\t\t\tif (read_len > sizeof(buf)) {\n\t\t\t\tread_size = sizeof(buf);\n\t\t\t} else {\n\t\t\t\tread_size = (int)read_len;\n\t\t\t}\n\n\t\t\twhile ((len = php_stream_read(fp, (char*)buf, read_size)) > 0) {\n\t\t\t\tPHP_SHA512Update(&context, buf, len);\n\t\t\t\tread_len -= (zend_off_t)len;\n\t\t\t\tif (read_len < read_size) {\n\t\t\t\t\tread_size = (int)read_len;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tPHP_SHA512Final(digest, &context);\n\n\t\t\tif (memcmp(digest, sig, sizeof(digest))) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"broken signature\");\n\t\t\t\t}\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\t*signature_len = phar_hex_str((const char*)digest, sizeof(digest), signature);\n\t\t\tbreak;\n\t\t}\n\t\tcase PHAR_SIG_SHA256: {\n \t\t\tunsigned char digest[32];\n \t\t\tPHP_SHA256_CTX context;\n \n \t\t\tPHP_SHA256Init(&context);\n \t\t\tread_len = end_of_phar;\n \n\t\t\tif (read_len > sizeof(buf)) {\n\t\t\t\tread_size = sizeof(buf);\n\t\t\t} else {\n\t\t\t\tread_size = (int)read_len;\n\t\t\t}\n\n\t\t\twhile ((len = php_stream_read(fp, (char*)buf, read_size)) > 0) {\n\t\t\t\tPHP_SHA256Update(&context, buf, len);\n\t\t\t\tread_len -= (zend_off_t)len;\n\t\t\t\tif (read_len < read_size) {\n\t\t\t\t\tread_size = (int)read_len;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tPHP_SHA256Final(digest, &context);\n\n\t\t\tif (memcmp(digest, sig, sizeof(digest))) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"broken signature\");\n\t\t\t\t}\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\t*signature_len = phar_hex_str((const char*)digest, sizeof(digest), signature);\n\t\t\tbreak;\n\t\t}\n#else\n\t\tcase PHAR_SIG_SHA512:\n\t\tcase PHAR_SIG_SHA256:\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"unsupported signature\");\n\t\t\t}\n\t\t\treturn FAILURE;\n#endif\n\t\tcase PHAR_SIG_SHA1: {\n \t\t\tunsigned char digest[20];\n \t\t\tPHP_SHA1_CTX  context;\n \n \t\t\tPHP_SHA1Init(&context);\n \t\t\tread_len = end_of_phar;\n \n\t\t\tif (read_len > sizeof(buf)) {\n\t\t\t\tread_size = sizeof(buf);\n\t\t\t} else {\n\t\t\t\tread_size = (int)read_len;\n\t\t\t}\n\n\t\t\twhile ((len = php_stream_read(fp, (char*)buf, read_size)) > 0) {\n\t\t\t\tPHP_SHA1Update(&context, buf, len);\n\t\t\t\tread_len -= (zend_off_t)len;\n\t\t\t\tif (read_len < read_size) {\n\t\t\t\t\tread_size = (int)read_len;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tPHP_SHA1Final(digest, &context);\n\n\t\t\tif (memcmp(digest, sig, sizeof(digest))) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"broken signature\");\n\t\t\t\t}\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\t*signature_len = phar_hex_str((const char*)digest, sizeof(digest), signature);\n\t\t\tbreak;\n\t\t}\n\t\tcase PHAR_SIG_MD5: {\n \t\t\tunsigned char digest[16];\n \t\t\tPHP_MD5_CTX   context;\n \n \t\t\tPHP_MD5Init(&context);\n \t\t\tread_len = end_of_phar;\n \n\t\t\tif (read_len > sizeof(buf)) {\n\t\t\t\tread_size = sizeof(buf);\n\t\t\t} else {\n\t\t\t\tread_size = (int)read_len;\n\t\t\t}\n\n\t\t\twhile ((len = php_stream_read(fp, (char*)buf, read_size)) > 0) {\n\t\t\t\tPHP_MD5Update(&context, buf, len);\n\t\t\t\tread_len -= (zend_off_t)len;\n\t\t\t\tif (read_len < read_size) {\n\t\t\t\t\tread_size = (int)read_len;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tPHP_MD5Final(digest, &context);\n\n\t\t\tif (memcmp(digest, sig, sizeof(digest))) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"broken signature\");\n\t\t\t\t}\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\t*signature_len = phar_hex_str((const char*)digest, sizeof(digest), signature);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"broken or unsupported signature\");\n\t\t\t}\n\t\t\treturn FAILURE;\n\t}\n\treturn SUCCESS;\n}\n/* }}} */\n", "target": 1, "idx": 180106}
{"func": "static int pptp_getname(struct socket *sock, struct sockaddr *uaddr,\n\tint *usockaddr_len, int peer)\n{\n\tint len = sizeof(struct sockaddr_pppox);\n\tstruct sockaddr_pppox sp;\n\n\tmemset(&sp.sa_addr, 0, sizeof(sp.sa_addr));\n\n\tsp.sa_family    = AF_PPPOX;\n\tsp.sa_protocol  = PX_PROTO_PPTP;\n\tsp.sa_addr.pptp = pppox_sk(sock->sk)->proto.pptp.src_addr;\n\n\tmemcpy(uaddr, &sp, len);\n\n\t*usockaddr_len = len;\n\n\treturn 0;\n}\n", "target": 0, "idx": 41444}
{"func": "int NsSetParameter (preproc_effect_t *effect, void *pParam, void *pValue)\n {\n     int status = 0;\n     return status;\n}\n", "target": 1, "idx": 187374}
{"func": "void SSLClientSocket::ClearSessionCache() {\n  SSLClientSocketOpenSSL::SSLContext* context =\n      SSLClientSocketOpenSSL::SSLContext::GetInstance();\n  context->session_cache()->Flush();\n  OpenSSLClientKeyStore::GetInstance()->Flush();\n}\n", "target": 0, "idx": 133738}
{"func": "int vp9_alloc_context_buffers(VP9_COMMON *cm, int width, int height) {\n int new_mi_size;\n\n  vp9_set_mb_mi(cm, width, height);\n  new_mi_size = cm->mi_stride * calc_mi_size(cm->mi_rows);\n if (cm->mi_alloc_size < new_mi_size) {\n    cm->free_mi(cm);\n if (cm->alloc_mi(cm, new_mi_size))\n goto fail;\n }\n\n if (cm->seg_map_alloc_size < cm->mi_rows * cm->mi_cols) {\n    free_seg_map(cm);\n if (alloc_seg_map(cm, cm->mi_rows * cm->mi_cols))\n goto fail;\n }\n\n if (cm->above_context_alloc_cols < cm->mi_cols) {\n    vpx_free(cm->above_context);\n    cm->above_context = (ENTROPY_CONTEXT *)vpx_calloc(\n 2 * mi_cols_aligned_to_sb(cm->mi_cols) * MAX_MB_PLANE,\n sizeof(*cm->above_context));\n if (!cm->above_context) goto fail;\n\n    vpx_free(cm->above_seg_context);\n    cm->above_seg_context = (PARTITION_CONTEXT *)vpx_calloc(\n        mi_cols_aligned_to_sb(cm->mi_cols), sizeof(*cm->above_seg_context));\n if (!cm->above_seg_context) goto fail;\n    cm->above_context_alloc_cols = cm->mi_cols;\n }\n\n\n   return 0;\n \n  fail:\n   vp9_free_context_buffers(cm);\n   return 1;\n }\n", "target": 1, "idx": 187403}
{"func": "RedChannelClient *red_channel_client_create_dummy(int size,\n                                                  RedChannel *channel,\n                                                  RedClient  *client,\n                                                  int num_common_caps, uint32_t *common_caps,\n                                                  int num_caps, uint32_t *caps)\n{\n    RedChannelClient *rcc = NULL;\n\n    spice_assert(size >= sizeof(RedChannelClient));\n\n    pthread_mutex_lock(&client->lock);\n    if (!red_channel_client_pre_create_validate(channel, client)) {\n        goto error;\n    }\n    rcc = spice_malloc0(size);\n    rcc->refs = 1;\n    rcc->client = client;\n    rcc->channel = channel;\n    red_channel_ref(channel);\n    red_channel_client_set_remote_caps(rcc, num_common_caps, common_caps, num_caps, caps);\n    if (red_channel_client_test_remote_common_cap(rcc, SPICE_COMMON_CAP_MINI_HEADER)) {\n        rcc->incoming.header = mini_header_wrapper;\n        rcc->send_data.header = mini_header_wrapper;\n        rcc->is_mini_header = TRUE;\n    } else {\n        rcc->incoming.header = full_header_wrapper;\n        rcc->send_data.header = full_header_wrapper;\n        rcc->is_mini_header = FALSE;\n    }\n\n    rcc->incoming.header.data = rcc->incoming.header_buf;\n    rcc->incoming.serial = 1;\n    ring_init(&rcc->pipe);\n\n    rcc->dummy = TRUE;\n    rcc->dummy_connected = TRUE;\n    red_channel_add_client(channel, rcc);\n    red_client_add_channel(client, rcc);\n    pthread_mutex_unlock(&client->lock);\n    return rcc;\nerror:\n    pthread_mutex_unlock(&client->lock);\n    return NULL;\n}\n", "target": 0, "idx": 2085}
{"func": "raptor_rss_emit_type_triple(raptor_parser* rdf_parser, \n                            raptor_term *resource,\n                            raptor_uri *type_uri) \n{\n  raptor_rss_parser* rss_parser = (raptor_rss_parser*)rdf_parser->context;\n  raptor_term *predicate_term;\n  raptor_term *object_term;\n\n  if(!resource) {\n    raptor_parser_error(rdf_parser, \"RSS node has no identifier\");\n    return 1;\n  }\n\n  rss_parser->statement.subject = resource;\n  \n  predicate_term = raptor_new_term_from_uri(rdf_parser->world, \n                                            RAPTOR_RDF_type_URI(rdf_parser->world));\n  rss_parser->statement.predicate = predicate_term;\n\n  object_term = raptor_new_term_from_uri(rdf_parser->world, type_uri);\n  rss_parser->statement.object = object_term;\n  \n  /* Generate the statement */\n  (*rdf_parser->statement_handler)(rdf_parser->user_data, &rss_parser->statement);\n\n  raptor_free_term(predicate_term);\n  raptor_free_term(object_term);\n  \n  return 0;\n}\n", "target": 0, "idx": 22037}
{"func": " static IMFSample* CreateSampleFromInputBuffer(\n     const media::BitstreamBuffer& bitstream_buffer,\n    base::ProcessHandle renderer_process,\n     DWORD stream_size,\n     DWORD alignment) {\n  HANDLE shared_memory_handle = NULL;\n  RETURN_ON_FAILURE(::DuplicateHandle(renderer_process,\n                                      bitstream_buffer.handle(),\n                                      base::GetCurrentProcessHandle(),\n                                      &shared_memory_handle,\n                                      0,\n                                      FALSE,\n                                      DUPLICATE_SAME_ACCESS),\n                     \"Duplicate handle failed\", NULL);\n  base::SharedMemory shm(shared_memory_handle, true);\n   RETURN_ON_FAILURE(shm.Map(bitstream_buffer.size()),\n                     \"Failed in base::SharedMemory::Map\", NULL);\n \n  return CreateInputSample(reinterpret_cast<const uint8*>(shm.memory()),\n                           bitstream_buffer.size(),\n                           stream_size,\n                           alignment);\n}\n", "target": 1, "idx": 184566}
{"func": " ext4_xattr_release_block(handle_t *handle, struct inode *inode,\n \t\t\t struct buffer_head *bh)\n {\n\tstruct mb_cache_entry *ce = NULL;\n \tint error = 0;\n\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n \n\tce = mb_cache_entry_get(ext4_mb_cache, bh->b_bdev, bh->b_blocknr);\n \tBUFFER_TRACE(bh, \"get_write_access\");\n \terror = ext4_journal_get_write_access(handle, bh);\n \tif (error)\n \t\tgoto out;\n \n \tlock_buffer(bh);\n \tif (BHDR(bh)->h_refcount == cpu_to_le32(1)) {\n \t\tea_bdebug(bh, \"refcount now=0; freeing\");\n\t\tif (ce)\n\t\t\tmb_cache_entry_free(ce);\n \t\tget_bh(bh);\n \t\tunlock_buffer(bh);\n \t\text4_free_blocks(handle, inode, bh, 0, 1,\n \t\t\t\t EXT4_FREE_BLOCKS_METADATA |\n \t\t\t\t EXT4_FREE_BLOCKS_FORGET);\n \t} else {\n \t\tle32_add_cpu(&BHDR(bh)->h_refcount, -1);\n\t\tif (ce)\n\t\t\tmb_cache_entry_release(ce);\n \t\t/*\n \t\t * Beware of this ugliness: Releasing of xattr block references\n \t\t * from different inodes can race and so we have to protect\n\t\t * from a race where someone else frees the block (and releases\n\t\t * its journal_head) before we are done dirtying the buffer. In\n\t\t * nojournal mode this race is harmless and we actually cannot\n\t\t * call ext4_handle_dirty_xattr_block() with locked buffer as\n\t\t * that function can call sync_dirty_buffer() so for that case\n\t\t * we handle the dirtying after unlocking the buffer.\n\t\t */\n\t\tif (ext4_handle_valid(handle))\n\t\t\terror = ext4_handle_dirty_xattr_block(handle, inode,\n\t\t\t\t\t\t\t      bh);\n\t\tunlock_buffer(bh);\n\t\tif (!ext4_handle_valid(handle))\n\t\t\terror = ext4_handle_dirty_xattr_block(handle, inode,\n\t\t\t\t\t\t\t      bh);\n\t\tif (IS_SYNC(inode))\n\t\t\text4_handle_sync(handle);\n\t\tdquot_free_block(inode, EXT4_C2B(EXT4_SB(inode->i_sb), 1));\n\t\tea_bdebug(bh, \"refcount now=%d; releasing\",\n\t\t\t  le32_to_cpu(BHDR(bh)->h_refcount));\n\t}\nout:\n\text4_std_error(inode->i_sb, error);\n\treturn;\n}\n", "target": 1, "idx": 183168}
{"func": "void HttpBridge::MakeAsynchronousPost() {\n  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));\n  base::AutoLock lock(fetch_state_lock_);\n  DCHECK(!fetch_state_.request_completed);\n   if (fetch_state_.aborted)\n     return;\n \n  fetch_state_.url_poster = new URLFetcher(url_for_request_,\n                                           URLFetcher::POST, this);\n   fetch_state_.url_poster->set_request_context(context_getter_for_request_);\n   fetch_state_.url_poster->set_upload_data(content_type_, request_content_);\n   fetch_state_.url_poster->set_extra_request_headers(extra_headers_);\n  fetch_state_.url_poster->set_load_flags(net::LOAD_DO_NOT_SEND_COOKIES);\n  fetch_state_.url_poster->Start();\n}\n", "target": 1, "idx": 183885}
{"func": "bool ldb_dn_add_base(struct ldb_dn *dn, struct ldb_dn *base)\n{\n\tconst char *s;\n\tchar *t;\n\n\tif ( !base || base->invalid || !dn || dn->invalid) {\n\t\treturn false;\n\t}\n\n\tif (dn->components) {\n\t\tunsigned int i;\n\n\t\tif ( ! ldb_dn_validate(base)) {\n\t\t\treturn false;\n\t\t}\n\n\t\ts = NULL;\n\t\tif (dn->valid_case) {\n\t\t\tif ( ! (s = ldb_dn_get_casefold(base))) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tdn->components = talloc_realloc(dn,\n\t\t\t\t\t\tdn->components,\n\t\t\t\t\t\tstruct ldb_dn_component,\n\t\t\t\t\t\tdn->comp_num + base->comp_num);\n\t\tif ( ! dn->components) {\n\t\t\tldb_dn_mark_invalid(dn);\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (i = 0; i < base->comp_num; dn->comp_num++, i++) {\n\t\t\tdn->components[dn->comp_num] =\n\t\t\t\tldb_dn_copy_component(dn->components,\n\t\t\t\t\t\t\t&base->components[i]);\n\t\t\tif (dn->components[dn->comp_num].value.data == NULL) {\n\t\t\t\tldb_dn_mark_invalid(dn);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tif (dn->casefold && s) {\n\t\t\tif (*dn->casefold) {\n\t\t\t\tt = talloc_asprintf(dn, \"%s,%s\",\n\t\t\t\t\t\t    dn->casefold, s);\n\t\t\t} else {\n\t\t\t\tt = talloc_strdup(dn, s);\n\t\t\t}\n\t\t\tLDB_FREE(dn->casefold);\n\t\t\tdn->casefold = t;\n\t\t}\n\t}\n\n\tif (dn->linearized) {\n\n\t\ts = ldb_dn_get_linearized(base);\n\t\tif ( ! s) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (*dn->linearized) {\n\t\t\tt = talloc_asprintf(dn, \"%s,%s\",\n\t\t\t\t\t    dn->linearized, s);\n\t\t} else {\n\t\t\tt = talloc_strdup(dn, s);\n\t\t}\n\t\tif ( ! t) {\n\t\t\tldb_dn_mark_invalid(dn);\n\t\t\treturn false;\n\t\t}\n\t\tLDB_FREE(dn->linearized);\n\t\tdn->linearized = t;\n\t}\n\n\t/* Wipe the ext_linearized DN,\n\t * the GUID and SID are almost certainly no longer valid */\n\tLDB_FREE(dn->ext_linearized);\n\tLDB_FREE(dn->ext_components);\n\tdn->ext_comp_num = 0;\n\n\treturn true;\n}\n", "target": 0, "idx": 2324}
{"func": "  virtual ~AcceleratorControllerTest() {};\n", "target": 0, "idx": 114021}
{"func": "static int nested_svm_check_permissions(struct vcpu_svm *svm)\n{\n\tif (!(svm->vcpu.arch.efer & EFER_SVME)\n\t    || !is_paging(&svm->vcpu)) {\n\t\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tif (svm->vmcb->save.cpl) {\n\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t\treturn 1;\n\t}\n\n       return 0;\n}\n", "target": 0, "idx": 37779}
{"func": " void FileAPIMessageFilter::RegisterFileAsBlob(const GURL& blob_url,\n                                              const FilePath& virtual_path,\n                                               const FilePath& platform_path) {\n  FilePath::StringType extension = virtual_path.Extension();\n   if (!extension.empty())\n     extension = extension.substr(1);  // Strip leading \".\".\n \n   scoped_refptr<webkit_blob::ShareableFileReference> shareable_file =\n       webkit_blob::ShareableFileReference::Get(platform_path);\n  if (shareable_file &&\n      !ChildProcessSecurityPolicyImpl::GetInstance()->CanReadFile(\n           process_id_, platform_path)) {\n     ChildProcessSecurityPolicyImpl::GetInstance()->GrantReadFile(\n         process_id_, platform_path);\n    shareable_file->AddFinalReleaseCallback(\n        base::Bind(&RevokeFilePermission, process_id_));\n   }\n \n  std::string mime_type;\n  net::GetWellKnownMimeTypeFromExtension(extension, &mime_type);\n  BlobData::Item item;\n  item.SetToFilePathRange(platform_path, 0, -1, base::Time());\n  BlobStorageController* controller = blob_storage_context_->controller();\n  controller->StartBuildingBlob(blob_url);\n  controller->AppendBlobDataItem(blob_url, item);\n  controller->FinishBuildingBlob(blob_url, mime_type);\n  blob_urls_.insert(blob_url.spec());\n}\n", "target": 1, "idx": 185290}
{"func": "bool BaseAudioContext::AreAutoplayRequirementsFulfilled() const {\n  switch (GetAutoplayPolicy()) {\n    case AutoplayPolicy::Type::kNoUserGestureRequired:\n      return true;\n    case AutoplayPolicy::Type::kUserGestureRequired:\n    case AutoplayPolicy::Type::kUserGestureRequiredForCrossOrigin:\n      return Frame::HasTransientUserActivation(\n          GetDocument() ? GetDocument()->GetFrame() : nullptr);\n    case AutoplayPolicy::Type::kDocumentUserActivationRequired:\n      return AutoplayPolicy::IsDocumentAllowedToPlay(*GetDocument());\n  }\n\n  NOTREACHED();\n  return false;\n}\n", "target": 0, "idx": 166921}
{"func": "gfx::Insets ScrollableShelfView::CalculateEdgePadding() const {\n  if (ShouldApplyDisplayCentering())\n    return CalculatePaddingForDisplayCentering();\n \n   const int icons_size = shelf_view_->GetSizeOfAppIcons(\n       shelf_view_->number_of_visible_apps(), false);\n  gfx::Insets padding_insets(\n      /*vertical= */ 0,\n      /*horizontal= */ ShelfConfig::Get()->app_icon_group_margin());\n \n   const int available_size_for_app_icons =\n       (GetShelf()->IsHorizontalAlignment() ? width() : height()) -\n      2 * ShelfConfig::Get()->app_icon_group_margin();\n\n  int gap =\n      layout_strategy_ == kNotShowArrowButtons\n           ? available_size_for_app_icons - icons_size  // shelf centering\n           : CalculateOverflowPadding(available_size_for_app_icons);  // overflow\n \n  padding_insets.set_left(padding_insets.left() + gap / 2);\n  padding_insets.set_right(padding_insets.right() +\n                           (gap % 2 ? gap / 2 + 1 : gap / 2));\n \n   return padding_insets;\n }\n", "target": 1, "idx": 187151}
{"func": "struct inet_peer *inet_getpeer(struct inetpeer_addr *daddr, int create)\n {\n \tstruct inet_peer __rcu **stack[PEER_MAXDEPTH], ***stackptr;\n \tstruct inet_peer_base *base = family_to_base(daddr->family);\n\tstruct inet_peer *p;\n\tunsigned int sequence;\n\tint invalidated, gccnt = 0;\n\n\t/* Attempt a lockless lookup first.\n\t * Because of a concurrent writer, we might not find an existing entry.\n\t */\n\trcu_read_lock();\n\tsequence = read_seqbegin(&base->lock);\n\tp = lookup_rcu(daddr, base);\n\tinvalidated = read_seqretry(&base->lock, sequence);\n\trcu_read_unlock();\n\n\tif (p)\n\t\treturn p;\n\n\t/* If no writer did a change during our lookup, we can return early. */\n\tif (!create && !invalidated)\n\t\treturn NULL;\n\n\t/* retry an exact lookup, taking the lock before.\n\t * At least, nodes should be hot in our cache.\n\t */\n\twrite_seqlock_bh(&base->lock);\nrelookup:\n\tp = lookup(daddr, stack, base);\n\tif (p != peer_avl_empty) {\n\t\tatomic_inc(&p->refcnt);\n\t\twrite_sequnlock_bh(&base->lock);\n\t\treturn p;\n\t}\n\tif (!gccnt) {\n\t\tgccnt = inet_peer_gc(base, stack, stackptr);\n\t\tif (gccnt && create)\n\t\t\tgoto relookup;\n\t}\n\tp = create ? kmem_cache_alloc(peer_cachep, GFP_ATOMIC) : NULL;\n\tif (p) {\n \t\tp->daddr = *daddr;\n \t\tatomic_set(&p->refcnt, 1);\n \t\tatomic_set(&p->rid, 0);\n\t\tatomic_set(&p->ip_id_count, secure_ip_id(daddr->addr.a4));\n \t\tp->tcp_ts_stamp = 0;\n \t\tp->metrics[RTAX_LOCK-1] = INETPEER_METRICS_NEW;\n \t\tp->rate_tokens = 0;\n\t\tp->rate_last = 0;\n\t\tp->pmtu_expires = 0;\n\t\tp->pmtu_orig = 0;\n\t\tmemset(&p->redirect_learned, 0, sizeof(p->redirect_learned));\n\n\n\t\t/* Link the node. */\n\t\tlink_to_pool(p, base);\n\t\tbase->total++;\n\t}\n\twrite_sequnlock_bh(&base->lock);\n\n\treturn p;\n}\n", "target": 1, "idx": 179022}
{"func": "void RendererSchedulerImpl::OnTriedToExecuteBlockedTask() {\n  if (main_thread_only().current_use_case == UseCase::kTouchstart ||\n      main_thread_only().longest_jank_free_task_duration <\n          base::TimeDelta::FromMilliseconds(kRailsResponseTimeMillis) ||\n      main_thread_only().renderer_pause_count != 0 ||\n      main_thread_only().stopped_when_backgrounded) {\n    return;\n  }\n  if (!main_thread_only().timer_tasks_seem_expensive &&\n      !main_thread_only().loading_tasks_seem_expensive) {\n    return;\n  }\n  if (!main_thread_only()\n           .have_reported_blocking_intervention_in_current_policy) {\n    main_thread_only().have_reported_blocking_intervention_in_current_policy =\n        true;\n    TRACE_EVENT_INSTANT0(\"renderer.scheduler\",\n                         \"RendererSchedulerImpl::TaskBlocked\",\n                         TRACE_EVENT_SCOPE_THREAD);\n  }\n\n  if (!main_thread_only()\n           .have_reported_blocking_intervention_since_navigation) {\n    {\n      base::AutoLock lock(any_thread_lock_);\n      if (!any_thread().have_seen_a_potentially_blocking_gesture)\n        return;\n    }\n    main_thread_only().have_reported_blocking_intervention_since_navigation =\n        true;\n    BroadcastIntervention(\n        \"Blink deferred a task in order to make scrolling smoother. \"\n        \"Your timer and network tasks should take less than 50ms to run \"\n        \"to avoid this. Please see \"\n        \"https://developers.google.com/web/tools/chrome-devtools/profile/\"\n        \"evaluate-performance/rail\"\n        \" and https://crbug.com/574343#c40 for more information.\");\n  }\n}\n", "target": 0, "idx": 156237}
{"func": "static int seek_firmware(struct dvb_frontend *fe, unsigned int type,\n\t\t\t v4l2_std_id *id)\n{\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tint                 i, best_i = -1, best_nr_matches = 0;\n\tunsigned int        type_mask = 0;\n\n\ttuner_dbg(\"%s called, want type=\", __func__);\n\tif (debug) {\n\t\tdump_firm_type(type);\n\t\tprintk(\"(%x), id %016llx.\\n\", type, (unsigned long long)*id);\n\t}\n\n\tif (!priv->firm) {\n\t\ttuner_err(\"Error! firmware not loaded\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (((type & ~SCODE) == 0) && (*id == 0))\n\t\t*id = V4L2_STD_PAL;\n\n\tif (type & BASE)\n\t\ttype_mask = BASE_TYPES;\n\telse if (type & SCODE) {\n\t\ttype &= SCODE_TYPES;\n\t\ttype_mask = SCODE_TYPES & ~HAS_IF;\n\t} else if (type & DTV_TYPES)\n\t\ttype_mask = DTV_TYPES;\n\telse if (type & STD_SPECIFIC_TYPES)\n\t\ttype_mask = STD_SPECIFIC_TYPES;\n\n\ttype &= type_mask;\n\n\tif (!(type & SCODE))\n\t\ttype_mask = ~0;\n\n\t/* Seek for exact match */\n\tfor (i = 0; i < priv->firm_size; i++) {\n\t\tif ((type == (priv->firm[i].type & type_mask)) &&\n\t\t    (*id == priv->firm[i].id))\n\t\t\tgoto found;\n\t}\n\n\t/* Seek for generic video standard match */\n\tfor (i = 0; i < priv->firm_size; i++) {\n\t\tv4l2_std_id match_mask;\n\t\tint nr_matches;\n\n\t\tif (type != (priv->firm[i].type & type_mask))\n\t\t\tcontinue;\n\n\t\tmatch_mask = *id & priv->firm[i].id;\n\t\tif (!match_mask)\n\t\t\tcontinue;\n\n\t\tif ((*id & match_mask) == *id)\n\t\t\tgoto found; /* Supports all the requested standards */\n\n\t\tnr_matches = hweight64(match_mask);\n\t\tif (nr_matches > best_nr_matches) {\n\t\t\tbest_nr_matches = nr_matches;\n\t\t\tbest_i = i;\n\t\t}\n\t}\n\n\tif (best_nr_matches > 0) {\n\t\ttuner_dbg(\"Selecting best matching firmware (%d bits) for \"\n\t\t\t  \"type=\", best_nr_matches);\n\t\tdump_firm_type(type);\n\t\tprintk(\"(%x), id %016llx:\\n\", type, (unsigned long long)*id);\n\t\ti = best_i;\n\t\tgoto found;\n\t}\n\n\t/*FIXME: Would make sense to seek for type \"hint\" match ? */\n\n\ti = -ENOENT;\n\tgoto ret;\n\nfound:\n\t*id = priv->firm[i].id;\n\nret:\n\ttuner_dbg(\"%s firmware for type=\", (i < 0) ? \"Can't find\" : \"Found\");\n\tif (debug) {\n\t\tdump_firm_type(type);\n\t\tprintk(\"(%x), id %016llx.\\n\", type, (unsigned long long)*id);\n\t}\n\treturn i;\n}\n", "target": 0, "idx": 49546}
{"func": "static const struct vhost_memory_region *find_region(struct vhost_memory *mem,\n\t\t\t\t\t\t     __u64 addr, __u32 len)\n{\n\tconst struct vhost_memory_region *reg;\n\tint start = 0, end = mem->nregions;\n\n\twhile (start < end) {\n\t\tint slot = start + (end - start) / 2;\n\t\treg = mem->regions + slot;\n\t\tif (addr >= reg->guest_phys_addr)\n\t\t\tend = slot;\n\t\telse\n\t\t\tstart = slot + 1;\n\t}\n\n\treg = mem->regions + start;\n\tif (addr >= reg->guest_phys_addr &&\n\t\treg->guest_phys_addr + reg->memory_size > addr)\n\t\treturn reg;\n\treturn NULL;\n}\n", "target": 0, "idx": 42201}
{"func": "table_mod__(struct oftable *oftable,\n            const struct ofputil_table_mod *tm)\n{\n    if (tm->miss == OFPUTIL_TABLE_MISS_DEFAULT) {\n        /* This is how an OFPT_TABLE_MOD decodes if it doesn't specify any\n         * table-miss configuration (because the protocol used doesn't have\n         * such a concept), so there's nothing to do. */\n    } else {\n        atomic_store_relaxed(&oftable->miss_config, tm->miss);\n    }\n\n    unsigned int new_eviction = oftable->eviction;\n    if (tm->eviction == OFPUTIL_TABLE_EVICTION_ON) {\n        new_eviction |= EVICTION_OPENFLOW;\n    } else if (tm->eviction == OFPUTIL_TABLE_EVICTION_OFF) {\n        new_eviction &= ~EVICTION_OPENFLOW;\n    }\n\n    if (new_eviction != oftable->eviction) {\n        ovs_mutex_lock(&ofproto_mutex);\n        oftable_configure_eviction(oftable, new_eviction,\n                                   oftable->eviction_fields,\n                                   oftable->n_eviction_fields);\n        ovs_mutex_unlock(&ofproto_mutex);\n    }\n\n    if (tm->vacancy != OFPUTIL_TABLE_VACANCY_DEFAULT) {\n        ovs_mutex_lock(&ofproto_mutex);\n        oftable->vacancy_down = tm->table_vacancy.vacancy_down;\n        oftable->vacancy_up = tm->table_vacancy.vacancy_up;\n        if (tm->vacancy == OFPUTIL_TABLE_VACANCY_OFF) {\n            oftable->vacancy_event = 0;\n        } else if (!oftable->vacancy_event) {\n            uint8_t vacancy = oftable_vacancy(oftable);\n            oftable->vacancy_event = (vacancy < oftable->vacancy_up\n                                      ? OFPTR_VACANCY_UP\n                                      : OFPTR_VACANCY_DOWN);\n        }\n        ovs_mutex_unlock(&ofproto_mutex);\n    }\n}\n", "target": 0, "idx": 77433}
{"func": "AudioRendererAlgorithm::AudioRendererAlgorithm()\n    : channels_(0),\n      samples_per_second_(0),\n      bytes_per_channel_(0),\n      playback_rate_(0.0f),\n      audio_buffer_(0, kStartingBufferSizeInBytes),\n      bytes_in_crossfade_(0),\n      bytes_per_frame_(0),\n      index_into_window_(0),\n      crossfade_frame_number_(0),\n      muted_(false),\n      needs_more_data_(false),\n      window_size_(0) {\n}\n", "target": 0, "idx": 127097}
{"func": "void qemu_spice_create_primary_surface(SimpleSpiceDisplay *ssd, uint32_t id,\n                                       QXLDevSurfaceCreate *surface,\n                                       qxl_async_io async)\n{\n    trace_qemu_spice_create_primary_surface(ssd->qxl.id, id, surface, async);\n    if (async != QXL_SYNC) {\n        spice_qxl_create_primary_surface_async(&ssd->qxl, id, surface,\n                (uintptr_t)qxl_cookie_new(QXL_COOKIE_TYPE_IO,\n                                          QXL_IO_CREATE_PRIMARY_ASYNC));\n    } else {\n        spice_qxl_create_primary_surface(&ssd->qxl, id, surface);\n    }\n}\n", "target": 0, "idx": 12186}
{"func": "static int jpc_pi_nextcprl(register jpc_pi_t *pi)\n{\n\tint rlvlno;\n\tjpc_pirlvl_t *pirlvl;\n\tjpc_pchg_t *pchg;\n\tint prchind;\n\tint prcvind;\n\tint *prclyrno;\n\tuint_fast32_t trx0;\n\tuint_fast32_t try0;\n\tuint_fast32_t r;\n\tuint_fast32_t rpx;\n\tuint_fast32_t rpy;\n\n\tpchg = pi->pchg;\n\tif (!pi->prgvolfirst) {\n\t\tgoto skip;\n\t} else {\n \t\tpi->prgvolfirst = 0;\n \t}\n \n\tfor (pi->compno = pchg->compnostart, pi->picomp =\n\t  &pi->picomps[pi->compno]; pi->compno < JAS_CAST(int, pchg->compnoend) && pi->compno < pi->numcomps; ++pi->compno,\n\t  ++pi->picomp) {\n \t\tpirlvl = pi->picomp->pirlvls;\n \t\tpi->xstep = pi->picomp->hsamp * (JAS_CAST(uint_fast32_t, 1) <<\n \t\t  (pirlvl->prcwidthexpn + pi->picomp->numrlvls - 1));\n \t\tpi->ystep = pi->picomp->vsamp * (JAS_CAST(uint_fast32_t, 1) <<\n\t\t  (pirlvl->prcheightexpn + pi->picomp->numrlvls - 1));\n\t\tfor (rlvlno = 1, pirlvl = &pi->picomp->pirlvls[1];\n\t\t  rlvlno < pi->picomp->numrlvls; ++rlvlno, ++pirlvl) {\n\t\t\tpi->xstep = JAS_MIN(pi->xstep, pi->picomp->hsamp *\n\t\t\t  (JAS_CAST(uint_fast32_t, 1) << (pirlvl->prcwidthexpn +\n\t\t\t  pi->picomp->numrlvls - rlvlno - 1)));\n\t\t\tpi->ystep = JAS_MIN(pi->ystep, pi->picomp->vsamp *\n\t\t\t  (JAS_CAST(uint_fast32_t, 1) << (pirlvl->prcheightexpn +\n\t\t\t  pi->picomp->numrlvls - rlvlno - 1)));\n\t\t}\n\t\tfor (pi->y = pi->ystart; pi->y < pi->yend;\n\t\t  pi->y += pi->ystep - (pi->y % pi->ystep)) {\n\t\t\tfor (pi->x = pi->xstart; pi->x < pi->xend;\n\t\t\t  pi->x += pi->xstep - (pi->x % pi->xstep)) {\n\t\t\t\tfor (pi->rlvlno = pchg->rlvlnostart,\n\t\t\t\t  pi->pirlvl = &pi->picomp->pirlvls[pi->rlvlno];\n\t\t\t\t  pi->rlvlno < pi->picomp->numrlvls && pi->rlvlno <\n\t\t\t\t  pchg->rlvlnoend; ++pi->rlvlno, ++pi->pirlvl) {\n\t\t\t\t\tif (pi->pirlvl->numprcs == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tr = pi->picomp->numrlvls - 1 - pi->rlvlno;\n\t\t\t\t\ttrx0 = JPC_CEILDIV(pi->xstart, pi->picomp->hsamp << r);\n \t\t\t\t\ttry0 = JPC_CEILDIV(pi->ystart, pi->picomp->vsamp << r);\n \t\t\t\t\trpx = r + pi->pirlvl->prcwidthexpn;\n \t\t\t\t\trpy = r + pi->pirlvl->prcheightexpn;\n\t\t\t\t\tif (((pi->x == pi->xstart && ((trx0 << r) % (1 << rpx))) ||\n \t\t\t\t\t  !(pi->x % (pi->picomp->hsamp << rpx))) &&\n\t\t\t\t\t  ((pi->y == pi->ystart && ((try0 << r) % (1 << rpy))) ||\n \t\t\t\t\t  !(pi->y % (pi->picomp->vsamp << rpy)))) {\n\t\t\t\t\t\tprchind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->x, pi->picomp->hsamp\n\t\t\t\t\t\t  << r), pi->pirlvl->prcwidthexpn) - JPC_FLOORDIVPOW2(trx0,\n\t\t\t\t\t\t  pi->pirlvl->prcwidthexpn);\n\t\t\t\t\t\tprcvind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->y, pi->picomp->vsamp\n\t\t\t\t\t\t  << r), pi->pirlvl->prcheightexpn) - JPC_FLOORDIVPOW2(try0,\n\t\t\t\t\t\t  pi->pirlvl->prcheightexpn);\n\t\t\t\t\t\tpi->prcno = prcvind *\n\t\t\t\t\t\t  pi->pirlvl->numhprcs +\n\t\t\t\t\t\t  prchind;\n\t\t\t\t\t\tassert(pi->prcno <\n\t\t\t\t\t\t  pi->pirlvl->numprcs);\n\t\t\t\t\t\tfor (pi->lyrno = 0; pi->lyrno <\n\t\t\t\t\t\t  pi->numlyrs && pi->lyrno < JAS_CAST(int, pchg->lyrnoend); ++pi->lyrno) {\n \t\t\t\t\t\t\tprclyrno = &pi->pirlvl->prclyrnos[pi->prcno];\n \t\t\t\t\t\t\tif (pi->lyrno >= *prclyrno) {\n \t\t\t\t\t\t\t\t++(*prclyrno);\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}\nskip:\n\t\t\t\t\t\t\t;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}\n", "target": 1, "idx": 182611}
{"func": "archive_read_support_format_rar(struct archive *_a)\n{\n  struct archive_read *a = (struct archive_read *)_a;\n  struct rar *rar;\n  int r;\n\n  archive_check_magic(_a, ARCHIVE_READ_MAGIC, ARCHIVE_STATE_NEW,\n                      \"archive_read_support_format_rar\");\n\n  rar = (struct rar *)malloc(sizeof(*rar));\n  if (rar == NULL)\n  {\n    archive_set_error(&a->archive, ENOMEM, \"Can't allocate rar data\");\n    return (ARCHIVE_FATAL);\n  }\n  memset(rar, 0, sizeof(*rar));\n\n\t/*\n\t * Until enough data has been read, we cannot tell about\n\t * any encrypted entries yet.\n\t */\n\trar->has_encrypted_entries = ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW;\n\n  r = __archive_read_register_format(a,\n                                     rar,\n                                     \"rar\",\n                                     archive_read_format_rar_bid,\n                                     archive_read_format_rar_options,\n                                     archive_read_format_rar_read_header,\n                                     archive_read_format_rar_read_data,\n                                     archive_read_format_rar_read_data_skip,\n                                     archive_read_format_rar_seek_data,\n                                     archive_read_format_rar_cleanup,\n                                     archive_read_support_format_rar_capabilities,\n                                     archive_read_format_rar_has_encrypted_entries);\n\n  if (r != ARCHIVE_OK)\n    free(rar);\n  return (r);\n}\n", "target": 0, "idx": 53467}
{"func": "unsigned int ipmi_addr_length(int addr_type)\n{\n\tif (addr_type == IPMI_SYSTEM_INTERFACE_ADDR_TYPE)\n\t\treturn sizeof(struct ipmi_system_interface_addr);\n\n\tif ((addr_type == IPMI_IPMB_ADDR_TYPE)\n\t\t\t|| (addr_type == IPMI_IPMB_BROADCAST_ADDR_TYPE))\n\t\treturn sizeof(struct ipmi_ipmb_addr);\n\n\tif (addr_type == IPMI_LAN_ADDR_TYPE)\n\t\treturn sizeof(struct ipmi_lan_addr);\n\n\treturn 0;\n}\n", "target": 0, "idx": 91262}
{"func": "gfx::NativeWindow PasswordAccessoryControllerImpl::native_window() const {\n  return web_contents_->GetTopLevelNativeWindow();\n}\n", "target": 1, "idx": 186034}
{"func": "bool RenderWidgetHostViewAura::ShouldFastACK(uint64 surface_id) {\n  ui::Texture* container = image_transport_clients_[surface_id];\n  DCHECK(container);\n   if (can_lock_compositor_ == NO_PENDING_RENDERER_FRAME ||\n       can_lock_compositor_ == NO_PENDING_COMMIT ||\n       resize_locks_.empty())\n     return false;\n \n  gfx::Size container_size = ConvertSizeToDIP(this, container->size());\n   ResizeLockList::iterator it = resize_locks_.begin();\n   while (it != resize_locks_.end()) {\n     if ((*it)->expected_size() == container_size)\n      break;\n    ++it;\n  }\n\n  return it == resize_locks_.end() || ++it != resize_locks_.end();\n}\n", "target": 1, "idx": 185084}
{"func": "void RenderThread::Init() {\n  TRACE_EVENT_BEGIN_ETW(\"RenderThread::Init\", 0, \"\");\n\n#if defined(OS_MACOSX)\n  WebKit::WebView::setUseExternalPopupMenus(true);\n#endif\n\n  lazy_tls.Pointer()->Set(this);\n#if defined(OS_WIN)\n  if (RenderProcessImpl::InProcessPlugins())\n    CoInitialize(0);\n#endif\n\n  suspend_webkit_shared_timer_ = true;\n  notify_webkit_of_modal_loop_ = true;\n  plugin_refresh_allowed_ = true;\n  widget_count_ = 0;\n  hidden_widget_count_ = 0;\n  idle_notification_delay_in_s_ = kInitialIdleHandlerDelayS;\n  task_factory_.reset(new ScopedRunnableMethodFactory<RenderThread>(this));\n\n  appcache_dispatcher_.reset(new AppCacheDispatcher(this));\n  indexed_db_dispatcher_.reset(new IndexedDBDispatcher());\n\n  db_message_filter_ = new DBMessageFilter();\n  AddFilter(db_message_filter_.get());\n\n  vc_manager_ = new VideoCaptureImplManager();\n  AddFilter(vc_manager_->video_capture_message_filter());\n\n  audio_input_message_filter_ = new AudioInputMessageFilter();\n  AddFilter(audio_input_message_filter_.get());\n\n   audio_message_filter_ = new AudioMessageFilter();\n   AddFilter(audio_message_filter_.get());\n \n   content::GetContentClient()->renderer()->RenderThreadStarted();\n \n   TRACE_EVENT_END_ETW(\"RenderThread::Init\", 0, \"\");\n}\n", "target": 1, "idx": 183783}
{"func": "PHP_FUNCTION(openssl_seal)\n{\n\tzval *pubkeys, *pubkey, *sealdata, *ekeys, *iv = NULL;\n\tHashTable *pubkeysht;\n\tEVP_PKEY **pkeys;\n\tzend_resource ** key_resources;\t/* so we know what to cleanup */\n\tint i, len1, len2, *eksl, nkeys, iv_len;\n\tunsigned char iv_buf[EVP_MAX_IV_LENGTH + 1], *buf = NULL, **eks;\n\tchar * data;\n\tsize_t data_len;\n\tchar *method =NULL;\n\tsize_t method_len = 0;\n\tconst EVP_CIPHER *cipher;\n\tEVP_CIPHER_CTX *ctx;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"sz/z/a/|sz/\", &data, &data_len,\n\t\t\t\t&sealdata, &ekeys, &pubkeys, &method, &method_len, &iv) == FAILURE) {\n\t\treturn;\n\t}\n\tpubkeysht = Z_ARRVAL_P(pubkeys);\n\tnkeys = pubkeysht ? zend_hash_num_elements(pubkeysht) : 0;\n\tif (!nkeys) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Fourth argument to openssl_seal() must be a non-empty array\");\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_OPENSSL_CHECK_SIZE_T_TO_INT(data_len, data);\n\n\tif (method) {\n\t\tcipher = EVP_get_cipherbyname(method);\n\t\tif (!cipher) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"Unknown signature algorithm.\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\t} else {\n\t\tcipher = EVP_rc4();\n\t}\n\n\tiv_len = EVP_CIPHER_iv_length(cipher);\n\tif (!iv && iv_len > 0) {\n\t\tphp_error_docref(NULL, E_WARNING,\n\t\t\t\t\"Cipher algorithm requires an IV to be supplied as a sixth parameter\");\n\t\tRETURN_FALSE;\n\t}\n\n\tpkeys = safe_emalloc(nkeys, sizeof(*pkeys), 0);\n\teksl = safe_emalloc(nkeys, sizeof(*eksl), 0);\n\teks = safe_emalloc(nkeys, sizeof(*eks), 0);\n\tmemset(eks, 0, sizeof(*eks) * nkeys);\n\tkey_resources = safe_emalloc(nkeys, sizeof(zend_resource*), 0);\n\tmemset(key_resources, 0, sizeof(zend_resource*) * nkeys);\n\tmemset(pkeys, 0, sizeof(*pkeys) * nkeys);\n\n\t/* get the public keys we are using to seal this data */\n\ti = 0;\n\tZEND_HASH_FOREACH_VAL(pubkeysht, pubkey) {\n\t\tpkeys[i] = php_openssl_evp_from_zval(pubkey, 1, NULL, 0, 0, &key_resources[i]);\n\t\tif (pkeys[i] == NULL) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"not a public key (%dth member of pubkeys)\", i+1);\n\t\t\tRETVAL_FALSE;\n\t\t\tgoto clean_exit;\n\t\t}\n\t\teks[i] = emalloc(EVP_PKEY_size(pkeys[i]) + 1);\n\t\ti++;\n\t} ZEND_HASH_FOREACH_END();\n\n\tctx = EVP_CIPHER_CTX_new();\n\tif (ctx == NULL || !EVP_EncryptInit(ctx,cipher,NULL,NULL)) {\n\t\tEVP_CIPHER_CTX_free(ctx);\n\t\tRETVAL_FALSE;\n\t\tgoto clean_exit;\n\t}\n\n\t/* allocate one byte extra to make room for \\0 */\n        buf = emalloc(data_len + EVP_CIPHER_CTX_block_size(ctx));\n        EVP_CIPHER_CTX_cleanup(ctx);\n \n       if (!EVP_SealInit(ctx, cipher, eks, eksl, &iv_buf[0], pkeys, nkeys) ||\n                        !EVP_SealUpdate(ctx, buf, &len1, (unsigned char *)data, (int)data_len) ||\n                        !EVP_SealFinal(ctx, buf + len1, &len2)) {\n                RETVAL_FALSE;\n\t\tefree(buf);\n\t\tEVP_CIPHER_CTX_free(ctx);\n\t\tgoto clean_exit;\n\t}\n\n\tif (len1 + len2 > 0) {\n\t\tzval_dtor(sealdata);\n\t\tZVAL_NEW_STR(sealdata, zend_string_init((char*)buf, len1 + len2, 0));\n\t\tefree(buf);\n\n\t\tzval_dtor(ekeys);\n\t\tarray_init(ekeys);\n\t\tfor (i=0; i<nkeys; i++) {\n\t\t\teks[i][eksl[i]] = '\\0';\n\t\t\tadd_next_index_stringl(ekeys, (const char*)eks[i], eksl[i]);\n\t\t\tefree(eks[i]);\n\t\t\teks[i] = NULL;\n\t\t}\n\n\t\tif (iv) {\n\t\t\tzval_dtor(iv);\n\t\t\tiv_buf[iv_len] = '\\0';\n\t\t\tZVAL_NEW_STR(iv, zend_string_init((char*)iv_buf, iv_len, 0));\n\t\t}\n\t} else {\n\t\tefree(buf);\n\t}\n\tRETVAL_LONG(len1 + len2);\n\tEVP_CIPHER_CTX_free(ctx);\n\nclean_exit:\n\tfor (i=0; i<nkeys; i++) {\n\t\tif (key_resources[i] == NULL && pkeys[i] != NULL) {\n\t\t\tEVP_PKEY_free(pkeys[i]);\n\t\t}\n\t\tif (eks[i]) {\n\t\t\tefree(eks[i]);\n\t\t}\n\t}\n\tefree(eks);\n\tefree(eksl);\n\tefree(pkeys);\n\tefree(key_resources);\n}\n", "target": 1, "idx": 177927}
{"func": "static inline bool vmsvga_verify_rect(DisplaySurface *surface,\n                                      const char *name,\n                                      int x, int y, int w, int h)\n{\n    if (x < 0) {\n        fprintf(stderr, \"%s: x was < 0 (%d)\\n\", name, x);\n        return false;\n    }\n    if (x > SVGA_MAX_WIDTH) {\n        fprintf(stderr, \"%s: x was > %d (%d)\\n\", name, SVGA_MAX_WIDTH, x);\n        return false;\n    }\n    if (w < 0) {\n        fprintf(stderr, \"%s: w was < 0 (%d)\\n\", name, w);\n        return false;\n    }\n    if (w > SVGA_MAX_WIDTH) {\n        fprintf(stderr, \"%s: w was > %d (%d)\\n\", name, SVGA_MAX_WIDTH, w);\n        return false;\n    }\n    if (x + w > surface_width(surface)) {\n        fprintf(stderr, \"%s: width was > %d (x: %d, w: %d)\\n\",\n                name, surface_width(surface), x, w);\n        return false;\n    }\n\n    if (y < 0) {\n        fprintf(stderr, \"%s: y was < 0 (%d)\\n\", name, y);\n        return false;\n    }\n    if (y > SVGA_MAX_HEIGHT) {\n        fprintf(stderr, \"%s: y was > %d (%d)\\n\", name, SVGA_MAX_HEIGHT, y);\n        return false;\n    }\n    if (h < 0) {\n        fprintf(stderr, \"%s: h was < 0 (%d)\\n\", name, h);\n        return false;\n    }\n    if (h > SVGA_MAX_HEIGHT) {\n        fprintf(stderr, \"%s: h was > %d (%d)\\n\", name, SVGA_MAX_HEIGHT, h);\n        return false;\n    }\n    if (y + h > surface_height(surface)) {\n        fprintf(stderr, \"%s: update height > %d (y: %d, h: %d)\\n\",\n                name, surface_height(surface), y, h);\n        return false;\n    }\n\n    return true;\n}\n", "target": 0, "idx": 8626}
{"func": "SYSCALL_DEFINE4(epoll_ctl, int, epfd, int, op, int, fd,\n\t\tstruct epoll_event __user *, event)\n{\n\tint error;\n\tint did_lock_epmutex = 0;\n\tstruct file *file, *tfile;\n\tstruct eventpoll *ep;\n\tstruct epitem *epi;\n\tstruct epoll_event epds;\n\n\terror = -EFAULT;\n\tif (ep_op_has_event(op) &&\n\t    copy_from_user(&epds, event, sizeof(struct epoll_event)))\n\t\tgoto error_return;\n\n\t/* Get the \"struct file *\" for the eventpoll file */\n\terror = -EBADF;\n\tfile = fget(epfd);\n\tif (!file)\n\t\tgoto error_return;\n\n\t/* Get the \"struct file *\" for the target file */\n\ttfile = fget(fd);\n\tif (!tfile)\n\t\tgoto error_fput;\n\n\t/* The target file descriptor must support poll */\n\terror = -EPERM;\n\tif (!tfile->f_op || !tfile->f_op->poll)\n\t\tgoto error_tgt_fput;\n\n\t/*\n\t * We have to check that the file structure underneath the file descriptor\n\t * the user passed to us _is_ an eventpoll file. And also we do not permit\n\t * adding an epoll file descriptor inside itself.\n\t */\n\terror = -EINVAL;\n\tif (file == tfile || !is_file_epoll(file))\n\t\tgoto error_tgt_fput;\n\n\t/*\n\t * At this point it is safe to assume that the \"private_data\" contains\n\t * our own data structure.\n\t */\n\tep = file->private_data;\n\n\t/*\n\t * When we insert an epoll file descriptor, inside another epoll file\n\t * descriptor, there is the change of creating closed loops, which are\n\t * better be handled here, than in more critical paths. While we are\n\t * checking for loops we also determine the list of files reachable\n\t * and hang them on the tfile_check_list, so we can check that we\n\t * haven't created too many possible wakeup paths.\n\t *\n\t * We need to hold the epmutex across both ep_insert and ep_remove\n\t * b/c we want to make sure we are looking at a coherent view of\n\t * epoll network.\n\t */\n\tif (op == EPOLL_CTL_ADD || op == EPOLL_CTL_DEL) {\n\t\tmutex_lock(&epmutex);\n\t\tdid_lock_epmutex = 1;\n\t}\n \tif (op == EPOLL_CTL_ADD) {\n \t\tif (is_file_epoll(tfile)) {\n \t\t\terror = -ELOOP;\n\t\t\tif (ep_loop_check(ep, tfile) != 0)\n \t\t\t\tgoto error_tgt_fput;\n \t\t} else\n \t\t\tlist_add(&tfile->f_tfile_llink, &tfile_check_list);\n \t}\n\n\tmutex_lock_nested(&ep->mtx, 0);\n\n\t/*\n\t * Try to lookup the file inside our RB tree, Since we grabbed \"mtx\"\n\t * above, we can be sure to be able to use the item looked up by\n\t * ep_find() till we release the mutex.\n\t */\n\tepi = ep_find(ep, tfile, fd);\n\n\terror = -EINVAL;\n\tswitch (op) {\n\tcase EPOLL_CTL_ADD:\n\t\tif (!epi) {\n\t\t\tepds.events |= POLLERR | POLLHUP;\n\t\t\terror = ep_insert(ep, &epds, tfile, fd);\n\t\t} else\n\t\t\terror = -EEXIST;\n\t\tclear_tfile_check_list();\n\t\tbreak;\n\tcase EPOLL_CTL_DEL:\n\t\tif (epi)\n\t\t\terror = ep_remove(ep, epi);\n\t\telse\n\t\t\terror = -ENOENT;\n\t\tbreak;\n\tcase EPOLL_CTL_MOD:\n\t\tif (epi) {\n\t\t\tepds.events |= POLLERR | POLLHUP;\n\t\t\terror = ep_modify(ep, epi, &epds);\n\t\t} else\n\t\t\terror = -ENOENT;\n\t\tbreak;\n\t}\n\tmutex_unlock(&ep->mtx);\n\nerror_tgt_fput:\n\tif (did_lock_epmutex)\n\t\tmutex_unlock(&epmutex);\n\n\tfput(tfile);\nerror_fput:\n\tfput(file);\nerror_return:\n\n\treturn error;\n}\n", "target": 1, "idx": 178760}
{"func": "get_match(\n\tchar *s,\n\tstruct masks *m\n\t)\n{\n\twhile (m->name) {\n\t\tif (strcmp(s, m->name) == 0)\n\t\t\treturn m->mask;\n\t\telse\n\t\t\tm++;\n\t}\n\treturn 0;\n}\n", "target": 0, "idx": 74201}
{"func": "bool GetNetworkList(NetworkInterfaceList* networks, int policy) {\n  if (networks == NULL)\n    return false;\n\n  base::ThreadRestrictions::AssertIOAllowed();\n\n  ifaddrs* interfaces;\n  if (getifaddrs(&interfaces) < 0) {\n    PLOG(ERROR) << \"getifaddrs\";\n    return false;\n  }\n\n   std::unique_ptr<internal::IPAttributesGetter> ip_attributes_getter;\n \n #if defined(OS_MACOSX) && !defined(OS_IOS)\n  ip_attributes_getter = base::MakeUnique<internal::IPAttributesGetterMac>();\n #endif\n \n   bool result = internal::IfaddrsToNetworkInterfaceList(\n      policy, interfaces, ip_attributes_getter.get(), networks);\n  freeifaddrs(interfaces);\n  return result;\n}\n", "target": 1, "idx": 187287}
{"func": "static void copyMultiCh16(short *dst, const int *const *src, unsigned nSamples, unsigned nChannels)\n {\n     for (unsigned i = 0; i < nSamples; ++i) {\n         for (unsigned c = 0; c < nChannels; ++c) {\n *dst++ = src[c][i];\n }\n }\n}\n", "target": 1, "idx": 188040}
{"func": "static void reflectedTreatNullAsNullStringURLAttrAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)\n{\n    TestObject* imp = V8TestObject::toNative(info.Holder());\n    v8SetReturnValueString(info, imp->getURLAttribute(HTMLNames::reflectedtreatnullasnullstringurlattrAttr), info.GetIsolate());\n}\n", "target": 0, "idx": 131035}
{"func": "void LogoService::GetLogo(LogoCallbacks callbacks) {\n  if (!template_url_service_) {\n    RunCallbacksWithDisabled(std::move(callbacks));\n    return;\n  }\n  const TemplateURL* template_url =\n      template_url_service_->GetDefaultSearchProvider();\n  if (!template_url) {\n    RunCallbacksWithDisabled(std::move(callbacks));\n    return;\n  }\n  const base::CommandLine* command_line =\n      base::CommandLine::ForCurrentProcess();\n  GURL logo_url;\n  if (command_line->HasSwitch(switches::kSearchProviderLogoURL)) {\n    logo_url = GURL(\n        command_line->GetSwitchValueASCII(switches::kSearchProviderLogoURL));\n  } else {\n#if defined(OS_ANDROID)\n    logo_url = template_url->logo_url();\n#endif\n  }\n  GURL base_url;\n  GURL doodle_url;\n  const bool is_google = template_url->url_ref().HasGoogleBaseURLs(\n      template_url_service_->search_terms_data());\n  if (is_google) {\n    base_url =\n        GURL(template_url_service_->search_terms_data().GoogleBaseURLValue());\n    doodle_url = search_provider_logos::GetGoogleDoodleURL(base_url);\n  } else if (base::FeatureList::IsEnabled(features::kThirdPartyDoodles)) {\n    if (command_line->HasSwitch(switches::kThirdPartyDoodleURL)) {\n      doodle_url = GURL(\n          command_line->GetSwitchValueASCII(switches::kThirdPartyDoodleURL));\n    } else {\n      std::string override_url = base::GetFieldTrialParamValueByFeature(\n          features::kThirdPartyDoodles,\n          features::kThirdPartyDoodlesOverrideUrlParam);\n      if (!override_url.empty()) {\n        doodle_url = GURL(override_url);\n      } else {\n        doodle_url = template_url->doodle_url();\n      }\n    }\n    base_url = doodle_url.GetOrigin();\n  }\n  if (!logo_url.is_valid() && !doodle_url.is_valid()) {\n    RunCallbacksWithDisabled(std::move(callbacks));\n    return;\n  }\n  const bool use_fixed_logo = !doodle_url.is_valid();\n  if (!logo_tracker_) {\n    std::unique_ptr<LogoCache> logo_cache = std::move(logo_cache_for_test_);\n    if (!logo_cache) {\n      logo_cache = std::make_unique<LogoCache>(cache_directory_);\n    }\n    std::unique_ptr<base::Clock> clock = std::move(clock_for_test_);\n    if (!clock) {\n      clock = std::make_unique<base::DefaultClock>();\n    }\n    logo_tracker_ = std::make_unique<LogoTracker>(\n        request_context_getter_,\n        std::make_unique<LogoDelegateImpl>(std::move(image_decoder_)),\n        std::move(logo_cache), std::move(clock));\n  }\n  if (use_fixed_logo) {\n    logo_tracker_->SetServerAPI(\n        logo_url, base::Bind(&search_provider_logos::ParseFixedLogoResponse),\n        base::Bind(&search_provider_logos::UseFixedLogoUrl));\n  } else if (is_google) {\n    logo_tracker_->SetServerAPI(\n        doodle_url,\n        search_provider_logos::GetGoogleParseLogoResponseCallback(base_url),\n        search_provider_logos::GetGoogleAppendQueryparamsCallback(\n            use_gray_background_));\n  } else {\n    logo_tracker_->SetServerAPI(\n        doodle_url,\n        base::Bind(&search_provider_logos::GoogleNewParseLogoResponse,\n                   base_url),\n        base::Bind(&search_provider_logos::GoogleNewAppendQueryparamsToLogoURL,\n                   use_gray_background_));\n  }\n  logo_tracker_->GetLogo(std::move(callbacks));\n}\n", "target": 1, "idx": 185830}
{"func": "int LE_init(LoudnessEnhancerContext *pContext)\n{\n    ALOGV(\"LE_init(%p)\", pContext);\n\n    pContext->mConfig.inputCfg.accessMode = EFFECT_BUFFER_ACCESS_READ;\n    pContext->mConfig.inputCfg.channels = AUDIO_CHANNEL_OUT_STEREO;\n    pContext->mConfig.inputCfg.format = AUDIO_FORMAT_PCM_16_BIT;\n    pContext->mConfig.inputCfg.samplingRate = 44100;\n    pContext->mConfig.inputCfg.bufferProvider.getBuffer = NULL;\n    pContext->mConfig.inputCfg.bufferProvider.releaseBuffer = NULL;\n    pContext->mConfig.inputCfg.bufferProvider.cookie = NULL;\n    pContext->mConfig.inputCfg.mask = EFFECT_CONFIG_ALL;\n    pContext->mConfig.outputCfg.accessMode = EFFECT_BUFFER_ACCESS_ACCUMULATE;\n    pContext->mConfig.outputCfg.channels = AUDIO_CHANNEL_OUT_STEREO;\n    pContext->mConfig.outputCfg.format = AUDIO_FORMAT_PCM_16_BIT;\n    pContext->mConfig.outputCfg.samplingRate = 44100;\n    pContext->mConfig.outputCfg.bufferProvider.getBuffer = NULL;\n    pContext->mConfig.outputCfg.bufferProvider.releaseBuffer = NULL;\n    pContext->mConfig.outputCfg.bufferProvider.cookie = NULL;\n    pContext->mConfig.outputCfg.mask = EFFECT_CONFIG_ALL;\n\n    pContext->mTargetGainmB = LOUDNESS_ENHANCER_DEFAULT_TARGET_GAIN_MB;\n float targetAmp = pow(10, pContext->mTargetGainmB/2000.0f); // mB to linear amplification\n    ALOGV(\"LE_init(): Target gain=%dmB <=> factor=%.2fX\", pContext->mTargetGainmB, targetAmp);\n\n if (pContext->mCompressor == NULL) {\n        pContext->mCompressor = new le_fx::AdaptiveDynamicRangeCompression();\n        pContext->mCompressor->Initialize(targetAmp, pContext->mConfig.inputCfg.samplingRate);\n }\n\n    LE_setConfig(pContext, &pContext->mConfig);\n\n return 0;\n}\n", "target": 0, "idx": 170546}
{"func": "static int rtecp_logout(sc_card_t *card)\n{\n\tsc_apdu_t apdu;\n\tint r;\n\n\tassert(card && card->ctx);\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_1, 0x40, 0, 0);\n\tapdu.cla = 0x80;\n\tr = sc_transmit_apdu(card, &apdu);\n\tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"APDU transmit failed\");\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);\n}\n", "target": 0, "idx": 78673}
{"func": "static int caif_seqpkt_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t       struct msghdr *m, size_t len, int flags)\n\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint ret;\n\tint copylen;\n\n\tret = -EOPNOTSUPP;\n \tif (m->msg_flags&MSG_OOB)\n \t\tgoto read_error;\n \n\tm->msg_namelen = 0;\n \tskb = skb_recv_datagram(sk, flags, 0 , &ret);\n \tif (!skb)\n \t\tgoto read_error;\n\tcopylen = skb->len;\n\tif (len < copylen) {\n\t\tm->msg_flags |= MSG_TRUNC;\n\t\tcopylen = len;\n\t}\n\n\tret = skb_copy_datagram_iovec(skb, 0, m->msg_iov, copylen);\n\tif (ret)\n\t\tgoto out_free;\n\n\tret = (flags & MSG_TRUNC) ? skb->len : copylen;\nout_free:\n\tskb_free_datagram(sk, skb);\n\tcaif_check_flow_release(sk);\n\treturn ret;\n\nread_error:\n\treturn ret;\n}\n", "target": 1, "idx": 179668}
{"func": "void Vp9Parser::ReadSegmentationData() {\n  segmentation_.abs_delta = reader_.ReadBool();\n \n   const int kFeatureDataBits[] = {7, 6, 2, 0};\n   const bool kFeatureDataSigned[] = {true, true, false, false};\n \n   for (size_t i = 0; i < Vp9Segmentation::kNumSegments; i++) {\n    for (size_t j = 0; j < Vp9Segmentation::SEG_LVL_MAX; j++) {\n       int8_t data = 0;\n      segmentation_.feature_enabled[i][j] = reader_.ReadBool();\n      if (segmentation_.feature_enabled[i][j]) {\n         data = reader_.ReadLiteral(kFeatureDataBits[j]);\n         if (kFeatureDataSigned[j])\n           if (reader_.ReadBool())\n             data = -data;\n       }\n      segmentation_.feature_data[i][j] = data;\n     }\n   }\n }\n", "target": 1, "idx": 183538}
{"func": " virtual void SetUp() {\n\n     fwd_txfm_ = GET_PARAM(0);\n     inv_txfm_ = GET_PARAM(1);\n     tx_type_  = GET_PARAM(2);\n     pitch_    = 16;\n     fwd_txfm_ref = fht16x16_ref;\n   }\n", "target": 1, "idx": 188550}
{"func": "kdc_process_s4u2self_req(kdc_realm_t *kdc_active_realm,\n                         krb5_kdc_req *request,\n                         krb5_const_principal client_princ,\n                         krb5_const_principal header_srv_princ,\n                         krb5_boolean issuing_referral,\n                         const krb5_db_entry *server,\n                         krb5_keyblock *tgs_subkey,\n                         krb5_keyblock *tgs_session,\n                         krb5_timestamp kdc_time,\n                         krb5_pa_s4u_x509_user **s4u_x509_user,\n                         krb5_db_entry **princ_ptr,\n                         const char **status)\n{\n    krb5_error_code             code;\n    krb5_boolean                is_local_tgt;\n    krb5_pa_data                *pa_data;\n    int                         flags;\n    krb5_db_entry               *princ;\n\n    *princ_ptr = NULL;\n\n    pa_data = krb5int_find_pa_data(kdc_context,\n                                   request->padata, KRB5_PADATA_S4U_X509_USER);\n    if (pa_data != NULL) {\n        code = kdc_process_s4u_x509_user(kdc_context,\n                                         request,\n                                         pa_data,\n                                         tgs_subkey,\n                                         tgs_session,\n                                         s4u_x509_user,\n                                         status);\n        if (code != 0)\n            return code;\n    } else {\n        pa_data = krb5int_find_pa_data(kdc_context,\n                                       request->padata, KRB5_PADATA_FOR_USER);\n        if (pa_data != NULL) {\n            code = kdc_process_for_user(kdc_active_realm,\n                                        pa_data,\n                                        tgs_session,\n                                        s4u_x509_user,\n                                        status);\n            if (code != 0)\n                return code;\n        } else\n            return 0;\n    }\n\n    /*\n     * We need to compare the client name in the TGT with the requested\n     * server name. Supporting server name aliases without assuming a\n     * global name service makes this difficult to do.\n     *\n     * The comparison below handles the following cases (note that the\n     * term \"principal name\" below excludes the realm).\n     *\n     * (1) The requested service is a host-based service with two name\n     *     components, in which case we assume the principal name to\n     *     contain sufficient qualifying information. The realm is\n     *     ignored for the purpose of comparison.\n     *\n     * (2) The requested service name is an enterprise principal name:\n     *     the service principal name is compared with the unparsed\n     *     form of the client name (including its realm).\n     *\n     * (3) The requested service is some other name type: an exact\n     *     match is required.\n     *\n     * An alternative would be to look up the server once again with\n     * FLAG_CANONICALIZE | FLAG_CLIENT_REFERRALS_ONLY set, do an exact\n     * match between the returned name and client_princ. However, this\n     * assumes that the client set FLAG_CANONICALIZE when requesting\n     * the TGT and that we have a global name service.\n     */\n    flags = 0;\n    switch (krb5_princ_type(kdc_context, request->server)) {\n    case KRB5_NT_SRV_HST:                   /* (1) */\n        if (krb5_princ_size(kdc_context, request->server) == 2)\n            flags |= KRB5_PRINCIPAL_COMPARE_IGNORE_REALM;\n        break;\n    case KRB5_NT_ENTERPRISE_PRINCIPAL:      /* (2) */\n        flags |= KRB5_PRINCIPAL_COMPARE_ENTERPRISE;\n        break;\n    default:                                /* (3) */\n        break;\n    }\n\n    if (!krb5_principal_compare_flags(kdc_context,\n                                      request->server,\n                                      client_princ,\n                                      flags)) {\n        *status = \"INVALID_S4U2SELF_REQUEST\";\n        return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN; /* match Windows error code */\n    }\n\n    /*\n     * Protocol transition is mutually exclusive with renew/forward/etc\n     * as well as user-to-user and constrained delegation. This check\n     * is also made in validate_as_request().\n     *\n     * We can assert from this check that the header ticket was a TGT, as\n     * that is validated previously in validate_tgs_request().\n     */\n    if (request->kdc_options & AS_INVALID_OPTIONS) {\n        *status = \"INVALID AS OPTIONS\";\n        return KRB5KDC_ERR_BADOPTION;\n    }\n\n    /*\n     * Valid S4U2Self requests can occur in the following combinations:\n     *\n     * (1) local TGT, local user, local server\n     * (2) cross TGT, local user, issuing referral\n     * (3) cross TGT, non-local user, issuing referral\n     * (4) cross TGT, non-local user, local server\n     *\n     * The first case is for a single-realm S4U2Self scenario; the second,\n     * third, and fourth cases are for the initial, intermediate (if any), and\n     * final cross-realm requests in a multi-realm scenario.\n     */\n\n    is_local_tgt = !is_cross_tgs_principal(header_srv_princ);\n    if (is_local_tgt && issuing_referral) {\n        /* The requesting server appears to no longer exist, and we found\n         * a referral instead.  Treat this as a server lookup failure. */\n        *status = \"LOOKING_UP_SERVER\";\n        return KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n    }\n\n    /*\n     * Do not attempt to lookup principals in foreign realms.\n     */\n    if (is_local_principal(kdc_active_realm,\n                           (*s4u_x509_user)->user_id.user)) {\n        krb5_db_entry no_server;\n        krb5_pa_data **e_data = NULL;\n\n        if (!is_local_tgt && !issuing_referral) {\n            /* A local server should not need a cross-realm TGT to impersonate\n             * a local principal. */\n            *status = \"NOT_CROSS_REALM_REQUEST\";\n            return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN; /* match Windows error */\n        }\n\n        code = krb5_db_get_principal(kdc_context,\n                                     (*s4u_x509_user)->user_id.user,\n                                     KRB5_KDB_FLAG_INCLUDE_PAC, &princ);\n        if (code == KRB5_KDB_NOENTRY) {\n            *status = \"UNKNOWN_S4U2SELF_PRINCIPAL\";\n            return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n        } else if (code) {\n            *status = \"LOOKING_UP_S4U2SELF_PRINCIPAL\";\n            return code; /* caller can free for_user */\n        }\n \n         memset(&no_server, 0, sizeof(no_server));\n \n         code = validate_as_request(kdc_active_realm, request, *princ,\n                                    no_server, kdc_time, status, &e_data);\n         if (code) {\n            krb5_db_free_principal(kdc_context, princ);\n            krb5_free_pa_data(kdc_context, e_data);\n            return code;\n        }\n\n        *princ_ptr = princ;\n    } else if (is_local_tgt) {\n        /*\n         * The server is asking to impersonate a principal from another realm,\n         * using a local TGT.  It should instead ask that principal's realm and\n         * follow referrals back to us.\n         */\n        *status = \"S4U2SELF_CLIENT_NOT_OURS\";\n        return KRB5KDC_ERR_POLICY; /* match Windows error */\n    }\n\n    return 0;\n}\n", "target": 1, "idx": 182129}
{"func": "void Document::dispose()\n{\n    ASSERT_WITH_SECURITY_IMPLICATION(!m_deletionHasBegun);\n    m_docType = 0;\n    m_focusedElement = 0;\n    m_hoverNode = 0;\n    m_activeElement = 0;\n    m_titleElement = 0;\n    m_documentElement = 0;\n    m_contextFeatures = ContextFeatures::defaultSwitch();\n    m_userActionElements.documentDidRemoveLastRef();\n    m_associatedFormControls.clear();\n\n    detachParser();\n\n    m_registrationContext.clear();\n\n    if (m_import) {\n        m_import->wasDetachedFromDocument();\n        m_import = 0;\n    }\n\n    destroyTreeScopeData();\n    removeDetachedChildren();\n    m_formController.clear();\n\n    m_markers->detach();\n\n    m_cssCanvasElements.clear();\n\n    if (m_scriptedAnimationController)\n        m_scriptedAnimationController->clearDocumentPointer();\n    m_scriptedAnimationController.clear();\n\n    if (svgExtensions())\n        accessSVGExtensions()->pauseAnimations();\n\n    m_lifecyle.advanceTo(DocumentLifecycle::Disposed);\n    lifecycleNotifier()->notifyDocumentWasDisposed();\n}\n", "target": 0, "idx": 109652}
{"func": "int CCITTFaxStream::lookChar() {\n  int code1, code2, code3;\n  int b1i, blackPixels, i, bits;\n  GBool gotEOL;\n\n  if (buf != EOF) {\n    return buf;\n  }\n\n  if (outputBits == 0) {\n\n    if (eof) {\n      return EOF;\n    }\n\n    err = gFalse;\n\n    if (nextLine2D) {\n       for (i = 0; i < columns && codingLine[i] < columns; ++i) {\n \trefLine[i] = codingLine[i];\n       }\n      refLine[i++] = columns;\n      refLine[i] = columns;\n       codingLine[0] = 0;\n       a0i = 0;\n       b1i = 0;\n      while (codingLine[a0i] < columns && !err) {\n\tcode1 = getTwoDimCode();\n\tswitch (code1) {\n\tcase twoDimPass:\n\t  if (likely(b1i + 1 < columns + 2)) {\n\t    addPixels(refLine[b1i + 1], blackPixels);\n\t    if (refLine[b1i + 1] < columns) {\n\t      b1i += 2;\n\t    }\n\t  }\n\t  break;\n\tcase twoDimHoriz:\n\t  code1 = code2 = 0;\n\t  if (blackPixels) {\n\t    do {\n\t      code1 += code3 = getBlackCode();\n\t    } while (code3 >= 64);\n\t    do {\n\t      code2 += code3 = getWhiteCode();\n\t    } while (code3 >= 64);\n\t  } else {\n\t    do {\n\t      code1 += code3 = getWhiteCode();\n\t    } while (code3 >= 64);\n\t    do {\n\t      code2 += code3 = getBlackCode();\n\t    } while (code3 >= 64);\n\t  }\n\t  addPixels(codingLine[a0i] + code1, blackPixels);\n\t  if (codingLine[a0i] < columns) {\n\t    addPixels(codingLine[a0i] + code2, blackPixels ^ 1);\n\t  }\n\t  while (refLine[b1i] <= codingLine[a0i] && refLine[b1i] < columns) {\n\t    b1i += 2;\n\t    if (unlikely(b1i > columns + 1)) {\n\t      error(errSyntaxError, getPos(),\n\t\t\"Bad 2D code {0:04x} in CCITTFax stream\", code1);\n\t      err = gTrue;\n\t      break;\n\t    }\n\t  }\n\t  break;\n\tcase twoDimVertR3:\n\t  if (unlikely(b1i > columns + 1)) {\n\t    error(errSyntaxError, getPos(),\n\t      \"Bad 2D code {0:04x} in CCITTFax stream\", code1);\n\t    err = gTrue;\n\t    break;\n\t  }\n\t  addPixels(refLine[b1i] + 3, blackPixels);\n\t  blackPixels ^= 1;\n\t  if (codingLine[a0i] < columns) {\n\t    ++b1i;\n\t    while (refLine[b1i] <= codingLine[a0i] && refLine[b1i] < columns) {\n\t      b1i += 2;\n\t      if (unlikely(b1i > columns + 1)) {\n\t\terror(errSyntaxError, getPos(),\n\t\t  \"Bad 2D code {0:04x} in CCITTFax stream\", code1);\n\t\terr = gTrue;\n\t\tbreak;\n\t      }\n\t    }\n\t  }\n\t  break;\n\tcase twoDimVertR2:\n\t  if (unlikely(b1i > columns + 1)) {\n\t    error(errSyntaxError, getPos(),\n\t      \"Bad 2D code {0:04x} in CCITTFax stream\", code1);\n\t    err = gTrue;\n\t    break;\n\t  }\n\t  addPixels(refLine[b1i] + 2, blackPixels);\n\t  blackPixels ^= 1;\n\t  if (codingLine[a0i] < columns) {\n\t    ++b1i;\n\t    while (refLine[b1i] <= codingLine[a0i] && refLine[b1i] < columns) {\n\t      b1i += 2;\n\t      if (unlikely(b1i > columns + 1)) {\n\t\terror(errSyntaxError, getPos(),\n\t\t  \"Bad 2D code {0:04x} in CCITTFax stream\", code1);\n\t\terr = gTrue;\n\t\tbreak;\n\t      }\n\t    }\n\t  }\n\t  break;\n\tcase twoDimVertR1:\n\t  if (unlikely(b1i > columns + 1)) {\n\t    error(errSyntaxError, getPos(),\n\t      \"Bad 2D code {0:04x} in CCITTFax stream\", code1);\n\t    err = gTrue;\n\t    break;\n\t  }\n\t  addPixels(refLine[b1i] + 1, blackPixels);\n\t  blackPixels ^= 1;\n\t  if (codingLine[a0i] < columns) {\n\t    ++b1i;\n\t    while (refLine[b1i] <= codingLine[a0i] && refLine[b1i] < columns) {\n\t      b1i += 2;\n\t      if (unlikely(b1i > columns + 1)) {\n\t\terror(errSyntaxError, getPos(),\n\t\t  \"Bad 2D code {0:04x} in CCITTFax stream\", code1);\n\t\terr = gTrue;\n\t\tbreak;\n\t      }\n\t    }\n\t  }\n\t  break;\n\tcase twoDimVert0:\n\t  if (unlikely(b1i > columns + 1)) {\n\t    error(errSyntaxError, getPos(),\n\t      \"Bad 2D code {0:04x} in CCITTFax stream\", code1);\n\t    err = gTrue;\n\t    break;\n\t  }\n\t  addPixels(refLine[b1i], blackPixels);\n\t  blackPixels ^= 1;\n\t  if (codingLine[a0i] < columns) {\n\t    ++b1i;\n\t    while (refLine[b1i] <= codingLine[a0i] && refLine[b1i] < columns) {\n\t      b1i += 2;\n\t      if (unlikely(b1i > columns + 1)) {\n\t\terror(errSyntaxError, getPos(),\n\t\t  \"Bad 2D code {0:04x} in CCITTFax stream\", code1);\n\t\terr = gTrue;\n\t\tbreak;\n\t      }\n\t    }\n\t  }\n\t  break;\n\tcase twoDimVertL3:\n\t  if (unlikely(b1i > columns + 1)) {\n\t    error(errSyntaxError, getPos(),\n\t      \"Bad 2D code {0:04x} in CCITTFax stream\", code1);\n\t    err = gTrue;\n\t    break;\n\t  }\n\t  addPixelsNeg(refLine[b1i] - 3, blackPixels);\n\t  blackPixels ^= 1;\n\t  if (codingLine[a0i] < columns) {\n\t    if (b1i > 0) {\n\t      --b1i;\n\t    } else {\n\t      ++b1i;\n\t    }\n\t    while (refLine[b1i] <= codingLine[a0i] && refLine[b1i] < columns) {\n\t      b1i += 2;\n\t      if (unlikely(b1i > columns + 1)) {\n\t\terror(errSyntaxError, getPos(),\n\t\t  \"Bad 2D code {0:04x} in CCITTFax stream\", code1);\n\t\terr = gTrue;\n\t\tbreak;\n\t      }\n\t    }\n\t  }\n\t  break;\n\tcase twoDimVertL2:\n\t  if (unlikely(b1i > columns + 1)) {\n\t    error(errSyntaxError, getPos(),\n\t      \"Bad 2D code {0:04x} in CCITTFax stream\", code1);\n\t    err = gTrue;\n\t    break;\n\t  }\n\t  addPixelsNeg(refLine[b1i] - 2, blackPixels);\n\t  blackPixels ^= 1;\n\t  if (codingLine[a0i] < columns) {\n\t    if (b1i > 0) {\n\t      --b1i;\n\t    } else {\n\t      ++b1i;\n\t    }\n\t    while (refLine[b1i] <= codingLine[a0i] && refLine[b1i] < columns) {\n\t      b1i += 2;\n\t      if (unlikely(b1i > columns + 1)) {\n\t        error(errSyntaxError, getPos(),\n\t\t  \"Bad 2D code {0:04x} in CCITTFax stream\", code1);\n\t        err = gTrue;\n\t        break;\n\t      }\n\t    }\n\t  }\n\t  break;\n\tcase twoDimVertL1:\n\t  if (unlikely(b1i > columns + 1)) {\n\t    error(errSyntaxError, getPos(),\n\t      \"Bad 2D code {0:04x} in CCITTFax stream\", code1);\n\t    err = gTrue;\n\t    break;\n\t  }\n\t  addPixelsNeg(refLine[b1i] - 1, blackPixels);\n\t  blackPixels ^= 1;\n\t  if (codingLine[a0i] < columns) {\n\t    if (b1i > 0) {\n\t      --b1i;\n\t    } else {\n\t      ++b1i;\n\t    }\n\t    while (refLine[b1i] <= codingLine[a0i] && refLine[b1i] < columns) {\n\t      b1i += 2;\n\t      if (unlikely(b1i > columns + 1)) {\n\t\terror(errSyntaxError, getPos(),\n\t\t  \"Bad 2D code {0:04x} in CCITTFax stream\", code1);\n\t\terr = gTrue;\n\t\tbreak;\n\t      }\n\t    }\n\t  }\n\t  break;\n\tcase EOF:\n\t  addPixels(columns, 0);\n\t  eof = gTrue;\n\t  break;\n\tdefault:\n\t  error(errSyntaxError, getPos(),\n\t\t\"Bad 2D code {0:04x} in CCITTFax stream\", code1);\n\t  addPixels(columns, 0);\n\t  err = gTrue;\n\t  break;\n\t}\n      }\n\n    } else {\n      codingLine[0] = 0;\n      a0i = 0;\n      blackPixels = 0;\n      while (codingLine[a0i] < columns) {\n\tcode1 = 0;\n\tif (blackPixels) {\n\t  do {\n\t    code1 += code3 = getBlackCode();\n\t  } while (code3 >= 64);\n\t} else {\n\t  do {\n\t    code1 += code3 = getWhiteCode();\n\t  } while (code3 >= 64);\n\t}\n\taddPixels(codingLine[a0i] + code1, blackPixels);\n\tblackPixels ^= 1;\n      }\n    }\n\n    gotEOL = gFalse;\n    if (!endOfBlock && row == rows - 1) {\n      eof = gTrue;\n    } else if (endOfLine || !byteAlign) {\n      code1 = lookBits(12);\n      if (endOfLine) {\n\twhile (code1 != EOF && code1 != 0x001) {\n\t  eatBits(1);\n\t  code1 = lookBits(12);\n\t}\n      } else {\n\twhile (code1 == 0) {\n\t  eatBits(1);\n\t  code1 = lookBits(12);\n\t}\n      }\n      if (code1 == 0x001) {\n\teatBits(12);\n\tgotEOL = gTrue;\n      }\n    }\n\n    if (byteAlign && !gotEOL) {\n      inputBits &= ~7;\n    }\n\n    if (lookBits(1) == EOF) {\n      eof = gTrue;\n    }\n\n    if (!eof && encoding > 0) {\n      nextLine2D = !lookBits(1);\n      eatBits(1);\n    }\n\n    if (endOfBlock && !endOfLine && byteAlign) {\n      code1 = lookBits(24);\n      if (code1 == 0x001001) {\n\teatBits(12);\n\tgotEOL = gTrue;\n      }\n    }\n    if (endOfBlock && gotEOL) {\n      code1 = lookBits(12);\n      if (code1 == 0x001) {\n\teatBits(12);\n\tif (encoding > 0) {\n\t  lookBits(1);\n\t  eatBits(1);\n\t}\n\tif (encoding >= 0) {\n\t  for (i = 0; i < 4; ++i) {\n\t    code1 = lookBits(12);\n\t    if (code1 != 0x001) {\n\t      error(errSyntaxError, getPos(),\n\t\t    \"Bad RTC code in CCITTFax stream\");\n\t    }\n\t    eatBits(12);\n\t    if (encoding > 0) {\n\t      lookBits(1);\n\t      eatBits(1);\n\t    }\n\t  }\n\t}\n\teof = gTrue;\n      }\n\n    } else if (err && endOfLine) {\n      while (1) {\n\tcode1 = lookBits(13);\n\tif (code1 == EOF) {\n\t  eof = gTrue;\n\t  return EOF;\n\t}\n\tif ((code1 >> 1) == 0x001) {\n\t  break;\n\t}\n\teatBits(1);\n      }\n      eatBits(12); \n      if (encoding > 0) {\n\teatBits(1);\n\tnextLine2D = !(code1 & 1);\n      }\n    }\n\n    if (codingLine[0] > 0) {\n      outputBits = codingLine[a0i = 0];\n    } else {\n      outputBits = codingLine[a0i = 1];\n    }\n\n    ++row;\n  }\n\n  if (outputBits >= 8) {\n    buf = (a0i & 1) ? 0x00 : 0xff;\n    outputBits -= 8;\n    if (outputBits == 0 && codingLine[a0i] < columns) {\n      ++a0i;\n      outputBits = codingLine[a0i] - codingLine[a0i - 1];\n    }\n  } else {\n    bits = 8;\n    buf = 0;\n    do {\n      if (outputBits > bits) {\n\tbuf <<= bits;\n\tif (!(a0i & 1)) {\n\t  buf |= 0xff >> (8 - bits);\n\t}\n\toutputBits -= bits;\n\tbits = 0;\n      } else {\n\tbuf <<= outputBits;\n\tif (!(a0i & 1)) {\n\t  buf |= 0xff >> (8 - outputBits);\n\t}\n\tbits -= outputBits;\n\toutputBits = 0;\n\tif (codingLine[a0i] < columns) {\n\t  ++a0i;\n\t  if (unlikely(a0i > columns)) {\n\t    error(errSyntaxError, getPos(),\n\t      \"Bad bits {0:04x} in CCITTFax stream\", bits);\n\t      err = gTrue;\n\t      break;\n\t  }\n\t  outputBits = codingLine[a0i] - codingLine[a0i - 1];\n\t} else if (bits > 0) {\n\t  buf <<= bits;\n\t  bits = 0;\n\t}\n      }\n    } while (bits);\n  }\n  if (black) {\n    buf ^= 0xff;\n  }\n  return buf;\n}\n", "target": 1, "idx": 177902}
{"func": "static void kvm_iommu_put_pages(struct kvm *kvm,\n\t\t\t\tgfn_t base_gfn, unsigned long npages)\n{\n\tstruct iommu_domain *domain;\n\tgfn_t end_gfn, gfn;\n\tpfn_t pfn;\n\tu64 phys;\n\n\tdomain  = kvm->arch.iommu_domain;\n\tend_gfn = base_gfn + npages;\n\tgfn     = base_gfn;\n\n\t/* check if iommu exists and in use */\n\tif (!domain)\n\t\treturn;\n\n\twhile (gfn < end_gfn) {\n\t\tunsigned long unmap_pages;\n\t\tsize_t size;\n\n\t\t/* Get physical address */\n\t\tphys = iommu_iova_to_phys(domain, gfn_to_gpa(gfn));\n\t\tpfn  = phys >> PAGE_SHIFT;\n\n\t\t/* Unmap address from IO address space */\n\t\tsize       = iommu_unmap(domain, gfn_to_gpa(gfn), PAGE_SIZE);\n\t\tunmap_pages = 1ULL << get_order(size);\n\n\t\t/* Unpin all pages we just unmapped to not leak any memory */\n\t\tkvm_unpin_pages(kvm, pfn, unmap_pages);\n\n\t\tgfn += unmap_pages;\n \t}\n }\n", "target": 0, "idx": 20293}
{"func": "void OmniboxViewViews::SelectAll(bool reversed) {\n  views::Textfield::SelectAll(reversed);\n}\n", "target": 0, "idx": 134295}
{"func": "static inline signed int ReadPropertySignedLong(const EndianType endian,\n  const unsigned char *buffer)\n{\n  union\n  {\n    unsigned int\n      unsigned_value;\n\n    signed int\n      signed_value;\n  } quantum;\n\n  unsigned int\n    value;\n \n   if (endian == LSBEndian)\n     {\n      value=(unsigned int) ((buffer[3] << 24) | (buffer[2] << 16) |\n        (buffer[1] << 8 ) | (buffer[0]));\n      quantum.unsigned_value=(value & 0xffffffff);\n       return(quantum.signed_value);\n     }\n  value=(unsigned int) ((buffer[0] << 24) | (buffer[1] << 16) |\n    (buffer[2] << 8) | buffer[3]);\n  quantum.unsigned_value=(value & 0xffffffff);\n   return(quantum.signed_value);\n }\n", "target": 1, "idx": 183126}
{"func": "void CuePoint::TrackPosition::Parse(\n    IMkvReader* pReader,\n    long long start_,\n    long long size_)\n{\n    const long long stop = start_ + size_;\n    long long pos = start_;\n \n    m_track = -1;\n    m_pos = -1;\n    m_block = 1;  //default\n \n    while (pos < stop)\n    {\n        long len;\n \n        const long long id = ReadUInt(pReader, pos, len);\n        assert(id >= 0);  //TODO\n        assert((pos + len) <= stop);\n \n        pos += len;  //consume ID\n \n        const long long size = ReadUInt(pReader, pos, len);\n        assert(size >= 0);\n        assert((pos + len) <= stop);\n \n        pos += len;  //consume Size field\n        assert((pos + size) <= stop);\n \n        if (id == 0x77)  //CueTrack ID\n            m_track = UnserializeUInt(pReader, pos, size);\n \n        else if (id == 0x71)  //CueClusterPos ID\n            m_pos = UnserializeUInt(pReader, pos, size);\n \n        else if (id == 0x1378)  //CueBlockNumber\n            m_block = UnserializeUInt(pReader, pos, size);\n        pos += size;  //consume payload\n        assert(pos <= stop);\n    }\n    assert(m_pos >= 0);\n    assert(m_track > 0);\n }\n", "target": 1, "idx": 188436}
{"func": "static int handle_ept_violation(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification;\n\tgpa_t gpa;\n\tu64 error_code;\n\n\texit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\n\t/*\n\t * EPT violation happened while executing iret from NMI,\n\t * \"blocked by NMI\" bit has to be set before next VM entry.\n\t * There are errata that may cause this bit to not be set:\n\t * AAK134, BY25.\n\t */\n\tif (!(to_vmx(vcpu)->idt_vectoring_info & VECTORING_INFO_VALID_MASK) &&\n\t\t\t(exit_qualification & INTR_INFO_UNBLOCK_NMI))\n\t\tvmcs_set_bits(GUEST_INTERRUPTIBILITY_INFO, GUEST_INTR_STATE_NMI);\n\n\tgpa = vmcs_read64(GUEST_PHYSICAL_ADDRESS);\n\ttrace_kvm_page_fault(gpa, exit_qualification);\n\n\t/* Is it a read fault? */\n\terror_code = (exit_qualification & EPT_VIOLATION_ACC_READ)\n\t\t     ? PFERR_USER_MASK : 0;\n\t/* Is it a write fault? */\n\terror_code |= (exit_qualification & EPT_VIOLATION_ACC_WRITE)\n\t\t      ? PFERR_WRITE_MASK : 0;\n\t/* Is it a fetch fault? */\n\terror_code |= (exit_qualification & EPT_VIOLATION_ACC_INSTR)\n\t\t      ? PFERR_FETCH_MASK : 0;\n\t/* ept page table entry is present? */\n\terror_code |= (exit_qualification &\n\t\t       (EPT_VIOLATION_READABLE | EPT_VIOLATION_WRITABLE |\n\t\t\tEPT_VIOLATION_EXECUTABLE))\n\t\t      ? PFERR_PRESENT_MASK : 0;\n\n\terror_code |= (exit_qualification & 0x100) != 0 ?\n\t       PFERR_GUEST_FINAL_MASK : PFERR_GUEST_PAGE_MASK;\n\n\tvcpu->arch.exit_qualification = exit_qualification;\n\treturn kvm_mmu_page_fault(vcpu, gpa, error_code, NULL, 0);\n}\n", "target": 0, "idx": 62962}
{"func": "  CaptionButtonModel(uint32_t visible_button_mask, uint32_t enabled_button_mask)\n      : visible_button_mask_(visible_button_mask),\n        enabled_button_mask_(enabled_button_mask) {}\n", "target": 0, "idx": 150351}
{"func": "ptaGetIPt(PTA      *pta,\n          l_int32   index,\n          l_int32  *px,\n          l_int32  *py)\n{\n    PROCNAME(\"ptaGetIPt\");\n\n    if (px) *px = 0;\n    if (py) *py = 0;\n    if (!pta)\n        return ERROR_INT(\"pta not defined\", procName, 1);\n    if (index < 0 || index >= pta->n)\n        return ERROR_INT(\"invalid index\", procName, 1);\n\n    if (px) *px = (l_int32)(pta->x[index] + 0.5);\n    if (py) *py = (l_int32)(pta->y[index] + 0.5);\n    return 0;\n}\n", "target": 0, "idx": 84174}
{"func": "PHYSICALPATH_FUNC(mod_alias_physical_handler) {\n\tplugin_data *p = p_d;\n\tint uri_len, basedir_len;\n\tchar *uri_ptr;\n\tsize_t k;\n\n\tif (buffer_is_empty(con->physical.path)) return HANDLER_GO_ON;\n\n\tmod_alias_patch_connection(srv, con, p);\n\n\t/* not to include the tailing slash */\n\tbasedir_len = buffer_string_length(con->physical.basedir);\n\tif ('/' == con->physical.basedir->ptr[basedir_len-1]) --basedir_len;\n\turi_len = buffer_string_length(con->physical.path) - basedir_len;\n\turi_ptr = con->physical.path->ptr + basedir_len;\n\n\tfor (k = 0; k < p->conf.alias->used; k++) {\n\t\tdata_string *ds = (data_string *)p->conf.alias->data[k];\n\t\tint alias_len = buffer_string_length(ds->key);\n\n\t\tif (alias_len > uri_len) continue;\n\t\tif (buffer_is_empty(ds->key)) continue;\n\n\t\tif (0 == (con->conf.force_lowercase_filenames ?\n\t\t\t\t\tstrncasecmp(uri_ptr, ds->key->ptr, alias_len) :\n \t\t\t\t\tstrncmp(uri_ptr, ds->key->ptr, alias_len))) {\n \t\t\t/* matched */\n \n \t\t\tbuffer_copy_buffer(con->physical.basedir, ds->value);\n \t\t\tbuffer_copy_buffer(srv->tmp_buf, ds->value);\n \t\t\tbuffer_append_string(srv->tmp_buf, uri_ptr + alias_len);\n\t\t\tbuffer_copy_buffer(con->physical.path, srv->tmp_buf);\n\n\t\t\treturn HANDLER_GO_ON;\n\t\t}\n\t}\n\n\t/* not found */\n\treturn HANDLER_GO_ON;\n}\n", "target": 1, "idx": 182151}
{"func": " ExtensionsGuestViewMessageFilter::~ExtensionsGuestViewMessageFilter() {\n   DCHECK_CURRENTLY_ON(BrowserThread::IO);\n  (*GetProcessIdToFilterMap())[render_process_id_] = nullptr;\n  base::PostTaskWithTraits(\n      FROM_HERE, BrowserThread::UI,\n      base::BindOnce(RemoveProcessIdFromGlobalMap, render_process_id_));\n }\n", "target": 1, "idx": 187031}
{"func": "spnego_gss_import_name(\n\t\t    OM_uint32 *minor_status,\n\t\t    gss_buffer_t input_name_buffer,\n\t\t    gss_OID input_name_type,\n\t\t    gss_name_t *output_name)\n{\n\tOM_uint32 status;\n\n\tdsyslog(\"Entering import_name\\n\");\n\n\tstatus = gss_import_name(minor_status, input_name_buffer,\n\t\t\tinput_name_type, output_name);\n\n\tdsyslog(\"Leaving import_name\\n\");\n\treturn (status);\n}\n", "target": 0, "idx": 36754}
{"func": "void DevToolsUIBindings::SetDelegate(Delegate* delegate) {\n  delegate_.reset(delegate);\n}\n", "target": 0, "idx": 151032}
{"func": "void SoftMPEG4::onQueueFilled(OMX_U32 /* portIndex */) {\n if (mSignalledError || mOutputPortSettingsChange != NONE) {\n return;\n }\n\n List<BufferInfo *> &inQueue = getPortQueue(0);\n List<BufferInfo *> &outQueue = getPortQueue(1);\n\n while (!inQueue.empty() && outQueue.size() == kNumOutputBuffers) {\n BufferInfo *inInfo = *inQueue.begin();\n        OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;\n if (inHeader == NULL) {\n            inQueue.erase(inQueue.begin());\n            inInfo->mOwnedByUs = false;\n continue;\n }\n\n PortInfo *port = editPortInfo(1);\n\n        OMX_BUFFERHEADERTYPE *outHeader =\n            port->mBuffers.editItemAt(mNumSamplesOutput & 1).mHeader;\n\n if (inHeader->nFilledLen == 0) {\n            inQueue.erase(inQueue.begin());\n            inInfo->mOwnedByUs = false;\n            notifyEmptyBufferDone(inHeader);\n\n ++mInputBufferCount;\n\n if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {\n                outHeader->nFilledLen = 0;\n                outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n\n List<BufferInfo *>::iterator it = outQueue.begin();\n while ((*it)->mHeader != outHeader) {\n ++it;\n }\n\n BufferInfo *outInfo = *it;\n                outInfo->mOwnedByUs = false;\n                outQueue.erase(it);\n                outInfo = NULL;\n\n                notifyFillBufferDone(outHeader);\n                outHeader = NULL;\n }\n return;\n }\n\n uint8_t *bitstream = inHeader->pBuffer + inHeader->nOffset;\n uint32_t *start_code = (uint32_t *)bitstream;\n bool volHeader = *start_code == 0xB0010000;\n if (volHeader) {\n PVCleanUpVideoDecoder(mHandle);\n            mInitialized = false;\n }\n\n if (!mInitialized) {\n uint8_t *vol_data[1];\n int32_t vol_size = 0;\n\n            vol_data[0] = NULL;\n\n if ((inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) || volHeader) {\n                vol_data[0] = bitstream;\n                vol_size = inHeader->nFilledLen;\n }\n\n            MP4DecodingMode mode =\n (mMode == MODE_MPEG4) ? MPEG4_MODE : H263_MODE;\n\n Bool success = PVInitVideoDecoder(\n                    mHandle, vol_data, &vol_size, 1,\n                    outputBufferWidth(), outputBufferHeight(), mode);\n\n if (!success) {\n                ALOGW(\"PVInitVideoDecoder failed. Unsupported content?\");\n\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                mSignalledError = true;\n return;\n }\n\n            MP4DecodingMode actualMode = PVGetDecBitstreamMode(mHandle);\n if (mode != actualMode) {\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                mSignalledError = true;\n return;\n }\n\n PVSetPostProcType((VideoDecControls *) mHandle, 0);\n\n bool hasFrameData = false;\n if (inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) {\n                inInfo->mOwnedByUs = false;\n                inQueue.erase(inQueue.begin());\n                inInfo = NULL;\n                notifyEmptyBufferDone(inHeader);\n                inHeader = NULL;\n } else if (volHeader) {\n                hasFrameData = true;\n }\n\n            mInitialized = true;\n\n if (mode == MPEG4_MODE && handlePortSettingsChange()) {\n return;\n }\n\n if (!hasFrameData) {\n continue;\n }\n }\n\n if (!mFramesConfigured) {\n PortInfo *port = editPortInfo(1);\n            OMX_BUFFERHEADERTYPE *outHeader = port->mBuffers.editItemAt(1).mHeader;\n\n\n             OMX_U32 yFrameSize = sizeof(uint8) * mHandle->size;\n             if ((outHeader->nAllocLen < yFrameSize) ||\n                     (outHeader->nAllocLen - yFrameSize < yFrameSize / 2)) {\n                ALOGE(\"Too small output buffer for reference frame: %zu bytes\",\n                        outHeader->nAllocLen);\n                 android_errorWriteLog(0x534e4554, \"30033990\");\n                 notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                 mSignalledError = true;\n return;\n }\n PVSetReferenceYUV(mHandle, outHeader->pBuffer);\n            mFramesConfigured = true;\n }\n\n uint32_t useExtTimestamp = (inHeader->nOffset == 0);\n\n uint32_t timestamp = 0xFFFFFFFF;\n if (useExtTimestamp) {\n            mPvToOmxTimeMap.add(mPvTime, inHeader->nTimeStamp);\n            timestamp = mPvTime;\n            mPvTime++;\n }\n\n int32_t bufferSize = inHeader->nFilledLen;\n int32_t tmp = bufferSize;\n\n        OMX_U32 frameSize;\n        OMX_U64 yFrameSize = (OMX_U64)mWidth * (OMX_U64)mHeight;\n if (yFrameSize > ((OMX_U64)UINT32_MAX / 3) * 2) {\n            ALOGE(\"Frame size too large\");\n            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n            mSignalledError = true;\n return;\n }\n        frameSize = (OMX_U32)(yFrameSize + (yFrameSize / 2));\n\n if (outHeader->nAllocLen < frameSize) {\n            android_errorWriteLog(0x534e4554, \"27833616\");\n            ALOGE(\"Insufficient output buffer size\");\n            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n            mSignalledError = true;\n return;\n }\n if (PVDecodeVideoFrame(\n                    mHandle, &bitstream, &timestamp, &tmp,\n &useExtTimestamp,\n                    outHeader->pBuffer) != PV_TRUE) {\n            ALOGE(\"failed to decode video frame.\");\n\n            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n            mSignalledError = true;\n return;\n }\n\n if (handlePortSettingsChange()) {\n return;\n }\n\n        outHeader->nTimeStamp = mPvToOmxTimeMap.valueFor(timestamp);\n        mPvToOmxTimeMap.removeItem(timestamp);\n\n        inHeader->nOffset += bufferSize;\n        inHeader->nFilledLen = 0;\n if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {\n            outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n } else {\n            outHeader->nFlags = 0;\n }\n\n if (inHeader->nFilledLen == 0) {\n            inInfo->mOwnedByUs = false;\n            inQueue.erase(inQueue.begin());\n            inInfo = NULL;\n            notifyEmptyBufferDone(inHeader);\n            inHeader = NULL;\n }\n\n ++mInputBufferCount;\n\n        outHeader->nOffset = 0;\n        outHeader->nFilledLen = frameSize;\n\n List<BufferInfo *>::iterator it = outQueue.begin();\n while ((*it)->mHeader != outHeader) {\n ++it;\n }\n\n BufferInfo *outInfo = *it;\n        outInfo->mOwnedByUs = false;\n        outQueue.erase(it);\n        outInfo = NULL;\n\n        notifyFillBufferDone(outHeader);\n        outHeader = NULL;\n\n ++mNumSamplesOutput;\n }\n}\n", "target": 1, "idx": 188170}
{"func": "void RendererSchedulerImpl::OnShutdownTaskQueue(\n    const scoped_refptr<MainThreadTaskQueue>& task_queue) {\n  if (main_thread_only().was_shutdown)\n    return;\n\n  if (task_queue_throttler_)\n    task_queue_throttler_->ShutdownTaskQueue(task_queue.get());\n\n  if (task_runners_.erase(task_queue)) {\n    switch (task_queue->queue_class()) {\n       case MainThreadTaskQueue::QueueClass::kTimer:\n         task_queue->RemoveTaskObserver(\n             &main_thread_only().timer_task_cost_estimator);\n       case MainThreadTaskQueue::QueueClass::kLoading:\n         task_queue->RemoveTaskObserver(\n             &main_thread_only().loading_task_cost_estimator);\n       default:\n         break;\n     }\n  }\n}\n", "target": 1, "idx": 186579}
{"func": "int utf8s_to_utf16s(const u8 *s, int len, wchar_t *pwcs)\n {\n \tu16 *op;\n \tint size;\n \tunicode_t u;\n \n \top = pwcs;\n\twhile (*s && len > 0) {\n \t\tif (*s & 0x80) {\n \t\t\tsize = utf8_to_utf32(s, len, &u);\n \t\t\tif (size < 0)\n \t\t\t\treturn -EINVAL;\n \n \t\t\tif (u >= PLANE_SIZE) {\n \t\t\t\tu -= PLANE_SIZE;\n\t\t\t\t*op++ = (wchar_t) (SURROGATE_PAIR |\n\t\t\t\t\t\t((u >> 10) & SURROGATE_BITS));\n\t\t\t\t*op++ = (wchar_t) (SURROGATE_PAIR |\n \t\t\t\t\t\tSURROGATE_LOW |\n\t\t\t\t\t\t(u & SURROGATE_BITS));\n \t\t\t} else {\n\t\t\t\t*op++ = (wchar_t) u;\n \t\t\t}\n\t\t\ts += size;\n\t\t\tlen -= size;\n \t\t} else {\n\t\t\t*op++ = *s++;\n \t\t\tlen--;\n \t\t}\n \t}\n \treturn op - pwcs;\n}\n", "target": 1, "idx": 179297}
{"func": "image_PaintProc(const gs_client_color * pcolor, gs_gstate * pgs)\n{\n    const pixmap_info *ppmap = gs_getpattern(pcolor)->client_data;\n    const gs_depth_bitmap *pbitmap = &(ppmap->bitmap);\n    gs_image_enum *pen =\n        gs_image_enum_alloc(gs_gstate_memory(pgs), \"image_PaintProc\");\n    gs_color_space *pcspace;\n    gx_image_enum_common_t *pie;\n    /*\n     * If the image is transparent then we want to do image type4 processing.\n     * Otherwise we want to use image type 1 processing.\n     */\n    int transparent = ppmap->white_index < (1 << (pbitmap->num_comps * pbitmap->pix_depth));\n\n    /*\n     * Note: gs_image1_t and gs_image4_t sre nearly identical structure\n     * definitions.  From our point of view, the only significant difference\n     * is MaskColor in gs_image4_t.  The fields are generally loaded using\n     * the gs_image1_t version of the union and then used for either type\n     * of image processing.\n     */\n    union {\n        gs_image1_t i1;\n        gs_image4_t i4;\n    } image;\n    int code;\n\n    if (pen == 0)\n        return_error(gs_error_VMerror);\n\n    if (ppmap->pcspace == 0) {\n        pcspace = gs_cspace_new_DeviceGray(pgs->memory);\n        if (pcspace == NULL)\n            return_error(gs_error_VMerror);\n    } else\n        pcspace = ppmap->pcspace;\n    code = gs_gsave(pgs);\n    if (code < 0)\n        goto fail;\n    code = gs_setcolorspace(pgs, pcspace);\n    if (code < 0)\n        return code;\n    if (transparent)\n        gs_image4_t_init( (gs_image4_t *) &image, pcspace);\n    else\n        gs_image_t_init_adjust( (gs_image_t *) &image, pcspace, 0);\n    image.i1.Width = pbitmap->size.x;\n    image.i1.Height = pbitmap->size.y;\n    if (transparent) {\n        image.i4.MaskColor_is_range = false;\n        image.i4.MaskColor[0] = ppmap->white_index;\n    }\n    image.i1.Decode[0] = 0.0;\n    image.i1.Decode[1] = (float)((1 << pbitmap->pix_depth) - 1);\n    image.i1.BitsPerComponent = pbitmap->pix_depth;\n    /* backwards compatibility */\n    if (ppmap->pcspace == 0) {\n        image.i1.Decode[0] = 1.0;\n        image.i1.Decode[1] = 0.0;\n    }\n\n    if ( (code = gs_image_begin_typed( (const gs_image_common_t *)&image,\n                                       pgs,\n                                       false,\n                                       false,\n                                       &pie )) >= 0 &&\n         (code = gs_image_enum_init( pen,\n                                     pie,\n                                     (gs_data_image_t *)&image,\n                                     pgs )) >= 0 &&\n        (code = bitmap_paint(pen, (gs_data_image_t *) & image, pbitmap, pgs)) >= 0) {\n        return gs_grestore(pgs);\n    }\n\nfail:\n    gs_free_object(gs_gstate_memory(pgs), pen, \"image_PaintProc\");\n    return code;\n}\n", "target": 0, "idx": 1695}
{"func": "InvalidationSet* RuleFeatureSet::invalidationSetForSelector(const CSSSelector& selector, InvalidationType type)\n{\n    if (selector.match() == CSSSelector::Class)\n        return &ensureClassInvalidationSet(selector.value(), type);\n    if (selector.isAttributeSelector())\n        return &ensureAttributeInvalidationSet(selector.attribute().localName(), type);\n    if (selector.match() == CSSSelector::Id)\n        return &ensureIdInvalidationSet(selector.value(), type);\n    if (selector.match() == CSSSelector::PseudoClass) {\n        switch (selector.pseudoType()) {\n        case CSSSelector::PseudoEmpty:\n        case CSSSelector::PseudoLink:\n        case CSSSelector::PseudoVisited:\n        case CSSSelector::PseudoAnyLink:\n        case CSSSelector::PseudoAutofill:\n        case CSSSelector::PseudoHover:\n        case CSSSelector::PseudoFocus:\n        case CSSSelector::PseudoActive:\n        case CSSSelector::PseudoChecked:\n        case CSSSelector::PseudoEnabled:\n        case CSSSelector::PseudoDisabled:\n         case CSSSelector::PseudoOptional:\n         case CSSSelector::PseudoPlaceholderShown:\n         case CSSSelector::PseudoRequired:\n         case CSSSelector::PseudoValid:\n         case CSSSelector::PseudoInvalid:\n         case CSSSelector::PseudoIndeterminate:\n        case CSSSelector::PseudoTarget:\n            return &ensurePseudoInvalidationSet(selector.pseudoType(), type);\n        default:\n            break;\n        }\n    }\n    return nullptr;\n}\n", "target": 1, "idx": 185449}
{"func": "void WebGL2RenderingContextBase::texSubImage3D(\n    ExecutionContext* execution_context,\n    GLenum target,\n    GLint level,\n    GLint xoffset,\n    GLint yoffset,\n    GLint zoffset,\n    GLsizei width,\n    GLsizei height,\n    GLsizei depth,\n    GLenum format,\n    GLenum type,\n    HTMLVideoElement* video,\n    ExceptionState& exception_state) {\n  if (isContextLost())\n    return;\n  if (bound_pixel_unpack_buffer_) {\n    SynthesizeGLError(GL_INVALID_OPERATION, \"texSubImage3D\",\n                      \"a buffer is bound to PIXEL_UNPACK_BUFFER\");\n    return;\n  }\n\n  TexImageHelperHTMLVideoElement(execution_context->GetSecurityOrigin(),\n                                 kTexSubImage3D, target, level, 0, format, type,\n                                 xoffset, yoffset, zoffset, video,\n                                 GetTextureSourceSubRectangle(width, height),\n                                 depth, unpack_image_height_, exception_state);\n}\n", "target": 0, "idx": 146166}
{"func": "BarProp* LocalDOMWindow::menubar() const {\n  if (!menubar_)\n    menubar_ = BarProp::Create(GetFrame(), BarProp::kMenubar);\n  return menubar_.Get();\n}\n", "target": 0, "idx": 136813}
{"func": "void V8TestObject::MeasuredLongAttributeAttributeSetterCallback(\n    const v8::FunctionCallbackInfo<v8::Value>& info) {\n  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), \"Blink_TestObject_measuredLongAttribute_Setter\");\n\n  v8::Local<v8::Value> v8_value = info[0];\n\n  UseCounter::Count(CurrentExecutionContext(info.GetIsolate()), WebFeature::kV8TestObject_MeasuredLongAttribute_AttributeSetter);\n\n  test_object_v8_internal::MeasuredLongAttributeAttributeSetter(v8_value, info);\n}\n", "target": 0, "idx": 147556}
{"func": "bool RenderFrameHostImpl::CreateRenderFrame(int previous_routing_id,\n                                            int opener_routing_id,\n                                            int parent_routing_id,\n                                            int previous_sibling_routing_id) {\n  TRACE_EVENT0(\"navigation\", \"RenderFrameHostImpl::CreateRenderFrame\");\n  DCHECK(!IsRenderFrameLive()) << \"Creating frame twice\";\n\n  if (!GetProcess()->Init())\n    return false;\n\n  DCHECK(GetProcess()->IsInitializedAndNotDead());\n\n  service_manager::mojom::InterfaceProviderPtr interface_provider;\n  BindInterfaceProviderRequest(mojo::MakeRequest(&interface_provider));\n\n  blink::mojom::DocumentInterfaceBrokerPtrInfo\n      document_interface_broker_content_info;\n  blink::mojom::DocumentInterfaceBrokerPtrInfo\n      document_interface_broker_blink_info;\n  BindDocumentInterfaceBrokerRequest(\n      mojo::MakeRequest(&document_interface_broker_content_info),\n      mojo::MakeRequest(&document_interface_broker_blink_info));\n\n  mojom::CreateFrameParamsPtr params = mojom::CreateFrameParams::New();\n  params->interface_bundle = mojom::DocumentScopedInterfaceBundle::New(\n      interface_provider.PassInterface(),\n      std::move(document_interface_broker_content_info),\n      std::move(document_interface_broker_blink_info));\n\n  params->routing_id = routing_id_;\n  params->previous_routing_id = previous_routing_id;\n  params->opener_routing_id = opener_routing_id;\n  params->parent_routing_id = parent_routing_id;\n  params->previous_sibling_routing_id = previous_sibling_routing_id;\n  params->replication_state = frame_tree_node()->current_replication_state();\n  params->devtools_frame_token = frame_tree_node()->devtools_frame_token();\n\n  params->replication_state.frame_policy =\n      frame_tree_node()->pending_frame_policy();\n\n  params->frame_owner_properties =\n      FrameOwnerProperties(frame_tree_node()->frame_owner_properties());\n\n  params->has_committed_real_load =\n      frame_tree_node()->has_committed_real_load();\n\n  params->widget_params = mojom::CreateFrameWidgetParams::New();\n  if (render_widget_host_) {\n    params->widget_params->routing_id = render_widget_host_->GetRoutingID();\n    params->widget_params->hidden = render_widget_host_->is_hidden();\n  } else {\n    params->widget_params->routing_id = MSG_ROUTING_NONE;\n    params->widget_params->hidden = true;\n  }\n\n  GetProcess()->GetRendererInterface()->CreateFrame(std::move(params));\n\n  if (parent_routing_id != MSG_ROUTING_NONE && render_widget_host_) {\n    RenderWidgetHostView* rwhv =\n        RenderWidgetHostViewChildFrame::Create(render_widget_host_);\n    rwhv->Hide();\n  }\n\n  if (previous_routing_id != MSG_ROUTING_NONE) {\n    RenderFrameProxyHost* proxy = RenderFrameProxyHost::FromID(\n        GetProcess()->GetID(), previous_routing_id);\n    proxy->set_render_frame_proxy_created(true);\n  }\n\n  SetRenderFrameCreated(true);\n\n  return true;\n}\n", "target": 0, "idx": 151912}
{"func": "void GamepadProvider::ResetVibrationActuator(\n    int pad_index,\n    mojom::GamepadHapticsManager::ResetVibrationActuatorCallback callback) {\n  PadState* pad_state = GetConnectedPadState(pad_index);\n  if (!pad_state) {\n    std::move(callback).Run(\n        mojom::GamepadHapticsResult::GamepadHapticsResultError);\n    return;\n  }\n\n  GamepadDataFetcher* fetcher = GetSourceGamepadDataFetcher(pad_state->source);\n  if (!fetcher) {\n    std::move(callback).Run(\n        mojom::GamepadHapticsResult::GamepadHapticsResultNotSupported);\n    return;\n  }\n\n  fetcher->ResetVibration(pad_state->source_id, std::move(callback));\n}\n", "target": 0, "idx": 162239}
{"func": "IDAT_list_extend(struct IDAT_list *tail)\n{\n /* Use the previous cached value if available. */\n struct IDAT_list *next = tail->next;\n\n if (next == NULL)\n {\n /* Insert a new, malloc'ed, block of IDAT information buffers, this\n       * one twice as large as the previous one:\n       */\n unsigned int length = 2 * tail->length;\n\n \n       if (length < tail->length) /* arithmetic overflow */\n          length = tail->length;\n      next = png_voidcast(IDAT_list*, malloc(IDAT_list_size(NULL, length)));\n       CLEAR(*next);\n \n       /* The caller must handle this: */\n if (next == NULL)\n return NULL;\n\n      next->next = NULL;\n      next->length = length;\n      tail->next = next;\n }\n\n return next;\n}\n", "target": 1, "idx": 187750}
{"func": "image_transform_png_set_strip_16_set(PNG_CONST image_transform *this,\n     transform_display *that, png_structp pp, png_infop pi)\n {\n    png_set_strip_16(pp);\n    this->next->set(this->next, that, pp, pi);\n }\n", "target": 1, "idx": 187672}
{"func": "static int tcp4_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct tcp_iter_state *st;\n\tstruct sock *sk = v;\n\n\tseq_setwidth(seq, TMPSZ - 1);\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(seq, \"  sl  local_address rem_address   st tx_queue \"\n\t\t\t   \"rx_queue tr tm->when retrnsmt   uid  timeout \"\n\t\t\t   \"inode\");\n\t\tgoto out;\n\t}\n\tst = seq->private;\n\n\tif (sk->sk_state == TCP_TIME_WAIT)\n\t\tget_timewait4_sock(v, seq, st->num);\n\telse if (sk->sk_state == TCP_NEW_SYN_RECV)\n\t\tget_openreq4(v, seq, st->num);\n\telse\n\t\tget_tcp4_sock(v, seq, st->num);\nout:\n\tseq_pad(seq, '\\n');\n\treturn 0;\n}\n", "target": 0, "idx": 49239}
{"func": "const char *SSL_rstate_string(const SSL *s)\n{\n    switch (s->rlayer.rstate) {\n    case SSL_ST_READ_HEADER:\n        return \"RH\";\n    case SSL_ST_READ_BODY:\n        return \"RB\";\n    case SSL_ST_READ_DONE:\n        return \"RD\";\n    default:\n        return \"unknown\";\n    }\n}\n", "target": 0, "idx": 13919}
{"func": "void impeg2d_flush_ext_and_user_data(dec_state_t *ps_dec)\n{\n    UWORD32 u4_start_code;\n stream_t *ps_stream;\n\n\n     ps_stream    = &ps_dec->s_bit_stream;\n     u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n \n    while(u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE)\n     {\n         impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)\n         {\n             impeg2d_bit_stream_flush(ps_stream,8);\n         }\n        u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n }\n}\n", "target": 1, "idx": 187971}
{"func": " bool Browser::ShouldFocusLocationBarByDefault(WebContents* source) {\n   const content::NavigationEntry* entry =\n       source->GetController().GetActiveEntry();\n   if (entry) {\n    const GURL& url = entry->GetURL();\n    const GURL& virtual_url = entry->GetVirtualURL();\n    if ((url.SchemeIs(content::kChromeUIScheme) &&\n         url.host_piece() == chrome::kChromeUINewTabHost) ||\n        (virtual_url.SchemeIs(content::kChromeUIScheme) &&\n         virtual_url.host_piece() == chrome::kChromeUINewTabHost)) {\n      return true;\n    }\n  }\n\n  return search::NavEntryIsInstantNTP(source, entry);\n}\n", "target": 1, "idx": 186449}
{"func": "\tvoid testUriComponents_Bug20070701() {\n\t\tUriParserStateA stateA;\n\t\tUriUriA uriA;\n\t\tstateA.uri = &uriA;\n\t\tconst char * const input = \"a\" \":\" \"b\";\n\t\tTEST_ASSERT(0 == uriParseUriA(&stateA, input));\n\n\t\tTEST_ASSERT(uriA.scheme.first == input);\n\t\tTEST_ASSERT(uriA.scheme.afterLast == input + 1);\n\t\tTEST_ASSERT(uriA.userInfo.first == NULL);\n\t\tTEST_ASSERT(uriA.userInfo.afterLast == NULL);\n\t\tTEST_ASSERT(uriA.hostText.first == NULL);\n\t\tTEST_ASSERT(uriA.hostText.afterLast == NULL);\n\t\tTEST_ASSERT(uriA.hostData.ipFuture.first == NULL);\n\t\tTEST_ASSERT(uriA.hostData.ipFuture.afterLast == NULL);\n\t\tTEST_ASSERT(uriA.portText.first == NULL);\n\t\tTEST_ASSERT(uriA.portText.afterLast == NULL);\n\n\t\tTEST_ASSERT(uriA.pathHead->text.first == input + 1 + 1);\n\t\tTEST_ASSERT(uriA.pathHead->text.afterLast == input + 1 + 1 + 1);\n\t\tTEST_ASSERT(uriA.pathHead->next == NULL);\n\t\tTEST_ASSERT(uriA.pathTail == uriA.pathHead);\n\n\t\tTEST_ASSERT(uriA.query.first == NULL);\n\t\tTEST_ASSERT(uriA.query.afterLast == NULL);\n\t\tTEST_ASSERT(uriA.fragment.first == NULL);\n\t\tTEST_ASSERT(uriA.fragment.afterLast == NULL);\n\n\t\tTEST_ASSERT(!uriA.absolutePath);\n\t\turiFreeUriMembersA(&uriA);\n\t}\n", "target": 0, "idx": 75767}
{"func": "void WebProcessProxy::disconnectFramesFromPage(WebPageProxy* page)\n{\n    Vector<RefPtr<WebFrameProxy> > frames;\n    copyValuesToVector(m_frameMap, frames);\n    for (size_t i = 0, size = frames.size(); i < size; ++i) {\n        if (frames[i]->page() == page)\n            frames[i]->disconnect();\n    }\n}\n", "target": 0, "idx": 113393}
{"func": "void PasswordAutofillAgent::PasswordValueGatekeeper::RegisterElement(\n    blink::WebInputElement* element) {\n  if (was_user_gesture_seen_)\n    ShowValue(element);\n  else\n    elements_.push_back(*element);\n}\n", "target": 0, "idx": 170162}
{"func": "static VncClientInfo *qmp_query_vnc_client(const VncState *client)\n{\n    struct sockaddr_storage sa;\n    socklen_t salen = sizeof(sa);\n    char host[NI_MAXHOST];\n    char serv[NI_MAXSERV];\n    VncClientInfo *info;\n\n    if (getpeername(client->csock, (struct sockaddr *)&sa, &salen) < 0) {\n        return NULL;\n    }\n\n    if (getnameinfo((struct sockaddr *)&sa, salen,\n                    host, sizeof(host),\n                    serv, sizeof(serv),\n                    NI_NUMERICHOST | NI_NUMERICSERV) < 0) {\n        return NULL;\n    }\n\n    info = g_malloc0(sizeof(*info));\n    info->base = g_malloc0(sizeof(*info->base));\n    info->base->host = g_strdup(host);\n    info->base->service = g_strdup(serv);\n    info->base->family = inet_netfamily(sa.ss_family);\n\n#ifdef CONFIG_VNC_TLS\n    if (client->tls.session && client->tls.dname) {\n        info->has_x509_dname = true;\n        info->x509_dname = g_strdup(client->tls.dname);\n    }\n#endif\n#ifdef CONFIG_VNC_SASL\n    if (client->sasl.conn && client->sasl.username) {\n        info->has_sasl_username = true;\n        info->sasl_username = g_strdup(client->sasl.username);\n    }\n#endif\n\n    return info;\n}\n", "target": 0, "idx": 7977}
{"func": "bool GLES2DecoderImpl::MakeCurrent() {\n  return context_.get() ? context_->MakeCurrent() : false;\n}\n", "target": 0, "idx": 108136}
{"func": "void InspectorPageAgent::handleJavaScriptDialog(ErrorString* errorString, bool accept, const String* promptText)\n{\n}\n", "target": 0, "idx": 109305}
{"func": "server_send_real (server *serv, char *buf, int len)\n{\n\tfe_add_rawlog (serv, buf, len, TRUE);\n\n\turl_check_line (buf, len);\n\n\treturn tcp_send_real (serv->ssl, serv->sok, serv->encoding, serv->using_irc,\n\t\t\t\t\t\t\t\t buf, len);\n}\n", "target": 0, "idx": 58457}
{"func": "png_get_rgb_to_gray_status (png_structp png_ptr)\n{\n   return (png_byte)(png_ptr? png_ptr->rgb_to_gray_status : 0);\n}\n", "target": 0, "idx": 143973}
{"func": "my_object_do_nothing (MyObject *obj, GError **error)\n{\n  return TRUE;\n}\n", "target": 1, "idx": 178264}
{"func": " void uwbd_stop(struct uwb_rc *rc)\n {\n\tkthread_stop(rc->uwbd.task);\n \tuwbd_flush(rc);\n }\n", "target": 1, "idx": 180858}
{"func": "PP_Flash_Menu* ReadMenu(int depth,\n                        const IPC::Message* m,\n                        PickleIterator* iter) {\n  if (depth > kMaxMenuDepth)\n    return NULL;\n  ++depth;\n\n  PP_Flash_Menu* menu = new PP_Flash_Menu;\n  menu->items = NULL;\n\n  if (!m->ReadUInt32(iter, &menu->count)) {\n    FreeMenu(menu);\n    return NULL;\n  }\n\n   if (menu->count == 0)\n     return menu;\n \n   menu->items = new PP_Flash_MenuItem[menu->count];\n   memset(menu->items, 0, sizeof(PP_Flash_MenuItem) * menu->count);\n   for (uint32_t i = 0; i < menu->count; ++i) {\n    if (!ReadMenuItem(depth, m, iter, menu->items + i)) {\n      FreeMenu(menu);\n      return NULL;\n    }\n  }\n  return menu;\n}\n", "target": 1, "idx": 185099}
{"func": "bool WebPagePrivate::zoomAboutPoint(double unclampedScale, const FloatPoint& anchor, bool enforceScaleClamping, bool forceRendering, bool isRestoringZoomLevel)\n{\n    if (!isRestoringZoomLevel) {\n        resetBlockZoom();\n    }\n\n#if ENABLE(VIEWPORT_REFLOW)\n    toggleTextReflowIfEnabledForBlockZoomOnly(m_shouldReflowBlock);\n    if (m_page->settings()->isTextReflowEnabled() && m_mainFrame->view())\n        setNeedsLayout();\n#endif\n\n    double scale;\n    if (!shouldZoomAboutPoint(unclampedScale, anchor, enforceScaleClamping, &scale)) {\n        if (m_webPage->settings()->textReflowMode() == WebSettings::TextReflowEnabled) {\n            m_currentPinchZoomNode = 0;\n            m_anchorInNodeRectRatio = FloatPoint(-1, -1);\n        }\n        return false;\n    }\n    TransformationMatrix zoom;\n    zoom.scale(scale);\n\n#if DEBUG_WEBPAGE_LOAD\n    if (loadState() < Finished)\n        BBLOG(Platform::LogLevelInfo, \"WebPagePrivate::zoomAboutPoint scale %f anchor (%f, %f)\", scale, anchor.x(), anchor.y());\n#endif\n\n    FloatPoint scrollPosition = this->scrollPosition();\n\n    FloatPoint anchorOffset(anchor.x() - scrollPosition.x(), anchor.y() - scrollPosition.y());\n\n    ASSERT(m_transformationMatrix->m11() == m_transformationMatrix->m22());\n\n    double inverseScale = scale / m_transformationMatrix->m11();\n\n    *m_transformationMatrix = zoom;\n\n    m_backingStore->d->suspendBackingStoreUpdates();\n    m_backingStore->d->suspendScreenUpdates();\n\n    updateViewportSize();\n\n    IntPoint newScrollPosition(IntPoint(max(0, static_cast<int>(roundf(anchor.x() - anchorOffset.x() / inverseScale))),\n                                        max(0, static_cast<int>(roundf(anchor.y() - anchorOffset.y() / inverseScale)))));\n\n    if (m_webPage->settings()->textReflowMode() == WebSettings::TextReflowEnabled) {\n        m_mainFrame->view()->setNeedsLayout();\n        requestLayoutIfNeeded();\n        if (m_currentPinchZoomNode)\n            newScrollPosition = calculateReflowedScrollPosition(anchorOffset, scale == minimumScale() ? 1 : inverseScale);\n         m_currentPinchZoomNode = 0;\n         m_anchorInNodeRectRatio = FloatPoint(-1, -1);\n    }\n\n    setScrollPosition(newScrollPosition);\n\n    notifyTransformChanged();\n\n    bool isLoading = this->isLoading();\n\n    m_backingStore->d->updateTiles(isLoading /* updateVisible */, false /* immediate */);\n\n    bool shouldRender = !isLoading || m_userPerformedManualZoom || forceRendering;\n    bool shouldClearVisibleZoom = isLoading && shouldRender;\n\n    if (shouldClearVisibleZoom) {\n        m_backingStore->d->clearVisibleZoom();\n    }\n\n    m_client->scaleChanged();\n\n    if (m_pendingOrientation != -1)\n        m_client->updateInteractionViews();\n\n    m_backingStore->d->resumeBackingStoreUpdates();\n\n    if (shouldRender) {\n        m_backingStore->d->resumeScreenUpdates(BackingStore::RenderAndBlit);\n    } else {\n        m_backingStore->d->resumeScreenUpdates(BackingStore::None);\n    }\n\n    return true;\n}\n", "target": 0, "idx": 111430}
{"func": "Page* ChromeClientImpl::CreateWindow(LocalFrame* frame,\n                                     const FrameLoadRequest& r,\n                                     const WebWindowFeatures& features,\n                                     NavigationPolicy navigation_policy,\n                                     SandboxFlags sandbox_flags) {\n  if (!web_view_->Client())\n    return nullptr;\n \n   if (!frame->GetPage() || frame->GetPage()->Paused())\n     return nullptr;\n  DCHECK(frame->GetDocument());\n  Fullscreen::FullyExitFullscreen(*frame->GetDocument());\n \n   const AtomicString& frame_name =\n       !EqualIgnoringASCIICase(r.FrameName(), \"_blank\") ? r.FrameName()\n                                                       : g_empty_atom;\n  WebViewImpl* new_view =\n      static_cast<WebViewImpl*>(web_view_->Client()->CreateView(\n          WebLocalFrameImpl::FromFrame(frame),\n          WrappedResourceRequest(r.GetResourceRequest()), features, frame_name,\n          static_cast<WebNavigationPolicy>(navigation_policy),\n          r.GetShouldSetOpener() == kNeverSetOpener,\n          static_cast<WebSandboxFlags>(sandbox_flags)));\n  if (!new_view)\n    return nullptr;\n  return new_view->GetPage();\n}\n", "target": 1, "idx": 186929}
{"func": "static void phar_copy_cached_phar(phar_archive_data **pphar TSRMLS_DC) /* {{{ */\n{\n\tphar_archive_data *phar;\n\tHashTable newmanifest;\n\tchar *fname;\n\tphar_archive_object **objphar;\n\n\tphar = (phar_archive_data *) emalloc(sizeof(phar_archive_data));\n\t*phar = **pphar;\n\tphar->is_persistent = 0;\n\tfname = phar->fname;\n\tphar->fname = estrndup(phar->fname, phar->fname_len);\n\tphar->ext = phar->fname + (phar->ext - fname);\n\n\tif (phar->alias) {\n\t\tphar->alias = estrndup(phar->alias, phar->alias_len);\n\t}\n\n\tif (phar->signature) {\n\t\tphar->signature = estrdup(phar->signature);\n\t}\n\n\tif (phar->metadata) {\n\t\t/* assume success, we would have failed before */\n\t\tif (phar->metadata_len) {\n\t\t\tchar *buf = estrndup((char *) phar->metadata, phar->metadata_len);\n\t\t\tphar_parse_metadata(&buf, &phar->metadata, phar->metadata_len TSRMLS_CC);\n\t\t\tefree(buf);\n\t\t} else {\n\t\t\tzval *t;\n\n\t\t\tt = phar->metadata;\n\t\t\tALLOC_ZVAL(phar->metadata);\n\t\t\t*phar->metadata = *t;\n\t\t\tzval_copy_ctor(phar->metadata);\n\t\t\tZ_SET_REFCOUNT_P(phar->metadata, 1);\n\t\t}\n\t}\n\n\tzend_hash_init(&newmanifest, sizeof(phar_entry_info),\n\t\tzend_get_hash_value, destroy_phar_manifest_entry, 0);\n\tzend_hash_copy(&newmanifest, &(*pphar)->manifest, NULL, NULL, sizeof(phar_entry_info));\n\tzend_hash_apply_with_argument(&newmanifest, (apply_func_arg_t) phar_update_cached_entry, (void *)phar TSRMLS_CC);\n\tphar->manifest = newmanifest;\n\tzend_hash_init(&phar->mounted_dirs, sizeof(char *),\n\t\tzend_get_hash_value, NULL, 0);\n\tzend_hash_init(&phar->virtual_dirs, sizeof(char *),\n\t\tzend_get_hash_value, NULL, 0);\n\tzend_hash_copy(&phar->virtual_dirs, &(*pphar)->virtual_dirs, NULL, NULL, sizeof(void *));\n\t*pphar = phar;\n\n\t/* now, scan the list of persistent Phar objects referencing this phar and update the pointers */\n\tfor (zend_hash_internal_pointer_reset(&PHAR_GLOBALS->phar_persist_map);\n\tSUCCESS == zend_hash_get_current_data(&PHAR_GLOBALS->phar_persist_map, (void **) &objphar);\n\tzend_hash_move_forward(&PHAR_GLOBALS->phar_persist_map)) {\n\t\tif (objphar[0]->arc.archive->fname_len == phar->fname_len && !memcmp(objphar[0]->arc.archive->fname, phar->fname, phar->fname_len)) {\n\t\t\tobjphar[0]->arc.archive = phar;\n\t\t}\n\t}\n}\n/* }}} */\n", "target": 0, "idx": 186}
{"func": "void RenderViewHostImpl::CreateNewWindow(\n    int route_id,\n    const ViewHostMsg_CreateWindow_Params& params,\n    SessionStorageNamespace* session_storage_namespace) {\n   ViewHostMsg_CreateWindow_Params validated_params(params);\n   ChildProcessSecurityPolicyImpl* policy =\n       ChildProcessSecurityPolicyImpl::GetInstance();\n \n   delegate_->CreateNewWindow(route_id, validated_params,\n                              session_storage_namespace);\n}\n", "target": 1, "idx": 185201}
{"func": "int perf_pmu_register(struct pmu *pmu, const char *name, int type)\n{\n\tint cpu, ret;\n\n\tmutex_lock(&pmus_lock);\n\tret = -ENOMEM;\n\tpmu->pmu_disable_count = alloc_percpu(int);\n\tif (!pmu->pmu_disable_count)\n\t\tgoto unlock;\n\n\tpmu->type = -1;\n\tif (!name)\n\t\tgoto skip_type;\n\tpmu->name = name;\n\n\tif (type < 0) {\n\t\ttype = idr_alloc(&pmu_idr, pmu, PERF_TYPE_MAX, 0, GFP_KERNEL);\n\t\tif (type < 0) {\n\t\t\tret = type;\n\t\t\tgoto free_pdc;\n\t\t}\n\t}\n\tpmu->type = type;\n\n\tif (pmu_bus_running) {\n\t\tret = pmu_dev_alloc(pmu);\n\t\tif (ret)\n\t\t\tgoto free_idr;\n\t}\n\nskip_type:\n\tpmu->pmu_cpu_context = find_pmu_context(pmu->task_ctx_nr);\n\tif (pmu->pmu_cpu_context)\n\t\tgoto got_cpu_context;\n\n\tret = -ENOMEM;\n\tpmu->pmu_cpu_context = alloc_percpu(struct perf_cpu_context);\n\tif (!pmu->pmu_cpu_context)\n\t\tgoto free_dev;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct perf_cpu_context *cpuctx;\n\n\t\tcpuctx = per_cpu_ptr(pmu->pmu_cpu_context, cpu);\n \t\t__perf_event_init_context(&cpuctx->ctx);\n \t\tlockdep_set_class(&cpuctx->ctx.mutex, &cpuctx_mutex);\n \t\tlockdep_set_class(&cpuctx->ctx.lock, &cpuctx_lock);\n\t\tcpuctx->ctx.type = cpu_context;\n \t\tcpuctx->ctx.pmu = pmu;\n \n \t\t__perf_cpu_hrtimer_init(cpuctx, cpu);\n\n\t\tINIT_LIST_HEAD(&cpuctx->rotation_list);\n\t\tcpuctx->unique_pmu = pmu;\n\t}\n\ngot_cpu_context:\n\tif (!pmu->start_txn) {\n\t\tif (pmu->pmu_enable) {\n\t\t\t/*\n\t\t\t * If we have pmu_enable/pmu_disable calls, install\n\t\t\t * transaction stubs that use that to try and batch\n\t\t\t * hardware accesses.\n\t\t\t */\n\t\t\tpmu->start_txn  = perf_pmu_start_txn;\n\t\t\tpmu->commit_txn = perf_pmu_commit_txn;\n\t\t\tpmu->cancel_txn = perf_pmu_cancel_txn;\n\t\t} else {\n\t\t\tpmu->start_txn  = perf_pmu_nop_void;\n\t\t\tpmu->commit_txn = perf_pmu_nop_int;\n\t\t\tpmu->cancel_txn = perf_pmu_nop_void;\n\t\t}\n\t}\n\n\tif (!pmu->pmu_enable) {\n\t\tpmu->pmu_enable  = perf_pmu_nop_void;\n\t\tpmu->pmu_disable = perf_pmu_nop_void;\n\t}\n\n\tif (!pmu->event_idx)\n\t\tpmu->event_idx = perf_event_idx_default;\n\n\tlist_add_rcu(&pmu->entry, &pmus);\n\tret = 0;\nunlock:\n\tmutex_unlock(&pmus_lock);\n\n\treturn ret;\n\nfree_dev:\n\tdevice_del(pmu->dev);\n\tput_device(pmu->dev);\n\nfree_idr:\n\tif (pmu->type >= PERF_TYPE_MAX)\n\t\tidr_remove(&pmu_idr, pmu->type);\n\nfree_pdc:\n\tfree_percpu(pmu->pmu_disable_count);\n\tgoto unlock;\n}\n", "target": 1, "idx": 182024}
{"func": "  FakeRenderWidgetHostViewAura(RenderWidgetHost* widget,\n                               bool is_guest_view_hack)\n      : RenderWidgetHostViewAura(widget,\n                                 is_guest_view_hack,\n                                 false /* is_mus_browser_plugin_guest */),\n        is_guest_view_hack_(is_guest_view_hack),\n        delegated_frame_host_client_(\n            new FakeDelegatedFrameHostClientAura(this)) {\n    InstallDelegatedFrameHostClient(\n        this, base::WrapUnique(delegated_frame_host_client_));\n    CreateNewRendererCompositorFrameSink();\n  }\n", "target": 0, "idx": 158405}
{"func": "bool extractPages (const char *srcFileName, const char *destFileName) {\n  char pathName[4096];\n  GooString *gfileName = new GooString (srcFileName);\n  PDFDoc *doc = new PDFDoc (gfileName, NULL, NULL, NULL);\n\n  if (!doc->isOk()) {\n    error(errSyntaxError, -1, \"Could not extract page(s) from damaged file ('{0:s}')\", srcFileName);\n    return false;\n  }\n\n  if (firstPage == 0 && lastPage == 0) {\n    firstPage = 1;\n    lastPage = doc->getNumPages();\n  }\n  if (lastPage == 0)\n    lastPage = doc->getNumPages();\n  if (firstPage == 0)\n   if (firstPage == 0)\n     firstPage = 1;\n   if (firstPage != lastPage && strstr(destFileName, \"%d\") == NULL) {\n    error(errSyntaxError, -1, \"'{0:s}' must contain '%%d' if more than one page should be extracted\", destFileName);\n     return false;\n   }\n   for (int pageNo = firstPage; pageNo <= lastPage; pageNo++) {\n     snprintf (pathName, sizeof (pathName) - 1, destFileName, pageNo);\n     GooString *gpageName = new GooString (pathName);\n\t{\n\t  printUsage (\"pdfseparate\", \"<PDF-sourcefile> <PDF-pattern-destfile>\",\n\t\t      argDesc);\n\t}\n      if (printVersion || printHelp)\n\texitCode = 0;\n      goto err0;\n    }\n  globalParams = new GlobalParams();\n  ok = extractPages (argv[1], argv[2]);\n  if (ok) {\n    exitCode = 0;\n  }\n  delete globalParams;\n\nerr0:\n\n  return exitCode;\n}\n", "target": 1, "idx": 177825}
{"func": "ShellMainDelegate::ShellMainDelegate() {\n}\n", "target": 1, "idx": 186089}
{"func": "int SBEntry::ChunkIdAtPrefix(int index) const {\n  if (type() == SUB_PREFIX)\n    return sub_prefixes_[index].add_chunk;\n  return (type() == SUB_FULL_HASH) ?\n      sub_full_hashes_[index].add_chunk : chunk_id();\n}\n", "target": 0, "idx": 99558}
{"func": "ModuleExport size_t RegisterPSImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=SetMagickInfo(\"EPI\");\n   entry->decoder=(DecodeImageHandler *) ReadPSImage;\n   entry->encoder=(EncodeImageHandler *) WritePSImage;\n   entry->magick=(IsImageFormatHandler *) IsPS;\n   entry->adjoin=MagickFalse;\n   entry->blob_support=MagickFalse;\n   entry->seekable_stream=MagickTrue;\n  entry->description=ConstantString(\n   \"Encapsulated PostScript Interchange format\");\n  entry->mime_type=ConstantString(\"application/postscript\");\n  entry->module=ConstantString(\"PS\");\n  (void) RegisterMagickInfo(entry);\n   entry=SetMagickInfo(\"EPS\");\n   entry->decoder=(DecodeImageHandler *) ReadPSImage;\n   entry->encoder=(EncodeImageHandler *) WritePSImage;\n   entry->magick=(IsImageFormatHandler *) IsPS;\n   entry->adjoin=MagickFalse;\n   entry->blob_support=MagickFalse;\n  entry->seekable_stream=MagickTrue;\n  entry->description=ConstantString(\"Encapsulated PostScript\");\n  entry->mime_type=ConstantString(\"application/postscript\");\n  entry->module=ConstantString(\"PS\");\n  (void) RegisterMagickInfo(entry);\n   entry=SetMagickInfo(\"EPSF\");\n   entry->decoder=(DecodeImageHandler *) ReadPSImage;\n   entry->encoder=(EncodeImageHandler *) WritePSImage;\n   entry->magick=(IsImageFormatHandler *) IsPS;\n   entry->adjoin=MagickFalse;\n   entry->blob_support=MagickFalse;\n  entry->seekable_stream=MagickTrue;\n  entry->description=ConstantString(\"Encapsulated PostScript\");\n  entry->mime_type=ConstantString(\"application/postscript\");\n  entry->module=ConstantString(\"PS\");\n  (void) RegisterMagickInfo(entry);\n   entry=SetMagickInfo(\"EPSI\");\n   entry->decoder=(DecodeImageHandler *) ReadPSImage;\n   entry->encoder=(EncodeImageHandler *) WritePSImage;\n   entry->magick=(IsImageFormatHandler *) IsPS;\n   entry->adjoin=MagickFalse;\n   entry->blob_support=MagickFalse;\n  entry->seekable_stream=MagickTrue;\n  entry->description=ConstantString(\n    \"Encapsulated PostScript Interchange format\");\n  entry->mime_type=ConstantString(\"application/postscript\");\n  entry->module=ConstantString(\"PS\");\n  (void) RegisterMagickInfo(entry);\n   entry=SetMagickInfo(\"PS\");\n   entry->decoder=(DecodeImageHandler *) ReadPSImage;\n   entry->encoder=(EncodeImageHandler *) WritePSImage;\n   entry->magick=(IsImageFormatHandler *) IsPS;\n   entry->mime_type=ConstantString(\"application/postscript\");\n   entry->module=ConstantString(\"PS\");\n  entry->blob_support=MagickFalse;\n  entry->seekable_stream=MagickTrue;\n  entry->description=ConstantString(\"PostScript\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n", "target": 1, "idx": 180935}
{"func": "gss_inquire_context(\n\t    OM_uint32 *minor_status,\n\t    gss_ctx_id_t context_handle,\n\t    gss_name_t *src_name,\n\t    gss_name_t *targ_name,\n\t    OM_uint32 *lifetime_rec,\n\t    gss_OID *mech_type,\n\t    OM_uint32 *ctx_flags,\n\t    int *locally_initiated,\n\t    int *opened)\n{\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n    OM_uint32\t\tstatus, temp_minor;\n    gss_OID\t\tactual_mech;\n    gss_name_t localTargName = NULL, localSourceName = NULL;\n\n    status = val_inq_ctx_args(minor_status,\n\t\t\t      context_handle,\n\t\t\t      src_name, targ_name,\n\t\t\t      lifetime_rec,\n\t\t\t      mech_type, ctx_flags,\n\t\t\t      locally_initiated, opened);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech || !mech->gss_inquire_context || !mech->gss_display_name ||\n\t!mech->gss_release_name) {\n\treturn (GSS_S_UNAVAILABLE);\n    }\n\n    status = mech->gss_inquire_context(\n\t\t\tminor_status,\n\t\t\tctx->internal_ctx_id,\n\t\t\t(src_name ? &localSourceName : NULL),\n\t\t\t(targ_name ? &localTargName : NULL),\n\t\t\tlifetime_rec,\n\t\t\t&actual_mech,\n\t\t\tctx_flags,\n\t\t\tlocally_initiated,\n\t\t\topened);\n\n    if (status != GSS_S_COMPLETE) {\n\tmap_error(minor_status, mech);\n\treturn status;\n    }\n\n    /* need to convert names */\n\n    if (src_name) {\n\tif (localSourceName) {\n\t    status = gssint_convert_name_to_union_name(minor_status, mech,\n\t\t\t\t\t\t      localSourceName, src_name);\n\n\t    if (status != GSS_S_COMPLETE) {\n\t\tif (localTargName)\n\t\t    mech->gss_release_name(&temp_minor, &localTargName);\n\t\treturn (status);\n\t    }\n\t} else {\n\t    *src_name = GSS_C_NO_NAME;\n\t}\n    }\n\n    if (targ_name) {\n        if (localTargName) {\n\t    status = gssint_convert_name_to_union_name(minor_status, mech,\n\t\t\t\t\t\t      localTargName, targ_name);\n\n\t    if (status != GSS_S_COMPLETE) {\n\t\tif (src_name)\n\t\t    (void) gss_release_name(&temp_minor, src_name);\n\n\t\treturn (status);\n\t    }\n        }\n        else {\n            *targ_name = GSS_C_NO_NAME;\n        }\n    }\n\n    if (mech_type)\n\t*mech_type = gssint_get_public_oid(actual_mech);\n\n    return(GSS_S_COMPLETE);\n}\n", "target": 1, "idx": 181189}
{"func": "static PHP_METHOD(PDOStatement, closeCursor)\n{\n\tPHP_STMT_GET_OBJ;\n\n\tif (!stmt->methods->cursor_closer) {\n\t\t/* emulate it by fetching and discarding rows */\n\t\tdo {\n\t\t\twhile (stmt->methods->fetcher(stmt, PDO_FETCH_ORI_NEXT, 0 TSRMLS_CC))\n\t\t\t\t;\n\t\t\tif (!stmt->methods->next_rowset) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!pdo_stmt_do_next_rowset(stmt TSRMLS_CC)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t} while (1);\n\t\tstmt->executed = 0;\n\t\tRETURN_TRUE;\n\t}\n\n\tPDO_STMT_CLEAR_ERR();\n\n\tif (!stmt->methods->cursor_closer(stmt TSRMLS_CC)) {\n\t\tPDO_HANDLE_STMT_ERR();\n\t\tRETURN_FALSE;\n\t}\n\tstmt->executed = 0;\n\tRETURN_TRUE;\n}\n", "target": 0, "idx": 72403}
{"func": "xfs_ioctl_setattr(\n\txfs_inode_t\t\t*ip,\n\tstruct fsxattr\t\t*fa,\n\tint\t\t\tmask)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_trans\t*tp;\n\tunsigned int\t\tlock_flags = 0;\n\tstruct xfs_dquot\t*udqp = NULL;\n\tstruct xfs_dquot\t*pdqp = NULL;\n\tstruct xfs_dquot\t*olddquot = NULL;\n\tint\t\t\tcode;\n\n\ttrace_xfs_ioctl_setattr(ip);\n\n\tif (mp->m_flags & XFS_MOUNT_RDONLY)\n\t\treturn XFS_ERROR(EROFS);\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn XFS_ERROR(EIO);\n\n\t/*\n\t * Disallow 32bit project ids when projid32bit feature is not enabled.\n\t */\n\tif ((mask & FSX_PROJID) && (fa->fsx_projid > (__uint16_t)-1) &&\n\t\t\t!xfs_sb_version_hasprojid32bit(&ip->i_mount->m_sb))\n\t\treturn XFS_ERROR(EINVAL);\n\n\t/*\n\t * If disk quotas is on, we make sure that the dquots do exist on disk,\n\t * before we start any other transactions. Trying to do this later\n\t * is messy. We don't care to take a readlock to look at the ids\n\t * in inode here, because we can't hold it across the trans_reserve.\n\t * If the IDs do change before we take the ilock, we're covered\n\t * because the i_*dquot fields will get updated anyway.\n\t */\n\tif (XFS_IS_QUOTA_ON(mp) && (mask & FSX_PROJID)) {\n\t\tcode = xfs_qm_vop_dqalloc(ip, ip->i_d.di_uid,\n\t\t\t\t\t ip->i_d.di_gid, fa->fsx_projid,\n\t\t\t\t\t XFS_QMOPT_PQUOTA, &udqp, NULL, &pdqp);\n\t\tif (code)\n\t\t\treturn code;\n\t}\n\n\t/*\n\t * For the other attributes, we acquire the inode lock and\n\t * first do an error checking pass.\n\t */\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_SETATTR_NOT_SIZE);\n\tcode = xfs_trans_reserve(tp, &M_RES(mp)->tr_ichange, 0, 0);\n\tif (code)\n\t\tgoto error_return;\n\n\tlock_flags = XFS_ILOCK_EXCL;\n\txfs_ilock(ip, lock_flags);\n\n\t/*\n\t * CAP_FOWNER overrides the following restrictions:\n\t *\n\t * The user ID of the calling process must be equal\n\t * to the file owner ID, except in cases where the\n\t * CAP_FSETID capability is applicable.\n\t */\n\tif (!inode_owner_or_capable(VFS_I(ip))) {\n\t\tcode = XFS_ERROR(EPERM);\n\t\tgoto error_return;\n\t}\n\n\t/*\n\t * Do a quota reservation only if projid is actually going to change.\n\t * Only allow changing of projid from init_user_ns since it is a\n\t * non user namespace aware identifier.\n\t */\n\tif (mask & FSX_PROJID) {\n\t\tif (current_user_ns() != &init_user_ns) {\n\t\t\tcode = XFS_ERROR(EINVAL);\n\t\t\tgoto error_return;\n\t\t}\n\n\t\tif (XFS_IS_QUOTA_RUNNING(mp) &&\n\t\t    XFS_IS_PQUOTA_ON(mp) &&\n\t\t    xfs_get_projid(ip) != fa->fsx_projid) {\n\t\t\tASSERT(tp);\n\t\t\tcode = xfs_qm_vop_chown_reserve(tp, ip, udqp, NULL,\n\t\t\t\t\t\tpdqp, capable(CAP_FOWNER) ?\n\t\t\t\t\t\tXFS_QMOPT_FORCE_RES : 0);\n\t\t\tif (code)\t/* out of quota */\n\t\t\t\tgoto error_return;\n\t\t}\n\t}\n\n\tif (mask & FSX_EXTSIZE) {\n\t\t/*\n\t\t * Can't change extent size if any extents are allocated.\n\t\t */\n\t\tif (ip->i_d.di_nextents &&\n\t\t    ((ip->i_d.di_extsize << mp->m_sb.sb_blocklog) !=\n\t\t     fa->fsx_extsize)) {\n\t\t\tcode = XFS_ERROR(EINVAL);\t/* EFBIG? */\n\t\t\tgoto error_return;\n\t\t}\n\n\t\t/*\n\t\t * Extent size must be a multiple of the appropriate block\n\t\t * size, if set at all. It must also be smaller than the\n\t\t * maximum extent size supported by the filesystem.\n\t\t *\n\t\t * Also, for non-realtime files, limit the extent size hint to\n\t\t * half the size of the AGs in the filesystem so alignment\n\t\t * doesn't result in extents larger than an AG.\n\t\t */\n\t\tif (fa->fsx_extsize != 0) {\n\t\t\txfs_extlen_t    size;\n\t\t\txfs_fsblock_t   extsize_fsb;\n\n\t\t\textsize_fsb = XFS_B_TO_FSB(mp, fa->fsx_extsize);\n\t\t\tif (extsize_fsb > MAXEXTLEN) {\n\t\t\t\tcode = XFS_ERROR(EINVAL);\n\t\t\t\tgoto error_return;\n\t\t\t}\n\n\t\t\tif (XFS_IS_REALTIME_INODE(ip) ||\n\t\t\t    ((mask & FSX_XFLAGS) &&\n\t\t\t    (fa->fsx_xflags & XFS_XFLAG_REALTIME))) {\n\t\t\t\tsize = mp->m_sb.sb_rextsize <<\n\t\t\t\t       mp->m_sb.sb_blocklog;\n\t\t\t} else {\n\t\t\t\tsize = mp->m_sb.sb_blocksize;\n\t\t\t\tif (extsize_fsb > mp->m_sb.sb_agblocks / 2) {\n\t\t\t\t\tcode = XFS_ERROR(EINVAL);\n\t\t\t\t\tgoto error_return;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (fa->fsx_extsize % size) {\n\t\t\t\tcode = XFS_ERROR(EINVAL);\n\t\t\t\tgoto error_return;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tif (mask & FSX_XFLAGS) {\n\t\t/*\n\t\t * Can't change realtime flag if any extents are allocated.\n\t\t */\n\t\tif ((ip->i_d.di_nextents || ip->i_delayed_blks) &&\n\t\t    (XFS_IS_REALTIME_INODE(ip)) !=\n\t\t    (fa->fsx_xflags & XFS_XFLAG_REALTIME)) {\n\t\t\tcode = XFS_ERROR(EINVAL);\t/* EFBIG? */\n\t\t\tgoto error_return;\n\t\t}\n\n\t\t/*\n\t\t * If realtime flag is set then must have realtime data.\n\t\t */\n\t\tif ((fa->fsx_xflags & XFS_XFLAG_REALTIME)) {\n\t\t\tif ((mp->m_sb.sb_rblocks == 0) ||\n\t\t\t    (mp->m_sb.sb_rextsize == 0) ||\n\t\t\t    (ip->i_d.di_extsize % mp->m_sb.sb_rextsize)) {\n\t\t\t\tcode = XFS_ERROR(EINVAL);\n\t\t\t\tgoto error_return;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Can't modify an immutable/append-only file unless\n\t\t * we have appropriate permission.\n\t\t */\n\t\tif ((ip->i_d.di_flags &\n\t\t\t\t(XFS_DIFLAG_IMMUTABLE|XFS_DIFLAG_APPEND) ||\n\t\t     (fa->fsx_xflags &\n\t\t\t\t(XFS_XFLAG_IMMUTABLE | XFS_XFLAG_APPEND))) &&\n\t\t    !capable(CAP_LINUX_IMMUTABLE)) {\n\t\t\tcode = XFS_ERROR(EPERM);\n\t\t\tgoto error_return;\n\t\t}\n\t}\n\n\txfs_trans_ijoin(tp, ip, 0);\n\n\t/*\n\t * Change file ownership.  Must be the owner or privileged.\n\t */\n\tif (mask & FSX_PROJID) {\n\t\t/*\n\t\t * CAP_FSETID overrides the following restrictions:\n\t\t *\n\t\t * The set-user-ID and set-group-ID bits of a file will be\n \t\t * cleared upon successful return from chown()\n \t\t */\n \t\tif ((ip->i_d.di_mode & (S_ISUID|S_ISGID)) &&\n\t\t    !inode_capable(VFS_I(ip), CAP_FSETID))\n \t\t\tip->i_d.di_mode &= ~(S_ISUID|S_ISGID);\n \n \t\t/*\n\t\t * Change the ownerships and register quota modifications\n\t\t * in the transaction.\n\t\t */\n\t\tif (xfs_get_projid(ip) != fa->fsx_projid) {\n\t\t\tif (XFS_IS_QUOTA_RUNNING(mp) && XFS_IS_PQUOTA_ON(mp)) {\n\t\t\t\tolddquot = xfs_qm_vop_chown(tp, ip,\n\t\t\t\t\t\t\t&ip->i_pdquot, pdqp);\n\t\t\t}\n\t\t\txfs_set_projid(ip, fa->fsx_projid);\n\n\t\t\t/*\n\t\t\t * We may have to rev the inode as well as\n\t\t\t * the superblock version number since projids didn't\n\t\t\t * exist before DINODE_VERSION_2 and SB_VERSION_NLINK.\n\t\t\t */\n\t\t\tif (ip->i_d.di_version == 1)\n\t\t\t\txfs_bump_ino_vers2(tp, ip);\n\t\t}\n\n\t}\n\n\tif (mask & FSX_EXTSIZE)\n\t\tip->i_d.di_extsize = fa->fsx_extsize >> mp->m_sb.sb_blocklog;\n\tif (mask & FSX_XFLAGS) {\n\t\txfs_set_diflags(ip, fa->fsx_xflags);\n\t\txfs_diflags_to_linux(ip);\n\t}\n\n\txfs_trans_ichgtime(tp, ip, XFS_ICHGTIME_CHG);\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\tXFS_STATS_INC(xs_ig_attrchg);\n\n\t/*\n\t * If this is a synchronous mount, make sure that the\n\t * transaction goes to disk before returning to the user.\n\t * This is slightly sub-optimal in that truncates require\n\t * two sync transactions instead of one for wsync filesystems.\n\t * One for the truncate and one for the timestamps since we\n\t * don't want to change the timestamps unless we're sure the\n\t * truncate worked.  Truncates are less than 1% of the laddis\n\t * mix so this probably isn't worth the trouble to optimize.\n\t */\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(tp);\n\tcode = xfs_trans_commit(tp, 0);\n\txfs_iunlock(ip, lock_flags);\n\n\t/*\n\t * Release any dquot(s) the inode had kept before chown.\n\t */\n\txfs_qm_dqrele(olddquot);\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(pdqp);\n\n\treturn code;\n\n error_return:\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(pdqp);\n\txfs_trans_cancel(tp, 0);\n\tif (lock_flags)\n\t\txfs_iunlock(ip, lock_flags);\n\treturn code;\n}\n", "target": 1, "idx": 179494}
{"func": "static int read_header(FFV1Context *f)\n{\n    uint8_t state[CONTEXT_SIZE];\n    int i, j, context_count = -1; //-1 to avoid warning\n    RangeCoder *const c = &f->slice_context[0]->c;\n\n     memset(state, 128, sizeof(state));\n \n     if (f->version < 2) {\n         unsigned v= get_symbol(c, state, 0);\n         if (v >= 2) {\n             av_log(f->avctx, AV_LOG_ERROR, \"invalid version %d in ver01 header\\n\", v);\n            return AVERROR_INVALIDDATA;\n        }\n        f->version = v;\n        f->ac      = f->avctx->coder_type = get_symbol(c, state, 0);\n        if (f->ac > 1) {\n            for (i = 1; i < 256; i++)\n                f->state_transition[i] = get_symbol(c, state, 1) + c->one_state[i];\n        }\n\n        f->colorspace = get_symbol(c, state, 0); //YUV cs type\n\n         if (f->version > 0)\n             f->avctx->bits_per_raw_sample = get_symbol(c, state, 0);\n \n        f->chroma_planes  = get_rac(c, state);\n        f->chroma_h_shift = get_symbol(c, state, 0);\n        f->chroma_v_shift = get_symbol(c, state, 0);\n        f->transparency   = get_rac(c, state);\n         f->plane_count    = 2 + f->transparency;\n     }\n \n    if (f->colorspace == 0) {\n        if (!f->transparency && !f->chroma_planes) {\n            if (f->avctx->bits_per_raw_sample <= 8)\n                f->avctx->pix_fmt = AV_PIX_FMT_GRAY8;\n            else\n                f->avctx->pix_fmt = AV_PIX_FMT_GRAY16;\n        } else if (f->avctx->bits_per_raw_sample<=8 && !f->transparency) {\n            switch(16 * f->chroma_h_shift + f->chroma_v_shift) {\n            case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P; break;\n            case 0x01: f->avctx->pix_fmt = AV_PIX_FMT_YUV440P; break;\n            case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P; break;\n            case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P; break;\n            case 0x20: f->avctx->pix_fmt = AV_PIX_FMT_YUV411P; break;\n            case 0x22: f->avctx->pix_fmt = AV_PIX_FMT_YUV410P; break;\n            default:\n                av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");\n                return AVERROR(ENOSYS);\n            }\n        } else if (f->avctx->bits_per_raw_sample <= 8 && f->transparency) {\n            switch(16*f->chroma_h_shift + f->chroma_v_shift) {\n            case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUVA444P; break;\n            case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUVA422P; break;\n            case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUVA420P; break;\n            default:\n                av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");\n                return AVERROR(ENOSYS);\n            }\n        } else if (f->avctx->bits_per_raw_sample == 9) {\n            f->packed_at_lsb = 1;\n            switch(16 * f->chroma_h_shift + f->chroma_v_shift) {\n            case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P9; break;\n            case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P9; break;\n            case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P9; break;\n            default:\n                av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");\n                return AVERROR(ENOSYS);\n            }\n        } else if (f->avctx->bits_per_raw_sample == 10) {\n            f->packed_at_lsb = 1;\n            switch(16 * f->chroma_h_shift + f->chroma_v_shift) {\n            case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P10; break;\n            case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P10; break;\n            case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P10; break;\n            default:\n                av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");\n                return AVERROR(ENOSYS);\n            }\n        } else {\n            switch(16 * f->chroma_h_shift + f->chroma_v_shift) {\n            case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P16; break;\n            case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P16; break;\n            case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P16; break;\n            default:\n                av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");\n                return AVERROR(ENOSYS);\n            }\n        }\n    } else if (f->colorspace == 1) {\n        if (f->chroma_h_shift || f->chroma_v_shift) {\n            av_log(f->avctx, AV_LOG_ERROR,\n                   \"chroma subsampling not supported in this colorspace\\n\");\n            return AVERROR(ENOSYS);\n        }\n        if (     f->avctx->bits_per_raw_sample ==  9)\n            f->avctx->pix_fmt = AV_PIX_FMT_GBRP9;\n        else if (f->avctx->bits_per_raw_sample == 10)\n            f->avctx->pix_fmt = AV_PIX_FMT_GBRP10;\n        else if (f->avctx->bits_per_raw_sample == 12)\n            f->avctx->pix_fmt = AV_PIX_FMT_GBRP12;\n        else if (f->avctx->bits_per_raw_sample == 14)\n            f->avctx->pix_fmt = AV_PIX_FMT_GBRP14;\n        else\n        if (f->transparency) f->avctx->pix_fmt = AV_PIX_FMT_RGB32;\n        else                 f->avctx->pix_fmt = AV_PIX_FMT_0RGB32;\n    } else {\n        av_log(f->avctx, AV_LOG_ERROR, \"colorspace not supported\\n\");\n        return AVERROR(ENOSYS);\n    }\n\n    av_dlog(f->avctx, \"%d %d %d\\n\",\n            f->chroma_h_shift, f->chroma_v_shift, f->avctx->pix_fmt);\n    if (f->version < 2) {\n        context_count = read_quant_tables(c, f->quant_table);\n        if (context_count < 0) {\n            av_log(f->avctx, AV_LOG_ERROR, \"read_quant_table error\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n    } else if (f->version < 3) {\n        f->slice_count = get_symbol(c, state, 0);\n    } else {\n        const uint8_t *p = c->bytestream_end;\n        for (f->slice_count = 0;\n             f->slice_count < MAX_SLICES && 3 < p - c->bytestream_start;\n             f->slice_count++) {\n            int trailer = 3 + 5*!!f->ec;\n            int size = AV_RB24(p-trailer);\n            if (size + trailer > p - c->bytestream_start)\n                break;\n            p -= size + trailer;\n        }\n    }\n    if (f->slice_count > (unsigned)MAX_SLICES || f->slice_count <= 0) {\n        av_log(f->avctx, AV_LOG_ERROR, \"slice count %d is invalid\\n\", f->slice_count);\n        return AVERROR_INVALIDDATA;\n    }\n\n    for (j = 0; j < f->slice_count; j++) {\n        FFV1Context *fs = f->slice_context[j];\n        fs->ac            = f->ac;\n        fs->packed_at_lsb = f->packed_at_lsb;\n\n        fs->slice_damaged = 0;\n\n        if (f->version == 2) {\n            fs->slice_x      =  get_symbol(c, state, 0)      * f->width ;\n            fs->slice_y      =  get_symbol(c, state, 0)      * f->height;\n            fs->slice_width  = (get_symbol(c, state, 0) + 1) * f->width  + fs->slice_x;\n            fs->slice_height = (get_symbol(c, state, 0) + 1) * f->height + fs->slice_y;\n\n            fs->slice_x     /= f->num_h_slices;\n            fs->slice_y     /= f->num_v_slices;\n            fs->slice_width  = fs->slice_width  / f->num_h_slices - fs->slice_x;\n            fs->slice_height = fs->slice_height / f->num_v_slices - fs->slice_y;\n            if ((unsigned)fs->slice_width  > f->width ||\n                (unsigned)fs->slice_height > f->height)\n                return AVERROR_INVALIDDATA;\n            if (   (unsigned)fs->slice_x + (uint64_t)fs->slice_width  > f->width\n                || (unsigned)fs->slice_y + (uint64_t)fs->slice_height > f->height)\n                return AVERROR_INVALIDDATA;\n        }\n\n        for (i = 0; i < f->plane_count; i++) {\n            PlaneContext *const p = &fs->plane[i];\n\n            if (f->version == 2) {\n                int idx = get_symbol(c, state, 0);\n                if (idx > (unsigned)f->quant_table_count) {\n                    av_log(f->avctx, AV_LOG_ERROR,\n                           \"quant_table_index out of range\\n\");\n                    return AVERROR_INVALIDDATA;\n                }\n                p->quant_table_index = idx;\n                memcpy(p->quant_table, f->quant_tables[idx],\n                       sizeof(p->quant_table));\n                context_count = f->context_count[idx];\n            } else {\n                memcpy(p->quant_table, f->quant_table, sizeof(p->quant_table));\n            }\n\n            if (f->version <= 2) {\n                av_assert0(context_count >= 0);\n                if (p->context_count < context_count) {\n                    av_freep(&p->state);\n                    av_freep(&p->vlc_state);\n                }\n                p->context_count = context_count;\n            }\n        }\n    }\n    return 0;\n}\n", "target": 1, "idx": 179100}
{"func": "void HistogramTimeLarge(const std::string& name, int64_t ms) {\n  if (ms < 0) return;\n\n  const PPB_UMA_Private* ptr = GetUMAInterface();\n  if (ptr == NULL) return;\n\n  ptr->HistogramCustomTimes(pp::Var(name).pp_var(),\n                            ms,\n                            kTimeLargeMin, kTimeLargeMax,\n                            kTimeLargeBuckets);\n}\n", "target": 0, "idx": 110309}
{"func": "status_t CameraClient::cancelAutoFocus() {\n    LOG1(\"cancelAutoFocus (pid %d)\", getCallingPid());\n\n Mutex::Autolock lock(mLock);\n status_t result = checkPidAndHardware();\n if (result != NO_ERROR) return result;\n\n return mHardware->cancelAutoFocus();\n}\n", "target": 0, "idx": 174936}
{"func": "static void tx3g_dump_rgb16(FILE * trace, char *name, char col[6])\n{\n\tfprintf(trace, \"%s=\\\"%x %x %x\\\"\", name, *((u16*)col), *((u16*)(col+1)), *((u16*)(col+2)));\n}\n", "target": 0, "idx": 80895}
{"func": "bool PrintRenderFrameHelper::PrintPagesNative(blink::WebLocalFrame* frame,\n                                              int page_count) {\n  const PrintMsg_PrintPages_Params& params = *print_pages_params_;\n  const PrintMsg_Print_Params& print_params = params.params;\n\n  std::vector<int> printed_pages = GetPrintedPages(params, page_count);\n  if (printed_pages.empty())\n    return false;\n\n  PdfMetafileSkia metafile(print_params.printed_doc_type);\n  CHECK(metafile.Init());\n\n  for (int page_number : printed_pages) {\n    PrintPageInternal(print_params, page_number, page_count, frame, &metafile,\n                      nullptr, nullptr);\n  }\n\n  FinishFramePrinting();\n\n  metafile.FinishDocument();\n\n#if defined(OS_ANDROID)\n  int sequence_number = -1;\n  base::FileDescriptor fd;\n\n  Send(new PrintHostMsg_AllocateTempFileForPrinting(routing_id(), &fd,\n                                                    &sequence_number));\n  if (!SaveToFD(metafile, fd))\n    return false;\n\n  Send(new PrintHostMsg_TempFileForPrintingWritten(\n      routing_id(), sequence_number, printed_pages.size()));\n   return true;\n #else\n   PrintHostMsg_DidPrintDocument_Params page_params;\n  if (!CopyMetafileDataToSharedMem(metafile,\n                                   &page_params.metafile_data_handle)) {\n     return false;\n   }\n \n  page_params.data_size = metafile.GetDataSize();\n  page_params.document_cookie = print_params.document_cookie;\n  Send(new PrintHostMsg_DidPrintDocument(routing_id(), page_params));\n  return true;\n#endif  // defined(OS_ANDROID)\n}\n", "target": 1, "idx": 186832}
{"func": "void Download::start()\n {\n     notImplemented();\n }\n", "target": 1, "idx": 183443}
{"func": "void DocumentLoader::SetSourceLocation(\n    std::unique_ptr<SourceLocation> source_location) {\n  source_location_ = std::move(source_location);\n}\n", "target": 0, "idx": 136628}
{"func": "void SendStatus(struct mg_connection* connection,\n                const struct mg_request_info* request_info,\n                void* user_data) {\n  std::string response = \"HTTP/1.1 200 OK\\r\\n\"\n                         \"Content-Length:2\\r\\n\\r\\n\"\n                         \"ok\";\n   mg_write(connection, response.data(), response.length());\n }\n", "target": 1, "idx": 183915}
{"func": " cdf_count_chain(const cdf_sat_t *sat, cdf_secid_t sid, size_t size)\n {\n \tsize_t i, j;\n\tcdf_secid_t maxsector = (cdf_secid_t)(sat->sat_len * size);\n \n \tDPRINTF((\"Chain:\"));\n \tfor (j = i = 0; sid >= 0; i++, j++) {\n\t\tDPRINTF((\" %d\", sid));\n\t\tif (j >= CDF_LOOP_LIMIT) {\n\t\t\tDPRINTF((\"Counting chain loop limit\"));\n \t\t\terrno = EFTYPE;\n \t\t\treturn (size_t)-1;\n \t\t}\n\t\tif (sid > maxsector) {\n\t\t\tDPRINTF((\"Sector %d > %d\\n\", sid, maxsector));\n \t\t\terrno = EFTYPE;\n \t\t\treturn (size_t)-1;\n \t\t}\n\t\tsid = CDF_TOLE4((uint32_t)sat->sat_tab[sid]);\n\t}\n\tif (i == 0) {\n\t\tDPRINTF((\" none, sid: %d\\n\", sid));\n\t\treturn (size_t)-1;\n\n\t}\n\tDPRINTF((\"\\n\"));\n\treturn i;\n}\n", "target": 1, "idx": 179537}
{"func": "int ssl3_get_record(SSL *s)\n{\n    int ssl_major, ssl_minor, al;\n    int enc_err, n, i, ret = -1;\n    SSL3_RECORD *rr;\n    SSL3_BUFFER *rbuf;\n    SSL_SESSION *sess;\n    unsigned char *p;\n    unsigned char md[EVP_MAX_MD_SIZE];\n    short version;\n    unsigned mac_size;\n    unsigned int num_recs = 0;\n    unsigned int max_recs;\n    unsigned int j;\n\n    rr = RECORD_LAYER_get_rrec(&s->rlayer);\n    rbuf = RECORD_LAYER_get_rbuf(&s->rlayer);\n    max_recs = s->max_pipelines;\n    if (max_recs == 0)\n        max_recs = 1;\n    sess = s->session;\n\n    do {\n        /* check if we have the header */\n        if ((RECORD_LAYER_get_rstate(&s->rlayer) != SSL_ST_READ_BODY) ||\n            (RECORD_LAYER_get_packet_length(&s->rlayer)\n             < SSL3_RT_HEADER_LENGTH)) {\n            n = ssl3_read_n(s, SSL3_RT_HEADER_LENGTH,\n                            SSL3_BUFFER_get_len(rbuf), 0,\n                            num_recs == 0 ? 1 : 0);\n            if (n <= 0)\n                return (n);     /* error or non-blocking */\n            RECORD_LAYER_set_rstate(&s->rlayer, SSL_ST_READ_BODY);\n\n            p = RECORD_LAYER_get_packet(&s->rlayer);\n\n            /*\n             * The first record received by the server may be a V2ClientHello.\n             */\n            if (s->server && RECORD_LAYER_is_first_record(&s->rlayer)\n                && (p[0] & 0x80) && (p[2] == SSL2_MT_CLIENT_HELLO)) {\n                /*\n                 *  SSLv2 style record\n                 *\n                 * |num_recs| here will actually always be 0 because\n                 * |num_recs > 0| only ever occurs when we are processing\n                 * multiple app data records - which we know isn't the case here\n                 * because it is an SSLv2ClientHello. We keep it using\n                 * |num_recs| for the sake of consistency\n                 */\n                rr[num_recs].type = SSL3_RT_HANDSHAKE;\n                rr[num_recs].rec_version = SSL2_VERSION;\n\n                rr[num_recs].length = ((p[0] & 0x7f) << 8) | p[1];\n\n                if (rr[num_recs].length > SSL3_BUFFER_get_len(rbuf)\n                    - SSL2_RT_HEADER_LENGTH) {\n                    al = SSL_AD_RECORD_OVERFLOW;\n                    SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_PACKET_LENGTH_TOO_LONG);\n                    goto f_err;\n                }\n\n                if (rr[num_recs].length < MIN_SSL2_RECORD_LEN) {\n                    al = SSL_AD_HANDSHAKE_FAILURE;\n                    SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_LENGTH_TOO_SHORT);\n                    goto f_err;\n                }\n            } else {\n                /* SSLv3+ style record */\n                if (s->msg_callback)\n                    s->msg_callback(0, 0, SSL3_RT_HEADER, p, 5, s,\n                                    s->msg_callback_arg);\n\n                /* Pull apart the header into the SSL3_RECORD */\n                rr[num_recs].type = *(p++);\n                ssl_major = *(p++);\n                ssl_minor = *(p++);\n                version = (ssl_major << 8) | ssl_minor;\n                rr[num_recs].rec_version = version;\n                n2s(p, rr[num_recs].length);\n\n                /* Lets check version */\n                if (!s->first_packet && version != s->version) {\n                    SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_WRONG_VERSION_NUMBER);\n                    if ((s->version & 0xFF00) == (version & 0xFF00)\n                        && !s->enc_write_ctx && !s->write_hash) {\n                        if (rr->type == SSL3_RT_ALERT) {\n                            /*\n                             * The record is using an incorrect version number,\n                             * but what we've got appears to be an alert. We\n                             * haven't read the body yet to check whether its a\n                             * fatal or not - but chances are it is. We probably\n                             * shouldn't send a fatal alert back. We'll just\n                             * end.\n                             */\n                            goto err;\n                        }\n                        /*\n                         * Send back error using their minor version number :-)\n                         */\n                        s->version = (unsigned short)version;\n                    }\n                    al = SSL_AD_PROTOCOL_VERSION;\n                    goto f_err;\n                }\n\n                if ((version >> 8) != SSL3_VERSION_MAJOR) {\n                    if (RECORD_LAYER_is_first_record(&s->rlayer)) {\n                        /* Go back to start of packet, look at the five bytes\n                         * that we have. */\n                        p = RECORD_LAYER_get_packet(&s->rlayer);\n                        if (strncmp((char *)p, \"GET \", 4) == 0 ||\n                            strncmp((char *)p, \"POST \", 5) == 0 ||\n                            strncmp((char *)p, \"HEAD \", 5) == 0 ||\n                            strncmp((char *)p, \"PUT \", 4) == 0) {\n                            SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_HTTP_REQUEST);\n                            goto err;\n                        } else if (strncmp((char *)p, \"CONNE\", 5) == 0) {\n                            SSLerr(SSL_F_SSL3_GET_RECORD,\n                                   SSL_R_HTTPS_PROXY_REQUEST);\n                            goto err;\n                        }\n\n                        /* Doesn't look like TLS - don't send an alert */\n                        SSLerr(SSL_F_SSL3_GET_RECORD,\n                               SSL_R_WRONG_VERSION_NUMBER);\n                        goto err;\n                    } else {\n                        SSLerr(SSL_F_SSL3_GET_RECORD,\n                               SSL_R_WRONG_VERSION_NUMBER);\n                        al = SSL_AD_PROTOCOL_VERSION;\n                        goto f_err;\n                    }\n                }\n\n                if (rr[num_recs].length >\n                    SSL3_BUFFER_get_len(rbuf) - SSL3_RT_HEADER_LENGTH) {\n                    al = SSL_AD_RECORD_OVERFLOW;\n                    SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_PACKET_LENGTH_TOO_LONG);\n                    goto f_err;\n                }\n            }\n\n            /* now s->rlayer.rstate == SSL_ST_READ_BODY */\n        }\n\n        /*\n         * s->rlayer.rstate == SSL_ST_READ_BODY, get and decode the data.\n         * Calculate how much more data we need to read for the rest of the\n         * record\n         */\n        if (rr[num_recs].rec_version == SSL2_VERSION) {\n            i = rr[num_recs].length + SSL2_RT_HEADER_LENGTH\n                - SSL3_RT_HEADER_LENGTH;\n        } else {\n            i = rr[num_recs].length;\n        }\n        if (i > 0) {\n            /* now s->packet_length == SSL3_RT_HEADER_LENGTH */\n\n            n = ssl3_read_n(s, i, i, 1, 0);\n            if (n <= 0)\n                return (n);     /* error or non-blocking io */\n        }\n\n        /* set state for later operations */\n        RECORD_LAYER_set_rstate(&s->rlayer, SSL_ST_READ_HEADER);\n\n        /*\n         * At this point, s->packet_length == SSL3_RT_HEADER_LENGTH + rr->length,\n         * or s->packet_length == SSL2_RT_HEADER_LENGTH + rr->length\n         * and we have that many bytes in s->packet\n         */\n        if (rr[num_recs].rec_version == SSL2_VERSION) {\n            rr[num_recs].input =\n                &(RECORD_LAYER_get_packet(&s->rlayer)[SSL2_RT_HEADER_LENGTH]);\n        } else {\n            rr[num_recs].input =\n                &(RECORD_LAYER_get_packet(&s->rlayer)[SSL3_RT_HEADER_LENGTH]);\n        }\n\n        /*\n         * ok, we can now read from 's->packet' data into 'rr' rr->input points\n         * at rr->length bytes, which need to be copied into rr->data by either\n         * the decryption or by the decompression When the data is 'copied' into\n         * the rr->data buffer, rr->input will be pointed at the new buffer\n         */\n\n        /*\n         * We now have - encrypted [ MAC [ compressed [ plain ] ] ] rr->length\n         * bytes of encrypted compressed stuff.\n         */\n\n        /* check is not needed I believe */\n        if (rr[num_recs].length > SSL3_RT_MAX_ENCRYPTED_LENGTH) {\n            al = SSL_AD_RECORD_OVERFLOW;\n            SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_ENCRYPTED_LENGTH_TOO_LONG);\n            goto f_err;\n        }\n\n        /* decrypt in place in 'rr->input' */\n        rr[num_recs].data = rr[num_recs].input;\n        rr[num_recs].orig_len = rr[num_recs].length;\n\n        /* Mark this record as not read by upper layers yet */\n        rr[num_recs].read = 0;\n\n        num_recs++;\n\n        /* we have pulled in a full packet so zero things */\n        RECORD_LAYER_reset_packet_length(&s->rlayer);\n        RECORD_LAYER_clear_first_record(&s->rlayer);\n    } while (num_recs < max_recs\n             && rr[num_recs - 1].type == SSL3_RT_APPLICATION_DATA\n             && SSL_USE_EXPLICIT_IV(s)\n             && s->enc_read_ctx != NULL\n             && (EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(s->enc_read_ctx))\n                 & EVP_CIPH_FLAG_PIPELINE)\n             && ssl3_record_app_data_waiting(s));\n\n    /*\n     * If in encrypt-then-mac mode calculate mac from encrypted record. All\n     * the details below are public so no timing details can leak.\n     */\n    if (SSL_USE_ETM(s) && s->read_hash) {\n        unsigned char *mac;\n        mac_size = EVP_MD_CTX_size(s->read_hash);\n        OPENSSL_assert(mac_size <= EVP_MAX_MD_SIZE);\n        for (j = 0; j < num_recs; j++) {\n            if (rr[j].length < mac_size) {\n                al = SSL_AD_DECODE_ERROR;\n                SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_LENGTH_TOO_SHORT);\n                goto f_err;\n            }\n            rr[j].length -= mac_size;\n            mac = rr[j].data + rr[j].length;\n            i = s->method->ssl3_enc->mac(s, &rr[j], md, 0 /* not send */ );\n            if (i < 0 || CRYPTO_memcmp(md, mac, (size_t)mac_size) != 0) {\n                al = SSL_AD_BAD_RECORD_MAC;\n                SSLerr(SSL_F_SSL3_GET_RECORD,\n                       SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC);\n                goto f_err;\n            }\n        }\n    }\n\n    enc_err = s->method->ssl3_enc->enc(s, rr, num_recs, 0);\n    /*-\n     * enc_err is:\n     *    0: (in non-constant time) if the record is publically invalid.\n     *    1: if the padding is valid\n     *    -1: if the padding is invalid\n     */\n    if (enc_err == 0) {\n        al = SSL_AD_DECRYPTION_FAILED;\n        SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_BLOCK_CIPHER_PAD_IS_WRONG);\n        goto f_err;\n    }\n#ifdef SSL_DEBUG\n    printf(\"dec %d\\n\", rr->length);\n    {\n        unsigned int z;\n        for (z = 0; z < rr->length; z++)\n            printf(\"%02X%c\", rr->data[z], ((z + 1) % 16) ? ' ' : '\\n');\n    }\n    printf(\"\\n\");\n#endif\n\n    /* r->length is now the compressed data plus mac */\n    if ((sess != NULL) &&\n        (s->enc_read_ctx != NULL) &&\n        (EVP_MD_CTX_md(s->read_hash) != NULL) && !SSL_USE_ETM(s)) {\n        /* s->read_hash != NULL => mac_size != -1 */\n        unsigned char *mac = NULL;\n        unsigned char mac_tmp[EVP_MAX_MD_SIZE];\n\n        mac_size = EVP_MD_CTX_size(s->read_hash);\n        OPENSSL_assert(mac_size <= EVP_MAX_MD_SIZE);\n\n        for (j = 0; j < num_recs; j++) {\n            /*\n             * orig_len is the length of the record before any padding was\n             * removed. This is public information, as is the MAC in use,\n             * therefore we can safely process the record in a different amount\n             * of time if it's too short to possibly contain a MAC.\n             */\n            if (rr[j].orig_len < mac_size ||\n                /* CBC records must have a padding length byte too. */\n                (EVP_CIPHER_CTX_mode(s->enc_read_ctx) == EVP_CIPH_CBC_MODE &&\n                 rr[j].orig_len < mac_size + 1)) {\n                al = SSL_AD_DECODE_ERROR;\n                SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_LENGTH_TOO_SHORT);\n                goto f_err;\n            }\n\n            if (EVP_CIPHER_CTX_mode(s->enc_read_ctx) == EVP_CIPH_CBC_MODE) {\n                /*\n                 * We update the length so that the TLS header bytes can be\n                 * constructed correctly but we need to extract the MAC in\n                 * constant time from within the record, without leaking the\n                 * contents of the padding bytes.\n                 */\n                mac = mac_tmp;\n                ssl3_cbc_copy_mac(mac_tmp, &rr[j], mac_size);\n                rr[j].length -= mac_size;\n            } else {\n                /*\n                 * In this case there's no padding, so |rec->orig_len| equals\n                 * |rec->length| and we checked that there's enough bytes for\n                 * |mac_size| above.\n                 */\n                rr[j].length -= mac_size;\n                mac = &rr[j].data[rr[j].length];\n            }\n\n            i = s->method->ssl3_enc->mac(s, &rr[j], md, 0 /* not send */ );\n            if (i < 0 || mac == NULL\n                || CRYPTO_memcmp(md, mac, (size_t)mac_size) != 0)\n                enc_err = -1;\n            if (rr->length > SSL3_RT_MAX_COMPRESSED_LENGTH + mac_size)\n                enc_err = -1;\n        }\n    }\n\n    if (enc_err < 0) {\n        /*\n         * A separate 'decryption_failed' alert was introduced with TLS 1.0,\n         * SSL 3.0 only has 'bad_record_mac'.  But unless a decryption\n         * failure is directly visible from the ciphertext anyway, we should\n         * not reveal which kind of error occurred -- this might become\n         * visible to an attacker (e.g. via a logfile)\n         */\n        al = SSL_AD_BAD_RECORD_MAC;\n        SSLerr(SSL_F_SSL3_GET_RECORD,\n               SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC);\n        goto f_err;\n    }\n\n    for (j = 0; j < num_recs; j++) {\n        /* rr[j].length is now just compressed */\n        if (s->expand != NULL) {\n            if (rr[j].length > SSL3_RT_MAX_COMPRESSED_LENGTH) {\n                al = SSL_AD_RECORD_OVERFLOW;\n                SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_COMPRESSED_LENGTH_TOO_LONG);\n                goto f_err;\n            }\n            if (!ssl3_do_uncompress(s, &rr[j])) {\n                al = SSL_AD_DECOMPRESSION_FAILURE;\n                SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_BAD_DECOMPRESSION);\n                goto f_err;\n            }\n        }\n\n        if (rr[j].length > SSL3_RT_MAX_PLAIN_LENGTH) {\n            al = SSL_AD_RECORD_OVERFLOW;\n            SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_DATA_LENGTH_TOO_LONG);\n            goto f_err;\n        }\n\n        rr[j].off = 0;\n        /*-\n         * So at this point the following is true\n         * rr[j].type   is the type of record\n         * rr[j].length == number of bytes in record\n         * rr[j].off    == offset to first valid byte\n         * rr[j].data   == where to take bytes from, increment after use :-).\n         */\n\n        /* just read a 0 length packet */\n        if (rr[j].length == 0) {\n            RECORD_LAYER_inc_empty_record_count(&s->rlayer);\n            if (RECORD_LAYER_get_empty_record_count(&s->rlayer)\n                > MAX_EMPTY_RECORDS) {\n                al = SSL_AD_UNEXPECTED_MESSAGE;\n                SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_RECORD_TOO_SMALL);\n                goto f_err;\n            }\n        } else {\n            RECORD_LAYER_reset_empty_record_count(&s->rlayer);\n        }\n    }\n\n    RECORD_LAYER_set_numrpipes(&s->rlayer, num_recs);\n    return 1;\n\n f_err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n err:\n    return ret;\n}\n", "target": 0, "idx": 12700}
{"func": "NPObject* WebPluginProxy::GetPluginElement() {\n  if (plugin_element_)\n    return WebBindings::retainObject(plugin_element_);\n \n   int npobject_route_id = channel_->GenerateRouteID();\n   bool success = false;\n  intptr_t npobject_ptr = NULL;\n  Send(new PluginHostMsg_GetPluginElement(\n      route_id_, npobject_route_id, &success, &npobject_ptr));\n   if (!success)\n     return NULL;\n \n  plugin_element_ = NPObjectProxy::Create(\n      channel_, npobject_route_id, containing_window_, page_url_);\n\n  return plugin_element_;\n}\n", "target": 1, "idx": 183563}
{"func": "PHP_FUNCTION(stream_resolve_include_path)\n{\n        char *filename, *resolved_path;\n        int filename_len;\n \n       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &filename, &filename_len) == FAILURE) {\n                return;\n        }\n\tresolved_path = zend_resolve_path(filename, filename_len TSRMLS_CC);\n\n\tif (resolved_path) {\n\t\tRETURN_STRING(resolved_path, 0);\n\t}\n\tRETURN_FALSE;\n}\n", "target": 1, "idx": 178489}
{"func": "void TryCreateDuplicateRequestIds(Shell* shell, bool block_loaders) {\n  NavigateToURL(shell, GURL(\"http://foo.com/simple_page.html\"));\n  RenderFrameHost* rfh = shell->web_contents()->GetMainFrame();\n\n  if (block_loaders) {\n    rfh->BlockRequestsForFrame();\n  }\n\n  const char* blocking_url = net::URLRequestSlowDownloadJob::kUnknownSizeUrl;\n  ResourceRequest request(CreateXHRRequest(blocking_url));\n\n  RenderProcessHostWatcher process_killed(\n      rfh->GetProcess(), RenderProcessHostWatcher::WATCH_FOR_PROCESS_EXIT);\n  IPC::IpcSecurityTestUtil::PwnMessageReceived(\n      rfh->GetProcess()->GetChannel(),\n      ResourceHostMsg_RequestResource(rfh->GetRoutingID(),\n                                      kRequestIdNotPreviouslyUsed, request,\n                                      net::MutableNetworkTrafficAnnotationTag(\n                                          TRAFFIC_ANNOTATION_FOR_TESTS)));\n  IPC::IpcSecurityTestUtil::PwnMessageReceived(\n      rfh->GetProcess()->GetChannel(),\n      ResourceHostMsg_RequestResource(rfh->GetRoutingID(),\n                                      kRequestIdNotPreviouslyUsed, request,\n                                      net::MutableNetworkTrafficAnnotationTag(\n                                          TRAFFIC_ANNOTATION_FOR_TESTS)));\n  process_killed.Wait();\n}\n", "target": 0, "idx": 169424}
{"func": "void ntlm_populate_message_header(NTLM_MESSAGE_HEADER* header, UINT32 MessageType)\n {\n \tCopyMemory(header->Signature, NTLM_SIGNATURE, sizeof(NTLM_SIGNATURE));\n \theader->MessageType = MessageType;\n }\n", "target": 1, "idx": 182445}
{"func": "void Browser::UpdateCommandsForContentRestrictionState() {\n  int restrictions = GetContentRestrictionsForSelectedTab();\n\n  command_updater_.UpdateCommandEnabled(\n      IDC_COPY, !(restrictions & CONTENT_RESTRICTION_COPY));\n  command_updater_.UpdateCommandEnabled(\n      IDC_CUT, !(restrictions & CONTENT_RESTRICTION_CUT));\n  command_updater_.UpdateCommandEnabled(\n      IDC_PASTE, !(restrictions & CONTENT_RESTRICTION_PASTE));\n  command_updater_.UpdateCommandEnabled(\n      IDC_SAVE_PAGE, !(restrictions & CONTENT_RESTRICTION_SAVE));\n  UpdatePrintingState(restrictions);\n}\n", "target": 0, "idx": 103217}
{"func": "int git_pkt_parse_line(\n\tgit_pkt **head, const char *line, const char **out, size_t bufflen)\n{\n\tint ret;\n\tint32_t len;\n\n\t/* Not even enough for the length */\n\tif (bufflen > 0 && bufflen < PKT_LEN_SIZE)\n\t\treturn GIT_EBUFS;\n\n\tlen = parse_len(line);\n\tif (len < 0) {\n\t\t/*\n\t\t * If we fail to parse the length, it might be because the\n\t\t * server is trying to send us the packfile already.\n\t\t */\n\t\tif (bufflen >= 4 && !git__prefixcmp(line, \"PACK\")) {\n\t\t\tgiterr_clear();\n\t\t\t*out = line;\n\t\t\treturn pack_pkt(head);\n\t\t}\n\n\t\treturn (int)len;\n\t}\n\n\t/*\n\t * If we were given a buffer length, then make sure there is\n\t * enough in the buffer to satisfy this line\n\t */\n \tif (bufflen > 0 && bufflen < (size_t)len)\n \t\treturn GIT_EBUFS;\n \n \tline += PKT_LEN_SIZE;\n \t/*\n \t * TODO: How do we deal with empty lines? Try again? with the next\n\t * line?\n\t */\n\tif (len == PKT_LEN_SIZE) {\n\t\t*head = NULL;\n\t\t*out = line;\n\t\treturn 0;\n\t}\n\n\tif (len == 0) { /* Flush pkt */\n\t\t*out = line;\n\t\treturn flush_pkt(head);\n\t}\n\n\tlen -= PKT_LEN_SIZE; /* the encoded length includes its own size */\n\n\tif (*line == GIT_SIDE_BAND_DATA)\n\t\tret = data_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_PROGRESS)\n\t\tret = sideband_progress_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_ERROR)\n\t\tret = sideband_error_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ACK\"))\n\t\tret = ack_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"NAK\"))\n\t\tret = nak_pkt(head);\n\telse if (!git__prefixcmp(line, \"ERR \"))\n\t\tret = err_pkt(head, line, len);\n\telse if (*line == '#')\n\t\tret = comment_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ok\"))\n\t\tret = ok_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ng\"))\n\t\tret = ng_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"unpack\"))\n\t\tret = unpack_pkt(head, line, len);\n\telse\n\t\tret = ref_pkt(head, line, len);\n\n\t*out = line + len;\n\n\treturn ret;\n}\n", "target": 1, "idx": 181702}
{"func": "static int ssl_parse_server_psk_hint( mbedtls_ssl_context *ssl,\n                                      unsigned char **p,\n                                      unsigned char *end )\n{\n    int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;\n    size_t  len;\n    ((void) ssl);\n\n    /*\n     * PSK parameters:\n     *\n     * opaque psk_identity_hint<0..2^16-1>;\n     */\n    if( (*p) > end - 2 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message \"\n                                    \"(psk_identity_hint length)\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n    }\n     len = (*p)[0] << 8 | (*p)[1];\n     *p += 2;\n \n    if( (*p) + len > end )\n     {\n         MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message \"\n                                     \"(psk_identity_hint length)\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n    }\n\n    /*\n     * Note: we currently ignore the PKS identity hint, as we only allow one\n     * PSK to be provisionned on the client. This could be changed later if\n     * someone needs that feature.\n     */\n    *p += len;\n    ret = 0;\n\n    return( ret );\n}\n", "target": 1, "idx": 183341}
{"func": "void Document::styleResolverMayHaveChanged()\n{\n    styleEngine().resolverChanged(hasNodesWithPlaceholderStyle() ? FullStyleUpdate : AnalyzedStyleUpdate);\n\n    if (didLayoutWithPendingStylesheets() && !styleEngine().hasPendingScriptBlockingSheets()) {\n        m_pendingSheetLayout = IgnoreLayoutWithPendingSheets;\n\n        DCHECK(layoutView() || importsController());\n        if (layoutView())\n            layoutView()->invalidatePaintForViewAndCompositedLayers();\n    }\n}\n", "target": 0, "idx": 143282}
{"func": "int nfs4_set_lock_state(struct nfs4_state *state, struct file_lock *fl)\n{\n\tstruct nfs4_lock_state *lsp;\n\n\tif (fl->fl_ops != NULL)\n\t\treturn 0;\n\tlsp = nfs4_get_lock_state(state, fl->fl_owner);\n\tif (lsp == NULL)\n\t\treturn -ENOMEM;\n\tfl->fl_u.nfs4_fl.owner = lsp;\n\tfl->fl_ops = &nfs4_fl_lock_ops;\n\treturn 0;\n}\n", "target": 0, "idx": 22957}
{"func": "void BrowserActionsContainer::BrowserActionAdded(Extension* extension,\n                                                 int index) {\n#if defined(DEBUG)\n  for (size_t i = 0; i < browser_action_views_.size(); ++i) {\n    DCHECK(browser_action_views_[i]->button()->extension() != extension) <<\n           \"Asked to add a browser action view for an extension that already \"\n           \"exists.\";\n  }\n#endif\n  size_t visible_actions = 0;\n  for (size_t i = 0; i < browser_action_views_.size(); ++i) {\n    if (browser_action_views_[i]->IsVisible())\n      ++visible_actions;\n  }\n  BrowserActionView* view = new BrowserActionView(extension, this);\n  browser_action_views_.push_back(view);\n  AddChildView(index, view);\n  if (visible_actions < browser_action_views_.size() - 1) {\n    OnBrowserActionVisibilityChanged();\n  } else {\n    animation_target_size_ = IconCountToWidth(visible_actions + 1);\n    suppress_chevron_ = !chevron_->IsVisible();\n    resize_animation_->Reset();\n    resize_animation_->SetTweenType(SlideAnimation::NONE);\n    resize_animation_->Show();\n  }\n}\n", "target": 1, "idx": 183608}
{"func": "do_ip_vs_get_ctl(struct sock *sk, int cmd, void __user *user, int *len)\n{\n\tunsigned char arg[128];\n\tint ret = 0;\n\tunsigned int copylen;\n\tstruct net *net = sock_net(sk);\n\tstruct netns_ipvs *ipvs = net_ipvs(net);\n\n\tBUG_ON(!net);\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_GET_MAX)\n\t\treturn -EINVAL;\n\n\tif (*len < get_arglen[GET_CMDID(cmd)]) {\n\t\tpr_err(\"get_ctl: len %u < %u\\n\",\n\t\t       *len, get_arglen[GET_CMDID(cmd)]);\n\t\treturn -EINVAL;\n\t}\n\n\tcopylen = get_arglen[GET_CMDID(cmd)];\n\tif (copylen > 128)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(arg, user, copylen) != 0)\n\t\treturn -EFAULT;\n\t/*\n\t * Handle daemons first since it has its own locking\n\t */\n\tif (cmd == IP_VS_SO_GET_DAEMON) {\n\t\tstruct ip_vs_daemon_user d[2];\n\n\t\tmemset(&d, 0, sizeof(d));\n\t\tif (mutex_lock_interruptible(&ipvs->sync_mutex))\n\t\t\treturn -ERESTARTSYS;\n\n\t\tif (ipvs->sync_state & IP_VS_STATE_MASTER) {\n\t\t\td[0].state = IP_VS_STATE_MASTER;\n\t\t\tstrlcpy(d[0].mcast_ifn, ipvs->master_mcast_ifn,\n\t\t\t\tsizeof(d[0].mcast_ifn));\n\t\t\td[0].syncid = ipvs->master_syncid;\n\t\t}\n\t\tif (ipvs->sync_state & IP_VS_STATE_BACKUP) {\n\t\t\td[1].state = IP_VS_STATE_BACKUP;\n\t\t\tstrlcpy(d[1].mcast_ifn, ipvs->backup_mcast_ifn,\n\t\t\t\tsizeof(d[1].mcast_ifn));\n\t\t\td[1].syncid = ipvs->backup_syncid;\n\t\t}\n\t\tif (copy_to_user(user, &d, sizeof(d)) != 0)\n\t\t\tret = -EFAULT;\n\t\tmutex_unlock(&ipvs->sync_mutex);\n\t\treturn ret;\n\t}\n\n\tif (mutex_lock_interruptible(&__ip_vs_mutex))\n\t\treturn -ERESTARTSYS;\n\n\tswitch (cmd) {\n\tcase IP_VS_SO_GET_VERSION:\n\t{\n\t\tchar buf[64];\n\n\t\tsprintf(buf, \"IP Virtual Server version %d.%d.%d (size=%d)\",\n\t\t\tNVERSION(IP_VS_VERSION_CODE), ip_vs_conn_tab_size);\n\t\tif (copy_to_user(user, buf, strlen(buf)+1) != 0) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\t*len = strlen(buf)+1;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_INFO:\n\t{\n\t\tstruct ip_vs_getinfo info;\n\t\tinfo.version = IP_VS_VERSION_CODE;\n\t\tinfo.size = ip_vs_conn_tab_size;\n\t\tinfo.num_services = ipvs->num_services;\n\t\tif (copy_to_user(user, &info, sizeof(info)) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_SERVICES:\n\t{\n\t\tstruct ip_vs_get_services *get;\n\t\tint size;\n\n\t\tget = (struct ip_vs_get_services *)arg;\n\t\tsize = sizeof(*get) +\n\t\t\tsizeof(struct ip_vs_service_entry) * get->num_services;\n\t\tif (*len != size) {\n\t\t\tpr_err(\"length: %u != %u\\n\", *len, size);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tret = __ip_vs_get_service_entries(net, get, user);\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_SERVICE:\n\t{\n\t\tstruct ip_vs_service_entry *entry;\n\t\tstruct ip_vs_service *svc;\n\t\tunion nf_inet_addr addr;\n\n\t\tentry = (struct ip_vs_service_entry *)arg;\n\t\taddr.ip = entry->addr;\n\t\tif (entry->fwmark)\n\t\t\tsvc = __ip_vs_svc_fwm_find(net, AF_INET, entry->fwmark);\n\t\telse\n\t\t\tsvc = __ip_vs_service_find(net, AF_INET,\n\t\t\t\t\t\t   entry->protocol, &addr,\n\t\t\t\t\t\t   entry->port);\n\t\tif (svc) {\n\t\t\tip_vs_copy_service(entry, svc);\n\t\t\tif (copy_to_user(user, entry, sizeof(*entry)) != 0)\n\t\t\t\tret = -EFAULT;\n\t\t} else\n\t\t\tret = -ESRCH;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_DESTS:\n\t{\n\t\tstruct ip_vs_get_dests *get;\n\t\tint size;\n\n\t\tget = (struct ip_vs_get_dests *)arg;\n\t\tsize = sizeof(*get) +\n\t\t\tsizeof(struct ip_vs_dest_entry) * get->num_dests;\n\t\tif (*len != size) {\n\t\t\tpr_err(\"length: %u != %u\\n\", *len, size);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tret = __ip_vs_get_dest_entries(net, get, user);\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_TIMEOUT:\n \t{\n \t\tstruct ip_vs_timeout_user t;\n \n \t\t__ip_vs_get_timeouts(net, &t);\n \t\tif (copy_to_user(user, &t, sizeof(t)) != 0)\n \t\t\tret = -EFAULT;\n\t}\n\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\nout:\n\tmutex_unlock(&__ip_vs_mutex);\n\treturn ret;\n}\n", "target": 1, "idx": 179358}
{"func": "static void Upsample(const size_t width,const size_t height,\n  const size_t scaled_width,unsigned char *pixels)\n{\n  register ssize_t\n    x,\n    y;\n\n  register unsigned char\n    *p,\n    *q,\n    *r;\n\n  /*\n    Create a new image that is a integral size greater than an existing one.\n  */\n  assert(pixels != (unsigned char *) NULL);\n  for (y=0; y < (ssize_t) height; y++)\n  {\n    p=pixels+(height-1-y)*scaled_width+(width-1);\n    q=pixels+((height-1-y) << 1)*scaled_width+((width-1) << 1);\n    *q=(*p);\n    *(q+1)=(*(p));\n    for (x=1; x < (ssize_t) width; x++)\n    {\n      p--;\n      q-=2;\n      *q=(*p);\n      *(q+1)=(unsigned char) ((((size_t) *p)+((size_t) *(p+1))+1) >> 1);\n    }\n  }\n  for (y=0; y < (ssize_t) (height-1); y++)\n  {\n    p=pixels+((size_t) y << 1)*scaled_width;\n    q=p+scaled_width;\n    r=q+scaled_width;\n    for (x=0; x < (ssize_t) (width-1); x++)\n    {\n      *q=(unsigned char) ((((size_t) *p)+((size_t) *r)+1) >> 1);\n      *(q+1)=(unsigned char) ((((size_t) *p)+((size_t) *(p+2))+\n        ((size_t) *r)+((size_t) *(r+2))+2) >> 2);\n      q+=2;\n      p+=2;\n      r+=2;\n    }\n    *q++=(unsigned char) ((((size_t) *p++)+((size_t) *r++)+1) >> 1);\n    *q++=(unsigned char) ((((size_t) *p++)+((size_t) *r++)+1) >> 1);\n  }\n  p=pixels+(2*height-2)*scaled_width;\n  q=pixels+(2*height-1)*scaled_width;\n  (void) memcpy(q,p,(size_t) (2*width));\n}\n", "target": 0, "idx": 91488}
{"func": "static void ssh_process_incoming_data(Ssh ssh,\n\t\t\t\t      const unsigned char **data, int *datalen)\n{\n    struct Packet *pktin;\n\n    pktin = ssh->s_rdpkt(ssh, data, datalen);\n    if (pktin) {\n\tssh->protocol(ssh, NULL, 0, pktin);\n\tssh_free_packet(pktin);\n    }\n}\n", "target": 0, "idx": 8583}
{"func": " static void copyStereo24(\n         short *dst,\n        const int *const *src,\n         unsigned nSamples,\n         unsigned /* nChannels */) {\n     for (unsigned i = 0; i < nSamples; ++i) {\n *dst++ = src[0][i] >> 8;\n *dst++ = src[1][i] >> 8;\n\n     }\n }\n", "target": 1, "idx": 188044}
{"func": "static int handle_oem_get_msg_cmd(struct ipmi_smi *intf,\n\t\t\t\t  struct ipmi_smi_msg *msg)\n{\n\tstruct cmd_rcvr       *rcvr;\n\tint                   rv = 0;\n\tunsigned char         netfn;\n\tunsigned char         cmd;\n\tunsigned char         chan;\n\tstruct ipmi_user *user = NULL;\n\tstruct ipmi_system_interface_addr *smi_addr;\n\tstruct ipmi_recv_msg  *recv_msg;\n\n\t/*\n\t * We expect the OEM SW to perform error checking\n\t * so we just do some basic sanity checks\n\t */\n\tif (msg->rsp_size < 4) {\n\t\t/* Message not big enough, just ignore it. */\n\t\tipmi_inc_stat(intf, invalid_commands);\n\t\treturn 0;\n\t}\n\n\tif (msg->rsp[2] != 0) {\n\t\t/* An error getting the response, just ignore it. */\n\t\treturn 0;\n\t}\n\n\t/*\n\t * This is an OEM Message so the OEM needs to know how\n\t * handle the message. We do no interpretation.\n\t */\n\tnetfn = msg->rsp[0] >> 2;\n\tcmd = msg->rsp[1];\n\tchan = msg->rsp[3] & 0xf;\n\n\trcu_read_lock();\n\trcvr = find_cmd_rcvr(intf, netfn, cmd, chan);\n\tif (rcvr) {\n\t\tuser = rcvr->user;\n\t\tkref_get(&user->refcount);\n\t} else\n\t\tuser = NULL;\n\trcu_read_unlock();\n\n\tif (user == NULL) {\n\t\t/* We didn't find a user, just give up. */\n\t\tipmi_inc_stat(intf, unhandled_commands);\n\n\t\t/*\n\t\t * Don't do anything with these messages, just allow\n\t\t * them to be freed.\n\t\t */\n\n\t\trv = 0;\n\t} else {\n\t\trecv_msg = ipmi_alloc_recv_msg();\n\t\tif (!recv_msg) {\n\t\t\t/*\n\t\t\t * We couldn't allocate memory for the\n\t\t\t * message, so requeue it for handling\n\t\t\t * later.\n\t\t\t */\n\t\t\trv = 1;\n\t\t\tkref_put(&user->refcount, free_user);\n\t\t} else {\n\t\t\t/*\n\t\t\t * OEM Messages are expected to be delivered via\n\t\t\t * the system interface to SMS software.  We might\n\t\t\t * need to visit this again depending on OEM\n\t\t\t * requirements\n\t\t\t */\n\t\t\tsmi_addr = ((struct ipmi_system_interface_addr *)\n\t\t\t\t    &recv_msg->addr);\n\t\t\tsmi_addr->addr_type = IPMI_SYSTEM_INTERFACE_ADDR_TYPE;\n\t\t\tsmi_addr->channel = IPMI_BMC_CHANNEL;\n\t\t\tsmi_addr->lun = msg->rsp[0] & 3;\n\n\t\t\trecv_msg->user = user;\n\t\t\trecv_msg->user_msg_data = NULL;\n\t\t\trecv_msg->recv_type = IPMI_OEM_RECV_TYPE;\n\t\t\trecv_msg->msg.netfn = msg->rsp[0] >> 2;\n\t\t\trecv_msg->msg.cmd = msg->rsp[1];\n\t\t\trecv_msg->msg.data = recv_msg->msg_data;\n\n\t\t\t/*\n\t\t\t * The message starts at byte 4 which follows the\n\t\t\t * the Channel Byte in the \"GET MESSAGE\" command\n\t\t\t */\n\t\t\trecv_msg->msg.data_len = msg->rsp_size - 4;\n\t\t\tmemcpy(recv_msg->msg_data, &msg->rsp[4],\n\t\t\t       msg->rsp_size - 4);\n\t\t\tif (deliver_response(intf, recv_msg))\n\t\t\t\tipmi_inc_stat(intf, unhandled_commands);\n\t\t\telse\n\t\t\t\tipmi_inc_stat(intf, handled_commands);\n\t\t}\n\t}\n\n\treturn rv;\n}\n", "target": 0, "idx": 91248}
{"func": "int64_t yr_object_get_integer(\n    YR_OBJECT* object,\n    const char* field,\n    ...)\n{\n  YR_OBJECT* integer_obj;\n\n  va_list args;\n  va_start(args, field);\n\n  if (field != NULL)\n    integer_obj = _yr_object_lookup(object, 0, field, args);\n  else\n    integer_obj = object;\n\n  va_end(args);\n\n  if (integer_obj == NULL)\n    return UNDEFINED;\n\n  assertf(integer_obj->type == OBJECT_TYPE_INTEGER,\n          \"type of \\\"%s\\\" is not integer\\n\", field);\n\n  return ((YR_OBJECT_INTEGER*) integer_obj)->value;\n}\n", "target": 0, "idx": 66048}
{"func": "void RenderBox::computePositionedLogicalHeightUsing(Length logicalHeightLength, const RenderBoxModelObject* containerBlock,\n                                                    LayoutUnit containerLogicalHeight, LayoutUnit bordersPlusPadding, LayoutUnit logicalHeight,\n                                                    Length logicalTop, Length logicalBottom, Length marginBefore, Length marginAfter,\n                                                    LogicalExtentComputedValues& computedValues) const\n{\n    ASSERT(!(logicalTop.isAuto() && logicalBottom.isAuto()));\n\n    LayoutUnit logicalHeightValue;\n    LayoutUnit contentLogicalHeight = logicalHeight - bordersPlusPadding;\n\n    const LayoutUnit containerRelativeLogicalWidth = containingBlockLogicalWidthForPositioned(containerBlock, false);\n\n    LayoutUnit logicalTopValue = 0;\n\n    bool logicalHeightIsAuto = logicalHeightLength.isAuto();\n    bool logicalTopIsAuto = logicalTop.isAuto();\n    bool logicalBottomIsAuto = logicalBottom.isAuto();\n\n    LayoutUnit resolvedLogicalHeight;\n    if (isTable()) {\n        resolvedLogicalHeight = contentLogicalHeight;\n        logicalHeightIsAuto = false;\n    } else {\n        if (logicalHeightLength.isIntrinsic())\n            resolvedLogicalHeight = computeIntrinsicLogicalContentHeightUsing(logicalHeightLength, contentLogicalHeight, bordersPlusPadding);\n        else\n            resolvedLogicalHeight = adjustContentBoxLogicalHeightForBoxSizing(valueForLength(logicalHeightLength, containerLogicalHeight));\n    }\n\n    if (!logicalTopIsAuto && !logicalHeightIsAuto && !logicalBottomIsAuto) {\n        /*-----------------------------------------------------------------------*\\\n         * If none of the three are 'auto': If both 'margin-top' and 'margin-\n         * bottom' are 'auto', solve the equation under the extra constraint that\n         * the two margins get equal values. If one of 'margin-top' or 'margin-\n         * bottom' is 'auto', solve the equation for that value. If the values\n         * are over-constrained, ignore the value for 'bottom' and solve for that\n         * value.\n        \\*-----------------------------------------------------------------------*/\n\n        logicalHeightValue = resolvedLogicalHeight;\n        logicalTopValue = valueForLength(logicalTop, containerLogicalHeight);\n\n        const LayoutUnit availableSpace = containerLogicalHeight - (logicalTopValue + logicalHeightValue + valueForLength(logicalBottom, containerLogicalHeight) + bordersPlusPadding);\n\n        if (marginBefore.isAuto() && marginAfter.isAuto()) {\n            computedValues.m_margins.m_before = availableSpace / 2; // split the difference\n            computedValues.m_margins.m_after = availableSpace - computedValues.m_margins.m_before; // account for odd valued differences\n        } else if (marginBefore.isAuto()) {\n            computedValues.m_margins.m_after = valueForLength(marginAfter, containerRelativeLogicalWidth);\n            computedValues.m_margins.m_before = availableSpace - computedValues.m_margins.m_after;\n        } else if (marginAfter.isAuto()) {\n            computedValues.m_margins.m_before = valueForLength(marginBefore, containerRelativeLogicalWidth);\n            computedValues.m_margins.m_after = availableSpace - computedValues.m_margins.m_before;\n        } else {\n            computedValues.m_margins.m_before = valueForLength(marginBefore, containerRelativeLogicalWidth);\n            computedValues.m_margins.m_after = valueForLength(marginAfter, containerRelativeLogicalWidth);\n        }\n    } else {\n        /*--------------------------------------------------------------------*\\\n         * Otherwise, set 'auto' values for 'margin-top' and 'margin-bottom'\n         * to 0, and pick the one of the following six rules that applies.\n         *\n         * 1. 'top' and 'height' are 'auto' and 'bottom' is not 'auto', then\n         *    the height is based on the content, and solve for 'top'.\n         *\n         *              OMIT RULE 2 AS IT SHOULD NEVER BE HIT\n         * ------------------------------------------------------------------\n         * 2. 'top' and 'bottom' are 'auto' and 'height' is not 'auto', then\n         *    set 'top' to the static position, and solve for 'bottom'.\n         * ------------------------------------------------------------------\n         *\n         * 3. 'height' and 'bottom' are 'auto' and 'top' is not 'auto', then\n         *    the height is based on the content, and solve for 'bottom'.\n         * 4. 'top' is 'auto', 'height' and 'bottom' are not 'auto', and\n         *    solve for 'top'.\n         * 5. 'height' is 'auto', 'top' and 'bottom' are not 'auto', and\n         *    solve for 'height'.\n         * 6. 'bottom' is 'auto', 'top' and 'height' are not 'auto', and\n         *    solve for 'bottom'.\n        \\*--------------------------------------------------------------------*/\n\n        computedValues.m_margins.m_before = minimumValueForLength(marginBefore, containerRelativeLogicalWidth);\n        computedValues.m_margins.m_after = minimumValueForLength(marginAfter, containerRelativeLogicalWidth);\n\n        const LayoutUnit availableSpace = containerLogicalHeight - (computedValues.m_margins.m_before + computedValues.m_margins.m_after + bordersPlusPadding);\n\n        if (logicalTopIsAuto && logicalHeightIsAuto && !logicalBottomIsAuto) {\n            logicalHeightValue = contentLogicalHeight;\n            logicalTopValue = availableSpace - (logicalHeightValue + valueForLength(logicalBottom, containerLogicalHeight));\n        } else if (!logicalTopIsAuto && logicalHeightIsAuto && logicalBottomIsAuto) {\n            logicalTopValue = valueForLength(logicalTop, containerLogicalHeight);\n            logicalHeightValue = contentLogicalHeight;\n        } else if (logicalTopIsAuto && !logicalHeightIsAuto && !logicalBottomIsAuto) {\n            logicalHeightValue = resolvedLogicalHeight;\n            logicalTopValue = availableSpace - (logicalHeightValue + valueForLength(logicalBottom, containerLogicalHeight));\n        } else if (!logicalTopIsAuto && logicalHeightIsAuto && !logicalBottomIsAuto) {\n            logicalTopValue = valueForLength(logicalTop, containerLogicalHeight);\n            logicalHeightValue = max<LayoutUnit>(0, availableSpace - (logicalTopValue + valueForLength(logicalBottom, containerLogicalHeight)));\n        } else if (!logicalTopIsAuto && !logicalHeightIsAuto && logicalBottomIsAuto) {\n            logicalHeightValue = resolvedLogicalHeight;\n            logicalTopValue = valueForLength(logicalTop, containerLogicalHeight);\n        }\n    }\n    computedValues.m_extent = logicalHeightValue;\n\n    computedValues.m_position = logicalTopValue + computedValues.m_margins.m_before;\n    computeLogicalTopPositionedOffset(computedValues.m_position, this, logicalHeightValue, containerBlock, containerLogicalHeight);\n}\n", "target": 0, "idx": 124843}
{"func": "static int rtnl_fill_ifinfo(struct sk_buff *skb, struct net_device *dev,\n\t\t\t    int type, u32 pid, u32 seq, u32 change,\n\t\t\t    unsigned int flags, u32 ext_filter_mask)\n{\n\tstruct ifinfomsg *ifm;\n\tstruct nlmsghdr *nlh;\n\tstruct rtnl_link_stats64 temp;\n\tconst struct rtnl_link_stats64 *stats;\n\tstruct nlattr *attr, *af_spec;\n\tstruct rtnl_af_ops *af_ops;\n\tstruct net_device *upper_dev = netdev_master_upper_dev_get(dev);\n\n\tASSERT_RTNL();\n\tnlh = nlmsg_put(skb, pid, seq, type, sizeof(*ifm), flags);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tifm = nlmsg_data(nlh);\n\tifm->ifi_family = AF_UNSPEC;\n\tifm->__ifi_pad = 0;\n\tifm->ifi_type = dev->type;\n\tifm->ifi_index = dev->ifindex;\n\tifm->ifi_flags = dev_get_flags(dev);\n\tifm->ifi_change = change;\n\n\tif (nla_put_string(skb, IFLA_IFNAME, dev->name) ||\n\t    nla_put_u32(skb, IFLA_TXQLEN, dev->tx_queue_len) ||\n\t    nla_put_u8(skb, IFLA_OPERSTATE,\n\t\t       netif_running(dev) ? dev->operstate : IF_OPER_DOWN) ||\n\t    nla_put_u8(skb, IFLA_LINKMODE, dev->link_mode) ||\n\t    nla_put_u32(skb, IFLA_MTU, dev->mtu) ||\n\t    nla_put_u32(skb, IFLA_GROUP, dev->group) ||\n\t    nla_put_u32(skb, IFLA_PROMISCUITY, dev->promiscuity) ||\n\t    nla_put_u32(skb, IFLA_NUM_TX_QUEUES, dev->num_tx_queues) ||\n#ifdef CONFIG_RPS\n\t    nla_put_u32(skb, IFLA_NUM_RX_QUEUES, dev->num_rx_queues) ||\n#endif\n\t    (dev->ifindex != dev->iflink &&\n\t     nla_put_u32(skb, IFLA_LINK, dev->iflink)) ||\n\t    (upper_dev &&\n\t     nla_put_u32(skb, IFLA_MASTER, upper_dev->ifindex)) ||\n\t    nla_put_u8(skb, IFLA_CARRIER, netif_carrier_ok(dev)) ||\n\t    (dev->qdisc &&\n\t     nla_put_string(skb, IFLA_QDISC, dev->qdisc->ops->id)) ||\n\t    (dev->ifalias &&\n\t     nla_put_string(skb, IFLA_IFALIAS, dev->ifalias)))\n\t\tgoto nla_put_failure;\n\n\tif (1) {\n\t\tstruct rtnl_link_ifmap map = {\n\t\t\t.mem_start   = dev->mem_start,\n\t\t\t.mem_end     = dev->mem_end,\n\t\t\t.base_addr   = dev->base_addr,\n\t\t\t.irq         = dev->irq,\n\t\t\t.dma         = dev->dma,\n\t\t\t.port        = dev->if_port,\n\t\t};\n\t\tif (nla_put(skb, IFLA_MAP, sizeof(map), &map))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (dev->addr_len) {\n\t\tif (nla_put(skb, IFLA_ADDRESS, dev->addr_len, dev->dev_addr) ||\n\t\t    nla_put(skb, IFLA_BROADCAST, dev->addr_len, dev->broadcast))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tattr = nla_reserve(skb, IFLA_STATS,\n\t\t\tsizeof(struct rtnl_link_stats));\n\tif (attr == NULL)\n\t\tgoto nla_put_failure;\n\n\tstats = dev_get_stats(dev, &temp);\n\tcopy_rtnl_link_stats(nla_data(attr), stats);\n\n\tattr = nla_reserve(skb, IFLA_STATS64,\n\t\t\tsizeof(struct rtnl_link_stats64));\n\tif (attr == NULL)\n\t\tgoto nla_put_failure;\n\tcopy_rtnl_link_stats64(nla_data(attr), stats);\n\n\tif (dev->dev.parent && (ext_filter_mask & RTEXT_FILTER_VF) &&\n\t    nla_put_u32(skb, IFLA_NUM_VF, dev_num_vf(dev->dev.parent)))\n\t\tgoto nla_put_failure;\n\n\tif (dev->netdev_ops->ndo_get_vf_config && dev->dev.parent\n\t    && (ext_filter_mask & RTEXT_FILTER_VF)) {\n\t\tint i;\n\n\t\tstruct nlattr *vfinfo, *vf;\n\t\tint num_vfs = dev_num_vf(dev->dev.parent);\n\n\t\tvfinfo = nla_nest_start(skb, IFLA_VFINFO_LIST);\n\t\tif (!vfinfo)\n\t\t\tgoto nla_put_failure;\n\t\tfor (i = 0; i < num_vfs; i++) {\n\t\t\tstruct ifla_vf_info ivi;\n\t\t\tstruct ifla_vf_mac vf_mac;\n\t\t\tstruct ifla_vf_vlan vf_vlan;\n\t\t\tstruct ifla_vf_tx_rate vf_tx_rate;\n\t\t\tstruct ifla_vf_spoofchk vf_spoofchk;\n\n\t\t\t/*\n\t\t\t * Not all SR-IOV capable drivers support the\n\t\t\t * spoofcheck query.  Preset to -1 so the user\n\t\t\t * space tool can detect that the driver didn't\n \t\t\t * report anything.\n \t\t\t */\n \t\t\tivi.spoofchk = -1;\n \t\t\tif (dev->netdev_ops->ndo_get_vf_config(dev, i, &ivi))\n \t\t\t\tbreak;\n \t\t\tvf_mac.vf =\n\t\t\t\tvf_vlan.vf =\n\t\t\t\tvf_tx_rate.vf =\n\t\t\t\tvf_spoofchk.vf = ivi.vf;\n\n\t\t\tmemcpy(vf_mac.mac, ivi.mac, sizeof(ivi.mac));\n\t\t\tvf_vlan.vlan = ivi.vlan;\n\t\t\tvf_vlan.qos = ivi.qos;\n\t\t\tvf_tx_rate.rate = ivi.tx_rate;\n\t\t\tvf_spoofchk.setting = ivi.spoofchk;\n\t\t\tvf = nla_nest_start(skb, IFLA_VF_INFO);\n\t\t\tif (!vf) {\n\t\t\t\tnla_nest_cancel(skb, vfinfo);\n\t\t\t\tgoto nla_put_failure;\n\t\t\t}\n\t\t\tif (nla_put(skb, IFLA_VF_MAC, sizeof(vf_mac), &vf_mac) ||\n\t\t\t    nla_put(skb, IFLA_VF_VLAN, sizeof(vf_vlan), &vf_vlan) ||\n\t\t\t    nla_put(skb, IFLA_VF_TX_RATE, sizeof(vf_tx_rate),\n\t\t\t\t    &vf_tx_rate) ||\n\t\t\t    nla_put(skb, IFLA_VF_SPOOFCHK, sizeof(vf_spoofchk),\n\t\t\t\t    &vf_spoofchk))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tnla_nest_end(skb, vf);\n\t\t}\n\t\tnla_nest_end(skb, vfinfo);\n\t}\n\n\tif (rtnl_port_fill(skb, dev))\n\t\tgoto nla_put_failure;\n\n\tif (dev->rtnl_link_ops) {\n\t\tif (rtnl_link_fill(skb, dev) < 0)\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (!(af_spec = nla_nest_start(skb, IFLA_AF_SPEC)))\n\t\tgoto nla_put_failure;\n\n\tlist_for_each_entry(af_ops, &rtnl_af_ops, list) {\n\t\tif (af_ops->fill_link_af) {\n\t\t\tstruct nlattr *af;\n\t\t\tint err;\n\n\t\t\tif (!(af = nla_nest_start(skb, af_ops->family)))\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\terr = af_ops->fill_link_af(skb, dev);\n\n\t\t\t/*\n\t\t\t * Caller may return ENODATA to indicate that there\n\t\t\t * was no data to be dumped. This is not an error, it\n\t\t\t * means we should trim the attribute header and\n\t\t\t * continue.\n\t\t\t */\n\t\t\tif (err == -ENODATA)\n\t\t\t\tnla_nest_cancel(skb, af);\n\t\t\telse if (err < 0)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tnla_nest_end(skb, af);\n\t\t}\n\t}\n\n\tnla_nest_end(skb, af_spec);\n\n\treturn nlmsg_end(skb, nlh);\n\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n", "target": 1, "idx": 179228}
{"func": "RenderProcessHost* RenderFrameHostImpl::GetProcess() {\n  return process_;\n}\n", "target": 0, "idx": 138696}
{"func": "error::Error GLES2DecoderPassthroughImpl::DoClearColor(GLclampf red,\n                                                       GLclampf green,\n                                                       GLclampf blue,\n                                                       GLclampf alpha) {\n  api()->glClearColorFn(red, green, blue, alpha);\n  return error::kNoError;\n}\n", "target": 0, "idx": 154589}
{"func": "DOMFileSystemSync* WorkerGlobalScopeFileSystem::webkitRequestFileSystemSync(WorkerGlobalScope& worker, int type, long long size, ExceptionState& exceptionState)\n{\n    ExecutionContext* secureContext = worker.executionContext();\n    if (!secureContext->securityOrigin()->canAccessFileSystem()) {\n        exceptionState.throwSecurityError(FileError::securityErrorMessage);\n        return 0;\n    }\n\n    FileSystemType fileSystemType = static_cast<FileSystemType>(type);\n    if (!DOMFileSystemBase::isValidType(fileSystemType)) {\n        exceptionState.throwDOMException(InvalidModificationError, \"the type must be TEMPORARY or PERSISTENT.\");\n         return 0;\n     }\n \n    RefPtr<FileSystemSyncCallbackHelper> helper = FileSystemSyncCallbackHelper::create();\n     OwnPtr<AsyncFileSystemCallbacks> callbacks = FileSystemCallbacks::create(helper->successCallback(), helper->errorCallback(), &worker, fileSystemType);\n     callbacks->setShouldBlockUntilCompletion(true);\n \n    LocalFileSystem::from(worker)->requestFileSystem(&worker, fileSystemType, size, callbacks.release());\n    return helper->getResult(exceptionState);\n}\n", "target": 1, "idx": 185130}
{"func": "int AXObject::lineForPosition(const VisiblePosition& position) const {\n  if (position.isNull() || !getNode())\n    return -1;\n\n  Node* containerNode = position.deepEquivalent().computeContainerNode();\n  if (!containerNode->isShadowIncludingInclusiveAncestorOf(getNode()) &&\n      !getNode()->isShadowIncludingInclusiveAncestorOf(containerNode))\n    return -1;\n\n  int lineCount = -1;\n  VisiblePosition currentPosition = position;\n  VisiblePosition previousPosition;\n\n  do {\n    previousPosition = currentPosition;\n    currentPosition =\n        previousLinePosition(currentPosition, LayoutUnit(), HasEditableAXRole);\n    ++lineCount;\n  } while (currentPosition.isNotNull() &&\n           !inSameLine(currentPosition, previousPosition));\n\n  return lineCount;\n}\n", "target": 0, "idx": 138182}
{"func": "static void scsi_write_complete(void * opaque, int ret)\n {\n     SCSIDiskReq *r = (SCSIDiskReq *)opaque;\n     SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    uint32_t len;\n     uint32_t n;\n \n     if (r->req.aiocb != NULL) {\n        r->req.aiocb = NULL;\n        bdrv_acct_done(s->bs, &r->acct);\n    }\n\n    if (ret) {\n        if (scsi_handle_rw_error(r, -ret, SCSI_REQ_STATUS_RETRY_WRITE)) {\n            return;\n         }\n     }\n \n    n = r->iov.iov_len / 512;\n     r->sector += n;\n     r->sector_count -= n;\n     if (r->sector_count == 0) {\n         scsi_req_complete(&r->req, GOOD);\n     } else {\n        len = r->sector_count * 512;\n        if (len > SCSI_DMA_BUF_SIZE) {\n            len = SCSI_DMA_BUF_SIZE;\n        }\n        r->iov.iov_len = len;\n        DPRINTF(\"Write complete tag=0x%x more=%d\\n\", r->req.tag, len);\n        scsi_req_data(&r->req, len);\n     }\n }\n", "target": 1, "idx": 183094}
{"func": "ShellWindow::ShellWindow(Profile* profile,\n                         const extensions::Extension* extension,\n                         const GURL& url)\n    : profile_(profile),\n      extension_(extension),\n      ALLOW_THIS_IN_INITIALIZER_LIST(\n          extension_function_dispatcher_(profile, this)) {\n  web_contents_ = WebContents::Create(\n      profile, SiteInstance::CreateForURL(profile, url), MSG_ROUTING_NONE, NULL,\n      NULL);\n  contents_.reset(new TabContents(web_contents_));\n  content::WebContentsObserver::Observe(web_contents_);\n  web_contents_->SetDelegate(this);\n  chrome::SetViewType(web_contents_, chrome::VIEW_TYPE_APP_SHELL);\n  web_contents_->GetMutableRendererPrefs()->\n       browser_handles_all_top_level_requests = true;\n   web_contents_->GetRenderViewHost()->SyncRendererPrefs();\n \n   web_contents_->GetController().LoadURL(\n       url, content::Referrer(), content::PAGE_TRANSITION_LINK,\n       std::string());\n   registrar_.Add(this, chrome::NOTIFICATION_EXTENSION_UNLOADED,\n                  content::Source<Profile>(profile_));\n  registrar_.Add(this, content::NOTIFICATION_APP_TERMINATING,\n                 content::NotificationService::AllSources());\n\n  TabContents* tab_contents = TabContents::FromWebContents(web_contents_);\n  InfoBarTabHelper* infobar_helper = tab_contents->infobar_tab_helper();\n  infobar_helper->set_infobars_enabled(false);\n\n  browser::StartKeepAlive();\n}\n", "target": 1, "idx": 184388}
{"func": "void AcceleratedStaticBitmapImage::Draw(cc::PaintCanvas* canvas,\n                                        const cc::PaintFlags& flags,\n                                        const FloatRect& dst_rect,\n                                        const FloatRect& src_rect,\n                                         RespectImageOrientationEnum,\n                                         ImageClampingMode image_clamping_mode,\n                                         ImageDecodingMode decode_mode) {\n   auto paint_image = PaintImageForCurrentFrame();\n   if (!paint_image)\n     return;\n  auto paint_image_decoding_mode = ToPaintImageDecodingMode(decode_mode);\n  if (paint_image.decoding_mode() != paint_image_decoding_mode) {\n    paint_image = PaintImageBuilder::WithCopy(std::move(paint_image))\n                      .set_decoding_mode(paint_image_decoding_mode)\n                      .TakePaintImage();\n  }\n  StaticBitmapImage::DrawHelper(canvas, flags, dst_rect, src_rect,\n                                image_clamping_mode, paint_image);\n}\n", "target": 1, "idx": 186570}
{"func": "  void TestFocusTraversal(RenderViewHost* render_view_host, bool reverse) {\n    const char kGetFocusedElementJS[] =\n        \"window.domAutomationController.send(getFocusedElement());\";\n    const char* kExpectedIDs[] = { \"textEdit\", \"searchButton\", \"luckyButton\",\n                                   \"googleLink\", \"gmailLink\", \"gmapLink\" };\n    SCOPED_TRACE(base::StringPrintf(\"TestFocusTraversal: reverse=%d\", reverse));\n    ui::KeyboardCode key = ui::VKEY_TAB;\n#if defined(OS_MACOSX)\n    key = reverse ? ui::VKEY_BACKTAB : ui::VKEY_TAB;\n#elif defined(OS_WIN)\n    if (base::win::GetVersion() < base::win::VERSION_VISTA)\n      return;\n#endif\n\n    for (size_t i = 0; i < 2; ++i) {\n      SCOPED_TRACE(base::StringPrintf(\"focus outer loop: %\" PRIuS, i));\n      ASSERT_TRUE(IsViewFocused(VIEW_ID_OMNIBOX));\n\n#if defined(OS_MACOSX)\n      if (ui_controls::IsFullKeyboardAccessEnabled()) {\n        ASSERT_TRUE(ui_test_utils::SendKeyPressSync(\n            browser(), key, false, reverse, false, false));\n        if (reverse) {\n          for (int j = 0; j < 3; ++j) {\n            ASSERT_TRUE(ui_test_utils::SendKeyPressSync(\n                browser(), key, false, reverse, false, false));\n          }\n        }\n      }\n#endif\n\n      if (reverse) {\n        ASSERT_TRUE(ui_test_utils::SendKeyPressAndWait(\n            browser(), key, false, reverse, false, false,\n            content::NOTIFICATION_ALL,\n            content::NotificationService::AllSources()));\n      }\n\n      for (size_t j = 0; j < arraysize(kExpectedIDs); ++j) {\n        SCOPED_TRACE(base::StringPrintf(\"focus inner loop %\" PRIuS, j));\n        const size_t index = reverse ? arraysize(kExpectedIDs) - 1 - j : j;\n        bool is_editable_node = index == 0;\n\n        ASSERT_TRUE(ui_test_utils::SendKeyPressAndWaitWithDetails(\n            browser(), key, false, reverse, false, false,\n            content::NOTIFICATION_FOCUS_CHANGED_IN_PAGE,\n            content::Source<RenderViewHost>(render_view_host),\n            content::Details<bool>(&is_editable_node)));\n        std::string focused_id;\n        EXPECT_TRUE(content::ExecuteScriptAndExtractString(\n            render_view_host, kGetFocusedElementJS, &focused_id));\n        EXPECT_STREQ(kExpectedIDs[index], focused_id.c_str());\n      }\n\n#if defined(OS_MACOSX)\n      chrome::FocusLocationBar(browser());\n#else\n      ASSERT_TRUE(ui_test_utils::SendKeyPressAndWait(\n          browser(), key, false, reverse, false, false,\n          chrome::NOTIFICATION_FOCUS_RETURNED_TO_BROWSER,\n          content::Source<Browser>(browser())));\n      EXPECT_TRUE(\n          IsViewFocused(reverse ? VIEW_ID_OMNIBOX : VIEW_ID_LOCATION_ICON));\n\n      ASSERT_TRUE(ui_test_utils::SendKeyPressAndWait(\n          browser(), key, false, reverse, false, false,\n          content::NOTIFICATION_ALL,\n          content::NotificationService::AllSources()));\n#endif\n      content::RunAllPendingInMessageLoop();\n      EXPECT_TRUE(\n          IsViewFocused(reverse ? VIEW_ID_LOCATION_ICON : VIEW_ID_OMNIBOX));\n      if (reverse) {\n        ASSERT_TRUE(ui_test_utils::SendKeyPressAndWait(\n            browser(), key, false, false, false, false,\n            content::NOTIFICATION_ALL,\n            content::NotificationService::AllSources()));\n      }\n    }\n  }\n", "target": 0, "idx": 151775}
{"func": "bool isIDString(const char *s) {\n  if (!isAlpha(*s))\n    return false;\n  while (*s) {\n    if (!(isAlpha(*s) || isNumeric(*s)))\n      return false;\n    s++;\n  }\n  return true;\n}\n", "target": 0, "idx": 82608}
{"func": "GDataFileSystem::GetFileFromCacheParams::GetFileFromCacheParams(\n    const FilePath& virtual_file_path,\n    const FilePath& local_tmp_path,\n    const GURL& content_url,\n    const std::string& resource_id,\n    const std::string& md5,\n    const std::string& mime_type,\n    const GetFileCallback& get_file_callback,\n    const GetDownloadDataCallback& get_download_data_callback)\n    : virtual_file_path(virtual_file_path),\n      local_tmp_path(local_tmp_path),\n      content_url(content_url),\n      resource_id(resource_id),\n      md5(md5),\n      mime_type(mime_type),\n      get_file_callback(get_file_callback),\n      get_download_data_callback(get_download_data_callback) {\n}\n", "target": 0, "idx": 125373}
{"func": "static int ovl_create_object(struct dentry *dentry, int mode, dev_t rdev,\n\t\t\t     const char *link)\n{\n\tint err;\n\n\terr = ovl_want_write(dentry);\n\tif (!err) {\n\t\terr = ovl_create_or_link(dentry, mode, rdev, link, NULL);\n\t\tovl_drop_write(dentry);\n\t}\n\n\treturn err;\n}\n", "target": 0, "idx": 51055}
{"func": "GF_Box *nump_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_NUMPBox, GF_ISOM_BOX_TYPE_NUMP);\n\treturn (GF_Box *)tmp;\n}\n", "target": 0, "idx": 80296}
{"func": "static StkId callrethooks (lua_State *L, StkId firstResult) {\n  ptrdiff_t fr = savestack(L, firstResult);  /* next call may change stack */\n  luaD_callhook(L, LUA_HOOKRET, -1);\n  if (f_isLua(L->ci)) {  /* Lua function? */\n    while ((L->hookmask & LUA_MASKRET) && L->ci->tailcalls--) /* tail calls */\n      luaD_callhook(L, LUA_HOOKTAILRET, -1);\n  }\n  return restorestack(L, fr);\n}\n", "target": 0, "idx": 43041}
{"func": " void ahci_uninit(AHCIState *s)\n {\n     g_free(s->dev);\n }\n", "target": 1, "idx": 177969}
{"func": "int main(int argc, char** argv)\n{\n    /* Kernel starts us with all fd's closed.\n     * But it's dangerous:\n     * fprintf(stderr) can dump messages into random fds, etc.\n     * Ensure that if any of fd 0,1,2 is closed, we open it to /dev/null.\n     */\n    int fd = xopen(\"/dev/null\", O_RDWR);\n    while (fd < 2)\n        fd = xdup(fd);\n    if (fd > 2)\n        close(fd);\n\n    int err = 1;\n    logmode = LOGMODE_JOURNAL;\n\n    /* Parse abrt.conf */\n    load_abrt_conf();\n    /* ... and plugins/CCpp.conf */\n    bool setting_MakeCompatCore;\n    bool setting_SaveBinaryImage;\n    bool setting_SaveFullCore;\n    bool setting_CreateCoreBacktrace;\n    bool setting_SaveContainerizedPackageData;\n    bool setting_StandaloneHook;\n    {\n        map_string_t *settings = new_map_string();\n        load_abrt_plugin_conf_file(\"CCpp.conf\", settings);\n        const char *value;\n        value = get_map_string_item_or_NULL(settings, \"MakeCompatCore\");\n        setting_MakeCompatCore = value && string_to_bool(value);\n        value = get_map_string_item_or_NULL(settings, \"SaveBinaryImage\");\n        setting_SaveBinaryImage = value && string_to_bool(value);\n        value = get_map_string_item_or_NULL(settings, \"SaveFullCore\");\n        setting_SaveFullCore = value ? string_to_bool(value) : true;\n        value = get_map_string_item_or_NULL(settings, \"CreateCoreBacktrace\");\n        setting_CreateCoreBacktrace = value ? string_to_bool(value) : true;\n\n        value = get_map_string_item_or_NULL(settings, \"SaveContainerizedPackageData\");\n        setting_SaveContainerizedPackageData = value && string_to_bool(value);\n\n        /* Do not call abrt-action-save-package-data with process's root, if ExploreChroots is disabled. */\n        if (!g_settings_explorechroots)\n        {\n            if (setting_SaveContainerizedPackageData)\n                log_warning(\"Ignoring SaveContainerizedPackageData because ExploreChroots is disabled\");\n            setting_SaveContainerizedPackageData = false;\n        }\n\n        value = get_map_string_item_or_NULL(settings, \"StandaloneHook\");\n        setting_StandaloneHook = value && string_to_bool(value);\n        value = get_map_string_item_or_NULL(settings, \"VerboseLog\");\n        if (value)\n            g_verbose = xatoi_positive(value);\n        free_map_string(settings);\n    }\n\n    if (argc == 2 && strcmp(argv[1], \"--config-test\"))\n        return test_configuration(setting_SaveFullCore, setting_CreateCoreBacktrace);\n\n    if (argc < 8)\n    {\n        /* percent specifier:         %s   %c              %p  %u  %g  %t   %e          %P         %i*/\n        /* argv:                  [0] [1]  [2]             [3] [4] [5] [6]  [7]         [8]        [9]*/\n        error_msg_and_die(\"Usage: %s SIGNO CORE_SIZE_LIMIT PID UID GID TIME BINARY_NAME GLOBAL_PID [TID]\", argv[0]);\n    }\n\n    /* Not needed on 2.6.30.\n     * At least 2.6.18 has a bug where\n     * argv[1] = \"SIGNO CORE_SIZE_LIMIT PID ...\"\n     * argv[2] = \"CORE_SIZE_LIMIT PID ...\"\n     * and so on. Fixing it:\n     */\n    if (strchr(argv[1], ' '))\n    {\n        int i;\n        for (i = 1; argv[i]; i++)\n        {\n            strchrnul(argv[i], ' ')[0] = '\\0';\n        }\n    }\n\n    errno = 0;\n    const char* signal_str = argv[1];\n    int signal_no = xatoi_positive(signal_str);\n    off_t ulimit_c = strtoull(argv[2], NULL, 10);\n    if (ulimit_c < 0) /* unlimited? */\n    {\n        /* set to max possible >0 value */\n        ulimit_c = ~((off_t)1 << (sizeof(off_t)*8-1));\n    }\n    const char *pid_str = argv[3];\n    pid_t local_pid = xatoi_positive(argv[3]);\n    uid_t uid = xatoi_positive(argv[4]);\n    if (errno || local_pid <= 0)\n    {\n        perror_msg_and_die(\"PID '%s' or limit '%s' is bogus\", argv[3], argv[2]);\n    }\n\n    {\n        char *s = xmalloc_fopen_fgetline_fclose(VAR_RUN\"/abrt/saved_core_pattern\");\n        /* If we have a saved pattern and it's not a \"|PROG ARGS\" thing... */\n        if (s && s[0] != '|')\n            core_basename = s;\n        else\n            free(s);\n    }\n    const char *global_pid_str = argv[8];\n    pid_t pid = xatoi_positive(argv[8]);\n\n    pid_t tid = -1;\n    const char *tid_str = argv[9];\n    if (tid_str)\n    {\n        tid = xatoi_positive(tid_str);\n    }\n\n    char path[PATH_MAX];\n\n    char *executable = get_executable(pid);\n    if (executable && strstr(executable, \"/abrt-hook-ccpp\"))\n    {\n        error_msg_and_die(\"PID %lu is '%s', not dumping it to avoid recursion\",\n                        (long)pid, executable);\n    }\n\n    user_pwd = get_cwd(pid); /* may be NULL on error */\n    log_notice(\"user_pwd:'%s'\", user_pwd);\n\n    sprintf(path, \"/proc/%lu/status\", (long)pid);\n    char *proc_pid_status = xmalloc_xopen_read_close(path, /*maxsz:*/ NULL);\n\n    uid_t fsuid = uid;\n    uid_t tmp_fsuid = get_fsuid(proc_pid_status);\n    if (tmp_fsuid < 0)\n        perror_msg_and_die(\"Can't parse 'Uid: line' in /proc/%lu/status\", (long)pid);\n\n    const int fsgid = get_fsgid(proc_pid_status);\n    if (fsgid < 0)\n        error_msg_and_die(\"Can't parse 'Gid: line' in /proc/%lu/status\", (long)pid);\n\n    int suid_policy = dump_suid_policy();\n    if (tmp_fsuid != uid)\n    {\n        /* use root for suided apps unless it's explicitly set to UNSAFE */\n        fsuid = 0;\n        if (suid_policy == DUMP_SUID_UNSAFE)\n            fsuid = tmp_fsuid;\n        else\n        {\n            g_user_core_flags = O_EXCL;\n            g_need_nonrelative = 1;\n        }\n    }\n\n    /* Open a fd to compat coredump, if requested and is possible */\n    int user_core_fd = -1;\n    if (setting_MakeCompatCore && ulimit_c != 0)\n        /* note: checks \"user_pwd == NULL\" inside; updates core_basename */\n        user_core_fd = open_user_core(uid, fsuid, fsgid, pid, &argv[1]);\n\n    if (executable == NULL)\n    {\n        /* readlink on /proc/$PID/exe failed, don't create abrt dump dir */\n        error_msg(\"Can't read /proc/%lu/exe link\", (long)pid);\n        return create_user_core(user_core_fd, pid, ulimit_c);\n    }\n\n    const char *signame = NULL;\n    if (!signal_is_fatal(signal_no, &signame))\n        return create_user_core(user_core_fd, pid, ulimit_c); // not a signal we care about\n\n    const int abrtd_running = daemon_is_ok();\n    if (!setting_StandaloneHook && !abrtd_running)\n    {\n        /* not an error, exit with exit code 0 */\n        log(\"abrtd is not running. If it crashed, \"\n            \"/proc/sys/kernel/core_pattern contains a stale value, \"\n            \"consider resetting it to 'core'\"\n        );\n        return create_user_core(user_core_fd, pid, ulimit_c);\n    }\n\n    if (setting_StandaloneHook)\n        ensure_writable_dir(g_settings_dump_location, DEFAULT_DUMP_LOCATION_MODE, \"abrt\");\n\n    if (g_settings_nMaxCrashReportsSize > 0)\n    {\n        /* If free space is less than 1/4 of MaxCrashReportsSize... */\n        if (low_free_space(g_settings_nMaxCrashReportsSize, g_settings_dump_location))\n            return create_user_core(user_core_fd, pid, ulimit_c);\n    }\n\n    /* Check /var/tmp/abrt/last-ccpp marker, do not dump repeated crashes\n     * if they happen too often. Else, write new marker value.\n     */\n    snprintf(path, sizeof(path), \"%s/last-ccpp\", g_settings_dump_location);\n    if (check_recent_crash_file(path, executable))\n    {\n        /* It is a repeating crash */\n        return create_user_core(user_core_fd, pid, ulimit_c);\n    }\n\n    const char *last_slash = strrchr(executable, '/');\n    if (last_slash && strncmp(++last_slash, \"abrt\", 4) == 0)\n    {\n        if (g_settings_debug_level == 0)\n        {\n            log_warning(\"Ignoring crash of %s (SIG%s).\",\n                        executable, signame ? signame : signal_str);\n            goto cleanup_and_exit;\n        }\n\n        /* If abrtd/abrt-foo crashes, we don't want to create a _directory_,\n         * since that can make new copy of abrtd to process it,\n         * and maybe crash again...\n         * Unlike dirs, mere files are ignored by abrtd.\n         */\n         if (snprintf(path, sizeof(path), \"%s/%s-coredump\", g_settings_dump_location, last_slash) >= sizeof(path))\n             error_msg_and_die(\"Error saving '%s': truncated long file path\", path);\n \n        int abrt_core_fd = xopen3(path, O_WRONLY | O_CREAT | O_TRUNC, 0600);\n         off_t core_size = copyfd_eof(STDIN_FILENO, abrt_core_fd, COPYFD_SPARSE);\n         if (core_size < 0 || fsync(abrt_core_fd) != 0)\n         {\n            unlink(path);\n            /* copyfd_eof logs the error including errno string,\n             * but it does not log file name */\n            error_msg_and_die(\"Error saving '%s'\", path);\n        }\n        log_notice(\"Saved core dump of pid %lu (%s) to %s (%llu bytes)\", (long)pid, executable, path, (long long)core_size);\n        err = 0;\n        goto cleanup_and_exit;\n    }\n\n    unsigned path_len = snprintf(path, sizeof(path), \"%s/ccpp-%s-%lu.new\",\n            g_settings_dump_location, iso_date_string(NULL), (long)pid);\n    if (path_len >= (sizeof(path) - sizeof(\"/\"FILENAME_COREDUMP)))\n    {\n        return create_user_core(user_core_fd, pid, ulimit_c);\n    }\n\n    /* If you don't want to have fs owner as root then:\n     *\n     * - use fsuid instead of uid for fs owner, so we don't expose any\n     *   sensitive information of suided app in /var/(tmp|spool)/abrt\n     *\n     * - use dd_create_skeleton() and dd_reset_ownership(), when you finish\n     *   creating the new dump directory, to prevent the real owner to write to\n     *   the directory until the hook is done (avoid race conditions and defend\n     *   hard and symbolic link attacs)\n     */\n    dd = dd_create(path, /*fs owner*/0, DEFAULT_DUMP_DIR_MODE);\n    if (dd)\n    {\n        char source_filename[sizeof(\"/proc/%lu/somewhat_long_name\") + sizeof(long)*3];\n        int source_base_ofs = sprintf(source_filename, \"/proc/%lu/root\", (long)pid);\n        source_base_ofs -= strlen(\"root\");\n\n        /* What's wrong on using /proc/[pid]/root every time ?*/\n        /* It creates os_info_in_root_dir for all crashes. */\n        char *rootdir = process_has_own_root(pid) ? get_rootdir(pid) : NULL;\n\n        /* Reading data from an arbitrary root directory is not secure. */\n        if (g_settings_explorechroots)\n        {\n            /* Yes, test 'rootdir' but use 'source_filename' because 'rootdir' can\n             * be '/' for a process with own namespace. 'source_filename' is /proc/[pid]/root. */\n            dd_create_basic_files(dd, fsuid, (rootdir != NULL) ? source_filename : NULL);\n        }\n        else\n        {\n            dd_create_basic_files(dd, fsuid, NULL);\n        }\n\n        char *dest_filename = concat_path_file(dd->dd_dirname, \"also_somewhat_longish_name\");\n        char *dest_base = strrchr(dest_filename, '/') + 1;\n\n\n        strcpy(source_filename + source_base_ofs, \"maps\");\n        dd_copy_file(dd, FILENAME_MAPS, source_filename);\n\n        strcpy(source_filename + source_base_ofs, \"limits\");\n        dd_copy_file(dd, FILENAME_LIMITS, source_filename);\n\n        strcpy(source_filename + source_base_ofs, \"cgroup\");\n        dd_copy_file(dd, FILENAME_CGROUP, source_filename);\n\n        strcpy(source_filename + source_base_ofs, \"mountinfo\");\n        dd_copy_file(dd, FILENAME_MOUNTINFO, source_filename);\n\n        strcpy(dest_base, FILENAME_OPEN_FDS);\n        strcpy(source_filename + source_base_ofs, \"fd\");\n        dump_fd_info_ext(dest_filename, source_filename, dd->dd_uid, dd->dd_gid);\n\n        strcpy(dest_base, FILENAME_NAMESPACES);\n        dump_namespace_diff_ext(dest_filename, 1, pid, dd->dd_uid, dd->dd_gid);\n\n        free(dest_filename);\n\n        char *tmp = NULL;\n        get_env_variable(pid, \"container\", &tmp);\n        if (tmp != NULL)\n        {\n            dd_save_text(dd, FILENAME_CONTAINER, tmp);\n            free(tmp);\n            tmp = NULL;\n        }\n\n        get_env_variable(pid, \"container_uuid\", &tmp);\n        if (tmp != NULL)\n        {\n            dd_save_text(dd, FILENAME_CONTAINER_UUID, tmp);\n            free(tmp);\n        }\n\n        /* There's no need to compare mount namespaces and search for '/' in\n         * mountifo.  Comparison of inodes of '/proc/[pid]/root' and '/' works\n         * fine. If those inodes do not equal each other, we have to verify\n         * that '/proc/[pid]/root' is not a symlink to a chroot.\n         */\n        const int containerized = (rootdir != NULL && strcmp(rootdir, \"/\") == 0);\n        if (containerized)\n        {\n            log_debug(\"Process %d is considered to be containerized\", pid);\n            pid_t container_pid;\n            if (get_pid_of_container(pid, &container_pid) == 0)\n            {\n                char *container_cmdline = get_cmdline(container_pid);\n                dd_save_text(dd, FILENAME_CONTAINER_CMDLINE, container_cmdline);\n                free(container_cmdline);\n            }\n        }\n\n        dd_save_text(dd, FILENAME_ANALYZER, \"abrt-ccpp\");\n        dd_save_text(dd, FILENAME_TYPE, \"CCpp\");\n        dd_save_text(dd, FILENAME_EXECUTABLE, executable);\n        dd_save_text(dd, FILENAME_PID, pid_str);\n        dd_save_text(dd, FILENAME_GLOBAL_PID, global_pid_str);\n        dd_save_text(dd, FILENAME_PROC_PID_STATUS, proc_pid_status);\n        if (user_pwd)\n            dd_save_text(dd, FILENAME_PWD, user_pwd);\n        if (tid_str)\n            dd_save_text(dd, FILENAME_TID, tid_str);\n\n        if (rootdir)\n        {\n            if (strcmp(rootdir, \"/\") != 0)\n                dd_save_text(dd, FILENAME_ROOTDIR, rootdir);\n        }\n        free(rootdir);\n\n        char *reason = xasprintf(\"%s killed by SIG%s\",\n                                 last_slash, signame ? signame : signal_str);\n        dd_save_text(dd, FILENAME_REASON, reason);\n        free(reason);\n\n        char *cmdline = get_cmdline(pid);\n        dd_save_text(dd, FILENAME_CMDLINE, cmdline ? : \"\");\n        free(cmdline);\n\n        char *environ = get_environ(pid);\n        dd_save_text(dd, FILENAME_ENVIRON, environ ? : \"\");\n        free(environ);\n\n        char *fips_enabled = xmalloc_fopen_fgetline_fclose(\"/proc/sys/crypto/fips_enabled\");\n        if (fips_enabled)\n        {\n            if (strcmp(fips_enabled, \"0\") != 0)\n                dd_save_text(dd, \"fips_enabled\", fips_enabled);\n            free(fips_enabled);\n        }\n\n        dd_save_text(dd, FILENAME_ABRT_VERSION, VERSION);\n\n        /* In case of errors, treat the process as if it has locked memory */\n        long unsigned lck_bytes = ULONG_MAX;\n        const char *vmlck = strstr(proc_pid_status, \"VmLck:\");\n        if (vmlck == NULL)\n            error_msg(\"/proc/%s/status does not contain 'VmLck:' line\", pid_str);\n        else if (1 != sscanf(vmlck + 6, \"%lu kB\\n\", &lck_bytes))\n            error_msg(\"Failed to parse 'VmLck:' line in /proc/%s/status\", pid_str);\n\n        if (lck_bytes)\n        {\n            log_notice(\"Process %s of user %lu has locked memory\",\n                        pid_str, (long unsigned)uid);\n\n            dd_mark_as_notreportable(dd, \"The process had locked memory \"\n                    \"which usually indicates efforts to protect sensitive \"\n                    \"data (passwords) from being written to disk.\\n\"\n                    \"In order to avoid sensitive information leakages, \"\n                    \"ABRT will not allow you to report this problem to \"\n                    \"bug tracking tools\");\n        }\n\n        if (setting_SaveBinaryImage)\n        {\n            if (save_crashing_binary(pid, dd))\n            {\n                error_msg(\"Error saving '%s'\", path);\n\n                goto cleanup_and_exit;\n            }\n        }\n\n        off_t core_size = 0;\n        if (setting_SaveFullCore)\n        {\n            strcpy(path + path_len, \"/\"FILENAME_COREDUMP);\n            int abrt_core_fd = create_or_die(path, user_core_fd);\n\n            /* We write both coredumps at once.\n             * We can't write user coredump first, since it might be truncated\n             * and thus can't be copied and used as abrt coredump;\n             * and if we write abrt coredump first and then copy it as user one,\n             * then we have a race when process exits but coredump does not exist yet:\n             * $ echo -e '#include<signal.h>\\nmain(){raise(SIGSEGV);}' | gcc -o test -x c -\n             * $ rm -f core*; ulimit -c unlimited; ./test; ls -l core*\n             * 21631 Segmentation fault (core dumped) ./test\n             * ls: cannot access core*: No such file or directory <=== BAD\n             */\n            core_size = copyfd_sparse(STDIN_FILENO, abrt_core_fd, user_core_fd, ulimit_c);\n            close_user_core(user_core_fd, core_size);\n            if (fsync(abrt_core_fd) != 0 || close(abrt_core_fd) != 0 || core_size < 0)\n            {\n                unlink(path);\n\n                /* copyfd_sparse logs the error including errno string,\n                 * but it does not log file name */\n                error_msg(\"Error writing '%s'\", path);\n\n                goto cleanup_and_exit;\n            }\n        }\n        else\n        {\n            /* User core is created even if WriteFullCore is off. */\n            create_user_core(user_core_fd, pid, ulimit_c);\n        }\n\n        /* User core is either written or closed */\n        user_core_fd = -1;\n\n        /*\n         * ! No other errors should cause removal of the user core !\n         */\n\n/* Because of #1211835 and #1126850 */\n#if 0\n        /* Save JVM crash log if it exists. (JVM's coredump per se\n         * is nearly useless for JVM developers)\n         */\n        {\n            char *java_log = xasprintf(\"/tmp/jvm-%lu/hs_error.log\", (long)pid);\n            int src_fd = open(java_log, O_RDONLY);\n            free(java_log);\n\n            /* If we couldn't open the error log in /tmp directory we can try to\n             * read the log from the current directory. It may produce AVC, it\n             * may produce some error log but all these are expected.\n             */\n            if (src_fd < 0)\n            {\n                java_log = xasprintf(\"%s/hs_err_pid%lu.log\", user_pwd, (long)pid);\n                src_fd = open(java_log, O_RDONLY);\n                free(java_log);\n            }\n\n            if (src_fd >= 0)\n            {\n                strcpy(path + path_len, \"/hs_err.log\");\n                int dst_fd = create_or_die(path, user_core_fd);\n                off_t sz = copyfd_eof(src_fd, dst_fd, COPYFD_SPARSE);\n                if (close(dst_fd) != 0 || sz < 0)\n                {\n                    error_msg(\"Error saving '%s'\", path);\n\n                    goto cleanup_and_exit;\n                }\n                close(src_fd);\n            }\n        }\n#endif\n\n        /* Perform crash-time unwind of the guilty thread. */\n        if (tid > 0 && setting_CreateCoreBacktrace)\n            create_core_backtrace(tid, executable, signal_no, dd);\n\n        /* We close dumpdir before we start catering for crash storm case.\n         * Otherwise, delete_dump_dir's from other concurrent\n         * CCpp's won't be able to delete our dump (their delete_dump_dir\n         * will wait for us), and we won't be able to delete their dumps.\n         * Classic deadlock.\n         */\n        dd_close(dd);\n        dd = NULL;\n\n        path[path_len] = '\\0'; /* path now contains only directory name */\n\n        if (abrtd_running && setting_SaveContainerizedPackageData && containerized)\n        {   /* Do we really need to run rpm from core_pattern hook? */\n            sprintf(source_filename, \"/proc/%lu/root\", (long)pid);\n\n            const char *cmd_args[6];\n            cmd_args[0] = BIN_DIR\"/abrt-action-save-package-data\";\n            cmd_args[1] = \"-d\";\n            cmd_args[2] = path;\n            cmd_args[3] = \"-r\";\n            cmd_args[4] = source_filename;\n            cmd_args[5] = NULL;\n\n            pid_t pid = fork_execv_on_steroids(0, (char **)cmd_args, NULL, NULL, path, 0);\n            int stat;\n            safe_waitpid(pid, &stat, 0);\n        }\n\n        char *newpath = xstrndup(path, path_len - (sizeof(\".new\")-1));\n        if (rename(path, newpath) == 0)\n            strcpy(path, newpath);\n        free(newpath);\n\n        if (core_size > 0)\n            log_notice(\"Saved core dump of pid %lu (%s) to %s (%llu bytes)\",\n                       (long)pid, executable, path, (long long)core_size);\n\n        if (abrtd_running)\n            notify_new_path(path);\n\n        /* rhbz#539551: \"abrt going crazy when crashing process is respawned\" */\n        if (g_settings_nMaxCrashReportsSize > 0)\n        {\n            /* x1.25 and round up to 64m: go a bit up, so that usual in-daemon trimming\n             * kicks in first, and we don't \"fight\" with it:\n             */\n            unsigned maxsize = g_settings_nMaxCrashReportsSize + g_settings_nMaxCrashReportsSize / 4;\n            maxsize |= 63;\n            trim_problem_dirs(g_settings_dump_location, maxsize * (double)(1024*1024), path);\n        }\n\n        err = 0;\n    }\n    else\n    {\n        /* We didn't create abrt dump, but may need to create compat coredump */\n        return create_user_core(user_core_fd, pid, ulimit_c);\n    }\n\ncleanup_and_exit:\n    if (dd)\n        dd_delete(dd);\n\n    if (user_core_fd >= 0)\n        unlinkat(dirfd(proc_cwd), core_basename, /*only files*/0);\n\n    if (proc_cwd != NULL)\n        closedir(proc_cwd);\n\n    return err;\n}\n", "target": 1, "idx": 179776}
{"func": "GeolocationInspectorAgent::~GeolocationInspectorAgent()\n{\n}\n", "target": 0, "idx": 123650}
{"func": "static int handle_rst_stream_frame(h2o_http2_conn_t *conn, h2o_http2_frame_t *frame, const char **err_desc)\n{\n    h2o_http2_rst_stream_payload_t payload;\n    h2o_http2_stream_t *stream;\n    int ret;\n\n    if ((ret = h2o_http2_decode_rst_stream_payload(&payload, frame, err_desc)) != 0)\n        return ret;\n    if (is_idle_stream_id(conn, frame->stream_id)) {\n        *err_desc = \"unexpected stream id in RST_STREAM frame\";\n        return H2O_HTTP2_ERROR_PROTOCOL;\n    }\n\n    stream = h2o_http2_conn_get_stream(conn, frame->stream_id);\n    if (stream != NULL) {\n        /* reset the stream */\n        h2o_http2_stream_reset(conn, stream);\n    }\n    /* TODO log */\n\n    return 0;\n}\n", "target": 0, "idx": 52567}
{"func": "void rds_ib_advertise_credits(struct rds_connection *conn, unsigned int posted)\n{\n\tstruct rds_ib_connection *ic = conn->c_transport_data;\n\n\tif (posted == 0)\n\t\treturn;\n\n\tatomic_add(IB_SET_POST_CREDITS(posted), &ic->i_credits);\n\n\t/* Decide whether to send an update to the peer now.\n\t * If we would send a credit update for every single buffer we\n\t * post, we would end up with an ACK storm (ACK arrives,\n\t * consumes buffer, we refill the ring, send ACK to remote\n\t * advertising the newly posted buffer... ad inf)\n\t *\n\t * Performance pretty much depends on how often we send\n\t * credit updates - too frequent updates mean lots of ACKs.\n\t * Too infrequent updates, and the peer will run out of\n\t * credits and has to throttle.\n\t * For the time being, 16 seems to be a good compromise.\n\t */\n\tif (IB_GET_POST_CREDITS(atomic_read(&ic->i_credits)) >= 16)\n\t\tset_bit(IB_ACK_REQUESTED, &ic->i_ack_flags);\n}\n", "target": 0, "idx": 27760}
{"func": "static int jpc_dec_process_siz(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_siz_t *siz = &ms->parms.siz;\n\tint compno;\n\tint tileno;\n\tjpc_dec_tile_t *tile;\n\tjpc_dec_tcomp_t *tcomp;\n \tint htileno;\n \tint vtileno;\n \tjpc_dec_cmpt_t *cmpt;\n \n \tdec->xstart = siz->xoff;\n \tdec->ystart = siz->yoff;\n\tdec->xend = siz->width;\n\tdec->yend = siz->height;\n\tdec->tilewidth = siz->tilewidth;\n\tdec->tileheight = siz->tileheight;\n\tdec->tilexoff = siz->tilexoff;\n\tdec->tileyoff = siz->tileyoff;\n\tdec->numcomps = siz->numcomps;\n\tif (!(dec->cp = jpc_dec_cp_create(dec->numcomps))) {\n\t\treturn -1;\n\t}\n\n\tif (!(dec->cmpts = jas_alloc2(dec->numcomps, sizeof(jpc_dec_cmpt_t)))) {\n\t\treturn -1;\n\t}\n\n\tfor (compno = 0, cmpt = dec->cmpts; compno < dec->numcomps; ++compno,\n\t  ++cmpt) {\n\t\tcmpt->prec = siz->comps[compno].prec;\n\t\tcmpt->sgnd = siz->comps[compno].sgnd;\n\t\tcmpt->hstep = siz->comps[compno].hsamp;\n\t\tcmpt->vstep = siz->comps[compno].vsamp;\n\t\tcmpt->width = JPC_CEILDIV(dec->xend, cmpt->hstep) -\n\t\t  JPC_CEILDIV(dec->xstart, cmpt->hstep);\n\t\tcmpt->height = JPC_CEILDIV(dec->yend, cmpt->vstep) -\n\t\t  JPC_CEILDIV(dec->ystart, cmpt->vstep);\n\t\tcmpt->hsubstep = 0;\n\t\tcmpt->vsubstep = 0;\n\t}\n\n\tdec->image = 0;\n \n \tdec->numhtiles = JPC_CEILDIV(dec->xend - dec->tilexoff, dec->tilewidth);\n \tdec->numvtiles = JPC_CEILDIV(dec->yend - dec->tileyoff, dec->tileheight);\n\tdec->numtiles = dec->numhtiles * dec->numvtiles;\n \tJAS_DBGLOG(10, (\"numtiles = %d; numhtiles = %d; numvtiles = %d;\\n\",\n \t  dec->numtiles, dec->numhtiles, dec->numvtiles));\n \tif (!(dec->tiles = jas_alloc2(dec->numtiles, sizeof(jpc_dec_tile_t)))) {\n\t\treturn -1;\n\t}\n\n\tfor (tileno = 0, tile = dec->tiles; tileno < dec->numtiles; ++tileno,\n\t  ++tile) {\n\t\thtileno = tileno % dec->numhtiles;\n\t\tvtileno = tileno / dec->numhtiles;\n\t\ttile->realmode = 0;\n\t\ttile->state = JPC_TILE_INIT;\n\t\ttile->xstart = JAS_MAX(dec->tilexoff + htileno * dec->tilewidth,\n\t\t  dec->xstart);\n\t\ttile->ystart = JAS_MAX(dec->tileyoff + vtileno * dec->tileheight,\n\t\t  dec->ystart);\n\t\ttile->xend = JAS_MIN(dec->tilexoff + (htileno + 1) *\n\t\t  dec->tilewidth, dec->xend);\n\t\ttile->yend = JAS_MIN(dec->tileyoff + (vtileno + 1) *\n\t\t  dec->tileheight, dec->yend);\n\t\ttile->numparts = 0;\n\t\ttile->partno = 0;\n\t\ttile->pkthdrstream = 0;\n\t\ttile->pkthdrstreampos = 0;\n\t\ttile->pptstab = 0;\n\t\ttile->cp = 0;\n\t\ttile->pi = 0;\n\t\tif (!(tile->tcomps = jas_alloc2(dec->numcomps,\n\t\t  sizeof(jpc_dec_tcomp_t)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (compno = 0, cmpt = dec->cmpts, tcomp = tile->tcomps;\n\t\t  compno < dec->numcomps; ++compno, ++cmpt, ++tcomp) {\n\t\t\ttcomp->rlvls = 0;\n\t\t\ttcomp->numrlvls = 0;\n\t\t\ttcomp->data = 0;\n\t\t\ttcomp->xstart = JPC_CEILDIV(tile->xstart, cmpt->hstep);\n\t\t\ttcomp->ystart = JPC_CEILDIV(tile->ystart, cmpt->vstep);\n\t\t\ttcomp->xend = JPC_CEILDIV(tile->xend, cmpt->hstep);\n\t\t\ttcomp->yend = JPC_CEILDIV(tile->yend, cmpt->vstep);\n\t\t\ttcomp->tsfb = 0;\n\t\t}\n\t}\n\n\tdec->pkthdrstreams = 0;\n\n\t/* We should expect to encounter other main header marker segments\n\t  or an SOT marker segment next. */\n\tdec->state = JPC_MH;\n\n\treturn 0;\n}\n", "target": 1, "idx": 181914}
{"func": " size_t OpenMP4SourceUDTA(char *filename)\n {\n\tmp4object *mp4 = (mp4object *)malloc(sizeof(mp4object));\n\tif (mp4 == NULL) return 0;\n\n\tmemset(mp4, 0, sizeof(mp4object));\n\n#ifdef _WINDOWS\n\tfopen_s(&mp4->mediafp, filename, \"rb\");\n#else\n\tmp4->mediafp = fopen(filename, \"rb\");\n#endif\n \n \tif (mp4->mediafp)\n \t{\n\t\tuint32_t qttag, qtsize32, len;\n \t\tint32_t nest = 0;\n \t\tuint64_t nestsize[MAX_NEST_LEVEL] = { 0 };\n \t\tuint64_t lastsize = 0, qtsize;\n\n\t\tdo\n\t\t{\n\t\t\tlen = fread(&qtsize32, 1, 4, mp4->mediafp);\n\t\t\tlen += fread(&qttag, 1, 4, mp4->mediafp);\n\t\t\tif (len == 8)\n \t\t\t{\n \t\t\t\tif (!GPMF_VALID_FOURCC(qttag))\n \t\t\t\t{\n\t\t\t\t\tLONGSEEK(mp4->mediafp, lastsize - 8 - 8, SEEK_CUR);\n \n \t\t\t\t\tNESTSIZE(lastsize - 8);\n \t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tqtsize32 = BYTESWAP32(qtsize32);\n\n\t\t\t\tif (qtsize32 == 1) // 64-bit Atom\n\t\t\t\t{\n\t\t\t\t\tfread(&qtsize, 1, 8, mp4->mediafp);\n\t\t\t\t\tqtsize = BYTESWAP64(qtsize) - 8;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tqtsize = qtsize32;\n\n\t\t\t\tnest++;\n\n\t\t\t\tif (qtsize < 8) break;\n\t\t\t\tif (nest >= MAX_NEST_LEVEL) break;\n\n\t\t\t\tnestsize[nest] = qtsize;\n\t\t\t\tlastsize = qtsize;\n\n \t\t\t\tif (qttag == MAKEID('m', 'd', 'a', 't') ||\n \t\t\t\t\tqttag == MAKEID('f', 't', 'y', 'p'))\n \t\t\t\t{\n\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);\n \t\t\t\t\tNESTSIZE(qtsize);\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n\n\t\t\t\tif (qttag == MAKEID('G', 'P', 'M', 'F'))\n\t\t\t\t{\n\t\t\t\t\tmp4->videolength += 1.0;\n\t\t\t\t\tmp4->metadatalength += 1.0;\n\n\t\t\t\t\tmp4->indexcount = (int)mp4->metadatalength;\n\n\t\t\t\t\tmp4->metasizes = (uint32_t *)malloc(mp4->indexcount * 4 + 4);  memset(mp4->metasizes, 0, mp4->indexcount * 4 + 4);\n\t\t\t\t\tmp4->metaoffsets = (uint64_t *)malloc(mp4->indexcount * 8 + 8);  memset(mp4->metaoffsets, 0, mp4->indexcount * 8 + 8);\n\n\t\t\t\t\tmp4->metasizes[0] = (int)qtsize - 8;\n\t\t\t\t\tmp4->metaoffsets[0] = ftell(mp4->mediafp);\n\t\t\t\t\tmp4->metasize_count = 1;\n\n\t\t\t\t\treturn (size_t)mp4;  // not an MP4, RAW GPMF which has not inherent timing, assigning a during of 1second.\n\t\t\t\t}\n \t\t\t\tif (qttag != MAKEID('m', 'o', 'o', 'v') && //skip over all but these atoms\n \t\t\t\t\tqttag != MAKEID('u', 'd', 't', 'a'))\n \t\t\t\t{\n\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);\n \t\t\t\t\tNESTSIZE(qtsize);\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tNESTSIZE(8);\n\t\t\t\t}\n\t\t\t}\n\t\t} while (len > 0);\n\t}\n\treturn (size_t)mp4;\n }\n", "target": 1, "idx": 182723}
{"func": "AutocompleteLog::AutocompleteLog(\n    const string16& text,\n    bool just_deleted_text,\n    AutocompleteInput::Type input_type,\n    size_t selected_index,\n    SessionID::id_type tab_id,\n    metrics::OmniboxEventProto::PageClassification current_page_classification,\n    base::TimeDelta elapsed_time_since_user_first_modified_omnibox,\n    size_t inline_autocompleted_length,\n    const AutocompleteResult& result)\n    : text(text),\n      just_deleted_text(just_deleted_text),\n      input_type(input_type),\n      selected_index(selected_index),\n      tab_id(tab_id),\n      current_page_classification(current_page_classification),\n       elapsed_time_since_user_first_modified_omnibox(\n           elapsed_time_since_user_first_modified_omnibox),\n       inline_autocompleted_length(inline_autocompleted_length),\n      result(result) {\n }\n", "target": 1, "idx": 184331}
{"func": "void Element::formatForDebugger(char* buffer, unsigned length) const\n{\n    StringBuilder result;\n    String s;\n\n    result.append(nodeName());\n\n    s = getIdAttribute();\n    if (s.length() > 0) {\n        if (result.length() > 0)\n            result.appendLiteral(\"; \");\n        result.appendLiteral(\"id=\");\n        result.append(s);\n    }\n\n    s = getAttribute(classAttr);\n    if (s.length() > 0) {\n        if (result.length() > 0)\n            result.appendLiteral(\"; \");\n        result.appendLiteral(\"class=\");\n        result.append(s);\n    }\n\n    strncpy(buffer, result.toString().utf8().data(), length - 1);\n}\n", "target": 0, "idx": 120522}
{"func": "int PKCS7_dataVerify(X509_STORE *cert_store, X509_STORE_CTX *ctx, BIO *bio,\n                     PKCS7 *p7, PKCS7_SIGNER_INFO *si)\n{\n    PKCS7_ISSUER_AND_SERIAL *ias;\n    int ret = 0, i;\n    STACK_OF(X509) *cert;\n    X509 *x509;\n\n    if (p7 == NULL) {\n        PKCS7err(PKCS7_F_PKCS7_DATAVERIFY, PKCS7_R_INVALID_NULL_POINTER);\n        return 0;\n    }\n\n    if (p7->d.ptr == NULL) {\n        PKCS7err(PKCS7_F_PKCS7_DATAVERIFY, PKCS7_R_NO_CONTENT);\n        return 0;\n    }\n\n    if (PKCS7_type_is_signed(p7)) {\n        cert = p7->d.sign->cert;\n    } else if (PKCS7_type_is_signedAndEnveloped(p7)) {\n        cert = p7->d.signed_and_enveloped->cert;\n    } else {\n        PKCS7err(PKCS7_F_PKCS7_DATAVERIFY, PKCS7_R_WRONG_PKCS7_TYPE);\n        goto err;\n    }\n    /* XXXXXXXXXXXXXXXXXXXXXXX */\n    ias = si->issuer_and_serial;\n\n    x509 = X509_find_by_issuer_and_serial(cert, ias->issuer, ias->serial);\n\n    /* were we able to find the cert in passed to us */\n    if (x509 == NULL) {\n        PKCS7err(PKCS7_F_PKCS7_DATAVERIFY,\n                 PKCS7_R_UNABLE_TO_FIND_CERTIFICATE);\n        goto err;\n    }\n\n    /* Lets verify */\n    if (!X509_STORE_CTX_init(ctx, cert_store, x509, cert)) {\n        PKCS7err(PKCS7_F_PKCS7_DATAVERIFY, ERR_R_X509_LIB);\n        goto err;\n    }\n    X509_STORE_CTX_set_purpose(ctx, X509_PURPOSE_SMIME_SIGN);\n    i = X509_verify_cert(ctx);\n    if (i <= 0) {\n        PKCS7err(PKCS7_F_PKCS7_DATAVERIFY, ERR_R_X509_LIB);\n        X509_STORE_CTX_cleanup(ctx);\n        goto err;\n    }\n    X509_STORE_CTX_cleanup(ctx);\n\n    return PKCS7_signatureVerify(bio, p7, si, x509);\n err:\n    return ret;\n}\n", "target": 0, "idx": 44221}
{"func": "static void __hidp_unlink_session(struct hidp_session *session)\n{\n\thci_conn_put_device(session->conn);\n\n\tlist_del(&session->list);\n}\n", "target": 0, "idx": 33725}
{"func": "static void change_port_settings(struct tty_struct *tty,\n\t\tstruct edgeport_port *edge_port, struct ktermios *old_termios)\n{\n\tstruct device *dev = &edge_port->port->dev;\n\tstruct ump_uart_config *config;\n\tint baud;\n\tunsigned cflag;\n\tint status;\n\tint port_number = edge_port->port->number -\n\t\t\t\t\tedge_port->port->serial->minor;\n\n\tdev_dbg(dev, \"%s - port %d\\n\", __func__, edge_port->port->number);\n\n\tconfig = kmalloc (sizeof (*config), GFP_KERNEL);\n\tif (!config) {\n\t\ttty->termios = *old_termios;\n\t\tdev_err(dev, \"%s - out of memory\\n\", __func__);\n\t\treturn;\n\t}\n\n\tcflag = tty->termios.c_cflag;\n\n\tconfig->wFlags = 0;\n\n\t/* These flags must be set */\n\tconfig->wFlags |= UMP_MASK_UART_FLAGS_RECEIVE_MS_INT;\n\tconfig->wFlags |= UMP_MASK_UART_FLAGS_AUTO_START_ON_ERR;\n\tconfig->bUartMode = (__u8)(edge_port->bUartMode);\n\n\tswitch (cflag & CSIZE) {\n\tcase CS5:\n\t\t    config->bDataBits = UMP_UART_CHAR5BITS;\n\t\t    dev_dbg(dev, \"%s - data bits = 5\\n\", __func__);\n\t\t    break;\n\tcase CS6:\n\t\t    config->bDataBits = UMP_UART_CHAR6BITS;\n\t\t    dev_dbg(dev, \"%s - data bits = 6\\n\", __func__);\n\t\t    break;\n\tcase CS7:\n\t\t    config->bDataBits = UMP_UART_CHAR7BITS;\n\t\t    dev_dbg(dev, \"%s - data bits = 7\\n\", __func__);\n\t\t    break;\n\tdefault:\n\tcase CS8:\n\t\t    config->bDataBits = UMP_UART_CHAR8BITS;\n\t\t    dev_dbg(dev, \"%s - data bits = 8\\n\", __func__);\n\t\t\t    break;\n\t}\n\n\tif (cflag & PARENB) {\n\t\tif (cflag & PARODD) {\n\t\t\tconfig->wFlags |= UMP_MASK_UART_FLAGS_PARITY;\n\t\t\tconfig->bParity = UMP_UART_ODDPARITY;\n\t\t\tdev_dbg(dev, \"%s - parity = odd\\n\", __func__);\n\t\t} else {\n\t\t\tconfig->wFlags |= UMP_MASK_UART_FLAGS_PARITY;\n\t\t\tconfig->bParity = UMP_UART_EVENPARITY;\n\t\t\tdev_dbg(dev, \"%s - parity = even\\n\", __func__);\n\t\t}\n\t} else {\n\t\tconfig->bParity = UMP_UART_NOPARITY;\n\t\tdev_dbg(dev, \"%s - parity = none\\n\", __func__);\n\t}\n\n\tif (cflag & CSTOPB) {\n\t\tconfig->bStopBits = UMP_UART_STOPBIT2;\n\t\tdev_dbg(dev, \"%s - stop bits = 2\\n\", __func__);\n\t} else {\n\t\tconfig->bStopBits = UMP_UART_STOPBIT1;\n\t\tdev_dbg(dev, \"%s - stop bits = 1\\n\", __func__);\n\t}\n\n\t/* figure out the flow control settings */\n\tif (cflag & CRTSCTS) {\n\t\tconfig->wFlags |= UMP_MASK_UART_FLAGS_OUT_X_CTS_FLOW;\n\t\tconfig->wFlags |= UMP_MASK_UART_FLAGS_RTS_FLOW;\n\t\tdev_dbg(dev, \"%s - RTS/CTS is enabled\\n\", __func__);\n\t} else {\n\t\tdev_dbg(dev, \"%s - RTS/CTS is disabled\\n\", __func__);\n\t\ttty->hw_stopped = 0;\n\t\trestart_read(edge_port);\n\t}\n\n\t/* if we are implementing XON/XOFF, set the start and stop\n\t   character in the device */\n\tconfig->cXon  = START_CHAR(tty);\n\tconfig->cXoff = STOP_CHAR(tty);\n\n\t/* if we are implementing INBOUND XON/XOFF */\n\tif (I_IXOFF(tty)) {\n\t\tconfig->wFlags |= UMP_MASK_UART_FLAGS_IN_X;\n\t\tdev_dbg(dev, \"%s - INBOUND XON/XOFF is enabled, XON = %2x, XOFF = %2x\\n\",\n\t\t\t__func__, config->cXon, config->cXoff);\n\t} else\n\t\tdev_dbg(dev, \"%s - INBOUND XON/XOFF is disabled\\n\", __func__);\n\n\t/* if we are implementing OUTBOUND XON/XOFF */\n\tif (I_IXON(tty)) {\n\t\tconfig->wFlags |= UMP_MASK_UART_FLAGS_OUT_X;\n\t\tdev_dbg(dev, \"%s - OUTBOUND XON/XOFF is enabled, XON = %2x, XOFF = %2x\\n\",\n\t\t\t__func__, config->cXon, config->cXoff);\n\t} else\n\t\tdev_dbg(dev, \"%s - OUTBOUND XON/XOFF is disabled\\n\", __func__);\n\n\ttty->termios.c_cflag &= ~CMSPAR;\n\n\t/* Round the baud rate */\n\tbaud = tty_get_baud_rate(tty);\n\tif (!baud) {\n\t\t/* pick a default, any default... */\n\t\tbaud = 9600;\n\t} else\n\t\ttty_encode_baud_rate(tty, baud, baud);\n\n\tedge_port->baud_rate = baud;\n\tconfig->wBaudRate = (__u16)((461550L + baud/2) / baud);\n\n\t/* FIXME: Recompute actual baud from divisor here */\n\n\tdev_dbg(dev, \"%s - baud rate = %d, wBaudRate = %d\\n\", __func__, baud, config->wBaudRate);\n\n\tdev_dbg(dev, \"wBaudRate:   %d\\n\", (int)(461550L / config->wBaudRate));\n\tdev_dbg(dev, \"wFlags:    0x%x\\n\", config->wFlags);\n\tdev_dbg(dev, \"bDataBits:   %d\\n\", config->bDataBits);\n\tdev_dbg(dev, \"bParity:     %d\\n\", config->bParity);\n\tdev_dbg(dev, \"bStopBits:   %d\\n\", config->bStopBits);\n\tdev_dbg(dev, \"cXon:        %d\\n\", config->cXon);\n\tdev_dbg(dev, \"cXoff:       %d\\n\", config->cXoff);\n\tdev_dbg(dev, \"bUartMode:   %d\\n\", config->bUartMode);\n\n\t/* move the word values into big endian mode */\n\tcpu_to_be16s(&config->wFlags);\n\tcpu_to_be16s(&config->wBaudRate);\n\n\tstatus = send_cmd(edge_port->port->serial->dev, UMPC_SET_CONFIG,\n\t\t\t\t(__u8)(UMPM_UART1_PORT + port_number),\n\t\t\t\t0, (__u8 *)config, sizeof(*config));\n\tif (status)\n\t\tdev_dbg(dev, \"%s - error %d when trying to write config to device\\n\",\n\t\t\t__func__, status);\n\tkfree(config);\n}\n", "target": 0, "idx": 33318}
{"func": "static const char* getReturnString(size_t idx)\n{\n if (idx < sizeof(kReturnStrings) / sizeof(kReturnStrings[0]))\n return kReturnStrings[idx];\n else\n return \"unknown\";\n}\n", "target": 0, "idx": 174319}
{"func": " stringprep_utf8_nfkc_normalize (const char *str, ssize_t len)\n {\n   return g_utf8_normalize (str, len, G_NORMALIZE_NFKC);\n }\n", "target": 1, "idx": 178156}
{"func": "decrypt_response(struct sc_card *card, unsigned char *in, size_t inlen, unsigned char *out, size_t * out_len)\n{\n\tsize_t cipher_len;\n\tsize_t i;\n\tunsigned char iv[16] = { 0 };\n\tunsigned char plaintext[4096] = { 0 };\n\tepass2003_exdata *exdata = NULL;\n\n\tif (!card->drv_data) \n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\texdata = (epass2003_exdata *)card->drv_data;\n\n\t/* no cipher */\n\tif (in[0] == 0x99)\n\t\treturn 0;\n\n\t/* parse cipher length */\n\tif (0x01 == in[2] && 0x82 != in[1]) {\n\t\tcipher_len = in[1];\n\t\ti = 3;\n\t}\n\telse if (0x01 == in[3] && 0x81 == in[1]) {\n\t\tcipher_len = in[2];\n\t\ti = 4;\n\t}\n\telse if (0x01 == in[4] && 0x82 == in[1]) {\n\t\tcipher_len = in[2] * 0x100;\n\t\tcipher_len += in[3];\n\t\ti = 5;\n\t}\n\telse {\n\t\treturn -1;\n\t}\n\n\tif (cipher_len < 2 || i+cipher_len > inlen || cipher_len > sizeof plaintext)\n\t\treturn -1;\n\n\t/* decrypt */\n\tif (KEY_TYPE_AES == exdata->smtype)\n\t\taes128_decrypt_cbc(exdata->sk_enc, 16, iv, &in[i], cipher_len - 1, plaintext);\n\telse\n\t\tdes3_decrypt_cbc(exdata->sk_enc, 16, iv, &in[i], cipher_len - 1, plaintext);\n\n\t/* unpadding */\n \twhile (0x80 != plaintext[cipher_len - 2] && (cipher_len - 2 > 0))\n \t\tcipher_len--;\n \n\tif (2 == cipher_len)\n \t\treturn -1;\n \n \tmemcpy(out, plaintext, cipher_len - 2);\n\t*out_len = cipher_len - 2;\n\treturn 0;\n}\n", "target": 1, "idx": 182244}
{"func": "SQLRETURN SQLSetDescField( SQLHDESC descriptor_handle,\n           SQLSMALLINT rec_number, \n           SQLSMALLINT field_identifier,\n           SQLPOINTER value, \n           SQLINTEGER buffer_length )\n{\n    /*\n     * not quite sure how the descriptor can be\n     * allocated to a statement, all the documentation talks\n     * about state transitions on statement states, but the\n     * descriptor may be allocated with more than one statement\n     * at one time. Which one should I check ?\n     */\n    DMHDESC descriptor = (DMHDESC) descriptor_handle;\n    SQLRETURN ret;\n    SQLCHAR s1[ 100 + LOG_MESSAGE_LEN ];\n    int isStrField = 0;\n\n    /*\n     * check descriptor\n     */\n\n    if ( !__validate_desc( descriptor ))\n    {\n        dm_log_write( __FILE__, \n                    __LINE__, \n                    LOG_INFO, \n                    LOG_INFO, \n                    \"Error: SQL_INVALID_HANDLE\" );\n\n        return SQL_INVALID_HANDLE;\n    }\n\n    function_entry( descriptor );\n\n    if ( log_info.log_flag )\n    {\n        sprintf( descriptor -> msg, \"\\n\\t\\tEntry:\\\n\\n\\t\\t\\tDescriptor = %p\\\n\\n\\t\\t\\tRec Number = %d\\\n\\n\\t\\t\\tField Ident = %s\\\n\\n\\t\\t\\tValue = %p\\\n\\n\\t\\t\\tBuffer Length = %d\",\n                descriptor,\n                rec_number,\n                __desc_attr_as_string( s1, field_identifier ),\n                value, \n                (int)buffer_length );\n\n        dm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                descriptor -> msg );\n    }\n\n    thread_protect( SQL_HANDLE_DESC, descriptor );\n\n    if ( descriptor -> connection -> state < STATE_C4 )\n    {\n        dm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                \"Error: HY010\" );\n\n        __post_internal_error( &descriptor -> error,\n                ERROR_HY010, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    /*\n     * check status of statements associated with this descriptor\n     */\n\n    if( __check_stmt_from_desc( descriptor, STATE_S8 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S9 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S10 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S11 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S12 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S13 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S14 ) ||\n        __check_stmt_from_desc( descriptor, STATE_S15 )) {\n\n        dm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                \"Error: HY010\" );\n\n        __post_internal_error( &descriptor -> error,\n                ERROR_HY010, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n\n    if ( rec_number < 0 )\n    {\n        __post_internal_error( &descriptor -> error,\n                ERROR_07009, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    switch ( field_identifier )\n    {\n    /* Fixed-length fields: buffer_length is ignored */\n    case SQL_DESC_ALLOC_TYPE:\n    case SQL_DESC_ARRAY_SIZE:\n    case SQL_DESC_ARRAY_STATUS_PTR:\n    case SQL_DESC_BIND_OFFSET_PTR:\n    case SQL_DESC_BIND_TYPE:\n    case SQL_DESC_COUNT:\n    case SQL_DESC_ROWS_PROCESSED_PTR:\n    case SQL_DESC_AUTO_UNIQUE_VALUE:\n    case SQL_DESC_CASE_SENSITIVE:\n    case SQL_DESC_CONCISE_TYPE:\n    case SQL_DESC_DATA_PTR:\n    case SQL_DESC_DATETIME_INTERVAL_CODE:\n    case SQL_DESC_DATETIME_INTERVAL_PRECISION:\n    case SQL_DESC_DISPLAY_SIZE:\n    case SQL_DESC_FIXED_PREC_SCALE:\n    case SQL_DESC_INDICATOR_PTR:\n    case SQL_DESC_LENGTH:\n    case SQL_DESC_NULLABLE:\n    case SQL_DESC_NUM_PREC_RADIX:\n    case SQL_DESC_OCTET_LENGTH:\n    case SQL_DESC_OCTET_LENGTH_PTR:\n    case SQL_DESC_PARAMETER_TYPE:\n    case SQL_DESC_PRECISION:\n    case SQL_DESC_ROWVER:\n    case SQL_DESC_SCALE:\n    case SQL_DESC_SEARCHABLE:\n    case SQL_DESC_TYPE:\n    case SQL_DESC_UNNAMED:\n    case SQL_DESC_UNSIGNED:\n    case SQL_DESC_UPDATABLE:\n        isStrField = 0;\n        break;\n    /* Pointer to data: buffer_length must be valid */\n    case SQL_DESC_BASE_COLUMN_NAME:\n    case SQL_DESC_BASE_TABLE_NAME:\n    case SQL_DESC_CATALOG_NAME:\n    case SQL_DESC_LABEL:\n    case SQL_DESC_LITERAL_PREFIX:\n    case SQL_DESC_LITERAL_SUFFIX:\n    case SQL_DESC_LOCAL_TYPE_NAME:\n    case SQL_DESC_NAME:\n    case SQL_DESC_SCHEMA_NAME:\n    case SQL_DESC_TABLE_NAME:\n    case SQL_DESC_TYPE_NAME:\n        isStrField = 1;\n        break;\n    default:\n        isStrField = buffer_length != SQL_IS_POINTER && buffer_length != SQL_IS_INTEGER\n            && buffer_length != SQL_IS_UINTEGER && buffer_length != SQL_IS_SMALLINT &&\n            buffer_length != SQL_IS_USMALLINT;\n    }\n    \n    if ( isStrField && buffer_length < 0 && buffer_length != SQL_NTS)\n    {\n        __post_internal_error( &descriptor -> error,\n            ERROR_HY090, NULL,\n            descriptor -> connection -> environment -> requested_version );\n\n         return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n     }\n \n    if ( field_identifier == SQL_DESC_COUNT && (SQLINTEGER)value < 0 )\n     {\n         __post_internal_error( &descriptor -> error,\n                 ERROR_07009, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n         return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n     }\n     \n    if ( field_identifier == SQL_DESC_PARAMETER_TYPE && value != SQL_PARAM_INPUT\n        && value != SQL_PARAM_OUTPUT && value != SQL_PARAM_INPUT_OUTPUT &&\n        value != SQL_PARAM_INPUT_OUTPUT_STREAM && value != SQL_PARAM_OUTPUT_STREAM )\n     {\n         __post_internal_error( &descriptor -> error,\n                 ERROR_HY105, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    if ( CHECK_SQLSETDESCFIELD( descriptor -> connection ))\n    {\n      ret = SQLSETDESCFIELD( descriptor -> connection,\n              descriptor -> driver_desc,\n              rec_number, \n              field_identifier,\n              value, \n              buffer_length );\n    }\n    else if ( CHECK_SQLSETDESCFIELDW( descriptor -> connection ))\n    {\n      SQLWCHAR *s1 = NULL;\n\n        if (isStrField)\n      {\n        s1 = ansi_to_unicode_alloc( value, buffer_length, descriptor -> connection, NULL );\n            if (SQL_NTS != buffer_length)\n            {\n                buffer_length *= sizeof(SQLWCHAR);\n            }\n      }\n      else\n      {\n              s1 = value;\n      }\n      ret = SQLSETDESCFIELDW( descriptor -> connection,\n                descriptor -> driver_desc,\n                rec_number, \n                field_identifier,\n                s1, \n                buffer_length );\n       \n        if (isStrField)\n       {\n        if (s1)\n          free(s1); \n       }\n    }\n    else \n\t{\n        dm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                \"Error: IM001\" );\n\n        __post_internal_error( &descriptor -> error,\n                ERROR_IM001, NULL,\n                descriptor -> connection -> environment -> requested_version );\n\n        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );\n    }\n\n    if ( log_info.log_flag )\n    {\n        sprintf( descriptor -> msg, \n                \"\\n\\t\\tExit:[%s]\",\n                    __get_return_status( ret, s1 ));\n\n        dm_log_write( __FILE__, \n                __LINE__, \n                LOG_INFO, \n                LOG_INFO, \n                descriptor -> msg );\n    }\n\n    return function_return( SQL_HANDLE_DESC, descriptor, ret );\n}\n", "target": 1, "idx": 182482}
{"func": "bool SiteInstanceImpl::DoesSiteRequireDedicatedProcess(\n    BrowserContext* browser_context,\n    const GURL& url) {\n   if (SiteIsolationPolicy::UseDedicatedProcessesForAllSites())\n     return true;\n \n  if (url.SchemeIs(kChromeErrorScheme))\n     return true;\n \n  GURL site_url = SiteInstance::GetSiteForURL(browser_context, url);\n  auto* policy = ChildProcessSecurityPolicyImpl::GetInstance();\n  if (policy->IsIsolatedOrigin(url::Origin::Create(site_url)))\n     return true;\n \n  if (GetContentClient()->browser()->DoesSiteRequireDedicatedProcess(\n          browser_context, site_url)) {\n    return true;\n  }\n\n  return false;\n}\n", "target": 1, "idx": 187303}
{"func": "RenderSetBit(unsigned char *line, int x, int bit)\n{\n    unsigned char mask;\n\n    if (screenInfo.bitmapBitOrder == LSBFirst)\n        mask = (1 << (x & 7));\n    else\n        mask = (0x80 >> (x & 7));\n    /* XXX assumes byte order is host byte order */\n    line += (x >> 3);\n    if (bit)\n        *line |= mask;\n    else\n        *line &= ~mask;\n}\n", "target": 0, "idx": 17605}
{"func": "TokenPreloadScanner::TokenPreloadScanner(const KURL& documentURL, PassOwnPtr<CachedDocumentParameters> documentParameters, const MediaValuesCached::MediaValuesCachedData& mediaValuesCachedData)\n    : m_documentURL(documentURL)\n    , m_inStyle(false)\n    , m_inPicture(false)\n    , m_inScript(false)\n    , m_isAppCacheEnabled(false)\n    , m_isCSPEnabled(false)\n    , m_templateCount(0)\n    , m_documentParameters(std::move(documentParameters))\n    , m_mediaValues(MediaValuesCached::create(mediaValuesCachedData))\n    , m_didRewind(false)\n {\n     ASSERT(m_documentParameters.get());\n     ASSERT(m_mediaValues.get());\n }\n", "target": 1, "idx": 186069}
{"func": "static inline int perf_intr_is_nmi(struct pt_regs *regs)\n{\n\treturn !regs->softe;\n}\n", "target": 0, "idx": 22686}
{"func": "void RenderWidgetHostViewAura::RemovingFromRootWindow() {\n  host_->ParentChanged(0);\n   ui::Compositor* compositor = GetCompositor();\n  RunCompositingDidCommitCallbacks(compositor);\n   locks_pending_commit_.clear();\n   if (compositor && compositor->HasObserver(this))\n     compositor->RemoveObserver(this);\n  DetachFromInputMethod();\n}\n", "target": 1, "idx": 185080}
{"func": "static void rxrpc_free_krb5_tagged(struct krb5_tagged_data *td)\n{\n\tkfree(td->data);\n}\n", "target": 0, "idx": 69503}
{"func": "static void DrawGLFunction(long view_context,\n                           AwDrawGLInfo* draw_info,\n                           void* spare) {\n  reinterpret_cast<android_webview::SharedRendererState*>(view_context)\n      ->DrawGL(draw_info);\n}\n", "target": 0, "idx": 127988}
{"func": "  Round_Super_45( EXEC_OP_ FT_F26Dot6  distance,\n                           FT_F26Dot6  compensation )\n  {\n    FT_F26Dot6  val;\n\n\n    if ( distance >= 0 )\n    {\n      val = ( ( distance - CUR.phase + CUR.threshold + compensation ) /\n                CUR.period ) * CUR.period;\n      if ( distance && val < 0 )\n        val = 0;\n      val += CUR.phase;\n    }\n    else\n    {\n      val = -( ( ( CUR.threshold - CUR.phase - distance + compensation ) /\n                   CUR.period ) * CUR.period );\n      if ( val > 0 )\n        val = 0;\n      val -= CUR.phase;\n    }\n\n    return val;\n  }\n", "target": 0, "idx": 10208}
{"func": "exsltStrXpathCtxtRegister (xmlXPathContextPtr ctxt, const xmlChar *prefix)\n{\n    if (ctxt\n        && prefix\n        && !xmlXPathRegisterNs(ctxt,\n                               prefix,\n                               (const xmlChar *) EXSLT_STRINGS_NAMESPACE)\n        && !xmlXPathRegisterFuncNS(ctxt,\n                                   (const xmlChar *) \"encode-uri\",\n                                   (const xmlChar *) EXSLT_STRINGS_NAMESPACE,\n                                   exsltStrEncodeUriFunction)\n        && !xmlXPathRegisterFuncNS(ctxt,\n                                   (const xmlChar *) \"decode-uri\",\n                                   (const xmlChar *) EXSLT_STRINGS_NAMESPACE,\n                                   exsltStrDecodeUriFunction)\n        && !xmlXPathRegisterFuncNS(ctxt,\n                                   (const xmlChar *) \"padding\",\n                                   (const xmlChar *) EXSLT_STRINGS_NAMESPACE,\n                                   exsltStrPaddingFunction)\n        && !xmlXPathRegisterFuncNS(ctxt,\n                                   (const xmlChar *) \"align\",\n                                   (const xmlChar *) EXSLT_STRINGS_NAMESPACE,\n                                   exsltStrAlignFunction)\n         && !xmlXPathRegisterFuncNS(ctxt,\n                                    (const xmlChar *) \"concat\",\n                                    (const xmlChar *) EXSLT_STRINGS_NAMESPACE,\n                                   exsltStrConcatFunction)\n        && !xmlXPathRegisterFuncNS(ctxt,\n                                   (const xmlChar *) \"replace\",\n                                   (const xmlChar *) EXSLT_STRINGS_NAMESPACE,\n                                   exsltStrReplaceFunction)) {\n         return 0;\n     }\n     return -1;\n}\n", "target": 1, "idx": 187319}
{"func": "ZSTD_compressionParameters ZSTD_getCParams(int compressionLevel, unsigned long long srcSizeHint, size_t dictSize)\n{\n    size_t const addedSize = srcSizeHint ? 0 : 500;\n    U64 const rSize = srcSizeHint+dictSize ? srcSizeHint+dictSize+addedSize : (U64)-1;\n    U32 const tableID = (rSize <= 256 KB) + (rSize <= 128 KB) + (rSize <= 16 KB);   /* intentional underflow for srcSizeHint == 0 */\n    int row = compressionLevel;\n    DEBUGLOG(5, \"ZSTD_getCParams (cLevel=%i)\", compressionLevel);\n    if (compressionLevel == 0) row = ZSTD_CLEVEL_DEFAULT;   /* 0 == default */\n    if (compressionLevel < 0) row = 0;   /* entry 0 is baseline for fast mode */\n    if (compressionLevel > ZSTD_MAX_CLEVEL) row = ZSTD_MAX_CLEVEL;\n    {   ZSTD_compressionParameters cp = ZSTD_defaultCParameters[tableID][row];\n        if (compressionLevel < 0) cp.targetLength = (unsigned)(-compressionLevel);   /* acceleration factor */\n        return ZSTD_adjustCParams_internal(cp, srcSizeHint, dictSize); }\n\n}\n", "target": 0, "idx": 90072}
{"func": "qboolean FS_FileCompare( const char *s1, const char *s2 ) {\n\tFILE    *f1, *f2;\n\tint len1, len2, pos;\n\tbyte    *b1, *b2, *p1, *p2;\n\n\tf1 = fopen( s1, \"rb\" );\n\tif ( !f1 ) {\n\t\tCom_Error( ERR_FATAL, \"FS_FileCompare: %s does not exist\\n\", s1 );\n\t}\n\n\tf2 = fopen( s2, \"rb\" );\n\tif ( !f2 ) {  // this file is allowed to not be there, since it might not exist in the previous build\n\t\tfclose( f1 );\n\t\treturn qfalse;\n\t}\n\n\tpos = ftell( f1 );\n\tfseek( f1, 0, SEEK_END );\n\tlen1 = ftell( f1 );\n\tfseek( f1, pos, SEEK_SET );\n\n\tpos = ftell( f2 );\n\tfseek( f2, 0, SEEK_END );\n\tlen2 = ftell( f2 );\n\tfseek( f2, pos, SEEK_SET );\n\n\tif ( len1 != len2 ) {\n\t\tfclose( f1 );\n\t\tfclose( f2 );\n\t\treturn qfalse;\n\t}\n\n\tb1 = malloc( len1 );\n\tif ( fread( b1, 1, len1, f1 ) != len1 ) {\n\t\tCom_Error( ERR_FATAL, \"Short read in FS_FileCompare()\\n\" );\n\t}\n\tfclose( f1 );\n\n\tb2 = malloc( len2 );\n\tif ( fread( b2, 1, len2, f2 ) != len2 ) {\n\t\tCom_Error( ERR_FATAL, \"Short read in FS_FileCompare()\\n\" );\n\t}\n\tfclose( f2 );\n\n\tp1 = b1;\n\tp2 = b2;\n\tfor ( pos = 0; pos < len1; pos++, p1++, p2++ )\n\t{\n\t\tif ( *p1 != *p2 ) {\n\t\t\tfree( b1 );\n\t\t\tfree( b2 );\n\t\t\treturn qfalse;\n\t\t}\n\t}\n\n\tfree( b1 );\n\tfree( b2 );\n\treturn qtrue;\n}\n", "target": 0, "idx": 95910}
{"func": "static int __gup_device_huge_pmd(pmd_t orig, pmd_t *pmdp, unsigned long addr,\n\t\tunsigned long end, struct page **pages, int *nr)\n{\n\tBUILD_BUG();\n\treturn 0;\n}\n", "target": 0, "idx": 96936}
{"func": "json_array_element_text(PG_FUNCTION_ARGS)\n{\n\ttext\t   *json = PG_GETARG_TEXT_P(0);\n\tint\t\t\telement = PG_GETARG_INT32(1);\n\ttext\t   *result;\n\n\tresult = get_worker(json, NULL, &element, 1, true);\n\n\tif (result != NULL)\n\t\tPG_RETURN_TEXT_P(result);\n\telse\n\t\tPG_RETURN_NULL();\n}\n", "target": 0, "idx": 2598}
{"func": "static unsigned lodepng_get_bpp_lct(LodePNGColorType colortype, unsigned bitdepth)\n{\n  /*bits per pixel is amount of channels * bits per channel*/\n  return getNumColorChannels(colortype) * bitdepth;\n}\n", "target": 0, "idx": 87548}
{"func": "BuildTestPacket(uint16_t id, uint16_t off, int mf, const char content,\n    int content_len)\n {\n     Packet *p = NULL;\n     int hlen = 20;\n    int ttl = 64;\n    uint8_t *pcontent;\n    IPV4Hdr ip4h;\n\n    p = SCCalloc(1, sizeof(*p) + default_packet_size);\n    if (unlikely(p == NULL))\n        return NULL;\n\n    PACKET_INITIALIZE(p);\n\n    gettimeofday(&p->ts, NULL);\n    ip4h.ip_verhl = 4 << 4;\n    ip4h.ip_verhl |= hlen >> 2;\n    ip4h.ip_len = htons(hlen + content_len);\n    ip4h.ip_id = htons(id);\n    ip4h.ip_off = htons(off);\n    if (mf)\n        ip4h.ip_off = htons(IP_MF | off);\n     else\n         ip4h.ip_off = htons(off);\n     ip4h.ip_ttl = ttl;\n    ip4h.ip_proto = IPPROTO_ICMP;\n \n     ip4h.s_ip_src.s_addr = 0x01010101; /* 1.1.1.1 */\n     ip4h.s_ip_dst.s_addr = 0x02020202; /* 2.2.2.2 */\n\n    /* copy content_len crap, we need full length */\n    PacketCopyData(p, (uint8_t *)&ip4h, sizeof(ip4h));\n    p->ip4h = (IPV4Hdr *)GET_PKT_DATA(p);\n    SET_IPV4_SRC_ADDR(p, &p->src);\n    SET_IPV4_DST_ADDR(p, &p->dst);\n\n    pcontent = SCCalloc(1, content_len);\n    if (unlikely(pcontent == NULL))\n        return NULL;\n    memset(pcontent, content, content_len);\n    PacketCopyDataOffset(p, hlen, pcontent, content_len);\n    SET_PKT_LEN(p, hlen + content_len);\n    SCFree(pcontent);\n\n    p->ip4h->ip_csum = IPV4CalculateChecksum((uint16_t *)GET_PKT_DATA(p), hlen);\n\n    /* Self test. */\n    if (IPV4_GET_VER(p) != 4)\n        goto error;\n    if (IPV4_GET_HLEN(p) != hlen)\n        goto error;\n    if (IPV4_GET_IPLEN(p) != hlen + content_len)\n        goto error;\n    if (IPV4_GET_IPID(p) != id)\n        goto error;\n    if (IPV4_GET_IPOFFSET(p) != off)\n        goto error;\n    if (IPV4_GET_MF(p) != mf)\n         goto error;\n     if (IPV4_GET_IPTTL(p) != ttl)\n         goto error;\n    if (IPV4_GET_IPPROTO(p) != IPPROTO_ICMP)\n         goto error;\n \n     return p;\nerror:\n    if (p != NULL)\n        SCFree(p);\n    return NULL;\n}\n", "target": 1, "idx": 181466}
{"func": "void AppLayerProtoDetectSupportedIpprotos(AppProto alproto, uint8_t *ipprotos)\n{\n    SCEnter();\n\n    AppLayerProtoDetectPMGetIpprotos(alproto, ipprotos);\n    AppLayerProtoDetectPPGetIpprotos(alproto, ipprotos);\n    AppLayerProtoDetectPEGetIpprotos(alproto, ipprotos);\n\n    SCReturn;\n}\n", "target": 0, "idx": 96511}
{"func": "void SafeBrowsingBlockingPage::CommandReceived(const std::string& cmd) {\n  std::string command(cmd);  // Make a local copy so we can modify it.\n  if (command.length() > 1 && command[0] == '\"') {\n    command = command.substr(1, command.length() - 2);\n  }\n\n  if (command == kDoReportCommand) {\n    SetReportingPreference(true);\n    return;\n  }\n\n  if (command == kDontReportCommand) {\n    SetReportingPreference(false);\n    return;\n  }\n\n  if (command == kLearnMoreCommand) {\n    GURL url;\n    SafeBrowsingService::UrlCheckResult threat_type =\n        unsafe_resources_[0].threat_type;\n    if (threat_type == SafeBrowsingService::URL_MALWARE) {\n      url = google_util::AppendGoogleLocaleParam(GURL(kLearnMoreMalwareUrl));\n    } else if (threat_type == SafeBrowsingService::URL_PHISHING ||\n               threat_type == SafeBrowsingService::CLIENT_SIDE_PHISHING_URL) {\n      url = google_util::AppendGoogleLocaleParam(GURL(kLearnMorePhishingUrl));\n    } else {\n      NOTREACHED();\n    }\n    tab()->OpenURL(url, GURL(), CURRENT_TAB, content::PAGE_TRANSITION_LINK);\n    return;\n  }\n\n  if (command == kShowPrivacyCommand) {\n    GURL url(kSbPrivacyPolicyUrl);\n    tab()->OpenURL(url, GURL(), CURRENT_TAB, content::PAGE_TRANSITION_LINK);\n    return;\n  }\n\n  if (command == kProceedCommand) {\n    Proceed();\n    return;\n   }\n \n   if (command == kTakeMeBackCommand) {\n    DontProceed();\n     return;\n   }\n \n  int element_index = 0;\n  size_t colon_index = command.find(':');\n  if (colon_index != std::string::npos) {\n    DCHECK(colon_index < command.size() - 1);\n    bool result = base::StringToInt(base::StringPiece(command.begin() +\n                                                      colon_index + 1,\n                                                      command.end()),\n                                    &element_index);\n    command = command.substr(0, colon_index);\n    DCHECK(result);\n  }\n\n  if (element_index >= static_cast<int>(unsafe_resources_.size())) {\n    NOTREACHED();\n    return;\n  }\n\n  std::string bad_url_spec = unsafe_resources_[element_index].url.spec();\n  if (command == kReportErrorCommand) {\n    SafeBrowsingService::UrlCheckResult threat_type =\n        unsafe_resources_[element_index].threat_type;\n    DCHECK(threat_type == SafeBrowsingService::URL_PHISHING ||\n           threat_type == SafeBrowsingService::CLIENT_SIDE_PHISHING_URL);\n    GURL report_url =\n        safe_browsing_util::GeneratePhishingReportUrl(\n            kSbReportPhishingErrorUrl,\n            bad_url_spec,\n            threat_type == SafeBrowsingService::CLIENT_SIDE_PHISHING_URL);\n    tab()->OpenURL(\n        report_url, GURL(), CURRENT_TAB, content::PAGE_TRANSITION_LINK);\n    return;\n  }\n\n  if (command == kShowDiagnosticCommand) {\n    std::string diagnostic =\n        base::StringPrintf(kSbDiagnosticUrl,\n            net::EscapeQueryParamValue(bad_url_spec, true).c_str());\n    GURL diagnostic_url(diagnostic);\n    diagnostic_url = google_util::AppendGoogleLocaleParam(diagnostic_url);\n    DCHECK(unsafe_resources_[element_index].threat_type ==\n           SafeBrowsingService::URL_MALWARE);\n    tab()->OpenURL(\n        diagnostic_url, GURL(), CURRENT_TAB, content::PAGE_TRANSITION_LINK);\n    return;\n  }\n\n  NOTREACHED() << \"Unexpected command: \" << command;\n}\n", "target": 1, "idx": 184658}
{"func": "SYSCALL_DEFINE2(munlock, unsigned long, start, size_t, len)\n{\n\tint ret;\n\n\tlen = PAGE_ALIGN(len + (start & ~PAGE_MASK));\n\tstart &= PAGE_MASK;\n\n\tdown_write(&current->mm->mmap_sem);\n\tret = do_mlock(start, len, 0);\n\tup_write(&current->mm->mmap_sem);\n\n\treturn ret;\n}\n", "target": 0, "idx": 38262}
{"func": "void MockWebRTCPeerConnectionHandler::setLocalDescription(const WebRTCVoidRequest& request, const WebRTCSessionDescriptionDescriptor& localDescription)\n{\n    if (!localDescription.isNull() && localDescription.type() == \"offer\") {\n        m_localDescription = localDescription;\n        postTask(new RTCVoidRequestTask(this, request, true));\n    } else\n        postTask(new RTCVoidRequestTask(this, request, false));\n}\n", "target": 1, "idx": 183819}
{"func": "static void mip6_addr_swap(struct sk_buff *skb)\n{\n\tstruct ipv6hdr *iph = ipv6_hdr(skb);\n\tstruct inet6_skb_parm *opt = IP6CB(skb);\n\tstruct ipv6_destopt_hao *hao;\n\tstruct in6_addr tmp;\n\tint off;\n\n\tif (opt->dsthao) {\n\t\toff = ipv6_find_tlv(skb, opt->dsthao, IPV6_TLV_HAO);\n\t\tif (likely(off >= 0)) {\n\t\t\thao = (struct ipv6_destopt_hao *)\n\t\t\t\t\t(skb_network_header(skb) + off);\n\t\t\ttmp = iph->saddr;\n\t\t\tiph->saddr = hao->addr;\n\t\t\thao->addr = tmp;\n\t\t}\n\t}\n}\n", "target": 0, "idx": 47697}
{"func": "static void free_pg_vec(struct pgv *pg_vec, unsigned int order,\n\t\t\tunsigned int len)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (likely(pg_vec[i].buffer)) {\n\t\t\tif (is_vmalloc_addr(pg_vec[i].buffer))\n\t\t\t\tvfree(pg_vec[i].buffer);\n\t\t\telse\n\t\t\t\tfree_pages((unsigned long)pg_vec[i].buffer,\n\t\t\t\t\t   order);\n\t\t\tpg_vec[i].buffer = NULL;\n\t\t}\n\t}\n\tkfree(pg_vec);\n}\n", "target": 0, "idx": 26541}
{"func": "static int handle_goaway_frame(h2o_http2_conn_t *conn, h2o_http2_frame_t *frame, const char **err_desc)\n{\n    h2o_http2_goaway_payload_t payload;\n    int ret;\n\n    if ((ret = h2o_http2_decode_goaway_payload(&payload, frame, err_desc)) != 0)\n        return ret;\n\n    /* nothing to do, since we do not open new streams by ourselves */\n    return 0;\n}\n", "target": 0, "idx": 52560}
{"func": "void *gdImageJpegPtr (gdImagePtr im, int *size, int quality)\n {\n \tvoid *rv;\n \tgdIOCtx *out = gdNewDynamicCtx (2048, NULL);\n\tgdImageJpegCtx (im, out, quality);\n\trv = gdDPExtractData (out, size);\n \tout->gd_free (out);\n \n \treturn rv;\n}\n", "target": 1, "idx": 182908}
{"func": "SupportsType MimeUtil::IsSimpleCodecSupported(\n    const std::string& mime_type_lower_case,\n    Codec codec,\n    bool is_encrypted) const {\n  DCHECK_EQ(MimeUtilToVideoCodec(codec), kUnknownVideoCodec);\n \n   SupportsType result = IsCodecSupported(\n       mime_type_lower_case, codec, VIDEO_CODEC_PROFILE_UNKNOWN,\n      0 /* video_level */, gfx::ColorSpace::TransferID::INVALID, is_encrypted);\n \n  DCHECK_NE(result, MayBeSupported);\n  return result;\n}\n", "target": 1, "idx": 185895}
{"func": "PHP_FUNCTION(file_get_contents)\n{\n\tchar *filename;\n\tint filename_len;\n\tchar *contents;\n\tzend_bool use_include_path = 0;\n\tphp_stream *stream;\n\tlong len;\n\tlong offset = -1;\n\tlong maxlen = PHP_STREAM_COPY_ALL;\n\tzval *zcontext = NULL;\n\tphp_stream_context *context = NULL;\n\n\t/* Parse arguments */\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p|br!ll\", &filename, &filename_len, &use_include_path, &zcontext, &offset, &maxlen) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (ZEND_NUM_ARGS() == 5 && maxlen < 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"length must be greater than or equal to zero\");\n\t\tRETURN_FALSE;\n\t}\n\n\tcontext = php_stream_context_from_zval(zcontext, 0);\n\n\tstream = php_stream_open_wrapper_ex(filename, \"rb\",\n\t\t\t\t(use_include_path ? USE_PATH : 0) | REPORT_ERRORS,\n\t\t\t\tNULL, context);\n\tif (!stream) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (offset > 0 && php_stream_seek(stream, offset, SEEK_SET) < 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Failed to seek to position %ld in the stream\", offset);\n\t\tphp_stream_close(stream);\n\t\tRETURN_FALSE;\n\t}\n\n\tif ((len = php_stream_copy_to_mem(stream, &contents, maxlen, 0)) > 0) {\n\t\tif (len > INT_MAX) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"content truncated from %ld to %d bytes\", len, INT_MAX);\n\t\t\tlen = INT_MAX;\n\t\t}\n\t\tRETVAL_STRINGL(contents, len, 0);\n\t} else if (len == 0) {\n\t\tRETVAL_EMPTY_STRING();\n\t} else {\n\t\tRETVAL_FALSE;\n\t}\n\n\tphp_stream_close(stream);\n}\n", "target": 0, "idx": 52147}
{"func": " PPB_URLLoader_Impl::~PPB_URLLoader_Impl() {\n }\n", "target": 1, "idx": 184221}
{"func": "void GraphicsContext::strokeArc(const IntRect& rect, int startAngle, int angleSpan)\n{\n    if (paintingDisabled())\n         return;\n     \n     m_data->context->SetPen(wxPen(strokeColor(), strokeThickness(), strokeStyleToWxPenStyle(strokeStyle())));\n    m_data->context->DrawEllipticArc(rect.x(), rect.y(), rect.width(), rect.height(), startAngle, angleSpan);\n }\n", "target": 1, "idx": 183884}
{"func": " void bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n \t{\n\tBN_ULONG t1,t2;\n \tBN_ULONG c1,c2,c3;\n \n \tc1=0;\n\tc2=0;\n\tc3=0;\n\tmul_add_c(a[0],b[0],c1,c2,c3);\n\tr[0]=c1;\n\tc1=0;\n\tmul_add_c(a[0],b[1],c2,c3,c1);\n\tmul_add_c(a[1],b[0],c2,c3,c1);\n\tr[1]=c2;\n\tc2=0;\n\tmul_add_c(a[2],b[0],c3,c1,c2);\n\tmul_add_c(a[1],b[1],c3,c1,c2);\n\tmul_add_c(a[0],b[2],c3,c1,c2);\n\tr[2]=c3;\n\tc3=0;\n\tmul_add_c(a[0],b[3],c1,c2,c3);\n\tmul_add_c(a[1],b[2],c1,c2,c3);\n\tmul_add_c(a[2],b[1],c1,c2,c3);\n\tmul_add_c(a[3],b[0],c1,c2,c3);\n\tr[3]=c1;\n\tc1=0;\n\tmul_add_c(a[4],b[0],c2,c3,c1);\n\tmul_add_c(a[3],b[1],c2,c3,c1);\n\tmul_add_c(a[2],b[2],c2,c3,c1);\n\tmul_add_c(a[1],b[3],c2,c3,c1);\n\tmul_add_c(a[0],b[4],c2,c3,c1);\n\tr[4]=c2;\n\tc2=0;\n\tmul_add_c(a[0],b[5],c3,c1,c2);\n\tmul_add_c(a[1],b[4],c3,c1,c2);\n\tmul_add_c(a[2],b[3],c3,c1,c2);\n\tmul_add_c(a[3],b[2],c3,c1,c2);\n\tmul_add_c(a[4],b[1],c3,c1,c2);\n\tmul_add_c(a[5],b[0],c3,c1,c2);\n\tr[5]=c3;\n\tc3=0;\n\tmul_add_c(a[6],b[0],c1,c2,c3);\n\tmul_add_c(a[5],b[1],c1,c2,c3);\n\tmul_add_c(a[4],b[2],c1,c2,c3);\n\tmul_add_c(a[3],b[3],c1,c2,c3);\n\tmul_add_c(a[2],b[4],c1,c2,c3);\n\tmul_add_c(a[1],b[5],c1,c2,c3);\n\tmul_add_c(a[0],b[6],c1,c2,c3);\n\tr[6]=c1;\n\tc1=0;\n\tmul_add_c(a[0],b[7],c2,c3,c1);\n\tmul_add_c(a[1],b[6],c2,c3,c1);\n\tmul_add_c(a[2],b[5],c2,c3,c1);\n\tmul_add_c(a[3],b[4],c2,c3,c1);\n\tmul_add_c(a[4],b[3],c2,c3,c1);\n\tmul_add_c(a[5],b[2],c2,c3,c1);\n\tmul_add_c(a[6],b[1],c2,c3,c1);\n\tmul_add_c(a[7],b[0],c2,c3,c1);\n\tr[7]=c2;\n\tc2=0;\n\tmul_add_c(a[7],b[1],c3,c1,c2);\n\tmul_add_c(a[6],b[2],c3,c1,c2);\n\tmul_add_c(a[5],b[3],c3,c1,c2);\n\tmul_add_c(a[4],b[4],c3,c1,c2);\n\tmul_add_c(a[3],b[5],c3,c1,c2);\n\tmul_add_c(a[2],b[6],c3,c1,c2);\n\tmul_add_c(a[1],b[7],c3,c1,c2);\n\tr[8]=c3;\n\tc3=0;\n\tmul_add_c(a[2],b[7],c1,c2,c3);\n\tmul_add_c(a[3],b[6],c1,c2,c3);\n\tmul_add_c(a[4],b[5],c1,c2,c3);\n\tmul_add_c(a[5],b[4],c1,c2,c3);\n\tmul_add_c(a[6],b[3],c1,c2,c3);\n\tmul_add_c(a[7],b[2],c1,c2,c3);\n\tr[9]=c1;\n\tc1=0;\n\tmul_add_c(a[7],b[3],c2,c3,c1);\n\tmul_add_c(a[6],b[4],c2,c3,c1);\n\tmul_add_c(a[5],b[5],c2,c3,c1);\n\tmul_add_c(a[4],b[6],c2,c3,c1);\n\tmul_add_c(a[3],b[7],c2,c3,c1);\n\tr[10]=c2;\n\tc2=0;\n\tmul_add_c(a[4],b[7],c3,c1,c2);\n\tmul_add_c(a[5],b[6],c3,c1,c2);\n\tmul_add_c(a[6],b[5],c3,c1,c2);\n\tmul_add_c(a[7],b[4],c3,c1,c2);\n\tr[11]=c3;\n\tc3=0;\n\tmul_add_c(a[7],b[5],c1,c2,c3);\n\tmul_add_c(a[6],b[6],c1,c2,c3);\n\tmul_add_c(a[5],b[7],c1,c2,c3);\n\tr[12]=c1;\n\tc1=0;\n\tmul_add_c(a[6],b[7],c2,c3,c1);\n\tmul_add_c(a[7],b[6],c2,c3,c1);\n\tr[13]=c2;\n\tc2=0;\n\tmul_add_c(a[7],b[7],c3,c1,c2);\n\tr[14]=c3;\n\tr[15]=c1;\n\t}\n", "target": 1, "idx": 180001}
{"func": "CMD_FUNC(m_svslogin)\n{\n\tif (!SASL_SERVER || MyClient(sptr) || (parc < 3) || !parv[3])\n\t\treturn 0;\n\n\tif (!stricmp(parv[1], me.name))\n\t{\n\t\taClient *target_p;\n\n\t\t/* is the PUID valid? */\n\t\tif ((target_p = decode_puid(parv[2])) == NULL)\n\t\t\treturn 0;\n\n\t\tif (target_p->user == NULL)\n\t\t\tmake_user(target_p);\n\n\t\tstrlcpy(target_p->user->svid, parv[3], sizeof(target_p->user->svid));\n\n\t\tsendto_one(target_p, err_str(RPL_LOGGEDIN), me.name,\n\t\t\t   BadPtr(target_p->name) ? \"*\" : target_p->name,\n\t\t\t   BadPtr(target_p->name) ? \"*\" : target_p->name,\n\t\t\t   BadPtr(target_p->user->username) ? \"*\" : target_p->user->username,\n\t\t\t   BadPtr(target_p->user->realhost) ? \"*\" : target_p->user->realhost,\n\t\t\t   target_p->user->svid, target_p->user->svid);\n\n\t\treturn 0;\n\t}\n\n\t/* not for us; propagate. */\n\tsendto_server(cptr, 0, 0, \":%s SVSLOGIN %s %s %s\",\n\t    sptr->name, parv[1], parv[2], parv[3]);\n\n\treturn 0;\n}\n", "target": 0, "idx": 73709}
{"func": "void ContentSuggestionsNotifierService::RegisterProfilePrefs(\n     user_prefs::PrefRegistrySyncable* registry) {\n   registry->RegisterIntegerPref(\n       prefs::kContentSuggestionsConsecutiveIgnoredPrefName, 0);\n \n   registry->RegisterStringPref(kNotificationIDWithinCategory, std::string());\n}\n", "target": 1, "idx": 185947}
{"func": "static void shrink_halt_poll_ns(struct kvm_vcpu *vcpu)\n{\n\tunsigned int old, val, shrink;\n\n\told = val = vcpu->halt_poll_ns;\n\tshrink = READ_ONCE(halt_poll_ns_shrink);\n\tif (shrink == 0)\n\t\tval = 0;\n\telse\n\t\tval /= shrink;\n\n\tvcpu->halt_poll_ns = val;\n\ttrace_kvm_halt_poll_ns_shrink(vcpu->vcpu_id, val, old);\n}\n", "target": 0, "idx": 71276}
{"func": "update_stats_dequeue(struct cfs_rq *cfs_rq, struct sched_entity *se, int flags)\n{\n\n\tif (!schedstat_enabled())\n\t\treturn;\n\n\t/*\n\t * Mark the end of the wait period if dequeueing a\n\t * waiting task:\n\t */\n\tif (se != cfs_rq->curr)\n\t\tupdate_stats_wait_end(cfs_rq, se);\n\n\tif ((flags & DEQUEUE_SLEEP) && entity_is_task(se)) {\n\t\tstruct task_struct *tsk = task_of(se);\n\n\t\tif (tsk->state & TASK_INTERRUPTIBLE)\n\t\t\t__schedstat_set(se->statistics.sleep_start,\n\t\t\t\t      rq_clock(rq_of(cfs_rq)));\n\t\tif (tsk->state & TASK_UNINTERRUPTIBLE)\n\t\t\t__schedstat_set(se->statistics.block_start,\n\t\t\t\t      rq_clock(rq_of(cfs_rq)));\n\t}\n}\n", "target": 0, "idx": 92774}
{"func": "MYSQLND_METHOD(mysqlnd_conn_data, set_server_option)(MYSQLND_CONN_DATA * const conn, enum_mysqlnd_server_option option TSRMLS_DC)\n{\n\tsize_t this_func = STRUCT_OFFSET(struct st_mysqlnd_conn_data_methods, set_server_option);\n\tzend_uchar buffer[2];\n\tenum_func_status ret = FAIL;\n\tDBG_ENTER(\"mysqlnd_conn_data::set_server_option\");\n\tif (PASS == conn->m->local_tx_start(conn, this_func TSRMLS_CC)) {\n \n                int2store(buffer, (unsigned int) option);\n                ret = conn->m->simple_command(conn, COM_SET_OPTION, buffer, sizeof(buffer), PROT_EOF_PACKET, FALSE, TRUE TSRMLS_CC);\n                conn->m->local_tx_end(conn, this_func, ret TSRMLS_CC);\n        }\n        DBG_RETURN(ret);\n}\n", "target": 1, "idx": 178446}
{"func": "static MagickBooleanType WritePICTImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n#define MaxCount  128\n#define PictCropRegionOp  0x01\n#define PictEndOfPictureOp  0xff\n#define PictJPEGOp  0x8200\n#define PictInfoOp  0x0C00\n#define PictInfoSize  512\n#define PictPixmapOp  0x9A\n#define PictPICTOp  0x98\n#define PictVersion  0x11\n\n  const StringInfo\n    *profile;\n\n  double\n    x_resolution,\n    y_resolution;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  PICTPixmap\n    pixmap;\n\n  PICTRectangle\n    bounds,\n    crop_rectangle,\n    destination_rectangle,\n    frame_rectangle,\n    size_rectangle,\n    source_rectangle;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n   size_t\n     bytes_per_line,\n     count,\n     storage_class;\n \n   ssize_t\n    y;\n\n  unsigned char\n    *buffer,\n    *packed_scanline,\n    *scanline;\n \n   unsigned short\n     base_address,\n    row_bytes,\n     transfer_mode;\n \n   /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if ((image->columns > 65535L) || (image->rows > 65535L))\n    ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) TransformImageColorspace(image,sRGBColorspace,exception);\n  /*\n    Initialize image info.\n  */\n  size_rectangle.top=0;\n  size_rectangle.left=0;\n  size_rectangle.bottom=(short) image->rows;\n  size_rectangle.right=(short) image->columns;\n  frame_rectangle=size_rectangle;\n  crop_rectangle=size_rectangle;\n   source_rectangle=size_rectangle;\n   destination_rectangle=size_rectangle;\n   base_address=0xff;\n  row_bytes=(unsigned short) (image->columns | 0x8000);\n   bounds.top=0;\n   bounds.left=0;\n   bounds.bottom=(short) image->rows;\n  bounds.right=(short) image->columns;\n  pixmap.version=0;\n  pixmap.pack_type=0;\n  pixmap.pack_size=0;\n  pixmap.pixel_type=0;\n  pixmap.bits_per_pixel=8;\n  pixmap.component_count=1;\n  pixmap.component_size=8;\n  pixmap.plane_bytes=0;\n  pixmap.table=0;\n  pixmap.reserved=0;\n  transfer_mode=0;\n  x_resolution=image->resolution.x != 0.0 ? image->resolution.x :\n    DefaultResolution;\n  y_resolution=image->resolution.y != 0.0 ? image->resolution.y :\n    DefaultResolution;\n  storage_class=image->storage_class;\n  if (image_info->compression == JPEGCompression)\n    storage_class=DirectClass;\n  if (storage_class == DirectClass)\n    {\n      pixmap.component_count=image->alpha_trait != UndefinedPixelTrait ? 4 : 3;\n      pixmap.pixel_type=16;\n       pixmap.bits_per_pixel=32;\n       pixmap.pack_type=0x04;\n       transfer_mode=0x40;\n      row_bytes=(unsigned short) ((4*image->columns) | 0x8000);\n     }\n   /*\n     Allocate memory.\n  */\n  bytes_per_line=image->columns;\n  if (storage_class == DirectClass)\n    bytes_per_line*=image->alpha_trait != UndefinedPixelTrait ? 4 : 3;\n  buffer=(unsigned char *) AcquireQuantumMemory(PictInfoSize,sizeof(*buffer));\n  packed_scanline=(unsigned char *) AcquireQuantumMemory((size_t)\n   (row_bytes+MaxCount),sizeof(*packed_scanline));\n  scanline=(unsigned char *) AcquireQuantumMemory(row_bytes,sizeof(*scanline));\n  if ((buffer == (unsigned char *) NULL) ||\n      (packed_scanline == (unsigned char *) NULL) ||\n      (scanline == (unsigned char *) NULL))\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(scanline,0,row_bytes);\n  (void) ResetMagickMemory(packed_scanline,0,(size_t) (row_bytes+MaxCount));\n  /*\n    Write header, header size, size bounding box, version, and reserved.\n  */\n  (void) ResetMagickMemory(buffer,0,PictInfoSize);\n  (void) WriteBlob(image,PictInfoSize,buffer);\n  (void) WriteBlobMSBShort(image,0);\n  (void) WriteBlobMSBShort(image,(unsigned short) size_rectangle.top);\n  (void) WriteBlobMSBShort(image,(unsigned short) size_rectangle.left);\n  (void) WriteBlobMSBShort(image,(unsigned short) size_rectangle.bottom);\n  (void) WriteBlobMSBShort(image,(unsigned short) size_rectangle.right);\n  (void) WriteBlobMSBShort(image,PictVersion);\n  (void) WriteBlobMSBShort(image,0x02ff);  /* version #2 */\n  (void) WriteBlobMSBShort(image,PictInfoOp);\n  (void) WriteBlobMSBLong(image,0xFFFE0000UL);\n  /*\n    Write full size of the file, resolution, frame bounding box, and reserved.\n  */\n  (void) WriteBlobMSBShort(image,(unsigned short) x_resolution);\n  (void) WriteBlobMSBShort(image,0x0000);\n  (void) WriteBlobMSBShort(image,(unsigned short) y_resolution);\n  (void) WriteBlobMSBShort(image,0x0000);\n  (void) WriteBlobMSBShort(image,(unsigned short) frame_rectangle.top);\n  (void) WriteBlobMSBShort(image,(unsigned short) frame_rectangle.left);\n  (void) WriteBlobMSBShort(image,(unsigned short) frame_rectangle.bottom);\n  (void) WriteBlobMSBShort(image,(unsigned short) frame_rectangle.right);\n  (void) WriteBlobMSBLong(image,0x00000000L);\n  profile=GetImageProfile(image,\"iptc\");\n  if (profile != (StringInfo *) NULL)\n    {\n      (void) WriteBlobMSBShort(image,0xa1);\n      (void) WriteBlobMSBShort(image,0x1f2);\n      (void) WriteBlobMSBShort(image,(unsigned short)\n        (GetStringInfoLength(profile)+4));\n      (void) WriteBlobString(image,\"8BIM\");\n      (void) WriteBlob(image,GetStringInfoLength(profile),\n        GetStringInfoDatum(profile));\n    }\n  profile=GetImageProfile(image,\"icc\");\n  if (profile != (StringInfo *) NULL)\n    {\n      (void) WriteBlobMSBShort(image,0xa1);\n      (void) WriteBlobMSBShort(image,0xe0);\n      (void) WriteBlobMSBShort(image,(unsigned short)\n        (GetStringInfoLength(profile)+4));\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlob(image,GetStringInfoLength(profile),\n        GetStringInfoDatum(profile));\n      (void) WriteBlobMSBShort(image,0xa1);\n      (void) WriteBlobMSBShort(image,0xe0);\n      (void) WriteBlobMSBShort(image,4);\n      (void) WriteBlobMSBLong(image,0x00000002UL);\n    }\n  /*\n    Write crop region opcode and crop bounding box.\n  */\n  (void) WriteBlobMSBShort(image,PictCropRegionOp);\n  (void) WriteBlobMSBShort(image,0xa);\n  (void) WriteBlobMSBShort(image,(unsigned short) crop_rectangle.top);\n  (void) WriteBlobMSBShort(image,(unsigned short) crop_rectangle.left);\n  (void) WriteBlobMSBShort(image,(unsigned short) crop_rectangle.bottom);\n  (void) WriteBlobMSBShort(image,(unsigned short) crop_rectangle.right);\n  if (image_info->compression == JPEGCompression)\n    {\n      Image\n        *jpeg_image;\n\n      ImageInfo\n        *jpeg_info;\n\n      size_t\n        length;\n\n      unsigned char\n        *blob;\n\n      jpeg_image=CloneImage(image,0,0,MagickTrue,exception);\n      if (jpeg_image == (Image *) NULL)\n        {\n          (void) CloseBlob(image);\n          return(MagickFalse);\n        }\n      jpeg_info=CloneImageInfo(image_info);\n      (void) CopyMagickString(jpeg_info->magick,\"JPEG\",MagickPathExtent);\n      length=0;\n      blob=(unsigned char *) ImageToBlob(jpeg_info,jpeg_image,&length,\n        exception);\n      jpeg_info=DestroyImageInfo(jpeg_info);\n      if (blob == (unsigned char *) NULL)\n        return(MagickFalse);\n      jpeg_image=DestroyImage(jpeg_image);\n      (void) WriteBlobMSBShort(image,PictJPEGOp);\n      (void) WriteBlobMSBLong(image,(unsigned int) length+154);\n      (void) WriteBlobMSBShort(image,0x0000);\n      (void) WriteBlobMSBLong(image,0x00010000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00010000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x40000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00400000UL);\n      (void) WriteBlobMSBShort(image,0x0000);\n      (void) WriteBlobMSBShort(image,(unsigned short) image->rows);\n      (void) WriteBlobMSBShort(image,(unsigned short) image->columns);\n      (void) WriteBlobMSBShort(image,0x0000);\n      (void) WriteBlobMSBShort(image,768);\n      (void) WriteBlobMSBShort(image,0x0000);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00566A70UL);\n      (void) WriteBlobMSBLong(image,0x65670000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000001UL);\n      (void) WriteBlobMSBLong(image,0x00016170UL);\n      (void) WriteBlobMSBLong(image,0x706C0000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBShort(image,768);\n      (void) WriteBlobMSBShort(image,(unsigned short) image->columns);\n      (void) WriteBlobMSBShort(image,(unsigned short) image->rows);\n      (void) WriteBlobMSBShort(image,(unsigned short) x_resolution);\n      (void) WriteBlobMSBShort(image,0x0000);\n      (void) WriteBlobMSBShort(image,(unsigned short) y_resolution);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x87AC0001UL);\n      (void) WriteBlobMSBLong(image,0x0B466F74UL);\n      (void) WriteBlobMSBLong(image,0x6F202D20UL);\n      (void) WriteBlobMSBLong(image,0x4A504547UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x0018FFFFUL);\n      (void) WriteBlob(image,length,blob);\n      if ((length & 0x01) != 0)\n        (void) WriteBlobByte(image,'\\0');\n      blob=(unsigned char *) RelinquishMagickMemory(blob);\n    }\n  /*\n    Write picture opcode, row bytes, and picture bounding box, and version.\n  */\n  if (storage_class == PseudoClass)\n    (void) WriteBlobMSBShort(image,PictPICTOp);\n  else\n    {\n      (void) WriteBlobMSBShort(image,PictPixmapOp);\n      (void) WriteBlobMSBLong(image,(size_t) base_address);\n    }\n  (void) WriteBlobMSBShort(image,(unsigned short) (row_bytes | 0x8000));\n  (void) WriteBlobMSBShort(image,(unsigned short) bounds.top);\n  (void) WriteBlobMSBShort(image,(unsigned short) bounds.left);\n  (void) WriteBlobMSBShort(image,(unsigned short) bounds.bottom);\n  (void) WriteBlobMSBShort(image,(unsigned short) bounds.right);\n  /*\n    Write pack type, pack size, resolution, pixel type, and pixel size.\n  */\n  (void) WriteBlobMSBShort(image,(unsigned short) pixmap.version);\n  (void) WriteBlobMSBShort(image,(unsigned short) pixmap.pack_type);\n  (void) WriteBlobMSBLong(image,(unsigned int) pixmap.pack_size);\n  (void) WriteBlobMSBShort(image,(unsigned short) (x_resolution+0.5));\n  (void) WriteBlobMSBShort(image,0x0000);\n  (void) WriteBlobMSBShort(image,(unsigned short) (y_resolution+0.5));\n  (void) WriteBlobMSBShort(image,0x0000);\n  (void) WriteBlobMSBShort(image,(unsigned short) pixmap.pixel_type);\n  (void) WriteBlobMSBShort(image,(unsigned short) pixmap.bits_per_pixel);\n  /*\n    Write component count, size, plane bytes, table size, and reserved.\n  */\n  (void) WriteBlobMSBShort(image,(unsigned short) pixmap.component_count);\n  (void) WriteBlobMSBShort(image,(unsigned short) pixmap.component_size);\n  (void) WriteBlobMSBLong(image,(unsigned int) pixmap.plane_bytes);\n  (void) WriteBlobMSBLong(image,(unsigned int) pixmap.table);\n  (void) WriteBlobMSBLong(image,(unsigned int) pixmap.reserved);\n  if (storage_class == PseudoClass)\n    {\n      /*\n        Write image colormap.\n      */\n      (void) WriteBlobMSBLong(image,0x00000000L);  /* color seed */\n      (void) WriteBlobMSBShort(image,0L);  /* color flags */\n      (void) WriteBlobMSBShort(image,(unsigned short) (image->colors-1));\n      for (i=0; i < (ssize_t) image->colors; i++)\n      {\n        (void) WriteBlobMSBShort(image,(unsigned short) i);\n        (void) WriteBlobMSBShort(image,ScaleQuantumToShort(\n          image->colormap[i].red));\n        (void) WriteBlobMSBShort(image,ScaleQuantumToShort(\n          image->colormap[i].green));\n        (void) WriteBlobMSBShort(image,ScaleQuantumToShort(\n          image->colormap[i].blue));\n      }\n    }\n  /*\n    Write source and destination rectangle.\n  */\n  (void) WriteBlobMSBShort(image,(unsigned short) source_rectangle.top);\n  (void) WriteBlobMSBShort(image,(unsigned short) source_rectangle.left);\n  (void) WriteBlobMSBShort(image,(unsigned short) source_rectangle.bottom);\n  (void) WriteBlobMSBShort(image,(unsigned short) source_rectangle.right);\n  (void) WriteBlobMSBShort(image,(unsigned short) destination_rectangle.top);\n  (void) WriteBlobMSBShort(image,(unsigned short) destination_rectangle.left);\n  (void) WriteBlobMSBShort(image,(unsigned short) destination_rectangle.bottom);\n  (void) WriteBlobMSBShort(image,(unsigned short) destination_rectangle.right);\n  (void) WriteBlobMSBShort(image,(unsigned short) transfer_mode);\n  /*\n    Write picture data.\n  */\n  count=0;\n  if (storage_class == PseudoClass)\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n      if (p == (const Quantum *) NULL)\n        break;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        scanline[x]=(unsigned char) GetPixelIndex(image,p);\n        p+=GetPixelChannels(image);\n      }\n      count+=EncodeImage(image,scanline,(size_t) (row_bytes & 0x7FFF),\n        packed_scanline);\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n  else\n    if (image_info->compression == JPEGCompression)\n      {\n        (void) ResetMagickMemory(scanline,0,row_bytes);\n        for (y=0; y < (ssize_t) image->rows; y++)\n          count+=EncodeImage(image,scanline,(size_t) (row_bytes & 0x7FFF),\n            packed_scanline);\n      }\n    else\n      {\n        register unsigned char\n          *blue,\n          *green,\n          *opacity,\n          *red;\n\n        red=scanline;\n        green=scanline+image->columns;\n        blue=scanline+2*image->columns;\n        opacity=scanline+3*image->columns;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          red=scanline;\n          green=scanline+image->columns;\n          blue=scanline+2*image->columns;\n          if (image->alpha_trait != UndefinedPixelTrait)\n            {\n              opacity=scanline;\n              red=scanline+image->columns;\n              green=scanline+2*image->columns;\n              blue=scanline+3*image->columns;\n            }\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *red++=ScaleQuantumToChar(GetPixelRed(image,p));\n            *green++=ScaleQuantumToChar(GetPixelGreen(image,p));\n            *blue++=ScaleQuantumToChar(GetPixelBlue(image,p));\n            if (image->alpha_trait != UndefinedPixelTrait)\n              *opacity++=ScaleQuantumToChar((Quantum) (GetPixelAlpha(image,p)));\n            p+=GetPixelChannels(image);\n          }\n          count+=EncodeImage(image,scanline,bytes_per_line & 0x7FFF,\n            packed_scanline);\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n  if ((count & 0x01) != 0)\n    (void) WriteBlobByte(image,'\\0');\n  (void) WriteBlobMSBShort(image,PictEndOfPictureOp);\n  offset=TellBlob(image);\n  offset=SeekBlob(image,512,SEEK_SET);\n  (void) WriteBlobMSBShort(image,(unsigned short) offset);\n  scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n  packed_scanline=(unsigned char *) RelinquishMagickMemory(packed_scanline);\n  buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n", "target": 1, "idx": 182036}
{"func": "void ImageBitmapFactories::ImageBitmapLoader::ResolvePromiseOnOriginalThread(\n    sk_sp<SkImage> frame) {\n  if (!frame) {\n    RejectPromise(kUndecodableImageBitmapRejectionReason);\n    return;\n  }\n  DCHECK(frame->width());\n  DCHECK(frame->height());\n\n  scoped_refptr<StaticBitmapImage> image =\n      StaticBitmapImage::Create(std::move(frame));\n  image->SetOriginClean(true);\n  ImageBitmap* image_bitmap = ImageBitmap::Create(image, crop_rect_, options_);\n  if (image_bitmap && image_bitmap->BitmapImage()) {\n    resolver_->Resolve(image_bitmap);\n  } else {\n    RejectPromise(kAllocationFailureImageBitmapRejectionReason);\n    return;\n  }\n  factory_->DidFinishLoading(this);\n }\n", "target": 0, "idx": 165856}
{"func": "exit_ext2_xattr(void)\n {\n\tmb_cache_destroy(ext2_xattr_cache);\n }\n", "target": 1, "idx": 183148}
{"func": "static size_t rtnl_link_get_af_size(const struct net_device *dev,\n\t\t\t\t    u32 ext_filter_mask)\n{\n\tstruct rtnl_af_ops *af_ops;\n\tsize_t size;\n\n\t/* IFLA_AF_SPEC */\n\tsize = nla_total_size(sizeof(struct nlattr));\n\n\tlist_for_each_entry(af_ops, &rtnl_af_ops, list) {\n\t\tif (af_ops->get_link_af_size) {\n\t\t\t/* AF_* + nested data */\n\t\t\tsize += nla_total_size(sizeof(struct nlattr)) +\n\t\t\t\taf_ops->get_link_af_size(dev, ext_filter_mask);\n\t\t}\n\t}\n\n\treturn size;\n}\n", "target": 0, "idx": 53164}
{"func": "void ff_avg_pixels16x16_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\n{\n    avg_pixels16_8_c(dst, src, stride, 16);\n}\n", "target": 0, "idx": 28116}
{"func": "bool VaapiVideoDecodeAccelerator::VaapiH264Accelerator::SubmitSlice(\n    const media::H264PPS* pps,\n    const media::H264SliceHeader* slice_hdr,\n    const H264Picture::Vector& ref_pic_list0,\n    const H264Picture::Vector& ref_pic_list1,\n    const scoped_refptr<H264Picture>& pic,\n    const uint8_t* data,\n    size_t size) {\n  VASliceParameterBufferH264 slice_param;\n  memset(&slice_param, 0, sizeof(slice_param));\n\n  slice_param.slice_data_size = slice_hdr->nalu_size;\n  slice_param.slice_data_offset = 0;\n   slice_param.slice_data_flag = VA_SLICE_DATA_FLAG_ALL;\n   slice_param.slice_data_bit_offset = slice_hdr->header_bit_size;\n \n#define SHDRToSP(a) slice_param.a = slice_hdr->a\n   SHDRToSP(first_mb_in_slice);\n   slice_param.slice_type = slice_hdr->slice_type % 5;\n   SHDRToSP(direct_spatial_mv_pred_flag);\n\n  SHDRToSP(num_ref_idx_l0_active_minus1);\n  SHDRToSP(num_ref_idx_l1_active_minus1);\n  SHDRToSP(cabac_init_idc);\n  SHDRToSP(slice_qp_delta);\n  SHDRToSP(disable_deblocking_filter_idc);\n  SHDRToSP(slice_alpha_c0_offset_div2);\n  SHDRToSP(slice_beta_offset_div2);\n\n  if (((slice_hdr->IsPSlice() || slice_hdr->IsSPSlice()) &&\n       pps->weighted_pred_flag) ||\n      (slice_hdr->IsBSlice() && pps->weighted_bipred_idc == 1)) {\n    SHDRToSP(luma_log2_weight_denom);\n    SHDRToSP(chroma_log2_weight_denom);\n\n    SHDRToSP(luma_weight_l0_flag);\n    SHDRToSP(luma_weight_l1_flag);\n\n    SHDRToSP(chroma_weight_l0_flag);\n    SHDRToSP(chroma_weight_l1_flag);\n\n    for (int i = 0; i <= slice_param.num_ref_idx_l0_active_minus1; ++i) {\n      slice_param.luma_weight_l0[i] =\n          slice_hdr->pred_weight_table_l0.luma_weight[i];\n      slice_param.luma_offset_l0[i] =\n          slice_hdr->pred_weight_table_l0.luma_offset[i];\n\n      for (int j = 0; j < 2; ++j) {\n        slice_param.chroma_weight_l0[i][j] =\n            slice_hdr->pred_weight_table_l0.chroma_weight[i][j];\n        slice_param.chroma_offset_l0[i][j] =\n            slice_hdr->pred_weight_table_l0.chroma_offset[i][j];\n      }\n    }\n\n    if (slice_hdr->IsBSlice()) {\n      for (int i = 0; i <= slice_param.num_ref_idx_l1_active_minus1; ++i) {\n        slice_param.luma_weight_l1[i] =\n            slice_hdr->pred_weight_table_l1.luma_weight[i];\n        slice_param.luma_offset_l1[i] =\n            slice_hdr->pred_weight_table_l1.luma_offset[i];\n\n        for (int j = 0; j < 2; ++j) {\n          slice_param.chroma_weight_l1[i][j] =\n              slice_hdr->pred_weight_table_l1.chroma_weight[i][j];\n          slice_param.chroma_offset_l1[i][j] =\n              slice_hdr->pred_weight_table_l1.chroma_offset[i][j];\n        }\n      }\n    }\n  }\n\n  static_assert(\n      arraysize(slice_param.RefPicList0) == arraysize(slice_param.RefPicList1),\n      \"Invalid RefPicList sizes\");\n\n  for (size_t i = 0; i < arraysize(slice_param.RefPicList0); ++i) {\n    InitVAPicture(&slice_param.RefPicList0[i]);\n    InitVAPicture(&slice_param.RefPicList1[i]);\n  }\n\n  for (size_t i = 0;\n       i < ref_pic_list0.size() && i < arraysize(slice_param.RefPicList0);\n       ++i) {\n    if (ref_pic_list0[i])\n      FillVAPicture(&slice_param.RefPicList0[i], ref_pic_list0[i]);\n  }\n  for (size_t i = 0;\n       i < ref_pic_list1.size() && i < arraysize(slice_param.RefPicList1);\n       ++i) {\n    if (ref_pic_list1[i])\n      FillVAPicture(&slice_param.RefPicList1[i], ref_pic_list1[i]);\n  }\n\n  if (!vaapi_wrapper_->SubmitBuffer(VASliceParameterBufferType,\n                                    sizeof(slice_param),\n                                    &slice_param))\n    return false;\n\n  void* non_const_ptr = const_cast<uint8*>(data);\n  return vaapi_wrapper_->SubmitBuffer(VASliceDataBufferType, size,\n                                      non_const_ptr);\n}\n", "target": 1, "idx": 183524}
{"func": "EventQueue* Document::getEventQueue() const\n{\n    if (!m_domWindow)\n        return 0;\n    return m_domWindow->getEventQueue();\n}\n", "target": 0, "idx": 143195}
{"func": "void bdrv_swap(BlockDriverState *bs_new, BlockDriverState *bs_old)\n{\n    BlockDriverState tmp;\n\n    /* The code needs to swap the node_name but simply swapping node_list won't\n     * work so first remove the nodes from the graph list, do the swap then\n     * insert them back if needed.\n     */\n    if (bs_new->node_name[0] != '\\0') {\n        QTAILQ_REMOVE(&graph_bdrv_states, bs_new, node_list);\n    }\n    if (bs_old->node_name[0] != '\\0') {\n        QTAILQ_REMOVE(&graph_bdrv_states, bs_old, node_list);\n    }\n\n    /* bs_new must be anonymous and shouldn't have anything fancy enabled */\n    assert(bs_new->device_name[0] == '\\0');\n    assert(QLIST_EMPTY(&bs_new->dirty_bitmaps));\n    assert(bs_new->job == NULL);\n    assert(bs_new->dev == NULL);\n    assert(bs_new->in_use == 0);\n    assert(bs_new->io_limits_enabled == false);\n    assert(!throttle_have_timer(&bs_new->throttle_state));\n\n    tmp = *bs_new;\n    *bs_new = *bs_old;\n    *bs_old = tmp;\n\n    /* there are some fields that should not be swapped, move them back */\n    bdrv_move_feature_fields(&tmp, bs_old);\n    bdrv_move_feature_fields(bs_old, bs_new);\n    bdrv_move_feature_fields(bs_new, &tmp);\n\n    /* bs_new shouldn't be in bdrv_states even after the swap!  */\n    assert(bs_new->device_name[0] == '\\0');\n\n    /* Check a few fields that should remain attached to the device */\n    assert(bs_new->dev == NULL);\n    assert(bs_new->job == NULL);\n    assert(bs_new->in_use == 0);\n    assert(bs_new->io_limits_enabled == false);\n    assert(!throttle_have_timer(&bs_new->throttle_state));\n\n    /* insert the nodes back into the graph node list if needed */\n    if (bs_new->node_name[0] != '\\0') {\n        QTAILQ_INSERT_TAIL(&graph_bdrv_states, bs_new, node_list);\n    }\n    if (bs_old->node_name[0] != '\\0') {\n        QTAILQ_INSERT_TAIL(&graph_bdrv_states, bs_old, node_list);\n    }\n\n    bdrv_rebind(bs_new);\n    bdrv_rebind(bs_old);\n}\n", "target": 0, "idx": 16901}
{"func": "static int powermate_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tstruct usb_device *udev = interface_to_usbdev (intf);\n\tstruct usb_host_interface *interface;\n\tstruct usb_endpoint_descriptor *endpoint;\n\tstruct powermate_device *pm;\n\tstruct input_dev *input_dev;\n\tint pipe, maxp;\n \tint error = -ENOMEM;\n \n \tinterface = intf->cur_altsetting;\n \tendpoint = &interface->endpoint[0].desc;\n \tif (!usb_endpoint_is_int_in(endpoint))\n \t\treturn -EIO;\n\n\tusb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t0x0a, USB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\t0, interface->desc.bInterfaceNumber, NULL, 0,\n\t\tUSB_CTRL_SET_TIMEOUT);\n\n\tpm = kzalloc(sizeof(struct powermate_device), GFP_KERNEL);\n\tinput_dev = input_allocate_device();\n\tif (!pm || !input_dev)\n\t\tgoto fail1;\n\n\tif (powermate_alloc_buffers(udev, pm))\n\t\tgoto fail2;\n\n\tpm->irq = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!pm->irq)\n\t\tgoto fail2;\n\n\tpm->config = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!pm->config)\n\t\tgoto fail3;\n\n\tpm->udev = udev;\n\tpm->intf = intf;\n\tpm->input = input_dev;\n\n\tusb_make_path(udev, pm->phys, sizeof(pm->phys));\n\tstrlcat(pm->phys, \"/input0\", sizeof(pm->phys));\n\n\tspin_lock_init(&pm->lock);\n\n\tswitch (le16_to_cpu(udev->descriptor.idProduct)) {\n\tcase POWERMATE_PRODUCT_NEW:\n\t\tinput_dev->name = pm_name_powermate;\n\t\tbreak;\n\tcase POWERMATE_PRODUCT_OLD:\n\t\tinput_dev->name = pm_name_soundknob;\n\t\tbreak;\n\tdefault:\n\t\tinput_dev->name = pm_name_soundknob;\n\t\tprintk(KERN_WARNING \"powermate: unknown product id %04x\\n\",\n\t\t       le16_to_cpu(udev->descriptor.idProduct));\n\t}\n\n\tinput_dev->phys = pm->phys;\n\tusb_to_input_id(udev, &input_dev->id);\n\tinput_dev->dev.parent = &intf->dev;\n\n\tinput_set_drvdata(input_dev, pm);\n\n\tinput_dev->event = powermate_input_event;\n\n\tinput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REL) |\n\t\tBIT_MASK(EV_MSC);\n\tinput_dev->keybit[BIT_WORD(BTN_0)] = BIT_MASK(BTN_0);\n\tinput_dev->relbit[BIT_WORD(REL_DIAL)] = BIT_MASK(REL_DIAL);\n\tinput_dev->mscbit[BIT_WORD(MSC_PULSELED)] = BIT_MASK(MSC_PULSELED);\n\n\t/* get a handle to the interrupt data pipe */\n\tpipe = usb_rcvintpipe(udev, endpoint->bEndpointAddress);\n\tmaxp = usb_maxpacket(udev, pipe, usb_pipeout(pipe));\n\n\tif (maxp < POWERMATE_PAYLOAD_SIZE_MIN || maxp > POWERMATE_PAYLOAD_SIZE_MAX) {\n\t\tprintk(KERN_WARNING \"powermate: Expected payload of %d--%d bytes, found %d bytes!\\n\",\n\t\t\tPOWERMATE_PAYLOAD_SIZE_MIN, POWERMATE_PAYLOAD_SIZE_MAX, maxp);\n\t\tmaxp = POWERMATE_PAYLOAD_SIZE_MAX;\n\t}\n\n\tusb_fill_int_urb(pm->irq, udev, pipe, pm->data,\n\t\t\t maxp, powermate_irq,\n\t\t\t pm, endpoint->bInterval);\n\tpm->irq->transfer_dma = pm->data_dma;\n\tpm->irq->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\t/* register our interrupt URB with the USB system */\n\tif (usb_submit_urb(pm->irq, GFP_KERNEL)) {\n\t\terror = -EIO;\n\t\tgoto fail4;\n\t}\n\n\terror = input_register_device(pm->input);\n\tif (error)\n\t\tgoto fail5;\n\n\n\t/* force an update of everything */\n\tpm->requires_update = UPDATE_PULSE_ASLEEP | UPDATE_PULSE_AWAKE | UPDATE_PULSE_MODE | UPDATE_STATIC_BRIGHTNESS;\n\tpowermate_pulse_led(pm, 0x80, 255, 0, 1, 0); // set default pulse parameters\n\n\tusb_set_intfdata(intf, pm);\n\treturn 0;\n\n fail5:\tusb_kill_urb(pm->irq);\n fail4:\tusb_free_urb(pm->config);\n fail3:\tusb_free_urb(pm->irq);\n fail2:\tpowermate_free_buffers(udev, pm);\n fail1:\tinput_free_device(input_dev);\n\tkfree(pm);\n\treturn error;\n}\n", "target": 1, "idx": 180604}
{"func": "static Image *ReadPDBImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  unsigned char\n    attributes,\n    tag[3];\n\n  Image\n    *image;\n\n  IndexPacket\n    index;\n\n  MagickBooleanType\n    status;\n\n  PDBImage\n    pdb_image;\n\n  PDBInfo\n    pdb_info;\n\n  register IndexPacket\n    *indexes;\n\n  register ssize_t\n    x;\n\n  register PixelPacket\n    *q;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bits_per_pixel,\n    num_pad_bytes,\n    one,\n    packets;\n\n  ssize_t\n    count,\n    img_offset,\n    comment_offset = 0,\n    y;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Determine if this a PDB image file.\n  */\n  count=ReadBlob(image,sizeof(pdb_info.name),(unsigned char *) pdb_info.name);\n  if (count != sizeof(pdb_info.name))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  pdb_info.attributes=(short) ReadBlobMSBShort(image);\n  pdb_info.version=(short) ReadBlobMSBShort(image);\n  pdb_info.create_time=ReadBlobMSBLong(image);\n  pdb_info.modify_time=ReadBlobMSBLong(image);\n  pdb_info.archive_time=ReadBlobMSBLong(image);\n  pdb_info.modify_number=ReadBlobMSBLong(image);\n  pdb_info.application_info=ReadBlobMSBLong(image);\n  pdb_info.sort_info=ReadBlobMSBLong(image);\n  (void) ReadBlob(image,4,(unsigned char *) pdb_info.type);\n  (void) ReadBlob(image,4,(unsigned char *) pdb_info.id);\n  pdb_info.seed=ReadBlobMSBLong(image);\n  pdb_info.next_record=ReadBlobMSBLong(image);\n  pdb_info.number_records=(short) ReadBlobMSBShort(image);\n  if ((memcmp(pdb_info.type,\"vIMG\",4) != 0) ||\n      (memcmp(pdb_info.id,\"View\",4) != 0))\n  if (pdb_info.next_record != 0)\n    ThrowReaderException(CoderError,\"MultipleRecordListNotSupported\");\n  /*\n    Read record header.\n  */\n  img_offset=(ssize_t) ((int) ReadBlobMSBLong(image));\n  attributes=(unsigned char) ((int) ReadBlobByte(image));\n  (void) attributes;\n  count=ReadBlob(image,3,(unsigned char *) tag);\n  if (count != 3  ||  memcmp(tag,\"\\x6f\\x80\\x00\",3) != 0)\n    ThrowReaderException(CorruptImageError,\"CorruptImage\");\n  if (pdb_info.number_records > 1)\n    {\n      comment_offset=(ssize_t) ((int) ReadBlobMSBLong(image));\n      attributes=(unsigned char) ((int) ReadBlobByte(image));\n      count=ReadBlob(image,3,(unsigned char *) tag);\n      if (count != 3  ||  memcmp(tag,\"\\x6f\\x80\\x01\",3) != 0)\n        ThrowReaderException(CorruptImageError,\"CorruptImage\");\n    }\n  num_pad_bytes = (size_t) (img_offset - TellBlob( image ));\n  while (num_pad_bytes-- != 0)\n  {\n    int\n      c;\n\n    c=ReadBlobByte(image);\n    if (c == EOF)\n      break;\n  }\n  /*\n    Read image header.\n  */\n  count=ReadBlob(image,sizeof(pdb_image.name),(unsigned char *) pdb_image.name);\n  if (count != sizeof(pdb_image.name))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  pdb_image.version=ReadBlobByte(image);\n  pdb_image.type=(unsigned char) ReadBlobByte(image);\n  pdb_image.reserved_1=ReadBlobMSBLong(image);\n  pdb_image.note=ReadBlobMSBLong(image);\n  pdb_image.x_last=(short) ReadBlobMSBShort(image);\n  pdb_image.y_last=(short) ReadBlobMSBShort(image);\n  pdb_image.reserved_2=ReadBlobMSBLong(image);\n  pdb_image.x_anchor=ReadBlobMSBShort(image);\n  pdb_image.y_anchor=ReadBlobMSBShort(image);\n  pdb_image.width=(short) ReadBlobMSBShort(image);\n  pdb_image.height=(short) ReadBlobMSBShort(image);\n  /*\n    Initialize image structure.\n  */\n  image->columns=(size_t) pdb_image.width;\n  image->rows=(size_t) pdb_image.height;\n  image->depth=8;\n  image->storage_class=PseudoClass;\n  bits_per_pixel=pdb_image.type == 0 ? 2UL : pdb_image.type == 2 ? 4UL : 1UL;\n  one=1;\n  if (AcquireImageColormap(image,one << bits_per_pixel) == MagickFalse)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n       return(DestroyImageList(image));\n     }\n   packets=(bits_per_pixel*image->columns+7)/8;\n  pixels=(unsigned char *) AcquireQuantumMemory(packets+256UL,image->rows*\n     sizeof(*pixels));\n   if (pixels == (unsigned char *) NULL)\n     ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  switch (pdb_image.version & 0x07)\n  {\n    case 0:\n    {\n      image->compression=NoCompression;\n      count=(ssize_t) ReadBlob(image, packets * image -> rows, pixels);\n      break;\n    }\n    case 1:\n    {\n      image->compression=RLECompression;\n      if (!DecodeImage(image, pixels, packets * image -> rows))\n        ThrowReaderException( CorruptImageError, \"RLEDecoderError\" );\n      break;\n    }\n    default:\n      ThrowReaderException(CorruptImageError,\n         \"UnrecognizedImageCompressionType\" );\n  }\n  p=pixels;\n  switch (bits_per_pixel)\n  {\n    case 1:\n    {\n      int\n        bit;\n\n      /*\n        Read 1-bit PDB image.\n      */\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n          break;\n        indexes=GetAuthenticIndexQueue(image);\n        for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n        {\n          for (bit=0; bit < 8; bit++)\n          {\n            index=(IndexPacket) (*p & (0x80 >> bit) ? 0x00 : 0x01);\n            SetPixelIndex(indexes+x+bit,index);\n          }\n          p++;\n        }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n      (void) SyncImage(image);\n      break;\n    }\n    case 2:\n    {\n      /*\n        Read 2-bit PDB image.\n      */\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n          break;\n        indexes=GetAuthenticIndexQueue(image);\n        for (x=0; x < (ssize_t) image->columns-3; x+=4)\n        {\n          index=ConstrainColormapIndex(image,3UL-((*p >> 6) & 0x03));\n          SetPixelIndex(indexes+x,index);\n          index=ConstrainColormapIndex(image,3UL-((*p >> 4) & 0x03));\n          SetPixelIndex(indexes+x+1,index);\n          index=ConstrainColormapIndex(image,3UL-((*p >> 2) & 0x03));\n          SetPixelIndex(indexes+x+2,index);\n          index=ConstrainColormapIndex(image,3UL-((*p) & 0x03));\n          SetPixelIndex(indexes+x+3,index);\n          p++;\n        }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n      (void) SyncImage(image);\n      break;\n    }\n    case 4:\n    {\n      /*\n        Read 4-bit PDB image.\n      */\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n          break;\n        indexes=GetAuthenticIndexQueue(image);\n        for (x=0; x < (ssize_t) image->columns-1; x+=2)\n        {\n          index=ConstrainColormapIndex(image,15UL-((*p >> 4) & 0x0f));\n          SetPixelIndex(indexes+x,index);\n          index=ConstrainColormapIndex(image,15UL-((*p) & 0x0f));\n          SetPixelIndex(indexes+x+1,index);\n          p++;\n        }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n      (void) SyncImage(image);\n      break;\n    }\n    default:\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  }\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  if (pdb_info.number_records > 1)\n    {\n      char\n        *comment;\n\n      int\n        c;\n\n      register char\n        *p;\n\n      size_t\n        length;\n\n      num_pad_bytes = (size_t) (comment_offset - TellBlob( image ));\n      while (num_pad_bytes--) ReadBlobByte( image );\n\n      /*\n        Read comment.\n      */\n      c=ReadBlobByte(image);\n      length=MaxTextExtent;\n      comment=AcquireString((char *) NULL);\n      for (p=comment; c != EOF; p++)\n      {\n        if ((size_t) (p-comment+MaxTextExtent) >= length)\n          {\n            *p='\\0';\n            length<<=1;\n            length+=MaxTextExtent;\n            comment=(char *) ResizeQuantumMemory(comment,length+MaxTextExtent,\n              sizeof(*comment));\n            if (comment == (char *) NULL)\n              break;\n            p=comment+strlen(comment);\n          }\n        *p=c;\n        c=ReadBlobByte(image);\n      }\n      *p='\\0';\n      if (comment == (char *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      (void) SetImageProperty(image,\"comment\",comment);\n      comment=DestroyString(comment);\n    }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n", "target": 1, "idx": 181962}
{"func": "void Editor::AppliedEditing(CompositeEditCommand* cmd) {\n  DCHECK(!cmd->IsCommandGroupWrapper());\n  EventQueueScope scope;\n\n  GetSpellChecker().MarkMisspellingsAfterApplyingCommand(*cmd);\n\n  UndoStep* undo_step = cmd->GetUndoStep();\n  DCHECK(undo_step);\n  DispatchEditableContentChangedEvents(undo_step->StartingRootEditableElement(),\n                                       undo_step->EndingRootEditableElement());\n  DispatchInputEventEditableContentChanged(\n      undo_step->StartingRootEditableElement(),\n      undo_step->EndingRootEditableElement(), cmd->GetInputType(),\n      cmd->TextDataForInputEvent(), IsComposingFromCommand(cmd));\n\n  const SelectionInDOMTree& new_selection = CorrectedSelectionAfterCommand(\n      cmd->EndingSelection(), GetFrame().GetDocument());\n\n  ChangeSelectionAfterCommand(new_selection, 0);\n\n  if (!cmd->PreservesTypingStyle())\n    ClearTypingStyle();\n\n  if (last_edit_command_.Get() == cmd) {\n    DCHECK(cmd->IsTypingCommand());\n  } else if (last_edit_command_ && last_edit_command_->IsDragAndDropCommand() &&\n             (cmd->GetInputType() == InputEvent::InputType::kDeleteByDrag ||\n              cmd->GetInputType() == InputEvent::InputType::kInsertFromDrop)) {\n    if (!last_edit_command_->GetUndoStep())\n      undo_stack_->RegisterUndoStep(last_edit_command_->EnsureUndoStep());\n    last_edit_command_->EnsureUndoStep()->SetEndingSelection(\n        cmd->EnsureUndoStep()->EndingSelection());\n    last_edit_command_->AppendCommandToUndoStep(cmd);\n  } else {\n    last_edit_command_ = cmd;\n    undo_stack_->RegisterUndoStep(last_edit_command_->EnsureUndoStep());\n  }\n\n  RespondToChangedContents(new_selection.Base());\n}\n", "target": 0, "idx": 139366}
{"func": "static int tpacket_rcv(struct sk_buff *skb, struct net_device *dev,\n\t\t       struct packet_type *pt, struct net_device *orig_dev)\n{\n\tstruct sock *sk;\n\tstruct packet_sock *po;\n\tstruct sockaddr_ll *sll;\n\tunion {\n\t\tstruct tpacket_hdr *h1;\n\t\tstruct tpacket2_hdr *h2;\n\t\tvoid *raw;\n\t} h;\n\tu8 *skb_head = skb->data;\n\tint skb_len = skb->len;\n\tunsigned int snaplen, res;\n\tunsigned long status = TP_STATUS_LOSING|TP_STATUS_USER;\n\tunsigned short macoff, netoff, hdrlen;\n\tstruct sk_buff *copy_skb = NULL;\n\tstruct timeval tv;\n\tstruct timespec ts;\n\tstruct skb_shared_hwtstamps *shhwtstamps = skb_hwtstamps(skb);\n\n\tif (skb->pkt_type == PACKET_LOOPBACK)\n\t\tgoto drop;\n\n\tsk = pt->af_packet_priv;\n\tpo = pkt_sk(sk);\n\n\tif (!net_eq(dev_net(dev), sock_net(sk)))\n\t\tgoto drop;\n\n\tif (dev->header_ops) {\n\t\tif (sk->sk_type != SOCK_DGRAM)\n\t\t\tskb_push(skb, skb->data - skb_mac_header(skb));\n\t\telse if (skb->pkt_type == PACKET_OUTGOING) {\n\t\t\t/* Special case: outgoing packets have ll header at head */\n\t\t\tskb_pull(skb, skb_network_offset(skb));\n\t\t}\n\t}\n\n\tif (skb->ip_summed == CHECKSUM_PARTIAL)\n\t\tstatus |= TP_STATUS_CSUMNOTREADY;\n\n\tsnaplen = skb->len;\n\n\tres = run_filter(skb, sk, snaplen);\n\tif (!res)\n\t\tgoto drop_n_restore;\n\tif (snaplen > res)\n\t\tsnaplen = res;\n\n\tif (sk->sk_type == SOCK_DGRAM) {\n\t\tmacoff = netoff = TPACKET_ALIGN(po->tp_hdrlen) + 16 +\n\t\t\t\t  po->tp_reserve;\n\t} else {\n\t\tunsigned maclen = skb_network_offset(skb);\n\t\tnetoff = TPACKET_ALIGN(po->tp_hdrlen +\n\t\t\t\t       (maclen < 16 ? 16 : maclen)) +\n\t\t\tpo->tp_reserve;\n\t\tmacoff = netoff - maclen;\n\t}\n\n\tif (macoff + snaplen > po->rx_ring.frame_size) {\n\t\tif (po->copy_thresh &&\n\t\t    atomic_read(&sk->sk_rmem_alloc) + skb->truesize <\n\t\t    (unsigned)sk->sk_rcvbuf) {\n\t\t\tif (skb_shared(skb)) {\n\t\t\t\tcopy_skb = skb_clone(skb, GFP_ATOMIC);\n\t\t\t} else {\n\t\t\t\tcopy_skb = skb_get(skb);\n\t\t\t\tskb_head = skb->data;\n\t\t\t}\n\t\t\tif (copy_skb)\n\t\t\t\tskb_set_owner_r(copy_skb, sk);\n\t\t}\n\t\tsnaplen = po->rx_ring.frame_size - macoff;\n\t\tif ((int)snaplen < 0)\n\t\t\tsnaplen = 0;\n\t}\n\n\tspin_lock(&sk->sk_receive_queue.lock);\n\th.raw = packet_current_frame(po, &po->rx_ring, TP_STATUS_KERNEL);\n\tif (!h.raw)\n\t\tgoto ring_is_full;\n\tpacket_increment_head(&po->rx_ring);\n\tpo->stats.tp_packets++;\n\tif (copy_skb) {\n\t\tstatus |= TP_STATUS_COPY;\n\t\t__skb_queue_tail(&sk->sk_receive_queue, copy_skb);\n\t}\n\tif (!po->stats.tp_drops)\n\t\tstatus &= ~TP_STATUS_LOSING;\n\tspin_unlock(&sk->sk_receive_queue.lock);\n\n\tskb_copy_bits(skb, 0, h.raw + macoff, snaplen);\n\n\tswitch (po->tp_version) {\n\tcase TPACKET_V1:\n\t\th.h1->tp_len = skb->len;\n\t\th.h1->tp_snaplen = snaplen;\n\t\th.h1->tp_mac = macoff;\n\t\th.h1->tp_net = netoff;\n\t\tif ((po->tp_tstamp & SOF_TIMESTAMPING_SYS_HARDWARE)\n\t\t\t\t&& shhwtstamps->syststamp.tv64)\n\t\t\ttv = ktime_to_timeval(shhwtstamps->syststamp);\n\t\telse if ((po->tp_tstamp & SOF_TIMESTAMPING_RAW_HARDWARE)\n\t\t\t\t&& shhwtstamps->hwtstamp.tv64)\n\t\t\ttv = ktime_to_timeval(shhwtstamps->hwtstamp);\n\t\telse if (skb->tstamp.tv64)\n\t\t\ttv = ktime_to_timeval(skb->tstamp);\n\t\telse\n\t\t\tdo_gettimeofday(&tv);\n\t\th.h1->tp_sec = tv.tv_sec;\n\t\th.h1->tp_usec = tv.tv_usec;\n\t\thdrlen = sizeof(*h.h1);\n\t\tbreak;\n\tcase TPACKET_V2:\n\t\th.h2->tp_len = skb->len;\n\t\th.h2->tp_snaplen = snaplen;\n\t\th.h2->tp_mac = macoff;\n\t\th.h2->tp_net = netoff;\n\t\tif ((po->tp_tstamp & SOF_TIMESTAMPING_SYS_HARDWARE)\n\t\t\t\t&& shhwtstamps->syststamp.tv64)\n\t\t\tts = ktime_to_timespec(shhwtstamps->syststamp);\n\t\telse if ((po->tp_tstamp & SOF_TIMESTAMPING_RAW_HARDWARE)\n\t\t\t\t&& shhwtstamps->hwtstamp.tv64)\n\t\t\tts = ktime_to_timespec(shhwtstamps->hwtstamp);\n\t\telse if (skb->tstamp.tv64)\n\t\t\tts = ktime_to_timespec(skb->tstamp);\n\t\telse\n\t\t\tgetnstimeofday(&ts);\n\t\th.h2->tp_sec = ts.tv_sec;\n\t\th.h2->tp_nsec = ts.tv_nsec;\n\t\tif (vlan_tx_tag_present(skb)) {\n\t\t\th.h2->tp_vlan_tci = vlan_tx_tag_get(skb);\n\t\t\tstatus |= TP_STATUS_VLAN_VALID;\n \t\t} else {\n \t\t\th.h2->tp_vlan_tci = 0;\n \t\t}\n \t\thdrlen = sizeof(*h.h2);\n \t\tbreak;\n \tdefault:\n\t\tBUG();\n\t}\n\n\tsll = h.raw + TPACKET_ALIGN(hdrlen);\n\tsll->sll_halen = dev_parse_header(skb, sll->sll_addr);\n\tsll->sll_family = AF_PACKET;\n\tsll->sll_hatype = dev->type;\n\tsll->sll_protocol = skb->protocol;\n\tsll->sll_pkttype = skb->pkt_type;\n\tif (unlikely(po->origdev))\n\t\tsll->sll_ifindex = orig_dev->ifindex;\n\telse\n\t\tsll->sll_ifindex = dev->ifindex;\n\n\t__packet_set_status(po, h.raw, status);\n\tsmp_mb();\n#if ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE == 1\n\t{\n\t\tu8 *start, *end;\n\n\t\tend = (u8 *)PAGE_ALIGN((unsigned long)h.raw + macoff + snaplen);\n\t\tfor (start = h.raw; start < end; start += PAGE_SIZE)\n\t\t\tflush_dcache_page(pgv_to_page(start));\n\t}\n#endif\n\n\tsk->sk_data_ready(sk, 0);\n\ndrop_n_restore:\n\tif (skb_head != skb->data && skb_shared(skb)) {\n\t\tskb->data = skb_head;\n\t\tskb->len = skb_len;\n\t}\ndrop:\n\tkfree_skb(skb);\n\treturn 0;\n\nring_is_full:\n\tpo->stats.tp_drops++;\n\tspin_unlock(&sk->sk_receive_queue.lock);\n\n\tsk->sk_data_ready(sk, 0);\n\tkfree_skb(copy_skb);\n\tgoto drop_n_restore;\n}\n", "target": 1, "idx": 179020}
{"func": "static void xhci_kick_ep(XHCIState *xhci, unsigned int slotid,\n                         unsigned int epid, unsigned int streamid)\n{\n    XHCIEPContext *epctx;\n\n    assert(slotid >= 1 && slotid <= xhci->numslots);\n    assert(epid >= 1 && epid <= 31);\n\n    if (!xhci->slots[slotid-1].enabled) {\n        DPRINTF(\"xhci: xhci_kick_ep for disabled slot %d\\n\", slotid);\n        return;\n    }\n    epctx = xhci->slots[slotid-1].eps[epid-1];\n    if (!epctx) {\n        DPRINTF(\"xhci: xhci_kick_ep for disabled endpoint %d,%d\\n\",\n                epid, slotid);\n        return;\n         return;\n     }\n \n     xhci_kick_epctx(epctx, streamid);\n }\n", "target": 1, "idx": 177967}
{"func": "static void doubleArrayAttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)\n{\n    INC_STATS(\"DOM.TestObj.doubleArray._set\");\n    TestObj* imp = V8TestObj::toNative(info.Holder());\n    Vector<double> v = v8NumberArrayToVector<double>(value);\n    imp->setDoubleArray(v);\n    return;\n}\n", "target": 0, "idx": 117803}
{"func": "const BlockEntry* Cluster::GetEntry(const Track* pTrack,\n long long time_ns) const {\n  assert(pTrack);\n\n\n   if (m_pSegment == NULL)  // this is the special EOS cluster\n     return pTrack->GetEOS();\n \n#if 0\n    LoadBlockEntries();\n    if ((m_entries == NULL) || (m_entries_count <= 0))\n        return NULL;  //return EOS here?\n    const BlockEntry* pResult = pTrack->GetEOS();\n    BlockEntry** i = m_entries;\n    assert(i);\n    BlockEntry** const j = i + m_entries_count;\n    while (i != j)\n    {\n        const BlockEntry* const pEntry = *i++;\n        assert(pEntry);\n        assert(!pEntry->EOS());\n        const Block* const pBlock = pEntry->GetBlock();\n        assert(pBlock);\n        if (pBlock->GetTrackNumber() != pTrack->GetNumber())\n            continue;\n        if (pTrack->VetEntry(pEntry))\n        {\n            if (time_ns < 0)  //just want first candidate block\n                return pEntry;\n            const long long ns = pBlock->GetTime(this);\n            if (ns > time_ns)\n                break;\n            pResult = pEntry;\n        }\n        else if (time_ns >= 0)\n        {\n            const long long ns = pBlock->GetTime(this);\n            if (ns > time_ns)\n                break;\n        }\n    }\n    return pResult;\n#else\n   const BlockEntry* pResult = pTrack->GetEOS();\n \n   long index = 0;\n\n for (;;) {\n if (index >= m_entries_count) {\n long long pos;\n long len;\n\n const long status = Parse(pos, len);\n      assert(status >= 0);\n\n if (status > 0) // completely parsed, and no more entries\n return pResult;\n\n if (status < 0) // should never happen\n return 0;\n\n      assert(m_entries);\n      assert(index < m_entries_count);\n }\n\n const BlockEntry* const pEntry = m_entries[index];\n    assert(pEntry);\n    assert(!pEntry->EOS());\n\n const Block* const pBlock = pEntry->GetBlock();\n    assert(pBlock);\n\n if (pBlock->GetTrackNumber() != pTrack->GetNumber()) {\n ++index;\n continue;\n }\n\n if (pTrack->VetEntry(pEntry)) {\n if (time_ns < 0) // just want first candidate block\n return pEntry;\n\n const long long ns = pBlock->GetTime(this);\n\n if (ns > time_ns)\n return pResult;\n\n      pResult = pEntry; // have a candidate\n } else if (time_ns >= 0) {\n const long long ns = pBlock->GetTime(this);\n\n if (ns > time_ns)\n return pResult;\n }\n\n \n     ++index;\n   }\n#endif\n }\n", "target": 1, "idx": 187838}
{"func": "RenderFrameHostManager::RenderFrameHostManager(\n    FrameTreeNode* frame_tree_node,\n    RenderFrameHostDelegate* render_frame_delegate,\n    RenderWidgetHostDelegate* render_widget_delegate,\n    Delegate* delegate)\n    : frame_tree_node_(frame_tree_node),\n       delegate_(delegate),\n       render_frame_delegate_(render_frame_delegate),\n       render_widget_delegate_(render_widget_delegate),\n      interstitial_page_(nullptr),\n       weak_factory_(this) {\n   DCHECK(frame_tree_node_);\n }\n", "target": 1, "idx": 186291}
{"func": "void PrintODList(GF_Terminal *term, GF_ObjectManager *root_odm, u32 num, u32 indent, char *root_name)\n{\n\tGF_MediaInfo odi;\n\tu32 i, count;\n\tchar szIndent[50];\n\tGF_ObjectManager *odm;\n\n\tif (!root_odm) {\n\t\tfprintf(stderr, \"Currently loaded objects:\\n\");\n\t\troot_odm = gf_term_get_root_object(term);\n\t}\n\tif (!root_odm) return;\n\n\tcount = gf_term_get_current_service_id(term);\n\tif (count)\n\t\tfprintf(stderr, \"Current service ID %d\\n\", count);\n\n\tif (gf_term_get_object_info(term, root_odm, &odi) != GF_OK) return;\n\tif (!odi.od) {\n\t\tfprintf(stderr, \"Service not attached\\n\");\n\t\treturn;\n\t}\n\n\tfor (i=0; i<indent; i++) szIndent[i]=' ';\n\tszIndent[indent]=0;\n\n\tfprintf(stderr, \"%s\", szIndent);\n\tfprintf(stderr, \"#%d %s - \", num, root_name);\n\tif (odi.od->ServiceID) fprintf(stderr, \"Service ID %d \", odi.od->ServiceID);\n\tif (odi.media_url) {\n\t\tfprintf(stderr, \"%s\\n\", odi.media_url);\n\t} else {\n\t\tfprintf(stderr, \"OD ID %d\\n\", odi.od->objectDescriptorID);\n\t}\n\n\tszIndent[indent]=' ';\n\tszIndent[indent+1]=0;\n\tindent++;\n\n\tcount = gf_term_get_object_count(term, root_odm);\n\tfor (i=0; i<count; i++) {\n\t\todm = gf_term_get_object(term, root_odm, i);\n\t\tif (!odm) break;\n\t\tnum++;\n\t\tif (gf_term_get_object_info(term, odm, &odi) == GF_OK) {\n\t\t\tswitch (gf_term_object_subscene_type(term, odm)) {\n\t\t\tcase 1:\n\t\t\t\tPrintODList(term, odm, num, indent, \"Root\");\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tPrintODList(term, odm, num, indent, \"Inline Scene\");\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tPrintODList(term, odm, num, indent, \"EXTERNPROTO Library\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfprintf(stderr, \"%s\", szIndent);\n\t\t\t\tfprintf(stderr, \"#%d - \", num);\n\t\t\t\tif (odi.media_url) {\n\t\t\t\t\tfprintf(stderr, \"%s\", odi.media_url);\n\t\t\t\t} else if (odi.od) {\n\t\t\t\t \tif (odi.od->URLString) {\n\t\t\t\t\t\tfprintf(stderr, \"%s\", odi.od->URLString);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfprintf(stderr, \"ID %d\", odi.od->objectDescriptorID);\n\t\t\t\t\t}\n\t\t\t\t} else if (odi.service_url) {\n\t\t\t\t\tfprintf(stderr, \"%s\", odi.service_url);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"unknown\");\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \" - %s\", (odi.od_type==GF_STREAM_VISUAL) ? \"Video\" : (odi.od_type==GF_STREAM_AUDIO) ? \"Audio\" : \"Systems\");\n\t\t\t\tif (odi.od && odi.od->ServiceID) fprintf(stderr, \" - Service ID %d\", odi.od->ServiceID);\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n", "target": 0, "idx": 92806}
{"func": "int ip_options_echo(struct ip_options * dopt, struct sk_buff * skb)\n {\n\tstruct ip_options *sopt;\n \tunsigned char *sptr, *dptr;\n \tint soffset, doffset;\n \tint\toptlen;\n\t__be32\tdaddr;\n\n\tmemset(dopt, 0, sizeof(struct ip_options));\n \n \tsopt = &(IPCB(skb)->opt);\n \n\tif (sopt->optlen == 0) {\n\t\tdopt->optlen = 0;\n \t\treturn 0;\n\t}\n \n \tsptr = skb_network_header(skb);\n \tdptr = dopt->__data;\n\n\tdaddr = skb_rtable(skb)->rt_spec_dst;\n\n\tif (sopt->rr) {\n\t\toptlen  = sptr[sopt->rr+1];\n\t\tsoffset = sptr[sopt->rr+2];\n\t\tdopt->rr = dopt->optlen + sizeof(struct iphdr);\n\t\tmemcpy(dptr, sptr+sopt->rr, optlen);\n\t\tif (sopt->rr_needaddr && soffset <= optlen) {\n\t\t\tif (soffset + 3 > optlen)\n\t\t\t\treturn -EINVAL;\n\t\t\tdptr[2] = soffset + 4;\n\t\t\tdopt->rr_needaddr = 1;\n\t\t}\n\t\tdptr += optlen;\n\t\tdopt->optlen += optlen;\n\t}\n\tif (sopt->ts) {\n\t\toptlen = sptr[sopt->ts+1];\n\t\tsoffset = sptr[sopt->ts+2];\n\t\tdopt->ts = dopt->optlen + sizeof(struct iphdr);\n\t\tmemcpy(dptr, sptr+sopt->ts, optlen);\n\t\tif (soffset <= optlen) {\n\t\t\tif (sopt->ts_needaddr) {\n\t\t\t\tif (soffset + 3 > optlen)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tdopt->ts_needaddr = 1;\n\t\t\t\tsoffset += 4;\n\t\t\t}\n\t\t\tif (sopt->ts_needtime) {\n\t\t\t\tif (soffset + 3 > optlen)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif ((dptr[3]&0xF) != IPOPT_TS_PRESPEC) {\n\t\t\t\t\tdopt->ts_needtime = 1;\n\t\t\t\t\tsoffset += 4;\n\t\t\t\t} else {\n\t\t\t\t\tdopt->ts_needtime = 0;\n\n\t\t\t\t\tif (soffset + 7 <= optlen) {\n\t\t\t\t\t\t__be32 addr;\n\n\t\t\t\t\t\tmemcpy(&addr, dptr+soffset-1, 4);\n\t\t\t\t\t\tif (inet_addr_type(dev_net(skb_dst(skb)->dev), addr) != RTN_UNICAST) {\n\t\t\t\t\t\t\tdopt->ts_needtime = 1;\n\t\t\t\t\t\t\tsoffset += 8;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdptr[2] = soffset;\n\t\t}\n\t\tdptr += optlen;\n \t\tdopt->optlen += optlen;\n \t}\n \tif (sopt->srr) {\n\t\tunsigned char * start = sptr+sopt->srr;\n \t\t__be32 faddr;\n \n \t\toptlen  = start[1];\n\t\tsoffset = start[2];\n\t\tdoffset = 0;\n\t\tif (soffset > optlen)\n\t\t\tsoffset = optlen + 1;\n\t\tsoffset -= 4;\n\t\tif (soffset > 3) {\n\t\t\tmemcpy(&faddr, &start[soffset-1], 4);\n\t\t\tfor (soffset-=4, doffset=4; soffset > 3; soffset-=4, doffset+=4)\n\t\t\t\tmemcpy(&dptr[doffset-1], &start[soffset-1], 4);\n\t\t\t/*\n\t\t\t * RFC1812 requires to fix illegal source routes.\n\t\t\t */\n\t\t\tif (memcmp(&ip_hdr(skb)->saddr,\n\t\t\t\t   &start[soffset + 3], 4) == 0)\n\t\t\t\tdoffset -= 4;\n\t\t}\n\t\tif (doffset > 3) {\n\t\t\tmemcpy(&start[doffset-1], &daddr, 4);\n\t\t\tdopt->faddr = faddr;\n\t\t\tdptr[0] = start[0];\n\t\t\tdptr[1] = doffset+3;\n\t\t\tdptr[2] = 4;\n\t\t\tdptr += doffset+3;\n\t\t\tdopt->srr = dopt->optlen + sizeof(struct iphdr);\n\t\t\tdopt->optlen += doffset+3;\n\t\t\tdopt->is_strictroute = sopt->is_strictroute;\n\t\t}\n\t}\n\tif (sopt->cipso) {\n\t\toptlen  = sptr[sopt->cipso+1];\n\t\tdopt->cipso = dopt->optlen+sizeof(struct iphdr);\n\t\tmemcpy(dptr, sptr+sopt->cipso, optlen);\n\t\tdptr += optlen;\n\t\tdopt->optlen += optlen;\n\t}\n\twhile (dopt->optlen & 3) {\n\t\t*dptr++ = IPOPT_END;\n\t\tdopt->optlen++;\n\t}\n\treturn 0;\n}\n", "target": 1, "idx": 178729}
{"func": "void ZeroSuggestProvider::Start(const AutocompleteInput& input,\n                                bool minimal_changes) {\n  TRACE_EVENT0(\"omnibox\", \"ZeroSuggestProvider::Start\");\n  matches_.clear();\n  if (!input.from_omnibox_focus() || client()->IsOffTheRecord() ||\n      input.type() == metrics::OmniboxInputType::INVALID)\n    return;\n\n  Stop(true, false);\n  set_field_trial_triggered(false);\n  set_field_trial_triggered_in_session(false);\n  results_from_cache_ = false;\n  permanent_text_ = input.text();\n  current_query_ = input.current_url().spec();\n  current_title_ = input.current_title();\n   current_page_classification_ = input.current_page_classification();\n   current_url_match_ = MatchForCurrentURL();\n \n  std::string url_string = GetContextualSuggestionsUrl();\n  GURL suggest_url(url_string);\n   if (!suggest_url.is_valid())\n     return;\n \n  const TemplateURLService* template_url_service =\n      client()->GetTemplateURLService();\n  const TemplateURL* default_provider =\n      template_url_service->GetDefaultSearchProvider();\n  const bool can_send_current_url =\n      CanSendURL(input.current_url(), suggest_url, default_provider,\n                 current_page_classification_,\n                 template_url_service->search_terms_data(), client());\n  GURL arbitrary_insecure_url(kArbitraryInsecureUrlString);\n  ZeroSuggestEligibility eligibility = ZeroSuggestEligibility::ELIGIBLE;\n  if (!can_send_current_url) {\n    const bool can_send_ordinary_url =\n        CanSendURL(arbitrary_insecure_url, suggest_url, default_provider,\n                   current_page_classification_,\n                   template_url_service->search_terms_data(), client());\n    eligibility = can_send_ordinary_url\n                      ? ZeroSuggestEligibility::URL_INELIGIBLE\n                      : ZeroSuggestEligibility::GENERALLY_INELIGIBLE;\n  }\n  UMA_HISTOGRAM_ENUMERATION(\n      \"Omnibox.ZeroSuggest.Eligible.OnFocus\", static_cast<int>(eligibility),\n      static_cast<int>(ZeroSuggestEligibility::ELIGIBLE_MAX_VALUE));\n  if (can_send_current_url &&\n       !OmniboxFieldTrial::InZeroSuggestPersonalizedFieldTrial() &&\n       !OmniboxFieldTrial::InZeroSuggestMostVisitedFieldTrial()) {\n    if (OmniboxFieldTrial::InZeroSuggestRedirectToChromeFieldTrial()) {\n      url_string +=\n           \"/url=\" + net::EscapePath(current_query_) +\n          OmniboxFieldTrial::ZeroSuggestRedirectToChromeAdditionalFields();\n      suggest_url = GURL(url_string);\n     } else {\n       base::string16 prefix;\n       TemplateURLRef::SearchTermsArgs search_term_args(prefix);\n      search_term_args.current_page_url = current_query_;\n      suggest_url =\n          GURL(default_provider->suggestions_url_ref().ReplaceSearchTerms(\n              search_term_args, template_url_service->search_terms_data()));\n    }\n  } else if (!ShouldShowNonContextualZeroSuggest(input.current_url())) {\n    return;\n  }\n\n  done_ = false;\n  MaybeUseCachedSuggestions();\n  Run(suggest_url);\n}\n", "target": 1, "idx": 185922}
{"func": "static int edge_ioctl(struct tty_struct *tty,\n\t\t\t\t\tunsigned int cmd, unsigned long arg)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\n\tstruct async_icount cnow;\n\tstruct async_icount cprev;\n\n\tdev_dbg(&port->dev, \"%s - port %d, cmd = 0x%x\\n\", __func__, port->number, cmd);\n\n\tswitch (cmd) {\n\tcase TIOCGSERIAL:\n\t\tdev_dbg(&port->dev, \"%s - TIOCGSERIAL\\n\", __func__);\n\t\treturn get_serial_info(edge_port,\n\t\t\t\t(struct serial_struct __user *) arg);\n\tcase TIOCMIWAIT:\n\t\tdev_dbg(&port->dev, \"%s - TIOCMIWAIT\\n\", __func__);\n\t\tcprev = edge_port->icount;\n\t\twhile (1) {\n\t\t\tinterruptible_sleep_on(&edge_port->delta_msr_wait);\n\t\t\t/* see if a signal did it */\n\t\t\tif (signal_pending(current))\n\t\t\t\treturn -ERESTARTSYS;\n\t\t\tcnow = edge_port->icount;\n\t\t\tif (cnow.rng == cprev.rng && cnow.dsr == cprev.dsr &&\n\t\t\t    cnow.dcd == cprev.dcd && cnow.cts == cprev.cts)\n\t\t\t\treturn -EIO; /* no change => error */\n\t\t\tif (((arg & TIOCM_RNG) && (cnow.rng != cprev.rng)) ||\n\t\t\t    ((arg & TIOCM_DSR) && (cnow.dsr != cprev.dsr)) ||\n\t\t\t    ((arg & TIOCM_CD)  && (cnow.dcd != cprev.dcd)) ||\n\t\t\t    ((arg & TIOCM_CTS) && (cnow.cts != cprev.cts))) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcprev = cnow;\n\t\t}\n\t\t/* not reached */\n\t\tbreak;\n\t}\n\treturn -ENOIOCTLCMD;\n}\n", "target": 0, "idx": 33332}
{"func": "void PasswordAccessoryControllerTest::InitializeGeneration(\n    const base::string16& password) {\n  ON_CALL(*(mock_password_manager_driver_.get()),\n          GetPasswordGenerationManager())\n      .WillByDefault(Return(mock_generation_manager_.get()));\n  EXPECT_CALL(mock_manual_filling_controller_,\n              OnAutomaticGenerationStatusChanged(true));\n  controller()->OnAutomaticGenerationStatusChanged(\n      true, GetTestGenerationUIData1(),\n      mock_password_manager_driver_->AsWeakPtr());\n  ON_CALL(*(mock_generation_manager_.get()), GeneratePassword(_, _, _, _, _))\n      .WillByDefault(Return(password));\n  ON_CALL(mock_dialog_factory(), Run)\n      .WillByDefault(Return(ByMove(std::move(mock_dialog_))));\n}\n", "target": 1, "idx": 186037}
{"func": "http_DissectRequest(struct sess *sp)\n{\n\tstruct http_conn *htc;\n\tstruct http *hp;\n\tuint16_t retval;\n\n\tCHECK_OBJ_NOTNULL(sp, SESS_MAGIC);\n\thtc = sp->htc;\n\tCHECK_OBJ_NOTNULL(htc, HTTP_CONN_MAGIC);\n\thp = sp->http;\n\tCHECK_OBJ_NOTNULL(hp, HTTP_MAGIC);\n\n\thp->logtag = HTTP_Rx;\n\n\tretval = http_splitline(sp->wrk, sp->fd, hp, htc,\n\t    HTTP_HDR_REQ, HTTP_HDR_URL, HTTP_HDR_PROTO);\n\tif (retval != 0) {\n\t\tWSPR(sp, SLT_HttpGarbage, htc->rxbuf);\n\t\treturn (retval);\n \t}\n \thttp_ProtoVer(hp);\n \n\tretval = htc_request_check_host_hdr(hp);\n\tif (retval != 0) {\n\t\tWSP(sp, SLT_Error, \"Duplicated Host header\");\n\t\treturn (retval);\n\t}\n \treturn (retval);\n }\n", "target": 1, "idx": 180651}
{"func": "static struct request *blk_mq_map_request(struct request_queue *q,\n\t\t\t\t\t  struct bio *bio,\n\t\t\t\t\t  struct blk_map_ctx *data)\n{\n\tstruct blk_mq_hw_ctx *hctx;\n\tstruct blk_mq_ctx *ctx;\n\tstruct request *rq;\n\tint rw = bio_data_dir(bio);\n\tstruct blk_mq_alloc_data alloc_data;\n\n\tif (unlikely(blk_mq_queue_enter(q, GFP_KERNEL))) {\n\t\tbio_io_error(bio);\n\t\treturn NULL;\n\t}\n\n\tctx = blk_mq_get_ctx(q);\n\thctx = q->mq_ops->map_queue(q, ctx->cpu);\n\n\tif (rw_is_sync(bio->bi_rw))\n\t\trw |= REQ_SYNC;\n\n\ttrace_block_getrq(q, bio, rw);\n\tblk_mq_set_alloc_data(&alloc_data, q, GFP_ATOMIC, false, ctx,\n\t\t\thctx);\n\trq = __blk_mq_alloc_request(&alloc_data, rw);\n\tif (unlikely(!rq)) {\n\t\t__blk_mq_run_hw_queue(hctx);\n\t\tblk_mq_put_ctx(ctx);\n\t\ttrace_block_sleeprq(q, bio, rw);\n\n\t\tctx = blk_mq_get_ctx(q);\n\t\thctx = q->mq_ops->map_queue(q, ctx->cpu);\n\t\tblk_mq_set_alloc_data(&alloc_data, q,\n\t\t\t\t__GFP_WAIT|GFP_ATOMIC, false, ctx, hctx);\n\t\trq = __blk_mq_alloc_request(&alloc_data, rw);\n\t\tctx = alloc_data.ctx;\n\t\thctx = alloc_data.hctx;\n\t}\n\n\thctx->queued++;\n\tdata->hctx = hctx;\n\tdata->ctx = ctx;\n\treturn rq;\n}\n", "target": 0, "idx": 86724}
{"func": "PepperMediaDeviceManager* PepperMediaDeviceManager::GetForRenderFrame(\n     RenderFrame* render_frame) {\n   PepperMediaDeviceManager* handler =\n       PepperMediaDeviceManager::Get(render_frame);\n   if (!handler)\n     handler = new PepperMediaDeviceManager(render_frame);\n  return handler;\n }\n", "target": 1, "idx": 185311}
{"func": "int __sys_recvmmsg(int fd, struct mmsghdr __user *mmsg, unsigned int vlen,\n\t\t   unsigned int flags, struct timespec *timeout)\n{\n\tint fput_needed, err, datagrams;\n\tstruct socket *sock;\n\tstruct mmsghdr __user *entry;\n\tstruct compat_mmsghdr __user *compat_entry;\n\tstruct msghdr msg_sys;\n\tstruct timespec end_time;\n\n\tif (timeout &&\n\t    poll_select_set_timeout(&end_time, timeout->tv_sec,\n\t\t\t\t    timeout->tv_nsec))\n\t\treturn -EINVAL;\n\n\tdatagrams = 0;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (!sock)\n\t\treturn err;\n\n\terr = sock_error(sock->sk);\n\tif (err)\n\t\tgoto out_put;\n\n\tentry = mmsg;\n\tcompat_entry = (struct compat_mmsghdr __user *)mmsg;\n\n\twhile (datagrams < vlen) {\n\t\t/*\n\t\t * No need to ask LSM for more than the first datagram.\n\t\t */\n\t\tif (MSG_CMSG_COMPAT & flags) {\n\t\t\terr = ___sys_recvmsg(sock, (struct user_msghdr __user *)compat_entry,\n\t\t\t\t\t     &msg_sys, flags & ~MSG_WAITFORONE,\n\t\t\t\t\t     datagrams);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t\terr = __put_user(err, &compat_entry->msg_len);\n\t\t\t++compat_entry;\n\t\t} else {\n\t\t\terr = ___sys_recvmsg(sock,\n\t\t\t\t\t     (struct user_msghdr __user *)entry,\n\t\t\t\t\t     &msg_sys, flags & ~MSG_WAITFORONE,\n\t\t\t\t\t     datagrams);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t\terr = put_user(err, &entry->msg_len);\n\t\t\t++entry;\n\t\t}\n\n\t\tif (err)\n\t\t\tbreak;\n\t\t++datagrams;\n\n\t\t/* MSG_WAITFORONE turns on MSG_DONTWAIT after one packet */\n\t\tif (flags & MSG_WAITFORONE)\n\t\t\tflags |= MSG_DONTWAIT;\n\n\t\tif (timeout) {\n\t\t\tktime_get_ts(timeout);\n\t\t\t*timeout = timespec_sub(end_time, *timeout);\n\t\t\tif (timeout->tv_sec < 0) {\n\t\t\t\ttimeout->tv_sec = timeout->tv_nsec = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Timeout, return less than vlen datagrams */\n\t\t\tif (timeout->tv_nsec == 0 && timeout->tv_sec == 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Out of band data, return right away */\n\t\tif (msg_sys.msg_flags & MSG_OOB)\n\t\t\tbreak;\n \t\tcond_resched();\n \t}\n \nout_put:\n\tfput_light(sock->file, fput_needed);\n \tif (err == 0)\n\t\treturn datagrams;\n \n\tif (datagrams != 0) {\n \t\t/*\n\t\t * We may return less entries than requested (vlen) if the\n\t\t * sock is non block and there aren't enough datagrams...\n \t\t */\n\t\tif (err != -EAGAIN) {\n\t\t\t/*\n\t\t\t * ... or  if recvmsg returns an error after we\n\t\t\t * received some datagrams, where we record the\n\t\t\t * error to return on the next call or if the\n\t\t\t * app asks about it using getsockopt(SO_ERROR).\n\t\t\t */\n\t\t\tsock->sk->sk_err = -err;\n\t\t}\n\t\treturn datagrams;\n \t}\n \n\treturn err;\n }\n", "target": 1, "idx": 180133}
{"func": "void LocalRTCStatsRequest::requestSucceeded(\n    const LocalRTCStatsResponse* response) {\n  impl_.RequestSucceeded(response->webKitStatsResponse());\n}\n", "target": 0, "idx": 166047}
{"func": "static void srpt_get_svc_entries(u64 ioc_guid,\n\t\t\t\t u16 slot, u8 hi, u8 lo, struct ib_dm_mad *mad)\n{\n\tstruct ib_dm_svc_entries *svc_entries;\n\n\tWARN_ON(!ioc_guid);\n\n\tif (!slot || slot > 16) {\n\t\tmad->mad_hdr.status\n\t\t\t= cpu_to_be16(DM_MAD_STATUS_INVALID_FIELD);\n\t\treturn;\n\t}\n\n\tif (slot > 2 || lo > hi || hi > 1) {\n\t\tmad->mad_hdr.status\n\t\t\t= cpu_to_be16(DM_MAD_STATUS_NO_IOC);\n\t\treturn;\n\t}\n\n\tsvc_entries = (struct ib_dm_svc_entries *)mad->data;\n\tmemset(svc_entries, 0, sizeof *svc_entries);\n\tsvc_entries->service_entries[0].id = cpu_to_be64(ioc_guid);\n\tsnprintf(svc_entries->service_entries[0].name,\n\t\t sizeof(svc_entries->service_entries[0].name),\n\t\t \"%s%016llx\",\n\t\t SRP_SERVICE_NAME_PREFIX,\n\t\t ioc_guid);\n\n\tmad->mad_hdr.status = 0;\n}\n", "target": 0, "idx": 50663}
{"func": "static long snd_timer_user_ioctl(struct file *file, unsigned int cmd,\n \t\t\t\t unsigned long arg)\n {\n \tstruct snd_timer_user *tu;\n\tvoid __user *argp = (void __user *)arg;\n\tint __user *p = argp;\n\n\ttu = file->private_data;\n\tswitch (cmd) {\n\tcase SNDRV_TIMER_IOCTL_PVERSION:\n\t\treturn put_user(SNDRV_TIMER_VERSION, p) ? -EFAULT : 0;\n\tcase SNDRV_TIMER_IOCTL_NEXT_DEVICE:\n\t\treturn snd_timer_user_next_device(argp);\n\tcase SNDRV_TIMER_IOCTL_TREAD:\n \t{\n \t\tint xarg;\n \n\t\tmutex_lock(&tu->tread_sem);\n\t\tif (tu->timeri)\t{\t/* too late */\n\t\t\tmutex_unlock(&tu->tread_sem);\n \t\t\treturn -EBUSY;\n\t\t}\n\t\tif (get_user(xarg, p)) {\n\t\t\tmutex_unlock(&tu->tread_sem);\n \t\t\treturn -EFAULT;\n\t\t}\n \t\ttu->tread = xarg ? 1 : 0;\n\t\tmutex_unlock(&tu->tread_sem);\n \t\treturn 0;\n \t}\n \tcase SNDRV_TIMER_IOCTL_GINFO:\n\t\treturn snd_timer_user_ginfo(file, argp);\n\tcase SNDRV_TIMER_IOCTL_GPARAMS:\n\t\treturn snd_timer_user_gparams(file, argp);\n\tcase SNDRV_TIMER_IOCTL_GSTATUS:\n\t\treturn snd_timer_user_gstatus(file, argp);\n\tcase SNDRV_TIMER_IOCTL_SELECT:\n\t\treturn snd_timer_user_tselect(file, argp);\n\tcase SNDRV_TIMER_IOCTL_INFO:\n\t\treturn snd_timer_user_info(file, argp);\n\tcase SNDRV_TIMER_IOCTL_PARAMS:\n\t\treturn snd_timer_user_params(file, argp);\n\tcase SNDRV_TIMER_IOCTL_STATUS:\n\t\treturn snd_timer_user_status(file, argp);\n\tcase SNDRV_TIMER_IOCTL_START:\n\tcase SNDRV_TIMER_IOCTL_START_OLD:\n\t\treturn snd_timer_user_start(file);\n\tcase SNDRV_TIMER_IOCTL_STOP:\n\tcase SNDRV_TIMER_IOCTL_STOP_OLD:\n\t\treturn snd_timer_user_stop(file);\n\tcase SNDRV_TIMER_IOCTL_CONTINUE:\n\tcase SNDRV_TIMER_IOCTL_CONTINUE_OLD:\n\t\treturn snd_timer_user_continue(file);\n\tcase SNDRV_TIMER_IOCTL_PAUSE:\n\tcase SNDRV_TIMER_IOCTL_PAUSE_OLD:\n\t\treturn snd_timer_user_pause(file);\n\t}\n \treturn -ENOTTY;\n }\n", "target": 1, "idx": 180576}
{"func": "int InputDispatcher::handleReceiveCallback(int fd, int events, void* data) {\n InputDispatcher* d = static_cast<InputDispatcher*>(data);\n\n { // acquire lock\n AutoMutex _l(d->mLock);\n\n ssize_t connectionIndex = d->mConnectionsByFd.indexOfKey(fd);\n if (connectionIndex < 0) {\n            ALOGE(\"Received spurious receive callback for unknown input channel.  \"\n \"fd=%d, events=0x%x\", fd, events);\n return 0; // remove the callback\n }\n\n bool notify;\n        sp<Connection> connection = d->mConnectionsByFd.valueAt(connectionIndex);\n if (!(events & (ALOOPER_EVENT_ERROR | ALOOPER_EVENT_HANGUP))) {\n if (!(events & ALOOPER_EVENT_INPUT)) {\n                ALOGW(\"channel '%s' ~ Received spurious callback for unhandled poll event.  \"\n \"events=0x%x\", connection->getInputChannelName(), events);\n return 1;\n }\n\n nsecs_t currentTime = now();\n bool gotOne = false;\n status_t status;\n for (;;) {\n uint32_t seq;\n bool handled;\n                status = connection->inputPublisher.receiveFinishedSignal(&seq, &handled);\n if (status) {\n break;\n }\n                d->finishDispatchCycleLocked(currentTime, connection, seq, handled);\n                gotOne = true;\n }\n if (gotOne) {\n                d->runCommandsLockedInterruptible();\n if (status == WOULD_BLOCK) {\n return 1;\n }\n }\n\n            notify = status != DEAD_OBJECT || !connection->monitor;\n if (notify) {\n                ALOGE(\"channel '%s' ~ Failed to receive finished signal.  status=%d\",\n                        connection->getInputChannelName(), status);\n }\n } else {\n            notify = !connection->monitor;\n if (notify) {\n                ALOGW(\"channel '%s' ~ Consumer closed input channel or an error occurred.  \"\n \"events=0x%x\", connection->getInputChannelName(), events);\n }\n }\n\n        d->unregisterInputChannelLocked(connection->inputChannel, notify);\n return 0; // remove the callback\n } // release lock\n}\n", "target": 0, "idx": 176948}
{"func": " static void ipv6_select_ident(struct frag_hdr *fhdr, struct rt6_info *rt)\n {\n \tstatic u32 ip6_idents_hashrnd __read_mostly;\n \tu32 hash, id;\n \n \tnet_get_random_once(&ip6_idents_hashrnd, sizeof(ip6_idents_hashrnd));\n \n \thash = __ipv6_addr_jhash(&rt->rt6i_dst.addr, ip6_idents_hashrnd);\n \thash = __ipv6_addr_jhash(&rt->rt6i_src.addr, hash);\n \n \tid = ip_idents_reserve(hash, 1);\n \tfhdr->identification = htonl(id);\n}\n", "target": 1, "idx": 183410}
{"func": "static int check_func_proto(const struct bpf_func_proto *fn)\n{\n\treturn check_raw_mode_ok(fn) &&\n\t       check_arg_pair_ok(fn) &&\n\t       check_refcount_ok(fn) ? 0 : -EINVAL;\n}\n", "target": 0, "idx": 91408}
{"func": "static const char *register_authz_provider(cmd_parms *cmd, void *_cfg,\n                                           const char *name, const char *file,\n                                           const char *function)\n{\n    lua_authz_provider_spec *spec;\n    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);\n    if (err)\n        return err;\n\n    spec = apr_pcalloc(cmd->pool, sizeof(*spec));\n    spec->name = name;\n    spec->file_name = file;\n    spec->function_name = function;\n\n    apr_hash_set(lua_authz_providers, name, APR_HASH_KEY_STRING, spec);\n    ap_register_auth_provider(cmd->pool, AUTHZ_PROVIDER_GROUP, name,\n                              AUTHZ_PROVIDER_VERSION,\n                              &lua_authz_provider,\n                              AP_AUTH_INTERNAL_PER_CONF);\n    return NULL;\n}\n", "target": 0, "idx": 35719}
{"func": "  explicit ImageDecodedHandlerWithTimeout(\n      const base::Callback<void(const SkBitmap&)>& image_decoded_callback)\n      : image_decoded_callback_(image_decoded_callback),\n        weak_ptr_factory_(this) {}\n", "target": 1, "idx": 185831}
{"func": "void __show_regs(struct pt_regs *regs, int all)\n{\n\tunsigned long cr0 = 0L, cr2 = 0L, cr3 = 0L, cr4 = 0L, fs, gs, shadowgs;\n\tunsigned long d0, d1, d2, d3, d6, d7;\n\tunsigned int fsindex, gsindex;\n\tunsigned int ds, cs, es;\n\n\tprintk(KERN_DEFAULT \"RIP: %04lx:[<%016lx>] \", regs->cs & 0xffff, regs->ip);\n\tprintk_address(regs->ip);\n\tprintk(KERN_DEFAULT \"RSP: %04lx:%016lx  EFLAGS: %08lx\\n\", regs->ss,\n\t\t\tregs->sp, regs->flags);\n\tprintk(KERN_DEFAULT \"RAX: %016lx RBX: %016lx RCX: %016lx\\n\",\n\t       regs->ax, regs->bx, regs->cx);\n\tprintk(KERN_DEFAULT \"RDX: %016lx RSI: %016lx RDI: %016lx\\n\",\n\t       regs->dx, regs->si, regs->di);\n\tprintk(KERN_DEFAULT \"RBP: %016lx R08: %016lx R09: %016lx\\n\",\n\t       regs->bp, regs->r8, regs->r9);\n\tprintk(KERN_DEFAULT \"R10: %016lx R11: %016lx R12: %016lx\\n\",\n\t       regs->r10, regs->r11, regs->r12);\n\tprintk(KERN_DEFAULT \"R13: %016lx R14: %016lx R15: %016lx\\n\",\n\t       regs->r13, regs->r14, regs->r15);\n\n\tasm(\"movl %%ds,%0\" : \"=r\" (ds));\n\tasm(\"movl %%cs,%0\" : \"=r\" (cs));\n\tasm(\"movl %%es,%0\" : \"=r\" (es));\n\tasm(\"movl %%fs,%0\" : \"=r\" (fsindex));\n\tasm(\"movl %%gs,%0\" : \"=r\" (gsindex));\n\n\trdmsrl(MSR_FS_BASE, fs);\n\trdmsrl(MSR_GS_BASE, gs);\n\trdmsrl(MSR_KERNEL_GS_BASE, shadowgs);\n\n\tif (!all)\n\t\treturn;\n\n\tcr0 = read_cr0();\n\tcr2 = read_cr2();\n\tcr3 = read_cr3();\n\tcr4 = read_cr4();\n\n\tprintk(KERN_DEFAULT \"FS:  %016lx(%04x) GS:%016lx(%04x) knlGS:%016lx\\n\",\n\t       fs, fsindex, gs, gsindex, shadowgs);\n\tprintk(KERN_DEFAULT \"CS:  %04x DS: %04x ES: %04x CR0: %016lx\\n\", cs, ds,\n\t\t\tes, cr0);\n\tprintk(KERN_DEFAULT \"CR2: %016lx CR3: %016lx CR4: %016lx\\n\", cr2, cr3,\n\t\t\tcr4);\n\n\tget_debugreg(d0, 0);\n\tget_debugreg(d1, 1);\n\tget_debugreg(d2, 2);\n\tget_debugreg(d3, 3);\n\tget_debugreg(d6, 6);\n\tget_debugreg(d7, 7);\n\n\t/* Only print out debug registers if they are in their non-default state. */\n\tif ((d0 == 0) && (d1 == 0) && (d2 == 0) && (d3 == 0) &&\n\t    (d6 == DR6_RESERVED) && (d7 == 0x400))\n\t\treturn;\n\n\tprintk(KERN_DEFAULT \"DR0: %016lx DR1: %016lx DR2: %016lx\\n\", d0, d1, d2);\n\tprintk(KERN_DEFAULT \"DR3: %016lx DR6: %016lx DR7: %016lx\\n\", d3, d6, d7);\n\n}\n", "target": 0, "idx": 35387}
{"func": "void HTMLConstructionSite::insertCommentOnDocument(AtomicHTMLToken& token)\n{\n    ASSERT(token.type() == HTMLToken::Comment);\n    attach(m_document, Comment::create(m_document, token.comment()));\n}\n", "target": 0, "idx": 98922}
{"func": "void Location::SetLocation(const String& url,\n                           LocalDOMWindow* current_window,\n                           LocalDOMWindow* entered_window,\n                           ExceptionState* exception_state,\n                           SetLocationPolicy set_location_policy) {\n  if (!IsAttached())\n    return;\n\n  if (!current_window->GetFrame())\n    return;\n\n  Document* entered_document = entered_window->document();\n  if (!entered_document)\n    return;\n\n  KURL completed_url = entered_document->CompleteURL(url);\n  if (completed_url.IsNull())\n    return;\n\n  if (!current_window->GetFrame()->CanNavigate(*dom_window_->GetFrame(),\n                                               completed_url)) {\n    if (exception_state) {\n      exception_state->ThrowSecurityError(\n          \"The current window does not have permission to navigate the target \"\n          \"frame to '\" +\n          url + \"'.\");\n    }\n    return;\n  }\n  if (exception_state && !completed_url.IsValid()) {\n    exception_state->ThrowDOMException(DOMExceptionCode::kSyntaxError,\n                                       \"'\" + url + \"' is not a valid URL.\");\n    return;\n  }\n\n   if (dom_window_->IsInsecureScriptAccess(*current_window, completed_url))\n     return;\n \n   V8DOMActivityLogger* activity_logger =\n       V8DOMActivityLogger::CurrentActivityLoggerIfIsolatedWorld();\n   if (activity_logger) {\n    Vector<String> argv;\n    argv.push_back(\"LocalDOMWindow\");\n    argv.push_back(\"url\");\n    argv.push_back(entered_document->Url());\n    argv.push_back(completed_url);\n    activity_logger->LogEvent(\"blinkSetAttribute\", argv.size(), argv.data());\n  }\n  WebFrameLoadType frame_load_type = WebFrameLoadType::kStandard;\n  if (set_location_policy == SetLocationPolicy::kReplaceThisFrame)\n    frame_load_type = WebFrameLoadType::kReplaceCurrentItem;\n  dom_window_->GetFrame()->ScheduleNavigation(*current_window->document(),\n                                              completed_url, frame_load_type,\n                                              UserGestureStatus::kNone);\n}\n", "target": 1, "idx": 187045}
{"func": "bit_catenate(VarBit *arg1, VarBit *arg2)\n{\n\tVarBit\t   *result;\n\tint\t\t\tbitlen1,\n\t\t\t\tbitlen2,\n\t\t\t\tbytelen,\n\t\t\t\tbit1pad,\n\t\t\t\tbit2shift;\n\tbits8\t   *pr,\n\t\t\t   *pa;\n\n \tbitlen1 = VARBITLEN(arg1);\n \tbitlen2 = VARBITLEN(arg2);\n \n \tbytelen = VARBITTOTALLEN(bitlen1 + bitlen2);\n \n \tresult = (VarBit *) palloc(bytelen);\n\tSET_VARSIZE(result, bytelen);\n\tVARBITLEN(result) = bitlen1 + bitlen2;\n\n\t/* Copy the first bitstring in */\n\tmemcpy(VARBITS(result), VARBITS(arg1), VARBITBYTES(arg1));\n\n\t/* Copy the second bit string */\n\tbit1pad = VARBITPAD(arg1);\n\tif (bit1pad == 0)\n\t{\n\t\tmemcpy(VARBITS(result) + VARBITBYTES(arg1), VARBITS(arg2),\n\t\t\t   VARBITBYTES(arg2));\n\t}\n\telse if (bitlen2 > 0)\n\t{\n\t\t/* We need to shift all the bits to fit */\n\t\tbit2shift = BITS_PER_BYTE - bit1pad;\n\t\tpr = VARBITS(result) + VARBITBYTES(arg1) - 1;\n\t\tfor (pa = VARBITS(arg2); pa < VARBITEND(arg2); pa++)\n\t\t{\n\t\t\t*pr |= ((*pa >> bit2shift) & BITMASK);\n\t\t\tpr++;\n\t\t\tif (pr < VARBITEND(result))\n\t\t\t\t*pr = (*pa << bit1pad) & BITMASK;\n\t\t}\n\t}\n\n\treturn result;\n}\n", "target": 1, "idx": 179589}
{"func": "PHP_METHOD(Phar, buildFromDirectory)\n{\n\tchar *dir, *error, *regex = NULL;\n\tsize_t dir_len, regex_len = 0;\n\tzend_bool apply_reg = 0;\n\tzval arg, arg2, iter, iteriter, regexiter;\n\tstruct _phar_t pass;\n\n\tPHAR_ARCHIVE_OBJECT();\n\n\tif (PHAR_G(readonly) && !phar_obj->archive->is_data) {\n\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0,\n\t\t\t\"Cannot write to archive - write operations restricted by INI setting\");\n                return;\n        }\n \n       if (zend_parse_parameters(ZEND_NUM_ARGS(), \"s|s\", &dir, &dir_len, &regex, &regex_len) == FAILURE) {\n                RETURN_FALSE;\n        }\n \n\tif (SUCCESS != object_init_ex(&iter, spl_ce_RecursiveDirectoryIterator)) {\n\t\tzval_ptr_dtor(&iter);\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0, \"Unable to instantiate directory iterator for %s\", phar_obj->archive->fname);\n\t\tRETURN_FALSE;\n\t}\n\n\tZVAL_STRINGL(&arg, dir, dir_len);\n\tZVAL_LONG(&arg2, SPL_FILE_DIR_SKIPDOTS|SPL_FILE_DIR_UNIXPATHS);\n\n\tzend_call_method_with_2_params(&iter, spl_ce_RecursiveDirectoryIterator,\n\t\t\t&spl_ce_RecursiveDirectoryIterator->constructor, \"__construct\", NULL, &arg, &arg2);\n\n\tzval_ptr_dtor(&arg);\n\tif (EG(exception)) {\n\t\tzval_ptr_dtor(&iter);\n\t\tRETURN_FALSE;\n\t}\n\n\tif (SUCCESS != object_init_ex(&iteriter, spl_ce_RecursiveIteratorIterator)) {\n\t\tzval_ptr_dtor(&iter);\n\t\tzval_ptr_dtor(&iteriter);\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0, \"Unable to instantiate directory iterator for %s\", phar_obj->archive->fname);\n\t\tRETURN_FALSE;\n\t}\n\n\tzend_call_method_with_1_params(&iteriter, spl_ce_RecursiveIteratorIterator,\n\t\t\t&spl_ce_RecursiveIteratorIterator->constructor, \"__construct\", NULL, &iter);\n\n\tif (EG(exception)) {\n\t\tzval_ptr_dtor(&iter);\n\t\tzval_ptr_dtor(&iteriter);\n\t\tRETURN_FALSE;\n\t}\n\n\tzval_ptr_dtor(&iter);\n\n\tif (regex_len > 0) {\n\t\tapply_reg = 1;\n\n\t\tif (SUCCESS != object_init_ex(&regexiter, spl_ce_RegexIterator)) {\n\t\t\tzval_ptr_dtor(&iteriter);\n\t\t\tzval_dtor(&regexiter);\n\t\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0, \"Unable to instantiate regex iterator for %s\", phar_obj->archive->fname);\n\t\t\tRETURN_FALSE;\n\t\t}\n\n\t\tZVAL_STRINGL(&arg2, regex, regex_len);\n\n\t\tzend_call_method_with_2_params(&regexiter, spl_ce_RegexIterator,\n\t\t\t&spl_ce_RegexIterator->constructor, \"__construct\", NULL, &iteriter, &arg2);\n\t\tzval_ptr_dtor(&arg2);\n\t}\n\n\tarray_init(return_value);\n\n\tpass.c = apply_reg ? Z_OBJCE(regexiter) : Z_OBJCE(iteriter);\n\tpass.p = phar_obj;\n\tpass.b = dir;\n\tpass.l = dir_len;\n\tpass.count = 0;\n\tpass.ret = return_value;\n\tpass.fp = php_stream_fopen_tmpfile();\n\tif (pass.fp == NULL) {\n\t\tzend_throw_exception_ex(phar_ce_PharException, 0, \"phar \\\"%s\\\" unable to create temporary file\", phar_obj->archive->fname);\n\t\treturn;\n\t}\n\n\tif (phar_obj->archive->is_persistent && FAILURE == phar_copy_on_write(&(phar_obj->archive))) {\n\t\tzval_ptr_dtor(&iteriter);\n\t\tif (apply_reg) {\n\t\t\tzval_ptr_dtor(&regexiter);\n\t\t}\n\t\tphp_stream_close(pass.fp);\n\t\tzend_throw_exception_ex(phar_ce_PharException, 0, \"phar \\\"%s\\\" is persistent, unable to copy on write\", phar_obj->archive->fname);\n\t\treturn;\n\t}\n\n\tif (SUCCESS == spl_iterator_apply((apply_reg ? &regexiter : &iteriter), (spl_iterator_apply_func_t) phar_build, (void *) &pass)) {\n\t\tzval_ptr_dtor(&iteriter);\n\n\t\tif (apply_reg) {\n\t\t\tzval_ptr_dtor(&regexiter);\n\t\t}\n\n\t\tphar_obj->archive->ufp = pass.fp;\n\t\tphar_flush(phar_obj->archive, 0, 0, 0, &error);\n\n\t\tif (error) {\n\t\t\tzend_throw_exception_ex(phar_ce_PharException, 0, \"%s\", error);\n\t\t\tefree(error);\n\t\t}\n\n\t} else {\n\t\tzval_ptr_dtor(&iteriter);\n\t\tif (apply_reg) {\n\t\t\tzval_ptr_dtor(&regexiter);\n\t\t}\n\t\tphp_stream_close(pass.fp);\n\t}\n}\n", "target": 1, "idx": 178234}
{"func": "xsltParseStylesheetCallerParam(xsltTransformContextPtr ctxt, xmlNodePtr inst)\n{\n#ifdef XSLT_REFACTORED\n    xsltStyleBasicItemVariablePtr comp;\n#else\n    xsltStylePreCompPtr comp;\n#endif\n    xmlNodePtr tree = NULL; /* The first child node of the instruction or\n                               the instruction itself. */\n    xsltStackElemPtr param = NULL;\n\n    if ((ctxt == NULL) || (inst == NULL) || (inst->type != XML_ELEMENT_NODE))\n\treturn(NULL);\n\n#ifdef XSLT_REFACTORED\n    comp = (xsltStyleBasicItemVariablePtr) inst->psvi;\n#else\n    comp = (xsltStylePreCompPtr) inst->psvi;\n#endif\n\n    if (comp == NULL) {\n        xsltTransformError(ctxt, NULL, inst,\n\t    \"Internal error in xsltParseStylesheetCallerParam(): \"\n\t    \"The XSLT 'with-param' instruction was not compiled.\\n\");\n        return(NULL);\n    }\n    if (comp->name == NULL) {\n\txsltTransformError(ctxt, NULL, inst,\n\t    \"Internal error in xsltParseStylesheetCallerParam(): \"\n\t    \"XSLT 'with-param': The attribute 'name' was not compiled.\\n\");\n\treturn(NULL);\n    }\n\n#ifdef WITH_XSLT_DEBUG_VARIABLE\n    XSLT_TRACE(ctxt,XSLT_TRACE_VARIABLES,xsltGenericDebug(xsltGenericDebugContext,\n\t    \"Handling xsl:with-param %s\\n\", comp->name));\n#endif\n\n    if (comp->select == NULL) {\n\ttree = inst->children;\n    } else {\n#ifdef WITH_XSLT_DEBUG_VARIABLE\n\tXSLT_TRACE(ctxt,XSLT_TRACE_VARIABLES,xsltGenericDebug(xsltGenericDebugContext,\n\t    \"        select %s\\n\", comp->select));\n#endif\n\ttree = inst;\n    }\n\n    param = xsltBuildVariable(ctxt, (xsltStylePreCompPtr) comp, tree);\n\n    return(param);\n}\n", "target": 0, "idx": 170036}
{"func": "OmniboxEditModel::State::State(bool user_input_in_progress,\n                               const base::string16& user_text,\n                               const base::string16& gray_text,\n                               const base::string16& keyword,\n                               bool is_keyword_hint,\n                               bool url_replacement_enabled,\n                               OmniboxFocusState focus_state,\n                               FocusSource focus_source,\n                               const AutocompleteInput& autocomplete_input)\n    : user_input_in_progress(user_input_in_progress),\n      user_text(user_text),\n      gray_text(gray_text),\n      keyword(keyword),\n      is_keyword_hint(is_keyword_hint),\n      url_replacement_enabled(url_replacement_enabled),\n      focus_state(focus_state),\n      focus_source(focus_source),\n      autocomplete_input(autocomplete_input) {\n}\n", "target": 0, "idx": 119362}
{"func": "WORD32 ih264d_parse_sei_message(dec_struct_t *ps_dec,\n dec_bit_stream_t *ps_bitstrm)\n{\n    UWORD32 ui4_payload_type, ui4_payload_size;\n    UWORD32 u4_bits;\n    WORD32 i4_status = 0;\n\n do\n {\n\n         ui4_payload_type = 0;\n \n         u4_bits = ih264d_get_bits_h264(ps_bitstrm, 8);\n        while(0xff == u4_bits)\n         {\n             u4_bits = ih264d_get_bits_h264(ps_bitstrm, 8);\n             ui4_payload_type += 255;\n }\n        ui4_payload_type += u4_bits;\n\n \n         ui4_payload_size = 0;\n         u4_bits = ih264d_get_bits_h264(ps_bitstrm, 8);\n        while(0xff == u4_bits)\n         {\n             u4_bits = ih264d_get_bits_h264(ps_bitstrm, 8);\n             ui4_payload_size += 255;\n }\n        ui4_payload_size += u4_bits;\n\n        i4_status = ih264d_parse_sei_payload(ps_bitstrm, ui4_payload_type,\n                                             ui4_payload_size, ps_dec);\n if(i4_status == -1)\n {\n            i4_status = 0;\n break;\n }\n\n if(i4_status != OK)\n return i4_status;\n\n if(ih264d_check_byte_aligned(ps_bitstrm) == 0)\n {\n            u4_bits = ih264d_get_bit_h264(ps_bitstrm);\n if(0 == u4_bits)\n\n             {\n                 H264_DEC_DEBUG_PRINT(\"\\nError in parsing SEI message\");\n             }\n            while(0 == ih264d_check_byte_aligned(ps_bitstrm))\n             {\n                 u4_bits = ih264d_get_bit_h264(ps_bitstrm);\n                 if(u4_bits)\n {\n                    H264_DEC_DEBUG_PRINT(\"\\nError in parsing SEI message\");\n }\n }\n }\n }\n while(ps_bitstrm->u4_ofst < ps_bitstrm->u4_max_ofst);\n return (i4_status);\n}\n", "target": 1, "idx": 188129}
{"func": "u32 h264bsdInit(storage_t *pStorage, u32 noOutputReordering)\n{\n\n/* Variables */\n    u32 size;\n/* Code */\n\n    ASSERT(pStorage);\n\n    h264bsdInitStorage(pStorage);\n\n /* allocate mbLayer to be next multiple of 64 to enable use of\n\n      * specific NEON optimized \"memset\" for clearing the structure */\n     size = (sizeof(macroblockLayer_t) + 63) & ~0x3F;\n \n    pStorage->mbLayer = (macroblockLayer_t*)H264SwDecMalloc(size);\n     if (!pStorage->mbLayer)\n         return HANTRO_NOK;\n \n if (noOutputReordering)\n        pStorage->noReordering = HANTRO_TRUE;\n\n return HANTRO_OK;\n}\n", "target": 1, "idx": 187898}
{"func": "my_object_emit_frobnicate (MyObject *obj, GError **error)\n{\n  g_signal_emit (obj, signals[FROBNICATE], 0, 42);\n  return TRUE;\n}\n", "target": 1, "idx": 178266}
{"func": "bool LayerTreeHost::IsSingleThreaded() const {\n  DCHECK(compositor_mode_ != CompositorMode::SINGLE_THREADED ||\n         !task_runner_provider_->HasImplThread());\n  return compositor_mode_ == CompositorMode::SINGLE_THREADED;\n}\n", "target": 0, "idx": 149806}
{"func": "static void perf_remove_from_owner(struct perf_event *event)\n{\n\tstruct task_struct *owner;\n\n\trcu_read_lock();\n\towner = ACCESS_ONCE(event->owner);\n\t/*\n\t * Matches the smp_wmb() in perf_event_exit_task(). If we observe\n\t * !owner it means the list deletion is complete and we can indeed\n\t * free this event, otherwise we need to serialize on\n\t * owner->perf_event_mutex.\n\t */\n\tsmp_read_barrier_depends();\n\tif (owner) {\n\t\t/*\n\t\t * Since delayed_put_task_struct() also drops the last\n\t\t * task reference we can safely take a new reference\n\t\t * while holding the rcu_read_lock().\n\t\t */\n\t\tget_task_struct(owner);\n\t}\n \trcu_read_unlock();\n \n \tif (owner) {\n\t\tmutex_lock(&owner->perf_event_mutex);\n \t\t/*\n \t\t * We have to re-check the event->owner field, if it is cleared\n \t\t * we raced with perf_event_exit_task(), acquiring the mutex\n\t\t * ensured they're done, and we can proceed with freeing the\n\t\t * event.\n\t\t */\n\t\tif (event->owner)\n\t\t\tlist_del_init(&event->owner_entry);\n\t\tmutex_unlock(&owner->perf_event_mutex);\n\t\tput_task_struct(owner);\n\t}\n}\n", "target": 1, "idx": 180166}
{"func": "int TestOpenProcess(DWORD process_id) {\n  HANDLE process = ::OpenProcess(PROCESS_VM_READ,\n                                  FALSE,  // Do not inherit handle.\n                                  process_id);\n   if (NULL == process) {\n    if (ERROR_ACCESS_DENIED == ::GetLastError()) {\n      return SBOX_TEST_DENIED;\n    } else {\n      return SBOX_TEST_FAILED_TO_EXECUTE_COMMAND;\n    }\n  } else {\n    ::CloseHandle(process);\n    return SBOX_TEST_SUCCEEDED;\n  }\n}\n", "target": 1, "idx": 184542}
{"func": "void PrintMsg_Print_Params::Reset() {\n  page_size = gfx::Size();\n  content_size = gfx::Size();\n  printable_area = gfx::Rect();\n  margin_top = 0;\n  margin_left = 0;\n  dpi = 0;\n  min_shrink = 0;\n  max_shrink = 0;\n  desired_dpi = 0;\n   document_cookie = 0;\n   selection_only = false;\n   supports_alpha_blend = false;\n  preview_ui_addr = std::string();\n   preview_request_id = 0;\n   is_first_request = false;\n   print_scaling_option = WebKit::WebPrintScalingOptionSourceSize;\n  print_to_pdf = false;\n  display_header_footer = false;\n  date = string16();\n  title = string16();\n  url = string16();\n}\n", "target": 1, "idx": 184420}
{"func": "map_engine_on_person_event(person_op_t op, script_t* script)\n{\n\tscript_t* old_script;\n\n\told_script = s_def_person_scripts[op];\n\ts_def_person_scripts[op] = script_ref(script);\n\tscript_unref(old_script);\n}\n", "target": 0, "idx": 75035}
{"func": " static inline void sem_lock_and_putref(struct sem_array *sma)\n {\n\tipc_lock_by_ptr(&sma->sem_perm);\n \tipc_rcu_putref(sma);\n }\n", "target": 1, "idx": 179147}
{"func": "void HTMLImportsController::Trace(blink::Visitor* visitor) {\n  visitor->Trace(root_);\n  visitor->Trace(loaders_);\n}\n", "target": 0, "idx": 158805}
{"func": "static int futex_requeue(u32 __user *uaddr1, unsigned int flags,\n\t\t\t u32 __user *uaddr2, int nr_wake, int nr_requeue,\n\t\t\t u32 *cmpval, int requeue_pi)\n{\n\tunion futex_key key1 = FUTEX_KEY_INIT, key2 = FUTEX_KEY_INIT;\n\tint drop_count = 0, task_count = 0, ret;\n\tstruct futex_pi_state *pi_state = NULL;\n\tstruct futex_hash_bucket *hb1, *hb2;\n \tstruct futex_q *this, *next;\n \n \tif (requeue_pi) {\n \t\t/*\n \t\t * requeue_pi requires a pi_state, try to allocate it now\n \t\t * without any locks in case it fails.\n\t\t */\n\t\tif (refill_pi_state_cache())\n\t\t\treturn -ENOMEM;\n\t\t/*\n\t\t * requeue_pi must wake as many tasks as it can, up to nr_wake\n\t\t * + nr_requeue, since it acquires the rt_mutex prior to\n\t\t * returning to userspace, so as to not leave the rt_mutex with\n\t\t * waiters and no owner.  However, second and third wake-ups\n\t\t * cannot be predicted as they involve race conditions with the\n\t\t * first wake and a fault while looking up the pi_state.  Both\n\t\t * pthread_cond_signal() and pthread_cond_broadcast() should\n\t\t * use nr_wake=1.\n\t\t */\n\t\tif (nr_wake != 1)\n\t\t\treturn -EINVAL;\n\t}\n\nretry:\n\tif (pi_state != NULL) {\n\t\t/*\n\t\t * We will have to lookup the pi_state again, so free this one\n\t\t * to keep the accounting correct.\n\t\t */\n\t\tfree_pi_state(pi_state);\n\t\tpi_state = NULL;\n\t}\n\n\tret = get_futex_key(uaddr1, flags & FLAGS_SHARED, &key1, VERIFY_READ);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\tret = get_futex_key(uaddr2, flags & FLAGS_SHARED, &key2,\n\t\t\t    requeue_pi ? VERIFY_WRITE : VERIFY_READ);\n \tif (unlikely(ret != 0))\n \t\tgoto out_put_key1;\n \n \thb1 = hash_futex(&key1);\n \thb2 = hash_futex(&key2);\n \nretry_private:\n\thb_waiters_inc(hb2);\n\tdouble_lock_hb(hb1, hb2);\n\n\tif (likely(cmpval != NULL)) {\n\t\tu32 curval;\n\n\t\tret = get_futex_value_locked(&curval, uaddr1);\n\n\t\tif (unlikely(ret)) {\n\t\t\tdouble_unlock_hb(hb1, hb2);\n\t\t\thb_waiters_dec(hb2);\n\n\t\t\tret = get_user(curval, uaddr1);\n\t\t\tif (ret)\n\t\t\t\tgoto out_put_keys;\n\n\t\t\tif (!(flags & FLAGS_SHARED))\n\t\t\t\tgoto retry_private;\n\n\t\t\tput_futex_key(&key2);\n\t\t\tput_futex_key(&key1);\n\t\t\tgoto retry;\n\t\t}\n\t\tif (curval != *cmpval) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tif (requeue_pi && (task_count - nr_wake < nr_requeue)) {\n\t\t/*\n\t\t * Attempt to acquire uaddr2 and wake the top waiter. If we\n\t\t * intend to requeue waiters, force setting the FUTEX_WAITERS\n\t\t * bit.  We force this here where we are able to easily handle\n\t\t * faults rather in the requeue loop below.\n\t\t */\n\t\tret = futex_proxy_trylock_atomic(uaddr2, hb1, hb2, &key1,\n\t\t\t\t\t\t &key2, &pi_state, nr_requeue);\n\n\t\t/*\n\t\t * At this point the top_waiter has either taken uaddr2 or is\n\t\t * waiting on it.  If the former, then the pi_state will not\n\t\t * exist yet, look it up one more time to ensure we have a\n\t\t * reference to it. If the lock was taken, ret contains the\n\t\t * vpid of the top waiter task.\n\t\t */\n\t\tif (ret > 0) {\n\t\t\tWARN_ON(pi_state);\n\t\t\tdrop_count++;\n\t\t\ttask_count++;\n\t\t\t/*\n\t\t\t * If we acquired the lock, then the user\n\t\t\t * space value of uaddr2 should be vpid. It\n\t\t\t * cannot be changed by the top waiter as it\n\t\t\t * is blocked on hb2 lock if it tries to do\n\t\t\t * so. If something fiddled with it behind our\n\t\t\t * back the pi state lookup might unearth\n\t\t\t * it. So we rather use the known value than\n\t\t\t * rereading and handing potential crap to\n\t\t\t * lookup_pi_state.\n\t\t\t */\n\t\t\tret = lookup_pi_state(ret, hb2, &key2, &pi_state, NULL);\n\t\t}\n\n\t\tswitch (ret) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase -EFAULT:\n\t\t\tdouble_unlock_hb(hb1, hb2);\n\t\t\thb_waiters_dec(hb2);\n\t\t\tput_futex_key(&key2);\n\t\t\tput_futex_key(&key1);\n\t\t\tret = fault_in_user_writeable(uaddr2);\n\t\t\tif (!ret)\n\t\t\t\tgoto retry;\n\t\t\tgoto out;\n\t\tcase -EAGAIN:\n\t\t\t/* The owner was exiting, try again. */\n\t\t\tdouble_unlock_hb(hb1, hb2);\n\t\t\thb_waiters_dec(hb2);\n\t\t\tput_futex_key(&key2);\n\t\t\tput_futex_key(&key1);\n\t\t\tcond_resched();\n\t\t\tgoto retry;\n\t\tdefault:\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tplist_for_each_entry_safe(this, next, &hb1->chain, list) {\n\t\tif (task_count - nr_wake >= nr_requeue)\n\t\t\tbreak;\n\n\t\tif (!match_futex(&this->key, &key1))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * FUTEX_WAIT_REQEUE_PI and FUTEX_CMP_REQUEUE_PI should always\n\t\t * be paired with each other and no other futex ops.\n\t\t *\n\t\t * We should never be requeueing a futex_q with a pi_state,\n\t\t * which is awaiting a futex_unlock_pi().\n\t\t */\n\t\tif ((requeue_pi && !this->rt_waiter) ||\n\t\t    (!requeue_pi && this->rt_waiter) ||\n\t\t    this->pi_state) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Wake nr_wake waiters.  For requeue_pi, if we acquired the\n\t\t * lock, we already woke the top_waiter.  If not, it will be\n\t\t * woken by futex_unlock_pi().\n\t\t */\n\t\tif (++task_count <= nr_wake && !requeue_pi) {\n\t\t\twake_futex(this);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Ensure we requeue to the expected futex for requeue_pi. */\n\t\tif (requeue_pi && !match_futex(this->requeue_pi_key, &key2)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Requeue nr_requeue waiters and possibly one more in the case\n\t\t * of requeue_pi if we couldn't acquire the lock atomically.\n\t\t */\n\t\tif (requeue_pi) {\n\t\t\t/* Prepare the waiter to take the rt_mutex. */\n\t\t\tatomic_inc(&pi_state->refcount);\n\t\t\tthis->pi_state = pi_state;\n\t\t\tret = rt_mutex_start_proxy_lock(&pi_state->pi_mutex,\n\t\t\t\t\t\t\tthis->rt_waiter,\n\t\t\t\t\t\t\tthis->task, 1);\n\t\t\tif (ret == 1) {\n\t\t\t\t/* We got the lock. */\n\t\t\t\trequeue_pi_wake_futex(this, &key2, hb2);\n\t\t\t\tdrop_count++;\n\t\t\t\tcontinue;\n\t\t\t} else if (ret) {\n\t\t\t\t/* -EDEADLK */\n\t\t\t\tthis->pi_state = NULL;\n\t\t\t\tfree_pi_state(pi_state);\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t}\n\t\trequeue_futex(this, hb1, hb2, &key2);\n\t\tdrop_count++;\n\t}\n\nout_unlock:\n\tdouble_unlock_hb(hb1, hb2);\n\thb_waiters_dec(hb2);\n\n\t/*\n\t * drop_futex_key_refs() must be called outside the spinlocks. During\n\t * the requeue we moved futex_q's from the hash bucket at key1 to the\n\t * one at key2 and updated their key pointer.  We no longer need to\n\t * hold the references to key1.\n\t */\n\twhile (--drop_count >= 0)\n\t\tdrop_futex_key_refs(&key1);\n\nout_put_keys:\n\tput_futex_key(&key2);\nout_put_key1:\n\tput_futex_key(&key1);\nout:\n\tif (pi_state != NULL)\n\t\tfree_pi_state(pi_state);\n\treturn ret ? ret : task_count;\n}\n", "target": 1, "idx": 179553}
{"func": "static int sctp_process_param(struct sctp_association *asoc,\n\t\t\t      union sctp_params param,\n\t\t\t      const union sctp_addr *peer_addr,\n\t\t\t      gfp_t gfp)\n{\n\tstruct net *net = sock_net(asoc->base.sk);\n\tunion sctp_addr addr;\n\tint i;\n\t__u16 sat;\n\tint retval = 1;\n\tsctp_scope_t scope;\n\ttime_t stale;\n\tstruct sctp_af *af;\n\tunion sctp_addr_param *addr_param;\n\tstruct sctp_transport *t;\n\tstruct sctp_endpoint *ep = asoc->ep;\n\n\t/* We maintain all INIT parameters in network byte order all the\n\t * time.  This allows us to not worry about whether the parameters\n\t * came from a fresh INIT, and INIT ACK, or were stored in a cookie.\n\t */\n\tswitch (param.p->type) {\n\tcase SCTP_PARAM_IPV6_ADDRESS:\n\t\tif (PF_INET6 != asoc->base.sk->sk_family)\n\t\t\tbreak;\n\t\tgoto do_addr_param;\n\n\tcase SCTP_PARAM_IPV4_ADDRESS:\n\t\t/* v4 addresses are not allowed on v6-only socket */\n\t\tif (ipv6_only_sock(asoc->base.sk))\n\t\t\tbreak;\ndo_addr_param:\n\t\taf = sctp_get_af_specific(param_type2af(param.p->type));\n\t\taf->from_addr_param(&addr, param.addr, htons(asoc->peer.port), 0);\n\t\tscope = sctp_scope(peer_addr);\n\t\tif (sctp_in_scope(net, &addr, scope))\n\t\t\tif (!sctp_assoc_add_peer(asoc, &addr, gfp, SCTP_UNCONFIRMED))\n\t\t\t\treturn 0;\n\t\tbreak;\n\n\tcase SCTP_PARAM_COOKIE_PRESERVATIVE:\n\t\tif (!net->sctp.cookie_preserve_enable)\n\t\t\tbreak;\n\n\t\tstale = ntohl(param.life->lifespan_increment);\n\n\t\t/* Suggested Cookie Life span increment's unit is msec,\n\t\t * (1/1000sec).\n\t\t */\n\t\tasoc->cookie_life = ktime_add_ms(asoc->cookie_life, stale);\n\t\tbreak;\n\n\tcase SCTP_PARAM_HOST_NAME_ADDRESS:\n\t\tpr_debug(\"%s: unimplemented SCTP_HOST_NAME_ADDRESS\\n\", __func__);\n\t\tbreak;\n\n\tcase SCTP_PARAM_SUPPORTED_ADDRESS_TYPES:\n\t\t/* Turn off the default values first so we'll know which\n\t\t * ones are really set by the peer.\n\t\t */\n\t\tasoc->peer.ipv4_address = 0;\n\t\tasoc->peer.ipv6_address = 0;\n\n\t\t/* Assume that peer supports the address family\n\t\t * by which it sends a packet.\n\t\t */\n\t\tif (peer_addr->sa.sa_family == AF_INET6)\n\t\t\tasoc->peer.ipv6_address = 1;\n\t\telse if (peer_addr->sa.sa_family == AF_INET)\n\t\t\tasoc->peer.ipv4_address = 1;\n\n\t\t/* Cycle through address types; avoid divide by 0. */\n\t\tsat = ntohs(param.p->length) - sizeof(sctp_paramhdr_t);\n\t\tif (sat)\n\t\t\tsat /= sizeof(__u16);\n\n\t\tfor (i = 0; i < sat; ++i) {\n\t\t\tswitch (param.sat->types[i]) {\n\t\t\tcase SCTP_PARAM_IPV4_ADDRESS:\n\t\t\t\tasoc->peer.ipv4_address = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase SCTP_PARAM_IPV6_ADDRESS:\n\t\t\t\tif (PF_INET6 == asoc->base.sk->sk_family)\n\t\t\t\t\tasoc->peer.ipv6_address = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase SCTP_PARAM_HOST_NAME_ADDRESS:\n\t\t\t\tasoc->peer.hostname_address = 1;\n\t\t\t\tbreak;\n\n\t\t\tdefault: /* Just ignore anything else.  */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase SCTP_PARAM_STATE_COOKIE:\n\t\tasoc->peer.cookie_len =\n\t\t\tntohs(param.p->length) - sizeof(sctp_paramhdr_t);\n\t\tasoc->peer.cookie = param.cookie->body;\n\t\tbreak;\n\n\tcase SCTP_PARAM_HEARTBEAT_INFO:\n\t\t/* Would be odd to receive, but it causes no problems. */\n\t\tbreak;\n\n\tcase SCTP_PARAM_UNRECOGNIZED_PARAMETERS:\n\t\t/* Rejected during verify stage. */\n\t\tbreak;\n\n\tcase SCTP_PARAM_ECN_CAPABLE:\n\t\tasoc->peer.ecn_capable = 1;\n\t\tbreak;\n\n\tcase SCTP_PARAM_ADAPTATION_LAYER_IND:\n\t\tasoc->peer.adaptation_ind = ntohl(param.aind->adaptation_ind);\n\t\tbreak;\n\n\tcase SCTP_PARAM_SET_PRIMARY:\n\t\tif (!net->sctp.addip_enable)\n\t\t\tgoto fall_through;\n\n \t\taddr_param = param.v + sizeof(sctp_addip_param_t);\n \n \t\taf = sctp_get_af_specific(param_type2af(param.p->type));\n \t\taf->from_addr_param(&addr, addr_param,\n \t\t\t\t    htons(asoc->peer.port), 0);\n \n\t\t/* if the address is invalid, we can't process it.\n\t\t * XXX: see spec for what to do.\n\t\t */\n\t\tif (!af->addr_valid(&addr, NULL, NULL))\n\t\t\tbreak;\n\n\t\tt = sctp_assoc_lookup_paddr(asoc, &addr);\n\t\tif (!t)\n\t\t\tbreak;\n\n\t\tsctp_assoc_set_primary(asoc, t);\n\t\tbreak;\n\n\tcase SCTP_PARAM_SUPPORTED_EXT:\n\t\tsctp_process_ext_param(asoc, param);\n\t\tbreak;\n\n\tcase SCTP_PARAM_FWD_TSN_SUPPORT:\n\t\tif (net->sctp.prsctp_enable) {\n\t\t\tasoc->peer.prsctp_capable = 1;\n\t\t\tbreak;\n\t\t}\n\t\t/* Fall Through */\n\t\tgoto fall_through;\n\n\tcase SCTP_PARAM_RANDOM:\n\t\tif (!ep->auth_enable)\n\t\t\tgoto fall_through;\n\n\t\t/* Save peer's random parameter */\n\t\tasoc->peer.peer_random = kmemdup(param.p,\n\t\t\t\t\t    ntohs(param.p->length), gfp);\n\t\tif (!asoc->peer.peer_random) {\n\t\t\tretval = 0;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SCTP_PARAM_HMAC_ALGO:\n\t\tif (!ep->auth_enable)\n\t\t\tgoto fall_through;\n\n\t\t/* Save peer's HMAC list */\n\t\tasoc->peer.peer_hmacs = kmemdup(param.p,\n\t\t\t\t\t    ntohs(param.p->length), gfp);\n\t\tif (!asoc->peer.peer_hmacs) {\n\t\t\tretval = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Set the default HMAC the peer requested*/\n\t\tsctp_auth_asoc_set_default_hmac(asoc, param.hmac_algo);\n\t\tbreak;\n\n\tcase SCTP_PARAM_CHUNKS:\n\t\tif (!ep->auth_enable)\n\t\t\tgoto fall_through;\n\n\t\tasoc->peer.peer_chunks = kmemdup(param.p,\n\t\t\t\t\t    ntohs(param.p->length), gfp);\n\t\tif (!asoc->peer.peer_chunks)\n\t\t\tretval = 0;\n\t\tbreak;\nfall_through:\n\tdefault:\n\t\t/* Any unrecognized parameters should have been caught\n\t\t * and handled by sctp_verify_param() which should be\n\t\t * called prior to this routine.  Simply log the error\n\t\t * here.\n\t\t */\n\t\tpr_debug(\"%s: ignoring param:%d for association:%p.\\n\",\n\t\t\t __func__, ntohs(param.p->type), asoc);\n\t\tbreak;\n\t}\n\n\treturn retval;\n}\n", "target": 1, "idx": 179425}
{"func": "static void snd_timer_user_tinterrupt(struct snd_timer_instance *timeri,\n\t\t\t\t      unsigned long resolution,\n\t\t\t\t      unsigned long ticks)\n{\n\tstruct snd_timer_user *tu = timeri->callback_data;\n\tstruct snd_timer_tread *r, r1;\n\tstruct timespec tstamp;\n\tint prev, append = 0;\n\n\tmemset(&tstamp, 0, sizeof(tstamp));\n\tspin_lock(&tu->qlock);\n\tif ((tu->filter & ((1 << SNDRV_TIMER_EVENT_RESOLUTION) |\n\t\t\t   (1 << SNDRV_TIMER_EVENT_TICK))) == 0) {\n\t\tspin_unlock(&tu->qlock);\n\t\treturn;\n\t}\n\tif (tu->last_resolution != resolution || ticks > 0) {\n\t\tif (timer_tstamp_monotonic)\n\t\t\tktime_get_ts(&tstamp);\n\t\telse\n\t\t\tgetnstimeofday(&tstamp);\n \t}\n \tif ((tu->filter & (1 << SNDRV_TIMER_EVENT_RESOLUTION)) &&\n \t    tu->last_resolution != resolution) {\n \t\tr1.event = SNDRV_TIMER_EVENT_RESOLUTION;\n \t\tr1.tstamp = tstamp;\n \t\tr1.val = resolution;\n\t\tsnd_timer_user_append_to_tqueue(tu, &r1);\n\t\ttu->last_resolution = resolution;\n\t\tappend++;\n\t}\n\tif ((tu->filter & (1 << SNDRV_TIMER_EVENT_TICK)) == 0)\n\t\tgoto __wake;\n\tif (ticks == 0)\n\t\tgoto __wake;\n\tif (tu->qused > 0) {\n\t\tprev = tu->qtail == 0 ? tu->queue_size - 1 : tu->qtail - 1;\n\t\tr = &tu->tqueue[prev];\n\t\tif (r->event == SNDRV_TIMER_EVENT_TICK) {\n\t\t\tr->tstamp = tstamp;\n\t\t\tr->val += ticks;\n\t\t\tappend++;\n\t\t\tgoto __wake;\n\t\t}\n\t}\n\tr1.event = SNDRV_TIMER_EVENT_TICK;\n\tr1.tstamp = tstamp;\n\tr1.val = ticks;\n\tsnd_timer_user_append_to_tqueue(tu, &r1);\n\tappend++;\n      __wake:\n\tspin_unlock(&tu->qlock);\n\tif (append == 0)\n\t\treturn;\n\tkill_fasync(&tu->fasync, SIGIO, POLL_IN);\n\twake_up(&tu->qchange_sleep);\n}\n", "target": 1, "idx": 180408}
{"func": "ResourceError WebFrameLoaderClient::cannotShowMIMETypeError(const ResourceResponse&) {\n  return ResourceError();\n}\n", "target": 0, "idx": 97160}
{"func": "const Cluster* Segment::GetLast() const\n{\n    if ((m_clusters == NULL) || (m_clusterCount <= 0))\n        return &m_eos;\n \n    const long idx = m_clusterCount - 1;\n \n    Cluster* const pCluster = m_clusters[idx];\n    assert(pCluster);\n    return pCluster;\n }\n", "target": 1, "idx": 188362}
{"func": "static void check_start_timer_thread(struct smi_info *smi_info)\n{\n\tif (smi_info->si_state == SI_NORMAL && smi_info->curr_msg == NULL) {\n\t\tsmi_mod_timer(smi_info, jiffies + SI_TIMEOUT_JIFFIES);\n\n\t\tif (smi_info->thread)\n\t\t\twake_up_process(smi_info->thread);\n\n\t\tstart_next_msg(smi_info);\n\t\tsmi_event_handler(smi_info, 0);\n\t}\n}\n", "target": 0, "idx": 90209}
{"func": "static inline void try_to_free_low(struct hstate *h, unsigned long count,\n\t\t\t\t\t\tnodemask_t *nodes_allowed)\n{\n}\n", "target": 0, "idx": 19765}
{"func": "void Splash::scaleMaskYuXd(SplashImageMaskSource src, void *srcData,\n\t\t\t   int srcWidth, int srcHeight,\n\t\t\t   int scaledWidth, int scaledHeight,\n\t\t\t   SplashBitmap *dest) {\n  Guchar *lineBuf;\n  Guint pix;\n   Guchar *destPtr0, *destPtr;\n   int yp, yq, xp, xq, yt, y, yStep, xt, x, xStep, xx, d, d0, d1;\n   int i;\n \n   yp = scaledHeight / srcHeight;\n  lineBuf = (Guchar *)gmalloc(srcWidth);\n\n  yt = 0;\n\n  destPtr0 = dest->data;\n  for (y = 0; y < srcHeight; ++y) {\n\n   yt = 0;\n \n  destPtr0 = dest->data;\n   for (y = 0; y < srcHeight; ++y) {\n \n    }\n\n    (*src)(srcData, lineBuf);\n\n    xt = 0;\n    d0 = (255 << 23) / xp;\n    d1 = (255 << 23) / (xp + 1);\n\n    xx = 0;\n    for (x = 0; x < scaledWidth; ++x) {\n\n      if ((xt += xq) >= scaledWidth) {\n\txt -= scaledWidth;\n\txStep = xp + 1;\n\td = d1;\n      } else {\n\txStep = xp;\n\td = d0;\n      }\n\n      pix = 0;\n      for (i = 0; i < xStep; ++i) {\n\tpix += lineBuf[xx++];\n      }\n      pix = (pix * d) >> 23;\n\n      for (i = 0; i < yStep; ++i) {\n\tdestPtr = destPtr0 + i * scaledWidth + x;\n\t*destPtr = (Guchar)pix;\n      }\n    }\n\n    destPtr0 += yStep * scaledWidth;\n  }\n\n  gfree(lineBuf);\n}\n", "target": 1, "idx": 177907}
{"func": "static void reds_info_new_channel(RedLinkInfo *link, int connection_id)\n{\n    spice_info(\"channel %d:%d, connected successfully, over %s link\",\n               link->link_mess->channel_type,\n               link->link_mess->channel_id,\n               link->stream->ssl == NULL ? \"Non Secure\" : \"Secure\");\n    /* add info + send event */\n    if (link->stream->ssl) {\n        link->stream->info->flags |= SPICE_CHANNEL_EVENT_FLAG_TLS;\n    }\n    link->stream->info->connection_id = connection_id;\n    link->stream->info->type = link->link_mess->channel_type;\n    link->stream->info->id   = link->link_mess->channel_id;\n    reds_stream_push_channel_event(link->stream, SPICE_CHANNEL_EVENT_INITIALIZED);\n}\n", "target": 0, "idx": 1887}
{"func": "gsicc_set_device_profile_colorants(gx_device *dev, char *name_str)\n{\n    int code;\n    cmm_dev_profile_t *profile_struct;\n    gsicc_colorname_t *name_entry;\n    gsicc_colorname_t **curr_entry;\n    gs_memory_t *mem;\n    char *temp_ptr, *last = NULL;\n    int done;\n    gsicc_namelist_t *spot_names;\n    char *pch;\n    int str_len;\n    int k;\n    bool free_str = false;\n\n    code = dev_proc(dev, get_profile)((gx_device *)dev, &profile_struct);\n    if (profile_struct != NULL) {\n        int count = 0;\n\n        if (name_str == NULL) {\n            /* Create a default name string that we can use */\n            int total_len;\n            int kk;\n            int num_comps = profile_struct->device_profile[0]->num_comps;\n            char temp_str[DEFAULT_ICC_COLORANT_LENGTH+2];\n\n            /* If names are already set then we do not want to set default ones */\n            if (profile_struct->spotnames != NULL)\n                return 0;\n\n            free_str = true;\n            /* Assume first 4 are CMYK */\n            total_len = ((DEFAULT_ICC_COLORANT_LENGTH + 1) * (num_comps-4)) +\n                        DEFAULT_ICC_PROCESS_LENGTH - 1;  /* -1 due to no comma at end */\n            name_str = (char*) gs_alloc_bytes(dev->memory, total_len+1,\n                                               \"gsicc_set_device_profile_colorants\");\n            if (name_str == NULL)\n                return gs_throw(gs_error_VMerror, \"Insufficient memory for colorant name\");\n            gs_sprintf(name_str, DEFAULT_ICC_PROCESS);\n            for (kk = 0; kk < num_comps-5; kk++) {\n                gs_sprintf(temp_str,\"ICC_COLOR_%d,\",kk);\n                strcat(name_str,temp_str);\n            }\n            /* Last one no comma */\n            gs_sprintf(temp_str,\"ICC_COLOR_%d\",kk);\n            strcat(name_str,temp_str);\n        }\n        str_len = strlen(name_str);\n        if (profile_struct->spotnames != NULL &&\n            profile_struct->spotnames->name_str != NULL &&\n            strlen(profile_struct->spotnames->name_str) == str_len) {\n            /* Here we check if the names are the same */\n            if (strncmp(name_str, profile_struct->spotnames->name_str, str_len) == 0) {\n                if (free_str)\n                    gs_free_object(dev->memory, name_str,\n                                            \"gsicc_set_device_profile_colorants\");\n                return 0;\n            }\n        }\n        mem = dev->memory->non_gc_memory;\n        /* We need to free the existing one if there was one */\n        if (profile_struct->spotnames != NULL) {\n            /* Free the linked list in this object */\n            gsicc_free_spotnames(profile_struct->spotnames, mem);\n            /* Free the main object */\n            gs_free_object(mem, profile_struct->spotnames,\n                           \"gsicc_set_device_profile_colorants\");\n        }\n        /* Allocate structure for managing names */\n        spot_names = gsicc_new_namelist(mem);\n        profile_struct->spotnames = spot_names;\n        spot_names->name_str = (char*) gs_alloc_bytes(mem, str_len+1,\n                                               \"gsicc_set_device_profile_colorants\");\n        if (spot_names->name_str == NULL)\n            return gs_throw(gs_error_VMerror, \"Insufficient memory for spot name\");\n        memcpy(spot_names->name_str, name_str, strlen(name_str));\n        spot_names->name_str[str_len] = 0;\n        curr_entry = &(spot_names->head);\n         /* Go ahead and tokenize now */\n        pch = gs_strtok(name_str, \",\", &last);\n        count = 0;\n        while (pch != NULL) {\n            temp_ptr = pch;\n            done = 0;\n            /* Remove any leading spaces */\n            while (!done) {\n                if (*temp_ptr == 0x20) {\n                    temp_ptr++;\n                } else {\n                    done = 1;\n                }\n            }\n            /* Allocate a new name object */\n            name_entry = gsicc_new_colorname(mem);\n            /* Set our current entry to this one */\n            *curr_entry = name_entry;\n            name_entry->length = strlen(temp_ptr);\n            name_entry->name = (char *) gs_alloc_bytes(mem, name_entry->length,\n                                        \"gsicc_set_device_profile_colorants\");\n            if (spot_names->name_str == NULL)\n                return gs_throw(gs_error_VMerror, \"Insufficient memory for spot name\");\n            memcpy(name_entry->name, temp_ptr, name_entry->length);\n            /* Get the next entry location */\n            curr_entry = &((*curr_entry)->next);\n            count += 1;\n            pch = gs_strtok(NULL, \",\", &last);\n        }\n        spot_names->count = count;\n        /* Create the color map.  Query the device to find out where these\n           colorants are located.   It is possible that the device may\n           not be opened yet.  In which case, we need to make sure that\n           when it is opened that it checks this entry and gets itself\n           properly initialized if it is a separation device. */\n        spot_names->color_map =\n            (gs_devicen_color_map*) gs_alloc_bytes(mem,\n                                                   sizeof(gs_devicen_color_map),\n                                                   \"gsicc_set_device_profile_colorants\");\n        if (spot_names->color_map == NULL)\n            return gs_throw(gs_error_VMerror, \"Insufficient memory for spot color map\");\n        spot_names->color_map->num_colorants = count;\n        spot_names->color_map->num_components = count;\n\n        name_entry = spot_names->head;\n        for (k = 0; k < count; k++) {\n            int colorant_number = (*dev_proc(dev, get_color_comp_index))\n                    (dev, (const char *)name_entry->name, name_entry->length,\n                     SEPARATION_NAME);\n            name_entry = name_entry->next;\n            spot_names->color_map->color_map[k] = colorant_number;\n        }\n        /* We need to set the equivalent CMYK color for this colorant.  This is\n           done by faking out the update spot equivalent call with a special\n           gs_gstate and color space that makes it seem like the\n           spot color is a separation color space.  Unfortunately, we need the\n           graphic state to do this so we save it for later when we try to do\n           our first mapping.  We then use this flag to know if we did it yet */\n        spot_names->equiv_cmyk_set = false;\n        if (free_str)\n            gs_free_object(dev->memory, name_str,\n                           \"gsicc_set_device_profile_colorants\");\n    }\n    return code;\n}\n", "target": 0, "idx": 13996}
{"func": "static int snd_timer_user_continue(struct file *file)\n{\n\tint err;\n\tstruct snd_timer_user *tu;\n\n\ttu = file->private_data;\n\tif (!tu->timeri)\n\t\treturn -EBADFD;\n\ttu->timeri->lost = 0;\n\treturn (err = snd_timer_continue(tu->timeri)) < 0 ? err : 0;\n}\n", "target": 0, "idx": 52723}
{"func": "static int pop_fetch_headers(struct Context *ctx)\n{\n  struct PopData *pop_data = (struct PopData *) ctx->data;\n  struct Progress progress;\n\n#ifdef USE_HCACHE\n  header_cache_t *hc = pop_hcache_open(pop_data, ctx->path);\n#endif\n\n  time(&pop_data->check_time);\n  pop_data->clear_cache = false;\n\n  for (int i = 0; i < ctx->msgcount; i++)\n    ctx->hdrs[i]->refno = -1;\n\n  const int old_count = ctx->msgcount;\n  int ret = pop_fetch_data(pop_data, \"UIDL\\r\\n\", NULL, fetch_uidl, ctx);\n  const int new_count = ctx->msgcount;\n  ctx->msgcount = old_count;\n\n  if (pop_data->cmd_uidl == 2)\n  {\n    if (ret == 0)\n    {\n      pop_data->cmd_uidl = 1;\n\n      mutt_debug(1, \"set UIDL capability\\n\");\n    }\n\n    if (ret == -2 && pop_data->cmd_uidl == 2)\n    {\n      pop_data->cmd_uidl = 0;\n\n      mutt_debug(1, \"unset UIDL capability\\n\");\n      snprintf(pop_data->err_msg, sizeof(pop_data->err_msg), \"%s\",\n               _(\"Command UIDL is not supported by server.\"));\n    }\n  }\n\n  if (!ctx->quiet)\n  {\n    mutt_progress_init(&progress, _(\"Fetching message headers...\"),\n                       MUTT_PROGRESS_MSG, ReadInc, new_count - old_count);\n  }\n\n  if (ret == 0)\n  {\n    int i, deleted;\n    for (i = 0, deleted = 0; i < old_count; i++)\n    {\n      if (ctx->hdrs[i]->refno == -1)\n      {\n        ctx->hdrs[i]->deleted = true;\n        deleted++;\n      }\n    }\n    if (deleted > 0)\n    {\n      mutt_error(\n          ngettext(\"%d message has been lost. Try reopening the mailbox.\",\n                   \"%d messages have been lost. Try reopening the mailbox.\", deleted),\n          deleted);\n    }\n\n    bool hcached = false;\n    for (i = old_count; i < new_count; i++)\n    {\n      if (!ctx->quiet)\n        mutt_progress_update(&progress, i + 1 - old_count, -1);\n#ifdef USE_HCACHE\n      void *data = mutt_hcache_fetch(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data));\n      if (data)\n      {\n        char *uidl = mutt_str_strdup(ctx->hdrs[i]->data);\n        int refno = ctx->hdrs[i]->refno;\n        int index = ctx->hdrs[i]->index;\n        /*\n         * - POP dynamically numbers headers and relies on h->refno\n         *   to map messages; so restore header and overwrite restored\n         *   refno with current refno, same for index\n         * - h->data needs to a separate pointer as it's driver-specific\n         *   data freed separately elsewhere\n         *   (the old h->data should point inside a malloc'd block from\n         *   hcache so there shouldn't be a memleak here)\n         */\n        struct Header *h = mutt_hcache_restore((unsigned char *) data);\n        mutt_hcache_free(hc, &data);\n        mutt_header_free(&ctx->hdrs[i]);\n        ctx->hdrs[i] = h;\n        ctx->hdrs[i]->refno = refno;\n        ctx->hdrs[i]->index = index;\n        ctx->hdrs[i]->data = uidl;\n        ret = 0;\n        hcached = true;\n      }\n      else\n#endif\n          if ((ret = pop_read_header(pop_data, ctx->hdrs[i])) < 0)\n        break;\n#ifdef USE_HCACHE\n      else\n      {\n        mutt_hcache_store(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data),\n                          ctx->hdrs[i], 0);\n      }\n#endif\n\n      /*\n       * faked support for flags works like this:\n       * - if 'hcached' is true, we have the message in our hcache:\n       *        - if we also have a body: read\n       *        - if we don't have a body: old\n       *          (if $mark_old is set which is maybe wrong as\n       *          $mark_old should be considered for syncing the\n       *          folder and not when opening it XXX)\n       * - if 'hcached' is false, we don't have the message in our hcache:\n       *        - if we also have a body: read\n        *        - if we don't have a body: new\n        */\n       const bool bcached =\n          (mutt_bcache_exists(pop_data->bcache, ctx->hdrs[i]->data) == 0);\n       ctx->hdrs[i]->old = false;\n       ctx->hdrs[i]->read = false;\n       if (hcached)\n      {\n        if (bcached)\n          ctx->hdrs[i]->read = true;\n        else if (MarkOld)\n          ctx->hdrs[i]->old = true;\n      }\n      else\n      {\n        if (bcached)\n          ctx->hdrs[i]->read = true;\n      }\n\n      ctx->msgcount++;\n    }\n\n    if (i > old_count)\n      mx_update_context(ctx, i - old_count);\n  }\n\n#ifdef USE_HCACHE\n  mutt_hcache_close(hc);\n#endif\n\n  if (ret < 0)\n  {\n    for (int i = ctx->msgcount; i < new_count; i++)\n      mutt_header_free(&ctx->hdrs[i]);\n    return ret;\n  }\n\n  /* after putting the result into our structures,\n   * clean up cache, i.e. wipe messages deleted outside\n   * the availability of our cache\n   */\n  if (MessageCacheClean)\n    mutt_bcache_list(pop_data->bcache, msg_cache_check, (void *) ctx);\n\n  mutt_clear_error();\n  return (new_count - old_count);\n}\n", "target": 1, "idx": 182293}
{"func": "void GetWebRTCSessionDescriptionFromSessionDescriptionCallback(\n    base::OnceCallback<const webrtc::SessionDescriptionInterface*()>\n        description_callback,\n    blink::WebRTCSessionDescription* web_description) {\n  const webrtc::SessionDescriptionInterface* description =\n      std::move(description_callback).Run();\n  if (description) {\n    std::string sdp;\n    description->ToString(&sdp);\n    web_description->Initialize(blink::WebString::FromUTF8(description->type()),\n                                blink::WebString::FromUTF8(sdp));\n  }\n}\n", "target": 0, "idx": 165984}
{"func": " void InspectorPageAgent::updateTouchEventEmulationInPage(bool enabled)\n {\n     m_state->setBoolean(PageAgentState::touchEventEmulationEnabled, enabled);\n     if (mainFrame() && mainFrame()->settings())\n         mainFrame()->settings()->setTouchEventEmulationEnabled(enabled);\n    m_overlay->setOverride(InspectorOverlay::TouchOverride, enabled);\n}\n", "target": 1, "idx": 184244}
{"func": "test_bson_build_child_deep_no_begin_end_1 (bson_t *b, int *count)\n{\n   bson_t child;\n\n   (*count)++;\n\n   bson_init (&child);\n   if (*count < 100) {\n      test_bson_build_child_deep_1 (&child, count);\n   } else {\n      BSON_ASSERT (bson_append_int32 (&child, \"b\", -1, 1234));\n   }\n   BSON_ASSERT (bson_append_document (b, \"b\", -1, &child));\n   bson_destroy (&child);\n}\n", "target": 0, "idx": 77904}
{"func": "static void serial_update_parameters(SerialState *s)\n{\n     int speed, parity, data_bits, stop_bits, frame_size;\n     QEMUSerialSetParams ssp;\n \n    if (s->divider == 0)\n         return;\n \n     /* Start bit. */\n     frame_size = 1;\n        /* Parity bit. */\n        frame_size++;\n        if (s->lcr & 0x10)\n            parity = 'E';\n        else\n            parity = 'O';\n    } else {\n            parity = 'N';\n    }\n", "target": 1, "idx": 178082}
{"func": "static SegmentInfo AffineEdge(const Image *image,const AffineMatrix *affine,\n  const double y,const SegmentInfo *edge)\n{\n  double\n    intercept,\n    z;\n\n  register double\n    x;\n\n  SegmentInfo\n    inverse_edge;\n\n  /*\n    Determine left and right edges.\n  */\n  inverse_edge.x1=edge->x1;\n  inverse_edge.y1=edge->y1;\n  inverse_edge.x2=edge->x2;\n  inverse_edge.y2=edge->y2;\n  z=affine->ry*y+affine->tx;\n  if (affine->sx >= MagickEpsilon)\n    {\n      intercept=(-z/affine->sx);\n      x=intercept;\n      if (x > inverse_edge.x1)\n        inverse_edge.x1=x;\n      intercept=(-z+(double) image->columns)/affine->sx;\n      x=intercept;\n      if (x < inverse_edge.x2)\n        inverse_edge.x2=x;\n    }\n  else\n    if (affine->sx < -MagickEpsilon)\n      {\n        intercept=(-z+(double) image->columns)/affine->sx;\n        x=intercept;\n        if (x > inverse_edge.x1)\n          inverse_edge.x1=x;\n        intercept=(-z/affine->sx);\n        x=intercept;\n        if (x < inverse_edge.x2)\n          inverse_edge.x2=x;\n      }\n    else\n      if ((z < 0.0) || ((size_t) floor(z+0.5) >= image->columns))\n        {\n          inverse_edge.x2=edge->x1;\n          return(inverse_edge);\n        }\n  /*\n    Determine top and bottom edges.\n  */\n  z=affine->sy*y+affine->ty;\n  if (affine->rx >= MagickEpsilon)\n    {\n      intercept=(-z/affine->rx);\n      x=intercept;\n      if (x > inverse_edge.x1)\n        inverse_edge.x1=x;\n      intercept=(-z+(double) image->rows)/affine->rx;\n      x=intercept;\n      if (x < inverse_edge.x2)\n        inverse_edge.x2=x;\n    }\n  else\n    if (affine->rx < -MagickEpsilon)\n      {\n        intercept=(-z+(double) image->rows)/affine->rx;\n        x=intercept;\n        if (x > inverse_edge.x1)\n          inverse_edge.x1=x;\n        intercept=(-z/affine->rx);\n        x=intercept;\n        if (x < inverse_edge.x2)\n          inverse_edge.x2=x;\n      }\n    else\n      if ((z < 0.0) || ((size_t) floor(z+0.5) >= image->rows))\n        {\n          inverse_edge.x2=edge->x2;\n          return(inverse_edge);\n        }\n  return(inverse_edge);\n}\n", "target": 0, "idx": 52993}
{"func": "  void SetLegalMessage(const std::string& message_json,\n                       bool should_cvc_be_requested = false) {\n    std::unique_ptr<base::Value> value(base::JSONReader::Read(message_json));\n    ASSERT_TRUE(value);\n    base::DictionaryValue* dictionary;\n    ASSERT_TRUE(value->GetAsDictionary(&dictionary));\n    std::unique_ptr<base::DictionaryValue> legal_message =\n        dictionary->CreateDeepCopy();\n    controller()->ShowBubbleForUpload(CreditCard(), std::move(legal_message),\n                                      should_cvc_be_requested,\n                                      base::Bind(&SaveCardCallback));\n  }\n", "target": 0, "idx": 149699}
{"func": "DocumentLoader::~DocumentLoader() {\n  DCHECK(!frame_);\n  DCHECK(!GetResource());\n  DCHECK(!application_cache_host_);\n  DCHECK_EQ(state_, kSentDidFinishLoad);\n}\n", "target": 0, "idx": 136641}
{"func": "static void add_background(ASS_Renderer *render_priv, EventImages *event_images)\n{\n    void *nbuffer = ass_aligned_alloc(1, event_images->width * event_images->height, false);\n    if (!nbuffer)\n        return;\n    memset(nbuffer, 0xFF, event_images->width * event_images->height);\n    ASS_Image *img = my_draw_bitmap(nbuffer, event_images->width,\n                                    event_images->height,\n                                    event_images->width,\n                                    event_images->left,\n                                    event_images->top,\n                                    render_priv->state.c[3], NULL);\n    if (img) {\n        img->next = event_images->imgs;\n        event_images->imgs = img;\n    }\n}\n", "target": 0, "idx": 73339}
{"func": "    void registerURL(const char* url, const char* file, const char* mimeType)\n    {\n        registerMockedURLLoad(KURL(m_baseUrl, url), WebString::fromUTF8(file), m_folder, WebString::fromUTF8(mimeType));\n    }\n", "target": 1, "idx": 185277}
{"func": "void ExtensionInstallDialogView::InitView() {\n  int left_column_width =\n      (prompt_->ShouldShowPermissions() || prompt_->GetRetainedFileCount() > 0)\n          ? kPermissionsLeftColumnWidth\n          : kNoPermissionsLeftColumnWidth;\n  if (is_external_install())\n    left_column_width = kExternalInstallLeftColumnWidth;\n\n  int column_set_id = 0;\n  views::GridLayout* layout = CreateLayout(left_column_width, column_set_id);\n\n  ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();\n\n  if (prompt_->has_webstore_data()) {\n    layout->StartRow(0, column_set_id);\n    views::View* rating = new views::View();\n    rating->SetLayoutManager(new views::BoxLayout(\n        views::BoxLayout::kHorizontal, 0, 0, 0));\n    layout->AddView(rating);\n    prompt_->AppendRatingStars(AddResourceIcon, rating);\n\n    const gfx::FontList& small_font_list =\n        rb.GetFontList(ui::ResourceBundle::SmallFont);\n    views::Label* rating_count =\n        new views::Label(prompt_->GetRatingCount(), small_font_list);\n    rating_count->SetBorder(views::Border::CreateEmptyBorder(0, 2, 0, 0));\n    rating->AddChildView(rating_count);\n\n    layout->StartRow(0, column_set_id);\n    views::Label* user_count =\n        new views::Label(prompt_->GetUserCount(), small_font_list);\n    user_count->SetAutoColorReadabilityEnabled(false);\n    user_count->SetEnabledColor(SK_ColorGRAY);\n    layout->AddView(user_count);\n\n    layout->StartRow(0, column_set_id);\n    views::Link* store_link = new views::Link(\n        l10n_util::GetStringUTF16(IDS_EXTENSION_PROMPT_STORE_LINK));\n    store_link->SetFontList(small_font_list);\n    store_link->set_listener(this);\n    layout->AddView(store_link);\n\n    if (prompt_->ShouldShowPermissions()) {\n      layout->AddPaddingRow(0, views::kRelatedControlVerticalSpacing);\n      layout->StartRow(0, column_set_id);\n      layout->AddView(new views::Separator(views::Separator::HORIZONTAL),\n                      3,\n                      1,\n                      views::GridLayout::FILL,\n                      views::GridLayout::FILL);\n    }\n  }\n\n  int content_width = left_column_width + views::kPanelHorizMargin + kIconSize;\n\n  CustomScrollableView* scrollable = new CustomScrollableView();\n  views::GridLayout* scroll_layout = new views::GridLayout(scrollable);\n  scrollable->SetLayoutManager(scroll_layout);\n\n  views::ColumnSet* scrollable_column_set =\n      scroll_layout->AddColumnSet(column_set_id);\n  int scrollable_width = prompt_->has_webstore_data() ? content_width\n                                                      : left_column_width;\n  scrollable_column_set->AddColumn(views::GridLayout::LEADING,\n                                   views::GridLayout::LEADING,\n                                   0,  // no resizing\n                                   views::GridLayout::USE_PREF,\n                                   scrollable_width,\n                                   scrollable_width);\n  int padding_width =\n      content_width + views::kButtonHEdgeMarginNew - scrollable_width;\n  scrollable_column_set->AddPaddingColumn(0, padding_width);\n\n  layout->StartRow(0, column_set_id);\n  scroll_view_ = new views::ScrollView();\n  scroll_view_->set_hide_horizontal_scrollbar(true);\n  scroll_view_->SetContents(scrollable);\n  layout->AddView(scroll_view_, 4, 1);\n\n  if (is_bundle_install()) {\n    BundleInstaller::ItemList items = prompt_->bundle()->GetItemsWithState(\n        BundleInstaller::Item::STATE_PENDING);\n    scroll_layout->AddPaddingRow(0, views::kRelatedControlSmallVerticalSpacing);\n    for (const BundleInstaller::Item& item : items) {\n      scroll_layout->StartRow(0, column_set_id);\n      views::Label* extension_label =\n          new views::Label(item.GetNameForDisplay());\n      extension_label->SetMultiLine(true);\n      extension_label->SetHorizontalAlignment(gfx::ALIGN_LEFT);\n      extension_label->SizeToFit(\n          scrollable_width - kSmallIconSize - kSmallIconPadding);\n      gfx::ImageSkia image = gfx::ImageSkia::CreateFrom1xBitmap(item.icon);\n      scroll_layout->AddView(new IconedView(extension_label, image));\n    }\n    scroll_layout->AddPaddingRow(0, views::kRelatedControlVerticalSpacing);\n  }\n\n  if (prompt_->ShouldShowPermissions()) {\n    bool has_permissions =\n        prompt_->GetPermissionCount(\n            ExtensionInstallPrompt::PermissionsType::ALL_PERMISSIONS) > 0;\n    if (has_permissions) {\n      AddPermissions(\n          scroll_layout,\n          rb,\n          column_set_id,\n          scrollable_width,\n          ExtensionInstallPrompt::PermissionsType::REGULAR_PERMISSIONS);\n      AddPermissions(\n          scroll_layout,\n          rb,\n          column_set_id,\n          scrollable_width,\n          ExtensionInstallPrompt::PermissionsType::WITHHELD_PERMISSIONS);\n    } else {\n      scroll_layout->AddPaddingRow(0, views::kRelatedControlVerticalSpacing);\n      scroll_layout->StartRow(0, column_set_id);\n      views::Label* permission_label = new views::Label(\n          l10n_util::GetStringUTF16(IDS_EXTENSION_NO_SPECIAL_PERMISSIONS));\n      permission_label->SetMultiLine(true);\n      permission_label->SetHorizontalAlignment(gfx::ALIGN_LEFT);\n      permission_label->SizeToFit(scrollable_width);\n      scroll_layout->AddView(permission_label);\n    }\n  }\n\n  if (prompt_->GetRetainedFileCount()) {\n    scroll_layout->AddPaddingRow(0, views::kRelatedControlVerticalSpacing);\n\n    scroll_layout->StartRow(0, column_set_id);\n    views::Label* retained_files_header =\n        new views::Label(prompt_->GetRetainedFilesHeading());\n    retained_files_header->SetMultiLine(true);\n    retained_files_header->SetHorizontalAlignment(gfx::ALIGN_LEFT);\n    retained_files_header->SizeToFit(scrollable_width);\n    scroll_layout->AddView(retained_files_header);\n\n    scroll_layout->StartRow(0, column_set_id);\n    PermissionDetails details;\n    for (size_t i = 0; i < prompt_->GetRetainedFileCount(); ++i) {\n      details.push_back(prompt_->GetRetainedFile(i));\n    }\n    ExpandableContainerView* issue_advice_view =\n        new ExpandableContainerView(this,\n                                    base::string16(),\n                                    details,\n                                    scrollable_width,\n                                    false);\n    scroll_layout->AddView(issue_advice_view);\n  }\n\n  if (prompt_->GetRetainedDeviceCount()) {\n    scroll_layout->AddPaddingRow(0, views::kRelatedControlVerticalSpacing);\n\n    scroll_layout->StartRow(0, column_set_id);\n    views::Label* retained_devices_header =\n        new views::Label(prompt_->GetRetainedDevicesHeading());\n    retained_devices_header->SetMultiLine(true);\n    retained_devices_header->SetHorizontalAlignment(gfx::ALIGN_LEFT);\n    retained_devices_header->SizeToFit(scrollable_width);\n    scroll_layout->AddView(retained_devices_header);\n\n    scroll_layout->StartRow(0, column_set_id);\n    PermissionDetails details;\n    for (size_t i = 0; i < prompt_->GetRetainedDeviceCount(); ++i) {\n      details.push_back(prompt_->GetRetainedDeviceMessageString(i));\n    }\n    ExpandableContainerView* issue_advice_view =\n        new ExpandableContainerView(this,\n                                    base::string16(),\n                                    details,\n                                    scrollable_width,\n                                    false);\n     scroll_layout->AddView(issue_advice_view);\n   }\n \n  DCHECK(prompt_->type() >= 0);\n   UMA_HISTOGRAM_ENUMERATION(\"Extensions.InstallPrompt.Type\",\n                             prompt_->type(),\n                             ExtensionInstallPrompt::NUM_PROMPT_TYPES);\n\n  scroll_view_->ClipHeightTo(\n      0,\n      std::min(kScrollViewMaxHeight, scrollable->GetPreferredSize().height()));\n\n  dialog_size_ = gfx::Size(\n      content_width + 2 * views::kButtonHEdgeMarginNew,\n      container_->GetPreferredSize().height());\n\n  std::string event_name = ExperienceSamplingEvent::kExtensionInstallDialog;\n  event_name.append(\n      ExtensionInstallPrompt::PromptTypeToString(prompt_->type()));\n  sampling_event_ = ExperienceSamplingEvent::Create(event_name);\n}\n", "target": 1, "idx": 186175}
{"func": "ImageDataPlatformBackend::~ImageDataPlatformBackend() {\n}\n", "target": 0, "idx": 108765}
{"func": "long Cluster::CreateBlockGroup(long long start_offset, long long size,\n long long discard_padding) {\n  assert(m_entries);\n  assert(m_entries_size > 0);\n  assert(m_entries_count >= 0);\n  assert(m_entries_count < m_entries_size);\n\n IMkvReader* const pReader = m_pSegment->m_pReader;\n\n long long pos = start_offset;\n const long long stop = start_offset + size;\n\n\n long long prev = 1; // nonce\n long long next = 0; // nonce\n long long duration = -1; // really, this is unsigned\n\n long long bpos = -1;\n long long bsize = -1;\n\n while (pos < stop) {\n long len;\n const long long id = ReadID(pReader, pos, len);\n if (id < 0 || (pos + len) > stop)\n return E_FILE_FORMAT_INVALID;\n\n    pos += len; // consume ID\n\n const long long size = ReadUInt(pReader, pos, len);\n    assert(size >= 0); // TODO\n    assert((pos + len) <= stop);\n\n    pos += len; // consume size\n\n if (id == 0x21) { // Block ID\n if (bpos < 0) { // Block ID\n        bpos = pos;\n        bsize = size;\n }\n } else if (id == 0x1B) { // Duration ID\n if (size > 8)\n return E_FILE_FORMAT_INVALID;\n\n      duration = UnserializeUInt(pReader, pos, size);\n\n if (duration < 0)\n return E_FILE_FORMAT_INVALID;\n } else if (id == 0x7B) { // ReferenceBlock\n if (size > 8 || size <= 0)\n return E_FILE_FORMAT_INVALID;\n const long size_ = static_cast<long>(size);\n\n long long time;\n\n long status = UnserializeInt(pReader, pos, size_, time);\n      assert(status == 0);\n if (status != 0)\n return -1;\n\n if (time <= 0) // see note above\n        prev = time;\n else // weird\n        next = time;\n }\n\n    pos += size; // consume payload\n if (pos > stop)\n return E_FILE_FORMAT_INVALID;\n }\n if (bpos < 0)\n return E_FILE_FORMAT_INVALID;\n\n if (pos != stop)\n return E_FILE_FORMAT_INVALID;\n  assert(bsize >= 0);\n\n const long idx = m_entries_count;\n\n BlockEntry** const ppEntry = m_entries + idx;\n BlockEntry*& pEntry = *ppEntry;\n\n  pEntry = new (std::nothrow)\n BlockGroup(this, idx, bpos, bsize, prev, next, duration, discard_padding);\n\n if (pEntry == NULL)\n return -1; // generic error\n\n BlockGroup* const p = static_cast<BlockGroup*>(pEntry);\n\n const long status = p->Parse();\n\n if (status == 0) { // success\n ++m_entries_count;\n return 0;\n }\n\n delete pEntry;\n  pEntry = 0;\n\n return status;\n}\n", "target": 0, "idx": 177366}
{"func": " static void __udf_read_inode(struct inode *inode)\n {\n \tstruct buffer_head *bh = NULL;\n\tstruct fileEntry *fe;\n\tstruct extendedFileEntry *efe;\n\tuint16_t ident;\n \tstruct udf_inode_info *iinfo = UDF_I(inode);\n \tstruct udf_sb_info *sbi = UDF_SB(inode->i_sb);\n \tunsigned int link_count;\n \n \t/*\n \t * Set defaults, but the inode is still incomplete!\n \t * Note: get_new_inode() sets the following on a new inode:\n\t *      i_sb = sb\n\t *      i_no = ino\n\t *      i_flags = sb->s_flags\n\t *      i_state = 0\n\t * clean_inode(): zero fills and sets\n\t *      i_count = 1\n\t *      i_nlink = 1\n\t *      i_op = NULL;\n\t */\n\tbh = udf_read_ptagged(inode->i_sb, &iinfo->i_location, 0, &ident);\n\tif (!bh) {\n\t\tudf_err(inode->i_sb, \"(ino %ld) failed !bh\\n\", inode->i_ino);\n\t\tmake_bad_inode(inode);\n\t\treturn;\n\t}\n\n\tif (ident != TAG_IDENT_FE && ident != TAG_IDENT_EFE &&\n\t    ident != TAG_IDENT_USE) {\n\t\tudf_err(inode->i_sb, \"(ino %ld) failed ident=%d\\n\",\n\t\t\tinode->i_ino, ident);\n\t\tbrelse(bh);\n\t\tmake_bad_inode(inode);\n\t\treturn;\n\t}\n\n\tfe = (struct fileEntry *)bh->b_data;\n\tefe = (struct extendedFileEntry *)bh->b_data;\n\n\tif (fe->icbTag.strategyType == cpu_to_le16(4096)) {\n\t\tstruct buffer_head *ibh;\n\n \t\tibh = udf_read_ptagged(inode->i_sb, &iinfo->i_location, 1,\n \t\t\t\t\t&ident);\n \t\tif (ident == TAG_IDENT_IE && ibh) {\n\t\t\tstruct buffer_head *nbh = NULL;\n \t\t\tstruct kernel_lb_addr loc;\n \t\t\tstruct indirectEntry *ie;\n \n \t\t\tie = (struct indirectEntry *)ibh->b_data;\n \t\t\tloc = lelb_to_cpu(ie->indirectICB.extLocation);\n \n\t\t\tif (ie->indirectICB.extLength &&\n\t\t\t\t(nbh = udf_read_ptagged(inode->i_sb, &loc, 0,\n\t\t\t\t\t\t\t&ident))) {\n\t\t\t\tif (ident == TAG_IDENT_FE ||\n\t\t\t\t\tident == TAG_IDENT_EFE) {\n\t\t\t\t\tmemcpy(&iinfo->i_location,\n\t\t\t\t\t\t&loc,\n\t\t\t\t\t\tsizeof(struct kernel_lb_addr));\n\t\t\t\t\tbrelse(bh);\n\t\t\t\t\tbrelse(ibh);\n\t\t\t\t\tbrelse(nbh);\n\t\t\t\t\t__udf_read_inode(inode);\n \t\t\t\t\treturn;\n \t\t\t\t}\n\t\t\t\tbrelse(nbh);\n \t\t\t}\n \t\t}\n \t\tbrelse(ibh);\n\t} else if (fe->icbTag.strategyType != cpu_to_le16(4)) {\n\t\tudf_err(inode->i_sb, \"unsupported strategy type: %d\\n\",\n\t\t\tle16_to_cpu(fe->icbTag.strategyType));\n\t\tbrelse(bh);\n\t\tmake_bad_inode(inode);\n\t\treturn;\n\t}\n\tif (fe->icbTag.strategyType == cpu_to_le16(4))\n\t\tiinfo->i_strat4096 = 0;\n\telse /* if (fe->icbTag.strategyType == cpu_to_le16(4096)) */\n\t\tiinfo->i_strat4096 = 1;\n\n\tiinfo->i_alloc_type = le16_to_cpu(fe->icbTag.flags) &\n\t\t\t\t\t\t\tICBTAG_FLAG_AD_MASK;\n\tiinfo->i_unique = 0;\n\tiinfo->i_lenEAttr = 0;\n\tiinfo->i_lenExtents = 0;\n\tiinfo->i_lenAlloc = 0;\n\tiinfo->i_next_alloc_block = 0;\n\tiinfo->i_next_alloc_goal = 0;\n\tif (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_EFE)) {\n\t\tiinfo->i_efe = 1;\n\t\tiinfo->i_use = 0;\n\t\tif (udf_alloc_i_data(inode, inode->i_sb->s_blocksize -\n\t\t\t\t\tsizeof(struct extendedFileEntry))) {\n\t\t\tmake_bad_inode(inode);\n\t\t\treturn;\n\t\t}\n\t\tmemcpy(iinfo->i_ext.i_data,\n\t\t       bh->b_data + sizeof(struct extendedFileEntry),\n\t\t       inode->i_sb->s_blocksize -\n\t\t\t\t\tsizeof(struct extendedFileEntry));\n\t} else if (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_FE)) {\n\t\tiinfo->i_efe = 0;\n\t\tiinfo->i_use = 0;\n\t\tif (udf_alloc_i_data(inode, inode->i_sb->s_blocksize -\n\t\t\t\t\t\tsizeof(struct fileEntry))) {\n\t\t\tmake_bad_inode(inode);\n\t\t\treturn;\n\t\t}\n\t\tmemcpy(iinfo->i_ext.i_data,\n\t\t       bh->b_data + sizeof(struct fileEntry),\n\t\t       inode->i_sb->s_blocksize - sizeof(struct fileEntry));\n\t} else if (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_USE)) {\n\t\tiinfo->i_efe = 0;\n\t\tiinfo->i_use = 1;\n\t\tiinfo->i_lenAlloc = le32_to_cpu(\n\t\t\t\t((struct unallocSpaceEntry *)bh->b_data)->\n\t\t\t\t lengthAllocDescs);\n\t\tif (udf_alloc_i_data(inode, inode->i_sb->s_blocksize -\n\t\t\t\t\tsizeof(struct unallocSpaceEntry))) {\n\t\t\tmake_bad_inode(inode);\n\t\t\treturn;\n\t\t}\n\t\tmemcpy(iinfo->i_ext.i_data,\n\t\t       bh->b_data + sizeof(struct unallocSpaceEntry),\n\t\t       inode->i_sb->s_blocksize -\n\t\t\t\t\tsizeof(struct unallocSpaceEntry));\n\t\treturn;\n\t}\n\n\tread_lock(&sbi->s_cred_lock);\n\ti_uid_write(inode, le32_to_cpu(fe->uid));\n\tif (!uid_valid(inode->i_uid) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_UID_IGNORE) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_UID_SET))\n\t\tinode->i_uid = UDF_SB(inode->i_sb)->s_uid;\n\n\ti_gid_write(inode, le32_to_cpu(fe->gid));\n\tif (!gid_valid(inode->i_gid) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_GID_IGNORE) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_GID_SET))\n\t\tinode->i_gid = UDF_SB(inode->i_sb)->s_gid;\n\n\tif (fe->icbTag.fileType != ICBTAG_FILE_TYPE_DIRECTORY &&\n\t\t\tsbi->s_fmode != UDF_INVALID_MODE)\n\t\tinode->i_mode = sbi->s_fmode;\n\telse if (fe->icbTag.fileType == ICBTAG_FILE_TYPE_DIRECTORY &&\n\t\t\tsbi->s_dmode != UDF_INVALID_MODE)\n\t\tinode->i_mode = sbi->s_dmode;\n\telse\n\t\tinode->i_mode = udf_convert_permissions(fe);\n\tinode->i_mode &= ~sbi->s_umask;\n\tread_unlock(&sbi->s_cred_lock);\n\n\tlink_count = le16_to_cpu(fe->fileLinkCount);\n\tif (!link_count)\n\t\tlink_count = 1;\n\tset_nlink(inode, link_count);\n\n\tinode->i_size = le64_to_cpu(fe->informationLength);\n\tiinfo->i_lenExtents = inode->i_size;\n\n\tif (iinfo->i_efe == 0) {\n\t\tinode->i_blocks = le64_to_cpu(fe->logicalBlocksRecorded) <<\n\t\t\t(inode->i_sb->s_blocksize_bits - 9);\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_atime, fe->accessTime))\n\t\t\tinode->i_atime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_mtime,\n\t\t\t\t\t    fe->modificationTime))\n\t\t\tinode->i_mtime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_ctime, fe->attrTime))\n\t\t\tinode->i_ctime = sbi->s_record_time;\n\n\t\tiinfo->i_unique = le64_to_cpu(fe->uniqueID);\n\t\tiinfo->i_lenEAttr = le32_to_cpu(fe->lengthExtendedAttr);\n\t\tiinfo->i_lenAlloc = le32_to_cpu(fe->lengthAllocDescs);\n\t\tiinfo->i_checkpoint = le32_to_cpu(fe->checkpoint);\n\t} else {\n\t\tinode->i_blocks = le64_to_cpu(efe->logicalBlocksRecorded) <<\n\t\t    (inode->i_sb->s_blocksize_bits - 9);\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_atime, efe->accessTime))\n\t\t\tinode->i_atime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_mtime,\n\t\t\t\t\t    efe->modificationTime))\n\t\t\tinode->i_mtime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&iinfo->i_crtime, efe->createTime))\n\t\t\tiinfo->i_crtime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_ctime, efe->attrTime))\n\t\t\tinode->i_ctime = sbi->s_record_time;\n\n\t\tiinfo->i_unique = le64_to_cpu(efe->uniqueID);\n\t\tiinfo->i_lenEAttr = le32_to_cpu(efe->lengthExtendedAttr);\n\t\tiinfo->i_lenAlloc = le32_to_cpu(efe->lengthAllocDescs);\n\t\tiinfo->i_checkpoint = le32_to_cpu(efe->checkpoint);\n\t}\n\n\tswitch (fe->icbTag.fileType) {\n\tcase ICBTAG_FILE_TYPE_DIRECTORY:\n\t\tinode->i_op = &udf_dir_inode_operations;\n\t\tinode->i_fop = &udf_dir_operations;\n\t\tinode->i_mode |= S_IFDIR;\n\t\tinc_nlink(inode);\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_REALTIME:\n\tcase ICBTAG_FILE_TYPE_REGULAR:\n\tcase ICBTAG_FILE_TYPE_UNDEF:\n\tcase ICBTAG_FILE_TYPE_VAT20:\n\t\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\t\tinode->i_data.a_ops = &udf_adinicb_aops;\n\t\telse\n\t\t\tinode->i_data.a_ops = &udf_aops;\n\t\tinode->i_op = &udf_file_inode_operations;\n\t\tinode->i_fop = &udf_file_operations;\n\t\tinode->i_mode |= S_IFREG;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_BLOCK:\n\t\tinode->i_mode |= S_IFBLK;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_CHAR:\n\t\tinode->i_mode |= S_IFCHR;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_FIFO:\n\t\tinit_special_inode(inode, inode->i_mode | S_IFIFO, 0);\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_SOCKET:\n\t\tinit_special_inode(inode, inode->i_mode | S_IFSOCK, 0);\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_SYMLINK:\n\t\tinode->i_data.a_ops = &udf_symlink_aops;\n\t\tinode->i_op = &udf_symlink_inode_operations;\n\t\tinode->i_mode = S_IFLNK | S_IRWXUGO;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_MAIN:\n\t\tudf_debug(\"METADATA FILE-----\\n\");\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_MIRROR:\n\t\tudf_debug(\"METADATA MIRROR FILE-----\\n\");\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_BITMAP:\n\t\tudf_debug(\"METADATA BITMAP FILE-----\\n\");\n\t\tbreak;\n\tdefault:\n\t\tudf_err(inode->i_sb, \"(ino %ld) failed unknown file type=%d\\n\",\n\t\t\tinode->i_ino, fe->icbTag.fileType);\n\t\tmake_bad_inode(inode);\n\t\treturn;\n\t}\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tstruct deviceSpec *dsea =\n\t\t\t(struct deviceSpec *)udf_get_extendedattr(inode, 12, 1);\n\t\tif (dsea) {\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t\tMKDEV(le32_to_cpu(dsea->majorDeviceIdent),\n\t\t\t\t      le32_to_cpu(dsea->minorDeviceIdent)));\n\t\t\t/* Developer ID ??? */\n\t\t} else\n\t\t\tmake_bad_inode(inode);\n\t}\n\tbrelse(bh);\n}\n", "target": 1, "idx": 179438}
{"func": "static Image *ReadDPXImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    magick[4],\n    value[MaxTextExtent];\n\n  DPXInfo\n    dpx;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  register ssize_t\n    i;\n\n  size_t\n    extent,\n    samples_per_pixel;\n\n  ssize_t\n    count,\n    n,\n    row,\n    y;\n\n  unsigned char\n    component_type;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read DPX file header.\n  */\n  offset=0;\n  count=ReadBlob(image,4,(unsigned char *) magick);\n  offset+=count;\n  if ((count != 4) || ((LocaleNCompare(magick,\"SDPX\",4) != 0) &&\n      (LocaleNCompare((char *) magick,\"XPDS\",4) != 0)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  image->endian=LSBEndian;\n  if (LocaleNCompare(magick,\"SDPX\",4) == 0)\n    image->endian=MSBEndian;\n  (void) ResetMagickMemory(&dpx,0,sizeof(dpx));\n  dpx.file.image_offset=ReadBlobLong(image);\n  offset+=4;\n  offset+=ReadBlob(image,sizeof(dpx.file.version),(unsigned char *)\n    dpx.file.version);\n  (void) FormatImageProperty(image,\"dpx:file.version\",\"%.8s\",dpx.file.version);\n  dpx.file.file_size=ReadBlobLong(image);\n  offset+=4;\n  dpx.file.ditto_key=ReadBlobLong(image);\n  offset+=4;\n  if (dpx.file.ditto_key != ~0U)\n    (void) FormatImageProperty(image,\"dpx:file.ditto.key\",\"%u\",\n      dpx.file.ditto_key);\n  dpx.file.generic_size=ReadBlobLong(image);\n  offset+=4;\n  dpx.file.industry_size=ReadBlobLong(image);\n  offset+=4;\n  dpx.file.user_size=ReadBlobLong(image);\n  offset+=4;\n  offset+=ReadBlob(image,sizeof(dpx.file.filename),(unsigned char *)\n    dpx.file.filename);\n  (void) FormatImageProperty(image,\"dpx:file.filename\",\"%.100s\",\n    dpx.file.filename);\n  (void) FormatImageProperty(image,\"document\",\"%.100s\",dpx.file.filename);\n  offset+=ReadBlob(image,sizeof(dpx.file.timestamp),(unsigned char *)\n    dpx.file.timestamp);\n  if (*dpx.file.timestamp != '\\0')\n    (void) FormatImageProperty(image,\"dpx:file.timestamp\",\"%.24s\",\n      dpx.file.timestamp);\n  offset+=ReadBlob(image,sizeof(dpx.file.creator),(unsigned char *)\n    dpx.file.creator);\n  if (*dpx.file.creator == '\\0')\n    {\n      (void) FormatImageProperty(image,\"dpx:file.creator\",\"%.100s\",\n        GetMagickVersion((size_t *) NULL));\n      (void) FormatImageProperty(image,\"software\",\"%.100s\",\n        GetMagickVersion((size_t *) NULL));\n    }\n  else\n    {\n      (void) FormatImageProperty(image,\"dpx:file.creator\",\"%.100s\",\n        dpx.file.creator);\n      (void) FormatImageProperty(image,\"software\",\"%.100s\",dpx.file.creator);\n    }\n  offset+=ReadBlob(image,sizeof(dpx.file.project),(unsigned char *)\n    dpx.file.project);\n  if (*dpx.file.project != '\\0')\n    {\n      (void) FormatImageProperty(image,\"dpx:file.project\",\"%.200s\",\n        dpx.file.project);\n      (void) FormatImageProperty(image,\"comment\",\"%.100s\",dpx.file.project);\n    }\n  offset+=ReadBlob(image,sizeof(dpx.file.copyright),(unsigned char *)\n    dpx.file.copyright);\n  if (*dpx.file.copyright != '\\0')\n    {\n      (void) FormatImageProperty(image,\"dpx:file.copyright\",\"%.200s\",\n        dpx.file.copyright);\n      (void) FormatImageProperty(image,\"copyright\",\"%.100s\",\n        dpx.file.copyright);\n    }\n  dpx.file.encrypt_key=ReadBlobLong(image);\n  offset+=4;\n  if (dpx.file.encrypt_key != ~0U)\n    (void) FormatImageProperty(image,\"dpx:file.encrypt_key\",\"%u\",\n      dpx.file.encrypt_key);\n  offset+=ReadBlob(image,sizeof(dpx.file.reserve),(unsigned char *)\n    dpx.file.reserve);\n  /*\n    Read DPX image header.\n  */\n  dpx.image.orientation=ReadBlobShort(image);\n  if (dpx.image.orientation > 7)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  offset+=2;\n  if (dpx.image.orientation != (unsigned short) ~0)\n    (void) FormatImageProperty(image,\"dpx:image.orientation\",\"%d\",\n      dpx.image.orientation);\n  switch (dpx.image.orientation)\n  {\n    default:\n    case 0: image->orientation=TopLeftOrientation; break;\n    case 1: image->orientation=TopRightOrientation; break;\n    case 2: image->orientation=BottomLeftOrientation; break;\n    case 3: image->orientation=BottomRightOrientation; break;\n    case 4: image->orientation=LeftTopOrientation; break;\n    case 5: image->orientation=RightTopOrientation; break;\n    case 6: image->orientation=LeftBottomOrientation; break;\n    case 7: image->orientation=RightBottomOrientation; break;\n  }\n  dpx.image.number_elements=ReadBlobShort(image);\n  if (dpx.image.number_elements > MaxNumberImageElements)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  offset+=2;\n  dpx.image.pixels_per_line=ReadBlobLong(image);\n  offset+=4;\n  image->columns=dpx.image.pixels_per_line;\n  dpx.image.lines_per_element=ReadBlobLong(image);\n  offset+=4;\n  image->rows=dpx.image.lines_per_element;\n  for (i=0; i < 8; i++)\n  {\n    char\n      property[MaxTextExtent];\n\n    dpx.image.image_element[i].data_sign=ReadBlobLong(image);\n    offset+=4;\n    dpx.image.image_element[i].low_data=ReadBlobLong(image);\n    offset+=4;\n    dpx.image.image_element[i].low_quantity=ReadBlobFloat(image);\n    offset+=4;\n    dpx.image.image_element[i].high_data=ReadBlobLong(image);\n    offset+=4;\n    dpx.image.image_element[i].high_quantity=ReadBlobFloat(image);\n    offset+=4;\n    dpx.image.image_element[i].descriptor=(unsigned char) ReadBlobByte(image);\n    offset++;\n    dpx.image.image_element[i].transfer_characteristic=(unsigned char)\n      ReadBlobByte(image);\n    (void) FormatLocaleString(property,MaxTextExtent,\n      \"dpx:image.element[%lu].transfer-characteristic\",(long) i);\n    (void) FormatImageProperty(image,property,\"%s\",\n      GetImageTransferCharacteristic((DPXTransferCharacteristic)\n      dpx.image.image_element[i].transfer_characteristic));\n    offset++;\n    dpx.image.image_element[i].colorimetric=(unsigned char) ReadBlobByte(image);\n    offset++;\n    dpx.image.image_element[i].bit_size=(unsigned char) ReadBlobByte(image);\n    offset++;\n    dpx.image.image_element[i].packing=ReadBlobShort(image);\n    offset+=2;\n    dpx.image.image_element[i].encoding=ReadBlobShort(image);\n    offset+=2;\n    dpx.image.image_element[i].data_offset=ReadBlobLong(image);\n    offset+=4;\n    dpx.image.image_element[i].end_of_line_padding=ReadBlobLong(image);\n    offset+=4;\n    dpx.image.image_element[i].end_of_image_padding=ReadBlobLong(image);\n    offset+=4;\n    offset+=ReadBlob(image,sizeof(dpx.image.image_element[i].description),\n      (unsigned char *) dpx.image.image_element[i].description);\n  }\n  (void) SetImageColorspace(image,RGBColorspace);\n  offset+=ReadBlob(image,sizeof(dpx.image.reserve),(unsigned char *)\n    dpx.image.reserve);\n  if (dpx.file.image_offset >= 1664U)\n    {\n      /*\n        Read DPX orientation header.\n      */\n      dpx.orientation.x_offset=ReadBlobLong(image);\n      offset+=4;\n      if (dpx.orientation.x_offset != ~0U)\n        (void) FormatImageProperty(image,\"dpx:orientation.x_offset\",\"%u\",\n          dpx.orientation.x_offset);\n      dpx.orientation.y_offset=ReadBlobLong(image);\n      offset+=4;\n      if (dpx.orientation.y_offset != ~0U)\n        (void) FormatImageProperty(image,\"dpx:orientation.y_offset\",\"%u\",\n          dpx.orientation.y_offset);\n      dpx.orientation.x_center=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.orientation.x_center) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:orientation.x_center\",\"%g\",\n          dpx.orientation.x_center);\n      dpx.orientation.y_center=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.orientation.y_center) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:orientation.y_center\",\"%g\",\n          dpx.orientation.y_center);\n      dpx.orientation.x_size=ReadBlobLong(image);\n      offset+=4;\n      if (dpx.orientation.x_size != ~0U)\n        (void) FormatImageProperty(image,\"dpx:orientation.x_size\",\"%u\",\n          dpx.orientation.x_size);\n      dpx.orientation.y_size=ReadBlobLong(image);\n      offset+=4;\n      if (dpx.orientation.y_size != ~0U)\n        (void) FormatImageProperty(image,\"dpx:orientation.y_size\",\"%u\",\n          dpx.orientation.y_size);\n      offset+=ReadBlob(image,sizeof(dpx.orientation.filename),(unsigned char *)\n        dpx.orientation.filename);\n      if (*dpx.orientation.filename != '\\0')\n        (void) FormatImageProperty(image,\"dpx:orientation.filename\",\"%.100s\",\n          dpx.orientation.filename);\n      offset+=ReadBlob(image,sizeof(dpx.orientation.timestamp),(unsigned char *)\n        dpx.orientation.timestamp);\n      if (*dpx.orientation.timestamp != '\\0')\n        (void) FormatImageProperty(image,\"dpx:orientation.timestamp\",\"%.24s\",\n          dpx.orientation.timestamp);\n      offset+=ReadBlob(image,sizeof(dpx.orientation.device),(unsigned char *)\n        dpx.orientation.device);\n      if (*dpx.orientation.device != '\\0')\n        (void) FormatImageProperty(image,\"dpx:orientation.device\",\"%.32s\",\n          dpx.orientation.device);\n      offset+=ReadBlob(image,sizeof(dpx.orientation.serial),(unsigned char *)\n        dpx.orientation.serial);\n      if (*dpx.orientation.serial != '\\0')\n        (void) FormatImageProperty(image,\"dpx:orientation.serial\",\"%.32s\",\n          dpx.orientation.serial);\n      for (i=0; i < 4; i++)\n      {\n        dpx.orientation.border[i]=ReadBlobShort(image);\n        offset+=2;\n      }\n      if ((dpx.orientation.border[0] != (unsigned short) (~0)) &&\n          (dpx.orientation.border[1] != (unsigned short) (~0)))\n        (void) FormatImageProperty(image,\"dpx:orientation.border\",\"%dx%d%+d%+d\",          dpx.orientation.border[0],dpx.orientation.border[1],\n          dpx.orientation.border[2],dpx.orientation.border[3]);\n      for (i=0; i < 2; i++)\n      {\n        dpx.orientation.aspect_ratio[i]=ReadBlobLong(image);\n        offset+=4;\n      }\n      if ((dpx.orientation.aspect_ratio[0] != ~0U) &&\n          (dpx.orientation.aspect_ratio[1] != ~0U))\n        (void) FormatImageProperty(image,\"dpx:orientation.aspect_ratio\",\n          \"%ux%u\",dpx.orientation.aspect_ratio[0],\n          dpx.orientation.aspect_ratio[1]);\n      offset+=ReadBlob(image,sizeof(dpx.orientation.reserve),(unsigned char *)\n        dpx.orientation.reserve);\n    }\n  if (dpx.file.image_offset >= 1920U)\n    {\n      /*\n        Read DPX film header.\n      */\n      offset+=ReadBlob(image,sizeof(dpx.film.id),(unsigned char *) dpx.film.id);\n      if (*dpx.film.id != '\\0')\n        (void) FormatImageProperty(image,\"dpx:film.id\",\"%.2s\",dpx.film.id);\n      offset+=ReadBlob(image,sizeof(dpx.film.type),(unsigned char *)\n        dpx.film.type);\n      if (*dpx.film.type != '\\0')\n        (void) FormatImageProperty(image,\"dpx:film.type\",\"%.2s\",dpx.film.type);\n      offset+=ReadBlob(image,sizeof(dpx.film.offset),(unsigned char *)\n        dpx.film.offset);\n      if (*dpx.film.offset != '\\0')\n        (void) FormatImageProperty(image,\"dpx:film.offset\",\"%.2s\",\n          dpx.film.offset);\n      offset+=ReadBlob(image,sizeof(dpx.film.prefix),(unsigned char *)\n        dpx.film.prefix);\n      if (*dpx.film.prefix != '\\0')\n        (void) FormatImageProperty(image,\"dpx:film.prefix\",\"%.6s\",\n          dpx.film.prefix);\n      offset+=ReadBlob(image,sizeof(dpx.film.count),(unsigned char *)\n        dpx.film.count);\n      if (*dpx.film.count != '\\0')\n        (void) FormatImageProperty(image,\"dpx:film.count\",\"%.4s\",\n          dpx.film.count);\n      offset+=ReadBlob(image,sizeof(dpx.film.format),(unsigned char *)\n        dpx.film.format);\n      if (*dpx.film.format != '\\0')\n        (void) FormatImageProperty(image,\"dpx:film.format\",\"%.4s\",\n          dpx.film.format);\n      dpx.film.frame_position=ReadBlobLong(image);\n      offset+=4;\n      if (dpx.film.frame_position != ~0U)\n        (void) FormatImageProperty(image,\"dpx:film.frame_position\",\"%u\",\n          dpx.film.frame_position);\n      dpx.film.sequence_extent=ReadBlobLong(image);\n      offset+=4;\n      if (dpx.film.sequence_extent != ~0U)\n        (void) FormatImageProperty(image,\"dpx:film.sequence_extent\",\"%u\",\n          dpx.film.sequence_extent);\n      dpx.film.held_count=ReadBlobLong(image);\n      offset+=4;\n      if (dpx.film.held_count != ~0U)\n        (void) FormatImageProperty(image,\"dpx:film.held_count\",\"%u\",\n          dpx.film.held_count);\n      dpx.film.frame_rate=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.film.frame_rate) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:film.frame_rate\",\"%g\",\n          dpx.film.frame_rate);\n      dpx.film.shutter_angle=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.film.shutter_angle) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:film.shutter_angle\",\"%g\",\n          dpx.film.shutter_angle);\n      offset+=ReadBlob(image,sizeof(dpx.film.frame_id),(unsigned char *)\n        dpx.film.frame_id);\n      if (*dpx.film.frame_id != '\\0')\n        (void) FormatImageProperty(image,\"dpx:film.frame_id\",\"%.32s\",\n          dpx.film.frame_id);\n      offset+=ReadBlob(image,sizeof(dpx.film.slate),(unsigned char *)\n        dpx.film.slate);\n      if (*dpx.film.slate != '\\0')\n        (void) FormatImageProperty(image,\"dpx:film.slate\",\"%.100s\",\n          dpx.film.slate);\n      offset+=ReadBlob(image,sizeof(dpx.film.reserve),(unsigned char *)\n        dpx.film.reserve);\n    }\n  if (dpx.file.image_offset >= 2048U)\n    {\n      /*\n        Read DPX television header.\n      */\n      dpx.television.time_code=(unsigned int) ReadBlobLong(image);\n      offset+=4;\n      TimeCodeToString(dpx.television.time_code,value);\n      (void) SetImageProperty(image,\"dpx:television.time.code\",value);\n      dpx.television.user_bits=(unsigned int) ReadBlobLong(image);\n      offset+=4;\n      TimeCodeToString(dpx.television.user_bits,value);\n      (void) SetImageProperty(image,\"dpx:television.user.bits\",value);\n      dpx.television.interlace=(unsigned char) ReadBlobByte(image);\n      offset++;\n      if (dpx.television.interlace != 0)\n        (void) FormatImageProperty(image,\"dpx:television.interlace\",\"%.20g\",\n          (double) dpx.television.interlace);\n      dpx.television.field_number=(unsigned char) ReadBlobByte(image);\n      offset++;\n      if (dpx.television.field_number != 0)\n        (void) FormatImageProperty(image,\"dpx:television.field_number\",\"%.20g\",\n          (double) dpx.television.field_number);\n      dpx.television.video_signal=(unsigned char) ReadBlobByte(image);\n      offset++;\n      if (dpx.television.video_signal != 0)\n        (void) FormatImageProperty(image,\"dpx:television.video_signal\",\"%.20g\",\n          (double) dpx.television.video_signal);\n      dpx.television.padding=(unsigned char) ReadBlobByte(image);\n      offset++;\n      if (dpx.television.padding != 0)\n        (void) FormatImageProperty(image,\"dpx:television.padding\",\"%d\",\n          dpx.television.padding);\n      dpx.television.horizontal_sample_rate=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.horizontal_sample_rate) != MagickFalse)\n        (void) FormatImageProperty(image,\n          \"dpx:television.horizontal_sample_rate\",\"%g\",\n          dpx.television.horizontal_sample_rate);\n      dpx.television.vertical_sample_rate=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.vertical_sample_rate) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:television.vertical_sample_rate\",\n          \"%g\",dpx.television.vertical_sample_rate);\n      dpx.television.frame_rate=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.frame_rate) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:television.frame_rate\",\"%g\",\n          dpx.television.frame_rate);\n      dpx.television.time_offset=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.time_offset) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:television.time_offset\",\"%g\",\n          dpx.television.time_offset);\n      dpx.television.gamma=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.gamma) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:television.gamma\",\"%g\",\n          dpx.television.gamma);\n      dpx.television.black_level=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.black_level) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:television.black_level\",\"%g\",\n          dpx.television.black_level);\n      dpx.television.black_gain=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.black_gain) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:television.black_gain\",\"%g\",\n          dpx.television.black_gain);\n      dpx.television.break_point=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.break_point) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:television.break_point\",\"%g\",\n          dpx.television.break_point);\n      dpx.television.white_level=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.white_level) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:television.white_level\",\"%g\",\n          dpx.television.white_level);\n      dpx.television.integration_times=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(dpx.television.integration_times) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:television.integration_times\",\n          \"%g\",dpx.television.integration_times);\n      offset+=ReadBlob(image,sizeof(dpx.television.reserve),(unsigned char *)\n        dpx.television.reserve);\n    }\n  if (dpx.file.image_offset > 2080U)\n    {\n      /*\n        Read DPX user header.\n      */\n      offset+=ReadBlob(image,sizeof(dpx.user.id),(unsigned char *) dpx.user.id);\n      if (*dpx.user.id != '\\0')\n        (void) FormatImageProperty(image,\"dpx:user.id\",\"%.32s\",dpx.user.id);\n      if ((dpx.file.user_size != ~0U) &&\n          ((size_t) dpx.file.user_size > sizeof(dpx.user.id)))\n        {\n          StringInfo\n            *profile;\n\n           profile=BlobToStringInfo((const void *) NULL,\n             dpx.file.user_size-sizeof(dpx.user.id));\n           if (profile == (StringInfo *) NULL)\n             ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n           offset+=ReadBlob(image,GetStringInfoLength(profile),\n             GetStringInfoDatum(profile));\n           (void) SetImageProfile(image,\"dpx:user-data\",profile);\n           profile=DestroyStringInfo(profile);\n        }\n    }\n  for ( ; offset < (MagickOffsetType) dpx.file.image_offset; offset++)\n    (void) ReadBlobByte(image);\n  /*\n    Read DPX image header.\n  */\n  if (image_info->ping != MagickFalse)\n    {\n       (void) CloseBlob(image);\n       return(GetFirstImageInList(image));\n     }\n   for (n=0; n < (ssize_t) dpx.image.number_elements; n++)\n   {\n     /*\n      Convert DPX raster image to pixel packets.\n    */\n    if ((dpx.image.image_element[n].data_offset != ~0U) &&\n        (dpx.image.image_element[n].data_offset != 0U))\n      {\n         MagickOffsetType\n           data_offset;\n\n         data_offset=(MagickOffsetType) dpx.image.image_element[n].data_offset;\n         if (data_offset < offset)\n           offset=SeekBlob(image,data_offset,SEEK_SET);\n         else\n           for ( ; offset < data_offset; offset++)\n             (void) ReadBlobByte(image);\n          if (offset != data_offset)\n            ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n       }\n    SetPrimaryChromaticity((DPXColorimetric)\n      dpx.image.image_element[n].colorimetric,&image->chromaticity);\n    image->depth=dpx.image.image_element[n].bit_size;\n    samples_per_pixel=1;\n    quantum_type=GrayQuantum;\n    component_type=dpx.image.image_element[n].descriptor;\n    switch (component_type)\n    {\n      case CbYCrY422ComponentType:\n      {\n        samples_per_pixel=2;\n        quantum_type=CbYCrYQuantum;\n        break;\n      }\n      case CbYACrYA4224ComponentType:\n      case CbYCr444ComponentType:\n      {\n        samples_per_pixel=3;\n        quantum_type=CbYCrQuantum;\n        break;\n      }\n      case RGBComponentType:\n      {\n        samples_per_pixel=3;\n        quantum_type=RGBQuantum;\n        break;\n      }\n      case ABGRComponentType:\n      case RGBAComponentType:\n      {\n        image->matte=MagickTrue;\n        samples_per_pixel=4;\n        quantum_type=RGBAQuantum;\n        break;\n      }\n      default:\n        break;\n    }\n    switch (component_type)\n    {\n      case CbYCrY422ComponentType:\n      case CbYACrYA4224ComponentType:\n      case CbYCr444ComponentType:\n      {\n        (void) SetImageColorspace(image,Rec709YCbCrColorspace);\n        break;\n      }\n      case LumaComponentType:\n      {\n        (void) SetImageColorspace(image,GRAYColorspace);\n        break;\n      }\n      default:\n      {\n        (void) SetImageColorspace(image,RGBColorspace);\n        if (dpx.image.image_element[n].transfer_characteristic == LogarithmicColorimetric)\n          (void) SetImageColorspace(image,LogColorspace);\n        if (dpx.image.image_element[n].transfer_characteristic == PrintingDensityColorimetric)\n          (void) SetImageColorspace(image,LogColorspace);\n        break;\n      }\n    }\n    extent=GetBytesPerRow(image->columns,samples_per_pixel,image->depth,\n      dpx.image.image_element[n].packing == 0 ? MagickFalse : MagickTrue);\n    /*\n      DPX any-bit pixel format.\n    */\n    status=MagickTrue;\n    row=0;\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    SetQuantumQuantum(quantum_info,32);\n    SetQuantumPack(quantum_info,dpx.image.image_element[n].packing == 0 ?\n      MagickTrue : MagickFalse);\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      MagickBooleanType\n        sync;\n\n      register PixelPacket\n        *q;\n\n      size_t\n        length;\n\n      ssize_t\n        count,\n        offset;\n\n      unsigned char\n        *pixels;\n\n      if (status == MagickFalse)\n        continue;\n      pixels=GetQuantumPixels(quantum_info);\n      {\n        count=ReadBlob(image,extent,pixels);\n        if ((image->progress_monitor != (MagickProgressMonitor) NULL) &&\n            (image->previous == (Image *) NULL))\n          {\n            MagickBooleanType\n              proceed;\n\n            proceed=SetImageProgress(image,LoadImageTag,(MagickOffsetType) row,\n              image->rows);\n            if (proceed == MagickFalse)\n              status=MagickFalse;\n          }\n        offset=row++;\n      }\n      if (count != (ssize_t) extent)\n        status=MagickFalse;\n      q=QueueAuthenticPixels(image,0,offset,image->columns,1,exception);\n      if (q == (PixelPacket *) NULL)\n        {\n          status=MagickFalse;\n          continue;\n        }\n      length=ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n        quantum_type,pixels,exception);\n      (void) length;\n      sync=SyncAuthenticPixels(image,exception);\n      if (sync == MagickFalse)\n        status=MagickFalse;\n    }\n    quantum_info=DestroyQuantumInfo(quantum_info);\n    if (status == MagickFalse)\n      ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n    SetQuantumImageType(image,quantum_type);\n    if (EOFBlob(image) != MagickFalse)\n      ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n        image->filename);\n  }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n", "target": 1, "idx": 181733}
{"func": "int DownloadManagerImpl::InProgressCount() const {\n  int count = 0;\n  for (const auto& it : downloads_) {\n    if (it.second->GetState() == download::DownloadItem::IN_PROGRESS)\n      ++count;\n  }\n  return count;\n}\n", "target": 0, "idx": 164040}
{"func": "  virtual InputMethodDescriptors* GetActiveInputMethods() {\n    chromeos::InputMethodDescriptors* result =\n        new chromeos::InputMethodDescriptors;\n     for (size_t i = 0; i < active_input_method_ids_.size(); ++i) {\n       const std::string& input_method_id = active_input_method_ids_[i];\n      const InputMethodDescriptor* descriptor =\n          chromeos::input_method::GetInputMethodDescriptorFromId(\n               input_method_id);\n       if (descriptor) {\n         result->push_back(*descriptor);\n      } else {\n        LOG(ERROR) << \"Descriptor is not found for: \" << input_method_id;\n      }\n    }\n    if (result->empty()) {\n      LOG(WARNING) << \"No active input methods found.\";\n      result->push_back(input_method::GetFallbackInputMethodDescriptor());\n    }\n    return result;\n   }\n", "target": 1, "idx": 183943}
{"func": " virtual void SetUp() {\n    fwd_txfm_ = GET_PARAM(0);\n    inv_txfm_ = GET_PARAM(1);\n\n     tx_type_  = GET_PARAM(2);\n     pitch_    = 4;\n     fwd_txfm_ref = fdct4x4_ref;\n   }\n", "target": 1, "idx": 188577}
{"func": "void AppCacheHost::SelectCacheForWorker(int parent_process_id,\n                                         int parent_host_id) {\n   DCHECK(pending_start_update_callback_.is_null() &&\n          pending_swap_cache_callback_.is_null() &&\n          pending_get_status_callback_.is_null() &&\n         !is_selection_pending() && !was_select_cache_called_);\n \n   was_select_cache_called_ = true;\n   parent_process_id_ = parent_process_id;\n   parent_host_id_ = parent_host_id;\n   FinishCacheSelection(NULL, NULL);\n }\n", "target": 1, "idx": 185619}
{"func": "void V8ContextNativeHandler::RunWithNativesEnabledModuleSystem(\n     const v8::FunctionCallbackInfo<v8::Value>& args) {\n   CHECK_EQ(args.Length(), 1);\n   CHECK(args[0]->IsFunction());\n  v8::Local<v8::Value> call_with_args[] = {\n    context()->module_system()->NewInstance()};\n   ModuleSystem::NativesEnabledScope natives_enabled(context()->module_system());\n  context()->CallFunction(v8::Local<v8::Function>::Cast(args[0]), 1,\n                          call_with_args);\n }\n", "target": 1, "idx": 185826}
{"func": "PHP_FUNCTION(imagepsencodefont)\n{\n\tzval *fnt;\n        char *enc, **enc_vector;\n        int enc_len, *f_ind;\n \n       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rs\", &fnt, &enc, &enc_len) == FAILURE) {\n                return;\n        }\n\tZEND_FETCH_RESOURCE(f_ind, int *, &fnt, -1, \"Type 1 font\", le_ps_font);\n\n\tif ((enc_vector = T1_LoadEncoding(enc)) == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Couldn't load encoding vector from %s\", enc);\n\t\tRETURN_FALSE;\n\t}\n\n\tT1_DeleteAllSizes(*f_ind);\n\tif (T1_ReencodeFont(*f_ind, enc_vector)) {\n\t\tT1_DeleteEncoding(enc_vector);\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Couldn't re-encode font\");\n\t\tRETURN_FALSE;\n\t}\n\n\tzend_list_insert(enc_vector, le_ps_enc TSRMLS_CC);\n\n\tRETURN_TRUE;\n}\n", "target": 1, "idx": 178484}
{"func": " void NavigationControllerImpl::DiscardNonCommittedEntriesInternal() {\n   if (pending_entry_index_ == -1)\n     delete pending_entry_;\n   pending_entry_ = NULL;\n   pending_entry_index_ = -1;\n  DiscardTransientEntry();\n }\n", "target": 1, "idx": 184880}
{"func": "static void enforcedRangeLongAttrAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)\n{\n    TRACE_EVENT_SET_SAMPLING_STATE(\"Blink\", \"DOMGetter\");\n    TestObjectV8Internal::enforcedRangeLongAttrAttributeGetter(info);\n    TRACE_EVENT_SET_SAMPLING_STATE(\"V8\", \"V8Execution\");\n}\n", "target": 0, "idx": 130750}
{"func": "static bool glfs_check_config(const char *cfgstring, char **reason)\n{\n\tchar *path;\n\tglfs_t *fs = NULL;\n\tglfs_fd_t *gfd = NULL;\n\tgluster_server *hosts = NULL; /* gluster server defination */\n\tbool result = true;\n\tpath = strchr(cfgstring, '/');\n\tif (!path) {\n\t\tif (asprintf(reason, \"No path found\") == -1)\n\t\t\t*reason = NULL;\n\t\tresult = false;\n\t\tgoto done;\n\t}\n\tpath += 1; /* get past '/' */\n\tfs = tcmu_create_glfs_object(path, &hosts);\n\tif (!fs) {\n\t\ttcmu_err(\"tcmu_create_glfs_object failed\\n\");\n\t\tgoto done;\n\t}\n\tgfd = glfs_open(fs, hosts->path, ALLOWED_BSOFLAGS);\n\tif (!gfd) {\n\t\tif (asprintf(reason, \"glfs_open failed: %m\") == -1)\n\t\t\t*reason = NULL;\n\t\tresult = false;\n\t\tgoto unref;\n\t}\n\tif (glfs_access(fs, hosts->path, R_OK|W_OK) == -1) {\n\t\tif (asprintf(reason, \"glfs_access file not present, or not writable\") == -1)\n\t\t\t*reason = NULL;\n\t\tresult = false;\n\t\tgoto unref;\n\t}\n\tgoto done;\nunref:\n\tgluster_cache_refresh(fs, path);\ndone:\n\tif (gfd)\n\t\tglfs_close(gfd);\n\tgluster_free_server(&hosts);\n\treturn result;\n}\n", "target": 1, "idx": 180807}
{"func": "void Player::finish(ExceptionState& exceptionState)\n{\n    if (!m_playbackRate)\n        return;\n    if (m_playbackRate < 0) {\n        setCurrentTime(0);\n    } else {\n        if (sourceEnd() == std::numeric_limits<double>::infinity()) {\n            exceptionState.throwDOMException(InvalidStateError, \"Player has source content whose end time is infinity.\");\n            return;\n        }\n        setCurrentTime(sourceEnd());\n    }\n    ASSERT(finished());\n}\n", "target": 0, "idx": 125317}
{"func": "int ptrace_writedata(struct task_struct *tsk, char __user *src, unsigned long dst, int len)\n{\n\tint copied = 0;\n\n\twhile (len > 0) {\n\t\tchar buf[128];\n\t\tint this_len, retval;\n\n\t\tthis_len = (len > sizeof(buf)) ? sizeof(buf) : len;\n\t\tif (copy_from_user(buf, src, this_len))\n\t\t\treturn -EFAULT;\n\t\tretval = access_process_vm(tsk, dst, buf, this_len, 1);\n\t\tif (!retval) {\n\t\t\tif (copied)\n\t\t\t\tbreak;\n\t\t\treturn -EIO;\n\t\t}\n\t\tcopied += retval;\n\t\tsrc += retval;\n\t\tdst += retval;\n\t\tlen -= retval;\n\t}\n\treturn copied;\n}\n", "target": 0, "idx": 30959}
{"func": " void DelegatedFrameHost::ClearDelegatedFrame() {\n   EvictDelegatedFrame();\n }\n", "target": 1, "idx": 186931}
{"func": "  sfnt_done_face( TT_Face  face )\n  {\n    FT_Memory     memory;\n    SFNT_Service  sfnt;\n\n\n    if ( !face )\n      return;\n\n    memory = face->root.memory;\n    sfnt   = (SFNT_Service)face->sfnt;\n\n    if ( sfnt )\n    {\n      /* destroy the postscript names table if it is loaded */\n      if ( sfnt->free_psnames )\n        sfnt->free_psnames( face );\n\n      /* destroy the embedded bitmaps table if it is loaded */\n      if ( sfnt->free_eblc )\n        sfnt->free_eblc( face );\n    }\n\n#ifdef TT_CONFIG_OPTION_BDF\n    /* freeing the embedded BDF properties */\n    tt_face_free_bdf_props( face );\n#endif\n\n    /* freeing the kerning table */\n    tt_face_done_kern( face );\n\n    /* freeing the collection table */\n    FT_FREE( face->ttc_header.offsets );\n    face->ttc_header.count = 0;\n\n    /* freeing table directory */\n    FT_FREE( face->dir_tables );\n    face->num_tables = 0;\n\n    {\n      FT_Stream  stream = FT_FACE_STREAM( face );\n\n\n      /* simply release the 'cmap' table frame */\n      FT_FRAME_RELEASE( face->cmap_table );\n      face->cmap_size = 0;\n    }\n\n    face->horz_metrics_size = 0;\n    face->vert_metrics_size = 0;\n\n    /* freeing vertical metrics, if any */\n    if ( face->vertical_info )\n    {\n      FT_FREE( face->vertical.long_metrics  );\n      FT_FREE( face->vertical.short_metrics );\n      face->vertical_info = 0;\n    }\n\n    /* freeing the gasp table */\n    FT_FREE( face->gasp.gaspRanges );\n    face->gasp.numRanges = 0;\n\n    /* freeing the name table */\n    if ( sfnt )\n      sfnt->free_name( face );\n\n    /* freeing family and style name */\n    FT_FREE( face->root.family_name );\n    FT_FREE( face->root.style_name );\n\n    /* freeing sbit size table */\n    FT_FREE( face->root.available_sizes );\n    FT_FREE( face->sbit_strike_map );\n    face->root.num_fixed_sizes = 0;\n\n    FT_FREE( face->postscript_name );\n\n    face->sfnt = NULL;\n  }\n", "target": 0, "idx": 7531}
{"func": "AuthenticatorSelectAccountSheetModel::AuthenticatorSelectAccountSheetModel(\n    AuthenticatorRequestDialogModel* dialog_model)\n    : AuthenticatorSheetModelBase(dialog_model) {}\n", "target": 0, "idx": 155530}
{"func": "v8::Local<v8::Value> V8ValueConverterImpl::ToV8Object(\n    v8::Isolate* isolate,\n    v8::Local<v8::Object> creation_context,\n     const base::DictionaryValue* val) const {\n   v8::Local<v8::Object> result(v8::Object::New(isolate));\n \n   for (base::DictionaryValue::Iterator iter(*val);\n        !iter.IsAtEnd(); iter.Advance()) {\n     const std::string& key = iter.key();\n     v8::Local<v8::Value> child_v8 =\n         ToV8ValueImpl(isolate, creation_context, &iter.value());\n     CHECK(!child_v8.IsEmpty());\n \n    v8::TryCatch try_catch(isolate);\n    result->Set(\n        v8::String::NewFromUtf8(\n            isolate, key.c_str(), v8::String::kNormalString, key.length()),\n         child_v8);\n    if (try_catch.HasCaught()) {\n      LOG(ERROR) << \"Setter for property \" << key.c_str() << \" threw an \"\n                 << \"exception.\";\n    }\n   }\n \n   return result;\n}\n", "target": 1, "idx": 187306}
{"func": "static int nfs4_xdr_dec_sequence(struct rpc_rqst *rqstp,\n\t\t\t\t struct xdr_stream *xdr,\n\t\t\t\t struct nfs4_sequence_res *res)\n{\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (!status)\n\t\tstatus = decode_sequence(xdr, res, rqstp);\n\treturn status;\n}\n", "target": 0, "idx": 23443}
{"func": "internalEntityProcessor(XML_Parser parser, const char *s, const char *end,\n                        const char **nextPtr) {\n  ENTITY *entity;\n  const char *textStart, *textEnd;\n  const char *next;\n  enum XML_Error result;\n  OPEN_INTERNAL_ENTITY *openEntity = parser->m_openInternalEntities;\n  if (! openEntity)\n    return XML_ERROR_UNEXPECTED_STATE;\n\n  entity = openEntity->entity;\n  textStart = ((char *)entity->textPtr) + entity->processed;\n  textEnd = (char *)(entity->textPtr + entity->textLen);\n  /* Set a safe default value in case 'next' does not get set */\n  next = textStart;\n\n#ifdef XML_DTD\n  if (entity->is_param) {\n     int tok\n         = XmlPrologTok(parser->m_internalEncoding, textStart, textEnd, &next);\n     result = doProlog(parser, parser->m_internalEncoding, textStart, textEnd,\n                      tok, next, &next, XML_FALSE);\n   } else\n #endif /* XML_DTD */\n     result = doContent(parser, openEntity->startTagLevel,\n                       parser->m_internalEncoding, textStart, textEnd, &next,\n                       XML_FALSE);\n\n  if (result != XML_ERROR_NONE)\n    return result;\n  else if (textEnd != next\n           && parser->m_parsingStatus.parsing == XML_SUSPENDED) {\n    entity->processed = (int)(next - (char *)entity->textPtr);\n    return result;\n  } else {\n    entity->open = XML_FALSE;\n    parser->m_openInternalEntities = openEntity->next;\n    /* put openEntity back in list of free instances */\n    openEntity->next = parser->m_freeInternalEntities;\n    parser->m_freeInternalEntities = openEntity;\n  }\n\n#ifdef XML_DTD\n  if (entity->is_param) {\n    int tok;\n     parser->m_processor = prologProcessor;\n     tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n     return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n                    (XML_Bool)! parser->m_parsingStatus.finalBuffer);\n   } else\n #endif /* XML_DTD */\n   {\n    parser->m_processor = contentProcessor;\n    /* see externalEntityContentProcessor vs contentProcessor */\n    return doContent(parser, parser->m_parentParser ? 1 : 0, parser->m_encoding,\n                     s, end, nextPtr,\n                     (XML_Bool)! parser->m_parsingStatus.finalBuffer);\n  }\n}\n", "target": 1, "idx": 182703}
{"func": "static Image *ReadWEBPImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  int\n    webp_status;\n\n  MagickBooleanType\n    status;\n\n  register unsigned char\n    *p;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    header[12],\n    *stream;\n\n  WebPDecoderConfig\n    configure;\n\n  WebPDecBuffer\n    *restrict webp_image = &configure.output;\n\n  WebPBitstreamFeatures\n    *restrict features = &configure.input;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (WebPInitDecoderConfig(&configure) == 0)\n    ThrowReaderException(ResourceLimitError,\"UnableToDecodeImageFile\");\n  webp_image->colorspace=MODE_RGBA;\n  count=ReadBlob(image,12,header);\n  if (count != 12)\n    ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n  status=IsWEBP(header,count);\n  if (status == MagickFalse)\n    ThrowReaderException(CorruptImageError,\"CorruptImage\");\n  length=(size_t) (ReadWebPLSBWord(header+4)+8);\n  if (length < 12)\n    ThrowReaderException(CorruptImageError,\"CorruptImage\");\n  stream=(unsigned char *) AcquireQuantumMemory(length,sizeof(*stream));\n  if (stream == (unsigned char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) memcpy(stream,header,12);\n  count=ReadBlob(image,length-12,stream+12);\n  if (count != (ssize_t) (length-12))\n    ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n  webp_status=WebPGetFeatures(stream,length,features);\n  if (webp_status == VP8_STATUS_OK)\n    {\n      image->columns=(size_t) features->width;\n      image->rows=(size_t) features->height;\n      image->depth=8;\n      image->matte=features->has_alpha != 0 ? MagickTrue : MagickFalse;\n      if (IsWEBPImageLossless(stream,length) != MagickFalse)\n        image->quality=100;\n      if (image_info->ping != MagickFalse)\n        {\n          stream=(unsigned char*) RelinquishMagickMemory(stream);\n           (void) CloseBlob(image);\n           return(GetFirstImageInList(image));\n         }\n       webp_status=WebPDecode(stream,length,&configure);\n     }\n   if (webp_status != VP8_STATUS_OK)\n    {\n      stream=(unsigned char*) RelinquishMagickMemory(stream);\n      switch (webp_status)\n      {\n        case VP8_STATUS_OUT_OF_MEMORY:\n        {\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          break;\n        }\n        case VP8_STATUS_INVALID_PARAM:\n        {\n          ThrowReaderException(CorruptImageError,\"invalid parameter\");\n          break;\n        }\n        case VP8_STATUS_BITSTREAM_ERROR:\n        {\n          ThrowReaderException(CorruptImageError,\"CorruptImage\");\n          break;\n        }\n        case VP8_STATUS_UNSUPPORTED_FEATURE:\n        {\n          ThrowReaderException(CoderError,\"DataEncodingSchemeIsNotSupported\");\n          break;\n        }\n        case VP8_STATUS_SUSPENDED:\n        {\n          ThrowReaderException(CorruptImageError,\"decoder suspended\");\n          break;\n        }\n        case VP8_STATUS_USER_ABORT:\n        {\n          ThrowReaderException(CorruptImageError,\"user abort\");\n          break;\n        }\n        case VP8_STATUS_NOT_ENOUGH_DATA:\n        {\n          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n          break;\n        }\n        default:\n          ThrowReaderException(CorruptImageError,\"CorruptImage\");\n      }\n    }\n  p=(unsigned char *) webp_image->u.RGBA.rgba;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register PixelPacket\n      *q;\n\n    register ssize_t\n      x;\n\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      SetPixelRed(q,ScaleCharToQuantum(*p++));\n      SetPixelGreen(q,ScaleCharToQuantum(*p++));\n      SetPixelBlue(q,ScaleCharToQuantum(*p++));\n      SetPixelAlpha(q,ScaleCharToQuantum(*p++));\n      q++;\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  WebPFreeDecBuffer(webp_image);\n  stream=(unsigned char*) RelinquishMagickMemory(stream);\n  return(image);\n}\n", "target": 1, "idx": 181792}
{"func": "void InspectorPageAgent::updateSensorsOverlayMessage()\n{\n    m_overlay->setOverride(InspectorOverlay::SensorsOverride, m_geolocationOverridden || m_deviceOrientation);\n }\n", "target": 1, "idx": 184243}
{"func": "    void setHasMarginBeforeQuirk(bool b) { m_hasMarginBeforeQuirk = b; }\n", "target": 0, "idx": 124768}
{"func": "next_matching_table(const struct ofproto *ofproto,\n                    const struct oftable *table, uint8_t table_id)\n{\n    return (table_id == 0xff\n            ? next_visible_table(ofproto, (table - ofproto->tables) + 1)\n            : NULL);\n}\n", "target": 0, "idx": 77279}
{"func": "horDiff16(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\tTIFFPredictorState* sp = PredictorState(tif);\n\ttmsize_t stride = sp->stride;\n\tuint16 *wp = (uint16*) cp0;\n\ttmsize_t wc = cc/2;\n\n    if((cc%(2*stride))!=0)\n    {\n        TIFFErrorExt(tif->tif_clientdata, \"horDiff8\",\n                     \"%s\", \"(cc%(2*stride))!=0\");\n        return 0;\n    }\n\n\tif (wc > stride) {\n\t\twc -= stride;\n\t\twp += wc - 1;\n\t\tdo {\n\t\t\tREPEAT4(stride, wp[stride] = (uint16)(((unsigned int)wp[stride] - (unsigned int)wp[0]) & 0xffff); wp--)\n\t\t\twc -= stride;\n\t\t} while (wc > 0);\n\t}\n\treturn 1;\n}\n", "target": 0, "idx": 94711}
{"func": "PHP_FUNCTION(imagecrop)\n{\n\tzval *IM;\n\tgdImagePtr im;\n\tgdImagePtr im_crop;\n\tgdRect rect;\n\tzval *z_rect;\n\tzval **tmp;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ra\", &IM, &z_rect) == FAILURE)  {\n\t\treturn;\n\t}\n\n \tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n \n \tif (zend_hash_find(HASH_OF(z_rect), \"x\", sizeof(\"x\"), (void **)&tmp) != FAILURE) {\n\t\trect.x = Z_LVAL_PP(tmp);\n \t} else {\n \t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing x position\");\n \t\tRETURN_FALSE;\n \t}\n \n \tif (zend_hash_find(HASH_OF(z_rect), \"y\", sizeof(\"x\"), (void **)&tmp) != FAILURE) {\n\t\trect.y = Z_LVAL_PP(tmp);\n \t} else {\n \t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing y position\");\n \t\tRETURN_FALSE;\n \t}\n \n \tif (zend_hash_find(HASH_OF(z_rect), \"width\", sizeof(\"width\"), (void **)&tmp) != FAILURE) {\n\t\trect.width = Z_LVAL_PP(tmp);\n \t} else {\n \t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing width\");\n \t\tRETURN_FALSE;\n \t}\n \n \tif (zend_hash_find(HASH_OF(z_rect), \"height\", sizeof(\"height\"), (void **)&tmp) != FAILURE) {\n\t\trect.height = Z_LVAL_PP(tmp);\n \t} else {\n \t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing height\");\n \t\tRETURN_FALSE;\n\t}\n\n\tim_crop = gdImageCrop(im, &rect);\n\n\tif (im_crop == NULL) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tZEND_REGISTER_RESOURCE(return_value, im_crop, le_gd);\n\t}\n}\n", "target": 1, "idx": 179599}
{"func": "static int megasas_dcmd_set_fw_time(MegasasState *s, MegasasCmd *cmd)\n{\n    uint64_t fw_time;\n\n    /* This is a dummy; setting of firmware time is not allowed */\n    memcpy(&fw_time, cmd->frame->dcmd.mbox, sizeof(fw_time));\n\n    trace_megasas_dcmd_set_fw_time(cmd->index, fw_time);\n    fw_time = cpu_to_le64(megasas_fw_time());\n    return MFI_STAT_OK;\n}\n", "target": 0, "idx": 10432}
{"func": "  virtual ~SyncInternal() {\n    CHECK(!initialized_);\n  }\n", "target": 0, "idx": 102219}
{"func": "static void hns_gmac_config_max_frame_length(void *mac_drv, u16 newval)\n{\n\tstruct mac_driver *drv = (struct mac_driver *)mac_drv;\n\n\tdsaf_set_dev_field(drv, GMAC_MAX_FRM_SIZE_REG, GMAC_MAX_FRM_SIZE_M,\n\t\t\t   GMAC_MAX_FRM_SIZE_S, newval);\n\n\tdsaf_set_dev_field(drv, GAMC_RX_MAX_FRAME, GMAC_MAX_FRM_SIZE_M,\n\t\t\t   GMAC_MAX_FRM_SIZE_S, newval);\n}\n", "target": 0, "idx": 85532}
{"func": "predicate_parse(const char *str, int nr_parens, int nr_preds,\n\t\tparse_pred_fn parse_pred, void *data,\n\t\tstruct filter_parse_error *pe)\n{\n\tstruct prog_entry *prog_stack;\n\tstruct prog_entry *prog;\n\tconst char *ptr = str;\n\tchar *inverts = NULL;\n\tint *op_stack;\n\tint *top;\n\tint invert = 0;\n\tint ret = -ENOMEM;\n\tint len;\n\tint N = 0;\n\tint i;\n\n\tnr_preds += 2; /* For TRUE and FALSE */\n\n\top_stack = kmalloc_array(nr_parens, sizeof(*op_stack), GFP_KERNEL);\n\tif (!op_stack)\n\t\treturn ERR_PTR(-ENOMEM);\n\tprog_stack = kmalloc_array(nr_preds, sizeof(*prog_stack), GFP_KERNEL);\n\tif (!prog_stack) {\n\t\tparse_error(pe, -ENOMEM, 0);\n\t\tgoto out_free;\n\t}\n\tinverts = kmalloc_array(nr_preds, sizeof(*inverts), GFP_KERNEL);\n\tif (!inverts) {\n\t\tparse_error(pe, -ENOMEM, 0);\n\t\tgoto out_free;\n\t}\n\n\ttop = op_stack;\n\tprog = prog_stack;\n\t*top = 0;\n\n\t/* First pass */\n\twhile (*ptr) {\t\t\t\t\t\t/* #1 */\n\t\tconst char *next = ptr++;\n\n\t\tif (isspace(*next))\n\t\t\tcontinue;\n\n\t\tswitch (*next) {\n\t\tcase '(':\t\t\t\t\t/* #2 */\n\t\t\tif (top - op_stack > nr_parens)\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\t*(++top) = invert;\n\t\t\tcontinue;\n\t\tcase '!':\t\t\t\t\t/* #3 */\n\t\t\tif (!is_not(next))\n\t\t\t\tbreak;\n\t\t\tinvert = !invert;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (N >= nr_preds) {\n\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_PREDS, next - str);\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tinverts[N] = invert;\t\t\t\t/* #4 */\n\t\tprog[N].target = N-1;\n\n\t\tlen = parse_pred(next, data, ptr - str, pe, &prog[N].pred);\n\t\tif (len < 0) {\n\t\t\tret = len;\n\t\t\tgoto out_free;\n\t\t}\n\t\tptr = next + len;\n\n\t\tN++;\n\n\t\tret = -1;\n\t\twhile (1) {\t\t\t\t\t/* #5 */\n\t\t\tnext = ptr++;\n\t\t\tif (isspace(*next))\n\t\t\t\tcontinue;\n\n\t\t\tswitch (*next) {\n\t\t\tcase ')':\n\t\t\tcase '\\0':\n\t\t\t\tbreak;\n\t\t\tcase '&':\n\t\t\tcase '|':\n\t\t\t\tif (next[1] == next[0]) {\n\t\t\t\t\tptr++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_PREDS,\n\t\t\t\t\t    next - str);\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\tinvert = *top & INVERT;\n\n\t\t\tif (*top & PROCESS_AND) {\t\t/* #7 */\n\t\t\t\tupdate_preds(prog, N - 1, invert);\n\t\t\t\t*top &= ~PROCESS_AND;\n\t\t\t}\n\t\t\tif (*next == '&') {\t\t\t/* #8 */\n\t\t\t\t*top |= PROCESS_AND;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (*top & PROCESS_OR) {\t\t/* #9 */\n\t\t\t\tupdate_preds(prog, N - 1, !invert);\n\t\t\t\t*top &= ~PROCESS_OR;\n\t\t\t}\n\t\t\tif (*next == '|') {\t\t\t/* #10 */\n\t\t\t\t*top |= PROCESS_OR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!*next)\t\t\t\t/* #11 */\n\t\t\t\tgoto out;\n\n\t\t\tif (top == op_stack) {\n\t\t\t\tret = -1;\n\t\t\t\t/* Too few '(' */\n\t\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_CLOSE, ptr - str);\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\ttop--;\t\t\t\t\t/* #12 */\n\t\t}\n\t}\n out:\n\tif (top != op_stack) {\n\t\t/* Too many '(' */\n\t\tparse_error(pe, FILT_ERR_TOO_MANY_OPEN, ptr - str);\n \t\tgoto out_free;\n \t}\n \n \tprog[N].pred = NULL;\t\t\t\t\t/* #13 */\n \tprog[N].target = 1;\t\t/* TRUE */\n \tprog[N+1].pred = NULL;\n\tprog[N+1].target = 0;\t\t/* FALSE */\n\tprog[N-1].target = N;\n\tprog[N-1].when_to_branch = false;\n\n\t/* Second Pass */\n\tfor (i = N-1 ; i--; ) {\n\t\tint target = prog[i].target;\n\t\tif (prog[i].when_to_branch == prog[target].when_to_branch)\n\t\t\tprog[i].target = prog[target].target;\n\t}\n\n\t/* Third Pass */\n\tfor (i = 0; i < N; i++) {\n\t\tinvert = inverts[i] ^ prog[i].when_to_branch;\n\t\tprog[i].when_to_branch = invert;\n\t\t/* Make sure the program always moves forward */\n\t\tif (WARN_ON(prog[i].target <= i)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\treturn prog;\nout_free:\n\tkfree(op_stack);\n\tkfree(prog_stack);\n\tkfree(inverts);\n\treturn ERR_PTR(ret);\n}\n", "target": 1, "idx": 182358}
{"func": "XML_ErrorString(enum XML_Error code) {\n  switch (code) {\n  case XML_ERROR_NONE:\n    return NULL;\n  case XML_ERROR_NO_MEMORY:\n    return XML_L(\"out of memory\");\n  case XML_ERROR_SYNTAX:\n    return XML_L(\"syntax error\");\n  case XML_ERROR_NO_ELEMENTS:\n    return XML_L(\"no element found\");\n  case XML_ERROR_INVALID_TOKEN:\n    return XML_L(\"not well-formed (invalid token)\");\n  case XML_ERROR_UNCLOSED_TOKEN:\n    return XML_L(\"unclosed token\");\n  case XML_ERROR_PARTIAL_CHAR:\n    return XML_L(\"partial character\");\n  case XML_ERROR_TAG_MISMATCH:\n    return XML_L(\"mismatched tag\");\n  case XML_ERROR_DUPLICATE_ATTRIBUTE:\n    return XML_L(\"duplicate attribute\");\n  case XML_ERROR_JUNK_AFTER_DOC_ELEMENT:\n    return XML_L(\"junk after document element\");\n  case XML_ERROR_PARAM_ENTITY_REF:\n    return XML_L(\"illegal parameter entity reference\");\n  case XML_ERROR_UNDEFINED_ENTITY:\n    return XML_L(\"undefined entity\");\n  case XML_ERROR_RECURSIVE_ENTITY_REF:\n    return XML_L(\"recursive entity reference\");\n  case XML_ERROR_ASYNC_ENTITY:\n    return XML_L(\"asynchronous entity\");\n  case XML_ERROR_BAD_CHAR_REF:\n    return XML_L(\"reference to invalid character number\");\n  case XML_ERROR_BINARY_ENTITY_REF:\n    return XML_L(\"reference to binary entity\");\n  case XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF:\n    return XML_L(\"reference to external entity in attribute\");\n  case XML_ERROR_MISPLACED_XML_PI:\n    return XML_L(\"XML or text declaration not at start of entity\");\n  case XML_ERROR_UNKNOWN_ENCODING:\n    return XML_L(\"unknown encoding\");\n  case XML_ERROR_INCORRECT_ENCODING:\n    return XML_L(\"encoding specified in XML declaration is incorrect\");\n  case XML_ERROR_UNCLOSED_CDATA_SECTION:\n    return XML_L(\"unclosed CDATA section\");\n  case XML_ERROR_EXTERNAL_ENTITY_HANDLING:\n    return XML_L(\"error in processing external entity reference\");\n  case XML_ERROR_NOT_STANDALONE:\n    return XML_L(\"document is not standalone\");\n  case XML_ERROR_UNEXPECTED_STATE:\n    return XML_L(\"unexpected parser state - please send a bug report\");\n  case XML_ERROR_ENTITY_DECLARED_IN_PE:\n    return XML_L(\"entity declared in parameter entity\");\n  case XML_ERROR_FEATURE_REQUIRES_XML_DTD:\n    return XML_L(\"requested feature requires XML_DTD support in Expat\");\n  case XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING:\n    return XML_L(\"cannot change setting once parsing has begun\");\n  /* Added in 1.95.7. */\n  case XML_ERROR_UNBOUND_PREFIX:\n    return XML_L(\"unbound prefix\");\n  /* Added in 1.95.8. */\n  case XML_ERROR_UNDECLARING_PREFIX:\n    return XML_L(\"must not undeclare prefix\");\n  case XML_ERROR_INCOMPLETE_PE:\n    return XML_L(\"incomplete markup in parameter entity\");\n  case XML_ERROR_XML_DECL:\n    return XML_L(\"XML declaration not well-formed\");\n  case XML_ERROR_TEXT_DECL:\n    return XML_L(\"text declaration not well-formed\");\n  case XML_ERROR_PUBLICID:\n    return XML_L(\"illegal character(s) in public id\");\n  case XML_ERROR_SUSPENDED:\n    return XML_L(\"parser suspended\");\n  case XML_ERROR_NOT_SUSPENDED:\n    return XML_L(\"parser not suspended\");\n  case XML_ERROR_ABORTED:\n    return XML_L(\"parsing aborted\");\n  case XML_ERROR_FINISHED:\n    return XML_L(\"parsing finished\");\n  case XML_ERROR_SUSPEND_PE:\n    return XML_L(\"cannot suspend in external parameter entity\");\n  /* Added in 2.0.0. */\n  case XML_ERROR_RESERVED_PREFIX_XML:\n    return XML_L(\n        \"reserved prefix (xml) must not be undeclared or bound to another namespace name\");\n  case XML_ERROR_RESERVED_PREFIX_XMLNS:\n    return XML_L(\"reserved prefix (xmlns) must not be declared or undeclared\");\n  case XML_ERROR_RESERVED_NAMESPACE_URI:\n    return XML_L(\n        \"prefix must not be bound to one of the reserved namespace names\");\n  /* Added in 2.2.5. */\n  case XML_ERROR_INVALID_ARGUMENT: /* Constant added in 2.2.1, already */\n    return XML_L(\"invalid argument\");\n  }\n  return NULL;\n}\n", "target": 0, "idx": 88179}
{"func": "long long Chapters::Atom::GetStopTimecode() const\n{\n    return m_stop_timecode;\n}\n", "target": 1, "idx": 188380}
{"func": "static void unaccount_pmu_sb_event(struct perf_event *event)\n{\n\tif (is_sb_event(event))\n\t\tdetach_sb_event(event);\n}\n", "target": 0, "idx": 68433}
{"func": "void OfflinePageModelTaskified::GetOfflineIdsForClientId(\n    const ClientId& client_id,\n    const MultipleOfflineIdCallback& callback) {\n  auto task = GetPagesTask::CreateTaskMatchingClientIds(\n      store_.get(), base::Bind(&WrapInMultipleItemsCallback, callback),\n      {client_id});\n  task_queue_.AddTask(std::move(task));\n}\n", "target": 0, "idx": 169003}
{"func": "static int opmul(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\n\tif ( op->operands[0].type & OT_QWORD ) {\n\t\tdata[l++] = 0x48;\n\t}\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_WORD ) {\n\t\t\tdata[l++] = 0x66;\n\t\t}\n\t\tif (op->operands[0].type & OT_BYTE) {\n\t\t\tdata[l++] = 0xf6;\n\t\t} else {\n\t\t\tdata[l++] = 0xf7;\n\t\t}\n\t\tif (op->operands[0].type & OT_MEMORY) {\n\t\t\tdata[l++] = 0x20 | op->operands[0].regs[0];\n\t\t} else {\n\t\t\tdata[l++] = 0xe0 | op->operands[0].reg;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n", "target": 0, "idx": 75440}
{"func": " header_put_le_short (SF_PRIVATE *psf, int x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 2)\n\t{\tpsf->header [psf->headindex++] = x ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\t} ;\n } /* header_put_le_short */\n", "target": 1, "idx": 183230}
{"func": "static int em_fxrstor(struct x86_emulate_ctxt *ctxt)\n{\n\tstruct fxregs_state fx_state;\n\tint rc;\n\n\trc = check_fxsr(ctxt);\n \tif (rc != X86EMUL_CONTINUE)\n \t\treturn rc;\n \n\trc = segmented_read(ctxt, ctxt->memop.addr.mem, &fx_state, 512);\n \tif (rc != X86EMUL_CONTINUE)\n \t\treturn rc;\n \n\tif (fx_state.mxcsr >> 16)\n\t\treturn emulate_gp(ctxt, 0);\n\n\tctxt->ops->get_fpu(ctxt);\n\n\tif (ctxt->mode < X86EMUL_MODE_PROT64)\n\t\trc = fxrstor_fixup(ctxt, &fx_state);\n\n\tif (rc == X86EMUL_CONTINUE)\n\t\trc = asm_safe(\"fxrstor %[fx]\", : [fx] \"m\"(fx_state));\n\n\tctxt->ops->put_fpu(ctxt);\n\n\treturn rc;\n}\n", "target": 1, "idx": 181616}
{"func": "void UsbFindDevicesFunction::OnGetDevicesComplete(\n    const std::vector<scoped_refptr<UsbDevice>>& devices) {\n  result_.reset(new base::ListValue());\n  barrier_ = base::BarrierClosure(\n      devices.size(), base::Bind(&UsbFindDevicesFunction::OpenComplete, this));\n\n  for (const scoped_refptr<UsbDevice>& device : devices) {\n    if (device->vendor_id() != vendor_id_ ||\n         device->product_id() != product_id_) {\n       barrier_.Run();\n     } else {\n      device->OpenInterface(\n          interface_id_,\n          base::Bind(&UsbFindDevicesFunction::OnDeviceOpened, this));\n     }\n   }\n }\n", "target": 1, "idx": 185482}
{"func": "void SoftGSM::onQueueFilled(OMX_U32 /* portIndex */) {\n if (mSignalledError) {\n return;\n }\n\n List<BufferInfo *> &inQueue = getPortQueue(0);\n List<BufferInfo *> &outQueue = getPortQueue(1);\n\n while (!inQueue.empty() && !outQueue.empty()) {\n BufferInfo *inInfo = *inQueue.begin();\n        OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;\n\n BufferInfo *outInfo = *outQueue.begin();\n        OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;\n\n if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {\n            inQueue.erase(inQueue.begin());\n            inInfo->mOwnedByUs = false;\n            notifyEmptyBufferDone(inHeader);\n\n            outHeader->nFilledLen = 0;\n            outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n\n            outQueue.erase(outQueue.begin());\n            outInfo->mOwnedByUs = false;\n            notifyFillBufferDone(outHeader);\n return;\n }\n\n if (inHeader->nFilledLen > kMaxNumSamplesPerFrame) {\n            ALOGE(\"input buffer too large (%d).\", inHeader->nFilledLen);\n            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n            mSignalledError = true;\n }\n\n if(((inHeader->nFilledLen / kMSGSMFrameSize) * kMSGSMFrameSize) != inHeader->nFilledLen) {\n            ALOGE(\"input buffer not multiple of %d (%d).\", kMSGSMFrameSize, inHeader->nFilledLen);\n            notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n\n             mSignalledError = true;\n         }\n \n         uint8_t *inputptr = inHeader->pBuffer + inHeader->nOffset;\n \n         int n = mSignalledError ? 0 : DecodeGSM(mGsm,\n reinterpret_cast<int16_t *>(outHeader->pBuffer), inputptr, inHeader->nFilledLen);\n\n        outHeader->nTimeStamp = inHeader->nTimeStamp;\n        outHeader->nOffset = 0;\n        outHeader->nFilledLen = n * sizeof(int16_t);\n        outHeader->nFlags = 0;\n\n        inInfo->mOwnedByUs = false;\n        inQueue.erase(inQueue.begin());\n        inInfo = NULL;\n        notifyEmptyBufferDone(inHeader);\n        inHeader = NULL;\n\n        outInfo->mOwnedByUs = false;\n        outQueue.erase(outQueue.begin());\n        outInfo = NULL;\n        notifyFillBufferDone(outHeader);\n        outHeader = NULL;\n }\n}\n", "target": 1, "idx": 187801}
{"func": "  LocalSiteCharacteristicsWebContentsObserverTest() {\n    scoped_feature_list_.InitAndEnableFeature(\n        features::kSiteCharacteristicsDatabase);\n  }\n", "target": 1, "idx": 186185}
{"func": "void queue_push(register Queue *qp, size_t extra_length, char const *info)\n{\n    register char *cp;\n    size_t memory_length;\n    size_t available_length;\n    size_t begin_length;\n    size_t n_begin;\n    size_t q_length;\n\n    if (!extra_length)\n        return;\n\n    memory_length    = qp->d_memory_end - qp->d_memory;\n\n    q_length = \n        qp->d_read <= qp->d_write ?\n            (size_t)(qp->d_write - qp->d_read)\n        :\n            memory_length - (qp->d_read - qp->d_write);\n\n    available_length = memory_length - q_length - 1;\n                            /* -1, as the Q cannot completely fill up all   */\n                            /* available memory in the buffer               */\n\n    if (message_show(MSG_INFO))\n        message(\"push_front %u bytes in `%s'\", (unsigned)extra_length, info);\n \n     if (extra_length > available_length)\n     {\n                                                    /* enlarge the buffer:  */\n         memory_length += extra_length - available_length + BLOCK_QUEUE;\n         cp = new_memory(memory_length, sizeof(char));\n \n         if (message_show(MSG_INFO))\n            message(\"Reallocating queue at %p to %p\", qp->d_memory, cp);\n\n        if (qp->d_read > qp->d_write)               /* q wraps around end   */\n        {\n            size_t tail_len = qp->d_memory_end - qp->d_read;\n            memcpy(cp, qp->d_read, tail_len);       /* first part -> begin  */\n                                                    /* 2nd part beyond      */\n            memcpy(cp + tail_len, qp->d_memory, \n                                    (size_t)(qp->d_write - qp->d_memory));\n            qp->d_write = cp + q_length;\n            qp->d_read = cp;\n         }\n         else                                        /* q as one block       */\n         {\n            memcpy(cp, qp->d_memory, memory_length);/* cp existing buffer   */\n             qp->d_read = cp + (qp->d_read - qp->d_memory);\n             qp->d_write = cp + (qp->d_write - qp->d_memory);\n         }\n\n        free(qp->d_memory);                         /* free old memory      */\n        qp->d_memory_end = cp + memory_length;      /* update d_memory_end  */\n        qp->d_memory = cp;                          /* update d_memory      */\n    }\n\n    /*\n        Write as much as possible at the begin of the buffer, then write\n        the remaining chars at the end.\n\n        q_length is increased by the length of the info string\n\n        The first chars to write are at the end of info, and the 2nd part to\n        write are the initial chars of info, since the initial part of info\n        is then read first.\n    */\n\n                                                /* # chars available at the */\n    begin_length = qp->d_read - qp->d_memory;   /* begin of the buffer      */\n\n    n_begin = extra_length <= begin_length ?    /* determine # to write at  */\n                    extra_length                /* the begin of the buffer  */\n                :\n                    begin_length;\n\n    memcpy                                      /* write trailing part of   */\n    (                                           /* info first               */\n        qp->d_read -= n_begin,\n        info + extra_length - n_begin,\n        n_begin\n    );\n\n    if (extra_length > begin_length)            /* not yet all chars written*/\n    {\n        /* continue with the remaining number of characters. Insert these at*/\n        /* the end of the buffer                                            */\n\n        extra_length -= begin_length;           /* reduce # to write        */\n\n\n        memcpy                                  /* d_read wraps to the end  */\n        (                                       /* write info's rest        */\n            qp->d_read = qp->d_memory_end - extra_length,\n            info,\n            extra_length\n        );\n    }\n}\n", "target": 1, "idx": 181631}
{"func": "  const NotificationSource& source() const {\n    return source_;\n  }\n", "target": 0, "idx": 156754}
{"func": "void ExtensionsGuestViewMessageFilter::ResumeAttachOrDestroy(\n    int32_t element_instance_id,\n    int32_t plugin_frame_routing_id) {\n  auto it = frame_navigation_helpers_.find(element_instance_id);\n  if (it == frame_navigation_helpers_.end()) {\n    return;\n  }\n  auto* plugin_rfh = content::RenderFrameHost::FromID(render_process_id_,\n                                                      plugin_frame_routing_id);\n  auto* helper = it->second.get();\n  auto* guest_view = helper->GetGuestView();\n  if (!guest_view)\n    return;\n \n  if (plugin_rfh) {\n    DCHECK(\n        guest_view->web_contents()->CanAttachToOuterContentsFrame(plugin_rfh));\n    guest_view->AttachToOuterWebContentsFrame(plugin_rfh, element_instance_id,\n                                              helper->is_full_page_plugin());\n  } else {\n    guest_view->GetEmbedderFrame()->Send(\n        new ExtensionsGuestViewMsg_DestroyFrameContainer(element_instance_id));\n    guest_view->Destroy(true);\n  }\n  frame_navigation_helpers_.erase(element_instance_id);\n }\n", "target": 1, "idx": 187028}
{"func": " void CLASS foveon_load_camf()\n {\n   unsigned type, wide, high, i, j, row, col, diff;\n  ushort huff[258], vpred[2][2] = {{512,512},{512,512}}, hpred[2];\n \n   fseek (ifp, meta_offset, SEEK_SET);\n   type = get4();  get4();  get4();\n   wide = get4();\n   high = get4();\n   if (type == 2) {\n     fread (meta_data, 1, meta_length, ifp);\n     for (i=0; i < meta_length; i++) {\n      high = (high * 1597 + 51749) % 244944;\n      wide = high * (INT64) 301593171 >> 24;\n      meta_data[i] ^= ((((high << 8) - wide) >> 1) + wide) >> 17;\n    }\n  } else if (type == 4) {\n    free (meta_data);\n    meta_data = (char *) malloc (meta_length = wide*high*3/2);\n    merror (meta_data, \"foveon_load_camf()\");\n    foveon_huff (huff);\n    get4();\n    getbits(-1);\n    for (j=row=0; row < high; row++) {\n      for (col=0; col < wide; col++) {\n\tdiff = ljpeg_diff(huff);\n\tif (col < 2) hpred[col] = vpred[row & 1][col] += diff;\n\telse         hpred[col & 1] += diff;\n\tif (col & 1) {\n\t  meta_data[j++] = hpred[0] >> 4;\n\t  meta_data[j++] = hpred[0] << 4 | hpred[1] >> 8;\n\t  meta_data[j++] = hpred[1];\n        }\n      }\n    }\n  } else\n    fprintf (stderr,_(\"%s has unknown CAMF type %d.\\n\"), ifname, type);\n}\n", "target": 1, "idx": 181486}
{"func": "static int vrend_decode_set_polygon_stipple(struct vrend_decode_ctx *ctx, int length)\n{\n   struct pipe_poly_stipple ps;\n   int i;\n\n   if (length != VIRGL_POLYGON_STIPPLE_SIZE)\n      return EINVAL;\n\n   for (i = 0; i < 32; i++)\n      ps.stipple[i] = get_buf_entry(ctx, VIRGL_POLYGON_STIPPLE_P0 + i);\n\n   vrend_set_polygon_stipple(ctx->grctx, &ps);\n   return 0;\n}\n", "target": 0, "idx": 9118}
{"func": "const TransformPaintPropertyNode* t0() {\n  return TransformPaintPropertyNode::Root();\n}\n", "target": 1, "idx": 185700}
{"func": "static int jas_iccputsint(jas_stream_t *out, int n, longlong val)\n {\n\tulonglong tmp;\n \ttmp = (val < 0) ? (abort(), 0) : val;\n \treturn jas_iccputuint(out, n, tmp);\n }\n", "target": 1, "idx": 181861}
{"func": "  void CreateFile(const FilePath& file_path) {\n    const std::string kFoo = \"foo\";\n    ASSERT_TRUE(file_util::WriteFile(file_path, kFoo.data(), kFoo.size()))\n        << \": \" << file_path.value();\n  }\n", "target": 1, "idx": 184443}
{"func": "OMX_ERRORTYPE  omx_vdec::set_config(OMX_IN OMX_HANDLETYPE      hComp,\n        OMX_IN OMX_INDEXTYPE configIndex,\n        OMX_IN OMX_PTR        configData)\n{\n (void) hComp;\n if (m_state == OMX_StateInvalid) {\n        DEBUG_PRINT_ERROR(\"Get Config in Invalid State\");\n return OMX_ErrorInvalidState;\n }\n\n    OMX_ERRORTYPE ret = OMX_ErrorNone;\n    OMX_VIDEO_CONFIG_NALSIZE *pNal;\n\n    DEBUG_PRINT_LOW(\"Set Config Called\");\n\n if (configIndex == (OMX_INDEXTYPE)OMX_IndexVendorVideoExtraData) {\n        OMX_VENDOR_EXTRADATATYPE *config = (OMX_VENDOR_EXTRADATATYPE *) configData;\n        DEBUG_PRINT_LOW(\"Index OMX_IndexVendorVideoExtraData called\");\n if (!strcmp(drv_ctx.kind, \"OMX.qcom.video.decoder.avc\") ||\n !strcmp(drv_ctx.kind, \"OMX.qcom.video.decoder.mvc\")) {\n            DEBUG_PRINT_LOW(\"Index OMX_IndexVendorVideoExtraData AVC\");\n            OMX_U32 extra_size;\n\n            nal_length = (config->pData[4] & 0x03) + 1;\n\n            extra_size = 0;\n if (nal_length > 2) {\n /* Presently we assume that only one SPS and one PPS in AvC1 Atom */\n                extra_size = (nal_length - 2) * 2;\n }\n\n            OMX_U8 *pSrcBuf = (OMX_U8 *) (&config->pData[6]);\n            OMX_U8 *pDestBuf;\n            m_vendor_config.nPortIndex = config->nPortIndex;\n\n            m_vendor_config.nDataSize = config->nDataSize - 6 - 1 + extra_size;\n            m_vendor_config.pData = (OMX_U8 *) malloc(m_vendor_config.nDataSize);\n            OMX_U32 len;\n            OMX_U8 index = 0;\n            pDestBuf = m_vendor_config.pData;\n\n            DEBUG_PRINT_LOW(\"Rxd SPS+PPS nPortIndex[%u] len[%u] data[%p]\",\n (unsigned int)m_vendor_config.nPortIndex,\n (unsigned int)m_vendor_config.nDataSize,\n                    m_vendor_config.pData);\n while (index < 2) {\n uint8 *psize;\n                len = *pSrcBuf;\n                len = len << 8;\n                len |= *(pSrcBuf + 1);\n                psize = (uint8 *) & len;\n                memcpy(pDestBuf + nal_length, pSrcBuf + 2,len);\n for (unsigned int i = 0; i < nal_length; i++) {\n                    pDestBuf[i] = psize[nal_length - 1 - i];\n }\n                pDestBuf += len + nal_length;\n                pSrcBuf += len + 2;\n                index++;\n                pSrcBuf++; // skip picture param set\n                len = 0;\n }\n } else if (!strcmp(drv_ctx.kind, \"OMX.qcom.video.decoder.mpeg4\") ||\n !strcmp(drv_ctx.kind, \"OMX.qcom.video.decoder.mpeg2\")) {\n            m_vendor_config.nPortIndex = config->nPortIndex;\n            m_vendor_config.nDataSize = config->nDataSize;\n            m_vendor_config.pData = (OMX_U8 *) malloc((config->nDataSize));\n            memcpy(m_vendor_config.pData, config->pData,config->nDataSize);\n } else if (!strcmp(drv_ctx.kind, \"OMX.qcom.video.decoder.vc1\")) {\n if (m_vendor_config.pData) {\n                free(m_vendor_config.pData);\n                m_vendor_config.pData = NULL;\n                m_vendor_config.nDataSize = 0;\n }\n\n if (((*((OMX_U32 *) config->pData)) &\n                        VC1_SP_MP_START_CODE_MASK) ==\n                    VC1_SP_MP_START_CODE) {\n                DEBUG_PRINT_LOW(\"set_config - VC1 simple/main profile\");\n                m_vendor_config.nPortIndex = config->nPortIndex;\n                m_vendor_config.nDataSize = config->nDataSize;\n                m_vendor_config.pData =\n (OMX_U8 *) malloc(config->nDataSize);\n                memcpy(m_vendor_config.pData, config->pData,\n                        config->nDataSize);\n                m_vc1_profile = VC1_SP_MP_RCV;\n } else if (*((OMX_U32 *) config->pData) == VC1_AP_SEQ_START_CODE) {\n                DEBUG_PRINT_LOW(\"set_config - VC1 Advance profile\");\n                m_vendor_config.nPortIndex = config->nPortIndex;\n                m_vendor_config.nDataSize = config->nDataSize;\n                m_vendor_config.pData =\n (OMX_U8 *) malloc((config->nDataSize));\n                memcpy(m_vendor_config.pData, config->pData,\n                        config->nDataSize);\n                m_vc1_profile = VC1_AP;\n } else if ((config->nDataSize == VC1_STRUCT_C_LEN)) {\n                DEBUG_PRINT_LOW(\"set_config - VC1 Simple/Main profile struct C only\");\n                m_vendor_config.nPortIndex = config->nPortIndex;\n                m_vendor_config.nDataSize  = config->nDataSize;\n                m_vendor_config.pData = (OMX_U8*)malloc(config->nDataSize);\n                memcpy(m_vendor_config.pData,config->pData,config->nDataSize);\n                m_vc1_profile = VC1_SP_MP_RCV;\n } else {\n                DEBUG_PRINT_LOW(\"set_config - Error: Unknown VC1 profile\");\n }\n }\n return ret;\n } else if (configIndex == OMX_IndexConfigVideoNalSize) {\n\n         struct v4l2_control temp;\n         temp.id = V4L2_CID_MPEG_VIDC_VIDEO_STREAM_FORMAT;\n \n         pNal = reinterpret_cast < OMX_VIDEO_CONFIG_NALSIZE * >(configData);\n         switch (pNal->nNaluBytes) {\n             case 0:\n                temp.value = V4L2_MPEG_VIDC_VIDEO_NAL_FORMAT_STARTCODES;\n break;\n case 2:\n                temp.value = V4L2_MPEG_VIDC_VIDEO_NAL_FORMAT_TWO_BYTE_LENGTH;\n break;\n case 4:\n                temp.value = V4L2_MPEG_VIDC_VIDEO_NAL_FORMAT_FOUR_BYTE_LENGTH;\n break;\n default:\n return OMX_ErrorUnsupportedSetting;\n }\n\n if (!arbitrary_bytes) {\n /* In arbitrary bytes mode, the assembler strips out nal size and replaces\n             * with start code, so only need to notify driver in frame by frame mode */\n if (ioctl(drv_ctx.video_driver_fd, VIDIOC_S_CTRL, &temp)) {\n                DEBUG_PRINT_ERROR(\"Failed to set V4L2_CID_MPEG_VIDC_VIDEO_STREAM_FORMAT\");\n return OMX_ErrorHardware;\n }\n }\n\n        nal_length = pNal->nNaluBytes;\n        m_frame_parser.init_nal_length(nal_length);\n\n        DEBUG_PRINT_LOW(\"OMX_IndexConfigVideoNalSize called with Size %d\", nal_length);\n return ret;\n } else if ((int)configIndex == (int)OMX_IndexVendorVideoFrameRate) {\n        OMX_VENDOR_VIDEOFRAMERATE *config = (OMX_VENDOR_VIDEOFRAMERATE *) configData;\n        DEBUG_PRINT_HIGH(\"Index OMX_IndexVendorVideoFrameRate %u\", (unsigned int)config->nFps);\n\n if (config->nPortIndex == OMX_CORE_INPUT_PORT_INDEX) {\n if (config->bEnabled) {\n if ((config->nFps >> 16) > 0) {\n                    DEBUG_PRINT_HIGH(\"set_config: frame rate set by omx client : %u\",\n (unsigned int)config->nFps >> 16);\n                    Q16ToFraction(config->nFps, drv_ctx.frame_rate.fps_numerator,\n                            drv_ctx.frame_rate.fps_denominator);\n\n if (!drv_ctx.frame_rate.fps_numerator) {\n                        DEBUG_PRINT_ERROR(\"Numerator is zero setting to 30\");\n                        drv_ctx.frame_rate.fps_numerator = 30;\n }\n\n if (drv_ctx.frame_rate.fps_denominator) {\n                        drv_ctx.frame_rate.fps_numerator = (int)\n                            drv_ctx.frame_rate.fps_numerator / drv_ctx.frame_rate.fps_denominator;\n }\n\n                    drv_ctx.frame_rate.fps_denominator = 1;\n                    frm_int = drv_ctx.frame_rate.fps_denominator * 1e6 /\n                        drv_ctx.frame_rate.fps_numerator;\n\n struct v4l2_outputparm oparm;\n /*XXX: we're providing timing info as seconds per frame rather than frames\n                     * per second.*/\n                    oparm.timeperframe.numerator = drv_ctx.frame_rate.fps_denominator;\n                    oparm.timeperframe.denominator = drv_ctx.frame_rate.fps_numerator;\n\n struct v4l2_streamparm sparm;\n                    sparm.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\n                    sparm.parm.output = oparm;\n if (ioctl(drv_ctx.video_driver_fd, VIDIOC_S_PARM, &sparm)) {\n                        DEBUG_PRINT_ERROR(\"Unable to convey fps info to driver, \\\n                                performance might be affected\");\n                        ret = OMX_ErrorHardware;\n }\n                    client_set_fps = true;\n } else {\n                    DEBUG_PRINT_ERROR(\"Frame rate not supported.\");\n                    ret = OMX_ErrorUnsupportedSetting;\n }\n } else {\n                DEBUG_PRINT_HIGH(\"set_config: Disabled client's frame rate\");\n                client_set_fps = false;\n }\n } else {\n            DEBUG_PRINT_ERROR(\" Set_config: Bad Port idx %d\",\n (int)config->nPortIndex);\n            ret = OMX_ErrorBadPortIndex;\n }\n\n return ret;\n } else if ((int)configIndex == (int)OMX_QcomIndexConfigPerfLevel) {\n        OMX_QCOM_VIDEO_CONFIG_PERF_LEVEL *perf =\n (OMX_QCOM_VIDEO_CONFIG_PERF_LEVEL *)configData;\n struct v4l2_control control;\n\n        DEBUG_PRINT_LOW(\"Set perf level: %d\", perf->ePerfLevel);\n\n        control.id = V4L2_CID_MPEG_VIDC_SET_PERF_LEVEL;\n\n switch (perf->ePerfLevel) {\n case OMX_QCOM_PerfLevelNominal:\n                control.value = V4L2_CID_MPEG_VIDC_PERF_LEVEL_NOMINAL;\n break;\n case OMX_QCOM_PerfLevelTurbo:\n                control.value = V4L2_CID_MPEG_VIDC_PERF_LEVEL_TURBO;\n break;\n default:\n                ret = OMX_ErrorUnsupportedSetting;\n break;\n }\n\n if (ret == OMX_ErrorNone) {\n            ret = (ioctl(drv_ctx.video_driver_fd, VIDIOC_S_CTRL, &control) < 0) ?\n                OMX_ErrorUnsupportedSetting : OMX_ErrorNone;\n }\n\n return ret;\n } else if ((int)configIndex == (int)OMX_IndexConfigPriority) {\n        OMX_PARAM_U32TYPE *priority = (OMX_PARAM_U32TYPE *)configData;\n        DEBUG_PRINT_LOW(\"Set_config: priority %d\", priority->nU32);\n\n struct v4l2_control control;\n\n        control.id = V4L2_CID_MPEG_VIDC_VIDEO_PRIORITY;\n if (priority->nU32 == 0)\n            control.value = V4L2_MPEG_VIDC_VIDEO_PRIORITY_REALTIME_ENABLE;\n else\n            control.value = V4L2_MPEG_VIDC_VIDEO_PRIORITY_REALTIME_DISABLE;\n\n if (ioctl(drv_ctx.video_driver_fd, VIDIOC_S_CTRL, &control)) {\n            DEBUG_PRINT_ERROR(\"Failed to set Priority\");\n            ret = OMX_ErrorUnsupportedSetting;\n }\n return ret;\n } else if ((int)configIndex == (int)OMX_IndexConfigOperatingRate) {\n        OMX_PARAM_U32TYPE *rate = (OMX_PARAM_U32TYPE *)configData;\n        DEBUG_PRINT_LOW(\"Set_config: operating-rate %u fps\", rate->nU32 >> 16);\n\n struct v4l2_control control;\n\n        control.id = V4L2_CID_MPEG_VIDC_VIDEO_OPERATING_RATE;\n        control.value = rate->nU32;\n\n if (ioctl(drv_ctx.video_driver_fd, VIDIOC_S_CTRL, &control)) {\n            ret = errno == -EBUSY ? OMX_ErrorInsufficientResources :\n                    OMX_ErrorUnsupportedSetting;\n            DEBUG_PRINT_ERROR(\"Failed to set operating rate %u fps (%s)\",\n                    rate->nU32 >> 16, errno == -EBUSY ? \"HW Overload\" : strerror(errno));\n }\n return ret;\n }\n\n return OMX_ErrorNotImplemented;\n}\n", "target": 1, "idx": 187812}
{"func": "void *nlmsg_reserve(struct nl_msg *n, size_t len, int pad)\n{\n\tvoid *buf = n->nm_nlh;\n        size_t nlmsg_len = n->nm_nlh->nlmsg_len;\n        size_t tlen;\n \n        tlen = pad ? ((len + (pad - 1)) & ~(pad - 1)) : len;\n \n        if ((tlen + nlmsg_len) > n->nm_size)\n\tn->nm_nlh->nlmsg_len += tlen;\n\n\tif (tlen > len)\n\t\tmemset(buf + len, 0, tlen - len);\n\n\tNL_DBG(2, \"msg %p: Reserved %zu (%zu) bytes, pad=%d, nlmsg_len=%d\\n\",\n\t\t  n, tlen, len, pad, n->nm_nlh->nlmsg_len);\n\n\treturn buf;\n}\n", "target": 1, "idx": 178390}
{"func": "static inline RefPtr<DocumentFragment> createFragmentFromSource(const String& sourceString, const String& sourceMIMEType, Document* outputDoc)\n{\n    RefPtr<DocumentFragment> fragment = outputDoc->createDocumentFragment();\n    if (sourceMIMEType == \"text/html\") {\n        RefPtr<HTMLBodyElement> fakeBody = HTMLBodyElement::create(outputDoc);\n        fragment->parseHTML(sourceString, fakeBody.get());\n    } else if (sourceMIMEType == \"text/plain\")\n        fragment->parserAddChild(Text::create(outputDoc, sourceString));\n    else {\n        bool successfulParse = fragment->parseXML(sourceString, 0);\n        if (!successfulParse)\n            return 0;\n    }\n    return fragment;\n}\n", "target": 1, "idx": 183901}
{"func": "void WebBluetoothServiceImpl::DidFinishNavigation(\n    NavigationHandle* navigation_handle) {\n  if (navigation_handle->HasCommitted() &&\n      navigation_handle->GetRenderFrameHost() == render_frame_host_ &&\n      !navigation_handle->IsSameDocument()) {\n    ClearState();\n  }\n}\n", "target": 0, "idx": 150776}
{"func": "error::Error GLES2DecoderPassthroughImpl::DoCopyTexSubImage3D(GLenum target,\n                                                              GLint level,\n                                                              GLint xoffset,\n                                                              GLint yoffset,\n                                                              GLint zoffset,\n                                                              GLint x,\n                                                              GLint y,\n                                                              GLsizei width,\n                                                              GLsizei height) {\n  api()->glCopyTexSubImage3DFn(target, level, xoffset, yoffset, zoffset, x, y,\n                               width, height);\n\n  ExitCommandProcessingEarly();\n\n  return error::kNoError;\n}\n", "target": 0, "idx": 154604}
{"func": "static struct sk_buff *xfrm_state_netlink(struct sk_buff *in_skb,\n\t\t\t\t\t  struct xfrm_state *x, u32 seq)\n {\n \tstruct xfrm_dump_info info;\n \tstruct sk_buff *skb;\n \n \tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n \tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinfo.in_skb = in_skb;\n\tinfo.out_skb = skb;\n \tinfo.nlmsg_seq = seq;\n \tinfo.nlmsg_flags = 0;\n \n\tif (dump_one_state(x, 0, &info)) {\n \t\tkfree_skb(skb);\n\t\treturn NULL;\n \t}\n \n \treturn skb;\n}\n", "target": 1, "idx": 179284}
{"func": "void AppCache::AddEntry(const GURL& url, const AppCacheEntry& entry) {\n   DCHECK(entries_.find(url) == entries_.end());\n   entries_.insert(EntryMap::value_type(url, entry));\n   cache_size_ += entry.response_size();\n }\n", "target": 1, "idx": 186945}
{"func": "  const gfx::Size& GetPreferredSize() {\n    view()->UpdatePreferredSize();\n    return view()->preferred_size_;\n  }\n", "target": 0, "idx": 152575}
{"func": " bool HasCallType(Plugin* plugin,\n                  CallType call_type,\n                 nacl::string call_name,\n                  const char* caller) {\n   uintptr_t id = plugin->browser_interface()->StringToIdentifier(call_name);\n   PLUGIN_PRINTF((\"ScriptableHandle::%s (id=%\"NACL_PRIxPTR\")\\n\",\n                 caller, id));\n  return plugin->HasMethod(id, call_type);\n}\n", "target": 1, "idx": 183642}
{"func": "static int lxc_cgroupfs_get(const char *filename, char *value, size_t len, const char *name, const char *lxcpath)\n{\n\tchar *subsystem = NULL, *p, *path;\n\tint ret = -1;\n\n\tsubsystem = alloca(strlen(filename) + 1);\n\tstrcpy(subsystem, filename);\n\tif ((p = strchr(subsystem, '.')) != NULL)\n\t\t*p = '\\0';\n\n\tpath = lxc_cgroup_get_hierarchy_abs_path(subsystem, name, lxcpath);\n\tif (path) {\n\t\tret = do_cgroup_get(path, filename, value, len);\n\t\tfree(path);\n\t}\n\treturn ret;\n}\n", "target": 0, "idx": 44509}
{"func": "static int decode_map(codebook *s, oggpack_buffer *b, ogg_int32_t *v, int point){\n ogg_uint32_t entry = decode_packed_entry_number(s,b);\n int i;\n if(oggpack_eop(b))return(-1);\n\n /* 1 used by test file 0 */\n\n /* according to decode type */\n switch(s->dec_type){\n case 1:{\n /* packed vector of values */\n int mask=(1<<s->q_bits)-1;\n for(i=0;i<s->dim;i++){\n      v[i]=entry&mask;\n      entry>>=s->q_bits;\n }\n break;\n }\n case 2:{\n /* packed vector of column offsets */\n\n     int mask=(1<<s->q_pack)-1;\n     for(i=0;i<s->dim;i++){\n       if(s->q_bits<=8)\n\tv[i]=((unsigned char *)(s->q_val))[entry&mask];\n       else\n\tv[i]=((ogg_uint16_t *)(s->q_val))[entry&mask];\n       entry>>=s->q_pack;\n     }\n     break;\n }\n case 3:{\n /* offset into array */\n void *ptr=((char *)s->q_val)+entry*s->q_pack;\n\n \n     if(s->q_bits<=8){\n       for(i=0;i<s->dim;i++)\n\tv[i]=((unsigned char *)ptr)[i];\n     }else{\n       for(i=0;i<s->dim;i++)\n\tv[i]=((ogg_uint16_t *)ptr)[i];\n     }\n     break;\n   }\n default:\n return -1;\n }\n\n /* we have the unpacked multiplicands; compute final vals */\n {\n int         shiftM = point-s->q_delp;\n ogg_int32_t add    = point-s->q_minp;\n int         mul    = s->q_del;\n\n if(add>0)\n      add= s->q_min >> add;\n else\n      add= s->q_min << -add;\n if (shiftM<0)\n {\n      mul <<= -shiftM;\n      shiftM = 0;\n }\n    add <<= shiftM;\n\n for(i=0;i<s->dim;i++)\n      v[i]= ((add + v[i] * mul) >> shiftM);\n\n \n     if(s->q_seq)\n       for(i=1;i<s->dim;i++)\n\tv[i]+=v[i-1];\n   }\n \n   return 0;\n}\n", "target": 1, "idx": 188005}
{"func": "gst_asf_demux_process_ext_content_desc (GstASFDemux * demux, guint8 * data,\n    guint64 size)\n{\n  /* Other known (and unused) 'text/unicode' metadata available :\n   *\n   *   WM/Lyrics =\n   *   WM/MediaPrimaryClassID = {D1607DBC-E323-4BE2-86A1-48A42A28441E}\n   *   WMFSDKVersion = 9.00.00.2980\n   *   WMFSDKNeeded = 0.0.0.0000\n   *   WM/UniqueFileIdentifier = AMGa_id=R    15334;AMGp_id=P     5149;AMGt_id=T  2324984\n   *   WM/Publisher = 4AD\n   *   WM/Provider = AMG\n   *   WM/ProviderRating = 8\n   *   WM/ProviderStyle = Rock (similar to WM/Genre)\n   *   WM/GenreID (similar to WM/Genre)\n   *   WM/TrackNumber (same as WM/Track but as a string)\n   *\n   * Other known (and unused) 'non-text' metadata available :\n   *\n   *   WM/EncodingTime\n   *   WM/MCDI\n   *   IsVBR\n   *\n   * We might want to read WM/TrackNumber and use atoi() if we don't have\n   * WM/Track\n   */\n\n  GstTagList *taglist;\n  guint16 blockcount, i;\n  gboolean content3D = FALSE;\n\n  struct\n  {\n    const gchar *interleave_name;\n    GstASF3DMode interleaving_type;\n  } stereoscopic_layout_map[] = {\n    {\n    \"SideBySideRF\", GST_ASF_3D_SIDE_BY_SIDE_HALF_RL}, {\n    \"SideBySideLF\", GST_ASF_3D_SIDE_BY_SIDE_HALF_LR}, {\n    \"OverUnderRT\", GST_ASF_3D_TOP_AND_BOTTOM_HALF_RL}, {\n    \"OverUnderLT\", GST_ASF_3D_TOP_AND_BOTTOM_HALF_LR}, {\n    \"DualStream\", GST_ASF_3D_DUAL_STREAM}\n  };\n  GST_INFO_OBJECT (demux, \"object is an extended content description\");\n\n  taglist = gst_tag_list_new_empty ();\n\n  /* Content Descriptor Count */\n  if (size < 2)\n    goto not_enough_data;\n\n  blockcount = gst_asf_demux_get_uint16 (&data, &size);\n\n  for (i = 1; i <= blockcount; ++i) {\n    const gchar *gst_tag_name;\n    guint16 datatype;\n    guint16 value_len;\n    guint16 name_len;\n    GValue tag_value = { 0, };\n    gsize in, out;\n    gchar *name;\n    gchar *name_utf8 = NULL;\n    gchar *value;\n\n    /* Descriptor */\n    if (!gst_asf_demux_get_string (&name, &name_len, &data, &size))\n      goto not_enough_data;\n\n    if (size < 2) {\n      g_free (name);\n      goto not_enough_data;\n    }\n    /* Descriptor Value Data Type */\n    datatype = gst_asf_demux_get_uint16 (&data, &size);\n\n    /* Descriptor Value (not really a string, but same thing reading-wise) */\n    if (!gst_asf_demux_get_string (&value, &value_len, &data, &size)) {\n      g_free (name);\n      goto not_enough_data;\n    }\n\n    name_utf8 =\n        g_convert (name, name_len, \"UTF-8\", \"UTF-16LE\", &in, &out, NULL);\n\n    if (name_utf8 != NULL) {\n      GST_DEBUG (\"Found tag/metadata %s\", name_utf8);\n\n      gst_tag_name = gst_asf_demux_get_gst_tag_from_tag_name (name_utf8);\n      GST_DEBUG (\"gst_tag_name %s\", GST_STR_NULL (gst_tag_name));\n\n      switch (datatype) {\n        case ASF_DEMUX_DATA_TYPE_UTF16LE_STRING:{\n          gchar *value_utf8;\n\n          value_utf8 = g_convert (value, value_len, \"UTF-8\", \"UTF-16LE\",\n              &in, &out, NULL);\n\n          /* get rid of tags with empty value */\n          if (value_utf8 != NULL && *value_utf8 != '\\0') {\n            GST_DEBUG (\"string value %s\", value_utf8);\n\n            value_utf8[out] = '\\0';\n\n            if (gst_tag_name != NULL) {\n              if (strcmp (gst_tag_name, GST_TAG_DATE_TIME) == 0) {\n                guint year = atoi (value_utf8);\n\n                if (year > 0) {\n                  g_value_init (&tag_value, GST_TYPE_DATE_TIME);\n                  g_value_take_boxed (&tag_value, gst_date_time_new_y (year));\n                }\n              } else if (strcmp (gst_tag_name, GST_TAG_GENRE) == 0) {\n                guint id3v1_genre_id;\n                const gchar *genre_str;\n\n                if (sscanf (value_utf8, \"(%u)\", &id3v1_genre_id) == 1 &&\n                    ((genre_str = gst_tag_id3_genre_get (id3v1_genre_id)))) {\n                  GST_DEBUG (\"Genre: %s -> %s\", value_utf8, genre_str);\n                  g_free (value_utf8);\n                  value_utf8 = g_strdup (genre_str);\n                }\n              } else {\n                GType tag_type;\n\n                /* convert tag from string to other type if required */\n                tag_type = gst_tag_get_type (gst_tag_name);\n                g_value_init (&tag_value, tag_type);\n                if (!gst_value_deserialize (&tag_value, value_utf8)) {\n                  GValue from_val = { 0, };\n\n                  g_value_init (&from_val, G_TYPE_STRING);\n                  g_value_set_string (&from_val, value_utf8);\n                  if (!g_value_transform (&from_val, &tag_value)) {\n                    GST_WARNING_OBJECT (demux,\n                        \"Could not transform string tag to \" \"%s tag type %s\",\n                        gst_tag_name, g_type_name (tag_type));\n                    g_value_unset (&tag_value);\n                  }\n                  g_value_unset (&from_val);\n                }\n              }\n            } else {\n              /* metadata ! */\n              GST_DEBUG (\"Setting metadata\");\n              g_value_init (&tag_value, G_TYPE_STRING);\n              g_value_set_string (&tag_value, value_utf8);\n              /* If we found a stereoscopic marker, look for StereoscopicLayout\n               * metadata */\n              if (content3D) {\n                guint i;\n                if (strncmp (\"StereoscopicLayout\", name_utf8,\n                        strlen (name_utf8)) == 0) {\n                  for (i = 0; i < G_N_ELEMENTS (stereoscopic_layout_map); i++) {\n                    if (g_str_equal (stereoscopic_layout_map[i].interleave_name,\n                            value_utf8)) {\n                      demux->asf_3D_mode =\n                          stereoscopic_layout_map[i].interleaving_type;\n                      GST_INFO (\"find interleave type %u\", demux->asf_3D_mode);\n                    }\n                  }\n                }\n                GST_INFO_OBJECT (demux, \"3d type is %u\", demux->asf_3D_mode);\n              } else {\n                demux->asf_3D_mode = GST_ASF_3D_NONE;\n                GST_INFO_OBJECT (demux, \"None 3d type\");\n              }\n            }\n          } else if (value_utf8 == NULL) {\n            GST_WARNING (\"Failed to convert string value to UTF8, skipping\");\n          } else {\n            GST_DEBUG (\"Skipping empty string value for %s\",\n                GST_STR_NULL (gst_tag_name));\n          }\n          g_free (value_utf8);\n          break;\n        }\n        case ASF_DEMUX_DATA_TYPE_BYTE_ARRAY:{\n          if (gst_tag_name) {\n            if (!g_str_equal (gst_tag_name, GST_TAG_IMAGE)) {\n              GST_FIXME (\"Unhandled byte array tag %s\",\n                  GST_STR_NULL (gst_tag_name));\n              break;\n            } else {\n              asf_demux_parse_picture_tag (taglist, (guint8 *) value,\n                  value_len);\n            }\n          }\n           break;\n         }\n         case ASF_DEMUX_DATA_TYPE_DWORD:{\n          guint uint_val = GST_READ_UINT32_LE (value);\n \n           /* this is the track number */\n           g_value_init (&tag_value, G_TYPE_UINT);\n\n          /* WM/Track counts from 0 */\n          if (!strcmp (name_utf8, \"WM/Track\"))\n            ++uint_val;\n\n          g_value_set_uint (&tag_value, uint_val);\n          break;\n         }\n           /* Detect 3D */\n         case ASF_DEMUX_DATA_TYPE_BOOL:{\n          gboolean bool_val = GST_READ_UINT32_LE (value);\n \n           if (strncmp (\"Stereoscopic\", name_utf8, strlen (name_utf8)) == 0) {\n             if (bool_val) {\n              GST_INFO_OBJECT (demux, \"This is 3D contents\");\n              content3D = TRUE;\n            } else {\n              GST_INFO_OBJECT (demux, \"This is not 3D contenst\");\n              content3D = FALSE;\n            }\n          }\n\n          break;\n        }\n        default:{\n          GST_DEBUG (\"Skipping tag %s of type %d\", gst_tag_name, datatype);\n          break;\n        }\n      }\n\n      if (G_IS_VALUE (&tag_value)) {\n        if (gst_tag_name) {\n          GstTagMergeMode merge_mode = GST_TAG_MERGE_APPEND;\n\n          /* WM/TrackNumber is more reliable than WM/Track, since the latter\n           * is supposed to have a 0 base but is often wrongly written to start\n           * from 1 as well, so prefer WM/TrackNumber when we have it: either\n           * replace the value added earlier from WM/Track or put it first in\n           * the list, so that it will get picked up by _get_uint() */\n          if (strcmp (name_utf8, \"WM/TrackNumber\") == 0)\n            merge_mode = GST_TAG_MERGE_REPLACE;\n\n          gst_tag_list_add_values (taglist, merge_mode, gst_tag_name,\n              &tag_value, NULL);\n        } else {\n          GST_DEBUG (\"Setting global metadata %s\", name_utf8);\n          gst_structure_set_value (demux->global_metadata, name_utf8,\n              &tag_value);\n        }\n\n        g_value_unset (&tag_value);\n      }\n    }\n\n    g_free (name);\n    g_free (value);\n    g_free (name_utf8);\n  }\n\n  gst_asf_demux_add_global_tags (demux, taglist);\n\n  return GST_FLOW_OK;\n\n  /* Errors */\nnot_enough_data:\n  {\n    GST_WARNING (\"Unexpected end of data parsing ext content desc object\");\n    gst_tag_list_unref (taglist);\n    return GST_FLOW_OK;         /* not really fatal */\n  }\n}\n", "target": 1, "idx": 181550}
{"func": "void BluetoothOptionsHandler::GenerateFakeDiscoveredDevice(\n     const std::string& name,\n     const std::string& address,\n     const std::string& icon,\n     bool paired,\n    bool connected) {\n  DictionaryValue device;\n  device.SetString(\"name\", name);\n  device.SetString(\"address\", address);\n  device.SetString(\"icon\", icon);\n  device.SetBoolean(\"paired\", paired);\n  device.SetBoolean(\"connected\", connected);\n  web_ui_->CallJavascriptFunction(\n      \"options.SystemOptions.addBluetoothDevice\", device);\n}\n", "target": 1, "idx": 184600}
{"func": "PHP_METHOD(PharFileInfo, __construct)\n{\n\tchar *fname, *arch, *entry, *error;\n\tsize_t fname_len;\n\tint arch_len, entry_len;\n\tphar_entry_object *entry_obj;\n\tphar_entry_info *entry_info;\n        phar_archive_data *phar_data;\n        zval *zobj = getThis(), arg1;\n \n       if (zend_parse_parameters_throw(ZEND_NUM_ARGS(), \"s\", &fname, &fname_len) == FAILURE) {\n                return;\n        }\n\tentry_obj = (phar_entry_object*)((char*)Z_OBJ_P(zobj) - Z_OBJ_P(zobj)->handlers->offset);\n\n\tif (entry_obj->entry) {\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0, \"Cannot call constructor twice\");\n\t\treturn;\n\t}\n\n\tif (fname_len < 7 || memcmp(fname, \"phar://\", 7) || phar_split_fname(fname, (int)fname_len, &arch, &arch_len, &entry, &entry_len, 2, 0) == FAILURE) {\n\t\tzend_throw_exception_ex(spl_ce_RuntimeException, 0,\n\t\t\t\"'%s' is not a valid phar archive URL (must have at least phar://filename.phar)\", fname);\n\t\treturn;\n\t}\n\n\tif (phar_open_from_filename(arch, arch_len, NULL, 0, REPORT_ERRORS, &phar_data, &error) == FAILURE) {\n\t\tefree(arch);\n\t\tefree(entry);\n\t\tif (error) {\n\t\t\tzend_throw_exception_ex(spl_ce_RuntimeException, 0,\n\t\t\t\t\"Cannot open phar file '%s': %s\", fname, error);\n\t\t\tefree(error);\n\t\t} else {\n\t\t\tzend_throw_exception_ex(spl_ce_RuntimeException, 0,\n\t\t\t\t\"Cannot open phar file '%s'\", fname);\n\t\t}\n\t\treturn;\n\t}\n\n\tif ((entry_info = phar_get_entry_info_dir(phar_data, entry, entry_len, 1, &error, 1)) == NULL) {\n\t\tzend_throw_exception_ex(spl_ce_RuntimeException, 0,\n\t\t\t\"Cannot access phar file entry '%s' in archive '%s'%s%s\", entry, arch, error ? \", \" : \"\", error ? error : \"\");\n\t\tefree(arch);\n\t\tefree(entry);\n\t\treturn;\n\t}\n\n\tefree(arch);\n\tefree(entry);\n\n\tentry_obj->entry = entry_info;\n\n\tZVAL_STRINGL(&arg1, fname, fname_len);\n\n\tzend_call_method_with_1_params(zobj, Z_OBJCE_P(zobj),\n\t\t&spl_ce_SplFileInfo->constructor, \"__construct\", NULL, &arg1);\n\n\tzval_ptr_dtor(&arg1);\n}\n", "target": 1, "idx": 178245}
{"func": " static void gamma_transform_test(png_modifier *pm,\n   PNG_CONST png_byte colour_type, PNG_CONST png_byte bit_depth,\n   PNG_CONST int palette_number,\n   PNG_CONST int interlace_type, PNG_CONST double file_gamma,\n   PNG_CONST double screen_gamma, PNG_CONST png_byte sbit,\n   PNG_CONST int use_input_precision, PNG_CONST int scale16)\n {\n    size_t pos = 0;\n    char name[64];\n\n if (sbit != bit_depth && sbit != 0)\n {\n      pos = safecat(name, sizeof name, pos, \"sbit(\");\n      pos = safecatn(name, sizeof name, pos, sbit);\n      pos = safecat(name, sizeof name, pos, \") \");\n }\n\n else\n      pos = safecat(name, sizeof name, pos, \"gamma \");\n\n if (scale16)\n      pos = safecat(name, sizeof name, pos, \"16to8 \");\n\n   pos = safecatd(name, sizeof name, pos, file_gamma, 3);\n   pos = safecat(name, sizeof name, pos, \"->\");\n   pos = safecatd(name, sizeof name, pos, screen_gamma, 3);\n\n   gamma_test(pm, colour_type, bit_depth, palette_number, interlace_type,\n      file_gamma, screen_gamma, sbit, 0, name, use_input_precision,\n      scale16, pm->test_gamma_expand16, 0 , 0, 0);\n}\n", "target": 1, "idx": 187637}
{"func": "static void prefetch_table(const volatile byte *tab, size_t len)\n {\n   size_t i;\n \n  for (i = 0; i < len; i += 8 * 32)\n     {\n       (void)tab[i + 0 * 32];\n       (void)tab[i + 1 * 32];\n      (void)tab[i + 2 * 32];\n      (void)tab[i + 3 * 32];\n      (void)tab[i + 4 * 32];\n      (void)tab[i + 5 * 32];\n       (void)tab[i + 6 * 32];\n       (void)tab[i + 7 * 32];\n     }\n \n   (void)tab[len - 1];\n }\n", "target": 1, "idx": 183387}
{"func": "static char *eol(char *s)\n{\n    char *p = strend(s);\n    if (p - s > 1 && p[-1] != 10) {\n        *p++ = 10;\n        *p = 0;\n    }\n    return p;\n}\n", "target": 0, "idx": 76640}
{"func": "xmlParsePEReference(xmlParserCtxtPtr ctxt)\n{\n const xmlChar *name;\n    xmlEntityPtr entity = NULL;\n    xmlParserInputPtr input;\n\n if (RAW != '%')\n return;\n    NEXT;\n    name = xmlParseName(ctxt);\n if (name == NULL) {\n\txmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n \"xmlParsePEReference: no name\\n\");\n return;\n }\n if (RAW != ';') {\n\txmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL);\n return;\n }\n\n    NEXT;\n\n /*\n     * Increate the number of entity references parsed\n     */\n    ctxt->nbentities++;\n\n /*\n     * Request the entity from SAX\n     */\n if ((ctxt->sax != NULL) &&\n (ctxt->sax->getParameterEntity != NULL))\n\tentity = ctxt->sax->getParameterEntity(ctxt->userData, name);\n if (ctxt->instate == XML_PARSER_EOF)\n return;\n if (entity == NULL) {\n /*\n\t * [ WFC: Entity Declared ]\n\t * In a document without any DTD, a document with only an\n\t * internal DTD subset which contains no parameter entity\n\t * references, or a document with \"standalone='yes'\", ...\n\t * ... The declaration of a parameter entity must precede\n\t * any reference to it...\n\t */\n if ((ctxt->standalone == 1) ||\n ((ctxt->hasExternalSubset == 0) &&\n (ctxt->hasPErefs == 0))) {\n\t    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,\n \"PEReference: %%%s; not found\\n\",\n\t\t\t      name);\n } else {\n /*\n\t     * [ VC: Entity Declared ]\n\t     * In a document with an external subset or external\n\t     * parameter entities with \"standalone='no'\", ...\n\t     * ... The declaration of a parameter entity must\n\t     * precede any reference to it...\n\t     */\n\t    xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,\n \"PEReference: %%%s; not found\\n\",\n\t\t\t  name, NULL);\n\t    ctxt->valid = 0;\n }\n\txmlParserEntityCheck(ctxt, 0, NULL, 0);\n } else {\n /*\n\t * Internal checking in case the entity quest barfed\n\t */\n if ((entity->etype != XML_INTERNAL_PARAMETER_ENTITY) &&\n (entity->etype != XML_EXTERNAL_PARAMETER_ENTITY)) {\n\t    xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,\n \"Internal: %%%s; is not a parameter entity\\n\",\n\t\t\t  name, NULL);\n } else if (ctxt->input->free != deallocblankswrapper) {\n\t    input = xmlNewBlanksWrapperInputStream(ctxt, entity);\n\n \t    if (xmlPushInput(ctxt, input) < 0)\n \t\treturn;\n \t} else {\n \t    /*\n \t     * TODO !!!\n \t     * handle the extra spaces added before and after\n\t     * c.f. http://www.w3.org/TR/REC-xml#as-PE\n\t     */\n\t    input = xmlNewEntityInputStream(ctxt, entity);\n if (xmlPushInput(ctxt, input) < 0)\n return;\n if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&\n (CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) &&\n (IS_BLANK_CH(NXT(5)))) {\n\t\txmlParseTextDecl(ctxt);\n if (ctxt->errNo ==\n\t\t    XML_ERR_UNSUPPORTED_ENCODING) {\n /*\n\t\t     * The XML REC instructs us to stop parsing\n\t\t     * right here\n\t\t     */\n\t\t    xmlHaltParser(ctxt);\n return;\n }\n }\n }\n }\n    ctxt->hasPErefs = 1;\n}\n", "target": 1, "idx": 188142}
{"func": "static struct ucma_multicast* ucma_alloc_multicast(struct ucma_context *ctx)\n{\n\tstruct ucma_multicast *mc;\n\n\tmc = kzalloc(sizeof(*mc), GFP_KERNEL);\n\tif (!mc)\n \t\treturn NULL;\n \n \tmutex_lock(&mut);\n\tmc->id = idr_alloc(&multicast_idr, mc, 0, 0, GFP_KERNEL);\n \tmutex_unlock(&mut);\n \tif (mc->id < 0)\n \t\tgoto error;\n\n\tmc->ctx = ctx;\n\tlist_add_tail(&mc->list, &ctx->mc_list);\n\treturn mc;\n\nerror:\n\tkfree(mc);\n\treturn NULL;\n}\n", "target": 1, "idx": 182281}
{"func": "bool_t auth_gssapi_unwrap_data(\n     OM_uint32 *major,\n     OM_uint32 *minor,\n     gss_ctx_id_t context,\n     uint32_t seq_num,\n     XDR *in_xdrs,\n     bool_t (*xdr_func)(),\n     caddr_t xdr_ptr)\n{\n     gss_buffer_desc in_buf, out_buf;\n     XDR temp_xdrs;\n     uint32_t verf_seq_num;\n     int conf, qop;\n     unsigned int length;\n\n     PRINTF((\"gssapi_unwrap_data: starting\\n\"));\n\n     *major = GSS_S_COMPLETE;\n     *minor = 0; /* assumption */\n\n     in_buf.value = NULL;\n     out_buf.value = NULL;\n     if (! xdr_bytes(in_xdrs, (char **) &in_buf.value,\n\t\t     &length, (unsigned int) -1)) {\n\t PRINTF((\"gssapi_unwrap_data: deserializing encrypted data failed\\n\"));\n\t temp_xdrs.x_op = XDR_FREE;\n\t (void)xdr_bytes(&temp_xdrs, (char **) &in_buf.value, &length,\n\t\t\t (unsigned int) -1);\n\t return FALSE;\n     }\n     in_buf.length = length;\n\n     *major = gss_unseal(minor, context, &in_buf, &out_buf, &conf,\n\t\t\t &qop);\n     free(in_buf.value);\n     if (*major != GSS_S_COMPLETE)\n\t  return FALSE;\n\n     PRINTF((\"gssapi_unwrap_data: %llu bytes data, %llu bytes sealed\\n\",\n\t     (unsigned long long)out_buf.length,\n\t     (unsigned long long)in_buf.length));\n\n     xdrmem_create(&temp_xdrs, out_buf.value, out_buf.length, XDR_DECODE);\n\n     /* deserialize the sequence number */\n     if (! xdr_u_int32(&temp_xdrs, &verf_seq_num)) {\n\t  PRINTF((\"gssapi_unwrap_data: deserializing verf_seq_num failed\\n\"));\n\t  gss_release_buffer(minor, &out_buf);\n\t  XDR_DESTROY(&temp_xdrs);\n\t  return FALSE;\n     }\n     if (verf_seq_num != seq_num) {\n\t  PRINTF((\"gssapi_unwrap_data: seq %d specified, read %d\\n\",\n\t\t  seq_num, verf_seq_num));\n\t  gss_release_buffer(minor, &out_buf);\n\t  XDR_DESTROY(&temp_xdrs);\n\t  return FALSE;\n     }\n     PRINTF((\"gssapi_unwrap_data: unwrap seq_num %d okay\\n\", verf_seq_num));\n\n     /* deserialize the arguments into xdr_ptr */\n      if (! (*xdr_func)(&temp_xdrs, xdr_ptr)) {\n \t  PRINTF((\"gssapi_unwrap_data: deserializing arguments failed\\n\"));\n \t  gss_release_buffer(minor, &out_buf);\n\t  xdr_free(xdr_func, xdr_ptr);\n \t  XDR_DESTROY(&temp_xdrs);\n \t  return FALSE;\n      }\n\n     PRINTF((\"gssapi_unwrap_data: succeeding\\n\\n\"));\n\n     gss_release_buffer(minor, &out_buf);\n     XDR_DESTROY(&temp_xdrs);\n     return TRUE;\n}\n", "target": 1, "idx": 179964}
{"func": "ui::Layer* OverlayWindowViews::GetCloseControlsLayer() {\n  return close_controls_view_->layer();\n}\n", "target": 0, "idx": 156017}
{"func": "static float *get_window(vorb *f, int len)\n{\n    len <<= 1;\n    if (len == f->blocksize_0) return f->window[0];\n    if (len == f->blocksize_1) return f->window[1];\n   assert(0);\n    return NULL;\n }\n", "target": 1, "idx": 182787}
{"func": "  void AddExpectationsForSimulatedAttrib0(\n      GLsizei num_vertices, GLuint buffer_id) {\n     EXPECT_CALL(*gl_, BindBuffer(GL_ARRAY_BUFFER, kServiceAttrib0BufferId))\n         .Times(1)\n         .RetiresOnSaturation();\n    EXPECT_CALL(*gl_, BufferData(GL_ARRAY_BUFFER,\n                                 num_vertices * sizeof(GLfloat) * 4,\n                                  _, GL_DYNAMIC_DRAW))\n         .Times(1)\n         .RetiresOnSaturation();\n    EXPECT_CALL(*gl_, BufferSubData(\n        GL_ARRAY_BUFFER, 0, num_vertices * sizeof(GLfloat) * 4, _))\n        .Times(1)\n        .RetiresOnSaturation();\n    EXPECT_CALL(*gl_, VertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, 0, NULL))\n        .Times(1)\n        .RetiresOnSaturation();\n    EXPECT_CALL(*gl_, BindBuffer(GL_ARRAY_BUFFER, 0))\n        .Times(1)\n        .RetiresOnSaturation();\n    EXPECT_CALL(*gl_, VertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, 0, NULL))\n        .Times(1)\n        .RetiresOnSaturation();\n    EXPECT_CALL(*gl_, BindBuffer(GL_ARRAY_BUFFER, buffer_id))\n        .Times(1)\n        .RetiresOnSaturation();\n   }\n", "target": 1, "idx": 183791}
{"func": "LosslessReduceDepthOK(Image *image,ExceptionInfo *exception)\n{\n    /* Reduce bit depth if it can be reduced losslessly from 16+ to 8.\n     *\n     * This is true if the high byte and the next highest byte of\n     * each sample of the image, the colormap, and the background color\n     * are equal to each other.  We check this by seeing if the samples\n     * are unchanged when we scale them down to 8 and back up to Quantum.\n     *\n     * We don't use the method GetImageDepth() because it doesn't check\n     * background and doesn't handle PseudoClass specially.\n     */\n\n#define QuantumToCharToQuantumEqQuantum(quantum) \\\n ((ScaleCharToQuantum((unsigned char) ScaleQuantumToChar(quantum))) == quantum)\n\n    MagickBooleanType\n      ok_to_reduce=MagickFalse;\n\n    if (image->depth >= 16)\n      {\n\n        const Quantum\n          *p;\n\n        ok_to_reduce=\n           QuantumToCharToQuantumEqQuantum(image->background_color.red) &&\n           QuantumToCharToQuantumEqQuantum(image->background_color.green) &&\n           QuantumToCharToQuantumEqQuantum(image->background_color.blue) ?\n           MagickTrue : MagickFalse;\n\n        if (ok_to_reduce != MagickFalse && image->storage_class == PseudoClass)\n          {\n            int indx;\n\n            for (indx=0; indx < (ssize_t) image->colors; indx++)\n              {\n                ok_to_reduce=(\n                   QuantumToCharToQuantumEqQuantum(\n                   image->colormap[indx].red) &&\n                   QuantumToCharToQuantumEqQuantum(\n                   image->colormap[indx].green) &&\n                   QuantumToCharToQuantumEqQuantum(\n                   image->colormap[indx].blue)) ?\n                   MagickTrue : MagickFalse;\n\n                if (ok_to_reduce == MagickFalse)\n                   break;\n              }\n          }\n\n        if ((ok_to_reduce != MagickFalse) &&\n            (image->storage_class != PseudoClass))\n          {\n            ssize_t\n              y;\n\n            register ssize_t\n              x;\n\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n\n              if (p == (const Quantum *) NULL)\n                {\n                  ok_to_reduce = MagickFalse;\n                  break;\n                }\n\n              for (x=(ssize_t) image->columns-1; x >= 0; x--)\n              {\n                ok_to_reduce=\n                   QuantumToCharToQuantumEqQuantum(GetPixelRed(image,p)) &&\n                   QuantumToCharToQuantumEqQuantum(GetPixelGreen(image,p)) &&\n                   QuantumToCharToQuantumEqQuantum(GetPixelBlue(image,p)) ?\n                   MagickTrue : MagickFalse;\n\n                if (ok_to_reduce == MagickFalse)\n                  break;\n\n                p+=GetPixelChannels(image);\n              }\n              if (x >= 0)\n                break;\n            }\n          }\n\n        if (ok_to_reduce != MagickFalse)\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    OK to reduce PNG bit depth to 8 without loss of info\");\n          }\n        else\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Not OK to reduce PNG bit depth to 8 without losing info\");\n          }\n      }\n\n    return ok_to_reduce;\n}\n", "target": 0, "idx": 63296}
{"func": "String HTMLFormControlElement::nameForAutofill() const\n{\n    String fullName = name();\n    String trimmedName = fullName.stripWhiteSpace();\n    if (!trimmedName.isEmpty())\n        return trimmedName;\n    fullName = getIdAttribute();\n    trimmedName = fullName.stripWhiteSpace();\n    return trimmedName;\n}\n", "target": 0, "idx": 122277}
{"func": "static int xfrm_do_migrate(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t   struct nlattr **attrs)\n{\n\tstruct xfrm_userpolicy_id *pi = nlmsg_data(nlh);\n\tstruct xfrm_migrate m[XFRM_MAX_DEPTH];\n\tstruct xfrm_kmaddress km, *kmp;\n\tu8 type;\n\tint err;\n\tint n = 0;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_encap_tmpl  *encap = NULL;\n\n\tif (attrs[XFRMA_MIGRATE] == NULL)\n\t\treturn -EINVAL;\n\n\tkmp = attrs[XFRMA_KMADDRESS] ? &km : NULL;\n\n\terr = copy_from_user_policy_type(&type, attrs);\n\tif (err)\n\t\treturn err;\n\n\terr = copy_from_user_migrate((struct xfrm_migrate *)m, kmp, attrs, &n);\n\tif (err)\n\t\treturn err;\n\n\tif (!n)\n\t\treturn 0;\n\n\tif (attrs[XFRMA_ENCAP]) {\n\t\tencap = kmemdup(nla_data(attrs[XFRMA_ENCAP]),\n\t\t\t\tsizeof(*encap), GFP_KERNEL);\n\t\tif (!encap)\n\t\t\treturn 0;\n\t}\n\n\terr = xfrm_migrate(&pi->sel, pi->dir, type, m, n, kmp, net, encap);\n\n\tkfree(encap);\n\n\treturn err;\n}\n", "target": 0, "idx": 59358}
{"func": "pdf14_get_num_spots(gx_device * dev)\n{\n    cmm_dev_profile_t *dev_profile;\n    cmm_profile_t *icc_profile;\n    gsicc_rendering_param_t render_cond;\n\n    dev_proc(dev, get_profile)(dev, &dev_profile);\n    gsicc_extract_profile(GS_UNKNOWN_TAG, dev_profile, &icc_profile,\n        &render_cond);\n    return dev->color_info.num_components - icc_profile->num_comps;\n}\n", "target": 0, "idx": 13317}
{"func": "static inline int is_revectored(int nr, struct revectored_struct *bitmap)\n{\n\t__asm__ __volatile__(\"btl %2,%1\\n\\tsbbl %0,%0\"\n\t\t:\"=r\" (nr)\n\t\t:\"m\" (*bitmap), \"r\" (nr));\n\treturn nr;\n}\n", "target": 0, "idx": 20966}
{"func": "ppp_send_frame(struct ppp *ppp, struct sk_buff *skb)\n{\n\tint proto = PPP_PROTO(skb);\n\tstruct sk_buff *new_skb;\n\tint len;\n\tunsigned char *cp;\n\n\tif (proto < 0x8000) {\n#ifdef CONFIG_PPP_FILTER\n\t\t/* check if we should pass this packet */\n\t\t/* the filter instructions are constructed assuming\n\t\t   a four-byte PPP header on each packet */\n\t\t*skb_push(skb, 2) = 1;\n\t\tif (ppp->pass_filter &&\n\t\t    BPF_PROG_RUN(ppp->pass_filter, skb) == 0) {\n\t\t\tif (ppp->debug & 1)\n\t\t\t\tnetdev_printk(KERN_DEBUG, ppp->dev,\n\t\t\t\t\t      \"PPP: outbound frame \"\n\t\t\t\t\t      \"not passed\\n\");\n\t\t\tkfree_skb(skb);\n\t\t\treturn;\n\t\t}\n\t\t/* if this packet passes the active filter, record the time */\n\t\tif (!(ppp->active_filter &&\n\t\t      BPF_PROG_RUN(ppp->active_filter, skb) == 0))\n\t\t\tppp->last_xmit = jiffies;\n\t\tskb_pull(skb, 2);\n#else\n\t\t/* for data packets, record the time */\n\t\tppp->last_xmit = jiffies;\n#endif /* CONFIG_PPP_FILTER */\n\t}\n\n\t++ppp->stats64.tx_packets;\n\tppp->stats64.tx_bytes += skb->len - 2;\n\n\tswitch (proto) {\n\tcase PPP_IP:\n\t\tif (!ppp->vj || (ppp->flags & SC_COMP_TCP) == 0)\n\t\t\tbreak;\n\t\t/* try to do VJ TCP header compression */\n\t\tnew_skb = alloc_skb(skb->len + ppp->dev->hard_header_len - 2,\n\t\t\t\t    GFP_ATOMIC);\n\t\tif (!new_skb) {\n\t\t\tnetdev_err(ppp->dev, \"PPP: no memory (VJ comp pkt)\\n\");\n\t\t\tgoto drop;\n\t\t}\n\t\tskb_reserve(new_skb, ppp->dev->hard_header_len - 2);\n\t\tcp = skb->data + 2;\n\t\tlen = slhc_compress(ppp->vj, cp, skb->len - 2,\n\t\t\t\t    new_skb->data + 2, &cp,\n\t\t\t\t    !(ppp->flags & SC_NO_TCP_CCID));\n\t\tif (cp == skb->data + 2) {\n\t\t\t/* didn't compress */\n\t\t\tconsume_skb(new_skb);\n\t\t} else {\n\t\t\tif (cp[0] & SL_TYPE_COMPRESSED_TCP) {\n\t\t\t\tproto = PPP_VJC_COMP;\n\t\t\t\tcp[0] &= ~SL_TYPE_COMPRESSED_TCP;\n\t\t\t} else {\n\t\t\t\tproto = PPP_VJC_UNCOMP;\n\t\t\t\tcp[0] = skb->data[2];\n\t\t\t}\n\t\t\tconsume_skb(skb);\n\t\t\tskb = new_skb;\n\t\t\tcp = skb_put(skb, len + 2);\n\t\t\tcp[0] = 0;\n\t\t\tcp[1] = proto;\n\t\t}\n\t\tbreak;\n\n\tcase PPP_CCP:\n\t\t/* peek at outbound CCP frames */\n\t\tppp_ccp_peek(ppp, skb, 0);\n\t\tbreak;\n\t}\n\n\t/* try to do packet compression */\n\tif ((ppp->xstate & SC_COMP_RUN) && ppp->xc_state &&\n\t    proto != PPP_LCP && proto != PPP_CCP) {\n\t\tif (!(ppp->flags & SC_CCP_UP) && (ppp->flags & SC_MUST_COMP)) {\n\t\t\tif (net_ratelimit())\n\t\t\t\tnetdev_err(ppp->dev,\n\t\t\t\t\t   \"ppp: compression required but \"\n\t\t\t\t\t   \"down - pkt dropped.\\n\");\n\t\t\tgoto drop;\n\t\t}\n\t\tskb = pad_compress_skb(ppp, skb);\n\t\tif (!skb)\n\t\t\tgoto drop;\n\t}\n\n\t/*\n\t * If we are waiting for traffic (demand dialling),\n\t * queue it up for pppd to receive.\n\t */\n\tif (ppp->flags & SC_LOOP_TRAFFIC) {\n\t\tif (ppp->file.rq.qlen > PPP_MAX_RQLEN)\n\t\t\tgoto drop;\n\t\tskb_queue_tail(&ppp->file.rq, skb);\n\t\twake_up_interruptible(&ppp->file.rwait);\n\t\treturn;\n\t}\n\n\tppp->xmit_pending = skb;\n\tppp_push(ppp);\n\treturn;\n\n drop:\n\tkfree_skb(skb);\n\t++ppp->dev->stats.tx_errors;\n}\n", "target": 0, "idx": 52653}
{"func": " void TextTrackCue::setStartTime(double value) {\n  if (start_time_ == value || value < 0)\n     return;\n \n   CueWillChange();\n  start_time_ = value;\n  CueDidChange(kCueMutationAffectsOrder);\n }\n", "target": 1, "idx": 185647}
{"func": "static MagickBooleanType WriteCALSImage(const ImageInfo *image_info,\n  Image *image)\n{\n  char\n    header[MaxTextExtent];\n\n  Image\n    *group4_image;\n\n  ImageInfo\n    *write_info;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  size_t\n    density,\n    length,\n    orient_x,\n    orient_y;\n\n  ssize_t\n    count;\n\n  unsigned char\n    *group4;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(status);\n  /*\n    Create standard CALS header.\n  */\n  count=WriteCALSRecord(image,\"srcdocid: NONE\");\n  (void) count;\n  count=WriteCALSRecord(image,\"dstdocid: NONE\");\n  count=WriteCALSRecord(image,\"txtfilid: NONE\");\n  count=WriteCALSRecord(image,\"figid: NONE\");\n  count=WriteCALSRecord(image,\"srcgph: NONE\");\n  count=WriteCALSRecord(image,\"doccls: NONE\");\n  count=WriteCALSRecord(image,\"rtype: 1\");\n  orient_x=0;\n  orient_y=0;\n  switch (image->orientation)\n  {\n    case TopRightOrientation:\n    {\n      orient_x=180;\n      orient_y=270;\n      break;\n    }\n    case BottomRightOrientation:\n    {\n      orient_x=180;\n      orient_y=90;\n      break;\n    }\n    case BottomLeftOrientation:\n    {\n      orient_y=90;\n      break;\n    }\n    case LeftTopOrientation:\n    {\n      orient_x=270;\n      break;\n    }\n    case RightTopOrientation:\n    {\n      orient_x=270;\n      orient_y=180;\n      break;\n    }\n    case RightBottomOrientation:\n    {\n      orient_x=90;\n      orient_y=180;\n      break;\n    }\n    case LeftBottomOrientation:\n    {\n      orient_x=90;\n      break;\n    }\n    default:\n    {\n      orient_y=270;\n      break;\n    }\n  }\n  (void) FormatLocaleString(header,sizeof(header),\"rorient: %03ld,%03ld\",\n    (long) orient_x,(long) orient_y);\n  count=WriteCALSRecord(image,header);\n  (void) FormatLocaleString(header,sizeof(header),\"rpelcnt: %06lu,%06lu\",\n    (unsigned long) image->columns,(unsigned long) image->rows);\n  count=WriteCALSRecord(image,header);\n  density=200;\n  if (image_info->density != (char *) NULL)\n    {\n      GeometryInfo\n        geometry_info;\n\n      (void) ParseGeometry(image_info->density,&geometry_info);\n      density=(size_t) floor(geometry_info.rho+0.5);\n    }\n  (void) FormatLocaleString(header,sizeof(header),\"rdensty: %04lu\",\n    (unsigned long) density);\n  count=WriteCALSRecord(image,header);\n  count=WriteCALSRecord(image,\"notes: NONE\");\n  (void) ResetMagickMemory(header,' ',128);\n  for (i=0; i < 5; i++)\n    (void) WriteBlob(image,128,(unsigned char *) header);\n  /*\n    Write CALS pixels.\n  */\n  write_info=CloneImageInfo(image_info);\n  (void) CopyMagickString(write_info->filename,\"GROUP4:\",MaxTextExtent);\n  (void) CopyMagickString(write_info->magick,\"GROUP4\",MaxTextExtent);\n   group4_image=CloneImage(image,0,0,MagickTrue,&image->exception);\n   if (group4_image == (Image *) NULL)\n     {\n       (void) CloseBlob(image);\n       return(MagickFalse);\n     }\n  group4=(unsigned char *) ImageToBlob(write_info,group4_image,&length,\n    &image->exception);\n   group4_image=DestroyImage(group4_image);\n   if (group4 == (unsigned char *) NULL)\n     {\n       (void) CloseBlob(image);\n       return(MagickFalse);\n     }\n  write_info=DestroyImageInfo(write_info);\n  if (WriteBlob(image,length,group4) != (ssize_t) length)\n    status=MagickFalse;\n  group4=(unsigned char *) RelinquishMagickMemory(group4);\n  (void) CloseBlob(image);\n  return(status);\n}\n", "target": 1, "idx": 181139}
{"func": "http_splitline(struct worker *w, int fd, struct http *hp,\n    const struct http_conn *htc, int h1, int h2, int h3)\n{\n\tchar *p, *q;\n\n\tCHECK_OBJ_NOTNULL(htc, HTTP_CONN_MAGIC);\n\tCHECK_OBJ_NOTNULL(hp, HTTP_MAGIC);\n\n\t/* XXX: Assert a NUL at rx.e ? */\n\tTcheck(htc->rxbuf);\n\n\t/* Skip leading LWS */\n\tfor (p = htc->rxbuf.b ; vct_islws(*p); p++)\n\t\tcontinue;\n\n\t/* First field cannot contain SP, CRLF or CTL */\n\tq = p;\n\tfor (; !vct_issp(*p); p++) {\n\t\tif (vct_isctl(*p))\n\t\t\treturn (400);\n\t}\n\thp->hd[h1].b = q;\n\thp->hd[h1].e = p;\n\n\t/* Skip SP */\n\tfor (; vct_issp(*p); p++) {\n\t\tif (vct_isctl(*p))\n\t\t\treturn (400);\n\t}\n\n\t/* Second field cannot contain LWS or CTL */\n\tq = p;\n\tfor (; !vct_islws(*p); p++) {\n\t\tif (vct_isctl(*p))\n\t\t\treturn (400);\n\t}\n\thp->hd[h2].b = q;\n\thp->hd[h2].e = p;\n\n\tif (!Tlen(hp->hd[h2]))\n\t\treturn (400);\n\n\t/* Skip SP */\n\tfor (; vct_issp(*p); p++) {\n\t\tif (vct_isctl(*p))\n\t\t\treturn (400);\n\t}\n \n \t/* Third field is optional and cannot contain CTL */\n \tq = p;\n\tif (!vct_iscrlf(*p)) {\n\t\tfor (; !vct_iscrlf(*p); p++)\n \t\t\tif (!vct_issep(*p) && vct_isctl(*p))\n \t\t\t\treturn (400);\n \t}\n\thp->hd[h3].b = q;\n\thp->hd[h3].e = p;\n\n\t/* Skip CRLF */\n\tp += vct_skipcrlf(p);\n\n\t*hp->hd[h1].e = '\\0';\n\tWSLH(w, fd, hp, h1);\n\n\t*hp->hd[h2].e = '\\0';\n\tWSLH(w, fd, hp, h2);\n\n\tif (hp->hd[h3].e != NULL) {\n\t\t*hp->hd[h3].e = '\\0';\n\t\tWSLH(w, fd, hp, h3);\n\t}\n\n\treturn (http_dissect_hdrs(w, hp, fd, p, htc));\n}\n", "target": 1, "idx": 183170}
{"func": " static inline size_t GetPSDRowSize(Image *image)\n {\n   if (image->depth == 1)\n    return((image->columns+7)/8);\n   else\n     return(image->columns*GetPSDPacketSize(image));\n }\n", "target": 1, "idx": 181976}
{"func": "static inline u64 hash_name(const char *name)\n{\n\tunsigned long a, b, adata, bdata, mask, hash, len;\n\tconst struct word_at_a_time constants = WORD_AT_A_TIME_CONSTANTS;\n\n\thash = a = 0;\n\tlen = -sizeof(unsigned long);\n\tdo {\n\t\thash = (hash + a) * 9;\n\t\tlen += sizeof(unsigned long);\n\t\ta = load_unaligned_zeropad(name+len);\n\t\tb = a ^ REPEAT_BYTE('/');\n\t} while (!(has_zero(a, &adata, &constants) | has_zero(b, &bdata, &constants)));\n\n\tadata = prep_zero_mask(a, adata, &constants);\n\tbdata = prep_zero_mask(b, bdata, &constants);\n\n\tmask = create_zero_mask(adata | bdata);\n\n\thash += a & zero_bytemask(mask);\n\tlen += find_zero(mask);\n\treturn hashlen_create(fold_hash(hash), len);\n}\n", "target": 0, "idx": 42326}
{"func": "static inline void uipc_wakeup_locked(void)\n\n {\n     char sig_on = 1;\n     BTIF_TRACE_EVENT(\"UIPC SEND WAKE UP\");\n    send(uipc_main.signal_fds[1], &sig_on, sizeof(sig_on), 0);\n }\n", "target": 1, "idx": 187521}
{"func": "EntrySync* WorkerGlobalScopeFileSystem::webkitResolveLocalFileSystemSyncURL(WorkerGlobalScope& worker, const String& url, ExceptionState& exceptionState)\n{\n    KURL completedURL = worker.completeURL(url);\n    ExecutionContext* secureContext = worker.executionContext();\n    if (!secureContext->securityOrigin()->canAccessFileSystem() || !secureContext->securityOrigin()->canRequest(completedURL)) {\n        exceptionState.throwSecurityError(FileError::securityErrorMessage);\n        return 0;\n    }\n\n    if (!completedURL.isValid()) {\n        exceptionState.throwDOMException(EncodingError, \"the URL '\" + url + \"' is invalid.\");\n         return 0;\n     }\n \n    RefPtr<EntrySyncCallbackHelper> resolveURLHelper = EntrySyncCallbackHelper::create();\n     OwnPtr<AsyncFileSystemCallbacks> callbacks = ResolveURICallbacks::create(resolveURLHelper->successCallback(), resolveURLHelper->errorCallback(), &worker);\n     callbacks->setShouldBlockUntilCompletion(true);\n \n    LocalFileSystem::from(worker)->resolveURL(&worker, completedURL, callbacks.release());\n\n    return resolveURLHelper->getResult(exceptionState);\n}\n", "target": 1, "idx": 185131}
{"func": "static void *listen_fn_(UNUSED_ATTR void *context) {\n\n  prctl(PR_SET_NAME, (unsigned long)LISTEN_THREAD_NAME_, 0, 0, 0);\n\n  listen_socket_ = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n if (listen_socket_ == -1) {\n    LOG_ERROR(\"%s socket creation failed: %s\", __func__, strerror(errno));\n goto cleanup;\n }\n\n int enable = 1;\n if (setsockopt(listen_socket_, SOL_SOCKET, SO_REUSEADDR, &enable, sizeof(enable)) == -1) {\n    LOG_ERROR(\"%s unable to set SO_REUSEADDR: %s\", __func__, strerror(errno));\n goto cleanup;\n }\n\n struct sockaddr_in addr;\n  addr.sin_family = AF_INET;\n  addr.sin_addr.s_addr = htonl(LOCALHOST_);\n  addr.sin_port = htons(LISTEN_PORT_);\n if (bind(listen_socket_, (struct sockaddr *)&addr, sizeof(addr)) == -1) {\n    LOG_ERROR(\"%s unable to bind listen socket: %s\", __func__, strerror(errno));\n goto cleanup;\n }\n\n if (listen(listen_socket_, 10) == -1) {\n    LOG_ERROR(\"%s unable to listen: %s\", __func__, strerror(errno));\n goto cleanup;\n\n   }\n \n   for (;;) {\n    int client_socket = accept(listen_socket_, NULL, NULL);\n     if (client_socket == -1) {\n       if (errno == EINVAL || errno == EBADF) {\n         break;\n }\n      LOG_WARN(\"%s error accepting socket: %s\", __func__, strerror(errno));\n continue;\n }\n\n /* When a new client connects, we have to send the btsnoop file header. This allows\n       a decoder to treat the session as a new, valid btsnoop file. */\n\n     pthread_mutex_lock(&client_socket_lock_);\n     safe_close_(&client_socket_);\n     client_socket_ = client_socket;\n    send(client_socket_, \"btsnoop\\0\\0\\0\\0\\1\\0\\0\\x3\\xea\", 16, 0);\n     pthread_mutex_unlock(&client_socket_lock_);\n   }\n \ncleanup:\n  safe_close_(&listen_socket_);\n return NULL;\n}\n", "target": 1, "idx": 187497}
{"func": "void Layer::RemoveAnimation(int animation_id) {\n  layer_animation_controller_->RemoveAnimation(animation_id);\n  SetNeedsCommit();\n}\n", "target": 0, "idx": 120132}
{"func": "iNewEntry(struct rx_call *call, char aname[], afs_int32 aid, afs_int32 oid,\n\t  afs_int32 *cid)\n{\n    /* used primarily for conversion - not intended to be used as usual means\n     * of entering people into the database. */\n    struct ubik_trans *tt;\n    afs_int32 code;\n    afs_int32 gflag = 0;\n    int admin;\n\n    stolower(aname);\n    code = Initdb();\n    if (code != PRSUCCESS)\n\treturn code;\n    code = ubik_BeginTrans(dbase, UBIK_WRITETRANS, &tt);\n    if (code)\n\treturn code;\n    code = ubik_SetLock(tt, 1, 1, LOCKWRITE);\n    if (code)\n\tABORT_WITH(tt, code);\n    code = read_DbHeader(tt);\n    if (code)\n\tABORT_WITH(tt, code);\n\n    code = WhoIsThis(call, tt, cid);\n    if (code)\n\tABORT_WITH(tt, PRPERM);\n    admin = IsAMemberOf(tt, *cid, SYSADMINID);\n\n    /* first verify the id is good */\n    if (aid == 0)\n\tABORT_WITH(tt, PRPERM);\n    if (aid < 0) {\n\tgflag |= PRGRP;\n\t/* only sysadmin can reuse a group id */\n\tif (!admin && !pr_noAuth && (aid != ntohl(cheader.maxGroup) - 1))\n\t    ABORT_WITH(tt, PRPERM);\n    }\n    if (FindByID(tt, aid))\n\tABORT_WITH(tt, PRIDEXIST);\n\n    /* check a few other things */\n    if (!CreateOK(tt, *cid, oid, gflag, admin))\n\tABORT_WITH(tt, PRPERM);\n\n    code = CreateEntry(tt, aname, &aid, 1, gflag, oid, *cid);\n    if (code != PRSUCCESS)\n\tABORT_WITH(tt, code);\n\n    /* finally, commit transaction */\n    code = ubik_EndTrans(tt);\n    if (code)\n\treturn code;\n    return PRSUCCESS;\n}\n", "target": 0, "idx": 12538}
{"func": "static int php_var_unserialize_internal(UNSERIALIZE_PARAMETER)\n{\n\tconst unsigned char *cursor, *limit, *marker, *start;\n\tzval *rval_ref;\n\n\tlimit = max;\n\tcursor = *p;\n\n\tif (YYCURSOR >= YYLIMIT) {\n\t\treturn 0;\n\t}\n\n\tif (var_hash && (*p)[0] != 'R') {\n\t\tvar_push(var_hash, rval);\n\t}\n\n \tstart = cursor;\n \n \n#line 585 \"ext/standard/var_unserializer.c\"\n {\n \tYYCTYPE yych;\n \tstatic const unsigned char yybm[] = {\n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t128, 128, 128, 128, 128, 128, 128, 128, \n\t\t128, 128,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t};\n\tif ((YYLIMIT - YYCURSOR) < 7) YYFILL(7);\n \tyych = *YYCURSOR;\n \tswitch (yych) {\n \tcase 'C':\n\tcase 'O':\tgoto yy13;\n \tcase 'N':\tgoto yy5;\n\tcase 'R':\tgoto yy2;\n\tcase 'S':\tgoto yy10;\n\tcase 'a':\tgoto yy11;\n\tcase 'b':\tgoto yy6;\n\tcase 'd':\tgoto yy8;\n\tcase 'i':\tgoto yy7;\n \tcase 'o':\tgoto yy12;\n\tcase 'r':\tgoto yy4;\n\tcase 's':\tgoto yy9;\n\tcase '}':\tgoto yy14;\n\tdefault:\tgoto yy16;\n \t}\n yy2:\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy95;\n yy3:\n#line 962 \"ext/standard/var_unserializer.re\"\n \t{ return 0; }\n#line 646 \"ext/standard/var_unserializer.c\"\n yy4:\n \tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy89;\n \tgoto yy3;\n yy5:\n \tyych = *++YYCURSOR;\n\tif (yych == ';') goto yy87;\n \tgoto yy3;\n yy6:\n \tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy83;\n \tgoto yy3;\n yy7:\n \tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy77;\n \tgoto yy3;\n yy8:\n \tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy53;\n \tgoto yy3;\n yy9:\n \tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy46;\n \tgoto yy3;\n yy10:\n \tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy39;\n \tgoto yy3;\n yy11:\n \tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy32;\n \tgoto yy3;\n yy12:\n \tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy25;\n \tgoto yy3;\n yy13:\n \tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy17;\n \tgoto yy3;\n yy14:\n \t++YYCURSOR;\n#line 956 \"ext/standard/var_unserializer.re\"\n \t{\n \t/* this is the case where we have less data than planned */\n \tphp_error_docref(NULL, E_NOTICE, \"Unexpected end of serialized data\");\n \treturn 0; /* not sure if it should be 0 or 1 here? */\n }\n#line 695 \"ext/standard/var_unserializer.c\"\nyy16:\n\tyych = *++YYCURSOR;\n\tgoto yy3;\n yy17:\n \tyych = *++YYCURSOR;\n \tif (yybm[0+yych] & 128) {\n\t\tgoto yy20;\n \t}\n\tif (yych == '+') goto yy19;\n yy18:\n \tYYCURSOR = YYMARKER;\n \tgoto yy3;\n yy19:\n \tyych = *++YYCURSOR;\n\tif (yybm[0+yych] & 128) {\n\t\tgoto yy20;\n \t}\n \tgoto yy18;\nyy20:\n\t++YYCURSOR;\n\tif ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);\n\tyych = *YYCURSOR;\n\tif (yybm[0+yych] & 128) {\n\t\tgoto yy20;\n\t}\n \tif (yych <= '/') goto yy18;\n\tif (yych >= ';') goto yy18;\n \tyych = *++YYCURSOR;\n\tif (yych != '\"') goto yy18;\n\t++YYCURSOR;\n#line 804 \"ext/standard/var_unserializer.re\"\n\t{\n\tsize_t len, len2, len3, maxlen;\n\tzend_long elements;\n\tchar *str;\n\tzend_string *class_name;\n\tzend_class_entry *ce;\n\tint incomplete_class = 0;\n\tint custom_object = 0;\n\tzval user_func;\n\tzval retval;\n\tzval args[1];\n    if (!var_hash) return 0;\n\tif (*start == 'C') {\n\t\tcustom_object = 1;\n\t}\n\tlen2 = len = parse_uiv(start + 2);\n\tmaxlen = max - YYCURSOR;\n\tif (maxlen < len || len == 0) {\n\t\t*p = start + 2;\n\t\treturn 0;\n\t}\n\tstr = (char*)YYCURSOR;\n\tYYCURSOR += len;\n\tif (*(YYCURSOR) != '\"') {\n\t\t*p = YYCURSOR;\n\t\treturn 0;\n\t}\n\tif (*(YYCURSOR+1) != ':') {\n\t\t*p = YYCURSOR+1;\n\t\treturn 0;\n\t}\n\tlen3 = strspn(str, \"0123456789_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\\177\\200\\201\\202\\203\\204\\205\\206\\207\\210\\211\\212\\213\\214\\215\\216\\217\\220\\221\\222\\223\\224\\225\\226\\227\\230\\231\\232\\233\\234\\235\\236\\237\\240\\241\\242\\243\\244\\245\\246\\247\\250\\251\\252\\253\\254\\255\\256\\257\\260\\261\\262\\263\\264\\265\\266\\267\\270\\271\\272\\273\\274\\275\\276\\277\\300\\301\\302\\303\\304\\305\\306\\307\\310\\311\\312\\313\\314\\315\\316\\317\\320\\321\\322\\323\\324\\325\\326\\327\\330\\331\\332\\333\\334\\335\\336\\337\\340\\341\\342\\343\\344\\345\\346\\347\\350\\351\\352\\353\\354\\355\\356\\357\\360\\361\\362\\363\\364\\365\\366\\367\\370\\371\\372\\373\\374\\375\\376\\377\\\\\");\n\tif (len3 != len)\n\t{\n\t\t*p = YYCURSOR + len3 - len;\n\t\treturn 0;\n\t}\n\tclass_name = zend_string_init(str, len, 0);\n\tdo {\n\t\tif(!unserialize_allowed_class(class_name, classes)) {\n\t\t\tincomplete_class = 1;\n\t\t\tce = PHP_IC_ENTRY;\n\t\t\tbreak;\n\t\t}\n\t\t/* Try to find class directly */\n\t\tBG(serialize_lock)++;\n\t\tce = zend_lookup_class(class_name);\n\t\tif (ce) {\n\t\t\tBG(serialize_lock)--;\n\t\t\tif (EG(exception)) {\n\t\t\t\tzend_string_release(class_name);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tBG(serialize_lock)--;\n\t\tif (EG(exception)) {\n\t\t\tzend_string_release(class_name);\n\t\t\treturn 0;\n\t\t}\n\t\t/* Check for unserialize callback */\n\t\tif ((PG(unserialize_callback_func) == NULL) || (PG(unserialize_callback_func)[0] == '\\0')) {\n\t\t\tincomplete_class = 1;\n\t\t\tce = PHP_IC_ENTRY;\n\t\t\tbreak;\n\t\t}\n\t\t/* Call unserialize callback */\n\t\tZVAL_STRING(&user_func, PG(unserialize_callback_func));\n\t\tZVAL_STR_COPY(&args[0], class_name);\n\t\tBG(serialize_lock)++;\n\t\tif (call_user_function_ex(CG(function_table), NULL, &user_func, &retval, 1, args, 0, NULL) != SUCCESS) {\n\t\t\tBG(serialize_lock)--;\n\t\t\tif (EG(exception)) {\n\t\t\t\tzend_string_release(class_name);\n\t\t\t\tzval_ptr_dtor(&user_func);\n\t\t\t\tzval_ptr_dtor(&args[0]);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tphp_error_docref(NULL, E_WARNING, \"defined (%s) but not found\", Z_STRVAL(user_func));\n\t\t\tincomplete_class = 1;\n\t\t\tce = PHP_IC_ENTRY;\n\t\t\tzval_ptr_dtor(&user_func);\n\t\t\tzval_ptr_dtor(&args[0]);\n\t\t\tbreak;\n\t\t}\n\t\tBG(serialize_lock)--;\n\t\tzval_ptr_dtor(&retval);\n\t\tif (EG(exception)) {\n\t\t\tzend_string_release(class_name);\n\t\t\tzval_ptr_dtor(&user_func);\n\t\t\tzval_ptr_dtor(&args[0]);\n\t\t\treturn 0;\n\t\t}\n\t\t/* The callback function may have defined the class */\n\t\tBG(serialize_lock)++;\n\t\tif ((ce = zend_lookup_class(class_name)) == NULL) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"Function %s() hasn't defined the class it was called for\", Z_STRVAL(user_func));\n\t\t\tincomplete_class = 1;\n\t\t\tce = PHP_IC_ENTRY;\n \t\t}\n\t\tBG(serialize_lock)--;\n\t\tzval_ptr_dtor(&user_func);\n\t\tzval_ptr_dtor(&args[0]);\n\t\tbreak;\n\t} while (1);\n\t*p = YYCURSOR;\n\tif (custom_object) {\n\t\tint ret;\n\t\tret = object_custom(UNSERIALIZE_PASSTHRU, ce);\n\t\tif (ret && incomplete_class) {\n\t\t\tphp_store_class_name(rval, ZSTR_VAL(class_name), len2);\n \t\t}\n\t\tzend_string_release(class_name);\n\t\treturn ret;\n \t}\n\telements = object_common1(UNSERIALIZE_PASSTHRU, ce);\n\tif (elements < 0) {\n\t   zend_string_release(class_name);\n\t   return 0;\n \t}\n\tif (incomplete_class) {\n\t\tphp_store_class_name(rval, ZSTR_VAL(class_name), len2);\n \t}\n\tzend_string_release(class_name);\n\treturn object_common2(UNSERIALIZE_PASSTHRU, elements);\n}\n#line 878 \"ext/standard/var_unserializer.c\"\nyy25:\n \tyych = *++YYCURSOR;\n \tif (yych <= ',') {\n\t\tif (yych != '+') goto yy18;\n \t} else {\n\t\tif (yych <= '-') goto yy26;\n \t\tif (yych <= '/') goto yy18;\n\t\tif (yych <= '9') goto yy27;\n \t\tgoto yy18;\n \t}\nyy26:\n \tyych = *++YYCURSOR;\n \tif (yych <= '/') goto yy18;\n\tif (yych >= ':') goto yy18;\nyy27:\n \t++YYCURSOR;\n \tif ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);\n \tyych = *YYCURSOR;\n \tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy27;\n\tif (yych >= ';') goto yy18;\n \tyych = *++YYCURSOR;\n\tif (yych != '\"') goto yy18;\n \t++YYCURSOR;\n#line 793 \"ext/standard/var_unserializer.re\"\n\t{\n\tzend_long elements;\n    if (!var_hash) return 0;\n\telements = object_common1(UNSERIALIZE_PASSTHRU, ZEND_STANDARD_CLASS_DEF_PTR);\n\tif (elements < 0 || elements >= HT_MAX_SIZE) {\n\t\treturn 0;\n\t}\n\treturn object_common2(UNSERIALIZE_PASSTHRU, elements);\n}\n#line 914 \"ext/standard/var_unserializer.c\"\nyy32:\n\tyych = *++YYCURSOR;\n\tif (yych == '+') goto yy33;\n \tif (yych <= '/') goto yy18;\n \tif (yych <= '9') goto yy34;\n \tgoto yy18;\nyy33:\n \tyych = *++YYCURSOR;\n \tif (yych <= '/') goto yy18;\n \tif (yych >= ':') goto yy18;\nyy34:\n \t++YYCURSOR;\n \tif ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);\n \tyych = *YYCURSOR;\n \tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy34;\n\tif (yych >= ';') goto yy18;\n \tyych = *++YYCURSOR;\n\tif (yych != '{') goto yy18;\n \t++YYCURSOR;\n#line 769 \"ext/standard/var_unserializer.re\"\n\t{\n\tzend_long elements = parse_iv(start + 2);\n\t/* use iv() not uiv() in order to check data range */\n\t*p = YYCURSOR;\n    if (!var_hash) return 0;\n\tif (elements < 0 || elements >= HT_MAX_SIZE) {\n\t\treturn 0;\n\t}\n\tarray_init_size(rval, elements);\n\tif (elements) {\n\t\t/* we can't convert from packed to hash during unserialization, because\n\t\t   reference to some zvals might be keept in var_hash (to support references) */\n\t\tzend_hash_real_init(Z_ARRVAL_P(rval), 0);\n \t}\n\tif (!process_nested_data(UNSERIALIZE_PASSTHRU, Z_ARRVAL_P(rval), elements, 0)) {\n\t\treturn 0;\n \t}\n\treturn finish_nested_data(UNSERIALIZE_PASSTHRU);\n}\n#line 959 \"ext/standard/var_unserializer.c\"\nyy39:\n \tyych = *++YYCURSOR;\n\tif (yych == '+') goto yy40;\n \tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy41;\n \tgoto yy18;\nyy40:\n \tyych = *++YYCURSOR;\n \tif (yych <= '/') goto yy18;\n \tif (yych >= ':') goto yy18;\nyy41:\n \t++YYCURSOR;\n \tif ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);\n \tyych = *YYCURSOR;\n \tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy41;\n\tif (yych >= ';') goto yy18;\n \tyych = *++YYCURSOR;\n\tif (yych != '\"') goto yy18;\n \t++YYCURSOR;\n#line 735 \"ext/standard/var_unserializer.re\"\n\t{\n\tsize_t len, maxlen;\n\tzend_string *str;\n\tlen = parse_uiv(start + 2);\n\tmaxlen = max - YYCURSOR;\n\tif (maxlen < len) {\n\t\t*p = start + 2;\n\t\treturn 0;\n\t}\n\tif ((str = unserialize_str(&YYCURSOR, len, maxlen)) == NULL) {\n\t\treturn 0;\n\t}\n\tif (*(YYCURSOR) != '\"') {\n\t\tzend_string_free(str);\n\t\t*p = YYCURSOR;\n\t\treturn 0;\n\t}\n\tif (*(YYCURSOR + 1) != ';') {\n\t\tefree(str);\n\t\t*p = YYCURSOR + 1;\n\t\treturn 0;\n\t}\n\tYYCURSOR += 2;\n\t*p = YYCURSOR;\n\tZVAL_STR(rval, str);\n\treturn 1;\n}\n#line 1014 \"ext/standard/var_unserializer.c\"\nyy46:\n\tyych = *++YYCURSOR;\n\tif (yych == '+') goto yy47;\n \tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy48;\n \tgoto yy18;\nyy47:\n \tyych = *++YYCURSOR;\n \tif (yych <= '/') goto yy18;\n \tif (yych >= ':') goto yy18;\nyy48:\n \t++YYCURSOR;\n \tif ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);\n \tyych = *YYCURSOR;\n \tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy48;\n\tif (yych >= ';') goto yy18;\n \tyych = *++YYCURSOR;\n\tif (yych != '\"') goto yy18;\n \t++YYCURSOR;\n#line 703 \"ext/standard/var_unserializer.re\"\n \t{\n\tsize_t len, maxlen;\n\tchar *str;\n\tlen = parse_uiv(start + 2);\n\tmaxlen = max - YYCURSOR;\n\tif (maxlen < len) {\n\t\t*p = start + 2;\n\t\treturn 0;\n\t}\n\tstr = (char*)YYCURSOR;\n \n\tYYCURSOR += len;\n \n\tif (*(YYCURSOR) != '\"') {\n\t\t*p = YYCURSOR;\n \t\treturn 0;\n \t}\n \n\tif (*(YYCURSOR + 1) != ';') {\n\t\t*p = YYCURSOR + 1;\n \t\treturn 0;\n \t}\n \n\tYYCURSOR += 2;\n\t*p = YYCURSOR;\n \n\tZVAL_STRINGL(rval, str, len);\n \treturn 1;\n }\n#line 1067 \"ext/standard/var_unserializer.c\"\nyy53:\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') {\n\t\tif (yych <= ',') {\n\t\t\tif (yych == '+') goto yy57;\n\t\t\tgoto yy18;\n\t\t} else {\n\t\t\tif (yych <= '-') goto yy55;\n\t\t\tif (yych <= '.') goto yy60;\n\t\t\tgoto yy18;\n\t\t}\n\t} else {\n\t\tif (yych <= 'I') {\n\t\t\tif (yych <= '9') goto yy58;\n\t\t\tif (yych <= 'H') goto yy18;\n\t\t\tgoto yy56;\n\t\t} else {\n\t\t\tif (yych != 'N') goto yy18;\n\t\t}\n\t}\n \tyych = *++YYCURSOR;\n\tif (yych == 'A') goto yy76;\n \tgoto yy18;\nyy55:\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') {\n\t\tif (yych == '.') goto yy60;\n\t\tgoto yy18;\n\t} else {\n\t\tif (yych <= '9') goto yy58;\n\t\tif (yych != 'I') goto yy18;\n\t}\nyy56:\n \tyych = *++YYCURSOR;\n\tif (yych == 'N') goto yy72;\n \tgoto yy18;\nyy57:\n\tyych = *++YYCURSOR;\n\tif (yych == '.') goto yy60;\n\tif (yych <= '/') goto yy18;\n\tif (yych >= ':') goto yy18;\nyy58:\n \t++YYCURSOR;\n\tif ((YYLIMIT - YYCURSOR) < 4) YYFILL(4);\n\tyych = *YYCURSOR;\n\tif (yych <= ':') {\n\t\tif (yych <= '.') {\n\t\t\tif (yych <= '-') goto yy18;\n\t\t\tgoto yy70;\n\t\t} else {\n\t\t\tif (yych <= '/') goto yy18;\n\t\t\tif (yych <= '9') goto yy58;\n\t\t\tgoto yy18;\n\t\t}\n\t} else {\n\t\tif (yych <= 'E') {\n\t\t\tif (yych <= ';') goto yy63;\n\t\t\tif (yych <= 'D') goto yy18;\n\t\t\tgoto yy65;\n\t\t} else {\n\t\t\tif (yych == 'e') goto yy65;\n\t\t\tgoto yy18;\n\t\t}\n\t}\nyy60:\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych >= ':') goto yy18;\nyy61:\n \t++YYCURSOR;\n \tif ((YYLIMIT - YYCURSOR) < 4) YYFILL(4);\n \tyych = *YYCURSOR;\n \tif (yych <= ';') {\n \t\tif (yych <= '/') goto yy18;\n\t\tif (yych <= '9') goto yy61;\n \t\tif (yych <= ':') goto yy18;\n \t} else {\n \t\tif (yych <= 'E') {\n \t\t\tif (yych <= 'D') goto yy18;\n\t\t\tgoto yy65;\n \t\t} else {\n\t\t\tif (yych == 'e') goto yy65;\n \t\t\tgoto yy18;\n \t\t}\n \t}\nyy63:\n \t++YYCURSOR;\n#line 694 \"ext/standard/var_unserializer.re\"\n \t{\n #if SIZEOF_ZEND_LONG == 4\n use_double:\n#endif\n\t*p = YYCURSOR;\n \tZVAL_DOUBLE(rval, zend_strtod((const char *)start + 2, NULL));\n \treturn 1;\n }\n#line 1164 \"ext/standard/var_unserializer.c\"\nyy65:\n \tyych = *++YYCURSOR;\n \tif (yych <= ',') {\n\t\tif (yych != '+') goto yy18;\n \t} else {\n\t\tif (yych <= '-') goto yy66;\n \t\tif (yych <= '/') goto yy18;\n\t\tif (yych <= '9') goto yy67;\n \t\tgoto yy18;\n \t}\nyy66:\n \tyych = *++YYCURSOR;\n\tif (yych <= ',') {\n\t\tif (yych == '+') goto yy69;\n\t\tgoto yy18;\n\t} else {\n\t\tif (yych <= '-') goto yy69;\n\t\tif (yych <= '/') goto yy18;\n\t\tif (yych >= ':') goto yy18;\n\t}\nyy67:\n\t++YYCURSOR;\n\tif (YYLIMIT <= YYCURSOR) YYFILL(1);\n\tyych = *YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy67;\n\tif (yych == ';') goto yy63;\n \tgoto yy18;\nyy69:\n \tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy67;\n \tgoto yy18;\nyy70:\n \t++YYCURSOR;\n\tif ((YYLIMIT - YYCURSOR) < 4) YYFILL(4);\n\tyych = *YYCURSOR;\n\tif (yych <= ';') {\n\t\tif (yych <= '/') goto yy18;\n\t\tif (yych <= '9') goto yy70;\n\t\tif (yych <= ':') goto yy18;\n\t\tgoto yy63;\n\t} else {\n\t\tif (yych <= 'E') {\n\t\t\tif (yych <= 'D') goto yy18;\n\t\t\tgoto yy65;\n \t\t} else {\n\t\t\tif (yych == 'e') goto yy65;\n\t\t\tgoto yy18;\n \t\t}\n \t}\nyy72:\n\tyych = *++YYCURSOR;\n\tif (yych != 'F') goto yy18;\nyy73:\n \tyych = *++YYCURSOR;\n\tif (yych != ';') goto yy18;\n \t++YYCURSOR;\n#line 678 \"ext/standard/var_unserializer.re\"\n \t{\n\t*p = YYCURSOR;\n \n\tif (!strncmp((char*)start + 2, \"NAN\", 3)) {\n\t\tZVAL_DOUBLE(rval, php_get_nan());\n\t} else if (!strncmp((char*)start + 2, \"INF\", 3)) {\n\t\tZVAL_DOUBLE(rval, php_get_inf());\n\t} else if (!strncmp((char*)start + 2, \"-INF\", 4)) {\n\t\tZVAL_DOUBLE(rval, -php_get_inf());\n\t} else {\n\t\tZVAL_NULL(rval);\n \t}\n \n \treturn 1;\n }\n#line 1239 \"ext/standard/var_unserializer.c\"\nyy76:\n \tyych = *++YYCURSOR;\n\tif (yych == 'N') goto yy73;\n \tgoto yy18;\nyy77:\n\tyych = *++YYCURSOR;\n\tif (yych <= ',') {\n\t\tif (yych != '+') goto yy18;\n\t} else {\n\t\tif (yych <= '-') goto yy78;\n\t\tif (yych <= '/') goto yy18;\n\t\tif (yych <= '9') goto yy79;\n\t\tgoto yy18;\n\t}\nyy78:\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych >= ':') goto yy18;\nyy79:\n \t++YYCURSOR;\n\tif (YYLIMIT <= YYCURSOR) YYFILL(1);\n\tyych = *YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy79;\n\tif (yych != ';') goto yy18;\n\t++YYCURSOR;\n#line 652 \"ext/standard/var_unserializer.re\"\n \t{\n#if SIZEOF_ZEND_LONG == 4\n\tint digits = YYCURSOR - start - 3;\n \n\tif (start[2] == '-' || start[2] == '+') {\n\t\tdigits--;\n \t}\n \n\t/* Use double for large zend_long values that were serialized on a 64-bit system */\n\tif (digits >= MAX_LENGTH_OF_LONG - 1) {\n\t\tif (digits == MAX_LENGTH_OF_LONG - 1) {\n\t\t\tint cmp = strncmp((char*)YYCURSOR - MAX_LENGTH_OF_LONG, long_min_digits, MAX_LENGTH_OF_LONG - 1);\n \n\t\t\tif (!(cmp < 0 || (cmp == 0 && start[2] == '-'))) {\n\t\t\t\tgoto use_double;\n \t\t\t}\n\t\t} else {\n\t\t\tgoto use_double;\n \t\t}\n\t}\n#endif\n \t*p = YYCURSOR;\n\tZVAL_LONG(rval, parse_iv(start + 2));\n\treturn 1;\n }\n#line 1292 \"ext/standard/var_unserializer.c\"\nyy83:\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych >= '2') goto yy18;\n\tyych = *++YYCURSOR;\n\tif (yych != ';') goto yy18;\n \t++YYCURSOR;\n#line 646 \"ext/standard/var_unserializer.re\"\n \t{\n \t*p = YYCURSOR;\n\tZVAL_BOOL(rval, parse_iv(start + 2));\n \treturn 1;\n }\n#line 1306 \"ext/standard/var_unserializer.c\"\nyy87:\n \t++YYCURSOR;\n#line 640 \"ext/standard/var_unserializer.re\"\n \t{\n \t*p = YYCURSOR;\n\tZVAL_NULL(rval);\n\treturn 1;\n }\n#line 1315 \"ext/standard/var_unserializer.c\"\nyy89:\n \tyych = *++YYCURSOR;\n \tif (yych <= ',') {\n\t\tif (yych != '+') goto yy18;\n \t} else {\n\t\tif (yych <= '-') goto yy90;\n \t\tif (yych <= '/') goto yy18;\n\t\tif (yych <= '9') goto yy91;\n\t\tgoto yy18;\n \t}\nyy90:\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych >= ':') goto yy18;\nyy91:\n \t++YYCURSOR;\n \tif (YYLIMIT <= YYCURSOR) YYFILL(1);\n \tyych = *YYCURSOR;\n \tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy91;\n\tif (yych != ';') goto yy18;\n \t++YYCURSOR;\n#line 615 \"ext/standard/var_unserializer.re\"\n \t{\n\tzend_long id;\n \n \t*p = YYCURSOR;\n\tif (!var_hash) return 0;\n \n\tid = parse_iv(start + 2) - 1;\n\tif (id == -1 || (rval_ref = var_access(var_hash, id)) == NULL) {\n \t\treturn 0;\n \t}\n \n\tif (rval_ref == rval) {\n \t\treturn 0;\n \t}\n \n\tif (Z_ISUNDEF_P(rval_ref) || (Z_ISREF_P(rval_ref) && Z_ISUNDEF_P(Z_REFVAL_P(rval_ref)))) {\n\t\tZVAL_UNDEF(rval);\n\t\treturn 1;\n \t}\n \n\tZVAL_COPY(rval, rval_ref);\n \n \treturn 1;\n }\n#line 1363 \"ext/standard/var_unserializer.c\"\nyy95:\n\tyych = *++YYCURSOR;\n\tif (yych <= ',') {\n\t\tif (yych != '+') goto yy18;\n\t} else {\n\t\tif (yych <= '-') goto yy96;\n\t\tif (yych <= '/') goto yy18;\n\t\tif (yych <= '9') goto yy97;\n\t\tgoto yy18;\n\t}\n yy96:\n \tyych = *++YYCURSOR;\n \tif (yych <= '/') goto yy18;\n\tif (yych >= ':') goto yy18;\n yy97:\n \t++YYCURSOR;\n\tif (YYLIMIT <= YYCURSOR) YYFILL(1);\n\tyych = *YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy97;\n\tif (yych != ';') goto yy18;\n\t++YYCURSOR;\n#line 589 \"ext/standard/var_unserializer.re\"\n \t{\n\tzend_long id;\n \t*p = YYCURSOR;\n\tif (!var_hash) return 0;\n\tid = parse_iv(start + 2) - 1;\n\tif (id == -1 || (rval_ref = var_access(var_hash, id)) == NULL) {\n\t\treturn 0;\n\t}\n \n\tzval_ptr_dtor(rval);\n\tif (Z_ISUNDEF_P(rval_ref) || (Z_ISREF_P(rval_ref) && Z_ISUNDEF_P(Z_REFVAL_P(rval_ref)))) {\n\t\tZVAL_UNDEF(rval);\n\t\treturn 1;\n\t}\n\tif (Z_ISREF_P(rval_ref)) {\n\t\tZVAL_COPY(rval, rval_ref);\n \t} else {\n\t\tZVAL_NEW_REF(rval_ref, rval_ref);\n\t\tZVAL_COPY(rval, rval_ref);\n \t}\n \n \treturn 1;\n }\n#line 1412 \"ext/standard/var_unserializer.c\"\n }\n#line 964 \"ext/standard/var_unserializer.re\"\n \n \n \treturn 0;\n}\n", "target": 1, "idx": 181105}
{"func": "entry_guard_chan_failed(channel_t *chan)\n{\n  if (!chan)\n    return;\n\n  smartlist_t *pending = smartlist_new();\n  circuit_get_all_pending_on_channel(pending, chan);\n  SMARTLIST_FOREACH_BEGIN(pending, circuit_t *, circ) {\n    if (!CIRCUIT_IS_ORIGIN(circ))\n      continue;\n\n    origin_circuit_t *origin_circ = TO_ORIGIN_CIRCUIT(circ);\n    if (origin_circ->guard_state) {\n      /* We might have no guard state if we didn't use a guard on this\n       * circuit (eg it's for a fallback directory). */\n      entry_guard_failed(&origin_circ->guard_state);\n    }\n  } SMARTLIST_FOREACH_END(circ);\n  smartlist_free(pending);\n}\n", "target": 0, "idx": 69665}
{"func": "int tls1_check_ec_tmp_key(SSL *s, unsigned long cid)\n{\n    unsigned char curve_id[2];\n    EC_KEY *ec = s->cert->ecdh_tmp;\n#  ifdef OPENSSL_SSL_DEBUG_BROKEN_PROTOCOL\n    /* Allow any curve: not just those peer supports */\n    if (s->cert->cert_flags & SSL_CERT_FLAG_BROKEN_PROTOCOL)\n        return 1;\n#  endif\n    /*\n     * If Suite B, AES128 MUST use P-256 and AES256 MUST use P-384, no other\n     * curves permitted.\n     */\n    if (tls1_suiteb(s)) {\n        /* Curve to check determined by ciphersuite */\n        if (cid == TLS1_CK_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256)\n            curve_id[1] = TLSEXT_curve_P_256;\n        else if (cid == TLS1_CK_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384)\n            curve_id[1] = TLSEXT_curve_P_384;\n        else\n            return 0;\n        curve_id[0] = 0;\n        /* Check this curve is acceptable */\n        if (!tls1_check_ec_key(s, curve_id, NULL))\n            return 0;\n        /* If auto or setting curve from callback assume OK */\n        if (s->cert->ecdh_tmp_auto || s->cert->ecdh_tmp_cb)\n            return 1;\n        /* Otherwise check curve is acceptable */\n        else {\n            unsigned char curve_tmp[2];\n            if (!ec)\n                return 0;\n            if (!tls1_set_ec_id(curve_tmp, NULL, ec))\n                return 0;\n            if (!curve_tmp[0] || curve_tmp[1] == curve_id[1])\n                return 1;\n            return 0;\n        }\n\n    }\n    if (s->cert->ecdh_tmp_auto) {\n        /* Need a shared curve */\n        if (tls1_shared_curve(s, 0))\n            return 1;\n        else\n            return 0;\n    }\n    if (!ec) {\n        if (s->cert->ecdh_tmp_cb)\n            return 1;\n        else\n            return 0;\n    }\n    if (!tls1_set_ec_id(curve_id, NULL, ec))\n        return 0;\n/* Set this to allow use of invalid curves for testing */\n#  if 0\n    return 1;\n#  else\n    return tls1_check_ec_key(s, curve_id, NULL);\n#  endif\n}\n", "target": 0, "idx": 6163}
{"func": "static void inv_predict_0(uint8_t *p, const uint8_t *p_l, const uint8_t *p_tl,\n                          const uint8_t *p_t, const uint8_t *p_tr)\n{\n    AV_WB32(p, 0xFF000000);\n}\n", "target": 0, "idx": 64038}
{"func": "static int ipv6_create_tempaddr(struct inet6_ifaddr *ifp, struct inet6_ifaddr *ift)\n{\n\tstruct inet6_dev *idev = ifp->idev;\n\tstruct in6_addr addr, *tmpaddr;\n\tunsigned long tmp_prefered_lft, tmp_valid_lft, tmp_tstamp, age;\n\tunsigned long regen_advance;\n\tint tmp_plen;\n\tint ret = 0;\n\tu32 addr_flags;\n\tunsigned long now = jiffies;\n\n\twrite_lock_bh(&idev->lock);\n\tif (ift) {\n\t\tspin_lock_bh(&ift->lock);\n\t\tmemcpy(&addr.s6_addr[8], &ift->addr.s6_addr[8], 8);\n\t\tspin_unlock_bh(&ift->lock);\n\t\ttmpaddr = &addr;\n\t} else {\n\t\ttmpaddr = NULL;\n\t}\nretry:\n\tin6_dev_hold(idev);\n\tif (idev->cnf.use_tempaddr <= 0) {\n\t\twrite_unlock_bh(&idev->lock);\n\t\tpr_info(\"%s: use_tempaddr is disabled\\n\", __func__);\n\t\tin6_dev_put(idev);\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\tspin_lock_bh(&ifp->lock);\n\tif (ifp->regen_count++ >= idev->cnf.regen_max_retry) {\n\t\tidev->cnf.use_tempaddr = -1;\t/*XXX*/\n\t\tspin_unlock_bh(&ifp->lock);\n\t\twrite_unlock_bh(&idev->lock);\n\t\tpr_warn(\"%s: regeneration time exceeded - disabled temporary address support\\n\",\n\t\t\t__func__);\n\t\tin6_dev_put(idev);\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\tin6_ifa_hold(ifp);\n\tmemcpy(addr.s6_addr, ifp->addr.s6_addr, 8);\n\t__ipv6_try_regen_rndid(idev, tmpaddr);\n\tmemcpy(&addr.s6_addr[8], idev->rndid, 8);\n\tage = (now - ifp->tstamp) / HZ;\n\ttmp_valid_lft = min_t(__u32,\n\t\t\t      ifp->valid_lft,\n\t\t\t      idev->cnf.temp_valid_lft + age);\n\ttmp_prefered_lft = min_t(__u32,\n\t\t\t\t ifp->prefered_lft,\n\t\t\t\t idev->cnf.temp_prefered_lft + age -\n\t\t\t\t idev->cnf.max_desync_factor);\n\ttmp_plen = ifp->prefix_len;\n\ttmp_tstamp = ifp->tstamp;\n\tspin_unlock_bh(&ifp->lock);\n\n\tregen_advance = idev->cnf.regen_max_retry *\n\t\t\tidev->cnf.dad_transmits *\n\t\t\tNEIGH_VAR(idev->nd_parms, RETRANS_TIME) / HZ;\n\twrite_unlock_bh(&idev->lock);\n\n\t/* A temporary address is created only if this calculated Preferred\n\t * Lifetime is greater than REGEN_ADVANCE time units.  In particular,\n\t * an implementation must not create a temporary address with a zero\n\t * Preferred Lifetime.\n\t * Use age calculation as in addrconf_verify to avoid unnecessary\n\t * temporary addresses being generated.\n\t */\n\tage = (now - tmp_tstamp + ADDRCONF_TIMER_FUZZ_MINUS) / HZ;\n\tif (tmp_prefered_lft <= regen_advance + age) {\n\t\tin6_ifa_put(ifp);\n\t\tin6_dev_put(idev);\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\taddr_flags = IFA_F_TEMPORARY;\n\t/* set in addrconf_prefix_rcv() */\n\tif (ifp->flags & IFA_F_OPTIMISTIC)\n\t\taddr_flags |= IFA_F_OPTIMISTIC;\n\n\tift = ipv6_add_addr(idev, &addr, NULL, tmp_plen,\n\t\t\t    ipv6_addr_scope(&addr), addr_flags,\n\t\t\t    tmp_valid_lft, tmp_prefered_lft);\n\tif (IS_ERR(ift)) {\n\t\tin6_ifa_put(ifp);\n\t\tin6_dev_put(idev);\n\t\tpr_info(\"%s: retry temporary address regeneration\\n\", __func__);\n\t\ttmpaddr = &addr;\n\t\twrite_lock_bh(&idev->lock);\n\t\tgoto retry;\n\t}\n\n\tspin_lock_bh(&ift->lock);\n\tift->ifpub = ifp;\n\tift->cstamp = now;\n\tift->tstamp = tmp_tstamp;\n\tspin_unlock_bh(&ift->lock);\n\n\taddrconf_dad_start(ift);\n\tin6_ifa_put(ift);\n\tin6_dev_put(idev);\nout:\n\treturn ret;\n}\n", "target": 0, "idx": 41867}
{"func": "void CustomDrag::OnDragBegin(GtkWidget* widget, GdkDragContext* drag_context) {\n  if (pixbuf_)\n    gtk_drag_set_icon_pixbuf(drag_context, pixbuf_, 0, 0);\n}\n", "target": 0, "idx": 99548}
{"func": "static v8::Handle<v8::Value> anotherFunctionCallback(const v8::Arguments& args)\n {\n     INC_STATS(\"DOM.TestCustomNamedGetter.anotherFunction\");\n     if (args.Length() < 1)\n        return V8Proxy::throwNotEnoughArgumentsError();\n     TestCustomNamedGetter* imp = V8TestCustomNamedGetter::toNative(args.Holder());\n     STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, str, MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined));\n     imp->anotherFunction(str);\n    return v8::Handle<v8::Value>();\n}\n", "target": 1, "idx": 184760}
{"func": "int bt_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t\tstruct msghdr *msg, size_t len, int flags)\n{\n\tint noblock = flags & MSG_DONTWAIT;\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tsize_t copied;\n\tint err;\n\n\tBT_DBG(\"sock %p sk %p len %zu\", sock, sk, len);\n\n\tif (flags & (MSG_OOB))\n\t\treturn -EOPNOTSUPP;\n \n \tskb = skb_recv_datagram(sk, flags, noblock, &err);\n \tif (!skb) {\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN) {\n\t\t\tmsg->msg_namelen = 0;\n \t\t\treturn 0;\n\t\t}\n \t\treturn err;\n \t}\n \n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\tskb_reset_transport_header(skb);\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err == 0) {\n\t\tsock_recv_ts_and_drops(msg, sk, skb);\n\n \t\tif (bt_sk(sk)->skb_msg_name)\n \t\t\tbt_sk(sk)->skb_msg_name(skb, msg->msg_name,\n \t\t\t\t\t\t&msg->msg_namelen);\n\t\telse\n\t\t\tmsg->msg_namelen = 0;\n \t}\n \n \tskb_free_datagram(sk, skb);\n\n\treturn err ? : copied;\n}\n", "target": 1, "idx": 179663}
{"func": "BluetoothAdapter::RetrieveGattConnectedDevicesWithDiscoveryFilter(\n    const BluetoothDiscoveryFilter& discovery_filter) {\n  return std::unordered_map<BluetoothDevice*, BluetoothDevice::UUIDSet>();\n}\n", "target": 0, "idx": 150881}
{"func": "static struct page *allocate_slab(struct kmem_cache *s, gfp_t flags, int node)\n{\n\tstruct page *page;\n\tstruct kmem_cache_order_objects oo = s->oo;\n\n\tflags |= s->allocflags;\n\n\tpage = alloc_slab_page(flags | __GFP_NOWARN | __GFP_NORETRY, node,\n\t\t\t\t\t\t\t\t\too);\n\tif (unlikely(!page)) {\n\t\too = s->min;\n\t\t/*\n\t\t * Allocation may have failed due to fragmentation.\n\t\t * Try a lower order alloc if possible\n\t\t */\n\t\tpage = alloc_slab_page(flags, node, oo);\n\t\tif (!page)\n\t\t\treturn NULL;\n\n\t\tstat(get_cpu_slab(s, raw_smp_processor_id()), ORDER_FALLBACK);\n\t}\n\tpage->objects = oo_objects(oo);\n\tmod_zone_page_state(page_zone(page),\n\t\t(s->flags & SLAB_RECLAIM_ACCOUNT) ?\n\t\tNR_SLAB_RECLAIMABLE : NR_SLAB_UNRECLAIMABLE,\n\t\t1 << oo_order(oo));\n\n\treturn page;\n}\n", "target": 0, "idx": 24762}
{"func": "status_t QueryCodecs(\n const sp<IOMX> &omx,\n const char *mimeType, bool queryDecoders,\n Vector<CodecCapabilities> *results) {\n return QueryCodecs(omx, mimeType, queryDecoders, false /*hwCodecOnly*/, results);\n}\n", "target": 0, "idx": 171310}
{"func": "static int ebt_size_mwt(struct compat_ebt_entry_mwt *match32,\n\t\t\tunsigned int size_left, enum compat_mwt type,\n\t\t\tstruct ebt_entries_buf_state *state, const void *base)\n{\n\tint growth = 0;\n\tchar *buf;\n\n\tif (size_left == 0)\n\t\treturn 0;\n\n\tbuf = (char *) match32;\n\n\twhile (size_left >= sizeof(*match32)) {\n\t\tstruct ebt_entry_match *match_kern;\n\t\tint ret;\n\n\t\tmatch_kern = (struct ebt_entry_match *) state->buf_kern_start;\n\t\tif (match_kern) {\n\t\t\tchar *tmp;\n\t\t\ttmp = state->buf_kern_start + state->buf_kern_offset;\n\t\t\tmatch_kern = (struct ebt_entry_match *) tmp;\n\t\t}\n\t\tret = ebt_buf_add(state, buf, sizeof(*match32));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tsize_left -= sizeof(*match32);\n\n\t\t/* add padding before match->data (if any) */\n\t\tret = ebt_buf_add_pad(state, ebt_compat_entry_padsize());\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (match32->match_size > size_left)\n\t\t\treturn -EINVAL;\n\n\t\tsize_left -= match32->match_size;\n\n\t\tret = compat_mtw_from_user(match32, type, state, base);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (WARN_ON(ret < match32->match_size))\n\t\t\treturn -EINVAL;\n\t\tgrowth += ret - match32->match_size;\n\t\tgrowth += ebt_compat_entry_padsize();\n\n\t\tbuf += sizeof(*match32);\n\t\tbuf += match32->match_size;\n\n \t\tif (match_kern)\n \t\t\tmatch_kern->match_size = ret;\n \n\t\tWARN_ON(type == EBT_COMPAT_TARGET && size_left);\n \t\tmatch32 = (struct compat_ebt_entry_mwt *) buf;\n \t}\n \n\treturn growth;\n}\n", "target": 1, "idx": 182529}
{"func": "format_clsid(char *buf, size_t len, const uint64_t uuid[2]) {\n\tsnprintf(buf, len, \"%.8\" PRIx64 \"-%.4\" PRIx64 \"-%.4\" PRIx64 \"-%.4\" \n\t    PRIx64 \"-%.12\" PRIx64,\n\t    (uuid[0] >> 32) & (uint64_t)0x000000000ffffffffLLU,\n\t    (uuid[0] >> 16) & (uint64_t)0x0000000000000ffffLLU,\n\t    (uuid[0] >>  0) & (uint64_t)0x0000000000000ffffLLU, \n\t    (uuid[1] >> 48) & (uint64_t)0x0000000000000ffffLLU,\n\t    (uuid[1] >>  0) & (uint64_t)0x0000fffffffffffffLLU);\n\treturn buf;\n}\n", "target": 0, "idx": 39584}
{"func": "static dbus_uint32_t fromAscii(char ascii)\n{\n    if(ascii >= '0' && ascii <= '9')\n        return ascii - '0';\n    if(ascii >= 'A' && ascii <= 'F')\n        return ascii - 'A' + 10;\n    if(ascii >= 'a' && ascii <= 'f')\n        return ascii - 'a' + 10;\n    return 0;    \n}\n", "target": 0, "idx": 3831}
{"func": " static inline const unsigned char *ReadResourceLong(const unsigned char *p,\n   unsigned int *quantum)\n {\n  *quantum=(size_t) (*p++ << 24);\n  *quantum|=(size_t) (*p++ << 16);\n  *quantum|=(size_t) (*p++ << 8);\n  *quantum|=(size_t) (*p++ << 0);\n   return(p);\n }\n", "target": 1, "idx": 183119}
{"func": "bool ChromeContentRendererClient::IsOtherExtensionWithWebRequestInstalled() {\n  return extension_dispatcher_->IsOtherExtensionWithWebRequestInstalled();\n}\n", "target": 0, "idx": 116403}
{"func": "status_t MPEG4Extractor::parseSegmentIndex(off64_t offset, size_t size) {\n  ALOGV(\"MPEG4Extractor::parseSegmentIndex\");\n\n if (size < 12) {\n return -EINVAL;\n }\n\n uint32_t flags;\n if (!mDataSource->getUInt32(offset, &flags)) {\n return ERROR_MALFORMED;\n }\n\n uint32_t version = flags >> 24;\n    flags &= 0xffffff;\n\n    ALOGV(\"sidx version %d\", version);\n\n uint32_t referenceId;\n if (!mDataSource->getUInt32(offset + 4, &referenceId)) {\n return ERROR_MALFORMED;\n }\n\n uint32_t timeScale;\n if (!mDataSource->getUInt32(offset + 8, &timeScale)) {\n return ERROR_MALFORMED;\n }\n    ALOGV(\"sidx refid/timescale: %d/%d\", referenceId, timeScale);\n\n uint64_t earliestPresentationTime;\n uint64_t firstOffset;\n\n    offset += 12;\n    size -= 12;\n\n if (version == 0) {\n if (size < 8) {\n return -EINVAL;\n }\n uint32_t tmp;\n if (!mDataSource->getUInt32(offset, &tmp)) {\n return ERROR_MALFORMED;\n }\n        earliestPresentationTime = tmp;\n if (!mDataSource->getUInt32(offset + 4, &tmp)) {\n return ERROR_MALFORMED;\n }\n        firstOffset = tmp;\n        offset += 8;\n        size -= 8;\n } else {\n if (size < 16) {\n return -EINVAL;\n }\n if (!mDataSource->getUInt64(offset, &earliestPresentationTime)) {\n return ERROR_MALFORMED;\n }\n if (!mDataSource->getUInt64(offset + 8, &firstOffset)) {\n return ERROR_MALFORMED;\n }\n        offset += 16;\n        size -= 16;\n }\n    ALOGV(\"sidx pres/off: %\" PRIu64 \"/%\" PRIu64, earliestPresentationTime, firstOffset);\n\n if (size < 4) {\n return -EINVAL;\n }\n\n uint16_t referenceCount;\n if (!mDataSource->getUInt16(offset + 2, &referenceCount)) {\n return ERROR_MALFORMED;\n }\n    offset += 4;\n    size -= 4;\n    ALOGV(\"refcount: %d\", referenceCount);\n\n if (size < referenceCount * 12) {\n return -EINVAL;\n }\n\n uint64_t total_duration = 0;\n for (unsigned int i = 0; i < referenceCount; i++) {\n uint32_t d1, d2, d3;\n\n if (!mDataSource->getUInt32(offset, &d1) || // size\n !mDataSource->getUInt32(offset + 4, &d2) || // duration\n !mDataSource->getUInt32(offset + 8, &d3)) { // flags\n return ERROR_MALFORMED;\n }\n\n if (d1 & 0x80000000) {\n            ALOGW(\"sub-sidx boxes not supported yet\");\n }\n bool sap = d3 & 0x80000000;\n uint32_t saptype = (d3 >> 28) & 7;\n if (!sap || (saptype != 1 && saptype != 2)) {\n            ALOGW(\"not a stream access point, or unsupported type: %08x\", d3);\n }\n        total_duration += d2;\n        offset += 12;\n        ALOGV(\" item %d, %08x %08x %08x\", i, d1, d2, d3);\n SidxEntry se;\n        se.mSize = d1 & 0x7fffffff;\n        se.mDurationUs = 1000000LL * d2 / timeScale;\n        mSidxEntries.add(se);\n }\n\n uint64_t sidxDuration = total_duration * 1000000 / timeScale;\n\n int64_t metaDuration;\n if (!mLastTrack->meta->findInt64(kKeyDuration, &metaDuration) || metaDuration == 0) {\n        mLastTrack->meta->setInt64(kKeyDuration, sidxDuration);\n }\n return OK;\n}\n", "target": 0, "idx": 170373}
{"func": "static int nfc_genl_dep_link_down(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tint rc;\n\tu32 idx;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX])\n\t\treturn -EINVAL;\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\trc = nfc_dep_link_down(dev);\n\n\tnfc_put_device(dev);\n\treturn rc;\n}\n", "target": 0, "idx": 89431}
{"func": "void DownloadFileManager::RenameCompletingDownloadFile(\n    DownloadId global_id,\n    const FilePath& full_path,\n    bool overwrite_existing_file,\n    const RenameCompletionCallback& callback) {\n  VLOG(20) << __FUNCTION__ << \"()\" << \" id = \" << global_id\n           << \" overwrite_existing_file = \" << overwrite_existing_file\n           << \" full_path = \\\"\" << full_path.value() << \"\\\"\";\n  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::FILE));\n  DownloadFile* download_file = GetDownloadFile(global_id);\n  if (!download_file) {\n    BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,\n                            base::Bind(callback, FilePath()));\n    return;\n  }\n \n  VLOG(20) << __FUNCTION__ << \"()\"\n           << \" download_file = \" << download_file->DebugString();\n  FilePath new_path = full_path;\n  if (!overwrite_existing_file) {\n    int uniquifier =\n        file_util::GetUniquePathNumber(new_path, FILE_PATH_LITERAL(\"\"));\n    if (uniquifier > 0) {\n      new_path = new_path.InsertBeforeExtensionASCII(\n          StringPrintf(\" (%d)\", uniquifier));\n    }\n  }\n  net::Error rename_error = download_file->Rename(new_path);\n  if (net::OK != rename_error) {\n    CancelDownloadOnRename(global_id, rename_error);\n     new_path.clear();\n  } else {\n    download_file->AnnotateWithSourceInformation();\n   }\n   BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,\n                           base::Bind(callback, new_path));\n }\n", "target": 1, "idx": 184451}
{"func": " void TargetThread::ThreadMain() {\n   id_ = PlatformThread::CurrentId();\n  SignalAndWaitUntilSignaled(&thread_started_event_, &finish_event_);\n }\n", "target": 1, "idx": 185406}
{"func": "xfs_bounce_unaligned_dio_write(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\toffset_fsb,\n\tstruct xfs_bmbt_irec\t*imap)\n{\n\tstruct xfs_bmbt_irec\tirec;\n\txfs_fileoff_t\t\tdelta;\n\tbool\t\t\tshared;\n\tbool\t\t\tx;\n\tint\t\t\terror;\n\n\tirec = *imap;\n\tif (offset_fsb > irec.br_startoff) {\n\t\tdelta = offset_fsb - irec.br_startoff;\n\t\tirec.br_blockcount -= delta;\n\t\tirec.br_startblock += delta;\n\t\tirec.br_startoff = offset_fsb;\n\t}\n\terror = xfs_reflink_trim_around_shared(ip, &irec, &shared, &x);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * We're here because we're trying to do a directio write to a\n\t * region that isn't aligned to a filesystem block.  If any part\n\t * of the extent is shared, fall back to buffered mode to handle\n\t * the RMW.  This is done by returning -EREMCHG (\"remote addr\n\t * changed\"), which is caught further up the call stack.\n\t */\n\tif (shared) {\n\t\ttrace_xfs_reflink_bounce_dio_write(ip, imap);\n\t\treturn -EREMCHG;\n\t}\n\treturn 0;\n}\n", "target": 0, "idx": 93939}
{"func": "void WebGL2RenderingContextBase::beginTransformFeedback(GLenum primitive_mode) {\n  if (isContextLost())\n    return;\n  if (!ValidateTransformFeedbackPrimitiveMode(\"beginTransformFeedback\",\n                                              primitive_mode))\n    return;\n  if (!current_program_) {\n    SynthesizeGLError(GL_INVALID_OPERATION, \"beginTransformFeedback\",\n                      \"no program object is active\");\n    return;\n  }\n  if (transform_feedback_binding_->active()) {\n    SynthesizeGLError(GL_INVALID_OPERATION, \"beginTransformFeedback\",\n                      \"transform feedback is already active\");\n    return;\n  }\n  int required_buffer_count =\n      current_program_->GetRequiredTransformFeedbackBufferCount(this);\n  if (required_buffer_count == 0) {\n    SynthesizeGLError(GL_INVALID_OPERATION, \"beginTransformFeedback\",\n                      \"current active program does not specify any transform \"\n                      \"feedback varyings to record\");\n    return;\n  }\n  if (!transform_feedback_binding_->HasEnoughBuffers(required_buffer_count)) {\n    SynthesizeGLError(GL_INVALID_OPERATION, \"beginTransformFeedback\",\n                      \"not enough transform feedback buffers bound\");\n    return;\n  }\n\n  ContextGL()->BeginTransformFeedback(primitive_mode);\n  current_program_->IncreaseActiveTransformFeedbackCount();\n  transform_feedback_binding_->SetProgram(current_program_);\n  transform_feedback_binding_->SetActive(true);\n  transform_feedback_binding_->SetPaused(false);\n}\n", "target": 0, "idx": 166597}
{"func": "bool CheckClientDownloadRequest::IsSupportedDownload(\n    DownloadCheckResultReason* reason,\n    ClientDownloadRequest::DownloadType* type) {\n  return IsSupportedDownload(*item_, item_->GetTargetFilePath(), reason, type);\n}\n", "target": 0, "idx": 149378}
{"func": "bool RenderBuffer::AllocateStorage(const gfx::Size& size, GLenum format) {\n  ScopedGLErrorSuppressor suppressor(decoder_);\n  ScopedRenderBufferBinder binder(decoder_, id_);\n  glRenderbufferStorageEXT(GL_RENDERBUFFER,\n                           format,\n                           size.width(),\n                           size.height());\n  return glGetError() == GL_NO_ERROR;\n}\n", "target": 0, "idx": 108038}
{"func": "   virtual size_t GetNumActiveInputMethods() {\n    scoped_ptr<InputMethodDescriptors> input_methods(GetActiveInputMethods());\n     return input_methods->size();\n   }\n", "target": 1, "idx": 183947}
{"func": "bool IsGL_REDSupportedOnFBOs() {\n  DCHECK(glGetError() == GL_NO_ERROR);\n  GLint fb_binding = 0;\n  GLint tex_binding = 0;\n  glGetIntegerv(GL_FRAMEBUFFER_BINDING, &fb_binding);\n  glGetIntegerv(GL_TEXTURE_BINDING_2D, &tex_binding);\n\n  GLuint textureId = 0;\n  glGenTextures(1, &textureId);\n  glBindTexture(GL_TEXTURE_2D, textureId);\n  GLubyte data[1] = {0};\n  glTexImage2D(GL_TEXTURE_2D, 0, GL_RED_EXT, 1, 1, 0, GL_RED_EXT,\n               GL_UNSIGNED_BYTE, data);\n  GLuint textureFBOID = 0;\n  glGenFramebuffersEXT(1, &textureFBOID);\n  glBindFramebufferEXT(GL_FRAMEBUFFER, textureFBOID);\n  glFramebufferTexture2DEXT(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D,\n                            textureId, 0);\n  bool result =\n      glCheckFramebufferStatusEXT(GL_FRAMEBUFFER) == GL_FRAMEBUFFER_COMPLETE;\n  glDeleteFramebuffersEXT(1, &textureFBOID);\n  glDeleteTextures(1, &textureId);\n\n  glBindFramebufferEXT(GL_FRAMEBUFFER, static_cast<GLuint>(fb_binding));\n  glBindTexture(GL_TEXTURE_2D, static_cast<GLuint>(tex_binding));\n\n  DCHECK(glGetError() == GL_NO_ERROR);\n\n  return result;\n}\n", "target": 0, "idx": 149742}
{"func": " header_put_be_8byte (SF_PRIVATE *psf, sf_count_t x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 8)\n\t{\tpsf->header [psf->headindex++] = (x >> 56) ;\n\t\tpsf->header [psf->headindex++] = (x >> 48) ;\n\t\tpsf->header [psf->headindex++] = (x >> 40) ;\n\t\tpsf->header [psf->headindex++] = (x >> 32) ;\n\t\tpsf->header [psf->headindex++] = (x >> 24) ;\n\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = x ;\n\t\t} ;\n } /* header_put_be_8byte */\n", "target": 1, "idx": 183222}
{"func": "bool NormalPage::IsEmpty() {\n  HeapObjectHeader* header = reinterpret_cast<HeapObjectHeader*>(Payload());\n  return header->IsFree() && header->size() == PayloadSize();\n}\n", "target": 0, "idx": 166745}
{"func": "static ssize_t port_fops_write(struct file *filp, const char __user *ubuf,\n\t\t\t       size_t count, loff_t *offp)\n{\n\tstruct port *port;\n\tstruct port_buffer *buf;\n\tssize_t ret;\n\tbool nonblock;\n\tstruct scatterlist sg[1];\n\n\t/* Userspace could be out to fool us */\n\tif (!count)\n\t\treturn 0;\n\n\tport = filp->private_data;\n\n\tnonblock = filp->f_flags & O_NONBLOCK;\n\n\tret = wait_port_writable(port, nonblock);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcount = min((size_t)(32 * 1024), count);\n\n\tbuf = alloc_buf(port->out_vq, count, 0);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = copy_from_user(buf->buf, ubuf, count);\n\tif (ret) {\n\t\tret = -EFAULT;\n\t\tgoto free_buf;\n\t}\n\n\t/*\n\t * We now ask send_buf() to not spin for generic ports -- we\n\t * can re-use the same code path that non-blocking file\n\t * descriptors take for blocking file descriptors since the\n\t * wait is already done and we're certain the write will go\n\t * through to the host.\n\t */\n\tnonblock = true;\n\tsg_init_one(sg, buf->buf, count);\n\tret = __send_to_port(port, sg, 1, count, buf, nonblock);\n\n\tif (nonblock && ret > 0)\n\t\tgoto out;\n\nfree_buf:\n\tfree_buf(buf, true);\nout:\n\treturn ret;\n}\n", "target": 0, "idx": 66609}
{"func": "void vrend_clear(struct vrend_context *ctx,\n                 unsigned buffers,\n                 const union pipe_color_union *color,\n                 double depth, unsigned stencil)\n{\n   GLbitfield bits = 0;\n\n   if (ctx->in_error)\n      return;\n\n   if (ctx->ctx_switch_pending)\n      vrend_finish_context_switch(ctx);\n\n   glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, ctx->sub->fb_id);\n\n   vrend_update_frontface_state(ctx);\n   if (ctx->sub->stencil_state_dirty)\n      vrend_update_stencil_state(ctx);\n   if (ctx->sub->scissor_state_dirty)\n      vrend_update_scissor_state(ctx);\n   if (ctx->sub->viewport_state_dirty)\n      vrend_update_viewport_state(ctx);\n\n   vrend_use_program(ctx, 0);\n\n   if (buffers & PIPE_CLEAR_COLOR) {\n      if (ctx->sub->nr_cbufs && ctx->sub->surf[0] && vrend_format_is_emulated_alpha(ctx->sub->surf[0]->format)) {\n         glClearColor(color->f[3], 0.0, 0.0, 0.0);\n      } else {\n         glClearColor(color->f[0], color->f[1], color->f[2], color->f[3]);\n      }\n   }\n\n   if (buffers & PIPE_CLEAR_DEPTH) {\n      /* gallium clears don't respect depth mask */\n      glDepthMask(GL_TRUE);\n      glClearDepth(depth);\n   }\n\n   if (buffers & PIPE_CLEAR_STENCIL)\n      glClearStencil(stencil);\n\n   if (buffers & PIPE_CLEAR_COLOR) {\n      uint32_t mask = 0;\n      int i;\n      for (i = 0; i < ctx->sub->nr_cbufs; i++) {\n         if (ctx->sub->surf[i])\n            mask |= (1 << i);\n      }\n      if (mask != (buffers >> 2)) {\n          mask = buffers >> 2;\n          while (mask) {\n             i = u_bit_scan(&mask);\n            if (util_format_is_pure_uint(ctx->sub->surf[i]->format))\n                glClearBufferuiv(GL_COLOR,\n                                 i, (GLuint *)color);\n            else if (util_format_is_pure_sint(ctx->sub->surf[i]->format))\n                glClearBufferiv(GL_COLOR,\n                                 i, (GLint *)color);\n             else\n               glClearBufferfv(GL_COLOR,\n                                i, (GLfloat *)color);\n         }\n      }\n      else\n         bits |= GL_COLOR_BUFFER_BIT;\n   }\n   if (buffers & PIPE_CLEAR_DEPTH)\n      bits |= GL_DEPTH_BUFFER_BIT;\n   if (buffers & PIPE_CLEAR_STENCIL)\n      bits |= GL_STENCIL_BUFFER_BIT;\n\n   if (bits)\n      glClear(bits);\n\n   if (buffers & PIPE_CLEAR_DEPTH)\n      if (!ctx->sub->dsa_state.depth.writemask)\n         glDepthMask(GL_FALSE);\n}\n", "target": 1, "idx": 178130}
{"func": "int ParseWave64HeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)\n{\n    int64_t total_samples = 0, infilesize;\n    Wave64ChunkHeader chunk_header;\n    Wave64FileHeader filehdr;\n    WaveHeader WaveHeader;\n    uint32_t bcount;\n\n    infilesize = DoGetFileSize (infile);\n    memcpy (&filehdr, fourcc, 4);\n\n    if (!DoReadFile (infile, ((char *) &filehdr) + 4, sizeof (Wave64FileHeader) - 4, &bcount) ||\n        bcount != sizeof (Wave64FileHeader) - 4 || memcmp (filehdr.ckID, riff_guid, sizeof (riff_guid)) ||\n        memcmp (filehdr.formType, wave_guid, sizeof (wave_guid))) {\n            error_line (\"%s is not a valid .W64 file!\", infilename);\n            return WAVPACK_SOFT_ERROR;\n    }\n    else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n        !WavpackAddWrapper (wpc, &filehdr, sizeof (filehdr))) {\n            error_line (\"%s\", WavpackGetErrorMessage (wpc));\n            return WAVPACK_SOFT_ERROR;\n    }\n\n#if 1   // this might be a little too picky...\n    WavpackLittleEndianToNative (&filehdr, Wave64ChunkHeaderFormat);\n\n    if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) &&\n        filehdr.ckSize && filehdr.ckSize + 1 && filehdr.ckSize != infilesize) {\n            error_line (\"%s is not a valid .W64 file!\", infilename);\n            return WAVPACK_SOFT_ERROR;\n    }\n#endif\n\n\n    while (1) {\n        if (!DoReadFile (infile, &chunk_header, sizeof (Wave64ChunkHeader), &bcount) ||\n            bcount != sizeof (Wave64ChunkHeader)) {\n                error_line (\"%s is not a valid .W64 file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n        }\n        else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n            !WavpackAddWrapper (wpc, &chunk_header, sizeof (Wave64ChunkHeader))) {\n                error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                return WAVPACK_SOFT_ERROR;\n        }\n\n        WavpackLittleEndianToNative (&chunk_header, Wave64ChunkHeaderFormat);\n        chunk_header.ckSize -= sizeof (chunk_header);\n\n\n        if (!memcmp (chunk_header.ckID, fmt_guid, sizeof (fmt_guid))) {\n            int supported = TRUE, format;\n\n            chunk_header.ckSize = (chunk_header.ckSize + 7) & ~7L;\n\n            if (chunk_header.ckSize < 16 || chunk_header.ckSize > sizeof (WaveHeader) ||\n                !DoReadFile (infile, &WaveHeader, (uint32_t) chunk_header.ckSize, &bcount) ||\n                bcount != chunk_header.ckSize) {\n                    error_line (\"%s is not a valid .W64 file!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, &WaveHeader, (uint32_t) chunk_header.ckSize)) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            WavpackLittleEndianToNative (&WaveHeader, WaveHeaderFormat);\n\n            if (debug_logging_mode) {\n                error_line (\"format tag size = %d\", chunk_header.ckSize);\n                error_line (\"FormatTag = %x, NumChannels = %d, BitsPerSample = %d\",\n                    WaveHeader.FormatTag, WaveHeader.NumChannels, WaveHeader.BitsPerSample);\n                error_line (\"BlockAlign = %d, SampleRate = %d, BytesPerSecond = %d\",\n                    WaveHeader.BlockAlign, WaveHeader.SampleRate, WaveHeader.BytesPerSecond);\n\n                if (chunk_header.ckSize > 16)\n                    error_line (\"cbSize = %d, ValidBitsPerSample = %d\", WaveHeader.cbSize,\n                        WaveHeader.ValidBitsPerSample);\n\n                if (chunk_header.ckSize > 20)\n                    error_line (\"ChannelMask = %x, SubFormat = %d\",\n                        WaveHeader.ChannelMask, WaveHeader.SubFormat);\n            }\n\n            if (chunk_header.ckSize > 16 && WaveHeader.cbSize == 2)\n                config->qmode |= QMODE_ADOBE_MODE;\n\n            format = (WaveHeader.FormatTag == 0xfffe && chunk_header.ckSize == 40) ?\n                WaveHeader.SubFormat : WaveHeader.FormatTag;\n\n            config->bits_per_sample = (chunk_header.ckSize == 40 && WaveHeader.ValidBitsPerSample) ?\n                WaveHeader.ValidBitsPerSample : WaveHeader.BitsPerSample;\n\n            if (format != 1 && format != 3)\n                supported = FALSE;\n\n            if (format == 3 && config->bits_per_sample != 32)\n                supported = FALSE;\n\n            if (!WaveHeader.NumChannels || WaveHeader.NumChannels > 256 ||\n                WaveHeader.BlockAlign / WaveHeader.NumChannels < (config->bits_per_sample + 7) / 8 ||\n                WaveHeader.BlockAlign / WaveHeader.NumChannels > 4 ||\n                WaveHeader.BlockAlign % WaveHeader.NumChannels)\n                    supported = FALSE;\n\n            if (config->bits_per_sample < 1 || config->bits_per_sample > 32)\n                supported = FALSE;\n\n            if (!supported) {\n                error_line (\"%s is an unsupported .W64 format!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            if (chunk_header.ckSize < 40) {\n                if (!config->channel_mask && !(config->qmode & QMODE_CHANS_UNASSIGNED)) {\n                    if (WaveHeader.NumChannels <= 2)\n                        config->channel_mask = 0x5 - WaveHeader.NumChannels;\n                    else if (WaveHeader.NumChannels <= 18)\n                        config->channel_mask = (1 << WaveHeader.NumChannels) - 1;\n                    else\n                        config->channel_mask = 0x3ffff;\n                }\n            }\n            else if (WaveHeader.ChannelMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) {\n                error_line (\"this W64 file already has channel order information!\");\n                return WAVPACK_SOFT_ERROR;\n            }\n            else if (WaveHeader.ChannelMask)\n                config->channel_mask = WaveHeader.ChannelMask;\n\n            if (format == 3)\n                config->float_norm_exp = 127;\n            else if ((config->qmode & QMODE_ADOBE_MODE) &&\n                WaveHeader.BlockAlign / WaveHeader.NumChannels == 4) {\n                    if (WaveHeader.BitsPerSample == 24)\n                        config->float_norm_exp = 127 + 23;\n                    else if (WaveHeader.BitsPerSample == 32)\n                        config->float_norm_exp = 127 + 15;\n            }\n\n            if (debug_logging_mode) {\n                if (config->float_norm_exp == 127)\n                    error_line (\"data format: normalized 32-bit floating point\");\n                else\n                    error_line (\"data format: %d-bit integers stored in %d byte(s)\",\n                        config->bits_per_sample, WaveHeader.BlockAlign / WaveHeader.NumChannels);\n            }\n        }\n        else if (!memcmp (chunk_header.ckID, data_guid, sizeof (data_guid))) { // on the data chunk, get size and exit loop\n\n            if (!WaveHeader.NumChannels) {          // make sure we saw \"fmt\" chunk\n                error_line (\"%s is not a valid .W64 file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            if ((config->qmode & QMODE_IGNORE_LENGTH) || chunk_header.ckSize <= 0) {\n                config->qmode |= QMODE_IGNORE_LENGTH;\n\n                if (infilesize && DoGetFilePosition (infile) != -1)\n                    total_samples = (infilesize - DoGetFilePosition (infile)) / WaveHeader.BlockAlign;\n                else\n                    total_samples = -1;\n            }\n            else {\n                if (infilesize && infilesize - chunk_header.ckSize > 16777216) {\n                    error_line (\"this .W64 file has over 16 MB of extra RIFF data, probably is corrupt!\");\n                    return WAVPACK_SOFT_ERROR;\n                }\n\n                total_samples = chunk_header.ckSize / WaveHeader.BlockAlign;\n\n                if (!total_samples) {\n                    error_line (\"this .W64 file has no audio samples, probably is corrupt!\");\n                    return WAVPACK_SOFT_ERROR;\n                }\n\n                if (total_samples > MAX_WAVPACK_SAMPLES) {\n                    error_line (\"%s has too many samples for WavPack!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n                }\n            }\n\n            config->bytes_per_sample = WaveHeader.BlockAlign / WaveHeader.NumChannels;\n            config->num_channels = WaveHeader.NumChannels;\n            config->sample_rate = WaveHeader.SampleRate;\n            break;\n         }\n         else {          // just copy unknown chunks to output file\n             int bytes_to_copy = (chunk_header.ckSize + 7) & ~7L;\n            char *buff = malloc (bytes_to_copy);\n \n             if (debug_logging_mode)\n                 error_line (\"extra unknown chunk \\\"%c%c%c%c\\\" of %d bytes\",\n                    chunk_header.ckID [0], chunk_header.ckID [1], chunk_header.ckID [2],\n                    chunk_header.ckID [3], chunk_header.ckSize);\n\n            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||\n                bcount != bytes_to_copy ||\n                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    free (buff);\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            free (buff);\n        }\n    }\n\n    if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) {\n        error_line (\"%s: %s\", infilename, WavpackGetErrorMessage (wpc));\n        return WAVPACK_SOFT_ERROR;\n    }\n\n    return WAVPACK_NO_ERROR;\n}\n", "target": 1, "idx": 182423}
{"func": "   void RunBackoffTest(double jitter) {\n     fake_registration_manager_.SetJitter(jitter);\n     ObjectIdSet ids = GetSequenceOfIds(kObjectIdsCount);\n    fake_registration_manager_.SetRegisteredIds(ids);\n \n     ObjectIdSet lost_ids = GetSequenceOfIds(2);\n    LoseRegistrations(lost_ids);\n    ExpectPendingRegistrations(\n        lost_ids, 0.0,\n        fake_registration_manager_.GetPendingRegistrationsForTest());\n\n    fake_registration_manager_.FirePendingRegistrationsForTest();\n    LoseRegistrations(lost_ids);\n\n    double scaled_jitter =\n        jitter * RegistrationManager::kRegistrationDelayMaxJitter;\n\n    double expected_delay =\n        RegistrationManager::kInitialRegistrationDelaySeconds *\n        (1.0 + scaled_jitter);\n    expected_delay = std::floor(expected_delay);\n    ExpectPendingRegistrations(\n        lost_ids, expected_delay,\n        fake_registration_manager_.GetPendingRegistrationsForTest());\n\n    fake_registration_manager_.FirePendingRegistrationsForTest();\n    LoseRegistrations(lost_ids);\n    expected_delay *=\n        RegistrationManager::kRegistrationDelayExponent + scaled_jitter;\n    expected_delay = std::floor(expected_delay);\n    ExpectPendingRegistrations(\n        lost_ids, expected_delay,\n        fake_registration_manager_.GetPendingRegistrationsForTest());\n\n    while (expected_delay < RegistrationManager::kMaxRegistrationDelaySeconds) {\n      fake_registration_manager_.FirePendingRegistrationsForTest();\n      LoseRegistrations(lost_ids);\n      expected_delay *=\n          RegistrationManager::kRegistrationDelayExponent + scaled_jitter;\n      expected_delay = std::floor(expected_delay);\n    }\n    ExpectPendingRegistrations(\n        lost_ids,\n        RegistrationManager::kMaxRegistrationDelaySeconds,\n        fake_registration_manager_.GetPendingRegistrationsForTest());\n  }\n", "target": 1, "idx": 184531}
{"func": "bool InputMethodController::HasComposition() const {\n  return has_composition_ && !composition_range_->collapsed() &&\n         composition_range_->IsConnected();\n}\n", "target": 0, "idx": 135745}
{"func": "content::HeaderInterceptorResult CheckOriginHeader(\n    content::ResourceContext* resource_context,\n    int child_id,\n    const GURL& origin) {\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n\n  if (!origin.SchemeIs(kExtensionScheme))\n    return content::HeaderInterceptorResult::CONTINUE;\n\n  ProfileIOData* io_data = ProfileIOData::FromResourceContext(resource_context);\n  InfoMap* extension_info_map = io_data->GetExtensionInfoMap();\n  const Extension* extension =\n      extension_info_map->extensions().GetExtensionOrAppByURL(origin);\n  if (!extension)\n    return content::HeaderInterceptorResult::FAIL;\n\n  const ProcessMap& process_map = extension_info_map->process_map();\n  if (extension->is_platform_app() &&\n      !process_map.Contains(extension->id(), child_id)) {\n    if (!extension->permissions_data()->HasAPIPermission(\n            extensions::APIPermission::kWebView)) {\n      return content::HeaderInterceptorResult::KILL;\n    }\n\n    std::string owner_extension_id;\n    int owner_process_id;\n    WebViewRendererState::GetInstance()->GetOwnerInfo(\n        child_id, &owner_process_id, &owner_extension_id);\n    const Extension* owner_extension =\n        extension_info_map->extensions().GetByID(owner_extension_id);\n    if (!owner_extension || owner_extension != extension)\n      return content::HeaderInterceptorResult::KILL;\n\n    return content::HeaderInterceptorResult::CONTINUE;\n  }\n\n  return content::HeaderInterceptorResult::CONTINUE;\n}\n", "target": 0, "idx": 163804}
{"func": "static enum entity_charset determine_charset(char *charset_hint TSRMLS_DC)\n{\n\tint i;\n\tenum entity_charset charset = cs_utf_8;\n\tint len = 0;\n\tconst zend_encoding *zenc;\n\n\t/* Default is now UTF-8 */\n\tif (charset_hint == NULL)\n\t\treturn cs_utf_8;\n\n\tif ((len = strlen(charset_hint)) != 0) {\n\t\tgoto det_charset;\n\t}\n\n\tzenc = zend_multibyte_get_internal_encoding(TSRMLS_C);\n\tif (zenc != NULL) {\n\t\tcharset_hint = (char *)zend_multibyte_get_encoding_name(zenc);\n\t\tif (charset_hint != NULL && (len=strlen(charset_hint)) != 0) {\n\t\t\tif ((len == 4) /* sizeof (none|auto|pass) */ &&\n\t\t\t\t\t(!memcmp(\"pass\", charset_hint, 4) ||\n\t\t\t\t\t !memcmp(\"auto\", charset_hint, 4) ||\n\t\t\t\t\t !memcmp(\"auto\", charset_hint, 4))) {\n\t\t\t\tcharset_hint = NULL;\n\t\t\t\tlen = 0;\n\t\t\t} else {\n\t\t\t\tgoto det_charset;\n\t\t\t}\n\t\t}\n\t}\n\n\tcharset_hint = SG(default_charset);\n\tif (charset_hint != NULL && (len=strlen(charset_hint)) != 0) {\n\t\tgoto det_charset;\n\t}\n\n\t/* try to detect the charset for the locale */\n#if HAVE_NL_LANGINFO && HAVE_LOCALE_H && defined(CODESET)\n\tcharset_hint = nl_langinfo(CODESET);\n\tif (charset_hint != NULL && (len=strlen(charset_hint)) != 0) {\n\t\tgoto det_charset;\n\t}\n#endif\n\n#if HAVE_LOCALE_H\n\t/* try to figure out the charset from the locale */\n\t{\n\t\tchar *localename;\n\t\tchar *dot, *at;\n\n\t\t/* lang[_territory][.codeset][@modifier] */\n\t\tlocalename = setlocale(LC_CTYPE, NULL);\n\n\t\tdot = strchr(localename, '.');\n\t\tif (dot) {\n\t\t\tdot++;\n\t\t\t/* locale specifies a codeset */\n\t\t\tat = strchr(dot, '@');\n\t\t\tif (at)\n\t\t\t\tlen = at - dot;\n\t\t\telse\n\t\t\t\tlen = strlen(dot);\n\t\t\tcharset_hint = dot;\n\t\t} else {\n\t\t\t/* no explicit name; see if the name itself\n\t\t\t * is the charset */\n\t\t\tcharset_hint = localename;\n\t\t\tlen = strlen(charset_hint);\n\t\t}\n\t}\n#endif\n\ndet_charset:\n \n \tif (charset_hint) {\n \t\tint found = 0;\n \t\t/* now walk the charset map and look for the codeset */\n \t\tfor (i = 0; charset_map[i].codeset; i++) {\n \t\t\tif (len == strlen(charset_map[i].codeset) && strncasecmp(charset_hint, charset_map[i].codeset, len) == 0) {\n\t\t\t\tcharset = charset_map[i].charset;\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"charset `%s' not supported, assuming utf-8\",\n\t\t\t\t\tcharset_hint);\n\t\t}\n\t}\n\treturn charset;\n}\n", "target": 1, "idx": 180341}
{"func": "static int do_proc_dointvec(struct ctl_table *table, int write,\n\t\t  void __user *buffer, size_t *lenp, loff_t *ppos,\n\t\t  int (*conv)(bool *negp, unsigned long *lvalp, int *valp,\n\t\t\t      int write, void *data),\n\t\t  void *data)\n{\n\treturn __do_proc_dointvec(table->data, table, write,\n\t\t\tbuffer, lenp, ppos, conv, data);\n}\n", "target": 0, "idx": 24410}
{"func": "void USBMountObserver::MountChanged(chromeos::MountLibrary* obj,\n                                    chromeos::MountEventType evt,\n                                    const std::string& path) {\n  if (evt == chromeos::DISK_ADDED) {\n    const chromeos::MountLibrary::DiskVector& disks = obj->disks();\n    for (size_t i = 0; i < disks.size(); ++i) {\n      chromeos::MountLibrary::Disk disk = disks[i];\n      if (disk.device_path == path) {\n        if (disk.is_parent) {\n          if (!disk.has_media) {\n            RemoveBrowserFromVector(disk.system_path);\n          }\n        } else if (!obj->MountPath(path.c_str())) {\n          RemoveBrowserFromVector(disk.system_path);\n        }\n      }\n    }\n    LOG(INFO) << \"Got added mount:\" << path;\n  } else if (evt == chromeos::DISK_REMOVED ||\n             evt == chromeos::DEVICE_REMOVED) {\n    RemoveBrowserFromVector(path);\n   } else if (evt == chromeos::DISK_CHANGED) {\n     BrowserIterator iter = FindBrowserForPath(path);\n     LOG(INFO) << \"Got changed mount:\" << path;\n    if (iter == browsers_.end() && iter->browser) {\n       const chromeos::MountLibrary::DiskVector& disks = obj->disks();\n      for (size_t i = 0; i < disks.size(); ++i) {\n        if (disks[i].device_path == path) {\n          if (!disks[i].mount_path.empty()) {\n            iter = FindBrowserForPath(disks[i].system_path);\n            if (iter != browsers_.end() && iter->browser) {\n              std::string url = kFilebrowseURLHash;\n              url += disks[i].mount_path;\n              TabContents* tab = iter->browser->GetSelectedTabContents();\n              iter->browser->window()->SetBounds(gfx::Rect(\n                  0, 0, FileBrowseUI::kPopupWidth, FileBrowseUI::kPopupHeight));\n              tab->OpenURL(GURL(url), GURL(), CURRENT_TAB,\n                  PageTransition::LINK);\n              tab->NavigateToPendingEntry(NavigationController::RELOAD);\n              iter->device_path = path;\n            } else {\n              OpenFileBrowse(disks[i].mount_path, disks[i].device_path, false);\n            }\n          }\n          return;\n        }\n      }\n    }\n  } else if (evt == chromeos::DEVICE_ADDED) {\n    LOG(INFO) << \"Got device added\" << path;\n    OpenFileBrowse(kFilebrowseScanning, path, true);\n  } else if (evt == chromeos::DEVICE_SCANNED) {\n    LOG(INFO) << \"Got device scanned:\" << path;\n  }\n}\n", "target": 1, "idx": 183490}
{"func": "static void send_ascii_command(const char *buf) {\n    off_t offset = 0;\n    const char* ptr = buf;\n    size_t len = strlen(buf);\n\n    do {\n        ssize_t nw = write(sock, ptr + offset, len - offset);\n        if (nw == -1) {\n            if (errno != EINTR) {\n                fprintf(stderr, \"Failed to write: %s\\n\", strerror(errno));\n                abort();\n            }\n        } else {\n            offset += nw;\n        }\n    } while (offset < len);\n}\n", "target": 0, "idx": 94238}
{"func": "static void blk_mq_hctx_mark_pending(struct blk_mq_hw_ctx *hctx,\n\t\t\t\t     struct blk_mq_ctx *ctx)\n{\n\tstruct blk_align_bitmap *bm = get_bm(hctx, ctx);\n\n\tif (!test_bit(CTX_TO_BIT(hctx, ctx), &bm->word))\n\t\tset_bit(CTX_TO_BIT(hctx, ctx), &bm->word);\n}\n", "target": 0, "idx": 86708}
{"func": "l2tp_framing_cap_print(netdissect_options *ndo, const u_char *dat)\n {\n \tconst uint32_t *ptr = (const uint32_t *)dat;\n \n \tif (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_CAP_ASYNC_MASK) {\n \t\tND_PRINT((ndo, \"A\"));\n \t}\n\tif (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_CAP_SYNC_MASK) {\n\t\tND_PRINT((ndo, \"S\"));\n\t}\n }\n", "target": 1, "idx": 181066}
{"func": "void ObjectBackedNativeHandler::SetPrivate(v8::Local<v8::Context> context,\n                                           v8::Local<v8::Object> obj,\n                                           const char* key,\n                                           v8::Local<v8::Value> value) {\n  obj->SetPrivate(context, v8::Private::ForApi(context->GetIsolate(),\n                                               v8::String::NewFromUtf8(\n                                                   context->GetIsolate(), key)),\n                  value)\n      .FromJust();\n}\n", "target": 0, "idx": 145301}
{"func": "static __init int hardware_setup(void)\n{\n\tint r = -ENOMEM, i, msr;\n\n\trdmsrl_safe(MSR_EFER, &host_efer);\n\n\tfor (i = 0; i < ARRAY_SIZE(vmx_msr_index); ++i)\n\t\tkvm_define_shared_msr(i, vmx_msr_index[i]);\n\n\tvmx_io_bitmap_a = (unsigned long *)__get_free_page(GFP_KERNEL);\n\tif (!vmx_io_bitmap_a)\n\t\treturn r;\n\n\tvmx_io_bitmap_b = (unsigned long *)__get_free_page(GFP_KERNEL);\n\tif (!vmx_io_bitmap_b)\n\t\tgoto out;\n\n\tvmx_msr_bitmap_legacy = (unsigned long *)__get_free_page(GFP_KERNEL);\n\tif (!vmx_msr_bitmap_legacy)\n\t\tgoto out1;\n\n\tvmx_msr_bitmap_legacy_x2apic =\n\t\t\t\t(unsigned long *)__get_free_page(GFP_KERNEL);\n\tif (!vmx_msr_bitmap_legacy_x2apic)\n\t\tgoto out2;\n\n\tvmx_msr_bitmap_longmode = (unsigned long *)__get_free_page(GFP_KERNEL);\n\tif (!vmx_msr_bitmap_longmode)\n\t\tgoto out3;\n\n\tvmx_msr_bitmap_longmode_x2apic =\n\t\t\t\t(unsigned long *)__get_free_page(GFP_KERNEL);\n\tif (!vmx_msr_bitmap_longmode_x2apic)\n\t\tgoto out4;\n\n\tif (nested) {\n\t\tvmx_msr_bitmap_nested =\n\t\t\t(unsigned long *)__get_free_page(GFP_KERNEL);\n\t\tif (!vmx_msr_bitmap_nested)\n\t\t\tgoto out5;\n\t}\n\n\tvmx_vmread_bitmap = (unsigned long *)__get_free_page(GFP_KERNEL);\n\tif (!vmx_vmread_bitmap)\n\t\tgoto out6;\n\n\tvmx_vmwrite_bitmap = (unsigned long *)__get_free_page(GFP_KERNEL);\n\tif (!vmx_vmwrite_bitmap)\n\t\tgoto out7;\n\n\tmemset(vmx_vmread_bitmap, 0xff, PAGE_SIZE);\n\tmemset(vmx_vmwrite_bitmap, 0xff, PAGE_SIZE);\n\n\t/*\n\t * Allow direct access to the PC debug port (it is often used for I/O\n\t * delays, but the vmexits simply slow things down).\n\t */\n\tmemset(vmx_io_bitmap_a, 0xff, PAGE_SIZE);\n\tclear_bit(0x80, vmx_io_bitmap_a);\n\n\tmemset(vmx_io_bitmap_b, 0xff, PAGE_SIZE);\n\n\tmemset(vmx_msr_bitmap_legacy, 0xff, PAGE_SIZE);\n\tmemset(vmx_msr_bitmap_longmode, 0xff, PAGE_SIZE);\n\tif (nested)\n\t\tmemset(vmx_msr_bitmap_nested, 0xff, PAGE_SIZE);\n\n\tif (setup_vmcs_config(&vmcs_config) < 0) {\n\t\tr = -EIO;\n\t\tgoto out8;\n\t}\n\n\tif (boot_cpu_has(X86_FEATURE_NX))\n\t\tkvm_enable_efer_bits(EFER_NX);\n\n\tif (!cpu_has_vmx_vpid())\n\t\tenable_vpid = 0;\n\tif (!cpu_has_vmx_shadow_vmcs())\n\t\tenable_shadow_vmcs = 0;\n\tif (enable_shadow_vmcs)\n\t\tinit_vmcs_shadow_fields();\n\n\tif (!cpu_has_vmx_ept() ||\n\t    !cpu_has_vmx_ept_4levels()) {\n\t\tenable_ept = 0;\n\t\tenable_unrestricted_guest = 0;\n\t\tenable_ept_ad_bits = 0;\n\t}\n\n\tif (!cpu_has_vmx_ept_ad_bits())\n\t\tenable_ept_ad_bits = 0;\n\n\tif (!cpu_has_vmx_unrestricted_guest())\n\t\tenable_unrestricted_guest = 0;\n\n\tif (!cpu_has_vmx_flexpriority())\n\t\tflexpriority_enabled = 0;\n\n\t/*\n\t * set_apic_access_page_addr() is used to reload apic access\n\t * page upon invalidation.  No need to do anything if not\n\t * using the APIC_ACCESS_ADDR VMCS field.\n\t */\n\tif (!flexpriority_enabled)\n\t\tkvm_x86_ops->set_apic_access_page_addr = NULL;\n\n\tif (!cpu_has_vmx_tpr_shadow())\n\t\tkvm_x86_ops->update_cr8_intercept = NULL;\n\n\tif (enable_ept && !cpu_has_vmx_ept_2m_page())\n\t\tkvm_disable_largepages();\n\n\tif (!cpu_has_vmx_ple())\n\t\tple_gap = 0;\n\n\tif (!cpu_has_vmx_apicv())\n\t\tenable_apicv = 0;\n\n\tif (cpu_has_vmx_tsc_scaling()) {\n\t\tkvm_has_tsc_control = true;\n\t\tkvm_max_tsc_scaling_ratio = KVM_VMX_TSC_MULTIPLIER_MAX;\n\t\tkvm_tsc_scaling_ratio_frac_bits = 48;\n\t}\n\n\tvmx_disable_intercept_for_msr(MSR_FS_BASE, false);\n\tvmx_disable_intercept_for_msr(MSR_GS_BASE, false);\n\tvmx_disable_intercept_for_msr(MSR_KERNEL_GS_BASE, true);\n\tvmx_disable_intercept_for_msr(MSR_IA32_SYSENTER_CS, false);\n\tvmx_disable_intercept_for_msr(MSR_IA32_SYSENTER_ESP, false);\n\tvmx_disable_intercept_for_msr(MSR_IA32_SYSENTER_EIP, false);\n\tvmx_disable_intercept_for_msr(MSR_IA32_BNDCFGS, true);\n\n\tmemcpy(vmx_msr_bitmap_legacy_x2apic,\n\t\t\tvmx_msr_bitmap_legacy, PAGE_SIZE);\n\tmemcpy(vmx_msr_bitmap_longmode_x2apic,\n\t\t\tvmx_msr_bitmap_longmode, PAGE_SIZE);\n \n \tset_bit(0, vmx_vpid_bitmap); /* 0 is reserved for host */\n \n\tif (enable_apicv) {\n\t\tfor (msr = 0x800; msr <= 0x8ff; msr++)\n\t\t\tvmx_disable_intercept_msr_read_x2apic(msr);\n\t\t/* According SDM, in x2apic mode, the whole id reg is used.\n\t\t * But in KVM, it only use the highest eight bits. Need to\n\t\t * intercept it */\n\t\tvmx_enable_intercept_msr_read_x2apic(0x802);\n\t\t/* TMCCT */\n\t\tvmx_enable_intercept_msr_read_x2apic(0x839);\n\t\t/* TPR */\n\t\tvmx_disable_intercept_msr_write_x2apic(0x808);\n\t\t/* EOI */\n\t\tvmx_disable_intercept_msr_write_x2apic(0x80b);\n\t\t/* SELF-IPI */\n\t\tvmx_disable_intercept_msr_write_x2apic(0x83f);\n\t}\n \n \tif (enable_ept) {\n \t\tkvm_mmu_set_mask_ptes(0ull,\n\t\t\t(enable_ept_ad_bits) ? VMX_EPT_ACCESS_BIT : 0ull,\n\t\t\t(enable_ept_ad_bits) ? VMX_EPT_DIRTY_BIT : 0ull,\n\t\t\t0ull, VMX_EPT_EXECUTABLE_MASK);\n\t\tept_set_mmio_spte_mask();\n\t\tkvm_enable_tdp();\n\t} else\n\t\tkvm_disable_tdp();\n\n\tupdate_ple_window_actual_max();\n\n\t/*\n\t * Only enable PML when hardware supports PML feature, and both EPT\n\t * and EPT A/D bit features are enabled -- PML depends on them to work.\n\t */\n\tif (!enable_ept || !enable_ept_ad_bits || !cpu_has_vmx_pml())\n\t\tenable_pml = 0;\n\n\tif (!enable_pml) {\n\t\tkvm_x86_ops->slot_enable_log_dirty = NULL;\n\t\tkvm_x86_ops->slot_disable_log_dirty = NULL;\n\t\tkvm_x86_ops->flush_log_dirty = NULL;\n\t\tkvm_x86_ops->enable_log_dirty_pt_masked = NULL;\n\t}\n\n\tkvm_set_posted_intr_wakeup_handler(wakeup_handler);\n\n\treturn alloc_kvm_area();\n\nout8:\n\tfree_page((unsigned long)vmx_vmwrite_bitmap);\nout7:\n\tfree_page((unsigned long)vmx_vmread_bitmap);\nout6:\n\tif (nested)\n\t\tfree_page((unsigned long)vmx_msr_bitmap_nested);\nout5:\n\tfree_page((unsigned long)vmx_msr_bitmap_longmode_x2apic);\nout4:\n\tfree_page((unsigned long)vmx_msr_bitmap_longmode);\nout3:\n\tfree_page((unsigned long)vmx_msr_bitmap_legacy_x2apic);\nout2:\n\tfree_page((unsigned long)vmx_msr_bitmap_legacy);\nout1:\n\tfree_page((unsigned long)vmx_io_bitmap_b);\nout:\n\tfree_page((unsigned long)vmx_io_bitmap_a);\n\n    return r;\n}\n", "target": 1, "idx": 180434}
{"func": "void AppCacheHost::MarkAsForeignEntry(const GURL& document_url,\n                                       int64 cache_document_was_loaded_from) {\n   storage()->MarkEntryAsForeign(\n       main_resource_was_namespace_entry_ ? namespace_entry_url_ : document_url,\n       cache_document_was_loaded_from);\n   SelectCache(document_url, kAppCacheNoCacheId, GURL());\n }\n", "target": 1, "idx": 185616}
{"func": "static int jp2_bpcc_getdata(jp2_box_t *box, jas_stream_t *in)\n {\n \tjp2_bpcc_t *bpcc = &box->data.bpcc;\n \tunsigned int i;\n \tbpcc->numcmpts = box->datalen;\n \tif (!(bpcc->bpcs = jas_alloc2(bpcc->numcmpts, sizeof(uint_fast8_t)))) {\n \t\treturn -1;\n\t}\n\tfor (i = 0; i < bpcc->numcmpts; ++i) {\n\t\tif (jp2_getuint8(in, &bpcc->bpcs[i])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n", "target": 1, "idx": 181492}
{"func": "hash_foreach_prepend_string (gpointer key, gpointer val, gpointer user_data)\n{\n  HashAndString *data = (HashAndString*) user_data;\n  gchar *in = (gchar*) val;\n  g_hash_table_insert (data->hash, g_strdup ((gchar*) key),\n                       g_strjoin (\" \", data->string, in, NULL));\n}\n", "target": 1, "idx": 178258}
{"func": "gst_qtdemux_loop_state_movie (GstQTDemux * qtdemux)\n{\n  GstFlowReturn ret = GST_FLOW_OK;\n  GstBuffer *buf = NULL;\n  QtDemuxStream *stream;\n  guint64 min_time;\n  guint64 offset;\n  guint64 timestamp;\n  guint64 duration;\n  gboolean keyframe;\n  guint size;\n  gint index;\n  gint i;\n\n  gst_qtdemux_push_pending_newsegment (qtdemux);\n\n  /* Figure out the next stream sample to output, min_time is expressed in\n   * global time and runs over the edit list segments. */\n  min_time = G_MAXUINT64;\n  index = -1;\n  for (i = 0; i < qtdemux->n_streams; i++) {\n    guint64 position;\n\n    stream = qtdemux->streams[i];\n    position = stream->time_position;\n\n    /* position of -1 is EOS */\n    if (position != -1 && position < min_time) {\n      min_time = position;\n      index = i;\n    }\n  }\n  /* all are EOS */\n  if (index == -1) {\n    GST_DEBUG_OBJECT (qtdemux, \"all streams are EOS\");\n    goto eos;\n  }\n\n  /* check for segment end */\n  if (qtdemux->segment.stop != -1 && qtdemux->segment.stop < min_time) {\n    GST_DEBUG_OBJECT (qtdemux, \"we reached the end of our segment.\");\n    goto eos;\n  }\n\n  stream = qtdemux->streams[index];\n\n  /* fetch info for the current sample of this stream */\n  if (!gst_qtdemux_prepare_current_sample (qtdemux, stream, &offset, &size,\n          &timestamp, &duration, &keyframe))\n    goto eos;\n\n  GST_LOG_OBJECT (qtdemux,\n      \"pushing from stream %d, offset %\" G_GUINT64_FORMAT\n      \", size %d, timestamp=%\" GST_TIME_FORMAT \", duration %\" GST_TIME_FORMAT,\n      index, offset, size, GST_TIME_ARGS (timestamp), GST_TIME_ARGS (duration));\n\n  /* hmm, empty sample, skip and move to next sample */\n  if (G_UNLIKELY (size <= 0))\n    goto next;\n\n  /* last pushed sample was out of boundary, goto next sample */\n  if (stream->last_ret == GST_FLOW_UNEXPECTED)\n    goto next;\n\n  GST_LOG_OBJECT (qtdemux, \"reading %d bytes @ %\" G_GUINT64_FORMAT, size,\n      offset);\n\n  ret = gst_pad_pull_range (qtdemux->sinkpad, offset, size, &buf);\n  if (ret != GST_FLOW_OK)\n    goto beach;\n\n  if (stream->fourcc == FOURCC_rtsp) {\n    GstMessage *m;\n    gchar *url;\n\n    url = g_strndup ((gchar *) GST_BUFFER_DATA (buf), GST_BUFFER_SIZE (buf));\n\n    /* we have RTSP redirect now */\n    m = gst_message_new_element (GST_OBJECT_CAST (qtdemux),\n        gst_structure_new (\"redirect\",\n            \"new-location\", G_TYPE_STRING, url, NULL));\n    g_free (url);\n\n    gst_element_post_message (GST_ELEMENT_CAST (qtdemux), m);\n  }\n\n  qtdemux->last_ts = min_time;\n  if (qtdemux->segment.rate >= 0) {\n    gst_segment_set_last_stop (&qtdemux->segment, GST_FORMAT_TIME, min_time);\n  }\n  if (stream->pad) {\n    /* we're going to modify the metadata */\n    buf = gst_buffer_make_metadata_writable (buf);\n\n    GST_BUFFER_TIMESTAMP (buf) = timestamp;\n    GST_BUFFER_DURATION (buf) = duration;\n    GST_BUFFER_OFFSET (buf) = -1;\n    GST_BUFFER_OFFSET_END (buf) = -1;\n\n    if (stream->need_clip)\n      buf = gst_qtdemux_clip_buffer (qtdemux, stream, buf);\n\n    if (buf == NULL)\n      goto next;\n\n    if (stream->discont) {\n      GST_LOG_OBJECT (qtdemux, \"marking discont buffer\");\n      GST_BUFFER_FLAG_SET (buf, GST_BUFFER_FLAG_DISCONT);\n      stream->discont = FALSE;\n    }\n\n    if (!keyframe)\n      GST_BUFFER_FLAG_SET (buf, GST_BUFFER_FLAG_DELTA_UNIT);\n\n    gst_buffer_set_caps (buf, stream->caps);\n\n    GST_LOG_OBJECT (qtdemux,\n        \"Pushing buffer with time %\" GST_TIME_FORMAT \", duration %\"\n        GST_TIME_FORMAT \" on pad %s\",\n        GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (buf)),\n        GST_TIME_ARGS (GST_BUFFER_DURATION (buf)), GST_PAD_NAME (stream->pad));\n\n    ret = gst_pad_push (stream->pad, buf);\n  } else {\n    GST_DEBUG_OBJECT (qtdemux, \"No output pad for stream, ignoring\");\n    gst_buffer_unref (buf);\n    ret = GST_FLOW_OK;\n  }\n\n  /* combine flows */\n  ret = gst_qtdemux_combine_flows (qtdemux, stream, ret);\n  /* ignore unlinked, we will not push on the pad anymore and we will EOS when\n   * we have no more data for the pad to push */\n  if (ret == GST_FLOW_UNEXPECTED)\n    ret = GST_FLOW_OK;\n\nnext:\n  gst_qtdemux_advance_sample (qtdemux, stream);\n\nbeach:\n  return ret;\n\n  /* special cases */\neos:\n  {\n    GST_DEBUG_OBJECT (qtdemux, \"No samples left for any streams - EOS\");\n    ret = GST_FLOW_UNEXPECTED;\n    goto beach;\n  }\n}\n", "target": 0, "idx": 4951}
{"func": "void OMXCodec::initOutputFormat(const sp<MetaData> &inputFormat) {\n    mOutputFormat = new MetaData;\n    mOutputFormat->setCString(kKeyDecoderComponent, mComponentName);\n if (mIsEncoder) {\n int32_t timeScale;\n if (inputFormat->findInt32(kKeyTimeScale, &timeScale)) {\n            mOutputFormat->setInt32(kKeyTimeScale, timeScale);\n }\n }\n\n    OMX_PARAM_PORTDEFINITIONTYPE def;\n InitOMXParams(&def);\n    def.nPortIndex = kPortIndexOutput;\n\n status_t err = mOMX->getParameter(\n            mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));\n    CHECK_EQ(err, (status_t)OK);\n\n switch (def.eDomain) {\n case OMX_PortDomainImage:\n {\n            OMX_IMAGE_PORTDEFINITIONTYPE *imageDef = &def.format.image;\n            CHECK_EQ((int)imageDef->eCompressionFormat,\n (int)OMX_IMAGE_CodingUnused);\n\n            mOutputFormat->setCString(kKeyMIMEType, MEDIA_MIMETYPE_VIDEO_RAW);\n            mOutputFormat->setInt32(kKeyColorFormat, imageDef->eColorFormat);\n            mOutputFormat->setInt32(kKeyWidth, imageDef->nFrameWidth);\n            mOutputFormat->setInt32(kKeyHeight, imageDef->nFrameHeight);\n break;\n }\n\n case OMX_PortDomainAudio:\n {\n            OMX_AUDIO_PORTDEFINITIONTYPE *audio_def = &def.format.audio;\n\n if (audio_def->eEncoding == OMX_AUDIO_CodingPCM) {\n                OMX_AUDIO_PARAM_PCMMODETYPE params;\n InitOMXParams(&params);\n                params.nPortIndex = kPortIndexOutput;\n\n                err = mOMX->getParameter(\n                        mNode, OMX_IndexParamAudioPcm, &params, sizeof(params));\n                CHECK_EQ(err, (status_t)OK);\n\n                CHECK_EQ((int)params.eNumData, (int)OMX_NumericalDataSigned);\n                CHECK_EQ(params.nBitPerSample, 16u);\n                CHECK_EQ((int)params.ePCMMode, (int)OMX_AUDIO_PCMModeLinear);\n\n int32_t numChannels, sampleRate;\n                inputFormat->findInt32(kKeyChannelCount, &numChannels);\n                inputFormat->findInt32(kKeySampleRate, &sampleRate);\n\n if ((OMX_U32)numChannels != params.nChannels) {\n                    ALOGV(\"Codec outputs a different number of channels than \"\n \"the input stream contains (contains %d channels, \"\n \"codec outputs %u channels).\",\n                         numChannels, params.nChannels);\n }\n\n if (sampleRate != (int32_t)params.nSamplingRate) {\n                    ALOGV(\"Codec outputs at different sampling rate than \"\n \"what the input stream contains (contains data at \"\n \"%d Hz, codec outputs %u Hz)\",\n                         sampleRate, params.nSamplingRate);\n }\n\n                mOutputFormat->setCString(\n                        kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_RAW);\n\n                mOutputFormat->setInt32(\n                        kKeyChannelCount,\n (mQuirks & kDecoderLiesAboutNumberOfChannels)\n ? numChannels : params.nChannels);\n\n                mOutputFormat->setInt32(kKeySampleRate, params.nSamplingRate);\n } else if (audio_def->eEncoding == OMX_AUDIO_CodingAMR) {\n                OMX_AUDIO_PARAM_AMRTYPE amr;\n InitOMXParams(&amr);\n                amr.nPortIndex = kPortIndexOutput;\n\n                err = mOMX->getParameter(\n                        mNode, OMX_IndexParamAudioAmr, &amr, sizeof(amr));\n                CHECK_EQ(err, (status_t)OK);\n\n                CHECK_EQ(amr.nChannels, 1u);\n                mOutputFormat->setInt32(kKeyChannelCount, 1);\n\n if (amr.eAMRBandMode >= OMX_AUDIO_AMRBandModeNB0\n && amr.eAMRBandMode <= OMX_AUDIO_AMRBandModeNB7) {\n                    mOutputFormat->setCString(\n                            kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_AMR_NB);\n                    mOutputFormat->setInt32(kKeySampleRate, 8000);\n } else if (amr.eAMRBandMode >= OMX_AUDIO_AMRBandModeWB0\n && amr.eAMRBandMode <= OMX_AUDIO_AMRBandModeWB8) {\n                    mOutputFormat->setCString(\n                            kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_AMR_WB);\n                    mOutputFormat->setInt32(kKeySampleRate, 16000);\n } else {\n                    CHECK(!\"Unknown AMR band mode.\");\n }\n } else if (audio_def->eEncoding == OMX_AUDIO_CodingAAC) {\n                mOutputFormat->setCString(\n                        kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_AAC);\n int32_t numChannels, sampleRate, bitRate;\n                inputFormat->findInt32(kKeyChannelCount, &numChannels);\n                inputFormat->findInt32(kKeySampleRate, &sampleRate);\n                inputFormat->findInt32(kKeyBitRate, &bitRate);\n                mOutputFormat->setInt32(kKeyChannelCount, numChannels);\n                mOutputFormat->setInt32(kKeySampleRate, sampleRate);\n                mOutputFormat->setInt32(kKeyBitRate, bitRate);\n } else if (audio_def->eEncoding ==\n (OMX_AUDIO_CODINGTYPE)OMX_AUDIO_CodingAndroidAC3) {\n                mOutputFormat->setCString(\n                        kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_AC3);\n int32_t numChannels, sampleRate, bitRate;\n                inputFormat->findInt32(kKeyChannelCount, &numChannels);\n                inputFormat->findInt32(kKeySampleRate, &sampleRate);\n                inputFormat->findInt32(kKeyBitRate, &bitRate);\n                mOutputFormat->setInt32(kKeyChannelCount, numChannels);\n                mOutputFormat->setInt32(kKeySampleRate, sampleRate);\n                mOutputFormat->setInt32(kKeyBitRate, bitRate);\n } else {\n                CHECK(!\"Should not be here. Unknown audio encoding.\");\n }\n break;\n }\n\n case OMX_PortDomainVideo:\n {\n            OMX_VIDEO_PORTDEFINITIONTYPE *video_def = &def.format.video;\n\n if (video_def->eCompressionFormat == OMX_VIDEO_CodingUnused) {\n                mOutputFormat->setCString(\n                        kKeyMIMEType, MEDIA_MIMETYPE_VIDEO_RAW);\n } else if (video_def->eCompressionFormat == OMX_VIDEO_CodingMPEG4) {\n                mOutputFormat->setCString(\n                        kKeyMIMEType, MEDIA_MIMETYPE_VIDEO_MPEG4);\n } else if (video_def->eCompressionFormat == OMX_VIDEO_CodingH263) {\n                mOutputFormat->setCString(\n                        kKeyMIMEType, MEDIA_MIMETYPE_VIDEO_H263);\n } else if (video_def->eCompressionFormat == OMX_VIDEO_CodingAVC) {\n                mOutputFormat->setCString(\n                        kKeyMIMEType, MEDIA_MIMETYPE_VIDEO_AVC);\n } else {\n                CHECK(!\"Unknown compression format.\");\n }\n\n            mOutputFormat->setInt32(kKeyWidth, video_def->nFrameWidth);\n            mOutputFormat->setInt32(kKeyHeight, video_def->nFrameHeight);\n            mOutputFormat->setInt32(kKeyColorFormat, video_def->eColorFormat);\n\n if (!mIsEncoder) {\n                OMX_CONFIG_RECTTYPE rect;\n InitOMXParams(&rect);\n                rect.nPortIndex = kPortIndexOutput;\n status_t err =\n                        mOMX->getConfig(\n                            mNode, OMX_IndexConfigCommonOutputCrop,\n &rect, sizeof(rect));\n\n                CODEC_LOGI(\"video dimensions are %u x %u\",\n                        video_def->nFrameWidth, video_def->nFrameHeight);\n\n if (err == OK) {\n                    CHECK_GE(rect.nLeft, 0);\n                    CHECK_GE(rect.nTop, 0);\n                    CHECK_GE(rect.nWidth, 0u);\n                    CHECK_GE(rect.nHeight, 0u);\n                    CHECK_LE(rect.nLeft + rect.nWidth - 1, video_def->nFrameWidth);\n                    CHECK_LE(rect.nTop + rect.nHeight - 1, video_def->nFrameHeight);\n\n                    mOutputFormat->setRect(\n                            kKeyCropRect,\n                            rect.nLeft,\n                            rect.nTop,\n                            rect.nLeft + rect.nWidth - 1,\n                            rect.nTop + rect.nHeight - 1);\n\n                    CODEC_LOGI(\"Crop rect is %u x %u @ (%d, %d)\",\n                            rect.nWidth, rect.nHeight, rect.nLeft, rect.nTop);\n } else {\n                    mOutputFormat->setRect(\n                            kKeyCropRect,\n 0, 0,\n                            video_def->nFrameWidth - 1,\n                            video_def->nFrameHeight - 1);\n }\n\n if (mNativeWindow != NULL) {\n                     initNativeWindowCrop();\n }\n }\n break;\n }\n\n default:\n {\n            CHECK(!\"should not be here, neither audio nor video.\");\n break;\n }\n }\n\n\n int32_t rotationDegrees;\n if (mSource->getFormat()->findInt32(kKeyRotation, &rotationDegrees)) {\n        mOutputFormat->setInt32(kKeyRotation, rotationDegrees);\n }\n}\n", "target": 0, "idx": 171346}
{"func": "static int efx_register_netdev(struct efx_nic *efx)\n{\n\tstruct net_device *net_dev = efx->net_dev;\n\tstruct efx_channel *channel;\n\tint rc;\n\n\tnet_dev->watchdog_timeo = 5 * HZ;\n \tnet_dev->irq = efx->pci_dev->irq;\n \tnet_dev->netdev_ops = &efx_netdev_ops;\n \tSET_ETHTOOL_OPS(net_dev, &efx_ethtool_ops);\n \n \t/* Clear MAC statistics */\n \tefx->mac_op->update_stats(efx);\n\tmemset(&efx->mac_stats, 0, sizeof(efx->mac_stats));\n\n\trtnl_lock();\n\n\trc = dev_alloc_name(net_dev, net_dev->name);\n\tif (rc < 0)\n\t\tgoto fail_locked;\n\tefx_update_name(efx);\n\n\trc = register_netdevice(net_dev);\n\tif (rc)\n\t\tgoto fail_locked;\n\n\tefx_for_each_channel(channel, efx) {\n\t\tstruct efx_tx_queue *tx_queue;\n\t\tefx_for_each_channel_tx_queue(tx_queue, channel)\n\t\t\tefx_init_tx_queue_core_txq(tx_queue);\n\t}\n\n\t/* Always start with carrier off; PHY events will detect the link */\n\tnetif_carrier_off(efx->net_dev);\n\n\trtnl_unlock();\n\n\trc = device_create_file(&efx->pci_dev->dev, &dev_attr_phy_type);\n\tif (rc) {\n\t\tnetif_err(efx, drv, efx->net_dev,\n\t\t\t  \"failed to init net dev attributes\\n\");\n\t\tgoto fail_registered;\n\t}\n\n\treturn 0;\n\nfail_locked:\n\trtnl_unlock();\n\tnetif_err(efx, drv, efx->net_dev, \"could not register net dev\\n\");\n\treturn rc;\n\nfail_registered:\n\tunregister_netdev(net_dev);\n\treturn rc;\n}\n", "target": 1, "idx": 178757}
{"func": " static zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof TSRMLS_DC)\n {\n\tchar *ksep, *vsep, *val;\n \tsize_t klen, vlen;\n \t/* FIXME: string-size_t */\n \tunsigned int new_vlen;\n\n\tif (var->ptr >= var->end) {\n \t\treturn 0;\n \t}\n \n\tvsep = memchr(var->ptr, '&', var->end - var->ptr);\n \tif (!vsep) {\n \t\tif (!eof) {\n \t\t\treturn 0;\n \t\t} else {\n \t\t\tvsep = var->end;\n\t\t}\n\t}\n\n\tksep = memchr(var->ptr, '=', vsep - var->ptr);\n\tif (ksep) {\n\t\t*ksep = '\\0';\n\t\t/* \"foo=bar&\" or \"foo=&\" */\n\t\tklen = ksep - var->ptr;\n\t\tvlen = vsep - ++ksep;\n\t} else {\n\t\tksep = \"\";\n\t\t/* \"foo&\" */\n\t\tklen = vsep - var->ptr;\n\t\tvlen = 0;\n\t}\n\n\tphp_url_decode(var->ptr, klen);\n\n\tval = estrndup(ksep, vlen);\n\tif (vlen) {\n\t\tvlen = php_url_decode(val, vlen);\n\t}\n\n\tif (sapi_module.input_filter(PARSE_POST, var->ptr, &val, vlen, &new_vlen TSRMLS_CC)) {\n\t\tphp_register_variable_safe(var->ptr, val, new_vlen, arr TSRMLS_CC);\n\t}\n \tefree(val);\n \n \tvar->ptr = vsep + (vsep != var->end);\n \treturn 1;\n }\n", "target": 1, "idx": 181226}
{"func": "void AutofillExternalDelegate::OnSuggestionsReturned(\n    int query_id,\n    const std::vector<Suggestion>& input_suggestions,\n    bool autoselect_first_suggestion,\n    bool is_all_server_suggestions) {\n  if (query_id != query_id_)\n    return;\n\n  std::vector<Suggestion> suggestions(input_suggestions);\n\n   PossiblyRemoveAutofillWarnings(&suggestions);\n \n#if !defined(OS_ANDROID)\n  if (!suggestions.empty() && !features::ShouldUseNativeViews()) {\n    suggestions.push_back(Suggestion());\n    suggestions.back().frontend_id = POPUP_ITEM_ID_SEPARATOR;\n  }\n#endif\n   if (should_show_scan_credit_card_) {\n     Suggestion scan_credit_card(\n         l10n_util::GetStringUTF16(IDS_AUTOFILL_SCAN_CREDIT_CARD));\n    scan_credit_card.frontend_id = POPUP_ITEM_ID_SCAN_CREDIT_CARD;\n    scan_credit_card.icon = base::ASCIIToUTF16(\"scanCreditCardIcon\");\n    suggestions.push_back(scan_credit_card);\n  }\n\n  has_autofill_suggestions_ = false;\n  for (size_t i = 0; i < suggestions.size(); ++i) {\n    if (suggestions[i].frontend_id > 0) {\n      has_autofill_suggestions_ = true;\n      break;\n    }\n  }\n\n  if (should_show_cards_from_account_option_) {\n    suggestions.emplace_back(\n        l10n_util::GetStringUTF16(IDS_AUTOFILL_SHOW_ACCOUNT_CARDS));\n    suggestions.back().frontend_id = POPUP_ITEM_ID_SHOW_ACCOUNT_CARDS;\n    suggestions.back().icon = base::ASCIIToUTF16(\"google\");\n  }\n\n  if (has_autofill_suggestions_)\n    ApplyAutofillOptions(&suggestions, is_all_server_suggestions);\n\n   if (suggestions.empty() && should_show_cc_signin_promo_) {\n#if !defined(OS_ANDROID)\n    if (has_autofill_suggestions_) {\n      suggestions.push_back(Suggestion());\n      suggestions.back().frontend_id = POPUP_ITEM_ID_SEPARATOR;\n    }\n#endif\n     Suggestion signin_promo_suggestion(\n         l10n_util::GetStringUTF16(IDS_AUTOFILL_CREDIT_CARD_SIGNIN_PROMO));\n     signin_promo_suggestion.frontend_id =\n        POPUP_ITEM_ID_CREDIT_CARD_SIGNIN_PROMO;\n    suggestions.push_back(signin_promo_suggestion);\n    signin_metrics::RecordSigninImpressionUserActionForAccessPoint(\n         signin_metrics::AccessPoint::ACCESS_POINT_AUTOFILL_DROPDOWN);\n   }\n \n#if !defined(OS_ANDROID)\n  if (!suggestions.empty() &&\n      suggestions.back().frontend_id == POPUP_ITEM_ID_SEPARATOR) {\n    suggestions.pop_back();\n  }\n#endif\n  InsertDataListValues(&suggestions);\n\n  if (suggestions.empty()) {\n    manager_->client()->HideAutofillPopup();\n    return;\n  }\n\n  if (query_field_.is_focusable) {\n    manager_->client()->ShowAutofillPopup(\n        element_bounds_, query_field_.text_direction, suggestions,\n        autoselect_first_suggestion, GetWeakPtr());\n  }\n}\n", "target": 1, "idx": 186010}
{"func": "bool Part::openFile()\n{\n    qCDebug(ARK) << \"Attempting to open archive\" << localFilePath();\n\n    resetGui();\n\n    if (!isLocalFileValid()) {\n        return false;\n    }\n\n    const bool creatingNewArchive = arguments().metaData()[QStringLiteral(\"createNewArchive\")] == QLatin1String(\"true\");\n\n    if (creatingNewArchive) {\n        createArchive();\n    } else {\n        loadArchive();\n    }\n\n    return true;\n}\n", "target": 0, "idx": 9907}
{"func": "void GpuChannel::OnInitialize(base::ProcessHandle renderer_process) {\n  DCHECK(!renderer_process_);\n  if (base::GetProcId(renderer_process) == renderer_pid_)\n    renderer_process_ = renderer_process;\n}\n", "target": 1, "idx": 184561}
{"func": "char *am_reconstruct_url(request_rec *r)\n{\n    char *url;\n\n    /* This function will construct an full url for a given path relative to\n     * the root of the web site. To configure what hostname and port this\n     * function will use, see the UseCanonicalName configuration directive.\n     */\n    url = ap_construct_url(r->pool, r->unparsed_uri, r);\n\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,\n                  \"reconstruct_url: url==\\\"%s\\\", unparsed_uri==\\\"%s\\\"\", url,\n                  r->unparsed_uri);\n    return url;\n}\n", "target": 0, "idx": 91721}
{"func": "static int mxf_read_primer_pack(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFContext *mxf = arg;\n    int item_num = avio_rb32(pb);\n    int item_len = avio_rb32(pb);\n\n    if (item_len != 18) {\n         avpriv_request_sample(pb, \"Primer pack item length %d\", item_len);\n         return AVERROR_PATCHWELCOME;\n     }\n    if (item_num > 65536) {\n         av_log(mxf->fc, AV_LOG_ERROR, \"item_num %d is too large\\n\", item_num);\n         return AVERROR_INVALIDDATA;\n     }\n    if (mxf->local_tags)\n        av_log(mxf->fc, AV_LOG_VERBOSE, \"Multiple primer packs\\n\");\n    av_free(mxf->local_tags);\n    mxf->local_tags_count = 0;\n    mxf->local_tags = av_calloc(item_num, item_len);\n    if (!mxf->local_tags)\n        return AVERROR(ENOMEM);\n    mxf->local_tags_count = item_num;\n    avio_read(pb, mxf->local_tags, item_num*item_len);\n    return 0;\n}\n", "target": 1, "idx": 180938}
{"func": "static int load_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n \t\t\t\t   u16 selector, int seg)\n {\n \tu8 cpl = ctxt->ops->cpl(ctxt);\n\treturn __load_segment_descriptor(ctxt, selector, seg, cpl, false);\n }\n", "target": 1, "idx": 179513}
{"func": "dhcp6opt_print(netdissect_options *ndo,\n               const u_char *cp, const u_char *ep)\n{\n\tconst struct dhcp6opt *dh6o;\n\tconst u_char *tp;\n\tsize_t i;\n\tuint16_t opttype;\n\tsize_t optlen;\n\tuint8_t auth_proto;\n\tu_int authinfolen, authrealmlen;\n\tint remain_len;  /* Length of remaining options */\n\tint label_len;   /* Label length */\n\tuint16_t subopt_code;\n\tuint16_t subopt_len;\n\n\tif (cp == ep)\n\t\treturn;\n\twhile (cp < ep) {\n\t\tif (ep < cp + sizeof(*dh6o))\n\t\t\tgoto trunc;\n\t\tdh6o = (const struct dhcp6opt *)cp;\n\t\tND_TCHECK(*dh6o);\n\t\toptlen = EXTRACT_16BITS(&dh6o->dh6opt_len);\n\t\tif (ep < cp + sizeof(*dh6o) + optlen)\n\t\t\tgoto trunc;\n\t\topttype = EXTRACT_16BITS(&dh6o->dh6opt_type);\n\t\tND_PRINT((ndo, \" (%s\", tok2str(dh6opt_str, \"opt_%u\", opttype)));\n\t\tND_TCHECK2(*(cp + sizeof(*dh6o)), optlen);\n\t\tswitch (opttype) {\n\t\tcase DH6OPT_CLIENTID:\n\t\tcase DH6OPT_SERVERID:\n\t\t\tif (optlen < 2) {\n\t\t\t\t/*(*/\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tswitch (EXTRACT_16BITS(tp)) {\n\t\t\tcase 1:\n\t\t\t\tif (optlen >= 2 + 6) {\n\t\t\t\t\tND_PRINT((ndo, \" hwaddr/time type %u time %u \",\n\t\t\t\t\t    EXTRACT_16BITS(&tp[2]),\n\t\t\t\t\t    EXTRACT_32BITS(&tp[4])));\n\t\t\t\t\tfor (i = 8; i < optlen; i++)\n\t\t\t\t\t\tND_PRINT((ndo, \"%02x\", tp[i]));\n\t\t\t\t\t/*(*/\n\t\t\t\t\tND_PRINT((ndo, \")\"));\n\t\t\t\t} else {\n\t\t\t\t\t/*(*/\n\t\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tif (optlen >= 2 + 8) {\n\t\t\t\t\tND_PRINT((ndo, \" vid \"));\n\t\t\t\t\tfor (i = 2; i < 2 + 8; i++)\n\t\t\t\t\t\tND_PRINT((ndo, \"%02x\", tp[i]));\n\t\t\t\t\t/*(*/\n\t\t\t\t\tND_PRINT((ndo, \")\"));\n\t\t\t\t} else {\n\t\t\t\t\t/*(*/\n\t\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tif (optlen >= 2 + 2) {\n\t\t\t\t\tND_PRINT((ndo, \" hwaddr type %u \",\n\t\t\t\t\t    EXTRACT_16BITS(&tp[2])));\n\t\t\t\t\tfor (i = 4; i < optlen; i++)\n\t\t\t\t\t\tND_PRINT((ndo, \"%02x\", tp[i]));\n\t\t\t\t\t/*(*/\n\t\t\t\t\tND_PRINT((ndo, \")\"));\n\t\t\t\t} else {\n\t\t\t\t\t/*(*/\n\t\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tND_PRINT((ndo, \" type %d)\", EXTRACT_16BITS(tp)));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DH6OPT_IA_ADDR:\n\t\t\tif (optlen < 24) {\n\t\t\t\t/*(*/\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tND_PRINT((ndo, \" %s\", ip6addr_string(ndo, &tp[0])));\n\t\t\tND_PRINT((ndo, \" pltime:%u vltime:%u\",\n\t\t\t    EXTRACT_32BITS(&tp[16]),\n\t\t\t    EXTRACT_32BITS(&tp[20])));\n\t\t\tif (optlen > 24) {\n\t\t\t\t/* there are sub-options */\n\t\t\t\tdhcp6opt_print(ndo, tp + 24, tp + optlen);\n\t\t\t}\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_ORO:\n\t\tcase DH6OPT_ERO:\n\t\t\tif (optlen % 2) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tfor (i = 0; i < optlen; i += 2) {\n\t\t\t\tND_PRINT((ndo, \" %s\",\n\t\t\t\t    tok2str(dh6opt_str, \"opt_%u\", EXTRACT_16BITS(&tp[i]))));\n\t\t\t}\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_PREFERENCE:\n\t\t\tif (optlen != 1) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tND_PRINT((ndo, \" %d)\", *tp));\n\t\t\tbreak;\n\t\tcase DH6OPT_ELAPSED_TIME:\n\t\t\tif (optlen != 2) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tND_PRINT((ndo, \" %d)\", EXTRACT_16BITS(tp)));\n\t\t\tbreak;\n\t\tcase DH6OPT_RELAY_MSG:\n\t\t\tND_PRINT((ndo, \" (\"));\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tdhcp6_print(ndo, tp, optlen);\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_AUTH:\n\t\t\tif (optlen < 11) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tauth_proto = *tp;\n\t\t\tswitch (auth_proto) {\n\t\t\tcase DH6OPT_AUTHPROTO_DELAYED:\n\t\t\t\tND_PRINT((ndo, \" proto: delayed\"));\n\t\t\t\tbreak;\n\t\t\tcase DH6OPT_AUTHPROTO_RECONFIG:\n\t\t\t\tND_PRINT((ndo, \" proto: reconfigure\"));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tND_PRINT((ndo, \" proto: %d\", auth_proto));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp++;\n\t\t\tswitch (*tp) {\n\t\t\tcase DH6OPT_AUTHALG_HMACMD5:\n\t\t\t\t/* XXX: may depend on the protocol */\n\t\t\t\tND_PRINT((ndo, \", alg: HMAC-MD5\"));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tND_PRINT((ndo, \", alg: %d\", *tp));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp++;\n\t\t\tswitch (*tp) {\n\t\t\tcase DH6OPT_AUTHRDM_MONOCOUNTER:\n\t\t\t\tND_PRINT((ndo, \", RDM: mono\"));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tND_PRINT((ndo, \", RDM: %d\", *tp));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp++;\n\t\t\tND_PRINT((ndo, \", RD:\"));\n\t\t\tfor (i = 0; i < 4; i++, tp += 2)\n\t\t\t\tND_PRINT((ndo, \" %04x\", EXTRACT_16BITS(tp)));\n\n\t\t\t/* protocol dependent part */\n\t\t\tauthinfolen = optlen - 11;\n\t\t\tswitch (auth_proto) {\n\t\t\tcase DH6OPT_AUTHPROTO_DELAYED:\n\t\t\t\tif (authinfolen == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tif (authinfolen < 20) {\n\t\t\t\t\tND_PRINT((ndo, \" ??\"));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tauthrealmlen = authinfolen - 20;\n\t\t\t\tif (authrealmlen > 0) {\n\t\t\t\t\tND_PRINT((ndo, \", realm: \"));\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < authrealmlen; i++, tp++)\n\t\t\t\t\tND_PRINT((ndo, \"%02x\", *tp));\n\t\t\t\tND_PRINT((ndo, \", key ID: %08x\", EXTRACT_32BITS(tp)));\n\t\t\t\ttp += 4;\n\t\t\t\tND_PRINT((ndo, \", HMAC-MD5:\"));\n\t\t\t\tfor (i = 0; i < 4; i++, tp+= 4)\n\t\t\t\t\tND_PRINT((ndo, \" %08x\", EXTRACT_32BITS(tp)));\n\t\t\t\tbreak;\n\t\t\tcase DH6OPT_AUTHPROTO_RECONFIG:\n\t\t\t\tif (authinfolen != 17) {\n\t\t\t\t\tND_PRINT((ndo, \" ??\"));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tswitch (*tp++) {\n\t\t\t\tcase DH6OPT_AUTHRECONFIG_KEY:\n\t\t\t\t\tND_PRINT((ndo, \" reconfig-key\"));\n\t\t\t\t\tbreak;\n\t\t\t\tcase DH6OPT_AUTHRECONFIG_HMACMD5:\n\t\t\t\t\tND_PRINT((ndo, \" type: HMAC-MD5\"));\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tND_PRINT((ndo, \" type: ??\"));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tND_PRINT((ndo, \" value:\"));\n\t\t\t\tfor (i = 0; i < 4; i++, tp+= 4)\n\t\t\t\t\tND_PRINT((ndo, \" %08x\", EXTRACT_32BITS(tp)));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tND_PRINT((ndo, \" ??\"));\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_RAPID_COMMIT: /* nothing todo */\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_INTERFACE_ID:\n\t\tcase DH6OPT_SUBSCRIBER_ID:\n\t\t\t/*\n\t\t\t * Since we cannot predict the encoding, print hex dump\n\t\t\t * at most 10 characters.\n\t\t\t */\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tND_PRINT((ndo, \" \"));\n\t\t\tfor (i = 0; i < optlen && i < 10; i++)\n\t\t\t\tND_PRINT((ndo, \"%02x\", tp[i]));\n \t\t\tND_PRINT((ndo, \"...)\"));\n \t\t\tbreak;\n \t\tcase DH6OPT_RECONF_MSG:\n \t\t\ttp = (const u_char *)(dh6o + 1);\n \t\t\tswitch (*tp) {\n \t\t\tcase DH6_RENEW:\n\t\t\t\tND_PRINT((ndo, \" for renew)\"));\n\t\t\t\tbreak;\n\t\t\tcase DH6_INFORM_REQ:\n\t\t\t\tND_PRINT((ndo, \" for inf-req)\"));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tND_PRINT((ndo, \" for ?\\?\\?(%02x))\", *tp));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DH6OPT_RECONF_ACCEPT: /* nothing todo */\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_SIP_SERVER_A:\n\t\tcase DH6OPT_DNS_SERVERS:\n\t\tcase DH6OPT_SNTP_SERVERS:\n\t\tcase DH6OPT_NIS_SERVERS:\n\t\tcase DH6OPT_NISP_SERVERS:\n\t\tcase DH6OPT_BCMCS_SERVER_A:\n\t\tcase DH6OPT_PANA_AGENT:\n\t\tcase DH6OPT_LQ_CLIENT_LINK:\n\t\t\tif (optlen % 16) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tfor (i = 0; i < optlen; i += 16)\n\t\t\t\tND_PRINT((ndo, \" %s\", ip6addr_string(ndo, &tp[i])));\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_SIP_SERVER_D:\n\t\tcase DH6OPT_DOMAIN_LIST:\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\twhile (tp < cp + sizeof(*dh6o) + optlen) {\n\t\t\t\tND_PRINT((ndo, \" \"));\n\t\t\t\tif ((tp = ns_nprint(ndo, tp, cp + sizeof(*dh6o) + optlen)) == NULL)\n\t\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_STATUS_CODE:\n\t\t\tif (optlen < 2) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tND_PRINT((ndo, \" %s)\", dhcp6stcode(EXTRACT_16BITS(&tp[0]))));\n\t\t\tbreak;\n\t\tcase DH6OPT_IA_NA:\n\t\tcase DH6OPT_IA_PD:\n\t\t\tif (optlen < 12) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tND_PRINT((ndo, \" IAID:%u T1:%u T2:%u\",\n\t\t\t    EXTRACT_32BITS(&tp[0]),\n\t\t\t    EXTRACT_32BITS(&tp[4]),\n\t\t\t    EXTRACT_32BITS(&tp[8])));\n\t\t\tif (optlen > 12) {\n\t\t\t\t/* there are sub-options */\n\t\t\t\tdhcp6opt_print(ndo, tp + 12, tp + optlen);\n\t\t\t}\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_IA_TA:\n\t\t\tif (optlen < 4) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tND_PRINT((ndo, \" IAID:%u\", EXTRACT_32BITS(tp)));\n\t\t\tif (optlen > 4) {\n\t\t\t\t/* there are sub-options */\n\t\t\t\tdhcp6opt_print(ndo, tp + 4, tp + optlen);\n\t\t\t}\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_IA_PD_PREFIX:\n\t\t\tif (optlen < 25) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tND_PRINT((ndo, \" %s/%d\", ip6addr_string(ndo, &tp[9]), tp[8]));\n\t\t\tND_PRINT((ndo, \" pltime:%u vltime:%u\",\n\t\t\t    EXTRACT_32BITS(&tp[0]),\n\t\t\t    EXTRACT_32BITS(&tp[4])));\n\t\t\tif (optlen > 25) {\n\t\t\t\t/* there are sub-options */\n\t\t\t\tdhcp6opt_print(ndo, tp + 25, tp + optlen);\n\t\t\t}\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_LIFETIME:\n\t\tcase DH6OPT_CLT_TIME:\n\t\t\tif (optlen != 4) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tND_PRINT((ndo, \" %d)\", EXTRACT_32BITS(tp)));\n\t\t\tbreak;\n\t\tcase DH6OPT_REMOTE_ID:\n\t\t\tif (optlen < 4) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tND_PRINT((ndo, \" %d \", EXTRACT_32BITS(tp)));\n\t\t\t/*\n\t\t\t * Print hex dump first 10 characters.\n\t\t\t */\n\t\t\tfor (i = 4; i < optlen && i < 14; i++)\n\t\t\t\tND_PRINT((ndo, \"%02x\", tp[i]));\n\t\t\tND_PRINT((ndo, \"...)\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_LQ_QUERY:\n\t\t\tif (optlen < 17) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tswitch (*tp) {\n\t\t\tcase 1:\n\t\t\t\tND_PRINT((ndo, \" by-address\"));\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tND_PRINT((ndo, \" by-clientID\"));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tND_PRINT((ndo, \" type_%d\", (int)*tp));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \" %s\", ip6addr_string(ndo, &tp[1])));\n\t\t\tif (optlen > 17) {\n\t\t\t\t/* there are query-options */\n\t\t\t\tdhcp6opt_print(ndo, tp + 17, tp + optlen);\n\t\t\t}\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_CLIENT_DATA:\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tif (optlen > 0) {\n\t\t\t\t/* there are encapsulated options */\n\t\t\t\tdhcp6opt_print(ndo, tp, tp + optlen);\n\t\t\t}\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_LQ_RELAY_DATA:\n\t\t\tif (optlen < 16) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tND_PRINT((ndo, \" %s \", ip6addr_string(ndo, &tp[0])));\n\t\t\t/*\n\t\t\t * Print hex dump first 10 characters.\n\t\t\t */\n\t\t\tfor (i = 16; i < optlen && i < 26; i++)\n\t\t\t\tND_PRINT((ndo, \"%02x\", tp[i]));\n\t\t\tND_PRINT((ndo, \"...)\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_NTP_SERVER:\n\t\t\tif (optlen < 4) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\twhile (tp < cp + sizeof(*dh6o) + optlen - 4) {\n\t\t\t\tsubopt_code = EXTRACT_16BITS(tp);\n\t\t\t\ttp += 2;\n\t\t\t\tsubopt_len = EXTRACT_16BITS(tp);\n\t\t\t\ttp += 2;\n\t\t\t\tif (tp + subopt_len > cp + sizeof(*dh6o) + optlen)\n\t\t\t\t\tgoto trunc;\n\t\t\t\tND_PRINT((ndo, \" subopt:%d\", subopt_code));\n\t\t\t\tswitch (subopt_code) {\n\t\t\t\tcase DH6OPT_NTP_SUBOPTION_SRV_ADDR:\n\t\t\t\tcase DH6OPT_NTP_SUBOPTION_MC_ADDR:\n\t\t\t\t\tif (subopt_len != 16) {\n\t\t\t\t\t\tND_PRINT((ndo, \" ?\"));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tND_PRINT((ndo, \" %s\", ip6addr_string(ndo, &tp[0])));\n\t\t\t\t\tbreak;\n\t\t\t\tcase DH6OPT_NTP_SUBOPTION_SRV_FQDN:\n\t\t\t\t\tND_PRINT((ndo, \" \"));\n\t\t\t\t\tif (ns_nprint(ndo, tp, tp + subopt_len) == NULL)\n\t\t\t\t\t\tgoto trunc;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tND_PRINT((ndo, \" ?\"));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttp += subopt_len;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_AFTR_NAME:\n\t\t\tif (optlen < 3) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tremain_len = optlen;\n\t\t\tND_PRINT((ndo, \" \"));\n\t\t\t/* Encoding is described in section 3.1 of RFC 1035 */\n\t\t\twhile (remain_len && *tp) {\n\t\t\t\tlabel_len =  *tp++;\n\t\t\t\tif (label_len < remain_len - 1) {\n\t\t\t\t\t(void)fn_printn(ndo, tp, label_len, NULL);\n\t\t\t\t\ttp += label_len;\n\t\t\t\t\tremain_len -= (label_len + 1);\n\t\t\t\t\tif(*tp) ND_PRINT((ndo, \".\"));\n\t\t\t\t} else {\n\t\t\t\t\tND_PRINT((ndo, \" ?\"));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_NEW_POSIX_TIMEZONE: /* all three of these options */\n\t\tcase DH6OPT_NEW_TZDB_TIMEZONE:\t/* are encoded similarly */\n\t\tcase DH6OPT_MUDURL:\t\t/* although GMT might not work */\n\t\t        if (optlen < 5) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tND_PRINT((ndo, \"=\"));\n\t\t\t(void)fn_printn(ndo, tp, (u_int)optlen, NULL);\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\t}\n\n\t\tcp += sizeof(*dh6o) + optlen;\n\t}\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \"[|dhcp6ext]\"));\n}\n", "target": 1, "idx": 181047}
{"func": "static unsigned long capacity_orig_of(int cpu)\n{\n\treturn cpu_rq(cpu)->cpu_capacity_orig;\n}\n", "target": 0, "idx": 92476}
{"func": "void RenderFrameHostImpl::OnEnforceInsecureRequestPolicy(\n    blink::WebInsecureRequestPolicy policy) {\n  frame_tree_node()->SetInsecureRequestPolicy(policy);\n}\n", "target": 0, "idx": 138753}
{"func": "void PluginInstance::OnTimerCall(void (*func)(NPP id, uint32 timer_id),\n                                 NPP id,\n                                 uint32 timer_id) {\n  TimerMap::iterator it = timers_.find(timer_id);\n  if (it == timers_.end())\n    return;\n\n  TimerInfo info = it->second;\n\n  func(id, timer_id);\n\n  if (timers_.find(timer_id) == timers_.end())\n    return;\n\n   if (info.repeat) {\n    message_loop_->PostDelayedTask(FROM_HERE,\n                                   NewRunnableMethod(\n                                       this,\n                                       &PluginInstance::OnTimerCall,\n                                       func,\n                                       npp_,\n                                       timer_id),\n                                   info.interval);\n   } else {\n     timers_.erase(it);\n   }\n}\n", "target": 1, "idx": 183587}
{"func": "void BlockPainter::PaintScrollHitTestDisplayItem(const PaintInfo& paint_info) {\n  DCHECK(RuntimeEnabledFeatures::SlimmingPaintV2Enabled());\n\n  if (paint_info.GetGlobalPaintFlags() & kGlobalPaintFlattenCompositingLayers)\n    return;\n\n\n  const auto* fragment = paint_info.FragmentToPaint(layout_block_);\n  const auto* properties = fragment ? fragment->PaintProperties() : nullptr;\n\n  if (properties && properties->Scroll()) {\n    DCHECK(properties->ScrollTranslation());\n    ScopedPaintChunkProperties scroll_hit_test_properties(\n        paint_info.context.GetPaintController(),\n        fragment->LocalBorderBoxProperties(), layout_block_,\n         DisplayItem::kScrollHitTest);\n     ScrollHitTestDisplayItem::Record(paint_info.context, layout_block_,\n                                      DisplayItem::kScrollHitTest,\n                                     properties->ScrollTranslation());\n   }\n }\n", "target": 1, "idx": 185667}
{"func": " logger_get_mask_expanded (struct t_gui_buffer *buffer, const char *mask)\n {\n    char *mask2, *mask_decoded, *mask_decoded2, *mask_decoded3, *mask_decoded4;\n    char *mask_decoded5;\n     const char *dir_separator;\n     int length;\n     time_t seconds;\n     struct tm *date_tmp;\n \n     mask2 = NULL;\n    mask_decoded = NULL;\n    mask_decoded2 = NULL;\n    mask_decoded3 = NULL;\n    mask_decoded4 = NULL;\n    mask_decoded5 = NULL;\n \n     dir_separator = weechat_info_get (\"dir_separator\", \"\");\n     if (!dir_separator)\n         return NULL;\n \n     /*\n      * we first replace directory separator (commonly '/') by \\01 because\n      * buffer mask can contain this char, and will be replaced by replacement\n      * char ('_' by default)\n      */\n    mask2 = weechat_string_replace (mask, dir_separator, \"\\01\");\n    if (!mask2)\n         goto end;\n \n    mask_decoded = weechat_buffer_string_replace_local_var (buffer, mask2);\n    if (!mask_decoded)\n         goto end;\n \n    mask_decoded2 = weechat_string_replace (mask_decoded,\n                                            dir_separator,\n                                            weechat_config_string (logger_config_file_replacement_char));\n    if (!mask_decoded2)\n         goto end;\n \n #ifdef __CYGWIN__\n    mask_decoded3 = weechat_string_replace (mask_decoded2, \"\\\\\",\n                                            weechat_config_string (logger_config_file_replacement_char));\n #else\n    mask_decoded3 = strdup (mask_decoded2);\n #endif /* __CYGWIN__ */\n    if (!mask_decoded3)\n         goto end;\n \n     /* restore directory separator */\n    mask_decoded4 = weechat_string_replace (mask_decoded3,\n                                            \"\\01\", dir_separator);\n    if (!mask_decoded4)\n        goto end;\n    /* replace date/time specifiers in mask */\n    length = strlen (mask_decoded4) + 256 + 1;\n    mask_decoded5 = malloc (length);\n    if (!mask_decoded5)\n         goto end;\n    seconds = time (NULL);\n    date_tmp = localtime (&seconds);\n    mask_decoded5[0] = '\\0';\n    strftime (mask_decoded5, length - 1, mask_decoded4, date_tmp);\n \n     /* convert to lower case? */\n     if (weechat_config_boolean (logger_config_file_name_lower_case))\n        weechat_string_tolower (mask_decoded5);\n \n     if (weechat_logger_plugin->debug)\n     {\n        weechat_printf_date_tags (NULL, 0, \"no_log\",\n                                  \"%s: buffer = \\\"%s\\\", mask = \\\"%s\\\", \"\n                                   \"decoded mask = \\\"%s\\\"\",\n                                   LOGGER_PLUGIN_NAME,\n                                   weechat_buffer_get_string (buffer, \"name\"),\n                                  mask, mask_decoded5);\n     }\n \n end:\n     if (mask2)\n         free (mask2);\n    if (mask_decoded)\n        free (mask_decoded);\n    if (mask_decoded2)\n        free (mask_decoded2);\n    if (mask_decoded3)\n        free (mask_decoded3);\n    if (mask_decoded4)\n        free (mask_decoded4);\n    return mask_decoded5;\n }\n", "target": 1, "idx": 180917}
{"func": "int hugetlb_report_node_meminfo(int nid, char *buf)\n{\n\tstruct hstate *h = &default_hstate;\n\treturn sprintf(buf,\n\t\t\"Node %d HugePages_Total: %5u\\n\"\n\t\t\"Node %d HugePages_Free:  %5u\\n\"\n\t\t\"Node %d HugePages_Surp:  %5u\\n\",\n\t\tnid, h->nr_huge_pages_node[nid],\n\t\tnid, h->free_huge_pages_node[nid],\n\t\tnid, h->surplus_huge_pages_node[nid]);\n}\n", "target": 0, "idx": 19711}
{"func": "void WebPagePrivate::didReceiveCursorEventMode(CursorEventMode mode)\n{\n    if (mode != m_cursorEventMode)\n        m_client->cursorEventModeChanged(toPlatformCursorEventMode(mode));\n    m_cursorEventMode = mode;\n}\n", "target": 0, "idx": 111122}
{"func": "static int acm_tty_ioctl(struct tty_struct *tty,\n\t\t\t\t\tunsigned int cmd, unsigned long arg)\n{\n\tstruct acm *acm = tty->driver_data;\n\tint rv = -ENOIOCTLCMD;\n\n\tswitch (cmd) {\n\tcase TIOCGSERIAL: /* gets serial port data */\n\t\trv = get_serial_info(acm, (struct serial_struct __user *) arg);\n\t\tbreak;\n\tcase TIOCSSERIAL:\n\t\trv = set_serial_info(acm, (struct serial_struct __user *) arg);\n\t\tbreak;\n\tcase TIOCMIWAIT:\n\t\trv = usb_autopm_get_interface(acm->control);\n\t\tif (rv < 0) {\n\t\t\trv = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\trv = wait_serial_change(acm, arg);\n\t\tusb_autopm_put_interface(acm->control);\n\t\tbreak;\n\tcase TIOCGICOUNT:\n\t\trv = get_serial_usage(acm, (struct serial_icounter_struct __user *) arg);\n\t\tbreak;\n\t}\n\n\treturn rv;\n}\n", "target": 0, "idx": 54209}
{"func": "static void update_eoi_exitmap(struct kvm_vcpu *vcpu)\n{\n\tu64 eoi_exit_bitmap[4];\n\n\tmemset(eoi_exit_bitmap, 0, 32);\n\n\tkvm_ioapic_calculate_eoi_exitmap(vcpu, eoi_exit_bitmap);\n\tkvm_x86_ops->load_eoi_exitmap(vcpu, eoi_exit_bitmap);\n}\n", "target": 0, "idx": 33296}
{"func": "void InputHandler::ensureFocusTextElementVisible(CaretScrollType scrollType)\n{\n    if (!isActiveTextEdit() || !isInputModeEnabled() || !m_currentFocusElement->document())\n        return;\n\n    if (!(Platform::Settings::instance()->allowedScrollAdjustmentForInputFields() & scrollType))\n        return;\n\n    if (DOMSupport::isFixedPositionOrHasFixedPositionAncestor(m_currentFocusElement->renderer()))\n        return;\n\n    Frame* elementFrame = m_currentFocusElement->document()->frame();\n    if (!elementFrame)\n        return;\n\n    Frame* mainFrame = m_webPage->mainFrame();\n    if (!mainFrame)\n        return;\n\n    FrameView* mainFrameView = mainFrame->view();\n    if (!mainFrameView)\n        return;\n\n    WebCore::IntRect selectionFocusRect;\n    switch (elementFrame->selection()->selectionType()) {\n    case VisibleSelection::CaretSelection:\n        selectionFocusRect = elementFrame->selection()->absoluteCaretBounds();\n        break;\n    case VisibleSelection::RangeSelection: {\n        Position selectionPosition;\n        if (m_webPage->m_selectionHandler->lastUpdatedEndPointIsValid())\n            selectionPosition = elementFrame->selection()->end();\n        else\n            selectionPosition = elementFrame->selection()->start();\n        selectionFocusRect = VisiblePosition(selectionPosition).absoluteCaretBounds();\n        break;\n    }\n    case VisibleSelection::NoSelection:\n        m_shouldEnsureFocusTextElementVisibleOnSelectionChanged = true;\n        return;\n    }\n\n    int fontHeight = selectionFocusRect.height();\n\n    static const int s_minimumTextHeightInPixels = Graphics::Screen::primaryScreen()->heightInMMToPixels(3);\n\n    double zoomScaleRequired;\n    if (m_webPage->isUserScalable() && fontHeight && fontHeight * m_webPage->currentScale() < s_minimumTextHeightInPixels && !isRunningDrt())\n        zoomScaleRequired = static_cast<double>(s_minimumTextHeightInPixels) / fontHeight;\n    else\n        zoomScaleRequired = m_webPage->currentScale(); // Don't scale.\n\n    WebCore::FloatPoint offset(selectionFocusRect.location().x() - m_webPage->scrollPosition().x(), selectionFocusRect.location().y() - m_webPage->scrollPosition().y());\n    double inverseScale = zoomScaleRequired / m_webPage->currentScale();\n    WebCore::IntPoint destinationScrollLocation = WebCore::IntPoint(max(0, static_cast<int>(roundf(selectionFocusRect.location().x() - offset.x() / inverseScale))),\n                                                                    max(0, static_cast<int>(roundf(selectionFocusRect.location().y() - offset.y() / inverseScale))));\n\n    if (elementFrame != mainFrame) { // Element is in a subframe.\n        selectionFocusRect.move(-elementFrame->view()->scrollPosition().x(), -elementFrame->view()->scrollPosition().y());\n\n        if (elementFrame->ownerRenderer()) {\n            WebCore::IntPoint frameOffset = elementFrame->ownerRenderer()->absoluteContentBox().location();\n            selectionFocusRect.move(frameOffset.x(), frameOffset.y());\n        }\n    }\n\n    bool shouldConstrainScrollingToContentEdge = true;\n    Position start = elementFrame->selection()->start();\n    if (start.anchorNode() && start.anchorNode()->renderer()) {\n        if (RenderLayer* layer = start.anchorNode()->renderer()->enclosingLayer()) {\n            WebCore::IntRect actualScreenRect = WebCore::IntRect(destinationScrollLocation.x(), destinationScrollLocation.y(), m_webPage->actualVisibleSize().width() / inverseScale, m_webPage->actualVisibleSize().height() / inverseScale);\n\n            ScrollAlignment horizontalScrollAlignment = ScrollAlignment::alignToEdgeIfNeeded;\n            ScrollAlignment verticalScrollAlignment = ScrollAlignment::alignToEdgeIfNeeded;\n\n            if (scrollType != EdgeIfNeeded) {\n                if (RenderObject* focusedRenderer = m_currentFocusElement->renderer()) {\n                    WebCore::IntRect nodeOutlineBounds = focusedRenderer->absoluteOutlineBounds();\n                    WebCore::IntRect caretAtEdgeRect = rectForCaret(0);\n                    int paddingX = abs(caretAtEdgeRect.x() - nodeOutlineBounds.x());\n                    int paddingY = abs(caretAtEdgeRect.y() - nodeOutlineBounds.y());\n\n                    if (selectionFocusRect.x() - paddingX == nodeOutlineBounds.x())\n                        selectionFocusRect.setX(nodeOutlineBounds.x());\n                    else if (selectionFocusRect.maxX() + paddingX == nodeOutlineBounds.maxX())\n                        selectionFocusRect.setX(nodeOutlineBounds.maxX() - selectionFocusRect.width());\n                    if (selectionFocusRect.y() - paddingY == nodeOutlineBounds.y())\n                        selectionFocusRect.setY(nodeOutlineBounds.y() - selectionFocusRect.height());\n                    else if (selectionFocusRect.maxY() + paddingY == nodeOutlineBounds.maxY())\n                        selectionFocusRect.setY(nodeOutlineBounds.maxY() - selectionFocusRect.height());\n\n                    if (selectionFocusRect.x() - caretAtEdgeRect.x() < actualScreenRect.width() / 2)\n                        selectionFocusRect.setX(nodeOutlineBounds.x());\n                    else\n                        horizontalScrollAlignment = ScrollAlignment::alignCenterIfNeeded;\n\n                }\n                verticalScrollAlignment = (scrollType == CenterAlways) ? ScrollAlignment::alignCenterAlways : ScrollAlignment::alignCenterIfNeeded;\n            }\n\n            static const int s_focusRectPaddingSize = Graphics::Screen::primaryScreen()->heightInMMToPixels(3);\n            selectionFocusRect.inflate(m_webPage->mapFromTransformed(WebCore::IntSize(0, s_focusRectPaddingSize)).height());\n\n            WebCore::IntRect revealRect(layer->getRectToExpose(actualScreenRect, selectionFocusRect,\n                                                                 horizontalScrollAlignment,\n                                                                 verticalScrollAlignment));\n\n            shouldConstrainScrollingToContentEdge = false;\n\n            destinationScrollLocation = revealRect.location();\n            destinationScrollLocation.clampNegativeToZero();\n            WebCore::IntPoint maximumScrollPosition = WebCore::IntPoint(mainFrameView->contentsWidth() - actualScreenRect.width(), mainFrameView->contentsHeight() - actualScreenRect.height());\n            destinationScrollLocation = destinationScrollLocation.shrunkTo(maximumScrollPosition);\n        }\n    }\n\n    if (destinationScrollLocation != mainFrameView->scrollPosition() || zoomScaleRequired != m_webPage->currentScale()) {\n        InputLog(LogLevelInfo, \"InputHandler::ensureFocusTextElementVisible zooming in to %f and scrolling to point %d, %d\", zoomScaleRequired, destinationScrollLocation.x(), destinationScrollLocation.y());\n\n        m_webPage->m_finalBlockPoint = WebCore::FloatPoint(destinationScrollLocation);\n        m_webPage->m_blockZoomFinalScale = zoomScaleRequired;\n        m_webPage->m_shouldReflowBlock = false;\n        m_webPage->m_userPerformedManualZoom = true;\n        m_webPage->m_userPerformedManualScroll = true;\n        m_webPage->m_shouldConstrainScrollingToContentEdge = shouldConstrainScrollingToContentEdge;\n        m_webPage->client()->animateBlockZoom(zoomScaleRequired, m_webPage->m_finalBlockPoint);\n    }\n}\n", "target": 0, "idx": 111466}
{"func": "static void save_nogroups(void) {\n\tif (arg_nogroups == 0)\n\t\treturn;\n\n\tFILE *fp = fopen(RUN_GROUPS_CFG, \"w\");\n\tif (fp) {\n\t\tfprintf(fp, \"\\n\");\n\t\tSET_PERMS_STREAM(fp, 0, 0, 0644); // assume mode 0644\n\t\tfclose(fp);\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: cannot save nogroups state\\n\");\n\t\texit(1);\n\t}\n}\n", "target": 0, "idx": 89764}
{"func": "TEE_Result syscall_cryp_derive_key(unsigned long state,\n\t\t\tconst struct utee_attribute *usr_params,\n\t\t\tunsigned long param_count, unsigned long derived_key)\n{\n\tTEE_Result res = TEE_ERROR_NOT_SUPPORTED;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *ko;\n\tstruct tee_obj *so;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_cryp_obj_secret *sk;\n\tconst struct tee_cryp_obj_type_props *type_props;\n\tTEE_Attribute *params = NULL;\n\tstruct user_ta_ctx *utc;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tutc = to_user_ta_ctx(sess->ctx);\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n \tif (res != TEE_SUCCESS)\n \t\treturn res;\n \n\tparams = malloc(sizeof(TEE_Attribute) * param_count);\n \tif (!params)\n \t\treturn TEE_ERROR_OUT_OF_MEMORY;\n \tres = copy_in_attrs(utc, usr_params, param_count, params);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\t/* Get key set in operation */\n\tres = tee_obj_get(utc, cs->key1, &ko);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_obj_get(utc, tee_svc_uref_to_vaddr(derived_key), &so);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\t/* Find information needed about the object to initialize */\n\tsk = so->attr;\n\n\t/* Find description of object */\n\ttype_props = tee_svc_find_type_props(so->info.objectType);\n\tif (!type_props) {\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t\tgoto out;\n\t}\n\n\tif (cs->algo == TEE_ALG_DH_DERIVE_SHARED_SECRET) {\n\t\tsize_t alloc_size;\n\t\tstruct bignum *pub;\n\t\tstruct bignum *ss;\n\n\t\tif (param_count != 1 ||\n\t\t    params[0].attributeID != TEE_ATTR_DH_PUBLIC_VALUE) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tgoto out;\n\t\t}\n\n\t\talloc_size = params[0].content.ref.length * 8;\n\t\tpub = crypto_bignum_allocate(alloc_size);\n\t\tss = crypto_bignum_allocate(alloc_size);\n\t\tif (pub && ss) {\n\t\t\tcrypto_bignum_bin2bn(params[0].content.ref.buffer,\n\t\t\t\t\t     params[0].content.ref.length, pub);\n\t\t\tres = crypto_acipher_dh_shared_secret(ko->attr,\n\t\t\t\t\t\t\t      pub, ss);\n\t\t\tif (res == TEE_SUCCESS) {\n\t\t\t\tsk->key_size = crypto_bignum_num_bytes(ss);\n\t\t\t\tcrypto_bignum_bn2bin(ss, (uint8_t *)(sk + 1));\n\t\t\t\tso->info.handleFlags |=\n\t\t\t\t\t\tTEE_HANDLE_FLAG_INITIALIZED;\n\t\t\t\tset_attribute(so, type_props,\n\t\t\t\t\t      TEE_ATTR_SECRET_VALUE);\n\t\t\t}\n\t\t} else {\n\t\t\tres = TEE_ERROR_OUT_OF_MEMORY;\n\t\t}\n\t\tcrypto_bignum_free(pub);\n\t\tcrypto_bignum_free(ss);\n\t} else if (TEE_ALG_GET_MAIN_ALG(cs->algo) == TEE_MAIN_ALGO_ECDH) {\n\t\tsize_t alloc_size;\n\t\tstruct ecc_public_key key_public;\n\t\tuint8_t *pt_secret;\n\t\tunsigned long pt_secret_len;\n\n\t\tif (param_count != 2 ||\n\t\t    params[0].attributeID != TEE_ATTR_ECC_PUBLIC_VALUE_X ||\n\t\t    params[1].attributeID != TEE_ATTR_ECC_PUBLIC_VALUE_Y) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tswitch (cs->algo) {\n\t\tcase TEE_ALG_ECDH_P192:\n\t\t\talloc_size = 192;\n\t\t\tbreak;\n\t\tcase TEE_ALG_ECDH_P224:\n\t\t\talloc_size = 224;\n\t\t\tbreak;\n\t\tcase TEE_ALG_ECDH_P256:\n\t\t\talloc_size = 256;\n\t\t\tbreak;\n\t\tcase TEE_ALG_ECDH_P384:\n\t\t\talloc_size = 384;\n\t\t\tbreak;\n\t\tcase TEE_ALG_ECDH_P521:\n\t\t\talloc_size = 521;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tres = TEE_ERROR_NOT_IMPLEMENTED;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Create the public key */\n\t\tres = crypto_acipher_alloc_ecc_public_key(&key_public,\n\t\t\t\t\t\t\t  alloc_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tkey_public.curve = ((struct ecc_keypair *)ko->attr)->curve;\n\t\tcrypto_bignum_bin2bn(params[0].content.ref.buffer,\n\t\t\t\t     params[0].content.ref.length,\n\t\t\t\t     key_public.x);\n\t\tcrypto_bignum_bin2bn(params[1].content.ref.buffer,\n\t\t\t\t     params[1].content.ref.length,\n\t\t\t\t     key_public.y);\n\n\t\tpt_secret = (uint8_t *)(sk + 1);\n\t\tpt_secret_len = sk->alloc_size;\n\t\tres = crypto_acipher_ecc_shared_secret(ko->attr, &key_public,\n\t\t\t\t\t\t       pt_secret,\n\t\t\t\t\t\t       &pt_secret_len);\n\n\t\tif (res == TEE_SUCCESS) {\n\t\t\tsk->key_size = pt_secret_len;\n\t\t\tso->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\t\t\tset_attribute(so, type_props, TEE_ATTR_SECRET_VALUE);\n\t\t}\n\n\t\t/* free the public key */\n\t\tcrypto_acipher_free_ecc_public_key(&key_public);\n\t}\n#if defined(CFG_CRYPTO_HKDF)\n\telse if (TEE_ALG_GET_MAIN_ALG(cs->algo) == TEE_MAIN_ALGO_HKDF) {\n\t\tvoid *salt, *info;\n\t\tsize_t salt_len, info_len, okm_len;\n\t\tuint32_t hash_id = TEE_ALG_GET_DIGEST_HASH(cs->algo);\n\t\tstruct tee_cryp_obj_secret *ik = ko->attr;\n\t\tconst uint8_t *ikm = (const uint8_t *)(ik + 1);\n\n\t\tres = get_hkdf_params(params, param_count, &salt, &salt_len,\n\t\t\t\t      &info, &info_len, &okm_len);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\t/* Requested size must fit into the output object's buffer */\n\t\tif (okm_len > ik->alloc_size) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tres = tee_cryp_hkdf(hash_id, ikm, ik->key_size, salt, salt_len,\n\t\t\t\t    info, info_len, (uint8_t *)(sk + 1),\n\t\t\t\t    okm_len);\n\t\tif (res == TEE_SUCCESS) {\n\t\t\tsk->key_size = okm_len;\n\t\t\tso->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\t\t\tset_attribute(so, type_props, TEE_ATTR_SECRET_VALUE);\n\t\t}\n\t}\n#endif\n#if defined(CFG_CRYPTO_CONCAT_KDF)\n\telse if (TEE_ALG_GET_MAIN_ALG(cs->algo) == TEE_MAIN_ALGO_CONCAT_KDF) {\n\t\tvoid *info;\n\t\tsize_t info_len, derived_key_len;\n\t\tuint32_t hash_id = TEE_ALG_GET_DIGEST_HASH(cs->algo);\n\t\tstruct tee_cryp_obj_secret *ss = ko->attr;\n\t\tconst uint8_t *shared_secret = (const uint8_t *)(ss + 1);\n\n\t\tres = get_concat_kdf_params(params, param_count, &info,\n\t\t\t\t\t    &info_len, &derived_key_len);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\t/* Requested size must fit into the output object's buffer */\n\t\tif (derived_key_len > ss->alloc_size) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tres = tee_cryp_concat_kdf(hash_id, shared_secret, ss->key_size,\n\t\t\t\t\t  info, info_len, (uint8_t *)(sk + 1),\n\t\t\t\t\t  derived_key_len);\n\t\tif (res == TEE_SUCCESS) {\n\t\t\tsk->key_size = derived_key_len;\n\t\t\tso->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\t\t\tset_attribute(so, type_props, TEE_ATTR_SECRET_VALUE);\n\t\t}\n\t}\n#endif\n#if defined(CFG_CRYPTO_PBKDF2)\n\telse if (TEE_ALG_GET_MAIN_ALG(cs->algo) == TEE_MAIN_ALGO_PBKDF2) {\n\t\tvoid *salt;\n\t\tsize_t salt_len, iteration_count, derived_key_len;\n\t\tuint32_t hash_id = TEE_ALG_GET_DIGEST_HASH(cs->algo);\n\t\tstruct tee_cryp_obj_secret *ss = ko->attr;\n\t\tconst uint8_t *password = (const uint8_t *)(ss + 1);\n\n\t\tres = get_pbkdf2_params(params, param_count, &salt, &salt_len,\n\t\t\t\t\t&derived_key_len, &iteration_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\t/* Requested size must fit into the output object's buffer */\n\t\tif (derived_key_len > ss->alloc_size) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tres = tee_cryp_pbkdf2(hash_id, password, ss->key_size, salt,\n\t\t\t\t      salt_len, iteration_count,\n\t\t\t\t      (uint8_t *)(sk + 1), derived_key_len);\n\t\tif (res == TEE_SUCCESS) {\n\t\t\tsk->key_size = derived_key_len;\n\t\t\tso->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\t\t\tset_attribute(so, type_props, TEE_ATTR_SECRET_VALUE);\n\t\t}\n\t}\n#endif\n\telse\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\nout:\n\tfree(params);\n\treturn res;\n}\n", "target": 1, "idx": 182639}
{"func": "int get_signal_to_deliver(siginfo_t *info, struct k_sigaction *return_ka,\n\t\t\t  struct pt_regs *regs, void *cookie)\n{\n\tstruct sighand_struct *sighand = current->sighand;\n\tstruct signal_struct *signal = current->signal;\n\tint signr;\n\nrelock:\n\t/*\n\t * We'll jump back here after any time we were stopped in TASK_STOPPED.\n\t * While in TASK_STOPPED, we were considered \"frozen enough\".\n\t * Now that we woke up, it's crucial if we're supposed to be\n\t * frozen that we freeze now before running anything substantial.\n\t */\n\ttry_to_freeze();\n\n\tspin_lock_irq(&sighand->siglock);\n\t/*\n\t * Every stopped thread goes here after wakeup. Check to see if\n\t * we should notify the parent, prepare_signal(SIGCONT) encodes\n\t * the CLD_ si_code into SIGNAL_CLD_MASK bits.\n\t */\n\tif (unlikely(signal->flags & SIGNAL_CLD_MASK)) {\n\t\tint why = (signal->flags & SIGNAL_STOP_CONTINUED)\n\t\t\t\t? CLD_CONTINUED : CLD_STOPPED;\n\t\tsignal->flags &= ~SIGNAL_CLD_MASK;\n\n\t\twhy = tracehook_notify_jctl(why, CLD_CONTINUED);\n\t\tspin_unlock_irq(&sighand->siglock);\n\n\t\tif (why) {\n\t\t\tread_lock(&tasklist_lock);\n\t\t\tdo_notify_parent_cldstop(current->group_leader, why);\n\t\t\tread_unlock(&tasklist_lock);\n\t\t}\n\t\tgoto relock;\n\t}\n\n\tfor (;;) {\n\t\tstruct k_sigaction *ka;\n\t\t/*\n\t\t * Tracing can induce an artifical signal and choose sigaction.\n\t\t * The return value in @signr determines the default action,\n\t\t * but @info->si_signo is the signal number we will report.\n\t\t */\n\t\tsignr = tracehook_get_signal(current, regs, info, return_ka);\n\t\tif (unlikely(signr < 0))\n\t\t\tgoto relock;\n\t\tif (unlikely(signr != 0))\n\t\t\tka = return_ka;\n\t\telse {\n\t\t\tif (unlikely(signal->group_stop_count > 0) &&\n\t\t\t    do_signal_stop(0))\n\t\t\t\tgoto relock;\n\n\t\t\tsignr = dequeue_signal(current, &current->blocked,\n\t\t\t\t\t       info);\n\n\t\t\tif (!signr)\n\t\t\t\tbreak; /* will return 0 */\n\n\t\t\tif (signr != SIGKILL) {\n\t\t\t\tsignr = ptrace_signal(signr, info,\n\t\t\t\t\t\t      regs, cookie);\n\t\t\t\tif (!signr)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tka = &sighand->action[signr-1];\n\t\t}\n\n\t\t/* Trace actually delivered signals. */\n\t\ttrace_signal_deliver(signr, info, ka);\n\n\t\tif (ka->sa.sa_handler == SIG_IGN) /* Do nothing.  */\n\t\t\tcontinue;\n\t\tif (ka->sa.sa_handler != SIG_DFL) {\n\t\t\t/* Run the handler.  */\n\t\t\t*return_ka = *ka;\n\n\t\t\tif (ka->sa.sa_flags & SA_ONESHOT)\n\t\t\t\tka->sa.sa_handler = SIG_DFL;\n\n\t\t\tbreak; /* will return non-zero \"signr\" value */\n\t\t}\n\n\t\t/*\n\t\t * Now we are doing the default action for this signal.\n\t\t */\n\t\tif (sig_kernel_ignore(signr)) /* Default is nothing. */\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Global init gets no signals it doesn't want.\n\t\t * Container-init gets no signals it doesn't want from same\n\t\t * container.\n\t\t *\n\t\t * Note that if global/container-init sees a sig_kernel_only()\n\t\t * signal here, the signal must have been generated internally\n\t\t * or must have come from an ancestor namespace. In either\n\t\t * case, the signal cannot be dropped.\n\t\t */\n\t\tif (unlikely(signal->flags & SIGNAL_UNKILLABLE) &&\n\t\t\t\t!sig_kernel_only(signr))\n\t\t\tcontinue;\n\n\t\tif (sig_kernel_stop(signr)) {\n\t\t\t/*\n\t\t\t * The default action is to stop all threads in\n\t\t\t * the thread group.  The job control signals\n\t\t\t * do nothing in an orphaned pgrp, but SIGSTOP\n\t\t\t * always works.  Note that siglock needs to be\n\t\t\t * dropped during the call to is_orphaned_pgrp()\n\t\t\t * because of lock ordering with tasklist_lock.\n\t\t\t * This allows an intervening SIGCONT to be posted.\n\t\t\t * We need to check for that and bail out if necessary.\n\t\t\t */\n\t\t\tif (signr != SIGSTOP) {\n\t\t\t\tspin_unlock_irq(&sighand->siglock);\n\n\t\t\t\t/* signals can be posted during this window */\n\n\t\t\t\tif (is_current_pgrp_orphaned())\n\t\t\t\t\tgoto relock;\n\n\t\t\t\tspin_lock_irq(&sighand->siglock);\n\t\t\t}\n\n\t\t\tif (likely(do_signal_stop(info->si_signo))) {\n\t\t\t\t/* It released the siglock.  */\n\t\t\t\tgoto relock;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We didn't actually stop, due to a race\n\t\t\t * with SIGCONT or something like that.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\tspin_unlock_irq(&sighand->siglock);\n\n\t\t/*\n\t\t * Anything else is fatal, maybe with a core dump.\n\t\t */\n\t\tcurrent->flags |= PF_SIGNALED;\n\n\t\tif (sig_kernel_coredump(signr)) {\n\t\t\tif (print_fatal_signals)\n\t\t\t\tprint_fatal_signal(regs, info->si_signo);\n\t\t\t/*\n\t\t\t * If it was able to dump core, this kills all\n\t\t\t * other threads in the group and synchronizes with\n\t\t\t * their demise.  If we lost the race with another\n\t\t\t * thread getting here, it set group_exit_code\n\t\t\t * first and our do_group_exit call below will use\n\t\t\t * that value and ignore the one we pass it.\n\t\t\t */\n\t\t\tdo_coredump(info->si_signo, info->si_signo, regs);\n\t\t}\n\n\t\t/*\n\t\t * Death signals, no core dump.\n\t\t */\n\t\tdo_group_exit(info->si_signo);\n\t\t/* NOTREACHED */\n\t}\n\tspin_unlock_irq(&sighand->siglock);\n\treturn signr;\n}\n", "target": 0, "idx": 35178}
{"func": "GtkWidget* CreateMenu(GtkWidget* menu_bar, const char* text) {\n  GtkWidget* menu_widget = gtk_menu_new();\n  GtkWidget* menu_header = gtk_menu_item_new_with_label(text);\n  gtk_menu_item_set_submenu(GTK_MENU_ITEM(menu_header), menu_widget);\n  gtk_menu_shell_append(GTK_MENU_SHELL(menu_bar), menu_header);\n  return menu_widget;\n}\n", "target": 0, "idx": 108586}
{"func": "void __scm_destroy(struct scm_cookie *scm)\n{\n\tstruct scm_fp_list *fpl = scm->fp;\n\tint i;\n\n\tif (fpl) {\n \t\tscm->fp = NULL;\n \t\tfor (i=fpl->count-1; i>=0; i--)\n \t\t\tfput(fpl->fp[i]);\n \t\tkfree(fpl);\n \t}\n }\n", "target": 1, "idx": 180563}
{"func": " AccessibilityButtonState AXObject::checkboxOrRadioValue() const {\n   const AtomicString& checkedAttribute =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked);\n  if (equalIgnoringCase(checkedAttribute, \"true\"))\n     return ButtonStateOn;\n \n  if (equalIgnoringCase(checkedAttribute, \"mixed\")) {\n     AccessibilityRole role = ariaRoleAttribute();\n     if (role == CheckBoxRole || role == MenuItemCheckBoxRole)\n      return ButtonStateMixed;\n  }\n\n  return ButtonStateOff;\n}\n", "target": 1, "idx": 185802}
{"func": "Label::~Label() {\n}\n", "target": 0, "idx": 105812}
{"func": "piv_process_history(sc_card_t *card)\n{\n\tpiv_private_data_t * priv = PIV_DATA(card);\n\tint r;\n\tint i;\n\tint enumtag;\n\tu8 * rbuf = NULL;\n\tsize_t rbuflen = 0;\n\tconst u8 * body;\n\tsize_t bodylen;\n\tconst u8 * num;\n\tsize_t numlen;\n\tconst u8 * url = NULL;\n\tsize_t urllen;\n\tu8 * ocfhfbuf = NULL;\n\tunsigned int cla_out, tag_out;\n\tsize_t ocfhflen;\n\tconst u8 * seq;\n\tconst u8 * seqtag;\n\tsize_t seqlen;\n\tconst u8 * keyref;\n\tsize_t keyreflen;\n\tconst u8 * cert;\n\tsize_t certlen;\n\tsize_t certobjlen, i2;\n\tu8 * certobj;\n\tu8 * cp;\n\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\tr = piv_get_cached_data(card, PIV_OBJ_HISTORY, &rbuf, &rbuflen);\n\tif (r == SC_ERROR_FILE_NOT_FOUND)\n\t\tr = 0;\t\t\t/* OK if not found */\n\tif (r <= 0) {\n\t\tpriv->obj_cache[PIV_OBJ_HISTORY].flags |= PIV_OBJ_CACHE_NOT_PRESENT;\n\t\tgoto err;\t\t/* no file, must be pre 800-73-3 card and not on card */\n\t}\n\n\t/* the object is now cached, see what we have */\n\tif (rbuflen != 0) {\n\t\tbody = rbuf;\n\t\tif ((r = sc_asn1_read_tag(&body, rbuflen, &cla_out, &tag_out,  &bodylen)) != SC_SUCCESS) {\n\t\t\tsc_log(card->ctx, \"DER problem %d\",r);\n\t\t\tr = SC_ERROR_INVALID_ASN1_OBJECT;\n\t\t\tgoto err;\n\t\t}\n\n\t\tif ( cla_out+tag_out == 0x53 && body != NULL && bodylen != 0) {\n\t\t\tnumlen = 0;\n\t\t\tnum = sc_asn1_find_tag(card->ctx, body, bodylen, 0xC1, &numlen);\n\t\t\tif (num) {\n\t\t\t\tif (numlen != 1 || *num > PIV_OBJ_RETIRED_X509_20-PIV_OBJ_RETIRED_X509_1+1) {\n\t\t\t\t\tr = SC_ERROR_INTERNAL; /* TODO some other error */\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\n\t\t\t\tpriv->keysWithOnCardCerts = *num;\n\t\t\t}\n\n\t\t\tnumlen = 0;\n\t\t\tnum = sc_asn1_find_tag(card->ctx, body, bodylen, 0xC2, &numlen);\n\t\t\tif (num) {\n\t\t\t\tif (numlen != 1 || *num > PIV_OBJ_RETIRED_X509_20-PIV_OBJ_RETIRED_X509_1+1) {\n\t\t\t\t\tr = SC_ERROR_INTERNAL; /* TODO some other error */\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\n\t\t\t\tpriv->keysWithOffCardCerts = *num;\n\t\t\t}\n\n\t\t\turl = sc_asn1_find_tag(card->ctx, body, bodylen, 0xF3, &urllen);\n\t\t\tif (url) {\n\t\t\t\tpriv->offCardCertURL = calloc(1,urllen+1);\n\t\t\t\tif (priv->offCardCertURL == NULL)\n\t\t\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\t\t\t\tmemcpy(priv->offCardCertURL, url, urllen);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tsc_log(card->ctx, \"Problem with History object\\n\");\n\t\t\tgoto err;\n\t\t}\n\t}\n\tsc_log(card->ctx, \"History on=%d off=%d URL=%s\",\n\t\t\tpriv->keysWithOnCardCerts, priv->keysWithOffCardCerts,\n\t\t\tpriv->offCardCertURL ? priv->offCardCertURL:\"NONE\");\n\n\t/* now mark what objects are on the card */\n\tfor (i=0; i<priv->keysWithOnCardCerts; i++)\n\t\tpriv->obj_cache[PIV_OBJ_RETIRED_X509_1+i].flags &= ~PIV_OBJ_CACHE_NOT_PRESENT;\n\n\t/*\n\t * If user has gotten copy of the file from the offCardCertsURL,\n\t * we will read in and add the certs to the cache as listed on\n\t * the card. some of the certs may be on the card as well.\n\t *\n\t * Get file name from url. verify that the filename is valid\n\t * The URL ends in a SHA1 string. We will use this as the filename\n\t * in the directory used for the  PKCS15 cache\n\t */\n\n\tr = 0;\n\tif (priv->offCardCertURL) {\n\t\tchar * fp;\n\t\tchar filename[PATH_MAX];\n\n\t\tif (strncmp(\"http://\", priv->offCardCertURL, 7)) {\n\t\t\tr = SC_ERROR_INVALID_DATA;\n\t\t\tgoto err;\n\t\t}\n\t\t/* find the last /  so we have the filename part */\n\t\tfp = strrchr(priv->offCardCertURL + 7,'/');\n\t\tif (fp == NULL) {\n\t\t\tr = SC_ERROR_INVALID_DATA;\n\t\t\tgoto err;\n\t\t}\n\t\tfp++;\n\n\t\t/* Use the same directory as used for other OpenSC cached items */\n\t\tr = sc_get_cache_dir(card->ctx, filename, sizeof(filename) - strlen(fp) - 2);\n\t\tif (r != SC_SUCCESS)\n\t\t\tgoto err;\n#ifdef _WIN32\n\t\tstrcat(filename,\"\\\\\");\n#else\n\t\tstrcat(filename,\"/\");\n#endif\n\t\tstrcat(filename,fp);\n\n\t\tr = piv_read_obj_from_file(card, filename,\n\t\t\t &ocfhfbuf, &ocfhflen);\n\t\tif (r == SC_ERROR_FILE_NOT_FOUND) {\n\t\t\tr = 0;\n\t\t\tgoto err;\n\t\t}\n\n\t\t/*\n\t\t * Its a seq of seq of a key ref and cert\n\t\t */\n\n\t\tbody = ocfhfbuf;\n\t\tif (sc_asn1_read_tag(&body, ocfhflen, &cla_out,\n\t\t\t\t\t&tag_out, &bodylen) != SC_SUCCESS\n\t\t\t\t|| cla_out+tag_out != 0x30) {\n\t\t\tsc_log(card->ctx, \"DER problem\");\n\t\t\tr = SC_ERROR_INVALID_ASN1_OBJECT;\n\t\t\tgoto err;\n\t\t}\n\t\tseq = body;\n\t\twhile (bodylen > 0) {\n\t\t\tseqtag = seq;\n\t\t\tif (sc_asn1_read_tag(&seq, bodylen, &cla_out,\n\t\t\t\t\t\t&tag_out, &seqlen) != SC_SUCCESS\n\t\t\t\t\t|| cla_out+tag_out != 0x30) {\n\t\t\t\tsc_log(card->ctx, \"DER problem\");\n\t\t\t\tr = SC_ERROR_INVALID_ASN1_OBJECT;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tkeyref = sc_asn1_find_tag(card->ctx, seq, seqlen, 0x04, &keyreflen);\n\t\t\tif (!keyref || keyreflen != 1 ||\n\t\t\t\t\t(*keyref < 0x82 || *keyref > 0x95)) {\n\t\t\t\tsc_log(card->ctx, \"DER problem\");\n\t\t\t\tr = SC_ERROR_INVALID_ASN1_OBJECT;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tcert = keyref + keyreflen;\n\t\t\tcertlen = seqlen - (cert - seq);\n\n\t\t\tenumtag = PIV_OBJ_RETIRED_X509_1 + *keyref - 0x82;\n\t\t\t/* now add the cert like another object */\n\n\t\t\ti2 = put_tag_and_len(0x70,certlen, NULL)\n\t\t\t\t\t+ put_tag_and_len(0x71, 1, NULL)\n\t\t\t\t\t+ put_tag_and_len(0xFE, 0, NULL);\n\n\t\t\tcertobjlen = put_tag_and_len(0x53, i2, NULL);\n\n\t\t\tcertobj = malloc(certobjlen);\n\t\t\tif (certobj == NULL) {\n\t\t\t\tr = SC_ERROR_OUT_OF_MEMORY;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tcp = certobj;\n\t\t\tput_tag_and_len(0x53, i2, &cp);\n\t\t\tput_tag_and_len(0x70,certlen, &cp);\n\t\t\tmemcpy(cp, cert, certlen);\n\t\t\tcp += certlen;\n\t\t\tput_tag_and_len(0x71, 1,&cp);\n\t\t\t*cp++ = 0x00;\n\t\t\tput_tag_and_len(0xFE, 0, &cp);\n\n\t\t\tpriv->obj_cache[enumtag].obj_data = certobj;\n\t\t\tpriv->obj_cache[enumtag].obj_len = certobjlen;\n\t\t\tpriv->obj_cache[enumtag].flags |= PIV_OBJ_CACHE_VALID;\n\t\t\tpriv->obj_cache[enumtag].flags &= ~PIV_OBJ_CACHE_NOT_PRESENT;\n\n\t\t\tr = piv_cache_internal_data(card, enumtag);\n\t\t\tsc_log(card->ctx, \"got internal r=%d\",r);\n\n\t\t\tcertobj = NULL;\n\n\t\t\tsc_log(card->ctx,\n\t\t\t       \"Added from off card file #%d %p:%\"SC_FORMAT_LEN_SIZE_T\"u 0x%02X\",\n\t\t\t       enumtag,\n\t\t\t       priv->obj_cache[enumtag].obj_data,\n\t\t\t       priv->obj_cache[enumtag].obj_len, *keyref);\n\n\t\t\tbodylen -= (seqlen + seq - seqtag);\n\t\t\tseq += seqlen;\n\t\t}\n\t}\nerr:\n\tif (ocfhfbuf)\n\t\tfree(ocfhfbuf);\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n", "target": 0, "idx": 78649}
{"func": "status_t MPEG4Extractor::verifyTrack(Track *track) {\n const char *mime;\n    CHECK(track->meta->findCString(kKeyMIMEType, &mime));\n\n uint32_t type;\n const void *data;\n size_t size;\n if (!strcasecmp(mime, MEDIA_MIMETYPE_VIDEO_AVC)) {\n if (!track->meta->findData(kKeyAVCC, &type, &data, &size)\n || type != kTypeAVCC) {\n return ERROR_MALFORMED;\n }\n } else if (!strcasecmp(mime, MEDIA_MIMETYPE_VIDEO_HEVC)) {\n if (!track->meta->findData(kKeyHVCC, &type, &data, &size)\n || type != kTypeHVCC) {\n return ERROR_MALFORMED;\n }\n } else if (!strcasecmp(mime, MEDIA_MIMETYPE_VIDEO_MPEG4)\n || !strcasecmp(mime, MEDIA_MIMETYPE_VIDEO_MPEG2)\n || !strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AAC)) {\n if (!track->meta->findData(kKeyESDS, &type, &data, &size)\n || type != kTypeESDS) {\n return ERROR_MALFORMED;\n }\n }\n\n if (track->sampleTable == NULL || !track->sampleTable->isValid()) {\n        ALOGE(\"stbl atom missing/invalid.\");\n return ERROR_MALFORMED;\n }\n\n if (track->timescale == 0) {\n        ALOGE(\"timescale invalid.\");\n return ERROR_MALFORMED;\n }\n\n return OK;\n}\n", "target": 0, "idx": 172778}
{"func": "MagickExport int LocaleUppercase(const int c)\n {\n #if defined(MAGICKCORE_LOCALE_SUPPORT)\n   if (c_locale != (locale_t) NULL)\n    return(toupper_l(c,c_locale));\n #endif\n  return(toupper(c));\n }\n", "target": 1, "idx": 183406}
{"func": "void Pack<WebGLImageConversion::kDataFormatRGB16F,\n          WebGLImageConversion::kAlphaDoUnmultiply,\n          float,\n          uint16_t>(const float* source,\n                    uint16_t* destination,\n                    unsigned pixels_per_row) {\n  for (unsigned i = 0; i < pixels_per_row; ++i) {\n    float scale_factor = source[3] ? 1.0f / source[3] : 1.0f;\n    destination[0] = ConvertFloatToHalfFloat(source[0] * scale_factor);\n    destination[1] = ConvertFloatToHalfFloat(source[1] * scale_factor);\n    destination[2] = ConvertFloatToHalfFloat(source[2] * scale_factor);\n    source += 4;\n    destination += 3;\n  }\n}\n", "target": 0, "idx": 159510}
{"func": "  MockCachingHostResolver* GetMockHostResolver() {\n    return &host_resolver_;\n  }\n", "target": 0, "idx": 140463}
{"func": " GetStartupData(HANDLE pipe, STARTUP_DATA *sud)\n {\n     size_t size, len;\n    BOOL ret = FALSE;\n     WCHAR *data = NULL;\n     DWORD bytes, read;\n \n    bytes = PeekNamedPipeAsync(pipe, 1, &exit_event);\n    if (bytes == 0)\n     {\n         MsgToEventLog(M_SYSERR, TEXT(\"PeekNamedPipeAsync failed\"));\n         ReturnLastError(pipe, L\"PeekNamedPipeAsync\");\n        goto out;\n     }\n \n     size = bytes / sizeof(*data);\n     if (size == 0)\n     {\n         MsgToEventLog(M_SYSERR, TEXT(\"malformed startup data: 1 byte received\"));\n         ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto out;\n     }\n \n     data = malloc(bytes);\n     if (data == NULL)\n     {\n         MsgToEventLog(M_SYSERR, TEXT(\"malloc failed\"));\n         ReturnLastError(pipe, L\"malloc\");\n        goto out;\n     }\n \n     read = ReadPipeAsync(pipe, data, bytes, 1, &exit_event);\n     if (bytes != read)\n     {\n         MsgToEventLog(M_SYSERR, TEXT(\"ReadPipeAsync failed\"));\n         ReturnLastError(pipe, L\"ReadPipeAsync\");\n        goto out;\n     }\n \n     if (data[size - 1] != 0)\n     {\n         MsgToEventLog(M_ERR, TEXT(\"Startup data is not NULL terminated\"));\n         ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto out;\n     }\n \n     sud->directory = data;\n    len = wcslen(sud->directory) + 1;\n    size -= len;\n    if (size <= 0)\n     {\n         MsgToEventLog(M_ERR, TEXT(\"Startup data ends at working directory\"));\n         ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto out;\n     }\n \n     sud->options = sud->directory + len;\n    len = wcslen(sud->options) + 1;\n    size -= len;\n    if (size <= 0)\n     {\n         MsgToEventLog(M_ERR, TEXT(\"Startup data ends at command line options\"));\n         ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto out;\n     }\n \n     sud->std_input = sud->options + len;\n    data = NULL; /* don't free data */\n    ret = TRUE;\n \nout:\n     free(data);\n    return ret;\n }\n", "target": 1, "idx": 182439}
{"func": "struct mapped_device *dm_get_from_kobject(struct kobject *kobj)\n{\n\tstruct mapped_device *md;\n \n \tmd = container_of(kobj, struct mapped_device, kobj_holder.kobj);\n \n\tif (test_bit(DMF_FREEING, &md->flags) ||\n\t    dm_deleting_md(md))\n\t\treturn NULL;\n \tdm_get(md);\n \treturn md;\n }\n", "target": 1, "idx": 182583}
{"func": "bool BackingStoreWin::ColorManagementEnabled() {\n  static bool enabled = false;\n  static bool checked = false;\n  if (!checked) {\n    checked = true;\n    const CommandLine& command = *CommandLine::ForCurrentProcess();\n    enabled = command.HasSwitch(switches::kEnableMonitorProfile);\n  }\n  return enabled;\n}\n", "target": 0, "idx": 98607}
{"func": "PHP_METHOD(Phar, setSignatureAlgorithm)\n{\n\tlong algo;\n\tchar *error, *key = NULL;\n\tint key_len = 0;\n\n\tPHAR_ARCHIVE_OBJECT();\n\n\tif (PHAR_G(readonly) && !phar_obj->arc.archive->is_data) {\n\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,\n\t\t\t\"Cannot set signature algorithm, phar is read-only\");\n\t\treturn;\n\t}\n\n\tif (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, ZEND_NUM_ARGS() TSRMLS_CC, \"l|s\", &algo, &key, &key_len) != SUCCESS) {\n\t\treturn;\n\t}\n\n\tswitch (algo) {\n\t\tcase PHAR_SIG_SHA256:\n\t\tcase PHAR_SIG_SHA512:\n#ifndef PHAR_HASH_OK\n\t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,\n\t\t\t\t\"SHA-256 and SHA-512 signatures are only supported if the hash extension is enabled and built non-shared\");\n\t\t\treturn;\n#endif\n\t\tcase PHAR_SIG_MD5:\n\t\tcase PHAR_SIG_SHA1:\n\t\tcase PHAR_SIG_OPENSSL:\n\t\t\tif (phar_obj->arc.archive->is_persistent && FAILURE == phar_copy_on_write(&(phar_obj->arc.archive) TSRMLS_CC)) {\n\t\t\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"phar \\\"%s\\\" is persistent, unable to copy on write\", phar_obj->arc.archive->fname);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tphar_obj->arc.archive->sig_flags = algo;\n\t\t\tphar_obj->arc.archive->is_modified = 1;\n\t\t\tPHAR_G(openssl_privatekey) = key;\n\t\t\tPHAR_G(openssl_privatekey_len) = key_len;\n\n\t\t\tphar_flush(phar_obj->arc.archive, 0, 0, 0, &error TSRMLS_CC);\n\t\t\tif (error) {\n\t\t\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"%s\", error);\n\t\t\t\tefree(error);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,\n\t\t\t\t\"Unknown signature algorithm specified\");\n\t}\n}\n", "target": 0, "idx": 4385}
{"func": "int VaapiVideoDecodeAccelerator::VaapiH264Accelerator::FillVARefFramesFromDPB(\n     const H264DPB& dpb,\n     VAPictureH264* va_pics,\n     int num_pics) {\n   H264Picture::Vector::const_reverse_iterator rit;\n   int i;\n \n  for (rit = dpb.rbegin(), i = 0; rit != dpb.rend() && i < num_pics; ++rit) {\n    if ((*rit)->ref)\n      FillVAPicture(&va_pics[i++], *rit);\n  }\n\n  return i;\n}\n", "target": 1, "idx": 186778}
{"func": "static int event_enable_on_exec(struct perf_event *event,\n\t\t\t\tstruct perf_event_context *ctx)\n{\n\tif (!event->attr.enable_on_exec)\n\t\treturn 0;\n\n\tevent->attr.enable_on_exec = 0;\n\tif (event->state >= PERF_EVENT_STATE_INACTIVE)\n\t\treturn 0;\n\n\t__perf_event_mark_enabled(event, ctx);\n\n\treturn 1;\n}\n", "target": 0, "idx": 25994}
{"func": "delay(int64_t ns)\n{\n    struct timespec req, rem;\n\n    req.tv_sec = 0;\n\n    while (ns >= 1000000000L) {\n        ns -= 1000000000L;\n        req.tv_sec += 1;\n    }\n\n    req.tv_nsec = ns;\n\n    while (nanosleep(&req, &rem) == -1)\n        if (EINTR == errno)\n            memcpy(&req, &rem, sizeof(rem));\n        else\n            return -1;\n    return 0;\n}\n", "target": 0, "idx": 53450}
{"func": "static void elementAttributeAttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)\n{\n    TestObjectPython* imp = V8TestObjectPython::toNative(info.Holder());\n    V8TRYCATCH_VOID(Element*, cppValue, V8Element::toNativeWithTypeCheck(info.GetIsolate(), jsValue));\n    imp->setElementAttribute(WTF::getPtr(cppValue));\n}\n", "target": 0, "idx": 131370}
{"func": "do_decrypt (const RIJNDAEL_context *ctx, unsigned char *bx,\n            const unsigned char *ax)\n {\n #ifdef USE_AMD64_ASM\n   return _gcry_aes_amd64_decrypt_block(ctx->keyschdec, bx, ax, ctx->rounds,\n\t\t\t\t       &dec_tables);\n #elif defined(USE_ARM_ASM)\n   return _gcry_aes_arm_decrypt_block(ctx->keyschdec, bx, ax, ctx->rounds,\n\t\t\t\t     &dec_tables);\n #else\n   return do_decrypt_fn (ctx, bx, ax);\n #endif /*!USE_ARM_ASM && !USE_AMD64_ASM*/\n}\n", "target": 1, "idx": 183383}
{"func": "copy_thread(unsigned long clone_flags, unsigned long stack_start,\n\t    unsigned long stk_sz, struct task_struct *p)\n{\n\tstruct thread_info *thread = task_thread_info(p);\n\tstruct pt_regs *childregs = task_pt_regs(p);\n\n\tmemset(&thread->cpu_context, 0, sizeof(struct cpu_context_save));\n\n\tif (likely(!(p->flags & PF_KTHREAD))) {\n\t\t*childregs = *current_pt_regs();\n\t\tchildregs->ARM_r0 = 0;\n\t\tif (stack_start)\n\t\t\tchildregs->ARM_sp = stack_start;\n\t} else {\n\t\tmemset(childregs, 0, sizeof(struct pt_regs));\n\t\tthread->cpu_context.r4 = stk_sz;\n\t\tthread->cpu_context.r5 = stack_start;\n\t\tchildregs->ARM_cpsr = SVC_MODE;\n\t}\n\tthread->cpu_context.pc = (unsigned long)ret_from_fork;\n\tthread->cpu_context.sp = (unsigned long)childregs;\n\n \tclear_ptrace_hw_breakpoint(p);\n \n \tif (clone_flags & CLONE_SETTLS)\n\t\tthread->tp_value = childregs->ARM_r3;\n \n \tthread_notify(THREAD_NOTIFY_COPY, thread);\n \n\treturn 0;\n}\n", "target": 1, "idx": 180751}
{"func": "PHP_FUNCTION(ini_get)\n{\n\tchar *varname, *str;\n\tint varname_len;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &varname, &varname_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tstr = zend_ini_string(varname, varname_len + 1, 0);\n\n\tif (!str) {\n\t\tRETURN_FALSE;\n\t}\n\n\tRETURN_STRING(str, 1);\n}\n", "target": 0, "idx": 4279}
{"func": "  GtkPrinterList() : default_printer_(NULL) {\n    gtk_enumerate_printers((GtkPrinterFunc)SetPrinter, this, NULL, TRUE);\n  }\n", "target": 0, "idx": 101905}
{"func": "int NoOpVerifyCallback(X509_STORE_CTX*, void *) {\n  DVLOG(3) << \"skipping cert verify\";\n  return 1;\n}\n", "target": 1, "idx": 185540}
{"func": "param_integer( const char *name, int default_value,\n\t\t\t   int min_value, int max_value, bool use_param_table )\n{\n\tint result;\n\n\tparam_integer( name, result, true, default_value,\n\t\t\t\t   true, min_value, max_value, NULL, NULL, use_param_table );\n\treturn result;\n}\n", "target": 0, "idx": 16516}
{"func": "static bool check_allocations(ASS_Shaper *shaper, size_t new_size)\n{\n    if (new_size > shaper->n_glyphs) {\n        if (!ASS_REALLOC_ARRAY(shaper->event_text, new_size) ||\n            !ASS_REALLOC_ARRAY(shaper->ctypes, new_size) ||\n             !ASS_REALLOC_ARRAY(shaper->emblevels, new_size) ||\n             !ASS_REALLOC_ARRAY(shaper->cmap, new_size))\n             return false;\n     }\n     return true;\n }\n", "target": 1, "idx": 181946}
{"func": "IHEVCD_ERROR_T ihevcd_parse_slice_header(codec_t *ps_codec,\n nal_header_t *ps_nal)\n\n {\n     IHEVCD_ERROR_T ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;\n     WORD32 value;\n    WORD32 i;\n     WORD32 sps_id;\n \n     pps_t *ps_pps;\n sps_t *ps_sps;\n slice_header_t *ps_slice_hdr;\n    WORD32 disable_deblocking_filter_flag;\n bitstrm_t *ps_bitstrm = &ps_codec->s_parse.s_bitstrm;\n    WORD32 idr_pic_flag;\n    WORD32 pps_id;\n    WORD32 first_slice_in_pic_flag;\n    WORD32 no_output_of_prior_pics_flag = 0;\n    WORD8 i1_nal_unit_type = ps_nal->i1_nal_unit_type;\n    WORD32 num_poc_total_curr = 0;\n    WORD32 slice_address;\n\n if(ps_codec->i4_slice_error == 1)\n return ret;\n\n    idr_pic_flag = (NAL_IDR_W_LP == i1_nal_unit_type) ||\n (NAL_IDR_N_LP == i1_nal_unit_type);\n\n\n    BITS_PARSE(\"first_slice_in_pic_flag\", first_slice_in_pic_flag, ps_bitstrm, 1);\n if((NAL_BLA_W_LP <= i1_nal_unit_type) &&\n (NAL_RSV_RAP_VCL23          >= i1_nal_unit_type))\n {\n        BITS_PARSE(\"no_output_of_prior_pics_flag\", no_output_of_prior_pics_flag, ps_bitstrm, 1);\n }\n    UEV_PARSE(\"pic_parameter_set_id\", pps_id, ps_bitstrm);\n    pps_id = CLIP3(pps_id, 0, MAX_PPS_CNT - 2);\n\n /* Get the current PPS structure */\n    ps_pps = ps_codec->s_parse.ps_pps_base + pps_id;\n if(0 == ps_pps->i1_pps_valid)\n {\n pps_t *ps_pps_ref = ps_codec->ps_pps_base;\n while(0 == ps_pps_ref->i1_pps_valid)\n            ps_pps_ref++;\n\n if((ps_pps_ref - ps_codec->ps_pps_base >= MAX_PPS_CNT - 1))\n return IHEVCD_INVALID_HEADER;\n\n        ihevcd_copy_pps(ps_codec, pps_id, ps_pps_ref->i1_pps_id);\n }\n\n /* Get SPS id for the current PPS */\n    sps_id = ps_pps->i1_sps_id;\n\n /* Get the current SPS structure */\n    ps_sps = ps_codec->s_parse.ps_sps_base + sps_id;\n\n /* When the current slice is the first in a pic,\n     *  check whether the previous frame is complete\n     *  If the previous frame is incomplete -\n     *  treat the remaining CTBs as skip */\n if((0 != ps_codec->u4_pic_cnt || ps_codec->i4_pic_present) &&\n                    first_slice_in_pic_flag)\n {\n if(ps_codec->i4_pic_present)\n {\n slice_header_t *ps_slice_hdr_next;\n            ps_codec->i4_slice_error = 1;\n            ps_codec->s_parse.i4_cur_slice_idx--;\n if(ps_codec->s_parse.i4_cur_slice_idx < 0)\n                ps_codec->s_parse.i4_cur_slice_idx = 0;\n\n            ps_slice_hdr_next = ps_codec->s_parse.ps_slice_hdr_base + ((ps_codec->s_parse.i4_cur_slice_idx + 1) & (MAX_SLICE_HDR_CNT - 1));\n            ps_slice_hdr_next->i2_ctb_x = 0;\n            ps_slice_hdr_next->i2_ctb_y = ps_codec->s_parse.ps_sps->i2_pic_ht_in_ctb;\n return ret;\n }\n else\n {\n            ps_codec->i4_slice_error = 0;\n }\n }\n\n if(first_slice_in_pic_flag)\n {\n        ps_codec->s_parse.i4_cur_slice_idx = 0;\n }\n else\n {\n /* If the current slice is not the first slice in the pic,\n         * but the first one to be parsed, set the current slice indx to 1\n         * Treat the first slice to be missing and copy the current slice header\n         * to the first one */\n if(0 == ps_codec->i4_pic_present)\n            ps_codec->s_parse.i4_cur_slice_idx = 1;\n }\n\n    ps_slice_hdr = ps_codec->s_parse.ps_slice_hdr_base + (ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1));\n\n\n if((ps_pps->i1_dependent_slice_enabled_flag) &&\n (!first_slice_in_pic_flag))\n {\n        BITS_PARSE(\"dependent_slice_flag\", value, ps_bitstrm, 1);\n\n /* If dependendent slice, copy slice header from previous slice */\n if(value && (ps_codec->s_parse.i4_cur_slice_idx > 0))\n {\n            ihevcd_copy_slice_hdr(ps_codec,\n (ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1)),\n ((ps_codec->s_parse.i4_cur_slice_idx - 1) & (MAX_SLICE_HDR_CNT - 1)));\n }\n        ps_slice_hdr->i1_dependent_slice_flag = value;\n }\n else\n {\n        ps_slice_hdr->i1_dependent_slice_flag = 0;\n }\n    ps_slice_hdr->i1_nal_unit_type = i1_nal_unit_type;\n    ps_slice_hdr->i1_pps_id = pps_id;\n    ps_slice_hdr->i1_first_slice_in_pic_flag = first_slice_in_pic_flag;\n\n    ps_slice_hdr->i1_no_output_of_prior_pics_flag = 1;\n if((NAL_BLA_W_LP <= i1_nal_unit_type) &&\n (NAL_RSV_RAP_VCL23          >= i1_nal_unit_type))\n {\n        ps_slice_hdr->i1_no_output_of_prior_pics_flag = no_output_of_prior_pics_flag;\n }\n    ps_slice_hdr->i1_pps_id = pps_id;\n\n if(!ps_slice_hdr->i1_first_slice_in_pic_flag)\n {\n        WORD32 num_bits;\n\n /* Use CLZ to compute Ceil( Log2( PicSizeInCtbsY ) ) */\n        num_bits = 32 - CLZ(ps_sps->i4_pic_size_in_ctb - 1);\n        BITS_PARSE(\"slice_address\", value, ps_bitstrm, num_bits);\n\n        slice_address = value;\n /* If slice address is greater than the number of CTBs in a picture,\n         * ignore the slice */\n if(value >= ps_sps->i4_pic_size_in_ctb)\n return IHEVCD_IGNORE_SLICE;\n }\n else\n {\n        slice_address = 0;\n }\n\n if(!ps_slice_hdr->i1_dependent_slice_flag)\n {\n        ps_slice_hdr->i1_pic_output_flag = 1;\n        ps_slice_hdr->i4_pic_order_cnt_lsb = 0;\n        ps_slice_hdr->i1_num_long_term_sps = 0;\n        ps_slice_hdr->i1_num_long_term_pics = 0;\n\n for(i = 0; i < ps_pps->i1_num_extra_slice_header_bits; i++)\n {\n            BITS_PARSE(\"slice_reserved_undetermined_flag[ i ]\", value, ps_bitstrm, 1);\n }\n        UEV_PARSE(\"slice_type\", value, ps_bitstrm);\n        ps_slice_hdr->i1_slice_type = value;\n\n /* If the picture is IRAP, slice type must be equal to ISLICE */\n if((ps_slice_hdr->i1_nal_unit_type >= NAL_BLA_W_LP) &&\n (ps_slice_hdr->i1_nal_unit_type <= NAL_RSV_RAP_VCL23))\n            ps_slice_hdr->i1_slice_type = ISLICE;\n\n if((ps_slice_hdr->i1_slice_type < 0) ||\n (ps_slice_hdr->i1_slice_type > 2))\n return IHEVCD_IGNORE_SLICE;\n\n if(ps_pps->i1_output_flag_present_flag)\n {\n            BITS_PARSE(\"pic_output_flag\", value, ps_bitstrm, 1);\n            ps_slice_hdr->i1_pic_output_flag = value;\n }\n        ps_slice_hdr->i1_colour_plane_id = 0;\n if(1 == ps_sps->i1_separate_colour_plane_flag)\n {\n            BITS_PARSE(\"colour_plane_id\", value, ps_bitstrm, 2);\n            ps_slice_hdr->i1_colour_plane_id = value;\n }\n        ps_slice_hdr->i1_slice_temporal_mvp_enable_flag = 0;\n\n if(!idr_pic_flag)\n {\n\n            WORD32 st_rps_idx;\n            WORD32 num_neg_pics;\n            WORD32 num_pos_pics;\n            WORD8 *pi1_used;\n\n            BITS_PARSE(\"pic_order_cnt_lsb\", value, ps_bitstrm, ps_sps->i1_log2_max_pic_order_cnt_lsb);\n            ps_slice_hdr->i4_pic_order_cnt_lsb = value;\n\n            BITS_PARSE(\"short_term_ref_pic_set_sps_flag\", value, ps_bitstrm, 1);\n            ps_slice_hdr->i1_short_term_ref_pic_set_sps_flag = value;\n\n if(1 == ps_slice_hdr->i1_short_term_ref_pic_set_sps_flag)\n {\n                WORD32 numbits;\n\n                ps_slice_hdr->i1_short_term_ref_pic_set_idx = 0;\n if(ps_sps->i1_num_short_term_ref_pic_sets > 1)\n {\n                    numbits = 32 - CLZ(ps_sps->i1_num_short_term_ref_pic_sets - 1);\n                    BITS_PARSE(\"short_term_ref_pic_set_idx\", value, ps_bitstrm, numbits);\n                    ps_slice_hdr->i1_short_term_ref_pic_set_idx = value;\n }\n\n                st_rps_idx = ps_slice_hdr->i1_short_term_ref_pic_set_idx;\n                num_neg_pics = ps_sps->as_stref_picset[st_rps_idx].i1_num_neg_pics;\n                num_pos_pics = ps_sps->as_stref_picset[st_rps_idx].i1_num_pos_pics;\n                pi1_used = ps_sps->as_stref_picset[st_rps_idx].ai1_used;\n }\n else\n {\n                ihevcd_short_term_ref_pic_set(ps_bitstrm,\n &ps_sps->as_stref_picset[0],\n                                              ps_sps->i1_num_short_term_ref_pic_sets,\n                                              ps_sps->i1_num_short_term_ref_pic_sets,\n &ps_slice_hdr->s_stref_picset);\n\n                st_rps_idx = ps_sps->i1_num_short_term_ref_pic_sets;\n                num_neg_pics = ps_slice_hdr->s_stref_picset.i1_num_neg_pics;\n                num_pos_pics = ps_slice_hdr->s_stref_picset.i1_num_pos_pics;\n                pi1_used = ps_slice_hdr->s_stref_picset.ai1_used;\n }\n\n if(ps_sps->i1_long_term_ref_pics_present_flag)\n {\n if(ps_sps->i1_num_long_term_ref_pics_sps > 0)\n {\n                    UEV_PARSE(\"num_long_term_sps\", value, ps_bitstrm);\n                    ps_slice_hdr->i1_num_long_term_sps = value;\n\n                    ps_slice_hdr->i1_num_long_term_sps = CLIP3(ps_slice_hdr->i1_num_long_term_sps,\n 0, MAX_DPB_SIZE - num_neg_pics - num_pos_pics);\n }\n                UEV_PARSE(\"num_long_term_pics\", value, ps_bitstrm);\n                ps_slice_hdr->i1_num_long_term_pics = value;\n                ps_slice_hdr->i1_num_long_term_pics = CLIP3(ps_slice_hdr->i1_num_long_term_pics,\n 0, MAX_DPB_SIZE - num_neg_pics - num_pos_pics -\n                                                            ps_slice_hdr->i1_num_long_term_sps);\n\n for(i = 0; i < (ps_slice_hdr->i1_num_long_term_sps +\n                                ps_slice_hdr->i1_num_long_term_pics); i++)\n {\n if(i < ps_slice_hdr->i1_num_long_term_sps)\n {\n /* Use CLZ to compute Ceil( Log2( num_long_term_ref_pics_sps ) ) */\n                        WORD32 num_bits = 32 - CLZ(ps_sps->i1_num_long_term_ref_pics_sps);\n                        BITS_PARSE(\"lt_idx_sps[ i ]\", value, ps_bitstrm, num_bits);\n                        ps_slice_hdr->ai4_poc_lsb_lt[i] = ps_sps->ai1_lt_ref_pic_poc_lsb_sps[value];\n                        ps_slice_hdr->ai1_used_by_curr_pic_lt_flag[i] = ps_sps->ai1_used_by_curr_pic_lt_sps_flag[value];\n\n }\n else\n {\n                        BITS_PARSE(\"poc_lsb_lt[ i ]\", value, ps_bitstrm, ps_sps->i1_log2_max_pic_order_cnt_lsb);\n                        ps_slice_hdr->ai4_poc_lsb_lt[i] = value;\n\n                        BITS_PARSE(\"used_by_curr_pic_lt_flag[ i ]\", value, ps_bitstrm, 1);\n                        ps_slice_hdr->ai1_used_by_curr_pic_lt_flag[i] = value;\n\n }\n                    BITS_PARSE(\"delta_poc_msb_present_flag[ i ]\", value, ps_bitstrm, 1);\n                    ps_slice_hdr->ai1_delta_poc_msb_present_flag[i] = value;\n\n\n                    ps_slice_hdr->ai1_delta_poc_msb_cycle_lt[i] = 0;\n if(ps_slice_hdr->ai1_delta_poc_msb_present_flag[i])\n {\n\n                        UEV_PARSE(\"delata_poc_msb_cycle_lt[ i ]\", value, ps_bitstrm);\n                        ps_slice_hdr->ai1_delta_poc_msb_cycle_lt[i] = value;\n }\n\n if((i != 0) && (i != ps_slice_hdr->i1_num_long_term_sps))\n {\n                        ps_slice_hdr->ai1_delta_poc_msb_cycle_lt[i] += ps_slice_hdr->ai1_delta_poc_msb_cycle_lt[i - 1];\n }\n\n }\n }\n\n for(i = 0; i < num_neg_pics + num_pos_pics; i++)\n {\n if(pi1_used[i])\n {\n                    num_poc_total_curr++;\n }\n }\n for(i = 0; i < ps_slice_hdr->i1_num_long_term_sps + ps_slice_hdr->i1_num_long_term_pics; i++)\n {\n if(ps_slice_hdr->ai1_used_by_curr_pic_lt_flag[i])\n {\n                    num_poc_total_curr++;\n }\n }\n\n\n if(ps_sps->i1_sps_temporal_mvp_enable_flag)\n {\n                BITS_PARSE(\"enable_temporal_mvp_flag\", value, ps_bitstrm, 1);\n                ps_slice_hdr->i1_slice_temporal_mvp_enable_flag = value;\n }\n\n }\n        ps_slice_hdr->i1_slice_sao_luma_flag = 0;\n        ps_slice_hdr->i1_slice_sao_chroma_flag = 0;\n if(ps_sps->i1_sample_adaptive_offset_enabled_flag)\n {\n            BITS_PARSE(\"slice_sao_luma_flag\", value, ps_bitstrm, 1);\n            ps_slice_hdr->i1_slice_sao_luma_flag = value;\n\n            BITS_PARSE(\"slice_sao_chroma_flag\", value, ps_bitstrm, 1);\n            ps_slice_hdr->i1_slice_sao_chroma_flag = value;\n\n }\n\n        ps_slice_hdr->i1_max_num_merge_cand = 1;\n        ps_slice_hdr->i1_cabac_init_flag = 0;\n\n        ps_slice_hdr->i1_num_ref_idx_l0_active = 0;\n        ps_slice_hdr->i1_num_ref_idx_l1_active = 0;\n        ps_slice_hdr->i1_slice_cb_qp_offset = 0;\n        ps_slice_hdr->i1_slice_cr_qp_offset = 0;\n if((PSLICE == ps_slice_hdr->i1_slice_type) ||\n (BSLICE == ps_slice_hdr->i1_slice_type))\n {\n            BITS_PARSE(\"num_ref_idx_active_override_flag\", value, ps_bitstrm, 1);\n            ps_slice_hdr->i1_num_ref_idx_active_override_flag = value;\n\n if(ps_slice_hdr->i1_num_ref_idx_active_override_flag)\n {\n                UEV_PARSE(\"num_ref_idx_l0_active_minus1\", value, ps_bitstrm);\n                ps_slice_hdr->i1_num_ref_idx_l0_active = value + 1;\n\n if(BSLICE == ps_slice_hdr->i1_slice_type)\n {\n                    UEV_PARSE(\"num_ref_idx_l1_active_minus1\", value, ps_bitstrm);\n                    ps_slice_hdr->i1_num_ref_idx_l1_active = value + 1;\n }\n\n }\n else\n {\n                ps_slice_hdr->i1_num_ref_idx_l0_active = ps_pps->i1_num_ref_idx_l0_default_active;\n\n if(BSLICE == ps_slice_hdr->i1_slice_type)\n {\n                    ps_slice_hdr->i1_num_ref_idx_l1_active = ps_pps->i1_num_ref_idx_l1_default_active;\n }\n }\n\n            ps_slice_hdr->i1_num_ref_idx_l0_active = CLIP3(ps_slice_hdr->i1_num_ref_idx_l0_active, 0, MAX_DPB_SIZE - 1);\n            ps_slice_hdr->i1_num_ref_idx_l1_active = CLIP3(ps_slice_hdr->i1_num_ref_idx_l1_active, 0, MAX_DPB_SIZE - 1);\n\n if(0 == num_poc_total_curr)\n return IHEVCD_IGNORE_SLICE;\n if((ps_pps->i1_lists_modification_present_flag) && (num_poc_total_curr > 1))\n {\n                ihevcd_ref_pic_list_modification(ps_bitstrm,\n                                                 ps_slice_hdr, num_poc_total_curr);\n }\n else\n {\n                ps_slice_hdr->s_rplm.i1_ref_pic_list_modification_flag_l0 = 0;\n                ps_slice_hdr->s_rplm.i1_ref_pic_list_modification_flag_l1 = 0;\n }\n\n if(BSLICE == ps_slice_hdr->i1_slice_type)\n {\n                BITS_PARSE(\"mvd_l1_zero_flag\", value, ps_bitstrm, 1);\n                ps_slice_hdr->i1_mvd_l1_zero_flag = value;\n }\n\n            ps_slice_hdr->i1_cabac_init_flag = 0;\n if(ps_pps->i1_cabac_init_present_flag)\n {\n                BITS_PARSE(\"cabac_init_flag\", value, ps_bitstrm, 1);\n                ps_slice_hdr->i1_cabac_init_flag = value;\n\n }\n            ps_slice_hdr->i1_collocated_from_l0_flag = 1;\n            ps_slice_hdr->i1_collocated_ref_idx = 0;\n if(ps_slice_hdr->i1_slice_temporal_mvp_enable_flag)\n {\n if(BSLICE == ps_slice_hdr->i1_slice_type)\n {\n                    BITS_PARSE(\"collocated_from_l0_flag\", value, ps_bitstrm, 1);\n                    ps_slice_hdr->i1_collocated_from_l0_flag = value;\n }\n\n if((ps_slice_hdr->i1_collocated_from_l0_flag  && (ps_slice_hdr->i1_num_ref_idx_l0_active > 1)) ||\n (!ps_slice_hdr->i1_collocated_from_l0_flag  && (ps_slice_hdr->i1_num_ref_idx_l1_active > 1)))\n {\n                    UEV_PARSE(\"collocated_ref_idx\", value, ps_bitstrm);\n                    ps_slice_hdr->i1_collocated_ref_idx = value;\n }\n\n }\n            ps_slice_hdr->i1_collocated_ref_idx = CLIP3(ps_slice_hdr->i1_collocated_ref_idx, 0, MAX_DPB_SIZE - 1);\n\n if((ps_pps->i1_weighted_pred_flag  && (PSLICE == ps_slice_hdr->i1_slice_type)) ||\n (ps_pps->i1_weighted_bipred_flag  && (BSLICE == ps_slice_hdr->i1_slice_type)))\n {\n                ihevcd_parse_pred_wt_ofst(ps_bitstrm, ps_sps, ps_pps, ps_slice_hdr);\n }\n            UEV_PARSE(\"five_minus_max_num_merge_cand\", value, ps_bitstrm);\n            ps_slice_hdr->i1_max_num_merge_cand = 5 - value;\n\n }\n        ps_slice_hdr->i1_max_num_merge_cand = CLIP3(ps_slice_hdr->i1_max_num_merge_cand, 1, 5);\n        SEV_PARSE(\"slice_qp_delta\", value, ps_bitstrm);\n        ps_slice_hdr->i1_slice_qp_delta = value;\n\n if(ps_pps->i1_pic_slice_level_chroma_qp_offsets_present_flag)\n {\n            SEV_PARSE(\"slice_cb_qp_offset\", value, ps_bitstrm);\n            ps_slice_hdr->i1_slice_cb_qp_offset = value;\n\n            SEV_PARSE(\"slice_cr_qp_offset\", value, ps_bitstrm);\n            ps_slice_hdr->i1_slice_cr_qp_offset = value;\n\n }\n        ps_slice_hdr->i1_deblocking_filter_override_flag = 0;\n        ps_slice_hdr->i1_slice_disable_deblocking_filter_flag  = ps_pps->i1_pic_disable_deblocking_filter_flag;\n        ps_slice_hdr->i1_beta_offset_div2 = ps_pps->i1_beta_offset_div2;\n        ps_slice_hdr->i1_tc_offset_div2 = ps_pps->i1_tc_offset_div2;\n\n        disable_deblocking_filter_flag = ps_pps->i1_pic_disable_deblocking_filter_flag;\n\n if(ps_pps->i1_deblocking_filter_control_present_flag)\n {\n\n if(ps_pps->i1_deblocking_filter_override_enabled_flag)\n {\n                BITS_PARSE(\"deblocking_filter_override_flag\", value, ps_bitstrm, 1);\n                ps_slice_hdr->i1_deblocking_filter_override_flag = value;\n }\n\n if(ps_slice_hdr->i1_deblocking_filter_override_flag)\n {\n                BITS_PARSE(\"slice_disable_deblocking_filter_flag\", value, ps_bitstrm, 1);\n                ps_slice_hdr->i1_slice_disable_deblocking_filter_flag = value;\n                disable_deblocking_filter_flag = ps_slice_hdr->i1_slice_disable_deblocking_filter_flag;\n\n if(!ps_slice_hdr->i1_slice_disable_deblocking_filter_flag)\n {\n                    SEV_PARSE(\"beta_offset_div2\", value, ps_bitstrm);\n                    ps_slice_hdr->i1_beta_offset_div2 = value;\n\n                    SEV_PARSE(\"tc_offset_div2\", value, ps_bitstrm);\n                    ps_slice_hdr->i1_tc_offset_div2 = value;\n\n }\n }\n }\n\n        ps_slice_hdr->i1_slice_loop_filter_across_slices_enabled_flag = ps_pps->i1_loop_filter_across_slices_enabled_flag;\n if(ps_pps->i1_loop_filter_across_slices_enabled_flag  &&\n (ps_slice_hdr->i1_slice_sao_luma_flag  ||  ps_slice_hdr->i1_slice_sao_chroma_flag  || !disable_deblocking_filter_flag))\n {\n            BITS_PARSE(\"slice_loop_filter_across_slices_enabled_flag\", value, ps_bitstrm, 1);\n            ps_slice_hdr->i1_slice_loop_filter_across_slices_enabled_flag = value;\n }\n\n }\n\n /* Check sanity of slice */\n if((!first_slice_in_pic_flag) &&\n (ps_codec->i4_pic_present))\n {\n slice_header_t *ps_slice_hdr_base = ps_codec->ps_slice_hdr_base;\n\n\n /* According to the standard, the above conditions must be satisfied - But for error resilience,\n         * only the following conditions are checked */\n if((ps_slice_hdr_base->i1_pps_id != ps_slice_hdr->i1_pps_id) ||\n (ps_slice_hdr_base->i4_pic_order_cnt_lsb != ps_slice_hdr->i4_pic_order_cnt_lsb))\n {\n return IHEVCD_IGNORE_SLICE;\n }\n\n }\n\n\n if(0 == ps_codec->i4_pic_present)\n {\n        ps_slice_hdr->i4_abs_pic_order_cnt = ihevcd_calc_poc(ps_codec, ps_nal, ps_sps->i1_log2_max_pic_order_cnt_lsb, ps_slice_hdr->i4_pic_order_cnt_lsb);\n }\n else\n {\n        ps_slice_hdr->i4_abs_pic_order_cnt = ps_codec->s_parse.i4_abs_pic_order_cnt;\n }\n\n\n if(!first_slice_in_pic_flag)\n {\n /* Check if the current slice belongs to the same pic (Pic being parsed) */\n if(ps_codec->s_parse.i4_abs_pic_order_cnt == ps_slice_hdr->i4_abs_pic_order_cnt)\n {\n\n /* If the Next CTB's index is less than the slice address,\n             * the previous slice is incomplete.\n             * Indicate slice error, and treat the remaining CTBs as skip */\n if(slice_address > ps_codec->s_parse.i4_next_ctb_indx)\n {\n if(ps_codec->i4_pic_present)\n {\n                    ps_codec->i4_slice_error = 1;\n                    ps_codec->s_parse.i4_cur_slice_idx--;\n if(ps_codec->s_parse.i4_cur_slice_idx < 0)\n                        ps_codec->s_parse.i4_cur_slice_idx = 0;\n\n return ret;\n }\n else\n {\n return IHEVCD_IGNORE_SLICE;\n }\n }\n /* If the slice address is less than the next CTB's index,\n             * extra CTBs have been decoded in the previous slice.\n             * Ignore the current slice. Treat it as incomplete */\n else if(slice_address < ps_codec->s_parse.i4_next_ctb_indx)\n {\n return IHEVCD_IGNORE_SLICE;\n }\n else\n {\n                ps_codec->i4_slice_error = 0;\n }\n }\n\n /* The current slice does not belong to the pic that is being parsed */\n else\n {\n /* The previous pic is incomplete.\n             * Treat the remaining CTBs as skip */\n if(ps_codec->i4_pic_present)\n {\n slice_header_t *ps_slice_hdr_next;\n                ps_codec->i4_slice_error = 1;\n                ps_codec->s_parse.i4_cur_slice_idx--;\n if(ps_codec->s_parse.i4_cur_slice_idx < 0)\n                    ps_codec->s_parse.i4_cur_slice_idx = 0;\n\n                ps_slice_hdr_next = ps_codec->s_parse.ps_slice_hdr_base + ((ps_codec->s_parse.i4_cur_slice_idx + 1) & (MAX_SLICE_HDR_CNT - 1));\n                ps_slice_hdr_next->i2_ctb_x = 0;\n                ps_slice_hdr_next->i2_ctb_y = ps_codec->s_parse.ps_sps->i2_pic_ht_in_ctb;\n return ret;\n }\n\n /* If the previous pic is complete,\n             * return if the current slice is dependant\n             * otherwise, update the parse context's POC */\n else\n {\n if(ps_slice_hdr->i1_dependent_slice_flag)\n return IHEVCD_IGNORE_SLICE;\n\n                ps_codec->s_parse.i4_abs_pic_order_cnt = ps_slice_hdr->i4_abs_pic_order_cnt;\n }\n }\n }\n\n /* If the slice is the first slice in the pic, update the parse context's POC */\n else\n {\n /* If the first slice is repeated, ignore the second occurrence\n         * If any other slice is repeated, the CTB addr will be greater than the slice addr,\n         * and hence the second occurrence is ignored */\n if(ps_codec->s_parse.i4_abs_pic_order_cnt == ps_slice_hdr->i4_abs_pic_order_cnt)\n return IHEVCD_IGNORE_SLICE;\n\n        ps_codec->s_parse.i4_abs_pic_order_cnt = ps_slice_hdr->i4_abs_pic_order_cnt;\n }\n\n    ps_slice_hdr->i4_num_entry_point_offsets = 0;\n if((ps_pps->i1_tiles_enabled_flag) ||\n (ps_pps->i1_entropy_coding_sync_enabled_flag))\n {\n        UEV_PARSE(\"num_entry_point_offsets\", value, ps_bitstrm);\n        ps_slice_hdr->i4_num_entry_point_offsets = value;\n\n {\n            WORD32 max_num_entry_point_offsets;\n if((ps_pps->i1_tiles_enabled_flag) &&\n (ps_pps->i1_entropy_coding_sync_enabled_flag))\n {\n                max_num_entry_point_offsets = ps_pps->i1_num_tile_columns * (ps_sps->i2_pic_ht_in_ctb - 1);\n }\n else if(ps_pps->i1_tiles_enabled_flag)\n {\n                max_num_entry_point_offsets = ps_pps->i1_num_tile_columns * ps_pps->i1_num_tile_rows;\n }\n else\n {\n                max_num_entry_point_offsets = (ps_sps->i2_pic_ht_in_ctb - 1);\n }\n\n            ps_slice_hdr->i4_num_entry_point_offsets = CLIP3(ps_slice_hdr->i4_num_entry_point_offsets,\n 0, max_num_entry_point_offsets);\n }\n\n if(ps_slice_hdr->i4_num_entry_point_offsets > 0)\n {\n            UEV_PARSE(\"offset_len_minus1\", value, ps_bitstrm);\n            ps_slice_hdr->i1_offset_len = value + 1;\n\n for(i = 0; i < ps_slice_hdr->i4_num_entry_point_offsets; i++)\n {\n                BITS_PARSE(\"entry_point_offset\", value, ps_bitstrm, ps_slice_hdr->i1_offset_len);\n\n /* TODO: pu4_entry_point_offset needs to be initialized */\n }\n\n }\n }\n\n if(ps_pps->i1_slice_header_extension_present_flag)\n {\n        UEV_PARSE(\"slice_header_extension_length\", value, ps_bitstrm);\n        ps_slice_hdr->i2_slice_header_extension_length = value;\n\n\n for(i = 0; i < ps_slice_hdr->i2_slice_header_extension_length; i++)\n {\n            BITS_PARSE(\"slice_header_extension_data_byte\", value, ps_bitstrm, 8);\n }\n\n }\n\n    ihevcd_bits_flush_to_byte_boundary(ps_bitstrm);\n\n {\n dpb_mgr_t *ps_dpb_mgr = (dpb_mgr_t *)ps_codec->pv_dpb_mgr;\n        WORD32 r_idx;\n\n if((NAL_IDR_W_LP == ps_slice_hdr->i1_nal_unit_type) ||\n (NAL_IDR_N_LP == ps_slice_hdr->i1_nal_unit_type) ||\n (NAL_BLA_N_LP == ps_slice_hdr->i1_nal_unit_type) ||\n (NAL_BLA_W_DLP == ps_slice_hdr->i1_nal_unit_type) ||\n (NAL_BLA_W_LP == ps_slice_hdr->i1_nal_unit_type) ||\n (0 == ps_codec->u4_pic_cnt))\n {\n for(i = 0; i < MAX_DPB_BUFS; i++)\n {\n if(ps_dpb_mgr->as_dpb_info[i].ps_pic_buf)\n {\n pic_buf_t *ps_pic_buf = ps_dpb_mgr->as_dpb_info[i].ps_pic_buf;\n mv_buf_t *ps_mv_buf;\n\n /* Long term index is set to MAX_DPB_BUFS to ensure it is not added as LT */\n\n                     ihevc_dpb_mgr_del_ref((dpb_mgr_t *)ps_codec->pv_dpb_mgr, (buf_mgr_t *)ps_codec->pv_pic_buf_mgr, ps_pic_buf->i4_abs_poc);\n                     /* Find buffer id of the MV bank corresponding to the buffer being freed (Buffer with POC of u4_abs_poc) */\n                     ps_mv_buf = (mv_buf_t *)ps_codec->ps_mv_buf;\n                    for(i = 0; i < BUF_MGR_MAX_CNT; i++)\n                     {\n                         if(ps_mv_buf && ps_mv_buf->i4_abs_poc == ps_pic_buf->i4_abs_poc)\n                         {\n                            ihevc_buf_mgr_release((buf_mgr_t *)ps_codec->pv_mv_buf_mgr, i, BUF_MGR_REF);\n                             break;\n                         }\n                         ps_mv_buf++;\n }\n\n }\n\n }\n\n /* Initialize the reference lists to NULL\n             * This is done to take care of the cases where the first pic is not IDR\n             * but the reference list is not created for the first pic because\n             * pic count is zero leaving the reference list uninitialised  */\n for(r_idx = 0; r_idx < MAX_DPB_SIZE; r_idx++)\n {\n                ps_slice_hdr->as_ref_pic_list0[r_idx].pv_pic_buf = NULL;\n                ps_slice_hdr->as_ref_pic_list0[r_idx].pv_mv_buf = NULL;\n\n                ps_slice_hdr->as_ref_pic_list1[r_idx].pv_pic_buf = NULL;\n                ps_slice_hdr->as_ref_pic_list1[r_idx].pv_mv_buf = NULL;\n }\n\n }\n else\n {\n            ret = ihevcd_ref_list(ps_codec, ps_pps, ps_sps, ps_slice_hdr);\n if ((WORD32)IHEVCD_SUCCESS != ret)\n {\n return ret;\n }\n\n }\n\n }\n\n /* Fill the remaining entries of the reference lists with the nearest POC\n     * This is done to handle cases where there is a corruption in the reference index */\n if(ps_codec->i4_pic_present)\n {\n pic_buf_t *ps_pic_buf_ref;\n mv_buf_t *ps_mv_buf_ref;\n        WORD32 r_idx;\n dpb_mgr_t *ps_dpb_mgr = (dpb_mgr_t *)ps_codec->pv_dpb_mgr;\n buf_mgr_t *ps_mv_buf_mgr = (buf_mgr_t *)ps_codec->pv_mv_buf_mgr;\n\n        ps_pic_buf_ref = ihevc_dpb_mgr_get_ref_by_nearest_poc(ps_dpb_mgr, ps_slice_hdr->i4_abs_pic_order_cnt);\n if(NULL == ps_pic_buf_ref)\n {\n            ps_pic_buf_ref = ps_codec->as_process[0].ps_cur_pic;\n            ps_mv_buf_ref = ps_codec->s_parse.ps_cur_mv_buf;\n }\n else\n {\n            ps_mv_buf_ref = ihevcd_mv_mgr_get_poc(ps_mv_buf_mgr, ps_pic_buf_ref->i4_abs_poc);\n }\n\n for(r_idx = 0; r_idx < ps_slice_hdr->i1_num_ref_idx_l0_active; r_idx++)\n {\n if(NULL == ps_slice_hdr->as_ref_pic_list0[r_idx].pv_pic_buf)\n {\n                ps_slice_hdr->as_ref_pic_list0[r_idx].pv_pic_buf = (void *)ps_pic_buf_ref;\n                ps_slice_hdr->as_ref_pic_list0[r_idx].pv_mv_buf = (void *)ps_mv_buf_ref;\n }\n }\n\n for(r_idx = ps_slice_hdr->i1_num_ref_idx_l0_active; r_idx < MAX_DPB_SIZE; r_idx++)\n {\n            ps_slice_hdr->as_ref_pic_list0[r_idx].pv_pic_buf = (void *)ps_pic_buf_ref;\n            ps_slice_hdr->as_ref_pic_list0[r_idx].pv_mv_buf = (void *)ps_mv_buf_ref;\n }\n\n for(r_idx = 0; r_idx < ps_slice_hdr->i1_num_ref_idx_l1_active; r_idx++)\n {\n if(NULL == ps_slice_hdr->as_ref_pic_list1[r_idx].pv_pic_buf)\n {\n                ps_slice_hdr->as_ref_pic_list1[r_idx].pv_pic_buf = (void *)ps_pic_buf_ref;\n                ps_slice_hdr->as_ref_pic_list1[r_idx].pv_mv_buf = (void *)ps_mv_buf_ref;\n }\n }\n\n for(r_idx = ps_slice_hdr->i1_num_ref_idx_l1_active; r_idx < MAX_DPB_SIZE; r_idx++)\n {\n            ps_slice_hdr->as_ref_pic_list1[r_idx].pv_pic_buf = (void *)ps_pic_buf_ref;\n            ps_slice_hdr->as_ref_pic_list1[r_idx].pv_mv_buf = (void *)ps_mv_buf_ref;\n }\n }\n\n /* Update slice address in the header */\n if(!ps_slice_hdr->i1_first_slice_in_pic_flag)\n {\n        ps_slice_hdr->i2_ctb_x = slice_address % ps_sps->i2_pic_wd_in_ctb;\n        ps_slice_hdr->i2_ctb_y = slice_address / ps_sps->i2_pic_wd_in_ctb;\n\n if(!ps_slice_hdr->i1_dependent_slice_flag)\n {\n            ps_slice_hdr->i2_independent_ctb_x = ps_slice_hdr->i2_ctb_x;\n            ps_slice_hdr->i2_independent_ctb_y = ps_slice_hdr->i2_ctb_y;\n }\n }\n else\n {\n        ps_slice_hdr->i2_ctb_x = 0;\n        ps_slice_hdr->i2_ctb_y = 0;\n\n        ps_slice_hdr->i2_independent_ctb_x = 0;\n        ps_slice_hdr->i2_independent_ctb_y = 0;\n }\n\n /* If the first slice in the pic is missing, copy the current slice header to\n     * the first slice's header */\n if((!first_slice_in_pic_flag) &&\n (0 == ps_codec->i4_pic_present))\n {\n slice_header_t *ps_slice_hdr_prev = ps_codec->s_parse.ps_slice_hdr_base;\n        ihevcd_copy_slice_hdr(ps_codec, 0, (ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1)));\n\n        ps_codec->i4_slice_error = 1;\n\n        ps_slice_hdr_prev->i2_ctb_x = 0;\n        ps_slice_hdr_prev->i2_ctb_y = 0;\n\n        ps_codec->s_parse.i4_ctb_x = 0;\n        ps_codec->s_parse.i4_ctb_y = 0;\n\n        ps_codec->s_parse.i4_cur_slice_idx = 0;\n\n if((ps_slice_hdr->i2_ctb_x == 0) &&\n (ps_slice_hdr->i2_ctb_y == 0))\n {\n            ps_slice_hdr->i2_ctb_x++;\n }\n }\n\n {\n /* If skip B is enabled,\n         * ignore pictures that are non-reference\n         * TODO: (i1_nal_unit_type < NAL_BLA_W_LP) && (i1_nal_unit_type % 2 == 0) only says it is\n         * sub-layer non-reference slice. May need to find a way to detect actual non-reference pictures*/\n\n if((i1_nal_unit_type < NAL_BLA_W_LP) &&\n (i1_nal_unit_type % 2 == 0))\n {\n if(IVD_SKIP_B == ps_codec->e_pic_skip_mode)\n return IHEVCD_IGNORE_SLICE;\n }\n\n /* If skip PB is enabled,\n         * decode only I slices */\n if((IVD_SKIP_PB == ps_codec->e_pic_skip_mode) &&\n (ISLICE != ps_slice_hdr->i1_slice_type))\n {\n return IHEVCD_IGNORE_SLICE;\n }\n }\n\n return ret;\n}\n", "target": 1, "idx": 188019}
{"func": "   virtual void SetUp() {\n    full_itxfm_ = GET_PARAM(0);\n    partial_itxfm_ = GET_PARAM(1);\n    tx_size_  = GET_PARAM(2);\n    last_nonzero_ = GET_PARAM(3);\n   }\n", "target": 1, "idx": 188589}
{"func": "ftrace_profile_write(struct file *filp, const char __user *ubuf,\n\t\t     size_t cnt, loff_t *ppos)\n{\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul_from_user(ubuf, cnt, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tval = !!val;\n\n\tmutex_lock(&ftrace_profile_lock);\n\tif (ftrace_profile_enabled ^ val) {\n\t\tif (val) {\n\t\t\tret = ftrace_profile_init();\n\t\t\tif (ret < 0) {\n\t\t\t\tcnt = ret;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = register_ftrace_profiler();\n\t\t\tif (ret < 0) {\n\t\t\t\tcnt = ret;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tftrace_profile_enabled = 1;\n\t\t} else {\n\t\t\tftrace_profile_enabled = 0;\n\t\t\t/*\n\t\t\t * unregister_ftrace_profiler calls stop_machine\n\t\t\t * so this acts like an synchronize_sched.\n\t\t\t */\n\t\t\tunregister_ftrace_profiler();\n\t\t}\n\t}\n out:\n\tmutex_unlock(&ftrace_profile_lock);\n\n\t*ppos += cnt;\n\n\treturn cnt;\n}\n", "target": 0, "idx": 30209}
{"func": "static MagickBooleanType WritePNMImage(const ImageInfo *image_info,Image *image)\n{\n  char\n    buffer[MaxTextExtent],\n    format,\n    magick[MaxTextExtent];\n\n  const char\n    *value;\n\n  IndexPacket\n    index;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  QuantumAny\n    pixel;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  register unsigned char\n    *pixels,\n    *q;\n\n  size_t\n    extent,\n    imageListLength,\n    packet_size;\n\n  ssize_t\n    count,\n    y;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(status);\n  scene=0;\n  imageListLength=GetImageListLength(image);\n  do\n  {\n    QuantumAny\n      max_value;\n\n    /*\n      Write PNM file header.\n    */\n    max_value=GetQuantumRange(image->depth);\n    packet_size=3;\n    quantum_type=RGBQuantum;\n    (void) CopyMagickString(magick,image_info->magick,MaxTextExtent);\n    switch (magick[1])\n    {\n      case 'A':\n      case 'a':\n      {\n        format='7';\n        break;\n      }\n      case 'B':\n      case 'b':\n      {\n        format='4';\n        if (image_info->compression == NoCompression)\n          format='1';\n        break;\n      }\n      case 'F':\n      case 'f':\n      {\n        format='F';\n        if (SetImageGray(image,&image->exception) != MagickFalse)\n          format='f';\n        break;\n      }\n      case 'G':\n      case 'g':\n      {\n        format='5';\n        if (image_info->compression == NoCompression)\n          format='2';\n        break;\n      }\n      case 'N':\n      case 'n':\n      {\n        if ((image_info->type != TrueColorType) &&\n            (SetImageGray(image,&image->exception) != MagickFalse))\n          {\n            format='5';\n            if (image_info->compression == NoCompression)\n              format='2';\n            if (SetImageMonochrome(image,&image->exception) != MagickFalse)\n              {\n                format='4';\n                if (image_info->compression == NoCompression)\n                  format='1';\n              }\n            break;\n          }\n      }\n      default:\n      {\n        format='6';\n        if (image_info->compression == NoCompression)\n          format='3';\n        break;\n      }\n    }\n    (void) FormatLocaleString(buffer,MaxTextExtent,\"P%c\\n\",format);\n    (void) WriteBlobString(image,buffer);\n    value=GetImageProperty(image,\"comment\");\n    if (value != (const char *) NULL)\n      {\n        register const char\n          *p;\n\n        /*\n          Write comments to file.\n        */\n        (void) WriteBlobByte(image,'#');\n        for (p=value; *p != '\\0'; p++)\n        {\n          (void) WriteBlobByte(image,(unsigned char) *p);\n          if ((*p == '\\n') || (*p == '\\r'))\n            (void) WriteBlobByte(image,'#');\n        }\n        (void) WriteBlobByte(image,'\\n');\n      }\n    if (format != '7')\n      {\n        (void) FormatLocaleString(buffer,MaxTextExtent,\"%.20g %.20g\\n\",\n          (double) image->columns,(double) image->rows);\n        (void) WriteBlobString(image,buffer);\n      }\n    else\n      {\n        char\n          type[MaxTextExtent];\n\n        /*\n          PAM header.\n        */\n        (void) FormatLocaleString(buffer,MaxTextExtent,\n          \"WIDTH %.20g\\nHEIGHT %.20g\\n\",(double) image->columns,(double)\n          image->rows);\n        (void) WriteBlobString(image,buffer);\n        quantum_type=GetQuantumType(image,&image->exception);\n        switch (quantum_type)\n        {\n          case CMYKQuantum:\n          case CMYKAQuantum:\n          {\n            packet_size=4;\n            (void) CopyMagickString(type,\"CMYK\",MaxTextExtent);\n            break;\n          }\n          case GrayQuantum:\n          case GrayAlphaQuantum:\n          {\n            packet_size=1;\n            (void) CopyMagickString(type,\"GRAYSCALE\",MaxTextExtent);\n            if (IdentifyImageMonochrome(image,&image->exception) != MagickFalse)\n              (void) CopyMagickString(type,\"BLACKANDWHITE\",MaxTextExtent);\n            break;\n          }\n          default:\n          {\n            quantum_type=RGBQuantum;\n            if (image->matte != MagickFalse)\n              quantum_type=RGBAQuantum;\n            packet_size=3;\n            (void) CopyMagickString(type,\"RGB\",MaxTextExtent);\n            break;\n          }\n        }\n        if (image->matte != MagickFalse)\n          {\n            packet_size++;\n            (void) ConcatenateMagickString(type,\"_ALPHA\",MaxTextExtent);\n          }\n        if (image->depth > 32)\n          image->depth=32;\n        (void) FormatLocaleString(buffer,MaxTextExtent,\n          \"DEPTH %.20g\\nMAXVAL %.20g\\n\",(double) packet_size,(double)\n          ((MagickOffsetType) GetQuantumRange(image->depth)));\n        (void) WriteBlobString(image,buffer);\n        (void) FormatLocaleString(buffer,MaxTextExtent,\"TUPLTYPE %s\\nENDHDR\\n\",\n          type);\n        (void) WriteBlobString(image,buffer);\n      }\n    /*\n      Convert to PNM raster pixels.\n    */\n    switch (format)\n    {\n      case '1':\n      {\n        unsigned char\n          pixels[2048];\n\n        /*\n          Convert image to a PBM image.\n        */\n        (void) SetImageType(image,BilevelType);\n        q=pixels;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const PixelPacket\n            *magick_restrict p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n          if (p == (const PixelPacket *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=(unsigned char) (GetPixelLuma(image,p) >= (QuantumRange/2.0) ?\n              '0' : '1');\n            *q++=' ';\n            if ((q-pixels+1) >= (ssize_t) sizeof(pixels))\n              {\n                *q++='\\n';\n                (void) WriteBlob(image,q-pixels,pixels);\n                q=pixels;\n              }\n            p++;\n          }\n          *q++='\\n';\n          (void) WriteBlob(image,q-pixels,pixels);\n          q=pixels;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        if (q != pixels)\n          {\n            *q++='\\n';\n            (void) WriteBlob(image,q-pixels,pixels);\n          }\n        break;\n      }\n      case '2':\n      {\n        unsigned char\n          pixels[2048];\n\n        /*\n          Convert image to a PGM image.\n        */\n        if (image->depth <= 8)\n          (void) WriteBlobString(image,\"255\\n\");\n        else\n          if (image->depth <= 16)\n            (void) WriteBlobString(image,\"65535\\n\");\n          else\n            (void) WriteBlobString(image,\"4294967295\\n\");\n        q=pixels;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const PixelPacket\n            *magick_restrict p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n          if (p == (const PixelPacket *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            index=ClampToQuantum(GetPixelLuma(image,p));\n            if (image->depth <= 8)\n              count=(ssize_t) FormatLocaleString(buffer,MaxTextExtent,\"%u \",\n                ScaleQuantumToChar(index));\n            else\n              if (image->depth <= 16)\n                count=(ssize_t) FormatLocaleString(buffer,MaxTextExtent,\"%u \",\n                  ScaleQuantumToShort(index));\n              else\n                count=(ssize_t) FormatLocaleString(buffer,MaxTextExtent,\"%u \",\n                  ScaleQuantumToLong(index));\n             extent=(size_t) count;\n             (void) strncpy((char *) q,buffer,extent);\n             q+=extent;\n            if ((q-pixels+extent+1) >= sizeof(pixels))\n               {\n                 *q++='\\n';\n                 (void) WriteBlob(image,q-pixels,pixels);\n                q=pixels;\n              }\n            p++;\n          }\n          *q++='\\n';\n          (void) WriteBlob(image,q-pixels,pixels);\n          q=pixels;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        if (q != pixels)\n          {\n            *q++='\\n';\n            (void) WriteBlob(image,q-pixels,pixels);\n          }\n        break;\n      }\n      case '3':\n      {\n        unsigned char\n          pixels[2048];\n\n        /*\n          Convert image to a PNM image.\n        */\n        (void) TransformImageColorspace(image,sRGBColorspace);\n        if (image->depth <= 8)\n          (void) WriteBlobString(image,\"255\\n\");\n        else\n          if (image->depth <= 16)\n            (void) WriteBlobString(image,\"65535\\n\");\n          else\n            (void) WriteBlobString(image,\"4294967295\\n\");\n        q=pixels;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const PixelPacket\n            *magick_restrict p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n          if (p == (const PixelPacket *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            if (image->depth <= 8)\n              count=(ssize_t) FormatLocaleString(buffer,MaxTextExtent,\n                \"%u %u %u \",ScaleQuantumToChar(GetPixelRed(p)),\n                ScaleQuantumToChar(GetPixelGreen(p)),\n                ScaleQuantumToChar(GetPixelBlue(p)));\n            else\n              if (image->depth <= 16)\n                count=(ssize_t) FormatLocaleString(buffer,MaxTextExtent,\n                  \"%u %u %u \",ScaleQuantumToShort(GetPixelRed(p)),\n                  ScaleQuantumToShort(GetPixelGreen(p)),\n                  ScaleQuantumToShort(GetPixelBlue(p)));\n              else\n                count=(ssize_t) FormatLocaleString(buffer,MaxTextExtent,\n                  \"%u %u %u \",ScaleQuantumToLong(GetPixelRed(p)),\n                  ScaleQuantumToLong(GetPixelGreen(p)),\n                  ScaleQuantumToLong(GetPixelBlue(p)));\n             extent=(size_t) count;\n             (void) strncpy((char *) q,buffer,extent);\n             q+=extent;\n            if ((q-pixels+extent+1) >= sizeof(pixels))\n               {\n                 *q++='\\n';\n                 (void) WriteBlob(image,q-pixels,pixels);\n                q=pixels;\n              }\n            p++;\n          }\n          *q++='\\n';\n          (void) WriteBlob(image,q-pixels,pixels);\n          q=pixels;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        if (q != pixels)\n          {\n            *q++='\\n';\n            (void) WriteBlob(image,q-pixels,pixels);\n          }\n        break;\n      }\n      case '4':\n      {\n        /*\n          Convert image to a PBM image.\n        */\n        (void) SetImageType(image,BilevelType);\n        image->depth=1;\n        quantum_info=AcquireQuantumInfo(image_info,image);\n        if (quantum_info == (QuantumInfo *) NULL)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) SetQuantumEndian(image,quantum_info,MSBEndian);\n        quantum_info->min_is_white=MagickTrue;\n        pixels=GetQuantumPixels(quantum_info);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const PixelPacket\n            *magick_restrict p;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n          if (p == (const PixelPacket *) NULL)\n            break;\n          extent=ExportQuantumPixels(image,(const CacheView *) NULL,\n            quantum_info,GrayQuantum,pixels,&image->exception);\n          count=WriteBlob(image,extent,pixels);\n          if (count != (ssize_t) extent)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        quantum_info=DestroyQuantumInfo(quantum_info);\n        break;\n      }\n      case '5':\n      {\n        /*\n          Convert image to a PGM image.\n        */\n        if (image->depth > 32)\n          image->depth=32;\n        (void) FormatLocaleString(buffer,MaxTextExtent,\"%.20g\\n\",(double)\n          ((MagickOffsetType) GetQuantumRange(image->depth)));\n        (void) WriteBlobString(image,buffer);\n        quantum_info=AcquireQuantumInfo(image_info,image);\n        if (quantum_info == (QuantumInfo *) NULL)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) SetQuantumEndian(image,quantum_info,MSBEndian);\n        quantum_info->min_is_white=MagickTrue;\n        pixels=GetQuantumPixels(quantum_info);\n        extent=GetQuantumExtent(image,quantum_info,GrayQuantum);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const PixelPacket\n            *magick_restrict p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n          if (p == (const PixelPacket *) NULL)\n            break;\n          q=pixels;\n          switch (image->depth)\n          {\n            case 8:\n            case 16:\n            case 32:\n            {\n              extent=ExportQuantumPixels(image,(const CacheView *) NULL,\n                quantum_info,GrayQuantum,pixels,&image->exception);\n              break;\n            }\n            default:\n            {\n              if (image->depth <= 8)\n                {\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    if (IsGrayPixel(p) == MagickFalse)\n                      pixel=ScaleQuantumToAny(ClampToQuantum(\n                        GetPixelLuma(image,p)),max_value);\n                    else\n                      {\n                        if (image->depth == 8)\n                          pixel=ScaleQuantumToChar(GetPixelRed(p));\n                        else\n                          pixel=ScaleQuantumToAny(GetPixelRed(p),max_value);\n                      }\n                    q=PopCharPixel((unsigned char) pixel,q);\n                    p++;\n                  }\n                  extent=(size_t) (q-pixels);\n                  break;\n                }\n              if (image->depth <= 16)\n                {\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    if (IsGrayPixel(p) == MagickFalse)\n                      pixel=ScaleQuantumToAny(ClampToQuantum(\n                        GetPixelLuma(image,p)),max_value);\n                    else\n                      {\n                        if (image->depth == 16)\n                          pixel=ScaleQuantumToShort(GetPixelRed(p));\n                        else\n                          pixel=ScaleQuantumToAny(GetPixelRed(p),max_value);\n                      }\n                    q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                    p++;\n                  }\n                  extent=(size_t) (q-pixels);\n                  break;\n                }\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                if (IsGrayPixel(p) == MagickFalse)\n                  pixel=ScaleQuantumToAny(ClampToQuantum(\n                    GetPixelLuma(image,p)),max_value);\n                else\n                  {\n                    if (image->depth == 32)\n                      pixel=ScaleQuantumToLong(GetPixelRed(p));\n                    else\n                      pixel=ScaleQuantumToAny(GetPixelRed(p),max_value);\n                  }\n                q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                p++;\n              }\n              extent=(size_t) (q-pixels);\n              break;\n            }\n          }\n          count=WriteBlob(image,extent,pixels);\n          if (count != (ssize_t) extent)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        quantum_info=DestroyQuantumInfo(quantum_info);\n        break;\n      }\n      case '6':\n      {\n        /*\n          Convert image to a PNM image.\n        */\n        (void) TransformImageColorspace(image,sRGBColorspace);\n        if (image->depth > 32)\n          image->depth=32;\n        (void) FormatLocaleString(buffer,MaxTextExtent,\"%.20g\\n\",(double)\n          ((MagickOffsetType) GetQuantumRange(image->depth)));\n        (void) WriteBlobString(image,buffer);\n        quantum_info=AcquireQuantumInfo(image_info,image);\n        if (quantum_info == (QuantumInfo *) NULL)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) SetQuantumEndian(image,quantum_info,MSBEndian);\n        (void) SetQuantumEndian(image,quantum_info,MSBEndian);\n        pixels=GetQuantumPixels(quantum_info);\n        extent=GetQuantumExtent(image,quantum_info,quantum_type);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const PixelPacket\n            *magick_restrict p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n          if (p == (const PixelPacket *) NULL)\n            break;\n          q=pixels;\n          switch (image->depth)\n          {\n            case 8:\n            case 16:\n            case 32:\n            {\n              extent=ExportQuantumPixels(image,(const CacheView *) NULL,\n                quantum_info,quantum_type,pixels,&image->exception);\n              break;\n            }\n            default:\n            {\n              if (image->depth <= 8)\n                {\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    pixel=ScaleQuantumToAny(GetPixelRed(p),max_value);\n                    q=PopCharPixel((unsigned char) pixel,q);\n                    pixel=ScaleQuantumToAny(GetPixelGreen(p),max_value);\n                    q=PopCharPixel((unsigned char) pixel,q);\n                    pixel=ScaleQuantumToAny(GetPixelBlue(p),max_value);\n                    q=PopCharPixel((unsigned char) pixel,q);\n                    p++;\n                  }\n                  extent=(size_t) (q-pixels);\n                  break;\n                }\n              if (image->depth <= 16)\n                {\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    pixel=ScaleQuantumToAny(GetPixelRed(p),max_value);\n                    q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                    pixel=ScaleQuantumToAny(GetPixelGreen(p),max_value);\n                    q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                    pixel=ScaleQuantumToAny(GetPixelBlue(p),max_value);\n                    q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                    p++;\n                  }\n                  extent=(size_t) (q-pixels);\n                  break;\n                }\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                pixel=ScaleQuantumToAny(GetPixelRed(p),max_value);\n                q=PopLongPixel(MSBEndian,(unsigned short) pixel,q);\n                pixel=ScaleQuantumToAny(GetPixelGreen(p),max_value);\n                q=PopLongPixel(MSBEndian,(unsigned short) pixel,q);\n                pixel=ScaleQuantumToAny(GetPixelBlue(p),max_value);\n                q=PopLongPixel(MSBEndian,(unsigned short) pixel,q);\n                p++;\n              }\n              extent=(size_t) (q-pixels);\n              break;\n            }\n          }\n          count=WriteBlob(image,extent,pixels);\n          if (count != (ssize_t) extent)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        quantum_info=DestroyQuantumInfo(quantum_info);\n        break;\n      }\n      case '7':\n      {\n        /*\n          Convert image to a PAM.\n        */\n        if (image->depth > 32)\n          image->depth=32;\n        quantum_info=AcquireQuantumInfo(image_info,image);\n        if (quantum_info == (QuantumInfo *) NULL)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) SetQuantumEndian(image,quantum_info,MSBEndian);\n        pixels=GetQuantumPixels(quantum_info);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const IndexPacket\n            *magick_restrict indexes;\n\n          register const PixelPacket\n            *magick_restrict p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n          if (p == (const PixelPacket *) NULL)\n            break;\n          indexes=GetVirtualIndexQueue(image);\n          q=pixels;\n          switch (image->depth)\n          {\n            case 8:\n            case 16:\n            case 32:\n            {\n              extent=ExportQuantumPixels(image,(const CacheView *) NULL,\n                quantum_info,quantum_type,pixels,&image->exception);\n              break;\n            }\n            default:\n            {\n              switch (quantum_type)\n              {\n                case GrayQuantum:\n                case GrayAlphaQuantum:\n                {\n                  if (image->depth <= 8)\n                    {\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        pixel=ScaleQuantumToAny(ClampToQuantum(\n                          GetPixelLuma(image,p)),max_value);\n                        q=PopCharPixel((unsigned char) pixel,q);\n                        if (image->matte != MagickFalse)\n                          {\n                            pixel=(unsigned char) ScaleQuantumToAny(\n                              GetPixelOpacity(p),max_value);\n                            q=PopCharPixel((unsigned char) pixel,q);\n                          }\n                        p++;\n                      }\n                      break;\n                    }\n                  if (image->depth <= 16)\n                    {\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        pixel=ScaleQuantumToAny(ClampToQuantum(\n                          GetPixelLuma(image,p)),max_value);\n                        q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                        if (image->matte != MagickFalse)\n                          {\n                            pixel=(unsigned char) ScaleQuantumToAny(\n                              GetPixelOpacity(p),max_value);\n                            q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                          }\n                        p++;\n                      }\n                      break;\n                    }\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    pixel=ScaleQuantumToAny(ClampToQuantum(\n                      GetPixelLuma(image,p)),max_value);\n                    q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                    if (image->matte != MagickFalse)\n                      {\n                        pixel=(unsigned char) ScaleQuantumToAny(\n                          GetPixelOpacity(p),max_value);\n                        q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                      }\n                    p++;\n                  }\n                  break;\n                }\n                case CMYKQuantum:\n                case CMYKAQuantum:\n                {\n                  if (image->depth <= 8)\n                    {\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        pixel=ScaleQuantumToAny(GetPixelRed(p),max_value);\n                        q=PopCharPixel((unsigned char) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelGreen(p),max_value);\n                        q=PopCharPixel((unsigned char) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelBlue(p),max_value);\n                        q=PopCharPixel((unsigned char) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelIndex(indexes+x),\n                          max_value);\n                        q=PopCharPixel((unsigned char) pixel,q);\n                        if (image->matte != MagickFalse)\n                          {\n                            pixel=ScaleQuantumToAny((Quantum) (QuantumRange-\n                              GetPixelOpacity(p)),max_value);\n                            q=PopCharPixel((unsigned char) pixel,q);\n                          }\n                        p++;\n                      }\n                      break;\n                    }\n                  if (image->depth <= 16)\n                    {\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        pixel=ScaleQuantumToAny(GetPixelRed(p),max_value);\n                        q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelGreen(p),max_value);\n                        q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelBlue(p),max_value);\n                        q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelIndex(indexes+x),\n                          max_value);\n                        q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                        if (image->matte != MagickFalse)\n                          {\n                            pixel=ScaleQuantumToAny((Quantum) (QuantumRange-\n                              GetPixelOpacity(p)),max_value);\n                            q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                          }\n                        p++;\n                      }\n                      break;\n                    }\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    pixel=ScaleQuantumToAny(GetPixelRed(p),max_value);\n                    q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                    pixel=ScaleQuantumToAny(GetPixelGreen(p),max_value);\n                    q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                    pixel=ScaleQuantumToAny(GetPixelBlue(p),max_value);\n                    q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                    pixel=ScaleQuantumToAny(GetPixelIndex(indexes+x),max_value);\n                    q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                    if (image->matte != MagickFalse)\n                      {\n                        pixel=ScaleQuantumToAny((Quantum) (QuantumRange-\n                          GetPixelOpacity(p)),max_value);\n                        q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                      }\n                    p++;\n                  }\n                  break;\n                }\n                default:\n                {\n                  if (image->depth <= 8)\n                    {\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        pixel=ScaleQuantumToAny(GetPixelRed(p),max_value);\n                        q=PopCharPixel((unsigned char) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelGreen(p),max_value);\n                        q=PopCharPixel((unsigned char) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelBlue(p),max_value);\n                        q=PopCharPixel((unsigned char) pixel,q);\n                        if (image->matte != MagickFalse)\n                          {\n                            pixel=ScaleQuantumToAny((Quantum) (QuantumRange-\n                              GetPixelOpacity(p)),max_value);\n                            q=PopCharPixel((unsigned char) pixel,q);\n                          }\n                        p++;\n                      }\n                      break;\n                    }\n                  if (image->depth <= 16)\n                    {\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        pixel=ScaleQuantumToAny(GetPixelRed(p),max_value);\n                        q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelGreen(p),max_value);\n                        q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelBlue(p),max_value);\n                        q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                        if (image->matte != MagickFalse)\n                          {\n                            pixel=ScaleQuantumToAny((Quantum) (QuantumRange-\n                              GetPixelOpacity(p)),max_value);\n                            q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                          }\n                        p++;\n                      }\n                      break;\n                    }\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    pixel=ScaleQuantumToAny(GetPixelRed(p),max_value);\n                    q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                    pixel=ScaleQuantumToAny(GetPixelGreen(p),max_value);\n                    q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                    pixel=ScaleQuantumToAny(GetPixelBlue(p),max_value);\n                    q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                    if (image->matte != MagickFalse)\n                      {\n                        pixel=ScaleQuantumToAny((Quantum) (QuantumRange-\n                          GetPixelOpacity(p)),max_value);\n                        q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                      }\n                    p++;\n                  }\n                  break;\n                }\n              }\n              extent=(size_t) (q-pixels);\n              break;\n            }\n          }\n          count=WriteBlob(image,extent,pixels);\n          if (count != (ssize_t) extent)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        quantum_info=DestroyQuantumInfo(quantum_info);\n        break;\n      }\n      case 'F':\n      case 'f':\n      {\n        (void) WriteBlobString(image,image->endian == LSBEndian ? \"-1.0\\n\" :\n          \"1.0\\n\");\n        image->depth=32;\n        quantum_type=format == 'f' ? GrayQuantum : RGBQuantum;\n        quantum_info=AcquireQuantumInfo((const ImageInfo *) NULL,image);\n        if (quantum_info == (QuantumInfo *) NULL)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);\n        if (status == MagickFalse)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        pixels=GetQuantumPixels(quantum_info);\n        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          register const PixelPacket\n            *magick_restrict p;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n          if (p == (const PixelPacket *) NULL)\n            break;\n          extent=ExportQuantumPixels(image,(const CacheView *) NULL,\n            quantum_info,quantum_type,pixels,&image->exception);\n          (void) WriteBlob(image,extent,pixels);\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        quantum_info=DestroyQuantumInfo(quantum_info);\n        break;\n      }\n    }\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,imageListLength);\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n", "target": 1, "idx": 182768}
{"func": " DictionaryValue* BaseNode::GetDetailsAsValue() const {\n   DictionaryValue* node_info = GetSummaryAsValue();\n  node_info->SetString(\n      \"modificationTime\",\n      browser_sync::GetTimeDebugString(GetModificationTime()));\n   node_info->SetString(\"parentId\", base::Int64ToString(GetParentId()));\n  node_info->SetString(\"externalId\",\n                       base::Int64ToString(GetExternalId()));\n  node_info->SetString(\"predecessorId\",\n                       base::Int64ToString(GetPredecessorId()));\n  node_info->SetString(\"successorId\",\n                       base::Int64ToString(GetSuccessorId()));\n  node_info->SetString(\"firstChildId\",\n                       base::Int64ToString(GetFirstChildId()));\n  node_info->Set(\"entry\", GetEntry()->ToValue());\n  return node_info;\n}\n", "target": 1, "idx": 183661}
{"func": "ofputil_decode_packet_out(struct ofputil_packet_out *po,\n                          const struct ofp_header *oh,\n                          struct ofpbuf *ofpacts)\n{\n    struct ofpbuf b = ofpbuf_const_initializer(oh, ntohs(oh->length));\n    enum ofpraw raw = ofpraw_pull_assert(&b);\n\n    ofpbuf_clear(ofpacts);\n    if (raw == OFPRAW_OFPT11_PACKET_OUT) {\n        enum ofperr error;\n        const struct ofp11_packet_out *opo = ofpbuf_pull(&b, sizeof *opo);\n\n        po->buffer_id = ntohl(opo->buffer_id);\n        error = ofputil_port_from_ofp11(opo->in_port, &po->in_port);\n        if (error) {\n            return error;\n        }\n\n        error = ofpacts_pull_openflow_actions(&b, ntohs(opo->actions_len),\n                                              oh->version, NULL, NULL,\n                                              ofpacts);\n        if (error) {\n            return error;\n        }\n    } else if (raw == OFPRAW_OFPT10_PACKET_OUT) {\n        enum ofperr error;\n        const struct ofp10_packet_out *opo = ofpbuf_pull(&b, sizeof *opo);\n\n        po->buffer_id = ntohl(opo->buffer_id);\n        po->in_port = u16_to_ofp(ntohs(opo->in_port));\n\n        error = ofpacts_pull_openflow_actions(&b, ntohs(opo->actions_len),\n                                              oh->version, NULL, NULL,\n                                              ofpacts);\n        if (error) {\n            return error;\n        }\n    } else {\n        OVS_NOT_REACHED();\n    }\n\n    if (ofp_to_u16(po->in_port) >= ofp_to_u16(OFPP_MAX)\n        && po->in_port != OFPP_LOCAL\n        && po->in_port != OFPP_NONE && po->in_port != OFPP_CONTROLLER) {\n        VLOG_WARN_RL(&bad_ofmsg_rl, \"packet-out has bad input port %#\"PRIx32,\n                     po->in_port);\n        return OFPERR_OFPBRC_BAD_PORT;\n    }\n\n    po->ofpacts = ofpacts->data;\n    po->ofpacts_len = ofpacts->size;\n\n    if (po->buffer_id == UINT32_MAX) {\n        po->packet = b.data;\n        po->packet_len = b.size;\n    } else {\n        po->packet = NULL;\n        po->packet_len = 0;\n    }\n\n    return 0;\n}\n", "target": 0, "idx": 77528}
{"func": "void PulseAudioMixer::CompleteOperation(pa_operation* pa_op,\n                                         bool* done) const {\n  CHECK(pa_op);\n\n  while (pa_operation_get_state(pa_op) == PA_OPERATION_RUNNING) {\n    if (*done) {\n      pa_operation_cancel(pa_op);\n      break;\n    }\n    MainloopWait();\n  }\n  pa_operation_unref(pa_op);\n }\n", "target": 1, "idx": 184148}
{"func": "IPV6DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)\n{\n    int i;\n    int ret = 0;\n\n    DefragInit();\n\n    /*\n     * Build the packets.\n     */\n\n    int id = 1;\n    Packet *packets[17];\n    memset(packets, 0x00, sizeof(packets));\n\n    /*\n     * Original fragments.\n      */\n \n     /* A*24 at 0. */\n    packets[0] = IPV6BuildTestPacket(id, 0, 1, 'A', 24);\n \n     /* B*15 at 32. */\n    packets[1] = IPV6BuildTestPacket(id, 32 >> 3, 1, 'B', 16);\n \n     /* C*24 at 48. */\n    packets[2] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'C', 24);\n \n     /* D*8 at 80. */\n    packets[3] = IPV6BuildTestPacket(id, 80 >> 3, 1, 'D', 8);\n \n     /* E*16 at 104. */\n    packets[4] = IPV6BuildTestPacket(id, 104 >> 3, 1, 'E', 16);\n \n     /* F*24 at 120. */\n    packets[5] = IPV6BuildTestPacket(id, 120 >> 3, 1, 'F', 24);\n \n     /* G*16 at 144. */\n    packets[6] = IPV6BuildTestPacket(id, 144 >> 3, 1, 'G', 16);\n \n     /* H*16 at 160. */\n    packets[7] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'H', 16);\n \n     /* I*8 at 176. */\n    packets[8] = IPV6BuildTestPacket(id, 176 >> 3, 1, 'I', 8);\n \n     /*\n      * Overlapping subsequent fragments.\n      */\n \n     /* J*32 at 8. */\n    packets[9] = IPV6BuildTestPacket(id, 8 >> 3, 1, 'J', 32);\n \n     /* K*24 at 48. */\n    packets[10] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'K', 24);\n \n     /* L*24 at 72. */\n    packets[11] = IPV6BuildTestPacket(id, 72 >> 3, 1, 'L', 24);\n \n     /* M*24 at 96. */\n    packets[12] = IPV6BuildTestPacket(id, 96 >> 3, 1, 'M', 24);\n \n     /* N*8 at 128. */\n    packets[13] = IPV6BuildTestPacket(id, 128 >> 3, 1, 'N', 8);\n \n     /* O*8 at 152. */\n    packets[14] = IPV6BuildTestPacket(id, 152 >> 3, 1, 'O', 8);\n \n     /* P*8 at 160. */\n    packets[15] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'P', 8);\n \n     /* Q*16 at 176. */\n    packets[16] = IPV6BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);\n \n     default_policy = policy;\n \n    /* Send all but the last. */\n    for (i = 0; i < 9; i++) {\n        Packet *tp = Defrag(NULL, NULL, packets[i], NULL);\n        if (tp != NULL) {\n            SCFree(tp);\n            goto end;\n        }\n        if (ENGINE_ISSET_EVENT(packets[i], IPV6_FRAG_OVERLAP)) {\n            goto end;\n        }\n    }\n    int overlap = 0;\n    for (; i < 16; i++) {\n        Packet *tp = Defrag(NULL, NULL, packets[i], NULL);\n        if (tp != NULL) {\n            SCFree(tp);\n            goto end;\n        }\n        if (ENGINE_ISSET_EVENT(packets[i], IPV6_FRAG_OVERLAP)) {\n            overlap++;\n        }\n    }\n    if (!overlap)\n        goto end;\n\n    /* And now the last one. */\n    Packet *reassembled = Defrag(NULL, NULL, packets[16], NULL);\n    if (reassembled == NULL)\n        goto end;\n    if (memcmp(GET_PKT_DATA(reassembled) + 40, expected, expected_len) != 0)\n        goto end;\n\n    if (IPV6_GET_PLEN(reassembled) != 192)\n        goto end;\n\n    SCFree(reassembled);\n\n    /* Make sure all frags were returned to the pool. */\n    if (defrag_context->frag_pool->outstanding != 0) {\n        printf(\"defrag_context->frag_pool->outstanding %u: \", defrag_context->frag_pool->outstanding);\n        goto end;\n    }\n\n    ret = 1;\n\nend:\n    for (i = 0; i < 17; i++) {\n        SCFree(packets[i]);\n    }\n    DefragDestroy();\n    return ret;\n}\n", "target": 1, "idx": 181480}
{"func": "cJSON *cJSON_GetArrayItem( cJSON *array, int item )\n{\n\tcJSON *c = array->child;\n\twhile ( c && item > 0 ) {\n\t\t--item;\n\t\tc = c->next;\n\t}\n\treturn c;\n}\n", "target": 1, "idx": 180458}
{"func": "GeometryMapper::SourceToDestinationProjectionInternal(\n    const TransformPaintPropertyNode* source,\n    const TransformPaintPropertyNode* destination,\n    bool& success) {\n  DCHECK(source && destination);\n  DEFINE_STATIC_LOCAL(TransformationMatrix, identity, (TransformationMatrix()));\n  DEFINE_STATIC_LOCAL(TransformationMatrix, temp, (TransformationMatrix()));\n\n  if (source == destination) {\n    success = true;\n    return identity;\n  }\n\n  const GeometryMapperTransformCache& source_cache =\n      source->GetTransformCache();\n  const GeometryMapperTransformCache& destination_cache =\n      destination->GetTransformCache();\n\n  if (source_cache.plane_root() == destination_cache.plane_root()) {\n    success = true;\n    if (source == destination_cache.plane_root())\n      return destination_cache.from_plane_root();\n    if (destination == source_cache.plane_root())\n      return source_cache.to_plane_root();\n    temp = destination_cache.from_plane_root();\n    temp.Multiply(source_cache.to_plane_root());\n    return temp;\n  }\n\n  if (!destination_cache.projection_from_screen_is_valid()) {\n    success = false;\n    return identity;\n  }\n \n  const auto* root = TransformPaintPropertyNode::Root();\n   success = true;\n   if (source == root)\n     return destination_cache.projection_from_screen();\n  if (destination == root) {\n    temp = source_cache.to_screen();\n  } else {\n    temp = destination_cache.projection_from_screen();\n    temp.Multiply(source_cache.to_screen());\n  }\n  temp.FlattenTo2d();\n  return temp;\n}\n", "target": 1, "idx": 185713}
{"func": "int sock_setsockopt(struct socket *sock, int level, int optname,\n\t\t    char __user *optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tint val;\n\tint valbool;\n\tstruct linger ling;\n\tint ret = 0;\n\n\t/*\n\t *\tOptions without arguments\n\t */\n\n\tif (optname == SO_BINDTODEVICE)\n\t\treturn sock_bindtodevice(sk, optval, optlen);\n\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\n\tif (get_user(val, (int __user *)optval))\n\t\treturn -EFAULT;\n\n\tvalbool = val ? 1 : 0;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase SO_DEBUG:\n\t\tif (val && !capable(CAP_NET_ADMIN))\n\t\t\tret = -EACCES;\n\t\telse\n\t\t\tsock_valbool_flag(sk, SOCK_DBG, valbool);\n\t\tbreak;\n\tcase SO_REUSEADDR:\n\t\tsk->sk_reuse = (valbool ? SK_CAN_REUSE : SK_NO_REUSE);\n\t\tbreak;\n\tcase SO_TYPE:\n\tcase SO_PROTOCOL:\n\tcase SO_DOMAIN:\n\tcase SO_ERROR:\n\t\tret = -ENOPROTOOPT;\n\t\tbreak;\n\tcase SO_DONTROUTE:\n\t\tsock_valbool_flag(sk, SOCK_LOCALROUTE, valbool);\n\t\tbreak;\n\tcase SO_BROADCAST:\n\t\tsock_valbool_flag(sk, SOCK_BROADCAST, valbool);\n \t\tbreak;\n \tcase SO_SNDBUF:\n \t\t/* Don't error on this BSD doesn't and if you think\n\t\t   about it this is right. Otherwise apps have to\n\t\t   play 'guess the biggest size' games. RCVBUF/SNDBUF\n\t\t   are treated in BSD as hints */\n\t\tif (val > sysctl_wmem_max)\n\t\t\tval = sysctl_wmem_max;\n set_sndbuf:\n \t\tsk->sk_userlocks |= SOCK_SNDBUF_LOCK;\n\t\tif ((val * 2) < SOCK_MIN_SNDBUF)\n\t\t\tsk->sk_sndbuf = SOCK_MIN_SNDBUF;\n\t\telse\n\t\t\tsk->sk_sndbuf = val * 2;\n\t\t/*\n\t\t *\tWake up sending tasks if we\n\t\t *\tupped the value.\n\t\t */\n \t\tsk->sk_write_space(sk);\n \t\tbreak;\n \n\tcase SO_SNDBUFFORCE:\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\tret = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tgoto set_sndbuf;\n \n \tcase SO_RCVBUF:\n \t\t/* Don't error on this BSD doesn't and if you think\n\t\t   about it this is right. Otherwise apps have to\n\t\t   play 'guess the biggest size' games. RCVBUF/SNDBUF\n\t\t   are treated in BSD as hints */\n\t\tif (val > sysctl_rmem_max)\n\t\t\tval = sysctl_rmem_max;\n set_rcvbuf:\n \t\tsk->sk_userlocks |= SOCK_RCVBUF_LOCK;\n \t\t/*\n\t\t * We double it on the way in to account for\n\t\t * \"struct sk_buff\" etc. overhead.   Applications\n\t\t * assume that the SO_RCVBUF setting they make will\n\t\t * allow that much actual data to be received on that\n\t\t * socket.\n\t\t *\n\t\t * Applications are unaware that \"struct sk_buff\" and\n\t\t * other overheads allocate from the receive buffer\n\t\t * during socket buffer allocation.\n\t\t *\n\t\t * And after considering the possible alternatives,\n \t\t * returning the value we actually used in getsockopt\n \t\t * is the most desirable behavior.\n \t\t */\n\t\tif ((val * 2) < SOCK_MIN_RCVBUF)\n\t\t\tsk->sk_rcvbuf = SOCK_MIN_RCVBUF;\n\t\telse\n\t\t\tsk->sk_rcvbuf = val * 2;\n \t\tbreak;\n \n \tcase SO_RCVBUFFORCE:\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\tret = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tgoto set_rcvbuf;\n\n\tcase SO_KEEPALIVE:\n#ifdef CONFIG_INET\n\t\tif (sk->sk_protocol == IPPROTO_TCP)\n\t\t\ttcp_set_keepalive(sk, valbool);\n#endif\n\t\tsock_valbool_flag(sk, SOCK_KEEPOPEN, valbool);\n\t\tbreak;\n\n\tcase SO_OOBINLINE:\n\t\tsock_valbool_flag(sk, SOCK_URGINLINE, valbool);\n\t\tbreak;\n\n\tcase SO_NO_CHECK:\n\t\tsk->sk_no_check = valbool;\n\t\tbreak;\n\n\tcase SO_PRIORITY:\n\t\tif ((val >= 0 && val <= 6) || capable(CAP_NET_ADMIN))\n\t\t\tsk->sk_priority = val;\n\t\telse\n\t\t\tret = -EPERM;\n\t\tbreak;\n\n\tcase SO_LINGER:\n\t\tif (optlen < sizeof(ling)) {\n\t\t\tret = -EINVAL;\t/* 1003.1g */\n\t\t\tbreak;\n\t\t}\n\t\tif (copy_from_user(&ling, optval, sizeof(ling))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (!ling.l_onoff)\n\t\t\tsock_reset_flag(sk, SOCK_LINGER);\n\t\telse {\n#if (BITS_PER_LONG == 32)\n\t\t\tif ((unsigned int)ling.l_linger >= MAX_SCHEDULE_TIMEOUT/HZ)\n\t\t\t\tsk->sk_lingertime = MAX_SCHEDULE_TIMEOUT;\n\t\t\telse\n#endif\n\t\t\t\tsk->sk_lingertime = (unsigned int)ling.l_linger * HZ;\n\t\t\tsock_set_flag(sk, SOCK_LINGER);\n\t\t}\n\t\tbreak;\n\n\tcase SO_BSDCOMPAT:\n\t\tsock_warn_obsolete_bsdism(\"setsockopt\");\n\t\tbreak;\n\n\tcase SO_PASSCRED:\n\t\tif (valbool)\n\t\t\tset_bit(SOCK_PASSCRED, &sock->flags);\n\t\telse\n\t\t\tclear_bit(SOCK_PASSCRED, &sock->flags);\n\t\tbreak;\n\n\tcase SO_TIMESTAMP:\n\tcase SO_TIMESTAMPNS:\n\t\tif (valbool)  {\n\t\t\tif (optname == SO_TIMESTAMP)\n\t\t\t\tsock_reset_flag(sk, SOCK_RCVTSTAMPNS);\n\t\t\telse\n\t\t\t\tsock_set_flag(sk, SOCK_RCVTSTAMPNS);\n\t\t\tsock_set_flag(sk, SOCK_RCVTSTAMP);\n\t\t\tsock_enable_timestamp(sk, SOCK_TIMESTAMP);\n\t\t} else {\n\t\t\tsock_reset_flag(sk, SOCK_RCVTSTAMP);\n\t\t\tsock_reset_flag(sk, SOCK_RCVTSTAMPNS);\n\t\t}\n\t\tbreak;\n\n\tcase SO_TIMESTAMPING:\n\t\tif (val & ~SOF_TIMESTAMPING_MASK) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tsock_valbool_flag(sk, SOCK_TIMESTAMPING_TX_HARDWARE,\n\t\t\t\t  val & SOF_TIMESTAMPING_TX_HARDWARE);\n\t\tsock_valbool_flag(sk, SOCK_TIMESTAMPING_TX_SOFTWARE,\n\t\t\t\t  val & SOF_TIMESTAMPING_TX_SOFTWARE);\n\t\tsock_valbool_flag(sk, SOCK_TIMESTAMPING_RX_HARDWARE,\n\t\t\t\t  val & SOF_TIMESTAMPING_RX_HARDWARE);\n\t\tif (val & SOF_TIMESTAMPING_RX_SOFTWARE)\n\t\t\tsock_enable_timestamp(sk,\n\t\t\t\t\t      SOCK_TIMESTAMPING_RX_SOFTWARE);\n\t\telse\n\t\t\tsock_disable_timestamp(sk,\n\t\t\t\t\t       (1UL << SOCK_TIMESTAMPING_RX_SOFTWARE));\n\t\tsock_valbool_flag(sk, SOCK_TIMESTAMPING_SOFTWARE,\n\t\t\t\t  val & SOF_TIMESTAMPING_SOFTWARE);\n\t\tsock_valbool_flag(sk, SOCK_TIMESTAMPING_SYS_HARDWARE,\n\t\t\t\t  val & SOF_TIMESTAMPING_SYS_HARDWARE);\n\t\tsock_valbool_flag(sk, SOCK_TIMESTAMPING_RAW_HARDWARE,\n\t\t\t\t  val & SOF_TIMESTAMPING_RAW_HARDWARE);\n\t\tbreak;\n\n\tcase SO_RCVLOWAT:\n\t\tif (val < 0)\n\t\t\tval = INT_MAX;\n\t\tsk->sk_rcvlowat = val ? : 1;\n\t\tbreak;\n\n\tcase SO_RCVTIMEO:\n\t\tret = sock_set_timeout(&sk->sk_rcvtimeo, optval, optlen);\n\t\tbreak;\n\n\tcase SO_SNDTIMEO:\n\t\tret = sock_set_timeout(&sk->sk_sndtimeo, optval, optlen);\n\t\tbreak;\n\n\tcase SO_ATTACH_FILTER:\n\t\tret = -EINVAL;\n\t\tif (optlen == sizeof(struct sock_fprog)) {\n\t\t\tstruct sock_fprog fprog;\n\n\t\t\tret = -EFAULT;\n\t\t\tif (copy_from_user(&fprog, optval, sizeof(fprog)))\n\t\t\t\tbreak;\n\n\t\t\tret = sk_attach_filter(&fprog, sk);\n\t\t}\n\t\tbreak;\n\n\tcase SO_DETACH_FILTER:\n\t\tret = sk_detach_filter(sk);\n\t\tbreak;\n\n\tcase SO_PASSSEC:\n\t\tif (valbool)\n\t\t\tset_bit(SOCK_PASSSEC, &sock->flags);\n\t\telse\n\t\t\tclear_bit(SOCK_PASSSEC, &sock->flags);\n\t\tbreak;\n\tcase SO_MARK:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\tret = -EPERM;\n\t\telse\n\t\t\tsk->sk_mark = val;\n\t\tbreak;\n\n\t\t/* We implement the SO_SNDLOWAT etc to\n\t\t   not be settable (1003.1g 5.3) */\n\tcase SO_RXQ_OVFL:\n\t\tsock_valbool_flag(sk, SOCK_RXQ_OVFL, valbool);\n\t\tbreak;\n\n\tcase SO_WIFI_STATUS:\n\t\tsock_valbool_flag(sk, SOCK_WIFI_STATUS, valbool);\n\t\tbreak;\n\n\tcase SO_PEEK_OFF:\n\t\tif (sock->ops->set_peek_off)\n\t\t\tsock->ops->set_peek_off(sk, val);\n\t\telse\n\t\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\n\tcase SO_NOFCS:\n\t\tsock_valbool_flag(sk, SOCK_NOFCS, valbool);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\treturn ret;\n}\n", "target": 1, "idx": 180781}
{"func": "static int mmu_topup_memory_cache(struct kvm_mmu_memory_cache *cache,\n\t\t\t\t  struct kmem_cache *base_cache, int min)\n{\n\tvoid *obj;\n\n\tif (cache->nobjs >= min)\n\t\treturn 0;\n\twhile (cache->nobjs < ARRAY_SIZE(cache->objects)) {\n\t\tobj = kmem_cache_zalloc(base_cache, GFP_KERNEL);\n\t\tif (!obj)\n\t\t\treturn -ENOMEM;\n\t\tcache->objects[cache->nobjs++] = obj;\n\t}\n\treturn 0;\n}\n", "target": 0, "idx": 37545}
{"func": "void LayerTreeHostImpl::DeleteUIResource(UIResourceId uid) {\n  ResourceId id = ResourceIdForUIResource(uid);\n  if (id) {\n    if (has_valid_compositor_frame_sink_)\n      resource_provider_->DeleteResource(id);\n    ui_resource_map_.erase(uid);\n  }\n  MarkUIResourceNotEvicted(uid);\n}\n", "target": 0, "idx": 149926}
{"func": "void ChromeInvalidationClient::InvalidateUnknownVersion(\n    invalidation::InvalidationClient* client,\n     const invalidation::ObjectId& object_id,\n     const invalidation::AckHandle& ack_handle) {\n   DCHECK(CalledOnValidThread());\n   DVLOG(1) << \"InvalidateUnknownVersion\";\n \n   ObjectIdPayloadMap id_payloads;\n  id_payloads[object_id] = std::string();\n  EmitInvalidation(id_payloads);\n  client->Acknowledge(ack_handle);\n}\n", "target": 1, "idx": 184514}
{"func": "static MagickBooleanType TraceBezier(MVGInfo *mvg_info,\n  const size_t number_coordinates)\n{\n  double\n    alpha,\n    *coefficients,\n    weight;\n\n  PointInfo\n    end,\n    point,\n    *points;\n\n  PrimitiveInfo\n    *primitive_info;\n\n  register PrimitiveInfo\n    *p;\n\n  register ssize_t\n    i,\n    j;\n\n  size_t\n    control_points,\n    quantum;\n\n  /*\n    Allocate coefficients.\n  */\n  primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;\n  quantum=number_coordinates;\n  for (i=0; i < (ssize_t) number_coordinates; i++)\n  {\n    for (j=i+1; j < (ssize_t) number_coordinates; j++)\n    {\n      alpha=fabs(primitive_info[j].point.x-primitive_info[i].point.x);\n      if (alpha > (double) SSIZE_MAX)\n        {\n          (void) ThrowMagickException(mvg_info->exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n          return(MagickFalse);\n        }\n      if (alpha > (double) quantum)\n        quantum=(size_t) alpha;\n      alpha=fabs(primitive_info[j].point.y-primitive_info[i].point.y);\n      if (alpha > (double) SSIZE_MAX)\n        {\n          (void) ThrowMagickException(mvg_info->exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n          return(MagickFalse);\n        }\n      if (alpha > (double) quantum)\n         quantum=(size_t) alpha;\n     }\n   }\n  quantum=MagickMin(quantum/number_coordinates,BezierQuantum);\n   primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;\n   coefficients=(double *) AcquireQuantumMemory(number_coordinates,\n     sizeof(*coefficients));\n   points=(PointInfo *) AcquireQuantumMemory(quantum,number_coordinates*\n    sizeof(*points));\n  if ((coefficients == (double *) NULL) || (points == (PointInfo *) NULL))\n    {\n      if (points != (PointInfo *) NULL)\n        points=(PointInfo *) RelinquishMagickMemory(points);\n      if (coefficients != (double *) NULL)\n        coefficients=(double *) RelinquishMagickMemory(coefficients);\n      (void) ThrowMagickException(mvg_info->exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n      return(MagickFalse);\n    }\n  control_points=quantum*number_coordinates;\n  if (CheckPrimitiveExtent(mvg_info,control_points+1) == MagickFalse)\n    {\n      points=(PointInfo *) RelinquishMagickMemory(points);\n       coefficients=(double *) RelinquishMagickMemory(coefficients);\n       return(MagickFalse);\n     }\n   /*\n     Compute bezier points.\n   */\n  end=primitive_info[number_coordinates-1].point;\n  for (i=0; i < (ssize_t) number_coordinates; i++)\n    coefficients[i]=Permutate((ssize_t) number_coordinates-1,i);\n  weight=0.0;\n  for (i=0; i < (ssize_t) control_points; i++)\n  {\n    p=primitive_info;\n    point.x=0.0;\n    point.y=0.0;\n    alpha=pow((double) (1.0-weight),(double) number_coordinates-1.0);\n    for (j=0; j < (ssize_t) number_coordinates; j++)\n    {\n      point.x+=alpha*coefficients[j]*p->point.x;\n      point.y+=alpha*coefficients[j]*p->point.y;\n      alpha*=weight/(1.0-weight);\n      p++;\n    }\n    points[i]=point;\n    weight+=1.0/control_points;\n  }\n  /*\n    Bezier curves are just short segmented polys.\n  */\n  p=primitive_info;\n  for (i=0; i < (ssize_t) control_points; i++)\n  {\n    if (TracePoint(p,points[i]) == MagickFalse)\n      {\n        points=(PointInfo *) RelinquishMagickMemory(points);\n        coefficients=(double *) RelinquishMagickMemory(coefficients);\n        return(MagickFalse);\n      }\n    p+=p->coordinates;\n  }\n  if (TracePoint(p,end) == MagickFalse)\n    {\n      points=(PointInfo *) RelinquishMagickMemory(points);\n      coefficients=(double *) RelinquishMagickMemory(coefficients);\n      return(MagickFalse);\n    }\n  p+=p->coordinates;\n  primitive_info->coordinates=(size_t) (p-primitive_info);\n  primitive_info->closed_subpath=MagickFalse;\n  for (i=0; i < (ssize_t) primitive_info->coordinates; i++)\n  {\n    p->primitive=primitive_info->primitive;\n    p--;\n  }\n  points=(PointInfo *) RelinquishMagickMemory(points);\n  coefficients=(double *) RelinquishMagickMemory(coefficients);\n  return(MagickTrue);\n}\n", "target": 1, "idx": 182657}
{"func": "int ssl3_write_bytes(SSL *s, int type, const void *buf_, int len)\n\t{\n\tconst unsigned char *buf=buf_;\n\tint tot;\n\tunsigned int n,nw;\n#if !defined(OPENSSL_NO_MULTIBLOCK) && EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK\n\tunsigned int max_send_fragment;\n#endif\n\tSSL3_BUFFER *wb=&(s->s3->wbuf);\n\tint i;\n\tunsigned int u_len = (unsigned int)len;\n\n\tif (len < 0)\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_WRITE_BYTES,SSL_R_SSL_NEGATIVE_LENGTH);\n\t\treturn -1;\n\t\t}\n\n\ts->rwstate=SSL_NOTHING;\n\tOPENSSL_assert(s->s3->wnum <= INT_MAX);\n\ttot=s->s3->wnum;\n\ts->s3->wnum=0;\n\n\tif (SSL_in_init(s) && !s->in_handshake)\n\t\t{\n\t\ti=s->handshake_func(s);\n\t\tif (i < 0) return(i);\n\t\tif (i == 0)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_WRITE_BYTES,SSL_R_SSL_HANDSHAKE_FAILURE);\n\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t/* ensure that if we end up with a smaller value of data to write \n\t * out than the the original len from a write which didn't complete \n\t * for non-blocking I/O and also somehow ended up avoiding \n\t * the check for this in ssl3_write_pending/SSL_R_BAD_WRITE_RETRY as\n\t * it must never be possible to end up with (len-tot) as a large\n\t * number that will then promptly send beyond the end of the users\n\t * buffer ... so we trap and report the error in a way the user\n\t * will notice\n\t */\n\tif (len < tot)\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_WRITE_BYTES,SSL_R_BAD_LENGTH);\n\t\treturn(-1);\n\t\t}\n\n\t/* first check if there is a SSL3_BUFFER still being written\n\t * out.  This will happen with non blocking IO */\n\tif (wb->left != 0)\n\t\t{\n\t\ti = ssl3_write_pending(s,type,&buf[tot],s->s3->wpend_tot);\n\t\tif (i<=0)\n\t\t\t{\n\t\t\t/* XXX should we ssl3_release_write_buffer if i<0? */\n\t\t\ts->s3->wnum=tot;\n\t\t\treturn i;\n\t\t\t}\n\t\ttot += i;\t/* this might be last fragment */\n\t\t}\n\n#if !defined(OPENSSL_NO_MULTIBLOCK) && EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK\n\t/*\n\t * Depending on platform multi-block can deliver several *times*\n\t * better performance. Downside is that it has to allocate\n\t * jumbo buffer to accomodate up to 8 records, but the\n\t * compromise is considered worthy.\n\t */\n\tif (type==SSL3_RT_APPLICATION_DATA &&\n\t    u_len >= 4*(max_send_fragment=s->max_send_fragment) &&\n\t    s->compress==NULL && s->msg_callback==NULL &&\n\t    !SSL_USE_ETM(s) && SSL_USE_EXPLICIT_IV(s) &&\n\t    EVP_CIPHER_flags(s->enc_write_ctx->cipher)&EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK)\n\t\t{\n\t\tunsigned char aad[13];\n\t\tEVP_CTRL_TLS1_1_MULTIBLOCK_PARAM mb_param;\n\t\tint packlen;\n\n\t\t/* minimize address aliasing conflicts */\n\t\tif ((max_send_fragment&0xfff) == 0)\n\t\t\tmax_send_fragment -= 512;\n\n\t\tif (tot==0 || wb->buf==NULL)\t/* allocate jumbo buffer */\n\t\t\t{\n\t\t\tssl3_release_write_buffer(s);\n\n\t\t\tpacklen = EVP_CIPHER_CTX_ctrl(s->enc_write_ctx,\n\t\t\t\t\tEVP_CTRL_TLS1_1_MULTIBLOCK_MAX_BUFSIZE,\n\t\t\t\t\tmax_send_fragment,NULL);\n\n\t\t\tif (u_len >= 8*max_send_fragment)\tpacklen *= 8;\n\t\t\telse\t\t\t\tpacklen *= 4;\n\n\t\t\twb->buf=OPENSSL_malloc(packlen);\n\t\t\twb->len=packlen;\n\t\t\t}\n\t\telse if (tot==len)\t\t/* done? */\n\t\t\t{\n\t\t\tOPENSSL_free(wb->buf);\t/* free jumbo buffer */\n\t\t\twb->buf = NULL;\n\t\t\treturn tot;\n\t\t\t}\n\n\t\tn=(len-tot);\n\t\tfor (;;)\n\t\t\t{\n\t\t\tif (n < 4*max_send_fragment)\n\t\t\t\t{\n\t\t\t\tOPENSSL_free(wb->buf);\t/* free jumbo buffer */\n\t\t\t\twb->buf = NULL;\n\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tif (s->s3->alert_dispatch)\n\t\t\t\t{\n\t\t\t\ti=s->method->ssl_dispatch_alert(s);\n\t\t\t\tif (i <= 0)\n\t\t\t\t\t{\n\t\t\t\t\ts->s3->wnum=tot;\n\t\t\t\t\treturn i;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\tif (n >= 8*max_send_fragment)\n\t\t\t\tnw = max_send_fragment*(mb_param.interleave=8);\n\t\t\telse\n\t\t\t\tnw = max_send_fragment*(mb_param.interleave=4);\n\n\t\t\tmemcpy(aad,s->s3->write_sequence,8);\n\t\t\taad[8]=type;\n\t\t\taad[9]=(unsigned char)(s->version>>8);\n\t\t\taad[10]=(unsigned char)(s->version);\n\t\t\taad[11]=0;\n\t\t\taad[12]=0;\n\t\t\tmb_param.out = NULL;\n\t\t\tmb_param.inp = aad;\n\t\t\tmb_param.len = nw;\n\n\t\t\tpacklen = EVP_CIPHER_CTX_ctrl(s->enc_write_ctx,\n\t\t\t\t\tEVP_CTRL_TLS1_1_MULTIBLOCK_AAD,\n\t\t\t\t\tsizeof(mb_param),&mb_param);\n\n\t\t\tif (packlen<=0 || packlen>(int)wb->len)\t/* never happens */\n\t\t\t\t{\n\t\t\t\tOPENSSL_free(wb->buf);\t/* free jumbo buffer */\n\t\t\t\twb->buf = NULL;\n\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tmb_param.out = wb->buf;\n\t\t\tmb_param.inp = &buf[tot];\n\t\t\tmb_param.len = nw;\n\n\t\t\tif (EVP_CIPHER_CTX_ctrl(s->enc_write_ctx,\n\t\t\t\t\tEVP_CTRL_TLS1_1_MULTIBLOCK_ENCRYPT,\n\t\t\t\t\tsizeof(mb_param),&mb_param)<=0)\n\t\t\t\treturn -1;\n\n\t\t\ts->s3->write_sequence[7] += mb_param.interleave;\n\t\t\tif (s->s3->write_sequence[7] < mb_param.interleave)\n\t\t\t\t{\n\t\t\t\tint j=6;\n\t\t\t\twhile (j>=0 && (++s->s3->write_sequence[j--])==0) ;\n\t\t\t\t}\n\n\t\t\twb->offset = 0;\n\t\t\twb->left = packlen;\n\n\t\t\ts->s3->wpend_tot = nw;\n\t\t\ts->s3->wpend_buf = &buf[tot];\n\t\t\ts->s3->wpend_type= type;\n\t\t\ts->s3->wpend_ret = nw;\n\n\t\t\ti = ssl3_write_pending(s,type,&buf[tot],nw);\n\t\t\tif (i<=0)\n\t\t\t\t{\n\t\t\t\tif (i<0)\n\t\t\t\t\t{\n\t\t\t\t\tOPENSSL_free(wb->buf);\n\t\t\t\t\twb->buf = NULL;\n\t\t\t\t\t}\n\t\t\t\ts->s3->wnum=tot;\n\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\tif (i==(int)n)\n\t\t\t\t{\n\t\t\t\tOPENSSL_free(wb->buf);\t/* free jumbo buffer */\n\t\t\t\twb->buf = NULL;\n\t\t\t\treturn tot+i;\n\t\t\t\t}\n\t\t\tn-=i;\n\t\t\ttot+=i;\n\t\t\t}\n\t\t}\n\telse\n#endif\n\tif (tot==len)\t\t/* done? */\n\t\t{\n\t\tif (s->mode & SSL_MODE_RELEASE_BUFFERS &&\n\t\t\t!SSL_IS_DTLS(s))\n\t\t\tssl3_release_write_buffer(s);\n\n\t\treturn tot;\n\t\t}\n\n\n\tn=(len-tot);\n\tfor (;;)\n\t\t{\n\t\tif (n > s->max_send_fragment)\n\t\t\tnw=s->max_send_fragment;\n\t\telse\n\t\t\tnw=n;\n\n\t\ti=do_ssl3_write(s, type, &(buf[tot]), nw, 0);\n\t\tif (i <= 0)\n\t\t\t{\n\t\t\t/* XXX should we ssl3_release_write_buffer if i<0? */\n\t\t\ts->s3->wnum=tot;\n\t\t\treturn i;\n\t\t\t}\n\n\t\tif ((i == (int)n) ||\n\t\t\t(type == SSL3_RT_APPLICATION_DATA &&\n\t\t\t (s->mode & SSL_MODE_ENABLE_PARTIAL_WRITE)))\n\t\t\t{\n\t\t\t/* next chunk of data should get another prepended empty fragment\n\t\t\t * in ciphersuites with known-IV weakness: */\n\t\t\ts->s3->empty_fragment_done = 0;\n\n\t\t\tif ((i==(int)n) && s->mode & SSL_MODE_RELEASE_BUFFERS &&\n\t\t\t\t!SSL_IS_DTLS(s))\n\t\t\t\tssl3_release_write_buffer(s);\n\n\t\t\treturn tot+i;\n\t\t\t}\n\n\t\tn-=i;\n\t\ttot+=i;\n\t\t}\n\t}\n", "target": 0, "idx": 94704}
{"func": "int ip_options_get(struct net *net, struct ip_options **optp,\n \t\t   unsigned char *data, int optlen)\n {\n\tstruct ip_options *opt = ip_options_get_alloc(optlen);\n \n \tif (!opt)\n \t\treturn -ENOMEM;\n \tif (optlen)\n\t\tmemcpy(opt->__data, data, optlen);\n \treturn ip_options_get_finish(net, optp, opt, optlen);\n }\n", "target": 1, "idx": 178730}
{"func": "void GpuVideoDecodeAccelerator::Initialize(\n    const media::VideoCodecProfile profile,\n    IPC::Message* init_done_msg) {\n  DCHECK(!video_decode_accelerator_.get());\n  DCHECK(!init_done_msg_);\n   DCHECK(init_done_msg);\n   init_done_msg_ = init_done_msg;\n \n#if defined(OS_CHROMEOS) || defined(OS_WIN)\n   DCHECK(stub_ && stub_->decoder());\n #if defined(OS_WIN)\n   if (base::win::GetVersion() < base::win::VERSION_WIN7) {\n    NOTIMPLEMENTED() << \"HW video decode acceleration not available.\";\n    NotifyError(media::VideoDecodeAccelerator::PLATFORM_FAILURE);\n    return;\n  }\n   DLOG(INFO) << \"Initializing DXVA HW decoder for windows.\";\n   DXVAVideoDecodeAccelerator* video_decoder =\n       new DXVAVideoDecodeAccelerator(this);\n#elif defined(OS_CHROMEOS)  // OS_WIN\n#if defined(ARCH_CPU_ARMEL)\n   OmxVideoDecodeAccelerator* video_decoder =\n       new OmxVideoDecodeAccelerator(this);\n   video_decoder->SetEglState(\n       gfx::GLSurfaceEGL::GetHardwareDisplay(),\n       stub_->decoder()->GetGLContext()->GetHandle());\n#elif defined(ARCH_CPU_X86_FAMILY)\n  VaapiVideoDecodeAccelerator* video_decoder =\n      new VaapiVideoDecodeAccelerator(this);\n  gfx::GLContextGLX* glx_context =\n      static_cast<gfx::GLContextGLX*>(stub_->decoder()->GetGLContext());\n  GLXContext glx_context_handle =\n      static_cast<GLXContext>(glx_context->GetHandle());\n  video_decoder->SetGlxState(glx_context->display(), glx_context_handle);\n#endif  // ARCH_CPU_ARMEL\n #endif  // OS_WIN\n   video_decode_accelerator_ = video_decoder;\n   if (!video_decode_accelerator_->Initialize(profile))\n     NotifyError(media::VideoDecodeAccelerator::PLATFORM_FAILURE);\n #else  // Update RenderViewImpl::createMediaPlayer when adding clauses.\n   NOTIMPLEMENTED() << \"HW video decode acceleration not available.\";\n   NotifyError(media::VideoDecodeAccelerator::PLATFORM_FAILURE);\n#endif  // defined(OS_CHROMEOS) || defined(OS_WIN)\n }\n", "target": 1, "idx": 184276}
{"func": "void NavigationRequest::OnStartChecksComplete(\n    NavigationThrottle::ThrottleCheckResult result) {\n  DCHECK(result.action() != NavigationThrottle::DEFER);\n  DCHECK(result.action() != NavigationThrottle::BLOCK_RESPONSE);\n\n  if (on_start_checks_complete_closure_)\n    on_start_checks_complete_closure_.Run();\n  if (result.action() == NavigationThrottle::CANCEL_AND_IGNORE ||\n      result.action() == NavigationThrottle::CANCEL ||\n      result.action() == NavigationThrottle::BLOCK_REQUEST ||\n      result.action() == NavigationThrottle::BLOCK_REQUEST_AND_COLLAPSE) {\n#if DCHECK_IS_ON()\n    if (result.action() == NavigationThrottle::BLOCK_REQUEST) {\n      DCHECK(result.net_error_code() == net::ERR_BLOCKED_BY_CLIENT ||\n             result.net_error_code() == net::ERR_BLOCKED_BY_ADMINISTRATOR);\n    }\n    else if (result.action() == NavigationThrottle::CANCEL_AND_IGNORE) {\n      DCHECK_EQ(result.net_error_code(), net::ERR_ABORTED);\n    }\n#endif\n\n    bool collapse_frame =\n        result.action() == NavigationThrottle::BLOCK_REQUEST_AND_COLLAPSE;\n\n    BrowserThread::PostTask(\n        BrowserThread::UI, FROM_HERE,\n        base::BindOnce(\n            &NavigationRequest::OnRequestFailedInternal,\n            weak_factory_.GetWeakPtr(),\n            network::URLLoaderCompletionStatus(result.net_error_code()),\n            true /* skip_throttles */, result.error_page_content(),\n            collapse_frame));\n\n    return;\n  }\n\n  DCHECK_NE(AssociatedSiteInstanceType::NONE, associated_site_instance_type_);\n  RenderFrameHostImpl* navigating_frame_host =\n      associated_site_instance_type_ == AssociatedSiteInstanceType::SPECULATIVE\n          ? frame_tree_node_->render_manager()->speculative_frame_host()\n          : frame_tree_node_->current_frame_host();\n  DCHECK(navigating_frame_host);\n\n  navigation_handle_->SetExpectedProcess(navigating_frame_host->GetProcess());\n\n  BrowserContext* browser_context =\n      frame_tree_node_->navigator()->GetController()->GetBrowserContext();\n  StoragePartition* partition = BrowserContext::GetStoragePartition(\n      browser_context, navigating_frame_host->GetSiteInstance());\n  DCHECK(partition);\n\n  DCHECK(!loader_);\n\n  bool can_create_service_worker =\n      (frame_tree_node_->pending_frame_policy().sandbox_flags &\n       blink::WebSandboxFlags::kOrigin) != blink::WebSandboxFlags::kOrigin;\n  request_params_.should_create_service_worker = can_create_service_worker;\n  if (can_create_service_worker) {\n    ServiceWorkerContextWrapper* service_worker_context =\n        static_cast<ServiceWorkerContextWrapper*>(\n            partition->GetServiceWorkerContext());\n    navigation_handle_->InitServiceWorkerHandle(service_worker_context);\n  }\n\n  if (IsSchemeSupportedForAppCache(common_params_.url)) {\n    if (navigating_frame_host->GetRenderViewHost()\n            ->GetWebkitPreferences()\n            .application_cache_enabled) {\n      navigation_handle_->InitAppCacheHandle(\n          static_cast<ChromeAppCacheService*>(partition->GetAppCacheService()));\n    }\n  }\n\n  request_params_.navigation_timing.fetch_start = base::TimeTicks::Now();\n\n  GURL base_url;\n#if defined(OS_ANDROID)\n  NavigationEntry* last_committed_entry =\n      frame_tree_node_->navigator()->GetController()->GetLastCommittedEntry();\n  if (last_committed_entry)\n    base_url = last_committed_entry->GetBaseURLForDataURL();\n#endif\n  const GURL& top_document_url =\n      !base_url.is_empty()\n          ? base_url\n           : frame_tree_node_->frame_tree()->root()->current_url();\n \n  const FrameTreeNode* current = frame_tree_node_->parent();\n  bool ancestors_are_same_site = true;\n  while (current && ancestors_are_same_site) {\n    if (!net::registry_controlled_domains::SameDomainOrHost(\n            top_document_url, current->current_url(),\n            net::registry_controlled_domains::INCLUDE_PRIVATE_REGISTRIES)) {\n      ancestors_are_same_site = false;\n     }\n     current = current->parent();\n   }\n   const GURL& site_for_cookies =\n      ancestors_are_same_site\n           ? (frame_tree_node_->IsMainFrame() ? common_params_.url\n                                              : top_document_url)\n          : GURL::EmptyGURL();\n   bool parent_is_main_frame = !frame_tree_node_->parent()\n                                   ? false\n                                   : frame_tree_node_->parent()->IsMainFrame();\n\n  std::unique_ptr<NavigationUIData> navigation_ui_data;\n  if (navigation_handle_->GetNavigationUIData())\n    navigation_ui_data = navigation_handle_->GetNavigationUIData()->Clone();\n\n  bool is_for_guests_only =\n      navigation_handle_->GetStartingSiteInstance()->GetSiteURL().\n          SchemeIs(kGuestScheme);\n\n  bool report_raw_headers = false;\n  RenderFrameDevToolsAgentHost::ApplyOverrides(\n      frame_tree_node_, begin_params_.get(), &report_raw_headers);\n  RenderFrameDevToolsAgentHost::OnNavigationRequestWillBeSent(*this);\n\n  loader_ = NavigationURLLoader::Create(\n      browser_context->GetResourceContext(), partition,\n      std::make_unique<NavigationRequestInfo>(\n          common_params_, begin_params_.Clone(), site_for_cookies,\n          frame_tree_node_->IsMainFrame(), parent_is_main_frame,\n          IsSecureFrame(frame_tree_node_->parent()),\n          frame_tree_node_->frame_tree_node_id(), is_for_guests_only,\n          report_raw_headers,\n          navigating_frame_host->GetVisibilityState() ==\n              blink::mojom::PageVisibilityState::kPrerender,\n          upgrade_if_insecure_,\n          blob_url_loader_factory_ ? blob_url_loader_factory_->Clone()\n                                   : nullptr,\n          devtools_navigation_token(),\n          frame_tree_node_->devtools_frame_token()),\n      std::move(navigation_ui_data),\n      navigation_handle_->service_worker_handle(),\n      navigation_handle_->appcache_handle(), this);\n}\n", "target": 1, "idx": 186247}
{"func": "void RenderView::didFocus() {\n  if (webview() && webview()->mainFrame() &&\n      webview()->mainFrame()->isProcessingUserGesture()) {\n    Send(new ViewHostMsg_Focus(routing_id_));\n  }\n}\n", "target": 0, "idx": 103890}
{"func": "static av_always_inline void mc_part_weighted(H264Context *h, int n, int square,\n                                              int height, int delta,\n                                              uint8_t *dest_y, uint8_t *dest_cb,\n                                              uint8_t *dest_cr,\n                                              int x_offset, int y_offset,\n                                              qpel_mc_func *qpix_put,\n                                              h264_chroma_mc_func chroma_put,\n                                              h264_weight_func luma_weight_op,\n                                              h264_weight_func chroma_weight_op,\n                                              h264_biweight_func luma_weight_avg,\n                                              h264_biweight_func chroma_weight_avg,\n                                              int list0, int list1,\n                                              int pixel_shift, int chroma_idc)\n{\n    int chroma_height;\n\n    dest_y += (2 * x_offset << pixel_shift) + 2 * y_offset * h->mb_linesize;\n    if (chroma_idc == 3 /* yuv444 */) {\n        chroma_height     = height;\n        chroma_weight_avg = luma_weight_avg;\n        chroma_weight_op  = luma_weight_op;\n        dest_cb += (2 * x_offset << pixel_shift) + 2 * y_offset * h->mb_linesize;\n        dest_cr += (2 * x_offset << pixel_shift) + 2 * y_offset * h->mb_linesize;\n    } else if (chroma_idc == 2 /* yuv422 */) {\n        chroma_height = height;\n        dest_cb      += (x_offset << pixel_shift) + 2 * y_offset * h->mb_uvlinesize;\n        dest_cr      += (x_offset << pixel_shift) + 2 * y_offset * h->mb_uvlinesize;\n    } else { /* yuv420 */\n        chroma_height = height >> 1;\n        dest_cb      += (x_offset << pixel_shift) + y_offset * h->mb_uvlinesize;\n        dest_cr      += (x_offset << pixel_shift) + y_offset * h->mb_uvlinesize;\n    }\n    x_offset += 8 * h->mb_x;\n    y_offset += 8 * (h->mb_y >> MB_FIELD(h));\n\n    if (list0 && list1) {\n        /* don't optimize for luma-only case, since B-frames usually\n         * use implicit weights => chroma too. */\n        uint8_t *tmp_cb = h->bipred_scratchpad;\n        uint8_t *tmp_cr = h->bipred_scratchpad + (16 << pixel_shift);\n        uint8_t *tmp_y  = h->bipred_scratchpad + 16 * h->mb_uvlinesize;\n        int refn0       = h->ref_cache[0][scan8[n]];\n        int refn1       = h->ref_cache[1][scan8[n]];\n\n        mc_dir_part(h, &h->ref_list[0][refn0], n, square, height, delta, 0,\n                    dest_y, dest_cb, dest_cr,\n                    x_offset, y_offset, qpix_put, chroma_put,\n                    pixel_shift, chroma_idc);\n        mc_dir_part(h, &h->ref_list[1][refn1], n, square, height, delta, 1,\n                    tmp_y, tmp_cb, tmp_cr,\n                    x_offset, y_offset, qpix_put, chroma_put,\n                    pixel_shift, chroma_idc);\n\n        if (h->use_weight == 2) {\n            int weight0 = h->implicit_weight[refn0][refn1][h->mb_y & 1];\n            int weight1 = 64 - weight0;\n            luma_weight_avg(dest_y, tmp_y, h->mb_linesize,\n                            height, 5, weight0, weight1, 0);\n            chroma_weight_avg(dest_cb, tmp_cb, h->mb_uvlinesize,\n                              chroma_height, 5, weight0, weight1, 0);\n            chroma_weight_avg(dest_cr, tmp_cr, h->mb_uvlinesize,\n                              chroma_height, 5, weight0, weight1, 0);\n        } else {\n            luma_weight_avg(dest_y, tmp_y, h->mb_linesize, height,\n                            h->luma_log2_weight_denom,\n                            h->luma_weight[refn0][0][0],\n                            h->luma_weight[refn1][1][0],\n                            h->luma_weight[refn0][0][1] +\n                            h->luma_weight[refn1][1][1]);\n            chroma_weight_avg(dest_cb, tmp_cb, h->mb_uvlinesize, chroma_height,\n                              h->chroma_log2_weight_denom,\n                              h->chroma_weight[refn0][0][0][0],\n                              h->chroma_weight[refn1][1][0][0],\n                              h->chroma_weight[refn0][0][0][1] +\n                              h->chroma_weight[refn1][1][0][1]);\n            chroma_weight_avg(dest_cr, tmp_cr, h->mb_uvlinesize, chroma_height,\n                              h->chroma_log2_weight_denom,\n                              h->chroma_weight[refn0][0][1][0],\n                              h->chroma_weight[refn1][1][1][0],\n                              h->chroma_weight[refn0][0][1][1] +\n                              h->chroma_weight[refn1][1][1][1]);\n        }\n    } else {\n        int list     = list1 ? 1 : 0;\n        int refn     = h->ref_cache[list][scan8[n]];\n        Picture *ref = &h->ref_list[list][refn];\n        mc_dir_part(h, ref, n, square, height, delta, list,\n                    dest_y, dest_cb, dest_cr, x_offset, y_offset,\n                    qpix_put, chroma_put, pixel_shift, chroma_idc);\n\n        luma_weight_op(dest_y, h->mb_linesize, height,\n                       h->luma_log2_weight_denom,\n                       h->luma_weight[refn][list][0],\n                       h->luma_weight[refn][list][1]);\n        if (h->use_weight_chroma) {\n            chroma_weight_op(dest_cb, h->mb_uvlinesize, chroma_height,\n                             h->chroma_log2_weight_denom,\n                             h->chroma_weight[refn][list][0][0],\n                             h->chroma_weight[refn][list][0][1]);\n            chroma_weight_op(dest_cr, h->mb_uvlinesize, chroma_height,\n                             h->chroma_log2_weight_denom,\n                             h->chroma_weight[refn][list][1][0],\n                             h->chroma_weight[refn][list][1][1]);\n        }\n    }\n}\n", "target": 0, "idx": 28263}
{"func": "BluetoothSocketGetInfoFunction::BluetoothSocketGetInfoFunction() {}\n", "target": 0, "idx": 167079}
{"func": "MagickExport void *FileToBlob(const char *filename,const size_t extent,\n  size_t *length,ExceptionInfo *exception)\n{\n  int\n    file;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  register size_t\n    i;\n\n  ssize_t\n    count;\n\n  struct stat\n    attributes;\n\n  unsigned char\n    *blob;\n\n  void\n    *map;\n\n  assert(filename != (const char *) NULL);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  *length=0;\n  status=IsRightsAuthorized(PathPolicyDomain,ReadPolicyRights,filename);\n  if (status == MagickFalse)\n    {\n      errno=EPERM;\n      (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,\n        \"NotAuthorized\",\"`%s'\",filename);\n      return(NULL);\n    }\n  file=fileno(stdin);\n  if (LocaleCompare(filename,\"-\") != 0)\n    {\n      status=GetPathAttributes(filename,&attributes);\n      if ((status == MagickFalse) || (S_ISDIR(attributes.st_mode) != 0))\n        {\n          ThrowFileException(exception,BlobError,\"UnableToReadBlob\",filename);\n          return(NULL);\n        }\n      file=open_utf8(filename,O_RDONLY | O_BINARY,0);\n    }\n  if (file == -1)\n    {\n      ThrowFileException(exception,BlobError,\"UnableToOpenFile\",filename);\n      return(NULL);\n    }\n  offset=(MagickOffsetType) lseek(file,0,SEEK_END);\n  count=0;\n  if ((file == fileno(stdin)) || (offset < 0) ||\n      (offset != (MagickOffsetType) ((ssize_t) offset)))\n    {\n      size_t\n        quantum;\n\n      struct stat\n        file_stats;\n\n      /*\n        Stream is not seekable.\n      */\n      offset=(MagickOffsetType) lseek(file,0,SEEK_SET);\n      quantum=(size_t) MagickMaxBufferExtent;\n      if ((fstat(file,&file_stats) == 0) && (file_stats.st_size > 0))\n        quantum=(size_t) MagickMin(file_stats.st_size,MagickMaxBufferExtent);\n      blob=(unsigned char *) AcquireQuantumMemory(quantum,sizeof(*blob));\n      for (i=0; blob != (unsigned char *) NULL; i+=count)\n      {\n        count=read(file,blob+i,quantum);\n        if (count <= 0)\n          {\n            count=0;\n            if (errno != EINTR)\n              break;\n          }\n        if (~((size_t) i) < (quantum+1))\n          {\n            blob=(unsigned char *) RelinquishMagickMemory(blob);\n            break;\n          }\n        blob=(unsigned char *) ResizeQuantumMemory(blob,i+quantum+1,\n          sizeof(*blob));\n        if ((size_t) (i+count) >= extent)\n          break;\n      }\n      if (LocaleCompare(filename,\"-\") != 0)\n        file=close(file);\n      if (blob == (unsigned char *) NULL)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",filename);\n          return(NULL);\n        }\n      if (file == -1)\n        {\n          blob=(unsigned char *) RelinquishMagickMemory(blob);\n          ThrowFileException(exception,BlobError,\"UnableToReadBlob\",filename);\n          return(NULL);\n        }\n      *length=(size_t) MagickMin(i+count,extent);\n      blob[*length]='\\0';\n      return(blob);\n    }\n  *length=(size_t) MagickMin(offset,(MagickOffsetType)\n    MagickMin(extent,(size_t) SSIZE_MAX));\n  blob=(unsigned char *) NULL;\n  if (~(*length) >= (MagickPathExtent-1))\n    blob=(unsigned char *) AcquireQuantumMemory(*length+MagickPathExtent,\n      sizeof(*blob));\n  if (blob == (unsigned char *) NULL)\n    {\n      file=close(file);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",filename);\n      return(NULL);\n    }\n  map=MapBlob(file,ReadMode,0,*length);\n  if (map != (unsigned char *) NULL)\n    {\n      (void) memcpy(blob,map,*length);\n      (void) UnmapBlob(map,*length);\n    }\n  else\n    {\n      (void) lseek(file,0,SEEK_SET);\n      for (i=0; i < *length; i+=count)\n      {\n        count=read(file,blob+i,(size_t) MagickMin(*length-i,(size_t)\n          SSIZE_MAX));\n        if (count <= 0)\n          {\n            count=0;\n            if (errno != EINTR)\n              break;\n          }\n      }\n      if (i < *length)\n        {\n          file=close(file)-1;\n          blob=(unsigned char *) RelinquishMagickMemory(blob);\n          ThrowFileException(exception,BlobError,\"UnableToReadBlob\",filename);\n          return(NULL);\n        }\n    }\n  blob[*length]='\\0';\n  if (LocaleCompare(filename,\"-\") != 0)\n    file=close(file);\n  if (file == -1)\n    {\n      blob=(unsigned char *) RelinquishMagickMemory(blob);\n      ThrowFileException(exception,BlobError,\"UnableToReadBlob\",filename);\n    }\n  return(blob);\n}\n", "target": 0, "idx": 96636}
{"func": "IHEVCD_ERROR_T ihevcd_mv_buf_mgr_add_bufs(codec_t *ps_codec)\n{\n    IHEVCD_ERROR_T ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;\n    WORD32 i;\n    WORD32 max_dpb_size;\n    WORD32 mv_bank_size_allocated;\n    WORD32 pic_mv_bank_size;\n\n sps_t *ps_sps;\n    UWORD8 *pu1_buf;\n mv_buf_t *ps_mv_buf;\n\n\n /* Initialize MV Bank buffer manager */\n    ps_sps = ps_codec->s_parse.ps_sps;\n\n\n /* Compute the number of MV Bank buffers needed */\n    max_dpb_size = ps_sps->ai1_sps_max_dec_pic_buffering[ps_sps->i1_sps_max_sub_layers - 1];\n\n /* Allocate one extra MV Bank to handle current frame\n     * In case of asynchronous parsing and processing, number of buffers should increase here\n     * based on when parsing and processing threads are synchronized\n\n      */\n     max_dpb_size++;\n \n     pu1_buf = (UWORD8 *)ps_codec->pv_mv_bank_buf_base;\n \n     ps_mv_buf = (mv_buf_t *)pu1_buf;\n    pu1_buf += max_dpb_size * sizeof(mv_buf_t);\n    ps_codec->ps_mv_buf = ps_mv_buf;\n    mv_bank_size_allocated = ps_codec->i4_total_mv_bank_size - max_dpb_size  * sizeof(mv_buf_t);\n\n /* Compute MV bank size per picture */\n    pic_mv_bank_size = ihevcd_get_pic_mv_bank_size(ALIGN64(ps_sps->i2_pic_width_in_luma_samples) *\n                                                   ALIGN64(ps_sps->i2_pic_height_in_luma_samples));\n\n for(i = 0; i < max_dpb_size; i++)\n {\n        WORD32 buf_ret;\n        WORD32 num_pu;\n        WORD32 num_ctb;\n        WORD32 pic_size;\n        pic_size = ALIGN64(ps_sps->i2_pic_width_in_luma_samples) *\n                        ALIGN64(ps_sps->i2_pic_height_in_luma_samples);\n\n\n        num_pu = pic_size / (MIN_PU_SIZE * MIN_PU_SIZE);\n        num_ctb = pic_size / (MIN_CTB_SIZE * MIN_CTB_SIZE);\n\n\n        mv_bank_size_allocated -= pic_mv_bank_size;\n\n if(mv_bank_size_allocated < 0)\n {\n            ps_codec->s_parse.i4_error_code = IHEVCD_INSUFFICIENT_MEM_MVBANK;\n return IHEVCD_INSUFFICIENT_MEM_MVBANK;\n }\n\n        ps_mv_buf->pu4_pic_pu_idx = (UWORD32 *)pu1_buf;\n        pu1_buf += (num_ctb + 1) * sizeof(WORD32);\n\n        ps_mv_buf->pu1_pic_pu_map = pu1_buf;\n        pu1_buf += num_pu;\n\n        ps_mv_buf->pu1_pic_slice_map = (UWORD16 *)pu1_buf;\n        pu1_buf += ALIGN4(num_ctb * sizeof(UWORD16));\n\n        ps_mv_buf->ps_pic_pu = (pu_t *)pu1_buf;\n        pu1_buf += num_pu * sizeof(pu_t);\n\n        buf_ret = ihevc_buf_mgr_add((buf_mgr_t *)ps_codec->pv_mv_buf_mgr, ps_mv_buf, i);\n\n if(0 != buf_ret)\n {\n            ps_codec->s_parse.i4_error_code = IHEVCD_BUF_MGR_ERROR;\n return IHEVCD_BUF_MGR_ERROR;\n }\n\n        ps_mv_buf++;\n\n }\n return ret;\n}\n", "target": 1, "idx": 188021}
{"func": "BOOLEAN ParaNdis_AnalyzeReceivedPacket(\n    PVOID headersBuffer,\n    ULONG dataLength,\n    PNET_PACKET_INFO packetInfo)\n{\n    NdisZeroMemory(packetInfo, sizeof(*packetInfo));\n\n    packetInfo->headersBuffer = headersBuffer;\n    packetInfo->dataLength = dataLength;\n\n    if(!AnalyzeL2Hdr(packetInfo))\n        return FALSE;\n\n    if (!AnalyzeL3Hdr(packetInfo))\n        return FALSE;\n\n    return TRUE;\n}\n", "target": 0, "idx": 74434}
{"func": "static void updateHashChain(Hash* hash, size_t wpos, unsigned hashval, unsigned short numzeros)\n{\n  hash->val[wpos] = (int)hashval;\n  if(hash->head[hashval] != -1) hash->chain[wpos] = hash->head[hashval];\n  hash->head[hashval] = wpos;\n\n  hash->zeros[wpos] = numzeros;\n  if(hash->headz[numzeros] != -1) hash->chainz[wpos] = hash->headz[numzeros];\n  hash->headz[numzeros] = wpos;\n}\n", "target": 0, "idx": 87615}
{"func": "Chapters::Edition::Edition()\n{\n }\n", "target": 1, "idx": 188295}
{"func": "void Document::InheritHtmlAndBodyElementStyles(StyleRecalcChange change) {\n  DCHECK(InStyleRecalc());\n  DCHECK(documentElement());\n\n  bool did_recalc_document_element = false;\n  RefPtr<ComputedStyle> document_element_style =\n      documentElement()->MutableComputedStyle();\n  if (change == kForce)\n    documentElement()->ClearAnimationStyleChange();\n  if (!document_element_style || documentElement()->NeedsStyleRecalc() ||\n      change == kForce) {\n    document_element_style =\n        EnsureStyleResolver().StyleForElement(documentElement());\n    did_recalc_document_element = true;\n  }\n\n  WritingMode root_writing_mode = document_element_style->GetWritingMode();\n  TextDirection root_direction = document_element_style->Direction();\n\n  HTMLElement* body = this->body();\n  RefPtr<ComputedStyle> body_style;\n\n  if (body) {\n    body_style = body->MutableComputedStyle();\n    if (did_recalc_document_element)\n      body->ClearAnimationStyleChange();\n    if (!body_style || body->NeedsStyleRecalc() ||\n        did_recalc_document_element) {\n      body_style = EnsureStyleResolver().StyleForElement(\n          body, document_element_style.Get(), document_element_style.Get());\n    }\n    root_writing_mode = body_style->GetWritingMode();\n    root_direction = body_style->Direction();\n  }\n\n  const ComputedStyle* background_style = document_element_style.Get();\n  if (isHTMLHtmlElement(documentElement()) && isHTMLBodyElement(body) &&\n      !background_style->HasBackground())\n    background_style = body_style.Get();\n\n  Node& root_scroller = GetRootScrollerController().EffectiveRootScroller();\n  RefPtr<ComputedStyle> root_scroller_style;\n  if (this != &root_scroller) {\n    DCHECK(root_scroller.IsElementNode());\n    Element* root_scroller_element = ToElement(&root_scroller);\n    root_scroller_style = root_scroller_element->MutableComputedStyle();\n\n    if (!root_scroller_style || root_scroller_element->NeedsStyleRecalc()) {\n      root_scroller_style =\n          EnsureStyleResolver().StyleForElement(root_scroller_element);\n    }\n\n    background_style = root_scroller_style.Get();\n  }\n\n  Color background_color =\n      background_style->VisitedDependentColor(CSSPropertyBackgroundColor);\n  FillLayer background_layers = background_style->BackgroundLayers();\n  for (auto current_layer = &background_layers; current_layer;\n       current_layer = current_layer->Next()) {\n    current_layer->SetClip(kBorderFillBox);\n\n    if (current_layer->Attachment() == kScrollBackgroundAttachment)\n      current_layer->SetAttachment(kLocalBackgroundAttachment);\n  }\n  EImageRendering image_rendering = background_style->ImageRendering();\n\n  const ComputedStyle* overflow_style = nullptr;\n  if (Element* element =\n          ViewportDefiningElement(document_element_style.Get())) {\n    if (element == body) {\n      overflow_style = body_style.Get();\n    } else {\n      DCHECK_EQ(element, documentElement());\n      overflow_style = document_element_style.Get();\n\n      if (body_style && !body_style->IsOverflowVisible())\n        UseCounter::Count(*this, WebFeature::kBodyScrollsInAdditionToViewport);\n    }\n  }\n\n  if (GetStyleEngine().UsesRemUnits() &&\n      (documentElement()->NeedsAttach() ||\n       !documentElement()->GetComputedStyle() ||\n       documentElement()->GetComputedStyle()->FontSize() !=\n           document_element_style->FontSize())) {\n    EnsureStyleResolver().InvalidateMatchedPropertiesCache();\n    documentElement()->SetNeedsStyleRecalc(\n        kSubtreeStyleChange, StyleChangeReasonForTracing::Create(\n                                 StyleChangeReason::kFontSizeChange));\n  }\n\n  EOverflowAnchor overflow_anchor = EOverflowAnchor::kAuto;\n  EOverflow overflow_x = EOverflow::kAuto;\n  EOverflow overflow_y = EOverflow::kAuto;\n  float column_gap = 0;\n  if (overflow_style) {\n    overflow_anchor = overflow_style->OverflowAnchor();\n    overflow_x = overflow_style->OverflowX();\n    overflow_y = overflow_style->OverflowY();\n    if (overflow_x == EOverflow::kVisible)\n      overflow_x = EOverflow::kAuto;\n    if (overflow_y == EOverflow::kVisible)\n      overflow_y = EOverflow::kAuto;\n    if (overflow_anchor == EOverflowAnchor::kVisible)\n      overflow_anchor = EOverflowAnchor::kAuto;\n    column_gap = overflow_style->ColumnGap();\n  }\n\n  ScrollSnapType snap_type = overflow_style->GetScrollSnapType();\n\n  RefPtr<ComputedStyle> viewport_style = GetLayoutViewItem().MutableStyle();\n  if (viewport_style->GetWritingMode() != root_writing_mode ||\n      viewport_style->Direction() != root_direction ||\n      viewport_style->VisitedDependentColor(CSSPropertyBackgroundColor) !=\n          background_color ||\n      viewport_style->BackgroundLayers() != background_layers ||\n      viewport_style->ImageRendering() != image_rendering ||\n      viewport_style->OverflowAnchor() != overflow_anchor ||\n      viewport_style->OverflowX() != overflow_x ||\n      viewport_style->OverflowY() != overflow_y ||\n      viewport_style->ColumnGap() != column_gap ||\n      viewport_style->GetScrollSnapType() != snap_type) {\n    RefPtr<ComputedStyle> new_style = ComputedStyle::Clone(*viewport_style);\n    new_style->SetWritingMode(root_writing_mode);\n    new_style->SetDirection(root_direction);\n    new_style->SetBackgroundColor(background_color);\n    new_style->AccessBackgroundLayers() = background_layers;\n    new_style->SetImageRendering(image_rendering);\n    new_style->SetOverflowAnchor(overflow_anchor);\n    new_style->SetOverflowX(overflow_x);\n    new_style->SetOverflowY(overflow_y);\n    new_style->SetColumnGap(column_gap);\n    new_style->SetScrollSnapType(snap_type);\n    GetLayoutViewItem().SetStyle(new_style);\n    SetupFontBuilder(*new_style);\n  }\n\n  if (body) {\n    if (const ComputedStyle* style = body->GetComputedStyle()) {\n      if (style->Direction() != root_direction ||\n          style->GetWritingMode() != root_writing_mode)\n        body->SetNeedsStyleRecalc(kSubtreeStyleChange,\n                                  StyleChangeReasonForTracing::Create(\n                                      StyleChangeReason::kWritingModeChange));\n    }\n  }\n\n  if (const ComputedStyle* style = documentElement()->GetComputedStyle()) {\n    if (style->Direction() != root_direction ||\n        style->GetWritingMode() != root_writing_mode)\n      documentElement()->SetNeedsStyleRecalc(\n          kSubtreeStyleChange, StyleChangeReasonForTracing::Create(\n                                   StyleChangeReason::kWritingModeChange));\n  }\n}\n", "target": 0, "idx": 146772}
{"func": "long long VideoTrack::GetHeight() const\n{\n    return m_height;\n}\n", "target": 1, "idx": 188349}
{"func": "static bool blk_mq_hctx_has_pending(struct blk_mq_hw_ctx *hctx)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hctx->ctx_map.size; i++)\n\t\tif (hctx->ctx_map.map[i].word)\n\t\t\treturn true;\n\n\treturn false;\n}\n", "target": 0, "idx": 86707}
{"func": "bitcat(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *arg1 = PG_GETARG_VARBIT_P(0);\n\tVarBit\t   *arg2 = PG_GETARG_VARBIT_P(1);\n\n\tPG_RETURN_VARBIT_P(bit_catenate(arg1, arg2));\n}\n", "target": 0, "idx": 39075}
{"func": "SplashError Splash::fillImageMask(SplashImageMaskSource src, void *srcData,\n\t\t\t\t  int w, int h, SplashCoord *mat,\n\t\t\t\t  GBool glyphMode) {\n  SplashPipe pipe;\n  GBool rot;\n  SplashCoord xScale, yScale, xShear, yShear, yShear1;\n  int tx, tx2, ty, ty2, scaledWidth, scaledHeight, xSign, ySign;\n  int ulx, uly, llx, lly, urx, ury, lrx, lry;\n  int ulx1, uly1, llx1, lly1, urx1, ury1, lrx1, lry1;\n  int xMin, xMax, yMin, yMax;\n  SplashClipResult clipRes, clipRes2;\n  int yp, yq, yt, yStep, lastYStep;\n  int xp, xq, xt, xStep, xSrc;\n  int k1, spanXMin, spanXMax, spanY;\n  SplashColorPtr pixBuf, p;\n  int pixAcc;\n  int x, y, x1, x2, y2;\n  SplashCoord y1;\n  int n, m, i, j;\n\n  if (debugMode) {\n    printf(\"fillImageMask: w=%d h=%d mat=[%.2f %.2f %.2f %.2f %.2f %.2f]\\n\",\n\t   w, h, (double)mat[0], (double)mat[1], (double)mat[2],\n\t   (double)mat[3], (double)mat[4], (double)mat[5]);\n  }\n\n  if (w == 0 && h == 0) return splashErrZeroImage;\n\n  if (splashAbs(mat[0] * mat[3] - mat[1] * mat[2]) < 0.000001) {\n    return splashErrSingularMatrix;\n  }\n\n  rot = splashAbs(mat[1]) > splashAbs(mat[0]);\n  if (rot) {\n    xScale = -mat[1];\n    yScale = mat[2] - (mat[0] * mat[3]) / mat[1];\n    xShear = -mat[3] / yScale;\n    yShear = -mat[0] / mat[1];\n  } else {\n    xScale = mat[0];\n    yScale = mat[3] - (mat[1] * mat[2]) / mat[0];\n    xShear = mat[2] / yScale;\n    yShear = mat[1] / mat[0];\n  }\n  if (glyphMode) {\n    if (xScale >= 0) {\n      tx = splashRound(mat[4]);\n      tx2 = splashRound(mat[4] + xScale) - 1;\n    } else {\n      tx = splashRound(mat[4]) - 1;\n      tx2 = splashRound(mat[4] + xScale);\n    }\n  } else {\n    if (xScale >= 0) {\n      tx = splashFloor(mat[4] - 0.01);\n      tx2 = splashFloor(mat[4] + xScale + 0.01);\n    } else {\n      tx = splashFloor(mat[4] + 0.01);\n      tx2 = splashFloor(mat[4] + xScale - 0.01);\n    }\n  }\n  scaledWidth = abs(tx2 - tx) + 1;\n  if (glyphMode) {\n    if (yScale >= 0) {\n      ty = splashRound(mat[5]);\n      ty2 = splashRound(mat[5] + yScale) - 1;\n    } else {\n      ty = splashRound(mat[5]) - 1;\n      ty2 = splashRound(mat[5] + yScale);\n    }\n  } else {\n    if (yScale >= 0) {\n      ty = splashFloor(mat[5] - 0.01);\n      ty2 = splashFloor(mat[5] + yScale + 0.01);\n    } else {\n      ty = splashFloor(mat[5] + 0.01);\n      ty2 = splashFloor(mat[5] + yScale - 0.01);\n    }\n  }\n  scaledHeight = abs(ty2 - ty) + 1;\n  xSign = (xScale < 0) ? -1 : 1;\n  ySign = (yScale < 0) ? -1 : 1;\n  yShear1 = (SplashCoord)xSign * yShear;\n\n  ulx1 = 0;\n  uly1 = 0;\n  urx1 = xSign * (scaledWidth - 1);\n  ury1 = (int)(yShear * urx1);\n  llx1 = splashRound(xShear * ySign * (scaledHeight - 1));\n  lly1 = ySign * (scaledHeight - 1) + (int)(yShear * llx1);\n  lrx1 = xSign * (scaledWidth - 1) +\n           splashRound(xShear * ySign * (scaledHeight - 1));\n  lry1 = ySign * (scaledHeight - 1) + (int)(yShear * lrx1);\n  if (rot) {\n    ulx = tx + uly1;    uly = ty - ulx1;\n    urx = tx + ury1;    ury = ty - urx1;\n    llx = tx + lly1;    lly = ty - llx1;\n    lrx = tx + lry1;    lry = ty - lrx1;\n  } else {\n    ulx = tx + ulx1;    uly = ty + uly1;\n    urx = tx + urx1;    ury = ty + ury1;\n    llx = tx + llx1;    lly = ty + lly1;\n    lrx = tx + lrx1;    lry = ty + lry1;\n  }\n  xMin = (ulx < urx) ? (ulx < llx) ? (ulx < lrx) ? ulx : lrx\n                                   : (llx < lrx) ? llx : lrx\n\t\t     : (urx < llx) ? (urx < lrx) ? urx : lrx\n                                   : (llx < lrx) ? llx : lrx;\n  xMax = (ulx > urx) ? (ulx > llx) ? (ulx > lrx) ? ulx : lrx\n                                   : (llx > lrx) ? llx : lrx\n\t\t     : (urx > llx) ? (urx > lrx) ? urx : lrx\n                                   : (llx > lrx) ? llx : lrx;\n  yMin = (uly < ury) ? (uly < lly) ? (uly < lry) ? uly : lry\n                                   : (lly < lry) ? lly : lry\n\t\t     : (ury < lly) ? (ury < lry) ? ury : lry\n                                   : (lly < lry) ? lly : lry;\n  yMax = (uly > ury) ? (uly > lly) ? (uly > lry) ? uly : lry\n                                   : (lly > lry) ? lly : lry\n\t\t     : (ury > lly) ? (ury > lry) ? ury : lry\n                                   : (lly > lry) ? lly : lry;\n  clipRes = state->clip->testRect(xMin, yMin, xMax, yMax);\n  opClipRes = clipRes;\n\n  yp = h / scaledHeight;\n  yq = h % scaledHeight;\n  xp = w / scaledWidth;\n   xq = w % scaledWidth;\n \n  pixBuf = (SplashColorPtr)gmalloc((yp + 1) * w);\n \n   pipeInit(&pipe, 0, 0, state->fillPattern, NULL, state->fillAlpha,\n\t   gTrue, gFalse);\n  if (vectorAntialias) {\n    drawAAPixelInit();\n  }\n\n  yt = 0;\n  lastYStep = 1;\n\n  for (y = 0; y < scaledHeight; ++y) {\n\n    yStep = yp;\n    yt += yq;\n    if (yt >= scaledHeight) {\n      yt -= scaledHeight;\n      ++yStep;\n    }\n\n    n = (yp > 0) ? yStep : lastYStep;\n    if (n > 0) {\n      p = pixBuf;\n      for (i = 0; i < n; ++i) {\n\t(*src)(srcData, p);\n\tp += w;\n      }\n    }\n    lastYStep = yStep;\n\n    k1 = splashRound(xShear * ySign * y);\n\n    if (clipRes != splashClipAllInside &&\n\t!rot &&\n\t(int)(yShear * k1) ==\n\t  (int)(yShear * (xSign * (scaledWidth - 1) + k1))) {\n      if (xSign > 0) {\n\tspanXMin = tx + k1;\n\tspanXMax = spanXMin + (scaledWidth - 1);\n      } else {\n\tspanXMax = tx + k1;\n\tspanXMin = spanXMax - (scaledWidth - 1);\n      }\n      spanY = ty + ySign * y + (int)(yShear * k1);\n      clipRes2 = state->clip->testSpan(spanXMin, spanXMax, spanY);\n      if (clipRes2 == splashClipAllOutside) {\n\tcontinue;\n      }\n    } else {\n      clipRes2 = clipRes;\n    }\n\n    xt = 0;\n    xSrc = 0;\n\n    x1 = k1;\n\n    y1 = (SplashCoord)ySign * y + yShear * x1;\n    if (yShear1 < 0) {\n      y1 += 0.999;\n    }\n\n    n = yStep > 0 ? yStep : 1;\n\n    for (x = 0; x < scaledWidth; ++x) {\n\n      xStep = xp;\n      xt += xq;\n      if (xt >= scaledWidth) {\n\txt -= scaledWidth;\n\t++xStep;\n      }\n\n      if (rot) {\n\tx2 = (int)y1;\n\ty2 = -x1;\n      } else {\n\tx2 = x1;\n\ty2 = (int)y1;\n      }\n\n      m = xStep > 0 ? xStep : 1;\n      p = pixBuf + xSrc;\n      pixAcc = 0;\n      for (i = 0; i < n; ++i) {\n\tfor (j = 0; j < m; ++j) {\n\t  pixAcc += *p++;\n\t}\n\tp += w - m;\n      }\n\n      if (pixAcc != 0) {\n\tpipe.shape = (pixAcc == n * m)\n\t                 ? (SplashCoord)1\n\t                 : (SplashCoord)pixAcc / (SplashCoord)(n * m);\n\tif (vectorAntialias && clipRes2 != splashClipAllInside) {\n\t  drawAAPixel(&pipe, tx + x2, ty + y2);\n\t} else {\n\t  drawPixel(&pipe, tx + x2, ty + y2, clipRes2 == splashClipAllInside);\n\t}\n      }\n\n      xSrc += xStep;\n\n      x1 += xSign;\n\n      y1 += yShear1;\n    }\n  }\n\n  gfree(pixBuf);\n\n  return splashOk;\n}\n", "target": 1, "idx": 177791}
{"func": "static Image *ReadMONOImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  register IndexPacket\n    *indexes;\n\n  register PixelPacket\n    *q;\n\n  register ssize_t\n    x;\n\n  size_t\n    bit,\n    byte;\n\n  ssize_t\n    y;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  if ((image->columns == 0) || (image->rows == 0))\n    ThrowReaderException(OptionError,\"MustSpecifyImageSize\");\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (DiscardBlobBytes(image,image->offset) == MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  /*\n    Initialize image colormap.\n  */\n  image->depth=1;\n  if (AcquireImageColormap(image,2) == MagickFalse)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  if (image_info->ping != MagickFalse)\n    {\n       (void) CloseBlob(image);\n       return(GetFirstImageInList(image));\n     }\n   /*\n     Convert bi-level image to pixel packets.\n   */\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      break;\n    indexes=GetAuthenticIndexQueue(image);\n    bit=0;\n    byte=0;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if (bit == 0)\n        byte=(size_t) ReadBlobByte(image);\n      if (image_info->endian == LSBEndian)\n        SetPixelIndex(indexes+x,((byte & 0x01) != 0) ? 0x00 : 0x01)\n      else\n        SetPixelIndex(indexes+x,((byte & 0x01) != 0) ? 0x01 : 0x00)\n      bit++;\n      if (bit == 8)\n        bit=0;\n      byte>>=1;\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  (void) SyncImage(image);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n", "target": 1, "idx": 181754}
{"func": " void SynchronousCompositorImpl::DidActivatePendingTree() {\n   DCHECK(compositor_client_);\n  compositor_client_->DidUpdateContent();\n   DeliverMessages();\n }\n", "target": 1, "idx": 185584}
{"func": "static int try_read_command(conn *c) {\n    assert(c != NULL);\n    assert(c->rcurr <= (c->rbuf + c->rsize));\n    assert(c->rbytes > 0);\n\n    if (c->protocol == negotiating_prot || c->transport == udp_transport)  {\n        if ((unsigned char)c->rbuf[0] == (unsigned char)PROTOCOL_BINARY_REQ) {\n            c->protocol = binary_prot;\n        } else {\n            c->protocol = ascii_prot;\n        }\n\n        if (settings.verbose > 1) {\n            fprintf(stderr, \"%d: Client using the %s protocol\\n\", c->sfd,\n                    prot_text(c->protocol));\n        }\n    }\n\n    if (c->protocol == binary_prot) {\n        /* Do we have the complete packet header? */\n        if (c->rbytes < sizeof(c->binary_header)) {\n            /* need more data! */\n            return 0;\n        } else {\n#ifdef NEED_ALIGN\n            if (((long)(c->rcurr)) % 8 != 0) {\n                /* must realign input buffer */\n                memmove(c->rbuf, c->rcurr, c->rbytes);\n                c->rcurr = c->rbuf;\n                if (settings.verbose > 1) {\n                    fprintf(stderr, \"%d: Realign input buffer\\n\", c->sfd);\n                }\n            }\n#endif\n            protocol_binary_request_header* req;\n            req = (protocol_binary_request_header*)c->rcurr;\n\n            if (settings.verbose > 1) {\n                /* Dump the packet before we convert it to host order */\n                int ii;\n                fprintf(stderr, \"<%d Read binary protocol data:\", c->sfd);\n                for (ii = 0; ii < sizeof(req->bytes); ++ii) {\n                    if (ii % 4 == 0) {\n                        fprintf(stderr, \"\\n<%d   \", c->sfd);\n                    }\n                    fprintf(stderr, \" 0x%02x\", req->bytes[ii]);\n                }\n                fprintf(stderr, \"\\n\");\n            }\n\n            c->binary_header = *req;\n            c->binary_header.request.keylen = ntohs(req->request.keylen);\n            c->binary_header.request.bodylen = ntohl(req->request.bodylen);\n            c->binary_header.request.cas = ntohll(req->request.cas);\n\n            if (c->binary_header.request.magic != PROTOCOL_BINARY_REQ) {\n                if (settings.verbose) {\n                    fprintf(stderr, \"Invalid magic:  %x\\n\",\n                            c->binary_header.request.magic);\n                }\n                conn_set_state(c, conn_closing);\n                return -1;\n            }\n\n            c->msgcurr = 0;\n            c->msgused = 0;\n            c->iovused = 0;\n            if (add_msghdr(c) != 0) {\n                out_string(c, \"SERVER_ERROR out of memory\");\n                return 0;\n            }\n\n            c->cmd = c->binary_header.request.opcode;\n            c->keylen = c->binary_header.request.keylen;\n            c->opaque = c->binary_header.request.opaque;\n            /* clear the returned cas value */\n            c->cas = 0;\n\n            dispatch_bin_command(c);\n\n            c->rbytes -= sizeof(c->binary_header);\n            c->rcurr += sizeof(c->binary_header);\n        }\n    } else {\n        char *el, *cont;\n \n         if (c->rbytes == 0)\n             return 0;\n         el = memchr(c->rcurr, '\\n', c->rbytes);\n        if (!el)\n             return 0;\n         cont = el + 1;\n         if ((el - c->rcurr) > 1 && *(el - 1) == '\\r') {\n             el--;\n        }\n        *el = '\\0';\n\n        assert(cont <= (c->rcurr + c->rbytes));\n\n        process_command(c, c->rcurr);\n\n        c->rbytes -= (cont - c->rcurr);\n        c->rcurr = cont;\n\n        assert(c->rcurr <= (c->rbuf + c->rsize));\n    }\n\n    return 1;\n}\n", "target": 1, "idx": 183047}
{"func": "static void customGetterImplementedAsLongAttributeAttributeSetterCallback(v8::Local<v8::String>, v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)\n{\n    TRACE_EVENT_SET_SAMPLING_STATE(\"Blink\", \"DOMSetter\");\n    TestObjectPythonV8Internal::customGetterImplementedAsLongAttributeAttributeSetter(jsValue, info);\n    TRACE_EVENT_SET_SAMPLING_STATE(\"V8\", \"V8Execution\");\n}\n", "target": 0, "idx": 131315}
{"func": "void gdImageString (gdImagePtr im, gdFontPtr f, int x, int y, unsigned char *s, int color)\n{\n\tint i;\n\tint l;\n\tl = strlen ((char *) s);\n\tfor (i = 0; (i < l); i++) {\n\t\tgdImageChar(im, f, x, y, s[i], color);\n\t\tx += f->w;\n\t}\n}\n", "target": 0, "idx": 51455}
{"func": "static int unix_attach_fds(struct scm_cookie *scm, struct sk_buff *skb)\n{\n\tint i;\n\tunsigned char max_level = 0;\n\tint unix_sock_count = 0;\n\n\tif (too_many_unix_fds(current))\n\t\treturn -ETOOMANYREFS;\n\n\tfor (i = scm->fp->count - 1; i >= 0; i--) {\n\t\tstruct sock *sk = unix_get_socket(scm->fp->fp[i]);\n\n\t\tif (sk) {\n\t\t\tunix_sock_count++;\n\t\t\tmax_level = max(max_level,\n\t\t\t\t\tunix_sk(sk)->recursion_level);\n\t\t}\n\t}\n\tif (unlikely(max_level > MAX_RECURSION_LEVEL))\n\t\treturn -ETOOMANYREFS;\n\n\t/*\n\t * Need to duplicate file references for the sake of garbage\n\t * collection.  Otherwise a socket in the fps might become a\n\t * candidate for GC while the skb is not yet queued.\n\t */\n\tUNIXCB(skb).fp = scm_fp_dup(scm->fp);\n\tif (!UNIXCB(skb).fp)\n \t\treturn -ENOMEM;\n \n \tfor (i = scm->fp->count - 1; i >= 0; i--)\n\t\tunix_inflight(scm->fp->fp[i]);\n \treturn max_level;\n }\n", "target": 1, "idx": 180566}
{"func": "  static void QuitMessageLoop() {\n    base::RunLoop::QuitCurrentWhenIdleDeprecated();\n   }\n", "target": 1, "idx": 185967}
{"func": "SendTabToSelfInfoBarDelegate::Create(const SendTabToSelfEntry* entry) {\n  return base::WrapUnique(new SendTabToSelfInfoBarDelegate(entry));\n }\n", "target": 1, "idx": 186509}
{"func": "void TextIterator::emitText(Node* textNode, RenderObject* renderObject, int textStartOffset, int textEndOffset)\n{\n    RenderText* renderer = toRenderText(renderObject);\n    m_text = m_emitsOriginalText ? renderer->originalText() : (m_emitsTextWithoutTranscoding ? renderer->textWithoutTranscoding() : renderer->text());\n    ASSERT(!m_text.isEmpty());\n    ASSERT(0 <= textStartOffset && textStartOffset < static_cast<int>(m_text.length()));\n    ASSERT(0 <= textEndOffset && textEndOffset <= static_cast<int>(m_text.length()));\n    ASSERT(textStartOffset <= textEndOffset);\n\n    m_positionNode = textNode;\n    m_positionOffsetBaseNode = 0;\n    m_positionStartOffset = textStartOffset;\n    m_positionEndOffset = textEndOffset;\n    m_textCharacters = 0;\n    m_textLength = textEndOffset - textStartOffset;\n    m_lastCharacter = m_text[textEndOffset - 1];\n\n    m_lastTextNodeEndedWithCollapsedSpace = false;\n    m_hasEmitted = true;\n}\n", "target": 0, "idx": 121588}
{"func": " void grubfs_free (GrubFS *gf) {\n \tif (gf) {\n\t\tif (gf->file && gf->file->device)\n \t\t\tfree (gf->file->device->disk);\n \t\tfree (gf->file);\n \t\tfree (gf);\n\t}\n}\n", "target": 1, "idx": 181262}
{"func": "void FeatureInfo::EnableES3Validators() {\n  DCHECK(IsES3Capable());\n  validators_.UpdateValuesES3();\n\n  GLint max_color_attachments = 0;\n  glGetIntegerv(GL_MAX_COLOR_ATTACHMENTS, &max_color_attachments);\n  const int kTotalColorAttachmentEnums = 16;\n  const GLenum kColorAttachments[] = {\n    GL_COLOR_ATTACHMENT0,\n    GL_COLOR_ATTACHMENT1,\n    GL_COLOR_ATTACHMENT2,\n    GL_COLOR_ATTACHMENT3,\n    GL_COLOR_ATTACHMENT4,\n    GL_COLOR_ATTACHMENT5,\n    GL_COLOR_ATTACHMENT6,\n    GL_COLOR_ATTACHMENT7,\n    GL_COLOR_ATTACHMENT8,\n    GL_COLOR_ATTACHMENT9,\n    GL_COLOR_ATTACHMENT10,\n    GL_COLOR_ATTACHMENT11,\n    GL_COLOR_ATTACHMENT12,\n    GL_COLOR_ATTACHMENT13,\n    GL_COLOR_ATTACHMENT14,\n    GL_COLOR_ATTACHMENT15,\n  };\n  if (max_color_attachments < kTotalColorAttachmentEnums) {\n    validators_.attachment.RemoveValues(\n        kColorAttachments + max_color_attachments,\n        kTotalColorAttachmentEnums - max_color_attachments);\n    validators_.attachment_query.RemoveValues(\n        kColorAttachments + max_color_attachments,\n        kTotalColorAttachmentEnums - max_color_attachments);\n    validators_.read_buffer.RemoveValues(\n        kColorAttachments + max_color_attachments,\n        kTotalColorAttachmentEnums - max_color_attachments);\n  }\n\n  GLint max_draw_buffers = 0;\n  glGetIntegerv(GL_MAX_DRAW_BUFFERS, &max_draw_buffers);\n  const int kTotalDrawBufferEnums = 16;\n  const GLenum kDrawBuffers[] = {\n    GL_DRAW_BUFFER0,\n    GL_DRAW_BUFFER1,\n    GL_DRAW_BUFFER2,\n    GL_DRAW_BUFFER3,\n    GL_DRAW_BUFFER4,\n    GL_DRAW_BUFFER5,\n    GL_DRAW_BUFFER6,\n    GL_DRAW_BUFFER7,\n    GL_DRAW_BUFFER8,\n    GL_DRAW_BUFFER9,\n    GL_DRAW_BUFFER10,\n    GL_DRAW_BUFFER11,\n    GL_DRAW_BUFFER12,\n    GL_DRAW_BUFFER13,\n    GL_DRAW_BUFFER14,\n    GL_DRAW_BUFFER15,\n  };\n  if (max_draw_buffers < kTotalDrawBufferEnums) {\n    validators_.g_l_state.RemoveValues(\n        kDrawBuffers + max_draw_buffers,\n        kTotalDrawBufferEnums - max_draw_buffers);\n  }\n\n  if (feature_flags_.ext_texture_format_bgra8888) {\n    validators_.texture_internal_format.AddValue(GL_BGRA8_EXT);\n    validators_.texture_sized_color_renderable_internal_format.AddValue(\n        GL_BGRA8_EXT);\n    validators_.texture_sized_texture_filterable_internal_format.AddValue(\n        GL_BGRA8_EXT);\n  }\n\n  if (!IsWebGLContext()) {\n    validators_.texture_parameter.AddValue(GL_TEXTURE_SWIZZLE_R);\n    validators_.texture_parameter.AddValue(GL_TEXTURE_SWIZZLE_G);\n    validators_.texture_parameter.AddValue(GL_TEXTURE_SWIZZLE_B);\n    validators_.texture_parameter.AddValue(GL_TEXTURE_SWIZZLE_A);\n  }\n}\n", "target": 0, "idx": 149726}
{"func": "EncodedJSValue JSC_HOST_CALL JSTestNamedConstructorNamedConstructor::constructJSTestNamedConstructor(ExecState* exec)\n {\n     JSTestNamedConstructorNamedConstructor* castedThis = jsCast<JSTestNamedConstructorNamedConstructor*>(exec->callee());\n     if (exec->argumentCount() < 1)\n        return throwVMError(exec, createTypeError(exec, \"Not enough arguments\"));\n     ExceptionCode ec = 0;\n     const String& str1(ustringToString(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).isEmpty() ? UString() : MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toString(exec)->value(exec)));\n     if (exec->hadException())\n        return JSValue::encode(jsUndefined());\n    const String& str2(ustringToString(MAYBE_MISSING_PARAMETER(exec, 1, DefaultIsUndefined).isEmpty() ? UString() : MAYBE_MISSING_PARAMETER(exec, 1, DefaultIsUndefined).toString(exec)->value(exec)));\n    if (exec->hadException())\n        return JSValue::encode(jsUndefined());\n    const String& str3(ustringToString(MAYBE_MISSING_PARAMETER(exec, 2, DefaultIsNullString).isEmpty() ? UString() : MAYBE_MISSING_PARAMETER(exec, 2, DefaultIsNullString).toString(exec)->value(exec)));\n    if (exec->hadException())\n        return JSValue::encode(jsUndefined());\n    RefPtr<TestNamedConstructor> object = TestNamedConstructor::createForJSConstructor(castedThis->document(), str1, str2, str3, ec);\n    if (ec) {\n        setDOMException(exec, ec);\n        return JSValue::encode(JSValue());\n    }\n    return JSValue::encode(asObject(toJS(exec, castedThis->globalObject(), object.get())));\n}\n", "target": 1, "idx": 184034}
{"func": "IMPEG2D_ERROR_CODES_T impeg2d_dec_p_b_slice(dec_state_t *ps_dec)\n{\n    WORD16 *pi2_vld_out;\n    UWORD32 i;\n yuv_buf_t *ps_cur_frm_buf      = &ps_dec->s_cur_frm_buf;\n\n    UWORD32 u4_frm_offset          = 0;\n const dec_mb_params_t *ps_dec_mb_params;\n    IMPEG2D_ERROR_CODES_T e_error   = (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;\n\n    pi2_vld_out = ps_dec->ai2_vld_buf;\n    memset(ps_dec->ai2_pred_mv,0,sizeof(ps_dec->ai2_pred_mv));\n\n    ps_dec->u2_prev_intra_mb    = 0;\n    ps_dec->u2_first_mb       = 1;\n\n    ps_dec->u2_picture_width = ps_dec->u2_frame_width;\n\n if(ps_dec->u2_picture_structure != FRAME_PICTURE)\n {\n        ps_dec->u2_picture_width <<= 1;\n if(ps_dec->u2_picture_structure == BOTTOM_FIELD)\n {\n            u4_frm_offset = ps_dec->u2_frame_width;\n }\n }\n\n\n     do\n     {\n         UWORD32 u4_x_offset, u4_y_offset;\n \n \n         UWORD32 u4_x_dst_offset = 0;\n        UWORD32 u4_y_dst_offset = 0;\n        UWORD8  *pu1_out_p;\n        UWORD8  *pu1_pred;\n        WORD32 u4_pred_strd;\n\n        IMPEG2D_TRACE_MB_START(ps_dec->u2_mb_x, ps_dec->u2_mb_y);\n\n \n \n         if(ps_dec->e_pic_type == B_PIC)\n            impeg2d_dec_pnb_mb_params(ps_dec);\n         else\n            impeg2d_dec_p_mb_params(ps_dec);\n \n         IMPEG2D_TRACE_MB_START(ps_dec->u2_mb_x, ps_dec->u2_mb_y);\n \n         u4_x_dst_offset = u4_frm_offset + (ps_dec->u2_mb_x << 4);\n        u4_y_dst_offset = (ps_dec->u2_mb_y << 4) * ps_dec->u2_picture_width;\n        pu1_out_p = ps_cur_frm_buf->pu1_y + u4_x_dst_offset + u4_y_dst_offset;\n if(ps_dec->u2_prev_intra_mb == 0)\n {\n            UWORD32 offset_x, offset_y, stride;\n            UWORD16 index = (ps_dec->u2_motion_type);\n /*only for non intra mb's*/\n if(ps_dec->e_mb_pred == BIDIRECT)\n {\n                ps_dec_mb_params = &ps_dec->ps_func_bi_direct[index];\n }\n else\n {\n                ps_dec_mb_params = &ps_dec->ps_func_forw_or_back[index];\n }\n\n            stride = ps_dec->u2_picture_width;\n\n            offset_x = u4_frm_offset + (ps_dec->u2_mb_x << 4);\n\n            offset_y = (ps_dec->u2_mb_y << 4);\n\n            ps_dec->s_dest_buf.pu1_y = ps_cur_frm_buf->pu1_y + offset_y * stride + offset_x;\n\n            stride = stride >> 1;\n\n            ps_dec->s_dest_buf.pu1_u = ps_cur_frm_buf->pu1_u + (offset_y >> 1) * stride\n + (offset_x >> 1);\n\n            ps_dec->s_dest_buf.pu1_v = ps_cur_frm_buf->pu1_v + (offset_y >> 1) * stride\n + (offset_x >> 1);\n\n            PROFILE_DISABLE_MC_IF0\n            ps_dec_mb_params->pf_mc(ps_dec);\n\n }\n for(i = 0; i < NUM_LUMA_BLKS; ++i)\n {\n if((ps_dec->u2_cbp & (1 << (BLOCKS_IN_MB - 1 - i))) != 0)\n {\n                e_error = ps_dec->pf_vld_inv_quant(ps_dec, pi2_vld_out, ps_dec->pu1_inv_scan_matrix,\n                              ps_dec->u2_prev_intra_mb, Y_LUMA, 0);\n if ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE != e_error)\n {\n return e_error;\n }\n\n                u4_x_offset = gai2_impeg2_blk_x_off[i];\n\n if(ps_dec->u2_field_dct == 0)\n                    u4_y_offset = gai2_impeg2_blk_y_off_frm[i] ;\n else\n                    u4_y_offset = gai2_impeg2_blk_y_off_fld[i] ;\n\n\n\n\n\n                IMPEG2D_IDCT_INP_STATISTICS(pi2_vld_out, ps_dec->u4_non_zero_cols, ps_dec->u4_non_zero_rows);\n\n                PROFILE_DISABLE_IDCT_IF0\n {\n                    WORD32 idx;\n if(1 == (ps_dec->u4_non_zero_cols | ps_dec->u4_non_zero_rows))\n                        idx = 0;\n else\n                        idx = 1;\n\n if(0 == ps_dec->u2_prev_intra_mb)\n {\n                        pu1_pred = pu1_out_p + u4_y_offset * ps_dec->u2_picture_width + u4_x_offset;\n                        u4_pred_strd = ps_dec->u2_picture_width << ps_dec->u2_field_dct;\n }\n else\n {\n                        pu1_pred = (UWORD8 *)gau1_impeg2_zerobuf;\n                        u4_pred_strd = 8;\n }\n\n                    ps_dec->pf_idct_recon[idx * 2 + ps_dec->i4_last_value_one](pi2_vld_out,\n                                                            ps_dec->ai2_idct_stg1,\n                                                            pu1_pred,\n                                                            pu1_out_p + u4_y_offset * ps_dec->u2_picture_width + u4_x_offset,\n 8,\n                                                            u4_pred_strd,\n                                                            ps_dec->u2_picture_width << ps_dec->u2_field_dct,\n ~ps_dec->u4_non_zero_cols, ~ps_dec->u4_non_zero_rows);\n }\n }\n\n }\n\n /* For U and V blocks, divide the x and y offsets by 2. */\n        u4_x_dst_offset >>= 1;\n        u4_y_dst_offset >>= 2;\n\n\n /* In case of chrominance blocks the DCT will be frame DCT */\n /* i = 0, U component and i = 1 is V componet */\n if((ps_dec->u2_cbp & 0x02) != 0)\n {\n            pu1_out_p = ps_cur_frm_buf->pu1_u + u4_x_dst_offset + u4_y_dst_offset;\n            e_error = ps_dec->pf_vld_inv_quant(ps_dec, pi2_vld_out, ps_dec->pu1_inv_scan_matrix,\n                          ps_dec->u2_prev_intra_mb, U_CHROMA, 0);\n if ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE != e_error)\n {\n return e_error;\n }\n\n\n            IMPEG2D_IDCT_INP_STATISTICS(pi2_vld_out, ps_dec->u4_non_zero_cols, ps_dec->u4_non_zero_rows);\n\n            PROFILE_DISABLE_IDCT_IF0\n {\n                WORD32 idx;\n if(1 == (ps_dec->u4_non_zero_cols | ps_dec->u4_non_zero_rows))\n                    idx = 0;\n else\n                    idx = 1;\n\n if(0 == ps_dec->u2_prev_intra_mb)\n {\n                    pu1_pred = pu1_out_p;\n                    u4_pred_strd = ps_dec->u2_picture_width >> 1;\n }\n else\n {\n                    pu1_pred = (UWORD8 *)gau1_impeg2_zerobuf;\n                    u4_pred_strd = 8;\n }\n\n                ps_dec->pf_idct_recon[idx * 2 + ps_dec->i4_last_value_one](pi2_vld_out,\n                                                        ps_dec->ai2_idct_stg1,\n                                                        pu1_pred,\n                                                        pu1_out_p,\n 8,\n                                                        u4_pred_strd,\n                                                        ps_dec->u2_picture_width >> 1,\n ~ps_dec->u4_non_zero_cols, ~ps_dec->u4_non_zero_rows);\n\n }\n\n }\n\n\n if((ps_dec->u2_cbp & 0x01) != 0)\n {\n            pu1_out_p = ps_cur_frm_buf->pu1_v + u4_x_dst_offset + u4_y_dst_offset;\n            e_error = ps_dec->pf_vld_inv_quant(ps_dec, pi2_vld_out, ps_dec->pu1_inv_scan_matrix,\n                          ps_dec->u2_prev_intra_mb, V_CHROMA, 0);\n if ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE != e_error)\n {\n return e_error;\n }\n\n\n            IMPEG2D_IDCT_INP_STATISTICS(pi2_vld_out, ps_dec->u4_non_zero_cols, ps_dec->u4_non_zero_rows);\n\n            PROFILE_DISABLE_IDCT_IF0\n {\n                WORD32 idx;\n if(1 == (ps_dec->u4_non_zero_cols | ps_dec->u4_non_zero_rows))\n                    idx = 0;\n else\n                    idx = 1;\n if(0 == ps_dec->u2_prev_intra_mb)\n {\n                    pu1_pred = pu1_out_p;\n                    u4_pred_strd = ps_dec->u2_picture_width >> 1;\n }\n else\n {\n                    pu1_pred = (UWORD8 *)gau1_impeg2_zerobuf;\n                    u4_pred_strd = 8;\n }\n\n                ps_dec->pf_idct_recon[idx * 2 + ps_dec->i4_last_value_one](pi2_vld_out,\n                                                        ps_dec->ai2_idct_stg1,\n                                                        pu1_pred,\n                                                        pu1_out_p,\n 8,\n                                                        u4_pred_strd,\n                                                        ps_dec->u2_picture_width >> 1,\n ~ps_dec->u4_non_zero_cols, ~ps_dec->u4_non_zero_rows);\n\n }\n }\n\n\n        ps_dec->u2_num_mbs_left--;\n        ps_dec->u2_first_mb = 0;\n        ps_dec->u2_mb_x++;\n\n if(ps_dec->s_bit_stream.u4_offset > ps_dec->s_bit_stream.u4_max_offset)\n {\n return IMPEG2D_BITSTREAM_BUFF_EXCEEDED_ERR;\n }\n else if (ps_dec->u2_mb_x == ps_dec->u2_num_horiz_mb)\n {\n            ps_dec->u2_mb_x = 0;\n            ps_dec->u2_mb_y++;\n\n }\n }\n while(ps_dec->u2_num_mbs_left != 0 && impeg2d_bit_stream_nxt(&ps_dec->s_bit_stream,23) != 0x0);\n return e_error;\n}\n", "target": 1, "idx": 188630}
{"func": "int gdTransformAffineCopy(gdImagePtr dst,\n\t\t  int dst_x, int dst_y,\n\t\t  const gdImagePtr src,\n\t\t  gdRectPtr src_region,\n\t\t  const double affine[6])\n{\n\tint c1x,c1y,c2x,c2y;\n\tint backclip = 0;\n\tint backup_clipx1, backup_clipy1, backup_clipx2, backup_clipy2;\n\tregister int x, y, src_offset_x, src_offset_y;\n\tdouble inv[6];\n\tint *dst_p;\n\tgdPointF pt, src_pt;\n\tgdRect bbox;\n\tint end_x, end_y;\n\tgdInterpolationMethod interpolation_id_bak = GD_DEFAULT;\n\tinterpolation_method interpolation_bak;\n\n\t/* These methods use special implementations */\n \tif (src->interpolation_id == GD_BILINEAR_FIXED || src->interpolation_id == GD_BICUBIC_FIXED || src->interpolation_id == GD_NEAREST_NEIGHBOUR) {\n \t\tinterpolation_id_bak = src->interpolation_id;\n \t\tinterpolation_bak = src->interpolation;\n \t\tgdImageSetInterpolationMethod(src, GD_BICUBIC);\n \t}\n \n\n\tgdImageClipRectangle(src, src_region);\n\n\tif (src_region->x > 0 || src_region->y > 0\n\t\t|| src_region->width < gdImageSX(src)\n\t\t|| src_region->height < gdImageSY(src)) {\n\t\tbackclip = 1;\n\n\t\tgdImageGetClip(src, &backup_clipx1, &backup_clipy1,\n\t\t&backup_clipx2, &backup_clipy2);\n\n\t\tgdImageSetClip(src, src_region->x, src_region->y,\n\t\t\tsrc_region->x + src_region->width - 1,\n\t\t\tsrc_region->y + src_region->height - 1);\n\t}\n\n\tif (!gdTransformAffineBoundingBox(src_region, affine, &bbox)) {\n\t\tif (backclip) {\n\t\t\tgdImageSetClip(src, backup_clipx1, backup_clipy1,\n\t\t\t\t\tbackup_clipx2, backup_clipy2);\n\t\t}\n\t\tgdImageSetInterpolationMethod(src, interpolation_id_bak);\n\t\treturn GD_FALSE;\n\t}\n\n\tgdImageGetClip(dst, &c1x, &c1y, &c2x, &c2y);\n\n\tend_x = bbox.width  + (int) fabs(bbox.x);\n\tend_y = bbox.height + (int) fabs(bbox.y);\n\n\t/* Get inverse affine to let us work with destination -> source */\n\tgdAffineInvert(inv, affine);\n\n\tsrc_offset_x =  src_region->x;\n\tsrc_offset_y =  src_region->y;\n\n\tif (dst->alphaBlendingFlag) {\n\t\tfor (y = bbox.y; y <= end_y; y++) {\n\t\t\tpt.y = y + 0.5;\n\t\t\tfor (x = 0; x <= end_x; x++) {\n\t\t\t\tpt.x = x + 0.5;\n\t\t\t\tgdAffineApplyToPointF(&src_pt, &pt, inv);\n\t\t\t\tgdImageSetPixel(dst, dst_x + x, dst_y + y, getPixelInterpolated(src, src_offset_x + src_pt.x, src_offset_y + src_pt.y, 0));\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (y = 0; y <= end_y; y++) {\n\t\t\tpt.y = y + 0.5 + bbox.y;\n\t\t\tif ((dst_y + y) < 0 || ((dst_y + y) > gdImageSY(dst) -1)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdst_p = dst->tpixels[dst_y + y] + dst_x;\n\n\t\t\tfor (x = 0; x <= end_x; x++) {\n\t\t\t\tpt.x = x + 0.5 + bbox.x;\n\t\t\t\tgdAffineApplyToPointF(&src_pt, &pt, inv);\n\n\t\t\t\tif ((dst_x + x) < 0 || (dst_x + x) > (gdImageSX(dst) - 1)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*(dst_p++) = getPixelInterpolated(src, src_offset_x + src_pt.x, src_offset_y + src_pt.y, -1);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Restore clip if required */\n\tif (backclip) {\n\t\tgdImageSetClip(src, backup_clipx1, backup_clipy1,\n\t\t\t\tbackup_clipx2, backup_clipy2);\n\t}\n\n\tgdImageSetInterpolationMethod(src, interpolation_id_bak);\n\treturn GD_TRUE;\n}\n", "target": 1, "idx": 183178}
{"func": "command_set_status_text (Fep *fep,\n\t\t\t FepControlMessage *request)\n{\n  FepAttribute attr;\n  if (_fep_control_message_read_attribute_arg (request, 1, &attr) == 0)\n    _fep_output_status_text (fep, request->args[0].str, &attr);\n}\n", "target": 0, "idx": 36955}
{"func": "static int encrypted_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct encrypted_key_payload *epayload = key->payload.data[0];\n\tstruct encrypted_key_payload *new_epayload;\n\tchar *buf;\n\tchar *new_master_desc = NULL;\n\tconst char *format = NULL;\n \tsize_t datalen = prep->datalen;\n \tint ret = 0;\n \n\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n \t\treturn -ENOKEY;\n \tif (datalen <= 0 || datalen > 32767 || !prep->data)\n \t\treturn -EINVAL;\n\n\tbuf = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tbuf[datalen] = 0;\n\tmemcpy(buf, prep->data, datalen);\n\tret = datablob_parse(buf, &format, &new_master_desc, NULL, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = valid_master_desc(new_master_desc, epayload->master_desc);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tnew_epayload = encrypted_key_alloc(key, epayload->format,\n\t\t\t\t\t   new_master_desc, epayload->datalen);\n\tif (IS_ERR(new_epayload)) {\n\t\tret = PTR_ERR(new_epayload);\n\t\tgoto out;\n\t}\n\n\t__ekey_init(new_epayload, epayload->format, new_master_desc,\n\t\t    epayload->datalen);\n\n\tmemcpy(new_epayload->iv, epayload->iv, ivsize);\n\tmemcpy(new_epayload->payload_data, epayload->payload_data,\n\t       epayload->payload_datalen);\n\n\trcu_assign_keypointer(key, new_epayload);\n\tcall_rcu(&epayload->rcu, encrypted_rcu_free);\nout:\n\tkzfree(buf);\n\treturn ret;\n}\n", "target": 1, "idx": 180866}
{"func": "void V8Window::namedPropertyGetterCustom(v8::Local<v8::String> name, const v8::PropertyCallbackInfo<v8::Value>& info)\n{\n\n    DOMWindow* window = V8Window::toNative(info.Holder());\n    if (!window)\n        return;\n\n    Frame* frame = window->frame();\n    if (!frame)\n        return;\n\n    AtomicString propName = toWebCoreAtomicString(name);\n    Frame* child = frame->tree().scopedChild(propName);\n    if (child) {\n        v8SetReturnValueFast(info, child->domWindow(), window);\n        return;\n    }\n\n    if (!info.Holder()->GetRealNamedProperty(name).IsEmpty())\n        return;\n\n     Document* doc = frame->document();\n \n     if (doc && doc->isHTMLDocument()) {\n        if (toHTMLDocument(doc)->hasNamedItem(propName.impl()) || doc->hasElementWithId(propName.impl())) {\n             RefPtr<HTMLCollection> items = doc->windowNamedItems(propName);\n             if (!items->isEmpty()) {\n                 if (items->hasExactlyOneItem()) {\n                    v8SetReturnValueFast(info, items->item(0), window);\n                    return;\n                }\n                v8SetReturnValueFast(info, items.release(), window);\n                return;\n            }\n        }\n    }\n}\n", "target": 1, "idx": 184847}
{"func": "void ssl_set_own_cert( ssl_context *ssl, x509_cert *own_cert,\n                       rsa_context *rsa_key )\n{\n    ssl->own_cert   = own_cert;\n    ssl->rsa_key    = rsa_key;\n}\n", "target": 0, "idx": 29037}
{"func": "PannerNode* AudioContext::createPanner()\n{\n    ASSERT(isMainThread());\n    return PannerNode::create(this, m_destinationNode->sampleRate());\n}\n", "target": 0, "idx": 139642}
{"func": "static int gather_pte_stats(pmd_t *pmd, unsigned long addr,\n\t\tunsigned long end, struct mm_walk *walk)\n{\n\tstruct numa_maps *md;\n\tspinlock_t *ptl;\n\tpte_t *orig_pte;\n\tpte_t *pte;\n\n\tmd = walk->private;\n\tspin_lock(&walk->mm->page_table_lock);\n\tif (pmd_trans_huge(*pmd)) {\n\t\tif (pmd_trans_splitting(*pmd)) {\n\t\t\tspin_unlock(&walk->mm->page_table_lock);\n\t\t\twait_split_huge_page(md->vma->anon_vma, pmd);\n\t\t} else {\n\t\t\tpte_t huge_pte = *(pte_t *)pmd;\n\t\t\tstruct page *page;\n\n\t\t\tpage = can_gather_numa_stats(huge_pte, md->vma, addr);\n\t\t\tif (page)\n\t\t\t\tgather_stats(page, md, pte_dirty(huge_pte),\n\t\t\t\t\t\tHPAGE_PMD_SIZE/PAGE_SIZE);\n\t\t\tspin_unlock(&walk->mm->page_table_lock);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n \t\tspin_unlock(&walk->mm->page_table_lock);\n \t}\n \n \torig_pte = pte = pte_offset_map_lock(walk->mm, pmd, addr, &ptl);\n \tdo {\n \t\tstruct page *page = can_gather_numa_stats(*pte, md->vma, addr);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tgather_stats(page, md, pte_dirty(*pte), 1);\n\n\t} while (pte++, addr += PAGE_SIZE, addr != end);\n\tpte_unmap_unlock(orig_pte, ptl);\n\treturn 0;\n}\n", "target": 1, "idx": 178800}
{"func": "bool_t auth_gssapi_unseal_seq(\n     gss_ctx_id_t context,\n     gss_buffer_t in_buf,\n     uint32_t *seq_num)\n{\n     gss_buffer_desc out_buf;\n     OM_uint32 gssstat, minor_stat;\n     uint32_t nl_seq_num;\n\n     gssstat = gss_unseal(&minor_stat, context, in_buf, &out_buf,\n\t\t\t  NULL, NULL);\n     if (gssstat != GSS_S_COMPLETE) {\n\t  PRINTF((\"gssapi_unseal_seq: failed\\n\"));\n\t  AUTH_GSSAPI_DISPLAY_STATUS((\"unsealing sequence number\",\n\t\t\t\t      gssstat, minor_stat));\n\t  return FALSE;\n     } else if (out_buf.length != sizeof(uint32_t)) {\n\t  PRINTF((\"gssapi_unseal_seq: unseal gave %d bytes\\n\",\n\t\t  (int) out_buf.length));\n\t  gss_release_buffer(&minor_stat, &out_buf);\n\t  return FALSE;\n     }\n\n     nl_seq_num = *((uint32_t *) out_buf.value);\n     *seq_num = (uint32_t) ntohl(nl_seq_num);\n     gss_release_buffer(&minor_stat, &out_buf);\n\n     return TRUE;\n}\n", "target": 0, "idx": 46095}
{"func": " void user_describe(const struct key *key, struct seq_file *m)\n {\n \tseq_puts(m, key->description);\n\tif (key_is_instantiated(key))\n \t\tseq_printf(m, \": %u\", key->datalen);\n }\n", "target": 1, "idx": 180881}
{"func": "USHORT CNB::QueryL4HeaderOffset(PVOID PacketData, ULONG IpHeaderOffset) const\n {\n     USHORT Res;\n     auto ppr = ParaNdis_ReviewIPPacket(RtlOffsetToPointer(PacketData, IpHeaderOffset),\n                                       GetDataLength(), __FUNCTION__);\n     if (ppr.ipStatus != ppresNotIP)\n     {\n         Res = static_cast<USHORT>(IpHeaderOffset + ppr.ipHeaderSize);\n    }\n    else\n    {\n        DPrintf(0, (\"[%s] ERROR: NOT an IP packet - expected troubles!\\n\", __FUNCTION__));\n        Res = 0;\n    }\n    return Res;\n}\n", "target": 1, "idx": 183313}
{"func": " void BluetoothDeviceChromeOS::CancelPairing() {\n  if (!RunPairingCallbacks(CANCELLED)) {\n     DBusThreadManager::Get()->GetBluetoothDeviceClient()->\n         CancelPairing(\n             object_path_,\n            base::Bind(&base::DoNothing),\n            base::Bind(&BluetoothDeviceChromeOS::OnCancelPairingError,\n                        weak_ptr_factory_.GetWeakPtr()));\n \n    UnregisterAgent();\n   }\n }\n", "target": 1, "idx": 184911}
{"func": "static int hid_match_usage(struct hid_device *hid, struct hid_usage *usage)\n{\n\tconst struct hid_usage_id *id = hid->driver->usage_table;\n\n\tif (!id) /* NULL means all */\n\t\treturn 1;\n\n\tfor (; id->usage_type != HID_ANY_ID - 1; id++)\n\t\tif ((id->usage_hid == HID_ANY_ID ||\n\t\t\t\tid->usage_hid == usage->hid) &&\n\t\t\t\t(id->usage_type == HID_ANY_ID ||\n\t\t\t\tid->usage_type == usage->type) &&\n\t\t\t\t(id->usage_code == HID_ANY_ID ||\n\t\t\t\t id->usage_code == usage->code))\n\t\t\treturn 1;\n\treturn 0;\n}\n", "target": 0, "idx": 49503}
{"func": " BOOL region16_union_rect(REGION16* dst, const REGION16* src, const RECTANGLE_16* rect)\n {\n \tconst RECTANGLE_16* srcExtents;\n \tRECTANGLE_16* dstExtents;\n \tconst RECTANGLE_16* currentBand, *endSrcRect, *nextBand;\n\tREGION16_DATA* newItems = NULL;\n\tRECTANGLE_16* dstRect = NULL;\n\tUINT32 usedRects, srcNbRects;\n\tUINT16 topInterBand;\n\tassert(src);\n\tassert(src->data);\n\tassert(dst);\n\tsrcExtents = region16_extents(src);\n\tdstExtents = region16_extents_noconst(dst);\n\n\tif (!region16_n_rects(src))\n\t{\n\t\t/* source is empty, so the union is rect */\n\t\tdst->extents = *rect;\n\t\tdst->data = allocateRegion(1);\n\n\t\tif (!dst->data)\n\t\t\treturn FALSE;\n\n\t\tdstRect = region16_rects_noconst(dst);\n\t\tdstRect->top = rect->top;\n\t\tdstRect->left = rect->left;\n\t\tdstRect->right = rect->right;\n\t\tdstRect->bottom = rect->bottom;\n\t\treturn TRUE;\n\t}\n\n\tnewItems = allocateRegion((1 + region16_n_rects(src)) * 4);\n\n\tif (!newItems)\n\t\treturn FALSE;\n\n\tdstRect = (RECTANGLE_16*)(&newItems[1]);\n\tusedRects = 0;\n\n\t/* adds the piece of rect that is on the top of src */\n\tif (rect->top < srcExtents->top)\n\t{\n\t\tdstRect->top = rect->top;\n\t\tdstRect->left = rect->left;\n\t\tdstRect->right = rect->right;\n\t\tdstRect->bottom = MIN(srcExtents->top, rect->bottom);\n\t\tusedRects++;\n\t\tdstRect++;\n\t}\n\n\t/* treat possibly overlapping region */\n\tcurrentBand = region16_rects(src, &srcNbRects);\n\tendSrcRect = currentBand + srcNbRects;\n\n\twhile (currentBand < endSrcRect)\n\t{\n\t\tif ((currentBand->bottom <= rect->top) || (rect->bottom <= currentBand->top) ||\n\t\t    rectangle_contained_in_band(currentBand, endSrcRect, rect))\n\t\t{\n\t\t\t/* no overlap between rect and the band, rect is totally below or totally above\n\t\t\t * the current band, or rect is already covered by an item of the band.\n\t\t\t * let's copy all the rectangles from this band\n\t\t\t\t\t\t+----+\n\t\t\t\t\t\t|    |   rect (case 1)\n\t\t\t\t\t\t+----+\n\n\t\t\t   =================\n\t\t\tband of srcRect\n\t\t\t =================\n\t\t\t\t\t+----+\n\t\t\t\t\t|    |   rect (case 2)\n\t\t\t\t\t+----+\n\t\t\t*/\n\t\t\tregion16_copy_band_with_union(dstRect,\n\t\t\t                              currentBand, endSrcRect,\n\t\t\t                              currentBand->top, currentBand->bottom,\n\t\t\t                              NULL, &usedRects,\n\t\t\t                              &nextBand, &dstRect);\n\t\t\ttopInterBand = rect->top;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* rect overlaps the band:\n\t\t\t\t\t   |    |  |    |\n\t\t\t====^=================|    |==|    |=========================== band\n\t\t\t|   top split     |    |  |    |\n\t\t\tv                 | 1  |  | 2  |\n\t\t\t^                 |    |  |    |  +----+   +----+\n\t\t\t|   merge zone    |    |  |    |  |    |   | 4  |\n\t\t\tv                 +----+  |    |  |    |   +----+\n\t\t\t^                         |    |  | 3  |\n\t\t\t|   bottom split          |    |  |    |\n\t\t\t====v=========================|    |==|    |===================\n\t\t\t\t\t   |    |  |    |\n\n\t\t\t possible cases:\n\t\t\t 1) no top split, merge zone then a bottom split. The band will be splitted\n\t\t\t  in two\n\t\t\t 2) not band split, only the merge zone, band merged with rect but not splitted\n\t\t\t 3) a top split, the merge zone and no bottom split. The band will be split\n\t\t\t in two\n\t\t\t 4) a top split, the merge zone and also a bottom split. The band will be\n\t\t\t splitted in 3, but the coalesce algorithm may merge the created bands\n\t\t\t */\n\t\t\tUINT16 mergeTop = currentBand->top;\n\t\t\tUINT16 mergeBottom = currentBand->bottom;\n\n\t\t\t/* test if we need a top split, case 3 and 4 */\n\t\t\tif (rect->top > currentBand->top)\n\t\t\t{\n\t\t\t\tregion16_copy_band_with_union(dstRect,\n\t\t\t\t                              currentBand, endSrcRect,\n\t\t\t\t                              currentBand->top, rect->top,\n\t\t\t\t                              NULL, &usedRects,\n\t\t\t\t                              &nextBand, &dstRect);\n\t\t\t\tmergeTop = rect->top;\n\t\t\t}\n\n\t\t\t/* do the merge zone (all cases) */\n\t\t\tif (rect->bottom < currentBand->bottom)\n\t\t\t\tmergeBottom = rect->bottom;\n\n\t\t\tregion16_copy_band_with_union(dstRect,\n\t\t\t                              currentBand, endSrcRect,\n\t\t\t                              mergeTop, mergeBottom,\n\t\t\t                              rect, &usedRects,\n\t\t\t                              &nextBand, &dstRect);\n\n\t\t\t/* test if we need a bottom split, case 1 and 4 */\n\t\t\tif (rect->bottom < currentBand->bottom)\n\t\t\t{\n\t\t\t\tregion16_copy_band_with_union(dstRect,\n\t\t\t\t                              currentBand, endSrcRect,\n\t\t\t\t                              mergeBottom, currentBand->bottom,\n\t\t\t\t                              NULL, &usedRects,\n\t\t\t\t                              &nextBand, &dstRect);\n\t\t\t}\n\n\t\t\ttopInterBand = currentBand->bottom;\n\t\t}\n\n\t\t/* test if a piece of rect should be inserted as a new band between\n\t\t * the current band and the next one. band n and n+1 shouldn't touch.\n\t\t *\n\t\t * ==============================================================\n\t\t *                                                        band n\n\t\t *            +------+                    +------+\n\t\t * ===========| rect |====================|      |===============\n\t\t *            |      |    +------+        |      |\n\t\t *            +------+    | rect |        | rect |\n\t\t *                        +------+        |      |\n\t\t * =======================================|      |================\n\t\t *                                        +------+         band n+1\n\t\t * ===============================================================\n\t\t *\n\t\t */\n\t\tif ((nextBand < endSrcRect) && (nextBand->top != currentBand->bottom) &&\n\t\t    (rect->bottom > currentBand->bottom) && (rect->top < nextBand->top))\n\t\t{\n\t\t\tdstRect->right = rect->right;\n\t\t\tdstRect->left = rect->left;\n\t\t\tdstRect->top = topInterBand;\n\t\t\tdstRect->bottom = MIN(nextBand->top, rect->bottom);\n\t\t\tdstRect++;\n\t\t\tusedRects++;\n\t\t}\n\n\t\tcurrentBand = nextBand;\n\t}\n\n\t/* adds the piece of rect that is below src */\n\tif (srcExtents->bottom < rect->bottom)\n\t{\n\t\tdstRect->top = MAX(srcExtents->bottom, rect->top);\n\t\tdstRect->left = rect->left;\n\t\tdstRect->right = rect->right;\n\t\tdstRect->bottom = rect->bottom;\n\t\tusedRects++;\n\t\tdstRect++;\n\t}\n\n\tif ((src == dst) && (src->data->size > 0) && (src->data != &empty_region))\n\t\tfree(src->data);\n\n\tdstExtents->top = MIN(rect->top, srcExtents->top);\n\tdstExtents->left = MIN(rect->left, srcExtents->left);\n \tdstExtents->bottom = MAX(rect->bottom, srcExtents->bottom);\n \tdstExtents->right = MAX(rect->right, srcExtents->right);\n \tnewItems->size = sizeof(REGION16_DATA) + (usedRects * sizeof(RECTANGLE_16));\n\tdst->data = realloc(newItems, newItems->size);\n \n \tif (!dst->data)\n \t{\n\t\tfree(newItems);\n\t\treturn FALSE;\n\t}\n\n\tdst->data->nbRects = usedRects;\n\treturn region16_simplify_bands(dst);\n}\n", "target": 1, "idx": 182670}
{"func": "juniper_es_print(netdissect_options *ndo,\n                 const struct pcap_pkthdr *h, register const u_char *p)\n{\n        struct juniper_l2info_t l2info;\n        struct juniper_ipsec_header {\n            uint8_t sa_index[2];\n            uint8_t ttl;\n            uint8_t type;\n            uint8_t spi[4];\n            uint8_t src_ip[4];\n            uint8_t dst_ip[4];\n        };\n        u_int rewrite_len,es_type_bundle;\n        const struct juniper_ipsec_header *ih;\n\n        l2info.pictype = DLT_JUNIPER_ES;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n\n         p+=l2info.header_len;\n         ih = (const struct juniper_ipsec_header *)p;\n \n         switch (ih->type) {\n         case JUNIPER_IPSEC_O_ESP_ENCRYPT_ESP_AUTHEN_TYPE:\n         case JUNIPER_IPSEC_O_ESP_ENCRYPT_AH_AUTHEN_TYPE:\n            rewrite_len = 0;\n            es_type_bundle = 1;\n            break;\n        case JUNIPER_IPSEC_O_ESP_AUTHENTICATION_TYPE:\n        case JUNIPER_IPSEC_O_AH_AUTHENTICATION_TYPE:\n        case JUNIPER_IPSEC_O_ESP_ENCRYPTION_TYPE:\n            rewrite_len = 16;\n            es_type_bundle = 0;\n            break;\n        default:\n            ND_PRINT((ndo, \"ES Invalid type %u, length %u\",\n                   ih->type,\n                   l2info.length));\n            return l2info.header_len;\n        }\n\n        l2info.length-=rewrite_len;\n        p+=rewrite_len;\n\n        if (ndo->ndo_eflag) {\n            if (!es_type_bundle) {\n                ND_PRINT((ndo, \"ES SA, index %u, ttl %u type %s (%u), spi %u, Tunnel %s > %s, length %u\\n\",\n                       EXTRACT_16BITS(&ih->sa_index),\n                       ih->ttl,\n                       tok2str(juniper_ipsec_type_values,\"Unknown\",ih->type),\n                       ih->type,\n                       EXTRACT_32BITS(&ih->spi),\n                       ipaddr_string(ndo, &ih->src_ip),\n                       ipaddr_string(ndo, &ih->dst_ip),\n                       l2info.length));\n            } else {\n                ND_PRINT((ndo, \"ES SA, index %u, ttl %u type %s (%u), length %u\\n\",\n                       EXTRACT_16BITS(&ih->sa_index),\n                       ih->ttl,\n                       tok2str(juniper_ipsec_type_values,\"Unknown\",ih->type),\n                       ih->type,\n                       l2info.length));\n            }\n        }\n \n         ip_print(ndo, p, l2info.length);\n         return l2info.header_len;\n }\n", "target": 1, "idx": 181088}
{"func": "static Image *ReadJP2Image(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  const char\n    *option;\n\n  Image\n    *image;\n\n  int\n    jp2_status;\n\n  MagickBooleanType\n    status;\n\n  opj_codec_t\n    *jp2_codec;\n\n  opj_codestream_index_t\n    *codestream_index = (opj_codestream_index_t *) NULL;\n\n  opj_dparameters_t\n    parameters;\n\n  opj_image_t\n    *jp2_image;\n\n  opj_stream_t\n    *jp2_stream;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    y;\n\n  unsigned char\n    sans[4];\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Initialize JP2 codec.\n  */\n  if (ReadBlob(image,4,sans) != 4)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) SeekBlob(image,SEEK_SET,0);\n  if (LocaleCompare(image_info->magick,\"JPT\") == 0)\n    jp2_codec=opj_create_decompress(OPJ_CODEC_JPT);\n  else\n    if (IsJ2K(sans,4) != MagickFalse)\n      jp2_codec=opj_create_decompress(OPJ_CODEC_J2K);\n    else\n      jp2_codec=opj_create_decompress(OPJ_CODEC_JP2);\n  opj_set_warning_handler(jp2_codec,JP2WarningHandler,exception);\n  opj_set_error_handler(jp2_codec,JP2ErrorHandler,exception);\n  opj_set_default_decoder_parameters(&parameters);\n  option=GetImageOption(image_info,\"jp2:reduce-factor\");\n  if (option != (const char *) NULL)\n    parameters.cp_reduce=StringToInteger(option);\n  option=GetImageOption(image_info,\"jp2:quality-layers\");\n  if (option == (const char *) NULL)\n    option=GetImageOption(image_info,\"jp2:layer-number\");\n  if (option != (const char *) NULL)\n    parameters.cp_layer=StringToInteger(option);\n  if (opj_setup_decoder(jp2_codec,&parameters) == 0)\n    {\n      opj_destroy_codec(jp2_codec);\n      ThrowReaderException(DelegateError,\"UnableToManageJP2Stream\");\n    }\n  jp2_stream=opj_stream_create(OPJ_J2K_STREAM_CHUNK_SIZE,OPJ_TRUE);\n  opj_stream_set_read_function(jp2_stream,JP2ReadHandler);\n  opj_stream_set_write_function(jp2_stream,JP2WriteHandler);\n  opj_stream_set_seek_function(jp2_stream,JP2SeekHandler);\n  opj_stream_set_skip_function(jp2_stream,JP2SkipHandler);\n  opj_stream_set_user_data(jp2_stream,image,NULL);\n  opj_stream_set_user_data_length(jp2_stream,GetBlobSize(image));\n  if (opj_read_header(jp2_stream,jp2_codec,&jp2_image) == 0)\n    {\n      opj_stream_destroy(jp2_stream);\n      opj_destroy_codec(jp2_codec);\n      ThrowReaderException(DelegateError,\"UnableToDecodeImageFile\");\n    }\n  jp2_status=1;\n  if ((image->columns != 0) && (image->rows != 0))\n    {\n      /*\n        Extract an area from the image.\n      */\n      jp2_status=opj_set_decode_area(jp2_codec,jp2_image,\n        (OPJ_INT32) image->extract_info.x,(OPJ_INT32) image->extract_info.y,\n        (OPJ_INT32) image->extract_info.x+(ssize_t) image->columns,\n        (OPJ_INT32) image->extract_info.y+(ssize_t) image->rows);\n      if (jp2_status == 0)\n        {\n          opj_stream_destroy(jp2_stream);\n          opj_destroy_codec(jp2_codec);\n          opj_image_destroy(jp2_image);\n          ThrowReaderException(DelegateError,\"UnableToDecodeImageFile\");\n        }\n    }\n  if ((image_info->number_scenes != 0) && (image_info->scene != 0))\n    jp2_status=opj_get_decoded_tile(jp2_codec,jp2_stream,jp2_image,\n      (unsigned int) image_info->scene-1);\n  else\n    if (image->ping == MagickFalse)\n      {\n        jp2_status=opj_decode(jp2_codec,jp2_stream,jp2_image);\n        if (jp2_status != 0)\n          jp2_status=opj_end_decompress(jp2_codec,jp2_stream);\n      }\n  if (jp2_status == 0)\n    {\n      opj_stream_destroy(jp2_stream);\n      opj_destroy_codec(jp2_codec);\n      opj_image_destroy(jp2_image);\n      ThrowReaderException(DelegateError,\"UnableToDecodeImageFile\");\n    }\n  opj_stream_destroy(jp2_stream);\n  for (i=0; i < (ssize_t) jp2_image->numcomps; i++)\n  {\n    if ((jp2_image->comps[0].dx == 0) || (jp2_image->comps[0].dy == 0) ||\n         (jp2_image->comps[0].dx != jp2_image->comps[i].dx) ||\n         (jp2_image->comps[0].dy != jp2_image->comps[i].dy) ||\n         (jp2_image->comps[0].prec != jp2_image->comps[i].prec) ||\n        (jp2_image->comps[0].sgnd != jp2_image->comps[i].sgnd))\n       {\n         opj_destroy_codec(jp2_codec);\n         opj_image_destroy(jp2_image);\n        ThrowReaderException(CoderError,\"IrregularChannelGeometryNotSupported\")\n      }\n  }\n  /*\n    Convert JP2 image.\n  */\n  image->columns=(size_t) jp2_image->comps[0].w;\n  image->rows=(size_t) jp2_image->comps[0].h;\n  image->depth=jp2_image->comps[0].prec;\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  image->compression=JPEG2000Compression;\n  if (jp2_image->color_space == 2)\n    {\n      SetImageColorspace(image,GRAYColorspace);\n      if (jp2_image->numcomps > 1)\n        image->matte=MagickTrue;\n    }\n  else\n    if (jp2_image->color_space == 3)\n      SetImageColorspace(image,Rec601YCbCrColorspace);\n  if (jp2_image->numcomps > 3)\n    image->matte=MagickTrue;\n  if (jp2_image->icc_profile_buf != (unsigned char *) NULL)\n    {\n      StringInfo\n        *profile;\n\n      profile=BlobToStringInfo(jp2_image->icc_profile_buf,\n        jp2_image->icc_profile_len);\n      if (profile != (StringInfo *) NULL)\n        SetImageProfile(image,\"icc\",profile);\n    }\n  if (image->ping != MagickFalse)\n    {\n      opj_destroy_codec(jp2_codec);\n      opj_image_destroy(jp2_image);\n      opj_destroy_cstr_index(&codestream_index);\n      return(GetFirstImageInList(image));\n    }\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register PixelPacket\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      for (i=0; i < (ssize_t) jp2_image->numcomps; i++)\n      {\n        double\n          pixel,\n          scale;\n\n        scale=QuantumRange/(double) ((1UL << jp2_image->comps[i].prec)-1);\n        pixel=scale*(jp2_image->comps[i].data[y/jp2_image->comps[i].dy*\n          image->columns/jp2_image->comps[i].dx+x/jp2_image->comps[i].dx]+\n          (jp2_image->comps[i].sgnd ? 1UL << (jp2_image->comps[i].prec-1) : 0));\n        switch (i)\n        {\n           case 0:\n           {\n             q->red=ClampToQuantum(pixel);\n             q->green=q->red;\n             q->blue=q->red;\n             q->opacity=OpaqueOpacity;\n             break;\n           }\n           case 1:\n           {\n             if (jp2_image->numcomps == 2)\n               {\n                 q->opacity=ClampToQuantum(QuantumRange-pixel);\n                 break;\n               }\n             q->green=ClampToQuantum(pixel);\n             break;\n           }\n           case 2:\n           {\n             q->blue=ClampToQuantum(pixel);\n             break;\n           }\n           case 3:\n           {\n             q->opacity=ClampToQuantum(QuantumRange-pixel);\n             break;\n           }\n        }\n      }\n      q++;\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  /*\n    Free resources.\n  */\n  opj_destroy_codec(jp2_codec);\n  opj_image_destroy(jp2_image);\n  opj_destroy_cstr_index(&codestream_index);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n", "target": 1, "idx": 183196}
{"func": "static Image *ReadPICTImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n#define ThrowPICTException(exception,message) \\\n{ \\\n  if (tile_image != (Image *) NULL) \\\n    tile_image=DestroyImage(tile_image); \\\n  if (read_info != (ImageInfo *) NULL) \\\n    read_info=DestroyImageInfo(read_info); \\\n  ThrowReaderException((exception),(message)); \\\n}\n\n  char\n    geometry[MagickPathExtent],\n    header_ole[4];\n\n  Image\n    *image,\n    *tile_image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    code;\n\n  MagickBooleanType\n    jpeg,\n    status;\n\n  PICTRectangle\n    frame;\n\n  PICTPixmap\n    pixmap;\n\n  Quantum\n    index;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  size_t\n    extent,\n    length;\n\n  ssize_t\n    count,\n    flags,\n    j,\n    version,\n    y;\n\n  StringInfo\n    *profile;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read PICT header.\n  */\n  read_info=(ImageInfo *) NULL;\n  tile_image=(Image *) NULL;\n  pixmap.bits_per_pixel=0;\n  pixmap.component_count=0;\n  /*\n    Skip header : 512 for standard PICT and 4, ie \"PICT\" for OLE2.\n  */\n  header_ole[0]=ReadBlobByte(image);\n  header_ole[1]=ReadBlobByte(image);\n  header_ole[2]=ReadBlobByte(image);\n  header_ole[3]=ReadBlobByte(image);\n  if (!((header_ole[0] == 0x50) && (header_ole[1] == 0x49) &&\n      (header_ole[2] == 0x43) && (header_ole[3] == 0x54 )))\n    for (i=0; i < 508; i++)\n      if (ReadBlobByte(image) == EOF)\n        break;\n  (void) ReadBlobMSBShort(image);  /* skip picture size */\n  if (ReadRectangle(image,&frame) == MagickFalse)\n    ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n  while ((c=ReadBlobByte(image)) == 0) ;\n  if (c != 0x11)\n    ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n  version=(ssize_t) ReadBlobByte(image);\n  if (version == 2)\n    {\n      c=ReadBlobByte(image);\n      if (c != 0xff)\n        ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  else\n    if (version != 1)\n      ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n  if ((frame.left < 0) || (frame.right < 0) || (frame.top < 0) ||\n      (frame.bottom < 0) || (frame.left >= frame.right) ||\n      (frame.top >= frame.bottom))\n    ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n  /*\n    Create black canvas.\n  */\n  flags=0;\n  image->depth=8;\n  image->columns=(size_t) (frame.right-frame.left);\n  image->rows=(size_t) (frame.bottom-frame.top);\n  image->resolution.x=DefaultResolution;\n  image->resolution.y=DefaultResolution;\n  image->units=UndefinedResolution;\n  if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n    if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n      {\n        (void) CloseBlob(image);\n        return(GetFirstImageInList(image));\n      }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status != MagickFalse)\n    status=ResetImagePixels(image,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Interpret PICT opcodes.\n  */\n  jpeg=MagickFalse;\n  for (code=0; EOFBlob(image) == MagickFalse; )\n  {\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if ((version == 1) || ((TellBlob(image) % 2) != 0))\n      code=ReadBlobByte(image);\n    if (version == 2)\n      code=ReadBlobMSBSignedShort(image);\n    if (code < 0)\n      break;\n    if (code == 0)\n      continue;\n    if (code > 0xa1)\n      {\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"%04X:\",code);\n      }\n    else\n      {\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  %04X %s: %s\",code,codes[code].name,codes[code].description);\n        switch (code)\n        {\n          case 0x01:\n          {\n            /*\n              Clipping rectangle.\n            */\n            length=ReadBlobMSBShort(image);\n            if (length != 0x000a)\n              {\n                for (i=0; i < (ssize_t) (length-2); i++)\n                  if (ReadBlobByte(image) == EOF)\n                    break;\n                break;\n              }\n            if (ReadRectangle(image,&frame) == MagickFalse)\n              ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n            if (((frame.left & 0x8000) != 0) || ((frame.top & 0x8000) != 0))\n              break;\n            image->columns=(size_t) (frame.right-frame.left);\n            image->rows=(size_t) (frame.bottom-frame.top);\n            status=SetImageExtent(image,image->columns,image->rows,exception);\n            if (status != MagickFalse)\n              status=ResetImagePixels(image,exception);\n            if (status == MagickFalse)\n              return(DestroyImageList(image));\n            break;\n          }\n          case 0x12:\n          case 0x13:\n          case 0x14:\n          {\n            ssize_t\n              pattern;\n\n            size_t\n              height,\n              width;\n\n            /*\n              Skip pattern definition.\n            */\n            pattern=(ssize_t) ReadBlobMSBShort(image);\n            for (i=0; i < 8; i++)\n              if (ReadBlobByte(image) == EOF)\n                break;\n            if (pattern == 2)\n              {\n                for (i=0; i < 5; i++)\n                  if (ReadBlobByte(image) == EOF)\n                    break;\n                break;\n              }\n            if (pattern != 1)\n              ThrowPICTException(CorruptImageError,\"UnknownPatternType\");\n            length=ReadBlobMSBShort(image);\n            if (ReadRectangle(image,&frame) == MagickFalse)\n              ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n            if (ReadPixmap(image,&pixmap) == MagickFalse)\n              ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n            image->depth=(size_t) pixmap.component_size;\n            image->resolution.x=1.0*pixmap.horizontal_resolution;\n            image->resolution.y=1.0*pixmap.vertical_resolution;\n            image->units=PixelsPerInchResolution;\n            (void) ReadBlobMSBLong(image);\n            flags=(ssize_t) ReadBlobMSBShort(image);\n            length=ReadBlobMSBShort(image);\n            for (i=0; i <= (ssize_t) length; i++)\n              (void) ReadBlobMSBLong(image);\n            width=(size_t) (frame.bottom-frame.top);\n            height=(size_t) (frame.right-frame.left);\n            if (pixmap.bits_per_pixel <= 8)\n              length&=0x7fff;\n            if (pixmap.bits_per_pixel == 16)\n              width<<=1;\n            if (length == 0)\n              length=width;\n            if (length < 8)\n              {\n                for (i=0; i < (ssize_t) (length*height); i++)\n                  if (ReadBlobByte(image) == EOF)\n                    break;\n              }\n            else\n              for (i=0; i < (ssize_t) height; i++)\n              {\n                if (EOFBlob(image) != MagickFalse)\n                  break;\n                if (length > 200)\n                  {\n                    for (j=0; j < (ssize_t) ReadBlobMSBShort(image); j++)\n                      if (ReadBlobByte(image) == EOF)\n                        break;\n                  }\n                else\n                  for (j=0; j < (ssize_t) ReadBlobByte(image); j++)\n                    if (ReadBlobByte(image) == EOF)\n                      break;\n              }\n            break;\n          }\n          case 0x1b:\n          {\n            /*\n              Initialize image background color.\n            */\n            image->background_color.red=(Quantum)\n              ScaleShortToQuantum(ReadBlobMSBShort(image));\n            image->background_color.green=(Quantum)\n              ScaleShortToQuantum(ReadBlobMSBShort(image));\n            image->background_color.blue=(Quantum)\n              ScaleShortToQuantum(ReadBlobMSBShort(image));\n            break;\n          }\n          case 0x70:\n          case 0x71:\n          case 0x72:\n          case 0x73:\n          case 0x74:\n          case 0x75:\n          case 0x76:\n          case 0x77:\n          {\n            /*\n              Skip polygon or region.\n            */\n            length=ReadBlobMSBShort(image);\n            for (i=0; i < (ssize_t) (length-2); i++)\n              if (ReadBlobByte(image) == EOF)\n                break;\n            break;\n          }\n          case 0x90:\n          case 0x91:\n          case 0x98:\n          case 0x99:\n          case 0x9a:\n          case 0x9b:\n          {\n            PICTRectangle\n              source,\n              destination;\n\n            register unsigned char\n              *p;\n\n            size_t\n              j;\n\n            ssize_t\n              bytes_per_line;\n\n            unsigned char\n              *pixels;\n\n            /*\n              Pixmap clipped by a rectangle.\n            */\n            bytes_per_line=0;\n            if ((code != 0x9a) && (code != 0x9b))\n              bytes_per_line=(ssize_t) ReadBlobMSBShort(image);\n            else\n              {\n                (void) ReadBlobMSBShort(image);\n                (void) ReadBlobMSBShort(image);\n                (void) ReadBlobMSBShort(image);\n              }\n            if (ReadRectangle(image,&frame) == MagickFalse)\n              ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n            /*\n              Initialize tile image.\n            */\n            tile_image=CloneImage(image,(size_t) (frame.right-frame.left),\n              (size_t) (frame.bottom-frame.top),MagickTrue,exception);\n            if (tile_image == (Image *) NULL)\n              ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n            if ((code == 0x9a) || (code == 0x9b) ||\n                ((bytes_per_line & 0x8000) != 0))\n              {\n                if (ReadPixmap(image,&pixmap) == MagickFalse)\n                  ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n                tile_image->depth=(size_t) pixmap.component_size;\n                tile_image->alpha_trait=pixmap.component_count == 4 ?\n                  BlendPixelTrait : UndefinedPixelTrait;\n                tile_image->resolution.x=(double) pixmap.horizontal_resolution;\n                tile_image->resolution.y=(double) pixmap.vertical_resolution;\n                tile_image->units=PixelsPerInchResolution;\n                if (tile_image->alpha_trait != UndefinedPixelTrait)\n                  (void) SetImageAlpha(tile_image,OpaqueAlpha,exception);\n              }\n            if ((code != 0x9a) && (code != 0x9b))\n              {\n                /*\n                  Initialize colormap.\n                */\n                tile_image->colors=2;\n                if ((bytes_per_line & 0x8000) != 0)\n                  {\n                    (void) ReadBlobMSBLong(image);\n                    flags=(ssize_t) ReadBlobMSBShort(image);\n                    tile_image->colors=1UL*ReadBlobMSBShort(image)+1;\n                  }\n                status=AcquireImageColormap(tile_image,tile_image->colors,\n                  exception);\n                if (status == MagickFalse)\n                  ThrowPICTException(ResourceLimitError,\n                    \"MemoryAllocationFailed\");\n                if ((bytes_per_line & 0x8000) != 0)\n                  {\n                    for (i=0; i < (ssize_t) tile_image->colors; i++)\n                    {\n                      j=ReadBlobMSBShort(image) % tile_image->colors;\n                      if ((flags & 0x8000) != 0)\n                        j=(size_t) i;\n                      tile_image->colormap[j].red=(Quantum)\n                        ScaleShortToQuantum(ReadBlobMSBShort(image));\n                      tile_image->colormap[j].green=(Quantum)\n                        ScaleShortToQuantum(ReadBlobMSBShort(image));\n                      tile_image->colormap[j].blue=(Quantum)\n                        ScaleShortToQuantum(ReadBlobMSBShort(image));\n                    }\n                  }\n                else\n                  {\n                    for (i=0; i < (ssize_t) tile_image->colors; i++)\n                    {\n                      tile_image->colormap[i].red=(Quantum) (QuantumRange-\n                        tile_image->colormap[i].red);\n                      tile_image->colormap[i].green=(Quantum) (QuantumRange-\n                        tile_image->colormap[i].green);\n                      tile_image->colormap[i].blue=(Quantum) (QuantumRange-\n                        tile_image->colormap[i].blue);\n                    }\n                  }\n              }\n            if (EOFBlob(image) != MagickFalse)\n              ThrowPICTException(CorruptImageError,\n                \"InsufficientImageDataInFile\");\n            if (ReadRectangle(image,&source) == MagickFalse)\n              ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n            if (ReadRectangle(image,&destination) == MagickFalse)\n              ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n            (void) ReadBlobMSBShort(image);\n            if ((code == 0x91) || (code == 0x99) || (code == 0x9b))\n              {\n                /*\n                  Skip region.\n                */\n                length=ReadBlobMSBShort(image);\n                for (i=0; i < (ssize_t) (length-2); i++)\n                  if (ReadBlobByte(image) == EOF)\n                    break;\n              }\n            if ((code != 0x9a) && (code != 0x9b) &&\n                (bytes_per_line & 0x8000) == 0)\n              pixels=DecodeImage(image,tile_image,(size_t) bytes_per_line,1,\n                &extent);\n            else\n              pixels=DecodeImage(image,tile_image,(size_t) bytes_per_line,\n                (unsigned int) pixmap.bits_per_pixel,&extent);\n            if (pixels == (unsigned char *) NULL)\n              ThrowPICTException(CorruptImageError,\"UnableToUncompressImage\");\n            /*\n              Convert PICT tile image to pixel packets.\n            */\n            p=pixels;\n            for (y=0; y < (ssize_t) tile_image->rows; y++)\n            {\n              if (p > (pixels+extent+image->columns))\n                {\n                  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n                  ThrowPICTException(CorruptImageError,\"NotEnoughPixelData\");\n                }\n              q=QueueAuthenticPixels(tile_image,0,y,tile_image->columns,1,\n                exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) tile_image->columns; x++)\n              {\n                if (tile_image->storage_class == PseudoClass)\n                  {\n                    index=(Quantum) ConstrainColormapIndex(tile_image,(ssize_t)\n                      *p,exception);\n                    SetPixelIndex(tile_image,index,q);\n                    SetPixelRed(tile_image,\n                      tile_image->colormap[(ssize_t) index].red,q);\n                    SetPixelGreen(tile_image,\n                      tile_image->colormap[(ssize_t) index].green,q);\n                    SetPixelBlue(tile_image,\n                      tile_image->colormap[(ssize_t) index].blue,q);\n                  }\n                else\n                  {\n                    if (pixmap.bits_per_pixel == 16)\n                      {\n                        i=(ssize_t) (*p++);\n                        j=(size_t) (*p);\n                        SetPixelRed(tile_image,ScaleCharToQuantum(\n                          (unsigned char) ((i & 0x7c) << 1)),q);\n                        SetPixelGreen(tile_image,ScaleCharToQuantum(\n                          (unsigned char) (((i & 0x03) << 6) |\n                          ((j & 0xe0) >> 2))),q);\n                        SetPixelBlue(tile_image,ScaleCharToQuantum(\n                          (unsigned char) ((j & 0x1f) << 3)),q);\n                      }\n                    else\n                      if (tile_image->alpha_trait == UndefinedPixelTrait)\n                        {\n                          if (p > (pixels+extent+2*image->columns))\n                            ThrowPICTException(CorruptImageError,\n                              \"NotEnoughPixelData\");\n                          SetPixelRed(tile_image,ScaleCharToQuantum(*p),q);\n                          SetPixelGreen(tile_image,ScaleCharToQuantum(\n                            *(p+tile_image->columns)),q);\n                          SetPixelBlue(tile_image,ScaleCharToQuantum(\n                            *(p+2*tile_image->columns)),q);\n                        }\n                      else\n                        {\n                          if (p > (pixels+extent+3*image->columns))\n                            ThrowPICTException(CorruptImageError,\n                              \"NotEnoughPixelData\");\n                          SetPixelAlpha(tile_image,ScaleCharToQuantum(*p),q);\n                          SetPixelRed(tile_image,ScaleCharToQuantum(\n                            *(p+tile_image->columns)),q);\n                          SetPixelGreen(tile_image,ScaleCharToQuantum(\n                            *(p+2*tile_image->columns)),q);\n                          SetPixelBlue(tile_image,ScaleCharToQuantum(\n                            *(p+3*tile_image->columns)),q);\n                        }\n                  }\n                p++;\n                q+=GetPixelChannels(tile_image);\n              }\n              if (SyncAuthenticPixels(tile_image,exception) == MagickFalse)\n                break;\n              if ((tile_image->storage_class == DirectClass) &&\n                  (pixmap.bits_per_pixel != 16))\n                {\n                  p+=(pixmap.component_count-1)*tile_image->columns;\n                  if (p < pixels)\n                    break;\n                }\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                tile_image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n            pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n            if ((jpeg == MagickFalse) && (EOFBlob(image) == MagickFalse))\n              if ((code == 0x9a) || (code == 0x9b) ||\n                  ((bytes_per_line & 0x8000) != 0))\n                (void) CompositeImage(image,tile_image,CopyCompositeOp,\n                  MagickTrue,(ssize_t) destination.left,(ssize_t)\n                  destination.top,exception);\n            tile_image=DestroyImage(tile_image);\n            break;\n          }\n          case 0xa1:\n          {\n            unsigned char\n              *info;\n\n            size_t\n              type;\n\n            /*\n              Comment.\n            */\n            type=ReadBlobMSBShort(image);\n            length=ReadBlobMSBShort(image);\n            if (length == 0)\n              break;\n            (void) ReadBlobMSBLong(image);\n            length-=MagickMin(length,4);\n            if (length == 0)\n              break;\n            info=(unsigned char *) AcquireQuantumMemory(length,sizeof(*info));\n            if (info == (unsigned char *) NULL)\n              break;\n            count=ReadBlob(image,length,info);\n            if (count != (ssize_t) length)\n              {\n                info=(unsigned char *) RelinquishMagickMemory(info);\n                ThrowPICTException(ResourceLimitError,\"UnableToReadImageData\");\n              }\n            switch (type)\n            {\n              case 0xe0:\n              {\n                profile=BlobToStringInfo((const void *) NULL,length);\n                SetStringInfoDatum(profile,info);\n                status=SetImageProfile(image,\"icc\",profile,exception);\n                profile=DestroyStringInfo(profile);\n                if (status == MagickFalse)\n                  {\n                    info=(unsigned char *) RelinquishMagickMemory(info);\n                    ThrowPICTException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                  }\n                break;\n              }\n              case 0x1f2:\n              {\n                profile=BlobToStringInfo((const void *) NULL,length);\n                SetStringInfoDatum(profile,info);\n                status=SetImageProfile(image,\"iptc\",profile,exception);\n                if (status == MagickFalse)\n                  {\n                    info=(unsigned char *) RelinquishMagickMemory(info);\n                    ThrowPICTException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                  }\n                profile=DestroyStringInfo(profile);\n                break;\n              }\n              default:\n                break;\n            }\n            info=(unsigned char *) RelinquishMagickMemory(info);\n            break;\n          }\n          default:\n          {\n            /*\n              Skip to next op code.\n            */\n            if (codes[code].length == -1)\n              (void) ReadBlobMSBShort(image);\n            else\n              for (i=0; i < (ssize_t) codes[code].length; i++)\n                if (ReadBlobByte(image) == EOF)\n                  break;\n          }\n        }\n      }\n    if (code == 0xc00)\n      {\n        /*\n          Skip header.\n        */\n        for (i=0; i < 24; i++)\n          if (ReadBlobByte(image) == EOF)\n            break;\n        continue;\n      }\n    if (((code >= 0xb0) && (code <= 0xcf)) ||\n        ((code >= 0x8000) && (code <= 0x80ff)))\n      continue;\n    if (code == 0x8200)\n      {\n        char\n          filename[MaxTextExtent];\n\n        FILE\n          *file;\n\n        int\n          unique_file;\n\n        /*\n          Embedded JPEG.\n        */\n        jpeg=MagickTrue;\n        read_info=CloneImageInfo(image_info);\n        SetImageInfoBlob(read_info,(void *) NULL,0);\n        file=(FILE *) NULL;\n        unique_file=AcquireUniqueFileResource(filename);\n        (void) FormatLocaleString(read_info->filename,MaxTextExtent,\"jpeg:%s\",\n          filename);\n        if (unique_file != -1)\n          file=fdopen(unique_file,\"wb\");\n        if ((unique_file == -1) || (file == (FILE *) NULL))\n          {\n            (void) RelinquishUniqueFileResource(read_info->filename);\n            (void) CopyMagickString(image->filename,read_info->filename,\n              MagickPathExtent);\n            ThrowPICTException(FileOpenError,\"UnableToCreateTemporaryFile\");\n          }\n        length=ReadBlobMSBLong(image);\n        if (length > 154)\n          {\n            for (i=0; i < 6; i++)\n              (void) ReadBlobMSBLong(image);\n            if (ReadRectangle(image,&frame) == MagickFalse)\n              {\n                (void) fclose(file);\n                (void) RelinquishUniqueFileResource(read_info->filename);\n                ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n              }\n            for (i=0; i < 122; i++)\n              if (ReadBlobByte(image) == EOF)\n                break;\n            for (i=0; i < (ssize_t) (length-154); i++)\n            {\n               c=ReadBlobByte(image);\n               if (c == EOF)\n                 break;\n              (void) fputc(c,file);\n             }\n           }\n         (void) fclose(file);\n        (void) close(unique_file);\n        tile_image=ReadImage(read_info,exception);\n        (void) RelinquishUniqueFileResource(filename);\n        read_info=DestroyImageInfo(read_info);\n        if (tile_image == (Image *) NULL)\n          continue;\n        (void) FormatLocaleString(geometry,MagickPathExtent,\"%.20gx%.20g\",\n          (double) MagickMax(image->columns,tile_image->columns),\n          (double) MagickMax(image->rows,tile_image->rows));\n        (void) SetImageExtent(image,\n          MagickMax(image->columns,tile_image->columns),\n          MagickMax(image->rows,tile_image->rows),exception);\n        (void) TransformImageColorspace(image,tile_image->colorspace,exception);\n        (void) CompositeImage(image,tile_image,CopyCompositeOp,MagickTrue,\n          (ssize_t) frame.left,(ssize_t) frame.right,exception);\n        image->compression=tile_image->compression;\n        tile_image=DestroyImage(tile_image);\n        continue;\n      }\n    if ((code == 0xff) || (code == 0xffff))\n      break;\n    if (((code >= 0xd0) && (code <= 0xfe)) ||\n        ((code >= 0x8100) && (code <= 0xffff)))\n      {\n        /*\n          Skip reserved.\n        */\n        length=ReadBlobMSBShort(image);\n        for (i=0; i < (ssize_t) length; i++)\n          if (ReadBlobByte(image) == EOF)\n            break;\n        continue;\n      }\n    if ((code >= 0x100) && (code <= 0x7fff))\n      {\n        /*\n          Skip reserved.\n        */\n        length=(size_t) ((code >> 7) & 0xff);\n        for (i=0; i < (ssize_t) length; i++)\n          if (ReadBlobByte(image) == EOF)\n            break;\n        continue;\n      }\n  }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n", "target": 1, "idx": 182212}
{"func": "void Browser::RemoveScheduledUpdatesFor(WebContents* contents) {\n  if (!contents)\n    return;\n\n  UpdateMap::iterator i = scheduled_updates_.find(contents);\n  if (i != scheduled_updates_.end())\n    scheduled_updates_.erase(i);\n}\n", "target": 0, "idx": 126224}
{"func": "int XfrmController::fillUserTemplate(const XfrmSaInfo& record, xfrm_user_tmpl* tmpl) {\n    tmpl->id.daddr = record.dstAddr;\n    tmpl->id.spi = record.spi;\n    tmpl->id.proto = IPPROTO_ESP;\n\n    tmpl->family = record.addrFamily;\n    tmpl->saddr = record.srcAddr;\n    tmpl->reqid = record.transformId;\n    tmpl->mode = static_cast<uint8_t>(record.mode);\n    tmpl->share = XFRM_SHARE_UNIQUE;\n    tmpl->optional = 0; // if this is true, then a failed state lookup will be considered OK:\n    tmpl->aalgos = ALGO_MASK_AUTH_ALL; // TODO: if there's a bitmask somewhere of\n    tmpl->ealgos = ALGO_MASK_CRYPT_ALL; // TODO: if there's a bitmask somewhere...\n return sizeof(xfrm_user_tmpl*);\n}\n", "target": 0, "idx": 175875}
{"func": "juniper_parse_header(netdissect_options *ndo,\n                     const u_char *p, const struct pcap_pkthdr *h, struct juniper_l2info_t *l2info)\n{\n    const struct juniper_cookie_table_t *lp = juniper_cookie_table;\n    u_int idx, jnx_ext_len, jnx_header_len = 0;\n    uint8_t tlv_type,tlv_len;\n    uint32_t control_word;\n    int tlv_value;\n    const u_char *tptr;\n\n\n    l2info->header_len = 0;\n    l2info->cookie_len = 0;\n    l2info->proto = 0;\n\n\n    l2info->length = h->len;\n    l2info->caplen = h->caplen;\n    ND_TCHECK2(p[0], 4);\n    l2info->flags = p[3];\n    l2info->direction = p[3]&JUNIPER_BPF_PKT_IN;\n\n    if (EXTRACT_24BITS(p) != JUNIPER_MGC_NUMBER) { /* magic number found ? */\n        ND_PRINT((ndo, \"no magic-number found!\"));\n        return 0;\n    }\n\n    if (ndo->ndo_eflag) /* print direction */\n        ND_PRINT((ndo, \"%3s \", tok2str(juniper_direction_values, \"---\", l2info->direction)));\n\n    /* magic number + flags */\n    jnx_header_len = 4;\n\n    if (ndo->ndo_vflag > 1)\n        ND_PRINT((ndo, \"\\n\\tJuniper PCAP Flags [%s]\",\n               bittok2str(jnx_flag_values, \"none\", l2info->flags)));\n\n    /* extensions present ?  - calculate how much bytes to skip */\n    if ((l2info->flags & JUNIPER_BPF_EXT ) == JUNIPER_BPF_EXT ) {\n\n        tptr = p+jnx_header_len;\n\n        /* ok to read extension length ? */\n        ND_TCHECK2(tptr[0], 2);\n        jnx_ext_len = EXTRACT_16BITS(tptr);\n        jnx_header_len += 2;\n        tptr +=2;\n\n        /* nail up the total length -\n         * just in case something goes wrong\n         * with TLV parsing */\n        jnx_header_len += jnx_ext_len;\n\n        if (ndo->ndo_vflag > 1)\n            ND_PRINT((ndo, \", PCAP Extension(s) total length %u\", jnx_ext_len));\n\n        ND_TCHECK2(tptr[0], jnx_ext_len);\n        while (jnx_ext_len > JUNIPER_EXT_TLV_OVERHEAD) {\n            tlv_type = *(tptr++);\n            tlv_len = *(tptr++);\n            tlv_value = 0;\n\n            /* sanity checks */\n            if (tlv_type == 0 || tlv_len == 0)\n                break;\n            if (tlv_len+JUNIPER_EXT_TLV_OVERHEAD > jnx_ext_len)\n                goto trunc;\n\n            if (ndo->ndo_vflag > 1)\n                ND_PRINT((ndo, \"\\n\\t  %s Extension TLV #%u, length %u, value \",\n                       tok2str(jnx_ext_tlv_values,\"Unknown\",tlv_type),\n                       tlv_type,\n                       tlv_len));\n\n            tlv_value = juniper_read_tlv_value(tptr, tlv_type, tlv_len);\n            switch (tlv_type) {\n            case JUNIPER_EXT_TLV_IFD_NAME:\n                /* FIXME */\n                break;\n            case JUNIPER_EXT_TLV_IFD_MEDIATYPE:\n            case JUNIPER_EXT_TLV_TTP_IFD_MEDIATYPE:\n                if (tlv_value != -1) {\n                    if (ndo->ndo_vflag > 1)\n                        ND_PRINT((ndo, \"%s (%u)\",\n                               tok2str(juniper_ifmt_values, \"Unknown\", tlv_value),\n                               tlv_value));\n                }\n                break;\n            case JUNIPER_EXT_TLV_IFL_ENCAPS:\n            case JUNIPER_EXT_TLV_TTP_IFL_ENCAPS:\n                if (tlv_value != -1) {\n                    if (ndo->ndo_vflag > 1)\n                        ND_PRINT((ndo, \"%s (%u)\",\n                               tok2str(juniper_ifle_values, \"Unknown\", tlv_value),\n                               tlv_value));\n                }\n                break;\n            case JUNIPER_EXT_TLV_IFL_IDX: /* fall through */\n            case JUNIPER_EXT_TLV_IFL_UNIT:\n            case JUNIPER_EXT_TLV_IFD_IDX:\n            default:\n                if (tlv_value != -1) {\n                    if (ndo->ndo_vflag > 1)\n                        ND_PRINT((ndo, \"%u\", tlv_value));\n                }\n                break;\n            }\n\n            tptr+=tlv_len;\n            jnx_ext_len -= tlv_len+JUNIPER_EXT_TLV_OVERHEAD;\n        }\n\n        if (ndo->ndo_vflag > 1)\n            ND_PRINT((ndo, \"\\n\\t-----original packet-----\\n\\t\"));\n    }\n\n    if ((l2info->flags & JUNIPER_BPF_NO_L2 ) == JUNIPER_BPF_NO_L2 ) {\n        if (ndo->ndo_eflag)\n            ND_PRINT((ndo, \"no-L2-hdr, \"));\n\n        /* there is no link-layer present -\n         * perform the v4/v6 heuristics\n         * to figure out what it is\n         */\n        ND_TCHECK2(p[jnx_header_len + 4], 1);\n        if (ip_heuristic_guess(ndo, p + jnx_header_len + 4,\n                               l2info->length - (jnx_header_len + 4)) == 0)\n            ND_PRINT((ndo, \"no IP-hdr found!\"));\n\n        l2info->header_len=jnx_header_len+4;\n        return 0; /* stop parsing the output further */\n\n    }\n    l2info->header_len = jnx_header_len;\n    p+=l2info->header_len;\n    l2info->length -= l2info->header_len;\n    l2info->caplen -= l2info->header_len;\n\n    /* search through the cookie table and copy values matching for our PIC type */\n    ND_TCHECK(p[0]);\n    while (lp->s != NULL) {\n        if (lp->pictype == l2info->pictype) {\n\n            l2info->cookie_len += lp->cookie_len;\n\n            switch (p[0]) {\n            case LS_COOKIE_ID:\n                l2info->cookie_type = LS_COOKIE_ID;\n                l2info->cookie_len += 2;\n                break;\n            case AS_COOKIE_ID:\n                l2info->cookie_type = AS_COOKIE_ID;\n                l2info->cookie_len = 8;\n                break;\n\n            default:\n                l2info->bundle = l2info->cookie[0];\n                break;\n            }\n\n\n#ifdef DLT_JUNIPER_MFR\n            /* MFR child links don't carry cookies */\n            if (l2info->pictype == DLT_JUNIPER_MFR &&\n                (p[0] & MFR_BE_MASK) == MFR_BE_MASK) {\n                l2info->cookie_len = 0;\n            }\n#endif\n\n            l2info->header_len += l2info->cookie_len;\n            l2info->length -= l2info->cookie_len;\n            l2info->caplen -= l2info->cookie_len;\n\n            if (ndo->ndo_eflag)\n                ND_PRINT((ndo, \"%s-PIC, cookie-len %u\",\n                       lp->s,\n                       l2info->cookie_len));\n\n            if (l2info->cookie_len > 0) {\n                ND_TCHECK2(p[0], l2info->cookie_len);\n                if (ndo->ndo_eflag)\n                    ND_PRINT((ndo, \", cookie 0x\"));\n                for (idx = 0; idx < l2info->cookie_len; idx++) {\n                    l2info->cookie[idx] = p[idx]; /* copy cookie data */\n                    if (ndo->ndo_eflag) ND_PRINT((ndo, \"%02x\", p[idx]));\n                }\n            }\n\n             if (ndo->ndo_eflag) ND_PRINT((ndo, \": \")); /* print demarc b/w L2/L3*/\n \n \n             l2info->proto = EXTRACT_16BITS(p+l2info->cookie_len);\n             break;\n         }\n        ++lp;\n    }\n    p+=l2info->cookie_len;\n\n    /* DLT_ specific parsing */\n    switch(l2info->pictype) {\n#ifdef DLT_JUNIPER_MLPPP\n    case DLT_JUNIPER_MLPPP:\n        switch (l2info->cookie_type) {\n        case LS_COOKIE_ID:\n            l2info->bundle = l2info->cookie[1];\n            break;\n        case AS_COOKIE_ID:\n            l2info->bundle = (EXTRACT_16BITS(&l2info->cookie[6])>>3)&0xfff;\n            l2info->proto = (l2info->cookie[5])&JUNIPER_LSQ_L3_PROTO_MASK;\n            break;\n        default:\n            l2info->bundle = l2info->cookie[0];\n            break;\n        }\n        break;\n#endif\n#ifdef DLT_JUNIPER_MLFR\n    case DLT_JUNIPER_MLFR:\n        switch (l2info->cookie_type) {\n        case LS_COOKIE_ID:\n            ND_TCHECK2(p[0], 2);\n            l2info->bundle = l2info->cookie[1];\n            l2info->proto = EXTRACT_16BITS(p);\n            l2info->header_len += 2;\n            l2info->length -= 2;\n            l2info->caplen -= 2;\n            break;\n        case AS_COOKIE_ID:\n            l2info->bundle = (EXTRACT_16BITS(&l2info->cookie[6])>>3)&0xfff;\n            l2info->proto = (l2info->cookie[5])&JUNIPER_LSQ_L3_PROTO_MASK;\n            break;\n        default:\n            l2info->bundle = l2info->cookie[0];\n            l2info->header_len += 2;\n            l2info->length -= 2;\n            l2info->caplen -= 2;\n            break;\n        }\n        break;\n#endif\n#ifdef DLT_JUNIPER_MFR\n    case DLT_JUNIPER_MFR:\n        switch (l2info->cookie_type) {\n        case LS_COOKIE_ID:\n            ND_TCHECK2(p[0], 2);\n            l2info->bundle = l2info->cookie[1];\n            l2info->proto = EXTRACT_16BITS(p);\n            l2info->header_len += 2;\n            l2info->length -= 2;\n            l2info->caplen -= 2;\n            break;\n        case AS_COOKIE_ID:\n            l2info->bundle = (EXTRACT_16BITS(&l2info->cookie[6])>>3)&0xfff;\n            l2info->proto = (l2info->cookie[5])&JUNIPER_LSQ_L3_PROTO_MASK;\n            break;\n        default:\n            l2info->bundle = l2info->cookie[0];\n            break;\n        }\n        break;\n#endif\n#ifdef DLT_JUNIPER_ATM2\n    case DLT_JUNIPER_ATM2:\n        ND_TCHECK2(p[0], 4);\n        /* ATM cell relay control word present ? */\n        if (l2info->cookie[7] & ATM2_PKT_TYPE_MASK) {\n            control_word = EXTRACT_32BITS(p);\n            /* some control word heuristics */\n            switch(control_word) {\n            case 0: /* zero control word */\n            case 0x08000000: /* < JUNOS 7.4 control-word */\n            case 0x08380000: /* cntl word plus cell length (56) >= JUNOS 7.4*/\n                l2info->header_len += 4;\n                break;\n            default:\n                break;\n            }\n\n            if (ndo->ndo_eflag)\n                ND_PRINT((ndo, \"control-word 0x%08x \", control_word));\n        }\n        break;\n#endif\n#ifdef DLT_JUNIPER_GGSN\n    case DLT_JUNIPER_GGSN:\n        break;\n#endif\n#ifdef DLT_JUNIPER_ATM1\n    case DLT_JUNIPER_ATM1:\n        break;\n#endif\n#ifdef DLT_JUNIPER_PPP\n    case DLT_JUNIPER_PPP:\n        break;\n#endif\n#ifdef DLT_JUNIPER_CHDLC\n    case DLT_JUNIPER_CHDLC:\n        break;\n#endif\n#ifdef DLT_JUNIPER_ETHER\n    case DLT_JUNIPER_ETHER:\n        break;\n#endif\n#ifdef DLT_JUNIPER_FRELAY\n    case DLT_JUNIPER_FRELAY:\n        break;\n#endif\n\n    default:\n        ND_PRINT((ndo, \"Unknown Juniper DLT_ type %u: \", l2info->pictype));\n        break;\n    }\n\n    if (ndo->ndo_eflag > 1)\n        ND_PRINT((ndo, \"hlen %u, proto 0x%04x, \", l2info->header_len, l2info->proto));\n\n    return 1; /* everything went ok so far. continue parsing */\n trunc:\n    ND_PRINT((ndo, \"[|juniper_hdr], length %u\", h->len));\n    return 0;\n}\n", "target": 1, "idx": 183200}
{"func": "  static Child* Create() { return new Child(); }\n", "target": 0, "idx": 166803}
{"func": "bool WebContext::setDefaultVideoCaptureDeviceId(const QString& id) {\n  if (IsInitialized()) {\n    return MediaCaptureDevicesContext::Get(context_.get())\n        ->SetDefaultVideoDeviceId(id.toStdString());\n  }\n\n  construct_props_->default_video_capture_device_id = id.toStdString();\n  client_->DefaultVideoCaptureDeviceChanged();\n  return true;\n}\n", "target": 0, "idx": 17003}
{"func": "static bool nested_exit_on_nmi(struct kvm_vcpu *vcpu)\n{\n\treturn nested_cpu_has_nmi_exiting(get_vmcs12(vcpu));\n}\n", "target": 0, "idx": 80978}
{"func": "void fz_drop_colorspace_context(fz_context *ctx)\n{\n\tif (!ctx)\n\t\treturn;\n\tif (fz_drop_imp(ctx, ctx->colorspace, &ctx->colorspace->ctx_refs))\n\t{\n\t\tfz_drop_colorspace(ctx, ctx->colorspace->gray);\n\t\tfz_drop_colorspace(ctx, ctx->colorspace->rgb);\n\t\tfz_drop_colorspace(ctx, ctx->colorspace->bgr);\n\t\tfz_drop_colorspace(ctx, ctx->colorspace->cmyk);\n\t\tfz_drop_colorspace(ctx, ctx->colorspace->lab);\n\t\tfz_drop_cmm_context(ctx);\n\t\tfz_free(ctx, ctx->colorspace);\n\t\tctx->colorspace = NULL;\n\t}\n}\n", "target": 0, "idx": 368}
{"func": "  void Verify_StoreExistingGroupExistingCache(base::Time expected_update_time) {\n    EXPECT_TRUE(delegate()->stored_group_success_);\n    EXPECT_EQ(cache_.get(), group_->newest_complete_cache());\n\n    AppCacheDatabase::CacheRecord cache_record;\n    EXPECT_TRUE(database()->FindCache(1, &cache_record));\n    EXPECT_EQ(1, cache_record.cache_id);\n    EXPECT_EQ(1, cache_record.group_id);\n     EXPECT_FALSE(cache_record.online_wildcard);\n     EXPECT_TRUE(expected_update_time == cache_record.update_time);\n     EXPECT_EQ(100 + kDefaultEntrySize, cache_record.cache_size);\n \n     std::vector<AppCacheDatabase::EntryRecord> entry_records;\n     EXPECT_TRUE(database()->FindEntriesForCache(1, &entry_records));\n    EXPECT_EQ(2U, entry_records.size());\n    if (entry_records[0].url == kDefaultEntryUrl)\n       entry_records.erase(entry_records.begin());\n     EXPECT_EQ(1, entry_records[0].cache_id);\n     EXPECT_EQ(kEntryUrl, entry_records[0].url);\n    EXPECT_EQ(AppCacheEntry::MASTER, entry_records[0].flags);\n     EXPECT_EQ(1, entry_records[0].response_id);\n     EXPECT_EQ(100, entry_records[0].response_size);\n \n    EXPECT_EQ(100 + kDefaultEntrySize, storage()->usage_map_[kOrigin]);\n     EXPECT_EQ(1, mock_quota_manager_proxy_->notify_storage_modified_count_);\n     EXPECT_EQ(kOrigin, mock_quota_manager_proxy_->last_origin_);\n    EXPECT_EQ(100, mock_quota_manager_proxy_->last_delta_);\n \n     TestFinished();\n   }\n", "target": 1, "idx": 186972}
{"func": "static void crypto_givcipher_show(struct seq_file *m, struct crypto_alg *alg)\n{\n\tstruct ablkcipher_alg *ablkcipher = &alg->cra_ablkcipher;\n\n\tseq_printf(m, \"type         : givcipher\\n\");\n\tseq_printf(m, \"async        : %s\\n\", alg->cra_flags & CRYPTO_ALG_ASYNC ?\n\t\t\t\t\t     \"yes\" : \"no\");\n\tseq_printf(m, \"blocksize    : %u\\n\", alg->cra_blocksize);\n\tseq_printf(m, \"min keysize  : %u\\n\", ablkcipher->min_keysize);\n\tseq_printf(m, \"max keysize  : %u\\n\", ablkcipher->max_keysize);\n\tseq_printf(m, \"ivsize       : %u\\n\", ablkcipher->ivsize);\n\tseq_printf(m, \"geniv        : %s\\n\", ablkcipher->geniv ?: \"<built-in>\");\n}\n", "target": 0, "idx": 31197}
{"func": "GF_Box *tfdt_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TFBaseMediaDecodeTimeBox, GF_ISOM_BOX_TYPE_TFDT);\n\treturn (GF_Box *)tmp;\n}\n", "target": 0, "idx": 80511}
{"func": "static int dnxhd_find_frame_end(DNXHDParserContext *dctx,\n                                const uint8_t *buf, int buf_size)\n{\n    ParseContext *pc = &dctx->pc;\n    uint64_t state = pc->state64;\n    int pic_found = pc->frame_start_found;\n    int i = 0;\n    int interlaced = dctx->interlaced;\n    int cur_field = dctx->cur_field;\n\n    if (!pic_found) {\n        for (i = 0; i < buf_size; i++) {\n            state = (state << 8) | buf[i];\n            if (ff_dnxhd_check_header_prefix(state & 0xffffffffff00LL) != 0) {\n                i++;\n                pic_found = 1;\n                interlaced = (state&2)>>1; /* byte following the 5-byte header prefix */\n                cur_field = state&1;\n                dctx->cur_byte = 0;\n                dctx->remaining = 0;\n                break;\n            }\n        }\n    }\n\n    if (pic_found && !dctx->remaining) {\n        if (!buf_size) /* EOF considered as end of frame */\n            return 0;\n        for (; i < buf_size; i++) {\n            dctx->cur_byte++;\n            state = (state << 8) | buf[i];\n\n            if (dctx->cur_byte == 24) {\n                dctx->h = (state >> 32) & 0xFFFF;\n            } else if (dctx->cur_byte == 26) {\n                 dctx->w = (state >> 32) & 0xFFFF;\n             } else if (dctx->cur_byte == 42) {\n                 int cid = (state >> 32) & 0xFFFFFFFF;\n \n                 if (cid <= 0)\n                     continue;\n \n                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);\n                if (dctx->remaining <= 0) {\n                    dctx->remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);\n                    if (dctx->remaining <= 0)\n                        return dctx->remaining;\n                 }\n                 if (buf_size - i >= dctx->remaining && (!dctx->interlaced || dctx->cur_field)) {\n                     int remaining = dctx->remaining;\n \n                    pc->frame_start_found = 0;\n                    pc->state64 = -1;\n                    dctx->interlaced = interlaced;\n                    dctx->cur_field = 0;\n                    dctx->cur_byte = 0;\n                    dctx->remaining = 0;\n                    return remaining;\n                } else {\n                    dctx->remaining -= buf_size;\n                }\n            }\n        }\n    } else if (pic_found) {\n        if (dctx->remaining > buf_size) {\n            dctx->remaining -= buf_size;\n        } else {\n            int remaining = dctx->remaining;\n\n            pc->frame_start_found = 0;\n            pc->state64 = -1;\n            dctx->interlaced = interlaced;\n            dctx->cur_field = 0;\n            dctx->cur_byte = 0;\n            dctx->remaining = 0;\n            return remaining;\n        }\n    }\n    pc->frame_start_found = pic_found;\n    pc->state64 = state;\n    dctx->interlaced = interlaced;\n    dctx->cur_field = cur_field;\n    return END_NOT_FOUND;\n}\n", "target": 1, "idx": 181264}
{"func": "void HTMLAnchorElement::setActive(bool down)\n{\n    if (hasEditableStyle())\n        return;\n\n    ContainerNode::setActive(down);\n}\n", "target": 0, "idx": 145343}
{"func": "static void purge_persistent_gnt(struct xen_blkif_ring *ring)\n{\n\tstruct persistent_gnt *persistent_gnt;\n\tstruct rb_node *n;\n\tunsigned int num_clean, total;\n\tbool scan_used = false, clean_used = false;\n\tstruct rb_root *root;\n\n\tif (ring->persistent_gnt_c < xen_blkif_max_pgrants ||\n\t    (ring->persistent_gnt_c == xen_blkif_max_pgrants &&\n\t    !ring->blkif->vbd.overflow_max_grants)) {\n\t\tgoto out;\n\t}\n\n\tif (work_busy(&ring->persistent_purge_work)) {\n\t\tpr_alert_ratelimited(\"Scheduled work from previous purge is still busy, cannot purge list\\n\");\n\t\tgoto out;\n\t}\n\n\tnum_clean = (xen_blkif_max_pgrants / 100) * LRU_PERCENT_CLEAN;\n\tnum_clean = ring->persistent_gnt_c - xen_blkif_max_pgrants + num_clean;\n\tnum_clean = min(ring->persistent_gnt_c, num_clean);\n\tif ((num_clean == 0) ||\n\t    (num_clean > (ring->persistent_gnt_c - atomic_read(&ring->persistent_gnt_in_use))))\n\t\tgoto out;\n\n\t/*\n\t * At this point, we can assure that there will be no calls\n         * to get_persistent_grant (because we are executing this code from\n         * xen_blkif_schedule), there can only be calls to put_persistent_gnt,\n         * which means that the number of currently used grants will go down,\n         * but never up, so we will always be able to remove the requested\n         * number of grants.\n\t */\n\n\ttotal = num_clean;\n\n\tpr_debug(\"Going to purge %u persistent grants\\n\", num_clean);\n\n\tBUG_ON(!list_empty(&ring->persistent_purge_list));\n\troot = &ring->persistent_gnts;\npurge_list:\n\tforeach_grant_safe(persistent_gnt, n, root, node) {\n\t\tBUG_ON(persistent_gnt->handle ==\n\t\t\tBLKBACK_INVALID_HANDLE);\n\n\t\tif (clean_used) {\n\t\t\tclear_bit(PERSISTENT_GNT_WAS_ACTIVE, persistent_gnt->flags);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (test_bit(PERSISTENT_GNT_ACTIVE, persistent_gnt->flags))\n\t\t\tcontinue;\n\t\tif (!scan_used &&\n\t\t    (test_bit(PERSISTENT_GNT_WAS_ACTIVE, persistent_gnt->flags)))\n\t\t\tcontinue;\n\n\t\trb_erase(&persistent_gnt->node, root);\n\t\tlist_add(&persistent_gnt->remove_node,\n\t\t\t &ring->persistent_purge_list);\n\t\tif (--num_clean == 0)\n\t\t\tgoto finished;\n\t}\n\t/*\n\t * If we get here it means we also need to start cleaning\n\t * grants that were used since last purge in order to cope\n\t * with the requested num\n\t */\n\tif (!scan_used && !clean_used) {\n\t\tpr_debug(\"Still missing %u purged frames\\n\", num_clean);\n\t\tscan_used = true;\n\t\tgoto purge_list;\n\t}\nfinished:\n\tif (!clean_used) {\n\t\tpr_debug(\"Finished scanning for grants to clean, removing used flag\\n\");\n\t\tclean_used = true;\n\t\tgoto purge_list;\n\t}\n\n\tring->persistent_gnt_c -= (total - num_clean);\n\tring->blkif->vbd.overflow_max_grants = 0;\n\n\t/* We can defer this work */\n\tschedule_work(&ring->persistent_purge_work);\n\tpr_debug(\"Purged %u/%u\\n\", (total - num_clean), total);\n\nout:\n\treturn;\n}\n", "target": 0, "idx": 63734}
{"func": "static int elf_idx(struct user_ta_ctx *utc, vaddr_t r_va, size_t r_size)\n{\n\tstruct user_ta_elf *elf;\n\tint idx = 0;\n\n\tTAILQ_FOREACH(elf, &utc->elfs, link) {\n\t\tsize_t n;\n\n\t\tfor (n = 0; n < elf->num_segs; n++)\n\t\t\tif (elf->segs[n].va == r_va &&\n\t\t\t    elf->segs[n].size == r_size)\n\t\t\t\treturn idx;\n\t\tidx++;\n\t}\n\treturn -1;\n}\n", "target": 0, "idx": 86933}
{"func": "void LoginDisplayHostWebUI::OnDisplayMetricsChanged(\n    const display::Display& display,\n    uint32_t changed_metrics) {\n  const display::Display primary_display =\n      display::Screen::GetScreen()->GetPrimaryDisplay();\n  if (display.id() != primary_display.id() ||\n      !(changed_metrics & DISPLAY_METRIC_BOUNDS)) {\n    return;\n  }\n\n  if (GetOobeUI()) {\n    if (is_voice_interaction_oobe_)\n      login_window_->SetSize(primary_display.work_area_size());\n\n    const gfx::Size& size = primary_display.size();\n    GetOobeUI()->GetCoreOobeView()->SetClientAreaSize(size.width(),\n                                                      size.height());\n\n    if (changed_metrics & DISPLAY_METRIC_PRIMARY)\n      GetOobeUI()->OnDisplayConfigurationChanged();\n  }\n}\n", "target": 0, "idx": 144315}
{"func": "void SoftAMR::onQueueFilled(OMX_U32 /* portIndex */) {\n List<BufferInfo *> &inQueue = getPortQueue(0);\n List<BufferInfo *> &outQueue = getPortQueue(1);\n\n if (mSignalledError || mOutputPortSettingsChange != NONE) {\n return;\n }\n\n while (!inQueue.empty() && !outQueue.empty()) {\n\n         BufferInfo *inInfo = *inQueue.begin();\n         OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;\n \n        if (inHeader->nFilledLen == 0) {\n            inInfo->mOwnedByUs = false;\n            inQueue.erase(inQueue.begin());\n            notifyEmptyBufferDone(inHeader);\n            continue;\n        }\n         BufferInfo *outInfo = *outQueue.begin();\n         OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;\n \n if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {\n            inQueue.erase(inQueue.begin());\n            inInfo->mOwnedByUs = false;\n            notifyEmptyBufferDone(inHeader);\n\n            outHeader->nFilledLen = 0;\n            outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n\n            outQueue.erase(outQueue.begin());\n            outInfo->mOwnedByUs = false;\n            notifyFillBufferDone(outHeader);\n\n             return;\n         }\n \n         if (inHeader->nOffset == 0) {\n             mAnchorTimeUs = inHeader->nTimeStamp;\n             mNumSamplesOutput = 0;\n }\n\n const uint8_t *inputPtr = inHeader->pBuffer + inHeader->nOffset;\n int32_t numBytesRead;\n\n if (mMode == MODE_NARROW) {\n if (outHeader->nAllocLen < kNumSamplesPerFrameNB * sizeof(int16_t)) {\n                ALOGE(\"b/27662364: NB expected output buffer %zu bytes vs %u\",\n                       kNumSamplesPerFrameNB * sizeof(int16_t), outHeader->nAllocLen);\n                android_errorWriteLog(0x534e4554, \"27662364\");\n                notify(OMX_EventError, OMX_ErrorOverflow, 0, NULL);\n                mSignalledError = true;\n return;\n }\n\n int16 mode = ((inputPtr[0] >> 3) & 0x0f);\n size_t frameSize = WmfDecBytesPerFrame[mode] + 1;\n\n if (inHeader->nFilledLen < frameSize) {\n                ALOGE(\"b/27662364: expected %zu bytes vs %u\", frameSize, inHeader->nFilledLen);\n                notify(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);\n                mSignalledError = true;\n return;\n }\n\n            numBytesRead =\n AMRDecode(mState,\n (Frame_Type_3GPP)((inputPtr[0] >> 3) & 0x0f),\n (UWord8 *)&inputPtr[1],\n reinterpret_cast<int16_t *>(outHeader->pBuffer),\n                  MIME_IETF);\n\n if (numBytesRead == -1) {\n                ALOGE(\"PV AMR decoder AMRDecode() call failed\");\n\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                mSignalledError = true;\n\n return;\n }\n\n ++numBytesRead; // Include the frame type header byte.\n\n if (static_cast<size_t>(numBytesRead) > inHeader->nFilledLen) {\n\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                mSignalledError = true;\n\n return;\n }\n } else {\n if (outHeader->nAllocLen < kNumSamplesPerFrameWB * sizeof(int16_t)) {\n                ALOGE(\"b/27662364: WB expected output buffer %zu bytes vs %u\",\n                       kNumSamplesPerFrameWB * sizeof(int16_t), outHeader->nAllocLen);\n                android_errorWriteLog(0x534e4554, \"27662364\");\n                notify(OMX_EventError, OMX_ErrorOverflow, 0, NULL);\n                mSignalledError = true;\n return;\n }\n\n int16 mode = ((inputPtr[0] >> 3) & 0x0f);\n\n if (mode >= 10 && mode <= 13) {\n                ALOGE(\"encountered illegal frame type %d in AMR WB content.\",\n                      mode);\n\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                mSignalledError = true;\n\n return;\n }\n\n size_t frameSize = getFrameSize(mode);\n if (inHeader->nFilledLen < frameSize) {\n                ALOGE(\"b/27662364: expected %zu bytes vs %u\", frameSize, inHeader->nFilledLen);\n                notify(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);\n                mSignalledError = true;\n return;\n }\n\n int16_t *outPtr = (int16_t *)outHeader->pBuffer;\n\n if (mode >= 9) {\n                memset(outPtr, 0, kNumSamplesPerFrameWB * sizeof(int16_t));\n } else if (mode < 9) {\n int16 frameType;\n                RX_State_wb rx_state;\n                mime_unsorting(\n const_cast<uint8_t *>(&inputPtr[1]),\n                        mInputSampleBuffer,\n &frameType, &mode, 1, &rx_state);\n\n int16_t numSamplesOutput;\n                pvDecoder_AmrWb(\n                        mode, mInputSampleBuffer,\n                        outPtr,\n &numSamplesOutput,\n                        mDecoderBuf, frameType, mDecoderCookie);\n\n                CHECK_EQ((int)numSamplesOutput, (int)kNumSamplesPerFrameWB);\n\n for (int i = 0; i < kNumSamplesPerFrameWB; ++i) {\n /* Delete the 2 LSBs (14-bit output) */\n                    outPtr[i] &= 0xfffC;\n }\n }\n\n            numBytesRead = frameSize;\n }\n\n        inHeader->nOffset += numBytesRead;\n        inHeader->nFilledLen -= numBytesRead;\n\n        outHeader->nFlags = 0;\n        outHeader->nOffset = 0;\n\n if (mMode == MODE_NARROW) {\n            outHeader->nFilledLen = kNumSamplesPerFrameNB * sizeof(int16_t);\n\n            outHeader->nTimeStamp =\n                mAnchorTimeUs\n + (mNumSamplesOutput * 1000000ll) / kSampleRateNB;\n\n            mNumSamplesOutput += kNumSamplesPerFrameNB;\n } else {\n            outHeader->nFilledLen = kNumSamplesPerFrameWB * sizeof(int16_t);\n\n            outHeader->nTimeStamp =\n                mAnchorTimeUs\n + (mNumSamplesOutput * 1000000ll) / kSampleRateWB;\n\n            mNumSamplesOutput += kNumSamplesPerFrameWB;\n }\n\n if (inHeader->nFilledLen == 0) {\n            inInfo->mOwnedByUs = false;\n            inQueue.erase(inQueue.begin());\n            inInfo = NULL;\n            notifyEmptyBufferDone(inHeader);\n            inHeader = NULL;\n }\n\n        outInfo->mOwnedByUs = false;\n        outQueue.erase(outQueue.begin());\n        outInfo = NULL;\n        notifyFillBufferDone(outHeader);\n        outHeader = NULL;\n\n ++mInputBufferCount;\n }\n}\n", "target": 1, "idx": 188252}
{"func": "static inline size_t xfrm_spdinfo_msgsize(void)\n{\n\treturn NLMSG_ALIGN(4)\n\t       + nla_total_size(sizeof(struct xfrmu_spdinfo))\n\t       + nla_total_size(sizeof(struct xfrmu_spdhinfo));\n}\n", "target": 0, "idx": 33179}
{"func": "static int afiucv_hs_callback_syn(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct sock *nsk;\n\tstruct iucv_sock *iucv, *niucv;\n\tstruct af_iucv_trans_hdr *trans_hdr;\n\tint err;\n\n\tiucv = iucv_sk(sk);\n\ttrans_hdr = (struct af_iucv_trans_hdr *)skb->data;\n\tif (!iucv) {\n\t\t/* no sock - connection refused */\n\t\tafiucv_swap_src_dest(skb);\n\t\ttrans_hdr->flags = AF_IUCV_FLAG_SYN | AF_IUCV_FLAG_FIN;\n\t\terr = dev_queue_xmit(skb);\n\t\tgoto out;\n\t}\n\n\tnsk = iucv_sock_alloc(NULL, sk->sk_type, GFP_ATOMIC);\n\tbh_lock_sock(sk);\n\tif ((sk->sk_state != IUCV_LISTEN) ||\n\t    sk_acceptq_is_full(sk) ||\n\t    !nsk) {\n\t\t/* error on server socket - connection refused */\n\t\tif (nsk)\n\t\t\tsk_free(nsk);\n\t\tafiucv_swap_src_dest(skb);\n\t\ttrans_hdr->flags = AF_IUCV_FLAG_SYN | AF_IUCV_FLAG_FIN;\n\t\terr = dev_queue_xmit(skb);\n\t\tbh_unlock_sock(sk);\n\t\tgoto out;\n\t}\n\n\tniucv = iucv_sk(nsk);\n\tiucv_sock_init(nsk, sk);\n\tniucv->transport = AF_IUCV_TRANS_HIPER;\n\tniucv->msglimit = iucv->msglimit;\n\tif (!trans_hdr->window)\n\t\tniucv->msglimit_peer = IUCV_HIPER_MSGLIM_DEFAULT;\n\telse\n\t\tniucv->msglimit_peer = trans_hdr->window;\n\tmemcpy(niucv->dst_name, trans_hdr->srcAppName, 8);\n\tmemcpy(niucv->dst_user_id, trans_hdr->srcUserID, 8);\n\tmemcpy(niucv->src_name, iucv->src_name, 8);\n\tmemcpy(niucv->src_user_id, iucv->src_user_id, 8);\n\tnsk->sk_bound_dev_if = sk->sk_bound_dev_if;\n\tniucv->hs_dev = iucv->hs_dev;\n\tdev_hold(niucv->hs_dev);\n\tafiucv_swap_src_dest(skb);\n\ttrans_hdr->flags = AF_IUCV_FLAG_SYN | AF_IUCV_FLAG_ACK;\n\ttrans_hdr->window = niucv->msglimit;\n\t/* if receiver acks the xmit connection is established */\n\terr = dev_queue_xmit(skb);\n\tif (!err) {\n\t\tiucv_accept_enqueue(sk, nsk);\n\t\tnsk->sk_state = IUCV_CONNECTED;\n\t\tsk->sk_data_ready(sk, 1);\n\t} else\n\t\tiucv_sock_kill(nsk);\n\tbh_unlock_sock(sk);\n\nout:\n\treturn NET_RX_SUCCESS;\n}\n", "target": 0, "idx": 30576}
{"func": "zlib_end(struct zlib *zlib)\n{\n /* Output the summary line now; this ensures a summary line always gets\n    * output regardless of the manner of exit.\n    */\n if (!zlib->global->quiet)\n {\n if (zlib->ok_bits < 16) /* stream was read ok */\n {\n const char *reason;\n\n if (zlib->cksum)\n            reason = \"CHK\"; /* checksum error */\n\n else if (zlib->ok_bits > zlib->file_bits)\n            reason = \"TFB\"; /* fixing a too-far-back error */\n\n else if (zlib->ok_bits == zlib->file_bits)\n            reason = \"OK \";\n\n else\n            reason = \"OPT\"; /* optimizing window bits */\n\n /* SUMMARY FORMAT (for a successful zlib inflate):\n          *\n          * IDAT reason flevel file-bits ok-bits compressed uncompressed file\n          */\n         type_name(zlib->chunk->chunk_type, stdout);\n         printf(\" %s %s %d %d \", reason, zlib_flevel(zlib), zlib->file_bits,\n            zlib->ok_bits);\n         uarb_print(zlib->compressed_bytes, zlib->compressed_digits, stdout);\n         putc(' ', stdout);\n         uarb_print(zlib->uncompressed_bytes, zlib->uncompressed_digits,\n            stdout);\n         putc(' ', stdout);\n         fputs(zlib->file->file_name, stdout);\n         putc('\\n', stdout);\n }\n\n else\n {\n /* This is a zlib read error; the chunk will be skipped.  For an IDAT\n          * stream this will also cause a fatal read error (via stop()).\n          *\n          * SUMMARY FORMAT:\n          *\n          * IDAT SKP flevel file-bits z-rc compressed message file\n\n           *\n           * z-rc is the zlib failure code; message is the error message with\n           * spaces replaced by '-'.  The compressed byte count indicates where\n          * in the zlib stream the error occured.\n           */\n          type_name(zlib->chunk->chunk_type, stdout);\n          printf(\" SKP %s %d %s \", zlib_flevel(zlib), zlib->file_bits,\n            zlib_rc(zlib));\n         uarb_print(zlib->compressed_bytes, zlib->compressed_digits, stdout);\n         putc(' ', stdout);\n         emit_string(zlib->z.msg ? zlib->z.msg : \"[no_message]\", stdout);\n         putc(' ', stdout);\n         fputs(zlib->file->file_name, stdout);\n         putc('\\n', stdout);\n }\n }\n\n if (zlib->state >= 0)\n {\n      zlib->rc = inflateEnd(&zlib->z);\n\n if (zlib->rc != Z_OK)\n         zlib_message(zlib, 1/*unexpected*/);\n }\n\n   CLEAR(*zlib);\n}\n", "target": 1, "idx": 187763}
{"func": "scoped_refptr<BrowserContext> BrowserContextImpl::GetOffTheRecordContext() {\n   if (!otr_context_) {\n    OTRBrowserContextImpl* context = new OTRBrowserContextImpl(\n        this,\n        static_cast<BrowserContextIODataImpl *>(io_data()));\n    otr_context_ = context->GetWeakPtr();\n   }\n \n  return make_scoped_refptr(otr_context_.get());\n }\n", "target": 1, "idx": 178585}
{"func": "static void vnc_dpy_update(DisplayState *ds, int x, int y, int w, int h)\n{\n     int i;\n     VncDisplay *vd = ds->opaque;\n     struct VncSurface *s = &vd->guest;\n \n     h += y;\n \n       two 16-pixel blocks but we only mark the first as dirty\n    */\n    w += (x % 16);\n    x -= (x % 16);\n     w += (x % 16);\n     x -= (x % 16);\n \n    x = MIN(x, s->ds->width);\n    y = MIN(y, s->ds->height);\n    w = MIN(x + w, s->ds->width) - x;\n    h = MIN(h, s->ds->height);\n \n     for (; y < h; y++)\n         for (i = 0; i < w; i += 16)\n\nvoid vnc_framebuffer_update(VncState *vs, int x, int y, int w, int h,\n                            int32_t encoding)\n{\n    vnc_write_u16(vs, x);\n    vnc_write_u16(vs, y);\n    vnc_write_u16(vs, w);\n    vnc_write_u16(vs, h);\n\n    vnc_write_s32(vs, encoding);\n}\n\nvoid buffer_reserve(Buffer *buffer, size_t len)\n{\n    if ((buffer->capacity - buffer->offset) < len) {\n        buffer->capacity += (len + 1024);\n        buffer->buffer = g_realloc(buffer->buffer, buffer->capacity);\n        if (buffer->buffer == NULL) {\n            fprintf(stderr, \"vnc: out of memory\\n\");\n            exit(1);\n        }\n    }\n}\n\nint buffer_empty(Buffer *buffer)\n{\n    return buffer->offset == 0;\n}\n\nuint8_t *buffer_end(Buffer *buffer)\n{\n    return buffer->buffer + buffer->offset;\n}\n\nvoid buffer_reset(Buffer *buffer)\n{\n        buffer->offset = 0;\n}\n\nvoid buffer_free(Buffer *buffer)\n{\n    g_free(buffer->buffer);\n    buffer->offset = 0;\n    buffer->capacity = 0;\n    buffer->buffer = NULL;\n}\n\nvoid buffer_append(Buffer *buffer, const void *data, size_t len)\n{\n    memcpy(buffer->buffer + buffer->offset, data, len);\n    buffer->offset += len;\n}\n\nstatic void vnc_desktop_resize(VncState *vs)\n{\n    DisplayState *ds = vs->ds;\n\n    if (vs->csock == -1 || !vnc_has_feature(vs, VNC_FEATURE_RESIZE)) {\n        return;\n    }\n    if (vs->client_width == ds_get_width(ds) &&\n        vs->client_height == ds_get_height(ds)) {\n        return;\n    }\n    vs->client_width = ds_get_width(ds);\n    vs->client_height = ds_get_height(ds);\n    vnc_lock_output(vs);\n    vnc_write_u8(vs, VNC_MSG_SERVER_FRAMEBUFFER_UPDATE);\n    vnc_write_u8(vs, 0);\n    vnc_write_u16(vs, 1); /* number of rects */\n    vnc_framebuffer_update(vs, 0, 0, vs->client_width, vs->client_height,\n                           VNC_ENCODING_DESKTOPRESIZE);\n    vnc_unlock_output(vs);\n    vnc_flush(vs);\n}\n\nstatic void vnc_abort_display_jobs(VncDisplay *vd)\n{\n    VncState *vs;\n\n    QTAILQ_FOREACH(vs, &vd->clients, next) {\n        vnc_lock_output(vs);\n        vs->abort = true;\n        vnc_unlock_output(vs);\n    }\n    QTAILQ_FOREACH(vs, &vd->clients, next) {\n        vnc_jobs_join(vs);\n    }\n    QTAILQ_FOREACH(vs, &vd->clients, next) {\n        vnc_lock_output(vs);\n        vs->abort = false;\n        vnc_unlock_output(vs);\n    }\n}\n     }\n", "target": 1, "idx": 178642}
{"func": "void Editor::PasteAsFragment(DocumentFragment* pasting_fragment,\n                             bool smart_replace,\n                             bool match_style) {\n  Element* target = FindEventTargetFromSelection();\n  if (!target)\n    return;\n  target->DispatchEvent(TextEvent::CreateForFragmentPaste(\n      GetFrame().DomWindow(), pasting_fragment, smart_replace, match_style));\n}\n", "target": 0, "idx": 135574}
{"func": "void PasswordInputType::DisableSecureTextInput() {\n  LocalFrame* frame = GetElement().GetDocument().GetFrame();\n  if (!frame)\n    return;\n  frame->Selection().SetUseSecureKeyboardEntryWhenActive(false);\n}\n", "target": 1, "idx": 185735}
{"func": "int TopSitesImpl::num_results_to_request_from_history() const {\n  DCHECK(thread_checker_.CalledOnValidThread());\n\n  const base::DictionaryValue* blacklist =\n      pref_service_->GetDictionary(kMostVisitedURLsBlacklist);\n  return kNonForcedTopSitesNumber + (blacklist ? blacklist->size() : 0);\n}\n", "target": 0, "idx": 159910}
{"func": "static void sock_def_write_space(struct sock *sk)\n{\n\tstruct socket_wq *wq;\n\n\trcu_read_lock();\n\n\t/* Do not wake up a writer until he can make \"significant\"\n\t * progress.  --DaveM\n\t */\n\tif ((atomic_read(&sk->sk_wmem_alloc) << 1) <= sk->sk_sndbuf) {\n\t\twq = rcu_dereference(sk->sk_wq);\n\t\tif (skwq_has_sleeper(wq))\n\t\t\twake_up_interruptible_sync_poll(&wq->wait, POLLOUT |\n\t\t\t\t\t\tPOLLWRNORM | POLLWRBAND);\n\n\t\t/* Should agree with poll, otherwise some programs break */\n\t\tif (sock_writeable(sk))\n\t\t\tsk_wake_async(sk, SOCK_WAKE_SPACE, POLL_OUT);\n\t}\n\n\trcu_read_unlock();\n}\n", "target": 0, "idx": 47896}
{"func": "image_transform_default_ini(PNG_CONST image_transform *this,\n     transform_display *that)\n {\n    this->next->ini(this->next, that);\n}\n", "target": 1, "idx": 187643}
{"func": "int ip6_append_data(struct sock *sk, int getfrag(void *from, char *to,\n\tint offset, int len, int odd, struct sk_buff *skb),\n\tvoid *from, int length, int transhdrlen,\n\tint hlimit, int tclass, struct ipv6_txoptions *opt, struct flowi6 *fl6,\n\tstruct rt6_info *rt, unsigned int flags, int dontfrag)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct inet_cork *cork;\n\tstruct sk_buff *skb, *skb_prev = NULL;\n\tunsigned int maxfraglen, fragheaderlen, mtu;\n\tint exthdrlen;\n\tint dst_exthdrlen;\n\tint hh_len;\n\tint copy;\n\tint err;\n\tint offset = 0;\n\t__u8 tx_flags = 0;\n\n\tif (flags&MSG_PROBE)\n\t\treturn 0;\n\tcork = &inet->cork.base;\n\tif (skb_queue_empty(&sk->sk_write_queue)) {\n\t\t/*\n\t\t * setup for corking\n\t\t */\n\t\tif (opt) {\n\t\t\tif (WARN_ON(np->cork.opt))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tnp->cork.opt = kzalloc(opt->tot_len, sk->sk_allocation);\n\t\t\tif (unlikely(np->cork.opt == NULL))\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\tnp->cork.opt->tot_len = opt->tot_len;\n\t\t\tnp->cork.opt->opt_flen = opt->opt_flen;\n\t\t\tnp->cork.opt->opt_nflen = opt->opt_nflen;\n\n\t\t\tnp->cork.opt->dst0opt = ip6_opt_dup(opt->dst0opt,\n\t\t\t\t\t\t\t    sk->sk_allocation);\n\t\t\tif (opt->dst0opt && !np->cork.opt->dst0opt)\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\tnp->cork.opt->dst1opt = ip6_opt_dup(opt->dst1opt,\n\t\t\t\t\t\t\t    sk->sk_allocation);\n\t\t\tif (opt->dst1opt && !np->cork.opt->dst1opt)\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\tnp->cork.opt->hopopt = ip6_opt_dup(opt->hopopt,\n\t\t\t\t\t\t\t   sk->sk_allocation);\n\t\t\tif (opt->hopopt && !np->cork.opt->hopopt)\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\tnp->cork.opt->srcrt = ip6_rthdr_dup(opt->srcrt,\n\t\t\t\t\t\t\t    sk->sk_allocation);\n\t\t\tif (opt->srcrt && !np->cork.opt->srcrt)\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\t/* need source address above miyazawa*/\n\t\t}\n\t\tdst_hold(&rt->dst);\n\t\tcork->dst = &rt->dst;\n\t\tinet->cork.fl.u.ip6 = *fl6;\n\t\tnp->cork.hop_limit = hlimit;\n\t\tnp->cork.tclass = tclass;\n\t\tif (rt->dst.flags & DST_XFRM_TUNNEL)\n\t\t\tmtu = np->pmtudisc == IPV6_PMTUDISC_PROBE ?\n\t\t\t      rt->dst.dev->mtu : dst_mtu(&rt->dst);\n\t\telse\n\t\t\tmtu = np->pmtudisc == IPV6_PMTUDISC_PROBE ?\n\t\t\t      rt->dst.dev->mtu : dst_mtu(rt->dst.path);\n\t\tif (np->frag_size < mtu) {\n\t\t\tif (np->frag_size)\n\t\t\t\tmtu = np->frag_size;\n\t\t}\n\t\tcork->fragsize = mtu;\n\t\tif (dst_allfrag(rt->dst.path))\n\t\t\tcork->flags |= IPCORK_ALLFRAG;\n\t\tcork->length = 0;\n\t\texthdrlen = (opt ? opt->opt_flen : 0);\n\t\tlength += exthdrlen;\n\t\ttranshdrlen += exthdrlen;\n\t\tdst_exthdrlen = rt->dst.header_len - rt->rt6i_nfheader_len;\n\t} else {\n\t\trt = (struct rt6_info *)cork->dst;\n\t\tfl6 = &inet->cork.fl.u.ip6;\n\t\topt = np->cork.opt;\n\t\ttranshdrlen = 0;\n\t\texthdrlen = 0;\n\t\tdst_exthdrlen = 0;\n\t\tmtu = cork->fragsize;\n\t}\n\n\thh_len = LL_RESERVED_SPACE(rt->dst.dev);\n\n\tfragheaderlen = sizeof(struct ipv6hdr) + rt->rt6i_nfheader_len +\n\t\t\t(opt ? opt->opt_nflen : 0);\n\tmaxfraglen = ((mtu - fragheaderlen) & ~7) + fragheaderlen - sizeof(struct frag_hdr);\n\n\tif (mtu <= sizeof(struct ipv6hdr) + IPV6_MAXPLEN) {\n\t\tif (cork->length + length > sizeof(struct ipv6hdr) + IPV6_MAXPLEN - fragheaderlen) {\n\t\t\tipv6_local_error(sk, EMSGSIZE, fl6, mtu-exthdrlen);\n\t\t\treturn -EMSGSIZE;\n\t\t}\n\t}\n\n\t/* For UDP, check if TX timestamp is enabled */\n\tif (sk->sk_type == SOCK_DGRAM)\n\t\tsock_tx_timestamp(sk, &tx_flags);\n\n\t/*\n\t * Let's try using as much space as possible.\n\t * Use MTU if total length of the message fits into the MTU.\n\t * Otherwise, we need to reserve fragment header and\n\t * fragment alignment (= 8-15 octects, in total).\n\t *\n\t * Note that we may need to \"move\" the data from the tail of\n\t * of the buffer to the new fragment when we split\n\t * the message.\n\t *\n\t * FIXME: It may be fragmented into multiple chunks\n\t *        at once if non-fragmentable extension headers\n\t *        are too large.\n \t * --yoshfuji\n \t */\n \n\tcork->length += length;\n\tif (length > mtu) {\n\t\tint proto = sk->sk_protocol;\n\t\tif (dontfrag && (proto == IPPROTO_UDP || proto == IPPROTO_RAW)){\n\t\t\tipv6_local_rxpmtu(sk, fl6, mtu-exthdrlen);\n\t\t\treturn -EMSGSIZE;\n\t\t}\n\t\tif (proto == IPPROTO_UDP &&\n\t\t    (rt->dst.dev->features & NETIF_F_UFO)) {\n \n\t\t\terr = ip6_ufo_append_data(sk, getfrag, from, length,\n\t\t\t\t\t\t  hh_len, fragheaderlen,\n\t\t\t\t\t\t  transhdrlen, mtu, flags, rt);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t\treturn 0;\n\t\t}\n \t}\n \n\tif ((skb = skb_peek_tail(&sk->sk_write_queue)) == NULL)\n \t\tgoto alloc_new_skb;\n \n \twhile (length > 0) {\n\t\t/* Check if the remaining data fits into current packet. */\n\t\tcopy = (cork->length <= mtu && !(cork->flags & IPCORK_ALLFRAG) ? mtu : maxfraglen) - skb->len;\n\t\tif (copy < length)\n\t\t\tcopy = maxfraglen - skb->len;\n\n\t\tif (copy <= 0) {\n\t\t\tchar *data;\n\t\t\tunsigned int datalen;\n\t\t\tunsigned int fraglen;\n\t\t\tunsigned int fraggap;\n\t\t\tunsigned int alloclen;\nalloc_new_skb:\n\t\t\t/* There's no room in the current skb */\n\t\t\tif (skb)\n\t\t\t\tfraggap = skb->len - maxfraglen;\n\t\t\telse\n\t\t\t\tfraggap = 0;\n\t\t\t/* update mtu and maxfraglen if necessary */\n\t\t\tif (skb == NULL || skb_prev == NULL)\n\t\t\t\tip6_append_data_mtu(&mtu, &maxfraglen,\n\t\t\t\t\t\t    fragheaderlen, skb, rt,\n\t\t\t\t\t\t    np->pmtudisc ==\n\t\t\t\t\t\t    IPV6_PMTUDISC_PROBE);\n\n\t\t\tskb_prev = skb;\n\n\t\t\t/*\n\t\t\t * If remaining data exceeds the mtu,\n\t\t\t * we know we need more fragment(s).\n\t\t\t */\n\t\t\tdatalen = length + fraggap;\n\n\t\t\tif (datalen > (cork->length <= mtu && !(cork->flags & IPCORK_ALLFRAG) ? mtu : maxfraglen) - fragheaderlen)\n\t\t\t\tdatalen = maxfraglen - fragheaderlen - rt->dst.trailer_len;\n\t\t\tif ((flags & MSG_MORE) &&\n\t\t\t    !(rt->dst.dev->features&NETIF_F_SG))\n\t\t\t\talloclen = mtu;\n\t\t\telse\n\t\t\t\talloclen = datalen + fragheaderlen;\n\n\t\t\talloclen += dst_exthdrlen;\n\n\t\t\tif (datalen != length + fraggap) {\n\t\t\t\t/*\n\t\t\t\t * this is not the last fragment, the trailer\n\t\t\t\t * space is regarded as data space.\n\t\t\t\t */\n\t\t\t\tdatalen += rt->dst.trailer_len;\n\t\t\t}\n\n\t\t\talloclen += rt->dst.trailer_len;\n\t\t\tfraglen = datalen + fragheaderlen;\n\n\t\t\t/*\n\t\t\t * We just reserve space for fragment header.\n\t\t\t * Note: this may be overallocation if the message\n\t\t\t * (without MSG_MORE) fits into the MTU.\n\t\t\t */\n\t\t\talloclen += sizeof(struct frag_hdr);\n\n\t\t\tif (transhdrlen) {\n\t\t\t\tskb = sock_alloc_send_skb(sk,\n\t\t\t\t\t\talloclen + hh_len,\n\t\t\t\t\t\t(flags & MSG_DONTWAIT), &err);\n\t\t\t} else {\n\t\t\t\tskb = NULL;\n\t\t\t\tif (atomic_read(&sk->sk_wmem_alloc) <=\n\t\t\t\t    2 * sk->sk_sndbuf)\n\t\t\t\t\tskb = sock_wmalloc(sk,\n\t\t\t\t\t\t\t   alloclen + hh_len, 1,\n\t\t\t\t\t\t\t   sk->sk_allocation);\n\t\t\t\tif (unlikely(skb == NULL))\n\t\t\t\t\terr = -ENOBUFS;\n\t\t\t\telse {\n\t\t\t\t\t/* Only the initial fragment\n\t\t\t\t\t * is time stamped.\n\t\t\t\t\t */\n\t\t\t\t\ttx_flags = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (skb == NULL)\n\t\t\t\tgoto error;\n\t\t\t/*\n\t\t\t *\tFill in the control structures\n\t\t\t */\n\t\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\t\tskb->csum = 0;\n\t\t\t/* reserve for fragmentation and ipsec header */\n\t\t\tskb_reserve(skb, hh_len + sizeof(struct frag_hdr) +\n\t\t\t\t    dst_exthdrlen);\n\n\t\t\tif (sk->sk_type == SOCK_DGRAM)\n\t\t\t\tskb_shinfo(skb)->tx_flags = tx_flags;\n\n\t\t\t/*\n\t\t\t *\tFind where to start putting bytes\n\t\t\t */\n\t\t\tdata = skb_put(skb, fraglen);\n\t\t\tskb_set_network_header(skb, exthdrlen);\n\t\t\tdata += fragheaderlen;\n\t\t\tskb->transport_header = (skb->network_header +\n\t\t\t\t\t\t fragheaderlen);\n\t\t\tif (fraggap) {\n\t\t\t\tskb->csum = skb_copy_and_csum_bits(\n\t\t\t\t\tskb_prev, maxfraglen,\n\t\t\t\t\tdata + transhdrlen, fraggap, 0);\n\t\t\t\tskb_prev->csum = csum_sub(skb_prev->csum,\n\t\t\t\t\t\t\t  skb->csum);\n\t\t\t\tdata += fraggap;\n\t\t\t\tpskb_trim_unique(skb_prev, maxfraglen);\n\t\t\t}\n\t\t\tcopy = datalen - transhdrlen - fraggap;\n\n\t\t\tif (copy < 0) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tkfree_skb(skb);\n\t\t\t\tgoto error;\n\t\t\t} else if (copy > 0 && getfrag(from, data + transhdrlen, offset, copy, fraggap, skb) < 0) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tkfree_skb(skb);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\toffset += copy;\n\t\t\tlength -= datalen - fraggap;\n\t\t\ttranshdrlen = 0;\n\t\t\texthdrlen = 0;\n\t\t\tdst_exthdrlen = 0;\n\n\t\t\t/*\n\t\t\t * Put the packet on the pending queue\n\t\t\t */\n\t\t\t__skb_queue_tail(&sk->sk_write_queue, skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (copy > length)\n\t\t\tcopy = length;\n\n\t\tif (!(rt->dst.dev->features&NETIF_F_SG)) {\n\t\t\tunsigned int off;\n\n\t\t\toff = skb->len;\n\t\t\tif (getfrag(from, skb_put(skb, copy),\n\t\t\t\t\t\toffset, copy, off, skb) < 0) {\n\t\t\t\t__skb_trim(skb, off);\n\t\t\t\terr = -EFAULT;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t} else {\n\t\t\tint i = skb_shinfo(skb)->nr_frags;\n\t\t\tstruct page_frag *pfrag = sk_page_frag(sk);\n\n\t\t\terr = -ENOMEM;\n\t\t\tif (!sk_page_frag_refill(sk, pfrag))\n\t\t\t\tgoto error;\n\n\t\t\tif (!skb_can_coalesce(skb, i, pfrag->page,\n\t\t\t\t\t      pfrag->offset)) {\n\t\t\t\terr = -EMSGSIZE;\n\t\t\t\tif (i == MAX_SKB_FRAGS)\n\t\t\t\t\tgoto error;\n\n\t\t\t\t__skb_fill_page_desc(skb, i, pfrag->page,\n\t\t\t\t\t\t     pfrag->offset, 0);\n\t\t\t\tskb_shinfo(skb)->nr_frags = ++i;\n\t\t\t\tget_page(pfrag->page);\n\t\t\t}\n\t\t\tcopy = min_t(int, copy, pfrag->size - pfrag->offset);\n\t\t\tif (getfrag(from,\n\t\t\t\t    page_address(pfrag->page) + pfrag->offset,\n\t\t\t\t    offset, copy, skb->len, skb) < 0)\n\t\t\t\tgoto error_efault;\n\n\t\t\tpfrag->offset += copy;\n\t\t\tskb_frag_size_add(&skb_shinfo(skb)->frags[i - 1], copy);\n\t\t\tskb->len += copy;\n\t\t\tskb->data_len += copy;\n\t\t\tskb->truesize += copy;\n\t\t\tatomic_add(copy, &sk->sk_wmem_alloc);\n\t\t}\n\t\toffset += copy;\n\t\tlength -= copy;\n\t}\n\n\treturn 0;\n\nerror_efault:\n\terr = -EFAULT;\nerror:\n\tcork->length -= length;\n\tIP6_INC_STATS(sock_net(sk), rt->rt6i_idev, IPSTATS_MIB_OUTDISCARDS);\n\treturn err;\n}\n", "target": 1, "idx": 179159}
{"func": "cJSON *cJSON_CreateNull( void )\n{\n\tcJSON *item = cJSON_New_Item();\n\tif ( item )\n\t\titem->type = cJSON_NULL;\n\treturn item;\n}\n", "target": 1, "idx": 180448}
{"func": "void ClientSession::OnConnectionClosed(\n    protocol::ConnectionToClient* connection) {\n   DCHECK_EQ(connection_.get(), connection);\n   scoped_refptr<ClientSession> self = this;\n   event_handler_->OnSessionClosed(this);\n  Disconnect();\n }\n", "target": 1, "idx": 184641}
{"func": "std::vector<GURL> ComputeCookieURLs(RenderFrameHostImpl* frame_host,\n                                    Maybe<Array<String>>& protocol_urls) {\n  std::vector<GURL> urls;\n\n  if (protocol_urls.isJust()) {\n    std::unique_ptr<Array<std::string>> actual_urls = protocol_urls.takeJust();\n\n    for (size_t i = 0; i < actual_urls->length(); i++)\n      urls.push_back(GURL(actual_urls->get(i)));\n  } else {\n    base::queue<FrameTreeNode*> queue;\n    queue.push(frame_host->frame_tree_node());\n    while (!queue.empty()) {\n      FrameTreeNode* node = queue.front();\n      queue.pop();\n\n      urls.push_back(node->current_url());\n      for (size_t i = 0; i < node->child_count(); ++i)\n        queue.push(node->child_at(i));\n    }\n  }\n\n  return urls;\n}\n", "target": 0, "idx": 161315}
{"func": "void TradQT_Manager::ExportSimpleXMP ( XMP_Uns32 id, const SXMPMeta & xmp, XMP_StringPtr ns, XMP_StringPtr prop,\n\t\t\t\t\t\t\t\t\t   bool createWithZeroLang /* = false */  )\n{\n\tstd::string xmpValue, macValue;\n\n\tInfoMapPos infoPos = this->parsedBoxes.find ( id );\n\tbool qtFound = (infoPos != this->parsedBoxes.end()) && (! infoPos->second.values.empty());\n\n\tbool xmpFound = xmp.GetProperty ( ns, prop, &xmpValue, 0 );\n\tif ( (! xmpFound) || (xmpValue.empty()) ) {\n\t\tif ( qtFound ) {\n\t\t\tthis->parsedBoxes.erase ( infoPos );\n\t\t\tthis->changed = true;\n\t\t}\n\t\treturn;\n\t}\n\t\n\tXMP_Assert ( xmpFound );\n\tif ( ! qtFound ) {\n\t\tif ( ! createWithZeroLang ) return;\n\t\tinfoPos = this->parsedBoxes.insert ( this->parsedBoxes.end(),\n\t\t\t\t\t\t\t\t\t\t\t InfoMap::value_type ( id, ParsedBoxInfo ( id ) ) );\n\t\tValueVector * newValues = &infoPos->second.values;\n\t\tnewValues->push_back ( ValueInfo() );\n\t\tValueInfo * newValue = &newValues->back();\n\t\tnewValue->macLang = 0;\t// Happens to be langEnglish.\n\t\tnewValue->xmpLang = kMacToXMPLang_0_94[0];\n\t\tthis->changed = infoPos->second.changed = true;\n\t}\n\t\t\n\tValueInfo * qtItem = &infoPos->second.values[0];\t// ! Use the first QT entry.\n\tif ( ! IsMacLangKnown ( qtItem->macLang ) ) return;\n\t\n\tbool convertOK = ConvertToMacLang ( xmpValue, qtItem->macLang, &macValue );\n\tif ( convertOK && (macValue != qtItem->macValue) ) {\n\t\tqtItem->macValue = macValue;\n\t\tthis->changed = infoPos->second.changed = true;\n\t}\n\t\n}\t// TradQT_Manager::ExportSimpleXMP\n", "target": 0, "idx": 15894}
{"func": "static int raw_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n\t\t       size_t len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipcm_cookie ipc;\n\tstruct rtable *rt = NULL;\n\tint free = 0;\n\t__be32 daddr;\n \t__be32 saddr;\n \tu8  tos;\n \tint err;\n \n \terr = -EMSGSIZE;\n \tif (len > 0xFFFF)\n\t\tgoto out;\n\n\t/*\n\t *\tCheck the flags.\n\t */\n\n\terr = -EOPNOTSUPP;\n\tif (msg->msg_flags & MSG_OOB)\t/* Mirror BSD error message */\n\t\tgoto out;               /* compatibility */\n\n\t/*\n\t *\tGet and verify the address.\n\t */\n\n\tif (msg->msg_namelen) {\n\t\tstruct sockaddr_in *usin = (struct sockaddr_in *)msg->msg_name;\n\t\terr = -EINVAL;\n\t\tif (msg->msg_namelen < sizeof(*usin))\n\t\t\tgoto out;\n\t\tif (usin->sin_family != AF_INET) {\n\t\t\tstatic int complained;\n\t\t\tif (!complained++)\n\t\t\t\tprintk(KERN_INFO \"%s forgot to set AF_INET in \"\n\t\t\t\t\t\t \"raw sendmsg. Fix it!\\n\",\n\t\t\t\t\t\t current->comm);\n\t\t\terr = -EAFNOSUPPORT;\n\t\t\tif (usin->sin_family)\n\t\t\t\tgoto out;\n\t\t}\n\t\tdaddr = usin->sin_addr.s_addr;\n\t\t/* ANK: I did not forget to get protocol from port field.\n\t\t * I just do not know, who uses this weirdness.\n\t\t * IP_HDRINCL is much more convenient.\n\t\t */\n\t} else {\n\t\terr = -EDESTADDRREQ;\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out;\n\t\tdaddr = inet->inet_daddr;\n\t}\n\n\tipc.addr = inet->inet_saddr;\n\tipc.opt = NULL;\n\tipc.tx_flags = 0;\n\tipc.oif = sk->sk_bound_dev_if;\n\n\tif (msg->msg_controllen) {\n\t\terr = ip_cmsg_send(sock_net(sk), msg, &ipc);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (ipc.opt)\n\t\t\tfree = 1;\n\t}\n\n \tsaddr = ipc.addr;\n \tipc.addr = daddr;\n \n\tif (!ipc.opt)\n\t\tipc.opt = inet->opt;\n \n \tif (ipc.opt) {\n \t\terr = -EINVAL;\n\t\t/* Linux does not mangle headers on raw sockets,\n\t\t * so that IP options + IP_HDRINCL is non-sense.\n \t\t */\n \t\tif (inet->hdrincl)\n \t\t\tgoto done;\n\t\tif (ipc.opt->srr) {\n \t\t\tif (!daddr)\n \t\t\t\tgoto done;\n\t\t\tdaddr = ipc.opt->faddr;\n \t\t}\n \t}\n \ttos = RT_CONN_FLAGS(sk);\n\tif (msg->msg_flags & MSG_DONTROUTE)\n\t\ttos |= RTO_ONLINK;\n\n\tif (ipv4_is_multicast(daddr)) {\n\t\tif (!ipc.oif)\n\t\t\tipc.oif = inet->mc_index;\n\t\tif (!saddr)\n\t\t\tsaddr = inet->mc_addr;\n\t}\n\n\t{\n\t\tstruct flowi4 fl4;\n\n\t\tflowi4_init_output(&fl4, ipc.oif, sk->sk_mark, tos,\n\t\t\t\t   RT_SCOPE_UNIVERSE,\n\t\t\t\t   inet->hdrincl ? IPPROTO_RAW : sk->sk_protocol,\n\t\t\t\t   FLOWI_FLAG_CAN_SLEEP, daddr, saddr, 0, 0);\n\n\t\tif (!inet->hdrincl) {\n\t\t\terr = raw_probe_proto_opt(&fl4, msg);\n\t\t\tif (err)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\tsecurity_sk_classify_flow(sk, flowi4_to_flowi(&fl4));\n\t\trt = ip_route_output_flow(sock_net(sk), &fl4, sk);\n\t\tif (IS_ERR(rt)) {\n\t\t\terr = PTR_ERR(rt);\n\t\t\trt = NULL;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\terr = -EACCES;\n\tif (rt->rt_flags & RTCF_BROADCAST && !sock_flag(sk, SOCK_BROADCAST))\n\t\tgoto done;\n\n\tif (msg->msg_flags & MSG_CONFIRM)\n\t\tgoto do_confirm;\nback_from_confirm:\n\n\tif (inet->hdrincl)\n\t\terr = raw_send_hdrinc(sk, msg->msg_iov, len,\n\t\t\t\t\t&rt, msg->msg_flags);\n\n\t else {\n\t\tif (!ipc.addr)\n\t\t\tipc.addr = rt->rt_dst;\n\t\tlock_sock(sk);\n\t\terr = ip_append_data(sk, ip_generic_getfrag, msg->msg_iov, len, 0,\n\t\t\t\t\t&ipc, &rt, msg->msg_flags);\n\t\tif (err)\n\t\t\tip_flush_pending_frames(sk);\n\t\telse if (!(msg->msg_flags & MSG_MORE)) {\n\t\t\terr = ip_push_pending_frames(sk);\n\t\t\tif (err == -ENOBUFS && !inet->recverr)\n\t\t\t\terr = 0;\n\t\t}\n\t\trelease_sock(sk);\n\t}\ndone:\n\tif (free)\n\t\tkfree(ipc.opt);\n\tip_rt_put(rt);\n\nout:\n\tif (err < 0)\n\t\treturn err;\n\treturn len;\n\ndo_confirm:\n\tdst_confirm(&rt->dst);\n\tif (!(msg->msg_flags & MSG_PROBE) || len)\n\t\tgoto back_from_confirm;\n\terr = 0;\n\tgoto done;\n}\n", "target": 1, "idx": 178740}
{"func": "void RenderBlockFlow::styleWillChange(StyleDifference diff, const RenderStyle& newStyle)\n {\n     RenderStyle* oldStyle = style();\n     s_canPropagateFloatIntoSibling = oldStyle ? !isFloatingOrOutOfFlowPositioned() && !avoidsFloats() : false;\n    if (oldStyle && parent() && diff == StyleDifferenceLayout && oldStyle->position() != newStyle.position()\n         && containsFloats() && !isFloating() && !isOutOfFlowPositioned() && newStyle.hasOutOfFlowPosition())\n             markAllDescendantsWithFloatsForLayout();\n \n    RenderBlock::styleWillChange(diff, newStyle);\n}\n", "target": 1, "idx": 185161}
{"func": "MagickExport Image *ShaveImage(const Image *image,\n  const RectangleInfo *shave_info,ExceptionInfo *exception)\n{\n  Image\n    *shave_image;\n\n  RectangleInfo\n    geometry;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (((2*shave_info->width) >= image->columns) ||\n      ((2*shave_info->height) >= image->rows))\n    ThrowImageException(OptionWarning,\"GeometryDoesNotContainImage\");\n  SetGeometry(image,&geometry);\n  geometry.width-=2*shave_info->width;\n  geometry.height-=2*shave_info->height;\n  geometry.x=(ssize_t) shave_info->width+image->page.x;\n  geometry.y=(ssize_t) shave_info->height+image->page.y;\n  shave_image=CropImage(image,&geometry,exception);\n  if (shave_image == (Image *) NULL)\n    return((Image *) NULL);\n  shave_image->page.width-=2*shave_info->width;\n  shave_image->page.height-=2*shave_info->height;\n  shave_image->page.x-=(ssize_t) shave_info->width;\n  shave_image->page.y-=(ssize_t) shave_info->height;\n  return(shave_image);\n}\n", "target": 0, "idx": 74025}
{"func": "static int _c2s_sx_sasl_callback(int cb, void *arg, void **res, sx_t s, void *cbarg) {\n    c2s_t c2s = (c2s_t) cbarg;\n    const char *my_realm, *mech;\n    sx_sasl_creds_t creds;\n    static char buf[3072];\n    char mechbuf[256];\n    struct jid_st jid;\n    jid_static_buf jid_buf;\n    int i, r;\n    sess_t sess;\n    char skey[44];\n    host_t host;\n\n    /* init static jid */\n    jid_static(&jid,&jid_buf);\n\n    /* retrieve our session */\n    assert(s != NULL);\n    sprintf(skey, \"%d\", s->tag);\n\n    /*\n     * Retrieve the session, note that depending on the operation,\n     * session may be null.\n     */\n    sess = xhash_get(c2s->sessions, skey);\n\n    switch(cb) {\n        case sx_sasl_cb_GET_REALM:\n\n            if(s->req_to == NULL)   /* this shouldn't happen */\n                my_realm = \"\";\n\n            else {\n                /* get host for request */\n                host = xhash_get(c2s->hosts, s->req_to);\n                if(host == NULL) {\n                    log_write(c2s->log, LOG_ERR, \"SASL callback for non-existing host: %s\", s->req_to);\n                    *res = (void *)NULL;\n                    return sx_sasl_ret_FAIL;\n                }\n\n                my_realm = host->realm;\n                if(my_realm == NULL)\n                    my_realm = s->req_to;\n            }\n\n            strncpy(buf, my_realm, 256);\n            *res = (void *)buf;\n\n            log_debug(ZONE, \"sx sasl callback: get realm: realm is '%s'\", buf);\n            return sx_sasl_ret_OK;\n            break;\n\n        case sx_sasl_cb_GET_PASS:\n            assert(sess != NULL);\n            creds = (sx_sasl_creds_t) arg;\n\n            log_debug(ZONE, \"sx sasl callback: get pass (authnid=%s, realm=%s)\", creds->authnid, creds->realm);\n\n            if(sess->host->ar->get_password && (sess->host->ar->get_password)(\n                        sess->host->ar, sess, (char *)creds->authnid, (creds->realm != NULL) ? (char *)creds->realm: \"\", buf) == 0) {\n                *res = buf;\n                return sx_sasl_ret_OK;\n            }\n\n            return sx_sasl_ret_FAIL;\n\n        case sx_sasl_cb_CHECK_PASS:\n            assert(sess != NULL);\n            creds = (sx_sasl_creds_t) arg;\n\n            log_debug(ZONE, \"sx sasl callback: check pass (authnid=%s, realm=%s)\", creds->authnid, creds->realm);\n\n            if(sess->host->ar->check_password != NULL) {\n                if ((sess->host->ar->check_password)(\n                            sess->host->ar, sess, (char *)creds->authnid, (creds->realm != NULL) ? (char *)creds->realm : \"\", (char *)creds->pass) == 0)\n                    return sx_sasl_ret_OK;\n                else\n                    return sx_sasl_ret_FAIL;\n            }\n\n            if(sess->host->ar->get_password != NULL) {\n                if ((sess->host->ar->get_password)(sess->host->ar, sess, (char *)creds->authnid, (creds->realm != NULL) ? (char *)creds->realm : \"\", buf) != 0)\n                    return sx_sasl_ret_FAIL;\n\n                if (strcmp(creds->pass, buf)==0)\n                    return sx_sasl_ret_OK;\n            }\n\n            return sx_sasl_ret_FAIL;\n            break;\n\n        case sx_sasl_cb_CHECK_AUTHZID:\n            assert(sess != NULL);\n            creds = (sx_sasl_creds_t) arg;\n\n            /* we need authzid to validate */\n            if(creds->authzid == NULL || creds->authzid[0] == '\\0')\n                return sx_sasl_ret_FAIL;\n\n            /* authzid must be a valid jid */\n            if(jid_reset(&jid, creds->authzid, -1) == NULL)\n                return sx_sasl_ret_FAIL;\n\n            /* and have domain == stream to addr */\n            if(!s->req_to || (strcmp(jid.domain, s->req_to) != 0))\n                return sx_sasl_ret_FAIL;\n\n            /* and have no resource */\n            if(jid.resource[0] != '\\0')\n                return sx_sasl_ret_FAIL;\n\n            /* and user has right to authorize as */\n            if (sess->host->ar->user_authz_allowed) {\n                if (sess->host->ar->user_authz_allowed(sess->host->ar, sess, (char *)creds->authnid, (char *)creds->realm, (char *)creds->authzid))\n                        return sx_sasl_ret_OK;\n            } else {\n                if (strcmp(creds->authnid, jid.node) == 0 &&\n                    (sess->host->ar->user_exists)(sess->host->ar, sess, jid.node, jid.domain))\n                    return sx_sasl_ret_OK;\n            }\n\n            return sx_sasl_ret_FAIL;\n\n        case sx_sasl_cb_GEN_AUTHZID:\n            /* generate a jid for SASL ANONYMOUS */\n            jid_reset(&jid, s->req_to, -1);\n\n            /* make node a random string */\n            jid_random_part(&jid, jid_NODE);\n\n            strcpy(buf, jid.node);\n\n            *res = (void *)buf;\n\n            return sx_sasl_ret_OK;\n            break;\n\n        case sx_sasl_cb_CHECK_MECH:\n            mech = (char *)arg;\n\n            strncpy(mechbuf, mech, sizeof(mechbuf));\n             mechbuf[sizeof(mechbuf)-1]='\\0';\n             for(i = 0; mechbuf[i]; i++) mechbuf[i] = tolower(mechbuf[i]);\n \n             /* get host for request */\n             host = xhash_get(c2s->hosts, s->req_to);\n             if(host == NULL) {\n                log_write(c2s->log, LOG_WARNING, \"SASL callback for non-existing host: %s\", s->req_to);\n                return sx_sasl_ret_FAIL;\n            }\n\n            /* Determine if our configuration will let us use this mechanism.\n             * We support different mechanisms for both SSL and normal use */\n            if (strcmp(mechbuf, \"digest-md5\") == 0) {\n                /* digest-md5 requires that our authreg support get_password */\n                if (host->ar->get_password == NULL)\n                    return sx_sasl_ret_FAIL;\n            } else if (strcmp(mechbuf, \"plain\") == 0) {\n                /* plain requires either get_password or check_password */\n                if (host->ar->get_password == NULL && host->ar->check_password == NULL)\n                    return sx_sasl_ret_FAIL;\n            }\n\n            /* Using SSF is potentially dangerous, as SASL can also set the\n             * SSF of the connection. However, SASL shouldn't do so until after\n             * we've finished mechanism establishment\n             */\n            if (s->ssf>0) {\n                r = snprintf(buf, sizeof(buf), \"authreg.ssl-mechanisms.sasl.%s\",mechbuf);\n                if (r < -1 || r > sizeof(buf))\n                    return sx_sasl_ret_FAIL;\n                if(config_get(c2s->config,buf) != NULL)\n                    return sx_sasl_ret_OK;\n            }\n\n            r = snprintf(buf, sizeof(buf), \"authreg.mechanisms.sasl.%s\",mechbuf);\n            if (r < -1 || r > sizeof(buf))\n                return sx_sasl_ret_FAIL;\n\n            /* Work out if our configuration will let us use this mechanism */\n            if(config_get(c2s->config,buf) != NULL)\n                return sx_sasl_ret_OK;\n            else\n                return sx_sasl_ret_FAIL;\n        default:\n            break;\n    }\n\n    return sx_sasl_ret_FAIL;\n}\n", "target": 1, "idx": 181233}
{"func": "ProcXResQueryResourceBytes (ClientPtr client)\n{\n    REQUEST(xXResQueryResourceBytesReq);\n\n    int                          rc;\n     ConstructResourceBytesCtx    ctx;\n \n     REQUEST_AT_LEAST_SIZE(xXResQueryResourceBytesReq);\n     REQUEST_FIXED_SIZE(xXResQueryResourceBytesReq,\n                        stuff->numSpecs * sizeof(ctx.specs[0]));\n \n                                       (void*) ((char*) stuff +\n                                                sz_xXResQueryResourceBytesReq))) {\n        return BadAlloc;\n    }\n\n    rc = ConstructResourceBytes(stuff->client, &ctx);\n\n    if (rc == Success) {\n        xXResQueryResourceBytesReply rep = {\n            .type = X_Reply,\n            .sequenceNumber = client->sequence,\n            .length = bytes_to_int32(ctx.resultBytes),\n            .numSizes = ctx.numSizes\n        };\n\n        if (client->swapped) {\n            swaps (&rep.sequenceNumber);\n            swapl (&rep.length);\n            swapl (&rep.numSizes);\n\n            SwapXResQueryResourceBytes(&ctx.response);\n        }\n\n        WriteToClient(client, sizeof(rep), &rep);\n        WriteFragmentsToClient(client, &ctx.response);\n    }\n\n    DestroyConstructResourceBytesCtx(&ctx);\n\n    return rc;\n}\n", "target": 1, "idx": 178606}
{"func": "void PasswordAutofillAgent::OnInferredFormSubmission(SubmissionSource source) {\n  if (source == SubmissionSource::FRAME_DETACHED) {\n    OnFrameDetached();\n  } else {\n    SubmissionIndicatorEvent event = ToSubmissionIndicatorEvent(source);\n    if (event == SubmissionIndicatorEvent::NONE)\n      return;\n    FireSubmissionIfFormDisappear(event);\n  }\n}\n", "target": 0, "idx": 150322}
{"func": " void ServerWrapper::OnHttpRequest(int connection_id,\n                                   const net::HttpServerRequestInfo& info) {\n   server_->SetSendBufferSize(connection_id, kSendBufferSizeForDevTools);\n \n   if (base::StartsWith(info.path, \"/json\", base::CompareCase::SENSITIVE)) {\n    BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,\n                            base::BindOnce(&DevToolsHttpHandler::OnJsonRequest,\n                                           handler_, connection_id, info));\n    return;\n  }\n\n  if (info.path.empty() || info.path == \"/\") {\n    BrowserThread::PostTask(\n        BrowserThread::UI, FROM_HERE,\n        base::BindOnce(&DevToolsHttpHandler::OnDiscoveryPageRequest, handler_,\n                       connection_id));\n    return;\n  }\n\n  if (!base::StartsWith(info.path, \"/devtools/\",\n                        base::CompareCase::SENSITIVE)) {\n    server_->Send404(connection_id, kDevtoolsHttpHandlerTrafficAnnotation);\n    return;\n  }\n\n  std::string filename = PathWithoutParams(info.path.substr(10));\n  std::string mime_type = GetMimeType(filename);\n\n  if (!debug_frontend_dir_.empty()) {\n    base::FilePath path = debug_frontend_dir_.AppendASCII(filename);\n    std::string data;\n    base::ReadFileToString(path, &data);\n    server_->Send200(connection_id, data, mime_type,\n                     kDevtoolsHttpHandlerTrafficAnnotation);\n    return;\n  }\n\n  if (bundles_resources_) {\n    BrowserThread::PostTask(\n        BrowserThread::UI, FROM_HERE,\n        base::BindOnce(&DevToolsHttpHandler::OnFrontendResourceRequest,\n                       handler_, connection_id, filename));\n    return;\n  }\n  server_->Send404(connection_id, kDevtoolsHttpHandlerTrafficAnnotation);\n}\n", "target": 1, "idx": 186709}
{"func": "int xstateregs_set(struct task_struct *target, const struct user_regset *regset,\n\t\t  unsigned int pos, unsigned int count,\n\t\t  const void *kbuf, const void __user *ubuf)\n{\n\tstruct fpu *fpu = &target->thread.fpu;\n\tstruct xregs_state *xsave;\n\tint ret;\n\n\tif (!boot_cpu_has(X86_FEATURE_XSAVE))\n\t\treturn -ENODEV;\n\n\t/*\n\t * A whole standard-format XSAVE buffer is needed:\n\t */\n\tif ((pos != 0) || (count < fpu_user_xstate_size))\n\t\treturn -EFAULT;\n\n\txsave = &fpu->state.xsave;\n\n\tfpu__activate_fpstate_write(fpu);\n\n\tif (boot_cpu_has(X86_FEATURE_XSAVES)) {\n\t\tif (kbuf)\n\t\t\tret = copy_kernel_to_xstate(xsave, kbuf);\n\t\telse\n \t\t\tret = copy_user_to_xstate(xsave, ubuf);\n \t} else {\n \t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, xsave, 0, -1);\n \t}\n \n \t/*\n\t * In case of failure, mark all states as init:\n\t */\n\tif (ret)\n\t\tfpstate_init(&fpu->state);\n\n\t/*\n\t * mxcsr reserved bits must be masked to zero for security reasons.\n\t */\n\txsave->i387.mxcsr &= mxcsr_feature_mask;\n\txsave->header.xfeatures &= xfeatures_mask;\n\t/*\n\t * These bits must be zero.\n\t */\n\tmemset(&xsave->header.reserved, 0, 48);\n\n\treturn ret;\n}\n", "target": 1, "idx": 180890}
{"func": "int http_find_next_header(char *sol, struct hdr_idx *idx, struct hdr_ctx *ctx)\n{\n\tchar *eol, *sov;\n\tint cur_idx, old_idx;\n\tint len;\n\n\tcur_idx = ctx->idx;\n\tif (cur_idx) {\n\t\t/* We have previously returned a header, let's search another one */\n\t\tsol = ctx->line;\n\t\teol = sol + idx->v[cur_idx].len;\n\t\tgoto next_hdr;\n\t}\n\n\t/* first request for this header */\n\tsol += hdr_idx_first_pos(idx);\n\told_idx = 0;\n\tcur_idx = hdr_idx_first_idx(idx);\n\twhile (cur_idx) {\n\t\teol = sol + idx->v[cur_idx].len;\n\n\t\tlen = 0;\n\t\twhile (1) {\n\t\t\tif (len >= eol - sol)\n\t\t\t\tgoto next_hdr;\n\t\t\tif (sol[len] == ':')\n\t\t\t\tbreak;\n\t\t\tlen++;\n\t\t}\n\n\t\tctx->del = len;\n\t\tsov = sol + len + 1;\n\t\twhile (sov < eol && HTTP_IS_LWS(*sov))\n\t\t\tsov++;\n\n\t\tctx->line = sol;\n\t\tctx->prev = old_idx;\n\t\tctx->idx  = cur_idx;\n\t\tctx->val  = sov - sol;\n\t\tctx->tws = 0;\n\n\t\twhile (eol > sov && HTTP_IS_LWS(*(eol - 1))) {\n\t\t\teol--;\n\t\t\tctx->tws++;\n\t\t}\n\t\tctx->vlen = eol - sov;\n\t\treturn 1;\n\n\tnext_hdr:\n\t\tsol = eol + idx->v[cur_idx].cr + 1;\n\t\told_idx = cur_idx;\n\t\tcur_idx = idx->v[cur_idx].next;\n\t}\n\treturn 0;\n}\n", "target": 0, "idx": 6824}
{"func": "void PulseAudioMixer::DoGetVolume(GetVolumeCallback* callback,\n                                  void* user) {\n  callback->Run(GetVolumeDb(), user);\n  delete callback;\n}\n", "target": 1, "idx": 184150}
{"func": "static int magicmouse_raw_event(struct hid_device *hdev,\n\t\tstruct hid_report *report, u8 *data, int size)\n{\n\tstruct magicmouse_sc *msc = hid_get_drvdata(hdev);\n\tstruct input_dev *input = msc->input;\n\tint x = 0, y = 0, ii, clicks = 0, npoints;\n\n\tswitch (data[0]) {\n\tcase TRACKPAD_REPORT_ID:\n\t\t/* Expect four bytes of prefix, and N*9 bytes of touch data. */\n \t\tif (size < 4 || ((size - 4) % 9) != 0)\n \t\t\treturn 0;\n \t\tnpoints = (size - 4) / 9;\n \t\tmsc->ntouches = 0;\n \t\tfor (ii = 0; ii < npoints; ii++)\n \t\t\tmagicmouse_emit_touch(msc, ii, data + ii * 9 + 4);\n\n\t\tclicks = data[1];\n\n\t\t/* The following bits provide a device specific timestamp. They\n\t\t * are unused here.\n\t\t *\n\t\t * ts = data[1] >> 6 | data[2] << 2 | data[3] << 10;\n\t\t */\n\t\tbreak;\n\tcase MOUSE_REPORT_ID:\n\t\t/* Expect six bytes of prefix, and N*8 bytes of touch data. */\n \t\tif (size < 6 || ((size - 6) % 8) != 0)\n \t\t\treturn 0;\n \t\tnpoints = (size - 6) / 8;\n \t\tmsc->ntouches = 0;\n \t\tfor (ii = 0; ii < npoints; ii++)\n \t\t\tmagicmouse_emit_touch(msc, ii, data + ii * 8 + 6);\n\n\t\t/* When emulating three-button mode, it is important\n\t\t * to have the current touch information before\n\t\t * generating a click event.\n\t\t */\n\t\tx = (int)(((data[3] & 0x0c) << 28) | (data[1] << 22)) >> 22;\n\t\ty = (int)(((data[3] & 0x30) << 26) | (data[2] << 22)) >> 22;\n\t\tclicks = data[3];\n\n\t\t/* The following bits provide a device specific timestamp. They\n\t\t * are unused here.\n\t\t *\n\t\t * ts = data[3] >> 6 | data[4] << 2 | data[5] << 10;\n\t\t */\n\t\tbreak;\n\tcase DOUBLE_REPORT_ID:\n\t\t/* Sometimes the trackpad sends two touch reports in one\n\t\t * packet.\n\t\t */\n\t\tmagicmouse_raw_event(hdev, report, data + 2, data[1]);\n\t\tmagicmouse_raw_event(hdev, report, data + 2 + data[1],\n\t\t\tsize - 2 - data[1]);\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tif (input->id.product == USB_DEVICE_ID_APPLE_MAGICMOUSE) {\n\t\tmagicmouse_emit_buttons(msc, clicks & 3);\n\t\tinput_report_rel(input, REL_X, x);\n\t\tinput_report_rel(input, REL_Y, y);\n\t} else { /* USB_DEVICE_ID_APPLE_MAGICTRACKPAD */\n\t\tinput_report_key(input, BTN_MOUSE, clicks & 1);\n\t\tinput_mt_report_pointer_emulation(input, true);\n\t}\n\n\tinput_sync(input);\n\treturn 1;\n}\n", "target": 1, "idx": 179551}
{"func": "void AutomationMouseEventProcessor::OnProcessMouseEventACK(\n    bool success,\n    const std::string& error_msg) {\n  InvokeCallback(automation::Error(error_msg));\n}\n", "target": 0, "idx": 126027}
{"func": "SkColor DelegatedFrameHost::GetGutterColor() const {\n  return client_->DelegatedFrameHostGetGutterColor(background_color_);\n}\n", "target": 0, "idx": 163768}
{"func": "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags)\n{\n\tstruct pipe_buffer *ibuf, *obuf;\n\tint ret = 0, nbuf;\n\tbool input_wakeup = false;\n\n\nretry:\n\tret = ipipe_prep(ipipe, flags);\n\tif (ret)\n\t\treturn ret;\n\n\tret = opipe_prep(opipe, flags);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Potential ABBA deadlock, work around it by ordering lock\n\t * grabbing by pipe info address. Otherwise two different processes\n\t * could deadlock (one doing tee from A -> B, the other from B -> A).\n\t */\n\tpipe_double_lock(ipipe, opipe);\n\n\tdo {\n\t\tif (!opipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tif (!ret)\n\t\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!ipipe->nrbufs && !ipipe->writers)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Cannot make any progress, because either the input\n\t\t * pipe is empty or the output pipe is full.\n\t\t */\n\t\tif (!ipipe->nrbufs || opipe->nrbufs >= opipe->buffers) {\n\t\t\t/* Already processed some buffers, break */\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\tif (flags & SPLICE_F_NONBLOCK) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We raced with another reader/writer and haven't\n\t\t\t * managed to process any buffers.  A zero return\n\t\t\t * value means EOF, so retry instead.\n\t\t\t */\n\t\t\tpipe_unlock(ipipe);\n\t\t\tpipe_unlock(opipe);\n\t\t\tgoto retry;\n\t\t}\n\n\t\tibuf = ipipe->bufs + ipipe->curbuf;\n\t\tnbuf = (opipe->curbuf + opipe->nrbufs) & (opipe->buffers - 1);\n\t\tobuf = opipe->bufs + nbuf;\n\n\t\tif (len >= ibuf->len) {\n\t\t\t/*\n\t\t\t * Simply move the whole buffer from ipipe to opipe\n\t\t\t */\n\t\t\t*obuf = *ibuf;\n\t\t\tibuf->ops = NULL;\n\t\t\topipe->nrbufs++;\n\t\t\tipipe->curbuf = (ipipe->curbuf + 1) & (ipipe->buffers - 1);\n\t\t\tipipe->nrbufs--;\n\t\t\tinput_wakeup = true;\n\t\t} else {\n\t\t\t/*\n \t\t\t * Get a reference to this pipe buffer,\n \t\t\t * so we can copy the contents over.\n \t\t\t */\n\t\t\tpipe_buf_get(ipipe, ibuf);\n \t\t\t*obuf = *ibuf;\n \n \t\t\t/*\n\t\t\t * Don't inherit the gift flag, we need to\n\t\t\t * prevent multiple steals of this page.\n\t\t\t */\n\t\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n\n\t\t\tobuf->len = len;\n\t\t\topipe->nrbufs++;\n\t\t\tibuf->offset += obuf->len;\n\t\t\tibuf->len -= obuf->len;\n\t\t}\n\t\tret += obuf->len;\n\t\tlen -= obuf->len;\n\t} while (len);\n\n\tpipe_unlock(ipipe);\n\tpipe_unlock(opipe);\n\n\t/*\n\t * If we put data in the output pipe, wakeup any potential readers.\n\t */\n\tif (ret > 0)\n\t\twakeup_pipe_readers(opipe);\n\n\tif (input_wakeup)\n\t\twakeup_pipe_writers(ipipe);\n\n\treturn ret;\n}\n", "target": 1, "idx": 183403}
{"func": "test_function (char * (*my_asnprintf) (char *, size_t *, const char *, ...))\n{\n  char buf[8];\n  int size;\n\n  for (size = 0; size <= 8; size++)\n    {\n      size_t length = size;\n      char *result = my_asnprintf (NULL, &length, \"%d\", 12345);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"12345\") == 0);\n      ASSERT (length == 5);\n      free (result);\n    }\n\n  for (size = 0; size <= 8; size++)\n    {\n      size_t length;\n      char *result;\n\n      memcpy (buf, \"DEADBEEF\", 8);\n      length = size;\n      result = my_asnprintf (buf, &length, \"%d\", 12345);\n       ASSERT (result != NULL);\n       ASSERT (strcmp (result, \"12345\") == 0);\n       ASSERT (length == 5);\n      if (size < 6)\n         ASSERT (result != buf);\n       ASSERT (memcmp (buf + size, &\"DEADBEEF\"[size], 8 - size) == 0);\n       if (result != buf)\n        free (result);\n    }\n}\n", "target": 1, "idx": 182186}
{"func": "static Image *ReadEXRImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  const ImfHeader\n    *hdr_info;\n\n  Image\n    *image;\n\n  ImageInfo\n    *read_info;\n\n  ImfInputFile\n    *file;\n\n  ImfRgba\n    *scanline;\n\n  int\n    max_x,\n    max_y,\n    min_x,\n    min_y;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    x;\n\n  register PixelPacket\n    *q;\n\n  ssize_t\n    y;\n\n  /*\n    Open image.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  read_info=CloneImageInfo(image_info);\n  if (IsPathAccessible(read_info->filename) == MagickFalse)\n    {\n      (void) AcquireUniqueFilename(read_info->filename);\n      (void) ImageToFile(image,read_info->filename,exception);\n    }\n  file=ImfOpenInputFile(read_info->filename);\n  if (file == (ImfInputFile *) NULL)\n    {\n      ThrowFileException(exception,BlobError,\"UnableToOpenBlob\",\n        ImfErrorMessage());\n      if (LocaleCompare(image_info->filename,read_info->filename) != 0)\n        (void) RelinquishUniqueFileResource(read_info->filename);\n      read_info=DestroyImageInfo(read_info);\n      return((Image *) NULL);\n    }\n  hdr_info=ImfInputHeader(file);\n  ImfHeaderDisplayWindow(hdr_info,&min_x,&min_y,&max_x,&max_y);\n  image->columns=max_x-min_x+1UL;\n  image->rows=max_y-min_y+1UL;\n  image->matte=MagickTrue;\n  SetImageColorspace(image,RGBColorspace);\n  if (image_info->ping != MagickFalse)\n    {\n      (void) ImfCloseInputFile(file);\n      if (LocaleCompare(image_info->filename,read_info->filename) != 0)\n        (void) RelinquishUniqueFileResource(read_info->filename);\n      read_info=DestroyImageInfo(read_info);\n       (void) CloseBlob(image);\n       return(GetFirstImageInList(image));\n     }\n   scanline=(ImfRgba *) AcquireQuantumMemory(image->columns,sizeof(*scanline));\n   if (scanline == (ImfRgba *) NULL)\n     {\n      (void) ImfCloseInputFile(file);\n      if (LocaleCompare(image_info->filename,read_info->filename) != 0)\n        (void) RelinquishUniqueFileResource(read_info->filename);\n      read_info=DestroyImageInfo(read_info);\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      break;\n    ResetMagickMemory(scanline,0,image->columns*sizeof(*scanline));\n    ImfInputSetFrameBuffer(file,scanline-min_x-image->columns*(min_y+y),1,\n      image->columns);\n    ImfInputReadPixels(file,min_y+y,min_y+y);\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      SetPixelRed(q,ClampToQuantum((MagickRealType) QuantumRange*\n        ImfHalfToFloat(scanline[x].r)));\n      SetPixelGreen(q,ClampToQuantum((MagickRealType) QuantumRange*\n        ImfHalfToFloat(scanline[x].g)));\n      SetPixelBlue(q,ClampToQuantum((MagickRealType) QuantumRange*\n        ImfHalfToFloat(scanline[x].b)));\n      SetPixelAlpha(q,ClampToQuantum((MagickRealType) QuantumRange*\n        ImfHalfToFloat(scanline[x].a)));\n      q++;\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n  }\n  scanline=(ImfRgba *) RelinquishMagickMemory(scanline);\n  (void) ImfCloseInputFile(file);\n  if (LocaleCompare(image_info->filename,read_info->filename) != 0)\n    (void) RelinquishUniqueFileResource(read_info->filename);\n  read_info=DestroyImageInfo(read_info);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n", "target": 1, "idx": 181735}
{"func": " bool WebContentsImpl::IsLoading() const {\n   return frame_tree_.IsLoading() &&\n         !(ShowingInterstitialPage() &&\n           GetRenderManager()->interstitial_page()->pause_throbber());\n }\n", "target": 1, "idx": 186299}
{"func": " TranslateInfoBarDelegate* TranslateManager::GetTranslateInfoBarDelegate(\n     TabContents* tab) {\n   for (int i = 0; i < tab->infobar_delegate_count(); ++i) {\n    InfoBarDelegate* delegate = tab->GetInfoBarDelegateAt(i);\n    if (!delegate) {\n      NOTREACHED();\n      continue;\n    }\n    TranslateInfoBarDelegate* translate_delegate =\n        delegate->AsTranslateInfoBarDelegate();\n    if (translate_delegate)\n      return translate_delegate;\n   }\n   return NULL;\n }\n", "target": 1, "idx": 183436}
{"func": "v8::Handle<v8::Value> V8TestObj::constructorCallback(const v8::Arguments& args)\n{\n    INC_STATS(\"DOM.TestObj.Constructor\");\n\n    if (!args.IsConstructCall())\n        return V8Proxy::throwTypeError(\"DOM object constructor cannot be called as a function.\");\n\n     if (ConstructorMode::current() == ConstructorMode::WrapExistingObject)\n         return args.Holder();\n     if (args.Length() < 1)\n        return V8Proxy::throwNotEnoughArgumentsError();\n     if (args.Length() <= 0 || !args[0]->IsFunction())\n         return throwError(TYPE_MISMATCH_ERR, args.GetIsolate());\n     RefPtr<TestCallback> testCallback = V8TestCallback::create(args[0], getScriptExecutionContext());\n\n    RefPtr<TestObj> impl = TestObj::create(testCallback);\n    v8::Handle<v8::Object> wrapper = args.Holder();\n\n    V8DOMWrapper::setDOMWrapper(wrapper, &info, impl.get());\n    V8DOMWrapper::setJSWrapperForDOMObject(impl.release(), v8::Persistent<v8::Object>::New(wrapper), args.GetIsolate());\n    return args.Holder();\n}\n", "target": 1, "idx": 184768}
{"func": "static void ssl_check_for_safari(SSL *s, const unsigned char *data,\n                                 const unsigned char *limit)\n{\n    unsigned short type, size;\n    static const unsigned char kSafariExtensionsBlock[] = {\n        0x00, 0x0a,             /* elliptic_curves extension */\n        0x00, 0x08,             /* 8 bytes */\n        0x00, 0x06,             /* 6 bytes of curve ids */\n        0x00, 0x17,             /* P-256 */\n        0x00, 0x18,             /* P-384 */\n        0x00, 0x19,             /* P-521 */\n\n        0x00, 0x0b,             /* ec_point_formats */\n        0x00, 0x02,             /* 2 bytes */\n        0x01,                   /* 1 point format */\n        0x00,                   /* uncompressed */\n    };\n\n    /* The following is only present in TLS 1.2 */\n    static const unsigned char kSafariTLS12ExtensionsBlock[] = {\n        0x00, 0x0d,             /* signature_algorithms */\n        0x00, 0x0c,             /* 12 bytes */\n        0x00, 0x0a,             /* 10 bytes */\n        0x05, 0x01,             /* SHA-384/RSA */\n        0x04, 0x01,             /* SHA-256/RSA */\n        0x02, 0x01,             /* SHA-1/RSA */\n        0x04, 0x03,             /* SHA-256/ECDSA */\n         0x02, 0x03,             /* SHA-1/ECDSA */\n     };\n \n    if (data >= (limit - 2))\n         return;\n     data += 2;\n \n    if (data > (limit - 4))\n         return;\n     n2s(data, type);\n     n2s(data, size);\n\n     if (type != TLSEXT_TYPE_server_name)\n         return;\n \n    if (data + size > limit)\n         return;\n     data += size;\n \n    if (TLS1_get_client_version(s) >= TLS1_2_VERSION) {\n         const size_t len1 = sizeof(kSafariExtensionsBlock);\n         const size_t len2 = sizeof(kSafariTLS12ExtensionsBlock);\n \n        if (data + len1 + len2 != limit)\n             return;\n         if (memcmp(data, kSafariExtensionsBlock, len1) != 0)\n             return;\n        if (memcmp(data + len1, kSafariTLS12ExtensionsBlock, len2) != 0)\n            return;\n     } else {\n         const size_t len = sizeof(kSafariExtensionsBlock);\n \n        if (data + len != limit)\n             return;\n         if (memcmp(data, kSafariExtensionsBlock, len) != 0)\n             return;\n    }\n\n    s->s3->is_probably_safari = 1;\n}\n", "target": 1, "idx": 178374}
{"func": " bool TranslateInfoBarDelegate::IsTranslatableLanguageByPrefs() {\n  Profile* profile =\n      Profile::FromBrowserContext(GetWebContents()->GetBrowserContext());\n  Profile* original_profile = profile->GetOriginalProfile();\n   scoped_ptr<TranslatePrefs> translate_prefs(\n      TranslateTabHelper::CreateTranslatePrefs(original_profile->GetPrefs()));\n   TranslateAcceptLanguages* accept_languages =\n      TranslateTabHelper::GetTranslateAcceptLanguages(original_profile);\n   return translate_prefs->CanTranslateLanguage(accept_languages,\n                                                original_language_code());\n }\n", "target": 1, "idx": 184866}
{"func": "void ContentSecurityPolicy::reportAccumulatedHeaders(\n    LocalFrameClient* client) const {\n  DCHECK(client);\n  for (const auto& policy : m_policies) {\n    client->didAddContentSecurityPolicy(\n        policy->header(), policy->headerType(), policy->headerSource(),\n        {policy->exposeForNavigationalChecks()});\n  }\n}\n", "target": 0, "idx": 149459}
{"func": "SPL_METHOD(DirectoryIterator, next)\n {\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n \tint skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS);\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n\n\tintern->u.dir.index++;\n\tdo {\n\t\tspl_filesystem_dir_read(intern TSRMLS_CC);\n\t} while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));\n\tif (intern->file_name) {\n\t\tefree(intern->file_name);\n\t\tintern->file_name = NULL;\n\t}\n}\n", "target": 1, "idx": 180201}
{"func": "jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)\n{\n\tjas_image_t *image;\n\tbmp_hdr_t hdr;\n\tbmp_info_t *info;\n\tuint_fast16_t cmptno;\n\tjas_image_cmptparm_t cmptparms[3];\n \tjas_image_cmptparm_t *cmptparm;\n \tuint_fast16_t numcmpts;\n \tlong n;\n \n \timage = 0;\n \tinfo = 0;\n \n\tif (optstr) {\n\t\tjas_eprintf(\"warning: ignoring BMP decoder options\\n\");\n \t}\n \n \tjas_eprintf(\n\t  \"THE BMP FORMAT IS NOT FULLY SUPPORTED!\\n\"\n\t  \"THAT IS, THE JASPER SOFTWARE CANNOT DECODE ALL TYPES OF BMP DATA.\\n\"\n\t  \"IF YOU HAVE ANY PROBLEMS, PLEASE TRY CONVERTING YOUR IMAGE DATA\\n\"\n\t  \"TO THE PNM FORMAT, AND USING THIS FORMAT INSTEAD.\\n\"\n\t  );\n\n\t/* Read the bitmap header. */\n \tif (bmp_gethdr(in, &hdr)) {\n \t\tjas_eprintf(\"cannot get header\\n\");\n \t\tgoto error;\n \tJAS_DBGLOG(1, (\n \t  \"BMP header: magic 0x%x; siz %d; res1 %d; res2 %d; off %d\\n\",\n\t  hdr.magic, hdr.siz, hdr.reserved1, hdr.reserved2, hdr.off\n\t  ));\n\n \t/* Read the bitmap information. */\n \tif (!(info = bmp_getinfo(in))) {\n \t\tjas_eprintf(\"cannot get info\\n\");\n \t}\n \tJAS_DBGLOG(1,\n\t  (\"BMP information: len %ld; width %ld; height %ld; numplanes %d; \"\n\t  \"depth %d; enctype %ld; siz %ld; hres %ld; vres %ld; numcolors %ld; \"\n\t  \"mincolors %ld\\n\", JAS_CAST(long, info->len),\n\t  JAS_CAST(long, info->width), JAS_CAST(long, info->height),\n\t  JAS_CAST(long, info->numplanes), JAS_CAST(long, info->depth),\n\t  JAS_CAST(long, info->enctype), JAS_CAST(long, info->siz),\n\t  JAS_CAST(long, info->hres), JAS_CAST(long, info->vres),\n\t  JAS_CAST(long, info->numcolors), JAS_CAST(long, info->mincolors)));\n\n\tif (info->width < 0 || info->height < 0 || info->numplanes < 0 ||\n\t  info->depth < 0 || info->siz < 0 || info->hres < 0 || info->vres < 0) {\n\t\tjas_eprintf(\"corrupt bit stream\\n\");\n \t\tgoto error;\n \t}\n \n \t/* Ensure that we support this type of BMP file. */\n \tif (!bmp_issupported(&hdr, info)) {\n \t\tjas_eprintf(\"error: unsupported BMP encoding\\n\");\n \t}\n \n\t/* Skip over any useless data between the end of the palette\n\t  and start of the bitmap data. */\n \tif ((n = hdr.off - (BMP_HDRLEN + BMP_INFOLEN + BMP_PALLEN(info))) < 0) {\n \t\tjas_eprintf(\"error: possibly bad bitmap offset?\\n\");\n \t\tgoto error;\n \tif (n > 0) {\n \t\tjas_eprintf(\"skipping unknown data in BMP file\\n\");\n \t\tif (bmp_gobble(in, n)) {\n \t\t}\n \t}\n\n\t/* Get the number of components. */\n\tnumcmpts = bmp_numcmpts(info);\n\n\tfor (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,\n\t  ++cmptparm) {\n\t\tcmptparm->tlx = 0;\n\t\tcmptparm->tly = 0;\n\t\tcmptparm->hstep = 1;\n\t\tcmptparm->vstep = 1;\n\t\tcmptparm->width = info->width;\n\t\tcmptparm->height = info->height;\n\t\tcmptparm->prec = 8;\n\t\tcmptparm->sgnd = false;\n\t}\n\n \t/* Create image object. */\n \tif (!(image = jas_image_create(numcmpts, cmptparms,\n \t  JAS_CLRSPC_UNKNOWN))) {\n \t}\n \n\tif (numcmpts == 3) {\n\t\tjas_image_setclrspc(image, JAS_CLRSPC_SRGB);\n\t\tjas_image_setcmpttype(image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R));\n\t\tjas_image_setcmpttype(image, 1,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G));\n\t\tjas_image_setcmpttype(image, 2,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B));\n\t} else {\n\t\tjas_image_setclrspc(image, JAS_CLRSPC_SGRAY);\n\t\tjas_image_setcmpttype(image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y));\n\t}\n \n \t/* Read the bitmap data. */\n \tif (bmp_getdata(in, info, image)) {\n \t}\n \n\tbmp_info_destroy(info);\n\n\treturn image;\n\nerror:\n\tif (info) {\n\t\tbmp_info_destroy(info);\n\t}\n\tif (image) {\n\t\tjas_image_destroy(image);\n\t}\n\treturn 0;\n}\n", "target": 1, "idx": 181885}
{"func": "bool SendAutomationJSONRequest(AutomationMessageSender* sender,\n                               const DictionaryValue& request_dict,\n                               DictionaryValue* reply_dict,\n                                std::string* error_msg) {\n   std::string request, reply;\n   base::JSONWriter::Write(&request_dict, false, &request);\n  bool success = false;\n  int timeout_ms = TestTimeouts::action_max_timeout_ms();\n   base::Time before_sending = base::Time::Now();\n  if (!SendAutomationJSONRequest(\n          sender, request, timeout_ms, &reply, &success)) {\n    int64 elapsed_ms = (base::Time::Now() - before_sending).InMilliseconds();\n    std::string command;\n    request_dict.GetString(\"command\", &command);\n    if (elapsed_ms >= timeout_ms) {\n      *error_msg = base::StringPrintf(\n          \"Chrome did not respond to '%s'. Request may have timed out. \"\n              \"Elapsed time was %\" PRId64 \" ms. Request timeout was %d ms. \"\n              \"Request details: (%s).\",\n          command.c_str(),\n          elapsed_ms,\n          timeout_ms,\n          request.c_str());\n    } else {\n      *error_msg = base::StringPrintf(\n          \"Chrome did not respond to '%s'. Elapsed time was %\" PRId64 \" ms. \"\n              \"Request details: (%s).\",\n          command.c_str(),\n          elapsed_ms,\n          request.c_str());\n    }\n     return false;\n   }\n   scoped_ptr<Value> value(base::JSONReader::Read(reply, true));\n   if (!value.get() || !value->IsType(Value::TYPE_DICTIONARY)) {\n    std::string command;\n    request_dict.GetString(\"command\", &command);\n     LOG(ERROR) << \"JSON request did not return dict: \" << command << \"\\n\";\n     return false;\n   }\n   DictionaryValue* dict = static_cast<DictionaryValue*>(value.get());\n   if (!success) {\n    std::string command, error;\n    request_dict.GetString(\"command\", &command);\n     dict->GetString(\"error\", &error);\n     *error_msg = base::StringPrintf(\n         \"Internal Chrome error during '%s': (%s). Request details: (%s).\",\n        command.c_str(),\n        error.c_str(),\n        request.c_str());\n    LOG(ERROR) << \"JSON request failed: \" << command << \"\\n\"\n               << \"    with error: \" << error;\n    return false;\n  }\n  reply_dict->MergeDictionary(dict);\n  return true;\n}\n", "target": 1, "idx": 183908}
{"func": "void ResourceMessageFilter::OnClipboardReadAsciiText(Clipboard::Buffer buffer,\n                                                     IPC::Message* reply) {\n  std::string result;\n  GetClipboard()->ReadAsciiText(buffer, &result);\n  ViewHostMsg_ClipboardReadAsciiText::WriteReplyParams(reply, result);\n  Send(reply);\n}\n", "target": 0, "idx": 99277}
{"func": "int sc_bin_to_hex(const u8 *in, size_t in_len, char *out, size_t out_len,\n\t\t  int in_sep)\n{\n\tunsigned int\tn, sep_len;\n\tchar\t\t*pos, *end, sep;\n\n\tsep = (char)in_sep;\n\tsep_len = sep > 0 ? 1 : 0;\n\tpos = out;\n\tend = out + out_len;\n\tfor (n = 0; n < in_len; n++) {\n\t\tif (pos + 3 + sep_len >= end)\n\t\t\treturn SC_ERROR_BUFFER_TOO_SMALL;\n\t\tif (n && sep_len)\n\t\t\t*pos++ = sep;\n\t\tsprintf(pos, \"%02x\", in[n]);\n\t\tpos += 2;\n\t}\n\t*pos = '\\0';\n\treturn SC_SUCCESS;\n}\n", "target": 0, "idx": 78824}
{"func": "standard_test(png_store* PNG_CONST psIn, png_uint_32 PNG_CONST id,\n    int do_interlace, int use_update_info)\n {\n    standard_display d;\n   context(psIn, fault);\n\n /* Set up the display (stack frame) variables from the arguments to the\n    * function and initialize the locals that are filled in later.\n    */\n   standard_display_init(&d, psIn, id, do_interlace, use_update_info);\n\n /* Everything is protected by a Try/Catch.  The functions called also\n    * typically have local Try/Catch blocks.\n    */\n Try\n {\n      png_structp pp;\n      png_infop pi;\n\n /* Get a png_struct for reading the image. This will throw an error if it\n       * fails, so we don't need to check the result.\n       */\n      pp = set_store_for_read(d.ps, &pi, d.id,\n         d.do_interlace ? (d.ps->progressive ?\n \"pngvalid progressive deinterlacer\" :\n \"pngvalid sequential deinterlacer\") : (d.ps->progressive ?\n \"progressive reader\" : \"sequential reader\"));\n\n /* Initialize the palette correctly from the png_store_file. */\n      standard_palette_init(&d);\n\n /* Introduce the correct read function. */\n if (d.ps->progressive)\n {\n         png_set_progressive_read_fn(pp, &d, standard_info, progressive_row,\n            standard_end);\n\n /* Now feed data into the reader until we reach the end: */\n         store_progressive_read(d.ps, pp, pi);\n }\n else\n {\n /* Note that this takes the store, not the display. */\n         png_set_read_fn(pp, d.ps, store_read);\n\n /* Check the header values: */\n         png_read_info(pp, pi);\n\n /* The code tests both versions of the images that the sequential\n          * reader can produce.\n          */\n         standard_info_imp(&d, pp, pi, 2 /*images*/);\n\n /* Need the total bytes in the image below; we can't get to this point\n          * unless the PNG file values have been checked against the expected\n          * values.\n          */\n {\n            sequential_row(&d, pp, pi, 0, 1);\n\n /* After the last pass loop over the rows again to check that the\n             * image is correct.\n             */\n if (!d.speed)\n {\n               standard_text_validate(&d, pp, pi, 1/*check_end*/);\n               standard_image_validate(&d, pp, 0, 1);\n }\n else\n               d.ps->validated = 1;\n }\n }\n\n /* Check for validation. */\n if (!d.ps->validated)\n         png_error(pp, \"image read failed silently\");\n\n /* Successful completion. */\n }\n\n Catch(fault)\n      d.ps = fault; /* make sure this hasn't been clobbered. */\n\n /* In either case clean up the store. */\n   store_read_reset(d.ps);\n\n }\n", "target": 1, "idx": 187724}
{"func": "void WebContentsImpl::OnMediaNotification(int64 player_cookie,\n                                          bool has_video,\n                                          bool has_audio,\n                                          bool is_playing) {\n#if !defined(OS_CHROMEOS)\n  if (is_playing) {\n    scoped_ptr<PowerSaveBlocker> blocker;\n    if (has_video) {\n      blocker = PowerSaveBlocker::Create(\n          PowerSaveBlocker::kPowerSaveBlockPreventDisplaySleep,\n          \"Playing video\");\n#if defined(OS_ANDROID)\n      static_cast<PowerSaveBlockerImpl*>(blocker.get())->\n          InitDisplaySleepBlocker(GetView()->GetNativeView());\n#endif\n    } else if (has_audio) {\n      blocker = PowerSaveBlocker::Create(\n          PowerSaveBlocker::kPowerSaveBlockPreventAppSuspension,\n          \"Playing audio\");\n    }\n\n    if (blocker)\n      power_save_blockers_[message_source_][player_cookie] = blocker.release();\n  } else {\n    delete power_save_blockers_[message_source_][player_cookie];\n    power_save_blockers_[message_source_].erase(player_cookie);\n  }\n#endif  // !defined(OS_CHROMEOS)\n}\n", "target": 0, "idx": 118989}
{"func": "void databasesCron(void) {\n    /* Expire keys by random sampling. Not required for slaves\n     * as master will synthesize DELs for us. */\n    if (server.active_expire_enabled && server.masterhost == NULL)\n        activeExpireCycle(ACTIVE_EXPIRE_CYCLE_SLOW);\n\n    /* Perform hash tables rehashing if needed, but only if there are no\n     * other processes saving the DB on disk. Otherwise rehashing is bad\n     * as will cause a lot of copy-on-write of memory pages. */\n    if (server.rdb_child_pid == -1 && server.aof_child_pid == -1) {\n        /* We use global counters so if we stop the computation at a given\n         * DB we'll be able to start from the successive in the next\n         * cron loop iteration. */\n        static unsigned int resize_db = 0;\n        static unsigned int rehash_db = 0;\n        int dbs_per_call = CRON_DBS_PER_CALL;\n        int j;\n\n        /* Don't test more DBs than we have. */\n        if (dbs_per_call > server.dbnum) dbs_per_call = server.dbnum;\n\n        /* Resize */\n        for (j = 0; j < dbs_per_call; j++) {\n            tryResizeHashTables(resize_db % server.dbnum);\n            resize_db++;\n        }\n\n        /* Rehash */\n        if (server.activerehashing) {\n            for (j = 0; j < dbs_per_call; j++) {\n                int work_done = incrementallyRehash(rehash_db % server.dbnum);\n                rehash_db++;\n                if (work_done) {\n                    /* If the function did some work, stop here, we'll do\n                     * more at the next cron loop. */\n                    break;\n                }\n            }\n        }\n    }\n}\n", "target": 0, "idx": 70011}
{"func": "void StorageHandler::SetRenderer(RenderProcessHost* process_host,\n                                  RenderFrameHostImpl* frame_host) {\n  process_ = process_host;\n }\n", "target": 1, "idx": 186751}
{"func": " PasswordGenerationDialogViewInterface::Create(\n    PasswordAccessoryController* controller) {\n   return std::make_unique<PasswordGenerationDialogViewAndroid>(controller);\n }\n", "target": 1, "idx": 186019}
{"func": "  void VerifyDailyContentLengthPrefLists(\n       const int64* original_values, size_t original_count,\n       const int64* received_values, size_t received_count,\n       const int64* original_with_data_reduction_proxy_enabled_values,\n      size_t original_with_data_reduction_proxy_enabled_count,\n      const int64* received_with_data_reduction_proxy_enabled_values,\n      size_t received_with_data_reduction_proxy_count,\n      const int64* original_via_data_reduction_proxy_values,\n      size_t original_via_data_reduction_proxy_count,\n      const int64* received_via_data_reduction_proxy_values,\n      size_t received_via_data_reduction_proxy_count) {\n    VerifyPrefList(prefs::kDailyHttpOriginalContentLength,\n                   original_values, original_count);\n    VerifyPrefList(prefs::kDailyHttpReceivedContentLength,\n                   received_values, received_count);\n    VerifyPrefList(\n        prefs::kDailyOriginalContentLengthWithDataReductionProxyEnabled,\n        original_with_data_reduction_proxy_enabled_values,\n        original_with_data_reduction_proxy_enabled_count);\n    VerifyPrefList(\n        prefs::kDailyContentLengthWithDataReductionProxyEnabled,\n        received_with_data_reduction_proxy_enabled_values,\n        received_with_data_reduction_proxy_count);\n    VerifyPrefList(\n        prefs::kDailyOriginalContentLengthViaDataReductionProxy,\n        original_via_data_reduction_proxy_values,\n        original_via_data_reduction_proxy_count);\n    VerifyPrefList(\n        prefs::kDailyContentLengthViaDataReductionProxy,\n        received_via_data_reduction_proxy_values,\n         received_via_data_reduction_proxy_count);\n   }\n", "target": 1, "idx": 185028}
{"func": "static const char *get_rmode(__le16 mode)\n{\n        switch(mode & RXMODE_MASK) {\n        case RXMODE_RFMON:  return \"rfmon\";\n        case RXMODE_RFMON_ANYBSS:  return \"yna (any) bss rfmon\";\n        case RXMODE_LANMON:  return \"lanmon\";\n        }\n        return \"ESS\";\n}\n", "target": 0, "idx": 24034}
{"func": "GlobalHistogramAllocator* GlobalHistogramAllocator::Get() {\n  return reinterpret_cast<GlobalHistogramAllocator*>(\n      subtle::Acquire_Load(&g_histogram_allocator));\n}\n", "target": 0, "idx": 143795}
{"func": " _TIFFmalloc(tsize_t s)\n {\n \treturn (malloc((size_t) s));\n }\n", "target": 1, "idx": 182632}
{"func": "NPObject* WebPluginProxy::GetWindowScriptNPObject() {\n  if (window_npobject_)\n    return WebBindings::retainObject(window_npobject_);\n \n   int npobject_route_id = channel_->GenerateRouteID();\n   bool success = false;\n  intptr_t npobject_ptr = NULL;\n   Send(new PluginHostMsg_GetWindowScriptNPObject(\n      route_id_, npobject_route_id, &success, &npobject_ptr));\n   if (!success)\n     return NULL;\n \n  window_npobject_ = NPObjectProxy::Create(\n      channel_, npobject_route_id, containing_window_, page_url_);\n\n  return window_npobject_;\n}\n", "target": 1, "idx": 183564}
{"func": "brcmf_cfg80211_start_ap(struct wiphy *wiphy, struct net_device *ndev,\n\t\t\tstruct cfg80211_ap_settings *settings)\n{\n\ts32 ie_offset;\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\tconst struct brcmf_tlv *ssid_ie;\n\tconst struct brcmf_tlv *country_ie;\n\tstruct brcmf_ssid_le ssid_le;\n\ts32 err = -EPERM;\n\tconst struct brcmf_tlv *rsn_ie;\n\tconst struct brcmf_vs_tlv *wpa_ie;\n\tstruct brcmf_join_params join_params;\n\tenum nl80211_iftype dev_role;\n\tstruct brcmf_fil_bss_enable_le bss_enable;\n\tu16 chanspec = chandef_to_chanspec(&cfg->d11inf, &settings->chandef);\n\tbool mbss;\n\tint is_11d;\n\n\tbrcmf_dbg(TRACE, \"ctrlchn=%d, center=%d, bw=%d, beacon_interval=%d, dtim_period=%d,\\n\",\n\t\t  settings->chandef.chan->hw_value,\n\t\t  settings->chandef.center_freq1, settings->chandef.width,\n\t\t  settings->beacon_interval, settings->dtim_period);\n\tbrcmf_dbg(TRACE, \"ssid=%s(%zu), auth_type=%d, inactivity_timeout=%d\\n\",\n\t\t  settings->ssid, settings->ssid_len, settings->auth_type,\n\t\t  settings->inactivity_timeout);\n\tdev_role = ifp->vif->wdev.iftype;\n\tmbss = ifp->vif->mbss;\n\n\t/* store current 11d setting */\n\tbrcmf_fil_cmd_int_get(ifp, BRCMF_C_GET_REGULATORY, &ifp->vif->is_11d);\n\tcountry_ie = brcmf_parse_tlvs((u8 *)settings->beacon.tail,\n\t\t\t\t      settings->beacon.tail_len,\n\t\t\t\t      WLAN_EID_COUNTRY);\n\tis_11d = country_ie ? 1 : 0;\n\n\tmemset(&ssid_le, 0, sizeof(ssid_le));\n\tif (settings->ssid == NULL || settings->ssid_len == 0) {\n\t\tie_offset = DOT11_MGMT_HDR_LEN + DOT11_BCN_PRB_FIXED_LEN;\n\t\tssid_ie = brcmf_parse_tlvs(\n \t\t\t\t(u8 *)&settings->beacon.head[ie_offset],\n \t\t\t\tsettings->beacon.head_len - ie_offset,\n \t\t\t\tWLAN_EID_SSID);\n\t\tif (!ssid_ie)\n \t\t\treturn -EINVAL;\n \n \t\tmemcpy(ssid_le.SSID, ssid_ie->data, ssid_ie->len);\n\t\tssid_le.SSID_len = cpu_to_le32(ssid_ie->len);\n\t\tbrcmf_dbg(TRACE, \"SSID is (%s) in Head\\n\", ssid_le.SSID);\n\t} else {\n\t\tmemcpy(ssid_le.SSID, settings->ssid, settings->ssid_len);\n\t\tssid_le.SSID_len = cpu_to_le32((u32)settings->ssid_len);\n\t}\n\n\tif (!mbss) {\n\t\tbrcmf_set_mpc(ifp, 0);\n\t\tbrcmf_configure_arp_nd_offload(ifp, false);\n\t}\n\n\t/* find the RSN_IE */\n\trsn_ie = brcmf_parse_tlvs((u8 *)settings->beacon.tail,\n\t\t\t\t  settings->beacon.tail_len, WLAN_EID_RSN);\n\n\t/* find the WPA_IE */\n\twpa_ie = brcmf_find_wpaie((u8 *)settings->beacon.tail,\n\t\t\t\t  settings->beacon.tail_len);\n\n\tif ((wpa_ie != NULL || rsn_ie != NULL)) {\n\t\tbrcmf_dbg(TRACE, \"WPA(2) IE is found\\n\");\n\t\tif (wpa_ie != NULL) {\n\t\t\t/* WPA IE */\n\t\t\terr = brcmf_configure_wpaie(ifp, wpa_ie, false);\n\t\t\tif (err < 0)\n\t\t\t\tgoto exit;\n\t\t} else {\n\t\t\tstruct brcmf_vs_tlv *tmp_ie;\n\n\t\t\ttmp_ie = (struct brcmf_vs_tlv *)rsn_ie;\n\n\t\t\t/* RSN IE */\n\t\t\terr = brcmf_configure_wpaie(ifp, tmp_ie, true);\n\t\t\tif (err < 0)\n\t\t\t\tgoto exit;\n\t\t}\n\t} else {\n\t\tbrcmf_dbg(TRACE, \"No WPA(2) IEs found\\n\");\n\t\tbrcmf_configure_opensecurity(ifp);\n\t}\n\n\tbrcmf_config_ap_mgmt_ie(ifp->vif, &settings->beacon);\n\n\t/* Parameters shared by all radio interfaces */\n\tif (!mbss) {\n\t\tif (is_11d != ifp->vif->is_11d) {\n\t\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_REGULATORY,\n\t\t\t\t\t\t    is_11d);\n\t\t\tif (err < 0) {\n\t\t\t\tbrcmf_err(\"Regulatory Set Error, %d\\n\", err);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\tif (settings->beacon_interval) {\n\t\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_BCNPRD,\n\t\t\t\t\t\t    settings->beacon_interval);\n\t\t\tif (err < 0) {\n\t\t\t\tbrcmf_err(\"Beacon Interval Set Error, %d\\n\",\n\t\t\t\t\t  err);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\tif (settings->dtim_period) {\n\t\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_DTIMPRD,\n\t\t\t\t\t\t    settings->dtim_period);\n\t\t\tif (err < 0) {\n\t\t\t\tbrcmf_err(\"DTIM Interval Set Error, %d\\n\", err);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\n\t\tif ((dev_role == NL80211_IFTYPE_AP) &&\n\t\t    ((ifp->ifidx == 0) ||\n\t\t     !brcmf_feat_is_enabled(ifp, BRCMF_FEAT_RSDB))) {\n\t\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_DOWN, 1);\n\t\t\tif (err < 0) {\n\t\t\t\tbrcmf_err(\"BRCMF_C_DOWN error %d\\n\", err);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tbrcmf_fil_iovar_int_set(ifp, \"apsta\", 0);\n\t\t}\n\n\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_INFRA, 1);\n\t\tif (err < 0) {\n\t\t\tbrcmf_err(\"SET INFRA error %d\\n\", err);\n\t\t\tgoto exit;\n\t\t}\n\t} else if (WARN_ON(is_11d != ifp->vif->is_11d)) {\n\t\t/* Multiple-BSS should use same 11d configuration */\n\t\terr = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\t/* Interface specific setup */\n\tif (dev_role == NL80211_IFTYPE_AP) {\n\t\tif ((brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MBSS)) && (!mbss))\n\t\t\tbrcmf_fil_iovar_int_set(ifp, \"mbss\", 1);\n\n\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_AP, 1);\n\t\tif (err < 0) {\n\t\t\tbrcmf_err(\"setting AP mode failed %d\\n\", err);\n\t\t\tgoto exit;\n\t\t}\n\t\tif (!mbss) {\n\t\t\t/* Firmware 10.x requires setting channel after enabling\n\t\t\t * AP and before bringing interface up.\n\t\t\t */\n\t\t\terr = brcmf_fil_iovar_int_set(ifp, \"chanspec\", chanspec);\n\t\t\tif (err < 0) {\n\t\t\t\tbrcmf_err(\"Set Channel failed: chspec=%d, %d\\n\",\n\t\t\t\t\t  chanspec, err);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_UP, 1);\n\t\tif (err < 0) {\n\t\t\tbrcmf_err(\"BRCMF_C_UP error (%d)\\n\", err);\n\t\t\tgoto exit;\n\t\t}\n\t\t/* On DOWN the firmware removes the WEP keys, reconfigure\n\t\t * them if they were set.\n\t\t */\n\t\tbrcmf_cfg80211_reconfigure_wep(ifp);\n\n\t\tmemset(&join_params, 0, sizeof(join_params));\n\t\t/* join parameters starts with ssid */\n\t\tmemcpy(&join_params.ssid_le, &ssid_le, sizeof(ssid_le));\n\t\t/* create softap */\n\t\terr = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_SSID,\n\t\t\t\t\t     &join_params, sizeof(join_params));\n\t\tif (err < 0) {\n\t\t\tbrcmf_err(\"SET SSID error (%d)\\n\", err);\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (settings->hidden_ssid) {\n\t\t\terr = brcmf_fil_iovar_int_set(ifp, \"closednet\", 1);\n\t\t\tif (err) {\n\t\t\t\tbrcmf_err(\"closednet error (%d)\\n\", err);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\n\t\tbrcmf_dbg(TRACE, \"AP mode configuration complete\\n\");\n\t} else if (dev_role == NL80211_IFTYPE_P2P_GO) {\n\t\terr = brcmf_fil_iovar_int_set(ifp, \"chanspec\", chanspec);\n\t\tif (err < 0) {\n\t\t\tbrcmf_err(\"Set Channel failed: chspec=%d, %d\\n\",\n\t\t\t\t  chanspec, err);\n\t\t\tgoto exit;\n\t\t}\n\t\terr = brcmf_fil_bsscfg_data_set(ifp, \"ssid\", &ssid_le,\n\t\t\t\t\t\tsizeof(ssid_le));\n\t\tif (err < 0) {\n\t\t\tbrcmf_err(\"setting ssid failed %d\\n\", err);\n\t\t\tgoto exit;\n\t\t}\n\t\tbss_enable.bsscfgidx = cpu_to_le32(ifp->bsscfgidx);\n\t\tbss_enable.enable = cpu_to_le32(1);\n\t\terr = brcmf_fil_iovar_data_set(ifp, \"bss\", &bss_enable,\n\t\t\t\t\t       sizeof(bss_enable));\n\t\tif (err < 0) {\n\t\t\tbrcmf_err(\"bss_enable config failed %d\\n\", err);\n\t\t\tgoto exit;\n\t\t}\n\n\t\tbrcmf_dbg(TRACE, \"GO mode configuration complete\\n\");\n\t} else {\n\t\tWARN_ON(1);\n\t}\n\n\tset_bit(BRCMF_VIF_STATUS_AP_CREATED, &ifp->vif->sme_state);\n\tbrcmf_net_setcarrier(ifp, true);\n\nexit:\n\tif ((err) && (!mbss)) {\n\t\tbrcmf_set_mpc(ifp, 1);\n\t\tbrcmf_configure_arp_nd_offload(ifp, true);\n\t}\n\treturn err;\n}\n", "target": 1, "idx": 180080}
{"func": " void WebGL2RenderingContextBase::bindVertexArray(\n     WebGLVertexArrayObject* vertex_array) {\n  if (isContextLost())\n     return;\n  if (vertex_array &&\n      (vertex_array->IsDeleted() || !vertex_array->Validate(nullptr, this))) {\n     SynthesizeGLError(GL_INVALID_OPERATION, \"bindVertexArray\",\n                      \"invalid vertexArray\");\n     return;\n   }\n \n  if (vertex_array && !vertex_array->IsDefaultObject() &&\n      vertex_array->Object()) {\n    ContextGL()->BindVertexArrayOES(ObjectOrZero(vertex_array));\n\n    vertex_array->SetHasEverBeenBound();\n    SetBoundVertexArrayObject(vertex_array);\n  } else {\n    ContextGL()->BindVertexArrayOES(0);\n    SetBoundVertexArrayObject(nullptr);\n  }\n}\n", "target": 1, "idx": 187107}
{"func": " static int cm_init_av_by_path(struct ib_sa_path_rec *path, struct cm_av *av)\n {\n \tstruct cm_device *cm_dev;\n\tstruct cm_port *port = NULL;\n\tunsigned long flags;\n\tint ret;\n\tu8 p;\n\n\tread_lock_irqsave(&cm.device_lock, flags);\n\tlist_for_each_entry(cm_dev, &cm.device_list, list) {\n\t\tif (!ib_find_cached_gid(cm_dev->ib_device, &path->sgid,\n\t\t\t\t\t&p, NULL)) {\n\t\t\tport = cm_dev->port[p-1];\n\t\t\tbreak;\n\t\t}\n\t}\n\tread_unlock_irqrestore(&cm.device_lock, flags);\n\n\tif (!port)\n\t\treturn -EINVAL;\n\n\tret = ib_find_cached_pkey(cm_dev->ib_device, port->port_num,\n\t\t\t\t  be16_to_cpu(path->pkey), &av->pkey_index);\n\tif (ret)\n\t\treturn ret;\n\n\tav->port = port;\n\tib_init_ah_from_path(cm_dev->ib_device, port->port_num, path,\n\t\t\t     &av->ah_attr);\n\tav->timeout = path->packet_life_time + 1;\n\tmemcpy(av->smac, path->smac, sizeof(av->smac));\n\n\tav->valid = 1;\n\treturn 0;\n}\n", "target": 0, "idx": 38391}
{"func": "NaClIPCAdapter::LockedData::~LockedData() {\n}\n", "target": 0, "idx": 110260}
{"func": "static void __ipv4_sk_update_pmtu(struct sk_buff *skb, struct sock *sk, u32 mtu)\n{\n\tconst struct iphdr *iph = (const struct iphdr *) skb->data;\n\tstruct flowi4 fl4;\n\tstruct rtable *rt;\n\n\t__build_flow_key(sock_net(sk), &fl4, sk, iph, 0, 0, 0, 0, 0);\n\n\tif (!fl4.flowi4_mark)\n\t\tfl4.flowi4_mark = IP4_REPLY_MARK(sock_net(sk), skb->mark);\n\n\trt = __ip_route_output_key(sock_net(sk), &fl4);\n\tif (!IS_ERR(rt)) {\n\t\t__ip_rt_update_pmtu(rt, &fl4, mtu);\n\t\tip_rt_put(rt);\n\t}\n}\n", "target": 0, "idx": 62041}
{"func": "decode_rt_routing_info(netdissect_options *ndo,\n                       const u_char *pptr, char *buf, u_int buflen)\n {\n \tuint8_t route_target[8];\n \tu_int plen;\n \n \tND_TCHECK(pptr[0]);\n \tplen = pptr[0];   /* get prefix length */\n \n \tif (0 == plen) {\n \t\tsnprintf(buf, buflen, \"default route target\");\n \t\treturn 1;\n \t}\n \n \tif (32 > plen)\n \t\treturn -1;\n \n         plen-=32; /* adjust prefix length */\n \n \tif (64 < plen)\n \t\treturn -1;\n \n \tmemset(&route_target, 0, sizeof(route_target));\n\tND_TCHECK2(pptr[1], (plen + 7) / 8);\n\tmemcpy(&route_target, &pptr[1], (plen + 7) / 8);\n \tif (plen % 8) {\n \t\t((u_char *)&route_target)[(plen + 7) / 8 - 1] &=\n \t\t\t((0xff00 >> (plen % 8)) & 0xff);\n \t}\n \tsnprintf(buf, buflen, \"origin AS: %s, route target %s\",\n\t    as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(pptr+1)),\n \t    bgp_vpn_rd_print(ndo, (u_char *)&route_target));\n \n \treturn 5 + (plen + 7) / 8;\n\ntrunc:\n\treturn -2;\n}\n", "target": 1, "idx": 180992}
{"func": "void AudioNode::disconnect(unsigned output_index,\n                           ExceptionState& exception_state) {\n  DCHECK(IsMainThread());\n  BaseAudioContext::GraphAutoLocker locker(context());\n\n  if (output_index >= numberOfOutputs()) {\n    exception_state.ThrowDOMException(\n        kIndexSizeError,\n        ExceptionMessages::IndexOutsideRange(\n            \"output index\", output_index, 0u,\n            ExceptionMessages::kInclusiveBound, numberOfOutputs() - 1,\n            ExceptionMessages::kInclusiveBound));\n    return;\n  }\n  DisconnectAllFromOutput(output_index);\n}\n", "target": 0, "idx": 161655}
{"func": "mldv2_query_print(netdissect_options *ndo, const u_char *bp, u_int len)\n{\n    const struct icmp6_hdr *icp = (const struct icmp6_hdr *) bp;\n    u_int mrc;\n    int mrt, qqi;\n    u_int nsrcs;\n    register u_int i;\n\n    /* Minimum len is 28 */\n    if (len < 28) {\n            ND_PRINT((ndo,\" [invalid len %d]\", len));\n\treturn;\n    }\n    ND_TCHECK(icp->icmp6_data16[0]);\n    mrc = EXTRACT_16BITS(&icp->icmp6_data16[0]);\n    if (mrc < 32768) {\n\tmrt = mrc;\n    } else {\n        mrt = ((mrc & 0x0fff) | 0x1000) << (((mrc & 0x7000) >> 12) + 3);\n    }\n    if (ndo->ndo_vflag) {\n            ND_PRINT((ndo,\" [max resp delay=%d]\", mrt));\n    }\n    ND_TCHECK2(bp[8], sizeof(struct in6_addr));\n    ND_PRINT((ndo,\" [gaddr %s\", ip6addr_string(ndo, &bp[8])));\n\n    if (ndo->ndo_vflag) {\n        ND_TCHECK(bp[25]);\n\tif (bp[24] & 0x08) {\n\t\tND_PRINT((ndo,\" sflag\"));\n\t}\n\tif (bp[24] & 0x07) {\n\t\tND_PRINT((ndo,\" robustness=%d\", bp[24] & 0x07));\n\t}\n\tif (bp[25] < 128) {\n\t\tqqi = bp[25];\n\t} else {\n\t\tqqi = ((bp[25] & 0x0f) | 0x10) << (((bp[25] & 0x70) >> 4) + 3);\n\t}\n\tND_PRINT((ndo,\" qqi=%d\", qqi));\n    }\n\n    ND_TCHECK2(bp[26], 2);\n    nsrcs = EXTRACT_16BITS(&bp[26]);\n    if (nsrcs > 0) {\n\tif (len < 28 + nsrcs * sizeof(struct in6_addr))\n\t    ND_PRINT((ndo,\" [invalid number of sources]\"));\n\telse if (ndo->ndo_vflag > 1) {\n\t    ND_PRINT((ndo,\" {\"));\n\t    for (i = 0; i < nsrcs; i++) {\n\t\tND_TCHECK2(bp[28 + i * sizeof(struct in6_addr)],\n                        sizeof(struct in6_addr));\n\t\tND_PRINT((ndo,\" %s\", ip6addr_string(ndo, &bp[28 + i * sizeof(struct in6_addr)])));\n\t    }\n\t    ND_PRINT((ndo,\" }\"));\n\t} else\n                ND_PRINT((ndo,\", %d source(s)\", nsrcs));\n    }\n     ND_PRINT((ndo,\"]\"));\n     return;\n trunc:\n    ND_PRINT((ndo,\"[|icmp6]\"));\n     return;\n }\n", "target": 1, "idx": 182998}
{"func": "void ScrollableShelfView::OnFocusRingActivationChanged(bool activated) {\n  if (activated) {\n    focus_ring_activated_ = true;\n    SetPaneFocusAndFocusDefault();\n\n    GradientLayerDelegate::FadeZone fade_zone = {gfx::Rect(), false, false};\n    gradient_layer_delegate_->set_fade_zone(fade_zone);\n    gradient_layer_delegate_->layer()->SetBounds(layer()->bounds());\n    SchedulePaint();\n  } else {\n    focus_ring_activated_ = false;\n    UpdateGradientZone();\n  }\n}\n", "target": 0, "idx": 167301}
{"func": "void InspectorNetworkAgent::DidReceiveResourceResponse(\n    unsigned long identifier,\n    DocumentLoader* loader,\n    const ResourceResponse& response,\n    Resource* cached_resource) {\n  String request_id = IdentifiersFactory::RequestId(identifier);\n  bool is_not_modified = response.HttpStatusCode() == 304;\n\n  bool resource_is_empty = true;\n  std::unique_ptr<protocol::Network::Response> resource_response =\n      BuildObjectForResourceResponse(response, cached_resource,\n                                      &resource_is_empty);\n \n   InspectorPageAgent::ResourceType type =\n      cached_resource ? InspectorPageAgent::CachedResourceType(*cached_resource)\n                      : InspectorPageAgent::kOtherResource;\n   InspectorPageAgent::ResourceType saved_type =\n       resources_data_->GetResourceType(request_id);\n  if (saved_type == InspectorPageAgent::kScriptResource ||\n      saved_type == InspectorPageAgent::kXHRResource ||\n      saved_type == InspectorPageAgent::kDocumentResource ||\n      saved_type == InspectorPageAgent::kFetchResource ||\n      saved_type == InspectorPageAgent::kEventSourceResource) {\n    type = saved_type;\n  }\n  if (type == InspectorPageAgent::kDocumentResource && loader &&\n      loader->GetSubstituteData().IsValid())\n    return;\n\n  if (cached_resource)\n    resources_data_->AddResource(request_id, cached_resource);\n  String frame_id = loader && loader->GetFrame()\n                        ? IdentifiersFactory::FrameId(loader->GetFrame())\n                        : \"\";\n  String loader_id = loader ? IdentifiersFactory::LoaderId(loader) : \"\";\n  resources_data_->ResponseReceived(request_id, frame_id, response);\n  resources_data_->SetResourceType(request_id, type);\n\n  if (response.GetSecurityStyle() != ResourceResponse::kSecurityStyleUnknown &&\n      response.GetSecurityStyle() !=\n          ResourceResponse::kSecurityStyleUnauthenticated) {\n    const ResourceResponse::SecurityDetails* response_security_details =\n        response.GetSecurityDetails();\n    resources_data_->SetCertificate(request_id,\n                                    response_security_details->certificate);\n  }\n\n  if (resource_response && !resource_is_empty) {\n    Maybe<String> maybe_frame_id;\n    if (!frame_id.IsEmpty())\n      maybe_frame_id = frame_id;\n    GetFrontend()->responseReceived(\n        request_id, loader_id, MonotonicallyIncreasingTime(),\n        InspectorPageAgent::ResourceTypeJson(type),\n        std::move(resource_response), std::move(maybe_frame_id));\n  }\n  if (is_not_modified && cached_resource && cached_resource->EncodedSize())\n    DidReceiveData(identifier, loader, 0, cached_resource->EncodedSize());\n}\n", "target": 1, "idx": 186434}
{"func": "void unix_inflight(struct file *fp)\n {\n \tstruct sock *s = unix_get_socket(fp);\n \n \tif (s) {\n \t\tstruct unix_sock *u = unix_sk(s);\n \n\t\tspin_lock(&unix_gc_lock);\n \t\tif (atomic_long_inc_return(&u->inflight) == 1) {\n \t\t\tBUG_ON(!list_empty(&u->link));\n \t\t\tlist_add_tail(&u->link, &gc_inflight_list);\n \t\t} else {\n \t\t\tBUG_ON(list_empty(&u->link));\n \t\t}\n \t\tunix_tot_inflight++;\n\t\tspin_unlock(&unix_gc_lock);\n \t}\n }\n", "target": 1, "idx": 180769}
{"func": "static void buffer_pipe_buf_get(struct pipe_inode_info *pipe,\n \t\t\t\tstruct pipe_buffer *buf)\n {\n \tstruct buffer_ref *ref = (struct buffer_ref *)buf->private;\n \n \tref->ref++;\n }\n", "target": 1, "idx": 183393}
{"func": "static int get_option_uid(substring_t args[], kuid_t *result)\n{\n\tunsigned long value;\n\tkuid_t uid;\n\tint rc;\n\n\trc = get_option_ul(args, &value);\n\tif (rc)\n\t\treturn rc;\n\n\tuid = make_kuid(current_user_ns(), value);\n\tif (!uid_valid(uid))\n\t\treturn -EINVAL;\n\n\t*result = uid;\n\treturn 0;\n}\n", "target": 0, "idx": 29850}
{"func": "AtomicString Document::encodingName() const\n{\n    return AtomicString(encoding().name());\n}\n", "target": 0, "idx": 135224}
{"func": "static bool encode_vlv_request(void *mem_ctx, void *in, DATA_BLOB *out)\n{\n\tstruct ldb_vlv_req_control *lvrc = talloc_get_type(in, struct ldb_vlv_req_control);\n\tstruct asn1_data *data = asn1_init(mem_ctx);\n\n\tif (!data) return false;\n\n\tif (!asn1_push_tag(data, ASN1_SEQUENCE(0))) {\n\t\treturn false;\n\t}\n\n\tif (!asn1_write_Integer(data, lvrc->beforeCount)) {\n\t\treturn false;\n\t}\n\n\tif (!asn1_write_Integer(data, lvrc->afterCount)) {\n\t\treturn false;\n\t}\n\n\tif (lvrc->type == 0) {\n\t\tif (!asn1_push_tag(data, ASN1_CONTEXT(0))) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (!asn1_push_tag(data, ASN1_SEQUENCE(0))) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (!asn1_write_Integer(data, lvrc->match.byOffset.offset)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!asn1_write_Integer(data, lvrc->match.byOffset.contentCount)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!asn1_pop_tag(data)) { /*SEQUENCE*/\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!asn1_pop_tag(data)) { /*CONTEXT*/\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tif (!asn1_push_tag(data, ASN1_CONTEXT(1))) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (!asn1_write_OctetString(data, lvrc->match.gtOrEq.value, lvrc->match.gtOrEq.value_len)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!asn1_pop_tag(data)) { /*CONTEXT*/\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (lvrc->ctxid_len) {\n\t\tif (!asn1_write_OctetString(data, lvrc->contextId, lvrc->ctxid_len)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (!asn1_pop_tag(data)) {\n\t\treturn false;\n\t}\n\n\t*out = data_blob_talloc(mem_ctx, data->data, data->length);\n\tif (out->data == NULL) {\n\t\treturn false;\n\t}\n\ttalloc_free(data);\n\n\treturn true;\n}\n", "target": 0, "idx": 656}
{"func": "pdf_read_old_xref(fz_context *ctx, pdf_document *doc, pdf_lexbuf *buf)\n{\n\tfz_stream *file = doc->file;\n\n\tint64_t ofs;\n\tint len;\n\tchar *s;\n\tsize_t n;\n\tpdf_token tok;\n\tint64_t i;\n\tint c;\n\tint xref_len = pdf_xref_size_from_old_trailer(ctx, doc, buf);\n\tpdf_xref_entry *table;\n\tint carried;\n\n\tfz_skip_space(ctx, doc->file);\n\tif (fz_skip_string(ctx, doc->file, \"xref\"))\n\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"cannot find xref marker\");\n\tfz_skip_space(ctx, doc->file);\n\n\twhile (1)\n\t{\n\t\tc = fz_peek_byte(ctx, file);\n\t\tif (!(c >= '0' && c <= '9'))\n\t\t\tbreak;\n\n\t\tfz_read_line(ctx, file, buf->scratch, buf->size);\n\t\ts = buf->scratch;\n\t\tofs = fz_atoi64(fz_strsep(&s, \" \"));\n\t\tlen = fz_atoi(fz_strsep(&s, \" \"));\n\n\t\t/* broken pdfs where the section is not on a separate line */\n\t\tif (s && *s != '\\0')\n\t\t{\n\t\t\tfz_warn(ctx, \"broken xref section. proceeding anyway.\");\n                        fz_seek(ctx, file, -(2 + (int)strlen(s)), SEEK_CUR);\n                }\n \n               if (ofs < 0)\n                       fz_throw(ctx, FZ_ERROR_GENERIC, \"out of range object num in xref: %d\", (int)ofs);\n               if (ofs > INT64_MAX - len)\n                       fz_throw(ctx, FZ_ERROR_GENERIC, \"xref section object numbers too big\");\n                /* broken pdfs where size in trailer undershoots entries in xref sections */\n                if (ofs + len > xref_len)\n                {\n\t\t}\n\n\t\ttable = pdf_xref_find_subsection(ctx, doc, ofs, len);\n\n\t\t/* Xref entries SHOULD be 20 bytes long, but we see 19 byte\n\t\t * ones more frequently than we'd like (e.g. PCLm drivers).\n\t\t * Cope with this by 'carrying' data forward. */\n\t\tcarried = 0;\n\t\tfor (i = ofs; i < ofs + len; i++)\n\t\t{\n\t\t\tpdf_xref_entry *entry = &table[i-ofs];\n\t\t\tn = fz_read(ctx, file, (unsigned char *) buf->scratch + carried, 20-carried);\n\t\t\tif (n != 20-carried)\n\t\t\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"unexpected EOF in xref table\");\n\t\t\tn += carried;\n\t\t\tif (!entry->type)\n\t\t\t{\n\t\t\t\ts = buf->scratch;\n\n\t\t\t\t/* broken pdfs where line start with white space */\n\t\t\t\twhile (*s != '\\0' && iswhite(*s))\n\t\t\t\t\ts++;\n\n\t\t\t\tentry->ofs = fz_atoi64(s);\n\t\t\t\tentry->gen = fz_atoi(s + 11);\n\t\t\t\tentry->num = (int)i;\n\t\t\t\tentry->type = s[17];\n\t\t\t\tif (s[17] != 'f' && s[17] != 'n' && s[17] != 'o')\n\t\t\t\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"unexpected xref type: 0x%x (%d %d R)\", s[17], entry->num, entry->gen);\n\t\t\t\t/* If the last byte of our buffer isn't an EOL (or space), carry one byte forward */\n\t\t\t\tcarried = s[19] > 32;\n\t\t\t\tif (carried)\n\t\t\t\t\ts[0] = s[19];\n\t\t\t}\n\t\t}\n\t\tif (carried)\n\t\t\tfz_unread_byte(ctx, file);\n\t}\n\n\ttok = pdf_lex(ctx, file, buf);\n\tif (tok != PDF_TOK_TRAILER)\n\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"expected trailer marker\");\n\n\ttok = pdf_lex(ctx, file, buf);\n\tif (tok != PDF_TOK_OPEN_DICT)\n\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"expected trailer dictionary\");\n\n\treturn pdf_parse_dict(ctx, doc, file, buf);\n}\n", "target": 1, "idx": 178563}
{"func": "xfs_prep_free_cowblocks(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_ifork\t*ifp)\n{\n\t/*\n\t * Just clear the tag if we have an empty cow fork or none at all. It's\n\t * possible the inode was fully unshared since it was originally tagged.\n\t */\n\tif (!xfs_is_reflink_inode(ip) || !ifp->if_bytes) {\n\t\ttrace_xfs_inode_free_cowblocks_invalid(ip);\n\t\txfs_inode_clear_cowblocks_tag(ip);\n\t\treturn false;\n\t}\n\n\t/*\n\t * If the mapping is dirty or under writeback we cannot touch the\n\t * CoW fork.  Leave it alone if we're in the midst of a directio.\n\t */\n\tif ((VFS_I(ip)->i_state & I_DIRTY_PAGES) ||\n\t    mapping_tagged(VFS_I(ip)->i_mapping, PAGECACHE_TAG_DIRTY) ||\n\t    mapping_tagged(VFS_I(ip)->i_mapping, PAGECACHE_TAG_WRITEBACK) ||\n\t    atomic_read(&VFS_I(ip)->i_dio_count))\n\t\treturn false;\n\n\treturn true;\n}\n", "target": 0, "idx": 79975}
{"func": "    BufferMeta(const sp<IMemory> &mem, OMX_U32 portIndex, bool is_backup = false)\n         : mMem(mem),\n          mIsBackup(is_backup),\n          mPortIndex(portIndex) {\n     }\n", "target": 1, "idx": 188146}
{"func": "void ResourceDispatcherHost::ResumeRequest(const GlobalRequestID& request_id) {\n  PendingRequestList::iterator i = pending_requests_.find(request_id);\n  if (i == pending_requests_.end())  // The request may have been destroyed\n    return;\n\n  URLRequest* request = i->second;\n  ResourceDispatcherHostRequestInfo* info = InfoForRequest(request);\n  if (!info->is_paused())\n    return;\n\n  RESOURCE_LOG(\"Resuming: \" << i->second->url().spec());\n\n  info->set_is_paused(false);\n\n  if (info->called_on_response_started()) {\n    if (info->has_started_reading()) {\n      OnReadCompleted(i->second, info->paused_read_bytes());\n    } else {\n      StartReading(request);\n    }\n  } else {\n    OnResponseStarted(i->second);\n  }\n}\n", "target": 0, "idx": 99120}
{"func": "static ssize_t mem_read(struct file * file, char __user * buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct task_struct *task = get_proc_task(file->f_path.dentry->d_inode);\n\tchar *page;\n\tunsigned long src = *ppos;\n\tint ret = -ESRCH;\n\tstruct mm_struct *mm;\n\n\tif (!task)\n\t\tgoto out_no_task;\n\n\tret = -ENOMEM;\n\tpage = (char *)__get_free_page(GFP_TEMPORARY);\n\tif (!page)\n\t\tgoto out;\n\n\tmm = check_mem_permission(task);\n\tret = PTR_ERR(mm);\n\tif (IS_ERR(mm))\n\t\tgoto out_free;\n\n\tret = -EIO;\n \n\tif (file->private_data != (void*)((long)current->self_exec_id))\n\t\tgoto out_put;\n\n\tret = 0;\n \n\twhile (count > 0) {\n\t\tint this_len, retval;\n\n\t\tthis_len = (count > PAGE_SIZE) ? PAGE_SIZE : count;\n\t\tretval = access_remote_vm(mm, src, page, this_len, 0);\n\t\tif (!retval) {\n\t\t\tif (!ret)\n\t\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_to_user(buf, page, retval)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n \n\t\tret += retval;\n\t\tsrc += retval;\n\t\tbuf += retval;\n\t\tcount -= retval;\n\t}\n\t*ppos = src;\n\nout_put:\n\tmmput(mm);\nout_free:\n\tfree_page((unsigned long) page);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn ret;\n}\n", "target": 0, "idx": 26818}
{"func": "static int ipip6_err(struct sk_buff *skb, u32 info)\n{\n\tconst struct iphdr *iph = (const struct iphdr *)skb->data;\n\tconst int type = icmp_hdr(skb)->type;\n\tconst int code = icmp_hdr(skb)->code;\n\tunsigned int data_len = 0;\n\tstruct ip_tunnel *t;\n\tint sifindex;\n\tint err;\n\n\tswitch (type) {\n\tdefault:\n\tcase ICMP_PARAMETERPROB:\n\t\treturn 0;\n\n\tcase ICMP_DEST_UNREACH:\n\t\tswitch (code) {\n\t\tcase ICMP_SR_FAILED:\n\t\t\t/* Impossible event. */\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\t/* All others are translated to HOST_UNREACH.\n\t\t\t   rfc2003 contains \"deep thoughts\" about NET_UNREACH,\n\t\t\t   I believe they are just ether pollution. --ANK\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase ICMP_TIME_EXCEEDED:\n\t\tif (code != ICMP_EXC_TTL)\n\t\t\treturn 0;\n\t\tdata_len = icmp_hdr(skb)->un.reserved[1] * 4; /* RFC 4884 4.1 */\n\t\tbreak;\n\tcase ICMP_REDIRECT:\n\t\tbreak;\n\t}\n\n\terr = -ENOENT;\n\n\tsifindex = netif_is_l3_master(skb->dev) ? IPCB(skb)->iif : 0;\n\tt = ipip6_tunnel_lookup(dev_net(skb->dev), skb->dev,\n\t\t\t\tiph->daddr, iph->saddr, sifindex);\n\tif (!t)\n\t\tgoto out;\n\n\tif (type == ICMP_DEST_UNREACH && code == ICMP_FRAG_NEEDED) {\n\t\tipv4_update_pmtu(skb, dev_net(skb->dev), info,\n\t\t\t\t t->parms.link, iph->protocol);\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\tif (type == ICMP_REDIRECT) {\n\t\tipv4_redirect(skb, dev_net(skb->dev), t->parms.link,\n\t\t\t      iph->protocol);\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\terr = 0;\n\tif (__in6_dev_get(skb->dev) &&\n\t    !ip6_err_gen_icmpv6_unreach(skb, iph->ihl * 4, type, data_len))\n\t\tgoto out;\n\n\tif (t->parms.iph.daddr == 0)\n\t\tgoto out;\n\n\tif (t->parms.iph.ttl == 0 && type == ICMP_TIME_EXCEEDED)\n\t\tgoto out;\n\n\tif (time_before(jiffies, t->err_time + IPTUNNEL_ERR_TIMEO))\n\t\tt->err_count++;\n\telse\n\t\tt->err_count = 1;\n\tt->err_time = jiffies;\nout:\n\treturn err;\n}\n", "target": 0, "idx": 87691}
{"func": "WebsiteSettings::WebsiteSettings(\n     WebsiteSettingsUI* ui,\n     Profile* profile,\n     TabSpecificContentSettings* tab_specific_content_settings,\n    InfoBarService* infobar_service,\n     const GURL& url,\n     const content::SSLStatus& ssl,\n     content::CertStore* cert_store)\n     : TabSpecificContentSettings::SiteDataObserver(\n           tab_specific_content_settings),\n       ui_(ui),\n      infobar_service_(infobar_service),\n       show_info_bar_(false),\n       site_url_(url),\n       site_identity_status_(SITE_IDENTITY_STATUS_UNKNOWN),\n      cert_id_(0),\n      site_connection_status_(SITE_CONNECTION_STATUS_UNKNOWN),\n      cert_store_(cert_store),\n      content_settings_(profile->GetHostContentSettingsMap()),\n      chrome_ssl_host_state_delegate_(\n          ChromeSSLHostStateDelegateFactory::GetForProfile(profile)),\n      did_revoke_user_ssl_decisions_(false) {\n  Init(profile, url, ssl);\n\n  PresentSitePermissions();\n  PresentSiteData();\n  PresentSiteIdentity();\n\n  RecordWebsiteSettingsAction(WEBSITE_SETTINGS_OPENED);\n}\n", "target": 1, "idx": 185658}
{"func": "throw_error (GDBusMethodInvocation *context,\n             gint                   error_code,\n             const gchar           *format,\n             ...)\n{\n        va_list args;\n        g_autofree gchar *message = NULL;\n\n        va_start (args, format);\n        message = g_strdup_vprintf (format, args);\n        va_end (args);\n\n        g_dbus_method_invocation_return_error (context, ERROR, error_code, \"%s\", message);\n}\n", "target": 0, "idx": 4718}
{"func": "MagickExport void ClonePixelCacheMethods(Cache clone,const Cache cache)\n{\n  CacheInfo\n    *restrict cache_info,\n    *restrict source_info;\n\n  assert(clone != (Cache) NULL);\n  source_info=(CacheInfo *) clone;\n  assert(source_info->signature == MagickSignature);\n  if (source_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      source_info->filename);\n  assert(cache != (Cache) NULL);\n  cache_info=(CacheInfo *) cache;\n  assert(cache_info->signature == MagickSignature);\n  source_info->methods=cache_info->methods;\n}\n", "target": 0, "idx": 73610}
{"func": "int ParseRiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)\n{\n    int is_rf64 = !strncmp (fourcc, \"RF64\", 4), got_ds64 = 0;\n    int64_t total_samples = 0, infilesize;\n    RiffChunkHeader riff_chunk_header;\n    ChunkHeader chunk_header;\n    WaveHeader WaveHeader;\n    DS64Chunk ds64_chunk;\n    uint32_t bcount;\n\n    CLEAR (WaveHeader);\n    CLEAR (ds64_chunk);\n    infilesize = DoGetFileSize (infile);\n\n    if (!is_rf64 && infilesize >= 4294967296LL && !(config->qmode & QMODE_IGNORE_LENGTH)) {\n        error_line (\"can't handle .WAV files larger than 4 GB (non-standard)!\");\n        return WAVPACK_SOFT_ERROR;\n    }\n\n    memcpy (&riff_chunk_header, fourcc, 4);\n\n    if ((!DoReadFile (infile, ((char *) &riff_chunk_header) + 4, sizeof (RiffChunkHeader) - 4, &bcount) ||\n        bcount != sizeof (RiffChunkHeader) - 4 || strncmp (riff_chunk_header.formType, \"WAVE\", 4))) {\n            error_line (\"%s is not a valid .WAV file!\", infilename);\n            return WAVPACK_SOFT_ERROR;\n    }\n    else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n        !WavpackAddWrapper (wpc, &riff_chunk_header, sizeof (RiffChunkHeader))) {\n            error_line (\"%s\", WavpackGetErrorMessage (wpc));\n            return WAVPACK_SOFT_ERROR;\n    }\n\n\n    while (1) {\n        if (!DoReadFile (infile, &chunk_header, sizeof (ChunkHeader), &bcount) ||\n            bcount != sizeof (ChunkHeader)) {\n                error_line (\"%s is not a valid .WAV file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n        }\n        else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n            !WavpackAddWrapper (wpc, &chunk_header, sizeof (ChunkHeader))) {\n                error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                return WAVPACK_SOFT_ERROR;\n        }\n\n        WavpackLittleEndianToNative (&chunk_header, ChunkHeaderFormat);\n\n        if (!strncmp (chunk_header.ckID, \"ds64\", 4)) {\n            if (chunk_header.ckSize < sizeof (DS64Chunk) ||\n                !DoReadFile (infile, &ds64_chunk, sizeof (DS64Chunk), &bcount) ||\n                bcount != sizeof (DS64Chunk)) {\n                    error_line (\"%s is not a valid .WAV file!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, &ds64_chunk, sizeof (DS64Chunk))) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            got_ds64 = 1;\n            WavpackLittleEndianToNative (&ds64_chunk, DS64ChunkFormat);\n\n            if (debug_logging_mode)\n                error_line (\"DS64: riffSize = %lld, dataSize = %lld, sampleCount = %lld, table_length = %d\",\n                    (long long) ds64_chunk.riffSize64, (long long) ds64_chunk.dataSize64,\n                    (long long) ds64_chunk.sampleCount64, ds64_chunk.tableLength);\n\n            if (ds64_chunk.tableLength * sizeof (CS64Chunk) != chunk_header.ckSize - sizeof (DS64Chunk)) {\n                error_line (\"%s is not a valid .WAV file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            while (ds64_chunk.tableLength--) {\n                CS64Chunk cs64_chunk;\n                if (!DoReadFile (infile, &cs64_chunk, sizeof (CS64Chunk), &bcount) ||\n                    bcount != sizeof (CS64Chunk) ||\n                    (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                    !WavpackAddWrapper (wpc, &cs64_chunk, sizeof (CS64Chunk)))) {\n                        error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                        return WAVPACK_SOFT_ERROR;\n                }\n            }\n        }\n        else if (!strncmp (chunk_header.ckID, \"fmt \", 4)) {     // if it's the format chunk, we want to get some info out of there and\n            int supported = TRUE, format;                        // make sure it's a .wav file we can handle\n\n            if (chunk_header.ckSize < 16 || chunk_header.ckSize > sizeof (WaveHeader) ||\n                !DoReadFile (infile, &WaveHeader, chunk_header.ckSize, &bcount) ||\n                bcount != chunk_header.ckSize) {\n                    error_line (\"%s is not a valid .WAV file!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n            }\n            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, &WaveHeader, chunk_header.ckSize)) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            WavpackLittleEndianToNative (&WaveHeader, WaveHeaderFormat);\n\n            if (debug_logging_mode) {\n                error_line (\"format tag size = %d\", chunk_header.ckSize);\n                error_line (\"FormatTag = %x, NumChannels = %d, BitsPerSample = %d\",\n                    WaveHeader.FormatTag, WaveHeader.NumChannels, WaveHeader.BitsPerSample);\n                error_line (\"BlockAlign = %d, SampleRate = %d, BytesPerSecond = %d\",\n                    WaveHeader.BlockAlign, WaveHeader.SampleRate, WaveHeader.BytesPerSecond);\n\n                if (chunk_header.ckSize > 16)\n                    error_line (\"cbSize = %d, ValidBitsPerSample = %d\", WaveHeader.cbSize,\n                        WaveHeader.ValidBitsPerSample);\n\n                if (chunk_header.ckSize > 20)\n                    error_line (\"ChannelMask = %x, SubFormat = %d\",\n                        WaveHeader.ChannelMask, WaveHeader.SubFormat);\n            }\n\n            if (chunk_header.ckSize > 16 && WaveHeader.cbSize == 2)\n                config->qmode |= QMODE_ADOBE_MODE;\n\n            format = (WaveHeader.FormatTag == 0xfffe && chunk_header.ckSize == 40) ?\n                WaveHeader.SubFormat : WaveHeader.FormatTag;\n\n            config->bits_per_sample = (chunk_header.ckSize == 40 && WaveHeader.ValidBitsPerSample) ?\n                WaveHeader.ValidBitsPerSample : WaveHeader.BitsPerSample;\n\n            if (format != 1 && format != 3)\n                supported = FALSE;\n\n            if (format == 3 && config->bits_per_sample != 32)\n                supported = FALSE;\n\n            if (!WaveHeader.NumChannels || WaveHeader.NumChannels > 256 ||\n                WaveHeader.BlockAlign / WaveHeader.NumChannels < (config->bits_per_sample + 7) / 8 ||\n                WaveHeader.BlockAlign / WaveHeader.NumChannels > 4 ||\n                WaveHeader.BlockAlign % WaveHeader.NumChannels)\n                    supported = FALSE;\n\n            if (config->bits_per_sample < 1 || config->bits_per_sample > 32)\n                supported = FALSE;\n\n            if (!supported) {\n                error_line (\"%s is an unsupported .WAV format!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            if (chunk_header.ckSize < 40) {\n                if (!config->channel_mask && !(config->qmode & QMODE_CHANS_UNASSIGNED)) {\n                    if (WaveHeader.NumChannels <= 2)\n                        config->channel_mask = 0x5 - WaveHeader.NumChannels;\n                    else if (WaveHeader.NumChannels <= 18)\n                        config->channel_mask = (1 << WaveHeader.NumChannels) - 1;\n                    else\n                        config->channel_mask = 0x3ffff;\n                }\n            }\n            else if (WaveHeader.ChannelMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) {\n                error_line (\"this WAV file already has channel order information!\");\n                return WAVPACK_SOFT_ERROR;\n            }\n            else if (WaveHeader.ChannelMask)\n                config->channel_mask = WaveHeader.ChannelMask;\n\n            if (format == 3)\n                config->float_norm_exp = 127;\n            else if ((config->qmode & QMODE_ADOBE_MODE) &&\n                WaveHeader.BlockAlign / WaveHeader.NumChannels == 4) {\n                    if (WaveHeader.BitsPerSample == 24)\n                        config->float_norm_exp = 127 + 23;\n                    else if (WaveHeader.BitsPerSample == 32)\n                        config->float_norm_exp = 127 + 15;\n            }\n\n            if (debug_logging_mode) {\n                if (config->float_norm_exp == 127)\n                    error_line (\"data format: normalized 32-bit floating point\");\n                else if (config->float_norm_exp)\n                    error_line (\"data format: 32-bit floating point (Audition %d:%d float type 1)\",\n                        config->float_norm_exp - 126, 150 - config->float_norm_exp);\n                else\n                    error_line (\"data format: %d-bit integers stored in %d byte(s)\",\n                        config->bits_per_sample, WaveHeader.BlockAlign / WaveHeader.NumChannels);\n            }\n        }\n        else if (!strncmp (chunk_header.ckID, \"data\", 4)) {             // on the data chunk, get size and exit loop\n\n            int64_t data_chunk_size = (got_ds64 && chunk_header.ckSize == (uint32_t) -1) ?\n                ds64_chunk.dataSize64 : chunk_header.ckSize;\n\n\n            if (!WaveHeader.NumChannels || (is_rf64 && !got_ds64)) {   // make sure we saw \"fmt\" and \"ds64\" chunks (if required)\n                error_line (\"%s is not a valid .WAV file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) && infilesize - data_chunk_size > 16777216) {\n                error_line (\"this .WAV file has over 16 MB of extra RIFF data, probably is corrupt!\");\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            if (config->qmode & QMODE_IGNORE_LENGTH) {\n                if (infilesize && DoGetFilePosition (infile) != -1)\n                    total_samples = (infilesize - DoGetFilePosition (infile)) / WaveHeader.BlockAlign;\n                else\n                    total_samples = -1;\n            }\n            else {\n                total_samples = data_chunk_size / WaveHeader.BlockAlign;\n\n                if (got_ds64 && total_samples != ds64_chunk.sampleCount64) {\n                    error_line (\"%s is not a valid .WAV file!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n                }\n\n                if (!total_samples) {\n                    error_line (\"this .WAV file has no audio samples, probably is corrupt!\");\n                    return WAVPACK_SOFT_ERROR;\n                }\n\n                if (total_samples > MAX_WAVPACK_SAMPLES) {\n                    error_line (\"%s has too many samples for WavPack!\", infilename);\n                    return WAVPACK_SOFT_ERROR;\n                }\n            }\n\n            config->bytes_per_sample = WaveHeader.BlockAlign / WaveHeader.NumChannels;\n            config->num_channels = WaveHeader.NumChannels;\n            config->sample_rate = WaveHeader.SampleRate;\n            break;\n        }\n         else {          // just copy unknown chunks to output file\n \n             int bytes_to_copy = (chunk_header.ckSize + 1) & ~1L;\n            char *buff = malloc (bytes_to_copy);\n \n             if (debug_logging_mode)\n                 error_line (\"extra unknown chunk \\\"%c%c%c%c\\\" of %d bytes\",\n                    chunk_header.ckID [0], chunk_header.ckID [1], chunk_header.ckID [2],\n                    chunk_header.ckID [3], chunk_header.ckSize);\n\n            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||\n                bcount != bytes_to_copy ||\n                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {\n                    error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                    free (buff);\n                    return WAVPACK_SOFT_ERROR;\n            }\n\n            free (buff);\n        }\n    }\n\n    if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) {\n        error_line (\"%s: %s\", infilename, WavpackGetErrorMessage (wpc));\n        return WAVPACK_SOFT_ERROR;\n    }\n\n    return WAVPACK_NO_ERROR;\n}\n", "target": 1, "idx": 182422}
{"func": "void StatusBubbleGtk::MouseMoved(\n    const gfx::Point& location, bool left_content) {\n  if (left_content && ignore_next_left_content_) {\n    ignore_next_left_content_ = false;\n    return;\n  }\n\n  last_mouse_location_ = location;\n  last_mouse_left_content_ = left_content;\n\n  if (!GTK_WIDGET_REALIZED(container_.get()))\n    return;\n\n  GtkWidget* parent = gtk_widget_get_parent(container_.get());\n  if (!parent || !GTK_WIDGET_REALIZED(parent))\n    return;\n\n  int old_y_offset = y_offset_;\n  bool old_flip_horizontally = flip_horizontally_;\n\n  if (left_content) {\n    SetFlipHorizontally(false);\n    y_offset_ = 0;\n  } else {\n    GtkWidget* toplevel = gtk_widget_get_toplevel(container_.get());\n    if (!toplevel || !GTK_WIDGET_REALIZED(toplevel))\n      return;\n\n    bool ltr = !base::i18n::IsRTL();\n\n    GtkRequisition requisition;\n    gtk_widget_size_request(container_.get(), &requisition);\n\n    gint toplevel_x = 0, toplevel_y = 0;\n    gdk_window_get_position(toplevel->window, &toplevel_x, &toplevel_y);\n    gfx::Rect parent_rect =\n        gtk_util::GetWidgetRectRelativeToToplevel(parent);\n    gfx::Rect bubble_rect(\n        toplevel_x + parent_rect.x() +\n            (ltr ? 0 : parent->allocation.width - requisition.width),\n        toplevel_y + parent_rect.y() +\n            parent->allocation.height - requisition.height,\n        requisition.width,\n        requisition.height);\n\n    int left_threshold =\n        bubble_rect.x() - bubble_rect.height() - kMousePadding;\n    int right_threshold =\n        bubble_rect.right() + bubble_rect.height() + kMousePadding;\n    int top_threshold = bubble_rect.y() - kMousePadding;\n\n    if (((ltr && location.x() < right_threshold) ||\n         (!ltr && location.x() > left_threshold)) &&\n        location.y() > top_threshold) {\n      if (download_shelf_is_visible_) {\n        SetFlipHorizontally(true);\n        y_offset_ = 0;\n      } else {\n        SetFlipHorizontally(false);\n        int distance = std::max(ltr ?\n                                    location.x() - right_threshold :\n                                    left_threshold - location.x(),\n                                top_threshold - location.y());\n        y_offset_ = std::min(-1 * distance, requisition.height);\n      }\n    } else {\n      SetFlipHorizontally(false);\n      y_offset_ = 0;\n    }\n  }\n\n  if (y_offset_ != old_y_offset || flip_horizontally_ != old_flip_horizontally)\n    gtk_widget_queue_resize_no_redraw(parent);\n}\n", "target": 0, "idx": 107704}
{"func": "int ChromeBrowserMainPartsChromeos::PreEarlyInitialization() {\n  base::CommandLine* singleton_command_line =\n      base::CommandLine::ForCurrentProcess();\n\n  if (parsed_command_line().HasSwitch(switches::kGuestSession)) {\n    singleton_command_line->AppendSwitch(::switches::kDisableSync);\n    singleton_command_line->AppendSwitch(::switches::kDisableExtensions);\n    browser_defaults::bookmarks_enabled = false;\n  }\n\n  if (!base::SysInfo::IsRunningOnChromeOS() &&\n      !parsed_command_line().HasSwitch(switches::kLoginManager) &&\n      !parsed_command_line().HasSwitch(switches::kLoginUser) &&\n      !parsed_command_line().HasSwitch(switches::kGuestSession)) {\n    singleton_command_line->AppendSwitchASCII(\n        switches::kLoginUser,\n        cryptohome::Identification(user_manager::StubAccountId()).id());\n    if (!parsed_command_line().HasSwitch(switches::kLoginProfile)) {\n      singleton_command_line->AppendSwitchASCII(switches::kLoginProfile,\n                                                chrome::kTestUserProfileDir);\n    }\n    LOG(WARNING) << \"Running as stub user with profile dir: \"\n                 << singleton_command_line\n                        ->GetSwitchValuePath(switches::kLoginProfile)\n                        .value();\n  }\n\n  RegisterStubPathOverridesIfNecessary();\n\n#if defined(GOOGLE_CHROME_BUILD)\n  const char kChromeOSReleaseTrack[] = \"CHROMEOS_RELEASE_TRACK\";\n  std::string channel;\n  if (base::SysInfo::GetLsbReleaseValue(kChromeOSReleaseTrack, &channel))\n    chrome::SetChannel(channel);\n#endif\n \n   dbus_pre_early_init_ = std::make_unique<internal::DBusPreEarlyInit>();\n \n   return ChromeBrowserMainPartsLinux::PreEarlyInitialization();\n }\n", "target": 1, "idx": 185605}
{"func": "  TabTest() {\n    fake_clock_.Advance(base::TimeDelta::FromMilliseconds(2000));\n  }\n", "target": 0, "idx": 153549}
{"func": "Extension::Location Extension::GetHigherPriorityLocation(\n    Extension::Location loc1, Extension::Location loc2) {\n  if (loc1 == loc2)\n    return loc1;\n\n  int loc1_rank = GetLocationRank(loc1);\n  int loc2_rank = GetLocationRank(loc2);\n\n  CHECK(loc1_rank != loc2_rank);\n\n  return (loc1_rank > loc2_rank ? loc1 : loc2 );\n}\n", "target": 0, "idx": 104607}
{"func": " int insn_get_code_seg_params(struct pt_regs *regs)\n {\n\tstruct desc_struct *desc;\n \tshort sel;\n \n \tif (v8086_mode(regs))\n\t\t/* Address and operand size are both 16-bit. */\n\t\treturn INSN_CODE_SEG_PARAMS(2, 2);\n\n\tsel = get_segment_selector(regs, INAT_SEG_REG_CS);\n \tif (sel < 0)\n \t\treturn sel;\n \n\tdesc = get_desc(sel);\n\tif (!desc)\n \t\treturn -EINVAL;\n \n \t/*\n \t * The most significant byte of the Type field of the segment descriptor\n \t * determines whether a segment contains data or code. If this is a data\n \t * segment, return error.\n \t */\n\tif (!(desc->type & BIT(3)))\n \t\treturn -EINVAL;\n \n\tswitch ((desc->l << 1) | desc->d) {\n \tcase 0: /*\n \t\t * Legacy mode. CS.L=0, CS.D=0. Address and operand size are\n \t\t * both 16-bit.\n\t\t */\n\t\treturn INSN_CODE_SEG_PARAMS(2, 2);\n\tcase 1: /*\n\t\t * Legacy mode. CS.L=0, CS.D=1. Address and operand size are\n\t\t * both 32-bit.\n\t\t */\n\t\treturn INSN_CODE_SEG_PARAMS(4, 4);\n\tcase 2: /*\n\t\t * IA-32e 64-bit mode. CS.L=1, CS.D=0. Address size is 64-bit;\n\t\t * operand size is 32-bit.\n\t\t */\n\t\treturn INSN_CODE_SEG_PARAMS(4, 8);\n\tcase 3: /* Invalid setting. CS.L=1, CS.D=1 */\n\t\t/* fall through */\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n", "target": 1, "idx": 182781}
{"func": "encode_SET_QUEUE(const struct ofpact_queue *queue,\n                 enum ofp_version ofp_version, struct ofpbuf *out)\n{\n    put_OFPAT_SET_QUEUE(out, ofp_version, queue->queue_id);\n}\n", "target": 0, "idx": 76900}
{"func": "PHP_FUNCTION(stream_filter_prepend)\n{\n\tapply_filter_to_stream(0, INTERNAL_FUNCTION_PARAM_PASSTHRU);\n}\n", "target": 0, "idx": 15270}
{"func": "bool SyncManager::ReceivedExperiment(browser_sync::Experiments* experiments)\n    const {\n  ReadTransaction trans(FROM_HERE, GetUserShare());\n  ReadNode node(&trans);\n  if (node.InitByTagLookup(kNigoriTag) != sync_api::BaseNode::INIT_OK) {\n    DVLOG(1) << \"Couldn't find Nigori node.\";\n     return false;\n   }\n   bool found_experiment = false;\n  if (node.GetNigoriSpecifics().sync_tabs()) {\n    experiments->sync_tabs = true;\n    found_experiment = true;\n  }\n   if (node.GetNigoriSpecifics().sync_tab_favicons()) {\n     experiments->sync_tab_favicons = true;\n     found_experiment = true;\n  }\n  return found_experiment;\n}\n", "target": 1, "idx": 184370}
{"func": "Status XvMCGetDRInfo(Display *dpy, XvPortID port,\n\t\t     char **name, char **busID,\n\t\t     int *major, int *minor,\n\t\t     int *patchLevel,\n\t\t     int *isLocal)\n{\n    XExtDisplayInfo *info = xvmc_find_display(dpy);\n    xvmcGetDRInfoReply rep;\n    xvmcGetDRInfoReq  *req;\n    CARD32 magic;\n\n#ifdef HAVE_SHMAT\n    volatile CARD32 *shMem;\n    struct timezone here;\n    struct timeval now;\n    here.tz_minuteswest = 0;\n    here.tz_dsttime = 0;\n#endif\n\n    *name = NULL;\n    *busID = NULL;\n\n    XvMCCheckExtension (dpy, info, BadImplementation);\n\n    LockDisplay (dpy);\n    XvMCGetReq (GetDRInfo, req);\n\n    req->port = port;\n    magic = 0;\n    req->magic = 0;\n#ifdef HAVE_SHMAT\n    req->shmKey = shmget(IPC_PRIVATE, 1024, IPC_CREAT | 0600);\n\n    /*\n     * We fill a shared memory page with a repetitive pattern. If the\n     * X server can read this pattern, we probably have a local connection.\n     * Note that we can trigger the remote X server to read any shared\n     * page on the remote machine, so we shouldn't be able to guess and verify\n     * any complicated data on those pages. Thats the explanation of this\n     * otherwise stupid-looking pattern algorithm.\n     */\n\n    if (req->shmKey >= 0) {\n\tshMem = (CARD32 *) shmat(req->shmKey, NULL, 0);\n\tshmctl( req->shmKey, IPC_RMID, NULL);\n\tif ( shMem ) {\n\n\t    register volatile CARD32 *shMemC = shMem;\n\t    register int i;\n\n\t    gettimeofday( &now, &here);\n\t    magic = now.tv_usec & 0x000FFFFF;\n\t    req->magic = magic;\n\t    i = 1024 / sizeof(CARD32);\n\t    while(i--) {\n\t        *shMemC++ = magic;\n\t        magic = ~magic;\n\t    }\n\t} else {\n\t    req->shmKey = -1;\n\t}\n    }\n#else\n    req->shmKey = 0;\n#endif\n    if (!_XReply (dpy, (xReply *) &rep, 0, xFalse)) {\n        UnlockDisplay (dpy);\n        SyncHandle ();\n#ifdef HAVE_SHMAT\n\tif ( req->shmKey >= 0) {\n\t    shmdt( (const void *) shMem );\n\t}\n#endif\n        return -1;\n    }\n#ifdef HAVE_SHMAT\n    shmdt( (const void *) shMem );\n#endif\n\n    if (rep.length > 0) {\n\tunsigned long realSize = 0;\n\tchar *tmpBuf = NULL;\n\n\tif ((rep.length < (INT_MAX >> 2)) &&\n\t    /* protect against overflow in strncpy below */\n\t    (rep.nameLen + rep.busIDLen > rep.nameLen)) {\n\t    realSize = rep.length << 2;\n\t    if (realSize >= (rep.nameLen + rep.busIDLen)) {\n\t\ttmpBuf = Xmalloc(realSize);\n\t\t*name = Xmalloc(rep.nameLen);\n\t\t*busID = Xmalloc(rep.busIDLen);\n\t    }\n\t}\n\n \tif (*name && *busID && tmpBuf) {\n \t    _XRead(dpy, tmpBuf, realSize);\n \t    strncpy(*name,tmpBuf,rep.nameLen);\n\t    (*name)[rep.nameLen - 1] = '\\0';\n \t    strncpy(*busID,tmpBuf+rep.nameLen,rep.busIDLen);\n\t    (*busID)[rep.busIDLen - 1] = '\\0';\n \t    XFree(tmpBuf);\n \t} else {\n \t    XFree(*name);\n\t    *name = NULL;\n\t    XFree(*busID);\n\t    *busID = NULL;\n\t    XFree(tmpBuf);\n\n\t    _XEatDataWords(dpy, rep.length);\n\t    UnlockDisplay (dpy);\n\t    SyncHandle ();\n\t    return -1;\n\n\t}\n    }\n\n    UnlockDisplay (dpy);\n    SyncHandle ();\n    *major = rep.major;\n    *minor = rep.minor;\n    *patchLevel = rep.patchLevel;\n    *isLocal = (req->shmKey > 0) ? rep.isLocal : 1;\n    return (rep.length > 0) ? Success : BadImplementation;\n}\n", "target": 1, "idx": 178085}
{"func": " void RenderFrameHostManager::EnsureRenderFrameHostVisibilityConsistent() {\n  if (render_frame_host_->GetView() &&\n      render_frame_host_->render_view_host()->GetWidget()->is_hidden() !=\n          delegate_->IsHidden()) {\n     if (delegate_->IsHidden()) {\n      render_frame_host_->GetView()->Hide();\n     } else {\n      render_frame_host_->GetView()->Show();\n     }\n   }\n }\n", "target": 1, "idx": 186289}
{"func": "void DesktopSessionWin::OnChannelConnected() {\n   DCHECK(main_task_runner_->BelongsToCurrentThread());\n }\n", "target": 1, "idx": 185245}
{"func": "bool AXLayoutObject::ariaRoleHasPresentationalChildren() const {\n  switch (m_ariaRole) {\n    case ButtonRole:\n    case SliderRole:\n    case ImageRole:\n    case ProgressIndicatorRole:\n    case SpinButtonRole:\n      return true;\n    default:\n      return false;\n  }\n}\n", "target": 0, "idx": 137919}
{"func": "  void DetachWebContentsTest(DiscardReason reason) {\n    LifecycleUnit* first_lifecycle_unit = nullptr;\n    LifecycleUnit* second_lifecycle_unit = nullptr;\n    CreateTwoTabs(true /* focus_tab_strip */, &first_lifecycle_unit,\n                  &second_lifecycle_unit);\n\n    ExpectCanDiscardTrueAllReasons(first_lifecycle_unit);\n    std::unique_ptr<content::WebContents> owned_contents =\n        tab_strip_model_->DetachWebContentsAt(0);\n    ExpectCanDiscardFalseTrivialAllReasons(first_lifecycle_unit);\n\n    NoUnloadListenerTabStripModelDelegate other_tab_strip_model_delegate;\n    TabStripModel other_tab_strip_model(&other_tab_strip_model_delegate,\n                                        profile());\n     other_tab_strip_model.AddObserver(source_);\n \n    EXPECT_CALL(source_observer_, OnLifecycleUnitCreated(testing::_));\n     other_tab_strip_model.AppendWebContents(CreateTestWebContents(),\n                                             /*foreground=*/true);\n \n    other_tab_strip_model.AppendWebContents(std::move(owned_contents), false);\n     ExpectCanDiscardTrueAllReasons(first_lifecycle_unit);\n \n     EXPECT_EQ(LifecycleUnitState::ACTIVE, first_lifecycle_unit->GetState());\n    EXPECT_CALL(tab_observer_, OnDiscardedStateChange(testing::_, true));\n     first_lifecycle_unit->Discard(reason);\n \n    testing::Mock::VerifyAndClear(&tab_observer_);\n     TransitionFromPendingDiscardToDiscardedIfNeeded(reason,\n                                                     first_lifecycle_unit);\n \n    CloseTabsAndExpectNotifications(&other_tab_strip_model,\n                                    {first_lifecycle_unit});\n  }\n", "target": 1, "idx": 186191}
{"func": "long Segment::DoParseNext(const Cluster*& pResult, long long& pos, long& len) {\n long long total, avail;\n\n long status = m_pReader->Length(&total, &avail);\n\n if (status < 0) // error\n return status;\n\n  assert((total < 0) || (avail <= total));\n\n const long long segment_stop = (m_size < 0) ? -1 : m_start + m_size;\n\n\n long long off_next = 0;\n long long cluster_size = -1;\n\n for (;;) {\n if ((total >= 0) && (pos >= total))\n return 1; // EOF\n\n if ((segment_stop >= 0) && (pos >= segment_stop))\n return 1; // EOF\n\n if ((pos + 1) > avail) {\n      len = 1;\n return E_BUFFER_NOT_FULL;\n }\n\n long long result = GetUIntLength(m_pReader, pos, len);\n\n if (result < 0) // error\n return static_cast<long>(result);\n\n if (result > 0) // weird\n return E_BUFFER_NOT_FULL;\n\n if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n return E_FILE_FORMAT_INVALID;\n\n if ((pos + len) > avail)\n return E_BUFFER_NOT_FULL;\n\n const long long idpos = pos; // absolute\n const long long idoff = pos - m_start; // relative\n\n const long long id = ReadUInt(m_pReader, idpos, len); // absolute\n\n if (id < 0) // error\n return static_cast<long>(id);\n\n if (id == 0) // weird\n return -1; // generic error\n\n    pos += len; // consume ID\n\n\n if ((pos + 1) > avail) {\n      len = 1;\n return E_BUFFER_NOT_FULL;\n }\n\n    result = GetUIntLength(m_pReader, pos, len);\n\n if (result < 0) // error\n return static_cast<long>(result);\n\n if (result > 0) // weird\n return E_BUFFER_NOT_FULL;\n\n if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n return E_FILE_FORMAT_INVALID;\n\n if ((pos + len) > avail)\n return E_BUFFER_NOT_FULL;\n\n const long long size = ReadUInt(m_pReader, pos, len);\n\n if (size < 0) // error\n return static_cast<long>(size);\n\n    pos += len; // consume length of size of element\n\n\n if (size == 0) // weird\n continue;\n\n const long long unknown_size = (1LL << (7 * len)) - 1;\n\n if ((segment_stop >= 0) && (size != unknown_size) &&\n ((pos + size) > segment_stop)) {\n return E_FILE_FORMAT_INVALID;\n }\n\n if (id == 0x0C53BB6B) { // Cues ID\n if (size == unknown_size)\n return E_FILE_FORMAT_INVALID;\n\n const long long element_stop = pos + size;\n\n if ((segment_stop >= 0) && (element_stop > segment_stop))\n return E_FILE_FORMAT_INVALID;\n\n const long long element_start = idpos;\n\n       const long long element_size = element_stop - element_start;\n \n       if (m_pCues == NULL) {\n        m_pCues = new Cues(this, pos, size, element_start, element_size);\n        assert(m_pCues);  // TODO\n       }\n \n       pos += size;  // consume payload\n      assert((segment_stop < 0) || (pos <= segment_stop));\n \n       continue;\n     }\n\n if (id != 0x0F43B675) { // not a Cluster ID\n if (size == unknown_size)\n\n         return E_FILE_FORMAT_INVALID;\n \n       pos += size;  // consume payload\n      assert((segment_stop < 0) || (pos <= segment_stop));\n \n       continue;\n     }\n \n#if 0  // this is commented-out to support incremental cluster parsing\n        len = static_cast<long>(size);\n        if (element_stop > avail)\n            return E_BUFFER_NOT_FULL;\n#endif\n     off_next = idoff;\n \n     if (size != unknown_size)\n      cluster_size = size;\n\n break;\n }\n\n  assert(off_next > 0); // have cluster\n\n\n Cluster** const ii = m_clusters + m_clusterCount;\n Cluster** i = ii;\n\n Cluster** const jj = ii + m_clusterPreloadCount;\n Cluster** j = jj;\n\n while (i < j) {\n\n Cluster** const k = i + (j - i) / 2;\n    assert(k < jj);\n\n const Cluster* const pNext = *k;\n    assert(pNext);\n    assert(pNext->m_index < 0);\n\n    pos = pNext->GetPosition();\n    assert(pos >= 0);\n\n if (pos < off_next)\n      i = k + 1;\n else if (pos > off_next)\n      j = k;\n else {\n      pResult = pNext;\n return 0; // success\n }\n }\n\n  assert(i == j);\n\n long long pos_;\n long len_;\n\n  status = Cluster::HasBlockEntries(this, off_next, pos_, len_);\n\n if (status < 0) { // error or underflow\n    pos = pos_;\n    len = len_;\n\n return status;\n }\n\n if (status > 0) { // means \"found at least one block entry\"\n\n     Cluster* const pNext = Cluster::Create(this,\n                                            -1,  // preloaded\n                                            off_next);\n    assert(pNext);\n \n     const ptrdiff_t idx_next = i - m_clusters;  // insertion position\n \n    PreloadCluster(pNext, idx_next);\n     assert(m_clusters);\n     assert(idx_next < m_clusterSize);\n     assert(m_clusters[idx_next] == pNext);\n\n    pResult = pNext;\n return 0; // success\n }\n\n\n if (cluster_size < 0) { // unknown size\n const long long payload_pos = pos; // absolute pos of cluster payload\n\n for (;;) { // determine cluster size\n if ((total >= 0) && (pos >= total))\n break;\n\n if ((segment_stop >= 0) && (pos >= segment_stop))\n break; // no more clusters\n\n\n if ((pos + 1) > avail) {\n        len = 1;\n return E_BUFFER_NOT_FULL;\n }\n\n long long result = GetUIntLength(m_pReader, pos, len);\n\n if (result < 0) // error\n return static_cast<long>(result);\n\n if (result > 0) // weird\n return E_BUFFER_NOT_FULL;\n\n if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n return E_FILE_FORMAT_INVALID;\n\n if ((pos + len) > avail)\n return E_BUFFER_NOT_FULL;\n\n const long long idpos = pos;\n const long long id = ReadUInt(m_pReader, idpos, len);\n\n if (id < 0) // error (or underflow)\n return static_cast<long>(id);\n\n\n if (id == 0x0F43B675) // Cluster ID\n break;\n\n if (id == 0x0C53BB6B) // Cues ID\n break;\n\n      pos += len; // consume ID (of sub-element)\n\n\n if ((pos + 1) > avail) {\n        len = 1;\n return E_BUFFER_NOT_FULL;\n }\n\n      result = GetUIntLength(m_pReader, pos, len);\n\n if (result < 0) // error\n return static_cast<long>(result);\n\n if (result > 0) // weird\n return E_BUFFER_NOT_FULL;\n\n if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n return E_FILE_FORMAT_INVALID;\n\n if ((pos + len) > avail)\n return E_BUFFER_NOT_FULL;\n\n const long long size = ReadUInt(m_pReader, pos, len);\n\n if (size < 0) // error\n return static_cast<long>(size);\n\n      pos += len; // consume size field of element\n\n\n if (size == 0) // weird\n continue;\n\n const long long unknown_size = (1LL << (7 * len)) - 1;\n\n if (size == unknown_size)\n return E_FILE_FORMAT_INVALID; // not allowed for sub-elements\n\n if ((segment_stop >= 0) && ((pos + size) > segment_stop)) // weird\n\n         return E_FILE_FORMAT_INVALID;\n \n       pos += size;  // consume payload of sub-element\n      assert((segment_stop < 0) || (pos <= segment_stop));\n     }  // determine cluster size\n \n     cluster_size = pos - payload_pos;\n    assert(cluster_size >= 0); // TODO: handle cluster_size = 0\n\n    pos = payload_pos; // reset and re-parse original cluster\n\n   }\n \n   pos += cluster_size;  // consume payload\n  assert((segment_stop < 0) || (pos <= segment_stop));\n \n   return 2;  // try to find a cluster that follows next\n }\n", "target": 1, "idx": 187832}
{"func": "static v8::Handle<v8::Value> methodThatRequiresAllArgsAndThrowsCallback(const v8::Arguments& args)\n {\n     INC_STATS(\"DOM.TestObj.methodThatRequiresAllArgsAndThrows\");\n     if (args.Length() < 2)\n        return V8Proxy::throwNotEnoughArgumentsError();\n     TestObj* imp = V8TestObj::toNative(args.Holder());\n     ExceptionCode ec = 0;\n     {\n    STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, strArg, MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined));\n    EXCEPTION_BLOCK(TestObj*, objArg, V8TestObj::HasInstance(MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined)) ? V8TestObj::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined))) : 0);\n    RefPtr<TestObj> result = imp->methodThatRequiresAllArgsAndThrows(strArg, objArg, ec);\n    if (UNLIKELY(ec))\n        goto fail;\n    return toV8(result.release(), args.GetIsolate());\n    }\n    fail:\n    V8Proxy::setDOMException(ec, args.GetIsolate());\n    return v8::Handle<v8::Value>();\n}\n", "target": 1, "idx": 184779}
{"func": "fbFetch_a8b8g8r8 (const FbBits *bits, int x, int width, CARD32 *buffer, miIndexedPtr indexed)\n{\n    const CARD32 *pixel = (CARD32 *)bits + x;\n    const CARD32 *end = pixel + width;\n    while (pixel < end) {\n        WRITE(buffer++, ((READ(pixel) & 0xff00ff00) |\n                         ((READ(pixel) >> 16) & 0xff) |\n                         ((READ(pixel) & 0xff) << 16)));\n        ++pixel;\n    }\n}\n", "target": 0, "idx": 11447}
{"func": "GF_Err lsrc_Size(GF_Box *s)\n{\n\tGF_LASERConfigurationBox *ptr = (GF_LASERConfigurationBox *)s;\n\tptr->size += ptr->hdr_size;\n\treturn GF_OK;\n}\n", "target": 0, "idx": 80201}
{"func": "  ObjectAttributeSetter(AXObjectAttribute attribute) : m_attribute(attribute) {}\n", "target": 0, "idx": 138017}
{"func": "PHP_FUNCTION(var_dump)\n{\n\tzval *args;\n\tint argc;\n\tint\ti;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"+\", &args, &argc) == FAILURE) {\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < argc; i++) {\n\t\tphp_var_dump(&args[i], 1);\n\t}\n}\n", "target": 0, "idx": 72360}
{"func": "download::DownloadInterruptReason DownloadManagerImpl::BeginDownloadRequest(\n    std::unique_ptr<net::URLRequest> url_request,\n    ResourceContext* resource_context,\n    download::DownloadUrlParameters* params) {\n  if (ResourceDispatcherHostImpl::Get()->is_shutdown())\n    return download::DOWNLOAD_INTERRUPT_REASON_USER_SHUTDOWN;\n\n  ResourceDispatcherHostImpl::Get()->InitializeURLRequest(\n      url_request.get(),\n      Referrer(params->referrer(),\n               Referrer::NetReferrerPolicyToBlinkReferrerPolicy(\n                    params->referrer_policy())),\n       true,  // download.\n       params->render_process_host_id(), params->render_view_host_routing_id(),\n      params->render_frame_host_routing_id(), PREVIEWS_OFF, resource_context);\n \n  url_request->set_first_party_url_policy(\n      net::URLRequest::UPDATE_FIRST_PARTY_URL_ON_REDIRECT);\n\n  const GURL& url = url_request->original_url();\n\n  const net::URLRequestContext* request_context = url_request->context();\n  if (!request_context->job_factory()->IsHandledProtocol(url.scheme())) {\n    DVLOG(1) << \"Download request for unsupported protocol: \"\n             << url.possibly_invalid_spec();\n    return download::DOWNLOAD_INTERRUPT_REASON_NETWORK_INVALID_REQUEST;\n  }\n\n  std::unique_ptr<ResourceHandler> handler(\n      DownloadResourceHandler::CreateForNewRequest(\n          url_request.get(), params->request_origin(),\n          params->download_source(), params->follow_cross_origin_redirects()));\n\n  ResourceDispatcherHostImpl::Get()->BeginURLRequest(\n      std::move(url_request), std::move(handler), true,  // download\n      params->content_initiated(), params->do_not_prompt_for_login(),\n      resource_context);\n  return download::DOWNLOAD_INTERRUPT_REASON_NONE;\n}\n", "target": 1, "idx": 187001}
{"func": "static inline void clgi(void)\n{\n\tasm volatile (__ex(SVM_CLGI));\n}\n", "target": 0, "idx": 37737}
{"func": "InputEventAckState RenderWidgetHostViewAura::FilterInputEvent(\n    const blink::WebInputEvent& input_event) {\n  bool consumed = false;\n  if (input_event.GetType() == WebInputEvent::kGestureFlingStart) {\n    const WebGestureEvent& gesture_event =\n        static_cast<const WebGestureEvent&>(input_event);\n    if (gesture_event.source_device == blink::kWebGestureDeviceTouchpad &&\n        !gesture_event.data.fling_start.velocity_x &&\n        !gesture_event.data.fling_start.velocity_y) {\n      consumed = true;\n    }\n  }\n\n  if (overscroll_controller_)\n    consumed |= overscroll_controller_->WillHandleEvent(input_event);\n\n  if (WebTouchEvent::IsTouchEventType(input_event.GetType()))\n    return INPUT_EVENT_ACK_STATE_NOT_CONSUMED;\n\n  if (consumed &&\n      input_event.GetType() == blink::WebInputEvent::kGestureFlingStart) {\n    return INPUT_EVENT_ACK_STATE_NO_CONSUMER_EXISTS;\n  }\n\n  return consumed ? INPUT_EVENT_ACK_STATE_CONSUMED\n                  : INPUT_EVENT_ACK_STATE_NOT_CONSUMED;\n}\n", "target": 0, "idx": 144901}
{"func": "static void userns_put(struct ns_common *ns)\n{\n\tput_user_ns(to_user_ns(ns));\n}\n", "target": 0, "idx": 76206}
{"func": "MagickBooleanType SyncExifProfile(Image *image,StringInfo *profile)\n{\n#define MaxDirectoryStack  16\n#define EXIF_DELIMITER  \"\\n\"\n#define EXIF_NUM_FORMATS  12\n#define TAG_EXIF_OFFSET  0x8769\n#define TAG_INTEROP_OFFSET  0xa005\n\n  typedef struct _DirectoryInfo\n  {\n    unsigned char\n      *directory;\n\n    size_t\n      entry;\n  } DirectoryInfo;\n\n  DirectoryInfo\n    directory_stack[MaxDirectoryStack];\n\n  EndianType\n    endian;\n\n  size_t\n    entry,\n    length,\n    number_entries;\n\n  ssize_t\n    id,\n    level,\n    offset;\n\n  static int\n    format_bytes[] = {0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8};\n\n  unsigned char\n    *directory,\n    *exif;\n\n  /*\n    Set EXIF resolution tag.\n  */\n  length=GetStringInfoLength(profile);\n  exif=GetStringInfoDatum(profile);\n  if (length < 16)\n    return(MagickFalse);\n  id=(ssize_t) ReadProfileShort(LSBEndian,exif);\n  if ((id != 0x4949) && (id != 0x4D4D))\n    {\n      while (length != 0)\n      {\n        if (ReadProfileByte(&exif,&length) != 0x45)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x78)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x69)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x66)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x00)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x00)\n          continue;\n        break;\n      }\n      if (length < 16)\n        return(MagickFalse);\n      id=(ssize_t) ReadProfileShort(LSBEndian,exif);\n    }\n  endian=LSBEndian;\n  if (id == 0x4949)\n    endian=LSBEndian;\n  else\n    if (id == 0x4D4D)\n      endian=MSBEndian;\n    else\n      return(MagickFalse);\n  if (ReadProfileShort(endian,exif+2) != 0x002a)\n    return(MagickFalse);\n  /*\n    This the offset to the first IFD.\n  */\n  offset=(ssize_t) ReadProfileLong(endian,exif+4);\n  if ((offset < 0) || (size_t) offset >= length)\n    return(MagickFalse);\n  directory=exif+offset;\n  level=0;\n  entry=0;\n  do\n  {\n    if (level > 0)\n      {\n        level--;\n        directory=directory_stack[level].directory;\n        entry=directory_stack[level].entry;\n      }\n    if ((directory < exif) || (directory > (exif+length-2)))\n      break;\n    /*\n      Determine how many entries there are in the current IFD.\n    */\n    number_entries=ReadProfileShort(endian,directory);\n    for ( ; entry < number_entries; entry++)\n    {\n      int\n        components;\n\n      register unsigned char\n        *p,\n        *q;\n\n      size_t\n        number_bytes;\n\n      ssize_t\n        format,\n        tag_value;\n\n      q=(unsigned char *) (directory+2+(12*entry));\n      if (q > (exif+length-12))\n         break;  /* corrupt EXIF */\n       tag_value=(ssize_t) ReadProfileShort(endian,q);\n       format=(ssize_t) ReadProfileShort(endian,q+2);\n      if ((format-1) >= EXIF_NUM_FORMATS)\n         break;\n       components=(ssize_t) ReadProfileLong(endian,q+4);\n       if (components < 0)\n        break;  /* corrupt EXIF */\n      number_bytes=(size_t) components*format_bytes[format];\n      if ((ssize_t) number_bytes < components)\n        break;  /* prevent overflow */\n      if (number_bytes <= 4)\n        p=q+8;\n      else\n        {\n          /*\n            The directory entry contains an offset.\n          */\n          offset=(ssize_t)  ReadProfileLong(endian,q+8);\n          if ((size_t) (offset+number_bytes) > length)\n            continue;\n          if (~length < number_bytes)\n            continue;  /* prevent overflow */\n          p=(unsigned char *) (exif+offset);\n        }\n      switch (tag_value)\n      {\n        case 0x011a:\n        {\n          (void) WriteProfileLong(endian,(size_t) (image->resolution.x+0.5),p);\n          (void) WriteProfileLong(endian,1UL,p+4);\n          break;\n        }\n        case 0x011b:\n        {\n          (void) WriteProfileLong(endian,(size_t) (image->resolution.y+0.5),p);\n          (void) WriteProfileLong(endian,1UL,p+4);\n          break;\n        }\n        case 0x0112:\n        {\n          if (number_bytes == 4)\n            {\n              (void) WriteProfileLong(endian,(size_t) image->orientation,p);\n              break;\n            }\n          (void) WriteProfileShort(endian,(unsigned short) image->orientation,\n            p);\n          break;\n        }\n        case 0x0128:\n        {\n          if (number_bytes == 4)\n            {\n              (void) WriteProfileLong(endian,(size_t) (image->units+1),p);\n              break;\n            }\n          (void) WriteProfileShort(endian,(unsigned short) (image->units+1),p);\n          break;\n        }\n        default:\n          break;\n      }\n      if ((tag_value == TAG_EXIF_OFFSET) || (tag_value == TAG_INTEROP_OFFSET))\n        {\n          offset=(ssize_t)  ReadProfileLong(endian,p);\n          if (((size_t) offset < length) && (level < (MaxDirectoryStack-2)))\n            {\n              directory_stack[level].directory=directory;\n              entry++;\n              directory_stack[level].entry=entry;\n              level++;\n              directory_stack[level].directory=exif+offset;\n              directory_stack[level].entry=0;\n              level++;\n              if ((directory+2+(12*number_entries)) > (exif+length))\n                break;\n              offset=(ssize_t)  ReadProfileLong(endian,directory+2+(12*\n                number_entries));\n              if ((offset != 0) && ((size_t) offset < length) &&\n                  (level < (MaxDirectoryStack-2)))\n                {\n                  directory_stack[level].directory=exif+offset;\n                  directory_stack[level].entry=0;\n                  level++;\n                }\n            }\n          break;\n        }\n    }\n  } while (level > 0);\n  return(MagickTrue);\n}\n", "target": 1, "idx": 181949}
{"func": "gfx::Point EventLocationFromNative(const base::NativeEvent& native_event) {\n  if (IsClientMouseEvent(native_event) && !IsMouseWheelEvent(native_event))\n    return gfx::Point(native_event.lParam);\n  DCHECK(IsNonClientMouseEvent(native_event) ||\n         IsMouseWheelEvent(native_event) || IsScrollEvent(native_event));\n  POINT native_point;\n  if (IsScrollEvent(native_event)) {\n    ::GetCursorPos(&native_point);\n  } else {\n    native_point.x = GET_X_LPARAM(native_event.lParam);\n    native_point.y = GET_Y_LPARAM(native_event.lParam);\n  }\n  ScreenToClient(native_event.hwnd, &native_point);\n  gfx::Point location(native_point);\n  location = gfx::win::ScreenToDIPPoint(location);\n  return location;\n}\n", "target": 0, "idx": 134189}
{"func": "bool ContentSecurityPolicy::AllowRequestWithoutIntegrity(\n    mojom::RequestContextType context,\n    const KURL& url,\n    RedirectStatus redirect_status,\n    SecurityViolationReportingPolicy reporting_policy,\n    CheckHeaderType check_header_type) const {\n  for (const auto& policy : policies_) {\n    if (CheckHeaderTypeMatches(check_header_type, policy->HeaderType()) &&\n        !policy->AllowRequestWithoutIntegrity(context, url, redirect_status,\n                                              reporting_policy))\n      return false;\n  }\n  return true;\n}\n", "target": 0, "idx": 165494}
{"func": "void AutomationMouseEventProcessor::RenderViewHostDestroyed(\n    RenderViewHost* host) {\n  InvokeCallback(automation::Error(\"The render view host was destroyed\"));\n}\n", "target": 0, "idx": 126041}
{"func": "  bool OnHostDomainPolicyUpdate(const std::string& host_domain) {\n    DCHECK(context_->network_task_runner()->BelongsToCurrentThread());\n\n    if (!host_domain.empty() &&\n        !EndsWith(xmpp_login_, std::string(\"@\") + host_domain, false)) {\n      Shutdown(kInvalidHostDomainExitCode);\n    }\n    return false;\n  }\n", "target": 0, "idx": 122027}
{"func": "l2tp_proxy_auth_id_print(netdissect_options *ndo, const u_char *dat)\n {\n \tconst uint16_t *ptr = (const uint16_t *)dat;\n \n \tND_PRINT((ndo, \"%u\", EXTRACT_16BITS(ptr) & L2TP_PROXY_AUTH_ID_MASK));\n }\n", "target": 1, "idx": 181071}
{"func": "ssh_packet_set_state(struct ssh *ssh, struct sshbuf *m)\n{\n\tstruct session_state *state = ssh->state;\n\tconst u_char *ssh1key, *ivin, *ivout, *keyin, *keyout, *input, *output;\n\tsize_t ssh1keylen, rlen, slen, ilen, olen;\n\tint r;\n\tu_int ssh1cipher = 0;\n\n\tif (!compat20) {\n\t\tif ((r = sshbuf_get_u32(m, &state->remote_protocol_flags)) != 0 ||\n\t\t    (r = sshbuf_get_u32(m, &ssh1cipher)) != 0 ||\n\t\t    (r = sshbuf_get_string_direct(m, &ssh1key, &ssh1keylen)) != 0 ||\n\t\t    (r = sshbuf_get_string_direct(m, &ivout, &slen)) != 0 ||\n\t\t    (r = sshbuf_get_string_direct(m, &ivin, &rlen)) != 0)\n\t\t\treturn r;\n\t\tif (ssh1cipher > INT_MAX)\n\t\t\treturn SSH_ERR_KEY_UNKNOWN_CIPHER;\n\t\tssh_packet_set_encryption_key(ssh, ssh1key, ssh1keylen,\n\t\t    (int)ssh1cipher);\n\t\tif (cipher_get_keyiv_len(state->send_context) != (int)slen ||\n\t\t    cipher_get_keyiv_len(state->receive_context) != (int)rlen)\n\t\t\treturn SSH_ERR_INVALID_FORMAT;\n\t\tif ((r = cipher_set_keyiv(state->send_context, ivout)) != 0 ||\n\t\t    (r = cipher_set_keyiv(state->receive_context, ivin)) != 0)\n\t\t\treturn r;\n\t} else {\n\t\tif ((r = kex_from_blob(m, &ssh->kex)) != 0 ||\n\t\t    (r = newkeys_from_blob(m, ssh, MODE_OUT)) != 0 ||\n\t\t    (r = newkeys_from_blob(m, ssh, MODE_IN)) != 0 ||\n\t\t    (r = sshbuf_get_u64(m, &state->rekey_limit)) != 0 ||\n\t\t    (r = sshbuf_get_u32(m, &state->rekey_interval)) != 0 ||\n\t\t    (r = sshbuf_get_u32(m, &state->p_send.seqnr)) != 0 ||\n\t\t    (r = sshbuf_get_u64(m, &state->p_send.blocks)) != 0 ||\n\t\t    (r = sshbuf_get_u32(m, &state->p_send.packets)) != 0 ||\n\t\t    (r = sshbuf_get_u64(m, &state->p_send.bytes)) != 0 ||\n\t\t    (r = sshbuf_get_u32(m, &state->p_read.seqnr)) != 0 ||\n\t\t    (r = sshbuf_get_u64(m, &state->p_read.blocks)) != 0 ||\n\t\t    (r = sshbuf_get_u32(m, &state->p_read.packets)) != 0 ||\n\t\t    (r = sshbuf_get_u64(m, &state->p_read.bytes)) != 0)\n\t\t\treturn r;\n\t\t/*\n\t\t * We set the time here so that in post-auth privsep slave we\n\t\t * count from the completion of the authentication.\n\t\t */\n\t\tstate->rekey_time = monotime();\n\t\t/* XXX ssh_set_newkeys overrides p_read.packets? XXX */\n\t\tif ((r = ssh_set_newkeys(ssh, MODE_IN)) != 0 ||\n\t\t    (r = ssh_set_newkeys(ssh, MODE_OUT)) != 0)\n\t\t\treturn r;\n\t}\n\tif ((r = sshbuf_get_string_direct(m, &keyout, &slen)) != 0 ||\n\t    (r = sshbuf_get_string_direct(m, &keyin, &rlen)) != 0)\n\t\treturn r;\n\tif (cipher_get_keycontext(state->send_context, NULL) != (int)slen ||\n\t    cipher_get_keycontext(state->receive_context, NULL) != (int)rlen)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n \tcipher_set_keycontext(state->send_context, keyout);\n \tcipher_set_keycontext(state->receive_context, keyin);\n \n\tif ((r = ssh_packet_set_compress_state(ssh, m)) != 0 ||\n\t    (r = ssh_packet_set_postauth(ssh)) != 0)\n \t\treturn r;\n \n \tsshbuf_reset(state->input);\n\tsshbuf_reset(state->output);\n\tif ((r = sshbuf_get_string_direct(m, &input, &ilen)) != 0 ||\n\t    (r = sshbuf_get_string_direct(m, &output, &olen)) != 0 ||\n\t    (r = sshbuf_put(state->input, input, ilen)) != 0 ||\n\t    (r = sshbuf_put(state->output, output, olen)) != 0)\n\t\treturn r;\n\n\tif (sshbuf_len(m))\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tdebug3(\"%s: done\", __func__);\n\treturn 0;\n}\n", "target": 1, "idx": 181828}
{"func": "void DomDistillerViewerSource::StartDataRequest(\n    const std::string& path,\n    int render_process_id,\n    int render_frame_id,\n    const content::URLDataSource::GotDataCallback& callback) {\n  content::RenderFrameHost* render_frame_host =\n      content::RenderFrameHost::FromID(render_process_id, render_frame_id);\n  if (!render_frame_host)\n    return;\n  content::RenderViewHost* render_view_host =\n      render_frame_host->GetRenderViewHost();\n  DCHECK(render_view_host);\n  CHECK_EQ(0, render_view_host->GetEnabledBindings());\n\n  if (kViewerCssPath == path) {\n    std::string css = viewer::GetCss();\n    callback.Run(base::RefCountedString::TakeString(&css));\n    return;\n  } else if (base::StartsWith(path, kViewerSaveFontScalingPath,\n                              base::CompareCase::SENSITIVE)) {\n    double scale = 1.0;\n    if (base::StringToDouble(\n        path.substr(strlen(kViewerSaveFontScalingPath)), &scale)) {\n      dom_distiller_service_->GetDistilledPagePrefs()->SetFontScaling(scale);\n    }\n  }\n  content::WebContents* web_contents =\n      content::WebContents::FromRenderFrameHost(render_frame_host);\n  DCHECK(web_contents);\n  const std::string path_after_query_separator =\n      path.size() > 0 ? path.substr(1) : \"\";\n  RequestViewerHandle* request_viewer_handle =\n      new RequestViewerHandle(web_contents, scheme_, path_after_query_separator,\n                              dom_distiller_service_->GetDistilledPagePrefs());\n  scoped_ptr<ViewerHandle> viewer_handle = viewer::CreateViewRequest(\n      dom_distiller_service_, path, request_viewer_handle,\n      web_contents->GetContainerBounds().size());\n\n  GURL current_url(url_utils::GetValueForKeyInUrlPathQuery(path, kUrlKey));\n  std::string unsafe_page_html = viewer::GetUnsafeArticleTemplateHtml(\n      url_utils::GetOriginalUrlFromDistillerUrl(current_url).spec(),\n      dom_distiller_service_->GetDistilledPagePrefs()->GetTheme(),\n      dom_distiller_service_->GetDistilledPagePrefs()->GetFontFamily());\n\n   render_frame_host->GetServiceRegistry()->AddService(\n       base::Bind(&CreateDistillerJavaScriptService,\n           render_frame_host,\n          external_feedback_reporter_.get()));\n \n   DistillerPageNotifierServicePtr page_notifier_service;\n  render_frame_host->GetServiceRegistry()->ConnectToRemoteService(\n      mojo::GetProxy(&page_notifier_service));\n  DCHECK(page_notifier_service);\n  page_notifier_service->NotifyIsDistillerPage();\n\n  if (viewer_handle) {\n    request_viewer_handle->TakeViewerHandle(viewer_handle.Pass());\n  } else {\n    request_viewer_handle->FlagAsErrorPage();\n  }\n\n  callback.Run(base::RefCountedString::TakeString(&unsafe_page_html));\n};\n", "target": 1, "idx": 185394}
{"func": " SPL_METHOD(FilesystemIterator, getFlags)\n {\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n\n\tRETURN_LONG(intern->flags & (SPL_FILE_DIR_KEY_MODE_MASK | SPL_FILE_DIR_CURRENT_MODE_MASK | SPL_FILE_DIR_OTHERS_MASK));\n} /* }}} */\n\n/* {{{ proto void FilesystemIterator::setFlags(long $flags)\n", "target": 1, "idx": 180216}
{"func": "set_value(png_bytep row, size_t rowbytes, png_uint_32 x, unsigned int bit_depth,\n   png_uint_32 value, png_const_bytep gamma_table, double conv)\n{\n unsigned int mask = (1U << bit_depth)-1;\n\n   x *= bit_depth; /* Maximum x is 4*1024, maximum bit_depth is 16 */\n\n if (value <= mask)\n {\n      png_uint_32 offset = x >> 3;\n\n if (offset < rowbytes && (bit_depth < 16 || offset+1 < rowbytes))\n {\n         row += offset;\n\n switch (bit_depth)\n {\n case 1:\n case 2:\n case 4:\n /* Don't gamma correct - values get smashed */\n {\n unsigned int shift = (8 - bit_depth) - (x & 0x7U);\n\n                  mask <<= shift;\n                  value = (value << shift) & mask;\n *row = (png_byte)((*row & ~mask) | value);\n }\n return;\n\n default:\n               fprintf(stderr, \"makepng: bad bit depth (internal error)\\n\");\n\n                exit(1);\n \n             case 16:\n               value = (unsigned int)floor(65535*pow(value/65535.,conv)+.5);\n                *row++ = (png_byte)(value >> 8);\n                *row = (png_byte)value;\n                return;\n\n case 8:\n *row = gamma_table[value];\n return;\n }\n }\n\n else\n {\n         fprintf(stderr, \"makepng: row buffer overflow (internal error)\\n\");\n         exit(1);\n }\n }\n\n else\n {\n      fprintf(stderr, \"makepng: component overflow (internal error)\\n\");\n      exit(1);\n\n    }\n }\n", "target": 1, "idx": 187607}
{"func": "int ssl_parse_certificate( ssl_context *ssl )\n{\n    int ret;\n    size_t i, n;\n\n    SSL_DEBUG_MSG( 2, ( \"=> parse certificate\" ) );\n\n    if( ssl->endpoint == SSL_IS_SERVER &&\n        ssl->authmode == SSL_VERIFY_NONE )\n    {\n        ssl->verify_result = BADCERT_SKIP_VERIFY;\n        SSL_DEBUG_MSG( 2, ( \"<= skip parse certificate\" ) );\n        ssl->state++;\n        return( 0 );\n    }\n\n    if( ( ret = ssl_read_record( ssl ) ) != 0 )\n    {\n        SSL_DEBUG_RET( 1, \"ssl_read_record\", ret );\n        return( ret );\n    }\n\n    ssl->state++;\n\n    /*\n     * Check if the client sent an empty certificate\n     */\n    if( ssl->endpoint  == SSL_IS_SERVER &&\n        ssl->minor_ver == SSL_MINOR_VERSION_0 )\n    {\n        if( ssl->in_msglen  == 2                        &&\n            ssl->in_msgtype == SSL_MSG_ALERT            &&\n            ssl->in_msg[0]  == SSL_ALERT_LEVEL_WARNING  &&\n            ssl->in_msg[1]  == SSL_ALERT_MSG_NO_CERT )\n        {\n            SSL_DEBUG_MSG( 1, ( \"SSLv3 client has no certificate\" ) );\n\n            ssl->verify_result = BADCERT_MISSING;\n            if( ssl->authmode == SSL_VERIFY_OPTIONAL )\n                return( 0 );\n            else\n                return( POLARSSL_ERR_SSL_NO_CLIENT_CERTIFICATE );\n        }\n    }\n\n    if( ssl->endpoint  == SSL_IS_SERVER &&\n        ssl->minor_ver != SSL_MINOR_VERSION_0 )\n    {\n        if( ssl->in_hslen   == 7                    &&\n            ssl->in_msgtype == SSL_MSG_HANDSHAKE    &&\n            ssl->in_msg[0]  == SSL_HS_CERTIFICATE   &&\n            memcmp( ssl->in_msg + 4, \"\\0\\0\\0\", 3 ) == 0 )\n        {\n            SSL_DEBUG_MSG( 1, ( \"TLSv1 client has no certificate\" ) );\n\n            ssl->verify_result = BADCERT_MISSING;\n            if( ssl->authmode == SSL_VERIFY_REQUIRED )\n                return( POLARSSL_ERR_SSL_NO_CLIENT_CERTIFICATE );\n            else\n                return( 0 );\n        }\n    }\n\n    if( ssl->in_msgtype != SSL_MSG_HANDSHAKE )\n    {\n        SSL_DEBUG_MSG( 1, ( \"bad certificate message\" ) );\n        return( POLARSSL_ERR_SSL_UNEXPECTED_MESSAGE );\n    }\n\n    if( ssl->in_msg[0] != SSL_HS_CERTIFICATE || ssl->in_hslen < 10 )\n    {\n        SSL_DEBUG_MSG( 1, ( \"bad certificate message\" ) );\n        return( POLARSSL_ERR_SSL_BAD_HS_CERTIFICATE );\n    }\n\n    /*\n     * Same message structure as in ssl_write_certificate()\n     */\n    n = ( ssl->in_msg[5] << 8 ) | ssl->in_msg[6];\n\n    if( ssl->in_msg[4] != 0 || ssl->in_hslen != 7 + n )\n    {\n        SSL_DEBUG_MSG( 1, ( \"bad certificate message\" ) );\n        return( POLARSSL_ERR_SSL_BAD_HS_CERTIFICATE );\n    }\n\n    if( ( ssl->session_negotiate->peer_cert = (x509_cert *) malloc(\n                    sizeof( x509_cert ) ) ) == NULL )\n    {\n        SSL_DEBUG_MSG( 1, ( \"malloc(%d bytes) failed\",\n                       sizeof( x509_cert ) ) );\n        return( POLARSSL_ERR_SSL_MALLOC_FAILED );\n    }\n\n    memset( ssl->session_negotiate->peer_cert, 0, sizeof( x509_cert ) );\n\n    i = 7;\n\n    while( i < ssl->in_hslen )\n    {\n        if( ssl->in_msg[i] != 0 )\n        {\n            SSL_DEBUG_MSG( 1, ( \"bad certificate message\" ) );\n            return( POLARSSL_ERR_SSL_BAD_HS_CERTIFICATE );\n        }\n\n        n = ( (unsigned int) ssl->in_msg[i + 1] << 8 )\n            | (unsigned int) ssl->in_msg[i + 2];\n        i += 3;\n\n        if( n < 128 || i + n > ssl->in_hslen )\n        {\n            SSL_DEBUG_MSG( 1, ( \"bad certificate message\" ) );\n             return( POLARSSL_ERR_SSL_BAD_HS_CERTIFICATE );\n         }\n \n        ret = x509parse_crt( ssl->session_negotiate->peer_cert, ssl->in_msg + i,\n                             n );\n         if( ret != 0 )\n         {\n             SSL_DEBUG_RET( 1, \" x509parse_crt\", ret );\n            return( ret );\n        }\n\n        i += n;\n    }\n\n    SSL_DEBUG_CRT( 3, \"peer certificate\", ssl->session_negotiate->peer_cert );\n\n    if( ssl->authmode != SSL_VERIFY_NONE )\n    {\n        if( ssl->ca_chain == NULL )\n        {\n            SSL_DEBUG_MSG( 1, ( \"got no CA chain\" ) );\n            return( POLARSSL_ERR_SSL_CA_CHAIN_REQUIRED );\n        }\n\n        ret = x509parse_verify( ssl->session_negotiate->peer_cert,\n                                ssl->ca_chain, ssl->ca_crl,\n                                ssl->peer_cn,  &ssl->verify_result,\n                                ssl->f_vrfy, ssl->p_vrfy );\n\n        if( ret != 0 )\n            SSL_DEBUG_RET( 1, \"x509_verify_cert\", ret );\n\n        if( ssl->authmode != SSL_VERIFY_REQUIRED )\n            ret = 0;\n    }\n\n    SSL_DEBUG_MSG( 2, ( \"<= parse certificate\" ) );\n\n    return( ret );\n}\n", "target": 1, "idx": 179126}
{"func": "mojom::FrameInputHandler* RenderFrameHostImpl::GetFrameInputHandler() {\n  if (legacy_frame_input_handler_)\n    return legacy_frame_input_handler_.get();\n  return frame_input_handler_.get();\n}\n", "target": 0, "idx": 160439}
{"func": "void net_checksum_calculate(uint8_t *data, int length)\n{\n     int hlen, plen, proto, csum_offset;\n     uint16_t csum;\n \n     if ((data[14] & 0xf0) != 0x40)\n        return; /* not IPv4 */\n     hlen  = (data[14] & 0x0f) * 4;\n\tcsum_offset = 16;\n\tbreak;\n    case PROTO_UDP:\n\tcsum_offset = 6;\n\tbreak;\n    default:\n\treturn;\n    }\n", "target": 1, "idx": 178354}
{"func": "  Ins_INSTCTRL( INS_ARG )\n  {\n    FT_Long  K, L;\n\n\n    K = args[1];\n    L = args[0];\n\n    if ( K < 1 || K > 2 )\n    {\n      if ( CUR.pedantic_hinting )\n        CUR.error = TT_Err_Invalid_Reference;\n      return;\n    }\n\n    if ( L != 0 )\n        L = K;\n\n    CUR.GS.instruct_control = FT_BOOL(\n      ( (FT_Byte)CUR.GS.instruct_control & ~(FT_Byte)K ) | (FT_Byte)L );\n  }\n", "target": 0, "idx": 10117}
{"func": "status_t SoftAVC::initDecoder() {\n if (H264SwDecInit(&mHandle, 0) == H264SWDEC_OK) {\n return OK;\n }\n return UNKNOWN_ERROR;\n}\n", "target": 0, "idx": 177052}
{"func": "static void cmdinfo()\n{\n\tfprintf(stderr, \"Image Information Utility (Version %s).\\n\",\n\t  JAS_VERSION);\n\tfprintf(stderr,\n\t  \"Copyright (c) 2001 Michael David Adams.\\n\"\n\t  \"All rights reserved.\\n\"\n\t  );\n}\n", "target": 0, "idx": 72667}
{"func": "void ImageLoader::dispose() {\n  RESOURCE_LOADING_DVLOG(1)\n      << \"~ImageLoader \" << this\n      << \"; m_hasPendingLoadEvent=\" << m_hasPendingLoadEvent\n      << \", m_hasPendingErrorEvent=\" << m_hasPendingErrorEvent;\n\n  if (m_image) {\n    m_image->removeObserver(this);\n    m_image = nullptr;\n  }\n}\n", "target": 0, "idx": 139020}
{"func": "FLAC__bool read_metadata_seektable_(FLAC__StreamDecoder *decoder, FLAC__bool is_last, unsigned length)\n{\n\tFLAC__uint32 i, x;\n\tFLAC__uint64 xx;\n\n\tFLAC__ASSERT(FLAC__bitreader_is_consumed_byte_aligned(decoder->private_->input));\n\n\tdecoder->private_->seek_table.type = FLAC__METADATA_TYPE_SEEKTABLE;\n\tdecoder->private_->seek_table.is_last = is_last;\n\tdecoder->private_->seek_table.length = length;\n\n\tdecoder->private_->seek_table.data.seek_table.num_points = length / FLAC__STREAM_METADATA_SEEKPOINT_LENGTH;\n\n /* use realloc since we may pass through here several times (e.g. after seeking) */\n if(0 == (decoder->private_->seek_table.data.seek_table.points = safe_realloc_mul_2op_(decoder->private_->seek_table.data.seek_table.points, decoder->private_->seek_table.data.seek_table.num_points, /*times*/sizeof(FLAC__StreamMetadata_SeekPoint)))) {\n\t\tdecoder->protected_->state = FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR;\n return false;\n }\n for(i = 0; i < decoder->private_->seek_table.data.seek_table.num_points; i++) {\n if(!FLAC__bitreader_read_raw_uint64(decoder->private_->input, &xx, FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN))\n return false; /* read_callback_ sets the state for us */\n\t\tdecoder->private_->seek_table.data.seek_table.points[i].sample_number = xx;\n\n if(!FLAC__bitreader_read_raw_uint64(decoder->private_->input, &xx, FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN))\n return false; /* read_callback_ sets the state for us */\n\t\tdecoder->private_->seek_table.data.seek_table.points[i].stream_offset = xx;\n\n if(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN))\n return false; /* read_callback_ sets the state for us */\n\t\tdecoder->private_->seek_table.data.seek_table.points[i].frame_samples = x;\n }\n\tlength -= (decoder->private_->seek_table.data.seek_table.num_points * FLAC__STREAM_METADATA_SEEKPOINT_LENGTH);\n /* if there is a partial point left, skip over it */\n if(length > 0) {\n /*@@@ do a send_error_to_client_() here?  there's an argument for either way */\n if(!FLAC__bitreader_skip_byte_block_aligned_no_crc(decoder->private_->input, length))\n return false; /* read_callback_ sets the state for us */\n }\n\n return true;\n}\n", "target": 0, "idx": 174407}
{"func": "static int mov_write_mvex_tag(AVIOContext *pb, MOVMuxContext *mov)\n{\n    int64_t pos = avio_tell(pb);\n    int i;\n    avio_wb32(pb, 0x0); /* size */\n    ffio_wfourcc(pb, \"mvex\");\n    for (i = 0; i < mov->nb_streams; i++)\n        mov_write_trex_tag(pb, &mov->tracks[i]);\n    return update_size(pb, pos);\n}\n", "target": 0, "idx": 79381}
{"func": "int vcc_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,\n\t\tsize_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct atm_vcc *vcc;\n \tstruct sk_buff *skb;\n \tint copied, error = -EINVAL;\n \n \tif (sock->state != SS_CONNECTED)\n \t\treturn -ENOTCONN;\n \n\t/* only handle MSG_DONTWAIT and MSG_PEEK */\n\tif (flags & ~(MSG_DONTWAIT | MSG_PEEK))\n\t\treturn -EOPNOTSUPP;\n\n\tvcc = ATM_SD(sock);\n\tif (test_bit(ATM_VF_RELEASED, &vcc->flags) ||\n\t    test_bit(ATM_VF_CLOSE, &vcc->flags) ||\n\t    !test_bit(ATM_VF_READY, &vcc->flags))\n\t\treturn 0;\n\n\tskb = skb_recv_datagram(sk, flags, flags & MSG_DONTWAIT, &error);\n\tif (!skb)\n\t\treturn error;\n\n\tcopied = skb->len;\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\terror = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (error)\n\t\treturn error;\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\n\tif (!(flags & MSG_PEEK)) {\n\t\tpr_debug(\"%d -= %d\\n\", atomic_read(&sk->sk_rmem_alloc),\n\t\t\t skb->truesize);\n\t\tatm_return(vcc, skb->truesize);\n\t}\n\n\tskb_free_datagram(sk, skb);\n\treturn copied;\n}\n", "target": 1, "idx": 179217}
{"func": "bool Frame::canHaveSecureChild() const\n{\n    for (const Frame* parent = this; parent; parent = parent->tree().parent()) {\n        if (!parent->securityContext()->getSecurityOrigin()->isPotentiallyTrustworthy())\n            return false;\n    }\n    return true;\n}\n", "target": 1, "idx": 186064}
{"func": "void DevToolsWindow::DoAction(const DevToolsToggleAction& action) {\n  switch (action.type()) {\n    case DevToolsToggleAction::kShowConsole: {\n      base::StringValue panel_name(\"console\");\n      bindings_->CallClientFunction(\"DevToolsAPI.showPanel\", &panel_name, NULL,\n                                    NULL);\n      break;\n    }\n    case DevToolsToggleAction::kShowSecurityPanel: {\n      base::StringValue panel_name(\"security\");\n      bindings_->CallClientFunction(\"DevToolsAPI.showPanel\", &panel_name, NULL,\n                                    NULL);\n      break;\n    }\n    case DevToolsToggleAction::kInspect:\n      bindings_->CallClientFunction(\n          \"DevToolsAPI.enterInspectElementMode\", NULL, NULL, NULL);\n      break;\n\n    case DevToolsToggleAction::kShow:\n    case DevToolsToggleAction::kToggle:\n      break;\n\n    case DevToolsToggleAction::kReveal: {\n      const DevToolsToggleAction::RevealParams* params =\n          action.params();\n      CHECK(params);\n      base::StringValue url_value(params->url);\n      base::FundamentalValue line_value(static_cast<int>(params->line_number));\n      base::FundamentalValue column_value(\n          static_cast<int>(params->column_number));\n      bindings_->CallClientFunction(\"DevToolsAPI.revealSourceLine\",\n                                    &url_value, &line_value, &column_value);\n      break;\n    }\n    default:\n      NOTREACHED();\n      break;\n  }\n}\n", "target": 0, "idx": 152911}
{"func": "static void tun_disable_queue(struct tun_struct *tun, struct tun_file *tfile)\n{\n\ttfile->detached = tun;\n\tlist_add_tail(&tfile->next, &tun->disabled);\n\t++tun->numdisabled;\n}\n", "target": 0, "idx": 93277}
{"func": "uint NotificationsEngine::Notify(const QString &app_name, uint replaces_id,\n                                 const QString &app_icon, const QString &summary, const QString &body,\n                                 const QStringList &actions, const QVariantMap &hints, int timeout)\n{\n    uint partOf = 0;\n    const QString appRealName = hints[QStringLiteral(\"x-kde-appname\")].toString();\n    const QString eventId = hints[QStringLiteral(\"x-kde-eventId\")].toString();\n    const bool skipGrouping = hints[QStringLiteral(\"x-kde-skipGrouping\")].toBool();\n\n    if (!replaces_id && m_activeNotifications.values().contains(app_name + summary) && !skipGrouping && !m_alwaysReplaceAppsList.contains(app_name)) {\n        partOf = m_activeNotifications.key(app_name + summary).midRef(13).toUInt();\n    }\n\n     qDebug() << \"Currrent active notifications:\" << m_activeNotifications;\n     qDebug() << \"Guessing partOf as:\" << partOf;\n     qDebug() << \" New Notification: \" << summary << body << timeout << \"& Part of:\" << partOf;\n    QString _body;\n \n     if (partOf > 0) {\n         const QString source = QStringLiteral(\"notification %1\").arg(partOf);\n         Plasma::DataContainer *container = containerForSource(source);\n         if (container) {\n            _body = container->data()[QStringLiteral(\"body\")].toString();\n            if (_body != body) {\n                _body.append(\"\\n\").append(body);\n            } else {\n                _body = body;\n             }\n \n             replaces_id = partOf;\n            CloseNotification(partOf);\n        }\n    }\n\n    uint id = replaces_id ? replaces_id : m_nextId++;\n\n    if (m_alwaysReplaceAppsList.contains(app_name)) {\n        if (m_notificationsFromReplaceableApp.contains(app_name)) {\n            id = m_notificationsFromReplaceableApp.value(app_name);\n        } else {\n            m_notificationsFromReplaceableApp.insert(app_name, id);\n        }\n    }\n\n    QString appname_str = app_name;\n    if (appname_str.isEmpty()) {\n        appname_str = i18n(\"Unknown Application\");\n    }\n\n    bool isPersistent = timeout == 0;\n\n \n     const int AVERAGE_WORD_LENGTH = 6;\n     const int WORD_PER_MINUTE = 250;\n    int count = summary.length() + body.length();\n \n        timeout = 60000 * count / AVERAGE_WORD_LENGTH / WORD_PER_MINUTE;\n\n        timeout = 2000 + qMax(timeout, 3000);\n    }\n", "target": 1, "idx": 178197}
{"func": "void AeroPeekManager::ActivateTab(int tab_id) {\n  TabContents* contents = GetTabContents(tab_id);\n  if (contents && contents->delegate())\n    contents->delegate()->ActivateContents(contents);\n}\n", "target": 0, "idx": 98461}
{"func": "void processRequest(struct reqelem * req)\n{\n\tssize_t n;\n\tunsigned int l, m;\n\tunsigned char buf[2048];\n\tconst unsigned char * p;\n\tint type;\n\tstruct device * d = devlist;\n\tunsigned char rbuf[4096];\n\tunsigned char * rp = rbuf+1;\n\tunsigned char nrep = 0;\n\ttime_t t;\n\tstruct service * newserv = NULL;\n\tstruct service * serv;\n\n\tn = read(req->socket, buf, sizeof(buf));\n\tif(n<0) {\n\t\tif(errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK)\n\t\t\treturn;\t/* try again later */\n\t\tsyslog(LOG_ERR, \"(s=%d) processRequest(): read(): %m\", req->socket);\n\t\tgoto error;\n\t}\n\tif(n==0) {\n\t\tsyslog(LOG_INFO, \"(s=%d) request connection closed\", req->socket);\n\t\tgoto error;\n\t}\n\tt = time(NULL);\n\ttype = buf[0];\n\tp = buf + 1;\n\tDECODELENGTH_CHECKLIMIT(l, p, buf + n);\n\tif(p+l > buf+n) {\n\t\tsyslog(LOG_WARNING, \"bad request (length encoding)\");\n\t\tgoto error;\n\t}\n\tif(l == 0 && type != 3) {\n\t\tsyslog(LOG_WARNING, \"bad request (length=0)\");\n\t\tgoto error;\n\t}\n\tsyslog(LOG_INFO, \"(s=%d) request type=%d str='%.*s'\",\n\t       req->socket, type, l, p);\n\tswitch(type) {\n\tcase 1:\t/* request by type */\n\tcase 2:\t/* request by USN (unique id) */\n\tcase 3:\t/* everything */\n\t\twhile(d && (nrep < 255)) {\n\t\t\tif(d->t < t) {\n\t\t\t\tsyslog(LOG_INFO, \"outdated device\");\n\t\t\t} else {\n\t\t\t\t/* test if we can put more responses in the buffer */\n\t\t\t\tif(d->headers[HEADER_LOCATION].l + d->headers[HEADER_NT].l\n\t\t\t\t  + d->headers[HEADER_USN].l + 6\n\t\t\t\t  + (rp - rbuf) >= (int)sizeof(rbuf))\n\t\t\t\t\tbreak;\n\t\t\t\tif( (type==1 && 0==memcmp(d->headers[HEADER_NT].p, p, l))\n\t\t\t\t  ||(type==2 && 0==memcmp(d->headers[HEADER_USN].p, p, l))\n\t\t\t\t  ||(type==3) ) {\n\t\t\t\t\t/* response :\n\t\t\t\t\t * 1 - Location\n\t\t\t\t\t * 2 - NT (device/service type)\n\t\t\t\t\t * 3 - usn */\n\t\t\t\t\tm = d->headers[HEADER_LOCATION].l;\n\t\t\t\t\tCODELENGTH(m, rp);\n\t\t\t\t\tmemcpy(rp, d->headers[HEADER_LOCATION].p, d->headers[HEADER_LOCATION].l);\n\t\t\t\t\trp += d->headers[HEADER_LOCATION].l;\n\t\t\t\t\tm = d->headers[HEADER_NT].l;\n\t\t\t\t\tCODELENGTH(m, rp);\n\t\t\t\t\tmemcpy(rp, d->headers[HEADER_NT].p, d->headers[HEADER_NT].l);\n\t\t\t\t\trp += d->headers[HEADER_NT].l;\n\t\t\t\t\tm = d->headers[HEADER_USN].l;\n\t\t\t\t\tCODELENGTH(m, rp);\n\t\t\t\t\tmemcpy(rp, d->headers[HEADER_USN].p, d->headers[HEADER_USN].l);\n\t\t\t\t\trp += d->headers[HEADER_USN].l;\n\t\t\t\t\tnrep++;\n\t\t\t\t}\n\t\t\t}\n\t\t\td = d->next;\n\t\t}\n\t\t/* Also look in service list */\n\t\tfor(serv = servicelisthead.lh_first;\n\t\t    serv && (nrep < 255);\n\t\t    serv = serv->entries.le_next) {\n\t\t\t/* test if we can put more responses in the buffer */\n\t\t\tif(strlen(serv->location) + strlen(serv->st)\n\t\t\t  + strlen(serv->usn) + 6 + (rp - rbuf) >= sizeof(rbuf))\n\t\t\t  \tbreak;\n\t\t\tif( (type==1 && 0==strncmp(serv->st, (const char *)p, l))\n\t\t\t  ||(type==2 && 0==strncmp(serv->usn, (const char *)p, l))\n\t\t\t  ||(type==3) ) {\n\t\t\t\t/* response :\n\t\t\t\t * 1 - Location\n\t\t\t\t * 2 - NT (device/service type)\n\t\t\t\t * 3 - usn */\n\t\t\t\tm = strlen(serv->location);\n\t\t\t\tCODELENGTH(m, rp);\n\t\t\t\tmemcpy(rp, serv->location, m);\n\t\t\t\trp += m;\n\t\t\t\tm = strlen(serv->st);\n\t\t\t\tCODELENGTH(m, rp);\n\t\t\t\tmemcpy(rp, serv->st, m);\n\t\t\t\trp += m;\n\t\t\t\tm = strlen(serv->usn);\n\t\t\t\tCODELENGTH(m, rp);\n\t\t\t\tmemcpy(rp, serv->usn, m);\n\t\t\t\trp += m;\n\t\t\t\tnrep++;\n\t\t\t}\n\t\t}\n\t\trbuf[0] = nrep;\n\t\tsyslog(LOG_DEBUG, \"(s=%d) response : %d device%s\",\n\t\t       req->socket, nrep, (nrep > 1) ? \"s\" : \"\");\n\t\tif(write(req->socket, rbuf, rp - rbuf) < 0) {\n\t\t\tsyslog(LOG_ERR, \"(s=%d) write: %m\", req->socket);\n\t\t\tgoto error;\n\t\t}\n\t\tbreak;\n\tcase 4:\t/* submit service */\n\t\tnewserv = malloc(sizeof(struct service));\n\t\tif(!newserv) {\n \t\t\tsyslog(LOG_ERR, \"cannot allocate memory\");\n \t\t\tgoto error;\n \t\t}\n \t\tif(containsForbiddenChars(p, l)) {\n \t\t\tsyslog(LOG_ERR, \"bad request (st contains forbidden chars)\");\n \t\t\tgoto error;\n\t\t}\n\t\tnewserv->st = malloc(l + 1);\n\t\tif(!newserv->st) {\n\t\t\tsyslog(LOG_ERR, \"cannot allocate memory\");\n\t\t\tgoto error;\n\t\t}\n\t\tmemcpy(newserv->st, p, l);\n\t\tnewserv->st[l] = '\\0';\n\t\tp += l;\n\t\tif(p >= buf + n) {\n\t\t\tsyslog(LOG_WARNING, \"bad request (missing usn)\");\n\t\t\tgoto error;\n\t\t}\n\t\tDECODELENGTH_CHECKLIMIT(l, p, buf + n);\n\t\tif(p+l > buf+n) {\n\t\t\tsyslog(LOG_WARNING, \"bad request (length encoding)\");\n\t\t\tgoto error;\n\t\t}\n\t\tif(containsForbiddenChars(p, l)) {\n\t\t\tsyslog(LOG_ERR, \"bad request (usn contains forbidden chars)\");\n\t\t\tgoto error;\n\t\t}\n\t\tsyslog(LOG_INFO, \"usn='%.*s'\", l, p);\n\t\tnewserv->usn = malloc(l + 1);\n\t\tif(!newserv->usn) {\n\t\t\tsyslog(LOG_ERR, \"cannot allocate memory\");\n\t\t\tgoto error;\n\t\t}\n\t\tmemcpy(newserv->usn, p, l);\n\t\tnewserv->usn[l] = '\\0';\n\t\tp += l;\n\t\tDECODELENGTH_CHECKLIMIT(l, p, buf + n);\n\t\tif(p+l > buf+n) {\n\t\t\tsyslog(LOG_WARNING, \"bad request (length encoding)\");\n\t\t\tgoto error;\n\t\t}\n\t\tif(containsForbiddenChars(p, l)) {\n\t\t\tsyslog(LOG_ERR, \"bad request (server contains forbidden chars)\");\n\t\t\tgoto error;\n\t\t}\n\t\tsyslog(LOG_INFO, \"server='%.*s'\", l, p);\n\t\tnewserv->server = malloc(l + 1);\n\t\tif(!newserv->server) {\n\t\t\tsyslog(LOG_ERR, \"cannot allocate memory\");\n\t\t\tgoto error;\n\t\t}\n\t\tmemcpy(newserv->server, p, l);\n\t\tnewserv->server[l] = '\\0';\n\t\tp += l;\n\t\tDECODELENGTH_CHECKLIMIT(l, p, buf + n);\n\t\tif(p+l > buf+n) {\n\t\t\tsyslog(LOG_WARNING, \"bad request (length encoding)\");\n\t\t\tgoto error;\n\t\t}\n\t\tif(containsForbiddenChars(p, l)) {\n\t\t\tsyslog(LOG_ERR, \"bad request (location contains forbidden chars)\");\n\t\t\tgoto error;\n\t\t}\n\t\tsyslog(LOG_INFO, \"location='%.*s'\", l, p);\n\t\tnewserv->location = malloc(l + 1);\n\t\tif(!newserv->location) {\n\t\t\tsyslog(LOG_ERR, \"cannot allocate memory\");\n\t\t\tgoto error;\n\t\t}\n\t\tmemcpy(newserv->location, p, l);\n\t\tnewserv->location[l] = '\\0';\n\t\t/* look in service list for duplicate */\n\t\tfor(serv = servicelisthead.lh_first;\n\t\t    serv;\n\t\t    serv = serv->entries.le_next) {\n\t\t\tif(0 == strcmp(newserv->usn, serv->usn)\n\t\t\t  && 0 == strcmp(newserv->st, serv->st)) {\n\t\t\t\tsyslog(LOG_INFO, \"Service allready in the list. Updating...\");\n\t\t\t\tfree(newserv->st);\n\t\t\t\tfree(newserv->usn);\n\t\t\t\tfree(serv->server);\n\t\t\t\tserv->server = newserv->server;\n\t\t\t\tfree(serv->location);\n\t\t\t\tserv->location = newserv->location;\n\t\t\t\tfree(newserv);\n\t\t\t\tnewserv = NULL;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t/* Inserting new service */\n\t\tLIST_INSERT_HEAD(&servicelisthead, newserv, entries);\n\t\tnewserv = NULL;\n\t\t/*rbuf[0] = '\\0';\n\t\tif(write(req->socket, rbuf, 1) < 0)\n\t\t\tsyslog(LOG_ERR, \"(s=%d) write: %m\", req->socket);\n\t\t*/\n\t\tbreak;\n\tdefault:\n\t\tsyslog(LOG_WARNING, \"Unknown request type %d\", type);\n\t\trbuf[0] = '\\0';\n\t\tif(write(req->socket, rbuf, 1) < 0) {\n\t\t\tsyslog(LOG_ERR, \"(s=%d) write: %m\", req->socket);\n\t\t\tgoto error;\n\t\t}\n\t}\n\treturn;\nerror:\n\tif(newserv) {\n\t\tfree(newserv->st);\n\t\tfree(newserv->usn);\n\t\tfree(newserv->server);\n\t\tfree(newserv->location);\n\t\tfree(newserv);\n\t\tnewserv = NULL;\n\t}\n\tclose(req->socket);\n\treq->socket = -1;\n\treturn;\n}\n", "target": 1, "idx": 182015}
{"func": "static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)\n{\n  unsigned char result = (unsigned char)(READBIT(*bitpointer, bitstream));\n  (*bitpointer)++;\n  return result;\n}\n", "target": 0, "idx": 87580}
{"func": " void mlock_vma_page(struct page *page)\n {\n \tBUG_ON(!PageLocked(page));\n \n \tif (!TestSetPageMlocked(page)) {\n\t\tmod_zone_page_state(page_zone(page), NR_MLOCK,\n\t\t\t\t    hpage_nr_pages(page));\n\t\tcount_vm_event(UNEVICTABLE_PGMLOCKED);\n\t\tif (!isolate_lru_page(page))\n\t\t\tputback_lru_page(page);\n\t}\n}\n", "target": 1, "idx": 179557}
{"func": "void ChromeOSCancelHandwriting(InputMethodStatusConnection* connection,\n                               int n_strokes) {\n  g_return_if_fail(connection);\n  connection->CancelHandwriting(n_strokes);\n }\n", "target": 1, "idx": 183977}
{"func": " Accelerator GetAccelerator(KeyboardCode code, int mask) {\n  return Accelerator(code, mask & (1 << 0), mask & (1 << 1), mask & (1 << 2));\n }\n", "target": 1, "idx": 184534}
{"func": "char *M_fs_path_tmpdir(M_fs_system_t sys_type)\n{\n\tchar         *d   = NULL;\n\tchar         *out = NULL;\n\tM_fs_error_t  res;\n\n#ifdef _WIN32\n\tsize_t len = M_fs_path_get_path_max(M_FS_SYSTEM_WINDOWS)+1;\n\td = M_malloc_zero(len);\n\t/* Return is length without NULL. */\n\tif (GetTempPath((DWORD)len, d) >= len) {\n\t\tM_free(d);\n\t\td = NULL;\n\t}\n#elif defined(__APPLE__)\n \td = M_fs_path_mac_tmpdir();\n #else\n \tconst char *const_temp;\n\t/* Try Unix env var. */\n #  ifdef HAVE_SECURE_GETENV\n \tconst_temp = secure_getenv(\"TMPDIR\");\n #  else\n\tconst_temp = getenv(\"TMPDIR\");\n#  endif\n\tif (!M_str_isempty(const_temp) && M_fs_perms_can_access(const_temp, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_WRITE) == M_FS_ERROR_SUCCESS) {\n\t\td = M_strdup(const_temp);\n\t}\n\t/* Fallback to some \"standard\" system paths. */\n\tif (d == NULL) {\n\t\tconst_temp = \"/tmp\";\n\t\tif (!M_str_isempty(const_temp) && M_fs_perms_can_access(const_temp, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_WRITE) == M_FS_ERROR_SUCCESS) {\n\t\t\td = M_strdup(const_temp);\n\t\t}\n\t}\n\tif (d == NULL) {\n\t\tconst_temp = \"/var/tmp\";\n\t\tif (!M_str_isempty(const_temp) && M_fs_perms_can_access(const_temp, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_WRITE) == M_FS_ERROR_SUCCESS) {\n\t\t\td = M_strdup(const_temp);\n\t\t}\n\t}\n#endif\n\n\tif (d != NULL) {\n\t\tres = M_fs_path_norm(&out, d, M_FS_PATH_NORM_ABSOLUTE, sys_type);\n\t\tif (res != M_FS_ERROR_SUCCESS) {\n\t\t\tout = NULL;\n\t\t}\n\t}\n\tM_free(d);\n\n\treturn out;\n}\n", "target": 1, "idx": 182319}
{"func": "print_trans(netdissect_options *ndo,\n            const u_char *words, const u_char *data1, const u_char *buf, const u_char *maxbuf)\n{\n    u_int bcc;\n    const char *f1, *f2, *f3, *f4;\n    const u_char *data, *param;\n    const u_char *w = words + 1;\n    int datalen, paramlen;\n\n    if (request) {\n\tND_TCHECK2(w[12 * 2], 2);\n\tparamlen = EXTRACT_LE_16BITS(w + 9 * 2);\n\tparam = buf + EXTRACT_LE_16BITS(w + 10 * 2);\n\tdatalen = EXTRACT_LE_16BITS(w + 11 * 2);\n\tdata = buf + EXTRACT_LE_16BITS(w + 12 * 2);\n\tf1 = \"TotParamCnt=[d] \\nTotDataCnt=[d] \\nMaxParmCnt=[d] \\nMaxDataCnt=[d]\\nMaxSCnt=[d] \\nTransFlags=[w] \\nRes1=[w] \\nRes2=[w] \\nRes3=[w]\\nParamCnt=[d] \\nParamOff=[d] \\nDataCnt=[d] \\nDataOff=[d] \\nSUCnt=[d]\\n\";\n\tf2 = \"|Name=[S]\\n\";\n\tf3 = \"|Param \";\n\tf4 = \"|Data \";\n    } else {\n\tND_TCHECK2(w[7 * 2], 2);\n\tparamlen = EXTRACT_LE_16BITS(w + 3 * 2);\n\tparam = buf + EXTRACT_LE_16BITS(w + 4 * 2);\n\tdatalen = EXTRACT_LE_16BITS(w + 6 * 2);\n\tdata = buf + EXTRACT_LE_16BITS(w + 7 * 2);\n\tf1 = \"TotParamCnt=[d] \\nTotDataCnt=[d] \\nRes1=[d]\\nParamCnt=[d] \\nParamOff=[d] \\nRes2=[d] \\nDataCnt=[d] \\nDataOff=[d] \\nRes3=[d]\\nLsetup=[d]\\n\";\n\tf2 = \"|Unknown \";\n\tf3 = \"|Param \";\n\tf4 = \"|Data \";\n    }\n\n    smb_fdata(ndo, words + 1, f1, min(words + 1 + 2 * words[0], maxbuf),\n        unicodestr);\n\n    ND_TCHECK2(*data1, 2);\n    bcc = EXTRACT_LE_16BITS(data1);\n     ND_PRINT((ndo, \"smb_bcc=%u\\n\", bcc));\n     if (bcc > 0) {\n \tsmb_fdata(ndo, data1 + 2, f2, maxbuf - (paramlen + datalen), unicodestr);\n\tif (strcmp((const char *)(data1 + 2), \"\\\\MAILSLOT\\\\BROWSE\") == 0) {\n \t    print_browse(ndo, param, paramlen, data, datalen);\n \t    return;\n \t}\n \n\tif (strcmp((const char *)(data1 + 2), \"\\\\PIPE\\\\LANMAN\") == 0) {\n \t    print_ipc(ndo, param, paramlen, data, datalen);\n \t    return;\n \t}\n \n \tif (paramlen)\n \t    smb_fdata(ndo, param, f3, min(param + paramlen, maxbuf), unicodestr);\n\tif (datalen)\n\t    smb_fdata(ndo, data, f4, min(data + datalen, maxbuf), unicodestr);\n    }\n    return;\ntrunc:\n    ND_PRINT((ndo, \"%s\", tstr));\n}\n", "target": 1, "idx": 182987}
{"func": "static inline int __sock_recvmsg_nosec(struct kiocb *iocb, struct socket *sock,\n\t\t\t\t       struct msghdr *msg, size_t size, int flags)\n{\n\treturn sock->ops->recvmsg(iocb, sock, msg, size, flags);\n}\n", "target": 0, "idx": 57913}
{"func": " MagickExport int LocaleUppercase(const int c)\n {\n  if (c < 0)\n     return(c);\n #if defined(MAGICKCORE_LOCALE_SUPPORT)\n   if (c_locale != (locale_t) NULL)\n    return(toupper_l((int) ((unsigned char) c),c_locale));\n#endif\n  return(toupper((int) ((unsigned char) c)));\n}\n", "target": 1, "idx": 183408}
{"func": "bool AppCacheBackendImpl::SelectCache(\n    int host_id,\n    const GURL& document_url,\n     const int64 cache_document_was_loaded_from,\n     const GURL& manifest_url) {\n   AppCacheHost* host = GetHost(host_id);\n  if (!host || host->was_select_cache_called())\n     return false;\n \n  host->SelectCache(document_url, cache_document_was_loaded_from,\n                     manifest_url);\n  return true;\n }\n", "target": 1, "idx": 185613}
{"func": "static void umount_tree(struct mount *mnt, enum umount_tree_flags how)\n{\n\tLIST_HEAD(tmp_list);\n\tstruct mount *p;\n\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_mount_unlock(mnt);\n\n\t/* Gather the mounts to umount */\n\tfor (p = mnt; p; p = next_mnt(p, mnt)) {\n\t\tp->mnt.mnt_flags |= MNT_UMOUNT;\n\t\tlist_move(&p->mnt_list, &tmp_list);\n\t}\n\n\t/* Hide the mounts from mnt_mounts */\n\tlist_for_each_entry(p, &tmp_list, mnt_list) {\n\t\tlist_del_init(&p->mnt_child);\n\t}\n\n\t/* Add propogated mounts to the tmp_list */\n\tif (how & UMOUNT_PROPAGATE)\n \t\tpropagate_umount(&tmp_list);\n \n \twhile (!list_empty(&tmp_list)) {\n \t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n \t\tlist_del_init(&p->mnt_expire);\n \t\tlist_del_init(&p->mnt_list);\n\t\t__touch_mnt_namespace(p->mnt_ns);\n\t\tp->mnt_ns = NULL;\n \t\tif (how & UMOUNT_SYNC)\n \t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n \n\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt, &unmounted);\n \t\tif (mnt_has_parent(p)) {\n \t\t\tmnt_add_count(p->mnt_parent, -1);\n\t\t\tumount_mnt(p);\n \t\t}\n \t\tchange_mnt_propagation(p, MS_PRIVATE);\n \t}\n}\n", "target": 1, "idx": 180762}
{"func": " void TaskService::RunTask(InstanceId instance_id,\n                           RunnerId runner_id,\n                           base::OnceClosure task) {\n  base::subtle::AutoReadLock task_lock(task_lock_);\n   {\n    base::AutoLock lock(lock_);\n    if (instance_id != bound_instance_id_)\n      return;\n   }\n  std::move(task).Run();\n }\n", "target": 1, "idx": 186180}
{"func": "luks_unlock_device_not_seen_cb (gpointer user_data)\n{\n  UnlockEncryptionData *data = user_data;\n\n  g_signal_handler_disconnect (data->device->priv->daemon, data->device_added_signal_handler_id);\n  g_signal_handler_disconnect (data->device->priv->daemon, data->device_changed_signal_handler_id);\n\n  throw_error (data->context,\n               ERROR_FAILED,\n               \"Error unlocking device: timeout (10s) waiting for cleartext device to show up\");\n\n  if (data->hook_func != NULL)\n    {\n      data->hook_func (data->context, NULL, data->hook_user_data);\n    }\n\n  unlock_encryption_data_unref (data);\n  return FALSE;\n}\n", "target": 0, "idx": 11773}
{"func": "bool HTMLInputElement::IsInRange() const {\n  return willValidate() && input_type_->IsInRange(value());\n}\n", "target": 0, "idx": 136912}
{"func": " int sfgets(void)\n {\n     struct pollfd pfd;\n     int pollret;\n     ssize_t readnb;\n     signed char seen_r = 0;\n    static size_t scanned;\n    static size_t readnbd;\n     \n     if (scanned > (size_t) 0U) {       /* support pipelining */\n         readnbd -= scanned;        \n        memmove(cmd, cmd + scanned, readnbd);   /* safe */\n        scanned = (size_t) 0U;\n    }\n    pfd.fd = clientfd;\n#ifdef __APPLE_CC__\n    pfd.events = POLLIN | POLLERR | POLLHUP;\n#else\n    pfd.events = POLLIN | POLLPRI | POLLERR | POLLHUP;\n#endif\n    while (scanned < cmdsize) {\n        if (scanned >= readnbd) {      /* nothing left in the buffer */\n            pfd.revents = 0;\n            while ((pollret = poll(&pfd, 1U, idletime * 1000UL)) < 0 &&\n                   errno == EINTR);\n            if (pollret == 0) {\n                return -1;\n            }\n            if (pollret <= 0 ||\n                (pfd.revents & (POLLERR | POLLHUP | POLLNVAL)) != 0) {\n                return -2;\n            }\n            if ((pfd.revents & (POLLIN | POLLPRI)) == 0) {\n                continue;\n            }\n            if (readnbd >= cmdsize) {\n                break;\n            }\n#ifdef WITH_TLS\n            if (tls_cnx != NULL) {\n                while ((readnb = SSL_read\n                        (tls_cnx, cmd + readnbd, cmdsize - readnbd))\n                       < (ssize_t) 0 && errno == EINTR);\n            } else\n#endif\n            {\n                while ((readnb = read(clientfd, cmd + readnbd,\n                                      cmdsize - readnbd)) < (ssize_t) 0 &&\n                       errno == EINTR);\n            }\n            if (readnb <= (ssize_t) 0) {\n                return -2;\n            }\n            readnbd += readnb;\n            if (readnbd > cmdsize) {\n                return -2;\n            }\n        }\n#ifdef RFC_CONFORMANT_LINES\n        if (seen_r != 0) {\n#endif\n            if (cmd[scanned] == '\\n') {\n#ifndef RFC_CONFORMANT_LINES\n                if (seen_r != 0) {\n#endif\n                    cmd[scanned - 1U] = 0;\n#ifndef RFC_CONFORMANT_LINES\n                } else {\n                    cmd[scanned] = 0;\n                }\n#endif\n                if (++scanned >= readnbd) {   /* non-pipelined command */\n                    scanned = readnbd = (size_t) 0U;\n                }\n                return 0;\n            }\n            seen_r = 0;\n#ifdef RFC_CONFORMANT_LINES\n        }\n#endif\n        if (ISCTRLCODE(cmd[scanned])) {\n            if (cmd[scanned] == '\\r') {\n                seen_r = 1;\n            }\n#ifdef RFC_CONFORMANT_PARSER                   /* disabled by default, intentionnaly */\n            else if (cmd[scanned] == 0) {\n                cmd[scanned] = '\\n';\n            }\n#else\n            /* replace control chars with _ */\n            cmd[scanned] = '_';                \n#endif\n        }\n        scanned++;\n    }\n    die(421, LOG_WARNING, MSG_LINE_TOO_LONG);   /* don't remove this */\n    \n    return 0;                         /* to please GCC */\n}\n", "target": 1, "idx": 178698}
{"func": "static inline double GetFITSPixelRange(const size_t depth)\n{\n  return((double) ((MagickOffsetType) GetQuantumRange(depth)));\n}\n", "target": 0, "idx": 71542}
{"func": "long long Cluster::GetFirstTime() const\n{\n    const BlockEntry* pEntry;\n    const long status = GetFirst(pEntry);\n    if (status < 0)  //error\n        return status;\n    if (pEntry == NULL)  //empty cluster\n        return GetTime();\n    const Block* const pBlock = pEntry->GetBlock();\n    assert(pBlock);\n    return pBlock->GetTime(this);\n}\n", "target": 1, "idx": 188345}
{"func": "varbit_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *input_string = PG_GETARG_CSTRING(0);\n\n#ifdef NOT_USED\n\tOid\t\t\ttypelem = PG_GETARG_OID(1);\n#endif\n\tint32\t\tatttypmod = PG_GETARG_INT32(2);\n\tVarBit\t   *result;\t\t\t/* The resulting bit string\t\t\t  */\n\tchar\t   *sp;\t\t\t\t/* pointer into the character string  */\n\tbits8\t   *r;\t\t\t\t/* pointer into the result */\n\tint\t\t\tlen,\t\t\t/* Length of the whole data structure */\n\t\t\t\tbitlen,\t\t\t/* Number of bits in the bit string   */\n\t\t\t\tslen;\t\t\t/* Length of the input string\t\t  */\n\tbool\t\tbit_not_hex;\t/* false = hex string  true = bit string */\n\tint\t\t\tbc;\n\tbits8\t\tx = 0;\n\n\t/* Check that the first character is a b or an x */\n\tif (input_string[0] == 'b' || input_string[0] == 'B')\n\t{\n\t\tbit_not_hex = true;\n\t\tsp = input_string + 1;\n\t}\n\telse if (input_string[0] == 'x' || input_string[0] == 'X')\n\t{\n\t\tbit_not_hex = false;\n\t\tsp = input_string + 1;\n\t}\n\telse\n\t{\n\t\tbit_not_hex = true;\n \t\tsp = input_string;\n \t}\n \n \tslen = strlen(sp);\n\t/* Determine bitlength from input string */\n \tif (bit_not_hex)\n \t\tbitlen = slen;\n \telse\n \t\tbitlen = slen * 4;\n \n \t/*\n \t * Sometimes atttypmod is not supplied. If it is supplied we need to make\n\t * sure that the bitstring fits.\n\t */\n\tif (atttypmod <= 0)\n\t\tatttypmod = bitlen;\n\telse if (bitlen > atttypmod)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_STRING_DATA_RIGHT_TRUNCATION),\n\t\t\t\t errmsg(\"bit string too long for type bit varying(%d)\",\n\t\t\t\t\t\tatttypmod)));\n\n\tlen = VARBITTOTALLEN(bitlen);\n\t/* set to 0 so that *r is always initialised and string is zero-padded */\n\tresult = (VarBit *) palloc0(len);\n\tSET_VARSIZE(result, len);\n\tVARBITLEN(result) = Min(bitlen, atttypmod);\n\n\tr = VARBITS(result);\n\tif (bit_not_hex)\n\t{\n\t\t/* Parse the bit representation of the string */\n\t\t/* We know it fits, as bitlen was compared to atttypmod */\n\t\tx = HIGHBIT;\n\t\tfor (; *sp; sp++)\n\t\t{\n\t\t\tif (*sp == '1')\n\t\t\t\t*r |= x;\n\t\t\telse if (*sp != '0')\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"\\\"%c\\\" is not a valid binary digit\",\n\t\t\t\t\t\t\t\t*sp)));\n\n\t\t\tx >>= 1;\n\t\t\tif (x == 0)\n\t\t\t{\n\t\t\t\tx = HIGHBIT;\n\t\t\t\tr++;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Parse the hex representation of the string */\n\t\tfor (bc = 0; *sp; sp++)\n\t\t{\n\t\t\tif (*sp >= '0' && *sp <= '9')\n\t\t\t\tx = (bits8) (*sp - '0');\n\t\t\telse if (*sp >= 'A' && *sp <= 'F')\n\t\t\t\tx = (bits8) (*sp - 'A') + 10;\n\t\t\telse if (*sp >= 'a' && *sp <= 'f')\n\t\t\t\tx = (bits8) (*sp - 'a') + 10;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"\\\"%c\\\" is not a valid hexadecimal digit\",\n\t\t\t\t\t\t\t\t*sp)));\n\n\t\t\tif (bc)\n\t\t\t{\n\t\t\t\t*r++ |= x;\n\t\t\t\tbc = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t*r = x << 4;\n\t\t\t\tbc = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tPG_RETURN_VARBIT_P(result);\n}\n", "target": 1, "idx": 179591}
{"func": "mp_join_print(netdissect_options *ndo,\n              const u_char *opt, u_int opt_len, u_char flags)\n {\n         const struct mp_join *mpj = (const struct mp_join *) opt;\n \n        if (!(opt_len == 12 && flags & TH_SYN) &&\n             !(opt_len == 16 && (flags & (TH_SYN | TH_ACK)) == (TH_SYN | TH_ACK)) &&\n            !(opt_len == 24 && flags & TH_ACK))\n                 return 0;\n \n         if (opt_len != 24) {\n                if (mpj->sub_b & MP_JOIN_B)\n                        ND_PRINT((ndo, \" backup\"));\n                ND_PRINT((ndo, \" id %u\", mpj->addr_id));\n        }\n\n        switch (opt_len) {\n        case 12: /* SYN */\n                ND_PRINT((ndo, \" token 0x%x\" \" nonce 0x%x\",\n                        EXTRACT_32BITS(mpj->u.syn.token),\n                        EXTRACT_32BITS(mpj->u.syn.nonce)));\n                break;\n        case 16: /* SYN/ACK */\n                ND_PRINT((ndo, \" hmac 0x%\" PRIx64 \" nonce 0x%x\",\n                        EXTRACT_64BITS(mpj->u.synack.mac),\n                        EXTRACT_32BITS(mpj->u.synack.nonce)));\n                break;\n        case 24: {/* ACK */\n                size_t i;\n                ND_PRINT((ndo, \" hmac 0x\"));\n                for (i = 0; i < sizeof(mpj->u.ack.mac); ++i)\n                        ND_PRINT((ndo, \"%02x\", mpj->u.ack.mac[i]));\n        }\n        default:\n                break;\n        }\n         return 1;\n }\n", "target": 1, "idx": 181010}
{"func": "hugetlbfs_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct inode * inode;\n\tstruct dentry * root;\n\tint ret;\n\tstruct hugetlbfs_config config;\n\tstruct hugetlbfs_sb_info *sbinfo;\n\n\tsave_mount_options(sb, data);\n\n\tconfig.nr_blocks = -1; /* No limit on size by default */\n\tconfig.nr_inodes = -1; /* No limit on number of inodes by default */\n\tconfig.uid = current_fsuid();\n\tconfig.gid = current_fsgid();\n\tconfig.mode = 0755;\n\tconfig.hstate = &default_hstate;\n\tret = hugetlbfs_parse_options(data, &config);\n\tif (ret)\n\t\treturn ret;\n\n\tsbinfo = kmalloc(sizeof(struct hugetlbfs_sb_info), GFP_KERNEL);\n\tif (!sbinfo)\n\t\treturn -ENOMEM;\n \tsb->s_fs_info = sbinfo;\n \tsbinfo->hstate = config.hstate;\n \tspin_lock_init(&sbinfo->stat_lock);\n\tsbinfo->max_blocks = config.nr_blocks;\n\tsbinfo->free_blocks = config.nr_blocks;\n \tsbinfo->max_inodes = config.nr_inodes;\n \tsbinfo->free_inodes = config.nr_inodes;\n \tsb->s_maxbytes = MAX_LFS_FILESIZE;\n \tsb->s_blocksize = huge_page_size(config.hstate);\n \tsb->s_blocksize_bits = huge_page_shift(config.hstate);\n\tsb->s_magic = HUGETLBFS_MAGIC;\n\tsb->s_op = &hugetlbfs_ops;\n\tsb->s_time_gran = 1;\n\tinode = hugetlbfs_get_root(sb, &config);\n\tif (!inode)\n\t\tgoto out_free;\n\n\troot = d_alloc_root(inode);\n\tif (!root) {\n\t\tiput(inode);\n\t\tgoto out_free;\n\t}\n \tsb->s_root = root;\n \treturn 0;\n out_free:\n \tkfree(sbinfo);\n \treturn -ENOMEM;\n }\n", "target": 1, "idx": 178777}
{"func": "parse_wbxml_tag_defined (proto_tree *tree, tvbuff_t *tvb, guint32 offset,\n\t\t\t guint32 str_tbl, guint8 *level, guint8 *codepage_stag, guint8 *codepage_attr,\n \t\t\t const wbxml_decoding *map)\n {\n \tguint32     tvb_len  = tvb_reported_length (tvb);\n\tguint32     off      = offset;\n \tguint32     len;\n \tguint       str_len;\n \tguint32     ent;\n\tguint32     idx;\n\tguint8      peek;\n\tguint32     tag_len;                     /* Length of the index (uintvar) from a LITERAL tag */\n\tguint8      tag_save_known      = 0;     /* Will contain peek & 0x3F (tag identity) */\n\tguint8      tag_new_known       = 0;     /* Will contain peek & 0x3F (tag identity) */\n\tconst char *tag_save_literal;            /* Will contain the LITERAL tag identity */\n\tconst char *tag_new_literal;             /* Will contain the LITERAL tag identity */\n\tguint8      parsing_tag_content = FALSE; /* Are we parsing content from a\n\t\t\t\t\t            tag with content: <x>Content</x>\n\n\t\t\t\t\t            The initial state is FALSE.\n\t\t\t\t\t            This state will trigger recursion. */\n \ttag_save_literal = NULL;                 /* Prevents compiler warning */\n \n \tDebugLog((\"parse_wbxml_tag_defined (level = %u, offset = %u)\\n\", *level, offset));\n \twhile (off < tvb_len) {\n \t\tpeek = tvb_get_guint8 (tvb, off);\n \t\tDebugLog((\"STAG: (top of while) level = %3u, peek = 0x%02X, off = %u, tvb_len = %u\\n\", *level, peek, off, tvb_len));\n\t\tif ((peek & 0x3F) < 4) switch (peek) { /* Global tokens in state = STAG\n\t\t\t\t\t\t\t  but not the LITERAL tokens */\n\t\tcase 0x00: /* SWITCH_PAGE */\n\t\t\t*codepage_stag = tvb_get_guint8 (tvb, off+1);\n\t\t\tproto_tree_add_text (tree, tvb, off, 2,\n\t\t\t\t\t     \"      | Tag   | T -->%3d \"\n\t\t\t\t\t     \"| SWITCH_PAGE (Tag code page)     \"\n\t\t\t\t\t     \"|\",\n\t\t\t\t\t     *codepage_stag);\n\t\t\toff += 2;\n\t\t\tbreak;\n\t\tcase 0x01: /* END: only possible for Tag with Content */\n\t\t\tif (tag_save_known) { /* Known TAG */\n\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t     \"| END (Known Tag 0x%02X)            \"\n\t\t\t\t\t\t     \"| %s</%s>\",\n\t\t\t\t\t\t     *level, *codepage_stag,\n\t\t\t\t\t\t     tag_save_known, Indent (*level),\n\t\t\t\t\t\t     tag_save_literal); /* We already looked it up! */\n\t\t\t} else { /* Literal TAG */\n\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t     \"| END (Literal Tag)               \"\n\t\t\t\t\t\t     \"| %s</%s>\",\n\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level),\n\t\t\t\t\t\t     tag_save_literal ? tag_save_literal : \"\");\n\t\t\t}\n\t\t\t(*level)--;\n\t\t\toff++;\n\t\t\t/* Reset code page: not needed as return from recursion */\n\t\t\tDebugLog((\"STAG: level = %u, Return: len = %u\\n\", *level, off - offset));\n\t\t\treturn (off - offset);\n\t\tcase 0x02: /* ENTITY */\n\t\t\tent = tvb_get_guintvar (tvb, off+1, &len);\n\t\t\tproto_tree_add_text (tree, tvb, off, 1+len,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t     \"| ENTITY                          \"\n\t\t\t\t\t     \"| %s'&#%u;'\",\n\t\t\t\t\t     *level, *codepage_stag, Indent (*level), ent);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x03: /* STR_I */\n\t\t\tlen = tvb_strsize (tvb, off+1);\n\t\t\tproto_tree_add_text (tree, tvb, off, 1+len,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t     \"| STR_I (Inline string)           \"\n\t\t\t\t\t     \"| %s\\'%s\\'\",\n\t\t\t\t\t     *level, *codepage_stag, Indent(*level),\n\t\t\t\t\t     tvb_format_text (tvb, off+1, len-1));\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x40: /* EXT_I_0 */\n\t\tcase 0x41: /* EXT_I_1 */\n\t\tcase 0x42: /* EXT_I_2 */\n\t\t\t/* Extension tokens */\n\t\t\tlen = tvb_strsize (tvb, off+1);\n\t\t\tproto_tree_add_text (tree, tvb, off, 1+len,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t     \"| EXT_I_%1x    (Extension Token)    \"\n\t\t\t\t\t     \"| %s(%s: \\'%s\\')\",\n\t\t\t\t\t     *level, *codepage_stag,\n\t\t\t\t\t     peek & 0x0f, Indent (*level),\n\t\t\t\t\t     map_token (map->global, 0, peek),\n\t\t\t\t\t     tvb_format_text (tvb, off+1, len-1));\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x43: /* PI */\n\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t     \"| PI (XML Processing Instruction) \"\n\t\t\t\t\t     \"| %s<?xml\",\n\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb, off,\n\t\t\t\t\t\t\t\t  str_tbl, *level, codepage_attr, map);\n\t\t\t/* Check that there is still room in packet */\n\t\t\toff += len;\n\t\t\tif (off >= tvb_len) {\n\t\t\t\tDebugLog((\"STAG: level = %u, ThrowException: len = %u (short frame)\\n\", *level, off - offset));\n\t\t\t\t/*\n\t\t\t\t * TODO - Do we need to free g_malloc()ed memory?\n\t\t\t\t */\n\t\t\t\tTHROW(ReportedBoundsError);\n\t\t\t}\n\t\t\tproto_tree_add_text (tree, tvb, off-1, 1,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t     \"| END (PI)                        \"\n\t\t\t\t\t     \"| %s?>\",\n\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\tbreak;\n\t\tcase 0x80: /* EXT_T_0 */\n\t\tcase 0x81: /* EXT_T_1 */\n\t\tcase 0x82: /* EXT_T_2 */\n\t\t\t/* Extension tokens */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len);\n\t\t\t{   char *s;\n\t\t\t\tif (map->ext_t[peek & 0x03])\n\t\t\t\t\ts = (map->ext_t[peek & 0x03])(tvb, idx, str_tbl);\n\t\t\t\telse\n\t\t\t\t\ts = wmem_strdup_printf(wmem_packet_scope(), \"EXT_T_%1x (%s)\", peek & 0x03,\n\t\t\t\t\t\t\t    map_token (map->global, 0, peek));\n\t\t\t\tproto_tree_add_text (tree, tvb, off, 1+len,\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t     \"| EXT_T_%1x    (Extension Token)    \"\n\t\t\t\t\t\t     \"| %s%s\",\n\t\t\t\t\t\t     *level, *codepage_stag, peek & 0x0f, Indent (*level),\n\t\t\t\t\t\t     s);\n\t\t\t}\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x83: /* STR_T */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len);\n\t\t\tstr_len = tvb_strsize (tvb, str_tbl+idx);\n\t\t\tproto_tree_add_text (tree, tvb, off, 1+len,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t     \"| STR_T (Tableref string)         \"\n\t\t\t\t\t     \"| %s\\'%s\\'\",\n\t\t\t\t\t     *level, *codepage_stag, Indent (*level),\n\t\t\t\t\t     tvb_format_text (tvb, str_tbl+idx, str_len-1));\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0xC0: /* EXT_0 */\n\t\tcase 0xC1: /* EXT_1 */\n\t\tcase 0xC2: /* EXT_2 */\n\t\t\t/* Extension tokens */\n\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t     \"| EXT_%1x      (Extension Token)    \"\n\t\t\t\t\t     \"| %s(%s)\",\n\t\t\t\t\t     *level, *codepage_stag, peek & 0x0f, Indent (*level),\n\t\t\t\t\t     map_token (map->global, 0, peek));\n\t\t\toff++;\n\t\t\tbreak;\n\t\tcase 0xC3: /* OPAQUE - WBXML 1.1 and newer */\n\t\t\tif (tvb_get_guint8 (tvb, 0)) { /* WBXML 1.x (x > 0) */\n\t\t\t\tchar *str;\n\t\t\t\tif (tag_save_known) { /* Knwon tag */\n\t\t\t\t\tif (map->opaque_binary_tag) {\n\t\t\t\t\t\tstr = map->opaque_binary_tag(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t     tag_save_known, *codepage_stag, &len);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstr = default_opaque_binary_tag(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\ttag_save_known, *codepage_stag, &len);\n\t\t\t\t\t}\n\t\t\t\t} else { /* lITERAL tag */\n\t\t\t\t\tif (map->opaque_literal_tag) {\n\t\t\t\t\t\tstr = map->opaque_literal_tag(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t      tag_save_literal, *codepage_stag, &len);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstr = default_opaque_literal_tag(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\t tag_save_literal, *codepage_stag, &len);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tproto_tree_add_text (tree, tvb, off, 1 + len,\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t     \"| OPAQUE (Opaque data)            \"\n\t\t\t\t\t\t     \"| %s%s\",\n\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level), str);\n\t\t\t\toff += 1 + len;\n\t\t\t} else { /* WBXML 1.0 - RESERVED_2 token (invalid) */\n\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t     \"| RESERVED_2     (Invalid Token!) \"\n\t\t\t\t\t\t     \"| WBXML 1.0 parsing stops here.\",\n\t\t\t\t\t\t     *level, *codepage_stag);\n\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\toff = tvb_len;\n\t\t\t\tDebugLog((\"STAG: level = %u, Return: len = %u\\n\", *level, off - offset));\n\t\t\t\treturn (off - offset);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\t/* No default clause, as all cases have been treated */\n\t\t} else { /* LITERAL or Known TAG */\n\t\t\t/* We must store the initial tag, and also retrieve the new tag.\n\t\t\t * For efficiency reasons, we store the literal tag representation\n\t\t\t * for known tags too, so we can easily close the tag without the\n\t\t\t * need of a new lookup and avoiding storage of token codepage.\n\t\t\t *\n\t\t\t * There are 4 possibilities:\n\t\t\t *\n\t\t\t *  1. Known tag followed by a known tag\n\t\t\t *  2. Known tag followed by a LITERAL tag\n\t\t\t *  3. LITERAL tag followed by Known tag\n\t\t\t *  4. LITERAL tag followed by LITERAL tag\n\t\t\t */\n\n\t\t\t/* Store the new tag */\n\t\t\ttag_len = 0;\n\t\t\tif ((peek & 0x3F) == 4) { /* LITERAL */\n\t\t\t\tDebugLog((\"STAG: LITERAL tag (peek = 0x%02X, off = %u) - TableRef follows!\\n\", peek, off));\n\t\t\t\tidx = tvb_get_guintvar (tvb, off+1, &tag_len);\n\t\t\t\tstr_len = tvb_strsize (tvb, str_tbl+idx);\n\t\t\t\ttag_new_literal = (const gchar*)tvb_get_ptr (tvb, str_tbl+idx, str_len);\n\t\t\t\ttag_new_known = 0; /* invalidate known tag_new */\n\t\t\t} else { /* Known tag */\n\t\t\t\ttag_new_known = peek & 0x3F;\n\t\t\t\ttag_new_literal = map_token (map->tags, *codepage_stag,\n\t\t\t\t\t\t\t     tag_new_known);\n\t\t\t\t/* Stored looked up tag name string */\n\t\t\t}\n\n\t\t\t/* Parsing of TAG starts HERE */\n\t\t\tif (peek & 0x40) { /* Content present */\n\t\t\t\t/* Content follows\n\t\t\t\t * [!] An explicit END token is expected in these cases!\n\t\t\t\t * ==> Recursion possible if we encounter a tag with content;\n\t\t\t\t *     recursion will return at the explicit END token.\n\t\t\t\t */\n\t\t\t\tif (parsing_tag_content) { /* Recurse */\n\t\t\t\t\tDebugLog((\"STAG: Tag in Tag - RECURSE! (off = %u)\\n\", off));\n\t\t\t\t\t/* Do not process the attribute list:\n\t\t\t\t\t * recursion will take care of it */\n\t\t\t\t\t(*level)++;\n\t\t\t\t\tlen = parse_wbxml_tag_defined (tree, tvb, off, str_tbl,\n\t\t\t\t\t\t\t\t       level, codepage_stag, codepage_attr, map);\n\t\t\t\t\toff += len;\n\t\t\t\t} else { /* Now we will have content to parse */\n\t\t\t\t\t/* Save the start tag so we can properly close it later. */\n\t\t\t\t\tif ((peek & 0x3F) == 4) { /* Literal tag */\n\t\t\t\t\t\ttag_save_literal = tag_new_literal;\n\t\t\t\t\t\ttag_save_known = 0;\n\t\t\t\t\t} else { /* Known tag */\n\t\t\t\t\t\ttag_save_known = tag_new_known;\n\t\t\t\t\t\ttag_save_literal = tag_new_literal;\n\t\t\t\t\t\t/* The last statement avoids needless lookups */\n\t\t\t\t\t}\n\t\t\t\t\t/* Process the attribute list if present */\n\t\t\t\t\tif (peek & 0x80) { /* Content and Attribute list present */\n\t\t\t\t\t\tif (tag_new_known) { /* Known tag */\n\t\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t\t     \"|   Known Tag 0x%02X           (AC) \"\n\t\t\t\t\t\t\t\t\t     \"| %s<%s\",\n\t\t\t\t\t\t\t\t\t     *level, *codepage_stag, tag_new_known,\n\t\t\t\t\t\t\t\t\t     Indent (*level), tag_new_literal);\n\t\t\t\t\t\t\t/* Tag string already looked up earlier! */\n\t\t\t\t\t\t\toff++;\n\t\t\t\t\t\t} else { /* LITERAL tag */\n\t\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t\t     \"| LITERAL_AC (Literal tag)   (AC) \"\n\t\t\t\t\t\t\t\t\t     \"| %s<%s\",\n\t\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level), tag_new_literal);\n\t\t\t\t\t\t\toff += 1 + tag_len;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb,\n\t\t\t\t\t\t\t\t\t\t\t  off, str_tbl, *level, codepage_attr, map);\n\t\t\t\t\t\t/* Check that there is still room in packet */\n\t\t\t\t\t\toff += len;\n\t\t\t\t\t\tif (off >= tvb_len) {\n\t\t\t\t\t\t\tDebugLog((\"STAG: level = %u, ThrowException: len = %u (short frame)\\n\",\n\t\t\t\t\t\t\t\t  *level, off - offset));\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * TODO - Do we need to free g_malloc()ed memory?\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tTHROW(ReportedBoundsError);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off-1, 1,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t     \"| END (attribute list)            \"\n\t\t\t\t\t\t\t\t     \"| %s>\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\t\t\t} else { /* Content, no Attribute list */\n\t\t\t\t\t\tif (tag_new_known) { /* Known tag */\n\t\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t\t     \"|   Known Tag 0x%02X           (.C) \"\n\t\t\t\t\t\t\t\t\t     \"| %s<%s>\",\n\t\t\t\t\t\t\t\t\t     *level, *codepage_stag, tag_new_known,\n\t\t\t\t\t\t\t\t\t     Indent (*level), tag_new_literal);\n\t\t\t\t\t\t\t/* Tag string already looked up earlier! */\n\t\t\t\t\t\t\toff++;\n\t\t\t\t\t\t} else { /* LITERAL tag */\n\t\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t\t     \"| LITERAL_C  (Literal Tag)   (.C) \"\n\t\t\t\t\t\t\t\t\t     \"| %s<%s>\",\n\t\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level),\n\t\t\t\t\t\t\t\t\t     tag_new_literal);\n\t\t\t\t\t\t\toff += 1 + tag_len;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/* The data that follows in the parsing process\n\t\t\t\t\t * represents content for the opening tag\n\t\t\t\t\t * we've just processed in the lines above.\n\t\t\t\t\t * Next time we encounter a tag with content: recurse\n\t\t\t\t\t */\n\t\t\t\t\tparsing_tag_content = TRUE;\n\t\t\t\t\tDebugLog((\"Tag in Tag - No recursion this time! (off = %u)\\n\", off));\n\t\t\t\t}\n\t\t\t} else { /* No Content */\n\t\t\t\tDebugLog((\"<Tag/> in Tag - No recursion! (off = %u)\\n\", off));\n\t\t\t\t(*level)++;\n\t\t\t\tif (peek & 0x80) { /* No Content, Attribute list present */\n\t\t\t\t\tif (tag_new_known) { /* Known tag */\n\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t     \"|   Known Tag 0x%02X           (A.) \"\n\t\t\t\t\t\t\t\t     \"| %s<%s\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, tag_new_known,\n\t\t\t\t\t\t\t\t     Indent (*level), tag_new_literal);\n\t\t\t\t\t\t/* Tag string already looked up earlier! */\n\t\t\t\t\t\toff++;\n\t\t\t\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb,\n\t\t\t\t\t\t\t\t\t\t\t  off, str_tbl, *level, codepage_attr, map);\n\t\t\t\t\t\t/* Check that there is still room in packet */\n\t\t\t\t\t\toff += len;\n\t\t\t\t\t\tif (off > tvb_len) {\n\t\t\t\t\t\t\tDebugLog((\"STAG: level = %u, ThrowException: len = %u (short frame)\\n\", *level, off - offset));\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * TODO - Do we need to free g_malloc()ed memory?\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tTHROW(ReportedBoundsError);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off-1, 1,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t     \"| END (Known Tag)                 \"\n\t\t\t\t\t\t\t\t     \"| %s/>\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\t\t\t} else { /* LITERAL tag */\n\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t     \"| LITERAL_A  (Literal Tag)   (A.) \"\n\t\t\t\t\t\t\t\t     \"| %s<%s\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level), tag_new_literal);\n\t\t\t\t\t\toff += 1 + tag_len;\n\t\t\t\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb,\n\t\t\t\t\t\t\t\t\t\t\t  off, str_tbl, *level, codepage_attr, map);\n\t\t\t\t\t\t/* Check that there is still room in packet */\n\t\t\t\t\t\toff += len;\n\t\t\t\t\t\tif (off >= tvb_len) {\n\t\t\t\t\t\t\tDebugLog((\"STAG: level = %u, ThrowException: len = %u (short frame)\\n\", *level, off - offset));\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * TODO - Do we need to free g_malloc()ed memory?\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tTHROW(ReportedBoundsError);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off-1, 1,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t     \"| END (Literal Tag)               \"\n\t\t\t\t\t\t\t\t     \"| %s/>\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\t\t\t}\n\t\t\t\t} else { /* No Content, No Attribute list */\n\t\t\t\t\tif (tag_new_known) { /* Known tag */\n\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t     \"|   Known Tag 0x%02x           (..) \"\n\t\t\t\t\t\t\t\t     \"| %s<%s />\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, tag_new_known,\n\t\t\t\t\t\t\t\t     Indent (*level), tag_new_literal);\n\t\t\t\t\t\t/* Tag string already looked up earlier! */\n\t\t\t\t\t\toff++;\n\t\t\t\t\t} else { /* LITERAL tag */\n\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t     \"| LITERAL    (Literal Tag)   (..) \"\n\t\t\t\t\t\t\t\t     \"| %s<%s />\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level),\n\t\t\t\t\t\t\t\t     tag_new_literal);\n\t\t\t\t\t\toff += 1 + tag_len;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t(*level)--;\n \t\t\t\t/* TODO: Do I have to reset code page here? */\n \t\t\t}\n \t\t} /* if (tag & 0x3F) >= 5 */\n \t} /* while */\n \tDebugLog((\"STAG: level = %u, Return: len = %u (end of function body)\\n\", *level, off - offset));\n \treturn (off - offset);\n}\n", "target": 1, "idx": 180314}
{"func": "bool AuthenticatorSelectAccountSheetModel::IsAcceptButtonEnabled() const {\n  return false;\n}\n", "target": 0, "idx": 155638}
{"func": "videobuf_vm_open(struct vm_area_struct *vma)\n {\n \tstruct videobuf_mapping *map = vma->vm_private_data;\n \n\tdprintk(2,\"vm_open %p [count=%d,vma=%08lx-%08lx]\\n\",map,\n \t\tmap->count,vma->vm_start,vma->vm_end);\n \n \tmap->count++;\n}\n", "target": 1, "idx": 182091}
{"func": " jpc_streamlist_t *jpc_ppmstabtostreams(jpc_ppxstab_t *tab)\n {\n \tjpc_streamlist_t *streams;\n\tuchar *dataptr;\n \tuint_fast32_t datacnt;\n \tuint_fast32_t tpcnt;\n \tjpc_ppxstabent_t *ent;\n\tint entno;\n\tjas_stream_t *stream;\n\tint n;\n\n\tif (!(streams = jpc_streamlist_create())) {\n\t\tgoto error;\n\t}\n\n\tif (!tab->numents) {\n\t\treturn streams;\n\t}\n\n\tentno = 0;\n\tent = tab->ents[entno];\n\tdataptr = ent->data;\n\tdatacnt = ent->len;\n\tfor (;;) {\n\n\t\t/* Get the length of the packet header data for the current\n\t\t  tile-part. */\n\t\tif (datacnt < 4) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (!(stream = jas_stream_memopen(0, 0))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (jpc_streamlist_insert(streams, jpc_streamlist_numstreams(streams),\n\t\t  stream)) {\n\t\t\tgoto error;\n\t\t}\n\t\ttpcnt = (dataptr[0] << 24) | (dataptr[1] << 16) | (dataptr[2] << 8)\n\t\t  | dataptr[3];\n\t\tdatacnt -= 4;\n\t\tdataptr += 4;\n\n\t\t/* Get the packet header data for the current tile-part. */\n\t\twhile (tpcnt) {\n\t\t\tif (!datacnt) {\n\t\t\t\tif (++entno >= tab->numents) {\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tent = tab->ents[entno];\n\t\t\t\tdataptr = ent->data;\n\t\t\t\tdatacnt = ent->len;\n\t\t\t}\n\t\t\tn = JAS_MIN(tpcnt, datacnt);\n\t\t\tif (jas_stream_write(stream, dataptr, n) != n) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\ttpcnt -= n;\n\t\t\tdataptr += n;\n\t\t\tdatacnt -= n;\n\t\t}\n\t\tjas_stream_rewind(stream);\n\t\tif (!datacnt) {\n\t\t\tif (++entno >= tab->numents) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tent = tab->ents[entno];\n\t\t\tdataptr = ent->data;\n\t\t\tdatacnt = ent->len;\n\t\t}\n\t}\n\n\treturn streams;\n\nerror:\n\tif (streams) {\n\t\tjpc_streamlist_destroy(streams);\n\t}\n\treturn 0;\n}\n", "target": 1, "idx": 181891}
{"func": " void ChromeInvalidationClient::Start(\n     const std::string& client_id, const std::string& client_info,\n     const std::string& state,\n     const InvalidationVersionMap& initial_max_invalidation_versions,\n    const WeakHandle<InvalidationStateTracker>& invalidation_state_tracker,\n    Listener* listener) {\n  DCHECK(CalledOnValidThread());\n  Stop();\n\n  chrome_system_resources_.set_platform(client_info);\n  chrome_system_resources_.Start();\n\n  chrome_system_resources_.storage()->SetInitialState(state);\n\n  max_invalidation_versions_ = initial_max_invalidation_versions;\n  if (max_invalidation_versions_.empty()) {\n    DVLOG(2) << \"No initial max invalidation versions for any id\";\n  } else {\n    for (InvalidationVersionMap::const_iterator it =\n             max_invalidation_versions_.begin();\n         it != max_invalidation_versions_.end(); ++it) {\n      DVLOG(2) << \"Initial max invalidation version for \"\n               << ObjectIdToString(it->first) << \" is \"\n               << it->second;\n    }\n  }\n  invalidation_state_tracker_ = invalidation_state_tracker;\n  DCHECK(invalidation_state_tracker_.IsInitialized());\n\n  DCHECK(!listener_);\n  DCHECK(listener);\n  listener_ = listener;\n \n   int client_type = ipc::invalidation::ClientType::CHROME_SYNC;\n   invalidation_client_.reset(\n      invalidation::CreateInvalidationClient(\n           &chrome_system_resources_, client_type, client_id,\n           kApplicationName, this));\n   invalidation_client_->Start();\n\n  registration_manager_.reset(\n      new RegistrationManager(invalidation_client_.get()));\n}\n", "target": 1, "idx": 184518}
{"func": "WORD32 ixheaacd_qmf_hbe_data_reinit(ia_esbr_hbe_txposer_struct *ptr_hbe_txposer,\n                                    WORD16 *p_freq_band_tab[2],\n                                    WORD16 *p_num_sfb, WORD32 upsamp_4_flag) {\n  WORD32 synth_size, sfb, patch, stop_patch;\n\n if (ptr_hbe_txposer != NULL) {\n    ptr_hbe_txposer->start_band = p_freq_band_tab[LOW][0];\n    ptr_hbe_txposer->end_band = p_freq_band_tab[LOW][p_num_sfb[LOW]];\n\n    ptr_hbe_txposer->synth_size =\n 4 * ((ptr_hbe_txposer->start_band + 4) / 8 + 1);\n    ptr_hbe_txposer->k_start =\n        ixheaacd_start_subband2kL_tbl[ptr_hbe_txposer->start_band];\n\n    ptr_hbe_txposer->upsamp_4_flag = upsamp_4_flag;\n\n if (upsamp_4_flag) {\n if (ptr_hbe_txposer->k_start + ptr_hbe_txposer->synth_size > 16)\n        ptr_hbe_txposer->k_start = 16 - ptr_hbe_txposer->synth_size;\n } else if (ptr_hbe_txposer->core_frame_length == 768) {\n if (ptr_hbe_txposer->k_start + ptr_hbe_txposer->synth_size > 24)\n        ptr_hbe_txposer->k_start = 24 - ptr_hbe_txposer->synth_size;\n }\n\n    memset(ptr_hbe_txposer->synth_buf, 0, 1280 * sizeof(FLOAT32));\n    synth_size = ptr_hbe_txposer->synth_size;\n    ptr_hbe_txposer->synth_buf_offset = 18 * synth_size;\n switch (synth_size) {\n case 4:\n        ptr_hbe_txposer->synth_cos_tab =\n\n             (FLOAT32 *)ixheaacd_synth_cos_table_kl_4;\n         ptr_hbe_txposer->analy_cos_sin_tab =\n             (FLOAT32 *)ixheaacd_analy_cos_sin_table_kl_8;\n        ixheaacd_real_synth_fft = &ixheaacd_real_synth_fft_p2;\n        ixheaacd_cmplx_anal_fft = &ixheaacd_cmplx_anal_fft_p2;\n         break;\n       case 8:\n         ptr_hbe_txposer->synth_cos_tab =\n             (FLOAT32 *)ixheaacd_synth_cos_table_kl_8;\n         ptr_hbe_txposer->analy_cos_sin_tab =\n             (FLOAT32 *)ixheaacd_analy_cos_sin_table_kl_16;\n        ixheaacd_real_synth_fft = &ixheaacd_real_synth_fft_p2;\n        ixheaacd_cmplx_anal_fft = &ixheaacd_cmplx_anal_fft_p2;\n         break;\n       case 12:\n         ptr_hbe_txposer->synth_cos_tab =\n             (FLOAT32 *)ixheaacd_synth_cos_table_kl_12;\n         ptr_hbe_txposer->analy_cos_sin_tab =\n             (FLOAT32 *)ixheaacd_analy_cos_sin_table_kl_24;\n        ixheaacd_real_synth_fft = &ixheaacd_real_synth_fft_p3;\n        ixheaacd_cmplx_anal_fft = &ixheaacd_cmplx_anal_fft_p3;\n         break;\n       case 16:\n         ptr_hbe_txposer->synth_cos_tab =\n             (FLOAT32 *)ixheaacd_synth_cos_table_kl_16;\n         ptr_hbe_txposer->analy_cos_sin_tab =\n             (FLOAT32 *)ixheaacd_analy_cos_sin_table_kl_32;\n        ixheaacd_real_synth_fft = &ixheaacd_real_synth_fft_p2;\n        ixheaacd_cmplx_anal_fft = &ixheaacd_cmplx_anal_fft_p2;\n         break;\n       case 20:\n         ptr_hbe_txposer->synth_cos_tab =\n (FLOAT32 *)ixheaacd_synth_cos_table_kl_20;\n        ptr_hbe_txposer->analy_cos_sin_tab =\n (FLOAT32 *)ixheaacd_analy_cos_sin_table_kl_40;\n break;\n default:\n        ptr_hbe_txposer->synth_cos_tab =\n\n             (FLOAT32 *)ixheaacd_synth_cos_table_kl_4;\n         ptr_hbe_txposer->analy_cos_sin_tab =\n             (FLOAT32 *)ixheaacd_analy_cos_sin_table_kl_8;\n        ixheaacd_real_synth_fft = &ixheaacd_real_synth_fft_p2;\n        ixheaacd_cmplx_anal_fft = &ixheaacd_cmplx_anal_fft_p2;\n     }\n \n     ptr_hbe_txposer->synth_wind_coeff = ixheaacd_map_prot_filter(synth_size);\n\n    memset(ptr_hbe_txposer->analy_buf, 0, 640 * sizeof(FLOAT32));\n    synth_size = 2 * ptr_hbe_txposer->synth_size;\n    ptr_hbe_txposer->analy_wind_coeff = ixheaacd_map_prot_filter(synth_size);\n\n    memset(ptr_hbe_txposer->x_over_qmf, 0, MAX_NUM_PATCHES * sizeof(WORD32));\n    sfb = 0;\n if (upsamp_4_flag) {\n      stop_patch = MAX_NUM_PATCHES;\n      ptr_hbe_txposer->max_stretch = MAX_STRETCH;\n } else {\n      stop_patch = MAX_STRETCH;\n }\n\n for (patch = 1; patch <= stop_patch; patch++) {\n while (sfb <= p_num_sfb[LOW] &&\n             p_freq_band_tab[LOW][sfb] <= patch * ptr_hbe_txposer->start_band)\n        sfb++;\n if (sfb <= p_num_sfb[LOW]) {\n if ((patch * ptr_hbe_txposer->start_band -\n             p_freq_band_tab[LOW][sfb - 1]) <= 3) {\n          ptr_hbe_txposer->x_over_qmf[patch - 1] =\n              p_freq_band_tab[LOW][sfb - 1];\n } else {\n          WORD32 sfb = 0;\n while (sfb <= p_num_sfb[HIGH] &&\n                 p_freq_band_tab[HIGH][sfb] <=\n                     patch * ptr_hbe_txposer->start_band)\n            sfb++;\n          ptr_hbe_txposer->x_over_qmf[patch - 1] =\n              p_freq_band_tab[HIGH][sfb - 1];\n }\n } else {\n        ptr_hbe_txposer->x_over_qmf[patch - 1] = ptr_hbe_txposer->end_band;\n        ptr_hbe_txposer->max_stretch = min(patch, MAX_STRETCH);\n\n         break;\n       }\n     }\n  }\n  if (ptr_hbe_txposer->k_start < 0) {\n    return -1;\n   }\n   return 0;\n }\n", "target": 1, "idx": 188114}
{"func": "zset_outputintent(i_ctx_t * i_ctx_p)\n{\n    os_ptr                  op = osp;\n    int                     code = 0;\n    gx_device *dev = gs_currentdevice(igs);\n    cmm_dev_profile_t       *dev_profile;\n    stream *                s = 0L;\n    ref *                   pnval;\n    ref *                   pstrmval;\n    int                     ncomps, dev_comps;\n    cmm_profile_t           *picc_profile;\n    int                     expected = 0;\n    gs_color_space_index    index;\n    gsicc_manager_t         *icc_manager = igs->icc_manager;\n    cmm_profile_t           *source_profile = NULL;\n\n    check_type(*op, t_dictionary);\n    check_dict_read(*op);\n    if_debug0m(gs_debug_flag_icc, imemory, \"[icc] Using OutputIntent\\n\");\n\n    /* Get the device structure */\n    code = dev_proc(dev, get_profile)(dev,  &dev_profile);\n    if (code < 0)\n        return code;\n\n    if (dev_profile == NULL) {\n        code = gsicc_init_device_profile_struct(dev, NULL, 0);\n        if (code < 0)\n            return code;\n        code = dev_proc(dev, get_profile)(dev,  &dev_profile);\n        if (code < 0)\n            return code;\n    }\n    if (dev_profile->oi_profile != NULL) {\n        return 0;  /* Allow only one setting of this object */\n    }\n    code = dict_find_string(op, \"N\", &pnval);\n    if (code < 0)\n         return code;\n     if (code == 0)\n         return_error(gs_error_undefined);\n     ncomps = pnval->value.intval;\n \n     /* verify the DataSource entry. Creat profile from stream */\n    check_read_file(i_ctx_p, s, pstrmval);\n\n    picc_profile = gsicc_profile_new(s, gs_gstate_memory(igs), NULL, 0);\n    if (picc_profile == NULL)\n        return gs_throw(gs_error_VMerror, \"Creation of ICC profile failed\");\n    picc_profile->num_comps = ncomps;\n    picc_profile->profile_handle =\n        gsicc_get_profile_handle_buffer(picc_profile->buffer,\n                                        picc_profile->buffer_size,\n                                        gs_gstate_memory(igs));\n    if (picc_profile->profile_handle == NULL) {\n        rc_decrement(picc_profile,\"zset_outputintent\");\n        return -1;\n    }\n    picc_profile->data_cs =\n        gscms_get_profile_data_space(picc_profile->profile_handle,\n            picc_profile->memory);\n    switch (picc_profile->data_cs) {\n        case gsCIEXYZ:\n        case gsCIELAB:\n        case gsRGB:\n            expected = 3;\n            source_profile = icc_manager->default_rgb;\n            break;\n        case gsGRAY:\n            expected = 1;\n            source_profile = icc_manager->default_gray;\n            break;\n        case gsCMYK:\n            expected = 4;\n            source_profile = icc_manager->default_cmyk;\n            break;\n        case gsNCHANNEL:\n            expected = 0;\n            break;\n        case gsNAMED:\n        case gsUNDEFINED:\n            break;\n    }\n    if (expected && ncomps != expected) {\n        rc_decrement(picc_profile,\"zset_outputintent\");\n        return_error(gs_error_rangecheck);\n    }\n    gsicc_init_hash_cs(picc_profile, igs);\n\n    /* All is well with the profile.  Lets set the stuff that needs to be set */\n    dev_profile->oi_profile = picc_profile;\n    picc_profile->name = (char *) gs_alloc_bytes(picc_profile->memory,\n                                                 MAX_DEFAULT_ICC_LENGTH,\n                                                 \"zset_outputintent\");\n    strncpy(picc_profile->name, OI_PROFILE, strlen(OI_PROFILE));\n    picc_profile->name[strlen(OI_PROFILE)] = 0;\n    picc_profile->name_length = strlen(OI_PROFILE);\n    /* Set the range of the profile */\n    gsicc_set_icc_range(&picc_profile);\n\n    /* If the output device has a different number of componenets, then we are\n       going to set the output intent as the proofing profile, unless the\n       proofing profile has already been set.\n\n       If the device has the same number of components (and color model) then as\n       the profile we will use this as the output profile, unless someone has\n       explicitly set the output profile.\n\n       Finally, we will use the output intent profile for the default profile\n       of the proper Device profile in the icc manager, again, unless someone\n       has explicitly set this default profile. */\n\n    dev_comps = dev_profile->device_profile[0]->num_comps;\n    index = gsicc_get_default_type(dev_profile->device_profile[0]);\n    if (ncomps == dev_comps && index < gs_color_space_index_DevicePixel) {\n        /* The OI profile is the same type as the profile for the device and a\n           \"default\" profile for the device was not externally set. So we go\n           ahead and use the OI profile as the device profile.  Care needs to be\n           taken here to keep from screwing up any device parameters.   We will\n           use a keyword of OIProfile for the user/device parameter to indicate\n           its usage.  Also, note conflicts if one is setting object dependent\n           color management */\n        rc_assign(dev_profile->device_profile[0], picc_profile,\n                  \"zset_outputintent\");\n        if_debug0m(gs_debug_flag_icc, imemory, \"[icc] OutputIntent used for device profile\\n\");\n    } else {\n        if (dev_profile->proof_profile == NULL) {\n            /* This means that we should use the OI profile as the proofing\n               profile.  Note that if someone already has specified a\n               proofing profile it is unclear what they are trying to do\n               with the output intent.  In this case, we will use it\n               just for the source data below */\n            dev_profile->proof_profile = picc_profile;\n            rc_increment(picc_profile);\n            if_debug0m(gs_debug_flag_icc, imemory, \"[icc] OutputIntent used for proof profile\\n\");\n        }\n    }\n    /* Now the source colors.  See which source color space needs to use the\n       output intent ICC profile */\n    index = gsicc_get_default_type(source_profile);\n    if (index < gs_color_space_index_DevicePixel) {\n        /* source_profile is currently the default.  Set it to the OI profile */\n        switch (picc_profile->data_cs) {\n            case gsGRAY:\n                if_debug0m(gs_debug_flag_icc, imemory, \"[icc] OutputIntent used source Gray\\n\");\n                rc_assign(icc_manager->default_gray, picc_profile,\n                          \"zset_outputintent\");\n                break;\n            case gsRGB:\n                if_debug0m(gs_debug_flag_icc, imemory, \"[icc] OutputIntent used source RGB\\n\");\n                rc_assign(icc_manager->default_rgb, picc_profile,\n                          \"zset_outputintent\");\n                break;\n            case gsCMYK:\n                if_debug0m(gs_debug_flag_icc, imemory, \"[icc] OutputIntent used source CMYK\\n\");\n                rc_assign(icc_manager->default_cmyk, picc_profile,\n                          \"zset_outputintent\");\n                break;\n            default:\n                break;\n        }\n    }\n    /* Remove the output intent dict from the stack */\n    pop(1);\n    return code;\n}\n", "target": 1, "idx": 177808}
{"func": "static MagickBooleanType WriteINLINEImage(const ImageInfo *image_info,\n  Image *image)\n{\n  char\n    *base64,\n    message[MaxTextExtent];\n\n  const MagickInfo\n    *magick_info;\n\n  ExceptionInfo\n    *exception;\n\n  Image\n    *write_image;\n\n  ImageInfo\n    *write_info;\n\n  MagickBooleanType\n    status;\n\n  size_t\n    blob_length,\n    encode_length;\n\n  unsigned char\n    *blob;\n\n  /*\n    Convert image to base64-encoding.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  exception=(&image->exception);\n  write_info=CloneImageInfo(image_info);\n  (void) SetImageInfo(write_info,1,exception);\n  if (LocaleCompare(write_info->magick,\"INLINE\") == 0)\n    (void) CopyMagickString(write_info->magick,image->magick,MaxTextExtent);\n   magick_info=GetMagickInfo(write_info->magick,exception);\n   if ((magick_info == (const MagickInfo *) NULL) ||\n       (GetMagickMimeType(magick_info) == (const char *) NULL))\n    ThrowWriterException(CorruptImageError,\"ImageTypeNotSupported\");\n   (void) CopyMagickString(image->filename,write_info->filename,MaxTextExtent);\n   blob_length=2048;\n   write_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (write_image == (Image *) NULL)\n    {\n      write_info=DestroyImageInfo(write_info);\n      return(MagickTrue);\n    }\n  blob=(unsigned char *) ImageToBlob(write_info,write_image,&blob_length,\n    exception);\n  write_image=DestroyImage(write_image);\n  write_info=DestroyImageInfo(write_info);\n  if (blob == (unsigned char *) NULL)\n    return(MagickFalse);\n  encode_length=0;\n  base64=Base64Encode(blob,blob_length,&encode_length);\n  blob=(unsigned char *) RelinquishMagickMemory(blob);\n  if (base64 == (char *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  /*\n    Write base64-encoded image.\n  */\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      base64=DestroyString(base64);\n      return(status);\n    }\n  (void) FormatLocaleString(message,MaxTextExtent,\"data:%s;base64,\",\n    GetMagickMimeType(magick_info));\n  (void) WriteBlobString(image,message);\n  (void) WriteBlobString(image,base64);\n  base64=DestroyString(base64);\n  return(MagickTrue);\n}\n", "target": 1, "idx": 181143}
{"func": "void ConvertDeviceFilter(const usb::DeviceFilter& input,\n                         UsbDeviceFilter* output) {\n  if (input.vendor_id) {\n    output->SetVendorId(*input.vendor_id);\n  }\n  if (input.product_id) {\n    output->SetProductId(*input.product_id);\n  }\n  if (input.interface_class) {\n    output->SetInterfaceClass(*input.interface_class);\n  }\n  if (input.interface_subclass) {\n    output->SetInterfaceSubclass(*input.interface_subclass);\n  }\n  if (input.interface_protocol) {\n    output->SetInterfaceProtocol(*input.interface_protocol);\n  }\n}\n", "target": 0, "idx": 132445}
{"func": "NaClProcessHost::~NaClProcessHost() {\n#ifndef DISABLE_NACL\n  for (size_t i = 0; i < internal_->sockets_for_renderer.size(); i++) {\n    if (nacl::Close(internal_->sockets_for_renderer[i]) != 0) {\n      LOG(ERROR) << \"nacl::Close() failed\";\n    }\n  }\n  for (size_t i = 0; i < internal_->sockets_for_sel_ldr.size(); i++) {\n    if (nacl::Close(internal_->sockets_for_sel_ldr[i]) != 0) {\n      LOG(ERROR) << \"nacl::Close() failed\";\n    }\n  }\n#endif\n\n  if (reply_msg_) {\n    reply_msg_->set_reply_error();\n    chrome_render_message_filter_->Send(reply_msg_);\n  }\n}\n", "target": 0, "idx": 102582}
{"func": "static void inotify_free_group_priv(struct fsnotify_group *group)\n{\n\t/* ideally the idr is empty and we won't hit the BUG in teh callback */\n \tidr_for_each(&group->inotify_data.idr, idr_callback, group);\n \tidr_remove_all(&group->inotify_data.idr);\n \tidr_destroy(&group->inotify_data.idr);\n \tfree_uid(group->inotify_data.user);\n }\n", "target": 1, "idx": 179058}
{"func": "bool Document::DispatchBeforeUnloadEvent(ChromeClient& chrome_client,\n                                         bool is_reload,\n                                         bool& did_allow_navigation) {\n  if (!dom_window_)\n    return true;\n\n  if (!body())\n    return true;\n\n  if (ProcessingBeforeUnload())\n    return false;\n\n  BeforeUnloadEvent* before_unload_event = BeforeUnloadEvent::Create();\n  before_unload_event->initEvent(EventTypeNames::beforeunload, false, true);\n  load_event_progress_ = kBeforeUnloadEventInProgress;\n  const TimeTicks beforeunload_event_start = CurrentTimeTicks();\n  dom_window_->DispatchEvent(before_unload_event, this);\n  const TimeTicks beforeunload_event_end = CurrentTimeTicks();\n  load_event_progress_ = kBeforeUnloadEventCompleted;\n  DEFINE_STATIC_LOCAL(\n      CustomCountHistogram, beforeunload_histogram,\n      (\"DocumentEventTiming.BeforeUnloadDuration\", 0, 10000000, 50));\n  beforeunload_histogram.Count(\n      (beforeunload_event_end - beforeunload_event_start).InMicroseconds());\n  if (!before_unload_event->defaultPrevented())\n    DefaultEventHandler(before_unload_event);\n\n  enum BeforeUnloadDialogHistogramEnum {\n    kNoDialogNoText,\n    kNoDialogNoUserGesture,\n    kNoDialogMultipleConfirmationForNavigation,\n    kShowDialog,\n    kDialogEnumMax\n  };\n  DEFINE_STATIC_LOCAL(EnumerationHistogram, beforeunload_dialog_histogram,\n                      (\"Document.BeforeUnloadDialog\", kDialogEnumMax));\n  if (before_unload_event->returnValue().IsNull()) {\n    beforeunload_dialog_histogram.Count(kNoDialogNoText);\n  }\n  if (!GetFrame() || before_unload_event->returnValue().IsNull())\n    return true;\n\n  if (!GetFrame()->HasBeenActivated()) {\n    beforeunload_dialog_histogram.Count(kNoDialogNoUserGesture);\n    AddConsoleMessage(ConsoleMessage::Create(\n        kInterventionMessageSource, kErrorMessageLevel,\n        \"Blocked attempt to show a 'beforeunload' confirmation panel for a \"\n        \"frame that never had a user gesture since its load. \"\n        \"https://www.chromestatus.com/feature/5082396709879808\"));\n    return true;\n  }\n\n  if (did_allow_navigation) {\n    beforeunload_dialog_histogram.Count(\n        kNoDialogMultipleConfirmationForNavigation);\n    AddConsoleMessage(ConsoleMessage::Create(\n        kInterventionMessageSource, kErrorMessageLevel,\n        \"Blocked attempt to show multiple 'beforeunload' confirmation panels \"\n        \"for a single navigation.\"));\n    return true;\n  }\n  String text = before_unload_event->returnValue();\n  beforeunload_dialog_histogram.Count(\n      BeforeUnloadDialogHistogramEnum::kShowDialog);\n  if (chrome_client.OpenBeforeUnloadConfirmPanel(text, frame_, is_reload)) {\n    did_allow_navigation = true;\n    return true;\n  }\n\n  return false;\n}\n", "target": 0, "idx": 167876}
{"func": "OscillatorNode* AudioContext::createOscillator()\n{\n    ASSERT(isMainThread());\n\n    OscillatorNode* node = OscillatorNode::create(this, m_destinationNode->sampleRate());\n\n\n    return node;\n}\n", "target": 0, "idx": 139641}
{"func": " int flush_completed_IO(struct inode *inode)\n {\n \text4_io_end_t *io;\n \tint ret = 0;\n \tint ret2 = 0;\n \n\tif (list_empty(&EXT4_I(inode)->i_completed_io_list))\n \t\treturn ret;\n \n \tdump_completed_IO(inode);\n\twhile (!list_empty(&EXT4_I(inode)->i_completed_io_list)){\n\t\tio = list_entry(EXT4_I(inode)->i_completed_io_list.next,\n \t\t\t\text4_io_end_t, list);\n \t\t/*\n \t\t * Calling ext4_end_io_nolock() to convert completed\n\t\t * IO to written.\n\t\t *\n\t\t * When ext4_sync_file() is called, run_queue() may already\n\t\t * about to flush the work corresponding to this io structure.\n\t\t * It will be upset if it founds the io structure related\n\t\t * to the work-to-be schedule is freed.\n\t\t *\n\t\t * Thus we need to keep the io structure still valid here after\n\t\t * convertion finished. The io structure has a flag to\n \t\t * avoid double converting from both fsync and background work\n \t\t * queue work.\n \t\t */\n \t\tret = ext4_end_io_nolock(io);\n \t\tif (ret < 0)\n \t\t\tret2 = ret;\n \t\telse\n \t\t\tlist_del_init(&io->list);\n \t}\n \treturn (ret2 < 0) ? ret2 : 0;\n }\n", "target": 1, "idx": 180722}
{"func": "void DefaultAudioDestinationHandler::StopPlatformDestination() {\n  if (platform_destination_->IsPlaying()) {\n    platform_destination_->Stop();\n  }\n}\n", "target": 0, "idx": 143075}
{"func": "void MetricsWebContentsObserver::WebContentsWillSoonBeDestroyed() {\n  web_contents_will_soon_be_destroyed_ = true;\n}\n", "target": 0, "idx": 152856}
{"func": "base::WaitableEvent* ProxyChannelDelegate::GetShutdownEvent() {\n  return &shutdown_event_;\n}\n", "target": 1, "idx": 184308}
{"func": " explicit BpCrypto(const sp<IBinder> &impl)\n : BpInterface<ICrypto>(impl) {\n }\n", "target": 0, "idx": 176095}
{"func": "static int ovl_set_opaque(struct dentry *upperdentry)\n{\n\treturn ovl_do_setxattr(upperdentry, OVL_XATTR_OPAQUE, \"y\", 1, 0);\n}\n", "target": 0, "idx": 51070}
{"func": "data_sock_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tint\t\t\terr = 0, id;\n\tstruct sock\t\t*sk = sock->sk;\n\tstruct mISDNdevice\t*dev;\n\tstruct mISDNversion\tver;\n\n\tswitch (cmd) {\n\tcase IMGETVERSION:\n\t\tver.major = MISDN_MAJOR_VERSION;\n\t\tver.minor = MISDN_MINOR_VERSION;\n\t\tver.release = MISDN_RELEASE;\n\t\tif (copy_to_user((void __user *)arg, &ver, sizeof(ver)))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tcase IMGETCOUNT:\n\t\tid = get_mdevice_count();\n\t\tif (put_user(id, (int __user *)arg))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tcase IMGETDEVINFO:\n\t\tif (get_user(id, (int __user *)arg)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tdev = get_mdevice(id);\n\t\tif (dev) {\n\t\t\tstruct mISDN_devinfo di;\n\n\t\t\tmemset(&di, 0, sizeof(di));\n\t\t\tdi.id = dev->id;\n\t\t\tdi.Dprotocols = dev->Dprotocols;\n\t\t\tdi.Bprotocols = dev->Bprotocols | get_all_Bprotocols();\n\t\t\tdi.protocol = dev->D.protocol;\n\t\t\tmemcpy(di.channelmap, dev->channelmap,\n\t\t\t       sizeof(di.channelmap));\n\t\t\tdi.nrbchan = dev->nrbchan;\n\t\t\tstrcpy(di.name, dev_name(&dev->dev));\n\t\t\tif (copy_to_user((void __user *)arg, &di, sizeof(di)))\n\t\t\t\terr = -EFAULT;\n\t\t} else\n\t\t\terr = -ENODEV;\n\t\tbreak;\n\tdefault:\n\t\tif (sk->sk_state == MISDN_BOUND)\n\t\t\terr = data_sock_ioctl_bound(sk, cmd,\n\t\t\t\t\t\t    (void __user *)arg);\n\t\telse\n\t\t\terr = -ENOTCONN;\n\t}\n\treturn err;\n}\n", "target": 0, "idx": 40253}
{"func": "seamless_process_line(const char *line, void *data)\n{\n\tUNUSED(data);\n\tchar *p, *l;\n\tchar *tok1, *tok3, *tok4, *tok5, *tok6, *tok7, *tok8;\n\tunsigned long id, flags;\n\tchar *endptr;\n\n\tl = xstrdup(line);\n\tp = l;\n\n\tlogger(Core, Debug, \"seamless_process_line(), got '%s'\", p);\n\n\ttok1 = seamless_get_token(&p);\n\t(void) seamless_get_token(&p);\n\ttok3 = seamless_get_token(&p);\n\ttok4 = seamless_get_token(&p);\n\ttok5 = seamless_get_token(&p);\n\ttok6 = seamless_get_token(&p);\n\ttok7 = seamless_get_token(&p);\n\ttok8 = seamless_get_token(&p);\n\n\tif (!strcmp(\"CREATE\", tok1))\n\t{\n\t\tunsigned long group, parent;\n\t\tif (!tok6)\n\t\t\treturn False;\n\n\t\tid = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tgroup = strtoul(tok4, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tparent = strtoul(tok5, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok6, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_create_window(id, group, parent, flags);\n\t}\n\telse if (!strcmp(\"DESTROY\", tok1))\n\t{\n\t\tif (!tok4)\n\t\t\treturn False;\n\n\t\tid = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok4, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_destroy_window(id, flags);\n\n\t}\n\telse if (!strcmp(\"DESTROYGRP\", tok1))\n\t{\n\t\tif (!tok4)\n\t\t\treturn False;\n\n\t\tid = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok4, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_destroy_group(id, flags);\n\t}\n\telse if (!strcmp(\"SETICON\", tok1))\n\t{\n\t\tint chunk, width, height, len;\n\t\tchar byte[3];\n\n\t\tif (!tok8)\n\t\t\treturn False;\n\n\t\tid = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tchunk = strtoul(tok4, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\twidth = strtoul(tok6, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\theight = strtoul(tok7, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tbyte[2] = '\\0';\n\t\tlen = 0;\n\t\twhile (*tok8 != '\\0')\n\t\t{\n\t\t\tbyte[0] = *tok8;\n\t\t\ttok8++;\n\t\t\tif (*tok8 == '\\0')\n\t\t\t\treturn False;\n\t\t\tbyte[1] = *tok8;\n\t\t\ttok8++;\n \n \t\t\ticon_buf[len] = strtol(byte, NULL, 16);\n \t\t\tlen++;\n \t\t}\n \n \t\tui_seamless_seticon(id, tok5, width, height, chunk, icon_buf, len);\n\t}\n\telse if (!strcmp(\"DELICON\", tok1))\n\t{\n\t\tint width, height;\n\n\t\tif (!tok6)\n\t\t\treturn False;\n\n\t\tid = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\twidth = strtoul(tok5, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\theight = strtoul(tok6, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_delicon(id, tok4, width, height);\n\t}\n\telse if (!strcmp(\"POSITION\", tok1))\n\t{\n\t\tint x, y, width, height;\n\n\t\tif (!tok8)\n\t\t\treturn False;\n\n\t\tid = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tx = strtol(tok4, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\t\ty = strtol(tok5, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\twidth = strtol(tok6, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\t\theight = strtol(tok7, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok8, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_move_window(id, x, y, width, height, flags);\n\t}\n\telse if (!strcmp(\"ZCHANGE\", tok1))\n\t{\n\t\tunsigned long behind;\n\n\t\tid = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tbehind = strtoul(tok4, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok5, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_restack_window(id, behind, flags);\n\t}\n\telse if (!strcmp(\"TITLE\", tok1))\n\t{\n\t\tif (!tok5)\n\t\t\treturn False;\n\n\t\tid = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok5, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_settitle(id, tok4, flags);\n\t}\n\telse if (!strcmp(\"STATE\", tok1))\n\t{\n\t\tunsigned int state;\n\n\t\tif (!tok5)\n\t\t\treturn False;\n\n\t\tid = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tstate = strtoul(tok4, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok5, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_setstate(id, state, flags);\n\t}\n\telse if (!strcmp(\"DEBUG\", tok1))\n\t{\n\t\tlogger(Core, Debug, \"seamless_process_line(), %s\", line);\n\t}\n\telse if (!strcmp(\"SYNCBEGIN\", tok1))\n\t{\n\t\tif (!tok3)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_syncbegin(flags);\n\t}\n\telse if (!strcmp(\"SYNCEND\", tok1))\n\t{\n\t\tif (!tok3)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\t/* do nothing, currently */\n\t}\n\telse if (!strcmp(\"HELLO\", tok1))\n\t{\n\t\tif (!tok3)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_begin(! !(flags & SEAMLESSRDP_HELLO_HIDDEN));\n\t}\n\telse if (!strcmp(\"ACK\", tok1))\n\t{\n\t\tunsigned int serial;\n\n\t\tserial = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_ack(serial);\n\t}\n\telse if (!strcmp(\"HIDE\", tok1))\n\t{\n\t\tif (!tok3)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_hide_desktop();\n\t}\n\telse if (!strcmp(\"UNHIDE\", tok1))\n\t{\n\t\tif (!tok3)\n\t\t\treturn False;\n\n\t\tflags = strtoul(tok3, &endptr, 0);\n\t\tif (*endptr)\n\t\t\treturn False;\n\n\t\tui_seamless_unhide_desktop();\n\t}\n\n\n\txfree(l);\n\treturn True;\n}\n", "target": 1, "idx": 182981}
{"func": "TIFFFlushData1(TIFF* tif)\n{\n\tif (tif->tif_rawcc > 0 && tif->tif_flags & TIFF_BUF4WRITE ) {\n\t\tif (!isFillOrder(tif, tif->tif_dir.td_fillorder) &&\n\t\t    (tif->tif_flags & TIFF_NOBITREV) == 0)\n\t\t\tTIFFReverseBits((uint8*)tif->tif_rawdata,\n\t\t\t    tif->tif_rawcc);\n \t\tif (!TIFFAppendToStrip(tif,\n \t\t    isTiled(tif) ? tif->tif_curtile : tif->tif_curstrip,\n \t\t    tif->tif_rawdata, tif->tif_rawcc))\n \t\t\treturn (0);\n \t\ttif->tif_rawcc = 0;\n \t\ttif->tif_rawcp = tif->tif_rawdata;\n \t}\n\treturn (1);\n}\n", "target": 1, "idx": 180043}
{"func": "ftp_reinit(ftpbuf_t *ftp)\n{\n\tif (ftp == NULL) {\n\t\treturn 0;\n\t}\n\n\tftp_gc(ftp);\n\n\tftp->nb = 0;\n\n\tif (!ftp_putcmd(ftp, \"REIN\", NULL)) {\n\t\treturn 0;\n\t}\n\tif (!ftp_getresp(ftp) || ftp->resp != 220) {\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n", "target": 0, "idx": 14807}
{"func": "static Image *ReadDCMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    explicit_vr[MaxTextExtent],\n    implicit_vr[MaxTextExtent],\n    magick[MaxTextExtent],\n    photometric[MaxTextExtent];\n\n  DCMStreamInfo\n    *stream_info;\n\n  Image\n    *image;\n\n  int\n    *bluemap,\n    datum,\n    *greenmap,\n    *graymap,\n    index,\n    *redmap;\n\n  MagickBooleanType\n    explicit_file,\n    explicit_retry,\n    polarity,\n    sequence,\n    use_explicit;\n\n  MagickOffsetType\n    offset;\n\n  Quantum\n    *scale;\n\n  register IndexPacket\n    *indexes;\n\n  register ssize_t\n    i,\n    x;\n\n  register PixelPacket\n    *q;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bits_allocated,\n    bytes_per_pixel,\n    colors,\n    depth,\n    height,\n    length,\n    mask,\n    max_value,\n    number_scenes,\n    quantum,\n    samples_per_pixel,\n    signed_data,\n    significant_bits,\n    status,\n    width,\n    window_width;\n\n  ssize_t\n    count,\n    scene,\n    window_center,\n    y;\n\n  unsigned char\n    *data;\n\n  unsigned short\n    group,\n    element;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  image->depth=8UL;\n  image->endian=LSBEndian;\n  /*\n    Read DCM preamble.\n  */\n  stream_info=(DCMStreamInfo *) AcquireMagickMemory(sizeof(*stream_info));\n  if (stream_info == (DCMStreamInfo *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(stream_info,0,sizeof(*stream_info));\n  count=ReadBlob(image,128,(unsigned char *) magick);\n  if (count != 128)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  count=ReadBlob(image,4,(unsigned char *) magick);\n  if ((count != 4) || (LocaleNCompare(magick,\"DICM\",4) != 0))\n    {\n      offset=SeekBlob(image,0L,SEEK_SET);\n      if (offset < 0)\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  /*\n    Read DCM Medical image.\n  */\n  (void) CopyMagickString(photometric,\"MONOCHROME1 \",MaxTextExtent);\n  bits_allocated=8;\n  bytes_per_pixel=1;\n  polarity=MagickFalse;\n  data=(unsigned char *) NULL;\n  depth=8;\n  element=0;\n  explicit_vr[2]='\\0';\n  explicit_file=MagickFalse;\n  colors=0;\n  redmap=(int *) NULL;\n  greenmap=(int *) NULL;\n  bluemap=(int *) NULL;\n  graymap=(int *) NULL;\n  height=0;\n  max_value=255UL;\n  mask=0xffff;\n  number_scenes=1;\n  samples_per_pixel=1;\n  scale=(Quantum *) NULL;\n  sequence=MagickFalse;\n  signed_data=(~0UL);\n  significant_bits=0;\n  use_explicit=MagickFalse;\n  explicit_retry = MagickFalse;\n  width=0;\n  window_center=0;\n  window_width=0;\n  for (group=0; (group != 0x7FE0) || (element != 0x0010) ||\n                (sequence != MagickFalse); )\n  {\n    /*\n      Read a group.\n    */\n    image->offset=(ssize_t) TellBlob(image);\n    group=ReadBlobLSBShort(image);\n    element=ReadBlobLSBShort(image);\n    if ((group != 0x0002) && (image->endian == MSBEndian))\n      {\n        group=(unsigned short) ((group << 8) | ((group >> 8) & 0xFF));\n        element=(unsigned short) ((element << 8) | ((element >> 8) & 0xFF));\n      }\n    quantum=0;\n    /*\n      Find corresponding VR for this group and element.\n    */\n    for (i=0; dicom_info[i].group < 0xffff; i++)\n      if ((group == dicom_info[i].group) && (element == dicom_info[i].element))\n        break;\n    (void) CopyMagickString(implicit_vr,dicom_info[i].vr,MaxTextExtent);\n    count=ReadBlob(image,2,(unsigned char *) explicit_vr);\n    if (count != 2)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    /*\n      Check for \"explicitness\", but meta-file headers always explicit.\n    */\n    if ((explicit_file == MagickFalse) && (group != 0x0002))\n      explicit_file=(isupper((unsigned char) *explicit_vr) != MagickFalse) &&\n        (isupper((unsigned char) *(explicit_vr+1)) != MagickFalse) ?\n        MagickTrue : MagickFalse;\n    use_explicit=((group == 0x0002) && (explicit_retry == MagickFalse)) ||\n      (explicit_file != MagickFalse) ? MagickTrue : MagickFalse;\n    if ((use_explicit != MagickFalse) && (strcmp(implicit_vr,\"xs\") == 0))\n      (void) CopyMagickString(implicit_vr,explicit_vr,MaxTextExtent);\n    if ((use_explicit == MagickFalse) || (strcmp(implicit_vr,\"!!\") == 0))\n      {\n        offset=SeekBlob(image,(MagickOffsetType) -2,SEEK_CUR);\n        if (offset < 0)\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        quantum=4;\n      }\n    else\n      {\n        /*\n          Assume explicit type.\n        */\n        quantum=2;\n        if ((strcmp(explicit_vr,\"OB\") == 0) ||\n            (strcmp(explicit_vr,\"UN\") == 0) ||\n            (strcmp(explicit_vr,\"OW\") == 0) || (strcmp(explicit_vr,\"SQ\") == 0))\n          {\n            (void) ReadBlobLSBShort(image);\n            quantum=4;\n          }\n      }\n    datum=0;\n    if (quantum == 4)\n      {\n        if (group == 0x0002)\n          datum=(int) ReadBlobLSBLong(image);\n        else\n          datum=(int) ReadBlobLong(image);\n      }\n    else\n      if (quantum == 2)\n        {\n          if (group == 0x0002)\n            datum=(int) ReadBlobLSBShort(image);\n          else\n            datum=(int) ReadBlobShort(image);\n        }\n    quantum=0;\n    length=1;\n    if (datum != 0)\n      {\n        if ((strcmp(implicit_vr,\"SS\") == 0) ||\n            (strcmp(implicit_vr,\"US\") == 0))\n          quantum=2;\n        else\n          if ((strcmp(implicit_vr,\"UL\") == 0) ||\n              (strcmp(implicit_vr,\"SL\") == 0) ||\n              (strcmp(implicit_vr,\"FL\") == 0))\n            quantum=4;\n          else\n            if (strcmp(implicit_vr,\"FD\") != 0)\n              quantum=1;\n            else\n              quantum=8;\n        if (datum != ~0)\n          length=(size_t) datum/quantum;\n        else\n          {\n            /*\n              Sequence and item of undefined length.\n            */\n            quantum=0;\n            length=0;\n          }\n      }\n    if (image_info->verbose != MagickFalse)\n      {\n        /*\n          Display Dicom info.\n        */\n        if (use_explicit == MagickFalse)\n          explicit_vr[0]='\\0';\n        for (i=0; dicom_info[i].description != (char *) NULL; i++)\n          if ((group == dicom_info[i].group) &&\n              (element == dicom_info[i].element))\n            break;\n        (void) FormatLocaleFile(stdout,\"0x%04lX %4ld %s-%s (0x%04lx,0x%04lx)\",\n          (unsigned long) image->offset,(long) length,implicit_vr,explicit_vr,\n          (unsigned long) group,(unsigned long) element);\n        if (dicom_info[i].description != (char *) NULL)\n          (void) FormatLocaleFile(stdout,\" %s\",dicom_info[i].description);\n        (void) FormatLocaleFile(stdout,\": \");\n      }\n    if ((sequence == MagickFalse) && (group == 0x7FE0) && (element == 0x0010))\n      {\n        if (image_info->verbose != MagickFalse)\n          (void) FormatLocaleFile(stdout,\"\\n\");\n        break;\n      }\n    /*\n      Allocate space and read an array.\n    */\n    data=(unsigned char *) NULL;\n    if ((length == 1) && (quantum == 1))\n      datum=(int) ReadBlobByte(image);\n    else\n      if ((length == 1) && (quantum == 2))\n        {\n          if (group == 0x0002)\n            datum=(int) ReadBlobLSBShort(image);\n          else\n            datum=(int) ReadBlobShort(image);\n        }\n      else\n        if ((length == 1) && (quantum == 4))\n          {\n            if (group == 0x0002)\n              datum=(int) ReadBlobLSBLong(image);\n            else\n              datum=(int) ReadBlobLong(image);\n          }\n        else\n          if ((quantum != 0) && (length != 0))\n            {\n              if (~length >= 1)\n                data=(unsigned char *) AcquireQuantumMemory(length+1,quantum*\n                  sizeof(*data));\n              if (data == (unsigned char *) NULL)\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              count=ReadBlob(image,(size_t) quantum*length,data);\n              if (count != (ssize_t) (quantum*length))\n                {\n                  if (image_info->verbose != MagickFalse)\n                    (void) FormatLocaleFile(stdout,\"count=%d quantum=%d \"\n                      \"length=%d group=%d\\n\",(int) count,(int) quantum,(int)\n                      length,(int) group);\n                   ThrowReaderException(CorruptImageError,\n                     \"InsufficientImageDataInFile\");\n                }\n              data[length*quantum]='\\0';\n            }\n          else\n            if ((unsigned int) datum == 0xFFFFFFFFU)\n              {\n                sequence=MagickTrue;\n                continue;\n              }\n    if ((unsigned int) ((group << 16) | element) == 0xFFFEE0DD)\n      {\n        if (data != (unsigned char *) NULL)\n          data=(unsigned char *) RelinquishMagickMemory(data);\n        sequence=MagickFalse;\n        continue;\n      }\n    if (sequence != MagickFalse)\n      {\n        if (data != (unsigned char *) NULL)\n          data=(unsigned char *) RelinquishMagickMemory(data);\n        continue;\n      }\n    switch (group)\n    {\n      case 0x0002:\n      {\n        switch (element)\n        {\n          case 0x0010:\n          {\n            char\n              transfer_syntax[MaxTextExtent];\n\n            /*\n              Transfer Syntax.\n            */\n            if ((datum == 0) && (explicit_retry == MagickFalse))\n              {\n                explicit_retry=MagickTrue;\n                (void) SeekBlob(image,(MagickOffsetType) 0,SEEK_SET);\n                group=0;\n                element=0;\n                if (image_info->verbose != MagickFalse)\n                  (void) FormatLocaleFile(stdout,\n                    \"Corrupted image - trying explicit format\\n\");\n                break;\n              }\n            *transfer_syntax='\\0';\n            if (data != (unsigned char *) NULL)\n              (void) CopyMagickString(transfer_syntax,(char *) data,\n                MaxTextExtent);\n            if (image_info->verbose != MagickFalse)\n              (void) FormatLocaleFile(stdout,\"transfer_syntax=%s\\n\",\n                (const char *) transfer_syntax);\n            if (strncmp(transfer_syntax,\"1.2.840.10008.1.2\",17) == 0)\n              {\n                int\n                  subtype,\n                  type;\n\n                type=0;\n                subtype=0;\n                (void) sscanf(transfer_syntax+17,\".%d.%d\",&type,&subtype);\n                switch (type)\n                {\n                  case 1:\n                  {\n                    image->endian=LSBEndian;\n                    break;\n                  }\n                  case 2:\n                  {\n                    image->endian=MSBEndian;\n                    break;\n                  }\n                  case 4:\n                  {\n                    if ((subtype >= 80) && (subtype <= 81))\n                      image->compression=JPEGCompression;\n                    else\n                      if ((subtype >= 90) && (subtype <= 93))\n                        image->compression=JPEG2000Compression;\n                      else\n                        image->compression=JPEGCompression;\n                    break;\n                  }\n                  case 5:\n                  {\n                    image->compression=RLECompression;\n                    break;\n                  }\n                }\n              }\n            break;\n          }\n          default:\n            break;\n        }\n        break;\n      }\n      case 0x0028:\n      {\n        switch (element)\n        {\n          case 0x0002:\n          {\n            /*\n              Samples per pixel.\n            */\n            samples_per_pixel=(size_t) datum;\n            break;\n          }\n          case 0x0004:\n          {\n            /*\n              Photometric interpretation.\n            */\n            for (i=0; i < (ssize_t) MagickMin(length,MaxTextExtent-1); i++)\n              photometric[i]=(char) data[i];\n            photometric[i]='\\0';\n            polarity=LocaleCompare(photometric,\"MONOCHROME1 \") == 0 ?\n              MagickTrue : MagickFalse;\n            break;\n          }\n          case 0x0006:\n          {\n            /*\n              Planar configuration.\n            */\n            if (datum == 1)\n              image->interlace=PlaneInterlace;\n            break;\n          }\n          case 0x0008:\n          {\n            /*\n              Number of frames.\n            */\n            number_scenes=StringToUnsignedLong((char *) data);\n            break;\n          }\n          case 0x0010:\n          {\n            /*\n              Image rows.\n            */\n            height=(size_t) datum;\n            break;\n          }\n          case 0x0011:\n          {\n            /*\n              Image columns.\n            */\n            width=(size_t) datum;\n            break;\n          }\n          case 0x0100:\n          {\n            /*\n              Bits allocated.\n            */\n            bits_allocated=(size_t) datum;\n            bytes_per_pixel=1;\n            if (datum > 8)\n              bytes_per_pixel=2;\n            depth=bits_allocated;\n            if (depth > 32)\n              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            max_value=(1UL << bits_allocated)-1;\n            break;\n          }\n          case 0x0101:\n          {\n            /*\n              Bits stored.\n            */\n            significant_bits=(size_t) datum;\n            bytes_per_pixel=1;\n            if (significant_bits > 8)\n              bytes_per_pixel=2;\n            depth=significant_bits;\n            if (depth > 32)\n              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            max_value=(1UL << significant_bits)-1;\n            mask=(size_t) GetQuantumRange(significant_bits);\n            break;\n          }\n          case 0x0102:\n          {\n            /*\n              High bit.\n            */\n            break;\n          }\n          case 0x0103:\n          {\n            /*\n              Pixel representation.\n            */\n            signed_data=(size_t) datum;\n            break;\n          }\n          case 0x1050:\n          {\n            /*\n              Visible pixel range: center.\n            */\n            if (data != (unsigned char *) NULL)\n              window_center=(ssize_t) StringToLong((char *) data);\n            break;\n          }\n          case 0x1051:\n          {\n            /*\n              Visible pixel range: width.\n            */\n            if (data != (unsigned char *) NULL)\n              window_width=StringToUnsignedLong((char *) data);\n            break;\n          }\n          case 0x1200:\n          case 0x3006:\n          {\n            /*\n              Populate graymap.\n            */\n            if (data == (unsigned char *) NULL)\n              break;\n            colors=(size_t) (length/bytes_per_pixel);\n            datum=(int) colors;\n            graymap=(int *) AcquireQuantumMemory((size_t) colors,\n              sizeof(*graymap));\n            if (graymap == (int *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            for (i=0; i < (ssize_t) colors; i++)\n              if (bytes_per_pixel == 1)\n                graymap[i]=(int) data[i];\n              else\n                graymap[i]=(int) ((short *) data)[i];\n            break;\n          }\n          case 0x1201:\n          {\n            unsigned short\n              index;\n\n            /*\n              Populate redmap.\n            */\n            if (data == (unsigned char *) NULL)\n              break;\n            colors=(size_t) (length/2);\n            datum=(int) colors;\n            redmap=(int *) AcquireQuantumMemory((size_t) colors,\n              sizeof(*redmap));\n            if (redmap == (int *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            p=data;\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              if (image->endian == MSBEndian)\n                index=(unsigned short) ((*p << 8) | *(p+1));\n              else\n                index=(unsigned short) (*p | (*(p+1) << 8));\n              redmap[i]=(int) index;\n              p+=2;\n            }\n            break;\n          }\n          case 0x1202:\n          {\n            unsigned short\n              index;\n\n            /*\n              Populate greenmap.\n            */\n            if (data == (unsigned char *) NULL)\n              break;\n            colors=(size_t) (length/2);\n            datum=(int) colors;\n            greenmap=(int *) AcquireQuantumMemory((size_t) colors,\n              sizeof(*greenmap));\n            if (greenmap == (int *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            p=data;\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              if (image->endian == MSBEndian)\n                index=(unsigned short) ((*p << 8) | *(p+1));\n              else\n                index=(unsigned short) (*p | (*(p+1) << 8));\n              greenmap[i]=(int) index;\n              p+=2;\n            }\n            break;\n          }\n          case 0x1203:\n          {\n            unsigned short\n              index;\n\n            /*\n              Populate bluemap.\n            */\n            if (data == (unsigned char *) NULL)\n              break;\n            colors=(size_t) (length/2);\n            datum=(int) colors;\n            bluemap=(int *) AcquireQuantumMemory((size_t) colors,\n              sizeof(*bluemap));\n            if (bluemap == (int *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            p=data;\n            for (i=0; i < (ssize_t) colors; i++)\n            {\n              if (image->endian == MSBEndian)\n                index=(unsigned short) ((*p << 8) | *(p+1));\n              else\n                index=(unsigned short) (*p | (*(p+1) << 8));\n              bluemap[i]=(int) index;\n              p+=2;\n            }\n            break;\n          }\n          default:\n            break;\n        }\n        break;\n      }\n      case 0x2050:\n      {\n        switch (element)\n        {\n          case 0x0020:\n          {\n            if ((data != (unsigned char *) NULL) &&\n                (strncmp((char*) data,\"INVERSE\", 7) == 0))\n              polarity=MagickTrue;\n            break;\n          }\n          default:\n            break;\n        }\n        break;\n      }\n      default:\n        break;\n    }\n    if (data != (unsigned char *) NULL)\n      {\n        char\n          *attribute;\n\n        for (i=0; dicom_info[i].description != (char *) NULL; i++)\n          if ((group == dicom_info[i].group) &&\n              (element == dicom_info[i].element))\n            break;\n        if (dicom_info[i].description != (char *) NULL)\n          {\n            attribute=AcquireString(\"dcm:\");\n            (void) ConcatenateString(&attribute,dicom_info[i].description);\n            for (i=0; i < (ssize_t) MagickMax(length,4); i++)\n              if (isprint((int) data[i]) == MagickFalse)\n                break;\n            if ((i == (ssize_t) length) || (length > 4))\n              {\n                (void) SubstituteString(&attribute,\" \",\"\");\n                (void) SetImageProperty(image,attribute,(char *) data);\n              }\n            attribute=DestroyString(attribute);\n          }\n      }\n    if (image_info->verbose != MagickFalse)\n      {\n        if (data == (unsigned char *) NULL)\n          (void) FormatLocaleFile(stdout,\"%d\\n\",datum);\n        else\n          {\n            /*\n              Display group data.\n            */\n            for (i=0; i < (ssize_t) MagickMax(length,4); i++)\n              if (isprint((int) data[i]) == MagickFalse)\n                break;\n            if ((i != (ssize_t) length) && (length <= 4))\n              {\n                ssize_t\n                  j;\n\n                datum=0;\n                for (j=(ssize_t) length-1; j >= 0; j--)\n                  datum=(256*datum+data[j]);\n                (void) FormatLocaleFile(stdout,\"%d\",datum);\n              }\n            else\n              for (i=0; i < (ssize_t) length; i++)\n                if (isprint((int) data[i]) != MagickFalse)\n                  (void) FormatLocaleFile(stdout,\"%c\",data[i]);\n                else\n                  (void) FormatLocaleFile(stdout,\"%c\",'.');\n            (void) FormatLocaleFile(stdout,\"\\n\");\n          }\n      }\n    if (data != (unsigned char *) NULL)\n      data=(unsigned char *) RelinquishMagickMemory(data);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n  }\n  if ((width == 0) || (height == 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  image->columns=(size_t) width;\n  image->rows=(size_t) height;\n  if (signed_data == 0xffff)\n    signed_data=(size_t) (significant_bits == 16 ? 1 : 0);\n  if ((image->compression == JPEGCompression) ||\n      (image->compression == JPEG2000Compression))\n    {\n      Image\n        *images;\n\n      ImageInfo\n        *read_info;\n\n      int\n        c;\n\n      size_t\n        length;\n\n      unsigned int\n        tag;\n\n      /*\n        Read offset table.\n      */\n      for (i=0; i < (ssize_t) stream_info->remaining; i++)\n        (void) ReadBlobByte(image);\n      tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);\n      (void) tag;\n      length=(size_t) ReadBlobLSBLong(image);\n      stream_info->offset_count=length >> 2;\n      if (stream_info->offset_count != 0)\n        {\n          MagickOffsetType\n            offset;\n\n          stream_info->offsets=(ssize_t *) AcquireQuantumMemory(\n            stream_info->offset_count,sizeof(*stream_info->offsets));\n          if (stream_info->offsets == (ssize_t *) NULL)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n            stream_info->offsets[i]=(ssize_t) ((int) ReadBlobLSBLong(image));\n          offset=TellBlob(image);\n          for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n            stream_info->offsets[i]+=offset;\n        }\n      /*\n        Handle non-native image formats.\n      */\n      read_info=CloneImageInfo(image_info);\n      SetImageInfoBlob(read_info,(void *) NULL,0);\n      images=NewImageList();\n      for (scene=0; scene < (ssize_t) number_scenes; scene++)\n      {\n        char\n          filename[MaxTextExtent];\n\n        const char\n          *property;\n\n        FILE\n          *file;\n\n        Image\n          *jpeg_image;\n\n        int\n          unique_file;\n\n        unsigned int\n          tag;\n\n        tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);\n        length=(size_t) ReadBlobLSBLong(image);\n        if (tag == 0xFFFEE0DD)\n          break; /* sequence delimiter tag */\n        if (tag != 0xFFFEE000)\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        file=(FILE *) NULL;\n        unique_file=AcquireUniqueFileResource(filename);\n        if (unique_file != -1)\n          file=fdopen(unique_file,\"wb\");\n        if (file == (FILE *) NULL)\n          {\n            (void) RelinquishUniqueFileResource(filename);\n            ThrowFileException(exception,FileOpenError,\n              \"UnableToCreateTemporaryFile\",filename);\n            break;\n          }\n        for ( ; length != 0; length--)\n        {\n          c=ReadBlobByte(image);\n          if (c == EOF)\n            {\n              ThrowFileException(exception,CorruptImageError,\n                \"UnexpectedEndOfFile\",image->filename);\n              break;\n            }\n          (void) fputc(c,file);\n        }\n        (void) fclose(file);\n        (void) FormatLocaleString(read_info->filename,MaxTextExtent,\"jpeg:%s\",\n          filename);\n        if (image->compression == JPEG2000Compression)\n          (void) FormatLocaleString(read_info->filename,MaxTextExtent,\"j2k:%s\",\n            filename);\n        jpeg_image=ReadImage(read_info,exception);\n        if (jpeg_image != (Image *) NULL)\n          {\n            ResetImagePropertyIterator(image);\n            property=GetNextImageProperty(image);\n            while (property != (const char *) NULL)\n            {\n              (void) SetImageProperty(jpeg_image,property,\n                GetImageProperty(image,property));\n              property=GetNextImageProperty(image);\n            }\n            AppendImageToList(&images,jpeg_image);\n          }\n        (void) RelinquishUniqueFileResource(filename);\n      }\n      read_info=DestroyImageInfo(read_info);\n      image=DestroyImage(image);\n      return(GetFirstImageInList(images));\n    }\n  if (depth != (1UL*MAGICKCORE_QUANTUM_DEPTH))\n    {\n      QuantumAny\n        range;\n\n      size_t\n        length;\n\n      /*\n        Compute pixel scaling table.\n      */\n      length=(size_t) (GetQuantumRange(depth)+1);\n      scale=(Quantum *) AcquireQuantumMemory(length,sizeof(*scale));\n      if (scale == (Quantum *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      range=GetQuantumRange(depth);\n      for (i=0; i < (ssize_t) (GetQuantumRange(depth)+1); i++)\n        scale[i]=ScaleAnyToQuantum((size_t) i,range);\n    }\n  if (image->compression == RLECompression)\n    {\n      size_t\n        length;\n\n      unsigned int\n        tag;\n\n      /*\n        Read RLE offset table.\n      */\n      for (i=0; i < (ssize_t) stream_info->remaining; i++)\n        (void) ReadBlobByte(image);\n      tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);\n      (void) tag;\n      length=(size_t) ReadBlobLSBLong(image);\n      stream_info->offset_count=length >> 2;\n      if (stream_info->offset_count != 0)\n        {\n          MagickOffsetType\n            offset;\n\n          stream_info->offsets=(ssize_t *) AcquireQuantumMemory(\n            stream_info->offset_count,sizeof(*stream_info->offsets));\n          if (stream_info->offsets == (ssize_t *) NULL)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n            stream_info->offsets[i]=(ssize_t) ((int) ReadBlobLSBLong(image));\n          offset=TellBlob(image);\n          for (i=0; i < (ssize_t) stream_info->offset_count; i++)\n            stream_info->offsets[i]+=offset;\n        }\n    }\n  for (scene=0; scene < (ssize_t) number_scenes; scene++)\n  {\n    if (image_info->ping != MagickFalse)\n      break;\n     image->columns=(size_t) width;\n     image->rows=(size_t) height;\n     image->depth=depth;\n     image->colorspace=RGBColorspace;\n     if ((image->colormap == (PixelPacket *) NULL) && (samples_per_pixel == 1))\n       {\n        size_t\n          one;\n\n        one=1;\n        if (colors == 0)\n          colors=one << depth;\n        if (AcquireImageColormap(image,one << depth) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        if (redmap != (int *) NULL)\n          for (i=0; i < (ssize_t) colors; i++)\n          {\n            index=redmap[i];\n            if ((scale != (Quantum *) NULL) && (index <= (int) max_value))\n              index=(int) scale[index];\n            image->colormap[i].red=(Quantum) index;\n          }\n        if (greenmap != (int *) NULL)\n          for (i=0; i < (ssize_t) colors; i++)\n          {\n            index=greenmap[i];\n            if ((scale != (Quantum *) NULL) && (index <= (int) max_value))\n              index=(int) scale[index];\n            image->colormap[i].green=(Quantum) index;\n          }\n        if (bluemap != (int *) NULL)\n          for (i=0; i < (ssize_t) colors; i++)\n          {\n            index=bluemap[i];\n            if ((scale != (Quantum *) NULL) && (index <= (int) max_value))\n              index=(int) scale[index];\n            image->colormap[i].blue=(Quantum) index;\n          }\n        if (graymap != (int *) NULL)\n          for (i=0; i < (ssize_t) colors; i++)\n          {\n            index=graymap[i];\n            if ((scale != (Quantum *) NULL) && (index <= (int) max_value))\n              index=(int) scale[index];\n            image->colormap[i].red=(Quantum) index;\n            image->colormap[i].green=(Quantum) index;\n            image->colormap[i].blue=(Quantum) index;\n          }\n      }\n    if (image->compression == RLECompression)\n      {\n        unsigned int\n          tag;\n\n        /*\n          Read RLE segment table.\n        */\n        for (i=0; i < (ssize_t) stream_info->remaining; i++)\n          (void) ReadBlobByte(image);\n        tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);\n        stream_info->remaining=(size_t) ReadBlobLSBLong(image);\n        if ((tag != 0xFFFEE000) || (stream_info->remaining <= 64) ||\n            (EOFBlob(image) != MagickFalse))\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        stream_info->count=0;\n        stream_info->segment_count=ReadBlobLSBLong(image);\n        if (stream_info->segment_count > 1)\n          {\n            bytes_per_pixel=1;\n            depth=8;\n          }\n        for (i=0; i < 15; i++)\n          stream_info->segments[i]=(ssize_t) ((int) ReadBlobLSBLong(image));\n        stream_info->remaining-=64;\n      }\n    if ((samples_per_pixel > 1) && (image->interlace == PlaneInterlace))\n      {\n        /*\n          Convert Planar RGB DCM Medical image to pixel packets.\n        */\n        for (i=0; i < (ssize_t) samples_per_pixel; i++)\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (PixelPacket *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              switch ((int) i)\n              {\n                case 0:\n                {\n                  SetPixelRed(q,ScaleCharToQuantum((unsigned char)\n                    ReadDCMByte(stream_info,image)));\n                  break;\n                }\n                case 1:\n                {\n                  SetPixelGreen(q,ScaleCharToQuantum((unsigned char)\n                    ReadDCMByte(stream_info,image)));\n                  break;\n                }\n                case 2:\n                {\n                  SetPixelBlue(q,ScaleCharToQuantum((unsigned char)\n                    ReadDCMByte(stream_info,image)));\n                  break;\n                }\n                case 3:\n                {\n                  SetPixelAlpha(q,ScaleCharToQuantum((unsigned char)\n                    ReadDCMByte(stream_info,image)));\n                  break;\n                }\n                default:\n                  break;\n              }\n              q++;\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                  image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n      }\n    else\n      {\n        const char\n          *option;\n\n        int\n          byte;\n\n        LongPixelPacket\n          pixel;\n\n        /*\n          Convert DCM Medical image to pixel packets.\n        */\n        byte=0;\n        i=0;\n        if ((window_center != 0) && (window_width == 0))\n          window_width=(size_t) window_center;\n        option=GetImageOption(image_info,\"dcm:display-range\");\n        if (option != (const char *) NULL)\n          {\n            if (LocaleCompare(option,\"reset\") == 0)\n              window_width=0;\n          }\n        (void) ResetMagickMemory(&pixel,0,sizeof(pixel));\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          indexes=GetAuthenticIndexQueue(image);\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            if (samples_per_pixel == 1)\n              {\n                int\n                  pixel_value;\n\n                if (bytes_per_pixel == 1)\n                  pixel_value=polarity != MagickFalse ? ((int) max_value-\n                    ReadDCMByte(stream_info,image)) :\n                    ReadDCMByte(stream_info,image);\n                else\n                  if ((bits_allocated != 12) || (significant_bits != 12))\n                    pixel_value=(int) (polarity != MagickFalse ? (max_value-\n                      ReadDCMShort(stream_info,image)) :\n                      ReadDCMShort(stream_info,image));\n                  else\n                    {\n                      if ((i & 0x01) != 0)\n                        pixel_value=(ReadDCMByte(stream_info,image) << 8) |\n                          byte;\n                      else\n                        {\n                          pixel_value=(int) ReadDCMShort(stream_info,image);\n                          byte=(int) (pixel_value & 0x0f);\n                          pixel_value>>=4;\n                        }\n                      i++;\n                    }\n                index=pixel_value;\n                if (window_width == 0)\n                  {\n                    if (signed_data == 1)\n                      index=pixel_value-32767;\n                  }\n                else\n                  {\n                    ssize_t\n                      window_max,\n                      window_min;\n\n                    window_min=(ssize_t) ceil((double) window_center-\n                      (window_width-1.0)/2.0-0.5);\n                    window_max=(ssize_t) floor((double) window_center+\n                      (window_width-1.0)/2.0+0.5);\n                    if ((ssize_t) pixel_value <= window_min)\n                      index=0;\n                    else\n                      if ((ssize_t) pixel_value > window_max)\n                        index=(int) max_value;\n                      else\n                        index=(int) (max_value*(((pixel_value-window_center-\n                          0.5)/(window_width-1))+0.5));\n                  }\n                index&=mask;\n                index=(int) ConstrainColormapIndex(image,(size_t) index);\n                SetPixelIndex(indexes+x,index);\n                pixel.red=1U*image->colormap[index].red;\n                pixel.green=1U*image->colormap[index].green;\n                pixel.blue=1U*image->colormap[index].blue;\n              }\n            else\n              {\n                if (bytes_per_pixel == 1)\n                  {\n                    pixel.red=(unsigned int) ReadDCMByte(stream_info,image);\n                    pixel.green=(unsigned int) ReadDCMByte(stream_info,image);\n                    pixel.blue=(unsigned int) ReadDCMByte(stream_info,image);\n                  }\n                else\n                  {\n                    pixel.red=ReadDCMShort(stream_info,image);\n                    pixel.green=ReadDCMShort(stream_info,image);\n                    pixel.blue=ReadDCMShort(stream_info,image);\n                  }\n                pixel.red&=mask;\n                pixel.green&=mask;\n                pixel.blue&=mask;\n                if (scale != (Quantum *) NULL)\n                  {\n                    pixel.red=scale[pixel.red];\n                    pixel.green=scale[pixel.green];\n                    pixel.blue=scale[pixel.blue];\n                  }\n              }\n            SetPixelRed(q,pixel.red);\n            SetPixelGreen(q,pixel.green);\n            SetPixelBlue(q,pixel.blue);\n            q++;\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        if (stream_info->segment_count > 1)\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (PixelPacket *) NULL)\n              break;\n            indexes=GetAuthenticIndexQueue(image);\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              if (samples_per_pixel == 1)\n                {\n                  int\n                    pixel_value;\n\n                  if (bytes_per_pixel == 1)\n                    pixel_value=polarity != MagickFalse ? ((int) max_value-\n                      ReadDCMByte(stream_info,image)) :\n                      ReadDCMByte(stream_info,image);\n                  else\n                    if ((bits_allocated != 12) || (significant_bits != 12))\n                      {\n                        pixel_value=(int) (polarity != MagickFalse ? (max_value-\n                          ReadDCMShort(stream_info,image)) :\n                          ReadDCMShort(stream_info,image));\n                        if (signed_data == 1)\n                          pixel_value=((signed short) pixel_value);\n                      }\n                    else\n                      {\n                        if ((i & 0x01) != 0)\n                          pixel_value=(ReadDCMByte(stream_info,image) << 8) |\n                            byte;\n                        else\n                          {\n                            pixel_value=(int) ReadDCMShort(stream_info,image);\n                            byte=(int) (pixel_value & 0x0f);\n                            pixel_value>>=4;\n                          }\n                        i++;\n                      }\n                  index=pixel_value;\n                  if (window_width == 0)\n                    {\n                      if (signed_data == 1)\n                        index=pixel_value-32767;\n                    }\n                  else\n                    {\n                      ssize_t\n                        window_max,\n                        window_min;\n\n                      window_min=(ssize_t) ceil((double) window_center-\n                        (window_width-1.0)/2.0-0.5);\n                      window_max=(ssize_t) floor((double) window_center+\n                        (window_width-1.0)/2.0+0.5);\n                      if ((ssize_t) pixel_value <= window_min)\n                        index=0;\n                      else\n                        if ((ssize_t) pixel_value > window_max)\n                          index=(int) max_value;\n                        else\n                          index=(int) (max_value*(((pixel_value-window_center-\n                            0.5)/(window_width-1))+0.5));\n                    }\n                  index&=mask;\n                  index=(int) ConstrainColormapIndex(image,(size_t) index);\n                  SetPixelIndex(indexes+x,(((size_t) GetPixelIndex(indexes+x)) |\n                    (((size_t) index) << 8)));\n                  pixel.red=1U*image->colormap[index].red;\n                  pixel.green=1U*image->colormap[index].green;\n                  pixel.blue=1U*image->colormap[index].blue;\n                }\n              else\n                {\n                  if (bytes_per_pixel == 1)\n                    {\n                      pixel.red=(unsigned int) ReadDCMByte(stream_info,image);\n                      pixel.green=(unsigned int) ReadDCMByte(stream_info,image);\n                      pixel.blue=(unsigned int) ReadDCMByte(stream_info,image);\n                    }\n                  else\n                    {\n                      pixel.red=ReadDCMShort(stream_info,image);\n                      pixel.green=ReadDCMShort(stream_info,image);\n                      pixel.blue=ReadDCMShort(stream_info,image);\n                    }\n                  pixel.red&=mask;\n                  pixel.green&=mask;\n                  pixel.blue&=mask;\n                  if (scale != (Quantum *) NULL)\n                    {\n                      pixel.red=scale[pixel.red];\n                      pixel.green=scale[pixel.green];\n                      pixel.blue=scale[pixel.blue];\n                    }\n                }\n              SetPixelRed(q,(((size_t) GetPixelRed(q)) |\n                (((size_t) pixel.red) << 8)));\n              SetPixelGreen(q,(((size_t) GetPixelGreen(q)) |\n                (((size_t) pixel.green) << 8)));\n              SetPixelBlue(q,(((size_t) GetPixelBlue(q)) |\n                (((size_t) pixel.blue) << 8)));\n              q++;\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                  image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n      }\n    if (IsGrayImage(image,exception) != MagickFalse)\n      (void) SetImageColorspace(image,GRAYColorspace);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if (scene < (ssize_t) (number_scenes-1))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  /*\n    Free resources.\n  */\n  if (stream_info->offsets != (ssize_t *) NULL)\n    stream_info->offsets=(ssize_t *)\n      RelinquishMagickMemory(stream_info->offsets);\n  stream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info);\n  if (scale != (Quantum *) NULL)\n    scale=(Quantum *) RelinquishMagickMemory(scale);\n  if (graymap != (int *) NULL)\n    graymap=(int *) RelinquishMagickMemory(graymap);\n  if (bluemap != (int *) NULL)\n    bluemap=(int *) RelinquishMagickMemory(bluemap);\n  if (greenmap != (int *) NULL)\n    greenmap=(int *) RelinquishMagickMemory(greenmap);\n  if (redmap != (int *) NULL)\n    redmap=(int *) RelinquishMagickMemory(redmap);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n", "target": 1, "idx": 181727}
{"func": "v8::Local<v8::Object> AsObjectOrEmpty(v8::Local<v8::Value> value) {\n  return value->IsObject() ? value.As<v8::Object>() : v8::Local<v8::Object>();\n}\n", "target": 0, "idx": 145205}
{"func": "DECLAREreadFunc(readContigTilesIntoBuffer)\n{\n\tint status = 1;\n\ttsize_t tilesize = TIFFTileSize(in);\n\ttdata_t tilebuf;\n\tuint32 imagew = TIFFScanlineSize(in);\n\tuint32 tilew  = TIFFTileRowSize(in);\n\tint iskew = imagew - tilew;\n\tuint8* bufp = (uint8*) buf;\n\tuint32 tw, tl;\n\tuint32 row;\n\n\t(void) spp;\n\ttilebuf = _TIFFmalloc(tilesize);\n\tif (tilebuf == 0)\n\t\treturn 0;\n\t_TIFFmemset(tilebuf, 0, tilesize);\n\t(void) TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);\n\t(void) TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);\n        \n\tfor (row = 0; row < imagelength; row += tl) {\n\t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;\n \t\tuint32 colb = 0;\n \t\tuint32 col;\n \n\t\tfor (col = 0; col < imagewidth; col += tw) {\n \t\t\tif (TIFFReadTile(in, tilebuf, col, row, 0, 0) < 0\n \t\t\t    && !ignore) {\n \t\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t\t    \"Error, can't read tile at %lu %lu\",\n\t\t\t\t    (unsigned long) col,\n\t\t\t\t    (unsigned long) row);\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif (colb + tilew > imagew) {\n\t\t\t\tuint32 width = imagew - colb;\n\t\t\t\tuint32 oskew = tilew - width;\n\t\t\t\tcpStripToTile(bufp + colb,\n\t\t\t\t    tilebuf, nrow, width,\n\t\t\t\t    oskew + iskew, oskew );\n\t\t\t} else\n\t\t\t\tcpStripToTile(bufp + colb,\n\t\t\t\t    tilebuf, nrow, tilew,\n\t\t\t\t    iskew, 0);\n\t\t\tcolb += tilew;\n\t\t}\n\t\tbufp += imagew * nrow;\n\t}\ndone:\n\t_TIFFfree(tilebuf);\n\treturn status;\n}\n", "target": 1, "idx": 180034}
{"func": "static void ptrace_triggered(struct perf_event *bp, int nmi,\n \t\t\t     struct perf_sample_data *data,\n \t\t\t     struct pt_regs *regs)\n {\n\tint i;\n\tstruct thread_struct *thread = &(current->thread);\n\n\t/*\n\t * Store in the virtual DR6 register the fact that the breakpoint\n\t * was hit so the thread's debugger will see it.\n\t */\n\tfor (i = 0; i < HBP_NUM; i++) {\n\t\tif (thread->ptrace_bps[i] == bp)\n\t\t\tbreak;\n\t}\n\n\tthread->debugreg6 |= (DR_TRAP0 << i);\n}\n", "target": 1, "idx": 178996}
{"func": "WORD32 ih264d_parse_decode_slice(UWORD8 u1_is_idr_slice,\n                                 UWORD8 u1_nal_ref_idc,\n dec_struct_t *ps_dec /* Decoder parameters */\n )\n{\n dec_bit_stream_t * ps_bitstrm = ps_dec->ps_bitstrm;\n dec_pic_params_t *ps_pps;\n dec_seq_params_t *ps_seq;\n dec_slice_params_t *ps_cur_slice = ps_dec->ps_cur_slice;\n pocstruct_t s_tmp_poc;\n    WORD32 i_delta_poc[2];\n    WORD32 i4_poc = 0;\n    UWORD16 u2_first_mb_in_slice, u2_frame_num;\n    UWORD8 u1_field_pic_flag, u1_redundant_pic_cnt = 0, u1_slice_type;\n    UWORD32 u4_idr_pic_id = 0;\n    UWORD8 u1_bottom_field_flag, u1_pic_order_cnt_type;\n\n    UWORD8 u1_nal_unit_type;\n    UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;\n    UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;\n    WORD8 i1_is_end_of_poc;\n\n    WORD32 ret, end_of_frame;\n    WORD32 prev_slice_err, num_mb_skipped;\n    UWORD8 u1_mbaff;\n pocstruct_t *ps_cur_poc;\n\n    UWORD32 u4_temp;\n    WORD32 i_temp;\n    UWORD32 u4_call_end_of_pic = 0;\n\n /* read FirstMbInSlice  and slice type*/\n    ps_dec->ps_dpb_cmds->u1_dpb_commands_read_slc = 0;\n    u2_first_mb_in_slice = ih264d_uev(pu4_bitstrm_ofst,\n                                     pu4_bitstrm_buf);\n if(u2_first_mb_in_slice\n > (ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs))\n {\n\n return ERROR_CORRUPTED_SLICE;\n }\n\n /*we currently don not support ASO*/\n if(((u2_first_mb_in_slice << ps_cur_slice->u1_mbaff_frame_flag)\n <= ps_dec->u2_cur_mb_addr) && (ps_dec->u4_first_slice_in_pic == 0))\n {\n return ERROR_CORRUPTED_SLICE;\n }\n\n    COPYTHECONTEXT(\"SH: first_mb_in_slice\",u2_first_mb_in_slice);\n\n    u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);\n\n if(u4_temp > 9)\n return ERROR_INV_SLC_TYPE_T;\n\n    u1_slice_type = u4_temp;\n    COPYTHECONTEXT(\"SH: slice_type\",(u1_slice_type));\n    ps_dec->u1_sl_typ_5_9 = 0;\n /* Find Out the Slice Type is 5 to 9 or not then Set the Flag   */\n /* u1_sl_typ_5_9 = 1 .Which tells that all the slices in the Pic*/\n /* will be of same type of current                            */\n if(u1_slice_type > 4)\n {\n        u1_slice_type -= 5;\n        ps_dec->u1_sl_typ_5_9 = 1;\n }\n\n {\n        UWORD32 skip;\n\n if((ps_dec->i4_app_skip_mode == IVD_SKIP_PB)\n || (ps_dec->i4_dec_skip_mode == IVD_SKIP_PB))\n {\n            UWORD32 u4_bit_stream_offset = 0;\n\n if(ps_dec->u1_nal_unit_type == IDR_SLICE_NAL)\n {\n                skip = 0;\n\n                ps_dec->i4_dec_skip_mode = IVD_SKIP_NONE;\n }\n else if((I_SLICE == u1_slice_type)\n && (1 >= ps_dec->ps_cur_sps->u1_num_ref_frames))\n {\n                skip = 0;\n\n                ps_dec->i4_dec_skip_mode = IVD_SKIP_NONE;\n }\n else\n {\n                skip = 1;\n }\n\n /* If one frame worth of data is already skipped, do not skip the next one */\n if((0 == u2_first_mb_in_slice) && (1 == ps_dec->u4_prev_nal_skipped))\n {\n                skip = 0;\n }\n\n if(skip)\n {\n                ps_dec->u4_prev_nal_skipped = 1;\n                ps_dec->i4_dec_skip_mode = IVD_SKIP_PB;\n return 0;\n }\n else\n {\n /* If the previous NAL was skipped, then\n                 do not process that buffer in this call.\n                 Return to app and process it in the next call.\n                 This is necessary to handle cases where I/IDR is not complete in\n                 the current buffer and application intends to fill the remaining part of the bitstream\n                 later. This ensures we process only frame worth of data in every call */\n if(1 == ps_dec->u4_prev_nal_skipped)\n {\n                    ps_dec->u4_return_to_app = 1;\n return 0;\n }\n }\n }\n\n }\n\n    u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);\n if(u4_temp & MASK_ERR_PIC_SET_ID)\n return ERROR_INV_SLICE_HDR_T;\n /* discard slice if pic param is invalid */\n    COPYTHECONTEXT(\"SH: pic_parameter_set_id\", u4_temp);\n    ps_pps = &ps_dec->ps_pps[u4_temp];\n if(FALSE == ps_pps->u1_is_valid)\n {\n return ERROR_INV_SLICE_HDR_T;\n }\n    ps_seq = ps_pps->ps_sps;\n if(!ps_seq)\n return ERROR_INV_SLICE_HDR_T;\n if(FALSE == ps_seq->u1_is_valid)\n return ERROR_INV_SLICE_HDR_T;\n\n /* Get the frame num */\n    u2_frame_num = ih264d_get_bits_h264(ps_bitstrm,\n                                         ps_seq->u1_bits_in_frm_num);\n\n    COPYTHECONTEXT(\"SH: frame_num\", u2_frame_num);\n\n /* Get the field related flags  */\n if(!ps_seq->u1_frame_mbs_only_flag)\n {\n\n        u1_field_pic_flag = ih264d_get_bit_h264(ps_bitstrm);\n        COPYTHECONTEXT(\"SH: field_pic_flag\", u1_field_pic_flag);\n        u1_bottom_field_flag = 0;\n\n if(u1_field_pic_flag)\n {\n            ps_dec->pu1_inv_scan = (UWORD8 *)gau1_ih264d_inv_scan_fld;\n            u1_bottom_field_flag = ih264d_get_bit_h264(ps_bitstrm);\n            COPYTHECONTEXT(\"SH: bottom_field_flag\", u1_bottom_field_flag);\n\n }\n else\n {\n            ps_dec->pu1_inv_scan = (UWORD8 *)gau1_ih264d_inv_scan;\n }\n }\n else\n {\n        u1_field_pic_flag = 0;\n        u1_bottom_field_flag = 0;\n\n        ps_dec->pu1_inv_scan = (UWORD8 *)gau1_ih264d_inv_scan;\n }\n\n    u1_nal_unit_type = SLICE_NAL;\n if(u1_is_idr_slice)\n {\n if(0 == u1_field_pic_flag)\n {\n            ps_dec->u1_top_bottom_decoded = TOP_FIELD_ONLY | BOT_FIELD_ONLY;\n }\n        u1_nal_unit_type = IDR_SLICE_NAL;\n        u4_idr_pic_id = ih264d_uev(pu4_bitstrm_ofst,\n                                   pu4_bitstrm_buf);\n if(u4_idr_pic_id > 65535)\n return ERROR_INV_SLICE_HDR_T;\n        COPYTHECONTEXT(\"SH:  \", u4_idr_pic_id);\n }\n\n /* read delta pic order count information*/\n    i_delta_poc[0] = i_delta_poc[1] = 0;\n    s_tmp_poc.i4_pic_order_cnt_lsb = 0;\n    s_tmp_poc.i4_delta_pic_order_cnt_bottom = 0;\n    u1_pic_order_cnt_type = ps_seq->u1_pic_order_cnt_type;\n if(u1_pic_order_cnt_type == 0)\n {\n        i_temp = ih264d_get_bits_h264(\n                        ps_bitstrm,\n                        ps_seq->u1_log2_max_pic_order_cnt_lsb_minus);\n if(i_temp < 0 || i_temp >= ps_seq->i4_max_pic_order_cntLsb)\n return ERROR_INV_SLICE_HDR_T;\n        s_tmp_poc.i4_pic_order_cnt_lsb = i_temp;\n        COPYTHECONTEXT(\"SH: pic_order_cnt_lsb\", s_tmp_poc.i4_pic_order_cnt_lsb);\n\n if((ps_pps->u1_pic_order_present_flag == 1) && (!u1_field_pic_flag))\n {\n            s_tmp_poc.i4_delta_pic_order_cnt_bottom = ih264d_sev(\n                            pu4_bitstrm_ofst, pu4_bitstrm_buf);\n            COPYTHECONTEXT(\"SH: delta_pic_order_cnt_bottom\",\n                            s_tmp_poc.i4_delta_pic_order_cnt_bottom);\n }\n }\n\n    s_tmp_poc.i4_delta_pic_order_cnt[0] = 0;\n    s_tmp_poc.i4_delta_pic_order_cnt[1] = 0;\n if(u1_pic_order_cnt_type == 1\n && (!ps_seq->u1_delta_pic_order_always_zero_flag))\n {\n        s_tmp_poc.i4_delta_pic_order_cnt[0] = ih264d_sev(pu4_bitstrm_ofst,\n                                                         pu4_bitstrm_buf);\n        COPYTHECONTEXT(\"SH: delta_pic_order_cnt[0]\",\n                        s_tmp_poc.i4_delta_pic_order_cnt[0]);\n\n if(ps_pps->u1_pic_order_present_flag && !u1_field_pic_flag)\n {\n            s_tmp_poc.i4_delta_pic_order_cnt[1] = ih264d_sev(\n                            pu4_bitstrm_ofst, pu4_bitstrm_buf);\n            COPYTHECONTEXT(\"SH: delta_pic_order_cnt[1]\",\n                            s_tmp_poc.i4_delta_pic_order_cnt[1]);\n }\n }\n\n if(ps_pps->u1_redundant_pic_cnt_present_flag)\n {\n        u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);\n if(u4_temp > MAX_REDUNDANT_PIC_CNT)\n return ERROR_INV_SLICE_HDR_T;\n        u1_redundant_pic_cnt = u4_temp;\n        COPYTHECONTEXT(\"SH: redundant_pic_cnt\", u1_redundant_pic_cnt);\n }\n\n\n     /*--------------------------------------------------------------------*/\n     /* Check if the slice is part of new picture                          */\n     /*--------------------------------------------------------------------*/\n    i1_is_end_of_poc = 0;\n    if(!ps_dec->u1_first_slice_in_stream)\n     {\n         i1_is_end_of_poc = ih264d_is_end_of_pic(u2_frame_num, u1_nal_ref_idc,\n                                             &s_tmp_poc, &ps_dec->s_cur_pic_poc,\n                                            ps_cur_slice, u1_pic_order_cnt_type,\n\n                                             u1_nal_unit_type, u4_idr_pic_id,\n                                             u1_field_pic_flag,\n                                             u1_bottom_field_flag);\n        /* since we support only Full frame decode, every new process should\n         * process a new pic\n         */\n        if((ps_dec->u4_first_slice_in_pic == 2) && (i1_is_end_of_poc == 0))\n        {\n            /* if it is the first slice is process call ,it should be a new frame. If it is not\n             * reject current pic and dont add it to dpb\n             */\n            ps_dec->ps_dec_err_status->u1_err_flag |= REJECT_CUR_PIC;\n            i1_is_end_of_poc = 1;\n        }\n        else\n        {\n            /* reset REJECT_CUR_PIC */\n            ps_dec->ps_dec_err_status->u1_err_flag &= MASK_REJECT_CUR_PIC;\n        }\n     }\n \n     /*--------------------------------------------------------------------*/\n /* Check for error in slice and parse the missing/corrupted MB's      */\n /* as skip-MB's in an inserted P-slice                                */\n /*--------------------------------------------------------------------*/\n    u1_mbaff = ps_seq->u1_mb_aff_flag && (!u1_field_pic_flag);\n    prev_slice_err = 0;\n\n if(i1_is_end_of_poc || ps_dec->u1_first_slice_in_stream)\n {\n if(u2_frame_num != ps_dec->u2_prv_frame_num\n && ps_dec->u1_top_bottom_decoded != 0\n && ps_dec->u1_top_bottom_decoded\n != (TOP_FIELD_ONLY | BOT_FIELD_ONLY))\n {\n            ps_dec->u1_dangling_field = 1;\n if(ps_dec->u4_first_slice_in_pic)\n {\n                prev_slice_err = 1;\n }\n else\n {\n                prev_slice_err = 2;\n }\n\n if(ps_dec->u1_top_bottom_decoded ==TOP_FIELD_ONLY)\n                ps_cur_slice->u1_bottom_field_flag = 1;\n else\n                ps_cur_slice->u1_bottom_field_flag = 0;\n\n            num_mb_skipped = (ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n - ps_dec->u2_total_mbs_coded;\n            ps_cur_poc = &ps_dec->s_cur_pic_poc;\n\n            u1_is_idr_slice = ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL;\n }\n else if(ps_dec->u4_first_slice_in_pic == 2)\n {\n if(u2_first_mb_in_slice > 0)\n {\n                prev_slice_err = 1;\n                num_mb_skipped = u2_first_mb_in_slice << u1_mbaff;\n                ps_cur_poc = &s_tmp_poc;\n\n                ps_cur_slice->u4_idr_pic_id = u4_idr_pic_id;\n                ps_cur_slice->u1_field_pic_flag = u1_field_pic_flag;\n                ps_cur_slice->u1_bottom_field_flag = u1_bottom_field_flag;\n                ps_cur_slice->i4_pic_order_cnt_lsb =\n                        s_tmp_poc.i4_pic_order_cnt_lsb;\n                ps_cur_slice->u1_nal_unit_type = u1_nal_unit_type;\n                ps_cur_slice->u1_redundant_pic_cnt = u1_redundant_pic_cnt;\n                ps_cur_slice->u1_nal_ref_idc = u1_nal_ref_idc;\n                ps_cur_slice->u1_pic_order_cnt_type = u1_pic_order_cnt_type;\n                ps_cur_slice->u1_mbaff_frame_flag = ps_seq->u1_mb_aff_flag\n && (!u1_field_pic_flag);\n }\n }\n else\n {\n\n if(ps_dec->u4_first_slice_in_pic)\n {\n /* if valid slice header is not decoded do start of pic processing\n                 * since in the current process call, frame num is not updated in the slice structure yet\n                 * ih264d_is_end_of_pic is checked with valid frame num of previous process call,\n                 * although i1_is_end_of_poc is set there could be  more slices in the frame,\n                 * so conceal only till cur slice */\n                prev_slice_err = 1;\n                num_mb_skipped = u2_first_mb_in_slice << u1_mbaff;\n }\n else\n {\n /* since i1_is_end_of_poc is set ,means new frame num is encountered. so conceal the current frame\n                 * completely */\n                prev_slice_err = 2;\n                num_mb_skipped = (ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n - ps_dec->u2_total_mbs_coded;\n }\n            ps_cur_poc = &s_tmp_poc;\n }\n }\n else\n {\n if((u2_first_mb_in_slice << u1_mbaff) > ps_dec->u2_total_mbs_coded)\n {\n            prev_slice_err = 2;\n            num_mb_skipped = (u2_first_mb_in_slice << u1_mbaff)\n - ps_dec->u2_total_mbs_coded;\n            ps_cur_poc = &s_tmp_poc;\n }\n else if((u2_first_mb_in_slice << u1_mbaff) < ps_dec->u2_total_mbs_coded)\n {\n return ERROR_CORRUPTED_SLICE;\n }\n }\n\n if(prev_slice_err)\n {\n        ret = ih264d_mark_err_slice_skip(ps_dec, num_mb_skipped, u1_is_idr_slice, u2_frame_num, ps_cur_poc, prev_slice_err);\n\n if(ps_dec->u1_dangling_field == 1)\n {\n            ps_dec->u1_second_field = 1 - ps_dec->u1_second_field;\n            ps_cur_slice->u1_bottom_field_flag = u1_bottom_field_flag;\n            ps_dec->u2_prv_frame_num = u2_frame_num;\n            ps_dec->u1_first_slice_in_stream = 0;\n return ERROR_DANGLING_FIELD_IN_PIC;\n }\n\n if(prev_slice_err == 2)\n {\n            ps_dec->u1_first_slice_in_stream = 0;\n return ERROR_INCOMPLETE_FRAME;\n }\n\n if(ps_dec->u2_total_mbs_coded\n >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n {\n /* return if all MBs in frame are parsed*/\n            ps_dec->u1_first_slice_in_stream = 0;\n return ERROR_IN_LAST_SLICE_OF_PIC;\n }\n\n if(ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC)\n {\n            ih264d_err_pic_dispbuf_mgr(ps_dec);\n return ERROR_NEW_FRAME_EXPECTED;\n }\n\n if(ret != OK)\n return ret;\n\n        i1_is_end_of_poc = 0;\n }\n\n if (ps_dec->u4_first_slice_in_pic == 0)\n {\n        ps_dec->ps_parse_cur_slice++;\n        ps_dec->u2_cur_slice_num++;\n }\n\n if((ps_dec->u1_separate_parse == 0) && (ps_dec->u4_first_slice_in_pic == 0))\n {\n        ps_dec->ps_decode_cur_slice++;\n }\n    ps_dec->u1_slice_header_done = 0;\n\n /*--------------------------------------------------------------------*/\n /* If the slice is part of new picture, do End of Pic processing.     */\n /*--------------------------------------------------------------------*/\n if(!ps_dec->u1_first_slice_in_stream)\n {\n        UWORD8 uc_mbs_exceed = 0;\n\n if(ps_dec->u2_total_mbs_coded\n == (ps_dec->ps_cur_sps->u2_max_mb_addr + 1))\n {\n /*u2_total_mbs_coded is forced  to u2_max_mb_addr+ 1 at the end of decode ,so\n             ,if it is first slice in pic dont consider u2_total_mbs_coded to detect new picture */\n if(ps_dec->u4_first_slice_in_pic == 0)\n                uc_mbs_exceed = 1;\n }\n\n if(i1_is_end_of_poc || uc_mbs_exceed)\n {\n\n if(1 == ps_dec->u1_last_pic_not_decoded)\n {\n                ret = ih264d_end_of_pic_dispbuf_mgr(ps_dec);\n\n if(ret != OK)\n return ret;\n\n                ret = ih264d_end_of_pic(ps_dec, u1_is_idr_slice, u2_frame_num);\n if(ret != OK)\n return ret;\n#if WIN32\n                H264_DEC_DEBUG_PRINT(\" ------ PIC SKIPPED ------\\n\");\n#endif\n return RET_LAST_SKIP;\n }\n else\n {\n                ret = ih264d_end_of_pic(ps_dec, u1_is_idr_slice, u2_frame_num);\n if(ret != OK)\n return ret;\n }\n\n }\n }\n\n if(u1_field_pic_flag)\n {\n        ps_dec->u2_prv_frame_num = u2_frame_num;\n }\n\n if(ps_cur_slice->u1_mmco_equalto5)\n {\n        WORD32 i4_temp_poc;\n        WORD32 i4_top_field_order_poc, i4_bot_field_order_poc;\n\n if(!ps_cur_slice->u1_field_pic_flag) // or a complementary field pair\n {\n            i4_top_field_order_poc = ps_dec->ps_cur_pic->i4_top_field_order_cnt;\n            i4_bot_field_order_poc =\n                            ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;\n            i4_temp_poc = MIN(i4_top_field_order_poc,\n                                     i4_bot_field_order_poc);\n }\n else if(!ps_cur_slice->u1_bottom_field_flag)\n            i4_temp_poc = ps_dec->ps_cur_pic->i4_top_field_order_cnt;\n else\n            i4_temp_poc = ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;\n\n        ps_dec->ps_cur_pic->i4_top_field_order_cnt = i4_temp_poc\n - ps_dec->ps_cur_pic->i4_top_field_order_cnt;\n        ps_dec->ps_cur_pic->i4_bottom_field_order_cnt = i4_temp_poc\n - ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;\n        ps_dec->ps_cur_pic->i4_poc = i4_temp_poc;\n        ps_dec->ps_cur_pic->i4_avg_poc = i4_temp_poc;\n }\n if(ps_dec->u4_first_slice_in_pic == 2)\n {\n        ret = ih264d_decode_pic_order_cnt(u1_is_idr_slice, u2_frame_num,\n &ps_dec->s_prev_pic_poc,\n &s_tmp_poc, ps_cur_slice, ps_pps,\n                                          u1_nal_ref_idc,\n                                          u1_bottom_field_flag,\n                                          u1_field_pic_flag, &i4_poc);\n if(ret != OK)\n return ret;\n /* Display seq no calculations */\n if(i4_poc >= ps_dec->i4_max_poc)\n            ps_dec->i4_max_poc = i4_poc;\n /* IDR Picture or POC wrap around */\n if(i4_poc == 0)\n {\n            ps_dec->i4_prev_max_display_seq = ps_dec->i4_prev_max_display_seq\n + ps_dec->i4_max_poc\n + ps_dec->u1_max_dec_frame_buffering + 1;\n            ps_dec->i4_max_poc = 0;\n }\n }\n\n /*--------------------------------------------------------------------*/\n /* Copy the values read from the bitstream to the slice header and then*/\n /* If the slice is first slice in picture, then do Start of Picture   */\n /* processing.                                                        */\n /*--------------------------------------------------------------------*/\n    ps_cur_slice->i4_delta_pic_order_cnt[0] = i_delta_poc[0];\n    ps_cur_slice->i4_delta_pic_order_cnt[1] = i_delta_poc[1];\n    ps_cur_slice->u4_idr_pic_id = u4_idr_pic_id;\n    ps_cur_slice->u2_first_mb_in_slice = u2_first_mb_in_slice;\n    ps_cur_slice->u1_field_pic_flag = u1_field_pic_flag;\n    ps_cur_slice->u1_bottom_field_flag = u1_bottom_field_flag;\n    ps_cur_slice->u1_slice_type = u1_slice_type;\n    ps_cur_slice->i4_pic_order_cnt_lsb = s_tmp_poc.i4_pic_order_cnt_lsb;\n\n    ps_cur_slice->u1_nal_unit_type = u1_nal_unit_type;\n    ps_cur_slice->u1_redundant_pic_cnt = u1_redundant_pic_cnt;\n    ps_cur_slice->u1_nal_ref_idc = u1_nal_ref_idc;\n    ps_cur_slice->u1_pic_order_cnt_type = u1_pic_order_cnt_type;\n\n if(ps_seq->u1_frame_mbs_only_flag)\n        ps_cur_slice->u1_direct_8x8_inference_flag =\n                        ps_seq->u1_direct_8x8_inference_flag;\n else\n        ps_cur_slice->u1_direct_8x8_inference_flag = 1;\n\n if(u1_slice_type == B_SLICE)\n {\n        ps_cur_slice->u1_direct_spatial_mv_pred_flag = ih264d_get_bit_h264(\n                        ps_bitstrm);\n        COPYTHECONTEXT(\"SH: direct_spatial_mv_pred_flag\",\n                        ps_cur_slice->u1_direct_spatial_mv_pred_flag);\n\n if(ps_cur_slice->u1_direct_spatial_mv_pred_flag)\n            ps_cur_slice->pf_decodeDirect = ih264d_decode_spatial_direct;\n else\n            ps_cur_slice->pf_decodeDirect = ih264d_decode_temporal_direct;\n if(!((ps_pps->ps_sps->u1_mb_aff_flag) && (!u1_field_pic_flag)))\n            ps_dec->pf_mvpred = ih264d_mvpred_nonmbaffB;\n }\n else\n {\n if(!((ps_pps->ps_sps->u1_mb_aff_flag) && (!u1_field_pic_flag)))\n            ps_dec->pf_mvpred = ih264d_mvpred_nonmbaff;\n }\n\n if(ps_dec->u4_first_slice_in_pic == 2)\n {\n if(u2_first_mb_in_slice == 0)\n {\n            ret = ih264d_start_of_pic(ps_dec, i4_poc, &s_tmp_poc, u2_frame_num, ps_pps);\n if(ret != OK)\n return ret;\n }\n\n        ps_dec->u4_output_present = 0;\n\n {\n            ih264d_get_next_display_field(ps_dec,\n                                          ps_dec->ps_out_buffer,\n &(ps_dec->s_disp_op));\n /* If error code is non-zero then there is no buffer available for display,\n             hence avoid format conversion */\n\n if(0 != ps_dec->s_disp_op.u4_error_code)\n {\n                ps_dec->u4_fmt_conv_cur_row = ps_dec->s_disp_frame_info.u4_y_ht;\n }\n else\n                ps_dec->u4_output_present = 1;\n }\n if(ps_dec->u1_separate_parse == 1)\n {\n if(ps_dec->u4_dec_thread_created == 0)\n {\n                ithread_create(ps_dec->pv_dec_thread_handle, NULL,\n (void *)ih264d_decode_picture_thread,\n (void *)ps_dec);\n\n                ps_dec->u4_dec_thread_created = 1;\n }\n\n if((ps_dec->u4_num_cores == 3) &&\n ((ps_dec->u4_app_disable_deblk_frm == 0) || ps_dec->i1_recon_in_thread3_flag)\n && (ps_dec->u4_bs_deblk_thread_created == 0))\n {\n                ps_dec->u4_start_recon_deblk = 0;\n                ithread_create(ps_dec->pv_bs_deblk_thread_handle, NULL,\n (void *)ih264d_recon_deblk_thread,\n (void *)ps_dec);\n                ps_dec->u4_bs_deblk_thread_created = 1;\n }\n }\n\n }\n\n /* INITIALIZATION of fn ptrs for MC and formMbPartInfo functions */\n {\n        UWORD8 uc_nofield_nombaff;\n\n\n\n        uc_nofield_nombaff = ((ps_dec->ps_cur_slice->u1_field_pic_flag == 0)\n && (ps_dec->ps_cur_slice->u1_mbaff_frame_flag == 0)\n && (u1_slice_type != B_SLICE)\n && (ps_dec->ps_cur_pps->u1_wted_pred_flag == 0));\n\n /* Initialise MC and formMbPartInfo fn ptrs one time based on profile_idc */\n\n if(uc_nofield_nombaff)\n {\n            ps_dec->p_form_mb_part_info = ih264d_form_mb_part_info_bp;\n            ps_dec->p_motion_compensate = ih264d_motion_compensate_bp;\n }\n else\n {\n            ps_dec->p_form_mb_part_info = ih264d_form_mb_part_info_mp;\n            ps_dec->p_motion_compensate = ih264d_motion_compensate_mp;\n }\n\n\n }\n\n /*\n     * Decide whether to decode the current picture or not\n     */\n {\n dec_err_status_t * ps_err = ps_dec->ps_dec_err_status;\n if(ps_err->u4_frm_sei_sync == u2_frame_num)\n {\n            ps_err->u1_err_flag = ACCEPT_ALL_PICS;\n            ps_err->u4_frm_sei_sync = SYNC_FRM_DEFAULT;\n }\n        ps_err->u4_cur_frm = u2_frame_num;\n }\n\n /* Decision for decoding if the picture is to be skipped */\n {\n        WORD32 i4_skip_b_pic, i4_skip_p_pic;\n\n        i4_skip_b_pic = (ps_dec->u4_skip_frm_mask & B_SLC_BIT)\n && (B_SLICE == u1_slice_type) && (0 == u1_nal_ref_idc);\n\n        i4_skip_p_pic = (ps_dec->u4_skip_frm_mask & P_SLC_BIT)\n && (P_SLICE == u1_slice_type) && (0 == u1_nal_ref_idc);\n\n /**************************************************************/\n /* Skip the B picture if skip mask is set for B picture and   */\n /* Current B picture is a non reference B picture or there is */\n /* no user for reference B picture                            */\n /**************************************************************/\n if(i4_skip_b_pic)\n {\n            ps_dec->ps_cur_pic->u4_pack_slc_typ |= B_SLC_BIT;\n /* Don't decode the picture in SKIP-B mode if that picture is B */\n /* and also it is not to be used as a reference picture         */\n            ps_dec->u1_last_pic_not_decoded = 1;\n\n return OK;\n }\n /**************************************************************/\n /* Skip the P picture if skip mask is set for P picture and   */\n /* Current P picture is a non reference P picture or there is */\n /* no user for reference P picture                            */\n /**************************************************************/\n if(i4_skip_p_pic)\n {\n            ps_dec->ps_cur_pic->u4_pack_slc_typ |= P_SLC_BIT;\n /* Don't decode the picture in SKIP-P mode if that picture is P */\n /* and also it is not to be used as a reference picture         */\n            ps_dec->u1_last_pic_not_decoded = 1;\n\n return OK;\n }\n }\n\n {\n        UWORD16 u2_mb_x, u2_mb_y;\n\n        ps_dec->i4_submb_ofst = ((u2_first_mb_in_slice\n << ps_cur_slice->u1_mbaff_frame_flag) * SUB_BLK_SIZE)\n - SUB_BLK_SIZE;\n if(u2_first_mb_in_slice)\n {\n            UWORD8 u1_mb_aff;\n            UWORD8 u1_field_pic;\n            UWORD16 u2_frm_wd_in_mbs;\n            u2_frm_wd_in_mbs = ps_seq->u2_frm_wd_in_mbs;\n            u1_mb_aff = ps_cur_slice->u1_mbaff_frame_flag;\n            u1_field_pic = ps_cur_slice->u1_field_pic_flag;\n\n {\n                UWORD32 x_offset;\n                UWORD32 y_offset;\n                UWORD32 u4_frame_stride;\n tfr_ctxt_t *ps_trns_addr; // = &ps_dec->s_tran_addrecon_parse;\n\n if(ps_dec->u1_separate_parse)\n {\n                    ps_trns_addr = &ps_dec->s_tran_addrecon_parse;\n }\n else\n {\n                    ps_trns_addr = &ps_dec->s_tran_addrecon;\n }\n                u2_mb_x = MOD(u2_first_mb_in_slice, u2_frm_wd_in_mbs);\n                u2_mb_y = DIV(u2_first_mb_in_slice, u2_frm_wd_in_mbs);\n\n                u2_mb_y <<= u1_mb_aff;\n\n if((u2_mb_x > u2_frm_wd_in_mbs - 1)\n || (u2_mb_y > ps_dec->u2_frm_ht_in_mbs - 1))\n {\n return ERROR_CORRUPTED_SLICE;\n }\n\n                u4_frame_stride = ps_dec->u2_frm_wd_y << u1_field_pic;\n                x_offset = u2_mb_x << 4;\n                y_offset = (u2_mb_y * u4_frame_stride) << 4;\n\n                ps_trns_addr->pu1_dest_y = ps_dec->s_cur_pic.pu1_buf1 + x_offset\n + y_offset;\n\n                u4_frame_stride = ps_dec->u2_frm_wd_uv << u1_field_pic;\n                x_offset >>= 1;\n                y_offset = (u2_mb_y * u4_frame_stride) << 3;\n\n                x_offset *= YUV420SP_FACTOR;\n\n                ps_trns_addr->pu1_dest_u = ps_dec->s_cur_pic.pu1_buf2 + x_offset\n + y_offset;\n                ps_trns_addr->pu1_dest_v = ps_dec->s_cur_pic.pu1_buf3 + x_offset\n + y_offset;\n\n                ps_trns_addr->pu1_mb_y = ps_trns_addr->pu1_dest_y;\n                ps_trns_addr->pu1_mb_u = ps_trns_addr->pu1_dest_u;\n                ps_trns_addr->pu1_mb_v = ps_trns_addr->pu1_dest_v;\n\n\n if(ps_dec->u1_separate_parse == 1)\n {\n                    ps_dec->ps_deblk_mbn = ps_dec->ps_deblk_pic\n + (u2_first_mb_in_slice << u1_mb_aff);\n }\n else\n {\n                        ps_dec->ps_deblk_mbn = ps_dec->ps_deblk_pic\n + (u2_first_mb_in_slice << u1_mb_aff);\n }\n\n                ps_dec->u2_cur_mb_addr = (u2_first_mb_in_slice << u1_mb_aff);\n\n                ps_dec->ps_mv_cur = ps_dec->s_cur_pic.ps_mv\n + ((u2_first_mb_in_slice << u1_mb_aff) << 4);\n }\n }\n else\n {\n tfr_ctxt_t *ps_trns_addr;\n\n if(ps_dec->u1_separate_parse)\n {\n                ps_trns_addr = &ps_dec->s_tran_addrecon_parse;\n }\n else\n {\n                ps_trns_addr = &ps_dec->s_tran_addrecon;\n }\n\n            u2_mb_x = 0xffff;\n            u2_mb_y = 0;\n            ps_dec->u2_cur_mb_addr = 0;\n            ps_dec->ps_deblk_mbn = ps_dec->ps_deblk_pic;\n            ps_dec->ps_mv_cur = ps_dec->s_cur_pic.ps_mv;\n            ps_trns_addr->pu1_dest_y = ps_dec->s_cur_pic.pu1_buf1;\n            ps_trns_addr->pu1_dest_u = ps_dec->s_cur_pic.pu1_buf2;\n            ps_trns_addr->pu1_dest_v = ps_dec->s_cur_pic.pu1_buf3;\n\n            ps_trns_addr->pu1_mb_y = ps_trns_addr->pu1_dest_y;\n            ps_trns_addr->pu1_mb_u = ps_trns_addr->pu1_dest_u;\n            ps_trns_addr->pu1_mb_v = ps_trns_addr->pu1_dest_v;\n\n }\n\n        ps_dec->ps_part = ps_dec->ps_parse_part_params;\n\n        ps_dec->u2_mbx =\n (MOD(u2_first_mb_in_slice - 1, ps_seq->u2_frm_wd_in_mbs));\n        ps_dec->u2_mby =\n (DIV(u2_first_mb_in_slice - 1, ps_seq->u2_frm_wd_in_mbs));\n        ps_dec->u2_mby <<= ps_cur_slice->u1_mbaff_frame_flag;\n        ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;\n        ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;\n }\n\n /* RBSP stop bit is used for CABAC decoding*/\n    ps_bitstrm->u4_max_ofst += ps_dec->ps_cur_pps->u1_entropy_coding_mode;\n\n    ps_dec->u1_B = (u1_slice_type == B_SLICE);\n    ps_dec->u4_next_mb_skip = 0;\n\n    ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice =\n                    ps_dec->ps_cur_slice->u2_first_mb_in_slice;\n    ps_dec->ps_parse_cur_slice->slice_type =\n                    ps_dec->ps_cur_slice->u1_slice_type;\n\n\n    ps_dec->u4_start_recon_deblk = 1;\n {\n        WORD32 num_entries;\n        WORD32 size;\n        UWORD8 *pu1_buf;\n\n        num_entries = MIN(MAX_FRAMES, ps_dec->u4_num_ref_frames_at_init);\n        num_entries = 2 * ((2 * num_entries) + 1);\n\n        size = num_entries * sizeof(void *);\n        size += PAD_MAP_IDX_POC * sizeof(void *);\n\n        pu1_buf = (UWORD8 *)ps_dec->pv_map_ref_idx_to_poc_buf;\n        pu1_buf += size * ps_dec->u2_cur_slice_num;\n        ps_dec->ps_parse_cur_slice->ppv_map_ref_idx_to_poc = ( void *)pu1_buf;\n }\n\n if(ps_dec->u1_separate_parse)\n {\n        ps_dec->ps_parse_cur_slice->pv_tu_coeff_data_start = ps_dec->pv_parse_tu_coeff_data;\n }\n else\n {\n        ps_dec->pv_proc_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;\n }\n\n if(u1_slice_type == I_SLICE)\n {\n        ps_dec->ps_cur_pic->u4_pack_slc_typ |= I_SLC_BIT;\n\n        ret = ih264d_parse_islice(ps_dec, u2_first_mb_in_slice);\n\n if(ps_dec->i4_pic_type != B_SLICE && ps_dec->i4_pic_type != P_SLICE)\n            ps_dec->i4_pic_type = I_SLICE;\n\n }\n else if(u1_slice_type == P_SLICE)\n {\n        ps_dec->ps_cur_pic->u4_pack_slc_typ |= P_SLC_BIT;\n        ret = ih264d_parse_pslice(ps_dec, u2_first_mb_in_slice);\n        ps_dec->u1_pr_sl_type = u1_slice_type;\n if(ps_dec->i4_pic_type != B_SLICE)\n            ps_dec->i4_pic_type = P_SLICE;\n }\n else if(u1_slice_type == B_SLICE)\n {\n        ps_dec->ps_cur_pic->u4_pack_slc_typ |= B_SLC_BIT;\n        ret = ih264d_parse_bslice(ps_dec, u2_first_mb_in_slice);\n        ps_dec->u1_pr_sl_type = u1_slice_type;\n        ps_dec->i4_pic_type = B_SLICE;\n }\n else\n return ERROR_INV_SLC_TYPE_T;\n\n if(ps_dec->u1_slice_header_done)\n {\n /* set to zero to indicate a valid slice has been decoded */\n /* first slice header successfully decoded */\n        ps_dec->u4_first_slice_in_pic = 0;\n        ps_dec->u1_first_slice_in_stream = 0;\n }\n\n if(ret != OK)\n return ret;\n\n /* storing last Mb X and MbY of the slice */\n    ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;\n    ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;\n\n /* End of Picture detection */\n\n if(ps_dec->u2_total_mbs_coded >= (ps_seq->u2_max_mb_addr + 1))\n {\n        ps_dec->u1_pic_decode_done = 1;\n\n }\n\n {\n dec_err_status_t * ps_err = ps_dec->ps_dec_err_status;\n if((ps_err->u1_err_flag & REJECT_PB_PICS)\n && (ps_err->u1_cur_pic_type == PIC_TYPE_I))\n {\n            ps_err->u1_err_flag = ACCEPT_ALL_PICS;\n }\n }\n\n    PRINT_BIN_BIT_RATIO(ps_dec)\n\n return ret;\n}\n", "target": 1, "idx": 188066}
{"func": "int perf_event_overflow(struct perf_event *event, int nmi,\n \t\t\t  struct perf_sample_data *data,\n \t\t\t  struct pt_regs *regs)\n {\n\treturn __perf_event_overflow(event, nmi, 1, data, regs);\n }\n", "target": 1, "idx": 179005}
{"func": "int sc_pkcs15emu_sc_hsm_get_public_key(struct sc_context *ctx, sc_cvc_t *cvc, struct sc_pkcs15_pubkey *pubkey)\n{\n\tif (cvc->publicPoint && cvc->publicPointlen) {\n\t\treturn sc_pkcs15emu_sc_hsm_get_ec_public_key(ctx, cvc, pubkey);\n\t} else {\n\t\treturn sc_pkcs15emu_sc_hsm_get_rsa_public_key(ctx, cvc, pubkey);\n\t}\n}\n", "target": 0, "idx": 78813}
{"func": "connection_edge_process_relay_cell(cell_t *cell, circuit_t *circ,\n                                   edge_connection_t *conn,\n                                   crypt_path_t *layer_hint)\n{\n  static int num_seen=0;\n  relay_header_t rh;\n  unsigned domain = layer_hint?LD_APP:LD_EXIT;\n  int reason;\n  int optimistic_data = 0; /* Set to 1 if we receive data on a stream\n                            * that's in the EXIT_CONN_STATE_RESOLVING\n                            * or EXIT_CONN_STATE_CONNECTING states. */\n\n  tor_assert(cell);\n  tor_assert(circ);\n\n  relay_header_unpack(&rh, cell->payload);\n  num_seen++;\n  log_debug(domain, \"Now seen %d relay cells here (command %d, stream %d).\",\n            num_seen, rh.command, rh.stream_id);\n\n  if (rh.length > RELAY_PAYLOAD_SIZE) {\n    log_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n           \"Relay cell length field too long. Closing circuit.\");\n    return - END_CIRC_REASON_TORPROTOCOL;\n  }\n\n  if (rh.stream_id == 0) {\n    switch (rh.command) {\n      case RELAY_COMMAND_BEGIN:\n      case RELAY_COMMAND_CONNECTED:\n      case RELAY_COMMAND_DATA:\n      case RELAY_COMMAND_END:\n      case RELAY_COMMAND_RESOLVE:\n      case RELAY_COMMAND_RESOLVED:\n      case RELAY_COMMAND_BEGIN_DIR:\n        log_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL, \"Relay command %d with zero \"\n               \"stream_id. Dropping.\", (int)rh.command);\n        return 0;\n      default:\n        ;\n    }\n  }\n\n  /* either conn is NULL, in which case we've got a control cell, or else\n   * conn points to the recognized stream. */\n\n  if (conn && !connection_state_is_open(TO_CONN(conn))) {\n    if (conn->base_.type == CONN_TYPE_EXIT &&\n        (conn->base_.state == EXIT_CONN_STATE_CONNECTING ||\n         conn->base_.state == EXIT_CONN_STATE_RESOLVING) &&\n        rh.command == RELAY_COMMAND_DATA) {\n      /* Allow DATA cells to be delivered to an exit node in state\n       * EXIT_CONN_STATE_CONNECTING or EXIT_CONN_STATE_RESOLVING.\n       * This speeds up HTTP, for example. */\n      optimistic_data = 1;\n    } else {\n      return connection_edge_process_relay_cell_not_open(\n               &rh, cell, circ, conn, layer_hint);\n    }\n  }\n\n  switch (rh.command) {\n    case RELAY_COMMAND_DROP:\n      return 0;\n    case RELAY_COMMAND_BEGIN:\n    case RELAY_COMMAND_BEGIN_DIR:\n      if (layer_hint &&\n          circ->purpose != CIRCUIT_PURPOSE_S_REND_JOINED) {\n        log_fn(LOG_PROTOCOL_WARN, LD_APP,\n               \"Relay begin request unsupported at AP. Dropping.\");\n        return 0;\n      }\n      if (circ->purpose == CIRCUIT_PURPOSE_S_REND_JOINED &&\n          layer_hint != TO_ORIGIN_CIRCUIT(circ)->cpath->prev) {\n        log_fn(LOG_PROTOCOL_WARN, LD_APP,\n               \"Relay begin request to Hidden Service \"\n               \"from intermediary node. Dropping.\");\n        return 0;\n      }\n      if (conn) {\n        log_fn(LOG_PROTOCOL_WARN, domain,\n                \"Begin cell for known stream. Dropping.\");\n         return 0;\n       }\n      if (rh.command == RELAY_COMMAND_BEGIN_DIR) {\n         /* Assign this circuit and its app-ward OR connection a unique ID,\n          * so that we can measure download times. The local edge and dir\n          * connection will be assigned the same ID when they are created\n         * and linked. */\n        static uint64_t next_id = 0;\n        circ->dirreq_id = ++next_id;\n        TO_OR_CIRCUIT(circ)->p_chan->dirreq_id = circ->dirreq_id;\n      }\n\n      return connection_exit_begin_conn(cell, circ);\n    case RELAY_COMMAND_DATA:\n      ++stats_n_data_cells_received;\n      if (( layer_hint && --layer_hint->deliver_window < 0) ||\n          (!layer_hint && --circ->deliver_window < 0)) {\n        log_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n               \"(relay data) circ deliver_window below 0. Killing.\");\n        if (conn) {\n          /* XXXX Do we actually need to do this?  Will killing the circuit\n           * not send an END and mark the stream for close as appropriate? */\n          connection_edge_end(conn, END_STREAM_REASON_TORPROTOCOL);\n          connection_mark_for_close(TO_CONN(conn));\n        }\n        return -END_CIRC_REASON_TORPROTOCOL;\n      }\n      log_debug(domain,\"circ deliver_window now %d.\", layer_hint ?\n                layer_hint->deliver_window : circ->deliver_window);\n\n      circuit_consider_sending_sendme(circ, layer_hint);\n\n      if (!conn) {\n        log_info(domain,\"data cell dropped, unknown stream (streamid %d).\",\n                 rh.stream_id);\n        return 0;\n      }\n\n      if (--conn->deliver_window < 0) { /* is it below 0 after decrement? */\n        log_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n               \"(relay data) conn deliver_window below 0. Killing.\");\n        return -END_CIRC_REASON_TORPROTOCOL;\n      }\n\n      stats_n_data_bytes_received += rh.length;\n      connection_write_to_buf((char*)(cell->payload + RELAY_HEADER_SIZE),\n                              rh.length, TO_CONN(conn));\n\n      if (!optimistic_data) {\n        /* Only send a SENDME if we're not getting optimistic data; otherwise\n         * a SENDME could arrive before the CONNECTED.\n         */\n        connection_edge_consider_sending_sendme(conn);\n      }\n\n      return 0;\n    case RELAY_COMMAND_END:\n      reason = rh.length > 0 ?\n        get_uint8(cell->payload+RELAY_HEADER_SIZE) : END_STREAM_REASON_MISC;\n      if (!conn) {\n        log_info(domain,\"end cell (%s) dropped, unknown stream.\",\n                 stream_end_reason_to_string(reason));\n        return 0;\n      }\n/* XXX add to this log_fn the exit node's nickname? */\n      log_info(domain,TOR_SOCKET_T_FORMAT\": end cell (%s) for stream %d. \"\n               \"Removing stream.\",\n               conn->base_.s,\n               stream_end_reason_to_string(reason),\n               conn->stream_id);\n      if (conn->base_.type == CONN_TYPE_AP) {\n        entry_connection_t *entry_conn = EDGE_TO_ENTRY_CONN(conn);\n        if (entry_conn->socks_request &&\n            !entry_conn->socks_request->has_finished)\n          log_warn(LD_BUG,\n                   \"open stream hasn't sent socks answer yet? Closing.\");\n      }\n      /* We just *got* an end; no reason to send one. */\n      conn->edge_has_sent_end = 1;\n      if (!conn->end_reason)\n        conn->end_reason = reason | END_STREAM_REASON_FLAG_REMOTE;\n      if (!conn->base_.marked_for_close) {\n        /* only mark it if not already marked. it's possible to\n         * get the 'end' right around when the client hangs up on us. */\n        connection_mark_and_flush(TO_CONN(conn));\n      }\n      return 0;\n    case RELAY_COMMAND_EXTEND:\n    case RELAY_COMMAND_EXTEND2: {\n      static uint64_t total_n_extend=0, total_nonearly=0;\n      total_n_extend++;\n      if (rh.stream_id) {\n        log_fn(LOG_PROTOCOL_WARN, domain,\n               \"'extend' cell received for non-zero stream. Dropping.\");\n        return 0;\n      }\n      if (cell->command != CELL_RELAY_EARLY &&\n          !networkstatus_get_param(NULL,\"AllowNonearlyExtend\",0,0,1)) {\n#define EARLY_WARNING_INTERVAL 3600\n        static ratelim_t early_warning_limit =\n          RATELIM_INIT(EARLY_WARNING_INTERVAL);\n        char *m;\n        if (cell->command == CELL_RELAY) {\n          ++total_nonearly;\n          if ((m = rate_limit_log(&early_warning_limit, approx_time()))) {\n            double percentage = ((double)total_nonearly)/total_n_extend;\n            percentage *= 100;\n            log_fn(LOG_PROTOCOL_WARN, domain, \"EXTEND cell received, \"\n                   \"but not via RELAY_EARLY. Dropping.%s\", m);\n            log_fn(LOG_PROTOCOL_WARN, domain, \"  (We have dropped %.02f%% of \"\n                   \"all EXTEND cells for this reason)\", percentage);\n            tor_free(m);\n          }\n        } else {\n          log_fn(LOG_WARN, domain,\n                 \"EXTEND cell received, in a cell with type %d! Dropping.\",\n                 cell->command);\n        }\n        return 0;\n      }\n      return circuit_extend(cell, circ);\n    }\n    case RELAY_COMMAND_EXTENDED:\n    case RELAY_COMMAND_EXTENDED2:\n      if (!layer_hint) {\n        log_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n               \"'extended' unsupported at non-origin. Dropping.\");\n        return 0;\n      }\n      log_debug(domain,\"Got an extended cell! Yay.\");\n      {\n        extended_cell_t extended_cell;\n        if (extended_cell_parse(&extended_cell, rh.command,\n                        (const uint8_t*)cell->payload+RELAY_HEADER_SIZE,\n                        rh.length)<0) {\n          log_warn(LD_PROTOCOL,\n                   \"Can't parse EXTENDED cell; killing circuit.\");\n          return -END_CIRC_REASON_TORPROTOCOL;\n        }\n        if ((reason = circuit_finish_handshake(TO_ORIGIN_CIRCUIT(circ),\n                                         &extended_cell.created_cell)) < 0) {\n          log_warn(domain,\"circuit_finish_handshake failed.\");\n          return reason;\n        }\n      }\n      if ((reason=circuit_send_next_onion_skin(TO_ORIGIN_CIRCUIT(circ)))<0) {\n        log_info(domain,\"circuit_send_next_onion_skin() failed.\");\n        return reason;\n      }\n      return 0;\n    case RELAY_COMMAND_TRUNCATE:\n      if (layer_hint) {\n        log_fn(LOG_PROTOCOL_WARN, LD_APP,\n               \"'truncate' unsupported at origin. Dropping.\");\n        return 0;\n      }\n      if (circ->n_hop) {\n        if (circ->n_chan)\n          log_warn(LD_BUG, \"n_chan and n_hop set on the same circuit!\");\n        extend_info_free(circ->n_hop);\n        circ->n_hop = NULL;\n        tor_free(circ->n_chan_create_cell);\n        circuit_set_state(circ, CIRCUIT_STATE_OPEN);\n      }\n      if (circ->n_chan) {\n        uint8_t trunc_reason = get_uint8(cell->payload + RELAY_HEADER_SIZE);\n        circuit_clear_cell_queue(circ, circ->n_chan);\n        channel_send_destroy(circ->n_circ_id, circ->n_chan,\n                             trunc_reason);\n        circuit_set_n_circid_chan(circ, 0, NULL);\n      }\n      log_debug(LD_EXIT, \"Processed 'truncate', replying.\");\n      {\n        char payload[1];\n        payload[0] = (char)END_CIRC_REASON_REQUESTED;\n        relay_send_command_from_edge(0, circ, RELAY_COMMAND_TRUNCATED,\n                                     payload, sizeof(payload), NULL);\n      }\n      return 0;\n    case RELAY_COMMAND_TRUNCATED:\n      if (!layer_hint) {\n        log_fn(LOG_PROTOCOL_WARN, LD_EXIT,\n               \"'truncated' unsupported at non-origin. Dropping.\");\n        return 0;\n      }\n      circuit_truncated(TO_ORIGIN_CIRCUIT(circ), layer_hint,\n                        get_uint8(cell->payload + RELAY_HEADER_SIZE));\n      return 0;\n    case RELAY_COMMAND_CONNECTED:\n      if (conn) {\n        log_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n               \"'connected' unsupported while open. Closing circ.\");\n        return -END_CIRC_REASON_TORPROTOCOL;\n      }\n      log_info(domain,\n               \"'connected' received, no conn attached anymore. Ignoring.\");\n      return 0;\n    case RELAY_COMMAND_SENDME:\n      if (!rh.stream_id) {\n        if (layer_hint) {\n          if (layer_hint->package_window + CIRCWINDOW_INCREMENT >\n                CIRCWINDOW_START_MAX) {\n            log_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n                   \"Unexpected sendme cell from exit relay. \"\n                   \"Closing circ.\");\n            return -END_CIRC_REASON_TORPROTOCOL;\n          }\n          layer_hint->package_window += CIRCWINDOW_INCREMENT;\n          log_debug(LD_APP,\"circ-level sendme at origin, packagewindow %d.\",\n                    layer_hint->package_window);\n          circuit_resume_edge_reading(circ, layer_hint);\n        } else {\n          if (circ->package_window + CIRCWINDOW_INCREMENT >\n                CIRCWINDOW_START_MAX) {\n            log_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n                   \"Unexpected sendme cell from client. \"\n                   \"Closing circ (window %d).\",\n                   circ->package_window);\n            return -END_CIRC_REASON_TORPROTOCOL;\n          }\n          circ->package_window += CIRCWINDOW_INCREMENT;\n          log_debug(LD_APP,\n                    \"circ-level sendme at non-origin, packagewindow %d.\",\n                    circ->package_window);\n          circuit_resume_edge_reading(circ, layer_hint);\n        }\n        return 0;\n      }\n      if (!conn) {\n        log_info(domain,\"sendme cell dropped, unknown stream (streamid %d).\",\n                 rh.stream_id);\n        return 0;\n      }\n      conn->package_window += STREAMWINDOW_INCREMENT;\n      log_debug(domain,\"stream-level sendme, packagewindow now %d.\",\n                conn->package_window);\n      if (circuit_queue_streams_are_blocked(circ)) {\n        /* Still waiting for queue to flush; don't touch conn */\n        return 0;\n      }\n      connection_start_reading(TO_CONN(conn));\n      /* handle whatever might still be on the inbuf */\n      if (connection_edge_package_raw_inbuf(conn, 1, NULL) < 0) {\n        /* (We already sent an end cell if possible) */\n        connection_mark_for_close(TO_CONN(conn));\n        return 0;\n      }\n      return 0;\n    case RELAY_COMMAND_RESOLVE:\n      if (layer_hint) {\n        log_fn(LOG_PROTOCOL_WARN, LD_APP,\n               \"resolve request unsupported at AP; dropping.\");\n        return 0;\n      } else if (conn) {\n        log_fn(LOG_PROTOCOL_WARN, domain,\n               \"resolve request for known stream; dropping.\");\n        return 0;\n      } else if (circ->purpose != CIRCUIT_PURPOSE_OR) {\n        log_fn(LOG_PROTOCOL_WARN, domain,\n               \"resolve request on circ with purpose %d; dropping\",\n               circ->purpose);\n        return 0;\n      }\n      connection_exit_begin_resolve(cell, TO_OR_CIRCUIT(circ));\n      return 0;\n    case RELAY_COMMAND_RESOLVED:\n      if (conn) {\n        log_fn(LOG_PROTOCOL_WARN, domain,\n               \"'resolved' unsupported while open. Closing circ.\");\n        return -END_CIRC_REASON_TORPROTOCOL;\n      }\n      log_info(domain,\n               \"'resolved' received, no conn attached anymore. Ignoring.\");\n      return 0;\n    case RELAY_COMMAND_ESTABLISH_INTRO:\n    case RELAY_COMMAND_ESTABLISH_RENDEZVOUS:\n    case RELAY_COMMAND_INTRODUCE1:\n    case RELAY_COMMAND_INTRODUCE2:\n    case RELAY_COMMAND_INTRODUCE_ACK:\n    case RELAY_COMMAND_RENDEZVOUS1:\n    case RELAY_COMMAND_RENDEZVOUS2:\n    case RELAY_COMMAND_INTRO_ESTABLISHED:\n    case RELAY_COMMAND_RENDEZVOUS_ESTABLISHED:\n      rend_process_relay_cell(circ, layer_hint,\n                              rh.command, rh.length,\n                              cell->payload+RELAY_HEADER_SIZE);\n      return 0;\n  }\n  log_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n         \"Received unknown relay command %d. Perhaps the other side is using \"\n         \"a newer version of Tor? Dropping.\",\n         rh.command);\n  return 0; /* for forward compatibility, don't kill the circuit */\n}\n", "target": 1, "idx": 181623}
{"func": "static int srpt_build_tskmgmt_rsp(struct srpt_rdma_ch *ch,\n\t\t\t\t  struct srpt_send_ioctx *ioctx,\n\t\t\t\t  u8 rsp_code, u64 tag)\n{\n\tstruct srp_rsp *srp_rsp;\n\tint resp_data_len;\n\tint resp_len;\n\n\tresp_data_len = 4;\n\tresp_len = sizeof(*srp_rsp) + resp_data_len;\n\n\tsrp_rsp = ioctx->ioctx.buf;\n\tBUG_ON(!srp_rsp);\n\tmemset(srp_rsp, 0, sizeof *srp_rsp);\n\n\tsrp_rsp->opcode = SRP_RSP;\n\tsrp_rsp->req_lim_delta =\n\t\tcpu_to_be32(1 + atomic_xchg(&ch->req_lim_delta, 0));\n\tsrp_rsp->tag = tag;\n\n\tsrp_rsp->flags |= SRP_RSP_FLAG_RSPVALID;\n\tsrp_rsp->resp_data_len = cpu_to_be32(resp_data_len);\n\tsrp_rsp->data[3] = rsp_code;\n\n\treturn resp_len;\n}\n", "target": 0, "idx": 50627}
{"func": "void RenderFrameHostImpl::CreateWebSocket(\n    network::mojom::WebSocketRequest request) {\n  WebSocketManager::CreateWebSocket(process_->GetID(), routing_id_,\n                                    last_committed_origin_, std::move(request));\n}\n", "target": 0, "idx": 169149}
{"func": "bool Document::NeedsFullLayoutTreeUpdate() const {\n  if (!IsActive() || !View())\n    return false;\n  if (style_engine_->NeedsActiveStyleUpdate())\n    return true;\n  if (style_engine_->NeedsWhitespaceReattachment())\n    return true;\n  if (!use_elements_needing_update_.IsEmpty())\n    return true;\n  if (NeedsStyleRecalc())\n    return true;\n  if (NeedsStyleInvalidation())\n    return true;\n  if (ChildNeedsDistributionRecalc())\n    return true;\n  if (DocumentAnimations::NeedsAnimationTimingUpdate(*this))\n    return true;\n  return false;\n}\n", "target": 0, "idx": 156815}
{"func": "lib_file_open(gs_file_path_ptr  lib_path, const gs_memory_t *mem, i_ctx_t *i_ctx_p,\n                       const char *fname, uint flen, char *buffer, int blen, uint *pclen, ref *pfile)\n{   /* i_ctx_p is NULL running arg (@) files.\n     * lib_path and mem are never NULL\n     */\n    bool starting_arg_file = (i_ctx_p == NULL) ? true : i_ctx_p->starting_arg_file;\n    bool search_with_no_combine = false;\n    bool search_with_combine = false;\n    char fmode[2] = { 'r', 0};\n    gx_io_device *iodev = iodev_default(mem);\n     gs_main_instance *minst = get_minst_from_memory(mem);\n     int code;\n \n     /* when starting arg files (@ files) iodev_default is not yet set */\n     if (iodev == 0)\n         iodev = (gx_io_device *)gx_io_device_table[0];\n       search_with_combine = false;\n    } else {\n       search_with_no_combine = starting_arg_file;\n       search_with_combine = true;\n    }\n", "target": 1, "idx": 178436}
{"func": "static int udp_v6_push_pending_frames(struct sock *sk)\n{\n\tstruct sk_buff *skb;\n\tstruct udphdr *uh;\n\tstruct udp_sock  *up = udp_sk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct flowi6 *fl6 = &inet->cork.fl.u.ip6;\n\tint err = 0;\n\tint is_udplite = IS_UDPLITE(sk);\n\t__wsum csum = 0;\n\n\t/* Grab the skbuff where UDP header space exists. */\n\tif ((skb = skb_peek(&sk->sk_write_queue)) == NULL)\n\t\tgoto out;\n\n\t/*\n\t * Create a UDP header\n\t */\n\tuh = udp_hdr(skb);\n\tuh->source = fl6->fl6_sport;\n\tuh->dest = fl6->fl6_dport;\n\tuh->len = htons(up->len);\n\tuh->check = 0;\n\n\tif (is_udplite)\n\t\tcsum = udplite_csum_outgoing(sk, skb);\n\telse if (skb->ip_summed == CHECKSUM_PARTIAL) { /* UDP hardware csum */\n\t\tudp6_hwcsum_outgoing(sk, skb, &fl6->saddr, &fl6->daddr,\n\t\t\t\t     up->len);\n\t\tgoto send;\n\t} else\n\t\tcsum = udp_csum_outgoing(sk, skb);\n\n\t/* add protocol-dependent pseudo-header */\n\tuh->check = csum_ipv6_magic(&fl6->saddr, &fl6->daddr,\n\t\t\t\t    up->len, fl6->flowi6_proto, csum);\n\tif (uh->check == 0)\n\t\tuh->check = CSUM_MANGLED_0;\n\nsend:\n\terr = ip6_push_pending_frames(sk);\n\tif (err) {\n\t\tif (err == -ENOBUFS && !inet6_sk(sk)->recverr) {\n\t\t\tUDP6_INC_STATS_USER(sock_net(sk),\n\t\t\t\t\t    UDP_MIB_SNDBUFERRORS, is_udplite);\n\t\t\terr = 0;\n\t\t}\n\t} else\n\t\tUDP6_INC_STATS_USER(sock_net(sk),\n\t\t\t\t    UDP_MIB_OUTDATAGRAMS, is_udplite);\nout:\n\tup->len = 0;\n\tup->pending = 0;\n\treturn err;\n}\n", "target": 0, "idx": 22762}
{"func": "  explicit MockInputMethodObserver(ClientChangeVerifier* verifier)\n      : verifier_(verifier) {\n   }\n", "target": 1, "idx": 185558}
{"func": "LONG ValidateSignature(HWND hDlg, const char* path)\n{\n\tLONG r;\n\tWINTRUST_DATA trust_data = { 0 };\n\tWINTRUST_FILE_INFO trust_file = { 0 };\n\tGUID guid_generic_verify =\t// WINTRUST_ACTION_GENERIC_VERIFY_V2\n\t\t{ 0xaac56b, 0xcd44, 0x11d0,{ 0x8c, 0xc2, 0x0, 0xc0, 0x4f, 0xc2, 0x95, 0xee } };\n\tchar *signature_name;\n\tsize_t i, len;\n\n\tsignature_name = GetSignatureName(path);\n\tif (signature_name == NULL) {\n\t\tuprintf(\"PKI: Could not get signature name\");\n\t\tMessageBoxExU(hDlg, lmprintf(MSG_284), lmprintf(MSG_283), MB_OK | MB_ICONERROR | MB_IS_RTL, selected_langid);\n\t\treturn TRUST_E_NOSIGNATURE;\n\t}\n\tfor (i = 0; i < ARRAYSIZE(cert_name); i++) {\n\t\tlen = strlen(cert_name[i]);\n\t\tif (strncmp(signature_name, cert_name[i], len) == 0) {\n\t\t\tif ((len >= strlen(signature_name)) || isspace(signature_name[len]))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (i >= ARRAYSIZE(cert_name)) {\n\t\tuprintf(\"PKI: Signature '%s' is unexpected...\", signature_name);\n\t\tif (MessageBoxExU(hDlg, lmprintf(MSG_285, signature_name), lmprintf(MSG_283),\n\t\t\tMB_YESNO | MB_ICONWARNING | MB_IS_RTL, selected_langid) != IDYES)\n\t\t\treturn TRUST_E_EXPLICIT_DISTRUST;\n\t}\n\n\ttrust_file.cbStruct = sizeof(trust_file);\n\ttrust_file.pcwszFilePath = utf8_to_wchar(path);\n\tif (trust_file.pcwszFilePath == NULL) {\n\t\tuprintf(\"PKI: Unable to convert '%s' to UTF16\", path);\n\t\treturn ERROR_SEVERITY_ERROR | FAC(FACILITY_CERT) | ERROR_NOT_ENOUGH_MEMORY;\n \t}\n \n \ttrust_data.cbStruct = sizeof(trust_data);\n\ttrust_data.dwUIChoice = WTD_UI_ALL;\n \ttrust_data.fdwRevocationChecks = WTD_REVOKE_WHOLECHAIN;\n\ttrust_data.dwProvFlags = WTD_REVOCATION_CHECK_CHAIN | 0x400;\n\ttrust_data.dwUnionChoice = WTD_CHOICE_FILE;\n\ttrust_data.pFile = &trust_file;\n \n \tr = WinVerifyTrust(NULL, &guid_generic_verify, &trust_data);\n \tsafe_free(trust_file.pcwszFilePath);\n \n \treturn r;\n }\n", "target": 1, "idx": 180987}
{"func": "static void clean_verifier_state(struct bpf_verifier_env *env,\n\t\t\t\t struct bpf_verifier_state *st)\n{\n\tint i;\n\n\tif (st->frame[0]->regs[0].live & REG_LIVE_DONE)\n\t\t/* all regs in this state in all frames were already marked */\n\t\treturn;\n\n\tfor (i = 0; i <= st->curframe; i++)\n\t\tclean_func_state(env, st->frame[i]);\n}\n", "target": 0, "idx": 91428}
{"func": "int js_utfptrtoidx(const char *s, const char *p)\n{\n\tRune rune;\n\tint i = 0;\n\twhile (s < p) {\n\t\tif (*(unsigned char *)s < Runeself)\n\t\t\t++s;\n\t\telse\n\t\t\ts += chartorune(&rune, s);\n\t\t++i;\n\t}\n\treturn i;\n}\n", "target": 0, "idx": 90678}
{"func": " init_global_keywords(bool global_active)\n {\n\t/* global definitions mapping */\n\tinstall_keyword_root(\"linkbeat_use_polling\", use_polling_handler, global_active);\n#if HAVE_DECL_CLONE_NEWNET\n\tinstall_keyword_root(\"net_namespace\", &net_namespace_handler, global_active);\n\tinstall_keyword_root(\"namespace_with_ipsets\", &namespace_ipsets_handler, global_active);\n#endif\n\tinstall_keyword_root(\"use_pid_dir\", &use_pid_dir_handler, global_active);\n\tinstall_keyword_root(\"instance\", &instance_handler, global_active);\n\tinstall_keyword_root(\"child_wait_time\", &child_wait_handler, global_active);\n\tinstall_keyword_root(\"global_defs\", NULL, global_active);\n\tinstall_keyword(\"router_id\", &routerid_handler);\n\tinstall_keyword(\"notification_email_from\", &emailfrom_handler);\n\tinstall_keyword(\"smtp_server\", &smtpserver_handler);\n\tinstall_keyword(\"smtp_helo_name\", &smtphelo_handler);\n\tinstall_keyword(\"smtp_connect_timeout\", &smtpto_handler);\n\tinstall_keyword(\"notification_email\", &email_handler);\n\tinstall_keyword(\"smtp_alert\", &smtp_alert_handler);\n#ifdef _WITH_VRRP_\n\tinstall_keyword(\"smtp_alert_vrrp\", &smtp_alert_vrrp_handler);\n#endif\n#ifdef _WITH_LVS_\n\tinstall_keyword(\"smtp_alert_checker\", &smtp_alert_checker_handler);\n#endif\n#ifdef _WITH_VRRP_\n\tinstall_keyword(\"dynamic_interfaces\", &dynamic_interfaces_handler);\n\tinstall_keyword(\"no_email_faults\", &no_email_faults_handler);\n\tinstall_keyword(\"default_interface\", &default_interface_handler);\n#endif\n#ifdef _WITH_LVS_\n\tinstall_keyword(\"lvs_timeouts\", &lvs_timeouts);\n\tinstall_keyword(\"lvs_flush\", &lvs_flush_handler);\n#ifdef _WITH_VRRP_\n\tinstall_keyword(\"lvs_sync_daemon\", &lvs_syncd_handler);\n#endif\n#endif\n#ifdef _WITH_VRRP_\n\tinstall_keyword(\"vrrp_mcast_group4\", &vrrp_mcast_group4_handler);\n\tinstall_keyword(\"vrrp_mcast_group6\", &vrrp_mcast_group6_handler);\n\tinstall_keyword(\"vrrp_garp_master_delay\", &vrrp_garp_delay_handler);\n\tinstall_keyword(\"vrrp_garp_master_repeat\", &vrrp_garp_rep_handler);\n\tinstall_keyword(\"vrrp_garp_master_refresh\", &vrrp_garp_refresh_handler);\n\tinstall_keyword(\"vrrp_garp_master_refresh_repeat\", &vrrp_garp_refresh_rep_handler);\n\tinstall_keyword(\"vrrp_garp_lower_prio_delay\", &vrrp_garp_lower_prio_delay_handler);\n\tinstall_keyword(\"vrrp_garp_lower_prio_repeat\", &vrrp_garp_lower_prio_rep_handler);\n\tinstall_keyword(\"vrrp_garp_interval\", &vrrp_garp_interval_handler);\n\tinstall_keyword(\"vrrp_gna_interval\", &vrrp_gna_interval_handler);\n\tinstall_keyword(\"vrrp_lower_prio_no_advert\", &vrrp_lower_prio_no_advert_handler);\n\tinstall_keyword(\"vrrp_higher_prio_send_advert\", &vrrp_higher_prio_send_advert_handler);\n\tinstall_keyword(\"vrrp_version\", &vrrp_version_handler);\n\tinstall_keyword(\"vrrp_iptables\", &vrrp_iptables_handler);\n#ifdef _HAVE_LIBIPSET_\n\tinstall_keyword(\"vrrp_ipsets\", &vrrp_ipsets_handler);\n#endif\n\tinstall_keyword(\"vrrp_check_unicast_src\", &vrrp_check_unicast_src_handler);\n\tinstall_keyword(\"vrrp_skip_check_adv_addr\", &vrrp_check_adv_addr_handler);\n\tinstall_keyword(\"vrrp_strict\", &vrrp_strict_handler);\n\tinstall_keyword(\"vrrp_priority\", &vrrp_prio_handler);\n\tinstall_keyword(\"vrrp_no_swap\", &vrrp_no_swap_handler);\n#ifdef _HAVE_SCHED_RT_\n\tinstall_keyword(\"vrrp_rt_priority\", &vrrp_rt_priority_handler);\n#if HAVE_DECL_RLIMIT_RTTIME == 1\n\tinstall_keyword(\"vrrp_rlimit_rtime\", &vrrp_rt_rlimit_handler);\n#endif\n#endif\n#endif\n\tinstall_keyword(\"notify_fifo\", &global_notify_fifo);\n\tinstall_keyword(\"notify_fifo_script\", &global_notify_fifo_script);\n#ifdef _WITH_VRRP_\n\tinstall_keyword(\"vrrp_notify_fifo\", &vrrp_notify_fifo);\n\tinstall_keyword(\"vrrp_notify_fifo_script\", &vrrp_notify_fifo_script);\n#endif\n#ifdef _WITH_LVS_\n\tinstall_keyword(\"lvs_notify_fifo\", &lvs_notify_fifo);\n\tinstall_keyword(\"lvs_notify_fifo_script\", &lvs_notify_fifo_script);\n\tinstall_keyword(\"checker_priority\", &checker_prio_handler);\n\tinstall_keyword(\"checker_no_swap\", &checker_no_swap_handler);\n#ifdef _HAVE_SCHED_RT_\n\tinstall_keyword(\"checker_rt_priority\", &checker_rt_priority_handler);\n#if HAVE_DECL_RLIMIT_RTTIME == 1\n\tinstall_keyword(\"checker_rlimit_rtime\", &checker_rt_rlimit_handler);\n#endif\n#endif\n#endif\n#ifdef _WITH_BFD_\n\tinstall_keyword(\"bfd_priority\", &bfd_prio_handler);\n\tinstall_keyword(\"bfd_no_swap\", &bfd_no_swap_handler);\n#ifdef _HAVE_SCHED_RT_\n\tinstall_keyword(\"bfd_rt_priority\", &bfd_rt_priority_handler);\n#if HAVE_DECL_RLIMIT_RTTIME == 1\n\tinstall_keyword(\"bfd_rlimit_rtime\", &bfd_rt_rlimit_handler);\n#endif\n#endif\n#endif\n#ifdef _WITH_SNMP_\n\tinstall_keyword(\"snmp_socket\", &snmp_socket_handler);\n\tinstall_keyword(\"enable_traps\", &trap_handler);\n#ifdef _WITH_SNMP_VRRP_\n\tinstall_keyword(\"enable_snmp_vrrp\", &snmp_vrrp_handler);\n\tinstall_keyword(\"enable_snmp_keepalived\", &snmp_vrrp_handler);\t/* Deprecated v2.0.0 */\n#endif\n#ifdef _WITH_SNMP_RFC_\n\tinstall_keyword(\"enable_snmp_rfc\", &snmp_rfc_handler);\n#endif\n#ifdef _WITH_SNMP_RFCV2_\n\tinstall_keyword(\"enable_snmp_rfcv2\", &snmp_rfcv2_handler);\n#endif\n#ifdef _WITH_SNMP_RFCV3_\n\tinstall_keyword(\"enable_snmp_rfcv3\", &snmp_rfcv3_handler);\n#endif\n#ifdef _WITH_SNMP_CHECKER_\n\tinstall_keyword(\"enable_snmp_checker\", &snmp_checker_handler);\n#endif\n#endif\n#ifdef _WITH_DBUS_\n\tinstall_keyword(\"enable_dbus\", &enable_dbus_handler);\n\tinstall_keyword(\"dbus_service_name\", &dbus_service_name_handler);\n#endif\n\tinstall_keyword(\"script_user\", &script_user_handler);\n\tinstall_keyword(\"enable_script_security\", &script_security_handler);\n#ifdef _WITH_VRRP_\n\tinstall_keyword(\"vrrp_netlink_cmd_rcv_bufs\", &vrrp_netlink_cmd_rcv_bufs_handler);\n\tinstall_keyword(\"vrrp_netlink_cmd_rcv_bufs_force\", &vrrp_netlink_cmd_rcv_bufs_force_handler);\n\tinstall_keyword(\"vrrp_netlink_monitor_rcv_bufs\", &vrrp_netlink_monitor_rcv_bufs_handler);\n\tinstall_keyword(\"vrrp_netlink_monitor_rcv_bufs_force\", &vrrp_netlink_monitor_rcv_bufs_force_handler);\n#endif\n#ifdef _WITH_LVS_\n\tinstall_keyword(\"lvs_netlink_cmd_rcv_bufs\", &lvs_netlink_cmd_rcv_bufs_handler);\n\tinstall_keyword(\"lvs_netlink_cmd_rcv_bufs_force\", &lvs_netlink_cmd_rcv_bufs_force_handler);\n\tinstall_keyword(\"lvs_netlink_monitor_rcv_bufs\", &lvs_netlink_monitor_rcv_bufs_handler);\n\tinstall_keyword(\"lvs_netlink_monitor_rcv_bufs_force\", &lvs_netlink_monitor_rcv_bufs_force_handler);\n#endif\n#ifdef _WITH_LVS_\n\tinstall_keyword(\"rs_init_notifies\", &rs_init_notifies_handler);\n\tinstall_keyword(\"no_checker_emails\", &no_checker_emails_handler);\n#endif\n#ifdef _WITH_VRRP_\n \tinstall_keyword(\"vrrp_rx_bufs_policy\", &vrrp_rx_bufs_policy_handler);\n \tinstall_keyword(\"vrrp_rx_bufs_multiplier\", &vrrp_rx_bufs_multiplier_handler);\n #endif\n }\n", "target": 1, "idx": 182153}
{"func": "std::string GenerateUUID() // DCE/RFC 4122\n{\n\tstd::srand((unsigned int)std::time(nullptr));\n\tstd::string uuid = std::string(36, ' ');\n\n\tuuid[8] = '-';\n\tuuid[13] = '-';\n\tuuid[14] = '4'; //M\n\tuuid[18] = '-';\n\tuuid[23] = '-';\n\n\tfor (size_t ii = 0; ii < uuid.size(); ii++)\n\t{\n\t\tif (uuid[ii] == ' ')\n\t\t{\n\t\t\tuuid[ii] = hexCHARS[(ii == 19) ? (8 + (std::rand() & 0x03)) : std::rand() & 0x0F];\n\t\t}\n\t}\n\treturn uuid;\n}\n", "target": 0, "idx": 90914}
{"func": "int main(int argc, char *argv[]) {\n char *fin, *fout;\n FILE *fpin, *fpout;\n uint8_t *inbuf, *outbuf;\n uint8_t *inbuf_u, *outbuf_u;\n uint8_t *inbuf_v, *outbuf_v;\n\n   int f, frames;\n   int width, height, target_width, target_height;\n \n   if (argc < 5) {\n     printf(\"Incorrect parameters:\\n\");\n    usage(argv[0]);\n     return 1;\n   }\n \n  fin = argv[1];\n\n   fout = argv[4];\n   if (!parse_dim(argv[2], &width, &height)) {\n     printf(\"Incorrect parameters: %s\\n\", argv[2]);\n    usage(argv[0]);\n     return 1;\n   }\n   if (!parse_dim(argv[3], &target_width, &target_height)) {\n     printf(\"Incorrect parameters: %s\\n\", argv[3]);\n    usage(argv[0]);\n     return 1;\n   }\n \n   fpin = fopen(fin, \"rb\");\n   if (fpin == NULL) {\n     printf(\"Can't open file %s to read\\n\", fin);\n    usage(argv[0]);\n     return 1;\n   }\n   fpout = fopen(fout, \"wb\");\n   if (fpout == NULL) {\n     printf(\"Can't open file %s to write\\n\", fout);\n    usage(argv[0]);\n     return 1;\n   }\n   if (argc >= 6)\n    frames = atoi(argv[5]);\n else\n    frames = INT_MAX;\n\n  printf(\"Input size:  %dx%d\\n\",\n         width, height);\n  printf(\"Target size: %dx%d, Frames: \",\n         target_width, target_height);\n if (frames == INT_MAX)\n    printf(\"All\\n\");\n else\n    printf(\"%d\\n\", frames);\n\n  inbuf = (uint8_t*)malloc(width * height * 3 / 2);\n  outbuf = (uint8_t*)malloc(target_width * target_height * 3 / 2);\n  inbuf_u = inbuf + width * height;\n  inbuf_v = inbuf_u + width * height / 4;\n  outbuf_u = outbuf + target_width * target_height;\n  outbuf_v = outbuf_u + target_width * target_height / 4;\n  f = 0;\n while (f < frames) {\n if (fread(inbuf, width * height * 3 / 2, 1, fpin) != 1)\n break;\n    vp9_resize_frame420(inbuf, width, inbuf_u, inbuf_v, width / 2,\n                        height, width,\n                        outbuf, target_width, outbuf_u, outbuf_v,\n                        target_width / 2,\n                        target_height, target_width);\n    fwrite(outbuf, target_width * target_height * 3 / 2, 1, fpout);\n    f++;\n }\n  printf(\"%d frames processed\\n\", f);\n  fclose(fpin);\n  fclose(fpout);\n\n  free(inbuf);\n  free(outbuf);\n return 0;\n}\n", "target": 1, "idx": 188501}
{"func": "void MessageLoop::SetNestableTasksAllowed(bool allowed) {\n  if (allowed) {\n     CHECK(RunLoop::IsNestingAllowedOnCurrentThread());\n \n     pump_->ScheduleWork();\n   }\n   nestable_tasks_allowed_ = allowed;\n }\n", "target": 1, "idx": 185745}
{"func": "int remap_pfn_range(struct vm_area_struct *vma, unsigned long addr,\n\t\t    unsigned long pfn, unsigned long size, pgprot_t prot)\n{\n\tpgd_t *pgd;\n\tunsigned long next;\n\tunsigned long end = addr + PAGE_ALIGN(size);\n\tstruct mm_struct *mm = vma->vm_mm;\n\tint err;\n\n\t/*\n\t * Physically remapped pages are special. Tell the\n\t * rest of the world about it:\n\t *   VM_IO tells people not to look at these pages\n\t *\t(accesses can have side effects).\n\t *   VM_PFNMAP tells the core MM that the base pages are just\n\t *\traw PFN mappings, and do not have a \"struct page\" associated\n\t *\twith them.\n\t *   VM_DONTEXPAND\n\t *      Disable vma merging and expanding with mremap().\n\t *   VM_DONTDUMP\n\t *      Omit vma from core dump, even when VM_IO turned off.\n\t *\n\t * There's a horrible special case to handle copy-on-write\n\t * behaviour that some programs depend on. We mark the \"original\"\n\t * un-COW'ed pages by matching them up with \"vma->vm_pgoff\".\n\t * See vm_normal_page() for details.\n\t */\n\tif (is_cow_mapping(vma->vm_flags)) {\n\t\tif (addr != vma->vm_start || end != vma->vm_end)\n\t\t\treturn -EINVAL;\n\t\tvma->vm_pgoff = pfn;\n\t}\n\n\terr = track_pfn_remap(vma, &prot, pfn, addr, PAGE_ALIGN(size));\n\tif (err)\n\t\treturn -EINVAL;\n\n\tvma->vm_flags |= VM_IO | VM_PFNMAP | VM_DONTEXPAND | VM_DONTDUMP;\n\n\tBUG_ON(addr >= end);\n\tpfn -= addr >> PAGE_SHIFT;\n\tpgd = pgd_offset(mm, addr);\n\tflush_cache_range(vma, addr, end);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\terr = remap_pud_range(mm, pgd, addr, next,\n\t\t\t\tpfn + (addr >> PAGE_SHIFT), prot);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (pgd++, addr = next, addr != end);\n\n\tif (err)\n\t\tuntrack_pfn(vma, pfn, PAGE_ALIGN(size));\n\n\treturn err;\n}\n", "target": 0, "idx": 57885}
{"func": "sg_get_dev(int dev)\n{\n\tstruct sg_device *sdp;\n\tunsigned long flags;\n\n\tread_lock_irqsave(&sg_index_lock, flags);\n\tsdp = sg_lookup_dev(dev);\n\tif (!sdp)\n\t\tsdp = ERR_PTR(-ENXIO);\n\telse if (atomic_read(&sdp->detaching)) {\n\t\t/* If sdp->detaching, then the refcount may already be 0, in\n\t\t * which case it would be a bug to do kref_get().\n\t\t */\n\t\tsdp = ERR_PTR(-ENODEV);\n\t} else\n\t\tkref_get(&sdp->d_ref);\n\tread_unlock_irqrestore(&sg_index_lock, flags);\n\n\treturn sdp;\n}\n", "target": 0, "idx": 42268}
{"func": "dump_cfg_strarray(ServerOpCodes code, u_int count, char **vals)\n{\n\tu_int i;\n\n\tfor (i = 0; i < count; i++)\n\t\tprintf(\"%s %s\\n\", lookup_opcode_name(code), vals[i]);\n}\n", "target": 0, "idx": 72214}
{"func": "BlockEntry::Kind Track::EOSBlock::GetKind() const\n{\n    return kBlockEOS;\n}\n", "target": 1, "idx": 188353}
{"func": "   void FillRandom(uint8_t *data, int stride) {\n     for (int h = 0; h < height_; ++h) {\n       for (int w = 0; w < width_; ++w) {\n        data[h * stride + w] = rnd_.Rand8();\n       }\n     }\n   }\n", "target": 1, "idx": 188594}
{"func": "FrameTreeNode* RenderFrameHostImpl::FindAndVerifyChild(\n    int32_t child_frame_routing_id,\n    bad_message::BadMessageReason reason) {\n  FrameTreeNode* child = frame_tree_node()->frame_tree()->FindByRoutingID(\n      GetProcess()->GetID(), child_frame_routing_id);\n  if (child && child->parent() != frame_tree_node()) {\n    bad_message::ReceivedBadMessage(GetProcess(), reason);\n    return nullptr;\n  }\n  return child;\n}\n", "target": 0, "idx": 138677}
{"func": "PHP_NAMED_FUNCTION(zif_locale_get_default)\n{\n\tRETURN_STRING( intl_locale_get_default( TSRMLS_C ), TRUE );\n}\n", "target": 0, "idx": 52215}
{"func": "base::RepeatingCallback<void(Args...)> CreateSafeCallback(\n    SkiaOutputSurfaceDependency* dependency,\n    const base::RepeatingCallback<void(Args...)>& callback) {\n  DCHECK(dependency);\n  return base::BindRepeating(&PostAsyncTask<Args...>, dependency, callback);\n}\n", "target": 0, "idx": 148633}
{"func": "void MenuGtk::OnMenuHidden(GtkWidget* widget, MenuGtk* menu) {\n  menu->delegate_->StoppedShowing();\n}\n", "target": 0, "idx": 100590}
{"func": "static void fwnet_transmit_packet_failed(struct fwnet_packet_task *ptask)\n{\n\tstruct fwnet_device *dev = ptask->dev;\n\tunsigned long flags;\n\tbool free;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\t/* One fragment failed; don't try to send remaining fragments. */\n\tptask->outstanding_pkts = 0;\n\n\t/* Check whether we or the networking TX soft-IRQ is last user. */\n\tfree = ptask->enqueued;\n\tif (free)\n\t\tdec_queued_datagrams(dev);\n\n\tdev->netdev->stats.tx_dropped++;\n\tdev->netdev->stats.tx_errors++;\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tif (free)\n\t\tfwnet_free_ptask(ptask);\n}\n", "target": 0, "idx": 49353}
{"func": " mcs_parse_domain_params(STREAM s)\n {\n\tint length;\n \n \tber_parse_header(s, MCS_TAG_DOMAIN_PARAMS, &length);\n \tin_uint8s(s, length);\n \n \treturn s_check(s);\n}\n", "target": 1, "idx": 182971}
{"func": "status_t StreamingProcessor::processRecordingFrame() {\n    ATRACE_CALL();\n status_t res;\n    sp<Camera2Heap> recordingHeap;\n size_t heapIdx = 0;\n nsecs_t timestamp;\n\n    sp<Camera2Client> client = mClient.promote();\n if (client == 0) {\n BufferItem imgBuffer;\n        res = mRecordingConsumer->acquireBuffer(&imgBuffer, 0);\n if (res != OK) {\n if (res != BufferItemConsumer::NO_BUFFER_AVAILABLE) {\n                ALOGE(\"%s: Camera %d: Can't acquire recording buffer: %s (%d)\",\n                        __FUNCTION__, mId, strerror(-res), res);\n }\n return res;\n }\n        mRecordingConsumer->releaseBuffer(imgBuffer);\n return OK;\n }\n\n {\n /* acquire SharedParameters before mMutex so we don't dead lock\n            with Camera2Client code calling into StreamingProcessor */\n SharedParameters::Lock l(client->getParameters());\n Mutex::Autolock m(mMutex);\n BufferItem imgBuffer;\n        res = mRecordingConsumer->acquireBuffer(&imgBuffer, 0);\n if (res != OK) {\n if (res != BufferItemConsumer::NO_BUFFER_AVAILABLE) {\n                ALOGE(\"%s: Camera %d: Can't acquire recording buffer: %s (%d)\",\n                        __FUNCTION__, mId, strerror(-res), res);\n }\n return res;\n }\n        timestamp = imgBuffer.mTimestamp;\n\n        mRecordingFrameCount++;\n        ALOGVV(\"OnRecordingFrame: Frame %d\", mRecordingFrameCount);\n\n if (l.mParameters.state != Parameters::RECORD &&\n                l.mParameters.state != Parameters::VIDEO_SNAPSHOT) {\n            ALOGV(\"%s: Camera %d: Discarding recording image buffers \"\n \"received after recording done\", __FUNCTION__,\n                    mId);\n            mRecordingConsumer->releaseBuffer(imgBuffer);\n return INVALID_OPERATION;\n }\n\n if (mRecordingHeap == 0) {\n size_t payloadSize = sizeof(VideoNativeMetadata);\n            ALOGV(\"%s: Camera %d: Creating recording heap with %zu buffers of \"\n \"size %zu bytes\", __FUNCTION__, mId,\n                    mRecordingHeapCount, payloadSize);\n\n            mRecordingHeap = new Camera2Heap(payloadSize, mRecordingHeapCount,\n \"Camera2Client::RecordingHeap\");\n if (mRecordingHeap->mHeap->getSize() == 0) {\n                ALOGE(\"%s: Camera %d: Unable to allocate memory for recording\",\n                        __FUNCTION__, mId);\n                mRecordingConsumer->releaseBuffer(imgBuffer);\n return NO_MEMORY;\n }\n for (size_t i = 0; i < mRecordingBuffers.size(); i++) {\n if (mRecordingBuffers[i].mBuf !=\n BufferItemConsumer::INVALID_BUFFER_SLOT) {\n                    ALOGE(\"%s: Camera %d: Non-empty recording buffers list!\",\n                            __FUNCTION__, mId);\n }\n }\n            mRecordingBuffers.clear();\n            mRecordingBuffers.setCapacity(mRecordingHeapCount);\n            mRecordingBuffers.insertAt(0, mRecordingHeapCount);\n\n            mRecordingHeapHead = 0;\n            mRecordingHeapFree = mRecordingHeapCount;\n }\n\n if (mRecordingHeapFree == 0) {\n            ALOGE(\"%s: Camera %d: No free recording buffers, dropping frame\",\n                    __FUNCTION__, mId);\n            mRecordingConsumer->releaseBuffer(imgBuffer);\n return NO_MEMORY;\n }\n\n        heapIdx = mRecordingHeapHead;\n        mRecordingHeapHead = (mRecordingHeapHead + 1) % mRecordingHeapCount;\n        mRecordingHeapFree--;\n\n        ALOGVV(\"%s: Camera %d: Timestamp %lld\",\n                __FUNCTION__, mId, timestamp);\n\n ssize_t offset;\n size_t size;\n        sp<IMemoryHeap> heap =\n                mRecordingHeap->mBuffers[heapIdx]->getMemory(&offset,\n &size);\n\n VideoNativeMetadata *payload = reinterpret_cast<VideoNativeMetadata*>(\n\n             (uint8_t*)heap->getBase() + offset);\n         payload->eType = kMetadataBufferTypeANWBuffer;\n         payload->pBuffer = imgBuffer.mGraphicBuffer->getNativeBuffer();\n         payload->nFenceFd = -1;\n \n         ALOGVV(\"%s: Camera %d: Sending out ANWBuffer %p\",\n                __FUNCTION__, mId, payload->pBuffer);\n\n        mRecordingBuffers.replaceAt(imgBuffer, heapIdx);\n        recordingHeap = mRecordingHeap;\n }\n\n Camera2Client::SharedCameraCallbacks::Lock l(client->mSharedCameraCallbacks);\n if (l.mRemoteCallback != 0) {\n        l.mRemoteCallback->dataCallbackTimestamp(timestamp,\n                CAMERA_MSG_VIDEO_FRAME,\n                recordingHeap->mBuffers[heapIdx]);\n } else {\n        ALOGW(\"%s: Camera %d: Remote callback gone\", __FUNCTION__, mId);\n }\n\n return OK;\n}\n", "target": 1, "idx": 187533}
{"func": "void BrowserPolicyConnector::SetDeviceCredentials(\n     const std::string& owner_email,\n     const std::string& token,\n     TokenType token_type) {\n#if defined(OS_CHROMEOS)\n  if (device_data_store_.get()) {\n    device_data_store_->set_user_name(owner_email);\n    switch (token_type) {\n      case TOKEN_TYPE_OAUTH:\n        device_data_store_->SetOAuthToken(token);\n        break;\n      case TOKEN_TYPE_GAIA:\n        device_data_store_->SetGaiaToken(token);\n        break;\n      default:\n        NOTREACHED() << \"Invalid token type \" << token_type;\n    }\n  }\n#endif\n}\n", "target": 1, "idx": 183737}
{"func": "void unregister_pernet_device(struct pernet_operations *ops)\n{\n\tmutex_lock(&net_mutex);\n\tif (&ops->list == first_device)\n\t\tfirst_device = first_device->next;\n\tunregister_pernet_operations(ops);\n\tmutex_unlock(&net_mutex);\n}\n", "target": 0, "idx": 86311}
{"func": "static int tcos_select_file(sc_card_t *card,\n\t\t\t    const sc_path_t *in_path,\n\t\t\t    sc_file_t **file_out)\n{\n\tsc_context_t *ctx;\n\tsc_apdu_t apdu;\n\tsc_file_t *file=NULL;\n\tu8 buf[SC_MAX_APDU_BUFFER_SIZE], pathbuf[SC_MAX_PATH_SIZE], *path = pathbuf;\n\tunsigned int i;\n\tint r, pathlen;\n\n\tassert(card != NULL && in_path != NULL);\n\tctx=card->ctx;\n\tmemcpy(path, in_path->value, in_path->len);\n\tpathlen = in_path->len;\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0xA4, 0, 0x04);\n\t\n\tswitch (in_path->type) {\n\tcase SC_PATH_TYPE_FILE_ID:\n\t\tif (pathlen != 2) return SC_ERROR_INVALID_ARGUMENTS;\n\t\t/* fall through */\n\tcase SC_PATH_TYPE_FROM_CURRENT:\n\t\tapdu.p1 = 9;\n\t\tbreak;\n\tcase SC_PATH_TYPE_DF_NAME:\n\t\tapdu.p1 = 4;\n\t\tbreak;\n\tcase SC_PATH_TYPE_PATH:\n\t\tapdu.p1 = 8;\n\t\tif (pathlen >= 2 && memcmp(path, \"\\x3F\\x00\", 2) == 0) path += 2, pathlen -= 2;\n\t\tif (pathlen == 0) apdu.p1 = 0;\n\t\tbreak;\n\tcase SC_PATH_TYPE_PARENT:\n\t\tapdu.p1 = 3;\n\t\tpathlen = 0;\n\t\tbreak;\n\tdefault:\n\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INVALID_ARGUMENTS);\n\t}\n\tif( pathlen == 0 ) apdu.cse = SC_APDU_CASE_2_SHORT;\n\n\tapdu.lc = pathlen;\n\tapdu.data = path;\n\tapdu.datalen = pathlen;\n\n\tif (file_out != NULL) {\n\t\tapdu.resp = buf;\n\t\tapdu.resplen = sizeof(buf);\n\t\tapdu.le = 256;\n\t} else {\n\t\tapdu.resplen = 0;\n\t\tapdu.le = 0; \n\t\tapdu.p2 = 0x0C; \n\t\tapdu.cse = (pathlen == 0) ? SC_APDU_CASE_1 : SC_APDU_CASE_3_SHORT;\n\t}\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tSC_TEST_RET(ctx, SC_LOG_DEBUG_NORMAL, r, \"APDU transmit failed\");\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tif (r || file_out == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, r);\n\n\tif (apdu.resplen < 1 || apdu.resp[0] != 0x62){\n\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL, \"received invalid template %02X\\n\", apdu.resp[0]);\n\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\t}\n\n\tfile = sc_file_new();\n\tif (file == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_OUT_OF_MEMORY);\n\t*file_out = file;\n \tfile->path = *in_path;\n \n \tfor(i=2; i+1<apdu.resplen && i+1+apdu.resp[i+1]<apdu.resplen; i+=2+apdu.resp[i+1]){\n\t\tint j, len=apdu.resp[i+1];\n \t\tunsigned char type=apdu.resp[i], *d=apdu.resp+i+2;\n \n \t\tswitch (type) {\n\t\tcase 0x80:\n\t\tcase 0x81:\n\t\t\tfile->size=0;\n\t\t\tfor(j=0; j<len; ++j) file->size = (file->size<<8) | d[j];\n\t\t\tbreak;\n\t\tcase 0x82:\n\t\t\tfile->shareable = (d[0] & 0x40) ? 1 : 0;\n\t\t\tfile->ef_structure = d[0] & 7;\n\t\t\tswitch ((d[0]>>3) & 7) {\n\t\t\tcase 0: file->type = SC_FILE_TYPE_WORKING_EF; break;\n\t\t\tcase 7: file->type = SC_FILE_TYPE_DF; break;\n\t\t\tdefault:\n\t\t\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL, \"invalid file type %02X in file descriptor\\n\", d[0]);\n\t\t\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x83:\n \t\t\tfile->id = (d[0]<<8) | d[1];\n \t\t\tbreak;\n \t\tcase 0x84:\n\t\t\tmemcpy(file->name, d, len);\n\t\t\tfile->namelen = len;\n \t\t\tbreak;\n \t\tcase 0x86:\n \t\t\tsc_file_set_sec_attr(file, d, len); \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (len>0) sc_file_set_prop_attr(file, d, len); \n\t\t}\n\t}\n\tfile->magic = SC_FILE_MAGIC;\n\n\tparse_sec_attr(card, file, file->sec_attr, file->sec_attr_len);\n\n\treturn 0;\n}\n", "target": 1, "idx": 182247}
{"func": "void ForwardShapeDetectionRequest(R request) {\n  service_manager::Connector* connector =\n      ServiceManagerConnection::GetForProcess()->GetConnector();\n  connector->BindInterface(shape_detection::mojom::kServiceName,\n                           std::move(request));\n}\n", "target": 0, "idx": 139149}
{"func": "static int tg3_fiber_aneg_smachine(struct tg3 *tp,\n\t\t\t\t   struct tg3_fiber_aneginfo *ap)\n{\n\tu16 flowctrl;\n\tunsigned long delta;\n\tu32 rx_cfg_reg;\n\tint ret;\n\n\tif (ap->state == ANEG_STATE_UNKNOWN) {\n\t\tap->rxconfig = 0;\n\t\tap->link_time = 0;\n\t\tap->cur_time = 0;\n\t\tap->ability_match_cfg = 0;\n\t\tap->ability_match_count = 0;\n\t\tap->ability_match = 0;\n\t\tap->idle_match = 0;\n\t\tap->ack_match = 0;\n\t}\n\tap->cur_time++;\n\n\tif (tr32(MAC_STATUS) & MAC_STATUS_RCVD_CFG) {\n\t\trx_cfg_reg = tr32(MAC_RX_AUTO_NEG);\n\n\t\tif (rx_cfg_reg != ap->ability_match_cfg) {\n\t\t\tap->ability_match_cfg = rx_cfg_reg;\n\t\t\tap->ability_match = 0;\n\t\t\tap->ability_match_count = 0;\n\t\t} else {\n\t\t\tif (++ap->ability_match_count > 1) {\n\t\t\t\tap->ability_match = 1;\n\t\t\t\tap->ability_match_cfg = rx_cfg_reg;\n\t\t\t}\n\t\t}\n\t\tif (rx_cfg_reg & ANEG_CFG_ACK)\n\t\t\tap->ack_match = 1;\n\t\telse\n\t\t\tap->ack_match = 0;\n\n\t\tap->idle_match = 0;\n\t} else {\n\t\tap->idle_match = 1;\n\t\tap->ability_match_cfg = 0;\n\t\tap->ability_match_count = 0;\n\t\tap->ability_match = 0;\n\t\tap->ack_match = 0;\n\n\t\trx_cfg_reg = 0;\n\t}\n\n\tap->rxconfig = rx_cfg_reg;\n\tret = ANEG_OK;\n\n\tswitch (ap->state) {\n\tcase ANEG_STATE_UNKNOWN:\n\t\tif (ap->flags & (MR_AN_ENABLE | MR_RESTART_AN))\n\t\t\tap->state = ANEG_STATE_AN_ENABLE;\n\n\t\t/* fallthru */\n\tcase ANEG_STATE_AN_ENABLE:\n\t\tap->flags &= ~(MR_AN_COMPLETE | MR_PAGE_RX);\n\t\tif (ap->flags & MR_AN_ENABLE) {\n\t\t\tap->link_time = 0;\n\t\t\tap->cur_time = 0;\n\t\t\tap->ability_match_cfg = 0;\n\t\t\tap->ability_match_count = 0;\n\t\t\tap->ability_match = 0;\n\t\t\tap->idle_match = 0;\n\t\t\tap->ack_match = 0;\n\n\t\t\tap->state = ANEG_STATE_RESTART_INIT;\n\t\t} else {\n\t\t\tap->state = ANEG_STATE_DISABLE_LINK_OK;\n\t\t}\n\t\tbreak;\n\n\tcase ANEG_STATE_RESTART_INIT:\n\t\tap->link_time = ap->cur_time;\n\t\tap->flags &= ~(MR_NP_LOADED);\n\t\tap->txconfig = 0;\n\t\ttw32(MAC_TX_AUTO_NEG, 0);\n\t\ttp->mac_mode |= MAC_MODE_SEND_CONFIGS;\n\t\ttw32_f(MAC_MODE, tp->mac_mode);\n\t\tudelay(40);\n\n\t\tret = ANEG_TIMER_ENAB;\n\t\tap->state = ANEG_STATE_RESTART;\n\n\t\t/* fallthru */\n\tcase ANEG_STATE_RESTART:\n\t\tdelta = ap->cur_time - ap->link_time;\n\t\tif (delta > ANEG_STATE_SETTLE_TIME)\n\t\t\tap->state = ANEG_STATE_ABILITY_DETECT_INIT;\n\t\telse\n\t\t\tret = ANEG_TIMER_ENAB;\n\t\tbreak;\n\n\tcase ANEG_STATE_DISABLE_LINK_OK:\n\t\tret = ANEG_DONE;\n\t\tbreak;\n\n\tcase ANEG_STATE_ABILITY_DETECT_INIT:\n\t\tap->flags &= ~(MR_TOGGLE_TX);\n\t\tap->txconfig = ANEG_CFG_FD;\n\t\tflowctrl = tg3_advert_flowctrl_1000X(tp->link_config.flowctrl);\n\t\tif (flowctrl & ADVERTISE_1000XPAUSE)\n\t\t\tap->txconfig |= ANEG_CFG_PS1;\n\t\tif (flowctrl & ADVERTISE_1000XPSE_ASYM)\n\t\t\tap->txconfig |= ANEG_CFG_PS2;\n\t\ttw32(MAC_TX_AUTO_NEG, ap->txconfig);\n\t\ttp->mac_mode |= MAC_MODE_SEND_CONFIGS;\n\t\ttw32_f(MAC_MODE, tp->mac_mode);\n\t\tudelay(40);\n\n\t\tap->state = ANEG_STATE_ABILITY_DETECT;\n\t\tbreak;\n\n\tcase ANEG_STATE_ABILITY_DETECT:\n\t\tif (ap->ability_match != 0 && ap->rxconfig != 0)\n\t\t\tap->state = ANEG_STATE_ACK_DETECT_INIT;\n\t\tbreak;\n\n\tcase ANEG_STATE_ACK_DETECT_INIT:\n\t\tap->txconfig |= ANEG_CFG_ACK;\n\t\ttw32(MAC_TX_AUTO_NEG, ap->txconfig);\n\t\ttp->mac_mode |= MAC_MODE_SEND_CONFIGS;\n\t\ttw32_f(MAC_MODE, tp->mac_mode);\n\t\tudelay(40);\n\n\t\tap->state = ANEG_STATE_ACK_DETECT;\n\n\t\t/* fallthru */\n\tcase ANEG_STATE_ACK_DETECT:\n\t\tif (ap->ack_match != 0) {\n\t\t\tif ((ap->rxconfig & ~ANEG_CFG_ACK) ==\n\t\t\t    (ap->ability_match_cfg & ~ANEG_CFG_ACK)) {\n\t\t\t\tap->state = ANEG_STATE_COMPLETE_ACK_INIT;\n\t\t\t} else {\n\t\t\t\tap->state = ANEG_STATE_AN_ENABLE;\n\t\t\t}\n\t\t} else if (ap->ability_match != 0 &&\n\t\t\t   ap->rxconfig == 0) {\n\t\t\tap->state = ANEG_STATE_AN_ENABLE;\n\t\t}\n\t\tbreak;\n\n\tcase ANEG_STATE_COMPLETE_ACK_INIT:\n\t\tif (ap->rxconfig & ANEG_CFG_INVAL) {\n\t\t\tret = ANEG_FAILED;\n\t\t\tbreak;\n\t\t}\n\t\tap->flags &= ~(MR_LP_ADV_FULL_DUPLEX |\n\t\t\t       MR_LP_ADV_HALF_DUPLEX |\n\t\t\t       MR_LP_ADV_SYM_PAUSE |\n\t\t\t       MR_LP_ADV_ASYM_PAUSE |\n\t\t\t       MR_LP_ADV_REMOTE_FAULT1 |\n\t\t\t       MR_LP_ADV_REMOTE_FAULT2 |\n\t\t\t       MR_LP_ADV_NEXT_PAGE |\n\t\t\t       MR_TOGGLE_RX |\n\t\t\t       MR_NP_RX);\n\t\tif (ap->rxconfig & ANEG_CFG_FD)\n\t\t\tap->flags |= MR_LP_ADV_FULL_DUPLEX;\n\t\tif (ap->rxconfig & ANEG_CFG_HD)\n\t\t\tap->flags |= MR_LP_ADV_HALF_DUPLEX;\n\t\tif (ap->rxconfig & ANEG_CFG_PS1)\n\t\t\tap->flags |= MR_LP_ADV_SYM_PAUSE;\n\t\tif (ap->rxconfig & ANEG_CFG_PS2)\n\t\t\tap->flags |= MR_LP_ADV_ASYM_PAUSE;\n\t\tif (ap->rxconfig & ANEG_CFG_RF1)\n\t\t\tap->flags |= MR_LP_ADV_REMOTE_FAULT1;\n\t\tif (ap->rxconfig & ANEG_CFG_RF2)\n\t\t\tap->flags |= MR_LP_ADV_REMOTE_FAULT2;\n\t\tif (ap->rxconfig & ANEG_CFG_NP)\n\t\t\tap->flags |= MR_LP_ADV_NEXT_PAGE;\n\n\t\tap->link_time = ap->cur_time;\n\n\t\tap->flags ^= (MR_TOGGLE_TX);\n\t\tif (ap->rxconfig & 0x0008)\n\t\t\tap->flags |= MR_TOGGLE_RX;\n\t\tif (ap->rxconfig & ANEG_CFG_NP)\n\t\t\tap->flags |= MR_NP_RX;\n\t\tap->flags |= MR_PAGE_RX;\n\n\t\tap->state = ANEG_STATE_COMPLETE_ACK;\n\t\tret = ANEG_TIMER_ENAB;\n\t\tbreak;\n\n\tcase ANEG_STATE_COMPLETE_ACK:\n\t\tif (ap->ability_match != 0 &&\n\t\t    ap->rxconfig == 0) {\n\t\t\tap->state = ANEG_STATE_AN_ENABLE;\n\t\t\tbreak;\n\t\t}\n\t\tdelta = ap->cur_time - ap->link_time;\n\t\tif (delta > ANEG_STATE_SETTLE_TIME) {\n\t\t\tif (!(ap->flags & (MR_LP_ADV_NEXT_PAGE))) {\n\t\t\t\tap->state = ANEG_STATE_IDLE_DETECT_INIT;\n\t\t\t} else {\n\t\t\t\tif ((ap->txconfig & ANEG_CFG_NP) == 0 &&\n\t\t\t\t    !(ap->flags & MR_NP_RX)) {\n\t\t\t\t\tap->state = ANEG_STATE_IDLE_DETECT_INIT;\n\t\t\t\t} else {\n\t\t\t\t\tret = ANEG_FAILED;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase ANEG_STATE_IDLE_DETECT_INIT:\n\t\tap->link_time = ap->cur_time;\n\t\ttp->mac_mode &= ~MAC_MODE_SEND_CONFIGS;\n\t\ttw32_f(MAC_MODE, tp->mac_mode);\n\t\tudelay(40);\n\n\t\tap->state = ANEG_STATE_IDLE_DETECT;\n\t\tret = ANEG_TIMER_ENAB;\n\t\tbreak;\n\n\tcase ANEG_STATE_IDLE_DETECT:\n\t\tif (ap->ability_match != 0 &&\n\t\t    ap->rxconfig == 0) {\n\t\t\tap->state = ANEG_STATE_AN_ENABLE;\n\t\t\tbreak;\n\t\t}\n\t\tdelta = ap->cur_time - ap->link_time;\n\t\tif (delta > ANEG_STATE_SETTLE_TIME) {\n\t\t\t/* XXX another gem from the Broadcom driver :( */\n\t\t\tap->state = ANEG_STATE_LINK_OK;\n\t\t}\n\t\tbreak;\n\n\tcase ANEG_STATE_LINK_OK:\n\t\tap->flags |= (MR_AN_COMPLETE | MR_LINK_OK);\n\t\tret = ANEG_DONE;\n\t\tbreak;\n\n\tcase ANEG_STATE_NEXT_PAGE_WAIT_INIT:\n\t\t/* ??? unimplemented */\n\t\tbreak;\n\n\tcase ANEG_STATE_NEXT_PAGE_WAIT:\n\t\t/* ??? unimplemented */\n\t\tbreak;\n\n\tdefault:\n\t\tret = ANEG_FAILED;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n", "target": 0, "idx": 32531}
{"func": "int CSoundFile::FrequencyToTranspose(DWORD freq)\n{\n\treturn int(1536*(log(freq/8363.0)/log(2.0)));\n\n#ifdef MSC_VER\n\tconst float _f1_8363 = 1.0f / 8363.0f;\n\tconst float _factor = 128 * 12;\n\tLONG result;\n\n\tif (!freq) return 0;\n\t_asm {\n\tfld _factor\n\tfild freq\n\tfld _f1_8363\n\tfmulp st(1), st(0)\n\tfyl2x\n\tfistp result\n\t}\n\treturn result;\n#endif\n}\n", "target": 0, "idx": 8474}
{"func": " static void do_perf_sw_event(enum perf_type_id type, u32 event_id,\n\t\t\t\t    u64 nr, int nmi,\n \t\t\t\t    struct perf_sample_data *data,\n \t\t\t\t    struct pt_regs *regs)\n {\n\tstruct swevent_htable *swhash = &__get_cpu_var(swevent_htable);\n\tstruct perf_event *event;\n\tstruct hlist_node *node;\n\tstruct hlist_head *head;\n\n\trcu_read_lock();\n\thead = find_swevent_head_rcu(swhash, type, event_id);\n\tif (!head)\n\t\tgoto end;\n \n \thlist_for_each_entry_rcu(event, node, head, hlist_entry) {\n \t\tif (perf_swevent_match(event, type, event_id, data, regs))\n\t\t\tperf_swevent_event(event, nr, nmi, data, regs);\n \t}\n end:\n \trcu_read_unlock();\n}\n", "target": 1, "idx": 179000}
{"func": "void __audit_fd_pair(int fd1, int fd2)\n{\n\tstruct audit_context *context = current->audit_context;\n\tcontext->fds[0] = fd1;\n\tcontext->fds[1] = fd2;\n}\n", "target": 0, "idx": 51120}
{"func": "check_cv_name_str(mrb_state *mrb, mrb_value str)\n{\n  const char *s = RSTRING_PTR(str);\n  mrb_int len = RSTRING_LEN(str);\n\n  if (len < 3 || !(s[0] == '@' && s[1] == '@')) {\n    mrb_name_error(mrb, mrb_intern_str(mrb, str), \"'%S' is not allowed as a class variable name\", str);\n  }\n}\n", "target": 0, "idx": 82044}
{"func": "check_mountpoint(const char *progname, char *mountpoint)\n{\n\tint err;\n        struct stat statbuf;\n \n        /* does mountpoint exist and is it a directory? */\n       err = stat(mountpoint, &statbuf);\n        if (err) {\n                fprintf(stderr, \"%s: failed to stat %s: %s\\n\", progname,\n                                mountpoint, strerror(errno));\n\t\treturn EX_USAGE;\n\t}\n\n\tif (!S_ISDIR(statbuf.st_mode)) {\n\t\tfprintf(stderr, \"%s: %s is not a directory!\", progname,\n\t\t\t\tmountpoint);\n\t\treturn EX_USAGE;\n\t}\n\n#if CIFS_LEGACY_SETUID_CHECK\n\t/* do extra checks on mountpoint for legacy setuid behavior */\n\tif (!getuid() || geteuid())\n\t\treturn 0;\n\n\tif (statbuf.st_uid != getuid()) {\n\t\tfprintf(stderr, \"%s: %s is not owned by user\\n\", progname,\n\t\t\tmountpoint);\n\t\treturn EX_USAGE;\n\t}\n\n\tif ((statbuf.st_mode & S_IRWXU) != S_IRWXU) {\n\t\tfprintf(stderr, \"%s: invalid permissions on %s\\n\", progname,\n\t\t\tmountpoint);\n\t\treturn EX_USAGE;\n\t}\n#endif /* CIFS_LEGACY_SETUID_CHECK */\n\n\treturn 0;\n}\n", "target": 1, "idx": 178340}
{"func": "void FolderHeaderView::ContentsChanged(views::Textfield* sender,\n                                       const base::string16& new_contents) {\n   if (!folder_item_)\n     return;\n \n   folder_item_->RemoveObserver(this);\n  std::string name = base::UTF16ToUTF8(folder_name_view_->text());\n  delegate_->SetItemName(folder_item_, name);\n   folder_item_->AddObserver(this);\n \n   Layout();\n}\n", "target": 1, "idx": 184892}
{"func": "inline HTMLLinkElement::HTMLLinkElement(const QualifiedName& tagName, Document* document, bool createdByParser)\n    : HTMLElement(tagName, document)\n     , m_disabledState(Unset)\n     , m_loading(false)\n     , m_createdByParser(createdByParser)\n    , m_shouldProcessAfterAttach(false)\n {\n     ASSERT(hasTagName(linkTag));\n }\n", "target": 1, "idx": 183485}
{"func": "bool IsAccountManagerEnabled() {\n  return base::FeatureList::IsEnabled(kAccountManager);\n}\n", "target": 0, "idx": 134927}
{"func": "std::unique_ptr<views::Border> AutofillPopupBaseView::CreateBorder() {\n  auto border = std::make_unique<views::BubbleBorder>(\n      views::BubbleBorder::NONE, views::BubbleBorder::SMALL_SHADOW,\n      SK_ColorWHITE);\n  border->SetCornerRadius(GetCornerRadius());\n  border->set_md_shadow_elevation(\n      ChromeLayoutProvider::Get()->GetShadowElevationMetric(\n          views::EMPHASIS_MEDIUM));\n  return border;\n}\n", "target": 1, "idx": 186007}
{"func": "MagickExport Image *MeanShiftImage(const Image *image,const size_t width,\n  const size_t height,const double color_distance,ExceptionInfo *exception)\n{\n#define MaxMeanShiftIterations  100\n#define MeanShiftImageTag  \"MeanShift/Image\"\n\n  CacheView\n    *image_view,\n    *mean_view,\n    *pixel_view;\n\n  Image\n    *mean_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  ssize_t\n    y;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  mean_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (mean_image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(mean_image,DirectClass) == MagickFalse)\n    {\n      InheritException(exception,&mean_image->exception);\n      mean_image=DestroyImage(mean_image);\n      return((Image *) NULL);\n    }\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireVirtualCacheView(image,exception);\n  pixel_view=AcquireVirtualCacheView(image,exception);\n  mean_view=AcquireAuthenticCacheView(mean_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(status,progress) \\\n    magick_number_threads(mean_image,mean_image,mean_image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) mean_image->rows; y++)\n  {\n    register const IndexPacket\n      *magick_restrict indexes;\n\n    register const PixelPacket\n      *magick_restrict p;\n\n    register PixelPacket\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    q=GetCacheViewAuthenticPixels(mean_view,0,y,mean_image->columns,1,\n      exception);\n    if ((p == (const PixelPacket *) NULL) || (q == (PixelPacket *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    indexes=GetCacheViewVirtualIndexQueue(image_view);\n    for (x=0; x < (ssize_t) mean_image->columns; x++)\n    {\n      MagickPixelPacket\n        mean_pixel,\n        previous_pixel;\n\n      PointInfo\n        mean_location,\n        previous_location;\n\n      register ssize_t\n        i;\n\n      GetMagickPixelPacket(image,&mean_pixel);\n      SetMagickPixelPacket(image,p,indexes+x,&mean_pixel);\n      mean_location.x=(double) x;\n      mean_location.y=(double) y;\n      for (i=0; i < MaxMeanShiftIterations; i++)\n      {\n        double\n          distance,\n          gamma;\n\n        MagickPixelPacket\n          sum_pixel;\n\n        PointInfo\n          sum_location;\n\n        ssize_t\n          count,\n          v;\n\n        sum_location.x=0.0;\n        sum_location.y=0.0;\n        GetMagickPixelPacket(image,&sum_pixel);\n        previous_location=mean_location;\n        previous_pixel=mean_pixel;\n        count=0;\n        for (v=(-((ssize_t) height/2)); v <= (((ssize_t) height/2)); v++)\n        {\n          ssize_t\n            u;\n\n          for (u=(-((ssize_t) width/2)); u <= (((ssize_t) width/2)); u++)\n          {\n            if ((v*v+u*u) <= (ssize_t) ((width/2)*(height/2)))\n              {\n                PixelPacket\n                  pixel;\n\n                status=GetOneCacheViewVirtualPixel(pixel_view,(ssize_t)\n                  MagickRound(mean_location.x+u),(ssize_t) MagickRound(\n                  mean_location.y+v),&pixel,exception);\n                distance=(mean_pixel.red-pixel.red)*(mean_pixel.red-pixel.red)+\n                  (mean_pixel.green-pixel.green)*(mean_pixel.green-pixel.green)+\n                  (mean_pixel.blue-pixel.blue)*(mean_pixel.blue-pixel.blue);\n                if (distance <= (color_distance*color_distance))\n                  {\n                    sum_location.x+=mean_location.x+u;\n                    sum_location.y+=mean_location.y+v;\n                    sum_pixel.red+=pixel.red;\n                    sum_pixel.green+=pixel.green;\n                    sum_pixel.blue+=pixel.blue;\n                    sum_pixel.opacity+=pixel.opacity;\n                    count++;\n                  }\n               }\n           }\n         }\n        gamma=1.0/count;\n         mean_location.x=gamma*sum_location.x;\n         mean_location.y=gamma*sum_location.y;\n         mean_pixel.red=gamma*sum_pixel.red;\n        mean_pixel.green=gamma*sum_pixel.green;\n        mean_pixel.blue=gamma*sum_pixel.blue;\n        mean_pixel.opacity=gamma*sum_pixel.opacity;\n        distance=(mean_location.x-previous_location.x)*\n          (mean_location.x-previous_location.x)+\n          (mean_location.y-previous_location.y)*\n          (mean_location.y-previous_location.y)+\n          255.0*QuantumScale*(mean_pixel.red-previous_pixel.red)*\n          255.0*QuantumScale*(mean_pixel.red-previous_pixel.red)+\n          255.0*QuantumScale*(mean_pixel.green-previous_pixel.green)*\n          255.0*QuantumScale*(mean_pixel.green-previous_pixel.green)+\n          255.0*QuantumScale*(mean_pixel.blue-previous_pixel.blue)*\n          255.0*QuantumScale*(mean_pixel.blue-previous_pixel.blue);\n        if (distance <= 3.0)\n          break;\n      }\n      q->red=ClampToQuantum(mean_pixel.red);\n      q->green=ClampToQuantum(mean_pixel.green);\n      q->blue=ClampToQuantum(mean_pixel.blue);\n      q->opacity=ClampToQuantum(mean_pixel.opacity);\n      p++;\n      q++;\n    }\n    if (SyncCacheViewAuthenticPixels(mean_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n#endif\n        progress++;\n        proceed=SetImageProgress(image,MeanShiftImageTag,progress,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  mean_view=DestroyCacheView(mean_view);\n  pixel_view=DestroyCacheView(pixel_view);\n  image_view=DestroyCacheView(image_view);\n  return(mean_image);\n}\n", "target": 1, "idx": 182734}
{"func": "void webkit_web_view_go_forward(WebKitWebView* webView)\n{\n    g_return_if_fail(WEBKIT_IS_WEB_VIEW(webView));\n\n    core(webView)->goForward();\n}\n", "target": 0, "idx": 105460}
{"func": "zisofs_rewind_boot_file(struct archive_write *a)\n{\n\tstruct iso9660 *iso9660 = a->format_data;\n\n\tif (iso9660->el_torito.boot->file->zisofs.header_size != 0) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"We cannot extract the zisofs imaged boot file;\"\n\t\t    \" this may not boot in being zisofs imaged\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\treturn (ARCHIVE_OK);\n}\n", "target": 0, "idx": 50914}
{"func": "TracingController* TracingController::GetInstance() {\n  return TracingControllerImpl::GetInstance();\n}\n", "target": 0, "idx": 141554}
{"func": " device_has_capability (NMDevice *self, NMDeviceCapabilities caps)\n {\n{\n\tstatic guint32 devcount = 0;\n\tNMDevicePrivate *priv;\n\n\tg_return_if_fail (NM_IS_DEVICE (self));\n\n\tpriv = NM_DEVICE_GET_PRIVATE (self);\n\tg_return_if_fail (priv->path == NULL);\n\n\tpriv->path = g_strdup_printf (\"/org/freedesktop/NetworkManager/Devices/%d\", devcount++);\n\t_LOGI (LOGD_DEVICE, \"exported as %s\", priv->path);\n\tnm_dbus_manager_register_object (nm_dbus_manager_get (), priv->path, self);\n}\n\nconst char *\nnm_device_get_path (NMDevice *self)\n{\n\tg_return_val_if_fail (self != NULL, NULL);\n\n\treturn NM_DEVICE_GET_PRIVATE (self)->path;\n}\n\nconst char *\nnm_device_get_udi (NMDevice *self)\n{\n\tg_return_val_if_fail (self != NULL, NULL);\n\n\treturn NM_DEVICE_GET_PRIVATE (self)->udi;\n}\n\nconst char *\nnm_device_get_iface (NMDevice *self)\n{\n\tg_return_val_if_fail (NM_IS_DEVICE (self), 0);\n\n\treturn NM_DEVICE_GET_PRIVATE (self)->iface;\n}\n\nint\nnm_device_get_ifindex (NMDevice *self)\n{\n\tg_return_val_if_fail (self != NULL, 0);\n\n\treturn NM_DEVICE_GET_PRIVATE (self)->ifindex;\n}\n\ngboolean\nnm_device_is_software (NMDevice *self)\n{\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\n\treturn priv->is_software;\n}\n\nconst char *\nnm_device_get_ip_iface (NMDevice *self)\n{\n\tNMDevicePrivate *priv;\n\n\tg_return_val_if_fail (self != NULL, NULL);\n\n\tpriv = NM_DEVICE_GET_PRIVATE (self);\n\t/* If it's not set, default to iface */\n\treturn priv->ip_iface ? priv->ip_iface : priv->iface;\n}\n\nint\nnm_device_get_ip_ifindex (NMDevice *self)\n{\n\tNMDevicePrivate *priv;\n\n\tg_return_val_if_fail (self != NULL, 0);\n\n\tpriv = NM_DEVICE_GET_PRIVATE (self);\n\t/* If it's not set, default to iface */\n\treturn priv->ip_iface ? priv->ip_ifindex : priv->ifindex;\n}\n\nvoid\nnm_device_set_ip_iface (NMDevice *self, const char *iface)\n{\n\tNMDevicePrivate *priv;\n\tchar *old_ip_iface;\n\n\tg_return_if_fail (NM_IS_DEVICE (self));\n\n\tpriv = NM_DEVICE_GET_PRIVATE (self);\n\tif (!g_strcmp0 (iface, priv->ip_iface))\n\t\treturn;\n\n\told_ip_iface = priv->ip_iface;\n\tpriv->ip_ifindex = 0;\n\n\tpriv->ip_iface = g_strdup (iface);\n\tif (priv->ip_iface) {\n\t\tpriv->ip_ifindex = nm_platform_link_get_ifindex (priv->ip_iface);\n\t\tif (priv->ip_ifindex > 0) {\n\t\t\tif (nm_platform_check_support_user_ipv6ll ())\n\t\t\t\tnm_platform_link_set_user_ipv6ll_enabled (priv->ip_ifindex, TRUE);\n\n\t\t\tif (!nm_platform_link_is_up (priv->ip_ifindex))\n\t\t\t\tnm_platform_link_set_up (priv->ip_ifindex);\n\t\t} else {\n\t\t\t/* Device IP interface must always be a kernel network interface */\n\t\t\t_LOGW (LOGD_HW, \"failed to look up interface index\");\n\t\t}\n\t}\n\n\t/* We don't care about any saved values from the old iface */\n\tg_hash_table_remove_all (priv->ip6_saved_properties);\n\n\t/* Emit change notification */\n\tif (g_strcmp0 (old_ip_iface, priv->ip_iface))\n\t\tg_object_notify (G_OBJECT (self), NM_DEVICE_IP_IFACE);\n\tg_free (old_ip_iface);\n}\n\nstatic gboolean\nget_ip_iface_identifier (NMDevice *self, NMUtilsIPv6IfaceId *out_iid)\n{\n\tNMLinkType link_type;\n\tconst guint8 *hwaddr = NULL;\n\tsize_t hwaddr_len = 0;\n\tint ifindex;\n\tgboolean success;\n\n\t/* If we get here, we *must* have a kernel netdev, which implies an ifindex */\n\tifindex = nm_device_get_ip_ifindex (self);\n\tg_assert (ifindex);\n\n\tlink_type = nm_platform_link_get_type (ifindex);\n\tg_return_val_if_fail (link_type > NM_LINK_TYPE_UNKNOWN, 0);\n\n\thwaddr = nm_platform_link_get_address (ifindex, &hwaddr_len);\n\tif (!hwaddr_len)\n\t\treturn FALSE;\n\n\tsuccess = nm_utils_get_ipv6_interface_identifier (link_type,\n\t                                                  hwaddr,\n\t                                                  hwaddr_len,\n\t                                                  out_iid);\n\tif (!success) {\n\t\t_LOGW (LOGD_HW, \"failed to generate interface identifier \"\n\t\t       \"for link type %u hwaddr_len %zu\", link_type, hwaddr_len);\n\t}\n\treturn success;\n}\n\nstatic gboolean\nnm_device_get_ip_iface_identifier (NMDevice *self, NMUtilsIPv6IfaceId *iid)\n{\n\treturn NM_DEVICE_GET_CLASS (self)->get_ip_iface_identifier (self, iid);\n}\n\nconst char *\nnm_device_get_driver (NMDevice *self)\n{\n\tg_return_val_if_fail (self != NULL, NULL);\n\n\treturn NM_DEVICE_GET_PRIVATE (self)->driver;\n}\n\nconst char *\nnm_device_get_driver_version (NMDevice *self)\n{\n\tg_return_val_if_fail (self != NULL, NULL);\n\n\treturn NM_DEVICE_GET_PRIVATE (self)->driver_version;\n}\n\nNMDeviceType\nnm_device_get_device_type (NMDevice *self)\n{\n\tg_return_val_if_fail (NM_IS_DEVICE (self), NM_DEVICE_TYPE_UNKNOWN);\n\n\treturn NM_DEVICE_GET_PRIVATE (self)->type;\n}\n\n\n/**\n * nm_device_get_priority():\n * @self: the #NMDevice\n *\n * Returns: the device's routing priority.  Lower numbers means a \"better\"\n *  device, eg higher priority.\n */\nint\nnm_device_get_priority (NMDevice *self)\n{\n\tg_return_val_if_fail (NM_IS_DEVICE (self), 1000);\n\n\t/* Device 'priority' is used for the default route-metric and is based on\n\t * the device type. The settings ipv4.route-metric and ipv6.route-metric\n\t * can overwrite this default.\n\t *\n\t * Currently for both IPv4 and IPv6 we use the same default values.\n\t *\n\t * The route-metric is used for the metric of the routes of device.\n\t * This also applies to the default route. Therefore it affects also\n\t * which device is the \"best\".\n\t *\n\t * For comparison, note that iproute2 by default adds IPv4 routes with\n\t * metric 0, and IPv6 routes with metric 1024. The latter is the IPv6\n\t * \"user default\" in the kernel (NM_PLATFORM_ROUTE_METRIC_DEFAULT_IP6).\n\t * In kernel, the full uint32_t range is available for route\n\t * metrics (except for IPv6, where 0 means 1024).\n\t */\n\n\tswitch (nm_device_get_device_type (self)) {\n\t/* 50 is reserved for VPN (NM_VPN_ROUTE_METRIC_DEFAULT) */\n\tcase NM_DEVICE_TYPE_ETHERNET:\n\t\treturn 100;\n\tcase NM_DEVICE_TYPE_INFINIBAND:\n\t\treturn 150;\n\tcase NM_DEVICE_TYPE_ADSL:\n\t\treturn 200;\n\tcase NM_DEVICE_TYPE_WIMAX:\n\t\treturn 250;\n\tcase NM_DEVICE_TYPE_BOND:\n\t\treturn 300;\n\tcase NM_DEVICE_TYPE_TEAM:\n\t\treturn 350;\n\tcase NM_DEVICE_TYPE_VLAN:\n\t\treturn 400;\n\tcase NM_DEVICE_TYPE_BRIDGE:\n\t\treturn 425;\n\tcase NM_DEVICE_TYPE_MODEM:\n\t\treturn 450;\n\tcase NM_DEVICE_TYPE_BT:\n\t\treturn 550;\n\tcase NM_DEVICE_TYPE_WIFI:\n\t\treturn 600;\n\tcase NM_DEVICE_TYPE_OLPC_MESH:\n\t\treturn 650;\n\tcase NM_DEVICE_TYPE_GENERIC:\n\t\treturn 950;\n\tcase NM_DEVICE_TYPE_UNKNOWN:\n\t\treturn 10000;\n\tcase NM_DEVICE_TYPE_UNUSED1:\n\tcase NM_DEVICE_TYPE_UNUSED2:\n\t\t/* omit default: to get compiler warning about missing switch cases */\n\t\tbreak;\n\t}\n\treturn 11000;\n}\n\nguint32\nnm_device_get_ip4_route_metric (NMDevice *self)\n{\n\tNMConnection *connection;\n\tgint64 route_metric = -1;\n\n\tg_return_val_if_fail (NM_IS_DEVICE (self), G_MAXUINT32);\n\n\tconnection = nm_device_get_connection (self);\n\n\tif (connection)\n\t\troute_metric = nm_setting_ip_config_get_route_metric (nm_connection_get_setting_ip4_config (connection));\n\n\treturn route_metric >= 0 ? route_metric : nm_device_get_priority (self);\n}\n\nguint32\nnm_device_get_ip6_route_metric (NMDevice *self)\n{\n\tNMConnection *connection;\n\tgint64 route_metric = -1;\n\n\tg_return_val_if_fail (NM_IS_DEVICE (self), G_MAXUINT32);\n\n\tconnection = nm_device_get_connection (self);\n\n\tif (connection)\n\t\troute_metric = nm_setting_ip_config_get_route_metric (nm_connection_get_setting_ip6_config (connection));\n\n\treturn route_metric >= 0 ? route_metric : nm_device_get_priority (self);\n}\n\nconst NMPlatformIP4Route *\nnm_device_get_ip4_default_route (NMDevice *self, gboolean *out_is_assumed)\n{\n\tNMDevicePrivate *priv;\n\n\tg_return_val_if_fail (NM_IS_DEVICE (self), NULL);\n\n\tpriv = NM_DEVICE_GET_PRIVATE (self);\n\n\tif (out_is_assumed)\n\t\t*out_is_assumed = priv->default_route.v4_is_assumed;\n\n\treturn priv->default_route.v4_has ? &priv->default_route.v4 : NULL;\n}\n\nconst NMPlatformIP6Route *\nnm_device_get_ip6_default_route (NMDevice *self, gboolean *out_is_assumed)\n{\n\tNMDevicePrivate *priv;\n\n\tg_return_val_if_fail (NM_IS_DEVICE (self), NULL);\n\n\tpriv = NM_DEVICE_GET_PRIVATE (self);\n\n\tif (out_is_assumed)\n\t\t*out_is_assumed = priv->default_route.v6_is_assumed;\n\n\treturn priv->default_route.v6_has ? &priv->default_route.v6 : NULL;\n}\n\nconst char *\nnm_device_get_type_desc (NMDevice *self)\n{\n\tg_return_val_if_fail (self != NULL, NULL);\n\n\treturn NM_DEVICE_GET_PRIVATE (self)->type_desc;\n}\n\ngboolean\nnm_device_has_carrier (NMDevice *self)\n{\n\treturn NM_DEVICE_GET_PRIVATE (self)->carrier;\n}\n\nNMActRequest *\nnm_device_get_act_request (NMDevice *self)\n{\n\tg_return_val_if_fail (self != NULL, NULL);\n\n\treturn NM_DEVICE_GET_PRIVATE (self)->act_request;\n}\n\nNMConnection *\nnm_device_get_connection (NMDevice *self)\n{\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\n\treturn priv->act_request ? nm_act_request_get_connection (priv->act_request) : NULL;\n}\n\nRfKillType\nnm_device_get_rfkill_type (NMDevice *self)\n{\n\tg_return_val_if_fail (NM_IS_DEVICE (self), FALSE);\n\n\treturn NM_DEVICE_GET_PRIVATE (self)->rfkill_type;\n}\n\nstatic const char *\nnm_device_get_physical_port_id (NMDevice *self)\n{\n\treturn NM_DEVICE_GET_PRIVATE (self)->physical_port_id;\n}\n\n/***********************************************************/\n\nstatic gboolean\nnm_device_uses_generated_assumed_connection (NMDevice *self)\n{\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\tNMConnection *connection;\n\n\tif (   priv->act_request\n\t    && nm_active_connection_get_assumed (NM_ACTIVE_CONNECTION (priv->act_request))) {\n\t\tconnection = nm_act_request_get_connection (priv->act_request);\n\t\tif (   connection\n\t\t    && nm_settings_connection_get_nm_generated_assumed (NM_SETTINGS_CONNECTION (connection)))\n\t\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n\ngboolean\nnm_device_uses_assumed_connection (NMDevice *self)\n{\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\n\tif (   priv->act_request\n\t    && nm_active_connection_get_assumed (NM_ACTIVE_CONNECTION (priv->act_request)))\n\t\treturn TRUE;\n\treturn FALSE;\n}\n\nstatic SlaveInfo *\nfind_slave_info (NMDevice *self, NMDevice *slave)\n{\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\tSlaveInfo *info;\n\tGSList *iter;\n\n\tfor (iter = priv->slaves; iter; iter = g_slist_next (iter)) {\n\t\tinfo = iter->data;\n\t\tif (info->slave == slave)\n\t\t\treturn info;\n\t}\n\treturn NULL;\n}\n\nstatic void\nfree_slave_info (SlaveInfo *info)\n{\n\tg_signal_handler_disconnect (info->slave, info->watch_id);\n\tg_clear_object (&info->slave);\n\tmemset (info, 0, sizeof (*info));\n\tg_free (info);\n}\n\n/**\n * nm_device_enslave_slave:\n * @self: the master device\n * @slave: the slave device to enslave\n * @connection: (allow-none): the slave device's connection\n *\n * If @self is capable of enslaving other devices (ie it's a bridge, bond, team,\n * etc) then this function enslaves @slave.\n *\n * Returns: %TRUE on success, %FALSE on failure or if this device cannot enslave\n *  other devices.\n */\nstatic gboolean\nnm_device_enslave_slave (NMDevice *self, NMDevice *slave, NMConnection *connection)\n{\n\tSlaveInfo *info;\n\tgboolean success = FALSE;\n\tgboolean configure;\n\n\tg_return_val_if_fail (self != NULL, FALSE);\n\tg_return_val_if_fail (slave != NULL, FALSE);\n\tg_return_val_if_fail (NM_DEVICE_GET_CLASS (self)->enslave_slave != NULL, FALSE);\n\n\tinfo = find_slave_info (self, slave);\n\tif (!info)\n\t\treturn FALSE;\n\n\tif (info->enslaved)\n\t\tsuccess = TRUE;\n\telse {\n\t\tconfigure = (info->configure && connection != NULL);\n\t\tif (configure)\n\t\t\tg_return_val_if_fail (nm_device_get_state (slave) >= NM_DEVICE_STATE_DISCONNECTED, FALSE);\n\n\t\tsuccess = NM_DEVICE_GET_CLASS (self)->enslave_slave (self, slave, connection, configure);\n\t\tinfo->enslaved = success;\n\t}\n\n\tnm_device_slave_notify_enslave (info->slave, success);\n\n\t/* Ensure the device's hardware address is up-to-date; it often changes\n\t * when slaves change.\n\t */\n\tnm_device_update_hw_address (self);\n\n\t/* Restart IP configuration if we're waiting for slaves.  Do this\n\t * after updating the hardware address as IP config may need the\n\t * new address.\n\t */\n\tif (success) {\n\t\tif (NM_DEVICE_GET_PRIVATE (self)->ip4_state == IP_WAIT)\n\t\t\tnm_device_activate_stage3_ip4_start (self);\n\n\t\tif (NM_DEVICE_GET_PRIVATE (self)->ip6_state == IP_WAIT)\n\t\t\tnm_device_activate_stage3_ip6_start (self);\n\t}\n\n\treturn success;\n}\n\n/**\n * nm_device_release_one_slave:\n * @self: the master device\n * @slave: the slave device to release\n * @configure: whether @self needs to actually release @slave\n * @reason: the state change reason for the @slave\n *\n * If @self is capable of enslaving other devices (ie it's a bridge, bond, team,\n * etc) then this function releases the previously enslaved @slave and/or\n * updates the state of @self and @slave to reflect its release.\n *\n * Returns: %TRUE on success, %FALSE on failure, if this device cannot enslave\n *  other devices, or if @slave was never enslaved.\n */\nstatic gboolean\nnm_device_release_one_slave (NMDevice *self, NMDevice *slave, gboolean configure, NMDeviceStateReason reason)\n{\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\tSlaveInfo *info;\n\tgboolean success = FALSE;\n\n\tg_return_val_if_fail (slave != NULL, FALSE);\n\tg_return_val_if_fail (NM_DEVICE_GET_CLASS (self)->release_slave != NULL, FALSE);\n\n\tinfo = find_slave_info (self, slave);\n\tif (!info)\n\t\treturn FALSE;\n\tpriv->slaves = g_slist_remove (priv->slaves, info);\n\n\tif (info->enslaved) {\n\t\tsuccess = NM_DEVICE_GET_CLASS (self)->release_slave (self, slave, configure);\n\t\t/* The release_slave() implementation logs success/failure (in the\n\t\t * correct device-specific log domain), so we don't have to do anything.\n\t\t */\n\t}\n\n\tif (!configure) {\n\t\tg_warn_if_fail (reason == NM_DEVICE_STATE_REASON_NONE || reason == NM_DEVICE_STATE_REASON_REMOVED);\n\t\treason = NM_DEVICE_STATE_REASON_NONE;\n\t} else if (reason == NM_DEVICE_STATE_REASON_NONE) {\n\t\tg_warn_if_reached ();\n\t\treason = NM_DEVICE_STATE_REASON_UNKNOWN;\n\t}\n\tnm_device_slave_notify_release (info->slave, reason);\n\n\tfree_slave_info (info);\n\n\t/* Ensure the device's hardware address is up-to-date; it often changes\n\t * when slaves change.\n\t */\n\tnm_device_update_hw_address (self);\n\n\treturn success;\n}\n\nstatic gboolean\nis_software_external (NMDevice *self)\n{\n\treturn   nm_device_is_software (self)\n\t      && !nm_device_get_is_nm_owned (self);\n}\n\n/**\n * nm_device_finish_init:\n * @self: the master device\n *\n * Whatever needs to be done post-initialization, when the device has a DBus\n * object name.\n */\nvoid\nnm_device_finish_init (NMDevice *self)\n{\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\n\tg_assert (priv->initialized == FALSE);\n\n\t/* Do not manage externally created software devices until they are IFF_UP */\n\tif (   is_software_external (self)\n\t    && !nm_platform_link_is_up (priv->ifindex)\n\t    && priv->ifindex > 0)\n\t\tnm_device_set_initial_unmanaged_flag (self, NM_UNMANAGED_EXTERNAL_DOWN, TRUE);\n\n\tif (priv->master)\n\t\tnm_device_enslave_slave (priv->master, self, NULL);\n\n\tpriv->initialized = TRUE;\n}\n\nstatic void\ncarrier_changed (NMDevice *self, gboolean carrier)\n{\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\n\tif (!nm_device_get_managed (self))\n\t\treturn;\n\n\tnm_device_recheck_available_connections (self);\n\n\t/* ignore-carrier devices ignore all carrier-down events */\n\tif (priv->ignore_carrier && !carrier)\n\t\treturn;\n\n\tif (priv->is_master) {\n\t\t/* Bridge/bond/team carrier does not affect its own activation,\n\t\t * but when carrier comes on, if there are slaves waiting,\n\t\t * it will restart them.\n\t\t */\n\t\tif (!carrier)\n\t\t\treturn;\n\n\t\tif (nm_device_activate_ip4_state_in_wait (self))\n\t\t\tnm_device_activate_stage3_ip4_start (self);\n\t\tif (nm_device_activate_ip6_state_in_wait (self))\n\t\t\tnm_device_activate_stage3_ip6_start (self);\n\n\t\treturn;\n\t} else if (nm_device_get_enslaved (self) && !carrier) {\n\t\t/* Slaves don't deactivate when they lose carrier; for\n\t\t * bonds/teams in particular that would be actively\n\t\t * counterproductive.\n\t\t */\n\t\treturn;\n\t}\n\n\tif (carrier) {\n\t\tg_warn_if_fail (priv->state >= NM_DEVICE_STATE_UNAVAILABLE);\n\n\t\tif (priv->state == NM_DEVICE_STATE_UNAVAILABLE) {\n\t\t\tnm_device_queue_state (self, NM_DEVICE_STATE_DISCONNECTED,\n\t\t\t                       NM_DEVICE_STATE_REASON_CARRIER);\n\t\t} else if (priv->state == NM_DEVICE_STATE_DISCONNECTED) {\n\t\t\t/* If the device is already in DISCONNECTED state without a carrier\n\t\t\t * (probably because it is tagged for carrier ignore) ensure that\n\t\t\t * when the carrier appears, auto connections are rechecked for\n\t\t\t * the device.\n\t\t\t */\n\t\t\tnm_device_emit_recheck_auto_activate (self);\n\t\t}\n\t} else {\n\t\tg_return_if_fail (priv->state >= NM_DEVICE_STATE_UNAVAILABLE);\n\n\t\tif (priv->state == NM_DEVICE_STATE_UNAVAILABLE) {\n\t\t\tif (nm_device_queued_state_peek (self) >= NM_DEVICE_STATE_DISCONNECTED)\n\t\t\t\tnm_device_queued_state_clear (self);\n\t\t} else {\n\t\t\tnm_device_queue_state (self, NM_DEVICE_STATE_UNAVAILABLE,\n\t\t\t                       NM_DEVICE_STATE_REASON_CARRIER);\n\t\t}\n\t}\n}\n\n#define LINK_DISCONNECT_DELAY 4\n\nstatic gboolean\nlink_disconnect_action_cb (gpointer user_data)\n{\n\tNMDevice *self = NM_DEVICE (user_data);\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\n\t_LOGD (LOGD_DEVICE, \"link disconnected (calling deferred action) (id=%u)\", priv->carrier_defer_id);\n\n\tpriv->carrier_defer_id = 0;\n\n\t_LOGI (LOGD_DEVICE, \"link disconnected (calling deferred action)\");\n\n\tNM_DEVICE_GET_CLASS (self)->carrier_changed (self, FALSE);\n\n\treturn FALSE;\n}\n\nstatic void\nlink_disconnect_action_cancel (NMDevice *self)\n{\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\n\tif (priv->carrier_defer_id) {\n\t\tg_source_remove (priv->carrier_defer_id);\n\t\t_LOGD (LOGD_DEVICE, \"link disconnected (canceling deferred action) (id=%u)\", priv->carrier_defer_id);\n\t\tpriv->carrier_defer_id = 0;\n\t}\n}\n\nvoid\nnm_device_set_carrier (NMDevice *self, gboolean carrier)\n{\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\tNMDeviceClass *klass = NM_DEVICE_GET_CLASS (self);\n\tNMDeviceState state = nm_device_get_state (self);\n\n\tif (priv->carrier == carrier)\n\t\treturn;\n\n\tpriv->carrier = carrier;\n\tg_object_notify (G_OBJECT (self), NM_DEVICE_CARRIER);\n\n\tif (priv->carrier) {\n\t\t_LOGI (LOGD_DEVICE, \"link connected\");\n\t\tlink_disconnect_action_cancel (self);\n\t\tklass->carrier_changed (self, TRUE);\n\n\t\tif (priv->carrier_wait_id) {\n\t\t\tg_source_remove (priv->carrier_wait_id);\n\t\t\tpriv->carrier_wait_id = 0;\n\t\t\tnm_device_remove_pending_action (self, \"carrier wait\", TRUE);\n\t\t\t_carrier_wait_check_queued_act_request (self);\n\t\t}\n\t} else if (state <= NM_DEVICE_STATE_DISCONNECTED) {\n\t\t_LOGI (LOGD_DEVICE, \"link disconnected\");\n\t\tklass->carrier_changed (self, FALSE);\n\t} else {\n\t\t_LOGI (LOGD_DEVICE, \"link disconnected (deferring action for %d seconds)\", LINK_DISCONNECT_DELAY);\n\t\tpriv->carrier_defer_id = g_timeout_add_seconds (LINK_DISCONNECT_DELAY,\n\t\t                                                link_disconnect_action_cb, self);\n\t\t_LOGD (LOGD_DEVICE, \"link disconnected (deferring action for %d seconds) (id=%u)\",\n\t\t       LINK_DISCONNECT_DELAY, priv->carrier_defer_id);\n\t}\n}\n\nstatic void\nupdate_for_ip_ifname_change (NMDevice *self)\n{\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\n\tg_hash_table_remove_all (priv->ip6_saved_properties);\n\n\tif (priv->dhcp4_client) {\n\t\tif (!nm_device_dhcp4_renew (self, FALSE)) {\n\t\t\tnm_device_state_changed (self,\n\t\t\t                         NM_DEVICE_STATE_FAILED,\n\t\t\t                         NM_DEVICE_STATE_REASON_DHCP_FAILED);\n\t\t\treturn;\n\t\t}\n\t}\n\tif (priv->dhcp6_client) {\n\t\tif (!nm_device_dhcp6_renew (self, FALSE)) {\n\t\t\tnm_device_state_changed (self,\n\t\t\t                         NM_DEVICE_STATE_FAILED,\n\t\t\t                         NM_DEVICE_STATE_REASON_DHCP_FAILED);\n\t\t\treturn;\n\t\t}\n\t}\n\tif (priv->rdisc) {\n\t\t/* FIXME: todo */\n\t}\n\tif (priv->dnsmasq_manager) {\n\t\t/* FIXME: todo */\n\t}\n}\n\nstatic void\ndevice_set_master (NMDevice *self, int ifindex)\n{\n\tNMDevice *master;\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\n\tmaster = nm_manager_get_device_by_ifindex (nm_manager_get (), ifindex);\n\tif (master && NM_DEVICE_GET_CLASS (master)->enslave_slave) {\n\t\tg_clear_object (&priv->master);\n\t\tpriv->master = g_object_ref (master);\n\t\tnm_device_master_add_slave (master, self, FALSE);\n\t} else if (master) {\n\t\t_LOGI (LOGD_DEVICE, \"enslaved to non-master-type device %s; ignoring\",\n\t\t       nm_device_get_iface (master));\n\t} else {\n\t\t_LOGW (LOGD_DEVICE, \"enslaved to unknown device %d %s\",\n\t\t       ifindex,\n\t\t       nm_platform_link_get_name (ifindex));\n\t}\n}\n\nstatic void\ndevice_link_changed (NMDevice *self, NMPlatformLink *info)\n{\n\tNMDeviceClass *klass = NM_DEVICE_GET_CLASS (self);\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\tNMUtilsIPv6IfaceId token_iid;\n\tgboolean ip_ifname_changed = FALSE;\n\n\tif (info->udi && g_strcmp0 (info->udi, priv->udi)) {\n\t\t/* Update UDI to what udev gives us */\n\t\tg_free (priv->udi);\n\t\tpriv->udi = g_strdup (info->udi);\n\t\tg_object_notify (G_OBJECT (self), NM_DEVICE_UDI);\n\t}\n\n\t/* Update MTU if it has changed. */\n\tif (priv->mtu != info->mtu) {\n\t\tpriv->mtu = info->mtu;\n\t\tg_object_notify (G_OBJECT (self), NM_DEVICE_MTU);\n\t}\n\n\tif (info->name[0] && strcmp (priv->iface, info->name) != 0) {\n\t\t_LOGI (LOGD_DEVICE, \"interface index %d renamed iface from '%s' to '%s'\",\n\t\t       priv->ifindex, priv->iface, info->name);\n\t\tg_free (priv->iface);\n\t\tpriv->iface = g_strdup (info->name);\n\n\t\t/* If the device has no explicit ip_iface, then changing iface changes ip_iface too. */\n\t\tip_ifname_changed = !priv->ip_iface;\n\n\t\tg_object_notify (G_OBJECT (self), NM_DEVICE_IFACE);\n\t\tif (ip_ifname_changed)\n\t\t\tg_object_notify (G_OBJECT (self), NM_DEVICE_IP_IFACE);\n\n\t\t/* Re-match available connections against the new interface name */\n\t\tnm_device_recheck_available_connections (self);\n\n\t\t/* Let any connections that use the new interface name have a chance\n\t\t * to auto-activate on the device.\n\t\t */\n\t\tnm_device_emit_recheck_auto_activate (self);\n\t}\n\n\t/* Update slave status for external changes */\n\tif (priv->enslaved && info->master != nm_device_get_ifindex (priv->master))\n\t\tnm_device_release_one_slave (priv->master, self, FALSE, NM_DEVICE_STATE_REASON_NONE);\n\tif (info->master && !priv->enslaved) {\n\t\tdevice_set_master (self, info->master);\n\t\tif (priv->master)\n\t\t\tnm_device_enslave_slave (priv->master, self, NULL);\n\t}\n\n\tif (priv->rdisc && nm_platform_link_get_ipv6_token (priv->ifindex, &token_iid)) {\n\t\t_LOGD (LOGD_DEVICE, \"IPv6 tokenized identifier present on device %s\", priv->iface);\n\t\tif (nm_rdisc_set_iid (priv->rdisc, token_iid))\n\t\t\tnm_rdisc_start (priv->rdisc);\n\t}\n\n\tif (klass->link_changed)\n\t\tklass->link_changed (self, info);\n\n\t/* Update DHCP, etc, if needed */\n\tif (ip_ifname_changed)\n\t\tupdate_for_ip_ifname_change (self);\n\n\tif (priv->up != info->up) {\n\t\tpriv->up = info->up;\n\n\t\t/* Manage externally-created software interfaces only when they are IFF_UP */\n\t\tg_assert (priv->ifindex > 0);\n\t\tif (is_software_external (self)) {\n\t\t\tgboolean external_down = nm_device_get_unmanaged_flag (self, NM_UNMANAGED_EXTERNAL_DOWN);\n\n\t\t\tif (external_down && info->up) {\n\t\t\t\tif (nm_device_get_state (self) < NM_DEVICE_STATE_DISCONNECTED) {\n\t\t\t\t\t/* Ensure the assume check is queued before any queued state changes\n\t\t\t\t\t * from the transition to UNAVAILABLE.\n\t\t\t\t\t */\n\t\t\t\t\tnm_device_queue_recheck_assume (self);\n\n\t\t\t\t\t/* Resetting the EXTERNAL_DOWN flag may change the device's state\n\t\t\t\t\t * to UNAVAILABLE.  To ensure that the state change doesn't touch\n\t\t\t\t\t * the device before assumption occurs, pass\n\t\t\t\t\t * NM_DEVICE_STATE_REASON_CONNECTION_ASSUMED as the reason.\n\t\t\t\t\t */\n\t\t\t\t\tnm_device_set_unmanaged (self,\n\t\t\t\t\t                         NM_UNMANAGED_EXTERNAL_DOWN,\n\t\t\t\t\t                         FALSE,\n\t\t\t\t\t                         NM_DEVICE_STATE_REASON_CONNECTION_ASSUMED);\n\t\t\t\t} else {\n\t\t\t\t\t/* Don't trigger a state change; if the device is in a\n\t\t\t\t\t * state higher than UNAVAILABLE, it is already IFF_UP\n\t\t\t\t\t * or an explicit activation request was received.\n\t\t\t\t\t */\n\t\t\t\t\tpriv->unmanaged_flags &= ~NM_UNMANAGED_EXTERNAL_DOWN;\n\t\t\t\t}\n\t\t\t} else if (!external_down && !info->up && nm_device_get_state (self) <= NM_DEVICE_STATE_DISCONNECTED) {\n\t\t\t\t/* If the device is already disconnected and is set !IFF_UP,\n\t\t\t\t * unmanage it.\n\t\t\t\t */\n\t\t\t\tnm_device_set_unmanaged (self,\n\t\t\t\t                         NM_UNMANAGED_EXTERNAL_DOWN,\n\t\t\t\t                         TRUE,\n\t\t\t\t                         NM_DEVICE_STATE_REASON_USER_REQUESTED);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void\ndevice_ip_link_changed (NMDevice *self, NMPlatformLink *info)\n{\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\n\tif (info->name[0] && g_strcmp0 (priv->ip_iface, info->name)) {\n\t\t_LOGI (LOGD_DEVICE, \"interface index %d renamed ip_iface (%d) from '%s' to '%s'\",\n\t\t       priv->ifindex, nm_device_get_ip_ifindex (self),\n\t\t       priv->ip_iface, info->name);\n\t\tg_free (priv->ip_iface);\n\t\tpriv->ip_iface = g_strdup (info->name);\n\n\t\tg_object_notify (G_OBJECT (self), NM_DEVICE_IP_IFACE);\n\t\tupdate_for_ip_ifname_change (self);\n\t}\n}\n\nstatic void\nlink_changed_cb (NMPlatform *platform,\n                 int ifindex,\n                 NMPlatformLink *info,\n                 NMPlatformSignalChangeType change_type,\n                 NMPlatformReason reason,\n                 NMDevice *self)\n{\n\tif (change_type != NM_PLATFORM_SIGNAL_CHANGED)\n\t\treturn;\n\n\t/* We don't filter by 'reason' because we are interested in *all* link\n\t * changes. For example a call to nm_platform_link_set_up() may result\n\t * in an internal carrier change (i.e. we ask the kernel to set IFF_UP\n\t * and it results in also setting IFF_LOWER_UP.\n\t */\n\n\tif (ifindex == nm_device_get_ifindex (self))\n\t\tdevice_link_changed (self, info);\n\telse if (ifindex == nm_device_get_ip_ifindex (self))\n\t\tdevice_ip_link_changed (self, info);\n}\n\nstatic void\nlink_changed (NMDevice *self, NMPlatformLink *info)\n{\n\t/* Update carrier from link event if applicable. */\n\tif (   device_has_capability (self, NM_DEVICE_CAP_CARRIER_DETECT)\n\t    && !device_has_capability (self, NM_DEVICE_CAP_NONSTANDARD_CARRIER))\n\t\tnm_device_set_carrier (self, info->connected);\n}\n\n/**\n * nm_device_notify_component_added():\n * @self: the #NMDevice\n * @component: the component being added by a plugin\n *\n * Called by the manager to notify the device that a new component has\n * been found.  The device implementation should return %TRUE if it\n * wishes to claim the component, or %FALSE if it cannot.\n *\n * Returns: %TRUE to claim the component, %FALSE if the component cannot be\n * claimed.\n */\ngboolean\nnm_device_notify_component_added (NMDevice *self, GObject *component)\n{\n\tif (NM_DEVICE_GET_CLASS (self)->component_added)\n\t\treturn NM_DEVICE_GET_CLASS (self)->component_added (self, component);\n\treturn FALSE;\n}\n\n/**\n * nm_device_owns_iface():\n * @self: the #NMDevice\n * @iface: an interface name\n *\n * Called by the manager to ask if the device or any of its components owns\n * @iface.  For example, a WWAN implementation would return %TRUE for an\n * ethernet interface name that was owned by the WWAN device's modem component,\n * because that ethernet interface is controlled by the WWAN device and cannot\n * be used independently of the WWAN device.\n *\n * Returns: %TRUE if @self or it's components owns the interface name,\n * %FALSE if not\n */\ngboolean\nnm_device_owns_iface (NMDevice *self, const char *iface)\n{\n\tif (NM_DEVICE_GET_CLASS (self)->owns_iface)\n\t\treturn NM_DEVICE_GET_CLASS (self)->owns_iface (self, iface);\n\treturn FALSE;\n}\n\nNMConnection *\nnm_device_new_default_connection (NMDevice *self)\n{\n\tif (NM_DEVICE_GET_CLASS (self)->new_default_connection)\n\t\treturn NM_DEVICE_GET_CLASS (self)->new_default_connection (self);\n\treturn NULL;\n}\n\nstatic void\nslave_state_changed (NMDevice *slave,\n                     NMDeviceState slave_new_state,\n                     NMDeviceState slave_old_state,\n                     NMDeviceStateReason reason,\n                     NMDevice *self)\n{\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\tgboolean release = FALSE;\n\n\t_LOGD (LOGD_DEVICE, \"slave %s state change %d (%s) -> %d (%s)\",\n\t       nm_device_get_iface (slave),\n\t       slave_old_state,\n\t       state_to_string (slave_old_state),\n\t       slave_new_state,\n\t       state_to_string (slave_new_state));\n\n\t/* Don't try to enslave slaves until the master is ready */\n\tif (priv->state < NM_DEVICE_STATE_CONFIG)\n\t\treturn;\n\n\tif (slave_new_state == NM_DEVICE_STATE_IP_CONFIG)\n\t\tnm_device_enslave_slave (self, slave, nm_device_get_connection (slave));\n\telse if (slave_new_state > NM_DEVICE_STATE_ACTIVATED)\n\t\trelease = TRUE;\n\telse if (   slave_new_state <= NM_DEVICE_STATE_DISCONNECTED\n\t         && slave_old_state > NM_DEVICE_STATE_DISCONNECTED) {\n\t\t/* Catch failures due to unavailable or unmanaged */\n\t\trelease = TRUE;\n\t}\n\n\tif (release) {\n\t\tnm_device_release_one_slave (self, slave, TRUE, reason);\n\t\t/* Bridge/bond/team interfaces are left up until manually deactivated */\n\t\tif (priv->slaves == NULL && priv->state == NM_DEVICE_STATE_ACTIVATED)\n\t\t\t_LOGD (LOGD_DEVICE, \"last slave removed; remaining activated\");\n\t}\n}\n\n/**\n * nm_device_master_add_slave:\n * @self: the master device\n * @slave: the slave device to enslave\n * @configure: pass %TRUE if the slave should be configured by the master, or\n * %FALSE if it is already configured outside NetworkManager\n *\n * If @self is capable of enslaving other devices (ie it's a bridge, bond, team,\n * etc) then this function adds @slave to the slave list for later enslavement.\n *\n * Returns: %TRUE on success, %FALSE on failure\n */\nstatic gboolean\nnm_device_master_add_slave (NMDevice *self, NMDevice *slave, gboolean configure)\n{\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\tSlaveInfo *info;\n\n\tg_return_val_if_fail (self != NULL, FALSE);\n\tg_return_val_if_fail (slave != NULL, FALSE);\n\tg_return_val_if_fail (NM_DEVICE_GET_CLASS (self)->enslave_slave != NULL, FALSE);\n\n\tif (configure)\n\t\tg_return_val_if_fail (nm_device_get_state (slave) >= NM_DEVICE_STATE_DISCONNECTED, FALSE);\n\n\tif (!find_slave_info (self, slave)) {\n\t\tinfo = g_malloc0 (sizeof (SlaveInfo));\n\t\tinfo->slave = g_object_ref (slave);\n\t\tinfo->configure = configure;\n\t\tinfo->watch_id = g_signal_connect (slave, \"state-changed\",\n\t\t                                   G_CALLBACK (slave_state_changed), self);\n\t\tpriv->slaves = g_slist_append (priv->slaves, info);\n\t}\n\tnm_device_queue_recheck_assume (self);\n\n\treturn TRUE;\n}\n\n\n/**\n * nm_device_master_get_slaves:\n * @self: the master device\n *\n * Returns: any slaves of which @self is the master.  Caller owns returned list.\n */\nGSList *\nnm_device_master_get_slaves (NMDevice *self)\n{\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\tGSList *slaves = NULL, *iter;\n\n\tfor (iter = priv->slaves; iter; iter = g_slist_next (iter))\n\t\tslaves = g_slist_prepend (slaves, ((SlaveInfo *) iter->data)->slave);\n\n\treturn slaves;\n}\n\n/**\n * nm_device_master_get_slave_by_ifindex:\n * @self: the master device\n * @ifindex: the slave's interface index\n *\n * Returns: the slave with the given @ifindex of which @self is the master,\n *   or %NULL if no device with @ifindex is a slave of @self.\n */\nNMDevice *\nnm_device_master_get_slave_by_ifindex (NMDevice *self, int ifindex)\n{\n\tGSList *iter;\n\n\tfor (iter = NM_DEVICE_GET_PRIVATE (self)->slaves; iter; iter = g_slist_next (iter)) {\n\t\tSlaveInfo *info = iter->data;\n\n\t\tif (nm_device_get_ip_ifindex (info->slave) == ifindex)\n\t\t\treturn info->slave;\n\t}\n\treturn NULL;\n}\n\n/**\n * nm_device_master_check_slave_physical_port:\n * @self: the master device\n * @slave: a slave device\n * @log_domain: domain to log a warning in\n *\n * Checks if @self already has a slave with the same #NMDevice:physical-port-id\n * as @slave, and logs a warning if so.\n */\nvoid\nnm_device_master_check_slave_physical_port (NMDevice *self, NMDevice *slave,\n                                            guint64 log_domain)\n{\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\tconst char *slave_physical_port_id, *existing_physical_port_id;\n\tSlaveInfo *info;\n\tGSList *iter;\n\n\tslave_physical_port_id = nm_device_get_physical_port_id (slave);\n\tif (!slave_physical_port_id)\n\t\treturn;\n\n\tfor (iter = priv->slaves; iter; iter = iter->next) {\n\t\tinfo = iter->data;\n\t\tif (info->slave == slave)\n\t\t\tcontinue;\n\n\t\texisting_physical_port_id = nm_device_get_physical_port_id (info->slave);\n\t\tif (!g_strcmp0 (slave_physical_port_id, existing_physical_port_id)) {\n\t\t\t_LOGW (log_domain, \"slave %s shares a physical port with existing slave %s\",\n\t\t\t       nm_device_get_ip_iface (slave),\n\t\t\t       nm_device_get_ip_iface (info->slave));\n\t\t\t/* Since this function will get called for every slave, we only have\n\t\t\t * to warn about the first match we find; if there are other matches\n\t\t\t * later in the list, we will have already warned about them matching\n\t\t\t * @existing earlier.\n\t\t\t */\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n/* release all slaves */\nstatic void\nnm_device_master_release_slaves (NMDevice *self)\n{\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\tNMDeviceStateReason reason;\n\n\t/* Don't release the slaves if this connection doesn't belong to NM. */\n\tif (nm_device_uses_generated_assumed_connection (self))\n\t\treturn;\n\n\treason = priv->state_reason;\n\tif (priv->state == NM_DEVICE_STATE_FAILED)\n\t\treason = NM_DEVICE_STATE_REASON_DEPENDENCY_FAILED;\n\n\twhile (priv->slaves) {\n\t\tSlaveInfo *info = priv->slaves->data;\n\n\t\tnm_device_release_one_slave (self, info->slave, TRUE, reason);\n\t}\n}\n\n/**\n * nm_device_get_master:\n * @self: the device\n *\n * If @self has been enslaved by another device, this returns that\n * device. Otherwise it returns %NULL. (In particular, note that if\n * @self is in the process of activating as a slave, but has not yet\n * been enslaved by its master, this will return %NULL.)\n *\n * Returns: (transfer none): @self's master, or %NULL\n */\nNMDevice *\nnm_device_get_master (NMDevice *self)\n{\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\n\tif (priv->enslaved)\n\t\treturn priv->master;\n\telse\n\t\treturn NULL;\n}\n\n/**\n * nm_device_slave_notify_enslave:\n * @self: the slave device\n * @success: whether the enslaving operation succeeded\n *\n * Notifies a slave that either it has been enslaved, or else its master tried\n * to enslave it and failed.\n */\nstatic void\nnm_device_slave_notify_enslave (NMDevice *self, gboolean success)\n{\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\tNMConnection *connection = nm_device_get_connection (self);\n\tgboolean activating = (priv->state == NM_DEVICE_STATE_IP_CONFIG);\n\n\tg_assert (priv->master);\n\n\tif (!priv->enslaved) {\n\t\tif (success) {\n\t\t\tif (activating) {\n\t\t\t\t_LOGI (LOGD_DEVICE, \"Activation: connection '%s' enslaved, continuing activation\",\n\t\t\t\t       nm_connection_get_id (connection));\n\t\t\t} else\n\t\t\t\t_LOGI (LOGD_DEVICE, \"enslaved to %s\", nm_device_get_iface (priv->master));\n\n\t\t\tpriv->enslaved = TRUE;\n\t\t\tg_object_notify (G_OBJECT (self), NM_DEVICE_MASTER);\n\t\t} else if (activating) {\n\t\t\t_LOGW (LOGD_DEVICE, \"Activation: connection '%s' could not be enslaved\",\n\t\t\t       nm_connection_get_id (connection));\n\t\t}\n\t}\n\n\tif (activating) {\n\t\tpriv->ip4_state = IP_DONE;\n\t\tpriv->ip6_state = IP_DONE;\n\t\tnm_device_queue_state (self,\n\t\t                       success ? NM_DEVICE_STATE_SECONDARIES : NM_DEVICE_STATE_FAILED,\n\t\t                       NM_DEVICE_STATE_REASON_NONE);\n\t} else\n\t\tnm_device_queue_recheck_assume (self);\n}\n\n/**\n * nm_device_slave_notify_release:\n * @self: the slave device\n * @reason: the reason associated with the state change\n *\n * Notifies a slave that it has been released, and why.\n */\nstatic void\nnm_device_slave_notify_release (NMDevice *self, NMDeviceStateReason reason)\n{\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\tNMConnection *connection = nm_device_get_connection (self);\n\tNMDeviceState new_state;\n\tconst char *master_status;\n\n\tif (   reason != NM_DEVICE_STATE_REASON_NONE\n\t    && priv->state > NM_DEVICE_STATE_DISCONNECTED\n\t    && priv->state <= NM_DEVICE_STATE_ACTIVATED) {\n\t\tif (reason == NM_DEVICE_STATE_REASON_DEPENDENCY_FAILED) {\n\t\t\tnew_state = NM_DEVICE_STATE_FAILED;\n\t\t\tmaster_status = \"failed\";\n\t\t} else if (reason == NM_DEVICE_STATE_REASON_USER_REQUESTED) {\n\t\t\tnew_state = NM_DEVICE_STATE_DEACTIVATING;\n\t\t\tmaster_status = \"deactivated by user request\";\n\t\t} else {\n\t\t\tnew_state = NM_DEVICE_STATE_DISCONNECTED;\n\t\t\tmaster_status = \"deactivated\";\n\t\t}\n\n\t\t_LOGD (LOGD_DEVICE, \"Activation: connection '%s' master %s\",\n\t\t       nm_connection_get_id (connection),\n\t\t       master_status);\n\n\t\tnm_device_queue_state (self, new_state, reason);\n\t} else if (priv->master)\n\t\t_LOGI (LOGD_DEVICE, \"released from master %s\", nm_device_get_iface (priv->master));\n\telse\n\t\t_LOGD (LOGD_DEVICE, \"released from master%s\", priv->enslaved ? \"\" : \" (was not enslaved)\");\n\n\tif (priv->enslaved) {\n\t\tpriv->enslaved = FALSE;\n\t\tg_object_notify (G_OBJECT (self), NM_DEVICE_MASTER);\n\t}\n}\n\n/**\n * nm_device_get_enslaved:\n * @self: the #NMDevice\n *\n * Returns: %TRUE if the device is enslaved to a master device (eg bridge or\n * bond or team), %FALSE if not\n */\ngboolean\nnm_device_get_enslaved (NMDevice *self)\n{\n\treturn NM_DEVICE_GET_PRIVATE (self)->enslaved;\n}\n\n/**\n * nm_device_removed:\n * @self: the #NMDevice\n *\n * Called by the manager when the device was removed. Releases the device from\n * the master in case it's enslaved.\n */\nvoid\nnm_device_removed (NMDevice *self)\n{\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\n\tif (priv->enslaved)\n\t\tnm_device_release_one_slave (priv->master, self, FALSE, NM_DEVICE_STATE_REASON_REMOVED);\n}\n\n\nstatic gboolean\nis_available (NMDevice *self, NMDeviceCheckDevAvailableFlags flags)\n{\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\n\tif (priv->carrier || priv->ignore_carrier)\n\t\treturn TRUE;\n\n\tif (NM_FLAGS_HAS (flags, NM_DEVICE_CHECK_DEV_AVAILABLE_IGNORE_CARRIER))\n\t\treturn TRUE;\n\n\treturn FALSE;\n}\n\n/**\n * nm_device_is_available:\n * @self: the #NMDevice\n * @flags: additional flags to influence the check. Flags have the\n *   meaning to increase the availability of a device.\n *\n * Checks if @self would currently be capable of activating a\n * connection. In particular, it checks that the device is ready (eg,\n * is not missing firmware), that it has carrier (if necessary), and\n * that any necessary external software (eg, ModemManager,\n * wpa_supplicant) is available.\n *\n * @self can only be in a state higher than\n * %NM_DEVICE_STATE_UNAVAILABLE when nm_device_is_available() returns\n * %TRUE. (But note that it can still be %NM_DEVICE_STATE_UNMANAGED\n * when it is available.)\n *\n * Returns: %TRUE or %FALSE\n */\ngboolean\nnm_device_is_available (NMDevice *self, NMDeviceCheckDevAvailableFlags flags)\n{\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\n\tif (priv->firmware_missing)\n\t\treturn FALSE;\n\n\treturn NM_DEVICE_GET_CLASS (self)->is_available (self, flags);\n}\n\ngboolean\nnm_device_get_enabled (NMDevice *self)\n{\n\tg_return_val_if_fail (NM_IS_DEVICE (self), FALSE);\n\n\tif (NM_DEVICE_GET_CLASS (self)->get_enabled)\n\t\treturn NM_DEVICE_GET_CLASS (self)->get_enabled (self);\n\treturn TRUE;\n}\n\nvoid\nnm_device_set_enabled (NMDevice *self, gboolean enabled)\n{\n\tg_return_if_fail (NM_IS_DEVICE (self));\n\n\tif (NM_DEVICE_GET_CLASS (self)->set_enabled)\n\t\tNM_DEVICE_GET_CLASS (self)->set_enabled (self, enabled);\n}\n\n/**\n * nm_device_get_autoconnect:\n * @self: the #NMDevice\n *\n * Returns: %TRUE if the device allows autoconnect connections, or %FALSE if the\n * device is explicitly blocking all autoconnect connections.  Does not take\n * into account transient conditions like companion devices that may wish to\n * block the device.\n */\ngboolean\nnm_device_get_autoconnect (NMDevice *self)\n{\n\tg_return_val_if_fail (NM_IS_DEVICE (self), FALSE);\n\n\treturn NM_DEVICE_GET_PRIVATE (self)->autoconnect;\n}\n\nstatic void\nnm_device_set_autoconnect (NMDevice *self, gboolean autoconnect)\n{\n\tNMDevicePrivate *priv;\n\n\tg_return_if_fail (NM_IS_DEVICE (self));\n\n\tpriv = NM_DEVICE_GET_PRIVATE (self);\n\tif (priv->autoconnect == autoconnect)\n\t\treturn;\n\n\tif (autoconnect) {\n\t\t/* Default-unmanaged devices never autoconnect */\n\t\tif (!nm_device_get_default_unmanaged (self)) {\n\t\t\tpriv->autoconnect = TRUE;\n\t\t\tg_object_notify (G_OBJECT (self), NM_DEVICE_AUTOCONNECT);\n\t\t}\n\t} else {\n\t\tpriv->autoconnect = FALSE;\n\t\tg_object_notify (G_OBJECT (self), NM_DEVICE_AUTOCONNECT);\n\t}\n}\n\nstatic gboolean\nautoconnect_allowed_accumulator (GSignalInvocationHint *ihint,\n                                 GValue *return_accu,\n                                 const GValue *handler_return, gpointer data)\n{\n\tif (!g_value_get_boolean (handler_return))\n\t\tg_value_set_boolean (return_accu, FALSE);\n\treturn TRUE;\n}\n\n/**\n * nm_device_autoconnect_allowed:\n * @self: the #NMDevice\n *\n * Returns: %TRUE if the device can be auto-connected immediately, taking\n * transient conditions into account (like companion devices that may wish to\n * block autoconnect for a time).\n */\ngboolean\nnm_device_autoconnect_allowed (NMDevice *self)\n{\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\tGValue instance = G_VALUE_INIT;\n\tGValue retval = G_VALUE_INIT;\n\n\tif (priv->state < NM_DEVICE_STATE_DISCONNECTED || !priv->autoconnect)\n\t\treturn FALSE;\n\n\t/* The 'autoconnect-allowed' signal is emitted on a device to allow\n\t * other listeners to block autoconnect on the device if they wish.\n\t * This is mainly used by the OLPC Mesh devices to block autoconnect\n\t * on their companion WiFi device as they share radio resources and\n\t * cannot be connected at the same time.\n\t */\n\n\tg_value_init (&instance, G_TYPE_OBJECT);\n\tg_value_set_object (&instance, self);\n\n\tg_value_init (&retval, G_TYPE_BOOLEAN);\n\tif (priv->autoconnect)\n\t\tg_value_set_boolean (&retval, TRUE);\n\telse\n\t\tg_value_set_boolean (&retval, FALSE);\n\n\t/* Use g_signal_emitv() rather than g_signal_emit() to avoid the return\n\t * value being changed if no handlers are connected */\n\tg_signal_emitv (&instance, signals[AUTOCONNECT_ALLOWED], 0, &retval);\n\tg_value_unset (&instance);\n\treturn g_value_get_boolean (&retval);\n}\n\nstatic gboolean\ncan_auto_connect (NMDevice *self,\n                  NMConnection *connection,\n                  char **specific_object)\n{\n\tNMSettingConnection *s_con;\n\n\ts_con = nm_connection_get_setting_connection (connection);\n\tif (!nm_setting_connection_get_autoconnect (s_con))\n\t\treturn FALSE;\n\n\treturn nm_device_check_connection_available (self, connection, NM_DEVICE_CHECK_CON_AVAILABLE_NONE, NULL);\n}\n\n/**\n * nm_device_can_auto_connect:\n * @self: an #NMDevice\n * @connection: a #NMConnection\n * @specific_object: (out) (transfer full): on output, the path of an\n *   object associated with the returned connection, to be passed to\n *   nm_manager_activate_connection(), or %NULL.\n *\n * Checks if @connection can be auto-activated on @self right now.\n * This requires, at a minimum, that the connection be compatible with\n * @self, and that it have the #NMSettingConnection:autoconnect property\n * set, and that the device allow auto connections. Some devices impose\n * additional requirements. (Eg, a Wi-Fi connection can only be activated\n * if its SSID was seen in the last scan.)\n *\n * Returns: %TRUE, if the @connection can be auto-activated.\n **/\ngboolean\nnm_device_can_auto_connect (NMDevice *self,\n                            NMConnection *connection,\n                            char **specific_object)\n{\n\tg_return_val_if_fail (NM_IS_DEVICE (self), FALSE);\n\tg_return_val_if_fail (NM_IS_CONNECTION (connection), FALSE);\n\tg_return_val_if_fail (specific_object && !*specific_object, FALSE);\n\n\tif (nm_device_autoconnect_allowed (self))\n\t\treturn NM_DEVICE_GET_CLASS (self)->can_auto_connect (self, connection, specific_object);\n\treturn FALSE;\n}\n\nstatic gboolean\ndevice_has_config (NMDevice *self)\n{\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\n\t/* Check for IP configuration. */\n\tif (priv->ip4_config && nm_ip4_config_get_num_addresses (priv->ip4_config))\n\t\treturn TRUE;\n\tif (priv->ip6_config && nm_ip6_config_get_num_addresses (priv->ip6_config))\n\t\treturn TRUE;\n\n\t/* The existence of a software device is good enough. */\n\tif (nm_device_is_software (self))\n\t\treturn TRUE;\n\n\t/* Slaves are also configured by definition */\n\tif (nm_platform_link_get_master (priv->ifindex) > 0)\n\t\treturn TRUE;\n\n\treturn FALSE;\n}\n\n/**\n * nm_device_master_update_slave_connection:\n * @self: the master #NMDevice\n * @slave: the slave #NMDevice\n * @connection: the #NMConnection to update with the slave settings\n * @GError: (out): error description\n *\n * Reads the slave configuration for @slave and updates @connection with those\n * properties. This invokes a virtual function on the master device @self.\n *\n * Returns: %TRUE if the configuration was read and @connection updated,\n * %FALSE on failure.\n */\ngboolean\nnm_device_master_update_slave_connection (NMDevice *self,\n                                          NMDevice *slave,\n                                          NMConnection *connection,\n                                          GError **error)\n{\n\tNMDeviceClass *klass;\n\tgboolean success;\n\n\tg_return_val_if_fail (self, FALSE);\n\tg_return_val_if_fail (NM_IS_DEVICE (self), FALSE);\n\tg_return_val_if_fail (slave, FALSE);\n\tg_return_val_if_fail (connection, FALSE);\n\tg_return_val_if_fail (!error || !*error, FALSE);\n\tg_return_val_if_fail (nm_connection_get_setting_connection (connection), FALSE);\n\n\tg_return_val_if_fail (nm_device_get_iface (self), FALSE);\n\n\tklass = NM_DEVICE_GET_CLASS (self);\n\tif (klass->master_update_slave_connection) {\n\t\tsuccess = klass->master_update_slave_connection (self, slave, connection, error);\n\n\t\tg_return_val_if_fail (!error || (success && !*error) || *error, success);\n\t\treturn success;\n\t}\n\n\tg_set_error (error,\n\t             NM_DEVICE_ERROR,\n\t             NM_DEVICE_ERROR_FAILED,\n\t             \"master device '%s' cannot update a slave connection for slave device '%s' (master type not supported?)\",\n\t             nm_device_get_iface (self), nm_device_get_iface (slave));\n\treturn FALSE;\n}\n\nNMConnection *\nnm_device_generate_connection (NMDevice *self, NMDevice *master)\n{\n\tNMDeviceClass *klass = NM_DEVICE_GET_CLASS (self);\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\tconst char *ifname = nm_device_get_iface (self);\n\tNMConnection *connection;\n\tNMSetting *s_con;\n\tNMSetting *s_ip4;\n\tNMSetting *s_ip6;\n\tgs_free char *uuid = NULL;\n\tconst char *ip4_method, *ip6_method;\n\tGError *error = NULL;\n\n\t/* If update_connection() is not implemented, just fail. */\n\tif (!klass->update_connection)\n\t\treturn NULL;\n\n\t/* Return NULL if device is unconfigured. */\n\tif (!device_has_config (self)) {\n\t\t_LOGD (LOGD_DEVICE, \"device has no existing configuration\");\n\t\treturn NULL;\n\t}\n\n\tconnection = nm_simple_connection_new ();\n\ts_con = nm_setting_connection_new ();\n\tuuid = nm_utils_uuid_generate ();\n\n\tg_object_set (s_con,\n\t              NM_SETTING_CONNECTION_UUID, uuid,\n\t              NM_SETTING_CONNECTION_ID, ifname,\n\t              NM_SETTING_CONNECTION_AUTOCONNECT, FALSE,\n\t              NM_SETTING_CONNECTION_INTERFACE_NAME, ifname,\n\t              NM_SETTING_CONNECTION_TIMESTAMP, (guint64) time (NULL),\n\t              NULL);\n\tif (klass->connection_type)\n\t\tg_object_set (s_con, NM_SETTING_CONNECTION_TYPE, klass->connection_type, NULL);\n\tnm_connection_add_setting (connection, s_con);\n\n\t/* If the device is a slave, update various slave settings */\n\tif (master) {\n\t\tif (!nm_device_master_update_slave_connection (master,\n\t\t                                               self,\n\t\t                                               connection,\n\t\t                                               &error))\n\t\t{\n\t\t\t_LOGE (LOGD_DEVICE, \"master device '%s' failed to update slave connection: %s\",\n\t\t\t       nm_device_get_iface (master), error ? error->message : \"(unknown error)\");\n\t\t\tg_error_free (error);\n\t\t\tg_object_unref (connection);\n\t\t\treturn NULL;\n\t\t}\n\t} else {\n\t\t/* Only regular and master devices get IP configuration; slaves do not */\n\t\ts_ip4 = nm_ip4_config_create_setting (priv->ip4_config);\n\t\tnm_connection_add_setting (connection, s_ip4);\n\n\t\ts_ip6 = nm_ip6_config_create_setting (priv->ip6_config);\n\t\tnm_connection_add_setting (connection, s_ip6);\n\t}\n\n\tklass->update_connection (self, connection);\n\n\t/* Check the connection in case of update_connection() bug. */\n\tif (!nm_connection_verify (connection, &error)) {\n\t\t_LOGE (LOGD_DEVICE, \"Generated connection does not verify: %s\", error->message);\n\t\tg_clear_error (&error);\n\t\tg_object_unref (connection);\n\t\treturn NULL;\n\t}\n\n\t/* Ignore the connection if it has no IP configuration,\n\t * no slave configuration, and is not a master interface.\n\t */\n\tip4_method = nm_utils_get_ip_config_method (connection, NM_TYPE_SETTING_IP4_CONFIG);\n\tip6_method = nm_utils_get_ip_config_method (connection, NM_TYPE_SETTING_IP6_CONFIG);\n\tif (   g_strcmp0 (ip4_method, NM_SETTING_IP4_CONFIG_METHOD_DISABLED) == 0\n\t    && g_strcmp0 (ip6_method, NM_SETTING_IP6_CONFIG_METHOD_IGNORE) == 0\n\t    && !nm_setting_connection_get_master (NM_SETTING_CONNECTION (s_con))\n\t    && !priv->slaves) {\n\t\t_LOGD (LOGD_DEVICE, \"ignoring generated connection (no IP and not in master-slave relationship)\");\n\t\tg_object_unref (connection);\n\t\tconnection = NULL;\n\t}\n\n\treturn connection;\n}\n\ngboolean\nnm_device_complete_connection (NMDevice *self,\n                               NMConnection *connection,\n                               const char *specific_object,\n                               const GSList *existing_connections,\n                               GError **error)\n{\n\tgboolean success = FALSE;\n\n\tg_return_val_if_fail (self != NULL, FALSE);\n\tg_return_val_if_fail (connection != NULL, FALSE);\n\n\tif (!NM_DEVICE_GET_CLASS (self)->complete_connection) {\n\t\tg_set_error (error, NM_DEVICE_ERROR, NM_DEVICE_ERROR_INVALID_CONNECTION,\n\t\t             \"Device class %s had no complete_connection method\",\n\t\t             G_OBJECT_TYPE_NAME (self));\n\t\treturn FALSE;\n\t}\n\n\tsuccess = NM_DEVICE_GET_CLASS (self)->complete_connection (self,\n\t                                                           connection,\n\t                                                           specific_object,\n\t                                                           existing_connections,\n\t                                                           error);\n\tif (success)\n\t\tsuccess = nm_connection_verify (connection, error);\n\n\treturn success;\n}\n\nstatic gboolean\ncheck_connection_compatible (NMDevice *self, NMConnection *connection)\n{\n\tNMSettingConnection *s_con;\n\tconst char *config_iface, *device_iface;\n\n\ts_con = nm_connection_get_setting_connection (connection);\n\tg_assert (s_con);\n\n\tconfig_iface = nm_setting_connection_get_interface_name (s_con);\n\tdevice_iface = nm_device_get_iface (self);\n\tif (config_iface && strcmp (config_iface, device_iface) != 0)\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n\n/**\n * nm_device_check_connection_compatible:\n * @self: an #NMDevice\n * @connection: an #NMConnection\n *\n * Checks if @connection could potentially be activated on @self.\n * This means only that @self has the proper capabilities, and that\n * @connection is not locked to some other device. It does not\n * necessarily mean that @connection could be activated on @self\n * right now. (Eg, it might refer to a Wi-Fi network that is not\n * currently available.)\n *\n * Returns: #TRUE if @connection could potentially be activated on\n *   @self.\n */\ngboolean\nnm_device_check_connection_compatible (NMDevice *self, NMConnection *connection)\n{\n\tg_return_val_if_fail (NM_IS_DEVICE (self), FALSE);\n\tg_return_val_if_fail (NM_IS_CONNECTION (connection), FALSE);\n\n\treturn NM_DEVICE_GET_CLASS (self)->check_connection_compatible (self, connection);\n}\n\n/**\n * nm_device_can_assume_connections:\n * @self: #NMDevice instance\n *\n * This is a convenience function to determine whether connection assumption\n * is available for this device.\n *\n * Returns: %TRUE if the device is capable of assuming connections, %FALSE if not\n */\nstatic gboolean\nnm_device_can_assume_connections (NMDevice *self)\n{\n\treturn !!NM_DEVICE_GET_CLASS (self)->update_connection;\n}\n\n/**\n * nm_device_can_assume_active_connection:\n * @self: #NMDevice instance\n *\n * This is a convenience function to determine whether the device's active\n * connection can be assumed if NetworkManager restarts.  This method returns\n * %TRUE if and only if the device can assume connections, and the device has\n * an active connection, and that active connection can be assumed.\n *\n * Returns: %TRUE if the device's active connection can be assumed, or %FALSE\n * if there is no active connection or the active connection cannot be\n * assumed.\n */\ngboolean\nnm_device_can_assume_active_connection (NMDevice *self)\n{\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\tNMConnection *connection;\n\tconst char *method;\n\tconst char *assumable_ip6_methods[] = {\n\t\tNM_SETTING_IP6_CONFIG_METHOD_IGNORE,\n\t\tNM_SETTING_IP6_CONFIG_METHOD_AUTO,\n\t\tNM_SETTING_IP6_CONFIG_METHOD_DHCP,\n\t\tNM_SETTING_IP6_CONFIG_METHOD_LINK_LOCAL,\n\t\tNM_SETTING_IP6_CONFIG_METHOD_MANUAL,\n\t\tNULL\n\t};\n\tconst char *assumable_ip4_methods[] = {\n\t\tNM_SETTING_IP4_CONFIG_METHOD_DISABLED,\n\t\tNM_SETTING_IP6_CONFIG_METHOD_AUTO,\n\t\tNM_SETTING_IP6_CONFIG_METHOD_MANUAL,\n\t\tNULL\n\t};\n\n\tif (!nm_device_can_assume_connections (self))\n\t\treturn FALSE;\n\n\tconnection = nm_device_get_connection (self);\n\tif (!connection)\n\t\treturn FALSE;\n\n\t/* Can't assume connections that aren't yet configured\n\t * FIXME: what about bridges/bonds waiting for slaves?\n\t */\n\tif (priv->state < NM_DEVICE_STATE_IP_CONFIG)\n\t\treturn FALSE;\n\tif (priv->ip4_state != IP_DONE && priv->ip6_state != IP_DONE)\n\t\treturn FALSE;\n\n\tmethod = nm_utils_get_ip_config_method (connection, NM_TYPE_SETTING_IP6_CONFIG);\n\tif (!_nm_utils_string_in_list (method, assumable_ip6_methods))\n\t\treturn FALSE;\n\n\tmethod = nm_utils_get_ip_config_method (connection, NM_TYPE_SETTING_IP4_CONFIG);\n\tif (!_nm_utils_string_in_list (method, assumable_ip4_methods))\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n\nstatic gboolean\nnm_device_emit_recheck_assume (gpointer self)\n{\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\n\tpriv->recheck_assume_id = 0;\n\tif (!nm_device_get_act_request (self)) {\n\t\t_LOGD (LOGD_DEVICE, \"emit RECHECK_ASSUME signal\");\n\t\tg_signal_emit (self, signals[RECHECK_ASSUME], 0);\n\t}\n\treturn G_SOURCE_REMOVE;\n}\n\nvoid\nnm_device_queue_recheck_assume (NMDevice *self)\n{\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\n\tif (nm_device_can_assume_connections (self) && !priv->recheck_assume_id)\n\t\tpriv->recheck_assume_id = g_idle_add (nm_device_emit_recheck_assume, self);\n}\n\nvoid\nnm_device_emit_recheck_auto_activate (NMDevice *self)\n{\n\tg_signal_emit (self, signals[RECHECK_AUTO_ACTIVATE], 0);\n}\n\nstatic void\ndnsmasq_state_changed_cb (NMDnsMasqManager *manager, guint32 status, gpointer user_data)\n{\n\tNMDevice *self = NM_DEVICE (user_data);\n\n\tswitch (status) {\n\tcase NM_DNSMASQ_STATUS_DEAD:\n\t\tnm_device_state_changed (self, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_SHARED_START_FAILED);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void\nactivation_source_clear (NMDevice *self, gboolean remove_source, int family)\n{\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\tguint *act_source_id;\n\tgpointer *act_source_func;\n\n\tif (family == AF_INET6) {\n\t\tact_source_id = &priv->act_source6_id;\n\t\tact_source_func = &priv->act_source6_func;\n\t} else {\n\t\tact_source_id = &priv->act_source_id;\n\t\tact_source_func = &priv->act_source_func;\n\t}\n\n\tif (*act_source_id) {\n\t\tif (remove_source)\n\t\t\tg_source_remove (*act_source_id);\n\t\t*act_source_id = 0;\n\t\t*act_source_func = NULL;\n\t}\n}\n\nstatic void\nactivation_source_schedule (NMDevice *self, GSourceFunc func, int family)\n{\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\tguint *act_source_id;\n\tgpointer *act_source_func;\n\n\tif (family == AF_INET6) {\n\t\tact_source_id = &priv->act_source6_id;\n\t\tact_source_func = &priv->act_source6_func;\n\t} else {\n\t\tact_source_id = &priv->act_source_id;\n\t\tact_source_func = &priv->act_source_func;\n\t}\n\n\tif (*act_source_id)\n\t\t_LOGE (LOGD_DEVICE, \"activation stage already scheduled\");\n\n\t/* Don't bother rescheduling the same function that's about to\n\t * run anyway.  Fixes issues with crappy wireless drivers sending\n\t * streams of associate events before NM has had a chance to process\n\t * the first one.\n\t */\n\tif (!*act_source_id || (*act_source_func != func)) {\n\t\tactivation_source_clear (self, TRUE, family);\n\t\t*act_source_id = g_idle_add (func, self);\n\t\t*act_source_func = func;\n\t}\n}\n\nstatic gboolean\nget_ip_config_may_fail (NMDevice *self, int family)\n{\n\tNMConnection *connection;\n\tNMSettingIPConfig *s_ip = NULL;\n\n\tg_return_val_if_fail (self != NULL, TRUE);\n\n\tconnection = nm_device_get_connection (self);\n\tg_assert (connection);\n\n\t/* Fail the connection if the failed IP method is required to complete */\n\tswitch (family) {\n\tcase AF_INET:\n\t\ts_ip = nm_connection_get_setting_ip4_config (connection);\n\t\tbreak;\n\tcase AF_INET6:\n\t\ts_ip = nm_connection_get_setting_ip6_config (connection);\n\t\tbreak;\n\tdefault:\n\t\tg_assert_not_reached ();\n\t}\n\n\treturn nm_setting_ip_config_get_may_fail (s_ip);\n}\n\nstatic void\nmaster_ready_cb (NMActiveConnection *active,\n                 GParamSpec *pspec,\n                 NMDevice *self)\n{\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\tNMActiveConnection *master;\n\n\tg_assert (priv->state == NM_DEVICE_STATE_PREPARE);\n\n\t/* Notify a master device that it has a new slave */\n\tg_assert (nm_active_connection_get_master_ready (active));\n\tmaster = nm_active_connection_get_master (active);\n\n\tpriv->master = g_object_ref (nm_active_connection_get_device (master));\n\tnm_device_master_add_slave (priv->master,\n\t                            self,\n\t                            nm_active_connection_get_assumed (active) ? FALSE : TRUE);\n\n\t_LOGD (LOGD_DEVICE, \"master connection ready; master device %s\",\n\t       nm_device_get_iface (priv->master));\n\n\tif (priv->master_ready_id) {\n\t\tg_signal_handler_disconnect (active, priv->master_ready_id);\n\t\tpriv->master_ready_id = 0;\n\t}\n\n\tnm_device_activate_schedule_stage2_device_config (self);\n}\n\nstatic NMActStageReturn\nact_stage1_prepare (NMDevice *self, NMDeviceStateReason *reason)\n{\n\treturn NM_ACT_STAGE_RETURN_SUCCESS;\n}\n\n/*\n * nm_device_activate_stage1_device_prepare\n *\n * Prepare for device activation\n *\n */\nstatic gboolean\nnm_device_activate_stage1_device_prepare (gpointer user_data)\n{\n\tNMDevice *self = NM_DEVICE (user_data);\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\tNMActStageReturn ret = NM_ACT_STAGE_RETURN_SUCCESS;\n\tNMDeviceStateReason reason = NM_DEVICE_STATE_REASON_NONE;\n\tNMActiveConnection *active = NM_ACTIVE_CONNECTION (priv->act_request);\n\n\t/* Clear the activation source ID now that this stage has run */\n\tactivation_source_clear (self, FALSE, 0);\n\n\tpriv->ip4_state = priv->ip6_state = IP_NONE;\n\n\t/* Notify the new ActiveConnection along with the state change */\n\tg_object_notify (G_OBJECT (self), NM_DEVICE_ACTIVE_CONNECTION);\n\n\t_LOGI (LOGD_DEVICE, \"Activation: Stage 1 of 5 (Device Prepare) started...\");\n\tnm_device_state_changed (self, NM_DEVICE_STATE_PREPARE, NM_DEVICE_STATE_REASON_NONE);\n\n\t/* Assumed connections were already set up outside NetworkManager */\n\tif (!nm_active_connection_get_assumed (active)) {\n\t\tret = NM_DEVICE_GET_CLASS (self)->act_stage1_prepare (self, &reason);\n\t\tif (ret == NM_ACT_STAGE_RETURN_POSTPONE) {\n\t\t\tgoto out;\n\t\t} else if (ret == NM_ACT_STAGE_RETURN_FAILURE) {\n\t\t\tnm_device_state_changed (self, NM_DEVICE_STATE_FAILED, reason);\n\t\t\tgoto out;\n\t\t}\n\t\tg_assert (ret == NM_ACT_STAGE_RETURN_SUCCESS);\n\t}\n\n\tif (nm_active_connection_get_master (active)) {\n\t\t/* If the master connection is ready for slaves, attach ourselves */\n\t\tif (nm_active_connection_get_master_ready (active))\n\t\t\tmaster_ready_cb (active, NULL, self);\n\t\telse {\n\t\t\t_LOGD (LOGD_DEVICE, \"waiting for master connection to become ready\");\n\n\t\t\t/* Attach a signal handler and wait for the master connection to begin activating */\n\t\t\tg_assert (priv->master_ready_id == 0);\n\t\t\tpriv->master_ready_id = g_signal_connect (active,\n\t\t\t                                          \"notify::\" NM_ACTIVE_CONNECTION_INT_MASTER_READY,\n\t\t\t                                          (GCallback) master_ready_cb,\n\t\t\t                                          self);\n\t\t\t/* Postpone */\n\t\t}\n\t} else\n\t\tnm_device_activate_schedule_stage2_device_config (self);\n\nout:\n\t_LOGI (LOGD_DEVICE, \"Activation: Stage 1 of 5 (Device Prepare) complete.\");\n\treturn FALSE;\n}\n\n\n/*\n * nm_device_activate_schedule_stage1_device_prepare\n *\n * Prepare a device for activation\n *\n */\nvoid\nnm_device_activate_schedule_stage1_device_prepare (NMDevice *self)\n{\n\tNMDevicePrivate *priv;\n\n\tg_return_if_fail (NM_IS_DEVICE (self));\n\n\tpriv = NM_DEVICE_GET_PRIVATE (self);\n\tg_return_if_fail (priv->act_request);\n\n\tactivation_source_schedule (self, nm_device_activate_stage1_device_prepare, 0);\n\n\t_LOGI (LOGD_DEVICE, \"Activation: Stage 1 of 5 (Device Prepare) scheduled...\");\n}\n\nstatic NMActStageReturn\nact_stage2_config (NMDevice *self, NMDeviceStateReason *reason)\n{\n\t/* Nothing to do */\n\treturn NM_ACT_STAGE_RETURN_SUCCESS;\n}\n\n/*\n * nm_device_activate_stage2_device_config\n *\n * Determine device parameters and set those on the device, ie\n * for wireless devices, set SSID, keys, etc.\n *\n */\nstatic gboolean\nnm_device_activate_stage2_device_config (gpointer user_data)\n{\n\tNMDevice *self = NM_DEVICE (user_data);\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\tNMActStageReturn ret;\n\tNMDeviceStateReason reason = NM_DEVICE_STATE_REASON_NONE;\n\tgboolean no_firmware = FALSE;\n\tNMActiveConnection *active = NM_ACTIVE_CONNECTION (priv->act_request);\n\tGSList *iter;\n\n\t/* Clear the activation source ID now that this stage has run */\n\tactivation_source_clear (self, FALSE, 0);\n\n\t_LOGI (LOGD_DEVICE, \"Activation: Stage 2 of 5 (Device Configure) starting...\");\n\tnm_device_state_changed (self, NM_DEVICE_STATE_CONFIG, NM_DEVICE_STATE_REASON_NONE);\n\n\t/* Assumed connections were already set up outside NetworkManager */\n\tif (!nm_active_connection_get_assumed (active)) {\n\t\tif (!nm_device_bring_up (self, FALSE, &no_firmware)) {\n\t\t\tif (no_firmware)\n\t\t\t\tnm_device_state_changed (self, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_FIRMWARE_MISSING);\n\t\t\telse\n\t\t\t\tnm_device_state_changed (self, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_CONFIG_FAILED);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = NM_DEVICE_GET_CLASS (self)->act_stage2_config (self, &reason);\n\t\tif (ret == NM_ACT_STAGE_RETURN_POSTPONE)\n\t\t\tgoto out;\n\t\telse if (ret == NM_ACT_STAGE_RETURN_FAILURE) {\n\t\t\tnm_device_state_changed (self, NM_DEVICE_STATE_FAILED, reason);\n\t\t\tgoto out;\n\t\t}\n\t\tg_assert (ret == NM_ACT_STAGE_RETURN_SUCCESS);\n\t}\n\n\t/* If we have slaves that aren't yet enslaved, do that now */\n\tfor (iter = priv->slaves; iter; iter = g_slist_next (iter)) {\n\t\tSlaveInfo *info = iter->data;\n\t\tNMDeviceState slave_state = nm_device_get_state (info->slave);\n\n\t\tif (slave_state == NM_DEVICE_STATE_IP_CONFIG)\n\t\t\tnm_device_enslave_slave (self, info->slave, nm_device_get_connection (info->slave));\n\t\telse if (   nm_device_uses_generated_assumed_connection (self)\n\t\t         && slave_state <= NM_DEVICE_STATE_DISCONNECTED)\n\t\t\tnm_device_queue_recheck_assume (info->slave);\n\t}\n\n\t_LOGI (LOGD_DEVICE, \"Activation: Stage 2 of 5 (Device Configure) successful.\");\n\n\tnm_device_activate_schedule_stage3_ip_config_start (self);\n\nout:\n\t_LOGI (LOGD_DEVICE, \"Activation: Stage 2 of 5 (Device Configure) complete.\");\n\treturn FALSE;\n}\n\n\n/*\n * nm_device_activate_schedule_stage2_device_config\n *\n * Schedule setup of the hardware device\n *\n */\nvoid\nnm_device_activate_schedule_stage2_device_config (NMDevice *self)\n{\n\tNMDevicePrivate *priv;\n\n\tg_return_if_fail (NM_IS_DEVICE (self));\n\n\tpriv = NM_DEVICE_GET_PRIVATE (self);\n\tg_return_if_fail (priv->act_request);\n\n\tactivation_source_schedule (self, nm_device_activate_stage2_device_config, 0);\n\n\t_LOGI (LOGD_DEVICE, \"Activation: Stage 2 of 5 (Device Configure) scheduled...\");\n}\n\n/*********************************************/\n/* avahi-autoipd stuff */\n\nstatic void\naipd_timeout_remove (NMDevice *self)\n{\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\n\tif (priv->aipd_timeout) {\n\t\tg_source_remove (priv->aipd_timeout);\n\t\tpriv->aipd_timeout = 0;\n\t}\n}\n\nstatic void\naipd_cleanup (NMDevice *self)\n{\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\n\tif (priv->aipd_watch) {\n\t\tg_source_remove (priv->aipd_watch);\n\t\tpriv->aipd_watch = 0;\n\t}\n\n\tif (priv->aipd_pid > 0) {\n\t\tnm_utils_kill_child_sync (priv->aipd_pid, SIGKILL, LOGD_AUTOIP4, \"avahi-autoipd\", NULL, 0, 0);\n\t\tpriv->aipd_pid = -1;\n\t}\n\n\taipd_timeout_remove (self);\n}\n\nstatic NMIP4Config *\naipd_get_ip4_config (NMDevice *self, guint32 lla)\n{\n\tNMIP4Config *config = NULL;\n\tNMPlatformIP4Address address;\n\tNMPlatformIP4Route route;\n\n\tconfig = nm_ip4_config_new (nm_device_get_ip_ifindex (self));\n\tg_assert (config);\n\n\tmemset (&address, 0, sizeof (address));\n\taddress.address = lla;\n\taddress.plen = 16;\n\taddress.source = NM_IP_CONFIG_SOURCE_IP4LL;\n\tnm_ip4_config_add_address (config, &address);\n\n\t/* Add a multicast route for link-local connections: destination= 224.0.0.0, netmask=240.0.0.0 */\n\tmemset (&route, 0, sizeof (route));\n\troute.network = htonl (0xE0000000L);\n\troute.plen = 4;\n\troute.source = NM_IP_CONFIG_SOURCE_IP4LL;\n\troute.metric = nm_device_get_ip4_route_metric (self);\n\tnm_ip4_config_add_route (config, &route);\n\n\treturn config;\n}\n\n#define IPV4LL_NETWORK (htonl (0xA9FE0000L))\n#define IPV4LL_NETMASK (htonl (0xFFFF0000L))\n\nvoid\nnm_device_handle_autoip4_event (NMDevice *self,\n                                const char *event,\n                                const char *address)\n{\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\tNMConnection *connection = NULL;\n\tconst char *method;\n\tNMDeviceStateReason reason = NM_DEVICE_STATE_REASON_NONE;\n\n\tg_return_if_fail (event != NULL);\n\n\tif (priv->act_request == NULL)\n\t\treturn;\n\n\tconnection = nm_act_request_get_connection (priv->act_request);\n\tg_assert (connection);\n\n\t/* Ignore if the connection isn't an AutoIP connection */\n\tmethod = nm_utils_get_ip_config_method (connection, NM_TYPE_SETTING_IP4_CONFIG);\n\tif (g_strcmp0 (method, NM_SETTING_IP4_CONFIG_METHOD_LINK_LOCAL) != 0)\n\t\treturn;\n\n\tif (strcmp (event, \"BIND\") == 0) {\n\t\tguint32 lla;\n\t\tNMIP4Config *config;\n\n\t\tif (inet_pton (AF_INET, address, &lla) <= 0) {\n\t\t\t_LOGE (LOGD_AUTOIP4, \"invalid address %s received from avahi-autoipd.\", address);\n\t\t\tnm_device_state_changed (self, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_AUTOIP_ERROR);\n\t\t\treturn;\n\t\t}\n\n\t\tif ((lla & IPV4LL_NETMASK) != IPV4LL_NETWORK) {\n\t\t\t_LOGE (LOGD_AUTOIP4, \"invalid address %s received from avahi-autoipd (not link-local).\", address);\n\t\t\tnm_device_state_changed (self, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_AUTOIP_ERROR);\n\t\t\treturn;\n\t\t}\n\n\t\tconfig = aipd_get_ip4_config (self, lla);\n\t\tif (config == NULL) {\n\t\t\t_LOGE (LOGD_AUTOIP4, \"failed to get autoip config\");\n\t\t\tnm_device_state_changed (self, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_IP_CONFIG_UNAVAILABLE);\n\t\t\treturn;\n\t\t}\n\n\t\tif (priv->ip4_state == IP_CONF) {\n\t\t\taipd_timeout_remove (self);\n\t\t\tnm_device_activate_schedule_ip4_config_result (self, config);\n\t\t} else if (priv->ip4_state == IP_DONE) {\n\t\t\tif (!ip4_config_merge_and_apply (self, config, TRUE, &reason)) {\n\t\t\t\t_LOGE (LOGD_AUTOIP4, \"failed to update IP4 config for autoip change.\");\n\t\t\t\tnm_device_state_changed (self, NM_DEVICE_STATE_FAILED, reason);\n\t\t\t}\n\t\t} else\n\t\t\tg_assert_not_reached ();\n\n\t\tg_object_unref (config);\n\t} else {\n\t\t_LOGW (LOGD_AUTOIP4, \"autoip address %s no longer valid because '%s'.\", address, event);\n\n\t\t/* The address is gone; terminate the connection or fail activation */\n\t\tnm_device_state_changed (self, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_IP_CONFIG_EXPIRED);\n\t}\n}\n\nstatic void\naipd_watch_cb (GPid pid, gint status, gpointer user_data)\n{\n\tNMDevice *self = NM_DEVICE (user_data);\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\tNMDeviceState state;\n\n\tif (!priv->aipd_watch)\n\t\treturn;\n\tpriv->aipd_watch = 0;\n\n\tif (WIFEXITED (status))\n\t\t_LOGD (LOGD_AUTOIP4, \"avahi-autoipd exited with error code %d\", WEXITSTATUS (status));\n\telse if (WIFSTOPPED (status))\n\t\t_LOGW (LOGD_AUTOIP4, \"avahi-autoipd stopped unexpectedly with signal %d\", WSTOPSIG (status));\n\telse if (WIFSIGNALED (status))\n\t\t_LOGW (LOGD_AUTOIP4, \"avahi-autoipd died with signal %d\", WTERMSIG (status));\n\telse\n\t\t_LOGW (LOGD_AUTOIP4, \"avahi-autoipd died from an unknown cause\");\n\n\taipd_cleanup (self);\n\n\tstate = nm_device_get_state (self);\n\tif (nm_device_is_activating (self) || (state == NM_DEVICE_STATE_ACTIVATED))\n\t\tnm_device_state_changed (self, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_AUTOIP_FAILED);\n}\n\nstatic gboolean\naipd_timeout_cb (gpointer user_data)\n{\n\tNMDevice *self = NM_DEVICE (user_data);\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\n\tif (priv->aipd_timeout) {\n\t\t_LOGI (LOGD_AUTOIP4, \"avahi-autoipd timed out.\");\n\t\tpriv->aipd_timeout = 0;\n\t\taipd_cleanup (self);\n\n\t\tif (priv->ip4_state == IP_CONF)\n\t\t\tnm_device_activate_schedule_ip4_config_timeout (self);\n\t}\n\n\treturn FALSE;\n}\n\n/* default to installed helper, but can be modified for testing */\nconst char *nm_device_autoipd_helper_path = LIBEXECDIR \"/nm-avahi-autoipd.action\";\n\nstatic NMActStageReturn\naipd_start (NMDevice *self, NMDeviceStateReason *reason)\n{\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\tconst char *argv[6];\n\tchar *cmdline;\n\tconst char *aipd_binary;\n\tint i = 0;\n\tGError *error = NULL;\n\n\taipd_cleanup (self);\n\n\t/* Find avahi-autoipd */\n\taipd_binary = nm_utils_find_helper (\"avahi-autoipd\", NULL, NULL);\n\tif (!aipd_binary) {\n\t\t_LOGW (LOGD_DEVICE | LOGD_AUTOIP4,\n\t\t       \"Activation: Stage 3 of 5 (IP Configure Start) failed\"\n\t\t       \" to start avahi-autoipd: not found\");\n\t\t*reason = NM_DEVICE_STATE_REASON_AUTOIP_START_FAILED;\n\t\treturn NM_ACT_STAGE_RETURN_FAILURE;\n\t}\n\n\targv[i++] = aipd_binary;\n\targv[i++] = \"--script\";\n\targv[i++] = nm_device_autoipd_helper_path;\n\n\tif (nm_logging_enabled (LOGL_DEBUG, LOGD_AUTOIP4))\n\t\targv[i++] = \"--debug\";\n\targv[i++] = nm_device_get_ip_iface (self);\n\targv[i++] = NULL;\n\n\tcmdline = g_strjoinv (\" \", (char **) argv);\n\t_LOGD (LOGD_AUTOIP4, \"running: %s\", cmdline);\n\tg_free (cmdline);\n\n\tif (!g_spawn_async (\"/\", (char **) argv, NULL, G_SPAWN_DO_NOT_REAP_CHILD,\n\t                    nm_utils_setpgid, NULL, &(priv->aipd_pid), &error)) {\n\t\t_LOGW (LOGD_DEVICE | LOGD_AUTOIP4,\n\t\t       \"Activation: Stage 3 of 5 (IP Configure Start) failed\"\n\t\t       \" to start avahi-autoipd: %s\",\n\t\t       error && error->message ? error->message : \"(unknown)\");\n\t\tg_clear_error (&error);\n\t\taipd_cleanup (self);\n\t\treturn NM_ACT_STAGE_RETURN_FAILURE;\n\t}\n\n\t_LOGI (LOGD_DEVICE | LOGD_AUTOIP4,\n\t       \"Activation: Stage 3 of 5 (IP Configure Start) started\"\n\t       \" avahi-autoipd...\");\n\n\t/* Monitor the child process so we know when it dies */\n\tpriv->aipd_watch = g_child_watch_add (priv->aipd_pid, aipd_watch_cb, self);\n\n\t/* Start a timeout to bound the address attempt */\n\tpriv->aipd_timeout = g_timeout_add_seconds (20, aipd_timeout_cb, self);\n\n\treturn NM_ACT_STAGE_RETURN_POSTPONE;\n}\n\n/*********************************************/\n\nstatic gboolean\n_device_get_default_route_from_platform (NMDevice *self, int addr_family, NMPlatformIPRoute *out_route)\n{\n\tgboolean success = FALSE;\n\tint ifindex = nm_device_get_ip_ifindex (self);\n\tGArray *routes;\n\n\tif (addr_family == AF_INET)\n\t\troutes = nm_platform_ip4_route_get_all (ifindex, NM_PLATFORM_GET_ROUTE_MODE_ONLY_DEFAULT);\n\telse\n\t\troutes = nm_platform_ip6_route_get_all (ifindex, NM_PLATFORM_GET_ROUTE_MODE_ONLY_DEFAULT);\n\n\tif (routes) {\n\t\tguint route_metric = G_MAXUINT32, m;\n\t\tconst NMPlatformIPRoute *route = NULL, *r;\n\t\tguint i;\n\n\t\t/* if there are several default routes, find the one with the best metric */\n\t\tfor (i = 0; i < routes->len; i++) {\n\t\t\tif (addr_family == AF_INET) {\n\t\t\t\tr = (const NMPlatformIPRoute *) &g_array_index (routes, NMPlatformIP4Route, i);\n\t\t\t\tm = r->metric;\n\t\t\t} else {\n\t\t\t\tr = (const NMPlatformIPRoute *) &g_array_index (routes, NMPlatformIP6Route, i);\n\t\t\t\tm = nm_utils_ip6_route_metric_normalize (r->metric);\n\t\t\t}\n\t\t\tif (!route || m < route_metric) {\n\t\t\t\troute = r;\n\t\t\t\troute_metric = m;\n\t\t\t}\n\t\t}\n\n\t\tif (route) {\n\t\t\tif (addr_family == AF_INET)\n\t\t\t\t*((NMPlatformIP4Route *) out_route) = *((NMPlatformIP4Route *) route);\n\t\t\telse\n\t\t\t\t*((NMPlatformIP6Route *) out_route) = *((NMPlatformIP6Route *) route);\n\t\t\tsuccess = TRUE;\n\t\t}\n\t\tg_array_free (routes, TRUE);\n\t}\n\treturn success;\n}\n\n/*********************************************/\n\nstatic void\nensure_con_ipx_config (NMDevice *self)\n{\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\tint ip_ifindex = nm_device_get_ip_ifindex (self);\n\tNMConnection *connection;\n\n\tg_assert (!!priv->con_ip4_config == !!priv->con_ip6_config);\n\n\tif (priv->con_ip4_config)\n\t\treturn;\n\n\tconnection = nm_device_get_connection (self);\n\tif (!connection)\n\t\treturn;\n\n\tpriv->con_ip4_config = nm_ip4_config_new (ip_ifindex);\n\tpriv->con_ip6_config = nm_ip6_config_new (ip_ifindex);\n\n\tnm_ip4_config_merge_setting (priv->con_ip4_config,\n\t                             nm_connection_get_setting_ip4_config (connection),\n\t                             nm_device_get_ip4_route_metric (self));\n\tnm_ip6_config_merge_setting (priv->con_ip6_config,\n\t                             nm_connection_get_setting_ip6_config (connection),\n\t                             nm_device_get_ip6_route_metric (self));\n\n\tif (nm_device_uses_assumed_connection (self)) {\n\t\t/* For assumed connections ignore all addresses and routes. */\n\t\tnm_ip4_config_reset_addresses (priv->con_ip4_config);\n\t\tnm_ip4_config_reset_routes (priv->con_ip4_config);\n\n\t\tnm_ip6_config_reset_addresses (priv->con_ip6_config);\n\t\tnm_ip6_config_reset_routes (priv->con_ip6_config);\n\t}\n}\n\n/*********************************************/\n/* DHCPv4 stuff */\n\nstatic void\ndhcp4_cleanup (NMDevice *self, gboolean stop, gboolean release)\n{\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\n\tif (priv->dhcp4_client) {\n\t\t/* Stop any ongoing DHCP transaction on this device */\n\t\tif (priv->dhcp4_state_sigid) {\n\t\t\tg_signal_handler_disconnect (priv->dhcp4_client, priv->dhcp4_state_sigid);\n\t\t\tpriv->dhcp4_state_sigid = 0;\n\t\t}\n\n\t\tnm_device_remove_pending_action (self, PENDING_ACTION_DHCP4, FALSE);\n\n\t\tif (stop)\n\t\t\tnm_dhcp_client_stop (priv->dhcp4_client, release);\n\n\t\tg_clear_object (&priv->dhcp4_client);\n\t}\n\n\tif (priv->dhcp4_config) {\n\t\tg_clear_object (&priv->dhcp4_config);\n\t\tg_object_notify (G_OBJECT (self), NM_DEVICE_DHCP4_CONFIG);\n\t}\n}\n\nstatic gboolean\nip4_config_merge_and_apply (NMDevice *self,\n                            NMIP4Config *config,\n                            gboolean commit,\n                            NMDeviceStateReason *out_reason)\n{\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\tNMConnection *connection;\n\tgboolean success;\n\tNMIP4Config *composite;\n\tgboolean has_direct_route;\n\tconst guint32 default_route_metric = nm_device_get_ip4_route_metric (self);\n\tguint32 gateway;\n\n\t/* Merge all the configs into the composite config */\n\tif (config) {\n\t\tg_clear_object (&priv->dev_ip4_config);\n\t\tpriv->dev_ip4_config = g_object_ref (config);\n\t}\n\n\tcomposite = nm_ip4_config_new (nm_device_get_ip_ifindex (self));\n\n\tensure_con_ipx_config (self);\n\n\tif (priv->dev_ip4_config)\n\t\tnm_ip4_config_merge (composite, priv->dev_ip4_config);\n\tif (priv->vpn4_config)\n\t\tnm_ip4_config_merge (composite, priv->vpn4_config);\n\tif (priv->ext_ip4_config)\n\t\tnm_ip4_config_merge (composite, priv->ext_ip4_config);\n\n\t/* Merge WWAN config *last* to ensure modem-given settings overwrite\n\t * any external stuff set by pppd or other scripts.\n\t */\n\tif (priv->wwan_ip4_config)\n\t\tnm_ip4_config_merge (composite, priv->wwan_ip4_config);\n\n\t/* Merge user overrides into the composite config. For assumed connection,\n\t * con_ip4_config is empty. */\n\tif (priv->con_ip4_config)\n\t\tnm_ip4_config_merge (composite, priv->con_ip4_config);\n\n\tconnection = nm_device_get_connection (self);\n\n\t/* Add the default route.\n\t *\n\t * We keep track of the default route of a device in a private field.\n\t * NMDevice needs to know the default route at this point, because the gateway\n\t * might require a direct route (see below).\n\t *\n\t * But also, we don't want to add the default route to priv->ip4_config,\n\t * because the default route from the setting might not be the same that\n\t * NMDefaultRouteManager eventually configures (because the it might\n\t * tweak the effective metric).\n\t */\n\n\t/* unless we come to a different conclusion below, we have no default route and\n\t * the route is assumed. */\n\tpriv->default_route.v4_has = FALSE;\n\tpriv->default_route.v4_is_assumed = TRUE;\n\n\tif (!commit) {\n\t\t/* during a non-commit event, we always pickup whatever is configured. */\n\t\tgoto END_ADD_DEFAULT_ROUTE;\n\t}\n\n\tif (nm_device_uses_assumed_connection (self))\n\t\tgoto END_ADD_DEFAULT_ROUTE;\n\n\n\t/* we are about to commit (for a non-assumed connection). Enforce whatever we have\n\t * configured. */\n\tpriv->default_route.v4_is_assumed = FALSE;\n\n\tif (   !connection\n\t    || !nm_default_route_manager_ip4_connection_has_default_route (nm_default_route_manager_get (), connection))\n\t\tgoto END_ADD_DEFAULT_ROUTE;\n\n\tif (!nm_ip4_config_get_num_addresses (composite)) {\n\t\t/* without addresses we can have no default route. */\n\t\tgoto END_ADD_DEFAULT_ROUTE;\n\t}\n\n\tgateway = nm_ip4_config_get_gateway (composite);\n\tif (   !gateway\n\t    && nm_device_get_device_type (self) != NM_DEVICE_TYPE_MODEM)\n\t\tgoto END_ADD_DEFAULT_ROUTE;\n\n\thas_direct_route = (   gateway == 0\n\t                    || nm_ip4_config_get_subnet_for_host (composite, gateway)\n\t                    || nm_ip4_config_get_direct_route_for_host (composite, gateway));\n\n\tpriv->default_route.v4_has = TRUE;\n\tmemset (&priv->default_route.v4, 0, sizeof (priv->default_route.v4));\n\tpriv->default_route.v4.source = NM_IP_CONFIG_SOURCE_USER;\n\tpriv->default_route.v4.gateway = gateway;\n\tpriv->default_route.v4.metric = default_route_metric;\n\tpriv->default_route.v4.mss = nm_ip4_config_get_mss (composite);\n\n\tif (!has_direct_route) {\n\t\tNMPlatformIP4Route r = priv->default_route.v4;\n\n\t\t/* add a direct route to the gateway */\n\t\tr.network = gateway;\n\t\tr.plen = 32;\n\t\tr.gateway = 0;\n\t\tnm_ip4_config_add_route (composite, &r);\n\t}\n\nEND_ADD_DEFAULT_ROUTE:\n\n\tif (priv->default_route.v4_is_assumed) {\n\t\t/* If above does not explicitly assign a default route, we always pick up the\n\t\t * default route based on what is currently configured.\n\t\t * That means that even managed connections with never-default, can\n\t\t * get a default route (if configured externally).\n\t\t */\n\t\tpriv->default_route.v4_has = _device_get_default_route_from_platform (self, AF_INET, (NMPlatformIPRoute *) &priv->default_route.v4);\n\t}\n\n\t/* Allow setting MTU etc */\n\tif (commit) {\n\t\tif (NM_DEVICE_GET_CLASS (self)->ip4_config_pre_commit)\n\t\t\tNM_DEVICE_GET_CLASS (self)->ip4_config_pre_commit (self, composite);\n\t}\n\n\tsuccess = nm_device_set_ip4_config (self, composite, default_route_metric, commit, out_reason);\n\tg_object_unref (composite);\n\treturn success;\n}\n\nstatic void\ndhcp4_lease_change (NMDevice *self, NMIP4Config *config)\n{\n\tNMDeviceStateReason reason = NM_DEVICE_STATE_REASON_NONE;\n\n\tg_return_if_fail (config != NULL);\n\n\tif (!ip4_config_merge_and_apply (self, config, TRUE, &reason)) {\n\t\t_LOGW (LOGD_DHCP4, \"failed to update IPv4 config for DHCP change.\");\n\t\tnm_device_state_changed (self, NM_DEVICE_STATE_FAILED, reason);\n\t} else {\n\t\t/* Notify dispatcher scripts of new DHCP4 config */\n\t\tnm_dispatcher_call (DISPATCHER_ACTION_DHCP4_CHANGE,\n\t\t                    nm_device_get_connection (self),\n\t\t                    self,\n\t\t                    NULL,\n\t\t                    NULL,\n\t\t                    NULL);\n\t}\n}\n\nstatic void\ndhcp4_fail (NMDevice *self, gboolean timeout)\n{\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\n\tdhcp4_cleanup (self, TRUE, FALSE);\n\tif (timeout || (priv->ip4_state == IP_CONF))\n\t\tnm_device_activate_schedule_ip4_config_timeout (self);\n\telse if (priv->ip4_state == IP_DONE)\n\t\tnm_device_state_changed (self, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_IP_CONFIG_EXPIRED);\n\telse\n\t\tg_warn_if_reached ();\n}\n\nstatic void\ndhcp4_update_config (NMDevice *self, NMDhcp4Config *config, GHashTable *options)\n{\n\tGHashTableIter iter;\n\tconst char *key, *value;\n\n\t/* Update the DHCP4 config object with new DHCP options */\n\tnm_dhcp4_config_reset (config);\n\n\tg_hash_table_iter_init (&iter, options);\n\twhile (g_hash_table_iter_next (&iter, (gpointer) &key, (gpointer) &value))\n\t\tnm_dhcp4_config_add_option (config, key, value);\n\n\tg_object_notify (G_OBJECT (self), NM_DEVICE_DHCP4_CONFIG);\n}\n\nstatic void\ndhcp4_state_changed (NMDhcpClient *client,\n                     NMDhcpState state,\n                     NMIP4Config *ip4_config,\n                     GHashTable *options,\n                     gpointer user_data)\n{\n\tNMDevice *self = NM_DEVICE (user_data);\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\n\tg_return_if_fail (nm_dhcp_client_get_ipv6 (client) == FALSE);\n\tg_return_if_fail (!ip4_config || NM_IS_IP4_CONFIG (ip4_config));\n\n\t_LOGD (LOGD_DHCP4, \"new DHCPv4 client state %d\", state);\n\n\tswitch (state) {\n\tcase NM_DHCP_STATE_BOUND:\n\t\tif (!ip4_config) {\n\t\t\t_LOGW (LOGD_DHCP4, \"failed to get IPv4 config in response to DHCP event.\");\n\t\t\tnm_device_state_changed (self,\n\t\t\t                         NM_DEVICE_STATE_FAILED,\n\t\t\t                         NM_DEVICE_STATE_REASON_IP_CONFIG_UNAVAILABLE);\n\t\t\tbreak;\n\t\t}\n\n\t\tdhcp4_update_config (self, priv->dhcp4_config, options);\n\n\t\tif (priv->ip4_state == IP_CONF)\n\t\t\tnm_device_activate_schedule_ip4_config_result (self, ip4_config);\n\t\telse if (priv->ip4_state == IP_DONE)\n\t\t\tdhcp4_lease_change (self, ip4_config);\n\t\tbreak;\n\tcase NM_DHCP_STATE_TIMEOUT:\n\t\tdhcp4_fail (self, TRUE);\n\t\tbreak;\n\tcase NM_DHCP_STATE_EXPIRE:\n\t\t/* Ignore expiry before we even have a lease (NAK, old lease, etc) */\n\t\tif (priv->ip4_state == IP_CONF)\n\t\t\tbreak;\n\t\t/* Fall through */\n\tcase NM_DHCP_STATE_DONE:\n\tcase NM_DHCP_STATE_FAIL:\n\t\tdhcp4_fail (self, FALSE);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic NMActStageReturn\ndhcp4_start (NMDevice *self,\n             NMConnection *connection,\n             NMDeviceStateReason *reason)\n{\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\tNMSettingIPConfig *s_ip4;\n\tconst guint8 *hw_addr;\n\tsize_t hw_addr_len = 0;\n\tGByteArray *tmp = NULL;\n\n\ts_ip4 = nm_connection_get_setting_ip4_config (connection);\n\n\t/* Clear old exported DHCP options */\n\tif (priv->dhcp4_config)\n\t\tg_object_unref (priv->dhcp4_config);\n\tpriv->dhcp4_config = nm_dhcp4_config_new ();\n\n\thw_addr = nm_platform_link_get_address (nm_device_get_ip_ifindex (self), &hw_addr_len);\n\tif (hw_addr_len) {\n\t\ttmp = g_byte_array_sized_new (hw_addr_len);\n\t\tg_byte_array_append (tmp, hw_addr, hw_addr_len);\n\t}\n\n\t/* Begin DHCP on the interface */\n\tg_warn_if_fail (priv->dhcp4_client == NULL);\n\tpriv->dhcp4_client = nm_dhcp_manager_start_ip4 (nm_dhcp_manager_get (),\n\t                                                nm_device_get_ip_iface (self),\n\t                                                nm_device_get_ip_ifindex (self),\n\t                                                tmp,\n\t                                                nm_connection_get_uuid (connection),\n\t                                                nm_device_get_ip4_route_metric (self),\n\t                                                nm_setting_ip_config_get_dhcp_send_hostname (s_ip4),\n\t                                                nm_setting_ip_config_get_dhcp_hostname (s_ip4),\n\t                                                nm_setting_ip4_config_get_dhcp_client_id (NM_SETTING_IP4_CONFIG (s_ip4)),\n\t                                                priv->dhcp_timeout,\n\t                                                priv->dhcp_anycast_address,\n\t                                                NULL);\n\n\tif (tmp)\n\t\tg_byte_array_free (tmp, TRUE);\n\n\tif (!priv->dhcp4_client) {\n\t\t*reason = NM_DEVICE_STATE_REASON_DHCP_START_FAILED;\n\t\treturn NM_ACT_STAGE_RETURN_FAILURE;\n\t}\n\n\tpriv->dhcp4_state_sigid = g_signal_connect (priv->dhcp4_client,\n\t                                            NM_DHCP_CLIENT_SIGNAL_STATE_CHANGED,\n\t                                            G_CALLBACK (dhcp4_state_changed),\n\t                                            self);\n\n\tnm_device_add_pending_action (self, PENDING_ACTION_DHCP4, TRUE);\n\n\t/* DHCP devices will be notified by the DHCP manager when stuff happens */\n\treturn NM_ACT_STAGE_RETURN_POSTPONE;\n}\n\ngboolean\nnm_device_dhcp4_renew (NMDevice *self, gboolean release)\n{\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\tNMActStageReturn ret;\n\tNMDeviceStateReason reason;\n\tNMConnection *connection;\n\n\tg_return_val_if_fail (priv->dhcp4_client != NULL, FALSE);\n\n\t_LOGI (LOGD_DHCP4, \"DHCPv4 lease renewal requested\");\n\n\t/* Terminate old DHCP instance and release the old lease */\n\tdhcp4_cleanup (self, TRUE, release);\n\n\tconnection = nm_device_get_connection (self);\n\tg_assert (connection);\n\n\t/* Start DHCP again on the interface */\n\tret = dhcp4_start (self, connection, &reason);\n\n\treturn (ret != NM_ACT_STAGE_RETURN_FAILURE);\n}\n\n/*********************************************/\n\nstatic GHashTable *shared_ips = NULL;\n\nstatic void\nrelease_shared_ip (gpointer data)\n{\n\tg_hash_table_remove (shared_ips, data);\n}\n\nstatic gboolean\nreserve_shared_ip (NMDevice *self, NMSettingIPConfig *s_ip4, NMPlatformIP4Address *address)\n{\n\tif (G_UNLIKELY (shared_ips == NULL))\n\t\tshared_ips = g_hash_table_new (g_direct_hash, g_direct_equal);\n\n\tmemset (address, 0, sizeof (*address));\n\n\tif (s_ip4 && nm_setting_ip_config_get_num_addresses (s_ip4)) {\n\t\t/* Use the first user-supplied address */\n\t\tNMIPAddress *user = nm_setting_ip_config_get_address (s_ip4, 0);\n\n\t\tg_assert (user);\n\t\tnm_ip_address_get_address_binary (user, &address->address);\n\t\taddress->plen = nm_ip_address_get_prefix (user);\n\t} else {\n\t\t/* Find an unused address in the 10.42.x.x range */\n\t\tguint32 start = (guint32) ntohl (0x0a2a0001); /* 10.42.0.1 */\n\t\tguint32 count = 0;\n\n\t\twhile (g_hash_table_lookup (shared_ips, GUINT_TO_POINTER (start + count))) {\n\t\t\tcount += ntohl (0x100);\n\t\t\tif (count > ntohl (0xFE00)) {\n\t\t\t\t_LOGE (LOGD_SHARING, \"ran out of shared IP addresses!\");\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\t\taddress->address = start + count;\n\t\taddress->plen = 24;\n\n\t\tg_hash_table_insert (shared_ips,\n\t\t                     GUINT_TO_POINTER (address->address),\n\t\t                     GUINT_TO_POINTER (TRUE));\n\t}\n\n\treturn TRUE;\n}\n\nstatic NMIP4Config *\nshared4_new_config (NMDevice *self, NMConnection *connection, NMDeviceStateReason *reason)\n{\n\tNMIP4Config *config = NULL;\n\tNMPlatformIP4Address address;\n\n\tg_return_val_if_fail (self != NULL, NULL);\n\n\tif (!reserve_shared_ip (self, nm_connection_get_setting_ip4_config (connection), &address)) {\n\t\t*reason = NM_DEVICE_STATE_REASON_IP_CONFIG_UNAVAILABLE;\n\t\treturn NULL;\n\t}\n\n\tconfig = nm_ip4_config_new (nm_device_get_ip_ifindex (self));\n\taddress.source = NM_IP_CONFIG_SOURCE_SHARED;\n\tnm_ip4_config_add_address (config, &address);\n\n\t/* Remove the address lock when the object gets disposed */\n\tg_object_set_data_full (G_OBJECT (config), \"shared-ip\",\n\t                        GUINT_TO_POINTER (address.address),\n\t                        release_shared_ip);\n\n\treturn config;\n}\n\n/*********************************************/\n\nstatic gboolean\nconnection_ip4_method_requires_carrier (NMConnection *connection,\n                                        gboolean *out_ip4_enabled)\n{\n\tconst char *method = nm_utils_get_ip_config_method (connection, NM_TYPE_SETTING_IP4_CONFIG);\n\tstatic const char *ip4_carrier_methods[] = {\n\t\tNM_SETTING_IP4_CONFIG_METHOD_AUTO,\n\t\tNM_SETTING_IP4_CONFIG_METHOD_LINK_LOCAL,\n\t\tNULL\n\t};\n\n\tif (out_ip4_enabled)\n\t\t*out_ip4_enabled = !!strcmp (method, NM_SETTING_IP4_CONFIG_METHOD_DISABLED);\n\treturn _nm_utils_string_in_list (method, ip4_carrier_methods);\n}\n\nstatic gboolean\nconnection_ip6_method_requires_carrier (NMConnection *connection,\n                                        gboolean *out_ip6_enabled)\n{\n\tconst char *method = nm_utils_get_ip_config_method (connection, NM_TYPE_SETTING_IP6_CONFIG);\n\tstatic const char *ip6_carrier_methods[] = {\n\t\tNM_SETTING_IP6_CONFIG_METHOD_AUTO,\n\t\tNM_SETTING_IP6_CONFIG_METHOD_DHCP,\n\t\tNM_SETTING_IP6_CONFIG_METHOD_LINK_LOCAL,\n\t\tNULL\n\t};\n\n\tif (out_ip6_enabled)\n\t\t*out_ip6_enabled = !!strcmp (method, NM_SETTING_IP6_CONFIG_METHOD_IGNORE);\n\treturn _nm_utils_string_in_list (method, ip6_carrier_methods);\n}\n\nstatic gboolean\nconnection_requires_carrier (NMConnection *connection)\n{\n\tNMSettingIPConfig *s_ip4, *s_ip6;\n\tgboolean ip4_carrier_wanted, ip6_carrier_wanted;\n\tgboolean ip4_used = FALSE, ip6_used = FALSE;\n\n\tip4_carrier_wanted = connection_ip4_method_requires_carrier (connection, &ip4_used);\n\tif (ip4_carrier_wanted) {\n\t\t/* If IPv4 wants a carrier and cannot fail, the whole connection\n\t\t * requires a carrier regardless of the IPv6 method.\n\t\t */\n\t\ts_ip4 = nm_connection_get_setting_ip4_config (connection);\n\t\tif (s_ip4 && !nm_setting_ip_config_get_may_fail (s_ip4))\n\t\t\treturn TRUE;\n\t}\n\n\tip6_carrier_wanted = connection_ip6_method_requires_carrier (connection, &ip6_used);\n\tif (ip6_carrier_wanted) {\n\t\t/* If IPv6 wants a carrier and cannot fail, the whole connection\n\t\t * requires a carrier regardless of the IPv4 method.\n\t\t */\n\t\ts_ip6 = nm_connection_get_setting_ip6_config (connection);\n\t\tif (s_ip6 && !nm_setting_ip_config_get_may_fail (s_ip6))\n\t\t\treturn TRUE;\n\t}\n\n\t/* If an IP version wants a carrier and and the other IP version isn't\n\t * used, the connection requires carrier since it will just fail without one.\n\t */\n\tif (ip4_carrier_wanted && !ip6_used)\n\t\treturn TRUE;\n\tif (ip6_carrier_wanted && !ip4_used)\n\t\treturn TRUE;\n\n\t/* If both want a carrier, the whole connection wants a carrier */\n\treturn ip4_carrier_wanted && ip6_carrier_wanted;\n}\n\nstatic gboolean\nhave_any_ready_slaves (NMDevice *self, const GSList *slaves)\n{\n\tconst GSList *iter;\n\n\t/* Any enslaved slave is \"ready\" in the generic case as it's\n\t * at least >= NM_DEVCIE_STATE_IP_CONFIG and has had Layer 2\n\t * properties set up.\n\t */\n\tfor (iter = slaves; iter; iter = g_slist_next (iter)) {\n\t\tif (nm_device_get_enslaved (iter->data))\n\t\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n\nstatic gboolean\nip4_requires_slaves (NMConnection *connection)\n{\n\tconst char *method;\n\n\tmethod = nm_utils_get_ip_config_method (connection, NM_TYPE_SETTING_IP4_CONFIG);\n\treturn strcmp (method, NM_SETTING_IP4_CONFIG_METHOD_AUTO) == 0;\n}\n\nstatic NMActStageReturn\nact_stage3_ip4_config_start (NMDevice *self,\n                             NMIP4Config **out_config,\n                             NMDeviceStateReason *reason)\n{\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\tNMConnection *connection;\n\tNMActStageReturn ret = NM_ACT_STAGE_RETURN_FAILURE;\n\tconst char *method;\n\tGSList *slaves;\n\tgboolean ready_slaves;\n\n\tg_return_val_if_fail (reason != NULL, NM_ACT_STAGE_RETURN_FAILURE);\n\n\tconnection = nm_device_get_connection (self);\n\tg_assert (connection);\n\n\tif (   connection_ip4_method_requires_carrier (connection, NULL)\n\t    && priv->is_master\n\t    && !priv->carrier) {\n\t\t_LOGI (LOGD_IP4 | LOGD_DEVICE,\n\t\t       \"IPv4 config waiting until carrier is on\");\n\t\treturn NM_ACT_STAGE_RETURN_WAIT;\n\t}\n\n\tif (priv->is_master && ip4_requires_slaves (connection)) {\n\t\t/* If the master has no ready slaves, and depends on slaves for\n\t\t * a successful IPv4 attempt, then postpone IPv4 addressing.\n\t\t */\n\t\tslaves = nm_device_master_get_slaves (self);\n\t\tready_slaves = NM_DEVICE_GET_CLASS (self)->have_any_ready_slaves (self, slaves);\n\t\tg_slist_free (slaves);\n\n\t\tif (ready_slaves == FALSE) {\n\t\t\t_LOGI (LOGD_DEVICE | LOGD_IP4,\n\t\t\t       \"IPv4 config waiting until slaves are ready\");\n\t\t\treturn NM_ACT_STAGE_RETURN_WAIT;\n\t\t}\n\t}\n\n\tmethod = nm_utils_get_ip_config_method (connection, NM_TYPE_SETTING_IP4_CONFIG);\n\n\t/* Start IPv4 addressing based on the method requested */\n\tif (strcmp (method, NM_SETTING_IP4_CONFIG_METHOD_AUTO) == 0)\n\t\tret = dhcp4_start (self, connection, reason);\n\telse if (strcmp (method, NM_SETTING_IP4_CONFIG_METHOD_LINK_LOCAL) == 0)\n\t\tret = aipd_start (self, reason);\n\telse if (strcmp (method, NM_SETTING_IP4_CONFIG_METHOD_MANUAL) == 0) {\n\t\t/* Use only IPv4 config from the connection data */\n\t\t*out_config = nm_ip4_config_new (nm_device_get_ip_ifindex (self));\n\t\tg_assert (*out_config);\n\t\tret = NM_ACT_STAGE_RETURN_SUCCESS;\n\t} else if (strcmp (method, NM_SETTING_IP4_CONFIG_METHOD_SHARED) == 0) {\n\t\t*out_config = shared4_new_config (self, connection, reason);\n\t\tif (*out_config) {\n\t\t\tpriv->dnsmasq_manager = nm_dnsmasq_manager_new (nm_device_get_ip_iface (self));\n\t\t\tret = NM_ACT_STAGE_RETURN_SUCCESS;\n\t\t} else\n\t\t\tret = NM_ACT_STAGE_RETURN_FAILURE;\n\t} else if (strcmp (method, NM_SETTING_IP4_CONFIG_METHOD_DISABLED) == 0) {\n\t\t/* Nothing to do... */\n\t\tret = NM_ACT_STAGE_RETURN_STOP;\n\t} else\n\t\t_LOGW (LOGD_IP4, \"unhandled IPv4 config method '%s'; will fail\", method);\n\n\treturn ret;\n}\n\n/*********************************************/\n/* DHCPv6 stuff */\n\nstatic void\ndhcp6_cleanup (NMDevice *self, gboolean stop, gboolean release)\n{\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\n\tpriv->dhcp6_mode = NM_RDISC_DHCP_LEVEL_NONE;\n\tg_clear_object (&priv->dhcp6_ip6_config);\n\n\tif (priv->dhcp6_client) {\n\t\tif (priv->dhcp6_state_sigid) {\n\t\t\tg_signal_handler_disconnect (priv->dhcp6_client, priv->dhcp6_state_sigid);\n\t\t\tpriv->dhcp6_state_sigid = 0;\n\t\t}\n\n\t\tif (stop)\n\t\t\tnm_dhcp_client_stop (priv->dhcp6_client, release);\n\n\t\tg_clear_object (&priv->dhcp6_client);\n\t}\n\n\tnm_device_remove_pending_action (self, PENDING_ACTION_DHCP6, FALSE);\n\n\tif (priv->dhcp6_config) {\n\t\tg_clear_object (&priv->dhcp6_config);\n\t\tg_object_notify (G_OBJECT (self), NM_DEVICE_DHCP6_CONFIG);\n\t}\n}\n\nstatic gboolean\nip6_config_merge_and_apply (NMDevice *self,\n                            gboolean commit,\n                            NMDeviceStateReason *out_reason)\n{\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\tNMConnection *connection;\n\tgboolean success;\n\tNMIP6Config *composite;\n\tgboolean has_direct_route;\n\tconst struct in6_addr *gateway;\n\n\t/* If no config was passed in, create a new one */\n\tcomposite = nm_ip6_config_new (nm_device_get_ip_ifindex (self));\n\n\tensure_con_ipx_config (self);\n\tg_assert (composite);\n\n\t/* Merge all the IP configs into the composite config */\n\tif (priv->ac_ip6_config)\n\t\tnm_ip6_config_merge (composite, priv->ac_ip6_config);\n\tif (priv->dhcp6_ip6_config)\n\t\tnm_ip6_config_merge (composite, priv->dhcp6_ip6_config);\n\tif (priv->vpn6_config)\n\t\tnm_ip6_config_merge (composite, priv->vpn6_config);\n\tif (priv->ext_ip6_config)\n\t\tnm_ip6_config_merge (composite, priv->ext_ip6_config);\n\n\t/* Merge WWAN config *last* to ensure modem-given settings overwrite\n\t * any external stuff set by pppd or other scripts.\n\t */\n\tif (priv->wwan_ip6_config)\n\t\tnm_ip6_config_merge (composite, priv->wwan_ip6_config);\n\n\t/* Merge user overrides into the composite config. For assumed connections,\n\t * con_ip6_config is empty. */\n\tif (priv->con_ip6_config)\n\t\tnm_ip6_config_merge (composite, priv->con_ip6_config);\n\n\tconnection = nm_device_get_connection (self);\n\n\t/* Add the default route.\n\t *\n\t * We keep track of the default route of a device in a private field.\n\t * NMDevice needs to know the default route at this point, because the gateway\n\t * might require a direct route (see below).\n\t *\n\t * But also, we don't want to add the default route to priv->ip6_config,\n\t * because the default route from the setting might not be the same that\n\t * NMDefaultRouteManager eventually configures (because the it might\n\t * tweak the effective metric).\n\t */\n\n\t/* unless we come to a different conclusion below, we have no default route and\n\t * the route is assumed. */\n\tpriv->default_route.v6_has = FALSE;\n\tpriv->default_route.v6_is_assumed = TRUE;\n\n\tif (!commit) {\n\t\t/* during a non-commit event, we always pickup whatever is configured. */\n\t\tgoto END_ADD_DEFAULT_ROUTE;\n\t}\n\n\tif (nm_device_uses_assumed_connection (self))\n\t\tgoto END_ADD_DEFAULT_ROUTE;\n\n\n\t/* we are about to commit (for a non-assumed connection). Enforce whatever we have\n\t * configured. */\n\tpriv->default_route.v6_is_assumed = FALSE;\n\n\tif (   !connection\n\t    || !nm_default_route_manager_ip6_connection_has_default_route (nm_default_route_manager_get (), connection))\n\t\tgoto END_ADD_DEFAULT_ROUTE;\n\n\tif (!nm_ip6_config_get_num_addresses (composite)) {\n\t\t/* without addresses we can have no default route. */\n\t\tgoto END_ADD_DEFAULT_ROUTE;\n\t}\n\n\tgateway = nm_ip6_config_get_gateway (composite);\n\tif (!gateway)\n\t\tgoto END_ADD_DEFAULT_ROUTE;\n\n\n\thas_direct_route = nm_ip6_config_get_direct_route_for_host (composite, gateway) != NULL;\n\n\n\n\tpriv->default_route.v6_has = TRUE;\n\tmemset (&priv->default_route.v6, 0, sizeof (priv->default_route.v6));\n\tpriv->default_route.v6.source = NM_IP_CONFIG_SOURCE_USER;\n\tpriv->default_route.v6.gateway = *gateway;\n\tpriv->default_route.v6.metric = nm_device_get_ip6_route_metric (self);\n\tpriv->default_route.v6.mss = nm_ip6_config_get_mss (composite);\n\n\tif (!has_direct_route) {\n\t\tNMPlatformIP6Route r = priv->default_route.v6;\n\n\t\t/* add a direct route to the gateway */\n\t\tr.network = *gateway;\n\t\tr.plen = 128;\n\t\tr.gateway = in6addr_any;\n\t\tnm_ip6_config_add_route (composite, &r);\n\t}\n\nEND_ADD_DEFAULT_ROUTE:\n\n\tif (priv->default_route.v6_is_assumed) {\n\t\t/* If above does not explicitly assign a default route, we always pick up the\n\t\t * default route based on what is currently configured.\n\t\t * That means that even managed connections with never-default, can\n\t\t * get a default route (if configured externally).\n\t\t */\n\t\tpriv->default_route.v6_has = _device_get_default_route_from_platform (self, AF_INET6, (NMPlatformIPRoute *) &priv->default_route.v6);\n\t}\n\n\tnm_ip6_config_addresses_sort (composite,\n\t    priv->rdisc ? priv->rdisc_use_tempaddr : NM_SETTING_IP6_CONFIG_PRIVACY_UNKNOWN);\n\n\t/* Allow setting MTU etc */\n\tif (commit) {\n\t\tif (NM_DEVICE_GET_CLASS (self)->ip6_config_pre_commit)\n\t\t\tNM_DEVICE_GET_CLASS (self)->ip6_config_pre_commit (self, composite);\n\t}\n\n\tsuccess = nm_device_set_ip6_config (self, composite, commit, out_reason);\n\tg_object_unref (composite);\n\treturn success;\n}\n\nstatic void\ndhcp6_lease_change (NMDevice *self)\n{\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\tNMConnection *connection;\n\tNMDeviceStateReason reason = NM_DEVICE_STATE_REASON_NONE;\n\n\tif (priv->dhcp6_ip6_config == NULL) {\n\t\t_LOGW (LOGD_DHCP6, \"failed to get DHCPv6 config for rebind\");\n\t\tnm_device_state_changed (self, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_IP_CONFIG_EXPIRED);\n\t\treturn;\n\t}\n\n\tg_assert (priv->dhcp6_client);  /* sanity check */\n\n\tconnection = nm_device_get_connection (self);\n\tg_assert (connection);\n\n\t/* Apply the updated config */\n\tif (ip6_config_merge_and_apply (self, TRUE, &reason) == FALSE) {\n\t\t_LOGW (LOGD_DHCP6, \"failed to update IPv6 config in response to DHCP event.\");\n\t\tnm_device_state_changed (self, NM_DEVICE_STATE_FAILED, reason);\n\t} else {\n\t\t/* Notify dispatcher scripts of new DHCPv6 config */\n\t\tnm_dispatcher_call (DISPATCHER_ACTION_DHCP6_CHANGE, connection, self, NULL, NULL, NULL);\n\t}\n}\n\nstatic void\ndhcp6_fail (NMDevice *self, gboolean timeout)\n{\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\n\tdhcp6_cleanup (self, TRUE, FALSE);\n\n\tif (priv->dhcp6_mode == NM_RDISC_DHCP_LEVEL_MANAGED) {\n\t\tif (timeout || (priv->ip6_state == IP_CONF))\n\t\t\tnm_device_activate_schedule_ip6_config_timeout (self);\n\t\telse if (priv->ip6_state == IP_DONE)\n\t\t\tnm_device_state_changed (self, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_IP_CONFIG_EXPIRED);\n\t\telse\n\t\t\tg_warn_if_reached ();\n\t} else {\n\t\t/* not a hard failure; just live with the RA info */\n\t\tif (priv->ip6_state == IP_CONF)\n\t\t\tnm_device_activate_schedule_ip6_config_result (self);\n\t}\n}\n\nstatic void\ndhcp6_timeout (NMDevice *self, NMDhcpClient *client)\n{\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\n\tif (priv->dhcp6_mode == NM_RDISC_DHCP_LEVEL_MANAGED)\n\t\tdhcp6_fail (self, TRUE);\n\telse {\n\t\t/* not a hard failure; just live with the RA info */\n\t\tdhcp6_cleanup (self, TRUE, FALSE);\n\t\tif (priv->ip6_state == IP_CONF)\n\t\t\tnm_device_activate_schedule_ip6_config_result (self);\n\t}\n}\n\nstatic void\ndhcp6_update_config (NMDevice *self, NMDhcp6Config *config, GHashTable *options)\n{\n\tGHashTableIter iter;\n\tconst char *key, *value;\n\n\t/* Update the DHCP6 config object with new DHCP options */\n\tnm_dhcp6_config_reset (config);\n\n\tg_hash_table_iter_init (&iter, options);\n\twhile (g_hash_table_iter_next (&iter, (gpointer) &key, (gpointer) &value))\n\t\tnm_dhcp6_config_add_option (config, key, value);\n\n\tg_object_notify (G_OBJECT (self), NM_DEVICE_DHCP6_CONFIG);\n}\n\nstatic void\ndhcp6_state_changed (NMDhcpClient *client,\n                     NMDhcpState state,\n                     NMIP6Config *ip6_config,\n                     GHashTable *options,\n                     gpointer user_data)\n{\n\tNMDevice *self = NM_DEVICE (user_data);\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\n\tg_return_if_fail (nm_dhcp_client_get_ipv6 (client) == TRUE);\n\tg_return_if_fail (!ip6_config || NM_IS_IP6_CONFIG (ip6_config));\n\n\t_LOGD (LOGD_DHCP6, \"new DHCPv6 client state %d\", state);\n\n\tswitch (state) {\n\tcase NM_DHCP_STATE_BOUND:\n\t\tg_clear_object (&priv->dhcp6_ip6_config);\n\t\tif (ip6_config) {\n\t\t\tpriv->dhcp6_ip6_config = g_object_ref (ip6_config);\n\t\t\tdhcp6_update_config (self, priv->dhcp6_config, options);\n\t\t}\n\n\t\tif (priv->ip6_state == IP_CONF) {\n\t\t\tif (priv->dhcp6_ip6_config == NULL) {\n\t\t\t\t/* FIXME: Initial DHCP failed; should we fail IPv6 entirely then? */\n\t\t\t\tnm_device_state_changed (self, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_DHCP_FAILED);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnm_device_activate_schedule_ip6_config_result (self);\n\t\t} else if (priv->ip6_state == IP_DONE)\n\t\t\tdhcp6_lease_change (self);\n\t\tbreak;\n\tcase NM_DHCP_STATE_TIMEOUT:\n\t\tdhcp6_timeout (self, client);\n\t\tbreak;\n\tcase NM_DHCP_STATE_EXPIRE:\n\t\t/* Ignore expiry before we even have a lease (NAK, old lease, etc) */\n\t\tif (priv->ip6_state != IP_CONF)\n\t\t\tdhcp6_fail (self, FALSE);\n\t\tbreak;\n\tcase NM_DHCP_STATE_DONE:\n\t\t/* In IPv6 info-only mode, the client doesn't handle leases so it\n\t\t * may exit right after getting a response from the server.  That's\n\t\t * normal.  In that case we just ignore the exit.\n\t\t */\n\t\tif (priv->dhcp6_mode == NM_RDISC_DHCP_LEVEL_OTHERCONF)\n\t\t\tbreak;\n\t\t/* Otherwise, fall through */\n\tcase NM_DHCP_STATE_FAIL:\n\t\tdhcp6_fail (self, FALSE);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic gboolean\ndhcp6_start_with_link_ready (NMDevice *self, NMConnection *connection)\n{\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\tNMSettingIPConfig *s_ip6;\n\tGByteArray *tmp = NULL;\n\tconst guint8 *hw_addr;\n\tsize_t hw_addr_len = 0;\n\n\tg_assert (connection);\n\ts_ip6 = nm_connection_get_setting_ip6_config (connection);\n\tg_assert (s_ip6);\n\n\thw_addr = nm_platform_link_get_address (nm_device_get_ip_ifindex (self), &hw_addr_len);\n\tif (hw_addr_len) {\n\t\ttmp = g_byte_array_sized_new (hw_addr_len);\n\t\tg_byte_array_append (tmp, hw_addr, hw_addr_len);\n\t}\n\n\tpriv->dhcp6_client = nm_dhcp_manager_start_ip6 (nm_dhcp_manager_get (),\n\t                                                nm_device_get_ip_iface (self),\n\t                                                nm_device_get_ip_ifindex (self),\n\t                                                tmp,\n\t                                                nm_connection_get_uuid (connection),\n\t                                                nm_device_get_ip6_route_metric (self),\n\t                                                nm_setting_ip_config_get_dhcp_send_hostname (s_ip6),\n\t                                                nm_setting_ip_config_get_dhcp_hostname (s_ip6),\n\t                                                priv->dhcp_timeout,\n\t                                                priv->dhcp_anycast_address,\n\t                                                (priv->dhcp6_mode == NM_RDISC_DHCP_LEVEL_OTHERCONF) ? TRUE : FALSE,\n\t                                                nm_setting_ip6_config_get_ip6_privacy (NM_SETTING_IP6_CONFIG (s_ip6)));\n\tif (tmp)\n\t\tg_byte_array_free (tmp, TRUE);\n\n\tif (priv->dhcp6_client) {\n\t\tpriv->dhcp6_state_sigid = g_signal_connect (priv->dhcp6_client,\n\t\t                                            NM_DHCP_CLIENT_SIGNAL_STATE_CHANGED,\n\t\t                                            G_CALLBACK (dhcp6_state_changed),\n\t\t                                            self);\n\t}\n\n\treturn !!priv->dhcp6_client;\n}\n\nstatic gboolean\ndhcp6_start (NMDevice *self, gboolean wait_for_ll, NMDeviceStateReason *reason)\n{\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\tNMConnection *connection;\n\tNMSettingIPConfig *s_ip6;\n\n\tg_clear_object (&priv->dhcp6_config);\n\tpriv->dhcp6_config = nm_dhcp6_config_new ();\n\n\tg_warn_if_fail (priv->dhcp6_ip6_config == NULL);\n\tg_clear_object (&priv->dhcp6_ip6_config);\n\n\tconnection = nm_device_get_connection (self);\n\tg_assert (connection);\n\ts_ip6 = nm_connection_get_setting_ip6_config (connection);\n\tif (!nm_setting_ip_config_get_may_fail (s_ip6) ||\n\t    !strcmp (nm_setting_ip_config_get_method (s_ip6), NM_SETTING_IP6_CONFIG_METHOD_DHCP))\n\t\tnm_device_add_pending_action (self, PENDING_ACTION_DHCP6, TRUE);\n\n\tif (wait_for_ll) {\n\t\tNMActStageReturn ret;\n\n\t\t/* ensure link local is ready... */\n\t\tret = linklocal6_start (self);\n\t\tif (ret == NM_ACT_STAGE_RETURN_POSTPONE) {\n\t\t\t/* success; wait for the LL address to show up */\n\t\t\treturn TRUE;\n\t\t}\n\n\t\t/* success; already have the LL address; kick off DHCP */\n\t\tg_assert (ret == NM_ACT_STAGE_RETURN_SUCCESS);\n\t}\n\n\tif (!dhcp6_start_with_link_ready (self, connection)) {\n\t\t*reason = NM_DEVICE_STATE_REASON_DHCP_START_FAILED;\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\ngboolean\nnm_device_dhcp6_renew (NMDevice *self, gboolean release)\n{\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\n\tg_return_val_if_fail (priv->dhcp6_client != NULL, FALSE);\n\n\t_LOGI (LOGD_DHCP6, \"DHCPv6 lease renewal requested\");\n\n\t/* Terminate old DHCP instance and release the old lease */\n\tdhcp6_cleanup (self, TRUE, release);\n\n\t/* Start DHCP again on the interface */\n\treturn dhcp6_start (self, FALSE, NULL);\n}\n\n/******************************************/\n\nstatic gboolean\nhave_ip6_address (const NMIP6Config *ip6_config, gboolean linklocal)\n{\n\tguint i;\n\n\tif (!ip6_config)\n\t\treturn FALSE;\n\n\tlinklocal = !!linklocal;\n\n\tfor (i = 0; i < nm_ip6_config_get_num_addresses (ip6_config); i++) {\n\t\tconst NMPlatformIP6Address *addr = nm_ip6_config_get_address (ip6_config, i);\n\n\t\tif ((IN6_IS_ADDR_LINKLOCAL (&addr->address) == linklocal) &&\n\t\t    !(addr->flags & IFA_F_TENTATIVE))\n\t\t\treturn TRUE;\n\t}\n\n\treturn FALSE;\n}\n\nstatic void\nlinklocal6_cleanup (NMDevice *self)\n{\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\n\tif (priv->linklocal6_timeout_id) {\n\t\tg_source_remove (priv->linklocal6_timeout_id);\n\t\tpriv->linklocal6_timeout_id = 0;\n\t}\n}\n\nstatic gboolean\nlinklocal6_timeout_cb (gpointer user_data)\n{\n\tNMDevice *self = user_data;\n\n\tlinklocal6_cleanup (self);\n\n\t_LOGD (LOGD_DEVICE, \"linklocal6: waiting for link-local addresses failed due to timeout\");\n\n\tnm_device_activate_schedule_ip6_config_timeout (self);\n\treturn G_SOURCE_REMOVE;\n}\n\nstatic void\nlinklocal6_complete (NMDevice *self)\n{\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\tNMConnection *connection;\n\tconst char *method;\n\n\tg_assert (priv->linklocal6_timeout_id);\n\tg_assert (have_ip6_address (priv->ip6_config, TRUE));\n\n\tlinklocal6_cleanup (self);\n\n\tconnection = nm_device_get_connection (self);\n\tg_assert (connection);\n\n\tmethod = nm_utils_get_ip_config_method (connection, NM_TYPE_SETTING_IP6_CONFIG);\n\n\t_LOGD (LOGD_DEVICE, \"linklocal6: waiting for link-local addresses successful, continue with method %s\", method);\n\n\tif (strcmp (method, NM_SETTING_IP6_CONFIG_METHOD_AUTO) == 0) {\n\t\tif (!addrconf6_start_with_link_ready (self)) {\n\t\t\t/* Time out IPv6 instead of failing the entire activation */\n\t\t\tnm_device_activate_schedule_ip6_config_timeout (self);\n\t\t}\n\t} else if (strcmp (method, NM_SETTING_IP6_CONFIG_METHOD_DHCP) == 0) {\n\t\tif (!dhcp6_start_with_link_ready (self, connection)) {\n\t\t\t/* Time out IPv6 instead of failing the entire activation */\n\t\t\tnm_device_activate_schedule_ip6_config_timeout (self);\n\t\t}\n\t} else if (strcmp (method, NM_SETTING_IP6_CONFIG_METHOD_LINK_LOCAL) == 0)\n\t\tnm_device_activate_schedule_ip6_config_result (self);\n\telse\n\t\tg_return_if_fail (FALSE);\n}\n\nstatic void\ncheck_and_add_ipv6ll_addr (NMDevice *self)\n{\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\tint ip_ifindex = nm_device_get_ip_ifindex (self);\n\tNMUtilsIPv6IfaceId iid;\n\tstruct in6_addr lladdr;\n\tguint i, n;\n\n\tif (priv->nm_ipv6ll == FALSE)\n\t\treturn;\n\n\tif (priv->ip6_config) {\n\t\tn = nm_ip6_config_get_num_addresses (priv->ip6_config);\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tconst NMPlatformIP6Address *addr;\n\n\t\t\taddr = nm_ip6_config_get_address (priv->ip6_config, i);\n\t\t\tif (IN6_IS_ADDR_LINKLOCAL (&addr->address)) {\n\t\t\t\t/* Already have an LL address, nothing to do */\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!nm_device_get_ip_iface_identifier (self, &iid)) {\n\t\t_LOGW (LOGD_IP6, \"failed to get interface identifier; IPv6 may be broken\");\n\t\treturn;\n\t}\n\n\tmemset (&lladdr, 0, sizeof (lladdr));\n\tlladdr.s6_addr16[0] = htons (0xfe80);\n\tnm_utils_ipv6_addr_set_interface_identfier (&lladdr, iid);\n\t_LOGD (LOGD_IP6, \"adding IPv6LL address %s\", nm_utils_inet6_ntop (&lladdr, NULL));\n\tif (!nm_platform_ip6_address_add (ip_ifindex,\n\t                                  lladdr,\n\t                                  in6addr_any,\n\t                                  64,\n\t                                  NM_PLATFORM_LIFETIME_PERMANENT,\n\t                                  NM_PLATFORM_LIFETIME_PERMANENT,\n\t                                  0)) {\n\t\t_LOGW (LOGD_IP6, \"failed to add IPv6 link-local address %s\",\n\t\t       nm_utils_inet6_ntop (&lladdr, NULL));\n\t}\n}\n\nstatic NMActStageReturn\nlinklocal6_start (NMDevice *self)\n{\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n\tNMConnection *connection;\n\tconst char *method;\n\n\tlinklocal6_cleanup (self);\n\n\tif (have_ip6_address (priv->ip6_config, TRUE))\n\t\treturn NM_ACT_STAGE_RETURN_SUCCESS;\n\n\tconnection = nm_device_get_connection (self);\n\tg_assert (connection);\n\n\tmethod = nm_utils_get_ip_config_method (connection, NM_TYPE_SETTING_IP6_CONFIG);\n\t_LOGD (LOGD_DEVICE, \"linklocal6: starting IPv6 with method '%s', but the device has no link-local addresses configured. Wait.\", method);\n\n\tcheck_and_add_ipv6ll_addr (self);\n\n\tpriv->linklocal6_timeout_id = g_timeout_add_seconds (5, linklocal6_timeout_cb, self);\n\n\treturn NM_ACT_STAGE_RETURN_POSTPONE;\n}\n\n/******************************************/\n\nstatic void\nprint_support_extended_ifa_flags (NMSettingIP6ConfigPrivacy use_tempaddr)\n{\n\tstatic gint8 warn = 0;\n\tstatic gint8 s_libnl = -1, s_kernel;\n\n\tif (warn >= 2)\n\t\treturn;\n\n\tif (s_libnl == -1) {\n\t\ts_libnl = !!nm_platform_check_support_libnl_extended_ifa_flags ();\n\t\ts_kernel = !!nm_platform_check_support_kernel_extended_ifa_flags ();\n\n\t\tif (s_libnl && s_kernel) {\n\t\t\tnm_log_dbg (LOGD_IP6, \"kernel and libnl support extended IFA_FLAGS (needed by NM for IPv6 private addresses)\");\n\t\t\twarn = 2;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (   use_tempaddr != NM_SETTING_IP6_CONFIG_PRIVACY_PREFER_TEMP_ADDR\n\t    && use_tempaddr != NM_SETTING_IP6_CONFIG_PRIVACY_PREFER_PUBLIC_ADDR) {\n\t\tif (warn == 0) {\n\t\t\tnm_log_dbg (LOGD_IP6, \"%s%s%s %s not support extended IFA_FLAGS (needed by NM for IPv6 private addresses)\",\n\t\t\t                      !s_kernel ? \"kernel\" : \"\",\n\t\t\t                      !s_kernel && !s_libnl ? \" and \" : \"\",\n\t\t\t                      !s_libnl ? \"libnl\" : \"\",\n\t\t\t                      !s_kernel && !s_libnl ? \"do\" : \"does\");\n\t\t\twarn = 1;\n\t\t}\n\t\treturn;\n\t}\n\n\tif (!s_libnl && !s_kernel) {\n\t\tnm_log_warn (LOGD_IP6, \"libnl and the kernel do not support extended IFA_FLAGS needed by NM for \"\n\t\t                       \"IPv6 private addresses. This feature is not available\");\n\t} else if (!s_libnl) {\n\t\tnm_log_warn (LOGD_IP6, \"libnl does not support extended IFA_FLAGS needed by NM for \"\n\t\t                       \"IPv6 private addresses. This feature is not available\");\n\t} else if (!s_kernel) {\n\t\tnm_log_warn (LOGD_IP6, \"The kernel does not support extended IFA_FLAGS needed by NM for \"\n\t\t                       \"IPv6 private addresses. This feature is not available\");\n\t}\n\n\twarn = 2;\n}\n\nstatic void\nrdisc_config_changed (NMRDisc *rdisc, NMRDiscConfigMap changed, NMDevice *self)\n{\n\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n \twarn = 2;\n }\n \n static void\n rdisc_config_changed (NMRDisc *rdisc, NMRDiscConfigMap changed, NMDevice *self)\n {\n\t\t\taddress.preferred = discovered_address->preferred;\n\t\t\tif (address.preferred > address.lifetime)\n\t\t\t\taddress.preferred = address.lifetime;\n\t\t\taddress.source = NM_IP_CONFIG_SOURCE_RDISC;\n\t\t\taddress.flags = ifa_flags;\n\n\t\t\tnm_ip6_config_add_address (priv->ac_ip6_config, &address);\n\t\t}\n\t}\n", "target": 1, "idx": 177986}
{"func": "bool RenderBlock::nodeAtPoint(const HitTestRequest& request, HitTestResult& result, const HitTestLocation& locationInContainer, const LayoutPoint& accumulatedOffset, HitTestAction hitTestAction)\n{\n    LayoutPoint adjustedLocation(accumulatedOffset + location());\n    LayoutSize localOffset = toLayoutSize(adjustedLocation);\n\n    if (!isRenderView()) {\n        LayoutRect overflowBox = hasOverflowClip() ? borderBoxRect() : visualOverflowRect();\n        flipForWritingMode(overflowBox);\n        overflowBox.moveBy(adjustedLocation);\n        if (!locationInContainer.intersects(overflowBox))\n            return false;\n    }\n\n    if ((hitTestAction == HitTestBlockBackground || hitTestAction == HitTestChildBlockBackground)\n        && visibleToHitTestRequest(request)\n        && isPointInOverflowControl(result, locationInContainer.point(), adjustedLocation)) {\n        updateHitTestResult(result, locationInContainer.point() - localOffset);\n        if (!result.addNodeToRectBasedTestResult(nodeForHitTest(), request, locationInContainer))\n           return true;\n    }\n\n    bool useOverflowClip = hasOverflowClip() && !hasSelfPaintingLayer();\n    bool useClip = (hasControlClip() || useOverflowClip);\n    bool checkChildren = !useClip || (hasControlClip() ? locationInContainer.intersects(controlClipRect(adjustedLocation)) : locationInContainer.intersects(overflowClipRect(adjustedLocation, IncludeOverlayScrollbarSize)));\n    if (checkChildren) {\n        LayoutSize scrolledOffset(localOffset);\n        if (hasOverflowClip())\n            scrolledOffset -= scrolledContentOffset();\n\n        if (!hasColumns()) {\n            if (hitTestContents(request, result, locationInContainer, toLayoutPoint(scrolledOffset), hitTestAction)) {\n                updateHitTestResult(result, flipForWritingMode(locationInContainer.point() - localOffset));\n                return true;\n            }\n            if (hitTestAction == HitTestFloat && hitTestFloats(request, result, locationInContainer, toLayoutPoint(scrolledOffset)))\n                return true;\n        } else if (hitTestColumns(request, result, locationInContainer, toLayoutPoint(scrolledOffset), hitTestAction)) {\n            updateHitTestResult(result, flipForWritingMode(locationInContainer.point() - localOffset));\n            return true;\n        }\n    }\n\n    if (!isRenderView() && style()->hasBorderRadius()) {\n        LayoutRect borderRect = borderBoxRect();\n        borderRect.moveBy(adjustedLocation);\n        RoundedRect border = style()->getRoundedBorderFor(borderRect);\n        if (!locationInContainer.intersects(border))\n            return false;\n    }\n\n    if (hitTestAction == HitTestBlockBackground || hitTestAction == HitTestChildBlockBackground) {\n        LayoutRect boundsRect(adjustedLocation, size());\n        if (visibleToHitTestRequest(request) && locationInContainer.intersects(boundsRect)) {\n            updateHitTestResult(result, flipForWritingMode(locationInContainer.point() - localOffset));\n            if (!result.addNodeToRectBasedTestResult(nodeForHitTest(), request, locationInContainer, boundsRect))\n                return true;\n        }\n    }\n\n    return false;\n}\n", "target": 0, "idx": 124597}
{"func": "void WebView::processDidCrash()\n{\n    updateNativeCursor();\n    ::InvalidateRect(m_window, 0, TRUE);\n}\n", "target": 0, "idx": 106749}
{"func": "  ChromeServiceWorkerFetchTest() {}\n", "target": 0, "idx": 160228}
{"func": "static int swp_handler(struct pt_regs *regs, unsigned int instr)\n{\n \tunsigned int address, destreg, data, type;\n \tunsigned int res = 0;\n \n\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, 0, regs, regs->ARM_pc);\n \n \tif (current->pid != previous_pid) {\n \t\tpr_debug(\"\\\"%s\\\" (%ld) uses deprecated SWP{B} instruction\\n\",\n\t\t\t current->comm, (unsigned long)current->pid);\n\t\tprevious_pid = current->pid;\n\t}\n\n\taddress = regs->uregs[EXTRACT_REG_NUM(instr, RN_OFFSET)];\n\tdata\t= regs->uregs[EXTRACT_REG_NUM(instr, RT2_OFFSET)];\n\tdestreg = EXTRACT_REG_NUM(instr, RT_OFFSET);\n\n\ttype = instr & TYPE_SWPB;\n\n\tpr_debug(\"addr in r%d->0x%08x, dest is r%d, source in r%d->0x%08x)\\n\",\n\t\t EXTRACT_REG_NUM(instr, RN_OFFSET), address,\n\t\t destreg, EXTRACT_REG_NUM(instr, RT2_OFFSET), data);\n\n\t/* Check access in reasonable access range for both SWP and SWPB */\n\tif (!access_ok(VERIFY_WRITE, (address & ~3), 4)) {\n\t\tpr_debug(\"SWP{B} emulation: access to %p not allowed!\\n\",\n\t\t\t (void *)address);\n\t\tres = -EFAULT;\n\t} else {\n\t\tres = emulate_swpX(address, &data, type);\n\t}\n\n\tif (res == 0) {\n\t\t/*\n\t\t * On successful emulation, revert the adjustment to the PC\n\t\t * made in kernel/traps.c in order to resume execution at the\n\t\t * instruction following the SWP{B}.\n\t\t */\n\t\tregs->ARM_pc += 4;\n\t\tregs->uregs[destreg] = data;\n\t} else if (res == -EFAULT) {\n\t\t/*\n\t\t * Memory errors do not mean emulation failed.\n\t\t * Set up signal info to return SEGV, then return OK\n\t\t */\n\t\tset_segfault(regs, address);\n\t}\n\n\treturn 0;\n}\n", "target": 1, "idx": 178950}
{"func": "static void user_tick_function_call(user_tick_function_entry *tick_fe TSRMLS_DC) /* {{{ */\n{\n\tzval retval;\n\tzval *function = tick_fe->arguments[0];\n\n\t/* Prevent reentrant calls to the same user ticks function */\n\tif (! tick_fe->calling) {\n\t\ttick_fe->calling = 1;\n\n\t\tif (call_user_function(\tEG(function_table), NULL,\n\t\t\t\t\t\t\t\tfunction,\n\t\t\t\t\t\t\t\t&retval,\n\t\t\t\t\t\t\t\ttick_fe->arg_count - 1,\n\t\t\t\t\t\t\t\ttick_fe->arguments + 1\n\t\t\t\t\t\t\t\tTSRMLS_CC) == SUCCESS) {\n\t\t\tzval_dtor(&retval);\n\n\t\t} else {\n\t\t\tzval **obj, **method;\n\n\t\t\tif (Z_TYPE_P(function) == IS_STRING) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to call %s() - function does not exist\", Z_STRVAL_P(function));\n\t\t\t} else if (\tZ_TYPE_P(function) == IS_ARRAY\n\t\t\t\t\t\t&& zend_hash_index_find(Z_ARRVAL_P(function), 0, (void **) &obj) == SUCCESS\n\t\t\t\t\t\t&& zend_hash_index_find(Z_ARRVAL_P(function), 1, (void **) &method) == SUCCESS\n\t\t\t\t\t\t&& Z_TYPE_PP(obj) == IS_OBJECT\n\t\t\t\t\t\t&& Z_TYPE_PP(method) == IS_STRING) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to call %s::%s() - function does not exist\", Z_OBJCE_PP(obj)->name, Z_STRVAL_PP(method));\n\t\t\t} else {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to call tick function\");\n\t\t\t}\n\t\t}\n\n\t\ttick_fe->calling = 0;\n\t}\n}\n/* }}} */\n", "target": 0, "idx": 4332}
{"func": "int ZLIB_INTERNAL inflate_table(type, lens, codes, table, bits, work)\ncodetype type;\nunsigned short FAR *lens;\nunsigned codes;\ncode FAR * FAR *table;\nunsigned FAR *bits;\nunsigned short FAR *work;\n{\n    unsigned len;               /* a code's length in bits */\n    unsigned sym;               /* index of code symbols */\n    unsigned min, max;          /* minimum and maximum code lengths */\n    unsigned root;              /* number of index bits for root table */\n    unsigned curr;              /* number of index bits for current table */\n    unsigned drop;              /* code bits to drop for sub-table */\n    int left;                   /* number of prefix codes available */\n    unsigned used;              /* code entries in table used */\n    unsigned huff;              /* Huffman code */\n    unsigned incr;              /* for incrementing code, index */\n    unsigned fill;              /* index for replicating entries */\n    unsigned low;               /* low bits for current root entry */\n    unsigned mask;              /* mask for low root bits */\n    code here;                  /* table entry for duplication */\n     code FAR *next;             /* next available space in table */\n     const unsigned short FAR *base;     /* base value table to use */\n     const unsigned short FAR *extra;    /* extra bits table to use */\n    int end;                    /* use base and extra for symbol > end */\n     unsigned short count[MAXBITS+1];    /* number of codes of each length */\n     unsigned short offs[MAXBITS+1];     /* offsets in table for each length */\n     static const unsigned short lbase[31] = { /* Length codes 257..285 base */\n        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};\n    static const unsigned short lext[31] = { /* Length codes 257..285 extra */\n        16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,\n        19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 203, 198};\n    static const unsigned short dbase[32] = { /* Distance codes 0..29 base */\n        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n        8193, 12289, 16385, 24577, 0, 0};\n    static const unsigned short dext[32] = { /* Distance codes 0..29 extra */\n        16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,\n        23, 23, 24, 24, 25, 25, 26, 26, 27, 27,\n        28, 28, 29, 29, 64, 64};\n\n    /*\n       Process a set of code lengths to create a canonical Huffman code.  The\n       code lengths are lens[0..codes-1].  Each length corresponds to the\n       symbols 0..codes-1.  The Huffman code is generated by first sorting the\n       symbols by length from short to long, and retaining the symbol order\n       for codes with equal lengths.  Then the code starts with all zero bits\n       for the first code of the shortest length, and the codes are integer\n       increments for the same length, and zeros are appended as the length\n       increases.  For the deflate format, these bits are stored backwards\n       from their more natural integer increment ordering, and so when the\n       decoding tables are built in the large loop below, the integer codes\n       are incremented backwards.\n\n       This routine assumes, but does not check, that all of the entries in\n       lens[] are in the range 0..MAXBITS.  The caller must assure this.\n       1..MAXBITS is interpreted as that code length.  zero means that that\n       symbol does not occur in this code.\n\n       The codes are sorted by computing a count of codes for each length,\n       creating from that a table of starting indices for each length in the\n       sorted table, and then entering the symbols in order in the sorted\n       table.  The sorted table is work[], with that space being provided by\n       the caller.\n\n       The length counts are used for other purposes as well, i.e. finding\n       the minimum and maximum length codes, determining if there are any\n       codes at all, checking for a valid set of lengths, and looking ahead\n       at length counts to determine sub-table sizes when building the\n       decoding tables.\n     */\n\n    /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */\n    for (len = 0; len <= MAXBITS; len++)\n        count[len] = 0;\n    for (sym = 0; sym < codes; sym++)\n        count[lens[sym]]++;\n\n    /* bound code lengths, force root to be within code lengths */\n    root = *bits;\n    for (max = MAXBITS; max >= 1; max--)\n        if (count[max] != 0) break;\n    if (root > max) root = max;\n    if (max == 0) {                     /* no symbols to code at all */\n        here.op = (unsigned char)64;    /* invalid code marker */\n        here.bits = (unsigned char)1;\n        here.val = (unsigned short)0;\n        *(*table)++ = here;             /* make a table to force an error */\n        *(*table)++ = here;\n        *bits = 1;\n        return 0;     /* no symbols, but wait for decoding to report error */\n    }\n    for (min = 1; min < max; min++)\n        if (count[min] != 0) break;\n    if (root < min) root = min;\n\n    /* check for an over-subscribed or incomplete set of lengths */\n    left = 1;\n    for (len = 1; len <= MAXBITS; len++) {\n        left <<= 1;\n        left -= count[len];\n        if (left < 0) return -1;        /* over-subscribed */\n    }\n    if (left > 0 && (type == CODES || max != 1))\n        return -1;                      /* incomplete set */\n\n    /* generate offsets into symbol table for each length for sorting */\n    offs[1] = 0;\n    for (len = 1; len < MAXBITS; len++)\n        offs[len + 1] = offs[len] + count[len];\n\n    /* sort symbols by length, by symbol order within each length */\n    for (sym = 0; sym < codes; sym++)\n        if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;\n\n    /*\n       Create and fill in decoding tables.  In this loop, the table being\n       filled is at next and has curr index bits.  The code being used is huff\n       with length len.  That code is converted to an index by dropping drop\n       bits off of the bottom.  For codes where len is less than drop + curr,\n       those top drop + curr - len bits are incremented through all values to\n       fill the table with replicated entries.\n\n       root is the number of index bits for the root table.  When len exceeds\n       root, sub-tables are created pointed to by the root entry with an index\n       of the low root bits of huff.  This is saved in low to check for when a\n       new sub-table should be started.  drop is zero when the root table is\n       being filled, and drop is root when sub-tables are being filled.\n\n       When a new sub-table is needed, it is necessary to look ahead in the\n       code lengths to determine what size sub-table is needed.  The length\n       counts are used for this, and so count[] is decremented as codes are\n       entered in the tables.\n\n       used keeps track of how many table entries have been allocated from the\n       provided *table space.  It is checked for LENS and DIST tables against\n       the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in\n       the initial root table size constants.  See the comments in inftrees.h\n       for more information.\n\n       sym increments through all symbols, and the loop terminates when\n       all codes of length max, i.e. all codes, have been processed.  This\n       routine permits incomplete codes, so another loop after this one fills\n       in the rest of the decoding tables with invalid code markers.\n     */\n\n    /* set up for code type */\n     switch (type) {\n     case CODES:\n         base = extra = work;    /* dummy value--not used */\n        end = 19;\n         break;\n     case LENS:\n         base = lbase;\n        base -= 257;\n         extra = lext;\n        extra -= 257;\n        end = 256;\n         break;\n     default:            /* DISTS */\n         base = dbase;\n         extra = dext;\n        end = -1;\n     }\n \n     /* initialize state for loop */\n    huff = 0;                   /* starting code */\n    sym = 0;                    /* starting code symbol */\n    len = min;                  /* starting code length */\n    next = *table;              /* current table to fill in */\n    curr = root;                /* current table index bits */\n    drop = 0;                   /* current bits to drop from code for index */\n    low = (unsigned)(-1);       /* trigger new sub-table when len > root */\n    used = 1U << root;          /* use root table entries */\n    mask = used - 1;            /* mask for comparing low */\n\n    /* check available table space */\n    if ((type == LENS && used > ENOUGH_LENS) ||\n        (type == DISTS && used > ENOUGH_DISTS))\n        return 1;\n\n    /* process all codes and make table entries */\n     for (;;) {\n         /* create table entry */\n         here.bits = (unsigned char)(len - drop);\n        if ((int)(work[sym]) < end) {\n             here.op = (unsigned char)0;\n             here.val = work[sym];\n         }\n        else if ((int)(work[sym]) > end) {\n            here.op = (unsigned char)(extra[work[sym]]);\n            here.val = base[work[sym]];\n         }\n         else {\n             here.op = (unsigned char)(32 + 64);         /* end of block */\n            here.val = 0;\n        }\n\n        /* replicate for those indices with low len bits equal to huff */\n        incr = 1U << (len - drop);\n        fill = 1U << curr;\n        min = fill;                 /* save offset to next table */\n        do {\n            fill -= incr;\n            next[(huff >> drop) + fill] = here;\n        } while (fill != 0);\n\n        /* backwards increment the len-bit code huff */\n        incr = 1U << (len - 1);\n        while (huff & incr)\n            incr >>= 1;\n        if (incr != 0) {\n            huff &= incr - 1;\n            huff += incr;\n        }\n        else\n            huff = 0;\n\n        /* go to next symbol, update count, len */\n        sym++;\n        if (--(count[len]) == 0) {\n            if (len == max) break;\n            len = lens[work[sym]];\n        }\n\n        /* create new sub-table if needed */\n        if (len > root && (huff & mask) != low) {\n            /* if first time, transition to sub-tables */\n            if (drop == 0)\n                drop = root;\n\n            /* increment past last table */\n            next += min;            /* here min is 1 << curr */\n\n            /* determine length of next table */\n            curr = len - drop;\n            left = (int)(1 << curr);\n            while (curr + drop < max) {\n                left -= count[curr + drop];\n                if (left <= 0) break;\n                curr++;\n                left <<= 1;\n            }\n\n            /* check for enough space */\n            used += 1U << curr;\n            if ((type == LENS && used > ENOUGH_LENS) ||\n                (type == DISTS && used > ENOUGH_DISTS))\n                return 1;\n\n            /* point entry in root table to sub-table */\n            low = huff & mask;\n            (*table)[low].op = (unsigned char)curr;\n            (*table)[low].bits = (unsigned char)root;\n            (*table)[low].val = (unsigned short)(next - *table);\n        }\n    }\n\n    /* fill in remaining table entry if code is incomplete (guaranteed to have\n       at most one remaining entry, since if the code is incomplete, the\n       maximum code length that was allowed to get this far is one bit) */\n    if (huff != 0) {\n        here.op = (unsigned char)64;            /* invalid code marker */\n        here.bits = (unsigned char)(len - drop);\n        here.val = (unsigned short)0;\n        next[huff] = here;\n    }\n\n    /* set return parameters */\n    *table += used;\n    *bits = root;\n    return 0;\n}\n", "target": 1, "idx": 181847}
{"func": "LayoutUnit RenderFlexibleBox::flowAwarePaddingAfter() const\n{\n    switch (transformedWritingMode()) {\n    case TopToBottomWritingMode:\n        return paddingBottom();\n    case BottomToTopWritingMode:\n        return paddingTop();\n    case LeftToRightWritingMode:\n        return paddingRight();\n    case RightToLeftWritingMode:\n        return paddingLeft();\n    }\n    ASSERT_NOT_REACHED();\n    return paddingTop();\n}\n", "target": 0, "idx": 125017}
{"func": "static void coroutine_fn v9fs_write(void *opaque)\n{\n    ssize_t err;\n    int32_t fid;\n    uint64_t off;\n    uint32_t count;\n    int32_t len = 0;\n    int32_t total = 0;\n    size_t offset = 7;\n    V9fsFidState *fidp;\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n    QEMUIOVector qiov_full;\n    QEMUIOVector qiov;\n\n    err = pdu_unmarshal(pdu, offset, \"dqd\", &fid, &off, &count);\n    if (err < 0) {\n        pdu_complete(pdu, err);\n        return;\n    }\n    offset += err;\n    v9fs_init_qiov_from_pdu(&qiov_full, pdu, offset, count, true);\n    trace_v9fs_write(pdu->tag, pdu->id, fid, off, count, qiov_full.niov);\n\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    if (fidp->fid_type == P9_FID_FILE) {\n        if (fidp->fs.fd == -1) {\n            err = -EINVAL;\n            goto out;\n        }\n    } else if (fidp->fid_type == P9_FID_XATTR) {\n        /*\n         * setxattr operation\n         */\n        err = v9fs_xattr_write(s, pdu, fidp, off, count,\n                               qiov_full.iov, qiov_full.niov);\n        goto out;\n    } else {\n        err = -EINVAL;\n        goto out;\n    }\n    qemu_iovec_init(&qiov, qiov_full.niov);\n    do {\n        qemu_iovec_reset(&qiov);\n        qemu_iovec_concat(&qiov, &qiov_full, total, qiov_full.size - total);\n        if (0) {\n            print_sg(qiov.iov, qiov.niov);\n        }\n        /* Loop in case of EINTR */\n        do {\n            len = v9fs_co_pwritev(pdu, fidp, qiov.iov, qiov.niov, off);\n            if (len >= 0) {\n                off   += len;\n                total += len;\n            }\n        } while (len == -EINTR && !pdu->cancelled);\n        if (len < 0) {\n            /* IO error return the error */\n            err = len;\n            goto out_qiov;\n        }\n    } while (total < count && len > 0);\n\n     offset = 7;\n     err = pdu_marshal(pdu, offset, \"d\", total);\n     if (err < 0) {\n        goto out;\n     }\n     err += offset;\n     trace_v9fs_write_return(pdu->tag, pdu->id, total, err);\nout_qiov:\n    qemu_iovec_destroy(&qiov);\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    qemu_iovec_destroy(&qiov_full);\n    pdu_complete(pdu, err);\n}\n", "target": 1, "idx": 178078}
{"func": "M_bool M_fs_path_ishidden(const char *path, M_fs_info_t *info)\n{\n\tM_list_str_t *path_parts;\n\tsize_t        len;\n\tM_bool        ret        = M_FALSE;\n\n\t(void)info;\n\n\tif (path == NULL || *path == '\\0') {\n\t\treturn M_FALSE;\n \t}\n \n \t/* Hidden. Check if the first character of the last part of the path. Either the file or directory name itself\n \t * starts with a '.'. */\n \tpath_parts = M_fs_path_componentize_path(path, M_FS_SYSTEM_UNIX);\n \tlen = M_list_str_len(path_parts);\n \tif (len > 0) {\n\t\tif (*M_list_str_at(path_parts, len-1) == '.') {\n\t\t\tret = M_TRUE;\n\t\t}\n\t}\n\tM_list_str_destroy(path_parts);\n\n\treturn ret;\n}\n", "target": 1, "idx": 182317}
{"func": "error::Error GLES2DecoderPassthroughImpl::DoGetInteger64v(GLenum pname,\n                                                          GLsizei bufsize,\n                                                          GLsizei* length,\n                                                          GLint64* params) {\n  return GetNumericHelper(\n      pname, bufsize, length, params,\n      [this](GLenum pname, GLsizei bufsize, GLsizei* length, GLint64* params) {\n        api()->glGetInteger64vRobustANGLEFn(pname, bufsize, length, params);\n      });\n}\n", "target": 0, "idx": 154688}
{"func": "static void crypto_rfc4106_free(struct crypto_instance *inst)\n{\n\tcrypto_drop_spawn(crypto_instance_ctx(inst));\n\tkfree(inst);\n}\n", "target": 0, "idx": 45751}
{"func": "static TEE_Result get_open_session_meta(size_t num_params,\n\t\t\t\t\tstruct optee_msg_param *params,\n\t\t\t\t\tsize_t *num_meta, TEE_UUID *uuid,\n\t\t\t\t\tTEE_Identity *clnt_id)\n{\n\tconst uint32_t req_attr = OPTEE_MSG_ATTR_META |\n\t\t\t\t  OPTEE_MSG_ATTR_TYPE_VALUE_INPUT;\n\n\tif (num_params < 2)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tif (params[0].attr != req_attr || params[1].attr != req_attr)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\ttee_uuid_from_octets(uuid, (void *)&params[0].u.value);\n\tclnt_id->login = params[1].u.value.c;\n\tswitch (clnt_id->login) {\n\tcase TEE_LOGIN_PUBLIC:\n\t\tmemset(&clnt_id->uuid, 0, sizeof(clnt_id->uuid));\n\t\tbreak;\n\tcase TEE_LOGIN_USER:\n\tcase TEE_LOGIN_GROUP:\n\tcase TEE_LOGIN_APPLICATION:\n\tcase TEE_LOGIN_APPLICATION_USER:\n\tcase TEE_LOGIN_APPLICATION_GROUP:\n\t\ttee_uuid_from_octets(&clnt_id->uuid,\n\t\t\t\t     (void *)&params[1].u.value);\n\t\tbreak;\n\tdefault:\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\t*num_meta = 2;\n\treturn TEE_SUCCESS;\n}\n", "target": 0, "idx": 86999}
{"func": " jbig2_image_compose_unopt(Jbig2Ctx *ctx, Jbig2Image *dst, Jbig2Image *src, int x, int y, Jbig2ComposeOp op)\n {\n    int i, j;\n    int sw = src->width;\n    int sh = src->height;\n    int sx = 0;\n    int sy = 0;\n \n     /* clip to the dst image boundaries */\n     if (x < 0) {\n        sx += -x;\n        sw -= -x;\n        x = 0;\n    }\n    if (y < 0) {\n        sy += -y;\n        sh -= -y;\n        y = 0;\n    }\n    if (x + sw >= dst->width)\n        sw = dst->width - x;\n    if (y + sh >= dst->height)\n        sh = dst->height - y;\n\n    switch (op) {\n    case JBIG2_COMPOSE_OR:\n        for (j = 0; j < sh; j++) {\n            for (i = 0; i < sw; i++) {\n                jbig2_image_set_pixel(dst, i + x, j + y, jbig2_image_get_pixel(src, i + sx, j + sy) | jbig2_image_get_pixel(dst, i + x, j + y));\n            }\n        }\n        break;\n    case JBIG2_COMPOSE_AND:\n        for (j = 0; j < sh; j++) {\n            for (i = 0; i < sw; i++) {\n                jbig2_image_set_pixel(dst, i + x, j + y, jbig2_image_get_pixel(src, i + sx, j + sy) & jbig2_image_get_pixel(dst, i + x, j + y));\n            }\n        }\n        break;\n    case JBIG2_COMPOSE_XOR:\n        for (j = 0; j < sh; j++) {\n            for (i = 0; i < sw; i++) {\n                jbig2_image_set_pixel(dst, i + x, j + y, jbig2_image_get_pixel(src, i + sx, j + sy) ^ jbig2_image_get_pixel(dst, i + x, j + y));\n            }\n        }\n        break;\n    case JBIG2_COMPOSE_XNOR:\n        for (j = 0; j < sh; j++) {\n            for (i = 0; i < sw; i++) {\n                jbig2_image_set_pixel(dst, i + x, j + y, (jbig2_image_get_pixel(src, i + sx, j + sy) == jbig2_image_get_pixel(dst, i + x, j + y)));\n            }\n        }\n        break;\n    case JBIG2_COMPOSE_REPLACE:\n        for (j = 0; j < sh; j++) {\n            for (i = 0; i < sw; i++) {\n                jbig2_image_set_pixel(dst, i + x, j + y, jbig2_image_get_pixel(src, i + sx, j + sy));\n            }\n        }\n        break;\n    }\n\n    return 0;\n}\n", "target": 1, "idx": 178662}
{"func": "png_read_init_3(png_structpp ptr_ptr, png_const_charp user_png_ver,\n   png_size_t png_struct_size)\n{\n#ifdef PNG_SETJMP_SUPPORTED\n   jmp_buf tmp_jmp;  /* to save current jump buffer */\n#endif\n\n   int i = 0;\n\n   png_structp png_ptr=*ptr_ptr;\n\n   if (png_ptr == NULL)\n      return;\n \n    do\n    {\n      if (user_png_ver[i] != png_libpng_ver[i])\n       {\n #ifdef PNG_LEGACY_SUPPORTED\n         png_ptr->flags |= PNG_FLAG_LIBRARY_MISMATCH;\n#else\n        png_ptr->warning_fn = NULL;\n        png_warning(png_ptr,\n         \"Application uses deprecated png_read_init() and should be\"\n         \" recompiled.\");\n        break;\n#endif\n      }\n   } while (png_libpng_ver[i++]);\n\n   png_debug(1, \"in png_read_init_3\");\n\n#ifdef PNG_SETJMP_SUPPORTED\n   /* Save jump buffer and error functions */\n   png_memcpy(tmp_jmp, png_ptr->jmpbuf, png_sizeof(jmp_buf));\n#endif\n\n   if (png_sizeof(png_struct) > png_struct_size)\n   {\n      png_destroy_struct(png_ptr);\n      *ptr_ptr = (png_structp)png_create_struct(PNG_STRUCT_PNG);\n      png_ptr = *ptr_ptr;\n   }\n\n   /* Reset all variables to 0 */\n   png_memset(png_ptr, 0, png_sizeof(png_struct));\n\n#ifdef PNG_SETJMP_SUPPORTED\n   /* Restore jump buffer */\n   png_memcpy(png_ptr->jmpbuf, tmp_jmp, png_sizeof(jmp_buf));\n#endif\n\n   /* Added at libpng-1.2.6 */\n#ifdef PNG_SET_USER_LIMITS_SUPPORTED\n   png_ptr->user_width_max = PNG_USER_WIDTH_MAX;\n   png_ptr->user_height_max = PNG_USER_HEIGHT_MAX;\n#endif\n\n   /* Initialize zbuf - compression buffer */\n   png_ptr->zbuf_size = PNG_ZBUF_SIZE;\n   png_ptr->zstream.zalloc = png_zalloc;\n   png_ptr->zbuf = (png_bytep)png_malloc(png_ptr,\n     (png_uint_32)png_ptr->zbuf_size);\n   png_ptr->zstream.zalloc = png_zalloc;\n   png_ptr->zstream.zfree = png_zfree;\n   png_ptr->zstream.opaque = (voidpf)png_ptr;\n\n   switch (inflateInit(&png_ptr->zstream))\n   {\n      case Z_OK: /* Do nothing */ break;\n      case Z_STREAM_ERROR: png_error(png_ptr, \"zlib memory error\"); break;\n      case Z_VERSION_ERROR: png_error(png_ptr, \"zlib version error\");\n          break;\n      default: png_error(png_ptr, \"Unknown zlib error\");\n   }\n\n   png_ptr->zstream.next_out = png_ptr->zbuf;\n   png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;\n\n   png_set_read_fn(png_ptr, png_voidp_NULL, png_rw_ptr_NULL);\n}\n", "target": 1, "idx": 186137}
{"func": "void hugetlb_unreserve_pages(struct inode *inode, long offset, long freed)\n {\n \tstruct hstate *h = hstate_inode(inode);\n \tlong chg = region_truncate(&inode->i_mapping->private_list, offset);\n \n \tspin_lock(&inode->i_lock);\n \tinode->i_blocks -= (blocks_per_huge_page(h) * freed);\n \tspin_unlock(&inode->i_lock);\n \n\thugetlb_put_quota(inode->i_mapping, (chg - freed));\n \thugetlb_acct_memory(h, -(chg - freed));\n }\n", "target": 1, "idx": 178783}
{"func": "void ExtensionInstalledBubble::Show(const Extension* extension,\n                                    Browser *browser,\n                                    const SkBitmap& icon) {\n  new ExtensionInstalledBubble(extension, browser, icon);\n}\n", "target": 0, "idx": 116035}
{"func": "ssize_t blkdev_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct blk_plug plug;\n\tssize_t ret;\n\n\tblk_start_plug(&plug);\n\tret = __generic_file_write_iter(iocb, from);\n\tif (ret > 0) {\n\t\tssize_t err;\n\t\terr = generic_write_sync(file, iocb->ki_pos - ret, ret);\n\t\tif (err < 0)\n\t\t\tret = err;\n\t}\n\tblk_finish_plug(&plug);\n\treturn ret;\n}\n", "target": 0, "idx": 46267}
{"func": "void PrepareDropData(DropData* drop_data, const ui::OSExchangeData& data) {\n  base::string16 plain_text;\n  data.GetString(&plain_text);\n  if (!plain_text.empty())\n    drop_data->text = base::NullableString16(plain_text, false);\n \n   GURL url;\n   base::string16 url_title;\n  data.GetURLAndTitle(&url, &url_title);\n   if (url.is_valid()) {\n     drop_data->url = url;\n     drop_data->url_title = url_title;\n  }\n\n  base::string16 html;\n  GURL html_base_url;\n  data.GetHtml(&html, &html_base_url);\n  if (!html.empty())\n    drop_data->html = base::NullableString16(html, false);\n  if (html_base_url.is_valid())\n    drop_data->html_base_url = html_base_url;\n\n  std::vector<ui::OSExchangeData::FileInfo> files;\n  if (data.GetFilenames(&files) && !files.empty()) {\n    for (std::vector<ui::OSExchangeData::FileInfo>::const_iterator\n             it = files.begin(); it != files.end(); ++it) {\n      drop_data->filenames.push_back(\n          DropData::FileInfo(\n              base::UTF8ToUTF16(it->path.AsUTF8Unsafe()),\n              base::UTF8ToUTF16(it->display_name.AsUTF8Unsafe())));\n    }\n  }\n\n  Pickle pickle;\n  if (data.GetPickledData(ui::Clipboard::GetWebCustomDataFormatType(), &pickle))\n    ui::ReadCustomDataIntoMap(\n        pickle.data(), pickle.size(), &drop_data->custom_data);\n}\n", "target": 1, "idx": 185576}
{"func": "static int ext4_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tchar *orig_data = kstrdup(data, GFP_KERNEL);\n\tstruct buffer_head *bh;\n\tstruct ext4_super_block *es = NULL;\n\tstruct ext4_sb_info *sbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\text4_fsblk_t block;\n\text4_fsblk_t sb_block = get_sb_block(&data);\n\text4_fsblk_t logical_sb_block;\n\tunsigned long offset = 0;\n\tunsigned long journal_devnum = 0;\n\tunsigned long def_mount_opts;\n\tstruct inode *root;\n\tconst char *descr;\n\tint ret = -ENOMEM;\n\tint blocksize, clustersize;\n\tunsigned int db_count;\n\tunsigned int i;\n\tint needs_recovery, has_huge_files, has_bigalloc;\n\t__u64 blocks_count;\n\tint err = 0;\n\tunsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO;\n\text4_group_t first_not_zeroed;\n\n\tif ((data && !orig_data) || !sbi)\n\t\tgoto out_free_base;\n\n\tsbi->s_blockgroup_lock =\n\t\tkzalloc(sizeof(struct blockgroup_lock), GFP_KERNEL);\n\tif (!sbi->s_blockgroup_lock)\n\t\tgoto out_free_base;\n\n\tsb->s_fs_info = sbi;\n\tsbi->s_sb = sb;\n\tsbi->s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS;\n\tsbi->s_sb_block = sb_block;\n\tif (sb->s_bdev->bd_part)\n\t\tsbi->s_sectors_written_start =\n\t\t\tpart_stat_read(sb->s_bdev->bd_part, sectors[1]);\n\n\t/* Cleanup superblock name */\n\tstrreplace(sb->s_id, '/', '!');\n\n\t/* -EINVAL is default */\n\tret = -EINVAL;\n\tblocksize = sb_min_blocksize(sb, EXT4_MIN_BLOCK_SIZE);\n\tif (!blocksize) {\n\t\text4_msg(sb, KERN_ERR, \"unable to set blocksize\");\n\t\tgoto out_fail;\n\t}\n\n\t/*\n\t * The ext4 superblock will not be buffer aligned for other than 1kB\n\t * block sizes.  We need to calculate the offset from buffer start.\n\t */\n\tif (blocksize != EXT4_MIN_BLOCK_SIZE) {\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t} else {\n\t\tlogical_sb_block = sb_block;\n\t}\n\n\tif (!(bh = sb_bread_unmovable(sb, logical_sb_block))) {\n\t\text4_msg(sb, KERN_ERR, \"unable to read superblock\");\n\t\tgoto out_fail;\n\t}\n\t/*\n\t * Note: s_es must be initialized as soon as possible because\n\t *       some ext4 macro-instructions depend on its value\n\t */\n\tes = (struct ext4_super_block *) (bh->b_data + offset);\n\tsbi->s_es = es;\n\tsb->s_magic = le16_to_cpu(es->s_magic);\n\tif (sb->s_magic != EXT4_SUPER_MAGIC)\n\t\tgoto cantfind_ext4;\n\tsbi->s_kbytes_written = le64_to_cpu(es->s_kbytes_written);\n\n\t/* Warn if metadata_csum and gdt_csum are both set. */\n\tif (ext4_has_feature_metadata_csum(sb) &&\n\t    ext4_has_feature_gdt_csum(sb))\n\t\text4_warning(sb, \"metadata_csum and uninit_bg are \"\n\t\t\t     \"redundant flags; please run fsck.\");\n\n\t/* Check for a known checksum algorithm */\n\tif (!ext4_verify_csum_type(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"unknown checksum algorithm.\");\n\t\tsilent = 1;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Load the checksum driver */\n\tif (ext4_has_feature_metadata_csum(sb)) {\n\t\tsbi->s_chksum_driver = crypto_alloc_shash(\"crc32c\", 0, 0);\n\t\tif (IS_ERR(sbi->s_chksum_driver)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Cannot load crc32c driver.\");\n\t\t\tret = PTR_ERR(sbi->s_chksum_driver);\n\t\t\tsbi->s_chksum_driver = NULL;\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/* Check superblock checksum */\n\tif (!ext4_superblock_csum_verify(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"invalid superblock checksum.  Run e2fsck?\");\n\t\tsilent = 1;\n\t\tret = -EFSBADCRC;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Precompute checksum seed for all metadata */\n\tif (ext4_has_feature_csum_seed(sb))\n\t\tsbi->s_csum_seed = le32_to_cpu(es->s_checksum_seed);\n\telse if (ext4_has_metadata_csum(sb))\n\t\tsbi->s_csum_seed = ext4_chksum(sbi, ~0, es->s_uuid,\n\t\t\t\t\t       sizeof(es->s_uuid));\n\n\t/* Set defaults before we parse the mount options */\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\tset_opt(sb, INIT_INODE_TABLE);\n\tif (def_mount_opts & EXT4_DEFM_DEBUG)\n\t\tset_opt(sb, DEBUG);\n\tif (def_mount_opts & EXT4_DEFM_BSDGROUPS)\n\t\tset_opt(sb, GRPID);\n\tif (def_mount_opts & EXT4_DEFM_UID16)\n\t\tset_opt(sb, NO_UID32);\n\t/* xattr user namespace & acls are now defaulted on */\n\tset_opt(sb, XATTR_USER);\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\tset_opt(sb, POSIX_ACL);\n#endif\n\t/* don't forget to enable journal_csum when metadata_csum is enabled. */\n\tif (ext4_has_metadata_csum(sb))\n\t\tset_opt(sb, JOURNAL_CHECKSUM);\n\n\tif ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_DATA)\n\t\tset_opt(sb, JOURNAL_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_ORDERED)\n\t\tset_opt(sb, ORDERED_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_WBACK)\n\t\tset_opt(sb, WRITEBACK_DATA);\n\n\tif (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_PANIC)\n\t\tset_opt(sb, ERRORS_PANIC);\n\telse if (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_CONTINUE)\n\t\tset_opt(sb, ERRORS_CONT);\n\telse\n\t\tset_opt(sb, ERRORS_RO);\n\t/* block_validity enabled by default; disable with noblock_validity */\n\tset_opt(sb, BLOCK_VALIDITY);\n\tif (def_mount_opts & EXT4_DEFM_DISCARD)\n\t\tset_opt(sb, DISCARD);\n\n\tsbi->s_resuid = make_kuid(&init_user_ns, le16_to_cpu(es->s_def_resuid));\n\tsbi->s_resgid = make_kgid(&init_user_ns, le16_to_cpu(es->s_def_resgid));\n\tsbi->s_commit_interval = JBD2_DEFAULT_MAX_COMMIT_AGE * HZ;\n\tsbi->s_min_batch_time = EXT4_DEF_MIN_BATCH_TIME;\n\tsbi->s_max_batch_time = EXT4_DEF_MAX_BATCH_TIME;\n\n\tif ((def_mount_opts & EXT4_DEFM_NOBARRIER) == 0)\n\t\tset_opt(sb, BARRIER);\n\n\t/*\n\t * enable delayed allocation by default\n\t * Use -o nodelalloc to turn it off\n\t */\n\tif (!IS_EXT3_SB(sb) && !IS_EXT2_SB(sb) &&\n\t    ((def_mount_opts & EXT4_DEFM_NODELALLOC) == 0))\n\t\tset_opt(sb, DELALLOC);\n\n\t/*\n\t * set default s_li_wait_mult for lazyinit, for the case there is\n\t * no mount option specified.\n\t */\n\tsbi->s_li_wait_mult = EXT4_DEF_LI_WAIT_MULT;\n\n\tif (sbi->s_es->s_mount_opts[0]) {\n\t\tchar *s_mount_opts = kstrndup(sbi->s_es->s_mount_opts,\n\t\t\t\t\t      sizeof(sbi->s_es->s_mount_opts),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!s_mount_opts)\n\t\t\tgoto failed_mount;\n\t\tif (!parse_options(s_mount_opts, sb, &journal_devnum,\n\t\t\t\t   &journal_ioprio, 0)) {\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"failed to parse options in superblock: %s\",\n\t\t\t\t s_mount_opts);\n\t\t}\n\t\tkfree(s_mount_opts);\n\t}\n\tsbi->s_def_mount_opt = sbi->s_mount_opt;\n\tif (!parse_options((char *) data, sb, &journal_devnum,\n\t\t\t   &journal_ioprio, 0))\n\t\tgoto failed_mount;\n\n\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA) {\n\t\tprintk_once(KERN_WARNING \"EXT4-fs: Warning: mounting \"\n\t\t\t    \"with data=journal disables delayed \"\n\t\t\t    \"allocation and O_DIRECT support!\\n\");\n\t\tif (test_opt2(sb, EXPLICIT_DELALLOC)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and delalloc\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DIOREAD_NOLOCK)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dioread_nolock\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DAX)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dax\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DELALLOC))\n\t\t\tclear_opt(sb, DELALLOC);\n\t} else {\n\t\tsb->s_iflags |= SB_I_CGROUPWB;\n\t}\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t(test_opt(sb, POSIX_ACL) ? MS_POSIXACL : 0);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV &&\n\t    (ext4_has_compat_features(sb) ||\n\t     ext4_has_ro_compat_features(sb) ||\n\t     ext4_has_incompat_features(sb)))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t       \"feature flags set on rev 0 fs, \"\n\t\t       \"running e2fsck is recommended\");\n\n\tif (es->s_creator_os == cpu_to_le32(EXT4_OS_HURD)) {\n\t\tset_opt2(sb, HURD_COMPAT);\n\t\tif (ext4_has_feature_64bit(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"The Hurd can't support 64-bit file systems\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT2_SB(sb)) {\n\t\tif (ext2_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext2 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext2 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT3_SB(sb)) {\n\t\tif (ext3_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext3 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext3 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/*\n\t * Check feature flags regardless of the revision level, since we\n\t * previously didn't change the revision level when setting the flags,\n\t * so there is a chance incompat flags are set on a rev 0 filesystem.\n\t */\n\tif (!ext4_feature_set_ok(sb, (sb->s_flags & MS_RDONLY)))\n\t\tgoto failed_mount;\n\n\tblocksize = BLOCK_SIZE << le32_to_cpu(es->s_log_block_size);\n\tif (blocksize < EXT4_MIN_BLOCK_SIZE ||\n\t    blocksize > EXT4_MAX_BLOCK_SIZE) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t       \"Unsupported filesystem blocksize %d (%d log_block_size)\",\n\t\t\t blocksize, le32_to_cpu(es->s_log_block_size));\n\t\tgoto failed_mount;\n\t}\n\tif (le32_to_cpu(es->s_log_block_size) >\n\t    (EXT4_MAX_BLOCK_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Invalid log block size: %u\",\n\t\t\t le32_to_cpu(es->s_log_block_size));\n\t\tgoto failed_mount;\n\t}\n\n\tif (le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks) > (blocksize / 4)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Number of reserved GDT blocks insanely large: %d\",\n\t\t\t le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks));\n\t\tgoto failed_mount;\n\t}\n\n\tif (sbi->s_mount_opt & EXT4_MOUNT_DAX) {\n\t\terr = bdev_dax_supported(sb, blocksize);\n\t\tif (err)\n\t\t\tgoto failed_mount;\n\t}\n\n\tif (ext4_has_feature_encrypt(sb) && es->s_encryption_level) {\n\t\text4_msg(sb, KERN_ERR, \"Unsupported encryption level %d\",\n\t\t\t es->s_encryption_level);\n\t\tgoto failed_mount;\n\t}\n\n\tif (sb->s_blocksize != blocksize) {\n\t\t/* Validate the filesystem blocksize */\n\t\tif (!sb_set_blocksize(sb, blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR, \"bad block size %d\",\n\t\t\t\t\tblocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t\tbh = sb_bread_unmovable(sb, logical_sb_block);\n\t\tif (!bh) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Can't read superblock on 2nd try\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tes = (struct ext4_super_block *)(bh->b_data + offset);\n\t\tsbi->s_es = es;\n\t\tif (es->s_magic != cpu_to_le16(EXT4_SUPER_MAGIC)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Magic mismatch, very weird!\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\thas_huge_files = ext4_has_feature_huge_file(sb);\n\tsbi->s_bitmap_maxbytes = ext4_max_bitmap_size(sb->s_blocksize_bits,\n\t\t\t\t\t\t      has_huge_files);\n\tsb->s_maxbytes = ext4_max_size(sb->s_blocksize_bits, has_huge_files);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV) {\n\t\tsbi->s_inode_size = EXT4_GOOD_OLD_INODE_SIZE;\n\t\tsbi->s_first_ino = EXT4_GOOD_OLD_FIRST_INO;\n\t} else {\n\t\tsbi->s_inode_size = le16_to_cpu(es->s_inode_size);\n\t\tsbi->s_first_ino = le32_to_cpu(es->s_first_ino);\n\t\tif ((sbi->s_inode_size < EXT4_GOOD_OLD_INODE_SIZE) ||\n\t\t    (!is_power_of_2(sbi->s_inode_size)) ||\n\t\t    (sbi->s_inode_size > blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported inode size: %d\",\n\t\t\t       sbi->s_inode_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE)\n\t\t\tsb->s_time_gran = 1 << (EXT4_EPOCH_BITS - 2);\n\t}\n\n\tsbi->s_desc_size = le16_to_cpu(es->s_desc_size);\n\tif (ext4_has_feature_64bit(sb)) {\n\t\tif (sbi->s_desc_size < EXT4_MIN_DESC_SIZE_64BIT ||\n\t\t    sbi->s_desc_size > EXT4_MAX_DESC_SIZE ||\n\t\t    !is_power_of_2(sbi->s_desc_size)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported descriptor size %lu\",\n\t\t\t       sbi->s_desc_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else\n\t\tsbi->s_desc_size = EXT4_MIN_DESC_SIZE;\n\n\tsbi->s_blocks_per_group = le32_to_cpu(es->s_blocks_per_group);\n\tsbi->s_inodes_per_group = le32_to_cpu(es->s_inodes_per_group);\n\n\tsbi->s_inodes_per_block = blocksize / EXT4_INODE_SIZE(sb);\n\tif (sbi->s_inodes_per_block == 0)\n\t\tgoto cantfind_ext4;\n\tif (sbi->s_inodes_per_group < sbi->s_inodes_per_block ||\n\t    sbi->s_inodes_per_group > blocksize * 8) {\n\t\text4_msg(sb, KERN_ERR, \"invalid inodes per group: %lu\\n\",\n\t\t\t sbi->s_blocks_per_group);\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_itb_per_group = sbi->s_inodes_per_group /\n\t\t\t\t\tsbi->s_inodes_per_block;\n\tsbi->s_desc_per_block = blocksize / EXT4_DESC_SIZE(sb);\n\tsbi->s_sbh = bh;\n\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\tsbi->s_addr_per_block_bits = ilog2(EXT4_ADDR_PER_BLOCK(sb));\n\tsbi->s_desc_per_block_bits = ilog2(EXT4_DESC_PER_BLOCK(sb));\n\n\tfor (i = 0; i < 4; i++)\n\t\tsbi->s_hash_seed[i] = le32_to_cpu(es->s_hash_seed[i]);\n\tsbi->s_def_hash_version = es->s_def_hash_version;\n\tif (ext4_has_feature_dir_index(sb)) {\n\t\ti = le32_to_cpu(es->s_flags);\n\t\tif (i & EXT2_FLAGS_UNSIGNED_HASH)\n\t\t\tsbi->s_hash_unsigned = 3;\n\t\telse if ((i & EXT2_FLAGS_SIGNED_HASH) == 0) {\n#ifdef __CHAR_UNSIGNED__\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_UNSIGNED_HASH);\n\t\t\tsbi->s_hash_unsigned = 3;\n#else\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_SIGNED_HASH);\n#endif\n\t\t}\n\t}\n\n\t/* Handle clustersize */\n\tclustersize = BLOCK_SIZE << le32_to_cpu(es->s_log_cluster_size);\n\thas_bigalloc = ext4_has_feature_bigalloc(sb);\n\tif (has_bigalloc) {\n\t\tif (clustersize < blocksize) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"cluster size (%d) smaller than \"\n\t\t\t\t \"block size (%d)\", clustersize, blocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (le32_to_cpu(es->s_log_cluster_size) >\n\t\t    (EXT4_MAX_CLUSTER_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"Invalid log cluster size: %u\",\n\t\t\t\t le32_to_cpu(es->s_log_cluster_size));\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_cluster_bits = le32_to_cpu(es->s_log_cluster_size) -\n\t\t\tle32_to_cpu(es->s_log_block_size);\n\t\tsbi->s_clusters_per_group =\n\t\t\tle32_to_cpu(es->s_clusters_per_group);\n\t\tif (sbi->s_clusters_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#clusters per group too big: %lu\",\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_blocks_per_group !=\n\t\t    (sbi->s_clusters_per_group * (clustersize / blocksize))) {\n\t\t\text4_msg(sb, KERN_ERR, \"blocks per group (%lu) and \"\n\t\t\t\t \"clusters per group (%lu) inconsistent\",\n\t\t\t\t sbi->s_blocks_per_group,\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else {\n\t\tif (clustersize != blocksize) {\n\t\t\text4_warning(sb, \"fragment/cluster size (%d) != \"\n\t\t\t\t     \"block size (%d)\", clustersize,\n\t\t\t\t     blocksize);\n\t\t\tclustersize = blocksize;\n\t\t}\n\t\tif (sbi->s_blocks_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#blocks per group too big: %lu\",\n\t\t\t\t sbi->s_blocks_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_clusters_per_group = sbi->s_blocks_per_group;\n\t\tsbi->s_cluster_bits = 0;\n\t}\n\tsbi->s_cluster_ratio = clustersize / blocksize;\n\n\t/* Do we have standard group size of clustersize * 8 blocks ? */\n\tif (sbi->s_blocks_per_group == clustersize << 3)\n\t\tset_opt2(sb, STD_GROUP_SIZE);\n\n\t/*\n\t * Test whether we have more sectors than will fit in sector_t,\n\t * and whether the max offset is addressable by the page cache.\n\t */\n\terr = generic_check_addressable(sb->s_blocksize_bits,\n\t\t\t\t\text4_blocks_count(es));\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"filesystem\"\n\t\t\t \" too large to mount safely on this system\");\n\t\tif (sizeof(sector_t) < 8)\n\t\t\text4_msg(sb, KERN_WARNING, \"CONFIG_LBDAF not enabled\");\n\t\tgoto failed_mount;\n\t}\n\n\tif (EXT4_BLOCKS_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext4;\n\n\t/* check blocks count against device size */\n\tblocks_count = sb->s_bdev->bd_inode->i_size >> sb->s_blocksize_bits;\n\tif (blocks_count && ext4_blocks_count(es) > blocks_count) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: block count %llu \"\n\t\t       \"exceeds size of device (%llu blocks)\",\n\t\t       ext4_blocks_count(es), blocks_count);\n\t\tgoto failed_mount;\n\t}\n\n\t/*\n\t * It makes no sense for the first data block to be beyond the end\n\t * of the filesystem.\n\t */\n\tif (le32_to_cpu(es->s_first_data_block) >= ext4_blocks_count(es)) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: first data \"\n\t\t\t \"block %u is beyond end of filesystem (%llu)\",\n\t\t\t le32_to_cpu(es->s_first_data_block),\n\t\t\t ext4_blocks_count(es));\n\t\tgoto failed_mount;\n\t}\n\tblocks_count = (ext4_blocks_count(es) -\n\t\t\tle32_to_cpu(es->s_first_data_block) +\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb) - 1);\n\tdo_div(blocks_count, EXT4_BLOCKS_PER_GROUP(sb));\n\tif (blocks_count > ((uint64_t)1<<32) - EXT4_DESC_PER_BLOCK(sb)) {\n\t\text4_msg(sb, KERN_WARNING, \"groups count too large: %u \"\n\t\t       \"(block count %llu, first data block %u, \"\n\t\t       \"blocks per group %lu)\", sbi->s_groups_count,\n\t\t       ext4_blocks_count(es),\n\t\t       le32_to_cpu(es->s_first_data_block),\n\t\t       EXT4_BLOCKS_PER_GROUP(sb));\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_groups_count = blocks_count;\n\tsbi->s_blockfile_groups = min_t(ext4_group_t, sbi->s_groups_count,\n \t\t\t(EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP(sb)));\n \tdb_count = (sbi->s_groups_count + EXT4_DESC_PER_BLOCK(sb) - 1) /\n \t\t   EXT4_DESC_PER_BLOCK(sb);\n \tsbi->s_group_desc = ext4_kvmalloc(db_count *\n \t\t\t\t\t  sizeof(struct buffer_head *),\n \t\t\t\t\t  GFP_KERNEL);\n\tif (sbi->s_group_desc == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount;\n\t}\n\n\tbgl_lock_init(sbi->s_blockgroup_lock);\n\n\tfor (i = 0; i < db_count; i++) {\n\t\tblock = descriptor_loc(sb, logical_sb_block, i);\n\t\tsbi->s_group_desc[i] = sb_bread_unmovable(sb, block);\n\t\tif (!sbi->s_group_desc[i]) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"can't read group descriptor %d\", i);\n\t\t\tdb_count = i;\n\t\t\tgoto failed_mount2;\n\t\t}\n\t}\n\tif (!ext4_check_descriptors(sb, logical_sb_block, &first_not_zeroed)) {\n\t\text4_msg(sb, KERN_ERR, \"group descriptors corrupted!\");\n\t\tret = -EFSCORRUPTED;\n\t\tgoto failed_mount2;\n\t}\n\n\tsbi->s_gdb_count = db_count;\n\tget_random_bytes(&sbi->s_next_generation, sizeof(u32));\n\tspin_lock_init(&sbi->s_next_gen_lock);\n\n\tsetup_timer(&sbi->s_err_report, print_daily_error_info,\n\t\t(unsigned long) sb);\n\n\t/* Register extent status tree shrinker */\n\tif (ext4_es_register_shrinker(sbi))\n\t\tgoto failed_mount3;\n\n\tsbi->s_stripe = ext4_get_stripe_size(sbi);\n\tsbi->s_extent_max_zeroout_kb = 32;\n\n\t/*\n\t * set up enough so that it can read an inode\n\t */\n\tsb->s_op = &ext4_sops;\n\tsb->s_export_op = &ext4_export_ops;\n\tsb->s_xattr = ext4_xattr_handlers;\n\tsb->s_cop = &ext4_cryptops;\n#ifdef CONFIG_QUOTA\n\tsb->dq_op = &ext4_quota_operations;\n\tif (ext4_has_feature_quota(sb))\n\t\tsb->s_qcop = &dquot_quotactl_sysfile_ops;\n\telse\n\t\tsb->s_qcop = &ext4_qctl_operations;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP | QTYPE_MASK_PRJ;\n#endif\n\tmemcpy(sb->s_uuid, es->s_uuid, sizeof(es->s_uuid));\n\n\tINIT_LIST_HEAD(&sbi->s_orphan); /* unlinked but open files */\n\tmutex_init(&sbi->s_orphan_lock);\n\n\tsb->s_root = NULL;\n\n\tneeds_recovery = (es->s_last_orphan != 0 ||\n\t\t\t  ext4_has_feature_journal_needs_recovery(sb));\n\n\tif (ext4_has_feature_mmp(sb) && !(sb->s_flags & MS_RDONLY))\n\t\tif (ext4_multi_mount_protect(sb, le64_to_cpu(es->s_mmp_block)))\n\t\t\tgoto failed_mount3a;\n\n\t/*\n\t * The first inode we look at is the journal inode.  Don't try\n\t * root first: it may be modified in the journal!\n\t */\n\tif (!test_opt(sb, NOLOAD) && ext4_has_feature_journal(sb)) {\n\t\tif (ext4_load_journal(sb, es, journal_devnum))\n\t\t\tgoto failed_mount3a;\n\t} else if (test_opt(sb, NOLOAD) && !(sb->s_flags & MS_RDONLY) &&\n\t\t   ext4_has_feature_journal_needs_recovery(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"required journal recovery \"\n\t\t       \"suppressed and not mounted read-only\");\n\t\tgoto failed_mount_wq;\n\t} else {\n\t\t/* Nojournal mode, all journal mount options are illegal */\n\t\tif (test_opt2(sb, EXPLICIT_JOURNAL_CHECKSUM)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_checksum, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_async_commit, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (sbi->s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE*HZ) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"commit=%lu, fs mounted w/o journal\",\n\t\t\t\t sbi->s_commit_interval / HZ);\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (EXT4_MOUNT_DATA_FLAGS &\n\t\t    (sbi->s_mount_opt ^ sbi->s_def_mount_opt)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"data=, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tsbi->s_def_mount_opt &= EXT4_MOUNT_JOURNAL_CHECKSUM;\n\t\tclear_opt(sb, JOURNAL_CHECKSUM);\n\t\tclear_opt(sb, DATA_FLAGS);\n\t\tsbi->s_journal = NULL;\n\t\tneeds_recovery = 0;\n\t\tgoto no_journal;\n\t}\n\n\tif (ext4_has_feature_64bit(sb) &&\n\t    !jbd2_journal_set_features(EXT4_SB(sb)->s_journal, 0, 0,\n\t\t\t\t       JBD2_FEATURE_INCOMPAT_64BIT)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set 64-bit journal feature\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (!set_journal_csum_feature_set(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set journal checksum \"\n\t\t\t \"feature set\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\t/* We have now updated the journal if required, so we can\n\t * validate the data journaling mode. */\n\tswitch (test_opt(sb, DATA_FLAGS)) {\n\tcase 0:\n\t\t/* No mode set, assume a default based on the journal\n\t\t * capabilities: ORDERED_DATA if the journal can\n\t\t * cope, else JOURNAL_DATA\n\t\t */\n\t\tif (jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE))\n\t\t\tset_opt(sb, ORDERED_DATA);\n\t\telse\n\t\t\tset_opt(sb, JOURNAL_DATA);\n\t\tbreak;\n\n\tcase EXT4_MOUNT_ORDERED_DATA:\n\tcase EXT4_MOUNT_WRITEBACK_DATA:\n\t\tif (!jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Journal does not support \"\n\t\t\t       \"requested data journaling mode\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\tdefault:\n\t\tbreak;\n\t}\n\tset_task_ioprio(sbi->s_journal->j_task, journal_ioprio);\n\n\tsbi->s_journal->j_commit_callback = ext4_journal_commit_callback;\n\nno_journal:\n\tsbi->s_mb_cache = ext4_xattr_create_cache();\n\tif (!sbi->s_mb_cache) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to create an mb_cache\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif ((DUMMY_ENCRYPTION_ENABLED(sbi) || ext4_has_feature_encrypt(sb)) &&\n\t    (blocksize != PAGE_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Unsupported blocksize for fs encryption\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (DUMMY_ENCRYPTION_ENABLED(sbi) && !(sb->s_flags & MS_RDONLY) &&\n\t    !ext4_has_feature_encrypt(sb)) {\n\t\text4_set_feature_encrypt(sb);\n\t\text4_commit_super(sb, 1);\n\t}\n\n\t/*\n\t * Get the # of file system overhead blocks from the\n\t * superblock if present.\n\t */\n\tif (es->s_overhead_clusters)\n\t\tsbi->s_overhead = le32_to_cpu(es->s_overhead_clusters);\n\telse {\n\t\terr = ext4_calculate_overhead(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount_wq;\n\t}\n\n\t/*\n\t * The maximum number of concurrent works can be high and\n\t * concurrency isn't really necessary.  Limit it to 1.\n\t */\n\tEXT4_SB(sb)->rsv_conversion_wq =\n\t\talloc_workqueue(\"ext4-rsv-conversion\", WQ_MEM_RECLAIM | WQ_UNBOUND, 1);\n\tif (!EXT4_SB(sb)->rsv_conversion_wq) {\n\t\tprintk(KERN_ERR \"EXT4-fs: failed to create workqueue\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\t/*\n\t * The jbd2_journal_load will have done any necessary log recovery,\n\t * so we can safely mount the rest of the filesystem now.\n\t */\n\n\troot = ext4_iget(sb, EXT4_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\text4_msg(sb, KERN_ERR, \"get root inode failed\");\n\t\tret = PTR_ERR(root);\n\t\troot = NULL;\n\t\tgoto failed_mount4;\n\t}\n\tif (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {\n\t\text4_msg(sb, KERN_ERR, \"corrupt root inode, run e2fsck\");\n\t\tiput(root);\n\t\tgoto failed_mount4;\n\t}\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\text4_msg(sb, KERN_ERR, \"get root dentry failed\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\tif (ext4_setup_super(sb, es, sb->s_flags & MS_RDONLY))\n\t\tsb->s_flags |= MS_RDONLY;\n\n\t/* determine the minimum size of new large inodes, if present */\n\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t     EXT4_GOOD_OLD_INODE_SIZE;\n\t\tif (ext4_has_feature_extra_isize(sb)) {\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_want_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_want_extra_isize);\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_min_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_min_extra_isize);\n\t\t}\n\t}\n\t/* Check if enough inode space is available */\n\tif (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >\n\t\t\t\t\t\t\tsbi->s_inode_size) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t       EXT4_GOOD_OLD_INODE_SIZE;\n\t\text4_msg(sb, KERN_INFO, \"required extra inode space not\"\n\t\t\t \"available\");\n\t}\n\n\text4_set_resv_clusters(sb);\n\n\terr = ext4_setup_system_zone(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize system \"\n\t\t\t \"zone (%d)\", err);\n\t\tgoto failed_mount4a;\n\t}\n\n\text4_ext_init(sb);\n\terr = ext4_mb_init(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize mballoc (%d)\",\n\t\t\t err);\n\t\tgoto failed_mount5;\n\t}\n\n\tblock = ext4_count_free_clusters(sb);\n\text4_free_blocks_count_set(sbi->s_es, \n\t\t\t\t   EXT4_C2B(sbi, block));\n\terr = percpu_counter_init(&sbi->s_freeclusters_counter, block,\n\t\t\t\t  GFP_KERNEL);\n\tif (!err) {\n\t\tunsigned long freei = ext4_count_free_inodes(sb);\n\t\tsbi->s_es->s_free_inodes_count = cpu_to_le32(freei);\n\t\terr = percpu_counter_init(&sbi->s_freeinodes_counter, freei,\n\t\t\t\t\t  GFP_KERNEL);\n\t}\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirs_counter,\n\t\t\t\t\t  ext4_count_dirs(sb), GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirtyclusters_counter, 0,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_init_rwsem(&sbi->s_journal_flag_rwsem);\n\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"insufficient memory\");\n\t\tgoto failed_mount6;\n\t}\n\n\tif (ext4_has_feature_flex_bg(sb))\n\t\tif (!ext4_fill_flex_info(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unable to initialize \"\n\t\t\t       \"flex_bg meta info!\");\n\t\t\tgoto failed_mount6;\n\t\t}\n\n\terr = ext4_register_li_request(sb, first_not_zeroed);\n\tif (err)\n\t\tgoto failed_mount6;\n\n\terr = ext4_register_sysfs(sb);\n\tif (err)\n\t\tgoto failed_mount7;\n\n#ifdef CONFIG_QUOTA\n\t/* Enable quota usage during mount. */\n\tif (ext4_has_feature_quota(sb) && !(sb->s_flags & MS_RDONLY)) {\n\t\terr = ext4_enable_quotas(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount8;\n\t}\n#endif  /* CONFIG_QUOTA */\n\n\tEXT4_SB(sb)->s_mount_state |= EXT4_ORPHAN_FS;\n\text4_orphan_cleanup(sb, es);\n\tEXT4_SB(sb)->s_mount_state &= ~EXT4_ORPHAN_FS;\n\tif (needs_recovery) {\n\t\text4_msg(sb, KERN_INFO, \"recovery complete\");\n\t\text4_mark_recovery_complete(sb, es);\n\t}\n\tif (EXT4_SB(sb)->s_journal) {\n\t\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)\n\t\t\tdescr = \" journalled data mode\";\n\t\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)\n\t\t\tdescr = \" ordered data mode\";\n\t\telse\n\t\t\tdescr = \" writeback data mode\";\n\t} else\n\t\tdescr = \"out journal\";\n\n\tif (test_opt(sb, DISCARD)) {\n\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\tif (!blk_queue_discard(q))\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"mounting with \\\"discard\\\" option, but \"\n\t\t\t\t \"the device does not support discard\");\n\t}\n\n\tif (___ratelimit(&ext4_mount_msg_ratelimit, \"EXT4-fs mount\"))\n\t\text4_msg(sb, KERN_INFO, \"mounted filesystem with%s. \"\n\t\t\t \"Opts: %.*s%s%s\", descr,\n\t\t\t (int) sizeof(sbi->s_es->s_mount_opts),\n\t\t\t sbi->s_es->s_mount_opts,\n\t\t\t *sbi->s_es->s_mount_opts ? \"; \" : \"\", orig_data);\n\n\tif (es->s_error_count)\n\t\tmod_timer(&sbi->s_err_report, jiffies + 300*HZ); /* 5 minutes */\n\n\t/* Enable message ratelimiting. Default is 10 messages per 5 secs. */\n\tratelimit_state_init(&sbi->s_err_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_warning_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_msg_ratelimit_state, 5 * HZ, 10);\n\n\tkfree(orig_data);\n#ifdef CONFIG_EXT4_FS_ENCRYPTION\n\tmemcpy(sbi->key_prefix, EXT4_KEY_DESC_PREFIX,\n\t\t\t\tEXT4_KEY_DESC_PREFIX_SIZE);\n\tsbi->key_prefix_size = EXT4_KEY_DESC_PREFIX_SIZE;\n#endif\n\treturn 0;\n\ncantfind_ext4:\n\tif (!silent)\n\t\text4_msg(sb, KERN_ERR, \"VFS: Can't find ext4 filesystem\");\n\tgoto failed_mount;\n\n#ifdef CONFIG_QUOTA\nfailed_mount8:\n\text4_unregister_sysfs(sb);\n#endif\nfailed_mount7:\n\text4_unregister_li_request(sb);\nfailed_mount6:\n\text4_mb_release(sb);\n\tif (sbi->s_flex_groups)\n\t\tkvfree(sbi->s_flex_groups);\n\tpercpu_counter_destroy(&sbi->s_freeclusters_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tpercpu_counter_destroy(&sbi->s_dirtyclusters_counter);\nfailed_mount5:\n\text4_ext_release(sb);\n\text4_release_system_zone(sb);\nfailed_mount4a:\n\tdput(sb->s_root);\n\tsb->s_root = NULL;\nfailed_mount4:\n\text4_msg(sb, KERN_ERR, \"mount failed\");\n\tif (EXT4_SB(sb)->rsv_conversion_wq)\n\t\tdestroy_workqueue(EXT4_SB(sb)->rsv_conversion_wq);\nfailed_mount_wq:\n\tif (sbi->s_mb_cache) {\n\t\text4_xattr_destroy_cache(sbi->s_mb_cache);\n\t\tsbi->s_mb_cache = NULL;\n\t}\n\tif (sbi->s_journal) {\n\t\tjbd2_journal_destroy(sbi->s_journal);\n\t\tsbi->s_journal = NULL;\n\t}\nfailed_mount3a:\n\text4_es_unregister_shrinker(sbi);\nfailed_mount3:\n\tdel_timer_sync(&sbi->s_err_report);\n\tif (sbi->s_mmp_tsk)\n\t\tkthread_stop(sbi->s_mmp_tsk);\nfailed_mount2:\n\tfor (i = 0; i < db_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\n\tkvfree(sbi->s_group_desc);\nfailed_mount:\n\tif (sbi->s_chksum_driver)\n\t\tcrypto_free_shash(sbi->s_chksum_driver);\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\text4_blkdev_remove(sbi);\n\tbrelse(bh);\nout_fail:\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\nout_free_base:\n\tkfree(sbi);\n\tkfree(orig_data);\n\treturn err ? err : ret;\n}\n", "target": 1, "idx": 181660}
{"func": "v8::Handle<v8::Value> V8WebGLRenderingContext::getProgramParameterCallback(const v8::Arguments& args)\n{\n     INC_STATS(\"DOM.WebGLRenderingContext.getProgramParameter()\");\n \n     if (args.Length() != 2)\n        return V8Proxy::throwNotEnoughArgumentsError();\n \n     ExceptionCode ec = 0;\n     WebGLRenderingContext* context = V8WebGLRenderingContext::toNative(args.Holder());\n    if (args.Length() > 0 && !isUndefinedOrNull(args[0]) && !V8WebGLProgram::HasInstance(args[0])) {\n        V8Proxy::throwTypeError();\n        return notHandledByInterceptor();\n    }\n    WebGLProgram* program = V8WebGLProgram::HasInstance(args[0]) ? V8WebGLProgram::toNative(v8::Handle<v8::Object>::Cast(args[0])) : 0;\n    unsigned pname = toInt32(args[1]);\n    WebGLGetInfo info = context->getProgramParameter(program, pname, ec);\n    if (ec) {\n        V8Proxy::setDOMException(ec, args.GetIsolate());\n        return v8::Undefined();\n    }\n    return toV8Object(info, args.GetIsolate());\n}\n", "target": 1, "idx": 184817}
{"func": "bool PanelBrowserView::OnTitlebarMouseDragged(\n    const gfx::Point& mouse_location) {\n  if (!mouse_pressed_)\n    return false;\n\n  int delta_x = mouse_location.x() - last_mouse_location_.x();\n  int delta_y = mouse_location.y() - last_mouse_location_.y();\n   if (mouse_dragging_state_ == NO_DRAGGING &&\n       ExceededDragThreshold(delta_x, delta_y)) {\n    old_focused_view_ = GetFocusManager()->GetFocusedView();\n    GetFocusManager()->SetFocusedView(GetFrameView());\n \n     panel_->manager()->StartDragging(panel_.get(), last_mouse_location_);\n     mouse_dragging_state_ = DRAGGING_STARTED;\n  }\n  if (mouse_dragging_state_ == DRAGGING_STARTED) {\n    panel_->manager()->Drag(mouse_location);\n\n    last_mouse_location_ = mouse_location;\n  }\n  return true;\n}\n", "target": 1, "idx": 184479}
{"func": "static int xfrm_user_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlattr *attrs[XFRMA_MAX+1];\n\tconst struct xfrm_link *link;\n\tint type, err;\n\n#ifdef CONFIG_COMPAT\n\tif (in_compat_syscall())\n\t\treturn -EOPNOTSUPP;\n#endif\n\n\ttype = nlh->nlmsg_type;\n\tif (type > XFRM_MSG_MAX)\n\t\treturn -EINVAL;\n\n\ttype -= XFRM_MSG_BASE;\n\tlink = &xfrm_dispatch[type];\n\n\t/* All operations require privileges, even GET */\n\tif (!netlink_net_capable(skb, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif ((type == (XFRM_MSG_GETSA - XFRM_MSG_BASE) ||\n\t     type == (XFRM_MSG_GETPOLICY - XFRM_MSG_BASE)) &&\n\t    (nlh->nlmsg_flags & NLM_F_DUMP)) {\n\t\tif (link->dump == NULL)\n\t\t\treturn -EINVAL;\n \n \t\t{\n \t\t\tstruct netlink_dump_control c = {\n \t\t\t\t.dump = link->dump,\n \t\t\t\t.done = link->done,\n \t\t\t};\n\t\t\treturn netlink_dump_start(net->xfrm.nlsk, skb, nlh, &c);\n\t\t}\n\t}\n\n\terr = nlmsg_parse(nlh, xfrm_msg_min[type], attrs,\n\t\t\t  link->nla_max ? : XFRMA_MAX,\n\t\t\t  link->nla_pol ? : xfrma_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (link->doit == NULL)\n\t\treturn -EINVAL;\n\n\treturn link->doit(skb, nlh, attrs);\n}\n", "target": 1, "idx": 180836}
{"func": "bool HeapAllocator::expandHashTableBacking(void* address, size_t newSize) {\n  return backingExpand(address, newSize);\n}\n", "target": 0, "idx": 160331}
{"func": "void SoftAVC::setDecodeArgs(\n         ivd_video_decode_ip_t *ps_dec_ip,\n         ivd_video_decode_op_t *ps_dec_op,\n         OMX_BUFFERHEADERTYPE *inHeader,\n        OMX_BUFFERHEADERTYPE *outHeader,\n\n         size_t timeStampIx) {\n     size_t sizeY = outputBufferWidth() * outputBufferHeight();\n     size_t sizeUV;\n    uint8_t *pBuf;\n \n     ps_dec_ip->u4_size = sizeof(ivd_video_decode_ip_t);\n     ps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);\n\n    ps_dec_ip->e_cmd = IVD_CMD_VIDEO_DECODE;\n\n /* When in flush and after EOS with zero byte input,\n     * inHeader is set to zero. Hence check for non-null */\n if (inHeader) {\n        ps_dec_ip->u4_ts = timeStampIx;\n        ps_dec_ip->pv_stream_buffer =\n            inHeader->pBuffer + inHeader->nOffset;\n        ps_dec_ip->u4_num_Bytes = inHeader->nFilledLen;\n } else {\n        ps_dec_ip->u4_ts = 0;\n        ps_dec_ip->pv_stream_buffer = NULL;\n\n         ps_dec_ip->u4_num_Bytes = 0;\n     }\n \n    if (outHeader) {\n        pBuf = outHeader->pBuffer;\n    } else {\n        pBuf = mFlushOutBuffer;\n    }\n     sizeUV = sizeY / 4;\n     ps_dec_ip->s_out_buffer.u4_min_out_buf_size[0] = sizeY;\n     ps_dec_ip->s_out_buffer.u4_min_out_buf_size[1] = sizeUV;\n     ps_dec_ip->s_out_buffer.u4_min_out_buf_size[2] = sizeUV;\n \n     ps_dec_ip->s_out_buffer.pu1_bufs[0] = pBuf;\n     ps_dec_ip->s_out_buffer.pu1_bufs[1] = pBuf + sizeY;\n     ps_dec_ip->s_out_buffer.pu1_bufs[2] = pBuf + sizeY + sizeUV;\n     ps_dec_ip->s_out_buffer.u4_num_bufs = 3;\n    return;\n }\n", "target": 1, "idx": 188202}
{"func": "Label::Label() {\n  Init(std::wstring(), GetDefaultFont());\n}\n", "target": 0, "idx": 105789}
{"func": "bool CommandsIssuedQuery::Process() {\n  NOTREACHED();\n  return true;\n}\n", "target": 0, "idx": 130502}
{"func": "MSG_PROCESS_RETURN tls_process_certificate_request(SSL *s, PACKET *pkt)\n{\n    int ret = MSG_PROCESS_ERROR;\n    unsigned int list_len, ctype_num, i, name_len;\n    X509_NAME *xn = NULL;\n    const unsigned char *data;\n    const unsigned char *namestart, *namebytes;\n    STACK_OF(X509_NAME) *ca_sk = NULL;\n\n    if ((ca_sk = sk_X509_NAME_new(ca_dn_cmp)) == NULL) {\n        SSLerr(SSL_F_TLS_PROCESS_CERTIFICATE_REQUEST, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    /* get the certificate types */\n    if (!PACKET_get_1(pkt, &ctype_num)\n        || !PACKET_get_bytes(pkt, &data, ctype_num)) {\n        ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n        SSLerr(SSL_F_TLS_PROCESS_CERTIFICATE_REQUEST, SSL_R_LENGTH_MISMATCH);\n        goto err;\n    }\n    OPENSSL_free(s->cert->ctypes);\n    s->cert->ctypes = NULL;\n    if (ctype_num > SSL3_CT_NUMBER) {\n        /* If we exceed static buffer copy all to cert structure */\n        s->cert->ctypes = OPENSSL_malloc(ctype_num);\n        if (s->cert->ctypes == NULL) {\n            SSLerr(SSL_F_TLS_PROCESS_CERTIFICATE_REQUEST, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n        memcpy(s->cert->ctypes, data, ctype_num);\n        s->cert->ctype_num = (size_t)ctype_num;\n        ctype_num = SSL3_CT_NUMBER;\n    }\n    for (i = 0; i < ctype_num; i++)\n        s->s3->tmp.ctype[i] = data[i];\n\n    if (SSL_USE_SIGALGS(s)) {\n        if (!PACKET_get_net_2(pkt, &list_len)\n            || !PACKET_get_bytes(pkt, &data, list_len)) {\n            ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n            SSLerr(SSL_F_TLS_PROCESS_CERTIFICATE_REQUEST,\n                   SSL_R_LENGTH_MISMATCH);\n            goto err;\n        }\n\n        /* Clear certificate digests and validity flags */\n        for (i = 0; i < SSL_PKEY_NUM; i++) {\n            s->s3->tmp.md[i] = NULL;\n            s->s3->tmp.valid_flags[i] = 0;\n        }\n        if ((list_len & 1) || !tls1_save_sigalgs(s, data, list_len)) {\n            ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n            SSLerr(SSL_F_TLS_PROCESS_CERTIFICATE_REQUEST,\n                   SSL_R_SIGNATURE_ALGORITHMS_ERROR);\n            goto err;\n        }\n        if (!tls1_process_sigalgs(s)) {\n            ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);\n            SSLerr(SSL_F_TLS_PROCESS_CERTIFICATE_REQUEST, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n    } else {\n        ssl_set_default_md(s);\n    }\n\n    /* get the CA RDNs */\n    if (!PACKET_get_net_2(pkt, &list_len)\n        || PACKET_remaining(pkt) != list_len) {\n        ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n        SSLerr(SSL_F_TLS_PROCESS_CERTIFICATE_REQUEST, SSL_R_LENGTH_MISMATCH);\n        goto err;\n    }\n\n    while (PACKET_remaining(pkt)) {\n        if (!PACKET_get_net_2(pkt, &name_len)\n            || !PACKET_get_bytes(pkt, &namebytes, name_len)) {\n            ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n            SSLerr(SSL_F_TLS_PROCESS_CERTIFICATE_REQUEST,\n                   SSL_R_LENGTH_MISMATCH);\n            goto err;\n        }\n\n        namestart = namebytes;\n\n        if ((xn = d2i_X509_NAME(NULL, (const unsigned char **)&namebytes,\n                                name_len)) == NULL) {\n            ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n            SSLerr(SSL_F_TLS_PROCESS_CERTIFICATE_REQUEST, ERR_R_ASN1_LIB);\n            goto err;\n        }\n\n        if (namebytes != (namestart + name_len)) {\n            ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n            SSLerr(SSL_F_TLS_PROCESS_CERTIFICATE_REQUEST,\n                   SSL_R_CA_DN_LENGTH_MISMATCH);\n            goto err;\n        }\n        if (!sk_X509_NAME_push(ca_sk, xn)) {\n            SSLerr(SSL_F_TLS_PROCESS_CERTIFICATE_REQUEST, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n        xn = NULL;\n    }\n\n    /* we should setup a certificate to return.... */\n    s->s3->tmp.cert_req = 1;\n    s->s3->tmp.ctype_num = ctype_num;\n    sk_X509_NAME_pop_free(s->s3->tmp.ca_names, X509_NAME_free);\n    s->s3->tmp.ca_names = ca_sk;\n    ca_sk = NULL;\n\n    ret = MSG_PROCESS_CONTINUE_PROCESSING;\n    goto done;\n err:\n    ossl_statem_set_error(s);\n done:\n    X509_NAME_free(xn);\n    sk_X509_NAME_pop_free(ca_sk, X509_NAME_free);\n    return ret;\n}\n", "target": 0, "idx": 69381}
{"func": "String WebFrameLoaderClient::generatedMIMETypeForURLScheme(const String& URLScheme) const {\n  String mimetype(\"x-apple-web-kit/\");\n  mimetype.append(URLScheme.lower());\n  return mimetype;\n}\n", "target": 0, "idx": 97214}
{"func": "void SynchronousCompositorImpl::SetInputHandler(\n    cc::InputHandler* input_handler) {\n  DCHECK(CalledOnValidThread());\n  if (input_handler_)\n    input_handler_->SetRootLayerScrollOffsetDelegate(NULL);\n  input_handler_ = input_handler;\n  if (input_handler_)\n    input_handler_->SetRootLayerScrollOffsetDelegate(this);\n}\n", "target": 1, "idx": 185592}
{"func": "static int super_90_validate(struct mddev *mddev, struct md_rdev *rdev)\n{\n\tmdp_disk_t *desc;\n\tmdp_super_t *sb = page_address(rdev->sb_page);\n\t__u64 ev1 = md_event(sb);\n\n\trdev->raid_disk = -1;\n\tclear_bit(Faulty, &rdev->flags);\n\tclear_bit(In_sync, &rdev->flags);\n\tclear_bit(Bitmap_sync, &rdev->flags);\n\tclear_bit(WriteMostly, &rdev->flags);\n\n\tif (mddev->raid_disks == 0) {\n\t\tmddev->major_version = 0;\n\t\tmddev->minor_version = sb->minor_version;\n\t\tmddev->patch_version = sb->patch_version;\n\t\tmddev->external = 0;\n\t\tmddev->chunk_sectors = sb->chunk_size >> 9;\n\t\tmddev->ctime = sb->ctime;\n\t\tmddev->utime = sb->utime;\n\t\tmddev->level = sb->level;\n\t\tmddev->clevel[0] = 0;\n\t\tmddev->layout = sb->layout;\n\t\tmddev->raid_disks = sb->raid_disks;\n\t\tmddev->dev_sectors = ((sector_t)sb->size) * 2;\n\t\tmddev->events = ev1;\n\t\tmddev->bitmap_info.offset = 0;\n\t\tmddev->bitmap_info.space = 0;\n\t\t/* bitmap can use 60 K after the 4K superblocks */\n\t\tmddev->bitmap_info.default_offset = MD_SB_BYTES >> 9;\n\t\tmddev->bitmap_info.default_space = 64*2 - (MD_SB_BYTES >> 9);\n\t\tmddev->reshape_backwards = 0;\n\n\t\tif (mddev->minor_version >= 91) {\n\t\t\tmddev->reshape_position = sb->reshape_position;\n\t\t\tmddev->delta_disks = sb->delta_disks;\n\t\t\tmddev->new_level = sb->new_level;\n\t\t\tmddev->new_layout = sb->new_layout;\n\t\t\tmddev->new_chunk_sectors = sb->new_chunk >> 9;\n\t\t\tif (mddev->delta_disks < 0)\n\t\t\t\tmddev->reshape_backwards = 1;\n\t\t} else {\n\t\t\tmddev->reshape_position = MaxSector;\n\t\t\tmddev->delta_disks = 0;\n\t\t\tmddev->new_level = mddev->level;\n\t\t\tmddev->new_layout = mddev->layout;\n\t\t\tmddev->new_chunk_sectors = mddev->chunk_sectors;\n\t\t}\n\n\t\tif (sb->state & (1<<MD_SB_CLEAN))\n\t\t\tmddev->recovery_cp = MaxSector;\n\t\telse {\n\t\t\tif (sb->events_hi == sb->cp_events_hi &&\n\t\t\t\tsb->events_lo == sb->cp_events_lo) {\n\t\t\t\tmddev->recovery_cp = sb->recovery_cp;\n\t\t\t} else\n\t\t\t\tmddev->recovery_cp = 0;\n\t\t}\n\n\t\tmemcpy(mddev->uuid+0, &sb->set_uuid0, 4);\n\t\tmemcpy(mddev->uuid+4, &sb->set_uuid1, 4);\n\t\tmemcpy(mddev->uuid+8, &sb->set_uuid2, 4);\n\t\tmemcpy(mddev->uuid+12,&sb->set_uuid3, 4);\n\n\t\tmddev->max_disks = MD_SB_DISKS;\n\n\t\tif (sb->state & (1<<MD_SB_BITMAP_PRESENT) &&\n\t\t    mddev->bitmap_info.file == NULL) {\n\t\t\tmddev->bitmap_info.offset =\n\t\t\t\tmddev->bitmap_info.default_offset;\n\t\t\tmddev->bitmap_info.space =\n\t\t\t\tmddev->bitmap_info.default_space;\n\t\t}\n\n\t} else if (mddev->pers == NULL) {\n\t\t/* Insist on good event counter while assembling, except\n\t\t * for spares (which don't need an event count) */\n\t\t++ev1;\n\t\tif (sb->disks[rdev->desc_nr].state & (\n\t\t\t    (1<<MD_DISK_SYNC) | (1 << MD_DISK_ACTIVE)))\n\t\t\tif (ev1 < mddev->events)\n\t\t\t\treturn -EINVAL;\n\t} else if (mddev->bitmap) {\n\t\t/* if adding to array with a bitmap, then we can accept an\n\t\t * older device ... but not too old.\n\t\t */\n\t\tif (ev1 < mddev->bitmap->events_cleared)\n\t\t\treturn 0;\n\t\tif (ev1 < mddev->events)\n\t\t\tset_bit(Bitmap_sync, &rdev->flags);\n\t} else {\n\t\tif (ev1 < mddev->events)\n\t\t\t/* just a hot-add of a new device, leave raid_disk at -1 */\n\t\t\treturn 0;\n\t}\n\n\tif (mddev->level != LEVEL_MULTIPATH) {\n\t\tdesc = sb->disks + rdev->desc_nr;\n\n\t\tif (desc->state & (1<<MD_DISK_FAULTY))\n\t\t\tset_bit(Faulty, &rdev->flags);\n\t\telse if (desc->state & (1<<MD_DISK_SYNC) /* &&\n\t\t\t    desc->raid_disk < mddev->raid_disks */) {\n\t\t\tset_bit(In_sync, &rdev->flags);\n\t\t\trdev->raid_disk = desc->raid_disk;\n\t\t\trdev->saved_raid_disk = desc->raid_disk;\n\t\t} else if (desc->state & (1<<MD_DISK_ACTIVE)) {\n\t\t\t/* active but not in sync implies recovery up to\n\t\t\t * reshape position.  We don't know exactly where\n\t\t\t * that is, so set to zero for now */\n\t\t\tif (mddev->minor_version >= 91) {\n\t\t\t\trdev->recovery_offset = 0;\n\t\t\t\trdev->raid_disk = desc->raid_disk;\n\t\t\t}\n\t\t}\n\t\tif (desc->state & (1<<MD_DISK_WRITEMOSTLY))\n\t\t\tset_bit(WriteMostly, &rdev->flags);\n\t} else /* MULTIPATH are always insync */\n\t\tset_bit(In_sync, &rdev->flags);\n\treturn 0;\n}\n", "target": 0, "idx": 42554}
{"func": "poppler_page_selection_region_free (GList *region)\n{\n  if (!region)\n    return;\n\n  g_list_foreach (region, (GFunc)poppler_rectangle_free, NULL);\n  g_list_free (region);\n}\n", "target": 0, "idx": 806}
{"func": "void RecordCacheFlags(HistogramCacheFlag flag) {\n  UMA_HISTOGRAM_ENUMERATION(\"Navigation.BackForward.CacheFlags\", flag,\n                            HISTOGRAM_CACHE_FLAG_MAX);\n}\n", "target": 0, "idx": 164957}
{"func": " void buffer_slow_realign(struct buffer *buf)\n {\n       /* two possible cases :\n        *   - the buffer is in one contiguous block, we move it in-place\n        *   - the buffer is in two blocks, we move it via the swap_buffer\n        */\n       if (buf->i) {\n               int block1 = buf->i;\n               int block2 = 0;\n               if (buf->p + buf->i > buf->data + buf->size) {\n                       /* non-contiguous block */\n                       block1 = buf->data + buf->size - buf->p;\n                       block2 = buf->p + buf->i - (buf->data + buf->size);\n               }\n               if (block2)\n                       memcpy(swap_buffer, buf->data, block2);\n               memmove(buf->data, buf->p, block1);\n               if (block2)\n                       memcpy(buf->data + block1, swap_buffer, block2);\n        }\n \n        buf->p = buf->data;\n }\n", "target": 1, "idx": 177886}
{"func": "nfsd_sanitize_attrs(struct inode *inode, struct iattr *iap)\n{\n\t/* sanitize the mode change */\n\tif (iap->ia_valid & ATTR_MODE) {\n\t\tiap->ia_mode &= S_IALLUGO;\n\t\tiap->ia_mode |= (inode->i_mode & ~S_IALLUGO);\n\t}\n\n\t/* Revoke setuid/setgid on chown */\n\tif (!S_ISDIR(inode->i_mode) &&\n\t    ((iap->ia_valid & ATTR_UID) || (iap->ia_valid & ATTR_GID))) {\n\t\tiap->ia_valid |= ATTR_KILL_PRIV;\n\t\tif (iap->ia_valid & ATTR_MODE) {\n\t\t\t/* we're setting mode too, just clear the s*id bits */\n\t\t\tiap->ia_mode &= ~S_ISUID;\n\t\t\tif (iap->ia_mode & S_IXGRP)\n\t\t\t\tiap->ia_mode &= ~S_ISGID;\n\t\t} else {\n\t\t\t/* set ATTR_KILL_* bits and let VFS handle it */\n\t\t\tiap->ia_valid |= (ATTR_KILL_SUID | ATTR_KILL_SGID);\n\t\t}\n\t}\n}\n", "target": 0, "idx": 65908}
{"func": "read_gif(Gif_Reader *grr, int read_flags,\n\t const char* landmark, Gif_ReadErrorHandler handler)\n{\n  Gif_Stream *gfs;\n  Gif_Image *gfi;\n  Gif_Context gfc;\n  int unknown_block_type = 0;\n\n  if (gifgetc(grr) != 'G' ||\n      gifgetc(grr) != 'I' ||\n      gifgetc(grr) != 'F')\n    return 0;\n  (void)gifgetc(grr);\n  (void)gifgetc(grr);\n  (void)gifgetc(grr);\n\n  gfs = Gif_NewStream();\n  gfi = Gif_NewImage();\n\n  gfc.stream = gfs;\n  gfc.prefix = Gif_NewArray(Gif_Code, GIF_MAX_CODE);\n  gfc.suffix = Gif_NewArray(uint8_t, GIF_MAX_CODE);\n  gfc.length = Gif_NewArray(uint16_t, GIF_MAX_CODE);\n  gfc.handler = handler;\n  gfc.gfi = gfi;\n  gfc.errors[0] = gfc.errors[1] = 0;\n\n  if (!gfs || !gfi || !gfc.prefix || !gfc.suffix || !gfc.length)\n    goto done;\n  gfs->landmark = landmark;\n\n  GIF_DEBUG((\"\\nGIF \"));\n  if (!read_logical_screen_descriptor(gfs, grr))\n    goto done;\n  GIF_DEBUG((\"logscrdesc \"));\n\n  while (!gifeof(grr)) {\n\n    uint8_t block = gifgetbyte(grr);\n\n    switch (block) {\n\n     case ',': /* image block */\n      GIF_DEBUG((\"imageread %d \", gfs->nimages));\n\n      gfi->identifier = last_name;\n      last_name = 0;\n      if (!Gif_AddImage(gfs, gfi))\n          goto done;\n      else if (!read_image(grr, &gfc, gfi, read_flags)) {\n          Gif_RemoveImage(gfs, gfs->nimages - 1);\n          gfi = 0;\n          goto done;\n      }\n\n      gfc.gfi = gfi = Gif_NewImage();\n      if (!gfi)\n          goto done;\n      break;\n\n     case ';': /* terminator */\n      GIF_DEBUG((\"term\\n\"));\n      goto done;\n\n     case '!': /* extension */\n      block = gifgetbyte(grr);\n      GIF_DEBUG((\"ext(0x%02X) \", block));\n      switch (block) {\n\n       case 0xF9:\n\tread_graphic_control_extension(&gfc, gfi, grr);\n\tbreak;\n\n       case 0xCE:\n\tlast_name = suck_data(last_name, 0, grr);\n\tbreak;\n\n       case 0xFE:\n\tif (!read_comment_extension(gfi, grr)) goto done;\n\tbreak;\n\n       case 0xFF:\n\tread_application_extension(&gfc, grr);\n\tbreak;\n\n       default:\n        read_unknown_extension(&gfc, grr, block, 0, 0);\n\tbreak;\n\n      }\n      break;\n\n     default:\n       if (!unknown_block_type) {\n\t char buf[256];\n\t sprintf(buf, \"unknown block type %d at file offset %u\", block, grr->pos - 1);\n\t gif_read_error(&gfc, 1, buf);\n\t unknown_block_type = 1;\n       }\n       break;\n\n    }\n\n  }\n\n done:\n\n  /* Move comments and extensions after last image into stream. */\n  if (gfs && gfi) {\n      Gif_Extension* gfex;\n      gfs->end_comment = gfi->comment;\n      gfi->comment = 0;\n      gfs->end_extension_list = gfi->extension_list;\n      gfi->extension_list = 0;\n      for (gfex = gfs->end_extension_list; gfex; gfex = gfex->next)\n          gfex->image = NULL;\n  }\n\n  Gif_DeleteImage(gfi);\n  Gif_DeleteArray(last_name);\n  Gif_DeleteArray(gfc.prefix);\n   Gif_DeleteArray(gfc.suffix);\n   Gif_DeleteArray(gfc.length);\n   gfc.gfi = 0;\n \n   if (gfs)\n     gfs->errors = gfc.errors[1];\n  if (gfs && gfc.errors[1] == 0\n      && !(read_flags & GIF_READ_TRAILING_GARBAGE_OK)\n      && !grr->eofer(grr))\n      gif_read_error(&gfc, 0, \"trailing garbage after GIF ignored\");\n  /* finally, export last message */\n  gif_read_error(&gfc, -1, 0);\n\n  return gfs;\n}\n", "target": 1, "idx": 182592}
{"func": " ip_printroute(netdissect_options *ndo,\n               register const u_char *cp, u_int length)\n {\n\tregister u_int ptr;\n\tregister u_int len;\n \n \tif (length < 3) {\n \t\tND_PRINT((ndo, \" [bad length %u]\", length));\n\t\treturn;\n \t}\n \tif ((length + 1) & 3)\n \t\tND_PRINT((ndo, \" [bad length %u]\", length));\n \tptr = cp[2] - 1;\n \tif (ptr < 3 || ((ptr + 1) & 3) || ptr > length + 1)\n \t\tND_PRINT((ndo, \" [bad ptr %u]\", cp[2]));\n \n \tfor (len = 3; len < length; len += 4) {\n \t\tND_PRINT((ndo, \" %s\", ipaddr_string(ndo, &cp[len])));\n \t\tif (ptr > len)\n \t\t\tND_PRINT((ndo, \",\"));\n \t}\n }\n", "target": 1, "idx": 181042}
{"func": "LRESULT WebView::onGesture(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam, bool& handled)\n {\n     ASSERT(GetGestureInfoPtr());\n     ASSERT(CloseGestureInfoHandlePtr());\n \n    if (!GetGestureInfoPtr() || !CloseGestureInfoHandlePtr()) {\n         handled = false;\n         return 0;\n     }\n\n    HGESTUREINFO gestureHandle = reinterpret_cast<HGESTUREINFO>(lParam);\n    GESTUREINFO gi = {0};\n    gi.cbSize = sizeof(GESTUREINFO);\n\n    if (!GetGestureInfoPtr()(gestureHandle, &gi)) {\n        handled = false;\n        return 0;\n    }\n\n    switch (gi.dwID) {\n    case GID_BEGIN:\n        m_lastPanX = gi.ptsLocation.x;\n        m_lastPanY = gi.ptsLocation.y;\n        break;\n    case GID_END:\n        m_page->gestureDidEnd();\n        break;\n    case GID_PAN: {\n        int currentX = gi.ptsLocation.x;\n        int currentY = gi.ptsLocation.y;\n\n        int deltaX = m_lastPanX - currentX;\n        int deltaY = m_lastPanY - currentY;\n\n         m_lastPanX = currentX;\n         m_lastPanY = currentY;\n \n        m_page->gestureDidScroll(IntSize(deltaX, deltaY));\n \n \n         CloseGestureInfoHandlePtr()(gestureHandle);\n \n        handled = true;\n        return 0;\n    }\n    default:\n        break;\n    }\n\n    handled = false;\n    return 0;\n}\n", "target": 1, "idx": 184082}
{"func": "void ExtensionRegistry::TriggerOnUninstalled(const Extension* extension,\n                                             UninstallReason reason) {\n  CHECK(extension);\n  DCHECK(!GenerateInstalledExtensionsSet()->Contains(extension->id()));\n  FOR_EACH_OBSERVER(\n      ExtensionRegistryObserver,\n      observers_,\n      OnExtensionUninstalled(browser_context_, extension, reason));\n}\n", "target": 0, "idx": 134071}
{"func": "RenderFrameHostManager::DetermineSiteInstanceForURL(\n    const GURL& dest_url,\n    SiteInstance* source_instance,\n    SiteInstance* current_instance,\n    SiteInstance* dest_instance,\n    ui::PageTransition transition,\n    bool dest_is_restore,\n    bool dest_is_view_source_mode,\n    bool force_browsing_instance_swap,\n    bool was_server_redirect) {\n  SiteInstanceImpl* current_instance_impl =\n      static_cast<SiteInstanceImpl*>(current_instance);\n  NavigationControllerImpl& controller =\n      delegate_->GetControllerForRenderManager();\n  BrowserContext* browser_context = controller.GetBrowserContext();\n\n  if (dest_instance) {\n    if (force_browsing_instance_swap) {\n      CHECK(!dest_instance->IsRelatedSiteInstance(\n                render_frame_host_->GetSiteInstance()));\n    }\n    return SiteInstanceDescriptor(dest_instance);\n  }\n\n  if (force_browsing_instance_swap)\n    return SiteInstanceDescriptor(browser_context, dest_url,\n                                  SiteInstanceRelation::UNRELATED);\n\n  if (base::CommandLine::ForCurrentProcess()->HasSwitch(\n          switches::kProcessPerSite) &&\n      ui::PageTransitionCoreTypeIs(transition, ui::PAGE_TRANSITION_GENERATED)) {\n    return SiteInstanceDescriptor(current_instance_impl);\n  }\n\n  if (SiteIsolationPolicy::AreCrossProcessFramesPossible() &&\n      !frame_tree_node_->IsMainFrame()) {\n    SiteInstance* parent_site_instance =\n        frame_tree_node_->parent()->current_frame_host()->GetSiteInstance();\n    if (parent_site_instance->GetSiteURL().SchemeIs(kChromeUIScheme) &&\n        dest_url.SchemeIs(kChromeUIScheme)) {\n      return SiteInstanceDescriptor(parent_site_instance);\n    }\n  }\n\n  if (!current_instance_impl->HasSite()) {\n    bool use_process_per_site =\n        RenderProcessHost::ShouldUseProcessPerSite(browser_context, dest_url) &&\n        RenderProcessHostImpl::GetProcessHostForSite(browser_context, dest_url);\n    if (current_instance_impl->HasRelatedSiteInstance(dest_url) ||\n        use_process_per_site) {\n      return SiteInstanceDescriptor(browser_context, dest_url,\n                                    SiteInstanceRelation::RELATED);\n    }\n\n    if (current_instance_impl->HasWrongProcessForURL(dest_url))\n      return SiteInstanceDescriptor(browser_context, dest_url,\n                                    SiteInstanceRelation::RELATED);\n\n    if (dest_is_view_source_mode)\n      return SiteInstanceDescriptor(browser_context, dest_url,\n                                    SiteInstanceRelation::UNRELATED);\n\n    if (WebUIControllerFactoryRegistry::GetInstance()->UseWebUIForURL(\n            browser_context, dest_url)) {\n      return SiteInstanceDescriptor(browser_context, dest_url,\n                                    SiteInstanceRelation::UNRELATED);\n    }\n\n    if (dest_is_restore &&\n        GetContentClient()->browser()->ShouldAssignSiteForURL(dest_url)) {\n      current_instance_impl->SetSite(dest_url);\n    }\n\n    return SiteInstanceDescriptor(current_instance_impl);\n  }\n\n\n   NavigationEntry* current_entry = controller.GetLastCommittedEntry();\n  if (interstitial_page_) {\n     current_entry = controller.GetEntryAtOffset(-1);\n  }\n\n  if (current_entry &&\n      current_entry->IsViewSourceMode() != dest_is_view_source_mode &&\n      !IsRendererDebugURL(dest_url)) {\n    return SiteInstanceDescriptor(browser_context, dest_url,\n                                  SiteInstanceRelation::UNRELATED);\n  }\n\n  GURL about_blank(url::kAboutBlankURL);\n  GURL about_srcdoc(content::kAboutSrcDocURL);\n  bool dest_is_data_or_about = dest_url == about_srcdoc ||\n                               dest_url == about_blank ||\n                               dest_url.scheme() == url::kDataScheme;\n  if (source_instance && dest_is_data_or_about && !was_server_redirect)\n    return SiteInstanceDescriptor(source_instance);\n\n  if (IsCurrentlySameSite(render_frame_host_.get(), dest_url))\n    return SiteInstanceDescriptor(render_frame_host_->GetSiteInstance());\n\n  if (SiteIsolationPolicy::IsTopDocumentIsolationEnabled()) {\n    if (!frame_tree_node_->IsMainFrame()) {\n      RenderFrameHostImpl* main_frame =\n          frame_tree_node_->frame_tree()->root()->current_frame_host();\n      if (IsCurrentlySameSite(main_frame, dest_url))\n        return SiteInstanceDescriptor(main_frame->GetSiteInstance());\n    }\n\n    if (frame_tree_node_->opener()) {\n      RenderFrameHostImpl* opener_frame =\n          frame_tree_node_->opener()->current_frame_host();\n      if (IsCurrentlySameSite(opener_frame, dest_url))\n        return SiteInstanceDescriptor(opener_frame->GetSiteInstance());\n    }\n  }\n\n  if (!frame_tree_node_->IsMainFrame() &&\n      SiteIsolationPolicy::IsTopDocumentIsolationEnabled() &&\n      !SiteInstanceImpl::DoesSiteRequireDedicatedProcess(browser_context,\n                                                         dest_url)) {\n    if (GetContentClient()\n            ->browser()\n            ->ShouldFrameShareParentSiteInstanceDespiteTopDocumentIsolation(\n                dest_url, current_instance)) {\n      return SiteInstanceDescriptor(render_frame_host_->GetSiteInstance());\n    }\n\n    return SiteInstanceDescriptor(\n        browser_context, dest_url,\n        SiteInstanceRelation::RELATED_DEFAULT_SUBFRAME);\n  }\n\n  if (!frame_tree_node_->IsMainFrame()) {\n    RenderFrameHostImpl* parent =\n        frame_tree_node_->parent()->current_frame_host();\n    bool dest_url_requires_dedicated_process =\n        SiteInstanceImpl::DoesSiteRequireDedicatedProcess(browser_context,\n                                                          dest_url);\n    if (!parent->GetSiteInstance()->RequiresDedicatedProcess() &&\n        !dest_url_requires_dedicated_process) {\n      return SiteInstanceDescriptor(parent->GetSiteInstance());\n    }\n  }\n\n  return SiteInstanceDescriptor(browser_context, dest_url,\n                                SiteInstanceRelation::RELATED);\n}\n", "target": 1, "idx": 186288}
{"func": "static inline void register_rt_sched_group(struct task_group *tg, int cpu)\n{\n}\n", "target": 0, "idx": 22516}
{"func": "DEFINE_TRACE(SVGFEColorMatrixElement)\n{\n    visitor->trace(m_values);\n    visitor->trace(m_in1);\n    visitor->trace(m_type);\n    SVGFilterPrimitiveStandardAttributes::trace(visitor);\n}\n", "target": 0, "idx": 139052}
{"func": "void TabStrip::RemoveAndDeleteTab(Tab* tab) {\n  scoped_ptr<Tab> deleter(tab);\n  for (TabsClosingMap::iterator i(tabs_closing_map_.begin());\n       i != tabs_closing_map_.end(); ++i) {\n    std::vector<Tab*>::iterator j =\n        std::find(i->second.begin(), i->second.end(), tab);\n    if (j != i->second.end()) {\n      i->second.erase(j);\n      if (i->second.empty())\n        tabs_closing_map_.erase(i);\n      return;\n    }\n  }\n  NOTREACHED();\n}\n", "target": 0, "idx": 134405}
{"func": "request_find_from_trans_id(struct evdns_base *base, u16 trans_id) {\n\tstruct request *req = REQ_HEAD(base, trans_id);\n\tstruct request *const started_at = req;\n\n\tASSERT_LOCKED(base);\n\n\tif (req) {\n\t\tdo {\n\t\t\tif (req->trans_id == trans_id) return req;\n\t\t\treq = req->next;\n\t\t} while (req != started_at);\n\t}\n\n\treturn NULL;\n}\n", "target": 0, "idx": 70676}
{"func": "static sector_t udf_scan_anchors(struct super_block *sb, sector_t lastblock,\n\t\t\t\t struct kernel_lb_addr *fileset)\n{\n\tsector_t last[6];\n\tint i;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tint last_count = 0;\n\n\t/* First try user provided anchor */\n\tif (sbi->s_anchor) {\n\t\tif (udf_check_anchor_block(sb, sbi->s_anchor, fileset))\n\t\t\treturn lastblock;\n\t}\n\t/*\n\t * according to spec, anchor is in either:\n\t *     block 256\n\t *     lastblock-256\n\t *     lastblock\n\t *  however, if the disc isn't closed, it could be 512.\n\t */\n\tif (udf_check_anchor_block(sb, sbi->s_session + 256, fileset))\n\t\treturn lastblock;\n\t/*\n\t * The trouble is which block is the last one. Drives often misreport\n\t * this so we try various possibilities.\n\t */\n\tlast[last_count++] = lastblock;\n\tif (lastblock >= 1)\n\t\tlast[last_count++] = lastblock - 1;\n\tlast[last_count++] = lastblock + 1;\n\tif (lastblock >= 2)\n\t\tlast[last_count++] = lastblock - 2;\n\tif (lastblock >= 150)\n\t\tlast[last_count++] = lastblock - 150;\n\tif (lastblock >= 152)\n\t\tlast[last_count++] = lastblock - 152;\n\n\tfor (i = 0; i < last_count; i++) {\n\t\tif (last[i] >= sb->s_bdev->bd_inode->i_size >>\n\t\t\t\tsb->s_blocksize_bits)\n\t\t\tcontinue;\n\t\tif (udf_check_anchor_block(sb, last[i], fileset))\n\t\t\treturn last[i];\n\t\tif (last[i] < 256)\n\t\t\tcontinue;\n\t\tif (udf_check_anchor_block(sb, last[i] - 256, fileset))\n\t\t\treturn last[i];\n\t}\n\n\t/* Finally try block 512 in case media is open */\n\tif (udf_check_anchor_block(sb, sbi->s_session + 512, fileset))\n\t\treturn last[0];\n\treturn 0;\n}\n", "target": 0, "idx": 19546}
{"func": " void PaymentRequest::Retry(mojom::PaymentValidationErrorsPtr errors) {\n  if (!client_.is_bound() || !binding_.is_bound()) {\n    DLOG(ERROR) << \"Attempted Retry(), but binding(s) missing.\";\n     OnConnectionTerminated();\n     return;\n   }\n \n  if (!display_handle_) {\n    DLOG(ERROR) << \"Attempted Retry(), but display_handle_ is nullptr.\";\n     OnConnectionTerminated();\n     return;\n   }\n \n   std::string error;\n   if (!PaymentsValidators::IsValidPaymentValidationErrorsFormat(errors,\n                                                                 &error)) {\n    DLOG(ERROR) << error;\n     client_->OnError(mojom::PaymentErrorReason::USER_CANCEL);\n     OnConnectionTerminated();\n     return;\n  }\n\n  spec()->Retry(std::move(errors));\n   display_handle_->Retry();\n }\n", "target": 1, "idx": 187069}
{"func": "static int __revoke_inmem_pages(struct inode *inode,\n\t\t\t\tstruct list_head *head, bool drop, bool recover)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct inmem_pages *cur, *tmp;\n\tint err = 0;\n\n\tlist_for_each_entry_safe(cur, tmp, head, list) {\n\t\tstruct page *page = cur->page;\n\n\t\tif (drop)\n\t\t\ttrace_f2fs_commit_inmem_page(page, INMEM_DROP);\n\n\t\tlock_page(page);\n\n\t\tif (recover) {\n\t\t\tstruct dnode_of_data dn;\n\t\t\tstruct node_info ni;\n\n\t\t\ttrace_f2fs_commit_inmem_page(page, INMEM_REVOKE);\n\n\t\t\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\t\t\tif (get_dnode_of_data(&dn, page->index, LOOKUP_NODE)) {\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tget_node_info(sbi, dn.nid, &ni);\n\t\t\tf2fs_replace_block(sbi, &dn, dn.data_blkaddr,\n\t\t\t\t\tcur->old_addr, ni.version, true, true);\n\t\t\tf2fs_put_dnode(&dn);\n\t\t}\nnext:\n\t\t/* we don't need to invalidate this in the sccessful status */\n\t\tif (drop || recover)\n\t\t\tClearPageUptodate(page);\n\t\tset_page_private(page, 0);\n\t\tClearPagePrivate(page);\n\t\tf2fs_put_page(page, 1);\n\n\t\tlist_del(&cur->list);\n\t\tkmem_cache_free(inmem_entry_slab, cur);\n\t\tdec_page_count(F2FS_I_SB(inode), F2FS_INMEM_PAGES);\n\t}\n\treturn err;\n}\n", "target": 0, "idx": 85350}
{"func": "static inline int xfrm_replay_verify_len(struct xfrm_replay_state_esn *replay_esn,\n \t\t\t\t\t struct nlattr *rp)\n {\n \tstruct xfrm_replay_state_esn *up;\n \n \tif (!replay_esn || !rp)\n \t\treturn 0;\n \n \tup = nla_data(rp);\n \n\tif (xfrm_replay_state_esn_len(replay_esn) !=\n\t\t\txfrm_replay_state_esn_len(up))\n \t\treturn -EINVAL;\n \n \treturn 0;\n}\n", "target": 1, "idx": 179364}
{"func": "static int tomoyo_mount_acl(struct tomoyo_request_info *r, char *dev_name,\n\t\t\t    struct path *dir, char *type, unsigned long flags)\n{\n\tstruct path path;\n\tstruct file_system_type *fstype = NULL;\n\tconst char *requested_type = NULL;\n\tconst char *requested_dir_name = NULL;\n\tconst char *requested_dev_name = NULL;\n\tstruct tomoyo_path_info rtype;\n\tstruct tomoyo_path_info rdev;\n\tstruct tomoyo_path_info rdir;\n\tint need_dev = 0;\n\tint error = -ENOMEM;\n\n\t/* Get fstype. */\n\trequested_type = tomoyo_encode(type);\n\tif (!requested_type)\n\t\tgoto out;\n\trtype.name = requested_type;\n\ttomoyo_fill_path_info(&rtype);\n\n\t/* Get mount point. */\n\trequested_dir_name = tomoyo_realpath_from_path(dir);\n\tif (!requested_dir_name) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\trdir.name = requested_dir_name;\n\ttomoyo_fill_path_info(&rdir);\n\n\t/* Compare fs name. */\n\tif (!strcmp(type, TOMOYO_MOUNT_REMOUNT_KEYWORD)) {\n\t\t/* dev_name is ignored. */\n\t} else if (!strcmp(type, TOMOYO_MOUNT_MAKE_UNBINDABLE_KEYWORD) ||\n\t\t   !strcmp(type, TOMOYO_MOUNT_MAKE_PRIVATE_KEYWORD) ||\n\t\t   !strcmp(type, TOMOYO_MOUNT_MAKE_SLAVE_KEYWORD) ||\n\t\t   !strcmp(type, TOMOYO_MOUNT_MAKE_SHARED_KEYWORD)) {\n\t\t/* dev_name is ignored. */\n\t} else if (!strcmp(type, TOMOYO_MOUNT_BIND_KEYWORD) ||\n\t\t   !strcmp(type, TOMOYO_MOUNT_MOVE_KEYWORD)) {\n\t\tneed_dev = -1; /* dev_name is a directory */\n\t} else {\n\t\tfstype = get_fs_type(type);\n\t\tif (!fstype) {\n\t\t\terror = -ENODEV;\n\t\t\tgoto out;\n\t\t}\n\t\tif (fstype->fs_flags & FS_REQUIRES_DEV)\n\t\t\t/* dev_name is a block device file. */\n\t\t\tneed_dev = 1;\n \t}\n \tif (need_dev) {\n \t\t/* Get mount point or device file. */\n\t\tif (kern_path(dev_name, LOOKUP_FOLLOW, &path)) {\n \t\t\terror = -ENOENT;\n \t\t\tgoto out;\n \t\t}\n\t\trequested_dev_name = tomoyo_realpath_from_path(&path);\n\t\tpath_put(&path);\n\t\tif (!requested_dev_name) {\n\t\t\terror = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t/* Map dev_name to \"<NULL>\" if no dev_name given. */\n\t\tif (!dev_name)\n\t\t\tdev_name = \"<NULL>\";\n\t\trequested_dev_name = tomoyo_encode(dev_name);\n\t\tif (!requested_dev_name) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\trdev.name = requested_dev_name;\n\ttomoyo_fill_path_info(&rdev);\n\tr->param_type = TOMOYO_TYPE_MOUNT_ACL;\n\tr->param.mount.need_dev = need_dev;\n\tr->param.mount.dev = &rdev;\n\tr->param.mount.dir = &rdir;\n\tr->param.mount.type = &rtype;\n\tr->param.mount.flags = flags;\n\tdo {\n\t\ttomoyo_check_acl(r, tomoyo_check_mount_acl);\n\t\terror = tomoyo_audit_mount_log(r);\n\t} while (error == TOMOYO_RETRY_REQUEST);\n out:\n\tkfree(requested_dev_name);\n\tkfree(requested_dir_name);\n\tif (fstype)\n\t\tput_filesystem(fstype);\n\tkfree(requested_type);\n\treturn error;\n}\n", "target": 1, "idx": 179028}
{"func": "LifecycleUnit::SortKey TabLifecycleUnitSource::TabLifecycleUnit::GetSortKey()\n    const {\n  if (base::FeatureList::IsEnabled(features::kTabRanker)) {\n    base::Optional<float> reactivation_score =\n        resource_coordinator::TabActivityWatcher::GetInstance()\n            ->CalculateReactivationScore(GetWebContents());\n    if (reactivation_score.has_value())\n      return SortKey(reactivation_score.value(), last_focused_time_);\n    return SortKey(SortKey::kMaxScore, last_focused_time_);\n  }\n\n  return SortKey(last_focused_time_);\n}\n", "target": 0, "idx": 144787}
{"func": "void PrintJobWorker::GetSettingsWithUI(\n    int document_page_count,\n    bool has_selection,\n     bool is_scripted) {\n   DCHECK_CURRENTLY_ON(BrowserThread::UI);\n \n #if defined(OS_ANDROID)\n   if (is_scripted) {\n    PrintingContextDelegate* printing_context_delegate =\n        static_cast<PrintingContextDelegate*>(printing_context_delegate_.get());\n    content::WebContents* web_contents =\n        printing_context_delegate->GetWebContents();\n     TabAndroid* tab =\n         web_contents ? TabAndroid::FromWebContents(web_contents) : nullptr;\n \n    if (tab)\n      tab->SetPendingPrint();\n   }\n #endif\n \n   printing_context_->AskUserForSettings(\n       document_page_count, has_selection, is_scripted,\n      base::Bind(&PostOnOwnerThread, make_scoped_refptr(owner_),\n                 base::Bind(&PrintJobWorker::GetSettingsDone,\n                            weak_factory_.GetWeakPtr())));\n}\n", "target": 1, "idx": 186281}
{"func": "void BluetoothDeviceChromeOS::DisplayPinCode(\n    const dbus::ObjectPath& device_path,\n    const std::string& pincode) {\n  DCHECK(agent_.get());\n  DCHECK(device_path == object_path_);\n  VLOG(1) << object_path_.value() << \": DisplayPinCode: \" << pincode;\n  UMA_HISTOGRAM_ENUMERATION(\"Bluetooth.PairingMethod\",\n                            UMA_PAIRING_METHOD_DISPLAY_PINCODE,\n                            UMA_PAIRING_METHOD_COUNT);\n  DCHECK(pairing_delegate_);\n  pairing_delegate_->DisplayPinCode(this, pincode);\n  pairing_delegate_used_ = true;\n}\n", "target": 1, "idx": 184915}
{"func": "AcpiNsBuildInternalName (\n    ACPI_NAMESTRING_INFO    *Info)\n{\n    UINT32                  NumSegments = Info->NumSegments;\n    char                    *InternalName = Info->InternalName;\n    const char              *ExternalName = Info->NextExternalChar;\n    char                    *Result = NULL;\n    UINT32                  i;\n\n\n    ACPI_FUNCTION_TRACE (NsBuildInternalName);\n\n\n    /* Setup the correct prefixes, counts, and pointers */\n\n    if (Info->FullyQualified)\n    {\n        InternalName[0] = AML_ROOT_PREFIX;\n\n        if (NumSegments <= 1)\n        {\n            Result = &InternalName[1];\n        }\n        else if (NumSegments == 2)\n        {\n            InternalName[1] = AML_DUAL_NAME_PREFIX;\n            Result = &InternalName[2];\n        }\n        else\n        {\n            InternalName[1] = AML_MULTI_NAME_PREFIX_OP;\n            InternalName[2] = (char) NumSegments;\n            Result = &InternalName[3];\n        }\n    }\n    else\n    {\n        /*\n         * Not fully qualified.\n         * Handle Carats first, then append the name segments\n         */\n        i = 0;\n        if (Info->NumCarats)\n        {\n            for (i = 0; i < Info->NumCarats; i++)\n            {\n                InternalName[i] = AML_PARENT_PREFIX;\n            }\n        }\n\n        if (NumSegments <= 1)\n        {\n            Result = &InternalName[i];\n        }\n        else if (NumSegments == 2)\n        {\n            InternalName[i] = AML_DUAL_NAME_PREFIX;\n            Result = &InternalName[(ACPI_SIZE) i+1];\n        }\n        else\n        {\n            InternalName[i] = AML_MULTI_NAME_PREFIX_OP;\n            InternalName[(ACPI_SIZE) i+1] = (char) NumSegments;\n            Result = &InternalName[(ACPI_SIZE) i+2];\n        }\n    }\n\n    /* Build the name (minus path separators) */\n\n    for (; NumSegments; NumSegments--)\n    {\n        for (i = 0; i < ACPI_NAME_SIZE; i++)\n        {\n            if (ACPI_IS_PATH_SEPARATOR (*ExternalName) ||\n               (*ExternalName == 0))\n            {\n                /* Pad the segment with underscore(s) if segment is short */\n\n                Result[i] = '_';\n            }\n            else\n            {\n                /* Convert the character to uppercase and save it */\n\n                Result[i] = (char) toupper ((int) *ExternalName);\n                ExternalName++;\n            }\n        }\n\n        /* Now we must have a path separator, or the pathname is bad */\n\n        if (!ACPI_IS_PATH_SEPARATOR (*ExternalName) &&\n            (*ExternalName != 0))\n        {\n            return_ACPI_STATUS (AE_BAD_PATHNAME);\n        }\n\n        /* Move on the next segment */\n\n        ExternalName++;\n        Result += ACPI_NAME_SIZE;\n    }\n\n    /* Terminate the string */\n\n    *Result = 0;\n\n    if (Info->FullyQualified)\n    {\n        ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, \"Returning [%p] (abs) \\\"\\\\%s\\\"\\n\",\n            InternalName, InternalName));\n    }\n    else\n    {\n        ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, \"Returning [%p] (rel) \\\"%s\\\"\\n\",\n            InternalName, InternalName));\n    }\n\n    return_ACPI_STATUS (AE_OK);\n}\n", "target": 0, "idx": 95287}
{"func": "int propagate_mnt(struct mount *dest_mnt, struct mountpoint *dest_mp,\n\t\t    struct mount *source_mnt, struct hlist_head *tree_list)\n{\n\tstruct mount *m, *n;\n\tint ret = 0;\n\n\t/*\n\t * we don't want to bother passing tons of arguments to\n\t * propagate_one(); everything is serialized by namespace_sem,\n\t * so globals will do just fine.\n \t */\n \tuser_ns = current->nsproxy->mnt_ns->user_ns;\n \tlast_dest = dest_mnt;\n \tlast_source = source_mnt;\n \tmp = dest_mp;\n \tlist = tree_list;\n\tdest_master = dest_mnt->mnt_master;\n\n\t/* all peers of dest_mnt, except dest_mnt itself */\n\tfor (n = next_peer(dest_mnt); n != dest_mnt; n = next_peer(n)) {\n\t\tret = propagate_one(n);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t/* all slave groups */\n\tfor (m = next_group(dest_mnt, dest_mnt); m;\n\t\t\tm = next_group(m, dest_mnt)) {\n\t\t/* everything in that slave group */\n\t\tn = m;\n\t\tdo {\n\t\t\tret = propagate_one(n);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tn = next_peer(n);\n\t\t} while (n != m);\n\t}\nout:\n\tread_seqlock_excl(&mount_lock);\n\thlist_for_each_entry(n, tree_list, mnt_hash) {\n\t\tm = n->mnt_parent;\n\t\tif (m->mnt_master != dest_mnt->mnt_master)\n\t\t\tCLEAR_MNT_MARK(m->mnt_master);\n\t}\n\tread_sequnlock_excl(&mount_lock);\n\treturn ret;\n}\n", "target": 1, "idx": 180405}
{"func": "void evm_inode_post_removexattr(struct dentry *dentry, const char *xattr_name)\n{\n\tif (!evm_initialized || !evm_protected_xattr(xattr_name))\n\t\treturn;\n\n\tevm_reset_status(dentry->d_inode);\n\n\tevm_update_evmxattr(dentry, xattr_name, NULL, 0);\n}\n", "target": 0, "idx": 55365}
{"func": "free_netinfo_config(\n\tstruct netinfo_config_state *config\n\t)\n{\n\tni_free(config->domain);\n\tfree(config);\n}\n", "target": 0, "idx": 74199}
{"func": "static void stringArrayMethodMethod(const v8::FunctionCallbackInfo<v8::Value>& info)\n{\n    TestObjectPython* imp = V8TestObjectPython::toNative(info.Holder());\n    v8SetReturnValue(info, v8Array(imp->stringArrayMethod(), info.GetIsolate()));\n}\n", "target": 0, "idx": 131755}
{"func": "GF_Err fdsa_AddBox(GF_Box *s, GF_Box *a)\n{\n\tGF_HintSample *ptr = (GF_HintSample *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_FDPA:\n\t\tgf_list_add(ptr->packetTable, a);\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_EXTR:\n\t\tif (ptr->extra_data) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\tptr->extra_data = (GF_ExtraDataBox*)a;\n\t\tbreak;\n\tdefault:\n\t\treturn gf_isom_box_add_default(s, a);\n\t}\n\treturn GF_OK;\n}\n", "target": 0, "idx": 80108}
{"func": "MagickExport MagickBooleanType SetImageProperty(Image *image,\n  const char *property,const char *value,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  MagickStatusType\n    flags;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->properties == (void *) NULL)\n    image->properties=NewSplayTree(CompareSplayTreeString,\n      RelinquishMagickMemory,RelinquishMagickMemory);  /* create splay-tree */\n  if (value == (const char *) NULL)\n    return(DeleteImageProperty(image,property));  /* delete if NULL */\n  status=MagickTrue;\n  if (strlen(property) <= 1)\n     {\n       /*\n         Do not 'set' single letter properties - read only shorthand.\n       */\n       (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n         \"SetReadOnlyProperty\",\"`%s'\",property);\n       return(MagickFalse);\n    }\n\n  /* FUTURE: binary chars or quotes in key should produce a error */\n  /* Set attributes with known names or special prefixes\n     return result is found, or break to set a free form properity\n  */\n  switch (*property)\n  {\n#if 0  /* Percent escape's sets values with this prefix: for later use\n          Throwing an exception causes this setting to fail */\n    case '8':\n    {\n      if (LocaleNCompare(\"8bim:\",property,5) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break;\n    }\n#endif\n    case 'B':\n    case 'b':\n    {\n      if (LocaleCompare(\"background\",property) == 0)\n        {\n          (void) QueryColorCompliance(value,AllCompliance,\n               &image->background_color,exception);\n          /* check for FUTURE: value exception?? */\n          /* also add user input to splay tree */\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'C':\n    case 'c':\n    {\n      if (LocaleCompare(\"channels\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      if (LocaleCompare(\"colorspace\",property) == 0)\n        {\n          ssize_t\n            colorspace;\n\n          colorspace=ParseCommandOption(MagickColorspaceOptions,MagickFalse,\n            value);\n          if (colorspace < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          return(SetImageColorspace(image,(ColorspaceType) colorspace,exception));\n        }\n      if (LocaleCompare(\"compose\",property) == 0)\n        {\n          ssize_t\n            compose;\n\n          compose=ParseCommandOption(MagickComposeOptions,MagickFalse,value);\n          if (compose < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->compose=(CompositeOperator) compose;\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"compress\",property) == 0)\n        {\n          ssize_t\n            compression;\n\n          compression=ParseCommandOption(MagickCompressOptions,MagickFalse,\n            value);\n          if (compression < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->compression=(CompressionType) compression;\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'D':\n    case 'd':\n    {\n      if (LocaleCompare(\"delay\",property) == 0)\n        {\n          GeometryInfo\n            geometry_info;\n\n          flags=ParseGeometry(value,&geometry_info);\n          if ((flags & GreaterValue) != 0)\n            {\n              if (image->delay > (size_t) floor(geometry_info.rho+0.5))\n                image->delay=(size_t) floor(geometry_info.rho+0.5);\n            }\n          else\n            if ((flags & LessValue) != 0)\n              {\n                if (image->delay < (size_t) floor(geometry_info.rho+0.5))\n                  image->delay=(ssize_t)\n                    floor(geometry_info.sigma+0.5);\n              }\n            else\n              image->delay=(size_t) floor(geometry_info.rho+0.5);\n          if ((flags & SigmaValue) != 0)\n            image->ticks_per_second=(ssize_t) floor(geometry_info.sigma+0.5);\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"delay_units\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      if (LocaleCompare(\"density\",property) == 0)\n        {\n          GeometryInfo\n            geometry_info;\n\n          flags=ParseGeometry(value,&geometry_info);\n          image->resolution.x=geometry_info.rho;\n          image->resolution.y=geometry_info.sigma;\n          if ((flags & SigmaValue) == 0)\n            image->resolution.y=image->resolution.x;\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"depth\",property) == 0)\n        {\n          image->depth=StringToUnsignedLong(value);\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"dispose\",property) == 0)\n        {\n          ssize_t\n            dispose;\n\n          dispose=ParseCommandOption(MagickDisposeOptions,MagickFalse,value);\n          if (dispose < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->dispose=(DisposeType) dispose;\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n#if 0  /* Percent escape's sets values with this prefix: for later use\n          Throwing an exception causes this setting to fail */\n    case 'E':\n    case 'e':\n    {\n      if (LocaleNCompare(\"exif:\",property,5) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'F':\n    case 'f':\n    {\n      if (LocaleNCompare(\"fx:\",property,3) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    }\n#endif\n    case 'G':\n    case 'g':\n    {\n      if (LocaleCompare(\"gamma\",property) == 0)\n        {\n          image->gamma=StringToDouble(value,(char **) NULL);\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"gravity\",property) == 0)\n        {\n          ssize_t\n            gravity;\n\n          gravity=ParseCommandOption(MagickGravityOptions,MagickFalse,value);\n          if (gravity < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->gravity=(GravityType) gravity;\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'H':\n    case 'h':\n    {\n      if (LocaleCompare(\"height\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'I':\n    case 'i':\n    {\n      if (LocaleCompare(\"intensity\",property) == 0)\n        {\n          ssize_t\n            intensity;\n\n          intensity=ParseCommandOption(MagickIntentOptions,MagickFalse,value);\n          if (intensity < 0)\n            return(MagickFalse);\n          image->intensity=(PixelIntensityMethod) intensity;\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"intent\",property) == 0)\n        {\n          ssize_t\n            rendering_intent;\n\n          rendering_intent=ParseCommandOption(MagickIntentOptions,MagickFalse,\n            value);\n          if (rendering_intent < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->rendering_intent=(RenderingIntent) rendering_intent;\n          return(MagickTrue);\n        }\n      if (LocaleCompare(\"interpolate\",property) == 0)\n        {\n          ssize_t\n            interpolate;\n\n          interpolate=ParseCommandOption(MagickInterpolateOptions,MagickFalse,\n            value);\n          if (interpolate < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->interpolate=(PixelInterpolateMethod) interpolate;\n          return(MagickTrue);\n        }\n#if 0  /* Percent escape's sets values with this prefix: for later use\n          Throwing an exception causes this setting to fail */\n      if (LocaleNCompare(\"iptc:\",property,5) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n#endif\n      break; /* not an attribute, add as a property */\n    }\n    case 'K':\n    case 'k':\n      if (LocaleCompare(\"kurtosis\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    case 'L':\n    case 'l':\n    {\n      if (LocaleCompare(\"loop\",property) == 0)\n        {\n          image->iterations=StringToUnsignedLong(value);\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'M':\n    case 'm':\n      if ((LocaleCompare(\"magick\",property) == 0) ||\n          (LocaleCompare(\"max\",property) == 0) ||\n          (LocaleCompare(\"mean\",property) == 0) ||\n          (LocaleCompare(\"min\",property) == 0) ||\n          (LocaleCompare(\"min\",property) == 0))\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n             \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    case 'O':\n    case 'o':\n      if (LocaleCompare(\"opaque\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    case 'P':\n    case 'p':\n    {\n      if (LocaleCompare(\"page\",property) == 0)\n        {\n          char\n            *geometry;\n\n          geometry=GetPageGeometry(value);\n          flags=ParseAbsoluteGeometry(geometry,&image->page);\n          geometry=DestroyString(geometry);\n          return(MagickTrue);\n        }\n#if 0  /* Percent escape's sets values with this prefix: for later use\n          Throwing an exception causes this setting to fail */\n      if (LocaleNCompare(\"pixel:\",property,6) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n#endif\n      if (LocaleCompare(\"profile\",property) == 0)\n        {\n          ImageInfo\n            *image_info;\n\n          StringInfo\n            *profile;\n\n          image_info=AcquireImageInfo();\n          (void) CopyMagickString(image_info->filename,value,MagickPathExtent);\n          (void) SetImageInfo(image_info,1,exception);\n          profile=FileToStringInfo(image_info->filename,~0UL,exception);\n          if (profile != (StringInfo *) NULL)\n            status=SetImageProfile(image,image_info->magick,profile,exception);\n          image_info=DestroyImageInfo(image_info);\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'R':\n    case 'r':\n    {\n      if (LocaleCompare(\"rendering-intent\",property) == 0)\n        {\n          ssize_t\n            rendering_intent;\n\n          rendering_intent=ParseCommandOption(MagickIntentOptions,MagickFalse,\n            value);\n          if (rendering_intent < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->rendering_intent=(RenderingIntent) rendering_intent;\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'S':\n    case 's':\n      if ((LocaleCompare(\"size\",property) == 0) ||\n          (LocaleCompare(\"skewness\",property) == 0) ||\n          (LocaleCompare(\"scenes\",property) == 0) ||\n          (LocaleCompare(\"standard-deviation\",property) == 0))\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    case 'T':\n    case 't':\n    {\n      if (LocaleCompare(\"tile-offset\",property) == 0)\n        {\n          char\n            *geometry;\n\n          geometry=GetPageGeometry(value);\n          flags=ParseAbsoluteGeometry(geometry,&image->tile_offset);\n          geometry=DestroyString(geometry);\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'U':\n    case 'u':\n    {\n      if (LocaleCompare(\"units\",property) == 0)\n        {\n          ssize_t\n            units;\n\n          units=ParseCommandOption(MagickResolutionOptions,MagickFalse,value);\n          if (units < 0)\n            return(MagickFalse); /* FUTURE: value exception?? */\n          image->units=(ResolutionType) units;\n          return(MagickTrue);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'V':\n    case 'v':\n    {\n      if (LocaleCompare(\"version\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    }\n    case 'W':\n    case 'w':\n    {\n      if (LocaleCompare(\"width\",property) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    }\n#if 0  /* Percent escape's sets values with this prefix: for later use\n          Throwing an exception causes this setting to fail */\n    case 'X':\n    case 'x':\n    {\n      if (LocaleNCompare(\"xmp:\",property,4) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"SetReadOnlyProperty\",\"`%s'\",property);\n          return(MagickFalse);\n        }\n      break; /* not an attribute, add as a property */\n    }\n#endif\n  }\n  /* Default: not an attribute, add as a property */\n  status=AddValueToSplayTree((SplayTreeInfo *) image->properties,\n    ConstantString(property),ConstantString(value));\n  /* FUTURE: error if status is bad? */\n  return(status);\n}\n", "target": 1, "idx": 181850}
{"func": "ConstructType JSTestSerializedScriptValueInterfaceConstructor::getConstructData(JSCell*, ConstructData& constructData)\n{\n    constructData.native.function = constructJSTestSerializedScriptValueInterface;\n    return ConstructTypeHost;\n}\n", "target": 0, "idx": 106260}
{"func": "static struct ib_ucontext *hns_roce_alloc_ucontext(struct ib_device *ib_dev,\n\t\t\t\t\t\t   struct ib_udata *udata)\n {\n \tint ret = 0;\n \tstruct hns_roce_ucontext *context;\n\tstruct hns_roce_ib_alloc_ucontext_resp resp;\n \tstruct hns_roce_dev *hr_dev = to_hr_dev(ib_dev);\n \n \tresp.qp_tab_size = hr_dev->caps.num_qps;\n\n\tcontext = kmalloc(sizeof(*context), GFP_KERNEL);\n\tif (!context)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = hns_roce_uar_alloc(hr_dev, &context->uar);\n\tif (ret)\n\t\tgoto error_fail_uar_alloc;\n\n\tif (hr_dev->caps.flags & HNS_ROCE_CAP_FLAG_RECORD_DB) {\n\t\tINIT_LIST_HEAD(&context->page_list);\n\t\tmutex_init(&context->page_mutex);\n\t}\n\n\tret = ib_copy_to_udata(udata, &resp, sizeof(resp));\n\tif (ret)\n\t\tgoto error_fail_copy_to_udata;\n\n\treturn &context->ibucontext;\n\nerror_fail_copy_to_udata:\n\thns_roce_uar_free(hr_dev, &context->uar);\n\nerror_fail_uar_alloc:\n\tkfree(context);\n\n\treturn ERR_PTR(ret);\n}\n", "target": 1, "idx": 182676}
{"func": "static UINT drdynvc_process_close_request(drdynvcPlugin* drdynvc, int Sp,\n        int cbChId, wStream* s)\n{\n\tint value;\n \tUINT error;\n \tUINT32 ChannelId;\n \twStream* data_out;\n \tChannelId = drdynvc_read_variable_uint(s, cbChId);\n \tWLog_Print(drdynvc->log, WLOG_DEBUG, \"process_close_request: Sp=%d cbChId=%d, ChannelId=%\"PRIu32\"\",\n \t           Sp,\n\t           cbChId, ChannelId);\n\n\tif ((error = dvcman_close_channel(drdynvc->channel_mgr, ChannelId)))\n\t{\n\t\tWLog_Print(drdynvc->log, WLOG_ERROR, \"dvcman_close_channel failed with error %\"PRIu32\"!\", error);\n\t\treturn error;\n\t}\n\n\tdata_out = Stream_New(NULL, 4);\n\n\tif (!data_out)\n\t{\n\t\tWLog_Print(drdynvc->log, WLOG_ERROR, \"Stream_New failed!\");\n\t\treturn CHANNEL_RC_NO_MEMORY;\n\t}\n\n\tvalue = (CLOSE_REQUEST_PDU << 4) | (cbChId & 0x03);\n\tStream_Write_UINT8(data_out, value);\n\tdrdynvc_write_variable_uint(data_out, ChannelId);\n\terror = drdynvc_send(drdynvc, data_out);\n\n\tif (error)\n\t\tWLog_Print(drdynvc->log, WLOG_ERROR, \"VirtualChannelWriteEx failed with %s [%08\"PRIX32\"]\",\n\t\t           WTSErrorToString(error), error);\n\n\treturn error;\n}\n", "target": 1, "idx": 182107}
{"func": "static int get_tp_trap(struct pt_regs *regs, unsigned int instr)\n{\n \tint reg = (instr >> 12) & 15;\n \tif (reg == 15)\n \t\treturn 1;\n\tregs->uregs[reg] = current_thread_info()->tp_value;\n \tregs->ARM_pc += 4;\n \treturn 0;\n }\n", "target": 1, "idx": 180754}
{"func": "ikev1_t_print(netdissect_options *ndo, u_char tpay _U_,\n\t      const struct isakmp_gen *ext, u_int item_len,\n\t      const u_char *ep, uint32_t phase _U_, uint32_t doi _U_,\n\t      uint32_t proto, int depth _U_)\n{\n\tconst struct ikev1_pl_t *p;\n\tstruct ikev1_pl_t t;\n\tconst u_char *cp;\n\tconst char *idstr;\n\tconst struct attrmap *map;\n\tsize_t nmap;\n\tconst u_char *ep2;\n\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_T)));\n\n\tp = (const struct ikev1_pl_t *)ext;\n\tND_TCHECK(*p);\n\tUNALIGNED_MEMCPY(&t, ext, sizeof(t));\n\n\tswitch (proto) {\n\tcase 1:\n\t\tidstr = STR_OR_ID(t.t_id, ikev1_p_map);\n\t\tmap = oakley_t_map;\n\t\tnmap = sizeof(oakley_t_map)/sizeof(oakley_t_map[0]);\n\t\tbreak;\n\tcase 2:\n\t\tidstr = STR_OR_ID(t.t_id, ah_p_map);\n\t\tmap = ipsec_t_map;\n\t\tnmap = sizeof(ipsec_t_map)/sizeof(ipsec_t_map[0]);\n\t\tbreak;\n\tcase 3:\n\t\tidstr = STR_OR_ID(t.t_id, esp_p_map);\n\t\tmap = ipsec_t_map;\n\t\tnmap = sizeof(ipsec_t_map)/sizeof(ipsec_t_map[0]);\n\t\tbreak;\n\tcase 4:\n\t\tidstr = STR_OR_ID(t.t_id, ipcomp_p_map);\n\t\tmap = ipsec_t_map;\n\t\tnmap = sizeof(ipsec_t_map)/sizeof(ipsec_t_map[0]);\n\t\tbreak;\n\tdefault:\n\t\tidstr = NULL;\n\t\tmap = NULL;\n\t\tnmap = 0;\n\t\tbreak;\n\t}\n\n\tif (idstr)\n\t\tND_PRINT((ndo,\" #%d id=%s \", t.t_no, idstr));\n\telse\n\t\tND_PRINT((ndo,\" #%d id=%d \", t.t_no, t.t_id));\n \tcp = (const u_char *)(p + 1);\n \tep2 = (const u_char *)p + item_len;\n \twhile (cp < ep && cp < ep2) {\n\t\tif (map && nmap) {\n\t\t\tcp = ikev1_attrmap_print(ndo, cp, (ep < ep2) ? ep : ep2,\n\t\t\t\tmap, nmap);\n\t\t} else\n\t\t\tcp = ikev1_attr_print(ndo, cp, (ep < ep2) ? ep : ep2);\n \t}\n \tif (ep < ep2)\n \t\tND_PRINT((ndo,\"...\"));\n\treturn cp;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_T)));\n\treturn NULL;\n}\n", "target": 1, "idx": 181014}
{"func": "bool AXNodeObject::isRequired() const {\n  Node* n = this->getNode();\n  if (n && (n->isElementNode() && toElement(n)->isFormControlElement()) &&\n       hasAttribute(requiredAttr))\n     return toHTMLFormControlElement(n)->isRequired();\n \n  if (equalIgnoringCase(getAttribute(aria_requiredAttr), \"true\"))\n     return true;\n \n   return false;\n}\n", "target": 1, "idx": 185797}
{"func": "void MetricsWebContentsObserver::BroadcastEventToObservers(\n    const void* const event_key) {\n  if (committed_load_)\n    committed_load_->BroadcastEventToObservers(event_key);\n}\n", "target": 0, "idx": 152819}
{"func": "request_reissue(struct request *req) {\n\tconst struct nameserver *const last_ns = req->ns;\n\tASSERT_LOCKED(req->base);\n\tASSERT_VALID_REQUEST(req);\n\t/* the last nameserver should have been marked as failing */\n\t/* by the caller of this function, therefore pick will try */\n\t/* not to return it */\n\trequest_swap_ns(req, nameserver_pick(req->base));\n\tif (req->ns == last_ns) {\n\t\t/* ... but pick did return it */\n\t\t/* not a lot of point in trying again with the */\n\t\t/* same server */\n\t\treturn 1;\n\t}\n\n\treq->reissue_count++;\n\treq->tx_count = 0;\n\treq->transmit_me = 1;\n\n\treturn 0;\n}\n", "target": 0, "idx": 70679}
{"func": "BGD_DECLARE(void) gdImageWebp (gdImagePtr im, FILE * outFile)\n{\n\tgdIOCtx *out = gdNewFileCtx(outFile);\n \tif (out == NULL) {\n \t\treturn;\n \t}\n\tgdImageWebpCtx(im, out, -1);\n \tout->gd_free(out);\n }\n", "target": 1, "idx": 181988}
{"func": "static v8::Handle<v8::Value> convert5Callback(const v8::Arguments& args)\n {\n     INC_STATS(\"DOM.TestObj.convert5\");\n     if (args.Length() < 1)\n        return V8Proxy::throwNotEnoughArgumentsError();\n     TestObj* imp = V8TestObj::toNative(args.Holder());\n     EXCEPTION_BLOCK(e*, , V8e::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8e::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);\n     imp->convert5();\n    return v8::Handle<v8::Value>();\n}\n", "target": 1, "idx": 184773}
{"func": "static struct extent_map *prev_extent_map(struct extent_map *em)\n{\n\tstruct rb_node *prev;\n\n\tprev = rb_prev(&em->rb_node);\n\tif (!prev)\n\t\treturn NULL;\n\treturn container_of(prev, struct extent_map, rb_node);\n}\n", "target": 0, "idx": 41720}
{"func": "mrb_io_initialize_copy(mrb_state *mrb, mrb_value copy)\n{\n  mrb_value orig;\n  mrb_value buf;\n  struct mrb_io *fptr_copy;\n  struct mrb_io *fptr_orig;\n   mrb_bool failed = TRUE;\n \n   mrb_get_args(mrb, \"o\", &orig);\n   fptr_copy = (struct mrb_io *)DATA_PTR(copy);\n   if (fptr_copy != NULL) {\n     fptr_finalize(mrb, fptr_copy, FALSE);\n     mrb_free(mrb, fptr_copy);\n   }\n   fptr_copy = (struct mrb_io *)mrb_io_alloc(mrb);\n  fptr_orig = io_get_open_fptr(mrb, orig);\n \n   DATA_TYPE(copy) = &mrb_io_type;\n   DATA_PTR(copy) = fptr_copy;\n\n  buf = mrb_iv_get(mrb, orig, mrb_intern_cstr(mrb, \"@buf\"));\n  mrb_iv_set(mrb, copy, mrb_intern_cstr(mrb, \"@buf\"), buf);\n\n  fptr_copy->fd = mrb_dup(mrb, fptr_orig->fd, &failed);\n  if (failed) {\n    mrb_sys_fail(mrb, 0);\n  }\n  mrb_fd_cloexec(mrb, fptr_copy->fd);\n\n  if (fptr_orig->fd2 != -1) {\n    fptr_copy->fd2 = mrb_dup(mrb, fptr_orig->fd2, &failed);\n    if (failed) {\n      close(fptr_copy->fd);\n      mrb_sys_fail(mrb, 0);\n    }\n    mrb_fd_cloexec(mrb, fptr_copy->fd2);\n  }\n\n  fptr_copy->pid = fptr_orig->pid;\n  fptr_copy->readable = fptr_orig->readable;\n  fptr_copy->writable = fptr_orig->writable;\n  fptr_copy->sync = fptr_orig->sync;\n  fptr_copy->is_socket = fptr_orig->is_socket;\n\n  return copy;\n}\n", "target": 1, "idx": 182427}
{"func": " void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(\n     JNIEnv* env,\n    mojo::ScopedSharedBufferMapping mapping,\n     const CreateSensorCallback& callback) {\n   if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(\n           env, j_object_,\n          static_cast<jint>(\n              mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION)))) {\n    auto sensor_fusion_algorithm =\n        std::make_unique<OrientationEulerAnglesFusionAlgorithmUsingQuaternion>(\n            true /* absolute */);\n \n    PlatformSensorFusion::Create(std::move(mapping), this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   } else {\n     auto sensor_fusion_algorithm = std::make_unique<\n         AbsoluteOrientationEulerAnglesFusionAlgorithmUsingAccelerometerAndMagnetometer>();\n \n    PlatformSensorFusion::Create(std::move(mapping), this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n", "target": 1, "idx": 186811}
{"func": " raptor_libxml_resolveEntity(void* user_data, \n                            const xmlChar *publicId, const xmlChar *systemId) {\n   raptor_sax2* sax2 = (raptor_sax2*)user_data;\n  return libxml2_resolveEntity(sax2->xc, publicId, systemId);\n }\n", "target": 1, "idx": 178831}
{"func": "void DownloadItemImpl::OnIntermediatePathDetermined(\n    DownloadFileManager* file_manager,\n    const FilePath& intermediate_path,\n    bool ok_to_overwrite) {\n  DownloadFileManager::RenameCompletionCallback callback =\n      base::Bind(&DownloadItemImpl::OnDownloadRenamedToIntermediateName,\n                  weak_ptr_factory_.GetWeakPtr());\n   BrowserThread::PostTask(\n       BrowserThread::FILE, FROM_HERE,\n      base::Bind(&DownloadFileManager::RenameInProgressDownloadFile,\n                  file_manager, GetGlobalId(), intermediate_path,\n                  ok_to_overwrite, callback));\n }\n", "target": 1, "idx": 184458}
{"func": " void SocketStream::DoLoop(int result) {\n  if (!context_.get())\n     next_state_ = STATE_CLOSE;\n \n   if (next_state_ == STATE_NONE)\n    return;\n\n  do {\n    State state = next_state_;\n    next_state_ = STATE_NONE;\n    switch (state) {\n      case STATE_BEFORE_CONNECT:\n        DCHECK_EQ(OK, result);\n        result = DoBeforeConnect();\n        break;\n      case STATE_BEFORE_CONNECT_COMPLETE:\n        result = DoBeforeConnectComplete(result);\n        break;\n      case STATE_RESOLVE_PROXY:\n        DCHECK_EQ(OK, result);\n        result = DoResolveProxy();\n        break;\n      case STATE_RESOLVE_PROXY_COMPLETE:\n        result = DoResolveProxyComplete(result);\n        break;\n      case STATE_RESOLVE_HOST:\n        DCHECK_EQ(OK, result);\n        result = DoResolveHost();\n        break;\n      case STATE_RESOLVE_HOST_COMPLETE:\n        result = DoResolveHostComplete(result);\n        break;\n      case STATE_RESOLVE_PROTOCOL:\n        result = DoResolveProtocol(result);\n        break;\n      case STATE_RESOLVE_PROTOCOL_COMPLETE:\n        result = DoResolveProtocolComplete(result);\n        break;\n      case STATE_TCP_CONNECT:\n        result = DoTcpConnect(result);\n        break;\n      case STATE_TCP_CONNECT_COMPLETE:\n        result = DoTcpConnectComplete(result);\n        break;\n      case STATE_GENERATE_PROXY_AUTH_TOKEN:\n        result = DoGenerateProxyAuthToken();\n        break;\n      case STATE_GENERATE_PROXY_AUTH_TOKEN_COMPLETE:\n        result = DoGenerateProxyAuthTokenComplete(result);\n        break;\n      case STATE_WRITE_TUNNEL_HEADERS:\n        DCHECK_EQ(OK, result);\n        result = DoWriteTunnelHeaders();\n        break;\n      case STATE_WRITE_TUNNEL_HEADERS_COMPLETE:\n        result = DoWriteTunnelHeadersComplete(result);\n        break;\n      case STATE_READ_TUNNEL_HEADERS:\n        DCHECK_EQ(OK, result);\n        result = DoReadTunnelHeaders();\n        break;\n      case STATE_READ_TUNNEL_HEADERS_COMPLETE:\n        result = DoReadTunnelHeadersComplete(result);\n        break;\n      case STATE_SOCKS_CONNECT:\n        DCHECK_EQ(OK, result);\n        result = DoSOCKSConnect();\n        break;\n      case STATE_SOCKS_CONNECT_COMPLETE:\n        result = DoSOCKSConnectComplete(result);\n        break;\n      case STATE_SECURE_PROXY_CONNECT:\n        DCHECK_EQ(OK, result);\n        result = DoSecureProxyConnect();\n        break;\n      case STATE_SECURE_PROXY_CONNECT_COMPLETE:\n        result = DoSecureProxyConnectComplete(result);\n        break;\n      case STATE_SECURE_PROXY_HANDLE_CERT_ERROR:\n        result = DoSecureProxyHandleCertError(result);\n        break;\n      case STATE_SECURE_PROXY_HANDLE_CERT_ERROR_COMPLETE:\n        result = DoSecureProxyHandleCertErrorComplete(result);\n        break;\n      case STATE_SSL_CONNECT:\n        DCHECK_EQ(OK, result);\n        result = DoSSLConnect();\n        break;\n      case STATE_SSL_CONNECT_COMPLETE:\n        result = DoSSLConnectComplete(result);\n        break;\n      case STATE_SSL_HANDLE_CERT_ERROR:\n        result = DoSSLHandleCertError(result);\n        break;\n      case STATE_SSL_HANDLE_CERT_ERROR_COMPLETE:\n        result = DoSSLHandleCertErrorComplete(result);\n        break;\n      case STATE_READ_WRITE:\n        result = DoReadWrite(result);\n        break;\n      case STATE_AUTH_REQUIRED:\n        Finish(result);\n        return;\n      case STATE_CLOSE:\n        DCHECK_LE(result, OK);\n        Finish(result);\n        return;\n      default:\n        NOTREACHED() << \"bad state \" << state;\n        Finish(result);\n        return;\n    }\n    if (state == STATE_RESOLVE_PROTOCOL && result == ERR_PROTOCOL_SWITCHED)\n      continue;\n    if (state != STATE_READ_WRITE && result < ERR_IO_PENDING) {\n      net_log_.EndEventWithNetErrorCode(\n          NetLog::TYPE_SOCKET_STREAM_CONNECT, result);\n    }\n  } while (result != ERR_IO_PENDING);\n}\n", "target": 1, "idx": 184946}
{"func": "int test_mod_exp(BIO *bp, BN_CTX *ctx)\n{\n    BIGNUM *a, *b, *c, *d, *e;\n    int i;\n\n    a = BN_new();\n    b = BN_new();\n    c = BN_new();\n    d = BN_new();\n    e = BN_new();\n\n    BN_one(a);\n    BN_one(b);\n    BN_zero(c);\n    if (BN_mod_exp(d, a, b, c, ctx)) {\n        fprintf(stderr, \"BN_mod_exp with zero modulus succeeded!\\n\");\n        return 0;\n    }\n\n    BN_bntest_rand(c, 30, 0, 1); /* must be odd for montgomery */\n    for (i = 0; i < num2; i++) {\n        BN_bntest_rand(a, 20 + i * 5, 0, 0);\n        BN_bntest_rand(b, 2 + i, 0, 0);\n\n        if (!BN_mod_exp(d, a, b, c, ctx))\n            return (0);\n\n        if (bp != NULL) {\n            if (!results) {\n                BN_print(bp, a);\n                BIO_puts(bp, \" ^ \");\n                BN_print(bp, b);\n                BIO_puts(bp, \" % \");\n                BN_print(bp, c);\n                BIO_puts(bp, \" - \");\n            }\n            BN_print(bp, d);\n            BIO_puts(bp, \"\\n\");\n        }\n        BN_exp(e, a, b, ctx);\n        BN_sub(e, e, d);\n        BN_div(a, b, e, c, ctx);\n        if (!BN_is_zero(b)) {\n            fprintf(stderr, \"Modulo exponentiation test failed!\\n\");\n             return 0;\n         }\n     }\n     BN_free(a);\n     BN_free(b);\n     BN_free(c);\n    BN_zero(c);\n    if (BN_mod_exp_mont_consttime(d, a, b, c, ctx, NULL)) {\n        fprintf(stderr, \"BN_mod_exp_mont_consttime with zero modulus \"\n                \"succeeded\\n\");\n        return 0;\n    }\n\n    BN_set_word(c, 16);\n    if (BN_mod_exp_mont_consttime(d, a, b, c, ctx, NULL)) {\n        fprintf(stderr, \"BN_mod_exp_mont_consttime with even modulus \"\n                \"succeeded\\n\");\n        return 0;\n    }\n\n    BN_bntest_rand(c, 30, 0, 1); /* must be odd for montgomery */\n    for (i = 0; i < num2; i++) {\n        BN_bntest_rand(a, 20 + i * 5, 0, 0);\n        BN_bntest_rand(b, 2 + i, 0, 0);\n\n        if (!BN_mod_exp_mont_consttime(d, a, b, c, ctx, NULL))\n            return (00);\n\n        if (bp != NULL) {\n            if (!results) {\n                BN_print(bp, a);\n                BIO_puts(bp, \" ^ \");\n                BN_print(bp, b);\n                BIO_puts(bp, \" % \");\n                BN_print(bp, c);\n                BIO_puts(bp, \" - \");\n            }\n            BN_print(bp, d);\n            BIO_puts(bp, \"\\n\");\n        }\n        BN_exp(e, a, b, ctx);\n        BN_sub(e, e, d);\n        BN_div(a, b, e, c, ctx);\n        if (!BN_is_zero(b)) {\n            fprintf(stderr, \"Modulo exponentiation test failed!\\n\");\n            return 0;\n        }\n    }\n    BN_free(a);\n    BN_free(b);\n    BN_free(c);\n    BN_free(d);\n    BN_free(e);\n    return (1);\n}\n", "target": 1, "idx": 177893}
{"func": "selaGetCombName(SELA    *sela,\n                l_int32  size,\n                 l_int32  direction)\n {\n char    *selname;\nchar     combname[L_BUF_SIZE];\n l_int32  i, nsels, sx, sy, found;\n SEL     *sel;\n \n    PROCNAME(\"selaGetCombName\");\n\n    if (!sela)\n        return (char *)ERROR_PTR(\"sela not defined\", procName, NULL);\n    if (direction != L_HORIZ && direction != L_VERT)\n        return (char *)ERROR_PTR(\"invalid direction\", procName, NULL);\n \n         /* Derive the comb name we're looking for */\n     if (direction == L_HORIZ)\n        snprintf(combname, L_BUF_SIZE, \"sel_comb_%dh\", size);\n     else  /* direction == L_VERT */\n        snprintf(combname, L_BUF_SIZE, \"sel_comb_%dv\", size);\n \n     found = FALSE;\n     nsels = selaGetCount(sela);\n    for (i = 0; i < nsels; i++) {\n        sel = selaGetSel(sela, i);\n        selGetParameters(sel, &sy, &sx, NULL, NULL);\n        if (sy != 1 && sx != 1)  /* 2-D; not a comb */\n            continue;\n        selname = selGetName(sel);\n        if (!strcmp(selname, combname)) {\n            found = TRUE;\n            break;\n        }\n    }\n\n    if (found)\n        return stringNew(selname);\n    else\n        return (char *)ERROR_PTR(\"sel not found\", procName, NULL);\n}\n", "target": 1, "idx": 182502}
{"func": "gss_export_sec_context(minor_status,\n                       context_handle,\n                       interprocess_token)\n\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t *\t\tcontext_handle;\ngss_buffer_t\t\tinterprocess_token;\n\n{\n    OM_uint32\t\tstatus;\n    OM_uint32 \t\tlength;\n    gss_union_ctx_id_t\tctx = NULL;\n    gss_mechanism\tmech;\n    gss_buffer_desc\ttoken = GSS_C_EMPTY_BUFFER;\n    char\t\t*buf;\n\n    status = val_exp_sec_ctx_args(minor_status,\n\t\t\t\t  context_handle, interprocess_token);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n      */\n \n     ctx = (gss_union_ctx_id_t) *context_handle;\n     mech = gssint_get_mechanism (ctx->mech_type);\n     if (!mech)\n \treturn GSS_S_BAD_MECH;\n    if (!mech->gss_export_sec_context)\n\treturn (GSS_S_UNAVAILABLE);\n\n    status = mech->gss_export_sec_context(minor_status,\n\t\t\t\t\t  &ctx->internal_ctx_id, &token);\n    if (status != GSS_S_COMPLETE) {\n\tmap_error(minor_status, mech);\n\tgoto cleanup;\n    }\n\n    length = token.length + 4 + ctx->mech_type->length;\n    interprocess_token->length = length;\n    interprocess_token->value = malloc(length);\n    if (interprocess_token->value == 0) {\n\t*minor_status = ENOMEM;\n\tstatus = GSS_S_FAILURE;\n\tgoto cleanup;\n    }\n    buf = interprocess_token->value;\n    length = ctx->mech_type->length;\n    buf[3] = (unsigned char) (length & 0xFF);\n    length >>= 8;\n    buf[2] = (unsigned char) (length & 0xFF);\n    length >>= 8;\n    buf[1] = (unsigned char) (length & 0xFF);\n    length >>= 8;\n    buf[0] = (unsigned char) (length & 0xFF);\n    memcpy(buf+4, ctx->mech_type->elements, (size_t) ctx->mech_type->length);\n    memcpy(buf+4+ctx->mech_type->length, token.value, token.length);\n\n    status = GSS_S_COMPLETE;\n\ncleanup:\n    (void) gss_release_buffer(minor_status, &token);\n    if (ctx != NULL && ctx->internal_ctx_id == GSS_C_NO_CONTEXT) {\n\t/* If the mech deleted its context, delete the union context. */\n\tfree(ctx->mech_type->elements);\n\tfree(ctx->mech_type);\n\tfree(ctx);\n\t*context_handle = GSS_C_NO_CONTEXT;\n    }\n    return status;\n}\n", "target": 1, "idx": 181187}
{"func": " bool ExtensionTtsPlatformImplWin::Speak(\n     const std::string& src_utterance,\n    const std::string& language,\n    const std::string& gender,\n    double rate,\n    double pitch,\n    double volume) {\n  std::wstring utterance = UTF8ToUTF16(src_utterance);\n \n   if (!speech_synthesizer_)\n     return false;\n \n \n  if (rate >= 0.0) {\n    speech_synthesizer_->SetRate(static_cast<int32>(rate * 20 - 10));\n   }\n \n  if (pitch >= 0.0) {\n     std::wstring pitch_value =\n        base::IntToString16(static_cast<int>(pitch * 20 - 10));\n    utterance = L\"<pitch absmiddle=\\\"\" + pitch_value + L\"\\\">\" +\n        utterance + L\"</pitch>\";\n   }\n \n  if (volume >= 0.0) {\n    speech_synthesizer_->SetVolume(static_cast<uint16>(volume * 100));\n   }\n \n   if (paused_) {\n     speech_synthesizer_->Resume();\n     paused_ = false;\n   }\n  speech_synthesizer_->Speak(\n      utterance.c_str(), SPF_ASYNC | SPF_PURGEBEFORESPEAK, NULL);\n \n  return true;\n }\n", "target": 1, "idx": 183859}
{"func": "PHP_FUNCTION(mcrypt_enc_get_supported_key_sizes)\n {\n \tint i, count = 0;\n \tint *key_sizes;\n \tMCRYPT_GET_TD_ARG\n \tarray_init(return_value);\n \n\tkey_sizes = mcrypt_enc_get_supported_key_sizes(pm->td, &count);\n\n\tfor (i = 0; i < count; i++) {\n\t\tadd_index_long(return_value, i, key_sizes[i]);\n\t}\n\n\tmcrypt_free(key_sizes);\n}\n", "target": 1, "idx": 180265}
{"func": " IW_IMPL(unsigned int) iw_get_ui32be(const iw_byte *b)\n {\n\treturn (b[0]<<24) | (b[1]<<16) | (b[2]<<8) | b[3];\n }\n", "target": 1, "idx": 181371}
{"func": " void SynchronousCompositorExternalBeginFrameSource::SetCompositor(\n     SynchronousCompositorImpl* compositor) {\n   DCHECK(CalledOnValidThread());\n   compositor_ = compositor;\n }\n", "target": 1, "idx": 185582}
{"func": "static int nested_vmx_eptp_switching(struct kvm_vcpu *vcpu,\n\t\t\t\t     struct vmcs12 *vmcs12)\n{\n\tu32 index = vcpu->arch.regs[VCPU_REGS_RCX];\n\tu64 address;\n\tbool accessed_dirty;\n\tstruct kvm_mmu *mmu = vcpu->arch.walk_mmu;\n\n\tif (!nested_cpu_has_eptp_switching(vmcs12) ||\n\t    !nested_cpu_has_ept(vmcs12))\n\t\treturn 1;\n\n\tif (index >= VMFUNC_EPTP_ENTRIES)\n\t\treturn 1;\n\n\n\tif (kvm_vcpu_read_guest_page(vcpu, vmcs12->eptp_list_address >> PAGE_SHIFT,\n\t\t\t\t     &address, index * 8, 8))\n\t\treturn 1;\n\n\taccessed_dirty = !!(address & VMX_EPTP_AD_ENABLE_BIT);\n\n\t/*\n\t * If the (L2) guest does a vmfunc to the currently\n\t * active ept pointer, we don't have to do anything else\n\t */\n\tif (vmcs12->ept_pointer != address) {\n\t\tif (!valid_ept_address(vcpu, address))\n\t\t\treturn 1;\n\n\t\tkvm_mmu_unload(vcpu);\n\t\tmmu->ept_ad = accessed_dirty;\n\t\tmmu->base_role.ad_disabled = !accessed_dirty;\n\t\tvmcs12->ept_pointer = address;\n\t\t/*\n\t\t * TODO: Check what's the correct approach in case\n\t\t * mmu reload fails. Currently, we just let the next\n\t\t * reload potentially fail\n\t\t */\n\t\tkvm_mmu_reload(vcpu);\n\t}\n\n\treturn 0;\n}\n", "target": 0, "idx": 63004}
{"func": "nfs4_callback_svc(void *vrqstp)\n{\n\tint err;\n\tstruct svc_rqst *rqstp = vrqstp;\n \n \tset_freezable();\n \n\twhile (!kthread_should_stop()) {\n \t\t/*\n \t\t * Listen for a request on the socket\n \t\t */\n\t\terr = svc_recv(rqstp, MAX_SCHEDULE_TIMEOUT);\n\t\tif (err == -EAGAIN || err == -EINTR)\n \t\t\tcontinue;\n \t\tsvc_process(rqstp);\n \t}\n \treturn 0;\n }\n", "target": 1, "idx": 181310}
{"func": "static noinline int acls_after_inode_item(struct extent_buffer *leaf,\n\t\t\t\t\t  int slot, u64 objectid)\n{\n\tu32 nritems = btrfs_header_nritems(leaf);\n\tstruct btrfs_key found_key;\n\tint scanned = 0;\n\n\tslot++;\n\twhile (slot < nritems) {\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, slot);\n\n\t\t/* we found a different objectid, there must not be acls */\n\t\tif (found_key.objectid != objectid)\n\t\t\treturn 0;\n\n\t\t/* we found an xattr, assume we've got an acl */\n\t\tif (found_key.type == BTRFS_XATTR_ITEM_KEY)\n\t\t\treturn 1;\n\n\t\t/*\n\t\t * we found a key greater than an xattr key, there can't\n\t\t * be any acls later on\n\t\t */\n\t\tif (found_key.type > BTRFS_XATTR_ITEM_KEY)\n\t\t\treturn 0;\n\n\t\tslot++;\n\t\tscanned++;\n\n\t\t/*\n\t\t * it goes inode, inode backrefs, xattrs, extents,\n\t\t * so if there are a ton of hard links to an inode there can\n\t\t * be a lot of backrefs.  Don't waste time searching too hard,\n\t\t * this is just an optimization\n\t\t */\n\t\tif (scanned >= 8)\n\t\t\tbreak;\n\t}\n\t/* we hit the end of the leaf before we found an xattr or\n\t * something larger than an xattr.  We have to assume the inode\n\t * has acls\n\t */\n\treturn 1;\n}\n", "target": 0, "idx": 34274}
{"func": "status_t Parcel::writeByteVector(const std::unique_ptr<std::vector<uint8_t>>& val)\n{\n return writeByteVectorInternalPtr(this, val);\n}\n", "target": 0, "idx": 176780}
{"func": "  void Wait() {\n    if (web_contents()->GetController().GetVisibleEntry())\n      return;\n    run_loop_.Run();\n  }\n", "target": 0, "idx": 159678}
{"func": " static void registerStreamURLTask(void* context)\n {\n     OwnPtr<BlobRegistryContext> blobRegistryContext = adoptPtr(static_cast<BlobRegistryContext*>(context));\n    blobRegistry().registerStreamURL(blobRegistryContext->url, blobRegistryContext->type);\n }\n", "target": 1, "idx": 184263}
{"func": "  SiteInstance* parent_site_instance() const {\n    return parent_site_instance_.get();\n  }\n", "target": 1, "idx": 187030}
{"func": "static void __devexit pmcraid_remove(struct pci_dev *pdev)\n{\n\tstruct pmcraid_instance *pinstance = pci_get_drvdata(pdev);\n\n\t/* remove the management interface (/dev file) for this device */\n\tpmcraid_release_chrdev(pinstance);\n\n\t/* remove host template from scsi midlayer */\n\tscsi_remove_host(pinstance->host);\n\n\t/* block requests from mid-layer */\n\tscsi_block_requests(pinstance->host);\n\n\t/* initiate shutdown adapter */\n\tpmcraid_shutdown(pdev);\n\n\tpmcraid_disable_interrupts(pinstance, ~0);\n\tflush_work_sync(&pinstance->worker_q);\n\n\tpmcraid_kill_tasklets(pinstance);\n\tpmcraid_unregister_interrupt_handler(pinstance);\n\tpmcraid_release_buffers(pinstance);\n\tiounmap(pinstance->mapped_dma_addr);\n\tpci_release_regions(pdev);\n\tscsi_host_put(pinstance->host);\n\tpci_disable_device(pdev);\n\n\treturn;\n}\n", "target": 0, "idx": 26500}
{"func": "KURL Document::openSearchDescriptionURL()\n{\n    static const char openSearchMIMEType[] = \"application/opensearchdescription+xml\";\n    static const char openSearchRelation[] = \"search\";\n\n    if (!frame() || frame()->tree().parent())\n        return KURL();\n\n    if (!loadEventFinished())\n        return KURL();\n\n    if (!head())\n        return KURL();\n\n    for (HTMLLinkElement* linkElement = Traversal<HTMLLinkElement>::firstChild(*head()); linkElement; linkElement = Traversal<HTMLLinkElement>::nextSibling(*linkElement)) {\n        if (!equalIgnoringCase(linkElement->type(), openSearchMIMEType) || !equalIgnoringCase(linkElement->rel(), openSearchRelation))\n            continue;\n        if (linkElement->href().isEmpty())\n            continue;\n\n        UseCounter::Feature osdDisposition;\n        RefPtr<SecurityOrigin> target = SecurityOrigin::create(linkElement->href());\n        if (isSecureContext()) {\n            osdDisposition = target->isPotentiallyTrustworthy()\n                ? UseCounter::OpenSearchSecureOriginSecureTarget\n                : UseCounter::OpenSearchSecureOriginInsecureTarget;\n        } else {\n            osdDisposition = target->isPotentiallyTrustworthy()\n                ? UseCounter::OpenSearchInsecureOriginSecureTarget\n                : UseCounter::OpenSearchInsecureOriginInsecureTarget;\n        }\n        UseCounter::count(*this, osdDisposition);\n\n        return linkElement->href();\n    }\n\n    return KURL();\n}\n", "target": 0, "idx": 143232}
{"func": "static int pack_offset_sort(const void *_a, const void *_b)\n{\n\tconst struct object_entry *a = *(struct object_entry **)_a;\n\tconst struct object_entry *b = *(struct object_entry **)_b;\n\n\t/* avoid filesystem trashing with loose objects */\n\tif (!a->in_pack && !b->in_pack)\n\t\treturn hashcmp(a->idx.sha1, b->idx.sha1);\n\n\tif (a->in_pack < b->in_pack)\n\t\treturn -1;\n\tif (a->in_pack > b->in_pack)\n\t\treturn 1;\n\treturn a->in_pack_offset < b->in_pack_offset ? -1 :\n\t\t\t(a->in_pack_offset > b->in_pack_offset);\n}\n", "target": 0, "idx": 54864}
{"func": "void BluetoothOptionsHandler::GenerateFakePairing(\n    const std::string& name,\n    const std::string& address,\n    const std::string& icon,\n     const std::string& pairing) {\n  DictionaryValue device;\n  device.SetString(\"name\", name);\n  device.SetString(\"address\", address);\n  device.SetString(\"icon\", icon);\n  device.SetBoolean(\"paired\", false);\n  device.SetBoolean(\"connected\", false);\n  DictionaryValue op;\n  op.SetString(\"pairing\", pairing);\n  if (pairing.compare(\"bluetoothEnterPasskey\") != 0)\n    op.SetInteger(\"passkey\", 12345);\n  if (pairing.compare(\"bluetoothRemotePasskey\") == 0)\n    op.SetInteger(\"entered\", 2);\n  web_ui_->CallJavascriptFunction(\n      \"options.SystemOptions.connectBluetoothDevice\", device, op);\n }\n", "target": 1, "idx": 184601}
{"func": "int bio_add_page(struct bio *bio, struct page *page,\n\t\t unsigned int len, unsigned int offset)\n{\n\tstruct bio_vec *bv;\n\n\t/*\n\t * cloned bio must not modify vec list\n\t */\n\tif (WARN_ON_ONCE(bio_flagged(bio, BIO_CLONED)))\n\t\treturn 0;\n\n\t/*\n\t * For filesystems with a blocksize smaller than the pagesize\n\t * we will often be called with the same page as last time and\n\t * a consecutive offset.  Optimize this special case.\n\t */\n\tif (bio->bi_vcnt > 0) {\n\t\tbv = &bio->bi_io_vec[bio->bi_vcnt - 1];\n\n\t\tif (page == bv->bv_page &&\n\t\t    offset == bv->bv_offset + bv->bv_len) {\n\t\t\tbv->bv_len += len;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif (bio->bi_vcnt >= bio->bi_max_vecs)\n\t\treturn 0;\n\n\tbv\t\t= &bio->bi_io_vec[bio->bi_vcnt];\n\tbv->bv_page\t= page;\n\tbv->bv_len\t= len;\n\tbv->bv_offset\t= offset;\n\n\tbio->bi_vcnt++;\ndone:\n\tbio->bi_iter.bi_size += len;\n\treturn len;\n}\n", "target": 0, "idx": 62804}
{"func": "static double FreshnessLifetime(const ResourceResponse& response,\n                                double response_timestamp) {\n#if !defined(OS_ANDROID)\n  if (response.Url().IsLocalFile())\n    return 0;\n#endif\n\n  if (!response.Url().ProtocolIsInHTTPFamily() &&\n      !response.Url().ProtocolIs(\"filesystem\"))\n    return std::numeric_limits<double>::max();\n\n  double max_age_value = response.CacheControlMaxAge();\n  if (std::isfinite(max_age_value))\n    return max_age_value;\n  double expires_value = response.Expires();\n  double date_value = response.Date();\n  double creation_time =\n      std::isfinite(date_value) ? date_value : response_timestamp;\n  if (std::isfinite(expires_value))\n    return expires_value - creation_time;\n  double last_modified_value = response.LastModified();\n  if (std::isfinite(last_modified_value))\n    return (creation_time - last_modified_value) * 0.1;\n  return 0;\n}\n", "target": 0, "idx": 162541}
{"func": "int read_escaped_char(\n    yyscan_t yyscanner,\n    uint8_t* escaped_char)\n{\n  char text[4] = {0, 0, 0, 0};\n\n   text[0] = '\\\\';\n   text[1] = RE_YY_INPUT(yyscanner);\n \n  if (text[1] == EOF)\n     return 0;\n \n   if (text[1] == 'x')\n   {\n     text[2] = RE_YY_INPUT(yyscanner);\n \n    if (text[2] == EOF)\n       return 0;\n \n     text[3] = RE_YY_INPUT(yyscanner);\n \n    if (text[3] == EOF)\n       return 0;\n   }\n \n  *escaped_char = escaped_char_value(text);\n\n  return 1;\n}\n", "target": 1, "idx": 181658}
{"func": "int nfs_revalidate_inode(struct nfs_server *server, struct inode *inode)\n{\n\tif (!(NFS_I(inode)->cache_validity & NFS_INO_INVALID_ATTR)\n\t\t\t&& !nfs_attribute_timeout(inode))\n\t\treturn NFS_STALE(inode) ? -ESTALE : 0;\n\treturn __nfs_revalidate_inode(server, inode);\n}\n", "target": 0, "idx": 22812}
{"func": "int inet6_sk_rebuild_header(struct sock *sk)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct dst_entry *dst;\n\n\tdst = __sk_dst_check(sk, np->dst_cookie);\n\n\tif (!dst) {\n\t\tstruct inet_sock *inet = inet_sk(sk);\n\t\tstruct in6_addr *final_p, final;\n\t\tstruct flowi6 fl6;\n\n\t\tmemset(&fl6, 0, sizeof(fl6));\n\t\tfl6.flowi6_proto = sk->sk_protocol;\n\t\tfl6.daddr = sk->sk_v6_daddr;\n\t\tfl6.saddr = np->saddr;\n\t\tfl6.flowlabel = np->flow_label;\n\t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\t\tfl6.flowi6_mark = sk->sk_mark;\n\t\tfl6.fl6_dport = inet->inet_dport;\n \t\tfl6.fl6_sport = inet->inet_sport;\n \t\tsecurity_sk_classify_flow(sk, flowi6_to_flowi(&fl6));\n \n\t\tfinal_p = fl6_update_dst(&fl6, np->opt, &final);\n \n \t\tdst = ip6_dst_lookup_flow(sk, &fl6, final_p);\n \t\tif (IS_ERR(dst)) {\n\t\t\tsk->sk_route_caps = 0;\n\t\t\tsk->sk_err_soft = -PTR_ERR(dst);\n\t\t\treturn PTR_ERR(dst);\n\t\t}\n\n\t\t__ip6_dst_store(sk, dst, NULL, NULL);\n\t}\n\n\treturn 0;\n}\n", "target": 1, "idx": 180500}
{"func": "PaymentRequest::PaymentRequest(\n    content::RenderFrameHost* render_frame_host,\n    content::WebContents* web_contents,\n    std::unique_ptr<ContentPaymentRequestDelegate> delegate,\n    PaymentRequestWebContentsManager* manager,\n    PaymentRequestDisplayManager* display_manager,\n     mojo::InterfaceRequest<mojom::PaymentRequest> request,\n     ObserverForTest* observer_for_testing)\n     : web_contents_(web_contents),\n       delegate_(std::move(delegate)),\n       manager_(manager),\n       display_manager_(display_manager),\n      display_handle_(nullptr),\n      binding_(this, std::move(request)),\n      top_level_origin_(url_formatter::FormatUrlForSecurityDisplay(\n          web_contents_->GetLastCommittedURL())),\n      frame_origin_(url_formatter::FormatUrlForSecurityDisplay(\n          render_frame_host->GetLastCommittedURL())),\n      observer_for_testing_(observer_for_testing),\n      journey_logger_(delegate_->IsIncognito(),\n                      ukm::GetSourceIdForWebContentsDocument(web_contents)),\n      weak_ptr_factory_(this) {\n  binding_.set_connection_error_handler(base::BindOnce(\n      &PaymentRequest::OnConnectionTerminated, weak_ptr_factory_.GetWeakPtr()));\n}\n", "target": 1, "idx": 187068}
{"func": "static void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags)\n{\n\tconst struct sched_class *class;\n\n\tif (p->sched_class == rq->curr->sched_class) {\n\t\trq->curr->sched_class->check_preempt_curr(rq, p, flags);\n\t} else {\n\t\tfor_each_class(class) {\n\t\t\tif (class == rq->curr->sched_class)\n\t\t\t\tbreak;\n\t\t\tif (class == p->sched_class) {\n\t\t\t\tresched_task(rq->curr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * A queue event has occurred, and we're going to schedule.  In\n\t * this case, we can save a useless back to back clock update.\n\t */\n\tif (rq->curr->on_rq && test_tsk_need_resched(rq->curr))\n\t\trq->skip_clock_update = 1;\n}\n", "target": 0, "idx": 26262}
{"func": "ofproto_type_wait(const char *datapath_type)\n{\n    const struct ofproto_class *class;\n\n    datapath_type = ofproto_normalize_type(datapath_type);\n    class = ofproto_class_find__(datapath_type);\n\n    if (class->type_wait) {\n        class->type_wait(datapath_type);\n    }\n}\n", "target": 0, "idx": 77400}
{"func": "Address LargeObjectArena::doAllocateLargeObjectPage(size_t allocationSize,\n                                                    size_t gcInfoIndex) {\n  size_t largeObjectSize = LargeObjectPage::pageHeaderSize() + allocationSize;\n#if defined(ADDRESS_SANITIZER)\n  largeObjectSize += allocationGranularity;\n#endif\n\n  getThreadState()->shouldFlushHeapDoesNotContainCache();\n  PageMemory* pageMemory = PageMemory::allocate(\n      largeObjectSize, getThreadState()->heap().getRegionTree());\n  Address largeObjectAddress = pageMemory->writableStart();\n  Address headerAddress =\n      largeObjectAddress + LargeObjectPage::pageHeaderSize();\n#if DCHECK_IS_ON()\n  for (size_t i = 0; i < largeObjectSize; ++i)\n    ASSERT(!largeObjectAddress[i]);\n#endif\n  ASSERT(gcInfoIndex > 0);\n  HeapObjectHeader* header = new (NotNull, headerAddress)\n      HeapObjectHeader(largeObjectSizeInHeader, gcInfoIndex);\n  Address result = headerAddress + sizeof(*header);\n   ASSERT(!(reinterpret_cast<uintptr_t>(result) & allocationMask));\n   LargeObjectPage* largeObject = new (largeObjectAddress)\n       LargeObjectPage(pageMemory, this, allocationSize);\n  ASSERT(header->checkHeader());\n \n   ASAN_POISON_MEMORY_REGION(header, sizeof(*header));\n  ASAN_POISON_MEMORY_REGION(largeObject->getAddress() + largeObject->size(),\n                            allocationGranularity);\n\n  largeObject->link(&m_firstPage);\n\n  getThreadState()->heap().heapStats().increaseAllocatedSpace(\n      largeObject->size());\n  getThreadState()->increaseAllocatedObjectSize(largeObject->size());\n  return result;\n}\n", "target": 1, "idx": 186686}
{"func": " cib_remote_listen(gpointer data)\n {\n    int lpc = 0;\n     int csock = 0;\n     unsigned laddr;\n    time_t now = 0;\n    time_t start = time(NULL);\n     struct sockaddr_in addr;\n     int ssock = *(int *)data;\n \n #ifdef HAVE_GNUTLS_GNUTLS_H\n     gnutls_session *session = NULL;\n #endif\n     cib_client_t *new_client = NULL;\n \n    xmlNode *login = NULL;\n    const char *user = NULL;\n    const char *pass = NULL;\n    const char *tmp = NULL;\n#ifdef HAVE_DECL_NANOSLEEP\n    const struct timespec sleepfast = { 0, 10000000 };  /* 10 millisec */\n#endif\n     static struct mainloop_fd_callbacks remote_client_fd_callbacks = \n         {\n             .dispatch = cib_remote_msg,\n             .destroy = cib_remote_connection_destroy,\n        };    \n     /* accept the connection */\n     laddr = sizeof(addr);\n     csock = accept(ssock, (struct sockaddr *)&addr, &laddr);\n    crm_debug(\"New %s connection from %s\",\n              ssock == remote_tls_fd ? \"secure\" : \"clear-text\", inet_ntoa(addr.sin_addr));\n\n    if (csock == -1) {\n        crm_err(\"accept socket failed\");\n         return TRUE;\n     }\n \n     if (ssock == remote_tls_fd) {\n #ifdef HAVE_GNUTLS_GNUTLS_H\n         /* create gnutls session for the server socket */\n        session = create_tls_session(csock, GNUTLS_SERVER);\n         if (session == NULL) {\n             crm_err(\"TLS session creation failed\");\n             close(csock);\n            return TRUE;\n        }\n #endif\n     }\n \n    do {\n        crm_trace(\"Iter: %d\", lpc++);\n        if (ssock == remote_tls_fd) {\n#ifdef HAVE_GNUTLS_GNUTLS_H\n            login = crm_recv_remote_msg(session, TRUE);\n#endif\n        } else {\n            login = crm_recv_remote_msg(GINT_TO_POINTER(csock), FALSE);\n        }\n        if (login != NULL) {\n            break;\n        }\n#ifdef HAVE_DECL_NANOSLEEP\n        nanosleep(&sleepfast, NULL);\n#else\n        sleep(1);\n#endif\n        now = time(NULL);\n        /* Peers have 3s to connect */\n    } while (login == NULL && (start - now) < 4);\n    crm_log_xml_info(login, \"Login: \");\n    if (login == NULL) {\n        goto bail;\n    }\n    tmp = crm_element_name(login);\n    if (safe_str_neq(tmp, \"cib_command\")) {\n        crm_err(\"Wrong tag: %s\", tmp);\n        goto bail;\n    }\n    tmp = crm_element_value(login, \"op\");\n    if (safe_str_neq(tmp, \"authenticate\")) {\n        crm_err(\"Wrong operation: %s\", tmp);\n        goto bail;\n    }\n    user = crm_element_value(login, \"user\");\n    pass = crm_element_value(login, \"password\");\n    /* Non-root daemons can only validate the password of the\n     * user they're running as\n     */\n    if (check_group_membership(user, CRM_DAEMON_GROUP) == FALSE) {\n        crm_err(\"User is not a member of the required group\");\n        goto bail;\n    } else if (authenticate_user(user, pass) == FALSE) {\n        crm_err(\"PAM auth failed\");\n        goto bail;\n    }\n    /* send ACK */\n     num_clients++;\n     new_client = calloc(1, sizeof(cib_client_t));\n    new_client->name = crm_element_value_copy(login, \"name\");\n    CRM_CHECK(new_client->id == NULL, free(new_client->id));\n     new_client->id = crm_generate_uuid();\n#if ENABLE_ACL\n    new_client->user = strdup(user);\n#endif\n     new_client->callback_id = NULL;\n     if (ssock == remote_tls_fd) {\n #ifdef HAVE_GNUTLS_GNUTLS_H\n         new_client->encrypted = TRUE;\n        new_client->session = session;\n#endif\n    } else {\n         new_client->session = GINT_TO_POINTER(csock);\n     }\n \n    free_xml(login);\n    login = create_xml_node(NULL, \"cib_result\");\n    crm_xml_add(login, F_CIB_OPERATION, CRM_OP_REGISTER);\n    crm_xml_add(login, F_CIB_CLIENTID, new_client->id);\n    crm_send_remote_msg(new_client->session, login, new_client->encrypted);\n    free_xml(login);\n     new_client->remote = mainloop_add_fd(\n         \"cib-remote-client\", G_PRIORITY_DEFAULT, csock, new_client, &remote_client_fd_callbacks);\n \n     g_hash_table_insert(client_list, new_client->id, new_client);\n \n     return TRUE;\n  bail:\n    if (ssock == remote_tls_fd) {\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        gnutls_bye(*session, GNUTLS_SHUT_RDWR);\n        gnutls_deinit(*session);\n        gnutls_free(session);\n#endif\n    }\n    close(csock);\n    free_xml(login);\n    return TRUE;\n }\n", "target": 1, "idx": 179320}
{"func": "static void xen_netbk_idx_release(struct xen_netbk *netbk, u16 pending_idx)\n {\n \tstruct xenvif *vif;\n \tstruct pending_tx_info *pending_tx_info;\n\tpending_ring_idx_t index;\n\n\t/* Already complete? */\n\tif (netbk->mmap_pages[pending_idx] == NULL)\n\t\treturn;\n\n\tpending_tx_info = &netbk->pending_tx_info[pending_idx];\n \n \tvif = pending_tx_info->vif;\n \n\tmake_tx_response(vif, &pending_tx_info->req, XEN_NETIF_RSP_OKAY);\n \n \tindex = pending_index(netbk->pending_prod++);\n \tnetbk->pending_ring[index] = pending_idx;\n\n\txenvif_put(vif);\n\n\tnetbk->mmap_pages[pending_idx]->mapping = 0;\n\tput_page(netbk->mmap_pages[pending_idx]);\n\tnetbk->mmap_pages[pending_idx] = NULL;\n}\n", "target": 1, "idx": 179340}
{"func": "fire_sched_out_preempt_notifiers(struct task_struct *curr,\n\t\t\t\t struct task_struct *next)\n{\n\tstruct preempt_notifier *notifier;\n\n\thlist_for_each_entry(notifier, &curr->preempt_notifiers, link)\n\t\tnotifier->ops->sched_out(notifier, next);\n}\n", "target": 0, "idx": 58157}
{"func": " int propagate_mnt(struct mount *dest_mnt, struct dentry *dest_dentry,\n \t\t    struct mount *source_mnt, struct list_head *tree_list)\n {\n \tstruct mount *m, *child;\n \tint ret = 0;\n \tstruct mount *prev_dest_mnt = dest_mnt;\n\tstruct mount *prev_src_mnt  = source_mnt;\n\tLIST_HEAD(tmp_list);\n\tLIST_HEAD(umount_list);\n\n\tfor (m = propagation_next(dest_mnt, dest_mnt); m;\n\t\t\tm = propagation_next(m, dest_mnt)) {\n\t\tint type;\n\t\tstruct mount *source;\n\n\t\tif (IS_MNT_NEW(m))\n\t\t\tcontinue;\n \n \t\tsource =  get_source(m, prev_dest_mnt, prev_src_mnt, &type);\n \n \t\tchild = copy_tree(source, source->mnt.mnt_root, type);\n \t\tif (IS_ERR(child)) {\n \t\t\tret = PTR_ERR(child);\n\t\t\tlist_splice(tree_list, tmp_list.prev);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (is_subdir(dest_dentry, m->mnt.mnt_root)) {\n\t\t\tmnt_set_mountpoint(m, dest_dentry, child);\n\t\t\tlist_add_tail(&child->mnt_hash, tree_list);\n\t\t} else {\n\t\t\t/*\n\t\t\t * This can happen if the parent mount was bind mounted\n\t\t\t * on some subdirectory of a shared/slave mount.\n\t\t\t */\n\t\t\tlist_add_tail(&child->mnt_hash, &tmp_list);\n\t\t}\n\t\tprev_dest_mnt = m;\n\t\tprev_src_mnt  = child;\n\t}\nout:\n\tbr_write_lock(&vfsmount_lock);\n\twhile (!list_empty(&tmp_list)) {\n\t\tchild = list_first_entry(&tmp_list, struct mount, mnt_hash);\n\t\tumount_tree(child, 0, &umount_list);\n\t}\n\tbr_write_unlock(&vfsmount_lock);\n\trelease_mounts(&umount_list);\n\treturn ret;\n}\n", "target": 1, "idx": 179268}
{"func": "GF_Err dmed_dump(GF_Box *a, FILE * trace)\n{\n\tGF_DMEDBox *p;\n\n\tp = (GF_DMEDBox *)a;\n\tgf_isom_box_dump_start(a, \"BytesFromMediaTrackBox\", trace);\n\tfprintf(trace, \"BytesSent=\\\"\"LLD\"\\\">\\n\", LLD_CAST p->nbBytes);\n\tgf_isom_box_dump_done(\"BytesFromMediaTrackBox\", a, trace);\n\treturn GF_OK;\n}\n", "target": 0, "idx": 80713}
{"func": "static int fetch_uidl(char *line, void *data)\n{\n  int i, index;\n  struct Context *ctx = (struct Context *) data;\n  struct PopData *pop_data = (struct PopData *) ctx->data;\n  char *endp = NULL;\n\n  errno = 0;\n  index = strtol(line, &endp, 10);\n  if (errno)\n    return -1;\n  while (*endp == ' ')\n     endp++;\n   memmove(line, endp, strlen(endp) + 1);\n \n   for (i = 0; i < ctx->msgcount; i++)\n     if (mutt_str_strcmp(line, ctx->hdrs[i]->data) == 0)\n       break;\n\n  if (i == ctx->msgcount)\n  {\n    mutt_debug(1, \"new header %d %s\\n\", index, line);\n\n    if (i >= ctx->hdrmax)\n      mx_alloc_memory(ctx);\n\n    ctx->msgcount++;\n    ctx->hdrs[i] = mutt_header_new();\n    ctx->hdrs[i]->data = mutt_str_strdup(line);\n  }\n  else if (ctx->hdrs[i]->index != index - 1)\n    pop_data->clear_cache = true;\n\n  ctx->hdrs[i]->refno = index;\n  ctx->hdrs[i]->index = index - 1;\n\n  return 0;\n}\n", "target": 1, "idx": 182308}
{"func": "static int mwifiex_uap_custom_ie_prepare(u8 *tlv, void *cmd_buf, u16 *ie_size)\n{\n\tstruct mwifiex_ie_list *ap_ie = cmd_buf;\n\tstruct mwifiex_ie_types_header *tlv_ie = (void *)tlv;\n\n\tif (!ap_ie || !ap_ie->len)\n\t\treturn -1;\n\n\t*ie_size += le16_to_cpu(ap_ie->len) +\n\t\t\tsizeof(struct mwifiex_ie_types_header);\n\n\ttlv_ie->type = cpu_to_le16(TLV_TYPE_MGMT_IE);\n\ttlv_ie->len = ap_ie->len;\n\ttlv += sizeof(struct mwifiex_ie_types_header);\n\n\tmemcpy(tlv, ap_ie->ie_list, le16_to_cpu(ap_ie->len));\n\n\treturn 0;\n}\n", "target": 0, "idx": 88624}
{"func": "media::mojom::VideoFrameDataPtr MakeVideoFrameData(\n    const scoped_refptr<media::VideoFrame>& input) {\n  if (input->metadata()->IsTrue(media::VideoFrameMetadata::END_OF_STREAM)) {\n    return media::mojom::VideoFrameData::NewEosData(\n        media::mojom::EosVideoFrameData::New());\n  }\n\n  if (input->storage_type() == media::VideoFrame::STORAGE_MOJO_SHARED_BUFFER) {\n     media::MojoSharedBufferVideoFrame* mojo_frame =\n         static_cast<media::MojoSharedBufferVideoFrame*>(input.get());\n \n     mojo::ScopedSharedBufferHandle dup = mojo_frame->Handle().Clone(\n        mojo::SharedBufferHandle::AccessMode::READ_ONLY);\n     DCHECK(dup.is_valid());\n \n     return media::mojom::VideoFrameData::NewSharedBufferData(\n        media::mojom::SharedBufferVideoFrameData::New(\n            std::move(dup), mojo_frame->MappedSize(),\n            mojo_frame->stride(media::VideoFrame::kYPlane),\n            mojo_frame->stride(media::VideoFrame::kUPlane),\n            mojo_frame->stride(media::VideoFrame::kVPlane),\n            mojo_frame->PlaneOffset(media::VideoFrame::kYPlane),\n            mojo_frame->PlaneOffset(media::VideoFrame::kUPlane),\n            mojo_frame->PlaneOffset(media::VideoFrame::kVPlane)));\n  }\n\n  if (input->HasTextures()) {\n    std::vector<gpu::MailboxHolder> mailbox_holder(\n        media::VideoFrame::kMaxPlanes);\n    size_t num_planes = media::VideoFrame::NumPlanes(input->format());\n    for (size_t i = 0; i < num_planes; i++)\n      mailbox_holder[i] = input->mailbox_holder(i);\n    return media::mojom::VideoFrameData::NewMailboxData(\n        media::mojom::MailboxVideoFrameData::New(std::move(mailbox_holder)));\n  }\n\n  NOTREACHED() << \"Unsupported VideoFrame conversion\";\n  return nullptr;\n}\n", "target": 1, "idx": 186853}
{"func": "BaseShadow::logTerminateEvent( int exitReason, update_style_t kind )\n{\n\tstruct rusage run_remote_rusage;\n\tJobTerminatedEvent event;\n\tMyString corefile;\n\n\tmemset( &run_remote_rusage, 0, sizeof(struct rusage) );\n\n\tswitch( exitReason ) {\n\tcase JOB_EXITED:\n\tcase JOB_COREDUMPED:\n\t\tbreak;\n\tdefault:\n\t\tdprintf( D_ALWAYS, \n\t\t\t\t \"UserLog logTerminateEvent with unknown reason (%d), aborting\\n\",\n\t\t\t\t exitReason ); \n\t\treturn;\n\t}\n\n\tif (kind == US_TERMINATE_PENDING) {\n\n\t\tfloat float_value;\n\t\tint exited_by_signal = FALSE;\n\t\tint exit_signal = 0;\n\t\tint exit_code = 0;\n\n\t\tgetJobAdExitedBySignal(jobAd, exited_by_signal);\n\t\tif (exited_by_signal == TRUE) {\n\t\t\tgetJobAdExitSignal(jobAd, exit_signal);\n\t\t\tevent.normal = false;\n\t\t\tevent.signalNumber = exit_signal;\n\t\t} else {\n\t\t\tgetJobAdExitCode(jobAd, exit_code);\n\t\t\tevent.normal = true;\n\t\t\tevent.returnValue = exit_code;\n\t\t}\n\n\t\t/* grab usage information out of job ad */\n\t\tif( jobAd->LookupFloat(ATTR_JOB_REMOTE_SYS_CPU, float_value) ) {\n\t\t\trun_remote_rusage.ru_stime.tv_sec = (int) float_value;\n\t\t}\n\n\t\tif( jobAd->LookupFloat(ATTR_JOB_REMOTE_USER_CPU, float_value) ) {\n\t\t\trun_remote_rusage.ru_utime.tv_sec = (int) float_value;\n\t\t}\n\n\t\tevent.run_remote_rusage = run_remote_rusage;\n\t\tevent.total_remote_rusage = run_remote_rusage;\n\t\n\t\t/*\n\t\t  we want to log the events from the perspective of the user\n\t\t  job, so if the shadow *sent* the bytes, then that means the\n\t\t  user job *received* the bytes\n\t\t*/\n\t\tjobAd->LookupFloat(ATTR_BYTES_SENT, event.recvd_bytes);\n\t\tjobAd->LookupFloat(ATTR_BYTES_RECVD, event.sent_bytes);\n\n\t\tevent.total_recvd_bytes = event.recvd_bytes;\n\t\tevent.total_sent_bytes = event.sent_bytes;\n\t\n\t\tif( exited_by_signal == TRUE ) {\n\t\t\tjobAd->LookupString(ATTR_JOB_CORE_FILENAME, corefile);\n\t\t\tevent.setCoreFile( corefile.Value() );\n\t\t}\n\n\t\tif (!uLog.writeEvent (&event,jobAd)) {\n\t\t\tdprintf (D_ALWAYS,\"Unable to log \"\n\t\t\t\t \t\"ULOG_JOB_TERMINATED event\\n\");\n\t\t\tEXCEPT(\"UserLog Unable to log ULOG_JOB_TERMINATED event\");\n\t\t}\n\n\t\treturn;\n\t}\n\n\n\trun_remote_rusage = getRUsage();\n\t\n\tif( exitedBySignal() ) {\n\t\tevent.normal = false;\n\t\tevent.signalNumber = exitSignal();\n\t} else {\n\t\tevent.normal = true;\n\t\tevent.returnValue = exitCode();\n\t}\n\n\tevent.run_remote_rusage = run_remote_rusage;\n\tevent.total_remote_rusage = run_remote_rusage;\n\t\n\t\t/*\n\t\t  we want to log the events from the perspective of the user\n\t\t  job, so if the shadow *sent* the bytes, then that means the\n\t\t  user job *received* the bytes\n\t\t*/\n\tevent.recvd_bytes = bytesSent();\n\tevent.sent_bytes = bytesReceived();\n\n\tevent.total_recvd_bytes = prev_run_bytes_recvd + bytesSent();\n\tevent.total_sent_bytes = prev_run_bytes_sent + bytesReceived();\n\t\n\tif( exitReason == JOB_COREDUMPED ) {\n\t\tevent.setCoreFile( core_file_name );\n\t}\n\t\n\tif (!uLog.writeEvent (&event,jobAd)) {\n\t\tdprintf (D_ALWAYS,\"Unable to log \"\n\t\t\t\t \"ULOG_JOB_TERMINATED event\\n\");\n\t\tEXCEPT(\"UserLog Unable to log ULOG_JOB_TERMINATED event\");\n\t}\n}\n", "target": 0, "idx": 16340}
{"func": "void DisplayItemList::removeLastDisplayItem()\n{\n    if (m_newDisplayItems.isEmpty())\n        return;\n\n#if ENABLE(ASSERT)\n    DisplayItemIndicesByClientMap::iterator it = m_newDisplayItemIndicesByClient.find(m_newDisplayItems.last().client());\n    if (it != m_newDisplayItemIndicesByClient.end()) {\n        Vector<size_t>& indices = it->value;\n        if (!indices.isEmpty() && indices.last() == (m_newDisplayItems.size() - 1))\n            indices.removeLast();\n     }\n #endif\n     m_newDisplayItems.removeLast();\n }\n", "target": 1, "idx": 185460}
{"func": "rotateContigSamples8bits(uint16 rotation, uint16 spp, uint16 bps, uint32 width, \n                         uint32 length,   uint32 col, uint8 *src, uint8 *dst)\n  {\n  int      ready_bits = 0;\n  uint32   src_byte = 0, src_bit = 0;\n  uint32   row, rowsize = 0, bit_offset = 0;\n  uint8    matchbits = 0, maskbits = 0;\n  uint8    buff1 = 0, buff2 = 0;\n  uint8   *next;\n  tsample_t sample;\n\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"rotateContigSamples8bits\",\"Invalid src or destination buffer\");\n    return (1);\n    }\n\n  rowsize = ((bps * spp * width) + 7) / 8;\n  ready_bits = 0;\n  maskbits =  (uint8)-1 >> ( 8 - bps);\n  buff1 = buff2 = 0;\n\n  for (row = 0; row < length ; row++)\n    {\n    bit_offset = col * bps * spp;\n    for (sample = 0; sample < spp; sample++)\n      {\n      if (sample == 0)\n        {\n        src_byte = bit_offset / 8;\n        src_bit  = bit_offset % 8;\n        }\n      else\n        {\n        src_byte = (bit_offset + (sample * bps)) / 8;\n        src_bit  = (bit_offset + (sample * bps)) % 8;\n        }\n\n      switch (rotation)\n\t{\n        case  90: next = src + src_byte - (row * rowsize);\n                  break;\n        case 270: next = src + src_byte + (row * rowsize);\n\t          break;\n\tdefault:  TIFFError(\"rotateContigSamples8bits\", \"Invalid rotation %d\", rotation);\n                  return (1);\n        }\n      matchbits = maskbits << (8 - src_bit - bps); \n      buff1 = ((*next) & matchbits) << (src_bit);\n\n       /* If we have a full buffer's worth, write it out */\n      if (ready_bits >= 8)\n        {\n        *dst++ = buff2;\n        buff2 = buff1;\n        ready_bits -= 8;\n        }\n      else\n        {\n        buff2 = (buff2 | (buff1 >> ready_bits));\n        }\n      ready_bits += bps;\n      }\n    }\n\n  if (ready_bits > 0)\n    {\n    buff1 = (buff2 & ((unsigned int)255 << (8 - ready_bits)));\n    *dst++ = buff1;\n    }\n\n  return (0);\n  }  /* end rotateContigSamples8bits */\n", "target": 0, "idx": 48282}
{"func": "SeekHead::SeekHead(\n    Segment* pSegment,\n    long long start,\n    long long size_,\n    long long element_start,\n    long long element_size) :\n    m_pSegment(pSegment),\n    m_start(start),\n    m_size(size_),\n    m_element_start(element_start),\n    m_element_size(element_size),\n    m_entries(0),\n    m_entry_count(0),\n    m_void_elements(0),\n    m_void_element_count(0)\n{\n }\n", "target": 1, "idx": 188459}
{"func": "void ass_shaper_find_runs(ASS_Shaper *shaper, ASS_Renderer *render_priv,\n                          GlyphInfo *glyphs, size_t len)\n{\n    int i;\n    int shape_run = 0;\n\n#ifdef CONFIG_HARFBUZZ\n    ass_shaper_determine_script(shaper, glyphs, len);\n#endif\n\n    for (i = 0; i < len; i++) {\n        GlyphInfo *last = glyphs + i - 1;\n        GlyphInfo *info = glyphs + i;\n        if (info->symbol == 0xfffc)\n            continue;\n        ass_font_get_index(render_priv->fontselect, info->font,\n                info->symbol, &info->face_index, &info->glyph_index);\n        if (i > 0 && (last->font != info->font ||\n                    last->face_index != info->face_index ||\n                    last->script != info->script ||\n                    last->font_size != info->font_size ||\n                    last->c[0] != info->c[0] ||\n                    last->c[1] != info->c[1] ||\n                    last->c[2] != info->c[2] ||\n                    last->c[3] != info->c[3] ||\n                    last->be != info->be ||\n                    last->blur != info->blur ||\n                    last->shadow_x != info->shadow_x ||\n                    last->shadow_y != info->shadow_y ||\n                    last->frx != info->frx ||\n                    last->fry != info->fry ||\n                    last->frz != info->frz ||\n                    last->fax != info->fax ||\n                    last->fay != info->fay ||\n                    last->scale_x != info->scale_x ||\n                    last->scale_y != info->scale_y ||\n                    last->border_style != info->border_style ||\n                    last->border_x != info->border_x ||\n                    last->border_y != info->border_y ||\n                    last->hspacing != info->hspacing ||\n                    last->italic != info->italic ||\n                    last->bold != info->bold ||\n                    last->flags != info->flags))\n            shape_run++;\n        info->shape_run_id = shape_run;\n    }\n}\n", "target": 0, "idx": 73275}
{"func": "static av_always_inline void mc_part_std(H264Context *h, int n, int square,\n                                         int height, int delta,\n                                         uint8_t *dest_y, uint8_t *dest_cb,\n                                         uint8_t *dest_cr,\n                                         int x_offset, int y_offset,\n                                         qpel_mc_func *qpix_put,\n                                         h264_chroma_mc_func chroma_put,\n                                         qpel_mc_func *qpix_avg,\n                                         h264_chroma_mc_func chroma_avg,\n                                         int list0, int list1,\n                                         int pixel_shift, int chroma_idc)\n{\n    qpel_mc_func *qpix_op         = qpix_put;\n    h264_chroma_mc_func chroma_op = chroma_put;\n\n    dest_y += (2 * x_offset << pixel_shift) + 2 * y_offset * h->mb_linesize;\n    if (chroma_idc == 3 /* yuv444 */) {\n        dest_cb += (2 * x_offset << pixel_shift) + 2 * y_offset * h->mb_linesize;\n        dest_cr += (2 * x_offset << pixel_shift) + 2 * y_offset * h->mb_linesize;\n    } else if (chroma_idc == 2 /* yuv422 */) {\n        dest_cb += (x_offset << pixel_shift) + 2 * y_offset * h->mb_uvlinesize;\n        dest_cr += (x_offset << pixel_shift) + 2 * y_offset * h->mb_uvlinesize;\n    } else { /* yuv420 */\n        dest_cb += (x_offset << pixel_shift) + y_offset * h->mb_uvlinesize;\n        dest_cr += (x_offset << pixel_shift) + y_offset * h->mb_uvlinesize;\n    }\n    x_offset += 8 * h->mb_x;\n    y_offset += 8 * (h->mb_y >> MB_FIELD(h));\n\n    if (list0) {\n        Picture *ref = &h->ref_list[0][h->ref_cache[0][scan8[n]]];\n        mc_dir_part(h, ref, n, square, height, delta, 0,\n                    dest_y, dest_cb, dest_cr, x_offset, y_offset,\n                    qpix_op, chroma_op, pixel_shift, chroma_idc);\n\n        qpix_op   = qpix_avg;\n        chroma_op = chroma_avg;\n    }\n\n    if (list1) {\n        Picture *ref = &h->ref_list[1][h->ref_cache[1][scan8[n]]];\n        mc_dir_part(h, ref, n, square, height, delta, 1,\n                    dest_y, dest_cb, dest_cr, x_offset, y_offset,\n                    qpix_op, chroma_op, pixel_shift, chroma_idc);\n    }\n}\n", "target": 0, "idx": 28262}
{"func": "event_filter_match(struct perf_event *event)\n{\n\treturn (event->cpu == -1 || event->cpu == smp_processor_id())\n\t    && perf_cgroup_match(event) && pmu_filter_match(event);\n}\n", "target": 0, "idx": 56041}
{"func": "image_transform_png_set_rgb_to_gray_mod(PNG_CONST image_transform *this,\n     image_pixel *that, png_const_structp pp,\n    PNG_CONST transform_display *display)\n {\n    if ((that->colour_type & PNG_COLOR_MASK_COLOR) != 0)\n    {\n       double gray, err;\n \n      if (that->colour_type == PNG_COLOR_TYPE_PALETTE)\n         image_pixel_convert_PLTE(that);\n \n       /* Image now has RGB channels... */\n #  if DIGITIZE\n       {\n         PNG_CONST png_modifier *pm = display->pm;\n          const unsigned int sample_depth = that->sample_depth;\n          const unsigned int calc_depth = (pm->assume_16_bit_calculations ? 16 :\n             sample_depth);\n         const unsigned int gamma_depth = (sample_depth == 16 ? 16 :\n            (pm->assume_16_bit_calculations ? PNG_MAX_GAMMA_8 : sample_depth));\n          int isgray;\n          double r, g, b;\n          double rlo, rhi, glo, ghi, blo, bhi, graylo, grayhi;\n\n /* Do this using interval arithmetic, otherwise it is too difficult to\n          * handle the errors correctly.\n          *\n          * To handle the gamma correction work out the upper and lower bounds\n          * of the digitized value.  Assume rounding here - normally the values\n\n           * will be identical after this operation if there is only one\n           * transform, feel free to delete the png_error checks on this below in\n           * the future (this is just me trying to ensure it works!)\n           */\n          r = rlo = rhi = that->redf;\n          rlo -= that->rede;\n         rlo = digitize(rlo, calc_depth, 1/*round*/);\n          rhi += that->rede;\n         rhi = digitize(rhi, calc_depth, 1/*round*/);\n \n          g = glo = ghi = that->greenf;\n          glo -= that->greene;\n         glo = digitize(glo, calc_depth, 1/*round*/);\n          ghi += that->greene;\n         ghi = digitize(ghi, calc_depth, 1/*round*/);\n \n          b = blo = bhi = that->bluef;\n          blo -= that->bluee;\n         blo = digitize(blo, calc_depth, 1/*round*/);\n         bhi += that->greene;\n         bhi = digitize(bhi, calc_depth, 1/*round*/);\n \n          isgray = r==g && g==b;\n \n          if (data.gamma != 1)\n          {\n            PNG_CONST double power = 1/data.gamma;\n            PNG_CONST double abse = calc_depth == 16 ? .5/65535 : .5/255;\n \n            /* 'abse' is the absolute error permitted in linear calculations. It\n             * is used here to capture the error permitted in the handling\n             * (undoing) of the gamma encoding.  Once again digitization occurs\n             * to handle the upper and lower bounds of the values.  This is\n             * where the real errors are introduced.\n              */\n             r = pow(r, power);\n            rlo = digitize(pow(rlo, power)-abse, calc_depth, 1);\n            rhi = digitize(pow(rhi, power)+abse, calc_depth, 1);\n \n             g = pow(g, power);\n            glo = digitize(pow(glo, power)-abse, calc_depth, 1);\n            ghi = digitize(pow(ghi, power)+abse, calc_depth, 1);\n \n             b = pow(b, power);\n            blo = digitize(pow(blo, power)-abse, calc_depth, 1);\n            bhi = digitize(pow(bhi, power)+abse, calc_depth, 1);\n          }\n \n          /* Now calculate the actual gray values.  Although the error in the\n           * coefficients depends on whether they were specified on the command\n           * line (in which case truncation to 15 bits happened) or not (rounding\n           * was used) the maxium error in an individual coefficient is always\n          * 1/32768, because even in the rounding case the requirement that\n           * coefficients add up to 32768 can cause a larger rounding error.\n           *\n           * The only time when rounding doesn't occur in 1.5.5 and later is when\n          * the non-gamma code path is used for less than 16 bit data.\n          */\n         gray = r * data.red_coefficient + g * data.green_coefficient +\n\n             b * data.blue_coefficient;\n \n          {\n            PNG_CONST int do_round = data.gamma != 1 || calc_depth == 16;\n            PNG_CONST double ce = 1. / 32768;\n \n            graylo = digitize(rlo * (data.red_coefficient-ce) +\n                glo * (data.green_coefficient-ce) +\n               blo * (data.blue_coefficient-ce), gamma_depth, do_round);\n            if (graylo <= 0)\n               graylo = 0;\n \n            grayhi = digitize(rhi * (data.red_coefficient+ce) +\n                ghi * (data.green_coefficient+ce) +\n               bhi * (data.blue_coefficient+ce), gamma_depth, do_round);\n            if (grayhi >= 1)\n               grayhi = 1;\n          }\n \n          /* And invert the gamma. */\n          if (data.gamma != 1)\n          {\n            PNG_CONST double power = data.gamma;\n \n             gray = pow(gray, power);\n            graylo = digitize(pow(graylo, power), sample_depth, 1);\n            grayhi = digitize(pow(grayhi, power), sample_depth, 1);\n          }\n \n          /* Now the error can be calculated.\n           *\n           * If r==g==b because there is no overall gamma correction libpng\n          * currently preserves the original value.\n          */\n if (isgray)\n            err = (that->rede + that->greene + that->bluee)/3;\n\n else\n {\n            err = fabs(grayhi-gray);\n if (fabs(gray - graylo) > err)\n               err = fabs(graylo-gray);\n\n /* Check that this worked: */\n if (err > pm->limit)\n {\n size_t pos = 0;\n char buffer[128];\n\n               pos = safecat(buffer, sizeof buffer, pos, \"rgb_to_gray error \");\n               pos = safecatd(buffer, sizeof buffer, pos, err, 6);\n               pos = safecat(buffer, sizeof buffer, pos, \" exceeds limit \");\n               pos = safecatd(buffer, sizeof buffer, pos, pm->limit, 6);\n               png_error(pp, buffer);\n }\n }\n }\n#  else  /* DIGITIZE */\n {\n double r = that->redf;\n double re = that->rede;\n double g = that->greenf;\n double ge = that->greene;\n\n          double b = that->bluef;\n          double be = that->bluee;\n \n         /* The true gray case involves no math. */\n         if (r == g && r == b)\n         {\n            gray = r;\n            err = re;\n            if (err < ge) err = ge;\n            if (err < be) err = be;\n         }\n \n         else if (data.gamma == 1)\n          {\n             /* There is no need to do the conversions to and from linear space,\n              * so the calculation should be a lot more accurate.  There is a\n             * built in 1/32768 error in the coefficients because they only have\n             * 15 bits and are adjusted to make sure they add up to 32768, so\n             * the result may have an additional error up to 1/32768.  (Note\n             * that adding the 1/32768 here avoids needing to increase the\n             * global error limits to take this into account.)\n              */\n             gray = r * data.red_coefficient + g * data.green_coefficient +\n                b * data.blue_coefficient;\n             err = re * data.red_coefficient + ge * data.green_coefficient +\n               be * data.blue_coefficient + 1./32768 + gray * 5 * DBL_EPSILON;\n          }\n \n          else\n {\n /* The calculation happens in linear space, and this produces much\n             * wider errors in the encoded space.  These are handled here by\n             * factoring the errors in to the calculation.  There are two table\n\n              * lookups in the calculation and each introduces a quantization\n              * error defined by the table size.\n              */\n            PNG_CONST png_modifier *pm = display->pm;\n             double in_qe = (that->sample_depth > 8 ? .5/65535 : .5/255);\n             double out_qe = (that->sample_depth > 8 ? .5/65535 :\n               (pm->assume_16_bit_calculations ? .5/(1<<PNG_MAX_GAMMA_8) :\n                .5/255));\n             double rhi, ghi, bhi, grayhi;\n             double g1 = 1/data.gamma;\n\n            rhi = r + re + in_qe; if (rhi > 1) rhi = 1;\n            r -= re + in_qe; if (r < 0) r = 0;\n            ghi = g + ge + in_qe; if (ghi > 1) ghi = 1;\n            g -= ge + in_qe; if (g < 0) g = 0;\n            bhi = b + be + in_qe; if (bhi > 1) bhi = 1;\n            b -= be + in_qe; if (b < 0) b = 0;\n\n            r = pow(r, g1)*(1-DBL_EPSILON); rhi = pow(rhi, g1)*(1+DBL_EPSILON);\n            g = pow(g, g1)*(1-DBL_EPSILON); ghi = pow(ghi, g1)*(1+DBL_EPSILON);\n            b = pow(b, g1)*(1-DBL_EPSILON); bhi = pow(bhi, g1)*(1+DBL_EPSILON);\n\n /* Work out the lower and upper bounds for the gray value in the\n             * encoded space, then work out an average and error.  Remove the\n\n              * previously added input quantization error at this point.\n              */\n             gray = r * data.red_coefficient + g * data.green_coefficient +\n               b * data.blue_coefficient - 1./32768 - out_qe;\n             if (gray <= 0)\n                gray = 0;\n             else\n {\n               gray *= (1 - 6 * DBL_EPSILON);\n               gray = pow(gray, data.gamma) * (1-DBL_EPSILON);\n\n             }\n \n             grayhi = rhi * data.red_coefficient + ghi * data.green_coefficient +\n               bhi * data.blue_coefficient + 1./32768 + out_qe;\n             grayhi *= (1 + 6 * DBL_EPSILON);\n             if (grayhi >= 1)\n                grayhi = 1;\n else\n               grayhi = pow(grayhi, data.gamma) * (1+DBL_EPSILON);\n\n            err = (grayhi - gray) / 2;\n            gray = (grayhi + gray) / 2;\n\n if (err <= in_qe)\n               err = gray * DBL_EPSILON;\n\n else\n               err -= in_qe;\n\n /* Validate that the error is within limits (this has caused\n             * problems before, it's much easier to detect them here.)\n             */\n if (err > pm->limit)\n {\n size_t pos = 0;\n char buffer[128];\n\n               pos = safecat(buffer, sizeof buffer, pos, \"rgb_to_gray error \");\n               pos = safecatd(buffer, sizeof buffer, pos, err, 6);\n               pos = safecat(buffer, sizeof buffer, pos, \" exceeds limit \");\n               pos = safecatd(buffer, sizeof buffer, pos, pm->limit, 6);\n               png_error(pp, buffer);\n }\n }\n }\n#  endif /* !DIGITIZE */\n\n      that->bluef = that->greenf = that->redf = gray;\n      that->bluee = that->greene = that->rede = err;\n\n /* The sBIT is the minium of the three colour channel sBITs. */\n if (that->red_sBIT > that->green_sBIT)\n         that->red_sBIT = that->green_sBIT;\n if (that->red_sBIT > that->blue_sBIT)\n         that->red_sBIT = that->blue_sBIT;\n      that->blue_sBIT = that->green_sBIT = that->red_sBIT;\n\n /* And remove the colour bit in the type: */\n if (that->colour_type == PNG_COLOR_TYPE_RGB)\n         that->colour_type = PNG_COLOR_TYPE_GRAY;\n else if (that->colour_type == PNG_COLOR_TYPE_RGB_ALPHA)\n         that->colour_type = PNG_COLOR_TYPE_GRAY_ALPHA;\n }\n\n this->next->mod(this->next, that, pp, display);\n}\n", "target": 1, "idx": 187665}
{"func": "MediaQueryList* LocalDOMWindow::matchMedia(const String& media) {\n  return document() ? document()->GetMediaQueryMatcher().MatchMedia(media)\n                    : nullptr;\n}\n", "target": 0, "idx": 136812}
{"func": "SYSCALL_DEFINE5(fchownat, int, dfd, const char __user *, filename, uid_t, user,\n\t\tgid_t, group, int, flag)\n{\n\tstruct path path;\n\tint error = -EINVAL;\n\tint lookup_flags;\n\n\tif ((flag & ~(AT_SYMLINK_NOFOLLOW | AT_EMPTY_PATH)) != 0)\n\t\tgoto out;\n\n\tlookup_flags = (flag & AT_SYMLINK_NOFOLLOW) ? 0 : LOOKUP_FOLLOW;\n\tif (flag & AT_EMPTY_PATH)\n\t\tlookup_flags |= LOOKUP_EMPTY;\nretry:\n\terror = user_path_at(dfd, filename, lookup_flags, &path);\n\tif (error)\n\t\tgoto out;\n\terror = mnt_want_write(path.mnt);\n\tif (error)\n\t\tgoto out_release;\n\terror = chown_common(&path, user, group);\n\tmnt_drop_write(path.mnt);\nout_release:\n\tpath_put(&path);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\nout:\n\treturn error;\n}\n", "target": 0, "idx": 46153}
{"func": "   void Wait() {\n    message_loop_runner_->Run();\n    message_loop_runner_ = new MessageLoopRunner;\n   }\n", "target": 1, "idx": 186696}
{"func": "bool Editor::CanRedo() {\n  return undo_stack_->CanRedo();\n}\n", "target": 0, "idx": 135528}
{"func": "static struct page *follow_pmd_mask(struct vm_area_struct *vma,\n\t\t\t\t    unsigned long address, pud_t *pudp,\n\t\t\t\t    unsigned int flags,\n\t\t\t\t    struct follow_page_context *ctx)\n{\n\tpmd_t *pmd, pmdval;\n\tspinlock_t *ptl;\n\tstruct page *page;\n\tstruct mm_struct *mm = vma->vm_mm;\n\n\tpmd = pmd_offset(pudp, address);\n\t/*\n\t * The READ_ONCE() will stabilize the pmdval in a register or\n\t * on the stack so that it will stop changing under the code.\n\t */\n\tpmdval = READ_ONCE(*pmd);\n\tif (pmd_none(pmdval))\n\t\treturn no_page_table(vma, flags);\n\tif (pmd_huge(pmdval) && vma->vm_flags & VM_HUGETLB) {\n\t\tpage = follow_huge_pmd(mm, address, pmd, flags);\n\t\tif (page)\n\t\t\treturn page;\n\t\treturn no_page_table(vma, flags);\n\t}\n\tif (is_hugepd(__hugepd(pmd_val(pmdval)))) {\n\t\tpage = follow_huge_pd(vma, address,\n\t\t\t\t      __hugepd(pmd_val(pmdval)), flags,\n\t\t\t\t      PMD_SHIFT);\n\t\tif (page)\n\t\t\treturn page;\n\t\treturn no_page_table(vma, flags);\n\t}\nretry:\n\tif (!pmd_present(pmdval)) {\n\t\tif (likely(!(flags & FOLL_MIGRATION)))\n\t\t\treturn no_page_table(vma, flags);\n\t\tVM_BUG_ON(thp_migration_supported() &&\n\t\t\t\t  !is_pmd_migration_entry(pmdval));\n\t\tif (is_pmd_migration_entry(pmdval))\n\t\t\tpmd_migration_entry_wait(mm, pmd);\n\t\tpmdval = READ_ONCE(*pmd);\n\t\t/*\n\t\t * MADV_DONTNEED may convert the pmd to null because\n\t\t * mmap_sem is held in read mode\n\t\t */\n\t\tif (pmd_none(pmdval))\n\t\t\treturn no_page_table(vma, flags);\n\t\tgoto retry;\n\t}\n\tif (pmd_devmap(pmdval)) {\n\t\tptl = pmd_lock(mm, pmd);\n\t\tpage = follow_devmap_pmd(vma, address, pmd, flags, &ctx->pgmap);\n\t\tspin_unlock(ptl);\n\t\tif (page)\n\t\t\treturn page;\n\t}\n\tif (likely(!pmd_trans_huge(pmdval)))\n\t\treturn follow_page_pte(vma, address, pmd, flags, &ctx->pgmap);\n\n\tif ((flags & FOLL_NUMA) && pmd_protnone(pmdval))\n\t\treturn no_page_table(vma, flags);\n\nretry_locked:\n\tptl = pmd_lock(mm, pmd);\n\tif (unlikely(pmd_none(*pmd))) {\n\t\tspin_unlock(ptl);\n\t\treturn no_page_table(vma, flags);\n\t}\n\tif (unlikely(!pmd_present(*pmd))) {\n\t\tspin_unlock(ptl);\n\t\tif (likely(!(flags & FOLL_MIGRATION)))\n\t\t\treturn no_page_table(vma, flags);\n\t\tpmd_migration_entry_wait(mm, pmd);\n\t\tgoto retry_locked;\n\t}\n\tif (unlikely(!pmd_trans_huge(*pmd))) {\n\t\tspin_unlock(ptl);\n\t\treturn follow_page_pte(vma, address, pmd, flags, &ctx->pgmap);\n\t}\n\tif (flags & FOLL_SPLIT) {\n\t\tint ret;\n\t\tpage = pmd_page(*pmd);\n\t\tif (is_huge_zero_page(page)) {\n\t\t\tspin_unlock(ptl);\n\t\t\tret = 0;\n\t\t\tsplit_huge_pmd(vma, pmd, address);\n \t\t\tif (pmd_trans_unstable(pmd))\n \t\t\t\tret = -EBUSY;\n \t\t} else {\n\t\t\tget_page(page);\n \t\t\tspin_unlock(ptl);\n \t\t\tlock_page(page);\n \t\t\tret = split_huge_page(page);\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tif (pmd_none(*pmd))\n\t\t\t\treturn no_page_table(vma, flags);\n\t\t}\n\n\t\treturn ret ? ERR_PTR(ret) :\n\t\t\tfollow_page_pte(vma, address, pmd, flags, &ctx->pgmap);\n\t}\n\tpage = follow_trans_huge_pmd(vma, address, pmd, flags);\n\tspin_unlock(ptl);\n\tctx->page_mask = HPAGE_PMD_NR - 1;\n\treturn page;\n}\n", "target": 1, "idx": 183395}
{"func": "   static void SetUpTestCase() {\n    input_ = reinterpret_cast<uint8_t*>(\n\n         vpx_memalign(kDataAlignment, kInputBufferSize + 1)) + 1;\n     output_ = reinterpret_cast<uint8_t*>(\n         vpx_memalign(kDataAlignment, kOutputBufferSize));\n   }\n", "target": 1, "idx": 188528}
{"func": " void VRDisplay::cancelAnimationFrame(int id) {\n   if (!scripted_animation_controller_)\n     return;\n   scripted_animation_controller_->CancelCallback(id);\n }\n", "target": 1, "idx": 185878}
{"func": " int do_adjtimex(struct timex *txc)\n {\n\tlong mtemp, save_adjust, rem;\n \ts64 freq_adj;\n \tint result;\n \n\t/* In order to modify anything, you gotta be super-user! */\n\tif (txc->modes && !capable(CAP_SYS_TIME))\n\t\treturn -EPERM;\n\n\t/* Now we validate the data before disabling interrupts */\n\n\tif ((txc->modes & ADJ_OFFSET_SINGLESHOT) == ADJ_OFFSET_SINGLESHOT) {\n\t  /* singleshot must not be used with any other mode bits */\n\t\tif (txc->modes != ADJ_OFFSET_SINGLESHOT &&\n\t\t\t\t\ttxc->modes != ADJ_OFFSET_SS_READ)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (txc->modes != ADJ_OFFSET_SINGLESHOT && (txc->modes & ADJ_OFFSET))\n\t  /* adjustment Offset limited to +- .512 seconds */\n\t\tif (txc->offset <= - MAXPHASE || txc->offset >= MAXPHASE )\n\t\t\treturn -EINVAL;\n\n\t/* if the quartz is off by more than 10% something is VERY wrong ! */\n\tif (txc->modes & ADJ_TICK)\n\t\tif (txc->tick <  900000/USER_HZ ||\n\t\t    txc->tick > 1100000/USER_HZ)\n\t\t\treturn -EINVAL;\n\n\twrite_seqlock_irq(&xtime_lock);\n\tresult = time_state;\t/* mostly `TIME_OK' */\n\n\t/* Save for later - semantics of adjtime is to return old value */\n\tsave_adjust = time_adjust;\n\n#if 0\t/* STA_CLOCKERR is never set yet */\n\ttime_status &= ~STA_CLOCKERR;\t\t/* reset STA_CLOCKERR */\n#endif\n\t/* If there are input parameters, then process them */\n\tif (txc->modes)\n\t{\n\t    if (txc->modes & ADJ_STATUS)\t/* only set allowed bits */\n\t\ttime_status =  (txc->status & ~STA_RONLY) |\n\t\t\t      (time_status & STA_RONLY);\n\n\t    if (txc->modes & ADJ_FREQUENCY) {\t/* p. 22 */\n\t\tif (txc->freq > MAXFREQ || txc->freq < -MAXFREQ) {\n\t\t    result = -EINVAL;\n\t\t    goto leave;\n\t\t}\n\t\ttime_freq = ((s64)txc->freq * NSEC_PER_USEC)\n\t\t\t\t>> (SHIFT_USEC - SHIFT_NSEC);\n\t    }\n\n\t    if (txc->modes & ADJ_MAXERROR) {\n\t\tif (txc->maxerror < 0 || txc->maxerror >= NTP_PHASE_LIMIT) {\n\t\t    result = -EINVAL;\n\t\t    goto leave;\n\t\t}\n\t\ttime_maxerror = txc->maxerror;\n\t    }\n\n\t    if (txc->modes & ADJ_ESTERROR) {\n\t\tif (txc->esterror < 0 || txc->esterror >= NTP_PHASE_LIMIT) {\n\t\t    result = -EINVAL;\n\t\t    goto leave;\n\t\t}\n\t\ttime_esterror = txc->esterror;\n\t    }\n\n\t    if (txc->modes & ADJ_TIMECONST) {\t/* p. 24 */\n\t\tif (txc->constant < 0) {\t/* NTP v4 uses values > 6 */\n\t\t    result = -EINVAL;\n\t\t    goto leave;\n\t\t}\n\t\ttime_constant = min(txc->constant + 4, (long)MAXTC);\n\t    }\n\n\t    if (txc->modes & ADJ_OFFSET) {\t/* values checked earlier */\n\t\tif (txc->modes == ADJ_OFFSET_SINGLESHOT) {\n\t\t    /* adjtime() is independent from ntp_adjtime() */\n\t\t    time_adjust = txc->offset;\n\t\t}\n\t\telse if (time_status & STA_PLL) {\n\t\t    time_offset = txc->offset * NSEC_PER_USEC;\n\n\t\t    /*\n\t\t     * Scale the phase adjustment and\n\t\t     * clamp to the operating range.\n\t\t     */\n\t\t    time_offset = min(time_offset, (s64)MAXPHASE * NSEC_PER_USEC);\n\t\t    time_offset = max(time_offset, (s64)-MAXPHASE * NSEC_PER_USEC);\n\n\t\t    /*\n\t\t     * Select whether the frequency is to be controlled\n\t\t     * and in which mode (PLL or FLL). Clamp to the operating\n\t\t     * range. Ugly multiply/divide should be replaced someday.\n\t\t     */\n\n\t\t    if (time_status & STA_FREQHOLD || time_reftime == 0)\n\t\t        time_reftime = xtime.tv_sec;\n\t\t    mtemp = xtime.tv_sec - time_reftime;\n\t\t    time_reftime = xtime.tv_sec;\n\n\t\t    freq_adj = time_offset * mtemp;\n\t\t    freq_adj = shift_right(freq_adj, time_constant * 2 +\n\t\t\t\t\t   (SHIFT_PLL + 2) * 2 - SHIFT_NSEC);\n\t\t    if (mtemp >= MINSEC && (time_status & STA_FLL || mtemp > MAXSEC))\n\t\t\tfreq_adj += div_s64(time_offset << (SHIFT_NSEC - SHIFT_FLL), mtemp);\n \t\t    freq_adj += time_freq;\n \t\t    freq_adj = min(freq_adj, (s64)MAXFREQ_NSEC);\n \t\t    time_freq = max(freq_adj, (s64)-MAXFREQ_NSEC);\n\t\t    time_offset = div_long_long_rem_signed(time_offset,\n\t\t\t\t\t\t\t   NTP_INTERVAL_FREQ,\n\t\t\t\t\t\t\t   &rem);\n \t\t    time_offset <<= SHIFT_UPDATE;\n \t\t} /* STA_PLL */\n \t    } /* txc->modes & ADJ_OFFSET */\n\t    if (txc->modes & ADJ_TICK)\n\t\ttick_usec = txc->tick;\n\n\t    if (txc->modes & (ADJ_TICK|ADJ_FREQUENCY|ADJ_OFFSET))\n\t\t    ntp_update_frequency();\n\t} /* txc->modes */\nleave:\tif ((time_status & (STA_UNSYNC|STA_CLOCKERR)) != 0)\n\t\tresult = TIME_ERROR;\n\n\tif ((txc->modes == ADJ_OFFSET_SINGLESHOT) ||\n\t\t\t(txc->modes == ADJ_OFFSET_SS_READ))\n\t\ttxc->offset = save_adjust;\n\telse\n\t\ttxc->offset = ((long)shift_right(time_offset, SHIFT_UPDATE)) *\n\t    \t\t\tNTP_INTERVAL_FREQ / 1000;\n\ttxc->freq\t   = (time_freq / NSEC_PER_USEC) <<\n\t\t\t\t(SHIFT_USEC - SHIFT_NSEC);\n\ttxc->maxerror\t   = time_maxerror;\n\ttxc->esterror\t   = time_esterror;\n\ttxc->status\t   = time_status;\n\ttxc->constant\t   = time_constant;\n\ttxc->precision\t   = 1;\n\ttxc->tolerance\t   = MAXFREQ;\n\ttxc->tick\t   = tick_usec;\n\n\t/* PPS is not implemented, so these are zero */\n\ttxc->ppsfreq\t   = 0;\n\ttxc->jitter\t   = 0;\n\ttxc->shift\t   = 0;\n\ttxc->stabil\t   = 0;\n\ttxc->jitcnt\t   = 0;\n\ttxc->calcnt\t   = 0;\n\ttxc->errcnt\t   = 0;\n\ttxc->stbcnt\t   = 0;\n\twrite_sequnlock_irq(&xtime_lock);\n\tdo_gettimeofday(&txc->time);\n\tnotify_cmos_timer();\n\treturn(result);\n}\n", "target": 1, "idx": 178929}
{"func": "int MockNetworkTransaction::RestartWithAuth(\n    const AuthCredentials& credentials,\n    const CompletionCallback& callback) {\n  if (!IsReadyToRestartForAuth())\n     return ERR_FAILED;\n \n   HttpRequestInfo auth_request_info = *request_;\n  auth_request_info.extra_headers.AddHeaderFromString(\"Authorization: Bar\");\n \n  return StartInternal(&auth_request_info, callback, BoundNetLog());\n}\n", "target": 1, "idx": 185304}
{"func": "log2vis_utf8 (PyObject * string, int unicode_length,\n\t      FriBidiParType base_direction, int clean, int reordernsm)\n{\n\tFriBidiChar *logical = NULL; /* input fribidi unicode buffer */\n\tFriBidiChar *visual = NULL;\t /* output fribidi unicode buffer */\n\tchar *visual_utf8 = NULL;    /* output fribidi UTF-8 buffer */\n\tFriBidiStrIndex new_len = 0; /* length of the UTF-8 buffer */\n\tPyObject *result = NULL;\t /* failure */\n\t/* Allocate fribidi unicode buffers */\n\tlogical = PyMem_New (FriBidiChar, unicode_length + 1);\n\tif (logical == NULL)\n\t{\n\t\tPyErr_SetString (PyExc_MemoryError,\n\t\t\t\t \"failed to allocate unicode buffer\");\n\t\tgoto cleanup;\n\t}\n\tvisual = PyMem_New (FriBidiChar, unicode_length + 1);\n\tif (visual == NULL)\n\t{\n\t\tPyErr_SetString (PyExc_MemoryError,\n\t\t\t\t \"failed to allocate unicode buffer\");\n\t\tgoto cleanup;\n\t}\n\t/* Convert to unicode and order visually */\n\tfribidi_set_reorder_nsm(reordernsm);\n\tfribidi_utf8_to_unicode (PyString_AS_STRING (string),\n\t\t\t\t PyString_GET_SIZE (string), logical);\n\tif (!fribidi_log2vis (logical, unicode_length, &base_direction, visual,\n\t\t\t      NULL, NULL, NULL))\n\t{\n\t\tPyErr_SetString (PyExc_RuntimeError,\n\t\t\t\t \"fribidi failed to order string\");\n\t\tgoto cleanup;\n\t}\n\t/* Cleanup the string if requested */\n\tif (clean)\n\t\tfribidi_remove_bidi_marks (visual, unicode_length, NULL, NULL, NULL);\n\t/* Allocate fribidi UTF-8 buffer */\n\tvisual_utf8 = PyMem_New(char, (unicode_length * 4)+1);\n\tif (visual_utf8 == NULL)\n\t{\n\t\tPyErr_SetString (PyExc_MemoryError,\n\t\t\t\t\"failed to allocate UTF-8 buffer\");\n\t\tgoto cleanup;\n\t}\n\t/* Encode the reordered string  and create result string */\n\tnew_len = fribidi_unicode_to_utf8 (visual, unicode_length, visual_utf8);\n\tresult = PyString_FromStringAndSize (visual_utf8, new_len);\n\tif (result == NULL)\n\t\t/* XXX does it raise any error? */\n\t\tgoto cleanup;\n      cleanup:\n\t/* Delete unicode buffers */\n\tPyMem_Del (logical);\n\tPyMem_Del (visual);\n\tPyMem_Del (visual_utf8);\n\treturn result;\n}\n", "target": 1, "idx": 178814}
{"func": "  ExtensionScriptAndCaptureVisibleTest()\n      : http_url(\"http://www.google.com\"),\n        http_url_with_path(\"http://www.google.com/index.html\"),\n        https_url(\"https://www.google.com\"),\n        example_com(\"https://example.com\"),\n        test_example_com(\"https://test.example.com\"),\n        sample_example_com(\"https://sample.example.com\"),\n        file_url(\"file:///foo/bar\"),\n        favicon_url(\"chrome://favicon/http://www.google.com\"),\n        extension_url(\"chrome-extension://\" +\n                       crx_file::id_util::GenerateIdForPath(\n                           base::FilePath(FILE_PATH_LITERAL(\"foo\")))),\n         settings_url(\"chrome://settings\"),\n        about_url(\"about:flags\") {\n     urls_.insert(http_url);\n     urls_.insert(http_url_with_path);\n     urls_.insert(https_url);\n    urls_.insert(example_com);\n    urls_.insert(test_example_com);\n    urls_.insert(sample_example_com);\n    urls_.insert(file_url);\n     urls_.insert(favicon_url);\n     urls_.insert(extension_url);\n     urls_.insert(settings_url);\n    urls_.insert(about_url);\n     PermissionsData::SetPolicyDelegate(NULL);\n   }\n", "target": 1, "idx": 187253}
{"func": "static void pmcraid_bist_done(struct pmcraid_cmd *cmd)\n{\n\tstruct pmcraid_instance *pinstance = cmd->drv_inst;\n\tunsigned long lock_flags;\n\tint rc;\n\tu16 pci_reg;\n\n\trc = pci_read_config_word(pinstance->pdev, PCI_COMMAND, &pci_reg);\n\n\t/* If PCI config space can't be accessed wait for another two secs */\n\tif ((rc != PCIBIOS_SUCCESSFUL || (!(pci_reg & PCI_COMMAND_MEMORY))) &&\n\t    cmd->time_left > 0) {\n\t\tpmcraid_info(\"BIST not complete, waiting another 2 secs\\n\");\n\t\tcmd->timer.expires = jiffies + cmd->time_left;\n\t\tcmd->time_left = 0;\n\t\tcmd->timer.data = (unsigned long)cmd;\n\t\tcmd->timer.function =\n\t\t\t(void (*)(unsigned long))pmcraid_bist_done;\n\t\tadd_timer(&cmd->timer);\n\t} else {\n\t\tcmd->time_left = 0;\n\t\tpmcraid_info(\"BIST is complete, proceeding with reset\\n\");\n\t\tspin_lock_irqsave(pinstance->host->host_lock, lock_flags);\n\t\tpmcraid_ioa_reset(cmd);\n\t\tspin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);\n\t}\n}\n", "target": 0, "idx": 26415}
{"func": "static int ip6mr_mfc_add(struct net *net, struct mr6_table *mrt,\n\t\t\t struct mf6cctl *mfc, int mrtsock, int parent)\n{\n\tbool found = false;\n\tint line;\n\tstruct mfc6_cache *uc, *c;\n\tunsigned char ttls[MAXMIFS];\n\tint i;\n\n\tif (mfc->mf6cc_parent >= MAXMIFS)\n\t\treturn -ENFILE;\n\n\tmemset(ttls, 255, MAXMIFS);\n\tfor (i = 0; i < MAXMIFS; i++) {\n\t\tif (IF_ISSET(i, &mfc->mf6cc_ifset))\n\t\t\tttls[i] = 1;\n\n\t}\n\n\tline = MFC6_HASH(&mfc->mf6cc_mcastgrp.sin6_addr, &mfc->mf6cc_origin.sin6_addr);\n\n\tlist_for_each_entry(c, &mrt->mfc6_cache_array[line], list) {\n\t\tif (ipv6_addr_equal(&c->mf6c_origin, &mfc->mf6cc_origin.sin6_addr) &&\n\t\t    ipv6_addr_equal(&c->mf6c_mcastgrp,\n\t\t\t\t    &mfc->mf6cc_mcastgrp.sin6_addr) &&\n\t\t    (parent == -1 || parent == mfc->mf6cc_parent)) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found) {\n\t\twrite_lock_bh(&mrt_lock);\n\t\tc->mf6c_parent = mfc->mf6cc_parent;\n\t\tip6mr_update_thresholds(mrt, c, ttls);\n\t\tif (!mrtsock)\n\t\t\tc->mfc_flags |= MFC_STATIC;\n\t\twrite_unlock_bh(&mrt_lock);\n\t\tmr6_netlink_event(mrt, c, RTM_NEWROUTE);\n\t\treturn 0;\n\t}\n\n\tif (!ipv6_addr_any(&mfc->mf6cc_mcastgrp.sin6_addr) &&\n\t    !ipv6_addr_is_multicast(&mfc->mf6cc_mcastgrp.sin6_addr))\n\t\treturn -EINVAL;\n\n\tc = ip6mr_cache_alloc();\n\tif (!c)\n\t\treturn -ENOMEM;\n\n\tc->mf6c_origin = mfc->mf6cc_origin.sin6_addr;\n\tc->mf6c_mcastgrp = mfc->mf6cc_mcastgrp.sin6_addr;\n\tc->mf6c_parent = mfc->mf6cc_parent;\n\tip6mr_update_thresholds(mrt, c, ttls);\n\tif (!mrtsock)\n\t\tc->mfc_flags |= MFC_STATIC;\n\n\twrite_lock_bh(&mrt_lock);\n\tlist_add(&c->list, &mrt->mfc6_cache_array[line]);\n\twrite_unlock_bh(&mrt_lock);\n\n\t/*\n\t *\tCheck to see if we resolved a queued list. If so we\n\t *\tneed to send on the frames and tidy up.\n\t */\n\tfound = false;\n\tspin_lock_bh(&mfc_unres_lock);\n\tlist_for_each_entry(uc, &mrt->mfc6_unres_queue, list) {\n\t\tif (ipv6_addr_equal(&uc->mf6c_origin, &c->mf6c_origin) &&\n\t\t    ipv6_addr_equal(&uc->mf6c_mcastgrp, &c->mf6c_mcastgrp)) {\n\t\t\tlist_del(&uc->list);\n\t\t\tatomic_dec(&mrt->cache_resolve_queue_len);\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (list_empty(&mrt->mfc6_unres_queue))\n\t\tdel_timer(&mrt->ipmr_expire_timer);\n\tspin_unlock_bh(&mfc_unres_lock);\n\n\tif (found) {\n\t\tip6mr_cache_resolve(net, mrt, uc, c);\n\t\tip6mr_cache_free(uc);\n\t}\n\tmr6_netlink_event(mrt, c, RTM_NEWROUTE);\n\treturn 0;\n}\n", "target": 0, "idx": 93535}
{"func": "poppler_page_get_thumbnail (PopplerPage *page)\n{\n  unsigned char *data;\n  int width, height, rowstride;\n  cairo_surface_t *surface;\n\n  g_return_val_if_fail (POPPLER_IS_PAGE (page), FALSE);\n\n  if (!page->page->loadThumb (&data, &width, &height, &rowstride))\n    return NULL;\n\n  surface = create_surface_from_thumbnail_data (data, width, height, rowstride);\n  gfree (data);\n  \n  return surface;\n}\n", "target": 0, "idx": 792}
{"func": "PHP_FUNCTION(mcrypt_create_iv)\n{\n\tchar *iv;\n\tlong source = RANDOM;\n\tlong size;\n\tint n = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l|l\", &size, &source) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (size <= 0 || size >= INT_MAX) {\n \t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Cannot create an IV with a size of less than 1 or greater than %d\", INT_MAX);\n \t\tRETURN_FALSE;\n \t}\n \tiv = ecalloc(size + 1, 1);\n \tif (source == RANDOM || source == URANDOM) {\n #if PHP_WIN32\n \t\t/* random/urandom equivalent on Windows */\n\t\tBYTE *iv_b = (BYTE *) iv;\n\t\tif (php_win32_get_random_bytes(iv_b, (size_t) size) == FAILURE){\n\t\t\tefree(iv);\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Could not gather sufficient random data\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tn = size;\n#else\n\t\tint    *fd = &MCG(fd[source]);\n\t\tsize_t read_bytes = 0;\n\n\t\tif (*fd < 0) {\n\t\t\t*fd = open(source == RANDOM ? \"/dev/random\" : \"/dev/urandom\", O_RDONLY);\n\t\t\tif (*fd < 0) {\n\t\t\t\tefree(iv);\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Cannot open source device\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t}\n\n\t\twhile (read_bytes < size) {\n\t\t\tn = read(*fd, iv + read_bytes, size - read_bytes);\n\t\t\tif (n < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tread_bytes += n;\n\t\t}\n\t\tn = read_bytes;\n\n\t\tif (n < size) {\n\t\t\tefree(iv);\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Could not gather sufficient random data\");\n\t\t\tRETURN_FALSE;\n\t\t}\n#endif\n\t} else {\n\t\tn = size;\n\t\twhile (size) {\n\t\t\tiv[--size] = (char) (255.0 * php_rand(TSRMLS_C) / RAND_MAX);\n\t\t}\n\t}\n\tRETURN_STRINGL(iv, n, 0);\n}\n", "target": 1, "idx": 180283}
{"func": "void ipmi_unregister_smi(struct ipmi_smi *intf)\n{\n\tstruct ipmi_smi_watcher *w;\n\tint intf_num = intf->intf_num, index;\n\n\tmutex_lock(&ipmi_interfaces_mutex);\n\tintf->intf_num = -1;\n\tintf->in_shutdown = true;\n\tlist_del_rcu(&intf->link);\n\tmutex_unlock(&ipmi_interfaces_mutex);\n\tsynchronize_srcu(&ipmi_interfaces_srcu);\n\n\t/* At this point no users can be added to the interface. */\n\n\t/*\n\t * Call all the watcher interfaces to tell them that\n\t * an interface is going away.\n\t */\n\tmutex_lock(&smi_watchers_mutex);\n\tlist_for_each_entry(w, &smi_watchers, link)\n\t\tw->smi_gone(intf_num);\n\tmutex_unlock(&smi_watchers_mutex);\n\n\tindex = srcu_read_lock(&intf->users_srcu);\n\twhile (!list_empty(&intf->users)) {\n\t\tstruct ipmi_user *user =\n\t\t\tcontainer_of(list_next_rcu(&intf->users),\n\t\t\t\t     struct ipmi_user, link);\n\n\t\t_ipmi_destroy_user(user);\n\t}\n\tsrcu_read_unlock(&intf->users_srcu, index);\n\n\tif (intf->handlers->shutdown)\n\t\tintf->handlers->shutdown(intf->send_info);\n\n\tcleanup_smi_msgs(intf);\n\n\tipmi_bmc_unregister(intf);\n\n\tcleanup_srcu_struct(&intf->users_srcu);\n\tkref_put(&intf->refcount, intf_free);\n}\n", "target": 0, "idx": 91298}
{"func": "static inline int vcc_writable(struct sock *sk)\n{\n\tstruct atm_vcc *vcc = atm_sk(sk);\n\n\treturn (vcc->qos.txtp.max_sdu +\n\t\tatomic_read(&sk->sk_wmem_alloc)) <= sk->sk_sndbuf;\n}\n", "target": 0, "idx": 30832}
{"func": "static void wakeup_softirqd(void)\n{\n\t/* Interrupts are disabled: no need to stop preemption */\n\tstruct task_struct *tsk = __this_cpu_read(ksoftirqd);\n\n\tif (tsk && tsk->state != TASK_RUNNING)\n\t\twake_up_process(tsk);\n}\n", "target": 0, "idx": 81229}
{"func": "bool CancelableSyncSocket::Shutdown() {\n  shutdown_event_.Signal();\n  return true;\n}\n", "target": 0, "idx": 119148}
{"func": "void MessageService::OpenChannelToNativeApp(\n    int source_process_id,\n    int source_routing_id,\n    int receiver_port_id,\n    const std::string& source_extension_id,\n    const std::string& native_app_name,\n    const std::string& channel_name,\n    const std::string& connect_message) {\n  content::RenderProcessHost* source =\n      content::RenderProcessHost::FromID(source_process_id);\n  if (!source)\n    return;\n\n  WebContents* source_contents = tab_util::GetWebContentsByID(\n      source_process_id, source_routing_id);\n\n   std::string tab_json = \"null\";\n   if (source_contents) {\n     scoped_ptr<DictionaryValue> tab_value(ExtensionTabUtil::CreateTabValue(\n        source_contents, ExtensionTabUtil::INCLUDE_PRIVACY_SENSITIVE_FIELDS));\n     base::JSONWriter::Write(tab_value.get(), &tab_json);\n   }\n \n  scoped_ptr<MessageChannel> channel(new MessageChannel());\n  channel->opener.reset(new ExtensionMessagePort(source, MSG_ROUTING_CONTROL,\n                                                 source_extension_id));\n\n  NativeMessageProcessHost::MessageType type =\n      channel_name == \"chrome.runtime.sendNativeMessage\" ?\n      NativeMessageProcessHost::TYPE_SEND_MESSAGE_REQUEST :\n      NativeMessageProcessHost::TYPE_CONNECT;\n\n  content::BrowserThread::PostTask(\n      content::BrowserThread::FILE,\n      FROM_HERE,\n      base::Bind(&NativeMessageProcessHost::Create,\n                 base::WeakPtr<NativeMessageProcessHost::Client>(\n                    weak_factory_.GetWeakPtr()),\n                 native_app_name, connect_message, receiver_port_id,\n                 type,\n                 base::Bind(&MessageService::FinalizeOpenChannelToNativeApp,\n                            weak_factory_.GetWeakPtr(),\n                            receiver_port_id,\n                            channel_name,\n                            base::Passed(&channel),\n                            tab_json)));\n}\n", "target": 1, "idx": 185145}
{"func": "void V8TestObject::TestObjectAttributeAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), \"Blink_TestObject_testObjectAttribute_Getter\");\n\n  test_object_v8_internal::TestObjectAttributeAttributeGetter(info);\n}\n", "target": 0, "idx": 147931}
{"func": "juniper_monitor_print(netdissect_options *ndo,\n                      const struct pcap_pkthdr *h, register const u_char *p)\n{\n        struct juniper_l2info_t l2info;\n        struct juniper_monitor_header {\n            uint8_t pkt_type;\n            uint8_t padding;\n            uint8_t iif[2];\n            uint8_t service_id[4];\n        };\n        const struct juniper_monitor_header *mh;\n\n        l2info.pictype = DLT_JUNIPER_MONITOR;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n\n         p+=l2info.header_len;\n         mh = (const struct juniper_monitor_header *)p;\n \n         if (ndo->ndo_eflag)\n             ND_PRINT((ndo, \"service-id %u, iif %u, pkt-type %u: \",\n                    EXTRACT_32BITS(&mh->service_id),\n                   EXTRACT_16BITS(&mh->iif),\n                   mh->pkt_type));\n\n        /* no proto field - lets guess by first byte of IP header*/\n         ip_heuristic_guess (ndo, p, l2info.length);\n \n         return l2info.header_len;\n }\n", "target": 1, "idx": 181090}
{"func": "static int isofs_readpages(struct file *file, struct address_space *mapping,\n\t\t\tstruct list_head *pages, unsigned nr_pages)\n{\n\treturn mpage_readpages(mapping, pages, nr_pages, isofs_get_block);\n}\n", "target": 0, "idx": 36108}
{"func": "static void ftrace_hash_rec_enable(struct ftrace_ops *ops,\n\t\t\t\t   int filter_hash)\n{\n\t__ftrace_hash_rec_update(ops, filter_hash, 1);\n}\n", "target": 0, "idx": 30164}
{"func": "  void DiscardAndActivateTest(DiscardReason reason) {\n    LifecycleUnit* background_lifecycle_unit = nullptr;\n    LifecycleUnit* foreground_lifecycle_unit = nullptr;\n    CreateTwoTabs(true /* focus_tab_strip */, &background_lifecycle_unit,\n                  &foreground_lifecycle_unit);\n    content::WebContents* initial_web_contents =\n        tab_strip_model_->GetWebContentsAt(0);\n\n     EXPECT_EQ(LifecycleUnitState::ACTIVE,\n               background_lifecycle_unit->GetState());\n    EXPECT_CALL(tab_observer_, OnDiscardedStateChange(testing::_, true));\n     background_lifecycle_unit->Discard(reason);\n    testing::Mock::VerifyAndClear(&tab_observer_);\n \n     TransitionFromPendingDiscardToDiscardedIfNeeded(reason,\n                                                     background_lifecycle_unit);\n\n    EXPECT_NE(initial_web_contents, tab_strip_model_->GetWebContentsAt(0));\n    EXPECT_FALSE(tab_strip_model_->GetWebContentsAt(0)\n                     ->GetController()\n                      .GetPendingEntry());\n \n    EXPECT_CALL(tab_observer_, OnDiscardedStateChange(testing::_, false));\n     tab_strip_model_->ActivateTabAt(0, true);\n    testing::Mock::VerifyAndClear(&tab_observer_);\n     EXPECT_EQ(LifecycleUnitState::ACTIVE,\n               background_lifecycle_unit->GetState());\n     EXPECT_TRUE(tab_strip_model_->GetWebContentsAt(0)\n                    ->GetController()\n                    .GetPendingEntry());\n  }\n", "target": 1, "idx": 186192}
{"func": "void LayerTreeHostImpl::AsValueWithFrameInto(\n    FrameData* frame,\n    base::trace_event::TracedValue* state) const {\n  if (this->pending_tree_) {\n    state->BeginDictionary(\"activation_state\");\n    ActivationStateAsValueInto(state);\n    state->EndDictionary();\n  }\n  MathUtil::AddToTracedValue(\"device_viewport_size\", device_viewport_size_,\n                             state);\n\n  std::vector<PrioritizedTile> prioritized_tiles;\n  active_tree_->GetAllPrioritizedTilesForTracing(&prioritized_tiles);\n  if (pending_tree_)\n    pending_tree_->GetAllPrioritizedTilesForTracing(&prioritized_tiles);\n\n  state->BeginArray(\"active_tiles\");\n  for (const auto& prioritized_tile : prioritized_tiles) {\n    state->BeginDictionary();\n    prioritized_tile.AsValueInto(state);\n    state->EndDictionary();\n  }\n  state->EndArray();\n\n  state->BeginDictionary(\"tile_manager_basic_state\");\n  tile_manager_.BasicStateAsValueInto(state);\n  state->EndDictionary();\n\n  state->BeginDictionary(\"active_tree\");\n  active_tree_->AsValueInto(state);\n  state->EndDictionary();\n  if (pending_tree_) {\n    state->BeginDictionary(\"pending_tree\");\n    pending_tree_->AsValueInto(state);\n    state->EndDictionary();\n  }\n  if (frame) {\n    state->BeginDictionary(\"frame\");\n    frame->AsValueInto(state);\n    state->EndDictionary();\n  }\n}\n", "target": 0, "idx": 149896}
{"func": "static void __net_exit tcp_sk_exit_batch(struct list_head *net_exit_list)\n{\n\tinet_twsk_purge(&tcp_hashinfo, &tcp_death_row, AF_INET);\n}\n", "target": 0, "idx": 19015}
{"func": "void ShelfBackgroundAnimator::GetTargetValues(\n    ShelfBackgroundType background_type,\n    AnimationValues* shelf_background_values) const {\n  auto darken_wallpaper = [&](int darkening_alpha) {\n    if (!wallpaper_controller_)\n      return kShelfDefaultBaseColor;\n    SkColor target_color =\n        wallpaper_controller_->GetProminentColor(GetShelfColorProfile());\n    if (target_color == kInvalidWallpaperColor)\n      return kShelfDefaultBaseColor;\n    return color_utils::GetResultingPaintColor(\n        SkColorSetA(kShelfDefaultBaseColor, darkening_alpha), target_color);\n  };\n\n  SkColor shelf_target_color = kShelfDefaultBaseColor;\n  switch (background_type) {\n    case SHELF_BACKGROUND_DEFAULT:\n    case SHELF_BACKGROUND_APP_LIST:\n    case SHELF_BACKGROUND_OVERVIEW:\n       shelf_target_color = darken_wallpaper(kShelfTranslucentColorDarkenAlpha);\n       break;\n     case SHELF_BACKGROUND_MAXIMIZED:\n    case SHELF_BACKGROUND_SPLIT_VIEW:\n       shelf_target_color = darken_wallpaper(kShelfOpaqueColorDarkenAlpha);\n       break;\n     case SHELF_BACKGROUND_OOBE:\n      shelf_target_color = SK_ColorTRANSPARENT;\n      break;\n    case SHELF_BACKGROUND_LOGIN:\n      shelf_target_color = SK_ColorTRANSPARENT;\n      break;\n    case SHELF_BACKGROUND_LOGIN_NONBLURRED_WALLPAPER:\n      shelf_target_color = login_constants::kDefaultBaseColor;\n      break;\n  }\n\n  shelf_background_values->SetTargetValues(SkColorSetA(\n      shelf_target_color, GetBackgroundAlphaValue(background_type)));\n}\n", "target": 1, "idx": 186042}
{"func": "bool Camera3Device::RequestThread::waitIfPaused() {\n status_t res;\n Mutex::Autolock l(mPauseLock);\n while (mDoPause) {\n if (mPaused == false) {\n            mPaused = true;\n            ALOGV(\"%s: RequestThread: Paused\", __FUNCTION__);\n            sp<StatusTracker> statusTracker = mStatusTracker.promote();\n if (statusTracker != 0) {\n                statusTracker->markComponentIdle(mStatusId, Fence::NO_FENCE);\n }\n }\n\n        res = mDoPauseSignal.waitRelative(mPauseLock, kRequestTimeout);\n if (res == TIMED_OUT || exitPending()) {\n return true;\n }\n }\n return false;\n}\n", "target": 0, "idx": 174290}
{"func": "static int efx_probe_all(struct efx_nic *efx)\n{\n\tint rc;\n\n\trc = efx_probe_nic(efx);\n\tif (rc) {\n\t\tnetif_err(efx, probe, efx->net_dev, \"failed to create NIC\\n\");\n\t\tgoto fail1;\n\t}\n\n\trc = efx_probe_port(efx);\n\tif (rc) {\n\t\tnetif_err(efx, probe, efx->net_dev, \"failed to create port\\n\");\n \t\tgoto fail2;\n \t}\n \n \tefx->rxq_entries = efx->txq_entries = EFX_DEFAULT_DMAQ_SIZE;\n \trc = efx_probe_channels(efx);\n \tif (rc)\n\t\tgoto fail3;\n\n\trc = efx_probe_filters(efx);\n\tif (rc) {\n\t\tnetif_err(efx, probe, efx->net_dev,\n\t\t\t  \"failed to create filter tables\\n\");\n\t\tgoto fail4;\n\t}\n\n\treturn 0;\n\n fail4:\n\tefx_remove_channels(efx);\n fail3:\n\tefx_remove_port(efx);\n fail2:\n\tefx_remove_nic(efx);\n fail1:\n\treturn rc;\n}\n", "target": 1, "idx": 178756}
{"func": "static Image *ReadARTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  MagickBooleanType\n    status;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  image->depth=1;\n  image->endian=MSBEndian;\n  (void) ReadBlobLSBShort(image);\n  image->columns=(size_t) ReadBlobLSBShort(image);\n  (void) ReadBlobLSBShort(image);\n  image->rows=(size_t) ReadBlobLSBShort(image);\n  if ((image->columns == 0) || (image->rows == 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  /*\n    Initialize image colormap.\n  */\n  if (AcquireImageColormap(image,2) == MagickFalse)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  if (image_info->ping != MagickFalse)\n    {\n       (void) CloseBlob(image);\n       return(GetFirstImageInList(image));\n     }\n   /*\n     Convert bi-level image to pixel packets.\n   */\n  SetImageColorspace(image,GRAYColorspace);\n  quantum_type=IndexQuantum;\n  quantum_info=AcquireQuantumInfo(image_info,image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  pixels=GetQuantumPixels(quantum_info);\n  length=GetQuantumExtent(image,quantum_info,quantum_type);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register PixelPacket\n      *restrict q;\n\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      break;\n    count=ReadBlob(image,length,pixels);\n    if (count != (ssize_t) length)\n      ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n    (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n      quantum_type,pixels,exception);\n    count=ReadBlob(image,(size_t) (-(ssize_t) length) & 0x01,pixels);\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  SetQuantumImageType(image,quantum_type);\n  quantum_info=DestroyQuantumInfo(quantum_info);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n", "target": 1, "idx": 181719}
{"func": "void SoftAMR::onQueueFilled(OMX_U32 /* portIndex */) {\n List<BufferInfo *> &inQueue = getPortQueue(0);\n List<BufferInfo *> &outQueue = getPortQueue(1);\n\n if (mSignalledError || mOutputPortSettingsChange != NONE) {\n return;\n }\n\n while (!inQueue.empty() && !outQueue.empty()) {\n BufferInfo *inInfo = *inQueue.begin();\n        OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;\n\n BufferInfo *outInfo = *outQueue.begin();\n        OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;\n\n if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {\n            inQueue.erase(inQueue.begin());\n            inInfo->mOwnedByUs = false;\n            notifyEmptyBufferDone(inHeader);\n\n            outHeader->nFilledLen = 0;\n            outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n\n            outQueue.erase(outQueue.begin());\n            outInfo->mOwnedByUs = false;\n            notifyFillBufferDone(outHeader);\n return;\n }\n\n if (inHeader->nFilledLen == 0) {\n            inInfo->mOwnedByUs = false;\n            inQueue.erase(inQueue.begin());\n            notifyEmptyBufferDone(inHeader);\n continue;\n }\n\n if (inHeader->nOffset == 0) {\n            mAnchorTimeUs = inHeader->nTimeStamp;\n            mNumSamplesOutput = 0;\n }\n\n const uint8_t *inputPtr = inHeader->pBuffer + inHeader->nOffset;\n int32_t numBytesRead;\n\n if (mMode == MODE_NARROW) {\n if (outHeader->nAllocLen < kNumSamplesPerFrameNB * sizeof(int16_t)) {\n                ALOGE(\"b/27662364: NB expected output buffer %zu bytes vs %u\",\n                       kNumSamplesPerFrameNB * sizeof(int16_t), outHeader->nAllocLen);\n                android_errorWriteLog(0x534e4554, \"27662364\");\n                notify(OMX_EventError, OMX_ErrorOverflow, 0, NULL);\n                mSignalledError = true;\n return;\n }\n\n int16 mode = ((inputPtr[0] >> 3) & 0x0f);\n size_t frameSize = WmfDecBytesPerFrame[mode] + 1;\n\n if (inHeader->nFilledLen < frameSize) {\n                ALOGE(\"b/27662364: expected %zu bytes vs %u\", frameSize, inHeader->nFilledLen);\n                notify(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);\n                mSignalledError = true;\n return;\n }\n\n            numBytesRead =\n AMRDecode(mState,\n (Frame_Type_3GPP)((inputPtr[0] >> 3) & 0x0f),\n (UWord8 *)&inputPtr[1],\n reinterpret_cast<int16_t *>(outHeader->pBuffer),\n                  MIME_IETF);\n\n if (numBytesRead == -1) {\n                ALOGE(\"PV AMR decoder AMRDecode() call failed\");\n\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                mSignalledError = true;\n\n return;\n }\n\n ++numBytesRead; // Include the frame type header byte.\n\n if (static_cast<size_t>(numBytesRead) > inHeader->nFilledLen) {\n\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                mSignalledError = true;\n\n return;\n }\n } else {\n if (outHeader->nAllocLen < kNumSamplesPerFrameWB * sizeof(int16_t)) {\n                ALOGE(\"b/27662364: WB expected output buffer %zu bytes vs %u\",\n                       kNumSamplesPerFrameWB * sizeof(int16_t), outHeader->nAllocLen);\n                android_errorWriteLog(0x534e4554, \"27662364\");\n                notify(OMX_EventError, OMX_ErrorOverflow, 0, NULL);\n                mSignalledError = true;\n return;\n }\n\n int16 mode = ((inputPtr[0] >> 3) & 0x0f);\n\n if (mode >= 10 && mode <= 13) {\n                ALOGE(\"encountered illegal frame type %d in AMR WB content.\",\n                      mode);\n\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                mSignalledError = true;\n\n return;\n }\n\n size_t frameSize = getFrameSize(mode);\n if (inHeader->nFilledLen < frameSize) {\n                ALOGE(\"b/27662364: expected %zu bytes vs %u\", frameSize, inHeader->nFilledLen);\n                notify(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);\n                mSignalledError = true;\n return;\n }\n\n int16_t *outPtr = (int16_t *)outHeader->pBuffer;\n\n if (mode >= 9) {\n                memset(outPtr, 0, kNumSamplesPerFrameWB * sizeof(int16_t));\n } else if (mode < 9) {\n int16 frameType;\n                RX_State_wb rx_state;\n                mime_unsorting(\n const_cast<uint8_t *>(&inputPtr[1]),\n                        mInputSampleBuffer,\n &frameType, &mode, 1, &rx_state);\n\n int16_t numSamplesOutput;\n                pvDecoder_AmrWb(\n                        mode, mInputSampleBuffer,\n                        outPtr,\n &numSamplesOutput,\n                        mDecoderBuf, frameType, mDecoderCookie);\n\n                CHECK_EQ((int)numSamplesOutput, (int)kNumSamplesPerFrameWB);\n\n for (int i = 0; i < kNumSamplesPerFrameWB; ++i) {\n /* Delete the 2 LSBs (14-bit output) */\n                    outPtr[i] &= 0xfffC;\n }\n }\n\n            numBytesRead = frameSize;\n }\n\n        inHeader->nOffset += numBytesRead;\n        inHeader->nFilledLen -= numBytesRead;\n\n        outHeader->nFlags = 0;\n        outHeader->nOffset = 0;\n\n if (mMode == MODE_NARROW) {\n            outHeader->nFilledLen = kNumSamplesPerFrameNB * sizeof(int16_t);\n\n            outHeader->nTimeStamp =\n                mAnchorTimeUs\n + (mNumSamplesOutput * 1000000ll) / kSampleRateNB;\n\n            mNumSamplesOutput += kNumSamplesPerFrameNB;\n } else {\n            outHeader->nFilledLen = kNumSamplesPerFrameWB * sizeof(int16_t);\n\n            outHeader->nTimeStamp =\n                mAnchorTimeUs\n + (mNumSamplesOutput * 1000000ll) / kSampleRateWB;\n\n            mNumSamplesOutput += kNumSamplesPerFrameWB;\n }\n\n if (inHeader->nFilledLen == 0) {\n            inInfo->mOwnedByUs = false;\n            inQueue.erase(inQueue.begin());\n            inInfo = NULL;\n            notifyEmptyBufferDone(inHeader);\n            inHeader = NULL;\n }\n\n        outInfo->mOwnedByUs = false;\n        outQueue.erase(outQueue.begin());\n        outInfo = NULL;\n        notifyFillBufferDone(outHeader);\n        outHeader = NULL;\n\n ++mInputBufferCount;\n }\n}\n", "target": 0, "idx": 177093}
{"func": "static int prepare_sdp_description(FFServerStream *stream, uint8_t **pbuffer,\n                                   struct in_addr my_ip)\n{\n    AVFormatContext *avc;\n    AVOutputFormat *rtp_format = av_guess_format(\"rtp\", NULL, NULL);\n    AVDictionaryEntry *entry = av_dict_get(stream->metadata, \"title\", NULL, 0);\n    int i;\n\n    *pbuffer = NULL;\n\n    avc =  avformat_alloc_context();\n    if (!avc || !rtp_format)\n        return -1;\n\n    avc->oformat = rtp_format;\n    av_dict_set(&avc->metadata, \"title\",\n                entry ? entry->value : \"No Title\", 0);\n    if (stream->is_multicast) {\n        snprintf(avc->filename, 1024, \"rtp://%s:%d?multicast=1?ttl=%d\",\n                 inet_ntoa(stream->multicast_ip),\n                 stream->multicast_port, stream->multicast_ttl);\n    } else\n        snprintf(avc->filename, 1024, \"rtp://0.0.0.0\");\n\n    for(i = 0; i < stream->nb_streams; i++) {\n        AVStream *st = avformat_new_stream(avc, NULL);\n        if (!st)\n            goto sdp_done;\n        avcodec_parameters_from_context(stream->streams[i]->codecpar, stream->streams[i]->codec);\n        unlayer_stream(st, stream->streams[i]);\n    }\n#define PBUFFER_SIZE 2048\n    *pbuffer = av_mallocz(PBUFFER_SIZE);\n    if (!*pbuffer)\n        goto sdp_done;\n    av_sdp_create(&avc, 1, *pbuffer, PBUFFER_SIZE);\n\n sdp_done:\n    av_freep(&avc->streams);\n    av_dict_free(&avc->metadata);\n    av_free(avc);\n\n    return *pbuffer ? strlen(*pbuffer) : AVERROR(ENOMEM);\n}\n", "target": 0, "idx": 70821}
{"func": "static inline int hpel_motion(MpegEncContext *s,\n                              uint8_t *dest, uint8_t *src,\n                              int src_x, int src_y,\n                              op_pixels_func *pix_op,\n                              int motion_x, int motion_y)\n{\n    int dxy = 0;\n    int emu = 0;\n\n    src_x += motion_x >> 1;\n    src_y += motion_y >> 1;\n\n    /* WARNING: do no forget half pels */\n    src_x = av_clip(src_x, -16, s->width); // FIXME unneeded for emu?\n    if (src_x != s->width)\n        dxy |= motion_x & 1;\n    src_y = av_clip(src_y, -16, s->height);\n    if (src_y != s->height)\n         dxy |= (motion_y & 1) << 1;\n     src += src_y * s->linesize + src_x;\n \n    if (s->unrestricted_mv) {\n        if ((unsigned)src_x > FFMAX(s->h_edge_pos - (motion_x & 1) - 8, 0) ||\n            (unsigned)src_y > FFMAX(s->v_edge_pos - (motion_y & 1) - 8, 0)) {\n            s->vdsp.emulated_edge_mc(s->sc.edge_emu_buffer, src,\n                                     s->linesize, s->linesize,\n                                     9, 9,\n                                     src_x, src_y, s->h_edge_pos,\n                                     s->v_edge_pos);\n            src = s->sc.edge_emu_buffer;\n            emu = 1;\n        }\n     }\n     pix_op[dxy](dest, src, s->linesize, 8);\n     return emu;\n    }\n", "target": 1, "idx": 178099}
{"func": "static Image *ReadLABELImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    geometry[MaxTextExtent],\n    *property;\n\n  const char\n    *label;\n\n  DrawInfo\n    *draw_info;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  TypeMetric\n    metrics;\n\n  size_t\n    height,\n    width;\n\n  /*\n    Initialize Image structure.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  (void) ResetImagePage(image,\"0x0+0+0\");\n  property=InterpretImageProperties(image_info,image,image_info->filename);\n  (void) SetImageProperty(image,\"label\",property);\n  property=DestroyString(property);\n  label=GetImageProperty(image,\"label\");\n  draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);\n  draw_info->text=ConstantString(label);\n  metrics.width=0;\n  metrics.ascent=0.0;\n  status=GetMultilineTypeMetrics(image,draw_info,&metrics);\n  if ((image->columns == 0) && (image->rows == 0))\n    {\n      image->columns=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);\n      image->rows=(size_t) floor(metrics.height+draw_info->stroke_width+0.5);\n    }\n  else\n    if ((strlen(label) > 0) &&\n        (((image->columns == 0) || (image->rows == 0)) ||\n         (fabs(image_info->pointsize) < MagickEpsilon)))\n      {\n        double\n          high,\n          low;\n\n        /*\n          Auto fit text into bounding box.\n        */\n        for ( ; ; draw_info->pointsize*=2.0)\n        {\n          (void) FormatLocaleString(geometry,MaxTextExtent,\"%+g%+g\",\n            -metrics.bounds.x1,metrics.ascent);\n          if (draw_info->gravity == UndefinedGravity)\n            (void) CloneString(&draw_info->geometry,geometry);\n          (void) GetMultilineTypeMetrics(image,draw_info,&metrics);\n          width=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);\n          height=(size_t) floor(metrics.height+draw_info->stroke_width+0.5);\n          if ((image->columns != 0) && (image->rows != 0))\n            {\n              if ((width >= image->columns) && (height >= image->rows))\n                break;\n            }\n          else\n            if (((image->columns != 0) && (width >= image->columns)) ||\n                ((image->rows != 0) && (height >= image->rows)))\n              break;\n        }\n        high=draw_info->pointsize;\n        for (low=1.0; (high-low) > 0.5; )\n        {\n          draw_info->pointsize=(low+high)/2.0;\n          (void) FormatLocaleString(geometry,MaxTextExtent,\"%+g%+g\",\n            -metrics.bounds.x1,metrics.ascent);\n          if (draw_info->gravity == UndefinedGravity)\n            (void) CloneString(&draw_info->geometry,geometry);\n          (void) GetMultilineTypeMetrics(image,draw_info,&metrics);\n          width=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);\n          height=(size_t) floor(metrics.height+draw_info->stroke_width+0.5);\n          if ((image->columns != 0) && (image->rows != 0))\n            {\n              if ((width < image->columns) && (height < image->rows))\n                low=draw_info->pointsize+0.5;\n              else\n                high=draw_info->pointsize-0.5;\n            }\n          else\n            if (((image->columns != 0) && (width < image->columns)) ||\n                ((image->rows != 0) && (height < image->rows)))\n              low=draw_info->pointsize+0.5;\n            else\n              high=draw_info->pointsize-0.5;\n        }\n        draw_info->pointsize=(low+high)/2.0-0.5;\n      }\n  status=GetMultilineTypeMetrics(image,draw_info,&metrics);\n  if (status == MagickFalse)\n    {\n      draw_info=DestroyDrawInfo(draw_info);\n      InheritException(exception,&image->exception);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (image->columns == 0)\n    image->columns=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);\n  if (image->columns == 0)\n    image->columns=(size_t) floor(draw_info->pointsize+draw_info->stroke_width+\n      0.5);\n  if (image->rows == 0)\n    image->rows=(size_t) floor(metrics.ascent-metrics.descent+\n      draw_info->stroke_width+0.5);\n  if (image->rows == 0)\n    image->rows=(size_t) floor(draw_info->pointsize+draw_info->stroke_width+\n      0.5);\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      draw_info=DestroyDrawInfo(draw_info);\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  if (SetImageBackgroundColor(image) == MagickFalse)\n    {\n      draw_info=DestroyDrawInfo(draw_info);\n      InheritException(exception,&image->exception);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Draw label.\n  */\n  (void) FormatLocaleString(geometry,MaxTextExtent,\"%+g%+g\",\n     draw_info->direction == RightToLeftDirection ? image->columns-\n     metrics.bounds.x2 : 0.0,draw_info->gravity == UndefinedGravity ?\n     metrics.ascent : 0.0);\n  draw_info->geometry=AcquireString(geometry);\n   status=AnnotateImage(image,draw_info);\n   if (image_info->pointsize == 0.0)\n     {\n      char\n        pointsize[MaxTextExtent];\n\n      (void) FormatLocaleString(pointsize,MaxTextExtent,\"%.20g\",\n        draw_info->pointsize);\n      (void) SetImageProperty(image,\"label:pointsize\",pointsize);\n    }\n  draw_info=DestroyDrawInfo(draw_info);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  return(GetFirstImageInList(image));\n}\n", "target": 1, "idx": 181695}
{"func": "void fdct8x8_ref(const int16_t *in, int16_t *out, int stride, int tx_type) {\n  vp9_fdct8x8_c(in, out, stride);\n }\n", "target": 1, "idx": 188586}
{"func": "xmlXPathCastNodeToString (xmlNodePtr node) {\nxmlChar *ret;\n    if ((ret = xmlNodeGetContent(node)) == NULL)\n\tret = xmlStrdup((const xmlChar *) \"\");\n    return(ret);\n}\n", "target": 0, "idx": 97584}
{"func": "void ScriptController::clearForClose(bool destroyGlobal)\n{\n    m_windowShell->clearForClose(destroyGlobal);\n    for (IsolatedWorldMap::iterator iter = m_isolatedWorlds.begin(); iter != m_isolatedWorlds.end(); ++iter)\n        iter->value->clearForClose(destroyGlobal);\n    V8GCController::hintForCollectGarbage();\n}\n", "target": 0, "idx": 119464}
{"func": "void NetworkActionPredictor::Shutdown() {\n  db_->OnPredictorDestroyed();\n}\n", "target": 0, "idx": 114710}
{"func": " void ChromeMockRenderThread::OnDidPrintPage(\n     const PrintHostMsg_DidPrintPage_Params& params) {\n  if (printer_.get())\n    printer_->PrintPage(params);\n }\n", "target": 1, "idx": 184424}
{"func": "pdf_process_extgstate(fz_context *ctx, pdf_processor *proc, pdf_csi *csi, pdf_obj *dict)\n{\n\tpdf_obj *obj;\n\n\tobj = pdf_dict_get(ctx, dict, PDF_NAME_LW);\n\tif (pdf_is_number(ctx, obj) && proc->op_w)\n\t\tproc->op_w(ctx, proc, pdf_to_real(ctx, obj));\n\n\tobj = pdf_dict_get(ctx, dict, PDF_NAME_LC);\n\tif (pdf_is_int(ctx, obj) && proc->op_J)\n\t\tproc->op_J(ctx, proc, fz_clampi(pdf_to_int(ctx, obj), 0, 2));\n\n\tobj = pdf_dict_get(ctx, dict, PDF_NAME_LJ);\n\tif (pdf_is_int(ctx, obj) && proc->op_j)\n\t\tproc->op_j(ctx, proc, fz_clampi(pdf_to_int(ctx, obj), 0, 2));\n\n\tobj = pdf_dict_get(ctx, dict, PDF_NAME_ML);\n\tif (pdf_is_number(ctx, obj) && proc->op_M)\n\t\tproc->op_M(ctx, proc, pdf_to_real(ctx, obj));\n\n\tobj = pdf_dict_get(ctx, dict, PDF_NAME_D);\n\tif (pdf_is_array(ctx, obj) && proc->op_d)\n\t{\n\t\tpdf_obj *dash_array = pdf_array_get(ctx, obj, 0);\n\t\tpdf_obj *dash_phase = pdf_array_get(ctx, obj, 1);\n\t\tproc->op_d(ctx, proc, dash_array, pdf_to_real(ctx, dash_phase));\n\t}\n\n\tobj = pdf_dict_get(ctx, dict, PDF_NAME_RI);\n\tif (pdf_is_name(ctx, obj) && proc->op_ri)\n\t\tproc->op_ri(ctx, proc, pdf_to_name(ctx, obj));\n\n\tobj = pdf_dict_get(ctx, dict, PDF_NAME_FL);\n\tif (pdf_is_number(ctx, obj) && proc->op_i)\n\t\tproc->op_i(ctx, proc, pdf_to_real(ctx, obj));\n\n\tobj = pdf_dict_get(ctx, dict, PDF_NAME_Font);\n\tif (pdf_is_array(ctx, obj) && proc->op_Tf)\n\t{\n\t\tpdf_obj *font_ref = pdf_array_get(ctx, obj, 0);\n\t\tpdf_obj *font_size = pdf_array_get(ctx, obj, 1);\n\t\tpdf_font_desc *font = load_font_or_hail_mary(ctx, csi->doc, csi->rdb, font_ref, 0, csi->cookie);\n\t\tfz_try(ctx)\n\t\t\tproc->op_Tf(ctx, proc, \"ExtGState\", font, pdf_to_real(ctx, font_size));\n\t\tfz_always(ctx)\n\t\t\tpdf_drop_font(ctx, font);\n\t\tfz_catch(ctx)\n\t\t\tfz_rethrow(ctx);\n\t}\n\n\t/* overprint and color management */\n\n\tobj = pdf_dict_get(ctx, dict, PDF_NAME_OP);\n\tif (pdf_is_bool(ctx, obj) && proc->op_gs_OP)\n\t\tproc->op_gs_OP(ctx, proc, pdf_to_bool(ctx, obj));\n\n\tobj = pdf_dict_get(ctx, dict, PDF_NAME_op);\n\tif (pdf_is_bool(ctx, obj) && proc->op_gs_op)\n\t\tproc->op_gs_op(ctx, proc, pdf_to_bool(ctx, obj));\n\n\tobj = pdf_dict_get(ctx, dict, PDF_NAME_OPM);\n\tif (pdf_is_int(ctx, obj) && proc->op_gs_OPM)\n\t\tproc->op_gs_OPM(ctx, proc, pdf_to_int(ctx, obj));\n\n\tobj = pdf_dict_get(ctx, dict, PDF_NAME_UseBlackPtComp);\n\tif (pdf_is_name(ctx, obj) && proc->op_gs_UseBlackPtComp)\n\t\tproc->op_gs_UseBlackPtComp(ctx, proc, obj);\n\n\t/* transfer functions */\n\n\tobj = pdf_dict_get(ctx, dict, PDF_NAME_TR2);\n\tif (pdf_is_name(ctx, obj))\n\t\tif (!pdf_name_eq(ctx, obj, PDF_NAME_Identity) && !pdf_name_eq(ctx, obj, PDF_NAME_Default))\n\t\t\tfz_warn(ctx, \"ignoring transfer function\");\n\tif (!obj) /* TR is ignored in the presence of TR2 */\n\t{\n\t\tpdf_obj *tr = pdf_dict_get(ctx, dict, PDF_NAME_TR);\n\t\tif (pdf_is_name(ctx, tr))\n\t\t\tif (!pdf_name_eq(ctx, tr, PDF_NAME_Identity))\n\t\t\t\tfz_warn(ctx, \"ignoring transfer function\");\n\t}\n\n\t/* transparency state */\n\n\tobj = pdf_dict_get(ctx, dict, PDF_NAME_CA);\n\tif (pdf_is_number(ctx, obj) && proc->op_gs_CA)\n\t\tproc->op_gs_CA(ctx, proc, pdf_to_real(ctx, obj));\n\n\tobj = pdf_dict_get(ctx, dict, PDF_NAME_ca);\n\tif (pdf_is_number(ctx, obj) && proc->op_gs_ca)\n\t\tproc->op_gs_ca(ctx, proc, pdf_to_real(ctx, obj));\n\n\tobj = pdf_dict_get(ctx, dict, PDF_NAME_BM);\n\tif (pdf_is_array(ctx, obj))\n\t\tobj = pdf_array_get(ctx, obj, 0);\n\tif (pdf_is_name(ctx, obj) && proc->op_gs_BM)\n\t\tproc->op_gs_BM(ctx, proc, pdf_to_name(ctx, obj));\n\n\tobj = pdf_dict_get(ctx, dict, PDF_NAME_SMask);\n\tif (proc->op_gs_SMask)\n\t{\n\t\tif (pdf_is_dict(ctx, obj))\n\t\t{\n\t\t\tpdf_xobject *xobj;\n\t\t\tpdf_obj *group, *s, *bc, *tr;\n\t\t\tfloat softmask_bc[FZ_MAX_COLORS];\n\t\t\tfz_colorspace *colorspace;\n\t\t\tint colorspace_n = 1;\n\t\t\tint k, luminosity;\n\n                        fz_var(xobj);\n \n                        group = pdf_dict_get(ctx, obj, PDF_NAME_G);\n                       if (!group)\n                               fz_throw(ctx, FZ_ERROR_SYNTAX, \"cannot load softmask xobject (%d 0 R)\", pdf_to_num(ctx, obj));\n                        xobj = pdf_load_xobject(ctx, csi->doc, group);\n \n\n\t\t\tfz_try(ctx)\n\t\t\t{\n\t\t\t\tcolorspace = pdf_xobject_colorspace(ctx, xobj);\n\t\t\t\tif (colorspace)\n\t\t\t\t\tcolorspace_n = fz_colorspace_n(ctx, colorspace);\n\n\t\t\t\t/* Default background color is black. */\n\t\t\t\tfor (k = 0; k < colorspace_n; k++)\n\t\t\t\t\tsoftmask_bc[k] = 0;\n\t\t\t\t/* Which in CMYK means not all zeros! This should really be\n\t\t\t\t * a test for subtractive color spaces, but this will have\n\t\t\t\t * to do for now. */\n\t\t\t\tif (fz_colorspace_is_cmyk(ctx, colorspace))\n\t\t\t\t\tsoftmask_bc[3] = 1.0f;\n\t\t\t\tfz_drop_colorspace(ctx, colorspace);\n\n\t\t\t\tbc = pdf_dict_get(ctx, obj, PDF_NAME_BC);\n\t\t\t\tif (pdf_is_array(ctx, bc))\n\t\t\t\t{\n\t\t\t\t\tfor (k = 0; k < colorspace_n; k++)\n\t\t\t\t\t\tsoftmask_bc[k] = pdf_to_real(ctx, pdf_array_get(ctx, bc, k));\n\t\t\t\t}\n\n\t\t\t\ts = pdf_dict_get(ctx, obj, PDF_NAME_S);\n\t\t\t\tif (pdf_name_eq(ctx, s, PDF_NAME_Luminosity))\n\t\t\t\t\tluminosity = 1;\n\t\t\t\telse\n\t\t\t\t\tluminosity = 0;\n\n\t\t\t\ttr = pdf_dict_get(ctx, obj, PDF_NAME_TR);\n\t\t\t\tif (tr && !pdf_name_eq(ctx, tr, PDF_NAME_Identity))\n\t\t\t\t\tfz_warn(ctx, \"ignoring transfer function\");\n\n\t\t\t\tproc->op_gs_SMask(ctx, proc, xobj, csi->rdb, softmask_bc, luminosity);\n\t\t\t}\n\t\t\tfz_always(ctx)\n\t\t\t{\n\t\t\t\tpdf_drop_xobject(ctx, xobj);\n\t\t\t}\n\t\t\tfz_catch(ctx)\n\t\t\t{\n\t\t\t\tfz_rethrow(ctx);\n\t\t\t}\n\t\t}\n\t\telse if (pdf_is_name(ctx, obj) && pdf_name_eq(ctx, obj, PDF_NAME_None))\n\t\t{\n\t\t\tproc->op_gs_SMask(ctx, proc, NULL, NULL, NULL, 0);\n\t\t}\n\t}\n}\n", "target": 1, "idx": 177753}
{"func": "bool PermissionsData::CanRunOnPage(const Extension* extension,\n                                   const GURL& document_url,\n                                   const GURL& top_frame_url,\n                                   int tab_id,\n                                   int process_id,\n                                   const URLPatternSet& permitted_url_patterns,\n                                   std::string* error) const {\n  if (g_policy_delegate &&\n      !g_policy_delegate->CanExecuteScriptOnPage(\n          extension, document_url, top_frame_url, tab_id, process_id, error)) {\n     return false;\n   }\n \n  bool can_execute_everywhere = CanExecuteScriptEverywhere(extension);\n  if (!can_execute_everywhere &&\n      !ExtensionsClient::Get()->IsScriptableURL(document_url, error)) {\n    return false;\n  }\n  if (!base::CommandLine::ForCurrentProcess()->HasSwitch(\n          switches::kExtensionsOnChromeURLs)) {\n    if (document_url.SchemeIs(content::kChromeUIScheme) &&\n        !can_execute_everywhere) {\n      if (error)\n        *error = manifest_errors::kCannotAccessChromeUrl;\n      return false;\n    }\n  }\n  if (top_frame_url.SchemeIs(kExtensionScheme) &&\n      top_frame_url.GetOrigin() !=\n          Extension::GetBaseURLFromExtensionId(extension->id()).GetOrigin() &&\n      !can_execute_everywhere) {\n    if (error)\n      *error = manifest_errors::kCannotAccessExtensionUrl;\n     return false;\n  }\n \n   if (HasTabSpecificPermissionToExecuteScript(tab_id, top_frame_url))\n     return true;\n\n  bool can_access = permitted_url_patterns.MatchesURL(document_url);\n\n  if (!can_access && error) {\n    *error = ErrorUtils::FormatErrorMessage(manifest_errors::kCannotAccessPage,\n                                            document_url.spec());\n  }\n\n  return can_access;\n}\n", "target": 1, "idx": 185359}
{"func": "static int nft_flush_table(struct nft_ctx *ctx)\n{\n\tint err;\n \tstruct nft_chain *chain, *nc;\n \tstruct nft_set *set, *ns;\n \n\tlist_for_each_entry_safe(chain, nc, &ctx->table->chains, list) {\n \t\tctx->chain = chain;\n \n \t\terr = nft_delrule_by_chain(ctx);\n \t\tif (err < 0)\n \t\t\tgoto out;\n\t\terr = nft_delchain(ctx);\n\t\tif (err < 0)\n\t\t\tgoto out;\n \t}\n \n \tlist_for_each_entry_safe(set, ns, &ctx->table->sets, list) {\n\t\tif (set->flags & NFT_SET_ANONYMOUS &&\n\t\t    !list_empty(&set->bindings))\n\t\t\tcontinue;\n\n\t\terr = nft_delset(ctx, set);\n\t\tif (err < 0)\n \t\t\tgoto out;\n \t}\n \n \terr = nft_deltable(ctx);\n out:\n \treturn err;\n}\n", "target": 1, "idx": 180744}
{"func": "TabContents* Browser::OpenApplicationWindow(\n    Profile* profile,\n    const Extension* extension,\n    extension_misc::LaunchContainer container,\n    const GURL& url_input,\n    Browser** app_browser) {\n  GURL url;\n  if (!url_input.is_empty()) {\n    if (extension)\n      DCHECK(extension->web_extent().ContainsURL(url_input));\n    url = url_input;\n  } else {\n    DCHECK(extension);  // Empty url and no extension.  Nothing to open.\n    url = extension->GetFullLaunchURL();\n  }\n\n  std::string app_name;\n  if (extension)\n    app_name =\n        web_app::GenerateApplicationNameFromExtensionId(extension->id());\n  else\n    app_name = web_app::GenerateApplicationNameFromURL(url);\n\n  RegisterAppPrefs(app_name, profile);\n\n  bool as_panel = extension && (container == extension_misc::LAUNCH_PANEL);\n\n  gfx::Size window_size;\n  if (extension)\n    window_size.SetSize(extension->launch_width(),\n                        extension->launch_height());\n\n  Browser* browser = Browser::CreateForApp(app_name, window_size, profile,\n                                           as_panel);\n\n  if (app_browser)\n    *app_browser = browser;\n\n  TabContentsWrapper* wrapper =\n      browser->AddSelectedTabWithURL(url, PageTransition::START_PAGE);\n  TabContents* contents = wrapper->tab_contents();\n  contents->GetMutableRendererPrefs()->can_accept_load_drops = false;\n  contents->render_view_host()->SyncRendererPrefs();\n  browser->window()->Show();\n\n  contents->view()->SetInitialFocus();\n  return contents;\n}\n", "target": 0, "idx": 103142}
{"func": "void AutofillManager::FillOrPreviewProfileForm(\n    AutofillDriver::RendererFormDataAction action,\n    int query_id,\n    const FormData& form,\n    const FormFieldData& field,\n    const AutofillProfile& profile) {\n  FormStructure* form_structure = nullptr;\n  AutofillField* autofill_field = nullptr;\n  if (!GetCachedFormAndField(form, field, &form_structure, &autofill_field))\n    return;\n  if (action == AutofillDriver::FORM_DATA_ACTION_FILL) {\n    address_form_event_logger_->OnDidFillSuggestion(profile, *form_structure,\n                                                    *autofill_field);\n\n    if (base::FeatureList::IsEnabled(features::kAutofillDynamicForms) &&\n        !form_structure->GetIdentifierForRefill().empty()) {\n      auto& entry =\n          filling_contexts_map_[form_structure->GetIdentifierForRefill()];\n      auto filling_context = std::make_unique<FillingContext>();\n      filling_context->temp_data_model = profile;\n      filling_context->filled_field_name = autofill_field->unique_name();\n      filling_context->original_fill_time = base::TimeTicks::Now();\n      entry = std::move(filling_context);\n    }\n  }\n\n  FillOrPreviewDataModelForm(\n      action, query_id, form, field, profile, /*is_credit_card=*/false,\n      /*cvc=*/base::string16(), form_structure, autofill_field);\n}\n", "target": 0, "idx": 168040}
{"func": "handle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks)\n{\n\tjournal_t *journal;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn ERR_PTR(-EROFS);\n\n\t/* Special case here: if the journal has aborted behind our\n\t * backs (eg. EIO in the commit thread), then we still need to\n\t * take the FS itself readonly cleanly. */\n\tjournal = EXT3_SB(sb)->s_journal;\n\tif (is_journal_aborted(journal)) {\n\t\text3_abort(sb, __func__,\n\t\t\t   \"Detected aborted journal\");\n\t\treturn ERR_PTR(-EROFS);\n\t}\n\n\treturn journal_start(journal, nblocks);\n}\n", "target": 0, "idx": 32932}
{"func": "static int scan(Scanner *s)\n{\n\tuchar *cursor = s->cur;\n\tchar *str, *ptr = NULL;\n\t\t\nstd:\n\ts->tok = cursor;\n\ts->len = 0;\n#line 311 \"ext/date/lib/parse_iso_intervals.re\"\n\n\n\n#line 291 \"ext/date/lib/parse_iso_intervals.c\"\n{\n\tYYCTYPE yych;\n\tunsigned int yyaccept = 0;\n\tstatic const unsigned char yybm[] = {\n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t128, 128, 128, 128, 128, 128, 128, 128, \n\t\t128, 128,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t};\n\n\tYYDEBUG(0, *YYCURSOR);\n\tif ((YYLIMIT - YYCURSOR) < 20) YYFILL(20);\n\tyych = *YYCURSOR;\n\tif (yych <= ',') {\n\t\tif (yych <= '\\n') {\n\t\t\tif (yych <= 0x00) goto yy9;\n\t\t\tif (yych <= 0x08) goto yy11;\n\t\t\tif (yych <= '\\t') goto yy7;\n\t\t\tgoto yy9;\n\t\t} else {\n\t\t\tif (yych == ' ') goto yy7;\n\t\t\tif (yych <= '+') goto yy11;\n\t\t\tgoto yy7;\n\t\t}\n\t} else {\n\t\tif (yych <= 'O') {\n\t\t\tif (yych <= '-') goto yy11;\n\t\t\tif (yych <= '/') goto yy7;\n\t\t\tif (yych <= '9') goto yy4;\n\t\t\tgoto yy11;\n\t\t} else {\n\t\t\tif (yych <= 'P') goto yy5;\n\t\t\tif (yych != 'R') goto yy11;\n\t\t}\n\t}\n\tYYDEBUG(2, *YYCURSOR);\n\t++YYCURSOR;\n\tif ((yych = *YYCURSOR) <= '/') goto yy3;\n\tif (yych <= '9') goto yy98;\nyy3:\n\tYYDEBUG(3, *YYCURSOR);\n#line 424 \"ext/date/lib/parse_iso_intervals.re\"\n\t{\n\t\tadd_error(s, \"Unexpected character\");\n\t\tgoto std;\n\t}\n#line 366 \"ext/date/lib/parse_iso_intervals.c\"\nyy4:\n\tYYDEBUG(4, *YYCURSOR);\n\tyyaccept = 0;\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych <= '/') goto yy3;\n\tif (yych <= '9') goto yy59;\n\tgoto yy3;\nyy5:\n\tYYDEBUG(5, *YYCURSOR);\n\tyyaccept = 1;\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych <= '/') goto yy6;\n\tif (yych <= '9') goto yy12;\n\tif (yych == 'T') goto yy14;\nyy6:\n\tYYDEBUG(6, *YYCURSOR);\n#line 351 \"ext/date/lib/parse_iso_intervals.re\"\n\t{\n\t\ttimelib_sll nr;\n\t\tint         in_time = 0;\n\t\tDEBUG_OUTPUT(\"period\");\n\t\tTIMELIB_INIT;\n\t\tptr++;\n\t\tdo {\n\t\t\tif ( *ptr == 'T' ) {\n\t\t\t\tin_time = 1;\n\t\t\t\tptr++;\n\t\t\t}\n\t\t\tif ( *ptr == '\\0' ) {\n\t\t\t\tadd_error(s, \"Missing expected time part\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tnr = timelib_get_unsigned_nr((char **) &ptr, 12);\n\t\t\tswitch (*ptr) {\n\t\t\t\tcase 'Y': s->period->y = nr; break;\n\t\t\t\tcase 'W': s->period->d = nr * 7; break;\n\t\t\t\tcase 'D': s->period->d = nr; break;\n\t\t\t\tcase 'H': s->period->h = nr; break;\n\t\t\t\tcase 'S': s->period->s = nr; break;\n\t\t\t\tcase 'M': \n\t\t\t\t\tif (in_time) {\n\t\t\t\t\t\ts->period->i = nr;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts->period->m = nr; \n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tadd_error(s, \"Undefined period specifier\");\n                                        break;\n                        }\n                        ptr++;\n               } while (*ptr);\n                s->have_period = 1;\n                TIMELIB_DEINIT;\n                return TIMELIB_PERIOD;\n\t}\n#line 424 \"ext/date/lib/parse_iso_intervals.c\"\nyy7:\n\tYYDEBUG(7, *YYCURSOR);\n\t++YYCURSOR;\n\tYYDEBUG(8, *YYCURSOR);\n#line 413 \"ext/date/lib/parse_iso_intervals.re\"\n\t{\n\t\tgoto std;\n\t}\n#line 433 \"ext/date/lib/parse_iso_intervals.c\"\nyy9:\n\tYYDEBUG(9, *YYCURSOR);\n\t++YYCURSOR;\n\tYYDEBUG(10, *YYCURSOR);\n#line 418 \"ext/date/lib/parse_iso_intervals.re\"\n\t{\n\t\ts->pos = cursor; s->line++;\n\t\tgoto std;\n\t}\n#line 443 \"ext/date/lib/parse_iso_intervals.c\"\nyy11:\n\tYYDEBUG(11, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tgoto yy3;\nyy12:\n\tYYDEBUG(12, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych <= 'L') {\n\t\tif (yych <= '9') {\n\t\t\tif (yych >= '0') goto yy25;\n\t\t} else {\n\t\t\tif (yych == 'D') goto yy24;\n\t\t}\n\t} else {\n\t\tif (yych <= 'W') {\n\t\t\tif (yych <= 'M') goto yy27;\n\t\t\tif (yych >= 'W') goto yy26;\n\t\t} else {\n\t\t\tif (yych == 'Y') goto yy28;\n\t\t}\n\t}\nyy13:\n\tYYDEBUG(13, *YYCURSOR);\n\tYYCURSOR = YYMARKER;\n\tif (yyaccept <= 0) {\n\t\tgoto yy3;\n\t} else {\n\t\tgoto yy6;\n\t}\nyy14:\n\tYYDEBUG(14, *YYCURSOR);\n\tyyaccept = 1;\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yybm[0+yych] & 128) {\n\t\tgoto yy15;\n\t}\n\tgoto yy6;\nyy15:\n\tYYDEBUG(15, *YYCURSOR);\n\t++YYCURSOR;\n\tif ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);\n\tyych = *YYCURSOR;\n\tYYDEBUG(16, *YYCURSOR);\n\tif (yybm[0+yych] & 128) {\n\t\tgoto yy15;\n\t}\n\tif (yych <= 'L') {\n\t\tif (yych == 'H') goto yy19;\n\t\tgoto yy13;\n\t} else {\n\t\tif (yych <= 'M') goto yy18;\n\t\tif (yych != 'S') goto yy13;\n\t}\nyy17:\n\tYYDEBUG(17, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tgoto yy6;\nyy18:\n\tYYDEBUG(18, *YYCURSOR);\n\tyyaccept = 1;\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych <= '/') goto yy6;\n\tif (yych <= '9') goto yy22;\n\tgoto yy6;\nyy19:\n\tYYDEBUG(19, *YYCURSOR);\n\tyyaccept = 1;\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych <= '/') goto yy6;\n\tif (yych >= ':') goto yy6;\nyy20:\n\tYYDEBUG(20, *YYCURSOR);\n\t++YYCURSOR;\n\tif ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);\n\tyych = *YYCURSOR;\n\tYYDEBUG(21, *YYCURSOR);\n\tif (yych <= 'L') {\n\t\tif (yych <= '/') goto yy13;\n\t\tif (yych <= '9') goto yy20;\n\t\tgoto yy13;\n\t} else {\n\t\tif (yych <= 'M') goto yy18;\n\t\tif (yych == 'S') goto yy17;\n\t\tgoto yy13;\n\t}\nyy22:\n\tYYDEBUG(22, *YYCURSOR);\n\t++YYCURSOR;\n\tif (YYLIMIT <= YYCURSOR) YYFILL(1);\n\tyych = *YYCURSOR;\n\tYYDEBUG(23, *YYCURSOR);\n\tif (yych <= '/') goto yy13;\n\tif (yych <= '9') goto yy22;\n\tif (yych == 'S') goto yy17;\n\tgoto yy13;\nyy24:\n\tYYDEBUG(24, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych == 'T') goto yy14;\n\tgoto yy6;\nyy25:\n\tYYDEBUG(25, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych <= 'L') {\n\t\tif (yych <= '9') {\n\t\t\tif (yych <= '/') goto yy13;\n\t\t\tgoto yy35;\n\t\t} else {\n\t\t\tif (yych == 'D') goto yy24;\n\t\t\tgoto yy13;\n\t\t}\n\t} else {\n\t\tif (yych <= 'W') {\n\t\t\tif (yych <= 'M') goto yy27;\n\t\t\tif (yych <= 'V') goto yy13;\n\t\t} else {\n\t\t\tif (yych == 'Y') goto yy28;\n\t\t\tgoto yy13;\n\t\t}\n\t}\nyy26:\n\tYYDEBUG(26, *YYCURSOR);\n\tyyaccept = 1;\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych <= '/') goto yy6;\n\tif (yych <= '9') goto yy33;\n\tif (yych == 'T') goto yy14;\n\tgoto yy6;\nyy27:\n\tYYDEBUG(27, *YYCURSOR);\n\tyyaccept = 1;\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych <= '/') goto yy6;\n\tif (yych <= '9') goto yy31;\n\tif (yych == 'T') goto yy14;\n\tgoto yy6;\nyy28:\n\tYYDEBUG(28, *YYCURSOR);\n\tyyaccept = 1;\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych <= '/') goto yy6;\n\tif (yych <= '9') goto yy29;\n\tif (yych == 'T') goto yy14;\n\tgoto yy6;\nyy29:\n\tYYDEBUG(29, *YYCURSOR);\n\t++YYCURSOR;\n\tif ((YYLIMIT - YYCURSOR) < 3) YYFILL(3);\n\tyych = *YYCURSOR;\n\tYYDEBUG(30, *YYCURSOR);\n\tif (yych <= 'D') {\n\t\tif (yych <= '/') goto yy13;\n\t\tif (yych <= '9') goto yy29;\n\t\tif (yych <= 'C') goto yy13;\n\t\tgoto yy24;\n\t} else {\n\t\tif (yych <= 'M') {\n\t\t\tif (yych <= 'L') goto yy13;\n\t\t\tgoto yy27;\n\t\t} else {\n\t\t\tif (yych == 'W') goto yy26;\n\t\t\tgoto yy13;\n\t\t}\n\t}\nyy31:\n\tYYDEBUG(31, *YYCURSOR);\n\t++YYCURSOR;\n\tif ((YYLIMIT - YYCURSOR) < 3) YYFILL(3);\n\tyych = *YYCURSOR;\n\tYYDEBUG(32, *YYCURSOR);\n\tif (yych <= 'C') {\n\t\tif (yych <= '/') goto yy13;\n\t\tif (yych <= '9') goto yy31;\n\t\tgoto yy13;\n\t} else {\n\t\tif (yych <= 'D') goto yy24;\n\t\tif (yych == 'W') goto yy26;\n\t\tgoto yy13;\n\t}\nyy33:\n\tYYDEBUG(33, *YYCURSOR);\n\t++YYCURSOR;\n\tif ((YYLIMIT - YYCURSOR) < 3) YYFILL(3);\n\tyych = *YYCURSOR;\n\tYYDEBUG(34, *YYCURSOR);\n\tif (yych <= '/') goto yy13;\n\tif (yych <= '9') goto yy33;\n\tif (yych == 'D') goto yy24;\n\tgoto yy13;\nyy35:\n\tYYDEBUG(35, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych <= 'L') {\n\t\tif (yych <= '9') {\n\t\t\tif (yych <= '/') goto yy13;\n\t\t} else {\n\t\t\tif (yych == 'D') goto yy24;\n\t\t\tgoto yy13;\n\t\t}\n\t} else {\n\t\tif (yych <= 'W') {\n\t\t\tif (yych <= 'M') goto yy27;\n\t\t\tif (yych <= 'V') goto yy13;\n\t\t\tgoto yy26;\n\t\t} else {\n\t\t\tif (yych == 'Y') goto yy28;\n\t\t\tgoto yy13;\n\t\t}\n\t}\n\tYYDEBUG(36, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych != '-') goto yy39;\n\tYYDEBUG(37, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy13;\n\tif (yych <= '0') goto yy40;\n\tif (yych <= '1') goto yy41;\n\tgoto yy13;\nyy38:\n\tYYDEBUG(38, *YYCURSOR);\n\t++YYCURSOR;\n\tif ((YYLIMIT - YYCURSOR) < 3) YYFILL(3);\n\tyych = *YYCURSOR;\nyy39:\n\tYYDEBUG(39, *YYCURSOR);\n\tif (yych <= 'L') {\n\t\tif (yych <= '9') {\n\t\t\tif (yych <= '/') goto yy13;\n\t\t\tgoto yy38;\n\t\t} else {\n\t\t\tif (yych == 'D') goto yy24;\n\t\t\tgoto yy13;\n\t\t}\n\t} else {\n\t\tif (yych <= 'W') {\n\t\t\tif (yych <= 'M') goto yy27;\n\t\t\tif (yych <= 'V') goto yy13;\n\t\t\tgoto yy26;\n\t\t} else {\n\t\t\tif (yych == 'Y') goto yy28;\n\t\t\tgoto yy13;\n\t\t}\n\t}\nyy40:\n\tYYDEBUG(40, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy13;\n\tif (yych <= '9') goto yy42;\n\tgoto yy13;\nyy41:\n\tYYDEBUG(41, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy13;\n\tif (yych >= '3') goto yy13;\nyy42:\n\tYYDEBUG(42, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych != '-') goto yy13;\n\tYYDEBUG(43, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy13;\n\tif (yych <= '0') goto yy44;\n\tif (yych <= '2') goto yy45;\n\tif (yych <= '3') goto yy46;\n\tgoto yy13;\nyy44:\n\tYYDEBUG(44, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy13;\n\tif (yych <= '9') goto yy47;\n\tgoto yy13;\nyy45:\n\tYYDEBUG(45, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy13;\n\tif (yych <= '9') goto yy47;\n\tgoto yy13;\nyy46:\n\tYYDEBUG(46, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy13;\n\tif (yych >= '2') goto yy13;\nyy47:\n\tYYDEBUG(47, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych != 'T') goto yy13;\n\tYYDEBUG(48, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy13;\n\tif (yych <= '1') goto yy49;\n\tif (yych <= '2') goto yy50;\n\tgoto yy13;\nyy49:\n\tYYDEBUG(49, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy13;\n\tif (yych <= '9') goto yy51;\n\tgoto yy13;\nyy50:\n\tYYDEBUG(50, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy13;\n\tif (yych >= '5') goto yy13;\nyy51:\n\tYYDEBUG(51, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych != ':') goto yy13;\n\tYYDEBUG(52, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy13;\n\tif (yych >= '6') goto yy13;\n\tYYDEBUG(53, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy13;\n\tif (yych >= ':') goto yy13;\n\tYYDEBUG(54, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych != ':') goto yy13;\n\tYYDEBUG(55, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy13;\n\tif (yych >= '6') goto yy13;\n\tYYDEBUG(56, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy13;\n\tif (yych >= ':') goto yy13;\n\tYYDEBUG(57, *YYCURSOR);\n\t++YYCURSOR;\n\tYYDEBUG(58, *YYCURSOR);\n#line 393 \"ext/date/lib/parse_iso_intervals.re\"\n\t{\n\t\tDEBUG_OUTPUT(\"combinedrep\");\n\t\tTIMELIB_INIT;\n\t\ts->period->y = timelib_get_unsigned_nr((char **) &ptr, 4);\n\t\tptr++;\n\t\ts->period->m = timelib_get_unsigned_nr((char **) &ptr, 2);\n\t\tptr++;\n\t\ts->period->d = timelib_get_unsigned_nr((char **) &ptr, 2);\n\t\tptr++;\n\t\ts->period->h = timelib_get_unsigned_nr((char **) &ptr, 2);\n\t\tptr++;\n\t\ts->period->i = timelib_get_unsigned_nr((char **) &ptr, 2);\n\t\tptr++;\n\t\ts->period->s = timelib_get_unsigned_nr((char **) &ptr, 2);\n\t\ts->have_period = 1;\n\t\tTIMELIB_DEINIT;\n\t\treturn TIMELIB_PERIOD;\n\t}\n#line 792 \"ext/date/lib/parse_iso_intervals.c\"\nyy59:\n\tYYDEBUG(59, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy13;\n\tif (yych >= ':') goto yy13;\n\tYYDEBUG(60, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy13;\n\tif (yych >= ':') goto yy13;\n\tYYDEBUG(61, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') {\n\t\tif (yych == '-') goto yy64;\n\t\tgoto yy13;\n\t} else {\n\t\tif (yych <= '0') goto yy62;\n\t\tif (yych <= '1') goto yy63;\n\t\tgoto yy13;\n\t}\nyy62:\n\tYYDEBUG(62, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych <= '0') goto yy13;\n\tif (yych <= '9') goto yy85;\n\tgoto yy13;\nyy63:\n\tYYDEBUG(63, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy13;\n\tif (yych <= '2') goto yy85;\n\tgoto yy13;\nyy64:\n\tYYDEBUG(64, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy13;\n\tif (yych <= '0') goto yy65;\n\tif (yych <= '1') goto yy66;\n\tgoto yy13;\nyy65:\n\tYYDEBUG(65, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych <= '0') goto yy13;\n\tif (yych <= '9') goto yy67;\n\tgoto yy13;\nyy66:\n\tYYDEBUG(66, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy13;\n\tif (yych >= '3') goto yy13;\nyy67:\n\tYYDEBUG(67, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych != '-') goto yy13;\n\tYYDEBUG(68, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy13;\n\tif (yych <= '0') goto yy69;\n\tif (yych <= '2') goto yy70;\n\tif (yych <= '3') goto yy71;\n\tgoto yy13;\nyy69:\n\tYYDEBUG(69, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych <= '0') goto yy13;\n\tif (yych <= '9') goto yy72;\n\tgoto yy13;\nyy70:\n\tYYDEBUG(70, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy13;\n\tif (yych <= '9') goto yy72;\n\tgoto yy13;\nyy71:\n\tYYDEBUG(71, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy13;\n\tif (yych >= '2') goto yy13;\nyy72:\n\tYYDEBUG(72, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych != 'T') goto yy13;\n\tYYDEBUG(73, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy13;\n\tif (yych <= '1') goto yy74;\n\tif (yych <= '2') goto yy75;\n\tgoto yy13;\nyy74:\n\tYYDEBUG(74, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy13;\n\tif (yych <= '9') goto yy76;\n\tgoto yy13;\nyy75:\n\tYYDEBUG(75, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy13;\n\tif (yych >= '5') goto yy13;\nyy76:\n\tYYDEBUG(76, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych != ':') goto yy13;\n\tYYDEBUG(77, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy13;\n\tif (yych >= '6') goto yy13;\n\tYYDEBUG(78, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy13;\n\tif (yych >= ':') goto yy13;\n\tYYDEBUG(79, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych != ':') goto yy13;\n\tYYDEBUG(80, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy13;\n\tif (yych >= '6') goto yy13;\n\tYYDEBUG(81, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy13;\n\tif (yych >= ':') goto yy13;\n\tYYDEBUG(82, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych != 'Z') goto yy13;\nyy83:\n\tYYDEBUG(83, *YYCURSOR);\n\t++YYCURSOR;\n\tYYDEBUG(84, *YYCURSOR);\n#line 327 \"ext/date/lib/parse_iso_intervals.re\"\n\t{\n\t\ttimelib_time *current;\n\n\t\tif (s->have_date || s->have_period) {\n\t\t\tcurrent = s->end;\n\t\t\ts->have_end_date = 1;\n\t\t} else {\n\t\t\tcurrent = s->begin;\n\t\t\ts->have_begin_date = 1;\n\t\t}\n\t\tDEBUG_OUTPUT(\"datetimebasic | datetimeextended\");\n\t\tTIMELIB_INIT;\n\t\tcurrent->y = timelib_get_nr((char **) &ptr, 4);\n\t\tcurrent->m = timelib_get_nr((char **) &ptr, 2);\n\t\tcurrent->d = timelib_get_nr((char **) &ptr, 2);\n\t\tcurrent->h = timelib_get_nr((char **) &ptr, 2);\n\t\tcurrent->i = timelib_get_nr((char **) &ptr, 2);\n\t\tcurrent->s = timelib_get_nr((char **) &ptr, 2);\n\t\ts->have_date = 1;\n\t\tTIMELIB_DEINIT;\n\t\treturn TIMELIB_ISO_DATE;\n\t}\n#line 944 \"ext/date/lib/parse_iso_intervals.c\"\nyy85:\n\tYYDEBUG(85, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy13;\n\tif (yych <= '0') goto yy86;\n\tif (yych <= '2') goto yy87;\n\tif (yych <= '3') goto yy88;\n\tgoto yy13;\nyy86:\n\tYYDEBUG(86, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych <= '0') goto yy13;\n\tif (yych <= '9') goto yy89;\n\tgoto yy13;\nyy87:\n\tYYDEBUG(87, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy13;\n\tif (yych <= '9') goto yy89;\n\tgoto yy13;\nyy88:\n\tYYDEBUG(88, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy13;\n\tif (yych >= '2') goto yy13;\nyy89:\n\tYYDEBUG(89, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych != 'T') goto yy13;\n\tYYDEBUG(90, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy13;\n\tif (yych <= '1') goto yy91;\n\tif (yych <= '2') goto yy92;\n\tgoto yy13;\nyy91:\n\tYYDEBUG(91, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy13;\n\tif (yych <= '9') goto yy93;\n\tgoto yy13;\nyy92:\n\tYYDEBUG(92, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy13;\n\tif (yych >= '5') goto yy13;\nyy93:\n\tYYDEBUG(93, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy13;\n\tif (yych >= '6') goto yy13;\n\tYYDEBUG(94, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy13;\n\tif (yych >= ':') goto yy13;\n\tYYDEBUG(95, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy13;\n\tif (yych >= '6') goto yy13;\n\tYYDEBUG(96, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy13;\n\tif (yych >= ':') goto yy13;\n\tYYDEBUG(97, *YYCURSOR);\n\tyych = *++YYCURSOR;\n\tif (yych == 'Z') goto yy83;\n\tgoto yy13;\nyy98:\n\tYYDEBUG(98, *YYCURSOR);\n\t++YYCURSOR;\n\tif (YYLIMIT <= YYCURSOR) YYFILL(1);\n\tyych = *YYCURSOR;\n\tYYDEBUG(99, *YYCURSOR);\n\tif (yych <= '/') goto yy100;\n\tif (yych <= '9') goto yy98;\nyy100:\n\tYYDEBUG(100, *YYCURSOR);\n#line 316 \"ext/date/lib/parse_iso_intervals.re\"\n\t{\n\t\tDEBUG_OUTPUT(\"recurrences\");\n\t\tTIMELIB_INIT;\n\t\tptr++;\n\t\ts->recurrences = timelib_get_unsigned_nr((char **) &ptr, 9);\n\t\tTIMELIB_DEINIT;\n\t\ts->have_recurrences = 1;\n\t\treturn TIMELIB_PERIOD;\n\t}\n#line 1032 \"ext/date/lib/parse_iso_intervals.c\"\n}\n#line 428 \"ext/date/lib/parse_iso_intervals.re\"\n\n}\n", "target": 1, "idx": 177738}
{"func": " int hns_ppe_get_sset_count(int stringset)\n {\n\tif (stringset == ETH_SS_STATS)\n \t\treturn ETH_PPE_STATIC_NUM;\n \treturn 0;\n }\n", "target": 1, "idx": 182571}
{"func": "static int l2tp_ip_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct sockaddr_l2tpip *addr = (struct sockaddr_l2tpip *) uaddr;\n\tstruct net *net = sock_net(sk);\n \tint ret;\n \tint chk_addr_ret;\n \n\tif (!sock_flag(sk, SOCK_ZAPPED))\n\t\treturn -EINVAL;\n \tif (addr_len < sizeof(struct sockaddr_l2tpip))\n \t\treturn -EINVAL;\n \tif (addr->l2tp_family != AF_INET)\n\t\treturn -EINVAL;\n\n\tret = -EADDRINUSE;\n\tread_lock_bh(&l2tp_ip_lock);\n\tif (__l2tp_ip_bind_lookup(net, addr->l2tp_addr.s_addr,\n\t\t\t\t  sk->sk_bound_dev_if, addr->l2tp_conn_id))\n\t\tgoto out_in_use;\n\n \tread_unlock_bh(&l2tp_ip_lock);\n \n \tlock_sock(sk);\n \tif (sk->sk_state != TCP_CLOSE || addr_len < sizeof(struct sockaddr_l2tpip))\n \t\tgoto out;\n \n\tchk_addr_ret = inet_addr_type(net, addr->l2tp_addr.s_addr);\n\tret = -EADDRNOTAVAIL;\n\tif (addr->l2tp_addr.s_addr && chk_addr_ret != RTN_LOCAL &&\n\t    chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST)\n\t\tgoto out;\n\n\tif (addr->l2tp_addr.s_addr)\n\t\tinet->inet_rcv_saddr = inet->inet_saddr = addr->l2tp_addr.s_addr;\n\tif (chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST)\n\t\tinet->inet_saddr = 0;  /* Use device */\n\tsk_dst_reset(sk);\n\n\tl2tp_ip_sk(sk)->conn_id = addr->l2tp_conn_id;\n\n\twrite_lock_bh(&l2tp_ip_lock);\n\tsk_add_bind_node(sk, &l2tp_ip_bind_table);\n\tsk_del_node_init(sk);\n\twrite_unlock_bh(&l2tp_ip_lock);\n\tret = 0;\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\nout:\n\trelease_sock(sk);\n\n\treturn ret;\n\nout_in_use:\n\tread_unlock_bh(&l2tp_ip_lock);\n\n\treturn ret;\n}\n", "target": 1, "idx": 181661}
{"func": "static inline int ip6_ufo_append_data(struct sock *sk,\n\t\t\tint getfrag(void *from, char *to, int offset, int len,\n\t\t\tint odd, struct sk_buff *skb),\n\t\t\tvoid *from, int length, int hh_len, int fragheaderlen,\n\t\t\tint transhdrlen, int mtu,unsigned int flags,\n\t\t\tstruct rt6_info *rt)\n \n {\n \tstruct sk_buff *skb;\n \tint err;\n \n \t/* There is support for UDP large send offload by network\n \t * device, so create one single skb packet containing complete\n \t * udp datagram\n \t */\n \tif ((skb = skb_peek_tail(&sk->sk_write_queue)) == NULL) {\n\t\tstruct frag_hdr fhdr;\n \t\tskb = sock_alloc_send_skb(sk,\n \t\t\thh_len + fragheaderlen + transhdrlen + 20,\n \t\t\t(flags & MSG_DONTWAIT), &err);\n\t\tif (skb == NULL)\n\t\t\treturn err;\n\n\t\t/* reserve space for Hardware header */\n\t\tskb_reserve(skb, hh_len);\n\n\t\t/* create space for UDP/IP header */\n\t\tskb_put(skb,fragheaderlen + transhdrlen);\n\n\t\t/* initialize network header pointer */\n\t\tskb_reset_network_header(skb);\n\n\t\t/* initialize protocol header pointer */\n \t\tskb->transport_header = skb->network_header + fragheaderlen;\n \n \t\tskb->protocol = htons(ETH_P_IPV6);\n\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n \t\tskb->csum = 0;\n \n\t\t/* Specify the length of each IPv6 datagram fragment.\n\t\t * It has to be a multiple of 8.\n\t\t */\n\t\tskb_shinfo(skb)->gso_size = (mtu - fragheaderlen -\n\t\t\t\t\t     sizeof(struct frag_hdr)) & ~7;\n\t\tskb_shinfo(skb)->gso_type = SKB_GSO_UDP;\n\t\tipv6_select_ident(&fhdr, rt);\n\t\tskb_shinfo(skb)->ip6_frag_id = fhdr.identification;\n \t\t__skb_queue_tail(&sk->sk_write_queue, skb);\n \t}\n \n \treturn skb_append_datato_frags(sk, skb, getfrag, from,\n \t\t\t\t       (length - transhdrlen));\n }\n", "target": 1, "idx": 183065}
{"func": "void PartialMagnificationController::SetScale(float scale) {\n  if (!is_enabled_)\n     return;\n \n  scale_ = scale;\n \n  if (IsPartialMagnified()) {\n    CreateMagnifierWindow();\n  } else {\n     CloseMagnifierWindow();\n   }\n }\n", "target": 1, "idx": 185521}
{"func": " void PluginInstance::SendJavaScriptStream(const GURL& url,\n                                           const std::string& result,\n                                           bool success,\n                                          bool notify_needed,\n                                          intptr_t notify_data) {\n   if (success) {\n     PluginStringStream *stream =\n      new PluginStringStream(this, url, notify_needed,\n                             reinterpret_cast<void*>(notify_data));\n     AddStream(stream);\n     stream->SendToPlugin(result, \"text/html\");\n   } else {\n    if (notify_needed) {\n      this->NPP_URLNotify(url.spec().c_str(), NPRES_DONE,\n                          reinterpret_cast<void*>(notify_data));\n    }\n   }\n }\n", "target": 1, "idx": 183592}
{"func": "void __init shm_init (void)\n{\n\tipc_init_proc_interface(\"sysvipc/shm\",\n#if BITS_PER_LONG <= 32\n\t\t\t\t\"       key      shmid perms       size  cpid  lpid nattch   uid   gid  cuid  cgid      atime      dtime      ctime        rss       swap\\n\",\n#else\n\t\t\t\t\"       key      shmid perms                  size  cpid  lpid nattch   uid   gid  cuid  cgid      atime      dtime      ctime                   rss                  swap\\n\",\n#endif\n\t\t\t\tIPC_SHM_IDS, sysvipc_shm_proc_show);\n}\n", "target": 0, "idx": 27970}
{"func": "static void domStringListFunctionMethod(const v8::FunctionCallbackInfo<v8::Value>& info)\n{\n    ExceptionState exceptionState(ExceptionState::ExecutionContext, \"domStringListFunction\", \"TestObject\", info.Holder(), info.GetIsolate());\n    if (UNLIKELY(info.Length() < 1)) {\n        exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));\n        exceptionState.throwIfNeeded();\n        return;\n    }\n    TestObject* imp = V8TestObject::toNative(info.Holder());\n    V8TRYCATCH_VOID(DOMStringList*, values, V8DOMStringList::toNativeWithTypeCheck(info.GetIsolate(), info[0]));\n    RefPtr<DOMStringList> result = imp->domStringListFunction(values, exceptionState);\n    if (exceptionState.throwIfNeeded())\n        return;\n    v8SetReturnValue(info, result.release());\n}\n", "target": 0, "idx": 130727}
{"func": "static int midi_setup_noteon(struct _mdi *mdi, uint8_t channel,\n                             uint8_t note, uint8_t velocity) {\n    MIDI_EVENT_DEBUG(__FUNCTION__,channel, note);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_note_on;\n    mdi->events[mdi->event_count].event_data.channel = channel;\n    mdi->events[mdi->event_count].event_data.data.value = (note << 8) | velocity;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n\n    if (mdi->channel[channel].isdrum)\n        _WM_load_patch(mdi, ((mdi->channel[channel].bank << 8) | (note | 0x80)));\n    return (0);\n}\n", "target": 0, "idx": 63282}
{"func": "xmlParseComment(xmlParserCtxtPtr ctxt) {\n    xmlChar *buf = NULL;\n    int size = XML_PARSER_BUFFER_SIZE;\n    int len = 0;\n    xmlParserInputState state;\n    const xmlChar *in;\n    int nbchar = 0, ccol;\n    int inputid;\n\n    /*\n     * Check that there is a comment right here.\n     */\n    if ((RAW != '<') || (NXT(1) != '!') ||\n        (NXT(2) != '-') || (NXT(3) != '-')) return;\n    state = ctxt->instate;\n    ctxt->instate = XML_PARSER_COMMENT;\n    inputid = ctxt->input->id;\n    SKIP(4);\n    SHRINK;\n    GROW;\n\n    /*\n     * Accelerated common case where input don't need to be\n     * modified before passing it to the handler.\n     */\n    in = ctxt->input->cur;\n    do {\n\tif (*in == 0xA) {\n\t    do {\n\t\tctxt->input->line++; ctxt->input->col = 1;\n\t\tin++;\n\t    } while (*in == 0xA);\n\t}\nget_more:\n        ccol = ctxt->input->col;\n\twhile (((*in > '-') && (*in <= 0x7F)) ||\n\t       ((*in >= 0x20) && (*in < '-')) ||\n\t       (*in == 0x09)) {\n\t\t    in++;\n\t\t    ccol++;\n\t}\n\tctxt->input->col = ccol;\n\tif (*in == 0xA) {\n\t    do {\n\t\tctxt->input->line++; ctxt->input->col = 1;\n\t\tin++;\n\t    } while (*in == 0xA);\n\t    goto get_more;\n\t}\n\tnbchar = in - ctxt->input->cur;\n\t/*\n\t * save current set of data\n\t */\n\tif (nbchar > 0) {\n\t    if ((ctxt->sax != NULL) &&\n\t\t(ctxt->sax->comment != NULL)) {\n\t\tif (buf == NULL) {\n\t\t    if ((*in == '-') && (in[1] == '-'))\n\t\t        size = nbchar + 1;\n\t\t    else\n\t\t        size = XML_PARSER_BUFFER_SIZE + nbchar;\n\t\t    buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));\n\t\t    if (buf == NULL) {\n\t\t        xmlErrMemory(ctxt, NULL);\n\t\t\tctxt->instate = state;\n\t\t\treturn;\n\t\t    }\n\t\t    len = 0;\n\t\t} else if (len + nbchar + 1 >= size) {\n\t\t    xmlChar *new_buf;\n\t\t    size  += len + nbchar + XML_PARSER_BUFFER_SIZE;\n\t\t    new_buf = (xmlChar *) xmlRealloc(buf,\n\t\t                                     size * sizeof(xmlChar));\n\t\t    if (new_buf == NULL) {\n\t\t        xmlFree (buf);\n\t\t\txmlErrMemory(ctxt, NULL);\n\t\t\tctxt->instate = state;\n\t\t\treturn;\n\t\t    }\n\t\t    buf = new_buf;\n\t\t}\n\t\tmemcpy(&buf[len], ctxt->input->cur, nbchar);\n\t\tlen += nbchar;\n\t\tbuf[len] = 0;\n\t    }\n\t}\n\tctxt->input->cur = in;\n\tif (*in == 0xA) {\n\t    in++;\n\t    ctxt->input->line++; ctxt->input->col = 1;\n\t}\n\tif (*in == 0xD) {\n\t    in++;\n\t    if (*in == 0xA) {\n\t\tctxt->input->cur = in;\n\t\tin++;\n\t\tctxt->input->line++; ctxt->input->col = 1;\n\t\tcontinue; /* while */\n\t    }\n\t    in--;\n \t}\n \tSHRINK;\n \tGROW;\n \tin = ctxt->input->cur;\n \tif (*in == '-') {\n \t    if (in[1] == '-') {\n\t        if (in[2] == '>') {\n\t\t    if (ctxt->input->id != inputid) {\n\t\t\txmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n\t\t\t\"comment doesn't start and stop in the same entity\\n\");\n\t\t    }\n\t\t    SKIP(3);\n\t\t    if ((ctxt->sax != NULL) && (ctxt->sax->comment != NULL) &&\n\t\t        (!ctxt->disableSAX)) {\n\t\t\tif (buf != NULL)\n\t\t\t    ctxt->sax->comment(ctxt->userData, buf);\n\t\t\telse\n\t\t\t    ctxt->sax->comment(ctxt->userData, BAD_CAST \"\");\n \t\t    }\n \t\t    if (buf != NULL)\n \t\t        xmlFree(buf);\n\t\t    ctxt->instate = state;\n \t\t    return;\n \t\t}\n \t\tif (buf != NULL)\n\t\t    xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,\n\t\t                      \"Comment not terminated \\n<!--%.50s\\n\",\n\t\t\t\t      buf);\n\t\telse\n\t\t    xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,\n\t\t                      \"Comment not terminated \\n\", NULL);\n\t\tin++;\n\t\tctxt->input->col++;\n\t    }\n\t    in++;\n\t    ctxt->input->col++;\n\t    goto get_more;\n\t}\n    } while (((*in >= 0x20) && (*in <= 0x7F)) || (*in == 0x09));\n    xmlParseCommentComplex(ctxt, buf, len, size);\n    ctxt->instate = state;\n    return;\n}\n", "target": 1, "idx": 184970}
{"func": "_gd2GetHeader (gdIOCtxPtr in, int *sx, int *sy,\n               int *cs, int *vers, int *fmt, int *ncx, int *ncy,\n               t_chunk_info ** chunkIdx)\n{\n\tint i;\n\tint ch;\n\tchar id[5];\n\tt_chunk_info *cidx;\n\tint sidx;\n\tint nc;\n\n\tGD2_DBG (printf (\"Reading gd2 header info\\n\"));\n\n\tfor (i = 0; i < 4; i++) {\n\t\tch = gdGetC (in);\n\t\tif (ch == EOF) {\n\t\t\tgoto fail1;\n\t\t};\n\t\tid[i] = ch;\n\t};\n\tid[4] = 0;\n\n\tGD2_DBG (printf (\"Got file code: %s\\n\", id));\n\n\t/* Equiv. of 'magick'.  */\n\tif (strcmp (id, GD2_ID) != 0) {\n\t\tGD2_DBG (printf (\"Not a valid gd2 file\\n\"));\n\t\tgoto fail1;\n\t};\n\n\t/* Version */\n\tif (gdGetWord (vers, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"Version: %d\\n\", *vers));\n\n\tif ((*vers != 1) && (*vers != 2)) {\n\t\tGD2_DBG (printf (\"Bad version: %d\\n\", *vers));\n\t\tgoto fail1;\n\t};\n\n\t/* Image Size */\n\tif (!gdGetWord (sx, in)) {\n\t\tGD2_DBG (printf (\"Could not get x-size\\n\"));\n\t\tgoto fail1;\n\t}\n\tif (!gdGetWord (sy, in)) {\n\t\tGD2_DBG (printf (\"Could not get y-size\\n\"));\n\t\tgoto fail1;\n\t}\n\tGD2_DBG (printf (\"Image is %dx%d\\n\", *sx, *sy));\n\n\t/* Chunk Size (pixels, not bytes!) */\n\tif (gdGetWord (cs, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"ChunkSize: %d\\n\", *cs));\n\n\tif ((*cs < GD2_CHUNKSIZE_MIN) || (*cs > GD2_CHUNKSIZE_MAX)) {\n\t\tGD2_DBG (printf (\"Bad chunk size: %d\\n\", *cs));\n\t\tgoto fail1;\n\t};\n\n\t/* Data Format */\n\tif (gdGetWord (fmt, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"Format: %d\\n\", *fmt));\n\n\tif ((*fmt != GD2_FMT_RAW) && (*fmt != GD2_FMT_COMPRESSED) &&\n\t        (*fmt != GD2_FMT_TRUECOLOR_RAW) &&\n\t        (*fmt != GD2_FMT_TRUECOLOR_COMPRESSED)) {\n\t\tGD2_DBG (printf (\"Bad data format: %d\\n\", *fmt));\n\t\tgoto fail1;\n\t};\n\n\n\t/* # of chunks wide */\n\tif (gdGetWord (ncx, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"%d Chunks Wide\\n\", *ncx));\n\n\t/* # of chunks high */\n\tif (gdGetWord (ncy, in) != 1) {\n\t\tgoto fail1;\n\t};\n \tGD2_DBG (printf (\"%d Chunks vertically\\n\", *ncy));\n \n \tif (gd2_compressed (*fmt)) {\n \t\tnc = (*ncx) * (*ncy);\n \n \t\tGD2_DBG (printf (\"Reading %d chunk index entries\\n\", nc));\n\t\tif (overflow2(sizeof(t_chunk_info), nc)) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tsidx = sizeof (t_chunk_info) * nc;\n\t\tif (sidx <= 0) {\n\t\t\tgoto fail1;\n\t\t}\n\n\t\tcidx = gdCalloc (sidx, 1);\n\t\tif (cidx == NULL) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tfor (i = 0; i < nc; i++) {\n\t\t\tif (gdGetInt (&cidx[i].offset, in) != 1) {\n\t\t\t\tgoto fail2;\n\t\t\t};\n\t\t\tif (gdGetInt (&cidx[i].size, in) != 1) {\n\t\t\t\tgoto fail2;\n\t\t\t};\n\t\t\tif (cidx[i].offset < 0 || cidx[i].size < 0)\n\t\t\t\tgoto fail2;\n\t\t};\n\t\t*chunkIdx = cidx;\n\t};\n\n\tGD2_DBG (printf (\"gd2 header complete\\n\"));\n\n\treturn 1;\nfail2:\n\tgdFree(cidx);\nfail1:\n\treturn 0;\n}\n", "target": 1, "idx": 181681}
{"func": "ice_io_error_handler (IceConn conn)\n{\n        g_debug (\"GsmXsmpServer: ice_io_error_handler (%p)\", conn);\n\n        /* We don't need to do anything here; the next call to\n         * IceProcessMessages() for this connection will receive\n         * IceProcessMessagesIOError and we can handle the error there.\n         */\n}\n", "target": 0, "idx": 63602}
{"func": "static EAS_RESULT Parse_wave (SDLS_SYNTHESIZER_DATA *pDLSData, EAS_I32 pos, EAS_U16 waveIndex)\n{\n    EAS_RESULT result;\n    EAS_U32 temp;\n    EAS_I32 size;\n    EAS_I32 endChunk;\n    EAS_I32 chunkPos;\n    EAS_I32 wsmpPos = 0;\n    EAS_I32 fmtPos = 0;\n    EAS_I32 dataPos = 0;\n    EAS_I32 dataSize = 0;\n    S_WSMP_DATA *p;\n void *pSample;\n    S_WSMP_DATA wsmp;\n\n /* seek to start of chunk */\n    chunkPos = pos + 12;\n if ((result = EAS_HWFileSeek(pDLSData->hwInstData, pDLSData->fileHandle, pos)) != EAS_SUCCESS)\n return result;\n\n /* get the chunk type */\n if ((result = NextChunk(pDLSData, &pos, &temp, &size)) != EAS_SUCCESS)\n return result;\n\n /* make sure it is a wave chunk */\n if (temp != CHUNK_WAVE)\n {\n { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, \"Offset in ptbl does not point to wave chunk\\n\"); */ }\n return EAS_ERROR_FILE_FORMAT;\n }\n\n /* read to end of chunk */\n    pos = chunkPos;\n    endChunk = pos + size;\n while (pos < endChunk)\n {\n        chunkPos = pos;\n\n /* get the chunk type */\n if ((result = NextChunk(pDLSData, &pos, &temp, &size)) != EAS_SUCCESS)\n return result;\n\n /* parse useful chunks */\n switch (temp)\n {\n case CHUNK_WSMP:\n                wsmpPos = chunkPos + 8;\n break;\n\n case CHUNK_FMT:\n                fmtPos = chunkPos + 8;\n break;\n\n case CHUNK_DATA:\n                dataPos = chunkPos + 8;\n                dataSize = size;\n break;\n\n default:\n break;\n }\n\n     }\n \n    if (dataSize > MAX_DLS_WAVE_SIZE)\n     {\n         return EAS_ERROR_SOUND_LIBRARY;\n     }\n\n /* for first pass, use temporary variable */\n if (pDLSData->pDLS == NULL)\n        p = &wsmp;\n else\n        p = &pDLSData->wsmpData[waveIndex];\n\n /* set the defaults */\n    p->fineTune = 0;\n    p->unityNote = 60;\n    p->gain = 0;\n    p->loopStart = 0;\n    p->loopLength = 0;\n\n /* must have a fmt chunk */\n if (!fmtPos)\n {\n { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, \"DLS wave chunk has no fmt chunk\\n\"); */ }\n return EAS_ERROR_UNRECOGNIZED_FORMAT;\n }\n\n /* must have a data chunk */\n if (!dataPos)\n {\n { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, \"DLS wave chunk has no data chunk\\n\"); */ }\n return EAS_ERROR_UNRECOGNIZED_FORMAT;\n }\n\n /* parse the wsmp chunk */\n if (wsmpPos)\n {\n if ((result = Parse_wsmp(pDLSData, wsmpPos, p)) != EAS_SUCCESS)\n return result;\n }\n\n /* parse the fmt chunk */\n if ((result = Parse_fmt(pDLSData, fmtPos, p)) != EAS_SUCCESS)\n return result;\n\n /* calculate the size of the wavetable needed. We need only half\n     * the memory for 16-bit samples when in 8-bit mode, and we need\n     * double the memory for 8-bit samples in 16-bit mode. For\n     * unlooped samples, we may use ADPCM. If so, we need only 1/4\n     * the memory.\n     *\n     * We also need to add one for looped samples to allow for\n     * the first sample to be copied to the end of the loop.\n     */\n\n /* use ADPCM encode for unlooped 16-bit samples if ADPCM is enabled */\n /*lint -e{506} -e{774} groundwork for future version to support 8 & 16 bit */\n if (bitDepth == 8)\n {\n if (p->bitsPerSample == 8)\n            size = dataSize;\n else\n /*lint -e{704} use shift for performance */\n            size = dataSize >> 1;\n if (p->loopLength)\n            size++;\n }\n\n else\n {\n if (p->bitsPerSample == 16)\n            size = dataSize;\n else\n /*lint -e{703} use shift for performance */\n            size = dataSize << 1;\n if (p->loopLength)\n            size += 2;\n }\n\n /* for first pass, add size to wave pool size and return */\n if (pDLSData->pDLS == NULL)\n {\n        pDLSData->wavePoolSize += (EAS_U32) size;\n return EAS_SUCCESS;\n }\n\n /* allocate memory and read in the sample data */\n    pSample = pDLSData->pDLS->pDLSSamples + pDLSData->wavePoolOffset;\n    pDLSData->pDLS->pDLSSampleOffsets[waveIndex] = pDLSData->wavePoolOffset;\n    pDLSData->pDLS->pDLSSampleLen[waveIndex] = (EAS_U32) size;\n    pDLSData->wavePoolOffset += (EAS_U32) size;\n if (pDLSData->wavePoolOffset > pDLSData->wavePoolSize)\n {\n { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, \"Wave pool exceeded allocation\\n\"); */ }\n return EAS_ERROR_SOUND_LIBRARY;\n }\n\n if ((result = Parse_data(pDLSData, dataPos, dataSize, p, pSample)) != EAS_SUCCESS)\n return result;\n\n return EAS_SUCCESS;\n}\n", "target": 1, "idx": 187378}
{"func": " xmlXPathNextPreceding(xmlXPathParserContextPtr ctxt, xmlNodePtr cur)\n {\n     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);\n    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||\n\t(ctxt->context->node->type == XML_NAMESPACE_DECL))\n\treturn(NULL);\n    if (cur == NULL)\n         cur = ctxt->context->node;\n     if (cur == NULL)\n \treturn (NULL);\n     if ((cur->prev != NULL) && (cur->prev->type == XML_DTD_NODE))\n\tcur = cur->prev;\n    do {\n        if (cur->prev != NULL) {\n            for (cur = cur->prev; cur->last != NULL; cur = cur->last) ;\n            return (cur);\n        }\n\n        cur = cur->parent;\n        if (cur == NULL)\n            return (NULL);\n        if (cur == ctxt->context->doc->children)\n            return (NULL);\n    } while (xmlXPathIsAncestor(cur, ctxt->context->node));\n    return (cur);\n}\n", "target": 1, "idx": 183428}
{"func": " void FrameFetchContext::DispatchDidBlockRequest(\n     const ResourceRequest& resource_request,\n     const FetchInitiatorInfo& fetch_initiator_info,\n    ResourceRequestBlockedReason blocked_reason) const {\n   if (IsDetached())\n     return;\n   probe::didBlockRequest(GetFrame()->GetDocument(), resource_request,\n                          MasterDocumentLoader(), fetch_initiator_info,\n                         blocked_reason);\n }\n", "target": 1, "idx": 186441}
{"func": "static void php_wddx_process_data(void *user_data, const XML_Char *s, int len)\n{\n\tst_entry *ent;\n\twddx_stack *stack = (wddx_stack *)user_data;\n\tTSRMLS_FETCH();\n\n\tif (!wddx_stack_is_empty(stack) && !stack->done) {\n\t\twddx_stack_top(stack, (void**)&ent);\n\t\tswitch (ent->type) {\n\t\t\tcase ST_STRING:\n\t\t\t\tif (Z_STRLEN_P(ent->data) == 0) {\n\t\t\t\t\tSTR_FREE(Z_STRVAL_P(ent->data));\n\t\t\t\t\tZ_STRVAL_P(ent->data) = estrndup(s, len);\n\t\t\t\t\tZ_STRLEN_P(ent->data) = len;\n\t\t\t\t} else {\n\t\t\t\t\tZ_STRVAL_P(ent->data) = erealloc(Z_STRVAL_P(ent->data), Z_STRLEN_P(ent->data) + len + 1);\n\t\t\t\t\tmemcpy(Z_STRVAL_P(ent->data) + Z_STRLEN_P(ent->data), s, len);\n\t\t\t\t\tZ_STRLEN_P(ent->data) += len;\n\t\t\t\t\tZ_STRVAL_P(ent->data)[Z_STRLEN_P(ent->data)] = '\\0';\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase ST_BINARY:\n\t\t\t\tif (Z_STRLEN_P(ent->data) == 0) {\n\t\t\t\t\tSTR_FREE(Z_STRVAL_P(ent->data));\n\t\t\t\t\tZ_STRVAL_P(ent->data) = estrndup(s, len + 1);\n\t\t\t\t} else {\n\t\t\t\t\tZ_STRVAL_P(ent->data) = erealloc(Z_STRVAL_P(ent->data), Z_STRLEN_P(ent->data) + len + 1);\n\t\t\t\t\tmemcpy(Z_STRVAL_P(ent->data) + Z_STRLEN_P(ent->data), s, len);\n\t\t\t\t}\n\t\t\t\tZ_STRLEN_P(ent->data) += len;\n\t\t\t\tZ_STRVAL_P(ent->data)[Z_STRLEN_P(ent->data)] = '\\0';\n\t\t\t\tbreak;\n\n\t\t\tcase ST_NUMBER:\n\t\t\t\tZ_TYPE_P(ent->data) = IS_STRING;\n\t\t\t\tZ_STRLEN_P(ent->data) = len;\n\t\t\t\tZ_STRVAL_P(ent->data) = estrndup(s, len);\n\t\t\t\tconvert_scalar_to_number(ent->data TSRMLS_CC);\n \t\t\t\tbreak;\n \n \t\t\tcase ST_BOOLEAN:\n \t\t\t\tif (!strcmp(s, \"true\")) {\n \t\t\t\t\tZ_LVAL_P(ent->data) = 1;\n \t\t\t\t} else if (!strcmp(s, \"false\")) {\n\t\t\t\t\tZ_LVAL_P(ent->data) = 0;\n\t\t\t\t} else {\n \t\t\t\t\tzval_ptr_dtor(&ent->data);\n \t\t\t\t\tif (ent->varname) {\n \t\t\t\t\t\tefree(ent->varname);\n \t\t\t\t\t}\n \t\t\t\t\tent->data = NULL;\n \t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase ST_DATETIME: {\n\t\t\t\tchar *tmp;\n\n\t\t\t\ttmp = emalloc(len + 1);\n\t\t\t\tmemcpy(tmp, s, len);\n\t\t\t\ttmp[len] = '\\0';\n\n\t\t\t\tZ_LVAL_P(ent->data) = php_parse_date(tmp, NULL);\n\t\t\t\t/* date out of range < 1969 or > 2038 */\n\t\t\t\tif (Z_LVAL_P(ent->data) == -1) {\n\t\t\t\t\tZ_TYPE_P(ent->data) = IS_STRING;\n\t\t\t\t\tZ_STRLEN_P(ent->data) = len;\n\t\t\t\t\tZ_STRVAL_P(ent->data) = estrndup(s, len);\n\t\t\t\t}\n\t\t\t\tefree(tmp);\n\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n", "target": 1, "idx": 180196}
{"func": "bool IsIDNComponentSafe(const char16* str,\n                        int str_len,\n                        const std::wstring& languages) {\n\n  UErrorCode status = U_ZERO_ERROR;\n#ifdef U_WCHAR_IS_UTF16\n  icu::UnicodeSet dangerous_characters(icu::UnicodeString(\n      L\"[[\\\\ \\u00bc\\u00bd\\u01c3\\u0337\\u0338\"\n      L\"\\u05c3\\u05f4\\u06d4\\u0702\\u115f\\u1160][\\u2000-\\u200b]\"\n      L\"[\\u2024\\u2027\\u2028\\u2029\\u2039\\u203a\\u2044\\u205f]\"\n      L\"[\\u2154-\\u2156][\\u2159-\\u215b][\\u215f\\u2215\\u23ae\"\n      L\"\\u29f6\\u29f8\\u2afb\\u2afd][\\u2ff0-\\u2ffb][\\u3014\"\n      L\"\\u3015\\u3033\\u3164\\u321d\\u321e\\u33ae\\u33af\\u33c6\\u33df\\ufe14\"\n      L\"\\ufe15\\ufe3f\\ufe5d\\ufe5e\\ufeff\\uff0e\\uff06\\uff61\\uffa0\\ufff9]\"\n      L\"[\\ufffa-\\ufffd]]\"), status);\n#else\n  icu::UnicodeSet dangerous_characters(icu::UnicodeString(\n      \"[[\\\\u0020\\\\u00bc\\\\u00bd\\\\u01c3\\\\u0337\\\\u0338\"\n      \"\\\\u05c3\\\\u05f4\\\\u06d4\\\\u0702\\\\u115f\\\\u1160][\\\\u2000-\\\\u200b]\"\n      \"[\\\\u2024\\\\u2027\\\\u2028\\\\u2029\\\\u2039\\\\u203a\\\\u2044\\\\u205f]\"\n      \"[\\\\u2154-\\\\u2156][\\\\u2159-\\\\u215b][\\\\u215f\\\\u2215\\\\u23ae\"\n      \"\\\\u29f6\\\\u29f8\\\\u2afb\\\\u2afd][\\\\u2ff0-\\\\u2ffb][\\\\u3014\"\n      \"\\\\u3015\\\\u3033\\\\u3164\\\\u321d\\\\u321e\\\\u33ae\\\\u33af\\\\u33c6\\\\u33df\\\\ufe14\"\n      \"\\\\ufe15\\\\ufe3f\\\\ufe5d\\\\ufe5e\\\\ufeff\\\\uff0e\\\\uff06\\\\uff61\\\\uffa0\\\\ufff9]\"\n      \"[\\\\ufffa-\\\\ufffd]]\", -1, US_INV), status);\n#endif\n  DCHECK(U_SUCCESS(status));\n  icu::UnicodeSet component_characters;\n  component_characters.addAll(icu::UnicodeString(str, str_len));\n  if (dangerous_characters.containsSome(component_characters))\n    return false;\n\n  if (languages.empty())\n    return IsIDNComponentInSingleScript(str, str_len);\n\n  icu::UnicodeSet common_characters(UNICODE_STRING_SIMPLE(\"[[0-9]\\\\-_+\\\\ ]\"),\n                                    status);\n  DCHECK(U_SUCCESS(status));\n  component_characters.removeAll(common_characters);\n\n  std::string languages_list(WideToASCII(languages));\n  StringTokenizer t(languages_list, \",\");\n  while (t.GetNext()) {\n    if (IsComponentCoveredByLang(component_characters, t.token()))\n      return true;\n  }\n  return false;\n}\n", "target": 0, "idx": 100082}
{"func": "static int handle_init(struct fuse* fuse, struct fuse_handler* handler,\n const struct fuse_in_header* hdr, const struct fuse_init_in* req)\n{\n struct fuse_init_out out;\n size_t fuse_struct_size;\n\n    TRACE(\"[%d] INIT ver=%d.%d maxread=%d flags=%x\\n\",\n            handler->token, req->major, req->minor, req->max_readahead, req->flags);\n\n /* Kernel 2.6.16 is the first stable kernel with struct fuse_init_out\n     * defined (fuse version 7.6). The structure is the same from 7.6 through\n     * 7.22. Beginning with 7.23, the structure increased in size and added\n     * new parameters.\n     */\n if (req->major != FUSE_KERNEL_VERSION || req->minor < 6) {\n        ERROR(\"Fuse kernel version mismatch: Kernel version %d.%d, Expected at least %d.6\",\n              req->major, req->minor, FUSE_KERNEL_VERSION);\n return -1;\n }\n\n /* We limit ourselves to 15 because we don't handle BATCH_FORGET yet */\n    out.minor = MIN(req->minor, 15);\n    fuse_struct_size = sizeof(out);\n#if defined(FUSE_COMPAT_22_INIT_OUT_SIZE)\n /* FUSE_KERNEL_VERSION >= 23. */\n\n /* If the kernel only works on minor revs older than or equal to 22,\n     * then use the older structure size since this code only uses the 7.22\n     * version of the structure. */\n if (req->minor <= 22) {\n        fuse_struct_size = FUSE_COMPAT_22_INIT_OUT_SIZE;\n }\n#endif\n\n    out.major = FUSE_KERNEL_VERSION;\n    out.max_readahead = req->max_readahead;\n    out.flags = FUSE_ATOMIC_O_TRUNC | FUSE_BIG_WRITES;\n    out.max_background = 32;\n    out.congestion_threshold = 32;\n    out.max_write = MAX_WRITE;\n    fuse_reply(fuse, hdr->unique, &out, fuse_struct_size);\n return NO_STATUS;\n}\n", "target": 0, "idx": 173741}
{"func": "static int __hw_addr_sync(struct netdev_hw_addr_list *to_list,\n\t\t\t  struct netdev_hw_addr_list *from_list,\n\t\t\t  int addr_len)\n{\n\tint err = 0;\n\tstruct netdev_hw_addr *ha, *tmp;\n\n\tlist_for_each_entry_safe(ha, tmp, &from_list->list, list) {\n\t\tif (!ha->synced) {\n\t\t\terr = __hw_addr_add(to_list, ha->addr,\n\t\t\t\t\t    addr_len, ha->type);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tha->synced = true;\n\t\t\tha->refcount++;\n\t\t} else if (ha->refcount == 1) {\n\t\t\t__hw_addr_del(to_list, ha->addr, addr_len, ha->type);\n\t\t\t__hw_addr_del(from_list, ha->addr, addr_len, ha->type);\n\t\t}\n\t}\n\treturn err;\n}\n", "target": 0, "idx": 32074}
{"func": " void RenderViewImpl::didActivateCompositor(int input_handler_identifier) {\n   CompositorThread* compositor_thread =\n       RenderThreadImpl::current()->compositor_thread();\n   if (compositor_thread)\n     compositor_thread->AddInputHandler(\n         routing_id_, input_handler_identifier, AsWeakPtr());\n \n   RenderWidget::didActivateCompositor(input_handler_identifier);\n \n  ProcessAcceleratedPinchZoomFlags(*CommandLine::ForCurrentProcess());\n}\n", "target": 1, "idx": 185177}
{"func": "void Microtask::performCheckpoint()\n {\n    v8::Isolate* isolate = v8::Isolate::GetCurrent();\n     V8PerIsolateData* isolateData = V8PerIsolateData::from(isolate);\n     ASSERT(isolateData);\n     if (isolateData->recursionLevel() || isolateData->performingMicrotaskCheckpoint() || isolateData->destructionPending() || ScriptForbiddenScope::isScriptForbidden())\n        return;\n    isolateData->setPerformingMicrotaskCheckpoint(true);\n    {\n        V8RecursionScope recursionScope(isolate);\n        isolate->RunMicrotasks();\n    }\n    isolateData->setPerformingMicrotaskCheckpoint(false);\n}\n", "target": 1, "idx": 185823}
{"func": "int rdma_listen(struct rdma_cm_id *id, int backlog)\n{\n\tstruct rdma_id_private *id_priv;\n\tint ret;\n\n\tid_priv = container_of(id, struct rdma_id_private, id);\n\tif (id_priv->state == RDMA_CM_IDLE) {\n\t\tid->route.addr.src_addr.ss_family = AF_INET;\n\t\tret = rdma_bind_addr(id, cma_src_addr(id_priv));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (!cma_comp_exch(id_priv, RDMA_CM_ADDR_BOUND, RDMA_CM_LISTEN))\n\t\treturn -EINVAL;\n\n\tif (id_priv->reuseaddr) {\n\t\tret = cma_bind_listen(id_priv);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tid_priv->backlog = backlog;\n\tif (id->device) {\n\t\tswitch (rdma_node_get_transport(id->device->node_type)) {\n\t\tcase RDMA_TRANSPORT_IB:\n\t\t\tret = cma_ib_listen(id_priv);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t\tbreak;\n\t\tcase RDMA_TRANSPORT_IWARP:\n\t\t\tret = cma_iw_listen(id_priv, backlog);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -ENOSYS;\n\t\t\tgoto err;\n\t\t}\n\t} else\n\t\tcma_listen_on_all(id_priv);\n\n\treturn 0;\nerr:\n\tid_priv->backlog = 0;\n\tcma_comp_exch(id_priv, RDMA_CM_LISTEN, RDMA_CM_ADDR_BOUND);\n\treturn ret;\n}\n", "target": 0, "idx": 38553}
{"func": "void WebPageProxy::didChangeProgress(double value)\n{\n    m_estimatedProgress = value;\n\n    m_loaderClient.didChangeProgress(this);\n}\n", "target": 0, "idx": 106469}
{"func": "create_watching_parent (void)\n{\n  pid_t child;\n  sigset_t ourset;\n  struct sigaction oldact[3];\n  int status = 0;\n  int retval;\n\n  retval = pam_open_session (pamh, 0);\n  if (is_pam_failure(retval))\n    {\n      cleanup_pam (retval);\n      errx (EXIT_FAILURE, _(\"cannot open session: %s\"),\n\t     pam_strerror (pamh, retval));\n    }\n  else\n    _pam_session_opened = 1;\n\n  memset(oldact, 0, sizeof(oldact));\n\n  child = fork ();\n  if (child == (pid_t) -1)\n    {\n      cleanup_pam (PAM_ABORT);\n      err (EXIT_FAILURE, _(\"cannot create child process\"));\n    }\n\n  /* the child proceeds to run the shell */\n  if (child == 0)\n    return;\n\n  /* In the parent watch the child.  */\n\n  /* su without pam support does not have a helper that keeps\n     sitting on any directory so let's go to /.  */\n  if (chdir (\"/\") != 0)\n    warn (_(\"cannot change directory to %s\"), \"/\");\n\n  sigfillset (&ourset);\n  if (sigprocmask (SIG_BLOCK, &ourset, NULL))\n    {\n      warn (_(\"cannot block signals\"));\n      caught_signal = true;\n    }\n  if (!caught_signal)\n    {\n      struct sigaction action;\n      action.sa_handler = su_catch_sig;\n      sigemptyset (&action.sa_mask);\n      action.sa_flags = 0;\n      sigemptyset (&ourset);\n    if (!same_session)\n      {\n        if (sigaddset(&ourset, SIGINT) || sigaddset(&ourset, SIGQUIT))\n          {\n            warn (_(\"cannot set signal handler\"));\n            caught_signal = true;\n          }\n      }\n    if (!caught_signal && (sigaddset(&ourset, SIGTERM)\n                    || sigaddset(&ourset, SIGALRM)\n                    || sigaction(SIGTERM, &action, &oldact[0])\n                    || sigprocmask(SIG_UNBLOCK, &ourset, NULL))) {\n\t  warn (_(\"cannot set signal handler\"));\n\t  caught_signal = true;\n\t}\n    if (!caught_signal && !same_session && (sigaction(SIGINT, &action, &oldact[1])\n                                     || sigaction(SIGQUIT, &action, &oldact[2])))\n      {\n        warn (_(\"cannot set signal handler\"));\n        caught_signal = true;\n      }\n    }\n  if (!caught_signal)\n    {\n      pid_t pid;\n      for (;;)\n\t{\n\t  pid = waitpid (child, &status, WUNTRACED);\n\n\t  if (pid != (pid_t)-1 && WIFSTOPPED (status))\n\t    {\n\t      kill (getpid (), SIGSTOP);\n\t      /* once we get here, we must have resumed */\n\t      kill (pid, SIGCONT);\n\t    }\n\t  else\n\t    break;\n\t}\n      if (pid != (pid_t)-1)\n        {\n          if (WIFSIGNALED (status))\n            {\n              fprintf (stderr, \"%s%s\\n\", strsignal (WTERMSIG (status)),\n                       WCOREDUMP (status) ? _(\" (core dumped)\") : \"\");\n              status = WTERMSIG (status) + 128;\n             }\n           else\n             status = WEXITSTATUS (status);\n         }\n       else if (caught_signal)\n         status = caught_signal + 128;\n      else\n        status = 1;\n    }\n   else\n     status = 1;\n \n  if (caught_signal)\n     {\n       fprintf (stderr, _(\"\\nSession terminated, killing shell...\"));\n       kill (child, SIGTERM);\n    }\n\n  cleanup_pam (PAM_SUCCESS);\n \n   if (caught_signal)\n     {\n      sleep (2);\n      kill (child, SIGKILL);\n      fprintf (stderr, _(\" ...killed.\\n\"));\n \n       /* Let's terminate itself with the received signal.\n        *\n       * It seems that shells use WIFSIGNALED() rather than our exit status\n       * value to detect situations when is necessary to cleanup (reset)\n       * terminal settings (kzak -- Jun 2013).\n       */\n      switch (caught_signal) {\n        case SIGTERM:\n          sigaction(SIGTERM, &oldact[0], NULL);\n          break;\n        case SIGINT:\n          sigaction(SIGINT, &oldact[1], NULL);\n          break;\n        case SIGQUIT:\n          sigaction(SIGQUIT, &oldact[2], NULL);\n          break;\n        default:\n\t  /* just in case that signal stuff initialization failed and\n\t   * caught_signal = true */\n          caught_signal = SIGKILL;\n          break;\n      }\n      kill(getpid(), caught_signal);\n    }\n  exit (status);\n}\n", "target": 1, "idx": 182607}
{"func": "static unsigned char *AcquireCompactPixels(const Image *image,\n  ExceptionInfo *exception)\n{\n  size_t\n    packet_size;\n\n  unsigned char\n    *compact_pixels;\n\n  packet_size=image->depth > 8UL ? 2UL : 1UL;\n  compact_pixels=(unsigned char *) AcquireQuantumMemory((9*\n    image->columns)+1,packet_size*sizeof(*compact_pixels));\n   if (compact_pixels == (unsigned char *) NULL)\n     {\n       (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\n        image->filename);\n     }\n   return(compact_pixels);\n }\n", "target": 1, "idx": 181575}
{"func": "static __be32 *reserve_space(struct xdr_stream *xdr, size_t nbytes)\n{\n\t__be32 *p = xdr_reserve_space(xdr, nbytes);\n\tBUG_ON(!p);\n\treturn p;\n}\n", "target": 0, "idx": 23503}
{"func": "put_queue_get_config_reply(struct ofport *port, uint32_t queue,\n                           struct ovs_list *replies)\n{\n    struct ofputil_queue_config qc;\n\n    /* None of the existing queues have compatible properties, so we hard-code\n     * omitting min_rate and max_rate. */\n    qc.port = port->ofp_port;\n    qc.queue = queue;\n    qc.min_rate = UINT16_MAX;\n    qc.max_rate = UINT16_MAX;\n    ofputil_append_queue_get_config_reply(&qc, replies);\n}\n", "target": 0, "idx": 77413}
{"func": "int sched_rt_handler(struct ctl_table *table, int write,\n\t\tvoid __user *buffer, size_t *lenp,\n\t\tloff_t *ppos)\n{\n\tint ret;\n\tint old_period, old_runtime;\n\tstatic DEFINE_MUTEX(mutex);\n\n\tmutex_lock(&mutex);\n\told_period = sysctl_sched_rt_period;\n\told_runtime = sysctl_sched_rt_runtime;\n\n\tret = proc_dointvec(table, write, buffer, lenp, ppos);\n\n\tif (!ret && write) {\n\t\tret = sched_rt_global_constraints();\n\t\tif (ret) {\n\t\t\tsysctl_sched_rt_period = old_period;\n\t\t\tsysctl_sched_rt_runtime = old_runtime;\n\t\t} else {\n\t\t\tdef_rt_bandwidth.rt_runtime = global_rt_runtime();\n\t\t\tdef_rt_bandwidth.rt_period =\n\t\t\t\tns_to_ktime(global_rt_period());\n\t\t}\n\t}\n\tmutex_unlock(&mutex);\n\n\treturn ret;\n}\n", "target": 0, "idx": 22568}
{"func": "static inline int compute_score2(struct sock *sk, struct net *net,\n\t\t\t\t const struct in6_addr *saddr, __be16 sport,\n\t\t\t\t const struct in6_addr *daddr,\n\t\t\t\t unsigned short hnum, int dif)\n{\n\tint score;\n\tstruct inet_sock *inet;\n\n\tif (!net_eq(sock_net(sk), net) ||\n\t    udp_sk(sk)->udp_port_hash != hnum ||\n\t    sk->sk_family != PF_INET6)\n\t\treturn -1;\n\n\tif (!ipv6_addr_equal(&sk->sk_v6_rcv_saddr, daddr))\n\t\treturn -1;\n\n\tscore = 0;\n\tinet = inet_sk(sk);\n\n\tif (inet->inet_dport) {\n\t\tif (inet->inet_dport != sport)\n\t\t\treturn -1;\n\t\tscore++;\n\t}\n\n\tif (!ipv6_addr_any(&sk->sk_v6_daddr)) {\n\t\tif (!ipv6_addr_equal(&sk->sk_v6_daddr, saddr))\n\t\t\treturn -1;\n\t\tscore++;\n\t}\n\n\tif (sk->sk_bound_dev_if) {\n\t\tif (sk->sk_bound_dev_if != dif)\n\t\t\treturn -1;\n\t\tscore++;\n\t}\n\n\tif (sk->sk_incoming_cpu == raw_smp_processor_id())\n\t\tscore++;\n\n\treturn score;\n}\n", "target": 0, "idx": 53737}
{"func": "void blk_mq_rq_timed_out(struct request *req, bool reserved)\n{\n\tstruct blk_mq_ops *ops = req->q->mq_ops;\n\tenum blk_eh_timer_return ret = BLK_EH_RESET_TIMER;\n\n\t/*\n\t * We know that complete is set at this point. If STARTED isn't set\n\t * anymore, then the request isn't active and the \"timeout\" should\n\t * just be ignored. This can happen due to the bitflag ordering.\n\t * Timeout first checks if STARTED is set, and if it is, assumes\n\t * the request is active. But if we race with completion, then\n\t * we both flags will get cleared. So check here again, and ignore\n\t * a timeout event with a request that isn't active.\n\t */\n\tif (!test_bit(REQ_ATOM_STARTED, &req->atomic_flags))\n\t\treturn;\n\n\tif (ops->timeout)\n\t\tret = ops->timeout(req, reserved);\n\n\tswitch (ret) {\n\tcase BLK_EH_HANDLED:\n\t\t__blk_mq_complete_request(req);\n\t\tbreak;\n\tcase BLK_EH_RESET_TIMER:\n\t\tblk_add_timer(req);\n\t\tblk_clear_rq_complete(req);\n\t\tbreak;\n\tcase BLK_EH_NOT_HANDLED:\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"block: bad eh return: %d\\n\", ret);\n\t\tbreak;\n\t}\n}\n", "target": 0, "idx": 86735}
{"func": "static int exception_type(int vector)\n{\n\tunsigned int mask;\n\n\tif (WARN_ON(vector > 31 || vector == NMI_VECTOR))\n\t\treturn EXCPT_INTERRUPT;\n\n\tmask = 1 << vector;\n\n\t/* #DB is trap, as instruction watchpoints are handled elsewhere */\n\tif (mask & ((1 << DB_VECTOR) | (1 << BP_VECTOR) | (1 << OF_VECTOR)))\n\t\treturn EXCPT_TRAP;\n\n\tif (mask & ((1 << DF_VECTOR) | (1 << MC_VECTOR)))\n\t\treturn EXCPT_ABORT;\n\n\t/* Reserved exceptions will result in fault */\n\treturn EXCPT_FAULT;\n}\n", "target": 0, "idx": 35764}
{"func": "static STGMEDIUM* GetStorageForFileDescriptor(\n    const base::FilePath& path) {\n   base::string16 file_name = path.value();\n   DCHECK(!file_name.empty());\n   HANDLE hdata = GlobalAlloc(GPTR, sizeof(FILEGROUPDESCRIPTOR));\n  base::win::ScopedHGlobal<FILEGROUPDESCRIPTOR> locked_mem(hdata);\n \n   FILEGROUPDESCRIPTOR* descriptor = locked_mem.get();\n   descriptor->cItems = 1;\n  descriptor->fgd[0].dwFlags = FD_LINKUI;\n  wcsncpy_s(descriptor->fgd[0].cFileName, MAX_PATH, file_name.c_str(),\n            std::min(file_name.size(), static_cast<size_t>(MAX_PATH - 1u)));\n\n  STGMEDIUM* storage = new STGMEDIUM;\n  storage->tymed = TYMED_HGLOBAL;\n  storage->hGlobal = hdata;\n  storage->pUnkForRelease = NULL;\n  return storage;\n}\n", "target": 1, "idx": 185446}
{"func": " static void __noclone vmx_vcpu_run(struct kvm_vcpu *vcpu)\n {\n \tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long debugctlmsr;\n \n \t/* Record the guest's net vcpu time for enforced NMI injections. */\n \tif (unlikely(!cpu_has_virtual_nmis() && vmx->soft_vnmi_blocked))\n\t\tvmx->entry_time = ktime_get();\n\n\t/* Don't enter VMX if guest state is invalid, let the exit handler\n\t   start emulation until we arrive back to a valid state */\n\tif (vmx->emulation_required)\n\t\treturn;\n\n\tif (vmx->ple_window_dirty) {\n\t\tvmx->ple_window_dirty = false;\n\t\tvmcs_write32(PLE_WINDOW, vmx->ple_window);\n\t}\n\n\tif (vmx->nested.sync_shadow_vmcs) {\n\t\tcopy_vmcs12_to_shadow(vmx);\n\t\tvmx->nested.sync_shadow_vmcs = false;\n\t}\n\n\tif (test_bit(VCPU_REGS_RSP, (unsigned long *)&vcpu->arch.regs_dirty))\n\t\tvmcs_writel(GUEST_RSP, vcpu->arch.regs[VCPU_REGS_RSP]);\n \tif (test_bit(VCPU_REGS_RIP, (unsigned long *)&vcpu->arch.regs_dirty))\n \t\tvmcs_writel(GUEST_RIP, vcpu->arch.regs[VCPU_REGS_RIP]);\n \n \t/* When single-stepping over STI and MOV SS, we must clear the\n \t * corresponding interruptibility bits in the guest state. Otherwise\n \t * vmentry fails as it then expects bit 14 (BS) in pending debug\n\t * exceptions being set, but that's not correct for the guest debugging\n\t * case. */\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)\n\t\tvmx_set_interrupt_shadow(vcpu, 0);\n\n\tatomic_switch_perf_msrs(vmx);\n\tdebugctlmsr = get_debugctlmsr();\n\n\tvmx->__launched = vmx->loaded_vmcs->launched;\n\tasm(\n\t\t/* Store host registers */\n\t\t\"push %%\" _ASM_DX \"; push %%\" _ASM_BP \";\"\n\t\t\"push %%\" _ASM_CX \" \\n\\t\" /* placeholder for guest rcx */\n\t\t\"push %%\" _ASM_CX \" \\n\\t\"\n\t\t\"cmp %%\" _ASM_SP \", %c[host_rsp](%0) \\n\\t\"\n\t\t\"je 1f \\n\\t\"\n\t\t\"mov %%\" _ASM_SP \", %c[host_rsp](%0) \\n\\t\"\n\t\t__ex(ASM_VMX_VMWRITE_RSP_RDX) \"\\n\\t\"\n\t\t\"1: \\n\\t\"\n\t\t/* Reload cr2 if changed */\n\t\t\"mov %c[cr2](%0), %%\" _ASM_AX \" \\n\\t\"\n\t\t\"mov %%cr2, %%\" _ASM_DX \" \\n\\t\"\n\t\t\"cmp %%\" _ASM_AX \", %%\" _ASM_DX \" \\n\\t\"\n\t\t\"je 2f \\n\\t\"\n\t\t\"mov %%\" _ASM_AX\", %%cr2 \\n\\t\"\n\t\t\"2: \\n\\t\"\n\t\t/* Check if vmlaunch of vmresume is needed */\n\t\t\"cmpl $0, %c[launched](%0) \\n\\t\"\n\t\t/* Load guest registers.  Don't clobber flags. */\n\t\t\"mov %c[rax](%0), %%\" _ASM_AX \" \\n\\t\"\n\t\t\"mov %c[rbx](%0), %%\" _ASM_BX \" \\n\\t\"\n\t\t\"mov %c[rdx](%0), %%\" _ASM_DX \" \\n\\t\"\n\t\t\"mov %c[rsi](%0), %%\" _ASM_SI \" \\n\\t\"\n\t\t\"mov %c[rdi](%0), %%\" _ASM_DI \" \\n\\t\"\n\t\t\"mov %c[rbp](%0), %%\" _ASM_BP \" \\n\\t\"\n#ifdef CONFIG_X86_64\n\t\t\"mov %c[r8](%0),  %%r8  \\n\\t\"\n\t\t\"mov %c[r9](%0),  %%r9  \\n\\t\"\n\t\t\"mov %c[r10](%0), %%r10 \\n\\t\"\n\t\t\"mov %c[r11](%0), %%r11 \\n\\t\"\n\t\t\"mov %c[r12](%0), %%r12 \\n\\t\"\n\t\t\"mov %c[r13](%0), %%r13 \\n\\t\"\n\t\t\"mov %c[r14](%0), %%r14 \\n\\t\"\n\t\t\"mov %c[r15](%0), %%r15 \\n\\t\"\n#endif\n\t\t\"mov %c[rcx](%0), %%\" _ASM_CX \" \\n\\t\" /* kills %0 (ecx) */\n\n\t\t/* Enter guest mode */\n\t\t\"jne 1f \\n\\t\"\n\t\t__ex(ASM_VMX_VMLAUNCH) \"\\n\\t\"\n\t\t\"jmp 2f \\n\\t\"\n\t\t\"1: \" __ex(ASM_VMX_VMRESUME) \"\\n\\t\"\n\t\t\"2: \"\n\t\t/* Save guest registers, load host registers, keep flags */\n\t\t\"mov %0, %c[wordsize](%%\" _ASM_SP \") \\n\\t\"\n\t\t\"pop %0 \\n\\t\"\n\t\t\"mov %%\" _ASM_AX \", %c[rax](%0) \\n\\t\"\n\t\t\"mov %%\" _ASM_BX \", %c[rbx](%0) \\n\\t\"\n\t\t__ASM_SIZE(pop) \" %c[rcx](%0) \\n\\t\"\n\t\t\"mov %%\" _ASM_DX \", %c[rdx](%0) \\n\\t\"\n\t\t\"mov %%\" _ASM_SI \", %c[rsi](%0) \\n\\t\"\n\t\t\"mov %%\" _ASM_DI \", %c[rdi](%0) \\n\\t\"\n\t\t\"mov %%\" _ASM_BP \", %c[rbp](%0) \\n\\t\"\n#ifdef CONFIG_X86_64\n\t\t\"mov %%r8,  %c[r8](%0) \\n\\t\"\n\t\t\"mov %%r9,  %c[r9](%0) \\n\\t\"\n\t\t\"mov %%r10, %c[r10](%0) \\n\\t\"\n\t\t\"mov %%r11, %c[r11](%0) \\n\\t\"\n\t\t\"mov %%r12, %c[r12](%0) \\n\\t\"\n\t\t\"mov %%r13, %c[r13](%0) \\n\\t\"\n\t\t\"mov %%r14, %c[r14](%0) \\n\\t\"\n\t\t\"mov %%r15, %c[r15](%0) \\n\\t\"\n#endif\n\t\t\"mov %%cr2, %%\" _ASM_AX \"   \\n\\t\"\n\t\t\"mov %%\" _ASM_AX \", %c[cr2](%0) \\n\\t\"\n\n\t\t\"pop  %%\" _ASM_BP \"; pop  %%\" _ASM_DX \" \\n\\t\"\n\t\t\"setbe %c[fail](%0) \\n\\t\"\n\t\t\".pushsection .rodata \\n\\t\"\n\t\t\".global vmx_return \\n\\t\"\n\t\t\"vmx_return: \" _ASM_PTR \" 2b \\n\\t\"\n\t\t\".popsection\"\n\t      : : \"c\"(vmx), \"d\"((unsigned long)HOST_RSP),\n\t\t[launched]\"i\"(offsetof(struct vcpu_vmx, __launched)),\n\t\t[fail]\"i\"(offsetof(struct vcpu_vmx, fail)),\n\t\t[host_rsp]\"i\"(offsetof(struct vcpu_vmx, host_rsp)),\n\t\t[rax]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RAX])),\n\t\t[rbx]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RBX])),\n\t\t[rcx]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RCX])),\n\t\t[rdx]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RDX])),\n\t\t[rsi]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RSI])),\n\t\t[rdi]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RDI])),\n\t\t[rbp]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RBP])),\n#ifdef CONFIG_X86_64\n\t\t[r8]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R8])),\n\t\t[r9]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R9])),\n\t\t[r10]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R10])),\n\t\t[r11]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R11])),\n\t\t[r12]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R12])),\n\t\t[r13]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R13])),\n\t\t[r14]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R14])),\n\t\t[r15]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R15])),\n#endif\n\t\t[cr2]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.cr2)),\n\t\t[wordsize]\"i\"(sizeof(ulong))\n\t      : \"cc\", \"memory\"\n#ifdef CONFIG_X86_64\n\t\t, \"rax\", \"rbx\", \"rdi\", \"rsi\"\n\t\t, \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\"\n#else\n\t\t, \"eax\", \"ebx\", \"edi\", \"esi\"\n#endif\n\t      );\n\n\t/* MSR_IA32_DEBUGCTLMSR is zeroed on vmexit. Restore it if needed */\n\tif (debugctlmsr)\n\t\tupdate_debugctlmsr(debugctlmsr);\n\n#ifndef CONFIG_X86_64\n\t/*\n\t * The sysexit path does not restore ds/es, so we must set them to\n\t * a reasonable value ourselves.\n\t *\n\t * We can't defer this to vmx_load_host_state() since that function\n\t * may be executed in interrupt context, which saves and restore segments\n\t * around it, nullifying its effect.\n\t */\n\tloadsegment(ds, __USER_DS);\n\tloadsegment(es, __USER_DS);\n#endif\n\n\tvcpu->arch.regs_avail = ~((1 << VCPU_REGS_RIP) | (1 << VCPU_REGS_RSP)\n\t\t\t\t  | (1 << VCPU_EXREG_RFLAGS)\n\t\t\t\t  | (1 << VCPU_EXREG_PDPTR)\n\t\t\t\t  | (1 << VCPU_EXREG_SEGMENTS)\n\t\t\t\t  | (1 << VCPU_EXREG_CR3));\n\tvcpu->arch.regs_dirty = 0;\n\n\tvmx->idt_vectoring_info = vmcs_read32(IDT_VECTORING_INFO_FIELD);\n\n\tvmx->loaded_vmcs->launched = 1;\n\n\tvmx->exit_reason = vmcs_read32(VM_EXIT_REASON);\n\ttrace_kvm_exit(vmx->exit_reason, vcpu, KVM_ISA_VMX);\n\n\t/*\n\t * the KVM_REQ_EVENT optimization bit is only on for one entry, and if\n\t * we did not inject a still-pending event to L1 now because of\n\t * nested_run_pending, we need to re-enable this bit.\n\t */\n\tif (vmx->nested.nested_run_pending)\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\tvmx->nested.nested_run_pending = 0;\n\n\tvmx_complete_atomic_exit(vmx);\n\tvmx_recover_nmi_blocking(vmx);\n\tvmx_complete_interrupts(vmx);\n}\n", "target": 1, "idx": 179501}
{"func": "int ext4_collapse_range(struct inode *inode, loff_t offset, loff_t len)\n{\n\tstruct super_block *sb = inode->i_sb;\n\text4_lblk_t punch_start, punch_stop;\n\thandle_t *handle;\n\tunsigned int credits;\n\tloff_t new_size, ioffset;\n\tint ret;\n\n\t/*\n\t * We need to test this early because xfstests assumes that a\n\t * collapse range of (0, 1) will return EOPNOTSUPP if the file\n\t * system does not support collapse range.\n\t */\n\tif (!ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\treturn -EOPNOTSUPP;\n\n\t/* Collapse range works only on fs block size aligned offsets. */\n\tif (offset & (EXT4_CLUSTER_SIZE(sb) - 1) ||\n\t    len & (EXT4_CLUSTER_SIZE(sb) - 1))\n\t\treturn -EINVAL;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\n\ttrace_ext4_collapse_range(inode, offset, len);\n\n\tpunch_start = offset >> EXT4_BLOCK_SIZE_BITS(sb);\n\tpunch_stop = (offset + len) >> EXT4_BLOCK_SIZE_BITS(sb);\n\n\t/* Call ext4_force_commit to flush all data in case of data=journal. */\n\tif (ext4_should_journal_data(inode)) {\n\t\tret = ext4_force_commit(inode->i_sb);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * Need to round down offset to be aligned with page size boundary\n\t * for page size > block size.\n\t */\n\tioffset = round_down(offset, PAGE_SIZE);\n\n\t/* Write out all dirty pages */\n\tret = filemap_write_and_wait_range(inode->i_mapping, ioffset,\n\t\t\t\t\t   LLONG_MAX);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Take mutex lock */\n\tmutex_lock(&inode->i_mutex);\n\n\t/*\n\t * There is no need to overlap collapse range with EOF, in which case\n\t * it is effectively a truncate operation\n\t */\n\tif (offset + len >= i_size_read(inode)) {\n\t\tret = -EINVAL;\n\t\tgoto out_mutex;\n\t}\n\n\t/* Currently just for extent based files */\n\tif (!ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tret = -EOPNOTSUPP;\n \t\tgoto out_mutex;\n \t}\n \n\ttruncate_pagecache(inode, ioffset);\n \t/* Wait for existing dio to complete */\n \text4_inode_block_unlocked_dio(inode);\n \tinode_dio_wait(inode);\n \n \tcredits = ext4_writepage_trans_blocks(inode);\n \thandle = ext4_journal_start(inode, EXT4_HT_TRUNCATE, credits);\n \tif (IS_ERR(handle)) {\n \t\tret = PTR_ERR(handle);\n\t\tgoto out_dio;\n \t}\n \n \tdown_write(&EXT4_I(inode)->i_data_sem);\n\text4_discard_preallocations(inode);\n\n\tret = ext4_es_remove_extent(inode, punch_start,\n\t\t\t\t    EXT_MAX_BLOCKS - punch_start);\n\tif (ret) {\n\t\tup_write(&EXT4_I(inode)->i_data_sem);\n\t\tgoto out_stop;\n\t}\n\n\tret = ext4_ext_remove_space(inode, punch_start, punch_stop - 1);\n\tif (ret) {\n\t\tup_write(&EXT4_I(inode)->i_data_sem);\n\t\tgoto out_stop;\n\t}\n\text4_discard_preallocations(inode);\n\n\tret = ext4_ext_shift_extents(inode, handle, punch_stop,\n\t\t\t\t     punch_stop - punch_start, SHIFT_LEFT);\n\tif (ret) {\n\t\tup_write(&EXT4_I(inode)->i_data_sem);\n\t\tgoto out_stop;\n\t}\n\n\tnew_size = i_size_read(inode) - len;\n\ti_size_write(inode, new_size);\n\tEXT4_I(inode)->i_disksize = new_size;\n\n\tup_write(&EXT4_I(inode)->i_data_sem);\n\tif (IS_SYNC(inode))\n\t\text4_handle_sync(handle);\n\tinode->i_mtime = inode->i_ctime = ext4_current_time(inode);\n\text4_mark_inode_dirty(handle, inode);\n \n out_stop:\n \text4_journal_stop(handle);\nout_dio:\n \text4_inode_resume_unlocked_dio(inode);\n out_mutex:\n \tmutex_unlock(&inode->i_mutex);\n\treturn ret;\n}\n", "target": 1, "idx": 180655}
{"func": "bool GeometryMapper::LocalToAncestorVisualRect(\n    const PropertyTreeState& local_state,\n    const PropertyTreeState& ancestor_state,\n    FloatClipRect& mapping_rect,\n    OverlayScrollbarClipBehavior clip_behavior,\n    InclusiveIntersectOrNot inclusive_behavior) {\n  bool success = false;\n  bool result = LocalToAncestorVisualRectInternal(local_state, ancestor_state,\n                                                  mapping_rect, clip_behavior,\n                                                  inclusive_behavior, success);\n  DCHECK(success);\n  return result;\n}\n", "target": 0, "idx": 136496}
{"func": "cib_remote_new(const char *server, const char *user, const char *passwd, int port,\n               gboolean encrypted)\n{\n    cib_remote_opaque_t *private = NULL;\n    cib_t *cib = cib_new_variant();\n\n    private = calloc(1, sizeof(cib_remote_opaque_t));\n\n    cib->variant = cib_remote;\n    cib->variant_opaque = private;\n\n    if (server) {\n        private->server = strdup(server);\n    }\n\n    if (user) {\n        private->user = strdup(user);\n    }\n\n    if (passwd) {\n        private->passwd = strdup(passwd);\n    }\n\n    private->port = port;\n    private->command.encrypted = encrypted;\n    private->callback.encrypted = encrypted;\n\n    /* assign variant specific ops */\n    cib->delegate_fn = cib_remote_perform_op;\n    cib->cmds->signon = cib_remote_signon;\n    cib->cmds->signoff = cib_remote_signoff;\n    cib->cmds->free = cib_remote_free;\n    cib->cmds->inputfd = cib_remote_inputfd;\n\n    cib->cmds->register_notification = cib_remote_register_notification;\n    cib->cmds->set_connection_dnotify = cib_remote_set_connection_dnotify;\n\n    return cib;\n}\n", "target": 0, "idx": 33891}
{"func": "static void virtio_queue_host_notifier_read(EventNotifier *n)\n{\n    VirtQueue *vq = container_of(n, VirtQueue, host_notifier);\n    if (event_notifier_test_and_clear(n)) {\n        virtio_queue_notify_vq(vq);\n    }\n}\n", "target": 0, "idx": 9227}
{"func": "png_reset_zstream(png_structp png_ptr)\n{\n   if (png_ptr == NULL)\n      return Z_STREAM_ERROR;\n   return (inflateReset(&png_ptr->zstream));\n}\n", "target": 0, "idx": 143942}
{"func": "void mq_put_mnt(struct ipc_namespace *ns)\n{\n\tkern_unmount(ns->mq_mnt);\n}\n", "target": 0, "idx": 63528}
{"func": "mldv2_report_print(netdissect_options *ndo, const u_char *bp, u_int len)\n{\n    const struct icmp6_hdr *icp = (const struct icmp6_hdr *) bp;\n    u_int group, nsrcs, ngroups;\n    u_int i, j;\n\n    /* Minimum len is 8 */\n    if (len < 8) {\n            ND_PRINT((ndo,\" [invalid len %d]\", len));\n            return;\n    }\n\n    ND_TCHECK(icp->icmp6_data16[1]);\n    ngroups = EXTRACT_16BITS(&icp->icmp6_data16[1]);\n    ND_PRINT((ndo,\", %d group record(s)\", ngroups));\n    if (ndo->ndo_vflag > 0) {\n\t/* Print the group records */\n\tgroup = 8;\n        for (i = 0; i < ngroups; i++) {\n\t    /* type(1) + auxlen(1) + numsrc(2) + grp(16) */\n\t    if (len < group + 20) {\n                    ND_PRINT((ndo,\" [invalid number of groups]\"));\n                    return;\n\t    }\n            ND_TCHECK2(bp[group + 4], sizeof(struct in6_addr));\n            ND_PRINT((ndo,\" [gaddr %s\", ip6addr_string(ndo, &bp[group + 4])));\n\t    ND_PRINT((ndo,\" %s\", tok2str(mldv2report2str, \" [v2-report-#%d]\",\n                                         bp[group])));\n            nsrcs = (bp[group + 2] << 8) + bp[group + 3];\n\t    /* Check the number of sources and print them */\n\t    if (len < group + 20 + (nsrcs * sizeof(struct in6_addr))) {\n                    ND_PRINT((ndo,\" [invalid number of sources %d]\", nsrcs));\n                    return;\n\t    }\n            if (ndo->ndo_vflag == 1)\n                    ND_PRINT((ndo,\", %d source(s)\", nsrcs));\n            else {\n\t\t/* Print the sources */\n                    ND_PRINT((ndo,\" {\"));\n                for (j = 0; j < nsrcs; j++) {\n                    ND_TCHECK2(bp[group + 20 + j * sizeof(struct in6_addr)],\n                            sizeof(struct in6_addr));\n\t\t    ND_PRINT((ndo,\" %s\", ip6addr_string(ndo, &bp[group + 20 + j * sizeof(struct in6_addr)])));\n\t\t}\n                ND_PRINT((ndo,\" }\"));\n            }\n\t    /* Next group record */\n            group += 20 + nsrcs * sizeof(struct in6_addr);\n\t    ND_PRINT((ndo,\"]\"));\n        }\n     }\n     return;\n trunc:\n    ND_PRINT((ndo,\"[|icmp6]\"));\n     return;\n }\n", "target": 1, "idx": 182999}
{"func": "        virtual void call(XMLTokenizer* tokenizer)\n        {\n            tokenizer->internalSubset(name, externalID, systemID);\n        }\n", "target": 0, "idx": 97267}
{"func": "status_t BnSoundTriggerHwService::onTransact(\n uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags)\n{\n switch(code) {\n\n         case LIST_MODULES: {\n             CHECK_INTERFACE(ISoundTriggerHwService, data, reply);\n             unsigned int numModulesReq = data.readInt32();\n             unsigned int numModules = numModulesReq;\n             struct sound_trigger_module_descriptor *modules =\n                     (struct sound_trigger_module_descriptor *)calloc(numModulesReq,\n                                                    sizeof(struct sound_trigger_module_descriptor));\n             status_t status = listModules(modules, &numModules);\n             reply->writeInt32(status);\n             reply->writeInt32(numModules);\n            ALOGV(\"LIST_MODULES status %d got numModules %d\", status, numModules);\n\n if (status == NO_ERROR) {\n if (numModulesReq > numModules) {\n                    numModulesReq = numModules;\n }\n                reply->write(modules,\n                             numModulesReq * sizeof(struct sound_trigger_module_descriptor));\n }\n            free(modules);\n return NO_ERROR;\n }\n\n case ATTACH: {\n            CHECK_INTERFACE(ISoundTriggerHwService, data, reply);\n sound_trigger_module_handle_t handle;\n            data.read(&handle, sizeof(sound_trigger_module_handle_t));\n            sp<ISoundTriggerClient> client =\n                    interface_cast<ISoundTriggerClient>(data.readStrongBinder());\n            sp<ISoundTrigger> module;\n status_t status = attach(handle, client, module);\n            reply->writeInt32(status);\n if (module != 0) {\n                reply->writeInt32(1);\n                reply->writeStrongBinder(IInterface::asBinder(module));\n } else {\n                reply->writeInt32(0);\n }\n return NO_ERROR;\n } break;\n\n case SET_CAPTURE_STATE: {\n            CHECK_INTERFACE(ISoundTriggerHwService, data, reply);\n            reply->writeInt32(setCaptureState((bool)data.readInt32()));\n return NO_ERROR;\n } break;\n\n default:\n return BBinder::onTransact(code, data, reply, flags);\n }\n}\n", "target": 1, "idx": 188094}
{"func": "static int snd_ctl_tlv_ioctl(struct snd_ctl_file *file,\n                             struct snd_ctl_tlv __user *_tlv,\n                             int op_flag)\n{\n\tstruct snd_card *card = file->card;\n\tstruct snd_ctl_tlv tlv;\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tunsigned int len;\n\tint err = 0;\n\n\tif (copy_from_user(&tlv, _tlv, sizeof(tlv)))\n\t\treturn -EFAULT;\n\tif (tlv.length < sizeof(unsigned int) * 2)\n\t\treturn -EINVAL;\n\tdown_read(&card->controls_rwsem);\n\tkctl = snd_ctl_find_numid(card, tlv.numid);\n\tif (kctl == NULL) {\n\t\terr = -ENOENT;\n\t\tgoto __kctl_end;\n\t}\n\tif (kctl->tlv.p == NULL) {\n\t\terr = -ENXIO;\n\t\tgoto __kctl_end;\n\t}\n\tvd = &kctl->vd[tlv.numid - kctl->id.numid];\n\tif ((op_flag == 0 && (vd->access & SNDRV_CTL_ELEM_ACCESS_TLV_READ) == 0) ||\n\t    (op_flag > 0 && (vd->access & SNDRV_CTL_ELEM_ACCESS_TLV_WRITE) == 0) ||\n\t    (op_flag < 0 && (vd->access & SNDRV_CTL_ELEM_ACCESS_TLV_COMMAND) == 0)) {\n\t    \terr = -ENXIO;\n\t    \tgoto __kctl_end;\n\t}\n\tif (vd->access & SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK) {\n\t\tif (vd->owner != NULL && vd->owner != file) {\n\t\t\terr = -EPERM;\n\t\t\tgoto __kctl_end;\n \t\t}\n \t\terr = kctl->tlv.c(kctl, op_flag, tlv.length, _tlv->tlv);\n \t\tif (err > 0) {\n \t\t\tup_read(&card->controls_rwsem);\n\t\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_TLV, &kctl->id);\n \t\t\treturn 0;\n \t\t}\n \t} else {\n\t\tif (op_flag) {\n\t\t\terr = -ENXIO;\n\t\t\tgoto __kctl_end;\n\t\t}\n\t\tlen = kctl->tlv.p[1] + 2 * sizeof(unsigned int);\n\t\tif (tlv.length < len) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto __kctl_end;\n\t\t}\n\t\tif (copy_to_user(_tlv->tlv, kctl->tlv.p, len))\n\t\t\terr = -EFAULT;\n\t}\n      __kctl_end:\n\tup_read(&card->controls_rwsem);\n\treturn err;\n}\n", "target": 1, "idx": 179467}
{"func": "const std::vector<GURL>& DownloadItemImpl::GetUrlChain() const {\n  return request_info_.url_chain;\n}\n", "target": 0, "idx": 159150}
{"func": "static int oidc_check_userid_openidc(request_rec *r, oidc_cfg *c) {\n\n\tif (oidc_get_redirect_uri(r, c) == NULL) {\n\t\toidc_error(r,\n\t\t\t\t\"configuration error: the authentication type is set to \\\"\" OIDC_AUTH_TYPE_OPENID_CONNECT \"\\\" but \" OIDCRedirectURI \" has not been set\");\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\t/* check if this is a sub-request or an initial request */\n\tif (ap_is_initial_req(r)) {\n\n\t\tint rc = OK;\n\n\t\t/* load the session from the request state; this will be a new \"empty\" session if no state exists */\n\t\toidc_session_t *session = NULL;\n\t\toidc_session_load(r, &session);\n\n\t\t/* see if the initial request is to the redirect URI; this handles potential logout too */\n\t\tif (oidc_util_request_matches_url(r, oidc_get_redirect_uri(r, c))) {\n\n\t\t\t/* handle request to the redirect_uri */\n\t\t\trc = oidc_handle_redirect_uri_request(r, c, session);\n\n\t\t\t/* free resources allocated for the session */\n\t\t\toidc_session_free(r, session);\n\n\t\t\treturn rc;\n\n\t\t\t/* initial request to non-redirect URI, check if we have an existing session */\n\t\t} else if (session->remote_user != NULL) {\n\n\t\t\t/* this is initial request and we already have a session */\n\t\t\trc = oidc_handle_existing_session(r, c, session);\n\n\t\t\t/* free resources allocated for the session */\n\t\t\toidc_session_free(r, session);\n\n\t\t\t/* strip any cookies that we need to */\n\t\t\toidc_strip_cookies(r);\n\n\t\t\treturn rc;\n\t\t}\n\n\t\t/* free resources allocated for the session */\n\t\toidc_session_free(r, session);\n\n\t\t/*\n\t\t * else: initial request, we have no session and it is not an authorization or\n\t\t *       discovery response: just hit the default flow for unauthenticated users\n\t\t */\n\t} else {\n\n\t\t/* not an initial request, try to recycle what we've already established in the main request */\n\t\tif (r->main != NULL)\n\t\t\tr->user = r->main->user;\n\t\telse if (r->prev != NULL)\n\t\t\tr->user = r->prev->user;\n\n\t\tif (r->user != NULL) {\n\n\t\t\t/* this is a sub-request and we have a session (headers will have been scrubbed and set already) */\n\t\t\toidc_debug(r,\n\t\t\t\t\t\"recycling user '%s' from initial request for sub-request\",\n\t\t\t\t\tr->user);\n\n\t\t\t/*\n\t\t\t * apparently request state can get lost in sub-requests, so let's see\n\t\t\t * if we need to restore id_token and/or claims from the session cache\n\t\t\t */\n\t\t\tconst char *s_id_token = oidc_request_state_get(r,\n\t\t\t\t\tOIDC_REQUEST_STATE_KEY_IDTOKEN);\n\t\t\tif (s_id_token == NULL) {\n\n\t\t\t\toidc_session_t *session = NULL;\n\t\t\t\toidc_session_load(r, &session);\n\n\t\t\t\toidc_copy_tokens_to_request_state(r, session, NULL, NULL);\n\n\t\t\t\t/* free resources allocated for the session */\n\t\t\t\toidc_session_free(r, session);\n\t\t\t}\n\n\t\t\t/* strip any cookies that we need to */\n\t\t\toidc_strip_cookies(r);\n\n\t\t\treturn OK;\n\t\t}\n\t\t/*\n\t\t * else: not initial request, but we could not find a session, so:\n\t\t * just hit the default flow for unauthenticated users\n\t\t */\n\t}\n\n\treturn oidc_handle_unauthenticated_user(r, c);\n}\n", "target": 0, "idx": 87059}
{"func": "static int ssl_parse_server_psk_hint( mbedtls_ssl_context *ssl,\n                                      unsigned char **p,\n                                      unsigned char *end )\n{\n    int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;\n    size_t  len;\n    ((void) ssl);\n\n    /*\n     * PSK parameters:\n      *\n      * opaque psk_identity_hint<0..2^16-1>;\n      */\n     len = (*p)[0] << 8 | (*p)[1];\n     *p += 2;\n \n    if( (*p) + len > end )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message \"\n                                    \"(psk_identity_hint length)\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n    }\n\n    /*\n     * Note: we currently ignore the PKS identity hint, as we only allow one\n     * PSK to be provisionned on the client. This could be changed later if\n     * someone needs that feature.\n     */\n    *p += len;\n    ret = 0;\n\n    return( ret );\n}\n", "target": 1, "idx": 182437}
{"func": "const BlockEntry* Cues::GetBlock(\n    const CuePoint* pCP,\n    const CuePoint::TrackPosition* pTP) const\n{\n    if (pCP == NULL)\n        return NULL;\n \n    if (pTP == NULL)\n        return NULL;\n    return m_pSegment->GetBlock(*pCP, *pTP);\n }\n", "target": 1, "idx": 188309}
{"func": " virtual status_t releaseSecureStops(Vector<uint8_t> const &ssRelease) {\n Parcel data, reply;\n        data.writeInterfaceToken(IDrm::getInterfaceDescriptor());\n\n        writeVector(data, ssRelease);\n status_t status = remote()->transact(RELEASE_SECURE_STOPS, data, &reply);\n if (status != OK) {\n return status;\n }\n\n return reply.readInt32();\n }\n", "target": 0, "idx": 174472}
{"func": "check_interlace_type(int PNG_CONST interlace_type)\n {\n    if (interlace_type != PNG_INTERLACE_NONE)\n    {\n       /* This is an internal error - --interlace tests should be skipped, not\n       * attempted.\n       */\n      fprintf(stderr, \"pngvalid: no interlace support\\n\");\n\n       exit(99);\n    }\n }\n", "target": 1, "idx": 187627}
{"func": " void DownloadController::OnDownloadStarted(\n     DownloadItem* download_item) {\n   DCHECK_CURRENTLY_ON(BrowserThread::UI);\n  WebContents* web_contents = download_item->GetWebContents();\n  if (!web_contents)\n    return;\n\n   download_item->AddObserver(this);\n \n   ChromeDownloadDelegate::FromWebContents(web_contents)->OnDownloadStarted(\n      download_item->GetTargetFilePath().BaseName().value(),\n      download_item->GetMimeType());\n }\n", "target": 1, "idx": 185760}
{"func": "struct key *keyring_alloc(const char *description, kuid_t uid, kgid_t gid,\n\t\t\t  const struct cred *cred, key_perm_t perm,\n\t\t\t  unsigned long flags, struct key *dest)\n{\n\tstruct key *keyring;\n\tint ret;\n\n\tkeyring = key_alloc(&key_type_keyring, description,\n\t\t\t    uid, gid, cred, perm, flags);\n\tif (!IS_ERR(keyring)) {\n\t\tret = key_instantiate_and_link(keyring, NULL, 0, dest, NULL);\n\t\tif (ret < 0) {\n\t\t\tkey_put(keyring);\n\t\t\tkeyring = ERR_PTR(ret);\n\t\t}\n\t}\n\n\treturn keyring;\n }\n", "target": 0, "idx": 69541}
{"func": "int hiddev_connect(struct hid_device *hid, unsigned int force)\n{\n\tstruct hiddev *hiddev;\n\tstruct usbhid_device *usbhid = hid->driver_data;\n\tint retval;\n\n\tif (!force) {\n\t\tunsigned int i;\n\t\tfor (i = 0; i < hid->maxcollection; i++)\n\t\t\tif (hid->collection[i].type ==\n\t\t\t    HID_COLLECTION_APPLICATION &&\n\t\t\t    !IS_INPUT_APPLICATION(hid->collection[i].usage))\n\t\t\t\tbreak;\n\n\t\tif (i == hid->maxcollection)\n\t\t\treturn -1;\n\t}\n\n\tif (!(hiddev = kzalloc(sizeof(struct hiddev), GFP_KERNEL)))\n\t\treturn -1;\n\n\tinit_waitqueue_head(&hiddev->wait);\n\tINIT_LIST_HEAD(&hiddev->list);\n\tspin_lock_init(&hiddev->list_lock);\n\tmutex_init(&hiddev->existancelock);\n\thid->hiddev = hiddev;\n\thiddev->hid = hid;\n\thiddev->exist = 1;\n\tretval = usb_register_dev(usbhid->intf, &hiddev_class);\n\tif (retval) {\n\t\thid_err(hid, \"Not able to get a minor for this device\\n\");\n\t\thid->hiddev = NULL;\n\t\tkfree(hiddev);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n", "target": 0, "idx": 51229}
{"func": "void WebPageProxy::didFinishProgress()\n{\n    m_estimatedProgress = 1.0;\n\n    m_loaderClient.didFinishProgress(this);\n}\n", "target": 0, "idx": 106490}
{"func": "static int nl80211_dump_scan(struct sk_buff *skb,\n\t\t\t     struct netlink_callback *cb)\n{\n\tstruct cfg80211_registered_device *rdev;\n\tstruct net_device *dev;\n\tstruct cfg80211_internal_bss *scan;\n\tstruct wireless_dev *wdev;\n\tint start = cb->args[1], idx = 0;\n\tint err;\n\n\terr = nl80211_prepare_netdev_dump(skb, cb, &rdev, &dev);\n\tif (err)\n\t\treturn err;\n\n\twdev = dev->ieee80211_ptr;\n\n\twdev_lock(wdev);\n\tspin_lock_bh(&rdev->bss_lock);\n\tcfg80211_bss_expire(rdev);\n\n\tlist_for_each_entry(scan, &rdev->bss_list, list) {\n\t\tif (++idx <= start)\n\t\t\tcontinue;\n\t\tif (nl80211_send_bss(skb,\n\t\t\t\tNETLINK_CB(cb->skb).pid,\n\t\t\t\tcb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\trdev, wdev, scan) < 0) {\n\t\t\tidx--;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock_bh(&rdev->bss_lock);\n\twdev_unlock(wdev);\n\n\tcb->args[1] = idx;\n\tnl80211_finish_netdev_dump(rdev);\n\n\treturn skb->len;\n}\n", "target": 0, "idx": 26678}
{"func": "static void cliPrintContextError(void) {\n    if (context == NULL) return;\n    fprintf(stderr,\"Error: %s\\n\",context->errstr);\n}\n", "target": 0, "idx": 81945}
{"func": "bool VideoTrack::VetEntry(const BlockEntry* pBlockEntry) const\n{\n    return Track::VetEntry(pBlockEntry) && pBlockEntry->GetBlock()->IsKey();\n}\n", "target": 1, "idx": 188474}
{"func": "static int ext4_readpage(struct file *file, struct page *page)\n{\n\treturn mpage_readpage(page, ext4_get_block);\n}\n", "target": 0, "idx": 57536}
{"func": "static void perf_event_for_each(struct perf_event *event,\n\t\t\t\t  void (*func)(struct perf_event *))\n{\n \tstruct perf_event_context *ctx = event->ctx;\n \tstruct perf_event *sibling;\n \n\tWARN_ON_ONCE(ctx->parent_ctx);\n\tmutex_lock(&ctx->mutex);\n \tevent = event->group_leader;\n \n \tperf_event_for_each_child(event, func);\n \tlist_for_each_entry(sibling, &event->sibling_list, group_entry)\n \t\tperf_event_for_each_child(sibling, func);\n\tmutex_unlock(&ctx->mutex);\n }\n", "target": 1, "idx": 180156}
{"func": "P2PQuicTransportImpl::P2PQuicTransportImpl(\n    P2PQuicTransportConfig p2p_transport_config,\n    std::unique_ptr<net::QuicChromiumConnectionHelper> helper,\n    std::unique_ptr<quic::QuicConnection> connection,\n    const quic::QuicConfig& quic_config,\n    quic::QuicClock* clock)\n    : quic::QuicSession(connection.get(),\n                        nullptr /* visitor */,\n                        quic_config,\n                        quic::CurrentSupportedVersions()),\n      helper_(std::move(helper)),\n      connection_(std::move(connection)),\n      perspective_(p2p_transport_config.is_server\n                       ? quic::Perspective::IS_SERVER\n                        : quic::Perspective::IS_CLIENT),\n       packet_transport_(p2p_transport_config.packet_transport),\n       delegate_(p2p_transport_config.delegate),\n      clock_(clock) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   DCHECK(delegate_);\n   DCHECK(clock_);\n   DCHECK(packet_transport_);\n   DCHECK_GT(p2p_transport_config.certificates.size(), 0u);\n   if (p2p_transport_config.can_respond_to_crypto_handshake) {\n     InitializeCryptoStream();\n  }\n  certificate_ = p2p_transport_config.certificates[0];\n  packet_transport_->SetReceiveDelegate(this);\n}\n", "target": 1, "idx": 186234}
{"func": "static void cypress_set_dead(struct usb_serial_port *port)\n{\n\tstruct cypress_private *priv = usb_get_serial_port_data(port);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tif (!priv->comm_is_ok) {\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\treturn;\n\t}\n\tpriv->comm_is_ok = 0;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\tdev_err(&port->dev, \"cypress_m8 suspending failing port %d - \"\n\t\t\"interval might be too short\\n\", port->port_number);\n}\n", "target": 0, "idx": 54244}
{"func": "png_free_data(png_structp png_ptr, png_infop info_ptr, png_uint_32 mask,\n   int num)\n{\n   png_debug(1, \"in png_free_data\");\n\n   if (png_ptr == NULL || info_ptr == NULL)\n      return;\n\n#ifdef PNG_TEXT_SUPPORTED\n   /* Free text item num or (if num == -1) all text items */\n#ifdef PNG_FREE_ME_SUPPORTED\n   if ((mask & PNG_FREE_TEXT) & info_ptr->free_me)\n#else\n   if (mask & PNG_FREE_TEXT)\n#endif\n   {\n      if (num != -1)\n      {\n         if (info_ptr->text && info_ptr->text[num].key)\n         {\n            png_free(png_ptr, info_ptr->text[num].key);\n            info_ptr->text[num].key = NULL;\n         }\n      }\n      else\n      {\n         int i;\n         for (i = 0; i < info_ptr->num_text; i++)\n             png_free_data(png_ptr, info_ptr, PNG_FREE_TEXT, i);\n         png_free(png_ptr, info_ptr->text);\n         info_ptr->text = NULL;\n         info_ptr->num_text=0;\n      }\n   }\n#endif\n\n#ifdef PNG_tRNS_SUPPORTED\n   /* Free any tRNS entry */\n#ifdef PNG_FREE_ME_SUPPORTED\n   if ((mask & PNG_FREE_TRNS) & info_ptr->free_me)\n#else\n   if ((mask & PNG_FREE_TRNS) && (png_ptr->flags & PNG_FLAG_FREE_TRNS))\n#endif\n   {\n      png_free(png_ptr, info_ptr->trans);\n      info_ptr->trans = NULL;\n      info_ptr->valid &= ~PNG_INFO_tRNS;\n#ifndef PNG_FREE_ME_SUPPORTED\n      png_ptr->flags &= ~PNG_FLAG_FREE_TRNS;\n#endif\n   }\n#endif\n\n#ifdef PNG_sCAL_SUPPORTED\n   /* Free any sCAL entry */\n#ifdef PNG_FREE_ME_SUPPORTED\n   if ((mask & PNG_FREE_SCAL) & info_ptr->free_me)\n#else\n   if (mask & PNG_FREE_SCAL)\n#endif\n   {\n#if defined(PNG_FIXED_POINT_SUPPORTED) && !defined(PNG_FLOATING_POINT_SUPPORTED)\n      png_free(png_ptr, info_ptr->scal_s_width);\n      png_free(png_ptr, info_ptr->scal_s_height);\n      info_ptr->scal_s_width = NULL;\n      info_ptr->scal_s_height = NULL;\n#endif\n      info_ptr->valid &= ~PNG_INFO_sCAL;\n   }\n#endif\n\n#ifdef PNG_pCAL_SUPPORTED\n   /* Free any pCAL entry */\n#ifdef PNG_FREE_ME_SUPPORTED\n   if ((mask & PNG_FREE_PCAL) & info_ptr->free_me)\n#else\n   if (mask & PNG_FREE_PCAL)\n#endif\n   {\n      png_free(png_ptr, info_ptr->pcal_purpose);\n      png_free(png_ptr, info_ptr->pcal_units);\n      info_ptr->pcal_purpose = NULL;\n      info_ptr->pcal_units = NULL;\n      if (info_ptr->pcal_params != NULL)\n         {\n            int i;\n            for (i = 0; i < (int)info_ptr->pcal_nparams; i++)\n            {\n               png_free(png_ptr, info_ptr->pcal_params[i]);\n               info_ptr->pcal_params[i] = NULL;\n            }\n            png_free(png_ptr, info_ptr->pcal_params);\n            info_ptr->pcal_params = NULL;\n         }\n      info_ptr->valid &= ~PNG_INFO_pCAL;\n   }\n#endif\n\n#ifdef PNG_iCCP_SUPPORTED\n   /* Free any iCCP entry */\n#ifdef PNG_FREE_ME_SUPPORTED\n   if ((mask & PNG_FREE_ICCP) & info_ptr->free_me)\n#else\n   if (mask & PNG_FREE_ICCP)\n#endif\n   {\n      png_free(png_ptr, info_ptr->iccp_name);\n      png_free(png_ptr, info_ptr->iccp_profile);\n      info_ptr->iccp_name = NULL;\n      info_ptr->iccp_profile = NULL;\n      info_ptr->valid &= ~PNG_INFO_iCCP;\n   }\n#endif\n\n#ifdef PNG_sPLT_SUPPORTED\n   /* Free a given sPLT entry, or (if num == -1) all sPLT entries */\n#ifdef PNG_FREE_ME_SUPPORTED\n   if ((mask & PNG_FREE_SPLT) & info_ptr->free_me)\n#else\n   if (mask & PNG_FREE_SPLT)\n#endif\n   {\n      if (num != -1)\n      {\n         if (info_ptr->splt_palettes)\n         {\n            png_free(png_ptr, info_ptr->splt_palettes[num].name);\n            png_free(png_ptr, info_ptr->splt_palettes[num].entries);\n            info_ptr->splt_palettes[num].name = NULL;\n            info_ptr->splt_palettes[num].entries = NULL;\n         }\n      }\n      else\n      {\n         if (info_ptr->splt_palettes_num)\n         {\n            int i;\n            for (i = 0; i < (int)info_ptr->splt_palettes_num; i++)\n               png_free_data(png_ptr, info_ptr, PNG_FREE_SPLT, i);\n\n            png_free(png_ptr, info_ptr->splt_palettes);\n            info_ptr->splt_palettes = NULL;\n            info_ptr->splt_palettes_num = 0;\n         }\n         info_ptr->valid &= ~PNG_INFO_sPLT;\n      }\n   }\n#endif\n\n#ifdef PNG_UNKNOWN_CHUNKS_SUPPORTED\n   if (png_ptr->unknown_chunk.data)\n   {\n      png_free(png_ptr, png_ptr->unknown_chunk.data);\n      png_ptr->unknown_chunk.data = NULL;\n   }\n\n#ifdef PNG_FREE_ME_SUPPORTED\n   if ((mask & PNG_FREE_UNKN) & info_ptr->free_me)\n#else\n   if (mask & PNG_FREE_UNKN)\n#endif\n   {\n      if (num != -1)\n      {\n          if (info_ptr->unknown_chunks)\n          {\n             png_free(png_ptr, info_ptr->unknown_chunks[num].data);\n             info_ptr->unknown_chunks[num].data = NULL;\n          }\n      }\n      else\n      {\n         int i;\n\n         if (info_ptr->unknown_chunks_num)\n         {\n            for (i = 0; i < (int)info_ptr->unknown_chunks_num; i++)\n               png_free_data(png_ptr, info_ptr, PNG_FREE_UNKN, i);\n\n            png_free(png_ptr, info_ptr->unknown_chunks);\n            info_ptr->unknown_chunks = NULL;\n            info_ptr->unknown_chunks_num = 0;\n         }\n      }\n   }\n#endif\n\n#ifdef PNG_hIST_SUPPORTED\n   /* Free any hIST entry */\n#ifdef PNG_FREE_ME_SUPPORTED\n   if ((mask & PNG_FREE_HIST)  & info_ptr->free_me)\n#else\n   if ((mask & PNG_FREE_HIST) && (png_ptr->flags & PNG_FLAG_FREE_HIST))\n#endif\n   {\n      png_free(png_ptr, info_ptr->hist);\n      info_ptr->hist = NULL;\n      info_ptr->valid &= ~PNG_INFO_hIST;\n#ifndef PNG_FREE_ME_SUPPORTED\n      png_ptr->flags &= ~PNG_FLAG_FREE_HIST;\n#endif\n   }\n#endif\n\n   /* Free any PLTE entry that was internally allocated */\n#ifdef PNG_FREE_ME_SUPPORTED\n   if ((mask & PNG_FREE_PLTE) & info_ptr->free_me)\n#else\n   if ((mask & PNG_FREE_PLTE) && (png_ptr->flags & PNG_FLAG_FREE_PLTE))\n#endif\n   {\n      png_zfree(png_ptr, info_ptr->palette);\n      info_ptr->palette = NULL;\n      info_ptr->valid &= ~PNG_INFO_PLTE;\n#ifndef PNG_FREE_ME_SUPPORTED\n      png_ptr->flags &= ~PNG_FLAG_FREE_PLTE;\n#endif\n      info_ptr->num_palette = 0;\n   }\n\n#ifdef PNG_INFO_IMAGE_SUPPORTED\n   /* Free any image bits attached to the info structure */\n#ifdef PNG_FREE_ME_SUPPORTED\n   if ((mask & PNG_FREE_ROWS) & info_ptr->free_me)\n#else\n   if (mask & PNG_FREE_ROWS)\n#endif\n   {\n      if (info_ptr->row_pointers)\n      {\n         int row;\n         for (row = 0; row < (int)info_ptr->height; row++)\n         {\n            png_free(png_ptr, info_ptr->row_pointers[row]);\n            info_ptr->row_pointers[row] = NULL;\n         }\n         png_free(png_ptr, info_ptr->row_pointers);\n         info_ptr->row_pointers = NULL;\n      }\n      info_ptr->valid &= ~PNG_INFO_IDAT;\n   }\n#endif\n\n#ifdef PNG_FREE_ME_SUPPORTED\n   if (num == -1)\n      info_ptr->free_me &= ~mask;\n   else\n      info_ptr->free_me &= ~(mask & ~PNG_FREE_MUL);\n#endif\n}\n", "target": 0, "idx": 143931}
{"func": "static inline void mcryptd_check_internal(struct rtattr **tb, u32 *type,\n \t\t\t\t\t  u32 *mask)\n {\n \tstruct crypto_attr_type *algt;\n \n \talgt = crypto_get_attr_type(tb);\n \tif (IS_ERR(algt))\n\t\treturn;\n\tif ((algt->type & CRYPTO_ALG_INTERNAL))\n\t\t*type |= CRYPTO_ALG_INTERNAL;\n\tif ((algt->mask & CRYPTO_ALG_INTERNAL))\n\t\t*mask |= CRYPTO_ALG_INTERNAL;\n }\n", "target": 1, "idx": 181692}
{"func": "pdf_copy_dict(fz_context *ctx, pdf_obj *obj)\n{\n\tpdf_document *doc;\n\tpdf_obj *dict;\n\tint i, n;\n\n\tRESOLVE(obj);\n\tif (!OBJ_IS_DICT(obj))\n\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"not a dict (%s)\", pdf_objkindstr(obj));\n\n\tdoc = DICT(obj)->doc;\n\tn = pdf_dict_len(ctx, obj);\n\tdict = pdf_new_dict(ctx, doc, n);\n\tfor (i = 0; i < n; i++)\n\t\tpdf_dict_put(ctx, dict, pdf_dict_get_key(ctx, obj, i), pdf_dict_get_val(ctx, obj, i));\n\n\treturn dict;\n}\n", "target": 0, "idx": 13882}
{"func": "bool NaClProcessHost::StartNaClExecution() {\n  NaClBrowser* nacl_browser = NaClBrowser::GetInstance();\n\n  nacl::NaClStartParams params;\n  params.validation_cache_enabled = nacl_browser->ValidationCacheIsEnabled();\n  params.validation_cache_key = nacl_browser->GetValidationCacheKey();\n  params.version = chrome::VersionInfo().CreateVersionString();\n   params.enable_exception_handling = enable_exception_handling_;\n   params.enable_debug_stub =\n       CommandLine::ForCurrentProcess()->HasSwitch(switches::kEnableNaClDebug);\n  params.enable_ipc_proxy = enable_ipc_proxy_;\n \n   base::PlatformFile irt_file = nacl_browser->IrtFile();\n   CHECK_NE(irt_file, base::kInvalidPlatformFileValue);\n\n  const ChildProcessData& data = process_->GetData();\n  for (size_t i = 0; i < internal_->sockets_for_sel_ldr.size(); i++) {\n    if (!ShareHandleToSelLdr(data.handle,\n                             internal_->sockets_for_sel_ldr[i], true,\n                             &params.handles)) {\n      return false;\n    }\n  }\n\n  if (!ShareHandleToSelLdr(data.handle, irt_file, false, &params.handles))\n    return false;\n\n#if defined(OS_MACOSX)\n  base::SharedMemory memory_buffer;\n  base::SharedMemoryCreateOptions options;\n  options.size = 1;\n  options.executable = true;\n  if (!memory_buffer.Create(options)) {\n    DLOG(ERROR) << \"Failed to allocate memory buffer\";\n    return false;\n  }\n  nacl::FileDescriptor memory_fd;\n  memory_fd.fd = dup(memory_buffer.handle().fd);\n  if (memory_fd.fd < 0) {\n    DLOG(ERROR) << \"Failed to dup() a file descriptor\";\n    return false;\n  }\n  memory_fd.auto_close = true;\n  params.handles.push_back(memory_fd);\n#endif\n\n  process_->Send(new NaClProcessMsg_Start(params));\n\n  internal_->sockets_for_sel_ldr.clear();\n  return true;\n }\n", "target": 1, "idx": 184303}
{"func": "IntPoint FrameView::convertToContainingView(const IntPoint& localPoint) const\n{\n    if (const ScrollView* parentScrollView = toScrollView(parent())) {\n        if (parentScrollView->isFrameView()) {\n            const FrameView* parentView = toFrameView(parentScrollView);\n\n            RenderPart* renderer = m_frame->ownerRenderer();\n            if (!renderer)\n                return localPoint;\n\n            IntPoint point(localPoint);\n\n            point.move(renderer->borderLeft() + renderer->paddingLeft(),\n                       renderer->borderTop() + renderer->paddingTop());\n            return parentView->convertFromRenderer(*renderer, point);\n        }\n\n        return Widget::convertToContainingView(localPoint);\n    }\n\n    return localPoint;\n}\n", "target": 0, "idx": 128235}
{"func": "iterate (const char *filename,\n\t enum grub_fshelp_filetype filetype,\n\t grub_fshelp_node_t node,\n\t void *closure)\n{\n  struct grub_ext2_dir_closure *c = closure;\n  struct grub_dirhook_info info;\n  grub_memset (&info, 0, sizeof (info));\n  if (! node->inode_read)\n    {\n      grub_ext2_read_inode (c->data, node->ino, &node->inode);\n      if (!grub_errno)\n\tnode->inode_read = 1;\n      grub_errno = GRUB_ERR_NONE;\n    }\n  if (node->inode_read)\n    {\n      info.mtimeset = 1;\n      info.mtime = grub_le_to_cpu32 (node->inode.mtime);\n    }\n\n  info.dir = ((filetype & GRUB_FSHELP_TYPE_MASK) == GRUB_FSHELP_DIR);\n  grub_free (node);\n  return (c->hook != NULL)? c->hook (filename, &info, c->closure): 0;\n}\n", "target": 0, "idx": 64165}
{"func": "int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)\n{\n\tstruct sctp_association *asoc = sctp_id2assoc(sk, id);\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct socket *sock;\n\tint err = 0;\n\n\tif (!asoc)\n\t\treturn -EINVAL;\n\n\t/* An association cannot be branched off from an already peeled-off\n\t * socket, nor is this supported for tcp style sockets.\n\t */\n\tif (!sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\t/* Create a new socket.  */\n\terr = sock_create(sk->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock);\n\tif (err < 0)\n\t\treturn err;\n\n\tsctp_copy_sock(sock->sk, sk, asoc);\n\n\t/* Make peeled-off sockets more like 1-1 accepted sockets.\n\t * Set the daddr and initialize id to something more random\n\t */\n\tsp->pf->to_sk_daddr(&asoc->peer.primary_addr, sk);\n\n\t/* Populate the fields of the newsk from the oldsk and migrate the\n\t * asoc to the newsk.\n\t */\n\tsctp_sock_migrate(sk, sock->sk, asoc, SCTP_SOCKET_UDP_HIGH_BANDWIDTH);\n\n\t*sockp = sock;\n\n\treturn err;\n}\n", "target": 0, "idx": 43529}
{"func": " static inline void schedule_debug(struct task_struct *prev)\n {\n #ifdef CONFIG_SCHED_STACK_END_CHECK\n\tBUG_ON(task_stack_end_corrupted(prev));\n #endif\n \n \tif (unlikely(in_atomic_preempt_off())) {\n\t\t__schedule_bug(prev);\n\t\tpreempt_count_set(PREEMPT_DISABLED);\n\t}\n\trcu_sleep_check();\n\n\tprofile_hit(SCHED_PROFILING, __builtin_return_address(0));\n\n\tschedstat_inc(this_rq(), sched_count);\n}\n", "target": 1, "idx": 180617}
{"func": "bool GLES2DecoderImpl::SimulateFixedAttribs(\n    const char* function_name,\n    GLuint max_vertex_accessed, bool* simulated, GLsizei primcount) {\n  DCHECK(simulated);\n  *simulated = false;\n  if (gfx::GetGLImplementation() == gfx::kGLImplementationEGLGLES2)\n    return true;\n\n  if (!vertex_attrib_manager_->HaveFixedAttribs()) {\n    return true;\n  }\n\n  PerformanceWarning(\n      \"GL_FIXED attributes have a signficant performance penalty\");\n\n\n  GLuint elements_needed = 0;\n  const VertexAttribManager::VertexAttribInfoList& infos =\n      vertex_attrib_manager_->GetEnabledVertexAttribInfos();\n  for (VertexAttribManager::VertexAttribInfoList::const_iterator it =\n       infos.begin(); it != infos.end(); ++it) {\n    const VertexAttribManager::VertexAttribInfo* info = *it;\n    const ProgramManager::ProgramInfo::VertexAttribInfo* attrib_info =\n        current_program_->GetAttribInfoByLocation(info->index());\n    GLuint max_accessed = info->MaxVertexAccessed(primcount,\n                                                  max_vertex_accessed);\n    GLuint num_vertices = max_accessed + 1;\n    if (num_vertices == 0) {\n      SetGLError(GL_OUT_OF_MEMORY, function_name, \"Simulating attrib 0\");\n      return false;\n    }\n     if (attrib_info &&\n         info->CanAccess(max_accessed) &&\n         info->type() == GL_FIXED) {\n      GLuint elements_used = 0;\n      if (!SafeMultiply(num_vertices,\n                        static_cast<GLuint>(info->size()), &elements_used) ||\n          !SafeAdd(elements_needed, elements_used, &elements_needed)) {\n         SetGLError(\n             GL_OUT_OF_MEMORY, function_name, \"simulating GL_FIXED attribs\");\n         return false;\n       }\n     }\n   }\n \n  const GLuint kSizeOfFloat = sizeof(float);  // NOLINT\n  GLuint size_needed = 0;\n  if (!SafeMultiply(elements_needed, kSizeOfFloat, &size_needed) ||\n       size_needed > 0x7FFFFFFFU) {\n     SetGLError(GL_OUT_OF_MEMORY, function_name, \"simulating GL_FIXED attribs\");\n     return false;\n  }\n\n  CopyRealGLErrorsToWrapper();\n\n  glBindBuffer(GL_ARRAY_BUFFER, fixed_attrib_buffer_id_);\n  if (static_cast<GLsizei>(size_needed) > fixed_attrib_buffer_size_) {\n    glBufferData(GL_ARRAY_BUFFER, size_needed, NULL, GL_DYNAMIC_DRAW);\n    GLenum error = glGetError();\n    if (error != GL_NO_ERROR) {\n      SetGLError(\n          GL_OUT_OF_MEMORY, function_name, \"simulating GL_FIXED attribs\");\n      return false;\n    }\n  }\n\n  GLintptr offset = 0;\n  for (VertexAttribManager::VertexAttribInfoList::const_iterator it =\n           infos.begin(); it != infos.end(); ++it) {\n    const VertexAttribManager::VertexAttribInfo* info = *it;\n    const ProgramManager::ProgramInfo::VertexAttribInfo* attrib_info =\n        current_program_->GetAttribInfoByLocation(info->index());\n    GLuint max_accessed = info->MaxVertexAccessed(primcount,\n                                                  max_vertex_accessed);\n    GLuint num_vertices = max_accessed + 1;\n    if (num_vertices == 0) {\n      SetGLError(GL_OUT_OF_MEMORY, function_name, \"Simulating attrib 0\");\n      return false;\n    }\n    if (attrib_info &&\n        info->CanAccess(max_accessed) &&\n        info->type() == GL_FIXED) {\n      int num_elements = info->size() * kSizeOfFloat;\n      int size = num_elements * num_vertices;\n      scoped_array<float> data(new float[size]);\n      const int32* src = reinterpret_cast<const int32 *>(\n          info->buffer()->GetRange(info->offset(), size));\n      const int32* end = src + num_elements;\n      float* dst = data.get();\n      while (src != end) {\n        *dst++ = static_cast<float>(*src++) / 65536.0f;\n      }\n      glBufferSubData(GL_ARRAY_BUFFER, offset, size, data.get());\n      glVertexAttribPointer(\n          info->index(), info->size(), GL_FLOAT, false, 0,\n          reinterpret_cast<GLvoid*>(offset));\n      offset += size;\n    }\n  }\n  *simulated = true;\n  return true;\n}\n", "target": 1, "idx": 184325}
{"func": "bool GpuProcessHost::OnMessageReceived(const IPC::Message& message) {\n  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\n#if defined(USE_OZONE)\n  ui::OzonePlatform::GetInstance()\n      ->GetGpuPlatformSupportHost()\n      ->OnMessageReceived(message);\n#endif\n  return true;\n}\n", "target": 0, "idx": 145172}
{"func": "static bool access_pmu_evcntr(struct kvm_vcpu *vcpu,\n\t\t\t      struct sys_reg_params *p,\n\t\t\t      const struct sys_reg_desc *r)\n{\n\tu64 idx;\n\n\tif (!kvm_arm_pmu_v3_ready(vcpu))\n\t\treturn trap_raz_wi(vcpu, p, r);\n\n\tif (r->CRn == 9 && r->CRm == 13) {\n\t\tif (r->Op2 == 2) {\n\t\t\t/* PMXEVCNTR_EL0 */\n\t\t\tif (pmu_access_event_counter_el0_disabled(vcpu))\n\t\t\t\treturn false;\n\n\t\t\tidx = vcpu_sys_reg(vcpu, PMSELR_EL0)\n\t\t\t      & ARMV8_PMU_COUNTER_MASK;\n\t\t} else if (r->Op2 == 0) {\n\t\t\t/* PMCCNTR_EL0 */\n\t\t\tif (pmu_access_cycle_counter_el0_disabled(vcpu))\n\t\t\t\treturn false;\n \n \t\t\tidx = ARMV8_PMU_CYCLE_IDX;\n \t\t} else {\n\t\t\tBUG();\n \t\t}\n \t} else if (r->CRn == 14 && (r->CRm & 12) == 8) {\n \t\t/* PMEVCNTRn_EL0 */\n \t\tif (pmu_access_event_counter_el0_disabled(vcpu))\n \t\t\treturn false;\n \n \t\tidx = ((r->CRm & 3) << 3) | (r->Op2 & 7);\n \t} else {\n\t\tBUG();\n \t}\n \n \tif (!pmu_counter_idx_valid(vcpu, idx))\n\t\treturn false;\n\n\tif (p->is_write) {\n\t\tif (pmu_access_el0_disabled(vcpu))\n\t\t\treturn false;\n\n\t\tkvm_pmu_set_counter_value(vcpu, idx, p->regval);\n\t} else {\n\t\tp->regval = kvm_pmu_get_counter_value(vcpu, idx);\n\t}\n\n\treturn true;\n}\n", "target": 1, "idx": 181161}
{"func": "int rose_parse_facilities(unsigned char *p,\n\tstruct rose_facilities_struct *facilities)\n{\n\tint facilities_len, len;\n\n\tfacilities_len = *p++;\n\n\tif (facilities_len == 0)\n\t\treturn 0;\n\n\twhile (facilities_len > 0) {\n\t\tif (*p == 0x00) {\n\t\t\tfacilities_len--;\n\t\t\tp++;\n\n \t\t\tswitch (*p) {\n \t\t\tcase FAC_NATIONAL:\t\t/* National */\n \t\t\t\tlen = rose_parse_national(p + 1, facilities, facilities_len - 1);\n \t\t\t\tfacilities_len -= len + 1;\n \t\t\t\tp += len + 1;\n \t\t\t\tbreak;\n \n \t\t\tcase FAC_CCITT:\t\t/* CCITT */\n \t\t\t\tlen = rose_parse_ccitt(p + 1, facilities, facilities_len - 1);\n \t\t\t\tfacilities_len -= len + 1;\n \t\t\t\tp += len + 1;\n \t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tprintk(KERN_DEBUG \"ROSE: rose_parse_facilities - unknown facilities family %02X\\n\", *p);\n\t\t\t\tfacilities_len--;\n\t\t\t\tp++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\tbreak;\t/* Error in facilities format */\n\t}\n\n\treturn 1;\n}\n", "target": 1, "idx": 178844}
{"func": "MagickExport void RemoveDuplicateLayers(Image **images,\n     ExceptionInfo *exception)\n {\n  register Image\n    *curr,\n    *next;\n   RectangleInfo\n     bounds;\n \n   assert((*images) != (const Image *) NULL);\n   assert((*images)->signature == MagickCoreSignature);\n   if ((*images)->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",(*images)->filename);\n   assert(exception != (ExceptionInfo *) NULL);\n   assert(exception->signature == MagickCoreSignature);\n  curr=GetFirstImageInList(*images);\n  for (; (next=GetNextImageInList(curr)) != (Image *) NULL; curr=next)\n   {\n    if ( curr->columns != next->columns || curr->rows != next->rows\n         || curr->page.x != next->page.x || curr->page.y != next->page.y )\n       continue;\n    bounds=CompareImagesBounds(curr,next,CompareAnyLayer,exception);\n    if ( bounds.x < 0 ) {\n      /*\n        the two images are the same, merge time delays and delete one.\n      */\n      size_t time;\n      time = curr->delay*1000/curr->ticks_per_second;\n      time += next->delay*1000/next->ticks_per_second;\n      next->ticks_per_second = 100L;\n      next->delay = time*curr->ticks_per_second/1000;\n      next->iterations = curr->iterations;\n      *images = curr;\n      (void) DeleteImageFromList(images);\n    }\n   }\n  *images = GetFirstImageInList(*images);\n }\n", "target": 1, "idx": 183364}
{"func": "void BrowserWindowGtk::Maximize() {\n  gtk_window_maximize(window_);\n}\n", "target": 0, "idx": 126389}
{"func": "netdev_features_t netif_skb_features(struct sk_buff *skb)\n{\n\tstruct net_device *dev = skb->dev;\n\tnetdev_features_t features = dev->features;\n\tu16 gso_segs = skb_shinfo(skb)->gso_segs;\n\n\tif (gso_segs > dev->gso_max_segs || gso_segs < dev->gso_min_segs)\n\t\tfeatures &= ~NETIF_F_GSO_MASK;\n\n\t/* If encapsulation offload request, verify we are testing\n\t * hardware encapsulation features instead of standard\n\t * features for the netdev\n\t */\n\tif (skb->encapsulation)\n\t\tfeatures &= dev->hw_enc_features;\n\n\tif (skb_vlan_tagged(skb))\n\t\tfeatures = netdev_intersect_features(features,\n\t\t\t\t\t\t     dev->vlan_features |\n\t\t\t\t\t\t     NETIF_F_HW_VLAN_CTAG_TX |\n\t\t\t\t\t\t     NETIF_F_HW_VLAN_STAG_TX);\n\n\tif (dev->netdev_ops->ndo_features_check)\n\t\tfeatures &= dev->netdev_ops->ndo_features_check(skb, dev,\n\t\t\t\t\t\t\t\tfeatures);\n\telse\n\t\tfeatures &= dflt_features_check(skb, dev, features);\n\n\treturn harmonize_features(skb, features);\n}\n", "target": 0, "idx": 48920}
{"func": "void AutoFillManager::FormSubmitted(const FormData& form) {\n  if (!IsAutoFillEnabled())\n    return;\n\n   if (tab_contents_->profile()->IsOffTheRecord())\n     return;\n \n   upload_form_structure_.reset(new FormStructure(form));\n \n  if (!upload_form_structure_->IsAutoFillable())\n    return;\n\n  DeterminePossibleFieldTypes(upload_form_structure_.get());\n  HandleSubmit();\n}\n", "target": 1, "idx": 183431}
{"func": "void AddRegisterComDllWorkItems(const FilePath& dll_folder,\n                                const std::vector<FilePath>& dll_list,\n                                bool system_level,\n                                bool do_register,\n                                bool ignore_failures,\n                                WorkItemList* work_item_list) {\n  DCHECK(work_item_list);\n  if (dll_list.empty()) {\n    VLOG(1) << \"No COM DLLs to register\";\n  } else {\n    std::vector<FilePath>::const_iterator dll_iter(dll_list.begin());\n    for (; dll_iter != dll_list.end(); ++dll_iter) {\n      FilePath dll_path = dll_folder.Append(*dll_iter);\n      WorkItem* work_item = work_item_list->AddSelfRegWorkItem(\n          dll_path.value(), do_register, !system_level);\n      DCHECK(work_item);\n      work_item->set_ignore_failure(ignore_failures);\n    }\n  }\n}\n", "target": 0, "idx": 106802}
{"func": "xmlXPathNumberFunction(xmlXPathParserContextPtr ctxt, int nargs) {\n    xmlXPathObjectPtr cur;\n    double res;\n\n    if (ctxt == NULL) return;\n    if (nargs == 0) {\n\tif (ctxt->context->node == NULL) {\n\t    valuePush(ctxt, xmlXPathCacheNewFloat(ctxt->context, 0.0));\n\t} else {\n\t    xmlChar* content = xmlNodeGetContent(ctxt->context->node);\n\n\t    res = xmlXPathStringEvalNumber(content);\n\t    valuePush(ctxt, xmlXPathCacheNewFloat(ctxt->context, res));\n\t    xmlFree(content);\n\t}\n\treturn;\n    }\n\n    CHECK_ARITY(1);\n    cur = valuePop(ctxt);\n    valuePush(ctxt, xmlXPathCacheConvertNumber(ctxt->context, cur));\n}\n", "target": 0, "idx": 97754}
{"func": "  static TT_F26Dot6  Project_x( EXEC_OPS TT_F26Dot6  Vx, TT_F26Dot6  Vy )\n  { (void)exc; (void)Vy;\n    return Vx;\n  }\n", "target": 0, "idx": 5485}
{"func": "  TabManagerTest() : scoped_set_tick_clock_for_testing_(&test_clock_) {\n     test_clock_.Advance(kShortDelay);\n   }\n", "target": 1, "idx": 186197}
{"func": "static int mem_cgroup_count_precharge_pte_range(pmd_t *pmd,\n\t\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\t\tstruct mm_walk *walk)\n{\n\tstruct vm_area_struct *vma = walk->private;\n\tpte_t *pte;\n\tspinlock_t *ptl;\n\n\tsplit_huge_page_pmd(walk->mm, pmd);\n\n\tpte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);\n\tfor (; addr != end; pte++, addr += PAGE_SIZE)\n\t\tif (is_target_pte_for_mc(vma, addr, *pte, NULL))\n\t\t\tmc.precharge++;\t/* increment precharge temporarily */\n\tpte_unmap_unlock(pte - 1, ptl);\n\tcond_resched();\n\n\treturn 0;\n}\n", "target": 0, "idx": 21433}
{"func": "void rds_inc_info_copy(struct rds_incoming *inc,\n\t\t       struct rds_info_iterator *iter,\n\t\t       __be32 saddr, __be32 daddr, int flip)\n{\n\tstruct rds_info_message minfo;\n\n\tminfo.seq = be64_to_cpu(inc->i_hdr.h_sequence);\n\tminfo.len = be32_to_cpu(inc->i_hdr.h_len);\n\n\tif (flip) {\n\t\tminfo.laddr = daddr;\n\t\tminfo.faddr = saddr;\n\t\tminfo.lport = inc->i_hdr.h_dport;\n\t\tminfo.fport = inc->i_hdr.h_sport;\n\t} else {\n\t\tminfo.laddr = saddr;\n\t\tminfo.faddr = daddr;\n\t\tminfo.lport = inc->i_hdr.h_sport;\n \t\tminfo.fport = inc->i_hdr.h_dport;\n \t}\n \n \trds_info_copy(iter, &minfo, sizeof(minfo));\n }\n", "target": 1, "idx": 180333}
{"func": "float MSG_ReadFloat( msg_t *msg ) {\n\tfloatint_t dat;\n\t\n\tdat.i = MSG_ReadBits( msg, 32 );\n\tif ( msg->readcount > msg->cursize ) {\n\t\tdat.f = -1;\n\t}\t\n\t\n\treturn dat.f;\t\n}\n", "target": 0, "idx": 63155}
{"func": "void TestController::ensureViewSupportsOptions(WKDictionaryRef options)\n{\n    if (m_mainWebView && !m_mainWebView->viewSupportsOptions(options)) {\n        WKPageSetPageUIClient(m_mainWebView->page(), 0);\n        WKPageSetPageLoaderClient(m_mainWebView->page(), 0);\n        WKPageSetPagePolicyClient(m_mainWebView->page(), 0);\n        WKPageClose(m_mainWebView->page());\n        \n        m_mainWebView = nullptr;\n\n        createWebViewWithOptions(options);\n        resetStateToConsistentValues();\n    }\n}\n", "target": 0, "idx": 115518}
{"func": "void raw_hash_sk(struct sock *sk)\n{\n\tstruct raw_hashinfo *h = sk->sk_prot->h.raw_hash;\n\tstruct hlist_head *head;\n\n\thead = &h->ht[inet_sk(sk)->inet_num & (RAW_HTABLE_SIZE - 1)];\n\n\twrite_lock_bh(&h->lock);\n\tsk_add_node(sk, head);\n\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, 1);\n\twrite_unlock_bh(&h->lock);\n}\n", "target": 0, "idx": 18957}
{"func": "__u32 secure_tcpv6_sequence_number(__be32 *saddr, __be32 *daddr,\n\t\t\t\t   __be16 sport, __be16 dport)\n{\n\t__u32 seq;\n\t__u32 hash[12];\n\tstruct keydata *keyptr = get_keyptr();\n\t/* The procedure is the same as for IPv4, but addresses are longer.\n\t * Thus we must use twothirdsMD4Transform.\n\t */\n\tmemcpy(hash, saddr, 16);\n\thash[4] = ((__force u16)sport << 16) + (__force u16)dport;\n\tmemcpy(&hash[5], keyptr->secret, sizeof(__u32) * 7);\n\tseq = twothirdsMD4Transform((const __u32 *)daddr, hash) & HASH_MASK;\n\tseq += keyptr->count;\n\tseq += ktime_to_ns(ktime_get_real());\n\treturn seq;\n}\n", "target": 1, "idx": 178941}
{"func": "static int java_switch_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len) {\n\tut8 op_byte = data[0];\n\tut64 offset = addr - java_get_method_start ();\n\tut8 pos = (offset+1)%4 ? 1 + 4 - (offset+1)%4 : 1;\n \n \tif (op_byte == 0xaa) {\n\t\tif (pos + 8 > len) {\n \t\t\treturn op->size;\n \t\t}\n\t\tint min_val = (ut32)(UINT (data, pos + 4)),\n\t\t\tmax_val = (ut32)(UINT (data, pos + 8));\n \n \t\tut32 default_loc = (ut32) (UINT (data, pos)), cur_case = 0;\n \t\top->switch_op = r_anal_switch_op_new (addr, min_val, default_loc);\n\t\tRAnalCaseOp *caseop = NULL;\n\t\tpos += 12;\n\t\tif (max_val > min_val && ((max_val - min_val)<(UT16_MAX/4))) {\n\t\t\tfor (cur_case = 0; cur_case <= max_val - min_val; pos += 4, cur_case++) {\n\t\t\t\tif (pos + 4 >= len) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint offset = (int)(ut32)(R_BIN_JAVA_UINT (data, pos));\n\t\t\t\tcaseop = r_anal_switch_op_add_case (op->switch_op,\n\t\t\t\t\taddr + pos, cur_case + min_val, addr + offset);\n\t\t\t\tif (caseop) {\n\t\t\t\t\tcaseop->bb_ref_to = addr+offset;\n\t\t\t\t\tcaseop->bb_ref_from = addr; // TODO figure this one out\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"Invalid switch boundaries at 0x%\"PFMT64x\"\\n\", addr);\n\t\t}\n\t}\n\top->size = pos;\n\treturn op->size;\n}\n", "target": 1, "idx": 182370}
{"func": "move_to_close_lru(struct nfs4_ol_stateid *s, struct net *net)\n{\n\tstruct nfs4_ol_stateid *last;\n\tstruct nfs4_openowner *oo = openowner(s->st_stateowner);\n\tstruct nfsd_net *nn = net_generic(s->st_stid.sc_client->net,\n\t\t\t\t\t\tnfsd_net_id);\n\n\tdprintk(\"NFSD: move_to_close_lru nfs4_openowner %p\\n\", oo);\n\n\t/*\n\t * We know that we hold one reference via nfsd4_close, and another\n\t * \"persistent\" reference for the client. If the refcount is higher\n\t * than 2, then there are still calls in progress that are using this\n\t * stateid. We can't put the sc_file reference until they are finished.\n\t * Wait for the refcount to drop to 2. Since it has been unhashed,\n\t * there should be no danger of the refcount going back up again at\n\t * this point.\n\t */\n\twait_event(close_wq, atomic_read(&s->st_stid.sc_count) == 2);\n\n\trelease_all_access(s);\n\tif (s->st_stid.sc_file) {\n\t\tput_nfs4_file(s->st_stid.sc_file);\n\t\ts->st_stid.sc_file = NULL;\n\t}\n\n\tspin_lock(&nn->client_lock);\n\tlast = oo->oo_last_closed_stid;\n\too->oo_last_closed_stid = s;\n\tlist_move_tail(&oo->oo_close_lru, &nn->close_lru);\n\too->oo_time = get_seconds();\n\tspin_unlock(&nn->client_lock);\n\tif (last)\n\t\tnfs4_put_stid(&last->st_stid);\n}\n", "target": 0, "idx": 65499}
{"func": "R_API RBinFile *r_bin_cur(RBin *bin) {\n\treturn bin? bin->cur: NULL;\n}\n", "target": 0, "idx": 60110}
{"func": "int FindPublicSession(const user_manager::UserList& users) {\n  int index = -1;\n  int i = 0;\n  for (user_manager::UserList::const_iterator it = users.begin();\n       it != users.end();\n       ++it, ++i) {\n    if ((*it)->GetType() == user_manager::USER_TYPE_PUBLIC_ACCOUNT) {\n      index = i;\n      break;\n    }\n  }\n\n  return index;\n}\n", "target": 0, "idx": 138874}
{"func": "chrand_principal_2_svc(chrand_arg *arg, struct svc_req *rqstp)\n{\n    static chrand_ret           ret;\n     krb5_keyblock               *k;\n     int                         nkeys;\n     char                        *prime_arg, *funcname;\n    gss_buffer_desc             client_name,\n        service_name;\n     OM_uint32                   minor_stat;\n     kadm5_server_handle_t       handle;\n     const char                  *errmsg = NULL;\n\n    xdr_free(xdr_chrand_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    funcname = \"kadm5_randkey_principal\";\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ)) {\n        ret.code = randkey_principal_wrapper_3((void *)handle, arg->princ,\n                                               FALSE, 0, NULL, &k, &nkeys);\n    } else if (!(CHANGEPW_SERVICE(rqstp)) &&\n               kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                                  ACL_CHANGEPW, arg->princ, NULL)) {\n        ret.code = kadm5_randkey_principal((void *)handle, arg->princ,\n                                           &k, &nkeys);\n    } else {\n        log_unauth(funcname, prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_CHANGEPW;\n    }\n\n    if(ret.code == KADM5_OK) {\n        ret.keys = k;\n        ret.n_keys = nkeys;\n    }\n\n    if(ret.code != KADM5_AUTH_CHANGEPW) {\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(funcname, prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n             krb5_free_error_message(handle->context, errmsg);\n     }\n     free(prime_arg);\n     gss_release_buffer(&minor_stat, &client_name);\n     gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n     free_server_handle(handle);\n     return &ret;\n }\n", "target": 1, "idx": 180679}
{"func": "HarfBuzzShaper::HarfBuzzShaper(const Font* font, const TextRun& run, const GlyphData* emphasisData,\n    HashSet<const SimpleFontData*>* fallbackFonts, FloatRect* bounds)\n    : Shaper(font, run, emphasisData, fallbackFonts, bounds)\n    , m_normalizedBufferLength(0)\n    , m_wordSpacingAdjustment(font->fontDescription().wordSpacing())\n    , m_letterSpacing(font->fontDescription().letterSpacing())\n     , m_expansionOpportunityCount(0)\n     , m_fromIndex(0)\n     , m_toIndex(m_run.length())\n {\n     m_normalizedBuffer = adoptArrayPtr(new UChar[m_run.length() + 1]);\n     normalizeCharacters(m_run, m_run.length(), m_normalizedBuffer.get(), &m_normalizedBufferLength);\n    setExpansion(m_run.expansion());\n    setFontFeatures();\n}\n", "target": 1, "idx": 185882}
{"func": "static Image *ReadBMPImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  BMPInfo\n    bmp_info;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset,\n    profile_data,\n    profile_size,\n    start_position;\n\n  MemoryInfo\n    *pixel_info;\n\n  Quantum\n    index;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bit,\n    bytes_per_line,\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    magick[12],\n    *pixels;\n\n  unsigned int\n    blue,\n    green,\n    offset_bits,\n    red;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Determine if this a BMP file.\n  */\n  (void) memset(&bmp_info,0,sizeof(bmp_info));\n  bmp_info.ba_offset=0;\n  start_position=0;\n  offset_bits=0;\n  count=ReadBlob(image,2,magick);\n  if (count != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  do\n  {\n    PixelInfo\n      quantum_bits;\n\n    PixelPacket\n      shift;\n\n    /*\n      Verify BMP identifier.\n    */\n    start_position=TellBlob(image)-2;\n    bmp_info.ba_offset=0;\n    while (LocaleNCompare((char *) magick,\"BA\",2) == 0)\n    {\n      bmp_info.file_size=ReadBlobLSBLong(image);\n      bmp_info.ba_offset=ReadBlobLSBLong(image);\n      bmp_info.offset_bits=ReadBlobLSBLong(image);\n      count=ReadBlob(image,2,magick);\n      if (count != 2)\n        break;\n    }\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Magick: %c%c\",\n        magick[0],magick[1]);\n    if ((count != 2) || ((LocaleNCompare((char *) magick,\"BM\",2) != 0) &&\n        (LocaleNCompare((char *) magick,\"CI\",2) != 0)))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    bmp_info.file_size=ReadBlobLSBLong(image);\n    (void) ReadBlobLSBLong(image);\n    bmp_info.offset_bits=ReadBlobLSBLong(image);\n    bmp_info.size=ReadBlobLSBLong(image);\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  BMP size: %u\",\n        bmp_info.size);\n    profile_data=0;\n    profile_size=0;\n    if (bmp_info.size == 12)\n      {\n        /*\n          OS/2 BMP image file.\n        */\n        (void) CopyMagickString(image->magick,\"BMP2\",MagickPathExtent);\n        bmp_info.width=(ssize_t) ((short) ReadBlobLSBShort(image));\n        bmp_info.height=(ssize_t) ((short) ReadBlobLSBShort(image));\n        bmp_info.planes=ReadBlobLSBShort(image);\n        bmp_info.bits_per_pixel=ReadBlobLSBShort(image);\n        bmp_info.x_pixels=0;\n        bmp_info.y_pixels=0;\n        bmp_info.number_colors=0;\n        bmp_info.compression=BI_RGB;\n        bmp_info.image_size=0;\n        bmp_info.alpha_mask=0;\n        if (image->debug != MagickFalse)\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Format: OS/2 Bitmap\");\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Geometry: %.20gx%.20g\",(double) bmp_info.width,(double)\n              bmp_info.height);\n          }\n      }\n    else\n      {\n        /*\n          Microsoft Windows BMP image file.\n        */\n        if (bmp_info.size < 40)\n          ThrowReaderException(CorruptImageError,\"NonOS2HeaderSizeError\");\n        bmp_info.width=(ssize_t) ReadBlobLSBSignedLong(image);\n        bmp_info.height=(ssize_t) ReadBlobLSBSignedLong(image);\n        bmp_info.planes=ReadBlobLSBShort(image);\n        bmp_info.bits_per_pixel=ReadBlobLSBShort(image);\n        bmp_info.compression=ReadBlobLSBLong(image);\n        bmp_info.image_size=ReadBlobLSBLong(image);\n        bmp_info.x_pixels=ReadBlobLSBLong(image);\n        bmp_info.y_pixels=ReadBlobLSBLong(image);\n        bmp_info.number_colors=ReadBlobLSBLong(image);\n        if ((MagickSizeType) bmp_info.number_colors > GetBlobSize(image))\n          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n        bmp_info.colors_important=ReadBlobLSBLong(image);\n        if (image->debug != MagickFalse)\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Format: MS Windows bitmap\");\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Geometry: %.20gx%.20g\",(double) bmp_info.width,(double)\n              bmp_info.height);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Bits per pixel: %.20g\",(double) bmp_info.bits_per_pixel);\n            switch (bmp_info.compression)\n            {\n              case BI_RGB:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression: BI_RGB\");\n                break;\n              }\n              case BI_RLE4:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression: BI_RLE4\");\n                break;\n              }\n              case BI_RLE8:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression: BI_RLE8\");\n                break;\n              }\n              case BI_BITFIELDS:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression: BI_BITFIELDS\");\n                break;\n              }\n              case BI_PNG:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression: BI_PNG\");\n                break;\n              }\n              case BI_JPEG:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression: BI_JPEG\");\n                break;\n              }\n              default:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression: UNKNOWN (%u)\",bmp_info.compression);\n              }\n            }\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Number of colors: %u\",bmp_info.number_colors);\n          }\n        bmp_info.red_mask=ReadBlobLSBLong(image);\n        bmp_info.green_mask=ReadBlobLSBLong(image);\n        bmp_info.blue_mask=ReadBlobLSBLong(image);\n        if (bmp_info.size > 40)\n          {\n            double\n              gamma;\n\n            /*\n              Read color management information.\n            */\n            bmp_info.alpha_mask=ReadBlobLSBLong(image);\n            bmp_info.colorspace=ReadBlobLSBSignedLong(image);\n            /*\n              Decode 2^30 fixed point formatted CIE primaries.\n            */\n#           define BMP_DENOM ((double) 0x40000000)\n            bmp_info.red_primary.x=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.red_primary.y=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.red_primary.z=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.green_primary.x=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.green_primary.y=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.green_primary.z=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.blue_primary.x=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.blue_primary.y=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.blue_primary.z=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n\n            gamma=bmp_info.red_primary.x+bmp_info.red_primary.y+\n              bmp_info.red_primary.z;\n            gamma=PerceptibleReciprocal(gamma);\n            bmp_info.red_primary.x*=gamma;\n            bmp_info.red_primary.y*=gamma;\n            image->chromaticity.red_primary.x=bmp_info.red_primary.x;\n            image->chromaticity.red_primary.y=bmp_info.red_primary.y;\n\n            gamma=bmp_info.green_primary.x+bmp_info.green_primary.y+\n              bmp_info.green_primary.z;\n            gamma=PerceptibleReciprocal(gamma);\n            bmp_info.green_primary.x*=gamma;\n            bmp_info.green_primary.y*=gamma;\n            image->chromaticity.green_primary.x=bmp_info.green_primary.x;\n            image->chromaticity.green_primary.y=bmp_info.green_primary.y;\n\n            gamma=bmp_info.blue_primary.x+bmp_info.blue_primary.y+\n              bmp_info.blue_primary.z;\n            gamma=PerceptibleReciprocal(gamma);\n            bmp_info.blue_primary.x*=gamma;\n            bmp_info.blue_primary.y*=gamma;\n            image->chromaticity.blue_primary.x=bmp_info.blue_primary.x;\n            image->chromaticity.blue_primary.y=bmp_info.blue_primary.y;\n\n            /*\n              Decode 16^16 fixed point formatted gamma_scales.\n            */\n            bmp_info.gamma_scale.x=(double) ReadBlobLSBLong(image)/0x10000;\n            bmp_info.gamma_scale.y=(double) ReadBlobLSBLong(image)/0x10000;\n            bmp_info.gamma_scale.z=(double) ReadBlobLSBLong(image)/0x10000;\n            /*\n              Compute a single gamma from the BMP 3-channel gamma.\n            */\n            image->gamma=(bmp_info.gamma_scale.x+bmp_info.gamma_scale.y+\n              bmp_info.gamma_scale.z)/3.0;\n          }\n        else\n          (void) CopyMagickString(image->magick,\"BMP3\",MagickPathExtent);\n\n        if (bmp_info.size > 108)\n          {\n            size_t\n              intent;\n\n            /*\n              Read BMP Version 5 color management information.\n            */\n            intent=ReadBlobLSBLong(image);\n            switch ((int) intent)\n            {\n              case LCS_GM_BUSINESS:\n              {\n                image->rendering_intent=SaturationIntent;\n                break;\n              }\n              case LCS_GM_GRAPHICS:\n              {\n                image->rendering_intent=RelativeIntent;\n                break;\n              }\n              case LCS_GM_IMAGES:\n              {\n                image->rendering_intent=PerceptualIntent;\n                break;\n              }\n              case LCS_GM_ABS_COLORIMETRIC:\n              {\n                image->rendering_intent=AbsoluteIntent;\n                break;\n              }\n            }\n            profile_data=(MagickOffsetType)ReadBlobLSBLong(image);\n            profile_size=(MagickOffsetType)ReadBlobLSBLong(image);\n            (void) ReadBlobLSBLong(image);  /* Reserved byte */\n          }\n      }\n    if ((MagickSizeType) bmp_info.file_size > GetBlobSize(image))\n      (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,\n        \"LengthAndFilesizeDoNotMatch\",\"`%s'\",image->filename);\n    else\n      if ((MagickSizeType) bmp_info.file_size < GetBlobSize(image))\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          CorruptImageWarning,\"LengthAndFilesizeDoNotMatch\",\"`%s'\",\n          image->filename);\n    if (bmp_info.width <= 0)\n      ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n    if (bmp_info.height == 0)\n      ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n    if (bmp_info.planes != 1)\n      ThrowReaderException(CorruptImageError,\"StaticPlanesValueNotEqualToOne\");\n    if ((bmp_info.bits_per_pixel != 1) && (bmp_info.bits_per_pixel != 4) &&\n        (bmp_info.bits_per_pixel != 8) && (bmp_info.bits_per_pixel != 16) &&\n        (bmp_info.bits_per_pixel != 24) && (bmp_info.bits_per_pixel != 32))\n      ThrowReaderException(CorruptImageError,\"UnsupportedBitsPerPixel\");\n    if (bmp_info.bits_per_pixel < 16 &&\n        bmp_info.number_colors > (1U << bmp_info.bits_per_pixel))\n      ThrowReaderException(CorruptImageError,\"UnrecognizedNumberOfColors\");\n    if ((bmp_info.compression == 1) && (bmp_info.bits_per_pixel != 8))\n      ThrowReaderException(CorruptImageError,\"UnsupportedBitsPerPixel\");\n    if ((bmp_info.compression == 2) && (bmp_info.bits_per_pixel != 4))\n      ThrowReaderException(CorruptImageError,\"UnsupportedBitsPerPixel\");\n    if ((bmp_info.compression == 3) && (bmp_info.bits_per_pixel < 16))\n      ThrowReaderException(CorruptImageError,\"UnsupportedBitsPerPixel\");\n    switch (bmp_info.compression)\n    {\n      case BI_RGB:\n        image->compression=NoCompression;\n        break;\n      case BI_RLE8:\n      case BI_RLE4:\n        image->compression=RLECompression;\n        break;\n      case BI_BITFIELDS:\n        break;\n      case BI_JPEG:\n        ThrowReaderException(CoderError,\"JPEGCompressNotSupported\");\n      case BI_PNG:\n        ThrowReaderException(CoderError,\"PNGCompressNotSupported\");\n      default:\n        ThrowReaderException(CorruptImageError,\"UnrecognizedImageCompression\");\n    }\n    image->columns=(size_t) MagickAbsoluteValue(bmp_info.width);\n    image->rows=(size_t) MagickAbsoluteValue(bmp_info.height);\n    image->depth=bmp_info.bits_per_pixel <= 8 ? bmp_info.bits_per_pixel : 8;\n    image->alpha_trait=((bmp_info.alpha_mask != 0) &&\n      (bmp_info.compression == BI_BITFIELDS)) ? BlendPixelTrait :\n      UndefinedPixelTrait;\n    if (bmp_info.bits_per_pixel < 16)\n      {\n        size_t\n          one;\n\n        image->storage_class=PseudoClass;\n        image->colors=bmp_info.number_colors;\n        one=1;\n        if (image->colors == 0)\n          image->colors=one << bmp_info.bits_per_pixel;\n      }\n    image->resolution.x=(double) bmp_info.x_pixels/100.0;\n    image->resolution.y=(double) bmp_info.y_pixels/100.0;\n    image->units=PixelsPerCentimeterResolution;\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    if (image->storage_class == PseudoClass)\n      {\n        unsigned char\n          *bmp_colormap;\n\n        size_t\n          packet_size;\n\n        /*\n          Read BMP raster colormap.\n        */\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Reading colormap of %.20g colors\",(double) image->colors);\n        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        bmp_colormap=(unsigned char *) AcquireQuantumMemory((size_t)\n          image->colors,4*sizeof(*bmp_colormap));\n        if (bmp_colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        if ((bmp_info.size == 12) || (bmp_info.size == 64))\n          packet_size=3;\n        else\n          packet_size=4;\n        offset=SeekBlob(image,start_position+14+bmp_info.size,SEEK_SET);\n        if (offset < 0)\n          {\n            bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n          }\n        count=ReadBlob(image,packet_size*image->colors,bmp_colormap);\n        if (count != (ssize_t) (packet_size*image->colors))\n          {\n            bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);\n            ThrowReaderException(CorruptImageError,\n              \"InsufficientImageDataInFile\");\n          }\n        p=bmp_colormap;\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          image->colormap[i].blue=(MagickRealType) ScaleCharToQuantum(*p++);\n          image->colormap[i].green=(MagickRealType) ScaleCharToQuantum(*p++);\n          image->colormap[i].red=(MagickRealType) ScaleCharToQuantum(*p++);\n          if (packet_size == 4)\n            p++;\n        }\n        bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);\n      }\n    /*\n      Read image data.\n    */\n    if (bmp_info.offset_bits == offset_bits)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    offset_bits=bmp_info.offset_bits;\n    offset=SeekBlob(image,start_position+bmp_info.offset_bits,SEEK_SET);\n    if (offset < 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if (bmp_info.compression == BI_RLE4)\n      bmp_info.bits_per_pixel<<=1;\n    bytes_per_line=4*((image->columns*bmp_info.bits_per_pixel+31)/32);\n    length=(size_t) bytes_per_line*image->rows;\n    if ((MagickSizeType) (length/256) > GetBlobSize(image))\n      ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n    if ((bmp_info.compression == BI_RGB) ||\n        (bmp_info.compression == BI_BITFIELDS))\n      {\n        pixel_info=AcquireVirtualMemory(image->rows,\n          MagickMax(bytes_per_line,image->columns+256UL)*sizeof(*pixels));\n        if (pixel_info == (MemoryInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Reading pixels (%.20g bytes)\",(double) length);\n        count=ReadBlob(image,length,pixels);\n        if (count != (ssize_t) length)\n          {\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowReaderException(CorruptImageError,\n              \"InsufficientImageDataInFile\");\n          }\n      }\n    else\n      {\n        /*\n          Convert run-length encoded raster pixels.\n        */\n        pixel_info=AcquireVirtualMemory(image->rows,\n          MagickMax(bytes_per_line,image->columns+256UL)*sizeof(*pixels));\n        if (pixel_info == (MemoryInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n        status=DecodeImage(image,bmp_info.compression,pixels,\n          image->columns*image->rows);\n        if (status == MagickFalse)\n          {\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowReaderException(CorruptImageError,\n              \"UnableToRunlengthDecodeImage\");\n          }\n      }\n    /*\n      Convert BMP raster image to pixel packets.\n    */\n    if (bmp_info.compression == BI_RGB)\n      {\n        /*\n          We should ignore the alpha value in BMP3 files but there have been\n          reports about 32 bit files with alpha. We do a quick check to see if\n          the alpha channel contains a value that is not zero (default value).\n          If we find a non zero value we asume the program that wrote the file\n          wants to use the alpha channel.\n        */\n        if ((image->alpha_trait == UndefinedPixelTrait) &&\n            (bmp_info.size == 40) && (bmp_info.bits_per_pixel == 32))\n          {\n            bytes_per_line=4*(image->columns);\n            for (y=(ssize_t) image->rows-1; y >= 0; y--)\n            {\n              p=pixels+(image->rows-y-1)*bytes_per_line;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                if (*(p+3) != 0)\n                  {\n                    image->alpha_trait=BlendPixelTrait;\n                    y=-1;\n                    break;\n                  }\n                p+=4;\n              }\n            }\n          }\n        bmp_info.alpha_mask=image->alpha_trait != UndefinedPixelTrait ?\n          0xff000000U : 0U;\n        bmp_info.red_mask=0x00ff0000U;\n        bmp_info.green_mask=0x0000ff00U;\n        bmp_info.blue_mask=0x000000ffU;\n        if (bmp_info.bits_per_pixel == 16)\n          {\n            /*\n              RGB555.\n            */\n            bmp_info.red_mask=0x00007c00U;\n            bmp_info.green_mask=0x000003e0U;\n            bmp_info.blue_mask=0x0000001fU;\n          }\n      }\n    (void) memset(&shift,0,sizeof(shift));\n    (void) memset(&quantum_bits,0,sizeof(quantum_bits));\n    if ((bmp_info.bits_per_pixel == 16) || (bmp_info.bits_per_pixel == 32))\n      {\n        register unsigned int\n          sample;\n\n        /*\n          Get shift and quantum bits info from bitfield masks.\n        */\n        if (bmp_info.red_mask != 0)\n          while (((bmp_info.red_mask << shift.red) & 0x80000000UL) == 0)\n          {\n            shift.red++;\n            if (shift.red >= 32U)\n              break;\n          }\n        if (bmp_info.green_mask != 0)\n          while (((bmp_info.green_mask << shift.green) & 0x80000000UL) == 0)\n          {\n            shift.green++;\n            if (shift.green >= 32U)\n              break;\n          }\n        if (bmp_info.blue_mask != 0)\n          while (((bmp_info.blue_mask << shift.blue) & 0x80000000UL) == 0)\n          {\n            shift.blue++;\n            if (shift.blue >= 32U)\n              break;\n          }\n        if (bmp_info.alpha_mask != 0)\n          while (((bmp_info.alpha_mask << shift.alpha) & 0x80000000UL) == 0)\n          {\n            shift.alpha++;\n            if (shift.alpha >= 32U)\n              break;\n          }\n        sample=shift.red;\n        while (((bmp_info.red_mask << sample) & 0x80000000UL) != 0)\n        {\n          sample++;\n          if (sample >= 32U)\n            break;\n        }\n        quantum_bits.red=(MagickRealType) (sample-shift.red);\n        sample=shift.green;\n        while (((bmp_info.green_mask << sample) & 0x80000000UL) != 0)\n        {\n          sample++;\n          if (sample >= 32U)\n            break;\n        }\n        quantum_bits.green=(MagickRealType) (sample-shift.green);\n        sample=shift.blue;\n        while (((bmp_info.blue_mask << sample) & 0x80000000UL) != 0)\n        {\n          sample++;\n          if (sample >= 32U)\n            break;\n        }\n        quantum_bits.blue=(MagickRealType) (sample-shift.blue);\n        sample=shift.alpha;\n        while (((bmp_info.alpha_mask << sample) & 0x80000000UL) != 0)\n        {\n          sample++;\n          if (sample >= 32U)\n            break;\n        }\n        quantum_bits.alpha=(MagickRealType) (sample-shift.alpha);\n      }\n    switch (bmp_info.bits_per_pixel)\n    {\n      case 1:\n      {\n        /*\n          Convert bitmap scanline.\n        */\n        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n          {\n            for (bit=0; bit < 8; bit++)\n            {\n              index=(Quantum) (((*p) & (0x80 >> bit)) != 0 ? 0x01 : 0x00);\n              SetPixelIndex(image,index,q);\n              q+=GetPixelChannels(image);\n            }\n            p++;\n          }\n          if ((image->columns % 8) != 0)\n            {\n              for (bit=0; bit < (image->columns % 8); bit++)\n              {\n                index=(Quantum) (((*p) & (0x80 >> bit)) != 0 ? 0x01 : 0x00);\n                SetPixelIndex(image,index,q);\n                q+=GetPixelChannels(image);\n              }\n              p++;\n            }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        (void) SyncImage(image,exception);\n        break;\n      }\n      case 4:\n      {\n        /*\n          Convert PseudoColor scanline.\n        */\n        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < ((ssize_t) image->columns-1); x+=2)\n          {\n            ValidateColormapValue(image,(ssize_t) ((*p >> 4) & 0x0f),&index,\n              exception);\n            SetPixelIndex(image,index,q);\n            q+=GetPixelChannels(image);\n            ValidateColormapValue(image,(ssize_t) (*p & 0x0f),&index,exception);\n            SetPixelIndex(image,index,q);\n            q+=GetPixelChannels(image);\n            p++;\n          }\n          if ((image->columns % 2) != 0)\n            {\n              ValidateColormapValue(image,(ssize_t) ((*p >> 4) & 0xf),&index,\n                exception);\n              SetPixelIndex(image,index,q);\n              q+=GetPixelChannels(image);\n              p++;\n              x++;\n            }\n          if (x < (ssize_t) image->columns)\n            break;\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        (void) SyncImage(image,exception);\n        break;\n      }\n      case 8:\n      {\n        /*\n          Convert PseudoColor scanline.\n        */\n        if ((bmp_info.compression == BI_RLE8) ||\n            (bmp_info.compression == BI_RLE4))\n          bytes_per_line=image->columns;\n        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=(ssize_t) image->columns; x != 0; --x)\n          {\n            ValidateColormapValue(image,(ssize_t) *p++,&index,exception);\n            SetPixelIndex(image,index,q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          offset=(MagickOffsetType) (image->rows-y-1);\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        (void) SyncImage(image,exception);\n        break;\n      }\n      case 16:\n      {\n        unsigned int\n          alpha,\n          pixel;\n\n        /*\n          Convert bitfield encoded 16-bit PseudoColor scanline.\n        */\n        if ((bmp_info.compression != BI_RGB) &&\n            (bmp_info.compression != BI_BITFIELDS))\n          {\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowReaderException(CorruptImageError,\n              \"UnrecognizedImageCompression\");\n          }\n        bytes_per_line=2*(image->columns+image->columns % 2);\n        image->storage_class=DirectClass;\n        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            pixel=(unsigned int) (*p++);\n            pixel|=(*p++) << 8;\n            red=((pixel & bmp_info.red_mask) << shift.red) >> 16;\n            if (quantum_bits.red == 5)\n              red|=((red & 0xe000) >> 5);\n            if (quantum_bits.red <= 8)\n              red|=((red & 0xff00) >> 8);\n            green=((pixel & bmp_info.green_mask) << shift.green) >> 16;\n            if (quantum_bits.green == 5)\n              green|=((green & 0xe000) >> 5);\n            if (quantum_bits.green == 6)\n              green|=((green & 0xc000) >> 6);\n            if (quantum_bits.green <= 8)\n              green|=((green & 0xff00) >> 8);\n            blue=((pixel & bmp_info.blue_mask) << shift.blue) >> 16;\n            if (quantum_bits.blue == 5)\n              blue|=((blue & 0xe000) >> 5);\n            if (quantum_bits.blue <= 8)\n              blue|=((blue & 0xff00) >> 8);\n            SetPixelRed(image,ScaleShortToQuantum((unsigned short) red),q);\n            SetPixelGreen(image,ScaleShortToQuantum((unsigned short) green),q);\n            SetPixelBlue(image,ScaleShortToQuantum((unsigned short) blue),q);\n            SetPixelAlpha(image,OpaqueAlpha,q);\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                alpha=((pixel & bmp_info.alpha_mask) << shift.alpha) >> 16;\n                if (quantum_bits.alpha <= 8)\n                  alpha|=((alpha & 0xff00) >> 8);\n                SetPixelAlpha(image,ScaleShortToQuantum(\n                  (unsigned short) alpha),q);\n              }\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          offset=(MagickOffsetType) (image->rows-y-1);\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 24:\n      {\n        /*\n          Convert DirectColor scanline.\n        */\n        bytes_per_line=4*((image->columns*24+31)/32);\n        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelBlue(image,ScaleCharToQuantum(*p++),q);\n            SetPixelGreen(image,ScaleCharToQuantum(*p++),q);\n            SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n            SetPixelAlpha(image,OpaqueAlpha,q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          offset=(MagickOffsetType) (image->rows-y-1);\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 32:\n      {\n        /*\n          Convert bitfield encoded DirectColor scanline.\n        */\n        if ((bmp_info.compression != BI_RGB) &&\n            (bmp_info.compression != BI_BITFIELDS))\n          {\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowReaderException(CorruptImageError,\n              \"UnrecognizedImageCompression\");\n          }\n        bytes_per_line=4*(image->columns);\n        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          unsigned int\n            alpha,\n            pixel;\n\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            pixel=(unsigned int) (*p++);\n            pixel|=((unsigned int) *p++ << 8);\n            pixel|=((unsigned int) *p++ << 16);\n            pixel|=((unsigned int) *p++ << 24);\n            red=((pixel & bmp_info.red_mask) << shift.red) >> 16;\n            if (quantum_bits.red == 8)\n              red|=(red >> 8);\n            green=((pixel & bmp_info.green_mask) << shift.green) >> 16;\n            if (quantum_bits.green == 8)\n              green|=(green >> 8);\n            blue=((pixel & bmp_info.blue_mask) << shift.blue) >> 16;\n            if (quantum_bits.blue == 8)\n              blue|=(blue >> 8);\n            SetPixelRed(image,ScaleShortToQuantum((unsigned short) red),q);\n            SetPixelGreen(image,ScaleShortToQuantum((unsigned short) green),q);\n            SetPixelBlue(image,ScaleShortToQuantum((unsigned short) blue),q);\n            SetPixelAlpha(image,OpaqueAlpha,q);\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                alpha=((pixel & bmp_info.alpha_mask) << shift.alpha) >> 16;\n                if (quantum_bits.alpha == 8)\n                  alpha|=(alpha >> 8);\n                SetPixelAlpha(image,ScaleShortToQuantum(\n                  (unsigned short) alpha),q);\n              }\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          offset=(MagickOffsetType) (image->rows-y-1);\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      default:\n      {\n        pixel_info=RelinquishVirtualMemory(pixel_info);\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n    }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (y > 0)\n      break;\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    if (bmp_info.height < 0)\n      {\n        Image\n          *flipped_image;\n\n        /*\n          Correct image orientation.\n        */\n        flipped_image=FlipImage(image,exception);\n        if (flipped_image != (Image *) NULL)\n          {\n            DuplicateBlob(flipped_image,image);\n            ReplaceImageInList(&image, flipped_image);\n            image=flipped_image;\n          }\n      }\n    /*\n      Read embeded ICC profile\n    */\n    if ((bmp_info.colorspace == 0x4D424544L) && (profile_data > 0) &&\n        (profile_size > 0))\n      {\n        StringInfo\n          *profile;\n\n        unsigned char\n          *datum;\n\n        offset=start_position+14+profile_data;\n        if ((offset < TellBlob(image)) ||\n            (SeekBlob(image,offset,SEEK_SET) != offset) ||\n            (GetBlobSize(image) < (MagickSizeType) (offset+profile_size)))\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        profile=AcquireStringInfo((size_t) profile_size);\n        if (profile == (StringInfo *) NULL)\n          ThrowReaderException(CorruptImageError,\"MemoryAllocationFailed\");\n        datum=GetStringInfoDatum(profile);\n        if (ReadBlob(image,(size_t) profile_size,datum) == (ssize_t) profile_size)\n          {\n            MagickOffsetType\n              profile_size_orig;\n\n            /*\n             Trimming padded bytes.\n            */\n            profile_size_orig=(MagickOffsetType) datum[0] << 24;\n            profile_size_orig|=(MagickOffsetType) datum[1] << 16;\n            profile_size_orig|=(MagickOffsetType) datum[2] << 8;\n            profile_size_orig|=(MagickOffsetType) datum[3];\n            if (profile_size_orig < profile_size)\n              SetStringInfoLength(profile,(size_t) profile_size_orig);\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"Profile: ICC, %u bytes\",(unsigned int) profile_size_orig);\n            (void) SetImageProfile(image,\"icc\",profile,exception);\n          }\n        profile=DestroyStringInfo(profile);\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    offset=(MagickOffsetType) bmp_info.ba_offset;\n    if (offset != 0)\n      if ((offset < TellBlob(image)) ||\n          (SeekBlob(image,offset,SEEK_SET) != offset))\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    *magick='\\0';\n    count=ReadBlob(image,2,magick);\n    if ((count == 2) && (IsBMP(magick,2) != MagickFalse))\n      {\n        /*\n          Acquire next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n         if (GetNextImageInList(image) == (Image *) NULL)\n           {\n             status=MagickFalse;\n            return((Image *) NULL);\n           }\n         image=SyncNextImageInList(image);\n         status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (IsBMP(magick,2) != MagickFalse);\n  (void) CloseBlob(image);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  return(GetFirstImageInList(image));\n}\n", "target": 1, "idx": 182794}
{"func": "static int csnmp_config_add_data(oconfig_item_t *ci) {\n  data_definition_t *dd;\n  int status = 0;\n\n  dd = calloc(1, sizeof(*dd));\n  if (dd == NULL)\n    return (-1);\n\n  status = cf_util_get_string(ci, &dd->name);\n  if (status != 0) {\n    free(dd);\n    return (-1);\n  }\n\n  dd->scale = 1.0;\n  dd->shift = 0.0;\n\n  for (int i = 0; i < ci->children_num; i++) {\n    oconfig_item_t *option = ci->children + i;\n\n    if (strcasecmp(\"Type\", option->key) == 0)\n      status = cf_util_get_string(option, &dd->type);\n    else if (strcasecmp(\"Table\", option->key) == 0)\n      status = cf_util_get_boolean(option, &dd->is_table);\n    else if (strcasecmp(\"Instance\", option->key) == 0)\n      status = csnmp_config_add_data_instance(dd, option);\n    else if (strcasecmp(\"InstancePrefix\", option->key) == 0)\n      status = csnmp_config_add_data_instance_prefix(dd, option);\n    else if (strcasecmp(\"Values\", option->key) == 0)\n      status = csnmp_config_add_data_values(dd, option);\n    else if (strcasecmp(\"Shift\", option->key) == 0)\n      status = cf_util_get_double(option, &dd->shift);\n    else if (strcasecmp(\"Scale\", option->key) == 0)\n      status = cf_util_get_double(option, &dd->scale);\n    else if (strcasecmp(\"Ignore\", option->key) == 0)\n      status = csnmp_config_add_data_blacklist(dd, option);\n    else if (strcasecmp(\"InvertMatch\", option->key) == 0)\n      status = csnmp_config_add_data_blacklist_match_inverted(dd, option);\n    else {\n      WARNING(\"snmp plugin: Option `%s' not allowed here.\", option->key);\n      status = -1;\n    }\n\n    if (status != 0)\n      break;\n  } /* for (ci->children) */\n\n  while (status == 0) {\n    if (dd->type == NULL) {\n      WARNING(\"snmp plugin: `Type' not given for data `%s'\", dd->name);\n      status = -1;\n      break;\n    }\n    if (dd->values == NULL) {\n      WARNING(\"snmp plugin: No `Value' given for data `%s'\", dd->name);\n      status = -1;\n      break;\n    }\n\n    break;\n  } /* while (status == 0) */\n\n  if (status != 0) {\n    sfree(dd->name);\n    sfree(dd->instance_prefix);\n    sfree(dd->values);\n    sfree(dd->ignores);\n    sfree(dd);\n    return (-1);\n  }\n\n  DEBUG(\"snmp plugin: dd = { name = %s, type = %s, is_table = %s, values_len = \"\n        \"%zu }\",\n        dd->name, dd->type, (dd->is_table != 0) ? \"true\" : \"false\",\n        dd->values_len);\n\n  if (data_head == NULL)\n    data_head = dd;\n  else {\n    data_definition_t *last;\n    last = data_head;\n    while (last->next != NULL)\n      last = last->next;\n    last->next = dd;\n  }\n\n  return (0);\n} /* int csnmp_config_add_data */\n", "target": 0, "idx": 59659}
{"func": "bool GLES2DecoderImpl::SimulateAttrib0(\n    const char* function_name, GLuint max_vertex_accessed, bool* simulated) {\n  DCHECK(simulated);\n  *simulated = false;\n\n  if (gfx::GetGLImplementation() == gfx::kGLImplementationEGLGLES2)\n    return true;\n\n  const VertexAttribManager::VertexAttribInfo* info =\n      vertex_attrib_manager_->GetVertexAttribInfo(0);\n  bool attrib_0_used = current_program_->GetAttribInfoByLocation(0) != NULL;\n  if (info->enabled() && attrib_0_used) {\n    return true;\n  }\n\n   typedef VertexAttribManager::VertexAttribInfo::Vec4 Vec4;\n \n   GLuint num_vertices = max_vertex_accessed + 1;\n  GLuint size_needed = 0;\n \n   if (num_vertices == 0 ||\n      !SafeMultiply(num_vertices, static_cast<GLuint>(sizeof(Vec4)),\n                    &size_needed) ||\n       size_needed > 0x7FFFFFFFU) {\n     SetGLError(GL_OUT_OF_MEMORY, function_name, \"Simulating attrib 0\");\n     return false;\n  }\n\n  PerformanceWarning(\n      \"Attribute 0 is disabled. This has signficant performance penalty\");\n\n  CopyRealGLErrorsToWrapper();\n  glBindBuffer(GL_ARRAY_BUFFER, attrib_0_buffer_id_);\n\n  bool new_buffer = static_cast<GLsizei>(size_needed) > attrib_0_size_;\n  if (new_buffer) {\n    glBufferData(GL_ARRAY_BUFFER, size_needed, NULL, GL_DYNAMIC_DRAW);\n    GLenum error = glGetError();\n    if (error != GL_NO_ERROR) {\n      SetGLError(GL_OUT_OF_MEMORY, function_name, \"Simulating attrib 0\");\n      return false;\n    }\n  }\n  if (new_buffer ||\n      (attrib_0_used &&\n       (!attrib_0_buffer_matches_value_ ||\n        (info->value().v[0] != attrib_0_value_.v[0] ||\n         info->value().v[1] != attrib_0_value_.v[1] ||\n         info->value().v[2] != attrib_0_value_.v[2] ||\n         info->value().v[3] != attrib_0_value_.v[3])))) {\n    std::vector<Vec4> temp(num_vertices, info->value());\n    glBufferSubData(GL_ARRAY_BUFFER, 0, size_needed, &temp[0].v[0]);\n    attrib_0_buffer_matches_value_ = true;\n    attrib_0_value_ = info->value();\n    attrib_0_size_ = size_needed;\n  }\n\n  glVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, 0, NULL);\n\n  if (info->divisor())\n    glVertexAttribDivisorANGLE(0, 0);\n\n  *simulated = true;\n  return true;\n}\n", "target": 1, "idx": 184324}
{"func": "MagickPrivate MagickBooleanType CacheComponentGenesis(void)\n{\n  if (cache_semaphore == (SemaphoreInfo *) NULL)\n    cache_semaphore=AcquireSemaphoreInfo();\n  return(MagickTrue);\n}\n", "target": 0, "idx": 94762}
{"func": "  content::WebContents* web_contents() { return stub_->web_contents(); }\n", "target": 0, "idx": 151852}
{"func": "static void on_new_connection(nw_ses *ses)\n{\n    log_trace(\"new connection from: %s\", nw_sock_human_addr(&ses->peer_addr));\n    struct clt_info *info = ses->privdata;\n    memset(info, 0, sizeof(struct clt_info));\n    info->ses = ses;\n    info->last_activity = current_timestamp();\n    http_parser_init(&info->parser, HTTP_REQUEST);\n    info->parser.data = info;\n}\n", "target": 0, "idx": 76581}
{"func": "SMB2_write(const unsigned int xid, struct cifs_io_parms *io_parms,\n\t   unsigned int *nbytes, struct kvec *iov, int n_vec)\n{\n\tstruct smb_rqst rqst;\n\tint rc = 0;\n\tstruct smb2_write_req *req = NULL;\n\tstruct smb2_write_rsp *rsp = NULL;\n\tint resp_buftype;\n\tstruct kvec rsp_iov;\n\tint flags = 0;\n\tunsigned int total_len;\n\n\t*nbytes = 0;\n\n\tif (n_vec < 1)\n\t\treturn rc;\n\n\trc = smb2_plain_req_init(SMB2_WRITE, io_parms->tcon, (void **) &req,\n\t\t\t     &total_len);\n\tif (rc)\n\t\treturn rc;\n\n\tif (io_parms->tcon->ses->server == NULL)\n\t\treturn -ECONNABORTED;\n\n\tif (smb3_encryption_required(io_parms->tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\treq->sync_hdr.ProcessId = cpu_to_le32(io_parms->pid);\n\n\treq->PersistentFileId = io_parms->persistent_fid;\n\treq->VolatileFileId = io_parms->volatile_fid;\n\treq->WriteChannelInfoOffset = 0;\n\treq->WriteChannelInfoLength = 0;\n\treq->Channel = 0;\n\treq->Length = cpu_to_le32(io_parms->length);\n\treq->Offset = cpu_to_le64(io_parms->offset);\n\treq->DataOffset = cpu_to_le16(\n\t\t\t\toffsetof(struct smb2_write_req, Buffer));\n\treq->RemainingBytes = 0;\n\n\ttrace_smb3_write_enter(xid, io_parms->persistent_fid,\n\t\tio_parms->tcon->tid, io_parms->tcon->ses->Suid,\n\t\tio_parms->offset, io_parms->length);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 1 for Buffer */\n\tiov[0].iov_len = total_len - 1;\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = n_vec + 1;\n \n \trc = cifs_send_recv(xid, io_parms->tcon->ses, &rqst,\n \t\t\t    &resp_buftype, flags, &rsp_iov);\n\tcifs_small_buf_release(req);\n \trsp = (struct smb2_write_rsp *)rsp_iov.iov_base;\n \n \tif (rc) {\n\t\ttrace_smb3_write_err(xid, req->PersistentFileId,\n\t\t\t\t     io_parms->tcon->tid,\n\t\t\t\t     io_parms->tcon->ses->Suid,\n\t\t\t\t     io_parms->offset, io_parms->length, rc);\n\t\tcifs_stats_fail_inc(io_parms->tcon, SMB2_WRITE_HE);\n\t\tcifs_dbg(VFS, \"Send error in write = %d\\n\", rc);\n\t} else {\n\t\t*nbytes = le32_to_cpu(rsp->DataLength);\n\t\ttrace_smb3_write_done(xid, req->PersistentFileId,\n\t\t\t\t     io_parms->tcon->tid,\n\t\t\t\t     io_parms->tcon->ses->Suid,\n \t\t\t\t     io_parms->offset, *nbytes);\n \t}\n \n \tfree_rsp_buf(resp_buftype, rsp);\n \treturn rc;\n }\n", "target": 1, "idx": 182698}
{"func": "ModuleExport void UnregisterSCRImage(void)\n{\n  (void) UnregisterMagickInfo(\"SCR\");\n}\n", "target": 0, "idx": 71680}
{"func": "static inline realpath_cache_bucket* realpath_cache_find(const char *path, int path_len, time_t t TSRMLS_DC) /* {{{ */\n{\n#ifdef PHP_WIN32\n\tunsigned long key = realpath_cache_key(path, path_len TSRMLS_CC);\n#else\n\tunsigned long key = realpath_cache_key(path, path_len);\n#endif\n\n\tunsigned long n = key % (sizeof(CWDG(realpath_cache)) / sizeof(CWDG(realpath_cache)[0]));\n\trealpath_cache_bucket **bucket = &CWDG(realpath_cache)[n];\n\n\twhile (*bucket != NULL) {\n\t\tif (CWDG(realpath_cache_ttl) && (*bucket)->expires < t) {\n                        realpath_cache_bucket *r = *bucket;\n                        *bucket = (*bucket)->next;\n \n                       /* if the pointers match then only subtract the length of the path */              \n                        if(r->path == r->realpath) {\n                                CWDG(realpath_cache_size) -= sizeof(realpath_cache_bucket) + r->path_len + 1;\n                        } else {\n\t\t\t\tCWDG(realpath_cache_size) -= sizeof(realpath_cache_bucket) + r->path_len + 1 + r->realpath_len + 1;\n\t\t\t}\n\t\t\tfree(r);\n\t\t} else if (key == (*bucket)->key && path_len == (*bucket)->path_len &&\n\t\t\t\t\tmemcmp(path, (*bucket)->path, path_len) == 0) {\n\t\t\treturn *bucket;\n\t\t} else {\n\t\t\tbucket = &(*bucket)->next;\n\t\t}\n\t}\n\treturn NULL;\n}\n/* }}} */\n", "target": 1, "idx": 178155}
{"func": "GF_Err saiz_Size(GF_Box *s)\n{\n\tGF_SampleAuxiliaryInfoSizeBox *ptr = (GF_SampleAuxiliaryInfoSizeBox*)s;\n\n\tif (ptr->aux_info_type || ptr->aux_info_type_parameter) {\n\t\tptr->flags |= 1;\n\t}\n\tif (ptr->flags & 1) ptr->size += 8;\n\tptr->size += 5;\n\tif (ptr->default_sample_info_size==0)  ptr->size += ptr->sample_count;\n\treturn GF_OK;\n}\n", "target": 0, "idx": 80378}
{"func": "static void glfs_async_cbk(glfs_fd_t *fd, ssize_t ret, void *data)\n{\n\tglfs_cbk_cookie *cookie = data;\n\tstruct tcmu_device *dev = cookie->dev;\n\tstruct tcmulib_cmd *cmd = cookie->cmd;\n\tsize_t length = cookie->length;\n\n\tif (ret < 0 || ret != length) {\n\t\t/* Read/write/flush failed */\n\t\tswitch (cookie->op) {\n\t\tcase TCMU_GLFS_READ:\n\t\t\tret =  tcmu_set_sense_data(cmd->sense_buf, MEDIUM_ERROR,\n\t\t\t                           ASC_READ_ERROR, NULL);\n\t\t\tbreak;\n\t\tcase TCMU_GLFS_WRITE:\n\t\tcase TCMU_GLFS_FLUSH:\n\t\t\tret =  tcmu_set_sense_data(cmd->sense_buf, MEDIUM_ERROR,\n\t\t\t                           ASC_WRITE_ERROR, NULL);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tret = SAM_STAT_GOOD;\n\t}\n\n\tcmd->done(dev, cmd, ret);\n\tfree(cookie);\n}\n", "target": 0, "idx": 59057}
{"func": "HTMLFrameOwnerElement* Document::ownerElement() const\n{\n    if (!frame())\n        return 0;\n    return frame()->deprecatedLocalOwner();\n}\n", "target": 0, "idx": 135318}
{"func": " static void dump_completed_IO(struct inode * inode)\n {\n #ifdef\tEXT4_DEBUG\n \tstruct list_head *cur, *before, *after;\n \text4_io_end_t *io, *io0, *io1;\n \n \tif (list_empty(&EXT4_I(inode)->i_completed_io_list)){\n \t\text4_debug(\"inode %lu completed_io list is empty\\n\", inode->i_ino);\n \t\treturn;\n \t}\n \n \text4_debug(\"Dump inode %lu completed_io list \\n\", inode->i_ino);\n \tlist_for_each_entry(io, &EXT4_I(inode)->i_completed_io_list, list){\n \t\tcur = &io->list;\n \t\tbefore = cur->prev;\n\t\tio0 = container_of(before, ext4_io_end_t, list);\n\t\tafter = cur->next;\n\t\tio1 = container_of(after, ext4_io_end_t, list);\n\n \t\text4_debug(\"io 0x%p from inode %lu,prev 0x%p,next 0x%p\\n\",\n \t\t\t    io, inode->i_ino, io0, io1);\n \t}\n #endif\n }\n", "target": 1, "idx": 180711}
{"func": "static int decode_first_pnfs_layout_type(struct xdr_stream *xdr,\n\t\t\t\t\t uint32_t *layouttype)\n{\n\tuint32_t *p;\n\tint num;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\tgoto out_overflow;\n\tnum = be32_to_cpup(p);\n\n\t/* pNFS is not supported by the underlying file system */\n\tif (num == 0) {\n\t\t*layouttype = 0;\n\t\treturn 0;\n\t}\n\tif (num > 1)\n\t\tprintk(KERN_INFO \"%s: Warning: Multiple pNFS layout drivers \"\n\t\t\t\"per filesystem not supported\\n\", __func__);\n\n\t/* Decode and set first layout type, move xdr->p past unused types */\n\tp = xdr_inline_decode(xdr, num * 4);\n\tif (unlikely(!p))\n\t\tgoto out_overflow;\n\t*layouttype = be32_to_cpup(p);\n\treturn 0;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}\n", "target": 0, "idx": 23300}
{"func": " bool __net_get_random_once(void *buf, int nbytes, bool *done,\n\t\t\t   struct static_key *done_key)\n {\n \tstatic DEFINE_SPINLOCK(lock);\n \tunsigned long flags;\n\n\tspin_lock_irqsave(&lock, flags);\n\tif (*done) {\n\t\tspin_unlock_irqrestore(&lock, flags);\n\t\treturn false;\n\t}\n\n\tget_random_bytes(buf, nbytes);\n \t*done = true;\n \tspin_unlock_irqrestore(&lock, flags);\n \n\t__net_random_once_disable_jump(done_key);\n \n \treturn true;\n }\n", "target": 1, "idx": 179430}
{"func": "FUNC_DECODER(dissector_postgresql)\n{\n   DECLARE_DISP_PTR(ptr);\n   struct ec_session *s = NULL;\n   void *ident = NULL;\n   char tmp[MAX_ASCII_ADDR_LEN];\n   struct postgresql_status *conn_status;\n\n   /* don't complain about unused var */\n   (void) DECODE_DATA; \n   (void) DECODE_DATALEN;\n   (void) DECODED_LEN;\n   \n   if (FROM_CLIENT(\"postgresql\", PACKET)) {\n      if (PACKET->DATA.len < 4)\n         return NULL;\n\n      dissect_create_ident(&ident, PACKET, DISSECT_CODE(dissector_postgresql));\n\n      /* if the session does not exist... */\n      if (session_get(&s, ident, DISSECT_IDENT_LEN) == -ENOTFOUND) {\n         /* search for user and database strings, look for StartupMessage  */\n         unsigned char *u = memmem(ptr, PACKET->DATA.len, \"user\", 4);\n         unsigned char *d = memmem(ptr, PACKET->DATA.len, \"database\", 8);\n         if (!memcmp(ptr + 4, \"\\x00\\x03\\x00\\x00\", 4) && u && d) {\n            /* create the new session */\n            dissect_create_session(&s, PACKET, DISSECT_CODE(dissector_postgresql));\n\n            /* remember the state (used later) */\n            SAFE_CALLOC(s->data, 1, sizeof(struct postgresql_status));\n\n            conn_status = (struct postgresql_status *) s->data;\n            conn_status->status = WAIT_AUTH;\n\n            /* user is always null-terminated */\n            strncpy((char*)conn_status->user, (char*)(u + 5), 65);\n            conn_status->user[64] = 0;\n\n            /* database is always null-terminated */\n            strncpy((char*)conn_status->database, (char*)(d + 9), 65);\n            conn_status->database[64] = 0;\n\n            /* save the session */\n            session_put(s);\n         }\n      } else {\n         conn_status = (struct postgresql_status *) s->data;\n         if (conn_status->status == WAIT_RESPONSE) {\n\n            /* check for PasswordMessage packet */\n            if (ptr[0] == 'p' && conn_status->type == MD5) {\n               DEBUG_MSG(\"\\tDissector_postgresql RESPONSE type is MD5\");\n               if(memcmp(ptr + 1, \"\\x00\\x00\\x00\\x28\", 4)) {\n                  DEBUG_MSG(\"\\tDissector_postgresql BUG, expected length is 40\");\n                  return NULL;\n               }\n               if (PACKET->DATA.len < 40) {\n                  DEBUG_MSG(\"\\tDissector_postgresql BUG, expected length is 40\");\n                  return NULL;\n               }\n               memcpy(conn_status->hash, ptr + 5 + 3, 32);\n               conn_status->hash[32] = 0;\n               DISSECT_MSG(\"%s:$postgres$%s*%s*%s:%s:%d\\n\", conn_status->user, conn_status->user, conn_status->salt, conn_status->hash, ip_addr_ntoa(&PACKET->L3.dst, tmp), ntohs(PACKET->L4.dst));\n               dissect_wipe_session(PACKET, DISSECT_CODE(dissector_postgresql));\n            }\n            else if (ptr[0] == 'p' && conn_status->type == CT) {\n                int length;\n                DEBUG_MSG(\"\\tDissector_postgresql RESPONSE type is clear-text!\");\n                GET_ULONG_BE(length, ptr, 1);\n               strncpy((char*)conn_status->password, (char*)(ptr + 5), length - 4);\n               conn_status->password[length - 4] = 0;\n                DISSECT_MSG(\"PostgreSQL credentials:%s-%d:%s:%s\\n\", ip_addr_ntoa(&PACKET->L3.dst, tmp), ntohs(PACKET->L4.dst), conn_status->user, conn_status->password);\n                dissect_wipe_session(PACKET, DISSECT_CODE(dissector_postgresql));\n             }\n         }\n      }\n   } else { /* Packets coming from the server */\n      if (PACKET->DATA.len < 9)\n         return NULL;\n      dissect_create_ident(&ident, PACKET, DISSECT_CODE(dissector_postgresql));\n\n      if (session_get(&s, ident, DISSECT_IDENT_LEN) == ESUCCESS) {\n         conn_status = (struct postgresql_status *) s->data;\n         if (conn_status->status == WAIT_AUTH &&\n               ptr[0] == 'R' && !memcmp(ptr + 1, \"\\x00\\x00\\x00\\x0c\", 4)  &&\n               !memcmp(ptr + 5, \"\\x00\\x00\\x00\\x05\", 4)) {\n\n            conn_status->status = WAIT_RESPONSE;\n\n            conn_status->type = MD5;\n            DEBUG_MSG(\"\\tDissector_postgresql AUTH type is MD5\");\n            hex_encode(ptr + 9, 4, conn_status->salt); /* save salt */\n         }\n         else if (conn_status->status == WAIT_AUTH &&\n               ptr[0] == 'R' && !memcmp(ptr + 1, \"\\x00\\x00\\x00\\x08\", 4)  &&\n               !memcmp(ptr + 5, \"\\x00\\x00\\x00\\x03\", 4)) {\n            conn_status->status = WAIT_RESPONSE;\n            conn_status->type = CT;\n            DEBUG_MSG(\"\\tDissector_postgresql AUTH type is clear-text!\");\n         }\n      }\n   }\n\n   SAFE_FREE(ident);\n   return NULL;\n}\n", "target": 1, "idx": 179439}
{"func": "GetCurrentRootWindow(DeviceIntPtr dev)\n{\n    return RootWindow(dev->spriteInfo->sprite);\n}\n", "target": 0, "idx": 4837}
{"func": "void HTMLFormElement::addToPastNamesMap(Element* element,\n                                        const AtomicString& pastName) {\n  if (pastName.isEmpty())\n    return;\n  if (!m_pastNamesMap)\n    m_pastNamesMap = new PastNamesMap;\n  m_pastNamesMap->set(pastName, element);\n}\n", "target": 0, "idx": 155204}
{"func": "void RenderThreadImpl::WidgetHidden() {\n  DCHECK(hidden_widget_count_ < widget_count_);\n  hidden_widget_count_++;\n\n  if (!content::GetContentClient()->renderer()->\n          RunIdleHandlerWhenWidgetsHidden()) {\n    return;\n  }\n\n  if (widget_count_ && hidden_widget_count_ == widget_count_)\n    ScheduleIdleHandler(kInitialIdleHandlerDelayMs);\n}\n", "target": 0, "idx": 114620}
{"func": "long long Block::GetTrackNumber() const\n{\n    return m_track;\n }\n", "target": 1, "idx": 188394}
{"func": "  explicit CancelAndIgnoreNavigationForPluginFrameThrottle(\n      NavigationHandle* handle)\n      : NavigationThrottle(handle) {}\n", "target": 1, "idx": 187016}
{"func": "pdf_xref_find_subsection(fz_context *ctx, pdf_document *doc, int64_t ofs, int len)\n{\n\tpdf_xref *xref = &doc->xref_sections[doc->num_xref_sections-1];\n\tpdf_xref_subsec *sub;\n\tint new_max;\n\n\t/* Different cases here. Case 1) We might be asking for a\n\t * subsection (or a subset of a subsection) that we already\n\t * have - Just return it. Case 2) We might be asking for a\n\t * completely new subsection - Create it and return it.\n\t * Case 3) We might have an overlapping one - Create a 'solid'\n\t * subsection and return that. */\n\n\t/* Sanity check */\n\tfor (sub = xref->subsec; sub != NULL; sub = sub->next)\n\t{\n\t\tif (ofs >= sub->start && ofs + len <= sub->start + sub->len)\n\t\t\treturn &sub->table[ofs-sub->start]; /* Case 1 */\n\t\tif (ofs + len > sub->start && ofs <= sub->start + sub->len)\n\t\t\tbreak; /* Case 3 */\n\t}\n\n\tnew_max = xref->num_objects;\n\tif (new_max < ofs + len)\n\t\tnew_max = ofs + len;\n\n\tif (sub == NULL)\n\t{\n\t\t/* Case 2 */\n\t\tsub = fz_malloc_struct(ctx, pdf_xref_subsec);\n\t\tfz_try(ctx)\n\t\t{\n\t\t\tsub->table = fz_calloc(ctx, len, sizeof(pdf_xref_entry));\n\t\t\tsub->start = ofs;\n\t\t\tsub->len = len;\n\t\t\tsub->next = xref->subsec;\n\t\t\txref->subsec = sub;\n\t\t}\n\t\tfz_catch(ctx)\n\t\t{\n\t\t\tfz_free(ctx, sub);\n\t\t\tfz_rethrow(ctx);\n\t\t}\n\t\txref->num_objects = new_max;\n\t\tif (doc->max_xref_len < new_max)\n\t\t\textend_xref_index(ctx, doc, new_max);\n\t}\n\telse\n\t{\n\t\t/* Case 3 */\n\t\tensure_solid_xref(ctx, doc, new_max, doc->num_xref_sections-1);\n\t\txref = &doc->xref_sections[doc->num_xref_sections-1];\n\t\tsub = xref->subsec;\n\t}\n\treturn &sub->table[ofs-sub->start];\n}\n", "target": 0, "idx": 16727}
{"func": "bool GLES2DecoderImpl::CheckFramebufferValid(\n    FramebufferManager::FramebufferInfo* framebuffer,\n    GLenum target, const char* func_name) {\n  if (!framebuffer) {\n    return true;\n  }\n\n  if (framebuffer_manager()->IsComplete(framebuffer)) {\n    return true;\n  }\n\n  GLenum completeness = framebuffer->IsPossiblyComplete();\n  if (completeness != GL_FRAMEBUFFER_COMPLETE) {\n    SetGLError(\n        GL_INVALID_FRAMEBUFFER_OPERATION, func_name, \"framebuffer incomplete\");\n    return false;\n  }\n\n  if (renderbuffer_manager()->HaveUnclearedRenderbuffers() ||\n      texture_manager()->HaveUnclearedMips()) {\n    if (!framebuffer->IsCleared()) {\n      if (glCheckFramebufferStatusEXT(target) != GL_FRAMEBUFFER_COMPLETE) {\n        SetGLError(\n            GL_INVALID_FRAMEBUFFER_OPERATION, func_name,\n            \"framebuffer incomplete (clear)\");\n        return false;\n      }\n      ClearUnclearedAttachments(target, framebuffer);\n    }\n  }\n\n  if (!framebuffer_manager()->IsComplete(framebuffer)) {\n    if (glCheckFramebufferStatusEXT(target) != GL_FRAMEBUFFER_COMPLETE) {\n      SetGLError(\n          GL_INVALID_FRAMEBUFFER_OPERATION, func_name,\n          \"framebuffer incomplete (check)\");\n      return false;\n    }\n    framebuffer_manager()->MarkAsComplete(framebuffer);\n  }\n\n  return true;\n}\n", "target": 0, "idx": 110435}
{"func": "static int vp8_lossy_decode_frame(AVCodecContext *avctx, AVFrame *p,\n                                  int *got_frame, uint8_t *data_start,\n                                  unsigned int data_size)\n{\n    WebPContext *s = avctx->priv_data;\n    AVPacket pkt;\n    int ret;\n\n     if (!s->initialized) {\n         ff_vp8_decode_init(avctx);\n         s->initialized = 1;\n        if (s->has_alpha)\n            avctx->pix_fmt = AV_PIX_FMT_YUVA420P;\n     }\n     s->lossless = 0;\n \n     if (data_size > INT_MAX) {\n        av_log(avctx, AV_LOG_ERROR, \"unsupported chunk size\\n\");\n        return AVERROR_PATCHWELCOME;\n    }\n\n    av_init_packet(&pkt);\n    pkt.data = data_start;\n    pkt.size = data_size;\n\n    ret = ff_vp8_decode_frame(avctx, p, got_frame, &pkt);\n    if (ret < 0)\n        return ret;\n\n    update_canvas_size(avctx, avctx->width, avctx->height);\n\n    if (s->has_alpha) {\n        ret = vp8_lossy_decode_alpha(avctx, p, s->alpha_data,\n                                     s->alpha_data_size);\n        if (ret < 0)\n            return ret;\n    }\n    return ret;\n}\n", "target": 1, "idx": 181244}
{"func": "void GLES2Implementation::InitializeDiscardableTextureCHROMIUM(\n    GLuint texture_id) {\n  ClientDiscardableTextureManager* manager =\n      share_group()->discardable_texture_manager();\n  if (manager->TextureIsValid(texture_id)) {\n    SetGLError(GL_INVALID_VALUE, \"glInitializeDiscardableTextureCHROMIUM\",\n               \"Texture ID already initialized\");\n    return;\n  }\n  ClientDiscardableHandle handle =\n      manager->InitializeTexture(helper_->command_buffer(), texture_id);\n  if (!handle.IsValid())\n    return;\n\n  helper_->InitializeDiscardableTextureCHROMIUM(texture_id, handle.shm_id(),\n                                                handle.byte_offset());\n}\n", "target": 0, "idx": 153748}
{"func": "void TabStripModel::ExecuteContextMenuCommand(\n    int context_index, ContextMenuCommand command_id) {\n  DCHECK(command_id > CommandFirst && command_id < CommandLast);\n  switch (command_id) {\n    case CommandNewTab:\n      content::RecordAction(UserMetricsAction(\"TabContextMenu_NewTab\"));\n      UMA_HISTOGRAM_ENUMERATION(\"Tab.NewTab\",\n                                TabStripModel::NEW_TAB_CONTEXT_MENU,\n                                TabStripModel::NEW_TAB_ENUM_COUNT);\n      delegate()->AddBlankTabAt(context_index + 1, true);\n      break;\n\n    case CommandReload: {\n      content::RecordAction(UserMetricsAction(\"TabContextMenu_Reload\"));\n      std::vector<int> indices = GetIndicesForCommand(context_index);\n      for (size_t i = 0; i < indices.size(); ++i) {\n        WebContents* tab = GetWebContentsAt(indices[i]);\n        if (tab) {\n          CoreTabHelperDelegate* core_delegate =\n              CoreTabHelper::FromWebContents(tab)->delegate();\n          if (!core_delegate || core_delegate->CanReloadContents(tab))\n            tab->GetController().Reload(true);\n        }\n      }\n      break;\n    }\n\n    case CommandDuplicate: {\n      content::RecordAction(UserMetricsAction(\"TabContextMenu_Duplicate\"));\n      std::vector<int> indices = GetIndicesForCommand(context_index);\n      std::vector<WebContents*> tabs;\n      for (size_t i = 0; i < indices.size(); ++i)\n        tabs.push_back(GetWebContentsAt(indices[i]));\n      for (size_t i = 0; i < tabs.size(); ++i) {\n        int index = GetIndexOfWebContents(tabs[i]);\n        if (index != -1 && delegate_->CanDuplicateContentsAt(index))\n          delegate_->DuplicateContentsAt(index);\n      }\n      break;\n    }\n\n    case CommandCloseTab: {\n      content::RecordAction(UserMetricsAction(\"TabContextMenu_CloseTab\"));\n      InternalCloseTabs(GetIndicesForCommand(context_index),\n                        CLOSE_CREATE_HISTORICAL_TAB | CLOSE_USER_GESTURE);\n      break;\n    }\n\n    case CommandCloseOtherTabs: {\n      content::RecordAction(\n          UserMetricsAction(\"TabContextMenu_CloseOtherTabs\"));\n      InternalCloseTabs(GetIndicesClosedByCommand(context_index, command_id),\n                        CLOSE_CREATE_HISTORICAL_TAB);\n      break;\n    }\n\n    case CommandCloseTabsToRight: {\n      content::RecordAction(\n          UserMetricsAction(\"TabContextMenu_CloseTabsToRight\"));\n      InternalCloseTabs(GetIndicesClosedByCommand(context_index, command_id),\n                        CLOSE_CREATE_HISTORICAL_TAB);\n      break;\n    }\n\n    case CommandRestoreTab: {\n      content::RecordAction(UserMetricsAction(\"TabContextMenu_RestoreTab\"));\n      delegate_->RestoreTab();\n      break;\n    }\n\n    case CommandTogglePinned: {\n      content::RecordAction(\n          UserMetricsAction(\"TabContextMenu_TogglePinned\"));\n      std::vector<int> indices = GetIndicesForCommand(context_index);\n      bool pin = WillContextMenuPin(context_index);\n      if (pin) {\n        for (size_t i = 0; i < indices.size(); ++i) {\n          if (!IsAppTab(indices[i]))\n            SetTabPinned(indices[i], true);\n        }\n      } else {\n        for (size_t i = indices.size(); i > 0; --i) {\n          if (!IsAppTab(indices[i - 1]))\n            SetTabPinned(indices[i - 1], false);\n        }\n      }\n      break;\n    }\n\n    case CommandBookmarkAllTabs: {\n      content::RecordAction(\n          UserMetricsAction(\"TabContextMenu_BookmarkAllTabs\"));\n\n      delegate_->BookmarkAllTabs();\n      break;\n    }\n\n    case CommandSelectByDomain:\n    case CommandSelectByOpener: {\n      std::vector<int> indices;\n      if (command_id == CommandSelectByDomain)\n        GetIndicesWithSameDomain(context_index, &indices);\n      else\n        GetIndicesWithSameOpener(context_index, &indices);\n      TabStripSelectionModel selection_model;\n      selection_model.SetSelectedIndex(context_index);\n      for (size_t i = 0; i < indices.size(); ++i)\n        selection_model.AddIndexToSelection(indices[i]);\n      SetSelectionFromModel(selection_model);\n      break;\n    }\n\n    default:\n      NOTREACHED();\n  }\n}\n", "target": 0, "idx": 126617}
{"func": "static void sctp_sock_migrate(struct sock *oldsk, struct sock *newsk,\n\t\t\t      struct sctp_association *assoc,\n\t\t\t      sctp_socket_type_t type)\n{\n\tstruct sctp_sock *oldsp = sctp_sk(oldsk);\n\tstruct sctp_sock *newsp = sctp_sk(newsk);\n\tstruct sctp_bind_bucket *pp; /* hash list port iterator */\n\tstruct sctp_endpoint *newep = newsp->ep;\n\tstruct sk_buff *skb, *tmp;\n\tstruct sctp_ulpevent *event;\n\tint flags = 0;\n\n\t/* Migrate socket buffer sizes and all the socket level options to the\n\t * new socket.\n\t */\n\tnewsk->sk_sndbuf = oldsk->sk_sndbuf;\n\tnewsk->sk_rcvbuf = oldsk->sk_rcvbuf;\n\t/* Brute force copy old sctp opt. */\n\tinet_sk_copy_descendant(newsk, oldsk);\n\n\t/* Restore the ep value that was overwritten with the above structure\n\t * copy.\n\t */\n\tnewsp->ep = newep;\n\tnewsp->hmac = NULL;\n\n\t/* Hook this new socket in to the bind_hash list. */\n\tpp = sctp_sk(oldsk)->bind_hash;\n\tsk_add_bind_node(newsk, &pp->owner);\n\tsctp_sk(newsk)->bind_hash = pp;\n\tinet_sk(newsk)->num = inet_sk(oldsk)->num;\n\n\t/* Copy the bind_addr list from the original endpoint to the new\n\t * endpoint so that we can handle restarts properly\n\t */\n\tif (PF_INET6 == assoc->base.sk->sk_family)\n\t\tflags = SCTP_ADDR6_ALLOWED;\n\tif (assoc->peer.ipv4_address)\n\t\tflags |= SCTP_ADDR4_PEERSUPP;\n\tif (assoc->peer.ipv6_address)\n\t\tflags |= SCTP_ADDR6_PEERSUPP;\n\tsctp_bind_addr_copy(&newsp->ep->base.bind_addr,\n\t\t\t     &oldsp->ep->base.bind_addr,\n\t\t\t     SCTP_SCOPE_GLOBAL, GFP_KERNEL, flags);\n\n\t/* Move any messages in the old socket's receive queue that are for the\n\t * peeled off association to the new socket's receive queue.\n\t */\n \tsctp_skb_for_each(skb, &oldsk->sk_receive_queue, tmp) {\n \t\tevent = sctp_skb2event(skb);\n \t\tif (event->asoc == assoc) {\n\t\t\tsctp_sock_rfree(skb);\n \t\t\t__skb_unlink(skb, &oldsk->sk_receive_queue);\n \t\t\t__skb_queue_tail(&newsk->sk_receive_queue, skb);\n\t\t\tsctp_skb_set_owner_r(skb, newsk);\n \t\t}\n \t}\n \n\t/* Clean up any messages pending delivery due to partial\n\t * delivery.   Three cases:\n\t * 1) No partial deliver;  no work.\n\t * 2) Peeling off partial delivery; keep pd_lobby in new pd_lobby.\n\t * 3) Peeling off non-partial delivery; move pd_lobby to receive_queue.\n\t */\n\tskb_queue_head_init(&newsp->pd_lobby);\n\tsctp_sk(newsk)->pd_mode = assoc->ulpq.pd_mode;\n\n\tif (sctp_sk(oldsk)->pd_mode) {\n\t\tstruct sk_buff_head *queue;\n\n\t\t/* Decide which queue to move pd_lobby skbs to. */\n\t\tif (assoc->ulpq.pd_mode) {\n\t\t\tqueue = &newsp->pd_lobby;\n\t\t} else\n\t\t\tqueue = &newsk->sk_receive_queue;\n\n\t\t/* Walk through the pd_lobby, looking for skbs that\n\t\t * need moved to the new socket.\n\t\t */\n \t\tsctp_skb_for_each(skb, &oldsp->pd_lobby, tmp) {\n \t\t\tevent = sctp_skb2event(skb);\n \t\t\tif (event->asoc == assoc) {\n\t\t\t\tsctp_sock_rfree(skb);\n \t\t\t\t__skb_unlink(skb, &oldsp->pd_lobby);\n \t\t\t\t__skb_queue_tail(queue, skb);\n\t\t\t\tsctp_skb_set_owner_r(skb, newsk);\n \t\t\t}\n \t\t}\n \n\t\t/* Clear up any skbs waiting for the partial\n\t\t * delivery to finish.\n\t\t */\n\t\tif (assoc->ulpq.pd_mode)\n\t\t\tsctp_clear_pd(oldsk);\n \n \t}\n \n \t/* Set the type of socket to indicate that it is peeled off from the\n \t * original UDP-style socket or created with the accept() call on a\n \t * TCP-style socket..\n\t */\n\tnewsp->type = type;\n\n\t/* Mark the new socket \"in-use\" by the user so that any packets\n\t * that may arrive on the association after we've moved it are\n\t * queued to the backlog.  This prevents a potential race between\n\t * backlog processing on the old socket and new-packet processing\n\t * on the new socket.\n\t */\n\tsctp_lock_sock(newsk);\n\tsctp_assoc_migrate(assoc, newsk);\n\n\t/* If the association on the newsk is already closed before accept()\n\t * is called, set RCV_SHUTDOWN flag.\n\t */\n\tif (sctp_state(assoc, CLOSED) && sctp_style(newsk, TCP))\n\t\tnewsk->sk_shutdown |= RCV_SHUTDOWN;\n\n\tnewsk->sk_state = SCTP_SS_ESTABLISHED;\n\tsctp_release_sock(newsk);\n}\n", "target": 1, "idx": 179396}
{"func": "  GBool isOk() { return bitmaps != NULL; }\n", "target": 0, "idx": 14702}
{"func": "LayoutUnit RenderBlockFlow::logicalLeftSelectionOffset(RenderBlock* rootBlock, LayoutUnit position)\n{\n    LayoutUnit logicalLeft = logicalLeftOffsetForLine(position, false);\n    if (logicalLeft == logicalLeftOffsetForContent())\n        return RenderBlock::logicalLeftSelectionOffset(rootBlock, position);\n\n    RenderBlock* cb = this;\n    while (cb != rootBlock) {\n        logicalLeft += cb->logicalLeft();\n        cb = cb->containingBlock();\n    }\n    return logicalLeft;\n}\n", "target": 0, "idx": 124733}
{"func": "int OMXNodeInstance::retrieveFenceFromMeta_l(\n        OMX_BUFFERHEADERTYPE *header, OMX_U32 portIndex) {\n    OMX_U32 metaSize = portIndex == kPortIndexInput ? header->nAllocLen : header->nFilledLen;\n int fenceFd = -1;\n if (mMetadataType[portIndex] == kMetadataBufferTypeANWBuffer\n && header->nAllocLen >= sizeof(VideoNativeMetadata)) {\n VideoNativeMetadata &nativeMeta = *(VideoNativeMetadata *)(header->pBuffer);\n if (nativeMeta.eType == kMetadataBufferTypeANWBuffer) {\n            fenceFd = nativeMeta.nFenceFd;\n            nativeMeta.nFenceFd = -1;\n }\n if (metaSize < sizeof(nativeMeta) && fenceFd >= 0) {\n            CLOG_ERROR(foundFenceInEmptyMeta, BAD_VALUE, FULL_BUFFER(\n                    NULL, header, nativeMeta.nFenceFd));\n            fenceFd = -1;\n }\n }\n return fenceFd;\n}\n", "target": 0, "idx": 170910}
{"func": "content::DownloadFile* MockDownloadFileFactory::CreateFile(\n    DownloadCreateInfo* info,\n    scoped_ptr<content::ByteStreamReader> stream,\n    content::DownloadManager* download_manager,\n     bool calculate_hash,\n     const net::BoundNetLog& bound_net_log) {\n   DCHECK(files_.end() == files_.find(info->download_id));\n  MockDownloadFile* created_file = new MockDownloadFile();\n   files_[info->download_id] = created_file;\n \n   ON_CALL(*created_file, GetDownloadManager())\n      .WillByDefault(Return(download_manager));\n  EXPECT_CALL(*created_file, Initialize());\n\n  return created_file;\n}\n", "target": 1, "idx": 184454}
{"func": "static void net_tx_action(struct softirq_action *h)\n{\n\tstruct softnet_data *sd = &__get_cpu_var(softnet_data);\n\n\tif (sd->completion_queue) {\n\t\tstruct sk_buff *clist;\n\n\t\tlocal_irq_disable();\n\t\tclist = sd->completion_queue;\n\t\tsd->completion_queue = NULL;\n\t\tlocal_irq_enable();\n\n\t\twhile (clist) {\n\t\t\tstruct sk_buff *skb = clist;\n\t\t\tclist = clist->next;\n\n\t\t\tWARN_ON(atomic_read(&skb->users));\n\t\t\t__kfree_skb(skb);\n\t\t}\n\t}\n\n\tif (sd->output_queue) {\n\t\tstruct Qdisc *head;\n\n\t\tlocal_irq_disable();\n\t\thead = sd->output_queue;\n\t\tsd->output_queue = NULL;\n\t\tlocal_irq_enable();\n\n\t\twhile (head) {\n\t\t\tstruct Qdisc *q = head;\n\t\t\tspinlock_t *root_lock;\n\n\t\t\thead = head->next_sched;\n\n\t\t\troot_lock = qdisc_lock(q);\n\t\t\tif (spin_trylock(root_lock)) {\n\t\t\t\tsmp_mb__before_clear_bit();\n\t\t\t\tclear_bit(__QDISC_STATE_SCHED,\n\t\t\t\t\t  &q->state);\n\t\t\t\tqdisc_run(q);\n\t\t\t\tspin_unlock(root_lock);\n\t\t\t} else {\n\t\t\t\tif (!test_bit(__QDISC_STATE_DEACTIVATED,\n\t\t\t\t\t      &q->state)) {\n\t\t\t\t\t__netif_reschedule(q);\n\t\t\t\t} else {\n\t\t\t\t\tsmp_mb__before_clear_bit();\n\t\t\t\t\tclear_bit(__QDISC_STATE_SCHED,\n\t\t\t\t\t\t  &q->state);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n", "target": 0, "idx": 32179}
{"func": "static int recv_stream(struct kiocb *iocb, struct socket *sock,\n\t\t       struct msghdr *m, size_t buf_len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct tipc_port *tport = tipc_sk_port(sk);\n\tstruct sk_buff *buf;\n\tstruct tipc_msg *msg;\n\tlong timeout;\n\tunsigned int sz;\n\tint sz_to_copy, target, needed;\n\tint sz_copied = 0;\n\tu32 err;\n\tint res = 0;\n\n\t/* Catch invalid receive attempts */\n\tif (unlikely(!buf_len))\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tif (unlikely((sock->state == SS_UNCONNECTED))) {\n\t\tres = -ENOTCONN;\n \t\tgoto exit;\n \t}\n \n\t/* will be updated in set_orig_addr() if needed */\n\tm->msg_namelen = 0;\n \ttarget = sock_rcvlowat(sk, flags & MSG_WAITALL, buf_len);\n \ttimeout = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);\n \nrestart:\n\t/* Look for a message in receive queue; wait if necessary */\n\twhile (skb_queue_empty(&sk->sk_receive_queue)) {\n\t\tif (sock->state == SS_DISCONNECTING) {\n\t\t\tres = -ENOTCONN;\n\t\t\tgoto exit;\n\t\t}\n\t\tif (timeout <= 0L) {\n\t\t\tres = timeout ? timeout : -EWOULDBLOCK;\n\t\t\tgoto exit;\n\t\t}\n\t\trelease_sock(sk);\n\t\ttimeout = wait_event_interruptible_timeout(*sk_sleep(sk),\n\t\t\t\t\t\t\t   tipc_rx_ready(sock),\n\t\t\t\t\t\t\t   timeout);\n\t\tlock_sock(sk);\n\t}\n\n\t/* Look at first message in receive queue */\n\tbuf = skb_peek(&sk->sk_receive_queue);\n\tmsg = buf_msg(buf);\n\tsz = msg_data_sz(msg);\n\terr = msg_errcode(msg);\n\n\t/* Discard an empty non-errored message & try again */\n\tif ((!sz) && (!err)) {\n\t\tadvance_rx_queue(sk);\n\t\tgoto restart;\n\t}\n\n\t/* Optionally capture sender's address & ancillary data of first msg */\n\tif (sz_copied == 0) {\n\t\tset_orig_addr(m, msg);\n\t\tres = anc_data_recv(m, msg, tport);\n\t\tif (res)\n\t\t\tgoto exit;\n\t}\n\n\t/* Capture message data (if valid) & compute return value (always) */\n\tif (!err) {\n\t\tu32 offset = (u32)(unsigned long)(TIPC_SKB_CB(buf)->handle);\n\n\t\tsz -= offset;\n\t\tneeded = (buf_len - sz_copied);\n\t\tsz_to_copy = (sz <= needed) ? sz : needed;\n\n\t\tres = skb_copy_datagram_iovec(buf, msg_hdr_sz(msg) + offset,\n\t\t\t\t\t      m->msg_iov, sz_to_copy);\n\t\tif (res)\n\t\t\tgoto exit;\n\n\t\tsz_copied += sz_to_copy;\n\n\t\tif (sz_to_copy < sz) {\n\t\t\tif (!(flags & MSG_PEEK))\n\t\t\t\tTIPC_SKB_CB(buf)->handle =\n\t\t\t\t(void *)(unsigned long)(offset + sz_to_copy);\n\t\t\tgoto exit;\n\t\t}\n\t} else {\n\t\tif (sz_copied != 0)\n\t\t\tgoto exit; /* can't add error msg to valid data */\n\n\t\tif ((err == TIPC_CONN_SHUTDOWN) || m->msg_control)\n\t\t\tres = 0;\n\t\telse\n\t\t\tres = -ECONNRESET;\n\t}\n\n\t/* Consume received message (optional) */\n\tif (likely(!(flags & MSG_PEEK))) {\n\t\tif (unlikely(++tport->conn_unacked >= TIPC_FLOW_CONTROL_WIN))\n\t\t\ttipc_acknowledge(tport->ref, tport->conn_unacked);\n\t\tadvance_rx_queue(sk);\n\t}\n\n\t/* Loop around if more data is required */\n\tif ((sz_copied < buf_len) &&\t/* didn't get all requested data */\n\t    (!skb_queue_empty(&sk->sk_receive_queue) ||\n\t    (sz_copied < target)) &&\t/* and more is ready or required */\n\t    (!(flags & MSG_PEEK)) &&\t/* and aren't just peeking at data */\n\t    (!err))\t\t\t/* and haven't reached a FIN */\n\t\tgoto restart;\n\nexit:\n\trelease_sock(sk);\n\treturn sz_copied ? sz_copied : res;\n}\n", "target": 1, "idx": 179690}
{"func": " bool DataReductionProxySettings::IsDataReductionProxyEnabled() const {\n   if (base::FeatureList::IsEnabled(network::features::kNetworkService) &&\n       !params::IsEnabledWithNetworkService()) {\n     return false;\n   }\n  return IsDataSaverEnabledByUser();\n }\n", "target": 1, "idx": 186523}
{"func": "static void jpc_undo_roi(jas_matrix_t *x, int roishift, int bgshift, int numbps)\n{\n\tint i;\n\tint j;\n\tint thresh;\n\tjpc_fix_t val;\n\tjpc_fix_t mag;\n \tbool warn;\n \tuint_fast32_t mask;\n \n \tif (roishift == 0 && bgshift == 0) {\n \t\treturn;\n \t}\n\tthresh = 1 << roishift;\n\n\twarn = false;\n\tfor (i = 0; i < jas_matrix_numrows(x); ++i) {\n\t\tfor (j = 0; j < jas_matrix_numcols(x); ++j) {\n\t\t\tval = jas_matrix_get(x, i, j);\n\t\t\tmag = JAS_ABS(val);\n\t\t\tif (mag >= thresh) {\n\t\t\t\t/* We are dealing with ROI data. */\n\t\t\t\tmag >>= roishift;\n\t\t\t\tval = (val < 0) ? (-mag) : mag;\n\t\t\t\tjas_matrix_set(x, i, j, val);\n \t\t\t} else {\n \t\t\t\t/* We are dealing with non-ROI (i.e., background) data. */\n \t\t\t\tmag <<= bgshift;\n\t\t\t\tmask = (1 << numbps) - 1;\n \t\t\t\t/* Perform a basic sanity check on the sample value. */\n \t\t\t\t/* Some implementations write garbage in the unused\n \t\t\t\t  most-significant bit planes introduced by ROI shifting.\n\t\t\t\t  Here we ensure that any such bits are masked off. */\n\t\t\t\tif (mag & (~mask)) {\n\t\t\t\t\tif (!warn) {\n\t\t\t\t\t\tjas_eprintf(\"warning: possibly corrupt code stream\\n\");\n\t\t\t\t\t\twarn = true;\n\t\t\t\t\t}\n\t\t\t\t\tmag &= mask;\n\t\t\t\t}\n\t\t\t\tval = (val < 0) ? (-mag) : mag;\n\t\t\t\tjas_matrix_set(x, i, j, val);\n\t\t\t}\n\t\t}\n\t}\n}\n", "target": 1, "idx": 181649}
{"func": " void NavigationController::RemoveEntryAtIndexInternal(int index) {\n   DCHECK(index < entry_count());\n \n   DiscardNonCommittedEntries();\n \n   entries_.erase(entries_.begin() + index);\n  if (last_committed_entry_index_ == index)\n    last_committed_entry_index_--;\n  else if (last_committed_entry_index_ > index)\n     last_committed_entry_index_--;\n }\n", "target": 1, "idx": 184667}
{"func": "static int kvm_vm_ioctl_create_vcpu(struct kvm *kvm, u32 id)\n{\n \tint r;\n \tstruct kvm_vcpu *vcpu, *v;\n \n \tvcpu = kvm_arch_vcpu_create(kvm, id);\n \tif (IS_ERR(vcpu))\n \t\treturn PTR_ERR(vcpu);\n\n\tpreempt_notifier_init(&vcpu->preempt_notifier, &kvm_preempt_ops);\n\n\tr = kvm_arch_vcpu_setup(vcpu);\n\tif (r)\n\t\tgoto vcpu_destroy;\n\n\tmutex_lock(&kvm->lock);\n\tif (!kvm_vcpu_compatible(vcpu)) {\n\t\tr = -EINVAL;\n\t\tgoto unlock_vcpu_destroy;\n\t}\n\tif (atomic_read(&kvm->online_vcpus) == KVM_MAX_VCPUS) {\n\t\tr = -EINVAL;\n\t\tgoto unlock_vcpu_destroy;\n\t}\n\n\tkvm_for_each_vcpu(r, v, kvm)\n\t\tif (v->vcpu_id == id) {\n\t\t\tr = -EEXIST;\n\t\t\tgoto unlock_vcpu_destroy;\n\t\t}\n\n\tBUG_ON(kvm->vcpus[atomic_read(&kvm->online_vcpus)]);\n\n\t/* Now it's all set up, let userspace reach it */\n\tkvm_get_kvm(kvm);\n\tr = create_vcpu_fd(vcpu);\n\tif (r < 0) {\n\t\tkvm_put_kvm(kvm);\n\t\tgoto unlock_vcpu_destroy;\n\t}\n\n\tkvm->vcpus[atomic_read(&kvm->online_vcpus)] = vcpu;\n\tsmp_wmb();\n\tatomic_inc(&kvm->online_vcpus);\n\n\tmutex_unlock(&kvm->lock);\n\tkvm_arch_vcpu_postcreate(vcpu);\n\treturn r;\n\nunlock_vcpu_destroy:\n\tmutex_unlock(&kvm->lock);\nvcpu_destroy:\n\tkvm_arch_vcpu_destroy(vcpu);\n\treturn r;\n}\n", "target": 1, "idx": 179131}
{"func": "void pagefault_out_of_memory(void)\n{\n\tif (try_set_system_oom()) {\n\t\tout_of_memory(NULL, 0, 0, NULL);\n\t\tclear_system_oom();\n\t}\n\tif (!test_thread_flag(TIF_MEMDIE))\n\t\tschedule_timeout_uninterruptible(1);\n}\n", "target": 0, "idx": 24353}
{"func": "_gcry_mpi_point_snatch_set (mpi_point_t point,\n                            gcry_mpi_t x, gcry_mpi_t y, gcry_mpi_t z)\n{\n  if (!point)\n    point = mpi_point_new (0);\n\n  if (x)\n    mpi_snatch (point->x, x);\n  else\n    mpi_clear (point->x);\n  if (y)\n    mpi_snatch (point->y, y);\n  else\n    mpi_clear (point->y);\n  if (z)\n    mpi_snatch (point->z, z);\n  else\n    mpi_clear (point->z);\n\n  return point;\n}\n", "target": 0, "idx": 13059}
{"func": "void InfoBarContainer::RemoveInfoBar(InfoBarDelegate* delegate,\n                                     bool use_animation) {\n   for (int i = 0; i < GetChildViewCount(); ++i) {\n    InfoBar* infobar = static_cast<InfoBar*>(GetChildViewAt(i));\n     if (infobar->delegate() == delegate) {\n       if (use_animation) {\n        infobar->AnimateClose();\n      } else {\n        infobar->Close();\n      }\n      break;\n    }\n  }\n}\n", "target": 1, "idx": 184196}
{"func": "static int php_openssl_is_private_key(EVP_PKEY* pkey TSRMLS_DC)\n{\n\tassert(pkey != NULL);\n\n\tswitch (pkey->type) {\n#ifndef NO_RSA\n\t\tcase EVP_PKEY_RSA:\n\t\tcase EVP_PKEY_RSA2:\n\t\t\tassert(pkey->pkey.rsa != NULL);\n\t\t\tif (pkey->pkey.rsa != NULL && (NULL == pkey->pkey.rsa->p || NULL == pkey->pkey.rsa->q)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n#endif\n#ifndef NO_DSA\n\t\tcase EVP_PKEY_DSA:\n\t\tcase EVP_PKEY_DSA1:\n\t\tcase EVP_PKEY_DSA2:\n\t\tcase EVP_PKEY_DSA3:\n\t\tcase EVP_PKEY_DSA4:\n\t\t\tassert(pkey->pkey.dsa != NULL);\n\n\t\t\tif (NULL == pkey->pkey.dsa->p || NULL == pkey->pkey.dsa->q || NULL == pkey->pkey.dsa->priv_key){ \n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n#endif\n#ifndef NO_DH\n\t\tcase EVP_PKEY_DH:\n\t\t\tassert(pkey->pkey.dh != NULL);\n\n\t\t\tif (NULL == pkey->pkey.dh->p || NULL == pkey->pkey.dh->priv_key) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n#endif\n#ifdef HAVE_EVP_PKEY_EC\n\t\tcase EVP_PKEY_EC:\n\t\t\tassert(pkey->pkey.ec != NULL);\n\n\t\t\tif ( NULL == EC_KEY_get0_private_key(pkey->pkey.ec)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"key type not supported in this PHP build!\");\n\t\t\tbreak;\n\t}\n\treturn 1;\n}\n", "target": 0, "idx": 4683}
{"func": "jbig2_find_changing_element(const byte *line, int x, int w)\n {\n     int a, b;\n \n     if (line == 0)\n        return w;\n \n    if (x == -1) {\n         a = 0;\n         x = 0;\n     } else {\n    }\n\n    while (x < w) {\n        b = getbit(line, x);\n        if (a != b)\n            break;\n        x++;\n    }\n\n    return x;\n}\n", "target": 1, "idx": 178666}
{"func": "static int mif_hdr_put(mif_hdr_t *hdr, jas_stream_t *out)\n{\n\tint cmptno;\n\tmif_cmpt_t *cmpt;\n\n\t/* Output signature. */\n\tjas_stream_putc(out, (MIF_MAGIC >> 24) & 0xff);\n\tjas_stream_putc(out, (MIF_MAGIC >> 16) & 0xff);\n\tjas_stream_putc(out, (MIF_MAGIC >> 8) & 0xff);\n\tjas_stream_putc(out, MIF_MAGIC & 0xff);\n\n\t/* Output component information. */\n\tfor (cmptno = 0; cmptno < hdr->numcmpts; ++cmptno) {\n\t\tcmpt = hdr->cmpts[cmptno];\n\t\tjas_stream_printf(out, \"component tlx=%ld tly=%ld \"\n\t\t  \"sampperx=%ld samppery=%ld width=%ld height=%ld prec=%d sgnd=%d\",\n\t\t  cmpt->tlx, cmpt->tly, cmpt->sampperx, cmpt->samppery, cmpt->width,\n\t\t  cmpt->height, cmpt->prec, cmpt->sgnd);\n\t\tif (cmpt->data) {\n\t\t\tjas_stream_printf(out, \" data=%s\", cmpt->data);\n\t\t}\n\t\tjas_stream_printf(out, \"\\n\");\n\t}\n\n\t/* Output end of header indicator. */\n\tjas_stream_printf(out, \"end\\n\");\n\n\treturn 0;\n}\n", "target": 0, "idx": 72949}
{"func": "Gfx::Gfx(XRef *xrefA, OutputDev *outA, Dict *resDict, Catalog *catalogA,\n\t PDFRectangle *box, PDFRectangle *cropBox,\n\t GBool (*abortCheckCbkA)(void *data),\n\t void *abortCheckCbkDataA)\n #ifdef USE_CMS\n : iccColorSpaceCache(5)\n#endif\n{\n  int i;\n\n  xref = xrefA;\n  catalog = catalogA;\n  subPage = gTrue;\n  printCommands = globalParams->getPrintCommands();\n  profileCommands = globalParams->getProfileCommands();\n  textHaveCSPattern = gFalse;\n  drawText = gFalse;\n   drawText = gFalse;\n   maskHaveCSPattern = gFalse;\n   mcStack = NULL;\n \n   res = new GfxResources(xref, resDict, NULL);\n  out = outA;\n  state = new GfxState(72, 72, box, 0, gFalse);\n  stackHeight = 1;\n  pushStateGuard();\n  fontChanged = gFalse;\n  clip = clipNone;\n  ignoreUndef = 0;\n  for (i = 0; i < 6; ++i) {\n    baseMatrix[i] = state->getCTM()[i];\n  }\n  formDepth = 0;\n  abortCheckCbk = abortCheckCbkA;\n  abortCheckCbkData = abortCheckCbkDataA;\n\n  if (cropBox) {\n    state->moveTo(cropBox->x1, cropBox->y1);\n    state->lineTo(cropBox->x2, cropBox->y1);\n    state->lineTo(cropBox->x2, cropBox->y2);\n    state->lineTo(cropBox->x1, cropBox->y2);\n    state->closePath();\n    state->clip();\n    out->clip(state);\n    state->clearPath();\n  }\n}\n", "target": 1, "idx": 178077}
{"func": "IDNSpoofChecker::~IDNSpoofChecker() {\n   uspoof_close(checker_);\n }\n", "target": 0, "idx": 161037}
{"func": "int xmkstemp(char **tmpname, char *dir)\n {\n \tchar *localtmp;\n\tchar *tmpenv;\n \tmode_t old_mode;\n \tint fd, rc;\n \n \t/* Some use cases must be capable of being moved atomically\n \t * with rename(2), which is the reason why dir is here.  */\n\tif (dir != NULL)\n\t\ttmpenv = dir;\n\telse\n\t\ttmpenv = getenv(\"TMPDIR\");\n\tif (tmpenv)\n\t\trc = asprintf(&localtmp, \"%s/%s.XXXXXX\", tmpenv,\n\t\t\t  program_invocation_short_name);\n\telse\n\t\trc = asprintf(&localtmp, \"%s/%s.XXXXXX\", _PATH_TMP,\n\t\t\t  program_invocation_short_name);\n \n \tif (rc < 0)\n \t\treturn -1;\n \n\told_mode = umask(077);\n\tfd = mkostemp(localtmp, O_RDWR|O_CREAT|O_EXCL|O_CLOEXEC);\n\tumask(old_mode);\n\tif (fd == -1) {\n\t\tfree(localtmp);\n\t\tlocaltmp = NULL;\n\t}\n\t*tmpname = localtmp;\n\treturn fd;\n}\n", "target": 1, "idx": 182045}
{"func": "void PrintRenderFrameHelper::OnPrintForSystemDialog() {\n  if (ipc_nesting_level_ > 1)\n    return;\n  blink::WebLocalFrame* frame = print_preview_context_.source_frame();\n  if (!frame) {\n    NOTREACHED();\n    return;\n  }\n  auto weak_this = weak_ptr_factory_.GetWeakPtr();\n  Print(frame, print_preview_context_.source_node(), false);\n  if (weak_this)\n    frame->DispatchAfterPrintEvent();\n}\n", "target": 0, "idx": 161935}
{"func": "static bool blit_build_vs_passthrough(struct vrend_blitter_ctx *blit_ctx)\n{\n   blit_ctx->vs = glCreateShader(GL_VERTEX_SHADER);\n\n   if (!build_and_check(blit_ctx->vs, VS_PASSTHROUGH)) {\n      glDeleteShader(blit_ctx->vs);\n      blit_ctx->vs = 0;\n      return false;\n   }\n   return true;\n}\n", "target": 0, "idx": 9160}
{"func": "static inline signed short ReadProfileShort(const EndianType endian,\n  unsigned char *buffer)\n{\n  union\n  {\n    unsigned int\n      unsigned_value;\n\n    signed int\n      signed_value;\n  } quantum;\n\n  unsigned short\n    value;\n \n   if (endian == LSBEndian)\n     {\n      value=(unsigned short) ((buffer[1] << 8) | buffer[0]);\n      quantum.unsigned_value=(value & 0xffff);\n       return(quantum.signed_value);\n     }\n  value=(unsigned short) ((((unsigned char *) buffer)[0] << 8) |\n    ((unsigned char *) buffer)[1]);\n  quantum.unsigned_value=(value & 0xffff);\n   return(quantum.signed_value);\n }\n", "target": 1, "idx": 183118}
{"func": "void SoftHEVC::setDecodeArgs(ivd_video_decode_ip_t *ps_dec_ip,\n         ivd_video_decode_op_t *ps_dec_op,\n         OMX_BUFFERHEADERTYPE *inHeader,\n         OMX_BUFFERHEADERTYPE *outHeader,\n         size_t timeStampIx) {\n     size_t sizeY = outputBufferWidth() * outputBufferHeight();\n     size_t sizeUV;\n    uint8_t *pBuf;\n \n     ps_dec_ip->u4_size = sizeof(ivd_video_decode_ip_t);\n     ps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);\n\n    ps_dec_ip->e_cmd = IVD_CMD_VIDEO_DECODE;\n\n /* When in flush and after EOS with zero byte input,\n     * inHeader is set to zero. Hence check for non-null */\n if (inHeader) {\n        ps_dec_ip->u4_ts = timeStampIx;\n        ps_dec_ip->pv_stream_buffer = inHeader->pBuffer\n + inHeader->nOffset;\n        ps_dec_ip->u4_num_Bytes = inHeader->nFilledLen;\n } else {\n        ps_dec_ip->u4_ts = 0;\n        ps_dec_ip->pv_stream_buffer = NULL;\n\n         ps_dec_ip->u4_num_Bytes = 0;\n     }\n \n    if (outHeader) {\n        pBuf = outHeader->pBuffer;\n    } else {\n        pBuf = mFlushOutBuffer;\n    }\n     sizeUV = sizeY / 4;\n     ps_dec_ip->s_out_buffer.u4_min_out_buf_size[0] = sizeY;\n     ps_dec_ip->s_out_buffer.u4_min_out_buf_size[1] = sizeUV;\n     ps_dec_ip->s_out_buffer.u4_min_out_buf_size[2] = sizeUV;\n \n     ps_dec_ip->s_out_buffer.pu1_bufs[0] = pBuf;\n     ps_dec_ip->s_out_buffer.pu1_bufs[1] = pBuf + sizeY;\n     ps_dec_ip->s_out_buffer.pu1_bufs[2] = pBuf + sizeY + sizeUV;\n     ps_dec_ip->s_out_buffer.u4_num_bufs = 3;\n    return;\n }\n", "target": 1, "idx": 188204}
{"func": "TreeModelNode* TreeView::GetEditingNode() {\n  return editing_node_;\n}\n", "target": 0, "idx": 105650}
{"func": "static MagickBooleanType WriteImageChannels(const PSDInfo *psd_info,\n  const ImageInfo *image_info,Image *image,Image *next_image,\n  const MagickBooleanType separate,ExceptionInfo *exception)\n{\n  size_t\n    channels,\n    packet_size;\n\n  unsigned char\n    *compact_pixels;\n\n  /*\n    Write uncompressed pixels as separate planes.\n  */\n  channels=1;\n  packet_size=next_image->depth > 8UL ? 2UL : 1UL;\n   compact_pixels=(unsigned char *) NULL;\n   if (next_image->compression == RLECompression)\n     {\n      compact_pixels=(unsigned char *) AcquireQuantumMemory(2*channels*\n        next_image->columns,packet_size*sizeof(*compact_pixels));\n       if (compact_pixels == (unsigned char *) NULL)\n         ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n     }\n  if (IsImageGray(next_image) != MagickFalse)\n    {\n      if (next_image->compression == RLECompression)\n        {\n          /*\n            Packbits compression.\n          */\n          (void) WriteBlobMSBShort(image,1);\n          WritePackbitsLength(psd_info,image_info,image,next_image,\n            compact_pixels,GrayQuantum,exception);\n          if (next_image->alpha_trait != UndefinedPixelTrait)\n            WritePackbitsLength(psd_info,image_info,image,next_image,\n              compact_pixels,AlphaQuantum,exception);\n        }\n      WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels,\n        GrayQuantum,MagickTrue,exception);\n      if (next_image->alpha_trait != UndefinedPixelTrait)\n        WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels,\n          AlphaQuantum,separate,exception);\n      (void) SetImageProgress(image,SaveImagesTag,0,1);\n    }\n  else\n    if (next_image->storage_class == PseudoClass)\n      {\n        if (next_image->compression == RLECompression)\n          {\n            /*\n              Packbits compression.\n            */\n            (void) WriteBlobMSBShort(image,1);\n            WritePackbitsLength(psd_info,image_info,image,next_image,\n              compact_pixels,IndexQuantum,exception);\n            if (next_image->alpha_trait != UndefinedPixelTrait)\n              WritePackbitsLength(psd_info,image_info,image,next_image,\n                compact_pixels,AlphaQuantum,exception);\n          }\n        WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels,\n          IndexQuantum,MagickTrue,exception);\n        if (next_image->alpha_trait != UndefinedPixelTrait)\n          WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels,\n            AlphaQuantum,separate,exception);\n        (void) SetImageProgress(image,SaveImagesTag,0,1);\n      }\n    else\n      {\n        if (next_image->colorspace == CMYKColorspace)\n          (void) NegateCMYK(next_image,exception);\n        if (next_image->compression == RLECompression)\n          {\n            /*\n              Packbits compression.\n            */\n            (void) WriteBlobMSBShort(image,1);\n            WritePackbitsLength(psd_info,image_info,image,next_image,\n              compact_pixels,RedQuantum,exception);\n            WritePackbitsLength(psd_info,image_info,image,next_image,\n              compact_pixels,GreenQuantum,exception);\n            WritePackbitsLength(psd_info,image_info,image,next_image,\n              compact_pixels,BlueQuantum,exception);\n            if (next_image->colorspace == CMYKColorspace)\n              WritePackbitsLength(psd_info,image_info,image,next_image,\n                compact_pixels,BlackQuantum,exception);\n            if (next_image->alpha_trait != UndefinedPixelTrait)\n              WritePackbitsLength(psd_info,image_info,image,next_image,\n                compact_pixels,AlphaQuantum,exception);\n          }\n        (void) SetImageProgress(image,SaveImagesTag,0,6);\n        WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels,\n          RedQuantum,MagickTrue,exception);\n        (void) SetImageProgress(image,SaveImagesTag,1,6);\n        WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels,\n          GreenQuantum,separate,exception);\n        (void) SetImageProgress(image,SaveImagesTag,2,6);\n        WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels,\n          BlueQuantum,separate,exception);\n        (void) SetImageProgress(image,SaveImagesTag,3,6);\n        if (next_image->colorspace == CMYKColorspace)\n          WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels,\n            BlackQuantum,separate,exception);\n        (void) SetImageProgress(image,SaveImagesTag,4,6);\n        if (next_image->alpha_trait != UndefinedPixelTrait)\n          WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels,\n            AlphaQuantum,separate,exception);\n        (void) SetImageProgress(image,SaveImagesTag,5,6);\n        if (next_image->colorspace == CMYKColorspace)\n          (void) NegateCMYK(next_image,exception);\n      }\n  if (next_image->compression == RLECompression)\n    compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);\n  return(MagickTrue);\n}\n", "target": 1, "idx": 183290}
{"func": "exsltFuncFunctionComp (xsltStylesheetPtr style, xmlNodePtr inst) {\n    xmlChar *name, *prefix;\n    xmlNsPtr ns;\n    xmlHashTablePtr data;\n    exsltFuncFunctionData *func;\n\n    if ((style == NULL) || (inst == NULL) || (inst->type != XML_ELEMENT_NODE))\n\treturn;\n\n    {\n\txmlChar *qname;\n\n\tqname = xmlGetProp(inst, (const xmlChar *) \"name\");\n\tname = xmlSplitQName2 (qname, &prefix);\n\txmlFree(qname);\n    }\n    if ((name == NULL) || (prefix == NULL)) {\n\txsltGenericError(xsltGenericErrorContext,\n\t\t\t \"func:function: not a QName\\n\");\n\tif (name != NULL)\n\t    xmlFree(name);\n\treturn;\n    }\n    /* namespace lookup */\n    ns = xmlSearchNs (inst->doc, inst, prefix);\n    if (ns == NULL) {\n\txsltGenericError(xsltGenericErrorContext,\n\t\t\t \"func:function: undeclared prefix %s\\n\",\n\t\t\t prefix);\n\txmlFree(name);\n\txmlFree(prefix);\n\treturn;\n    }\n    xmlFree(prefix);\n\n    xsltParseTemplateContent(style, inst);\n\n    /*\n      * Create function data\n      */\n     func = exsltFuncNewFunctionData();\n     func->content = inst->children;\n     while (IS_XSLT_ELEM(func->content) &&\n \t   IS_XSLT_NAME(func->content, \"param\")) {\n\tfunc->content = func->content->next;\n\tfunc->nargs++;\n    }\n\n    /*\n     * Register the function data such that it can be retrieved\n     * by exslFuncFunctionFunction\n     */\n#ifdef XSLT_REFACTORED\n    /*\n    * Ensure that the hash table will be stored in the *current*\n    * stylesheet level in order to correctly evaluate the\n    * import precedence.\n    */\n    data = (xmlHashTablePtr)\n\txsltStyleStylesheetLevelGetExtData(style,\n\t    EXSLT_FUNCTIONS_NAMESPACE);\n#else\n    data = (xmlHashTablePtr)\n\txsltStyleGetExtData (style, EXSLT_FUNCTIONS_NAMESPACE);\n#endif\n    if (data == NULL) {\n\txsltGenericError(xsltGenericErrorContext,\n\t\t\t \"exsltFuncFunctionComp: no stylesheet data\\n\");\n\txmlFree(name);\n\treturn;\n    }\n\n    if (xmlHashAddEntry2 (data, ns->href, name, func) < 0) {\n\txsltTransformError(NULL, style, inst,\n\t    \"Failed to register function {%s}%s\\n\",\n\t\t\t ns->href, name);\n\tstyle->errors++;\n    } else {\n\txsltGenericDebug(xsltGenericDebugContext,\n\t\t\t \"exsltFuncFunctionComp: register {%s}%s\\n\",\n\t\t\t ns->href, name);\n    }\n    xmlFree(name);\n}\n", "target": 1, "idx": 187314}
{"func": " void smp_proc_id_info(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n   uint8_t* p = p_data->p_data;\n \n   SMP_TRACE_DEBUG(\"%s\", __func__);\n   STREAM_TO_ARRAY(p_cb->tk, p, BT_OCTET16_LEN); /* reuse TK for IRK */\n   smp_key_distribution_by_transport(p_cb, NULL);\n }\n", "target": 1, "idx": 188097}
{"func": "translate_compat_table(struct net *net,\n\t\t       struct xt_table_info **pinfo,\n\t\t       void **pentry0,\n\t\t       const struct compat_ip6t_replace *compatr)\n{\n\tunsigned int i, j;\n\tstruct xt_table_info *newinfo, *info;\n\tvoid *pos, *entry0, *entry1;\n\tstruct compat_ip6t_entry *iter0;\n\tstruct ip6t_replace repl;\n\tunsigned int size;\n\tint ret = 0;\n\n\tinfo = *pinfo;\n\tentry0 = *pentry0;\n\tsize = compatr->size;\n\tinfo->number = compatr->num_entries;\n\n\tj = 0;\n\txt_compat_lock(AF_INET6);\n\txt_compat_init_offsets(AF_INET6, compatr->num_entries);\n\t/* Walk through entries, checking offsets. */\n\txt_entry_foreach(iter0, entry0, compatr->size) {\n\t\tret = check_compat_entry_size_and_hooks(iter0, info, &size,\n\t\t\t\t\t\t\tentry0,\n\t\t\t\t\t\t\tentry0 + compatr->size);\n\t\tif (ret != 0)\n\t\t\tgoto out_unlock;\n\t\t++j;\n\t}\n\n\tret = -EINVAL;\n\tif (j != compatr->num_entries)\n\t\tgoto out_unlock;\n\n\tret = -ENOMEM;\n\tnewinfo = xt_alloc_table_info(size);\n\tif (!newinfo)\n\t\tgoto out_unlock;\n\n\tnewinfo->number = compatr->num_entries;\n\tfor (i = 0; i < NF_INET_NUMHOOKS; i++) {\n\t\tnewinfo->hook_entry[i] = compatr->hook_entry[i];\n\t\tnewinfo->underflow[i] = compatr->underflow[i];\n\t}\n\tentry1 = newinfo->entries;\n\tpos = entry1;\n\tsize = compatr->size;\n\txt_entry_foreach(iter0, entry0, compatr->size)\n\t\tcompat_copy_entry_from_user(iter0, &pos, &size,\n\t\t\t\t\t    newinfo, entry1);\n\n\t/* all module references in entry0 are now gone. */\n\txt_compat_flush_offsets(AF_INET6);\n\txt_compat_unlock(AF_INET6);\n\n\tmemcpy(&repl, compatr, sizeof(*compatr));\n\n\tfor (i = 0; i < NF_INET_NUMHOOKS; i++) {\n\t\trepl.hook_entry[i] = newinfo->hook_entry[i];\n\t\trepl.underflow[i] = newinfo->underflow[i];\n\t}\n\n\trepl.num_counters = 0;\n\trepl.counters = NULL;\n\trepl.size = newinfo->size;\n\tret = translate_table(net, newinfo, entry1, &repl);\n\tif (ret)\n\t\tgoto free_newinfo;\n\n\t*pinfo = newinfo;\n\t*pentry0 = entry1;\n\txt_free_table_info(info);\n\treturn 0;\n\nfree_newinfo:\n\txt_free_table_info(newinfo);\n\treturn ret;\nout_unlock:\n\txt_compat_flush_offsets(AF_INET6);\n\txt_compat_unlock(AF_INET6);\n\txt_entry_foreach(iter0, entry0, compatr->size) {\n\t\tif (j-- == 0)\n\t\t\tbreak;\n\t\tcompat_release_entry(iter0);\n\t}\n\treturn ret;\n}\n", "target": 0, "idx": 85034}
{"func": "InputDispatcher::~InputDispatcher() {\n { // acquire lock\n AutoMutex _l(mLock);\n\n        resetKeyRepeatLocked();\n        releasePendingEventLocked();\n        drainInboundQueueLocked();\n }\n\n while (mConnectionsByFd.size() != 0) {\n        unregisterInputChannel(mConnectionsByFd.valueAt(0)->inputChannel);\n }\n}\n", "target": 0, "idx": 177037}
{"func": "static int afpClose(sqlite3_file *id) {\n  int rc = SQLITE_OK;\n  unixFile *pFile = (unixFile*)id;\n  assert( id!=0 );\n  afpUnlock(id, NO_LOCK);\n  assert( unixFileMutexNotheld(pFile) );\n  unixEnterMutex();\n  if( pFile->pInode ){\n    unixInodeInfo *pInode = pFile->pInode;\n    sqlite3_mutex_enter(pInode->pLockMutex);\n    if( pInode->nLock ){\n      /* If there are outstanding locks, do not actually close the file just\n      ** yet because that would clear those locks.  Instead, add the file\n      ** descriptor to pInode->aPending.  It will be automatically closed when\n      ** the last lock is cleared.\n      */\n      setPendingFd(pFile);\n    }\n    sqlite3_mutex_leave(pInode->pLockMutex);\n  }\n  releaseInodeInfo(pFile);\n  sqlite3_free(pFile->lockingContext);\n  rc = closeUnixFile(id);\n  unixLeaveMutex();\n  return rc;\n}\n", "target": 0, "idx": 164456}
{"func": "Bool GPAC_EventProc(void *ptr, GF_Event *evt)\n{\n\tif (!term) return 0;\n\n\tif (gui_mode==1) {\n\t\tif (evt->type==GF_EVENT_QUIT) {\n\t\t\tRun = 0;\n\t\t} else if (evt->type==GF_EVENT_KEYDOWN) {\n\t\t\tswitch (evt->key.key_code) {\n\t\t\tcase GF_KEY_C:\n\t\t\t\tif (evt->key.flags & (GF_KEY_MOD_CTRL|GF_KEY_MOD_ALT)) {\n\t\t\t\t\thide_shell(shell_visible ? 1 : 0);\n\t\t\t\t\tif (shell_visible) gui_mode=2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tswitch (evt->type) {\n\tcase GF_EVENT_DURATION:\n\t\tDuration = (u64) ( 1000 * (s64) evt->duration.duration);\n\t\tCanSeek = evt->duration.can_seek;\n\t\tbreak;\n\tcase GF_EVENT_MESSAGE:\n\t{\n\t\tconst char *servName;\n\t\tif (!evt->message.service || !strcmp(evt->message.service, the_url)) {\n\t\t\tservName = \"\";\n\t\t} else if (!strnicmp(evt->message.service, \"data:\", 5)) {\n\t\t\tservName = \"(embedded data)\";\n\t\t} else {\n\t\t\tservName = evt->message.service;\n\t\t}\n\n\n\t\tif (!evt->message.message) return 0;\n\n\t\tif (evt->message.error) {\n\t\t\tif (!is_connected) last_error = evt->message.error;\n\t\t\tif (evt->message.error==GF_SCRIPT_INFO) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONSOLE, (\"%s\\n\", evt->message.message));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONSOLE, (\"%s %s: %s\\n\", servName, evt->message.message, gf_error_to_string(evt->message.error)));\n\t\t\t}\n\t\t} else if (!be_quiet)\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONSOLE, (\"%s %s\\n\", servName, evt->message.message));\n\t}\n\tbreak;\n\tcase GF_EVENT_PROGRESS:\n\t{\n\t\tchar *szTitle = \"\";\n\t\tif (evt->progress.progress_type==0) {\n\t\t\tszTitle = \"Buffer \";\n\t\t\tif (bench_mode && (bench_mode!=3) ) {\n\t\t\t\tif (evt->progress.done >= evt->progress.total) bench_buffer = 0;\n\t\t\t\telse bench_buffer = 1 + 100*evt->progress.done / evt->progress.total;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse if (evt->progress.progress_type==1) {\n\t\t\tif (bench_mode) break;\n\t\t\tszTitle = \"Download \";\n\t\t}\n\t\telse if (evt->progress.progress_type==2) szTitle = \"Import \";\n\t\tgf_set_progress(szTitle, evt->progress.done, evt->progress.total);\n\t}\n\tbreak;\n\n\n\tcase GF_EVENT_DBLCLICK:\n\t\tgf_term_set_option(term, GF_OPT_FULLSCREEN, !gf_term_get_option(term, GF_OPT_FULLSCREEN));\n\t\treturn 0;\n\n\tcase GF_EVENT_MOUSEDOWN:\n\t\tif (evt->mouse.button==GF_MOUSE_RIGHT) {\n\t\t\tright_down = 1;\n\t\t\tlast_x = evt->mouse.x;\n\t\t\tlast_y = evt->mouse.y;\n\t\t}\n\t\treturn 0;\n\tcase GF_EVENT_MOUSEUP:\n\t\tif (evt->mouse.button==GF_MOUSE_RIGHT) {\n\t\t\tright_down = 0;\n\t\t\tlast_x = evt->mouse.x;\n\t\t\tlast_y = evt->mouse.y;\n\t\t}\n\t\treturn 0;\n\tcase GF_EVENT_MOUSEMOVE:\n\t\tif (right_down && (user.init_flags & GF_TERM_WINDOWLESS) ) {\n\t\t\tGF_Event move;\n\t\t\tmove.move.x = evt->mouse.x - last_x;\n\t\t\tmove.move.y = last_y-evt->mouse.y;\n\t\t\tmove.type = GF_EVENT_MOVE;\n\t\t\tmove.move.relative = 1;\n\t\t\tgf_term_user_event(term, &move);\n\t\t}\n\t\treturn 0;\n\n\tcase GF_EVENT_KEYUP:\n\t\tswitch (evt->key.key_code) {\n\t\tcase GF_KEY_SPACE:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL) switch_bench(!bench_mode);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase GF_EVENT_KEYDOWN:\n\t\tgf_term_process_shortcut(term, evt);\n\t\tswitch (evt->key.key_code) {\n\t\tcase GF_KEY_SPACE:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL) {\n\t\t\t\t/*ignore key repeat*/\n\t\t\t\tif (!bench_mode) switch_bench(!bench_mode);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_PAGEDOWN:\n\t\tcase GF_KEY_MEDIANEXTTRACK:\n\t\t\trequest_next_playlist_item = 1;\n\t\t\tbreak;\n\t\tcase GF_KEY_MEDIAPREVIOUSTRACK:\n\t\t\tbreak;\n\t\tcase GF_KEY_ESCAPE:\n\t\t\tgf_term_set_option(term, GF_OPT_FULLSCREEN, !gf_term_get_option(term, GF_OPT_FULLSCREEN));\n\t\t\tbreak;\n\t\tcase GF_KEY_C:\n\t\t\tif (evt->key.flags & (GF_KEY_MOD_CTRL|GF_KEY_MOD_ALT)) {\n\t\t\t\thide_shell(shell_visible ? 1 : 0);\n\t\t\t\tif (!shell_visible) gui_mode=1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_F:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL) fprintf(stderr, \"Rendering rate: %f FPS\\n\", gf_term_get_framerate(term, 0));\n\t\t\tbreak;\n\t\tcase GF_KEY_T:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL) fprintf(stderr, \"Scene Time: %f \\n\", gf_term_get_time_in_ms(term)/1000.0);\n\t\t\tbreak;\n\t\tcase GF_KEY_D:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL) gf_term_set_option(term, GF_OPT_DRAW_MODE, (gf_term_get_option(term, GF_OPT_DRAW_MODE)==GF_DRAW_MODE_DEFER) ? GF_DRAW_MODE_IMMEDIATE : GF_DRAW_MODE_DEFER );\n\t\t\tbreak;\n\t\tcase GF_KEY_4:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL)\n\t\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_4_3);\n\t\t\tbreak;\n\t\tcase GF_KEY_5:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL)\n\t\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_16_9);\n\t\t\tbreak;\n\t\tcase GF_KEY_6:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL)\n\t\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_FILL_SCREEN);\n\t\t\tbreak;\n\t\tcase GF_KEY_7:\n\t\t\tif (evt->key.flags & GF_KEY_MOD_CTRL)\n\t\t\t\tgf_term_set_option(term, GF_OPT_ASPECT_RATIO, GF_ASPECT_RATIO_KEEP);\n\t\t\tbreak;\n\t\tcase GF_KEY_O:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected) {\n\t\t\t\tif (gf_term_get_option(term, GF_OPT_MAIN_ADDON)) {\n\t\t\t\t\tfprintf(stderr, \"Resuming to main content\\n\");\n\t\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, GF_STATE_PLAY_LIVE);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"Main addon not enabled\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_P:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected) {\n\t\t\t\tu32 pause_state = gf_term_get_option(term, GF_OPT_PLAY_STATE) ;\n\t\t\t\tfprintf(stderr, \"[Status: %s]\\n\", pause_state ? \"Playing\" : \"Paused\");\n\t\t\t\tif ((pause_state == GF_STATE_PAUSED) && (evt->key.flags & GF_KEY_MOD_SHIFT)) {\n\t\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, GF_STATE_PLAY_LIVE);\n\t\t\t\t} else {\n\t\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, (pause_state==GF_STATE_PAUSED) ? GF_STATE_PLAYING : GF_STATE_PAUSED);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_S:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected) {\n\t\t\t\tgf_term_set_option(term, GF_OPT_PLAY_STATE, GF_STATE_STEP_PAUSE);\n\t\t\t\tfprintf(stderr, \"Step time: \");\n\t\t\t\tPrintTime(gf_term_get_time_in_ms(term));\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_B:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected)\n\t\t\t\tViewODs(term, 1);\n\t\t\tbreak;\n\t\tcase GF_KEY_M:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected)\n\t\t\t\tViewODs(term, 0);\n\t\t\tbreak;\n\t\tcase GF_KEY_H:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected) {\n\t\t\t\tgf_term_switch_quality(term, 1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_L:\n\t\t\tif ((evt->key.flags & GF_KEY_MOD_CTRL) && is_connected) {\n\t\t\t\tgf_term_switch_quality(term, 0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_F5:\n\t\t\tif (is_connected)\n\t\t\t\treload = 1;\n\t\t\tbreak;\n\t\tcase GF_KEY_A:\n\t\t\taddon_visible = !addon_visible;\n\t\t\tgf_term_toggle_addons(term, addon_visible);\n\t\t\tbreak;\n\t\tcase GF_KEY_UP:\n\t\t\tif ((evt->key.flags & VK_MOD) && is_connected) {\n\t\t\t\tdo_set_speed(playback_speed * 2);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_DOWN:\n\t\t\tif ((evt->key.flags & VK_MOD) && is_connected) {\n\t\t\t\tdo_set_speed(playback_speed / 2);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_KEY_LEFT:\n\t\t\tif ((evt->key.flags & VK_MOD) && is_connected) {\n\t\t\t\tdo_set_speed(-1 * playback_speed );\n\t\t\t}\n\t\t\tbreak;\n\n\t\t}\n\t\tbreak;\n\n\tcase GF_EVENT_CONNECT:\n\t\tif (evt->connect.is_connected) {\n\t\t\tis_connected = 1;\n\t\t\tfprintf(stderr, \"Service Connected\\n\");\n\t\t\teos_seen = GF_FALSE;\n\t\t\tif (playback_speed != FIX_ONE)\n\t\t\t\tgf_term_set_speed(term, playback_speed);\n\n\t\t} else if (is_connected) {\n\t\t\tfprintf(stderr, \"Service %s\\n\", is_connected ? \"Disconnected\" : \"Connection Failed\");\n\t\t\tis_connected = 0;\n\t\t\tDuration = 0;\n\t\t}\n\t\tif (init_w && init_h) {\n\t\t\tgf_term_set_size(term, init_w, init_h);\n\t\t}\n\t\tResetCaption();\n\t\tbreak;\n\tcase GF_EVENT_EOS:\n\t\teos_seen = GF_TRUE;\n\t\tif (playlist) {\n\t\t\tif (Duration>1500)\n\t\t\t\trequest_next_playlist_item = GF_TRUE;\n\t\t}\n\t\telse if (loop_at_end) {\n\t\t\trestart = 1;\n\t\t}\n\t\tbreak;\n\tcase GF_EVENT_SIZE:\n\t\tif (user.init_flags & GF_TERM_WINDOWLESS) {\n\t\t\tGF_Event move;\n\t\t\tmove.type = GF_EVENT_MOVE;\n\t\t\tmove.move.align_x = align_mode & 0xFF;\n\t\t\tmove.move.align_y = (align_mode>>8) & 0xFF;\n\t\t\tmove.move.relative = 2;\n\t\t\tgf_term_user_event(term, &move);\n\t\t}\n\t\tbreak;\n\tcase GF_EVENT_SCENE_SIZE:\n\t\tif (forced_width && forced_height) {\n\t\t\tGF_Event size;\n\t\t\tsize.type = GF_EVENT_SIZE;\n\t\t\tsize.size.width = forced_width;\n\t\t\tsize.size.height = forced_height;\n\t\t\tgf_term_user_event(term, &size);\n\t\t}\n\t\tbreak;\n\n\tcase GF_EVENT_METADATA:\n\t\tResetCaption();\n\t\tbreak;\n\n\tcase GF_EVENT_RELOAD:\n\t\tif (is_connected)\n\t\t\treload = 1;\n\t\tbreak;\n\tcase GF_EVENT_DROPFILE:\n\t{\n\t\tu32 i, pos;\n\t\t/*todo - force playlist mode*/\n\t\tif (readonly_playlist) {\n\t\t\tgf_fclose(playlist);\n\t\t\tplaylist = NULL;\n\t\t}\n\t\treadonly_playlist = 0;\n\t\tif (!playlist) {\n\t\t\treadonly_playlist = 0;\n\t\t\tplaylist = gf_temp_file_new(NULL);\n\t\t}\n\t\tpos = ftell(playlist);\n\t\ti=0;\n\t\twhile (i<evt->open_file.nb_files) {\n\t\t\tif (evt->open_file.files[i] != NULL) {\n\t\t\t\tfprintf(playlist, \"%s\\n\", evt->open_file.files[i]);\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tfseek(playlist, pos, SEEK_SET);\n\t\trequest_next_playlist_item = 1;\n\t}\n\treturn 1;\n\n\tcase GF_EVENT_QUIT:\n\t\tif (evt->message.error)  {\n\t\t\tfprintf(stderr, \"A fatal error was encoutered: %s (%s) - exiting ...\\n\", evt->message.message ? evt->message.message : \"no details\", gf_error_to_string(evt->message.error) );\n\t\t}\n\t\tRun = 0;\n\t\tbreak;\n\tcase GF_EVENT_DISCONNECT:\n\t\tgf_term_disconnect(term);\n\t\tbreak;\n\tcase GF_EVENT_MIGRATE:\n\t{\n\t}\n\tbreak;\n\tcase GF_EVENT_NAVIGATE_INFO:\n\t\tif (evt->navigate.to_url) fprintf(stderr, \"Go to URL: \\\"%s\\\"\\r\", evt->navigate.to_url);\n \t\tbreak;\n \tcase GF_EVENT_NAVIGATE:\n \t\tif (gf_term_is_supported_url(term, evt->navigate.to_url, 1, no_mime_check)) {\n\t\t\tstrcpy(the_url, evt->navigate.to_url);\n \t\t\tfprintf(stderr, \"Navigating to URL %s\\n\", the_url);\n \t\t\tgf_term_navigate_to(term, evt->navigate.to_url);\n \t\t\treturn 1;\n\t\t} else {\n\t\t\tfprintf(stderr, \"Navigation destination not supported\\nGo to URL: %s\\n\", evt->navigate.to_url);\n\t\t}\n\t\tbreak;\n\tcase GF_EVENT_SET_CAPTION:\n\t\tgf_term_user_event(term, evt);\n\t\tbreak;\n\tcase GF_EVENT_AUTHORIZATION:\n\t{\n\t\tint maxTries = 1;\n\t\tassert( evt->type == GF_EVENT_AUTHORIZATION);\n\t\tassert( evt->auth.user);\n\t\tassert( evt->auth.password);\n\t\tassert( evt->auth.site_url);\n\t\twhile ((!strlen(evt->auth.user) || !strlen(evt->auth.password)) && (maxTries--) >= 0) {\n\t\t\tfprintf(stderr, \"**** Authorization required for site %s ****\\n\", evt->auth.site_url);\n\t\t\tfprintf(stderr, \"login   : \");\n\t\t\tread_line_input(evt->auth.user, 50, 1);\n\t\t\tfprintf(stderr, \"\\npassword: \");\n\t\t\tread_line_input(evt->auth.password, 50, 0);\n\t\t\tfprintf(stderr, \"*********\\n\");\n\t\t}\n\t\tif (maxTries < 0) {\n\t\t\tfprintf(stderr, \"**** No User or password has been filled, aborting ***\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\tcase GF_EVENT_ADDON_DETECTED:\n\t\tif (enable_add_ons) {\n\t\t\tfprintf(stderr, \"Media Addon %s detected - enabling it\\n\", evt->addon_connect.addon_url);\n\t\t\taddon_visible = 1;\n\t\t}\n\t\treturn enable_add_ons;\n\t}\n\treturn 0;\n}\n", "target": 1, "idx": 182961}
{"func": "qedi_dbg_warn(struct qedi_dbg_ctx *qedi, const char *func, u32 line,\n\t      const char *fmt, ...)\n {\n \tva_list va;\n \tstruct va_format vaf;\n\tchar nfunc[32];\n\tmemset(nfunc, 0, sizeof(nfunc));\n\tmemcpy(nfunc, func, sizeof(nfunc) - 1);\n \n \tva_start(va, fmt);\n \n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\n\tif (!(qedi_dbg_log & QEDI_LOG_WARN))\n\t\tgoto ret;\n \n \tif (likely(qedi) && likely(qedi->pdev))\n \t\tpr_warn(\"[%s]:[%s:%d]:%d: %pV\", dev_name(&qedi->pdev->dev),\n\t\t\tnfunc, line, qedi->host_no, &vaf);\n \telse\n\t\tpr_warn(\"[0000:00:00.0]:[%s:%d]: %pV\", nfunc, line, &vaf);\n \n ret:\n \tva_end(va);\n}\n", "target": 1, "idx": 182733}
{"func": "void RenderFrameHostImpl::ResetFeaturePolicy() {\n  RenderFrameHostImpl* parent_frame_host = GetParent();\n  const blink::FeaturePolicy* parent_policy =\n      parent_frame_host ? parent_frame_host->feature_policy() : nullptr;\n  blink::ParsedFeaturePolicy container_policy =\n      frame_tree_node()->effective_frame_policy().container_policy;\n  feature_policy_ = blink::FeaturePolicy::CreateFromParentPolicy(\n      parent_policy,\n      *DirectivesWithDisposition(\n          blink::mojom::FeaturePolicyDisposition::kEnforce, container_policy),\n      last_committed_origin_);\n}\n", "target": 0, "idx": 166154}
{"func": "http_splitheader(struct http *hp, int req)\n{\n\tchar *p, *q, **hh;\n\tint n;\n\tchar buf[20];\n\n\tCHECK_OBJ_NOTNULL(hp, HTTP_MAGIC);\n\tif (req) {\n\t\tmemset(hp->req, 0, sizeof hp->req);\n\t\thh = hp->req;\n\t} else {\n\t\tmemset(hp->resp, 0, sizeof hp->resp);\n\t\thh = hp->resp;\n\t}\n\n\tn = 0;\n\tp = hp->rxbuf;\n\n\t/* REQ/PROTO */\n\twhile (vct_islws(*p))\n\t\tp++;\n \thh[n++] = p;\n \twhile (!vct_islws(*p))\n \t\tp++;\n\tassert(!vct_iscrlf(*p));\n \t*p++ = '\\0';\n \n \t/* URL/STATUS */\n \twhile (vct_issp(*p))\t\t/* XXX: H space only */\n \t\tp++;\n\tassert(!vct_iscrlf(*p));\n \thh[n++] = p;\n \twhile (!vct_islws(*p))\n \t\tp++;\n\tif (vct_iscrlf(*p)) {\n \t\thh[n++] = NULL;\n \t\tq = p;\n \t\tp += vct_skipcrlf(p);\n\t\t*q = '\\0';\n\t} else {\n\t\t*p++ = '\\0';\n\t\t/* PROTO/MSG */\n \t\twhile (vct_issp(*p))\t\t/* XXX: H space only */\n \t\t\tp++;\n \t\thh[n++] = p;\n\t\twhile (!vct_iscrlf(*p))\n \t\t\tp++;\n \t\tq = p;\n \t\tp += vct_skipcrlf(p);\n\t\t*q = '\\0';\n\t}\n\tassert(n == 3);\n \n \twhile (*p != '\\0') {\n \t\tassert(n < MAX_HDR);\n\t\tif (vct_iscrlf(*p))\n \t\t\tbreak;\n \t\thh[n++] = p++;\n\t\twhile (*p != '\\0' && !vct_iscrlf(*p))\n \t\t\tp++;\n \t\tq = p;\n \t\tp += vct_skipcrlf(p);\n\t\t*q = '\\0';\n\t}\n\tp += vct_skipcrlf(p);\n\tassert(*p == '\\0');\n\n\tfor (n = 0; n < 3 || hh[n] != NULL; n++) {\n\t\tsprintf(buf, \"http[%2d] \", n);\n\t\tvtc_dump(hp->vl, 4, buf, hh[n], -1);\n\t}\n}\n", "target": 1, "idx": 183172}
{"func": "flatpak_proxy_add_wildcarded_policy (FlatpakProxy *proxy,\n                                     const char   *name,\n                                     FlatpakPolicy policy)\n{\n  g_hash_table_replace (proxy->wildcard_policy, g_strdup (name), GINT_TO_POINTER (policy));\n}\n", "target": 0, "idx": 84373}
{"func": "bool DrawingBuffer::FinishPrepareTextureMailboxGpu(\n     viz::TextureMailbox* out_mailbox,\n     std::unique_ptr<cc::SingleReleaseCallback>* out_release_callback) {\n   DCHECK(state_restorer_);\n  if (web_gl_version_ > kWebGL1) {\n     state_restorer_->SetPixelUnpackBufferBindingDirty();\n     gl_->BindBuffer(GL_PIXEL_UNPACK_BUFFER, 0);\n   }\n\n  RefPtr<ColorBuffer> color_buffer_for_mailbox;\n  if (preserve_drawing_buffer_ == kDiscard) {\n    color_buffer_for_mailbox = back_color_buffer_;\n    back_color_buffer_ = CreateOrRecycleColorBuffer();\n    AttachColorBufferToReadFramebuffer();\n\n    if (discard_framebuffer_supported_) {\n      const GLenum kAttachments[3] = {GL_COLOR_ATTACHMENT0, GL_DEPTH_ATTACHMENT,\n                                      GL_STENCIL_ATTACHMENT};\n      state_restorer_->SetFramebufferBindingDirty();\n      gl_->BindFramebuffer(GL_FRAMEBUFFER, fbo_);\n      gl_->DiscardFramebufferEXT(GL_FRAMEBUFFER, 3, kAttachments);\n    }\n  } else {\n    color_buffer_for_mailbox = CreateOrRecycleColorBuffer();\n    gl_->CopySubTextureCHROMIUM(back_color_buffer_->texture_id, 0,\n                                color_buffer_for_mailbox->parameters.target,\n                                color_buffer_for_mailbox->texture_id, 0, 0, 0,\n                                0, 0, size_.Width(), size_.Height(), GL_FALSE,\n                                GL_FALSE, GL_FALSE);\n  }\n\n  {\n    gl_->ProduceTextureDirectCHROMIUM(\n        color_buffer_for_mailbox->texture_id,\n        color_buffer_for_mailbox->parameters.target,\n        color_buffer_for_mailbox->mailbox.name);\n    const GLuint64 fence_sync = gl_->InsertFenceSyncCHROMIUM();\n#if defined(OS_MACOSX)\n    gl_->DescheduleUntilFinishedCHROMIUM();\n#endif\n    gl_->Flush();\n    gl_->GenSyncTokenCHROMIUM(\n        fence_sync, color_buffer_for_mailbox->produce_sync_token.GetData());\n  }\n\n  {\n    bool is_overlay_candidate = color_buffer_for_mailbox->image_id != 0;\n    bool secure_output_only = false;\n    *out_mailbox = viz::TextureMailbox(\n        color_buffer_for_mailbox->mailbox,\n        color_buffer_for_mailbox->produce_sync_token,\n        color_buffer_for_mailbox->parameters.target, gfx::Size(size_),\n        is_overlay_candidate, secure_output_only);\n    out_mailbox->set_color_space(color_space_);\n\n    auto func =\n        WTF::Bind(&DrawingBuffer::MailboxReleasedGpu,\n                  RefPtr<DrawingBuffer>(this), color_buffer_for_mailbox);\n    *out_release_callback = cc::SingleReleaseCallback::Create(\n        ConvertToBaseCallback(std::move(func)));\n  }\n\n  front_color_buffer_ = color_buffer_for_mailbox;\n\n  contents_changed_ = false;\n  SetBufferClearNeeded(true);\n  return true;\n}\n", "target": 1, "idx": 186260}
{"func": "void skb_set_owner_w(struct sk_buff *skb, struct sock *sk)\n{\n\tskb_orphan(skb);\n\tskb->sk = sk;\n#ifdef CONFIG_INET\n\tif (unlikely(!sk_fullsock(sk))) {\n\t\tskb->destructor = sock_edemux;\n\t\tsock_hold(sk);\n\t\treturn;\n\t}\n#endif\n\tskb->destructor = sock_wfree;\n\tskb_set_hash_from_sk(skb, sk);\n\t/*\n\t * We used to take a refcount on sk, but following operation\n\t * is enough to guarantee sk_free() wont free this sock until\n\t * all in-flight packets are completed\n\t */\n\tatomic_add(skb->truesize, &sk->sk_wmem_alloc);\n}\n", "target": 0, "idx": 47887}
{"func": "void WebURLLoaderImpl::Context::OnReceivedResponse(\n    const ResourceResponseInfo& info) {\n  if (!client_)\n    return;\n\n  WebURLResponse response;\n  response.initialize();\n  PopulateURLResponse(request_.url(), info, &response);\n\n  bool show_raw_listing = (GURL(request_.url()).query() == \"raw\");\n\n  if (info.mime_type == \"text/vnd.chromium.ftp-dir\") {\n    if (show_raw_listing) {\n      response.setMIMEType(\"text/plain\");\n    } else {\n      response.setMIMEType(\"text/html\");\n     }\n   }\n \n   client_->didReceiveResponse(loader_, response);\n \n  if (!client_)\n    return;\n\n  DCHECK(!ftp_listing_delegate_.get());\n  DCHECK(!multipart_delegate_.get());\n  if (info.headers && info.mime_type == \"multipart/x-mixed-replace\") {\n    std::string content_type;\n    info.headers->EnumerateHeader(NULL, \"content-type\", &content_type);\n\n    std::string mime_type;\n    std::string charset;\n    bool had_charset = false;\n    std::string boundary;\n    net::HttpUtil::ParseContentType(content_type, &mime_type, &charset,\n                                    &had_charset, &boundary);\n    TrimString(boundary, \" \\\"\", &boundary);\n\n    if (!boundary.empty()) {\n      multipart_delegate_.reset(\n          new MultipartResponseDelegate(client_, loader_, response, boundary));\n    }\n  } else if (info.mime_type == \"text/vnd.chromium.ftp-dir\" &&\n             !show_raw_listing) {\n    ftp_listing_delegate_.reset(\n        new FtpDirectoryListingResponseDelegate(client_, loader_, response));\n  }\n}\n", "target": 1, "idx": 184958}
{"func": "void *_zend_shared_memdup(void *source, size_t size, zend_bool free_source)\n{\n\tvoid *old_p, *retval;\n\n\tif ((old_p = zend_hash_index_find_ptr(&xlat_table, (zend_ulong)source)) != NULL) {\n\t\t/* we already duplicated this pointer */\n\t\treturn old_p;\n\t}\n        retval = ZCG(mem);\n        ZCG(mem) = (void*)(((char*)ZCG(mem)) + ZEND_ALIGNED_SIZE(size));\n        memcpy(retval, source, size);\n        if (free_source) {\n                efree(source);\n        }\n       zend_shared_alloc_register_xlat_entry(source, retval);\n        return retval;\n }\n", "target": 1, "idx": 177942}
{"func": "EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionObjMethodWithArgs(ExecState* exec)\n{\n    JSValue thisValue = exec->hostThisValue();\n    if (!thisValue.inherits(&JSTestObj::s_info))\n        return throwVMTypeError(exec);\n    JSTestObj* castedThis = jsCast<JSTestObj*>(asObject(thisValue));\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\n     TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n     if (exec->argumentCount() < 3)\n        return throwVMError(exec, createTypeError(exec, \"Not enough arguments\"));\n     int intArg(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toInt32(exec));\n     if (exec->hadException())\n         return JSValue::encode(jsUndefined());\n    const String& strArg(ustringToString(MAYBE_MISSING_PARAMETER(exec, 1, DefaultIsUndefined).isEmpty() ? UString() : MAYBE_MISSING_PARAMETER(exec, 1, DefaultIsUndefined).toString(exec)->value(exec)));\n    if (exec->hadException())\n        return JSValue::encode(jsUndefined());\n    TestObj* objArg(toTestObj(MAYBE_MISSING_PARAMETER(exec, 2, DefaultIsUndefined)));\n    if (exec->hadException())\n        return JSValue::encode(jsUndefined());\n\n    JSC::JSValue result = toJS(exec, castedThis->globalObject(), WTF::getPtr(impl->objMethodWithArgs(intArg, strArg, objArg)));\n    return JSValue::encode(result);\n}\n", "target": 1, "idx": 184055}
{"func": "WORK_STATE ossl_statem_server_pre_work(SSL *s, WORK_STATE wst)\n{\n    OSSL_STATEM *st = &s->statem;\n\n    switch (st->hand_state) {\n     case TLS_ST_SW_HELLO_REQ:\n         s->shutdown = 0;\n         if (SSL_IS_DTLS(s))\n            dtls1_clear_record_buffer(s);\n         break;\n \n     case DTLS_ST_SW_HELLO_VERIFY_REQUEST:\n         s->shutdown = 0;\n         if (SSL_IS_DTLS(s)) {\n            dtls1_clear_record_buffer(s);\n             /* We don't buffer this message so don't use the timer */\n             st->use_timer = 0;\n         }\n        break;\n\n    case TLS_ST_SW_SRVR_HELLO:\n        if (SSL_IS_DTLS(s)) {\n            /*\n             * Messages we write from now on should be bufferred and\n             * retransmitted if necessary, so we need to use the timer now\n             */\n            st->use_timer = 1;\n        }\n        break;\n\n    case TLS_ST_SW_SRVR_DONE:\n#ifndef OPENSSL_NO_SCTP\n        if (SSL_IS_DTLS(s) && BIO_dgram_is_sctp(SSL_get_wbio(s)))\n            return dtls_wait_for_dry(s);\n#endif\n        return WORK_FINISHED_CONTINUE;\n\n    case TLS_ST_SW_SESSION_TICKET:\n        if (SSL_IS_DTLS(s)) {\n            /*\n             * We're into the last flight. We don't retransmit the last flight\n             * unless we need to, so we don't use the timer\n             */\n            st->use_timer = 0;\n        }\n        break;\n\n    case TLS_ST_SW_CHANGE:\n        s->session->cipher = s->s3->tmp.new_cipher;\n        if (!s->method->ssl3_enc->setup_key_block(s)) {\n            ossl_statem_set_error(s);\n            return WORK_ERROR;\n        }\n        if (SSL_IS_DTLS(s)) {\n            /*\n             * We're into the last flight. We don't retransmit the last flight\n             * unless we need to, so we don't use the timer. This might have\n             * already been set to 0 if we sent a NewSessionTicket message,\n             * but we'll set it again here in case we didn't.\n             */\n            st->use_timer = 0;\n        }\n        return WORK_FINISHED_CONTINUE;\n\n    case TLS_ST_OK:\n        return tls_finish_handshake(s, wst);\n\n    default:\n        /* No pre work to be done */\n        break;\n    }\n\n    return WORK_FINISHED_CONTINUE;\n}\n", "target": 1, "idx": 178371}
{"func": "load(ImlibImage * im, ImlibProgressFunction progress, char progress_granularity,\n     char immediate_load)\n{\n   static const int    intoffset[] = { 0, 4, 2, 1 };\n   static const int    intjump[] = { 8, 8, 4, 2 };\n   int                 rc;\n   DATA32             *ptr;\n   GifFileType        *gif;\n   GifRowType         *rows;\n   GifRecordType       rec;\n   ColorMapObject     *cmap;\n   int                 i, j, done, bg, r, g, b, w = 0, h = 0;\n   float               per = 0.0, per_inc;\n   int                 last_per = 0, last_y = 0;\n   int                 transp;\n   int                 fd;\n\n   done = 0;\n   rows = NULL;\n   transp = -1;\n\n   /* if immediate_load is 1, then dont delay image laoding as below, or */\n   /* already data in this image - dont load it again */\n   if (im->data)\n      return 0;\n\n   fd = open(im->real_file, O_RDONLY);\n   if (fd < 0)\n      return 0;\n\n#if GIFLIB_MAJOR >= 5\n   gif = DGifOpenFileHandle(fd, NULL);\n#else\n   gif = DGifOpenFileHandle(fd);\n#endif\n   if (!gif)\n     {\n        close(fd);\n        return 0;\n     }\n\n   rc = 0;                      /* Failure */\n\n   do\n     {\n        if (DGifGetRecordType(gif, &rec) == GIF_ERROR)\n          {\n             /* PrintGifError(); */\n             rec = TERMINATE_RECORD_TYPE;\n          }\n        if ((rec == IMAGE_DESC_RECORD_TYPE) && (!done))\n          {\n             if (DGifGetImageDesc(gif) == GIF_ERROR)\n               {\n                  /* PrintGifError(); */\n                  rec = TERMINATE_RECORD_TYPE;\n                  break;\n               }\n             w = gif->Image.Width;\n             h = gif->Image.Height;\n             if (!IMAGE_DIMENSIONS_OK(w, h))\n                goto quit2;\n\n             rows = calloc(h, sizeof(GifRowType *));\n             if (!rows)\n                goto quit2;\n\n             for (i = 0; i < h; i++)\n               {\n                  rows[i] = calloc(w, sizeof(GifPixelType));\n                  if (!rows[i])\n                     goto quit;\n               }\n\n             if (gif->Image.Interlace)\n               {\n                  for (i = 0; i < 4; i++)\n                    {\n                       for (j = intoffset[i]; j < h; j += intjump[i])\n                         {\n                            DGifGetLine(gif, rows[j], w);\n                         }\n                    }\n               }\n             else\n               {\n                  for (i = 0; i < h; i++)\n                    {\n                       DGifGetLine(gif, rows[i], w);\n                    }\n               }\n             done = 1;\n          }\n        else if (rec == EXTENSION_RECORD_TYPE)\n          {\n             int                 ext_code;\n             GifByteType        *ext;\n\n             ext = NULL;\n             DGifGetExtension(gif, &ext_code, &ext);\n             while (ext)\n               {\n                  if ((ext_code == 0xf9) && (ext[1] & 1) && (transp < 0))\n                    {\n                       transp = (int)ext[4];\n                    }\n                  ext = NULL;\n                  DGifGetExtensionNext(gif, &ext);\n               }\n          }\n     }\n   while (rec != TERMINATE_RECORD_TYPE);\n\n   if (transp >= 0)\n     {\n        SET_FLAG(im->flags, F_HAS_ALPHA);\n     }\n   else\n     {\n        UNSET_FLAG(im->flags, F_HAS_ALPHA);\n     }\n   if (!rows)\n     {\n        goto quit2;\n     }\n\n   /* set the format string member to the lower-case full extension */\n   /* name for the format - so example names would be: */\n   /* \"png\", \"jpeg\", \"tiff\", \"ppm\", \"pgm\", \"pbm\", \"gif\", \"xpm\" ... */\n   im->w = w;\n   im->h = h;\n   if (!im->format)\n      im->format = strdup(\"gif\");\n \n    if (im->loader || immediate_load || progress)\n      {\n         bg = gif->SBackGroundColor;\n         cmap = (gif->Image.ColorMap ? gif->Image.ColorMap : gif->SColorMap);\n         im->data = (DATA32 *) malloc(sizeof(DATA32) * w * h);\n         if (!im->data)\n            goto quit;\n                    {\n                       r = cmap->Colors[bg].Red;\n                       g = cmap->Colors[bg].Green;\n                       b = cmap->Colors[bg].Blue;\n                       *ptr++ = 0x00ffffff & ((r << 16) | (g << 8) | b);\n                    }\n                  else\n                    {\n                       r = cmap->Colors[rows[i][j]].Red;\n                       g = cmap->Colors[rows[i][j]].Green;\n                       b = cmap->Colors[rows[i][j]].Blue;\n                       *ptr++ = (0xff << 24) | (r << 16) | (g << 8) | b;\n           {\n              for (j = 0; j < w; j++)\n                {\n                  if (rows[i][j] == transp)\n                    {\n                       r = cmap->Colors[bg].Red;\n                       g = cmap->Colors[bg].Green;\n                       b = cmap->Colors[bg].Blue;\n                       *ptr++ = 0x00ffffff & ((r << 16) | (g << 8) | b);\n                    }\n                  else\n                    {\n                       r = cmap->Colors[rows[i][j]].Red;\n                       g = cmap->Colors[rows[i][j]].Green;\n                       b = cmap->Colors[rows[i][j]].Blue;\n                       *ptr++ = (0xff << 24) | (r << 16) | (g << 8) | b;\n                    }\n                   per += per_inc;\n                   if (progress && (((int)per) != last_per)\n                       && (((int)per) % progress_granularity == 0))\n                         {\n                            rc = 2;\n                            goto quit;\n                         }\n                       last_y = i;\n                    }\n               }\n          }\n\n      finish:\n        if (progress)\n           progress(im, 100, 0, last_y, w, h);\n     }\n\n   rc = 1;                      /* Success */\n\n quit:\n   for (i = 0; i < h; i++)\n      free(rows[i]);\n   free(rows);\n\n quit2:\n#if GIFLIB_MAJOR > 5 || (GIFLIB_MAJOR == 5 && GIFLIB_MINOR >= 1)\n   DGifCloseFile(gif, NULL);\n#else\n   DGifCloseFile(gif);\n#endif\n\n   return rc;\n}\n", "target": 1, "idx": 178251}
{"func": " static int read_request(int fd, debugger_request_t* out_request) {\n   ucred cr;\n   socklen_t len = sizeof(cr);\n int status = getsockopt(fd, SOL_SOCKET, SO_PEERCRED, &cr, &len);\n if (status != 0) {\n    ALOGE(\"cannot get credentials\");\n return -1;\n }\n\n  ALOGV(\"reading tid\");\n  fcntl(fd, F_SETFL, O_NONBLOCK);\n\n  pollfd pollfds[1];\n  pollfds[0].fd = fd;\n  pollfds[0].events = POLLIN;\n  pollfds[0].revents = 0;\n  status = TEMP_FAILURE_RETRY(poll(pollfds, 1, 3000));\n if (status != 1) {\n    ALOGE(\"timed out reading tid (from pid=%d uid=%d)\\n\", cr.pid, cr.uid);\n return -1;\n }\n\n debugger_msg_t msg;\n  memset(&msg, 0, sizeof(msg));\n  status = TEMP_FAILURE_RETRY(read(fd, &msg, sizeof(msg)));\n if (status < 0) {\n    ALOGE(\"read failure? %s (pid=%d uid=%d)\\n\", strerror(errno), cr.pid, cr.uid);\n return -1;\n }\n if (status != sizeof(debugger_msg_t)) {\n    ALOGE(\"invalid crash request of size %d (from pid=%d uid=%d)\\n\", status, cr.pid, cr.uid);\n return -1;\n }\n\n  out_request->action = static_cast<debugger_action_t>(msg.action);\n  out_request->tid = msg.tid;\n  out_request->pid = cr.pid;\n  out_request->uid = cr.uid;\n  out_request->gid = cr.gid;\n  out_request->abort_msg_address = msg.abort_msg_address;\n  out_request->original_si_code = msg.original_si_code;\n\n \n   if (msg.action == DEBUGGER_ACTION_CRASH) {\n    char buf[64];\n    struct stat s;\n    snprintf(buf, sizeof buf, \"/proc/%d/task/%d\", out_request->pid, out_request->tid);\n    if (stat(buf, &s)) {\n      ALOGE(\"tid %d does not exist in pid %d. ignoring debug request\\n\",\n          out_request->tid, out_request->pid);\n       return -1;\n     }\n  } else if (cr.uid == 0\n            || (cr.uid == AID_SYSTEM && msg.action == DEBUGGER_ACTION_DUMP_BACKTRACE)) {\n     status = get_process_info(out_request->tid, &out_request->pid,\n &out_request->uid, &out_request->gid);\n if (status < 0) {\n      ALOGE(\"tid %d does not exist. ignoring explicit dump request\\n\", out_request->tid);\n return -1;\n }\n\n if (!selinux_action_allowed(fd, out_request))\n return -1;\n } else {\n return -1;\n }\n return 0;\n}\n", "target": 1, "idx": 187429}
{"func": "size_t ZSTD_compressBegin_advanced_internal(ZSTD_CCtx* cctx,\n                                    const void* dict, size_t dictSize,\n                                    ZSTD_dictContentType_e dictContentType,\n                                    ZSTD_dictTableLoadMethod_e dtlm,\n                                    const ZSTD_CDict* cdict,\n                                    ZSTD_CCtx_params params,\n                                    unsigned long long pledgedSrcSize)\n{\n    DEBUGLOG(4, \"ZSTD_compressBegin_advanced_internal: wlog=%u\", params.cParams.windowLog);\n    /* compression parameters verification and optimization */\n    CHECK_F( ZSTD_checkCParams(params.cParams) );\n    return ZSTD_compressBegin_internal(cctx,\n                                       dict, dictSize, dictContentType, dtlm,\n                                       cdict,\n                                       params, pledgedSrcSize,\n                                       ZSTDb_not_buffered);\n}\n", "target": 0, "idx": 90009}
{"func": "static bool HitTestIsContentEditable(WebView* view, int x, int y) {\n  WebPoint hit_point(x, y);\n  WebHitTestResult hit_test_result = view->HitTestResultAt(hit_point);\n  return hit_test_result.IsContentEditable();\n}\n", "target": 0, "idx": 160871}
{"func": "static void reg_to_dbg(struct kvm_vcpu *vcpu,\n\t\t       struct sys_reg_params *p,\n\t\t       u64 *dbg_reg)\n{\n\tu64 val = p->regval;\n\n\tif (p->is_32bit) {\n\t\tval &= 0xffffffffUL;\n\t\tval |= ((*dbg_reg >> 32) << 32);\n\t}\n\n\t*dbg_reg = val;\n\tvcpu->arch.debug_flags |= KVM_ARM64_DEBUG_DIRTY;\n}\n", "target": 0, "idx": 62914}
{"func": "bool ScreenLayoutObserver::GetDisplayMessageForNotification(\n    const ScreenLayoutObserver::DisplayInfoMap& old_info,\n    base::string16* out_message,\n    base::string16* out_additional_message) {\n  if (old_display_mode_ != current_display_mode_) {\n    if (current_display_mode_ == DisplayMode::MIRRORING) {\n      *out_message = GetEnterMirrorModeMessage();\n      return true;\n    }\n    if (old_display_mode_ == DisplayMode::MIRRORING &&\n        GetExitMirrorModeMessage(out_message, out_additional_message)) {\n      return true;\n    }\n\n    if (current_display_mode_ == DisplayMode::UNIFIED) {\n      *out_message = GetEnterUnifiedModeMessage();\n      return true;\n    }\n    if (old_display_mode_ == DisplayMode::UNIFIED) {\n      *out_message = GetExitUnifiedModeMessage();\n      return true;\n    }\n\n    if (current_display_mode_ == DisplayMode::DOCKED ||\n        old_display_mode_ == DisplayMode::DOCKED) {\n      return false;\n    }\n  }\n\n  if (display_info_.size() < old_info.size()) {\n    for (const auto& iter : old_info) {\n      if (display_info_.count(iter.first))\n        continue;\n\n      *out_message =\n          GetDisplayRemovedMessage(iter.second, out_additional_message);\n      return true;\n    }\n  } else if (display_info_.size() > old_info.size()) {\n    for (const auto& iter : display_info_) {\n      if (old_info.count(iter.first))\n        continue;\n\n      *out_message = GetDisplayAddedMessage(iter.first, out_additional_message);\n      return true;\n    }\n  }\n\n  for (const auto& iter : display_info_) {\n    DisplayInfoMap::const_iterator old_iter = old_info.find(iter.first);\n    if (old_iter == old_info.end()) {\n      NOTREACHED() << \"A display mode transition that should have been handled\"\n                      \"earlier.\";\n      return false;\n    }\n\n    if (iter.second.configured_ui_scale() !=\n        old_iter->second.configured_ui_scale()) {\n      *out_additional_message = l10n_util::GetStringFUTF16(\n          IDS_ASH_STATUS_TRAY_DISPLAY_RESOLUTION_CHANGED,\n           GetDisplayName(iter.first), GetDisplaySize(iter.first));\n       return true;\n     }\n    if (iter.second.GetActiveRotation() !=\n        old_iter->second.GetActiveRotation()) {\n       int rotation_text_id = 0;\n       switch (iter.second.GetActiveRotation()) {\n         case display::Display::ROTATE_0:\n          rotation_text_id = IDS_ASH_STATUS_TRAY_DISPLAY_STANDARD_ORIENTATION;\n          break;\n        case display::Display::ROTATE_90:\n          rotation_text_id = IDS_ASH_STATUS_TRAY_DISPLAY_ORIENTATION_90;\n          break;\n        case display::Display::ROTATE_180:\n          rotation_text_id = IDS_ASH_STATUS_TRAY_DISPLAY_ORIENTATION_180;\n          break;\n        case display::Display::ROTATE_270:\n          rotation_text_id = IDS_ASH_STATUS_TRAY_DISPLAY_ORIENTATION_270;\n          break;\n      }\n      *out_additional_message = l10n_util::GetStringFUTF16(\n          IDS_ASH_STATUS_TRAY_DISPLAY_ROTATED, GetDisplayName(iter.first),\n          l10n_util::GetStringUTF16(rotation_text_id));\n      return true;\n    }\n  }\n\n  return false;\n}\n", "target": 1, "idx": 185952}
{"func": "static void run_ksoftirqd(unsigned int cpu)\n{\n\tlocal_irq_disable();\n\tif (local_softirq_pending()) {\n\t\t/*\n\t\t * We can safely run softirq on inline stack, as we are not deep\n\t\t * in the task stack here.\n\t\t */\n\t\t__do_softirq();\n\t\tlocal_irq_enable();\n\t\tcond_resched();\n\t\treturn;\n\t}\n\tlocal_irq_enable();\n}\n", "target": 0, "idx": 81217}
{"func": "void __udp4_lib_err(struct sk_buff *skb, u32 info, struct udp_table *udptable)\n{\n\tstruct inet_sock *inet;\n\tconst struct iphdr *iph = (const struct iphdr *)skb->data;\n\tstruct udphdr *uh = (struct udphdr *)(skb->data+(iph->ihl<<2));\n\tconst int type = icmp_hdr(skb)->type;\n\tconst int code = icmp_hdr(skb)->code;\n\tstruct sock *sk;\n\tint harderr;\n\tint err;\n\tstruct net *net = dev_net(skb->dev);\n\n\tsk = __udp4_lib_lookup(net, iph->daddr, uh->dest,\n\t\t\tiph->saddr, uh->source, skb->dev->ifindex, udptable);\n\tif (sk == NULL) {\n\t\tICMP_INC_STATS_BH(net, ICMP_MIB_INERRORS);\n\t\treturn;\t/* No socket for error */\n\t}\n\n\terr = 0;\n\tharderr = 0;\n\tinet = inet_sk(sk);\n\n\tswitch (type) {\n\tdefault:\n\tcase ICMP_TIME_EXCEEDED:\n\t\terr = EHOSTUNREACH;\n\t\tbreak;\n\tcase ICMP_SOURCE_QUENCH:\n\t\tgoto out;\n\tcase ICMP_PARAMETERPROB:\n\t\terr = EPROTO;\n\t\tharderr = 1;\n\t\tbreak;\n\tcase ICMP_DEST_UNREACH:\n\t\tif (code == ICMP_FRAG_NEEDED) { /* Path MTU discovery */\n\t\t\tipv4_sk_update_pmtu(skb, sk, info);\n\t\t\tif (inet->pmtudisc != IP_PMTUDISC_DONT) {\n\t\t\t\terr = EMSGSIZE;\n\t\t\t\tharderr = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\t\terr = EHOSTUNREACH;\n\t\tif (code <= NR_ICMP_UNREACH) {\n\t\t\tharderr = icmp_err_convert[code].fatal;\n\t\t\terr = icmp_err_convert[code].errno;\n\t\t}\n\t\tbreak;\n\tcase ICMP_REDIRECT:\n\t\tipv4_sk_redirect(skb, sk);\n\t\tgoto out;\n\t}\n\n\t/*\n\t *      RFC1122: OK.  Passes ICMP errors back to application, as per\n\t *\t4.1.3.3.\n\t */\n\tif (!inet->recverr) {\n\t\tif (!harderr || sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out;\n\t} else\n\t\tip_icmp_error(sk, skb, err, uh->dest, info, (u8 *)(uh+1));\n\n\tsk->sk_err = err;\n\tsk->sk_error_report(sk);\nout:\n\tsock_put(sk);\n}\n", "target": 0, "idx": 40162}
{"func": "void ResourceMessageFilter::OnClipboardWriteObjectsSync(\n    const Clipboard::ObjectMap& objects,\n    base::SharedMemoryHandle bitmap_handle) {\n  DCHECK(base::SharedMemory::IsHandleValid(bitmap_handle))\n      << \"Bad bitmap handle\";\n  Clipboard::ObjectMap* long_living_objects = new Clipboard::ObjectMap(objects);\n\n  Clipboard::ReplaceSharedMemHandle(long_living_objects, bitmap_handle,\n                                    handle());\n\n  ChromeThread::PostTask(\n      ChromeThread::UI,\n      FROM_HERE,\n      new WriteClipboardTask(long_living_objects));\n}\n", "target": 0, "idx": 99281}
{"func": " bool BluetoothDeviceChromeOS::ExpectingPasskey() const {\n  return !passkey_callback_.is_null();\n }\n", "target": 1, "idx": 184917}
{"func": "static int __init xfrm6_tunnel_init(void)\n {\n \tint rv;\n \n \trv = xfrm_register_type(&xfrm6_tunnel_type, AF_INET6);\n \tif (rv < 0)\n\t\tgoto err;\n \trv = xfrm6_tunnel_register(&xfrm6_tunnel_handler, AF_INET6);\n \tif (rv < 0)\n\t\tgoto unreg;\n \trv = xfrm6_tunnel_register(&xfrm46_tunnel_handler, AF_INET);\n \tif (rv < 0)\n\t\tgoto dereg6;\n\trv = xfrm6_tunnel_spi_init();\n\tif (rv < 0)\n\t\tgoto dereg46;\n\trv = register_pernet_subsys(&xfrm6_tunnel_net_ops);\n\tif (rv < 0)\n\t\tgoto deregspi;\n \treturn 0;\n \nderegspi:\n\txfrm6_tunnel_spi_fini();\ndereg46:\n\txfrm6_tunnel_deregister(&xfrm46_tunnel_handler, AF_INET);\ndereg6:\n \txfrm6_tunnel_deregister(&xfrm6_tunnel_handler, AF_INET6);\nunreg:\n \txfrm_unregister_type(&xfrm6_tunnel_type, AF_INET6);\nerr:\n \treturn rv;\n }\n", "target": 1, "idx": 179052}
{"func": "void do_syscall_trace(void)\n{\n\t/*\n\t * The 0x80 provides a way for the tracing parent to distinguish\n\t * between a syscall stop and SIGTRAP delivery\n\t */\n\tptrace_notify(SIGTRAP|((current->ptrace & PT_TRACESYSGOOD) ? 0x80 : 0));\n\n\t/*\n\t * this isn't the same as continuing with a signal, but it will do\n\t * for normal use.  strace only continues with a signal if the\n\t * stopping signal is not SIGTRAP.  -brl\n\t */\n\tif (current->exit_code) {\n\t\tsend_sig(current->exit_code, current, 1);\n\t\tcurrent->exit_code = 0;\n\t}\n}\n", "target": 0, "idx": 26586}
{"func": "bool HFSIterator::IsSymbolicLink() {\n  if (IsDirectory())\n    return S_ISLNK(catalog_->current_record()->folder->bsdInfo.fileMode);\n  else\n    return S_ISLNK(catalog_->current_record()->file->bsdInfo.fileMode);\n}\n", "target": 0, "idx": 133865}
{"func": "static int userfaultfd_unregister(struct userfaultfd_ctx *ctx,\n\t\t\t\t  unsigned long arg)\n{\n\tstruct mm_struct *mm = ctx->mm;\n\tstruct vm_area_struct *vma, *prev, *cur;\n\tint ret;\n\tstruct uffdio_range uffdio_unregister;\n\tunsigned long new_flags;\n\tbool found;\n\tunsigned long start, end, vma_end;\n\tconst void __user *buf = (void __user *)arg;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&uffdio_unregister, buf, sizeof(uffdio_unregister)))\n\t\tgoto out;\n\n\tret = validate_range(mm, uffdio_unregister.start,\n\t\t\t     uffdio_unregister.len);\n\tif (ret)\n\t\tgoto out;\n\n\tstart = uffdio_unregister.start;\n\tend = start + uffdio_unregister.len;\n\n\tret = -ENOMEM;\n\tif (!mmget_not_zero(mm))\n\t\tgoto out;\n\n\tdown_write(&mm->mmap_sem);\n\tvma = find_vma_prev(mm, start, &prev);\n\tif (!vma)\n\t\tgoto out_unlock;\n\n\t/* check that there's at least one vma in the range */\n\tret = -EINVAL;\n\tif (vma->vm_start >= end)\n\t\tgoto out_unlock;\n\n\t/*\n\t * If the first vma contains huge pages, make sure start address\n\t * is aligned to huge page size.\n\t */\n\tif (is_vm_hugetlb_page(vma)) {\n\t\tunsigned long vma_hpagesize = vma_kernel_pagesize(vma);\n\n\t\tif (start & (vma_hpagesize - 1))\n\t\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Search for not compatible vmas.\n\t */\n\tfound = false;\n\tret = -EINVAL;\n\tfor (cur = vma; cur && cur->vm_start < end; cur = cur->vm_next) {\n\t\tcond_resched();\n\n\t\tBUG_ON(!!cur->vm_userfaultfd_ctx.ctx ^\n\t\t       !!(cur->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP)));\n\n\t\t/*\n\t\t * Check not compatible vmas, not strictly required\n\t\t * here as not compatible vmas cannot have an\n\t\t * userfaultfd_ctx registered on them, but this\n\t\t * provides for more strict behavior to notice\n\t\t * unregistration errors.\n\t\t */\n\t\tif (!vma_can_userfault(cur))\n\t\t\tgoto out_unlock;\n\n\t\tfound = true;\n\t}\n\tBUG_ON(!found);\n\n\tif (vma->vm_start < start)\n\t\tprev = vma;\n\n\tret = 0;\n\tdo {\n \t\tcond_resched();\n \n \t\tBUG_ON(!vma_can_userfault(vma));\n \n \t\t/*\n \t\t * Nothing to do: this vma is already registered into this\n\t\t * userfaultfd and with the right tracking mode too.\n\t\t */\n\t\tif (!vma->vm_userfaultfd_ctx.ctx)\n\t\t\tgoto skip;\n\n\t\tif (vma->vm_start > start)\n\t\t\tstart = vma->vm_start;\n\t\tvma_end = min(end, vma->vm_end);\n\n\t\tif (userfaultfd_missing(vma)) {\n\t\t\t/*\n\t\t\t * Wake any concurrent pending userfault while\n\t\t\t * we unregister, so they will not hang\n\t\t\t * permanently and it avoids userland to call\n\t\t\t * UFFDIO_WAKE explicitly.\n\t\t\t */\n\t\t\tstruct userfaultfd_wake_range range;\n\t\t\trange.start = start;\n\t\t\trange.len = vma_end - start;\n\t\t\twake_userfault(vma->vm_userfaultfd_ctx.ctx, &range);\n\t\t}\n\n\t\tnew_flags = vma->vm_flags & ~(VM_UFFD_MISSING | VM_UFFD_WP);\n\t\tprev = vma_merge(mm, prev, start, vma_end, new_flags,\n\t\t\t\t vma->anon_vma, vma->vm_file, vma->vm_pgoff,\n\t\t\t\t vma_policy(vma),\n\t\t\t\t NULL_VM_UFFD_CTX);\n\t\tif (prev) {\n\t\t\tvma = prev;\n\t\t\tgoto next;\n\t\t}\n\t\tif (vma->vm_start < start) {\n\t\t\tret = split_vma(mm, vma, start, 1);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (vma->vm_end > end) {\n\t\t\tret = split_vma(mm, vma, end, 0);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\tnext:\n\t\t/*\n\t\t * In the vma_merge() successful mprotect-like case 8:\n\t\t * the next vma was merged into the current one and\n\t\t * the current one has not been updated yet.\n\t\t */\n\t\tvma->vm_flags = new_flags;\n\t\tvma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;\n\n\tskip:\n\t\tprev = vma;\n\t\tstart = vma->vm_end;\n\t\tvma = vma->vm_next;\n\t} while (vma && vma->vm_start < end);\nout_unlock:\n\tup_write(&mm->mmap_sem);\n\tmmput(mm);\nout:\n\treturn ret;\n}\n", "target": 1, "idx": 182178}
{"func": "static void stream_int_shutr_conn(struct stream_interface *si)\n{\n\tstruct connection *conn = __objt_conn(si->end);\n\n\tsi->ib->flags &= ~CF_SHUTR_NOW;\n\tif (si->ib->flags & CF_SHUTR)\n\t\treturn;\n\tsi->ib->flags |= CF_SHUTR;\n\tsi->ib->rex = TICK_ETERNITY;\n\tsi->flags &= ~SI_FL_WAIT_ROOM;\n\n\tif (si->state != SI_ST_EST && si->state != SI_ST_CON)\n\t\treturn;\n\n\tif (si->ob->flags & CF_SHUTW) {\n\t\tconn_full_close(conn);\n\t\tsi->state = SI_ST_DIS;\n\t\tsi->exp = TICK_ETERNITY;\n\t}\n\telse if (si->flags & SI_FL_NOHALF) {\n\t\t/* we want to immediately forward this close to the write side */\n\t\treturn stream_int_shutw_conn(si);\n\t}\n\telse if (conn->ctrl) {\n\t\t/* we want the caller to disable polling on this FD */\n\t\tconn_data_stop_recv(conn);\n\t}\n}\n", "target": 0, "idx": 9886}
{"func": "append_quoted (struct stringbuf *sb, const unsigned char *value, size_t length,\n               int skip)\n{\n  unsigned char tmp[4];\n  const unsigned char *s = value;\n  size_t n = 0;\n\n  for (;;)\n    {\n      for (value = s; n+skip < length; n++, s++)\n        {\n          s += skip;\n          n += skip;\n          if (*s < ' ' || *s > 126 || strchr (\",+\\\"\\\\<>;\", *s) )\n            break;\n        }\n\n      if (s != value)\n        put_stringbuf_mem_skip (sb, value, s-value, skip);\n      if (n+skip >= length)\n        return; /* ready */\n      s += skip;\n       n += skip;\n       if ( *s < ' ' || *s > 126 )\n         {\n          sprintf (tmp, \"\\\\%02X\", *s);\n           put_stringbuf_mem (sb, tmp, 3);\n         }\n       else\n        {\n          tmp[0] = '\\\\';\n          tmp[1] = *s;\n          put_stringbuf_mem (sb, tmp, 2);\n        }\n      n++; s++;\n    }\n}\n", "target": 1, "idx": 178221}
{"func": "static void SSL_SESSION_list_remove(SSL_CTX *ctx, SSL_SESSION *s)\n{\n    if ((s->next == NULL) || (s->prev == NULL))\n        return;\n\n    if (s->next == (SSL_SESSION *)&(ctx->session_cache_tail)) {\n        /* last element in list */\n        if (s->prev == (SSL_SESSION *)&(ctx->session_cache_head)) {\n            /* only one element in list */\n            ctx->session_cache_head = NULL;\n            ctx->session_cache_tail = NULL;\n        } else {\n            ctx->session_cache_tail = s->prev;\n            s->prev->next = (SSL_SESSION *)&(ctx->session_cache_tail);\n        }\n    } else {\n        if (s->prev == (SSL_SESSION *)&(ctx->session_cache_head)) {\n            /* first element in list */\n            ctx->session_cache_head = s->next;\n            s->next->prev = (SSL_SESSION *)&(ctx->session_cache_head);\n        } else {\n            /* middle of list */\n            s->next->prev = s->prev;\n            s->prev->next = s->next;\n        }\n    }\n    s->prev = s->next = NULL;\n}\n", "target": 0, "idx": 12792}
{"func": "static void check_clr_rcv_irq(struct smi_info *smi_info)\n{\n\tu8 enables = 0;\n\tint rv;\n\n\trv = get_global_enables(smi_info, &enables);\n\tif (!rv) {\n\t\tif ((enables & IPMI_BMC_RCV_MSG_INTR) == 0)\n\t\t\t/* Already clear, should work ok. */\n\t\t\treturn;\n\n\t\tenables &= ~IPMI_BMC_RCV_MSG_INTR;\n\t\trv = set_global_enables(smi_info, enables);\n\t}\n\n\tif (rv < 0) {\n\t\tdev_err(smi_info->io.dev,\n\t\t\t\"Cannot check clearing the rcv irq: %d\\n\", rv);\n\t\treturn;\n\t}\n\n\tif (rv) {\n\t\t/*\n\t\t * An error when setting the event buffer bit means\n\t\t * clearing the bit is not supported.\n\t\t */\n\t\tdev_warn(smi_info->io.dev,\n\t\t\t \"The BMC does not support clearing the recv irq bit, compensating, but the BMC needs to be fixed.\\n\");\n\t\tsmi_info->cannot_disable_irq = true;\n\t}\n}\n", "target": 0, "idx": 90206}
{"func": "    void setPositiveMargin(LayoutUnit p) { ASSERT(!m_discardMargin); m_positiveMargin = p; }\n", "target": 0, "idx": 124778}
{"func": "bool LayoutSVGViewportContainer::calculateLocalTransform()\n {\n     if (!m_needsTransformUpdate)\n        return false;\n \n     m_localToParentTransform = AffineTransform::translation(m_viewport.x(), m_viewport.y()) * viewportTransform();\n     m_needsTransformUpdate = false;\n    return true;\n }\n", "target": 1, "idx": 185371}
{"func": "static void firm_setup_port(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct device *dev = &port->dev;\n\tstruct whiteheat_port_settings port_settings;\n\tunsigned int cflag = tty->termios.c_cflag;\n\n\tport_settings.port = port->port_number + 1;\n\n\t/* get the byte size */\n\tswitch (cflag & CSIZE) {\n\tcase CS5:\tport_settings.bits = 5;   break;\n\tcase CS6:\tport_settings.bits = 6;   break;\n\tcase CS7:\tport_settings.bits = 7;   break;\n\tdefault:\n\tcase CS8:\tport_settings.bits = 8;   break;\n\t}\n\tdev_dbg(dev, \"%s - data bits = %d\\n\", __func__, port_settings.bits);\n\n\t/* determine the parity */\n\tif (cflag & PARENB)\n\t\tif (cflag & CMSPAR)\n\t\t\tif (cflag & PARODD)\n\t\t\t\tport_settings.parity = WHITEHEAT_PAR_MARK;\n\t\t\telse\n\t\t\t\tport_settings.parity = WHITEHEAT_PAR_SPACE;\n\t\telse\n\t\t\tif (cflag & PARODD)\n\t\t\t\tport_settings.parity = WHITEHEAT_PAR_ODD;\n\t\t\telse\n\t\t\t\tport_settings.parity = WHITEHEAT_PAR_EVEN;\n\telse\n\t\tport_settings.parity = WHITEHEAT_PAR_NONE;\n\tdev_dbg(dev, \"%s - parity = %c\\n\", __func__, port_settings.parity);\n\n\t/* figure out the stop bits requested */\n\tif (cflag & CSTOPB)\n\t\tport_settings.stop = 2;\n\telse\n\t\tport_settings.stop = 1;\n\tdev_dbg(dev, \"%s - stop bits = %d\\n\", __func__, port_settings.stop);\n\n\t/* figure out the flow control settings */\n\tif (cflag & CRTSCTS)\n\t\tport_settings.hflow = (WHITEHEAT_HFLOW_CTS |\n\t\t\t\t\t\tWHITEHEAT_HFLOW_RTS);\n\telse\n\t\tport_settings.hflow = WHITEHEAT_HFLOW_NONE;\n\tdev_dbg(dev, \"%s - hardware flow control = %s %s %s %s\\n\", __func__,\n\t    (port_settings.hflow & WHITEHEAT_HFLOW_CTS) ? \"CTS\" : \"\",\n\t    (port_settings.hflow & WHITEHEAT_HFLOW_RTS) ? \"RTS\" : \"\",\n\t    (port_settings.hflow & WHITEHEAT_HFLOW_DSR) ? \"DSR\" : \"\",\n\t    (port_settings.hflow & WHITEHEAT_HFLOW_DTR) ? \"DTR\" : \"\");\n\n\t/* determine software flow control */\n\tif (I_IXOFF(tty))\n\t\tport_settings.sflow = WHITEHEAT_SFLOW_RXTX;\n\telse\n\t\tport_settings.sflow = WHITEHEAT_SFLOW_NONE;\n\tdev_dbg(dev, \"%s - software flow control = %c\\n\", __func__, port_settings.sflow);\n\n\tport_settings.xon = START_CHAR(tty);\n\tport_settings.xoff = STOP_CHAR(tty);\n\tdev_dbg(dev, \"%s - XON = %2x, XOFF = %2x\\n\", __func__, port_settings.xon, port_settings.xoff);\n\n\t/* get the baud rate wanted */\n\tport_settings.baud = tty_get_baud_rate(tty);\n\tdev_dbg(dev, \"%s - baud rate = %d\\n\", __func__, port_settings.baud);\n\n\t/* fixme: should set validated settings */\n\ttty_encode_baud_rate(tty, port_settings.baud, port_settings.baud);\n\t/* handle any settings that aren't specified in the tty structure */\n\tport_settings.lloop = 0;\n\n\t/* now send the message to the device */\n\tfirm_send_command(port, WHITEHEAT_SETUP_PORT,\n\t\t\t(__u8 *)&port_settings, sizeof(port_settings));\n}\n", "target": 0, "idx": 38092}
{"func": "static zval *php_zip_property_reader(ze_zip_object *obj, zip_prop_handler *hnd, zval *rv) /* {{{ */\n{\n\tconst char *retchar = NULL;\n\tint retint = 0;\n\tint len = 0;\n\n\tif (obj && obj->za != NULL) {\n\t\tif (hnd->read_const_char_func) {\n\t\t\tretchar = hnd->read_const_char_func(obj->za, &len);\n\t\t} else {\n\t\t\tif (hnd->read_int_func) {\n\t\t\t\tretint = hnd->read_int_func(obj->za);\n\t\t\t\tif (retint == -1) {\n\t\t\t\t\tphp_error_docref(NULL, E_WARNING, \"Internal zip error returned\");\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (hnd->read_const_char_from_obj_func) {\n\t\t\t\t\tretchar = hnd->read_const_char_from_obj_func(obj);\n\t\t\t\t\tlen = strlen(retchar);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch (hnd->type) {\n\t\tcase IS_STRING:\n\t\t\tif (retchar) {\n\t\t\t\tZVAL_STRINGL(rv, (char *) retchar, len);\n\t\t\t} else {\n\t\t\t\tZVAL_EMPTY_STRING(rv);\n\t\t\t}\n\t\t\tbreak;\n\t\t/* case IS_TRUE */\n\t\tcase IS_FALSE:\n\t\t\tZVAL_BOOL(rv, (long)retint);\n\t\t\tbreak;\n\t\tcase IS_LONG:\n\t\t\tZVAL_LONG(rv, (long)retint);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tZVAL_NULL(rv);\n\t}\n\n\treturn rv;\n}\n/* }}} */\n", "target": 0, "idx": 54435}
{"func": " BrowserContext* SharedWorkerDevToolsAgentHost::GetBrowserContext() {\n  RenderProcessHost* rph = GetProcess();\n   return rph ? rph->GetBrowserContext() : nullptr;\n }\n", "target": 1, "idx": 186765}
{"func": "base::Optional<AuthenticatorGetAssertionResponse> ReadCTAPGetAssertionResponse(\n    base::span<const uint8_t> buffer) {\n  if (buffer.size() <= kResponseCodeLength)\n    return base::nullopt;\n\n  base::Optional<CBOR> decoded_response =\n      cbor::CBORReader::Read(buffer.subspan(1));\n\n  if (!decoded_response || !decoded_response->is_map())\n    return base::nullopt;\n\n  auto& response_map = decoded_response->GetMap();\n\n  auto it = response_map.find(CBOR(2));\n  if (it == response_map.end() || !it->second.is_bytestring())\n    return base::nullopt;\n\n  auto auth_data =\n      AuthenticatorData::DecodeAuthenticatorData(it->second.GetBytestring());\n  if (!auth_data)\n    return base::nullopt;\n\n  it = response_map.find(CBOR(3));\n  if (it == response_map.end() || !it->second.is_bytestring())\n    return base::nullopt;\n\n  auto signature = it->second.GetBytestring();\n  AuthenticatorGetAssertionResponse response(std::move(*auth_data),\n                                             std::move(signature));\n\n  it = response_map.find(CBOR(1));\n  if (it != response_map.end()) {\n    auto credential =\n        PublicKeyCredentialDescriptor::CreateFromCBORValue(it->second);\n    if (!credential)\n      return base::nullopt;\n    response.SetCredential(std::move(*credential));\n  }\n\n  it = response_map.find(CBOR(4));\n  if (it != response_map.end()) {\n    auto user = PublicKeyCredentialUserEntity::CreateFromCBORValue(it->second);\n    if (!user)\n      return base::nullopt;\n    response.SetUserEntity(std::move(*user));\n  }\n\n  it = response_map.find(CBOR(5));\n  if (it != response_map.end()) {\n    if (!it->second.is_unsigned())\n      return base::nullopt;\n\n    response.SetNumCredentials(it->second.GetUnsigned());\n  }\n\n  return base::Optional<AuthenticatorGetAssertionResponse>(std::move(response));\n}\n", "target": 0, "idx": 145564}
{"func": "parserep(netdissect_options *ndo,\n         register const struct sunrpc_msg *rp, register u_int length)\n{\n\tregister const uint32_t *dp;\n\tu_int len;\n\tenum sunrpc_accept_stat astat;\n\n\t/*\n\t * Portability note:\n\t * Here we find the address of the ar_verf credentials.\n\t * Originally, this calculation was\n\t *\tdp = (uint32_t *)&rp->rm_reply.rp_acpt.ar_verf\n\t * On the wire, the rp_acpt field starts immediately after\n\t * the (32 bit) rp_stat field.  However, rp_acpt (which is a\n\t * \"struct accepted_reply\") contains a \"struct opaque_auth\",\n\t * whose internal representation contains a pointer, so on a\n\t * 64-bit machine the compiler inserts 32 bits of padding\n\t * before rp->rm_reply.rp_acpt.ar_verf.  So, we cannot use\n\t * the internal representation to parse the on-the-wire\n\t * representation.  Instead, we skip past the rp_stat field,\n\t * which is an \"enum\" and so occupies one 32-bit word.\n\t */\n\tdp = ((const uint32_t *)&rp->rm_reply) + 1;\n\tND_TCHECK(dp[1]);\n\tlen = EXTRACT_32BITS(&dp[1]);\n\tif (len >= length)\n\t\treturn (NULL);\n\t/*\n \t * skip past the ar_verf credentials.\n \t */\n \tdp += (len + (2*sizeof(uint32_t) + 3)) / sizeof(uint32_t);\n\tND_TCHECK2(dp[0], 0);\n \n \t/*\n \t * now we can check the ar_stat field\n \t */\n \tastat = (enum sunrpc_accept_stat) EXTRACT_32BITS(dp);\n \tif (astat != SUNRPC_SUCCESS) {\n \t\tND_PRINT((ndo, \" %s\", tok2str(sunrpc_str, \"ar_stat %d\", astat)));\n\t\tnfserr = 1;\t\t/* suppress trunc string */\n\t\treturn (NULL);\n\t}\n\t/* successful return */\n\tND_TCHECK2(*dp, sizeof(astat));\n\treturn ((const uint32_t *) (sizeof(astat) + ((const char *)dp)));\ntrunc:\n\treturn (0);\n}\n", "target": 1, "idx": 181113}
{"func": "intuit_diff_type (bool need_header, mode_t *p_file_type)\n{\n    file_offset this_line = 0;\n    file_offset first_command_line = -1;\n    char first_ed_command_letter = 0;\n    lin fcl_line = 0; /* Pacify 'gcc -W'.  */\n    bool this_is_a_command = false;\n    bool stars_this_line = false;\n    bool extended_headers = false;\n    enum nametype i;\n    struct stat st[3];\n    int stat_errno[3];\n    int version_controlled[3];\n    enum diff retval;\n    mode_t file_type;\n\n    for (i = OLD;  i <= INDEX;  i++)\n      if (p_name[i]) {\n\t  free (p_name[i]);\n\t  p_name[i] = 0;\n        }\n    for (i = 0; i < ARRAY_SIZE (invalid_names); i++)\n\tinvalid_names[i] = NULL;\n    for (i = OLD; i <= NEW; i++)\n      if (p_timestr[i])\n\t{\n\t  free(p_timestr[i]);\n\t  p_timestr[i] = 0;\n\t}\n    for (i = OLD; i <= NEW; i++)\n      if (p_sha1[i])\n\t{\n\t  free (p_sha1[i]);\n\t  p_sha1[i] = 0;\n\t}\n    p_git_diff = false;\n    for (i = OLD; i <= NEW; i++)\n      {\n\tp_mode[i] = 0;\n\tp_copy[i] = false;\n\tp_rename[i] = false;\n      }\n\n    /* Ed and normal format patches don't have filename headers.  */\n    if (diff_type == ED_DIFF || diff_type == NORMAL_DIFF)\n      need_header = false;\n\n    version_controlled[OLD] = -1;\n    version_controlled[NEW] = -1;\n    version_controlled[INDEX] = -1;\n    p_rfc934_nesting = 0;\n    p_timestamp[OLD].tv_sec = p_timestamp[NEW].tv_sec = -1;\n    p_says_nonexistent[OLD] = p_says_nonexistent[NEW] = 0;\n    Fseek (pfp, p_base, SEEK_SET);\n    p_input_line = p_bline - 1;\n    for (;;) {\n\tchar *s;\n\tchar *t;\n\tfile_offset previous_line = this_line;\n\tbool last_line_was_command = this_is_a_command;\n\tbool stars_last_line = stars_this_line;\n\tsize_t indent = 0;\n\tchar ed_command_letter;\n\tbool strip_trailing_cr;\n\tsize_t chars_read;\n\n\tthis_line = file_tell (pfp);\n\tchars_read = pget_line (0, 0, false, false);\n\tif (chars_read == (size_t) -1)\n\t  xalloc_die ();\n\tif (! chars_read) {\n\t    if (first_ed_command_letter) {\n\t\t\t\t\t/* nothing but deletes!? */\n\t\tp_start = first_command_line;\n\t\tp_sline = fcl_line;\n\t\tretval = ED_DIFF;\n\t\tgoto scan_exit;\n\t    }\n\t    else {\n\t\tp_start = this_line;\n\t\tp_sline = p_input_line;\n\t\tif (extended_headers)\n\t\t  {\n\t\t    /* Patch contains no hunks; any diff type will do. */\n\t\t    retval = UNI_DIFF;\n\t\t    goto scan_exit;\n\t\t  }\n\t\treturn NO_DIFF;\n\t    }\n\t}\n\tstrip_trailing_cr = 2 <= chars_read && buf[chars_read - 2] == '\\r';\n\tfor (s = buf; *s == ' ' || *s == '\\t' || *s == 'X'; s++) {\n\t    if (*s == '\\t')\n\t\tindent = (indent + 8) & ~7;\n\t    else\n\t\tindent++;\n\t}\n\tif (ISDIGIT (*s))\n\t  {\n\t    for (t = s + 1; ISDIGIT (*t) || *t == ',';  t++)\n\t      /* do nothing */ ;\n\t    if (*t == 'd' || *t == 'c' || *t == 'a')\n\t      {\n\t\tfor (t++;  ISDIGIT (*t) || *t == ',';  t++)\n\t\t  /* do nothing */ ;\n\t\tfor (; *t == ' ' || *t == '\\t'; t++)\n\t\t  /* do nothing */ ;\n\t\tif (*t == '\\r')\n\t\t  t++;\n\t\tthis_is_a_command = (*t == '\\n');\n\t      }\n\t  }\n\tif (! need_header\n\t    && first_command_line < 0\n\t    && ((ed_command_letter = get_ed_command_letter (s))\n\t\t|| this_is_a_command)) {\n\t    first_command_line = this_line;\n\t    first_ed_command_letter = ed_command_letter;\n\t    fcl_line = p_input_line;\n\t    p_indent = indent;\t\t/* assume this for now */\n\t    p_strip_trailing_cr = strip_trailing_cr;\n\t}\n\tif (!stars_last_line && strnEQ(s, \"*** \", 4))\n\t  {\n\t    fetchname (s+4, strippath, &p_name[OLD], &p_timestr[OLD],\n\t\t       &p_timestamp[OLD]);\n\t    need_header = false;\n\t  }\n\telse if (strnEQ(s, \"+++ \", 4))\n\t  {\n\t    /* Swap with NEW below.  */\n\t    fetchname (s+4, strippath, &p_name[OLD], &p_timestr[OLD],\n\t\t       &p_timestamp[OLD]);\n\t    need_header = false;\n\t    p_strip_trailing_cr = strip_trailing_cr;\n\t  }\n\telse if (strnEQ(s, \"Index:\", 6))\n\t  {\n\t    fetchname (s+6, strippath, &p_name[INDEX], (char **) 0, NULL);\n\t    need_header = false;\n\t    p_strip_trailing_cr = strip_trailing_cr;\n\t  }\n\telse if (strnEQ(s, \"Prereq:\", 7))\n\t  {\n\t    for (t = s + 7;  ISSPACE ((unsigned char) *t);  t++)\n\t      /* do nothing */ ;\n\t    revision = t;\n\t    for (t = revision;  *t;  t++)\n\t      if (ISSPACE ((unsigned char) *t))\n\t\t{\n\t\t  char const *u;\n\t\t  for (u = t + 1;  ISSPACE ((unsigned char) *u);  u++)\n\t\t    /* do nothing */ ;\n\t\t  if (*u)\n\t\t    {\n\t\t      char numbuf[LINENUM_LENGTH_BOUND + 1];\n\t\t      say (\"Prereq: with multiple words at line %s of patch\\n\",\n\t\t\t   format_linenum (numbuf, this_line));\n\t\t    }\n\t\t  break;\n\t\t}\n\t    if (t == revision)\n\t\trevision = 0;\n\t    else {\n\t\tchar oldc = *t;\n\t\t*t = '\\0';\n\t\trevision = xstrdup (revision);\n\t\t*t = oldc;\n\t    }\n\t  }\n\telse if (strnEQ (s, \"diff --git \", 11))\n\t  {\n\t    char const *u;\n\n\t    if (extended_headers)\n\t      {\n\t\tp_start = this_line;\n\t\tp_sline = p_input_line;\n\t\t/* Patch contains no hunks; any diff type will do. */\n\t\tretval = UNI_DIFF;\n\t\tgoto scan_exit;\n\t      }\n\n\t    for (i = OLD; i <= NEW; i++)\n\t      {\n\t\tfree (p_name[i]);\n\t\tp_name[i] = 0;\n\t      }\n\t    if (! ((p_name[OLD] = parse_name (s + 11, strippath, &u))\n\t\t   && ISSPACE ((unsigned char) *u)\n\t\t   && (p_name[NEW] = parse_name (u, strippath, &u))\n\t\t   && (u = skip_spaces (u), ! *u)))\n\t      for (i = OLD; i <= NEW; i++)\n\t\t{\n\t\t  free (p_name[i]);\n\t\t  p_name[i] = 0;\n\t\t}\n\t    p_git_diff = true;\n\t  }\n\telse if (p_git_diff && strnEQ (s, \"index \", 6))\n\t  {\n\t    char const *u, *v;\n\t    if ((u = skip_hex_digits (s + 6))\n\t\t&& u[0] == '.' && u[1] == '.'\n\t\t&& (v = skip_hex_digits (u + 2))\n\t\t&& (! *v || ISSPACE ((unsigned char) *v)))\n\t      {\n\t\tget_sha1(&p_sha1[OLD], s + 6, u);\n\t\tget_sha1(&p_sha1[NEW], u + 2, v);\n\t\tp_says_nonexistent[OLD] = sha1_says_nonexistent (p_sha1[OLD]);\n\t\tp_says_nonexistent[NEW] = sha1_says_nonexistent (p_sha1[NEW]);\n\t\tif (*(v = skip_spaces (v)))\n\t\t  p_mode[OLD] = p_mode[NEW] = fetchmode (v);\n\t\textended_headers = true;\n\t      }\n\t  }\n\telse if (p_git_diff && strnEQ (s, \"old mode \", 9))\n\t  {\n\t    p_mode[OLD] = fetchmode (s + 9);\n\t    extended_headers = true;\n\t  }\n\telse if (p_git_diff && strnEQ (s, \"new mode \", 9))\n\t  {\n\t    p_mode[NEW] = fetchmode (s + 9);\n\t    extended_headers = true;\n\t  }\n\telse if (p_git_diff && strnEQ (s, \"deleted file mode \", 18))\n\t  {\n\t    p_mode[OLD] = fetchmode (s + 18);\n\t    p_says_nonexistent[NEW] = 2;\n\t    extended_headers = true;\n\t  }\n\telse if (p_git_diff && strnEQ (s, \"new file mode \", 14))\n\t  {\n\t    p_mode[NEW] = fetchmode (s + 14);\n\t    p_says_nonexistent[OLD] = 2;\n\t    extended_headers = true;\n\t  }\n\telse if (p_git_diff && strnEQ (s, \"rename from \", 12))\n\t  {\n\t    /* Git leaves out the prefix in the file name in this header,\n\t       so we can only ignore the file name.  */\n\t    p_rename[OLD] = true;\n\t    extended_headers = true;\n\t  }\n\telse if (p_git_diff && strnEQ (s, \"rename to \", 10))\n\t  {\n\t    /* Git leaves out the prefix in the file name in this header,\n\t       so we can only ignore the file name.  */\n\t    p_rename[NEW] = true;\n\t    extended_headers = true;\n\t  }\n\telse if (p_git_diff && strnEQ (s, \"copy from \", 10))\n\t  {\n\t    /* Git leaves out the prefix in the file name in this header,\n\t       so we can only ignore the file name.  */\n\t    p_copy[OLD] = true;\n\t    extended_headers = true;\n\t  }\n\telse if (p_git_diff && strnEQ (s, \"copy to \", 8))\n\t  {\n\t    /* Git leaves out the prefix in the file name in this header,\n\t       so we can only ignore the file name.  */\n\t    p_copy[NEW] = true;\n\t    extended_headers = true;\n\t  }\n\telse if (p_git_diff && strnEQ (s, \"GIT binary patch\", 16))\n\t  {\n\t    p_start = this_line;\n\t    p_sline = p_input_line;\n\t    retval = GIT_BINARY_DIFF;\n\t    goto scan_exit;\n\t  }\n\telse\n\t  {\n\t    for (t = s;  t[0] == '-' && t[1] == ' ';  t += 2)\n\t      /* do nothing */ ;\n\t    if (strnEQ(t, \"--- \", 4))\n\t      {\n\t\tstruct timespec timestamp;\n\t\ttimestamp.tv_sec = -1;\n\t\tfetchname (t+4, strippath, &p_name[NEW], &p_timestr[NEW],\n\t\t\t   &timestamp);\n\t\tneed_header = false;\n\t\tif (timestamp.tv_sec != -1)\n\t\t  {\n\t\t    p_timestamp[NEW] = timestamp;\n\t\t    p_rfc934_nesting = (t - s) >> 1;\n\t\t  }\n\t\tp_strip_trailing_cr = strip_trailing_cr;\n\t      }\n\t  }\n\tif (need_header)\n\t  continue;\n\tif ((diff_type == NO_DIFF || diff_type == ED_DIFF) &&\n\t  first_command_line >= 0 &&\n\t  strEQ(s, \".\\n\") ) {\n\t    p_start = first_command_line;\n\t    p_sline = fcl_line;\n\t    retval = ED_DIFF;\n\t    goto scan_exit;\n\t}\n\tif ((diff_type == NO_DIFF || diff_type == UNI_DIFF)\n\t    && strnEQ(s, \"@@ -\", 4)) {\n\n\t    /* 'p_name', 'p_timestr', and 'p_timestamp' are backwards;\n\t       swap them.  */\n\t    struct timespec ti = p_timestamp[OLD];\n\t    p_timestamp[OLD] = p_timestamp[NEW];\n\t    p_timestamp[NEW] = ti;\n\t    t = p_name[OLD];\n\t    p_name[OLD] = p_name[NEW];\n\t    p_name[NEW] = t;\n\t    t = p_timestr[OLD];\n\t    p_timestr[OLD] = p_timestr[NEW];\n\t    p_timestr[NEW] = t;\n\n\t    s += 4;\n\t    if (s[0] == '0' && !ISDIGIT (s[1]))\n\t      p_says_nonexistent[OLD] = 1 + ! p_timestamp[OLD].tv_sec;\n\t    while (*s != ' ' && *s != '\\n')\n\t      s++;\n\t    while (*s == ' ')\n\t      s++;\n\t    if (s[0] == '+' && s[1] == '0' && !ISDIGIT (s[2]))\n\t      p_says_nonexistent[NEW] = 1 + ! p_timestamp[NEW].tv_sec;\n\t    p_indent = indent;\n\t    p_start = this_line;\n\t    p_sline = p_input_line;\n\t    retval = UNI_DIFF;\n\t    if (! ((p_name[OLD] || ! p_timestamp[OLD].tv_sec)\n\t\t   && (p_name[NEW] || ! p_timestamp[NEW].tv_sec))\n\t\t&& ! p_name[INDEX] && need_header)\n\t      {\n\t\tchar numbuf[LINENUM_LENGTH_BOUND + 1];\n\t\tsay (\"missing header for unified diff at line %s of patch\\n\",\n\t\t     format_linenum (numbuf, p_sline));\n\t      }\n\t    goto scan_exit;\n\t}\n\tstars_this_line = strnEQ(s, \"********\", 8);\n\tif ((diff_type == NO_DIFF\n\t     || diff_type == CONTEXT_DIFF\n\t     || diff_type == NEW_CONTEXT_DIFF)\n\t    && stars_last_line && strnEQ (s, \"*** \", 4)) {\n\t    s += 4;\n\t    if (s[0] == '0' && !ISDIGIT (s[1]))\n\t      p_says_nonexistent[OLD] = 1 + ! p_timestamp[OLD].tv_sec;\n\t    /* if this is a new context diff the character just before */\n\t    /* the newline is a '*'. */\n\t    while (*s != '\\n')\n\t\ts++;\n\t    p_indent = indent;\n\t    p_strip_trailing_cr = strip_trailing_cr;\n\t    p_start = previous_line;\n\t    p_sline = p_input_line - 1;\n\t    retval = (*(s-1) == '*' ? NEW_CONTEXT_DIFF : CONTEXT_DIFF);\n\n\t    {\n\t      /* Scan the first hunk to see whether the file contents\n\t\t appear to have been deleted.  */\n\t      file_offset saved_p_base = p_base;\n\t      lin saved_p_bline = p_bline;\n\t      Fseek (pfp, previous_line, SEEK_SET);\n\t      p_input_line -= 2;\n\t      if (another_hunk (retval, false)\n\t\t  && ! p_repl_lines && p_newfirst == 1)\n\t\tp_says_nonexistent[NEW] = 1 + ! p_timestamp[NEW].tv_sec;\n\t      next_intuit_at (saved_p_base, saved_p_bline);\n\t    }\n\n\t    if (! ((p_name[OLD] || ! p_timestamp[OLD].tv_sec)\n\t\t   && (p_name[NEW] || ! p_timestamp[NEW].tv_sec))\n\t\t&& ! p_name[INDEX] && need_header)\n\t      {\n\t\tchar numbuf[LINENUM_LENGTH_BOUND + 1];\n\t\tsay (\"missing header for context diff at line %s of patch\\n\",\n\t\t     format_linenum (numbuf, p_sline));\n\t      }\n\t    goto scan_exit;\n\t}\n\tif ((diff_type == NO_DIFF || diff_type == NORMAL_DIFF) &&\n\t  last_line_was_command &&\n\t  (strnEQ(s, \"< \", 2) || strnEQ(s, \"> \", 2)) ) {\n\t    p_start = previous_line;\n\t    p_sline = p_input_line - 1;\n\t    p_indent = indent;\n\t    retval = NORMAL_DIFF;\n\t    goto scan_exit;\n\t}\n    }\n\n  scan_exit:\n\n    /* The old, new, or old and new file types may be defined.  When both\n       file types are defined, make sure they are the same, or else assume\n       we do not know the file type.  */\n    file_type = p_mode[OLD] & S_IFMT;\n    if (file_type)\n      {\n\tmode_t new_file_type = p_mode[NEW] & S_IFMT;\n\tif (new_file_type && file_type != new_file_type)\n\t  file_type = 0;\n      }\n    else\n      {\n\tfile_type = p_mode[NEW] & S_IFMT;\n\tif (! file_type)\n\t  file_type = S_IFREG;\n      }\n    *p_file_type = file_type;\n\n    /* To intuit 'inname', the name of the file to patch,\n       use the algorithm specified by POSIX 1003.1-2001 XCU lines 25680-26599\n       (with some modifications if posixly_correct is zero):\n\n       - Take the old and new names from the context header if present,\n\t and take the index name from the 'Index:' line if present and\n\t if either the old and new names are both absent\n\t or posixly_correct is nonzero.\n\t Consider the file names to be in the order (old, new, index).\n       - If some named files exist, use the first one if posixly_correct\n\t is nonzero, the best one otherwise.\n       - If patch_get is nonzero, and no named files exist,\n\t but an RCS or SCCS master file exists,\n\t use the first named file with an RCS or SCCS master.\n       - If no named files exist, no RCS or SCCS master was found,\n\t some names are given, posixly_correct is zero,\n\t and the patch appears to create a file, then use the best name\n\t requiring the creation of the fewest directories.\n       - Otherwise, report failure by setting 'inname' to 0;\n\t this causes our invoker to ask the user for a file name.  */\n\n    i = NONE;\n\n    if (!inname)\n      {\n\tenum nametype i0 = NONE;\n\n\tif (! posixly_correct && (p_name[OLD] || p_name[NEW]) && p_name[INDEX])\n\t  {\n\t    free (p_name[INDEX]);\n\t    p_name[INDEX] = 0;\n\t  }\n\n\tfor (i = OLD;  i <= INDEX;  i++)\n\t  if (p_name[i])\n\t    {\n\t      if (i0 != NONE && strcmp (p_name[i0], p_name[i]) == 0)\n\t\t{\n\t\t  /* It's the same name as before; reuse stat results.  */\n\t\t  stat_errno[i] = stat_errno[i0];\n\t\t  if (! stat_errno[i])\n\t\t    st[i] = st[i0];\n\t\t}\n\t      else\n\t\t{\n\t\t  stat_errno[i] = stat_file (p_name[i], &st[i]);\n\t\t  if (! stat_errno[i])\n\t\t    {\n\t\t      if (lookup_file_id (&st[i]) == DELETE_LATER)\n\t\t\tstat_errno[i] = ENOENT;\n\t\t      else if (posixly_correct && name_is_valid (p_name[i]))\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t      i0 = i;\n\t    }\n\n\tif (! posixly_correct)\n\t  {\n\t    /* The best of all existing files. */\n\t    i = best_name (p_name, stat_errno);\n\n\t    if (i == NONE && patch_get)\n\t      {\n\t\tenum nametype nope = NONE;\n\n\t\tfor (i = OLD;  i <= INDEX;  i++)\n\t\t  if (p_name[i])\n\t\t    {\n\t\t      char const *cs;\n\t\t      char *getbuf;\n\t\t      char *diffbuf;\n\t\t      bool readonly = (outfile\n\t\t\t\t       && strcmp (outfile, p_name[i]) != 0);\n\n\t\t      if (nope == NONE || strcmp (p_name[nope], p_name[i]) != 0)\n\t\t\t{\n\t\t\t  cs = (version_controller\n\t\t\t        (p_name[i], readonly, (struct stat *) 0,\n\t\t\t\t &getbuf, &diffbuf));\n\t\t\t  version_controlled[i] = !! cs;\n\t\t\t  if (cs)\n\t\t\t    {\n\t\t\t      if (version_get (p_name[i], cs, false, readonly,\n\t\t\t\t\t       getbuf, &st[i]))\n\t\t\t\tstat_errno[i] = 0;\n\t\t\t      else\n\t\t\t\tversion_controlled[i] = 0;\n\n\t\t\t      free (getbuf);\n\t\t\t      free (diffbuf);\n\n\t\t\t      if (! stat_errno[i])\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\n\t\t      nope = i;\n\t\t    }\n\t      }\n\n\t    if (i0 != NONE\n\t\t&& (i == NONE || (st[i].st_mode & S_IFMT) == file_type)\n\t\t&& maybe_reverse (p_name[i == NONE ? i0 : i], i == NONE,\n\t\t\t\t  i == NONE || st[i].st_size == 0)\n\t\t&& i == NONE)\n\t      i = i0;\n\n\t    if (i == NONE && p_says_nonexistent[reverse])\n\t      {\n\t\tint newdirs[3];\n\t\tint newdirs_min = INT_MAX;\n\t\tint distance_from_minimum[3];\n\n\t\tfor (i = OLD;  i <= INDEX;  i++)\n\t\t  if (p_name[i])\n\t\t    {\n\t\t      newdirs[i] = (prefix_components (p_name[i], false)\n\t\t\t\t    - prefix_components (p_name[i], true));\n\t\t      if (newdirs[i] < newdirs_min)\n\t\t\tnewdirs_min = newdirs[i];\n\t\t    }\n\n\t\tfor (i = OLD;  i <= INDEX;  i++)\n\t\t  if (p_name[i])\n\t\t    distance_from_minimum[i] = newdirs[i] - newdirs_min;\n\n\t\t/* The best of the filenames which create the fewest directories. */\n\t\ti = best_name (p_name, distance_from_minimum);\n\t      }\n \t  }\n       }\n \n     if (i == NONE)\n       {\n \tif (inname)\n\tinname = xstrdup (p_name[i]);\n\tinerrno = stat_errno[i];\n\tinvc = version_controlled[i];\n\tinstat = st[i];\n      }\n\n    return retval;\n}\n", "target": 1, "idx": 178569}
{"func": "v8::Local<v8::Value> PrivateScriptRunner::runDOMAttributeGetter(ScriptState* scriptState, ScriptState* scriptStateInUserScript, const char* className, const char* attributeName, v8::Local<v8::Value> holder)\n{\n    v8::Isolate* isolate = scriptState->isolate();\n    v8::Local<v8::Object> classObject = classObjectOfPrivateScript(scriptState, className);\n    v8::Local<v8::Value> descriptor;\n    if (!classObject->GetOwnPropertyDescriptor(scriptState->context(), v8String(isolate, attributeName)).ToLocal(&descriptor) || !descriptor->IsObject()) {\n        fprintf(stderr, \"Private script error: Target DOM attribute getter was not found. (Class name = %s, Attribute name = %s)\\n\", className, attributeName);\n        RELEASE_NOTREACHED();\n    }\n    v8::Local<v8::Value> getter;\n    if (!v8::Local<v8::Object>::Cast(descriptor)->Get(scriptState->context(), v8String(isolate, \"get\")).ToLocal(&getter) || !getter->IsFunction()) {\n        fprintf(stderr, \"Private script error: Target DOM attribute getter was not found. (Class name = %s, Attribute name = %s)\\n\", className, attributeName);\n        RELEASE_NOTREACHED();\n    }\n     initializeHolderIfNeeded(scriptState, classObject, holder);\n     v8::TryCatch block(isolate);\n     v8::Local<v8::Value> result;\n    if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(getter), scriptState->getExecutionContext(), holder, 0, 0, isolate).ToLocal(&result)) {\n         rethrowExceptionInPrivateScript(isolate, block, scriptStateInUserScript, ExceptionState::GetterContext, attributeName, className);\n         block.ReThrow();\n         return v8::Local<v8::Value>();\n    }\n    return result;\n}\n", "target": 1, "idx": 185988}
{"func": "check_entry_size_and_hooks(struct ipt_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n \tint err;\n \n \tif ((unsigned long)e % __alignof__(struct ipt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ipt_entry) >= limit) {\n \t\tduprintf(\"Bad offset %p\\n\", e);\n \t\treturn -EINVAL;\n \t}\n\n\tif (e->next_offset\n\t    < sizeof(struct ipt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_err(\"Underflows must be unconditional and \"\n\t\t\t\t       \"use the STANDARD target with \"\n\t\t\t\t       \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}\n", "target": 1, "idx": 180384}
{"func": "long Track::GetType() const\n{\n    return m_info.type;\n}\n", "target": 1, "idx": 188397}
{"func": "const Cues* Segment::GetCues() const\n{\n    return m_pCues;\n}\n", "target": 1, "idx": 188323}
{"func": "WebContents* DevToolsWindow::OpenURLFromTab(\n    WebContents* source,\n    const content::OpenURLParams& params) {\n   DCHECK(source == main_web_contents_);\n   if (!params.url.SchemeIs(content::kChromeDevToolsScheme)) {\n     WebContents* inspected_web_contents = GetInspectedWebContents();\n    return inspected_web_contents ?\n        inspected_web_contents->OpenURL(params) : NULL;\n   }\n   bindings_->Reload();\n   return main_web_contents_;\n}\n", "target": 1, "idx": 186937}
{"func": "void TabStrip::RemoveTabFromViewModel(int index) {\n  tabs_closing_map_[index].push_back(tab_at(index));\n  UpdateTabsClosingMap(index + 1, -1);\n  tabs_.Remove(index);\n}\n", "target": 0, "idx": 134410}
{"func": "string16 ExtensionInstallUI::Prompt::GetDialogTitle(\n    const Extension* extension) const {\n  if (type_ == INSTALL_PROMPT) {\n     return l10n_util::GetStringUTF16(extension->is_app() ?\n         IDS_EXTENSION_INSTALL_APP_PROMPT_TITLE :\n         IDS_EXTENSION_INSTALL_EXTENSION_PROMPT_TITLE);\n  } else if (type_ == INLINE_INSTALL_PROMPT) {\n    return l10n_util::GetStringFUTF16(\n      kTitleIds[type_], l10n_util::GetStringUTF16(IDS_SHORT_PRODUCT_NAME));\n   } else {\n     return l10n_util::GetStringUTF16(kTitleIds[type_]);\n   }\n}\n", "target": 1, "idx": 184673}
{"func": "ProcRenderAddGlyphs (ClientPtr client)\n{\n    GlyphSetPtr     glyphSet;\n    REQUEST(xRenderAddGlyphsReq);\n    GlyphNewRec\t    glyphsLocal[NLOCALGLYPH];\n    GlyphNewPtr\t    glyphsBase, glyphs, glyph_new;\n    int\t\t    remain, nglyphs;\n    CARD32\t    *gids;\n    xGlyphInfo\t    *gi;\n    CARD8\t    *bits;\n    unsigned int    size;\n    int\t\t    err;\n    int\t\t    i, screen;\n    PicturePtr\t    pSrc = NULL, pDst = NULL;\n    PixmapPtr\t    pSrcPix = NULL, pDstPix = NULL;\n    CARD32\t    component_alpha;\n\n    REQUEST_AT_LEAST_SIZE(xRenderAddGlyphsReq);\n    err = dixLookupResourceByType((pointer *)&glyphSet, stuff->glyphset, GlyphSetType,\n\t\t\t    client, DixAddAccess);\n    if (err != Success)\n    {\n\tclient->errorValue = stuff->glyphset;\n\treturn err;\n    }\n\n    err = BadAlloc;\n    nglyphs = stuff->nglyphs;\n    if (nglyphs > UINT32_MAX / sizeof(GlyphNewRec))\n\t    return BadAlloc;\n\n    component_alpha = NeedsComponent (glyphSet->format->format);\n\n    if (nglyphs <= NLOCALGLYPH) {\n\tmemset (glyphsLocal, 0, sizeof (glyphsLocal));\n\tglyphsBase = glyphsLocal;\n    }\n    else\n    {\n\tglyphsBase = (GlyphNewPtr)calloc(nglyphs, sizeof (GlyphNewRec));\n\tif (!glyphsBase)\n\t    return BadAlloc;\n    }\n\n    remain = (client->req_len << 2) - sizeof (xRenderAddGlyphsReq);\n\n    glyphs = glyphsBase;\n\n    gids = (CARD32 *) (stuff + 1);\n     gi = (xGlyphInfo *) (gids + nglyphs);\n     bits = (CARD8 *) (gi + nglyphs);\n     remain -= (sizeof (CARD32) + sizeof (xGlyphInfo)) * nglyphs;\n     for (i = 0; i < nglyphs; i++)\n     {\n \tsize_t padded_width;\n\tsize = gi[i].height * padded_width;\n\tif (remain < size)\n\t    break;\n\n\terr = HashGlyph (&gi[i], bits, size, glyph_new->sha1);\n\tif (err)\n\t    goto bail;\n\n\tglyph_new->glyph = FindGlyphByHash (glyph_new->sha1,\n\t\t\t\t\t    glyphSet->fdepth);\n\n\tif (glyph_new->glyph && glyph_new->glyph != DeletedGlyph)\n\t{\n\t    glyph_new->found = TRUE;\n\t}\n\telse\n\t{\n\t    GlyphPtr glyph;\n\n\t    glyph_new->found = FALSE;\n\t    glyph_new->glyph = glyph = AllocateGlyph (&gi[i], glyphSet->fdepth);\n\t    if (! glyph)\n\t    {\n\t\terr = BadAlloc;\n\t\tgoto bail;\n\t    }\n\n\t    for (screen = 0; screen < screenInfo.numScreens; screen++)\n\t    {\n\t\tint\t    width = gi[i].width;\n\t\tint\t    height = gi[i].height;\n\t\tint\t    depth = glyphSet->format->depth;\n\t\tScreenPtr   pScreen;\n\t\tint\t    error;\n\n\t\t/* Skip work if it's invisibly small anyway */\n\t\tif (!width || !height)\n\t\t    break;\n\n\t\tpScreen = screenInfo.screens[screen];\n\t\tpSrcPix = GetScratchPixmapHeader (pScreen,\n\t\t\t\t\t\t  width, height,\n\t\t\t\t\t\t  depth, depth,\n\t\t\t\t\t\t  -1, bits);\n\t\tif (! pSrcPix)\n\t\t{\n\t\t    err = BadAlloc;\n\t\t    goto bail;\n\t\t}\n\n\t\tpSrc = CreatePicture (0, &pSrcPix->drawable,\n\t\t\t\t      glyphSet->format, 0, NULL,\n\t\t\t\t      serverClient, &error);\n\t\tif (! pSrc)\n\t\t{\n\t\t    err = BadAlloc;\n\t\t    goto bail;\n\t\t}\n\n\t\tpDstPix = (pScreen->CreatePixmap) (pScreen,\n\t\t\t\t\t\t   width, height, depth,\n\t\t\t\t\t\t   CREATE_PIXMAP_USAGE_GLYPH_PICTURE);\n\n\t\tif (!pDstPix)\n\t\t{\n\t\t    err = BadAlloc;\n\t\t    goto bail;\n\t\t}\n\n\t\tGlyphPicture (glyph)[screen] = pDst =\n\t\t\tCreatePicture (0, &pDstPix->drawable,\n\t\t\t\t       glyphSet->format,\n\t\t\t\t       CPComponentAlpha, &component_alpha,\n\t\t\t\t       serverClient, &error);\n\n\t\t/* The picture takes a reference to the pixmap, so we\n\t\t   drop ours. */\n\t\t(pScreen->DestroyPixmap) (pDstPix);\n\t\tpDstPix = NULL;\n\n\t\tif (! pDst)\n\t\t{\n\t\t    err = BadAlloc;\n\t\t    goto bail;\n\t\t}\n\n\t\tCompositePicture (PictOpSrc,\n\t\t\t\t  pSrc,\n\t\t\t\t  None,\n\t\t\t\t  pDst,\n\t\t\t\t  0, 0,\n\t\t\t\t  0, 0,\n\t\t\t\t  0, 0,\n\t\t\t\t  width, height);\n\n\t\tFreePicture ((pointer) pSrc, 0);\n\t\tpSrc = NULL;\n\t\tFreeScratchPixmapHeader (pSrcPix);\n\t\tpSrcPix = NULL;\n\t    }\n\n\t    memcpy (glyph_new->glyph->sha1, glyph_new->sha1, 20);\n\t}\n\n\tglyph_new->id = gids[i];\n\t\n\tif (size & 3)\n\t    size += 4 - (size & 3);\n\tbits += size;\n\tremain -= size;\n    }\n    if (remain || i < nglyphs)\n    {\n\terr = BadLength;\n\tgoto bail;\n    }\n    if (!ResizeGlyphSet (glyphSet, nglyphs))\n    {\n\terr = BadAlloc;\n\tgoto bail;\n    }\n    for (i = 0; i < nglyphs; i++)\n\tAddGlyph (glyphSet, glyphs[i].glyph, glyphs[i].id);\n\n    if (glyphsBase != glyphsLocal)\n\tfree(glyphsBase);\n    return Success;\nbail:\n    if (pSrc)\n\tFreePicture ((pointer) pSrc, 0);\n    if (pSrcPix)\n\tFreeScratchPixmapHeader (pSrcPix);\n    for (i = 0; i < nglyphs; i++)\n\tif (glyphs[i].glyph && ! glyphs[i].found)\n\t    free(glyphs[i].glyph);\n    if (glyphsBase != glyphsLocal)\n\tfree(glyphsBase);\n    return err;\n}\n", "target": 1, "idx": 178440}
{"func": "InRegionScrollableArea::InRegionScrollableArea(WebPagePrivate* webPage, RenderLayer* layer)\n    : m_webPage(webPage)\n    , m_layer(layer)\n{\n    ASSERT(webPage);\n    ASSERT(layer);\n    m_isNull = false;\n\n\n    RenderObject* layerRenderer = layer->renderer();\n    ASSERT(layerRenderer);\n\n    if (layerRenderer->isRenderView()) { // #document case\n\n        FrameView* view = toRenderView(layerRenderer)->frameView();\n        ASSERT(view);\n\n        Frame* frame = view->frame();\n        ASSERT_UNUSED(frame, frame);\n\n        m_scrollPosition = m_webPage->mapToTransformed(view->scrollPosition());\n        m_contentsSize = m_webPage->mapToTransformed(view->contentsSize());\n        m_viewportSize = m_webPage->mapToTransformed(view->visibleContentRect(false /*includeScrollbars*/)).size();\n\n        m_visibleWindowRect = m_webPage->mapToTransformed(m_webPage->getRecursiveVisibleWindowRect(view));\n        IntRect transformedWindowRect = IntRect(IntPoint::zero(), m_webPage->transformedViewportSize());\n        m_visibleWindowRect.intersect(transformedWindowRect);\n\n         m_scrollsHorizontally = view->contentsWidth() > view->visibleWidth();\n         m_scrollsVertically = view->contentsHeight() > view->visibleHeight();\n \n        m_minimumScrollPosition = m_webPage->mapToTransformed(calculateMinimumScrollPosition(\n            view->visibleContentRect().size(),\n            0.0 /*overscrollLimit*/));\n        m_maximumScrollPosition = m_webPage->mapToTransformed(calculateMaximumScrollPosition(\n            view->visibleContentRect().size(),\n            view->contentsSize(),\n            0.0 /*overscrollLimit*/));\n     } else { // RenderBox-based elements case (scrollable boxes (div's, p's, textarea's, etc)).\n \n         RenderBox* box = m_layer->renderBox();\n        ASSERT(box);\n        ASSERT(box->canBeScrolledAndHasScrollableArea());\n\n        ScrollableArea* scrollableArea = static_cast<ScrollableArea*>(m_layer);\n        m_scrollPosition = m_webPage->mapToTransformed(scrollableArea->scrollPosition());\n        m_contentsSize = m_webPage->mapToTransformed(scrollableArea->contentsSize());\n        m_viewportSize = m_webPage->mapToTransformed(scrollableArea->visibleContentRect(false /*includeScrollbars*/)).size();\n\n        m_visibleWindowRect = m_layer->renderer()->absoluteClippedOverflowRect();\n        m_visibleWindowRect = m_layer->renderer()->frame()->view()->contentsToWindow(m_visibleWindowRect);\n        IntRect visibleFrameWindowRect = m_webPage->getRecursiveVisibleWindowRect(m_layer->renderer()->frame()->view());\n        m_visibleWindowRect.intersect(visibleFrameWindowRect);\n        m_visibleWindowRect = m_webPage->mapToTransformed(m_visibleWindowRect);\n        IntRect transformedWindowRect = IntRect(IntPoint::zero(), m_webPage->transformedViewportSize());\n        m_visibleWindowRect.intersect(transformedWindowRect);\n\n         m_scrollsHorizontally = box->scrollWidth() != box->clientWidth() && box->scrollsOverflowX();\n         m_scrollsVertically = box->scrollHeight() != box->clientHeight() && box->scrollsOverflowY();\n \n        m_minimumScrollPosition = m_webPage->mapToTransformed(calculateMinimumScrollPosition(\n            Platform::IntSize(box->clientWidth(), box->clientHeight()),\n            0.0 /*overscrollLimit*/));\n        m_maximumScrollPosition = m_webPage->mapToTransformed(calculateMaximumScrollPosition(\n            Platform::IntSize(box->clientWidth(), box->clientHeight()),\n            Platform::IntSize(box->scrollWidth(), box->scrollHeight()),\n            0.0 /*overscrollLimit*/));\n     }\n }\n", "target": 1, "idx": 183888}
{"func": "void EditorClientBlackBerry::textDidChangeInTextField(Element* element)\n{\n    if (m_webPagePrivate->m_webSettings->isFormAutofillEnabled()) {\n        if (HTMLInputElement* inputElement = element->toInputElement())\n            m_webPagePrivate->m_autofillManager->didChangeInTextField(inputElement);\n    }\n}\n", "target": 0, "idx": 111727}
{"func": "static void perf_sample_regs_user(struct perf_regs *regs_user,\n\t\t\t\t  struct pt_regs *regs,\n\t\t\t\t  struct pt_regs *regs_user_copy)\n{\n\tif (user_mode(regs)) {\n\t\tregs_user->abi = perf_reg_abi(current);\n\t\tregs_user->regs = regs;\n\t} else if (current->mm) {\n\t\tperf_get_regs_user(regs_user, regs, regs_user_copy);\n\t} else {\n\t\tregs_user->abi = PERF_SAMPLE_REGS_ABI_NONE;\n\t\tregs_user->regs = NULL;\n\t}\n}\n", "target": 0, "idx": 50519}
{"func": "VP8XChunk::VP8XChunk(Container* parent)\n  : Chunk(parent, kChunk_VP8X)\n{\n    this->needsRewrite = true;\n    this->size = 10;\n    this->data.resize(this->size);\n     this->data.assign(this->size, 0);\n     XMP_Uns8* bitstream =\n         (XMP_Uns8*)parent->chunks[WEBP_CHUNK_IMAGE][0]->data.data();\n    XMP_Uns32 width = ((bitstream[7] << 8) | bitstream[6]) & 0x3fff;\n    XMP_Uns32 height = ((bitstream[9] << 8) | bitstream[8]) & 0x3fff;\n     this->width(width);\n     this->height(height);\n     parent->vp8x = this;\nVP8XChunk::VP8XChunk(Container* parent, WEBP_MetaHandler* handler)\n  : Chunk(parent, handler)\n{\n    this->size = 10;\n    this->needsRewrite = true;\n    parent->vp8x = this;\n}\n\nXMP_Uns32 VP8XChunk::width()\n{\n    return GetLE24(&this->data[4]) + 1;\n}\nvoid VP8XChunk::width(XMP_Uns32 val)\n{\n    PutLE24(&this->data[4], val > 0 ? val - 1 : 0);\n}\nXMP_Uns32 VP8XChunk::height()\n{\n    return GetLE24(&this->data[7]) + 1;\n}\nvoid VP8XChunk::height(XMP_Uns32 val)\n{\n    PutLE24(&this->data[7], val > 0 ? val - 1 : 0);\n}\nbool VP8XChunk::xmp()\n{\n    XMP_Uns32 flags = GetLE32(&this->data[0]);\n    return (bool)((flags >> XMP_FLAG_BIT) & 1);\n}\nvoid VP8XChunk::xmp(bool hasXMP)\n{\n    XMP_Uns32 flags = GetLE32(&this->data[0]);\n    flags ^= (-hasXMP ^ flags) & (1 << XMP_FLAG_BIT);\n    PutLE32(&this->data[0], flags);\n}\n\nContainer::Container(WEBP_MetaHandler* handler) : Chunk(NULL, handler)\n{\n    this->needsRewrite = false;\n\n    XMP_IO* file = handler->parent->ioRef;\n\n    file->Seek(12, kXMP_SeekFromStart);\n\n    XMP_Int64 size = handler->initialFileSize;\n\n    XMP_Uns32 peek = 0;\n\n    while (file->Offset() < size) {\n        peek = XIO::PeekUns32_LE(file);\n        switch (peek) {\n        case kChunk_XMP_:\n            this->addChunk(new XMPChunk(this, handler));\n            break;\n        case kChunk_VP8X:\n            this->addChunk(new VP8XChunk(this, handler));\n            break;\n        default:\n            this->addChunk(new Chunk(this, handler));\n            break;\n        }\n    }\n\n    if (this->chunks[WEBP_CHUNK_IMAGE].size() == 0) {\n        XMP_Throw(\"File has no image bitstream\", kXMPErr_BadFileFormat);\n    }\n\n    if (this->chunks[WEBP_CHUNK_VP8X].size() == 0) {\n        this->needsRewrite = true;\n        this->addChunk(new VP8XChunk(this));\n    }\n\n    if (this->chunks[WEBP_CHUNK_XMP].size() == 0) {\n        XMPChunk* xmpChunk = new XMPChunk(this);\n        this->addChunk(xmpChunk);\n        handler->xmpChunk = xmpChunk;\n        this->vp8x->xmp(true);\n    }\n}\n\nChunk* Container::getExifChunk()\n{\n    if (this->chunks[WEBP::WEBP_CHUNK_EXIF].size() == 0) {\n        return NULL;\n    }\n    return this->chunks[WEBP::WEBP_CHUNK_EXIF][0];\n}\n\nvoid Container::addChunk(Chunk* chunk)\n{\n    ChunkId idx;\n\n    try {\n        idx = chunkMap.at(chunk->tag);\n    }\n    catch (const std::out_of_range& e) {\n        idx = WEBP_CHUNK_UNKNOWN;\n    }\n    this->chunks[idx].push_back(chunk);\n}\n\nvoid Container::write(WEBP_MetaHandler* handler)\n{\n    XMP_IO* file = handler->parent->ioRef;\n    file->Rewind();\n    XIO::WriteUns32_LE(file, this->tag);\n    XIO::WriteUns32_LE(file, (XMP_Uns32) this->size);\n    XIO::WriteUns32_LE(file, kChunk_WEBP);\n\n    size_t i, j;\n    std::vector<Chunk*> chunkVect;\n    for (i = 0; i < WEBP_CHUNK_NIL; i++) {\n        chunkVect = this->chunks[i];\n        for (j = 0; j < chunkVect.size(); j++) {\n            chunkVect.at(j)->write(handler);\n        }\n    }\n    XMP_Int64 lastOffset = file->Offset();\n    this->size = lastOffset - 8;\n    file->Seek(this->pos + 4, kXMP_SeekFromStart);\n    XIO::WriteUns32_LE(file, (XMP_Uns32) this->size);\n    file->Seek(lastOffset, kXMP_SeekFromStart);\n    if (lastOffset < handler->initialFileSize) {\n        file->Truncate(lastOffset);\n    }\n}\n\nContainer::~Container()\n{\n    Chunk* chunk;\n    size_t i;\n    std::vector<Chunk*> chunkVect;\n    for (i = 0; i < WEBP_CHUNK_NIL; i++) {\n        chunkVect = this->chunks[i];\n        while (!chunkVect.empty()) {\n            chunk = chunkVect.back();\n            delete chunk;\n            chunkVect.pop_back();\n        }\n    }\n}\n}\n", "target": 1, "idx": 178165}
{"func": "static void check_mm(struct mm_struct *mm)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_MM_COUNTERS; i++) {\n\t\tlong x = atomic_long_read(&mm->rss_stat.count[i]);\n\n\t\tif (unlikely(x))\n\t\t\tprintk(KERN_ALERT \"BUG: Bad rss-counter state \"\n\t\t\t\t\t  \"mm:%p idx:%d val:%ld\\n\", mm, i, x);\n\t}\n\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tVM_BUG_ON(mm->pmd_huge_pte);\n#endif\n}\n", "target": 0, "idx": 32865}
{"func": "void GLES2DecoderImpl::DoBindTexImage2DCHROMIUM(\n    GLenum target, GLint image_id) {\n  TRACE_EVENT0(\"gpu\", \"GLES2DecoderImpl::DoBindTexImage2DCHROMIUM\");\n\n  BindTexImage2DCHROMIUMImpl(\"glBindTexImage2DCHROMIUM\", target, 0, image_id);\n}\n", "target": 0, "idx": 153958}
{"func": "vbf_stp_error(struct worker *wrk, struct busyobj *bo)\n{\n\tssize_t l, ll, o;\n\tdouble now;\n\tuint8_t *ptr;\n\tstruct vsb *synth_body;\n\n\tCHECK_OBJ_NOTNULL(wrk, WORKER_MAGIC);\n\tCHECK_OBJ_NOTNULL(bo, BUSYOBJ_MAGIC);\n\tCHECK_OBJ_NOTNULL(bo->fetch_objcore, OBJCORE_MAGIC);\n\tAN(bo->fetch_objcore->flags & OC_F_BUSY);\n\tassert(bo->director_state == DIR_S_NULL);\n\n\twrk->stats->fetch_failed++;\n\n\tnow = W_TIM_real(wrk);\n\tVSLb_ts_busyobj(bo, \"Error\", now);\n\n\tif (bo->fetch_objcore->stobj->stevedore != NULL)\n\t\tObjFreeObj(bo->wrk, bo->fetch_objcore);\n\n\n\tHTTP_Setup(bo->beresp, bo->ws, bo->vsl, SLT_BerespMethod);\n\thttp_PutResponse(bo->beresp, \"HTTP/1.1\", 503, \"Backend fetch failed\");\n\thttp_TimeHeader(bo->beresp, \"Date: \", now);\n\thttp_SetHeader(bo->beresp, \"Server: Varnish\");\n\n\tbo->fetch_objcore->t_origin = now;\n\tif (!VTAILQ_EMPTY(&bo->fetch_objcore->objhead->waitinglist)) {\n\t\t/*\n\t\t * If there is a waitinglist, it means that there is no\n\t\t * grace-able object, so cache the error return for a\n\t\t * short time, so the waiting list can drain, rather than\n\t\t * each objcore on the waiting list sequentially attempt\n\t\t * to fetch from the backend.\n\t\t */\n\t\tbo->fetch_objcore->ttl = 1;\n\t\tbo->fetch_objcore->grace = 5;\n\t\tbo->fetch_objcore->keep = 5;\n\t} else {\n\t\tbo->fetch_objcore->ttl = 0;\n\t\tbo->fetch_objcore->grace = 0;\n\t\tbo->fetch_objcore->keep = 0;\n\t}\n\n\tsynth_body = VSB_new_auto();\n\tAN(synth_body);\n\n\tVCL_backend_error_method(bo->vcl, wrk, NULL, bo, synth_body);\n\n\tAZ(VSB_finish(synth_body));\n\n\tif (wrk->handling == VCL_RET_ABANDON || wrk->handling == VCL_RET_FAIL) {\n\t\tVSB_destroy(&synth_body);\n\t\treturn (F_STP_FAIL);\n\t}\n\n\tif (wrk->handling == VCL_RET_RETRY) {\n\t\tVSB_destroy(&synth_body);\n\t\tif (bo->retries++ < cache_param->max_retries)\n\t\t\treturn (F_STP_RETRY);\n\t\tVSLb(bo->vsl, SLT_VCL_Error, \"Too many retries, failing\");\n\t\treturn (F_STP_FAIL);\n\t}\n\n\tassert(wrk->handling == VCL_RET_DELIVER);\n\n\tbo->vfc->bo = bo;\n\tbo->vfc->wrk = bo->wrk;\n\tbo->vfc->oc = bo->fetch_objcore;\n\tbo->vfc->http = bo->beresp;\n\tbo->vfc->esi_req = bo->bereq;\n\n\tif (vbf_beresp2obj(bo)) {\n\t\t(void)VFP_Error(bo->vfc, \"Could not get storage\");\n\t\tVSB_destroy(&synth_body);\n\t\treturn (F_STP_FAIL);\n\t}\n\n\tll = VSB_len(synth_body);\n\to = 0;\n\twhile (ll > 0) {\n \t\tl = ll;\n \t\tif (VFP_GetStorage(bo->vfc, &l, &ptr) != VFP_OK)\n \t\t\tbreak;\n \t\tmemcpy(ptr, VSB_data(synth_body) + o, l);\n \t\tVFP_Extend(bo->vfc, l);\n \t\tll -= l;\n\t\to += l;\n\t}\n\tAZ(ObjSetU64(wrk, bo->fetch_objcore, OA_LEN, o));\n\tVSB_destroy(&synth_body);\n\tHSH_Unbusy(wrk, bo->fetch_objcore);\n\tObjSetState(wrk, bo->fetch_objcore, BOS_FINISHED);\n\treturn (F_STP_DONE);\n}\n", "target": 1, "idx": 181365}
{"func": "bool WebGLRenderingContextBase::ValidateDrawElements(const char* function_name,\n                                                     GLenum type,\n                                                     int64_t offset) {\n  if (isContextLost())\n    return false;\n\n  if (type == GL_UNSIGNED_INT && !IsWebGL2OrHigher() &&\n      !ExtensionEnabled(kOESElementIndexUintName)) {\n    SynthesizeGLError(GL_INVALID_ENUM, function_name, \"invalid type\");\n    return false;\n  }\n\n  if (!ValidateValueFitNonNegInt32(function_name, \"offset\", offset))\n    return false;\n\n  if (!ValidateRenderingState(function_name)) {\n    return false;\n  }\n\n  const char* reason = \"framebuffer incomplete\";\n  if (framebuffer_binding_ && framebuffer_binding_->CheckDepthStencilStatus(\n                                  &reason) != GL_FRAMEBUFFER_COMPLETE) {\n    SynthesizeGLError(GL_INVALID_FRAMEBUFFER_OPERATION, function_name, reason);\n    return false;\n  }\n\n  return true;\n}\n", "target": 0, "idx": 154995}
{"func": "static void nfs4_open_release(void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\tstruct nfs4_state *state = NULL;\n\n\t/* If this request hasn't been cancelled, do nothing */\n\tif (data->cancelled == 0)\n\t\tgoto out_free;\n\t/* In case of error, no cleanup! */\n\tif (data->rpc_status != 0 || !data->rpc_done)\n\t\tgoto out_free;\n\t/* In case we need an open_confirm, no cleanup! */\n\tif (data->o_res.rflags & NFS4_OPEN_RESULT_CONFIRM)\n \t\tgoto out_free;\n \tstate = nfs4_opendata_to_nfs4_state(data);\n \tif (!IS_ERR(state))\n\t\tnfs4_close_state(&data->path, state, data->o_arg.open_flags);\n out_free:\n \tnfs4_opendata_put(data);\n }\n", "target": 1, "idx": 178870}
{"func": " static void scsi_free_request(SCSIRequest *req)\n {\n     SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n \n    qemu_vfree(r->iov.iov_base);\n }\n", "target": 1, "idx": 179725}
{"func": "v8::Handle<v8::Value> V8TestSerializedScriptValueInterface::constructorCallback(const v8::Arguments& args)\n{\n    INC_STATS(\"DOM.TestSerializedScriptValueInterface.Constructor\");\n\n    if (!args.IsConstructCall())\n        return V8Proxy::throwTypeError(\"DOM object constructor cannot be called as a function.\");\n\n     if (ConstructorMode::current() == ConstructorMode::WrapExistingObject)\n         return args.Holder();\n     if (args.Length() < 2)\n        return V8Proxy::throwNotEnoughArgumentsError();\n     STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, hello, MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined));\n     MessagePortArray messagePortArrayTransferList;\n     ArrayBufferArray arrayBufferArrayTransferList;\n    if (args.Length() > 2) {\n        if (!extractTransferables(args[2], messagePortArrayTransferList, arrayBufferArrayTransferList))\n            return V8Proxy::throwTypeError(\"Could not extract transferables\");\n    }\n    bool dataDidThrow = false;\n    RefPtr<SerializedScriptValue> data = SerializedScriptValue::create(args[1], &messagePortArrayTransferList, &arrayBufferArrayTransferList, dataDidThrow, args.GetIsolate());\n    if (dataDidThrow)\n        return v8::Undefined();\n\n    RefPtr<TestSerializedScriptValueInterface> impl = TestSerializedScriptValueInterface::create(hello, data, messagePortArrayTransferList);\n    v8::Handle<v8::Object> wrapper = args.Holder();\n\n    V8DOMWrapper::setDOMWrapper(wrapper, &info, impl.get());\n    V8DOMWrapper::setJSWrapperForDOMObject(impl.release(), v8::Persistent<v8::Object>::New(wrapper), args.GetIsolate());\n    return args.Holder();\n}\n", "target": 1, "idx": 184800}
{"func": "int pseudo_get_buffer_info( int *bytes_out, int *block_size_out, int *prefetch_bytes_out )\n{\n\tint bytes=0, block_size=0;\n\n\tShadow->getJobAd()->LookupInteger(ATTR_BUFFER_SIZE,bytes);\n\tShadow->getJobAd()->LookupInteger(ATTR_BUFFER_BLOCK_SIZE,block_size);\n\n\tif( bytes<0 ) bytes = 0;\n\tif( block_size<0 ) block_size = 0;\n\tif( bytes<block_size ) block_size = bytes;\n\n\t*bytes_out = bytes;\n\t*block_size_out = block_size;\n\t*prefetch_bytes_out = 0;\n\n\tdprintf(D_SYSCALLS,\"\\tbuffer configuration is bytes=%d block_size=%d\\n\",bytes, block_size );\n\n\treturn 0;\n}\n", "target": 0, "idx": 16365}
{"func": "void V8TestObject::VoidMethodTestInterfaceEmptyArgVariadicTestInterfaceEmptyArgMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), \"Blink_TestObject_voidMethodTestInterfaceEmptyArgVariadicTestInterfaceEmptyArg\");\n\n  test_object_v8_internal::VoidMethodTestInterfaceEmptyArgVariadicTestInterfaceEmptyArgMethod(info);\n}\n", "target": 0, "idx": 148172}
{"func": "ScriptPromise BluetoothRemoteGATTService::getCharacteristicsImpl(\n    ScriptState* scriptState,\n    mojom::blink::WebBluetoothGATTQueryQuantity quantity,\n    const String& characteristicsUUID) {\n  if (!device()->gatt()->connected()) {\n    return ScriptPromise::rejectWithDOMException(\n        scriptState,\n        DOMException::create(NetworkError, kGATTServerNotConnected));\n  }\n\n  if (!device()->isValidService(m_service->instance_id)) {\n    return ScriptPromise::rejectWithDOMException(\n        scriptState, DOMException::create(InvalidStateError, kInvalidService));\n  }\n\n  ScriptPromiseResolver* resolver = ScriptPromiseResolver::create(scriptState);\n  ScriptPromise promise = resolver->promise();\n   device()->gatt()->AddToActiveAlgorithms(resolver);\n \n   mojom::blink::WebBluetoothService* service = m_device->bluetooth()->service();\n  WTF::Optional<String> uuid = WTF::nullopt;\n  if (!characteristicsUUID.isEmpty())\n    uuid = characteristicsUUID;\n   service->RemoteServiceGetCharacteristics(\n      m_service->instance_id, quantity, uuid,\n       convertToBaseCallback(\n           WTF::bind(&BluetoothRemoteGATTService::GetCharacteristicsCallback,\n                     wrapPersistent(this), m_service->instance_id, quantity,\n                    wrapPersistent(resolver))));\n\n  return promise;\n}\n", "target": 1, "idx": 185932}
{"func": "bool IDNToUnicodeOneComponent(const char16* comp,\n                              size_t comp_len,\n                              const std::string& languages,\n                              string16* out) {\n  DCHECK(out);\n  if (comp_len == 0)\n    return false;\n\n  static const char16 kIdnPrefix[] = {'x', 'n', '-', '-'};\n  if ((comp_len > arraysize(kIdnPrefix)) &&\n      !memcmp(comp, kIdnPrefix, arraysize(kIdnPrefix) * sizeof(char16))) {\n    size_t original_length = out->length();\n    for (int extra_space = 64; ; extra_space *= 2) {\n      UErrorCode status = U_ZERO_ERROR;\n      out->resize(out->length() + extra_space);\n      int output_chars = uidna_IDNToUnicode(comp,\n          static_cast<int32_t>(comp_len), &(*out)[original_length], extra_space,\n          UIDNA_DEFAULT, NULL, &status);\n      if (status == U_ZERO_ERROR) {\n        out->resize(original_length + output_chars);\n        if (IsIDNComponentSafe(out->data() + original_length, output_chars,\n                               languages))\n          return true;\n      }\n\n      if (status != U_BUFFER_OVERFLOW_ERROR)\n        break;\n    }\n    out->resize(original_length);\n  }\n\n  out->append(comp, comp_len);\n  return false;\n}\n", "target": 0, "idx": 102416}
{"func": "static void perf_event_enable_on_exec(int ctxn)\n{\n\tstruct perf_event_context *ctx, *clone_ctx = NULL;\n\tstruct perf_cpu_context *cpuctx;\n\tstruct perf_event *event;\n\tunsigned long flags;\n\tint enabled = 0;\n\n\tlocal_irq_save(flags);\n\tctx = current->perf_event_ctxp[ctxn];\n\tif (!ctx || !ctx->nr_events)\n\t\tgoto out;\n\n\tcpuctx = __get_cpu_context(ctx);\n\tperf_ctx_lock(cpuctx, ctx);\n\tctx_sched_out(ctx, cpuctx, EVENT_TIME);\n\tlist_for_each_entry(event, &ctx->event_list, event_entry)\n\t\tenabled |= event_enable_on_exec(event, ctx);\n\n\t/*\n\t * Unclone and reschedule this context if we enabled any event.\n\t */\n\tif (enabled) {\n\t\tclone_ctx = unclone_ctx(ctx);\n\t\tctx_resched(cpuctx, ctx);\n\t}\n\tperf_ctx_unlock(cpuctx, ctx);\n\nout:\n\tlocal_irq_restore(flags);\n\n\tif (clone_ctx)\n\t\tput_ctx(clone_ctx);\n}\n", "target": 0, "idx": 68355}
{"func": "void AwContents::UpdateScrollState(gfx::Vector2d max_scroll_offset,\n                                   gfx::SizeF contents_size_dip,\n                                    float page_scale_factor,\n                                    float min_page_scale_factor,\n                                    float max_page_scale_factor) {\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n  JNIEnv* env = AttachCurrentThread();\n  ScopedJavaLocalRef<jobject> obj = java_ref_.get(env);\n  if (obj.is_null())\n    return;\n  Java_AwContents_updateScrollState(env,\n                                    obj.obj(),\n                                    max_scroll_offset.x(),\n                                    max_scroll_offset.y(),\n                                    contents_size_dip.width(),\n                                    contents_size_dip.height(),\n                                    page_scale_factor,\n                                    min_page_scale_factor,\n                                     max_page_scale_factor);\n }\n", "target": 1, "idx": 185321}
{"func": "static int create_fixed_stream_quirk(struct snd_usb_audio *chip,\n\t\t\t\t     struct usb_interface *iface,\n\t\t\t\t     struct usb_driver *driver,\n\t\t\t\t     const struct snd_usb_audio_quirk *quirk)\n{\n\tstruct audioformat *fp;\n\tstruct usb_host_interface *alts;\n\tstruct usb_interface_descriptor *altsd;\n\tint stream, err;\n\tunsigned *rate_table = NULL;\n\n\tfp = kmemdup(quirk->data, sizeof(*fp), GFP_KERNEL);\n\tif (!fp) {\n\t\tusb_audio_err(chip, \"cannot memdup\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tif (fp->nr_rates > MAX_NR_RATES) {\n\t\tkfree(fp);\n\t\treturn -EINVAL;\n\t}\n\tif (fp->nr_rates > 0) {\n\t\trate_table = kmemdup(fp->rate_table,\n\t\t\t\t     sizeof(int) * fp->nr_rates, GFP_KERNEL);\n\t\tif (!rate_table) {\n\t\t\tkfree(fp);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tfp->rate_table = rate_table;\n\t}\n\n\tstream = (fp->endpoint & USB_DIR_IN)\n\t\t? SNDRV_PCM_STREAM_CAPTURE : SNDRV_PCM_STREAM_PLAYBACK;\n\terr = snd_usb_add_audio_stream(chip, stream, fp);\n\tif (err < 0) {\n\t\tkfree(fp);\n\t\tkfree(rate_table);\n\t\treturn err;\n\t}\n\tif (fp->iface != get_iface_desc(&iface->altsetting[0])->bInterfaceNumber ||\n\t    fp->altset_idx >= iface->num_altsetting) {\n\t\tkfree(fp);\n\t\tkfree(rate_table);\n\t\treturn -EINVAL;\n \t}\n \talts = &iface->altsetting[fp->altset_idx];\n \taltsd = get_iface_desc(alts);\n \tfp->protocol = altsd->bInterfaceProtocol;\n \n \tif (fp->datainterval == 0)\n\t\tfp->datainterval = snd_usb_parse_datainterval(chip, alts);\n\tif (fp->maxpacksize == 0)\n\t\tfp->maxpacksize = le16_to_cpu(get_endpoint(alts, 0)->wMaxPacketSize);\n\tusb_set_interface(chip->dev, fp->iface, 0);\n\tsnd_usb_init_pitch(chip, fp->iface, alts, fp);\n\tsnd_usb_init_sample_rate(chip, fp->iface, alts, fp, fp->rate_max);\n\treturn 0;\n}\n", "target": 1, "idx": 180606}
{"func": "static int cms_copy_content(BIO *out, BIO *in, unsigned int flags)\n \t{\n\tunsigned char buf[4096];\n\tint r = 0, i;\n\tBIO *tmpout = NULL;\n \tif (out == NULL)\n\t\ttmpout = BIO_new(BIO_s_null());\n \telse if (flags & CMS_TEXT)\n \t\t{\n\t\ttmpout = BIO_new(BIO_s_mem());\n\t\tBIO_set_mem_eof_return(tmpout, 0);\n \t\t}\n \telse\n\t\ttmpout = out;\n \n \tif(!tmpout)\n \t\t{\n\t\tCMSerr(CMS_F_CMS_COPY_CONTENT,ERR_R_MALLOC_FAILURE);\n\t\tgoto err;\n\t\t}\n\n\t/* Read all content through chain to process digest, decrypt etc */\n\tfor (;;)\n\t{\n\t\ti=BIO_read(in,buf,sizeof(buf));\n\t\tif (i <= 0)\n\t\t\t{\n\t\t\tif (BIO_method_type(in) == BIO_TYPE_CIPHER)\n\t\t\t\t{\n\t\t\t\tif (!BIO_get_cipher_status(in))\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\tif (i < 0)\n\t\t\t\tgoto err;\n\t\t\tbreak;\n\t\t\t}\n\t\t\t\t\n\t\tif (tmpout && (BIO_write(tmpout, buf, i) != i))\n\t\t\tgoto err;\n\t}\n\n\tif(flags & CMS_TEXT)\n\t\t{\n\t\tif(!SMIME_text(tmpout, out))\n\t\t\t{\n\t\t\tCMSerr(CMS_F_CMS_COPY_CONTENT,CMS_R_SMIME_TEXT_ERROR);\n\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\n\tr = 1;\n\n\terr:\n\tif (tmpout && (tmpout != out))\n\t\tBIO_free(tmpout);\n\treturn r;\n\n\t}\n", "target": 1, "idx": 179861}
{"func": "bool IsBlockedNavigation(net::Error error_code) {\n  switch (error_code) {\n    case net::ERR_BLOCKED_BY_CLIENT:\n    case net::ERR_BLOCKED_BY_RESPONSE:\n    case net::ERR_BLOCKED_BY_XSS_AUDITOR:\n    case net::ERR_UNSAFE_REDIRECT:\n      return true;\n    default:\n      return false;\n  }\n}\n", "target": 1, "idx": 186908}
{"func": "static Image *ReadDDSImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    status,\n    cubemap = MagickFalse,\n    volume = MagickFalse,\n    matte;\n\n  CompressionType\n    compression;\n\n  DDSInfo\n    dds_info;\n\n  DDSDecoder\n    *decoder;\n\n  size_t\n    n,\n    num_images;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n\n  /*\n    Initialize image structure.\n  */\n  if (ReadDDSInfo(image, &dds_info) != MagickTrue) {\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  }\n\n  if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP)\n    cubemap = MagickTrue;\n\n  if (dds_info.ddscaps2 & DDSCAPS2_VOLUME && dds_info.depth > 0)\n    volume = MagickTrue;\n\n  (void) SeekBlob(image, 128, SEEK_SET);\n\n  /*\n    Determine pixel format\n  */\n  if (dds_info.pixelformat.flags & DDPF_RGB)\n    {\n      compression = NoCompression;\n      if (dds_info.pixelformat.flags & DDPF_ALPHAPIXELS)\n        {\n          matte = MagickTrue;\n          decoder = ReadUncompressedRGBA;\n        }\n      else\n        {\n          matte = MagickTrue;\n          decoder = ReadUncompressedRGB;\n        }\n    }\n  else if (dds_info.pixelformat.flags & DDPF_LUMINANCE)\n   {\n      compression = NoCompression;\n      if (dds_info.pixelformat.flags & DDPF_ALPHAPIXELS)\n        {\n          /* Not sure how to handle this */\n          ThrowReaderException(CorruptImageError, \"ImageTypeNotSupported\");\n        }\n      else\n        {\n          matte = MagickFalse;\n          decoder = ReadUncompressedRGB;\n        }\n    }\n  else if (dds_info.pixelformat.flags & DDPF_FOURCC)\n    {\n      switch (dds_info.pixelformat.fourcc)\n      {\n        case FOURCC_DXT1:\n        {\n          matte = MagickFalse;\n          compression = DXT1Compression;\n          decoder = ReadDXT1;\n          break;\n        }\n        case FOURCC_DXT3:\n        {\n          matte = MagickTrue;\n          compression = DXT3Compression;\n          decoder = ReadDXT3;\n          break;\n        }\n        case FOURCC_DXT5:\n        {\n          matte = MagickTrue;\n          compression = DXT5Compression;\n          decoder = ReadDXT5;\n          break;\n        }\n        default:\n        {\n          /* Unknown FOURCC */\n          ThrowReaderException(CorruptImageError, \"ImageTypeNotSupported\");\n        }\n      }\n    }\n  else\n    {\n      /* Neither compressed nor uncompressed... thus unsupported */\n      ThrowReaderException(CorruptImageError, \"ImageTypeNotSupported\");\n    }\n\n  num_images = 1;\n  if (cubemap)\n    {\n      /*\n        Determine number of faces defined in the cubemap\n      */\n      num_images = 0;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEX) num_images++;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEX) num_images++;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEY) num_images++;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEY) num_images++;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEZ) num_images++;\n      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ) num_images++;\n    }\n\n  if (volume)\n    num_images = dds_info.depth;\n\n  for (n = 0; n < num_images; n++)\n   {\n     if (n != 0)\n       {\n         /* Start a new image */\n         AcquireNextImage(image_info,image);\n         if (GetNextImageInList(image) == (Image *) NULL)\n          return(DestroyImageList(image));\n        image=SyncNextImageInList(image);\n      }\n \n    image->matte = matte;\n    image->compression = compression;\n    image->columns = dds_info.width;\n    image->rows = dds_info.height;\n    image->storage_class = DirectClass;\n    image->endian = LSBEndian;\n    image->depth = 8;\n    if (image_info->ping != MagickFalse)\n      {\n        (void) CloseBlob(image);\n        return(GetFirstImageInList(image));\n      }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n\n    if ((decoder)(image, &dds_info, exception) != MagickTrue)\n      {\n        (void) CloseBlob(image);\n        return(GetFirstImageInList(image));\n      }\n  }\n\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n", "target": 1, "idx": 183325}
{"func": "bool IsComponentCoveredByLang(const icu::UnicodeSet& component_characters,\n                              const std::string& lang) {\n  static const icu::UnicodeSet kASCIILetters(0x61, 0x7a);  // [a-z]\n  icu::UnicodeSet* lang_set;\n  {\n    AutoLock lock(lang_set_lock);\n    if (!GetExemplarSetForLang(lang, &lang_set)) {\n      UErrorCode status = U_ZERO_ERROR;\n      ULocaleData* uld = ulocdata_open(lang.c_str(), &status);\n      if (U_SUCCESS(status) && status != U_USING_DEFAULT_WARNING) {\n        lang_set = reinterpret_cast<icu::UnicodeSet *>(\n            ulocdata_getExemplarSet(uld, NULL, 0,\n                                    ULOCDATA_ES_STANDARD, &status));\n        if (IsCompatibleWithASCIILetters(lang))\n          lang_set->addAll(kASCIILetters);\n      } else {\n        lang_set = new icu::UnicodeSet(1, 0);\n      }\n      lang_set->freeze();\n      SetExemplarSetForLang(lang, lang_set);\n      ulocdata_close(uld);\n    }\n  }\n  return !lang_set->isEmpty() && lang_set->containsAll(component_characters);\n}\n", "target": 0, "idx": 100077}
{"func": "AudioBuffer* BaseAudioContext::createBuffer(unsigned number_of_channels,\n                                            size_t number_of_frames,\n                                            float sample_rate,\n                                            ExceptionState& exception_state) {\n\n  AudioBuffer* buffer = AudioBuffer::Create(\n      number_of_channels, number_of_frames, sample_rate, exception_state);\n\n  if (buffer) {\n    DEFINE_STATIC_LOCAL(SparseHistogram, audio_buffer_channels_histogram,\n                        (\"WebAudio.AudioBuffer.NumberOfChannels\"));\n\n    DEFINE_STATIC_LOCAL(CustomCountHistogram, audio_buffer_length_histogram,\n                        (\"WebAudio.AudioBuffer.Length\", 1, 1000000, 50));\n    DEFINE_STATIC_LOCAL(\n        CustomCountHistogram, audio_buffer_sample_rate_histogram,\n        (\"WebAudio.AudioBuffer.SampleRate384kHz\", 3000, 384000, 60));\n\n    audio_buffer_channels_histogram.Sample(number_of_channels);\n    audio_buffer_length_histogram.Count(number_of_frames);\n    audio_buffer_sample_rate_histogram.Count(sample_rate);\n\n    if (!IsContextClosed()) {\n      DEFINE_STATIC_LOCAL(\n          CustomCountHistogram, audio_buffer_sample_rate_ratio_histogram,\n          (\"WebAudio.AudioBuffer.SampleRateRatio384kHz\", 1, 12800, 50));\n      float ratio = 100 * sample_rate / this->sampleRate();\n      audio_buffer_sample_rate_ratio_histogram.Count(\n          static_cast<int>(0.5 + ratio));\n    }\n  }\n\n  return buffer;\n}\n", "target": 0, "idx": 157429}
{"func": "int dev_change_net_namespace(struct net_device *dev, struct net *net, const char *pat)\n{\n\tint err;\n\n\tASSERT_RTNL();\n\n\t/* Don't allow namespace local devices to be moved. */\n\terr = -EINVAL;\n\tif (dev->features & NETIF_F_NETNS_LOCAL)\n\t\tgoto out;\n\n\t/* Ensure the device has been registrered */\n\terr = -EINVAL;\n\tif (dev->reg_state != NETREG_REGISTERED)\n\t\tgoto out;\n\n\t/* Get out if there is nothing todo */\n\terr = 0;\n\tif (net_eq(dev_net(dev), net))\n\t\tgoto out;\n\n\t/* Pick the destination device name, and ensure\n\t * we can use it in the destination network namespace.\n\t */\n\terr = -EEXIST;\n\tif (__dev_get_by_name(net, dev->name)) {\n\t\t/* We get here if we can't use the current device name */\n\t\tif (!pat)\n\t\t\tgoto out;\n\t\tif (dev_get_valid_name(dev, pat, 1))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * And now a mini version of register_netdevice unregister_netdevice.\n\t */\n\n\t/* If device is running close it first. */\n\tdev_close(dev);\n\n\t/* And unlink it from device chain */\n\terr = -ENODEV;\n\tunlist_netdevice(dev);\n\n\tsynchronize_net();\n\n\t/* Shutdown queueing discipline. */\n\tdev_shutdown(dev);\n\n\t/* Notify protocols, that we are about to destroy\n\t   this device. They should clean all the things.\n\n\t   Note that dev->reg_state stays at NETREG_REGISTERED.\n\t   This is wanted because this way 8021q and macvlan know\n\t   the device is just moving and can keep their slaves up.\n\t*/\n\tcall_netdevice_notifiers(NETDEV_UNREGISTER, dev);\n\tcall_netdevice_notifiers(NETDEV_UNREGISTER_BATCH, dev);\n\n\t/*\n\t *\tFlush the unicast and multicast chains\n\t */\n\tdev_uc_flush(dev);\n\tdev_mc_flush(dev);\n\n\t/* Actually switch the network namespace */\n\tdev_net_set(dev, net);\n\n\t/* If there is an ifindex conflict assign a new one */\n\tif (__dev_get_by_index(net, dev->ifindex)) {\n\t\tint iflink = (dev->iflink == dev->ifindex);\n\t\tdev->ifindex = dev_new_index(net);\n\t\tif (iflink)\n\t\t\tdev->iflink = dev->ifindex;\n\t}\n\n\t/* Fixup kobjects */\n\terr = device_rename(&dev->dev, dev->name);\n\tWARN_ON(err);\n\n\t/* Add the device back in the hashes */\n\tlist_netdevice(dev);\n\n\t/* Notify protocols, that a new device appeared. */\n\tcall_netdevice_notifiers(NETDEV_REGISTER, dev);\n\n\t/*\n\t *\tPrevent userspace races by waiting until the network\n\t *\tdevice is fully setup before sending notifications.\n\t */\n\trtmsg_ifinfo(RTM_NEWLINK, dev, ~0U);\n\n\tsynchronize_net();\n\terr = 0;\nout:\n\treturn err;\n}\n", "target": 0, "idx": 35242}
{"func": "SPL_METHOD(Array, getFlags)\n{\n\tzval *object = getThis();\n\tspl_array_object *intern = (spl_array_object*)zend_object_store_get_object(object TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\t\n\tRETURN_LONG(intern->ar_flags & ~SPL_ARRAY_INT_MASK);\n}\n", "target": 0, "idx": 12339}
{"func": "static enum hrtimer_restart perf_swevent_hrtimer(struct hrtimer *hrtimer)\n{\n\tenum hrtimer_restart ret = HRTIMER_RESTART;\n\tstruct perf_sample_data data;\n\tstruct pt_regs *regs;\n\tstruct perf_event *event;\n\tu64 period;\n\n\tevent = container_of(hrtimer, struct perf_event, hw.hrtimer);\n\n\tif (event->state != PERF_EVENT_STATE_ACTIVE)\n\t\treturn HRTIMER_NORESTART;\n\n\tevent->pmu->read(event);\n\n\tperf_sample_data_init(&data, 0);\n\tdata.period = event->hw.last_period;\n\tregs = get_irq_regs();\n \n \tif (regs && !perf_exclude_event(event, regs)) {\n \t\tif (!(event->attr.exclude_idle && current->pid == 0))\n\t\t\tif (perf_event_overflow(event, 0, &data, regs))\n \t\t\t\tret = HRTIMER_NORESTART;\n \t}\n \n\tperiod = max_t(u64, 10000, event->hw.sample_period);\n\thrtimer_forward_now(hrtimer, ns_to_ktime(period));\n\n\treturn ret;\n}\n", "target": 1, "idx": 179010}
{"func": " void DirectoryEntrySync::removeRecursively(ExceptionState& exceptionState)\n {\n    RefPtr<VoidSyncCallbackHelper> helper = VoidSyncCallbackHelper::create();\n     m_fileSystem->removeRecursively(this, helper->successCallback(), helper->errorCallback(), DOMFileSystemBase::Synchronous);\n     helper->getResult(exceptionState);\n }\n", "target": 1, "idx": 185117}
{"func": "ut64 MACH0_(get_main)(struct MACH0_(obj_t)* bin) {\n\tut64 addr = 0LL;\n\tstruct symbol_t *symbols;\n\tint i;\n\n\tif (!(symbols = MACH0_(get_symbols) (bin))) {\n\t\treturn 0;\n\t}\n\tfor (i = 0; !symbols[i].last; i++) {\n\t\tif (!strcmp (symbols[i].name, \"_main\")) {\n\t\t\taddr = symbols[i].addr;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree (symbols);\n\n\tif (!addr && bin->main_cmd.cmd == LC_MAIN) {\n\t\taddr = bin->entry + bin->baddr;\n\t}\n\n\tif (!addr) {\n \t\tut8 b[128];\n \t\tut64 entry = addr_to_offset(bin, bin->entry);\n\t\tif (entry > bin->size || entry + sizeof (b) > bin->size)\n \t\t\treturn 0;\n \t\ti = r_buf_read_at (bin->b, entry, b, sizeof (b));\n \t\tif (i < 1) {\n \t\t\treturn 0;\n\t\t}\n\t\tfor (i = 0; i < 64; i++) {\n\t\t\tif (b[i] == 0xe8 && !b[i+3] && !b[i+4]) {\n\t\t\t\tint delta = b[i+1] | (b[i+2] << 8) | (b[i+3] << 16) | (b[i+4] << 24);\n\t\t\t\treturn bin->entry + i + 5 + delta;\n\n\t\t\t}\n\t\t}\n\t}\n\treturn addr;\n}\n", "target": 1, "idx": 181407}
{"func": "void WebFrameLoaderClient::postProgressStartedNotification() {\n  WebViewImpl* webview = webframe_->GetWebViewImpl();\n  if (webview && webview->client())\n    webview->client()->didStartLoading();\n}\n", "target": 0, "idx": 97224}
{"func": "omx_venc::omx_venc()\n{\n#ifdef _ANDROID_ICS_\n    meta_mode_enable = false;\n    memset(meta_buffer_hdr,0,sizeof(meta_buffer_hdr));\n    memset(meta_buffers,0,sizeof(meta_buffers));\n    memset(opaque_buffer_hdr,0,sizeof(opaque_buffer_hdr));\n    mUseProxyColorFormat = false;\n    get_syntaxhdr_enable = false;\n#endif\n    bframes = entropy = 0;\n char property_value[PROPERTY_VALUE_MAX] = {0};\n    property_get(\"vidc.debug.level\", property_value, \"1\");\n    debug_level = atoi(property_value);\n    property_value[0] = '\\0';\n    property_get(\"vidc.debug.bframes\", property_value, \"0\");\n    bframes = atoi(property_value);\n    property_value[0] = '\\0';\n    property_get(\"vidc.debug.entropy\", property_value, \"1\");\n    entropy = !!atoi(property_value);\n    property_value[0] = '\\0';\n    property_get(\"vidc.debug.perf.mode\", property_value, \"0\");\n    perfmode = atoi(property_value);\n    property_value[0] = '\\0';\n    property_get(\"vidc.debug.hybrid.hierp\", property_value, \"0\");\n    hybrid_hp = atoi(property_value);\n    property_value[0] = '\\0';\n    handle = NULL;\n}\n", "target": 0, "idx": 172411}
{"func": "method_invocation_get_uid (GDBusMethodInvocation *context)\n{\n  const gchar *sender;\n  PolkitSubject *busname;\n  PolkitSubject *process;\n  uid_t uid;\n  sender = g_dbus_method_invocation_get_sender (context);\n  busname = polkit_system_bus_name_new (sender);\n  process = polkit_system_bus_name_get_process_sync (POLKIT_SYSTEM_BUS_NAME (busname), NULL, NULL);\n  uid = polkit_unix_process_get_uid (POLKIT_UNIX_PROCESS (process));\n  g_object_unref (busname);\n  g_object_unref (process);\n  return uid;\n}\n", "target": 1, "idx": 178182}
{"func": "OMX_ERRORTYPE SimpleSoftOMXComponent::internalGetParameter(\n        OMX_INDEXTYPE index, OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamPortDefinition:\n {\n\n             OMX_PARAM_PORTDEFINITIONTYPE *defParams =\n                 (OMX_PARAM_PORTDEFINITIONTYPE *)params;\n \n             if (defParams->nPortIndex >= mPorts.size()\n                     || defParams->nSize\n                             != sizeof(OMX_PARAM_PORTDEFINITIONTYPE)) {\n return OMX_ErrorUndefined;\n }\n\n const PortInfo *port =\n &mPorts.itemAt(defParams->nPortIndex);\n\n            memcpy(defParams, &port->mDef, sizeof(port->mDef));\n\n return OMX_ErrorNone;\n }\n\n default:\n return OMX_ErrorUnsupportedIndex;\n }\n}\n", "target": 1, "idx": 188244}
{"func": "void RemoveProcessIdFromGlobalMap(int32_t process_id) {\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n  GetProcessIdToFilterMap()->erase(process_id);\n}\n", "target": 1, "idx": 187027}
{"func": "void re_yypush_buffer_state (YY_BUFFER_STATE new_buffer , yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\tif (new_buffer == NULL)\n\t\treturn;\n\n\tre_yyensure_buffer_stack(yyscanner);\n\n\t/* This block is copied from re_yy_switch_to_buffer. */\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*yyg->yy_c_buf_p = yyg->yy_hold_char;\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_pos = yyg->yy_c_buf_p;\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;\n\t\t}\n\n\t/* Only push if top exists. Otherwise, replace top. */\n\tif (YY_CURRENT_BUFFER)\n\t\tyyg->yy_buffer_stack_top++;\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\n\t/* copied from re_yy_switch_to_buffer. */\n\tre_yy_load_buffer_state(yyscanner );\n\tyyg->yy_did_buffer_switch_on_eof = 1;\n}\n", "target": 0, "idx": 70496}
{"func": "gfx::NativeViewId RenderWidgetHostViewAndroid::GetNativeViewId() const {\n  return reinterpret_cast<gfx::NativeViewId>(\n      const_cast<RenderWidgetHostViewAndroid*>(this));\n}\n", "target": 0, "idx": 123096}
{"func": "static inline double get_dither_value(VignetteContext *s)\n{\n    double dv = 0;\n    if (s->do_dither) {\n        dv = s->dither / (double)(1LL<<32);\n        s->dither = s->dither * 1664525 + 1013904223;\n    }\n    return dv;\n}\n", "target": 0, "idx": 29776}
{"func": "void RenderViewImpl::CloseWidgetSoon() {\n  RenderWidget::CloseWidgetSoon();\n}\n", "target": 0, "idx": 160764}
{"func": "int32_t WebPage::setComposingText(spannable_string_t* spannableString, int32_t relativeCursorPosition)\n{\n    if (d->m_page->defersLoading())\n        return -1;\n    return d->m_inputHandler->setComposingText(spannableString, relativeCursorPosition);\n}\n", "target": 0, "idx": 111334}
{"func": " static void mark_commit(struct commit *c, void *data)\n {\n\tmark_object(&c->object, NULL, NULL, data);\n }\n", "target": 1, "idx": 180596}
{"func": "Frame* FrameLoaderClient::dispatchCreatePage()\n{\n    WebKitWebView* webView = getViewFromFrame(m_frame);\n    WebKitWebView* newWebView = 0;\n\n    g_signal_emit_by_name(webView, \"create-web-view\", m_frame, &newWebView);\n\n    if (!newWebView)\n        return 0;\n\n    WebKitWebViewPrivate* privateData = WEBKIT_WEB_VIEW_GET_PRIVATE(newWebView);\n    return core(privateData->mainFrame);\n}\n", "target": 0, "idx": 98293}
{"func": "bool jsvIsNewChild(const JsVar *v) { return jsvIsName(v) && jsvGetNextSibling(v) && jsvGetNextSibling(v)==jsvGetPrevSibling(v); }\n", "target": 0, "idx": 82481}
{"func": " void PopupContainer::refresh(const IntRect& targetControlRect)\n {\n    IntPoint location = m_frameView->contentsToWindow(targetControlRect.location());\n    location.move(0, targetControlRect.height());\n \n    listBox()->setBaseWidth(max(m_originalFrameRect.width() - kBorderSize * 2, 0));\n \n    listBox()->updateFromElement();\n    IntSize originalSize = size();\n    IntRect widgetRect = layoutAndCalculateWidgetRect(targetControlRect.height(), location);\n    if (originalSize != widgetRect.size()) {\n        ChromeClientChromium* chromeClient = chromeClientChromium();\n        if (chromeClient) {\n            IntPoint widgetLocation = chromeClient->screenToRootView(widgetRect.location());\n            widgetRect.setLocation(widgetLocation);\n            setFrameRect(widgetRect);\n        }\n     }\n \n     invalidate();\n}\n", "target": 1, "idx": 184719}
{"func": "void HttpResponseHeaders::Parse(const std::string& raw_input) {\n  raw_headers_.reserve(raw_input.size());\n\n  std::string::const_iterator line_begin = raw_input.begin();\n  std::string::const_iterator line_end =\n      std::find(line_begin, raw_input.end(), '\\0');\n  bool has_headers = (line_end != raw_input.end() &&\n                      (line_end + 1) != raw_input.end() &&\n                      *(line_end + 1) != '\\0');\n  ParseStatusLine(line_begin, line_end, has_headers);\n\n  if (line_end == raw_input.end()) {\n    raw_headers_.push_back('\\0');\n    return;\n  }\n\n  size_t status_line_len = raw_headers_.size();\n\n  raw_headers_.append(line_end + 1, raw_input.end());\n\n  line_end = raw_headers_.begin() + status_line_len - 1;\n\n  HttpUtil::HeadersIterator headers(line_end + 1, raw_headers_.end(),\n                                    std::string(1, '\\0'));\n  while (headers.GetNext()) {\n    AddHeader(headers.name_begin(),\n              headers.name_end(),\n              headers.values_begin(),\n              headers.values_end());\n  }\n}\n", "target": 0, "idx": 100814}
{"func": "transform_name(int t)\n /* The name, if 't' has multiple bits set the name of the lowest set bit is\n    * returned.\n    */\n{\n unsigned int i;\n\n \n    t &= -t; /* first set bit */\n \n   for (i=0; i<TTABLE_SIZE; ++i)\n    {\n       if ((transform_info[i].transform & t) != 0)\n          return transform_info[i].name;\n }\n\n return \"invalid transform\";\n}\n", "target": 1, "idx": 187612}
{"func": "EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionConvert2(ExecState* exec)\n{\n    JSValue thisValue = exec->hostThisValue();\n    if (!thisValue.inherits(&JSTestObj::s_info))\n        return throwVMTypeError(exec);\n    JSTestObj* castedThis = jsCast<JSTestObj*>(asObject(thisValue));\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\n     TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n     if (exec->argumentCount() < 1)\n        return throwVMError(exec, createTypeError(exec, \"Not enough arguments\"));\n     b* (tob(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined)));\n     if (exec->hadException())\n         return JSValue::encode(jsUndefined());\n    impl->convert2();\n    return JSValue::encode(jsUndefined());\n}\n", "target": 1, "idx": 184041}
{"func": "static int index_insert(\n\tgit_index *index,\n\tgit_index_entry **entry_ptr,\n\tint replace,\n\tbool trust_path,\n\tbool trust_mode,\n\tbool trust_id)\n{\n\tint error = 0;\n\tsize_t path_length, position;\n\tgit_index_entry *existing, *best, *entry;\n\n\tassert(index && entry_ptr);\n\n\tentry = *entry_ptr;\n\n\t/* make sure that the path length flag is correct */\n\tpath_length = ((struct entry_internal *)entry)->pathlen;\n\tindex_entry_adjust_namemask(entry, path_length);\n\n\t/* this entry is now up-to-date and should not be checked for raciness */\n\tentry->flags_extended |= GIT_IDXENTRY_UPTODATE;\n\n\tgit_vector_sort(&index->entries);\n\n\t/* look if an entry with this path already exists, either staged, or (if\n\t * this entry is a regular staged item) as the \"ours\" side of a conflict.\n\t */\n\tindex_existing_and_best(&existing, &position, &best, index, entry);\n\n\t/* update the file mode */\n\tentry->mode = trust_mode ?\n\t\tgit_index__create_mode(entry->mode) :\n\t\tindex_merge_mode(index, best, entry->mode);\n\n\t/* canonicalize the directory name */\n\tif (!trust_path)\n\t\terror = canonicalize_directory_path(index, entry, best);\n\n\t/* ensure that the given id exists (unless it's a submodule) */\n\tif (!error && !trust_id && INDEX_OWNER(index) &&\n\t\t(entry->mode & GIT_FILEMODE_COMMIT) != GIT_FILEMODE_COMMIT) {\n\n\t\tif (!git_object__is_valid(INDEX_OWNER(index), &entry->id,\n\t\t\tgit_object__type_from_filemode(entry->mode)))\n\t\t\terror = -1;\n\t}\n\n\t/* look for tree / blob name collisions, removing conflicts if requested */\n\tif (!error)\n\t\terror = check_file_directory_collision(index, entry, position, replace);\n\n\tif (error < 0)\n\t\t/* skip changes */;\n\n\t/* if we are replacing an existing item, overwrite the existing entry\n\t * and return it in place of the passed in one.\n\t */\n\telse if (existing) {\n\t\tif (replace) {\n\t\t\tindex_entry_cpy(existing, entry);\n\n\t\t\tif (trust_path)\n\t\t\t\tmemcpy((char *)existing->path, entry->path, strlen(entry->path));\n\t\t}\n\n\t\tindex_entry_free(entry);\n\t\t*entry_ptr = entry = existing;\n\t}\n\telse {\n\t\t/* if replace is not requested or no existing entry exists, insert\n\t\t * at the sorted position.  (Since we re-sort after each insert to\n\t\t * check for dups, this is actually cheaper in the long run.)\n\t\t */\n\t\terror = git_vector_insert_sorted(&index->entries, entry, index_no_dups);\n\n\t\tif (error == 0) {\n\t\t\tINSERT_IN_MAP(index, entry, &error);\n\t\t}\n\t}\n\n\tif (error < 0) {\n\t\tindex_entry_free(*entry_ptr);\n\t\t*entry_ptr = NULL;\n\t}\n\n\treturn error;\n}\n", "target": 0, "idx": 83743}
{"func": "void AppCacheGroup::QueueUpdate(AppCacheHost* host,\n                                const GURL& new_master_resource) {\n  DCHECK(update_job_ && host && !new_master_resource.is_empty());\n  queued_updates_.insert(QueuedUpdates::value_type(\n      host, std::make_pair(host, new_master_resource)));\n\n  host->AddObserver(host_observer_.get());\n\n  if (FindObserver(host, observers_)) {\n    observers_.RemoveObserver(host);\n    queued_observers_.AddObserver(host);\n  }\n}\n", "target": 0, "idx": 158224}
{"func": "static int tls_construct_cke_ecdhe(SSL *s, unsigned char **p, int *len, int *al)\n{\n#ifndef OPENSSL_NO_EC\n    unsigned char *encodedPoint = NULL;\n    int encoded_pt_len = 0;\n    EVP_PKEY *ckey = NULL, *skey = NULL;\n\n    skey = s->s3->peer_tmp;\n    if (skey == NULL) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);\n        return 0;\n     }\n \n     ckey = ssl_generate_pkey(skey);\n \n     if (ssl_derive(s, ckey, skey) == 0) {\n         SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_EVP_LIB);\n        goto err;\n    }\n\n    /* Generate encoding of client key */\n    encoded_pt_len = EVP_PKEY_get1_tls_encodedpoint(ckey, &encodedPoint);\n\n    if (encoded_pt_len == 0) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_EC_LIB);\n        goto err;\n    }\n\n    EVP_PKEY_free(ckey);\n    ckey = NULL;\n\n    *len = encoded_pt_len;\n\n    /* length of encoded point */\n    **p = *len;\n    *p += 1;\n    /* copy the point */\n    memcpy(*p, encodedPoint, *len);\n    /* increment len to account for length field */\n    *len += 1;\n\n    OPENSSL_free(encodedPoint);\n\n    return 1;\n err:\n    EVP_PKEY_free(ckey);\n    return 0;\n#else\n    SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);\n    *al = SSL_AD_INTERNAL_ERROR;\n    return 0;\n#endif\n}\n", "target": 1, "idx": 181606}
{"func": "void stts_del(GF_Box *s)\n{\n\tGF_TimeToSampleBox *ptr = (GF_TimeToSampleBox *)s;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n", "target": 0, "idx": 80500}
{"func": "evutil_adjust_hints_for_addrconfig_(struct evutil_addrinfo *hints)\n{\n\tif (!(hints->ai_flags & EVUTIL_AI_ADDRCONFIG))\n\t\treturn;\n\tif (hints->ai_family != PF_UNSPEC)\n\t\treturn;\n\tif (!have_checked_interfaces)\n\t\tevutil_check_interfaces(0);\n\tif (had_ipv4_address && !had_ipv6_address) {\n\t\thints->ai_family = PF_INET;\n\t} else if (!had_ipv4_address && had_ipv6_address) {\n\t\thints->ai_family = PF_INET6;\n\t}\n}\n", "target": 0, "idx": 70716}
{"func": "__weak void board_spl_fit_post_load(ulong load_addr, size_t length)\n{\n}\n", "target": 0, "idx": 89360}
{"func": "SVGDocumentExtensions* Document::accessSVGExtensions()\n{\n    if (!m_svgExtensions)\n        m_svgExtensions = adoptPtr(new SVGDocumentExtensions(this));\n    return m_svgExtensions.get();\n}\n", "target": 0, "idx": 109556}
{"func": "   static void GetCSI(const v8::FunctionCallbackInfo<v8::Value>& args) {\n     WebLocalFrame* frame = WebLocalFrame::frameForCurrentContext();\n    if (frame) {\n      WebDataSource* data_source = frame->dataSource();\n      if (data_source) {\n        DocumentState* document_state =\n            DocumentState::FromDataSource(data_source);\n        v8::Isolate* isolate = args.GetIsolate();\n        v8::Local<v8::Object> csi = v8::Object::New(isolate);\n        base::Time now = base::Time::Now();\n        base::Time start = document_state->request_time().is_null() ?\n            document_state->start_load_time() :\n            document_state->request_time();\n        base::Time onload = document_state->finish_document_load_time();\n        base::TimeDelta page = now - start;\n        csi->Set(v8::String::NewFromUtf8(isolate, \"startE\"),\n                 v8::Number::New(isolate, floor(start.ToDoubleT() * 1000)));\n        csi->Set(v8::String::NewFromUtf8(isolate, \"onloadT\"),\n                 v8::Number::New(isolate, floor(onload.ToDoubleT() * 1000)));\n        csi->Set(v8::String::NewFromUtf8(isolate, \"pageT\"),\n                 v8::Number::New(isolate, page.InMillisecondsF()));\n        csi->Set(\n            v8::String::NewFromUtf8(isolate, \"tran\"),\n            v8::Number::New(\n                isolate, GetCSITransitionType(data_source->navigationType())));\n        args.GetReturnValue().Set(csi);\n        return;\n      }\n     }\n    args.GetReturnValue().SetNull();\n    return;\n   }\n", "target": 1, "idx": 186085}
{"func": "bool Block::IsKey() const\n{\n    return ((m_flags & static_cast<unsigned char>(1 << 7)) != 0);\n }\n", "target": 1, "idx": 188414}
{"func": "static void add_full(struct kmem_cache_node *n, struct page *page)\n{\n\tspin_lock(&n->list_lock);\n\tlist_add(&page->lru, &n->full);\n\tspin_unlock(&n->list_lock);\n}\n", "target": 0, "idx": 24749}
{"func": "static void *proc_pid_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error = -EACCES;\n\n\t/* We don't need a base pointer in the /proc filesystem */\n\tpath_put(&nd->path);\n\n\t/* Are we allowed to snoop on the tasks file descriptors? */\n\tif (!proc_fd_access_allowed(inode))\n \t\tgoto out;\n \n \terror = PROC_I(inode)->op.proc_get_link(inode, &nd->path);\n\tnd->last_type = LAST_BIND;\n out:\n \treturn ERR_PTR(error);\n }\n", "target": 1, "idx": 179627}
{"func": "GDataDirectory* FindDirectory(GDataDirectoryService* directory_service,\n                              const char* path) {\n  return directory_service->FindEntryByPathSync(\n      FilePath(path))->AsGDataDirectory();\n}\n", "target": 0, "idx": 125541}
{"func": "image_transform_png_set_strip_16_mod(PNG_CONST image_transform *this,\n     image_pixel *that, png_const_structp pp,\n    PNG_CONST transform_display *display)\n {\n    if (that->bit_depth == 16)\n    {\n      that->sample_depth = that->bit_depth = 8;\n if (that->red_sBIT > 8) that->red_sBIT = 8;\n if (that->green_sBIT > 8) that->green_sBIT = 8;\n if (that->blue_sBIT > 8) that->blue_sBIT = 8;\n if (that->alpha_sBIT > 8) that->alpha_sBIT = 8;\n\n /* Prior to 1.5.4 png_set_strip_16 would use an 'accurate' method if this\n       * configuration option is set.  From 1.5.4 the flag is never set and the\n       * 'scale' API (above) must be used.\n       */\n#     ifdef PNG_READ_ACCURATE_SCALE_SUPPORTED\n#        if PNG_LIBPNG_VER >= 10504\n#           error PNG_READ_ACCURATE_SCALE should not be set\n#        endif\n\n /* The strip 16 algorithm drops the low 8 bits rather than calculating\n          * 1/257, so we need to adjust the permitted errors appropriately:\n          * Notice that this is only relevant prior to the addition of the\n\n           * png_set_scale_16 API in 1.5.4 (but 1.5.4+ always defines the above!)\n           */\n          {\n            PNG_CONST double d = (255-128.5)/65535;\n             that->rede += d;\n             that->greene += d;\n             that->bluee += d;\n            that->alphae += d;\n }\n#     endif\n }\n\n this->next->mod(this->next, that, pp, display);\n}\n", "target": 1, "idx": 187671}
{"func": "static int virtio_net_load(QEMUFile *f, void *opaque, int version_id)\n{\n    VirtIONet *n = opaque;\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n    int ret, i, link_down;\n\n    if (version_id < 2 || version_id > VIRTIO_NET_VM_VERSION)\n        return -EINVAL;\n\n    ret = virtio_load(vdev, f);\n    if (ret) {\n        return ret;\n    }\n\n    qemu_get_buffer(f, n->mac, ETH_ALEN);\n    n->vqs[0].tx_waiting = qemu_get_be32(f);\n\n    virtio_net_set_mrg_rx_bufs(n, qemu_get_be32(f));\n\n    if (version_id >= 3)\n        n->status = qemu_get_be16(f);\n\n    if (version_id >= 4) {\n        if (version_id < 8) {\n            n->promisc = qemu_get_be32(f);\n            n->allmulti = qemu_get_be32(f);\n        } else {\n            n->promisc = qemu_get_byte(f);\n            n->allmulti = qemu_get_byte(f);\n        }\n    }\n\n    if (version_id >= 5) {\n        n->mac_table.in_use = qemu_get_be32(f);\n        /* MAC_TABLE_ENTRIES may be different from the saved image */\n        if (n->mac_table.in_use <= MAC_TABLE_ENTRIES) {\n            qemu_get_buffer(f, n->mac_table.macs,\n                            n->mac_table.in_use * ETH_ALEN);\n        } else if (n->mac_table.in_use) {\n            uint8_t *buf = g_malloc0(n->mac_table.in_use);\n            qemu_get_buffer(f, buf, n->mac_table.in_use * ETH_ALEN);\n            g_free(buf);\n            n->mac_table.multi_overflow = n->mac_table.uni_overflow = 1;\n            n->mac_table.in_use = 0;\n        }\n    }\n \n    if (version_id >= 6)\n        qemu_get_buffer(f, (uint8_t *)n->vlans, MAX_VLAN >> 3);\n\n    if (version_id >= 7) {\n        if (qemu_get_be32(f) && !peer_has_vnet_hdr(n)) {\n            error_report(\"virtio-net: saved image requires vnet_hdr=on\");\n            return -1;\n        }\n    }\n\n    if (version_id >= 9) {\n        n->mac_table.multi_overflow = qemu_get_byte(f);\n        n->mac_table.uni_overflow = qemu_get_byte(f);\n    }\n\n    if (version_id >= 10) {\n        n->alluni = qemu_get_byte(f);\n        n->nomulti = qemu_get_byte(f);\n        n->nouni = qemu_get_byte(f);\n        n->nobcast = qemu_get_byte(f);\n    }\n\n    if (version_id >= 11) {\n        if (qemu_get_byte(f) && !peer_has_ufo(n)) {\n            error_report(\"virtio-net: saved image requires TUN_F_UFO support\");\n            return -1;\n        }\n    }\n\n    if (n->max_queues > 1) {\n        if (n->max_queues != qemu_get_be16(f)) {\n            error_report(\"virtio-net: different max_queues \");\n            return -1;\n         }\n \n         n->curr_queues = qemu_get_be16(f);\n         for (i = 1; i < n->curr_queues; i++) {\n             n->vqs[i].tx_waiting = qemu_get_be32(f);\n         }\n        n->curr_guest_offloads = virtio_net_supported_guest_offloads(n);\n    }\n\n    if (peer_has_vnet_hdr(n)) {\n        virtio_net_apply_guest_offloads(n);\n    }\n\n    virtio_net_set_queues(n);\n\n    /* Find the first multicast entry in the saved MAC filter */\n    for (i = 0; i < n->mac_table.in_use; i++) {\n        if (n->mac_table.macs[i * ETH_ALEN] & 1) {\n            break;\n        }\n    }\n    n->mac_table.first_multi = i;\n\n    /* nc.link_down can't be migrated, so infer link_down according\n     * to link status bit in n->status */\n    link_down = (n->status & VIRTIO_NET_S_LINK_UP) == 0;\n    for (i = 0; i < n->max_queues; i++) {\n        qemu_get_subqueue(n->nic, i)->link_down = link_down;\n    }\n\n    return 0;\n}\n", "target": 1, "idx": 178534}
{"func": " static size_t TrimTrailingSpaces ( char * firstChar, size_t origLen )\n {\n\tif ( origLen == 0 ) return 0;\n \n \tchar * lastChar  = firstChar + origLen - 1;\n \tif ( (*lastChar != ' ') && (*lastChar != 0) ) return origLen;\t// Nothing to do.\n\t\n\twhile ( (firstChar <= lastChar) && ((*lastChar == ' ') || (*lastChar == 0)) ) --lastChar;\n\t\n\tXMP_Assert ( (lastChar == firstChar-1) ||\n\t\t\t\t ((lastChar >= firstChar) && (*lastChar != ' ') && (*lastChar != 0)) );\n\t\n\tsize_t newLen = (size_t)((lastChar+1) - firstChar);\n\tXMP_Assert ( newLen <= origLen );\n\n\tif ( newLen < origLen ) {\n\t\t++lastChar;\n\t\t*lastChar = 0;\n\t}\n\n\treturn newLen;\n\n}\t// TrimTrailingSpaces\n", "target": 1, "idx": 178539}
{"func": "static size_t FaceIndexToGLTarget(size_t index) {\n  switch (index) {\n    case 0:\n      return GL_TEXTURE_CUBE_MAP_POSITIVE_X;\n    case 1:\n      return GL_TEXTURE_CUBE_MAP_NEGATIVE_X;\n    case 2:\n      return GL_TEXTURE_CUBE_MAP_POSITIVE_Y;\n    case 3:\n      return GL_TEXTURE_CUBE_MAP_NEGATIVE_Y;\n    case 4:\n      return GL_TEXTURE_CUBE_MAP_POSITIVE_Z;\n    case 5:\n      return GL_TEXTURE_CUBE_MAP_NEGATIVE_Z;\n    default:\n      NOTREACHED();\n      return 0;\n  }\n}\n", "target": 0, "idx": 110667}
{"func": "iakerb_gss_pseudo_random(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n                         int prf_key, const gss_buffer_t prf_in,\n                         ssize_t desired_output_len, gss_buffer_t prf_out)\n{\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n\n    if (ctx->gssc == GSS_C_NO_CONTEXT)\n        return GSS_S_NO_CONTEXT;\n\n    return krb5_gss_pseudo_random(minor_status, ctx->gssc, prf_key, prf_in,\n                                  desired_output_len, prf_out);\n}\n", "target": 0, "idx": 43783}
{"func": "RenderView::RenderView(RenderThreadBase* render_thread,\n                       gfx::NativeViewId parent_hwnd,\n                       int32 opener_id,\n                       const RendererPreferences& renderer_prefs,\n                       const WebPreferences& webkit_prefs,\n                       SharedRenderViewCounter* counter,\n                       int32 routing_id,\n                       int64 session_storage_namespace_id,\n                       const string16& frame_name)\n    : RenderWidget(render_thread, WebKit::WebPopupTypeNone),\n      webkit_preferences_(webkit_prefs),\n      send_content_state_immediately_(false),\n      enabled_bindings_(0),\n      send_preferred_size_changes_(false),\n      is_loading_(false),\n      navigation_gesture_(NavigationGestureUnknown),\n      opened_by_user_gesture_(true),\n      opener_suppressed_(false),\n      page_id_(-1),\n      last_page_id_sent_to_browser_(-1),\n      history_list_offset_(-1),\n      history_list_length_(0),\n      target_url_status_(TARGET_NONE),\n      ALLOW_THIS_IN_INITIALIZER_LIST(pepper_delegate_(this)),\n      ALLOW_THIS_IN_INITIALIZER_LIST(accessibility_method_factory_(this)),\n      ALLOW_THIS_IN_INITIALIZER_LIST(cookie_jar_(this)),\n      geolocation_dispatcher_(NULL),\n      speech_input_dispatcher_(NULL),\n      device_orientation_dispatcher_(NULL),\n      accessibility_ack_pending_(false),\n      p2p_socket_dispatcher_(NULL),\n      session_storage_namespace_id_(session_storage_namespace_id) {\n  routing_id_ = routing_id;\n  if (opener_id != MSG_ROUTING_NONE)\n    opener_id_ = opener_id;\n\n  webwidget_ = WebView::create(this);\n\n  if (counter) {\n    shared_popup_counter_ = counter;\n    shared_popup_counter_->data++;\n    decrement_shared_popup_at_destruction_ = true;\n  } else {\n    shared_popup_counter_ = new SharedRenderViewCounter(0);\n    decrement_shared_popup_at_destruction_ = false;\n  }\n\n  notification_provider_ = new NotificationProvider(this);\n\n  render_thread_->AddRoute(routing_id_, this);\n  AddRef();\n\n  if (opener_id == MSG_ROUTING_NONE) {\n    did_show_ = true;\n    CompleteInit(parent_hwnd);\n  }\n\n  g_view_map.Get().insert(std::make_pair(webview(), this));\n  webkit_preferences_.Apply(webview());\n  webview()->initializeMainFrame(this);\n  if (!frame_name.empty())\n    webview()->mainFrame()->setName(frame_name);\n  webview()->settings()->setMinimumTimerInterval(\n      is_hidden() ? webkit_glue::kBackgroundTabTimerInterval :\n          webkit_glue::kForegroundTabTimerInterval);\n\n  OnSetRendererPrefs(renderer_prefs);\n\n  host_window_ = parent_hwnd;\n\n  const CommandLine& command_line = *CommandLine::ForCurrentProcess();\n  if (command_line.HasSwitch(switches::kEnableAccessibility))\n    WebAccessibilityCache::enableAccessibility();\n\n#if defined(ENABLE_P2P_APIS)\n  p2p_socket_dispatcher_ = new P2PSocketDispatcher(this);\n#endif\n \n   new MHTMLGenerator(this);\n \n   if (command_line.HasSwitch(switches::kEnableMediaStream)) {\n     media_stream_impl_ = new MediaStreamImpl(\n         RenderThread::current()->video_capture_impl_manager());\n  }\n\n  content::GetContentClient()->renderer()->RenderViewCreated(this);\n}\n", "target": 1, "idx": 183785}
{"func": " ConnectionToClient::~ConnectionToClient() {\n }\n", "target": 1, "idx": 184655}
{"func": "int imap_append_message(struct Context *ctx, struct Message *msg)\n{\n  FILE *fp = NULL;\n  char buf[LONG_STRING];\n  char mbox[LONG_STRING];\n  char mailbox[LONG_STRING];\n  char internaldate[IMAP_DATELEN];\n  char imap_flags[SHORT_STRING];\n  size_t len;\n  struct Progress progressbar;\n  size_t sent;\n  int c, last;\n  struct ImapMbox mx;\n  int rc;\n\n  struct ImapData *idata = ctx->data;\n\n  if (imap_parse_path(ctx->path, &mx))\n    return -1;\n\n  imap_fix_path(idata, mx.mbox, mailbox, sizeof(mailbox));\n  if (!*mailbox)\n    mutt_str_strfcpy(mailbox, \"INBOX\", sizeof(mailbox));\n\n  fp = fopen(msg->path, \"r\");\n  if (!fp)\n  {\n    mutt_perror(msg->path);\n    goto fail;\n  }\n\n  /* currently we set the \\Seen flag on all messages, but probably we\n   * should scan the message Status header for flag info. Since we're\n   * already rereading the whole file for length it isn't any more\n   * expensive (it'd be nice if we had the file size passed in already\n   * by the code that writes the file, but that's a lot of changes.\n   * Ideally we'd have a Header structure with flag info here... */\n  for (last = EOF, len = 0; (c = fgetc(fp)) != EOF; last = c)\n  {\n    if (c == '\\n' && last != '\\r')\n      len++;\n\n    len++;\n  }\n  rewind(fp);\n\n  mutt_progress_init(&progressbar, _(\"Uploading message...\"),\n                     MUTT_PROGRESS_SIZE, NetInc, len);\n\n  imap_munge_mbox_name(idata, mbox, sizeof(mbox), mailbox);\n  mutt_date_make_imap(internaldate, sizeof(internaldate), msg->received);\n\n  imap_flags[0] = imap_flags[1] = 0;\n  if (msg->flags.read)\n    mutt_str_strcat(imap_flags, sizeof(imap_flags), \" \\\\Seen\");\n  if (msg->flags.replied)\n    mutt_str_strcat(imap_flags, sizeof(imap_flags), \" \\\\Answered\");\n  if (msg->flags.flagged)\n    mutt_str_strcat(imap_flags, sizeof(imap_flags), \" \\\\Flagged\");\n  if (msg->flags.draft)\n    mutt_str_strcat(imap_flags, sizeof(imap_flags), \" \\\\Draft\");\n\n  snprintf(buf, sizeof(buf), \"APPEND %s (%s) \\\"%s\\\" {%lu}\", mbox,\n           imap_flags + 1, internaldate, (unsigned long) len);\n\n  imap_cmd_start(idata, buf);\n\n  do\n    rc = imap_cmd_step(idata);\n  while (rc == IMAP_CMD_CONTINUE);\n\n  if (rc != IMAP_CMD_RESPOND)\n  {\n    mutt_debug(1, \"#1 command failed: %s\\n\", idata->buf);\n\n    char *pc = idata->buf + SEQLEN;\n    SKIPWS(pc);\n    pc = imap_next_word(pc);\n    mutt_error(\"%s\", pc);\n    mutt_file_fclose(&fp);\n    goto fail;\n  }\n\n  for (last = EOF, sent = len = 0; (c = fgetc(fp)) != EOF; last = c)\n  {\n    if (c == '\\n' && last != '\\r')\n      buf[len++] = '\\r';\n\n    buf[len++] = c;\n\n    if (len > sizeof(buf) - 3)\n    {\n      sent += len;\n      flush_buffer(buf, &len, idata->conn);\n      mutt_progress_update(&progressbar, sent, -1);\n    }\n  }\n\n  if (len)\n    flush_buffer(buf, &len, idata->conn);\n\n  mutt_socket_send(idata->conn, \"\\r\\n\");\n  mutt_file_fclose(&fp);\n\n  do\n    rc = imap_cmd_step(idata);\n  while (rc == IMAP_CMD_CONTINUE);\n\n  if (!imap_code(idata->buf))\n  {\n    mutt_debug(1, \"#2 command failed: %s\\n\", idata->buf);\n    char *pc = idata->buf + SEQLEN;\n    SKIPWS(pc);\n    pc = imap_next_word(pc);\n    mutt_error(\"%s\", pc);\n    goto fail;\n  }\n\n  FREE(&mx.mbox);\n  return 0;\n\nfail:\n  FREE(&mx.mbox);\n  return -1;\n}\n", "target": 0, "idx": 79531}
{"func": "static void check_pointer_type_change(Notifier *notifier, void *data)\n{\n    VncState *vs = container_of(notifier, VncState, mouse_mode_notifier);\n    int absolute = qemu_input_is_absolute();\n\n    if (vnc_has_feature(vs, VNC_FEATURE_POINTER_TYPE_CHANGE) && vs->absolute != absolute) {\n         vnc_write_u8(vs, 0);\n         vnc_write_u16(vs, 1);\n         vnc_framebuffer_update(vs, absolute, 0,\n                               surface_width(vs->vd->ds),\n                               surface_height(vs->vd->ds),\n                                VNC_ENCODING_POINTER_TYPE_CHANGE);\n         vnc_unlock_output(vs);\n         vnc_flush(vs);\n        vnc_unlock_output(vs);\n        vnc_flush(vs);\n    }\n    vs->absolute = absolute;\n}\n", "target": 1, "idx": 178630}
{"func": "MagickExport MagickBooleanType SetQuantumDepth(const Image *image,\n  QuantumInfo *quantum_info,const size_t depth)\n{\n  size_t\n    extent,\n    quantum;\n\n  /*\n    Allocate the quantum pixel buffer.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(quantum_info != (QuantumInfo *) NULL);\n  assert(quantum_info->signature == MagickSignature);\n  quantum_info->depth=depth;\n  if (quantum_info->format == FloatingPointQuantumFormat)\n    {\n      if (quantum_info->depth > 32)\n        quantum_info->depth=64;\n      else\n        if (quantum_info->depth > 16)\n          quantum_info->depth=32;\n        else\n          quantum_info->depth=16;\n    }\n  if (quantum_info->pixels != (unsigned char **) NULL)\n     DestroyQuantumPixels(quantum_info);\n   quantum=(quantum_info->pad+6)*(quantum_info->depth+7)/8;\n   extent=image->columns*quantum;\n  if (quantum != (extent/image->columns))\n     return(MagickFalse);\n   return(AcquireQuantumPixels(quantum_info,extent));\n }\n", "target": 1, "idx": 183285}
{"func": "int readpng_init(FILE *infile, ulg *pWidth, ulg *pHeight)\n{\n    uch sig[8];\n\n\n /* first do a quick check that the file really is a PNG image; could\n     * have used slightly more general png_sig_cmp() function instead */\n\n    fread(sig, 1, 8, infile);\n if (png_sig_cmp(sig, 0, 8))\n return 1; /* bad signature */\n\n\n \n     /* could pass pointers to user-defined error handlers instead of NULLs: */\n \n    png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);\n     if (!png_ptr)\n         return 4;   /* out of memory */\n \n    info_ptr = png_create_info_struct(png_ptr);\n if (!info_ptr) {\n        png_destroy_read_struct(&png_ptr, NULL, NULL);\n return 4; /* out of memory */\n }\n\n\n /* we could create a second info struct here (end_info), but it's only\n     * useful if we want to keep pre- and post-IDAT chunk info separated\n     * (mainly for PNG-aware image editors and converters) */\n\n\n /* setjmp() must be called in every function that calls a PNG-reading\n     * libpng function */\n\n if (setjmp(png_jmpbuf(png_ptr))) {\n        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n return 2;\n }\n\n\n    png_init_io(png_ptr, infile);\n    png_set_sig_bytes(png_ptr, 8); /* we already read the 8 signature bytes */\n\n    png_read_info(png_ptr, info_ptr); /* read all PNG info up to image data */\n\n\n /* alternatively, could make separate calls to png_get_image_width(),\n     * etc., but want bit_depth and color_type for later [don't care about\n     * compression_type and filter_type => NULLs] */\n\n    png_get_IHDR(png_ptr, info_ptr, &width, &height, &bit_depth, &color_type,\n      NULL, NULL, NULL);\n *pWidth = width;\n *pHeight = height;\n\n\n /* OK, that's all we need for now; return happy */\n\n return 0;\n}\n", "target": 1, "idx": 187589}
{"func": "DGAProcessKeyboardEvent(ScreenPtr pScreen, DGAEvent * event, DeviceIntPtr keybd)\n{\n    KeyClassPtr keyc = keybd->key;\n    DGAScreenPtr pScreenPriv = DGA_GET_SCREEN_PRIV(pScreen);\n    DeviceIntPtr pointer = GetMaster(keybd, POINTER_OR_FLOAT);\n    DeviceEvent ev = {\n        .header = ET_Internal,\n        .length = sizeof(ev),\n        .detail.key = event->detail,\n        .type = event->subtype,\n        .root_x = 0,\n        .root_y = 0,\n        .corestate = XkbStateFieldFromRec(&keyc->xkbInfo->state)\n    };\n    ev.corestate |= pointer->button->state;\n\n    UpdateDeviceState(keybd, &ev);\n\n    if (!IsMaster(keybd))\n        return;\n\n    /*\n     * Deliver the DGA event\n     */\n    if (pScreenPriv->client) {\n        dgaEvent de = {\n            .u.event.time = event->time,\n            .u.event.dx = event->dx,\n            .u.event.dy = event->dy,\n            .u.event.screen = pScreen->myNum,\n            .u.event.state = ev.corestate\n        };\n        de.u.u.type = DGAEventBase + GetCoreType(ev.type);\n        de.u.u.detail = event->detail;\n\n        /* If the DGA client has selected input, then deliver based on the usual filter */\n        TryClientEvents(pScreenPriv->client, keybd, (xEvent *) &de, 1,\n                        filters[ev.type], pScreenPriv->input, 0);\n    }\n    else {\n        /* If the keyboard is actively grabbed, deliver a grabbed core event */\n        if (keybd->deviceGrab.grab && !keybd->deviceGrab.fromPassiveGrab) {\n            ev.detail.key = event->detail;\n            ev.time = event->time;\n            ev.root_x = event->dx;\n            ev.root_y = event->dy;\n            ev.corestate = event->state;\n            ev.deviceid = keybd->id;\n            DeliverGrabbedEvent((InternalEvent *) &ev, keybd, FALSE);\n        }\n    }\n}\n", "target": 0, "idx": 17715}
{"func": "bool ACodec::isFlexibleColorFormat(\n const sp<IOMX> &omx, IOMX::node_id node,\n uint32_t colorFormat, bool usingNativeBuffers, OMX_U32 *flexibleEquivalent) {\n DescribeColorFormatParams describeParams;\n InitOMXParams(&describeParams);\n    describeParams.eColorFormat = (OMX_COLOR_FORMATTYPE)colorFormat;\n    describeParams.nFrameWidth = 128;\n    describeParams.nFrameHeight = 128;\n    describeParams.nStride = 128;\n    describeParams.nSliceHeight = 128;\n    describeParams.bUsingNativeBuffers = (OMX_BOOL)usingNativeBuffers;\n\n    CHECK(flexibleEquivalent != NULL);\n\n if (!describeColorFormat(omx, node, describeParams)) {\n return false;\n }\n\n const MediaImage &img = describeParams.sMediaImage;\n if (img.mType == MediaImage::MEDIA_IMAGE_TYPE_YUV) {\n if (img.mNumPlanes != 3 ||\n            img.mPlane[img.Y].mHorizSubsampling != 1 ||\n            img.mPlane[img.Y].mVertSubsampling != 1) {\n return false;\n }\n\n if (img.mPlane[img.U].mHorizSubsampling == 2\n && img.mPlane[img.U].mVertSubsampling == 2\n && img.mPlane[img.V].mHorizSubsampling == 2\n && img.mPlane[img.V].mVertSubsampling == 2) {\n if (img.mBitDepth <= 8) {\n *flexibleEquivalent = OMX_COLOR_FormatYUV420Flexible;\n return true;\n }\n }\n }\n return false;\n}\n", "target": 0, "idx": 177245}
{"func": " void ChromeMockRenderThread::set_print_dialog_user_response(bool response) {\n  print_dialog_user_response_ = response;\n}\n", "target": 0, "idx": 112814}
{"func": "int Element::offsetHeight()\n{\n    document()->updateLayoutIgnorePendingStylesheets();\n    if (RenderBoxModelObject* renderer = renderBoxModelObject())\n        return adjustLayoutUnitForAbsoluteZoom(renderer->pixelSnappedOffsetHeight(), renderer).round();\n    return 0;\n}\n", "target": 0, "idx": 120573}
{"func": "bool LinearHistogram::PrintEmptyBucket(uint32_t index) const {\n  return bucket_description_.find(ranges(index)) == bucket_description_.end();\n}\n", "target": 0, "idx": 152745}
{"func": "static void reply_sesssetup_and_X_spnego(struct smb_request *req)\n{\n\tconst uint8 *p;\n\tDATA_BLOB blob1;\n\tsize_t bufrem;\n\tchar *tmp;\n\tconst char *native_os;\n\tconst char *native_lanman;\n\tconst char *primary_domain;\n\tconst char *p2;\n\tuint16 data_blob_len = SVAL(req->vwv+7, 0);\n\tenum remote_arch_types ra_type = get_remote_arch();\n\tint vuid = req->vuid;\n\tuser_struct *vuser = NULL;\n\tNTSTATUS status = NT_STATUS_OK;\n\tuint16 smbpid = req->smbpid;\n\tstruct smbd_server_connection *sconn = smbd_server_conn;\n\n\tDEBUG(3,(\"Doing spnego session setup\\n\"));\n\n\tif (global_client_caps == 0) {\n\t\tglobal_client_caps = IVAL(req->vwv+10, 0);\n\n\t\tif (!(global_client_caps & CAP_STATUS32)) {\n\t\t\tremove_from_common_flags2(FLAGS2_32_BIT_ERROR_CODES);\n\t\t}\n\n\t}\n\n\tp = req->buf;\n\n\tif (data_blob_len == 0) {\n\t\t/* an invalid request */\n\t\treply_nterror(req, nt_status_squash(NT_STATUS_LOGON_FAILURE));\n\t\treturn;\n\t}\n\n\tbufrem = smbreq_bufrem(req, p);\n\t/* pull the spnego blob */\n\tblob1 = data_blob(p, MIN(bufrem, data_blob_len));\n\n#if 0\n        file_save(\"negotiate.dat\", blob1.data, blob1.length);\n #endif\n \n       p2 = (char *)req->buf + data_blob_len;\n \n        p2 += srvstr_pull_req_talloc(talloc_tos(), req, &tmp, p2,\n                                     STR_TERMINATE);\n\tnative_os = tmp ? tmp : \"\";\n\n\tp2 += srvstr_pull_req_talloc(talloc_tos(), req, &tmp, p2,\n\t\t\t\t     STR_TERMINATE);\n\tnative_lanman = tmp ? tmp : \"\";\n\n\tp2 += srvstr_pull_req_talloc(talloc_tos(), req, &tmp, p2,\n\t\t\t\t     STR_TERMINATE);\n\tprimary_domain = tmp ? tmp : \"\";\n\n\tDEBUG(3,(\"NativeOS=[%s] NativeLanMan=[%s] PrimaryDomain=[%s]\\n\",\n\t\tnative_os, native_lanman, primary_domain));\n\n\tif ( ra_type == RA_WIN2K ) {\n\t\t/* Vista sets neither the OS or lanman strings */\n\n\t\tif ( !strlen(native_os) && !strlen(native_lanman) )\n\t\t\tset_remote_arch(RA_VISTA);\n\n\t\t/* Windows 2003 doesn't set the native lanman string,\n\t\t   but does set primary domain which is a bug I think */\n\n\t\tif ( !strlen(native_lanman) ) {\n\t\t\tra_lanman_string( primary_domain );\n\t\t} else {\n\t\t\tra_lanman_string( native_lanman );\n\t\t}\n\t}\n\n\t/* Did we get a valid vuid ? */\n\tif (!is_partial_auth_vuid(sconn, vuid)) {\n\t\t/* No, then try and see if this is an intermediate sessionsetup\n\t\t * for a large SPNEGO packet. */\n\t\tstruct pending_auth_data *pad;\n\t\tpad = get_pending_auth_data(sconn, smbpid);\n\t\tif (pad) {\n\t\t\tDEBUG(10,(\"reply_sesssetup_and_X_spnego: found \"\n\t\t\t\t\"pending vuid %u\\n\",\n\t\t\t\t(unsigned int)pad->vuid ));\n\t\t\tvuid = pad->vuid;\n\t\t}\n\t}\n\n\t/* Do we have a valid vuid now ? */\n\tif (!is_partial_auth_vuid(sconn, vuid)) {\n\t\t/* No, start a new authentication setup. */\n\t\tvuid = register_initial_vuid(sconn);\n\t\tif (vuid == UID_FIELD_INVALID) {\n\t\t\tdata_blob_free(&blob1);\n\t\t\treply_nterror(req, nt_status_squash(\n\t\t\t\t\t      NT_STATUS_INVALID_PARAMETER));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tvuser = get_partial_auth_user_struct(sconn, vuid);\n\t/* This MUST be valid. */\n\tif (!vuser) {\n\t\tsmb_panic(\"reply_sesssetup_and_X_spnego: invalid vuid.\");\n\t}\n\n\t/* Large (greater than 4k) SPNEGO blobs are split into multiple\n\t * sessionsetup requests as the Windows limit on the security blob\n\t * field is 4k. Bug #4400. JRA.\n\t */\n\n\tstatus = check_spnego_blob_complete(sconn, smbpid, vuid, &blob1);\n\tif (!NT_STATUS_IS_OK(status)) {\n\t\tif (!NT_STATUS_EQUAL(status,\n\t\t\t\tNT_STATUS_MORE_PROCESSING_REQUIRED)) {\n\t\t\t/* Real error - kill the intermediate vuid */\n\t\t\tinvalidate_vuid(sconn, vuid);\n\t\t}\n\t\tdata_blob_free(&blob1);\n\t\treply_nterror(req, nt_status_squash(status));\n\t\treturn;\n\t}\n\n\tif (blob1.data[0] == ASN1_APPLICATION(0)) {\n\n\t\t/* its a negTokenTarg packet */\n\n\t\treply_spnego_negotiate(req, vuid, blob1,\n\t\t\t\t       &vuser->auth_ntlmssp_state);\n\t\tdata_blob_free(&blob1);\n\t\treturn;\n\t}\n\n\tif (blob1.data[0] == ASN1_CONTEXT(1)) {\n\n\t\t/* its a auth packet */\n\n\t\treply_spnego_auth(req, vuid, blob1,\n\t\t\t\t  &vuser->auth_ntlmssp_state);\n\t\tdata_blob_free(&blob1);\n\t\treturn;\n\t}\n\n\tif (strncmp((char *)(blob1.data), \"NTLMSSP\", 7) == 0) {\n\t\tDATA_BLOB chal;\n\n\t\tif (!vuser->auth_ntlmssp_state) {\n\t\t\tstatus = auth_ntlmssp_start(&vuser->auth_ntlmssp_state);\n\t\t\tif (!NT_STATUS_IS_OK(status)) {\n\t\t\t\t/* Kill the intermediate vuid */\n\t\t\t\tinvalidate_vuid(sconn, vuid);\n\t\t\t\tdata_blob_free(&blob1);\n\t\t\t\treply_nterror(req, nt_status_squash(status));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tstatus = auth_ntlmssp_update(vuser->auth_ntlmssp_state,\n\t\t\t\t\t\tblob1, &chal);\n\n\t\tdata_blob_free(&blob1);\n\n\t\treply_spnego_ntlmssp(req, vuid,\n\t\t\t\t     &vuser->auth_ntlmssp_state,\n\t\t\t\t     &chal, status, OID_NTLMSSP, false);\n\t\tdata_blob_free(&chal);\n\t\treturn;\n\t}\n\n\t/* what sort of packet is this? */\n\tDEBUG(1,(\"Unknown packet in reply_sesssetup_and_X_spnego\\n\"));\n\n\tdata_blob_free(&blob1);\n\n\treply_nterror(req, nt_status_squash(NT_STATUS_LOGON_FAILURE));\n}\n", "target": 1, "idx": 178226}
{"func": "ConfirmInfoBarDelegate* ConfirmInfoBar::GetDelegate() {\n  return delegate()->AsConfirmInfoBarDelegate();\n}\n", "target": 0, "idx": 107942}
{"func": "static int can_open_cached(struct nfs4_state *state, fmode_t mode, int open_mode)\n{\n\tint ret = 0;\n\n\tif (open_mode & (O_EXCL|O_TRUNC))\n\t\tgoto out;\n\tswitch (mode & (FMODE_READ|FMODE_WRITE)) {\n\t\tcase FMODE_READ:\n\t\t\tret |= test_bit(NFS_O_RDONLY_STATE, &state->flags) != 0\n\t\t\t\t&& state->n_rdonly != 0;\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tret |= test_bit(NFS_O_WRONLY_STATE, &state->flags) != 0\n\t\t\t\t&& state->n_wronly != 0;\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tret |= test_bit(NFS_O_RDWR_STATE, &state->flags) != 0\n\t\t\t\t&& state->n_rdwr != 0;\n\t}\nout:\n\treturn ret;\n}\n", "target": 0, "idx": 19842}
{"func": "static void MSLProcessingInstructions(void *context,const xmlChar *target,\n  const xmlChar *data)\n{\n  MSLInfo\n    *msl_info;\n\n  /*\n    A processing instruction has been parsed.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.processingInstruction(%s, %s)\",\n    target,data);\n  msl_info=(MSLInfo *) context;\n  (void) msl_info;\n}\n", "target": 0, "idx": 62787}
{"func": "void WorkerFetchContext::DispatchWillSendRequest(\n     unsigned long identifier,\n     ResourceRequest& request,\n     const ResourceResponse& redirect_response,\n     const FetchInitiatorInfo& initiator_info) {\n   probe::willSendRequest(global_scope_, identifier, nullptr, request,\n                         redirect_response, initiator_info);\n }\n", "target": 1, "idx": 186444}
{"func": "   void ProcessStateChangesUnifiedPlan(\n       WebRtcSetDescriptionObserver::States states) {\n     DCHECK_EQ(sdp_semantics_, webrtc::SdpSemantics::kUnifiedPlan);\n    handler_->OnModifyTransceivers(\n        std::move(states.transceiver_states),\n        action_ == PeerConnectionTracker::ACTION_SET_REMOTE_DESCRIPTION);\n   }\n", "target": 1, "idx": 187059}
{"func": "static void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags)\n{\n\tconst struct sched_class *class;\n\n\tif (p->sched_class == rq->curr->sched_class) {\n\t\trq->curr->sched_class->check_preempt_curr(rq, p, flags);\n\t} else {\n\t\tfor_each_class(class) {\n\t\t\tif (class == rq->curr->sched_class)\n\t\t\t\tbreak;\n\t\t\tif (class == p->sched_class) {\n\t\t\t\tresched_task(rq->curr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n \t * A queue event has occurred, and we're going to schedule.  In\n \t * this case, we can save a useless back to back clock update.\n \t */\n\tif (test_tsk_need_resched(rq->curr))\n \t\trq->skip_clock_update = 1;\n }\n", "target": 1, "idx": 178847}
{"func": "GF_Box *mp4s_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGSampleEntryBox, GF_ISOM_BOX_TYPE_MP4S);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\treturn (GF_Box *)tmp;\n}\n", "target": 0, "idx": 80266}
{"func": "find_alternate_tgs(kdc_realm_t *kdc_active_realm, krb5_principal princ,\n                   krb5_db_entry **server_ptr, const char **status)\n{\n    krb5_error_code retval;\n    krb5_principal *plist = NULL, *pl2;\n    krb5_data tmp;\n    krb5_db_entry *server = NULL;\n\n    *server_ptr = NULL;\n    assert(is_cross_tgs_principal(princ));\n    if ((retval = krb5_walk_realm_tree(kdc_context,\n                                       krb5_princ_realm(kdc_context, princ),\n                                       krb5_princ_component(kdc_context, princ, 1),\n                                       &plist, KRB5_REALM_BRANCH_CHAR))) {\n        goto cleanup;\n    }\n    /* move to the end */\n    for (pl2 = plist; *pl2; pl2++);\n\n    /* the first entry in this array is for krbtgt/local@local, so we\n       ignore it */\n    while (--pl2 > plist) {\n        tmp = *krb5_princ_realm(kdc_context, *pl2);\n        krb5_princ_set_realm(kdc_context, *pl2,\n                             krb5_princ_realm(kdc_context, tgs_server));\n        retval = db_get_svc_princ(kdc_context, *pl2, 0, &server, status);\n        krb5_princ_set_realm(kdc_context, *pl2, &tmp);\n        if (retval == KRB5_KDB_NOENTRY)\n            continue;\n        else if (retval)\n            goto cleanup;\n\n        log_tgs_alt_tgt(kdc_context, server->princ);\n        *server_ptr = server;\n        server = NULL;\n         goto cleanup;\n     }\n cleanup:\n     if (retval != 0)\n         *status = \"UNKNOWN_SERVER\";\n \n    krb5_free_realm_tree(kdc_context, plist);\n    krb5_db_free_principal(kdc_context, server);\n    return retval;\n}\n", "target": 1, "idx": 179302}
{"func": "void I18NCustomBindings::DetectTextLanguage(\n    const v8::FunctionCallbackInfo<v8::Value>& args) {\n  CHECK(args.Length() == 1);\n  CHECK(args[0]->IsString());\n\n  std::string text = *v8::String::Utf8Value(args[0]);\n  CLD2::CLDHints cldhints = {nullptr, \"\", CLD2::UNKNOWN_ENCODING,\n                             CLD2::UNKNOWN_LANGUAGE};\n\n  bool is_plain_text = true;  // assume the text is a plain text\n  int flags = 0;              // no flags, see compact_lang_det.h for details\n  int text_bytes;             // amount of non-tag/letters-only text (assumed 0)\n  int valid_prefix_bytes;     // amount of valid UTF8 character in the string\n  double normalized_score[kCldNumLangs];\n\n  CLD2::Language languages[kCldNumLangs];\n  int percents[kCldNumLangs];\n  bool is_reliable = false;\n\n  int cld_language = CLD2::ExtDetectLanguageSummaryCheckUTF8(\n      text.c_str(), static_cast<int>(text.size()), is_plain_text, &cldhints,\n      flags, languages, percents, normalized_score,\n      nullptr,  // assumed no ResultChunkVector is used\n      &text_bytes, &is_reliable, &valid_prefix_bytes);\n\n  if (valid_prefix_bytes < static_cast<int>(text.size()) &&\n      cld_language == CLD2::UNKNOWN_LANGUAGE) {\n    CLD2::ExtDetectLanguageSummary(\n        text.c_str(), valid_prefix_bytes, is_plain_text, &cldhints, flags,\n        languages, percents, normalized_score,\n        nullptr,  // assumed no ResultChunkVector is used\n        &text_bytes, &is_reliable);\n  }\n\n  LanguageDetectionResult result(is_reliable);\n  InitDetectedLanguages(languages, percents, &result.languages);\n\n  args.GetReturnValue().Set(result.ToValue(context()));\n}\n", "target": 0, "idx": 145278}
{"func": "        static PassRefPtrWillBeRawPtr<CreateFileResult> create()\n         {\n            return adoptRefWillBeNoop(new CreateFileResult());\n         }\n", "target": 1, "idx": 185111}
{"func": " void InspectorResourceAgent::setUserAgentOverride(ErrorString*, const String& userAgent)\n {\n     m_state->setString(ResourceAgentState::userAgentOverride, userAgent);\n    m_overlay->setOverride(InspectorOverlay::UserAgentOverride, !userAgent.isEmpty());\n }\n", "target": 1, "idx": 184247}
{"func": " static int perf_swevent_init(struct perf_event *event)\n {\n\tint event_id = event->attr.config;\n \n \tif (event->attr.type != PERF_TYPE_SOFTWARE)\n \t\treturn -ENOENT;\n\n\t/*\n\t * no branch sampling for software events\n\t */\n\tif (has_branch_stack(event))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (event_id) {\n\tcase PERF_COUNT_SW_CPU_CLOCK:\n\tcase PERF_COUNT_SW_TASK_CLOCK:\n\t\treturn -ENOENT;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (event_id >= PERF_COUNT_SW_MAX)\n\t\treturn -ENOENT;\n\n\tif (!event->parent) {\n\t\tint err;\n\n\t\terr = swevent_hlist_get(event);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tstatic_key_slow_inc(&perf_swevent_enabled[event_id]);\n\t\tevent->destroy = sw_perf_event_destroy;\n\t}\n\n\treturn 0;\n}\n", "target": 1, "idx": 179257}
{"func": "bool radeon_atom_get_tv_timings(struct radeon_device *rdev, int index,\n\t\t\t\tstruct drm_display_mode *mode)\n{\n\tstruct radeon_mode_info *mode_info = &rdev->mode_info;\n\tATOM_ANALOG_TV_INFO *tv_info;\n\tATOM_ANALOG_TV_INFO_V1_2 *tv_info_v1_2;\n\tATOM_DTD_FORMAT *dtd_timings;\n\tint data_index = GetIndexIntoMasterTable(DATA, AnalogTV_Info);\n\tu8 frev, crev;\n\tu16 data_offset, misc;\n\n\tif (!atom_parse_data_header(mode_info->atom_context, data_index, NULL,\n\t\t\t\t    &frev, &crev, &data_offset))\n\t\treturn false;\n\n \tswitch (crev) {\n \tcase 1:\n \t\ttv_info = (ATOM_ANALOG_TV_INFO *)(mode_info->atom_context->bios + data_offset);\n\t\tif (index > MAX_SUPPORTED_TV_TIMING)\n \t\t\treturn false;\n \n \t\tmode->crtc_htotal = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_H_Total);\n\t\tmode->crtc_hdisplay = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_H_Disp);\n\t\tmode->crtc_hsync_start = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_H_SyncStart);\n\t\tmode->crtc_hsync_end = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_H_SyncStart) +\n\t\t\tle16_to_cpu(tv_info->aModeTimings[index].usCRTC_H_SyncWidth);\n\n\t\tmode->crtc_vtotal = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_V_Total);\n\t\tmode->crtc_vdisplay = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_V_Disp);\n\t\tmode->crtc_vsync_start = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_V_SyncStart);\n\t\tmode->crtc_vsync_end = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_V_SyncStart) +\n\t\t\tle16_to_cpu(tv_info->aModeTimings[index].usCRTC_V_SyncWidth);\n\n\t\tmode->flags = 0;\n\t\tmisc = le16_to_cpu(tv_info->aModeTimings[index].susModeMiscInfo.usAccess);\n\t\tif (misc & ATOM_VSYNC_POLARITY)\n\t\t\tmode->flags |= DRM_MODE_FLAG_NVSYNC;\n\t\tif (misc & ATOM_HSYNC_POLARITY)\n\t\t\tmode->flags |= DRM_MODE_FLAG_NHSYNC;\n\t\tif (misc & ATOM_COMPOSITESYNC)\n\t\t\tmode->flags |= DRM_MODE_FLAG_CSYNC;\n\t\tif (misc & ATOM_INTERLACE)\n\t\t\tmode->flags |= DRM_MODE_FLAG_INTERLACE;\n\t\tif (misc & ATOM_DOUBLE_CLOCK_MODE)\n\t\t\tmode->flags |= DRM_MODE_FLAG_DBLSCAN;\n\n\t\tmode->clock = le16_to_cpu(tv_info->aModeTimings[index].usPixelClock) * 10;\n\n\t\tif (index == 1) {\n\t\t\t/* PAL timings appear to have wrong values for totals */\n\t\t\tmode->crtc_htotal -= 1;\n\t\t\tmode->crtc_vtotal -= 1;\n\t\t}\n \t\tbreak;\n \tcase 2:\n \t\ttv_info_v1_2 = (ATOM_ANALOG_TV_INFO_V1_2 *)(mode_info->atom_context->bios + data_offset);\n\t\tif (index > MAX_SUPPORTED_TV_TIMING_V1_2)\n \t\t\treturn false;\n \n \t\tdtd_timings = &tv_info_v1_2->aModeTimings[index];\n\t\tmode->crtc_htotal = le16_to_cpu(dtd_timings->usHActive) +\n\t\t\tle16_to_cpu(dtd_timings->usHBlanking_Time);\n\t\tmode->crtc_hdisplay = le16_to_cpu(dtd_timings->usHActive);\n\t\tmode->crtc_hsync_start = le16_to_cpu(dtd_timings->usHActive) +\n\t\t\tle16_to_cpu(dtd_timings->usHSyncOffset);\n\t\tmode->crtc_hsync_end = mode->crtc_hsync_start +\n\t\t\tle16_to_cpu(dtd_timings->usHSyncWidth);\n\n\t\tmode->crtc_vtotal = le16_to_cpu(dtd_timings->usVActive) +\n\t\t\tle16_to_cpu(dtd_timings->usVBlanking_Time);\n\t\tmode->crtc_vdisplay = le16_to_cpu(dtd_timings->usVActive);\n\t\tmode->crtc_vsync_start = le16_to_cpu(dtd_timings->usVActive) +\n\t\t\tle16_to_cpu(dtd_timings->usVSyncOffset);\n\t\tmode->crtc_vsync_end = mode->crtc_vsync_start +\n\t\t\tle16_to_cpu(dtd_timings->usVSyncWidth);\n\n\t\tmode->flags = 0;\n\t\tmisc = le16_to_cpu(dtd_timings->susModeMiscInfo.usAccess);\n\t\tif (misc & ATOM_VSYNC_POLARITY)\n\t\t\tmode->flags |= DRM_MODE_FLAG_NVSYNC;\n\t\tif (misc & ATOM_HSYNC_POLARITY)\n\t\t\tmode->flags |= DRM_MODE_FLAG_NHSYNC;\n\t\tif (misc & ATOM_COMPOSITESYNC)\n\t\t\tmode->flags |= DRM_MODE_FLAG_CSYNC;\n\t\tif (misc & ATOM_INTERLACE)\n\t\t\tmode->flags |= DRM_MODE_FLAG_INTERLACE;\n\t\tif (misc & ATOM_DOUBLE_CLOCK_MODE)\n\t\t\tmode->flags |= DRM_MODE_FLAG_DBLSCAN;\n\n\t\tmode->clock = le16_to_cpu(dtd_timings->usPixClk) * 10;\n\t\tbreak;\n\t}\n\treturn true;\n}\n", "target": 1, "idx": 183045}
{"func": "void set_task_cpu(struct task_struct *p, unsigned int new_cpu)\n{\n#ifdef CONFIG_SCHED_DEBUG\n\t/*\n\t * We should never call set_task_cpu() on a blocked task,\n\t * ttwu() will sort out the placement.\n\t */\n\tWARN_ON_ONCE(p->state != TASK_RUNNING && p->state != TASK_WAKING &&\n\t\t\t!(task_thread_info(p)->preempt_count & PREEMPT_ACTIVE));\n#endif\n\n\ttrace_sched_migrate_task(p, new_cpu);\n\n\tif (task_cpu(p) != new_cpu) {\n\t\tp->se.nr_migrations++;\n\t\tperf_sw_event(PERF_COUNT_SW_CPU_MIGRATIONS, 1, 1, NULL, 0);\n\t}\n\n\t__set_task_cpu(p, new_cpu);\n}\n", "target": 0, "idx": 22594}
{"func": " static void __exit exit_ext2_fs(void)\n {\n \tunregister_filesystem(&ext2_fs_type);\n \tdestroy_inodecache();\n\texit_ext2_xattr();\n }\n", "target": 1, "idx": 183144}
{"func": "int fib6_add(struct fib6_node *root, struct rt6_info *rt, struct nl_info *info)\n{\n\tstruct fib6_node *fn, *pn = NULL;\n\tint err = -ENOMEM;\n\tint allow_create = 1;\n\tint replace_required = 0;\n\n\tif (info->nlh) {\n\t\tif (!(info->nlh->nlmsg_flags & NLM_F_CREATE))\n\t\t\tallow_create = 0;\n\t\tif (info->nlh->nlmsg_flags & NLM_F_REPLACE)\n\t\t\treplace_required = 1;\n\t}\n\tif (!allow_create && !replace_required)\n\t\tpr_warn(\"RTM_NEWROUTE with no NLM_F_CREATE or NLM_F_REPLACE\\n\");\n\n \tfn = fib6_add_1(root, &rt->rt6i_dst.addr, rt->rt6i_dst.plen,\n \t\t\toffsetof(struct rt6_info, rt6i_dst), allow_create,\n \t\t\treplace_required);\n \tif (IS_ERR(fn)) {\n \t\terr = PTR_ERR(fn);\n \t\tgoto out;\n \t}\n \n\tpn = fn;\n\n#ifdef CONFIG_IPV6_SUBTREES\n\tif (rt->rt6i_src.plen) {\n\t\tstruct fib6_node *sn;\n\n\t\tif (!fn->subtree) {\n\t\t\tstruct fib6_node *sfn;\n\n\t\t\t/*\n\t\t\t * Create subtree.\n\t\t\t *\n\t\t\t *\t\tfn[main tree]\n\t\t\t *\t\t|\n\t\t\t *\t\tsfn[subtree root]\n\t\t\t *\t\t   \\\n\t\t\t *\t\t    sn[new leaf node]\n\t\t\t */\n\n\t\t\t/* Create subtree root node */\n\t\t\tsfn = node_alloc();\n\t\t\tif (!sfn)\n\t\t\t\tgoto st_failure;\n\n\t\t\tsfn->leaf = info->nl_net->ipv6.ip6_null_entry;\n\t\t\tatomic_inc(&info->nl_net->ipv6.ip6_null_entry->rt6i_ref);\n\t\t\tsfn->fn_flags = RTN_ROOT;\n\t\t\tsfn->fn_sernum = fib6_new_sernum();\n\n\t\t\t/* Now add the first leaf node to new subtree */\n\n\t\t\tsn = fib6_add_1(sfn, &rt->rt6i_src.addr,\n\t\t\t\t\trt->rt6i_src.plen,\n\t\t\t\t\toffsetof(struct rt6_info, rt6i_src),\n\t\t\t\t\tallow_create, replace_required);\n\n\t\t\tif (IS_ERR(sn)) {\n\t\t\t\t/* If it is failed, discard just allocated\n\t\t\t\t   root, and then (in st_failure) stale node\n\t\t\t\t   in main tree.\n\t\t\t\t */\n\t\t\t\tnode_free(sfn);\n\t\t\t\terr = PTR_ERR(sn);\n\t\t\t\tgoto st_failure;\n\t\t\t}\n\n\t\t\t/* Now link new subtree to main tree */\n\t\t\tsfn->parent = fn;\n\t\t\tfn->subtree = sfn;\n\t\t} else {\n\t\t\tsn = fib6_add_1(fn->subtree, &rt->rt6i_src.addr,\n\t\t\t\t\trt->rt6i_src.plen,\n\t\t\t\t\toffsetof(struct rt6_info, rt6i_src),\n\t\t\t\t\tallow_create, replace_required);\n\n\t\t\tif (IS_ERR(sn)) {\n\t\t\t\terr = PTR_ERR(sn);\n\t\t\t\tgoto st_failure;\n\t\t\t}\n\t\t}\n\n\t\tif (!fn->leaf) {\n\t\t\tfn->leaf = rt;\n\t\t\tatomic_inc(&rt->rt6i_ref);\n\t\t}\n\t\tfn = sn;\n\t}\n#endif\n\n\terr = fib6_add_rt2node(fn, rt, info);\n\tif (!err) {\n\t\tfib6_start_gc(info->nl_net, rt);\n\t\tif (!(rt->rt6i_flags & RTF_CACHE))\n\t\t\tfib6_prune_clones(info->nl_net, pn, rt);\n\t}\n\nout:\n\tif (err) {\n#ifdef CONFIG_IPV6_SUBTREES\n\t\t/*\n\t\t * If fib6_add_1 has cleared the old leaf pointer in the\n\t\t * super-tree leaf node we have to find a new one for it.\n\t\t */\n\t\tif (pn != fn && pn->leaf == rt) {\n\t\t\tpn->leaf = NULL;\n\t\t\tatomic_dec(&rt->rt6i_ref);\n\t\t}\n\t\tif (pn != fn && !pn->leaf && !(pn->fn_flags & RTN_RTINFO)) {\n\t\t\tpn->leaf = fib6_find_prefix(info->nl_net, pn);\n#if RT6_DEBUG >= 2\n\t\t\tif (!pn->leaf) {\n\t\t\t\tWARN_ON(pn->leaf == NULL);\n\t\t\t\tpn->leaf = info->nl_net->ipv6.ip6_null_entry;\n\t\t\t}\n#endif\n\t\t\tatomic_inc(&pn->leaf->rt6i_ref);\n\t\t}\n#endif\n\t\tdst_free(&rt->dst);\n\t}\n\treturn err;\n\n#ifdef CONFIG_IPV6_SUBTREES\n\t/* Subtree creation failed, probably main tree node\n\t   is orphan. If it is, shoot it.\n\t */\nst_failure:\n\tif (fn && !(fn->fn_flags & (RTN_RTINFO|RTN_ROOT)))\n\t\tfib6_repair_tree(info->nl_net, fn);\n\tdst_free(&rt->dst);\n\treturn err;\n#endif\n}\n", "target": 1, "idx": 179110}
{"func": "bool Document::cssGridLayoutEnabled() const\n{\n    return settings() && settings()->cssGridLayoutEnabled();\n}\n", "target": 0, "idx": 112430}
{"func": "void EncoderTest::MismatchHook(const vpx_image_t *img1,\n                               const vpx_image_t *img2) {\n   ASSERT_TRUE(0) << \"Encode/Decode mismatch found\";\n }\n", "target": 1, "idx": 188561}
{"func": " static OPJ_BOOL bmp_read_rle8_data(FILE* IN, OPJ_UINT8* pData,\n                                    OPJ_UINT32 stride, OPJ_UINT32 width, OPJ_UINT32 height)\n {\n    OPJ_UINT32 x, y;\n     OPJ_UINT8 *pix;\n     const OPJ_UINT8 *beyond;\n \n     beyond = pData + stride * height;\n     pix = pData;\n \n    x = y = 0U;\n     while (y < height) {\n         int c = getc(IN);\n         if (c == EOF) {\n            return OPJ_FALSE;\n        }\n\n        if (c) {\n            int j, c1_int;\n            OPJ_UINT8 c1;\n\n            c1_int = getc(IN);\n            if (c1_int == EOF) {\n                return OPJ_FALSE;\n            }\n            c1 = (OPJ_UINT8)c1_int;\n\n             for (j = 0; (j < c) && (x < width) &&\n                     ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {\n                 *pix = c1;\n             }\n         } else {\n             c = getc(IN);\n            if (c == EOF) {\n                return OPJ_FALSE;\n            }\n\n            if (c == 0x00) { /* EOL */\n                x = 0;\n                ++y;\n                pix = pData + y * stride + x;\n            } else if (c == 0x01) { /* EOP */\n                break;\n            } else if (c == 0x02) { /* MOVE by dxdy */\n                c = getc(IN);\n                if (c == EOF) {\n                    return OPJ_FALSE;\n                }\n                x += (OPJ_UINT32)c;\n                c = getc(IN);\n                if (c == EOF) {\n                    return OPJ_FALSE;\n                }\n                y += (OPJ_UINT32)c;\n                pix = pData + y * stride + x;\n            } else { /* 03 .. 255 */\n                int j;\n                for (j = 0; (j < c) && (x < width) &&\n                        ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {\n                    int c1_int;\n                    OPJ_UINT8 c1;\n                    c1_int = getc(IN);\n                    if (c1_int == EOF) {\n                        return OPJ_FALSE;\n                     }\n                     c1 = (OPJ_UINT8)c1_int;\n                     *pix = c1;\n                 }\n                 if ((OPJ_UINT32)c & 1U) { /* skip padding byte */\n                     c = getc(IN);\n                    if (c == EOF) {\n                        return OPJ_FALSE;\n                    }\n                }\n             }\n         }\n     }/* while() */\n     return OPJ_TRUE;\n }\n", "target": 1, "idx": 182821}
{"func": " static void cp2112_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tint ret;\n\n\tmutex_lock(&dev->lock);\n\n\tbuf[0] = CP2112_GPIO_SET;\n\tbuf[1] = value ? 0xff : 0;\n\tbuf[2] = 1 << offset;\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_SET, buf,\n\t\t\t\t CP2112_GPIO_SET_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n\tif (ret < 0)\n\t\thid_err(hdev, \"error setting GPIO values: %d\\n\", ret);\n\n\tmutex_unlock(&dev->lock);\n}\n", "target": 0, "idx": 66452}
{"func": "void InitializePrinting(content::WebContents* web_contents) {\n#if BUILDFLAG(ENABLE_PRINT_PREVIEW)\n  printing::PrintViewManager::CreateForWebContents(web_contents);\n  printing::PrintPreviewMessageHandler::CreateForWebContents(web_contents);\n #else\n   printing::PrintViewManagerBasic::CreateForWebContents(web_contents);\n #endif  // BUILDFLAG(ENABLE_PRINT_PREVIEW)\n }\n", "target": 1, "idx": 185772}
{"func": "ar6000_aggr_rcv_addba_req_evt(struct ar6_softc *ar, WMI_ADDBA_REQ_EVENT *evt)\n{\n    if(evt->status == 0) {\n        aggr_recv_addba_req_evt(ar->aggr_cntxt, evt->tid, evt->st_seq_no, evt->win_sz);\n    }\n}\n", "target": 0, "idx": 24144}
{"func": "void ExtensionService::ClearProvidersForTesting() {\n  external_extension_providers_.clear();\n}\n", "target": 0, "idx": 103432}
{"func": "InspectorOverlay::InspectorOverlay(Page* page, InspectorClient* client)\n    : m_page(page)\n    , m_client(client)\n    , m_inspectModeEnabled(false)\n    , m_drawViewSize(false)\n     , m_drawViewSizeWithGrid(false)\n     , m_timer(this, &InspectorOverlay::onTimer)\n     , m_overlayHost(InspectorOverlayHost::create())\n    , m_overrides(0)\n    , m_overridesTopOffset(0)\n {\n }\n", "target": 1, "idx": 184228}
{"func": "bool base64Decode(const UChar* data, unsigned length, Vector<char>& out, CharacterMatchFunctionPtr shouldIgnoreCharacter, Base64DecodePolicy policy)\n{\n    return base64DecodeInternal<UChar>(data, length, out, shouldIgnoreCharacter, policy);\n}\n", "target": 0, "idx": 130202}
{"func": "void AXLayoutObject::handleAriaExpandedChanged() {\n  AXObject* containerParent = this->parentObject();\n  while (containerParent) {\n    bool foundParent = false;\n\n    switch (containerParent->roleValue()) {\n      case TreeRole:\n      case TreeGridRole:\n      case GridRole:\n      case TableRole:\n        foundParent = true;\n        break;\n      default:\n        break;\n    }\n\n    if (foundParent)\n      break;\n\n    containerParent = containerParent->parentObject();\n  }\n\n  if (containerParent)\n    axObjectCache().postNotification(containerParent,\n                                     AXObjectCacheImpl::AXRowCountChanged);\n\n  AccessibilityExpanded expanded = isExpanded();\n  if (!expanded)\n    return;\n\n  if (roleValue() == RowRole || roleValue() == TreeItemRole) {\n    AXObjectCacheImpl::AXNotification notification =\n        AXObjectCacheImpl::AXRowExpanded;\n    if (expanded == ExpandedCollapsed)\n      notification = AXObjectCacheImpl::AXRowCollapsed;\n\n    axObjectCache().postNotification(this, notification);\n  } else {\n    axObjectCache().postNotification(this,\n                                     AXObjectCacheImpl::AXExpandedChanged);\n  }\n}\n", "target": 0, "idx": 137946}
{"func": "box_ge(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box1 = PG_GETARG_BOX_P(0);\n\tBOX\t\t   *box2 = PG_GETARG_BOX_P(1);\n\n\tPG_RETURN_BOOL(FPge(box_ar(box1), box_ar(box2)));\n}\n", "target": 0, "idx": 38810}
{"func": "static void rdma_umap_open(struct vm_area_struct *vma)\n{\n\tstruct ib_uverbs_file *ufile = vma->vm_file->private_data;\n\tstruct rdma_umap_priv *opriv = vma->vm_private_data;\n\tstruct rdma_umap_priv *priv;\n\n\tif (!opriv)\n\t\treturn;\n\n\t/* We are racing with disassociation */\n\tif (!down_read_trylock(&ufile->hw_destroy_rwsem))\n\t\tgoto out_zap;\n\t/*\n\t * Disassociation already completed, the VMA should already be zapped.\n\t */\n\tif (!ufile->ucontext)\n\t\tgoto out_unlock;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\tgoto out_unlock;\n\trdma_umap_priv_init(priv, vma);\n\n\tup_read(&ufile->hw_destroy_rwsem);\n\treturn;\n\nout_unlock:\n\tup_read(&ufile->hw_destroy_rwsem);\nout_zap:\n\t/*\n\t * We can't allow the VMA to be created with the actual IO pages, that\n\t * would break our API contract, and it can't be stopped at this\n\t * point, so zap it.\n\t */\n\tvma->vm_private_data = NULL;\n\tzap_vma_ptes(vma, vma->vm_start, vma->vm_end - vma->vm_start);\n}\n", "target": 0, "idx": 90474}
{"func": " void CoordinatorImpl::RequestGlobalMemoryDump(\n     MemoryDumpType dump_type,\n     MemoryDumpLevelOfDetail level_of_detail,\n     const std::vector<std::string>& allocator_dump_names,\n     const RequestGlobalMemoryDumpCallback& callback) {\n   auto adapter = [](const RequestGlobalMemoryDumpCallback& callback,\n                     bool success, uint64_t,\n                    mojom::GlobalMemoryDumpPtr global_memory_dump) {\n    callback.Run(success, std::move(global_memory_dump));\n  };\n\n  QueuedRequest::Args args(dump_type, level_of_detail, allocator_dump_names,\n                           false /* add_to_trace */, base::kNullProcessId);\n  RequestGlobalMemoryDumpInternal(args, base::BindRepeating(adapter, callback));\n}\n", "target": 1, "idx": 186892}
{"func": "bool LayerTreeHostQt::layerTreeTileUpdatesAllowed() const\n{\n    return !m_isSuspended && !m_waitingForUIProcess;\n}\n", "target": 0, "idx": 107134}
{"func": "xsltApplyTemplates(xsltTransformContextPtr ctxt, xmlNodePtr node,\n\t           xmlNodePtr inst, xsltStylePreCompPtr castedComp)\n{\n#ifdef XSLT_REFACTORED\n    xsltStyleItemApplyTemplatesPtr comp =\n\t(xsltStyleItemApplyTemplatesPtr) castedComp;\n#else\n    xsltStylePreCompPtr comp = castedComp;\n#endif\n    int i;\n     xmlNodePtr cur, delNode = NULL, oldContextNode;\n     xmlNodeSetPtr list = NULL, oldList;\n     xsltStackElemPtr withParams = NULL;\n    int oldXPProximityPosition, oldXPContextSize, oldXPNsNr;\n     const xmlChar *oldMode, *oldModeURI;\n     xmlDocPtr oldXPDoc;\n     xsltDocumentPtr oldDocInfo;\n     xmlXPathContextPtr xpctxt;\n    xmlNsPtr *oldXPNamespaces;\n \n     if (comp == NULL) {\n \txsltTransformError(ctxt, NULL, inst,\n\t     \"xsl:apply-templates : compilation failed\\n\");\n\treturn;\n    }\n    if ((ctxt == NULL) || (node == NULL) || (inst == NULL) || (comp == NULL))\n\treturn;\n\n#ifdef WITH_XSLT_DEBUG_PROCESS\n    if ((node != NULL) && (node->name != NULL))\n\tXSLT_TRACE(ctxt,XSLT_TRACE_APPLY_TEMPLATES,xsltGenericDebug(xsltGenericDebugContext,\n\t     \"xsltApplyTemplates: node: '%s'\\n\", node->name));\n#endif\n\n    xpctxt = ctxt->xpathCtxt;\n    /*\n    * Save context states.\n    */\n    oldContextNode = ctxt->node;\n    oldMode = ctxt->mode;\n    oldModeURI = ctxt->modeURI;\n    oldDocInfo = ctxt->document;\n    oldList = ctxt->nodeList;\n\n    /*\n     * The xpath context size and proximity position, as\n     * well as the xpath and context documents, may be changed\n     * so we save their initial state and will restore on exit\n     */\n     oldXPContextSize = xpctxt->contextSize;\n     oldXPProximityPosition = xpctxt->proximityPosition;\n     oldXPDoc = xpctxt->doc;\n    oldXPNsNr = xpctxt->nsNr;\n    oldXPNamespaces = xpctxt->namespaces;\n \n     /*\n     * Set up contexts.\n    */\n    ctxt->mode = comp->mode;\n    ctxt->modeURI = comp->modeURI;\n\n    if (comp->select != NULL) {\n\txmlXPathObjectPtr res = NULL;\n\n\tif (comp->comp == NULL) {\n\t    xsltTransformError(ctxt, NULL, inst,\n\t\t \"xsl:apply-templates : compilation failed\\n\");\n\t    goto error;\n\t}\n#ifdef WITH_XSLT_DEBUG_PROCESS\n\tXSLT_TRACE(ctxt,XSLT_TRACE_APPLY_TEMPLATES,xsltGenericDebug(xsltGenericDebugContext,\n \t     \"xsltApplyTemplates: select %s\\n\", comp->select));\n #endif\n \n\t/*\n\t* Set up XPath.\n\t*/\n\txpctxt->node = node; /* Set the \"context node\" */\n#ifdef XSLT_REFACTORED\n\tif (comp->inScopeNs != NULL) {\n\t    xpctxt->namespaces = comp->inScopeNs->list;\n\t    xpctxt->nsNr = comp->inScopeNs->xpathNumber;\n\t} else {\n\t    xpctxt->namespaces = NULL;\n\t    xpctxt->nsNr = 0;\n\t}\n#else\n\txpctxt->namespaces = comp->nsList;\n\txpctxt->nsNr = comp->nsNr;\n#endif\n\tres = xmlXPathCompiledEval(comp->comp, xpctxt);\n \n\txpctxt->contextSize = oldXPContextSize;\n\txpctxt->proximityPosition = oldXPProximityPosition;\n \tif (res != NULL) {\n \t    if (res->type == XPATH_NODESET) {\n \t\tlist = res->nodesetval; /* consume the node set */\n\t\tres->nodesetval = NULL;\n\t    } else {\n\t\txsltTransformError(ctxt, NULL, inst,\n\t\t    \"The 'select' expression did not evaluate to a \"\n\t\t    \"node set.\\n\");\n\t\tctxt->state = XSLT_STATE_STOPPED;\n\t\txmlXPathFreeObject(res);\n\t\tgoto error;\n\t    }\n\t    xmlXPathFreeObject(res);\n\t    /*\n\t    * Note: An xsl:apply-templates with a 'select' attribute,\n\t    * can change the current source doc.\n\t    */\n\t} else {\n\t    xsltTransformError(ctxt, NULL, inst,\n\t\t\"Failed to evaluate the 'select' expression.\\n\");\n\t    ctxt->state = XSLT_STATE_STOPPED;\n\t    goto error;\n\t}\n\tif (list == NULL) {\n#ifdef WITH_XSLT_DEBUG_PROCESS\n\t    XSLT_TRACE(ctxt,XSLT_TRACE_APPLY_TEMPLATES,xsltGenericDebug(xsltGenericDebugContext,\n\t\t\"xsltApplyTemplates: select didn't evaluate to a node list\\n\"));\n#endif\n\t    goto exit;\n\t}\n\t/*\n\t*\n\t* NOTE: Previously a document info (xsltDocument) was\n\t* created and attached to the Result Tree Fragment.\n\t* But such a document info is created on demand in\n\t* xsltKeyFunction() (functions.c), so we need to create\n\t* it here beforehand.\n\t* In order to take care of potential keys we need to\n\t* do some extra work for the case when a Result Tree Fragment\n\t* is converted into a nodeset (e.g. exslt:node-set()) :\n\t* We attach a \"pseudo-doc\" (xsltDocument) to _private.\n\t* This xsltDocument, together with the keyset, will be freed\n\t* when the Result Tree Fragment is freed.\n\t*\n\t*/\n#if 0\n\tif ((ctxt->nbKeys > 0) &&\n\t    (list->nodeNr != 0) &&\n\t    (list->nodeTab[0]->doc != NULL) &&\n\t    XSLT_IS_RES_TREE_FRAG(list->nodeTab[0]->doc))\n\t{\n\t    /*\n\t    * NOTE that it's also OK if @effectiveDocInfo will be\n\t    * set to NULL.\n\t    */\n\t    isRTF = 1;\n\t    effectiveDocInfo = list->nodeTab[0]->doc->_private;\n\t}\n#endif\n    } else {\n\t/*\n\t * Build an XPath node set with the children\n\t */\n\tlist = xmlXPathNodeSetCreate(NULL);\n\tif (list == NULL)\n\t    goto error;\n\tif (node->type != XML_NAMESPACE_DECL)\n\t    cur = node->children;\n\telse\n\t    cur = NULL;\n\twhile (cur != NULL) {\n\t    switch (cur->type) {\n\t\tcase XML_TEXT_NODE:\n\t\t    if ((IS_BLANK_NODE(cur)) &&\n\t\t\t(cur->parent != NULL) &&\n\t\t\t(cur->parent->type == XML_ELEMENT_NODE) &&\n\t\t\t(ctxt->style->stripSpaces != NULL)) {\n\t\t\tconst xmlChar *val;\n\n\t\t\tif (cur->parent->ns != NULL) {\n\t\t\t    val = (const xmlChar *)\n\t\t\t\t  xmlHashLookup2(ctxt->style->stripSpaces,\n\t\t\t\t\t\t cur->parent->name,\n\t\t\t\t\t\t cur->parent->ns->href);\n\t\t\t    if (val == NULL) {\n\t\t\t\tval = (const xmlChar *)\n\t\t\t\t  xmlHashLookup2(ctxt->style->stripSpaces,\n\t\t\t\t\t\t BAD_CAST \"*\",\n\t\t\t\t\t\t cur->parent->ns->href);\n\t\t\t    }\n\t\t\t} else {\n\t\t\t    val = (const xmlChar *)\n\t\t\t\t  xmlHashLookup2(ctxt->style->stripSpaces,\n\t\t\t\t\t\t cur->parent->name, NULL);\n\t\t\t}\n\t\t\tif ((val != NULL) &&\n\t\t\t    (xmlStrEqual(val, (xmlChar *) \"strip\"))) {\n\t\t\t    delNode = cur;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    /* no break on purpose */\n\t\tcase XML_ELEMENT_NODE:\n\t\tcase XML_DOCUMENT_NODE:\n\t\tcase XML_HTML_DOCUMENT_NODE:\n\t\tcase XML_CDATA_SECTION_NODE:\n\t\tcase XML_PI_NODE:\n\t\tcase XML_COMMENT_NODE:\n\t\t    xmlXPathNodeSetAddUnique(list, cur);\n\t\t    break;\n\t\tcase XML_DTD_NODE:\n\t\t    /* Unlink the DTD, it's still reachable\n\t\t     * using doc->intSubset */\n\t\t    if (cur->next != NULL)\n\t\t\tcur->next->prev = cur->prev;\n\t\t    if (cur->prev != NULL)\n\t\t\tcur->prev->next = cur->next;\n\t\t    break;\n\t\tcase XML_NAMESPACE_DECL:\n\t\t    break;\n\t\tdefault:\n#ifdef WITH_XSLT_DEBUG_PROCESS\n\t\t    XSLT_TRACE(ctxt,XSLT_TRACE_APPLY_TEMPLATES,xsltGenericDebug(xsltGenericDebugContext,\n\t\t     \"xsltApplyTemplates: skipping cur type %d\\n\",\n\t\t\t\t     cur->type));\n#endif\n\t\t    delNode = cur;\n\t    }\n\t    cur = cur->next;\n\t    if (delNode != NULL) {\n#ifdef WITH_XSLT_DEBUG_PROCESS\n\t\tXSLT_TRACE(ctxt,XSLT_TRACE_APPLY_TEMPLATES,xsltGenericDebug(xsltGenericDebugContext,\n\t\t     \"xsltApplyTemplates: removing ignorable blank cur\\n\"));\n#endif\n\t\txmlUnlinkNode(delNode);\n\t\txmlFreeNode(delNode);\n\t\tdelNode = NULL;\n\t    }\n\t}\n    }\n\n#ifdef WITH_XSLT_DEBUG_PROCESS\n    if (list != NULL)\n    XSLT_TRACE(ctxt,XSLT_TRACE_APPLY_TEMPLATES,xsltGenericDebug(xsltGenericDebugContext,\n\t\"xsltApplyTemplates: list of %d nodes\\n\", list->nodeNr));\n#endif\n\n    if ((list == NULL) || (list->nodeNr == 0))\n\tgoto exit;\n\n    /*\n    * Set the context's node set and size; this is also needed for\n    * for xsltDoSortFunction().\n    */\n    ctxt->nodeList = list;\n    /*\n    * Process xsl:with-param and xsl:sort instructions.\n    * (The code became so verbose just to avoid the\n    *  xmlNodePtr sorts[XSLT_MAX_SORT] if there's no xsl:sort)\n    * BUG TODO: We are not using namespaced potentially defined on the\n    * xsl:sort or xsl:with-param elements; XPath expression might fail.\n    */\n    if (inst->children) {\n\txsltStackElemPtr param;\n\n\tcur = inst->children;\n\twhile (cur) {\n\n#ifdef WITH_DEBUGGER\n\t    if (ctxt->debugStatus != XSLT_DEBUG_NONE)\n\t\txslHandleDebugger(cur, node, NULL, ctxt);\n#endif\n\t    if (ctxt->state == XSLT_STATE_STOPPED)\n\t\tbreak;\n\t    if (cur->type == XML_TEXT_NODE) {\n\t\tcur = cur->next;\n\t\tcontinue;\n\t    }\n\t    if (! IS_XSLT_ELEM(cur))\n\t\tbreak;\n\t    if (IS_XSLT_NAME(cur, \"with-param\")) {\n\t\tparam = xsltParseStylesheetCallerParam(ctxt, cur);\n\t\tif (param != NULL) {\n\t\t    param->next = withParams;\n\t\t    withParams = param;\n\t\t}\n\t    }\n\t    if (IS_XSLT_NAME(cur, \"sort\")) {\n\t\txsltTemplatePtr oldCurTempRule =\n\t\t    ctxt->currentTemplateRule;\n\t\tint nbsorts = 0;\n\t\txmlNodePtr sorts[XSLT_MAX_SORT];\n\n\t\tsorts[nbsorts++] = cur;\n\n\t\twhile (cur) {\n\n#ifdef WITH_DEBUGGER\n\t\t    if (ctxt->debugStatus != XSLT_DEBUG_NONE)\n\t\t\txslHandleDebugger(cur, node, NULL, ctxt);\n#endif\n\t\t    if (ctxt->state == XSLT_STATE_STOPPED)\n\t\t\tbreak;\n\n\t\t    if (cur->type == XML_TEXT_NODE) {\n\t\t\tcur = cur->next;\n\t\t\tcontinue;\n\t\t    }\n\n\t\t    if (! IS_XSLT_ELEM(cur))\n\t\t\tbreak;\n\t\t    if (IS_XSLT_NAME(cur, \"with-param\")) {\n\t\t\tparam = xsltParseStylesheetCallerParam(ctxt, cur);\n\t\t\tif (param != NULL) {\n\t\t\t    param->next = withParams;\n\t\t\t    withParams = param;\n\t\t\t}\n\t\t    }\n\t\t    if (IS_XSLT_NAME(cur, \"sort\")) {\n\t\t\tif (nbsorts >= XSLT_MAX_SORT) {\n\t\t\t    xsltTransformError(ctxt, NULL, cur,\n\t\t\t\t\"The number (%d) of xsl:sort instructions exceeds the \"\n\t\t\t\t\"maximum allowed by this processor's settings.\\n\",\n\t\t\t\tnbsorts);\n\t\t\t    ctxt->state = XSLT_STATE_STOPPED;\n\t\t\t    break;\n\t\t\t} else {\n\t\t\t    sorts[nbsorts++] = cur;\n\t\t\t}\n\t\t    }\n\t\t    cur = cur->next;\n\t\t}\n\t\t/*\n\t\t* The \"current template rule\" is cleared for xsl:sort.\n\t\t*/\n\t\tctxt->currentTemplateRule = NULL;\n\t\t/*\n\t\t* Sort.\n\t\t*/\n\t\txsltDoSortFunction(ctxt, sorts, nbsorts);\n\t\tctxt->currentTemplateRule = oldCurTempRule;\n\t\tbreak;\n\t    }\n\t    cur = cur->next;\n\t}\n    }\n    xpctxt->contextSize = list->nodeNr;\n    /*\n    * Apply templates for all selected source nodes.\n    */\n    for (i = 0; i < list->nodeNr; i++) {\n\tcur = list->nodeTab[i];\n\t/*\n\t* The node becomes the \"current node\".\n\t*/\n\tctxt->node = cur;\n\t/*\n\t* An xsl:apply-templates can change the current context doc.\n\t* OPTIMIZE TODO: Get rid of the need to set the context doc.\n\t*/\n\tif ((cur->type != XML_NAMESPACE_DECL) && (cur->doc != NULL))\n\t    xpctxt->doc = cur->doc;\n\n\txpctxt->proximityPosition = i + 1;\n\t/*\n\t* Find and apply a template for this node.\n\t*/\n\txsltProcessOneNode(ctxt, cur, withParams);\n    }\n\nexit:\nerror:\n    /*\n    * Free the parameter list.\n    */\n    if (withParams != NULL)\n\txsltFreeStackElemList(withParams);\n    if (list != NULL)\n\txmlXPathFreeNodeSet(list);\n     /*\n     * Restore context states.\n     */\n    xpctxt->nsNr = oldXPNsNr;\n    xpctxt->namespaces = oldXPNamespaces;\n     xpctxt->doc = oldXPDoc;\n     xpctxt->contextSize = oldXPContextSize;\n     xpctxt->proximityPosition = oldXPProximityPosition;\n\n    ctxt->document = oldDocInfo;\n    ctxt->nodeList = oldList;\n    ctxt->node = oldContextNode;\n    ctxt->mode = oldMode;\n    ctxt->modeURI = oldModeURI;\n}\n", "target": 1, "idx": 187342}
{"func": "static int do_subdinfo_ioctl(struct comedi_device *dev,\n\t\t\t     struct comedi_subdinfo __user *arg, void *file)\n{\n\tint ret, i;\n\tstruct comedi_subdinfo *tmp, *us;\n\tstruct comedi_subdevice *s;\n\n\ttmp =\n\t    kcalloc(dev->n_subdevices, sizeof(struct comedi_subdinfo),\n\t\t    GFP_KERNEL);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\t/* fill subdinfo structs */\n\tfor (i = 0; i < dev->n_subdevices; i++) {\n\t\ts = dev->subdevices + i;\n\t\tus = tmp + i;\n\n\t\tus->type = s->type;\n\t\tus->n_chan = s->n_chan;\n\t\tus->subd_flags = s->subdev_flags;\n\t\tif (comedi_get_subdevice_runflags(s) & SRF_RUNNING)\n\t\t\tus->subd_flags |= SDF_RUNNING;\n#define TIMER_nanosec 5\t\t/* backwards compatibility */\n\t\tus->timer_type = TIMER_nanosec;\n\t\tus->len_chanlist = s->len_chanlist;\n\t\tus->maxdata = s->maxdata;\n\t\tif (s->range_table) {\n\t\t\tus->range_type =\n\t\t\t    (i << 24) | (0 << 16) | (s->range_table->length);\n\t\t} else {\n\t\t\tus->range_type = 0;\t/* XXX */\n\t\t}\n\t\tus->flags = s->flags;\n\n\t\tif (s->busy)\n\t\t\tus->subd_flags |= SDF_BUSY;\n\t\tif (s->busy == file)\n\t\t\tus->subd_flags |= SDF_BUSY_OWNER;\n\t\tif (s->lock)\n\t\t\tus->subd_flags |= SDF_LOCKED;\n\t\tif (s->lock == file)\n\t\t\tus->subd_flags |= SDF_LOCK_OWNER;\n\t\tif (!s->maxdata && s->maxdata_list)\n\t\t\tus->subd_flags |= SDF_MAXDATA;\n\t\tif (s->flaglist)\n\t\t\tus->subd_flags |= SDF_FLAGS;\n\t\tif (s->range_table_list)\n\t\t\tus->subd_flags |= SDF_RANGETYPE;\n\t\tif (s->do_cmd)\n\t\t\tus->subd_flags |= SDF_CMD;\n\n\t\tif (s->insn_bits != &insn_inval)\n\t\t\tus->insn_bits_support = COMEDI_SUPPORTED;\n\t\telse\n\t\t\tus->insn_bits_support = COMEDI_UNSUPPORTED;\n\n\t\tus->settling_time_0 = s->settling_time_0;\n\t}\n\n\tret = copy_to_user(arg, tmp,\n\t\t\t   dev->n_subdevices * sizeof(struct comedi_subdinfo));\n\n\tkfree(tmp);\n\n\treturn ret ? -EFAULT : 0;\n}\n", "target": 0, "idx": 41304}
{"func": "AudioParameters GetInputParametersOnDeviceThread(AudioManager* audio_manager,\n                                                 const std::string& device_id) {\n   DCHECK(audio_manager->GetTaskRunner()->BelongsToCurrentThread());\n \n   if (!audio_manager->HasAudioInputDevices())\n     return AudioParameters();\n \n   return audio_manager->GetInputStreamParameters(device_id);\n }\n", "target": 1, "idx": 185866}
{"func": "GF_Err dinf_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e = gf_isom_box_array_read(s, bs, dinf_AddBox);\n\tif (e) {\n \t\treturn e;\n \t}\n \tif (!((GF_DataInformationBox *)s)->dref) {\n \t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing dref box in dinf\\n\"));\n\t\t((GF_DataInformationBox *)s)->dref = (GF_DataReferenceBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF);\n \t}\n \treturn GF_OK;\n }\n", "target": 1, "idx": 182931}
{"func": " ResizeGripper::ResizeGripper(ResizeGripperDelegate* delegate)\n    : delegate_(delegate), initial_position_(0) {\n   ResourceBundle &rb = ResourceBundle::GetSharedInstance();\n   SkBitmap* gripper_image = rb.GetBitmapNamed(IDR_RESIZE_GRIPPER);\n  SetImage(gripper_image);\n }\n", "target": 1, "idx": 183449}
{"func": "void __d_lookup_done(struct dentry *dentry)\n{\n\tstruct hlist_bl_head *b = in_lookup_hash(dentry->d_parent,\n\t\t\t\t\t\t dentry->d_name.hash);\n\thlist_bl_lock(b);\n\tdentry->d_flags &= ~DCACHE_PAR_LOOKUP;\n\t__hlist_bl_del(&dentry->d_u.d_in_lookup_hash);\n\twake_up_all(dentry->d_wait);\n\tdentry->d_wait = NULL;\n\thlist_bl_unlock(b);\n\tINIT_HLIST_NODE(&dentry->d_u.d_alias);\n\tINIT_LIST_HEAD(&dentry->d_lru);\n}\n", "target": 0, "idx": 67272}
{"func": "void DownloadController::CreateGETDownload(\n    const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n    bool must_download,\n    const DownloadInfo& info) {\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n  BrowserThread::PostTask(\n      BrowserThread::UI, FROM_HERE,\n      base::Bind(&DownloadController::StartAndroidDownload,\n                 base::Unretained(this),\n                 wc_getter, must_download, info));\n}\n", "target": 1, "idx": 185759}
{"func": "bool AXLayoutObject::isValidSelectionBound(const AXObject* boundObject) const {\n  return getLayoutObject() && boundObject && !boundObject->isDetached() &&\n         boundObject->isAXLayoutObject() && boundObject->getLayoutObject() &&\n         boundObject->getLayoutObject()->frame() ==\n             getLayoutObject()->frame() &&\n         &boundObject->axObjectCache() == &axObjectCache();\n}\n", "target": 0, "idx": 137963}
{"func": "static void nfs4_check_drain_fc_complete(struct nfs4_session *ses)\n{\n\tif (!test_bit(NFS4_SESSION_DRAINING, &ses->session_state)) {\n\t\trpc_wake_up_first(&ses->fc_slot_table.slot_tbl_waitq,\n\t\t\t\tnfs4_set_task_privileged, NULL);\n\t\treturn;\n\t}\n\n\tif (ses->fc_slot_table.highest_used_slotid != NFS4_NO_SLOT)\n\t\treturn;\n\n\tdprintk(\"%s COMPLETE: Session Fore Channel Drained\\n\", __func__);\n\tcomplete(&ses->fc_slot_table.complete);\n}\n", "target": 0, "idx": 19882}
{"func": "smb_send_kvec(struct TCP_Server_Info *server, struct kvec *iov, size_t n_vec,\n\t\tsize_t *sent)\n{\n\tint rc = 0;\n\tint i = 0;\n\tstruct msghdr smb_msg;\n\tunsigned int remaining;\n\tsize_t first_vec = 0;\n\tstruct socket *ssocket = server->ssocket;\n \n \t*sent = 0;\n \n\tif (ssocket == NULL)\n\t\treturn -ENOTSOCK; /* BB eventually add reconnect code here */\n \tsmb_msg.msg_name = (struct sockaddr *) &server->dstaddr;\n \tsmb_msg.msg_namelen = sizeof(struct sockaddr);\n \tsmb_msg.msg_control = NULL;\n\tsmb_msg.msg_controllen = 0;\n\tif (server->noblocksnd)\n\t\tsmb_msg.msg_flags = MSG_DONTWAIT + MSG_NOSIGNAL;\n\telse\n\t\tsmb_msg.msg_flags = MSG_NOSIGNAL;\n\n\tremaining = 0;\n\tfor (i = 0; i < n_vec; i++)\n\t\tremaining += iov[i].iov_len;\n\n\ti = 0;\n\twhile (remaining) {\n\t\t/*\n\t\t * If blocking send, we try 3 times, since each can block\n\t\t * for 5 seconds. For nonblocking  we have to try more\n\t\t * but wait increasing amounts of time allowing time for\n\t\t * socket to clear.  The overall time we wait in either\n\t\t * case to send on the socket is about 15 seconds.\n\t\t * Similarly we wait for 15 seconds for a response from\n\t\t * the server in SendReceive[2] for the server to send\n\t\t * a response back for most types of requests (except\n\t\t * SMB Write past end of file which can be slow, and\n\t\t * blocking lock operations). NFS waits slightly longer\n\t\t * than CIFS, but this can make it take longer for\n\t\t * nonresponsive servers to be detected and 15 seconds\n\t\t * is more than enough time for modern networks to\n\t\t * send a packet.  In most cases if we fail to send\n\t\t * after the retries we will kill the socket and\n\t\t * reconnect which may clear the network problem.\n\t\t */\n\t\trc = kernel_sendmsg(ssocket, &smb_msg, &iov[first_vec],\n\t\t\t\t    n_vec - first_vec, remaining);\n\t\tif (rc == -ENOSPC || rc == -EAGAIN) {\n\t\t\t/*\n\t\t\t * Catch if a low level driver returns -ENOSPC. This\n\t\t\t * WARN_ON will be removed by 3.10 if no one reports\n\t\t\t * seeing this.\n\t\t\t */\n\t\t\tWARN_ON_ONCE(rc == -ENOSPC);\n\t\t\ti++;\n\t\t\tif (i >= 14 || (!server->noblocksnd && (i > 2))) {\n\t\t\t\tcERROR(1, \"sends on sock %p stuck for 15 \"\n\t\t\t\t\t  \"seconds\", ssocket);\n\t\t\t\trc = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmsleep(1 << i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (rc < 0)\n\t\t\tbreak;\n\n\t\t/* send was at least partially successful */\n\t\t*sent += rc;\n\n\t\tif (rc == remaining) {\n\t\t\tremaining = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rc > remaining) {\n\t\t\tcERROR(1, \"sent %d requested %d\", rc, remaining);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rc == 0) {\n\t\t\t/* should never happen, letting socket clear before\n\t\t\t   retrying is our only obvious option here */\n\t\t\tcERROR(1, \"tcp sent no data\");\n\t\t\tmsleep(500);\n\t\t\tcontinue;\n\t\t}\n\n\t\tremaining -= rc;\n\n\t\t/* the line below resets i */\n\t\tfor (i = first_vec; i < n_vec; i++) {\n\t\t\tif (iov[i].iov_len) {\n\t\t\t\tif (rc > iov[i].iov_len) {\n\t\t\t\t\trc -= iov[i].iov_len;\n\t\t\t\t\tiov[i].iov_len = 0;\n\t\t\t\t} else {\n\t\t\t\t\tiov[i].iov_base += rc;\n\t\t\t\t\tiov[i].iov_len -= rc;\n\t\t\t\t\tfirst_vec = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ti = 0; /* in case we get ENOSPC on the next send */\n\t\trc = 0;\n\t}\n\treturn rc;\n}\n", "target": 1, "idx": 179197}
{"func": " bool Cues::Find(long long time_ns, const Track* pTrack, const CuePoint*& pCP,\n                 const CuePoint::TrackPosition*& pTP) const {\n  assert(time_ns >= 0);\n  assert(pTrack);\n#if 0\n    LoadCuePoint();  //establish invariant\n    assert(m_cue_points);\n    assert(m_count > 0);\n    CuePoint** const ii = m_cue_points;\n    CuePoint** i = ii;\n    CuePoint** const jj = ii + m_count + m_preload_count;\n    CuePoint** j = jj;\n    pCP = *i;\n    assert(pCP);\n    if (time_ns <= pCP->GetTime(m_pSegment))\n    {\n        pTP = pCP->Find(pTrack);\n        return (pTP != NULL);\n    }\n    IMkvReader* const pReader = m_pSegment->m_pReader;\n    while (i < j)\n    {\n        CuePoint** const k = i + (j - i) / 2;\n        assert(k < jj);\n        CuePoint* const pCP = *k;\n        assert(pCP);\n        pCP->Load(pReader);\n        const long long t = pCP->GetTime(m_pSegment);\n        if (t <= time_ns)\n            i = k + 1;\n        else\n            j = k;\n        assert(i <= j);\n    }\n    assert(i == j);\n    assert(i <= jj);\n    assert(i > ii);\n    pCP = *--i;\n    assert(pCP);\n    assert(pCP->GetTime(m_pSegment) <= time_ns);\n#else\n  if (m_cue_points == NULL)\n    return false;\n  if (m_count == 0)\n     return false;\n \n   CuePoint** const ii = m_cue_points;\n CuePoint** i = ii;\n\n CuePoint** const jj = ii + m_count;\n\n   CuePoint** j = jj;\n \n   pCP = *i;\n  assert(pCP);\n \n   if (time_ns <= pCP->GetTime(m_pSegment)) {\n     pTP = pCP->Find(pTrack);\n return (pTP != NULL);\n }\n\n while (i < j) {\n\n \n     CuePoint** const k = i + (j - i) / 2;\n    assert(k < jj);\n \n     CuePoint* const pCP = *k;\n    assert(pCP);\n \n     const long long t = pCP->GetTime(m_pSegment);\n \n if (t <= time_ns)\n      i = k + 1;\n\n     else\n       j = k;\n \n    assert(i <= j);\n   }\n \n  assert(i == j);\n  assert(i <= jj);\n  assert(i > ii);\n \n   pCP = *--i;\n  assert(pCP);\n  assert(pCP->GetTime(m_pSegment) <= time_ns);\n#endif\n \n\n  pTP = pCP->Find(pTrack);\n\n   return (pTP != NULL);\n }\n", "target": 1, "idx": 187833}
{"func": "static void v9fs_setattr(void *opaque)\n{\n    int err = 0;\n    int32_t fid;\n    V9fsFidState *fidp;\n    size_t offset = 7;\n    V9fsIattr v9iattr;\n    V9fsPDU *pdu = opaque;\n\n    err = pdu_unmarshal(pdu, offset, \"dI\", &fid, &v9iattr);\n    if (err < 0) {\n        goto out_nofid;\n    }\n\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    if (v9iattr.valid & P9_ATTR_MODE) {\n        err = v9fs_co_chmod(pdu, &fidp->path, v9iattr.mode);\n        if (err < 0) {\n            goto out;\n        }\n    }\n    if (v9iattr.valid & (P9_ATTR_ATIME | P9_ATTR_MTIME)) {\n        struct timespec times[2];\n        if (v9iattr.valid & P9_ATTR_ATIME) {\n            if (v9iattr.valid & P9_ATTR_ATIME_SET) {\n                times[0].tv_sec = v9iattr.atime_sec;\n                times[0].tv_nsec = v9iattr.atime_nsec;\n            } else {\n                times[0].tv_nsec = UTIME_NOW;\n            }\n        } else {\n            times[0].tv_nsec = UTIME_OMIT;\n        }\n        if (v9iattr.valid & P9_ATTR_MTIME) {\n            if (v9iattr.valid & P9_ATTR_MTIME_SET) {\n                times[1].tv_sec = v9iattr.mtime_sec;\n                times[1].tv_nsec = v9iattr.mtime_nsec;\n            } else {\n                times[1].tv_nsec = UTIME_NOW;\n            }\n        } else {\n            times[1].tv_nsec = UTIME_OMIT;\n        }\n        err = v9fs_co_utimensat(pdu, &fidp->path, times);\n        if (err < 0) {\n            goto out;\n        }\n    }\n    /*\n     * If the only valid entry in iattr is ctime we can call\n     * chown(-1,-1) to update the ctime of the file\n     */\n    if ((v9iattr.valid & (P9_ATTR_UID | P9_ATTR_GID)) ||\n        ((v9iattr.valid & P9_ATTR_CTIME)\n         && !((v9iattr.valid & P9_ATTR_MASK) & ~P9_ATTR_CTIME))) {\n        if (!(v9iattr.valid & P9_ATTR_UID)) {\n            v9iattr.uid = -1;\n        }\n        if (!(v9iattr.valid & P9_ATTR_GID)) {\n            v9iattr.gid = -1;\n        }\n        err = v9fs_co_chown(pdu, &fidp->path, v9iattr.uid,\n                            v9iattr.gid);\n        if (err < 0) {\n            goto out;\n        }\n    }\n    if (v9iattr.valid & (P9_ATTR_SIZE)) {\n        err = v9fs_co_truncate(pdu, &fidp->path, v9iattr.size);\n        if (err < 0) {\n            goto out;\n        }\n    }\n    err = offset;\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n}\n", "target": 0, "idx": 8234}
{"func": "static Image *ReadRLAImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  typedef struct _WindowFrame\n  {\n    short\n      left,\n      right,\n      bottom,\n      top;\n  } WindowFrame;\n\n  typedef struct _RLAInfo\n  {\n    WindowFrame\n      window,\n      active_window;\n\n    short\n      frame,\n      storage_type,\n      number_channels,\n      number_matte_channels,\n      number_auxiliary_channels,\n      revision;\n\n    char\n      gamma[16],\n      red_primary[24],\n      green_primary[24],\n      blue_primary[24],\n      white_point[24];\n\n    ssize_t\n      job_number;\n\n    char\n      name[128],\n      description[128],\n      program[64],\n      machine[32],\n      user[32],\n      date[20],\n      aspect[24],\n      aspect_ratio[8],\n      chan[32];\n\n    short\n      field;\n\n    char\n      time[12],\n      filter[32];\n\n    short\n      bits_per_channel,\n      matte_type,\n      matte_bits,\n      auxiliary_type,\n      auxiliary_bits;\n\n    char\n      auxiliary[32],\n      space[36];\n\n    ssize_t\n      next;\n  } RLAInfo;\n\n  Image\n    *image;\n\n  int\n    channel,\n    length,\n    runlength;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  register ssize_t\n    i,\n    x;\n\n  register PixelPacket\n    *q;\n\n  ssize_t\n    count,\n    *scanlines,\n    y;\n\n  RLAInfo\n    rla_info;\n\n  unsigned char\n    byte;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  rla_info.window.left=(short) ReadBlobMSBShort(image);\n  rla_info.window.right=(short) ReadBlobMSBShort(image);\n  rla_info.window.bottom=(short) ReadBlobMSBShort(image);\n  rla_info.window.top=(short) ReadBlobMSBShort(image);\n  rla_info.active_window.left=(short) ReadBlobMSBShort(image);\n  rla_info.active_window.right=(short) ReadBlobMSBShort(image);\n  rla_info.active_window.bottom=(short) ReadBlobMSBShort(image);\n  rla_info.active_window.top=(short) ReadBlobMSBShort(image);\n  rla_info.frame=(short) ReadBlobMSBShort(image);\n  rla_info.storage_type=(short) ReadBlobMSBShort(image);\n  rla_info.number_channels=(short) ReadBlobMSBShort(image);\n  rla_info.number_matte_channels=(short) ReadBlobMSBShort(image);\n  if (rla_info.number_channels == 0)\n    rla_info.number_channels=3;\n  rla_info.number_channels+=rla_info.number_matte_channels;\n  rla_info.number_auxiliary_channels=(short) ReadBlobMSBShort(image);\n  rla_info.revision=(short) ReadBlobMSBShort(image);\n  count=ReadBlob(image,16,(unsigned char *) rla_info.gamma);\n  count=ReadBlob(image,24,(unsigned char *) rla_info.red_primary);\n  count=ReadBlob(image,24,(unsigned char *) rla_info.green_primary);\n  count=ReadBlob(image,24,(unsigned char *) rla_info.blue_primary);\n  count=ReadBlob(image,24,(unsigned char *) rla_info.white_point);\n  rla_info.job_number=(int) ReadBlobMSBLong(image);\n  count=ReadBlob(image,128,(unsigned char *) rla_info.name);\n  count=ReadBlob(image,128,(unsigned char *) rla_info.description);\n  rla_info.description[127]='\\0';\n  count=ReadBlob(image,64,(unsigned char *) rla_info.program);\n  count=ReadBlob(image,32,(unsigned char *) rla_info.machine);\n  count=ReadBlob(image,32,(unsigned char *) rla_info.user);\n  count=ReadBlob(image,20,(unsigned char *) rla_info.date);\n  count=ReadBlob(image,24,(unsigned char *) rla_info.aspect);\n  count=ReadBlob(image,8,(unsigned char *) rla_info.aspect_ratio);\n  count=ReadBlob(image,32,(unsigned char *) rla_info.chan);\n  rla_info.field=(short) ReadBlobMSBShort(image);\n  count=ReadBlob(image,12,(unsigned char *) rla_info.time);\n  count=ReadBlob(image,32,(unsigned char *) rla_info.filter);\n  rla_info.bits_per_channel=(short) ReadBlobMSBShort(image);\n  rla_info.matte_type=(short) ReadBlobMSBShort(image);\n  rla_info.matte_bits=(short) ReadBlobMSBShort(image);\n  rla_info.auxiliary_type=(short) ReadBlobMSBShort(image);\n  rla_info.auxiliary_bits=(short) ReadBlobMSBShort(image);\n  count=ReadBlob(image,32,(unsigned char *) rla_info.auxiliary);\n  count=ReadBlob(image,36,(unsigned char *) rla_info.space);\n  if ((size_t) count != 36)\n    ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n  rla_info.next=(int) ReadBlobMSBLong(image);\n  /*\n    Initialize image structure.\n  */\n  image->matte=rla_info.number_matte_channels != 0 ? MagickTrue : MagickFalse;\n  image->columns=1UL*rla_info.active_window.right-rla_info.active_window.left+1;\n  image->rows=1UL*rla_info.active_window.top-rla_info.active_window.bottom+1;\n  if (image_info->ping != MagickFalse)\n    {\n       (void) CloseBlob(image);\n       return(GetFirstImageInList(image));\n     }\n   scanlines=(ssize_t *) AcquireQuantumMemory(image->rows,sizeof(*scanlines));\n   if (scanlines == (ssize_t *) NULL)\n     ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  if (*rla_info.description != '\\0')\n    (void) SetImageProperty(image,\"comment\",(char *) rla_info.description);\n  /*\n    Read offsets to each scanline data.\n  */\n  for (i=0; i < (ssize_t) image->rows; i++)\n    scanlines[i]=(int) ReadBlobMSBLong(image);\n  /*\n    Read image data.\n  */\n  x=0;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    offset=SeekBlob(image,scanlines[image->rows-y-1],SEEK_SET);\n    if (offset < 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    for (channel=0; channel < (int) rla_info.number_channels; channel++)\n    {\n      length=(int) ReadBlobMSBShort(image);\n      while (length > 0)\n      {\n        byte=(unsigned char) ReadBlobByte(image);\n        runlength=byte;\n        if (byte > 127)\n          runlength=byte-256;\n        length--;\n        if (length == 0)\n          break;\n        if (runlength < 0)\n          {\n            while (runlength < 0)\n            {\n              q=GetAuthenticPixels(image,(ssize_t) (x % image->columns),\n                (ssize_t) (y % image->rows),1,1,exception);\n              if (q == (PixelPacket *) NULL)\n                break;\n              byte=(unsigned char) ReadBlobByte(image);\n              length--;\n              switch (channel)\n              {\n                case 0:\n                {\n                  SetPixelRed(q,ScaleCharToQuantum(byte));\n                  break;\n                }\n                case 1:\n                {\n                  SetPixelGreen(q,ScaleCharToQuantum(byte));\n                  break;\n                }\n                case 2:\n                {\n                  SetPixelBlue(q,ScaleCharToQuantum(byte));\n                  break;\n                }\n                case 3:\n                default:\n                {\n                  SetPixelAlpha(q,ScaleCharToQuantum(byte));\n                  break;\n                }\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              x++;\n              runlength++;\n            }\n            continue;\n          }\n        byte=(unsigned char) ReadBlobByte(image);\n        length--;\n        runlength++;\n        do\n        {\n          q=GetAuthenticPixels(image,(ssize_t) (x % image->columns),\n            (ssize_t) (y % image->rows),1,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          switch (channel)\n          {\n            case 0:\n            {\n              SetPixelRed(q,ScaleCharToQuantum(byte));\n              break;\n            }\n            case 1:\n            {\n              SetPixelGreen(q,ScaleCharToQuantum(byte));\n              break;\n            }\n            case 2:\n            {\n              SetPixelBlue(q,ScaleCharToQuantum(byte));\n              break;\n            }\n            case 3:\n            default:\n            {\n              SetPixelAlpha(q,ScaleCharToQuantum(byte));\n              break;\n            }\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          x++;\n          runlength--;\n        }\n        while (runlength > 0);\n      }\n    }\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n", "target": 1, "idx": 181771}
{"func": "store_pool_error(png_store *ps, png_const_structp pp, PNG_CONST char *msg)\n {\n    if (pp != NULL)\n       png_error(pp, msg);\n\n /* Else we have to do it ourselves.  png_error eventually calls store_log,\n    * above.  store_log accepts a NULL png_structp - it just changes what gets\n    * output by store_message.\n    */\n   store_log(ps, pp, msg, 1 /* error */);\n}\n", "target": 1, "idx": 187730}
{"func": "static SegmentInfo AffineEdge(const Image *image,const AffineMatrix *affine,\n  const double y,const SegmentInfo *edge)\n{\n  double\n    intercept,\n    z;\n\n  register double\n    x;\n\n  SegmentInfo\n    inverse_edge;\n\n  /*\n    Determine left and right edges.\n  */\n  inverse_edge.x1=edge->x1;\n  inverse_edge.y1=edge->y1;\n  inverse_edge.x2=edge->x2;\n  inverse_edge.y2=edge->y2;\n  z=affine->ry*y+affine->tx;\n  if (affine->sx >= DrawEpsilon)\n    {\n      intercept=(-z/affine->sx);\n      x=intercept;\n      if (x > inverse_edge.x1)\n        inverse_edge.x1=x;\n      intercept=(-z+(double) image->columns)/affine->sx;\n      x=intercept;\n      if (x < inverse_edge.x2)\n        inverse_edge.x2=x;\n    }\n  else\n    if (affine->sx < -DrawEpsilon)\n      {\n        intercept=(-z+(double) image->columns)/affine->sx;\n        x=intercept;\n        if (x > inverse_edge.x1)\n          inverse_edge.x1=x;\n        intercept=(-z/affine->sx);\n        x=intercept;\n        if (x < inverse_edge.x2)\n          inverse_edge.x2=x;\n      }\n    else\n      if ((z < 0.0) || ((size_t) floor(z+0.5) >= image->columns))\n        {\n          inverse_edge.x2=edge->x1;\n          return(inverse_edge);\n        }\n  /*\n    Determine top and bottom edges.\n  */\n  z=affine->sy*y+affine->ty;\n  if (affine->rx >= DrawEpsilon)\n    {\n      intercept=(-z/affine->rx);\n      x=intercept;\n      if (x > inverse_edge.x1)\n        inverse_edge.x1=x;\n      intercept=(-z+(double) image->rows)/affine->rx;\n      x=intercept;\n      if (x < inverse_edge.x2)\n        inverse_edge.x2=x;\n    }\n  else\n    if (affine->rx < -DrawEpsilon)\n      {\n        intercept=(-z+(double) image->rows)/affine->rx;\n        x=intercept;\n        if (x > inverse_edge.x1)\n          inverse_edge.x1=x;\n        intercept=(-z/affine->rx);\n        x=intercept;\n        if (x < inverse_edge.x2)\n          inverse_edge.x2=x;\n      }\n    else\n      if ((z < 0.0) || ((size_t) floor(z+0.5) >= image->rows))\n        {\n          inverse_edge.x2=edge->x2;\n          return(inverse_edge);\n        }\n  return(inverse_edge);\n}\n", "target": 0, "idx": 71988}
{"func": "static inline int _setEdgePixel(const gdImagePtr src, unsigned int x, unsigned int y, gdFixed coverage, const int bgColor) \n {\n \tconst gdFixed f_127 = gd_itofx(127);\n \tregister int c = src->tpixels[y][x];\n\tc = c | (( (int) (gd_fxtof(gd_mulfx(coverage, f_127)) + 50.5f)) << 24);\n\treturn _color_blend(bgColor, c);\n}\n", "target": 1, "idx": 183177}
{"func": "TEE_Result syscall_check_access_rights(unsigned long flags, const void *buf,\n\t\t\t\t       size_t len)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *s;\n\n\tres = tee_ta_get_current_session(&s);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\treturn tee_mmu_check_access_rights(to_user_ta_ctx(s->ctx), flags,\n\t\t\t\t\t   (uaddr_t)buf, len);\n}\n", "target": 0, "idx": 86910}
{"func": "static Vector<AtomicString>* createInternalRoleNameVector() {\n  Vector<AtomicString>* internalRoleNameVector =\n      new Vector<AtomicString>(NumRoles);\n  for (size_t i = 0; i < WTF_ARRAY_LENGTH(internalRoles); i++)\n    (*internalRoleNameVector)[internalRoles[i].webcoreRole] =\n        AtomicString(internalRoles[i].internalRoleName);\n\n  return internalRoleNameVector;\n}\n", "target": 0, "idx": 138146}
{"func": "int dtls1_listen(SSL *s, struct sockaddr *client)\n {\n     int ret;\n \n     SSL_set_options(s, SSL_OP_COOKIE_EXCHANGE);\n     s->d1->listen = 1;\n\n    (void)BIO_dgram_get_peer(SSL_get_rbio(s), client);\n    return 1;\n}\n", "target": 1, "idx": 177993}
{"func": " int LELib_Create(const effect_uuid_t *uuid,\n                         int32_t sessionId,\n                         int32_t ioId,\n                          effect_handle_t *pHandle) {\n     ALOGV(\"LELib_Create()\");\n     int ret;\n int i;\n\n if (pHandle == NULL || uuid == NULL) {\n return -EINVAL;\n }\n\n if (memcmp(uuid, &gLEDescriptor.uuid, sizeof(effect_uuid_t)) != 0) {\n return -EINVAL;\n }\n\n LoudnessEnhancerContext *pContext = new LoudnessEnhancerContext;\n\n    pContext->mItfe = &gLEInterface;\n    pContext->mState = LOUDNESS_ENHANCER_STATE_UNINITIALIZED;\n\n    pContext->mCompressor = NULL;\n    ret = LE_init(pContext);\n if (ret < 0) {\n        ALOGW(\"LELib_Create() init failed\");\n delete pContext;\n return ret;\n }\n\n *pHandle = (effect_handle_t)pContext;\n\n    pContext->mState = LOUDNESS_ENHANCER_STATE_INITIALIZED;\n\n    ALOGV(\"  LELib_Create context is %p\", pContext);\n\n return 0;\n\n}\n", "target": 1, "idx": 187368}
{"func": "std::map<K, V> MapFromKeyValuePairs(std::vector<std::pair<K, V>> pairs) {\n  std::map<K, V> result;\n  for (size_t i = 0; i < pairs.size(); ++i)\n    result[pairs[i].first] = pairs[i].second;\n  return result;\n}\n", "target": 0, "idx": 141637}
{"func": "static int cJSON_strcasecmp( const char *s1, const char *s2 )\n {\n\tif ( ! s1 )\n\t\treturn ( s1 == s2 ) ? 0 : 1;\n\tif ( ! s2 )\n\t\treturn 1;\n\tfor ( ; tolower(*s1) == tolower(*s2); ++s1, ++s2)\n\t\tif( *s1 == 0 )\n\t\t\treturn 0;\n \treturn tolower(*(const unsigned char *)s1) - tolower(*(const unsigned char *)s2);\n }\n", "target": 1, "idx": 180469}
{"func": "char *X509_NAME_oneline(X509_NAME *a, char *buf, int len)\n{\n    X509_NAME_ENTRY *ne;\n    int i;\n    int n, lold, l, l1, l2, num, j, type;\n    const char *s;\n    char *p;\n    unsigned char *q;\n    BUF_MEM *b = NULL;\n    static const char hex[17] = \"0123456789ABCDEF\";\n    int gs_doit[4];\n    char tmp_buf[80];\n#ifdef CHARSET_EBCDIC\n    char ebcdic_buf[1024];\n#endif\n\n    if (buf == NULL) {\n        if ((b = BUF_MEM_new()) == NULL)\n            goto err;\n        if (!BUF_MEM_grow(b, 200))\n            goto err;\n        b->data[0] = '\\0';\n        len = 200;\n    } else if (len == 0) {\n        return NULL;\n    }\n    if (a == NULL) {\n        if (b) {\n            buf = b->data;\n            OPENSSL_free(b);\n        }\n        strncpy(buf, \"NO X509_NAME\", len);\n        buf[len - 1] = '\\0';\n        return buf;\n    }\n\n    len--;                      /* space for '\\0' */\n    l = 0;\n    for (i = 0; i < sk_X509_NAME_ENTRY_num(a->entries); i++) {\n        ne = sk_X509_NAME_ENTRY_value(a->entries, i);\n        n = OBJ_obj2nid(ne->object);\n        if ((n == NID_undef) || ((s = OBJ_nid2sn(n)) == NULL)) {\n            i2t_ASN1_OBJECT(tmp_buf, sizeof(tmp_buf), ne->object);\n            s = tmp_buf;\n        }\n        l1 = strlen(s);\n\n        type = ne->value->type;\n        num = ne->value->length;\n        if (num > NAME_ONELINE_MAX) {\n            X509err(X509_F_X509_NAME_ONELINE, X509_R_NAME_TOO_LONG);\n            goto end;\n        }\n        q = ne->value->data;\n#ifdef CHARSET_EBCDIC\n        if (type == V_ASN1_GENERALSTRING ||\n            type == V_ASN1_VISIBLESTRING ||\n             type == V_ASN1_PRINTABLESTRING ||\n             type == V_ASN1_TELETEXSTRING ||\n             type == V_ASN1_VISIBLESTRING || type == V_ASN1_IA5STRING) {\n            ascii2ebcdic(ebcdic_buf, q, (num > sizeof ebcdic_buf)\n                         ? sizeof ebcdic_buf : num);\n             q = ebcdic_buf;\n         }\n #endif\n        if ((type == V_ASN1_GENERALSTRING) && ((num % 4) == 0)) {\n            gs_doit[0] = gs_doit[1] = gs_doit[2] = gs_doit[3] = 0;\n            for (j = 0; j < num; j++)\n                if (q[j] != 0)\n                    gs_doit[j & 3] = 1;\n\n            if (gs_doit[0] | gs_doit[1] | gs_doit[2])\n                gs_doit[0] = gs_doit[1] = gs_doit[2] = gs_doit[3] = 1;\n            else {\n                gs_doit[0] = gs_doit[1] = gs_doit[2] = 0;\n                gs_doit[3] = 1;\n            }\n        } else\n            gs_doit[0] = gs_doit[1] = gs_doit[2] = gs_doit[3] = 1;\n\n        for (l2 = j = 0; j < num; j++) {\n            if (!gs_doit[j & 3])\n                continue;\n            l2++;\n#ifndef CHARSET_EBCDIC\n            if ((q[j] < ' ') || (q[j] > '~'))\n                l2 += 3;\n#else\n            if ((os_toascii[q[j]] < os_toascii[' ']) ||\n                (os_toascii[q[j]] > os_toascii['~']))\n                l2 += 3;\n#endif\n        }\n\n        lold = l;\n        l += 1 + l1 + 1 + l2;\n        if (l > NAME_ONELINE_MAX) {\n            X509err(X509_F_X509_NAME_ONELINE, X509_R_NAME_TOO_LONG);\n            goto end;\n        }\n        if (b != NULL) {\n            if (!BUF_MEM_grow(b, l + 1))\n                goto err;\n            p = &(b->data[lold]);\n        } else if (l > len) {\n            break;\n        } else\n            p = &(buf[lold]);\n        *(p++) = '/';\n        memcpy(p, s, (unsigned int)l1);\n        p += l1;\n        *(p++) = '=';\n\n#ifndef CHARSET_EBCDIC          /* q was assigned above already. */\n        q = ne->value->data;\n#endif\n\n        for (j = 0; j < num; j++) {\n            if (!gs_doit[j & 3])\n                continue;\n#ifndef CHARSET_EBCDIC\n            n = q[j];\n            if ((n < ' ') || (n > '~')) {\n                *(p++) = '\\\\';\n                *(p++) = 'x';\n                *(p++) = hex[(n >> 4) & 0x0f];\n                *(p++) = hex[n & 0x0f];\n            } else\n                *(p++) = n;\n#else\n            n = os_toascii[q[j]];\n            if ((n < os_toascii[' ']) || (n > os_toascii['~'])) {\n                *(p++) = '\\\\';\n                *(p++) = 'x';\n                *(p++) = hex[(n >> 4) & 0x0f];\n                *(p++) = hex[n & 0x0f];\n            } else\n                *(p++) = q[j];\n#endif\n        }\n        *p = '\\0';\n    }\n    if (b != NULL) {\n        p = b->data;\n        OPENSSL_free(b);\n    } else\n        p = buf;\n    if (i == 0)\n        *p = '\\0';\n    return (p);\n err:\n    X509err(X509_F_X509_NAME_ONELINE, ERR_R_MALLOC_FAILURE);\n end:\n    BUF_MEM_free(b);\n    return (NULL);\n}\n", "target": 1, "idx": 178379}
{"func": "void TabStripModel::InsertTabContentsAt(int index,\n                                        TabContents* contents,\n                                        int add_types) {\n  bool active = add_types & ADD_ACTIVE;\n  extensions::TabHelper* extensions_tab_helper =\n      extensions::TabHelper::FromWebContents(contents->web_contents());\n  bool pin = extensions_tab_helper->is_app() || add_types & ADD_PINNED;\n  index = ConstrainInsertionIndex(index, pin);\n\n  closing_all_ = false;\n\n  WebContents* active_contents = GetActiveWebContents();\n  WebContentsData* data = new WebContentsData(contents->web_contents());\n  data->pinned = pin;\n  if ((add_types & ADD_INHERIT_GROUP) && active_contents) {\n    if (active) {\n      ForgetAllOpeners();\n    }\n    data->SetGroup(active_contents);\n  } else if ((add_types & ADD_INHERIT_OPENER) && active_contents) {\n    if (active) {\n      ForgetAllOpeners();\n    }\n    data->opener = active_contents;\n  }\n\n  contents_data_.insert(contents_data_.begin() + index, data);\n\n  selection_model_.IncrementFrom(index);\n\n  FOR_EACH_OBSERVER(TabStripModelObserver, observers_,\n                    TabInsertedAt(contents->web_contents(), index, active));\n  if (active) {\n    TabStripSelectionModel new_model;\n    new_model.Copy(selection_model_);\n    new_model.SetSelectedIndex(index);\n    SetSelection(new_model, NOTIFY_DEFAULT);\n  }\n}\n", "target": 0, "idx": 126636}
{"func": "static int is_cpuid_PSE36(void)\n{\n\treturn 1;\n}\n", "target": 0, "idx": 37436}
{"func": "  explicit StreamBacktraceOutputHandler(std::ostream* os) : os_(os) {\n  }\n", "target": 0, "idx": 119101}
{"func": "spnego_gss_inquire_context(\n\t\t\tOM_uint32\t*minor_status,\n\t\t\tconst gss_ctx_id_t context_handle,\n\t\t\tgss_name_t\t*src_name,\n\t\t\tgss_name_t\t*targ_name,\n\t\t\tOM_uint32\t*lifetime_rec,\n\t\t\tgss_OID\t\t*mech_type,\n\t\t\tOM_uint32\t*ctx_flags,\n\t\t\tint\t\t*locally_initiated,\n \t\t\tint\t\t*opened)\n {\n \tOM_uint32 ret = GSS_S_COMPLETE;\n \n\tret = gss_inquire_context(minor_status,\n\t\t\t\tcontext_handle,\n\t\t\t\tsrc_name,\n\t\t\t\ttarg_name,\n\t\t\t\tlifetime_rec,\n\t\t\t\tmech_type,\n\t\t\t\tctx_flags,\n\t\t\t\tlocally_initiated,\n\t\t\t\topened);\n \n \treturn (ret);\n }\n", "target": 1, "idx": 179833}
{"func": "void *Sys_LoadGameDll(const char *name,\n\tintptr_t (QDECL **entryPoint)(int, ...),\n\tintptr_t (*systemcalls)(intptr_t, ...))\n{\n\tvoid *libHandle;\n\tvoid (*dllEntry)(intptr_t (*syscallptr)(intptr_t, ...));\n\n\tassert(name);\n\n\tCom_Printf( \"Loading DLL file: %s\\n\", name);\n\tlibHandle = Sys_LoadLibrary(name);\n\n\tif(!libHandle)\n\t{\n\t\tCom_Printf(\"Sys_LoadGameDll(%s) failed:\\n\\\"%s\\\"\\n\", name, Sys_LibraryError());\n\t\treturn NULL;\n\t}\n\n\tdllEntry = Sys_LoadFunction( libHandle, \"dllEntry\" );\n\t*entryPoint = Sys_LoadFunction( libHandle, \"vmMain\" );\n\n\tif ( !*entryPoint || !dllEntry )\n\t{\n\t\tCom_Printf ( \"Sys_LoadGameDll(%s) failed to find vmMain function:\\n\\\"%s\\\" !\\n\", name, Sys_LibraryError( ) );\n\t\tSys_UnloadLibrary(libHandle);\n\n\t\treturn NULL;\n\t}\n\n\tCom_Printf ( \"Sys_LoadGameDll(%s) found vmMain function at %p\\n\", name, *entryPoint );\n\tdllEntry( systemcalls );\n\n\treturn libHandle;\n}\n", "target": 0, "idx": 96070}
{"func": "void GLES2DecoderImpl::EmulateVertexArrayState() {\n  for (uint32_t vv = 0; vv < group_->max_vertex_attribs(); ++vv) {\n    RestoreStateForAttrib(vv, true);\n  }\n\n  Buffer* element_array_buffer =\n      state_.vertex_attrib_manager->element_array_buffer();\n  api()->glBindBufferFn(\n      GL_ELEMENT_ARRAY_BUFFER,\n      element_array_buffer ? element_array_buffer->service_id() : 0);\n}\n", "target": 0, "idx": 154113}
{"func": "void SaveCardBubbleControllerImpl::OnLegalMessageLinkClicked(const GURL& url) {\n  OpenUrl(url);\n  AutofillMetrics::LogSaveCardPromptMetric(\n      AutofillMetrics::SAVE_CARD_PROMPT_DISMISS_CLICK_LEGAL_MESSAGE,\n      is_uploading_, is_reshow_,\n      pref_service_->GetInteger(\n          prefs::kAutofillAcceptSaveCreditCardPromptState));\n}\n", "target": 0, "idx": 149687}
{"func": "long Chapters::Display::Parse(\n    IMkvReader* pReader,\n    long long pos,\n    long long size)\n{\n    const long long stop = pos + size;\n    while (pos < stop)\n    {\n        long long id, size;\n        long status = ParseElementHeader(\n                        pReader,\n                        pos,\n                        stop,\n                        id,\n                        size);\n        if (status < 0)  // error\n            return status;\n        if (size == 0)  // weird\n            continue;\n        if (id == 0x05)  // ChapterString ID\n        {\n            status = UnserializeString(pReader, pos, size, m_string);\n            if (status)\n              return status;\n        }\n        else if (id == 0x037C)  // ChapterLanguage ID\n        {\n            status = UnserializeString(pReader, pos, size, m_language);\n            if (status)\n              return status;\n        }\n        else if (id == 0x037E)  // ChapterCountry ID\n        {\n            status = UnserializeString(pReader, pos, size, m_country);\n            if (status)\n              return status;\n        }\n        pos += size;\n        assert(pos <= stop);\n    }\n    assert(pos == stop);\n    return 0;\n}\n", "target": 1, "idx": 188425}
{"func": "image_transform_set_end(PNG_CONST image_transform *this,\n    transform_display *that, png_structp pp, png_infop pi)\n {\n    UNUSED(this)\n   UNUSED(that)\n   UNUSED(pp)\n   UNUSED(pi)\n}\n", "target": 1, "idx": 187679}
{"func": "static void __exit atm_exit(void)\n{\n\tatm_proc_exit();\n\tatm_sysfs_exit();\n\tatmsvc_exit();\n\tatmpvc_exit();\n\tproto_unregister(&vcc_proto);\n}\n", "target": 0, "idx": 30811}
{"func": "nfsd4_encode_rdattr_error(struct xdr_stream *xdr, __be32 nfserr)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 20);\n\tif (!p)\n\t\treturn NULL;\n\t*p++ = htonl(2);\n\t*p++ = htonl(FATTR4_WORD0_RDATTR_ERROR); /* bmval0 */\n\t*p++ = htonl(0);\t\t\t /* bmval1 */\n\n\t*p++ = htonl(4);     /* attribute length */\n\t*p++ = nfserr;       /* no htonl */\n\treturn p;\n}\n", "target": 0, "idx": 65822}
{"func": "bool PropertyKeyIsBlacklisted(const char* key) {\n  for (size_t i = 0; i < arraysize(kInputMethodPropertyKeysBlacklist); ++i) {\n    if (!std::strcmp(key, kInputMethodPropertyKeysBlacklist[i])) {\n      return true;\n    }\n  }\n  return false;\n}\n", "target": 0, "idx": 105742}
{"func": "static void get_frame_stats(vpx_codec_ctx_t *ctx,\n                            const vpx_image_t *img,\n                            vpx_codec_pts_t pts,\n                            unsigned int duration,\n                            vpx_enc_frame_flags_t flags,\n                            unsigned int deadline,\n                            vpx_fixed_buf_t *stats) {\n   vpx_codec_iter_t iter = NULL;\n   const vpx_codec_cx_pkt_t *pkt = NULL;\n   const vpx_codec_err_t res = vpx_codec_encode(ctx, img, pts, duration, flags,\n                                               deadline);\n if (res != VPX_CODEC_OK)\n\n     die_codec(ctx, \"Failed to get frame stats.\");\n \n   while ((pkt = vpx_codec_get_cx_data(ctx, &iter)) != NULL) {\n     if (pkt->kind == VPX_CODEC_STATS_PKT) {\n       const uint8_t *const pkt_buf = pkt->data.twopass_stats.buf;\n       const size_t pkt_size = pkt->data.twopass_stats.sz;\n      stats->buf = realloc(stats->buf, stats->sz + pkt_size);\n      memcpy((uint8_t *)stats->buf + stats->sz, pkt_buf, pkt_size);\n\n       stats->sz += pkt_size;\n     }\n   }\n }\n", "target": 1, "idx": 188514}
{"func": "void Layer::RemoveChildOrDependent(Layer* child) {\n  if (mask_layer_.get() == child) {\n    mask_layer_->SetParent(NULL);\n    mask_layer_ = NULL;\n    SetNeedsFullTreeSync();\n    return;\n  }\n  if (replica_layer_.get() == child) {\n    replica_layer_->SetParent(NULL);\n    replica_layer_ = NULL;\n    SetNeedsFullTreeSync();\n    return;\n  }\n\n  for (LayerList::iterator iter = children_.begin();\n       iter != children_.end();\n       ++iter) {\n    if (iter->get() != child)\n      continue;\n\n    child->SetParent(NULL);\n    children_.erase(iter);\n    SetNeedsFullTreeSync();\n    return;\n  }\n}\n", "target": 0, "idx": 120133}
{"func": " void EntrySync::remove(ExceptionState& exceptionState) const\n {\n    RefPtr<VoidSyncCallbackHelper> helper = VoidSyncCallbackHelper::create();\n     m_fileSystem->remove(this, helper->successCallback(), helper->errorCallback(), DOMFileSystemBase::Synchronous);\n     helper->getResult(exceptionState);\n }\n", "target": 1, "idx": 185121}
{"func": "static bool EnsureCrosLoaded() {\n  if (!CrosLibrary::Get()->EnsureLoaded()) {\n    return false;\n  } else {\n    if (!BrowserThread::CurrentlyOn(BrowserThread::UI)) {\n      LOG(ERROR) << \"chromeos_library calls made from non UI thread!\";\n      NOTREACHED();\n    }\n    return true;\n  }\n}\n", "target": 0, "idx": 100240}
{"func": "nfsd4_set_opendowngradestateid(struct nfsd4_compound_state *cstate, struct nfsd4_open_downgrade *odp)\n{\n\tput_stateid(cstate, &odp->od_stateid);\n}\n", "target": 0, "idx": 65637}
{"func": "check_entry_size_and_hooks(struct ip6t_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct ip6t_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ip6t_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset\n\t    < sizeof(struct ip6t_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\n \tif (!ip6_checkentry(&e->ipv6))\n \t\treturn -EINVAL;\n \n\terr = xt_check_entry_offsets(e, e->target_offset, e->next_offset);\n \tif (err)\n \t\treturn err;\n \n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}\n", "target": 1, "idx": 180392}
{"func": "unsigned int full_name_hash(const unsigned char *name, unsigned int len)\n{\n\tunsigned long a, mask;\n\tunsigned long hash = 0;\n\n\tfor (;;) {\n\t\ta = load_unaligned_zeropad(name);\n\t\tif (len < sizeof(unsigned long))\n\t\t\tbreak;\n\t\thash += a;\n\t\thash *= 9;\n\t\tname += sizeof(unsigned long);\n\t\tlen -= sizeof(unsigned long);\n\t\tif (!len)\n\t\t\tgoto done;\n\t}\n\tmask = bytemask_from_count(len);\n\thash += mask & a;\ndone:\n\treturn fold_hash(hash);\n}\n", "target": 0, "idx": 36320}
{"func": "static bool __oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)\n{\n\tstruct mmu_gather tlb;\n\tstruct vm_area_struct *vma;\n\tbool ret = true;\n\n\t/*\n\t * We have to make sure to not race with the victim exit path\n\t * and cause premature new oom victim selection:\n\t * __oom_reap_task_mm\t\texit_mm\n\t *   mmget_not_zero\n\t *\t\t\t\t  mmput\n\t *\t\t\t\t    atomic_dec_and_test\n\t *\t\t\t\t  exit_oom_victim\n\t *\t\t\t\t[...]\n\t *\t\t\t\tout_of_memory\n\t *\t\t\t\t  select_bad_process\n\t *\t\t\t\t    # no TIF_MEMDIE task selects new victim\n\t *  unmap_page_range # frees some memory\n\t */\n\tmutex_lock(&oom_lock);\n\n\tif (!down_read_trylock(&mm->mmap_sem)) {\n\t\tret = false;\n\t\ttrace_skip_task_reaping(tsk->pid);\n\t\tgoto unlock_oom;\n\t}\n\n\t/*\n\t * If the mm has notifiers then we would need to invalidate them around\n\t * unmap_page_range and that is risky because notifiers can sleep and\n\t * what they do is basically undeterministic.  So let's have a short\n\t * sleep to give the oom victim some more time.\n\t * TODO: we really want to get rid of this ugly hack and make sure that\n\t * notifiers cannot block for unbounded amount of time and add\n\t * mmu_notifier_invalidate_range_{start,end} around unmap_page_range\n\t */\n\tif (mm_has_notifiers(mm)) {\n\t\tup_read(&mm->mmap_sem);\n\t\tschedule_timeout_idle(HZ);\n\t\tgoto unlock_oom;\n\t}\n\n\t/*\n\t * MMF_OOM_SKIP is set by exit_mmap when the OOM reaper can't\n\t * work on the mm anymore. The check for MMF_OOM_SKIP must run\n\t * under mmap_sem for reading because it serializes against the\n\t * down_write();up_write() cycle in exit_mmap().\n\t */\n\tif (test_bit(MMF_OOM_SKIP, &mm->flags)) {\n\t\tup_read(&mm->mmap_sem);\n\t\ttrace_skip_task_reaping(tsk->pid);\n\t\tgoto unlock_oom;\n\t}\n\n\ttrace_start_task_reaping(tsk->pid);\n\n\t/*\n\t * Tell all users of get_user/copy_from_user etc... that the content\n\t * is no longer stable. No barriers really needed because unmapping\n\t * should imply barriers already and the reader would hit a page fault\n\t * if it stumbled over a reaped memory.\n \t */\n \tset_bit(MMF_UNSTABLE, &mm->flags);\n \n\ttlb_gather_mmu(&tlb, mm, 0, -1);\n \tfor (vma = mm->mmap ; vma; vma = vma->vm_next) {\n \t\tif (!can_madv_dontneed_vma(vma))\n \t\t\tcontinue;\n\n\t\t/*\n\t\t * Only anonymous pages have a good chance to be dropped\n\t\t * without additional steps which we cannot afford as we\n\t\t * are OOM already.\n\t\t *\n\t\t * We do not even care about fs backed pages because all\n\t\t * which are reclaimable have already been reclaimed and\n \t\t * we do not want to block exit_mmap by keeping mm ref\n \t\t * count elevated without a good reason.\n \t\t */\n\t\tif (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED))\n \t\t\tunmap_page_range(&tlb, vma, vma->vm_start, vma->vm_end,\n \t\t\t\t\t NULL);\n \t}\n\ttlb_finish_mmu(&tlb, 0, -1);\n \tpr_info(\"oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\\n\",\n \t\t\ttask_pid_nr(tsk), tsk->comm,\n \t\t\tK(get_mm_counter(mm, MM_ANONPAGES)),\n\t\t\tK(get_mm_counter(mm, MM_FILEPAGES)),\n\t\t\tK(get_mm_counter(mm, MM_SHMEMPAGES)));\n\tup_read(&mm->mmap_sem);\n\n\ttrace_finish_task_reaping(tsk->pid);\nunlock_oom:\n\tmutex_unlock(&oom_lock);\n\treturn ret;\n}\n", "target": 1, "idx": 182584}
{"func": "static void nbd_recv_coroutines_enter_all(NBDClientSession *s)\n {\n     int i;\n \n     for (i = 0; i < MAX_NBD_REQUESTS; i++) {\n            qemu_coroutine_enter(s->recv_coroutine[i]);\n             qemu_coroutine_enter(s->recv_coroutine[i]);\n         }\n     }\n", "target": 1, "idx": 178621}
{"func": "static void h2s_destroy(struct h2s *h2s)\n{\n\th2s_close(h2s);\n\tLIST_DEL(&h2s->list);\n\tLIST_INIT(&h2s->list);\n\teb32_delete(&h2s->by_id);\n\tpool_free(pool_head_h2s, h2s);\n}\n", "target": 0, "idx": 7812}
{"func": "static int do_check(struct bpf_verifier_env *env)\n{\n\tstruct bpf_verifier_state *state;\n\tstruct bpf_insn *insns = env->prog->insnsi;\n\tstruct bpf_reg_state *regs;\n\tint insn_cnt = env->prog->len, i;\n\tint insn_processed = 0;\n\tbool do_print_state = false;\n\n\tenv->prev_linfo = NULL;\n\n\tstate = kzalloc(sizeof(struct bpf_verifier_state), GFP_KERNEL);\n \tif (!state)\n \t\treturn -ENOMEM;\n \tstate->curframe = 0;\n \tstate->frame[0] = kzalloc(sizeof(struct bpf_func_state), GFP_KERNEL);\n \tif (!state->frame[0]) {\n \t\tkfree(state);\n\t\treturn -ENOMEM;\n\t}\n\tenv->cur_state = state;\n\tinit_func_state(env, state->frame[0],\n\t\t\tBPF_MAIN_FUNC /* callsite */,\n\t\t\t0 /* frameno */,\n\t\t\t0 /* subprogno, zero == main subprog */);\n\n\tfor (;;) {\n\t\tstruct bpf_insn *insn;\n\t\tu8 class;\n\t\tint err;\n\n\t\tif (env->insn_idx >= insn_cnt) {\n\t\t\tverbose(env, \"invalid insn idx %d insn_cnt %d\\n\",\n\t\t\t\tenv->insn_idx, insn_cnt);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tinsn = &insns[env->insn_idx];\n\t\tclass = BPF_CLASS(insn->code);\n\n\t\tif (++insn_processed > BPF_COMPLEXITY_LIMIT_INSNS) {\n\t\t\tverbose(env,\n\t\t\t\t\"BPF program is too large. Processed %d insn\\n\",\n\t\t\t\tinsn_processed);\n\t\t\treturn -E2BIG;\n\t\t}\n\n\t\terr = is_state_visited(env, env->insn_idx);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (err == 1) {\n \t\t\t/* found equivalent state, can prune the search */\n \t\t\tif (env->log.level) {\n \t\t\t\tif (do_print_state)\n\t\t\t\t\tverbose(env, \"\\nfrom %d to %d: safe\\n\",\n\t\t\t\t\t\tenv->prev_insn_idx, env->insn_idx);\n \t\t\t\telse\n \t\t\t\t\tverbose(env, \"%d: safe\\n\", env->insn_idx);\n \t\t\t}\n\t\t\tgoto process_bpf_exit;\n\t\t}\n\n\t\tif (signal_pending(current))\n\t\t\treturn -EAGAIN;\n\n\t\tif (need_resched())\n\t\t\tcond_resched();\n\n\t\tif (env->log.level > 1 || (env->log.level && do_print_state)) {\n \t\t\tif (env->log.level > 1)\n \t\t\t\tverbose(env, \"%d:\", env->insn_idx);\n \t\t\telse\n\t\t\t\tverbose(env, \"\\nfrom %d to %d:\",\n\t\t\t\t\tenv->prev_insn_idx, env->insn_idx);\n \t\t\tprint_verifier_state(env, state->frame[state->curframe]);\n \t\t\tdo_print_state = false;\n \t\t}\n\n\t\tif (env->log.level) {\n\t\t\tconst struct bpf_insn_cbs cbs = {\n\t\t\t\t.cb_print\t= verbose,\n\t\t\t\t.private_data\t= env,\n\t\t\t};\n\n\t\t\tverbose_linfo(env, env->insn_idx, \"; \");\n\t\t\tverbose(env, \"%d: \", env->insn_idx);\n\t\t\tprint_bpf_insn(&cbs, insn, env->allow_ptr_leaks);\n\t\t}\n\n\t\tif (bpf_prog_is_dev_bound(env->prog->aux)) {\n\t\t\terr = bpf_prog_offload_verify_insn(env, env->insn_idx,\n\t\t\t\t\t\t\t   env->prev_insn_idx);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tregs = cur_regs(env);\n\t\tenv->insn_aux_data[env->insn_idx].seen = true;\n\n\t\tif (class == BPF_ALU || class == BPF_ALU64) {\n\t\t\terr = check_alu_op(env, insn);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t} else if (class == BPF_LDX) {\n\t\t\tenum bpf_reg_type *prev_src_type, src_reg_type;\n\n\t\t\t/* check for reserved fields is already done */\n\n\t\t\t/* check src operand */\n\t\t\terr = check_reg_arg(env, insn->src_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\terr = check_reg_arg(env, insn->dst_reg, DST_OP_NO_MARK);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tsrc_reg_type = regs[insn->src_reg].type;\n\n\t\t\t/* check that memory (src_reg + off) is readable,\n\t\t\t * the state of dst_reg will be updated by this func\n\t\t\t */\n\t\t\terr = check_mem_access(env, env->insn_idx, insn->src_reg,\n\t\t\t\t\t       insn->off, BPF_SIZE(insn->code),\n\t\t\t\t\t       BPF_READ, insn->dst_reg, false);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tprev_src_type = &env->insn_aux_data[env->insn_idx].ptr_type;\n\n\t\t\tif (*prev_src_type == NOT_INIT) {\n\t\t\t\t/* saw a valid insn\n\t\t\t\t * dst_reg = *(u32 *)(src_reg + off)\n\t\t\t\t * save type to validate intersecting paths\n\t\t\t\t */\n\t\t\t\t*prev_src_type = src_reg_type;\n\n\t\t\t} else if (reg_type_mismatch(src_reg_type, *prev_src_type)) {\n\t\t\t\t/* ABuser program is trying to use the same insn\n\t\t\t\t * dst_reg = *(u32*) (src_reg + off)\n\t\t\t\t * with different pointer types:\n\t\t\t\t * src_reg == ctx in one branch and\n\t\t\t\t * src_reg == stack|map in some other branch.\n\t\t\t\t * Reject it.\n\t\t\t\t */\n\t\t\t\tverbose(env, \"same insn cannot be used with different pointers\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t} else if (class == BPF_STX) {\n\t\t\tenum bpf_reg_type *prev_dst_type, dst_reg_type;\n\n\t\t\tif (BPF_MODE(insn->code) == BPF_XADD) {\n\t\t\t\terr = check_xadd(env, env->insn_idx, insn);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\tenv->insn_idx++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* check src1 operand */\n\t\t\terr = check_reg_arg(env, insn->src_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\t/* check src2 operand */\n\t\t\terr = check_reg_arg(env, insn->dst_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tdst_reg_type = regs[insn->dst_reg].type;\n\n\t\t\t/* check that memory (dst_reg + off) is writeable */\n\t\t\terr = check_mem_access(env, env->insn_idx, insn->dst_reg,\n\t\t\t\t\t       insn->off, BPF_SIZE(insn->code),\n\t\t\t\t\t       BPF_WRITE, insn->src_reg, false);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tprev_dst_type = &env->insn_aux_data[env->insn_idx].ptr_type;\n\n\t\t\tif (*prev_dst_type == NOT_INIT) {\n\t\t\t\t*prev_dst_type = dst_reg_type;\n\t\t\t} else if (reg_type_mismatch(dst_reg_type, *prev_dst_type)) {\n\t\t\t\tverbose(env, \"same insn cannot be used with different pointers\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t} else if (class == BPF_ST) {\n\t\t\tif (BPF_MODE(insn->code) != BPF_MEM ||\n\t\t\t    insn->src_reg != BPF_REG_0) {\n\t\t\t\tverbose(env, \"BPF_ST uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t/* check src operand */\n\t\t\terr = check_reg_arg(env, insn->dst_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tif (is_ctx_reg(env, insn->dst_reg)) {\n\t\t\t\tverbose(env, \"BPF_ST stores into R%d %s is not allowed\\n\",\n\t\t\t\t\tinsn->dst_reg,\n\t\t\t\t\treg_type_str[reg_state(env, insn->dst_reg)->type]);\n\t\t\t\treturn -EACCES;\n\t\t\t}\n\n\t\t\t/* check that memory (dst_reg + off) is writeable */\n\t\t\terr = check_mem_access(env, env->insn_idx, insn->dst_reg,\n\t\t\t\t\t       insn->off, BPF_SIZE(insn->code),\n\t\t\t\t\t       BPF_WRITE, -1, false);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t} else if (class == BPF_JMP) {\n\t\t\tu8 opcode = BPF_OP(insn->code);\n\n\t\t\tif (opcode == BPF_CALL) {\n\t\t\t\tif (BPF_SRC(insn->code) != BPF_K ||\n\t\t\t\t    insn->off != 0 ||\n\t\t\t\t    (insn->src_reg != BPF_REG_0 &&\n\t\t\t\t     insn->src_reg != BPF_PSEUDO_CALL) ||\n\t\t\t\t    insn->dst_reg != BPF_REG_0) {\n\t\t\t\t\tverbose(env, \"BPF_CALL uses reserved fields\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\t\t\t\terr = check_func_call(env, insn, &env->insn_idx);\n\t\t\t\telse\n\t\t\t\t\terr = check_helper_call(env, insn->imm, env->insn_idx);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t} else if (opcode == BPF_JA) {\n\t\t\t\tif (BPF_SRC(insn->code) != BPF_K ||\n\t\t\t\t    insn->imm != 0 ||\n\t\t\t\t    insn->src_reg != BPF_REG_0 ||\n\t\t\t\t    insn->dst_reg != BPF_REG_0) {\n\t\t\t\t\tverbose(env, \"BPF_JA uses reserved fields\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tenv->insn_idx += insn->off + 1;\n\t\t\t\tcontinue;\n\n\t\t\t} else if (opcode == BPF_EXIT) {\n\t\t\t\tif (BPF_SRC(insn->code) != BPF_K ||\n\t\t\t\t    insn->imm != 0 ||\n\t\t\t\t    insn->src_reg != BPF_REG_0 ||\n\t\t\t\t    insn->dst_reg != BPF_REG_0) {\n\t\t\t\t\tverbose(env, \"BPF_EXIT uses reserved fields\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tif (state->curframe) {\n\t\t\t\t\t/* exit from nested function */\n\t\t\t\t\tenv->prev_insn_idx = env->insn_idx;\n\t\t\t\t\terr = prepare_func_exit(env, &env->insn_idx);\n\t\t\t\t\tif (err)\n\t\t\t\t\t\treturn err;\n\t\t\t\t\tdo_print_state = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\terr = check_reference_leak(env);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t\t/* eBPF calling convetion is such that R0 is used\n\t\t\t\t * to return the value from eBPF program.\n\t\t\t\t * Make sure that it's readable at this time\n\t\t\t\t * of bpf_exit, which means that program wrote\n\t\t\t\t * something into it earlier\n\t\t\t\t */\n\t\t\t\terr = check_reg_arg(env, BPF_REG_0, SRC_OP);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t\tif (is_pointer_value(env, BPF_REG_0)) {\n\t\t\t\t\tverbose(env, \"R0 leaks addr as return value\\n\");\n\t\t\t\t\treturn -EACCES;\n\t\t\t\t}\n\n\t\t\t\terr = check_return_code(env);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\nprocess_bpf_exit:\n\t\t\t\terr = pop_stack(env, &env->prev_insn_idx,\n\t\t\t\t\t\t&env->insn_idx);\n\t\t\t\tif (err < 0) {\n\t\t\t\t\tif (err != -ENOENT)\n\t\t\t\t\t\treturn err;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tdo_print_state = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terr = check_cond_jmp_op(env, insn, &env->insn_idx);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t} else if (class == BPF_LD) {\n\t\t\tu8 mode = BPF_MODE(insn->code);\n\n\t\t\tif (mode == BPF_ABS || mode == BPF_IND) {\n\t\t\t\terr = check_ld_abs(env, insn);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t} else if (mode == BPF_IMM) {\n\t\t\t\terr = check_ld_imm(env, insn);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t\tenv->insn_idx++;\n\t\t\t\tenv->insn_aux_data[env->insn_idx].seen = true;\n\t\t\t} else {\n\t\t\t\tverbose(env, \"invalid BPF_LD mode\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tverbose(env, \"unknown insn class %d\\n\", class);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tenv->insn_idx++;\n\t}\n\n\tverbose(env, \"processed %d insns (limit %d), stack depth \",\n\t\tinsn_processed, BPF_COMPLEXITY_LIMIT_INSNS);\n\tfor (i = 0; i < env->subprog_cnt; i++) {\n\t\tu32 depth = env->subprog_info[i].stack_depth;\n\n\t\tverbose(env, \"%d\", depth);\n\t\tif (i + 1 < env->subprog_cnt)\n\t\t\tverbose(env, \"+\");\n\t}\n\tverbose(env, \"\\n\");\n\tenv->prog->aux->stack_depth = env->subprog_info[0].stack_depth;\n\treturn 0;\n}\n", "target": 1, "idx": 183414}
{"func": "bool ExtensionTtsPlatformImplChromeOs::IsSpeaking() {\n  if (chromeos::CrosLibrary::Get()->EnsureLoaded()) {\n    return chromeos::CrosLibrary::Get()->GetSpeechSynthesisLibrary()->\n        IsSpeaking();\n   }\n \n  set_error(kCrosLibraryNotLoadedError);\n  return false;\n }\n", "target": 1, "idx": 183855}
{"func": "bson_iter_init (bson_iter_t *iter,  /* OUT */\n                const bson_t *bson) /* IN */\n{\n   BSON_ASSERT (iter);\n   BSON_ASSERT (bson);\n\n   if (BSON_UNLIKELY (bson->len < 5)) {\n      memset (iter, 0, sizeof *iter);\n      return false;\n   }\n\n   iter->raw = bson_get_data (bson);\n   iter->len = bson->len;\n   iter->off = 0;\n   iter->type = 0;\n   iter->key = 0;\n   iter->d1 = 0;\n   iter->d2 = 0;\n   iter->d3 = 0;\n   iter->d4 = 0;\n   iter->next_off = 4;\n   iter->err_off = 0;\n\n   return true;\n}\n", "target": 0, "idx": 77835}
{"func": "static coroutine_fn int qcow2_co_discard(BlockDriverState *bs,\n    int64_t sector_num, int nb_sectors)\n{\n    int ret;\n    BDRVQcowState *s = bs->opaque;\n\n    qemu_co_mutex_lock(&s->lock);\n    ret = qcow2_discard_clusters(bs, sector_num << BDRV_SECTOR_BITS,\n        nb_sectors, QCOW2_DISCARD_REQUEST);\n    qemu_co_mutex_unlock(&s->lock);\n    return ret;\n}\n", "target": 0, "idx": 16763}
{"func": " void GM2TabStyle::PaintTabBackground(gfx::Canvas* canvas,\n                                     bool active,\n                                      int fill_id,\n                                      int y_inset,\n                                      const SkPath* clip) const {\n   DCHECK(!y_inset || fill_id);\n \n  const SkColor active_color =\n      tab_->controller()->GetTabBackgroundColor(TAB_ACTIVE);\n  const SkColor inactive_color =\n      tab_->GetThemeProvider()->GetDisplayProperty(\n          ThemeProperties::SHOULD_FILL_BACKGROUND_TAB_COLOR)\n          ? tab_->controller()->GetTabBackgroundColor(TAB_INACTIVE)\n          : SK_ColorTRANSPARENT;\n   const SkColor stroke_color =\n       tab_->controller()->GetToolbarTopSeparatorColor();\n  const bool paint_hover_effect = !active && IsHoverActive();\n  const float stroke_thickness = GetStrokeThickness(active);\n \n  PaintTabBackgroundFill(canvas, active, paint_hover_effect, active_color,\n                         inactive_color, fill_id, y_inset);\n   if (stroke_thickness > 0) {\n     gfx::ScopedCanvas scoped_canvas(clip ? canvas : nullptr);\n     if (clip)\n       canvas->sk_canvas()->clipPath(*clip, SkClipOp::kDifference, true);\n    PaintBackgroundStroke(canvas, active, stroke_color);\n   }\n \n   PaintSeparators(canvas);\n }\n", "target": 1, "idx": 186494}
{"func": "person_name(const person_t* person)\n{\n\treturn person != NULL ? person->name : \"\";\n}\n", "target": 0, "idx": 75098}
{"func": " static void Np_toString(js_State *J)\n {\n\tchar buf[32];\n \tjs_Object *self = js_toobject(J, 0);\n \tint radix = js_isundefined(J, 1) ? 10 : js_tointeger(J, 1);\n \tif (self->type != JS_CNUMBER)\n\t\tjs_typeerror(J, \"not a number\");\n\tif (radix == 10) {\n\t\tjs_pushstring(J, jsV_numbertostring(J, buf, self->u.number));\n\t\treturn;\n\t}\n\tif (radix < 2 || radix > 36)\n\t\tjs_rangeerror(J, \"invalid radix\");\n\n \t/* lame number to string conversion for any radix from 2 to 36 */\n \t{\n \t\tstatic const char digits[] = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n\t\tchar buf[100];\n \t\tdouble number = self->u.number;\n \t\tint sign = self->u.number < 0;\n \t\tjs_Buffer *sb = NULL;\n\t\tuint64_t u, limit = ((uint64_t)1<<52);\n\n\t\tint ndigits, exp, point;\n\n\t\tif (number == 0) { js_pushstring(J, \"0\"); return; }\n\t\tif (isnan(number)) { js_pushstring(J, \"NaN\"); return; }\n\t\tif (isinf(number)) { js_pushstring(J, sign ? \"-Infinity\" : \"Infinity\"); return; }\n\n\t\tif (sign)\n\t\t\tnumber = -number;\n\n\t\t/* fit as many digits as we want in an int */\n\t\texp = 0;\n\t\twhile (number * pow(radix, exp) > limit)\n\t\t\t--exp;\n\t\twhile (number * pow(radix, exp+1) < limit)\n\t\t\t++exp;\n\t\tu = number * pow(radix, exp) + 0.5;\n\n\t\t/* trim trailing zeros */\n\t\twhile (u > 0 && (u % radix) == 0) {\n\t\t\tu /= radix;\n\t\t\t--exp;\n\t\t}\n\n\t\t/* serialize digits */\n\t\tndigits = 0;\n\t\twhile (u > 0) {\n\t\t\tbuf[ndigits++] = digits[u % radix];\n\t\t\tu /= radix;\n\t\t}\n\t\tpoint = ndigits - exp;\n\n\t\tif (js_try(J)) {\n\t\t\tjs_free(J, sb);\n\t\t\tjs_throw(J);\n\t\t}\n\n\t\tif (sign)\n\t\t\tjs_putc(J, &sb, '-');\n\n\t\tif (point <= 0) {\n\t\t\tjs_putc(J, &sb, '0');\n\t\t\tjs_putc(J, &sb, '.');\n\t\t\twhile (point++ < 0)\n\t\t\t\tjs_putc(J, &sb, '0');\n\t\t\twhile (ndigits-- > 0)\n\t\t\t\tjs_putc(J, &sb, buf[ndigits]);\n\t\t} else {\n\t\t\twhile (ndigits-- > 0) {\n\t\t\t\tjs_putc(J, &sb, buf[ndigits]);\n\t\t\t\tif (--point == 0 && ndigits > 0)\n\t\t\t\t\tjs_putc(J, &sb, '.');\n\t\t\t}\n\t\t\twhile (point-- > 0)\n\t\t\t\tjs_putc(J, &sb, '0');\n\t\t}\n\n\t\tjs_putc(J, &sb, 0);\n\t\tjs_pushstring(J, sb->s);\n\n\t\tjs_endtry(J);\n\t\tjs_free(J, sb);\n\t}\n}\n", "target": 1, "idx": 182875}
{"func": "WebURLRequest RenderFrameImpl::CreateURLRequestForCommit(\n    const CommonNavigationParams& common_params,\n    const RequestNavigationParams& request_params,\n    network::mojom::URLLoaderClientEndpointsPtr url_loader_client_endpoints,\n    const network::ResourceResponseHead& head,\n    const GURL& body_url,\n    bool is_same_document_navigation) {\n  std::unique_ptr<StreamOverrideParameters> stream_override(\n      new StreamOverrideParameters());\n  stream_override->stream_url = body_url;\n  stream_override->url_loader_client_endpoints =\n      std::move(url_loader_client_endpoints);\n  stream_override->response = head;\n  stream_override->redirects = request_params.redirects;\n  stream_override->redirect_responses = request_params.redirect_response;\n  stream_override->redirect_infos = request_params.redirect_infos;\n\n  stream_override->on_delete = base::BindOnce(\n      [](base::WeakPtr<RenderFrameImpl> weak_self, const GURL& url) {\n        if (RenderFrameImpl* self = weak_self.get()) {\n          self->Send(\n              new FrameHostMsg_StreamHandleConsumed(self->routing_id_, url));\n        }\n      },\n      weak_factory_.GetWeakPtr());\n\n  WebURLRequest request = CreateURLRequestForNavigation(\n      common_params, request_params, std::move(stream_override),\n      frame_->IsViewSourceModeEnabled(), is_same_document_navigation);\n  request.SetFrameType(IsTopLevelNavigation(frame_)\n                           ? network::mojom::RequestContextFrameType::kTopLevel\n                           : network::mojom::RequestContextFrameType::kNested);\n\n  if (common_params.post_data) {\n    request.SetHTTPBody(GetWebHTTPBodyForRequestBody(*common_params.post_data));\n    if (!request_params.post_content_type.empty()) {\n      request.AddHTTPHeaderField(\n          WebString::FromASCII(net::HttpRequestHeaders::kContentType),\n          WebString::FromASCII(request_params.post_content_type));\n    }\n  }\n\n#if defined(OS_ANDROID)\n  request.SetHasUserGesture(common_params.has_user_gesture);\n#endif\n\n  request.SetCheckForBrowserSideNavigation(false);\n\n  request.SetNavigationStartTime(\n      ConvertToBlinkTime(common_params.navigation_start));\n\n  return request;\n}\n", "target": 0, "idx": 160568}
{"func": "IndexedDBConnection::IndexedDBConnection(\n    int child_process_id,\n    scoped_refptr<IndexedDBDatabase> database,\n    scoped_refptr<IndexedDBDatabaseCallbacks> callbacks)\n    : id_(next_id++),\n      child_process_id_(child_process_id),\n      database_(database),\n      callbacks_(callbacks),\n      weak_factory_(this) {}\n", "target": 0, "idx": 149335}
{"func": "NO_INLINE void jspeBlock() {\n  JSP_MATCH_WITH_RETURN('{',);\n  jspeBlockNoBrackets();\n  if (!JSP_SHOULDNT_PARSE) JSP_MATCH_WITH_RETURN('}',);\n  return;\n}\n", "target": 0, "idx": 82317}
{"func": "void inet6_destroy_sock(struct sock *sk)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sk_buff *skb;\n\tstruct ipv6_txoptions *opt;\n\n\t/* Release rx options */\n\n\tskb = xchg(&np->pktoptions, NULL);\n\tif (skb)\n\t\tkfree_skb(skb);\n\n\tskb = xchg(&np->rxpmtu, NULL);\n\tif (skb)\n\t\tkfree_skb(skb);\n\n\t/* Free flowlabels */\n\tfl6_free_socklist(sk);\n \n \t/* Free tx options */\n \n\topt = xchg(&np->opt, NULL);\n\tif (opt)\n\t\tsock_kfree_s(sk, opt, opt->tot_len);\n }\n", "target": 1, "idx": 180499}
{"func": "void DocumentThreadableLoader::dataReceived(Resource* resource, const char* data, size_t dataLength)\n{\n    ASSERT_UNUSED(resource, resource == this->resource());\n    ASSERT(m_async);\n\n    if (m_isUsingDataConsumerHandle)\n        return;\n\n    handleReceivedData(data, safeCast<unsigned>(dataLength));\n}\n", "target": 0, "idx": 127894}
{"func": "void ChangeListLoader::LoadDirectoryFromServerAfterLoad(\n    const DirectoryFetchInfo& directory_fetch_info,\n    const FileOperationCallback& callback,\n    FeedFetcher* fetcher,\n    FileError error,\n    ScopedVector<ChangeList> change_lists) {\n  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));\n  DCHECK(!callback.is_null());\n  DCHECK(!directory_fetch_info.empty());\n\n  fast_fetch_feed_fetcher_set_.erase(fetcher);\n  delete fetcher;\n\n  if (error != FILE_ERROR_OK) {\n    LOG(ERROR) << \"Failed to load directory: \"\n               << directory_fetch_info.local_id()\n               << \": \" << FileErrorToString(error);\n    callback.Run(error);\n    return;\n  }\n\n  base::FilePath* directory_path = new base::FilePath;\n  base::PostTaskAndReplyWithResult(\n      blocking_task_runner_,\n      FROM_HERE,\n      base::Bind(&ChangeListProcessor::RefreshDirectory,\n                 resource_metadata_,\n                 directory_fetch_info,\n                 base::Passed(&change_lists),\n                 directory_path),\n      base::Bind(&ChangeListLoader::LoadDirectoryFromServerAfterRefresh,\n                 weak_ptr_factory_.GetWeakPtr(),\n                 directory_fetch_info,\n                 callback,\n                 base::Owned(directory_path)));\n}\n", "target": 0, "idx": 121680}
{"func": "gfx::Rect BrowserView::GetToolbarBounds() const {\n  gfx::Rect toolbar_bounds(toolbar_->bounds());\n  if (toolbar_bounds.IsEmpty())\n    return toolbar_bounds;\n  toolbar_bounds.Inset(-views::NonClientFrameView::kClientEdgeThickness, 0);\n  return toolbar_bounds;\n}\n", "target": 0, "idx": 126787}
{"func": "get_chainname_rulenum(const struct ip6t_entry *s, const struct ip6t_entry *e,\n\t\t      const char *hookname, const char **chainname,\n\t\t      const char **comment, unsigned int *rulenum)\n{\n\tconst struct xt_standard_target *t = (void *)ip6t_get_target_c(s);\n\n\tif (strcmp(t->target.u.kernel.target->name, XT_ERROR_TARGET) == 0) {\n\t\t/* Head of user chain: ERROR target with chainname */\n\t\t*chainname = t->target.data;\n\t\t(*rulenum) = 0;\n \t} else if (s == e) {\n \t\t(*rulenum)++;\n \n\t\tif (s->target_offset == sizeof(struct ip6t_entry) &&\n \t\t    strcmp(t->target.u.kernel.target->name,\n \t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t    t->verdict < 0 &&\n\t\t    unconditional(&s->ipv6)) {\n \t\t\t/* Tail of chains: STANDARD target (return/policy) */\n \t\t\t*comment = *chainname == hookname\n \t\t\t\t? comments[NF_IP6_TRACE_COMMENT_POLICY]\n\t\t\t\t: comments[NF_IP6_TRACE_COMMENT_RETURN];\n\t\t}\n\t\treturn 1;\n\t} else\n\t\t(*rulenum)++;\n\n\treturn 0;\n}\n", "target": 1, "idx": 180546}
{"func": " void VP8XChunk::height(XMP_Uns32 val)\n {\n    PutLE24(&this->data[7], val - 1);\n }\n", "target": 1, "idx": 178537}
{"func": "map_engine_get_subject(void)\n{\n\treturn s_camera_person;\n}\n", "target": 0, "idx": 75029}
{"func": "void ntlm_print_negotiate_flags(UINT32 flags)\n {\n \tint i;\n \tconst char* str;\n\tWLog_INFO(TAG, \"negotiateFlags \\\"0x%08\"PRIX32\"\\\"\", flags);\n\n\tfor (i = 31; i >= 0; i--)\n\t{\n\t\tif ((flags >> i) & 1)\n\t\t{\n\t\t\tstr = NTLM_NEGOTIATE_STRINGS[(31 - i)];\n\t\t\tWLog_INFO(TAG, \"\\t%s (%d),\", str, (31 - i));\n\t\t}\n \t}\n }\n", "target": 1, "idx": 182447}
{"func": "GURL GetURLForLayoutTest(const std::string& test_name,\n                         FilePath* current_working_directory,\n                         bool* enable_pixel_dumping,\n                         std::string* expected_pixel_hash) {\n  std::string path_or_url = test_name;\n  std::string pixel_switch;\n  std::string pixel_hash;\n  std::string::size_type separator_position = path_or_url.find('\\'');\n  if (separator_position != std::string::npos) {\n    pixel_switch = path_or_url.substr(separator_position + 1);\n    path_or_url.erase(separator_position);\n  }\n  separator_position = pixel_switch.find('\\'');\n  if (separator_position != std::string::npos) {\n    pixel_hash = pixel_switch.substr(separator_position + 1);\n    pixel_switch.erase(separator_position);\n  }\n  if (enable_pixel_dumping) {\n    *enable_pixel_dumping =\n        (pixel_switch == \"--pixel-test\" || pixel_switch == \"-p\");\n  }\n  if (expected_pixel_hash)\n    *expected_pixel_hash = pixel_hash;\n  GURL test_url(path_or_url);\n  if (!(test_url.is_valid() && test_url.has_scheme())) {\n    base::ThreadRestrictions::ScopedAllowIO allow_io;\n#if defined(OS_WIN)\n    std::wstring wide_path_or_url =\n        base::SysNativeMBToWide(path_or_url);\n    FilePath local_file(wide_path_or_url);\n#else\n    FilePath local_file(path_or_url);\n#endif\n    file_util::AbsolutePath(&local_file);\n    test_url = net::FilePathToFileURL(local_file);\n  }\n  FilePath local_path;\n  {\n    base::ThreadRestrictions::ScopedAllowIO allow_io;\n    if (net::FileURLToFilePath(test_url, &local_path)) {\n      file_util::SetCurrentDirectory(local_path.DirName());\n    }\n    if (current_working_directory)\n      file_util::GetCurrentDirectory(current_working_directory);\n  }\n  return test_url;\n}\n", "target": 0, "idx": 125083}
{"func": "isis_print_mt_port_cap_subtlv(netdissect_options *ndo,\n                              const uint8_t *tptr, int len)\n{\n  int stlv_type, stlv_len;\n  const struct isis_subtlv_spb_mcid *subtlv_spb_mcid;\n  int i;\n\n  while (len > 2)\n  {\n    stlv_type = *(tptr++);\n    stlv_len  = *(tptr++);\n\n    /* first lets see if we know the subTLVs name*/\n    ND_PRINT((ndo, \"\\n\\t       %s subTLV #%u, length: %u\",\n               tok2str(isis_mt_port_cap_subtlv_values, \"unknown\", stlv_type),\n               stlv_type,\n               stlv_len));\n\n    /*len -= TLV_TYPE_LEN_OFFSET;*/\n    len = len -2;\n\n    switch (stlv_type)\n    {\n      case ISIS_SUBTLV_SPB_MCID:\n      {\n        ND_TCHECK2(*(tptr), ISIS_SUBTLV_SPB_MCID_MIN_LEN);\n\n        subtlv_spb_mcid = (const struct isis_subtlv_spb_mcid *)tptr;\n\n        ND_PRINT((ndo,  \"\\n\\t         MCID: \"));\n        isis_print_mcid(ndo, &(subtlv_spb_mcid->mcid));\n\n          /*tptr += SPB_MCID_MIN_LEN;\n            len -= SPB_MCID_MIN_LEN; */\n\n        ND_PRINT((ndo,  \"\\n\\t         AUX-MCID: \"));\n        isis_print_mcid(ndo, &(subtlv_spb_mcid->aux_mcid));\n\n          /*tptr += SPB_MCID_MIN_LEN;\n            len -= SPB_MCID_MIN_LEN; */\n        tptr = tptr + sizeof(struct isis_subtlv_spb_mcid);\n        len = len - sizeof(struct isis_subtlv_spb_mcid);\n\n        break;\n      }\n\n      case ISIS_SUBTLV_SPB_DIGEST:\n      {\n        ND_TCHECK2(*(tptr), ISIS_SUBTLV_SPB_DIGEST_MIN_LEN);\n\n        ND_PRINT((ndo, \"\\n\\t        RES: %d V: %d A: %d D: %d\",\n                        (*(tptr) >> 5), (((*tptr)>> 4) & 0x01),\n                        ((*(tptr) >> 2) & 0x03), ((*tptr) & 0x03)));\n\n        tptr++;\n\n        ND_PRINT((ndo,  \"\\n\\t         Digest: \"));\n\n        for(i=1;i<=8; i++)\n        {\n            ND_PRINT((ndo, \"%08x \", EXTRACT_32BITS(tptr)));\n            if (i%4 == 0 && i != 8)\n              ND_PRINT((ndo, \"\\n\\t                 \"));\n            tptr = tptr + 4;\n        }\n\n        len = len - ISIS_SUBTLV_SPB_DIGEST_MIN_LEN;\n\n        break;\n      }\n\n      case ISIS_SUBTLV_SPB_BVID:\n      {\n        ND_TCHECK2(*(tptr), stlv_len);\n\n        while (len >= ISIS_SUBTLV_SPB_BVID_MIN_LEN)\n        {\n          ND_TCHECK2(*(tptr), ISIS_SUBTLV_SPB_BVID_MIN_LEN);\n\n          ND_PRINT((ndo, \"\\n\\t           ECT: %08x\",\n                      EXTRACT_32BITS(tptr)));\n\n          tptr = tptr+4;\n\n          ND_PRINT((ndo, \" BVID: %d, U:%01x M:%01x \",\n                     (EXTRACT_16BITS (tptr) >> 4) ,\n                     (EXTRACT_16BITS (tptr) >> 3) & 0x01,\n                     (EXTRACT_16BITS (tptr) >> 2) & 0x01));\n\n          tptr = tptr + 2;\n          len = len - ISIS_SUBTLV_SPB_BVID_MIN_LEN;\n        }\n\n        break;\n      }\n\n      default:\n          break;\n    }\n  }\n\n  return 0;\n\n  trunc:\n    ND_PRINT((ndo, \"\\n\\t\\t\"));\n    ND_PRINT((ndo, \"%s\", tstr));\n    return(1);\n}\n", "target": 0, "idx": 62367}
{"func": "EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionRemoveEventListener(ExecState* exec)\n{\n    JSValue thisValue = exec->hostThisValue();\n    if (!thisValue.inherits(&JSTestObj::s_info))\n        return throwVMTypeError(exec);\n    JSTestObj* castedThis = jsCast<JSTestObj*>(asObject(thisValue));\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\n     TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n     if (exec->argumentCount() < 2)\n        return throwVMError(exec, createTypeError(exec, \"Not enough arguments\"));\n     JSValue listener = exec->argument(1);\n     if (!listener.isObject())\n         return JSValue::encode(jsUndefined());\n    impl->removeEventListener(ustringToAtomicString(exec->argument(0).toString(exec)->value(exec)), JSEventListener::create(asObject(listener), castedThis, false, currentWorld(exec)).get(), exec->argument(2).toBoolean(exec));\n    return JSValue::encode(jsUndefined());\n}\n", "target": 1, "idx": 184064}
{"func": "static void promiseMethodMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)\n{\n    TRACE_EVENT_SET_SAMPLING_STATE(\"Blink\", \"DOMMethod\");\n    TestObjectPythonV8Internal::promiseMethodMethod(info);\n    TRACE_EVENT_SET_SAMPLING_STATE(\"V8\", \"V8Execution\");\n}\n", "target": 0, "idx": 131609}
{"func": "static Image *ReadMACImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  register IndexPacket\n    *indexes;\n\n  register PixelPacket\n    *q;\n\n  register ssize_t\n    x;\n\n  register unsigned char\n    *p;\n\n  size_t\n    length;\n\n  ssize_t\n    offset,\n    y;\n\n  unsigned char\n    count,\n    bit,\n    byte,\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read MAC X image.\n  */\n  length=ReadBlobLSBShort(image);\n  if ((length & 0xff) != 0)\n    ThrowReaderException(CorruptImageError,\"CorruptImage\");\n  for (x=0; x < (ssize_t) 638; x++)\n    if (ReadBlobByte(image) == EOF)\n      ThrowReaderException(CorruptImageError,\"CorruptImage\");\n  image->columns=576;\n  image->rows=720;\n  image->depth=1;\n  if (AcquireImageColormap(image,2) == MagickFalse)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  if (image_info->ping != MagickFalse)\n    {\n       (void) CloseBlob(image);\n       return(GetFirstImageInList(image));\n     }\n   /*\n     Convert MAC raster image to pixel packets.\n   */\n  length=(image->columns+7)/8;\n  pixels=(unsigned char *) AcquireQuantumMemory(length+1,sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  p=pixels;\n  offset=0;\n  for (y=0; y < (ssize_t) image->rows; )\n  {\n    count=(unsigned char) ReadBlobByte(image);\n    if (EOFBlob(image) != MagickFalse)\n      break;\n    if ((count <= 0) || (count >= 128))\n      {\n        byte=(unsigned char) (~ReadBlobByte(image));\n        count=(~count)+2;\n        while (count != 0)\n        {\n          *p++=byte;\n          offset++;\n          count--;\n          if (offset >= (ssize_t) length)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (PixelPacket *) NULL)\n                break;\n              indexes=GetAuthenticIndexQueue(image);\n              p=pixels;\n              bit=0;\n              byte=0;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                if (bit == 0)\n                  byte=(*p++);\n                SetPixelIndex(indexes+x,((byte & 0x80) != 0 ? 0x01 : 0x00));\n                bit++;\n                byte<<=1;\n                if (bit == 8)\n                  bit=0;\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              offset=0;\n              p=pixels;\n              y++;\n            }\n        }\n        continue;\n      }\n    count++;\n    while (count != 0)\n    {\n      byte=(unsigned char) (~ReadBlobByte(image));\n      *p++=byte;\n      offset++;\n      count--;\n      if (offset >= (ssize_t) length)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          indexes=GetAuthenticIndexQueue(image);\n          p=pixels;\n          bit=0;\n          byte=0;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            if (bit == 0)\n              byte=(*p++);\n            SetPixelIndex(indexes+x,((byte & 0x80) != 0 ?  0x01 : 0x00));\n            bit++;\n            byte<<=1;\n            if (bit == 8)\n              bit=0;\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          offset=0;\n          p=pixels;\n          y++;\n        }\n    }\n  }\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  (void) SyncImage(image);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n", "target": 1, "idx": 181750}
{"func": "int emulator_write_phys(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\tconst void *val, int bytes)\n{\n\tint ret;\n\n\tret = kvm_write_guest(vcpu->kvm, gpa, val, bytes);\n\tif (ret < 0)\n\t\treturn 0;\n\tkvm_mmu_pte_write(vcpu, gpa, val, bytes);\n\treturn 1;\n}\n", "target": 0, "idx": 20692}
{"func": "static int tg3_poll(struct napi_struct *napi, int budget)\n{\n\tstruct tg3_napi *tnapi = container_of(napi, struct tg3_napi, napi);\n\tstruct tg3 *tp = tnapi->tp;\n\tint work_done = 0;\n\tstruct tg3_hw_status *sblk = tnapi->hw_status;\n\n\twhile (1) {\n\t\tif (sblk->status & SD_STATUS_ERROR)\n\t\t\ttg3_process_error(tp);\n\n\t\ttg3_poll_link(tp);\n\n\t\twork_done = tg3_poll_work(tnapi, work_done, budget);\n\n\t\tif (unlikely(tg3_flag(tp, TX_RECOVERY_PENDING)))\n\t\t\tgoto tx_recovery;\n\n\t\tif (unlikely(work_done >= budget))\n\t\t\tbreak;\n\n\t\tif (tg3_flag(tp, TAGGED_STATUS)) {\n\t\t\t/* tp->last_tag is used in tg3_int_reenable() below\n\t\t\t * to tell the hw how much work has been processed,\n\t\t\t * so we must read it before checking for more work.\n\t\t\t */\n\t\t\ttnapi->last_tag = sblk->status_tag;\n\t\t\ttnapi->last_irq_tag = tnapi->last_tag;\n\t\t\trmb();\n\t\t} else\n\t\t\tsblk->status &= ~SD_STATUS_UPDATED;\n\n\t\tif (likely(!tg3_has_work(tnapi))) {\n\t\t\tnapi_complete(napi);\n\t\t\ttg3_int_reenable(tnapi);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn work_done;\n\ntx_recovery:\n\t/* work_done is guaranteed to be less than budget. */\n\tnapi_complete(napi);\n\ttg3_reset_task_schedule(tp);\n\treturn work_done;\n}\n", "target": 0, "idx": 32677}
{"func": "int UDPSocketLibevent::InternalRecvFrom(IOBuffer* buf, int buf_len,\n                                        IPEndPoint* address) {\n  int bytes_transferred;\n  int flags = 0;\n\n  SockaddrStorage storage;\n\n  bytes_transferred =\n      HANDLE_EINTR(recvfrom(socket_,\n                            buf->data(),\n                            buf_len,\n                            flags,\n                            storage.addr,\n                            &storage.addr_len));\n  int result;\n  if (bytes_transferred >= 0) {\n    result = bytes_transferred;\n    if (address && !address->FromSockAddr(storage.addr, storage.addr_len))\n      result = ERR_FAILED;\n  } else {\n    result = MapSystemError(errno);\n  }\n  if (result != ERR_IO_PENDING)\n    LogRead(result, buf->data(), storage.addr_len, storage.addr);\n  return result;\n}\n", "target": 0, "idx": 121756}
{"func": " WebRunnerMainDelegate::WebRunnerMainDelegate(zx::channel context_channel)\n    : context_channel_(std::move(context_channel)) {}\n", "target": 1, "idx": 186128}
{"func": "void DownloadFileManager::RenameInProgressDownloadFile(\n     DownloadId global_id,\n     const FilePath& full_path,\n     bool overwrite_existing_file,\n     const RenameCompletionCallback& callback) {\n  VLOG(20) << __FUNCTION__ << \"()\" << \" id = \" << global_id\n           << \" full_path = \\\"\" << full_path.value() << \"\\\"\";\n   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::FILE));\n   DownloadFile* download_file = GetDownloadFile(global_id);\n   if (!download_file) {\n     BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,\n                             base::Bind(callback, FilePath()));\n     return;\n   }\n \n  VLOG(20) << __FUNCTION__ << \"()\"\n           << \" download_file = \" << download_file->DebugString();\n   FilePath new_path(full_path);\n   if (!overwrite_existing_file) {\n     int uniquifier =\n         file_util::GetUniquePathNumber(new_path, FILE_PATH_LITERAL(\"\"));\n     if (uniquifier > 0) {\n      new_path = new_path.InsertBeforeExtensionASCII(\n          StringPrintf(\" (%d)\", uniquifier));\n     }\n   }\n \n   net::Error rename_error = download_file->Rename(new_path);\n   if (net::OK != rename_error) {\n    CancelDownloadOnRename(global_id, rename_error);\n    new_path.clear();\n  }\n  BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,\n                          base::Bind(callback, new_path));\n}\n", "target": 1, "idx": 184452}
{"func": "static int create_window_attributes(NPSetWindowCallbackStruct *ws_info)\n{\n  if (ws_info == NULL)\n\treturn -1;\n  GdkVisual *gdk_visual;\n  if (ws_info->visual)\n\tgdk_visual = gdkx_visual_get((uintptr_t)ws_info->visual);\n  else\n\tgdk_visual = gdk_visual_get_system();\n  if (gdk_visual == NULL) {\n\tnpw_printf(\"ERROR: could not reconstruct XVisual from visualID\\n\");\n\treturn -2;\n  }\n  ws_info->display = x_display;\n  ws_info->visual = gdk_x11_visual_get_xvisual(gdk_visual);\n  return 0;\n}\n", "target": 0, "idx": 27023}
{"func": "void rds_recv_incoming(struct rds_connection *conn, __be32 saddr, __be32 daddr,\n\t\t       struct rds_incoming *inc, gfp_t gfp)\n{\n\tstruct rds_sock *rs = NULL;\n\tstruct sock *sk;\n\tunsigned long flags;\n\n\tinc->i_conn = conn;\n\tinc->i_rx_jiffies = jiffies;\n\n\trdsdebug(\"conn %p next %llu inc %p seq %llu len %u sport %u dport %u \"\n\t\t \"flags 0x%x rx_jiffies %lu\\n\", conn,\n\t\t (unsigned long long)conn->c_next_rx_seq,\n\t\t inc,\n\t\t (unsigned long long)be64_to_cpu(inc->i_hdr.h_sequence),\n\t\t be32_to_cpu(inc->i_hdr.h_len),\n\t\t be16_to_cpu(inc->i_hdr.h_sport),\n\t\t be16_to_cpu(inc->i_hdr.h_dport),\n\t\t inc->i_hdr.h_flags,\n\t\t inc->i_rx_jiffies);\n\n\t/*\n\t * Sequence numbers should only increase.  Messages get their\n\t * sequence number as they're queued in a sending conn.  They\n\t * can be dropped, though, if the sending socket is closed before\n\t * they hit the wire.  So sequence numbers can skip forward\n\t * under normal operation.  They can also drop back in the conn\n\t * failover case as previously sent messages are resent down the\n\t * new instance of a conn.  We drop those, otherwise we have\n\t * to assume that the next valid seq does not come after a\n\t * hole in the fragment stream.\n\t *\n\t * The headers don't give us a way to realize if fragments of\n\t * a message have been dropped.  We assume that frags that arrive\n\t * to a flow are part of the current message on the flow that is\n\t * being reassembled.  This means that senders can't drop messages\n\t * from the sending conn until all their frags are sent.\n\t *\n\t * XXX we could spend more on the wire to get more robust failure\n\t * detection, arguably worth it to avoid data corruption.\n\t */\n\tif (be64_to_cpu(inc->i_hdr.h_sequence) < conn->c_next_rx_seq &&\n\t    (inc->i_hdr.h_flags & RDS_FLAG_RETRANSMITTED)) {\n\t\trds_stats_inc(s_recv_drop_old_seq);\n\t\tgoto out;\n\t}\n\tconn->c_next_rx_seq = be64_to_cpu(inc->i_hdr.h_sequence) + 1;\n\n\tif (rds_sysctl_ping_enable && inc->i_hdr.h_dport == 0) {\n\t\trds_stats_inc(s_recv_ping);\n\t\trds_send_pong(conn, inc->i_hdr.h_sport);\n\t\tgoto out;\n\t}\n\n\trs = rds_find_bound(daddr, inc->i_hdr.h_dport);\n\tif (!rs) {\n\t\trds_stats_inc(s_recv_drop_no_sock);\n\t\tgoto out;\n\t}\n\n\t/* Process extension headers */\n\trds_recv_incoming_exthdrs(inc, rs);\n\n\t/* We can be racing with rds_release() which marks the socket dead. */\n\tsk = rds_rs_to_sk(rs);\n\n\t/* serialize with rds_release -> sock_orphan */\n\twrite_lock_irqsave(&rs->rs_recv_lock, flags);\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\trdsdebug(\"adding inc %p to rs %p's recv queue\\n\", inc, rs);\n\t\trds_stats_inc(s_recv_queued);\n\t\trds_recv_rcvbuf_delta(rs, sk, inc->i_conn->c_lcong,\n\t\t\t\t      be32_to_cpu(inc->i_hdr.h_len),\n\t\t\t\t      inc->i_hdr.h_dport);\n\t\tif (sock_flag(sk, SOCK_RCVTSTAMP))\n\t\t\tdo_gettimeofday(&inc->i_rx_tstamp);\n\t\trds_inc_addref(inc);\n\t\tlist_add_tail(&inc->i_item, &rs->rs_recv_queue);\n\t\t__rds_wake_sk_sleep(sk);\n\t} else {\n\t\trds_stats_inc(s_recv_drop_dead_sock);\n\t}\n\twrite_unlock_irqrestore(&rs->rs_recv_lock, flags);\n\nout:\n\tif (rs)\n\t\trds_sock_put(rs);\n}\n", "target": 0, "idx": 52058}
{"func": "static int kvm_handle_cp_32(struct kvm_vcpu *vcpu,\n\t\t\t    const struct sys_reg_desc *global,\n\t\t\t    size_t nr_global,\n\t\t\t    const struct sys_reg_desc *target_specific,\n\t\t\t    size_t nr_specific)\n{\n\tstruct sys_reg_params params;\n\tu32 hsr = kvm_vcpu_get_hsr(vcpu);\n\tint Rt  = (hsr >> 5) & 0xf;\n\n\tparams.is_aarch32 = true;\n\tparams.is_32bit = true;\n\tparams.CRm = (hsr >> 1) & 0xf;\n\tparams.regval = vcpu_get_reg(vcpu, Rt);\n\tparams.is_write = ((hsr & 1) == 0);\n\tparams.CRn = (hsr >> 10) & 0xf;\n\tparams.Op0 = 0;\n\tparams.Op1 = (hsr >> 14) & 0x7;\n\tparams.Op2 = (hsr >> 17) & 0x7;\n\n\tif (!emulate_cp(vcpu, &params, target_specific, nr_specific) ||\n\t    !emulate_cp(vcpu, &params, global, nr_global)) {\n\t\tif (!params.is_write)\n\t\t\tvcpu_set_reg(vcpu, Rt, params.regval);\n\t\treturn 1;\n\t}\n\n\tunhandled_cp_access(vcpu, &params);\n\treturn 1;\n}\n", "target": 0, "idx": 62901}
{"func": " std::string Backtrace::GetFunctionName(uintptr_t pc, uintptr_t* offset) {\n   std::string func_name = GetFunctionNameRaw(pc, offset);\n  if (!func_name.empty()) {\n#if defined(__APPLE__)\n    if (func_name[0] != '_') {\n      return func_name;\n    }\n#endif\n    char* name = __cxa_demangle(func_name.c_str(), 0, 0, 0);\n    if (name) {\n      func_name = name;\n      free(name);\n    }\n  }\n   return func_name;\n }\n", "target": 1, "idx": 187909}
{"func": "void arch_pick_mmap_layout(struct mm_struct *mm)\n{\n\tunsigned long random_factor = 0UL;\n\n \tif (current->flags & PF_RANDOMIZE)\n \t\trandom_factor = arch_mmap_rnd();\n \n\tmm->mmap_legacy_base = mmap_legacy_base(random_factor);\n \n \tif (mmap_is_legacy()) {\n \t\tmm->mmap_base = mm->mmap_legacy_base;\n\t\tmm->get_unmapped_area = arch_get_unmapped_area;\n\t} else {\n\t\tmm->mmap_base = mmap_base(random_factor);\n\t\tmm->get_unmapped_area = arch_get_unmapped_area_topdown;\n\t}\n}\n", "target": 1, "idx": 180524}
{"func": "is_v2_ckpt( const char *name )\n{\n\tint\t\tcluster;\n\tint\t\tproc;\n\n\tcluster = grab_val( name, \"job\" );\n\tproc = grab_val( name, \".ckpt.\" );\n\n\tif( proc < 0 ) {\n\t\treturn cluster_exists( cluster );\n\t} else {\n\t\treturn proc_exists( cluster, proc );\n\t}\n}\n", "target": 0, "idx": 16474}
{"func": "   bool UnSetVarImpl(const char* variable_name) {\n #if defined(OS_POSIX)\n    return unsetenv(variable_name) == 0;\n #elif defined(OS_WIN)\n    return ::SetEnvironmentVariable(ASCIIToWide(variable_name).c_str(),\n                                    NULL) != 0;\n #endif\n   }\n", "target": 1, "idx": 183441}
{"func": "brailleIndicatorDefined(TranslationTableOffset offset,\n\t\tconst TranslationTableHeader *table, const TranslationTableRule **indicRule) {\n\tif (!offset) return 0;\n\t*indicRule = (TranslationTableRule *)&table->ruleArea[offset];\n\treturn 1;\n}\n", "target": 0, "idx": 76725}
{"func": "void SSL3_RECORD_clear(SSL3_RECORD *r, unsigned int num_recs)\n{\n    unsigned char *comp;\n    unsigned int i;\n\n    for (i = 0; i < num_recs; i++) {\n        comp = r[i].comp;\n\n        memset(&r[i], 0, sizeof(*r));\n        r[i].comp = comp;\n    }\n}\n", "target": 0, "idx": 12691}
{"func": "static DNLI_t dnlFreeIterator(DNLI_t dnli)\n{\n    if (dnli) {\n\tif (dnli->active) free(dnli->active);\n\tfree(dnli);\n    }\n    return NULL;\n}\n", "target": 0, "idx": 67481}
{"func": "void ExtensionPrefs::SetExtensionPrefURLPatternSet(\n    const std::string& extension_id,\n    const std::string& pref_key,\n    const URLPatternSet& new_value) {\n  ListValue* value = new ListValue();\n  for (URLPatternSet::const_iterator i = new_value.begin();\n       i != new_value.end(); ++i)\n    value->AppendIfNotPresent(Value::CreateStringValue(i->GetAsString()));\n\n  UpdateExtensionPref(extension_id, pref_key, value);\n}\n", "target": 0, "idx": 102328}
{"func": "static void btif_dm_search_services_evt(UINT16 event, char *p_param)\n{\n    tBTA_DM_SEARCH *p_data = (tBTA_DM_SEARCH*)p_param;\n\n    BTIF_TRACE_EVENT(\"%s:  event = %d\", __FUNCTION__, event);\n switch (event)\n {\n case BTA_DM_DISC_RES_EVT:\n {\n bt_property_t prop;\n uint32_t i = 0;\n bt_bdaddr_t bd_addr;\n bt_status_t ret;\n\n            bdcpy(bd_addr.address, p_data->disc_res.bd_addr);\n\n            BTIF_TRACE_DEBUG(\"%s:(result=0x%x, services 0x%x)\", __FUNCTION__,\n                    p_data->disc_res.result, p_data->disc_res.services);\n if ((p_data->disc_res.result != BTA_SUCCESS) &&\n (pairing_cb.state == BT_BOND_STATE_BONDING ) &&\n (pairing_cb.sdp_attempts < BTIF_DM_MAX_SDP_ATTEMPTS_AFTER_PAIRING))\n {\n                BTIF_TRACE_WARNING(\"%s:SDP failed after bonding re-attempting\", __FUNCTION__);\n                pairing_cb.sdp_attempts++;\n                btif_dm_get_remote_services(&bd_addr);\n return;\n }\n            prop.type = BT_PROPERTY_UUIDS;\n            prop.len = 0;\n if ((p_data->disc_res.result == BTA_SUCCESS) && (p_data->disc_res.num_uuids > 0))\n {\n                 prop.val = p_data->disc_res.p_uuid_list;\n                 prop.len = p_data->disc_res.num_uuids * MAX_UUID_SIZE;\n for (i=0; i < p_data->disc_res.num_uuids; i++)\n {\n char temp[256];\n                      uuid_to_string_legacy((bt_uuid_t*)(p_data->disc_res.p_uuid_list + (i*MAX_UUID_SIZE)), temp);\n                      LOG_INFO(\"%s index:%d uuid:%s\", __func__, i, temp);\n }\n }\n\n /* onUuidChanged requires getBondedDevices to be populated.\n            ** bond_state_changed needs to be sent prior to remote_device_property\n            */\n if ((pairing_cb.state == BT_BOND_STATE_BONDING) &&\n ((bdcmp(p_data->disc_res.bd_addr, pairing_cb.bd_addr) == 0) ||\n (bdcmp(p_data->disc_res.bd_addr, pairing_cb.static_bdaddr.address) == 0)) &&\n                  pairing_cb.sdp_attempts > 0)\n {\n                 BTIF_TRACE_DEBUG(\"%s Remote Service SDP done. Call bond_state_changed_cb BONDED\",\n                                   __FUNCTION__);\n                 pairing_cb.sdp_attempts  = 0;\n\n if (bdcmp(p_data->disc_res.bd_addr, pairing_cb.static_bdaddr.address) == 0)\n                    bond_state_changed(BT_STATUS_SUCCESS, &bd_addr, BT_BOND_STATE_BONDING);\n\n                 bond_state_changed(BT_STATUS_SUCCESS, &bd_addr, BT_BOND_STATE_BONDED);\n }\n\n if (p_data->disc_res.num_uuids != 0)\n {\n /* Also write this to the NVRAM */\n                ret = btif_storage_set_remote_device_property(&bd_addr, &prop);\n                ASSERTC(ret == BT_STATUS_SUCCESS, \"storing remote services failed\", ret);\n /* Send the event to the BTIF */\n                HAL_CBACK(bt_hal_cbacks, remote_device_properties_cb,\n                                 BT_STATUS_SUCCESS, &bd_addr, 1, &prop);\n }\n }\n break;\n\n case BTA_DM_DISC_CMPL_EVT:\n /* fixme */\n break;\n\n#if (defined(BLE_INCLUDED) && (BLE_INCLUDED == TRUE))\n case BTA_DM_DISC_BLE_RES_EVT:\n             BTIF_TRACE_DEBUG(\"%s:, services 0x%x)\", __FUNCTION__,\n                                p_data->disc_ble_res.service.uu.uuid16);\n bt_uuid_t  uuid;\n int i = 0;\n int j = 15;\n if (p_data->disc_ble_res.service.uu.uuid16 == UUID_SERVCLASS_LE_HID)\n {\n                BTIF_TRACE_DEBUG(\"%s: Found HOGP UUID\",__FUNCTION__);\n bt_property_t prop;\n bt_bdaddr_t bd_addr;\n char temp[256];\n bt_status_t ret;\n\n                bta_gatt_convert_uuid16_to_uuid128(uuid.uu,p_data->disc_ble_res.service.uu.uuid16);\n\n while(i < j )\n {\n unsigned char c = uuid.uu[j];\n                    uuid.uu[j] = uuid.uu[i];\n                    uuid.uu[i] = c;\n                    i++;\n                    j--;\n }\n\n                uuid_to_string_legacy(&uuid, temp);\n                LOG_INFO(\"%s uuid:%s\", __func__, temp);\n\n                bdcpy(bd_addr.address, p_data->disc_ble_res.bd_addr);\n                prop.type = BT_PROPERTY_UUIDS;\n                prop.val = uuid.uu;\n                prop.len = MAX_UUID_SIZE;\n\n /* Also write this to the NVRAM */\n                ret = btif_storage_set_remote_device_property(&bd_addr, &prop);\n                ASSERTC(ret == BT_STATUS_SUCCESS, \"storing remote services failed\", ret);\n\n /* Send the event to the BTIF */\n                HAL_CBACK(bt_hal_cbacks, remote_device_properties_cb,\n                                 BT_STATUS_SUCCESS, &bd_addr, 1, &prop);\n\n }\n break;\n#endif /* BLE_INCLUDED */\n\n default:\n {\n            ASSERTC(0, \"unhandled search services event\", event);\n }\n break;\n }\n}\n", "target": 0, "idx": 171781}
{"func": "void jswrap_graphics_fillPoly(JsVar *parent, JsVar *poly) {\n  JsGraphics gfx; if (!graphicsGetFromVar(&gfx, parent)) return;\n  if (!jsvIsIterable(poly)) return;\n  const int maxVerts = 128;\n  short verts[maxVerts];\n  int idx = 0;\n  JsvIterator it;\n  jsvIteratorNew(&it, poly, JSIF_EVERY_ARRAY_ELEMENT);\n  while (jsvIteratorHasElement(&it) && idx<maxVerts) {\n    verts[idx++] = (short)jsvIteratorGetIntegerValue(&it);\n    jsvIteratorNext(&it);\n  }\n  jsvIteratorFree(&it);\n  if (idx==maxVerts) {\n    jsWarn(\"Maximum number of points (%d) exceeded for fillPoly\", maxVerts/2);\n  }\n  graphicsFillPoly(&gfx, idx/2, verts);\n  graphicsSetVar(&gfx); // gfx data changed because modified area\n}\n", "target": 0, "idx": 82570}
{"func": "bool RenderWidgetHostViewAura::SwapBuffersPrepare(\n    const gfx::Rect& surface_rect,\n    float surface_scale_factor,\n    const gfx::Rect& damage_rect,\n    const std::string& mailbox_name,\n    const BufferPresentedCallback& ack_callback) {\n  if (last_swapped_surface_size_ != surface_rect.size()) {\n    DLOG_IF(ERROR, damage_rect != surface_rect) << \"Expected full damage rect\";\n    skipped_damage_.setEmpty();\n    last_swapped_surface_size_ = surface_rect.size();\n    last_swapped_surface_scale_factor_ = surface_scale_factor;\n  }\n\n  if (ShouldSkipFrame(ConvertSizeToDIP(surface_scale_factor,\n                                       surface_rect.size())) ||\n      mailbox_name.empty()) {\n    skipped_damage_.op(RectToSkIRect(damage_rect), SkRegion::kUnion_Op);\n    ack_callback.Run(true, scoped_refptr<ui::Texture>());\n    return false;\n  }\n\n  ImageTransportFactory* factory = ImageTransportFactory::GetInstance();\n  current_surface_ =\n      factory->CreateTransportClient(surface_scale_factor);\n  if (!current_surface_.get()) {\n    LOG(ERROR) << \"Failed to create ImageTransport texture\";\n    ack_callback.Run(true, scoped_refptr<ui::Texture>());\n    return false;\n  }\n\n  current_surface_->Consume(mailbox_name, surface_rect.size());\n  released_front_lock_ = NULL;\n  UpdateExternalTexture();\n\n  return true;\n}\n", "target": 0, "idx": 133042}
{"func": "void MigrationTest::SetUpVersion69Database() {\n  sql::Connection connection;\n  ASSERT_TRUE(connection.Open(GetDatabasePath()));\n  ASSERT_TRUE(connection.BeginTransaction());\n  ASSERT_TRUE(connection.Execute(\n      \"CREATE TABLE extended_attributes(metahandle bigint, key varchar(127), \"\n          \"value blob, PRIMARY KEY(metahandle, key) ON CONFLICT REPLACE);\"\n      \"CREATE TABLE metas (metahandle bigint primary key ON CONFLICT FAIL,\"\n          \"base_version bigint default -1,server_version bigint default 0,\"\n          \"mtime bigint default 0,server_mtime bigint default 0,\"\n          \"ctime bigint default 0,server_ctime bigint default 0,\"\n          \"server_position_in_parent bigint default 0,\"\n          \"local_external_id bigint default 0,id varchar(255) default 'r',\"\n          \"parent_id varchar(255) default 'r',\"\n          \"server_parent_id varchar(255) default 'r',\"\n          \"prev_id varchar(255) default 'r',next_id varchar(255) default 'r',\"\n          \"is_unsynced bit default 0,is_unapplied_update bit default 0,\"\n          \"is_del bit default 0,is_dir bit default 0,\"\n          \"is_bookmark_object bit default 0,server_is_dir bit default 0,\"\n          \"server_is_del bit default 0,\"\n          \"server_is_bookmark_object bit default 0,\"\n          \"non_unique_name varchar,server_non_unique_name varchar(255),\"\n          \"bookmark_url varchar,server_bookmark_url varchar,\"\n           \"singleton_tag varchar,bookmark_favicon blob,\"\n           \"server_bookmark_favicon blob, specifics blob, \"\n           \"server_specifics blob);\"\n      \"INSERT INTO metas VALUES(1,-1,0,\" LEGACY_PROTO_TIME_VALS(1)\n          \",0,0,'r','r','r','r','r',0,0,0,1,0,0,0,0,NULL,NULL,NULL,NULL,NULL,\"\n           \"NULL,NULL,X'',X'');\"\n      \"INSERT INTO metas VALUES(2,669,669,\" LEGACY_PROTO_TIME_VALS(2)\n          \",-2097152,\"\n           \"4,'s_ID_2','s_ID_9','s_ID_9','s_ID_2','s_ID_2',0,0,1,0,1,0,1,1,\"\n           \"'Deleted Item','Deleted Item','http://www.google.com/',\"\n           \"'http://www.google.com/2',NULL,'AASGASGA','ASADGADGADG',\"\n           \"X'C28810220A16687474703A2F2F7777772E676F6F676C652E636F6D2F120841415\"\n           \"34741534741',X'C28810260A17687474703A2F2F7777772E676F6F676C652E636F\"\n           \"6D2F32120B4153414447414447414447');\"\n      \"INSERT INTO metas VALUES(4,681,681,\" LEGACY_PROTO_TIME_VALS(4)\n          \",-3145728,\"\n           \"3,'s_ID_4','s_ID_9','s_ID_9','s_ID_4','s_ID_4',0,0,1,0,1,0,1,1,\"\n           \"'Welcome to Chromium','Welcome to Chromium',\"\n           \"'http://www.google.com/chrome/intl/en/welcome.html',\"\n          \"'http://www.google.com/chrome/intl/en/welcome.html',NULL,NULL,NULL,\"\n          \"X'C28810350A31687474703A2F2F7777772E676F6F676C652E636F6D2F6368726F6\"\n           \"D652F696E746C2F656E2F77656C636F6D652E68746D6C1200',X'C28810350A3168\"\n           \"7474703A2F2F7777772E676F6F676C652E636F6D2F6368726F6D652F696E746C2F6\"\n           \"56E2F77656C636F6D652E68746D6C1200');\"\n      \"INSERT INTO metas VALUES(5,677,677,\" LEGACY_PROTO_TIME_VALS(5)\n          \",1048576,7,\"\n           \"'s_ID_5','s_ID_9','s_ID_9','s_ID_5','s_ID_5',0,0,1,0,1,0,1,1,\"\n           \"'Google','Google','http://www.google.com/',\"\n           \"'http://www.google.com/',NULL,'AGASGASG','AGFDGASG',X'C28810220A166\"\n           \"87474703A2F2F7777772E676F6F676C652E636F6D2F12084147415347415347',X'\"\n           \"C28810220A16687474703A2F2F7777772E676F6F676C652E636F6D2F12084147464\"\n           \"447415347');\"\n      \"INSERT INTO metas VALUES(6,694,694,\" LEGACY_PROTO_TIME_VALS(6)\n          \",-4194304,6\"\n           \",'s_ID_6','s_ID_9','s_ID_9','r','r',0,0,0,1,1,1,0,1,'The Internet',\"\n           \"'The Internet',NULL,NULL,NULL,NULL,NULL,X'C2881000',X'C2881000');\"\n      \"INSERT INTO metas VALUES(7,663,663,\" LEGACY_PROTO_TIME_VALS(7)\n          \",1048576,0,\"\n           \"'s_ID_7','r','r','r','r',0,0,0,1,1,1,0,1,'Google Chrome',\"\n           \"'Google Chrome',NULL,NULL,'google_chrome',NULL,NULL,NULL,NULL);\"\n      \"INSERT INTO metas VALUES(8,664,664,\" LEGACY_PROTO_TIME_VALS(8)\n          \",1048576,0,\"\n           \"'s_ID_8','s_ID_7','s_ID_7','r','r',0,0,0,1,1,1,0,1,'Bookmarks',\"\n           \"'Bookmarks',NULL,NULL,'google_chrome_bookmarks',NULL,NULL,\"\n           \"X'C2881000',X'C2881000');\"\n      \"INSERT INTO metas VALUES(9,665,665,\" LEGACY_PROTO_TIME_VALS(9)\n          \",1048576,1,\"\n           \"'s_ID_9','s_ID_8','s_ID_8','r','s_ID_10',0,0,0,1,1,1,0,1,\"\n           \"'Bookmark Bar','Bookmark Bar',NULL,NULL,'bookmark_bar',NULL,NULL,\"\n           \"X'C2881000',X'C2881000');\"\n      \"INSERT INTO metas VALUES(10,666,666,\" LEGACY_PROTO_TIME_VALS(10)\n          \",2097152,2,\"\n           \"'s_ID_10','s_ID_8','s_ID_8','s_ID_9','r',0,0,0,1,1,1,0,1,\"\n           \"'Other Bookmarks','Other Bookmarks',NULL,NULL,'other_bookmarks',\"\n           \"NULL,NULL,X'C2881000',X'C2881000');\"\n      \"INSERT INTO metas VALUES(11,683,683,\" LEGACY_PROTO_TIME_VALS(11)\n          \",-1048576,\"\n           \"8,'s_ID_11','s_ID_6','s_ID_6','r','s_ID_13',0,0,0,0,1,0,0,1,\"\n           \"'Home (The Chromium Projects)','Home (The Chromium Projects)',\"\n           \"'http://dev.chromium.org/','http://dev.chromium.org/other',NULL,\"\n           \"'AGATWA','AFAGVASF',X'C28810220A18687474703A2F2F6465762E6368726F6D6\"\n           \"9756D2E6F72672F1206414741545741',X'C28810290A1D687474703A2F2F646576\"\n           \"2E6368726F6D69756D2E6F72672F6F7468657212084146414756415346');\"\n      \"INSERT INTO metas VALUES(12,685,685,\" LEGACY_PROTO_TIME_VALS(12)\n          \",0,9,\"\n           \"'s_ID_12','s_ID_6','s_ID_6','s_ID_13','s_ID_14',0,0,0,1,1,1,0,1,\"\n           \"'Extra Bookmarks','Extra Bookmarks',NULL,NULL,NULL,NULL,NULL,\"\n           \"X'C2881000',X'C2881000');\"\n      \"INSERT INTO metas VALUES(13,687,687,\" LEGACY_PROTO_TIME_VALS(13)\n          \",-917504,\"\n           \"10,'s_ID_13','s_ID_6','s_ID_6','s_ID_11','s_ID_12',0,0,0,0,1,0,0,\"\n           \"1,'ICANN | Internet Corporation for Assigned Names and Numbers',\"\n           \"'ICANN | Internet Corporation for Assigned Names and Numbers',\"\n           \"'http://www.icann.com/','http://www.icann.com/',NULL,'PNGAXF0AAFF',\"\n           \"'DAAFASF',X'C28810240A15687474703A2F2F7777772E6963616E6E2E636F6D2F1\"\n           \"20B504E474158463041414646',X'C28810200A15687474703A2F2F7777772E6963\"\n           \"616E6E2E636F6D2F120744414146415346');\"\n      \"INSERT INTO metas VALUES(14,692,692,\" LEGACY_PROTO_TIME_VALS(14)\n          \",1048576,11,\"\n           \"'s_ID_14','s_ID_6','s_ID_6','s_ID_12','r',0,0,0,0,1,0,0,1,\"\n           \"'The WebKit Open Source Project','The WebKit Open Source Project',\"\n           \"'http://webkit.org/','http://webkit.org/x',NULL,'PNGX','PNG2Y',\"\n          \"X'C288101A0A12687474703A2F2F7765626B69742E6F72672F1204504E4758',X'C2\"\n          \"88101C0A13687474703A2F2F7765626B69742E6F72672F781205504E473259');\"\n      \"CREATE TABLE share_info (id VARCHAR(128) primary key, \"\n          \"last_sync_timestamp INT, name VARCHAR(128), \"\n          \"initial_sync_ended BIT default 0, store_birthday VARCHAR(256), \"\n          \"db_create_version VARCHAR(128), db_create_time int, \"\n          \"next_id bigint default -2, cache_guid VARCHAR(32));\"\n      \"INSERT INTO share_info VALUES('nick@chromium.org',694,\"\n          \"'nick@chromium.org',1,'c27e9f59-08ca-46f8-b0cc-f16a2ed778bb',\"\n          \"'Unknown',1263522064,-65542,\"\n          \"'9010788312004066376x-6609234393368420856x');\"\n      \"CREATE TABLE share_version (id VARCHAR(128) primary key, data INT);\"\n      \"INSERT INTO share_version VALUES('nick@chromium.org',69);\"\n  ));\n  ASSERT_TRUE(connection.CommitTransaction());\n}\n", "target": 1, "idx": 183679}
{"func": "static u32 apic_get_tmcct(struct kvm_lapic *apic)\n{\n\tktime_t remaining;\n\ts64 ns;\n\tu32 tmcct;\n\n \tASSERT(apic != NULL);\n \n \t/* if initial count is 0, current count should also be 0 */\n\tif (kvm_apic_get_reg(apic, APIC_TMICT) == 0)\n \t\treturn 0;\n \n \tremaining = hrtimer_get_remaining(&apic->lapic_timer.timer);\n\tif (ktime_to_ns(remaining) < 0)\n\t\tremaining = ktime_set(0, 0);\n\n\tns = mod_64(ktime_to_ns(remaining), apic->lapic_timer.period);\n\ttmcct = div64_u64(ns,\n\t\t\t (APIC_BUS_CYCLE_NS * apic->divide_count));\n\n\treturn tmcct;\n}\n", "target": 1, "idx": 179123}
{"func": "unsigned AudioNode::numberOfInputs() const {\n  return Handler().NumberOfInputs();\n}\n", "target": 0, "idx": 161661}
{"func": "inline static int php_openssl_safe_mode_chk(char *filename TSRMLS_DC)\n{\n\tif (PG(safe_mode) && (!php_checkuid(filename, NULL, CHECKUID_CHECK_FILE_AND_DIR))) {\n\t\treturn -1;\n\t}\n\tif (php_check_open_basedir(filename TSRMLS_CC)) {\n\t\treturn -1;\n\t}\n\t\n\treturn 0;\n}\n", "target": 0, "idx": 164}
{"func": "ModuleExport MagickBooleanType ReadPSDLayers(Image *image,\n  const ImageInfo *image_info,const PSDInfo *psd_info,\n  const MagickBooleanType skip_layers,ExceptionInfo *exception)\n{\n  char\n    type[4];\n\n  LayerInfo\n    *layer_info;\n\n  MagickSizeType\n    size;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count,\n    j,\n    number_layers;\n\n  size=GetPSDSize(psd_info,image);\n  if (size == 0)\n    {\n      /*\n        Skip layers & masks.\n      */\n      (void) ReadBlobLong(image);\n      count=ReadBlob(image,4,(unsigned char *) type);\n      ReversePSDString(image,type,4);\n      status=MagickFalse;\n      if ((count == 0) || (LocaleNCompare(type,\"8BIM\",4) != 0))\n        return(MagickTrue);\n      else\n        {\n          count=ReadBlob(image,4,(unsigned char *) type);\n          ReversePSDString(image,type,4);\n          if ((count != 0) && (LocaleNCompare(type,\"Lr16\",4) == 0))\n            size=GetPSDSize(psd_info,image);\n          else\n            return(MagickTrue);\n        }\n    }\n  status=MagickTrue;\n  if (size != 0)\n    {\n      layer_info=(LayerInfo *) NULL;\n      number_layers=(short) ReadBlobShort(image);\n\n      if (number_layers < 0)\n        {\n          /*\n            The first alpha channel in the merged result contains the\n            transparency data for the merged result.\n          */\n          number_layers=MagickAbsoluteValue(number_layers);\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  negative layer count corrected for\");\n          image->matte=MagickTrue;\n        }\n\n      /*\n        We only need to know if the image has an alpha channel\n      */\n      if (skip_layers != MagickFalse)\n        return(MagickTrue);\n\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  image contains %.20g layers\",(double) number_layers);\n\n      if (number_layers == 0)\n        ThrowBinaryException(CorruptImageError,\"InvalidNumberOfLayers\",\n          image->filename);\n\n      layer_info=(LayerInfo *) AcquireQuantumMemory((size_t) number_layers,\n        sizeof(*layer_info));\n      if (layer_info == (LayerInfo *) NULL)\n        {\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  allocation of LayerInfo failed\");\n          ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n            image->filename);\n        }\n      (void) ResetMagickMemory(layer_info,0,(size_t) number_layers*\n        sizeof(*layer_info));\n\n      for (i=0; i < number_layers; i++)\n      {\n        ssize_t\n          x,\n          y;\n\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  reading layer #%.20g\",(double) i+1);\n        layer_info[i].page.y=ReadBlobSignedLong(image);\n        layer_info[i].page.x=ReadBlobSignedLong(image);\n        y=ReadBlobSignedLong(image);\n        x=ReadBlobSignedLong(image);\n        layer_info[i].page.width=(size_t) (x-layer_info[i].page.x);\n        layer_info[i].page.height=(size_t) (y-layer_info[i].page.y);\n        layer_info[i].channels=ReadBlobShort(image);\n        if (layer_info[i].channels > MaxPSDChannels)\n          {\n            layer_info=DestroyLayerInfo(layer_info,number_layers);\n            ThrowBinaryException(CorruptImageError,\"MaximumChannelsExceeded\",\n              image->filename);\n          }\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    offset(%.20g,%.20g), size(%.20g,%.20g), channels=%.20g\",\n            (double) layer_info[i].page.x,(double) layer_info[i].page.y,\n            (double) layer_info[i].page.height,(double)\n            layer_info[i].page.width,(double) layer_info[i].channels);\n        for (j=0; j < (ssize_t) layer_info[i].channels; j++)\n        {\n          layer_info[i].channel_info[j].type=(short) ReadBlobShort(image);\n          layer_info[i].channel_info[j].size=(size_t) GetPSDSize(psd_info,\n            image);\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    channel[%.20g]: type=%.20g, size=%.20g\",(double) j,\n              (double) layer_info[i].channel_info[j].type,\n              (double) layer_info[i].channel_info[j].size);\n        }\n        count=ReadBlob(image,4,(unsigned char *) type);\n        ReversePSDString(image,type,4);\n        if ((count == 0) || (LocaleNCompare(type,\"8BIM\",4) != 0))\n          {\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  layer type was %.4s instead of 8BIM\", type);\n            layer_info=DestroyLayerInfo(layer_info,number_layers);\n            ThrowBinaryException(CorruptImageError,\"ImproperImageHeader\",\n              image->filename);\n          }\n        (void) ReadBlob(image,4,(unsigned char *) layer_info[i].blendkey);\n        ReversePSDString(image,layer_info[i].blendkey,4);\n        layer_info[i].opacity=(Quantum) ScaleCharToQuantum((unsigned char)\n          ReadBlobByte(image));\n        layer_info[i].clipping=(unsigned char) ReadBlobByte(image);\n        layer_info[i].flags=(unsigned char) ReadBlobByte(image);\n        layer_info[i].visible=!(layer_info[i].flags & 0x02);\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   blend=%.4s, opacity=%.20g, clipping=%s, flags=%d, visible=%s\",\n            layer_info[i].blendkey,(double) layer_info[i].opacity,\n            layer_info[i].clipping ? \"true\" : \"false\",layer_info[i].flags,\n            layer_info[i].visible ? \"true\" : \"false\");\n        (void) ReadBlobByte(image);  /* filler */\n\n        size=ReadBlobLong(image);\n        if (size != 0)\n          {\n            MagickSizeType\n              combined_length,\n              length;\n\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    layer contains additional info\");\n            length=ReadBlobLong(image);\n            combined_length=length+4;\n            if (length != 0)\n              {\n                /*\n                  Layer mask info.\n                */\n                layer_info[i].mask.page.y=ReadBlobSignedLong(image);\n                layer_info[i].mask.page.x=ReadBlobSignedLong(image);\n                layer_info[i].mask.page.height=(size_t) (ReadBlobLong(image)-\n                  layer_info[i].mask.page.y);\n                layer_info[i].mask.page.width=(size_t) (ReadBlobLong(image)-\n                  layer_info[i].mask.page.x);\n                layer_info[i].mask.background=(unsigned char) ReadBlobByte(\n                  image);\n                layer_info[i].mask.flags=(unsigned char) ReadBlobByte(image);\n                if (!(layer_info[i].mask.flags & 0x01))\n                  {\n                    layer_info[i].mask.page.y=layer_info[i].mask.page.y-\n                      layer_info[i].page.y;\n                    layer_info[i].mask.page.x=layer_info[i].mask.page.x-\n                      layer_info[i].page.x;\n                  }\n                if (image->debug != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"      layer mask: offset(%.20g,%.20g), size(%.20g,%.20g), length=%.20g\",\n                    (double) layer_info[i].mask.page.x,(double)\n                    layer_info[i].mask.page.y,(double) layer_info[i].mask.page.width,\n                    (double) layer_info[i].mask.page.height,(double)\n                    ((MagickOffsetType) length)-18);\n                /*\n                  Skip over the rest of the layer mask information.\n                */\n                if (DiscardBlobBytes(image,(MagickSizeType) (length-18)) == MagickFalse)\n                  {\n                    layer_info=DestroyLayerInfo(layer_info,number_layers);\n                    ThrowBinaryException(CorruptImageError,\"UnexpectedEndOfFile\",\n                      image->filename);\n                  }\n              }\n            length=ReadBlobLong(image);\n            combined_length+=length+4;\n            if (length != 0)\n              {\n                /*\n                  Layer blending ranges info.\n                */\n                if (image->debug != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"      layer blending ranges: length=%.20g\",(double)\n                    ((MagickOffsetType) length));\n                /*\n                  We read it, but don't use it...\n                */\n                for (j=0; j < (ssize_t) length; j+=8)\n                {\n                  size_t blend_source=ReadBlobLong(image);\n                  size_t blend_dest=ReadBlobLong(image);\n                  if (image->debug != MagickFalse)\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \"        source(%x), dest(%x)\",(unsigned int)\n                      blend_source,(unsigned int) blend_dest);\n                }\n              }\n             /*\n               Layer name.\n             */\n            length=(MagickSizeType) ReadBlobByte(image);\n             combined_length+=length+1;\n             if (length > 0)\n               (void) ReadBlob(image,(size_t) length++,layer_info[i].name);\n            layer_info[i].name[length]='\\0';\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"      layer name: %s\",layer_info[i].name);\n            if ((length % 4) != 0)\n              {\n                length=4-(length % 4);\n                combined_length+=length;\n                /* Skip over the padding of the layer name */\n                if (DiscardBlobBytes(image,length) == MagickFalse)\n                  {\n                    layer_info=DestroyLayerInfo(layer_info,number_layers);\n                    ThrowBinaryException(CorruptImageError,\n                      \"UnexpectedEndOfFile\",image->filename);\n                  }\n              }\n            length=(MagickSizeType) size-combined_length;\n            if (length > 0)\n              {\n                unsigned char\n                  *info;\n\n                layer_info[i].info=AcquireStringInfo((const size_t) length);\n                info=GetStringInfoDatum(layer_info[i].info);\n                (void) ReadBlob(image,(const size_t) length,info);\n              }\n          }\n      }\n\n      for (i=0; i < number_layers; i++)\n      {\n        if ((layer_info[i].page.width == 0) ||\n              (layer_info[i].page.height == 0))\n          {\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"      layer data is empty\");\n            if (layer_info[i].info != (StringInfo *) NULL)\n              layer_info[i].info=DestroyStringInfo(layer_info[i].info);\n            continue;\n          }\n\n        /*\n          Allocate layered image.\n        */\n        layer_info[i].image=CloneImage(image,layer_info[i].page.width,\n          layer_info[i].page.height,MagickFalse,exception);\n        if (layer_info[i].image == (Image *) NULL)\n          {\n            layer_info=DestroyLayerInfo(layer_info,number_layers);\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  allocation of image for layer %.20g failed\",(double) i);\n            ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n              image->filename);\n          }\n\n        if (layer_info[i].info != (StringInfo *) NULL)\n          {\n            (void) SetImageProfile(layer_info[i].image,\"psd:additional-info\",\n              layer_info[i].info);\n            layer_info[i].info=DestroyStringInfo(layer_info[i].info);\n          }\n      }\n\n      if (image_info->ping == MagickFalse)\n        {\n          for (i=0; i < number_layers; i++)\n          {\n            if (layer_info[i].image == (Image *) NULL)\n              {\n                for (j=0; j < layer_info[i].channels; j++)\n                {\n                  if (DiscardBlobBytes(image,(MagickSizeType)\n                      layer_info[i].channel_info[j].size) == MagickFalse)\n                    {\n                      layer_info=DestroyLayerInfo(layer_info,number_layers);\n                      ThrowBinaryException(CorruptImageError,\n                        \"UnexpectedEndOfFile\",image->filename);\n                    }\n                }\n                continue;\n              }\n\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  reading data for layer %.20g\",(double) i);\n            status=ReadPSDLayer(image,image_info,psd_info,&layer_info[i],\n              exception);\n            if (status == MagickFalse)\n              break;\n\n            status=SetImageProgress(image,LoadImagesTag,i,(MagickSizeType)\n              number_layers);\n            if (status == MagickFalse)\n              break;\n          }\n        }\n\n      if (status != MagickFalse)\n        {\n          for (i=0; i < number_layers; i++)\n          {\n            if (layer_info[i].image == (Image *) NULL)\n              {\n                for (j=i; j < number_layers - 1; j++)\n                  layer_info[j] = layer_info[j+1];\n                number_layers--;\n                i--;\n              }\n          }\n\n          if (number_layers > 0)\n            {\n              for (i=0; i < number_layers; i++)\n              {\n                if (i > 0)\n                  layer_info[i].image->previous=layer_info[i-1].image;\n                if (i < (number_layers-1))\n                  layer_info[i].image->next=layer_info[i+1].image;\n                layer_info[i].image->page=layer_info[i].page;\n              }\n              image->next=layer_info[0].image;\n              layer_info[0].image->previous=image;\n            }\n          layer_info=(LayerInfo *) RelinquishMagickMemory(layer_info);\n        }\n      else\n        layer_info=DestroyLayerInfo(layer_info,number_layers);\n    }\n\n  return(status);\n}\n", "target": 1, "idx": 183273}
{"func": "void blk_mq_enable_hotplug(void)\n{\n\tmutex_unlock(&all_q_mutex);\n}\n", "target": 0, "idx": 86691}
{"func": "  MenuDelegateImpl() : activated_command_id_(-1) {}\n", "target": 0, "idx": 113192}
{"func": " bool SynchronousCompositorImpl::IsExternalFlingActive() const {\n   DCHECK(CalledOnValidThread());\n   DCHECK(compositor_client_);\n   return compositor_client_->IsExternalFlingActive();\n }\n", "target": 1, "idx": 185590}
{"func": "asmlinkage long sys_adjtimex(struct timex __user *txc_p)\n{\n\tstruct timex txc;\t\t/* Local copy of parameter */\n\tint ret;\n\n\t/* Copy the user data space into the kernel copy\n\t * structure. But bear in mind that the structures\n\t * may change\n\t */\n\tif(copy_from_user(&txc, txc_p, sizeof(struct timex)))\n\t\treturn -EFAULT;\n\tret = do_adjtimex(&txc);\n\treturn copy_to_user(txc_p, &txc, sizeof(struct timex)) ? -EFAULT : ret;\n}\n", "target": 0, "idx": 24720}
{"func": "static void tcmu_glfs_close(struct tcmu_device *dev)\n{\n\tstruct glfs_state *gfsp = tcmu_get_dev_private(dev);\n\n\tglfs_close(gfsp->gfd);\n\tgluster_cache_refresh(gfsp->fs, tcmu_get_path(dev));\n\tgluster_free_server(&gfsp->hosts);\n\tfree(gfsp);\n}\n", "target": 0, "idx": 59068}
{"func": "BGD_DECLARE(gdImagePtr) gdImageCreateFromGd2PartCtx (gdIOCtx * in, int srcx, int srcy, int w, int h)\n{\n\t_noLibzError();\n\treturn NULL;\n}\n", "target": 0, "idx": 54450}
{"func": "static int32_t scsi_send_command(SCSIRequest *req, uint8_t *buf)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n    int32_t len;\n    uint8_t command;\n    uint8_t *outbuf;\n    int rc;\n\n    command = buf[0];\n    outbuf = (uint8_t *)r->iov.iov_base;\n    DPRINTF(\"Command: lun=%d tag=0x%x data=0x%02x\", req->lun, req->tag, buf[0]);\n\n#ifdef DEBUG_SCSI\n    {\n        int i;\n        for (i = 1; i < r->req.cmd.len; i++) {\n            printf(\" 0x%02x\", buf[i]);\n        }\n        printf(\"\\n\");\n    }\n#endif\n\n    switch (command) {\n    case TEST_UNIT_READY:\n    case INQUIRY:\n    case MODE_SENSE:\n    case MODE_SENSE_10:\n    case RESERVE:\n    case RESERVE_10:\n    case RELEASE:\n    case RELEASE_10:\n    case START_STOP:\n    case ALLOW_MEDIUM_REMOVAL:\n    case READ_CAPACITY_10:\n    case READ_TOC:\n    case GET_CONFIGURATION:\n    case SERVICE_ACTION_IN_16:\n    case VERIFY_10:\n        rc = scsi_disk_emulate_command(r, outbuf);\n        if (rc < 0) {\n            return 0;\n        }\n\n        r->iov.iov_len = rc;\n        break;\n    case SYNCHRONIZE_CACHE:\n        bdrv_acct_start(s->bs, &r->acct, 0, BDRV_ACCT_FLUSH);\n        r->req.aiocb = bdrv_aio_flush(s->bs, scsi_flush_complete, r);\n        if (r->req.aiocb == NULL) {\n            scsi_flush_complete(r, -EIO);\n        }\n        return 0;\n    case READ_6:\n    case READ_10:\n    case READ_12:\n    case READ_16:\n        len = r->req.cmd.xfer / s->qdev.blocksize;\n        DPRINTF(\"Read (sector %\" PRId64 \", count %d)\\n\", r->req.cmd.lba, len);\n        if (r->req.cmd.lba > s->max_lba)\n            goto illegal_lba;\n        r->sector = r->req.cmd.lba * s->cluster_size;\n        r->sector_count = len * s->cluster_size;\n        break;\n    case WRITE_6:\n    case WRITE_10:\n    case WRITE_12:\n    case WRITE_16:\n    case WRITE_VERIFY_10:\n    case WRITE_VERIFY_12:\n    case WRITE_VERIFY_16:\n        len = r->req.cmd.xfer / s->qdev.blocksize;\n        DPRINTF(\"Write %s(sector %\" PRId64 \", count %d)\\n\",\n                (command & 0xe) == 0xe ? \"And Verify \" : \"\",\n                r->req.cmd.lba, len);\n        if (r->req.cmd.lba > s->max_lba)\n            goto illegal_lba;\n        r->sector = r->req.cmd.lba * s->cluster_size;\n        r->sector_count = len * s->cluster_size;\n        break;\n    case MODE_SELECT:\n        DPRINTF(\"Mode Select(6) (len %lu)\\n\", (long)r->req.cmd.xfer);\n        /* We don't support mode parameter changes.\n           Allow the mode parameter header + block descriptors only. */\n        if (r->req.cmd.xfer > 12) {\n            goto fail;\n        }\n        break;\n    case MODE_SELECT_10:\n        DPRINTF(\"Mode Select(10) (len %lu)\\n\", (long)r->req.cmd.xfer);\n        /* We don't support mode parameter changes.\n           Allow the mode parameter header + block descriptors only. */\n        if (r->req.cmd.xfer > 16) {\n            goto fail;\n        }\n        break;\n    case SEEK_6:\n    case SEEK_10:\n        DPRINTF(\"Seek(%d) (sector %\" PRId64 \")\\n\", command == SEEK_6 ? 6 : 10,\n                r->req.cmd.lba);\n        if (r->req.cmd.lba > s->max_lba) {\n            goto illegal_lba;\n        }\n        break;\n    case WRITE_SAME_16:\n        len = r->req.cmd.xfer / s->qdev.blocksize;\n\n        DPRINTF(\"WRITE SAME(16) (sector %\" PRId64 \", count %d)\\n\",\n                r->req.cmd.lba, len);\n\n        if (r->req.cmd.lba > s->max_lba) {\n            goto illegal_lba;\n        }\n\n        /*\n         * We only support WRITE SAME with the unmap bit set for now.\n         */\n        if (!(buf[1] & 0x8)) {\n            goto fail;\n        }\n\n        rc = bdrv_discard(s->bs, r->req.cmd.lba * s->cluster_size,\n                          len * s->cluster_size);\n        if (rc < 0) {\n            /* XXX: better error code ?*/\n            goto fail;\n        }\n\n        break;\n    case REQUEST_SENSE:\n        abort();\n    default:\n        DPRINTF(\"Unknown SCSI command (%2.2x)\\n\", buf[0]);\n        scsi_check_condition(r, SENSE_CODE(INVALID_OPCODE));\n        return 0;\n    fail:\n        scsi_check_condition(r, SENSE_CODE(INVALID_FIELD));\n        return 0;\n    illegal_lba:\n        scsi_check_condition(r, SENSE_CODE(LBA_OUT_OF_RANGE));\n        return 0;\n    }\n    if (r->sector_count == 0 && r->iov.iov_len == 0) {\n        scsi_req_complete(&r->req, GOOD);\n    }\n    len = r->sector_count * 512 + r->iov.iov_len;\n    if (r->req.cmd.mode == SCSI_XFER_TO_DEV) {\n        return -len;\n    } else {\n        if (!r->sector_count)\n            r->sector_count = -1;\n        return len;\n    }\n}\n", "target": 0, "idx": 94570}
{"func": "static int qeth_handle_send_error(struct qeth_card *card,\n\t\tstruct qeth_qdio_out_buffer *buffer, unsigned int qdio_err)\n{\n\tint sbalf15 = buffer->buffer->element[15].sflags;\n\n\tQETH_CARD_TEXT(card, 6, \"hdsnderr\");\n\tif (card->info.type == QETH_CARD_TYPE_IQD) {\n\t\tif (sbalf15 == 0) {\n\t\t\tqdio_err = 0;\n\t\t} else {\n\t\t\tqdio_err = 1;\n\t\t}\n\t}\n\tqeth_check_qdio_errors(card, buffer->buffer, qdio_err, \"qouterr\");\n\n\tif (!qdio_err)\n\t\treturn QETH_SEND_ERROR_NONE;\n\n\tif ((sbalf15 >= 15) && (sbalf15 <= 31))\n\t\treturn QETH_SEND_ERROR_RETRY;\n\n\tQETH_CARD_TEXT(card, 1, \"lnkfail\");\n\tQETH_CARD_TEXT_(card, 1, \"%04x %02x\",\n\t\t       (u16)qdio_err, (u8)sbalf15);\n\treturn QETH_SEND_ERROR_LINK_FAILURE;\n}\n", "target": 0, "idx": 28573}
{"func": "static v8::Handle<v8::Value> convert3Callback(const v8::Arguments& args)\n {\n     INC_STATS(\"DOM.TestObj.convert3\");\n     if (args.Length() < 1)\n        return V8Proxy::throwNotEnoughArgumentsError();\n     TestObj* imp = V8TestObj::toNative(args.Holder());\n     EXCEPTION_BLOCK(c*, , V8c::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8c::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);\n     imp->convert3();\n    return v8::Handle<v8::Value>();\n}\n", "target": 1, "idx": 184771}
{"func": "bool Compositor::ScrollLayerTo(cc::ElementId element_id,\n                               const gfx::ScrollOffset& offset) {\n  auto input_handler = host_->GetInputHandler();\n  return input_handler && input_handler->ScrollLayerTo(element_id, offset);\n}\n", "target": 0, "idx": 153174}
{"func": "static bool CompareJsonValues(const std::string& lhs,\n                              const std::string& rhs,\n                              CompareOp op) {\n  switch (op) {\n    case IS_EQUAL:\n      return lhs == rhs;\n    case IS_NOT_EQUAL:\n      return lhs != rhs;\n    default:\n      CHECK(0);\n  }\n  return false;\n}\n", "target": 0, "idx": 129844}
{"func": "R_API int r_bin_file_set_cur_by_name(RBin *bin, const char *name) {\n\tRBinFile *bf = r_bin_file_find_by_name (bin, name);\n\treturn r_bin_file_set_cur_binfile (bin, bf);\n}\n", "target": 0, "idx": 60142}
{"func": "static int sctp_init_sock(struct sock *sk)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct sctp_sock *sp;\n\n\tpr_debug(\"%s: sk:%p\\n\", __func__, sk);\n\n\tsp = sctp_sk(sk);\n\n\t/* Initialize the SCTP per socket area.  */\n\tswitch (sk->sk_type) {\n\tcase SOCK_SEQPACKET:\n\t\tsp->type = SCTP_SOCKET_UDP;\n\t\tbreak;\n\tcase SOCK_STREAM:\n\t\tsp->type = SCTP_SOCKET_TCP;\n\t\tbreak;\n\tdefault:\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\n\t/* Initialize default send parameters. These parameters can be\n\t * modified with the SCTP_DEFAULT_SEND_PARAM socket option.\n\t */\n\tsp->default_stream = 0;\n\tsp->default_ppid = 0;\n\tsp->default_flags = 0;\n\tsp->default_context = 0;\n\tsp->default_timetolive = 0;\n\n\tsp->default_rcv_context = 0;\n\tsp->max_burst = net->sctp.max_burst;\n\n\tsp->sctp_hmac_alg = net->sctp.sctp_hmac_alg;\n\n\t/* Initialize default setup parameters. These parameters\n\t * can be modified with the SCTP_INITMSG socket option or\n\t * overridden by the SCTP_INIT CMSG.\n\t */\n\tsp->initmsg.sinit_num_ostreams   = sctp_max_outstreams;\n\tsp->initmsg.sinit_max_instreams  = sctp_max_instreams;\n\tsp->initmsg.sinit_max_attempts   = net->sctp.max_retrans_init;\n\tsp->initmsg.sinit_max_init_timeo = net->sctp.rto_max;\n\n\t/* Initialize default RTO related parameters.  These parameters can\n\t * be modified for with the SCTP_RTOINFO socket option.\n\t */\n\tsp->rtoinfo.srto_initial = net->sctp.rto_initial;\n\tsp->rtoinfo.srto_max     = net->sctp.rto_max;\n\tsp->rtoinfo.srto_min     = net->sctp.rto_min;\n\n\t/* Initialize default association related parameters. These parameters\n\t * can be modified with the SCTP_ASSOCINFO socket option.\n\t */\n\tsp->assocparams.sasoc_asocmaxrxt = net->sctp.max_retrans_association;\n\tsp->assocparams.sasoc_number_peer_destinations = 0;\n\tsp->assocparams.sasoc_peer_rwnd = 0;\n\tsp->assocparams.sasoc_local_rwnd = 0;\n\tsp->assocparams.sasoc_cookie_life = net->sctp.valid_cookie_life;\n\n\t/* Initialize default event subscriptions. By default, all the\n\t * options are off.\n\t */\n\tmemset(&sp->subscribe, 0, sizeof(struct sctp_event_subscribe));\n\n\t/* Default Peer Address Parameters.  These defaults can\n\t * be modified via SCTP_PEER_ADDR_PARAMS\n\t */\n\tsp->hbinterval  = net->sctp.hb_interval;\n\tsp->pathmaxrxt  = net->sctp.max_retrans_path;\n\tsp->pathmtu     = 0; /* allow default discovery */\n\tsp->sackdelay   = net->sctp.sack_timeout;\n\tsp->sackfreq\t= 2;\n\tsp->param_flags = SPP_HB_ENABLE |\n\t\t\t  SPP_PMTUD_ENABLE |\n\t\t\t  SPP_SACKDELAY_ENABLE;\n\n\t/* If enabled no SCTP message fragmentation will be performed.\n\t * Configure through SCTP_DISABLE_FRAGMENTS socket option.\n\t */\n\tsp->disable_fragments = 0;\n\n\t/* Enable Nagle algorithm by default.  */\n\tsp->nodelay           = 0;\n\n\tsp->recvrcvinfo = 0;\n\tsp->recvnxtinfo = 0;\n\n\t/* Enable by default. */\n\tsp->v4mapped          = 1;\n\n\t/* Auto-close idle associations after the configured\n\t * number of seconds.  A value of 0 disables this\n\t * feature.  Configure through the SCTP_AUTOCLOSE socket option,\n\t * for UDP-style sockets only.\n\t */\n\tsp->autoclose         = 0;\n\n\t/* User specified fragmentation limit. */\n\tsp->user_frag         = 0;\n\n\tsp->adaptation_ind = 0;\n\n\tsp->pf = sctp_get_pf_specific(sk->sk_family);\n\n\t/* Control variables for partial data delivery. */\n\tatomic_set(&sp->pd_mode, 0);\n\tskb_queue_head_init(&sp->pd_lobby);\n\tsp->frag_interleave = 0;\n\n\t/* Create a per socket endpoint structure.  Even if we\n\t * change the data structure relationships, this may still\n\t * be useful for storing pre-connect address information.\n\t */\n\tsp->ep = sctp_endpoint_new(sk, GFP_KERNEL);\n\tif (!sp->ep)\n\t\treturn -ENOMEM;\n\n\tsp->hmac = NULL;\n\n\tsk->sk_destruct = sctp_destruct_sock;\n\n\tSCTP_DBG_OBJCNT_INC(sock);\n\n \tlocal_bh_disable();\n \tpercpu_counter_inc(&sctp_sockets_allocated);\n \tsock_prot_inuse_add(net, sk->sk_prot, 1);\n \tif (net->sctp.default_auto_asconf) {\n \t\tlist_add_tail(&sp->auto_asconf_list,\n \t\t    &net->sctp.auto_asconf_splist);\n \t\tsp->do_auto_asconf = 1;\n\t} else\n \t\tsp->do_auto_asconf = 0;\n \tlocal_bh_enable();\n \n \treturn 0;\n }\n", "target": 1, "idx": 179801}
{"func": "struct rpc_clnt *rpc_create(struct rpc_create_args *args)\n{\n\tstruct rpc_xprt *xprt;\n\tstruct rpc_clnt *clnt;\n\tstruct xprt_create xprtargs = {\n\t\t.net = args->net,\n\t\t.ident = args->protocol,\n\t\t.srcaddr = args->saddress,\n\t\t.dstaddr = args->address,\n\t\t.addrlen = args->addrsize,\n\t\t.bc_xprt = args->bc_xprt,\n\t};\n\tchar servername[48];\n\n\t/*\n\t * If the caller chooses not to specify a hostname, whip\n\t * up a string representation of the passed-in address.\n\t */\n\tif (args->servername == NULL) {\n\t\tstruct sockaddr_un *sun =\n\t\t\t\t(struct sockaddr_un *)args->address;\n\t\tstruct sockaddr_in *sin =\n\t\t\t\t(struct sockaddr_in *)args->address;\n\t\tstruct sockaddr_in6 *sin6 =\n\t\t\t\t(struct sockaddr_in6 *)args->address;\n\n\t\tservername[0] = '\\0';\n\t\tswitch (args->address->sa_family) {\n\t\tcase AF_LOCAL:\n\t\t\tsnprintf(servername, sizeof(servername), \"%s\",\n\t\t\t\t sun->sun_path);\n\t\t\tbreak;\n\t\tcase AF_INET:\n\t\t\tsnprintf(servername, sizeof(servername), \"%pI4\",\n\t\t\t\t &sin->sin_addr.s_addr);\n\t\t\tbreak;\n\t\tcase AF_INET6:\n\t\t\tsnprintf(servername, sizeof(servername), \"%pI6\",\n\t\t\t\t &sin6->sin6_addr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* caller wants default server name, but\n\t\t\t * address family isn't recognized. */\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\targs->servername = servername;\n\t}\n\n\txprt = xprt_create_transport(&xprtargs);\n\tif (IS_ERR(xprt))\n\t\treturn (struct rpc_clnt *)xprt;\n\n\t/*\n\t * By default, kernel RPC client connects from a reserved port.\n\t * CAP_NET_BIND_SERVICE will not be set for unprivileged requesters,\n\t * but it is always enabled for rpciod, which handles the connect\n\t * operation.\n\t */\n\txprt->resvport = 1;\n\tif (args->flags & RPC_CLNT_CREATE_NONPRIVPORT)\n\t\txprt->resvport = 0;\n\n\tclnt = rpc_new_client(args, xprt);\n\tif (IS_ERR(clnt))\n\t\treturn clnt;\n\n\tif (!(args->flags & RPC_CLNT_CREATE_NOPING)) {\n\t\tint err = rpc_ping(clnt);\n\t\tif (err != 0) {\n\t\t\trpc_shutdown_client(clnt);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\t}\n\n\tclnt->cl_softrtry = 1;\n\tif (args->flags & RPC_CLNT_CREATE_HARDRTRY)\n\t\tclnt->cl_softrtry = 0;\n\n\tif (args->flags & RPC_CLNT_CREATE_AUTOBIND)\n\t\tclnt->cl_autobind = 1;\n\tif (args->flags & RPC_CLNT_CREATE_DISCRTRY)\n\t\tclnt->cl_discrtry = 1;\n\tif (!(args->flags & RPC_CLNT_CREATE_QUIET))\n\t\tclnt->cl_chatty = 1;\n\n\treturn clnt;\n}\n", "target": 0, "idx": 34899}
{"func": "static void load_xref_from_plaintext(FILE *fp, xref_t *xref)\n{\n    int  i, buf_idx, obj_id, added_entries;\n    char c, buf[32] = {0};\n    long start, pos;\n\n    start = ftell(fp);\n\n    /* Get number of entries */\n    pos = xref->end;\n    fseek(fp, pos, SEEK_SET);\n    while (ftell(fp) != 0)\n      if (SAFE_F(fp, (fgetc(fp) == '/' && fgetc(fp) == 'S')))\n        break;\n      else\n        SAFE_E(fseek(fp, --pos, SEEK_SET), 0, \"Failed seek to xref /Size.\\n\");\n \n     SAFE_E(fread(buf, 1, 21, fp), 21, \"Failed to load entry Size string.\\n\");\n     xref->n_entries = atoi(buf + strlen(\"ize \"));\n    xref->entries = calloc(1, xref->n_entries * sizeof(struct _xref_entry));\n \n     /* Load entry data */\n     obj_id = 0;\n    fseek(fp, xref->start + strlen(\"xref\"), SEEK_SET);\n    added_entries = 0;\n    for (i=0; i<xref->n_entries; i++)\n    {\n        /* Advance past newlines. */\n        c = fgetc(fp);\n        while (c == '\\n' || c == '\\r')\n          c = fgetc(fp);\n\n        /* Collect data up until the following newline. */\n        buf_idx = 0;\n        while (c != '\\n' && c != '\\r' && !feof(fp) &&\n               !ferror(fp) && buf_idx < sizeof(buf))\n        {\n            buf[buf_idx++] = c;\n            c = fgetc(fp);\n        }\n        if (buf_idx >= sizeof(buf))\n        {\n            ERR(\"Failed to locate newline character. \"\n                \"This might be a corrupt PDF.\\n\");\n            exit(EXIT_FAILURE);\n        }\n        buf[buf_idx] = '\\0';\n\n        /* Went to far and hit start of trailer */\n        if (strchr(buf, 't'))\n          break;\n\n        /* Entry or object id */\n        if (strlen(buf) > 17)\n        {\n            xref->entries[i].obj_id = obj_id++;\n            xref->entries[i].offset = atol(strtok(buf, \" \"));\n            xref->entries[i].gen_num = atoi(strtok(NULL, \" \"));\n            xref->entries[i].f_or_n = buf[17];\n            ++added_entries;\n        }\n        else\n        {\n            obj_id = atoi(buf);\n            --i;\n        }\n    }\n\n    xref->n_entries = added_entries;\n    fseek(fp, start, SEEK_SET);\n}\n", "target": 1, "idx": 182741}
{"func": "SharedMemoryHandleProvider::GetHandleForInterProcessTransit(bool read_only) {\n  if (read_only_flag_ && !read_only) {\n     NOTREACHED();\n     return mojo::ScopedSharedBufferHandle();\n   }\n   return mojo::WrapSharedMemoryHandle(\n       base::SharedMemory::DuplicateHandle(shared_memory_->handle()),\n      mapped_size_, read_only);\n }\n", "target": 1, "idx": 186846}
{"func": "xfs_attr3_leaf_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_attr_leafblock *leaf = bp->b_addr;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_da3_node_hdr *hdr3 = bp->b_addr;\n\n\t\tif (ichdr.magic != XFS_ATTR3_LEAF_MAGIC)\n\t\t\treturn false;\n\n\t\tif (!uuid_equal(&hdr3->info.uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (be64_to_cpu(hdr3->info.blkno) != bp->b_bn)\n\t\t\treturn false;\n\t} else {\n\t\tif (ichdr.magic != XFS_ATTR_LEAF_MAGIC)\n\t\t\treturn false;\n\t}\n\tif (ichdr.count == 0)\n\t\treturn false;\n\n\t/* XXX: need to range check rest of attr header values */\n\t/* XXX: hash order check? */\n\n\treturn true;\n}\n", "target": 0, "idx": 44944}
{"func": "int ext4_get_block_dax(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create)\n{\n\tint flags = EXT4_GET_BLOCKS_PRE_IO | EXT4_GET_BLOCKS_UNWRIT_EXT;\n\tif (create)\n\t\tflags |= EXT4_GET_BLOCKS_CREATE;\n\text4_debug(\"ext4_get_block_dax: inode %lu, create flag %d\\n\",\n\t\t   inode->i_ino, create);\n\treturn _ext4_get_block(inode, iblock, bh_result, flags);\n}\n", "target": 0, "idx": 56569}
{"func": "void GraphicsContext::addInnerRoundedRectClip(const IntRect& rect, int thickness)\n {\n    notImplemented();\n }\n", "target": 1, "idx": 183877}
{"func": " void LocalFileSystem::resolveURL(ExecutionContext* context, const KURL& fileSystemURL, PassOwnPtr<AsyncFileSystemCallbacks> callbacks)\n {\n     RefPtrWillBeRawPtr<ExecutionContext> contextPtr(context);\n    RefPtr<CallbackWrapper> wrapper = adoptRef(new CallbackWrapper(callbacks));\n     requestFileSystemAccessInternal(context,\n         bind(&LocalFileSystem::resolveURLInternal, this, contextPtr, fileSystemURL, wrapper),\n         bind(&LocalFileSystem::fileSystemNotAllowedInternal, this, contextPtr, wrapper));\n}\n", "target": 1, "idx": 185128}
{"func": " void WebPluginDelegateImpl::DidFinishLoadWithReason(const GURL& url,\n                                                     NPReason reason,\n                                                    intptr_t notify_data) {\n   if (quirks_ & PLUGIN_QUIRK_ALWAYS_NOTIFY_SUCCESS &&\n       reason == NPRES_NETWORK_ERR) {\n     reason = NPRES_DONE;\n   }\n \n  instance()->DidFinishLoadWithReason(\n      url, reason, reinterpret_cast<void*>(notify_data));\n }\n", "target": 1, "idx": 183594}
{"func": "int udhcpd_main(int argc UNUSED_PARAM, char **argv)\n{\n\tint server_socket = -1, retval;\n\tuint8_t *state;\n\tunsigned timeout_end;\n\tunsigned num_ips;\n\tunsigned opt;\n\tstruct option_set *option;\n\tchar *str_I = str_I;\n\tconst char *str_a = \"2000\";\n\tunsigned arpping_ms;\n\tIF_FEATURE_UDHCP_PORT(char *str_P;)\n\n\tsetup_common_bufsiz();\n\n\tIF_FEATURE_UDHCP_PORT(SERVER_PORT = 67;)\n\tIF_FEATURE_UDHCP_PORT(CLIENT_PORT = 68;)\n\n\topt = getopt32(argv, \"^\"\n\t\t\"fSI:va:\"IF_FEATURE_UDHCP_PORT(\"P:\")\n\t\t\"\\0\"\n#if defined CONFIG_UDHCP_DEBUG && CONFIG_UDHCP_DEBUG >= 1\n\t\t\"vv\"\n#endif\n\t\t, &str_I\n\t\t, &str_a\n\t\tIF_FEATURE_UDHCP_PORT(, &str_P)\n\t\tIF_UDHCP_VERBOSE(, &dhcp_verbose)\n\t\t);\n\tif (!(opt & 1)) { /* no -f */\n\t\tbb_daemonize_or_rexec(0, argv);\n\t\tlogmode = LOGMODE_NONE;\n\t}\n\t/* update argv after the possible vfork+exec in daemonize */\n\targv += optind;\n\tif (opt & 2) { /* -S */\n\t\topenlog(applet_name, LOG_PID, LOG_DAEMON);\n\t\tlogmode |= LOGMODE_SYSLOG;\n\t}\n\tif (opt & 4) { /* -I */\n\t\tlen_and_sockaddr *lsa = xhost_and_af2sockaddr(str_I, 0, AF_INET);\n\t\tserver_config.server_nip = lsa->u.sin.sin_addr.s_addr;\n\t\tfree(lsa);\n\t}\n#if ENABLE_FEATURE_UDHCP_PORT\n\tif (opt & 32) { /* -P */\n\t\tSERVER_PORT = xatou16(str_P);\n\t\tCLIENT_PORT = SERVER_PORT + 1;\n\t}\n#endif\n\tarpping_ms = xatou(str_a);\n\n\t/* Would rather not do read_config before daemonization -\n\t * otherwise NOMMU machines will parse config twice */\n\tread_config(argv[0] ? argv[0] : DHCPD_CONF_FILE);\n\t/* prevent poll timeout overflow */\n\tif (server_config.auto_time > INT_MAX / 1000)\n\t\tserver_config.auto_time = INT_MAX / 1000;\n\n\t/* Make sure fd 0,1,2 are open */\n\tbb_sanitize_stdio();\n\n\t/* Create pidfile */\n\twrite_pidfile(server_config.pidfile);\n\t/* if (!..) bb_perror_msg(\"can't create pidfile %s\", pidfile); */\n\n\tbb_error_msg(\"started, v\"BB_VER);\n\n\toption = udhcp_find_option(server_config.options, DHCP_LEASE_TIME);\n\tserver_config.max_lease_sec = DEFAULT_LEASE_TIME;\n\tif (option) {\n\t\tmove_from_unaligned32(server_config.max_lease_sec, option->data + OPT_DATA);\n\t\tserver_config.max_lease_sec = ntohl(server_config.max_lease_sec);\n\t}\n\n\t/* Sanity check */\n\tnum_ips = server_config.end_ip - server_config.start_ip + 1;\n\tif (server_config.max_leases > num_ips) {\n\t\tbb_error_msg(\"max_leases=%u is too big, setting to %u\",\n\t\t\t(unsigned)server_config.max_leases, num_ips);\n\t\tserver_config.max_leases = num_ips;\n\t}\n\n\t/* this sets g_leases */\n\tSET_PTR_TO_GLOBALS(xzalloc(server_config.max_leases * sizeof(g_leases[0])));\n\n\tread_leases(server_config.lease_file);\n\n\tif (udhcp_read_interface(server_config.interface,\n\t\t\t&server_config.ifindex,\n\t\t\t(server_config.server_nip == 0 ? &server_config.server_nip : NULL),\n\t\t\tserver_config.server_mac)\n\t) {\n\t\tretval = 1;\n\t\tgoto ret;\n\t}\n\n\t/* Setup the signal pipe */\n\tudhcp_sp_setup();\n\n continue_with_autotime:\n\ttimeout_end = monotonic_sec() + server_config.auto_time;\n\twhile (1) { /* loop until universe collapses */\n\t\tstruct pollfd pfds[2];\n\t\tstruct dhcp_packet packet;\n\t\tint bytes;\n\t\tint tv;\n\t\tuint8_t *server_id_opt;\n\t\tuint8_t *requested_ip_opt;\n\t\tuint32_t requested_nip = requested_nip; /* for compiler */\n\t\tuint32_t static_lease_nip;\n\t\tstruct dyn_lease *lease, fake_lease;\n\n\t\tif (server_socket < 0) {\n\t\t\tserver_socket = udhcp_listen_socket(/*INADDR_ANY,*/ SERVER_PORT,\n\t\t\t\t\tserver_config.interface);\n\t\t}\n\n\t\tudhcp_sp_fd_set(pfds, server_socket);\n\n new_tv:\n\t\ttv = -1;\n\t\tif (server_config.auto_time) {\n\t\t\ttv = timeout_end - monotonic_sec();\n\t\t\tif (tv <= 0) {\n write_leases:\n\t\t\t\twrite_leases();\n\t\t\t\tgoto continue_with_autotime;\n\t\t\t}\n\t\t\ttv *= 1000;\n\t\t}\n\n\t\t/* Block here waiting for either signal or packet */\n\t\tretval = poll(pfds, 2, tv);\n\t\tif (retval <= 0) {\n\t\t\tif (retval == 0)\n\t\t\t\tgoto write_leases;\n\t\t\tif (errno == EINTR)\n\t\t\t\tgoto new_tv;\n\t\t\t/* < 0 and not EINTR: should not happen */\n\t\t\tbb_perror_msg_and_die(\"poll\");\n\t\t}\n\n\t\tif (pfds[0].revents) switch (udhcp_sp_read()) {\n\t\tcase SIGUSR1:\n\t\t\tbb_error_msg(\"received %s\", \"SIGUSR1\");\n\t\t\twrite_leases();\n\t\t\t/* why not just reset the timeout, eh */\n\t\t\tgoto continue_with_autotime;\n\t\tcase SIGTERM:\n\t\t\tbb_error_msg(\"received %s\", \"SIGTERM\");\n\t\t\twrite_leases();\n\t\t\tgoto ret0;\n\t\t}\n\n\t\t/* Is it a packet? */\n\t\tif (!pfds[1].revents)\n\t\t\tcontinue; /* no */\n\n\t\t/* Note: we do not block here, we block on poll() instead.\n\t\t * Blocking here would prevent SIGTERM from working:\n\t\t * socket read inside this call is restarted on caught signals.\n\t\t */\n\t\tbytes = udhcp_recv_kernel_packet(&packet, server_socket);\n\t\tif (bytes < 0) {\n\t\t\t/* bytes can also be -2 (\"bad packet data\") */\n\t\t\tif (bytes == -1 && errno != EINTR) {\n\t\t\t\tlog1(\"read error: \"STRERROR_FMT\", reopening socket\" STRERROR_ERRNO);\n\t\t\t\tclose(server_socket);\n\t\t\t\tserver_socket = -1;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (packet.hlen != 6) {\n\t\t\tbb_error_msg(\"MAC length != 6, ignoring packet\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (packet.op != BOOTREQUEST) {\n\t\t\tbb_error_msg(\"not a REQUEST, ignoring packet\");\n\t\t\tcontinue;\n\t\t}\n\t\tstate = udhcp_get_option(&packet, DHCP_MESSAGE_TYPE);\n\t\tif (state == NULL || state[0] < DHCP_MINTYPE || state[0] > DHCP_MAXTYPE) {\n\t\t\tbb_error_msg(\"no or bad message type option, ignoring packet\");\n\t\t\tcontinue;\n \t\t}\n \n \t\t/* Get SERVER_ID if present */\n\t\tserver_id_opt = udhcp_get_option(&packet, DHCP_SERVER_ID);\n \t\tif (server_id_opt) {\n \t\t\tuint32_t server_id_network_order;\n \t\t\tmove_from_unaligned32(server_id_network_order, server_id_opt);\n\t\t\tif (server_id_network_order != server_config.server_nip) {\n\t\t\t\t/* client talks to somebody else */\n\t\t\t\tlog1(\"server ID doesn't match, ignoring\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* Look for a static/dynamic lease */\n\t\tstatic_lease_nip = get_static_nip_by_mac(server_config.static_leases, &packet.chaddr);\n\t\tif (static_lease_nip) {\n\t\t\tbb_error_msg(\"found static lease: %x\", static_lease_nip);\n\t\t\tmemcpy(&fake_lease.lease_mac, &packet.chaddr, 6);\n\t\t\tfake_lease.lease_nip = static_lease_nip;\n\t\t\tfake_lease.expires = 0;\n\t\t\tlease = &fake_lease;\n\t\t} else {\n\t\t\tlease = find_lease_by_mac(packet.chaddr);\n \t\t}\n \n \t\t/* Get REQUESTED_IP if present */\n\t\trequested_ip_opt = udhcp_get_option(&packet, DHCP_REQUESTED_IP);\n \t\tif (requested_ip_opt) {\n \t\t\tmove_from_unaligned32(requested_nip, requested_ip_opt);\n \t\t}\n\n\t\tswitch (state[0]) {\n\n\t\tcase DHCPDISCOVER:\n\t\t\tlog1(\"received %s\", \"DISCOVER\");\n\n\t\t\tsend_offer(&packet, static_lease_nip, lease, requested_ip_opt, arpping_ms);\n\t\t\tbreak;\n\n\t\tcase DHCPREQUEST:\n\t\t\tlog1(\"received %s\", \"REQUEST\");\n/* RFC 2131:\n\no DHCPREQUEST generated during SELECTING state:\n\n   Client inserts the address of the selected server in 'server\n   identifier', 'ciaddr' MUST be zero, 'requested IP address' MUST be\n   filled in with the yiaddr value from the chosen DHCPOFFER.\n\n   Note that the client may choose to collect several DHCPOFFER\n   messages and select the \"best\" offer.  The client indicates its\n   selection by identifying the offering server in the DHCPREQUEST\n   message.  If the client receives no acceptable offers, the client\n   may choose to try another DHCPDISCOVER message.  Therefore, the\n   servers may not receive a specific DHCPREQUEST from which they can\n   decide whether or not the client has accepted the offer.\n\no DHCPREQUEST generated during INIT-REBOOT state:\n\n   'server identifier' MUST NOT be filled in, 'requested IP address'\n   option MUST be filled in with client's notion of its previously\n   assigned address. 'ciaddr' MUST be zero. The client is seeking to\n   verify a previously allocated, cached configuration. Server SHOULD\n   send a DHCPNAK message to the client if the 'requested IP address'\n   is incorrect, or is on the wrong network.\n\n   Determining whether a client in the INIT-REBOOT state is on the\n   correct network is done by examining the contents of 'giaddr', the\n   'requested IP address' option, and a database lookup. If the DHCP\n   server detects that the client is on the wrong net (i.e., the\n   result of applying the local subnet mask or remote subnet mask (if\n   'giaddr' is not zero) to 'requested IP address' option value\n   doesn't match reality), then the server SHOULD send a DHCPNAK\n   message to the client.\n\n   If the network is correct, then the DHCP server should check if\n   the client's notion of its IP address is correct. If not, then the\n   server SHOULD send a DHCPNAK message to the client. If the DHCP\n   server has no record of this client, then it MUST remain silent,\n   and MAY output a warning to the network administrator. This\n   behavior is necessary for peaceful coexistence of non-\n   communicating DHCP servers on the same wire.\n\n   If 'giaddr' is 0x0 in the DHCPREQUEST message, the client is on\n   the same subnet as the server.  The server MUST broadcast the\n   DHCPNAK message to the 0xffffffff broadcast address because the\n   client may not have a correct network address or subnet mask, and\n   the client may not be answering ARP requests.\n\n   If 'giaddr' is set in the DHCPREQUEST message, the client is on a\n   different subnet.  The server MUST set the broadcast bit in the\n   DHCPNAK, so that the relay agent will broadcast the DHCPNAK to the\n   client, because the client may not have a correct network address\n   or subnet mask, and the client may not be answering ARP requests.\n\no DHCPREQUEST generated during RENEWING state:\n\n   'server identifier' MUST NOT be filled in, 'requested IP address'\n   option MUST NOT be filled in, 'ciaddr' MUST be filled in with\n   client's IP address. In this situation, the client is completely\n   configured, and is trying to extend its lease. This message will\n   be unicast, so no relay agents will be involved in its\n   transmission.  Because 'giaddr' is therefore not filled in, the\n   DHCP server will trust the value in 'ciaddr', and use it when\n   replying to the client.\n\n   A client MAY choose to renew or extend its lease prior to T1.  The\n   server may choose not to extend the lease (as a policy decision by\n   the network administrator), but should return a DHCPACK message\n   regardless.\n\no DHCPREQUEST generated during REBINDING state:\n\n   'server identifier' MUST NOT be filled in, 'requested IP address'\n   option MUST NOT be filled in, 'ciaddr' MUST be filled in with\n   client's IP address. In this situation, the client is completely\n   configured, and is trying to extend its lease. This message MUST\n   be broadcast to the 0xffffffff IP broadcast address.  The DHCP\n   server SHOULD check 'ciaddr' for correctness before replying to\n   the DHCPREQUEST.\n\n   The DHCPREQUEST from a REBINDING client is intended to accommodate\n   sites that have multiple DHCP servers and a mechanism for\n   maintaining consistency among leases managed by multiple servers.\n   A DHCP server MAY extend a client's lease only if it has local\n   administrative authority to do so.\n*/\n\t\t\tif (!requested_ip_opt) {\n\t\t\t\trequested_nip = packet.ciaddr;\n\t\t\t\tif (requested_nip == 0) {\n\t\t\t\t\tlog1(\"no requested IP and no ciaddr, ignoring\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lease && requested_nip == lease->lease_nip) {\n\t\t\t\t/* client requested or configured IP matches the lease.\n\t\t\t\t * ACK it, and bump lease expiration time. */\n\t\t\t\tsend_ACK(&packet, lease->lease_nip);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* No lease for this MAC, or lease IP != requested IP */\n\n\t\t\tif (server_id_opt    /* client is in SELECTING state */\n\t\t\t || requested_ip_opt /* client is in INIT-REBOOT state */\n\t\t\t) {\n\t\t\t\t/* \"No, we don't have this IP for you\" */\n\t\t\t\tsend_NAK(&packet);\n\t\t\t} /* else: client is in RENEWING or REBINDING, do not answer */\n\n\t\t\tbreak;\n\n\t\tcase DHCPDECLINE:\n\t\t\t/* RFC 2131:\n\t\t\t * \"If the server receives a DHCPDECLINE message,\n\t\t\t * the client has discovered through some other means\n\t\t\t * that the suggested network address is already\n\t\t\t * in use. The server MUST mark the network address\n\t\t\t * as not available and SHOULD notify the local\n\t\t\t * sysadmin of a possible configuration problem.\"\n\t\t\t *\n\t\t\t * SERVER_ID must be present,\n\t\t\t * REQUESTED_IP must be present,\n\t\t\t * chaddr must be filled in,\n\t\t\t * ciaddr must be 0 (we do not check this)\n\t\t\t */\n\t\t\tlog1(\"received %s\", \"DECLINE\");\n\t\t\tif (server_id_opt\n\t\t\t && requested_ip_opt\n\t\t\t && lease  /* chaddr matches this lease */\n\t\t\t && requested_nip == lease->lease_nip\n\t\t\t) {\n\t\t\t\tmemset(lease->lease_mac, 0, sizeof(lease->lease_mac));\n\t\t\t\tlease->expires = time(NULL) + server_config.decline_time;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase DHCPRELEASE:\n\t\t\t/* \"Upon receipt of a DHCPRELEASE message, the server\n\t\t\t * marks the network address as not allocated.\"\n\t\t\t *\n\t\t\t * SERVER_ID must be present,\n\t\t\t * REQUESTED_IP must not be present (we do not check this),\n\t\t\t * chaddr must be filled in,\n\t\t\t * ciaddr must be filled in\n\t\t\t */\n\t\t\tlog1(\"received %s\", \"RELEASE\");\n\t\t\tif (server_id_opt\n\t\t\t && lease  /* chaddr matches this lease */\n\t\t\t && packet.ciaddr == lease->lease_nip\n\t\t\t) {\n\t\t\t\tlease->expires = time(NULL);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase DHCPINFORM:\n\t\t\tlog1(\"received %s\", \"INFORM\");\n\t\t\tsend_inform(&packet);\n\t\t\tbreak;\n\t\t}\n\t}\n ret0:\n\tretval = 0;\n ret:\n\t/*if (server_config.pidfile) - server_config.pidfile is never NULL */\n\t\tremove_pidfile(server_config.pidfile);\n\treturn retval;\n}\n", "target": 1, "idx": 178398}
{"func": "sec_hash_16(uint8 * out, uint8 * in, uint8 * salt1, uint8 * salt2)\n{\n\tRDSSL_MD5 md5;\n\n\trdssl_md5_init(&md5);\n\trdssl_md5_update(&md5, in, 16);\n\trdssl_md5_update(&md5, salt1, 32);\n\trdssl_md5_update(&md5, salt2, 32);\n\trdssl_md5_final(&md5, out);\n}\n", "target": 0, "idx": 93102}
{"func": "int tcp_v4_rcv(struct sk_buff *skb)\n{\n\tstruct net *net = dev_net(skb->dev);\n\tconst struct iphdr *iph;\n\tconst struct tcphdr *th;\n\tbool refcounted;\n\tstruct sock *sk;\n\tint ret;\n\n\tif (skb->pkt_type != PACKET_HOST)\n\t\tgoto discard_it;\n\n\t/* Count it even if it's bad */\n\t__TCP_INC_STATS(net, TCP_MIB_INSEGS);\n\n\tif (!pskb_may_pull(skb, sizeof(struct tcphdr)))\n\t\tgoto discard_it;\n\n\tth = (const struct tcphdr *)skb->data;\n\n\tif (unlikely(th->doff < sizeof(struct tcphdr) / 4))\n\t\tgoto bad_packet;\n\tif (!pskb_may_pull(skb, th->doff * 4))\n\t\tgoto discard_it;\n\n\t/* An explanation is required here, I think.\n\t * Packet length and doff are validated by header prediction,\n\t * provided case of th->doff==0 is eliminated.\n\t * So, we defer the checks. */\n\n\tif (skb_checksum_init(skb, IPPROTO_TCP, inet_compute_pseudo))\n\t\tgoto csum_error;\n\n\tth = (const struct tcphdr *)skb->data;\n\tiph = ip_hdr(skb);\n\t/* This is tricky : We move IPCB at its correct location into TCP_SKB_CB()\n\t * barrier() makes sure compiler wont play fool^Waliasing games.\n\t */\n\tmemmove(&TCP_SKB_CB(skb)->header.h4, IPCB(skb),\n\t\tsizeof(struct inet_skb_parm));\n\tbarrier();\n\n\tTCP_SKB_CB(skb)->seq = ntohl(th->seq);\n\tTCP_SKB_CB(skb)->end_seq = (TCP_SKB_CB(skb)->seq + th->syn + th->fin +\n\t\t\t\t    skb->len - th->doff * 4);\n\tTCP_SKB_CB(skb)->ack_seq = ntohl(th->ack_seq);\n\tTCP_SKB_CB(skb)->tcp_flags = tcp_flag_byte(th);\n\tTCP_SKB_CB(skb)->tcp_tw_isn = 0;\n\tTCP_SKB_CB(skb)->ip_dsfield = ipv4_get_dsfield(iph);\n\tTCP_SKB_CB(skb)->sacked\t = 0;\n\nlookup:\n\tsk = __inet_lookup_skb(&tcp_hashinfo, skb, __tcp_hdrlen(th), th->source,\n\t\t\t       th->dest, &refcounted);\n\tif (!sk)\n\t\tgoto no_tcp_socket;\n\nprocess:\n\tif (sk->sk_state == TCP_TIME_WAIT)\n\t\tgoto do_time_wait;\n\n\tif (sk->sk_state == TCP_NEW_SYN_RECV) {\n\t\tstruct request_sock *req = inet_reqsk(sk);\n\t\tstruct sock *nsk;\n\n\t\tsk = req->rsk_listener;\n\t\tif (unlikely(tcp_v4_inbound_md5_hash(sk, skb))) {\n\t\t\tsk_drops_add(sk, skb);\n\t\t\treqsk_put(req);\n\t\t\tgoto discard_it;\n\t\t}\n\t\tif (unlikely(sk->sk_state != TCP_LISTEN)) {\n\t\t\tinet_csk_reqsk_queue_drop_and_put(sk, req);\n\t\t\tgoto lookup;\n\t\t}\n\t\t/* We own a reference on the listener, increase it again\n\t\t * as we might lose it too soon.\n\t\t */\n\t\tsock_hold(sk);\n\t\trefcounted = true;\n\t\tnsk = tcp_check_req(sk, skb, req, false);\n\t\tif (!nsk) {\n\t\t\treqsk_put(req);\n\t\t\tgoto discard_and_relse;\n\t\t}\n\t\tif (nsk == sk) {\n\t\t\treqsk_put(req);\n\t\t} else if (tcp_child_process(sk, nsk, skb)) {\n\t\t\ttcp_v4_send_reset(nsk, skb);\n\t\t\tgoto discard_and_relse;\n\t\t} else {\n\t\t\tsock_put(sk);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (unlikely(iph->ttl < inet_sk(sk)->min_ttl)) {\n\t\t__NET_INC_STATS(net, LINUX_MIB_TCPMINTTLDROP);\n\t\tgoto discard_and_relse;\n\t}\n\n\tif (!xfrm4_policy_check(sk, XFRM_POLICY_IN, skb))\n\t\tgoto discard_and_relse;\n\n\tif (tcp_v4_inbound_md5_hash(sk, skb))\n\t\tgoto discard_and_relse;\n \n \tnf_reset(skb);\n \n\tif (sk_filter(sk, skb))\n \t\tgoto discard_and_relse;\n \n \tskb->dev = NULL;\n \n\tif (sk->sk_state == TCP_LISTEN) {\n\t\tret = tcp_v4_do_rcv(sk, skb);\n\t\tgoto put_and_return;\n\t}\n\n\tsk_incoming_cpu_update(sk);\n\n\tbh_lock_sock_nested(sk);\n\ttcp_segs_in(tcp_sk(sk), skb);\n\tret = 0;\n\tif (!sock_owned_by_user(sk)) {\n\t\tif (!tcp_prequeue(sk, skb))\n\t\t\tret = tcp_v4_do_rcv(sk, skb);\n\t} else if (tcp_add_backlog(sk, skb)) {\n\t\tgoto discard_and_relse;\n\t}\n\tbh_unlock_sock(sk);\n\nput_and_return:\n\tif (refcounted)\n\t\tsock_put(sk);\n\n\treturn ret;\n\nno_tcp_socket:\n\tif (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb))\n\t\tgoto discard_it;\n\n\tif (tcp_checksum_complete(skb)) {\ncsum_error:\n\t\t__TCP_INC_STATS(net, TCP_MIB_CSUMERRORS);\nbad_packet:\n\t\t__TCP_INC_STATS(net, TCP_MIB_INERRS);\n\t} else {\n\t\ttcp_v4_send_reset(NULL, skb);\n\t}\n\ndiscard_it:\n\t/* Discard frame. */\n\tkfree_skb(skb);\n\treturn 0;\n\ndiscard_and_relse:\n\tsk_drops_add(sk, skb);\n\tif (refcounted)\n\t\tsock_put(sk);\n\tgoto discard_it;\n\ndo_time_wait:\n\tif (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb)) {\n\t\tinet_twsk_put(inet_twsk(sk));\n\t\tgoto discard_it;\n\t}\n\n\tif (tcp_checksum_complete(skb)) {\n\t\tinet_twsk_put(inet_twsk(sk));\n\t\tgoto csum_error;\n\t}\n\tswitch (tcp_timewait_state_process(inet_twsk(sk), skb, th)) {\n\tcase TCP_TW_SYN: {\n\t\tstruct sock *sk2 = inet_lookup_listener(dev_net(skb->dev),\n\t\t\t\t\t\t\t&tcp_hashinfo, skb,\n\t\t\t\t\t\t\t__tcp_hdrlen(th),\n\t\t\t\t\t\t\tiph->saddr, th->source,\n\t\t\t\t\t\t\tiph->daddr, th->dest,\n\t\t\t\t\t\t\tinet_iif(skb));\n\t\tif (sk2) {\n\t\t\tinet_twsk_deschedule_put(inet_twsk(sk));\n\t\t\tsk = sk2;\n\t\t\trefcounted = false;\n\t\t\tgoto process;\n\t\t}\n\t\t/* Fall through to ACK */\n\t}\n\tcase TCP_TW_ACK:\n\t\ttcp_v4_timewait_ack(sk, skb);\n\t\tbreak;\n\tcase TCP_TW_RST:\n\t\ttcp_v4_send_reset(sk, skb);\n\t\tinet_twsk_deschedule_put(inet_twsk(sk));\n\t\tgoto discard_it;\n\tcase TCP_TW_SUCCESS:;\n\t}\n\tgoto discard_it;\n}\n", "target": 1, "idx": 180085}
{"func": "static Eina_Bool _ewk_view_smart_zoom_set(Ewk_View_Smart_Data* smartData, float zoom, Evas_Coord centerX, Evas_Coord centerY)\n{\n    double px, py;\n    Evas_Coord x, y, width, height;\n    Eina_Bool result;\n\n    ewk_frame_scroll_size_get(smartData->main_frame, &width, &height);\n    ewk_frame_scroll_pos_get(smartData->main_frame, &x, &y);\n\n    if (width + smartData->view.w > 0)\n        px = static_cast<double>(x + centerX) / (width + smartData->view.w);\n    else\n        px = 0.0;\n\n    if (height + smartData->view.h > 0)\n        py = static_cast<double>(y + centerY) / (height + smartData->view.h);\n    else\n        py = 0.0;\n\n    result = ewk_frame_page_zoom_set(smartData->main_frame, zoom);\n\n    ewk_frame_scroll_size_get(smartData->main_frame, &width, &height);\n    x = (width + smartData->view.w) * px - centerX;\n    y = (height + smartData->view.h) * py - centerY;\n    ewk_frame_scroll_set(smartData->main_frame, x, y);\n    return result;\n}\n", "target": 0, "idx": 107500}
{"func": "static PHP_FUNCTION(gzopen)\n{\n\tchar *filename;\n\tchar *mode;\n\tint filename_len, mode_len;\n\tint flags = REPORT_ERRORS;\n        php_stream *stream;\n        long use_include_path = 0;\n \n       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ss|l\", &filename, &filename_len, &mode, &mode_len, &use_include_path) == FAILURE) {\n                return;\n        }\n \n\tif (use_include_path) {\n\t\tflags |= USE_PATH;\n\t}\n\n\tstream = php_stream_gzopen(NULL, filename, mode, flags, NULL, NULL STREAMS_CC TSRMLS_CC);\n\n\tif (!stream) {\n\t\tRETURN_FALSE;\n\t}\n\tphp_stream_to_zval(stream, return_value);\n}\n", "target": 1, "idx": 178491}
{"func": "void SignatureUtil::CheckSignature(\n    const FilePath& file_path,\n    ClientDownloadRequest_SignatureInfo* signature_info) {\n  VLOG(2) << \"Checking signature for \" << file_path.value();\n\n  WINTRUST_FILE_INFO file_info;\n  file_info.cbStruct = sizeof(file_info);\n  file_info.pcwszFilePath = file_path.value().c_str();\n  file_info.hFile = NULL;\n  file_info.pgKnownSubject = NULL;\n\n  WINTRUST_DATA wintrust_data;\n  wintrust_data.cbStruct = sizeof(wintrust_data);\n  wintrust_data.pPolicyCallbackData = NULL;\n  wintrust_data.pSIPClientData = NULL;\n  wintrust_data.dwUIChoice = WTD_UI_NONE;\n  wintrust_data.fdwRevocationChecks = WTD_REVOKE_NONE;\n  wintrust_data.dwUnionChoice = WTD_CHOICE_FILE;\n  wintrust_data.pFile = &file_info;\n  wintrust_data.dwStateAction = WTD_STATEACTION_VERIFY;\n  wintrust_data.hWVTStateData = NULL;\n  wintrust_data.pwszURLReference = NULL;\n  wintrust_data.dwProvFlags = WTD_CACHE_ONLY_URL_RETRIEVAL;\n  wintrust_data.dwUIContext = WTD_UICONTEXT_EXECUTE;\n\n  GUID policy_guid = WINTRUST_ACTION_GENERIC_VERIFY_V2;\n\n  LONG result = WinVerifyTrust(static_cast<HWND>(INVALID_HANDLE_VALUE),\n                               &policy_guid,\n                               &wintrust_data);\n\n  CRYPT_PROVIDER_DATA* prov_data = WTHelperProvDataFromStateData(\n      wintrust_data.hWVTStateData);\n  if (prov_data) {\n    if (prov_data->csSigners > 0) {\n      signature_info->set_trusted(result == ERROR_SUCCESS);\n    }\n     for (DWORD i = 0; i < prov_data->csSigners; ++i) {\n       const CERT_CHAIN_CONTEXT* cert_chain_context =\n           prov_data->pasSigners[i].pChainContext;\n       for (DWORD j = 0; j < cert_chain_context->cChain; ++j) {\n         CERT_SIMPLE_CHAIN* simple_chain = cert_chain_context->rgpChain[j];\n         ClientDownloadRequest_CertificateChain* chain =\n             signature_info->add_certificate_chain();\n         for (DWORD k = 0; k < simple_chain->cElement; ++k) {\n           CERT_CHAIN_ELEMENT* element = simple_chain->rgpElement[k];\n           chain->add_element()->set_certificate(\n              element->pCertContext->pbCertEncoded,\n              element->pCertContext->cbCertEncoded);\n        }\n      }\n    }\n\n    wintrust_data.dwStateAction = WTD_STATEACTION_CLOSE;\n    WinVerifyTrust(static_cast<HWND>(INVALID_HANDLE_VALUE),\n                   &policy_guid, &wintrust_data);\n  }\n}\n", "target": 1, "idx": 184605}
{"func": "unsigned long ring_buffer_bytes_cpu(struct ring_buffer *buffer, int cpu)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tunsigned long ret;\n\n\tif (!cpumask_test_cpu(cpu, buffer->cpumask))\n\t\treturn 0;\n\n\tcpu_buffer = buffer->buffers[cpu];\n\tret = local_read(&cpu_buffer->entries_bytes) - cpu_buffer->read_bytes;\n\n\treturn ret;\n}\n", "target": 0, "idx": 72591}
{"func": "void DownloadController::StartAndroidDownloadInternal(\n    const content::ResourceRequestInfo::WebContentsGetter& wc_getter,\n    bool must_download, const DownloadInfo& info, bool allowed) {\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n  if (!allowed)\n    return;\n  WebContents* web_contents = wc_getter.Run();\n  if (!web_contents)\n    return;\n  base::string16 filename = net::GetSuggestedFilename(\n      info.url, info.content_disposition,\n      std::string(),  // referrer_charset\n      std::string(),  // suggested_name\n      info.original_mime_type,\n      default_file_name_);\n  ChromeDownloadDelegate::FromWebContents(web_contents)->RequestHTTPGetDownload(\n      info.url.spec(), info.user_agent,\n      info.content_disposition, info.original_mime_type,\n      info.cookie, info.referer, filename,\n      info.total_bytes, info.has_user_gesture,\n      must_download);\n}\n", "target": 1, "idx": 185762}
{"func": "  void set_delegate(Delegate* delegate) {\n    delegate_ = delegate;\n  }\n", "target": 0, "idx": 116569}
{"func": "const service_manager::Manifest& GetChromeContentBrowserOverlayManifest() {\n  static base::NoDestructor<service_manager::Manifest> manifest {\n    service_manager::ManifestBuilder()\n        .ExposeCapability(\"gpu\",\n                          service_manager::Manifest::InterfaceList<\n                              metrics::mojom::CallStackProfileCollector>())\n        .ExposeCapability(\"renderer\",\n                          service_manager::Manifest::InterfaceList<\n                              chrome::mojom::AvailableOfflineContentProvider,\n                              chrome::mojom::CacheStatsRecorder,\n                              chrome::mojom::NetBenchmarking,\n                              data_reduction_proxy::mojom::DataReductionProxy,\n                              metrics::mojom::CallStackProfileCollector,\n#if defined(OS_WIN)\n                              mojom::ModuleEventSink,\n#endif\n                              rappor::mojom::RapporRecorder,\n                              safe_browsing::mojom::SafeBrowsing>())\n        .RequireCapability(\"ash\", \"system_ui\")\n        .RequireCapability(\"ash\", \"test\")\n        .RequireCapability(\"ash\", \"display\")\n        .RequireCapability(\"assistant\", \"assistant\")\n        .RequireCapability(\"assistant_audio_decoder\", \"assistant:audio_decoder\")\n        .RequireCapability(\"chrome\", \"input_device_controller\")\n        .RequireCapability(\"chrome_printing\", \"converter\")\n        .RequireCapability(\"cups_ipp_parser\", \"ipp_parser\")\n        .RequireCapability(\"device\", \"device:fingerprint\")\n        .RequireCapability(\"device\", \"device:geolocation_config\")\n        .RequireCapability(\"device\", \"device:geolocation_control\")\n        .RequireCapability(\"device\", \"device:ip_geolocator\")\n        .RequireCapability(\"ime\", \"input_engine\")\n        .RequireCapability(\"mirroring\", \"mirroring\")\n        .RequireCapability(\"nacl_broker\", \"browser\")\n        .RequireCapability(\"nacl_loader\", \"browser\")\n        .RequireCapability(\"noop\", \"noop\")\n        .RequireCapability(\"patch\", \"patch_file\")\n        .RequireCapability(\"preferences\", \"pref_client\")\n        .RequireCapability(\"preferences\", \"pref_control\")\n        .RequireCapability(\"profile_import\", \"import\")\n        .RequireCapability(\"removable_storage_writer\",\n                           \"removable_storage_writer\")\n        .RequireCapability(\"secure_channel\", \"secure_channel\")\n        .RequireCapability(\"ui\", \"ime_registrar\")\n        .RequireCapability(\"ui\", \"input_device_controller\")\n        .RequireCapability(\"ui\", \"window_manager\")\n        .RequireCapability(\"unzip\", \"unzip_file\")\n        .RequireCapability(\"util_win\", \"util_win\")\n        .RequireCapability(\"xr_device_service\", \"xr_device_provider\")\n        .RequireCapability(\"xr_device_service\", \"xr_device_test_hook\")\n#if defined(OS_CHROMEOS)\n        .RequireCapability(\"multidevice_setup\", \"multidevice_setup\")\n#endif\n        .ExposeInterfaceFilterCapability_Deprecated(\n            \"navigation:frame\", \"renderer\",\n            service_manager::Manifest::InterfaceList<\n                autofill::mojom::AutofillDriver,\n                autofill::mojom::PasswordManagerDriver,\n                chrome::mojom::OfflinePageAutoFetcher,\n#if defined(OS_CHROMEOS)\n                 chromeos_camera::mojom::CameraAppHelper,\n                 chromeos::cellular_setup::mojom::CellularSetup,\n                 chromeos::crostini_installer::mojom::PageHandlerFactory,\n                chromeos::crostini_upgrader::mojom::PageHandlerFactory,\n                 chromeos::ime::mojom::InputEngineManager,\n                 chromeos::machine_learning::mojom::PageHandler,\n                 chromeos::media_perception::mojom::MediaPerception,\n                chromeos::multidevice_setup::mojom::MultiDeviceSetup,\n                chromeos::multidevice_setup::mojom::PrivilegedHostDeviceSetter,\n                chromeos::network_config::mojom::CrosNetworkConfig,\n                cros::mojom::CameraAppDeviceProvider,\n#endif\n                contextual_search::mojom::ContextualSearchJsApiService,\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n                extensions::KeepAlive,\n#endif\n                media::mojom::MediaEngagementScoreDetailsProvider,\n                media_router::mojom::MediaRouter,\n                page_load_metrics::mojom::PageLoadMetrics,\n                translate::mojom::ContentTranslateDriver,\n\n                downloads::mojom::PageHandlerFactory,\n                feed_internals::mojom::PageHandler,\n                new_tab_page::mojom::PageHandlerFactory,\n#if defined(OS_ANDROID)\n                explore_sites_internals::mojom::PageHandler,\n#else\n                app_management::mojom::PageHandlerFactory,\n#endif\n#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || \\\n    defined(OS_CHROMEOS)\n                discards::mojom::DetailsProvider, discards::mojom::GraphDump,\n#endif\n#if defined(OS_CHROMEOS)\n                add_supervision::mojom::AddSupervisionHandler,\n#endif\n                mojom::BluetoothInternalsHandler,\n                mojom::InterventionsInternalsPageHandler,\n                mojom::OmniboxPageHandler, mojom::ResetPasswordHandler,\n                mojom::SiteEngagementDetailsProvider,\n                mojom::UsbInternalsPageHandler,\n                snippets_internals::mojom::PageHandlerFactory>())\n        .PackageService(prefs::GetManifest())\n#if defined(OS_CHROMEOS)\n        .PackageService(chromeos::multidevice_setup::GetManifest())\n#endif  // defined(OS_CHROMEOS)\n        .Build()\n  };\n  return *manifest;\n}\n", "target": 1, "idx": 186318}
{"func": "PHP_METHOD(Phar, addEmptyDir)\n{\n\tchar *dirname;\n\tsize_t dirname_len;\n \n        PHAR_ARCHIVE_OBJECT();\n \n       if (zend_parse_parameters(ZEND_NUM_ARGS(), \"s\", &dirname, &dirname_len) == FAILURE) {\n                return;\n        }\n \n\tif (dirname_len >= sizeof(\".phar\")-1 && !memcmp(dirname, \".phar\", sizeof(\".phar\")-1)) {\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0, \"Cannot create a directory in magic \\\".phar\\\" directory\");\n\t\treturn;\n\t}\n\n\tphar_mkdir(&phar_obj->archive, dirname, dirname_len);\n}\n", "target": 1, "idx": 178241}
{"func": "int pdf_add_line(struct pdf_doc *pdf, struct pdf_object *page,\n                 int x1, int y1, int x2, int y2, int width, uint32_t colour)\n{\n    int ret;\n    struct dstr str = {0, 0, 0};\n\n    dstr_append(&str, \"BT\\r\\n\");\n    dstr_printf(&str, \"%d w\\r\\n\", width);\n    dstr_printf(&str, \"%d %d m\\r\\n\", x1, y1);\n    dstr_printf(&str, \"/DeviceRGB CS\\r\\n\");\n    dstr_printf(&str, \"%f %f %f RG\\r\\n\",\n                PDF_RGB_R(colour), PDF_RGB_G(colour), PDF_RGB_B(colour));\n    dstr_printf(&str, \"%d %d l S\\r\\n\", x2, y2);\n    dstr_append(&str, \"ET\");\n\n    ret = pdf_add_stream(pdf, page, str.data);\n    dstr_free(&str);\n\n    return ret;\n}\n", "target": 0, "idx": 82992}
{"func": "SpeechSynthesisLibrary* CrosLibrary::GetSpeechSynthesisLibrary() {\n  return speech_synthesis_lib_.GetDefaultImpl(use_stub_impl_);\n}\n", "target": 1, "idx": 184098}
{"func": "int snd_card_new(struct device *parent, int idx, const char *xid,\n\t\t    struct module *module, int extra_size,\n\t\t    struct snd_card **card_ret)\n{\n\tstruct snd_card *card;\n\tint err;\n\n\tif (snd_BUG_ON(!card_ret))\n\t\treturn -EINVAL;\n\t*card_ret = NULL;\n\n\tif (extra_size < 0)\n\t\textra_size = 0;\n\tcard = kzalloc(sizeof(*card) + extra_size, GFP_KERNEL);\n\tif (!card)\n\t\treturn -ENOMEM;\n\tif (extra_size > 0)\n\t\tcard->private_data = (char *)card + sizeof(struct snd_card);\n\tif (xid)\n\t\tstrlcpy(card->id, xid, sizeof(card->id));\n\terr = 0;\n\tmutex_lock(&snd_card_mutex);\n\tif (idx < 0) /* first check the matching module-name slot */\n\t\tidx = get_slot_from_bitmask(idx, module_slot_match, module);\n\tif (idx < 0) /* if not matched, assign an empty slot */\n\t\tidx = get_slot_from_bitmask(idx, check_empty_slot, module);\n\tif (idx < 0)\n\t\terr = -ENODEV;\n\telse if (idx < snd_ecards_limit) {\n\t\tif (test_bit(idx, snd_cards_lock))\n\t\t\terr = -EBUSY;\t/* invalid */\n\t} else if (idx >= SNDRV_CARDS)\n\t\terr = -ENODEV;\n\tif (err < 0) {\n\t\tmutex_unlock(&snd_card_mutex);\n\t\tdev_err(parent, \"cannot find the slot for index %d (range 0-%i), error: %d\\n\",\n\t\t\t idx, snd_ecards_limit - 1, err);\n\t\tkfree(card);\n\t\treturn err;\n\t}\n\tset_bit(idx, snd_cards_lock);\t\t/* lock it */\n\tif (idx >= snd_ecards_limit)\n\t\tsnd_ecards_limit = idx + 1; /* increase the limit */\n\tmutex_unlock(&snd_card_mutex);\n\tcard->dev = parent;\n\tcard->number = idx;\n\tcard->module = module;\n \tINIT_LIST_HEAD(&card->devices);\n \tinit_rwsem(&card->controls_rwsem);\n \trwlock_init(&card->ctl_files_rwlock);\n \tINIT_LIST_HEAD(&card->controls);\n \tINIT_LIST_HEAD(&card->ctl_files);\n \tspin_lock_init(&card->files_lock);\n\tINIT_LIST_HEAD(&card->files_list);\n#ifdef CONFIG_PM\n\tmutex_init(&card->power_lock);\n\tinit_waitqueue_head(&card->power_sleep);\n#endif\n\n\tdevice_initialize(&card->card_dev);\n\tcard->card_dev.parent = parent;\n\tcard->card_dev.class = sound_class;\n\tcard->card_dev.release = release_card_device;\n\tcard->card_dev.groups = card_dev_attr_groups;\n\terr = kobject_set_name(&card->card_dev.kobj, \"card%d\", idx);\n\tif (err < 0)\n\t\tgoto __error;\n\n\t/* the control interface cannot be accessed from the user space until */\n\t/* snd_cards_bitmask and snd_cards are set with snd_card_register */\n\terr = snd_ctl_create(card);\n\tif (err < 0) {\n\t\tdev_err(parent, \"unable to register control minors\\n\");\n\t\tgoto __error;\n\t}\n\terr = snd_info_card_create(card);\n\tif (err < 0) {\n\t\tdev_err(parent, \"unable to create card info\\n\");\n\t\tgoto __error_ctl;\n\t}\n\t*card_ret = card;\n\treturn 0;\n\n      __error_ctl:\n\tsnd_device_free_all(card);\n      __error:\n\tput_device(&card->card_dev);\n  \treturn err;\n}\n", "target": 1, "idx": 179472}
{"func": "static void php_mb_regex_free_cache(php_mb_regex_t **pre) \n {\n \tonig_free(*pre);\n }\n", "target": 1, "idx": 180294}
{"func": "const char* lodepng_error_text(unsigned code)\n{\n  switch(code)\n  {\n    case 0: return \"no error, everything went ok\";\n    case 1: return \"nothing done yet\"; /*the Encoder/Decoder has done nothing yet, error checking makes no sense yet*/\n    case 10: return \"end of input memory reached without huffman end code\"; /*while huffman decoding*/\n    case 11: return \"error in code tree made it jump outside of huffman tree\"; /*while huffman decoding*/\n    case 13: return \"problem while processing dynamic deflate block\";\n    case 14: return \"problem while processing dynamic deflate block\";\n    case 15: return \"problem while processing dynamic deflate block\";\n    case 16: return \"unexisting code while processing dynamic deflate block\";\n    case 17: return \"end of out buffer memory reached while inflating\";\n    case 18: return \"invalid distance code while inflating\";\n    case 19: return \"end of out buffer memory reached while inflating\";\n    case 20: return \"invalid deflate block BTYPE encountered while decoding\";\n    case 21: return \"NLEN is not ones complement of LEN in a deflate block\";\n     /*end of out buffer memory reached while inflating:\n     This can happen if the inflated deflate data is longer than the amount of bytes required to fill up\n     all the pixels of the image, given the color depth and image dimensions. Something that doesn't\n     happen in a normal, well encoded, PNG image.*/\n    case 22: return \"end of out buffer memory reached while inflating\";\n    case 23: return \"end of in buffer memory reached while inflating\";\n    case 24: return \"invalid FCHECK in zlib header\";\n    case 25: return \"invalid compression method in zlib header\";\n    case 26: return \"FDICT encountered in zlib header while it's not used for PNG\";\n    case 27: return \"PNG file is smaller than a PNG header\";\n    /*Checks the magic file header, the first 8 bytes of the PNG file*/\n    case 28: return \"incorrect PNG signature, it's no PNG or corrupted\";\n    case 29: return \"first chunk is not the header chunk\";\n    case 30: return \"chunk length too large, chunk broken off at end of file\";\n    case 31: return \"illegal PNG color type or bpp\";\n    case 32: return \"illegal PNG compression method\";\n    case 33: return \"illegal PNG filter method\";\n    case 34: return \"illegal PNG interlace method\";\n    case 35: return \"chunk length of a chunk is too large or the chunk too small\";\n    case 36: return \"illegal PNG filter type encountered\";\n    case 37: return \"illegal bit depth for this color type given\";\n    case 38: return \"the palette is too big\"; /*more than 256 colors*/\n    case 39: return \"more palette alpha values given in tRNS chunk than there are colors in the palette\";\n    case 40: return \"tRNS chunk has wrong size for greyscale image\";\n    case 41: return \"tRNS chunk has wrong size for RGB image\";\n    case 42: return \"tRNS chunk appeared while it was not allowed for this color type\";\n    case 43: return \"bKGD chunk has wrong size for palette image\";\n    case 44: return \"bKGD chunk has wrong size for greyscale image\";\n    case 45: return \"bKGD chunk has wrong size for RGB image\";\n    /*the input data is empty, maybe a PNG file doesn't exist or is in the wrong path*/\n    case 48: return \"empty input or file doesn't exist\";\n    case 49: return \"jumped past memory while generating dynamic huffman tree\";\n    case 50: return \"jumped past memory while generating dynamic huffman tree\";\n    case 51: return \"jumped past memory while inflating huffman block\";\n    case 52: return \"jumped past memory while inflating\";\n    case 53: return \"size of zlib data too small\";\n    case 54: return \"repeat symbol in tree while there was no value symbol yet\";\n    /*jumped past tree while generating huffman tree, this could be when the\n    tree will have more leaves than symbols after generating it out of the\n    given lenghts. They call this an oversubscribed dynamic bit lengths tree in zlib.*/\n    case 55: return \"jumped past tree while generating huffman tree\";\n    case 56: return \"given output image colortype or bitdepth not supported for color conversion\";\n    case 57: return \"invalid CRC encountered (checking CRC can be disabled)\";\n    case 58: return \"invalid ADLER32 encountered (checking ADLER32 can be disabled)\";\n    case 59: return \"requested color conversion not supported\";\n    case 60: return \"invalid window size given in the settings of the encoder (must be 0-32768)\";\n    case 61: return \"invalid BTYPE given in the settings of the encoder (only 0, 1 and 2 are allowed)\";\n    /*LodePNG leaves the choice of RGB to greyscale conversion formula to the user.*/\n    case 62: return \"conversion from color to greyscale not supported\";\n    case 63: return \"length of a chunk too long, max allowed for PNG is 2147483647 bytes per chunk\"; /*(2^31-1)*/\n    /*this would result in the inability of a deflated block to ever contain an end code. It must be at least 1.*/\n    case 64: return \"the length of the END symbol 256 in the Huffman tree is 0\";\n    case 66: return \"the length of a text chunk keyword given to the encoder is longer than the maximum of 79 bytes\";\n    case 67: return \"the length of a text chunk keyword given to the encoder is smaller than the minimum of 1 byte\";\n    case 68: return \"tried to encode a PLTE chunk with a palette that has less than 1 or more than 256 colors\";\n    case 69: return \"unknown chunk type with 'critical' flag encountered by the decoder\";\n    case 71: return \"unexisting interlace mode given to encoder (must be 0 or 1)\";\n    case 72: return \"while decoding, unexisting compression method encountering in zTXt or iTXt chunk (it must be 0)\";\n    case 73: return \"invalid tIME chunk size\";\n    case 74: return \"invalid pHYs chunk size\";\n    /*length could be wrong, or data chopped off*/\n    case 75: return \"no null termination char found while decoding text chunk\";\n    case 76: return \"iTXt chunk too short to contain required bytes\";\n    case 77: return \"integer overflow in buffer size\";\n    case 78: return \"failed to open file for reading\"; /*file doesn't exist or couldn't be opened for reading*/\n    case 79: return \"failed to open file for writing\";\n    case 80: return \"tried creating a tree of 0 symbols\";\n    case 81: return \"lazy matching at pos 0 is impossible\";\n    case 82: return \"color conversion to palette requested while a color isn't in palette\";\n    case 83: return \"memory allocation failed\";\n    case 84: return \"given image too small to contain all pixels to be encoded\";\n    case 86: return \"impossible offset in lz77 encoding (internal bug)\";\n    case 87: return \"must provide custom zlib function pointer if LODEPNG_COMPILE_ZLIB is not defined\";\n    case 88: return \"invalid filter strategy given for LodePNGEncoderSettings.filter_strategy\";\n    case 89: return \"text chunk keyword too short or long: must have size 1-79\";\n    /*the windowsize in the LodePNGCompressSettings. Requiring POT(==> & instead of %) makes encoding 12% faster.*/\n    case 90: return \"windowsize must be a power of two\";\n    case 91: return \"fwrite failed\";\n  }\n  return \"unknown error code\";\n}\n", "target": 0, "idx": 87546}
{"func": "bool IsSmartVirtualKeyboardEnabled() {\n  if (base::CommandLine::ForCurrentProcess()->HasSwitch(\n           keyboard::switches::kEnableVirtualKeyboard)) {\n     return false;\n   }\n  return !base::CommandLine::ForCurrentProcess()->HasSwitch(\n      keyboard::switches::kDisableSmartVirtualKeyboard);\n }\n", "target": 1, "idx": 185478}
{"func": "static int bochs_open(BlockDriverState *bs, QDict *options, int flags,\n                      Error **errp)\n{\n    BDRVBochsState *s = bs->opaque;\n    uint32_t i;\n    struct bochs_header bochs;\n    int ret;\n\n    bs->read_only = 1; // no write support yet\n\n    ret = bdrv_pread(bs->file, 0, &bochs, sizeof(bochs));\n    if (ret < 0) {\n        return ret;\n    }\n\n    if (strcmp(bochs.magic, HEADER_MAGIC) ||\n        strcmp(bochs.type, REDOLOG_TYPE) ||\n        strcmp(bochs.subtype, GROWING_TYPE) ||\n\t((le32_to_cpu(bochs.version) != HEADER_VERSION) &&\n\t(le32_to_cpu(bochs.version) != HEADER_V1))) {\n        error_setg(errp, \"Image not in Bochs format\");\n        return -EINVAL;\n    }\n\n    if (le32_to_cpu(bochs.version) == HEADER_V1) {\n        bs->total_sectors = le64_to_cpu(bochs.extra.redolog_v1.disk) / 512;\n    } else {\n         bs->total_sectors = le64_to_cpu(bochs.extra.redolog.disk) / 512;\n     }\n \n     s->catalog_size = le32_to_cpu(bochs.catalog);\n     s->catalog_bitmap = g_malloc(s->catalog_size * 4);\n \n     ret = bdrv_pread(bs->file, le32_to_cpu(bochs.header), s->catalog_bitmap,\n\n    s->data_offset = le32_to_cpu(bochs.header) + (s->catalog_size * 4);\n\n    s->bitmap_blocks = 1 + (le32_to_cpu(bochs.bitmap) - 1) / 512;\n    s->extent_blocks = 1 + (le32_to_cpu(bochs.extent) - 1) / 512;\n\n    s->extent_size = le32_to_cpu(bochs.extent);\n\n    qemu_co_mutex_init(&s->lock);\n    return 0;\n\nfail:\n \n     s->extent_size = le32_to_cpu(bochs.extent);\n \n     qemu_co_mutex_init(&s->lock);\n     return 0;\n    extent_index = offset / s->extent_size;\n    extent_offset = (offset % s->extent_size) / 512;\n\n    if (s->catalog_bitmap[extent_index] == 0xffffffff) {\n\treturn -1; /* not allocated */\n    }\n\n    bitmap_offset = s->data_offset + (512 * s->catalog_bitmap[extent_index] *\n\t(s->extent_blocks + s->bitmap_blocks));\n\n    /* read in bitmap for current extent */\n    if (bdrv_pread(bs->file, bitmap_offset + (extent_offset / 8),\n                   &bitmap_entry, 1) != 1) {\n        return -1;\n    }\n\n    if (!((bitmap_entry >> (extent_offset % 8)) & 1)) {\n\treturn -1; /* not allocated */\n    }\n\n    return bitmap_offset + (512 * (s->bitmap_blocks + extent_offset));\n}\n", "target": 1, "idx": 178576}
{"func": "static void igmp_heard_query(struct in_device *in_dev, struct sk_buff *skb,\n\tint len)\n{\n\tstruct igmphdr \t\t*ih = igmp_hdr(skb);\n\tstruct igmpv3_query *ih3 = igmpv3_query_hdr(skb);\n\tstruct ip_mc_list\t*im;\n\t__be32\t\t\tgroup = ih->group;\n\tint\t\t\tmax_delay;\n\tint\t\t\tmark = 0;\n\n\n\tif (len == 8) {\n\t\tif (ih->code == 0) {\n\t\t\t/* Alas, old v1 router presents here. */\n\n\t\t\tmax_delay = IGMP_Query_Response_Interval;\n\t\t\tin_dev->mr_v1_seen = jiffies +\n\t\t\t\tIGMP_V1_Router_Present_Timeout;\n\t\t\tgroup = 0;\n\t\t} else {\n\t\t\t/* v2 router present */\n\t\t\tmax_delay = ih->code*(HZ/IGMP_TIMER_SCALE);\n\t\t\tin_dev->mr_v2_seen = jiffies +\n\t\t\t\tIGMP_V2_Router_Present_Timeout;\n\t\t}\n\t\t/* cancel the interface change timer */\n\t\tin_dev->mr_ifc_count = 0;\n\t\tif (del_timer(&in_dev->mr_ifc_timer))\n\t\t\t__in_dev_put(in_dev);\n\t\t/* clear deleted report items */\n\t\tigmpv3_clear_delrec(in_dev);\n\t} else if (len < 12) {\n\t\treturn;\t/* ignore bogus packet; freed by caller */\n\t} else if (IGMP_V1_SEEN(in_dev)) {\n\t\t/* This is a v3 query with v1 queriers present */\n\t\tmax_delay = IGMP_Query_Response_Interval;\n\t\tgroup = 0;\n\t} else if (IGMP_V2_SEEN(in_dev)) {\n\t\t/* this is a v3 query with v2 queriers present;\n\t\t * Interpretation of the max_delay code is problematic here.\n\t\t * A real v2 host would use ih_code directly, while v3 has a\n\t\t * different encoding. We use the v3 encoding as more likely\n \t\t * to be intended in a v3 query.\n \t\t */\n \t\tmax_delay = IGMPV3_MRC(ih3->code)*(HZ/IGMP_TIMER_SCALE);\n \t} else { /* v3 */\n \t\tif (!pskb_may_pull(skb, sizeof(struct igmpv3_query)))\n \t\t\treturn;\n\n\t\tih3 = igmpv3_query_hdr(skb);\n\t\tif (ih3->nsrcs) {\n\t\t\tif (!pskb_may_pull(skb, sizeof(struct igmpv3_query)\n\t\t\t\t\t   + ntohs(ih3->nsrcs)*sizeof(__be32)))\n\t\t\t\treturn;\n\t\t\tih3 = igmpv3_query_hdr(skb);\n\t\t}\n\n\t\tmax_delay = IGMPV3_MRC(ih3->code)*(HZ/IGMP_TIMER_SCALE);\n\t\tif (!max_delay)\n\t\t\tmax_delay = 1;\t/* can't mod w/ 0 */\n\t\tin_dev->mr_maxdelay = max_delay;\n\t\tif (ih3->qrv)\n\t\t\tin_dev->mr_qrv = ih3->qrv;\n\t\tif (!group) { /* general query */\n\t\t\tif (ih3->nsrcs)\n\t\t\t\treturn;\t/* no sources allowed */\n\t\t\tigmp_gq_start_timer(in_dev);\n\t\t\treturn;\n\t\t}\n\t\t/* mark sources to include, if group & source-specific */\n\t\tmark = ih3->nsrcs != 0;\n\t}\n\n\t/*\n\t * - Start the timers in all of our membership records\n\t *   that the query applies to for the interface on\n\t *   which the query arrived excl. those that belong\n\t *   to a \"local\" group (224.0.0.X)\n\t * - For timers already running check if they need to\n\t *   be reset.\n\t * - Use the igmp->igmp_code field as the maximum\n\t *   delay possible\n\t */\n\trcu_read_lock();\n\tfor_each_pmc_rcu(in_dev, im) {\n\t\tint changed;\n\n\t\tif (group && group != im->multiaddr)\n\t\t\tcontinue;\n\t\tif (im->multiaddr == IGMP_ALL_HOSTS)\n\t\t\tcontinue;\n\t\tspin_lock_bh(&im->lock);\n\t\tif (im->tm_running)\n\t\t\tim->gsquery = im->gsquery && mark;\n\t\telse\n\t\t\tim->gsquery = mark;\n\t\tchanged = !im->gsquery ||\n\t\t\tigmp_marksources(im, ntohs(ih3->nsrcs), ih3->srcs);\n\t\tspin_unlock_bh(&im->lock);\n\t\tif (changed)\n\t\t\tigmp_mod_timer(im, max_delay);\n\t}\n\trcu_read_unlock();\n}\n", "target": 1, "idx": 178823}
{"func": "static void emitraw(JF, int value)\n{\n\tif (value != (js_Instruction)value)\n\t\tjs_syntaxerror(J, \"integer overflow in instruction coding\");\n\tif (F->codelen >= F->codecap) {\n\t\tF->codecap = F->codecap ? F->codecap * 2 : 64;\n\t\tF->code = js_realloc(J, F->code, F->codecap * sizeof *F->code);\n\t}\n\tF->code[F->codelen++] = value;\n}\n", "target": 0, "idx": 7931}
{"func": "static int __net_init sctp_net_init(struct net *net)\n {\n \tint status;\n \n\t/*\n\t * 14. Suggested SCTP Protocol Parameter Values\n\t */\n\t/* The following protocol parameters are RECOMMENDED:  */\n\t/* RTO.Initial              - 3  seconds */\n\tnet->sctp.rto_initial\t\t\t= SCTP_RTO_INITIAL;\n\t/* RTO.Min                  - 1  second */\n\tnet->sctp.rto_min\t \t\t= SCTP_RTO_MIN;\n\t/* RTO.Max                 -  60 seconds */\n\tnet->sctp.rto_max \t\t\t= SCTP_RTO_MAX;\n\t/* RTO.Alpha                - 1/8 */\n\tnet->sctp.rto_alpha\t\t\t= SCTP_RTO_ALPHA;\n\t/* RTO.Beta                 - 1/4 */\n\tnet->sctp.rto_beta\t\t\t= SCTP_RTO_BETA;\n\n\t/* Valid.Cookie.Life        - 60  seconds */\n\tnet->sctp.valid_cookie_life\t\t= SCTP_DEFAULT_COOKIE_LIFE;\n\n\t/* Whether Cookie Preservative is enabled(1) or not(0) */\n\tnet->sctp.cookie_preserve_enable \t= 1;\n\n\t/* Default sctp sockets to use md5 as their hmac alg */\n#if defined (CONFIG_SCTP_DEFAULT_COOKIE_HMAC_MD5)\n\tnet->sctp.sctp_hmac_alg\t\t\t= \"md5\";\n#elif defined (CONFIG_SCTP_DEFAULT_COOKIE_HMAC_SHA1)\n\tnet->sctp.sctp_hmac_alg\t\t\t= \"sha1\";\n#else\n\tnet->sctp.sctp_hmac_alg\t\t\t= NULL;\n#endif\n\n\t/* Max.Burst\t\t    - 4 */\n\tnet->sctp.max_burst\t\t\t= SCTP_DEFAULT_MAX_BURST;\n\n\t/* Association.Max.Retrans  - 10 attempts\n\t * Path.Max.Retrans         - 5  attempts (per destination address)\n\t * Max.Init.Retransmits     - 8  attempts\n\t */\n\tnet->sctp.max_retrans_association\t= 10;\n\tnet->sctp.max_retrans_path\t\t= 5;\n\tnet->sctp.max_retrans_init\t\t= 8;\n\n\t/* Sendbuffer growth\t    - do per-socket accounting */\n\tnet->sctp.sndbuf_policy\t\t\t= 0;\n\n\t/* Rcvbuffer growth\t    - do per-socket accounting */\n\tnet->sctp.rcvbuf_policy\t\t\t= 0;\n\n\t/* HB.interval              - 30 seconds */\n\tnet->sctp.hb_interval\t\t\t= SCTP_DEFAULT_TIMEOUT_HEARTBEAT;\n\n\t/* delayed SACK timeout */\n\tnet->sctp.sack_timeout\t\t\t= SCTP_DEFAULT_TIMEOUT_SACK;\n\n\t/* Disable ADDIP by default. */\n\tnet->sctp.addip_enable = 0;\n\tnet->sctp.addip_noauth = 0;\n\tnet->sctp.default_auto_asconf = 0;\n\n\t/* Enable PR-SCTP by default. */\n\tnet->sctp.prsctp_enable = 1;\n\n\t/* Disable AUTH by default. */\n\tnet->sctp.auth_enable = 0;\n\n\t/* Set SCOPE policy to enabled */\n\tnet->sctp.scope_policy = SCTP_SCOPE_POLICY_ENABLE;\n\n\t/* Set the default rwnd update threshold */\n\tnet->sctp.rwnd_upd_shift = SCTP_DEFAULT_RWND_SHIFT;\n\n\t/* Initialize maximum autoclose timeout. */\n\tnet->sctp.max_autoclose\t\t= INT_MAX / HZ;\n\n\tstatus = sctp_sysctl_net_register(net);\n\tif (status)\n\t\tgoto err_sysctl_register;\n\n\t/* Allocate and initialise sctp mibs.  */\n\tstatus = init_sctp_mibs(net);\n\tif (status)\n\t\tgoto err_init_mibs;\n\n\t/* Initialize proc fs directory.  */\n\tstatus = sctp_proc_init(net);\n\tif (status)\n\t\tgoto err_init_proc;\n \n \tsctp_dbg_objcnt_init(net);\n \n\t/* Initialize the control inode/socket for handling OOTB packets.  */\n\tif ((status = sctp_ctl_sock_init(net))) {\n\t\tpr_err(\"Failed to initialize the SCTP control sock\\n\");\n\t\tgoto err_ctl_sock_init;\n\t}\n \t/* Initialize the local address list. */\n \tINIT_LIST_HEAD(&net->sctp.local_addr_list);\n \tspin_lock_init(&net->sctp.local_addr_lock);\n\tsctp_get_local_addr_list(net);\n\n\t/* Initialize the address event list */\n\tINIT_LIST_HEAD(&net->sctp.addr_waitq);\n\tINIT_LIST_HEAD(&net->sctp.auto_asconf_splist);\n\tspin_lock_init(&net->sctp.addr_wq_lock);\n\tnet->sctp.addr_wq_timer.expires = 0;\n\tsetup_timer(&net->sctp.addr_wq_timer, sctp_addr_wq_timeout_handler,\n\t\t    (unsigned long)net);\n \n \treturn 0;\n \nerr_ctl_sock_init:\n\tsctp_dbg_objcnt_exit(net);\n\tsctp_proc_exit(net);\n err_init_proc:\n \tcleanup_sctp_mibs(net);\n err_init_mibs:\n\tsctp_sysctl_net_unregister(net);\nerr_sysctl_register:\n \treturn status;\n }\n", "target": 1, "idx": 179780}
{"func": "  FileMetricsProviderTest()\n      : create_large_files_(GetParam()),\n        task_runner_(new base::TestSimpleTaskRunner()),\n        thread_task_runner_handle_(task_runner_),\n        statistics_recorder_(\n            base::StatisticsRecorder::CreateTemporaryForTesting()),\n        prefs_(new TestingPrefServiceSimple) {\n     EXPECT_TRUE(temp_dir_.CreateUniqueTempDir());\n     FileMetricsProvider::RegisterPrefs(prefs_->registry(), kMetricsName);\n     FileMetricsProvider::SetTaskRunnerForTesting(task_runner_);\n    base::GlobalHistogramAllocator::GetCreateHistogramResultHistogram();\n   }\n", "target": 1, "idx": 186109}
{"func": "     DisplayItemListTest()\n         : m_displayItemList(DisplayItemList::create())\n        , m_originalSlimmingPaintSubsequenceCachingEnabled(RuntimeEnabledFeatures::slimmingPaintSubsequenceCachingEnabled()) { }\n", "target": 1, "idx": 185461}
{"func": "bool LayoutBlockFlow::hitTestFloats(HitTestResult& result, const HitTestLocation& locationInContainer, const LayoutPoint& accumulatedOffset)\n{\n    if (!m_floatingObjects)\n        return false;\n\n    LayoutPoint adjustedLocation = accumulatedOffset;\n    if (isLayoutView()) {\n        DoublePoint position = toLayoutView(this)->frameView()->scrollPositionDouble();\n        adjustedLocation.move(position.x(), position.y());\n    }\n\n    const FloatingObjectSet& floatingObjectSet = m_floatingObjects->set();\n    FloatingObjectSetIterator begin = floatingObjectSet.begin();\n    for (FloatingObjectSetIterator it = floatingObjectSet.end(); it != begin;) {\n        --it;\n        const FloatingObject& floatingObject = *it->get();\n        if (floatingObject.isDirectlyContained() && !floatingObject.layoutObject()->hasSelfPaintingLayer()) {\n            LayoutUnit xOffset = xPositionForFloatIncludingMargin(floatingObject) - floatingObject.layoutObject()->location().x();\n            LayoutUnit yOffset = yPositionForFloatIncludingMargin(floatingObject) - floatingObject.layoutObject()->location().y();\n            LayoutPoint childPoint = flipFloatForWritingModeForChild(floatingObject, adjustedLocation + LayoutSize(xOffset, yOffset));\n            if (floatingObject.layoutObject()->hitTest(result, locationInContainer, childPoint)) {\n                updateHitTestResult(result, locationInContainer.point() - toLayoutSize(childPoint));\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n", "target": 0, "idx": 132071}
{"func": " static void kvmclock_reset(struct kvm_vcpu *vcpu)\n {\n\tif (vcpu->arch.time_page) {\n\t\tkvm_release_page_dirty(vcpu->arch.time_page);\n\t\tvcpu->arch.time_page = NULL;\n\t}\n }\n", "target": 1, "idx": 179291}
{"func": " StorageHandler::StorageHandler()\n     : DevToolsDomainHandler(Storage::Metainfo::domainName),\n      process_(nullptr),\n       weak_ptr_factory_(this) {}\n", "target": 1, "idx": 186752}
{"func": "bool Track::VetEntry(const BlockEntry* pBlockEntry) const\n{\n    assert(pBlockEntry);\n    const Block* const pBlock = pBlockEntry->GetBlock();\n    assert(pBlock);\n    assert(pBlock->GetTrackNumber() == m_info.number);\n    if (!pBlock || pBlock->GetTrackNumber() != m_info.number)\n        return false;\n \n \n    return true;\n }\n", "target": 1, "idx": 188473}
{"func": "static int find_high_bit(unsigned int x)\n {\n \tint i;\n \tfor(i=31;i>=0;i--) {\n\t\tif(x&(1<<i)) return i;\n \t}\n \treturn 0;\n }\n", "target": 1, "idx": 181366}
{"func": "WM_SYMBOL midi *WildMidi_Open(const char *midifile) {\n    uint8_t *mididata = NULL;\n    uint32_t midisize = 0;\n    uint8_t mus_hdr[] = { 'M', 'U', 'S', 0x1A };\n    uint8_t xmi_hdr[] = { 'F', 'O', 'R', 'M' };\n    midi * ret = NULL;\n\n    if (!WM_Initialized) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_INIT, NULL, 0);\n        return (NULL);\n    }\n    if (midifile == NULL) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(NULL filename)\", 0);\n        return (NULL);\n    }\n\n     if ((mididata = (uint8_t *) _WM_BufferFile(midifile, &midisize)) == NULL) {\n         return (NULL);\n     }\n     if (memcmp(mididata,\"HMIMIDIP\", 8) == 0) {\n         ret = (void *) _WM_ParseNewHmp(mididata, midisize);\n     } else if (memcmp(mididata, \"HMI-MIDISONG061595\", 18) == 0) {\n        ret = (void *) _WM_ParseNewHmi(mididata, midisize);\n    } else if (memcmp(mididata, mus_hdr, 4) == 0) {\n        ret = (void *) _WM_ParseNewMus(mididata, midisize);\n    } else if (memcmp(mididata, xmi_hdr, 4) == 0) {\n        ret = (void *) _WM_ParseNewXmi(mididata, midisize);\n    } else {\n        ret = (void *) _WM_ParseNewMidi(mididata, midisize);\n    }\n    free(mididata);\n\n    if (ret) {\n        if (add_handle(ret) != 0) {\n            WildMidi_Close(ret);\n            ret = NULL;\n        }\n    }\n\n    return (ret);\n}\n", "target": 1, "idx": 182541}
{"func": "  static void  Ins_MDRP( INS_ARG )\n  {\n    Int         point;\n    TT_F26Dot6  distance,\n                org_dist;\n \n     point = (Int)args[0];\n \n    if ( BOUNDS( args[0], CUR.zp1.n_points ) )\n     {\n         /* Current version of FreeType silently ignores this out of bounds error\n          * and drops the instruction, see bug #691121\n      return;\n    }\n\n    /* XXX: Is there some undocumented feature while in the */\n    /*      twilight zone?                                  */\n\n    org_dist = CUR_Func_dualproj( CUR.zp1.org_x[point] -\n                                    CUR.zp0.org_x[CUR.GS.rp0],\n                                  CUR.zp1.org_y[point] -\n                                    CUR.zp0.org_y[CUR.GS.rp0] );\n\n    /* single width cutin test */\n\n    if ( ABS(org_dist) < CUR.GS.single_width_cutin )\n    {\n      if ( org_dist >= 0 )\n        org_dist = CUR.GS.single_width_value;\n      else\n        org_dist = -CUR.GS.single_width_value;\n    }\n\n    /* round flag */\n\n    if ( (CUR.opcode & 4) != 0 )\n      distance = CUR_Func_round( org_dist,\n                                 CUR.metrics.compensations[CUR.opcode & 3] );\n    else\n      distance = Round_None( EXEC_ARGS\n                             org_dist,\n                             CUR.metrics.compensations[CUR.opcode & 3]  );\n\n    /* minimum distance flag */\n\n    if ( (CUR.opcode & 8) != 0 )\n    {\n      if ( org_dist >= 0 )\n      {\n        if ( distance < CUR.GS.minimum_distance )\n          distance = CUR.GS.minimum_distance;\n      }\n      else\n      {\n        if ( distance > -CUR.GS.minimum_distance )\n          distance = -CUR.GS.minimum_distance;\n      }\n    }\n\n    /* now move the point */\n\n    org_dist = CUR_Func_project( CUR.zp1.cur_x[point] -\n                                   CUR.zp0.cur_x[CUR.GS.rp0],\n                                 CUR.zp1.cur_y[point] -\n                                   CUR.zp0.cur_y[CUR.GS.rp0] );\n\n    CUR_Func_move( &CUR.zp1, point, distance - org_dist );\n\n    CUR.GS.rp1 = CUR.GS.rp0;\n    CUR.GS.rp2 = point;\n\n    if ( (CUR.opcode & 16) != 0 )\n      CUR.GS.rp0 = point;\n  }\n", "target": 1, "idx": 177952}
{"func": "stf_status ikev2parent_inI1outR1(struct msg_digest *md)\n{\n\tstruct state *st = md->st;\n\tlset_t policy = POLICY_IKEV2_ALLOW;\n\tstruct connection *c = find_host_connection(&md->iface->ip_addr,\n\t\t\t\t\t\t    md->iface->port,\n\t\t\t\t\t\t    &md->sender,\n\t\t\t\t\t\t    md->sender_port,\n\t\t\t\t\t\t    POLICY_IKEV2_ALLOW);\n\n\t/* retrieve st->st_gi */\n\n#if 0\n\tif (c == NULL) {\n\t\t/*\n\t\t * make up a policy from the thing that was proposed, and see\n\t\t * if we can find a connection with that policy.\n\t\t */\n\n\t\tpb_stream pre_sa_pbs = sa_pd->pbs;\n\t\tpolicy = preparse_isakmp_sa_body(&pre_sa_pbs);\n\t\tc = find_host_connection(&md->iface->ip_addr, pluto_port,\n\t\t\t\t\t (ip_address*)NULL, md->sender_port,\n\t\t\t\t\t policy);\n\n\t}\n#endif\n\n\tif (c == NULL) {\n\n\t\t/* See if a wildcarded connection can be found.\n\t\t * We cannot pick the right connection, so we're making a guess.\n\t\t * All Road Warrior connections are fair game:\n\t\t * we pick the first we come across (if any).\n\t\t * If we don't find any, we pick the first opportunistic\n\t\t * with the smallest subnet that includes the peer.\n\t\t * There is, of course, no necessary relationship between\n\t\t * an Initiator's address and that of its client,\n\t\t * but Food Groups kind of assumes one.\n\t\t */\n\t\t{\n\t\t\tstruct connection *d;\n\t\t\td = find_host_connection(&md->iface->ip_addr,\n\t\t\t\t\t\t pluto_port,\n\t\t\t\t\t\t (ip_address*)NULL,\n\t\t\t\t\t\t md->sender_port, policy);\n\n\t\t\tfor (; d != NULL; d = d->hp_next) {\n\t\t\t\tif (d->kind == CK_GROUP) {\n\t\t\t\t\t/* ignore */\n\t\t\t\t} else {\n\t\t\t\t\tif (d->kind == CK_TEMPLATE &&\n\t\t\t\t\t    !(d->policy & POLICY_OPPO)) {\n\t\t\t\t\t\t/* must be Road Warrior: we have a winner */\n\t\t\t\t\t\tc = d;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Opportunistic or Shunt: pick tightest match */\n\t\t\t\t\tif (addrinsubnet(&md->sender,\n\t\t\t\t\t\t\t &d->spd.that.client)\n\t\t\t\t\t    &&\n\t\t\t\t\t    (c == NULL ||\n\t\t\t\t\t     !subnetinsubnet(&c->spd.that.\n\t\t\t\t\t\t\t     client,\n\t\t\t\t\t\t\t     &d->spd.that.\n\t\t\t\t\t\t\t     client)))\n\t\t\t\t\t\tc = d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (c == NULL) {\n\t\t\tloglog(RC_LOG_SERIOUS, \"initial parent SA message received on %s:%u\"\n\t\t\t       \" but no connection has been authorized%s%s\",\n\t\t\t       ip_str(\n\t\t\t\t       &md->iface->ip_addr),\n\t\t\t       ntohs(portof(&md->iface->ip_addr)),\n\t\t\t       (policy != LEMPTY) ? \" with policy=\" : \"\",\n\t\t\t       (policy !=\n\t\t\t\tLEMPTY) ? bitnamesof(sa_policy_bit_names,\n\t\t\t\t\t\t     policy) : \"\");\n\t\t\treturn STF_FAIL + v2N_NO_PROPOSAL_CHOSEN;\n\t\t}\n\t\tif (c->kind != CK_TEMPLATE) {\n\t\t\tloglog(RC_LOG_SERIOUS, \"initial parent SA message received on %s:%u\"\n\t\t\t       \" but \\\"%s\\\" forbids connection\",\n\t\t\t       ip_str(\n\t\t\t\t       &md->iface->ip_addr), pluto_port,\n\t\t\t       c->name);\n\t\t\treturn STF_FAIL + v2N_NO_PROPOSAL_CHOSEN;\n\t\t}\n\t\tc = rw_instantiate(c, &md->sender, NULL, NULL);\n\n\t} else {\n\t\t/* we found a non-wildcard conn. double check if it needs instantiation anyway (eg vnet=) */\n\t\t/* vnet=/vhost= should have set CK_TEMPLATE on connection loading */\n\t\tif ((c->kind == CK_TEMPLATE) && c->spd.that.virt) {\n\t\t\tDBG(DBG_CONTROL,\n\t\t\t    DBG_log(\n\t\t\t\t    \"local endpoint has virt (vnet/vhost) set without wildcards - needs instantiation\"));\n\t\t\tc = rw_instantiate(c, &md->sender, NULL, NULL);\n\t\t} else if ((c->kind == CK_TEMPLATE) &&\n\t\t\t   (c->policy & POLICY_IKEV2_ALLOW_NARROWING)) {\n\t\t\tDBG(DBG_CONTROL,\n\t\t\t    DBG_log(\n\t\t\t\t    \"local endpoint has narrowing=yes - needs instantiation\"));\n\t\t\tc = rw_instantiate(c, &md->sender, NULL, NULL);\n\t\t}\n\t}\n\n\tDBG_log(\"found connection: %s\\n\", c ? c->name : \"<none>\");\n\n\tif (!st) {\n\t\tst = new_state();\n\t\t/* set up new state */\n\t\tmemcpy(st->st_icookie, md->hdr.isa_icookie, COOKIE_SIZE);\n\t\t/* initialize_new_state expects valid icookie/rcookie values, so create it now */\n\t\tget_cookie(FALSE, st->st_rcookie, COOKIE_SIZE, &md->sender);\n\t\tinitialize_new_state(st, c, policy, 0, NULL_FD,\n\t\t\t\t     pcim_stranger_crypto);\n\t\tst->st_ikev2 = TRUE;\n\t\tchange_state(st, STATE_PARENT_R1);\n\t\tst->st_msgid_lastack = INVALID_MSGID;\n\t\tst->st_msgid_nextuse = 0;\n\n\t\tmd->st = st;\n\t\tmd->from_state = STATE_IKEv2_BASE;\n\t}\n\n\t/* check,as a responder, are we under dos attack or not\n\t * if yes go to 6 message exchange mode. it is a config option for now.\n\t * TBD set force_busy dynamically\n\t * Paul: Can we check for STF_TOOMUCHCRYPTO ?\n\t */\n\tif (force_busy == TRUE) {\n\t\tu_char dcookie[SHA1_DIGEST_SIZE];\n\t\tchunk_t dc;\n\t\tikev2_get_dcookie( dcookie, st->st_ni, &md->sender,\n\t\t\t\t   st->st_icookie);\n\t\tdc.ptr = dcookie;\n\t\tdc.len = SHA1_DIGEST_SIZE;\n\n\t\t/* check if I1 packet contian KE and a v2N payload with type COOKIE */\n\t\tif ( md->chain[ISAKMP_NEXT_v2KE] &&\n\t\t     md->chain[ISAKMP_NEXT_v2N] &&\n\t\t     (md->chain[ISAKMP_NEXT_v2N]->payload.v2n.isan_type ==\n\t\t      v2N_COOKIE)) {\n\t\t\tu_int8_t spisize;\n\t\t\tconst pb_stream *dc_pbs;\n\t\t\tchunk_t blob;\n\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t    DBG_log(\"received a DOS cookie in I1 verify it\"));\n\t\t\t/* we received dcookie we send earlier verify it */\n\t\t\tspisize =\n\t\t\t\tmd->chain[ISAKMP_NEXT_v2N]->payload.v2n.\n\t\t\t\tisan_spisize;\n\t\t\tdc_pbs = &md->chain[ISAKMP_NEXT_v2N]->pbs;\n\t\t\tblob.ptr = dc_pbs->cur + spisize;\n\t\t\tblob.len = pbs_left(dc_pbs) - spisize;\n\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t    DBG_dump_chunk(\"dcookie received in I1 Packet\",\n\t\t\t\t\t   blob);\n\t\t\t    DBG_dump(\"dcookie computed\", dcookie,\n\t\t\t\t     SHA1_DIGEST_SIZE));\n\n\t\t\tif (memcmp(blob.ptr, dcookie, SHA1_DIGEST_SIZE) != 0) {\n\t\t\t\tlibreswan_log(\n\t\t\t\t\t\"mismatch in DOS v2N_COOKIE,send a new one\");\n\t\t\t\tSEND_NOTIFICATION_AA(v2N_COOKIE, &dc);\n\t\t\t\treturn STF_FAIL + v2N_INVALID_IKE_SPI;\n\t\t\t}\n\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t    DBG_log(\"dcookie received match with computed one\"));\n\t\t} else {\n\t\t\t/* we are under DOS attack I1 contains no DOS COOKIE */\n\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t    DBG_log(\n\t\t\t\t    \"busy mode on. receieved I1 without a valid dcookie\");\n\t\t\t    DBG_log(\"send a dcookie and forget this state\"));\n\t\t\tSEND_NOTIFICATION_AA(v2N_COOKIE, &dc);\n\t\t\treturn STF_FAIL;\n\t\t}\n\t} else {\n\t\tDBG(DBG_CONTROLMORE,\n\t\t    DBG_log(\"will not send/process a dcookie\"));\n\n\t}\n\n\t/*\n\t * We have to agree to the DH group before we actually know who\n\t * we are talking to.   If we support the group, we use it.\n\t *\n\t * It is really too hard here to go through all the possible policies\n\t * that might permit this group.  If we think we are being DOS'ed\n\t * then we should demand a cookie.\n \t */\n \t{\n \t\tstruct ikev2_ke *ke;\n \t\tke = &md->chain[ISAKMP_NEXT_v2KE]->payload.v2ke;\n \n \t\tst->st_oakley.group = lookup_group(ke->isak_group);\n \t\tif (st->st_oakley.group == NULL) {\n\t\t\tchar fromname[ADDRTOT_BUF];\n\t\t\taddrtot(&md->sender, 0, fromname, ADDRTOT_BUF);\n \t\t\tlibreswan_log(\n \t\t\t\t\"rejecting I1 from %s:%u, invalid DH group=%u\",\n \t\t\t\tfromname, md->sender_port,\n \t\t\t\tke->isak_group);\n\t\t\treturn v2N_INVALID_KE_PAYLOAD;\n \t\t}\n \t}\n \n\t/* now. we need to go calculate the nonce, and the KE */\n\t{\n\t\tstruct ke_continuation *ke = alloc_thing(\n\t\t\tstruct ke_continuation,\n\t\t\t\"ikev2_inI1outR1 KE\");\n\t\tstf_status e;\n\n\t\tke->md = md;\n\t\tset_suspended(st, ke->md);\n\n\t\tif (!st->st_sec_in_use) {\n\t\t\tpcrc_init(&ke->ke_pcrc);\n\t\t\tke->ke_pcrc.pcrc_func =\n\t\t\t\tikev2_parent_inI1outR1_continue;\n\t\t\te = build_ke(&ke->ke_pcrc, st, st->st_oakley.group,\n\t\t\t\t     pcim_stranger_crypto);\n\t\t\tif (e != STF_SUSPEND && e != STF_INLINE) {\n\t\t\t\tloglog(RC_CRYPTOFAILED, \"system too busy\");\n\t\t\t\tdelete_state(st);\n\t\t\t}\n\t\t} else {\n\t\t\te =\n\t\t\t\tikev2_parent_inI1outR1_tail((struct\n\t\t\t\t\t\t\t     pluto_crypto_req_cont\n\t\t\t\t\t\t\t     *)ke,\n\t\t\t\t\t\t\t    NULL);\n\t\t}\n\n\t\treset_globals();\n\n\t\treturn e;\n\t}\n}\n", "target": 1, "idx": 179646}
{"func": "int kvm_fix_hypercall(struct kvm_vcpu *vcpu)\n{\n\tchar instruction[3];\n\tunsigned long rip = kvm_rip_read(vcpu);\n\n\t/*\n\t * Blow out the MMU to ensure that no other VCPU has an active mapping\n\t * to ensure that the updated hypercall appears atomically across all\n\t * VCPUs.\n\t */\n\tkvm_mmu_zap_all(vcpu->kvm);\n\n\tkvm_x86_ops->patch_hypercall(vcpu, instruction);\n\n\treturn emulator_write_emulated(rip, instruction, 3, NULL, vcpu);\n}\n", "target": 0, "idx": 41379}
{"func": "bool FrameView::updateWidgets()\n{\n    ASSERT(!m_widgetUpdateSet.isEmpty());\n    if (m_nestedLayoutCount > 1 || m_widgetUpdateSet.isEmpty())\n        return true;\n\n    EmbeddedObjectSet objects;\n    objects.swap(m_widgetUpdateSet);\n\n    for (EmbeddedObjectSet::iterator it = objects.begin(); it != objects.end(); ++it) {\n        RenderEmbeddedObject& object = **it;\n        HTMLPlugInElement* element = toHTMLPlugInElement(object.node());\n\n        if (!element)\n            continue;\n\n        if (object.showsUnavailablePluginIndicator())\n            continue;\n\n        if (element->needsWidgetUpdate())\n            element->updateWidget();\n        object.updateWidgetPosition();\n\n        m_widgetUpdateSet.remove(&object);\n    }\n\n    return m_widgetUpdateSet.isEmpty();\n}\n", "target": 0, "idx": 128370}
{"func": "MagickExport MagickBooleanType AnnotateImage(Image *image,\n  const DrawInfo *draw_info,ExceptionInfo *exception)\n{\n  char\n    *p,\n    primitive[MagickPathExtent],\n    *text,\n    **textlist;\n\n  DrawInfo\n    *annotate,\n    *annotate_info;\n\n  GeometryInfo\n    geometry_info;\n\n  MagickBooleanType\n    status;\n\n  PointInfo\n    offset;\n\n  RectangleInfo\n    geometry;\n\n  register ssize_t\n    i;\n\n  TypeMetric\n    metrics;\n\n  size_t\n    height,\n    number_lines;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(draw_info != (DrawInfo *) NULL);\n  assert(draw_info->signature == MagickCoreSignature);\n  if (draw_info->text == (char *) NULL)\n    return(MagickFalse);\n  if (*draw_info->text == '\\0')\n    return(MagickTrue);\n  annotate=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  text=annotate->text;\n  annotate->text=(char *) NULL;\n  annotate_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  number_lines=1;\n  for (p=text; *p != '\\0'; p++)\n    if (*p == '\\n')\n       number_lines++;\n   textlist=AcquireQuantumMemory(number_lines+1,sizeof(*textlist));\n   if (textlist == (char **) NULL)\n    return(MagickFalse);\n   p=text;\n   for (i=0; i < number_lines; i++)\n   {\n    char\n      *q;\n\n    textlist[i]=p;\n    for (q=p; *q != '\\0'; q++)\n      if ((*q == '\\r') || (*q == '\\n'))\n        break;\n    if (*q == '\\r')\n      {\n        *q='\\0';\n        q++;\n      }\n    *q='\\0';\n    p=q+1;\n  }\n  textlist[i]=(char *) NULL;\n  SetGeometry(image,&geometry);\n  SetGeometryInfo(&geometry_info);\n  if (annotate_info->geometry != (char *) NULL)\n    {\n      (void) ParsePageGeometry(image,annotate_info->geometry,&geometry,\n        exception);\n       (void) ParseGeometry(annotate_info->geometry,&geometry_info);\n     }\n   if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    return(MagickFalse);\n   if (IsGrayColorspace(image->colorspace) != MagickFalse)\n     (void) SetImageColorspace(image,sRGBColorspace,exception);\n   status=MagickTrue;\n  (void) memset(&metrics,0,sizeof(metrics));\n  for (i=0; textlist[i] != (char *) NULL; i++)\n  {\n    if (*textlist[i] == '\\0')\n      continue;\n    /*\n      Position text relative to image.\n    */\n    annotate_info->affine.tx=geometry_info.xi-image->page.x;\n    annotate_info->affine.ty=geometry_info.psi-image->page.y;\n    (void) CloneString(&annotate->text,textlist[i]);\n    if ((metrics.width == 0) || (annotate->gravity != NorthWestGravity))\n      (void) GetTypeMetrics(image,annotate,&metrics,exception);\n    height=(ssize_t) (metrics.ascent-metrics.descent+\n      draw_info->interline_spacing+0.5);\n    switch (annotate->gravity)\n    {\n      case UndefinedGravity:\n      default:\n      {\n        offset.x=annotate_info->affine.tx+i*annotate_info->affine.ry*height;\n        offset.y=annotate_info->affine.ty+i*annotate_info->affine.sy*height;\n        break;\n      }\n      case NorthWestGravity:\n      {\n        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+i*\n          annotate_info->affine.ry*height+annotate_info->affine.ry*\n          (metrics.ascent+metrics.descent);\n        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+i*\n          annotate_info->affine.sy*height+annotate_info->affine.sy*\n          metrics.ascent;\n        break;\n      }\n      case NorthGravity:\n      {\n        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+\n          geometry.width/2.0+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width/2.0+annotate_info->affine.ry*\n          (metrics.ascent+metrics.descent);\n        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+i*\n          annotate_info->affine.sy*height+annotate_info->affine.sy*\n          metrics.ascent-annotate_info->affine.rx*metrics.width/2.0;\n        break;\n      }\n      case NorthEastGravity:\n      {\n        offset.x=(geometry.width == 0 ? 1.0 : -1.0)*annotate_info->affine.tx+\n          geometry.width+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width+annotate_info->affine.ry*\n          (metrics.ascent+metrics.descent)-1.0;\n        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+i*\n          annotate_info->affine.sy*height+annotate_info->affine.sy*\n          metrics.ascent-annotate_info->affine.rx*metrics.width;\n        break;\n      }\n      case WestGravity:\n      {\n        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+i*\n          annotate_info->affine.ry*height+annotate_info->affine.ry*\n          (metrics.ascent+metrics.descent-(number_lines-1.0)*height)/2.0;\n        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+\n          geometry.height/2.0+i*annotate_info->affine.sy*height+\n          annotate_info->affine.sy*(metrics.ascent+metrics.descent-\n          (number_lines-1.0)*height)/2.0;\n        break;\n      }\n      case CenterGravity:\n      {\n        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+\n          geometry.width/2.0+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width/2.0+annotate_info->affine.ry*\n          (metrics.ascent+metrics.descent-(number_lines-1.0)*height)/2.0;\n        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+\n          geometry.height/2.0+i*annotate_info->affine.sy*height-\n          annotate_info->affine.rx*metrics.width/2.0+annotate_info->affine.sy*\n          (metrics.ascent+metrics.descent-(number_lines-1.0)*height)/2.0;\n        break;\n      }\n      case EastGravity:\n      {\n        offset.x=(geometry.width == 0 ? 1.0 : -1.0)*annotate_info->affine.tx+\n          geometry.width+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width+\n          annotate_info->affine.ry*(metrics.ascent+metrics.descent-\n          (number_lines-1.0)*height)/2.0-1.0;\n        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+\n          geometry.height/2.0+i*annotate_info->affine.sy*height-\n          annotate_info->affine.rx*metrics.width+\n          annotate_info->affine.sy*(metrics.ascent+metrics.descent-\n          (number_lines-1.0)*height)/2.0;\n        break;\n      }\n      case SouthWestGravity:\n      {\n        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+i*\n          annotate_info->affine.ry*height-annotate_info->affine.ry*\n          (number_lines-1.0)*height;\n        offset.y=(geometry.height == 0 ? 1.0 : -1.0)*annotate_info->affine.ty+\n          geometry.height+i*annotate_info->affine.sy*height-\n          annotate_info->affine.sy*(number_lines-1.0)*height+metrics.descent;\n        break;\n      }\n      case SouthGravity:\n      {\n        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+\n          geometry.width/2.0+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width/2.0-\n          annotate_info->affine.ry*(number_lines-1.0)*height/2.0;\n        offset.y=(geometry.height == 0 ? 1.0 : -1.0)*annotate_info->affine.ty+\n          geometry.height+i*annotate_info->affine.sy*height-\n          annotate_info->affine.rx*metrics.width/2.0-\n          annotate_info->affine.sy*(number_lines-1.0)*height+metrics.descent;\n        break;\n      }\n      case SouthEastGravity:\n      {\n        offset.x=(geometry.width == 0 ? 1.0 : -1.0)*annotate_info->affine.tx+\n          geometry.width+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width-\n          annotate_info->affine.ry*(number_lines-1.0)*height-1.0;\n        offset.y=(geometry.height == 0 ? 1.0 : -1.0)*annotate_info->affine.ty+\n          geometry.height+i*annotate_info->affine.sy*height-\n          annotate_info->affine.rx*metrics.width-\n          annotate_info->affine.sy*(number_lines-1.0)*height+metrics.descent;\n        break;\n      }\n    }\n    switch (annotate->align)\n    {\n      case LeftAlign:\n      {\n        offset.x=annotate_info->affine.tx+i*annotate_info->affine.ry*height;\n        offset.y=annotate_info->affine.ty+i*annotate_info->affine.sy*height;\n        break;\n      }\n      case CenterAlign:\n      {\n        offset.x=annotate_info->affine.tx+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width/2.0;\n        offset.y=annotate_info->affine.ty+i*annotate_info->affine.sy*height-\n          annotate_info->affine.rx*metrics.width/2.0;\n        break;\n      }\n      case RightAlign:\n      {\n        offset.x=annotate_info->affine.tx+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width;\n        offset.y=annotate_info->affine.ty+i*annotate_info->affine.sy*height-\n          annotate_info->affine.rx*metrics.width;\n        break;\n      }\n      default:\n        break;\n    }\n    if (draw_info->undercolor.alpha != TransparentAlpha)\n      {\n        DrawInfo\n          *undercolor_info;\n\n        /*\n          Text box.\n        */\n        undercolor_info=CloneDrawInfo((ImageInfo *) NULL,(DrawInfo *) NULL);\n        undercolor_info->fill=draw_info->undercolor;\n        undercolor_info->affine=draw_info->affine;\n        undercolor_info->affine.tx=offset.x-draw_info->affine.ry*metrics.ascent;\n        undercolor_info->affine.ty=offset.y-draw_info->affine.sy*metrics.ascent;\n        (void) FormatLocaleString(primitive,MagickPathExtent,\n          \"rectangle 0.0,0.0 %g,%g\",metrics.origin.x,(double) height);\n        (void) CloneString(&undercolor_info->primitive,primitive);\n        (void) DrawImage(image,undercolor_info,exception);\n        (void) DestroyDrawInfo(undercolor_info);\n      }\n    annotate_info->affine.tx=offset.x;\n    annotate_info->affine.ty=offset.y;\n    (void) FormatLocaleString(primitive,MagickPathExtent,\"stroke-width %g \"\n      \"line 0,0 %g,0\",metrics.underline_thickness,metrics.width);\n    if (annotate->decorate == OverlineDecoration)\n      {\n        annotate_info->affine.ty-=(draw_info->affine.sy*(metrics.ascent+\n          metrics.descent-metrics.underline_position));\n        (void) CloneString(&annotate_info->primitive,primitive);\n        (void) DrawImage(image,annotate_info,exception);\n      }\n    else\n      if (annotate->decorate == UnderlineDecoration)\n        {\n          annotate_info->affine.ty-=(draw_info->affine.sy*\n            metrics.underline_position);\n          (void) CloneString(&annotate_info->primitive,primitive);\n          (void) DrawImage(image,annotate_info,exception);\n        }\n    /*\n      Annotate image with text.\n    */\n    status=RenderType(image,annotate,&offset,&metrics,exception);\n    if (status == MagickFalse)\n      break;\n    if (annotate->decorate == LineThroughDecoration)\n      {\n        annotate_info->affine.ty-=(draw_info->affine.sy*(height+\n          metrics.underline_position+metrics.descent)/2.0);\n        (void) CloneString(&annotate_info->primitive,primitive);\n        (void) DrawImage(image,annotate_info,exception);\n      }\n  }\n  /*\n    Relinquish resources.\n  */\n  annotate_info=DestroyDrawInfo(annotate_info);\n  annotate=DestroyDrawInfo(annotate);\n  textlist=(char **) RelinquishMagickMemory(textlist);\n  return(status);\n}\n", "target": 1, "idx": 182772}
{"func": "LogoService::LogoService(\n    const base::FilePath& cache_directory,\n    TemplateURLService* template_url_service,\n    std::unique_ptr<image_fetcher::ImageDecoder> image_decoder,\n    scoped_refptr<net::URLRequestContextGetter> request_context_getter,\n    bool use_gray_background)\n    : cache_directory_(cache_directory),\n      template_url_service_(template_url_service),\n      request_context_getter_(request_context_getter),\n      use_gray_background_(use_gray_background),\n      image_decoder_(std::move(image_decoder)) {}\n", "target": 1, "idx": 185833}
{"func": "static int v9fs_xattr_fid_clunk(V9fsPDU *pdu, V9fsFidState *fidp)\n{\n    int retval = 0;\n\n    if (fidp->fs.xattr.copied_len == -1) {\n        /* getxattr/listxattr fid */\n        goto free_value;\n    }\n    /*\n     * if this is fid for setxattr. clunk should\n     * result in setxattr localcall\n     */\n    if (fidp->fs.xattr.len != fidp->fs.xattr.copied_len) {\n        /* clunk after partial write */\n        retval = -EINVAL;\n        goto free_out;\n    }\n    if (fidp->fs.xattr.len) {\n        retval = v9fs_co_lsetxattr(pdu, &fidp->path, &fidp->fs.xattr.name,\n                                   fidp->fs.xattr.value,\n                                   fidp->fs.xattr.len,\n                                   fidp->fs.xattr.flags);\n    } else {\n        retval = v9fs_co_lremovexattr(pdu, &fidp->path, &fidp->fs.xattr.name);\n    }\nfree_out:\n    v9fs_string_free(&fidp->fs.xattr.name);\nfree_value:\n    g_free(fidp->fs.xattr.value);\n    return retval;\n}\n", "target": 0, "idx": 8243}
{"func": "static void VoidMethodBooleanArgMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  ExceptionState exception_state(info.GetIsolate(), ExceptionState::kExecutionContext, \"TestObject\", \"voidMethodBooleanArg\");\n\n  TestObject* impl = V8TestObject::ToImpl(info.Holder());\n\n  if (UNLIKELY(info.Length() < 1)) {\n    exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));\n    return;\n  }\n\n  bool boolean_arg;\n  boolean_arg = NativeValueTraits<IDLBoolean>::NativeValue(info.GetIsolate(), info[0], exception_state);\n  if (exception_state.HadException())\n    return;\n\n  impl->voidMethodBooleanArg(boolean_arg);\n}\n", "target": 0, "idx": 148032}
{"func": "int ecc_mul2add(ecc_point* A, mp_int* kA,\n                ecc_point* B, mp_int* kB,\n                ecc_point* C, mp_int* a, mp_int* modulus, void* heap)\n{\n   int  idx1 = -1, idx2 = -1, err = MP_OKAY, mpInit = 0;\n   mp_digit mp;\n   mp_int   mu;\n\n   err = mp_init(&mu);\n   if (err != MP_OKAY)\n       return err;\n\n#ifndef HAVE_THREAD_LS\n   if (initMutex == 0) {\n        wc_InitMutex(&ecc_fp_lock);\n        initMutex = 1;\n   }\n   if (wc_LockMutex(&ecc_fp_lock) != 0)\n      return BAD_MUTEX_E;\n#endif /* HAVE_THREAD_LS */\n\n      /* find point */\n      idx1 = find_base(A);\n\n      /* no entry? */\n      if (idx1 == -1) {\n         /* find hole and add it */\n         if ((idx1 = find_hole()) >= 0) {\n            err = add_entry(idx1, A);\n         }\n      }\n      if (err == MP_OKAY && idx1 != -1) {\n         /* increment LRU */\n         ++(fp_cache[idx1].lru_count);\n      }\n\n      if (err == MP_OKAY)\n        /* find point */\n        idx2 = find_base(B);\n\n      if (err == MP_OKAY) {\n        /* no entry? */\n        if (idx2 == -1) {\n           /* find hole and add it */\n           if ((idx2 = find_hole()) >= 0)\n              err = add_entry(idx2, B);\n         }\n      }\n\n      if (err == MP_OKAY && idx2 != -1) {\n         /* increment LRU */\n         ++(fp_cache[idx2].lru_count);\n      }\n\n      if (err == MP_OKAY) {\n        /* if it's 2 build the LUT, if it's higher just use the LUT */\n        if (idx1 >= 0 && fp_cache[idx1].lru_count == 2) {\n           /* compute mp */\n           err = mp_montgomery_setup(modulus, &mp);\n\n           if (err == MP_OKAY) {\n             mpInit = 1;\n             err = mp_montgomery_calc_normalization(&mu, modulus);\n           }\n\n           if (err == MP_OKAY)\n             /* build the LUT */\n               err = build_lut(idx1, a, modulus, mp, &mu);\n        }\n      }\n\n      if (err == MP_OKAY) {\n        /* if it's 2 build the LUT, if it's higher just use the LUT */\n        if (idx2 >= 0 && fp_cache[idx2].lru_count == 2) {\n           if (mpInit == 0) {\n                /* compute mp */\n                err = mp_montgomery_setup(modulus, &mp);\n                if (err == MP_OKAY) {\n                    mpInit = 1;\n                    err = mp_montgomery_calc_normalization(&mu, modulus);\n                }\n            }\n\n            if (err == MP_OKAY)\n            /* build the LUT */\n              err = build_lut(idx2, a, modulus, mp, &mu);\n        }\n      }\n\n\n      if (err == MP_OKAY) {\n        if (idx1 >=0 && idx2 >= 0 && fp_cache[idx1].lru_count >= 2 &&\n                                     fp_cache[idx2].lru_count >= 2) {\n           if (mpInit == 0) {\n              /* compute mp */\n              err = mp_montgomery_setup(modulus, &mp);\n           }\n           if (err == MP_OKAY)\n             err = accel_fp_mul2add(idx1, idx2, kA, kB, C, a, modulus, mp);\n        } else {\n           err = normal_ecc_mul2add(A, kA, B, kB, C, a, modulus, heap);\n        }\n    }\n\n#ifndef HAVE_THREAD_LS\n    wc_UnLockMutex(&ecc_fp_lock);\n#endif /* HAVE_THREAD_LS */\n    mp_clear(&mu);\n\n    return err;\n}\n", "target": 0, "idx": 81838}
{"func": "EXPORTED int mboxlist_update(mbentry_t *mbentry, int localonly)\n{\n    int r = 0, r2 = 0;\n    struct txn *tid = NULL;\n\n    r = mboxlist_update_entry(mbentry->name, mbentry, &tid);\n\n    if (!r)\n        mboxname_setmodseq(mbentry->name, mbentry->foldermodseq, mbentry->mbtype, /*dofolder*/1);\n\n    /* commit the change to mupdate */\n    if (!r && !localonly && config_mupdate_server) {\n        mupdate_handle *mupdate_h = NULL;\n\n        r = mupdate_connect(config_mupdate_server, NULL, &mupdate_h, NULL);\n        if (r) {\n            syslog(LOG_ERR,\n                   \"cannot connect to mupdate server for update of '%s'\",\n                   mbentry->name);\n        } else {\n            char *location = strconcat(config_servername, \"!\",\n                                       mbentry->partition, (char *)NULL);\n            r = mupdate_activate(mupdate_h, mbentry->name,\n                                 location, mbentry->acl);\n            free(location);\n            if (r) {\n                syslog(LOG_ERR,\n                       \"MUPDATE: can't update mailbox entry for '%s'\",\n                       mbentry->name);\n            }\n        }\n        mupdate_disconnect(&mupdate_h);\n    }\n\n    if (tid) {\n        if (r) {\n            r2 = cyrusdb_abort(mbdb, tid);\n        } else {\n            r2 = cyrusdb_commit(mbdb, tid);\n        }\n    }\n\n    if (r2) {\n        syslog(LOG_ERR, \"DBERROR: error %s txn in mboxlist_update: %s\",\n               r ? \"aborting\" : \"commiting\", cyrusdb_strerror(r2));\n    }\n\n    return r;\n}\n", "target": 0, "idx": 61301}
{"func": " bool MockRenderThread::OnMessageReceived(const IPC::Message& msg) {\n   sink_.OnMessageReceived(msg);\n\n  bool handled = true;\n   bool msg_is_ok = true;\n   IPC_BEGIN_MESSAGE_MAP_EX(MockRenderThread, msg, msg_is_ok)\n     IPC_MESSAGE_HANDLER(ViewHostMsg_CreateWidget, OnMsgCreateWidget)\n     IPC_MESSAGE_UNHANDLED(handled = false)\n   IPC_END_MESSAGE_MAP_EX()\n   return handled;\n}\n", "target": 1, "idx": 184715}
{"func": "static inline int tx_work_todo(struct xen_netbk *netbk)\n{\n\n\tif (((nr_pending_reqs(netbk) + MAX_SKB_FRAGS) < MAX_PENDING_REQS) &&\n\t\t\t!list_empty(&netbk->net_schedule_list))\n\t\treturn 1;\n\n\treturn 0;\n}\n", "target": 0, "idx": 34000}
{"func": "static void loop_config_discard(struct loop_device *lo)\n{\n\tstruct file *file = lo->lo_backing_file;\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct request_queue *q = lo->lo_queue;\n\n\t/*\n\t * We use punch hole to reclaim the free space used by the\n\t * image a.k.a. discard. However we do not support discard if\n\t * encryption is enabled, because it may give an attacker\n\t * useful information.\n\t */\n\tif ((!file->f_op->fallocate) ||\n\t    lo->lo_encrypt_key_size) {\n\t\tq->limits.discard_granularity = 0;\n\t\tq->limits.discard_alignment = 0;\n\t\tblk_queue_max_discard_sectors(q, 0);\n\t\tblk_queue_max_write_zeroes_sectors(q, 0);\n\t\tqueue_flag_clear_unlocked(QUEUE_FLAG_DISCARD, q);\n\t\treturn;\n\t}\n\n\tq->limits.discard_granularity = inode->i_sb->s_blocksize;\n\tq->limits.discard_alignment = 0;\n\n\tblk_queue_max_discard_sectors(q, UINT_MAX >> 9);\n\tblk_queue_max_write_zeroes_sectors(q, UINT_MAX >> 9);\n\tqueue_flag_set_unlocked(QUEUE_FLAG_DISCARD, q);\n}\n", "target": 0, "idx": 84719}
{"func": "void jsB_initnumber(js_State *J)\n{\n\tJ->Number_prototype->u.number = 0;\n\n\tjs_pushobject(J, J->Number_prototype);\n\t{\n\t\tjsB_propf(J, \"Number.prototype.valueOf\", Np_valueOf, 0);\n\t\tjsB_propf(J, \"Number.prototype.toString\", Np_toString, 1);\n\t\tjsB_propf(J, \"Number.prototype.toLocaleString\", Np_toString, 0);\n\t\tjsB_propf(J, \"Number.prototype.toFixed\", Np_toFixed, 1);\n\t\tjsB_propf(J, \"Number.prototype.toExponential\", Np_toExponential, 1);\n\t\tjsB_propf(J, \"Number.prototype.toPrecision\", Np_toPrecision, 1);\n\t}\n\tjs_newcconstructor(J, jsB_Number, jsB_new_Number, \"Number\", 0); /* 1 */\n\t{\n\t\tjsB_propn(J, \"MAX_VALUE\", 1.7976931348623157e+308);\n\t\tjsB_propn(J, \"MIN_VALUE\", 5e-324);\n\t\tjsB_propn(J, \"NaN\", NAN);\n\t\tjsB_propn(J, \"NEGATIVE_INFINITY\", -INFINITY);\n\t\tjsB_propn(J, \"POSITIVE_INFINITY\", INFINITY);\n\t}\n\tjs_defglobal(J, \"Number\", JS_DONTENUM);\n}\n", "target": 0, "idx": 90743}
{"func": "static int pppol2tp_session_setsockopt(struct sock *sk,\n\t\t\t\t       struct l2tp_session *session,\n\t\t\t\t       int optname, int val)\n{\n\tint err = 0;\n\tstruct pppol2tp_session *ps = l2tp_session_priv(session);\n\n\tswitch (optname) {\n\tcase PPPOL2TP_SO_RECVSEQ:\n\t\tif ((val != 0) && (val != 1)) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tsession->recv_seq = val ? -1 : 0;\n\t\tl2tp_info(session, PPPOL2TP_MSG_CONTROL,\n\t\t\t  \"%s: set recv_seq=%d\\n\",\n\t\t\t  session->name, session->recv_seq);\n\t\tbreak;\n\n\tcase PPPOL2TP_SO_SENDSEQ:\n\t\tif ((val != 0) && (val != 1)) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tsession->send_seq = val ? -1 : 0;\n\t\t{\n\t\t\tstruct sock *ssk      = ps->sock;\n\t\t\tstruct pppox_sock *po = pppox_sk(ssk);\n\t\t\tpo->chan.hdrlen = val ? PPPOL2TP_L2TP_HDR_SIZE_SEQ :\n\t\t\t\tPPPOL2TP_L2TP_HDR_SIZE_NOSEQ;\n\t\t}\n\t\tl2tp_session_set_header_len(session, session->tunnel->version);\n\t\tl2tp_info(session, PPPOL2TP_MSG_CONTROL,\n\t\t\t  \"%s: set send_seq=%d\\n\",\n\t\t\t  session->name, session->send_seq);\n\t\tbreak;\n\n\tcase PPPOL2TP_SO_LNSMODE:\n\t\tif ((val != 0) && (val != 1)) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tsession->lns_mode = val ? -1 : 0;\n\t\tl2tp_info(session, PPPOL2TP_MSG_CONTROL,\n\t\t\t  \"%s: set lns_mode=%d\\n\",\n\t\t\t  session->name, session->lns_mode);\n\t\tbreak;\n\n\tcase PPPOL2TP_SO_DEBUG:\n\t\tsession->debug = val;\n\t\tl2tp_info(session, PPPOL2TP_MSG_CONTROL, \"%s: set debug=%x\\n\",\n\t\t\t  session->name, session->debug);\n\t\tbreak;\n\n\tcase PPPOL2TP_SO_REORDERTO:\n\t\tsession->reorder_timeout = msecs_to_jiffies(val);\n\t\tl2tp_info(session, PPPOL2TP_MSG_CONTROL,\n\t\t\t  \"%s: set reorder_timeout=%d\\n\",\n\t\t\t  session->name, session->reorder_timeout);\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n", "target": 0, "idx": 36425}
{"func": "xsltReverseCompMatch(xsltParserContextPtr ctxt, xsltCompMatchPtr comp) {\n    int i = 0;\n    int j = comp->nbStep - 1;\n\n    while (j > i) {\n\tregister xmlChar *tmp;\n\tregister xsltOp op;\n\tregister xmlXPathCompExprPtr expr;\n\tregister int t;\n\n\ttmp = comp->steps[i].value;\n\tcomp->steps[i].value = comp->steps[j].value;\n\tcomp->steps[j].value = tmp;\n\ttmp = comp->steps[i].value2;\n\tcomp->steps[i].value2 = comp->steps[j].value2;\n\tcomp->steps[j].value2 = tmp;\n\ttmp = comp->steps[i].value3;\n\tcomp->steps[i].value3 = comp->steps[j].value3;\n\tcomp->steps[j].value3 = tmp;\n\top = comp->steps[i].op;\n\tcomp->steps[i].op = comp->steps[j].op;\n\tcomp->steps[j].op = op;\n\texpr = comp->steps[i].comp;\n\tcomp->steps[i].comp = comp->steps[j].comp;\n\tcomp->steps[j].comp = expr;\n\tt = comp->steps[i].previousExtra;\n\tcomp->steps[i].previousExtra = comp->steps[j].previousExtra;\n\tcomp->steps[j].previousExtra = t;\n\tt = comp->steps[i].indexExtra;\n\tcomp->steps[i].indexExtra = comp->steps[j].indexExtra;\n\tcomp->steps[j].indexExtra = t;\n\tt = comp->steps[i].lenExtra;\n\tcomp->steps[i].lenExtra = comp->steps[j].lenExtra;\n\tcomp->steps[j].lenExtra = t;\n\tj--;\n\ti++;\n    }\n     xsltCompMatchAdd(ctxt, comp, XSLT_OP_END, NULL, NULL, 0);\n \n     /*\n     * detect consecutive XSLT_OP_PREDICATE indicating a direct\n     * matching should be done.\n      */\n     for (i = 0;i < comp->nbStep - 1;i++) {\n        if ((comp->steps[i].op == XSLT_OP_PREDICATE) &&\n \t    (comp->steps[i + 1].op == XSLT_OP_PREDICATE)) {\n \n \t    comp->direct = 1;\n\t    if (comp->pattern[0] != '/') {\n\t\txmlChar *query;\n\n\t\tquery = xmlStrdup((const xmlChar *)\"//\");\n\t\tquery = xmlStrcat(query, comp->pattern);\n\n\t\txmlFree((xmlChar *) comp->pattern);\n\t\tcomp->pattern = query;\n\t    }\n\t    break;\n\t}\n    }\n}\n", "target": 1, "idx": 187335}
{"func": "BlackBerry::Platform::String WebPage::textEncoding()\n{\n    Frame* frame = d->focusedOrMainFrame();\n    if (!frame)\n        return \"\";\n\n    Document* document = frame->document();\n    if (!document)\n        return \"\";\n\n    return document->loader()->writer()->encoding();\n}\n", "target": 0, "idx": 111397}
{"func": " void webkitWebViewBaseSetInspectorViewHeight(WebKitWebViewBase* webkitWebViewBase, unsigned height)\n {\n    if (!webkitWebViewBase->priv->inspectorView)\n        return;\n     if (webkitWebViewBase->priv->inspectorViewHeight == height)\n         return;\n     webkitWebViewBase->priv->inspectorViewHeight = height;\n    gtk_widget_queue_resize_no_redraw(GTK_WIDGET(webkitWebViewBase));\n }\n", "target": 1, "idx": 184745}
{"func": "int blockingWrite_helper(int fd, void *buffer, size_t len) {\n return android::blockingWrite(fd, buffer, len);\n}\n", "target": 0, "idx": 175252}
{"func": "   bool CanCommitURL(const GURL& url) {\n    SchemeMap::const_iterator judgment(scheme_policy_.find(url.scheme()));\n    if (judgment != scheme_policy_.end())\n      return judgment->second;\n \n    if (url.SchemeIs(url::kFileScheme)) {\n      base::FilePath path;\n      if (net::FileURLToFilePath(url, &path))\n        return ContainsKey(request_file_set_, path);\n    }\n\n    return false;  // Unmentioned schemes are disallowed.\n  }\n", "target": 1, "idx": 185652}
{"func": "static void enforceRangeLongAttributeAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)\n{\n    TestObjectPython* imp = V8TestObjectPython::toNative(info.Holder());\n    v8SetReturnValueInt(info, imp->enforceRangeLongAttribute());\n}\n", "target": 0, "idx": 131372}
{"func": "static int netlink_sendmsg(struct kiocb *kiocb, struct socket *sock,\n\t\t\t   struct msghdr *msg, size_t len)\n{\n\tstruct sock_iocb *siocb = kiocb_to_siocb(kiocb);\n\tstruct sock *sk = sock->sk;\n\tstruct netlink_sock *nlk = nlk_sk(sk);\n\tstruct sockaddr_nl *addr = msg->msg_name;\n\tu32 dst_pid;\n\tu32 dst_group;\n\tstruct sk_buff *skb;\n\tint err;\n\tstruct scm_cookie scm;\n\n\tif (msg->msg_flags&MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n \tif (NULL == siocb->scm)\n \t\tsiocb->scm = &scm;\n \n\terr = scm_send(sock, msg, siocb->scm);\n \tif (err < 0)\n \t\treturn err;\n \n\tif (msg->msg_namelen) {\n\t\terr = -EINVAL;\n\t\tif (addr->nl_family != AF_NETLINK)\n\t\t\tgoto out;\n\t\tdst_pid = addr->nl_pid;\n\t\tdst_group = ffs(addr->nl_groups);\n\t\terr =  -EPERM;\n\t\tif (dst_group && !netlink_capable(sock, NL_NONROOT_SEND))\n\t\t\tgoto out;\n\t} else {\n\t\tdst_pid = nlk->dst_pid;\n\t\tdst_group = nlk->dst_group;\n\t}\n\n\tif (!nlk->pid) {\n\t\terr = netlink_autobind(sock);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\terr = -EMSGSIZE;\n\tif (len > sk->sk_sndbuf - 32)\n\t\tgoto out;\n\terr = -ENOBUFS;\n\tskb = alloc_skb(len, GFP_KERNEL);\n\tif (skb == NULL)\n\t\tgoto out;\n\n\tNETLINK_CB(skb).pid\t= nlk->pid;\n\tNETLINK_CB(skb).dst_group = dst_group;\n\tmemcpy(NETLINK_CREDS(skb), &siocb->scm->creds, sizeof(struct ucred));\n\n\terr = -EFAULT;\n\tif (memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len)) {\n\t\tkfree_skb(skb);\n\t\tgoto out;\n\t}\n\n\terr = security_netlink_send(sk, skb);\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\tgoto out;\n\t}\n\n\tif (dst_group) {\n\t\tatomic_inc(&skb->users);\n\t\tnetlink_broadcast(sk, skb, dst_pid, dst_group, GFP_KERNEL);\n\t}\n\terr = netlink_unicast(sk, skb, dst_pid, msg->msg_flags&MSG_DONTWAIT);\n\nout:\n\tscm_destroy(siocb->scm);\n\treturn err;\n}\n", "target": 1, "idx": 178750}
{"func": "static void perf_callchain_user_64(struct perf_callchain_entry *entry,\n\t\t\t\t   struct pt_regs *regs)\n{\n\tunsigned long sp, next_sp;\n\tunsigned long next_ip;\n\tunsigned long lr;\n\tlong level = 0;\n\tstruct signal_frame_64 __user *sigframe;\n\tunsigned long __user *fp, *uregs;\n\n\tnext_ip = perf_instruction_pointer(regs);\n\tlr = regs->link;\n \tsp = regs->gpr[1];\n \tperf_callchain_store(entry, next_ip);\n \n\tfor (;;) {\n \t\tfp = (unsigned long __user *) sp;\n \t\tif (!valid_user_sp(sp, 1) || read_user_stack_64(fp, &next_sp))\n \t\t\treturn;\n\t\tif (level > 0 && read_user_stack_64(&fp[2], &next_ip))\n\t\t\treturn;\n\n\t\t/*\n\t\t * Note: the next_sp - sp >= signal frame size check\n\t\t * is true when next_sp < sp, which can happen when\n\t\t * transitioning from an alternate signal stack to the\n\t\t * normal stack.\n\t\t */\n\t\tif (next_sp - sp >= sizeof(struct signal_frame_64) &&\n\t\t    (is_sigreturn_64_address(next_ip, sp) ||\n\t\t     (level <= 1 && is_sigreturn_64_address(lr, sp))) &&\n\t\t    sane_signal_64_frame(sp)) {\n\t\t\t/*\n\t\t\t * This looks like an signal frame\n\t\t\t */\n\t\t\tsigframe = (struct signal_frame_64 __user *) sp;\n\t\t\turegs = sigframe->uc.uc_mcontext.gp_regs;\n\t\t\tif (read_user_stack_64(&uregs[PT_NIP], &next_ip) ||\n\t\t\t    read_user_stack_64(&uregs[PT_LNK], &lr) ||\n\t\t\t    read_user_stack_64(&uregs[PT_R1], &sp))\n\t\t\t\treturn;\n\t\t\tlevel = 0;\n\t\t\tperf_callchain_store(entry, PERF_CONTEXT_USER);\n\t\t\tperf_callchain_store(entry, next_ip);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (level == 0)\n\t\t\tnext_ip = lr;\n\t\tperf_callchain_store(entry, next_ip);\n\t\t++level;\n\t\tsp = next_sp;\n\t}\n}\n", "target": 1, "idx": 179759}
{"func": " static freelist_idx_t next_random_slot(union freelist_init_state *state)\n {\n\treturn (state->list[state->pos++] + state->rand) % state->count;\n }\n", "target": 1, "idx": 181569}
{"func": "g_NPN_MemFlush(uint32_t size)\n{\n  D(bug(\"NPN_MemFlush size=%d\\n\", size));\n  return 0;\n}\n", "target": 0, "idx": 27057}
{"func": "String HTMLInputElement::value() const {\n  switch (input_type_->GetValueMode()) {\n    case ValueMode::kFilename:\n      return input_type_->ValueInFilenameValueMode();\n    case ValueMode::kDefault:\n      return FastGetAttribute(valueAttr);\n    case ValueMode::kDefaultOn: {\n      AtomicString value_string = FastGetAttribute(valueAttr);\n      return value_string.IsNull() ? \"on\" : value_string;\n    }\n    case ValueMode::kValue:\n      return non_attribute_value_;\n  }\n  NOTREACHED();\n  return g_empty_string;\n}\n", "target": 0, "idx": 137033}
{"func": "NO_INLINE JsVar *jspeFactorDelete() {\n  JSP_ASSERT_MATCH(LEX_R_DELETE);\n  JsVar *parent = 0;\n  JsVar *a = jspeFactorMember(jspeFactor(), &parent);\n  JsVar *result = 0;\n  if (JSP_SHOULD_EXECUTE) {\n    bool ok = false;\n    if (jsvIsName(a) && !jsvIsNewChild(a)) {\n      if (!parent && jsvIsChild(execInfo.root, a))\n        parent = jsvLockAgain(execInfo.root);\n\n      if (parent && !jsvIsFunction(parent)) {\n        if (jsvIsArray(parent)) {\n          JsVarInt l = jsvGetArrayLength(parent);\n          jsvRemoveChild(parent, a);\n          jsvSetArrayLength(parent, l, false);\n        } else {\n          jsvRemoveChild(parent, a);\n        }\n        ok = true;\n      }\n    }\n\n    result = jsvNewFromBool(ok);\n  }\n  jsvUnLock2(a, parent);\n  return result;\n}\n", "target": 0, "idx": 82325}
{"func": "chpass_principal3_2_svc(chpass3_arg *arg, struct svc_req *rqstp)\n {\n     static generic_ret              ret;\n     char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n     OM_uint32                       minor_stat;\n     kadm5_server_handle_t           handle;\n     const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ)) {\n        ret.code = chpass_principal_wrapper_3((void *)handle, arg->princ,\n                                              arg->keepold,\n                                              arg->n_ks_tuple,\n                                              arg->ks_tuple,\n                                              arg->pass);\n    } else if (!(CHANGEPW_SERVICE(rqstp)) &&\n               kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                                  ACL_CHANGEPW, arg->princ, NULL)) {\n        ret.code = kadm5_chpass_principal_3((void *)handle, arg->princ,\n                                            arg->keepold,\n                                            arg->n_ks_tuple,\n                                            arg->ks_tuple,\n                                            arg->pass);\n    } else {\n        log_unauth(\"kadm5_chpass_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_CHANGEPW;\n    }\n\n    if(ret.code != KADM5_AUTH_CHANGEPW) {\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_chpass_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n     }\n \n     free(prime_arg);\n     gss_release_buffer(&minor_stat, &client_name);\n     gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n     free_server_handle(handle);\n     return &ret;\n }\n", "target": 1, "idx": 180676}
{"func": "local uLong crc32_combine_(crc1, crc2, len2)\n    uLong crc1;\n    uLong crc2;\n    z_off64_t len2;\n{\n    int n;\n    unsigned long row;\n    unsigned long even[GF2_DIM];    /* even-power-of-two zeros operator */\n    unsigned long odd[GF2_DIM];     /* odd-power-of-two zeros operator */\n\n    /* degenerate case (also disallow negative lengths) */\n    if (len2 <= 0)\n        return crc1;\n\n    /* put operator for one zero bit in odd */\n    odd[0] = 0xedb88320UL;          /* CRC-32 polynomial */\n    row = 1;\n    for (n = 1; n < GF2_DIM; n++) {\n        odd[n] = row;\n        row <<= 1;\n    }\n\n    /* put operator for two zero bits in even */\n    gf2_matrix_square(even, odd);\n\n    /* put operator for four zero bits in odd */\n    gf2_matrix_square(odd, even);\n\n    /* apply len2 zeros to crc1 (first square will put the operator for one\n       zero byte, eight zero bits, in even) */\n    do {\n        /* apply zeros operator for this bit of len2 */\n        gf2_matrix_square(even, odd);\n        if (len2 & 1)\n            crc1 = gf2_matrix_times(even, crc1);\n        len2 >>= 1;\n\n        /* if no more bits set, then done */\n        if (len2 == 0)\n            break;\n\n        /* another iteration of the loop with odd and even swapped */\n        gf2_matrix_square(odd, even);\n        if (len2 & 1)\n            crc1 = gf2_matrix_times(odd, crc1);\n        len2 >>= 1;\n\n        /* if no more bits set, then done */\n    } while (len2 != 0);\n\n    /* return combined crc */\n    crc1 ^= crc2;\n    return crc1;\n}\n", "target": 0, "idx": 72481}
{"func": "static int read_private_key(RSA *rsa)\n{\n\tint r;\n\tsc_path_t path;\n\tsc_file_t *file;\n\tconst sc_acl_entry_t *e;\n\n\tu8 buf[2048], *p = buf;\n\tsize_t bufsize, keysize;\n\n\tr = select_app_df();\n\tif (r)\n\t\treturn 1;\n\tsc_format_path(\"I0012\", &path);\n\tr = sc_select_file(card, &path, &file);\n\tif (r) {\n\t\tfprintf(stderr, \"Unable to select private key file: %s\\n\", sc_strerror(r));\n\t\treturn 2;\n\t}\n \te = sc_file_get_acl_entry(file, SC_AC_OP_READ);\n \tif (e == NULL || e->method == SC_AC_NEVER)\n \t\treturn 10;\n\tbufsize = file->size;\n \tsc_file_free(file);\n \tr = sc_read_binary(card, 0, buf, bufsize, 0);\n \tif (r < 0) {\n\t\tfprintf(stderr, \"Unable to read private key file: %s\\n\", sc_strerror(r));\n\t\treturn 2;\n\t}\n\tbufsize = r;\n\tdo {\n\t\tif (bufsize < 4)\n\t\t\treturn 3;\n\t\tkeysize = (p[0] << 8) | p[1];\n\t\tif (keysize == 0)\n\t\t\tbreak;\n\t\tif (keysize < 3)\n\t\t\treturn 3;\n\t\tif (p[2] == opt_key_num)\n\t\t\tbreak;\n\t\tp += keysize;\n\t\tbufsize -= keysize;\n\t} while (1);\n\tif (keysize == 0) {\n\t\tprintf(\"Key number %d not found.\\n\", opt_key_num);\n\t\treturn 2;\n\t}\n\treturn parse_private_key(p, keysize, rsa);\n}\n", "target": 1, "idx": 182252}
{"func": "header_put_be_8byte (SF_PRIVATE *psf, sf_count_t x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 8)\n\t{\tpsf->header [psf->headindex++] = 0 ;\n\t\tpsf->header [psf->headindex++] = 0 ;\n\t\tpsf->header [psf->headindex++] = 0 ;\n\t\tpsf->header [psf->headindex++] = 0 ;\n\t\tpsf->header [psf->headindex++] = (x >> 24) ;\n\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = x ;\n\t\t} ;\n} /* header_put_be_8byte */\n", "target": 1, "idx": 183221}
{"func": "acc_ctx_hints(OM_uint32 *minor_status,\n\t      gss_ctx_id_t *ctx,\n\t      spnego_gss_cred_id_t spcred,\n\t      gss_buffer_t *mechListMIC,\n\t      OM_uint32 *negState,\n\t      send_token_flag *return_token)\n{\n\tOM_uint32 tmpmin, ret;\n\tgss_OID_set supported_mechSet;\n\tspnego_gss_ctx_id_t sc = NULL;\n\n\t*mechListMIC = GSS_C_NO_BUFFER;\n\tsupported_mechSet = GSS_C_NO_OID_SET;\n\t*return_token = NO_TOKEN_SEND;\n\t*negState = REJECT;\n\t*minor_status = 0;\n\n\t/* A hint request must be the first token received. */\n\tif (*ctx != GSS_C_NO_CONTEXT)\n\t    return GSS_S_DEFECTIVE_TOKEN;\n\n\tret = get_negotiable_mechs(minor_status, spcred, GSS_C_ACCEPT,\n\t\t\t\t   &supported_mechSet);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\n\tret = make_NegHints(minor_status, mechListMIC);\n \tif (ret != GSS_S_COMPLETE)\n \t\tgoto cleanup;\n \n\tsc = create_spnego_ctx();\n \tif (sc == NULL) {\n \t\tret = GSS_S_FAILURE;\n \t\tgoto cleanup;\n\t}\n\tif (put_mech_set(supported_mechSet, &sc->DER_mechTypes) < 0) {\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\tsc->internal_mech = GSS_C_NO_OID;\n\n\t*negState = ACCEPT_INCOMPLETE;\n\t*return_token = INIT_TOKEN_SEND;\n\tsc->firstpass = 1;\n\t*ctx = (gss_ctx_id_t)sc;\n\tsc = NULL;\n\tret = GSS_S_COMPLETE;\n\ncleanup:\n\trelease_spnego_ctx(&sc);\n\tgss_release_oid_set(&tmpmin, &supported_mechSet);\n\n\treturn ret;\n}\n", "target": 1, "idx": 179819}
{"func": "void InjectedBundlePage::beganExitFullScreen(WKBundlePageRef, WKRect, WKRect)\n{\n    if (InjectedBundle::shared().testRunner()->shouldDumpFullScreenCallbacks())\n        InjectedBundle::shared().outputText(\"beganExitFullScreen()\\n\");\n}\n", "target": 0, "idx": 115356}
{"func": "calc_delta_mine(unsigned long delta_exec, unsigned long weight,\n\t\tstruct load_weight *lw)\n{\n\tu64 tmp;\n\n\tif (!lw->inv_weight) {\n\t\tif (BITS_PER_LONG > 32 && unlikely(lw->weight >= WMULT_CONST))\n\t\t\tlw->inv_weight = 1;\n\t\telse\n\t\t\tlw->inv_weight = 1 + (WMULT_CONST-lw->weight/2)\n\t\t\t\t/ (lw->weight+1);\n\t}\n\n\ttmp = (u64)delta_exec * weight;\n\t/*\n\t * Check whether we'd overflow the 64-bit multiplication:\n\t */\n\tif (unlikely(tmp > WMULT_CONST))\n\t\ttmp = SRR(SRR(tmp, WMULT_SHIFT/2) * lw->inv_weight,\n\t\t\tWMULT_SHIFT/2);\n\telse\n\t\ttmp = SRR(tmp * lw->inv_weight, WMULT_SHIFT);\n\n\treturn (unsigned long)min(tmp, (u64)(unsigned long)LONG_MAX);\n}\n", "target": 0, "idx": 22346}
{"func": " void jas_matrix_asl(jas_matrix_t *matrix, int n)\n {\n\tint i;\n\tint j;\n \tjas_seqent_t *rowstart;\n\tint rowstep;\n \tjas_seqent_t *data;\n \n \tif (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {\n\t\tassert(matrix->rows_);\n\t\trowstep = jas_matrix_rowstep(matrix);\n\t\tfor (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i,\n\t\t  rowstart += rowstep) {\n\t\t\tfor (j = matrix->numcols_, data = rowstart; j > 0; --j,\n\t\t\t  ++data) {\n\t\t\t\t*data = jas_seqent_asl(*data, n);\n\t\t\t}\n\t\t}\n\t}\n}\n", "target": 1, "idx": 181869}
{"func": "void Browser::WindowFullscreenStateChanged() {\n  UpdateCommandsForFullscreenMode(window_->IsFullscreen());\n  UpdateBookmarkBarState(BOOKMARK_BAR_STATE_CHANGE_TOGGLE_FULLSCREEN);\n   MessageLoop::current()->PostTask(\n       FROM_HERE, method_factory_.NewRunnableMethod(\n       &Browser::NotifyFullscreenChange));\n  if (!window_->IsFullscreen())\n     NotifyTabOfFullscreenExitIfNecessary();\n }\n", "target": 1, "idx": 183692}
{"func": "static void nfs4_lock_release(void *calldata)\n{\n\tstruct nfs4_lockdata *data = calldata;\n\n\tdprintk(\"%s: begin!\\n\", __func__);\n\tnfs_free_seqid(data->arg.open_seqid);\n\tif (data->cancelled != 0) {\n\t\tstruct rpc_task *task;\n\t\ttask = nfs4_do_unlck(&data->fl, data->ctx, data->lsp,\n\t\t\t\tdata->arg.lock_seqid);\n\t\tif (!IS_ERR(task))\n\t\t\trpc_put_task(task);\n\t\tdprintk(\"%s: cancelling lock!\\n\", __func__);\n\t} else\n\t\tnfs_free_seqid(data->arg.lock_seqid);\n\tnfs4_put_lock_state(data->lsp);\n\tput_nfs_open_context(data->ctx);\n\tkfree(data);\n\tdprintk(\"%s: done!\\n\", __func__);\n}\n", "target": 0, "idx": 22878}
{"func": "xmlParseExtParsedEnt(xmlParserCtxtPtr ctxt) {\n    xmlChar start[4];\n    xmlCharEncoding enc;\n\n    if ((ctxt == NULL) || (ctxt->input == NULL))\n        return(-1);\n\n    xmlDefaultSAXHandlerInit();\n\n    xmlDetectSAX2(ctxt);\n\n    GROW;\n\n    /*\n     * SAX: beginning of the document processing.\n     */\n    if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))\n        ctxt->sax->setDocumentLocator(ctxt->userData, &xmlDefaultSAXLocator);\n\n    /* \n     * Get the 4 first bytes and decode the charset\n     * if enc != XML_CHAR_ENCODING_NONE\n     * plug some encoding conversion routines.\n     */\n    if ((ctxt->input->end - ctxt->input->cur) >= 4) {\n\tstart[0] = RAW;\n\tstart[1] = NXT(1);\n\tstart[2] = NXT(2);\n\tstart[3] = NXT(3);\n\tenc = xmlDetectCharEncoding(start, 4);\n\tif (enc != XML_CHAR_ENCODING_NONE) {\n\t    xmlSwitchEncoding(ctxt, enc);\n\t}\n    }\n\n\n    if (CUR == 0) {\n\txmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);\n    }\n\n    /*\n     * Check for the XMLDecl in the Prolog.\n     */\n    GROW;\n    if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) && (IS_BLANK_CH(NXT(5)))) {\n\n\t/*\n\t * Note that we will switch encoding on the fly.\n\t */\n\txmlParseXMLDecl(ctxt);\n\tif (ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) {\n\t    /*\n\t     * The XML REC instructs us to stop parsing right here\n\t     */\n\t    return(-1);\n\t}\n\tSKIP_BLANKS;\n    } else {\n\tctxt->version = xmlCharStrdup(XML_DEFAULT_VERSION);\n     }\n     if ((ctxt->sax) && (ctxt->sax->startDocument) && (!ctxt->disableSAX))\n         ctxt->sax->startDocument(ctxt->userData);\n \n     /*\n      * Doing validity checking on chunk doesn't make sense\n     */\n    ctxt->instate = XML_PARSER_CONTENT;\n    ctxt->validate = 0;\n    ctxt->loadsubset = 0;\n     ctxt->depth = 0;\n \n     xmlParseContent(ctxt);\n    \n     if ((RAW == '<') && (NXT(1) == '/')) {\n \txmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);\n    } else if (RAW != 0) {\n\txmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, NULL);\n    }\n\n    /*\n     * SAX: end of the document processing.\n     */\n    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\n        ctxt->sax->endDocument(ctxt->userData);\n\n    if (! ctxt->wellFormed) return(-1);\n    return(0);\n}\n", "target": 1, "idx": 184983}
{"func": "static int get_msr_hyperv_pw(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)\n{\n\tu64 data = 0;\n\tstruct kvm *kvm = vcpu->kvm;\n\n\tswitch (msr) {\n\tcase HV_X64_MSR_GUEST_OS_ID:\n\t\tdata = kvm->arch.hv_guest_os_id;\n\t\tbreak;\n\tcase HV_X64_MSR_HYPERCALL:\n\t\tdata = kvm->arch.hv_hypercall;\n\t\tbreak;\n\tdefault:\n\t\tpr_unimpl(vcpu, \"Hyper-V unhandled rdmsr: 0x%x\\n\", msr);\n\t\treturn 1;\n\t}\n\n\t*pdata = data;\n\treturn 0;\n}\n", "target": 0, "idx": 20698}
{"func": "static void windows_clear_transfer_priv(struct usbi_transfer *itransfer)\n{\n \tstruct windows_transfer_priv *transfer_priv = (struct windows_transfer_priv*)usbi_transfer_get_os_priv(itransfer);\n \n \tusbi_free_fd(&transfer_priv->pollable_fd);\n\tsafe_free(transfer_priv->hid_buffer);\n \tauto_release(itransfer);\n }\n", "target": 1, "idx": 187239}
{"func": "struct dentry *debugfs_rename(struct dentry *old_dir, struct dentry *old_dentry,\n\t\tstruct dentry *new_dir, const char *new_name)\n {\n \tint error;\n \tstruct dentry *dentry = NULL, *trap;\n\tconst char *old_name;\n \n \ttrap = lock_rename(new_dir, old_dir);\n \t/* Source or destination directories don't exist? */\n\tif (d_really_is_negative(old_dir) || d_really_is_negative(new_dir))\n\t\tgoto exit;\n\t/* Source does not exist, cyclic rename, or mountpoint? */\n\tif (d_really_is_negative(old_dentry) || old_dentry == trap ||\n\t    d_mountpoint(old_dentry))\n\t\tgoto exit;\n\tdentry = lookup_one_len(new_name, new_dir, strlen(new_name));\n\t/* Lookup failed, cyclic rename or target exists? */\n \tif (IS_ERR(dentry) || dentry == trap || d_really_is_positive(dentry))\n \t\tgoto exit;\n \n\told_name = fsnotify_oldname_init(old_dentry->d_name.name);\n \n \terror = simple_rename(d_inode(old_dir), old_dentry, d_inode(new_dir),\n \t\t\t      dentry, 0);\n \tif (error) {\n\t\tfsnotify_oldname_free(old_name);\n \t\tgoto exit;\n \t}\n \td_move(old_dentry, dentry);\n\tfsnotify_move(d_inode(old_dir), d_inode(new_dir), old_name,\n \t\td_is_dir(old_dentry),\n \t\tNULL, old_dentry);\n\tfsnotify_oldname_free(old_name);\n \tunlock_rename(new_dir, old_dir);\n \tdput(dentry);\n \treturn old_dentry;\nexit:\n\tif (dentry && !IS_ERR(dentry))\n\t\tdput(dentry);\n\tunlock_rename(new_dir, old_dir);\n\treturn NULL;\n}\n", "target": 1, "idx": 181434}
{"func": "static int cp2112_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tint ret;\n\n\tmutex_lock(&dev->lock);\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_GET_REPORT);\n\tif (ret != CP2112_GPIO_CONFIG_LENGTH) {\n\t\thid_err(hdev, \"error requesting GPIO config: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tbuf[1] &= ~(1 << offset);\n\tbuf[2] = gpio_push_pull;\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"error setting GPIO config: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tret = 0;\n \n exit:\n \tmutex_unlock(&dev->lock);\n\treturn ret <= 0 ? ret : -EIO;\n }\n", "target": 1, "idx": 181379}
{"func": "fpDiff(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\ttmsize_t stride = PredictorState(tif)->stride;\n\tuint32 bps = tif->tif_dir.td_bitspersample / 8;\n \ttmsize_t wc = cc / bps;\n \ttmsize_t count;\n \tuint8 *cp = (uint8 *) cp0;\n\tuint8 *tmp = (uint8 *)_TIFFmalloc(cc);\n \n     if((cc%(bps*stride))!=0)\n     {\n         TIFFErrorExt(tif->tif_clientdata, \"fpDiff\",\n                      \"%s\", \"(cc%(bps*stride))!=0\");\n         return 0;\n     }\n \tif (!tmp)\n \t\treturn 0;\n \n\t_TIFFmemcpy(tmp, cp0, cc);\n\tfor (count = 0; count < wc; count++) {\n\t\tuint32 byte;\n\t\tfor (byte = 0; byte < bps; byte++) {\n\t\t\t#if WORDS_BIGENDIAN\n\t\t\tcp[byte * wc + count] = tmp[bps * count + byte];\n\t\t\t#else\n\t\t\tcp[(bps - byte - 1) * wc + count] =\n\t\t\t\ttmp[bps * count + byte];\n\t\t\t#endif\n\t\t}\n\t}\n\t_TIFFfree(tmp);\n\n\tcp = (uint8 *) cp0;\n\tcp += cc - stride - 1;\n\tfor (count = cc; count > stride; count -= stride)\n\t\tREPEAT4(stride, cp[stride] = (unsigned char)((cp[stride] - cp[0])&0xff); cp--)\n    return 1;\n}\n", "target": 1, "idx": 183111}
{"func": "static void willRemoveChildren(ContainerNode* container)\n{\n     NodeVector children;\n     getChildNodes(container, children);\n \n    container->document().nodeChildrenWillBeRemoved(container);\n     ChildListMutationScope mutation(container);\n     for (NodeVector::const_iterator it = children.begin(); it != children.end(); it++) {\n         Node* child = it->get();\n        mutation.willRemoveChild(child);\n        child->notifyMutationObserversNodeWillDetach();\n\n        dispatchChildRemovalEvents(child);\n    }\n\n    ChildFrameDisconnector(container).disconnect(ChildFrameDisconnector::DescendantsOnly);\n}\n", "target": 1, "idx": 184851}
{"func": " void TabletModeWindowManager::Shutdown() {\n  base::flat_map<aura::Window*, WindowStateType> windows_in_splitview =\n      GetCarryOverWindowsInSplitView();\n  SplitViewController* split_view_controller =\n      Shell::Get()->split_view_controller();\n  if (split_view_controller->InSplitViewMode()) {\n    OverviewController* overview_controller =\n        Shell::Get()->overview_controller();\n    if (!overview_controller->InOverviewSession() ||\n        overview_controller->overview_session()->IsEmpty()) {\n      Shell::Get()->split_view_controller()->EndSplitView(\n          SplitViewController::EndReason::kExitTabletMode);\n      overview_controller->EndOverview();\n     }\n   }\n \n  for (aura::Window* window : added_windows_)\n    window->RemoveObserver(this);\n  added_windows_.clear();\n  Shell::Get()->RemoveShellObserver(this);\n  Shell::Get()->session_controller()->RemoveObserver(this);\n  Shell::Get()->overview_controller()->RemoveObserver(this);\n  display::Screen::GetScreen()->RemoveObserver(this);\n  RemoveWindowCreationObservers();\n \n   ScopedObserveWindowAnimation scoped_observe(GetTopWindow(), this,\n                                               /*exiting_tablet_mode=*/true);\n  ArrangeWindowsForClamshellMode(windows_in_splitview);\n }\n", "target": 1, "idx": 186370}
{"func": "  static std::string redirect_headers() {\n    return URLRequestTestJob::test_redirect_headers();\n  }\n", "target": 0, "idx": 108657}
{"func": "ossl_cipher_set_key(VALUE self, VALUE key)\n{\n    EVP_CIPHER_CTX *ctx;\n    int key_len;\n\n    StringValue(key);\n    GetCipher(self, ctx);\n\n    key_len = EVP_CIPHER_CTX_key_length(ctx);\n    if (RSTRING_LEN(key) != key_len)\n\tossl_raise(rb_eArgError, \"key must be %d bytes\", key_len);\n\n     if (EVP_CipherInit_ex(ctx, NULL, NULL, (unsigned char *)RSTRING_PTR(key), NULL, -1) != 1)\n \tossl_raise(eCipherError, NULL);\n \n     return key;\n }\n", "target": 1, "idx": 181954}
{"func": "void Texture::Copy(const gfx::Size& size, GLenum format) {\n  DCHECK_NE(id_, 0u);\n  ScopedGLErrorSuppressor suppressor(decoder_);\n  ScopedTexture2DBinder binder(decoder_, id_);\n  glCopyTexImage2D(GL_TEXTURE_2D,\n                   0,  // level\n                   format,\n                   0, 0,\n                   size.width(),\n                   size.height(),\n                   0);  // border\n}\n", "target": 0, "idx": 103969}
{"func": "dbus_g_proxy_manager_filter (DBusConnection    *connection,\n                             DBusMessage       *message,\n                             void              *user_data)\n{\n  DBusGProxyManager *manager;\n  \n  if (dbus_message_get_type (message) != DBUS_MESSAGE_TYPE_SIGNAL)\n    return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;\n\n  manager = user_data;\n\n  dbus_g_proxy_manager_ref (manager);\n  \n  LOCK_MANAGER (manager);\n  \n  if (dbus_message_is_signal (message,\n                              DBUS_INTERFACE_LOCAL,\n                              \"Disconnected\"))\n    {\n      /* Destroy all the proxies, quite possibly resulting in unreferencing\n       * the proxy manager and the connection as well.\n       */\n      GSList *all;\n      GSList *tmp;\n\n      all = dbus_g_proxy_manager_list_all (manager);\n\n      tmp = all;\n      while (tmp != NULL)\n        {\n          DBusGProxy *proxy;\n\n          proxy = DBUS_G_PROXY (tmp->data);\n\n          UNLOCK_MANAGER (manager);\n          dbus_g_proxy_destroy (proxy);\n          g_object_unref (G_OBJECT (proxy));\n          LOCK_MANAGER (manager);\n          \n          tmp = tmp->next;\n        }\n\n      g_slist_free (all);\n\n#ifndef G_DISABLE_CHECKS\n      if (manager->proxy_lists != NULL)\n        g_warning (\"Disconnection emitted \\\"destroy\\\" on all DBusGProxy, but somehow new proxies were created in response to one of those destroy signals. This will cause a memory leak.\");\n#endif\n    }\n  else\n    {\n      char *tri;\n      GSList *full_list;\n      GSList *owned_names;\n       GSList *tmp;\n       const char *sender;\n \n       /* First we handle NameOwnerChanged internally */\n      if (dbus_message_is_signal (message,\n \t\t\t\t  DBUS_INTERFACE_DBUS,\n \t\t\t\t  \"NameOwnerChanged\"))\n \t{\n\t  DBusError derr;\n\n\t  dbus_error_init (&derr);\n\t  if (!dbus_message_get_args (message,\n\t\t\t\t      &derr,\n\t\t\t\t      DBUS_TYPE_STRING,\n\t\t\t\t      &name,\n\t\t\t\t      DBUS_TYPE_STRING,\n\t\t\t\t      &prev_owner,\n\t\t\t\t      DBUS_TYPE_STRING,\n\t\t\t\t      &new_owner,\n\t\t\t\t      DBUS_TYPE_INVALID))\n\t    {\n\t      /* Ignore this error */\n\t      dbus_error_free (&derr);\n\t    }\n\t  else if (manager->owner_names != NULL)\n\t    {\n\t      dbus_g_proxy_manager_replace_name_owner (manager, name, prev_owner, new_owner);\n\t    }\n\t}\n\n \t    }\n \t}\n", "target": 1, "idx": 177953}
{"func": "psf_open_rsrc (SF_PRIVATE *psf)\n{\n\tif (psf->rsrc.filedes > 0)\n\t\treturn 0 ;\n\n\t/* Test for MacOSX style resource fork on HPFS or HPFS+ filesystems. */\n\tsnprintf (psf->rsrc.path.c, sizeof (psf->rsrc.path.c), \"%s/..namedfork/rsrc\", psf->file.path.c) ;\n\tpsf->error = SFE_NO_ERROR ;\n\tif ((psf->rsrc.filedes = psf_open_fd (&psf->rsrc)) >= 0)\n\t{\tpsf->rsrclength = psf_get_filelen_fd (psf->rsrc.filedes) ;\n\t\tif (psf->rsrclength > 0 || (psf->rsrc.mode & SFM_WRITE))\n\t\t\treturn SFE_NO_ERROR ;\n\t\tpsf_close_fd (psf->rsrc.filedes) ;\n\t\tpsf->rsrc.filedes = -1 ;\n\t\t} ;\n\n\tif (psf->rsrc.filedes == - SFE_BAD_OPEN_MODE)\n\t{\tpsf->error = SFE_BAD_OPEN_MODE ;\n\t\treturn psf->error ;\n\t\t} ;\n\n\t/*\n\t** Now try for a resource fork stored as a separate file in the same\n\t** directory, but preceded with a dot underscore.\n\t*/\n\tsnprintf (psf->rsrc.path.c, sizeof (psf->rsrc.path.c), \"%s._%s\", psf->file.dir.c, psf->file.name.c) ;\n\tpsf->error = SFE_NO_ERROR ;\n\tif ((psf->rsrc.filedes = psf_open_fd (&psf->rsrc)) >= 0)\n\t{\tpsf->rsrclength = psf_get_filelen_fd (psf->rsrc.filedes) ;\n\t\treturn SFE_NO_ERROR ;\n\t\t} ;\n\n\t/*\n\t** Now try for a resource fork stored in a separate file in the\n\t** .AppleDouble/ directory.\n\t*/\n\tsnprintf (psf->rsrc.path.c, sizeof (psf->rsrc.path.c), \"%s.AppleDouble/%s\", psf->file.dir.c, psf->file.name.c) ;\n\tpsf->error = SFE_NO_ERROR ;\n\tif ((psf->rsrc.filedes = psf_open_fd (&psf->rsrc)) >= 0)\n\t{\tpsf->rsrclength = psf_get_filelen_fd (psf->rsrc.filedes) ;\n\t\treturn SFE_NO_ERROR ;\n\t\t} ;\n\n\t/* No resource file found. */\n\tif (psf->rsrc.filedes == -1)\n\t\tpsf_log_syserr (psf, errno) ;\n\n\tpsf->rsrc.filedes = -1 ;\n\n\treturn psf->error ;\n} /* psf_open_rsrc */\n", "target": 0, "idx": 45249}
{"func": "ProfilingProcessHost::Mode ProfilingProcessHost::GetCurrentMode() {\n  const base::CommandLine* cmdline = base::CommandLine::ForCurrentProcess();\n#if BUILDFLAG(USE_ALLOCATOR_SHIM)\n  if (cmdline->HasSwitch(switches::kMemlog) ||\n      base::FeatureList::IsEnabled(kOOPHeapProfilingFeature)) {\n    if (cmdline->HasSwitch(switches::kEnableHeapProfiling)) {\n      LOG(ERROR) << \"--\" << switches::kEnableHeapProfiling\n                 << \" specified with --\" << switches::kMemlog\n                 << \"which are not compatible. Memlog will be disabled.\";\n      return Mode::kNone;\n    }\n\n    std::string mode;\n    if (cmdline->HasSwitch(switches::kMemlog)) {\n      mode = cmdline->GetSwitchValueASCII(switches::kMemlog);\n    } else {\n      mode = base::GetFieldTrialParamValueByFeature(\n           kOOPHeapProfilingFeature, kOOPHeapProfilingFeatureMode);\n     }\n \n    if (mode == switches::kMemlogModeAll)\n      return Mode::kAll;\n    if (mode == switches::kMemlogModeMinimal)\n      return Mode::kMinimal;\n    if (mode == switches::kMemlogModeBrowser)\n      return Mode::kBrowser;\n    if (mode == switches::kMemlogModeGpu)\n      return Mode::kGpu;\n    if (mode == switches::kMemlogModeRendererSampling)\n      return Mode::kRendererSampling;\n    DLOG(ERROR) << \"Unsupported value: \\\"\" << mode << \"\\\" passed to --\"\n                << switches::kMemlog;\n   }\n   return Mode::kNone;\n #else\n  LOG_IF(ERROR, cmdline->HasSwitch(switches::kMemlog))\n      << \"--\" << switches::kMemlog\n      << \" specified but it will have no effect because the use_allocator_shim \"\n      << \"is not available in this build.\";\n  return Mode::kNone;\n #endif\n }\n", "target": 1, "idx": 186901}
{"func": " pdf_repair_xref(fz_context *ctx, pdf_document *doc)\n {\n\tint c;\n\tpdf_lexbuf *buf = &doc->lexbuf.base;\n\tint num_roots = 0;\n\tint max_roots = 0;\n\n\tfz_var(encrypt);\n\tfz_var(id);\n\tfz_var(roots);\n\tfz_var(num_roots);\n\tfz_var(max_roots);\n\tfz_var(info);\n\tfz_var(list);\n\tfz_var(obj);\n\n\tif (doc->repair_attempted)\n\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"Repair failed already - not trying again\");\n\tdoc->repair_attempted = 1;\n\n\tdoc->dirty = 1;\n\t/* Can't support incremental update after repair */\n\tdoc->freeze_updates = 1;\n\n\tfz_seek(ctx, doc->file, 0, 0);\n\n\tfz_try(ctx)\n\t{\n\t\tpdf_xref_entry *entry;\n\t\tlistlen = 0;\n\t\tlistcap = 1024;\n\t\tlist = fz_malloc_array(ctx, listcap, sizeof(struct entry));\n\n\t\t/* look for '%PDF' version marker within first kilobyte of file */\n\t\tn = fz_read(ctx, doc->file, (unsigned char *)buf->scratch, fz_mini(buf->size, 1024));\n\n\t\tfz_seek(ctx, doc->file, 0, 0);\n\t\tif (n >= 4)\n\t\t{\n\t\t\tfor (j = 0; j < n - 4; j++)\n\t\t\t{\n\t\t\t\tif (memcmp(&buf->scratch[j], \"%PDF\", 4) == 0)\n\t\t\t\t{\n\t\t\t\t\tfz_seek(ctx, doc->file, j + 8, 0); /* skip \"%PDF-X.Y\" */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* skip comment line after version marker since some generators\n\t\t * forget to terminate the comment with a newline */\n\t\tc = fz_read_byte(ctx, doc->file);\n\t\twhile (c >= 0 && (c == ' ' || c == '%'))\n\t\t\tc = fz_read_byte(ctx, doc->file);\n\t\tfz_unread_byte(ctx, doc->file);\n\n\t\twhile (1)\n\t\t{\n\t\t\ttmpofs = fz_tell(ctx, doc->file);\n\t\t\tif (tmpofs < 0)\n\t\t\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"cannot tell in file\");\n\n\t\t\tfz_try(ctx)\n\t\t\t{\n\t\t\t\ttok = pdf_lex_no_string(ctx, doc->file, buf);\n\t\t\t}\n\t\t\tfz_catch(ctx)\n\t\t\t{\n\t\t\t\tfz_rethrow_if(ctx, FZ_ERROR_TRYLATER);\n\t\t\t\tfz_warn(ctx, \"ignoring the rest of the file\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* If we have the next token already, then we'll jump\n\t\t\t * back here, rather than going through the top of\n\t\t\t * the loop. */\n\t\thave_next_token:\n\n\t\t\tif (tok == PDF_TOK_INT)\n\t\t\t{\n\t\t\t\tif (buf->i < 0)\n\t\t\t\t{\n\t\t\t\t\tnum = 0;\n\t\t\t\t\tgen = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tnumofs = genofs;\n\t\t\t\tnum = gen;\n\t\t\t\tgenofs = tmpofs;\n\t\t\t\tgen = buf->i;\n\t\t\t}\n\n\t\t\telse if (tok == PDF_TOK_OBJ)\n\t\t\t{\n\t\t\t\tpdf_obj *root = NULL;\n\n\t\t\t\tfz_try(ctx)\n\t\t\t\t{\n\t\t\t\t\tstm_len = 0;\n\t\t\t\t\tstm_ofs = 0;\n\t\t\t\t\ttok = pdf_repair_obj(ctx, doc, buf, &stm_ofs, &stm_len, &encrypt, &id, NULL, &tmpofs, &root);\n\t\t\t\t\tif (root)\n\t\t\t\t\t\tadd_root(ctx, root, &roots, &num_roots, &max_roots);\n\t\t\t\t}\n\t\t\t\tfz_always(ctx)\n\t\t\t\t{\n\t\t\t\t\tpdf_drop_obj(ctx, root);\n\t\t\t\t}\n\t\t\t\tfz_catch(ctx)\n\t\t\t\t{\n\t\t\t\t\tfz_rethrow_if(ctx, FZ_ERROR_TRYLATER);\n\t\t\t\t\t/* If we haven't seen a root yet, there is nothing\n\t\t\t\t\t * we can do, but give up. Otherwise, we'll make\n\t\t\t\t\t * do. */\n\t\t\t\t\tif (!roots)\n\t\t\t\t\t\tfz_rethrow(ctx);\n\t\t\t\t\tfz_warn(ctx, \"cannot parse object (%d %d R) - ignoring rest of file\", num, gen);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (num <= 0 || num > MAX_OBJECT_NUMBER)\n\t\t\t\t{\n\t\t\t\t\tfz_warn(ctx, \"ignoring object with invalid object number (%d %d R)\", num, gen);\n\t\t\t\t\tgoto have_next_token;\n\t\t\t\t}\n\n\t\t\t\tgen = fz_clampi(gen, 0, 65535);\n\n\t\t\t\tif (listlen + 1 == listcap)\n\t\t\t\t{\n\t\t\t\t\tlistcap = (listcap * 3) / 2;\n\t\t\t\t\tlist = fz_resize_array(ctx, list, listcap, sizeof(struct entry));\n\t\t\t\t}\n\n\t\t\t\tlist[listlen].num = num;\n\t\t\t\tlist[listlen].gen = gen;\n\t\t\t\tlist[listlen].ofs = numofs;\n\t\t\t\tlist[listlen].stm_ofs = stm_ofs;\n\t\t\t\tlist[listlen].stm_len = stm_len;\n\t\t\t\tlistlen ++;\n\n\t\t\t\tif (num > maxnum)\n\t\t\t\t\tmaxnum = num;\n\n\t\t\t\tgoto have_next_token;\n\t\t\t}\n\n\t\t\t/* If we find a dictionary it is probably the trailer,\n\t\t\t * but could be a stream (or bogus) dictionary caused\n\t\t\t * by a corrupt file. */\n\t\t\telse if (tok == PDF_TOK_OPEN_DICT)\n\t\t\t{\n\t\t\t\tfz_try(ctx)\n\t\t\t\t{\n\t\t\t\t\tdict = pdf_parse_dict(ctx, doc, doc->file, buf);\n\t\t\t\t}\n\t\t\t\tfz_catch(ctx)\n\t\t\t\t{\n\t\t\t\t\tfz_rethrow_if(ctx, FZ_ERROR_TRYLATER);\n\t\t\t\t\t/* If this was the real trailer dict\n\t\t\t\t\t * it was broken, in which case we are\n\t\t\t\t\t * in trouble. Keep going though in\n\t\t\t\t\t * case this was just a bogus dict. */\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tobj = pdf_dict_get(ctx, dict, PDF_NAME_Encrypt);\n\t\t\t\tif (obj)\n\t\t\t\t{\n\t\t\t\t\tpdf_drop_obj(ctx, encrypt);\n\t\t\t\t\tencrypt = pdf_keep_obj(ctx, obj);\n\t\t\t\t}\n\n\t\t\t\tobj = pdf_dict_get(ctx, dict, PDF_NAME_ID);\n\t\t\t\tif (obj && (!id || !encrypt || pdf_dict_get(ctx, dict, PDF_NAME_Encrypt)))\n\t\t\t\t{\n\t\t\t\t\tpdf_drop_obj(ctx, id);\n\t\t\t\t\tid = pdf_keep_obj(ctx, obj);\n\t\t\t\t}\n\n\t\t\t\tobj = pdf_dict_get(ctx, dict, PDF_NAME_Root);\n\t\t\t\tif (obj)\n\t\t\t\t\tadd_root(ctx, obj, &roots, &num_roots, &max_roots);\n\n\t\t\t\tobj = pdf_dict_get(ctx, dict, PDF_NAME_Info);\n\t\t\t\tif (obj)\n\t\t\t\t{\n\t\t\t\t\tpdf_drop_obj(ctx, info);\n\t\t\t\t\tinfo = pdf_keep_obj(ctx, obj);\n\t\t\t\t}\n\n\t\t\t\tpdf_drop_obj(ctx, dict);\n\t\t\t\tobj = NULL;\n\t\t\t}\n\n\t\t\telse if (tok == PDF_TOK_EOF)\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (tok == PDF_TOK_ERROR)\n\t\t\t\t\tfz_read_byte(ctx, doc->file);\n\t\t\t\tnum = 0;\n\t\t\t\tgen = 0;\n\t\t\t}\n\n\t\t}\n\n\t\tif (listlen == 0)\n\t\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"no objects found\");\n\n\t\t/* make xref reasonable */\n\n\t\t/*\n\t\t\tDummy access to entry to assure sufficient space in the xref table\n\t\t\tand avoid repeated reallocs in the loop\n\t\t*/\n\t\t/* Ensure that the first xref table is a 'solid' one from\n\t\t * 0 to maxnum. */\n\t\tpdf_ensure_solid_xref(ctx, doc, maxnum);\n\n\t\tfor (i = 1; i < maxnum; i++)\n\t\t{\n\t\t\tentry = pdf_get_populating_xref_entry(ctx, doc, i);\n\t\t\tif (entry->obj != NULL)\n\t\t\t\tcontinue;\n\t\t\tentry->type = 'f';\n\t\t\tentry->ofs = 0;\n\t\t\tentry->gen = 0;\n\t\t\tentry->num = 0;\n\n\t\t\tentry->stm_ofs = 0;\n\t\t}\n\n\t\tfor (i = 0; i < listlen; i++)\n\t\t{\n\t\t\tentry = pdf_get_populating_xref_entry(ctx, doc, list[i].num);\n\t\t\tentry->type = 'n';\n\t\t\tentry->ofs = list[i].ofs;\n\t\t\tentry->gen = list[i].gen;\n\t\t\tentry->num = list[i].num;\n\n\t\t\tentry->stm_ofs = list[i].stm_ofs;\n\n\t\t\t/* correct stream length for unencrypted documents */\n\t\t\tif (!encrypt && list[i].stm_len >= 0)\n\t\t\t{\n\t\t\t\tdict = pdf_load_object(ctx, doc, list[i].num);\n\n\t\t\t\tlength = pdf_new_int(ctx, doc, list[i].stm_len);\n\t\t\t\tpdf_dict_put(ctx, dict, PDF_NAME_Length, length);\n\t\t\t\tpdf_drop_obj(ctx, length);\n\n\t\t\t\tpdf_drop_obj(ctx, dict);\n\t\t\t}\n\t\t}\n\n\t\tentry = pdf_get_populating_xref_entry(ctx, doc, 0);\n\t\tentry->type = 'f';\n\t\tentry->ofs = 0;\n\t\tentry->gen = 65535;\n\t\tentry->num = 0;\n\t\tentry->stm_ofs = 0;\n\n\t\tnext = 0;\n                        /* correct stream length for unencrypted documents */\n                        if (!encrypt && list[i].stm_len >= 0)\n                        {\n                                dict = pdf_load_object(ctx, doc, list[i].num);\n \n                                length = pdf_new_int(ctx, doc, list[i].stm_len);\n                               pdf_dict_put(ctx, dict, PDF_NAME_Length, length);\n                               pdf_drop_obj(ctx, length);\n                                pdf_drop_obj(ctx, dict);\n                        }\n                }\n\n\t\tobj = pdf_new_dict(ctx, doc, 5);\n\t\t/* During repair there is only a single xref section */\n\t\tpdf_set_populating_xref_trailer(ctx, doc, obj);\n\t\tpdf_drop_obj(ctx, obj);\n\t\tobj = NULL;\n\n\t\tobj = pdf_new_int(ctx, doc, maxnum + 1);\n\t\tpdf_dict_put(ctx, pdf_trailer(ctx, doc), PDF_NAME_Size, obj);\n\t\tpdf_drop_obj(ctx, obj);\n\t\tobj = NULL;\n\n\t\tif (roots)\n\t\t{\n\t\t\tint i;\n\t\t\tfor (i = num_roots-1; i > 0; i--)\n\t\t\t{\n\t\t\t\tif (pdf_is_dict(ctx, roots[i]))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i >= 0)\n\t\t\t{\n\t\t\t\tpdf_dict_put(ctx, pdf_trailer(ctx, doc), PDF_NAME_Root, roots[i]);\n\t\t\t}\n\t\t}\n\t\tif (info)\n\t\t{\n\t\t\tpdf_dict_put(ctx, pdf_trailer(ctx, doc), PDF_NAME_Info, info);\n\t\t\tpdf_drop_obj(ctx, info);\n\t\t\tinfo = NULL;\n\t\t}\n\n\t\tif (encrypt)\n\t\t{\n\t\t\tif (pdf_is_indirect(ctx, encrypt))\n\t\t\t{\n\t\t\t\t/* create new reference with non-NULL xref pointer */\n\t\t\t\tobj = pdf_new_indirect(ctx, doc, pdf_to_num(ctx, encrypt), pdf_to_gen(ctx, encrypt));\n\t\t\t\tpdf_drop_obj(ctx, encrypt);\n\t\t\t\tencrypt = obj;\n\t\t\t\tobj = NULL;\n\t\t\t}\n\t\t\tpdf_dict_put(ctx, pdf_trailer(ctx, doc), PDF_NAME_Encrypt, encrypt);\n\t\t\tpdf_drop_obj(ctx, encrypt);\n\t\t\tencrypt = NULL;\n\t\t}\n\n\t\tif (id)\n\t\t{\n\t\t\tif (pdf_is_indirect(ctx, id))\n\t\t\t{\n\t\t\t\t/* create new reference with non-NULL xref pointer */\n\t\t\t\tobj = pdf_new_indirect(ctx, doc, pdf_to_num(ctx, id), pdf_to_gen(ctx, id));\n\t\t\t\tpdf_drop_obj(ctx, id);\n\t\t\t\tid = obj;\n\t\t\t\tobj = NULL;\n\t\t\t}\n\t\t\tpdf_dict_put(ctx, pdf_trailer(ctx, doc), PDF_NAME_ID, id);\n\t\t\tpdf_drop_obj(ctx, id);\n\t\t\tid = NULL;\n\t\t}\n\n\t\tfz_free(ctx, list);\n\t}\n", "target": 1, "idx": 178433}
{"func": "set_store_for_write(png_store *ps, png_infopp ppi,\n   PNG_CONST char * volatile name)\n {\n    anon_context(ps);\n \n Try\n {\n if (ps->pwrite != NULL)\n         png_error(ps->pwrite, \"write store already in use\");\n\n      store_write_reset(ps);\n      safecat(ps->wname, sizeof ps->wname, 0, name);\n\n /* Don't do the slow memory checks if doing a speed test, also if user\n       * memory is not supported we can't do it anyway.\n       */\n#     ifdef PNG_USER_MEM_SUPPORTED\n if (!ps->speed)\n            ps->pwrite = png_create_write_struct_2(PNG_LIBPNG_VER_STRING,\n               ps, store_error, store_warning, &ps->write_memory_pool,\n               store_malloc, store_free);\n\n else\n#     endif\n         ps->pwrite = png_create_write_struct(PNG_LIBPNG_VER_STRING,\n            ps, store_error, store_warning);\n\n      png_set_write_fn(ps->pwrite, ps, store_write, store_flush);\n\n#     ifdef PNG_SET_OPTION_SUPPORTED\n {\n int opt;\n for (opt=0; opt<ps->noptions; ++opt)\n if (png_set_option(ps->pwrite, ps->options[opt].option,\n                  ps->options[opt].setting) == PNG_OPTION_INVALID)\n                  png_error(ps->pwrite, \"png option invalid\");\n }\n#     endif\n\n if (ppi != NULL)\n *ppi = ps->piwrite = png_create_info_struct(ps->pwrite);\n }\n\n Catch_anonymous\n return NULL;\n\n return ps->pwrite;\n}\n", "target": 1, "idx": 187718}
{"func": "leap_file(\n\tFILE\t*fp\t\t/* file handle */\n\t)\n{\n\tchar\tbuf[NTP_MAXSTRLEN]; /* file line buffer */\n\tu_long\tleap;\t\t/* NTP time at leap */\n\tu_long\texpire;\t\t/* NTP time when file expires */\n\tint\toffset;\t\t/* TAI offset at leap (s) */\n\tint\ti;\n\n\t/*\n\t * Read and parse the leapseconds file. Empty lines and comments\n\t * are ignored. A line beginning with #@ contains the file\n\t * expiration time in NTP seconds. Other lines begin with two\n\t * integers followed by junk or comments. The first integer is\n\t * the NTP seconds at the leap, the second is the TAI offset\n\t * after the leap.\n\t */\n\toffset = 0;\n\tleap = 0;\n\texpire = 0;\n\ti = 10;\n\twhile (fgets(buf, NTP_MAXSTRLEN - 1, fp) != NULL) {\n\t\tif (strlen(buf) < 1)\n\t\t\tcontinue;\n\n\t\tif (buf[0] == '#') {\n\t\t\tif (strlen(buf) < 3)\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * Note the '@' flag was used only in the 2006\n\t\t\t * table; previious to that the flag was '$'.\n\t\t\t */\n\t\t\tif (buf[1] == '@' || buf[1] == '$') {\n\t\t\t\tif (sscanf(&buf[2], \"%lu\", &expire) !=\n\t\t\t\t    1)\n\t\t\t\t\treturn (-1);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (sscanf(buf, \"%lu %d\", &leap, &offset) == 2) {\n\n\t\t\t/*\n\t\t\t * Valid offsets must increase by one for each\n\t\t\t * leap.\n\t\t\t */\n\t\t\tif (i++ != offset)\n\t\t\t\treturn (-1);\n\t\t}\n\t}\n\n\t/*\n\t * There must be at least one leap.\n\t */\n\tif (i == 10)\n\t\treturn (-1);\n\n\tleap_tai = offset;\n\tleap_sec = leap;\n\tleap_expire = expire;\n\treturn (0);\n}\n", "target": 0, "idx": 74218}
{"func": "static void WriteDDSInfo(Image *image, const size_t pixelFormat,\n  const size_t compression, const size_t mipmaps)\n{\n  char\n    software[MaxTextExtent];\n\n  register ssize_t\n    i;\n\n  unsigned int\n    format,\n    caps,\n    flags;\n\n  flags=(unsigned int) (DDSD_CAPS | DDSD_WIDTH | DDSD_HEIGHT |\n    DDSD_PIXELFORMAT | DDSD_LINEARSIZE);\n  caps=(unsigned int) DDSCAPS_TEXTURE;\n  format=(unsigned int) pixelFormat;\n\n  if (mipmaps > 0)\n    {\n      flags=flags | (unsigned int) DDSD_MIPMAPCOUNT;\n      caps=caps | (unsigned int) (DDSCAPS_MIPMAP | DDSCAPS_COMPLEX);\n    }\n\n  if (format != DDPF_FOURCC && image->matte)\n    format=format | DDPF_ALPHAPIXELS;\n\n  (void) WriteBlob(image,4,(unsigned char *) \"DDS \");\n  (void) WriteBlobLSBLong(image,124);\n  (void) WriteBlobLSBLong(image,flags);\n  (void) WriteBlobLSBLong(image,(unsigned int) image->rows);\n  (void) WriteBlobLSBLong(image,(unsigned int) image->columns);\n \n   if (compression == FOURCC_DXT1)\n     (void) WriteBlobLSBLong(image,\n             (unsigned int) (Max(1,(image->columns+3)/4) * 8));\n   else\n     (void) WriteBlobLSBLong(image,\n             (unsigned int) (Max(1,(image->columns+3)/4) * 16));\n \n   (void) WriteBlobLSBLong(image,0x00);\n   (void) WriteBlobLSBLong(image,(unsigned int) mipmaps+1);\n  (void) ResetMagickMemory(software,0,sizeof(software));\n  (void) strcpy(software,\"IMAGEMAGICK\");\n  (void) WriteBlob(image,44,(unsigned char *) software);\n\n  (void) WriteBlobLSBLong(image,32);\n  (void) WriteBlobLSBLong(image,format);\n\n  if (pixelFormat == DDPF_FOURCC)\n    {\n      (void) WriteBlobLSBLong(image,(unsigned int) compression);\n      for(i=0;i < 5;i++) // bitcount / masks\n        (void) WriteBlobLSBLong(image,0x00);\n    }\n  else\n    {\n      (void) WriteBlobLSBLong(image,0x00);\n      if (image->matte)\n        {\n          (void) WriteBlobLSBLong(image,32);\n          (void) WriteBlobLSBLong(image,0xff0000);\n          (void) WriteBlobLSBLong(image,0xff00);\n          (void) WriteBlobLSBLong(image,0xff);\n          (void) WriteBlobLSBLong(image,0xff000000);\n        }\n      else\n        {\n          (void) WriteBlobLSBLong(image,24);\n          (void) WriteBlobLSBLong(image,0xff);\n          (void) WriteBlobLSBLong(image,0x00);\n          (void) WriteBlobLSBLong(image,0x00);\n          (void) WriteBlobLSBLong(image,0x00);\n        }\n    }\n  \n  (void) WriteBlobLSBLong(image,caps);\n  for(i=0;i < 4;i++) // ddscaps2 + reserved region\n    (void) WriteBlobLSBLong(image,0x00);\n}\n", "target": 1, "idx": 182080}
{"func": "PHP_MSHUTDOWN_FUNCTION(localeconv)\n{\n\ttsrm_mutex_free( locale_mutex );\n\tlocale_mutex = NULL;\n\treturn SUCCESS;\n}\n", "target": 0, "idx": 14667}
{"func": "static int cqspi_indirect_write_setup(struct spi_nor *nor,\n\t\t\t\t      const unsigned int to_addr)\n{\n\tunsigned int reg;\n\tstruct cqspi_flash_pdata *f_pdata = nor->priv;\n\tstruct cqspi_st *cqspi = f_pdata->cqspi;\n\tvoid __iomem *reg_base = cqspi->iobase;\n\n\t/* Set opcode. */\n\treg = nor->program_opcode << CQSPI_REG_WR_INSTR_OPCODE_LSB;\n\twritel(reg, reg_base + CQSPI_REG_WR_INSTR);\n\treg = cqspi_calc_rdreg(nor, nor->program_opcode);\n\twritel(reg, reg_base + CQSPI_REG_RD_INSTR);\n\n\twritel(to_addr, reg_base + CQSPI_REG_INDIRECTWRSTARTADDR);\n\n\treg = readl(reg_base + CQSPI_REG_SIZE);\n\treg &= ~CQSPI_REG_SIZE_ADDRESS_MASK;\n\treg |= (nor->addr_width - 1);\n\twritel(reg, reg_base + CQSPI_REG_SIZE);\n\treturn 0;\n}\n", "target": 0, "idx": 93672}
{"func": "image_transform_png_set_palette_to_rgb_set(PNG_CONST image_transform *this,\n     transform_display *that, png_structp pp, png_infop pi)\n {\n    png_set_palette_to_rgb(pp);\n this->next->set(this->next, that, pp, pi);\n\n }\n", "target": 1, "idx": 187662}
{"func": "static void TerminateSource(j_decompress_ptr cinfo)\n{\n  (void) cinfo;\n}\n", "target": 0, "idx": 63378}
{"func": "void DragController::CancelDrag() {\n  page_->GetDragCaret().Clear();\n}\n", "target": 0, "idx": 165174}
{"func": "BlobDataHandle::BlobDataHandle(PassOwnPtr<BlobData> data, long long size)\n {\n     UNUSED_PARAM(size);\n     m_internalURL = BlobURL::createInternalURL();\n    ThreadableBlobRegistry::registerBlobURL(m_internalURL, data);\n }\n", "target": 1, "idx": 184268}
{"func": " bool ClipboardUtil::GetFilenames(IDataObject* data_object,\n                                 std::vector<base::string16>* filenames) {\n  DCHECK(data_object && filenames);\n  if (!HasFilenames(data_object))\n     return false;\n \n   STGMEDIUM medium;\n  if (!GetData(data_object, Clipboard::GetCFHDropFormatType(), &medium))\n    return false;\n \n  HDROP hdrop = static_cast<HDROP>(GlobalLock(medium.hGlobal));\n  if (!hdrop)\n    return false;\n \n  const int kMaxFilenameLen = 4096;\n  const unsigned num_files = DragQueryFileW(hdrop, 0xffffffff, 0, 0);\n  for (unsigned int i = 0; i < num_files; ++i) {\n    wchar_t filename[kMaxFilenameLen];\n    if (!DragQueryFileW(hdrop, i, filename, kMaxFilenameLen))\n      continue;\n    filenames->push_back(filename);\n   }\n \n  DragFinish(hdrop);\n  GlobalUnlock(medium.hGlobal);\n  return true;\n }\n", "target": 1, "idx": 185434}
{"func": "struct hid_device *hid_allocate_device(void)\n{\n\tstruct hid_device *hdev;\n\tint ret = -ENOMEM;\n\n\thdev = kzalloc(sizeof(*hdev), GFP_KERNEL);\n\tif (hdev == NULL)\n\t\treturn ERR_PTR(ret);\n\n\tdevice_initialize(&hdev->dev);\n\thdev->dev.release = hid_device_release;\n\thdev->dev.bus = &hid_bus_type;\n\tdevice_enable_async_suspend(&hdev->dev);\n\n\thid_close_report(hdev);\n\n\tinit_waitqueue_head(&hdev->debug_wait);\n\tINIT_LIST_HEAD(&hdev->debug_list);\n\tspin_lock_init(&hdev->debug_list_lock);\n\tsema_init(&hdev->driver_lock, 1);\n\tsema_init(&hdev->driver_input_lock, 1);\n\n\treturn hdev;\n}\n", "target": 0, "idx": 49480}
{"func": "MagickExport ColorspaceType GetPixelCacheColorspace(const Cache cache)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  assert(cache != (Cache) NULL);\n  cache_info=(CacheInfo *) cache;\n  assert(cache_info->signature == MagickSignature);\n  if (cache_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      cache_info->filename);\n  return(cache_info->colorspace);\n}\n", "target": 0, "idx": 73474}
{"func": "struct json_object* json_tokener_parse_ex(struct json_tokener *tok,\n\t\t\t\t\t  const char *str, int len)\n{\n  struct json_object *obj = NULL;\n  char c = '\\1';\n#ifdef HAVE_SETLOCALE\n  char *oldlocale=NULL, *tmplocale;\n\n  tmplocale = setlocale(LC_NUMERIC, NULL);\n  if (tmplocale) oldlocale = strdup(tmplocale);\n  setlocale(LC_NUMERIC, \"C\");\n#endif\n\n   tok->char_offset = 0;\n   tok->err = json_tokener_success;\n \n   while (PEEK_CHAR(c, tok)) {\n \n   redo_char:\n    switch(state) {\n\n    case json_tokener_state_eatws:\n      /* Advance until we change state */\n      while (isspace((int)c)) {\n\tif ((!ADVANCE_CHAR(str, tok)) || (!PEEK_CHAR(c, tok)))\n\t  goto out;\n      }\n      if(c == '/' && !(tok->flags & JSON_TOKENER_STRICT)) {\n\tprintbuf_reset(tok->pb);\n\tprintbuf_memappend_fast(tok->pb, &c, 1);\n\tstate = json_tokener_state_comment_start;\n      } else {\n\tstate = saved_state;\n\tgoto redo_char;\n      }\n      break;\n\n    case json_tokener_state_start:\n      switch(c) {\n      case '{':\n\tstate = json_tokener_state_eatws;\n\tsaved_state = json_tokener_state_object_field_start;\n\tcurrent = json_object_new_object();\n\tbreak;\n      case '[':\n\tstate = json_tokener_state_eatws;\n\tsaved_state = json_tokener_state_array;\n\tcurrent = json_object_new_array();\n\tbreak;\n      case 'I':\n      case 'i':\n\tstate = json_tokener_state_inf;\n\tprintbuf_reset(tok->pb);\n\ttok->st_pos = 0;\n\tgoto redo_char;\n      case 'N':\n      case 'n':\n\tstate = json_tokener_state_null; // or NaN\n\tprintbuf_reset(tok->pb);\n\ttok->st_pos = 0;\n\tgoto redo_char;\n      case '\\'':\n        if (tok->flags & JSON_TOKENER_STRICT) {\n            /* in STRICT mode only double-quote are allowed */\n            tok->err = json_tokener_error_parse_unexpected;\n            goto out;\n        }\n      case '\"':\n\tstate = json_tokener_state_string;\n\tprintbuf_reset(tok->pb);\n\ttok->quote_char = c;\n\tbreak;\n      case 'T':\n      case 't':\n      case 'F':\n      case 'f':\n\tstate = json_tokener_state_boolean;\n\tprintbuf_reset(tok->pb);\n\ttok->st_pos = 0;\n\tgoto redo_char;\n#if defined(__GNUC__)\n\t  case '0' ... '9':\n#else\n\t  case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n#endif\n      case '-':\n\tstate = json_tokener_state_number;\n\tprintbuf_reset(tok->pb);\n\ttok->is_double = 0;\n\tgoto redo_char;\n      default:\n\ttok->err = json_tokener_error_parse_unexpected;\n\tgoto out;\n      }\n      break;\n\n    case json_tokener_state_finish:\n      if(tok->depth == 0) goto out;\n      obj = json_object_get(current);\n      json_tokener_reset_level(tok, tok->depth);\n      tok->depth--;\n      goto redo_char;\n\n    case json_tokener_state_inf: /* aka starts with 'i' */\n      {\n\tint size;\n\tint size_inf;\n\tint is_negative = 0;\n\n\tprintbuf_memappend_fast(tok->pb, &c, 1);\n\tsize = json_min(tok->st_pos+1, json_null_str_len);\n\tsize_inf = json_min(tok->st_pos+1, json_inf_str_len);\n\tchar *infbuf = tok->pb->buf;\n\tif (*infbuf == '-')\n\t{\n\t\tinfbuf++;\n\t\tis_negative = 1;\n\t}\n\tif ((!(tok->flags & JSON_TOKENER_STRICT) &&\n\t          strncasecmp(json_inf_str, infbuf, size_inf) == 0) ||\n\t         (strncmp(json_inf_str, infbuf, size_inf) == 0)\n\t        )\n\t{\n\t\tif (tok->st_pos == json_inf_str_len)\n\t\t{\n\t\t\tcurrent = json_object_new_double(is_negative ? -INFINITY : INFINITY); \n\t\t\tsaved_state = json_tokener_state_finish;\n\t\t\tstate = json_tokener_state_eatws;\n\t\t\tgoto redo_char;\n\t\t}\n\t} else {\n\t\ttok->err = json_tokener_error_parse_unexpected;\n\t\tgoto out;\n\t}\n\ttok->st_pos++;\n      }\n      break;\n    case json_tokener_state_null: /* aka starts with 'n' */\n      {\n\tint size;\n\tint size_nan;\n\tprintbuf_memappend_fast(tok->pb, &c, 1);\n\tsize = json_min(tok->st_pos+1, json_null_str_len);\n\tsize_nan = json_min(tok->st_pos+1, json_nan_str_len);\n\tif((!(tok->flags & JSON_TOKENER_STRICT) &&\n\t  strncasecmp(json_null_str, tok->pb->buf, size) == 0)\n\t  || (strncmp(json_null_str, tok->pb->buf, size) == 0)\n\t  ) {\n\t  if (tok->st_pos == json_null_str_len) {\n\t    current = NULL;\n\t    saved_state = json_tokener_state_finish;\n\t    state = json_tokener_state_eatws;\n\t    goto redo_char;\n\t  }\n\t}\n\telse if ((!(tok->flags & JSON_TOKENER_STRICT) &&\n\t          strncasecmp(json_nan_str, tok->pb->buf, size_nan) == 0) ||\n\t         (strncmp(json_nan_str, tok->pb->buf, size_nan) == 0)\n\t        )\n\t{\n\t\tif (tok->st_pos == json_nan_str_len)\n\t\t{\n\t\t\tcurrent = json_object_new_double(NAN);\n\t\t\tsaved_state = json_tokener_state_finish;\n\t\t\tstate = json_tokener_state_eatws;\n\t\t\tgoto redo_char;\n\t\t}\n\t} else {\n\t  tok->err = json_tokener_error_parse_null;\n\t  goto out;\n\t}\n\ttok->st_pos++;\n      }\n      break;\n\n    case json_tokener_state_comment_start:\n      if(c == '*') {\n\tstate = json_tokener_state_comment;\n      } else if(c == '/') {\n\tstate = json_tokener_state_comment_eol;\n      } else {\n\ttok->err = json_tokener_error_parse_comment;\n\tgoto out;\n      }\n      printbuf_memappend_fast(tok->pb, &c, 1);\n      break;\n\n    case json_tokener_state_comment:\n              {\n          /* Advance until we change state */\n          const char *case_start = str;\n          while(c != '*') {\n            if (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok)) {\n              printbuf_memappend_fast(tok->pb, case_start, str-case_start);\n              goto out;\n            }\n          }\n          printbuf_memappend_fast(tok->pb, case_start, 1+str-case_start);\n          state = json_tokener_state_comment_end;\n        }\n            break;\n\n    case json_tokener_state_comment_eol:\n      {\n\t/* Advance until we change state */\n\tconst char *case_start = str;\n\twhile(c != '\\n') {\n\t  if (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok)) {\n\t    printbuf_memappend_fast(tok->pb, case_start, str-case_start);\n\t    goto out;\n\t  }\n\t}\n\tprintbuf_memappend_fast(tok->pb, case_start, str-case_start);\n\tMC_DEBUG(\"json_tokener_comment: %s\\n\", tok->pb->buf);\n\tstate = json_tokener_state_eatws;\n      }\n      break;\n\n    case json_tokener_state_comment_end:\n      printbuf_memappend_fast(tok->pb, &c, 1);\n      if(c == '/') {\n\tMC_DEBUG(\"json_tokener_comment: %s\\n\", tok->pb->buf);\n\tstate = json_tokener_state_eatws;\n      } else {\n\tstate = json_tokener_state_comment;\n      }\n      break;\n\n    case json_tokener_state_string:\n      {\n\t/* Advance until we change state */\n\tconst char *case_start = str;\n\twhile(1) {\n\t  if(c == tok->quote_char) {\n\t    printbuf_memappend_fast(tok->pb, case_start, str-case_start);\n\t    current = json_object_new_string_len(tok->pb->buf, tok->pb->bpos);\n\t    saved_state = json_tokener_state_finish;\n\t    state = json_tokener_state_eatws;\n\t    break;\n\t  } else if(c == '\\\\') {\n\t    printbuf_memappend_fast(tok->pb, case_start, str-case_start);\n\t    saved_state = json_tokener_state_string;\n\t    state = json_tokener_state_string_escape;\n\t    break;\n\t  }\n\t  if (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok)) {\n\t    printbuf_memappend_fast(tok->pb, case_start, str-case_start);\n\t    goto out;\n\t  }\n\t}\n      }\n      break;\n\n    case json_tokener_state_string_escape:\n      switch(c) {\n      case '\"':\n      case '\\\\':\n      case '/':\n\tprintbuf_memappend_fast(tok->pb, &c, 1);\n\tstate = saved_state;\n\tbreak;\n      case 'b':\n      case 'n':\n      case 'r':\n      case 't':\n      case 'f':\n\tif(c == 'b') printbuf_memappend_fast(tok->pb, \"\\b\", 1);\n\telse if(c == 'n') printbuf_memappend_fast(tok->pb, \"\\n\", 1);\n\telse if(c == 'r') printbuf_memappend_fast(tok->pb, \"\\r\", 1);\n\telse if(c == 't') printbuf_memappend_fast(tok->pb, \"\\t\", 1);\n\telse if(c == 'f') printbuf_memappend_fast(tok->pb, \"\\f\", 1);\n\tstate = saved_state;\n\tbreak;\n      case 'u':\n\ttok->ucs_char = 0;\n\ttok->st_pos = 0;\n\tstate = json_tokener_state_escape_unicode;\n\tbreak;\n      default:\n\ttok->err = json_tokener_error_parse_string;\n\tgoto out;\n      }\n      break;\n\n    case json_tokener_state_escape_unicode:\n\t{\n          unsigned int got_hi_surrogate = 0;\n\n\t  /* Handle a 4-byte sequence, or two sequences if a surrogate pair */\n\t  while(1) {\n\t    if(strchr(json_hex_chars, c)) {\n\t      tok->ucs_char += ((unsigned int)hexdigit(c) << ((3-tok->st_pos++)*4));\n\t      if(tok->st_pos == 4) {\n\t\tunsigned char unescaped_utf[4];\n\n                if (got_hi_surrogate) {\n\t\t  if (IS_LOW_SURROGATE(tok->ucs_char)) {\n                    /* Recalculate the ucs_char, then fall thru to process normally */\n                    tok->ucs_char = DECODE_SURROGATE_PAIR(got_hi_surrogate, tok->ucs_char);\n                  } else {\n                    /* Hi surrogate was not followed by a low surrogate */\n                    /* Replace the hi and process the rest normally */\n\t\t    printbuf_memappend_fast(tok->pb, (char*)utf8_replacement_char, 3);\n                  }\n                  got_hi_surrogate = 0;\n                }\n\n\t\tif (tok->ucs_char < 0x80) {\n\t\t  unescaped_utf[0] = tok->ucs_char;\n\t\t  printbuf_memappend_fast(tok->pb, (char*)unescaped_utf, 1);\n\t\t} else if (tok->ucs_char < 0x800) {\n\t\t  unescaped_utf[0] = 0xc0 | (tok->ucs_char >> 6);\n\t\t  unescaped_utf[1] = 0x80 | (tok->ucs_char & 0x3f);\n\t\t  printbuf_memappend_fast(tok->pb, (char*)unescaped_utf, 2);\n\t\t} else if (IS_HIGH_SURROGATE(tok->ucs_char)) {\n                  /* Got a high surrogate.  Remember it and look for the\n                   * the beginning of another sequence, which should be the\n                   * low surrogate.\n                   */\n                  got_hi_surrogate = tok->ucs_char;\n                  /* Not at end, and the next two chars should be \"\\u\" */\n                  if ((tok->char_offset+1 != len) &&\n                      (tok->char_offset+2 != len) &&\n                      (str[1] == '\\\\') &&\n                      (str[2] == 'u'))\n                  {\n                /* Advance through the 16 bit surrogate, and move on to the\n                 * next sequence. The next step is to process the following\n                 * characters.\n                 */\n\t            if( !ADVANCE_CHAR(str, tok) || !ADVANCE_CHAR(str, tok) ) {\n                    printbuf_memappend_fast(tok->pb, (char*)utf8_replacement_char, 3);\n                }\n                    /* Advance to the first char of the next sequence and\n                     * continue processing with the next sequence.\n                     */\n\t            if (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok)) {\n\t              printbuf_memappend_fast(tok->pb, (char*)utf8_replacement_char, 3);\n\t              goto out;\n                    }\n\t            tok->ucs_char = 0;\n                    tok->st_pos = 0;\n                    continue; /* other json_tokener_state_escape_unicode */\n                  } else {\n                    /* Got a high surrogate without another sequence following\n                     * it.  Put a replacement char in for the hi surrogate\n                     * and pretend we finished.\n                     */\n\t\t    printbuf_memappend_fast(tok->pb, (char*)utf8_replacement_char, 3);\n                  }\n\t\t} else if (IS_LOW_SURROGATE(tok->ucs_char)) {\n                  /* Got a low surrogate not preceded by a high */\n\t\t  printbuf_memappend_fast(tok->pb, (char*)utf8_replacement_char, 3);\n                } else if (tok->ucs_char < 0x10000) {\n\t\t  unescaped_utf[0] = 0xe0 | (tok->ucs_char >> 12);\n\t\t  unescaped_utf[1] = 0x80 | ((tok->ucs_char >> 6) & 0x3f);\n\t\t  unescaped_utf[2] = 0x80 | (tok->ucs_char & 0x3f);\n\t\t  printbuf_memappend_fast(tok->pb, (char*)unescaped_utf, 3);\n\t\t} else if (tok->ucs_char < 0x110000) {\n\t\t  unescaped_utf[0] = 0xf0 | ((tok->ucs_char >> 18) & 0x07);\n\t\t  unescaped_utf[1] = 0x80 | ((tok->ucs_char >> 12) & 0x3f);\n\t\t  unescaped_utf[2] = 0x80 | ((tok->ucs_char >> 6) & 0x3f);\n\t\t  unescaped_utf[3] = 0x80 | (tok->ucs_char & 0x3f);\n\t\t  printbuf_memappend_fast(tok->pb, (char*)unescaped_utf, 4);\n\t\t} else {\n                  /* Don't know what we got--insert the replacement char */\n\t\t  printbuf_memappend_fast(tok->pb, (char*)utf8_replacement_char, 3);\n                }\n\t\tstate = saved_state;\n\t\tbreak;\n\t      }\n\t    } else {\n\t      tok->err = json_tokener_error_parse_string;\n\t      goto out;\n\t    }\n\t  if (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok)) {\n            if (got_hi_surrogate) /* Clean up any pending chars */\n\t      printbuf_memappend_fast(tok->pb, (char*)utf8_replacement_char, 3);\n\t    goto out;\n\t  }\n\t}\n      }\n      break;\n\n    case json_tokener_state_boolean:\n      {\n\tint size1, size2;\n\tprintbuf_memappend_fast(tok->pb, &c, 1);\n\tsize1 = json_min(tok->st_pos+1, json_true_str_len);\n\tsize2 = json_min(tok->st_pos+1, json_false_str_len);\n\tif((!(tok->flags & JSON_TOKENER_STRICT) &&\n\t  strncasecmp(json_true_str, tok->pb->buf, size1) == 0)\n\t  || (strncmp(json_true_str, tok->pb->buf, size1) == 0)\n\t  ) {\n\t  if(tok->st_pos == json_true_str_len) {\n\t    current = json_object_new_boolean(1);\n\t    saved_state = json_tokener_state_finish;\n\t    state = json_tokener_state_eatws;\n\t    goto redo_char;\n\t  }\n\t} else if((!(tok->flags & JSON_TOKENER_STRICT) &&\n\t  strncasecmp(json_false_str, tok->pb->buf, size2) == 0)\n\t  || (strncmp(json_false_str, tok->pb->buf, size2) == 0)) {\n\t  if(tok->st_pos == json_false_str_len) {\n\t    current = json_object_new_boolean(0);\n\t    saved_state = json_tokener_state_finish;\n\t    state = json_tokener_state_eatws;\n\t    goto redo_char;\n\t  }\n\t} else {\n\t  tok->err = json_tokener_error_parse_boolean;\n\t  goto out;\n\t}\n\ttok->st_pos++;\n      }\n      break;\n\n    case json_tokener_state_number:\n      {\n\t/* Advance until we change state */\n\tconst char *case_start = str;\n\tint case_len=0;\n\twhile(c && strchr(json_number_chars, c)) {\n\t  ++case_len;\n\t  if(c == '.' || c == 'e' || c == 'E')\n\t    tok->is_double = 1;\n\t  if (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok)) {\n\t    printbuf_memappend_fast(tok->pb, case_start, case_len);\n\t    goto out;\n\t  }\n\t}\n        if (case_len>0)\n          printbuf_memappend_fast(tok->pb, case_start, case_len);\n\n\tif (tok->pb->buf[0] == '-' && case_len == 1 &&\n\t    (c == 'i' || c == 'I'))\n\t{\n\t\tstate = json_tokener_state_inf;\n\t\tgoto redo_char;\n\t}\n      }\n      {\n\tint64_t num64;\n\tdouble  numd;\n\tif (!tok->is_double && json_parse_int64(tok->pb->buf, &num64) == 0) {\n\t\tif (num64 && tok->pb->buf[0]=='0' && (tok->flags & JSON_TOKENER_STRICT)) {\n\t\t\t/* in strict mode, number must not start with 0 */\n\t\t\ttok->err = json_tokener_error_parse_number;\n\t\t\tgoto out;\n\t\t}\n\t\tcurrent = json_object_new_int64(num64);\n\t}\n\telse if(tok->is_double && json_parse_double(tok->pb->buf, &numd) == 0)\n\t{\n          current = json_object_new_double_s(numd, tok->pb->buf);\n        } else {\n          tok->err = json_tokener_error_parse_number;\n          goto out;\n        }\n        saved_state = json_tokener_state_finish;\n        state = json_tokener_state_eatws;\n        goto redo_char;\n      }\n      break;\n\n    case json_tokener_state_array_after_sep:\n    case json_tokener_state_array:\n      if(c == ']') {\n\t\tif (state == json_tokener_state_array_after_sep &&\n\t\t\t(tok->flags & JSON_TOKENER_STRICT))\n\t\t{\n\t\t\ttok->err = json_tokener_error_parse_unexpected;\n\t\t\tgoto out;\n\t\t}\n\tsaved_state = json_tokener_state_finish;\n\tstate = json_tokener_state_eatws;\n      } else {\n\tif(tok->depth >= tok->max_depth-1) {\n\t  tok->err = json_tokener_error_depth;\n\t  goto out;\n\t}\n\tstate = json_tokener_state_array_add;\n\ttok->depth++;\n\tjson_tokener_reset_level(tok, tok->depth);\n\tgoto redo_char;\n      }\n      break;\n\n    case json_tokener_state_array_add:\n      json_object_array_add(current, obj);\n      saved_state = json_tokener_state_array_sep;\n      state = json_tokener_state_eatws;\n      goto redo_char;\n\n    case json_tokener_state_array_sep:\n      if(c == ']') {\n\tsaved_state = json_tokener_state_finish;\n\tstate = json_tokener_state_eatws;\n      } else if(c == ',') {\n\tsaved_state = json_tokener_state_array_after_sep;\n\tstate = json_tokener_state_eatws;\n      } else {\n\ttok->err = json_tokener_error_parse_array;\n\tgoto out;\n      }\n      break;\n\n    case json_tokener_state_object_field_start:\n    case json_tokener_state_object_field_start_after_sep:\n      if(c == '}') {\n\t\tif (state == json_tokener_state_object_field_start_after_sep &&\n\t\t    (tok->flags & JSON_TOKENER_STRICT))\n\t\t{\n\t\t\ttok->err = json_tokener_error_parse_unexpected;\n\t\t\tgoto out;\n\t\t}\n\tsaved_state = json_tokener_state_finish;\n\tstate = json_tokener_state_eatws;\n      } else if (c == '\"' || c == '\\'') {\n\ttok->quote_char = c;\n\tprintbuf_reset(tok->pb);\n\tstate = json_tokener_state_object_field;\n      } else {\n\ttok->err = json_tokener_error_parse_object_key_name;\n\tgoto out;\n      }\n      break;\n\n    case json_tokener_state_object_field:\n      {\n\t/* Advance until we change state */\n\tconst char *case_start = str;\n\twhile(1) {\n\t  if(c == tok->quote_char) {\n\t    printbuf_memappend_fast(tok->pb, case_start, str-case_start);\n\t    obj_field_name = strdup(tok->pb->buf);\n\t    saved_state = json_tokener_state_object_field_end;\n\t    state = json_tokener_state_eatws;\n\t    break;\n\t  } else if(c == '\\\\') {\n\t    printbuf_memappend_fast(tok->pb, case_start, str-case_start);\n\t    saved_state = json_tokener_state_object_field;\n\t    state = json_tokener_state_string_escape;\n\t    break;\n\t  }\n\t  if (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok)) {\n\t    printbuf_memappend_fast(tok->pb, case_start, str-case_start);\n\t    goto out;\n\t  }\n\t}\n      }\n      break;\n\n    case json_tokener_state_object_field_end:\n      if(c == ':') {\n\tsaved_state = json_tokener_state_object_value;\n\tstate = json_tokener_state_eatws;\n      } else {\n\ttok->err = json_tokener_error_parse_object_key_sep;\n\tgoto out;\n      }\n      break;\n\n    case json_tokener_state_object_value:\n      if(tok->depth >= tok->max_depth-1) {\n\ttok->err = json_tokener_error_depth;\n\tgoto out;\n      }\n      state = json_tokener_state_object_value_add;\n      tok->depth++;\n      json_tokener_reset_level(tok, tok->depth);\n      goto redo_char;\n\n    case json_tokener_state_object_value_add:\n      json_object_object_add(current, obj_field_name, obj);\n      free(obj_field_name);\n      obj_field_name = NULL;\n      saved_state = json_tokener_state_object_sep;\n      state = json_tokener_state_eatws;\n      goto redo_char;\n\n    case json_tokener_state_object_sep:\n      if(c == '}') {\n\tsaved_state = json_tokener_state_finish;\n\tstate = json_tokener_state_eatws;\n      } else if(c == ',') {\n\tsaved_state = json_tokener_state_object_field_start_after_sep;\n\tstate = json_tokener_state_eatws;\n      } else {\n\ttok->err = json_tokener_error_parse_object_value_sep;\n\tgoto out;\n      }\n      break;\n\n    }\n    if (!ADVANCE_CHAR(str, tok))\n      goto out;\n  } /* while(POP_CHAR) */\n", "target": 1, "idx": 179711}
{"func": "status_t OMXNodeInstance::updateNativeHandleInMeta(\n        OMX_U32 portIndex, const sp<NativeHandle>& nativeHandle, OMX::buffer_id buffer) {\n Mutex::Autolock autoLock(mLock);\n    OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer, portIndex);\n if (header == NULL) {\n        ALOGE(\"b/25884056\");\n return BAD_VALUE;\n }\n\n if (portIndex != kPortIndexInput && portIndex != kPortIndexOutput) {\n return BAD_VALUE;\n\n     }\n \n     BufferMeta *bufferMeta = (BufferMeta *)(header->pAppPrivate);\n     sp<ABuffer> data = bufferMeta->getBuffer(\n             header, false /* backup */, false /* limit */);\n     bufferMeta->setNativeHandle(nativeHandle);\n if (mMetadataType[portIndex] == kMetadataBufferTypeNativeHandleSource\n && data->capacity() >= sizeof(VideoNativeHandleMetadata)) {\n VideoNativeHandleMetadata &metadata = *(VideoNativeHandleMetadata *)(data->data());\n        metadata.eType = mMetadataType[portIndex];\n        metadata.pHandle =\n            nativeHandle == NULL ? NULL : const_cast<native_handle*>(nativeHandle->handle());\n } else {\n        CLOG_ERROR(updateNativeHandleInMeta, BAD_VALUE, \"%s:%u, %#x bad type (%d) or size (%zu)\",\n            portString(portIndex), portIndex, buffer, mMetadataType[portIndex], data->capacity());\n return BAD_VALUE;\n }\n\n    CLOG_BUFFER(updateNativeHandleInMeta, \"%s:%u, %#x := %p\",\n            portString(portIndex), portIndex, buffer,\n            nativeHandle == NULL ? NULL : nativeHandle->handle());\n return OK;\n}\n", "target": 1, "idx": 188168}
{"func": "int main(int argc, char *argv[])\n{\n    opj_dinfo_t* dinfo;\n    opj_event_mgr_t event_mgr;      /* event manager */\n    int tnum;\n    unsigned int snum;\n    opj_mj2_t *movie;\n    mj2_tk_t *track;\n    mj2_sample_t *sample;\n    unsigned char* frame_codestream;\n    FILE *file, *outfile;\n    char outfilename[50];\n    mj2_dparameters_t parameters;\n\n    if (argc != 3) {\n        printf(\"Usage: %s mj2filename output_location\\n\", argv[0]);\n        printf(\"Example: %s foreman.mj2 output/foreman\\n\", argv[0]);\n        return 1;\n    }\n\n    file = fopen(argv[1], \"rb\");\n\n    if (!file) {\n        fprintf(stderr, \"failed to open %s for reading\\n\", argv[1]);\n        return 1;\n    }\n\n    /*\n    configure the event callbacks (not required)\n    setting of each callback is optional\n    */\n    memset(&event_mgr, 0, sizeof(opj_event_mgr_t));\n    event_mgr.error_handler = error_callback;\n    event_mgr.warning_handler = warning_callback;\n    event_mgr.info_handler = info_callback;\n\n    /* get a MJ2 decompressor handle */\n    dinfo = mj2_create_decompress();\n\n    /* catch events using our callbacks and give a local context */\n    opj_set_event_mgr((opj_common_ptr)dinfo, &event_mgr, stderr);\n\n    /* setup the decoder decoding parameters using user parameters */\n    memset(&parameters, 0, sizeof(mj2_dparameters_t));\n    movie = (opj_mj2_t*) dinfo->mj2_handle;\n    mj2_setup_decoder(movie, &parameters);\n\n    if (mj2_read_struct(file, movie)) { /* Creating the movie structure*/\n        return 1;\n    }\n\n    /* Decode first video track */\n    tnum = 0;\n    while (movie->tk[tnum].track_type != 0) {\n        tnum ++;\n    }\n\n    track = &movie->tk[tnum];\n\n    fprintf(stdout, \"Extracting %d frames from file...\\n\", track->num_samples);\n\n    for (snum = 0; snum < track->num_samples; snum++) {\n        sample = &track->sample[snum];\n        frame_codestream = (unsigned char*) malloc(sample->sample_size -\n                           8); /* Skipping JP2C marker*/\n        fseek(file, sample->offset + 8, SEEK_SET);\n         fread(frame_codestream, sample->sample_size - 8, 1,\n               file); /* Assuming that jp and ftyp markers size do*/\n \n        sprintf(outfilename, \"%s_%05d.j2k\", argv[2], snum);\n         outfile = fopen(outfilename, \"wb\");\n         if (!outfile) {\n             fprintf(stderr, \"failed to open %s for writing\\n\", outfilename);\n            return 1;\n        }\n        fwrite(frame_codestream, sample->sample_size - 8, 1, outfile);\n        fclose(outfile);\n        free(frame_codestream);\n    }\n    fclose(file);\n    fprintf(stdout, \"%d frames correctly extracted\\n\", snum);\n\n    /* free remaining structures */\n    if (dinfo) {\n        mj2_destroy_decompress((opj_mj2_t*)dinfo->mj2_handle);\n    }\n\n    return 0;\n}\n", "target": 1, "idx": 182479}
{"func": "grub_ext2_iterate_dir (grub_fshelp_node_t dir,\n\t\t       int (*hook) (const char *filename,\n\t\t\t\t    enum grub_fshelp_filetype filetype,\n\t\t\t\t    grub_fshelp_node_t node,\n\t\t\t\t    void *closure),\n\t\t       void *closure)\n{\n  unsigned int fpos = 0;\n  struct grub_fshelp_node *diro = (struct grub_fshelp_node *) dir;\n\n  if (! diro->inode_read)\n    {\n      grub_ext2_read_inode (diro->data, diro->ino, &diro->inode);\n      if (grub_errno)\n\treturn 0;\n    }\n\n  /* Search the file.  */\n  if (hook)\n  while (fpos < grub_le_to_cpu32 (diro->inode.size))\n    {\n      struct ext2_dirent dirent;\n\n      grub_ext2_read_file (diro, NULL, NULL, 0, fpos, sizeof (dirent),\n\t\t\t   (char *) &dirent);\n      if (grub_errno)\n\treturn 0;\n\n      if (dirent.direntlen == 0)\n        return 0;\n \n       if (dirent.namelen != 0)\n \t{\n#ifndef _MSC_VER\n\t  char filename[dirent.namelen + 1]; \n#else\n \t  char * filename = grub_malloc (dirent.namelen + 1);\n#endif\n \t  struct grub_fshelp_node *fdiro;\n \t  enum grub_fshelp_filetype type = GRUB_FSHELP_UNKNOWN;\n \n \t  grub_ext2_read_file (diro, 0, 0, 0,\n \t\t\t       fpos + sizeof (struct ext2_dirent),\n \t\t\t       dirent.namelen, filename);\n\t  if (grub_errno)\n \t    return 0;\n \n \t  fdiro = grub_malloc (sizeof (struct grub_fshelp_node));\n\t  if (! fdiro)\n \t    return 0;\n \n \t  fdiro->data = diro->data;\n \t  fdiro->ino = grub_le_to_cpu32 (dirent.inode);\n\n\t  filename[dirent.namelen] = '\\0';\n\n\t  if (dirent.filetype != FILETYPE_UNKNOWN)\n\t    {\n\t      fdiro->inode_read = 0;\n\n\t      if (dirent.filetype == FILETYPE_DIRECTORY)\n\t\ttype = GRUB_FSHELP_DIR;\n\t      else if (dirent.filetype == FILETYPE_SYMLINK)\n\t\ttype = GRUB_FSHELP_SYMLINK;\n\t      else if (dirent.filetype == FILETYPE_REG)\n\t\ttype = GRUB_FSHELP_REG;\n\t    }\n\t  else\n\t    {\n\t      /* The filetype can not be read from the dirent, read\n\t\t the inode to get more information.  */\n \t      grub_ext2_read_inode (diro->data,\n                                     grub_le_to_cpu32 (dirent.inode),\n \t\t\t\t    &fdiro->inode);\n\t      if (grub_errno)\n\t\t{\n \t\t  grub_free (fdiro);\n \t\t  return 0;\n \t\t}\n\n\t      fdiro->inode_read = 1;\n\n\t      if ((grub_le_to_cpu16 (fdiro->inode.mode)\n\t\t   & FILETYPE_INO_MASK) == FILETYPE_INO_DIRECTORY)\n\t\ttype = GRUB_FSHELP_DIR;\n\t      else if ((grub_le_to_cpu16 (fdiro->inode.mode)\n\t\t\t& FILETYPE_INO_MASK) == FILETYPE_INO_SYMLINK)\n\t\ttype = GRUB_FSHELP_SYMLINK;\n\t      else if ((grub_le_to_cpu16 (fdiro->inode.mode)\n\t\t\t& FILETYPE_INO_MASK) == FILETYPE_INO_REG)\n \t\ttype = GRUB_FSHELP_REG;\n \t    }\n \n\t  if (hook (filename, type, fdiro, closure))\n \t    return 1;\n \t}\n \n       fpos += grub_le_to_cpu16 (dirent.direntlen);\n    }\n\n  return 0;\n}\n", "target": 1, "idx": 181254}
{"func": "bool IDNSpoofChecker::SafeToDisplayAsUnicode(base::StringPiece16 label,\n                                             bool is_tld_ascii) {\n  UErrorCode status = U_ZERO_ERROR;\n  int32_t result =\n      uspoof_check(checker_, label.data(),\n                   base::checked_cast<int32_t>(label.size()), nullptr, &status);\n  if (U_FAILURE(status) || (result & USPOOF_ALL_CHECKS))\n    return false;\n\n  icu::UnicodeString label_string(FALSE, label.data(),\n                                  base::checked_cast<int32_t>(label.size()));\n\n  if (deviation_characters_.containsSome(label_string))\n    return false;\n\n  result &= USPOOF_RESTRICTION_LEVEL_MASK;\n  if (result == USPOOF_ASCII)\n    return true;\n  if (result == USPOOF_SINGLE_SCRIPT_RESTRICTIVE &&\n      kana_letters_exceptions_.containsNone(label_string) &&\n      combining_diacritics_exceptions_.containsNone(label_string)) {\n    return !is_tld_ascii || !IsMadeOfLatinAlikeCyrillic(label_string);\n  }\n\n  if (non_ascii_latin_letters_.containsSome(label_string) &&\n      !lgc_letters_n_ascii_.containsAll(label_string))\n    return false;\n\n  icu::RegexMatcher* dangerous_pattern =\n      reinterpret_cast<icu::RegexMatcher*>(DangerousPatternTLS().Get());\n  if (!dangerous_pattern) {\n        icu::UnicodeString(\n            R\"([^\\p{scx=kana}\\p{scx=hira}\\p{scx=hani}])\"\n            R\"([\\u30ce\\u30f3\\u30bd\\u30be])\"\n            R\"([^\\p{scx=kana}\\p{scx=hira}\\p{scx=hani}]|)\"\n            R\"([^\\p{scx=kana}\\p{scx=hira}]\\u30fc|^\\u30fc|)\"\n            R\"([^\\p{scx=kana}][\\u30fd\\u30fe]|^[\\u30fd\\u30fe]|)\"\n            R\"(^[\\p{scx=kana}]+[\\u3078-\\u307a][\\p{scx=kana}]+$|)\"\n            R\"(^[\\p{scx=hira}]+[\\u30d8-\\u30da][\\p{scx=hira}]+$|)\"\n            R\"([a-z]\\u30fb|\\u30fb[a-z]|)\"\n            R\"([^\\p{scx=latn}\\p{scx=grek}\\p{scx=cyrl}][\\u0300-\\u0339]|)\"\n            R\"(\\u0131[\\u0300-\\u0339]|)\"\n            R\"([ijl]\\u0307)\",\n            -1, US_INV),\n        0, status);\n    DangerousPatternTLS().Set(dangerous_pattern);\n  }\n  dangerous_pattern->reset(label_string);\n  return !dangerous_pattern->find();\n}\n", "target": 1, "idx": 187141}
{"func": "PluginInstance* PluginModule::GetSomeInstance() const {\n  CHECK(!instances_.empty());\n  return *instances_.begin();\n}\n", "target": 0, "idx": 110376}
{"func": "void ShelfLayoutManager::OnFirstWallpaperShown() {\n  MaybeUpdateShelfBackground(AnimationChangeType::ANIMATE);\n}\n", "target": 0, "idx": 142458}
{"func": "begin_softmask(fz_context *ctx, pdf_run_processor *pr, softmask_save *save)\n{\n\tpdf_gstate *gstate = pr->gstate + pr->gtop;\n\tpdf_xobject *softmask = gstate->softmask;\n\tfz_rect mask_bbox;\n\tfz_matrix tos_save[2], save_ctm;\n\tfz_matrix mask_matrix;\n\tfz_colorspace *mask_colorspace;\n\n\tsave->softmask = softmask;\n\tif (softmask == NULL)\n\t\treturn gstate;\n\tsave->page_resources = gstate->softmask_resources;\n\tsave->ctm = gstate->softmask_ctm;\n\tsave_ctm = gstate->ctm;\n\n\tpdf_xobject_bbox(ctx, softmask, &mask_bbox);\n\tpdf_xobject_matrix(ctx, softmask, &mask_matrix);\n\n\tpdf_tos_save(ctx, &pr->tos, tos_save);\n\n\tif (gstate->luminosity)\n\t\tmask_bbox = fz_infinite_rect;\n\telse\n\t{\n\t\tfz_transform_rect(&mask_bbox, &mask_matrix);\n\t\tfz_transform_rect(&mask_bbox, &gstate->softmask_ctm);\n\t}\n\tgstate->softmask = NULL;\n\tgstate->softmask_resources = NULL;\n\tgstate->ctm = gstate->softmask_ctm;\n\n        mask_colorspace = pdf_xobject_colorspace(ctx, softmask);\n \n        if (gstate->luminosity && !mask_colorspace)\n               mask_colorspace = fz_device_gray(ctx);\n \n        fz_try(ctx)\n        {\n\t\tfz_begin_mask(ctx, pr->dev, &mask_bbox, gstate->luminosity, mask_colorspace, gstate->softmask_bc, &gstate->fill.color_params);\n\t\tpdf_run_xobject(ctx, pr, softmask, save->page_resources, &fz_identity, 1);\n\t}\n\tfz_always(ctx)\n\t\tfz_drop_colorspace(ctx, mask_colorspace);\n\tfz_catch(ctx)\n\t{\n\t\tfz_rethrow_if(ctx, FZ_ERROR_TRYLATER);\n\t\t/* FIXME: Ignore error - nasty, but if we throw from\n\t\t * here the clip stack would be messed up. */\n\t\t/* TODO: pass cookie here to increase the cookie error count */\n\t}\n\n\tfz_end_mask(ctx, pr->dev);\n\n\tpdf_tos_restore(ctx, &pr->tos, tos_save);\n\n\tgstate = pr->gstate + pr->gtop;\n\tgstate->ctm = save_ctm;\n\n\treturn gstate;\n}\n", "target": 1, "idx": 177750}
{"func": "static inline void build_tablename(smart_str *querystr, PGconn *pg_link, const char *table) /* {{{ */\n{\n\tchar *table_copy, *escaped, *token, *tmp;\n\tsize_t len;\n\n        /* schame.table should be \"schame\".\"table\" */\n        table_copy = estrdup(table);\n        token = php_strtok_r(table_copy, \".\", &tmp);\n        len = strlen(token);\n        if (_php_pgsql_detect_identifier_escape(token, len) == SUCCESS) {\n                smart_str_appendl(querystr, token, len);\n\t\tPGSQLfree(escaped);\n\t}\n\tif (tmp && *tmp) {\n\t\tlen = strlen(tmp);\n\t\t/* \"schema\".\"table\" format */\n\t\tif (_php_pgsql_detect_identifier_escape(tmp, len) == SUCCESS) {\n\t\t\tsmart_str_appendc(querystr, '.');\n\t\t\tsmart_str_appendl(querystr, tmp, len);\n\t\t} else {\n\t\t\tescaped = PGSQLescapeIdentifier(pg_link, tmp, len);\n\t\t\tsmart_str_appendc(querystr, '.');\n\t\t\tsmart_str_appends(querystr, escaped);\n\t\t\tPGSQLfree(escaped);\n\t\t}\n\t}\n\tefree(table_copy);\n}\n/* }}} */\n", "target": 1, "idx": 177941}
{"func": "bool BlobURLRequestJob::ReadItem() {\n  if (remaining_bytes_ == 0)\n    return true;\n\n  if (item_index_ >= blob_data_->items().size()) {\n    NotifyFailure(net::ERR_FAILED);\n    return false;\n  }\n\n  bytes_to_read_ = ComputeBytesToRead();\n\n  if (bytes_to_read_ == 0) {\n    AdvanceItem();\n    return ReadItem();\n  }\n\n  const BlobData::Item& item = blob_data_->items().at(item_index_);\n  switch (item.type()) {\n    case BlobData::TYPE_DATA:\n      return ReadBytes(item);\n    case BlobData::TYPE_FILE:\n      return DispatchReadFile(item);\n    default:\n      DCHECK(false);\n      return false;\n  }\n}\n", "target": 0, "idx": 106422}
{"func": "char *my_asctime(time_t t)\n{\n\tstruct tm *tm;\n\tchar *str;\n         int len;\n \n \ttm = localtime(&t);\n \tstr = g_strdup(asctime(tm));\n \n \tlen = strlen(str);\n\tif (len > 0) str[len-1] = '\\0';\n        return str;\n}\n", "target": 1, "idx": 181228}
{"func": "error::Error GLES2DecoderImpl::HandleDeleteShader(uint32 immediate_data_size,\n                                                  const void* cmd_data) {\n  const gles2::cmds::DeleteShader& c =\n      *static_cast<const gles2::cmds::DeleteShader*>(cmd_data);\n  GLuint client_id = c.shader;\n  if (client_id) {\n    Shader* shader = GetShader(client_id);\n    if (shader) {\n      if (!shader->IsDeleted()) {\n        shader_manager()->Delete(shader);\n      }\n    } else {\n      LOCAL_SET_GL_ERROR(GL_INVALID_VALUE, \"glDeleteShader\", \"unknown shader\");\n    }\n  }\n  return error::kNoError;\n}\n", "target": 0, "idx": 140784}
{"func": "cJSON *cJSON_GetObjectItem( cJSON *object, const char *string )\n{\n\tcJSON *c = object->child;\n\twhile ( c && cJSON_strcasecmp( c->string, string ) )\n\t\tc = c->next;\n\treturn c;\n}\n", "target": 1, "idx": 180461}
{"func": "set_debug_options(const char *options)\n{\n\tchar all_processes, processes;\n\tchar opt;\n\tconst char *opt_p = options;\n\n#ifdef _DEBUG_\n\tall_processes = 1;\n#else\n\tall_processes = (1 << PROG_TYPE_PARENT);\n#if _WITH_BFD_\n\tall_processes |= (1 << PROG_TYPE_BFD);\n#endif\n#if _WITH_LVS_\n\tall_processes |= (1 << PROG_TYPE_CHECKER);\n#endif\n#if _WITH_VRRP_\n\tall_processes |= (1 << PROG_TYPE_VRRP);\n#endif\n#endif\n\n\tif (!options) {\n#ifdef _TIMER_CHECK_\n\t\ttimer_debug = all_processes;\n#endif\n#ifdef _SMTP_ALERT_DEBUG_\n\t\tsmtp_debug = all_processes;\n#endif\n#ifdef _EPOLL_DEBUG_\n\t\tepoll_debug = all_processes;\n#endif\n#ifdef _EPOLL_THREAD_DUMP_\n\t\tepoll_thread_debug = all_processes;\n#endif\n#ifdef _REGEX_DEBUG_\n\t\tregex_debug = all_processes;\n#endif\n#ifdef _WITH_REGEX_TIMERS_\n\t\tregex_timers = all_processes;\n#endif\n#ifdef _TSM_DEBUG_\n\t\ttsm_debug = all_processes;\n#endif\n#ifdef _VRRP_FD_DEBUG_\n\t\tvrrp_fd_debug = all_processes;\n#endif\n#ifdef _NETLINK_TIMERS_\n\t\tnetlink_timer_debug = all_processes;\n#endif\n\n\t\treturn;\n\t}\n\n\topt_p = options;\n\tdo {\n\t\tif (!isupper(*opt_p)) {\n\t\t\tfprintf(stderr, \"Unknown debug option'%c' in '%s'\\n\", *opt_p, options);\n\t\t\treturn;\n\t\t}\n\t\topt = *opt_p++;\n\n#ifdef _DEBUG_\n\t\tprocesses = all_processes;\n#else\n\t\tif (!*opt_p || isupper(*opt_p))\n\t\t\tprocesses = all_processes;\n\t\telse {\n\t\t\tprocesses = 0;\n\t\t\twhile (*opt_p && !isupper(*opt_p)) {\n\t\t\t\tswitch (*opt_p) {\n\t\t\t\tcase 'p':\n\t\t\t\t\tprocesses |= (1 << PROG_TYPE_PARENT);\n\t\t\t\t\tbreak;\n#if _WITH_BFD_\n\t\t\t\tcase 'b':\n\t\t\t\t\tprocesses |= (1 << PROG_TYPE_BFD);\n\t\t\t\t\tbreak;\n#endif\n#if _WITH_LVS_\n\t\t\t\tcase 'c':\n\t\t\t\t\tprocesses |= (1 << PROG_TYPE_CHECKER);\n\t\t\t\t\tbreak;\n#endif\n#if _WITH_VRRP_\n\t\t\t\tcase 'v':\n\t\t\t\t\tprocesses |= (1 << PROG_TYPE_VRRP);\n\t\t\t\t\tbreak;\n#endif\n\t\t\t\tdefault:\n\t\t\t\t\tfprintf(stderr, \"Unknown debug process '%c' in '%s'\\n\", *opt_p, options);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\topt_p++;\n\t\t\t}\n\t\t}\n#endif\n\n\t\tswitch (opt) {\n#ifdef _TIMER_CHECK_\n\t\tcase 'T':\n\t\t\ttimer_debug = processes;\n\t\t\tbreak;\n#endif\n#ifdef _SMTP_ALERT_DEBUG_\n\t\tcase 'M':\n\t\t\tsmtp_debug = processes;\n\t\t\tbreak;\n#endif\n#ifdef _EPOLL_DEBUG_\n\t\tcase 'E':\n\t\t\tepoll_debug = processes;\n\t\t\tbreak;\n#endif\n#ifdef _EPOLL_THREAD_DUMP_\n\t\tcase 'D':\n\t\t\tepoll_thread_debug = processes;\n\t\t\tbreak;\n#endif\n#ifdef _REGEX_DEBUG_\n\t\tcase 'R':\n\t\t\tregex_debug = processes;\n\t\t\tbreak;\n#endif\n#ifdef _WITH_REGEX_TIMERS_\n\t\tcase 'X':\n\t\t\tregex_timers = processes;\n\t\t\tbreak;\n#endif\n#ifdef _TSM_DEBUG_\n\t\tcase 'S':\n\t\t\ttsm_debug = processes;\n\t\t\tbreak;\n#endif\n#ifdef _VRRP_FD_DEBUG_\n\t\tcase 'F':\n\t\t\tvrrp_fd_debug = processes;\n\t\t\tbreak;\n#endif\n#ifdef _NETLINK_TIMERS_\n\t\tcase 'N':\n\t\t\tnetlink_timer_debug = processes;\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Unknown debug type '%c' in '%s'\\n\", opt, options);\n\t\t\treturn;\n\t\t}\n\t} while (opt_p && *opt_p);\n}\n", "target": 0, "idx": 75905}
{"func": "long VideoTrack::Parse(Segment* pSegment, const Info& info,\n long long element_start, long long element_size,\n VideoTrack*& pResult) {\n if (pResult)\n return -1;\n\n if (info.type != Track::kVideo)\n return -1;\n\n \n   long long width = 0;\n   long long height = 0;\n   double rate = 0.0;\n \n   IMkvReader* const pReader = pSegment->m_pReader;\n\n const Settings& s = info.settings;\n  assert(s.start >= 0);\n  assert(s.size >= 0);\n\n long long pos = s.start;\n  assert(pos >= 0);\n\n const long long stop = pos + s.size;\n\n while (pos < stop) {\n long long id, size;\n\n const long status = ParseElementHeader(pReader, pos, stop, id, size);\n\n if (status < 0) // error\n return status;\n\n if (id == 0x30) { // pixel width\n      width = UnserializeUInt(pReader, pos, size);\n\n if (width <= 0)\n return E_FILE_FORMAT_INVALID;\n } else if (id == 0x3A) { // pixel height\n      height = UnserializeUInt(pReader, pos, size);\n\n \n       if (height <= 0)\n         return E_FILE_FORMAT_INVALID;\n     } else if (id == 0x0383E3) {  // frame rate\n       const long status = UnserializeFloat(pReader, pos, size, rate);\n \n if (status < 0)\n return status;\n\n if (rate <= 0)\n return E_FILE_FORMAT_INVALID;\n\n     }\n \n     pos += size;  // consume payload\n    assert(pos <= stop);\n   }\n \n  assert(pos == stop);\n \n   VideoTrack* const pTrack =\n       new (std::nothrow) VideoTrack(pSegment, element_start, element_size);\n\n if (pTrack == NULL)\n return -1; // generic error\n\n const int status = info.Copy(pTrack->m_info);\n\n if (status) { // error\n delete pTrack;\n return status;\n }\n\n \n   pTrack->m_width = width;\n   pTrack->m_height = height;\n   pTrack->m_rate = rate;\n \n   pResult = pTrack;\n return 0; // success\n}\n", "target": 1, "idx": 187865}
{"func": "iasecc_keyset_change(struct sc_card *card, struct sc_pin_cmd_data *data, int *tries_left)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct iasecc_sdo_update update;\n\tstruct iasecc_sdo sdo;\n\tunsigned scb;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"Change keyset(ref:%i,lengths:%i)\", data->pin_reference, data->pin2.len);\n\tif (!data->pin2.data || data->pin2.len < 32)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_DATA, \"Needs at least 32 bytes for a new keyset value\");\n\n\tmemset(&sdo, 0, sizeof(sdo));\n\tsdo.sdo_class = IASECC_SDO_CLASS_KEYSET;\n\tsdo.sdo_ref  = data->pin_reference;\n\n\trv = iasecc_sdo_get_data(card, &sdo);\n\tLOG_TEST_RET(ctx, rv, \"Cannot get keyset data\");\n\n\tif (sdo.docp.acls_contact.size == 0)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_DATA, \"Bewildered ... there are no ACLs\");\n\tscb = sdo.docp.scbs[IASECC_ACLS_KEYSET_PUT_DATA];\n\tiasecc_sdo_free_fields(card, &sdo);\n\n\tsc_log(ctx, \"SCB:0x%X\", scb);\n\tif (!(scb & IASECC_SCB_METHOD_SM))\n\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"Other then protected by SM, the keyset change is not supported\");\n\n\tmemset(&update, 0, sizeof(update));\n\tupdate.magic = SC_CARDCTL_IASECC_SDO_MAGIC_PUT_DATA;\n\tupdate.sdo_class = sdo.sdo_class;\n\tupdate.sdo_ref = sdo.sdo_ref;\n\n\tupdate.fields[0].parent_tag = IASECC_SDO_KEYSET_TAG;\n\tupdate.fields[0].tag = IASECC_SDO_KEYSET_TAG_MAC;\n\t/* FIXME is it safe to modify the const value here? */\n\tupdate.fields[0].value = (unsigned char *) data->pin2.data;\n\tupdate.fields[0].size = 16;\n\n\tupdate.fields[1].parent_tag = IASECC_SDO_KEYSET_TAG;\n\tupdate.fields[1].tag = IASECC_SDO_KEYSET_TAG_ENC;\n\t/* FIXME is it safe to modify the const value here? */\n\tupdate.fields[1].value = (unsigned char *) data->pin2.data + 16;\n\tupdate.fields[1].size = 16;\n\n\trv = iasecc_sm_sdo_update(card, (scb & IASECC_SCB_METHOD_MASK_REF), &update);\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n", "target": 0, "idx": 78494}
{"func": "GF_Box *rtp_hnti_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_RTPBox, GF_ISOM_BOX_TYPE_RTP);\n\ttmp->subType = GF_ISOM_BOX_TYPE_SDP;\n\treturn (GF_Box *)tmp;\n}\n", "target": 0, "idx": 80358}
{"func": "lockd(void *vrqstp)\n {\n \tint\t\terr = 0;\n \tstruct svc_rqst *rqstp = vrqstp;\n \n \t/* try_to_freeze() is called from svc_recv() */\n \tset_freezable();\n\n\t/* Allow SIGKILL to tell lockd to drop all of its locks */\n\tallow_signal(SIGKILL);\n\n\tdprintk(\"NFS locking service started (ver \" LOCKD_VERSION \").\\n\");\n\n\t/*\n\t * The main request loop. We don't terminate until the last\n\t * NFS mount or NFS daemon has gone away.\n\t */\n\twhile (!kthread_should_stop()) {\n\t\tlong timeout = MAX_SCHEDULE_TIMEOUT;\n\t\tRPC_IFDEBUG(char buf[RPC_MAX_ADDRBUFLEN]);\n\n\t\t/* update sv_maxconn if it has changed */\n\t\trqstp->rq_server->sv_maxconn = nlm_max_connections;\n\n\t\tif (signalled()) {\n\t\t\tflush_signals(current);\n\t\t\trestart_grace();\n\t\t\tcontinue;\n\t\t}\n\n\t\ttimeout = nlmsvc_retry_blocked();\n\n\t\t/*\n\t\t * Find a socket with data available and call its\n\t\t * recvfrom routine.\n\t\t */\n\t\terr = svc_recv(rqstp, timeout);\n\t\tif (err == -EAGAIN || err == -EINTR)\n\t\t\tcontinue;\n\t\tdprintk(\"lockd: request from %s\\n\",\n\t\t\t\tsvc_print_addr(rqstp, buf, sizeof(buf)));\n\n\t\tsvc_process(rqstp);\n\t}\n\tflush_signals(current);\n \tif (nlmsvc_ops)\n \t\tnlmsvc_invalidate_all();\n \tnlm_shutdown_hosts();\n \treturn 0;\n }\n", "target": 1, "idx": 181306}
{"func": "png_text_compress(png_structp png_ptr,\n        png_charp text, png_size_t text_len, int compression,\n        compression_state *comp)\n{\n   int ret;\n\n   comp->num_output_ptr = 0;\n   comp->max_output_ptr = 0;\n   comp->output_ptr = NULL;\n   comp->input = NULL;\n   comp->input_len = 0;\n\n   /* We may just want to pass the text right through */\n   if (compression == PNG_TEXT_COMPRESSION_NONE)\n   {\n       comp->input = text;\n       comp->input_len = text_len;\n       return((int)text_len);\n   }\n\n   if (compression >= PNG_TEXT_COMPRESSION_LAST)\n   {\n#if defined(PNG_STDIO_SUPPORTED) && !defined(_WIN32_WCE)\n      char msg[50];\n      png_snprintf(msg, 50, \"Unknown compression type %d\", compression);\n      png_warning(png_ptr, msg);\n#else\n      png_warning(png_ptr, \"Unknown compression type\");\n#endif\n   }\n\n   /* We can't write the chunk until we find out how much data we have,\n    * which means we need to run the compressor first and save the\n    * output.  This shouldn't be a problem, as the vast majority of\n    * comments should be reasonable, but we will set up an array of\n    * malloc'd pointers to be sure.\n    *\n    * If we knew the application was well behaved, we could simplify this\n    * greatly by assuming we can always malloc an output buffer large\n    * enough to hold the compressed text ((1001 * text_len / 1000) + 12)\n    * and malloc this directly.  The only time this would be a bad idea is\n    * if we can't malloc more than 64K and we have 64K of random input\n    * data, or if the input string is incredibly large (although this\n    * wouldn't cause a failure, just a slowdown due to swapping).\n    */\n\n   /* Set up the compression buffers */\n   png_ptr->zstream.avail_in = (uInt)text_len;\n   png_ptr->zstream.next_in = (Bytef *)text;\n   png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;\n   png_ptr->zstream.next_out = (Bytef *)png_ptr->zbuf;\n\n   /* This is the same compression loop as in png_write_row() */\n   do\n   {\n      /* Compress the data */\n      ret = deflate(&png_ptr->zstream, Z_NO_FLUSH);\n      if (ret != Z_OK)\n      {\n         /* Error */\n         if (png_ptr->zstream.msg != NULL)\n            png_error(png_ptr, png_ptr->zstream.msg);\n         else\n            png_error(png_ptr, \"zlib error\");\n      }\n      /* Check to see if we need more room */\n      if (!(png_ptr->zstream.avail_out))\n      {\n         /* Make sure the output array has room */\n         if (comp->num_output_ptr >= comp->max_output_ptr)\n         {\n            int old_max;\n\n            old_max = comp->max_output_ptr;\n            comp->max_output_ptr = comp->num_output_ptr + 4;\n            if (comp->output_ptr != NULL)\n            {\n               png_charpp old_ptr;\n\n                old_ptr = comp->output_ptr;\n                comp->output_ptr = (png_charpp)png_malloc(png_ptr,\n                   (png_uint_32)\n                  (comp->max_output_ptr * png_sizeof(png_charpp)));\n                png_memcpy(comp->output_ptr, old_ptr, old_max\n                   * png_sizeof(png_charp));\n                png_free(png_ptr, old_ptr);\n            }\n            else\n               comp->output_ptr = (png_charpp)png_malloc(png_ptr,\n                  (png_uint_32)\n                  (comp->max_output_ptr * png_sizeof(png_charp)));\n         }\n\n         /* Save the data */\n         comp->output_ptr[comp->num_output_ptr] =\n            (png_charp)png_malloc(png_ptr,\n            (png_uint_32)png_ptr->zbuf_size);\n         png_memcpy(comp->output_ptr[comp->num_output_ptr], png_ptr->zbuf,\n            png_ptr->zbuf_size);\n         comp->num_output_ptr++;\n\n         /* and reset the buffer */\n         png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;\n         png_ptr->zstream.next_out = png_ptr->zbuf;\n      }\n   /* Continue until we don't have any more to compress */\n   } while (png_ptr->zstream.avail_in);\n\n   /* Finish the compression */\n   do\n   {\n      /* Tell zlib we are finished */\n      ret = deflate(&png_ptr->zstream, Z_FINISH);\n\n      if (ret == Z_OK)\n      {\n         /* Check to see if we need more room */\n         if (!(png_ptr->zstream.avail_out))\n         {\n            /* Check to make sure our output array has room */\n            if (comp->num_output_ptr >= comp->max_output_ptr)\n            {\n               int old_max;\n\n               old_max = comp->max_output_ptr;\n               comp->max_output_ptr = comp->num_output_ptr + 4;\n               if (comp->output_ptr != NULL)\n               {\n                  png_charpp old_ptr;\n\n                  old_ptr = comp->output_ptr;\n                  /* This could be optimized to realloc() */\n                  comp->output_ptr = (png_charpp)png_malloc(png_ptr,\n                     (png_uint_32)(comp->max_output_ptr *\n                     png_sizeof(png_charp)));\n                  png_memcpy(comp->output_ptr, old_ptr,\n                     old_max * png_sizeof(png_charp));\n                  png_free(png_ptr, old_ptr);\n               }\n               else\n                  comp->output_ptr = (png_charpp)png_malloc(png_ptr,\n                     (png_uint_32)(comp->max_output_ptr *\n                     png_sizeof(png_charp)));\n            }\n\n            /* Save the data */\n            comp->output_ptr[comp->num_output_ptr] =\n               (png_charp)png_malloc(png_ptr,\n               (png_uint_32)png_ptr->zbuf_size);\n            png_memcpy(comp->output_ptr[comp->num_output_ptr], png_ptr->zbuf,\n               png_ptr->zbuf_size);\n            comp->num_output_ptr++;\n\n            /* and reset the buffer pointers */\n            png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;\n            png_ptr->zstream.next_out = png_ptr->zbuf;\n         }\n      }\n      else if (ret != Z_STREAM_END)\n      {\n         /* We got an error */\n         if (png_ptr->zstream.msg != NULL)\n            png_error(png_ptr, png_ptr->zstream.msg);\n         else\n            png_error(png_ptr, \"zlib error\");\n      }\n   } while (ret != Z_STREAM_END);\n\n   /* Text length is number of buffers plus last buffer */\n   text_len = png_ptr->zbuf_size * comp->num_output_ptr;\n   if (png_ptr->zstream.avail_out < png_ptr->zbuf_size)\n      text_len += png_ptr->zbuf_size - (png_size_t)png_ptr->zstream.avail_out;\n\n   return((int)text_len);\n}\n", "target": 1, "idx": 186160}
{"func": "UrlData::UrlData(const GURL& url, CORSMode cors_mode, UrlIndex* url_index)\n    : url_(url),\n      have_data_origin_(false),\n      cors_mode_(cors_mode),\n      url_index_(url_index),\n       length_(kPositionNotSpecified),\n       range_supported_(false),\n       cacheable_(false),\n      has_opaque_data_(false),\n       last_used_(),\n       multibuffer_(this, url_index_->block_shift_) {}\n", "target": 1, "idx": 186605}
{"func": "void MemBackendImpl::EvictIfNeeded() {\n  if (current_size_ <= max_size_)\n    return;\n\n  int target_size = std::max(0, max_size_ - kDefaultEvictionSize);\n\n   base::LinkNode<MemEntryImpl>* entry = lru_list_.head();\n   while (current_size_ > target_size && entry != lru_list_.end()) {\n     MemEntryImpl* to_doom = entry->value();\n    entry = entry->next();\n     if (!to_doom->InUse())\n       to_doom->Doom();\n   }\n}\n", "target": 1, "idx": 186677}
{"func": "gs_main_run_string(gs_main_instance * minst, const char *str, int user_errors,\n                   int *pexit_code, ref * perror_object)\n{\n    return gs_main_run_string_with_length(minst, str, (uint) strlen(str),\n                                          user_errors,\n                                          pexit_code, perror_object);\n}\n", "target": 0, "idx": 2905}
{"func": "static void antiidle(void)\n{\n    if (noopidle == (time_t) -1) {\n        noopidle = time(NULL);\n    } else {\n        if ((time(NULL) - noopidle) > (time_t) idletime_noop) {\n            die(421, LOG_INFO, MSG_TIMEOUT_NOOP, (unsigned long) idletime_noop);\n        }\n    }    \n}\n", "target": 0, "idx": 18418}
{"func": "void FrameLoader::continueLoadAfterNavigationPolicy(const ResourceRequest&, PassRefPtr<FormState> formState, bool shouldContinue)\n{\n    ASSERT(m_policyDocumentLoader || !m_provisionalDocumentLoader->unreachableURL().isEmpty());\n\n    bool isTargetItem = history()->provisionalItem() ? history()->provisionalItem()->isTargetItem() : false;\n\n    bool canContinue = shouldContinue && (!isLoadingMainFrame() || m_frame->shouldClose());\n\n    if (!canContinue) {\n        if (m_quickRedirectComing)\n            clientRedirectCancelledOrFinished(false);\n\n        setPolicyDocumentLoader(0);\n\n        if ((isTargetItem || isLoadingMainFrame()) && isBackForwardLoadType(policyChecker()->loadType()))\n            if (Page* page = m_frame->page()) {\n                Frame* mainFrame = page->mainFrame();\n                if (HistoryItem* resetItem = mainFrame->loader()->history()->currentItem()) {\n                    page->backForwardList()->goToItem(resetItem);\n                    Settings* settings = m_frame->settings();\n                    page->setGlobalHistoryItem((!settings || settings->privateBrowsingEnabled()) ? 0 : resetItem);\n                }\n            }\n        return;\n    }\n\n    FrameLoadType type = policyChecker()->loadType();\n    stopAllLoaders();\n    \n    if (!m_frame->page())\n        return;\n\n#if ENABLE(JAVASCRIPT_DEBUGGER) && ENABLE(INSPECTOR)\n    if (Page* page = m_frame->page()) {\n        if (page->mainFrame() == m_frame)\n            page->inspectorController()->resumeDebugger();\n    }\n#endif\n\n    setProvisionalDocumentLoader(m_policyDocumentLoader.get());\n    m_loadType = type;\n    setState(FrameStateProvisional);\n\n    setPolicyDocumentLoader(0);\n\n    if (isBackForwardLoadType(type) && loadProvisionalItemFromCachedPage())\n        return;\n\n    if (formState)\n        m_client->dispatchWillSubmitForm(&PolicyChecker::continueLoadAfterWillSubmitForm, formState);\n    else\n        continueLoadAfterWillSubmitForm();\n}\n", "target": 0, "idx": 97382}
{"func": "static void kvm_ia64_sync_dirty_log(struct kvm *kvm,\n\t\t\t\t    struct kvm_memory_slot *memslot)\n{\n\tint i;\n\tlong base;\n\tunsigned long n;\n\tunsigned long *dirty_bitmap = (unsigned long *)(kvm->arch.vm_base +\n\t\t\toffsetof(struct kvm_vm_data, kvm_mem_dirty_log));\n\n\tn = kvm_dirty_bitmap_bytes(memslot);\n\tbase = memslot->base_gfn / BITS_PER_LONG;\n\n\tspin_lock(&kvm->arch.dirty_log_lock);\n\tfor (i = 0; i < n/sizeof(long); ++i) {\n\t\tmemslot->dirty_bitmap[i] = dirty_bitmap[base + i];\n\t\tdirty_bitmap[base + i] = 0;\n\t}\n\tspin_unlock(&kvm->arch.dirty_log_lock);\n}\n", "target": 0, "idx": 20626}
{"func": "cfm_print(netdissect_options *ndo,\n          register const u_char *pptr, register u_int length)\n{\n    const struct cfm_common_header_t *cfm_common_header;\n    const struct cfm_tlv_header_t *cfm_tlv_header;\n    const uint8_t *tptr, *tlv_ptr;\n    const uint8_t *namesp;\n    u_int names_data_remaining;\n    uint8_t md_nameformat, md_namelength;\n    const uint8_t *md_name;\n    uint8_t ma_nameformat, ma_namelength;\n    const uint8_t *ma_name;\n    u_int hexdump, tlen, cfm_tlv_len, cfm_tlv_type, ccm_interval;\n\n\n    union {\n        const struct cfm_ccm_t *cfm_ccm;\n        const struct cfm_lbm_t *cfm_lbm;\n        const struct cfm_ltm_t *cfm_ltm;\n        const struct cfm_ltr_t *cfm_ltr;\n    } msg_ptr;\n\n    tptr=pptr;\n    cfm_common_header = (const struct cfm_common_header_t *)pptr;\n    if (length < sizeof(*cfm_common_header))\n        goto tooshort;\n    ND_TCHECK(*cfm_common_header);\n\n    /*\n     * Sanity checking of the header.\n     */\n    if (CFM_EXTRACT_VERSION(cfm_common_header->mdlevel_version) != CFM_VERSION) {\n\tND_PRINT((ndo, \"CFMv%u not supported, length %u\",\n               CFM_EXTRACT_VERSION(cfm_common_header->mdlevel_version), length));\n\treturn;\n    }\n\n    ND_PRINT((ndo, \"CFMv%u %s, MD Level %u, length %u\",\n           CFM_EXTRACT_VERSION(cfm_common_header->mdlevel_version),\n           tok2str(cfm_opcode_values, \"unknown (%u)\", cfm_common_header->opcode),\n           CFM_EXTRACT_MD_LEVEL(cfm_common_header->mdlevel_version),\n           length));\n\n    /*\n     * In non-verbose mode just print the opcode and md-level.\n     */\n    if (ndo->ndo_vflag < 1) {\n        return;\n    }\n\n    ND_PRINT((ndo, \"\\n\\tFirst TLV offset %u\", cfm_common_header->first_tlv_offset));\n\n    tptr += sizeof(const struct cfm_common_header_t);\n    tlen = length - sizeof(struct cfm_common_header_t);\n\n    /*\n     * Sanity check the first TLV offset.\n     */\n    if (cfm_common_header->first_tlv_offset > tlen) {\n        ND_PRINT((ndo, \" (too large, must be <= %u)\", tlen));\n        return;\n    }\n\n    switch (cfm_common_header->opcode) {\n    case CFM_OPCODE_CCM:\n        msg_ptr.cfm_ccm = (const struct cfm_ccm_t *)tptr;\n        if (cfm_common_header->first_tlv_offset < sizeof(*msg_ptr.cfm_ccm)) {\n            ND_PRINT((ndo, \" (too small 1, must be >= %lu)\",\n                     (unsigned long) sizeof(*msg_ptr.cfm_ccm)));\n            return;\n        }\n        if (tlen < sizeof(*msg_ptr.cfm_ccm))\n            goto tooshort;\n        ND_TCHECK(*msg_ptr.cfm_ccm);\n\n        ccm_interval = CFM_EXTRACT_CCM_INTERVAL(cfm_common_header->flags);\n        ND_PRINT((ndo, \", Flags [CCM Interval %u%s]\",\n               ccm_interval,\n               cfm_common_header->flags & CFM_CCM_RDI_FLAG ?\n               \", RDI\" : \"\"));\n\n        /*\n         * Resolve the CCM interval field.\n         */\n        if (ccm_interval) {\n            ND_PRINT((ndo, \"\\n\\t  CCM Interval %.3fs\"\n                   \", min CCM Lifetime %.3fs, max CCM Lifetime %.3fs\",\n                   ccm_interval_base[ccm_interval],\n                   ccm_interval_base[ccm_interval] * CCM_INTERVAL_MIN_MULTIPLIER,\n                   ccm_interval_base[ccm_interval] * CCM_INTERVAL_MAX_MULTIPLIER));\n        }\n\n        ND_PRINT((ndo, \"\\n\\t  Sequence Number 0x%08x, MA-End-Point-ID 0x%04x\",\n               EXTRACT_32BITS(msg_ptr.cfm_ccm->sequence),\n               EXTRACT_16BITS(msg_ptr.cfm_ccm->ma_epi)));\n\n        namesp = msg_ptr.cfm_ccm->names;\n        names_data_remaining = sizeof(msg_ptr.cfm_ccm->names);\n\n        /*\n         * Resolve the MD fields.\n         */\n        md_nameformat = *namesp;\n        namesp++;\n        names_data_remaining--;  /* We know this is != 0 */\n        if (md_nameformat != CFM_CCM_MD_FORMAT_NONE) {\n            md_namelength = *namesp;\n            namesp++;\n            names_data_remaining--; /* We know this is !=0 */\n            ND_PRINT((ndo, \"\\n\\t  MD Name Format %s (%u), MD Name length %u\",\n                   tok2str(cfm_md_nameformat_values, \"Unknown\",\n                           md_nameformat),\n                   md_nameformat,\n                   md_namelength));\n\n            /*\n             * -3 for the MA short name format and length and one byte\n             * of MA short name.\n             */\n            if (md_namelength > names_data_remaining - 3) {\n                ND_PRINT((ndo, \" (too large, must be <= %u)\", names_data_remaining - 2));\n                return;\n            }\n\n            md_name = namesp;\n            ND_PRINT((ndo, \"\\n\\t  MD Name: \"));\n            switch (md_nameformat) {\n            case CFM_CCM_MD_FORMAT_DNS:\n            case CFM_CCM_MD_FORMAT_CHAR:\n                safeputs(ndo, md_name, md_namelength);\n                break;\n\n            case CFM_CCM_MD_FORMAT_MAC:\n                if (md_namelength == 6) {\n                    ND_PRINT((ndo, \"\\n\\t  MAC %s\", etheraddr_string(ndo,\n                               md_name)));\n                } else {\n                    ND_PRINT((ndo, \"\\n\\t  MAC (length invalid)\"));\n                }\n                break;\n\n                /* FIXME add printers for those MD formats - hexdump for now */\n            case CFM_CCM_MA_FORMAT_8021:\n            default:\n                print_unknown_data(ndo, md_name, \"\\n\\t    \",\n                                   md_namelength);\n            }\n            namesp += md_namelength;\n            names_data_remaining -= md_namelength;\n        } else {\n            ND_PRINT((ndo, \"\\n\\t  MD Name Format %s (%u)\",\n                   tok2str(cfm_md_nameformat_values, \"Unknown\",\n                           md_nameformat),\n                   md_nameformat));\n        }\n\n\n        /*\n         * Resolve the MA fields.\n         */\n        ma_nameformat = *namesp;\n        namesp++;\n        names_data_remaining--; /* We know this is != 0 */\n        ma_namelength = *namesp;\n        namesp++;\n        names_data_remaining--; /* We know this is != 0 */\n        ND_PRINT((ndo, \"\\n\\t  MA Name-Format %s (%u), MA name length %u\",\n               tok2str(cfm_ma_nameformat_values, \"Unknown\",\n                       ma_nameformat),\n               ma_nameformat,\n               ma_namelength));\n\n        if (ma_namelength > names_data_remaining) {\n            ND_PRINT((ndo, \" (too large, must be <= %u)\", names_data_remaining));\n            return;\n        }\n\n        ma_name = namesp;\n        ND_PRINT((ndo, \"\\n\\t  MA Name: \"));\n        switch (ma_nameformat) {\n        case CFM_CCM_MA_FORMAT_CHAR:\n            safeputs(ndo, ma_name, ma_namelength);\n            break;\n\n            /* FIXME add printers for those MA formats - hexdump for now */\n        case CFM_CCM_MA_FORMAT_8021:\n        case CFM_CCM_MA_FORMAT_VID:\n        case CFM_CCM_MA_FORMAT_INT:\n        case CFM_CCM_MA_FORMAT_VPN:\n        default:\n            print_unknown_data(ndo, ma_name, \"\\n\\t    \", ma_namelength);\n        }\n        break;\n\n    case CFM_OPCODE_LTM:\n        msg_ptr.cfm_ltm = (const struct cfm_ltm_t *)tptr;\n        if (cfm_common_header->first_tlv_offset < sizeof(*msg_ptr.cfm_ltm)) {\n            ND_PRINT((ndo, \" (too small 4, must be >= %lu)\",\n                     (unsigned long) sizeof(*msg_ptr.cfm_ltm)));\n            return;\n        }\n        if (tlen < sizeof(*msg_ptr.cfm_ltm))\n            goto tooshort;\n        ND_TCHECK(*msg_ptr.cfm_ltm);\n\n        ND_PRINT((ndo, \", Flags [%s]\",\n               bittok2str(cfm_ltm_flag_values, \"none\", cfm_common_header->flags)));\n\n        ND_PRINT((ndo, \"\\n\\t  Transaction-ID 0x%08x, ttl %u\",\n               EXTRACT_32BITS(msg_ptr.cfm_ltm->transaction_id),\n               msg_ptr.cfm_ltm->ttl));\n\n        ND_PRINT((ndo, \"\\n\\t  Original-MAC %s, Target-MAC %s\",\n               etheraddr_string(ndo, msg_ptr.cfm_ltm->original_mac),\n               etheraddr_string(ndo, msg_ptr.cfm_ltm->target_mac)));\n        break;\n\n    case CFM_OPCODE_LTR:\n        msg_ptr.cfm_ltr = (const struct cfm_ltr_t *)tptr;\n        if (cfm_common_header->first_tlv_offset < sizeof(*msg_ptr.cfm_ltr)) {\n            ND_PRINT((ndo, \" (too small 5, must be >= %lu)\",\n                     (unsigned long) sizeof(*msg_ptr.cfm_ltr)));\n            return;\n        }\n        if (tlen < sizeof(*msg_ptr.cfm_ltr))\n            goto tooshort;\n        ND_TCHECK(*msg_ptr.cfm_ltr);\n\n        ND_PRINT((ndo, \", Flags [%s]\",\n               bittok2str(cfm_ltr_flag_values, \"none\", cfm_common_header->flags)));\n\n        ND_PRINT((ndo, \"\\n\\t  Transaction-ID 0x%08x, ttl %u\",\n               EXTRACT_32BITS(msg_ptr.cfm_ltr->transaction_id),\n               msg_ptr.cfm_ltr->ttl));\n\n        ND_PRINT((ndo, \"\\n\\t  Replay-Action %s (%u)\",\n               tok2str(cfm_ltr_replay_action_values,\n                       \"Unknown\",\n                       msg_ptr.cfm_ltr->replay_action),\n               msg_ptr.cfm_ltr->replay_action));\n        break;\n\n        /*\n         * No message decoder yet.\n         * Hexdump everything up until the start of the TLVs\n         */\n    case CFM_OPCODE_LBR:\n    case CFM_OPCODE_LBM:\n    default:\n        print_unknown_data(ndo, tptr, \"\\n\\t  \",\n                           tlen -  cfm_common_header->first_tlv_offset);\n        break;\n    }\n\n    tptr += cfm_common_header->first_tlv_offset;\n    tlen -= cfm_common_header->first_tlv_offset;\n\n    while (tlen > 0) {\n        cfm_tlv_header = (const struct cfm_tlv_header_t *)tptr;\n\n        /* Enough to read the tlv type ? */\n        ND_TCHECK2(*tptr, 1);\n        cfm_tlv_type=cfm_tlv_header->type;\n\n        ND_PRINT((ndo, \"\\n\\t%s TLV (0x%02x)\",\n               tok2str(cfm_tlv_values, \"Unknown\", cfm_tlv_type),\n               cfm_tlv_type));\n\n        if (cfm_tlv_type == CFM_TLV_END) {\n            /* Length is \"Not present if the Type field is 0.\" */\n            return;\n        }\n\n        /* do we have the full tlv header ? */\n        if (tlen < sizeof(struct cfm_tlv_header_t))\n            goto tooshort;\n        ND_TCHECK2(*tptr, sizeof(struct cfm_tlv_header_t));\n        cfm_tlv_len=EXTRACT_16BITS(&cfm_tlv_header->length);\n\n        ND_PRINT((ndo, \", length %u\", cfm_tlv_len));\n\n        tptr += sizeof(struct cfm_tlv_header_t);\n        tlen -= sizeof(struct cfm_tlv_header_t);\n        tlv_ptr = tptr;\n\n        /* do we have the full tlv ? */\n        if (tlen < cfm_tlv_len)\n            goto tooshort;\n        ND_TCHECK2(*tptr, cfm_tlv_len);\n        hexdump = FALSE;\n\n        switch(cfm_tlv_type) {\n        case CFM_TLV_PORT_STATUS:\n            if (cfm_tlv_len < 1) {\n                ND_PRINT((ndo, \" (too short, must be >= 1)\"));\n                return;\n            }\n            ND_PRINT((ndo, \", Status: %s (%u)\",\n                   tok2str(cfm_tlv_port_status_values, \"Unknown\", *tptr),\n                   *tptr));\n            break;\n\n        case CFM_TLV_INTERFACE_STATUS:\n            if (cfm_tlv_len < 1) {\n                ND_PRINT((ndo, \" (too short, must be >= 1)\"));\n                return;\n            }\n            ND_PRINT((ndo, \", Status: %s (%u)\",\n                   tok2str(cfm_tlv_interface_status_values, \"Unknown\", *tptr),\n                   *tptr));\n            break;\n\n        case CFM_TLV_PRIVATE:\n            if (cfm_tlv_len < 4) {\n                ND_PRINT((ndo, \" (too short, must be >= 4)\"));\n                return;\n            }\n            ND_PRINT((ndo, \", Vendor: %s (%u), Sub-Type %u\",\n                   tok2str(oui_values,\"Unknown\", EXTRACT_24BITS(tptr)),\n                   EXTRACT_24BITS(tptr),\n                   *(tptr + 3)));\n            hexdump = TRUE;\n            break;\n\n        case CFM_TLV_SENDER_ID:\n        {\n            u_int chassis_id_type, chassis_id_length;\n            u_int mgmt_addr_length;\n \n             if (cfm_tlv_len < 1) {\n                 ND_PRINT((ndo, \" (too short, must be >= 1)\"));\n                return;\n             }\n \n             /*\n              * Get the Chassis ID length and check it.\n              */\n             chassis_id_length = *tptr;\n             tptr++;\n             tlen--;\n             cfm_tlv_len--;\n \n             if (chassis_id_length) {\n                 if (cfm_tlv_len < 1) {\n                     ND_PRINT((ndo, \"\\n\\t  (TLV too short)\"));\n                    return;\n                 }\n                 chassis_id_type = *tptr;\n                 cfm_tlv_len--;\n                ND_PRINT((ndo, \"\\n\\t  Chassis-ID Type %s (%u), Chassis-ID length %u\",\n                       tok2str(cfm_tlv_senderid_chassisid_values,\n                               \"Unknown\",\n                               chassis_id_type),\n                       chassis_id_type,\n                       chassis_id_length));\n \n                 if (cfm_tlv_len < chassis_id_length) {\n                     ND_PRINT((ndo, \"\\n\\t  (TLV too short)\"));\n                    return;\n                 }\n \n                 switch (chassis_id_type) {\n                 case CFM_CHASSIS_ID_MAC_ADDRESS:\n                     ND_PRINT((ndo, \"\\n\\t  MAC %s\", etheraddr_string(ndo, tptr + 1)));\n                     break;\n \n                 case CFM_CHASSIS_ID_NETWORK_ADDRESS:\n                    hexdump |= cfm_network_addr_print(ndo, tptr);\n                     break;\n \n                 case CFM_CHASSIS_ID_INTERFACE_NAME: /* fall through */\n                case CFM_CHASSIS_ID_INTERFACE_ALIAS:\n                case CFM_CHASSIS_ID_LOCAL:\n                case CFM_CHASSIS_ID_CHASSIS_COMPONENT:\n                case CFM_CHASSIS_ID_PORT_COMPONENT:\n                    safeputs(ndo, tptr + 1, chassis_id_length);\n                    break;\n\n                default:\n                    hexdump = TRUE;\n                    break;\n                }\n                cfm_tlv_len -= chassis_id_length;\n\n                tptr += 1 + chassis_id_length;\n                tlen -= 1 + chassis_id_length;\n            }\n \n             /*\n              * Check if there is a Management Address.\n              */\n             if (cfm_tlv_len == 0) {\n                 /* No, there isn't; we're done. */\n                return;\n             }\n \n             mgmt_addr_length = *tptr;\n             tptr++;\n             tlen--;\n             cfm_tlv_len--;\n             if (mgmt_addr_length) {\n                 if (cfm_tlv_len < mgmt_addr_length) {\n                     ND_PRINT((ndo, \"\\n\\t  (TLV too short)\"));\n                    return;\n                 }\n                 cfm_tlv_len -= mgmt_addr_length;\n                 /*\n                  * XXX - this is an OID; print it as such.\n                  */\n                 tptr += mgmt_addr_length;\n                 tlen -= mgmt_addr_length;\n \n                 if (cfm_tlv_len < 1) {\n                    ND_PRINT((ndo, \"\\n\\t  (TLV too short)\"));\n                    return;\n                 }\n \n                 mgmt_addr_length = *tptr;\n                 tptr++;\n                 tlen--;\n                 cfm_tlv_len--;\n                 if (mgmt_addr_length) {\n                     if (cfm_tlv_len < mgmt_addr_length) {\n                         ND_PRINT((ndo, \"\\n\\t  (TLV too short)\"));\n                         return;\n                    }\n                    cfm_tlv_len -= mgmt_addr_length;\n                     /*\n                      * XXX - this is a TransportDomain; print it as such.\n                      */\n                     tptr += mgmt_addr_length;\n                     tlen -= mgmt_addr_length;\n                 }\n            }\n            break;\n        }\n\n            /*\n             * FIXME those are the defined TLVs that lack a decoder\n             * you are welcome to contribute code ;-)\n             */\n\n        case CFM_TLV_DATA:\n        case CFM_TLV_REPLY_INGRESS:\n        case CFM_TLV_REPLY_EGRESS:\n        default:\n            hexdump = TRUE;\n            break;\n        }\n        /* do we want to see an additional hexdump ? */\n         if (hexdump || ndo->ndo_vflag > 1)\n             print_unknown_data(ndo, tlv_ptr, \"\\n\\t  \", cfm_tlv_len);\n \n         tptr+=cfm_tlv_len;\n         tlen-=cfm_tlv_len;\n     }\n    return;\n\ntooshort:\n    ND_PRINT((ndo, \"\\n\\t\\t packet is too short\"));\n    return;\n\ntrunc:\n    ND_PRINT((ndo, \"\\n\\t\\t packet exceeded snapshot\"));\n}\n", "target": 1, "idx": 180994}
{"func": "void CameraClient::disableMsgType(int32_t msgType) {\n    android_atomic_and(~msgType, &mMsgEnabled);\n    mHardware->disableMsgType(msgType);\n}\n", "target": 0, "idx": 174943}
{"func": "static int iscsi_add_notunderstood_response(\n\tchar *key,\n\tchar *value,\n\tstruct iscsi_param_list *param_list)\n{\n\tstruct iscsi_extra_response *extra_response;\n\n\tif (strlen(value) > VALUE_MAXLEN) {\n\t\tpr_err(\"Value for notunderstood key \\\"%s\\\" exceeds %d,\"\n\t\t\t\" protocol error.\\n\", key, VALUE_MAXLEN);\n\t\treturn -1;\n\t}\n\n\textra_response = kzalloc(sizeof(struct iscsi_extra_response), GFP_KERNEL);\n\tif (!extra_response) {\n\t\tpr_err(\"Unable to allocate memory for\"\n\t\t\t\" struct iscsi_extra_response.\\n\");\n\t\treturn -1;\n \t}\n \tINIT_LIST_HEAD(&extra_response->er_list);\n \n\tstrncpy(extra_response->key, key, strlen(key) + 1);\n\tstrncpy(extra_response->value, NOTUNDERSTOOD,\n\t\t\tstrlen(NOTUNDERSTOOD) + 1);\n \n \tlist_add_tail(&extra_response->er_list,\n \t\t\t&param_list->extra_response_list);\n\treturn 0;\n}\n", "target": 1, "idx": 179222}
{"func": "static netdev_features_t net_mpls_features(struct sk_buff *skb,\n\t\t\t\t\t   netdev_features_t features,\n\t\t\t\t\t   __be16 type)\n{\n\treturn features;\n}\n", "target": 0, "idx": 48853}
{"func": "static Image *ReadPSDImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    has_merged_image,\n    skip_layers;\n\n  MagickOffsetType\n    offset;\n\n  MagickSizeType\n    length;\n\n  MagickBooleanType\n    status;\n\n  PSDInfo\n    psd_info;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count;\n\n  unsigned char\n    *data;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read image header.\n  */\n  image->endian=MSBEndian;\n  count=ReadBlob(image,4,(unsigned char *) psd_info.signature);\n  psd_info.version=ReadBlobMSBShort(image);\n  if ((count == 0) || (LocaleNCompare(psd_info.signature,\"8BPS\",4) != 0) ||\n      ((psd_info.version != 1) && (psd_info.version != 2)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  (void) ReadBlob(image,6,psd_info.reserved);\n  psd_info.channels=ReadBlobMSBShort(image);\n  if (psd_info.channels > MaxPSDChannels)\n    ThrowReaderException(CorruptImageError,\"MaximumChannelsExceeded\");\n  psd_info.rows=ReadBlobMSBLong(image);\n  psd_info.columns=ReadBlobMSBLong(image);\n  if ((psd_info.version == 1) && ((psd_info.rows > 30000) ||\n      (psd_info.columns > 30000)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  psd_info.depth=ReadBlobMSBShort(image);\n  if ((psd_info.depth != 1) && (psd_info.depth != 8) && (psd_info.depth != 16))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  psd_info.mode=ReadBlobMSBShort(image);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Image is %.20g x %.20g with channels=%.20g, depth=%.20g, mode=%s\",\n      (double) psd_info.columns,(double) psd_info.rows,(double)\n      psd_info.channels,(double) psd_info.depth,ModeToString((PSDImageType)\n      psd_info.mode));\n  /*\n    Initialize image.\n  */\n  image->depth=psd_info.depth;\n  image->columns=psd_info.columns;\n  image->rows=psd_info.rows;\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  if (SetImageBackgroundColor(image,exception) == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (psd_info.mode == LabMode)\n    SetImageColorspace(image,LabColorspace,exception);\n  if (psd_info.mode == CMYKMode)\n    {\n      SetImageColorspace(image,CMYKColorspace,exception);\n      image->alpha_trait=psd_info.channels > 4 ? BlendPixelTrait :\n        UndefinedPixelTrait;\n    }\n  else if ((psd_info.mode == BitmapMode) || (psd_info.mode == GrayscaleMode) ||\n      (psd_info.mode == DuotoneMode))\n    {\n      status=AcquireImageColormap(image,psd_info.depth != 16 ? 256 : 65536,\n        exception);\n      if (status == MagickFalse)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Image colormap allocated\");\n      SetImageColorspace(image,GRAYColorspace,exception);\n      image->alpha_trait=psd_info.channels > 1 ? BlendPixelTrait :\n        UndefinedPixelTrait;\n    }\n  else\n    image->alpha_trait=psd_info.channels > 3 ? BlendPixelTrait :\n      UndefinedPixelTrait;\n  /*\n    Read PSD raster colormap only present for indexed and duotone images.\n  */\n  length=ReadBlobMSBLong(image);\n  if (length != 0)\n    {\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  reading colormap\");\n      if (psd_info.mode == DuotoneMode)\n        {\n          /*\n            Duotone image data;  the format of this data is undocumented.\n          */\n          data=(unsigned char *) AcquireQuantumMemory((size_t) length,\n            sizeof(*data));\n          if (data == (unsigned char *) NULL)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          (void) ReadBlob(image,(size_t) length,data);\n          data=(unsigned char *) RelinquishMagickMemory(data);\n        }\n      else\n        {\n          size_t\n            number_colors;\n\n          /*\n            Read PSD raster colormap.\n          */\n          number_colors=length/3;\n          if (number_colors > 65536)\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n          if (AcquireImageColormap(image,number_colors,exception) == MagickFalse)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          for (i=0; i < (ssize_t) image->colors; i++)\n            image->colormap[i].red=ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n          for (i=0; i < (ssize_t) image->colors; i++)\n            image->colormap[i].green=ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n          for (i=0; i < (ssize_t) image->colors; i++)\n            image->colormap[i].blue=ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n           image->alpha_trait=UndefinedPixelTrait;\n         }\n     }\n   has_merged_image=MagickTrue;\n   length=ReadBlobMSBLong(image);\n   if (length != 0)\n    {\n      unsigned char\n        *blocks;\n\n      /*\n        Image resources block.\n      */\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  reading image resource blocks - %.20g bytes\",(double)\n          ((MagickOffsetType) length));\n      blocks=(unsigned char *) AcquireQuantumMemory((size_t) length,\n        sizeof(*blocks));\n      if (blocks == (unsigned char *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      count=ReadBlob(image,(size_t) length,blocks);\n      if ((count != (ssize_t) length) ||\n          (LocaleNCompare((char *) blocks,\"8BIM\",4) != 0))\n        {\n          blocks=(unsigned char *) RelinquishMagickMemory(blocks);\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        }\n      ParseImageResourceBlocks(image,blocks,(size_t) length,&has_merged_image,\n        exception);\n      blocks=(unsigned char *) RelinquishMagickMemory(blocks);\n    }\n  /*\n    Layer and mask block.\n  */\n  length=GetPSDSize(&psd_info,image);\n  if (length == 8)\n    {\n      length=ReadBlobMSBLong(image);\n      length=ReadBlobMSBLong(image);\n    }\n  offset=TellBlob(image);\n  skip_layers=MagickFalse;\n  if ((image_info->number_scenes == 1) && (image_info->scene == 0) &&\n      (has_merged_image != MagickFalse))\n    {\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  read composite only\");\n      skip_layers=MagickTrue;\n    }\n  if (length == 0)\n    {\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  image has no layers\");\n    }\n  else\n    {\n      if (ReadPSDLayers(image,image_info,&psd_info,skip_layers,exception) !=\n          MagickTrue)\n        {\n          (void) CloseBlob(image);\n          image=DestroyImageList(image);\n          return((Image *) NULL);\n        }\n\n      /*\n         Skip the rest of the layer and mask information.\n      */\n      SeekBlob(image,offset+length,SEEK_SET);\n    }\n  /*\n    If we are only \"pinging\" the image, then we're done - so return.\n  */\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  /*\n    Read the precombined layer, present for PSD < 4 compatibility.\n  */\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  reading the precombined layer\");\n  if ((has_merged_image != MagickFalse) || (GetImageListLength(image) == 1))\n    has_merged_image=(MagickBooleanType) ReadPSDMergedImage(image_info,image,\n      &psd_info,exception);\n  if ((has_merged_image == MagickFalse) && (GetImageListLength(image) == 1) &&\n      (length != 0))\n    {\n      SeekBlob(image,offset,SEEK_SET);\n      status=ReadPSDLayers(image,image_info,&psd_info,MagickFalse,exception);\n      if (status != MagickTrue)\n        {\n          (void) CloseBlob(image);\n          image=DestroyImageList(image);\n          return((Image *) NULL);\n        }\n    }\n  if ((has_merged_image == MagickFalse) && (GetImageListLength(image) > 1))\n    {\n      Image\n        *merged;\n\n      SetImageAlphaChannel(image,TransparentAlphaChannel,exception);\n      image->background_color.alpha=TransparentAlpha;\n      image->background_color.alpha_trait=BlendPixelTrait;\n      merged=MergeImageLayers(image,FlattenLayer,exception);\n      ReplaceImageInList(&image,merged);\n    }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n", "target": 1, "idx": 183288}
{"func": "int main(int argc, char **argv) {\n\tint result;\n\tint error = FALSE;\n\tint display_license = FALSE;\n\tint display_help = FALSE;\n\tint c = 0;\n\tstruct tm *tm, tm_s;\n\ttime_t now;\n\tchar datestring[256];\n\tnagios_macros *mac;\n\tconst char *worker_socket = NULL;\n\tint i;\n#ifdef HAVE_SIGACTION\n\tstruct sigaction sig_action;\n#endif\n\n#ifdef HAVE_GETOPT_H\n\tint option_index = 0;\n\tstatic struct option long_options[] = {\n\t\t\t{\"help\", no_argument, 0, 'h'},\n\t\t\t{\"version\", no_argument, 0, 'V'},\n\t\t\t{\"license\", no_argument, 0, 'V'},\n\t\t\t{\"verify-config\", no_argument, 0, 'v'},\n\t\t\t{\"daemon\", no_argument, 0, 'd'},\n\t\t\t{\"test-scheduling\", no_argument, 0, 's'},\n\t\t\t{\"precache-objects\", no_argument, 0, 'p'},\n\t\t\t{\"use-precached-objects\", no_argument, 0, 'u'},\n\t\t\t{\"enable-timing-point\", no_argument, 0, 'T'},\n\t\t\t{\"worker\", required_argument, 0, 'W'},\n\t\t\t{0, 0, 0, 0}\n\t\t};\n#define getopt(argc, argv, o) getopt_long(argc, argv, o, long_options, &option_index)\n#endif\n\n\tmemset(&loadctl, 0, sizeof(loadctl));\n\tmac = get_global_macros();\n\n\t/* make sure we have the correct number of command line arguments */\n\tif(argc < 2)\n\t\terror = TRUE;\n\n\t/* get all command line arguments */\n\twhile(1) {\n\t\tc = getopt(argc, argv, \"+hVvdspuxTW\");\n\n\t\tif(c == -1 || c == EOF)\n\t\t\tbreak;\n\n\t\tswitch(c) {\n\n\t\t\tcase '?': /* usage */\n\t\t\tcase 'h':\n\t\t\t\tdisplay_help = TRUE;\n\t\t\t\tbreak;\n\n\t\t\tcase 'V': /* version */\n\t\t\t\tdisplay_license = TRUE;\n\t\t\t\tbreak;\n\n\t\t\tcase 'v': /* verify */\n\t\t\t\tverify_config++;\n\t\t\t\tbreak;\n\n\t\t\tcase 's': /* scheduling check */\n\t\t\t\ttest_scheduling = TRUE;\n\t\t\t\tbreak;\n\n\t\t\tcase 'd': /* daemon mode */\n\t\t\t\tdaemon_mode = TRUE;\n\t\t\t\tbreak;\n\n\t\t\tcase 'p': /* precache object config */\n\t\t\t\tprecache_objects = TRUE;\n\t\t\t\tbreak;\n\n\t\t\tcase 'u': /* use precached object config */\n\t\t\t\tuse_precached_objects = TRUE;\n\t\t\t\tbreak;\n\t\t\tcase 'T':\n\t\t\t\tenable_timing_point = TRUE;\n\t\t\t\tbreak;\n\t\t\tcase 'W':\n\t\t\t\tworker_socket = optarg;\n\t\t\t\tbreak;\n\n\t\t\tcase 'x':\n\t\t\t\tprintf(\"Warning: -x is deprecated and will be removed\\n\");\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\n#ifdef DEBUG_MEMORY\n\tmtrace();\n#endif\n\t/* if we're a worker we can skip everything below */\n\tif(worker_socket) {\n\t\texit(nagios_core_worker(worker_socket));\n\t}\n\n\t/* Initialize configuration variables */                             \n\tinit_main_cfg_vars(1);\n\tinit_shared_cfg_vars(1);\n\n\tif(daemon_mode == FALSE) {\n\t\tprintf(\"\\nNagios Core %s\\n\", PROGRAM_VERSION);\n\t\tprintf(\"Copyright (c) 2009-present Nagios Core Development Team and Community Contributors\\n\");\n\t\tprintf(\"Copyright (c) 1999-2009 Ethan Galstad\\n\");\n\t\tprintf(\"Last Modified: %s\\n\", PROGRAM_MODIFICATION_DATE);\n\t\tprintf(\"License: GPL\\n\\n\");\n\t\tprintf(\"Website: https://www.nagios.org\\n\");\n\t\t}\n\n\t/* just display the license */\n\tif(display_license == TRUE) {\n\n\t\tprintf(\"This program is free software; you can redistribute it and/or modify\\n\");\n\t\tprintf(\"it under the terms of the GNU General Public License version 2 as\\n\");\n\t\tprintf(\"published by the Free Software Foundation.\\n\\n\");\n\t\tprintf(\"This program is distributed in the hope that it will be useful,\\n\");\n\t\tprintf(\"but WITHOUT ANY WARRANTY; without even the implied warranty of\\n\");\n\t\tprintf(\"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n\");\n\t\tprintf(\"GNU General Public License for more details.\\n\\n\");\n\t\tprintf(\"You should have received a copy of the GNU General Public License\\n\");\n\t\tprintf(\"along with this program; if not, write to the Free Software\\n\");\n\t\tprintf(\"Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\\n\\n\");\n\n\t\texit(OK);\n\t\t}\n\n\t/* make sure we got the main config file on the command line... */\n\tif(optind >= argc)\n\t\terror = TRUE;\n\n\t/* if there are no command line options (or if we encountered an error), print usage */\n\tif(error == TRUE || display_help == TRUE) {\n\n\t\tprintf(\"Usage: %s [options] <main_config_file>\\n\", argv[0]);\n\t\tprintf(\"\\n\");\n\t\tprintf(\"Options:\\n\");\n\t\tprintf(\"\\n\");\n\t\tprintf(\"  -v, --verify-config          Verify all configuration data (-v -v for more info)\\n\");\n\t\tprintf(\"  -s, --test-scheduling        Shows projected/recommended check scheduling and other\\n\");\n\t\tprintf(\"                               diagnostic info based on the current configuration files.\\n\");\n\t\tprintf(\"  -T, --enable-timing-point    Enable timed commentary on initialization\\n\");\n\t\tprintf(\"  -x, --dont-verify-paths      Deprecated (Don't check for circular object paths)\\n\");\n\t\tprintf(\"  -p, --precache-objects       Precache object configuration\\n\");\n\t\tprintf(\"  -u, --use-precached-objects  Use precached object config file\\n\");\n\t\tprintf(\"  -d, --daemon                 Starts Nagios in daemon mode, instead of as a foreground process\\n\");\n\t\tprintf(\"  -W, --worker /path/to/socket Act as a worker for an already running daemon\\n\");\n\t\tprintf(\"\\n\");\n\t\tprintf(\"Visit the Nagios website at https://www.nagios.org/ for bug fixes, new\\n\");\n\t\tprintf(\"releases, online documentation, FAQs, information on subscribing to\\n\");\n\t\tprintf(\"the mailing lists, and commercial support options for Nagios.\\n\");\n\t\tprintf(\"\\n\");\n\n\t\texit(ERROR);\n\t\t}\n\n\n\t/*\n\t * config file is last argument specified.\n\t * Make sure it uses an absolute path\n\t */\n\tconfig_file = nspath_absolute(argv[optind], NULL);\n\tif(config_file == NULL) {\n\t\tprintf(\"Error allocating memory.\\n\");\n\t\texit(ERROR);\n\t\t}\n\n\tconfig_file_dir = nspath_absolute_dirname(config_file, NULL);\n\n\t/* \n\t * Set the signal handler for the SIGXFSZ signal here because\n\t * we may encounter this signal before the other signal handlers\n\t * are set.\n\t */\n#ifdef HAVE_SIGACTION\n\tsig_action.sa_sigaction = NULL;\n\tsig_action.sa_handler = handle_sigxfsz;\n\tsigfillset(&sig_action.sa_mask);\n\tsig_action.sa_flags = SA_NODEFER|SA_RESTART;\n\tsigaction(SIGXFSZ, &sig_action, NULL);\n#else\n\tsignal(SIGXFSZ, handle_sigxfsz);\n#endif\n\n\t/*\n\t * let's go to town. We'll be noisy if we're verifying config\n\t * or running scheduling tests.\n\t */\n\tif(verify_config || test_scheduling || precache_objects) {\n\t\treset_variables();\n\t\t/*\n\t\t * if we don't beef up our resource limits as much as\n\t\t * we can, it's quite possible we'll run headlong into\n\t\t * EAGAIN due to too many processes when we try to\n\t\t * drop privileges later.\n\t\t */\n\t\tset_loadctl_defaults();\n\n\t\tif(verify_config)\n\t\t\tprintf(\"Reading configuration data...\\n\");\n\n\t\t/* read our config file */\n\t\tresult = read_main_config_file(config_file);\n\t\tif(result != OK) {\n\t\t\tprintf(\"   Error processing main config file!\\n\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\n\t\tif(verify_config)\n\t\t\tprintf(\"   Read main config file okay...\\n\");\n\n\t\t/* drop privileges */\n\t\tif((result = drop_privileges(nagios_user, nagios_group)) == ERROR) {\n\t\t\tprintf(\"   Failed to drop privileges.  Aborting.\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\n\t\t/*\n\t\t * this must come after dropping privileges, so we make\n\t\t * sure to test access permissions as the right user.\n\t\t */\n\t\tif (!verify_config && test_configured_paths() == ERROR) {\n\t\t\tprintf(\"   One or more path problems detected. Aborting.\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\n\t\t/* read object config files */\n\t\tresult = read_all_object_data(config_file);\n\t\tif(result != OK) {\n\t\t\tprintf(\"   Error processing object config files!\\n\\n\");\n\t\t\t/* if the config filename looks fishy, warn the user */\n\t\t\tif(!strstr(config_file, \"nagios.cfg\")) {\n\t\t\t\tprintf(\"\\n***> The name of the main configuration file looks suspicious...\\n\");\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\tprintf(\"     Make sure you are specifying the name of the MAIN configuration file on\\n\");\n\t\t\t\tprintf(\"     the command line and not the name of another configuration file.  The\\n\");\n\t\t\t\tprintf(\"     main configuration file is typically '%s'\\n\", DEFAULT_CONFIG_FILE);\n\t\t\t\t}\n\n\t\t\tprintf(\"\\n***> One or more problems was encountered while processing the config files...\\n\");\n\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"     Check your configuration file(s) to ensure that they contain valid\\n\");\n\t\t\tprintf(\"     directives and data definitions.  If you are upgrading from a previous\\n\");\n\t\t\tprintf(\"     version of Nagios, you should be aware that some variables/definitions\\n\");\n\t\t\tprintf(\"     may have been removed or modified in this version.  Make sure to read\\n\");\n\t\t\tprintf(\"     the HTML documentation regarding the config files, as well as the\\n\");\n\t\t\tprintf(\"     'Whats New' section to find out what has changed.\\n\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\n\t\tif(verify_config) {\n\t\t\tprintf(\"   Read object config files okay...\\n\\n\");\n\t\t\tprintf(\"Running pre-flight check on configuration data...\\n\\n\");\n\t\t\t}\n\n\t\t/* run the pre-flight check to make sure things look okay... */\n\t\tresult = pre_flight_check();\n\n\t\tif(result != OK) {\n\t\t\tprintf(\"\\n***> One or more problems was encountered while running the pre-flight check...\\n\");\n\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"     Check your configuration file(s) to ensure that they contain valid\\n\");\n\t\t\tprintf(\"     directives and data definitions.  If you are upgrading from a previous\\n\");\n\t\t\tprintf(\"     version of Nagios, you should be aware that some variables/definitions\\n\");\n\t\t\tprintf(\"     may have been removed or modified in this version.  Make sure to read\\n\");\n\t\t\tprintf(\"     the HTML documentation regarding the config files, as well as the\\n\");\n\t\t\tprintf(\"     'Whats New' section to find out what has changed.\\n\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\n\t\tif(verify_config) {\n\t\t\tprintf(\"\\nThings look okay - No serious problems were detected during the pre-flight check\\n\");\n\t\t\t}\n\n\t\t/* scheduling tests need a bit more than config verifications */\n\t\tif(test_scheduling == TRUE) {\n\n\t\t\t/* we'll need the event queue here so we can time insertions */\n\t\t\tinit_event_queue();\n\t\t\ttiming_point(\"Done initializing event queue\\n\");\n\n\t\t\t/* read initial service and host state information */\n\t\t\tinitialize_retention_data(config_file);\n\t\t\tread_initial_state_information();\n\t\t\ttiming_point(\"Retention data and initial state parsed\\n\");\n\n\t\t\t/* initialize the event timing loop */\n\t\t\tinit_timing_loop();\n\t\t\ttiming_point(\"Timing loop initialized\\n\");\n\n\t\t\t/* display scheduling information */\n\t\t\tdisplay_scheduling_info();\n\t\t\t}\n\n\t\tif(precache_objects) {\n\t\t\tresult = fcache_objects(object_precache_file);\n\t\t\ttiming_point(\"Done precaching objects\\n\");\n\t\t\tif(result == OK) {\n\t\t\t\tprintf(\"Object precache file created:\\n%s\\n\", object_precache_file);\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\tprintf(\"Failed to precache objects to '%s': %s\\n\", object_precache_file, strerror(errno));\n\t\t\t\t}\n\t\t\t}\n\n\t\t/* clean up after ourselves */\n\t\tcleanup();\n\n\t\t/* exit */\n\t\ttiming_point(\"Exiting\\n\");\n\n\t\t/* make valgrind shut up about still reachable memory */\n\t\tneb_free_module_list();\n\t\tfree(config_file_dir);\n\t\tfree(config_file);\n\n\t\texit(result);\n\t\t}\n\n\n\t/* else start to monitor things... */\n\telse {\n\n\t\t/*\n\t\t * if we're called with a relative path we must make\n\t\t * it absolute so we can launch our workers.\n\t\t * If not, we needn't bother, as we're using execvp()\n\t\t */\n\t\tif (strchr(argv[0], '/'))\n\t\t\tnagios_binary_path = nspath_absolute(argv[0], NULL);\n\t\telse\n\t\t\tnagios_binary_path = strdup(argv[0]);\n\n\t\tif (!nagios_binary_path) {\n\t\t\tlogit(NSLOG_RUNTIME_ERROR, TRUE, \"Error: Unable to allocate memory for nagios_binary_path\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\n\t\tif (!(nagios_iobs = iobroker_create())) {\n\t\t\tlogit(NSLOG_RUNTIME_ERROR, TRUE, \"Error: Failed to create IO broker set: %s\\n\",\n\t\t\t\t  strerror(errno));\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\n\t\t/* keep monitoring things until we get a shutdown command */\n\t\tdo {\n\t\t\t/* reset internal book-keeping (in case we're restarting) */\n\t\t\twproc_num_workers_spawned = wproc_num_workers_online = 0;\n\t\t\tcaught_signal = sigshutdown = FALSE;\n\t\t\tsig_id = 0;\n\n\t\t\t/* reset program variables */\n\t\t\treset_variables();\n\t\t\ttiming_point(\"Variables reset\\n\");\n\n\t\t\t/* get PID */\n\t\t\tnagios_pid = (int)getpid();\n\n\t\t\t/* read in the configuration files (main and resource config files) */\n\t\t\tresult = read_main_config_file(config_file);\n\t\t\tif (result != OK) {\n\t\t\t\tlogit(NSLOG_CONFIG_ERROR, TRUE, \"Error: Failed to process config file '%s'. Aborting\\n\", config_file);\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\ttiming_point(\"Main config file read\\n\");\n\n\t\t\t/* NOTE 11/06/07 EG moved to after we read config files, as user may have overridden timezone offset */\n\t\t\t/* get program (re)start time and save as macro */\n \t\t\tprogram_start = time(NULL);\n \t\t\tmy_free(mac->x[MACRO_PROCESSSTARTTIME]);\n \t\t\tasprintf(&mac->x[MACRO_PROCESSSTARTTIME], \"%llu\", (unsigned long long)program_start);\n \n \t\t\t/* drop privileges */\n \t\t\tif(drop_privileges(nagios_user, nagios_group) == ERROR) {\n\n\t\t\t\tlogit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_CONFIG_ERROR, TRUE, \"Failed to drop privileges.  Aborting.\");\n\n\t\t\t\tcleanup();\n\t\t\t\texit(ERROR);\n\t\t\t\t}\n\n\t\t\tif (test_path_access(nagios_binary_path, X_OK)) {\n\t\t\t\tlogit(NSLOG_RUNTIME_ERROR, TRUE, \"Error: failed to access() %s: %s\\n\", nagios_binary_path, strerror(errno));\n\t\t\t\tlogit(NSLOG_RUNTIME_ERROR, TRUE, \"Error: Spawning workers will be impossible. Aborting.\\n\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\n\t\t\tif (test_configured_paths() == ERROR) {\n \t\t\t\t/* error has already been logged */\n \t\t\t\texit(EXIT_FAILURE);\n \t\t\t\t}\n\t\t\t/* enter daemon mode (unless we're restarting...) */\n\t\t\tif(daemon_mode == TRUE && sigrestart == FALSE) {\n\t\t\t\tresult = daemon_init();\n\t\t\t\t/* we had an error daemonizing, so bail... */\n\t\t\t\tif(result == ERROR) {\n\t\t\t\t\tlogit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR, TRUE, \"Bailing out due to failure to daemonize. (PID=%d)\", (int)getpid());\n\t\t\t\t\tcleanup();\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t\t}\n\t\t\t\t/* get new PID */\n\t\t\t\tnagios_pid = (int)getpid();\n\t\t\t\t}\n \n \t\t\t/* this must be logged after we read config data, as user may have changed location of main log file */\n \t\t\tlogit(NSLOG_PROCESS_INFO, TRUE, \"Nagios %s starting... (PID=%d)\\n\", PROGRAM_VERSION, (int)getpid());\n\n\t\t\t/* log the local time - may be different than clock time due to timezone offset */\n\t\t\tnow = time(NULL);\n\t\t\ttm = localtime_r(&now, &tm_s);\n\t\t\tstrftime(datestring, sizeof(datestring), \"%a %b %d %H:%M:%S %Z %Y\", tm);\n\t\t\tlogit(NSLOG_PROCESS_INFO, TRUE, \"Local time is %s\", datestring);\n\n\t\t\t/* write log version/info */\n\t\t\twrite_log_file_info(NULL);\n\n\t\t\t/* open debug log now that we're the right user */\n\t\t\topen_debug_log();\n\n#ifdef USE_EVENT_BROKER\n\t\t\t/* initialize modules */\n\t\t\tneb_init_modules();\n\t\t\tneb_init_callback_list();\n#endif\n\t\t\ttiming_point(\"NEB module API initialized\\n\");\n\n\t\t\t/* handle signals (interrupts) before we do any socket I/O */\n\t\t\tsetup_sighandler();\n\n\t\t\t/*\n\t\t\t * Initialize query handler and event subscription service.\n\t\t\t * This must be done before modules are initialized, so\n\t\t\t * the modules can use our in-core stuff properly\n\t\t\t */\n\t\t\tif (qh_init(qh_socket_path ? qh_socket_path : DEFAULT_QUERY_SOCKET) != OK) {\n\t\t\t\tlogit(NSLOG_RUNTIME_ERROR, TRUE, \"Error: Failed to initialize query handler. Aborting\\n\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\ttiming_point(\"Query handler initialized\\n\");\n\t\t\tnerd_init();\n\t\t\ttiming_point(\"NERD initialized\\n\");\n\n\t\t\t/* initialize check workers */\n\t\t\tif(init_workers(num_check_workers) < 0) {\n\t\t\t\tlogit(NSLOG_RUNTIME_ERROR, TRUE, \"Failed to spawn workers. Aborting\\n\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\ttiming_point(\"%u workers spawned\\n\", wproc_num_workers_spawned);\n\t\t\ti = 0;\n\t\t\twhile (i < 50 && wproc_num_workers_online < wproc_num_workers_spawned) {\n\t\t\t\tiobroker_poll(nagios_iobs, 50);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\ttiming_point(\"%u workers connected\\n\", wproc_num_workers_online);\n\n\t\t\t/* now that workers have arrived we can set the defaults */\n\t\t\tset_loadctl_defaults();\n\n#ifdef USE_EVENT_BROKER\n\t\t\t/* load modules */\n\t\t\tif (neb_load_all_modules() != OK) {\n\t\t\t\tlogit(NSLOG_CONFIG_ERROR, ERROR, \"Error: Module loading failed. Aborting.\\n\");\n\t\t\t\t/* if we're dumping core, we must remove all dl-files */\n\t\t\t\tif (daemon_dumps_core)\n\t\t\t\t\tneb_unload_all_modules(NEBMODULE_FORCE_UNLOAD, NEBMODULE_NEB_SHUTDOWN);\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\ttiming_point(\"Modules loaded\\n\");\n\n\t\t\t/* send program data to broker */\n\t\t\tbroker_program_state(NEBTYPE_PROCESS_PRELAUNCH, NEBFLAG_NONE, NEBATTR_NONE, NULL);\n\t\t\ttiming_point(\"First callback made\\n\");\n#endif\n\n\t\t\t/* read in all object config data */\n\t\t\tif(result == OK)\n\t\t\t\tresult = read_all_object_data(config_file);\n\n\t\t\t/* there was a problem reading the config files */\n\t\t\tif(result != OK)\n\t\t\t\tlogit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_CONFIG_ERROR, TRUE, \"Bailing out due to one or more errors encountered in the configuration files. Run Nagios from the command line with the -v option to verify your config before restarting. (PID=%d)\", (int)getpid());\n\n\t\t\telse {\n\n\t\t\t\t/* run the pre-flight check to make sure everything looks okay*/\n\t\t\t\tif((result = pre_flight_check()) != OK)\n\t\t\t\t\tlogit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_VERIFICATION_ERROR, TRUE, \"Bailing out due to errors encountered while running the pre-flight check.  Run Nagios from the command line with the -v option to verify your config before restarting. (PID=%d)\\n\", (int)getpid());\n\t\t\t\t}\n\n\t\t\t/* an error occurred that prevented us from (re)starting */\n\t\t\tif(result != OK) {\n\n\t\t\t\t/* if we were restarting, we need to cleanup from the previous run */\n\t\t\t\tif(sigrestart == TRUE) {\n\n\t\t\t\t\t/* clean up the status data */\n\t\t\t\t\tcleanup_status_data(TRUE);\n\t\t\t\t\t}\n\n#ifdef USE_EVENT_BROKER\n\t\t\t\t/* send program data to broker */\n\t\t\t\tbroker_program_state(NEBTYPE_PROCESS_SHUTDOWN, NEBFLAG_PROCESS_INITIATED, NEBATTR_SHUTDOWN_ABNORMAL, NULL);\n#endif\n\t\t\t\tcleanup();\n\t\t\t\texit(ERROR);\n\t\t\t\t}\n\n\t\t\ttiming_point(\"Object configuration parsed and understood\\n\");\n\n\t\t\t/* write the objects.cache file */\n\t\t\tfcache_objects(object_cache_file);\n\t\t\ttiming_point(\"Objects cached\\n\");\n\n\t\t\tinit_event_queue();\n\t\t\ttiming_point(\"Event queue initialized\\n\");\n\n\n#ifdef USE_EVENT_BROKER\n\t\t\t/* send program data to broker */\n\t\t\tbroker_program_state(NEBTYPE_PROCESS_START, NEBFLAG_NONE, NEBATTR_NONE, NULL);\n#endif\n\n\t\t\t/* initialize status data unless we're starting */\n\t\t\tif(sigrestart == FALSE) {\n\t\t\t\tinitialize_status_data(config_file);\n\t\t\t\ttiming_point(\"Status data initialized\\n\");\n\t\t\t\t}\n\n\t\t\t/* initialize scheduled downtime data */\n\t\t\tinitialize_downtime_data();\n\t\t\ttiming_point(\"Downtime data initialized\\n\");\n\n\t\t\t/* read initial service and host state information  */\n\t\t\tinitialize_retention_data(config_file);\n\t\t\ttiming_point(\"Retention data initialized\\n\");\n\t\t\tread_initial_state_information();\n\t\t\ttiming_point(\"Initial state information read\\n\");\n\n\t\t\t/* initialize comment data */\n\t\t\tinitialize_comment_data();\n\t\t\ttiming_point(\"Comment data initialized\\n\");\n\n\t\t\t/* initialize performance data */\n\t\t\tinitialize_performance_data(config_file);\n\t\t\ttiming_point(\"Performance data initialized\\n\");\n\n\t\t\t/* initialize the event timing loop */\n\t\t\tinit_timing_loop();\n\t\t\ttiming_point(\"Event timing loop initialized\\n\");\n\n\t\t\t/* initialize check statistics */\n\t\t\tinit_check_stats();\n\t\t\ttiming_point(\"check stats initialized\\n\");\n\n\t\t\t/* check for updates */\n\t\t\tcheck_for_nagios_updates(FALSE, TRUE);\n\t\t\ttiming_point(\"Update check concluded\\n\");\n\n\t\t\t/* update all status data (with retained information) */\n\t\t\tupdate_all_status_data();\n\t\t\ttiming_point(\"Status data updated\\n\");\n\n\t\t\t/* log initial host and service state */\n\t\t\tlog_host_states(INITIAL_STATES, NULL);\n\t\t\tlog_service_states(INITIAL_STATES, NULL);\n\t\t\ttiming_point(\"Initial states logged\\n\");\n\n\t\t\t/* reset the restart flag */\n\t\t\tsigrestart = FALSE;\n\n\t\t\t/* fire up command file worker */\n\t\t\tlaunch_command_file_worker();\n\t\t\ttiming_point(\"Command file worker launched\\n\");\n\n#ifdef USE_EVENT_BROKER\n\t\t\t/* send program data to broker */\n\t\t\tbroker_program_state(NEBTYPE_PROCESS_EVENTLOOPSTART, NEBFLAG_NONE, NEBATTR_NONE, NULL);\n#endif\n\n\t\t\t/* get event start time and save as macro */\n\t\t\tevent_start = time(NULL);\n\t\t\tmy_free(mac->x[MACRO_EVENTSTARTTIME]);\n\t\t\tasprintf(&mac->x[MACRO_EVENTSTARTTIME], \"%llu\", (unsigned long long)event_start);\n\n\t\t\ttiming_point(\"Entering event execution loop\\n\");\n\t\t\t/***** start monitoring all services *****/\n\t\t\t/* (doesn't return until a restart or shutdown signal is encountered) */\n\t\t\tevent_execution_loop();\n\n\t\t\t/*\n\t\t\t * immediately deinitialize the query handler so it\n\t\t\t * can remove modules that have stashed data with it\n\t\t\t */\n\t\t\tqh_deinit(qh_socket_path ? qh_socket_path : DEFAULT_QUERY_SOCKET);\n\n\t\t\t/* 03/01/2007 EG Moved from sighandler() to prevent FUTEX locking problems under NPTL */\n\t\t\t/* 03/21/2007 EG SIGSEGV signals are still logged in sighandler() so we don't loose them */\n\t\t\t/* did we catch a signal? */\n\t\t\tif(caught_signal == TRUE) {\n\n\t\t\t\tif(sig_id == SIGHUP)\n\t\t\t\t\tlogit(NSLOG_PROCESS_INFO, TRUE, \"Caught SIGHUP, restarting...\\n\");\n\n\t\t\t\t}\n\n#ifdef USE_EVENT_BROKER\n\t\t\t/* send program data to broker */\n\t\t\tbroker_program_state(NEBTYPE_PROCESS_EVENTLOOPEND, NEBFLAG_NONE, NEBATTR_NONE, NULL);\n\t\t\tif(sigshutdown == TRUE)\n\t\t\t\tbroker_program_state(NEBTYPE_PROCESS_SHUTDOWN, NEBFLAG_USER_INITIATED, NEBATTR_SHUTDOWN_NORMAL, NULL);\n\t\t\telse if(sigrestart == TRUE)\n\t\t\t\tbroker_program_state(NEBTYPE_PROCESS_RESTART, NEBFLAG_USER_INITIATED, NEBATTR_RESTART_NORMAL, NULL);\n#endif\n\n\t\t\t/* save service and host state information */\n\t\t\tsave_state_information(FALSE);\n\t\t\tcleanup_retention_data();\n\n\t\t\t/* clean up performance data */\n\t\t\tcleanup_performance_data();\n\n\t\t\t/* clean up the scheduled downtime data */\n\t\t\tcleanup_downtime_data();\n\n\t\t\t/* clean up the status data unless we're restarting */\n\t\t\tif(sigrestart == FALSE) {\n\t\t\t\tcleanup_status_data(TRUE);\n\t\t\t\t}\n\n\t\t\tfree_worker_memory(WPROC_FORCE);\n\t\t\t/* shutdown stuff... */\n\t\t\tif(sigshutdown == TRUE) {\n\t\t\t\tiobroker_destroy(nagios_iobs, IOBROKER_CLOSE_SOCKETS);\n\t\t\t\tnagios_iobs = NULL;\n\n\t\t\t\t/* log a shutdown message */\n\t\t\t\tlogit(NSLOG_PROCESS_INFO, TRUE, \"Successfully shutdown... (PID=%d)\\n\", (int)getpid());\n\t\t\t\t}\n\n\t\t\t/* clean up after ourselves */\n\t\t\tcleanup();\n\n\t\t\t/* close debug log */\n\t\t\tclose_debug_log();\n\n\t\t\t}\n\t\twhile(sigrestart == TRUE && sigshutdown == FALSE);\n\n\t\tif(daemon_mode == TRUE)\n\t\t\tunlink(lock_file);\n\n\t\t/* free misc memory */\n\t\tmy_free(lock_file);\n\t\tmy_free(config_file);\n\t\tmy_free(config_file_dir);\n\t\tmy_free(nagios_binary_path);\n\t\t}\n\n\treturn OK;\n\t}\n", "target": 1, "idx": 181138}
{"func": "xfs_attr_fork_reset(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_trans\t*tp)\n{\n\txfs_idestroy_fork(ip, XFS_ATTR_FORK);\n\tip->i_d.di_forkoff = 0;\n\tip->i_d.di_aformat = XFS_DINODE_FMT_EXTENTS;\n\n\tASSERT(ip->i_d.di_anextents == 0);\n\tASSERT(ip->i_afp == NULL);\n\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n}\n", "target": 0, "idx": 44946}
{"func": "CStarter::RemoteShutdownFast(int)\n{\n\tbool fast_in_progress = false;\n\n\tif( jic ) {\n\t\tfast_in_progress = jic->isFastShutdown();\n\t\tjic->gotShutdownFast();\n\t}\n\tif( fast_in_progress == false ) {\n\t\treturn ( this->ShutdownFast( ) );\n\t}\n\telse {\n\t\treturn ( false );\n\t}\n}\n", "target": 0, "idx": 16397}
{"func": "_rpc_timelimit(slurm_msg_t *msg)\n{\n\tuid_t           uid = g_slurm_auth_get_uid(msg->auth_cred,\n\t\t\t\t\t\t   conf->auth_info);\n\tkill_job_msg_t *req = msg->data;\n\tint             nsteps, rc;\n\n\tif (!_slurm_authorized_user(uid)) {\n\t\terror (\"Security violation: rpc_timelimit req from uid %d\",\n\t\t       uid);\n\t\tslurm_send_rc_msg(msg, ESLURM_USER_ID_MISSING);\n\t\treturn;\n\t}\n\n\t/*\n\t *  Indicate to slurmctld that we've received the message\n\t */\n\tslurm_send_rc_msg(msg, SLURM_SUCCESS);\n\tslurm_close(msg->conn_fd);\n\tmsg->conn_fd = -1;\n\n\tif (req->step_id != NO_VAL) {\n\t\tslurm_ctl_conf_t *cf;\n\t\tint delay;\n\t\t/* A jobstep has timed out:\n\t\t * - send the container a SIG_TIME_LIMIT or SIG_PREEMPTED\n\t\t *   to log the event\n\t\t * - send a SIGCONT to resume any suspended tasks\n\t\t * - send a SIGTERM to begin termination\n\t\t * - sleep KILL_WAIT\n\t\t * - send a SIGKILL to clean up\n\t\t */\n\t\tif (msg->msg_type == REQUEST_KILL_TIMELIMIT) {\n\t\t\trc = _signal_jobstep(req->job_id, req->step_id, uid,\n\t\t\t\t\t     SIG_TIME_LIMIT);\n\t\t} else {\n\t\t\trc = _signal_jobstep(req->job_id, req->step_id, uid,\n\t\t\t\t\t     SIG_PREEMPTED);\n\t\t}\n\t\tif (rc != SLURM_SUCCESS)\n\t\t\treturn;\n\t\trc = _signal_jobstep(req->job_id, req->step_id, uid, SIGCONT);\n\t\tif (rc != SLURM_SUCCESS)\n\t\t\treturn;\n\t\trc = _signal_jobstep(req->job_id, req->step_id, uid, SIGTERM);\n\t\tif (rc != SLURM_SUCCESS)\n\t\t\treturn;\n\t\tcf = slurm_conf_lock();\n\t\tdelay = MAX(cf->kill_wait, 5);\n\t\tslurm_conf_unlock();\n\t\tsleep(delay);\n\t\t_signal_jobstep(req->job_id, req->step_id, uid, SIGKILL);\n\t\treturn;\n\t}\n\n\tif (msg->msg_type == REQUEST_KILL_TIMELIMIT)\n\t\t_kill_all_active_steps(req->job_id, SIG_TIME_LIMIT, true);\n\telse /* (msg->type == REQUEST_KILL_PREEMPTED) */\n\t\t_kill_all_active_steps(req->job_id, SIG_PREEMPTED, true);\n\tnsteps = _kill_all_active_steps(req->job_id, SIGTERM, false);\n\tverbose( \"Job %u: timeout: sent SIGTERM to %d active steps\",\n\t\t req->job_id, nsteps );\n\n\t/* Revoke credential, send SIGKILL, run epilog, etc. */\n\t_rpc_terminate_job(msg);\n}\n", "target": 0, "idx": 72136}
{"func": " PHP_FUNCTION(xml_set_object)\n {\n\txml_parser *parser;\n\tzval *pind, *mythis;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ro\", &pind, &mythis) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(parser,xml_parser *, &pind, -1, \"XML Parser\", le_xml_parser);\n\n\t/* please leave this commented - or ask thies@thieso.net before doing it (again) */\n\tif (parser->object) {\n\t\tzval_ptr_dtor(&parser->object);\n\t}\n \n        /* please leave this commented - or ask thies@thieso.net before doing it (again) */\n /* #ifdef ZEND_ENGINE_2\n       zval_add_ref(&parser->object); \n #endif */\n \n        ALLOC_ZVAL(parser->object);\n\tMAKE_COPY_ZVAL(&mythis, parser->object);\n\n\tRETVAL_TRUE;\n }\n", "target": 1, "idx": 178208}
{"func": "void WebPluginDelegateProxy::OnInvalidateRect(const gfx::Rect& rect) {\n  if (!plugin_)\n    return;\n \n  const gfx::Rect clipped_rect(rect.Intersect(\n      gfx::Rect(0, 0, plugin_rect_.width(), plugin_rect_.height())));\n \n   invalidate_pending_ = true;\n   CopyFromTransportToBacking(clipped_rect);\n  plugin_->InvalidateRect(clipped_rect);\n}\n", "target": 1, "idx": 183466}
{"func": "int kvm_arch_vcpu_init(struct kvm_vcpu *vcpu)\n{\n\tstruct page *page;\n\tstruct kvm *kvm;\n\tint r;\n\n\tBUG_ON(vcpu->kvm == NULL);\n\tkvm = vcpu->kvm;\n\n\tvcpu->arch.pv.pv_unhalted = false;\n\tvcpu->arch.emulate_ctxt.ops = &emulate_ops;\n\tif (!irqchip_in_kernel(kvm) || kvm_vcpu_is_reset_bsp(vcpu))\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\telse\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_UNINITIALIZED;\n\n\tpage = alloc_page(GFP_KERNEL | __GFP_ZERO);\n\tif (!page) {\n\t\tr = -ENOMEM;\n\t\tgoto fail;\n\t}\n\tvcpu->arch.pio_data = page_address(page);\n\n\tkvm_set_tsc_khz(vcpu, max_tsc_khz);\n\n\tr = kvm_mmu_create(vcpu);\n\tif (r < 0)\n\t\tgoto fail_free_pio_data;\n\n\tif (irqchip_in_kernel(kvm)) {\n\t\tr = kvm_create_lapic(vcpu);\n\t\tif (r < 0)\n\t\t\tgoto fail_mmu_destroy;\n\t} else\n\t\tstatic_key_slow_inc(&kvm_no_apic_vcpu);\n\n\tvcpu->arch.mce_banks = kzalloc(KVM_MAX_MCE_BANKS * sizeof(u64) * 4,\n\t\t\t\t       GFP_KERNEL);\n\tif (!vcpu->arch.mce_banks) {\n\t\tr = -ENOMEM;\n\t\tgoto fail_free_lapic;\n\t}\n\tvcpu->arch.mcg_cap = KVM_MAX_MCE_BANKS;\n\n\tif (!zalloc_cpumask_var(&vcpu->arch.wbinvd_dirty_mask, GFP_KERNEL)) {\n\t\tr = -ENOMEM;\n\t\tgoto fail_free_mce_banks;\n\t}\n\n\tfx_init(vcpu);\n\n\tvcpu->arch.ia32_tsc_adjust_msr = 0x0;\n\tvcpu->arch.pv_time_enabled = false;\n\n\tvcpu->arch.guest_supported_xcr0 = 0;\n\tvcpu->arch.guest_xstate_size = XSAVE_HDR_SIZE + XSAVE_HDR_OFFSET;\n\n\tvcpu->arch.maxphyaddr = cpuid_query_maxphyaddr(vcpu);\n\n\tvcpu->arch.pat = MSR_IA32_CR_PAT_DEFAULT;\n\n\tkvm_async_pf_hash_reset(vcpu);\n\tkvm_pmu_init(vcpu);\n\n\tvcpu->arch.pending_external_vector = -1;\n\n\treturn 0;\n\nfail_free_mce_banks:\n\tkfree(vcpu->arch.mce_banks);\nfail_free_lapic:\n\tkvm_free_lapic(vcpu);\nfail_mmu_destroy:\n\tkvm_mmu_destroy(vcpu);\nfail_free_pio_data:\n\tfree_page((unsigned long)vcpu->arch.pio_data);\nfail:\n\treturn r;\n}\n", "target": 0, "idx": 57706}
{"func": "void RenderLayerCompositor::finishCompositingUpdateForFrameTree(Frame* frame)\n{\n    for (Frame* child = frame->tree().firstChild(); child; child = child->tree().nextSibling())\n        finishCompositingUpdateForFrameTree(child);\n\n    if (frame && frame->contentRenderer()) {\n        RenderLayerCompositor* frameCompositor = frame->contentRenderer()->compositor();\n        if (frameCompositor && !frameCompositor->isMainFrame())\n            frame->contentRenderer()->compositor()->updateCompositingLayers();\n    }\n}\n", "target": 0, "idx": 122144}
{"func": "long long mkvparser::GetUIntLength(\n    IMkvReader* pReader,\n    long long pos,\n    long& len)\n{\n    assert(pReader);\n    assert(pos >= 0);\n \n    long long total, available;\n \n    int status = pReader->Length(&total, &available);\n    assert(status >= 0);\n    assert((total < 0) || (available <= total));\n \n    len = 1;\n \n    if (pos >= available)\n        return pos;  //too few bytes available\n \n//// TODO(vigneshv): This function assumes that unsigned values never have their\n//// high bit set.\n     unsigned char b;\n \n    status = pReader->Read(pos, 1, &b);\n \n     if (status < 0)\n        return status;\n \n    assert(status == 0);\n \n    if (b == 0)  //we can't handle u-int values larger than 8 bytes\n        return E_FILE_FORMAT_INVALID;\n \n    unsigned char m = 0x80;\n    while (!(b & m))\n    {\n        m >>= 1;\n        ++len;\n    }\n    return 0;  //success\n }\n", "target": 1, "idx": 188399}
{"func": "static Image *ReadVIFFImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n#define VFF_CM_genericRGB  15\n#define VFF_CM_ntscRGB  1\n#define VFF_CM_NONE  0\n#define VFF_DEP_DECORDER  0x4\n#define VFF_DEP_NSORDER  0x8\n#define VFF_DES_RAW  0\n#define VFF_LOC_IMPLICIT  1\n#define VFF_MAPTYP_NONE  0\n#define VFF_MAPTYP_1_BYTE  1\n#define VFF_MAPTYP_2_BYTE  2\n#define VFF_MAPTYP_4_BYTE  4\n#define VFF_MAPTYP_FLOAT  5\n#define VFF_MAPTYP_DOUBLE  7\n#define VFF_MS_NONE  0\n#define VFF_MS_ONEPERBAND  1\n#define VFF_MS_SHARED  3\n#define VFF_TYP_BIT  0\n#define VFF_TYP_1_BYTE  1\n#define VFF_TYP_2_BYTE  2\n#define VFF_TYP_4_BYTE  4\n#define VFF_TYP_FLOAT  5\n#define VFF_TYP_DOUBLE  9\n\n  typedef struct _ViffInfo\n  {\n    unsigned char\n      identifier,\n      file_type,\n      release,\n      version,\n      machine_dependency,\n      reserve[3];\n\n    char\n      comment[512];\n\n    unsigned int\n      rows,\n      columns,\n      subrows;\n\n    int\n      x_offset,\n      y_offset;\n\n    float\n      x_bits_per_pixel,\n      y_bits_per_pixel;\n\n    unsigned int\n      location_type,\n      location_dimension,\n      number_of_images,\n      number_data_bands,\n      data_storage_type,\n      data_encode_scheme,\n      map_scheme,\n      map_storage_type,\n      map_rows,\n      map_columns,\n      map_subrows,\n      map_enable,\n      maps_per_cycle,\n      color_space_model;\n  } ViffInfo;\n\n  double\n    min_value,\n    scale_factor,\n    value;\n\n  Image\n    *image;\n\n  int\n    bit;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  register IndexPacket\n    *indexes;\n\n  register ssize_t\n    x;\n\n  register PixelPacket\n    *q;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bytes_per_pixel,\n    lsb_first,\n    max_packets,\n    quantum;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  ViffInfo\n    viff_info;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read VIFF header (1024 bytes).\n  */\n  count=ReadBlob(image,1,&viff_info.identifier);\n  do\n  {\n    /*\n      Verify VIFF identifier.\n    */\n    if ((count == 0) || ((unsigned char) viff_info.identifier != 0xab))\n      ThrowReaderException(CorruptImageError,\"NotAVIFFImage\");\n    /*\n      Initialize VIFF image.\n    */\n    (void) ReadBlob(image,sizeof(viff_info.file_type),&viff_info.file_type);\n    (void) ReadBlob(image,sizeof(viff_info.release),&viff_info.release);\n    (void) ReadBlob(image,sizeof(viff_info.version),&viff_info.version);\n    (void) ReadBlob(image,sizeof(viff_info.machine_dependency),\n      &viff_info.machine_dependency);\n    (void) ReadBlob(image,sizeof(viff_info.reserve),viff_info.reserve);\n    count=ReadBlob(image,512,(unsigned char *) viff_info.comment);\n    viff_info.comment[511]='\\0';\n    if (strlen(viff_info.comment) > 4)\n      (void) SetImageProperty(image,\"comment\",viff_info.comment);\n    if ((viff_info.machine_dependency == VFF_DEP_DECORDER) ||\n        (viff_info.machine_dependency == VFF_DEP_NSORDER))\n      image->endian=LSBEndian;\n    else\n      image->endian=MSBEndian;\n    viff_info.rows=ReadBlobLong(image);\n    viff_info.columns=ReadBlobLong(image);\n    viff_info.subrows=ReadBlobLong(image);\n    viff_info.x_offset=(int) ReadBlobLong(image);\n    viff_info.y_offset=(int) ReadBlobLong(image);\n    viff_info.x_bits_per_pixel=(float) ReadBlobLong(image);\n    viff_info.y_bits_per_pixel=(float) ReadBlobLong(image);\n    viff_info.location_type=ReadBlobLong(image);\n    viff_info.location_dimension=ReadBlobLong(image);\n    viff_info.number_of_images=ReadBlobLong(image);\n    viff_info.number_data_bands=ReadBlobLong(image);\n    viff_info.data_storage_type=ReadBlobLong(image);\n    viff_info.data_encode_scheme=ReadBlobLong(image);\n    viff_info.map_scheme=ReadBlobLong(image);\n    viff_info.map_storage_type=ReadBlobLong(image);\n    viff_info.map_rows=ReadBlobLong(image);\n    viff_info.map_columns=ReadBlobLong(image);\n    viff_info.map_subrows=ReadBlobLong(image);\n    viff_info.map_enable=ReadBlobLong(image);\n    viff_info.maps_per_cycle=ReadBlobLong(image);\n    viff_info.color_space_model=ReadBlobLong(image);\n    for (i=0; i < 420; i++)\n      (void) ReadBlobByte(image);\n    image->columns=viff_info.rows;\n    image->rows=viff_info.columns;\n    image->depth=viff_info.x_bits_per_pixel <= 8 ? 8UL :\n      MAGICKCORE_QUANTUM_DEPTH;\n    /*\n      Verify that we can read this VIFF image.\n    */\n    number_pixels=(MagickSizeType) viff_info.columns*viff_info.rows;\n    if (number_pixels != (size_t) number_pixels)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if (number_pixels == 0)\n      ThrowReaderException(CoderError,\"ImageColumnOrRowSizeIsNotSupported\");\n    if ((viff_info.number_data_bands < 1) || (viff_info.number_data_bands > 4))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((viff_info.data_storage_type != VFF_TYP_BIT) &&\n        (viff_info.data_storage_type != VFF_TYP_1_BYTE) &&\n        (viff_info.data_storage_type != VFF_TYP_2_BYTE) &&\n        (viff_info.data_storage_type != VFF_TYP_4_BYTE) &&\n        (viff_info.data_storage_type != VFF_TYP_FLOAT) &&\n        (viff_info.data_storage_type != VFF_TYP_DOUBLE))\n      ThrowReaderException(CoderError,\"DataStorageTypeIsNotSupported\");\n    if (viff_info.data_encode_scheme != VFF_DES_RAW)\n      ThrowReaderException(CoderError,\"DataEncodingSchemeIsNotSupported\");\n    if ((viff_info.map_storage_type != VFF_MAPTYP_NONE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_1_BYTE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_2_BYTE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_4_BYTE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_FLOAT) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_DOUBLE))\n      ThrowReaderException(CoderError,\"MapStorageTypeIsNotSupported\");\n    if ((viff_info.color_space_model != VFF_CM_NONE) &&\n        (viff_info.color_space_model != VFF_CM_ntscRGB) &&\n        (viff_info.color_space_model != VFF_CM_genericRGB))\n      ThrowReaderException(CoderError,\"ColorspaceModelIsNotSupported\");\n    if (viff_info.location_type != VFF_LOC_IMPLICIT)\n      ThrowReaderException(CoderError,\"LocationTypeIsNotSupported\");\n    if (viff_info.number_of_images != 1)\n      ThrowReaderException(CoderError,\"NumberOfImagesIsNotSupported\");\n    if (viff_info.map_rows == 0)\n      viff_info.map_scheme=VFF_MS_NONE;\n    switch ((int) viff_info.map_scheme)\n    {\n      case VFF_MS_NONE:\n      {\n        if (viff_info.number_data_bands < 3)\n          {\n            /*\n              Create linear color ramp.\n            */\n            if (viff_info.data_storage_type == VFF_TYP_BIT)\n              image->colors=2;\n            else\n              if (viff_info.data_storage_type == VFF_MAPTYP_1_BYTE)\n                image->colors=256UL;\n              else\n                image->colors=image->depth <= 8 ? 256UL : 65536UL;\n            if (AcquireImageColormap(image,image->colors) == MagickFalse)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        break;\n      }\n      case VFF_MS_ONEPERBAND:\n      case VFF_MS_SHARED:\n      {\n        unsigned char\n          *viff_colormap;\n\n        /*\n          Allocate VIFF colormap.\n        */\n        switch ((int) viff_info.map_storage_type)\n        {\n          case VFF_MAPTYP_1_BYTE: bytes_per_pixel=1; break;\n          case VFF_MAPTYP_2_BYTE: bytes_per_pixel=2; break;\n          case VFF_MAPTYP_4_BYTE: bytes_per_pixel=4; break;\n          case VFF_MAPTYP_FLOAT: bytes_per_pixel=4; break;\n          case VFF_MAPTYP_DOUBLE: bytes_per_pixel=8; break;\n          default: bytes_per_pixel=1; break;\n        }\n        image->colors=viff_info.map_columns;\n        if (AcquireImageColormap(image,image->colors) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        viff_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,\n          viff_info.map_rows*bytes_per_pixel*sizeof(*viff_colormap));\n        if (viff_colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        /*\n          Read VIFF raster colormap.\n        */\n        count=ReadBlob(image,bytes_per_pixel*image->colors*viff_info.map_rows,\n          viff_colormap);\n        lsb_first=1;\n        if (*(char *) &lsb_first &&\n            ((viff_info.machine_dependency != VFF_DEP_DECORDER) &&\n             (viff_info.machine_dependency != VFF_DEP_NSORDER)))\n          switch ((int) viff_info.map_storage_type)\n          {\n            case VFF_MAPTYP_2_BYTE:\n            {\n              MSBOrderShort(viff_colormap,(bytes_per_pixel*image->colors*\n                viff_info.map_rows));\n              break;\n            }\n            case VFF_MAPTYP_4_BYTE:\n            case VFF_MAPTYP_FLOAT:\n            {\n              MSBOrderLong(viff_colormap,(bytes_per_pixel*image->colors*\n                viff_info.map_rows));\n              break;\n            }\n            default: break;\n          }\n        for (i=0; i < (ssize_t) (viff_info.map_rows*image->colors); i++)\n        {\n          switch ((int) viff_info.map_storage_type)\n          {\n            case VFF_MAPTYP_2_BYTE: value=1.0*((short *) viff_colormap)[i]; break;\n            case VFF_MAPTYP_4_BYTE: value=1.0*((int *) viff_colormap)[i]; break;\n            case VFF_MAPTYP_FLOAT: value=((float *) viff_colormap)[i]; break;\n            case VFF_MAPTYP_DOUBLE: value=((double *) viff_colormap)[i]; break;\n            default: value=1.0*viff_colormap[i]; break;\n          }\n          if (i < (ssize_t) image->colors)\n            {\n              image->colormap[i].red=ScaleCharToQuantum((unsigned char) value);\n              image->colormap[i].green=ScaleCharToQuantum((unsigned char)\n                value);\n              image->colormap[i].blue=ScaleCharToQuantum((unsigned char) value);\n            }\n          else\n            if (i < (ssize_t) (2*image->colors))\n              image->colormap[i % image->colors].green=ScaleCharToQuantum(\n                (unsigned char) value);\n            else\n              if (i < (ssize_t) (3*image->colors))\n                image->colormap[i % image->colors].blue=ScaleCharToQuantum(\n                  (unsigned char) value);\n        }\n        viff_colormap=(unsigned char *) RelinquishMagickMemory(viff_colormap);\n        break;\n      }\n      default:\n        ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");\n    }\n    /*\n      Initialize image structure.\n    */\n    image->matte=viff_info.number_data_bands == 4 ? MagickTrue : MagickFalse;\n    image->storage_class=\n      (viff_info.number_data_bands < 3 ? PseudoClass : DirectClass);\n    image->columns=viff_info.rows;\n    image->rows=viff_info.columns;\n     if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n       if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n         break;\n     /*\n       Allocate VIFF pixels.\n     */\n    switch ((int) viff_info.data_storage_type)\n    {\n      case VFF_TYP_2_BYTE: bytes_per_pixel=2; break;\n      case VFF_TYP_4_BYTE: bytes_per_pixel=4; break;\n      case VFF_TYP_FLOAT: bytes_per_pixel=4; break;\n      case VFF_TYP_DOUBLE: bytes_per_pixel=8; break;\n      default: bytes_per_pixel=1; break;\n    }\n    if (viff_info.data_storage_type == VFF_TYP_BIT)\n      max_packets=((image->columns+7UL) >> 3UL)*image->rows;\n    else\n      max_packets=(size_t) (number_pixels*viff_info.number_data_bands);\n    pixels=(unsigned char *) AcquireQuantumMemory(max_packets,\n      bytes_per_pixel*sizeof(*pixels));\n    if (pixels == (unsigned char *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    count=ReadBlob(image,bytes_per_pixel*max_packets,pixels);\n    lsb_first=1;\n    if (*(char *) &lsb_first &&\n        ((viff_info.machine_dependency != VFF_DEP_DECORDER) &&\n         (viff_info.machine_dependency != VFF_DEP_NSORDER)))\n      switch ((int) viff_info.data_storage_type)\n      {\n        case VFF_TYP_2_BYTE:\n        {\n          MSBOrderShort(pixels,bytes_per_pixel*max_packets);\n          break;\n        }\n        case VFF_TYP_4_BYTE:\n        case VFF_TYP_FLOAT:\n        {\n          MSBOrderLong(pixels,bytes_per_pixel*max_packets);\n          break;\n        }\n        default: break;\n      }\n    min_value=0.0;\n    scale_factor=1.0;\n    if ((viff_info.data_storage_type != VFF_TYP_1_BYTE) &&\n        (viff_info.map_scheme == VFF_MS_NONE))\n      {\n        double\n          max_value;\n\n        /*\n          Determine scale factor.\n        */\n        switch ((int) viff_info.data_storage_type)\n        {\n          case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[0]; break;\n          case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[0]; break;\n          case VFF_TYP_FLOAT: value=((float *) pixels)[0]; break;\n          case VFF_TYP_DOUBLE: value=((double *) pixels)[0]; break;\n          default: value=1.0*pixels[0]; break;\n        }\n        max_value=value;\n        min_value=value;\n        for (i=0; i < (ssize_t) max_packets; i++)\n        {\n          switch ((int) viff_info.data_storage_type)\n          {\n            case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[i]; break;\n            case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[i]; break;\n            case VFF_TYP_FLOAT: value=((float *) pixels)[i]; break;\n            case VFF_TYP_DOUBLE: value=((double *) pixels)[i]; break;\n            default: value=1.0*pixels[i]; break;\n          }\n          if (value > max_value)\n            max_value=value;\n          else\n            if (value < min_value)\n              min_value=value;\n        }\n        if ((min_value == 0) && (max_value == 0))\n          scale_factor=0;\n        else\n          if (min_value == max_value)\n            {\n              scale_factor=(MagickRealType) QuantumRange/min_value;\n              min_value=0;\n            }\n          else\n            scale_factor=(MagickRealType) QuantumRange/(max_value-min_value);\n      }\n    /*\n      Convert pixels to Quantum size.\n    */\n    p=(unsigned char *) pixels;\n    for (i=0; i < (ssize_t) max_packets; i++)\n    {\n      switch ((int) viff_info.data_storage_type)\n      {\n        case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[i]; break;\n        case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[i]; break;\n        case VFF_TYP_FLOAT: value=((float *) pixels)[i]; break;\n        case VFF_TYP_DOUBLE: value=((double *) pixels)[i]; break;\n        default: value=1.0*pixels[i]; break;\n      }\n      if (viff_info.map_scheme == VFF_MS_NONE)\n        {\n          value=(value-min_value)*scale_factor;\n          if (value > QuantumRange)\n            value=QuantumRange;\n          else\n            if (value < 0)\n              value=0;\n        }\n      *p=(unsigned char) value;\n      p++;\n    }\n    /*\n      Convert VIFF raster image to pixel packets.\n    */\n    p=(unsigned char *) pixels;\n    if (viff_info.data_storage_type == VFF_TYP_BIT)\n      {\n        /*\n          Convert bitmap scanline.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          indexes=GetAuthenticIndexQueue(image);\n          for (x=0; x < (ssize_t) (image->columns-7); x+=8)\n          {\n            for (bit=0; bit < 8; bit++)\n            {\n              quantum=(size_t) ((*p) & (0x01 << bit) ? 0 : 1);\n              SetPixelIndex(indexes+x+bit,quantum);\n             }\n            p++;\n          }\n          if ((image->columns % 8) != 0)\n            {\n              for (bit=0; bit < (int) (image->columns % 8); bit++)\n              {\n                quantum=(size_t) ((*p) & (0x01 << bit) ? 0 : 1);\n                SetPixelIndex(indexes+x+bit,quantum);\n              }\n              p++;\n            }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n    else\n      if (image->storage_class == PseudoClass)\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          indexes=GetAuthenticIndexQueue(image);\n          for (x=0; x < (ssize_t) image->columns; x++)\n            SetPixelIndex(indexes+x,*p++);\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      else\n        {\n          /*\n            Convert DirectColor scanline.\n          */\n          number_pixels=(MagickSizeType) image->columns*image->rows;\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (PixelPacket *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelRed(q,ScaleCharToQuantum(*p));\n              SetPixelGreen(q,ScaleCharToQuantum(*(p+number_pixels)));\n              SetPixelBlue(q,ScaleCharToQuantum(*(p+2*number_pixels)));\n              if (image->colors != 0)\n                {\n                  ssize_t\n                    index;\n\n                  index=(ssize_t) GetPixelRed(q);\n                  SetPixelRed(q,image->colormap[(ssize_t)\n                    ConstrainColormapIndex(image,index)].red);\n                  index=(ssize_t) GetPixelGreen(q);\n                  SetPixelGreen(q,image->colormap[(ssize_t)\n                    ConstrainColormapIndex(image,index)].green);\n                  index=(ssize_t) GetPixelRed(q);\n                  SetPixelBlue(q,image->colormap[(ssize_t)\n                    ConstrainColormapIndex(image,index)].blue);\n                }\n              SetPixelOpacity(q,image->matte != MagickFalse ? QuantumRange-\n                ScaleCharToQuantum(*(p+number_pixels*3)) : OpaqueOpacity);\n              p++;\n              q++;\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n    pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n    if (image->storage_class == PseudoClass)\n      (void) SyncImage(image);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    count=ReadBlob(image,1,&viff_info.identifier);\n    if ((count != 0) && (viff_info.identifier == 0xab))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while ((count != 0) && (viff_info.identifier == 0xab));\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n", "target": 1, "idx": 181789}
{"func": "static size_t GetIPTCStream(unsigned char **info,size_t length)\n{\n  int\n    c;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    extent,\n    info_length;\n\n  unsigned int\n    marker;\n\n  size_t\n    tag_length;\n\n  p=(*info);\n  extent=length;\n  if ((*p == 0x1c) && (*(p+1) == 0x02))\n    return(length);\n  /*\n    Extract IPTC from 8BIM resource block.\n  */\n  while (extent >= 12)\n  {\n    if (strncmp((const char *) p,\"8BIM\",4))\n      break;\n    p+=4;\n    extent-=4;\n    marker=(unsigned int) (*p) << 8 | *(p+1);\n    p+=2;\n    extent-=2;\n    c=*p++;\n    extent--;\n    c|=0x01;\n    if ((size_t) c >= extent)\n      break;\n    p+=c;\n    extent-=c;\n    if (extent < 4)\n      break;\n    tag_length=(((size_t) *p) << 24) | (((size_t) *(p+1)) << 16) |\n      (((size_t) *(p+2)) << 8) | ((size_t) *(p+3));\n    p+=4;\n    extent-=4;\n    if (tag_length > extent)\n      break;\n    if (marker == IPTC_ID)\n      {\n        *info=p;\n        return(tag_length);\n      }\n    if ((tag_length & 0x01) != 0)\n      tag_length++;\n    p+=tag_length;\n    extent-=tag_length;\n  }\n  /*\n    Find the beginning of the IPTC info.\n  */\n  p=(*info);\n  tag_length=0;\niptc_find:\n  info_length=0;\n  marker=MagickFalse;\n  while (length != 0)\n  {\n    c=(*p++);\n    length--;\n    if (length == 0)\n      break;\n    if (c == 0x1c)\n      {\n        p--;\n        *info=p; /* let the caller know were it is */\n        break;\n      }\n  }\n  /*\n    Determine the length of the IPTC info.\n  */\n  while (length != 0)\n  {\n    c=(*p++);\n    length--;\n    if (length == 0)\n      break;\n    if (c == 0x1c)\n      marker=MagickTrue;\n    else\n      if (marker)\n        break;\n      else\n        continue;\n    info_length++;\n    /*\n      Found the 0x1c tag; skip the dataset and record number tags.\n    */\n    c=(*p++); /* should be 2 */\n    length--;\n    if (length == 0)\n      break;\n    if ((info_length == 1) && (c != 2))\n      goto iptc_find;\n    info_length++;\n    c=(*p++); /* should be 0 */\n    length--;\n    if (length == 0)\n      break;\n    if ((info_length == 2) && (c != 0))\n      goto iptc_find;\n    info_length++;\n    /*\n      Decode the length of the block that follows - ssize_t or short format.\n    */\n    c=(*p++);\n    length--;\n    if (length == 0)\n      break;\n    info_length++;\n    if ((c & 0x80) != 0)\n      {\n        /*\n          Long format.\n        */\n        tag_length=0;\n        for (i=0; i < 4; i++)\n        {\n          tag_length<<=8;\n          tag_length|=(*p++);\n          length--;\n          if (length == 0)\n            break;\n          info_length++;\n        }\n      }\n    else\n      {\n        /*\n          Short format.\n        */\n        tag_length=((long) c) << 8;\n        c=(*p++);\n        length--;\n        if (length == 0)\n          break;\n        info_length++;\n        tag_length|=(long) c;\n      }\n    if (tag_length > (length+1))\n      break;\n    p+=tag_length;\n    length-=tag_length;\n    if (length == 0)\n      break;\n    info_length+=tag_length;\n  }\n  return(info_length);\n}\n", "target": 0, "idx": 91151}
{"func": "int Instance::GetDocumentPixelWidth() const {\n  return static_cast<int>(ceil(document_size_.width() * zoom_ * device_scale_));\n}\n", "target": 0, "idx": 128565}
{"func": "  void WaitForPanelActiveStates(const std::vector<bool>& old_states,\n                                const std::vector<bool>& new_states) {\n    DCHECK(old_states.size() == new_states.size());\n    std::vector<Panel*> panels = PanelManager::GetInstance()->panels();\n    for (size_t i = 0; i < old_states.size(); i++) {\n      if (old_states[i] != new_states[i]){\n        WaitForPanelActiveState(\n            panels[i], new_states[i] ? SHOW_AS_ACTIVE : SHOW_AS_INACTIVE);\n      }\n    }\n  }\n", "target": 0, "idx": 115329}
{"func": "int ndp_call_eventfd_handler(struct ndp *ndp)\n{\n\treturn ndp_sock_recv(ndp);\n}\n", "target": 0, "idx": 53902}
{"func": "static int _hid_get_hid_descriptor(struct hid_device_priv* dev, void *data, size_t *size)\n{\n\tstruct libusb_hid_descriptor d;\n\tuint8_t tmp[MAX_HID_DESCRIPTOR_SIZE];\n\tsize_t report_len = MAX_HID_DESCRIPTOR_SIZE;\n\t_hid_get_report_descriptor(dev, tmp, &report_len);\n\td.bLength = LIBUSB_DT_HID_SIZE;\n\td.bDescriptorType = LIBUSB_DT_HID;\n\td.bcdHID = 0x0110; /* 1.10 */\n\td.bCountryCode = 0;\n\td.bNumDescriptors = 1;\n\td.bClassDescriptorType = LIBUSB_DT_REPORT;\n\td.wClassDescriptorLength = (uint16_t)report_len;\n\tif (*size > LIBUSB_DT_HID_SIZE)\n\t\t*size = LIBUSB_DT_HID_SIZE;\n\tmemcpy(data, &d, *size);\n\treturn LIBUSB_COMPLETED;\n}\n", "target": 1, "idx": 187214}
{"func": "inline void SearchBuffer::prependContext(const UChar* characters, size_t length)\n{\n    ASSERT(m_needsMoreContext);\n    ASSERT(m_prefixLength == m_buffer.size());\n\n    if (!length)\n        return;\n\n    m_atBreak = false;\n\n    size_t wordBoundaryContextStart = length;\n    if (wordBoundaryContextStart) {\n        U16_BACK_1(characters, 0, wordBoundaryContextStart);\n        wordBoundaryContextStart = startOfLastWordBoundaryContext(characters, wordBoundaryContextStart);\n    }\n\n    size_t usableLength = min(m_buffer.capacity() - m_prefixLength, length - wordBoundaryContextStart);\n    m_buffer.prepend(characters + length - usableLength, usableLength);\n    m_prefixLength += usableLength;\n\n    if (wordBoundaryContextStart || m_prefixLength == m_buffer.capacity())\n        m_needsMoreContext = false;\n}\n", "target": 0, "idx": 121627}
{"func": "status_t SampleTable::setSyncSampleParams(off64_t data_offset, size_t data_size) {\n if (mSyncSampleOffset >= 0 || data_size < 8) {\n return ERROR_MALFORMED;\n }\n\n uint8_t header[8];\n if (mDataSource->readAt(\n                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {\n return ERROR_IO;\n }\n\n if (U32_AT(header) != 0) {\n return ERROR_MALFORMED;\n }\n\n uint32_t numSyncSamples = U32_AT(&header[4]);\n\n if (numSyncSamples < 2) {\n        ALOGV(\"Table of sync samples is empty or has only a single entry!\");\n }\n\n uint64_t allocSize = (uint64_t)numSyncSamples * sizeof(uint32_t);\n if (allocSize > kMaxTotalSize) {\n        ALOGE(\"Sync sample table size too large.\");\n return ERROR_OUT_OF_RANGE;\n }\n\n    mTotalSize += allocSize;\n if (mTotalSize > kMaxTotalSize) {\n        ALOGE(\"Sync sample table size would make sample table too large.\\n\"\n \"    Requested sync sample table size = %llu\\n\"\n \"    Eventual sample table size >= %llu\\n\"\n \"    Allowed sample table size = %llu\\n\",\n (unsigned long long)allocSize,\n (unsigned long long)mTotalSize,\n (unsigned long long)kMaxTotalSize);\n return ERROR_OUT_OF_RANGE;\n }\n\n    mSyncSamples = new (std::nothrow) uint32_t[numSyncSamples];\n if (!mSyncSamples) {\n        ALOGE(\"Cannot allocate sync sample table with %llu entries.\",\n (unsigned long long)numSyncSamples);\n return ERROR_OUT_OF_RANGE;\n }\n\n \n     if (mDataSource->readAt(data_offset + 8, mSyncSamples,\n             (size_t)allocSize) != (ssize_t)allocSize) {\n        delete mSyncSamples;\n         mSyncSamples = NULL;\n         return ERROR_IO;\n     }\n\n for (size_t i = 0; i < numSyncSamples; ++i) {\n if (mSyncSamples[i] == 0) {\n            ALOGE(\"b/32423862, unexpected zero value in stss\");\n continue;\n }\n        mSyncSamples[i] = ntohl(mSyncSamples[i]) - 1;\n }\n\n    mSyncSampleOffset = data_offset;\n    mNumSyncSamples = numSyncSamples;\n\n return OK;\n}\n", "target": 1, "idx": 188014}
{"func": "bool IsKeyboardOverscrollEnabled() {\n  if (!IsKeyboardEnabled())\n    return false;\n\n  if (g_accessibility_keyboard_enabled)\n    return false;\n\n  if (g_keyboard_overscroll_override != KEYBOARD_OVERSCROLL_OVERRIDE_NONE) {\n    return g_keyboard_overscroll_override ==\n        KEYBOARD_OVERSCROLL_OVERRIDE_ENABLED;\n  }\n\n  if (base::CommandLine::ForCurrentProcess()->HasSwitch(\n          switches::kDisableVirtualKeyboardOverscroll)) {\n    return false;\n  }\n  return true;\n}\n", "target": 0, "idx": 132411}
{"func": "static void find_best_method(BlurMethod *blur, double r2)\n{\n    static const int index[][4] = {\n        { 1, 2, 3, 4 },\n        { 1, 2, 3, 5 },\n        { 1, 2, 4, 6 },\n    };\n\n    double mu[5];\n    if (r2 < 1.9) {\n        blur->level = blur->prefilter = blur->filter = 0;\n\n        if (r2 < 0.5) {\n            mu[2] = 0.085 * r2 * r2 * r2;\n            mu[1] = 0.5 * r2 - 4 * mu[2];\n            mu[3] = mu[4] = 0;\n        } else {\n            calc_gauss(mu, 4, r2);\n        }\n    } else {\n        double mul = 1;\n        if (r2 < 6.693) {\n            blur->level = 0;\n\n            if (r2 < 2.8)\n                blur->prefilter = 1;\n            else if (r2 < 4.4)\n                blur->prefilter = 2;\n            else\n                blur->prefilter = 3;\n\n            blur->filter = blur->prefilter - 1;\n        } else {\n            frexp((r2 + 0.7) / 26.5, &blur->level);\n            blur->level = (blur->level + 3) >> 1;\n            mul = pow(0.25, blur->level);\n            r2 *= mul;\n\n            if (r2 < 3.15 - 1.5 * mul)\n                blur->prefilter = 0;\n            else if (r2 < 5.3 - 5.2 * mul)\n                blur->prefilter = 1;\n            else\n                blur->prefilter = 2;\n\n            blur->filter = blur->prefilter;\n        }\n        calc_coeff(mu + 1, index[blur->filter], blur->prefilter, r2, mul);\n    }\n\n    for (int i = 1; i <= 4; ++i)\n        blur->coeff[i - 1] = (int)(0x10000 * mu[i] + 0.5);\n}\n", "target": 0, "idx": 73333}
{"func": "inline bool PulseAudioMixer::MainloopSafeLock() const {\n   AutoLock lock(mixer_state_lock_);\n   if ((mixer_state_ == SHUTTING_DOWN) || (!pa_mainloop_))\n     return false;\n   pa_threaded_mainloop_lock(pa_mainloop_);\n   ++mainloop_lock_count_;\n   return true;\n }\n", "target": 1, "idx": 184164}
{"func": "static PHP_RINIT_FUNCTION(libxml)\n{\n\tif (_php_libxml_per_request_initialization) {\n\t\t/* report errors via handler rather than stderr */\n                xmlSetGenericErrorFunc(NULL, php_libxml_error_handler);\n                xmlParserInputBufferCreateFilenameDefault(php_libxml_input_buffer_create_filename);\n                xmlOutputBufferCreateFilenameDefault(php_libxml_output_buffer_create_filename);\n        }\n        return SUCCESS;\n }\n", "target": 1, "idx": 178445}
{"func": "DataReductionProxySettings::~DataReductionProxySettings() {\n  spdy_proxy_auth_enabled_.Destroy();\n}\n", "target": 1, "idx": 186528}
{"func": "ModuleExport size_t RegisterMPCImage(void)\n{\n  MagickInfo\n    *entry;\n\n   entry=SetMagickInfo(\"CACHE\");\n   entry->description=ConstantString(\"Magick Persistent Cache image format\");\n   entry->module=ConstantString(\"MPC\");\n  entry->seekable_stream=MagickTrue;\n   entry->stealth=MagickTrue;\n   (void) RegisterMagickInfo(entry);\n   entry=SetMagickInfo(\"MPC\");\n  entry->decoder=(DecodeImageHandler *) ReadMPCImage;\n  entry->encoder=(EncodeImageHandler *) WriteMPCImage;\n  entry->magick=(IsImageFormatHandler *) IsMPC;\n  entry->description=ConstantString(\"Magick Persistent Cache image format\");\n  entry->seekable_stream=MagickTrue;\n  entry->module=ConstantString(\"MPC\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n", "target": 1, "idx": 183212}
{"func": "XRecordUnregisterClients(Display *dpy, XRecordContext context,\n\t\t\t XRecordClientSpec *clients, int nclients)\n{\n    XExtDisplayInfo *info = find_display (dpy);\n    register xRecordUnregisterClientsReq \t*req;\n    int\t\t\tclen = 4 * nclients;\n\n    XRecordCheckExtension (dpy, info, 0);\n    LockDisplay(dpy);\n    GetReq(RecordUnregisterClients, req);\n\n    req->reqType = info->codes->major_opcode;\n    req->recordReqType = X_RecordUnregisterClients;\n    req->context = context;\n    req->length += nclients;\n    req->nClients = nclients;\n\n    Data32(dpy, (long *)clients, clen);\n\n    UnlockDisplay(dpy);\n    SyncHandle();\n    return 1;\n}\n", "target": 0, "idx": 8267}
{"func": "SkColor AutofillPopupBaseView::GetBackgroundColor() {\n  return GetNativeTheme()->GetSystemColor(\n      ui::NativeTheme::kColorId_MenuBackgroundColor);\n}\n", "target": 0, "idx": 141867}
{"func": "void LockScreenMediaControlsView::SetArtwork(\n    base::Optional<gfx::ImageSkia> img) {\n  if (!img.has_value()) {\n    session_artwork_->SetImage(nullptr);\n     return;\n   }\n \n  session_artwork_->SetImageSize(ScaleSizeToFitView(\n      img->size(), gfx::Size(kArtworkViewWidth, kArtworkViewHeight)));\n   session_artwork_->SetImage(*img);\n }\n", "target": 1, "idx": 186310}
{"func": "bool FidoCableHandshakeHandler::ValidateAuthenticatorHandshakeMessage(\n    base::span<const uint8_t> response) {\n  crypto::HMAC hmac(crypto::HMAC::SHA256);\n  if (!hmac.Init(handshake_key_))\n    return false;\n\n  if (response.size() != kCableAuthenticatorHandshakeMessageSize) {\n    return false;\n  }\n\n  const auto authenticator_hello = response.first(\n      kCableAuthenticatorHandshakeMessageSize - kCableHandshakeMacMessageSize);\n  if (!hmac.VerifyTruncated(\n          fido_parsing_utils::ConvertToStringPiece(authenticator_hello),\n          fido_parsing_utils::ConvertToStringPiece(\n              response.subspan(authenticator_hello.size())))) {\n    return false;\n  }\n\n  const auto authenticator_hello_cbor =\n      cbor::CBORReader::Read(authenticator_hello);\n  if (!authenticator_hello_cbor || !authenticator_hello_cbor->is_map() ||\n      authenticator_hello_cbor->GetMap().size() != 2) {\n    return false;\n  }\n\n  const auto authenticator_hello_msg =\n      authenticator_hello_cbor->GetMap().find(cbor::CBORValue(0));\n  if (authenticator_hello_msg == authenticator_hello_cbor->GetMap().end() ||\n      !authenticator_hello_msg->second.is_string() ||\n      authenticator_hello_msg->second.GetString() !=\n          kCableAuthenticatorHelloMessage) {\n    return false;\n  }\n\n  const auto authenticator_random_nonce =\n      authenticator_hello_cbor->GetMap().find(cbor::CBORValue(1));\n  if (authenticator_random_nonce == authenticator_hello_cbor->GetMap().end() ||\n      !authenticator_random_nonce->second.is_bytestring() ||\n      authenticator_random_nonce->second.GetBytestring().size() != 16) {\n    return false;\n   }\n \n   cable_device_->SetEncryptionData(\n      GetEncryptionKeyAfterSuccessfulHandshake(\n          authenticator_random_nonce->second.GetBytestring()),\n       nonce_);\n \n   return true;\n}\n", "target": 1, "idx": 186242}
{"func": "int __glXDisp_ChangeDrawableAttributesSGIX(__GLXclientState *cl, GLbyte *pc)\n{\n    xGLXChangeDrawableAttributesSGIXReq *req =\n\t(xGLXChangeDrawableAttributesSGIXReq *)pc;\n\n    return DoChangeDrawableAttributes(cl->client, req->drawable,\n\t\t\t\t      req->numAttribs, (CARD32 *) (req + 1));\n}\n", "target": 0, "idx": 14142}
{"func": "void PepperRendererConnection::OnMsgDidCreateInProcessInstance(\n     PP_Instance instance,\n     const PepperRendererInstanceData& instance_data) {\n   PepperRendererInstanceData data = instance_data;\n   data.render_process_id = render_process_id_;\n   in_process_host_->AddInstance(instance, data);\n }\n", "target": 1, "idx": 186279}
{"func": "  JavaInterfaceProvider(\n      const BindCallback& bind_callback,\n      service_manager::mojom::InterfaceProviderRequest request)\n      : bind_callback_(bind_callback), binding_(this, std::move(request)) {}\n", "target": 0, "idx": 151997}
{"func": "my_object_stringify (MyObject *obj, GValue *value, char **ret, GError **error)\n{\n  GValue valstr = {0, };\n  g_value_init (&valstr, G_TYPE_STRING);\n  if (!g_value_transform (value, &valstr))\n    {\n      g_set_error (error,\n\t\t   MY_OBJECT_ERROR,\n\t\t   MY_OBJECT_ERROR_FOO,\n\t\t   \"couldn't transform value\");\n      return FALSE;\n    }\n  *ret = g_value_dup_string (&valstr);\n  g_value_unset (&valstr);\n  return TRUE;\n}\n", "target": 1, "idx": 178294}
{"func": "  IOSurfaceGpuMemoryBuffer(const gfx::Size& size, gfx::BufferFormat format)\n      : mapped_(false), size_(size), format_(format) {\n    iosurface_ = gfx::CreateIOSurface(size, gfx::BufferFormat::BGRA_8888);\n  }\n", "target": 0, "idx": 162862}
{"func": "Win32StackFrameUnwinder::~Win32StackFrameUnwinder() {\n  if (pending_blacklisted_module_) {\n    LeafUnwindBlacklist::GetInstance()->AddModuleToBlacklist(\n        pending_blacklisted_module_);\n  }\n}\n", "target": 1, "idx": 185415}
{"func": "void BrowserInit::CreateAutomationProvider(const std::string& channel_id,\n                                           Profile* profile,\n                                           size_t expected_tabs) {\n  scoped_refptr<AutomationProviderClass> automation =\n      new AutomationProviderClass(profile);\n  automation->ConnectToChannel(channel_id);\n  automation->SetExpectedTabCount(expected_tabs);\n\n  AutomationProviderList* list =\n      g_browser_process->InitAutomationProviderList();\n  DCHECK(list);\n  list->AddProvider(automation);\n}\n", "target": 0, "idx": 100160}
{"func": " dophn_core(struct magic_set *ms, int clazz, int swap, int fd, off_t off,\n    int num, size_t size, off_t fsize, int *flags)\n {\n \tElf32_Phdr ph32;\n \tElf64_Phdr ph64;\n\tsize_t offset, len;\n\tunsigned char nbuf[BUFSIZ];\n\tssize_t bufsize;\n\n\tif (size != xph_sizeof) {\n\t\tif (file_printf(ms, \", corrupted program header size\") == -1)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Loop through all the program headers.\n\t */\n\tfor ( ; num; num--) {\n\t\tif (pread(fd, xph_addr, xph_sizeof, off) < (ssize_t)xph_sizeof) {\n\t\t\tfile_badread(ms);\n\t\t\treturn -1;\n\t\t}\n\t\toff += size;\n\n\t\tif (fsize != SIZE_UNKNOWN && xph_offset > fsize) {\n\t\t\t/* Perhaps warn here */\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (xph_type != PT_NOTE)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * This is a PT_NOTE section; loop through all the notes\n\t\t * in the section.\n\t\t */\n\t\tlen = xph_filesz < sizeof(nbuf) ? xph_filesz : sizeof(nbuf);\n\t\tif ((bufsize = pread(fd, nbuf, len, xph_offset)) == -1) {\n\t\t\tfile_badread(ms);\n\t\t\treturn -1;\n\t\t}\n\t\toffset = 0;\n\t\tfor (;;) {\n \t\t\tif (offset >= (size_t)bufsize)\n \t\t\t\tbreak;\n \t\t\toffset = donote(ms, nbuf, offset, (size_t)bufsize,\n\t\t\t    clazz, swap, 4, flags);\n \t\t\tif (offset == 0)\n \t\t\t\tbreak;\n \n\t\t}\n\t}\n\treturn 0;\n}\n", "target": 1, "idx": 179949}
{"func": "static int __init ulri_disable(char *s)\n{\n\tpr_info(\"Disabling ulri\\n\");\n\tnoulri = 1;\n\n\treturn 1;\n}\n", "target": 0, "idx": 25433}
{"func": "  virtual void SetUp() {\n    syncdb_.SetUp();\n\n    mock_server_.reset(\n        new MockConnectionManager(syncdb_.manager(), syncdb_.name()));\n    EnableDatatype(syncable::BOOKMARKS);\n    worker_ = new ModelSafeWorker();\n    std::vector<SyncEngineEventListener*> listeners;\n    listeners.push_back(this);\n    context_.reset(new SyncSessionContext(mock_server_.get(),\n        syncdb_.manager(), this, listeners));\n    context_->set_account_name(syncdb_.name());\n    ASSERT_FALSE(context_->resolver());\n    syncer_ = new Syncer();\n    session_.reset(MakeSession());\n\n    ScopedDirLookup dir(syncdb_.manager(), syncdb_.name());\n    CHECK(dir.good());\n    ReadTransaction trans(FROM_HERE, dir);\n    syncable::Directory::ChildHandles children;\n    dir->GetChildHandlesById(&trans, trans.root_id(), &children);\n    ASSERT_TRUE(0 == children.size());\n    saw_syncer_event_ = false;\n    root_id_ = TestIdFactory::root();\n    parent_id_ = ids_.MakeServer(\"parent id\");\n    child_id_ = ids_.MakeServer(\"child id\");\n  }\n", "target": 0, "idx": 101274}
{"func": "void PictureLayerImpl::AppendQuads(RenderPass* render_pass,\n                                   const Occlusion& occlusion_in_content_space,\n                                   AppendQuadsData* append_quads_data) {\n  DCHECK(!needs_post_commit_initialization_);\n  DCHECK_IMPLIES(!raster_source_->GetSize().IsEmpty(),\n                 bounds() == raster_source_->GetSize())\n      << \" bounds \" << bounds().ToString() << \" pile \"\n      << raster_source_->GetSize().ToString();\n\n  SharedQuadState* shared_quad_state =\n      render_pass->CreateAndAppendSharedQuadState();\n\n  if (raster_source_->IsSolidColor()) {\n    PopulateSharedQuadState(shared_quad_state);\n\n    AppendDebugBorderQuad(\n        render_pass, bounds(), shared_quad_state, append_quads_data);\n\n    SolidColorLayerImpl::AppendSolidQuads(\n        render_pass, occlusion_in_content_space, shared_quad_state,\n        visible_content_rect(), raster_source_->GetSolidColor(),\n        append_quads_data);\n    return;\n  }\n\n  float max_contents_scale = MaximumTilingContentsScale();\n  gfx::Transform scaled_draw_transform = draw_transform();\n  scaled_draw_transform.Scale(SK_MScalar1 / max_contents_scale,\n                              SK_MScalar1 / max_contents_scale);\n  gfx::Size scaled_content_bounds =\n      gfx::ToCeiledSize(gfx::ScaleSize(bounds(), max_contents_scale));\n  gfx::Rect scaled_visible_content_rect =\n      gfx::ScaleToEnclosingRect(visible_content_rect(), max_contents_scale);\n  scaled_visible_content_rect.Intersect(gfx::Rect(scaled_content_bounds));\n  Occlusion scaled_occlusion =\n      occlusion_in_content_space.GetOcclusionWithGivenDrawTransform(\n          scaled_draw_transform);\n\n  shared_quad_state->SetAll(\n      scaled_draw_transform, scaled_content_bounds, scaled_visible_content_rect,\n      draw_properties().clip_rect, draw_properties().is_clipped,\n      draw_properties().opacity, draw_properties().blend_mode,\n      sorting_context_id_);\n\n  if (current_draw_mode_ == DRAW_MODE_RESOURCELESS_SOFTWARE) {\n    AppendDebugBorderQuad(\n        render_pass,\n        scaled_content_bounds,\n        shared_quad_state,\n        append_quads_data,\n        DebugColors::DirectPictureBorderColor(),\n        DebugColors::DirectPictureBorderWidth(layer_tree_impl()));\n\n    gfx::Rect geometry_rect = scaled_visible_content_rect;\n    gfx::Rect opaque_rect = contents_opaque() ? geometry_rect : gfx::Rect();\n    gfx::Rect visible_geometry_rect =\n        scaled_occlusion.GetUnoccludedContentRect(geometry_rect);\n    if (visible_geometry_rect.IsEmpty())\n      return;\n\n    gfx::Size texture_size = scaled_visible_content_rect.size();\n    gfx::RectF texture_rect = gfx::RectF(texture_size);\n    gfx::Rect quad_content_rect = scaled_visible_content_rect;\n\n    PictureDrawQuad* quad =\n        render_pass->CreateAndAppendDrawQuad<PictureDrawQuad>();\n    quad->SetNew(shared_quad_state, geometry_rect, opaque_rect,\n                 visible_geometry_rect, texture_rect, texture_size,\n                 nearest_neighbor_, RGBA_8888, quad_content_rect,\n                 max_contents_scale, raster_source_);\n    return;\n  }\n\n  AppendDebugBorderQuad(\n      render_pass, scaled_content_bounds, shared_quad_state, append_quads_data);\n\n  if (ShowDebugBorders()) {\n    for (PictureLayerTilingSet::CoverageIterator iter(\n             tilings_.get(),\n             max_contents_scale,\n             scaled_visible_content_rect,\n             ideal_contents_scale_);\n         iter;\n         ++iter) {\n      SkColor color;\n      float width;\n      if (*iter && iter->IsReadyToDraw()) {\n        ManagedTileState::DrawInfo::Mode mode = iter->draw_info().mode();\n        if (mode == ManagedTileState::DrawInfo::SOLID_COLOR_MODE) {\n          color = DebugColors::SolidColorTileBorderColor();\n          width = DebugColors::SolidColorTileBorderWidth(layer_tree_impl());\n        } else if (mode == ManagedTileState::DrawInfo::PICTURE_PILE_MODE) {\n          color = DebugColors::PictureTileBorderColor();\n          width = DebugColors::PictureTileBorderWidth(layer_tree_impl());\n        } else if (iter.resolution() == HIGH_RESOLUTION) {\n          color = DebugColors::HighResTileBorderColor();\n          width = DebugColors::HighResTileBorderWidth(layer_tree_impl());\n        } else if (iter.resolution() == LOW_RESOLUTION) {\n          color = DebugColors::LowResTileBorderColor();\n          width = DebugColors::LowResTileBorderWidth(layer_tree_impl());\n        } else if (iter->contents_scale() > max_contents_scale) {\n          color = DebugColors::ExtraHighResTileBorderColor();\n          width = DebugColors::ExtraHighResTileBorderWidth(layer_tree_impl());\n        } else {\n          color = DebugColors::ExtraLowResTileBorderColor();\n          width = DebugColors::ExtraLowResTileBorderWidth(layer_tree_impl());\n        }\n      } else {\n        color = DebugColors::MissingTileBorderColor();\n        width = DebugColors::MissingTileBorderWidth(layer_tree_impl());\n      }\n\n      DebugBorderDrawQuad* debug_border_quad =\n          render_pass->CreateAndAppendDrawQuad<DebugBorderDrawQuad>();\n      gfx::Rect geometry_rect = iter.geometry_rect();\n      gfx::Rect visible_geometry_rect = geometry_rect;\n      debug_border_quad->SetNew(shared_quad_state,\n                                geometry_rect,\n                                visible_geometry_rect,\n                                color,\n                                width);\n    }\n  }\n\n  std::vector<PictureLayerTiling*> seen_tilings;\n\n  gfx::Rect scaled_viewport_for_tile_priority = gfx::ScaleToEnclosingRect(\n      GetViewportForTilePriorityInContentSpace(), max_contents_scale);\n\n  size_t missing_tile_count = 0u;\n  size_t on_demand_missing_tile_count = 0u;\n  only_used_low_res_last_append_quads_ = true;\n  for (PictureLayerTilingSet::CoverageIterator iter(tilings_.get(),\n                                                    max_contents_scale,\n                                                    scaled_visible_content_rect,\n                                                    ideal_contents_scale_);\n       iter;\n       ++iter) {\n    gfx::Rect geometry_rect = iter.geometry_rect();\n    gfx::Rect opaque_rect = contents_opaque() ? geometry_rect : gfx::Rect();\n    gfx::Rect visible_geometry_rect =\n        scaled_occlusion.GetUnoccludedContentRect(geometry_rect);\n    if (visible_geometry_rect.IsEmpty())\n      continue;\n\n    append_quads_data->visible_content_area +=\n        visible_geometry_rect.width() * visible_geometry_rect.height();\n\n    bool has_draw_quad = false;\n    if (*iter && iter->IsReadyToDraw()) {\n      const ManagedTileState::DrawInfo& draw_info = iter->draw_info();\n      switch (draw_info.mode()) {\n        case ManagedTileState::DrawInfo::RESOURCE_MODE: {\n          gfx::RectF texture_rect = iter.texture_rect();\n\n          if (iter->contents_scale() != raster_contents_scale_ &&\n              iter->contents_scale() != ideal_contents_scale_ &&\n              geometry_rect.Intersects(scaled_viewport_for_tile_priority)) {\n            append_quads_data->num_incomplete_tiles++;\n          }\n\n          TileDrawQuad* quad =\n              render_pass->CreateAndAppendDrawQuad<TileDrawQuad>();\n          quad->SetNew(shared_quad_state,\n                       geometry_rect,\n                       opaque_rect,\n                       visible_geometry_rect,\n                       draw_info.get_resource_id(),\n                       texture_rect,\n                       iter.texture_size(),\n                       draw_info.contents_swizzled(),\n                       nearest_neighbor_);\n          has_draw_quad = true;\n          break;\n        }\n        case ManagedTileState::DrawInfo::PICTURE_PILE_MODE: {\n          if (!layer_tree_impl()\n                   ->GetRendererCapabilities()\n                   .allow_rasterize_on_demand) {\n            ++on_demand_missing_tile_count;\n            break;\n          }\n\n          gfx::RectF texture_rect = iter.texture_rect();\n\n          ResourceProvider* resource_provider =\n              layer_tree_impl()->resource_provider();\n          ResourceFormat format =\n              resource_provider->memory_efficient_texture_format();\n          PictureDrawQuad* quad =\n              render_pass->CreateAndAppendDrawQuad<PictureDrawQuad>();\n          quad->SetNew(shared_quad_state, geometry_rect, opaque_rect,\n                       visible_geometry_rect, texture_rect, iter.texture_size(),\n                       nearest_neighbor_, format, iter->content_rect(),\n                       iter->contents_scale(), raster_source_);\n          has_draw_quad = true;\n          break;\n        }\n        case ManagedTileState::DrawInfo::SOLID_COLOR_MODE: {\n          SolidColorDrawQuad* quad =\n              render_pass->CreateAndAppendDrawQuad<SolidColorDrawQuad>();\n          quad->SetNew(shared_quad_state,\n                       geometry_rect,\n                       visible_geometry_rect,\n                       draw_info.get_solid_color(),\n                       false);\n          has_draw_quad = true;\n          break;\n        }\n      }\n    }\n\n    if (!has_draw_quad) {\n      if (draw_checkerboard_for_missing_tiles()) {\n        CheckerboardDrawQuad* quad =\n            render_pass->CreateAndAppendDrawQuad<CheckerboardDrawQuad>();\n        SkColor color = DebugColors::DefaultCheckerboardColor();\n        quad->SetNew(\n            shared_quad_state, geometry_rect, visible_geometry_rect, color);\n      } else {\n        SkColor color = SafeOpaqueBackgroundColor();\n        SolidColorDrawQuad* quad =\n            render_pass->CreateAndAppendDrawQuad<SolidColorDrawQuad>();\n        quad->SetNew(shared_quad_state,\n                     geometry_rect,\n                     visible_geometry_rect,\n                     color,\n                     false);\n      }\n\n      if (geometry_rect.Intersects(scaled_viewport_for_tile_priority)) {\n        append_quads_data->num_missing_tiles++;\n        ++missing_tile_count;\n      }\n      append_quads_data->approximated_visible_content_area +=\n          visible_geometry_rect.width() * visible_geometry_rect.height();\n      continue;\n    }\n\n    if (iter.resolution() != HIGH_RESOLUTION) {\n      append_quads_data->approximated_visible_content_area +=\n          visible_geometry_rect.width() * visible_geometry_rect.height();\n    }\n\n    if (iter.resolution() != LOW_RESOLUTION)\n      only_used_low_res_last_append_quads_ = false;\n\n    if (seen_tilings.empty() || seen_tilings.back() != iter.CurrentTiling())\n      seen_tilings.push_back(iter.CurrentTiling());\n  }\n\n  if (missing_tile_count) {\n    TRACE_EVENT_INSTANT2(\"cc\",\n                         \"PictureLayerImpl::AppendQuads checkerboard\",\n                         TRACE_EVENT_SCOPE_THREAD,\n                         \"missing_tile_count\",\n                         missing_tile_count,\n                         \"on_demand_missing_tile_count\",\n                         on_demand_missing_tile_count);\n  }\n\n  CleanUpTilingsOnActiveLayer(seen_tilings);\n}\n", "target": 0, "idx": 132816}
{"func": "mount_args_check(int argc, char **argv, const char *action)\n{\n   Eina_Bool opts = EINA_FALSE;\n   struct stat st;\n   const char *node;\n   char buf[PATH_MAX];\n\n   if (!strcmp(action, \"mount\"))\n     {\n        /* will ALWAYS be:\n           /path/to/mount -o nosuid,uid=XYZ,[utf8,] UUID=XXXX-XXXX[-XXXX-XXXX] /media/$devnode\n         */\n        if (argc != 6) return EINA_FALSE;\n        if (argv[2][0] == '-')\n          {\n             /* disallow any -options other than -o */\n             if (strcmp(argv[2], \"-o\")) return EINA_FALSE;\n             opts = mountopts_check(argv[3]);\n          }\n        if (!opts) return EINA_FALSE;\n        if (!strncmp(argv[4], \"UUID=\", sizeof(\"UUID=\") - 1))\n          {\n             if (!check_uuid(argv[4] + 5)) return EINA_FALSE;\n          }\n        else\n          {\n             if (strncmp(argv[4], \"/dev/\", 5)) return EINA_FALSE;\n             if (stat(argv[4], &st)) return EINA_FALSE;\n          }\n\n        node = strrchr(argv[5], '/');\n        if (!node) return EINA_FALSE;\n        if (!node[1]) return EINA_FALSE;\n        if (node - argv[5] != 6) return EINA_FALSE;\n        snprintf(buf, sizeof(buf), \"/dev%s\", node);\n        if (stat(buf, &st)) return EINA_FALSE;\n     }\n   else if (!strcmp(action, \"umount\"))\n     {\n        /* will ALWAYS be:\n           /path/to/umount /dev/$devnode\n         */\n        if (argc != 3) return EINA_FALSE;\n        if (strncmp(argv[2], \"/dev/\", 5)) return EINA_FALSE;\n        if (stat(argv[2], &st)) return EINA_FALSE;\n        node = strrchr(argv[2], '/');\n        if (!node) return EINA_FALSE;\n        if (!node[1]) return EINA_FALSE;\n        if (node - argv[2] != 4) return EINA_FALSE;\n        /* this is good, but it prevents umounting user-mounted removable media;\n         * need to figure out a better way...\n         *\n           snprintf(buf, sizeof(buf), \"/media%s\", node);\n           if (stat(buf, &st)) return EINA_FALSE;\n           if (!S_ISDIR(st.st_mode)) return EINA_FALSE;\n         */\n     }\n   else if (!strcmp(action, \"eject\"))\n     {\n        /* will ALWAYS be:\n           /path/to/eject /dev/$devnode\n         */\n        if (argc != 3) return EINA_FALSE;\n        if (strncmp(argv[2], \"/dev/\", 5)) return EINA_FALSE;\n        if (stat(argv[2], &st)) return EINA_FALSE;\n        node = strrchr(argv[2], '/');\n        if (!node) return EINA_FALSE;\n        if (!node[1]) return EINA_FALSE;\n        if (node - argv[2] != 4) return EINA_FALSE;\n     }\n   else return EINA_FALSE;\n   return EINA_TRUE;\n}\n", "target": 0, "idx": 18113}
{"func": "static int tg3_ptp_adjfreq(struct ptp_clock_info *ptp, s32 ppb)\n{\n\tstruct tg3 *tp = container_of(ptp, struct tg3, ptp_info);\n\tbool neg_adj = false;\n\tu32 correction = 0;\n\n\tif (ppb < 0) {\n\t\tneg_adj = true;\n\t\tppb = -ppb;\n\t}\n\n\t/* Frequency adjustment is performed using hardware with a 24 bit\n\t * accumulator and a programmable correction value. On each clk, the\n\t * correction value gets added to the accumulator and when it\n\t * overflows, the time counter is incremented/decremented.\n\t *\n\t * So conversion from ppb to correction value is\n\t *\t\tppb * (1 << 24) / 1000000000\n\t */\n\tcorrection = div_u64((u64)ppb * (1 << 24), 1000000000ULL) &\n\t\t     TG3_EAV_REF_CLK_CORRECT_MASK;\n\n\ttg3_full_lock(tp, 0);\n\n\tif (correction)\n\t\ttw32(TG3_EAV_REF_CLK_CORRECT_CTL,\n\t\t     TG3_EAV_REF_CLK_CORRECT_EN |\n\t\t     (neg_adj ? TG3_EAV_REF_CLK_CORRECT_NEG : 0) | correction);\n\telse\n\t\ttw32(TG3_EAV_REF_CLK_CORRECT_CTL, 0);\n\n\ttg3_full_unlock(tp);\n\n\treturn 0;\n}\n", "target": 0, "idx": 32689}
{"func": "   virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,\n                                   ::libvpx_test::Encoder *encoder) {\n     const vpx_rational_t tb = video->timebase();\n     timebase_ = static_cast<double>(tb.num) / tb.den;\n     duration_ = 0;\n }\n", "target": 1, "idx": 188537}
{"func": "do_ip_vs_get_ctl(struct sock *sk, int cmd, void __user *user, int *len)\n {\n \tunsigned char arg[128];\n \tint ret = 0;\n \n \tif (!capable(CAP_NET_ADMIN))\n \t\treturn -EPERM;\n \n \tif (*len < get_arglen[GET_CMDID(cmd)]) {\n \t\tpr_err(\"get_ctl: len %u < %u\\n\",\n \t\t       *len, get_arglen[GET_CMDID(cmd)]);\n \t\treturn -EINVAL;\n \t}\n \n\tif (copy_from_user(arg, user, get_arglen[GET_CMDID(cmd)]) != 0)\n \t\treturn -EFAULT;\n \n \tif (mutex_lock_interruptible(&__ip_vs_mutex))\n\t\treturn -ERESTARTSYS;\n\n\tswitch (cmd) {\n\tcase IP_VS_SO_GET_VERSION:\n\t{\n\t\tchar buf[64];\n\n\t\tsprintf(buf, \"IP Virtual Server version %d.%d.%d (size=%d)\",\n\t\t\tNVERSION(IP_VS_VERSION_CODE), IP_VS_CONN_TAB_SIZE);\n\t\tif (copy_to_user(user, buf, strlen(buf)+1) != 0) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\t*len = strlen(buf)+1;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_INFO:\n\t{\n\t\tstruct ip_vs_getinfo info;\n\t\tinfo.version = IP_VS_VERSION_CODE;\n\t\tinfo.size = IP_VS_CONN_TAB_SIZE;\n\t\tinfo.num_services = ip_vs_num_services;\n\t\tif (copy_to_user(user, &info, sizeof(info)) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_SERVICES:\n\t{\n\t\tstruct ip_vs_get_services *get;\n\t\tint size;\n\n\t\tget = (struct ip_vs_get_services *)arg;\n\t\tsize = sizeof(*get) +\n\t\t\tsizeof(struct ip_vs_service_entry) * get->num_services;\n\t\tif (*len != size) {\n\t\t\tpr_err(\"length: %u != %u\\n\", *len, size);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tret = __ip_vs_get_service_entries(get, user);\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_SERVICE:\n\t{\n\t\tstruct ip_vs_service_entry *entry;\n\t\tstruct ip_vs_service *svc;\n\t\tunion nf_inet_addr addr;\n\n\t\tentry = (struct ip_vs_service_entry *)arg;\n\t\taddr.ip = entry->addr;\n\t\tif (entry->fwmark)\n\t\t\tsvc = __ip_vs_svc_fwm_get(AF_INET, entry->fwmark);\n\t\telse\n\t\t\tsvc = __ip_vs_service_get(AF_INET, entry->protocol,\n\t\t\t\t\t\t  &addr, entry->port);\n\t\tif (svc) {\n\t\t\tip_vs_copy_service(entry, svc);\n\t\t\tif (copy_to_user(user, entry, sizeof(*entry)) != 0)\n\t\t\t\tret = -EFAULT;\n\t\t\tip_vs_service_put(svc);\n\t\t} else\n\t\t\tret = -ESRCH;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_DESTS:\n\t{\n\t\tstruct ip_vs_get_dests *get;\n\t\tint size;\n\n\t\tget = (struct ip_vs_get_dests *)arg;\n\t\tsize = sizeof(*get) +\n\t\t\tsizeof(struct ip_vs_dest_entry) * get->num_dests;\n\t\tif (*len != size) {\n\t\t\tpr_err(\"length: %u != %u\\n\", *len, size);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tret = __ip_vs_get_dest_entries(get, user);\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_TIMEOUT:\n\t{\n\t\tstruct ip_vs_timeout_user t;\n\n\t\t__ip_vs_get_timeouts(&t);\n\t\tif (copy_to_user(user, &t, sizeof(t)) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\tbreak;\n\n\tcase IP_VS_SO_GET_DAEMON:\n\t{\n\t\tstruct ip_vs_daemon_user d[2];\n\n\t\tmemset(&d, 0, sizeof(d));\n\t\tif (ip_vs_sync_state & IP_VS_STATE_MASTER) {\n\t\t\td[0].state = IP_VS_STATE_MASTER;\n\t\t\tstrlcpy(d[0].mcast_ifn, ip_vs_master_mcast_ifn, sizeof(d[0].mcast_ifn));\n\t\t\td[0].syncid = ip_vs_master_syncid;\n\t\t}\n\t\tif (ip_vs_sync_state & IP_VS_STATE_BACKUP) {\n\t\t\td[1].state = IP_VS_STATE_BACKUP;\n\t\t\tstrlcpy(d[1].mcast_ifn, ip_vs_backup_mcast_ifn, sizeof(d[1].mcast_ifn));\n\t\t\td[1].syncid = ip_vs_backup_syncid;\n\t\t}\n\t\tif (copy_to_user(user, &d, sizeof(d)) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n  out:\n\tmutex_unlock(&__ip_vs_mutex);\n\treturn ret;\n}\n", "target": 1, "idx": 179129}
{"func": "void VaapiVideoDecodeAccelerator::ReturnCurrInputBuffer_Locked() {\n  lock_.AssertAcquired();\n  DCHECK(decoder_thread_task_runner_->BelongsToCurrentThread());\n  DCHECK(curr_input_buffer_.get());\n\n  int32 id = curr_input_buffer_->id;\n  curr_input_buffer_.reset();\n  DVLOG(4) << \"End of input buffer \" << id;\n  message_loop_->PostTask(FROM_HERE, base::Bind(\n      &Client::NotifyEndOfBitstreamBuffer, client_, id));\n\n  --num_stream_bufs_at_decoder_;\n  TRACE_COUNTER1(\"Video Decoder\", \"Stream buffers at decoder\",\n                 num_stream_bufs_at_decoder_);\n}\n", "target": 0, "idx": 99652}
{"func": "static size_t adev_get_input_buffer_size(const struct audio_hw_device *dev,\n const struct audio_config *config)\n{\n (void)dev;\n\n /* NOTE: we default to built in mic which may cause a mismatch between what we\n     * report here and the actual buffer size\n     */\n return get_input_buffer_size(config->sample_rate,\n                                 config->format,\n                                 audio_channel_count_from_in_mask(config->channel_mask),\n                                 PCM_CAPTURE /* usecase_type */,\n                                 AUDIO_DEVICE_IN_BUILTIN_MIC);\n}\n", "target": 0, "idx": 175415}
{"func": "static int brcmf_vif_add_validate(struct brcmf_cfg80211_info *cfg,\n\t\t\t\t  enum nl80211_iftype new_type)\n{\n\tint iftype_num[NUM_NL80211_IFTYPES];\n\tstruct brcmf_cfg80211_vif *pos;\n\n\tmemset(&iftype_num[0], 0, sizeof(iftype_num));\n\tlist_for_each_entry(pos, &cfg->vif_list, list)\n\t\tiftype_num[pos->wdev.iftype]++;\n\n\tiftype_num[new_type]++;\n\treturn cfg80211_check_combinations(cfg->wiphy, 1, 0, iftype_num);\n}\n", "target": 0, "idx": 49130}
{"func": "IMPEG2D_ERROR_CODES_T impeg2d_dec_seq_hdr(dec_state_t *ps_dec)\n{\n stream_t *ps_stream;\n    ps_stream = &ps_dec->s_bit_stream;\n    UWORD16 u2_height;\n    UWORD16 u2_width;\n\n if (impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != SEQUENCE_HEADER_CODE)\n {\n        impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n return IMPEG2D_FRM_HDR_START_CODE_NOT_FOUND;\n\n }\n    impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n\n    u2_width    = impeg2d_bit_stream_get(ps_stream,12);\n    u2_height   = impeg2d_bit_stream_get(ps_stream,12);\n\n if ((u2_width != ps_dec->u2_horizontal_size)\n || (u2_height != ps_dec->u2_vertical_size))\n {\n if (0 == ps_dec->u2_header_done)\n {\n /* This is the first time we are reading the resolution */\n            ps_dec->u2_horizontal_size = u2_width;\n            ps_dec->u2_vertical_size = u2_height;\n if (0 == ps_dec->u4_frm_buf_stride)\n {\n                ps_dec->u4_frm_buf_stride  = (UWORD32) ALIGN16(u2_width);\n }\n }\n else\n {\n if((u2_width > ps_dec->u2_create_max_width)\n || (u2_height > ps_dec->u2_create_max_height))\n {\n                IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS;\n\n                ps_dec->u2_reinit_max_height   = u2_height;\n                ps_dec->u2_reinit_max_width    = u2_width;\n\n return e_error;\n }\n else\n {\n /* The resolution has changed */\n return (IMPEG2D_ERROR_CODES_T)IVD_RES_CHANGED;\n }\n }\n }\n\n if((ps_dec->u2_horizontal_size > ps_dec->u2_create_max_width)\n || (ps_dec->u2_vertical_size > ps_dec->u2_create_max_height))\n {\n        IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS;\n return SET_IVD_FATAL_ERROR(e_error);\n }\n\n\n /*------------------------------------------------------------------------*/\n /* Flush the following as they are not being used                         */\n /* aspect_ratio_info (4 bits)                                             */\n /*------------------------------------------------------------------------*/\n    ps_dec->u2_aspect_ratio_info = impeg2d_bit_stream_get(ps_stream,4);\n\n /*------------------------------------------------------------------------*/\n\n     /* Frame rate code(4 bits)                                                */\n     /*------------------------------------------------------------------------*/\n     ps_dec->u2_frame_rate_code = impeg2d_bit_stream_get(ps_stream,4);\n     /*------------------------------------------------------------------------*/\n     /* Flush the following as they are not being used                         */\n     /* bit_rate_value (18 bits)                                               */\n /*------------------------------------------------------------------------*/\n    impeg2d_bit_stream_flush(ps_stream,18);\n    GET_MARKER_BIT(ps_dec,ps_stream);\n /*------------------------------------------------------------------------*/\n /* Flush the following as they are not being used                         */\n /* vbv_buffer_size_value(10 bits), constrained_parameter_flag (1 bit)     */\n /*------------------------------------------------------------------------*/\n    impeg2d_bit_stream_flush(ps_stream,11);\n\n /*------------------------------------------------------------------------*/\n /* Quantization matrix for the intra blocks                               */\n /*------------------------------------------------------------------------*/\n if(impeg2d_bit_stream_get_bit(ps_stream) == 1)\n {\n        UWORD16 i;\n for(i = 0; i < NUM_PELS_IN_BLOCK; i++)\n {\n            ps_dec->au1_intra_quant_matrix[gau1_impeg2_inv_scan_zig_zag[i]] = (UWORD8)impeg2d_bit_stream_get(ps_stream,8);\n }\n\n }\n else\n {\n        memcpy(ps_dec->au1_intra_quant_matrix,gau1_impeg2_intra_quant_matrix_default,\n                NUM_PELS_IN_BLOCK);\n }\n\n /*------------------------------------------------------------------------*/\n /* Quantization matrix for the inter blocks                               */\n /*------------------------------------------------------------------------*/\n if(impeg2d_bit_stream_get_bit(ps_stream) == 1)\n {\n        UWORD16 i;\n for(i = 0; i < NUM_PELS_IN_BLOCK; i++)\n {\n            ps_dec->au1_inter_quant_matrix[gau1_impeg2_inv_scan_zig_zag[i]] = (UWORD8)impeg2d_bit_stream_get(ps_stream,8);\n }\n }\n else\n {\n        memcpy(ps_dec->au1_inter_quant_matrix,gau1_impeg2_inter_quant_matrix_default,\n            NUM_PELS_IN_BLOCK);\n }\n    impeg2d_next_start_code(ps_dec);\n\n return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;\n}\n", "target": 1, "idx": 188058}
{"func": "static void SkipDXTMipmaps(Image *image, DDSInfo *dds_info, int texel_size)\n {\n   register ssize_t\n     i;\n\n  MagickOffsetType\n    offset;\n\n  size_t\n    h,\n    w;\n\n  /*\n    Only skip mipmaps for textures and cube maps\n  */\n  if (dds_info->ddscaps1 & DDSCAPS_MIPMAP\n       && (dds_info->ddscaps1 & DDSCAPS_TEXTURE\n           || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))\n     {\n       w = DIV2(dds_info->width);\n       h = DIV2(dds_info->height);\n \n      /*\n        Mipmapcount includes the main image, so start from one\n      */\n      for (i = 1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)\n      {\n        offset = (MagickOffsetType) ((w + 3) / 4) * ((h + 3) / 4) * texel_size;\n        (void) SeekBlob(image, offset, SEEK_CUR);\n\n        w = DIV2(w);\n         h = DIV2(h);\n       }\n     }\n }\n", "target": 1, "idx": 182076}
{"func": "static void addrconf_mod_rs_timer(struct inet6_dev *idev,\n\t\t\t\t  unsigned long when)\n{\n\tif (!timer_pending(&idev->rs_timer))\n\t\tin6_dev_hold(idev);\n\tmod_timer(&idev->rs_timer, jiffies + when);\n}\n", "target": 0, "idx": 41788}
{"func": "int snd_seq_client_notify_subscription(int client, int port,\n\t\t\t\t       struct snd_seq_port_subscribe *info,\n\t\t\t\t       int evtype)\n{\n\tstruct snd_seq_event event;\n\n\tmemset(&event, 0, sizeof(event));\n\tevent.type = evtype;\n\tevent.data.connect.dest = info->dest;\n\tevent.data.connect.sender = info->sender;\n\n\treturn snd_seq_system_notify(client, port, &event);  /* non-atomic */\n}\n", "target": 0, "idx": 54683}
{"func": "GF_Err mfra_Size(GF_Box *s)\n{\n\tGF_Err e;\n\tGF_MovieFragmentRandomAccessBox *ptr = (GF_MovieFragmentRandomAccessBox *)s;\n\n\tif (ptr->mfro) {\n\t\te = gf_isom_box_size((GF_Box *)ptr->mfro);\n\t\tif (e) return e;\n\t\tptr->size += ptr->mfro->size;\n\t}\n\treturn gf_isom_box_array_size(s, ptr->tfra_list);\n}\n", "target": 0, "idx": 80239}
{"func": "static int x25_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t       struct msghdr *msg, size_t size,\n\t\t       int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct x25_sock *x25 = x25_sk(sk);\n\tstruct sockaddr_x25 *sx25 = (struct sockaddr_x25 *)msg->msg_name;\n\tsize_t copied;\n\tint qbit, header_len;\n\tstruct sk_buff *skb;\n\tunsigned char *asmptr;\n\tint rc = -ENOTCONN;\n\n\tlock_sock(sk);\n\n\tif (x25->neighbour == NULL)\n\t\tgoto out;\n\n\theader_len = x25->neighbour->extended ?\n\t\tX25_EXT_MIN_LEN : X25_STD_MIN_LEN;\n\n\t/*\n\t * This works for seqpacket too. The receiver has ordered the queue for\n\t * us! We do one quick check first though\n\t */\n\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\tgoto out;\n\n\tif (flags & MSG_OOB) {\n\t\trc = -EINVAL;\n\t\tif (sock_flag(sk, SOCK_URGINLINE) ||\n\t\t    !skb_peek(&x25->interrupt_in_queue))\n\t\t\tgoto out;\n\n\t\tskb = skb_dequeue(&x25->interrupt_in_queue);\n\n\t\tif (!pskb_may_pull(skb, X25_STD_MIN_LEN))\n\t\t\tgoto out_free_dgram;\n\n\t\tskb_pull(skb, X25_STD_MIN_LEN);\n\n\t\t/*\n\t\t *\tNo Q bit information on Interrupt data.\n\t\t */\n\t\tif (test_bit(X25_Q_BIT_FLAG, &x25->flags)) {\n\t\t\tasmptr  = skb_push(skb, 1);\n\t\t\t*asmptr = 0x00;\n\t\t}\n\n\t\tmsg->msg_flags |= MSG_OOB;\n\t} else {\n\t\t/* Now we can treat all alike */\n\t\trelease_sock(sk);\n\t\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\t\tflags & MSG_DONTWAIT, &rc);\n\t\tlock_sock(sk);\n\t\tif (!skb)\n\t\t\tgoto out;\n\n\t\tif (!pskb_may_pull(skb, header_len))\n\t\t\tgoto out_free_dgram;\n\n\t\tqbit = (skb->data[0] & X25_Q_BIT) == X25_Q_BIT;\n\n\t\tskb_pull(skb, header_len);\n\n\t\tif (test_bit(X25_Q_BIT_FLAG, &x25->flags)) {\n\t\t\tasmptr  = skb_push(skb, 1);\n\t\t\t*asmptr = qbit;\n\t\t}\n\t}\n\n\tskb_reset_transport_header(skb);\n\tcopied = skb->len;\n\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\t/* Currently, each datagram always contains a complete record */\n\tmsg->msg_flags |= MSG_EOR;\n\n\trc = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (rc)\n\t\tgoto out_free_dgram;\n\n \tif (sx25) {\n \t\tsx25->sx25_family = AF_X25;\n \t\tsx25->sx25_addr   = x25->dest_addr;\n \t}\n \n\tmsg->msg_namelen = sizeof(struct sockaddr_x25);\n \tx25_check_rbuf(sk);\n \trc = copied;\n out_free_dgram:\n\tskb_free_datagram(sk, skb);\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\n", "target": 1, "idx": 179696}
{"func": "static int ndp_sock_recv(struct ndp *ndp)\n{\n\tstruct ndp_msg *msg;\n\tenum ndp_msg_type msg_type;\n\tsize_t len;\n\tint err;\n\n\tmsg = ndp_msg_alloc();\n\tif (!msg)\n\t\treturn -ENOMEM;\n \n \tlen = ndp_msg_payload_maxlen(msg);\n \terr = myrecvfrom6(ndp->sock, msg->buf, &len, 0,\n\t\t\t  &msg->addrto, &msg->ifindex);\n \tif (err) {\n \t\terr(ndp, \"Failed to receive message\");\n \t\tgoto free_msg;\n \t}\n\tdbg(ndp, \"rcvd from: %s, ifindex: %u\",\n\t\t str_in6_addr(&msg->addrto), msg->ifindex);\n \n \tif (len < sizeof(*msg->icmp6_hdr)) {\n \t\twarn(ndp, \"rcvd icmp6 packet too short (%luB)\", len);\n\t\terr = 0;\n\t\tgoto free_msg;\n\t}\n\terr = ndp_msg_type_by_raw_type(&msg_type, msg->icmp6_hdr->icmp6_type);\n\tif (err) {\n\t\terr = 0;\n\t\tgoto free_msg;\n\t}\n\tndp_msg_init(msg, msg_type);\n\tndp_msg_payload_len_set(msg, len);\n\n\tif (!ndp_msg_check_valid(msg)) {\n\t\twarn(ndp, \"rcvd invalid ND message\");\n\t\terr = 0;\n\t\tgoto free_msg;\n\t}\n\n\tdbg(ndp, \"rcvd %s, len: %zuB\",\n\t\t ndp_msg_type_info(msg_type)->strabbr, len);\n\n\tif (!ndp_msg_check_opts(msg)) {\n\t\terr = 0;\n\t\tgoto free_msg;\n\t}\n\n\terr = ndp_call_handlers(ndp, msg);;\n\nfree_msg:\n\tndp_msg_destroy(msg);\n\treturn err;\n}\n", "target": 1, "idx": 180522}
{"func": "static int create_encryption_context_from_policy(struct inode *inode,\n\t\t\t\tconst struct fscrypt_policy *policy)\n{\n\tstruct fscrypt_context ctx;\n\tint res;\n\n\tif (!inode->i_sb->s_cop->set_context)\n\t\treturn -EOPNOTSUPP;\n\n\tif (inode->i_sb->s_cop->prepare_context) {\n\t\tres = inode->i_sb->s_cop->prepare_context(inode);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\n\tctx.format = FS_ENCRYPTION_CONTEXT_FORMAT_V1;\n\tmemcpy(ctx.master_key_descriptor, policy->master_key_descriptor,\n\t\t\t\t\tFS_KEY_DESCRIPTOR_SIZE);\n\n\tif (!fscrypt_valid_contents_enc_mode(\n\t\t\t\tpolicy->contents_encryption_mode)) {\n\t\tprintk(KERN_WARNING\n\t\t       \"%s: Invalid contents encryption mode %d\\n\", __func__,\n\t\t\tpolicy->contents_encryption_mode);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!fscrypt_valid_filenames_enc_mode(\n\t\t\t\tpolicy->filenames_encryption_mode)) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"%s: Invalid filenames encryption mode %d\\n\", __func__,\n\t\t\tpolicy->filenames_encryption_mode);\n\t\treturn -EINVAL;\n\t}\n\n\tif (policy->flags & ~FS_POLICY_FLAGS_VALID)\n\t\treturn -EINVAL;\n\n\tctx.contents_encryption_mode = policy->contents_encryption_mode;\n\tctx.filenames_encryption_mode = policy->filenames_encryption_mode;\n\tctx.flags = policy->flags;\n\tBUILD_BUG_ON(sizeof(ctx.nonce) != FS_KEY_DERIVATION_NONCE_SIZE);\n\tget_random_bytes(ctx.nonce, FS_KEY_DERIVATION_NONCE_SIZE);\n\n\treturn inode->i_sb->s_cop->set_context(inode, &ctx, sizeof(ctx), NULL);\n}\n", "target": 0, "idx": 70112}
{"func": "compat_do_replace(struct net *net, void __user *user, unsigned int len)\n{\n\tint ret;\n\tstruct compat_ipt_replace tmp;\n\tstruct xt_table_info *newinfo;\n\tvoid *loc_cpu_entry;\n\tstruct ipt_entry *iter;\n\n\tif (copy_from_user(&tmp, user, sizeof(tmp)) != 0)\n\t\treturn -EFAULT;\n\n\t/* overflow check */\n\tif (tmp.size >= INT_MAX / num_possible_cpus())\n\t\treturn -ENOMEM;\n\tif (tmp.num_counters >= INT_MAX / sizeof(struct xt_counters))\n\t\treturn -ENOMEM;\n\tif (tmp.num_counters == 0)\n\t\treturn -EINVAL;\n\n\ttmp.name[sizeof(tmp.name)-1] = 0;\n\n\tnewinfo = xt_alloc_table_info(tmp.size);\n\tif (!newinfo)\n\t\treturn -ENOMEM;\n\n\tloc_cpu_entry = newinfo->entries;\n\tif (copy_from_user(loc_cpu_entry, user + sizeof(tmp),\n\t\t\t   tmp.size) != 0) {\n\t\tret = -EFAULT;\n\t\tgoto free_newinfo;\n\t}\n\n\tret = translate_compat_table(net, tmp.name, tmp.valid_hooks,\n\t\t\t\t     &newinfo, &loc_cpu_entry, tmp.size,\n\t\t\t\t     tmp.num_entries, tmp.hook_entry,\n\t\t\t\t     tmp.underflow);\n\tif (ret != 0)\n\t\tgoto free_newinfo;\n\n\tduprintf(\"compat_do_replace: Translated table\\n\");\n\n\tret = __do_replace(net, tmp.name, tmp.valid_hooks, newinfo,\n\t\t\t   tmp.num_counters, compat_ptr(tmp.counters));\n\tif (ret)\n\t\tgoto free_newinfo_untrans;\n\treturn 0;\n\n free_newinfo_untrans:\n\txt_entry_foreach(iter, loc_cpu_entry, newinfo->size)\n\t\tcleanup_entry(iter, net);\n free_newinfo:\n\txt_free_table_info(newinfo);\n\treturn ret;\n}\n", "target": 0, "idx": 52283}
{"func": "static int irda_create(struct net *net, struct socket *sock, int protocol,\n\t\t       int kern)\n{\n \tstruct sock *sk;\n \tstruct irda_sock *self;\n \n \tif (net != &init_net)\n \t\treturn -EAFNOSUPPORT;\n \n\t/* Check for valid socket type */\n\tswitch (sock->type) {\n\tcase SOCK_STREAM:     /* For TTP connections with SAR disabled */\n\tcase SOCK_SEQPACKET:  /* For TTP connections with SAR enabled */\n\tcase SOCK_DGRAM:      /* For TTP Unitdata or LMP Ultra transfers */\n\t\tbreak;\n\tdefault:\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\n\t/* Allocate networking socket */\n\tsk = sk_alloc(net, PF_IRDA, GFP_KERNEL, &irda_proto, kern);\n\tif (sk == NULL)\n\t\treturn -ENOMEM;\n\n\tself = irda_sk(sk);\n\tpr_debug(\"%s() : self is %p\\n\", __func__, self);\n\n\tinit_waitqueue_head(&self->query_wait);\n\n\tswitch (sock->type) {\n\tcase SOCK_STREAM:\n\t\tsock->ops = &irda_stream_ops;\n\t\tself->max_sdu_size_rx = TTP_SAR_DISABLE;\n\t\tbreak;\n\tcase SOCK_SEQPACKET:\n\t\tsock->ops = &irda_seqpacket_ops;\n\t\tself->max_sdu_size_rx = TTP_SAR_UNBOUND;\n\t\tbreak;\n\tcase SOCK_DGRAM:\n\t\tswitch (protocol) {\n#ifdef CONFIG_IRDA_ULTRA\n\t\tcase IRDAPROTO_ULTRA:\n\t\t\tsock->ops = &irda_ultra_ops;\n\t\t\t/* Initialise now, because we may send on unbound\n\t\t\t * sockets. Jean II */\n\t\t\tself->max_data_size = ULTRA_MAX_DATA - LMP_PID_HEADER;\n\t\t\tself->max_header_size = IRDA_MAX_HEADER + LMP_PID_HEADER;\n\t\t\tbreak;\n#endif /* CONFIG_IRDA_ULTRA */\n\t\tcase IRDAPROTO_UNITDATA:\n\t\t\tsock->ops = &irda_dgram_ops;\n\t\t\t/* We let Unitdata conn. be like seqpack conn. */\n\t\t\tself->max_sdu_size_rx = TTP_SAR_UNBOUND;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsk_free(sk);\n\t\t\treturn -ESOCKTNOSUPPORT;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tsk_free(sk);\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\n\t/* Initialise networking socket struct */\n\tsock_init_data(sock, sk);\t/* Note : set sk->sk_refcnt to 1 */\n\tsk->sk_family = PF_IRDA;\n\tsk->sk_protocol = protocol;\n\n\t/* Register as a client with IrLMP */\n\tself->ckey = irlmp_register_client(0, NULL, NULL, NULL);\n\tself->mask.word = 0xffff;\n\tself->rx_flow = self->tx_flow = FLOW_START;\n\tself->nslots = DISCOVERY_DEFAULT_SLOTS;\n\tself->daddr = DEV_ADDR_ANY;\t/* Until we get connected */\n\tself->saddr = 0x0;\t\t/* so IrLMP assign us any link */\n\treturn 0;\n}\n", "target": 1, "idx": 179738}
{"func": "void SecurityHandler::SetRenderer(RenderProcessHost* process_host,\n                                   RenderFrameHostImpl* frame_host) {\n   host_ = frame_host;\n   if (enabled_ && host_)\n    AttachToRenderFrameHost();\n}\n", "target": 1, "idx": 186742}
{"func": "unsigned int arg_parse_uint(const struct arg *arg) {\n long int   rawval;\n char *endptr;\n\n  rawval = strtol(arg->val, &endptr, 10);\n\n if (arg->val[0] != '\\0' && endptr[0] == '\\0') {\n if (rawval >= 0 && rawval <= UINT_MAX)\n return rawval;\n\n    die(\"Option %s: Value %ld out of range for unsigned int\\n\",\n        arg->name, rawval);\n }\n\n  die(\"Option %s: Invalid character '%c'\\n\", arg->name, *endptr);\n return 0;\n}\n", "target": 0, "idx": 177512}
{"func": "void RTCPeerConnection::setLocalDescription(PassRefPtr<RTCSessionDescription> prpSessionDescription, PassRefPtr<VoidCallback> successCallback, PassRefPtr<RTCErrorCallback> errorCallback, ExceptionCode& ec)\n{\n    if (m_readyState == ReadyStateClosing || m_readyState == ReadyStateClosed) {\n        ec = INVALID_STATE_ERR;\n        return;\n    }\n    RefPtr<RTCSessionDescription> sessionDescription = prpSessionDescription;\n    if (!sessionDescription) {\n        ec = TYPE_MISMATCH_ERR;\n        return;\n    }\n    RefPtr<RTCVoidRequestImpl> request = RTCVoidRequestImpl::create(scriptExecutionContext(), successCallback, errorCallback);\n    m_peerHandler->setLocalDescription(request.release(), sessionDescription->descriptor());\n}\n", "target": 1, "idx": 183795}
{"func": " void BrowserActionsContainer::Observe(NotificationType type,\n                                       const NotificationSource& source,\n                                       const NotificationDetails& details) {\n   switch (type.value) {\n     case NotificationType::EXTENSION_HOST_VIEW_SHOULD_CLOSE:\n       if (!popup_ || Details<ExtensionHost>(popup_->host()) != details)\n        return;\n\n      HidePopup();\n      break;\n\n    default:\n      NOTREACHED() << \"Unexpected notification\";\n  }\n}\n", "target": 1, "idx": 183611}
{"func": "int udp_recvmsg(struct sock *sk, struct msghdr *msg, size_t len, int noblock,\n\t\tint flags, int *addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_in *, sin, msg->msg_name);\n\tstruct sk_buff *skb;\n\tunsigned int ulen, copied;\n \tint peeked, off = 0;\n \tint err;\n \tint is_udplite = IS_UDPLITE(sk);\n \tbool slow;\n \n \tif (flags & MSG_ERRQUEUE)\n\t\treturn ip_recv_error(sk, msg, len, addr_len);\n\ntry_again:\n\tskb = __skb_recv_datagram(sk, flags | (noblock ? MSG_DONTWAIT : 0),\n\t\t\t\t  &peeked, &off, &err);\n\tif (!skb)\n\t\tgoto out;\n\n\tulen = skb->len - sizeof(struct udphdr);\n\tcopied = len;\n\tif (copied > ulen)\n\t\tcopied = ulen;\n\telse if (copied < ulen)\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\n\t/*\n\t * If checksum is needed at all, try to do it while copying the\n\t * data.  If the data is truncated, or if we only want a partial\n\t * coverage checksum (UDP-Lite), do it before the copy.\n \t */\n \n \tif (copied < ulen || UDP_SKB_CB(skb)->partial_cov) {\n\t\tif (udp_lib_checksum_complete(skb))\n \t\t\tgoto csum_copy_err;\n \t}\n \n\tif (skb_csum_unnecessary(skb))\n \t\terr = skb_copy_datagram_msg(skb, sizeof(struct udphdr),\n \t\t\t\t\t    msg, copied);\n \telse {\n\t\terr = skb_copy_and_csum_datagram_msg(skb, sizeof(struct udphdr),\n\t\t\t\t\t\t     msg);\n\n\t\tif (err == -EINVAL)\n\t\t\tgoto csum_copy_err;\n\t}\n\n\tif (unlikely(err)) {\n\t\ttrace_kfree_skb(skb, udp_recvmsg);\n\t\tif (!peeked) {\n\t\t\tatomic_inc(&sk->sk_drops);\n\t\t\tUDP_INC_STATS_USER(sock_net(sk),\n\t\t\t\t\t   UDP_MIB_INERRORS, is_udplite);\n\t\t}\n\t\tgoto out_free;\n\t}\n\n\tif (!peeked)\n\t\tUDP_INC_STATS_USER(sock_net(sk),\n\t\t\t\tUDP_MIB_INDATAGRAMS, is_udplite);\n\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\n\t/* Copy the address. */\n\tif (sin) {\n\t\tsin->sin_family = AF_INET;\n\t\tsin->sin_port = udp_hdr(skb)->source;\n\t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n\t\tmemset(sin->sin_zero, 0, sizeof(sin->sin_zero));\n\t\t*addr_len = sizeof(*sin);\n\t}\n\tif (inet->cmsg_flags)\n\t\tip_cmsg_recv_offset(msg, skb, sizeof(struct udphdr));\n\n\terr = copied;\n\tif (flags & MSG_TRUNC)\n\t\terr = ulen;\n\nout_free:\n\tskb_free_datagram_locked(sk, skb);\nout:\n\treturn err;\n\ncsum_copy_err:\n\tslow = lock_sock_fast(sk);\n\tif (!skb_kill_datagram(sk, skb, flags)) {\n\t\tUDP_INC_STATS_USER(sock_net(sk), UDP_MIB_CSUMERRORS, is_udplite);\n\t\tUDP_INC_STATS_USER(sock_net(sk), UDP_MIB_INERRORS, is_udplite);\n\t}\n\tunlock_sock_fast(sk, slow);\n\n\t/* starting over for a new packet, but check if we need to yield */\n\tcond_resched();\n\tmsg->msg_flags &= ~MSG_TRUNC;\n\tgoto try_again;\n}\n", "target": 1, "idx": 181651}
{"func": "void dtls1_stop_timer(SSL *s)\n\t{\n\t/* Reset everything */\n\tmemset(&(s->d1->timeout), 0, sizeof(struct dtls1_timeout_st));\n\tmemset(&(s->d1->next_timeout), 0, sizeof(struct timeval));\n\ts->d1->timeout_duration = 1;\n\tBIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT, 0, &(s->d1->next_timeout));\n\t/* Clear retransmission buffer */\n\tdtls1_clear_record_buffer(s);\n\t}\n", "target": 0, "idx": 46117}
{"func": "perf_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct perf_event *event = file->private_data;\n\tstruct perf_event_context *ctx;\n\tint ret;\n\n\tctx = perf_event_ctx_lock(event);\n\tret = __perf_read(event, buf, count);\n\tperf_event_ctx_unlock(event, ctx);\n\n\treturn ret;\n}\n", "target": 0, "idx": 56133}
{"func": "static vpx_codec_err_t vp8_peek_si_internal(const uint8_t *data,\n unsigned int data_sz,\n vpx_codec_stream_info_t *si,\n                                            vpx_decrypt_cb decrypt_cb,\n void *decrypt_state)\n{\n vpx_codec_err_t res = VPX_CODEC_OK;\n\n if(data + data_sz <= data)\n {\n        res = VPX_CODEC_INVALID_PARAM;\n }\n else\n {\n /* Parse uncompresssed part of key frame header.\n         * 3 bytes:- including version, frame type and an offset\n         * 3 bytes:- sync code (0x9d, 0x01, 0x2a)\n         * 4 bytes:- including image width and height in the lowest 14 bits\n         *           of each 2-byte value.\n         */\n uint8_t clear_buffer[10];\n const uint8_t *clear = data;\n if (decrypt_cb)\n {\n int n = MIN(sizeof(clear_buffer), data_sz);\n            decrypt_cb(decrypt_state, data, clear_buffer, n);\n            clear = clear_buffer;\n }\n        si->is_kf = 0;\n\n if (data_sz >= 10 && !(clear[0] & 0x01)) /* I-Frame */\n {\n            si->is_kf = 1;\n\n /* vet via sync code */\n if (clear[3] != 0x9d || clear[4] != 0x01 || clear[5] != 0x2a)\n return VPX_CODEC_UNSUP_BITSTREAM;\n\n            si->w = (clear[6] | (clear[7] << 8)) & 0x3fff;\n\n             si->h = (clear[8] | (clear[9] << 8)) & 0x3fff;\n \n             /*printf(\"w=%d, h=%d\\n\", si->w, si->h);*/\n            if (!(si->h | si->w))\n                res = VPX_CODEC_UNSUP_BITSTREAM;\n         }\n         else\n         {\n            res = VPX_CODEC_UNSUP_BITSTREAM;\n }\n }\n\n return res;\n}\n", "target": 1, "idx": 187405}
{"func": "  virtual void SetUp() {\n    FakeDBusThreadManager* fake_dbus_thread_manager = new FakeDBusThreadManager;\n    fake_bluetooth_profile_manager_client_ =\n        new FakeBluetoothProfileManagerClient;\n     fake_dbus_thread_manager->SetBluetoothProfileManagerClient(\n         scoped_ptr<BluetoothProfileManagerClient>(\n             fake_bluetooth_profile_manager_client_));\n     fake_dbus_thread_manager->SetBluetoothAdapterClient(\n         scoped_ptr<BluetoothAdapterClient>(new FakeBluetoothAdapterClient));\n     fake_dbus_thread_manager->SetBluetoothDeviceClient(\n        scoped_ptr<BluetoothDeviceClient>(new FakeBluetoothDeviceClient));\n    fake_dbus_thread_manager->SetBluetoothInputClient(\n        scoped_ptr<BluetoothInputClient>(new FakeBluetoothInputClient));\n    DBusThreadManager::InitializeForTesting(fake_dbus_thread_manager);\n\n    device::BluetoothAdapterFactory::GetAdapter(\n        base::Bind(&BluetoothProfileChromeOSTest::AdapterCallback,\n                   base::Unretained(this)));\n    ASSERT_TRUE(adapter_.get() != NULL);\n    ASSERT_TRUE(adapter_->IsInitialized());\n    ASSERT_TRUE(adapter_->IsPresent());\n\n    adapter_->SetPowered(\n        true,\n        base::Bind(&base::DoNothing),\n        base::Bind(&base::DoNothing));\n    ASSERT_TRUE(adapter_->IsPowered());\n  }\n", "target": 1, "idx": 184934}
{"func": "activate_desktop_file (ActivateParameters *parameters,\n                       NautilusFile       *file)\n{\n    ActivateParametersDesktop *parameters_desktop;\n    char *primary, *secondary, *display_name;\n    GtkWidget *dialog;\n    GdkScreen *screen;\n    char *uri;\n\n    screen = gtk_widget_get_screen (GTK_WIDGET (parameters->parent_window));\n\n    if (!nautilus_file_is_trusted_link (file))\n    {\n        /* copy the parts of parameters we are interested in as the orignal will be freed */\n        parameters_desktop = g_new0 (ActivateParametersDesktop, 1);\n        if (parameters->parent_window)\n        {\n            parameters_desktop->parent_window = parameters->parent_window;\n            g_object_add_weak_pointer (G_OBJECT (parameters_desktop->parent_window), (gpointer *) &parameters_desktop->parent_window);\n        }\n        parameters_desktop->file = nautilus_file_ref (file);\n\n        primary = _(\"Untrusted application launcher\");\n        display_name = nautilus_file_get_display_name (file);\n        secondary =\n            g_strdup_printf (_(\"The application launcher \u201c%s\u201d has not been marked as trusted. \"\n                               \"If you do not know the source of this file, launching it may be unsafe.\"\n                               ),\n                             display_name);\n\n        dialog = gtk_message_dialog_new (parameters->parent_window,\n                                         0,\n                                         GTK_MESSAGE_WARNING,\n                                         GTK_BUTTONS_NONE,\n                                         NULL);\n        g_object_set (dialog,\n                       \"text\", primary,\n                       \"secondary-text\", secondary,\n                       NULL);\n         gtk_dialog_add_button (GTK_DIALOG (dialog),\n                               _(\"_Launch Anyway\"), RESPONSE_RUN);\n         if (nautilus_file_can_set_permissions (file))\n         {\n             gtk_dialog_add_button (GTK_DIALOG (dialog),\n                                   _(\"Mark as _Trusted\"), RESPONSE_MARK_TRUSTED);\n         }\n        gtk_dialog_add_button (GTK_DIALOG (dialog),\n                               _(\"_Cancel\"), GTK_RESPONSE_CANCEL);\n        gtk_dialog_set_default_response (GTK_DIALOG (dialog), GTK_RESPONSE_CANCEL);\n         g_signal_connect (dialog, \"response\",\n                           G_CALLBACK (untrusted_launcher_response_callback),\n                           parameters_desktop);\n        gtk_widget_show (dialog);\n\n        g_free (display_name);\n        g_free (secondary);\n        return;\n    }\n\n    uri = nautilus_file_get_uri (file);\n    DEBUG (\"Launching trusted launcher %s\", uri);\n    nautilus_launch_desktop_file (screen, uri, NULL,\n                                  parameters->parent_window);\n    g_free (uri);\n}\n", "target": 1, "idx": 180924}
{"func": "cmsHANDLE  CMSEXPORT cmsIT8LoadFromFile(cmsContext ContextID, const char* cFileName)\n{\n\n     cmsHANDLE hIT8;\n     cmsIT8*  it8;\n     int type;\n\n     _cmsAssert(cFileName != NULL);\n\n     type = IsMyFile(cFileName);\n     if (type == 0) return NULL;\n\n     hIT8 = cmsIT8Alloc(ContextID);\n     it8 = (cmsIT8*) hIT8;\n     if (!hIT8) return NULL;\n\n\n     it8 ->FileStack[0]->Stream = fopen(cFileName, \"rt\");\n\n     if (!it8 ->FileStack[0]->Stream) {\n         cmsIT8Free(hIT8);\n         return NULL;\n     }\n\n\n    strncpy(it8->FileStack[0]->FileName, cFileName, cmsMAX_PATH-1);\n    it8->FileStack[0]->FileName[cmsMAX_PATH-1] = 0;\n\n    if (!ParseIT8(it8, type-1)) {\n\n            fclose(it8 ->FileStack[0]->Stream);\n            cmsIT8Free(hIT8);\n            return NULL;\n    }\n\n    CookPointers(it8);\n    it8 ->nTable = 0;\n\n    if (fclose(it8 ->FileStack[0]->Stream)!= 0) {\n            cmsIT8Free(hIT8);\n            return NULL;\n    }\n\n    return hIT8;\n\n}\n", "target": 0, "idx": 78073}
{"func": "static inline int aead_len(struct xfrm_algo_aead *alg)\n{\n\treturn sizeof(*alg) + ((alg->alg_key_len + 7) / 8);\n}\n", "target": 0, "idx": 33083}
{"func": "static int su3000_i2c_transfer(struct i2c_adapter *adap, struct i2c_msg msg[],\n \t\t\t\t\t\t\t\tint num)\n {\n \tstruct dvb_usb_device *d = i2c_get_adapdata(adap);\n\tu8 obuf[0x40], ibuf[0x40];\n \n \tif (!d)\n \t\treturn -ENODEV;\n \tif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\n \t\treturn -EAGAIN;\n \n \tswitch (num) {\n \tcase 1:\n \t\tswitch (msg[0].addr) {\n \t\tcase SU3000_STREAM_CTRL:\n\t\t\tobuf[0] = msg[0].buf[0] + 0x36;\n\t\t\tobuf[1] = 3;\n\t\t\tobuf[2] = 0;\n\t\t\tif (dvb_usb_generic_rw(d, obuf, 3, ibuf, 0, 0) < 0)\n \t\t\t\terr(\"i2c transfer failed.\");\n \t\t\tbreak;\n \t\tcase DW2102_RC_QUERY:\n\t\t\tobuf[0] = 0x10;\n\t\t\tif (dvb_usb_generic_rw(d, obuf, 1, ibuf, 2, 0) < 0)\n \t\t\t\terr(\"i2c transfer failed.\");\n\t\t\tmsg[0].buf[1] = ibuf[0];\n\t\t\tmsg[0].buf[0] = ibuf[1];\n \t\t\tbreak;\n \t\tdefault:\n \t\t\t/* always i2c write*/\n\t\t\tobuf[0] = 0x08;\n\t\t\tobuf[1] = msg[0].addr;\n\t\t\tobuf[2] = msg[0].len;\n \n\t\t\tmemcpy(&obuf[3], msg[0].buf, msg[0].len);\n \n\t\t\tif (dvb_usb_generic_rw(d, obuf, msg[0].len + 3,\n\t\t\t\t\t\tibuf, 1, 0) < 0)\n \t\t\t\terr(\"i2c transfer failed.\");\n \n \t\t}\n \t\tbreak;\n \tcase 2:\n \t\t/* always i2c read */\n\t\tobuf[0] = 0x09;\n\t\tobuf[1] = msg[0].len;\n\t\tobuf[2] = msg[1].len;\n\t\tobuf[3] = msg[0].addr;\n\t\tmemcpy(&obuf[4], msg[0].buf, msg[0].len);\n\t\tif (dvb_usb_generic_rw(d, obuf, msg[0].len + 4,\n\t\t\t\t\tibuf, msg[1].len + 1, 0) < 0)\n \t\t\terr(\"i2c transfer failed.\");\n \n\t\tmemcpy(msg[1].buf, &ibuf[1], msg[1].len);\n \t\tbreak;\n \tdefault:\n \t\twarn(\"more than 2 i2c messages at a time is not handled yet.\");\n \t\tbreak;\n \t}\n \tmutex_unlock(&d->i2c_mutex);\n \treturn num;\n }\n", "target": 1, "idx": 181398}
{"func": "long AudioTrack::Parse(\n    Segment* pSegment,\n    const Info& info,\n    long long element_start,\n    long long element_size,\n    AudioTrack*& pResult)\n{\n    if (pResult)\n        return -1;\n \n    if (info.type != Track::kAudio)\n        return -1;\n \n    IMkvReader* const pReader = pSegment->m_pReader;\n \n    const Settings& s = info.settings;\n    assert(s.start >= 0);\n    assert(s.size >= 0);\n \n    long long pos = s.start;\n    assert(pos >= 0);\n \n    const long long stop = pos + s.size;\n \n    double rate = 8000.0;  // MKV default\n    long long channels = 1;\n    long long bit_depth = 0;\n \n    while (pos < stop)\n    {\n        long long id, size;\n \n        long status = ParseElementHeader(\n                                pReader,\n                                pos,\n                                stop,\n                                id,\n                                size);\n \n        if (status < 0)  //error\n            return status;\n \n        if (id == 0x35)  //Sample Rate\n        {\n            status = UnserializeFloat(pReader, pos, size, rate);\n \n            if (status < 0)\n                return status;\n \n            if (rate <= 0)\n                return E_FILE_FORMAT_INVALID;\n        }\n        else if (id == 0x1F)  //Channel Count\n        {\n            channels = UnserializeUInt(pReader, pos, size);\n \n            if (channels <= 0)\n                return E_FILE_FORMAT_INVALID;\n        }\n        else if (id == 0x2264)  //Bit Depth\n        {\n            bit_depth = UnserializeUInt(pReader, pos, size);\n \n            if (bit_depth <= 0)\n                return E_FILE_FORMAT_INVALID;\n        }\n \n        pos += size;  //consume payload\n        assert(pos <= stop);\n     }\n \n    assert(pos == stop);\n \n    AudioTrack* const pTrack = new (std::nothrow) AudioTrack(pSegment,\n                                                             element_start,\n                                                             element_size);\n \n    if (pTrack == NULL)\n        return -1;  //generic error\n \n    const int status = info.Copy(pTrack->m_info);\n \n     if (status)\n    {\n        delete pTrack;\n        return status;\n    }\n    pTrack->m_rate = rate;\n    pTrack->m_channels = channels;\n    pTrack->m_bitDepth = bit_depth;\n \n     pResult = pTrack;\n    return 0;  //success\n }\n", "target": 1, "idx": 188429}
{"func": "void FrameSelection::ScheduleVisualUpdate() const {\n  if (Page* page = frame_->GetPage())\n    page->Animator().ScheduleVisualUpdate(&frame_->LocalFrameRoot());\n}\n", "target": 0, "idx": 135664}
{"func": "exsltFreeFuncResultPreComp (exsltFuncResultPreComp *comp) {\n    if (comp == NULL)\n\treturn;\n\n    if (comp->select != NULL)\n\txmlXPathFreeCompExpr (comp->select);\n    if (comp->nsList != NULL)\n        xmlFree(comp->nsList);\n    xmlFree(comp);\n}\n", "target": 0, "idx": 169809}
{"func": " TransportDIB* TransportDIB::Create(size_t size, uint32 sequence_num) {\n  const int shmkey = shmget(IPC_PRIVATE, size, 0666);\n   if (shmkey == -1) {\n     DLOG(ERROR) << \"Failed to create SysV shared memory region\"\n                 << \" errno:\" << errno;\n     return NULL;\n   }\n \n   void* address = shmat(shmkey, NULL /* desired address */, 0 /* flags */);\n  shmctl(shmkey, IPC_RMID, 0);\n  if (address == kInvalidAddress)\n    return NULL;\n\n  TransportDIB* dib = new TransportDIB;\n\n  dib->key_.shmkey = shmkey;\n  dib->address_ = address;\n  dib->size_ = size;\n  return dib;\n}\n", "target": 1, "idx": 185299}
{"func": "PHP_FUNCTION(get_html_translation_table)\n{\n\tlong all = HTML_SPECIALCHARS,\n\t\t flags = ENT_COMPAT;\n\tint doctype;\n\tentity_table_opt entity_table;\n\tconst enc_to_uni *to_uni_table = NULL;\n\tchar *charset_hint = NULL;\n\tint charset_hint_len;\n\tenum entity_charset charset;\n\n\t/* in this function we have to jump through some loops because we're\n\t * getting the translated table from data structures that are optimized for\n\t * random access, not traversal */\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|lls\",\n\t\t\t&all, &flags, &charset_hint, &charset_hint_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tcharset = determine_charset(charset_hint TSRMLS_CC);\n\tdoctype = flags & ENT_HTML_DOC_TYPE_MASK;\n \tLIMIT_ALL(all, doctype, charset);\n \n \tarray_init(return_value);\n \tentity_table = determine_entity_table(all, doctype);\n \tif (all && !CHARSET_UNICODE_COMPAT(charset)) {\n \t\tto_uni_table = enc_to_uni_index[charset];\n\t}\n\n\tif (all) { /* HTML_ENTITIES (actually, any non-zero value for 1st param) */\n\t\tconst entity_stage1_row *ms_table = entity_table.ms_table;\n\n\t\tif (CHARSET_UNICODE_COMPAT(charset)) {\n\t\t\tunsigned i, j, k,\n\t\t\t\t\t max_i, max_j, max_k;\n\t\t\t/* no mapping to unicode required */\n\t\t\tif (CHARSET_SINGLE_BYTE(charset)) { /* ISO-8859-1 */\n\t\t\t\tmax_i = 1; max_j = 4; max_k = 64;\n\t\t\t} else {\n\t\t\t\tmax_i = 0x1E; max_j = 64; max_k = 64;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < max_i; i++) {\n\t\t\t\tif (ms_table[i] == empty_stage2_table)\n\t\t\t\t\tcontinue;\n\t\t\t\tfor (j = 0; j < max_j; j++) {\n\t\t\t\t\tif (ms_table[i][j] == empty_stage3_table)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (k = 0; k < max_k; k++) {\n\t\t\t\t\t\tconst entity_stage3_row *r = &ms_table[i][j][k];\n\t\t\t\t\t\tunsigned code;\n\n\t\t\t\t\t\tif (r->data.ent.entity == NULL)\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tcode = ENT_CODE_POINT_FROM_STAGES(i, j, k);\n\t\t\t\t\t\tif (((code == '\\'' && !(flags & ENT_HTML_QUOTE_SINGLE)) ||\n\t\t\t\t\t\t\t\t(code == '\"' && !(flags & ENT_HTML_QUOTE_DOUBLE))))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\twrite_s3row_data(r, code, charset, return_value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t/* we have to iterate through the set of code points for this\n\t\t\t * encoding and map them to unicode code points */\n\t\t\tunsigned i;\n\t\t\tfor (i = 0; i <= 0xFF; i++) {\n\t\t\t\tconst entity_stage3_row *r;\n\t\t\t\tunsigned uni_cp;\n\n\t\t\t\t/* can be done before mapping, they're invariant */\n\t\t\t\tif (((i == '\\'' && !(flags & ENT_HTML_QUOTE_SINGLE)) ||\n\t\t\t\t\t\t(i == '\"' && !(flags & ENT_HTML_QUOTE_DOUBLE))))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tmap_to_unicode(i, to_uni_table, &uni_cp);\n\t\t\t\tr = &ms_table[ENT_STAGE1_INDEX(uni_cp)][ENT_STAGE2_INDEX(uni_cp)][ENT_STAGE3_INDEX(uni_cp)];\n\t\t\t\tif (r->data.ent.entity == NULL)\n\t\t\t\t\tcontinue;\n\n\t\t\t\twrite_s3row_data(r, i, charset, return_value);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* we could use sizeof(stage3_table_be_apos_00000) as well */\n\t\tunsigned\t  j,\n\t\t\t\t\t  numelems = sizeof(stage3_table_be_noapos_00000) /\n\t\t\t\t\t\t\tsizeof(*stage3_table_be_noapos_00000);\n\n\t\tfor (j = 0; j < numelems; j++) {\n\t\t\tconst entity_stage3_row *r = &entity_table.table[j];\n\t\t\tif (r->data.ent.entity == NULL)\n\t\t\t\tcontinue;\n\n\t\t\tif (((j == '\\'' && !(flags & ENT_HTML_QUOTE_SINGLE)) ||\n\t\t\t\t\t(j == '\"' && !(flags & ENT_HTML_QUOTE_DOUBLE))))\n\t\t\t\tcontinue;\n\n\t\t\t/* charset is indifferent, used cs_8859_1 for efficiency */\n\t\t\twrite_s3row_data(r, j, cs_8859_1, return_value);\n\t\t}\n\t}\n}\n", "target": 1, "idx": 180340}
{"func": "PassRefPtr<HTMLCollection> ContainerNode::children()\n{\n    return ensureRareData()->ensureNodeLists()->addCacheWithAtomicName<HTMLCollection>(this, NodeChildren);\n}\n", "target": 0, "idx": 118756}
{"func": "tracing_saved_cmdlines_size_write(struct file *filp, const char __user *ubuf,\n\t\t\t\t  size_t cnt, loff_t *ppos)\n{\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul_from_user(ubuf, cnt, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\t/* must have at least 1 entry or less than PID_MAX_DEFAULT */\n\tif (!val || val > PID_MAX_DEFAULT)\n\t\treturn -EINVAL;\n\n\tret = tracing_resize_saved_cmdlines((unsigned int)val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*ppos += cnt;\n\n\treturn cnt;\n}\n", "target": 0, "idx": 81510}
{"func": "MediaStreamImpl::~MediaStreamImpl() {\n  DCHECK(!peer_connection_handler_);\n  if (dependency_factory_.get())\n    dependency_factory_->ReleasePeerConnectionFactory();\n  if (network_manager_) {\n    if (chrome_worker_thread_.IsRunning()) {\n       chrome_worker_thread_.message_loop()->PostTask(FROM_HERE, base::Bind(\n           &MediaStreamImpl::DeleteIpcNetworkManager,\n           base::Unretained(this)));\n     } else {\n       NOTREACHED() << \"Worker thread not running.\";\n     }\n  }\n}\n", "target": 1, "idx": 184584}
{"func": "void BrowserRenderProcessHost::OnRevealFolderInOS(const FilePath& path) {\n  if (ChildProcessSecurityPolicy::GetInstance()->CanReadFile(id(), path))\n    content::GetContentClient()->browser()->RevealFolderInOS(path);\n}\n", "target": 0, "idx": 103677}
{"func": "static void dwc3_gadget_disable_irq(struct dwc3 *dwc)\n{\n\t/* mask all interrupts */\n\tdwc3_writel(dwc->regs, DWC3_DEVTEN, 0x00);\n}\n", "target": 0, "idx": 88651}
{"func": "_PUBLIC_ codepoint_t next_codepoint_handle_ext(\n\t\t\tstruct smb_iconv_handle *ic,\n\t\t\tconst char *str, size_t len,\n\t\t\tcharset_t src_charset,\n\t\t\tsize_t *bytes_consumed)\n{\n\t/* it cannot occupy more than 4 bytes in UTF16 format */\n\tuint8_t buf[4];\n\tsmb_iconv_t descriptor;\n\tsize_t ilen_orig;\n\tsize_t ilen;\n        size_t olen;\n        char *outbuf;\n \n       if ((str[0] & 0x80) == 0) {\n                *bytes_consumed = 1;\n                return (codepoint_t)str[0];\n        }\n\t * This is OK as we only support codepoints up to 1M (U+100000)\n\t */\n\tilen_orig = MIN(len, 5);\n\tilen = ilen_orig;\n\n\tdescriptor = get_conv_handle(ic, src_charset, CH_UTF16);\n\tif (descriptor == (smb_iconv_t)-1) {\n\t\t*bytes_consumed = 1;\n\t\treturn INVALID_CODEPOINT;\n\t}\n\n\t/*\n\t * this looks a little strange, but it is needed to cope with\n\t * codepoints above 64k (U+1000) which are encoded as per RFC2781.\n\t */\n\tolen = 2;\n\toutbuf = (char *)buf;\n\tsmb_iconv(descriptor, &str, &ilen, &outbuf, &olen);\n\tif (olen == 2) {\n\t\tolen = 4;\n\t\toutbuf = (char *)buf;\n\t\tsmb_iconv(descriptor,  &str, &ilen, &outbuf, &olen);\n\t\tif (olen == 4) {\n\t\t\t/* we didn't convert any bytes */\n\t\t\t*bytes_consumed = 1;\n\t\t\treturn INVALID_CODEPOINT;\n\t\t}\n\t\tolen = 4 - olen;\n\t} else {\n\t\tolen = 2 - olen;\n\t}\n\n\t*bytes_consumed = ilen_orig - ilen;\n\n\tif (olen == 2) {\n\t\treturn (codepoint_t)SVAL(buf, 0);\n\t}\n\tif (olen == 4) {\n\t\t/* decode a 4 byte UTF16 character manually */\n\t\treturn (codepoint_t)0x10000 +\n\t\t\t(buf[2] | ((buf[3] & 0x3)<<8) |\n\t\t\t (buf[0]<<10) | ((buf[1] & 0x3)<<18));\n\t}\n\n\t/* no other length is valid */\n\treturn INVALID_CODEPOINT;\n}\n", "target": 1, "idx": 177839}
{"func": "bool IsTraceEventArgsWhitelisted(const char* category_group_name,\n                                 const char* event_name) {\n   base::CStringTokenizer category_group_tokens(\n       category_group_name, category_group_name + strlen(category_group_name),\n       \",\");\n   while (category_group_tokens.GetNext()) {\n     const std::string& category_group_token = category_group_tokens.token();\n    for (int i = 0; kEventArgsWhitelist[i][0] != NULL; ++i) {\n      DCHECK(kEventArgsWhitelist[i][1]);\n \n       if (base::MatchPattern(category_group_token.c_str(),\n                             kEventArgsWhitelist[i][0]) &&\n          base::MatchPattern(event_name, kEventArgsWhitelist[i][1])) {\n         return true;\n       }\n     }\n  }\n\n  return false;\n}\n", "target": 1, "idx": 185384}
{"func": "static int __init ip6_tunnel_init(void)\n {\n \tint  err;\n \n\tif (xfrm6_tunnel_register(&ip4ip6_handler, AF_INET)) {\n \t\tprintk(KERN_ERR \"ip6_tunnel init: can't register ip4ip6\\n\");\n\t\terr = -EAGAIN;\n\t\tgoto out;\n \t}\n \n\tif (xfrm6_tunnel_register(&ip6ip6_handler, AF_INET6)) {\n \t\tprintk(KERN_ERR \"ip6_tunnel init: can't register ip6ip6\\n\");\n\t\terr = -EAGAIN;\n\t\tgoto unreg_ip4ip6;\n \t}\n \n\terr = register_pernet_device(&ip6_tnl_net_ops);\n\tif (err < 0)\n\t\tgoto err_pernet;\n \treturn 0;\nerr_pernet:\n\txfrm6_tunnel_deregister(&ip6ip6_handler, AF_INET6);\nunreg_ip4ip6:\n \txfrm6_tunnel_deregister(&ip4ip6_handler, AF_INET);\nout:\n \treturn err;\n }\n", "target": 1, "idx": 179049}
{"func": "void btm_sec_pin_code_request (UINT8 *p_bda)\n{\n\n     tBTM_SEC_DEV_REC *p_dev_rec;\n     tBTM_CB          *p_cb = &btm_cb;\n \n#ifdef PORCHE_PAIRING_CONFLICT\n    UINT8 default_pin_code_len = 4;\n    PIN_CODE default_pin_code = {0x30, 0x30, 0x30, 0x30};\n#endif\n     BTM_TRACE_EVENT (\"btm_sec_pin_code_request()  State: %s, BDA:%04x%08x\",\n                       btm_pair_state_descr(btm_cb.pairing_state),\n                       (p_bda[0]<<8)+p_bda[1], (p_bda[2]<<24)+(p_bda[3]<<16)+(p_bda[4]<<8)+p_bda[5] );\n\n if (btm_cb.pairing_state != BTM_PAIR_STATE_IDLE)\n {\n\n         if ( (memcmp (p_bda, btm_cb.pairing_bda, BD_ADDR_LEN) == 0)  &&\n              (btm_cb.pairing_state == BTM_PAIR_STATE_WAIT_AUTH_COMPLETE) )\n         {\n             /* fake this out - porshe carkit issue - */\n             if(! btm_cb.pin_code_len_saved)\n             {\n                 btsnd_hcic_pin_code_neg_reply (p_bda);\n                 return;\n             }\n             else\n             {\n                 btsnd_hcic_pin_code_req_reply (p_bda, btm_cb.pin_code_len_saved, p_cb->pin_code);\n      \t         return;\n             }\n         }\n         else if ((btm_cb.pairing_state != BTM_PAIR_STATE_WAIT_PIN_REQ)\n                  || memcmp (p_bda, btm_cb.pairing_bda, BD_ADDR_LEN) != 0)\n {\n\n             BTM_TRACE_WARNING (\"btm_sec_pin_code_request() rejected - state: %s\",\n                                 btm_pair_state_descr(btm_cb.pairing_state));\n \n#ifdef PORCHE_PAIRING_CONFLICT\n            /* reply pin code again due to counter in_rand when local initiates pairing */\n            BTM_TRACE_EVENT (\"btm_sec_pin_code_request from remote dev. for local initiated pairing\");\n            if(! btm_cb.pin_code_len_saved)\n            {\n                btm_sec_change_pairing_state (BTM_PAIR_STATE_WAIT_AUTH_COMPLETE);\n                btsnd_hcic_pin_code_req_reply (p_bda, default_pin_code_len, default_pin_code);\n            }\n            else\n            {\n                btm_sec_change_pairing_state (BTM_PAIR_STATE_WAIT_AUTH_COMPLETE);\n                btsnd_hcic_pin_code_req_reply (p_bda, btm_cb.pin_code_len_saved, p_cb->pin_code);\n            }\n#else\n             btsnd_hcic_pin_code_neg_reply (p_bda);\n#endif\n             return;\n         }\n     }\n\n    p_dev_rec = btm_find_or_alloc_dev (p_bda);\n /* received PIN code request. must be non-sm4 */\n    p_dev_rec->sm4 = BTM_SM4_KNOWN;\n\n if (btm_cb.pairing_state == BTM_PAIR_STATE_IDLE)\n {\n        memcpy (btm_cb.pairing_bda, p_bda, BD_ADDR_LEN);\n\n        btm_cb.pairing_flags = BTM_PAIR_FLAGS_PEER_STARTED_DD;\n /* Make sure we reset the trusted mask to help against attacks */\n        BTM_SEC_CLR_TRUSTED_DEVICE(p_dev_rec->trusted_mask);\n }\n\n if (!p_cb->pairing_disabled && (p_cb->cfg.pin_type == HCI_PIN_TYPE_FIXED))\n {\n        BTM_TRACE_EVENT (\"btm_sec_pin_code_request fixed pin replying\");\n        btm_sec_change_pairing_state (BTM_PAIR_STATE_WAIT_AUTH_COMPLETE);\n        btsnd_hcic_pin_code_req_reply (p_bda, p_cb->cfg.pin_code_len, p_cb->cfg.pin_code);\n return;\n }\n\n /* Use the connecting device's CoD for the connection */\n if ( (!memcmp (p_bda, p_cb->connecting_bda, BD_ADDR_LEN))\n && (p_cb->connecting_dc[0] || p_cb->connecting_dc[1] || p_cb->connecting_dc[2]) )\n        memcpy (p_dev_rec->dev_class, p_cb->connecting_dc, DEV_CLASS_LEN);\n\n /* We could have started connection after asking user for the PIN code */\n if (btm_cb.pin_code_len != 0)\n {\n\n         BTM_TRACE_EVENT (\"btm_sec_pin_code_request bonding sending reply\");\n         btsnd_hcic_pin_code_req_reply (p_bda, btm_cb.pin_code_len, p_cb->pin_code);\n \n#ifdef PORCHE_PAIRING_CONFLICT\n        btm_cb.pin_code_len_saved = btm_cb.pin_code_len;\n#endif\n         /* Mark that we forwarded received from the user PIN code */\n         btm_cb.pin_code_len = 0;\n \n /* We can change mode back right away, that other connection being established */\n /* is not forced to be secure - found a FW issue, so we can not do this\n        btm_restore_mode(); */\n\n        btm_sec_change_pairing_state (BTM_PAIR_STATE_WAIT_AUTH_COMPLETE);\n }\n\n /* If pairing disabled OR (no PIN callback and not bonding) */\n /* OR we could not allocate entry in the database reject pairing request */\n else if (p_cb->pairing_disabled\n || (p_cb->api.p_pin_callback == NULL)\n\n /* OR Microsoft keyboard can for some reason try to establish connection */\n /*  the only thing we can do here is to shut it up.  Normally we will be originator */\n /*  for keyboard bonding */\n || (!p_dev_rec->is_originator\n && ((p_dev_rec->dev_class[1] & BTM_COD_MAJOR_CLASS_MASK) == BTM_COD_MAJOR_PERIPHERAL)\n && (p_dev_rec->dev_class[2] & BTM_COD_MINOR_KEYBOARD)) )\n {\n        BTM_TRACE_WARNING(\"btm_sec_pin_code_request(): Pairing disabled:%d; PIN callback:%x, Dev Rec:%x!\",\n                           p_cb->pairing_disabled, p_cb->api.p_pin_callback, p_dev_rec);\n\n        btsnd_hcic_pin_code_neg_reply (p_bda);\n }\n\n     /* Notify upper layer of PIN request and start expiration timer */\n     else\n     {\n        btm_cb.pin_code_len_saved = 0;\n         btm_sec_change_pairing_state (BTM_PAIR_STATE_WAIT_LOCAL_PIN);\n         /* Pin code request can not come at the same time as connection request */\n         memcpy (p_cb->connecting_bda, p_bda, BD_ADDR_LEN);\n        memcpy (p_cb->connecting_dc,  p_dev_rec->dev_class, DEV_CLASS_LEN);\n\n /* Check if the name is known */\n /* Even if name is not known we might not be able to get one */\n /* this is the case when we are already getting something from the */\n /* device, so HCI level is flow controlled */\n /* Also cannot send remote name request while paging, i.e. connection is not completed */\n if (p_dev_rec->sec_flags & BTM_SEC_NAME_KNOWN)\n {\n            BTM_TRACE_EVENT (\"btm_sec_pin_code_request going for callback\");\n\n            btm_cb.pairing_flags |= BTM_PAIR_FLAGS_PIN_REQD;\n if (p_cb->api.p_pin_callback)\n (*p_cb->api.p_pin_callback) (p_bda, p_dev_rec->dev_class, p_dev_rec->sec_bd_name);\n }\n else\n {\n            BTM_TRACE_EVENT (\"btm_sec_pin_code_request going for remote name\");\n\n /* We received PIN code request for the device with unknown name */\n /* it is not user friendly just to ask for the PIN without name */\n /* try to get name at first */\n if (!btsnd_hcic_rmt_name_req (p_dev_rec->bd_addr,\n                                          HCI_PAGE_SCAN_REP_MODE_R1,\n                                          HCI_MANDATARY_PAGE_SCAN_MODE, 0))\n {\n                p_dev_rec->sec_flags |= BTM_SEC_NAME_KNOWN;\n                p_dev_rec->sec_bd_name[0] = 'f';\n                p_dev_rec->sec_bd_name[1] = '0';\n                BTM_TRACE_ERROR (\"can not send rmt_name_req?? fake a name and call callback\");\n\n                btm_cb.pairing_flags |= BTM_PAIR_FLAGS_PIN_REQD;\n if (p_cb->api.p_pin_callback)\n (*p_cb->api.p_pin_callback) (p_bda, p_dev_rec->dev_class, p_dev_rec->sec_bd_name);\n }\n }\n }\n\n return;\n}\n", "target": 1, "idx": 187924}
{"func": "void WebContentsImpl::DragSourceEndedAt(int client_x,\n                                        int client_y,\n                                        int screen_x,\n                                        int screen_y,\n                                        blink::WebDragOperation operation,\n                                        RenderWidgetHost* source_rwh) {\n  if (browser_plugin_embedder_.get())\n    browser_plugin_embedder_->DragSourceEndedAt(\n        client_x, client_y, screen_x, screen_y, operation);\n  if (source_rwh) {\n    source_rwh->DragSourceEndedAt(gfx::Point(client_x, client_y),\n                                  gfx::Point(screen_x, screen_y),\n                                  operation);\n  }\n}\n", "target": 0, "idx": 148364}
{"func": "WebKit::WebGeolocationClient* RenderViewImpl::geolocationClient() {\n  if (!geolocation_dispatcher_)\n    geolocation_dispatcher_ = new GeolocationDispatcher(this);\n  return geolocation_dispatcher_;\n}\n", "target": 0, "idx": 109129}
{"func": "  InputMethodDescriptors* GetInputMethodDescriptorsForTesting() {\n    InputMethodDescriptors* descriptions = new InputMethodDescriptors;\n    descriptions->push_back(InputMethodDescriptor(\n         \"xkb:nl::nld\", \"Netherlands\", \"nl\", \"nl\", \"nld\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"xkb:be::nld\", \"Belgium\", \"be\", \"be\", \"nld\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"xkb:fr::fra\", \"France\", \"fr\", \"fr\", \"fra\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"xkb:be::fra\", \"Belgium\", \"be\", \"be\", \"fra\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"xkb:ca::fra\", \"Canada\", \"ca\", \"ca\", \"fra\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"xkb:ch:fr:fra\", \"Switzerland - French\", \"ch(fr)\", \"ch(fr)\", \"fra\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"xkb:de::ger\", \"Germany\", \"de\", \"de\", \"ger\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"xkb:de:neo:ger\", \"Germany - Neo 2\", \"de(neo)\", \"de(neo)\", \"ger\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"xkb:be::ger\", \"Belgium\", \"be\", \"be\", \"ger\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"xkb:ch::ger\", \"Switzerland\", \"ch\", \"ch\", \"ger\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"mozc\", \"Mozc (US keyboard layout)\", \"us\", \"us\", \"ja\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"mozc-jp\", \"Mozc (Japanese keyboard layout)\", \"jp\", \"jp\", \"ja\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"mozc-dv\",\n         \"Mozc (US Dvorak keyboard layout)\", \"us(dvorak)\", \"us(dvorak)\", \"ja\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"xkb:jp::jpn\", \"Japan\", \"jp\", \"jp\", \"jpn\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"xkb:ru::rus\", \"Russia\", \"ru\", \"ru\", \"rus\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"xkb:ru:phonetic:rus\",\n         \"Russia - Phonetic\", \"ru(phonetic)\", \"ru(phonetic)\", \"rus\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"m17n:th:kesmanee\", \"kesmanee (m17n)\", \"us\", \"us\", \"th\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"m17n:th:pattachote\", \"pattachote (m17n)\", \"us\", \"us\", \"th\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"m17n:th:tis820\", \"tis820 (m17n)\", \"us\", \"us\", \"th\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"mozc-chewing\", \"Mozc Chewing (Chewing)\", \"us\", \"us\", \"zh_TW\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"m17n:zh:cangjie\", \"cangjie (m17n)\", \"us\", \"us\", \"zh\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"m17n:zh:quick\", \"quick (m17n)\", \"us\", \"us\", \"zh\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"m17n:vi:tcvn\", \"tcvn (m17n)\", \"us\", \"us\", \"vi\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"m17n:vi:telex\", \"telex (m17n)\", \"us\", \"us\", \"vi\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"m17n:vi:viqr\", \"viqr (m17n)\", \"us\", \"us\", \"vi\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"m17n:vi:vni\", \"vni (m17n)\", \"us\", \"us\", \"vi\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"xkb:us::eng\", \"USA\", \"us\", \"us\", \"eng\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"xkb:us:intl:eng\",\n         \"USA - International (with dead keys)\", \"us(intl)\", \"us(intl)\", \"eng\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"xkb:us:altgr-intl:eng\", \"USA - International (AltGr dead keys)\",\n         \"us(altgr-intl)\", \"us(altgr-intl)\", \"eng\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"xkb:us:dvorak:eng\",\n         \"USA - Dvorak\", \"us(dvorak)\", \"us(dvorak)\", \"eng\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"xkb:us:colemak:eng\",\n         \"USA - Colemak\", \"us(colemak)\", \"us(colemak)\", \"eng\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"hangul\", \"Korean\", \"kr(kr104)\", \"kr(kr104)\", \"ko\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"pinyin\", \"Pinyin\", \"us\", \"us\", \"zh\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"pinyin-dv\", \"Pinyin (for US Dvorak keyboard)\",\n         \"us(dvorak)\", \"us(dvorak)\", \"zh\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"m17n:ar:kbd\", \"kbd (m17n)\", \"us\", \"us\", \"ar\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"m17n:hi:itrans\", \"itrans (m17n)\", \"us\", \"us\", \"hi\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"m17n:fa:isiri\", \"isiri (m17n)\", \"us\", \"us\", \"fa\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"xkb:br::por\", \"Brazil\", \"br\", \"br\", \"por\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"xkb:bg::bul\", \"Bulgaria\", \"bg\", \"bg\", \"bul\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"xkb:bg:phonetic:bul\", \"Bulgaria - Traditional phonetic\",\n         \"bg(phonetic)\", \"bg(phonetic)\", \"bul\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"xkb:ca:eng:eng\", \"Canada - English\", \"ca(eng)\", \"ca(eng)\", \"eng\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"xkb:cz::cze\", \"Czechia\", \"cz\", \"cz\", \"cze\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"xkb:ee::est\", \"Estonia\", \"ee\", \"ee\", \"est\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"xkb:es::spa\", \"Spain\", \"es\", \"es\", \"spa\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"xkb:es:cat:cat\", \"Spain - Catalan variant with middle-dot L\",\n         \"es(cat)\", \"es(cat)\", \"cat\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"xkb:dk::dan\", \"Denmark\", \"dk\", \"dk\", \"dan\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"xkb:gr::gre\", \"Greece\", \"gr\", \"gr\", \"gre\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"xkb:il::heb\", \"Israel\", \"il\", \"il\", \"heb\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"xkb:kr:kr104:kor\", \"Korea, Republic of - 101/104 key Compatible\",\n         \"kr(kr104)\", \"kr(kr104)\", \"kor\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"xkb:latam::spa\", \"Latin American\", \"latam\", \"latam\", \"spa\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"xkb:lt::lit\", \"Lithuania\", \"lt\", \"lt\", \"lit\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"xkb:lv:apostrophe:lav\", \"Latvia - Apostrophe (') variant\",\n         \"lv(apostrophe)\", \"lv(apostrophe)\", \"lav\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"xkb:hr::scr\", \"Croatia\", \"hr\", \"hr\", \"scr\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"xkb:gb:extd:eng\", \"United Kingdom - Extended - Winkeys\",\n         \"gb(extd)\", \"gb(extd)\", \"eng\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"xkb:gb:dvorak:eng\", \"United Kingdom - Dvorak\",\n         \"gb(dvorak)\", \"gb(dvorak)\", \"eng\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"xkb:fi::fin\", \"Finland\", \"fi\", \"fi\", \"fin\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"xkb:hu::hun\", \"Hungary\", \"hu\", \"hu\", \"hun\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"xkb:it::ita\", \"Italy\", \"it\", \"it\", \"ita\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"xkb:no::nob\", \"Norway\", \"no\", \"no\", \"nob\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"xkb:pl::pol\", \"Poland\", \"pl\", \"pl\", \"pol\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"xkb:pt::por\", \"Portugal\", \"pt\", \"pt\", \"por\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"xkb:ro::rum\", \"Romania\", \"ro\", \"ro\", \"rum\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"xkb:se::swe\", \"Sweden\", \"se\", \"se\", \"swe\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"xkb:sk::slo\", \"Slovakia\", \"sk\", \"sk\", \"slo\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"xkb:si::slv\", \"Slovenia\", \"si\", \"si\", \"slv\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"xkb:rs::srp\", \"Serbia\", \"rs\", \"rs\", \"srp\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"xkb:tr::tur\", \"Turkey\", \"tr\", \"tr\", \"tur\"));\n    descriptions->push_back(InputMethodDescriptor(\n         \"xkb:ua::ukr\", \"Ukraine\", \"ua\", \"ua\", \"ukr\"));\n     return descriptions;\n   }\n", "target": 1, "idx": 183945}
{"func": "static int jpc_qcx_putcompparms(jpc_qcxcp_t *compparms, jpc_cstate_t *cstate,\n  jas_stream_t *out)\n{\n\tint i;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tjpc_putuint8(out, ((compparms->numguard & 7) << 5) | compparms->qntsty);\n\tfor (i = 0; i < compparms->numstepsizes; ++i) {\n\t\tif (compparms->qntsty == JPC_QCX_NOQNT) {\n\t\t\tif (jpc_putuint8(out, JPC_QCX_GETEXPN(\n\t\t\t  compparms->stepsizes[i]) << 3)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\tif (jpc_putuint16(out, compparms->stepsizes[i])) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n", "target": 0, "idx": 72884}
{"func": "static void free_VarFileInfo(VarFileInfo* varFileInfo) {\n\tif (varFileInfo) {\n\t\tfree (varFileInfo->szKey);\n\t\tif (varFileInfo->Children) {\n\t\t\tut32 children = 0;\n\t\t\tfor (; children < varFileInfo->numOfChildren; children++) {\n\t\t\t\tfree_Var (varFileInfo->Children[children]);\n\t\t\t}\n\t\t\tfree (varFileInfo->Children);\n\t\t}\n\t\tfree (varFileInfo);\n\t}\n}\n", "target": 0, "idx": 82904}
{"func": "const char *get_link(struct nameidata *nd)\n{\n\tstruct saved *last = nd->stack + nd->depth - 1;\n\tstruct dentry *dentry = last->link.dentry;\n\tstruct inode *inode = last->inode;\n\tint error;\n\tconst char *res;\n\n\tif (!(nd->flags & LOOKUP_RCU)) {\n\t\ttouch_atime(&last->link);\n\t\tcond_resched();\n\t} else if (atime_needs_update(&last->link, inode)) {\n\t\tif (unlikely(unlazy_walk(nd, NULL, 0)))\n\t\t\treturn ERR_PTR(-ECHILD);\n\t\ttouch_atime(&last->link);\n\t}\n\n\terror = security_inode_follow_link(dentry, inode,\n\t\t\t\t\t   nd->flags & LOOKUP_RCU);\n\tif (unlikely(error))\n\t\treturn ERR_PTR(error);\n\n\tnd->last_type = LAST_BIND;\n\tres = inode->i_link;\n\tif (!res) {\n\t\tif (nd->flags & LOOKUP_RCU) {\n\t\t\tif (unlikely(unlazy_walk(nd, NULL, 0)))\n\t\t\t\treturn ERR_PTR(-ECHILD);\n\t\t}\n\t\tres = inode->i_op->follow_link(dentry, &last->cookie);\n\t\tif (IS_ERR_OR_NULL(res)) {\n\t\t\tlast->cookie = NULL;\n\t\t\treturn res;\n\t\t}\n\t}\n\tif (*res == '/') {\n\t\tif (nd->flags & LOOKUP_RCU) {\n\t\t\tstruct dentry *d;\n\t\t\tif (!nd->root.mnt)\n\t\t\t\tset_root_rcu(nd);\n\t\t\tnd->path = nd->root;\n\t\t\td = nd->path.dentry;\n\t\t\tnd->inode = d->d_inode;\n\t\t\tnd->seq = nd->root_seq;\n\t\t\tif (unlikely(read_seqcount_retry(&d->d_seq, nd->seq)))\n\t\t\t\treturn ERR_PTR(-ECHILD);\n\t\t} else {\n\t\t\tif (!nd->root.mnt)\n\t\t\t\tset_root(nd);\n\t\t\tpath_put(&nd->path);\n\t\t\tnd->path = nd->root;\n\t\t\tpath_get(&nd->root);\n\t\t\tnd->inode = nd->path.dentry->d_inode;\n\t\t}\n\t\tnd->flags |= LOOKUP_JUMPED;\n\t\twhile (unlikely(*++res == '/'))\n\t\t\t;\n\t}\n\tif (!*res)\n\t\tres = NULL;\n\treturn res;\n}\n", "target": 0, "idx": 43657}
{"func": "void pci_init_board(void)\n{\n\tqrio_prstcfg(PCIE_SW_RST, PRSTCFG_POWUP_UNIT_CORE_RST);\n\tqrio_prstcfg(PEXHC_RST, PRSTCFG_POWUP_UNIT_CORE_RST);\n\tqrio_prstcfg(HOOPER_RST, PRSTCFG_POWUP_UNIT_CORE_RST);\n\n\t/* wait for the PCIe FPGA to be configured\n\t * it has been triggered earlier in board_early_init_r */\n\tif (wait_for_fpga_config())\n\t\tprintf(\"error finishing PCIe FPGA config\\n\");\n\n\tqrio_prst(PCIE_SW_RST, false, false);\n\tqrio_prst(PEXHC_RST, false, false);\n\tqrio_prst(HOOPER_RST, false, false);\n\t/* Hooper is not direcly PCIe capable */\n\tmdelay(50);\n\n\tfsl_pcie_init_board(0);\n}\n", "target": 0, "idx": 89327}
{"func": "WORD32 ihevcd_set_degrade(iv_obj_t *ps_codec_obj,\n void *pv_api_ip,\n void *pv_api_op)\n{\n ihevcd_cxa_ctl_degrade_ip_t *ps_ip;\n ihevcd_cxa_ctl_degrade_op_t *ps_op;\n codec_t *ps_codec = (codec_t *)ps_codec_obj->pv_codec_handle;\n\n    ps_ip = (ihevcd_cxa_ctl_degrade_ip_t *)pv_api_ip;\n    ps_op = (ihevcd_cxa_ctl_degrade_op_t *)pv_api_op;\n\n    ps_codec->i4_degrade_type = ps_ip->i4_degrade_type;\n    ps_codec->i4_nondegrade_interval = ps_ip->i4_nondegrade_interval;\n    ps_codec->i4_degrade_pics = ps_ip->i4_degrade_pics;\n\n    ps_op->u4_error_code = 0;\n    ps_codec->i4_degrade_pic_cnt = 0;\n\n return IV_SUCCESS;\n}\n", "target": 0, "idx": 176488}
{"func": "static int inet_rtm_getroute(struct sk_buff *in_skb, struct nlmsghdr *nlh,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct rtmsg *rtm;\n\tstruct nlattr *tb[RTA_MAX+1];\n\tstruct fib_result res = {};\n\tstruct rtable *rt = NULL;\n\tstruct flowi4 fl4;\n\t__be32 dst = 0;\n\t__be32 src = 0;\n\tu32 iif;\n\tint err;\n\tint mark;\n\tstruct sk_buff *skb;\n\tu32 table_id = RT_TABLE_MAIN;\n\tkuid_t uid;\n\n\terr = nlmsg_parse(nlh, sizeof(*rtm), tb, RTA_MAX, rtm_ipv4_policy,\n\t\t\t  extack);\n\tif (err < 0)\n\t\tgoto errout;\n\n\trtm = nlmsg_data(nlh);\n\n\tskb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!skb) {\n\t\terr = -ENOBUFS;\n\t\tgoto errout;\n\t}\n\n\t/* Reserve room for dummy headers, this skb can pass\n\t   through good chunk of routing engine.\n\t */\n\tskb_reset_mac_header(skb);\n\tskb_reset_network_header(skb);\n\n\tsrc = tb[RTA_SRC] ? nla_get_in_addr(tb[RTA_SRC]) : 0;\n\tdst = tb[RTA_DST] ? nla_get_in_addr(tb[RTA_DST]) : 0;\n\tiif = tb[RTA_IIF] ? nla_get_u32(tb[RTA_IIF]) : 0;\n\tmark = tb[RTA_MARK] ? nla_get_u32(tb[RTA_MARK]) : 0;\n\tif (tb[RTA_UID])\n\t\tuid = make_kuid(current_user_ns(), nla_get_u32(tb[RTA_UID]));\n\telse\n\t\tuid = (iif ? INVALID_UID : current_uid());\n\n\t/* Bugfix: need to give ip_route_input enough of an IP header to\n\t * not gag.\n\t */\n\tip_hdr(skb)->protocol = IPPROTO_UDP;\n\tip_hdr(skb)->saddr = src;\n\tip_hdr(skb)->daddr = dst;\n\n\tskb_reserve(skb, MAX_HEADER + sizeof(struct iphdr));\n\n\tmemset(&fl4, 0, sizeof(fl4));\n\tfl4.daddr = dst;\n\tfl4.saddr = src;\n\tfl4.flowi4_tos = rtm->rtm_tos;\n\tfl4.flowi4_oif = tb[RTA_OIF] ? nla_get_u32(tb[RTA_OIF]) : 0;\n\tfl4.flowi4_mark = mark;\n\tfl4.flowi4_uid = uid;\n\n\trcu_read_lock();\n\n\tif (iif) {\n\t\tstruct net_device *dev;\n\n\t\tdev = dev_get_by_index_rcu(net, iif);\n\t\tif (!dev) {\n\t\t\terr = -ENODEV;\n\t\t\tgoto errout_free;\n\t\t}\n\n\t\tskb->protocol\t= htons(ETH_P_IP);\n\t\tskb->dev\t= dev;\n\t\tskb->mark\t= mark;\n\t\terr = ip_route_input_rcu(skb, dst, src, rtm->rtm_tos,\n\t\t\t\t\t dev, &res);\n\n\t\trt = skb_rtable(skb);\n\t\tif (err == 0 && rt->dst.error)\n\t\t\terr = -rt->dst.error;\n\t} else {\n\t\trt = ip_route_output_key_hash_rcu(net, &fl4, &res, skb);\n\t\terr = 0;\n\t\tif (IS_ERR(rt))\n\t\t\terr = PTR_ERR(rt);\n\t\telse\n\t\t\tskb_dst_set(skb, &rt->dst);\n\t}\n\n\tif (err)\n\t\tgoto errout_free;\n\n\tif (rtm->rtm_flags & RTM_F_NOTIFY)\n\t\trt->rt_flags |= RTCF_NOTIFY;\n\n \tif (rtm->rtm_flags & RTM_F_LOOKUP_TABLE)\n \t\ttable_id = rt->rt_table_id;\n \n\tif (rtm->rtm_flags & RTM_F_FIB_MATCH)\n \t\terr = fib_dump_info(skb, NETLINK_CB(in_skb).portid,\n \t\t\t\t    nlh->nlmsg_seq, RTM_NEWROUTE, table_id,\n \t\t\t\t    rt->rt_type, res.prefix, res.prefixlen,\n \t\t\t\t    fl4.flowi4_tos, res.fi, 0);\n\telse\n \t\terr = rt_fill_info(net, dst, src, table_id, &fl4, skb,\n \t\t\t\t   NETLINK_CB(in_skb).portid, nlh->nlmsg_seq);\n \tif (err < 0)\n \t\tgoto errout_free;\n \n\trcu_read_unlock();\n\n\terr = rtnl_unicast(skb, net, NETLINK_CB(in_skb).portid);\nerrout:\n\treturn err;\n\nerrout_free:\n\trcu_read_unlock();\n\tkfree_skb(skb);\n\tgoto errout;\n}\n", "target": 1, "idx": 180978}
{"func": "void netif_nit_deliver(struct sk_buff *skb)\n{\n\tstruct packet_type *ptype;\n\n\tif (list_empty(&ptype_all))\n\t\treturn;\n\n\tskb_reset_network_header(skb);\n\tskb_reset_transport_header(skb);\n\tskb->mac_len = skb->network_header - skb->mac_header;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(ptype, &ptype_all, list) {\n\t\tif (!ptype->dev || ptype->dev == skb->dev)\n\t\t\tdeliver_skb(skb, ptype, skb->dev);\n\t}\n\trcu_read_unlock();\n}\n", "target": 0, "idx": 32209}
{"func": "bool FrameLoader::shouldClose(bool isReload)\n{\n    Page* page = m_frame->page();\n    if (!page || !page->chromeClient().canOpenBeforeUnloadConfirmPanel())\n        return true;\n\n    HeapVector<Member<LocalFrame>> targetFrames;\n    targetFrames.append(m_frame);\n    for (Frame* child = m_frame->tree().firstChild(); child; child = child->tree().traverseNext(m_frame)) {\n        if (child->isLocalFrame())\n            targetFrames.append(toLocalFrame(child));\n    }\n\n    bool shouldClose = false;\n    {\n        NavigationDisablerForBeforeUnload navigationDisabler;\n        size_t i;\n\n        bool didAllowNavigation = false;\n        for (i = 0; i < targetFrames.size(); i++) {\n            if (!targetFrames[i]->tree().isDescendantOf(m_frame))\n                continue;\n            if (!targetFrames[i]->document()->dispatchBeforeUnloadEvent(page->chromeClient(), isReload, didAllowNavigation))\n                break;\n        }\n\n        if (i == targetFrames.size())\n            shouldClose = true;\n    }\n\n    return shouldClose;\n}\n", "target": 0, "idx": 142712}
{"func": "static void migrate_page_add(struct page *page, struct list_head *pagelist,\n\t\t\t\tunsigned long flags)\n{\n}\n", "target": 0, "idx": 21319}
{"func": "void LogoService::SetLogoCacheForTests(std::unique_ptr<LogoCache> cache) {\n  logo_cache_for_test_ = std::move(cache);\n}\n", "target": 1, "idx": 185838}
{"func": " bool PlatformSensor::GetLatestReading(SensorReading* result) {\n   if (!shared_buffer_reader_) {\n    const auto* buffer = static_cast<const device::SensorReadingSharedBuffer*>(\n        shared_buffer_mapping_.get());\n     shared_buffer_reader_ =\n        std::make_unique<SensorReadingSharedBufferReader>(buffer);\n   }\n \n   return shared_buffer_reader_->GetReading(result);\n}\n", "target": 1, "idx": 186798}
{"func": "ossl_cipher_init(int argc, VALUE *argv, VALUE self, int mode)\n{\n    EVP_CIPHER_CTX *ctx;\n    unsigned char key[EVP_MAX_KEY_LENGTH], *p_key = NULL;\n    unsigned char iv[EVP_MAX_IV_LENGTH], *p_iv = NULL;\n    VALUE pass, init_v;\n\n    if(rb_scan_args(argc, argv, \"02\", &pass, &init_v) > 0){\n\t/*\n\t * oops. this code mistakes salt for IV.\n\t * We deprecated the arguments for this method, but we decided\n\t * keeping this behaviour for backward compatibility.\n\t */\n\tVALUE cname  = rb_class_path(rb_obj_class(self));\n\trb_warn(\"arguments for %\"PRIsVALUE\"#encrypt and %\"PRIsVALUE\"#decrypt were deprecated; \"\n                \"use %\"PRIsVALUE\"#pkcs5_keyivgen to derive key and IV\",\n                cname, cname, cname);\n\tStringValue(pass);\n\tGetCipher(self, ctx);\n\tif (NIL_P(init_v)) memcpy(iv, \"OpenSSL for Ruby rulez!\", sizeof(iv));\n\telse{\n\t    StringValue(init_v);\n\t    if (EVP_MAX_IV_LENGTH > RSTRING_LEN(init_v)) {\n\t\tmemset(iv, 0, EVP_MAX_IV_LENGTH);\n\t\tmemcpy(iv, RSTRING_PTR(init_v), RSTRING_LEN(init_v));\n\t    }\n\t    else memcpy(iv, RSTRING_PTR(init_v), sizeof(iv));\n\t}\n\tEVP_BytesToKey(EVP_CIPHER_CTX_cipher(ctx), EVP_md5(), iv,\n\t\t       (unsigned char *)RSTRING_PTR(pass), RSTRING_LENINT(pass), 1, key, NULL);\n\tp_key = key;\n\tp_iv = iv;\n    }\n    else {\n\tGetCipher(self, ctx);\n    }\n    if (EVP_CipherInit_ex(ctx, NULL, NULL, p_key, p_iv, mode) != 1) {\n \tossl_raise(eCipherError, NULL);\n     }\n \n     return self;\n }\n", "target": 1, "idx": 181951}
{"func": "static int ax25_info_show(struct seq_file *seq, void *v)\n{\n\tax25_cb *ax25 = hlist_entry(v, struct ax25_cb, ax25_node);\n\tchar buf[11];\n\tint k;\n\n\n\t/*\n\t * New format:\n\t * magic dev src_addr dest_addr,digi1,digi2,.. st vs vr va t1 t1 t2 t2 t3 t3 idle idle n2 n2 rtt window paclen Snd-Q Rcv-Q inode\n\t */\n\n\tseq_printf(seq, \"%8.8lx %s %s%s \",\n\t\t   (long) ax25,\n\t\t   ax25->ax25_dev == NULL? \"???\" : ax25->ax25_dev->dev->name,\n\t\t   ax2asc(buf, &ax25->source_addr),\n\t\t   ax25->iamdigi? \"*\":\"\");\n\tseq_printf(seq, \"%s\", ax2asc(buf, &ax25->dest_addr));\n\n\tfor (k=0; (ax25->digipeat != NULL) && (k < ax25->digipeat->ndigi); k++) {\n\t\tseq_printf(seq, \",%s%s\",\n\t\t\t   ax2asc(buf, &ax25->digipeat->calls[k]),\n\t\t\t   ax25->digipeat->repeated[k]? \"*\":\"\");\n\t}\n\n\tseq_printf(seq, \" %d %d %d %d %lu %lu %lu %lu %lu %lu %lu %lu %d %d %lu %d %d\",\n\t\t   ax25->state,\n\t\t   ax25->vs, ax25->vr, ax25->va,\n\t\t   ax25_display_timer(&ax25->t1timer) / HZ, ax25->t1 / HZ,\n\t\t   ax25_display_timer(&ax25->t2timer) / HZ, ax25->t2 / HZ,\n\t\t   ax25_display_timer(&ax25->t3timer) / HZ, ax25->t3 / HZ,\n\t\t   ax25_display_timer(&ax25->idletimer) / (60 * HZ),\n\t\t   ax25->idle / (60 * HZ),\n\t\t   ax25->n2count, ax25->n2,\n\t\t   ax25->rtt / HZ,\n\t\t   ax25->window,\n\t\t   ax25->paclen);\n\n\tif (ax25->sk != NULL) {\n\t\tseq_printf(seq, \" %d %d %lu\\n\",\n\t\t\t   sk_wmem_alloc_get(ax25->sk),\n\t\t\t   sk_rmem_alloc_get(ax25->sk),\n\t\t\t   sock_i_ino(ax25->sk));\n\t} else {\n\t\tseq_puts(seq, \" * * *\\n\");\n\t}\n\treturn 0;\n}\n", "target": 0, "idx": 30794}
{"func": "static int sd_try_extended_inquiry(struct scsi_device *sdp)\n{\n\t/*\n\t * Although VPD inquiries can go to SCSI-2 type devices,\n\t * some USB ones crash on receiving them, and the pages\n\t * we currently ask for are for SPC-3 and beyond\n\t */\n\tif (sdp->scsi_level > SCSI_SPC_2)\n\t\treturn 1;\n\treturn 0;\n}\n", "target": 0, "idx": 94429}
{"func": " void ReportPreconnectAccuracy(\n     const PreconnectStats& stats,\n    const std::map<GURL, OriginRequestSummary>& requests) {\n   if (stats.requests_stats.empty())\n     return;\n \n  int preresolve_hits_count = 0;\n  int preresolve_misses_count = 0;\n  int preconnect_hits_count = 0;\n  int preconnect_misses_count = 0;\n\n  for (const auto& request_stats : stats.requests_stats) {\n    bool hit = requests.find(request_stats.origin) != requests.end();\n    bool preconnect = request_stats.was_preconnected;\n\n    preresolve_hits_count += hit;\n    preresolve_misses_count += !hit;\n    preconnect_hits_count += preconnect && hit;\n    preconnect_misses_count += preconnect && !hit;\n  }\n\n  int total_preresolves = preresolve_hits_count + preresolve_misses_count;\n  int total_preconnects = preconnect_hits_count + preconnect_misses_count;\n  DCHECK_EQ(static_cast<int>(stats.requests_stats.size()),\n            preresolve_hits_count + preresolve_misses_count);\n  DCHECK_GT(total_preresolves, 0);\n\n  size_t preresolve_hits_percentage =\n      (100 * preresolve_hits_count) / total_preresolves;\n\n  if (total_preconnects > 0) {\n    size_t preconnect_hits_percentage =\n        (100 * preconnect_hits_count) / total_preconnects;\n    UMA_HISTOGRAM_PERCENTAGE(\n        internal::kLoadingPredictorPreconnectHitsPercentage,\n        preconnect_hits_percentage);\n  }\n\n  UMA_HISTOGRAM_PERCENTAGE(internal::kLoadingPredictorPreresolveHitsPercentage,\n                           preresolve_hits_percentage);\n  UMA_HISTOGRAM_COUNTS_100(internal::kLoadingPredictorPreresolveCount,\n                           total_preresolves);\n  UMA_HISTOGRAM_COUNTS_100(internal::kLoadingPredictorPreconnectCount,\n                           total_preconnects);\n}\n", "target": 1, "idx": 186340}
{"func": "static size_t PSDPackbitsEncodeImage(Image *image,const size_t length,\n  const unsigned char *pixels,unsigned char *compact_pixels)\n{\n  int\n    count;\n\n  register ssize_t\n    i,\n    j;\n\n  register unsigned char\n    *q;\n\n  unsigned char\n    *packbits;\n\n  /*\n    Compress pixels with Packbits encoding.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(pixels != (unsigned char *) NULL);\n  assert(compact_pixels != (unsigned char *) NULL);\n  packbits=(unsigned char *) AcquireQuantumMemory(128UL,sizeof(*packbits));\n  if (packbits == (unsigned char *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  q=compact_pixels;\n  for (i=(ssize_t) length; i != 0; )\n  {\n    switch (i)\n    {\n      case 1:\n      {\n        i--;\n        *q++=(unsigned char) 0;\n        *q++=(*pixels);\n        break;\n      }\n      case 2:\n      {\n        i-=2;\n        *q++=(unsigned char) 1;\n        *q++=(*pixels);\n        *q++=pixels[1];\n        break;\n      }\n      case 3:\n      {\n        i-=3;\n        if ((*pixels == *(pixels+1)) && (*(pixels+1) == *(pixels+2)))\n          {\n            *q++=(unsigned char) ((256-3)+1);\n            *q++=(*pixels);\n            break;\n          }\n        *q++=(unsigned char) 2;\n        *q++=(*pixels);\n        *q++=pixels[1];\n        *q++=pixels[2];\n        break;\n      }\n      default:\n      {\n        if ((*pixels == *(pixels+1)) && (*(pixels+1) == *(pixels+2)))\n          {\n            /*\n              Packed run.\n            */\n            count=3;\n            while (((ssize_t) count < i) && (*pixels == *(pixels+count)))\n            {\n              count++;\n              if (count >= 127)\n                break;\n            }\n            i-=count;\n            *q++=(unsigned char) ((256-count)+1);\n            *q++=(*pixels);\n            pixels+=count;\n            break;\n          }\n        /*\n          Literal run.\n        */\n        count=0;\n        while ((*(pixels+count) != *(pixels+count+1)) ||\n               (*(pixels+count+1) != *(pixels+count+2)))\n        {\n          packbits[count+1]=pixels[count];\n          count++;\n          if (((ssize_t) count >= (i-3)) || (count >= 127))\n            break;\n        }\n        i-=count;\n        *packbits=(unsigned char) (count-1);\n        for (j=0; j <= (ssize_t) count; j++)\n          *q++=packbits[j];\n        pixels+=count;\n        break;\n      }\n    }\n  }\n  *q++=(unsigned char) 128;  /* EOD marker */\n  packbits=(unsigned char *) RelinquishMagickMemory(packbits);\n  return((size_t) (q-compact_pixels));\n}\n", "target": 0, "idx": 61510}
{"func": "  _bdf_atos( char*   s,\n             char**  end,\n             int     base )\n  {\n    short                 v, neg;\n    const unsigned char*  dmap;\n\n\n    if ( s == 0 || *s == 0 )\n      return 0;\n\n    /* Make sure the radix is something recognizable.  Default to 10. */\n    switch ( base )\n    {\n    case 8:\n      dmap = odigits;\n      break;\n    case 16:\n      dmap = hdigits;\n      break;\n    default:\n      base = 10;\n      dmap = ddigits;\n      break;\n    }\n\n    /* Check for a minus. */\n    neg = 0;\n    if ( *s == '-' )\n    {\n      s++;\n      neg = 1;\n    }\n\n    /* Check for the special hex prefix. */\n    if ( *s == '0'                                  &&\n         ( *( s + 1 ) == 'x' || *( s + 1 ) == 'X' ) )\n    {\n      base = 16;\n      dmap = hdigits;\n      s   += 2;\n    }\n\n    for ( v = 0; sbitset( dmap, *s ); s++ )\n      v = (short)( v * base + a2i[(int)*s] );\n\n    if ( end != 0 )\n      *end = s;\n\n    return (short)( ( !neg ) ? v : -v );\n  }\n", "target": 0, "idx": 6505}
{"func": "static void timer_trigger_notify(Unit *u, Unit *other) {\n        Timer *t = TIMER(u);\n        TimerValue *v;\n\n        assert(u);\n        assert(other);\n\n        if (other->load_state != UNIT_LOADED)\n                return;\n\n        /* Reenable all timers that depend on unit state */\n        LIST_FOREACH(value, v, t->values)\n                if (v->base == TIMER_UNIT_ACTIVE ||\n                    v->base == TIMER_UNIT_INACTIVE)\n                        v->disabled = false;\n\n        switch (t->state) {\n\n        case TIMER_WAITING:\n        case TIMER_ELAPSED:\n\n                /* Recalculate sleep time */\n                timer_enter_waiting(t, false);\n                break;\n\n        case TIMER_RUNNING:\n\n                if (UNIT_IS_INACTIVE_OR_FAILED(unit_active_state(other))) {\n                        log_unit_debug(UNIT(t), \"Got notified about unit deactivation.\");\n                        timer_enter_waiting(t, false);\n                }\n                break;\n\n        case TIMER_DEAD:\n        case TIMER_FAILED:\n                break;\n\n        default:\n                assert_not_reached(\"Unknown timer state\");\n        }\n}\n", "target": 0, "idx": 96137}
{"func": "SPL_METHOD(SplTempFileObject, __construct)\n{\n\tlong max_memory = PHP_STREAM_MAX_MEM;\n\tchar tmp_fname[48];\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tzend_error_handling error_handling;\n\n\tzend_replace_error_handling(EH_THROW, spl_ce_RuntimeException, &error_handling TSRMLS_CC);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|l\", &max_memory) == FAILURE) {\n\t\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\t\treturn;\n\t}\n\n\tif (max_memory < 0) {\n\t\tintern->file_name = \"php://memory\";\n\t\tintern->file_name_len = 12;\n\t} else if (ZEND_NUM_ARGS()) {\n\t\tintern->file_name_len = slprintf(tmp_fname, sizeof(tmp_fname), \"php://temp/maxmemory:%ld\", max_memory);\n\t\tintern->file_name = tmp_fname;\n\t} else {\n\t\tintern->file_name = \"php://temp\";\n\t\tintern->file_name_len = 10;\n\t}\n \tintern->u.file.open_mode = \"wb\";\n \tintern->u.file.open_mode_len = 1;\n \tintern->u.file.zcontext = NULL;\n \tif (spl_filesystem_file_open(intern, 0, 0 TSRMLS_CC) == SUCCESS) {\n \t\tintern->_path_len = 0;\n \t\tintern->_path = estrndup(\"\", 0);\n\t}\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n} /* }}} */\n\n/* {{{ proto void SplFileObject::rewind()\n", "target": 1, "idx": 180222}
{"func": "white_point(PNG_CONST color_encoding *encoding)\n {\n    CIE_color white;\n \n   white.X = encoding->red.X + encoding->green.X + encoding->blue.X;\n   white.Y = encoding->red.Y + encoding->green.Y + encoding->blue.Y;\n   white.Z = encoding->red.Z + encoding->green.Z + encoding->blue.Z;\n\n \n    return white;\n }\n", "target": 1, "idx": 187740}
{"func": "externalParEntProcessor(XML_Parser parser, const char *s, const char *end,\n                        const char **nextPtr) {\n  const char *next = s;\n  int tok;\n\n  tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  if (tok <= 0) {\n    if (! parser->m_parsingStatus.finalBuffer && tok != XML_TOK_INVALID) {\n      *nextPtr = s;\n      return XML_ERROR_NONE;\n    }\n    switch (tok) {\n    case XML_TOK_INVALID:\n      return XML_ERROR_INVALID_TOKEN;\n    case XML_TOK_PARTIAL:\n      return XML_ERROR_UNCLOSED_TOKEN;\n    case XML_TOK_PARTIAL_CHAR:\n      return XML_ERROR_PARTIAL_CHAR;\n    case XML_TOK_NONE: /* start == end */\n    default:\n      break;\n    }\n  }\n  /* This would cause the next stage, i.e. doProlog to be passed XML_TOK_BOM.\n     However, when parsing an external subset, doProlog will not accept a BOM\n     as valid, and report a syntax error, so we have to skip the BOM\n  */\n  else if (tok == XML_TOK_BOM) {\n    s = next;\n    tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  }\n \n   parser->m_processor = prologProcessor;\n   return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n                  (XML_Bool)! parser->m_parsingStatus.finalBuffer);\n }\n", "target": 1, "idx": 182702}
{"func": "void AutoFillCCInfoBarDelegate::InfoBarClosed() {\n  if (host_) {\n     host_->OnInfoBarClosed(false);\n     host_ = NULL;\n   }\n  ConfirmInfoBarDelegate::InfoBarClosed();\n }\n", "target": 1, "idx": 183434}
{"func": "void OutOfProcessInstance::SearchString(const base::char16* string,\n                            const base::char16* term,\n                            bool case_sensitive,\n                            std::vector<SearchStringResult>* results) {\n  PP_PrivateFindResult* pp_results;\n  int count = 0;\n  pp::PDF::SearchString(\n      this,\n      reinterpret_cast<const unsigned short*>(string),\n      reinterpret_cast<const unsigned short*>(term),\n      case_sensitive,\n      &pp_results,\n      &count);\n\n  results->resize(count);\n  for (int i = 0; i < count; ++i) {\n    (*results)[i].start_index = pp_results[i].start_index;\n    (*results)[i].length = pp_results[i].length;\n  }\n\n  pp::Memory_Dev memory;\n  memory.MemFree(pp_results);\n}\n", "target": 0, "idx": 140660}
{"func": "PHP_LIBXML_API zval *php_libxml_switch_context(zval *context TSRMLS_DC)\n{\n\tzval *oldcontext;\n\n\toldcontext = LIBXML(stream_context);\n\tLIBXML(stream_context) = context;\n\treturn oldcontext;\n\n}\n", "target": 0, "idx": 14265}
{"func": " static bool generic_new(struct nf_conn *ct, const struct sk_buff *skb,\n \t\t\tunsigned int dataoff, unsigned int *timeouts)\n {\n\treturn true;\n }\n", "target": 1, "idx": 179981}
{"func": "s4u_identify_user(krb5_context context,\n                  krb5_creds *in_creds,\n                  krb5_data *subject_cert,\n                  krb5_principal *canon_user)\n{\n    krb5_error_code code;\n    krb5_preauthtype ptypes[1] = { KRB5_PADATA_S4U_X509_USER };\n    krb5_creds creds;\n    int use_master = 0;\n    krb5_get_init_creds_opt *opts = NULL;\n    krb5_principal_data client;\n    krb5_s4u_userid userid;\n\n    *canon_user = NULL;\n\n    if (in_creds->client == NULL && subject_cert == NULL) {\n        return EINVAL;\n    }\n\n    if (in_creds->client != NULL &&\n        in_creds->client->type != KRB5_NT_ENTERPRISE_PRINCIPAL) {\n        int anonymous;\n\n        anonymous = krb5_principal_compare(context, in_creds->client,\n                                           krb5_anonymous_principal());\n\n        return krb5_copy_principal(context,\n                                   anonymous ? in_creds->server\n                                   : in_creds->client,\n                                   canon_user);\n    }\n\n    memset(&creds, 0, sizeof(creds));\n\n    memset(&userid, 0, sizeof(userid));\n    if (subject_cert != NULL)\n        userid.subject_cert = *subject_cert;\n\n    code = krb5_get_init_creds_opt_alloc(context, &opts);\n    if (code != 0)\n        goto cleanup;\n    krb5_get_init_creds_opt_set_tkt_life(opts, 15);\n    krb5_get_init_creds_opt_set_renew_life(opts, 0);\n    krb5_get_init_creds_opt_set_forwardable(opts, 0);\n    krb5_get_init_creds_opt_set_proxiable(opts, 0);\n    krb5_get_init_creds_opt_set_canonicalize(opts, 1);\n    krb5_get_init_creds_opt_set_preauth_list(opts, ptypes, 1);\n\n    if (in_creds->client != NULL) {\n        client = *in_creds->client;\n        client.realm = in_creds->server->realm;\n    } else {\n        client.magic = KV5M_PRINCIPAL;\n        client.realm = in_creds->server->realm;\n        /* should this be NULL, empty or a fixed string? XXX */\n        client.data = NULL;\n        client.length = 0;\n        client.type = KRB5_NT_ENTERPRISE_PRINCIPAL;\n    }\n\n     code = k5_get_init_creds(context, &creds, &client, NULL, NULL, 0, NULL,\n                              opts, krb5_get_as_key_noop, &userid, &use_master,\n                              NULL);\n    if (code == 0 || code == KRB5_PREAUTH_FAILED) {\n         *canon_user = userid.user;\n         userid.user = NULL;\n         code = 0;\n    }\n\ncleanup:\n    krb5_free_cred_contents(context, &creds);\n    if (opts != NULL)\n        krb5_get_init_creds_opt_free(context, opts);\n    if (userid.user != NULL)\n        krb5_free_principal(context, userid.user);\n\n    return code;\n}\n", "target": 1, "idx": 182130}
{"func": "std::string ChromeContentRendererClient::GetNavigationErrorHtml(\n    const WebURLRequest& failed_request,\n    const WebURLError& error) {\n  GURL failed_url = error.unreachableURL;\n  std::string html;\n  const Extension* extension = NULL;\n\n  int resource_id;\n  DictionaryValue error_strings;\n  if (failed_url.is_valid() && !failed_url.SchemeIs(chrome::kExtensionScheme))\n    extension = extension_dispatcher_->extensions()->GetByURL(failed_url);\n  if (extension) {\n    LocalizedError::GetAppErrorStrings(error, failed_url, extension,\n                                       &error_strings);\n\n    resource_id = IDR_ERROR_APP_HTML;\n  } else {\n    if (error.domain == WebString::fromUTF8(net::kErrorDomain) &&\n        error.reason == net::ERR_CACHE_MISS &&\n        EqualsASCII(failed_request.httpMethod(), \"POST\")) {\n      LocalizedError::GetFormRepostStrings(failed_url, &error_strings);\n    } else {\n      LocalizedError::GetStrings(error, &error_strings);\n    }\n    resource_id = IDR_NET_ERROR_HTML;\n  }\n\n  const base::StringPiece template_html(\n      ResourceBundle::GetSharedInstance().GetRawDataResource(resource_id));\n  if (template_html.empty()) {\n    NOTREACHED() << \"unable to load template. ID: \" << resource_id;\n  } else {\n    html = jstemplate_builder::GetTemplatesHtml(\n        template_html, &error_strings, \"t\");\n  }\n\n  return html;\n}\n", "target": 0, "idx": 103646}
{"func": "ring_buffer_read(struct ring_buffer_iter *iter, u64 *ts)\n{\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer_per_cpu *cpu_buffer = iter->cpu_buffer;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&cpu_buffer->reader_lock, flags);\n again:\n\tevent = rb_iter_peek(iter, ts);\n\tif (!event)\n\t\tgoto out;\n\n\tif (event->type_len == RINGBUF_TYPE_PADDING)\n\t\tgoto again;\n\n\trb_advance_iter(iter);\n out:\n\traw_spin_unlock_irqrestore(&cpu_buffer->reader_lock, flags);\n\n\treturn event;\n}\n", "target": 0, "idx": 72617}
{"func": "static void __exit snd_compress_exit(void)\n{\n}\n", "target": 0, "idx": 58102}
{"func": "void GfxImageColorMap::getGrayLine(Guchar *in, Guchar *out, int length) {\n  int i, j;\n  Guchar *inp, *tmp_line;\n\n   switch (colorSpace->getMode()) {\n   case csIndexed:\n   case csSeparation:\n    tmp_line = (Guchar *) gmalloc (length * nComps2);\n     for (i = 0; i < length; i++) {\n       for (j = 0; j < nComps2; j++) {\n \ttmp_line[i * nComps2 + j] = byte_lookup[in[i] * nComps2 + j];\n      }\n    }\n    colorSpace2->getGrayLine(tmp_line, out, length);\n    gfree (tmp_line);\n    break;\n\n  default:\n    inp = in;\n    for (j = 0; j < length; j++)\n      for (i = 0; i < nComps; i++) {\n\t*inp = byte_lookup[*inp * nComps + i];\n\tinp++;\n      }\n    colorSpace->getGrayLine(in, out, length);\n    break;\n  }\n\n}\n", "target": 1, "idx": 177781}
{"func": "ipt_do_table(struct sk_buff *skb,\n\t     const struct nf_hook_state *state,\n\t     struct xt_table *table)\n{\n\tunsigned int hook = state->hook;\n\tstatic const char nulldevname[IFNAMSIZ] __attribute__((aligned(sizeof(long))));\n\tconst struct iphdr *ip;\n\t/* Initializing verdict to NF_DROP keeps gcc happy. */\n\tunsigned int verdict = NF_DROP;\n\tconst char *indev, *outdev;\n\tconst void *table_base;\n\tstruct ipt_entry *e, **jumpstack;\n\tunsigned int stackidx, cpu;\n\tconst struct xt_table_info *private;\n\tstruct xt_action_param acpar;\n\tunsigned int addend;\n\n\t/* Initialization */\n\tstackidx = 0;\n\tip = ip_hdr(skb);\n\tindev = state->in ? state->in->name : nulldevname;\n\toutdev = state->out ? state->out->name : nulldevname;\n\t/* We handle fragments by dealing with the first fragment as\n\t * if it was a normal packet.  All other fragments are treated\n\t * normally, except that they will NEVER match rules that ask\n\t * things we don't know, ie. tcp syn flag or ports).  If the\n\t * rule is also a fragment-specific rule, non-fragments won't\n\t * match it. */\n\tacpar.fragoff = ntohs(ip->frag_off) & IP_OFFSET;\n\tacpar.thoff   = ip_hdrlen(skb);\n\tacpar.hotdrop = false;\n\tacpar.net     = state->net;\n\tacpar.in      = state->in;\n\tacpar.out     = state->out;\n\tacpar.family  = NFPROTO_IPV4;\n\tacpar.hooknum = hook;\n\n\tIP_NF_ASSERT(table->valid_hooks & (1 << hook));\n\tlocal_bh_disable();\n\taddend = xt_write_recseq_begin();\n\tprivate = table->private;\n\tcpu        = smp_processor_id();\n\t/*\n\t * Ensure we load private-> members after we've fetched the base\n\t * pointer.\n\t */\n\tsmp_read_barrier_depends();\n\ttable_base = private->entries;\n\tjumpstack  = (struct ipt_entry **)private->jumpstack[cpu];\n\n\t/* Switch to alternate jumpstack if we're being invoked via TEE.\n\t * TEE issues XT_CONTINUE verdict on original skb so we must not\n\t * clobber the jumpstack.\n\t *\n\t * For recursion via REJECT or SYNPROXY the stack will be clobbered\n\t * but it is no problem since absolute verdict is issued by these.\n\t */\n\tif (static_key_false(&xt_tee_enabled))\n\t\tjumpstack += private->stacksize * __this_cpu_read(nf_skb_duplicated);\n\n\te = get_entry(table_base, private->hook_entry[hook]);\n\n\tpr_debug(\"Entering %s(hook %u), UF %p\\n\",\n\t\t table->name, hook,\n\t\t get_entry(table_base, private->underflow[hook]));\n\n\tdo {\n\t\tconst struct xt_entry_target *t;\n\t\tconst struct xt_entry_match *ematch;\n\t\tstruct xt_counters *counter;\n\n\t\tIP_NF_ASSERT(e);\n\t\tif (!ip_packet_match(ip, indev, outdev,\n\t\t    &e->ip, acpar.fragoff)) {\n no_match:\n\t\t\te = ipt_next_entry(e);\n\t\t\tcontinue;\n\t\t}\n\n\t\txt_ematch_foreach(ematch, e) {\n\t\t\tacpar.match     = ematch->u.kernel.match;\n\t\t\tacpar.matchinfo = ematch->data;\n\t\t\tif (!acpar.match->match(skb, &acpar))\n\t\t\t\tgoto no_match;\n\t\t}\n\n\t\tcounter = xt_get_this_cpu_counter(&e->counters);\n\t\tADD_COUNTER(*counter, skb->len, 1);\n\n\t\tt = ipt_get_target(e);\n\t\tIP_NF_ASSERT(t->u.kernel.target);\n\n#if IS_ENABLED(CONFIG_NETFILTER_XT_TARGET_TRACE)\n\t\t/* The packet is traced: log it */\n\t\tif (unlikely(skb->nf_trace))\n\t\t\ttrace_packet(state->net, skb, hook, state->in,\n\t\t\t\t     state->out, table->name, private, e);\n#endif\n\t\t/* Standard target? */\n\t\tif (!t->u.kernel.target->target) {\n\t\t\tint v;\n\n\t\t\tv = ((struct xt_standard_target *)t)->verdict;\n\t\t\tif (v < 0) {\n\t\t\t\t/* Pop from stack? */\n\t\t\t\tif (v != XT_RETURN) {\n\t\t\t\t\tverdict = (unsigned int)(-v) - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (stackidx == 0) {\n\t\t\t\t\te = get_entry(table_base,\n\t\t\t\t\t    private->underflow[hook]);\n\t\t\t\t\tpr_debug(\"Underflow (this is normal) \"\n\t\t\t\t\t\t \"to %p\\n\", e);\n\t\t\t\t} else {\n\t\t\t\t\te = jumpstack[--stackidx];\n\t\t\t\t\tpr_debug(\"Pulled %p out from pos %u\\n\",\n\t\t\t\t\t\t e, stackidx);\n\t\t\t\t\te = ipt_next_entry(e);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (table_base + v != ipt_next_entry(e) &&\n\t\t\t    !(e->ip.flags & IPT_F_GOTO)) {\n\t\t\t\tjumpstack[stackidx++] = e;\n\t\t\t\tpr_debug(\"Pushed %p into pos %u\\n\",\n\t\t\t\t\t e, stackidx - 1);\n\t\t\t}\n\n\t\t\te = get_entry(table_base, v);\n\t\t\tcontinue;\n\t\t}\n\n\t\tacpar.target   = t->u.kernel.target;\n\t\tacpar.targinfo = t->data;\n\n\t\tverdict = t->u.kernel.target->target(skb, &acpar);\n\t\t/* Target might have changed stuff. */\n\t\tip = ip_hdr(skb);\n\t\tif (verdict == XT_CONTINUE)\n\t\t\te = ipt_next_entry(e);\n\t\telse\n\t\t\t/* Verdict */\n\t\t\tbreak;\n\t} while (!acpar.hotdrop);\n\tpr_debug(\"Exiting %s; sp at %u\\n\", __func__, stackidx);\n\n\txt_write_recseq_end(addend);\n\tlocal_bh_enable();\n\n#ifdef DEBUG_ALLOW_ALL\n\treturn NF_ACCEPT;\n#else\n\tif (acpar.hotdrop)\n\t\treturn NF_DROP;\n\telse return verdict;\n#endif\n}\n", "target": 0, "idx": 52311}
{"func": " void PrintingMessageFilter::OnUpdatePrintSettingsReply(\n     scoped_refptr<printing::PrinterQuery> printer_query,\n     IPC::Message* reply_msg) {\n   PrintMsg_PrintPages_Params params;\n  if (printer_query->last_status() != printing::PrintingContext::OK) {\n     params.Reset();\n   } else {\n     RenderParamsFromPrintSettings(printer_query->settings(), &params.params);\n    params.params.document_cookie = printer_query->cookie();\n    params.pages =\n        printing::PageRange::GetPages(printer_query->settings().ranges);\n  }\n   PrintHostMsg_UpdatePrintSettings::WriteReplyParams(reply_msg, params);\n   Send(reply_msg);\n  if (printer_query->cookie() && printer_query->settings().dpi())\n    print_job_manager_->QueuePrinterQuery(printer_query.get());\n  else\n    printer_query->StopWorker();\n }\n", "target": 1, "idx": 183695}
{"func": "std::unique_ptr<JSONObject> EffectPaintPropertyNode::ToJSON() const {\n  auto json = JSONObject::Create();\n   if (Parent())\n     json->SetString(\"parent\", String::Format(\"%p\", Parent()));\n   json->SetString(\"localTransformSpace\",\n                  String::Format(\"%p\", state_.local_transform_space.get()));\n  json->SetString(\"outputClip\", String::Format(\"%p\", state_.output_clip.get()));\n   if (state_.color_filter != kColorFilterNone)\n     json->SetInteger(\"colorFilter\", state_.color_filter);\n   if (!state_.filter.IsEmpty())\n    json->SetString(\"filter\", state_.filter.ToString());\n  if (state_.opacity != 1.0f)\n    json->SetDouble(\"opacity\", state_.opacity);\n  if (state_.blend_mode != SkBlendMode::kSrcOver)\n    json->SetString(\"blendMode\", SkBlendMode_Name(state_.blend_mode));\n  if (state_.direct_compositing_reasons != CompositingReason::kNone) {\n    json->SetString(\n        \"directCompositingReasons\",\n        CompositingReason::ToString(state_.direct_compositing_reasons));\n  }\n  if (state_.compositor_element_id) {\n    json->SetString(\"compositorElementId\",\n                    state_.compositor_element_id.ToString().c_str());\n  }\n  if (state_.paint_offset != FloatPoint())\n    json->SetString(\"paintOffset\", state_.paint_offset.ToString());\n  return json;\n}\n", "target": 1, "idx": 185712}
{"func": "void PrintPreviewHandler::SelectFile(const FilePath& default_filename) {\n  ui::SelectFileDialog::FileTypeInfo file_type_info;\n  file_type_info.extensions.resize(1);\n  file_type_info.extensions[0].push_back(FILE_PATH_LITERAL(\"pdf\"));\n\n  if (!GetStickySettings()->save_path()) {\n    base::ThreadRestrictions::ScopedAllowIO allow_io;\n    FilePath file_path;\n    PathService::Get(chrome::DIR_USER_DOCUMENTS, &file_path);\n    GetStickySettings()->StoreSavePath(file_path);\n  }\n\n  select_file_dialog_ = ui::SelectFileDialog::Create(\n      this, new ChromeSelectFilePolicy(preview_web_contents())),\n  select_file_dialog_->SelectFile(\n      ui::SelectFileDialog::SELECT_SAVEAS_FILE,\n      string16(),\n      GetStickySettings()->save_path()->Append(default_filename),\n      &file_type_info,\n      0,\n      FILE_PATH_LITERAL(\"\"),\n      platform_util::GetTopLevel(preview_web_contents()->GetNativeView()),\n      NULL);\n}\n", "target": 0, "idx": 112775}
{"func": "static int hid_reset_device(int sub_api, struct libusb_device_handle *dev_handle)\n{\n\tstruct windows_device_handle_priv *handle_priv = _device_handle_priv(dev_handle);\n\tHANDLE hid_handle;\n\tint current_interface;\n\tCHECK_HID_AVAILABLE;\n\tfor (current_interface = 0; current_interface < USB_MAXINTERFACES; current_interface++) {\n\t\thid_handle = handle_priv->interface_handle[current_interface].api_handle;\n\t\tif ((hid_handle != 0) && (hid_handle != INVALID_HANDLE_VALUE)) {\n\t\t\tHidD_FlushQueue(hid_handle);\n\t\t}\n\t}\n\treturn LIBUSB_SUCCESS;\n}\n", "target": 1, "idx": 187233}
{"func": "SocketStreamDispatcherHost::SocketStreamDispatcherHost(\n     int render_process_id,\n     ResourceMessageFilter::URLRequestContextSelector* selector,\n     content::ResourceContext* resource_context)\n    : ALLOW_THIS_IN_INITIALIZER_LIST(ssl_delegate_weak_factory_(this)),\n      render_process_id_(render_process_id),\n       url_request_context_selector_(selector),\n       resource_context_(resource_context) {\n   DCHECK(selector);\n  net::WebSocketJob::EnsureInit();\n}\n", "target": 1, "idx": 184685}
{"func": " bool OmniboxViewViews::ShouldShowPlaceholderText() const {\n   return Textfield::ShouldShowPlaceholderText() &&\n         !model()->is_caret_visible() && !model()->is_keyword_selected();\n }\n", "target": 1, "idx": 186512}
{"func": "void HTMLLinkElement::attach()\n{\n    if (m_shouldProcessAfterAttach) {\n        m_shouldProcessAfterAttach = false;\n        queuePostAttachCallback(&HTMLLinkElement::processCallback, this);\n    }\n    HTMLElement::attach();\n}\n", "target": 1, "idx": 183486}
{"func": " AXObject* AXObjectCacheImpl::createFromRenderer(LayoutObject* layoutObject) {\n  Node* node = layoutObject->node();\n\n  if (nodeHasRole(node, \"list\") || nodeHasRole(node, \"directory\") ||\n      (nodeHasRole(node, nullAtom) &&\n       (isHTMLUListElement(node) || isHTMLOListElement(node) ||\n        isHTMLDListElement(node))))\n    return AXList::create(layoutObject, *this);\n\n  if (nodeHasRole(node, \"grid\") || nodeHasRole(node, \"treegrid\"))\n    return AXARIAGrid::create(layoutObject, *this);\n  if (nodeHasRole(node, \"row\"))\n    return AXARIAGridRow::create(layoutObject, *this);\n  if (nodeHasRole(node, \"gridcell\") || nodeHasRole(node, \"columnheader\") ||\n      nodeHasRole(node, \"rowheader\"))\n    return AXARIAGridCell::create(layoutObject, *this);\n\n  if (node && node->isMediaControlElement())\n    return AccessibilityMediaControl::create(layoutObject, *this);\n\n  if (isHTMLOptionElement(node))\n    return AXListBoxOption::create(layoutObject, *this);\n\n  if (isHTMLInputElement(node) &&\n      toHTMLInputElement(node)->type() == InputTypeNames::radio)\n    return AXRadioInput::create(layoutObject, *this);\n\n  if (layoutObject->isSVGRoot())\n    return AXSVGRoot::create(layoutObject, *this);\n\n  if (layoutObject->isBoxModelObject()) {\n    LayoutBoxModelObject* cssBox = toLayoutBoxModelObject(layoutObject);\n    if (cssBox->isListBox())\n      return AXListBox::create(toLayoutListBox(cssBox), *this);\n    if (cssBox->isMenuList())\n      return AXMenuList::create(toLayoutMenuList(cssBox), *this);\n\n    if (cssBox->isTable())\n      return AXTable::create(toLayoutTable(cssBox), *this);\n    if (cssBox->isTableRow())\n      return AXTableRow::create(toLayoutTableRow(cssBox), *this);\n    if (cssBox->isTableCell())\n      return AXTableCell::create(toLayoutTableCell(cssBox), *this);\n\n    if (cssBox->isProgress())\n      return AXProgressIndicator::create(toLayoutProgress(cssBox), *this);\n\n    if (cssBox->isSlider())\n      return AXSlider::create(toLayoutSlider(cssBox), *this);\n  }\n\n  return AXLayoutObject::create(layoutObject, *this);\n}\n", "target": 0, "idx": 138226}
{"func": "SoftVPX::SoftVPX(\n const char *name,\n const char *componentRole,\n        OMX_VIDEO_CODINGTYPE codingType,\n const OMX_CALLBACKTYPE *callbacks,\n        OMX_PTR appData,\n        OMX_COMPONENTTYPE **component)\n : SoftVideoDecoderOMXComponent(\n            name, componentRole, codingType,\n            codingType == OMX_VIDEO_CodingVP8 ? NULL : kVP9ProfileLevels,\n            codingType == OMX_VIDEO_CodingVP8 ? 0 : NELEM(kVP9ProfileLevels),\n 320 /* width */, 240 /* height */, callbacks, appData, component),\n      mMode(codingType == OMX_VIDEO_CodingVP8 ? MODE_VP8 : MODE_VP9),\n      mEOSStatus(INPUT_DATA_AVAILABLE),\n      mCtx(NULL),\n      mFrameParallelMode(false),\n      mTimeStampIdx(0),\n      mImg(NULL) {\n const size_t kMinCompressionRatio = mMode == MODE_VP8 ? 2 : 4;\n const char *mime = mMode == MODE_VP8 ? MEDIA_MIMETYPE_VIDEO_VP8 : MEDIA_MIMETYPE_VIDEO_VP9;\n const size_t kMaxOutputBufferSize = 2048 * 2048 * 3 / 2;\n    initPorts(\n            kNumBuffers, kMaxOutputBufferSize / kMinCompressionRatio /* inputBufferSize */,\n            kNumBuffers, mime, kMinCompressionRatio);\n    CHECK_EQ(initDecoder(), (status_t)OK);\n}\n", "target": 0, "idx": 171500}
{"func": "static void voidMethodNodeFilterArgMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)\n{\n    TRACE_EVENT_SET_SAMPLING_STATE(\"Blink\", \"DOMMethod\");\n    TestObjectPythonV8Internal::voidMethodNodeFilterArgMethod(info);\n    TRACE_EVENT_SET_SAMPLING_STATE(\"V8\", \"V8Execution\");\n}\n", "target": 0, "idx": 131930}
{"func": "static void NPN_SetException(NPObject* npobj, const NPUTF8* message)\n{\n    notImplemented();\n}\n", "target": 0, "idx": 99517}
{"func": "  void AssertObserverCount(int added_count, int removed_count,\n                            int changed_count) {\n     ASSERT_EQ(added_count, added_count_);\n     ASSERT_EQ(removed_count, removed_count_);\n    ASSERT_EQ(changed_count, changed_count_);\n  }\n", "target": 1, "idx": 183925}
{"func": " IW_IMPL(int) iw_get_i32le(const iw_byte *b)\n {\n\treturn (iw_int32)(iw_uint32)(b[0] | (b[1]<<8) | (b[2]<<16) | (b[3]<<24));\n }\n", "target": 1, "idx": 181368}
{"func": "OMX_ERRORTYPE SoftMPEG2::internalSetParameter(OMX_INDEXTYPE index, const OMX_PTR params) {\n const uint32_t oldWidth = mWidth;\n const uint32_t oldHeight = mHeight;\n    OMX_ERRORTYPE ret = SoftVideoDecoderOMXComponent::internalSetParameter(index, params);\n if (mWidth != oldWidth || mHeight != oldHeight) {\n        reInitDecoder();\n }\n\n     return ret;\n }\n", "target": 0, "idx": 177076}
{"func": "static int airo_close(struct net_device *dev) {\n\tstruct airo_info *ai = dev->ml_priv;\n\n\tnetif_stop_queue(dev);\n\n\tif (ai->wifidev != dev) {\n#ifdef POWER_ON_DOWN\n\t\t/* Shut power to the card. The idea is that the user can save\n\t\t * power when he doesn't need the card with \"ifconfig down\".\n\t\t * That's the method that is most friendly towards the network\n\t\t * stack (i.e. the network stack won't try to broadcast\n\t\t * anything on the interface and routes are gone. Jean II */\n\t\tset_bit(FLAG_RADIO_DOWN, &ai->flags);\n\t\tdisable_MAC(ai, 1);\n#endif\n\t\tdisable_interrupts( ai );\n\n\t\tfree_irq(dev->irq, dev);\n\n\t\tset_bit(JOB_DIE, &ai->jobs);\n\t\tkthread_stop(ai->airo_thread_task);\n\t}\n\treturn 0;\n}\n", "target": 0, "idx": 23943}
{"func": "long Chapters::Atom::Parse(\n    IMkvReader* pReader,\n    long long pos,\n    long long size)\n{\n    const long long stop = pos + size;\n    while (pos < stop)\n    {\n        long long id, size;\n        long status = ParseElementHeader(\n                        pReader,\n                        pos,\n                        stop,\n                        id,\n                        size);\n        if (status < 0)  // error\n            return status;\n        if (size == 0)  // weird\n            continue;\n        if (id == 0x00)  // Display ID\n        {\n            status = ParseDisplay(pReader, pos, size);\n            if (status < 0)  // error\n                return status;\n        }\n        else if (id == 0x1654)  // StringUID ID\n        {\n            status = UnserializeString(pReader, pos, size, m_string_uid);\n            if (status < 0)  // error\n                return status;\n        }\n        else if (id == 0x33C4)  // UID ID\n        {\n            long long val;\n            status = UnserializeInt(pReader, pos, size, val);\n            if (status < 0)  // error\n                return status;\n            m_uid = val;\n        }\n        else if (id == 0x11)  // TimeStart ID\n        {\n            const long long val = UnserializeUInt(pReader, pos, size);\n            if (val < 0)  // error\n                return static_cast<long>(val);\n            m_start_timecode = val;\n        }\n        else if (id == 0x12)  // TimeEnd ID\n        {\n            const long long val = UnserializeUInt(pReader, pos, size);\n            if (val < 0)  // error\n                return static_cast<long>(val);\n            m_stop_timecode = val;\n        }\n        pos += size;\n        assert(pos <= stop);\n    }\n    assert(pos == stop);\n    return 0;\n}\n", "target": 1, "idx": 188424}
{"func": "static int a2dp_command(struct a2dp_stream_common *common, char cmd)\n{\n char ack;\n\n\n     DEBUG(\"A2DP COMMAND %s\", dump_a2dp_ctrl_event(cmd));\n \n     /* send command */\n    if (send(common->ctrl_fd, &cmd, 1, MSG_NOSIGNAL) == -1)\n     {\n         ERROR(\"cmd failed (%s)\", strerror(errno));\n         skt_disconnect(common->ctrl_fd);\n        common->ctrl_fd = AUDIO_SKT_DISCONNECTED;\n return -1;\n }\n\n /* wait for ack byte */\n if (a2dp_ctrl_receive(common, &ack, 1) < 0)\n return -1;\n\n    DEBUG(\"A2DP COMMAND %s DONE STATUS %d\", dump_a2dp_ctrl_event(cmd), ack);\n\n if (ack == A2DP_CTRL_ACK_INCALL_FAILURE)\n return ack;\n if (ack != A2DP_CTRL_ACK_SUCCESS)\n return -1;\n\n return 0;\n}\n", "target": 1, "idx": 187444}
{"func": "bool ShouldSendCharEventForKeyboardCode(ui::KeyboardCode keycode) {\n  if ((keycode >= ui::VKEY_0 && keycode <= ui::VKEY_9) ||\n      (keycode >= ui::VKEY_A && keycode <= ui::VKEY_Z) ||\n      (keycode >= ui::VKEY_NUMPAD0 && keycode <= ui::VKEY_NUMPAD9)) {\n    return true;\n  }\n\n  switch (keycode) {\n    case ui::VKEY_RETURN:\n    case ui::VKEY_SPACE:\n    case ui::VKEY_MULTIPLY:\n    case ui::VKEY_ADD:\n    case ui::VKEY_SUBTRACT:\n    case ui::VKEY_DECIMAL:\n    case ui::VKEY_DIVIDE:\n    case ui::VKEY_OEM_1:\n    case ui::VKEY_OEM_2:\n    case ui::VKEY_OEM_3:\n    case ui::VKEY_OEM_4:\n    case ui::VKEY_OEM_5:\n    case ui::VKEY_OEM_6:\n    case ui::VKEY_OEM_7:\n    case ui::VKEY_OEM_102:\n    case ui::VKEY_OEM_PLUS:\n    case ui::VKEY_OEM_COMMA:\n    case ui::VKEY_OEM_MINUS:\n    case ui::VKEY_OEM_PERIOD:\n      return true;\n    default:\n      return false;\n  }\n}\n", "target": 0, "idx": 110958}
{"func": "print_attr_string(netdissect_options *ndo,\n                  register const u_char *data, u_int length, u_short attr_code)\n{\n   register u_int i;\n\n   ND_TCHECK2(data[0],length);\n\n   switch(attr_code)\n    {\n       case TUNNEL_PASS:\n            if (length < 3)\n           {\n              ND_PRINT((ndo, \"%s\", tstr));\n              return;\n           }\n            if (*data && (*data <=0x1F) )\n               ND_PRINT((ndo, \"Tag[%u] \", *data));\n            else\n              ND_PRINT((ndo, \"Tag[Unused] \"));\n           data++;\n           length--;\n           ND_PRINT((ndo, \"Salt %u \", EXTRACT_16BITS(data)));\n           data+=2;\n           length-=2;\n        break;\n      case TUNNEL_CLIENT_END:\n      case TUNNEL_SERVER_END:\n      case TUNNEL_PRIV_GROUP:\n      case TUNNEL_ASSIGN_ID:\n      case TUNNEL_CLIENT_AUTH:\n      case TUNNEL_SERVER_AUTH:\n            if (*data <= 0x1F)\n            {\n               if (length < 1)\n              {\n                 ND_PRINT((ndo, \"%s\", tstr));\n                 return;\n              }\n               if (*data)\n                 ND_PRINT((ndo, \"Tag[%u] \", *data));\n               else\n                ND_PRINT((ndo, \"Tag[Unused] \"));\n              data++;\n              length--;\n            }\n         break;\n       case EGRESS_VLAN_NAME:\n            ND_PRINT((ndo, \"%s (0x%02x) \",\n                   tok2str(rfc4675_tagged,\"Unknown tag\",*data),\n                   *data));\n           data++;\n           length--;\n         break;\n    }\n \n   for (i=0; *data && i < length ; i++, data++)\n        ND_PRINT((ndo, \"%c\", (*data < 32 || *data > 126) ? '.' : *data));\n \n    return;\n\n   trunc:\n      ND_PRINT((ndo, \"%s\", tstr));\n}\n", "target": 1, "idx": 181023}
{"func": "  explicit FrameFactoryImpl(const service_manager::BindSourceInfo& source_info)\n      : source_info_(source_info), routing_id_highmark_(-1) {}\n", "target": 0, "idx": 163320}
{"func": "BOOL transport_connect_nla(rdpTransport* transport)\n{\n\tfreerdp* instance;\n\trdpSettings* settings;\n\n\tif (transport->layer == TRANSPORT_LAYER_TSG)\n\t\treturn TRUE;\n\n\tif (!transport_connect_tls(transport))\n\t\treturn FALSE;\n\n\t/* Network Level Authentication */\n\n\tif (transport->settings->Authentication != TRUE)\n\t\treturn TRUE;\n\n\tsettings = transport->settings;\n\tinstance = (freerdp*) settings->instance;\n\n\tif (transport->credssp == NULL)\n\t\ttransport->credssp = credssp_new(instance, transport, settings);\n\n\tif (credssp_authenticate(transport->credssp) < 0)\n\t{\n\t\tif (!connectErrorCode)\n\t\t\tconnectErrorCode = AUTHENTICATIONERROR;\n\n\t\tfprintf(stderr, \"Authentication failure, check credentials.\\n\"\n \t\t\t\"If credentials are valid, the NTLMSSP implementation may be to blame.\\n\");\n \n \t\tcredssp_free(transport->credssp);\n \t\treturn FALSE;\n \t}\n \n\tcredssp_free(transport->credssp);\n\n\treturn TRUE;\n}\n", "target": 1, "idx": 180774}
{"func": "static int __init balloon_init(void)\n{\n\tif (!xen_domain())\n\t\treturn -ENODEV;\n\n\tpr_info(\"Initialising balloon driver\\n\");\n\n#ifdef CONFIG_XEN_PV\n\tballoon_stats.current_pages = xen_pv_domain()\n\t\t? min(xen_start_info->nr_pages - xen_released_pages, max_pfn)\n\t\t: get_num_physpages();\n#else\n\tballoon_stats.current_pages = get_num_physpages();\n#endif\n\tballoon_stats.target_pages  = balloon_stats.current_pages;\n\tballoon_stats.balloon_low   = 0;\n\tballoon_stats.balloon_high  = 0;\n\tballoon_stats.total_pages   = balloon_stats.current_pages;\n\n \tballoon_stats.schedule_delay = 1;\n \tballoon_stats.max_schedule_delay = 32;\n \tballoon_stats.retry_count = 1;\n\tballoon_stats.max_retry_count = RETRY_UNLIMITED;\n \n #ifdef CONFIG_XEN_BALLOON_MEMORY_HOTPLUG\n \tset_online_page_callback(&xen_online_page);\n\tregister_memory_notifier(&xen_memory_nb);\n\tregister_sysctl_table(xen_root);\n#endif\n\n#ifdef CONFIG_XEN_PV\n\t{\n\t\tint i;\n\n\t\t/*\n\t\t * Initialize the balloon with pages from the extra memory\n\t\t * regions (see arch/x86/xen/setup.c).\n\t\t */\n\t\tfor (i = 0; i < XEN_EXTRA_MEM_MAX_REGIONS; i++)\n\t\t\tif (xen_extra_mem[i].n_pfns)\n\t\t\t\tballoon_add_region(xen_extra_mem[i].start_pfn,\n\t\t\t\t\t\t   xen_extra_mem[i].n_pfns);\n\t}\n#endif\n\n\t/* Init the xen-balloon driver. */\n\txen_balloon_init();\n\n\treturn 0;\n}\n", "target": 1, "idx": 182665}
{"func": "LocalFrame* FrameFetchContext::GetFrame() const {\n  DCHECK(!IsDetached());\n\n  if (!document_loader_)\n    return FrameOfImportsController();\n\n  LocalFrame* frame = document_loader_->GetFrame();\n  DCHECK(frame);\n  return frame;\n}\n", "target": 0, "idx": 151421}
{"func": "spnego_gss_context_time(\n\t\t\tOM_uint32\t*minor_status,\n\t\t\tconst gss_ctx_id_t context_handle,\n \t\t\tOM_uint32\t*time_rec)\n {\n \tOM_uint32 ret;\n \tret = gss_context_time(minor_status,\n\t\t\t    context_handle,\n \t\t\t    time_rec);\n \treturn (ret);\n }\n", "target": 1, "idx": 179825}
{"func": "static Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define RMT_EQUAL_RGB  1\n#define RMT_NONE  0\n#define RMT_RAW  2\n#define RT_STANDARD  1\n#define RT_ENCODED  2\n#define RT_FORMAT_RGB  3\n\n  typedef struct _SUNInfo\n  {\n    unsigned int\n      magic,\n      width,\n      height,\n      depth,\n      length,\n      type,\n      maptype,\n      maplength;\n  } SUNInfo;\n\n  Image\n    *image;\n\n  int\n    bit;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bytes_per_line,\n    extent,\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  SUNInfo\n    sun_info;\n\n  unsigned char\n    *sun_data,\n    *sun_pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read SUN raster header.\n  */\n  (void) ResetMagickMemory(&sun_info,0,sizeof(sun_info));\n  sun_info.magic=ReadBlobMSBLong(image);\n  do\n  {\n    /*\n      Verify SUN identifier.\n    */\n    if (sun_info.magic != 0x59a66a95)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    sun_info.width=ReadBlobMSBLong(image);\n    sun_info.height=ReadBlobMSBLong(image);\n    sun_info.depth=ReadBlobMSBLong(image);\n    sun_info.length=ReadBlobMSBLong(image);\n    sun_info.type=ReadBlobMSBLong(image);\n    sun_info.maptype=ReadBlobMSBLong(image);\n    sun_info.maplength=ReadBlobMSBLong(image);\n    extent=sun_info.height*sun_info.width;\n    if ((sun_info.height != 0) && (sun_info.width != extent/sun_info.height))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.type != RT_STANDARD) && (sun_info.type != RT_ENCODED) &&\n        (sun_info.type != RT_FORMAT_RGB))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.maptype == RMT_NONE) && (sun_info.maplength != 0))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.depth == 0) || (sun_info.depth > 32))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.maptype != RMT_NONE) && (sun_info.maptype != RMT_EQUAL_RGB) &&\n        (sun_info.maptype != RMT_RAW))\n      ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");\n    image->columns=sun_info.width;\n    image->rows=sun_info.height;\n    image->depth=sun_info.depth <= 8 ? sun_info.depth :\n      MAGICKCORE_QUANTUM_DEPTH;\n    if (sun_info.depth < 24)\n      {\n        size_t\n          one;\n\n        image->storage_class=PseudoClass;\n        image->colors=sun_info.maplength;\n        one=1;\n        if (sun_info.maptype == RMT_NONE)\n          image->colors=one << sun_info.depth;\n        if (sun_info.maptype == RMT_EQUAL_RGB)\n          image->colors=sun_info.maplength/3;\n      }\n    switch (sun_info.maptype)\n    {\n      case RMT_NONE:\n      {\n        if (sun_info.depth < 24)\n          {\n            /*\n              Create linear color ramp.\n            */\n            if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        break;\n      }\n      case RMT_EQUAL_RGB:\n      {\n        unsigned char\n          *sun_colormap;\n\n        /*\n          Read SUN raster colormap.\n        */\n        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        sun_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,\n          sizeof(*sun_colormap));\n        if (sun_colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        count=ReadBlob(image,image->colors,sun_colormap);\n        if (count != (ssize_t) image->colors)\n          ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n        for (i=0; i < (ssize_t) image->colors; i++)\n          image->colormap[i].red=(MagickRealType) ScaleCharToQuantum(\n            sun_colormap[i]);\n        count=ReadBlob(image,image->colors,sun_colormap);\n        if (count != (ssize_t) image->colors)\n          ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n        for (i=0; i < (ssize_t) image->colors; i++)\n          image->colormap[i].green=(MagickRealType) ScaleCharToQuantum(\n            sun_colormap[i]);\n        count=ReadBlob(image,image->colors,sun_colormap);\n        if (count != (ssize_t) image->colors)\n          ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n        for (i=0; i < (ssize_t) image->colors; i++)\n          image->colormap[i].blue=(MagickRealType) ScaleCharToQuantum(\n            sun_colormap[i]);\n        sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);\n        break;\n      }\n      case RMT_RAW:\n      {\n        unsigned char\n          *sun_colormap;\n\n        /*\n          Read SUN raster colormap.\n        */\n        sun_colormap=(unsigned char *) AcquireQuantumMemory(sun_info.maplength,\n          sizeof(*sun_colormap));\n        if (sun_colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        count=ReadBlob(image,sun_info.maplength,sun_colormap);\n        if (count != (ssize_t) sun_info.maplength)\n          ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n        sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);\n        break;\n      }\n      default:\n        ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");\n    }\n    image->alpha_trait=sun_info.depth == 32 ? BlendPixelTrait :\n      UndefinedPixelTrait;\n    image->columns=sun_info.width;\n    image->rows=sun_info.height;\n    if (image_info->ping != MagickFalse)\n      {\n        (void) CloseBlob(image);\n        return(GetFirstImageInList(image));\n      }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    if ((sun_info.length*sizeof(*sun_data))/sizeof(*sun_data) !=\n        sun_info.length || !sun_info.length)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    number_pixels=(MagickSizeType) image->columns*image->rows;\n     if ((sun_info.type != RT_ENCODED) && (sun_info.depth >= 8) &&\n         ((number_pixels*((sun_info.depth+7)/8)) > sun_info.length))\n       ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    sun_data=(unsigned char *) AcquireQuantumMemory((size_t) sun_info.length,\n      sizeof(*sun_data));\n     if (sun_data == (unsigned char *) NULL)\n       ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n     count=(ssize_t) ReadBlob(image,sun_info.length,sun_data);\n    if (count != (ssize_t) sun_info.length)\n      ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n    sun_pixels=sun_data;\n    bytes_per_line=0;\n    if (sun_info.type == RT_ENCODED)\n      {\n        size_t\n          height;\n\n        /*\n           Read run-length encoded raster pixels.\n         */\n         height=sun_info.height;\n        bytes_per_line=sun_info.width*sun_info.depth;\n         if ((height == 0) || (sun_info.width == 0) || (sun_info.depth == 0) ||\n             ((bytes_per_line/sun_info.depth) != sun_info.width))\n           ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        bytes_per_line+=15;\n        bytes_per_line<<=1;\n        if ((bytes_per_line >> 1) != (sun_info.width*sun_info.depth+15))\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        bytes_per_line>>=4;\n        sun_pixels=(unsigned char *) AcquireQuantumMemory(height,\n          bytes_per_line*sizeof(*sun_pixels));\n        if (sun_pixels == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) DecodeImage(sun_data,sun_info.length,sun_pixels,bytes_per_line*\n          height);\n        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n      }\n    /*\n      Convert SUN raster image to pixel packets.\n    */\n    p=sun_pixels;\n    if (sun_info.depth == 1)\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n        {\n          for (bit=7; bit >= 0; bit--)\n          {\n            SetPixelIndex(image,(Quantum) ((*p) & (0x01 << bit) ? 0x00 : 0x01),\n              q);\n            q+=GetPixelChannels(image);\n          }\n          p++;\n        }\n        if ((image->columns % 8) != 0)\n          {\n            for (bit=7; bit >= (int) (8-(image->columns % 8)); bit--)\n            {\n              SetPixelIndex(image,(Quantum) ((*p) & (0x01 << bit) ? 0x00 :\n                0x01),q);\n              q+=GetPixelChannels(image);\n            }\n            p++;\n          }\n        if ((((image->columns/8)+(image->columns % 8 ? 1 : 0)) % 2) != 0)\n          p++;\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n      }\n    else\n      if (image->storage_class == PseudoClass)\n        {\n          if (bytes_per_line == 0)\n            bytes_per_line=image->columns;\n          length=image->rows*(image->columns+image->columns % 2);\n          if (((sun_info.type == RT_ENCODED) &&\n               (length > (bytes_per_line*image->rows))) ||\n              ((sun_info.type != RT_ENCODED) && (length > sun_info.length)))\n            ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelIndex(image,*p++,q);\n              q+=GetPixelChannels(image);\n            }\n            if ((image->columns % 2) != 0)\n              p++;\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n      else\n        {\n          size_t\n            bytes_per_pixel;\n\n          bytes_per_pixel=3;\n          if (image->alpha_trait != UndefinedPixelTrait)\n            bytes_per_pixel++;\n          if (bytes_per_line == 0)\n            bytes_per_line=bytes_per_pixel*image->columns;\n          length=image->rows*(bytes_per_line+image->columns % 2);\n          if (((sun_info.type == RT_ENCODED) &&\n               (length > (bytes_per_line*image->rows))) ||\n              ((sun_info.type != RT_ENCODED) && (length > sun_info.length)))\n            ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              if (image->alpha_trait != UndefinedPixelTrait)\n                SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);\n              if (sun_info.type == RT_STANDARD)\n                {\n                  SetPixelBlue(image,ScaleCharToQuantum(*p++),q);\n                  SetPixelGreen(image,ScaleCharToQuantum(*p++),q);\n                  SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n                }\n              else\n                {\n                  SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n                  SetPixelGreen(image,ScaleCharToQuantum(*p++),q);\n                  SetPixelBlue(image,ScaleCharToQuantum(*p++),q);\n                }\n              if (image->colors != 0)\n                {\n                  SetPixelRed(image,ClampToQuantum(image->colormap[(ssize_t)\n                    GetPixelRed(image,q)].red),q);\n                  SetPixelGreen(image,ClampToQuantum(image->colormap[(ssize_t)\n                    GetPixelGreen(image,q)].green),q);\n                  SetPixelBlue(image,ClampToQuantum(image->colormap[(ssize_t)\n                    GetPixelBlue(image,q)].blue),q);\n                }\n              q+=GetPixelChannels(image);\n            }\n            if (((bytes_per_pixel*image->columns) % 2) != 0)\n              p++;\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n    if (image->storage_class == PseudoClass)\n      (void) SyncImage(image,exception);\n    sun_pixels=(unsigned char *) RelinquishMagickMemory(sun_pixels);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    sun_info.magic=ReadBlobMSBLong(image);\n    if (sun_info.magic == 0x59a66a95)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (sun_info.magic == 0x59a66a95);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n", "target": 1, "idx": 183298}
{"func": "u64 vmx_read_l1_tsc(struct kvm_vcpu *vcpu, u64 host_tsc)\n{\n\tu64 tsc_offset;\n\n\ttsc_offset = is_guest_mode(vcpu) ?\n\t\tto_vmx(vcpu)->nested.vmcs01_tsc_offset :\n\t\tvmcs_read64(TSC_OFFSET);\n\treturn host_tsc + tsc_offset;\n}\n", "target": 0, "idx": 37676}
{"func": "perform_gamma_threshold_tests(png_modifier *pm)\n{\n   png_byte colour_type = 0;\n   png_byte bit_depth = 0;\n unsigned int palette_number = 0;\n\n\n    /* Don't test more than one instance of each palette - it's pointless, in\n     * fact this test is somewhat excessive since libpng doesn't make this\n     * decision based on colour type or bit depth!\n     */\n   while (next_format(&colour_type, &bit_depth, &palette_number, 1/*gamma*/))\n      if (palette_number == 0)\n    {\n       double test_gamma = 1.0;\n       while (test_gamma >= .4)\n {\n /* There's little point testing the interlacing vs non-interlacing,\n          * but this can be set from the command line.\n          */\n         gamma_threshold_test(pm, colour_type, bit_depth, pm->interlace_type,\n            test_gamma, 1/test_gamma);\n         test_gamma *= .95;\n }\n\n /* And a special test for sRGB */\n      gamma_threshold_test(pm, colour_type, bit_depth, pm->interlace_type,\n .45455, 2.2);\n\n if (fail(pm))\n return;\n }\n\n }\n", "target": 1, "idx": 187704}
{"func": "static void ext4_ext_show_leaf(struct inode *inode, struct ext4_ext_path *path)\n{\n\tint depth = ext_depth(inode);\n\tstruct ext4_extent_header *eh;\n\tstruct ext4_extent *ex;\n\tint i;\n\n\tif (!path)\n\t\treturn;\n\n\teh = path[depth].p_hdr;\n\tex = EXT_FIRST_EXTENT(eh);\n\n\text_debug(\"Displaying leaf extents for inode %lu\\n\", inode->i_ino);\n\n\tfor (i = 0; i < le16_to_cpu(eh->eh_entries); i++, ex++) {\n\t\text_debug(\"%d:[%d]%d:%llu \", le32_to_cpu(ex->ee_block),\n\t\t\t  ext4_ext_is_uninitialized(ex),\n\t\t\t  ext4_ext_get_actual_len(ex), ext_pblock(ex));\n\t}\n\text_debug(\"\\n\");\n}\n", "target": 0, "idx": 57450}
{"func": "std::string OutOfProcessInstance::ShowFileSelectionDialog() {\n  NOTREACHED();\n  return std::string();\n}\n", "target": 0, "idx": 140663}
{"func": "void WebPluginDelegateProxy::UpdateGeometry(const gfx::Rect& window_rect,\n                                            const gfx::Rect& clip_rect) {\n  if (window_rect.width() < 0  || window_rect.width() > (1<<15) ||\n      window_rect.height() < 0 || window_rect.height() > (1<<15) ||\n      window_rect.width() * window_rect.height() > (8<<20)) {\n    return;\n  }\n\n  plugin_rect_ = window_rect;\n\n  bool bitmaps_changed = false;\n\n  PluginMsg_UpdateGeometry_Param param;\n#if defined(OS_MACOSX)\n  param.ack_key = -1;\n#endif\n\n  if (uses_shared_bitmaps_) {\n    if (!backing_store_canvas_.get() ||\n        (window_rect.width() != backing_store_canvas_->getDevice()->width() ||\n         window_rect.height() != backing_store_canvas_->getDevice()->height()))\n    {\n      bitmaps_changed = true;\n\n      bool needs_background_store = transparent_;\n#if defined(OS_MACOSX)\n      needs_background_store = false;\n      if (transport_store_.get()) {\n        param.ack_key = transport_store_->handle().fd;\n      }\n#endif\n\n      ResetWindowlessBitmaps();\n      if (!window_rect.IsEmpty()) {\n        if (!CreateSharedBitmap(&transport_store_, &transport_store_canvas_) ||\n#if defined(OS_WIN)\n            !CreateSharedBitmap(&backing_store_, &backing_store_canvas_) ||\n#else\n            !CreateLocalBitmap(&backing_store_, &backing_store_canvas_) ||\n#endif\n            (needs_background_store &&\n             !CreateSharedBitmap(&background_store_,\n                                 &background_store_canvas_))) {\n          DCHECK(false);\n          ResetWindowlessBitmaps();\n          return;\n        }\n      }\n    }\n  }\n\n  param.window_rect = window_rect;\n  param.clip_rect = clip_rect;\n  param.windowless_buffer = TransportDIB::DefaultHandleValue();\n  param.background_buffer = TransportDIB::DefaultHandleValue();\n  param.transparent = transparent_;\n\n#if defined(OS_POSIX)\n  if (bitmaps_changed)\n#endif\n  {\n    if (transport_store_.get())\n      param.windowless_buffer = transport_store_->handle();\n\n    if (background_store_.get())\n      param.background_buffer = background_store_->handle();\n  }\n\n  IPC::Message* msg;\n#if defined (OS_WIN)\n  if (UseSynchronousGeometryUpdates()) {\n    msg = new PluginMsg_UpdateGeometrySync(instance_id_, param);\n  } else  // NOLINT\n#endif\n  {\n    msg = new PluginMsg_UpdateGeometry(instance_id_, param);\n    msg->set_unblock(true);\n  }\n\n  Send(msg);\n}\n", "target": 0, "idx": 98820}
{"func": "struct inet6_ifaddr *ipv6_get_ifaddr(struct net *net, const struct in6_addr *addr,\n\t\t\t\t     struct net_device *dev, int strict)\n{\n\tstruct inet6_ifaddr *ifp, *result = NULL;\n\tunsigned int hash = inet6_addr_hash(addr);\n\n\trcu_read_lock_bh();\n\thlist_for_each_entry_rcu_bh(ifp, &inet6_addr_lst[hash], addr_lst) {\n\t\tif (!net_eq(dev_net(ifp->idev->dev), net))\n\t\t\tcontinue;\n\t\tif (ipv6_addr_equal(&ifp->addr, addr)) {\n\t\t\tif (dev == NULL || ifp->idev->dev == dev ||\n\t\t\t    !(ifp->scope&(IFA_LINK|IFA_HOST) || strict)) {\n\t\t\t\tresult = ifp;\n\t\t\t\tin6_ifa_hold(ifp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock_bh();\n\n\treturn result;\n}\n", "target": 0, "idx": 41872}
{"func": "static int muscle_list_files(sc_card_t *card, u8 *buf, size_t bufLen)\n{\n\tmuscle_private_t* priv = MUSCLE_DATA(card);\n\tmscfs_t *fs = priv->fs;\n\tint x;\n\tint count = 0;\n\n \tmscfs_check_cache(priv->fs);\n \n \tfor(x = 0; x < fs->cache.size; x++) {\n\t\tu8* oid= fs->cache.array[x].objectId.id;\n \t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,\n \t\t\t\"FILE: %02X%02X%02X%02X\\n\",\n \t\t\toid[0],oid[1],oid[2],oid[3]);\n\t\tif(0 == memcmp(fs->currentPath, oid, 2)) {\n\t\t\tbuf[0] = oid[2];\n \t\t\tbuf[1] = oid[3];\n \t\t\tif(buf[0] == 0x00 && buf[1] == 0x00) continue; /* No directories/null names outside of root */\n \t\t\tbuf += 2;\n\t\t\tcount+=2;\n \t\t}\n \t}\n \treturn count;\n}\n", "target": 1, "idx": 182246}
{"func": "status_t OMXNodeInstance::updateGraphicBufferInMeta(\n        OMX_U32 portIndex, const sp<GraphicBuffer>& graphicBuffer,\n        OMX::buffer_id buffer) {\n Mutex::Autolock autoLock(mLock);\n    OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer, portIndex);\n\n     return updateGraphicBufferInMeta_l(\n             portIndex, graphicBuffer, buffer, header,\n            portIndex == kPortIndexOutput /* updateCodecBuffer */);\n }\n", "target": 1, "idx": 188163}
{"func": " OTRBrowserContextImpl::OTRBrowserContextImpl(\n     BrowserContextImpl* original,\n     BrowserContextIODataImpl* original_io_data)\n     : BrowserContext(new OTRBrowserContextIODataImpl(original_io_data)),\n      original_context_(original),\n      weak_ptr_factory_(this) {\n   BrowserContextDependencyManager::GetInstance()\n       ->CreateBrowserContextServices(this);\n }\n", "target": 1, "idx": 178588}
{"func": "ParseNameValue(const char * buffer, int bufsize,\n                struct NameValueParserData * data)\n {\n \tstruct xmlparser parser;\n\tdata->l_head = NULL;\n\tdata->portListing = NULL;\n\tdata->portListingLength = 0;\n \t/* init xmlparser object */\n \tparser.xmlstart = buffer;\n \tparser.xmlsize = bufsize;\n\tparser.data = data;\n\tparser.starteltfunc = NameValueParserStartElt;\n\tparser.endeltfunc = NameValueParserEndElt;\n\tparser.datafunc = NameValueParserGetData;\n\tparser.attfunc = 0;\n\tparsexml(&parser);\n}\n", "target": 1, "idx": 182540}
{"func": "void CheckFetchHandlerOfInstalledServiceWorker(\n    ServiceWorkerContext::CheckHasServiceWorkerCallback callback,\n    scoped_refptr<ServiceWorkerRegistration> registration) {\n  ServiceWorkerVersion* preferred_version =\n      registration->waiting_version() ? registration->waiting_version()\n                                      : registration->active_version();\n\n  DCHECK(preferred_version);\n\n  ServiceWorkerVersion::FetchHandlerExistence existence =\n      preferred_version->fetch_handler_existence();\n\n  DCHECK_NE(existence, ServiceWorkerVersion::FetchHandlerExistence::UNKNOWN);\n\n  std::move(callback).Run(\n      existence == ServiceWorkerVersion::FetchHandlerExistence::EXISTS\n          ? ServiceWorkerCapability::SERVICE_WORKER_WITH_FETCH_HANDLER\n          : ServiceWorkerCapability::SERVICE_WORKER_NO_FETCH_HANDLER);\n}\n", "target": 0, "idx": 152121}
{"func": "static int handle_wrmsr(struct kvm_vcpu *vcpu)\n{\n\tstruct msr_data msr;\n\tu32 ecx = vcpu->arch.regs[VCPU_REGS_RCX];\n\tu64 data = (vcpu->arch.regs[VCPU_REGS_RAX] & -1u)\n\t\t| ((u64)(vcpu->arch.regs[VCPU_REGS_RDX] & -1u) << 32);\n\n \tmsr.data = data;\n \tmsr.index = ecx;\n \tmsr.host_initiated = false;\n\tif (vmx_set_msr(vcpu, &msr) != 0) {\n \t\ttrace_kvm_msr_write_ex(ecx, data);\n \t\tkvm_inject_gp(vcpu, 0);\n \t\treturn 1;\n\t}\n\n\ttrace_kvm_msr_write(ecx, data);\n\tskip_emulated_instruction(vcpu);\n\treturn 1;\n}\n", "target": 1, "idx": 179521}
{"func": "static int spl_filesystem_file_read(spl_filesystem_object *intern, int silent TSRMLS_DC) /* {{{ */\n{\n\tchar *buf;\n\tsize_t line_len = 0;\n \tlong line_add = (intern->u.file.current_line || intern->u.file.current_zval) ? 1 : 0;\n \n \tspl_filesystem_file_free_line(intern TSRMLS_CC);\n \tif (php_stream_eof(intern->u.file.stream)) {\n \t\tif (!silent) {\n \t\t\tzend_throw_exception_ex(spl_ce_RuntimeException, 0 TSRMLS_CC, \"Cannot read from file %s\", intern->file_name);\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tif (intern->u.file.max_line_len > 0) {\n\t\tbuf = safe_emalloc((intern->u.file.max_line_len + 1), sizeof(char), 0);\n\t\tif (php_stream_get_line(intern->u.file.stream, buf, intern->u.file.max_line_len + 1, &line_len) == NULL) {\n\t\t\tefree(buf);\n\t\t\tbuf = NULL;\n\t\t} else {\n\t\t\tbuf[line_len] = '\\0';\n\t\t}\n\t} else {\n\t\tbuf = php_stream_get_line(intern->u.file.stream, NULL, 0, &line_len);\n\t}\n\n\tif (!buf) {\n\t\tintern->u.file.current_line = estrdup(\"\");\n\t\tintern->u.file.current_line_len = 0;\n\t} else {\n\t\tif (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_DROP_NEW_LINE)) {\n \t\t\tline_len = strcspn(buf, \"\\r\\n\");\n \t\t\tbuf[line_len] = '\\0';\n \t\t}\n \t\tintern->u.file.current_line = buf;\n \t\tintern->u.file.current_line_len = line_len;\n \t}\n\tintern->u.file.current_line_num += line_add;\n\n\treturn SUCCESS;\n} /* }}} */\n", "target": 1, "idx": 180248}
{"func": "static Image *ReadHALDImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  size_t\n    cube_size,\n    level;\n\n  ssize_t\n    y;\n\n  /*\n    Create HALD color lookup table image.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  level=0;\n  if (*image_info->filename != '\\0')\n    level=StringToUnsignedLong(image_info->filename);\n  if (level < 2)\n    level=8;\n  status=MagickTrue;\n   cube_size=level*level;\n   image->columns=(size_t) (level*cube_size);\n   image->rows=(size_t) (level*cube_size);\n   for (y=0; y < (ssize_t) image->rows; y+=(ssize_t) level)\n   {\n     ssize_t\n      blue,\n      green,\n      red;\n\n    register PixelPacket\n      *restrict q;\n \n     if (status == MagickFalse)\n       continue;\n    q=QueueAuthenticPixels(image,0,y,image->columns,(size_t) level,\n      exception);\n     if (q == (PixelPacket *) NULL)\n       {\n         status=MagickFalse;\n        continue;\n      }\n    blue=y/(ssize_t) level;\n    for (green=0; green < (ssize_t) cube_size; green++)\n    {\n      for (red=0; red < (ssize_t) cube_size; red++)\n      {\n        SetPixelRed(q,ClampToQuantum((MagickRealType)\n          (QuantumRange*red/(cube_size-1.0))));\n        SetPixelGreen(q,ClampToQuantum((MagickRealType)\n          (QuantumRange*green/(cube_size-1.0))));\n        SetPixelBlue(q,ClampToQuantum((MagickRealType)\n          (QuantumRange*blue/(cube_size-1.0))));\n        SetPixelOpacity(q,OpaqueOpacity);\n        q++;\n      }\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  return(GetFirstImageInList(image));\n}\n", "target": 1, "idx": 181741}
{"func": "alloc_strvec_quoted_escaped(char *src)\n{\n\tchar *token;\n\tvector_t *strvec;\n\tchar cur_quote = 0;\n\tchar *ofs_op;\n\tchar *op_buf;\n\tchar *ofs, *ofs1;\n\tchar op_char;\n\n\tif (!src) {\n\t\tif (!buf_extern)\n\t\t\treturn NULL;\n\t\tsrc = buf_extern;\n\t}\n\n\t/* Create a vector and alloc each command piece */\n\tstrvec = vector_alloc();\n\top_buf = MALLOC(MAXBUF);\n\n\tofs = src;\n\twhile (*ofs) {\n\t\t/* Find the next 'word' */\n\t\tofs += strspn(ofs, WHITE_SPACE);\n\t\tif (!*ofs)\n\t\t\tbreak;\n\n\t\tofs_op = op_buf;\n\n\t\twhile (*ofs) {\n\t\t\tofs1 = strpbrk(ofs, cur_quote == '\"' ? \"\\\"\\\\\" : cur_quote == '\\'' ? \"'\\\\\" : WHITE_SPACE_STR \"'\\\"\\\\\");\n\n\t\t\tif (!ofs1) {\n\t\t\t\tsize_t len;\n\t\t\t\tif (cur_quote) {\n\t\t\t\t\treport_config_error(CONFIG_UNMATCHED_QUOTE, \"String '%s': missing terminating %c\", src, cur_quote);\n\t\t\t\t\tgoto err_exit;\n\t\t\t\t}\n\t\t\t\tstrcpy(ofs_op, ofs);\n\t\t\t\tlen =  strlen(ofs);\n\t\t\t\tofs += len;\n\t\t\t\tofs_op += len;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Save the wanted text */\n\t\t\tstrncpy(ofs_op, ofs, ofs1 - ofs);\n\t\t\tofs_op += ofs1 - ofs;\n\t\t\tofs = ofs1;\n\n\t\t\tif (*ofs == '\\\\') {\n\t\t\t\t/* It is a '\\' */\n\t\t\t\tofs++;\n\n\t\t\t\tif (!*ofs) {\n\t\t\t\t\tlog_message(LOG_INFO, \"Missing escape char at end: '%s'\", src);\n\t\t\t\t\tgoto err_exit;\n\t\t\t\t}\n\n\t\t\t\tif (*ofs == 'x' && isxdigit(ofs[1])) {\n\t\t\t\t\top_char = 0;\n\t\t\t\t\tofs++;\n\t\t\t\t\twhile (isxdigit(*ofs)) {\n\t\t\t\t\t\top_char <<= 4;\n\t\t\t\t\t\top_char |= isdigit(*ofs) ? *ofs - '0' : (10 + *ofs - (isupper(*ofs)  ? 'A' : 'a'));\n\t\t\t\t\t\tofs++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (*ofs == 'c' && ofs[1]) {\n\t\t\t\t\top_char = *++ofs & 0x1f;\t/* Convert to control character */\n\t\t\t\t\tofs++;\n\t\t\t\t}\n\t\t\t\telse if (*ofs >= '0' && *ofs <= '7') {\n\t\t\t\t\top_char = *ofs++ - '0';\n\t\t\t\t\tif (*ofs >= '0' && *ofs <= '7') {\n\t\t\t\t\t\top_char <<= 3;\n\t\t\t\t\t\top_char += *ofs++ - '0';\n\t\t\t\t\t}\n\t\t\t\t\tif (*ofs >= '0' && *ofs <= '7') {\n\t\t\t\t\t\top_char <<= 3;\n\t\t\t\t\t\top_char += *ofs++ - '0';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tswitch (*ofs) {\n\t\t\t\t\tcase 'a':\n\t\t\t\t\t\top_char = '\\a';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'b':\n\t\t\t\t\t\top_char = '\\b';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'E':\n\t\t\t\t\t\top_char = 0x1b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'f':\n\t\t\t\t\t\top_char = '\\f';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'n':\n\t\t\t\t\t\top_char = '\\n';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'r':\n\t\t\t\t\t\top_char = '\\r';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 't':\n\t\t\t\t\t\top_char = '\\t';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'v':\n\t\t\t\t\t\top_char = '\\v';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault: /* \\\"'  */\n\t\t\t\t\t\top_char = *ofs;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tofs++;\n\t\t\t\t}\n\n\t\t\t\t*ofs_op++ = op_char;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (cur_quote) {\n\t\t\t\t/* It's the close quote */\n\t\t\t\tofs++;\n\t\t\t\tcur_quote = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (*ofs == '\"' || *ofs == '\\'') {\n\t\t\t\tcur_quote = *ofs++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\ttoken = MALLOC(ofs_op - op_buf + 1);\n\t\tmemcpy(token, op_buf, ofs_op - op_buf);\n\t\ttoken[ofs_op - op_buf] = '\\0';\n\n\t\t/* Alloc & set the slot */\n\t\tvector_alloc_slot(strvec);\n\t\tvector_set_slot(strvec, token);\n\t}\n\n\tFREE(op_buf);\n\n\tif (!vector_size(strvec)) {\n\t\tfree_strvec(strvec);\n\t\treturn NULL;\n\t}\n\n\treturn strvec;\n\nerr_exit:\n\tfree_strvec(strvec);\n\tFREE(op_buf);\n\treturn NULL;\n}\n", "target": 0, "idx": 76145}
{"func": "int regulator_allow_bypass(struct regulator *regulator, bool enable)\n{\n\tstruct regulator_dev *rdev = regulator->rdev;\n\tint ret = 0;\n\n\tif (!rdev->desc->ops->set_bypass)\n\t\treturn 0;\n\n\tif (rdev->constraints &&\n\t    !(rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_BYPASS))\n\t\treturn 0;\n\n\tmutex_lock(&rdev->mutex);\n\n\tif (enable && !regulator->bypass) {\n\t\trdev->bypass_count++;\n\n\t\tif (rdev->bypass_count == rdev->open_count) {\n\t\t\tret = rdev->desc->ops->set_bypass(rdev, enable);\n\t\t\tif (ret != 0)\n\t\t\t\trdev->bypass_count--;\n\t\t}\n\n\t} else if (!enable && regulator->bypass) {\n\t\trdev->bypass_count--;\n\n\t\tif (rdev->bypass_count != rdev->open_count) {\n\t\t\tret = rdev->desc->ops->set_bypass(rdev, enable);\n\t\t\tif (ret != 0)\n\t\t\t\trdev->bypass_count++;\n\t\t}\n\t}\n\n\tif (ret == 0)\n\t\tregulator->bypass = enable;\n\n\tmutex_unlock(&rdev->mutex);\n\n\treturn ret;\n}\n", "target": 0, "idx": 74478}
{"func": "   void RunSignBiasCheck() {\n     ACMRandom rnd(ACMRandom::DeterministicSeed());\n    DECLARE_ALIGNED_ARRAY(16, int16_t, test_input_block, 64);\n    DECLARE_ALIGNED_ARRAY(16, int16_t, test_output_block, 64);\n     int count_sign_block[64][2];\n     const int count_test_block = 100000;\n \n    memset(count_sign_block, 0, sizeof(count_sign_block));\n\n\n     for (int i = 0; i < count_test_block; ++i) {\n       for (int j = 0; j < 64; ++j)\n        test_input_block[j] = rnd.Rand8() - rnd.Rand8();\n      REGISTER_STATE_CHECK(\n           RunFwdTxfm(test_input_block, test_output_block, pitch_));\n \n       for (int j = 0; j < 64; ++j) {\n if (test_output_block[j] < 0)\n ++count_sign_block[j][0];\n else if (test_output_block[j] > 0)\n ++count_sign_block[j][1];\n }\n }\n\n \n     for (int j = 0; j < 64; ++j) {\n       const int diff = abs(count_sign_block[j][0] - count_sign_block[j][1]);\n      const int max_diff = 1125;\n      EXPECT_LT(diff, max_diff)\n           << \"Error: 8x8 FDCT/FHT has a sign bias > \"\n           << 1. * max_diff / count_test_block * 100 << \"%\"\n           << \" for input range [-255, 255] at index \" << j\n << \" count0: \" << count_sign_block[j][0]\n << \" count1: \" << count_sign_block[j][1]\n << \" diff: \" << diff;\n }\n\n\n     memset(count_sign_block, 0, sizeof(count_sign_block));\n \n     for (int i = 0; i < count_test_block; ++i) {\n       for (int j = 0; j < 64; ++j)\n        test_input_block[j] = (rnd.Rand8() >> 4) - (rnd.Rand8() >> 4);\n      REGISTER_STATE_CHECK(\n           RunFwdTxfm(test_input_block, test_output_block, pitch_));\n \n       for (int j = 0; j < 64; ++j) {\n if (test_output_block[j] < 0)\n ++count_sign_block[j][0];\n else if (test_output_block[j] > 0)\n ++count_sign_block[j][1];\n }\n }\n\n \n     for (int j = 0; j < 64; ++j) {\n       const int diff = abs(count_sign_block[j][0] - count_sign_block[j][1]);\n      const int max_diff = 10000;\n      EXPECT_LT(diff, max_diff)\n          << \"Error: 4x4 FDCT/FHT has a sign bias > \"\n           << 1. * max_diff / count_test_block * 100 << \"%\"\n           << \" for input range [-15, 15] at index \" << j\n           << \" count0: \" << count_sign_block[j][0]\n << \" count1: \" << count_sign_block[j][1]\n << \" diff: \" << diff;\n }\n }\n", "target": 1, "idx": 188583}
{"func": "StyleResolver::StyleResolver(Document& document)\n    : m_document(document)\n    , m_fontSelector(CSSFontSelector::create(&document))\n    , m_viewportStyleResolver(ViewportStyleResolver::create(&document))\n    , m_styleResourceLoader(document.fetcher())\n     , m_styleResolverStatsSequence(0)\n     , m_accessCount(0)\n {\n    Element* root = document.documentElement();\n     m_fontSelector->registerForInvalidationCallbacks(this);\n \n    CSSDefaultStyleSheets::initDefaultStyle(root);\n \n     FrameView* view = document.view();\n     if (view)\n         m_medium = adoptPtr(new MediaQueryEvaluator(view->mediaType()));\n     else\n         m_medium = adoptPtr(new MediaQueryEvaluator(\"all\"));\n \n     if (root)\n         m_rootDefaultStyle = styleForElement(root, 0, DisallowStyleSharing, MatchOnlyUserAgentRules);\n \n    if (m_rootDefaultStyle && view)\n        m_medium = adoptPtr(new MediaQueryEvaluator(view->mediaType(), &view->frame(), m_rootDefaultStyle.get()));\n\n    m_styleTree.clear();\n\n    initWatchedSelectorRules(CSSSelectorWatch::from(document).watchedCallbackSelectors());\n\n#if ENABLE(SVG_FONTS)\n    if (document.svgExtensions()) {\n        const HashSet<SVGFontFaceElement*>& svgFontFaceElements = document.svgExtensions()->svgFontFaceElements();\n        HashSet<SVGFontFaceElement*>::const_iterator end = svgFontFaceElements.end();\n        for (HashSet<SVGFontFaceElement*>::const_iterator it = svgFontFaceElements.begin(); it != end; ++it)\n            fontSelector()->addFontFaceRule((*it)->fontFaceRule());\n    }\n#endif\n\n    document.styleEngine()->appendActiveAuthorStyleSheets(this);\n}\n", "target": 1, "idx": 185287}
{"func": "static void update_cfs_group(struct sched_entity *se)\n{\n\tstruct cfs_rq *gcfs_rq = group_cfs_rq(se);\n\tlong shares, runnable;\n\n\tif (!gcfs_rq)\n\t\treturn;\n\n\tif (throttled_hierarchy(gcfs_rq))\n\t\treturn;\n\n#ifndef CONFIG_SMP\n\trunnable = shares = READ_ONCE(gcfs_rq->tg->shares);\n\n\tif (likely(se->load.weight == shares))\n\t\treturn;\n#else\n\tshares   = calc_group_shares(gcfs_rq);\n\trunnable = calc_group_runnable(gcfs_rq, shares);\n#endif\n\n\treweight_entity(cfs_rq_of(se), se, shares, runnable);\n}\n", "target": 0, "idx": 92747}
{"func": " bool ExtensionService::IsDownloadFromGallery(const GURL& download_url,\n                                              const GURL& referrer_url) {\n  if (IsDownloadFromMiniGallery(download_url) &&\n      StartsWithASCII(referrer_url.spec(),\n                      extension_urls::kMiniGalleryBrowsePrefix, false)) {\n    return true;\n  }\n\n  const Extension* download_extension = GetExtensionByWebExtent(download_url);\n  const Extension* referrer_extension = GetExtensionByWebExtent(referrer_url);\n  const Extension* webstore_app = GetWebStoreApp();\n\n   bool referrer_valid = (referrer_extension == webstore_app);\n   bool download_valid = (download_extension == webstore_app);\n \n   GURL store_url =\n       GURL(CommandLine::ForCurrentProcess()->GetSwitchValueASCII(\n           switches::kAppsGalleryURL));\n  if (!store_url.is_empty()) {\n    std::string store_tld =\n        net::RegistryControlledDomainService::GetDomainAndRegistry(store_url);\n    if (!referrer_valid) {\n      std::string referrer_tld =\n          net::RegistryControlledDomainService::GetDomainAndRegistry(\n              referrer_url);\n      referrer_valid = referrer_url.is_empty() || (referrer_tld == store_tld);\n    }\n\n    if (!download_valid) {\n      std::string download_tld =\n          net::RegistryControlledDomainService::GetDomainAndRegistry(\n              download_url);\n\n      download_valid = (download_tld == store_tld);\n    }\n  }\n\n  return (referrer_valid && download_valid);\n}\n", "target": 1, "idx": 183777}
{"func": " MagickExport const char *GetMagickFeatures(void)\n {\n   return \"DPC\"\n#if defined(MAGICKCORE_BUILD_MODULES) || defined(_DLL)\n  \" Modules\"\n #endif\n #if defined(MAGICKCORE_HDRI_SUPPORT)\n   \" HDRI\"\n #endif\n #if defined(MAGICKCORE_OPENCL_SUPPORT)\n   \" OpenCL\"\n #endif\n #if defined(MAGICKCORE_OPENMP_SUPPORT)\n   \" OpenMP\"\n #endif\n   ;\n }\n", "target": 1, "idx": 182033}
{"func": "_gcry_cipher_gcm_encrypt (gcry_cipher_hd_t c,\n                          byte *outbuf, size_t outbuflen,\n                          const byte *inbuf, size_t inbuflen)\n{\n  static const unsigned char zerobuf[MAX_BLOCKSIZE];\n  gcry_err_code_t err;\n\n  if (c->spec->blocksize != GCRY_GCM_BLOCK_LEN)\n    return GPG_ERR_CIPHER_ALGO;\n  if (outbuflen < inbuflen)\n    return GPG_ERR_BUFFER_TOO_SHORT;\n  if (c->u_mode.gcm.datalen_over_limits)\n    return GPG_ERR_INV_LENGTH;\n  if (c->marks.tag\n      || c->u_mode.gcm.ghash_data_finalized\n      || !c->u_mode.gcm.ghash_fn)\n    return GPG_ERR_INV_STATE;\n\n  if (!c->marks.iv)\n    _gcry_cipher_gcm_setiv (c, zerobuf, GCRY_GCM_BLOCK_LEN);\n\n  if (c->u_mode.gcm.disallow_encryption_because_of_setiv_in_fips_mode)\n    return GPG_ERR_INV_STATE;\n\n  if (!c->u_mode.gcm.ghash_aad_finalized)\n    {\n      /* Start of encryption marks end of AAD stream. */\n      do_ghash_buf(c, c->u_mode.gcm.u_tag.tag, NULL, 0, 1);\n      c->u_mode.gcm.ghash_aad_finalized = 1;\n    }\n\n  gcm_bytecounter_add(c->u_mode.gcm.datalen, inbuflen);\n  if (!gcm_check_datalen(c->u_mode.gcm.datalen))\n    {\n      c->u_mode.gcm.datalen_over_limits = 1;\n      return GPG_ERR_INV_LENGTH;\n    }\n\n  while (inbuflen)\n    {\n      size_t currlen = inbuflen;\n\n      /* Since checksumming is done after encryption, process input in 24KiB\n       * chunks to keep data loaded in L1 cache for checksumming. */\n      if (currlen > 24 * 1024)\n\tcurrlen = 24 * 1024;\n\n      err = gcm_ctr_encrypt(c, outbuf, outbuflen, inbuf, currlen);\n      if (err != 0)\n\treturn err;\n\n      do_ghash_buf(c, c->u_mode.gcm.u_tag.tag, outbuf, currlen, 0);\n\n      outbuf += currlen;\n      inbuf += currlen;\n      outbuflen -= currlen;\n      inbuflen -= currlen;\n    }\n\n  return 0;\n}\n", "target": 0, "idx": 89604}
{"func": "ModuleExport void UnregisterXWDImage(void)\n{\n  (void) UnregisterMagickInfo(\"XWD\");\n}\n", "target": 0, "idx": 88483}
{"func": "bool JSTestObjOwner::isReachableFromOpaqueRoots(JSC::Handle<JSC::Unknown> handle, void*, SlotVisitor& visitor)\n{\n    JSTestObj* jsTestObj = jsCast<JSTestObj*>(handle.get().asCell());\n    if (!isObservable(jsTestObj))\n        return false;\n    UNUSED_PARAM(visitor);\n    return false;\n}\n", "target": 0, "idx": 106085}
{"func": "static int pppoe_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t  struct msghdr *m, size_t total_len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint error = 0;\n\n\tif (sk->sk_state & PPPOX_BOUND) {\n\t\terror = -EIO;\n\t\tgoto end;\n\t}\n\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\tflags & MSG_DONTWAIT, &error);\n \tif (error < 0)\n \t\tgoto end;\n \n\tm->msg_namelen = 0;\n \tif (skb) {\n \t\ttotal_len = min_t(size_t, total_len, skb->len);\n \t\terror = skb_copy_datagram_iovec(skb, 0, m->msg_iov, total_len);\n\t\tif (error == 0) {\n\t\t\tconsume_skb(skb);\n\t\t\treturn total_len;\n\t\t}\n\t}\n\n\tkfree_skb(skb);\nend:\n\treturn error;\n}\n", "target": 1, "idx": 179659}
{"func": "  void AddServiceRequestHandlerOnIoThread(\n      const std::string& name,\n       const ServiceRequestHandler& handler) {\n     DCHECK(io_thread_checker_.CalledOnValidThread());\n     auto result = request_handlers_.insert(std::make_pair(name, handler));\n    DCHECK(result.second);\n   }\n", "target": 1, "idx": 185818}
{"func": "  Ins_IP( TT_ExecContext  exc )\n  {\n    FT_F26Dot6  old_range, cur_range;\n    FT_Vector*  orus_base;\n    FT_Vector*  cur_base;\n    FT_Int      twilight;\n\n\n    if ( exc->top < exc->GS.loop )\n    {\n      if ( exc->pedantic_hinting )\n        exc->error = FT_THROW( Invalid_Reference );\n      goto Fail;\n    }\n\n    /*\n     * We need to deal in a special way with the twilight zone.\n     * Otherwise, by definition, the value of exc->twilight.orus[n] is (0,0),\n     * for every n.\n     */\n    twilight = ( exc->GS.gep0 == 0 ||\n                 exc->GS.gep1 == 0 ||\n                 exc->GS.gep2 == 0 );\n\n    if ( BOUNDS( exc->GS.rp1, exc->zp0.n_points ) )\n    {\n      if ( exc->pedantic_hinting )\n        exc->error = FT_THROW( Invalid_Reference );\n      goto Fail;\n    }\n\n    if ( twilight )\n      orus_base = &exc->zp0.org[exc->GS.rp1];\n    else\n      orus_base = &exc->zp0.orus[exc->GS.rp1];\n\n    cur_base = &exc->zp0.cur[exc->GS.rp1];\n\n    /* XXX: There are some glyphs in some braindead but popular */\n    /*      fonts out there (e.g. [aeu]grave in monotype.ttf)   */\n    /*      calling IP[] with bad values of rp[12].             */\n    /*      Do something sane when this odd thing happens.      */\n    if ( BOUNDS( exc->GS.rp1, exc->zp0.n_points ) ||\n         BOUNDS( exc->GS.rp2, exc->zp1.n_points ) )\n    {\n      old_range = 0;\n      cur_range = 0;\n    }\n    else\n    {\n      if ( twilight )\n        old_range = DUALPROJ( &exc->zp1.org[exc->GS.rp2], orus_base );\n      else if ( exc->metrics.x_scale == exc->metrics.y_scale )\n        old_range = DUALPROJ( &exc->zp1.orus[exc->GS.rp2], orus_base );\n      else\n      {\n        FT_Vector  vec;\n\n\n        vec.x = FT_MulFix( SUB_LONG( exc->zp1.orus[exc->GS.rp2].x,\n                                     orus_base->x ),\n                           exc->metrics.x_scale );\n        vec.y = FT_MulFix( SUB_LONG( exc->zp1.orus[exc->GS.rp2].y,\n                                     orus_base->y ),\n                           exc->metrics.y_scale );\n\n        old_range = FAST_DUALPROJ( &vec );\n      }\n\n      cur_range = PROJECT( &exc->zp1.cur[exc->GS.rp2], cur_base );\n    }\n\n    for ( ; exc->GS.loop > 0; exc->GS.loop-- )\n    {\n      FT_UInt     point = (FT_UInt)exc->stack[--exc->args];\n      FT_F26Dot6  org_dist, cur_dist, new_dist;\n\n\n      /* check point bounds */\n      if ( BOUNDS( point, exc->zp2.n_points ) )\n      {\n        if ( exc->pedantic_hinting )\n        {\n          exc->error = FT_THROW( Invalid_Reference );\n          return;\n        }\n        continue;\n      }\n\n      if ( twilight )\n        org_dist = DUALPROJ( &exc->zp2.org[point], orus_base );\n      else if ( exc->metrics.x_scale == exc->metrics.y_scale )\n        org_dist = DUALPROJ( &exc->zp2.orus[point], orus_base );\n      else\n      {\n        FT_Vector  vec;\n\n\n        vec.x = FT_MulFix( SUB_LONG( exc->zp2.orus[point].x,\n                                     orus_base->x ),\n                           exc->metrics.x_scale );\n        vec.y = FT_MulFix( SUB_LONG( exc->zp2.orus[point].y,\n                                     orus_base->y ),\n                           exc->metrics.y_scale );\n\n        org_dist = FAST_DUALPROJ( &vec );\n      }\n\n      cur_dist = PROJECT( &exc->zp2.cur[point], cur_base );\n\n      if ( org_dist )\n      {\n        if ( old_range )\n          new_dist = FT_MulDiv( org_dist, cur_range, old_range );\n        else\n        {\n          /* This is the same as what MS does for the invalid case:  */\n          /*                                                         */\n          /*   delta = (Original_Pt - Original_RP1) -                */\n          /*           (Current_Pt - Current_RP1)         ;          */\n          /*                                                         */\n          /* In FreeType speak:                                      */\n          /*                                                         */\n          /*   delta = org_dist - cur_dist          .                */\n          /*                                                         */\n          /* We move `point' by `new_dist - cur_dist' after leaving  */\n          /* this block, thus we have                                */\n          /*                                                         */\n          /*   new_dist - cur_dist = delta                   ,       */\n          /*   new_dist - cur_dist = org_dist - cur_dist     ,       */\n          /*              new_dist = org_dist                .       */\n\n          new_dist = org_dist;\n        }\n      }\n      else\n        new_dist = 0;\n\n      exc->func_move( exc,\n                      &exc->zp2,\n                      (FT_UShort)point,\n                      SUB_LONG( new_dist, cur_dist ) );\n    }\n\n  Fail:\n    exc->GS.loop = 1;\n    exc->new_top = exc->args;\n  }\n", "target": 0, "idx": 10614}
{"func": "SProcRenderQueryPictFormats(ClientPtr client)\n{\n    REQUEST(xRenderQueryPictFormatsReq);\n    REQUEST_SIZE_MATCH(xRenderQueryPictFormatsReq);\n    swaps(&stuff->length);\n    return (*ProcRenderVector[stuff->renderReqType]) (client);\n}\n", "target": 0, "idx": 17626}
{"func": "check_v8086_mode(struct pt_regs *regs, unsigned long address,\n\t\t struct task_struct *tsk)\n{\n}\n", "target": 0, "idx": 25931}
{"func": " ActionReply Smb4KMountHelper::mount(const QVariantMap &args)\n {\n   ActionReply reply;\n   reply.addData(\"mh_mountpoint\", args[\"mh_mountpoint\"]);\n  command << args[\"mh_unc\"].toString();\n  command << args[\"mh_mountpoint\"].toString();\n  command << args[\"mh_options\"].toStringList();\n#elif defined(Q_OS_FREEBSD) || defined(Q_OS_NETBSD)\n  command << args[\"mh_command\"].toString();\n  command << args[\"mh_options\"].toStringList();\n  command << args[\"mh_unc\"].toString();\n  command << args[\"mh_mountpoint\"].toString();\n#else\n#endif\n  proc.setProgram(command);\n\n  proc.start();\n\n  if (proc.waitForStarted(-1))\n  {\n    bool user_kill = false;\n\n   QStringList command;\n #if defined(Q_OS_LINUX)\n  command << args[\"mh_command\"].toString();\n   command << args[\"mh_unc\"].toString();\n   command << args[\"mh_mountpoint\"].toString();\n   command << args[\"mh_options\"].toStringList();\n #elif defined(Q_OS_FREEBSD) || defined(Q_OS_NETBSD)\n  command << args[\"mh_command\"].toString();\n   command << args[\"mh_options\"].toStringList();\n   command << args[\"mh_unc\"].toString();\n   command << args[\"mh_mountpoint\"].toString();\n      {\n      }\n\n      if (HelperSupport::isStopped())\n      {\n        proc.kill();\n        user_kill = true;\n        break;\n      }\n      else\n      {\n      }\n    }\n\n    if (proc.exitStatus() == KProcess::CrashExit)\n    {\n      if (!user_kill)\n      {\n        reply.setErrorCode(ActionReply::HelperError);\n        reply.setErrorDescription(i18n(\"The mount process crashed.\"));\n        return reply;\n      }\n      else\n      {\n      }\n    }\n    else\n    {\n      QString stdErr = QString::fromUtf8(proc.readAllStandardError());\n      reply.addData(\"mh_error_message\", stdErr.trimmed());\n    }\n  }\n", "target": 1, "idx": 177998}
{"func": " AudioHandler::AudioHandler()\n     : connected_(false),\n      reconnect_tries_(0) {\n  mixer_.reset(new PulseAudioMixer());\n  if (!mixer_->Init(NewCallback(this, &AudioHandler::OnMixerInitialized))) {\n    LOG(ERROR) << \"Unable to connect to PulseAudio\";\n  }\n }\n", "target": 1, "idx": 184140}
{"func": "static __forceinline void draw_line(float *output, int x0, int y0, int x1, int y1, int n)\n{\n   int dy = y1 - y0;\n   int adx = x1 - x0;\n   int ady = abs(dy);\n   int base;\n   int x=x0,y=y0;\n   int err = 0;\n   int sy;\n\n#ifdef STB_VORBIS_DIVIDE_TABLE\n   if (adx < DIVTAB_DENOM && ady < DIVTAB_NUMER) {\n      if (dy < 0) {\n         base = -integer_divide_table[ady][adx];\n         sy = base-1;\n      } else {\n         base =  integer_divide_table[ady][adx];\n         sy = base+1;\n      }\n   } else {\n      base = dy / adx;\n      if (dy < 0)\n         sy = base - 1;\n      else\n         sy = base+1;\n   }\n#else\n   base = dy / adx;\n   if (dy < 0)\n      sy = base - 1;\n   else\n      sy = base+1;\n#endif\n    ady -= abs(base) * adx;\n    if (x1 > n) x1 = n;\n    if (x < x1) {\n      LINE_OP(output[x], inverse_db_table[y]);\n       for (++x; x < x1; ++x) {\n          err += ady;\n          if (err >= adx) {\n             err -= adx;\n             y += sy;\n          } else\n             y += base;\n         LINE_OP(output[x], inverse_db_table[y]);\n       }\n    }\n }\n", "target": 1, "idx": 182786}
{"func": " void WebBluetoothServiceImpl::ClearState() {\n   characteristic_id_to_notify_session_.clear();\n   pending_primary_services_requests_.clear();\n   descriptor_id_to_characteristic_id_.clear();\n  characteristic_id_to_service_id_.clear();\n  service_id_to_device_address_.clear();\n  connected_devices_.reset(\n      new FrameConnectedBluetoothDevices(render_frame_host_));\n  device_chooser_controller_.reset();\n  BluetoothAdapterFactoryWrapper::Get().ReleaseAdapter(this);\n}\n", "target": 1, "idx": 187195}
{"func": " make_random_bytes(png_uint_32* seed, void* pv, size_t size)\n {\n    png_uint_32 u0 = seed[0], u1 = seed[1];\n   png_bytep bytes = png_voidcast(png_bytep, pv);\n \n    /* There are thirty-three bits; the next bit in the sequence is bit-33 XOR\n     * bit-20.  The top 1 bit is in u1, the bottom 32 are in u0.\n    */\n size_t i;\n for (i=0; i<size; ++i)\n {\n /* First generate 8 new bits then shift them in at the end. */\n      png_uint_32 u = ((u0 >> (20-8)) ^ ((u1 << 7) | (u0 >> (32-7)))) & 0xff;\n      u1 <<= 8;\n      u1 |= u0 >> 24;\n      u0 <<= 8;\n      u0 |= u;\n *bytes++ = (png_byte)u;\n }\n\n   seed[0] = u0;\n   seed[1] = u1;\n}\n", "target": 1, "idx": 187758}
{"func": "void OnHttpHeaderReceived(const std::string& header,\n                          const std::string& value,\n                          int child_process_id,\n                          content::ResourceContext* resource_context,\n                          OnHeaderProcessedCallback callback) {\n  std::move(callback).Run(HeaderInterceptorResult::KILL);\n}\n", "target": 0, "idx": 156568}
{"func": "static int gen_d(RSA *rsa)\n{\n\tBN_CTX *bnctx;\n\tBIGNUM *r0, *r1, *r2;\n\tconst BIGNUM *rsa_p, *rsa_q, *rsa_n, *rsa_e, *rsa_d;\n\tBIGNUM *rsa_n_new, *rsa_e_new, *rsa_d_new;\n\n\tbnctx = BN_CTX_new();\n\tif (bnctx == NULL)\n\t\treturn -1;\n\tBN_CTX_start(bnctx);\n\tr0 = BN_CTX_get(bnctx);\n\tr1 = BN_CTX_get(bnctx);\n\tr2 = BN_CTX_get(bnctx);\n\tRSA_get0_key(rsa, &rsa_n, &rsa_e, &rsa_d);\n\tRSA_get0_factors(rsa, &rsa_p, &rsa_q);\n\n\tBN_sub(r1, rsa_p, BN_value_one());\n\tBN_sub(r2, rsa_q, BN_value_one());\n\tBN_mul(r0, r1, r2, bnctx);\n\tif ((rsa_d_new = BN_mod_inverse(NULL, rsa_e, r0, bnctx)) == NULL) {\n\t\tfprintf(stderr, \"BN_mod_inverse() failed.\\n\");\n\t\treturn -1;\n\t}\n\n\t/* RSA_set0_key will free previous value, and replace with new value\n\t * Thus the need to copy the contents of rsa_n and rsa_e\n\t */\n\trsa_n_new = BN_dup(rsa_n);\n\trsa_e_new = BN_dup(rsa_e);\n\tif (RSA_set0_key(rsa, rsa_n_new, rsa_e_new, rsa_d_new) != 1)\n\t\treturn -1;\n\n\tBN_CTX_end(bnctx);\n\tBN_CTX_free(bnctx);\n\treturn 0;\n}\n", "target": 0, "idx": 78872}
{"func": "int vp8_remove_decoder_instances(struct frame_buffers *fb)\n{\n if(!fb->use_frame_threads)\n {\n        VP8D_COMP *pbi = fb->pbi[0];\n\n\n         if (!pbi)\n             return VPX_CODEC_ERROR;\n #if CONFIG_MULTITHREAD\n        if (pbi->b_multithreaded_rd)\n            vp8mt_de_alloc_temp_buffers(pbi, pbi->common.mb_rows);\n         vp8_decoder_remove_threads(pbi);\n #endif\n \n /* decoder instance for single thread mode */\n        remove_decompressor(pbi);\n }\n else\n {\n /* TODO : remove frame threads and decoder instances for each\n         * thread here */\n }\n\n return VPX_CODEC_OK;\n}\n", "target": 1, "idx": 188087}
{"func": "dx_probe(const struct qstr *d_name, struct inode *dir,\n\t struct dx_hash_info *hinfo, struct dx_frame *frame_in, int *err)\n{\n\tunsigned count, indirect;\n\tstruct dx_entry *at, *entries, *p, *q, *m;\n\tstruct dx_root *root;\n\tstruct buffer_head *bh;\n\tstruct dx_frame *frame = frame_in;\n\tu32 hash;\n\n\tframe->bh = NULL;\n\tif (!(bh = ext4_bread (NULL,dir, 0, 0, err)))\n\t\tgoto fail;\n\troot = (struct dx_root *) bh->b_data;\n\tif (root->info.hash_version != DX_HASH_TEA &&\n\t    root->info.hash_version != DX_HASH_HALF_MD4 &&\n\t    root->info.hash_version != DX_HASH_LEGACY) {\n\t\text4_warning(dir->i_sb, \"Unrecognised inode hash code %d\",\n\t\t\t     root->info.hash_version);\n\t\tbrelse(bh);\n\t\t*err = ERR_BAD_DX_DIR;\n\t\tgoto fail;\n\t}\n\thinfo->hash_version = root->info.hash_version;\n\tif (hinfo->hash_version <= DX_HASH_TEA)\n\t\thinfo->hash_version += EXT4_SB(dir->i_sb)->s_hash_unsigned;\n\thinfo->seed = EXT4_SB(dir->i_sb)->s_hash_seed;\n\tif (d_name)\n\t\text4fs_dirhash(d_name->name, d_name->len, hinfo);\n\thash = hinfo->hash;\n\n\tif (root->info.unused_flags & 1) {\n\t\text4_warning(dir->i_sb, \"Unimplemented inode hash flags: %#06x\",\n\t\t\t     root->info.unused_flags);\n\t\tbrelse(bh);\n\t\t*err = ERR_BAD_DX_DIR;\n\t\tgoto fail;\n\t}\n\n\tif ((indirect = root->info.indirect_levels) > 1) {\n\t\text4_warning(dir->i_sb, \"Unimplemented inode hash depth: %#06x\",\n\t\t\t     root->info.indirect_levels);\n\t\tbrelse(bh);\n\t\t*err = ERR_BAD_DX_DIR;\n\t\tgoto fail;\n\t}\n\n\tif (!buffer_verified(bh) &&\n\t    !ext4_dx_csum_verify(dir, (struct ext4_dir_entry *)bh->b_data)) {\n\t\text4_warning(dir->i_sb, \"Root failed checksum\");\n\t\tbrelse(bh);\n\t\t*err = ERR_BAD_DX_DIR;\n\t\tgoto fail;\n\t}\n\tset_buffer_verified(bh);\n\n\tentries = (struct dx_entry *) (((char *)&root->info) +\n\t\t\t\t       root->info.info_length);\n\n\tif (dx_get_limit(entries) != dx_root_limit(dir,\n\t\t\t\t\t\t   root->info.info_length)) {\n\t\text4_warning(dir->i_sb, \"dx entry: limit != root limit\");\n\t\tbrelse(bh);\n\t\t*err = ERR_BAD_DX_DIR;\n\t\tgoto fail;\n\t}\n\n\tdxtrace(printk(\"Look up %x\", hash));\n\twhile (1)\n\t{\n\t\tcount = dx_get_count(entries);\n\t\tif (!count || count > dx_get_limit(entries)) {\n\t\t\text4_warning(dir->i_sb,\n\t\t\t\t     \"dx entry: no count or count > limit\");\n\t\t\tbrelse(bh);\n\t\t\t*err = ERR_BAD_DX_DIR;\n\t\t\tgoto fail2;\n\t\t}\n\n\t\tp = entries + 1;\n\t\tq = entries + count - 1;\n\t\twhile (p <= q)\n\t\t{\n\t\t\tm = p + (q - p)/2;\n\t\t\tdxtrace(printk(\".\"));\n\t\t\tif (dx_get_hash(m) > hash)\n\t\t\t\tq = m - 1;\n\t\t\telse\n\t\t\t\tp = m + 1;\n\t\t}\n\n\t\tif (0) // linear search cross check\n\t\t{\n\t\t\tunsigned n = count - 1;\n\t\t\tat = entries;\n\t\t\twhile (n--)\n\t\t\t{\n\t\t\t\tdxtrace(printk(\",\"));\n\t\t\t\tif (dx_get_hash(++at) > hash)\n\t\t\t\t{\n\t\t\t\t\tat--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert (at == p - 1);\n\t\t}\n\n\t\tat = p - 1;\n\t\tdxtrace(printk(\" %x->%u\\n\", at == entries? 0: dx_get_hash(at), dx_get_block(at)));\n\t\tframe->bh = bh;\n\t\tframe->entries = entries;\n\t\tframe->at = at;\n\t\tif (!indirect--) return frame;\n\t\tif (!(bh = ext4_bread (NULL,dir, dx_get_block(at), 0, err)))\n\t\t\tgoto fail2;\n\t\tat = entries = ((struct dx_node *) bh->b_data)->entries;\n\n\t\tif (!buffer_verified(bh) &&\n\t\t    !ext4_dx_csum_verify(dir,\n\t\t\t\t\t (struct ext4_dir_entry *)bh->b_data)) {\n\t\t\text4_warning(dir->i_sb, \"Node failed checksum\");\n\t\t\tbrelse(bh);\n\t\t\t*err = ERR_BAD_DX_DIR;\n\t\t\tgoto fail;\n\t\t}\n\t\tset_buffer_verified(bh);\n\n\t\tif (dx_get_limit(entries) != dx_node_limit (dir)) {\n\t\t\text4_warning(dir->i_sb,\n\t\t\t\t     \"dx entry: limit != node limit\");\n\t\t\tbrelse(bh);\n\t\t\t*err = ERR_BAD_DX_DIR;\n\t\t\tgoto fail2;\n\t\t}\n\t\tframe++;\n\t\tframe->bh = NULL;\n\t}\nfail2:\n\twhile (frame >= frame_in) {\n\t\tbrelse(frame->bh);\n\t\tframe--;\n\t}\nfail:\n\tif (*err == ERR_BAD_DX_DIR)\n\t\text4_warning(dir->i_sb,\n\t\t\t     \"Corrupt dir inode %lu, running e2fsck is \"\n\t\t\t     \"recommended.\", dir->i_ino);\n\treturn NULL;\n}\n", "target": 0, "idx": 42059}
{"func": "  adisplay_draw_text( void*        _display,\n                      int          x,\n                      int          y,\n                      const char*  msg )\n  {\n    ADisplay  adisplay = (ADisplay)_display;\n\n\n    grWriteCellString( adisplay->bitmap, x, y, msg,\n                       adisplay->fore_color );\n  }\n", "target": 0, "idx": 9989}
{"func": "static cJSON *cJSON_New_Item( void )\n {\n\tcJSON* node = (cJSON*) cJSON_malloc( sizeof(cJSON) );\n\tif ( node )\n\t\tmemset( node, 0, sizeof(cJSON) );\n \treturn node;\n }\n", "target": 1, "idx": 180463}
{"func": "static void dump_boot(DOS_FS * fs, struct boot_sector *b, unsigned lss)\n{\n    unsigned short sectors;\n\n    printf(\"Boot sector contents:\\n\");\n    if (!atari_format) {\n\tchar id[9];\n\tstrncpy(id, (const char *)b->system_id, 8);\n\tid[8] = 0;\n\tprintf(\"System ID \\\"%s\\\"\\n\", id);\n    } else {\n\t/* On Atari, a 24 bit serial number is stored at offset 8 of the boot\n\t * sector */\n\tprintf(\"Serial number 0x%x\\n\",\n\t       b->system_id[5] | (b->system_id[6] << 8) | (b->\n\t\t\t\t\t\t\t   system_id[7] << 16));\n    }\n    printf(\"Media byte 0x%02x (%s)\\n\", b->media, get_media_descr(b->media));\n    printf(\"%10d bytes per logical sector\\n\", GET_UNALIGNED_W(b->sector_size));\n    printf(\"%10d bytes per cluster\\n\", fs->cluster_size);\n    printf(\"%10d reserved sector%s\\n\", le16toh(b->reserved),\n\t   le16toh(b->reserved) == 1 ? \"\" : \"s\");\n    printf(\"First FAT starts at byte %llu (sector %llu)\\n\",\n \t   (unsigned long long)fs->fat_start,\n \t   (unsigned long long)fs->fat_start / lss);\n     printf(\"%10d FATs, %d bit entries\\n\", b->fats, fs->fat_bits);\n    printf(\"%10d bytes per FAT (= %u sectors)\\n\", fs->fat_size,\n\t   fs->fat_size / lss);\n     if (!fs->root_cluster) {\n \tprintf(\"Root directory starts at byte %llu (sector %llu)\\n\",\n \t       (unsigned long long)fs->root_start,\n\t       (unsigned long long)fs->root_start / lss);\n\tprintf(\"%10d root directory entries\\n\", fs->root_entries);\n    } else {\n\tprintf(\"Root directory start at cluster %lu (arbitrary size)\\n\",\n\t       (unsigned long)fs->root_cluster);\n    }\n    printf(\"Data area starts at byte %llu (sector %llu)\\n\",\n\t   (unsigned long long)fs->data_start,\n\t   (unsigned long long)fs->data_start / lss);\n    printf(\"%10lu data clusters (%llu bytes)\\n\",\n\t   (unsigned long)fs->data_clusters,\n\t   (unsigned long long)fs->data_clusters * fs->cluster_size);\n    printf(\"%u sectors/track, %u heads\\n\", le16toh(b->secs_track),\n\t   le16toh(b->heads));\n    printf(\"%10u hidden sectors\\n\", atari_format ?\n\t   /* On Atari, the hidden field is only 16 bit wide and unused */\n\t   (((unsigned char *)&b->hidden)[0] |\n\t    ((unsigned char *)&b->hidden)[1] << 8) : le32toh(b->hidden));\n    sectors = GET_UNALIGNED_W(b->sectors);\n    printf(\"%10u sectors total\\n\", sectors ? sectors : le32toh(b->total_sect));\n}\n", "target": 1, "idx": 180403}
{"func": "void InputMethodIBus::SetContext(IBusInputContext* ic) {\n  DCHECK(ic);\n  DCHECK(!context_);\n  context_ = ic;\n\n  g_signal_connect(ic, \"commit-text\",\n                   G_CALLBACK(OnCommitTextThunk), this);\n  g_signal_connect(ic, \"forward-key-event\",\n                   G_CALLBACK(OnForwardKeyEventThunk), this);\n  g_signal_connect(ic, \"update-preedit-text\",\n                   G_CALLBACK(OnUpdatePreeditTextThunk), this);\n  g_signal_connect(ic, \"show-preedit-text\",\n                   G_CALLBACK(OnShowPreeditTextThunk), this);\n  g_signal_connect(ic, \"hide-preedit-text\",\n                   G_CALLBACK(OnHidePreeditTextThunk), this);\n  g_signal_connect(ic, \"destroy\",\n                   G_CALLBACK(OnDestroyThunk), this);\n\n  ibus_client_->SetCapabilities(ic, internal::IBusClient::INLINE_COMPOSITION);\n\n  UpdateContextFocusState();\n  OnCaretBoundsChanged(GetTextInputClient());\n  OnInputMethodChanged();\n}\n", "target": 0, "idx": 113465}
{"func": "bool ContentBrowserClient::IsSuitableHost(RenderProcessHost* process_host,\n                                          const GURL& site_url) {\n  return true;\n}\n", "target": 0, "idx": 124210}
{"func": "static v8::Handle<v8::Value> overloadedMethod1Callback(const v8::Arguments& args)\n {\n     INC_STATS(\"DOM.TestObj.overloadedMethod1\");\n     if (args.Length() < 2)\n        return V8Proxy::throwNotEnoughArgumentsError();\n     TestObj* imp = V8TestObj::toNative(args.Holder());\n     EXCEPTION_BLOCK(TestObj*, objArg, V8TestObj::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8TestObj::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);\n     STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, strArg, MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined));\n    imp->overloadedMethod(objArg, strArg);\n    return v8::Handle<v8::Value>();\n}\n", "target": 1, "idx": 184789}
{"func": "void php_mysqlnd_rset_field_free_mem(void * _packet, zend_bool stack_allocation TSRMLS_DC)\n{\n\tMYSQLND_PACKET_RES_FIELD *p= (MYSQLND_PACKET_RES_FIELD *) _packet;\n\t/* p->metadata was passed to us as temporal buffer */\n\tif (!stack_allocation) {\n\t\tmnd_pefree(p, p->header.persistent);\n\t}\n}\n", "target": 0, "idx": 49955}
{"func": "static int __init mmtimer_init(void)\n{\n\tcnodeid_t node, maxn = -1;\n\n\tif (!ia64_platform_is(\"sn2\"))\n\t\treturn 0;\n\n\t/*\n\t * Sanity check the cycles/sec variable\n\t */\n\tif (sn_rtc_cycles_per_second < 100000) {\n\t\tprintk(KERN_ERR \"%s: unable to determine clock frequency\\n\",\n\t\t       MMTIMER_NAME);\n\t\tgoto out1;\n\t}\n\n\tmmtimer_femtoperiod = ((unsigned long)1E15 + sn_rtc_cycles_per_second /\n\t\t\t       2) / sn_rtc_cycles_per_second;\n\n\tif (request_irq(SGI_MMTIMER_VECTOR, mmtimer_interrupt, IRQF_PERCPU, MMTIMER_NAME, NULL)) {\n\t\tprintk(KERN_WARNING \"%s: unable to allocate interrupt.\",\n\t\t\tMMTIMER_NAME);\n\t\tgoto out1;\n\t}\n\n\tif (misc_register(&mmtimer_miscdev)) {\n\t\tprintk(KERN_ERR \"%s: failed to register device\\n\",\n\t\t       MMTIMER_NAME);\n\t\tgoto out2;\n\t}\n\n\t/* Get max numbered node, calculate slots needed */\n\tfor_each_online_node(node) {\n\t\tmaxn = node;\n\t}\n\tmaxn++;\n\n\t/* Allocate list of node ptrs to mmtimer_t's */\n\ttimers = kzalloc(sizeof(struct mmtimer_node)*maxn, GFP_KERNEL);\n\tif (timers == NULL) {\n\t\tprintk(KERN_ERR \"%s: failed to allocate memory for device\\n\",\n\t\t\t\tMMTIMER_NAME);\n\t\tgoto out3;\n\t}\n\n\t/* Initialize struct mmtimer's for each online node */\n\tfor_each_online_node(node) {\n\t\tspin_lock_init(&timers[node].lock);\n\t\ttasklet_init(&timers[node].tasklet, mmtimer_tasklet,\n\t\t\t(unsigned long) node);\n\t}\n\n\tsgi_clock_period = sgi_clock.res = NSEC_PER_SEC / sn_rtc_cycles_per_second;\n\tregister_posix_clock(CLOCK_SGI_CYCLE, &sgi_clock);\n\n\tprintk(KERN_INFO \"%s: v%s, %ld MHz\\n\", MMTIMER_DESC, MMTIMER_VERSION,\n\t       sn_rtc_cycles_per_second/(unsigned long)1E6);\n\n\treturn 0;\n\nout3:\n\tkfree(timers);\n\tmisc_deregister(&mmtimer_miscdev);\nout2:\n\tfree_irq(SGI_MMTIMER_VECTOR, NULL);\nout1:\n\treturn -1;\n}\n", "target": 0, "idx": 24649}
{"func": "HistogramBase* SparseHistogram::FactoryGet(const std::string& name,\n                                           int32_t flags) {\n  HistogramBase* histogram = StatisticsRecorder::FindHistogram(name);\n  if (!histogram) {\n    PersistentMemoryAllocator::Reference histogram_ref = 0;\n    std::unique_ptr<HistogramBase> tentative_histogram;\n    PersistentHistogramAllocator* allocator = GlobalHistogramAllocator::Get();\n    if (allocator) {\n      tentative_histogram = allocator->AllocateHistogram(\n          SPARSE_HISTOGRAM, name, 0, 0, nullptr, flags, &histogram_ref);\n    }\n\n    if (!tentative_histogram) {\n      DCHECK(!histogram_ref);  // Should never have been set.\n      DCHECK(!allocator);      // Shouldn't have failed.\n      flags &= ~HistogramBase::kIsPersistent;\n      tentative_histogram.reset(new SparseHistogram(name));\n      tentative_histogram->SetFlags(flags);\n    }\n\n    const void* tentative_histogram_ptr = tentative_histogram.get();\n    histogram = StatisticsRecorder::RegisterOrDeleteDuplicate(\n        tentative_histogram.release());\n\n    if (histogram_ref) {\n      allocator->FinalizeHistogram(histogram_ref,\n                                   histogram == tentative_histogram_ptr);\n    }\n\n    ReportHistogramActivity(*histogram, HISTOGRAM_CREATED);\n  } else {\n     ReportHistogramActivity(*histogram, HISTOGRAM_LOOKUP);\n   }\n \n  DCHECK_EQ(SPARSE_HISTOGRAM, histogram->GetHistogramType());\n   return histogram;\n }\n", "target": 1, "idx": 186462}
{"func": "GF_Box *tfhd_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackFragmentHeaderBox, GF_ISOM_BOX_TYPE_TFHD);\n\treturn (GF_Box *)tmp;\n}\n", "target": 0, "idx": 80516}
{"func": "static ssize_t fuse_dev_read(struct kiocb *iocb, const struct iovec *iov,\n\t\t\t      unsigned long nr_segs, loff_t pos)\n{\n\tstruct fuse_copy_state cs;\n\tstruct file *file = iocb->ki_filp;\n\tstruct fuse_conn *fc = fuse_get_conn(file);\n\tif (!fc)\n\t\treturn -EPERM;\n\n\tfuse_copy_init(&cs, fc, 1, iov, nr_segs);\n\n\treturn fuse_dev_do_read(fc, file, &cs, iov_length(iov, nr_segs));\n}\n", "target": 0, "idx": 24606}
{"func": "Response InspectorPageAgent::setAutoAttachToCreatedPages(bool auto_attach) {\n  state_->setBoolean(PageAgentState::kAutoAttachToCreatedPages, auto_attach);\n  return Response::OK();\n}\n", "target": 0, "idx": 151280}
{"func": "composite_to_json(Datum composite, StringInfo result, bool use_line_feeds)\n{\n\tHeapTupleHeader td;\n\tOid\t\t\ttupType;\n\tint32\t\ttupTypmod;\n\tTupleDesc\ttupdesc;\n\tHeapTupleData tmptup,\n\t\t\t   *tuple;\n\tint\t\t\ti;\n\tbool\t\tneedsep = false;\n\tconst char *sep;\n\n\tsep = use_line_feeds ? \",\\n \" : \",\";\n\n\ttd = DatumGetHeapTupleHeader(composite);\n\n\t/* Extract rowtype info and find a tupdesc */\n\ttupType = HeapTupleHeaderGetTypeId(td);\n\ttupTypmod = HeapTupleHeaderGetTypMod(td);\n\ttupdesc = lookup_rowtype_tupdesc(tupType, tupTypmod);\n\n\t/* Build a temporary HeapTuple control structure */\n\ttmptup.t_len = HeapTupleHeaderGetDatumLength(td);\n\ttmptup.t_data = td;\n\ttuple = &tmptup;\n\n\tappendStringInfoChar(result, '{');\n\n\tfor (i = 0; i < tupdesc->natts; i++)\n\t{\n\t\tDatum\t\tval;\n\t\tbool\t\tisnull;\n\t\tchar\t   *attname;\n\t\tJsonTypeCategory tcategory;\n\t\tOid\t\t\toutfuncoid;\n\n\t\tif (tupdesc->attrs[i]->attisdropped)\n\t\t\tcontinue;\n\n\t\tif (needsep)\n\t\t\tappendStringInfoString(result, sep);\n\t\tneedsep = true;\n\n\t\tattname = NameStr(tupdesc->attrs[i]->attname);\n\t\tescape_json(result, attname);\n\t\tappendStringInfoChar(result, ':');\n\n\t\tval = heap_getattr(tuple, i + 1, tupdesc, &isnull);\n\n\t\tif (isnull)\n\t\t{\n\t\t\ttcategory = JSONTYPE_NULL;\n\t\t\toutfuncoid = InvalidOid;\n\t\t}\n\t\telse\n\t\t\tjson_categorize_type(tupdesc->attrs[i]->atttypid,\n\t\t\t\t\t\t\t\t &tcategory, &outfuncoid);\n\n\t\tdatum_to_json(val, isnull, result, tcategory, outfuncoid, false);\n\t}\n\n\tappendStringInfoChar(result, '}');\n\tReleaseTupleDesc(tupdesc);\n}\n", "target": 0, "idx": 2521}
{"func": " COMPAT_SYSCALL_DEFINE6(mbind, compat_ulong_t, start, compat_ulong_t, len,\n \t\t       compat_ulong_t, mode, compat_ulong_t __user *, nmask,\n \t\t       compat_ulong_t, maxnode, compat_ulong_t, flags)\n {\n\tlong err = 0;\n \tunsigned long __user *nm = NULL;\n \tunsigned long nr_bits, alloc_size;\n \tnodemask_t bm;\n\n\tnr_bits = min_t(unsigned long, maxnode-1, MAX_NUMNODES);\n \talloc_size = ALIGN(nr_bits, BITS_PER_LONG) / 8;\n \n \tif (nmask) {\n\t\terr = compat_get_bitmap(nodes_addr(bm), nmask, nr_bits);\n \t\tnm = compat_alloc_user_space(alloc_size);\n\t\terr |= copy_to_user(nm, nodes_addr(bm), alloc_size);\n \t}\n \n\tif (err)\n\t\treturn -EFAULT;\n \treturn sys_mbind(start, len, mode, nm, nr_bits+1, flags);\n }\n", "target": 1, "idx": 181430}
{"func": " static int srp_tmr_to_tcm(int fn)\n {\n \tswitch (fn) {\n\tcase SRP_TSK_ABORT_TASK:\n\t\treturn TMR_ABORT_TASK;\n\tcase SRP_TSK_ABORT_TASK_SET:\n\t\treturn TMR_ABORT_TASK_SET;\n\tcase SRP_TSK_CLEAR_TASK_SET:\n\t\treturn TMR_CLEAR_TASK_SET;\n\tcase SRP_TSK_LUN_RESET:\n\t\treturn TMR_LUN_RESET;\n\tcase SRP_TSK_CLEAR_ACA:\n\t\treturn TMR_CLEAR_ACA;\n\tdefault:\n\t\treturn -1;\n\t}\n}\n", "target": 0, "idx": 50620}
{"func": "static int ehci_process_itd(EHCIState *ehci,\n                            EHCIitd *itd,\n                            uint32_t addr)\n {\n     USBDevice *dev;\n     USBEndpoint *ep;\n    uint32_t i, len, pid, dir, devaddr, endp;\n     uint32_t pg, off, ptr1, ptr2, max, mult;\n \n     ehci->periodic_sched_active = PERIODIC_ACTIVE;\n\n    dir =(itd->bufptr[1] & ITD_BUFPTR_DIRECTION);\n    devaddr = get_field(itd->bufptr[0], ITD_BUFPTR_DEVADDR);\n    endp = get_field(itd->bufptr[0], ITD_BUFPTR_EP);\n    max = get_field(itd->bufptr[1], ITD_BUFPTR_MAXPKT);\n    mult = get_field(itd->bufptr[2], ITD_BUFPTR_MULT);\n\n    for(i = 0; i < 8; i++) {\n        if (itd->transact[i] & ITD_XACT_ACTIVE) {\n            pg   = get_field(itd->transact[i], ITD_XACT_PGSEL);\n            off  = itd->transact[i] & ITD_XACT_OFFSET_MASK;\n            ptr1 = (itd->bufptr[pg] & ITD_BUFPTR_MASK);\n            ptr2 = (itd->bufptr[pg+1] & ITD_BUFPTR_MASK);\n            len  = get_field(itd->transact[i], ITD_XACT_LENGTH);\n\n            if (len > max * mult) {\n                len = max * mult;\n            }\n\n            if (len > BUFF_SIZE) {\n                return -1;\n            }\n\n            qemu_sglist_init(&ehci->isgl, ehci->device, 2, ehci->as);\n            if (off + len > 4096) {\n                /* transfer crosses page border */\n                uint32_t len2 = off + len - 4096;\n                uint32_t len1 = len - len2;\n                qemu_sglist_add(&ehci->isgl, ptr1 + off, len1);\n                qemu_sglist_add(&ehci->isgl, ptr2, len2);\n            } else {\n                qemu_sglist_add(&ehci->isgl, ptr1 + off, len);\n            }\n\n            pid = dir ? USB_TOKEN_IN : USB_TOKEN_OUT;\n\n            dev = ehci_find_device(ehci, devaddr);\n            ep = usb_ep_get(dev, pid, endp);\n            if (ep && ep->type == USB_ENDPOINT_XFER_ISOC) {\n                usb_packet_setup(&ehci->ipacket, pid, ep, 0, addr, false,\n                                 (itd->transact[i] & ITD_XACT_IOC) != 0);\n                usb_packet_map(&ehci->ipacket, &ehci->isgl);\n                usb_handle_packet(dev, &ehci->ipacket);\n                usb_packet_unmap(&ehci->ipacket, &ehci->isgl);\n            } else {\n                DPRINTF(\"ISOCH: attempt to addess non-iso endpoint\\n\");\n                ehci->ipacket.status = USB_RET_NAK;\n                ehci->ipacket.actual_length = 0;\n            }\n            qemu_sglist_destroy(&ehci->isgl);\n\n            switch (ehci->ipacket.status) {\n            case USB_RET_SUCCESS:\n                break;\n            default:\n                fprintf(stderr, \"Unexpected iso usb result: %d\\n\",\n                        ehci->ipacket.status);\n                /* Fall through */\n            case USB_RET_IOERROR:\n            case USB_RET_NODEV:\n                /* 3.3.2: XACTERR is only allowed on IN transactions */\n                if (dir) {\n                    itd->transact[i] |= ITD_XACT_XACTERR;\n                    ehci_raise_irq(ehci, USBSTS_ERRINT);\n                }\n                break;\n            case USB_RET_BABBLE:\n                itd->transact[i] |= ITD_XACT_BABBLE;\n                ehci_raise_irq(ehci, USBSTS_ERRINT);\n                break;\n            case USB_RET_NAK:\n                /* no data for us, so do a zero-length transfer */\n                ehci->ipacket.actual_length = 0;\n                break;\n            }\n            if (!dir) {\n                set_field(&itd->transact[i], len - ehci->ipacket.actual_length,\n                          ITD_XACT_LENGTH); /* OUT */\n            } else {\n                set_field(&itd->transact[i], ehci->ipacket.actual_length,\n                          ITD_XACT_LENGTH); /* IN */\n            }\n            if (itd->transact[i] & ITD_XACT_IOC) {\n                 ehci_raise_irq(ehci, USBSTS_INT);\n             }\n             itd->transact[i] &= ~ITD_XACT_ACTIVE;\n         }\n     }\n    return 0;\n }\n", "target": 1, "idx": 178451}
{"func": "void ArthurOutputDev::drawLink(Link *link, Catalog *catalog)\n{\n}\n", "target": 0, "idx": 849}
{"func": "static int cma_req_handler(struct ib_cm_id *cm_id, struct ib_cm_event *ib_event)\n{\n \tstruct rdma_id_private *listen_id, *conn_id;\n \tstruct rdma_cm_event event;\n \tint offset, ret;\n\tu8 smac[ETH_ALEN];\n\tu8 alt_smac[ETH_ALEN];\n\tu8 *psmac = smac;\n\tu8 *palt_smac = alt_smac;\n\tint is_iboe = ((rdma_node_get_transport(cm_id->device->node_type) ==\n\t\t\tRDMA_TRANSPORT_IB) &&\n\t\t       (rdma_port_get_link_layer(cm_id->device,\n\t\t\tib_event->param.req_rcvd.port) ==\n\t\t\tIB_LINK_LAYER_ETHERNET));\n \n \tlisten_id = cm_id->context;\n \tif (!cma_check_req_qp_type(&listen_id->id, ib_event))\n\t\treturn -EINVAL;\n\n\tif (cma_disable_callback(listen_id, RDMA_CM_LISTEN))\n\t\treturn -ECONNABORTED;\n\n\tmemset(&event, 0, sizeof event);\n\toffset = cma_user_data_offset(listen_id);\n\tevent.event = RDMA_CM_EVENT_CONNECT_REQUEST;\n\tif (ib_event->event == IB_CM_SIDR_REQ_RECEIVED) {\n\t\tconn_id = cma_new_udp_id(&listen_id->id, ib_event);\n\t\tevent.param.ud.private_data = ib_event->private_data + offset;\n\t\tevent.param.ud.private_data_len =\n\t\t\t\tIB_CM_SIDR_REQ_PRIVATE_DATA_SIZE - offset;\n\t} else {\n\t\tconn_id = cma_new_conn_id(&listen_id->id, ib_event);\n\t\tcma_set_req_event_data(&event, &ib_event->param.req_rcvd,\n\t\t\t\t       ib_event->private_data, offset);\n\t}\n\tif (!conn_id) {\n\t\tret = -ENOMEM;\n\t\tgoto err1;\n\t}\n\n\tmutex_lock_nested(&conn_id->handler_mutex, SINGLE_DEPTH_NESTING);\n\tret = cma_acquire_dev(conn_id, listen_id);\n\tif (ret)\n\t\tgoto err2;\n\n\tconn_id->cm_id.ib = cm_id;\n\tcm_id->context = conn_id;\n\tcm_id->cm_handler = cma_ib_handler;\n\n\t/*\n\t * Protect against the user destroying conn_id from another thread\n\t * until we're done accessing it.\n\t */\n\tatomic_inc(&conn_id->refcount);\n \tret = conn_id->id.event_handler(&conn_id->id, &event);\n \tif (ret)\n \t\tgoto err3;\n\tif (is_iboe) {\n\t\tif (ib_event->param.req_rcvd.primary_path != NULL)\n\t\t\trdma_addr_find_smac_by_sgid(\n\t\t\t\t&ib_event->param.req_rcvd.primary_path->sgid,\n\t\t\t\tpsmac, NULL);\n\t\telse\n\t\t\tpsmac = NULL;\n\t\tif (ib_event->param.req_rcvd.alternate_path != NULL)\n\t\t\trdma_addr_find_smac_by_sgid(\n\t\t\t\t&ib_event->param.req_rcvd.alternate_path->sgid,\n\t\t\t\tpalt_smac, NULL);\n\t\telse\n\t\t\tpalt_smac = NULL;\n\t}\n \t/*\n \t * Acquire mutex to prevent user executing rdma_destroy_id()\n \t * while we're accessing the cm_id.\n \t */\n \tmutex_lock(&lock);\n\tif (is_iboe)\n\t\tib_update_cm_av(cm_id, psmac, palt_smac);\n \tif (cma_comp(conn_id, RDMA_CM_CONNECT) &&\n \t    (conn_id->id.qp_type != IB_QPT_UD))\n \t\tib_send_cm_mra(cm_id, CMA_CM_MRA_SETTING, NULL, 0);\n\tmutex_unlock(&lock);\n\tmutex_unlock(&conn_id->handler_mutex);\n\tmutex_unlock(&listen_id->handler_mutex);\n\tcma_deref_id(conn_id);\n\treturn 0;\n\nerr3:\n\tcma_deref_id(conn_id);\n\t/* Destroy the CM ID by returning a non-zero value. */\n\tconn_id->cm_id.ib = NULL;\nerr2:\n\tcma_exch(conn_id, RDMA_CM_DESTROYING);\n\tmutex_unlock(&conn_id->handler_mutex);\nerr1:\n\tmutex_unlock(&listen_id->handler_mutex);\n\tif (conn_id)\n\t\trdma_destroy_id(&conn_id->id);\n\treturn ret;\n}\n", "target": 1, "idx": 179562}
{"func": "void OneClickSigninHelper::SetDoNotClearPendingEmailForTesting() {\n  do_not_clear_pending_email_ = true;\n}\n", "target": 0, "idx": 118097}
{"func": "void ar6000_set_numdataendpts(struct ar6_softc *ar, u32 num)\n{\n    A_ASSERT(num <= (HTC_MAILBOX_NUM_MAX - 1));\n    ar->arNumDataEndPts = num;\n}\n", "target": 0, "idx": 24220}
{"func": "void handle_lddfmna(struct pt_regs *regs, unsigned long sfar, unsigned long sfsr)\n{\n\tunsigned long pc = regs->tpc;\n\tunsigned long tstate = regs->tstate;\n\tu32 insn;\n\tu64 value;\n\tu8 freg;\n\tint flag;\n\tstruct fpustate *f = FPUSTATE;\n \n \tif (tstate & TSTATE_PRIV)\n \t\tdie_if_kernel(\"lddfmna from kernel\", regs);\n\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, 0, regs, sfar);\n \tif (test_thread_flag(TIF_32BIT))\n \t\tpc = (u32)pc;\n \tif (get_user(insn, (u32 __user *) pc) != -EFAULT) {\n\t\tint asi = decode_asi(insn, regs);\n\t\tu32 first, second;\n\t\tint err;\n\n\t\tif ((asi > ASI_SNFL) ||\n\t\t    (asi < ASI_P))\n\t\t\tgoto daex;\n\t\tfirst = second = 0;\n\t\terr = get_user(first, (u32 __user *)sfar);\n\t\tif (!err)\n\t\t\terr = get_user(second, (u32 __user *)(sfar + 4));\n\t\tif (err) {\n\t\t\tif (!(asi & 0x2))\n\t\t\t\tgoto daex;\n\t\t\tfirst = second = 0;\n\t\t}\n\t\tsave_and_clear_fpu();\n\t\tfreg = ((insn >> 25) & 0x1e) | ((insn >> 20) & 0x20);\n\t\tvalue = (((u64)first) << 32) | second;\n\t\tif (asi & 0x8) /* Little */\n\t\t\tvalue = __swab64p(&value);\n\t\tflag = (freg < 32) ? FPRS_DL : FPRS_DU;\n\t\tif (!(current_thread_info()->fpsaved[0] & FPRS_FEF)) {\n\t\t\tcurrent_thread_info()->fpsaved[0] = FPRS_FEF;\n\t\t\tcurrent_thread_info()->gsr[0] = 0;\n\t\t}\n\t\tif (!(current_thread_info()->fpsaved[0] & flag)) {\n\t\t\tif (freg < 32)\n\t\t\t\tmemset(f->regs, 0, 32*sizeof(u32));\n\t\t\telse\n\t\t\t\tmemset(f->regs+32, 0, 32*sizeof(u32));\n\t\t}\n\t\t*(u64 *)(f->regs + freg) = value;\n\t\tcurrent_thread_info()->fpsaved[0] |= flag;\n\t} else {\ndaex:\n\t\tif (tlb_type == hypervisor)\n\t\t\tsun4v_data_access_exception(regs, sfar, sfsr);\n\t\telse\n\t\t\tspitfire_data_access_exception(regs, sfsr, sfar);\n\t\treturn;\n\t}\n\tadvance(regs);\n}\n", "target": 1, "idx": 178980}
{"func": "void ACodec::BufferInfo::setReadFence(int fenceFd, const char *dbg) {\n if (mFenceFd >= 0) {\n        ALOGW(\"OVERWRITE OF %s fence %d by read fence %d in %s\",\n                mIsReadFence ? \"read\" : \"write\", mFenceFd, fenceFd, dbg);\n }\n    mFenceFd = fenceFd;\n    mIsReadFence = true;\n}\n", "target": 0, "idx": 177305}
{"func": "WebGLObject::WebGLObject(WebGLRenderingContext* context)\n     : m_object(0)\n     , m_attachmentCount(0)\n     , m_deleted(false)\n{\n}\n", "target": 1, "idx": 183631}
{"func": "  virtual void TreeNodesAdded(TreeModel* model, TreeModelNode* parent,\n                              int start, int count) {\n     added_count_++;\n   }\n", "target": 1, "idx": 183927}
{"func": "static int rtnl_link_fill(struct sk_buff *skb, const struct net_device *dev)\n{\n\tstruct nlattr *linkinfo;\n\tint err = -EMSGSIZE;\n\n\tlinkinfo = nla_nest_start(skb, IFLA_LINKINFO);\n\tif (linkinfo == NULL)\n\t\tgoto out;\n\n\terr = rtnl_link_info_fill(skb, dev);\n\tif (err < 0)\n\t\tgoto err_cancel_link;\n\n\terr = rtnl_link_slave_info_fill(skb, dev);\n\tif (err < 0)\n\t\tgoto err_cancel_link;\n\n\tnla_nest_end(skb, linkinfo);\n\treturn 0;\n\nerr_cancel_link:\n\tnla_nest_cancel(skb, linkinfo);\nout:\n\treturn err;\n}\n", "target": 0, "idx": 53163}
{"func": "bool PasswordAutofillAgent::ShowSuggestionPopup(\n    const PasswordInfo& password_info,\n    const WebInputElement& user_input,\n    bool show_all,\n    bool show_on_password_field) {\n  DCHECK(!user_input.IsNull());\n  WebFrame* frame = user_input.GetDocument().GetFrame();\n  if (!frame)\n    return false;\n\n  WebView* webview = frame->View();\n  if (!webview)\n    return false;\n\n  if (user_input.IsPasswordFieldForAutofill() && !user_input.IsAutofilled() &&\n      !user_input.Value().IsEmpty()) {\n    HidePopup();\n    return false;\n  }\n\n  FormData form;\n  FormFieldData field;\n  form_util::FindFormAndFieldForFormControlElement(user_input, &form, &field);\n\n  int options = 0;\n  if (show_all)\n    options |= SHOW_ALL;\n  if (show_on_password_field)\n    options |= IS_PASSWORD_FIELD;\n\n  base::string16 username_string(user_input.IsPasswordFieldForAutofill()\n                                     ? base::string16()\n                                     : user_input.Value().Utf16());\n\n  GetPasswordManagerDriver()->ShowPasswordSuggestions(\n      field.text_direction, username_string, options,\n      render_frame()->GetRenderView()->ElementBoundsInWindow(user_input));\n  username_query_prefix_ = username_string;\n  return CanShowSuggestion(password_info.fill_data, username_string, show_all);\n}\n", "target": 0, "idx": 150337}
{"func": "krb5_encode_krbsecretkey(krb5_key_data *key_data_in, int n_key_data,\n                         krb5_kvno mkvno) {\n    struct berval **ret = NULL;\n    int currkvno;\n     int num_versions = 1;\n     int i, j, last;\n     krb5_error_code err = 0;\n    krb5_key_data *key_data;\n \n    if (n_key_data <= 0)\n         return NULL;\n \n     /* Make a shallow copy of the key data so we can alter it. */\n     key_data = k5calloc(n_key_data, sizeof(*key_data), &err);\n    if (key_data_in == NULL)\n         goto cleanup;\n     memcpy(key_data, key_data_in, n_key_data * sizeof(*key_data));\n \n    /* Unpatched krb5 1.11 and 1.12 cannot decode KrbKey sequences with no salt\n     * field.  For compatibility, always encode a salt field. */\n    for (i = 0; i < n_key_data; i++) {\n        if (key_data[i].key_data_ver == 1) {\n            key_data[i].key_data_ver = 2;\n            key_data[i].key_data_type[1] = KRB5_KDB_SALTTYPE_NORMAL;\n            key_data[i].key_data_length[1] = 0;\n            key_data[i].key_data_contents[1] = NULL;\n        }\n    }\n\n    /* Find the number of key versions */\n    for (i = 0; i < n_key_data - 1; i++)\n        if (key_data[i].key_data_kvno != key_data[i + 1].key_data_kvno)\n            num_versions++;\n\n    ret = (struct berval **) calloc (num_versions + 1, sizeof (struct berval *));\n    if (ret == NULL) {\n        err = ENOMEM;\n        goto cleanup;\n    }\n    for (i = 0, last = 0, j = 0, currkvno = key_data[0].key_data_kvno; i < n_key_data; i++) {\n        krb5_data *code;\n        if (i == n_key_data - 1 || key_data[i + 1].key_data_kvno != currkvno) {\n            ret[j] = k5alloc(sizeof(struct berval), &err);\n            if (ret[j] == NULL)\n                goto cleanup;\n            err = asn1_encode_sequence_of_keys(key_data + last,\n                                               (krb5_int16)i - last + 1,\n                                               mkvno, &code);\n            if (err)\n                goto cleanup;\n            /*CHECK_NULL(ret[j]); */\n            ret[j]->bv_len = code->length;\n            ret[j]->bv_val = code->data;\n            free(code);\n            j++;\n            last = i + 1;\n\n            if (i < n_key_data - 1)\n                currkvno = key_data[i + 1].key_data_kvno;\n        }\n    }\n    ret[num_versions] = NULL;\n\ncleanup:\n\n     free(key_data);\n     if (err != 0) {\n         if (ret != NULL) {\n            for (i = 0; i <= num_versions; i++)\n                if (ret[i] != NULL)\n                    free (ret[i]);\n             free (ret);\n             ret = NULL;\n         }\n    }\n\n    return ret;\n}\n", "target": 1, "idx": 179444}
{"func": "sec_recv(RD_BOOL * is_fastpath)\n{\n\tuint8 fastpath_hdr, fastpath_flags;\n \tuint16 sec_flags;\n \tuint16 channel;\n \tSTREAM s;\n \n \twhile ((s = mcs_recv(&channel, is_fastpath, &fastpath_hdr)) != NULL)\n \t{\n \t\tif (*is_fastpath == True)\n \t\t{\n \t\t\t/* If fastpath packet is encrypted, read data\n\t\t\t   signature and decrypt */\n\t\t\t/* FIXME: extracting flags from hdr could be made less obscure */\n \t\t\tfastpath_flags = (fastpath_hdr & 0xC0) >> 6;\n \t\t\tif (fastpath_flags & FASTPATH_OUTPUT_ENCRYPTED)\n \t\t\t{\n \t\t\t\tin_uint8s(s, 8);\t/* signature */\n \t\t\t\tsec_decrypt(s->p, s->end - s->p);\n \t\t\t}\n\t\t\treturn s;\n\t\t}\n\n\t\tif (g_encryption || (!g_licence_issued && !g_licence_error_result))\n\t\t{\n\t\t\t/* TS_SECURITY_HEADER */\n\t\t\tin_uint16_le(s, sec_flags);\n\t\t\tin_uint8s(s, 2);\t/* skip sec_flags_hi */\n\n\t\t\tif (g_encryption)\n \t\t\t{\n \t\t\t\tif (sec_flags & SEC_ENCRYPT)\n \t\t\t\t{\n \t\t\t\t\tin_uint8s(s, 8);\t/* signature */\n \t\t\t\t\tsec_decrypt(s->p, s->end - s->p);\n \t\t\t\t}\n\n\t\t\t\tif (sec_flags & SEC_LICENSE_PKT)\n\t\t\t\t{\n\t\t\t\t\tlicence_process(s);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (sec_flags & SEC_REDIRECTION_PKT)\n \t\t\t\t{\n \t\t\t\t\tuint8 swapbyte;\n \n \t\t\t\t\tin_uint8s(s, 8);\t/* signature */\n \t\t\t\t\tsec_decrypt(s->p, s->end - s->p);\n \n\t\t\t\t\t/* Check for a redirect packet, starts with 00 04 */\n\t\t\t\t\tif (s->p[0] == 0 && s->p[1] == 4)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* for some reason the PDU and the length seem to be swapped.\n\t\t\t\t\t\t   This isn't good, but we're going to do a byte for byte\n\t\t\t\t\t\t   swap.  So the first four value appear as: 00 04 XX YY,\n\t\t\t\t\t\t   where XX YY is the little endian length. We're going to\n\t\t\t\t\t\t   use 04 00 as the PDU type, so after our swap this will look\n\t\t\t\t\t\t   like: XX YY 04 00 */\n\t\t\t\t\t\tswapbyte = s->p[0];\n\t\t\t\t\t\ts->p[0] = s->p[2];\n\t\t\t\t\t\ts->p[2] = swapbyte;\n\n\t\t\t\t\t\tswapbyte = s->p[1];\n\t\t\t\t\t\ts->p[1] = s->p[3];\n\t\t\t\t\t\ts->p[3] = swapbyte;\n\n\t\t\t\t\t\tswapbyte = s->p[2];\n\t\t\t\t\t\ts->p[2] = s->p[3];\n\t\t\t\t\t\ts->p[3] = swapbyte;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (sec_flags & SEC_LICENSE_PKT)\n\t\t\t\t{\n\t\t\t\t\tlicence_process(s);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ts->p -= 4;\n\t\t\t}\n\t\t}\n\n\t\tif (channel != MCS_GLOBAL_CHANNEL)\n\t\t{\n\t\t\tchannel_process(s, channel);\n\t\t\tcontinue;\n\t\t}\n\n\t\treturn s;\n\t}\n\n\treturn NULL;\n}\n", "target": 1, "idx": 182983}
{"func": "static SCSIRequest *scsi_new_request(SCSIDevice *d, uint32_t tag,\n                                     uint32_t lun, void *hba_private)\n {\n     SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d);\n     SCSIRequest *req;\n    SCSIDiskReq *r;\n \n     req = scsi_req_alloc(&scsi_disk_reqops, &s->qdev, tag, lun, hba_private);\n    r = DO_UPCAST(SCSIDiskReq, req, req);\n    r->iov.iov_base = qemu_blockalign(s->bs, SCSI_DMA_BUF_SIZE);\n     return req;\n }\n", "target": 1, "idx": 179727}
{"func": "instruction_next(const struct ofp11_instruction *inst)\n{\n    return ((struct ofp11_instruction *) (void *)\n            ((uint8_t *) inst + ntohs(inst->len)));\n}\n", "target": 0, "idx": 76974}
{"func": "bool Range::containedByReadOnly() const\n{\n    for (Node* n = m_start.container(); n; n = n->parentNode()) {\n        if (n->isReadOnlyNode())\n            return true;\n    }\n    for (Node* n = m_end.container(); n; n = n->parentNode()) {\n        if (n->isReadOnlyNode())\n            return true;\n    }\n    return false;\n}\n", "target": 0, "idx": 105111}
{"func": "static void __enable_ftrace_function_probe(void)\n{\n\tint ret;\n\tint i;\n\n\tif (ftrace_probe_registered)\n\t\treturn;\n\n\tfor (i = 0; i < FTRACE_FUNC_HASHSIZE; i++) {\n\t\tstruct hlist_head *hhd = &ftrace_func_hash[i];\n\t\tif (hhd->first)\n\t\t\tbreak;\n\t}\n\t/* Nothing registered? */\n\tif (i == FTRACE_FUNC_HASHSIZE)\n\t\treturn;\n\n\tret = __register_ftrace_function(&trace_probe_ops);\n\tif (!ret)\n\t\tret = ftrace_startup(&trace_probe_ops, 0);\n\n\tftrace_probe_registered = 1;\n}\n", "target": 0, "idx": 30101}
{"func": " virtual status_t initCheck() const {\n Parcel data, reply;\n        data.writeInterfaceToken(IDrm::getInterfaceDescriptor());\n status_t status = remote()->transact(INIT_CHECK, data, &reply);\n if (status != OK) {\n return status;\n }\n\n return reply.readInt32();\n }\n", "target": 0, "idx": 174463}
{"func": "void Resource::FinishAsError(const ResourceError& error,\n                             base::SingleThreadTaskRunner* task_runner) {\n  error_ = error;\n  is_revalidating_ = false;\n\n  if (IsMainThread())\n    GetMemoryCache()->Remove(this);\n\n  if (!ErrorOccurred())\n    SetStatus(ResourceStatus::kLoadError);\n  DCHECK(ErrorOccurred());\n  ClearData();\n  loader_ = nullptr;\n  CheckResourceIntegrity();\n  TriggerNotificationForFinishObservers(task_runner);\n  NotifyFinished();\n}\n", "target": 0, "idx": 162539}
{"func": "OneClickSigninSyncStarter::OneClickSigninSyncStarter(\n    Profile* profile,\n    Browser* browser,\n    const std::string& session_index,\n    const std::string& email,\n     const std::string& password,\n     StartSyncMode start_mode,\n     bool force_same_tab_navigation,\n    ConfirmationRequired confirmation_required)\n     : start_mode_(start_mode),\n       force_same_tab_navigation_(force_same_tab_navigation),\n       confirmation_required_(confirmation_required),\n       weak_pointer_factory_(this) {\n   DCHECK(profile);\n   BrowserList::AddObserver(this);\n\n  Initialize(profile, browser);\n\n  SigninManager* manager = SigninManagerFactory::GetForProfile(profile_);\n  SigninManager::OAuthTokenFetchedCallback callback;\n  callback = base::Bind(&OneClickSigninSyncStarter::ConfirmSignin,\n                        weak_pointer_factory_.GetWeakPtr());\n  manager->StartSignInWithCredentials(session_index, email, password, callback);\n}\n", "target": 1, "idx": 184937}
{"func": "int EmbedStream::getChar() {\n  if (limited && !length) {\n    return EOF;\n  }\n  --length;\n  return str->getChar();\n}\n", "target": 0, "idx": 3941}
{"func": " struct request *blk_mq_tag_to_rq(struct blk_mq_tags *tags, unsigned int tag)\n {\n\tstruct request *rq = tags->rqs[tag];\n\t/* mq_ctx of flush rq is always cloned from the corresponding req */\n\tstruct blk_flush_queue *fq = blk_get_flush_queue(rq->q, rq->mq_ctx);\n\tif (!is_flush_request(rq, fq, tag))\n\t\treturn rq;\n\treturn fq->flush_rq;\n }\n", "target": 1, "idx": 182629}
{"func": "static void voidMethodFloat32ArrayArgMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)\n{\n    TRACE_EVENT_SET_SAMPLING_STATE(\"Blink\", \"DOMMethod\");\n    TestObjectPythonV8Internal::voidMethodFloat32ArrayArgMethod(info);\n    TRACE_EVENT_SET_SAMPLING_STATE(\"V8\", \"V8Execution\");\n}\n", "target": 0, "idx": 131907}
{"func": "void ContextState::UpdateWindowRectanglesForBoundDrawFramebufferClientID(\n    GLuint client_id) {\n  bool old_id_nonzero = current_draw_framebuffer_client_id != 0;\n  bool new_id_nonzero = client_id != 0;\n  current_draw_framebuffer_client_id = client_id;\n  if (old_id_nonzero ^ new_id_nonzero) {\n    UpdateWindowRectangles();\n  }\n}\n", "target": 0, "idx": 162837}
{"func": "bool GestureSequence::PinchUpdate(const TouchEvent& event,\n     const GesturePoint& point, Gestures* gestures) {\n   DCHECK(state_ == GS_PINCH);\n   float distance = points_[0].Distance(points_[1]);\n  if (abs(distance - pinch_distance_current_) < kMinimumPinchUpdateDistance) {\n    if (!points_[0].DidScroll(event, kMinimumDistanceForPinchScroll) ||\n        !points_[1].DidScroll(event, kMinimumDistanceForPinchScroll))\n       return false;\n \n     gfx::Point center = points_[0].last_touch_position().Middle(\n                        points_[1].last_touch_position());\n    AppendScrollGestureUpdate(point, center, gestures);\n  } else {\n    AppendPinchGestureUpdate(points_[0], points_[1],\n        distance / pinch_distance_current_, gestures);\n    pinch_distance_current_ = distance;\n  }\n  return true;\n}\n", "target": 1, "idx": 184739}
{"func": "static long bcm_char_ioctl(struct file *filp, UINT cmd, ULONG arg)\n{\n\tstruct bcm_tarang_data *pTarang = filp->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\tstruct bcm_mini_adapter *Adapter = pTarang->Adapter;\n\tINT Status = STATUS_FAILURE;\n\tint timeout = 0;\n\tstruct bcm_ioctl_buffer IoBuffer;\n\tint bytes;\n\n\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Parameters Passed to control IOCTL cmd=0x%X arg=0x%lX\", cmd, arg);\n\n\tif (_IOC_TYPE(cmd) != BCM_IOCTL)\n\t\treturn -EFAULT;\n\tif (_IOC_DIR(cmd) & _IOC_READ)\n\t\tStatus = !access_ok(VERIFY_WRITE, argp, _IOC_SIZE(cmd));\n\telse if (_IOC_DIR(cmd) & _IOC_WRITE)\n\t\tStatus = !access_ok(VERIFY_READ, argp, _IOC_SIZE(cmd));\n\telse if (_IOC_NONE == (_IOC_DIR(cmd) & _IOC_NONE))\n\t\tStatus = STATUS_SUCCESS;\n\n\tif (Status)\n\t\treturn -EFAULT;\n\n\tif (Adapter->device_removed)\n\t\treturn -EFAULT;\n\n\tif (FALSE == Adapter->fw_download_done) {\n\t\tswitch (cmd) {\n\t\tcase IOCTL_MAC_ADDR_REQ:\n\t\tcase IOCTL_LINK_REQ:\n\t\tcase IOCTL_CM_REQUEST:\n\t\tcase IOCTL_SS_INFO_REQ:\n\t\tcase IOCTL_SEND_CONTROL_MESSAGE:\n\t\tcase IOCTL_IDLE_REQ:\n\t\tcase IOCTL_BCM_GPIO_SET_REQUEST:\n\t\tcase IOCTL_BCM_GPIO_STATUS_REQUEST:\n\t\t\treturn -EACCES;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tStatus = vendorextnIoctl(Adapter, cmd, arg);\n\tif (Status != CONTINUE_COMMON_PATH)\n\t\treturn Status;\n\n\tswitch (cmd) {\n\t/* Rdms for Swin Idle... */\n\tcase IOCTL_BCM_REGISTER_READ_PRIVATE: {\n\t\tstruct bcm_rdm_buffer sRdmBuffer = {0};\n\t\tPCHAR temp_buff;\n\t\tUINT Bufflen;\n\t\tu16 temp_value;\n\n\t\t/* Copy Ioctl Buffer structure */\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (IoBuffer.InputLength > sizeof(sRdmBuffer))\n\t\t\treturn -EINVAL;\n\n\t\tif (copy_from_user(&sRdmBuffer, IoBuffer.InputBuffer, IoBuffer.InputLength))\n\t\t\treturn -EFAULT;\n\n\t\tif (IoBuffer.OutputLength > USHRT_MAX ||\n\t\t\tIoBuffer.OutputLength == 0) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tBufflen = IoBuffer.OutputLength;\n\t\ttemp_value = 4 - (Bufflen % 4);\n\t\tBufflen += temp_value % 4;\n\n\t\ttemp_buff = kmalloc(Bufflen, GFP_KERNEL);\n\t\tif (!temp_buff)\n\t\t\treturn -ENOMEM;\n\n\t\tbytes = rdmalt(Adapter, (UINT)sRdmBuffer.Register,\n\t\t\t\t(PUINT)temp_buff, Bufflen);\n\t\tif (bytes > 0) {\n\t\t\tStatus = STATUS_SUCCESS;\n\t\t\tif (copy_to_user(IoBuffer.OutputBuffer, temp_buff, bytes)) {\n\t\t\t\tkfree(temp_buff);\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t} else {\n\t\t\tStatus = bytes;\n\t\t}\n\n\t\tkfree(temp_buff);\n\t\tbreak;\n\t}\n\n\tcase IOCTL_BCM_REGISTER_WRITE_PRIVATE: {\n\t\tstruct bcm_wrm_buffer sWrmBuffer = {0};\n\t\tUINT uiTempVar = 0;\n\t\t/* Copy Ioctl Buffer structure */\n\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (IoBuffer.InputLength > sizeof(sWrmBuffer))\n\t\t\treturn -EINVAL;\n\n\t\t/* Get WrmBuffer structure */\n\t\tif (copy_from_user(&sWrmBuffer, IoBuffer.InputBuffer, IoBuffer.InputLength))\n\t\t\treturn -EFAULT;\n\n\t\tuiTempVar = sWrmBuffer.Register & EEPROM_REJECT_MASK;\n\t\tif (!((Adapter->pstargetparams->m_u32Customize) & VSG_MODE) &&\n\t\t\t((uiTempVar == EEPROM_REJECT_REG_1) ||\n\t\t\t\t(uiTempVar == EEPROM_REJECT_REG_2) ||\n\t\t\t\t(uiTempVar == EEPROM_REJECT_REG_3) ||\n\t\t\t\t(uiTempVar == EEPROM_REJECT_REG_4))) {\n\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"EEPROM Access Denied, not in VSG Mode\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tStatus = wrmalt(Adapter, (UINT)sWrmBuffer.Register,\n\t\t\t\t(PUINT)sWrmBuffer.Data, sizeof(ULONG));\n\n\t\tif (Status == STATUS_SUCCESS) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"WRM Done\\n\");\n\t\t} else {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"WRM Failed\\n\");\n\t\t\tStatus = -EFAULT;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase IOCTL_BCM_REGISTER_READ:\n\tcase IOCTL_BCM_EEPROM_REGISTER_READ: {\n\t\tstruct bcm_rdm_buffer sRdmBuffer = {0};\n\t\tPCHAR temp_buff = NULL;\n\t\tUINT uiTempVar = 0;\n\t\tif ((Adapter->IdleMode == TRUE) ||\n\t\t\t(Adapter->bShutStatus == TRUE) ||\n\t\t\t(Adapter->bPreparingForLowPowerMode == TRUE)) {\n\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Device in Idle Mode, Blocking Rdms\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\t/* Copy Ioctl Buffer structure */\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (IoBuffer.InputLength > sizeof(sRdmBuffer))\n\t\t\treturn -EINVAL;\n\n\t\tif (copy_from_user(&sRdmBuffer, IoBuffer.InputBuffer, IoBuffer.InputLength))\n\t\t\treturn -EFAULT;\n\n\t\tif (IoBuffer.OutputLength > USHRT_MAX ||\n\t\t\tIoBuffer.OutputLength == 0) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\ttemp_buff = kmalloc(IoBuffer.OutputLength, GFP_KERNEL);\n\t\tif (!temp_buff)\n\t\t\treturn STATUS_FAILURE;\n\n\t\tif ((((ULONG)sRdmBuffer.Register & 0x0F000000) != 0x0F000000) ||\n\t\t\t((ULONG)sRdmBuffer.Register & 0x3)) {\n\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"RDM Done On invalid Address : %x Access Denied.\\n\",\n\t\t\t\t\t(int)sRdmBuffer.Register);\n\n\t\t\tkfree(temp_buff);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tuiTempVar = sRdmBuffer.Register & EEPROM_REJECT_MASK;\n\t\tbytes = rdmaltWithLock(Adapter, (UINT)sRdmBuffer.Register, (PUINT)temp_buff, IoBuffer.OutputLength);\n\n\t\tif (bytes > 0) {\n\t\t\tStatus = STATUS_SUCCESS;\n\t\t\tif (copy_to_user(IoBuffer.OutputBuffer, temp_buff, bytes)) {\n\t\t\t\tkfree(temp_buff);\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t} else {\n\t\t\tStatus = bytes;\n\t\t}\n\n\t\tkfree(temp_buff);\n\t\tbreak;\n\t}\n\tcase IOCTL_BCM_REGISTER_WRITE:\n\tcase IOCTL_BCM_EEPROM_REGISTER_WRITE: {\n\t\tstruct bcm_wrm_buffer sWrmBuffer = {0};\n\t\tUINT uiTempVar = 0;\n\n\t\tif ((Adapter->IdleMode == TRUE) ||\n\t\t\t(Adapter->bShutStatus == TRUE) ||\n\t\t\t(Adapter->bPreparingForLowPowerMode == TRUE)) {\n\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Device in Idle Mode, Blocking Wrms\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\t/* Copy Ioctl Buffer structure */\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (IoBuffer.InputLength > sizeof(sWrmBuffer))\n\t\t\treturn -EINVAL;\n\n\t\t/* Get WrmBuffer structure */\n\t\tif (copy_from_user(&sWrmBuffer, IoBuffer.InputBuffer, IoBuffer.InputLength))\n\t\t\treturn -EFAULT;\n\n\t\tif ((((ULONG)sWrmBuffer.Register & 0x0F000000) != 0x0F000000) ||\n\t\t\t((ULONG)sWrmBuffer.Register & 0x3)) {\n\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"WRM Done On invalid Address : %x Access Denied.\\n\", (int)sWrmBuffer.Register);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tuiTempVar = sWrmBuffer.Register & EEPROM_REJECT_MASK;\n\t\tif (!((Adapter->pstargetparams->m_u32Customize) & VSG_MODE) &&\n\t\t\t\t((uiTempVar == EEPROM_REJECT_REG_1) ||\n\t\t\t\t(uiTempVar == EEPROM_REJECT_REG_2) ||\n\t\t\t\t(uiTempVar == EEPROM_REJECT_REG_3) ||\n\t\t\t\t(uiTempVar == EEPROM_REJECT_REG_4)) &&\n\t\t\t\t(cmd == IOCTL_BCM_REGISTER_WRITE)) {\n\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"EEPROM Access Denied, not in VSG Mode\\n\");\n\t\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tStatus = wrmaltWithLock(Adapter, (UINT)sWrmBuffer.Register,\n\t\t\t\t\t(PUINT)sWrmBuffer.Data, sWrmBuffer.Length);\n\n\t\tif (Status == STATUS_SUCCESS) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, OSAL_DBG, DBG_LVL_ALL, \"WRM Done\\n\");\n\t\t} else {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"WRM Failed\\n\");\n\t\t\tStatus = -EFAULT;\n\t\t}\n\t\tbreak;\n\t}\n\tcase IOCTL_BCM_GPIO_SET_REQUEST: {\n\t\tUCHAR ucResetValue[4];\n\t\tUINT value = 0;\n\t\tUINT uiBit = 0;\n\t\tUINT uiOperation = 0;\n\t\tstruct bcm_gpio_info gpio_info = {0};\n\n\t\tif ((Adapter->IdleMode == TRUE) ||\n\t\t\t(Adapter->bShutStatus == TRUE) ||\n\t\t\t(Adapter->bPreparingForLowPowerMode == TRUE)) {\n\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"GPIO Can't be set/clear in Low power Mode\");\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (IoBuffer.InputLength > sizeof(gpio_info))\n\t\t\treturn -EINVAL;\n\n\t\tif (copy_from_user(&gpio_info, IoBuffer.InputBuffer, IoBuffer.InputLength))\n\t\t\treturn -EFAULT;\n\n\t\tuiBit  = gpio_info.uiGpioNumber;\n\t\tuiOperation = gpio_info.uiGpioValue;\n\t\tvalue = (1<<uiBit);\n\n\t\tif (IsReqGpioIsLedInNVM(Adapter, value) == FALSE) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Sorry, Requested GPIO<0x%X> is not correspond to LED !!!\", value);\n\t\t\tStatus = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Set - setting 1 */\n\t\tif (uiOperation) {\n\t\t\t/* Set the gpio output register */\n\t\t\tStatus = wrmaltWithLock(Adapter, BCM_GPIO_OUTPUT_SET_REG, (PUINT)(&value), sizeof(UINT));\n\n\t\t\tif (Status == STATUS_SUCCESS) {\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Set the GPIO bit\\n\");\n\t\t\t} else {\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Failed to set the %dth GPIO\\n\", uiBit);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t/* Set the gpio output register */\n\t\t\tStatus = wrmaltWithLock(Adapter, BCM_GPIO_OUTPUT_CLR_REG, (PUINT)(&value), sizeof(UINT));\n\n\t\t\tif (Status == STATUS_SUCCESS) {\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Set the GPIO bit\\n\");\n\t\t\t} else {\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Failed to clear the %dth GPIO\\n\", uiBit);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tbytes = rdmaltWithLock(Adapter, (UINT)GPIO_MODE_REGISTER, (PUINT)ucResetValue, sizeof(UINT));\n\t\tif (bytes < 0) {\n\t\t\tStatus = bytes;\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,\n\t\t\t\t\t\"GPIO_MODE_REGISTER read failed\");\n\t\t\tbreak;\n\t\t} else {\n\t\t\tStatus = STATUS_SUCCESS;\n\t\t}\n\n\t\t/* Set the gpio mode register to output */\n\t\t*(UINT *)ucResetValue |= (1<<uiBit);\n\t\tStatus = wrmaltWithLock(Adapter, GPIO_MODE_REGISTER,\n\t\t\t\t\t(PUINT)ucResetValue, sizeof(UINT));\n\n\t\tif (Status == STATUS_SUCCESS) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Set the GPIO to output Mode\\n\");\n\t\t} else {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Failed to put GPIO in Output Mode\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\tbreak;\n\n\tcase BCM_LED_THREAD_STATE_CHANGE_REQ: {\n\t\tstruct bcm_user_thread_req threadReq = {0};\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"User made LED thread InActive\");\n\n\t\tif ((Adapter->IdleMode == TRUE) ||\n\t\t\t(Adapter->bShutStatus == TRUE) ||\n\t\t\t(Adapter->bPreparingForLowPowerMode == TRUE)) {\n\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"GPIO Can't be set/clear in Low power Mode\");\n\t\t\tStatus = -EACCES;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (IoBuffer.InputLength > sizeof(threadReq))\n\t\t\treturn -EINVAL;\n\n\t\tif (copy_from_user(&threadReq, IoBuffer.InputBuffer, IoBuffer.InputLength))\n\t\t\treturn -EFAULT;\n\n\t\t/* if LED thread is running(Actively or Inactively) set it state to make inactive */\n\t\tif (Adapter->LEDInfo.led_thread_running) {\n\t\t\tif (threadReq.ThreadState == LED_THREAD_ACTIVATION_REQ) {\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Activating thread req\");\n\t\t\t\tAdapter->DriverState = LED_THREAD_ACTIVE;\n\t\t\t} else {\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"DeActivating Thread req.....\");\n\t\t\t\tAdapter->DriverState = LED_THREAD_INACTIVE;\n\t\t\t}\n\n\t\t\t/* signal thread. */\n\t\t\twake_up(&Adapter->LEDInfo.notify_led_event);\n\t\t}\n\t}\n\tbreak;\n\n\tcase IOCTL_BCM_GPIO_STATUS_REQUEST: {\n\t\tULONG uiBit = 0;\n\t\tUCHAR ucRead[4];\n\t\tstruct bcm_gpio_info gpio_info = {0};\n\n\t\tif ((Adapter->IdleMode == TRUE) ||\n\t\t\t(Adapter->bShutStatus == TRUE) ||\n\t\t\t(Adapter->bPreparingForLowPowerMode == TRUE))\n\t\t\treturn -EACCES;\n\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (IoBuffer.InputLength > sizeof(gpio_info))\n\t\t\treturn -EINVAL;\n\n\t\tif (copy_from_user(&gpio_info, IoBuffer.InputBuffer, IoBuffer.InputLength))\n\t\t\treturn -EFAULT;\n\n\t\tuiBit = gpio_info.uiGpioNumber;\n\n\t\t/* Set the gpio output register */\n\t\tbytes = rdmaltWithLock(Adapter, (UINT)GPIO_PIN_STATE_REGISTER,\n\t\t\t\t\t(PUINT)ucRead, sizeof(UINT));\n\n\t\tif (bytes < 0) {\n\t\t\tStatus = bytes;\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"RDM Failed\\n\");\n\t\t\treturn Status;\n\t\t} else {\n\t\t\tStatus = STATUS_SUCCESS;\n\t\t}\n\t}\n\tbreak;\n\n\tcase IOCTL_BCM_GPIO_MULTI_REQUEST: {\n\t\tUCHAR ucResetValue[4];\n\t\tstruct bcm_gpio_multi_info gpio_multi_info[MAX_IDX];\n\t\tstruct bcm_gpio_multi_info *pgpio_multi_info = (struct bcm_gpio_multi_info *)gpio_multi_info;\n\n\t\tmemset(pgpio_multi_info, 0, MAX_IDX * sizeof(struct bcm_gpio_multi_info));\n\n\t\tif ((Adapter->IdleMode == TRUE) ||\n\t\t\t(Adapter->bShutStatus == TRUE) ||\n\t\t\t(Adapter->bPreparingForLowPowerMode == TRUE))\n\t\t\treturn -EINVAL;\n\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (IoBuffer.InputLength > sizeof(gpio_multi_info))\n\t\t\treturn -EINVAL;\n\n\t\tif (copy_from_user(&gpio_multi_info, IoBuffer.InputBuffer, IoBuffer.InputLength))\n\t\t\treturn -EFAULT;\n\n\t\tif (IsReqGpioIsLedInNVM(Adapter, pgpio_multi_info[WIMAX_IDX].uiGPIOMask) == FALSE) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,\n\t\t\t\t\t\"Sorry, Requested GPIO<0x%X> is not correspond to NVM LED bit map<0x%X>!!!\",\n\t\t\t\t\tpgpio_multi_info[WIMAX_IDX].uiGPIOMask, Adapter->gpioBitMap);\n\t\t\tStatus = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Set the gpio output register */\n\t\tif ((pgpio_multi_info[WIMAX_IDX].uiGPIOMask) &\n\t\t\t(pgpio_multi_info[WIMAX_IDX].uiGPIOCommand)) {\n\t\t\t/* Set 1's in GPIO OUTPUT REGISTER */\n\t\t\t*(UINT *)ucResetValue =  pgpio_multi_info[WIMAX_IDX].uiGPIOMask &\n\t\t\t\tpgpio_multi_info[WIMAX_IDX].uiGPIOCommand &\n\t\t\t\tpgpio_multi_info[WIMAX_IDX].uiGPIOValue;\n\n\t\t\tif (*(UINT *) ucResetValue)\n\t\t\t\tStatus = wrmaltWithLock(Adapter, BCM_GPIO_OUTPUT_SET_REG,\n\t\t\t\t\t\t\t(PUINT)ucResetValue, sizeof(ULONG));\n\n\t\t\tif (Status != STATUS_SUCCESS) {\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"WRM to BCM_GPIO_OUTPUT_SET_REG Failed.\");\n\t\t\t\treturn Status;\n\t\t\t}\n\n\t\t\t/* Clear to 0's in GPIO OUTPUT REGISTER */\n\t\t\t*(UINT *)ucResetValue = (pgpio_multi_info[WIMAX_IDX].uiGPIOMask &\n\t\t\t\t\t\tpgpio_multi_info[WIMAX_IDX].uiGPIOCommand &\n\t\t\t\t\t\t(~(pgpio_multi_info[WIMAX_IDX].uiGPIOValue)));\n\n\t\t\tif (*(UINT *) ucResetValue)\n\t\t\t\tStatus = wrmaltWithLock(Adapter, BCM_GPIO_OUTPUT_CLR_REG, (PUINT)ucResetValue, sizeof(ULONG));\n\n\t\t\tif (Status != STATUS_SUCCESS) {\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"WRM to BCM_GPIO_OUTPUT_CLR_REG Failed.\");\n\t\t\t\treturn Status;\n\t\t\t}\n\t\t}\n\n\t\tif (pgpio_multi_info[WIMAX_IDX].uiGPIOMask) {\n\t\t\tbytes = rdmaltWithLock(Adapter, (UINT)GPIO_PIN_STATE_REGISTER, (PUINT)ucResetValue, sizeof(UINT));\n\n\t\t\tif (bytes < 0) {\n\t\t\t\tStatus = bytes;\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"RDM to GPIO_PIN_STATE_REGISTER Failed.\");\n\t\t\t\treturn Status;\n\t\t\t} else {\n\t\t\t\tStatus = STATUS_SUCCESS;\n\t\t\t}\n\n\t\t\tpgpio_multi_info[WIMAX_IDX].uiGPIOValue = (*(UINT *)ucResetValue &\n\t\t\t\t\t\t\t\tpgpio_multi_info[WIMAX_IDX].uiGPIOMask);\n\t\t}\n\n\t\tStatus = copy_to_user(IoBuffer.OutputBuffer, &gpio_multi_info, IoBuffer.OutputLength);\n\t\tif (Status) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,\n\t\t\t\t\t\"Failed while copying Content to IOBufer for user space err:%d\", Status);\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\tbreak;\n\n\tcase IOCTL_BCM_GPIO_MODE_REQUEST: {\n\t\tUCHAR ucResetValue[4];\n\t\tstruct bcm_gpio_multi_mode gpio_multi_mode[MAX_IDX];\n\t\tstruct bcm_gpio_multi_mode *pgpio_multi_mode = (struct bcm_gpio_multi_mode *)gpio_multi_mode;\n\n\t\tif ((Adapter->IdleMode == TRUE) ||\n\t\t\t(Adapter->bShutStatus == TRUE) ||\n\t\t\t(Adapter->bPreparingForLowPowerMode == TRUE))\n\t\t\treturn -EINVAL;\n\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (IoBuffer.InputLength > sizeof(gpio_multi_mode))\n\t\t\treturn -EINVAL;\n\n\t\tif (copy_from_user(&gpio_multi_mode, IoBuffer.InputBuffer, IoBuffer.InputLength))\n\t\t\treturn -EFAULT;\n\n\t\tbytes = rdmaltWithLock(Adapter, (UINT)GPIO_MODE_REGISTER, (PUINT)ucResetValue, sizeof(UINT));\n\n\t\tif (bytes < 0) {\n\t\t\tStatus = bytes;\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Read of GPIO_MODE_REGISTER failed\");\n\t\t\treturn Status;\n\t\t} else {\n\t\t\tStatus = STATUS_SUCCESS;\n\t\t}\n\n\t\t/* Validating the request */\n\t\tif (IsReqGpioIsLedInNVM(Adapter, pgpio_multi_mode[WIMAX_IDX].uiGPIOMask) == FALSE) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,\n\t\t\t\t\t\"Sorry, Requested GPIO<0x%X> is not correspond to NVM LED bit map<0x%X>!!!\",\n\t\t\t\t\tpgpio_multi_mode[WIMAX_IDX].uiGPIOMask, Adapter->gpioBitMap);\n\t\t\tStatus = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (pgpio_multi_mode[WIMAX_IDX].uiGPIOMask) {\n\t\t\t/* write all OUT's (1's) */\n\t\t\t*(UINT *) ucResetValue |= (pgpio_multi_mode[WIMAX_IDX].uiGPIOMode &\n\t\t\t\t\t\tpgpio_multi_mode[WIMAX_IDX].uiGPIOMask);\n\n\t\t\t/* write all IN's (0's) */\n\t\t\t*(UINT *) ucResetValue &= ~((~pgpio_multi_mode[WIMAX_IDX].uiGPIOMode) &\n\t\t\t\t\t\tpgpio_multi_mode[WIMAX_IDX].uiGPIOMask);\n\n\t\t\t/* Currently implemented return the modes of all GPIO's\n\t\t\t * else needs to bit AND with  mask\n\t\t\t */\n\t\t\tpgpio_multi_mode[WIMAX_IDX].uiGPIOMode = *(UINT *)ucResetValue;\n\n\t\t\tStatus = wrmaltWithLock(Adapter, GPIO_MODE_REGISTER, (PUINT)ucResetValue, sizeof(ULONG));\n\t\t\tif (Status == STATUS_SUCCESS) {\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,\n\t\t\t\t\t\t\"WRM to GPIO_MODE_REGISTER Done\");\n\t\t\t} else {\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,\n\t\t\t\t\t\t\"WRM to GPIO_MODE_REGISTER Failed\");\n\t\t\t\tStatus = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n/* if uiGPIOMask is 0 then return mode register configuration */\n\t\t\tpgpio_multi_mode[WIMAX_IDX].uiGPIOMode = *(UINT *)ucResetValue;\n\t\t}\n\n\t\tStatus = copy_to_user(IoBuffer.OutputBuffer, &gpio_multi_mode, IoBuffer.OutputLength);\n\t\tif (Status) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,\n\t\t\t\t\t\"Failed while copying Content to IOBufer for user space err:%d\", Status);\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\tbreak;\n\n\tcase IOCTL_MAC_ADDR_REQ:\n\tcase IOCTL_LINK_REQ:\n\tcase IOCTL_CM_REQUEST:\n\tcase IOCTL_SS_INFO_REQ:\n\tcase IOCTL_SEND_CONTROL_MESSAGE:\n\tcase IOCTL_IDLE_REQ: {\n\t\tPVOID pvBuffer = NULL;\n\n\t\t/* Copy Ioctl Buffer structure */\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (IoBuffer.InputLength < sizeof(struct bcm_link_request))\n\t\t\treturn -EINVAL;\n\n\t\tif (IoBuffer.InputLength > MAX_CNTL_PKT_SIZE)\n\t\t\treturn -EINVAL;\n\n\t\tpvBuffer = memdup_user(IoBuffer.InputBuffer,\n\t\t\t\t       IoBuffer.InputLength);\n\t\tif (IS_ERR(pvBuffer))\n\t\t\treturn PTR_ERR(pvBuffer);\n\n\t\tdown(&Adapter->LowPowerModeSync);\n\t\tStatus = wait_event_interruptible_timeout(Adapter->lowpower_mode_wait_queue,\n\t\t\t\t\t\t\t!Adapter->bPreparingForLowPowerMode,\n\t\t\t\t\t\t\t(1 * HZ));\n\t\tif (Status == -ERESTARTSYS)\n\t\t\tgoto cntrlEnd;\n\n\t\tif (Adapter->bPreparingForLowPowerMode) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,\n\t\t\t\t\t\"Preparing Idle Mode is still True - Hence Rejecting control message\\n\");\n\t\t\tStatus = STATUS_FAILURE;\n\t\t\tgoto cntrlEnd;\n\t\t}\n\t\tStatus = CopyBufferToControlPacket(Adapter, (PVOID)pvBuffer);\n\ncntrlEnd:\n\t\tup(&Adapter->LowPowerModeSync);\n\t\tkfree(pvBuffer);\n\t\tbreak;\n\t}\n\n\tcase IOCTL_BCM_BUFFER_DOWNLOAD_START: {\n\t\tif (down_trylock(&Adapter->NVMRdmWrmLock)) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,\n\t\t\t\t\t\"IOCTL_BCM_CHIP_RESET not allowed as EEPROM Read/Write is in progress\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,\n\t\t\t\t\"Starting the firmware download PID =0x%x!!!!\\n\", current->pid);\n\n\t\tif (down_trylock(&Adapter->fw_download_sema))\n\t\t\treturn -EBUSY;\n\n\t\tAdapter->bBinDownloaded = FALSE;\n\t\tAdapter->fw_download_process_pid = current->pid;\n\t\tAdapter->bCfgDownloaded = FALSE;\n\t\tAdapter->fw_download_done = FALSE;\n\t\tnetif_carrier_off(Adapter->dev);\n\t\tnetif_stop_queue(Adapter->dev);\n\t\tStatus = reset_card_proc(Adapter);\n\t\tif (Status) {\n\t\t\tpr_err(PFX \"%s: reset_card_proc Failed!\\n\", Adapter->dev->name);\n\t\t\tup(&Adapter->fw_download_sema);\n\t\t\tup(&Adapter->NVMRdmWrmLock);\n\t\t\treturn Status;\n\t\t}\n\t\tmdelay(10);\n\n\t\tup(&Adapter->NVMRdmWrmLock);\n\t\treturn Status;\n\t}\n\n\tcase IOCTL_BCM_BUFFER_DOWNLOAD: {\n\t\tstruct bcm_firmware_info *psFwInfo = NULL;\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Starting the firmware download PID =0x%x!!!!\\n\", current->pid);\n\n\t\tif (!down_trylock(&Adapter->fw_download_sema)) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,\n\t\t\t\t\t\"Invalid way to download buffer. Use Start and then call this!!!\\n\");\n\t\t\tup(&Adapter->fw_download_sema);\n\t\t\tStatus = -EINVAL;\n\t\t\treturn Status;\n\t\t}\n\n\t\t/* Copy Ioctl Buffer structure */\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer))) {\n\t\t\tup(&Adapter->fw_download_sema);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,\n\t\t\t\t\"Length for FW DLD is : %lx\\n\", IoBuffer.InputLength);\n\n\t\tif (IoBuffer.InputLength > sizeof(struct bcm_firmware_info)) {\n\t\t\tup(&Adapter->fw_download_sema);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tpsFwInfo = kmalloc(sizeof(*psFwInfo), GFP_KERNEL);\n\t\tif (!psFwInfo) {\n\t\t\tup(&Adapter->fw_download_sema);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (copy_from_user(psFwInfo, IoBuffer.InputBuffer, IoBuffer.InputLength)) {\n\t\t\tup(&Adapter->fw_download_sema);\n\t\t\tkfree(psFwInfo);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tif (!psFwInfo->pvMappedFirmwareAddress ||\n\t\t\t(psFwInfo->u32FirmwareLength == 0)) {\n\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Something else is wrong %lu\\n\",\n\t\t\t\t\tpsFwInfo->u32FirmwareLength);\n\t\t\tup(&Adapter->fw_download_sema);\n\t\t\tkfree(psFwInfo);\n\t\t\tStatus = -EINVAL;\n\t\t\treturn Status;\n\t\t}\n\n\t\tStatus = bcm_ioctl_fw_download(Adapter, psFwInfo);\n\n\t\tif (Status != STATUS_SUCCESS) {\n\t\t\tif (psFwInfo->u32StartingAddress == CONFIG_BEGIN_ADDR)\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"IOCTL: Configuration File Upload Failed\\n\");\n\t\t\telse\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,\t\"IOCTL: Firmware File Upload Failed\\n\");\n\n\t\t\t/* up(&Adapter->fw_download_sema); */\n\n\t\t\tif (Adapter->LEDInfo.led_thread_running & BCM_LED_THREAD_RUNNING_ACTIVELY) {\n\t\t\t\tAdapter->DriverState = DRIVER_INIT;\n\t\t\t\tAdapter->LEDInfo.bLedInitDone = FALSE;\n\t\t\t\twake_up(&Adapter->LEDInfo.notify_led_event);\n\t\t\t}\n\t\t}\n\n\t\tif (Status != STATUS_SUCCESS)\n\t\t\tup(&Adapter->fw_download_sema);\n\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, OSAL_DBG, DBG_LVL_ALL, \"IOCTL: Firmware File Uploaded\\n\");\n\t\tkfree(psFwInfo);\n\t\treturn Status;\n\t}\n\n\tcase IOCTL_BCM_BUFFER_DOWNLOAD_STOP: {\n\t\tif (!down_trylock(&Adapter->fw_download_sema)) {\n\t\t\tup(&Adapter->fw_download_sema);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (down_trylock(&Adapter->NVMRdmWrmLock)) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,\n\t\t\t\t\t\"FW download blocked as EEPROM Read/Write is in progress\\n\");\n\t\t\tup(&Adapter->fw_download_sema);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tAdapter->bBinDownloaded = TRUE;\n\t\tAdapter->bCfgDownloaded = TRUE;\n\t\tatomic_set(&Adapter->CurrNumFreeTxDesc, 0);\n\t\tAdapter->CurrNumRecvDescs = 0;\n\t\tAdapter->downloadDDR = 0;\n\n\t\t/* setting the Mips to Run */\n\t\tStatus = run_card_proc(Adapter);\n\n\t\tif (Status) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Firm Download Failed\\n\");\n\t\t\tup(&Adapter->fw_download_sema);\n\t\t\tup(&Adapter->NVMRdmWrmLock);\n\t\t\treturn Status;\n\t\t} else {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG,\n\t\t\t\t\tDBG_LVL_ALL, \"Firm Download Over...\\n\");\n\t\t}\n\n\t\tmdelay(10);\n\n\t\t/* Wait for MailBox Interrupt */\n\t\tif (StartInterruptUrb((struct bcm_interface_adapter *)Adapter->pvInterfaceAdapter))\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Unable to send interrupt...\\n\");\n\n\t\ttimeout = 5*HZ;\n\t\tAdapter->waiting_to_fw_download_done = FALSE;\n\t\twait_event_timeout(Adapter->ioctl_fw_dnld_wait_queue,\n\t\t\t\tAdapter->waiting_to_fw_download_done, timeout);\n\t\tAdapter->fw_download_process_pid = INVALID_PID;\n\t\tAdapter->fw_download_done = TRUE;\n\t\tatomic_set(&Adapter->CurrNumFreeTxDesc, 0);\n\t\tAdapter->CurrNumRecvDescs = 0;\n\t\tAdapter->PrevNumRecvDescs = 0;\n\t\tatomic_set(&Adapter->cntrlpktCnt, 0);\n\t\tAdapter->LinkUpStatus = 0;\n\t\tAdapter->LinkStatus = 0;\n\n\t\tif (Adapter->LEDInfo.led_thread_running & BCM_LED_THREAD_RUNNING_ACTIVELY) {\n\t\t\tAdapter->DriverState = FW_DOWNLOAD_DONE;\n\t\t\twake_up(&Adapter->LEDInfo.notify_led_event);\n\t\t}\n\n\t\tif (!timeout)\n\t\t\tStatus = -ENODEV;\n\n\t\tup(&Adapter->fw_download_sema);\n\t\tup(&Adapter->NVMRdmWrmLock);\n\t\treturn Status;\n\t}\n\n\tcase IOCTL_BE_BUCKET_SIZE:\n\t\tStatus = 0;\n\t\tif (get_user(Adapter->BEBucketSize, (unsigned long __user *)arg))\n\t\t\tStatus = -EFAULT;\n\t\tbreak;\n\n\tcase IOCTL_RTPS_BUCKET_SIZE:\n\t\tStatus = 0;\n\t\tif (get_user(Adapter->rtPSBucketSize, (unsigned long __user *)arg))\n\t\t\tStatus = -EFAULT;\n\t\tbreak;\n\n\tcase IOCTL_CHIP_RESET: {\n\t\tINT NVMAccess = down_trylock(&Adapter->NVMRdmWrmLock);\n\t\tif (NVMAccess) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \" IOCTL_BCM_CHIP_RESET not allowed as EEPROM Read/Write is in progress\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tdown(&Adapter->RxAppControlQueuelock);\n\t\tStatus = reset_card_proc(Adapter);\n\t\tflushAllAppQ();\n\t\tup(&Adapter->RxAppControlQueuelock);\n\t\tup(&Adapter->NVMRdmWrmLock);\n\t\tResetCounters(Adapter);\n\t\tbreak;\n\t}\n\n\tcase IOCTL_QOS_THRESHOLD: {\n\t\tUSHORT uiLoopIndex;\n\n\t\tStatus = 0;\n\t\tfor (uiLoopIndex = 0; uiLoopIndex < NO_OF_QUEUES; uiLoopIndex++) {\n\t\t\tif (get_user(Adapter->PackInfo[uiLoopIndex].uiThreshold,\n\t\t\t\t\t(unsigned long __user *)arg)) {\n\t\t\t\tStatus = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase IOCTL_DUMP_PACKET_INFO:\n\t\tDumpPackInfo(Adapter);\n\t\tDumpPhsRules(&Adapter->stBCMPhsContext);\n\t\tStatus = STATUS_SUCCESS;\n\t\tbreak;\n\n\tcase IOCTL_GET_PACK_INFO:\n\t\tif (copy_to_user(argp, &Adapter->PackInfo, sizeof(struct bcm_packet_info)*NO_OF_QUEUES))\n\t\t\treturn -EFAULT;\n\t\tStatus = STATUS_SUCCESS;\n\t\tbreak;\n\n\tcase IOCTL_BCM_SWITCH_TRANSFER_MODE: {\n\t\tUINT uiData = 0;\n\t\tif (copy_from_user(&uiData, argp, sizeof(UINT)))\n\t\t\treturn -EFAULT;\n\n\t\tif (uiData) {\n\t\t\t/* Allow All Packets */\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"IOCTL_BCM_SWITCH_TRANSFER_MODE: ETH_PACKET_TUNNELING_MODE\\n\");\n\t\t\t\tAdapter->TransferMode = ETH_PACKET_TUNNELING_MODE;\n\t\t} else {\n\t\t\t/* Allow IP only Packets */\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"IOCTL_BCM_SWITCH_TRANSFER_MODE: IP_PACKET_ONLY_MODE\\n\");\n\t\t\tAdapter->TransferMode = IP_PACKET_ONLY_MODE;\n\t\t}\n\t\tStatus = STATUS_SUCCESS;\n\t\tbreak;\n\t}\n\n\tcase IOCTL_BCM_GET_DRIVER_VERSION: {\n\t\tulong len;\n\n\t\t/* Copy Ioctl Buffer structure */\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tlen = min_t(ulong, IoBuffer.OutputLength, strlen(DRV_VERSION) + 1);\n\n\t\tif (copy_to_user(IoBuffer.OutputBuffer, DRV_VERSION, len))\n\t\t\treturn -EFAULT;\n\t\tStatus = STATUS_SUCCESS;\n\t\tbreak;\n\t}\n\n\tcase IOCTL_BCM_GET_CURRENT_STATUS: {\n\t\tstruct bcm_link_state link_state;\n\n\t\t/* Copy Ioctl Buffer structure */\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer))) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"copy_from_user failed..\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tif (IoBuffer.OutputLength != sizeof(link_state)) {\n\t\t\tStatus = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tmemset(&link_state, 0, sizeof(link_state));\n\t\tlink_state.bIdleMode = Adapter->IdleMode;\n\t\tlink_state.bShutdownMode = Adapter->bShutStatus;\n\t\tlink_state.ucLinkStatus = Adapter->LinkStatus;\n\n\t\tif (copy_to_user(IoBuffer.OutputBuffer, &link_state, min_t(size_t, sizeof(link_state), IoBuffer.OutputLength))) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Copy_to_user Failed..\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tStatus = STATUS_SUCCESS;\n\t\tbreak;\n\t}\n\n\tcase IOCTL_BCM_SET_MAC_TRACING: {\n\t\tUINT  tracing_flag;\n\n\t\t/* copy ioctl Buffer structure */\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (copy_from_user(&tracing_flag, IoBuffer.InputBuffer, sizeof(UINT)))\n\t\t\treturn -EFAULT;\n\n\t\tif (tracing_flag)\n\t\t\tAdapter->pTarangs->MacTracingEnabled = TRUE;\n\t\telse\n\t\t\tAdapter->pTarangs->MacTracingEnabled = FALSE;\n\t\tbreak;\n\t}\n\n\tcase IOCTL_BCM_GET_DSX_INDICATION: {\n\t\tULONG ulSFId = 0;\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (IoBuffer.OutputLength < sizeof(struct bcm_add_indication_alt)) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,\n\t\t\t\t\t\"Mismatch req: %lx needed is =0x%zx!!!\",\n\t\t\t\t\tIoBuffer.OutputLength, sizeof(struct bcm_add_indication_alt));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (copy_from_user(&ulSFId, IoBuffer.InputBuffer, sizeof(ulSFId)))\n\t\t\treturn -EFAULT;\n\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Get DSX Data SF ID is =%lx\\n\", ulSFId);\n\t\tget_dsx_sf_data_to_application(Adapter, ulSFId, IoBuffer.OutputBuffer);\n\t\tStatus = STATUS_SUCCESS;\n\t}\n\tbreak;\n\n\tcase IOCTL_BCM_GET_HOST_MIBS: {\n\t\tPVOID temp_buff;\n\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (IoBuffer.OutputLength != sizeof(struct bcm_host_stats_mibs)) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,\n\t\t\t\t\t\"Length Check failed %lu %zd\\n\",\n\t\t\t\t\tIoBuffer.OutputLength, sizeof(struct bcm_host_stats_mibs));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* FIXME: HOST_STATS are too big for kmalloc (122048)! */\n\t\ttemp_buff = kzalloc(sizeof(struct bcm_host_stats_mibs), GFP_KERNEL);\n\t\tif (!temp_buff)\n\t\t\treturn STATUS_FAILURE;\n\n\t\tStatus = ProcessGetHostMibs(Adapter, temp_buff);\n\t\tGetDroppedAppCntrlPktMibs(temp_buff, pTarang);\n\n\t\tif (Status != STATUS_FAILURE)\n\t\t\tif (copy_to_user(IoBuffer.OutputBuffer, temp_buff, sizeof(struct bcm_host_stats_mibs))) {\n\t\t\t\tkfree(temp_buff);\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\n\t\tkfree(temp_buff);\n\t\tbreak;\n\t}\n\n\tcase IOCTL_BCM_WAKE_UP_DEVICE_FROM_IDLE:\n\t\tif ((FALSE == Adapter->bTriedToWakeUpFromlowPowerMode) && (TRUE == Adapter->IdleMode)) {\n\t\t\tAdapter->usIdleModePattern = ABORT_IDLE_MODE;\n\t\t\tAdapter->bWakeUpDevice = TRUE;\n\t\t\twake_up(&Adapter->process_rx_cntrlpkt);\n\t\t}\n\n\t\tStatus = STATUS_SUCCESS;\n\t\tbreak;\n\n\tcase IOCTL_BCM_BULK_WRM: {\n\t\tstruct bcm_bulk_wrm_buffer *pBulkBuffer;\n\t\tUINT uiTempVar = 0;\n\t\tPCHAR pvBuffer = NULL;\n\n\t\tif ((Adapter->IdleMode == TRUE) ||\n\t\t\t(Adapter->bShutStatus == TRUE) ||\n\t\t\t(Adapter->bPreparingForLowPowerMode == TRUE)) {\n\n\t\t\tBCM_DEBUG_PRINT (Adapter, DBG_TYPE_PRINTK, 0, 0, \"Device in Idle/Shutdown Mode, Blocking Wrms\\n\");\n\t\t\tStatus = -EACCES;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Copy Ioctl Buffer structure */\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (IoBuffer.InputLength < sizeof(ULONG) * 2)\n\t\t\treturn -EINVAL;\n\n\t\tpvBuffer = memdup_user(IoBuffer.InputBuffer,\n\t\t\t\t       IoBuffer.InputLength);\n\t\tif (IS_ERR(pvBuffer))\n\t\t\treturn PTR_ERR(pvBuffer);\n\n\t\tpBulkBuffer = (struct bcm_bulk_wrm_buffer *)pvBuffer;\n\n\t\tif (((ULONG)pBulkBuffer->Register & 0x0F000000) != 0x0F000000 ||\n\t\t\t((ULONG)pBulkBuffer->Register & 0x3)) {\n\t\t\tBCM_DEBUG_PRINT (Adapter, DBG_TYPE_PRINTK, 0, 0, \"WRM Done On invalid Address : %x Access Denied.\\n\", (int)pBulkBuffer->Register);\n\t\t\tkfree(pvBuffer);\n\t\t\tStatus = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tuiTempVar = pBulkBuffer->Register & EEPROM_REJECT_MASK;\n\t\tif (!((Adapter->pstargetparams->m_u32Customize)&VSG_MODE) &&\n\t\t\t((uiTempVar == EEPROM_REJECT_REG_1) ||\n\t\t\t\t(uiTempVar == EEPROM_REJECT_REG_2) ||\n\t\t\t\t(uiTempVar == EEPROM_REJECT_REG_3) ||\n\t\t\t\t(uiTempVar == EEPROM_REJECT_REG_4)) &&\n\t\t\t(cmd == IOCTL_BCM_REGISTER_WRITE)) {\n\n\t\t\tkfree(pvBuffer);\n\t\t\tBCM_DEBUG_PRINT (Adapter, DBG_TYPE_PRINTK, 0, 0, \"EEPROM Access Denied, not in VSG Mode\\n\");\n\t\t\tStatus = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (pBulkBuffer->SwapEndian == FALSE)\n\t\t\tStatus = wrmWithLock(Adapter, (UINT)pBulkBuffer->Register, (PCHAR)pBulkBuffer->Values, IoBuffer.InputLength - 2*sizeof(ULONG));\n\t\telse\n\t\t\tStatus = wrmaltWithLock(Adapter, (UINT)pBulkBuffer->Register, (PUINT)pBulkBuffer->Values, IoBuffer.InputLength - 2*sizeof(ULONG));\n\n\t\tif (Status != STATUS_SUCCESS)\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"WRM Failed\\n\");\n\n\t\tkfree(pvBuffer);\n\t\tbreak;\n\t}\n\n\tcase IOCTL_BCM_GET_NVM_SIZE:\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (Adapter->eNVMType == NVM_EEPROM || Adapter->eNVMType == NVM_FLASH) {\n\t\t\tif (copy_to_user(IoBuffer.OutputBuffer, &Adapter->uiNVMDSDSize, sizeof(UINT)))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tStatus = STATUS_SUCCESS;\n\t\tbreak;\n\n\tcase IOCTL_BCM_CAL_INIT: {\n\t\tUINT uiSectorSize = 0 ;\n\t\tif (Adapter->eNVMType == NVM_FLASH) {\n\t\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tif (copy_from_user(&uiSectorSize, IoBuffer.InputBuffer, sizeof(UINT)))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tif ((uiSectorSize < MIN_SECTOR_SIZE) || (uiSectorSize > MAX_SECTOR_SIZE)) {\n\t\t\t\tif (copy_to_user(IoBuffer.OutputBuffer, &Adapter->uiSectorSize,\n\t\t\t\t\t\t\tsizeof(UINT)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t} else {\n\t\t\t\tif (IsFlash2x(Adapter)) {\n\t\t\t\t\tif (copy_to_user(IoBuffer.OutputBuffer,\t&Adapter->uiSectorSize, sizeof(UINT)))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t} else {\n\t\t\t\t\tif ((TRUE == Adapter->bShutStatus) || (TRUE == Adapter->IdleMode)) {\n\t\t\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Device is in Idle/Shutdown Mode\\n\");\n\t\t\t\t\t\treturn -EACCES;\n\t\t\t\t\t}\n\n\t\t\t\t\tAdapter->uiSectorSize = uiSectorSize;\n\t\t\t\t\tBcmUpdateSectorSize(Adapter, Adapter->uiSectorSize);\n\t\t\t\t}\n\t\t\t}\n\t\t\tStatus = STATUS_SUCCESS;\n\t\t} else {\n\t\t\tStatus = STATUS_FAILURE;\n\t\t}\n\t}\n\tbreak;\n\n\tcase IOCTL_BCM_SET_DEBUG:\n#ifdef DEBUG\n\t{\n\t\tstruct bcm_user_debug_state sUserDebugState;\n\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"In SET_DEBUG ioctl\\n\");\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (copy_from_user(&sUserDebugState, IoBuffer.InputBuffer, sizeof(struct bcm_user_debug_state)))\n\t\t\treturn -EFAULT;\n\n\t\tBCM_DEBUG_PRINT (Adapter, DBG_TYPE_PRINTK, 0, 0, \"IOCTL_BCM_SET_DEBUG: OnOff=%d Type = 0x%x \",\n\t\t\t\tsUserDebugState.OnOff, sUserDebugState.Type);\n\t\t/* sUserDebugState.Subtype <<= 1; */\n\t\tsUserDebugState.Subtype = 1 << sUserDebugState.Subtype;\n\t\tBCM_DEBUG_PRINT (Adapter, DBG_TYPE_PRINTK, 0, 0, \"actual Subtype=0x%x\\n\", sUserDebugState.Subtype);\n\n\t\t/* Update new 'DebugState' in the Adapter */\n\t\tAdapter->stDebugState.type |= sUserDebugState.Type;\n\t\t/* Subtype: A bitmap of 32 bits for Subtype per Type.\n\t\t * Valid indexes in 'subtype' array: 1,2,4,8\n\t\t * corresponding to valid Type values. Hence we can use the 'Type' field\n\t\t * as the index value, ignoring the array entries 0,3,5,6,7 !\n\t\t */\n\t\tif (sUserDebugState.OnOff)\n\t\t\tAdapter->stDebugState.subtype[sUserDebugState.Type] |= sUserDebugState.Subtype;\n\t\telse\n\t\t\tAdapter->stDebugState.subtype[sUserDebugState.Type] &= ~sUserDebugState.Subtype;\n\n\t\tBCM_SHOW_DEBUG_BITMAP(Adapter);\n\t}\n#endif\n\tbreak;\n\n\tcase IOCTL_BCM_NVM_READ:\n\tcase IOCTL_BCM_NVM_WRITE: {\n\t\tstruct bcm_nvm_readwrite stNVMReadWrite;\n\t\tPUCHAR pReadData = NULL;\n\t\tULONG ulDSDMagicNumInUsrBuff = 0;\n\t\tstruct timeval tv0, tv1;\n\t\tmemset(&tv0, 0, sizeof(struct timeval));\n\t\tmemset(&tv1, 0, sizeof(struct timeval));\n\t\tif ((Adapter->eNVMType == NVM_FLASH) && (Adapter->uiFlashLayoutMajorVersion == 0)) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"The Flash Control Section is Corrupted. Hence Rejection on NVM Read/Write\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tif (IsFlash2x(Adapter)) {\n\t\t\tif ((Adapter->eActiveDSD != DSD0) &&\n\t\t\t\t(Adapter->eActiveDSD != DSD1) &&\n\t\t\t\t(Adapter->eActiveDSD != DSD2)) {\n\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"No DSD is active..hence NVM Command is blocked\");\n\t\t\t\treturn STATUS_FAILURE;\n\t\t\t}\n\t\t}\n\n\t\t/* Copy Ioctl Buffer structure */\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (copy_from_user(&stNVMReadWrite,\n\t\t\t\t\t(IOCTL_BCM_NVM_READ == cmd) ? IoBuffer.OutputBuffer : IoBuffer.InputBuffer,\n\t\t\t\t\tsizeof(struct bcm_nvm_readwrite)))\n\t\t\treturn -EFAULT;\n\n\t\t/*\n\t\t * Deny the access if the offset crosses the cal area limit.\n\t\t */\n\t\tif (stNVMReadWrite.uiNumBytes > Adapter->uiNVMDSDSize)\n\t\t\treturn STATUS_FAILURE;\n\n\t\tif (stNVMReadWrite.uiOffset > Adapter->uiNVMDSDSize - stNVMReadWrite.uiNumBytes) {\n\t\t\t/* BCM_DEBUG_PRINT(Adapter,DBG_TYPE_PRINTK, 0, 0,\"Can't allow access beyond NVM Size: 0x%x 0x%x\\n\", stNVMReadWrite.uiOffset, stNVMReadWrite.uiNumBytes); */\n\t\t\treturn STATUS_FAILURE;\n\t\t}\n\n\t\tpReadData = memdup_user(stNVMReadWrite.pBuffer,\n\t\t\t\t\tstNVMReadWrite.uiNumBytes);\n\t\tif (IS_ERR(pReadData))\n\t\t\treturn PTR_ERR(pReadData);\n\n\t\tdo_gettimeofday(&tv0);\n\t\tif (IOCTL_BCM_NVM_READ == cmd) {\n\t\t\tdown(&Adapter->NVMRdmWrmLock);\n\n\t\t\tif ((Adapter->IdleMode == TRUE) ||\n\t\t\t\t(Adapter->bShutStatus == TRUE) ||\n\t\t\t\t(Adapter->bPreparingForLowPowerMode == TRUE)) {\n\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Device is in Idle/Shutdown Mode\\n\");\n\t\t\t\tup(&Adapter->NVMRdmWrmLock);\n\t\t\t\tkfree(pReadData);\n\t\t\t\treturn -EACCES;\n\t\t\t}\n\n\t\t\tStatus = BeceemNVMRead(Adapter, (PUINT)pReadData, stNVMReadWrite.uiOffset, stNVMReadWrite.uiNumBytes);\n\t\t\tup(&Adapter->NVMRdmWrmLock);\n\n\t\t\tif (Status != STATUS_SUCCESS) {\n\t\t\t\tkfree(pReadData);\n\t\t\t\treturn Status;\n\t\t\t}\n\n\t\t\tif (copy_to_user(stNVMReadWrite.pBuffer, pReadData, stNVMReadWrite.uiNumBytes)) {\n\t\t\t\tkfree(pReadData);\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t} else {\n\t\t\tdown(&Adapter->NVMRdmWrmLock);\n\n\t\t\tif ((Adapter->IdleMode == TRUE) ||\n\t\t\t\t(Adapter->bShutStatus == TRUE) ||\n\t\t\t\t(Adapter->bPreparingForLowPowerMode == TRUE)) {\n\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Device is in Idle/Shutdown Mode\\n\");\n\t\t\t\tup(&Adapter->NVMRdmWrmLock);\n\t\t\t\tkfree(pReadData);\n\t\t\t\treturn -EACCES;\n\t\t\t}\n\n\t\t\tAdapter->bHeaderChangeAllowed = TRUE;\n\t\t\tif (IsFlash2x(Adapter)) {\n\t\t\t\t/*\n\t\t\t\t *\t\t\tNew Requirement:-\n\t\t\t\t *\t\t\tDSD section updation will be allowed in two case:-\n\t\t\t\t *\t\t\t1.  if DSD sig is present in DSD header means dongle is ok and updation is fruitfull\n\t\t\t\t *\t\t\t2.  if point 1 failes then user buff should have DSD sig. this point ensures that if dongle is\n\t\t\t\t *\t\t\t      corrupted then user space program first modify the DSD header with valid DSD sig so\n\t\t\t\t *\t\t\t      that this as well as further write may be worthwhile.\n\t\t\t\t *\n\t\t\t\t *\t\t\t This restriction has been put assuming that if DSD sig is corrupted, DSD\n\t\t\t\t *\t\t\t data won't be considered valid.\n\t\t\t\t */\n\n\t\t\t\tStatus = BcmFlash2xCorruptSig(Adapter, Adapter->eActiveDSD);\n\t\t\t\tif (Status != STATUS_SUCCESS) {\n\t\t\t\t\tif (((stNVMReadWrite.uiOffset + stNVMReadWrite.uiNumBytes) != Adapter->uiNVMDSDSize) ||\n\t\t\t\t\t\t(stNVMReadWrite.uiNumBytes < SIGNATURE_SIZE)) {\n\n\t\t\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"DSD Sig is present neither in Flash nor User provided Input..\");\n\t\t\t\t\t\tup(&Adapter->NVMRdmWrmLock);\n\t\t\t\t\t\tkfree(pReadData);\n\t\t\t\t\t\treturn Status;\n\t\t\t\t\t}\n\n\t\t\t\t\tulDSDMagicNumInUsrBuff = ntohl(*(PUINT)(pReadData + stNVMReadWrite.uiNumBytes - SIGNATURE_SIZE));\n\t\t\t\t\tif (ulDSDMagicNumInUsrBuff != DSD_IMAGE_MAGIC_NUMBER) {\n\t\t\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"DSD Sig is present neither in Flash nor User provided Input..\");\n\t\t\t\t\t\tup(&Adapter->NVMRdmWrmLock);\n\t\t\t\t\t\tkfree(pReadData);\n\t\t\t\t\t\treturn Status;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tStatus = BeceemNVMWrite(Adapter, (PUINT)pReadData, stNVMReadWrite.uiOffset, stNVMReadWrite.uiNumBytes, stNVMReadWrite.bVerify);\n\t\t\tif (IsFlash2x(Adapter))\n\t\t\t\tBcmFlash2xWriteSig(Adapter, Adapter->eActiveDSD);\n\n\t\t\tAdapter->bHeaderChangeAllowed = FALSE;\n\n\t\t\tup(&Adapter->NVMRdmWrmLock);\n\n\t\t\tif (Status != STATUS_SUCCESS) {\n\t\t\t\tkfree(pReadData);\n\t\t\t\treturn Status;\n\t\t\t}\n\t\t}\n\n\t\tdo_gettimeofday(&tv1);\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \" timetaken by Write/read :%ld msec\\n\", (tv1.tv_sec - tv0.tv_sec)*1000 + (tv1.tv_usec - tv0.tv_usec)/1000);\n\n\t\tkfree(pReadData);\n\t\treturn STATUS_SUCCESS;\n\t}\n\n\tcase IOCTL_BCM_FLASH2X_SECTION_READ: {\n\t\tstruct bcm_flash2x_readwrite sFlash2xRead = {0};\n\t\tPUCHAR pReadBuff = NULL ;\n\t\tUINT NOB = 0;\n\t\tUINT BuffSize = 0;\n\t\tUINT ReadBytes = 0;\n\t\tUINT ReadOffset = 0;\n\t\tvoid __user *OutPutBuff;\n\n\t\tif (IsFlash2x(Adapter) != TRUE)\t{\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Flash Does not have 2.x map\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"IOCTL_BCM_FLASH2X_SECTION_READ Called\");\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\t/* Reading FLASH 2.x READ structure */\n\t\tif (copy_from_user(&sFlash2xRead, IoBuffer.InputBuffer, sizeof(struct bcm_flash2x_readwrite)))\n\t\t\treturn -EFAULT;\n\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"\\nsFlash2xRead.Section :%x\", sFlash2xRead.Section);\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"\\nsFlash2xRead.offset :%x\", sFlash2xRead.offset);\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"\\nsFlash2xRead.numOfBytes :%x\", sFlash2xRead.numOfBytes);\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"\\nsFlash2xRead.bVerify :%x\\n\", sFlash2xRead.bVerify);\n\n\t\t/* This was internal to driver for raw read. now it has ben exposed to user space app. */\n\t\tif (validateFlash2xReadWrite(Adapter, &sFlash2xRead) == FALSE)\n\t\t\treturn STATUS_FAILURE;\n\n\t\tNOB = sFlash2xRead.numOfBytes;\n\t\tif (NOB > Adapter->uiSectorSize)\n\t\t\tBuffSize = Adapter->uiSectorSize;\n\t\telse\n\t\t\tBuffSize = NOB;\n\n\t\tReadOffset = sFlash2xRead.offset ;\n\t\tOutPutBuff = IoBuffer.OutputBuffer;\n\t\tpReadBuff = (PCHAR)kzalloc(BuffSize , GFP_KERNEL);\n\n\t\tif (pReadBuff == NULL) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Memory allocation failed for Flash 2.x Read Structure\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tdown(&Adapter->NVMRdmWrmLock);\n\n\t\tif ((Adapter->IdleMode == TRUE) ||\n\t\t\t(Adapter->bShutStatus == TRUE) ||\n\t\t\t(Adapter->bPreparingForLowPowerMode == TRUE)) {\n\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Device is in Idle/Shutdown Mode\\n\");\n\t\t\tup(&Adapter->NVMRdmWrmLock);\n\t\t\tkfree(pReadBuff);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\twhile (NOB) {\n\t\t\tif (NOB > Adapter->uiSectorSize)\n\t\t\t\tReadBytes = Adapter->uiSectorSize;\n\t\t\telse\n\t\t\t\tReadBytes = NOB;\n\n\t\t\t/* Reading the data from Flash 2.x */\n\t\t\tStatus = BcmFlash2xBulkRead(Adapter, (PUINT)pReadBuff, sFlash2xRead.Section, ReadOffset, ReadBytes);\n\t\t\tif (Status) {\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Flash 2x read err with Status :%d\", Status);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tBCM_DEBUG_PRINT_BUFFER(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, pReadBuff, ReadBytes);\n\n\t\t\tStatus = copy_to_user(OutPutBuff, pReadBuff, ReadBytes);\n\t\t\tif (Status) {\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Copy to use failed with status :%d\", Status);\n\t\t\t\tup(&Adapter->NVMRdmWrmLock);\n\t\t\t\tkfree(pReadBuff);\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t\tNOB = NOB - ReadBytes;\n\t\t\tif (NOB) {\n\t\t\t\tReadOffset = ReadOffset + ReadBytes;\n\t\t\t\tOutPutBuff = OutPutBuff + ReadBytes ;\n\t\t\t}\n\t\t}\n\n\t\tup(&Adapter->NVMRdmWrmLock);\n\t\tkfree(pReadBuff);\n\t}\n\tbreak;\n\n\tcase IOCTL_BCM_FLASH2X_SECTION_WRITE: {\n\t\tstruct bcm_flash2x_readwrite sFlash2xWrite = {0};\n\t\tPUCHAR pWriteBuff;\n\t\tvoid __user *InputAddr;\n\t\tUINT NOB = 0;\n\t\tUINT BuffSize = 0;\n\t\tUINT WriteOffset = 0;\n\t\tUINT WriteBytes = 0;\n\n\t\tif (IsFlash2x(Adapter) != TRUE) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Flash Does not have 2.x map\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* First make this False so that we can enable the Sector Permission Check in BeceemFlashBulkWrite */\n\t\tAdapter->bAllDSDWriteAllow = FALSE;\n\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"IOCTL_BCM_FLASH2X_SECTION_WRITE Called\");\n\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\t/* Reading FLASH 2.x READ structure */\n\t\tif (copy_from_user(&sFlash2xWrite, IoBuffer.InputBuffer, sizeof(struct bcm_flash2x_readwrite)))\n\t\t\treturn -EFAULT;\n\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"\\nsFlash2xRead.Section :%x\", sFlash2xWrite.Section);\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"\\nsFlash2xRead.offset :%d\", sFlash2xWrite.offset);\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"\\nsFlash2xRead.numOfBytes :%x\", sFlash2xWrite.numOfBytes);\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"\\nsFlash2xRead.bVerify :%x\\n\", sFlash2xWrite.bVerify);\n\n\t\tif ((sFlash2xWrite.Section != VSA0) && (sFlash2xWrite.Section != VSA1) && (sFlash2xWrite.Section != VSA2)) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Only VSA write is allowed\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (validateFlash2xReadWrite(Adapter, &sFlash2xWrite) == FALSE)\n\t\t\treturn STATUS_FAILURE;\n\n\t\tInputAddr = sFlash2xWrite.pDataBuff;\n\t\tWriteOffset = sFlash2xWrite.offset;\n\t\tNOB = sFlash2xWrite.numOfBytes;\n\n\t\tif (NOB > Adapter->uiSectorSize)\n\t\t\tBuffSize = Adapter->uiSectorSize;\n\t\telse\n\t\t\tBuffSize = NOB ;\n\n\t\tpWriteBuff = kmalloc(BuffSize, GFP_KERNEL);\n\n\t\tif (pWriteBuff == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\t/* extracting the remainder of the given offset. */\n\t\tWriteBytes = Adapter->uiSectorSize;\n\t\tif (WriteOffset % Adapter->uiSectorSize)\n\t\t\tWriteBytes = Adapter->uiSectorSize - (WriteOffset % Adapter->uiSectorSize);\n\n\t\tif (NOB < WriteBytes)\n\t\t\tWriteBytes = NOB;\n\n\t\tdown(&Adapter->NVMRdmWrmLock);\n\n\t\tif ((Adapter->IdleMode == TRUE) ||\n\t\t\t(Adapter->bShutStatus == TRUE) ||\n\t\t\t(Adapter->bPreparingForLowPowerMode == TRUE)) {\n\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Device is in Idle/Shutdown Mode\\n\");\n\t\t\tup(&Adapter->NVMRdmWrmLock);\n\t\t\tkfree(pWriteBuff);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tBcmFlash2xCorruptSig(Adapter, sFlash2xWrite.Section);\n\t\tdo {\n\t\t\tStatus = copy_from_user(pWriteBuff, InputAddr, WriteBytes);\n\t\t\tif (Status) {\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Copy to user failed with status :%d\", Status);\n\t\t\t\tup(&Adapter->NVMRdmWrmLock);\n\t\t\t\tkfree(pWriteBuff);\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t\tBCM_DEBUG_PRINT_BUFFER(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, pWriteBuff, WriteBytes);\n\n\t\t\t/* Writing the data from Flash 2.x */\n\t\t\tStatus = BcmFlash2xBulkWrite(Adapter, (PUINT)pWriteBuff, sFlash2xWrite.Section, WriteOffset, WriteBytes, sFlash2xWrite.bVerify);\n\n\t\t\tif (Status) {\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Flash 2x read err with Status :%d\", Status);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tNOB = NOB - WriteBytes;\n\t\t\tif (NOB) {\n\t\t\t\tWriteOffset = WriteOffset + WriteBytes;\n\t\t\t\tInputAddr = InputAddr + WriteBytes;\n\t\t\t\tif (NOB > Adapter->uiSectorSize)\n\t\t\t\t\tWriteBytes = Adapter->uiSectorSize;\n\t\t\t\telse\n\t\t\t\t\tWriteBytes = NOB;\n\t\t\t}\n\t\t} while (NOB > 0);\n\n\t\tBcmFlash2xWriteSig(Adapter, sFlash2xWrite.Section);\n\t\tup(&Adapter->NVMRdmWrmLock);\n\t\tkfree(pWriteBuff);\n\t}\n\tbreak;\n\n\tcase IOCTL_BCM_GET_FLASH2X_SECTION_BITMAP: {\n\t\tstruct bcm_flash2x_bitmap *psFlash2xBitMap;\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"IOCTL_BCM_GET_FLASH2X_SECTION_BITMAP Called\");\n\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (IoBuffer.OutputLength != sizeof(struct bcm_flash2x_bitmap))\n\t\t\treturn -EINVAL;\n\n\t\tpsFlash2xBitMap = kzalloc(sizeof(struct bcm_flash2x_bitmap), GFP_KERNEL);\n\t\tif (psFlash2xBitMap == NULL) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Memory is not available\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\t/* Reading the Flash Sectio Bit map */\n\t\tdown(&Adapter->NVMRdmWrmLock);\n\n\t\tif ((Adapter->IdleMode == TRUE) ||\n\t\t\t(Adapter->bShutStatus == TRUE) ||\n\t\t\t(Adapter->bPreparingForLowPowerMode == TRUE)) {\n\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Device is in Idle/Shutdown Mode\\n\");\n\t\t\tup(&Adapter->NVMRdmWrmLock);\n\t\t\tkfree(psFlash2xBitMap);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tBcmGetFlash2xSectionalBitMap(Adapter, psFlash2xBitMap);\n\t\tup(&Adapter->NVMRdmWrmLock);\n\t\tif (copy_to_user(IoBuffer.OutputBuffer, psFlash2xBitMap, sizeof(struct bcm_flash2x_bitmap))) {\n\t\t\tkfree(psFlash2xBitMap);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tkfree(psFlash2xBitMap);\n\t}\n\tbreak;\n\n\tcase IOCTL_BCM_SET_ACTIVE_SECTION: {\n\t\tenum bcm_flash2x_section_val eFlash2xSectionVal = 0;\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"IOCTL_BCM_SET_ACTIVE_SECTION Called\");\n\n\t\tif (IsFlash2x(Adapter) != TRUE) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Flash Does not have 2.x map\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tStatus = copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer));\n\t\tif (Status) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Copy of IOCTL BUFFER failed\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tStatus = copy_from_user(&eFlash2xSectionVal, IoBuffer.InputBuffer, sizeof(INT));\n\t\tif (Status) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Copy of flash section val failed\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tdown(&Adapter->NVMRdmWrmLock);\n\n\t\tif ((Adapter->IdleMode == TRUE) ||\n\t\t\t(Adapter->bShutStatus == TRUE) ||\n\t\t\t(Adapter->bPreparingForLowPowerMode == TRUE)) {\n\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Device is in Idle/Shutdown Mode\\n\");\n\t\t\tup(&Adapter->NVMRdmWrmLock);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tStatus = BcmSetActiveSection(Adapter, eFlash2xSectionVal);\n\t\tif (Status)\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Failed to make it's priority Highest. Status %d\", Status);\n\n\t\tup(&Adapter->NVMRdmWrmLock);\n\t}\n\tbreak;\n\n\tcase IOCTL_BCM_IDENTIFY_ACTIVE_SECTION: {\n\t\t/* Right Now we are taking care of only DSD */\n\t\tAdapter->bAllDSDWriteAllow = FALSE;\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"IOCTL_BCM_IDENTIFY_ACTIVE_SECTION called\");\n\t\tStatus = STATUS_SUCCESS;\n\t}\n\tbreak;\n\n\tcase IOCTL_BCM_COPY_SECTION: {\n\t\tstruct bcm_flash2x_copy_section sCopySectStrut = {0};\n\t\tStatus = STATUS_SUCCESS;\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"IOCTL_BCM_COPY_SECTION  Called\");\n\n\t\tAdapter->bAllDSDWriteAllow = FALSE;\n\t\tif (IsFlash2x(Adapter) != TRUE) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Flash Does not have 2.x map\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tStatus = copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer));\n\t\tif (Status) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Copy of IOCTL BUFFER failed Status :%d\", Status);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tStatus = copy_from_user(&sCopySectStrut, IoBuffer.InputBuffer, sizeof(struct bcm_flash2x_copy_section));\n\t\tif (Status) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Copy of Copy_Section_Struct failed with Status :%d\", Status);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Source SEction :%x\", sCopySectStrut.SrcSection);\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Destination SEction :%x\", sCopySectStrut.DstSection);\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"offset :%x\", sCopySectStrut.offset);\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"NOB :%x\", sCopySectStrut.numOfBytes);\n\n\t\tif (IsSectionExistInFlash(Adapter, sCopySectStrut.SrcSection) == FALSE) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Source Section<%x> does not exixt in Flash \", sCopySectStrut.SrcSection);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (IsSectionExistInFlash(Adapter, sCopySectStrut.DstSection) == FALSE) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Destinatio Section<%x> does not exixt in Flash \", sCopySectStrut.DstSection);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (sCopySectStrut.SrcSection == sCopySectStrut.DstSection) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Source and Destination section should be different\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdown(&Adapter->NVMRdmWrmLock);\n\n\t\tif ((Adapter->IdleMode == TRUE) ||\n\t\t\t(Adapter->bShutStatus == TRUE) ||\n\t\t\t(Adapter->bPreparingForLowPowerMode == TRUE)) {\n\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Device is in Idle/Shutdown Mode\\n\");\n\t\t\tup(&Adapter->NVMRdmWrmLock);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (sCopySectStrut.SrcSection == ISO_IMAGE1 || sCopySectStrut.SrcSection == ISO_IMAGE2) {\n\t\t\tif (IsNonCDLessDevice(Adapter)) {\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Device is Non-CDLess hence won't have ISO !!\");\n\t\t\t\tStatus = -EINVAL;\n\t\t\t} else if (sCopySectStrut.numOfBytes == 0) {\n\t\t\t\tStatus = BcmCopyISO(Adapter, sCopySectStrut);\n\t\t\t} else {\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Partial Copy of ISO section is not Allowed..\");\n\t\t\t\tStatus = STATUS_FAILURE;\n\t\t\t}\n\t\t\tup(&Adapter->NVMRdmWrmLock);\n\t\t\treturn Status;\n\t\t}\n\n\t\tStatus = BcmCopySection(Adapter, sCopySectStrut.SrcSection,\n\t\t\t\t\tsCopySectStrut.DstSection, sCopySectStrut.offset, sCopySectStrut.numOfBytes);\n\t\tup(&Adapter->NVMRdmWrmLock);\n\t}\n\tbreak;\n\n\tcase IOCTL_BCM_GET_FLASH_CS_INFO: {\n\t\tStatus = STATUS_SUCCESS;\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \" IOCTL_BCM_GET_FLASH_CS_INFO Called\");\n\n\t\tStatus = copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer));\n\t\tif (Status) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Copy of IOCTL BUFFER failed\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tif (Adapter->eNVMType != NVM_FLASH) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Connected device does not have flash\");\n\t\t\tStatus = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (IsFlash2x(Adapter) == TRUE) {\n\t\t\tif (IoBuffer.OutputLength < sizeof(struct bcm_flash2x_cs_info))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (copy_to_user(IoBuffer.OutputBuffer, Adapter->psFlash2xCSInfo, sizeof(struct bcm_flash2x_cs_info)))\n\t\t\t\treturn -EFAULT;\n\t\t} else {\n\t\t\tif (IoBuffer.OutputLength < sizeof(struct bcm_flash_cs_info))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (copy_to_user(IoBuffer.OutputBuffer, Adapter->psFlashCSInfo, sizeof(struct bcm_flash_cs_info)))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\tbreak;\n\n\tcase IOCTL_BCM_SELECT_DSD: {\n\t\tUINT SectOfset = 0;\n\t\tenum bcm_flash2x_section_val eFlash2xSectionVal;\n\t\teFlash2xSectionVal = NO_SECTION_VAL;\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"IOCTL_BCM_SELECT_DSD Called\");\n\n\t\tif (IsFlash2x(Adapter) != TRUE) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Flash Does not have 2.x map\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tStatus = copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer));\n\t\tif (Status) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Copy of IOCTL BUFFER failed\");\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tStatus = copy_from_user(&eFlash2xSectionVal, IoBuffer.InputBuffer, sizeof(INT));\n\t\tif (Status) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Copy of flash section val failed\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Read Section :%d\", eFlash2xSectionVal);\n\t\tif ((eFlash2xSectionVal != DSD0) &&\n\t\t\t(eFlash2xSectionVal != DSD1) &&\n\t\t\t(eFlash2xSectionVal != DSD2)) {\n\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Passed section<%x> is not DSD section\", eFlash2xSectionVal);\n\t\t\treturn STATUS_FAILURE;\n\t\t}\n\n\t\tSectOfset = BcmGetSectionValStartOffset(Adapter, eFlash2xSectionVal);\n\t\tif (SectOfset == INVALID_OFFSET) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Provided Section val <%d> does not exixt in Flash 2.x\", eFlash2xSectionVal);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tAdapter->bAllDSDWriteAllow = TRUE;\n\t\tAdapter->ulFlashCalStart = SectOfset;\n\t\tAdapter->eActiveDSD = eFlash2xSectionVal;\n\t}\n\tStatus = STATUS_SUCCESS;\n\tbreak;\n\n\tcase IOCTL_BCM_NVM_RAW_READ: {\n\t\tstruct bcm_nvm_readwrite stNVMRead;\n\t\tINT NOB ;\n\t\tINT BuffSize ;\n\t\tINT ReadOffset = 0;\n\t\tUINT ReadBytes = 0 ;\n\t\tPUCHAR pReadBuff;\n\t\tvoid __user *OutPutBuff;\n\n\t\tif (Adapter->eNVMType != NVM_FLASH) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"NVM TYPE is not Flash\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* Copy Ioctl Buffer structure */\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer))) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"copy_from_user 1 failed\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tif (copy_from_user(&stNVMRead, IoBuffer.OutputBuffer, sizeof(struct bcm_nvm_readwrite)))\n\t\t\treturn -EFAULT;\n\n\t\tNOB = stNVMRead.uiNumBytes;\n\t\t/* In Raw-Read max Buff size : 64MB */\n\n\t\tif (NOB > DEFAULT_BUFF_SIZE)\n\t\t\tBuffSize = DEFAULT_BUFF_SIZE;\n\t\telse\n\t\t\tBuffSize = NOB;\n\n\t\tReadOffset = stNVMRead.uiOffset;\n\t\tOutPutBuff = stNVMRead.pBuffer;\n\n\t\tpReadBuff = kzalloc(BuffSize , GFP_KERNEL);\n\t\tif (pReadBuff == NULL) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Memory allocation failed for Flash 2.x Read Structure\");\n\t\t\tStatus = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\tdown(&Adapter->NVMRdmWrmLock);\n\n\t\tif ((Adapter->IdleMode == TRUE) ||\n\t\t\t(Adapter->bShutStatus == TRUE) ||\n\t\t\t(Adapter->bPreparingForLowPowerMode == TRUE)) {\n\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Device is in Idle/Shutdown Mode\\n\");\n\t\t\tkfree(pReadBuff);\n\t\t\tup(&Adapter->NVMRdmWrmLock);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tAdapter->bFlashRawRead = TRUE;\n\n\t\twhile (NOB) {\n\t\t\tif (NOB > DEFAULT_BUFF_SIZE)\n\t\t\t\tReadBytes = DEFAULT_BUFF_SIZE;\n\t\t\telse\n\t\t\t\tReadBytes = NOB;\n\n\t\t\t/* Reading the data from Flash 2.x */\n\t\t\tStatus = BeceemNVMRead(Adapter, (PUINT)pReadBuff, ReadOffset, ReadBytes);\n\t\t\tif (Status) {\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Flash 2x read err with Status :%d\", Status);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tBCM_DEBUG_PRINT_BUFFER(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, pReadBuff, ReadBytes);\n\n\t\t\tStatus = copy_to_user(OutPutBuff, pReadBuff, ReadBytes);\n\t\t\tif (Status) {\n\t\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"Copy to use failed with status :%d\", Status);\n\t\t\t\tup(&Adapter->NVMRdmWrmLock);\n\t\t\t\tkfree(pReadBuff);\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t\tNOB = NOB - ReadBytes;\n\t\t\tif (NOB) {\n\t\t\t\tReadOffset = ReadOffset + ReadBytes;\n\t\t\t\tOutPutBuff = OutPutBuff + ReadBytes;\n\t\t\t}\n\t\t}\n\t\tAdapter->bFlashRawRead = FALSE;\n\t\tup(&Adapter->NVMRdmWrmLock);\n\t\tkfree(pReadBuff);\n\t\tbreak;\n\t}\n\n\tcase IOCTL_BCM_CNTRLMSG_MASK: {\n\t\tULONG RxCntrlMsgBitMask = 0;\n\n\t\t/* Copy Ioctl Buffer structure */\n\t\tStatus = copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer));\n\t\tif (Status) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"copy of Ioctl buffer is failed from user space\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tif (IoBuffer.InputLength != sizeof(unsigned long)) {\n\t\t\tStatus = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tStatus = copy_from_user(&RxCntrlMsgBitMask, IoBuffer.InputBuffer, IoBuffer.InputLength);\n\t\tif (Status) {\n\t\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"copy of control bit mask failed from user space\");\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"\\n Got user defined cntrl msg bit mask :%lx\", RxCntrlMsgBitMask);\n\t\tpTarang->RxCntrlMsgBitMask = RxCntrlMsgBitMask;\n\t}\n\tbreak;\n\n\tcase IOCTL_BCM_GET_DEVICE_DRIVER_INFO: {\n\t\tstruct bcm_driver_info DevInfo;\n \n \t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Called IOCTL_BCM_GET_DEVICE_DRIVER_INFO\\n\");\n \n \t\tDevInfo.MaxRDMBufferSize = BUFFER_4K;\n \t\tDevInfo.u32DSDStartOffset = EEPROM_CALPARAM_START;\n \t\tDevInfo.u32RxAlignmentCorrection = 0;\n\t\tDevInfo.u32NVMType = Adapter->eNVMType;\n\t\tDevInfo.u32InterfaceType = BCM_USB;\n\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (IoBuffer.OutputLength < sizeof(DevInfo))\n\t\t\treturn -EINVAL;\n\n\t\tif (copy_to_user(IoBuffer.OutputBuffer, &DevInfo, sizeof(DevInfo)))\n\t\t\treturn -EFAULT;\n\t}\n\tbreak;\n\n\tcase IOCTL_BCM_TIME_SINCE_NET_ENTRY: {\n\t\tstruct bcm_time_elapsed stTimeElapsedSinceNetEntry = {0};\n\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"IOCTL_BCM_TIME_SINCE_NET_ENTRY called\");\n\n\t\tif (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))\n\t\t\treturn -EFAULT;\n\n\t\tif (IoBuffer.OutputLength < sizeof(struct bcm_time_elapsed))\n\t\t\treturn -EINVAL;\n\n\t\tstTimeElapsedSinceNetEntry.ul64TimeElapsedSinceNetEntry = get_seconds() - Adapter->liTimeSinceLastNetEntry;\n\n\t\tif (copy_to_user(IoBuffer.OutputBuffer, &stTimeElapsedSinceNetEntry, sizeof(struct bcm_time_elapsed)))\n\t\t\treturn -EFAULT;\n\t}\n\tbreak;\n\n\tcase IOCTL_CLOSE_NOTIFICATION:\n\t\tBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"IOCTL_CLOSE_NOTIFICATION\");\n\t\tbreak;\n\n\tdefault:\n\t\tpr_info(DRV_NAME \": unknown ioctl cmd=%#x\\n\", cmd);\n\t\tStatus = STATUS_FAILURE;\n\t\tbreak;\n\t}\n\treturn Status;\n}\n", "target": 1, "idx": 179134}
{"func": "int udpv6_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,\n\t\t  int noblock, int flags, int *addr_len)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct sk_buff *skb;\n\tunsigned int ulen, copied;\n \tint peeked, off = 0;\n \tint err;\n \tint is_udplite = IS_UDPLITE(sk);\n \tint is_udp4;\n \tbool slow;\n \n\tif (flags & MSG_ERRQUEUE)\n\t\treturn ipv6_recv_error(sk, msg, len, addr_len);\n\n\tif (np->rxpmtu && np->rxopt.bits.rxpmtu)\n\t\treturn ipv6_recv_rxpmtu(sk, msg, len, addr_len);\n\ntry_again:\n\tskb = __skb_recv_datagram(sk, flags | (noblock ? MSG_DONTWAIT : 0),\n\t\t\t\t  &peeked, &off, &err);\n\tif (!skb)\n\t\tgoto out;\n\n\tulen = skb->len - sizeof(struct udphdr);\n\tcopied = len;\n\tif (copied > ulen)\n\t\tcopied = ulen;\n\telse if (copied < ulen)\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\n\tis_udp4 = (skb->protocol == htons(ETH_P_IP));\n\n\t/*\n\t * If checksum is needed at all, try to do it while copying the\n\t * data.  If the data is truncated, or if we only want a partial\n\t * coverage checksum (UDP-Lite), do it before the copy.\n \t */\n \n \tif (copied < ulen || UDP_SKB_CB(skb)->partial_cov) {\n\t\tif (udp_lib_checksum_complete(skb))\n \t\t\tgoto csum_copy_err;\n \t}\n \n\tif (skb_csum_unnecessary(skb))\n \t\terr = skb_copy_datagram_msg(skb, sizeof(struct udphdr),\n \t\t\t\t\t    msg, copied);\n \telse {\n\t\terr = skb_copy_and_csum_datagram_msg(skb, sizeof(struct udphdr), msg);\n\t\tif (err == -EINVAL)\n\t\t\tgoto csum_copy_err;\n\t}\n\tif (unlikely(err)) {\n\t\ttrace_kfree_skb(skb, udpv6_recvmsg);\n\t\tif (!peeked) {\n\t\t\tatomic_inc(&sk->sk_drops);\n\t\t\tif (is_udp4)\n\t\t\t\tUDP_INC_STATS_USER(sock_net(sk),\n\t\t\t\t\t\t   UDP_MIB_INERRORS,\n\t\t\t\t\t\t   is_udplite);\n\t\t\telse\n\t\t\t\tUDP6_INC_STATS_USER(sock_net(sk),\n\t\t\t\t\t\t    UDP_MIB_INERRORS,\n\t\t\t\t\t\t    is_udplite);\n\t\t}\n\t\tgoto out_free;\n\t}\n\tif (!peeked) {\n\t\tif (is_udp4)\n\t\t\tUDP_INC_STATS_USER(sock_net(sk),\n\t\t\t\t\tUDP_MIB_INDATAGRAMS, is_udplite);\n\t\telse\n\t\t\tUDP6_INC_STATS_USER(sock_net(sk),\n\t\t\t\t\tUDP_MIB_INDATAGRAMS, is_udplite);\n\t}\n\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\n\t/* Copy the address. */\n\tif (msg->msg_name) {\n\t\tDECLARE_SOCKADDR(struct sockaddr_in6 *, sin6, msg->msg_name);\n\t\tsin6->sin6_family = AF_INET6;\n\t\tsin6->sin6_port = udp_hdr(skb)->source;\n\t\tsin6->sin6_flowinfo = 0;\n\n\t\tif (is_udp4) {\n\t\t\tipv6_addr_set_v4mapped(ip_hdr(skb)->saddr,\n\t\t\t\t\t       &sin6->sin6_addr);\n\t\t\tsin6->sin6_scope_id = 0;\n\t\t} else {\n\t\t\tsin6->sin6_addr = ipv6_hdr(skb)->saddr;\n\t\t\tsin6->sin6_scope_id =\n\t\t\t\tipv6_iface_scope_id(&sin6->sin6_addr,\n\t\t\t\t\t\t    inet6_iif(skb));\n\t\t}\n\t\t*addr_len = sizeof(*sin6);\n\t}\n\n\tif (np->rxopt.all)\n\t\tip6_datagram_recv_common_ctl(sk, msg, skb);\n\n\tif (is_udp4) {\n\t\tif (inet->cmsg_flags)\n\t\t\tip_cmsg_recv(msg, skb);\n\t} else {\n\t\tif (np->rxopt.all)\n\t\t\tip6_datagram_recv_specific_ctl(sk, msg, skb);\n\t}\n\n\terr = copied;\n\tif (flags & MSG_TRUNC)\n\t\terr = ulen;\n\nout_free:\n\tskb_free_datagram_locked(sk, skb);\nout:\n\treturn err;\n\ncsum_copy_err:\n\tslow = lock_sock_fast(sk);\n\tif (!skb_kill_datagram(sk, skb, flags)) {\n\t\tif (is_udp4) {\n\t\t\tUDP_INC_STATS_USER(sock_net(sk),\n\t\t\t\t\tUDP_MIB_CSUMERRORS, is_udplite);\n\t\t\tUDP_INC_STATS_USER(sock_net(sk),\n\t\t\t\t\tUDP_MIB_INERRORS, is_udplite);\n\t\t} else {\n\t\t\tUDP6_INC_STATS_USER(sock_net(sk),\n\t\t\t\t\tUDP_MIB_CSUMERRORS, is_udplite);\n\t\t\tUDP6_INC_STATS_USER(sock_net(sk),\n\t\t\t\t\tUDP_MIB_INERRORS, is_udplite);\n\t\t}\n\t}\n\tunlock_sock_fast(sk, slow);\n\n\t/* starting over for a new packet, but check if we need to yield */\n\tcond_resched();\n\tmsg->msg_flags &= ~MSG_TRUNC;\n\tgoto try_again;\n}\n", "target": 1, "idx": 181652}
{"func": "void Splash::blitMask(SplashBitmap *src, int xDest, int yDest,\n\t\t      SplashClipResult clipRes) {\n  SplashPipe pipe;\n  Guchar *p;\n  int w, h, x, y;\n \n   w = src->getWidth();\n   h = src->getHeight();\n   if (vectorAntialias && clipRes != splashClipAllInside) {\n     pipeInit(&pipe, xDest, yDest, state->fillPattern, NULL,\n \t     (Guchar)splashRound(state->fillAlpha * 255), gTrue, gFalse);\n     drawAAPixelInit();\n    p = src->getDataPtr();\n     for (y = 0; y < h; ++y) {\n       for (x = 0; x < w; ++x) {\n \tpipe.shape = *p++;\n    pipeInit(&pipe, xDest, yDest, state->fillPattern, NULL,\n\t     (Guchar)splashRound(state->fillAlpha * 255), gTrue, gFalse);\n    p = src->getDataPtr();\n   } else {\n     pipeInit(&pipe, xDest, yDest, state->fillPattern, NULL,\n \t     (Guchar)splashRound(state->fillAlpha * 255), gTrue, gFalse);\n    p = src->getDataPtr();\n     if (clipRes == splashClipAllInside) {\n       for (y = 0; y < h; ++y) {\n \tpipeSetXY(&pipe, xDest, yDest + y);\n\t    (this->*pipe.run)(&pipe);\n\t  } else {\n\t    pipeIncX(&pipe);\n\t  }\n\t  ++p;\n\t}\n      }\n      updateModX(xDest);\n      updateModX(xDest + w - 1);\n      updateModY(yDest);\n      updateModY(yDest + h - 1);\n    } else {\n      for (y = 0; y < h; ++y) {\n\tpipeSetXY(&pipe, xDest, yDest + y);\n\tfor (x = 0; x < w; ++x) {\n\t  if (*p && state->clip->test(xDest + x, yDest + y)) {\n\t    pipe.shape = *p;\n\t    (this->*pipe.run)(&pipe);\n\t    updateModX(xDest + x);\n\t    updateModY(yDest + y);\n\t  } else {\n\t    pipeIncX(&pipe);\n\t  }\n\t  ++p;\n\t}\n      }\n    }\n  }\n}\n", "target": 1, "idx": 177904}
{"func": "static void __d_rehash(struct dentry *entry)\n{\n\tstruct hlist_bl_head *b = d_hash(entry->d_name.hash);\n\tBUG_ON(!d_unhashed(entry));\n\thlist_bl_lock(b);\n\thlist_bl_add_head_rcu(&entry->d_hash, b);\n\thlist_bl_unlock(b);\n}\n", "target": 0, "idx": 67277}
{"func": "v8::Handle<v8::Value> V8WebKitMutationObserver::observeCallback(const v8::Arguments& args)\n {\n     INC_STATS(\"DOM.WebKitMutationObserver.observe\");\n     if (args.Length() < 2)\n        return V8Proxy::throwNotEnoughArgumentsError();\n     WebKitMutationObserver* imp = V8WebKitMutationObserver::toNative(args.Holder());\n     EXCEPTION_BLOCK(Node*, target, V8Node::HasInstance(args[0]) ? V8Node::toNative(v8::Handle<v8::Object>::Cast(args[0])) : 0);\n \n    if (!args[1]->IsObject())\n        return throwError(TYPE_MISMATCH_ERR, args.GetIsolate());\n\n    Dictionary optionsObject(args[1]);\n    unsigned options = 0;\n    HashSet<AtomicString> attributeFilter;\n    bool option;\n    if (optionsObject.get(\"childList\", option) && option)\n        options |= WebKitMutationObserver::ChildList;\n    if (optionsObject.get(\"attributes\", option) && option)\n        options |= WebKitMutationObserver::Attributes;\n    if (optionsObject.get(\"attributeFilter\", attributeFilter))\n        options |= WebKitMutationObserver::AttributeFilter;\n    if (optionsObject.get(\"characterData\", option) && option)\n        options |= WebKitMutationObserver::CharacterData;\n    if (optionsObject.get(\"subtree\", option) && option)\n        options |= WebKitMutationObserver::Subtree;\n    if (optionsObject.get(\"attributeOldValue\", option) && option)\n        options |= WebKitMutationObserver::AttributeOldValue;\n    if (optionsObject.get(\"characterDataOldValue\", option) && option)\n        options |= WebKitMutationObserver::CharacterDataOldValue;\n\n    ExceptionCode ec = 0;\n    imp->observe(target, options, attributeFilter, ec);\n    if (ec)\n        V8Proxy::setDOMException(ec, args.GetIsolate());\n    return v8::Handle<v8::Value>();\n}\n", "target": 1, "idx": 184824}
{"func": "ProcCopyColormapAndFree(ClientPtr client)\n{\n    Colormap mid;\n    ColormapPtr pSrcMap;\n\n    REQUEST(xCopyColormapAndFreeReq);\n    int rc;\n\n    REQUEST_SIZE_MATCH(xCopyColormapAndFreeReq);\n    mid = stuff->mid;\n    LEGAL_NEW_RESOURCE(mid, client);\n    rc = dixLookupResourceByType((void **) &pSrcMap, stuff->srcCmap,\n                                 RT_COLORMAP, client,\n                                 DixReadAccess | DixRemoveAccess);\n    if (rc == Success)\n        return CopyColormapAndFree(mid, pSrcMap, client->index);\n    client->errorValue = stuff->srcCmap;\n    return rc;\n}\n", "target": 0, "idx": 14960}
{"func": "void RenderWidgetHostViewAura::SendReclaimSoftwareFrames() {\n  if (!released_software_frame_)\n    return;\n  cc::CompositorFrameAck ack;\n  ack.last_software_frame_id = released_software_frame_->frame_id;\n  RenderWidgetHostImpl::SendReclaimCompositorResources(\n      host_->GetRoutingID(),\n      released_software_frame_->output_surface_id,\n      host_->GetProcess()->GetID(),\n      ack);\n  released_software_frame_.reset();\n}\n", "target": 0, "idx": 133020}
{"func": "void smp_proc_sec_grant(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n uint8_t res = *(uint8_t*)p_data;\n  SMP_TRACE_DEBUG(\"%s\", __func__);\n if (res != SMP_SUCCESS) {\n    smp_sm_event(p_cb, SMP_AUTH_CMPL_EVT, p_data);\n } else /*otherwise, start pairing */\n {\n /* send IO request callback */\n    p_cb->cb_evt = SMP_IO_CAP_REQ_EVT;\n }\n}\n", "target": 0, "idx": 175992}
{"func": "static int do_get_sock_timeout(struct socket *sock, int level, int optname,\n\t\tchar __user *optval, int __user *optlen)\n{\n\tstruct compat_timeval __user *up;\n\tstruct timeval ktime;\n\tmm_segment_t old_fs;\n\tint len, err;\n\n\tup = (struct compat_timeval __user *) optval;\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (len < sizeof(*up))\n\t\treturn -EINVAL;\n\tlen = sizeof(ktime);\n\told_fs = get_fs();\n\tset_fs(KERNEL_DS);\n\terr = sock_getsockopt(sock, level, optname, (char *) &ktime, &len);\n\tset_fs(old_fs);\n\n\tif (!err) {\n\t\tif (put_user(sizeof(*up), optlen) ||\n\t\t    !access_ok(VERIFY_WRITE, up, sizeof(*up)) ||\n\t\t    __put_user(ktime.tv_sec, &up->tv_sec) ||\n\t\t    __put_user(ktime.tv_usec, &up->tv_usec))\n\t\t\terr = -EFAULT;\n\t}\n\treturn err;\n}\n", "target": 0, "idx": 40078}
{"func": "add_peers(const char *s)\n{\n\tllist_t *item;\n\tpeer_t *p;\n\n\tp = xzalloc(sizeof(*p) + strlen(s));\n\tstrcpy(p->p_hostname, s);\n\tresolve_peer_hostname(p, /*loop_on_fail=*/ 1);\n\n\t/* Names like N.<country2chars>.pool.ntp.org are randomly resolved\n\t * to a pool of machines. Sometimes different N's resolve to the same IP.\n\t * It is not useful to have two peers with same IP. We skip duplicates.\n\t */\n\tfor (item = G.ntp_peers; item != NULL; item = item->link) {\n\t\tpeer_t *pp = (peer_t *) item->data;\n\t\tif (strcmp(p->p_dotted, pp->p_dotted) == 0) {\n\t\t\tbb_error_msg(\"duplicate peer %s (%s)\", s, p->p_dotted);\n\t\t\tfree(p->p_lsa);\n\t\t\tfree(p->p_dotted);\n\t\t\tfree(p);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tp->p_fd = -1;\n\tp->p_xmt_msg.m_status = MODE_CLIENT | (NTP_VERSION << 3);\n\tp->next_action_time = G.cur_time; /* = set_next(p, 0); */\n\treset_peer_stats(p, STEP_THRESHOLD);\n\n\tllist_add_to(&G.ntp_peers, p);\n\tG.peer_cnt++;\n}\n", "target": 0, "idx": 9480}
{"func": "kvp_respond_to_host(char *key, char *value, int error)\n{\n\tstruct hv_kvp_msg  *kvp_msg;\n\tstruct hv_kvp_msg_enumerate  *kvp_data;\n\tchar\t*key_name;\n\tstruct icmsg_hdr *icmsghdrp;\n\tint\tkeylen, valuelen;\n\tu32\tbuf_len;\n\tstruct vmbus_channel *channel;\n\tu64\treq_id;\n\n\t/*\n\t * If a transaction is not active; log and return.\n\t */\n\n\tif (!kvp_transaction.active) {\n\t\t/*\n\t\t * This is a spurious call!\n\t\t */\n\t\tpr_warn(\"KVP: Transaction not active\\n\");\n\t\treturn;\n\t}\n\t/*\n\t * Copy the global state for completing the transaction. Note that\n\t * only one transaction can be active at a time.\n\t */\n\n\tbuf_len = kvp_transaction.recv_len;\n\tchannel = kvp_transaction.recv_channel;\n\treq_id = kvp_transaction.recv_req_id;\n\n\tkvp_transaction.active = false;\n\n\tif (channel->onchannel_callback == NULL)\n\t\t/*\n\t\t * We have raced with util driver being unloaded;\n\t\t * silently return.\n\t\t */\n\t\treturn;\n\n\ticmsghdrp = (struct icmsg_hdr *)\n\t\t\t&recv_buffer[sizeof(struct vmbuspipe_hdr)];\n\tkvp_msg = (struct hv_kvp_msg *)\n\t\t\t&recv_buffer[sizeof(struct vmbuspipe_hdr) +\n\t\t\tsizeof(struct icmsg_hdr)];\n\tkvp_data = &kvp_msg->kvp_data;\n\tkey_name = key;\n\n\t/*\n\t * If the error parameter is set, terminate the host's enumeration.\n\t */\n\tif (error) {\n\t\t/*\n\t\t * We don't support this index or the we have timedout;\n\t\t * terminate the host-side iteration by returning an error.\n\t\t */\n\t\ticmsghdrp->status = HV_E_FAIL;\n\t\tgoto response_done;\n\t}\n\n\t/*\n \t * The windows host expects the key/value pair to be encoded\n \t * in utf16.\n \t */\n\tkeylen = utf8s_to_utf16s(key_name, strlen(key_name),\n\t\t\t\t(wchar_t *)kvp_data->data.key);\n \tkvp_data->data.key_size = 2*(keylen + 1); /* utf16 encoding */\n\tvaluelen = utf8s_to_utf16s(value, strlen(value),\n\t\t\t\t(wchar_t *)kvp_data->data.value);\n \tkvp_data->data.value_size = 2*(valuelen + 1); /* utf16 encoding */\n \n \tkvp_data->data.value_type = REG_SZ; /* all our values are strings */\n\ticmsghdrp->status = HV_S_OK;\n\nresponse_done:\n\ticmsghdrp->icflags = ICMSGHDRFLAG_TRANSACTION | ICMSGHDRFLAG_RESPONSE;\n\n\tvmbus_sendpacket(channel, recv_buffer, buf_len, req_id,\n\t\t\t\tVM_PKT_DATA_INBAND, 0);\n\n}\n", "target": 1, "idx": 179295}
{"func": "static void local_socket_close_locked(asocket* s) {\n    D(\"entered local_socket_close_locked. LS(%d) fd=%d\", s->id, s->fd);\n     if (s->peer) {\n         D(\"LS(%d): closing peer. peer->id=%d peer->fd=%d\", s->id, s->peer->id, s->peer->fd);\n         /* Note: it's important to call shutdown before disconnecting from\n         * the peer, this ensures that remote sockets can still get the id\n         * of the local socket they're connected to, to send a CLOSE()\n         * protocol event. */\n\n         if (s->peer->shutdown) {\n             s->peer->shutdown(s->peer);\n         }\n        s->peer->peer = 0;\n        if (s->peer->close == local_socket_close) {\n            local_socket_close_locked(s->peer);\n        } else {\n            s->peer->close(s->peer);\n        }\n        s->peer = 0;\n     }\n \n     /* If we are already closing, or if there are no\n    ** pending packets, destroy immediately\n    */\n if (s->closing || s->has_write_error || s->pkt_first == NULL) {\n int id = s->id;\n        local_socket_destroy(s);\n        D(\"LS(%d): closed\", id);\n return;\n }\n\n /* otherwise, put on the closing list\n    */\n    D(\"LS(%d): closing\", s->id);\n    s->closing = 1;\n    fdevent_del(&s->fde, FDE_READ);\n    remove_socket(s);\n    D(\"LS(%d): put on socket_closing_list fd=%d\", s->id, s->fd);\n    insert_local_socket(s, &local_socket_closing_list);\n    CHECK_EQ(FDE_WRITE, s->fde.state & FDE_WRITE);\n}\n", "target": 1, "idx": 188176}
{"func": "void InProcessBrowserTest::PrepareTestCommandLine(CommandLine* command_line) {\n  test_launcher_utils::PrepareBrowserCommandLineForTests(command_line);\n\n  command_line->AppendSwitchASCII(switches::kTestType, kBrowserTestType);\n\n#if defined(OS_WIN)\n  if (command_line->HasSwitch(switches::kAshBrowserTests)) {\n    command_line->AppendSwitchNative(switches::kViewerLaunchViaAppId,\n                                     win8::test::kDefaultTestAppUserModelId);\n    command_line->AppendSwitch(switches::kSilentLaunch);\n  }\n#endif\n\n#if defined(OS_MACOSX)\n  base::FilePath subprocess_path;\n  PathService::Get(base::FILE_EXE, &subprocess_path);\n  subprocess_path = subprocess_path.DirName().DirName();\n  DCHECK_EQ(subprocess_path.BaseName().value(), \"Contents\");\n  subprocess_path =\n      subprocess_path.Append(\"Versions\").Append(chrome::kChromeVersion);\n  subprocess_path =\n      subprocess_path.Append(chrome::kHelperProcessExecutablePath);\n  command_line->AppendSwitchPath(switches::kBrowserSubprocessPath,\n                                 subprocess_path);\n#endif\n\n   if (exit_when_last_browser_closes_)\n     command_line->AppendSwitch(switches::kDisableZeroBrowsersOpenForTests);\n \n  if (command_line->GetArgs().empty())\n     command_line->AppendArg(url::kAboutBlankURL);\n }\n", "target": 1, "idx": 184844}
{"func": "static MagickBooleanType SetGrayscaleImage(Image *image)\n{\n  CacheView\n    *image_view;\n\n  ExceptionInfo\n    *exception;\n\n  MagickBooleanType\n    status;\n\n  PixelPacket\n    *colormap;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    *colormap_index,\n    j,\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->type != GrayscaleType)\n    (void) TransformImageColorspace(image,GRAYColorspace);\n  colormap_index=(ssize_t *) AcquireQuantumMemory(MaxColormapSize,\n    sizeof(*colormap_index));\n  if (colormap_index == (ssize_t *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  if (image->storage_class != PseudoClass)\n    {\n      ExceptionInfo\n        *exception;\n\n       (void) ResetMagickMemory(colormap_index,(-1),MaxColormapSize*\n         sizeof(*colormap_index));\n       if (AcquireImageColormap(image,MaxColormapSize) == MagickFalse)\n        ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n          image->filename);\n       image->colors=0;\n       status=MagickTrue;\n       exception=(&image->exception);\n      image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      #pragma omp parallel for schedule(static,4) shared(status) \\\n        magick_threads(image,image,image->rows,1)\n#endif\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        register IndexPacket\n          *magick_restrict indexes;\n\n        register PixelPacket\n          *magick_restrict q;\n\n        register ssize_t\n          x;\n\n        if (status == MagickFalse)\n          continue;\n        q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,\n          exception);\n        if (q == (PixelPacket *) NULL)\n          {\n            status=MagickFalse;\n            continue;\n          }\n        indexes=GetCacheViewAuthenticIndexQueue(image_view);\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          register size_t\n            intensity;\n\n          intensity=ScaleQuantumToMap(GetPixelRed(q));\n          if (colormap_index[intensity] < 0)\n            {\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n              #pragma omp critical (MagickCore_SetGrayscaleImage)\n#endif\n              if (colormap_index[intensity] < 0)\n                {\n                  colormap_index[intensity]=(ssize_t) image->colors;\n                  image->colormap[image->colors].red=GetPixelRed(q);\n                  image->colormap[image->colors].green=GetPixelGreen(q);\n                  image->colormap[image->colors].blue=GetPixelBlue(q);\n                  image->colors++;\n               }\n            }\n          SetPixelIndex(indexes+x,colormap_index[intensity]);\n          q++;\n        }\n        if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n          status=MagickFalse;\n      }\n      image_view=DestroyCacheView(image_view);\n    }\n  for (i=0; i < (ssize_t) image->colors; i++)\n    image->colormap[i].opacity=(unsigned short) i;\n  qsort((void *) image->colormap,image->colors,sizeof(PixelPacket),\n    IntensityCompare);\n  colormap=(PixelPacket *) AcquireQuantumMemory(image->colors,\n    sizeof(*colormap));\n  if (colormap == (PixelPacket *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  j=0;\n  colormap[j]=image->colormap[0];\n  for (i=0; i < (ssize_t) image->colors; i++)\n  {\n    if (IsSameColor(image,&colormap[j],&image->colormap[i]) == MagickFalse)\n      {\n        j++;\n        colormap[j]=image->colormap[i];\n      }\n    colormap_index[(ssize_t) image->colormap[i].opacity]=j;\n  }\n  image->colors=(size_t) (j+1);\n  image->colormap=(PixelPacket *) RelinquishMagickMemory(image->colormap);\n  image->colormap=colormap;\n  status=MagickTrue;\n  exception=(&image->exception);\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(status) \\\n    magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register IndexPacket\n      *magick_restrict indexes;\n\n    register const PixelPacket\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    indexes=GetCacheViewAuthenticIndexQueue(image_view);\n    for (x=0; x < (ssize_t) image->columns; x++)\n      SetPixelIndex(indexes+x,colormap_index[ScaleQuantumToMap(GetPixelIndex(\n        indexes+x))]);\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  image_view=DestroyCacheView(image_view);\n  colormap_index=(ssize_t *) RelinquishMagickMemory(colormap_index);\n  image->type=GrayscaleType;\n  if (SetImageMonochrome(image,&image->exception) != MagickFalse)\n    image->type=BilevelType;\n  return(status);\n}\n", "target": 1, "idx": 181147}
{"func": "void test_base64_lengths(void)\n{\n  const char *in = \"FuseMuse\";\n  char out1[32];\n  char out2[32];\n  size_t enclen;\n  int declen;\n\n  /* Encoding a zero-length string should fail */\n  enclen = mutt_b64_encode(out1, in, 0, 32);\n  if (!TEST_CHECK(enclen == 0))\n  {\n    TEST_MSG(\"Expected: %zu\", 0);\n    TEST_MSG(\"Actual  : %zu\", enclen);\n  }\n \n   /* Decoding a zero-length string should fail, too */\n   out1[0] = '\\0';\n  declen = mutt_b64_decode(out2, out1);\n   if (!TEST_CHECK(declen == -1))\n   {\n     TEST_MSG(\"Expected: %zu\", -1);\n    TEST_MSG(\"Actual  : %zu\", declen);\n  }\n\n  /* Encode one to eight bytes, check the lengths of the returned string */\n  for (size_t i = 1; i <= 8; ++i)\n  {\n    enclen = mutt_b64_encode(out1, in, i, 32);\n    size_t exp = ((i + 2) / 3) << 2;\n    if (!TEST_CHECK(enclen == exp))\n    {\n       TEST_MSG(\"Expected: %zu\", exp);\n       TEST_MSG(\"Actual  : %zu\", enclen);\n     }\n    declen = mutt_b64_decode(out2, out1);\n     if (!TEST_CHECK(declen == i))\n     {\n       TEST_MSG(\"Expected: %zu\", i);\n      TEST_MSG(\"Actual  : %zu\", declen);\n    }\n    out2[declen] = '\\0';\n    if (!TEST_CHECK(strncmp(out2, in, i) == 0))\n    {\n      TEST_MSG(\"Expected: %s\", in);\n      TEST_MSG(\"Actual  : %s\", out2);\n    }\n  }\n}\n", "target": 1, "idx": 182303}
{"func": "copy_metadata(struct archive_write_disk *a, const char *metadata,\n    const char *datafork, int datafork_compressed)\n{\n\tint ret = ARCHIVE_OK;\n\n\tif (datafork_compressed) {\n\t\tint dffd, tmpfd;\n\n\t\ttmpfd = create_tempdatafork(a, metadata);\n\t\tif (tmpfd == -1)\n\t\t\treturn (ARCHIVE_WARN);\n\n\t\t/*\n\t\t * Do not open the data fork compressed by HFS+ compression\n\t\t * with at least a writing mode(O_RDWR or O_WRONLY). it\n\t\t * makes the data fork uncompressed.\n\t\t */\n\t\tdffd = open(datafork, 0);\n\t\tif (dffd == -1) {\n\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t    \"Failed to open the data fork for metadata\");\n\t\t\tclose(tmpfd);\n\t\t\treturn (ARCHIVE_WARN);\n\t\t}\n\n#if defined(HAVE_SYS_XATTR_H)\n\t\tret = copy_xattrs(a, tmpfd, dffd);\n\t\tif (ret == ARCHIVE_OK)\n#endif\n\t\t\tret = copy_acls(a, tmpfd, dffd);\n\t\tclose(tmpfd);\n\t\tclose(dffd);\n\t} else {\n\t\tif (copyfile(metadata, datafork, 0,\n\t\t    COPYFILE_UNPACK | COPYFILE_NOFOLLOW\n\t\t    | COPYFILE_ACL | COPYFILE_XATTR) < 0) {\n\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t    \"Failed to restore metadata\");\n\t\t\tret = ARCHIVE_WARN;\n\t\t}\n\t}\n\treturn (ret);\n}\n", "target": 0, "idx": 43903}
{"func": "void RenderWidgetHostViewGtk::AcceleratedSurfaceBuffersSwapped(\n     const GpuHostMsg_AcceleratedSurfaceBuffersSwapped_Params& params,\n     int gpu_host_id) {\n   RenderWidgetHostImpl::AcknowledgeBufferPresent(\n      params.route_id, gpu_host_id, true, 0);\n }\n", "target": 1, "idx": 185088}
{"func": " pimv2_addr_print(netdissect_options *ndo,\n                 const u_char *bp, enum pimv2_addrtype at, int silent)\n {\n \tint af;\n\tint len, hdrlen;\n \n\tND_TCHECK(bp[0]);\n\tif (pimv2_addr_len == 0) {\n \t\tND_TCHECK(bp[1]);\n \t\tswitch (bp[0]) {\n \t\tcase 1:\n \t\t\taf = AF_INET;\n\t\t\tlen = sizeof(struct in_addr);\n \t\t\tbreak;\n \t\tcase 2:\n \t\t\taf = AF_INET6;\n\t\t\tlen = sizeof(struct in6_addr);\n \t\t\tbreak;\n \t\tdefault:\n \t\t\treturn -1;\n\t\t}\n\t\tif (bp[1] != 0)\n \t\t\treturn -1;\n \t\thdrlen = 2;\n \t} else {\n\t\tswitch (pimv2_addr_len) {\n \t\tcase sizeof(struct in_addr):\n \t\t\taf = AF_INET;\n \t\t\tbreak;\n\t\tcase sizeof(struct in6_addr):\n\t\t\taf = AF_INET6;\n\t\t\tbreak;\n\t\tdefault:\n \t\t\treturn -1;\n \t\t\tbreak;\n \t\t}\n\t\tlen = pimv2_addr_len;\n \t\thdrlen = 0;\n \t}\n \n \tbp += hdrlen;\n \tswitch (at) {\n \tcase pimv2_unicast:\n\t\tND_TCHECK2(bp[0], len);\n \t\tif (af == AF_INET) {\n \t\t\tif (!silent)\n \t\t\t\tND_PRINT((ndo, \"%s\", ipaddr_string(ndo, bp)));\n\t\t}\n\t\telse if (af == AF_INET6) {\n \t\t\tif (!silent)\n \t\t\t\tND_PRINT((ndo, \"%s\", ip6addr_string(ndo, bp)));\n \t\t}\n\t\treturn hdrlen + len;\n \tcase pimv2_group:\n \tcase pimv2_source:\n\t\tND_TCHECK2(bp[0], len + 2);\n \t\tif (af == AF_INET) {\n \t\t\tif (!silent) {\n \t\t\t\tND_PRINT((ndo, \"%s\", ipaddr_string(ndo, bp + 2)));\n\t\t\t\tif (bp[1] != 32)\n\t\t\t\t\tND_PRINT((ndo, \"/%u\", bp[1]));\n\t\t\t}\n\t\t}\n\t\telse if (af == AF_INET6) {\n\t\t\tif (!silent) {\n\t\t\t\tND_PRINT((ndo, \"%s\", ip6addr_string(ndo, bp + 2)));\n\t\t\t\tif (bp[1] != 128)\n\t\t\t\t\tND_PRINT((ndo, \"/%u\", bp[1]));\n\t\t\t}\n\t\t}\n\t\tif (bp[0] && !silent) {\n\t\t\tif (at == pimv2_group) {\n\t\t\t\tND_PRINT((ndo, \"(0x%02x)\", bp[0]));\n\t\t\t} else {\n\t\t\t\tND_PRINT((ndo, \"(%s%s%s\",\n\t\t\t\t\tbp[0] & 0x04 ? \"S\" : \"\",\n\t\t\t\t\tbp[0] & 0x02 ? \"W\" : \"\",\n\t\t\t\t\tbp[0] & 0x01 ? \"R\" : \"\"));\n\t\t\t\tif (bp[0] & 0xf8) {\n\t\t\t\t\tND_PRINT((ndo, \"+0x%02x\", bp[0] & 0xf8));\n\t\t\t\t}\n \t\t\t\tND_PRINT((ndo, \")\"));\n \t\t\t}\n \t\t}\n\t\treturn hdrlen + 2 + len;\n \tdefault:\n \t\treturn -1;\n \t}\ntrunc:\n\treturn -1;\n}\n", "target": 1, "idx": 181029}
{"func": "ResourceRequestInfoImpl* ResourceDispatcherHostImpl::CreateRequestInfo(\n     int child_id,\n     int render_view_route_id,\n     int render_frame_route_id,\n     PreviewsState previews_state,\n     bool download,\n     ResourceContext* context) {\n   return new ResourceRequestInfoImpl(\n       ResourceRequesterInfo::CreateForDownloadOrPageSave(child_id),\n      render_view_route_id,\n      -1,                                  // frame_tree_node_id\n       ChildProcessHost::kInvalidUniqueID,  // plugin_child_id\n       MakeRequestID(), render_frame_route_id,\n       false,  // is_main_frame\n      {},     // fetch_window_id\n      RESOURCE_TYPE_SUB_RESOURCE, ui::PAGE_TRANSITION_LINK,\n      download,  // is_download\n      false,     // is_stream\n      download,  // allow_download\n      false,     // has_user_gesture\n      false,     // enable_load_timing\n      false,     // enable_upload_progress\n      false,     // do_not_prompt_for_login\n      false,     // keepalive\n      network::mojom::ReferrerPolicy::kDefault,\n      false,  // is_prerendering\n      context,\n      false,           // report_raw_headers\n      false,           // report_security_info\n      true,            // is_async\n      previews_state,  // previews_state\n      nullptr,         // body\n      false);          // initiated_in_secure_context\n}\n", "target": 1, "idx": 187006}
{"func": "VaapiVP9Picture::VaapiVP9Picture(\n    const scoped_refptr<VaapiVideoDecodeAccelerator::VaapiDecodeSurface>&\n        dec_surface)\n    : dec_surface_(dec_surface) {}\n", "target": 1, "idx": 183527}
{"func": "void DiceResponseHandler::ProcessDiceSignoutHeader(\n    const std::vector<signin::DiceResponseParams::AccountInfo>& account_infos) {\n  VLOG(1) << \"Start processing Dice signout response\";\n  if (account_consistency_ ==\n      signin::AccountConsistencyMethod::kDiceFixAuthErrors) {\n    return;\n  }\n\n  std::string primary_account = signin_manager_->GetAuthenticatedAccountId();\n  bool primary_account_signed_out = false;\n  for (const auto& account_info : account_infos) {\n    std::string signed_out_account =\n        account_tracker_service_->PickAccountIdForAccount(account_info.gaia_id,\n                                                          account_info.email);\n    if (signed_out_account == primary_account) {\n      primary_account_signed_out = true;\n      RecordDiceResponseHeader(kSignoutPrimary);\n      RecordGaiaSignoutMetrics(\n          (account_info.session_index == 0)\n              ? kChromePrimaryAccountIsFirstGaiaAccount\n              : kChromePrimaryAccountIsSecondaryGaiaAccount);\n\n      if (account_consistency_ == signin::AccountConsistencyMethod::kDice) {\n         token_service_->UpdateCredentials(\n             primary_account,\n            MutableProfileOAuth2TokenServiceDelegate::kInvalidRefreshToken);\n       } else {\n         continue;\n       }\n     } else {\n      token_service_->RevokeCredentials(signed_out_account);\n     }\n \n    for (auto it = token_fetchers_.begin(); it != token_fetchers_.end(); ++it) {\n      std::string token_fetcher_account_id =\n          account_tracker_service_->PickAccountIdForAccount(\n              it->get()->gaia_id(), it->get()->email());\n      if (token_fetcher_account_id == signed_out_account) {\n        token_fetchers_.erase(it);\n        break;\n      }\n    }\n  }\n\n  if (!primary_account_signed_out) {\n    RecordDiceResponseHeader(kSignoutSecondary);\n    RecordGaiaSignoutMetrics(primary_account.empty()\n                                 ? kNoChromePrimaryAccount\n                                 : kChromePrimaryAccountIsNotInGaiaAccounts);\n  }\n}\n", "target": 1, "idx": 186542}
{"func": "node_get_pref_orport(const node_t *node, tor_addr_port_t *ap_out)\n{\n  tor_assert(ap_out);\n\n  if (node_ipv6_or_preferred(node)) {\n    node_get_pref_ipv6_orport(node, ap_out);\n  } else {\n    /* the primary ORPort is always on IPv4 */\n    node_get_prim_orport(node, ap_out);\n  }\n}\n", "target": 0, "idx": 69790}
{"func": "static bool CheckMov(const uint8* buffer, int buffer_size) {\n  RCHECK(buffer_size > 8);\n \n   int offset = 0;\n   while (offset + 8 < buffer_size) {\n    int atomsize = Read32(buffer + offset);\n     uint32 atomtype = Read32(buffer + offset + 4);\n     switch (atomtype) {\n      case TAG('f','t','y','p'):\n      case TAG('p','d','i','n'):\n      case TAG('m','o','o','v'):\n      case TAG('m','o','o','f'):\n      case TAG('m','f','r','a'):\n      case TAG('m','d','a','t'):\n      case TAG('f','r','e','e'):\n      case TAG('s','k','i','p'):\n      case TAG('m','e','t','a'):\n      case TAG('m','e','c','o'):\n      case TAG('s','t','y','p'):\n      case TAG('s','i','d','x'):\n      case TAG('s','s','i','x'):\n      case TAG('p','r','f','t'):\n      case TAG('b','l','o','c'):\n        break;\n      default:\n        return false;\n    }\n    if (atomsize == 1) {\n      if (offset + 16 > buffer_size)\n        break;\n      if (Read32(buffer + offset + 8) != 0)\n         break;  // Offset is way past buffer size.\n       atomsize = Read32(buffer + offset + 12);\n     }\n    if (atomsize <= 0)\n       break;  // Indicates the last atom or length too big.\n     offset += atomsize;\n   }\n  return true;\n}\n", "target": 1, "idx": 185314}
{"func": "static int futex_lock_pi(u32 __user *uaddr, unsigned int flags, int detect,\n\t\t\t ktime_t *time, int trylock)\n{\n\tstruct hrtimer_sleeper timeout, *to = NULL;\n\tstruct futex_hash_bucket *hb;\n\tstruct futex_q q = futex_q_init;\n\tint res, ret;\n\n\tif (refill_pi_state_cache())\n\t\treturn -ENOMEM;\n\n\tif (time) {\n\t\tto = &timeout;\n\t\thrtimer_init_on_stack(&to->timer, CLOCK_REALTIME,\n\t\t\t\t      HRTIMER_MODE_ABS);\n\t\thrtimer_init_sleeper(to, current);\n\t\thrtimer_set_expires(&to->timer, *time);\n\t}\n\nretry:\n\tret = get_futex_key(uaddr, flags & FLAGS_SHARED, &q.key, VERIFY_WRITE);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\nretry_private:\n\thb = queue_lock(&q);\n\n\tret = futex_lock_pi_atomic(uaddr, hb, &q.key, &q.pi_state, current, 0);\n\tif (unlikely(ret)) {\n\t\tswitch (ret) {\n\t\tcase 1:\n\t\t\t/* We got the lock. */\n\t\t\tret = 0;\n\t\t\tgoto out_unlock_put_key;\n\t\tcase -EFAULT:\n\t\t\tgoto uaddr_faulted;\n\t\tcase -EAGAIN:\n\t\t\t/*\n\t\t\t * Task is exiting and we just wait for the\n\t\t\t * exit to complete.\n\t\t\t */\n\t\t\tqueue_unlock(hb);\n\t\t\tput_futex_key(&q.key);\n\t\t\tcond_resched();\n\t\t\tgoto retry;\n\t\tdefault:\n\t\t\tgoto out_unlock_put_key;\n\t\t}\n\t}\n\n\t/*\n\t * Only actually queue now that the atomic ops are done:\n\t */\n\tqueue_me(&q, hb);\n\n\tWARN_ON(!q.pi_state);\n\t/*\n\t * Block on the PI mutex:\n\t */\n\tif (!trylock)\n\t\tret = rt_mutex_timed_lock(&q.pi_state->pi_mutex, to, 1);\n\telse {\n\t\tret = rt_mutex_trylock(&q.pi_state->pi_mutex);\n\t\t/* Fixup the trylock return value: */\n\t\tret = ret ? 0 : -EWOULDBLOCK;\n\t}\n\n\tspin_lock(q.lock_ptr);\n\t/*\n\t * Fixup the pi_state owner and possibly acquire the lock if we\n\t * haven't already.\n\t */\n\tres = fixup_owner(uaddr, &q, !ret);\n\t/*\n\t * If fixup_owner() returned an error, proprogate that.  If it acquired\n\t * the lock, clear our -ETIMEDOUT or -EINTR.\n\t */\n\tif (res)\n\t\tret = (res < 0) ? res : 0;\n\n\t/*\n\t * If fixup_owner() faulted and was unable to handle the fault, unlock\n\t * it and return the fault to userspace.\n\t */\n\tif (ret && (rt_mutex_owner(&q.pi_state->pi_mutex) == current))\n\t\trt_mutex_unlock(&q.pi_state->pi_mutex);\n\n\t/* Unqueue and drop the lock */\n\tunqueue_me_pi(&q);\n\n\tgoto out_put_key;\n\nout_unlock_put_key:\n\tqueue_unlock(hb);\n\nout_put_key:\n\tput_futex_key(&q.key);\nout:\n\tif (to)\n\t\tdestroy_hrtimer_on_stack(&to->timer);\n\treturn ret != -EINTR ? ret : -ERESTARTNOINTR;\n\nuaddr_faulted:\n\tqueue_unlock(hb);\n\n\tret = fault_in_user_writeable(uaddr);\n\tif (ret)\n\t\tgoto out_put_key;\n\n\tif (!(flags & FLAGS_SHARED))\n\t\tgoto retry_private;\n\n\tput_futex_key(&q.key);\n\tgoto retry;\n}\n", "target": 0, "idx": 38203}
{"func": "static void smp_task_timedout(struct timer_list *t)\n{\n\tstruct sas_task_slow *slow = from_timer(slow, t, timer);\n\tstruct sas_task *task = slow->task;\n \tunsigned long flags;\n \n \tspin_lock_irqsave(&task->task_state_lock, flags);\n\tif (!(task->task_state_flags & SAS_TASK_STATE_DONE))\n \t\ttask->task_state_flags |= SAS_TASK_STATE_ABORTED;\n \tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\tcomplete(&task->slow_task->completion);\n }\n", "target": 1, "idx": 182955}
{"func": "void WebMediaPlayerImpl::SelectedVideoTrackChanged(\n    blink::WebMediaPlayer::TrackId* selectedTrackId) {\n  DCHECK(main_task_runner_->BelongsToCurrentThread());\n\n  base::Optional<MediaTrack::Id> selected_video_track_id;\n  if (selectedTrackId && !video_track_disabled_)\n    selected_video_track_id = MediaTrack::Id(selectedTrackId->Utf8().data());\n  MEDIA_LOG(INFO, media_log_.get())\n      << \"Selected video track: [\" << selected_video_track_id.value_or(\"\")\n      << \"]\";\n  pipeline_controller_.OnSelectedVideoTrackChanged(selected_video_track_id);\n}\n", "target": 0, "idx": 157312}
{"func": "static int ion_handle_put(struct ion_handle *handle)\n {\n \tstruct ion_client *client = handle->client;\n \tint ret;\n \n \tmutex_lock(&client->lock);\n\tret = kref_put(&handle->ref, ion_handle_destroy);\n \tmutex_unlock(&client->lock);\n \n \treturn ret;\n}\n", "target": 1, "idx": 180070}
{"func": "static void edge_bulk_in_callback(struct urb *urb)\n{\n\tstruct edgeport_port *edge_port = urb->context;\n\tstruct device *dev = &edge_port->port->dev;\n\tunsigned char *data = urb->transfer_buffer;\n\tint retval = 0;\n\tint port_number;\n\tint status = urb->status;\n\n\tswitch (status) {\n\tcase 0:\n\t\t/* success */\n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\t/* this urb is terminated, clean up */\n\t\tdev_dbg(&urb->dev->dev, \"%s - urb shutting down with status: %d\\n\", __func__, status);\n\t\treturn;\n\tdefault:\n\t\tdev_err(&urb->dev->dev, \"%s - nonzero read bulk status received: %d\\n\", __func__, status);\n\t}\n\n\tif (status == -EPIPE)\n\t\tgoto exit;\n\n\tif (status) {\n\t\tdev_err(&urb->dev->dev, \"%s - stopping read!\\n\", __func__);\n\t\treturn;\n\t}\n \n \tport_number = edge_port->port->port_number;\n \n\tif (edge_port->lsr_event) {\n \t\tedge_port->lsr_event = 0;\n \t\tdev_dbg(dev, \"%s ===== Port %u LSR Status = %02x, Data = %02x ======\\n\",\n \t\t\t__func__, port_number, edge_port->lsr_mask, *data);\n\t\thandle_new_lsr(edge_port, 1, edge_port->lsr_mask, *data);\n\t\t/* Adjust buffer length/pointer */\n\t\t--urb->actual_length;\n\t\t++data;\n\t}\n\n\tif (urb->actual_length) {\n\t\tusb_serial_debug_data(dev, __func__, urb->actual_length, data);\n\t\tif (edge_port->close_pending)\n\t\t\tdev_dbg(dev, \"%s - close pending, dropping data on the floor\\n\",\n\t\t\t\t\t\t\t\t__func__);\n\t\telse\n\t\t\tedge_tty_recv(edge_port->port, data,\n\t\t\t\t\turb->actual_length);\n\t\tedge_port->port->icount.rx += urb->actual_length;\n\t}\n\nexit:\n\t/* continue read unless stopped */\n\tspin_lock(&edge_port->ep_lock);\n\tif (edge_port->ep_read_urb_state == EDGE_READ_URB_RUNNING)\n\t\tretval = usb_submit_urb(urb, GFP_ATOMIC);\n\telse if (edge_port->ep_read_urb_state == EDGE_READ_URB_STOPPING)\n\t\tedge_port->ep_read_urb_state = EDGE_READ_URB_STOPPED;\n\n\tspin_unlock(&edge_port->ep_lock);\n\tif (retval)\n\t\tdev_err(dev, \"%s - usb_submit_urb failed with result %d\\n\", __func__, retval);\n}\n", "target": 1, "idx": 181361}
{"func": "void MigrationTest::SetUpVersion75Database() {\n  sql::Connection connection;\n  ASSERT_TRUE(connection.Open(GetDatabasePath()));\n  ASSERT_TRUE(connection.BeginTransaction());\n  ASSERT_TRUE(connection.Execute(\n      \"CREATE TABLE share_version (id VARCHAR(128) primary key, data INT);\"\n      \"INSERT INTO 'share_version' VALUES('nick@chromium.org',75);\"\n      \"CREATE TABLE 'share_info' (id TEXT primary key, name TEXT, store_birthd\"\n          \"ay TEXT, db_create_version TEXT, db_create_time INT, next_id INT de\"\n          \"fault -2, cache_guid TEXT , notification_state BLOB, autofill_migra\"\n          \"tion_state INT default 0,bookmarks_added_during_autofill_migration \"\n          \"INT default 0, autofill_migration_time INT default 0, autofill_entr\"\n          \"ies_added_during_migration INT default 0, autofill_profiles_added_d\"\n          \"uring_migration INT default 0);\"\n       \"INSERT INTO 'share_info' VALUES('nick@chromium.org','nick@chromium.org\"\n           \"','c27e9f59-08ca-46f8-b0cc-f16a2ed778bb','Unknown',1263522064,-655\"\n           \"42,'9010788312004066376x-6609234393368420856x',NULL,0,0,0,0,0);\"\n       \"CREATE TABLE models (model_id BLOB primary key, progress_marker BLOB, \"\n           \"initial_sync_ended BOOLEAN default 0);\"\n       \"INSERT INTO 'models' VALUES(X'C2881000',X'0888810218B605',1);\"\n       \"CREATE TABLE 'metas'(metahandle bigint primary key ON CONFLICT FAIL,ba\"\n           \"se_version bigint default -1,server_version bigint default 0,mtime\"\n           \" bigint default 0,server_mtime bigint default 0,ctime bigint defau\"\n           \"lt 0,server_ctime bigint default 0,server_position_in_parent bigin\"\n           \"t default 0,local_external_id bigint default 0,id varchar(255) def\"\n           \"ault 'r',parent_id varchar(255) default 'r',server_parent_id varch\"\n           \"ar(255) default 'r',prev_id varchar(255) default 'r',next_id varch\"\n           \"ar(255) default 'r',is_unsynced bit default 0,is_unapplied_update \"\n           \"bit default 0,is_del bit default 0,is_dir bit default 0,server_is_\"\n            \"dir bit default 0,server_is_del bit default 0,non_unique_name varc\"\n            \"har,server_non_unique_name varchar(255),unique_server_tag varchar,\"\n            \"unique_client_tag varchar,specifics blob,server_specifics blob);\"\n           \"INSERT INTO 'metas' VALUES(1,-1,0,\" LEGACY_PROTO_TIME_VALS(1)\n              \",0,0,'r','r','r','r','r',0,0,0,1,0,0,NULL,NULL,NULL,NUL\"\n               \"L,X'',X'');\"\n           \"INSERT INTO 'metas' VALUES(2,669,669,\" LEGACY_PROTO_TIME_VALS(2)\n              \",-2097152,4,'s_ID_\"\n               \"2','s_ID_9','s_ID_9','s_ID_2','s_ID_2',0,0,1,0,0,1,'Deleted Ite\"\n               \"m','Deleted Item',NULL,NULL,X'C28810220A16687474703A2F2F7777772\"\n               \"E676F6F676C652E636F6D2F12084141534741534741',X'C28810260A176874\"\n               \"74703A2F2F7777772E676F6F676C652E636F6D2F32120B41534144474144474\"\n               \"14447');\"\n           \"INSERT INTO 'metas' VALUES(4,681,681,\" LEGACY_PROTO_TIME_VALS(4)\n              \",-3145728,3,'s_ID_\"\n               \"4','s_ID_9','s_ID_9','s_ID_4','s_ID_4',0,0,1,0,0,1,'Welcome to \"\n               \"Chromium','Welcome to Chromium',NULL,NULL,X'C28810350A316874747\"\n               \"03A2F2F7777772E676F6F676C652E636F6D2F6368726F6D652F696E746C2F65\"\n               \"6E2F77656C636F6D652E68746D6C1200',X'C28810350A31687474703A2F2F7\"\n               \"777772E676F6F676C652E636F6D2F6368726F6D652F696E746C2F656E2F7765\"\n               \"6C636F6D652E68746D6C1200');\"\n           \"INSERT INTO 'metas' VALUES(5,677,677,\" LEGACY_PROTO_TIME_VALS(5)\n              \",1048576,7,'s_ID_5\"\n               \"','s_ID_9','s_ID_9','s_ID_5','s_ID_5',0,0,1,0,0,1,'Google','Goo\"\n               \"gle',NULL,NULL,X'C28810220A16687474703A2F2F7777772E676F6F676C65\"\n               \"2E636F6D2F12084147415347415347',X'C28810220A16687474703A2F2F777\"\n               \"7772E676F6F676C652E636F6D2F12084147464447415347');\"\n           \"INSERT INTO 'metas' VALUES(6,694,694,\" LEGACY_PROTO_TIME_VALS(6)\n              \",-4194304,6,'s_ID_\"\n               \"6','s_ID_9','s_ID_9','r','r',0,0,0,1,1,0,'The Internet','The In\"\n               \"ternet',NULL,NULL,X'C2881000',X'C2881000');\"\n           \"INSERT INTO 'metas' VALUES(7,663,663,\" LEGACY_PROTO_TIME_VALS(7)\n              \",1048576,0,'s_ID_7\"\n               \"','r','r','r','r',0,0,0,1,1,0,'Google Chrome','Google Chrome','\"\n               \"google_chrome',NULL,NULL,NULL);\"\n           \"INSERT INTO 'metas' VALUES(8,664,664,\" LEGACY_PROTO_TIME_VALS(8)\n              \",1048576,0,'s_ID_8\"\n               \"','s_ID_7','s_ID_7','r','r',0,0,0,1,1,0,'Bookmarks','Bookmarks'\"\n               \",'google_chrome_bookmarks',NULL,X'C2881000',X'C2881000');\"\n           \"INSERT INTO 'metas' VALUES(9,665,665,\" LEGACY_PROTO_TIME_VALS(9)\n              \",1048576,1,'s_ID_9\"\n               \"','s_ID_8','s_ID_8','r','s_ID_10',0,0,0,1,1,0,'Bookmark Bar','B\"\n               \"ookmark Bar','bookmark_bar',NULL,X'C2881000',X'C2881000');\"\n           \"INSERT INTO 'metas' VALUES(10,666,666,\" LEGACY_PROTO_TIME_VALS(10)\n              \",2097152,2,'s_ID_\"\n               \"10','s_ID_8','s_ID_8','s_ID_9','r',0,0,0,1,1,0,'Other Bookmarks\"\n               \"','Other Bookmarks','other_bookmarks',NULL,X'C2881000',X'C28810\"\n               \"00');\"\n           \"INSERT INTO 'metas' VALUES(11,683,683,\" LEGACY_PROTO_TIME_VALS(11)\n              \",-1048576,8,'s_ID\"\n               \"_11','s_ID_6','s_ID_6','r','s_ID_13',0,0,0,0,0,0,'Home (The Chr\"\n               \"omium Projects)','Home (The Chromium Projects)',NULL,NULL,X'C28\"\n               \"810220A18687474703A2F2F6465762E6368726F6D69756D2E6F72672F120641\"\n               \"4741545741',X'C28810290A1D687474703A2F2F6465762E6368726F6D69756\"\n               \"D2E6F72672F6F7468657212084146414756415346');\"\n           \"INSERT INTO 'metas' VALUES(12,685,685,\" LEGACY_PROTO_TIME_VALS(12)\n              \",0,9,'s_ID_12','s\"\n               \"_ID_6','s_ID_6','s_ID_13','s_ID_14',0,0,0,1,1,0,'Extra Bookmark\"\n               \"s','Extra Bookmarks',NULL,NULL,X'C2881000',X'C2881000');\"\n           \"INSERT INTO 'metas' VALUES(13,687,687,\" LEGACY_PROTO_TIME_VALS(13)\n              \",-917504,10,'s_ID\"\n               \"_13','s_ID_6','s_ID_6','s_ID_11','s_ID_12',0,0,0,0,0,0,'ICANN |\"\n               \" Internet Corporation for Assigned Names and Numbers','ICANN | \"\n               \"Internet Corporation for Assigned Names and Numbers',NULL,NULL,\"\n               \"X'C28810240A15687474703A2F2F7777772E6963616E6E2E636F6D2F120B504\"\n               \"E474158463041414646',X'C28810200A15687474703A2F2F7777772E696361\"\n               \"6E6E2E636F6D2F120744414146415346');\"\n           \"INSERT INTO 'metas' VALUES(14,692,692,\" LEGACY_PROTO_TIME_VALS(14)\n              \",1048576,11,'s_ID\"\n               \"_14','s_ID_6','s_ID_6','s_ID_12','r',0,0,0,0,0,0,'The WebKit Op\"\n               \"en Source Project','The WebKit Open Source Project',NULL,NULL,X\"\n               \"'C288101A0A12687474703A2F2F7765626B69742E6F72672F1204504E4758',\"\n              \"X'C288101C0A13687474703A2F2F7765626B69742E6F72672F781205504E473\"\n              \"259');\"\n      ));\n   ASSERT_TRUE(connection.CommitTransaction());\n }\n", "target": 1, "idx": 183685}
{"func": "static void *mntns_get(struct task_struct *task)\n{\n\tstruct mnt_namespace *ns = NULL;\n\tstruct nsproxy *nsproxy;\n\n\ttask_lock(task);\n\tnsproxy = task->nsproxy;\n\tif (nsproxy) {\n\t\tns = nsproxy->mnt_ns;\n\t\tget_mnt_ns(ns);\n\t}\n\ttask_unlock(task);\n\n\treturn ns;\n}\n", "target": 0, "idx": 36223}
{"func": "  QuotaCallback* NewWaitableGlobalQuotaCallback() {\n    ++waiting_callbacks_;\n    return callback_factory_.NewCallback(\n            &UsageAndQuotaDispatcherTask::DidGetGlobalQuota);\n  }\n", "target": 0, "idx": 101035}
{"func": "gfx::NativeWindow AppListControllerDelegateWin::GetAppListWindow() {\n  return AppListController::GetInstance()->GetAppListWindow();\n}\n", "target": 0, "idx": 121976}
{"func": "HistogramBase* CustomHistogram::FactoryGet(\n    const std::string& name,\n    const std::vector<Sample>& custom_ranges,\n    int32_t flags) {\n  CHECK(ValidateCustomRanges(custom_ranges));\n\n  return Factory(name, &custom_ranges, flags).Build();\n}\n", "target": 0, "idx": 152710}
{"func": "error::Error GLES2DecoderPassthroughImpl::DoGetVertexAttribIuiv(\n    GLuint index,\n    GLenum pname,\n    GLsizei bufsize,\n    GLsizei* length,\n    GLuint* params) {\n  api()->glGetVertexAttribIuivRobustANGLEFn(index, pname, bufsize, length,\n                                            params);\n  return error::kNoError;\n}\n", "target": 0, "idx": 154724}
{"func": "void ide_data_writew(void *opaque, uint32_t addr, uint32_t val)\n{\n    IDEBus *bus = opaque;\n    IDEState *s = idebus_active_if(bus);\n    uint8_t *p;\n\n    /* PIO data access allowed only when DRQ bit is set. The result of a write\n     * during PIO out is indeterminate, just ignore it. */\n    if (!(s->status & DRQ_STAT) || ide_is_pio_out(s)) {\n        return;\n    }\n\n    p = s->data_ptr;\n    *(uint16_t *)p = le16_to_cpu(val);\n    p += 2;\n    s->data_ptr = p;\n    if (p >= s->data_end)\n        s->end_transfer_func(s);\n}\n", "target": 0, "idx": 6731}
{"func": "void CapturerMac::CgBlit(const VideoFrameBuffer& buffer,\n                         const InvalidRects& rects) {\n  if (last_buffer_)\n    memcpy(buffer.ptr(), last_buffer_,\n           buffer.bytes_per_row() * buffer.size().height());\n  last_buffer_ = buffer.ptr();\n  CGDirectDisplayID main_display = CGMainDisplayID();\n  uint8* display_base_address =\n      reinterpret_cast<uint8*>(CGDisplayBaseAddress(main_display));\n  int src_bytes_per_row = CGDisplayBytesPerRow(main_display);\n  int src_bytes_per_pixel = CGDisplayBitsPerPixel(main_display) / 8;\n  for (InvalidRects::iterator i = rects.begin(); i != rects.end(); ++i) {\n    int src_row_offset =  i->x() * src_bytes_per_pixel;\n    int dst_row_offset = i->x() * sizeof(uint32_t);\n    int rect_width_in_bytes = i->width() * src_bytes_per_pixel;\n    int ymax = i->height() + i->y();\n    for (int y = i->y(); y < ymax; ++y) {\n      memcpy(buffer.ptr() + y * buffer.bytes_per_row() + dst_row_offset,\n             display_base_address + y * src_bytes_per_row + src_row_offset,\n             rect_width_in_bytes);\n    }\n  }\n}\n", "target": 0, "idx": 103374}
{"func": "AccessibilityMode WebContentsImpl::GetAccessibilityMode() const {\n  return accessibility_mode_;\n}\n", "target": 0, "idx": 144511}
{"func": "static void SSL_SESSION_list_add(SSL_CTX *ctx, SSL_SESSION *s)\n{\n    if ((s->next != NULL) && (s->prev != NULL))\n        SSL_SESSION_list_remove(ctx, s);\n\n    if (ctx->session_cache_head == NULL) {\n        ctx->session_cache_head = s;\n        ctx->session_cache_tail = s;\n        s->prev = (SSL_SESSION *)&(ctx->session_cache_head);\n        s->next = (SSL_SESSION *)&(ctx->session_cache_tail);\n    } else {\n        s->next = ctx->session_cache_head;\n        s->next->prev = s;\n        s->prev = (SSL_SESSION *)&(ctx->session_cache_head);\n        ctx->session_cache_head = s;\n    }\n}\n", "target": 0, "idx": 12791}
{"func": "base::string16 GetClipboardText() {\n  if (!ui::Clipboard::IsSupportedClipboardType(ui::CLIPBOARD_TYPE_SELECTION))\n    return base::string16();\n  ui::Clipboard* clipboard = ui::Clipboard::GetForCurrentThread();\n  CHECK(clipboard);\n  base::string16 clipboard_text;\n  clipboard->ReadText(ui::CLIPBOARD_TYPE_SELECTION, &clipboard_text);\n  return clipboard_text;\n}\n", "target": 0, "idx": 134340}
{"func": "WebContents* GetWebContents(int render_process_id,\n                            int render_frame_id,\n                            int frame_tree_node_id) {\n  DCHECK(IsBrowserSideNavigationEnabled());\n\n  WebContents* web_contents = WebContents::FromRenderFrameHost(\n      RenderFrameHost::FromID(render_process_id, render_frame_id));\n  if (web_contents)\n    return web_contents;\n\n  return WebContents::FromFrameTreeNodeId(frame_tree_node_id);\n}\n", "target": 0, "idx": 159253}
{"func": "irc_server_set_addresses (struct t_irc_server *server, const char *addresses)\n{\n    int i;\n    char *pos, *error;\n    long number;\n    \n    /* free data */\n    server->addresses_count = 0;\n    if (server->addresses_array)\n    {\n        weechat_string_free_split (server->addresses_array);\n        server->addresses_array = NULL;\n    }\n    if (server->ports_array)\n    {\n        free (server->ports_array);\n        server->ports_array = NULL;\n    }\n    \n    /* set new addresses/ports */\n    if (addresses && addresses[0])\n    {\n        server->addresses_array = weechat_string_split (addresses,\n                                                        \",\", 0, 0,\n                                                        &server->addresses_count);\n        server->ports_array = malloc (server->addresses_count * sizeof (server->ports_array[0]));\n        for (i = 0; i < server->addresses_count; i++)\n        {\n            pos = strchr (server->addresses_array[i], '/');\n            if (pos)\n            {\n                pos[0] = 0;\n                pos++;\n                error = NULL;\n                number = strtol (pos, &error, 10);\n                server->ports_array[i] = (error && !error[0]) ?\n                    number : IRC_SERVER_DEFAULT_PORT;\n            }\n            else\n            {\n                server->ports_array[i] = IRC_SERVER_DEFAULT_PORT;\n            }\n        }\n    }\n}\n", "target": 0, "idx": 3516}
{"func": "static int readEnergyInfo()\n{\n    ALOGV(\"%s:\",__FUNCTION__);\n    jboolean result = JNI_FALSE;\n if (!sBluetoothInterface) return result;\n int ret = sBluetoothInterface->read_energy_info();\n    result = (ret == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;\n return result;\n}\n", "target": 0, "idx": 176867}
{"func": "void HTMLFormControlElement::setFormMethod(const AtomicString& value) {\n  setAttribute(kFormmethodAttr, value);\n}\n", "target": 0, "idx": 149260}
{"func": "vc4_save_hang_state(struct drm_device *dev)\n{\n\tstruct vc4_dev *vc4 = to_vc4_dev(dev);\n\tstruct drm_vc4_get_hang_state *state;\n\tstruct vc4_hang_state *kernel_state;\n\tstruct vc4_exec_info *exec[2];\n\tstruct vc4_bo *bo;\n\tunsigned long irqflags;\n\tunsigned int i, j, unref_list_count, prev_idx;\n\n\tkernel_state = kcalloc(1, sizeof(*kernel_state), GFP_KERNEL);\n\tif (!kernel_state)\n\t\treturn;\n\n\tstate = &kernel_state->user_state;\n\n\tspin_lock_irqsave(&vc4->job_lock, irqflags);\n\texec[0] = vc4_first_bin_job(vc4);\n\texec[1] = vc4_first_render_job(vc4);\n\tif (!exec[0] && !exec[1]) {\n\t\tspin_unlock_irqrestore(&vc4->job_lock, irqflags);\n\t\treturn;\n\t}\n\n\t/* Get the bos from both binner and renderer into hang state. */\n\tstate->bo_count = 0;\n\tfor (i = 0; i < 2; i++) {\n\t\tif (!exec[i])\n\t\t\tcontinue;\n\n\t\tunref_list_count = 0;\n\t\tlist_for_each_entry(bo, &exec[i]->unref_list, unref_head)\n\t\t\tunref_list_count++;\n\t\tstate->bo_count += exec[i]->bo_count + unref_list_count;\n\t}\n\n\tkernel_state->bo = kcalloc(state->bo_count,\n\t\t\t\t   sizeof(*kernel_state->bo), GFP_ATOMIC);\n\n\tif (!kernel_state->bo) {\n\t\tspin_unlock_irqrestore(&vc4->job_lock, irqflags);\n\t\treturn;\n\t}\n\n\tprev_idx = 0;\n\tfor (i = 0; i < 2; i++) {\n\t\tif (!exec[i])\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < exec[i]->bo_count; j++) {\n\t\t\tdrm_gem_object_reference(&exec[i]->bo[j]->base);\n\t\t\tkernel_state->bo[j + prev_idx] = &exec[i]->bo[j]->base;\n\t\t}\n\n\t\tlist_for_each_entry(bo, &exec[i]->unref_list, unref_head) {\n\t\t\tdrm_gem_object_reference(&bo->base.base);\n\t\t\tkernel_state->bo[j + prev_idx] = &bo->base.base;\n\t\t\tj++;\n\t\t}\n\t\tprev_idx = j + 1;\n\t}\n\n\tif (exec[0])\n\t\tstate->start_bin = exec[0]->ct0ca;\n\tif (exec[1])\n\t\tstate->start_render = exec[1]->ct1ca;\n\n\tspin_unlock_irqrestore(&vc4->job_lock, irqflags);\n\n\tstate->ct0ca = V3D_READ(V3D_CTNCA(0));\n\tstate->ct0ea = V3D_READ(V3D_CTNEA(0));\n\n\tstate->ct1ca = V3D_READ(V3D_CTNCA(1));\n\tstate->ct1ea = V3D_READ(V3D_CTNEA(1));\n\n\tstate->ct0cs = V3D_READ(V3D_CTNCS(0));\n\tstate->ct1cs = V3D_READ(V3D_CTNCS(1));\n\n\tstate->ct0ra0 = V3D_READ(V3D_CT00RA0);\n\tstate->ct1ra0 = V3D_READ(V3D_CT01RA0);\n\n\tstate->bpca = V3D_READ(V3D_BPCA);\n\tstate->bpcs = V3D_READ(V3D_BPCS);\n\tstate->bpoa = V3D_READ(V3D_BPOA);\n\tstate->bpos = V3D_READ(V3D_BPOS);\n\n\tstate->vpmbase = V3D_READ(V3D_VPMBASE);\n\n\tstate->dbge = V3D_READ(V3D_DBGE);\n\tstate->fdbgo = V3D_READ(V3D_FDBGO);\n\tstate->fdbgb = V3D_READ(V3D_FDBGB);\n\tstate->fdbgr = V3D_READ(V3D_FDBGR);\n\tstate->fdbgs = V3D_READ(V3D_FDBGS);\n\tstate->errstat = V3D_READ(V3D_ERRSTAT);\n\n\tspin_lock_irqsave(&vc4->job_lock, irqflags);\n\tif (vc4->hang_state) {\n\t\tspin_unlock_irqrestore(&vc4->job_lock, irqflags);\n\t\tvc4_free_hang_state(dev, kernel_state);\n\t} else {\n\t\tvc4->hang_state = kernel_state;\n\t\tspin_unlock_irqrestore(&vc4->job_lock, irqflags);\n\t}\n}\n", "target": 0, "idx": 68699}
{"func": "BOOL update_bounds_is_null(rdpBounds* bounds)\n{\n\tif ((bounds->left == 0) && (bounds->top == 0) &&\n\t    (bounds->right == 0) && (bounds->bottom == 0))\n\t\treturn TRUE;\n\n\treturn FALSE;\n}\n", "target": 0, "idx": 83550}
{"func": " MockRenderProcess::MockRenderProcess()\n    : transport_dib_next_sequence_number_(0) {\n }\n", "target": 1, "idx": 184712}
{"func": " image_transform_png_set_expand_gray_1_2_4_to_8_add(image_transform *this,\n    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)\n {\n    return image_transform_png_set_expand_add(this, that, colour_type,\n       bit_depth);\n }\n", "target": 1, "idx": 187652}
{"func": "bool ChromeContentBrowserClient::ShouldUseProcessPerSite(\n    content::BrowserContext* browser_context, const GURL& effective_url) {\n\n  Profile* profile = Profile::FromBrowserContext(browser_context);\n  if (!profile)\n    return false;\n\n#if !defined(OS_ANDROID)\n  if (search::ShouldUseProcessPerSiteForInstantURL(effective_url, profile))\n    return true;\n#endif\n\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n  return ChromeContentBrowserClientExtensionsPart::ShouldUseProcessPerSite(\n      profile, effective_url);\n#else\n  return false;\n#endif\n}\n", "target": 0, "idx": 155458}
{"func": "ip_rfc1001_connect(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\t/*\n\t * some servers require RFC1001 sessinit before sending\n\t * negprot - BB check reconnection in case where second\n\t * sessinit is sent but no second negprot\n\t */\n\tstruct rfc1002_session_packet *ses_init_buf;\n\tstruct smb_hdr *smb_buf;\n\tses_init_buf = kzalloc(sizeof(struct rfc1002_session_packet),\n\t\t\t       GFP_KERNEL);\n\tif (ses_init_buf) {\n\t\tses_init_buf->trailer.session_req.called_len = 32;\n\n\t\tif (server->server_RFC1001_name &&\n\t\t    server->server_RFC1001_name[0] != 0)\n\t\t\trfc1002mangle(ses_init_buf->trailer.\n\t\t\t\t      session_req.called_name,\n\t\t\t\t      server->server_RFC1001_name,\n\t\t\t\t      RFC1001_NAME_LEN_WITH_NULL);\n\t\telse\n\t\t\trfc1002mangle(ses_init_buf->trailer.\n\t\t\t\t      session_req.called_name,\n\t\t\t\t      DEFAULT_CIFS_CALLED_NAME,\n\t\t\t\t      RFC1001_NAME_LEN_WITH_NULL);\n\n\t\tses_init_buf->trailer.session_req.calling_len = 32;\n\n\t\t/*\n\t\t * calling name ends in null (byte 16) from old smb\n\t\t * convention.\n\t\t */\n\t\tif (server->workstation_RFC1001_name &&\n\t\t    server->workstation_RFC1001_name[0] != 0)\n\t\t\trfc1002mangle(ses_init_buf->trailer.\n\t\t\t\t      session_req.calling_name,\n\t\t\t\t      server->workstation_RFC1001_name,\n\t\t\t\t      RFC1001_NAME_LEN_WITH_NULL);\n\t\telse\n\t\t\trfc1002mangle(ses_init_buf->trailer.\n\t\t\t\t      session_req.calling_name,\n\t\t\t\t      \"LINUX_CIFS_CLNT\",\n\t\t\t\t      RFC1001_NAME_LEN_WITH_NULL);\n\n\t\tses_init_buf->trailer.session_req.scope1 = 0;\n\t\tses_init_buf->trailer.session_req.scope2 = 0;\n\t\tsmb_buf = (struct smb_hdr *)ses_init_buf;\n\n\t\t/* sizeof RFC1002_SESSION_REQUEST with no scope */\n\t\tsmb_buf->smb_buf_length = cpu_to_be32(0x81000044);\n\t\trc = smb_send(server, smb_buf, 0x44);\n\t\tkfree(ses_init_buf);\n\t\t/*\n\t\t * RFC1001 layer in at least one server\n\t\t * requires very short break before negprot\n\t\t * presumably because not expecting negprot\n\t\t * to follow so fast.  This is a simple\n\t\t * solution that works without\n\t\t * complicating the code and causes no\n\t\t * significant slowing down on mount\n\t\t * for everyone else\n\t\t */\n\t\tusleep_range(1000, 2000);\n\t}\n\t/*\n\t * else the negprot may still work without this\n\t * even though malloc failed\n\t */\n\n\treturn rc;\n}\n", "target": 0, "idx": 29854}
{"func": " void Vp9Parser::UpdateSlots(const Vp9FrameHeader* fhdr) {\n   for (size_t i = 0; i < kVp9NumRefFrames; i++) {\n    if (fhdr->RefreshFlag(i)) {\n       ref_slots_[i].width = fhdr->width;\n       ref_slots_[i].height = fhdr->height;\n     }\n   }\n }\n", "target": 1, "idx": 183546}
{"func": "void gdImageSetAntiAliased (gdImagePtr im, int c)\n{\n\tim->AA = 1;\n\tim->AA_color = c;\n\tim->AA_dont_blend = -1;\n}\n", "target": 0, "idx": 51448}
{"func": "static inline uint32_t DefragHashGetKey(Packet *p)\n{\n    uint32_t key;\n\n    if (p->ip4h != NULL) {\n        DefragHashKey4 dhk;\n        if (p->src.addr_data32[0] > p->dst.addr_data32[0]) {\n            dhk.src = p->src.addr_data32[0];\n            dhk.dst = p->dst.addr_data32[0];\n        } else {\n            dhk.src = p->dst.addr_data32[0];\n            dhk.dst = p->src.addr_data32[0];\n        }\n        dhk.id = (uint32_t)IPV4_GET_IPID(p);\n        dhk.vlan_id[0] = p->vlan_id[0];\n        dhk.vlan_id[1] = p->vlan_id[1];\n\n        uint32_t hash = hashword(dhk.u32, 4, defrag_config.hash_rand);\n        key = hash % defrag_config.hash_size;\n    } else if (p->ip6h != NULL) {\n        DefragHashKey6 dhk;\n        if (DefragHashRawAddressIPv6GtU32(p->src.addr_data32, p->dst.addr_data32)) {\n            dhk.src[0] = p->src.addr_data32[0];\n            dhk.src[1] = p->src.addr_data32[1];\n            dhk.src[2] = p->src.addr_data32[2];\n            dhk.src[3] = p->src.addr_data32[3];\n            dhk.dst[0] = p->dst.addr_data32[0];\n            dhk.dst[1] = p->dst.addr_data32[1];\n            dhk.dst[2] = p->dst.addr_data32[2];\n            dhk.dst[3] = p->dst.addr_data32[3];\n        } else {\n            dhk.src[0] = p->dst.addr_data32[0];\n            dhk.src[1] = p->dst.addr_data32[1];\n            dhk.src[2] = p->dst.addr_data32[2];\n            dhk.src[3] = p->dst.addr_data32[3];\n            dhk.dst[0] = p->src.addr_data32[0];\n            dhk.dst[1] = p->src.addr_data32[1];\n            dhk.dst[2] = p->src.addr_data32[2];\n            dhk.dst[3] = p->src.addr_data32[3];\n        }\n        dhk.id = IPV6_EXTHDR_GET_FH_ID(p);\n        dhk.vlan_id[0] = p->vlan_id[0];\n        dhk.vlan_id[1] = p->vlan_id[1];\n\n        uint32_t hash = hashword(dhk.u32, 10, defrag_config.hash_rand);\n        key = hash % defrag_config.hash_size;\n    } else\n        key = 0;\n\n    return key;\n}\n", "target": 0, "idx": 67820}
{"func": "static inline void BLEND_OP(int I, u64 *W)\n{\n\tW[I & 15] += s1(W[(I-2) & 15]) + W[(I-7) & 15] + s0(W[(I-15) & 15]);\n}\n", "target": 0, "idx": 47367}
{"func": "static void svc_rdma_detach(struct svc_xprt *xprt)\n{\n\tstruct svcxprt_rdma *rdma =\n\t\tcontainer_of(xprt, struct svcxprt_rdma, sc_xprt);\n\tdprintk(\"svc: svc_rdma_detach(%p)\\n\", xprt);\n\n\t/* Disconnect and flush posted WQE */\n\trdma_disconnect(rdma->sc_cm_id);\n}\n", "target": 0, "idx": 65993}
{"func": "void Document::RegisterNodeList(const LiveNodeListBase* list) {\n  node_lists_.Add(list, list->InvalidationType());\n  LiveNodeListBaseWriteBarrier(this, list);\n  if (list->IsRootedAtTreeScope())\n    lists_invalidated_at_document_.insert(list);\n}\n", "target": 0, "idx": 141193}
{"func": " INST_HANDLER (lds) {\t// LDS Rd, k\n \tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n \tint k = (buf[3] << 8) | buf[2];\n \top->ptr = k;\n\n\t__generic_ld_st (op, \"ram\", 0, 1, 0, k, 0);\n\tESIL_A (\"r%d,=,\", d);\n}\n", "target": 1, "idx": 182406}
{"func": "static void encode_open_downgrade(struct xdr_stream *xdr, const struct nfs_closeargs *arg, struct compound_hdr *hdr)\n{\n\t__be32 *p;\n\n\tp = reserve_space(xdr, 4+NFS4_STATEID_SIZE+4);\n\t*p++ = cpu_to_be32(OP_OPEN_DOWNGRADE);\n\tp = xdr_encode_opaque_fixed(p, arg->stateid->data, NFS4_STATEID_SIZE);\n\t*p = cpu_to_be32(arg->seqid->sequence->counter);\n\tencode_share_access(xdr, arg->fmode);\n\thdr->nops++;\n\thdr->replen += decode_open_downgrade_maxsz;\n}\n", "target": 0, "idx": 23376}
{"func": "void WebDevToolsAgentImpl::clearBrowserCookies()\n{\n    m_client->clearBrowserCookies();\n}\n", "target": 1, "idx": 185047}
{"func": "static void sched_avg_update(struct rq *rq)\n{\n}\n", "target": 0, "idx": 22530}
{"func": "   void ChangeCurrentInputMethodFromId(const std::string& input_method_id) {\n    const chromeos::InputMethodDescriptor* descriptor =\n        chromeos::input_method::GetInputMethodDescriptorFromId(\n             input_method_id);\n     if (descriptor) {\n       ChangeCurrentInputMethod(*descriptor);\n    } else {\n      LOG(ERROR) << \"Descriptor is not found for: \" << input_method_id;\n    }\n   }\n", "target": 1, "idx": 183936}
{"func": "void FixFolderEnding(std::string &folder)\n{\n#if defined(WIN32)\n\tif (folder.at(folder.length() - 1) != '\\\\')\n\t\tfolder += \"\\\\\";\n#else\n\tif (folder.at(folder.length() - 1) != '/')\n\t\tfolder += \"/\";\n#endif\n}\n", "target": 0, "idx": 90911}
{"func": "const Cluster* Segment::FindOrPreloadCluster(long long requested_pos)\n{\n    if (requested_pos < 0)\n        return 0;\n \n    Cluster** const ii = m_clusters;\n    Cluster** i = ii;\n \n    const long count = m_clusterCount + m_clusterPreloadCount;\n \n    Cluster** const jj = ii + count;\n    Cluster** j = jj;\n \n    while (i < j)\n    {\n \n        Cluster** const k = i + (j - i) / 2;\n        assert(k < jj);\n        Cluster* const pCluster = *k;\n        assert(pCluster);\n        const long long pos = pCluster->GetPosition();\n        assert(pos >= 0);\n        if (pos < requested_pos)\n            i = k + 1;\n        else if (pos > requested_pos)\n            j = k;\n        else\n            return pCluster;\n    }\n    assert(i == j);\n    Cluster* const pCluster = Cluster::Create(\n                                this,\n                                -1,\n                                requested_pos);\n     assert(pCluster);\n \n    const ptrdiff_t idx = i - m_clusters;\n \n    PreloadCluster(pCluster, idx);\n    assert(m_clusters);\n    assert(m_clusterPreloadCount > 0);\n    assert(m_clusters[idx] == pCluster);\n \n    return pCluster;\n }\n", "target": 1, "idx": 188302}
{"func": "static int read_gab2_sub(AVFormatContext *s, AVStream *st, AVPacket *pkt)\n{\n    if (pkt->size >= 7 &&\n        pkt->size < INT_MAX - AVPROBE_PADDING_SIZE &&\n        !strcmp(pkt->data, \"GAB2\") && AV_RL16(pkt->data + 5) == 2) {\n        uint8_t desc[256];\n        int score      = AVPROBE_SCORE_EXTENSION, ret;\n        AVIStream *ast = st->priv_data;\n        AVInputFormat *sub_demuxer;\n        AVRational time_base;\n        int size;\n        AVIOContext *pb = avio_alloc_context(pkt->data + 7,\n                                             pkt->size - 7,\n                                             0, NULL, NULL, NULL, NULL);\n        AVProbeData pd;\n        unsigned int desc_len = avio_rl32(pb);\n\n        if (desc_len > pb->buf_end - pb->buf_ptr)\n            goto error;\n\n        ret = avio_get_str16le(pb, desc_len, desc, sizeof(desc));\n        avio_skip(pb, desc_len - ret);\n        if (*desc)\n            av_dict_set(&st->metadata, \"title\", desc, 0);\n\n        avio_rl16(pb);   /* flags? */\n        avio_rl32(pb);   /* data size */\n\n        size = pb->buf_end - pb->buf_ptr;\n        pd = (AVProbeData) { .buf      = av_mallocz(size + AVPROBE_PADDING_SIZE),\n                             .buf_size = size };\n        if (!pd.buf)\n            goto error;\n        memcpy(pd.buf, pb->buf_ptr, size);\n        sub_demuxer = av_probe_input_format2(&pd, 1, &score);\n        av_freep(&pd.buf);\n         if (!sub_demuxer)\n             goto error;\n \n         if (!(ast->sub_ctx = avformat_alloc_context()))\n             goto error;\n \n        ast->sub_ctx->pb = pb;\n\n        if (ff_copy_whiteblacklists(ast->sub_ctx, s) < 0)\n            goto error;\n\n        if (!avformat_open_input(&ast->sub_ctx, \"\", sub_demuxer, NULL)) {\n            if (ast->sub_ctx->nb_streams != 1)\n                goto error;\n            ff_read_packet(ast->sub_ctx, &ast->sub_pkt);\n            avcodec_parameters_copy(st->codecpar, ast->sub_ctx->streams[0]->codecpar);\n            time_base = ast->sub_ctx->streams[0]->time_base;\n            avpriv_set_pts_info(st, 64, time_base.num, time_base.den);\n        }\n        ast->sub_buffer = pkt->data;\n        memset(pkt, 0, sizeof(*pkt));\n        return 1;\n\nerror:\n        av_freep(&ast->sub_ctx);\n        av_freep(&pb);\n    }\n    return 0;\n}\n", "target": 1, "idx": 181245}
{"func": "bool Cues::Find(\n    long long time_ns,\n    const Track* pTrack,\n    const CuePoint*& pCP,\n    const CuePoint::TrackPosition*& pTP) const\n{\n    assert(time_ns >= 0);\n    assert(pTrack);\n \n #if 0\n     LoadCuePoint();  //establish invariant\n\n    assert(m_cue_points);\n    assert(m_count > 0);\n\n CuePoint** const ii = m_cue_points;\n CuePoint** i = ii;\n\n CuePoint** const jj = ii + m_count + m_preload_count;\n CuePoint** j = jj;\n\n    pCP = *i;\n    assert(pCP);\n\n if (time_ns <= pCP->GetTime(m_pSegment))\n {\n        pTP = pCP->Find(pTrack);\n return (pTP != NULL);\n }\n\n IMkvReader* const pReader = m_pSegment->m_pReader;\n\n while (i < j)\n {\n\n CuePoint** const k = i + (j - i) / 2;\n        assert(k < jj);\n\n CuePoint* const pCP = *k;\n        assert(pCP);\n\n        pCP->Load(pReader);\n\n const long long t = pCP->GetTime(m_pSegment);\n\n if (t <= time_ns)\n            i = k + 1;\n else\n            j = k;\n\n        assert(i <= j);\n }\n\n    assert(i == j);\n    assert(i <= jj);\n    assert(i > ii);\n\n    pCP = *--i;\n\n     assert(pCP);\n     assert(pCP->GetTime(m_pSegment) <= time_ns);\n #else\n    if (m_cue_points == NULL)\n        return false;\n \n    if (m_count == 0)\n        return false;\n \n    CuePoint** const ii = m_cue_points;\n    CuePoint** i = ii;\n \n    CuePoint** const jj = ii + m_count;\n    CuePoint** j = jj;\n \n    pCP = *i;\n    assert(pCP);\n \n    if (time_ns <= pCP->GetTime(m_pSegment))\n    {\n        pTP = pCP->Find(pTrack);\n        return (pTP != NULL);\n    }\n    while (i < j)\n    {\n        CuePoint** const k = i + (j - i) / 2;\n        assert(k < jj);\n        CuePoint* const pCP = *k;\n        assert(pCP);\n        const long long t = pCP->GetTime(m_pSegment);\n        if (t <= time_ns)\n            i = k + 1;\n        else\n            j = k;\n        assert(i <= j);\n    }\n    assert(i == j);\n    assert(i <= jj);\n    assert(i > ii);\n    pCP = *--i;\n    assert(pCP);\n    assert(pCP->GetTime(m_pSegment) <= time_ns);\n#endif\n     pTP = pCP->Find(pTrack);\n     return (pTP != NULL);\n}\n", "target": 1, "idx": 188299}
{"func": "void NavigationControllerImpl::RendererDidNavigateToNewPage(\n    RenderFrameHostImpl* rfh,\n    const FrameHostMsg_DidCommitProvisionalLoad_Params& params,\n    bool is_in_page,\n    bool replace_entry,\n    NavigationHandleImpl* handle) {\n  std::unique_ptr<NavigationEntryImpl> new_entry;\n  bool update_virtual_url = false;\n\n  if (is_in_page && GetLastCommittedEntry()) {\n    FrameNavigationEntry* frame_entry = new FrameNavigationEntry(\n        params.frame_unique_name, params.item_sequence_number,\n        params.document_sequence_number, rfh->GetSiteInstance(), nullptr,\n        params.url, params.referrer, params.method, params.post_id);\n    new_entry = GetLastCommittedEntry()->CloneAndReplace(\n        frame_entry, true, rfh->frame_tree_node(),\n        delegate_->GetFrameTree()->root());\n\n     CHECK(frame_entry->HasOneRef());\n \n     update_virtual_url = new_entry->update_virtual_url_with_url();\n   }\n \n  if (!new_entry &&\n      PendingEntryMatchesHandle(handle) && pending_entry_index_ == -1 &&\n      (!pending_entry_->site_instance() ||\n       pending_entry_->site_instance() == rfh->GetSiteInstance())) {\n    new_entry = pending_entry_->Clone();\n\n    update_virtual_url = new_entry->update_virtual_url_with_url();\n    new_entry->GetSSL() = handle->ssl_status();\n  }\n\n  if (!new_entry) {\n    new_entry = base::WrapUnique(new NavigationEntryImpl);\n\n    GURL url = params.url;\n    bool needs_update = false;\n    BrowserURLHandlerImpl::GetInstance()->RewriteURLIfNecessary(\n        &url, browser_context_, &needs_update);\n    new_entry->set_update_virtual_url_with_url(needs_update);\n\n    update_virtual_url = needs_update;\n    new_entry->GetSSL() = handle->ssl_status();\n  }\n\n  new_entry->set_page_type(params.url_is_unreachable ? PAGE_TYPE_ERROR\n                                                     : PAGE_TYPE_NORMAL);\n  new_entry->SetURL(params.url);\n  if (update_virtual_url)\n    UpdateVirtualURLToURL(new_entry.get(), params.url);\n  new_entry->SetReferrer(params.referrer);\n  new_entry->SetTransitionType(params.transition);\n  new_entry->set_site_instance(\n      static_cast<SiteInstanceImpl*>(rfh->GetSiteInstance()));\n  new_entry->SetOriginalRequestURL(params.original_request_url);\n  new_entry->SetIsOverridingUserAgent(params.is_overriding_user_agent);\n\n  FrameNavigationEntry* frame_entry =\n      new_entry->GetFrameEntry(rfh->frame_tree_node());\n  frame_entry->set_frame_unique_name(params.frame_unique_name);\n  frame_entry->set_item_sequence_number(params.item_sequence_number);\n  frame_entry->set_document_sequence_number(params.document_sequence_number);\n  frame_entry->set_method(params.method);\n  frame_entry->set_post_id(params.post_id);\n\n  if (is_in_page && GetLastCommittedEntry()) {\n    new_entry->SetTitle(GetLastCommittedEntry()->GetTitle());\n    new_entry->GetFavicon() = GetLastCommittedEntry()->GetFavicon();\n  }\n\n  DCHECK(!params.history_list_was_cleared || !replace_entry);\n  if (params.history_list_was_cleared) {\n    DiscardNonCommittedEntriesInternal();\n    entries_.clear();\n    last_committed_entry_index_ = -1;\n  }\n\n  InsertOrReplaceEntry(std::move(new_entry), replace_entry);\n}\n", "target": 1, "idx": 186379}
{"func": "SYSCALL_DEFINE5(recvmmsg, int, fd, struct mmsghdr __user *, mmsg,\n\t\tunsigned int, vlen, unsigned int, flags,\n\t\tstruct timespec __user *, timeout)\n{\n\treturn do_sys_recvmmsg(fd, mmsg, vlen, flags, timeout);\n}\n", "target": 0, "idx": 82230}
{"func": "v8::Handle<v8::Value> AppWindowCustomBindings::GetView(\n    const v8::Arguments& args) {\n  if (args.Length() != 1)\n    return v8::Undefined();\n\n  if (!args[0]->IsInt32())\n    return v8::Undefined();\n\n  int view_id = args[0]->Int32Value();\n\n  if (view_id == MSG_ROUTING_NONE)\n    return v8::Undefined();\n\n  FindViewByID view_finder(view_id);\n  content::RenderView::ForEach(&view_finder);\n  content::RenderView* view = view_finder.view();\n  if (!view)\n    return v8::Undefined();\n\n  content::RenderView* render_view = GetCurrentRenderView();\n  if (!render_view)\n    return v8::Undefined();\n   WebKit::WebFrame* opener = render_view->GetWebView()->mainFrame();\n   WebKit::WebFrame* frame = view->GetWebView()->mainFrame();\n   frame->setOpener(opener);\n \n   v8::Local<v8::Value> window = frame->mainWorldScriptContext()->Global();\n   return window;\n}\n", "target": 1, "idx": 184389}
{"func": "kg_unseal_v1(context, minor_status, ctx, ptr, bodysize, message_buffer,\n             conf_state, qop_state, toktype)\n    krb5_context context;\n    OM_uint32 *minor_status;\n    krb5_gss_ctx_id_rec *ctx;\n    unsigned char *ptr;\n    int bodysize;\n    gss_buffer_t message_buffer;\n    int *conf_state;\n    gss_qop_t *qop_state;\n    int toktype;\n{\n    krb5_error_code code;\n    int conflen = 0;\n    int signalg;\n    int sealalg;\n    int bad_pad = 0;\n    gss_buffer_desc token;\n    krb5_checksum cksum;\n    krb5_checksum md5cksum;\n    krb5_data plaind;\n    char *data_ptr;\n    unsigned char *plain;\n    unsigned int cksum_len = 0;\n    size_t plainlen;\n    int direction;\n    krb5_ui_4 seqnum;\n    OM_uint32 retval;\n    size_t sumlen;\n    size_t padlen;\n    krb5_keyusage sign_usage = KG_USAGE_SIGN;\n\n    if (toktype == KG_TOK_SEAL_MSG) {\n        message_buffer->length = 0;\n        message_buffer->value = NULL;\n    }\n\n    /* Sanity checks */\n\n    if (ctx->seq == NULL) {\n        /* ctx was established using a newer enctype, and cannot process RFC\n         * 1964 tokens. */\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    if ((bodysize < 22) || (ptr[4] != 0xff) || (ptr[5] != 0xff)) {\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    signalg = ptr[0] + (ptr[1]<<8);\n    sealalg = ptr[2] + (ptr[3]<<8);\n\n    if ((toktype != KG_TOK_SEAL_MSG) &&\n        (sealalg != 0xffff)) {\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    /* in the current spec, there is only one valid seal algorithm per\n       key type, so a simple comparison is ok */\n\n    if ((toktype == KG_TOK_SEAL_MSG) &&\n        !((sealalg == 0xffff) ||\n          (sealalg == ctx->sealalg))) {\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    /* there are several mappings of seal algorithms to sign algorithms,\n       but few enough that we can try them all. */\n\n    if ((ctx->sealalg == SEAL_ALG_NONE && signalg > 1) ||\n        (ctx->sealalg == SEAL_ALG_1 && signalg != SGN_ALG_3) ||\n        (ctx->sealalg == SEAL_ALG_DES3KD &&\n         signalg != SGN_ALG_HMAC_SHA1_DES3_KD)||\n        (ctx->sealalg == SEAL_ALG_MICROSOFT_RC4 &&\n         signalg != SGN_ALG_HMAC_MD5)) {\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    switch (signalg) {\n    case SGN_ALG_DES_MAC_MD5:\n    case SGN_ALG_MD2_5:\n    case SGN_ALG_HMAC_MD5:\n        cksum_len = 8;\n        if (toktype != KG_TOK_SEAL_MSG)\n            sign_usage = 15;\n        break;\n    case SGN_ALG_3:\n        cksum_len = 16;\n        break;\n    case SGN_ALG_HMAC_SHA1_DES3_KD:\n        cksum_len = 20;\n        break;\n    default:\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    if ((size_t)bodysize < 14 + cksum_len) {\n        *minor_status = 0;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    /* get the token parameters */\n\n    if ((code = kg_get_seq_num(context, ctx->seq, ptr+14, ptr+6, &direction,\n                               &seqnum))) {\n        *minor_status = code;\n        return(GSS_S_BAD_SIG);\n    }\n\n    /* decode the message, if SEAL */\n\n    if (toktype == KG_TOK_SEAL_MSG) {\n        size_t tmsglen = bodysize-(14+cksum_len);\n        if (sealalg != 0xffff) {\n            if ((plain = (unsigned char *) xmalloc(tmsglen)) == NULL) {\n                *minor_status = ENOMEM;\n                return(GSS_S_FAILURE);\n            }\n            if (ctx->sealalg == SEAL_ALG_MICROSOFT_RC4) {\n                unsigned char bigend_seqnum[4];\n                krb5_keyblock *enc_key;\n                int i;\n                store_32_be(seqnum, bigend_seqnum);\n                code = krb5_k_key_keyblock(context, ctx->enc, &enc_key);\n                if (code)\n                {\n                    xfree(plain);\n                    *minor_status = code;\n                    return(GSS_S_FAILURE);\n                }\n\n                assert (enc_key->length == 16);\n                for (i = 0; i <= 15; i++)\n                    ((char *) enc_key->contents)[i] ^=0xf0;\n                code = kg_arcfour_docrypt (enc_key, 0,\n                                           &bigend_seqnum[0], 4,\n                                           ptr+14+cksum_len, tmsglen,\n                                           plain);\n                krb5_free_keyblock (context, enc_key);\n            } else {\n                code = kg_decrypt(context, ctx->enc, KG_USAGE_SEAL, NULL,\n                                  ptr+14+cksum_len, plain, tmsglen);\n            }\n            if (code) {\n                xfree(plain);\n                *minor_status = code;\n                return(GSS_S_FAILURE);\n            }\n        } else {\n            plain = ptr+14+cksum_len;\n        }\n\n        plainlen = tmsglen;\n\n        conflen = kg_confounder_size(context, ctx->enc->keyblock.enctype);\n        if (tmsglen < conflen) {\n            if (sealalg != 0xffff)\n                xfree(plain);\n            *minor_status = 0;\n            return(GSS_S_DEFECTIVE_TOKEN);\n        }\n        padlen = plain[tmsglen - 1];\n        if (tmsglen - conflen < padlen) {\n            /* Don't error out yet, to avoid padding oracle attacks.  We will\n             * treat this as a checksum failure later on. */\n            padlen = 0;\n            bad_pad = 1;\n        }\n        token.length = tmsglen - conflen - padlen;\n\n        if (token.length) {\n            if ((token.value = (void *) gssalloc_malloc(token.length)) == NULL) {\n                if (sealalg != 0xffff)\n                    xfree(plain);\n                *minor_status = ENOMEM;\n                return(GSS_S_FAILURE);\n            }\n            memcpy(token.value, plain+conflen, token.length);\n        } else {\n            token.value = NULL;\n        }\n    } else if (toktype == KG_TOK_SIGN_MSG) {\n        token = *message_buffer;\n        plain = token.value;\n        plainlen = token.length;\n    } else {\n        token.length = 0;\n        token.value = NULL;\n        plain = token.value;\n        plainlen = token.length;\n    }\n\n    /* compute the checksum of the message */\n\n    /* initialize the the cksum */\n    switch (signalg) {\n    case SGN_ALG_DES_MAC_MD5:\n    case SGN_ALG_MD2_5:\n    case SGN_ALG_DES_MAC:\n    case SGN_ALG_3:\n        md5cksum.checksum_type = CKSUMTYPE_RSA_MD5;\n        break;\n    case SGN_ALG_HMAC_MD5:\n        md5cksum.checksum_type = CKSUMTYPE_HMAC_MD5_ARCFOUR;\n        break;\n    case SGN_ALG_HMAC_SHA1_DES3_KD:\n        md5cksum.checksum_type = CKSUMTYPE_HMAC_SHA1_DES3;\n        break;\n    default:\n        abort ();\n    }\n\n    code = krb5_c_checksum_length(context, md5cksum.checksum_type, &sumlen);\n    if (code)\n        return(code);\n    md5cksum.length = sumlen;\n\n    switch (signalg) {\n    case SGN_ALG_DES_MAC_MD5:\n    case SGN_ALG_3:\n        /* compute the checksum of the message */\n\n        /* 8 = bytes of token body to be checksummed according to spec */\n\n        if (! (data_ptr = xmalloc(8 + plainlen))) {\n            if (sealalg != 0xffff)\n                xfree(plain);\n            if (toktype == KG_TOK_SEAL_MSG)\n                gssalloc_free(token.value);\n            *minor_status = ENOMEM;\n            return(GSS_S_FAILURE);\n        }\n\n        (void) memcpy(data_ptr, ptr-2, 8);\n\n        (void) memcpy(data_ptr+8, plain, plainlen);\n\n        plaind.length = 8 + plainlen;\n        plaind.data = data_ptr;\n        code = krb5_k_make_checksum(context, md5cksum.checksum_type,\n                                    ctx->seq, sign_usage,\n                                    &plaind, &md5cksum);\n        xfree(data_ptr);\n\n        if (code) {\n            if (toktype == KG_TOK_SEAL_MSG)\n                gssalloc_free(token.value);\n            *minor_status = code;\n            return(GSS_S_FAILURE);\n        }\n\n        code = kg_encrypt_inplace(context, ctx->seq, KG_USAGE_SEAL,\n                                  (g_OID_equal(ctx->mech_used,\n                                               gss_mech_krb5_old) ?\n                                   ctx->seq->keyblock.contents : NULL),\n                                  md5cksum.contents, 16);\n        if (code) {\n            krb5_free_checksum_contents(context, &md5cksum);\n            if (toktype == KG_TOK_SEAL_MSG)\n                gssalloc_free(token.value);\n            *minor_status = code;\n            return GSS_S_FAILURE;\n        }\n\n        if (signalg == 0)\n            cksum.length = 8;\n        else\n            cksum.length = 16;\n        cksum.contents = md5cksum.contents + 16 - cksum.length;\n\n        code = k5_bcmp(cksum.contents, ptr + 14, cksum.length);\n        break;\n\n    case SGN_ALG_MD2_5:\n        if (!ctx->seed_init &&\n            (code = kg_make_seed(context, ctx->subkey, ctx->seed))) {\n            krb5_free_checksum_contents(context, &md5cksum);\n            if (sealalg != 0xffff)\n                xfree(plain);\n            if (toktype == KG_TOK_SEAL_MSG)\n                gssalloc_free(token.value);\n            *minor_status = code;\n            return GSS_S_FAILURE;\n        }\n\n        if (! (data_ptr = xmalloc(sizeof(ctx->seed) + 8 + plainlen))) {\n            krb5_free_checksum_contents(context, &md5cksum);\n            if (sealalg == 0)\n                xfree(plain);\n            if (toktype == KG_TOK_SEAL_MSG)\n                gssalloc_free(token.value);\n            *minor_status = ENOMEM;\n            return(GSS_S_FAILURE);\n        }\n        (void) memcpy(data_ptr, ptr-2, 8);\n        (void) memcpy(data_ptr+8, ctx->seed, sizeof(ctx->seed));\n        (void) memcpy(data_ptr+8+sizeof(ctx->seed), plain, plainlen);\n        plaind.length = 8 + sizeof(ctx->seed) + plainlen;\n        plaind.data = data_ptr;\n        krb5_free_checksum_contents(context, &md5cksum);\n        code = krb5_k_make_checksum(context, md5cksum.checksum_type,\n                                    ctx->seq, sign_usage,\n                                    &plaind, &md5cksum);\n        xfree(data_ptr);\n\n        if (code) {\n            if (sealalg == 0)\n                xfree(plain);\n            if (toktype == KG_TOK_SEAL_MSG)\n                gssalloc_free(token.value);\n            *minor_status = code;\n            return(GSS_S_FAILURE);\n        }\n\n        code = k5_bcmp(md5cksum.contents, ptr + 14, 8);\n        /* Falls through to defective-token??  */\n\n    default:\n        *minor_status = 0;\n        return(GSS_S_DEFECTIVE_TOKEN);\n\n    case SGN_ALG_HMAC_SHA1_DES3_KD:\n    case SGN_ALG_HMAC_MD5:\n        /* compute the checksum of the message */\n\n        /* 8 = bytes of token body to be checksummed according to spec */\n\n        if (! (data_ptr = xmalloc(8 + plainlen))) {\n            if (sealalg != 0xffff)\n                xfree(plain);\n            if (toktype == KG_TOK_SEAL_MSG)\n                gssalloc_free(token.value);\n            *minor_status = ENOMEM;\n            return(GSS_S_FAILURE);\n        }\n\n        (void) memcpy(data_ptr, ptr-2, 8);\n\n        (void) memcpy(data_ptr+8, plain, plainlen);\n\n        plaind.length = 8 + plainlen;\n        plaind.data = data_ptr;\n        code = krb5_k_make_checksum(context, md5cksum.checksum_type,\n                                    ctx->seq, sign_usage,\n                                    &plaind, &md5cksum);\n        xfree(data_ptr);\n\n        if (code) {\n            if (toktype == KG_TOK_SEAL_MSG)\n                gssalloc_free(token.value);\n            *minor_status = code;\n            return(GSS_S_FAILURE);\n        }\n\n        code = k5_bcmp(md5cksum.contents, ptr + 14, cksum_len);\n        break;\n    }\n\n    krb5_free_checksum_contents(context, &md5cksum);\n    if (sealalg != 0xffff)\n        xfree(plain);\n\n    /* compare the computed checksum against the transmitted checksum */\n\n    if (code || bad_pad) {\n        if (toktype == KG_TOK_SEAL_MSG)\n            gssalloc_free(token.value);\n        *minor_status = 0;\n        return(GSS_S_BAD_SIG);\n    }\n\n\n    /* it got through unscathed.  Make sure the context is unexpired */\n\n    if (toktype == KG_TOK_SEAL_MSG)\n        *message_buffer = token;\n\n    if (conf_state)\n        *conf_state = (sealalg != 0xffff);\n\n    if (qop_state)\n        *qop_state = GSS_C_QOP_DEFAULT;\n\n    /* do sequencing checks */\n\n    if ((ctx->initiate && direction != 0xff) ||\n        (!ctx->initiate && direction != 0)) {\n        if (toktype == KG_TOK_SEAL_MSG) {\n            gssalloc_free(token.value);\n            message_buffer->value = NULL;\n            message_buffer->length = 0;\n        }\n        *minor_status = (OM_uint32)G_BAD_DIRECTION;\n        return(GSS_S_BAD_SIG);\n    }\n\n    retval = g_seqstate_check(ctx->seqstate, (uint64_t)seqnum);\n\n    /* success or ordering violation */\n\n    *minor_status = 0;\n    return(retval);\n}\n", "target": 0, "idx": 46471}
{"func": "int lzxd_decompress(struct lzxd_stream *lzx, off_t out_bytes) {\n  /* bitstream and huffman reading variables */\n  register unsigned int bit_buffer;\n  register int bits_left, i=0;\n  unsigned char *i_ptr, *i_end;\n  register unsigned short sym;\n\n  int match_length, length_footer, extra, verbatim_bits, bytes_todo;\n  int this_run, main_element, aligned_bits, j;\n  unsigned char *window, *runsrc, *rundest, buf[12];\n  unsigned int frame_size=0, end_frame, match_offset, window_posn;\n  unsigned int R0, R1, R2;\n\n  /* easy answers */\n  if (!lzx || (out_bytes < 0)) return MSPACK_ERR_ARGS;\n  if (lzx->error) return lzx->error;\n\n  /* flush out any stored-up bytes before we begin */\n  i = lzx->o_end - lzx->o_ptr;\n  if ((off_t) i > out_bytes) i = (int) out_bytes;\n  if (i) {\n    if (lzx->sys->write(lzx->output, lzx->o_ptr, i) != i) {\n      return lzx->error = MSPACK_ERR_WRITE;\n    }\n    lzx->o_ptr  += i;\n    lzx->offset += i;\n    out_bytes   -= i;\n  }\n  if (out_bytes == 0) return MSPACK_ERR_OK;\n\n  /* restore local state */\n  RESTORE_BITS;\n  window = lzx->window;\n  window_posn = lzx->window_posn;\n  R0 = lzx->R0;\n  R1 = lzx->R1;\n  R2 = lzx->R2;\n\n  end_frame = (unsigned int)((lzx->offset + out_bytes) / LZX_FRAME_SIZE) + 1;\n\n  while (lzx->frame < end_frame) {\n    /* have we reached the reset interval? (if there is one?) */\n    if (lzx->reset_interval && ((lzx->frame % lzx->reset_interval) == 0)) {\n      if (lzx->block_remaining) {\n\tD((\"%d bytes remaining at reset interval\", lzx->block_remaining))\n\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n      }\n\n      /* re-read the intel header and reset the huffman lengths */\n      lzxd_reset_state(lzx);\n      R0 = lzx->R0;\n      R1 = lzx->R1;\n      R2 = lzx->R2;\n    }\n\n    /* LZX DELTA format has chunk_size, not present in LZX format */\n    if (lzx->is_delta) {\n      ENSURE_BITS(16);\n      REMOVE_BITS(16);\n    }\n\n    /* read header if necessary */\n    if (!lzx->header_read) {\n      /* read 1 bit. if bit=0, intel filesize = 0.\n       * if bit=1, read intel filesize (32 bits) */\n      j = 0; READ_BITS(i, 1); if (i) { READ_BITS(i, 16); READ_BITS(j, 16); }\n      lzx->intel_filesize = (i << 16) | j;\n      lzx->header_read = 1;\n    } \n\n    /* calculate size of frame: all frames are 32k except the final frame\n     * which is 32kb or less. this can only be calculated when lzx->length\n     * has been filled in. */\n    frame_size = LZX_FRAME_SIZE;\n    if (lzx->length && (lzx->length - lzx->offset) < (off_t)frame_size) {\n      frame_size = lzx->length - lzx->offset;\n    }\n\n    /* decode until one more frame is available */\n    bytes_todo = lzx->frame_posn + frame_size - window_posn;\n    while (bytes_todo > 0) {\n      /* initialise new block, if one is needed */\n      if (lzx->block_remaining == 0) {\n\t/* realign if previous block was an odd-sized UNCOMPRESSED block */\n\tif ((lzx->block_type == LZX_BLOCKTYPE_UNCOMPRESSED) &&\n\t    (lzx->block_length & 1))\n\t{\n\t  READ_IF_NEEDED;\n\t  i_ptr++;\n\t}\n\n\t/* read block type (3 bits) and block length (24 bits) */\n\tREAD_BITS(lzx->block_type, 3);\n\tREAD_BITS(i, 16); READ_BITS(j, 8);\n\tlzx->block_remaining = lzx->block_length = (i << 8) | j;\n\t/*D((\"new block t%d len %u\", lzx->block_type, lzx->block_length))*/\n\n\t/* read individual block headers */\n\tswitch (lzx->block_type) {\n\tcase LZX_BLOCKTYPE_ALIGNED:\n\t  /* read lengths of and build aligned huffman decoding tree */\n\t  for (i = 0; i < 8; i++) { READ_BITS(j, 3); lzx->ALIGNED_len[i] = j; }\n\t  BUILD_TABLE(ALIGNED);\n\t  /* no break -- rest of aligned header is same as verbatim */\n\tcase LZX_BLOCKTYPE_VERBATIM:\n\t  /* read lengths of and build main huffman decoding tree */\n\t  READ_LENGTHS(MAINTREE, 0, 256);\n\t  READ_LENGTHS(MAINTREE, 256, LZX_NUM_CHARS + lzx->num_offsets);\n\t  BUILD_TABLE(MAINTREE);\n\t  /* if the literal 0xE8 is anywhere in the block... */\n\t  if (lzx->MAINTREE_len[0xE8] != 0) lzx->intel_started = 1;\n\t  /* read lengths of and build lengths huffman decoding tree */\n\t  READ_LENGTHS(LENGTH, 0, LZX_NUM_SECONDARY_LENGTHS);\n\t  BUILD_TABLE_MAYBE_EMPTY(LENGTH);\n\t  break;\n\n\tcase LZX_BLOCKTYPE_UNCOMPRESSED:\n\t  /* because we can't assume otherwise */\n \t  lzx->intel_started = 1;\n \n \t  /* read 1-16 (not 0-15) bits to align to bytes */\n\t  ENSURE_BITS(16);\n\t  if (bits_left > 16) i_ptr -= 2;\n \t  bits_left = 0; bit_buffer = 0;\n \n \t  /* read 12 bytes of stored R0 / R1 / R2 values */\n\t  for (rundest = &buf[0], i = 0; i < 12; i++) {\n\t    READ_IF_NEEDED;\n\t    *rundest++ = *i_ptr++;\n\t  }\n\t  R0 = buf[0] | (buf[1] << 8) | (buf[2]  << 16) | (buf[3]  << 24);\n\t  R1 = buf[4] | (buf[5] << 8) | (buf[6]  << 16) | (buf[7]  << 24);\n\t  R2 = buf[8] | (buf[9] << 8) | (buf[10] << 16) | (buf[11] << 24);\n\t  break;\n\n\tdefault:\n\t  D((\"bad block type\"))\n\t  return lzx->error = MSPACK_ERR_DECRUNCH;\n\t}\n      }\n\n      /* decode more of the block:\n       * run = min(what's available, what's needed) */\n      this_run = lzx->block_remaining;\n      if (this_run > bytes_todo) this_run = bytes_todo;\n\n      /* assume we decode exactly this_run bytes, for now */\n      bytes_todo           -= this_run;\n      lzx->block_remaining -= this_run;\n\n      /* decode at least this_run bytes */\n      switch (lzx->block_type) {\n      case LZX_BLOCKTYPE_VERBATIM:\n\twhile (this_run > 0) {\n\t  READ_HUFFSYM(MAINTREE, main_element);\n\t  if (main_element < LZX_NUM_CHARS) {\n\t    /* literal: 0 to LZX_NUM_CHARS-1 */\n\t    window[window_posn++] = main_element;\n\t    this_run--;\n\t  }\n\t  else {\n\t    /* match: LZX_NUM_CHARS + ((slot<<3) | length_header (3 bits)) */\n\t    main_element -= LZX_NUM_CHARS;\n\n\t    /* get match length */\n\t    match_length = main_element & LZX_NUM_PRIMARY_LENGTHS;\n\t    if (match_length == LZX_NUM_PRIMARY_LENGTHS) {\n\t      if (lzx->LENGTH_empty) {\n                D((\"LENGTH symbol needed but tree is empty\"))\n                return lzx->error = MSPACK_ERR_DECRUNCH;\n              }\n\t      READ_HUFFSYM(LENGTH, length_footer);\n\t      match_length += length_footer;\n\t    }\n\t    match_length += LZX_MIN_MATCH;\n\n\t    /* get match offset */\n\t    switch ((match_offset = (main_element >> 3))) {\n\t    case 0: match_offset = R0;                                  break;\n\t    case 1: match_offset = R1; R1=R0;        R0 = match_offset; break;\n\t    case 2: match_offset = R2; R2=R0;        R0 = match_offset; break;\n\t    case 3: match_offset = 1;  R2=R1; R1=R0; R0 = match_offset; break;\n\t    default:\n\t      extra = (match_offset >= 36) ? 17 : extra_bits[match_offset];\n\t      READ_BITS(verbatim_bits, extra);\n\t      match_offset = position_base[match_offset] - 2 + verbatim_bits;\n\t      R2 = R1; R1 = R0; R0 = match_offset;\n\t    }\n\n\t    /* LZX DELTA uses max match length to signal even longer match */\n\t    if (match_length == LZX_MAX_MATCH && lzx->is_delta) {\n\t\tint extra_len = 0;\n\t\tENSURE_BITS(3); /* 4 entry huffman tree */\n\t\tif (PEEK_BITS(1) == 0) {\n\t\t    REMOVE_BITS(1); /* '0' -> 8 extra length bits */\n\t\t    READ_BITS(extra_len, 8);\n\t\t}\n\t\telse if (PEEK_BITS(2) == 2) {\n\t\t    REMOVE_BITS(2); /* '10' -> 10 extra length bits + 0x100 */\n\t\t    READ_BITS(extra_len, 10);\n\t\t    extra_len += 0x100;\n\t\t}\n\t\telse if (PEEK_BITS(3) == 6) {\n\t\t    REMOVE_BITS(3); /* '110' -> 12 extra length bits + 0x500 */\n\t\t    READ_BITS(extra_len, 12);\n\t\t    extra_len += 0x500;\n\t\t}\n\t\telse {\n\t\t    REMOVE_BITS(3); /* '111' -> 15 extra length bits */\n\t\t    READ_BITS(extra_len, 15);\n\t\t}\n\t\tmatch_length += extra_len;\n\t    }\n\n\t    if ((window_posn + match_length) > lzx->window_size) {\n\t      D((\"match ran over window wrap\"))\n\t      return lzx->error = MSPACK_ERR_DECRUNCH;\n\t    }\n\t    \n\t    /* copy match */\n\t    rundest = &window[window_posn];\n\t    i = match_length;\n\t    /* does match offset wrap the window? */\n\t    if (match_offset > window_posn) {\n\t      if (match_offset > lzx->offset &&\n\t\t  (match_offset - window_posn) > lzx->ref_data_size)\n\t      {\n\t\tD((\"match offset beyond LZX stream\"))\n\t\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n\t      }\n\t      /* j = length from match offset to end of window */\n\t      j = match_offset - window_posn;\n\t      if (j > (int) lzx->window_size) {\n\t\tD((\"match offset beyond window boundaries\"))\n\t\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n\t      }\n\t      runsrc = &window[lzx->window_size - j];\n\t      if (j < i) {\n\t\t/* if match goes over the window edge, do two copy runs */\n\t\ti -= j; while (j-- > 0) *rundest++ = *runsrc++;\n\t\trunsrc = window;\n\t      }\n\t      while (i-- > 0) *rundest++ = *runsrc++;\n\t    }\n\t    else {\n\t      runsrc = rundest - match_offset;\n\t      while (i-- > 0) *rundest++ = *runsrc++;\n\t    }\n\n\t    this_run    -= match_length;\n\t    window_posn += match_length;\n\t  }\n\t} /* while (this_run > 0) */\n\tbreak;\n\n      case LZX_BLOCKTYPE_ALIGNED:\n\twhile (this_run > 0) {\n\t  READ_HUFFSYM(MAINTREE, main_element);\n\t  if (main_element < LZX_NUM_CHARS) {\n\t    /* literal: 0 to LZX_NUM_CHARS-1 */\n\t    window[window_posn++] = main_element;\n\t    this_run--;\n\t  }\n\t  else {\n\t    /* match: LZX_NUM_CHARS + ((slot<<3) | length_header (3 bits)) */\n\t    main_element -= LZX_NUM_CHARS;\n\n\t    /* get match length */\n\t    match_length = main_element & LZX_NUM_PRIMARY_LENGTHS;\n\t    if (match_length == LZX_NUM_PRIMARY_LENGTHS) {\n              if (lzx->LENGTH_empty) {\n                D((\"LENGTH symbol needed but tree is empty\"))\n                return lzx->error = MSPACK_ERR_DECRUNCH;\n              } \n\t      READ_HUFFSYM(LENGTH, length_footer);\n\t      match_length += length_footer;\n\t    }\n\t    match_length += LZX_MIN_MATCH;\n\n\t    /* get match offset */\n\t    switch ((match_offset = (main_element >> 3))) {\n\t    case 0: match_offset = R0;                             break;\n\t    case 1: match_offset = R1; R1 = R0; R0 = match_offset; break;\n\t    case 2: match_offset = R2; R2 = R0; R0 = match_offset; break;\n\t    default:\n\t      extra = (match_offset >= 36) ? 17 : extra_bits[match_offset];\n\t      match_offset = position_base[match_offset] - 2;\n\t      if (extra > 3) {\n\t\t/* verbatim and aligned bits */\n\t\textra -= 3;\n\t\tREAD_BITS(verbatim_bits, extra);\n\t\tmatch_offset += (verbatim_bits << 3);\n\t\tREAD_HUFFSYM(ALIGNED, aligned_bits);\n\t\tmatch_offset += aligned_bits;\n\t      }\n\t      else if (extra == 3) {\n\t\t/* aligned bits only */\n\t\tREAD_HUFFSYM(ALIGNED, aligned_bits);\n\t\tmatch_offset += aligned_bits;\n\t      }\n\t      else if (extra > 0) { /* extra==1, extra==2 */\n\t\t/* verbatim bits only */\n\t\tREAD_BITS(verbatim_bits, extra);\n\t\tmatch_offset += verbatim_bits;\n\t      }\n\t      else /* extra == 0 */ {\n\t\t/* ??? not defined in LZX specification! */\n\t\tmatch_offset = 1;\n\t      }\n\t      /* update repeated offset LRU queue */\n\t      R2 = R1; R1 = R0; R0 = match_offset;\n\t    }\n\n\t    /* LZX DELTA uses max match length to signal even longer match */\n\t    if (match_length == LZX_MAX_MATCH && lzx->is_delta) {\n\t\tint extra_len = 0;\n\t\tENSURE_BITS(3); /* 4 entry huffman tree */\n\t\tif (PEEK_BITS(1) == 0) {\n\t\t    REMOVE_BITS(1); /* '0' -> 8 extra length bits */\n\t\t    READ_BITS(extra_len, 8);\n\t\t}\n\t\telse if (PEEK_BITS(2) == 2) {\n\t\t    REMOVE_BITS(2); /* '10' -> 10 extra length bits + 0x100 */\n\t\t    READ_BITS(extra_len, 10);\n\t\t    extra_len += 0x100;\n\t\t}\n\t\telse if (PEEK_BITS(3) == 6) {\n\t\t    REMOVE_BITS(3); /* '110' -> 12 extra length bits + 0x500 */\n\t\t    READ_BITS(extra_len, 12);\n\t\t    extra_len += 0x500;\n\t\t}\n\t\telse {\n\t\t    REMOVE_BITS(3); /* '111' -> 15 extra length bits */\n\t\t    READ_BITS(extra_len, 15);\n\t\t}\n\t\tmatch_length += extra_len;\n\t    }\n\n\t    if ((window_posn + match_length) > lzx->window_size) {\n\t      D((\"match ran over window wrap\"))\n\t      return lzx->error = MSPACK_ERR_DECRUNCH;\n\t    }\n\n\t    /* copy match */\n\t    rundest = &window[window_posn];\n\t    i = match_length;\n\t    /* does match offset wrap the window? */\n\t    if (match_offset > window_posn) {\n\t      if (match_offset > lzx->offset &&\n\t\t  (match_offset - window_posn) > lzx->ref_data_size)\n\t      {\n\t\tD((\"match offset beyond LZX stream\"))\n\t\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n\t      }\n\t      /* j = length from match offset to end of window */\n\t      j = match_offset - window_posn;\n\t      if (j > (int) lzx->window_size) {\n\t\tD((\"match offset beyond window boundaries\"))\n\t\treturn lzx->error = MSPACK_ERR_DECRUNCH;\n\t      }\n\t      runsrc = &window[lzx->window_size - j];\n\t      if (j < i) {\n\t\t/* if match goes over the window edge, do two copy runs */\n\t\ti -= j; while (j-- > 0) *rundest++ = *runsrc++;\n\t\trunsrc = window;\n\t      }\n\t      while (i-- > 0) *rundest++ = *runsrc++;\n\t    }\n\t    else {\n\t      runsrc = rundest - match_offset;\n\t      while (i-- > 0) *rundest++ = *runsrc++;\n\t    }\n\n\t    this_run    -= match_length;\n\t    window_posn += match_length;\n\t  }\n\t} /* while (this_run > 0) */\n\tbreak;\n\n      case LZX_BLOCKTYPE_UNCOMPRESSED:\n\t/* as this_run is limited not to wrap a frame, this also means it\n\t * won't wrap the window (as the window is a multiple of 32k) */\n\trundest = &window[window_posn];\n\twindow_posn += this_run;\n\twhile (this_run > 0) {\n\t  if ((i = i_end - i_ptr) == 0) {\n\t    READ_IF_NEEDED;\n\t  }\n\t  else {\n\t    if (i > this_run) i = this_run;\n\t    lzx->sys->copy(i_ptr, rundest, (size_t) i);\n\t    rundest  += i;\n\t    i_ptr    += i;\n\t    this_run -= i;\n\t  }\n\t}\n\tbreak;\n\n      default:\n\treturn lzx->error = MSPACK_ERR_DECRUNCH; /* might as well */\n      }\n\n      /* did the final match overrun our desired this_run length? */\n      if (this_run < 0) {\n\tif ((unsigned int)(-this_run) > lzx->block_remaining) {\n\t  D((\"overrun went past end of block by %d (%d remaining)\",\n\t     -this_run, lzx->block_remaining ))\n\t  return lzx->error = MSPACK_ERR_DECRUNCH;\n\t}\n\tlzx->block_remaining -= -this_run;\n      }\n    } /* while (bytes_todo > 0) */\n\n    /* streams don't extend over frame boundaries */\n    if ((window_posn - lzx->frame_posn) != frame_size) {\n      D((\"decode beyond output frame limits! %d != %d\",\n\t window_posn - lzx->frame_posn, frame_size))\n      return lzx->error = MSPACK_ERR_DECRUNCH;\n    }\n\n    /* re-align input bitstream */\n    if (bits_left > 0) ENSURE_BITS(16);\n    if (bits_left & 15) REMOVE_BITS(bits_left & 15);\n\n    /* check that we've used all of the previous frame first */\n    if (lzx->o_ptr != lzx->o_end) {\n      D((\"%ld avail bytes, new %d frame\",\n          (long)(lzx->o_end - lzx->o_ptr), frame_size))\n      return lzx->error = MSPACK_ERR_DECRUNCH;\n    }\n\n    /* does this intel block _really_ need decoding? */\n    if (lzx->intel_started && lzx->intel_filesize &&\n\t(lzx->frame <= 32768) && (frame_size > 10))\n    {\n      unsigned char *data    = &lzx->e8_buf[0];\n      unsigned char *dataend = &lzx->e8_buf[frame_size - 10];\n      signed int curpos      = lzx->intel_curpos;\n      signed int filesize    = lzx->intel_filesize;\n      signed int abs_off, rel_off;\n\n      /* copy e8 block to the e8 buffer and tweak if needed */\n      lzx->o_ptr = data;\n      lzx->sys->copy(&lzx->window[lzx->frame_posn], data, frame_size);\n\n      while (data < dataend) {\n\tif (*data++ != 0xE8) { curpos++; continue; }\n\tabs_off = data[0] | (data[1]<<8) | (data[2]<<16) | (data[3]<<24);\n\tif ((abs_off >= -curpos) && (abs_off < filesize)) {\n\t  rel_off = (abs_off >= 0) ? abs_off - curpos : abs_off + filesize;\n\t  data[0] = (unsigned char) rel_off;\n\t  data[1] = (unsigned char) (rel_off >> 8);\n\t  data[2] = (unsigned char) (rel_off >> 16);\n\t  data[3] = (unsigned char) (rel_off >> 24);\n\t}\n\tdata += 4;\n\tcurpos += 5;\n      }\n      lzx->intel_curpos += frame_size;\n    }\n    else {\n      lzx->o_ptr = &lzx->window[lzx->frame_posn];\n      if (lzx->intel_filesize) lzx->intel_curpos += frame_size;\n    }\n    lzx->o_end = &lzx->o_ptr[frame_size];\n\n    /* write a frame */\n    i = (out_bytes < (off_t)frame_size) ? (unsigned int)out_bytes : frame_size;\n    if (lzx->sys->write(lzx->output, lzx->o_ptr, i) != i) {\n      return lzx->error = MSPACK_ERR_WRITE;\n    }\n    lzx->o_ptr  += i;\n    lzx->offset += i;\n    out_bytes   -= i;\n\n    /* advance frame start position */\n    lzx->frame_posn += frame_size;\n    lzx->frame++;\n\n    /* wrap window / frame position pointers */\n    if (window_posn == lzx->window_size)     window_posn = 0;\n    if (lzx->frame_posn == lzx->window_size) lzx->frame_posn = 0;\n\n  } /* while (lzx->frame < end_frame) */\n\n  if (out_bytes) {\n    D((\"bytes left to output\"))\n    return lzx->error = MSPACK_ERR_DECRUNCH;\n  }\n\n  /* store local state */\n  STORE_BITS;\n  lzx->window_posn = window_posn;\n  lzx->R0 = R0;\n  lzx->R1 = R1;\n  lzx->R2 = R2;\n\n  return MSPACK_ERR_OK;\n}\n", "target": 1, "idx": 179784}
{"func": "void BackFramebuffer::Create() {\n  ScopedGLErrorSuppressor suppressor(\"BackFramebuffer::Create\",\n                                     decoder_->error_state_.get());\n  Destroy();\n  api()->glGenFramebuffersEXTFn(1, &id_);\n}\n", "target": 0, "idx": 153918}
{"func": "void FrameLoaderClient::dispatchDidReceiveAuthenticationChallenge(WebCore::DocumentLoader*, unsigned long  identifier, const AuthenticationChallenge&)\n{\n    notImplemented();\n}\n", "target": 0, "idx": 98313}
{"func": "   Core(const OAuthProviderInfo& info,\n        net::URLRequestContextGetter* request_context_getter)\n       : provider_info_(info),\n         request_context_getter_(request_context_getter),\n        delegate_(NULL) {\n   }\n", "target": 1, "idx": 184379}
{"func": "bool RenderFrameHostImpl::IsFeatureEnabled(\n    blink::mojom::FeaturePolicyFeature feature) {\n  return feature_policy_ && feature_policy_->IsFeatureEnabledForOrigin(\n                                feature, GetLastCommittedOrigin());\n}\n", "target": 0, "idx": 166135}
{"func": "static int get_cox(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *c)\n{\n    uint8_t byte;\n\n    if (bytestream2_get_bytes_left(&s->g) < 5)\n        return AVERROR_INVALIDDATA;\n\n    /*  nreslevels = number of resolution levels\n                   = number of decomposition level +1 */\n    c->nreslevels = bytestream2_get_byteu(&s->g) + 1;\n    if (c->nreslevels >= JPEG2000_MAX_RESLEVELS) {\n        av_log(s->avctx, AV_LOG_ERROR, \"nreslevels %d is invalid\\n\", c->nreslevels);\n         return AVERROR_INVALIDDATA;\n     }\n \n     /* compute number of resolution levels to decode */\n    if (c->nreslevels < s->reduction_factor)\n        c->nreslevels2decode = 1;\n    else\n        c->nreslevels2decode = c->nreslevels - s->reduction_factor;\n \n     c->log2_cblk_width  = (bytestream2_get_byteu(&s->g) & 15) + 2; // cblk width\n     c->log2_cblk_height = (bytestream2_get_byteu(&s->g) & 15) + 2; // cblk height\n\n    if (c->log2_cblk_width > 10 || c->log2_cblk_height > 10 ||\n        c->log2_cblk_width + c->log2_cblk_height > 12) {\n        av_log(s->avctx, AV_LOG_ERROR, \"cblk size invalid\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (c->log2_cblk_width > 6 || c->log2_cblk_height > 6) {\n        avpriv_request_sample(s->avctx, \"cblk size > 64\");\n        return AVERROR_PATCHWELCOME;\n    }\n\n    c->cblk_style = bytestream2_get_byteu(&s->g);\n    if (c->cblk_style != 0) { // cblk style\n        av_log(s->avctx, AV_LOG_WARNING, \"extra cblk styles %X\\n\", c->cblk_style);\n    }\n    c->transform = bytestream2_get_byteu(&s->g); // DWT transformation type\n    /* set integer 9/7 DWT in case of BITEXACT flag */\n    if ((s->avctx->flags & CODEC_FLAG_BITEXACT) && (c->transform == FF_DWT97))\n        c->transform = FF_DWT97_INT;\n\n    if (c->csty & JPEG2000_CSTY_PREC) {\n        int i;\n        for (i = 0; i < c->nreslevels; i++) {\n            byte = bytestream2_get_byte(&s->g);\n            c->log2_prec_widths[i]  =  byte       & 0x0F;    // precinct PPx\n            c->log2_prec_heights[i] = (byte >> 4) & 0x0F;    // precinct PPy\n        }\n    } else {\n        memset(c->log2_prec_widths , 15, sizeof(c->log2_prec_widths ));\n        memset(c->log2_prec_heights, 15, sizeof(c->log2_prec_heights));\n    }\n    return 0;\n}\n", "target": 1, "idx": 179090}
{"func": "IDNSpoofChecker::IDNSpoofChecker() {\n  UErrorCode status = U_ZERO_ERROR;\n  checker_ = uspoof_open(&status);\n  if (U_FAILURE(status)) {\n    checker_ = nullptr;\n    return;\n  }\n\n\n  uspoof_setRestrictionLevel(checker_, USPOOF_HIGHLY_RESTRICTIVE);\n\n  SetAllowedUnicodeSet(&status);\n\n  int32_t checks = uspoof_getChecks(checker_, &status) | USPOOF_AUX_INFO;\n  uspoof_setChecks(checker_, checks, &status);\n\n  deviation_characters_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u00df\\\\u03c2\\\\u200c\\\\u200d]\"), status);\n  deviation_characters_.freeze();\n\n  non_ascii_latin_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Latin:] - [a-zA-Z]]\"), status);\n  non_ascii_latin_letters_.freeze();\n\n  kana_letters_exceptions_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u3078-\\\\u307a\\\\u30d8-\\\\u30da\\\\u30fb-\\\\u30fe]\"),\n      status);\n  kana_letters_exceptions_.freeze();\n  combining_diacritics_exceptions_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[\\\\u0300-\\\\u0339]\"), status);\n  combining_diacritics_exceptions_.freeze();\n\n  cyrillic_letters_latin_alike_ = icu::UnicodeSet(\n      icu::UnicodeString::fromUTF8(\"[\u0430\u0441\u0501\u0435\u04bb\u0456\u0458\u04cf\u043e\u0440\u051b\u0455\u051d\u0445\u0443\u044a\u042c\u04bd\u043f\u0433\u0475\u0461]\"), status);\n  cyrillic_letters_latin_alike_.freeze();\n\n  cyrillic_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Cyrl:]]\"), status);\n  cyrillic_letters_.freeze();\n\n  DCHECK(U_SUCCESS(status));\n  lgc_letters_n_ascii_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[[:Latin:][:Greek:][:Cyrillic:][0-9\\\\u002e_\"\n                            \"\\\\u002d][\\\\u0300-\\\\u0339]]\"),\n      status);\n  lgc_letters_n_ascii_.freeze();\n\n  UParseError parse_error;\n  diacritic_remover_.reset(icu::Transliterator::createFromRules(\n      UNICODE_STRING_SIMPLE(\"DropAcc\"),\n      icu::UnicodeString::fromUTF8(\"::NFD; ::[:Nonspacing Mark:] Remove; ::NFC;\"\n                                   \" \u0142 > l; \u00f8 > o; \u0111 > d;\"),\n      UTRANS_FORWARD, parse_error, status));\n\n   extra_confusable_mapper_.reset(icu::Transliterator::createFromRules(\n       UNICODE_STRING_SIMPLE(\"ExtraConf\"),\n       icu::UnicodeString::fromUTF8(\n           \"[\u00e6\u04d5] > ae; [\u00fe\u03fc\u048f] > p; [\u0127\u043d\u045b\u04a3\u04a5\u04c8\u04ca\u050b\u0527\u0529] > h;\"\n           \"[\u0138\u03ba\u043a\u049b\u049d\u049f\u04a1\u04c4\u051f] > k; [\u014b\u043f\u0525] > n; \u0153 > ce;\"\n          \"[\u0167\u0442\u04ad\u050f] > t; [\u0185\u044c\u048d\u0432] > b;  [\u03c9\u0448\u0449\u0e1f] > w;\"\n           \"[\u043c\u04ce] > m; [\u0454\u04bd\u04bf\u1054] > e; \u0491 > r; [\u0493\u04fb] > f;\"\n           \"[\u04ab\u1004] > c; \u04b1 > y; [\u03c7\u04b3\u04fd\u04ff] > x;\"\n          \"\u0503  > d; [\u050d\u100c] > g; [\u0d1f\u0e23] > s; \u1042 > j;\"\n          \"[\u0437\u0499\u04e1] > 3\"),\n       UTRANS_FORWARD, parse_error, status));\n   DCHECK(U_SUCCESS(status))\n       << \"Spoofchecker initalization failed due to an error: \"\n      << u_errorName(status);\n}\n", "target": 1, "idx": 187142}
{"func": "void VirtualKeyboardController::OnMaximizeModeStarted() {\n  if (!IsSmartVirtualKeyboardEnabled()) {\n    SetKeyboardEnabled(true);\n  } else {\n    UpdateKeyboardEnabled();\n  }\n}\n", "target": 0, "idx": 132368}
{"func": "static MagickBooleanType EncodeImage(const ImageInfo *image_info,Image *image,\n  const size_t data_size,ExceptionInfo *exception)\n{\n#define MaxCode(number_bits)  ((one << (number_bits))-1)\n#define MaxHashTable  5003\n#define MaxGIFBits  12UL\n#define MaxGIFTable  (1UL << MaxGIFBits)\n#define GIFOutputCode(code) \\\n{ \\\n  /*  \\\n    Emit a code. \\\n  */ \\\n  if (bits > 0) \\\n    datum|=(size_t) (code) << bits; \\\n  else \\\n    datum=(size_t) (code); \\\n  bits+=number_bits; \\\n  while (bits >= 8) \\\n  { \\\n    /*  \\\n      Add a character to current packet. \\\n    */ \\\n    packet[length++]=(unsigned char) (datum & 0xff); \\\n    if (length >= 254) \\\n      { \\\n        (void) WriteBlobByte(image,(unsigned char) length); \\\n        (void) WriteBlob(image,length,packet); \\\n        length=0; \\\n      } \\\n    datum>>=8; \\\n    bits-=8; \\\n  } \\\n  if (free_code > max_code)  \\\n    { \\\n      number_bits++; \\\n      if (number_bits == MaxGIFBits) \\\n        max_code=MaxGIFTable; \\\n      else \\\n        max_code=MaxCode(number_bits); \\\n    } \\\n}\n\n  Quantum\n    index;\n\n  short\n    *hash_code,\n    *hash_prefix,\n    waiting_code;\n\n  size_t\n    bits,\n    clear_code,\n    datum,\n    end_of_information_code,\n    free_code,\n    length,\n    max_code,\n    next_pixel,\n    number_bits,\n    one,\n    pass;\n\n  ssize_t\n    displacement,\n    offset,\n    k,\n    y;\n\n  unsigned char\n    *packet,\n    *hash_suffix;\n\n  /*\n    Allocate encoder tables.\n  */\n  assert(image != (Image *) NULL);\n  one=1;\n  packet=(unsigned char *) AcquireQuantumMemory(256,sizeof(*packet));\n  hash_code=(short *) AcquireQuantumMemory(MaxHashTable,sizeof(*hash_code));\n  hash_prefix=(short *) AcquireQuantumMemory(MaxHashTable,sizeof(*hash_prefix));\n  hash_suffix=(unsigned char *) AcquireQuantumMemory(MaxHashTable,\n    sizeof(*hash_suffix));\n  if ((packet == (unsigned char *) NULL) || (hash_code == (short *) NULL) ||\n      (hash_prefix == (short *) NULL) ||\n      (hash_suffix == (unsigned char *) NULL))\n    {\n      if (packet != (unsigned char *) NULL)\n        packet=(unsigned char *) RelinquishMagickMemory(packet);\n      if (hash_code != (short *) NULL)\n        hash_code=(short *) RelinquishMagickMemory(hash_code);\n      if (hash_prefix != (short *) NULL)\n        hash_prefix=(short *) RelinquishMagickMemory(hash_prefix);\n      if (hash_suffix != (unsigned char *) NULL)\n        hash_suffix=(unsigned char *) RelinquishMagickMemory(hash_suffix);\n      return(MagickFalse);\n    }\n  /*\n    Initialize GIF encoder.\n  */\n  (void) memset(packet,0,256*sizeof(*packet));\n  (void) memset(hash_code,0,MaxHashTable*sizeof(*hash_code));\n  (void) memset(hash_prefix,0,MaxHashTable*sizeof(*hash_prefix));\n  (void) memset(hash_suffix,0,MaxHashTable*sizeof(*hash_suffix));\n  number_bits=data_size;\n  max_code=MaxCode(number_bits);\n  clear_code=((short) one << (data_size-1));\n  end_of_information_code=clear_code+1;\n  free_code=clear_code+2;\n  length=0;\n  datum=0;\n  bits=0;\n  GIFOutputCode(clear_code);\n  /*\n    Encode pixels.\n  */\n  offset=0;\n  pass=0;\n  waiting_code=0;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const Quantum\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    p=GetVirtualPixels(image,0,offset,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    if (y == 0)\n      {\n        waiting_code=(short) GetPixelIndex(image,p);\n        p+=GetPixelChannels(image);\n      }\n    for (x=(ssize_t) (y == 0 ? 1 : 0); x < (ssize_t) image->columns; x++)\n    {\n       /*\n         Probe hash table.\n       */\n       index=(Quantum) ((size_t) GetPixelIndex(image,p) & 0xff);\n       p+=GetPixelChannels(image);\n       k=(ssize_t) (((size_t) index << (MaxGIFBits-8))+waiting_code);\n       if (k >= MaxHashTable)\n         k-=MaxHashTable;\n      next_pixel=MagickFalse;\n      displacement=1;\n       if (hash_code[k] > 0)\n         {\n           if ((hash_prefix[k] == waiting_code) &&\n              (hash_suffix[k] == (unsigned char) index))\n            {\n              waiting_code=hash_code[k];\n              continue;\n            }\n          if (k != 0)\n            displacement=MaxHashTable-k;\n          for ( ; ; )\n          {\n            k-=displacement;\n            if (k < 0)\n              k+=MaxHashTable;\n            if (hash_code[k] == 0)\n              break;\n            if ((hash_prefix[k] == waiting_code) &&\n                (hash_suffix[k] == (unsigned char) index))\n              {\n                waiting_code=hash_code[k];\n                next_pixel=MagickTrue;\n                break;\n              }\n          }\n          if (next_pixel != MagickFalse)\n            continue;\n        }\n      GIFOutputCode(waiting_code);\n      if (free_code < MaxGIFTable)\n        {\n          hash_code[k]=(short) free_code++;\n          hash_prefix[k]=waiting_code;\n          hash_suffix[k]=(unsigned char) index;\n        }\n      else\n        {\n          /*\n            Fill the hash table with empty entries.\n          */\n          for (k=0; k < MaxHashTable; k++)\n            hash_code[k]=0;\n          /*\n            Reset compressor and issue a clear code.\n          */\n          free_code=clear_code+2;\n          GIFOutputCode(clear_code);\n          number_bits=data_size;\n          max_code=MaxCode(number_bits);\n        }\n      waiting_code=(short) index;\n    }\n    if (image_info->interlace == NoInterlace)\n      offset++;\n    else\n      switch (pass)\n      {\n        case 0:\n        default:\n        {\n          offset+=8;\n          if (offset >= (ssize_t) image->rows)\n            {\n              pass++;\n              offset=4;\n            }\n          break;\n        }\n        case 1:\n        {\n          offset+=8;\n          if (offset >= (ssize_t) image->rows)\n            {\n              pass++;\n              offset=2;\n            }\n          break;\n        }\n        case 2:\n        {\n          offset+=4;\n          if (offset >= (ssize_t) image->rows)\n            {\n              pass++;\n              offset=1;\n            }\n          break;\n        }\n        case 3:\n        {\n          offset+=2;\n          break;\n        }\n      }\n  }\n  /*\n    Flush out the buffered code.\n  */\n  GIFOutputCode(waiting_code);\n  GIFOutputCode(end_of_information_code);\n  if (bits > 0)\n    {\n      /*\n        Add a character to current packet.\n      */\n      packet[length++]=(unsigned char) (datum & 0xff);\n      if (length >= 254)\n        {\n          (void) WriteBlobByte(image,(unsigned char) length);\n          (void) WriteBlob(image,length,packet);\n          length=0;\n        }\n    }\n  /*\n    Flush accumulated data.\n  */\n  if (length > 0)\n    {\n      (void) WriteBlobByte(image,(unsigned char) length);\n      (void) WriteBlob(image,length,packet);\n    }\n  /*\n    Free encoder memory.\n  */\n  hash_suffix=(unsigned char *) RelinquishMagickMemory(hash_suffix);\n  hash_prefix=(short *) RelinquishMagickMemory(hash_prefix);\n  hash_code=(short *) RelinquishMagickMemory(hash_code);\n  packet=(unsigned char *) RelinquishMagickMemory(packet);\n  return(MagickTrue);\n}\n", "target": 1, "idx": 183372}
{"func": "void PrepareFrameAndViewForPrint::StartPrinting(\n    const gfx::Size& print_canvas_size) {\n  print_canvas_size_ = print_canvas_size;\n\n  gfx::Size print_layout_size(print_canvas_size_);\n  print_layout_size.set_height(static_cast<int>(\n      static_cast<double>(print_layout_size.height()) * 1.25));\n\n  web_view_->resize(print_layout_size);\n\n  expected_pages_count_ = frame_->printBegin(print_canvas_size_, node_to_print_,\n                                             dpi_, &use_browser_overlays_);\n}\n", "target": 0, "idx": 101537}
{"func": "static int setcos_card_ctl(sc_card_t *card, unsigned long cmd, void *ptr)\n{\n\tif (card->type != SC_CARD_TYPE_SETCOS_44 && !SETCOS_IS_EID_APPLET(card))\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\n\tswitch(cmd) {\n\tcase SC_CARDCTL_SETCOS_PUTDATA:\n\t\treturn setcos_putdata(card,\n\t\t\t\t(struct sc_cardctl_setcos_data_obj*) ptr);\n\t\tbreak;\n\tcase SC_CARDCTL_SETCOS_GETDATA:\n\t\treturn setcos_getdata(card,\n\t\t\t\t(struct sc_cardctl_setcos_data_obj*) ptr);\n\t\tbreak;\n\tcase SC_CARDCTL_SETCOS_GENERATE_STORE_KEY:\n\t\treturn setcos_generate_store_key(card,\n\t\t\t\t(struct sc_cardctl_setcos_gen_store_key_info *) ptr);\n\tcase SC_CARDCTL_SETCOS_ACTIVATE_FILE:\n\t\treturn setcos_activate_file(card);\n\t}\n\n\treturn SC_ERROR_NOT_SUPPORTED;\n}\n", "target": 0, "idx": 78692}
{"func": "void UiSceneCreator::CreateUnderDevelopmentNotice() {\n  auto text = base::MakeUnique<Text>(kUnderDevelopmentNoticeFontHeightDMM);\n  BindColor(model_, text.get(), &ColorScheme::world_background_text,\n            &Text::SetColor);\n  text->SetText(l10n_util::GetStringUTF16(IDS_VR_UNDER_DEVELOPMENT_NOTICE));\n  text->SetName(kUnderDevelopmentNotice);\n  text->SetDrawPhase(kPhaseForeground);\n  text->set_hit_testable(false);\n  text->SetSize(kUnderDevelopmentNoticeWidthDMM,\n                kUnderDevelopmentNoticeHeightDMM);\n  text->SetTranslate(0, -kUnderDevelopmentNoticeVerticalOffsetDMM, 0);\n  text->SetRotate(1, 0, 0, kUnderDevelopmentNoticeRotationRad);\n  text->set_y_anchoring(BOTTOM);\n  scene_->AddUiElement(kUrlBar, std::move(text));\n}\n", "target": 0, "idx": 168689}
{"func": "COMPS_HSList* comps_objmrtree_pairs(COMPS_ObjMRTree * rt) {\n    return __comps_objmrtree_all(rt, 2);\n}\n", "target": 0, "idx": 91775}
{"func": "ChromeRenderProcessObserver::ChromeRenderProcessObserver(\n    chrome::ChromeContentRendererClient* client)\n    : client_(client),\n      clear_cache_pending_(false) {\n  const CommandLine& command_line = *CommandLine::ForCurrentProcess();\n  if (command_line.HasSwitch(switches::kEnableWatchdog)) {\n  }\n\n  if (command_line.HasSwitch(switches::kDumpHistogramsOnExit)) {\n    base::StatisticsRecorder::set_dump_on_exit(true);\n  }\n\n  RenderThread* thread = RenderThread::Get();\n  resource_delegate_.reset(new RendererResourceDelegate());\n  thread->SetResourceDispatcherDelegate(resource_delegate_.get());\n\n  net::NetModule::SetResourceProvider(chrome_common_net::NetResourceProvider);\n\n#if defined(OS_WIN)\n  FilePath pdf;\n  if (PathService::Get(chrome::FILE_PDF_PLUGIN, &pdf) &&\n      file_util::PathExists(pdf)) {\n    g_iat_patch_createdca.Patch(\n        pdf.value().c_str(), \"gdi32.dll\", \"CreateDCA\", CreateDCAPatch);\n    g_iat_patch_get_font_data.Patch(\n        pdf.value().c_str(), \"gdi32.dll\", \"GetFontData\", GetFontDataPatch);\n  }\n#endif\n\n#if defined(OS_POSIX) && !defined(OS_MACOSX) && defined(USE_NSS)\n  if (!command_line.HasSwitch(switches::kSingleProcess)) {\n    crypto::DisableNSSForkCheck();\n    crypto::ForceNSSNoDBInit();\n    crypto::EnsureNSSInit();\n  }\n#elif defined(OS_WIN)\n  std::string error;\n  base::LoadNativeLibrary(FilePath(L\"crypt32.dll\"), &error);\n#endif\n  chrome_variations::SetChildProcessLoggingVariationList();\n}\n", "target": 0, "idx": 108446}
{"func": "static void utee_param_to_param(struct tee_ta_param *p, struct utee_params *up)\n {\n \tsize_t n;\n \tuint32_t types = up->types;\n\n\tp->types = types;\n \tfor (n = 0; n < TEE_NUM_PARAMS; n++) {\n \t\tuintptr_t a = up->vals[n * 2];\n \t\tsize_t b = up->vals[n * 2 + 1];\n \n \t\tswitch (TEE_PARAM_TYPE_GET(types, n)) {\n\t\tcase TEE_PARAM_TYPE_MEMREF_INPUT:\n \t\tcase TEE_PARAM_TYPE_MEMREF_OUTPUT:\n \t\tcase TEE_PARAM_TYPE_MEMREF_INOUT:\n \t\t\tp->u[n].mem.mobj = &mobj_virt;\n \t\t\tp->u[n].mem.offs = a;\n \t\t\tp->u[n].mem.size = b;\n \t\t\tbreak;\n \t\tcase TEE_PARAM_TYPE_VALUE_INPUT:\n \t\tcase TEE_PARAM_TYPE_VALUE_INOUT:\n\t\t\tp->u[n].val.a = a;\n\t\t\tp->u[n].val.b = b;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmemset(&p->u[n], 0, sizeof(p->u[n]));\n \t\t\tbreak;\n \t\t}\n \t}\n }\n", "target": 1, "idx": 182643}
{"func": "static int __init setup_slub_min_objects(char *str)\n{\n\tget_option(&str, &slub_min_objects);\n\n\treturn 1;\n}\n", "target": 0, "idx": 24891}
{"func": " selReadStream(FILE  *fp)\n {\n char    *selname;\nchar     linebuf[L_BUF_SIZE];\n l_int32  sy, sx, cy, cx, i, j, version, ignore;\n SEL     *sel;\n \n    PROCNAME(\"selReadStream\");\n\n    if (!fp)\n        return (SEL *)ERROR_PTR(\"stream not defined\", procName, NULL);\n\n    if (fscanf(fp, \"  Sel Version %d\\n\", &version) != 1)\n        return (SEL *)ERROR_PTR(\"not a sel file\", procName, NULL);\n     if (version != SEL_VERSION_NUMBER)\n         return (SEL *)ERROR_PTR(\"invalid sel version\", procName, NULL);\n \n    if (fgets(linebuf, L_BUF_SIZE, fp) == NULL)\n         return (SEL *)ERROR_PTR(\"error reading into linebuf\", procName, NULL);\n     selname = stringNew(linebuf);\n    sscanf(linebuf, \"  ------  %s  ------\", selname);\n \n     if (fscanf(fp, \"  sy = %d, sx = %d, cy = %d, cx = %d\\n\",\n             &sy, &sx, &cy, &cx) != 4) {\n        LEPT_FREE(selname);\n        return (SEL *)ERROR_PTR(\"dimensions not read\", procName, NULL);\n    }\n\n    if ((sel = selCreate(sy, sx, selname)) == NULL) {\n        LEPT_FREE(selname);\n        return (SEL *)ERROR_PTR(\"sel not made\", procName, NULL);\n    }\n    selSetOrigin(sel, cy, cx);\n\n    for (i = 0; i < sy; i++) {\n        ignore = fscanf(fp, \"    \");\n        for (j = 0; j < sx; j++)\n            ignore = fscanf(fp, \"%1d\", &sel->data[i][j]);\n        ignore = fscanf(fp, \"\\n\");\n    }\n    ignore = fscanf(fp, \"\\n\");\n\n    LEPT_FREE(selname);\n    return sel;\n}\n", "target": 1, "idx": 182501}
{"func": "void GLES2DecoderImpl::TexStorageImpl(GLenum target,\n                                      GLsizei levels,\n                                      GLenum internal_format,\n                                      GLsizei width,\n                                      GLsizei height,\n                                      GLsizei depth,\n                                      ContextState::Dimension dimension,\n                                      const char* function_name) {\n  if (levels == 0) {\n    LOCAL_SET_GL_ERROR(GL_INVALID_VALUE, function_name, \"levels == 0\");\n    return;\n  }\n  bool is_compressed_format = IsCompressedTextureFormat(internal_format);\n  if (is_compressed_format && target == GL_TEXTURE_3D) {\n    LOCAL_SET_GL_ERROR(\n        GL_INVALID_OPERATION, function_name, \"target invalid for format\");\n    return;\n  }\n  bool is_invalid_texstorage_size = width < 1 || height < 1 || depth < 1;\n  if (!texture_manager()->ValidForTarget(target, 0, width, height, depth) ||\n      is_invalid_texstorage_size ||\n      TextureManager::ComputeMipMapCount(target, width, height, depth) <\n          levels) {\n    LOCAL_SET_GL_ERROR(\n        GL_INVALID_VALUE, function_name, \"dimensions out of range\");\n    return;\n  }\n  TextureRef* texture_ref = texture_manager()->GetTextureInfoForTarget(\n      &state_, target);\n  if (!texture_ref) {\n    LOCAL_SET_GL_ERROR(\n        GL_INVALID_OPERATION, function_name, \"unknown texture for target\");\n    return;\n  }\n  Texture* texture = texture_ref->texture();\n  if (texture->IsAttachedToFramebuffer()) {\n    framebuffer_state_.clear_state_dirty = true;\n  }\n  if (texture->IsImmutable()) {\n    LOCAL_SET_GL_ERROR(\n        GL_INVALID_OPERATION, function_name, \"texture is immutable\");\n    return;\n  }\n\n  GLenum format = TextureManager::ExtractFormatFromStorageFormat(\n      internal_format);\n  GLenum type = TextureManager::ExtractTypeFromStorageFormat(internal_format);\n\n  {\n    GLsizei level_width = width;\n    GLsizei level_height = height;\n    GLsizei level_depth = depth;\n    base::CheckedNumeric<uint32_t> estimated_size(0);\n    PixelStoreParams params;\n    params.alignment = 1;\n    for (int ii = 0; ii < levels; ++ii) {\n      uint32_t size;\n      if (is_compressed_format) {\n        GLsizei level_size;\n        if (!GetCompressedTexSizeInBytes(\n                function_name, level_width, level_height, level_depth,\n                internal_format, &level_size, state_.GetErrorState())) {\n          return;\n        }\n        size = static_cast<uint32_t>(level_size);\n      } else {\n        if (!GLES2Util::ComputeImageDataSizesES3(level_width,\n                                                 level_height,\n                                                 level_depth,\n                                                 format, type,\n                                                 params,\n                                                 &size,\n                                                 nullptr, nullptr,\n                                                 nullptr, nullptr)) {\n          LOCAL_SET_GL_ERROR(\n              GL_OUT_OF_MEMORY, function_name, \"dimensions too large\");\n          return;\n        }\n      }\n      estimated_size += size;\n      level_width = std::max(1, level_width >> 1);\n      level_height = std::max(1, level_height >> 1);\n      if (target == GL_TEXTURE_3D)\n        level_depth = std::max(1, level_depth >> 1);\n    }\n    if (!estimated_size.IsValid()) {\n      LOCAL_SET_GL_ERROR(GL_OUT_OF_MEMORY, function_name, \"out of memory\");\n      return;\n    }\n  }\n\n  GLenum compatibility_internal_format =\n      texture_manager()->AdjustTexStorageFormat(feature_info_.get(),\n                                                internal_format);\n\n  const CompressedFormatInfo* format_info =\n      GetCompressedFormatInfo(internal_format);\n  if (format_info != nullptr && !format_info->support_check(*feature_info_)) {\n     compatibility_internal_format = format_info->decompressed_internal_format;\n   }\n \n  if (workarounds().reset_base_mipmap_level_before_texstorage &&\n      texture->base_level() > 0)\n    api()->glTexParameteriFn(target, GL_TEXTURE_BASE_LEVEL, 0);\n  if (dimension == ContextState::k2D) {\n    api()->glTexStorage2DEXTFn(target, levels, compatibility_internal_format,\n                               width, height);\n  } else {\n    api()->glTexStorage3DFn(target, levels, compatibility_internal_format,\n                            width, height, depth);\n  }\n  if (workarounds().reset_base_mipmap_level_before_texstorage &&\n      texture->base_level() > 0)\n    api()->glTexParameteriFn(target, GL_TEXTURE_BASE_LEVEL,\n                             texture->base_level());\n   {\n     GLsizei level_width = width;\n     GLsizei level_height = height;\n    GLsizei level_depth = depth;\n\n    GLenum adjusted_internal_format =\n        feature_info_->IsWebGL1OrES2Context() ? format : internal_format;\n    for (int ii = 0; ii < levels; ++ii) {\n      if (target == GL_TEXTURE_CUBE_MAP) {\n        for (int jj = 0; jj < 6; ++jj) {\n          GLenum face = GL_TEXTURE_CUBE_MAP_POSITIVE_X + jj;\n          texture_manager()->SetLevelInfo(\n              texture_ref, face, ii, adjusted_internal_format, level_width,\n              level_height, 1, 0, format, type, gfx::Rect());\n        }\n      } else {\n        texture_manager()->SetLevelInfo(\n            texture_ref, target, ii, adjusted_internal_format, level_width,\n            level_height, level_depth, 0, format, type, gfx::Rect());\n      }\n      level_width = std::max(1, level_width >> 1);\n      level_height = std::max(1, level_height >> 1);\n      if (target == GL_TEXTURE_3D)\n        level_depth = std::max(1, level_depth >> 1);\n    }\n     texture->ApplyFormatWorkarounds(feature_info_.get());\n     texture->SetImmutable(true);\n   }\n }\n", "target": 1, "idx": 186636}
{"func": "void virtio_config_writew(VirtIODevice *vdev, uint32_t addr, uint32_t data)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint16_t val = data;\n\n    if (addr + sizeof(val) > vdev->config_len) {\n        return;\n    }\n\n    stw_p(vdev->config + addr, val);\n\n    if (k->set_config) {\n        k->set_config(vdev, vdev->config);\n    }\n}\n", "target": 0, "idx": 9192}
{"func": "void EVP_EncodeUpdate(EVP_ENCODE_CTX *ctx, unsigned char *out, int *outl,\n                      const unsigned char *in, int inl)\n{\n    int i, j;\n    unsigned int total = 0;\n\n    *outl = 0;\n     if (inl <= 0)\n         return;\n     OPENSSL_assert(ctx->length <= (int)sizeof(ctx->enc_data));\n    if ((ctx->num + inl) < ctx->length) {\n         memcpy(&(ctx->enc_data[ctx->num]), in, inl);\n         ctx->num += inl;\n         return;\n    }\n    if (ctx->num != 0) {\n        i = ctx->length - ctx->num;\n        memcpy(&(ctx->enc_data[ctx->num]), in, i);\n        in += i;\n        inl -= i;\n        j = EVP_EncodeBlock(out, ctx->enc_data, ctx->length);\n        ctx->num = 0;\n        out += j;\n        *(out++) = '\\n';\n        *out = '\\0';\n        total = j + 1;\n    }\n    while (inl >= ctx->length) {\n        j = EVP_EncodeBlock(out, in, ctx->length);\n        in += ctx->length;\n        inl -= ctx->length;\n        out += j;\n        *(out++) = '\\n';\n        *out = '\\0';\n        total += j + 1;\n    }\n    if (inl != 0)\n        memcpy(&(ctx->enc_data[0]), in, inl);\n    ctx->num = inl;\n    *outl = total;\n}\n", "target": 1, "idx": 178389}
{"func": " AudioOutputAuthorizationHandler::AudioOutputAuthorizationHandler(\n    media::AudioManager* audio_manager,\n     MediaStreamManager* media_stream_manager,\n     int render_process_id,\n     const std::string& salt)\n    : audio_manager_(audio_manager),\n       media_stream_manager_(media_stream_manager),\n       permission_checker_(base::MakeUnique<MediaDevicesPermissionChecker>()),\n       render_process_id_(render_process_id),\n      salt_(salt),\n      weak_factory_(this) {\n  DCHECK(media_stream_manager_);\n}\n", "target": 1, "idx": 185858}
{"func": "void PermissionsData::SetActivePermissions(\n    std::unique_ptr<const PermissionSet> active) const {\n  AutoLockOnValidThread lock(runtime_lock_, thread_checker_.get());\n  active_permissions_unsafe_ = std::move(active);\n}\n", "target": 0, "idx": 164423}
{"func": "    void testResizeYieldsCorrectScrollAndScale(const char* url,\n                                               const float initialPageScaleFactor,\n                                               const WebSize scrollOffset,\n                                               const WebSize viewportSize,\n                                               const bool shouldScaleRelativeToViewportWidth) {\n        registerMockedHttpURLLoad(url);\n\n        const float aspectRatio = static_cast<float>(viewportSize.width) / viewportSize.height;\n\n        m_webView = FrameTestHelpers::createWebViewAndLoad(m_baseURL + url, true);\n        m_webView->settings()->setViewportEnabled(true);\n        m_webView->enableFixedLayoutMode(true);\n\n        {\n            webViewImpl()->resize(WebSize(viewportSize.width, viewportSize.height));\n            webViewImpl()->setPageScaleFactor(initialPageScaleFactor, WebPoint());\n            ASSERT_EQ(viewportSize, webViewImpl()->size());\n            ASSERT_EQ(initialPageScaleFactor, webViewImpl()->pageScaleFactor());\n            webViewImpl()->resize(WebSize(viewportSize.height, viewportSize.width));\n            float expectedPageScaleFactor = initialPageScaleFactor * (shouldScaleRelativeToViewportWidth ? 1 / aspectRatio : 1);\n            EXPECT_NEAR(expectedPageScaleFactor, webViewImpl()->pageScaleFactor(), 0.05f);\n            EXPECT_EQ(WebSize(), webViewImpl()->mainFrame()->scrollOffset());\n        }\n\n        {\n            webViewImpl()->resize(WebSize(viewportSize.width, viewportSize.height));\n            webViewImpl()->setPageScaleFactor(initialPageScaleFactor, WebPoint(scrollOffset.width, scrollOffset.height));\n            webViewImpl()->layout();\n            const WebSize expectedScrollOffset = webViewImpl()->mainFrame()->scrollOffset();\n            webViewImpl()->resize(WebSize(viewportSize.width, viewportSize.height * 0.8f));\n            EXPECT_EQ(initialPageScaleFactor, webViewImpl()->pageScaleFactor());\n            EXPECT_EQ(expectedScrollOffset, webViewImpl()->mainFrame()->scrollOffset());\n            webViewImpl()->resize(WebSize(viewportSize.width, viewportSize.height * 0.8f));\n            EXPECT_EQ(initialPageScaleFactor, webViewImpl()->pageScaleFactor());\n            EXPECT_EQ(expectedScrollOffset, webViewImpl()->mainFrame()->scrollOffset());\n        }\n\n        {\n            webViewImpl()->resize(WebSize(viewportSize.height, viewportSize.width));\n            float pageScaleFactor = webViewImpl()->pageScaleFactor();\n            webViewImpl()->resize(WebSize(viewportSize.width, viewportSize.height));\n            float expectedPageScaleFactor = pageScaleFactor * (shouldScaleRelativeToViewportWidth ? aspectRatio : 1);\n            EXPECT_NEAR(expectedPageScaleFactor, webViewImpl()->pageScaleFactor(), 0.05f);\n            webViewImpl()->mainFrame()->setScrollOffset(scrollOffset);\n\n            WebCore::IntPoint anchorPoint = WebCore::IntPoint(scrollOffset) + WebCore::IntPoint(viewportSize.width / 2, 0);\n            RefPtr<WebCore::Node> anchorNode = webViewImpl()->mainFrameImpl()->frame()->eventHandler()->hitTestResultAtPoint(anchorPoint, HitTestRequest::ReadOnly | HitTestRequest::Active | HitTestRequest::DisallowShadowContent).innerNode();\n            ASSERT(anchorNode);\n\n            pageScaleFactor = webViewImpl()->pageScaleFactor();\n            const WebCore::FloatSize preResizeRelativeOffset\n                = computeRelativeOffset(anchorPoint, anchorNode->boundingBox());\n            webViewImpl()->resize(WebSize(viewportSize.height, viewportSize.width));\n            WebCore::IntPoint newAnchorPoint = WebCore::IntPoint(webViewImpl()->mainFrame()->scrollOffset()) + WebCore::IntPoint(viewportSize.height / 2, 0);\n            const WebCore::FloatSize postResizeRelativeOffset\n                = computeRelativeOffset(newAnchorPoint, anchorNode->boundingBox());\n            EXPECT_NEAR(preResizeRelativeOffset.width(), postResizeRelativeOffset.width(), 0.15f);\n            expectedPageScaleFactor = pageScaleFactor * (shouldScaleRelativeToViewportWidth ? 1 / aspectRatio : 1);\n            EXPECT_NEAR(expectedPageScaleFactor, webViewImpl()->pageScaleFactor(), 0.05f);\n        }\n    }\n", "target": 0, "idx": 119948}
{"func": "WebView* RenderViewImpl::createView(\n    WebFrame* creator,\n    const WebURLRequest& request,\n    const WebWindowFeatures& features,\n    const WebString& frame_name,\n    WebNavigationPolicy policy) {\n  if (shared_popup_counter_->data > kMaximumNumberOfUnacknowledgedPopups)\n    return NULL;\n\n  ViewHostMsg_CreateWindow_Params params;\n  params.opener_id = routing_id_;\n  params.user_gesture = creator->isProcessingUserGesture();\n  params.window_container_type = WindowFeaturesToContainerType(features);\n  params.session_storage_namespace_id = session_storage_namespace_id_;\n   params.frame_name = frame_name;\n   params.opener_frame_id = creator->identifier();\n   params.opener_url = creator->document().url();\n  params.opener_security_origin =\n      creator->document().securityOrigin().toString().utf8();\n   params.opener_suppressed = creator->willSuppressOpenerInNewFrame();\n   params.disposition = NavigationPolicyToDisposition(policy);\n   if (!request.isNull())\n    params.target_url = request.url();\n\n  int32 routing_id = MSG_ROUTING_NONE;\n  int32 surface_id = 0;\n  int64 cloned_session_storage_namespace_id;\n\n  RenderThread::Get()->Send(\n      new ViewHostMsg_CreateWindow(params,\n                                   &routing_id,\n                                   &surface_id,\n                                   &cloned_session_storage_namespace_id));\n  if (routing_id == MSG_ROUTING_NONE)\n    return NULL;\n\n  creator->consumeUserGesture();\n\n  RenderViewImpl* view = RenderViewImpl::Create(\n      routing_id_,\n      renderer_preferences_,\n      webkit_preferences_,\n      shared_popup_counter_,\n      routing_id,\n      surface_id,\n      cloned_session_storage_namespace_id,\n      frame_name,\n      true,\n      false,\n      1,\n      screen_info_,\n      accessibility_mode_);\n  view->opened_by_user_gesture_ = params.user_gesture;\n\n  view->opener_suppressed_ = params.opener_suppressed;\n\n  view->alternate_error_page_url_ = alternate_error_page_url_;\n\n  return view->webview();\n}\n", "target": 1, "idx": 185202}
{"func": " void VaapiVideoDecodeAccelerator::VaapiH264Accelerator::FillVAPicture(\n     VAPictureH264* va_pic,\n     scoped_refptr<H264Picture> pic) {\n   VASurfaceID va_surface_id = VA_INVALID_SURFACE;\n \n   if (!pic->nonexisting) {\n    scoped_refptr<VaapiDecodeSurface> dec_surface =\n        H264PictureToVaapiDecodeSurface(pic);\n    va_surface_id = dec_surface->va_surface()->id();\n  }\n\n  va_pic->picture_id = va_surface_id;\n  va_pic->frame_idx = pic->frame_num;\n  va_pic->flags = 0;\n\n  switch (pic->field) {\n    case H264Picture::FIELD_NONE:\n      break;\n    case H264Picture::FIELD_TOP:\n      va_pic->flags |= VA_PICTURE_H264_TOP_FIELD;\n      break;\n    case H264Picture::FIELD_BOTTOM:\n      va_pic->flags |= VA_PICTURE_H264_BOTTOM_FIELD;\n      break;\n  }\n\n  if (pic->ref) {\n    va_pic->flags |= pic->long_term ? VA_PICTURE_H264_LONG_TERM_REFERENCE\n                                    : VA_PICTURE_H264_SHORT_TERM_REFERENCE;\n  }\n\n  va_pic->TopFieldOrderCnt = pic->top_field_order_cnt;\n  va_pic->BottomFieldOrderCnt = pic->bottom_field_order_cnt;\n}\n", "target": 1, "idx": 186777}
{"func": "int modbus_reply(modbus_t *ctx, const uint8_t *req,\n                 int req_length, modbus_mapping_t *mb_mapping)\n{\n    int offset;\n    int slave;\n    int function;\n    uint16_t address;\n    uint8_t rsp[MAX_MESSAGE_LENGTH];\n    int rsp_length = 0;\n    sft_t sft;\n\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    offset = ctx->backend->header_length;\n    slave = req[offset - 1];\n    function = req[offset];\n    address = (req[offset + 1] << 8) + req[offset + 2];\n\n    sft.slave = slave;\n    sft.function = function;\n    sft.t_id = ctx->backend->prepare_response_tid(req, &req_length);\n\n    /* Data are flushed on illegal number of values errors. */\n    switch (function) {\n    case MODBUS_FC_READ_COILS:\n    case MODBUS_FC_READ_DISCRETE_INPUTS: {\n        unsigned int is_input = (function == MODBUS_FC_READ_DISCRETE_INPUTS);\n        int start_bits = is_input ? mb_mapping->start_input_bits : mb_mapping->start_bits;\n        int nb_bits = is_input ? mb_mapping->nb_input_bits : mb_mapping->nb_bits;\n        uint8_t *tab_bits = is_input ? mb_mapping->tab_input_bits : mb_mapping->tab_bits;\n        const char * const name = is_input ? \"read_input_bits\" : \"read_bits\";\n        int nb = (req[offset + 3] << 8) + req[offset + 4];\n        /* The mapping can be shifted to reduce memory consumption and it\n           doesn't always start at address zero. */\n        int mapping_address = address - start_bits;\n\n        if (nb < 1 || MODBUS_MAX_READ_BITS < nb) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,\n                \"Illegal nb of values %d in %s (max %d)\\n\",\n                nb, name, MODBUS_MAX_READ_BITS);\n        } else if (mapping_address < 0 || (mapping_address + nb) > nb_bits) {\n            rsp_length = response_exception(\n                ctx, &sft,\n                MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data address 0x%0X in %s\\n\",\n                mapping_address < 0 ? address : address + nb, name);\n        } else {\n            rsp_length = ctx->backend->build_response_basis(&sft, rsp);\n            rsp[rsp_length++] = (nb / 8) + ((nb % 8) ? 1 : 0);\n            rsp_length = response_io_status(tab_bits, mapping_address, nb,\n                                            rsp, rsp_length);\n        }\n    }\n        break;\n    case MODBUS_FC_READ_HOLDING_REGISTERS:\n    case MODBUS_FC_READ_INPUT_REGISTERS: {\n        unsigned int is_input = (function == MODBUS_FC_READ_INPUT_REGISTERS);\n        int start_registers = is_input ? mb_mapping->start_input_registers : mb_mapping->start_registers;\n        int nb_registers = is_input ? mb_mapping->nb_input_registers : mb_mapping->nb_registers;\n        uint16_t *tab_registers = is_input ? mb_mapping->tab_input_registers : mb_mapping->tab_registers;\n        const char * const name = is_input ? \"read_input_registers\" : \"read_registers\";\n        int nb = (req[offset + 3] << 8) + req[offset + 4];\n        /* The mapping can be shifted to reduce memory consumption and it\n           doesn't always start at address zero. */\n        int mapping_address = address - start_registers;\n\n        if (nb < 1 || MODBUS_MAX_READ_REGISTERS < nb) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,\n                \"Illegal nb of values %d in %s (max %d)\\n\",\n                nb, name, MODBUS_MAX_READ_REGISTERS);\n        } else if (mapping_address < 0 || (mapping_address + nb) > nb_registers) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data address 0x%0X in %s\\n\",\n                mapping_address < 0 ? address : address + nb, name);\n        } else {\n            int i;\n\n            rsp_length = ctx->backend->build_response_basis(&sft, rsp);\n            rsp[rsp_length++] = nb << 1;\n            for (i = mapping_address; i < mapping_address + nb; i++) {\n                rsp[rsp_length++] = tab_registers[i] >> 8;\n                rsp[rsp_length++] = tab_registers[i] & 0xFF;\n            }\n        }\n    }\n        break;\n    case MODBUS_FC_WRITE_SINGLE_COIL: {\n        int mapping_address = address - mb_mapping->start_bits;\n\n        if (mapping_address < 0 || mapping_address >= mb_mapping->nb_bits) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data address 0x%0X in write_bit\\n\",\n                address);\n        } else {\n            int data = (req[offset + 3] << 8) + req[offset + 4];\n\n            if (data == 0xFF00 || data == 0x0) {\n                mb_mapping->tab_bits[mapping_address] = data ? ON : OFF;\n                memcpy(rsp, req, req_length);\n                rsp_length = req_length;\n            } else {\n                rsp_length = response_exception(\n                    ctx, &sft,\n                    MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, FALSE,\n                    \"Illegal data value 0x%0X in write_bit request at address %0X\\n\",\n                    data, address);\n            }\n        }\n    }\n        break;\n    case MODBUS_FC_WRITE_SINGLE_REGISTER: {\n        int mapping_address = address - mb_mapping->start_registers;\n\n        if (mapping_address < 0 || mapping_address >= mb_mapping->nb_registers) {\n            rsp_length = response_exception(\n                ctx, &sft,\n                MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data address 0x%0X in write_register\\n\",\n                address);\n        } else {\n            int data = (req[offset + 3] << 8) + req[offset + 4];\n\n            mb_mapping->tab_registers[mapping_address] = data;\n            memcpy(rsp, req, req_length);\n            rsp_length = req_length;\n        }\n    }\n         break;\n     case MODBUS_FC_WRITE_MULTIPLE_COILS: {\n         int nb = (req[offset + 3] << 8) + req[offset + 4];\n         int mapping_address = address - mb_mapping->start_bits;\n \n        if (nb < 1 || MODBUS_MAX_WRITE_BITS < nb) {\n             /* May be the indication has been truncated on reading because of\n              * invalid address (eg. nb is 0 but the request contains values to\n              * write) so it's necessary to flush. */\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,\n                \"Illegal number of values %d in write_bits (max %d)\\n\",\n                nb, MODBUS_MAX_WRITE_BITS);\n        } else if (mapping_address < 0 ||\n                   (mapping_address + nb) > mb_mapping->nb_bits) {\n            rsp_length = response_exception(\n                ctx, &sft,\n                MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data address 0x%0X in write_bits\\n\",\n                mapping_address < 0 ? address : address + nb);\n        } else {\n            /* 6 = byte count */\n            modbus_set_bits_from_bytes(mb_mapping->tab_bits, mapping_address, nb,\n                                       &req[offset + 6]);\n\n            rsp_length = ctx->backend->build_response_basis(&sft, rsp);\n            /* 4 to copy the bit address (2) and the quantity of bits */\n            memcpy(rsp + rsp_length, req + rsp_length, 4);\n            rsp_length += 4;\n        }\n    }\n         break;\n     case MODBUS_FC_WRITE_MULTIPLE_REGISTERS: {\n         int nb = (req[offset + 3] << 8) + req[offset + 4];\n         int mapping_address = address - mb_mapping->start_registers;\n \n        if (nb < 1 || MODBUS_MAX_WRITE_REGISTERS < nb) {\n             rsp_length = response_exception(\n                 ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,\n                 \"Illegal number of values %d in write_registers (max %d)\\n\",\n                nb, MODBUS_MAX_WRITE_REGISTERS);\n        } else if (mapping_address < 0 ||\n                   (mapping_address + nb) > mb_mapping->nb_registers) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data address 0x%0X in write_registers\\n\",\n                mapping_address < 0 ? address : address + nb);\n        } else {\n            int i, j;\n            for (i = mapping_address, j = 6; i < mapping_address + nb; i++, j += 2) {\n                /* 6 and 7 = first value */\n                mb_mapping->tab_registers[i] =\n                    (req[offset + j] << 8) + req[offset + j + 1];\n            }\n\n            rsp_length = ctx->backend->build_response_basis(&sft, rsp);\n            /* 4 to copy the address (2) and the no. of registers */\n            memcpy(rsp + rsp_length, req + rsp_length, 4);\n            rsp_length += 4;\n        }\n    }\n        break;\n    case MODBUS_FC_REPORT_SLAVE_ID: {\n        int str_len;\n        int byte_count_pos;\n\n        rsp_length = ctx->backend->build_response_basis(&sft, rsp);\n        /* Skip byte count for now */\n        byte_count_pos = rsp_length++;\n        rsp[rsp_length++] = _REPORT_SLAVE_ID;\n        /* Run indicator status to ON */\n        rsp[rsp_length++] = 0xFF;\n        /* LMB + length of LIBMODBUS_VERSION_STRING */\n        str_len = 3 + strlen(LIBMODBUS_VERSION_STRING);\n        memcpy(rsp + rsp_length, \"LMB\" LIBMODBUS_VERSION_STRING, str_len);\n        rsp_length += str_len;\n        rsp[byte_count_pos] = rsp_length - byte_count_pos - 1;\n    }\n        break;\n    case MODBUS_FC_READ_EXCEPTION_STATUS:\n        if (ctx->debug) {\n            fprintf(stderr, \"FIXME Not implemented\\n\");\n        }\n        errno = ENOPROTOOPT;\n        return -1;\n        break;\n    case MODBUS_FC_MASK_WRITE_REGISTER: {\n        int mapping_address = address - mb_mapping->start_registers;\n\n        if (mapping_address < 0 || mapping_address >= mb_mapping->nb_registers) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data address 0x%0X in write_register\\n\",\n                address);\n        } else {\n            uint16_t data = mb_mapping->tab_registers[mapping_address];\n            uint16_t and = (req[offset + 3] << 8) + req[offset + 4];\n            uint16_t or = (req[offset + 5] << 8) + req[offset + 6];\n\n            data = (data & and) | (or & (~and));\n            mb_mapping->tab_registers[mapping_address] = data;\n            memcpy(rsp, req, req_length);\n            rsp_length = req_length;\n        }\n    }\n        break;\n    case MODBUS_FC_WRITE_AND_READ_REGISTERS: {\n        int nb = (req[offset + 3] << 8) + req[offset + 4];\n        uint16_t address_write = (req[offset + 5] << 8) + req[offset + 6];\n        int nb_write = (req[offset + 7] << 8) + req[offset + 8];\n        int nb_write_bytes = req[offset + 9];\n        int mapping_address = address - mb_mapping->start_registers;\n        int mapping_address_write = address_write - mb_mapping->start_registers;\n\n        if (nb_write < 1 || MODBUS_MAX_WR_WRITE_REGISTERS < nb_write ||\n            nb < 1 || MODBUS_MAX_WR_READ_REGISTERS < nb ||\n            nb_write_bytes != nb_write * 2) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,\n                \"Illegal nb of values (W%d, R%d) in write_and_read_registers (max W%d, R%d)\\n\",\n                nb_write, nb, MODBUS_MAX_WR_WRITE_REGISTERS, MODBUS_MAX_WR_READ_REGISTERS);\n        } else if (mapping_address < 0 ||\n                   (mapping_address + nb) > mb_mapping->nb_registers ||\n                   mapping_address < 0 ||\n                   (mapping_address_write + nb_write) > mb_mapping->nb_registers) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data read address 0x%0X or write address 0x%0X write_and_read_registers\\n\",\n                mapping_address < 0 ? address : address + nb,\n                mapping_address_write < 0 ? address_write : address_write + nb_write);\n        } else {\n            int i, j;\n            rsp_length = ctx->backend->build_response_basis(&sft, rsp);\n            rsp[rsp_length++] = nb << 1;\n\n            /* Write first.\n               10 and 11 are the offset of the first values to write */\n            for (i = mapping_address_write, j = 10;\n                 i < mapping_address_write + nb_write; i++, j += 2) {\n                mb_mapping->tab_registers[i] =\n                    (req[offset + j] << 8) + req[offset + j + 1];\n            }\n\n            /* and read the data for the response */\n            for (i = mapping_address; i < mapping_address + nb; i++) {\n                rsp[rsp_length++] = mb_mapping->tab_registers[i] >> 8;\n                rsp[rsp_length++] = mb_mapping->tab_registers[i] & 0xFF;\n            }\n        }\n    }\n        break;\n\n    default:\n        rsp_length = response_exception(\n            ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_FUNCTION, rsp, TRUE,\n            \"Unknown Modbus function code: 0x%0X\\n\", function);\n        break;\n    }\n\n    /* Suppress any responses when the request was a broadcast */\n    return (ctx->backend->backend_type == _MODBUS_BACKEND_TYPE_RTU &&\n            slave == MODBUS_BROADCAST_ADDRESS) ? 0 : send_msg(ctx, rsp, rsp_length);\n}\n", "target": 1, "idx": 182753}
{"func": " void SendTabToSelfInfoBarDelegate::OpenTab() {\n  NOTIMPLEMENTED();\n }\n", "target": 1, "idx": 186510}
{"func": "void SoftAVC::onQueueFilled(OMX_U32 /* portIndex */) {\n if (mSignalledError || mOutputPortSettingsChange != NONE) {\n return;\n }\n\n if (mEOSStatus == OUTPUT_FRAMES_FLUSHED) {\n return;\n }\n\n List<BufferInfo *> &inQueue = getPortQueue(kInputPortIndex);\n List<BufferInfo *> &outQueue = getPortQueue(kOutputPortIndex);\n\n if (mHeadersDecoded) {\n\n        drainAllOutputBuffers(false /* eos */);\n }\n\n    H264SwDecRet ret = H264SWDEC_PIC_RDY;\n bool portWillReset = false;\n while ((mEOSStatus != INPUT_DATA_AVAILABLE || !inQueue.empty())\n && outQueue.size() == kNumOutputBuffers) {\n\n if (mEOSStatus == INPUT_EOS_SEEN) {\n            drainAllOutputBuffers(true /* eos */);\n return;\n }\n\n BufferInfo *inInfo = *inQueue.begin();\n        OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;\n ++mPicId;\n\n        OMX_BUFFERHEADERTYPE *header = new OMX_BUFFERHEADERTYPE;\n        memset(header, 0, sizeof(OMX_BUFFERHEADERTYPE));\n        header->nTimeStamp = inHeader->nTimeStamp;\n        header->nFlags = inHeader->nFlags;\n if (header->nFlags & OMX_BUFFERFLAG_EOS) {\n            mEOSStatus = INPUT_EOS_SEEN;\n }\n        mPicToHeaderMap.add(mPicId, header);\n        inQueue.erase(inQueue.begin());\n\n        H264SwDecInput inPicture;\n        H264SwDecOutput outPicture;\n        memset(&inPicture, 0, sizeof(inPicture));\n        inPicture.dataLen = inHeader->nFilledLen;\n        inPicture.pStream = inHeader->pBuffer + inHeader->nOffset;\n        inPicture.picId = mPicId;\n        inPicture.intraConcealmentMethod = 1;\n        H264SwDecPicture decodedPicture;\n\n while (inPicture.dataLen > 0) {\n            ret = H264SwDecDecode(mHandle, &inPicture, &outPicture);\n if (ret == H264SWDEC_HDRS_RDY_BUFF_NOT_EMPTY ||\n                ret == H264SWDEC_PIC_RDY_BUFF_NOT_EMPTY) {\n                inPicture.dataLen -= (u32)(outPicture.pStrmCurrPos - inPicture.pStream);\n                inPicture.pStream = outPicture.pStrmCurrPos;\n if (ret == H264SWDEC_HDRS_RDY_BUFF_NOT_EMPTY) {\n                    mHeadersDecoded = true;\n                    H264SwDecInfo decoderInfo;\n                    CHECK(H264SwDecGetInfo(mHandle, &decoderInfo) == H264SWDEC_OK);\n\n SoftVideoDecoderOMXComponent::CropSettingsMode cropSettingsMode =\n                        handleCropParams(decoderInfo);\n                    handlePortSettingsChange(\n &portWillReset, decoderInfo.picWidth, decoderInfo.picHeight,\n                            cropSettingsMode);\n }\n } else {\n if (portWillReset) {\n if (H264SwDecNextPicture(mHandle, &decodedPicture, 0)\n == H264SWDEC_PIC_RDY) {\n\n                        saveFirstOutputBuffer(\n                            decodedPicture.picId,\n (uint8_t *)decodedPicture.pOutputPicture);\n }\n }\n                inPicture.dataLen = 0;\n if (ret < 0) {\n                    ALOGE(\"Decoder failed: %d\", ret);\n\n                    notify(OMX_EventError, OMX_ErrorUndefined,\n                           ERROR_MALFORMED, NULL);\n\n                    mSignalledError = true;\n return;\n }\n }\n }\n        inInfo->mOwnedByUs = false;\n        notifyEmptyBufferDone(inHeader);\n\n if (portWillReset) {\n return;\n\n         }\n \n         if (mFirstPicture && !outQueue.empty()) {\n            drainOneOutputBuffer(mFirstPictureId, mFirstPicture);\n             delete[] mFirstPicture;\n             mFirstPicture = NULL;\n             mFirstPictureId = -1;\n }\n\n        drainAllOutputBuffers(false /* eos */);\n }\n}\n", "target": 1, "idx": 188200}
{"func": "void ACodec::ExecutingToIdleState::onOutputBufferDrained(\n const sp<AMessage> &msg) {\n BaseState::onOutputBufferDrained(msg);\n\n    changeStateIfWeOwnAllBuffers();\n}\n", "target": 0, "idx": 177282}
{"func": "double HTMLMediaElement::effectiveMediaVolume() const {\n  if (m_muted)\n    return 0;\n\n  return m_volume;\n}\n", "target": 0, "idx": 139979}
{"func": "void DownloadItemImplDelegate::CheckForFileRemoval(\n    DownloadItemImpl* download_item) {}\n", "target": 0, "idx": 159209}
{"func": "htmlElementAllowedHere(const htmlElemDesc* parent, const xmlChar* elt) {\n  const char** p ;\n\n  if ( ! elt || ! parent || ! parent->subelts )\n\treturn 0 ;\n\n  for ( p = parent->subelts; *p; ++p )\n    if ( !xmlStrcmp((const xmlChar *)*p, elt) )\n      return 1 ;\n\n  return 0 ;\n}\n", "target": 0, "idx": 163592}
{"func": "void pdf_summarize(\n    FILE        *fp,\n    const pdf_t *pdf,\n    const char  *name,\n    pdf_flag_t   flags)\n{\n    int   i, j, page, n_versions, n_entries;\n    FILE *dst, *out;\n    char *dst_name, *c;\n\n    dst = NULL;\n    dst_name = NULL;\n \n     if (name)\n     {\n        dst_name = malloc(strlen(name) * 2 + 16);\n         sprintf(dst_name, \"%s/%s\", name, name);\n \n         if ((c = strrchr(dst_name, '.')) && (strncmp(c, \".pdf\", 4) == 0))\n          *c = '\\0';\n\n        strcat(dst_name, \".summary\");\n        if (!(dst = fopen(dst_name, \"w\")))\n        {\n            ERR(\"Could not open file '%s' for writing\\n\", dst_name);\n            return;\n        }\n    }\n    \n    /* Send output to file or stdout */\n    out = (dst) ? dst : stdout;\n\n    /* Count versions */\n    n_versions = pdf->n_xrefs;\n    if (n_versions && pdf->xrefs[0].is_linear)\n      --n_versions;\n\n    /* Ignore bad xref entry */\n    for (i=1; i<pdf->n_xrefs; ++i)\n      if (pdf->xrefs[i].end == 0)\n        --n_versions;\n\n    /* If we have no valid versions but linear, count that */\n    if (!pdf->n_xrefs || (!n_versions && pdf->xrefs[0].is_linear))\n      n_versions = 1;\n\n    /* Compare each object (if we dont have xref streams) */\n    n_entries = 0;\n    for (i=0; !(const int)pdf->has_xref_streams && i<pdf->n_xrefs; i++)\n    {\n        if (flags & PDF_FLAG_QUIET)\n          continue;\n\n        for (j=0; j<pdf->xrefs[i].n_entries; j++)\n        {\n            ++n_entries;\n            fprintf(out,\n                    \"%s: --%c-- Version %d -- Object %d (%s)\",\n                    pdf->name,\n                    pdf_get_object_status(pdf, i, j),\n                    pdf->xrefs[i].version,\n                    pdf->xrefs[i].entries[j].obj_id,\n                    get_type(fp, pdf->xrefs[i].entries[j].obj_id,\n                             &pdf->xrefs[i]));\n\n            /* TODO\n            page = get_page(pdf->xrefs[i].entries[j].obj_id, &pdf->xrefs[i]);\n            */\n\n            if (0 /*page*/)\n              fprintf(out, \" Page(%d)\\n\", page);\n            else\n              fprintf(out, \"\\n\");\n        }\n    }\n\n    /* Trailing summary */\n    if (!(flags & PDF_FLAG_QUIET))\n    {\n        /* Let the user know that we cannot we print a per-object summary.\n         * If we have a 1.5 PDF using streams for xref, we have not objects\n         * to display, so let the user know whats up.\n         */\n        if (pdf->has_xref_streams || !n_entries)\n           fprintf(out,\n               \"%s: This PDF contains potential cross reference streams.\\n\"\n               \"%s: An object summary is not available.\\n\",\n               pdf->name,\n               pdf->name);\n\n        fprintf(out,\n                \"---------- %s ----------\\n\"\n                \"Versions: %d\\n\", \n                pdf->name,\n                n_versions);\n\n        /* Count entries for summary */\n        if (!pdf->has_xref_streams)\n          for (i=0; i<pdf->n_xrefs; i++)\n          {\n              if (pdf->xrefs[i].is_linear)\n                continue;\n\n              n_entries = pdf->xrefs[i].n_entries;\n\n              /* If we are a linearized PDF, all versions are made from those\n               * objects too.  So count em'\n               */\n              if (pdf->xrefs[0].is_linear)\n                n_entries += pdf->xrefs[0].n_entries; \n\n              if (pdf->xrefs[i].version && n_entries)\n                fprintf(out,\n                        \"Version %d -- %d objects\\n\",\n                        pdf->xrefs[i].version, \n                        n_entries);\n           }\n    }\n    else /* Quiet output */\n      fprintf(out, \"%s: %d\\n\", pdf->name, n_versions);\n\n    if (dst)\n    {\n        fclose(dst);\n        free(dst_name);\n    }\n}\n", "target": 1, "idx": 182746}
{"func": "long Cluster::ParseSimpleBlock(\n    long long block_size,\n    long long& pos,\n    long& len)\n{\n    const long long block_start = pos;\n    const long long block_stop = pos + block_size;\n    IMkvReader* const pReader = m_pSegment->m_pReader;\n    long long total, avail;\n    long status = pReader->Length(&total, &avail);\n    if (status < 0)  //error\n        return status;\n    assert((total < 0) || (avail <= total));\n    if ((pos + 1) > avail)\n    {\n        len = 1;\n        return E_BUFFER_NOT_FULL;\n     }\n \n     long long result = GetUIntLength(pReader, pos, len);\n \n    if (result < 0)  //error\n        return static_cast<long>(result);\n \n    if (result > 0)  //weird\n        return E_BUFFER_NOT_FULL;\n \n    if ((pos + len) > block_stop)\n        return E_FILE_FORMAT_INVALID;\n \n     if ((pos + len) > avail)\n         return E_BUFFER_NOT_FULL;\n \n    const long long track = ReadUInt(pReader, pos, len);\n \n    if (track < 0) //error\n        return static_cast<long>(track);\n \n    if (track == 0)\n        return E_FILE_FORMAT_INVALID;\n \n #if 0\n\n const Tracks* const pTracks = m_pSegment->GetTracks();\n    assert(pTracks);\n\n const long tn = static_cast<long>(track);\n\n const Track* const pTrack = pTracks->GetTrackByNumber(tn);\n\n if (pTrack == NULL)\n\n         return E_FILE_FORMAT_INVALID;\n #endif\n \n    pos += len;  //consume track number\n \n    if ((pos + 2) > block_stop)\n        return E_FILE_FORMAT_INVALID;\n \n    if ((pos + 2) > avail)\n    {\n        len = 2;\n        return E_BUFFER_NOT_FULL;\n    }\n \n    pos += 2;  //consume timecode\n \n    if ((pos + 1) > block_stop)\n        return E_FILE_FORMAT_INVALID;\n \n    if ((pos + 1) > avail)\n    {\n        len = 1;\n        return E_BUFFER_NOT_FULL;\n    }\n \n    unsigned char flags;\n \n    status = pReader->Read(pos, 1, &flags);\n \n    if (status < 0)  //error or underflow\n    {\n        len = 1;\n        return status;\n    }\n \n    ++pos;  //consume flags byte\n    assert(pos <= avail);\n \n    if (pos >= block_stop)\n        return E_FILE_FORMAT_INVALID;\n \n    const int lacing = int(flags & 0x06) >> 1;\n \n    if ((lacing != 0) && (block_stop > avail))\n    {\n        len = static_cast<long>(block_stop - pos);\n        return E_BUFFER_NOT_FULL;\n    }\n \n    status = CreateBlock(0x23,  //simple block id\n                         block_start, block_size,\n                         0);  //DiscardPadding\n \n    if (status != 0)\n        return status;\n \n    m_pos = block_stop;\n \n    return 0;  //success\n }\n", "target": 1, "idx": 188451}
{"func": "void BufferQueueConsumer::dump(String8& result, const char* prefix) const {\n const IPCThreadState* ipc = IPCThreadState::self();\n const pid_t pid = ipc->getCallingPid();\n const uid_t uid = ipc->getCallingUid();\n if ((uid != AID_SHELL)\n && !PermissionCache::checkPermission(String16(\n\n             \"android.permission.DUMP\"), pid, uid)) {\n         result.appendFormat(\"Permission Denial: can't dump BufferQueueConsumer \"\n                 \"from pid=%d, uid=%d\\n\", pid, uid);\n     } else {\n         mCore->dump(result, prefix);\n     }\n}\n", "target": 1, "idx": 187916}
{"func": "bool InitTargetServices(sandbox::TargetServices* target_services) {\n  DCHECK(target_services);\n  DCHECK(!g_target_services);\n  sandbox::ResultCode result = target_services->Init();\n  g_target_services = target_services;\n  return SBOX_ALL_OK == result;\n}\n", "target": 0, "idx": 113832}
{"func": "static int filter_frame(AVFilterLink *inlink, AVFrame *frame)\n{\n    AVFilterContext   *ctx     = inlink->dst;\n    FieldOrderContext *s       = ctx->priv;\n    AVFilterLink      *outlink = ctx->outputs[0];\n    int h, plane, line_step, line_size, line;\n    uint8_t *data;\n\n    if (!frame->interlaced_frame ||\n        frame->top_field_first == s->dst_tff)\n        return ff_filter_frame(outlink, frame);\n\n    av_dlog(ctx,\n             \"picture will move %s one line\\n\",\n             s->dst_tff ? \"up\" : \"down\");\n     h = frame->height;\n    for (plane = 0; plane < 4 && frame->data[plane]; plane++) {\n         line_step = frame->linesize[plane];\n         line_size = s->line_size[plane];\n         data = frame->data[plane];\n        if (s->dst_tff) {\n            /** Move every line up one line, working from\n             *  the top to the bottom of the frame.\n             *  The original top line is lost.\n             *  The new last line is created as a copy of the\n             *  penultimate line from that field. */\n            for (line = 0; line < h; line++) {\n                if (1 + line < frame->height) {\n                    memcpy(data, data + line_step, line_size);\n                } else {\n                    memcpy(data, data - line_step - line_step, line_size);\n                }\n                data += line_step;\n            }\n        } else {\n            /** Move every line down one line, working from\n             *  the bottom to the top of the frame.\n             *  The original bottom line is lost.\n             *  The new first line is created as a copy of the\n             *  second line from that field. */\n            data += (h - 1) * line_step;\n            for (line = h - 1; line >= 0 ; line--) {\n                if (line > 0) {\n                    memcpy(data, data - line_step, line_size);\n                } else {\n                    memcpy(data, data + line_step + line_step, line_size);\n                }\n                data -= line_step;\n            }\n        }\n    }\n    frame->top_field_first = s->dst_tff;\n\n    return ff_filter_frame(outlink, frame);\n}\n", "target": 1, "idx": 179172}
{"func": "IntSize PaintLayerScrollableArea::ScrollOffsetInt() const {\n  return FlooredIntSize(scroll_offset_);\n}\n", "target": 0, "idx": 141482}
{"func": "onig_is_in_code_range(const UChar* p, OnigCodePoint code)\n{\n  OnigCodePoint n, *data;\n  OnigCodePoint low, high, x;\n\n  GET_CODE_POINT(n, p);\n  data = (OnigCodePoint* )p;\n  data++;\n\n  for (low = 0, high = n; low < high; ) {\n    x = (low + high) >> 1;\n    if (code > data[x * 2 + 1])\n      low = x + 1;\n    else\n      high = x;\n  }\n\n  return ((low < n && code >= data[low * 2]) ? 1 : 0);\n}\n", "target": 0, "idx": 89193}
{"func": "static inline char *parse_ip_address_ex(const char *str, size_t str_len, int *portno, int get_err, zend_string **err)\n{\n\tchar *colon;\n \tchar *host = NULL;\n \n #ifdef HAVE_IPV6\n\tchar *p;\n \tif (*(str) == '[' && str_len > 1) {\n \t\t/* IPV6 notation to specify raw address with port (i.e. [fe80::1]:80) */\n\t\tp = memchr(str + 1, ']', str_len - 2);\n \t\tif (!p || *(p + 1) != ':') {\n \t\t\tif (get_err) {\n \t\t\t\t*err = strpprintf(0, \"Failed to parse IPv6 address \\\"%s\\\"\", str);\n \t\t\t}\n \t\t\treturn NULL;\n \t\t}\n\t\t*portno = atoi(p + 2);\n \t\treturn estrndup(str + 1, p - str - 1);\n \t}\n #endif\n \tif (str_len) {\n \t\tcolon = memchr(str, ':', str_len - 1);\n \t} else {\n \t\tcolon = NULL;\n \t}\n \tif (colon) {\n\t\t*portno = atoi(colon + 1);\n\t\thost = estrndup(str, colon - str);\n\t} else {\n\t\tif (get_err) {\n\t\t\t*err = strpprintf(0, \"Failed to parse address \\\"%s\\\"\", str);\n \t\t}\n\t\treturn NULL;\n \t}\n \n\treturn host;\n }\n", "target": 1, "idx": 181461}
{"func": "validate_group(struct perf_event *event)\n{\n\tstruct perf_event *sibling, *leader = event->group_leader;\n\tstruct pmu_hw_events fake_pmu;\n\tDECLARE_BITMAP(fake_used_mask, ARMPMU_MAX_HWEVENTS);\n\n\t/*\n\t * Initialise the fake PMU. We only need to populate the\n\t * used_mask for the purposes of validation.\n\t */\n \tmemset(fake_used_mask, 0, sizeof(fake_used_mask));\n \tfake_pmu.used_mask = fake_used_mask;\n \n\tif (!validate_event(&fake_pmu, leader))\n \t\treturn -EINVAL;\n \n \tlist_for_each_entry(sibling, &leader->sibling_list, group_entry) {\n\t\tif (!validate_event(&fake_pmu, sibling))\n \t\t\treturn -EINVAL;\n \t}\n \n\tif (!validate_event(&fake_pmu, event))\n \t\treturn -EINVAL;\n \n \treturn 0;\n}\n", "target": 1, "idx": 180640}
{"func": "static int ndp_sock_recv(struct ndp *ndp)\n{\n\tstruct ndp_msg *msg;\n\tenum ndp_msg_type msg_type;\n\tsize_t len;\n\tint err;\n\n\tmsg = ndp_msg_alloc();\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tlen = ndp_msg_payload_maxlen(msg);\n\terr = myrecvfrom6(ndp->sock, msg->buf, &len, 0,\n\t\t\t  &msg->addrto, &msg->ifindex, &msg->hoplimit);\n\tif (err) {\n\t\terr(ndp, \"Failed to receive message\");\n\t\tgoto free_msg;\n\t}\n\tdbg(ndp, \"rcvd from: %s, ifindex: %u, hoplimit: %d\",\n\t\t str_in6_addr(&msg->addrto), msg->ifindex, msg->hoplimit);\n\n\tif (msg->hoplimit != 255) {\n\t\twarn(ndp, \"ignoring packet with bad hop limit (%d)\", msg->hoplimit);\n\t\terr = 0;\n\t\tgoto free_msg;\n\t}\n\n\tif (len < sizeof(*msg->icmp6_hdr)) {\n\t\twarn(ndp, \"rcvd icmp6 packet too short (%luB)\", len);\n\t\terr = 0;\n\t\tgoto free_msg;\n\t}\n\terr = ndp_msg_type_by_raw_type(&msg_type, msg->icmp6_hdr->icmp6_type);\n\tif (err) {\n\t\terr = 0;\n\t\tgoto free_msg;\n\t}\n\tndp_msg_init(msg, msg_type);\n\tndp_msg_payload_len_set(msg, len);\n\n\tif (!ndp_msg_check_valid(msg)) {\n\t\twarn(ndp, \"rcvd invalid ND message\");\n\t\terr = 0;\n\t\tgoto free_msg;\n\t}\n\n\tdbg(ndp, \"rcvd %s, len: %zuB\",\n\t\t ndp_msg_type_info(msg_type)->strabbr, len);\n\n\tif (!ndp_msg_check_opts(msg)) {\n\t\terr = 0;\n\t\tgoto free_msg;\n\t}\n\n\terr = ndp_call_handlers(ndp, msg);;\n\nfree_msg:\n\tndp_msg_destroy(msg);\n\treturn err;\n}\n", "target": 0, "idx": 94935}
{"func": "void LargeObjectPage::Sweep() {\n  GetHeapObjectHeader()->Unmark();\n  Arena()->GetThreadState()->Heap().HeapStats().IncreaseMarkedObjectSize(\n      size());\n}\n", "target": 0, "idx": 166777}
{"func": "is_cgi(cupsd_client_t *con,\t\t/* I - Client connection */\n       const char     *filename,\t/* I - Real filename */\n       struct stat    *filestats,\t/* I - File information */\n       mime_type_t    *type)\t\t/* I - MIME type */\n{\n  const char\t*options;\t\t/* Options on URL */\n\n\n /*\n  * Get the options, if any...\n  */\n\n  if ((options = strchr(con->uri, '?')) != NULL)\n  {\n    options ++;\n    cupsdSetStringf(&(con->query_string), \"QUERY_STRING=%s\", options);\n  }\n\n /*\n  * Check for known types...\n  */\n\n  if (!type || _cups_strcasecmp(type->super, \"application\"))\n  {\n    cupsdLogClient(con, CUPSD_LOG_DEBUG2, \"is_cgi: filename=\\\"%s\\\", filestats=%p, type=%s/%s, returning 0.\", filename, filestats, type ? type->super : \"unknown\", type ? type->type : \"unknown\");\n    return (0);\n  }\n\n  if (!_cups_strcasecmp(type->type, \"x-httpd-cgi\") &&\n      (filestats->st_mode & 0111))\n  {\n   /*\n    * \"application/x-httpd-cgi\" is a CGI script.\n    */\n\n    cupsdSetString(&con->command, filename);\n\n    if (options)\n      cupsdSetStringf(&con->options, \" %s\", options);\n\n    cupsdLogClient(con, CUPSD_LOG_DEBUG2, \"is_cgi: filename=\\\"%s\\\", filestats=%p, type=%s/%s, returning 1.\", filename, filestats, type->super, type->type);\n    return (1);\n  }\n#ifdef HAVE_JAVA\n  else if (!_cups_strcasecmp(type->type, \"x-httpd-java\"))\n  {\n   /*\n    * \"application/x-httpd-java\" is a Java servlet.\n    */\n\n    cupsdSetString(&con->command, CUPS_JAVA);\n\n    if (options)\n      cupsdSetStringf(&con->options, \" %s %s\", filename, options);\n    else\n      cupsdSetStringf(&con->options, \" %s\", filename);\n\n    cupsdLogClient(con, CUPSD_LOG_DEBUG2, \"is_cgi: filename=\\\"%s\\\", filestats=%p, type=%s/%s, returning 1.\", filename, filestats, type->super, type->type);\n    return (1);\n  }\n#endif /* HAVE_JAVA */\n#ifdef HAVE_PERL\n  else if (!_cups_strcasecmp(type->type, \"x-httpd-perl\"))\n  {\n   /*\n    * \"application/x-httpd-perl\" is a Perl page.\n    */\n\n    cupsdSetString(&con->command, CUPS_PERL);\n\n    if (options)\n      cupsdSetStringf(&con->options, \" %s %s\", filename, options);\n    else\n      cupsdSetStringf(&con->options, \" %s\", filename);\n\n    cupsdLogClient(con, CUPSD_LOG_DEBUG2, \"is_cgi: filename=\\\"%s\\\", filestats=%p, type=%s/%s, returning 1.\", filename, filestats, type->super, type->type);\n    return (1);\n  }\n#endif /* HAVE_PERL */\n#ifdef HAVE_PHP\n  else if (!_cups_strcasecmp(type->type, \"x-httpd-php\"))\n  {\n   /*\n    * \"application/x-httpd-php\" is a PHP page.\n    */\n\n    cupsdSetString(&con->command, CUPS_PHP);\n\n    if (options)\n      cupsdSetStringf(&con->options, \" %s %s\", filename, options);\n    else\n      cupsdSetStringf(&con->options, \" %s\", filename);\n\n    cupsdLogClient(con, CUPSD_LOG_DEBUG2, \"is_cgi: filename=\\\"%s\\\", filestats=%p, type=%s/%s, returning 1.\", filename, filestats, type->super, type->type);\n    return (1);\n  }\n#endif /* HAVE_PHP */\n#ifdef HAVE_PYTHON\n  else if (!_cups_strcasecmp(type->type, \"x-httpd-python\"))\n  {\n   /*\n    * \"application/x-httpd-python\" is a Python page.\n    */\n\n    cupsdSetString(&con->command, CUPS_PYTHON);\n\n    if (options)\n      cupsdSetStringf(&con->options, \" %s %s\", filename, options);\n    else\n      cupsdSetStringf(&con->options, \" %s\", filename);\n\n    cupsdLogClient(con, CUPSD_LOG_DEBUG2, \"is_cgi: filename=\\\"%s\\\", filestats=%p, type=%s/%s, returning 1.\", filename, filestats, type->super, type->type);\n    return (1);\n  }\n#endif /* HAVE_PYTHON */\n\n  cupsdLogClient(con, CUPSD_LOG_DEBUG2, \"is_cgi: filename=\\\"%s\\\", filestats=%p, type=%s/%s, returning 0.\", filename, filestats, type->super, type->type);\n  return (0);\n}\n", "target": 0, "idx": 86109}
{"func": " void SoftAVC::drainAllOutputBuffers(bool eos) {\n List<BufferInfo *> &outQueue = getPortQueue(kOutputPortIndex);\n    H264SwDecPicture decodedPicture;\n\n if (mHeadersDecoded) {\n while (!outQueue.empty()\n && H264SWDEC_PIC_RDY == H264SwDecNextPicture(\n\n                     mHandle, &decodedPicture, eos /* flush */)) {\n             int32_t picId = decodedPicture.picId;\n             uint8_t *data = (uint8_t *) decodedPicture.pOutputPicture;\n            drainOneOutputBuffer(picId, data);\n         }\n     }\n \n if (!eos) {\n return;\n }\n\n while (!outQueue.empty()) {\n BufferInfo *outInfo = *outQueue.begin();\n        outQueue.erase(outQueue.begin());\n        OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;\n\n        outHeader->nTimeStamp = 0;\n        outHeader->nFilledLen = 0;\n        outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n\n        outInfo->mOwnedByUs = false;\n        notifyFillBufferDone(outHeader);\n\n        mEOSStatus = OUTPUT_FRAMES_FLUSHED;\n }\n}\n", "target": 1, "idx": 188198}
{"func": "IPV6DefragInOrderSimpleTest(void)\n{\n    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;\n    Packet *reassembled = NULL;\n    int id = 12;\n    int i;\n    int ret = 0;\n \n     DefragInit();\n \n    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n    if (Defrag(NULL, NULL, p1, NULL) != NULL)\n        goto end;\n    if (Defrag(NULL, NULL, p2, NULL) != NULL)\n        goto end;\n    reassembled = Defrag(NULL, NULL, p3, NULL);\n    if (reassembled == NULL)\n        goto end;\n\n    if (IPV6_GET_PLEN(reassembled) != 19)\n        goto end;\n\n    /* 40 bytes in we should find 8 bytes of A. */\n    for (i = 40; i < 40 + 8; i++) {\n        if (GET_PKT_DATA(reassembled)[i] != 'A')\n            goto end;\n    }\n\n    /* 28 bytes in we should find 8 bytes of B. */\n    for (i = 48; i < 48 + 8; i++) {\n        if (GET_PKT_DATA(reassembled)[i] != 'B')\n            goto end;\n    }\n\n    /* And 36 bytes in we should find 3 bytes of C. */\n    for (i = 56; i < 56 + 3; i++) {\n        if (GET_PKT_DATA(reassembled)[i] != 'C')\n            goto end;\n    }\n\n    ret = 1;\nend:\n    if (p1 != NULL)\n        SCFree(p1);\n    if (p2 != NULL)\n        SCFree(p2);\n    if (p3 != NULL)\n        SCFree(p3);\n    if (reassembled != NULL)\n        SCFree(reassembled);\n\n    DefragDestroy();\n    return ret;\n}\n", "target": 1, "idx": 181481}
{"func": "bool HFSIterator::IsDirectory() {\n  return catalog_->current_record()->record_type == kHFSPlusFolderRecord;\n}\n", "target": 0, "idx": 133862}
{"func": "void BluetoothDeviceChromeOS::RequestAuthorization(\n    const dbus::ObjectPath& device_path,\n    const ConfirmationCallback& callback) {\n  callback.Run(CANCELLED);\n}\n", "target": 1, "idx": 184926}
{"func": " FileStream::FileStream(const scoped_refptr<base::TaskRunner>& task_runner)\n    : context_(base::MakeUnique<Context>(task_runner)) {}\n", "target": 1, "idx": 187284}
{"func": "long Segment::DoParseNext(\n    const Cluster*& pResult,\n    long long& pos,\n    long& len)\n{\n    long long total, avail;\n \n    long status = m_pReader->Length(&total, &avail);\n \n    if (status < 0)  //error\n        return status;\n \n    assert((total < 0) || (avail <= total));\n \n    const long long segment_stop = (m_size < 0) ? -1 : m_start + m_size;\n \n \n    long long off_next = 0;\n    long long cluster_size = -1;\n \n    for (;;)\n     {\n        if ((total >= 0) && (pos >= total))\n            return 1;  //EOF\n \n        if ((segment_stop >= 0) && (pos >= segment_stop))\n            return 1;  //EOF\n \n        if ((pos + 1) > avail)\n        {\n            len = 1;\n            return E_BUFFER_NOT_FULL;\n        }\n \n        long long result = GetUIntLength(m_pReader, pos, len);\n \n        if (result < 0)  //error\n            return static_cast<long>(result);\n \n        if (result > 0)  //weird\n            return E_BUFFER_NOT_FULL;\n \n        if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n            return E_FILE_FORMAT_INVALID;\n \n        if ((pos + len) > avail)\n            return E_BUFFER_NOT_FULL;\n \n        const long long idpos = pos;             //absolute\n        const long long idoff = pos - m_start;   //relative\n \n        const long long id = ReadUInt(m_pReader, idpos, len);  //absolute\n \n        if (id < 0)  //error\n            return static_cast<long>(id);\n \n        if (id == 0)  //weird\n            return -1;  //generic error\n \n        pos += len;  //consume ID\n \n \n        if ((pos + 1) > avail)\n        {\n            len = 1;\n            return E_BUFFER_NOT_FULL;\n        }\n \n        result = GetUIntLength(m_pReader, pos, len);\n \n        if (result < 0)  //error\n            return static_cast<long>(result);\n \n        if (result > 0)  //weird\n            return E_BUFFER_NOT_FULL;\n \n        if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n            return E_FILE_FORMAT_INVALID;\n \n        if ((pos + len) > avail)\n            return E_BUFFER_NOT_FULL;\n \n        const long long size = ReadUInt(m_pReader, pos, len);\n \n        if (size < 0)  //error\n            return static_cast<long>(size);\n \n        pos += len;  //consume length of size of element\n \n \n        if (size == 0)  //weird\n            continue;\n \n        const long long unknown_size = (1LL << (7 * len)) - 1;\n \n        if ((segment_stop >= 0) &&\n            (size != unknown_size) &&\n            ((pos + size) > segment_stop))\n        {\n            return E_FILE_FORMAT_INVALID;\n        }\n \n        if (id == 0x0C53BB6B)  //Cues ID\n        {\n            if (size == unknown_size)\n                return E_FILE_FORMAT_INVALID;\n \n            const long long element_stop = pos + size;\n \n            if ((segment_stop >= 0) && (element_stop > segment_stop))\n                return E_FILE_FORMAT_INVALID;\n \n            const long long element_start = idpos;\n            const long long element_size = element_stop - element_start;\n \n            if (m_pCues == NULL)\n            {\n                m_pCues = new Cues(this,\n                                    pos,\n                                    size,\n                                    element_start,\n                                    element_size);\n                assert(m_pCues);  //TODO\n            }\n \n            pos += size;  //consume payload\n            assert((segment_stop < 0) || (pos <= segment_stop));\n \n            continue;\n        }\n \n        if (id != 0x0F43B675)  //not a Cluster ID\n        {\n            if (size == unknown_size)\n                return E_FILE_FORMAT_INVALID;\n \n            pos += size;  //consume payload\n            assert((segment_stop < 0) || (pos <= segment_stop));\n \n            continue;\n        }\n \n#if 0 //this is commented-out to support incremental cluster parsing\n         len = static_cast<long>(size);\n \n         if (element_stop > avail)\n             return E_BUFFER_NOT_FULL;\n #endif\n \n \n        off_next = idoff;\n \n        if (size != unknown_size)\n            cluster_size = size;\n \n         break;\n    }\n \n    assert(off_next > 0);  //have cluster\n \n \n    Cluster** const ii = m_clusters + m_clusterCount;\n    Cluster** i = ii;\n \n    Cluster** const jj = ii + m_clusterPreloadCount;\n    Cluster** j = jj;\n \n    while (i < j)\n    {\n \n        Cluster** const k = i + (j - i) / 2;\n        assert(k < jj);\n \n        const Cluster* const pNext = *k;\n        assert(pNext);\n        assert(pNext->m_index < 0);\n \n        pos = pNext->GetPosition();\n        assert(pos >= 0);\n \n        if (pos < off_next)\n            i = k + 1;\n        else if (pos > off_next)\n            j = k;\n        else\n        {\n            pResult = pNext;\n            return 0;  //success\n        }\n    }\n \n    assert(i == j);\n \n    long long pos_;\n    long len_;\n \n    status = Cluster::HasBlockEntries(this, off_next, pos_, len_);\n \n    if (status < 0)  //error or underflow\n    {\n        pos = pos_;\n        len = len_;\n \n        return status;\n    }\n \n    if (status > 0)  //means \"found at least one block entry\"\n    {\n        Cluster* const pNext = Cluster::Create(this,\n                                                -1,   //preloaded\n                                                off_next);\n        assert(pNext);\n \n        const ptrdiff_t idx_next = i - m_clusters;  //insertion position\n \n        PreloadCluster(pNext, idx_next);\n        assert(m_clusters);\n        assert(idx_next < m_clusterSize);\n        assert(m_clusters[idx_next] == pNext);\n \n        pResult = pNext;\n        return 0;  //success\n    }\n \n \n    if (cluster_size < 0)  //unknown size\n    {\n        const long long payload_pos = pos;  //absolute pos of cluster payload\n \n        for (;;)  //determine cluster size\n        {\n            if ((total >= 0) && (pos >= total))\n                break;\n \n            if ((segment_stop >= 0) && (pos >= segment_stop))\n                break;  //no more clusters\n \n \n            if ((pos + 1) > avail)\n            {\n                len = 1;\n                return E_BUFFER_NOT_FULL;\n            }\n \n            long long result = GetUIntLength(m_pReader, pos, len);\n \n            if (result < 0)  //error\n                return static_cast<long>(result);\n \n            if (result > 0)  //weird\n                return E_BUFFER_NOT_FULL;\n \n            if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n                return E_FILE_FORMAT_INVALID;\n \n            if ((pos + len) > avail)\n                return E_BUFFER_NOT_FULL;\n \n            const long long idpos = pos;\n            const long long id = ReadUInt(m_pReader, idpos, len);\n \n            if (id < 0)  //error (or underflow)\n                return static_cast<long>(id);\n \n \n            if (id == 0x0F43B675)  //Cluster ID\n                break;\n \n            if (id == 0x0C53BB6B)  //Cues ID\n                break;\n            pos += len;  //consume ID (of sub-element)\n            if ((pos + 1) > avail)\n            {\n                len = 1;\n                return E_BUFFER_NOT_FULL;\n            }\n            result = GetUIntLength(m_pReader, pos, len);\n            if (result < 0)  //error\n                return static_cast<long>(result);\n            if (result > 0)  //weird\n                return E_BUFFER_NOT_FULL;\n            if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n                return E_FILE_FORMAT_INVALID;\n            if ((pos + len) > avail)\n                return E_BUFFER_NOT_FULL;\n            const long long size = ReadUInt(m_pReader, pos, len);\n            if (size < 0)  //error\n                return static_cast<long>(size);\n            pos += len;  //consume size field of element\n            if (size == 0)  //weird\n                continue;\n            const long long unknown_size = (1LL << (7 * len)) - 1;\n            if (size == unknown_size)\n                return E_FILE_FORMAT_INVALID;  //not allowed for sub-elements\n            if ((segment_stop >= 0) && ((pos + size) > segment_stop))  //weird\n                return E_FILE_FORMAT_INVALID;\n            pos += size;  //consume payload of sub-element\n            assert((segment_stop < 0) || (pos <= segment_stop));\n        }  //determine cluster size\n        cluster_size = pos - payload_pos;\n        assert(cluster_size >= 0);  //TODO: handle cluster_size = 0\n        pos = payload_pos;  //reset and re-parse original cluster\n    }\n    pos += cluster_size;  //consume payload\n    assert((segment_stop < 0) || (pos <= segment_stop));\n    return 2;             //try to find a cluster that follows next\n }\n", "target": 1, "idx": 188288}
{"func": "ipt_do_table(struct sk_buff *skb,\n\t     const struct nf_hook_state *state,\n\t     struct xt_table *table)\n{\n\tunsigned int hook = state->hook;\n\tstatic const char nulldevname[IFNAMSIZ] __attribute__((aligned(sizeof(long))));\n\tconst struct iphdr *ip;\n\t/* Initializing verdict to NF_DROP keeps gcc happy. */\n\tunsigned int verdict = NF_DROP;\n\tconst char *indev, *outdev;\n\tconst void *table_base;\n\tstruct ipt_entry *e, **jumpstack;\n\tunsigned int stackidx, cpu;\n\tconst struct xt_table_info *private;\n\tstruct xt_action_param acpar;\n\tunsigned int addend;\n\n\t/* Initialization */\n\tstackidx = 0;\n\tip = ip_hdr(skb);\n\tindev = state->in ? state->in->name : nulldevname;\n\toutdev = state->out ? state->out->name : nulldevname;\n\t/* We handle fragments by dealing with the first fragment as\n\t * if it was a normal packet.  All other fragments are treated\n\t * normally, except that they will NEVER match rules that ask\n\t * things we don't know, ie. tcp syn flag or ports).  If the\n\t * rule is also a fragment-specific rule, non-fragments won't\n\t * match it. */\n\tacpar.fragoff = ntohs(ip->frag_off) & IP_OFFSET;\n\tacpar.thoff   = ip_hdrlen(skb);\n\tacpar.hotdrop = false;\n\tacpar.state   = state;\n\n\tWARN_ON(!(table->valid_hooks & (1 << hook)));\n\tlocal_bh_disable();\n\taddend = xt_write_recseq_begin();\n\tprivate = READ_ONCE(table->private); /* Address dependency. */\n\tcpu        = smp_processor_id();\n\ttable_base = private->entries;\n\tjumpstack  = (struct ipt_entry **)private->jumpstack[cpu];\n\n\t/* Switch to alternate jumpstack if we're being invoked via TEE.\n\t * TEE issues XT_CONTINUE verdict on original skb so we must not\n\t * clobber the jumpstack.\n\t *\n\t * For recursion via REJECT or SYNPROXY the stack will be clobbered\n\t * but it is no problem since absolute verdict is issued by these.\n\t */\n\tif (static_key_false(&xt_tee_enabled))\n\t\tjumpstack += private->stacksize * __this_cpu_read(nf_skb_duplicated);\n\n\te = get_entry(table_base, private->hook_entry[hook]);\n\n\tdo {\n\t\tconst struct xt_entry_target *t;\n\t\tconst struct xt_entry_match *ematch;\n\t\tstruct xt_counters *counter;\n\n\t\tWARN_ON(!e);\n\t\tif (!ip_packet_match(ip, indev, outdev,\n\t\t    &e->ip, acpar.fragoff)) {\n no_match:\n\t\t\te = ipt_next_entry(e);\n\t\t\tcontinue;\n\t\t}\n\n\t\txt_ematch_foreach(ematch, e) {\n\t\t\tacpar.match     = ematch->u.kernel.match;\n\t\t\tacpar.matchinfo = ematch->data;\n\t\t\tif (!acpar.match->match(skb, &acpar))\n\t\t\t\tgoto no_match;\n\t\t}\n\n\t\tcounter = xt_get_this_cpu_counter(&e->counters);\n\t\tADD_COUNTER(*counter, skb->len, 1);\n\n\t\tt = ipt_get_target(e);\n\t\tWARN_ON(!t->u.kernel.target);\n\n#if IS_ENABLED(CONFIG_NETFILTER_XT_TARGET_TRACE)\n\t\t/* The packet is traced: log it */\n\t\tif (unlikely(skb->nf_trace))\n\t\t\ttrace_packet(state->net, skb, hook, state->in,\n\t\t\t\t     state->out, table->name, private, e);\n#endif\n\t\t/* Standard target? */\n\t\tif (!t->u.kernel.target->target) {\n\t\t\tint v;\n\n\t\t\tv = ((struct xt_standard_target *)t)->verdict;\n\t\t\tif (v < 0) {\n\t\t\t\t/* Pop from stack? */\n\t\t\t\tif (v != XT_RETURN) {\n\t\t\t\t\tverdict = (unsigned int)(-v) - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (stackidx == 0) {\n\t\t\t\t\te = get_entry(table_base,\n\t\t\t\t\t    private->underflow[hook]);\n\t\t\t\t} else {\n\t\t\t\t\te = jumpstack[--stackidx];\n\t\t\t\t\te = ipt_next_entry(e);\n\t\t\t\t}\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\tif (table_base + v != ipt_next_entry(e) &&\n\t\t\t    !(e->ip.flags & IPT_F_GOTO))\n \t\t\t\tjumpstack[stackidx++] = e;\n \n \t\t\te = get_entry(table_base, v);\n \t\t\tcontinue;\n\t\t}\n\n\t\tacpar.target   = t->u.kernel.target;\n\t\tacpar.targinfo = t->data;\n\n\t\tverdict = t->u.kernel.target->target(skb, &acpar);\n\t\tif (verdict == XT_CONTINUE) {\n\t\t\t/* Target might have changed stuff. */\n\t\t\tip = ip_hdr(skb);\n\t\t\te = ipt_next_entry(e);\n\t\t} else {\n\t\t\t/* Verdict */\n\t\t\tbreak;\n\t\t}\n\t} while (!acpar.hotdrop);\n\n\txt_write_recseq_end(addend);\n\tlocal_bh_enable();\n\n\tif (acpar.hotdrop)\n\t\treturn NF_DROP;\n\telse return verdict;\n}\n", "target": 1, "idx": 182535}
{"func": "static Image *ReadOneMNGImage(MngInfo* mng_info, const ImageInfo *image_info,\n     ExceptionInfo *exception)\n{\n  char\n    page_geometry[MaxTextExtent];\n\n  Image\n    *image;\n\n  MagickBooleanType\n    logging;\n\n  volatile int\n    first_mng_object,\n    object_id,\n    term_chunk_found,\n    skip_to_iend;\n\n  volatile ssize_t\n    image_count=0;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  MngBox\n    default_fb,\n    fb,\n    previous_fb;\n\n#if defined(MNG_INSERT_LAYERS)\n  PixelPacket\n    mng_background_color;\n#endif\n\n  register unsigned char\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    count;\n\n  ssize_t\n    loop_level;\n\n  volatile short\n    skipping_loop;\n\n#if defined(MNG_INSERT_LAYERS)\n  unsigned int\n    mandatory_back=0;\n#endif\n\n  volatile unsigned int\n#ifdef MNG_OBJECT_BUFFERS\n    mng_background_object=0,\n#endif\n    mng_type=0;   /* 0: PNG or JNG; 1: MNG; 2: MNG-LC; 3: MNG-VLC */\n\n  size_t\n    default_frame_timeout,\n    frame_timeout,\n#if defined(MNG_INSERT_LAYERS)\n    image_height,\n    image_width,\n#endif\n    length;\n\n  /* These delays are all measured in image ticks_per_second,\n   * not in MNG ticks_per_second\n   */\n  volatile size_t\n    default_frame_delay,\n    final_delay,\n    final_image_delay,\n    frame_delay,\n#if defined(MNG_INSERT_LAYERS)\n    insert_layers,\n#endif\n    mng_iterations=1,\n    simplicity=0,\n    subframe_height=0,\n    subframe_width=0;\n\n  previous_fb.top=0;\n  previous_fb.bottom=0;\n  previous_fb.left=0;\n  previous_fb.right=0;\n  default_fb.top=0;\n  default_fb.bottom=0;\n  default_fb.left=0;\n  default_fb.right=0;\n\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  Enter ReadOneMNGImage()\");\n\n  image=mng_info->image;\n\n  if (LocaleCompare(image_info->magick,\"MNG\") == 0)\n    {\n      char\n        magic_number[MaxTextExtent];\n\n      /* Verify MNG signature.  */\n      count=(size_t) ReadBlob(image,8,(unsigned char *) magic_number);\n      if (memcmp(magic_number,\"\\212MNG\\r\\n\\032\\n\",8) != 0)\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n      /* Initialize some nonzero members of the MngInfo structure.  */\n      for (i=0; i < MNG_MAX_OBJECTS; i++)\n      {\n        mng_info->object_clip[i].right=(ssize_t) PNG_UINT_31_MAX;\n        mng_info->object_clip[i].bottom=(ssize_t) PNG_UINT_31_MAX;\n      }\n      mng_info->exists[0]=MagickTrue;\n    }\n\n  skipping_loop=(-1);\n  first_mng_object=MagickTrue;\n  mng_type=0;\n#if defined(MNG_INSERT_LAYERS)\n  insert_layers=MagickFalse; /* should be False when converting or mogrifying */\n#endif\n  default_frame_delay=0;\n  default_frame_timeout=0;\n  frame_delay=0;\n  final_delay=1;\n  mng_info->ticks_per_second=1UL*image->ticks_per_second;\n  object_id=0;\n  skip_to_iend=MagickFalse;\n  term_chunk_found=MagickFalse;\n  mng_info->framing_mode=1;\n#if defined(MNG_INSERT_LAYERS)\n  mandatory_back=MagickFalse;\n#endif\n#if defined(MNG_INSERT_LAYERS)\n  mng_background_color=image->background_color;\n#endif\n  default_fb=mng_info->frame;\n  previous_fb=mng_info->frame;\n  do\n  {\n    char\n      type[MaxTextExtent];\n\n    if (LocaleCompare(image_info->magick,\"MNG\") == 0)\n      {\n        unsigned char\n          *chunk;\n\n        /*\n          Read a new chunk.\n        */\n        type[0]='\\0';\n        (void) ConcatenateMagickString(type,\"errr\",MaxTextExtent);\n        length=ReadBlobMSBLong(image);\n        count=(size_t) ReadBlob(image,4,(unsigned char *) type);\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"  Reading MNG chunk type %c%c%c%c, length: %.20g\",\n           type[0],type[1],type[2],type[3],(double) length);\n\n        if (length > PNG_UINT_31_MAX)\n          {\n            status=MagickFalse;\n            break;\n          }\n\n        if (count == 0)\n          ThrowReaderException(CorruptImageError,\"CorruptImage\");\n\n        p=NULL;\n        chunk=(unsigned char *) NULL;\n\n        if (length != 0)\n          {\n            if (length > GetBlobSize(image))\n              ThrowReaderException(CorruptImageError,\n                \"InsufficientImageDataInFile\");\n            chunk=(unsigned char *) AcquireQuantumMemory(length+\n              MagickPathExtent,sizeof(*chunk));\n\n            if (chunk == (unsigned char *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n            for (i=0; i < (ssize_t) length; i++)\n            {\n              int\n                c;\n\n              c=ReadBlobByte(image);\n              if (c == EOF)\n                break;\n              chunk[i]=(unsigned char) c;\n            }\n\n            p=chunk;\n          }\n\n        (void) ReadBlobMSBLong(image);  /* read crc word */\n\n#if !defined(JNG_SUPPORTED)\n        if (memcmp(type,mng_JHDR,4) == 0)\n          {\n            skip_to_iend=MagickTrue;\n\n            if (mng_info->jhdr_warning == 0)\n              (void) ThrowMagickException(&image->exception,GetMagickModule(),\n                CoderError,\"JNGCompressNotSupported\",\"`%s'\",image->filename);\n\n            mng_info->jhdr_warning++;\n          }\n#endif\n        if (memcmp(type,mng_DHDR,4) == 0)\n          {\n            skip_to_iend=MagickTrue;\n\n            if (mng_info->dhdr_warning == 0)\n              (void) ThrowMagickException(&image->exception,GetMagickModule(),\n                CoderError,\"DeltaPNGNotSupported\",\"`%s'\",image->filename);\n\n            mng_info->dhdr_warning++;\n          }\n        if (memcmp(type,mng_MEND,4) == 0)\n          break;\n\n        if (skip_to_iend)\n          {\n            if (memcmp(type,mng_IEND,4) == 0)\n              skip_to_iend=MagickFalse;\n\n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Skip to IEND.\");\n\n            continue;\n          }\n\n        if (memcmp(type,mng_MHDR,4) == 0)\n          {\n            if (length != 28)\n              {\n                chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                ThrowReaderException(CorruptImageError,\"CorruptImage\");\n              }\n\n            mng_info->mng_width=(size_t) ((p[0] << 24) | (p[1] << 16) |\n                (p[2] << 8) | p[3]);\n\n            mng_info->mng_height=(size_t) ((p[4] << 24) | (p[5] << 16) |\n                (p[6] << 8) | p[7]);\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  MNG width: %.20g\",(double) mng_info->mng_width);\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  MNG height: %.20g\",(double) mng_info->mng_height);\n              }\n\n            p+=8;\n            mng_info->ticks_per_second=(size_t) mng_get_long(p);\n\n            if (mng_info->ticks_per_second == 0)\n              default_frame_delay=0;\n\n            else\n              default_frame_delay=1UL*image->ticks_per_second/\n                mng_info->ticks_per_second;\n\n            frame_delay=default_frame_delay;\n            simplicity=0;\n\n            /* Skip nominal layer count, frame count, and play time */\n            p+=16;\n            simplicity=(size_t) mng_get_long(p);\n\n            mng_type=1;    /* Full MNG */\n\n            if ((simplicity != 0) && ((simplicity | 11) == 11))\n              mng_type=2; /* LC */\n\n            if ((simplicity != 0) && ((simplicity | 9) == 9))\n              mng_type=3; /* VLC */\n\n#if defined(MNG_INSERT_LAYERS)\n            if (mng_type != 3)\n              insert_layers=MagickTrue;\n#endif\n            if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL)\n              {\n                /* Allocate next image structure.  */\n                AcquireNextImage(image_info,image);\n\n                if (GetNextImageInList(image) == (Image *) NULL)\n                  return(DestroyImageList(image));\n\n                image=SyncNextImageInList(image);\n                mng_info->image=image;\n              }\n\n            if ((mng_info->mng_width > 65535L) ||\n                (mng_info->mng_height > 65535L))\n              {\n                chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                ThrowReaderException(ImageError,\"WidthOrHeightExceedsLimit\");\n              }\n\n            (void) FormatLocaleString(page_geometry,MaxTextExtent,\n              \"%.20gx%.20g+0+0\",(double) mng_info->mng_width,(double)\n              mng_info->mng_height);\n\n            mng_info->frame.left=0;\n            mng_info->frame.right=(ssize_t) mng_info->mng_width;\n            mng_info->frame.top=0;\n            mng_info->frame.bottom=(ssize_t) mng_info->mng_height;\n            mng_info->clip=default_fb=previous_fb=mng_info->frame;\n\n            for (i=0; i < MNG_MAX_OBJECTS; i++)\n              mng_info->object_clip[i]=mng_info->frame;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_TERM,4) == 0)\n          {\n            int\n              repeat=0;\n\n            if (length != 0)\n              repeat=p[0];\n\n            if (repeat == 3 && length > 8)\n              {\n                final_delay=(png_uint_32) mng_get_long(&p[2]);\n                mng_iterations=(png_uint_32) mng_get_long(&p[6]);\n\n                if (mng_iterations == PNG_UINT_31_MAX)\n                  mng_iterations=0;\n\n                image->iterations=mng_iterations;\n                term_chunk_found=MagickTrue;\n              }\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    repeat=%d,  final_delay=%.20g,  iterations=%.20g\",\n                  repeat,(double) final_delay, (double) image->iterations);\n              }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_DEFI,4) == 0)\n          {\n            if (mng_type == 3)\n              (void) ThrowMagickException(&image->exception,GetMagickModule(),\n                CoderError,\"DEFI chunk found in MNG-VLC datastream\",\"`%s'\",\n                image->filename);\n\n            if (length > 1)\n              {\n                object_id=(p[0] << 8) | p[1];\n\n                if (mng_type == 2 && object_id != 0)\n                  (void) ThrowMagickException(&image->exception,\n                     GetMagickModule(),\n                     CoderError,\"Nonzero object_id in MNG-LC datastream\",\n                     \"`%s'\", image->filename);\n\n                if (object_id > MNG_MAX_OBJECTS)\n                  {\n                    /*\n                      Instead of using a warning we should allocate a larger\n                      MngInfo structure and continue.\n                    */\n                    (void) ThrowMagickException(&image->exception,\n                        GetMagickModule(), CoderError,\n                        \"object id too large\",\"`%s'\",image->filename);\n                        object_id=MNG_MAX_OBJECTS;\n                  }\n\n                if (mng_info->exists[object_id])\n                  if (mng_info->frozen[object_id])\n                    {\n                      chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                      (void) ThrowMagickException(&image->exception,\n                        GetMagickModule(),CoderError,\n                        \"DEFI cannot redefine a frozen MNG object\",\"`%s'\",\n                        image->filename);\n                      continue;\n                    }\n\n                mng_info->exists[object_id]=MagickTrue;\n\n                if (length > 2)\n                  mng_info->invisible[object_id]=p[2];\n\n                /*\n                  Extract object offset info.\n                */\n                if (length > 11)\n                  {\n                    mng_info->x_off[object_id]=(ssize_t) ((p[4] << 24) |\n                        (p[5] << 16) | (p[6] << 8) | p[7]);\n\n                    mng_info->y_off[object_id]=(ssize_t) ((p[8] << 24) |\n                        (p[9] << 16) | (p[10] << 8) | p[11]);\n\n                    if (logging != MagickFalse)\n                      {\n                        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                          \"  x_off[%d]: %.20g,  y_off[%d]: %.20g\",\n                          object_id,(double) mng_info->x_off[object_id],\n                          object_id,(double) mng_info->y_off[object_id]);\n                      }\n                  }\n\n                /*\n                  Extract object clipping info.\n                */\n            \n                if (length > 27)\n                  mng_info->object_clip[object_id]=\n                    mng_read_box(mng_info->frame,0, &p[12]);\n            }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_bKGD,4) == 0)\n          {\n            mng_info->have_global_bkgd=MagickFalse;\n\n            if (length > 5)\n              {\n                mng_info->mng_global_bkgd.red=\n                  ScaleShortToQuantum((unsigned short) ((p[0] << 8) | p[1]));\n\n                mng_info->mng_global_bkgd.green=\n                  ScaleShortToQuantum((unsigned short) ((p[2] << 8) | p[3]));\n\n                mng_info->mng_global_bkgd.blue=\n                  ScaleShortToQuantum((unsigned short) ((p[4] << 8) | p[5]));\n\n                mng_info->have_global_bkgd=MagickTrue;\n              }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_BACK,4) == 0)\n          {\n#if defined(MNG_INSERT_LAYERS)\n            if (length > 6)\n              mandatory_back=p[6];\n\n            else\n              mandatory_back=0;\n\n            if (mandatory_back && length > 5)\n              {\n                mng_background_color.red=\n                    ScaleShortToQuantum((unsigned short) ((p[0] << 8) | p[1]));\n\n                mng_background_color.green=\n                    ScaleShortToQuantum((unsigned short) ((p[2] << 8) | p[3]));\n\n                mng_background_color.blue=\n                    ScaleShortToQuantum((unsigned short) ((p[4] << 8) | p[5]));\n\n                mng_background_color.opacity=OpaqueOpacity;\n              }\n\n#ifdef MNG_OBJECT_BUFFERS\n            if (length > 8)\n              mng_background_object=(p[7] << 8) | p[8];\n#endif\n#endif\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_PLTE,4) == 0)\n          {\n            /* Read global PLTE.  */\n\n            if (length && (length < 769))\n              {\n                if (mng_info->global_plte == (png_colorp) NULL)\n                  mng_info->global_plte=(png_colorp) AcquireQuantumMemory(256,\n                    sizeof(*mng_info->global_plte));\n\n                for (i=0; i < (ssize_t) (length/3); i++)\n                {\n                  mng_info->global_plte[i].red=p[3*i];\n                  mng_info->global_plte[i].green=p[3*i+1];\n                  mng_info->global_plte[i].blue=p[3*i+2];\n                }\n\n                mng_info->global_plte_length=(unsigned int) (length/3);\n              }\n#ifdef MNG_LOOSE\n            for ( ; i < 256; i++)\n            {\n              mng_info->global_plte[i].red=i;\n              mng_info->global_plte[i].green=i;\n              mng_info->global_plte[i].blue=i;\n            }\n\n            if (length != 0)\n              mng_info->global_plte_length=256;\n#endif\n            else\n              mng_info->global_plte_length=0;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_tRNS,4) == 0)\n          {\n            /* read global tRNS */\n\n            if (length > 0 && length < 257)\n              for (i=0; i < (ssize_t) length; i++)\n                mng_info->global_trns[i]=p[i];\n\n#ifdef MNG_LOOSE\n            for ( ; i < 256; i++)\n              mng_info->global_trns[i]=255;\n#endif\n            mng_info->global_trns_length=(unsigned int) length;\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_gAMA,4) == 0)\n          {\n            if (length == 4)\n              {\n                ssize_t\n                  igamma;\n\n                igamma=mng_get_long(p);\n                mng_info->global_gamma=((float) igamma)*0.00001;\n                mng_info->have_global_gama=MagickTrue;\n              }\n\n            else\n              mng_info->have_global_gama=MagickFalse;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_cHRM,4) == 0)\n          {\n            /* Read global cHRM */\n\n            if (length == 32)\n              {\n                mng_info->global_chrm.white_point.x=0.00001*mng_get_long(p);\n                mng_info->global_chrm.white_point.y=0.00001*mng_get_long(&p[4]);\n                mng_info->global_chrm.red_primary.x=0.00001*mng_get_long(&p[8]);\n                mng_info->global_chrm.red_primary.y=0.00001*\n                  mng_get_long(&p[12]);\n                mng_info->global_chrm.green_primary.x=0.00001*\n                  mng_get_long(&p[16]);\n                mng_info->global_chrm.green_primary.y=0.00001*\n                  mng_get_long(&p[20]);\n                mng_info->global_chrm.blue_primary.x=0.00001*\n                  mng_get_long(&p[24]);\n                mng_info->global_chrm.blue_primary.y=0.00001*\n                  mng_get_long(&p[28]);\n                mng_info->have_global_chrm=MagickTrue;\n              }\n            else\n              mng_info->have_global_chrm=MagickFalse;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_sRGB,4) == 0)\n          {\n            /*\n              Read global sRGB.\n            */\n            if (length != 0)\n              {\n                mng_info->global_srgb_intent=\n                  Magick_RenderingIntent_from_PNG_RenderingIntent(p[0]);\n                mng_info->have_global_srgb=MagickTrue;\n              }\n            else\n              mng_info->have_global_srgb=MagickFalse;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_iCCP,4) == 0)\n          {\n            /* To do: */\n\n            /*\n              Read global iCCP.\n            */\n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            continue;\n          }\n\n        if (memcmp(type,mng_FRAM,4) == 0)\n          {\n            if (mng_type == 3)\n              (void) ThrowMagickException(&image->exception,GetMagickModule(),\n                CoderError,\"FRAM chunk found in MNG-VLC datastream\",\"`%s'\",\n                image->filename);\n\n            if ((mng_info->framing_mode == 2) || (mng_info->framing_mode == 4))\n              image->delay=frame_delay;\n\n            frame_delay=default_frame_delay;\n            frame_timeout=default_frame_timeout;\n            fb=default_fb;\n\n            if (length > 0)\n              if (p[0])\n                mng_info->framing_mode=p[0];\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Framing_mode=%d\",mng_info->framing_mode);\n\n            if (length > 6)\n              {\n                /* Note the delay and frame clipping boundaries.  */\n\n                p++; /* framing mode */\n\n                while (*p && ((p-chunk) < (ssize_t) length))\n                  p++;  /* frame name */\n\n                p++;  /* frame name terminator */\n\n                if ((p-chunk) < (ssize_t) (length-4))\n                  {\n                    int\n                      change_delay,\n                      change_timeout,\n                      change_clipping;\n\n                    change_delay=(*p++);\n                    change_timeout=(*p++);\n                    change_clipping=(*p++);\n                    p++; /* change_sync */\n\n                    if (change_delay && (p-chunk) < (ssize_t) (length-4))\n                      {\n                          frame_delay=1UL*image->ticks_per_second*\n                            mng_get_long(p);\n\n                        if (mng_info->ticks_per_second != 0)\n                          frame_delay/=mng_info->ticks_per_second;\n\n                        else\n                          frame_delay=PNG_UINT_31_MAX;\n\n                        if (change_delay == 2)\n                          default_frame_delay=frame_delay;\n\n                        p+=4;\n\n                        if (logging != MagickFalse)\n                          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                            \"    Framing_delay=%.20g\",(double) frame_delay);\n                      }\n\n                    if (change_timeout && (p-chunk) < (ssize_t) (length-4))\n                      {\n                        frame_timeout=1UL*image->ticks_per_second*\n                          mng_get_long(p);\n\n                        if (mng_info->ticks_per_second != 0)\n                          frame_timeout/=mng_info->ticks_per_second;\n\n                        else\n                          frame_timeout=PNG_UINT_31_MAX;\n\n                        if (change_timeout == 2)\n                          default_frame_timeout=frame_timeout;\n\n                        p+=4;\n\n                        if (logging != MagickFalse)\n                          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                            \"    Framing_timeout=%.20g\",(double) frame_timeout);\n                      }\n\n                    if (change_clipping && (p-chunk) < (ssize_t) (length-17))\n                      {\n                        fb=mng_read_box(previous_fb,(char) p[0],&p[1]);\n                        p+=17;\n                        previous_fb=fb;\n\n                        if (logging != MagickFalse)\n                          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                            \"    Frame_clip: L=%.20g R=%.20g T=%.20g B=%.20g\",\n                            (double) fb.left,(double) fb.right,(double) fb.top,\n                            (double) fb.bottom);\n\n                        if (change_clipping == 2)\n                          default_fb=fb;\n                      }\n                  }\n              }\n            mng_info->clip=fb;\n            mng_info->clip=mng_minimum_box(fb,mng_info->frame);\n\n            subframe_width=(size_t) (mng_info->clip.right\n               -mng_info->clip.left);\n\n            subframe_height=(size_t) (mng_info->clip.bottom\n               -mng_info->clip.top);\n            /*\n              Insert a background layer behind the frame if framing_mode is 4.\n            */\n#if defined(MNG_INSERT_LAYERS)\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"   subframe_width=%.20g, subframe_height=%.20g\",(double)\n                subframe_width,(double) subframe_height);\n\n            if (insert_layers && (mng_info->framing_mode == 4) &&\n                (subframe_width) && (subframe_height))\n              {\n                /* Allocate next image structure.  */\n                if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL)\n                  {\n                    AcquireNextImage(image_info,image);\n\n                    if (GetNextImageInList(image) == (Image *) NULL)\n                      return(DestroyImageList(image));\n\n                    image=SyncNextImageInList(image);\n                  }\n\n                mng_info->image=image;\n\n                if (term_chunk_found)\n                  {\n                    image->start_loop=MagickTrue;\n                    image->iterations=mng_iterations;\n                    term_chunk_found=MagickFalse;\n                  }\n\n                else\n                    image->start_loop=MagickFalse;\n\n                image->columns=subframe_width;\n                image->rows=subframe_height;\n                image->page.width=subframe_width;\n                image->page.height=subframe_height;\n                image->page.x=mng_info->clip.left;\n                image->page.y=mng_info->clip.top;\n                image->background_color=mng_background_color;\n                image->matte=MagickFalse;\n                image->delay=0;\n                (void) SetImageBackgroundColor(image);\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  Insert backgd layer, L=%.20g, R=%.20g T=%.20g, B=%.20g\",\n                    (double) mng_info->clip.left,(double) mng_info->clip.right,\n                    (double) mng_info->clip.top,(double) mng_info->clip.bottom);\n              }\n#endif\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_CLIP,4) == 0)\n          {\n            unsigned int\n              first_object,\n              last_object;\n\n            /*\n              Read CLIP.\n            */\n            if (length > 3)\n              {\n                first_object=(p[0] << 8) | p[1];\n                last_object=(p[2] << 8) | p[3];\n                p+=4;\n \n                 for (i=(int) first_object; i <= (int) last_object; i++)\n                 {\n                   if (mng_info->exists[i] && !mng_info->frozen[i])\n                     {\n                       MngBox\n                        box;\n\n                      box=mng_info->object_clip[i];\n                      if ((p-chunk) < (ssize_t) (length-17))\n                        mng_info->object_clip[i]=\n                           mng_read_box(box,(char) p[0],&p[1]);\n                    }\n                }\n\n              }\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_SAVE,4) == 0)\n          {\n            for (i=1; i < MNG_MAX_OBJECTS; i++)\n              if (mng_info->exists[i])\n                {\n                 mng_info->frozen[i]=MagickTrue;\n#ifdef MNG_OBJECT_BUFFERS\n                 if (mng_info->ob[i] != (MngBuffer *) NULL)\n                    mng_info->ob[i]->frozen=MagickTrue;\n#endif\n                }\n\n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            continue;\n          }\n\n        if ((memcmp(type,mng_DISC,4) == 0) || (memcmp(type,mng_SEEK,4) == 0))\n          {\n            /* Read DISC or SEEK.  */\n\n            if ((length == 0) || !memcmp(type,mng_SEEK,4))\n              {\n                for (i=1; i < MNG_MAX_OBJECTS; i++)\n                  MngInfoDiscardObject(mng_info,i);\n              }\n\n            else\n              {\n                register ssize_t\n                  j;\n\n                for (j=1; j < (ssize_t) length; j+=2)\n                {\n                  i=p[j-1] << 8 | p[j];\n                  MngInfoDiscardObject(mng_info,i);\n                }\n              }\n\n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            continue;\n          }\n\n        if (memcmp(type,mng_MOVE,4) == 0)\n          {\n            size_t\n              first_object,\n              last_object;\n\n            /* read MOVE */\n\n            if (length > 3)\n            {\n              first_object=(p[0] << 8) | p[1];\n              last_object=(p[2] << 8) | p[3];\n              p+=4;\n\n              for (i=(ssize_t) first_object; i <= (ssize_t) last_object; i++)\n              {\n                if ((i < 0) || (i >= MNG_MAX_OBJECTS))\n                  continue;\n                if (mng_info->exists[i] && !mng_info->frozen[i] &&\n                    (p-chunk) < (ssize_t) (length-8))\n                  {\n                    MngPair\n                      new_pair;\n\n                    MngPair\n                      old_pair;\n\n                    old_pair.a=mng_info->x_off[i];\n                    old_pair.b=mng_info->y_off[i];\n                    new_pair=mng_read_pair(old_pair,(int) p[0],&p[1]);\n                    mng_info->x_off[i]=new_pair.a;\n                    mng_info->y_off[i]=new_pair.b;\n                  }\n              }\n            }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_LOOP,4) == 0)\n          {\n            ssize_t loop_iters=1;\n            if (length > 4)\n              {\n                loop_level=chunk[0];\n                mng_info->loop_active[loop_level]=1;  /* mark loop active */\n\n                /* Record starting point.  */\n                loop_iters=mng_get_long(&chunk[1]);\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  LOOP level %.20g has %.20g iterations \",\n                    (double) loop_level, (double) loop_iters);\n\n                if (loop_iters == 0)\n                  skipping_loop=loop_level;\n\n                else\n                  {\n                    mng_info->loop_jump[loop_level]=TellBlob(image);\n                    mng_info->loop_count[loop_level]=loop_iters;\n                  }\n\n                mng_info->loop_iteration[loop_level]=0;\n              }\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_ENDL,4) == 0)\n          {\n            if (length > 0)\n              {\n                loop_level=chunk[0];\n\n                if (skipping_loop > 0)\n                  {\n                    if (skipping_loop == loop_level)\n                      {\n                        /*\n                          Found end of zero-iteration loop.\n                        */\n                        skipping_loop=(-1);\n                        mng_info->loop_active[loop_level]=0;\n                      }\n                  }\n\n                else\n                  {\n                    if (mng_info->loop_active[loop_level] == 1)\n                      {\n                        mng_info->loop_count[loop_level]--;\n                        mng_info->loop_iteration[loop_level]++;\n\n                        if (logging != MagickFalse)\n                          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                          \"  ENDL: LOOP level %.20g has %.20g remaining iters \",\n                            (double) loop_level,(double)\n                            mng_info->loop_count[loop_level]);\n\n                        if (mng_info->loop_count[loop_level] != 0)\n                          {\n                            offset=SeekBlob(image,\n                              mng_info->loop_jump[loop_level], SEEK_SET);\n\n                            if (offset < 0)\n                              {\n                                chunk=(unsigned char *) RelinquishMagickMemory(\n                                  chunk);\n                                ThrowReaderException(CorruptImageError,\n                                  \"ImproperImageHeader\");\n                              }\n                          }\n\n                        else\n                          {\n                            short\n                              last_level;\n\n                            /*\n                              Finished loop.\n                            */\n                            mng_info->loop_active[loop_level]=0;\n                            last_level=(-1);\n                            for (i=0; i < loop_level; i++)\n                              if (mng_info->loop_active[i] == 1)\n                                last_level=(short) i;\n                            loop_level=last_level;\n                          }\n                      }\n                  }\n              }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_CLON,4) == 0)\n          {\n            if (mng_info->clon_warning == 0)\n              (void) ThrowMagickException(&image->exception,GetMagickModule(),\n                CoderError,\"CLON is not implemented yet\",\"`%s'\",\n                image->filename);\n\n            mng_info->clon_warning++;\n          }\n\n        if (memcmp(type,mng_MAGN,4) == 0)\n          {\n            png_uint_16\n              magn_first,\n              magn_last,\n              magn_mb,\n              magn_ml,\n              magn_mr,\n              magn_mt,\n              magn_mx,\n              magn_my,\n              magn_methx,\n              magn_methy;\n\n            if (length > 1)\n              magn_first=(p[0] << 8) | p[1];\n\n            else\n              magn_first=0;\n\n            if (length > 3)\n              magn_last=(p[2] << 8) | p[3];\n\n            else\n              magn_last=magn_first;\n#ifndef MNG_OBJECT_BUFFERS\n            if (magn_first || magn_last)\n              if (mng_info->magn_warning == 0)\n                {\n                  (void) ThrowMagickException(&image->exception,\n                     GetMagickModule(),CoderError,\n                     \"MAGN is not implemented yet for nonzero objects\",\n                     \"`%s'\",image->filename);\n\n                   mng_info->magn_warning++;\n                }\n#endif\n            if (length > 4)\n              magn_methx=p[4];\n\n            else\n              magn_methx=0;\n\n            if (length > 6)\n              magn_mx=(p[5] << 8) | p[6];\n\n            else\n              magn_mx=1;\n\n            if (magn_mx == 0)\n              magn_mx=1;\n\n            if (length > 8)\n              magn_my=(p[7] << 8) | p[8];\n\n            else\n              magn_my=magn_mx;\n\n            if (magn_my == 0)\n              magn_my=1;\n\n            if (length > 10)\n              magn_ml=(p[9] << 8) | p[10];\n\n            else\n              magn_ml=magn_mx;\n\n            if (magn_ml == 0)\n              magn_ml=1;\n\n            if (length > 12)\n              magn_mr=(p[11] << 8) | p[12];\n\n            else\n              magn_mr=magn_mx;\n\n            if (magn_mr == 0)\n              magn_mr=1;\n\n            if (length > 14)\n              magn_mt=(p[13] << 8) | p[14];\n\n            else\n              magn_mt=magn_my;\n\n            if (magn_mt == 0)\n              magn_mt=1;\n\n            if (length > 16)\n              magn_mb=(p[15] << 8) | p[16];\n\n            else\n              magn_mb=magn_my;\n\n            if (magn_mb == 0)\n              magn_mb=1;\n\n            if (length > 17)\n              magn_methy=p[17];\n\n            else\n              magn_methy=magn_methx;\n\n\n            if (magn_methx > 5 || magn_methy > 5)\n              if (mng_info->magn_warning == 0)\n                {\n                  (void) ThrowMagickException(&image->exception,\n                     GetMagickModule(),CoderError,\n                     \"Unknown MAGN method in MNG datastream\",\"`%s'\",\n                     image->filename);\n\n                   mng_info->magn_warning++;\n                }\n#ifdef MNG_OBJECT_BUFFERS\n          /* Magnify existing objects in the range magn_first to magn_last */\n#endif\n            if (magn_first == 0 || magn_last == 0)\n              {\n                /* Save the magnification factors for object 0 */\n                mng_info->magn_mb=magn_mb;\n                mng_info->magn_ml=magn_ml;\n                mng_info->magn_mr=magn_mr;\n                mng_info->magn_mt=magn_mt;\n                mng_info->magn_mx=magn_mx;\n                mng_info->magn_my=magn_my;\n                mng_info->magn_methx=magn_methx;\n                mng_info->magn_methy=magn_methy;\n              }\n          }\n\n        if (memcmp(type,mng_PAST,4) == 0)\n          {\n            if (mng_info->past_warning == 0)\n              (void) ThrowMagickException(&image->exception,GetMagickModule(),\n                CoderError,\"PAST is not implemented yet\",\"`%s'\",\n                image->filename);\n\n            mng_info->past_warning++;\n          }\n\n        if (memcmp(type,mng_SHOW,4) == 0)\n          {\n            if (mng_info->show_warning == 0)\n              (void) ThrowMagickException(&image->exception,GetMagickModule(),\n                CoderError,\"SHOW is not implemented yet\",\"`%s'\",\n                image->filename);\n\n            mng_info->show_warning++;\n          }\n\n        if (memcmp(type,mng_sBIT,4) == 0)\n          {\n            if (length < 4)\n              mng_info->have_global_sbit=MagickFalse;\n\n            else\n              {\n                mng_info->global_sbit.gray=p[0];\n                mng_info->global_sbit.red=p[0];\n                mng_info->global_sbit.green=p[1];\n                mng_info->global_sbit.blue=p[2];\n                mng_info->global_sbit.alpha=p[3];\n                mng_info->have_global_sbit=MagickTrue;\n             }\n          }\n        if (memcmp(type,mng_pHYs,4) == 0)\n          {\n            if (length > 8)\n              {\n                mng_info->global_x_pixels_per_unit=\n                    (size_t) mng_get_long(p);\n                mng_info->global_y_pixels_per_unit=\n                    (size_t) mng_get_long(&p[4]);\n                mng_info->global_phys_unit_type=p[8];\n                mng_info->have_global_phys=MagickTrue;\n              }\n\n            else\n              mng_info->have_global_phys=MagickFalse;\n          }\n        if (memcmp(type,mng_pHYg,4) == 0)\n          {\n            if (mng_info->phyg_warning == 0)\n              (void) ThrowMagickException(&image->exception,GetMagickModule(),\n                CoderError,\"pHYg is not implemented.\",\"`%s'\",image->filename);\n\n            mng_info->phyg_warning++;\n          }\n        if (memcmp(type,mng_BASI,4) == 0)\n          {\n            skip_to_iend=MagickTrue;\n\n            if (mng_info->basi_warning == 0)\n              (void) ThrowMagickException(&image->exception,GetMagickModule(),\n                CoderError,\"BASI is not implemented yet\",\"`%s'\",\n                image->filename);\n\n            mng_info->basi_warning++;\n#ifdef MNG_BASI_SUPPORTED\n            if (length > 11)\n              {\n                basi_width=(size_t) ((p[0] << 24) | (p[1] << 16) |\n                   (p[2] << 8) | p[3]);\n                basi_height=(size_t) ((p[4] << 24) | (p[5] << 16) |\n                   (p[6] << 8) | p[7]);\n                basi_color_type=p[8];\n                basi_compression_method=p[9];\n                basi_filter_type=p[10];\n                basi_interlace_method=p[11];\n              }\n            if (length > 13)\n              basi_red=(p[12] << 8) & p[13];\n\n            else\n              basi_red=0;\n\n            if (length > 15)\n              basi_green=(p[14] << 8) & p[15];\n\n            else\n              basi_green=0;\n\n            if (length > 17)\n              basi_blue=(p[16] << 8) & p[17];\n\n            else\n              basi_blue=0;\n\n            if (length > 19)\n              basi_alpha=(p[18] << 8) & p[19];\n\n            else\n              {\n                if (basi_sample_depth == 16)\n                  basi_alpha=65535L;\n                else\n                  basi_alpha=255;\n              }\n\n            if (length > 20)\n              basi_viewable=p[20];\n\n            else\n              basi_viewable=0;\n\n#endif\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_IHDR,4)\n#if defined(JNG_SUPPORTED)\n            && memcmp(type,mng_JHDR,4)\n#endif\n            )\n          {\n            /* Not an IHDR or JHDR chunk */\n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            continue;\n          }\n/* Process IHDR */\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Processing %c%c%c%c chunk\",type[0],type[1],type[2],type[3]);\n\n        mng_info->exists[object_id]=MagickTrue;\n        mng_info->viewable[object_id]=MagickTrue;\n\n        if (mng_info->invisible[object_id])\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Skipping invisible object\");\n\n            skip_to_iend=MagickTrue;\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n#if defined(MNG_INSERT_LAYERS)\n        if (length < 8)\n          {\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n          }\n\n        image_width=(size_t) mng_get_long(p);\n        image_height=(size_t) mng_get_long(&p[4]);\n#endif\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        /*\n          Insert a transparent background layer behind the entire animation\n          if it is not full screen.\n        */\n#if defined(MNG_INSERT_LAYERS)\n        if (insert_layers && mng_type && first_mng_object)\n          {\n            if ((mng_info->clip.left > 0) || (mng_info->clip.top > 0) ||\n                (image_width < mng_info->mng_width) ||\n                (mng_info->clip.right < (ssize_t) mng_info->mng_width) ||\n                (image_height < mng_info->mng_height) ||\n                (mng_info->clip.bottom < (ssize_t) mng_info->mng_height))\n              {\n                if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL)\n                  {\n                    /*\n                      Allocate next image structure.\n                    */\n                    AcquireNextImage(image_info,image);\n\n                    if (GetNextImageInList(image) == (Image *) NULL)\n                      return(DestroyImageList(image));\n\n                    image=SyncNextImageInList(image);\n                  }\n                mng_info->image=image;\n\n                if (term_chunk_found)\n                  {\n                    image->start_loop=MagickTrue;\n                    image->iterations=mng_iterations;\n                    term_chunk_found=MagickFalse;\n                  }\n\n                else\n                    image->start_loop=MagickFalse;\n\n                /* Make a background rectangle.  */\n\n                image->delay=0;\n                image->columns=mng_info->mng_width;\n                image->rows=mng_info->mng_height;\n                image->page.width=mng_info->mng_width;\n                image->page.height=mng_info->mng_height;\n                image->page.x=0;\n                image->page.y=0;\n                image->background_color=mng_background_color;\n                (void) SetImageBackgroundColor(image);\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  Inserted transparent background layer, W=%.20g, H=%.20g\",\n                    (double) mng_info->mng_width,(double) mng_info->mng_height);\n              }\n          }\n        /*\n          Insert a background layer behind the upcoming image if\n          framing_mode is 3, and we haven't already inserted one.\n        */\n        if (insert_layers && (mng_info->framing_mode == 3) &&\n                (subframe_width) && (subframe_height) && (simplicity == 0 ||\n                (simplicity & 0x08)))\n          {\n            if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL)\n            {\n              /*\n                Allocate next image structure.\n              */\n              AcquireNextImage(image_info,image);\n\n              if (GetNextImageInList(image) == (Image *) NULL)\n                return(DestroyImageList(image));\n\n              image=SyncNextImageInList(image);\n            }\n\n            mng_info->image=image;\n\n            if (term_chunk_found)\n              {\n                image->start_loop=MagickTrue;\n                image->iterations=mng_iterations;\n                term_chunk_found=MagickFalse;\n              }\n\n            else\n                image->start_loop=MagickFalse;\n\n            image->delay=0;\n            image->columns=subframe_width;\n            image->rows=subframe_height;\n            image->page.width=subframe_width;\n            image->page.height=subframe_height;\n            image->page.x=mng_info->clip.left;\n            image->page.y=mng_info->clip.top;\n            image->background_color=mng_background_color;\n            image->matte=MagickFalse;\n            (void) SetImageBackgroundColor(image);\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Insert background layer, L=%.20g, R=%.20g T=%.20g, B=%.20g\",\n                (double) mng_info->clip.left,(double) mng_info->clip.right,\n                (double) mng_info->clip.top,(double) mng_info->clip.bottom);\n          }\n#endif /* MNG_INSERT_LAYERS */\n        first_mng_object=MagickFalse;\n\n        if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL)\n          {\n            /*\n              Allocate next image structure.\n            */\n            AcquireNextImage(image_info,image);\n\n            if (GetNextImageInList(image) == (Image *) NULL)\n              return(DestroyImageList(image));\n\n            image=SyncNextImageInList(image);\n          }\n        mng_info->image=image;\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n\n        if (status == MagickFalse)\n          break;\n\n        if (term_chunk_found)\n          {\n            image->start_loop=MagickTrue;\n            term_chunk_found=MagickFalse;\n          }\n\n        else\n            image->start_loop=MagickFalse;\n\n        if (mng_info->framing_mode == 1 || mng_info->framing_mode == 3)\n          {\n            image->delay=frame_delay;\n            frame_delay=default_frame_delay;\n          }\n\n        else\n          image->delay=0;\n\n        image->page.width=mng_info->mng_width;\n        image->page.height=mng_info->mng_height;\n        image->page.x=mng_info->x_off[object_id];\n        image->page.y=mng_info->y_off[object_id];\n        image->iterations=mng_iterations;\n\n        /*\n          Seek back to the beginning of the IHDR or JHDR chunk's length field.\n        */\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Seeking back to beginning of %c%c%c%c chunk\",type[0],type[1],\n            type[2],type[3]);\n\n        offset=SeekBlob(image,-((ssize_t) length+12),SEEK_CUR);\n\n        if (offset < 0)\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n\n    mng_info->image=image;\n    mng_info->mng_type=mng_type;\n    mng_info->object_id=object_id;\n\n    if (memcmp(type,mng_IHDR,4) == 0)\n      image=ReadOnePNGImage(mng_info,image_info,exception);\n\n#if defined(JNG_SUPPORTED)\n    else\n      image=ReadOneJNGImage(mng_info,image_info,exception);\n#endif\n\n    if (image == (Image *) NULL)\n      {\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"exit ReadJNGImage() with error\");\n\n        return((Image *) NULL);\n      }\n\n    if (image->columns == 0 || image->rows == 0)\n      {\n        (void) CloseBlob(image);\n        return(DestroyImageList(image));\n      }\n\n    mng_info->image=image;\n\n    if (mng_type)\n      {\n        MngBox\n          crop_box;\n\n        if (mng_info->magn_methx || mng_info->magn_methy)\n          {\n            png_uint_32\n               magnified_height,\n               magnified_width;\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Processing MNG MAGN chunk\");\n\n            if (mng_info->magn_methx == 1)\n              {\n                magnified_width=mng_info->magn_ml;\n\n                if (image->columns > 1)\n                   magnified_width += mng_info->magn_mr;\n\n                if (image->columns > 2)\n                   magnified_width += (png_uint_32)\n                      ((image->columns-2)*(mng_info->magn_mx));\n              }\n\n            else\n              {\n                magnified_width=(png_uint_32) image->columns;\n\n                if (image->columns > 1)\n                   magnified_width += mng_info->magn_ml-1;\n\n                if (image->columns > 2)\n                   magnified_width += mng_info->magn_mr-1;\n\n                if (image->columns > 3)\n                   magnified_width += (png_uint_32)\n                      ((image->columns-3)*(mng_info->magn_mx-1));\n              }\n\n            if (mng_info->magn_methy == 1)\n              {\n                magnified_height=mng_info->magn_mt;\n\n                if (image->rows > 1)\n                   magnified_height += mng_info->magn_mb;\n\n                if (image->rows > 2)\n                   magnified_height += (png_uint_32)\n                      ((image->rows-2)*(mng_info->magn_my));\n              }\n\n            else\n              {\n                magnified_height=(png_uint_32) image->rows;\n\n                if (image->rows > 1)\n                   magnified_height += mng_info->magn_mt-1;\n\n                if (image->rows > 2)\n                   magnified_height += mng_info->magn_mb-1;\n\n                if (image->rows > 3)\n                   magnified_height += (png_uint_32)\n                      ((image->rows-3)*(mng_info->magn_my-1));\n              }\n\n            if (magnified_height > image->rows ||\n                magnified_width > image->columns)\n              {\n                Image\n                  *large_image;\n\n                int\n                  yy;\n\n                ssize_t\n                  m,\n                  y;\n\n                register ssize_t\n                  x;\n\n                register PixelPacket\n                  *n,\n                  *q;\n\n                PixelPacket\n                  *next,\n                  *prev;\n\n                png_uint_16\n                  magn_methx,\n                  magn_methy;\n\n                /* Allocate next image structure.  */\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Allocate magnified image\");\n\n                AcquireNextImage(image_info,image);\n\n                if (GetNextImageInList(image) == (Image *) NULL)\n                  return(DestroyImageList(image));\n\n                large_image=SyncNextImageInList(image);\n\n                large_image->columns=magnified_width;\n                large_image->rows=magnified_height;\n\n                magn_methx=mng_info->magn_methx;\n                magn_methy=mng_info->magn_methy;\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\n#define QM unsigned short\n                if (magn_methx != 1 || magn_methy != 1)\n                  {\n                  /*\n                     Scale pixels to unsigned shorts to prevent\n                     overflow of intermediate values of interpolations\n                  */\n                     for (y=0; y < (ssize_t) image->rows; y++)\n                     {\n                       q=GetAuthenticPixels(image,0,y,image->columns,1,\n                          exception);\n\n                       for (x=(ssize_t) image->columns-1; x >= 0; x--)\n                       {\n                          SetPixelRed(q,ScaleQuantumToShort(\n                            GetPixelRed(q)));\n                          SetPixelGreen(q,ScaleQuantumToShort(\n                            GetPixelGreen(q)));\n                          SetPixelBlue(q,ScaleQuantumToShort(\n                            GetPixelBlue(q)));\n                          SetPixelOpacity(q,ScaleQuantumToShort(\n                            GetPixelOpacity(q)));\n                          q++;\n                       }\n\n                       if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                         break;\n                     }\n                  }\n#else\n#define QM Quantum\n#endif\n\n                if (image->matte != MagickFalse)\n                   (void) SetImageBackgroundColor(large_image);\n\n                else\n                  {\n                    large_image->background_color.opacity=OpaqueOpacity;\n                    (void) SetImageBackgroundColor(large_image);\n\n                    if (magn_methx == 4)\n                      magn_methx=2;\n\n                    if (magn_methx == 5)\n                      magn_methx=3;\n\n                    if (magn_methy == 4)\n                      magn_methy=2;\n\n                    if (magn_methy == 5)\n                      magn_methy=3;\n                  }\n\n                /* magnify the rows into the right side of the large image */\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Magnify the rows to %.20g\",(double) large_image->rows);\n                m=(ssize_t) mng_info->magn_mt;\n                yy=0;\n                length=(size_t) image->columns;\n                next=(PixelPacket *) AcquireQuantumMemory(length,sizeof(*next));\n                prev=(PixelPacket *) AcquireQuantumMemory(length,sizeof(*prev));\n\n                if ((prev == (PixelPacket *) NULL) ||\n                    (next == (PixelPacket *) NULL))\n                  {\n                     image=DestroyImageList(image);\n                     ThrowReaderException(ResourceLimitError,\n                       \"MemoryAllocationFailed\");\n                  }\n\n                n=GetAuthenticPixels(image,0,0,image->columns,1,exception);\n                (void) CopyMagickMemory(next,n,length);\n\n                for (y=0; y < (ssize_t) image->rows; y++)\n                {\n                  if (y == 0)\n                    m=(ssize_t) mng_info->magn_mt;\n\n                  else if (magn_methy > 1 && y == (ssize_t) image->rows-2)\n                    m=(ssize_t) mng_info->magn_mb;\n\n                  else if (magn_methy <= 1 && y == (ssize_t) image->rows-1)\n                    m=(ssize_t) mng_info->magn_mb;\n\n                  else if (magn_methy > 1 && y == (ssize_t) image->rows-1)\n                    m=1;\n\n                  else\n                    m=(ssize_t) mng_info->magn_my;\n\n                  n=prev;\n                  prev=next;\n                  next=n;\n\n                  if (y < (ssize_t) image->rows-1)\n                    {\n                      n=GetAuthenticPixels(image,0,y+1,image->columns,1,\n                          exception);\n                      (void) CopyMagickMemory(next,n,length);\n                    }\n\n                  for (i=0; i < m; i++, yy++)\n                  {\n                    register PixelPacket\n                      *pixels;\n\n                    assert(yy < (ssize_t) large_image->rows);\n                    pixels=prev;\n                    n=next;\n                    q=GetAuthenticPixels(large_image,0,yy,large_image->columns,\n                      1,exception);\n                    q+=(large_image->columns-image->columns);\n\n                    for (x=(ssize_t) image->columns-1; x >= 0; x--)\n                    {\n                      /* To do: get color as function of indexes[x] */\n                      /*\n                      if (image->storage_class == PseudoClass)\n                        {\n                        }\n                      */\n\n                      if (magn_methy <= 1)\n                        {\n                          /* replicate previous */\n                          SetPixelRGBO(q,(pixels));\n                        }\n\n                      else if (magn_methy == 2 || magn_methy == 4)\n                        {\n                          if (i == 0)\n                            {\n                              SetPixelRGBO(q,(pixels));\n                            }\n\n                          else\n                            {\n                              /* Interpolate */\n                              SetPixelRed(q,\n                                 ((QM) (((ssize_t)\n                                 (2*i*(GetPixelRed(n)\n                                 -GetPixelRed(pixels)+m))/\n                                 ((ssize_t) (m*2))\n                                 +GetPixelRed(pixels)))));\n                              SetPixelGreen(q,\n                                 ((QM) (((ssize_t)\n                                 (2*i*(GetPixelGreen(n)\n                                 -GetPixelGreen(pixels)+m))/\n                                 ((ssize_t) (m*2))\n                                 +GetPixelGreen(pixels)))));\n                              SetPixelBlue(q,\n                                 ((QM) (((ssize_t)\n                                 (2*i*(GetPixelBlue(n)\n                                 -GetPixelBlue(pixels)+m))/\n                                 ((ssize_t) (m*2))\n                                 +GetPixelBlue(pixels)))));\n\n                              if (image->matte != MagickFalse)\n                                 SetPixelOpacity(q,\n                                    ((QM) (((ssize_t)\n                                    (2*i*(GetPixelOpacity(n)\n                                    -GetPixelOpacity(pixels)+m))\n                                    /((ssize_t) (m*2))+\n                                   GetPixelOpacity(pixels)))));\n                            }\n\n                          if (magn_methy == 4)\n                            {\n                              /* Replicate nearest */\n                              if (i <= ((m+1) << 1))\n                                 SetPixelOpacity(q,\n                                 (*pixels).opacity+0);\n                              else\n                                 SetPixelOpacity(q,\n                                 (*n).opacity+0);\n                            }\n                        }\n\n                      else /* if (magn_methy == 3 || magn_methy == 5) */\n                        {\n                          /* Replicate nearest */\n                          if (i <= ((m+1) << 1))\n                          {\n                             SetPixelRGBO(q,(pixels));\n                          }\n\n                          else\n                          {\n                             SetPixelRGBO(q,(n));\n                          }\n\n                          if (magn_methy == 5)\n                            {\n                              SetPixelOpacity(q,\n                                 (QM) (((ssize_t) (2*i*\n                                 (GetPixelOpacity(n)\n                                 -GetPixelOpacity(pixels))\n                                 +m))/((ssize_t) (m*2))\n                                 +GetPixelOpacity(pixels)));\n                            }\n                        }\n                      n++;\n                      q++;\n                      pixels++;\n                    } /* x */\n\n                    if (SyncAuthenticPixels(large_image,exception) == 0)\n                      break;\n\n                  } /* i */\n                } /* y */\n\n                prev=(PixelPacket *) RelinquishMagickMemory(prev);\n                next=(PixelPacket *) RelinquishMagickMemory(next);\n\n                length=image->columns;\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Delete original image\");\n\n                DeleteImageFromList(&image);\n\n                image=large_image;\n\n                mng_info->image=image;\n\n                /* magnify the columns */\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Magnify the columns to %.20g\",(double) image->columns);\n\n                for (y=0; y < (ssize_t) image->rows; y++)\n                {\n                  register PixelPacket\n                    *pixels;\n\n                  q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n                  pixels=q+(image->columns-length);\n                  n=pixels+1;\n\n                  for (x=(ssize_t) (image->columns-length);\n                    x < (ssize_t) image->columns; x++)\n                  {\n                    /* To do: Rewrite using Get/Set***PixelComponent() */\n\n                    if (x == (ssize_t) (image->columns-length))\n                      m=(ssize_t) mng_info->magn_ml;\n\n                    else if (magn_methx > 1 && x == (ssize_t) image->columns-2)\n                      m=(ssize_t) mng_info->magn_mr;\n\n                    else if (magn_methx <= 1 && x == (ssize_t) image->columns-1)\n                      m=(ssize_t) mng_info->magn_mr;\n\n                    else if (magn_methx > 1 && x == (ssize_t) image->columns-1)\n                      m=1;\n\n                    else\n                      m=(ssize_t) mng_info->magn_mx;\n\n                    for (i=0; i < m; i++)\n                    {\n                      if (magn_methx <= 1)\n                        {\n                          /* replicate previous */\n                          SetPixelRGBO(q,(pixels));\n                        }\n\n                      else if (magn_methx == 2 || magn_methx == 4)\n                        {\n                          if (i == 0)\n                          {\n                             SetPixelRGBO(q,(pixels));\n                          }\n\n                          /* To do: Rewrite using Get/Set***PixelComponent() */\n                          else\n                            {\n                              /* Interpolate */\n                              SetPixelRed(q,\n                                 (QM) ((2*i*(\n                                 GetPixelRed(n)\n                                 -GetPixelRed(pixels))+m)\n                                 /((ssize_t) (m*2))+\n                                 GetPixelRed(pixels)));\n\n                              SetPixelGreen(q,\n                                 (QM) ((2*i*(\n                                 GetPixelGreen(n)\n                                 -GetPixelGreen(pixels))+m)\n                                 /((ssize_t) (m*2))+\n                                 GetPixelGreen(pixels)));\n\n                              SetPixelBlue(q,\n                                 (QM) ((2*i*(\n                                 GetPixelBlue(n)\n                                 -GetPixelBlue(pixels))+m)\n                                 /((ssize_t) (m*2))+\n                                 GetPixelBlue(pixels)));\n                              if (image->matte != MagickFalse)\n                                 SetPixelOpacity(q,\n                                   (QM) ((2*i*(\n                                   GetPixelOpacity(n)\n                                   -GetPixelOpacity(pixels))+m)\n                                   /((ssize_t) (m*2))+\n                                   GetPixelOpacity(pixels)));\n                            }\n\n                          if (magn_methx == 4)\n                            {\n                              /* Replicate nearest */\n                              if (i <= ((m+1) << 1))\n                              {\n                                 SetPixelOpacity(q,\n                                 GetPixelOpacity(pixels)+0);\n                              }\n                              else\n                              {\n                                 SetPixelOpacity(q,\n                                 GetPixelOpacity(n)+0);\n                              }\n                            }\n                        }\n\n                      else /* if (magn_methx == 3 || magn_methx == 5) */\n                        {\n                          /* Replicate nearest */\n                          if (i <= ((m+1) << 1))\n                          {\n                             SetPixelRGBO(q,(pixels));\n                          }\n\n                          else\n                          {\n                             SetPixelRGBO(q,(n));\n                          }\n\n                          if (magn_methx == 5)\n                            {\n                              /* Interpolate */\n                              SetPixelOpacity(q,\n                                 (QM) ((2*i*( GetPixelOpacity(n)\n                                 -GetPixelOpacity(pixels))+m)/\n                                 ((ssize_t) (m*2))\n                                 +GetPixelOpacity(pixels)));\n                            }\n                        }\n                      q++;\n                    }\n                    n++;\n                  }\n\n                  if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                    break;\n                }\n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\n              if (magn_methx != 1 || magn_methy != 1)\n                {\n                /*\n                   Rescale pixels to Quantum\n                */\n                   for (y=0; y < (ssize_t) image->rows; y++)\n                   {\n                     q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n                     for (x=(ssize_t) image->columns-1; x >= 0; x--)\n                     {\n                        SetPixelRed(q,ScaleShortToQuantum(\n                            GetPixelRed(q)));\n                        SetPixelGreen(q,ScaleShortToQuantum(\n                            GetPixelGreen(q)));\n                        SetPixelBlue(q,ScaleShortToQuantum(\n                            GetPixelBlue(q)));\n                        SetPixelOpacity(q,ScaleShortToQuantum(\n                            GetPixelOpacity(q)));\n                        q++;\n                     }\n\n                     if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                       break;\n                   }\n                }\n#endif\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  Finished MAGN processing\");\n              }\n          }\n\n        /*\n          Crop_box is with respect to the upper left corner of the MNG.\n        */\n        crop_box.left=mng_info->image_box.left+mng_info->x_off[object_id];\n        crop_box.right=mng_info->image_box.right+mng_info->x_off[object_id];\n        crop_box.top=mng_info->image_box.top+mng_info->y_off[object_id];\n        crop_box.bottom=mng_info->image_box.bottom+mng_info->y_off[object_id];\n        crop_box=mng_minimum_box(crop_box,mng_info->clip);\n        crop_box=mng_minimum_box(crop_box,mng_info->frame);\n        crop_box=mng_minimum_box(crop_box,mng_info->object_clip[object_id]);\n        if ((crop_box.left != (mng_info->image_box.left\n            +mng_info->x_off[object_id])) ||\n            (crop_box.right != (mng_info->image_box.right\n            +mng_info->x_off[object_id])) ||\n            (crop_box.top != (mng_info->image_box.top\n            +mng_info->y_off[object_id])) ||\n            (crop_box.bottom != (mng_info->image_box.bottom\n            +mng_info->y_off[object_id])))\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Crop the PNG image\");\n\n            if ((crop_box.left < crop_box.right) &&\n                (crop_box.top < crop_box.bottom))\n              {\n                Image\n                  *im;\n\n                RectangleInfo\n                  crop_info;\n\n                /*\n                  Crop_info is with respect to the upper left corner of\n                  the image.\n                */\n                crop_info.x=(crop_box.left-mng_info->x_off[object_id]);\n                crop_info.y=(crop_box.top-mng_info->y_off[object_id]);\n                crop_info.width=(size_t) (crop_box.right-crop_box.left);\n                crop_info.height=(size_t) (crop_box.bottom-crop_box.top);\n                image->page.width=image->columns;\n                image->page.height=image->rows;\n                image->page.x=0;\n                image->page.y=0;\n                im=CropImage(image,&crop_info,exception);\n\n                if (im != (Image *) NULL)\n                  {\n                    image->columns=im->columns;\n                    image->rows=im->rows;\n                    im=DestroyImage(im);\n                    image->page.width=image->columns;\n                    image->page.height=image->rows;\n                    image->page.x=crop_box.left;\n                    image->page.y=crop_box.top;\n                  }\n              }\n\n            else\n              {\n                /*\n                  No pixels in crop area.  The MNG spec still requires\n                  a layer, though, so make a single transparent pixel in\n                  the top left corner.\n                */\n                image->columns=1;\n                image->rows=1;\n                image->colors=2;\n                (void) SetImageBackgroundColor(image);\n                image->page.width=1;\n                image->page.height=1;\n                image->page.x=0;\n                image->page.y=0;\n              }\n          }\n#ifndef PNG_READ_EMPTY_PLTE_SUPPORTED\n        image=mng_info->image;\n#endif\n      }\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\n      /* PNG does not handle depths greater than 16 so reduce it even\n       * if lossy, and promote any depths > 8 to 16.\n       */\n      if (image->depth > 16)\n         image->depth=16;\n#endif\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 8)\n      if (image->depth > 8)\n        {\n          /* To do: fill low byte properly */\n          image->depth=16;\n        }\n\n      if (LosslessReduceDepthOK(image) != MagickFalse)\n         image->depth = 8;\n#endif\n\n      GetImageException(image,exception);\n\n      if (image_info->number_scenes != 0)\n        {\n          if (mng_info->scenes_found >\n             (ssize_t) (image_info->first_scene+image_info->number_scenes))\n            break;\n        }\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Finished reading image datastream.\");\n\n  } while (LocaleCompare(image_info->magick,\"MNG\") == 0);\n\n  (void) CloseBlob(image);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Finished reading all image datastreams.\");\n\n#if defined(MNG_INSERT_LAYERS)\n  if (insert_layers && !mng_info->image_found && (mng_info->mng_width) &&\n       (mng_info->mng_height))\n    {\n      /*\n        Insert a background layer if nothing else was found.\n      */\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  No images found.  Inserting a background layer.\");\n\n      if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL)\n        {\n          /*\n            Allocate next image structure.\n          */\n          AcquireNextImage(image_info,image);\n          if (GetNextImageInList(image) == (Image *) NULL)\n            {\n              if (logging != MagickFalse)\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Allocation failed, returning NULL.\");\n\n              return(DestroyImageList(image));\n            }\n          image=SyncNextImageInList(image);\n        }\n      image->columns=mng_info->mng_width;\n      image->rows=mng_info->mng_height;\n      image->page.width=mng_info->mng_width;\n      image->page.height=mng_info->mng_height;\n      image->page.x=0;\n      image->page.y=0;\n      image->background_color=mng_background_color;\n      image->matte=MagickFalse;\n\n      if (image_info->ping == MagickFalse)\n        (void) SetImageBackgroundColor(image);\n\n      mng_info->image_found++;\n    }\n#endif\n  image->iterations=mng_iterations;\n\n  if (mng_iterations == 1)\n    image->start_loop=MagickTrue;\n\n  while (GetPreviousImageInList(image) != (Image *) NULL)\n  {\n    image_count++;\n    if (image_count > 10*mng_info->image_found)\n      {\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  No beginning\");\n\n        (void) ThrowMagickException(&image->exception,GetMagickModule(),\n          CoderError,\"Linked list is corrupted, beginning of list not found\",\n          \"`%s'\",image_info->filename);\n\n        return(DestroyImageList(image));\n      }\n\n    image=GetPreviousImageInList(image);\n\n    if (GetNextImageInList(image) == (Image *) NULL)\n      {\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Corrupt list\");\n\n        (void) ThrowMagickException(&image->exception,GetMagickModule(),\n          CoderError,\"Linked list is corrupted; next_image is NULL\",\"`%s'\",\n          image_info->filename);\n      }\n  }\n\n  if (mng_info->ticks_per_second && mng_info->image_found > 1 &&\n             GetNextImageInList(image) ==\n     (Image *) NULL)\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  First image null\");\n\n      (void) ThrowMagickException(&image->exception,GetMagickModule(),\n        CoderError,\"image->next for first image is NULL but shouldn't be.\",\n        \"`%s'\",image_info->filename);\n    }\n\n  if (mng_info->image_found == 0)\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  No visible images found.\");\n\n      (void) ThrowMagickException(&image->exception,GetMagickModule(),\n        CoderError,\"No visible images in file\",\"`%s'\",image_info->filename);\n\n      return(DestroyImageList(image));\n    }\n\n  if (mng_info->ticks_per_second)\n    final_delay=1UL*MagickMax(image->ticks_per_second,1L)*\n            final_delay/mng_info->ticks_per_second;\n\n  else\n    image->start_loop=MagickTrue;\n\n  /* Find final nonzero image delay */\n  final_image_delay=0;\n\n  while (GetNextImageInList(image) != (Image *) NULL)\n    {\n      if (image->delay)\n        final_image_delay=image->delay;\n\n      image=GetNextImageInList(image);\n    }\n\n  if (final_delay < final_image_delay)\n    final_delay=final_image_delay;\n\n  image->delay=final_delay;\n\n  if (logging != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  image->delay=%.20g, final_delay=%.20g\",(double) image->delay,\n        (double) final_delay);\n\n  if (logging != MagickFalse)\n    {\n      int\n        scene;\n\n      scene=0;\n      image=GetFirstImageInList(image);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Before coalesce:\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    scene 0 delay=%.20g\",(double) image->delay);\n\n      while (GetNextImageInList(image) != (Image *) NULL)\n      {\n        image=GetNextImageInList(image);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    scene %.20g delay=%.20g\",(double) scene++,(double) image->delay);\n      }\n    }\n\n  image=GetFirstImageInList(image);\n#ifdef MNG_COALESCE_LAYERS\n  if (insert_layers)\n    {\n      Image\n        *next_image,\n        *next;\n\n      size_t\n        scene;\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Coalesce Images\");\n\n      scene=image->scene;\n      next_image=CoalesceImages(image,&image->exception);\n\n      if (next_image == (Image *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n      image=DestroyImageList(image);\n      image=next_image;\n\n      for (next=image; next != (Image *) NULL; next=next_image)\n      {\n         next->page.width=mng_info->mng_width;\n         next->page.height=mng_info->mng_height;\n         next->page.x=0;\n         next->page.y=0;\n         next->scene=scene++;\n         next_image=GetNextImageInList(next);\n\n         if (next_image == (Image *) NULL)\n           break;\n\n         if (next->delay == 0)\n           {\n             scene--;\n             next_image->previous=GetPreviousImageInList(next);\n             if (GetPreviousImageInList(next) == (Image *) NULL)\n               image=next_image;\n             else\n               next->previous->next=next_image;\n             next=DestroyImage(next);\n           }\n      }\n    }\n#endif\n\n  while (GetNextImageInList(image) != (Image *) NULL)\n      image=GetNextImageInList(image);\n\n  image->dispose=BackgroundDispose;\n\n  if (logging != MagickFalse)\n    {\n      int\n        scene;\n\n      scene=0;\n      image=GetFirstImageInList(image);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  After coalesce:\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    scene 0 delay=%.20g dispose=%.20g\",(double) image->delay,\n        (double) image->dispose);\n\n      while (GetNextImageInList(image) != (Image *) NULL)\n      {\n        image=GetNextImageInList(image);\n\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    scene %.20g delay=%.20g dispose=%.20g\",(double) scene++,\n          (double) image->delay,(double) image->dispose);\n      }\n   }\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  exit ReadOneJNGImage();\");\n\n  return(image);\n}\n", "target": 1, "idx": 180986}
{"func": "bool SetReparsePoint(HANDLE source, const wchar_t* target) {\n  USHORT size_target = static_cast<USHORT>(wcslen(target)) * sizeof(target[0]);\n  char buffer[2000] = {0};\n  DWORD returned;\n  REPARSE_DATA_BUFFER* data = reinterpret_cast<REPARSE_DATA_BUFFER*>(buffer);\n  data->ReparseTag = 0xa0000003;\n  memcpy(data->MountPointReparseBuffer.PathBuffer, target, size_target + 2);\n  data->MountPointReparseBuffer.SubstituteNameLength = size_target;\n  data->MountPointReparseBuffer.PrintNameOffset = size_target + 2;\n  data->ReparseDataLength = size_target + 4 + 8;\n  int data_size = data->ReparseDataLength + 8;\n  if (!DeviceIoControl(source, FSCTL_SET_REPARSE_POINT, &buffer, data_size,\n                       NULL, 0, &returned, NULL)) {\n    return false;\n  }\n  return true;\n}\n", "target": 1, "idx": 183552}
{"func": "BackgroundContents* BackgroundContentsService::CreateBackgroundContents(\n    SiteInstance* site,\n    int routing_id,\n    Profile* profile,\n    const string16& frame_name,\n    const string16& application_id) {\n  BackgroundContents* contents = new BackgroundContents(site, routing_id, this);\n\n  BackgroundContentsOpenedDetails details = {contents,\n                                             frame_name,\n                                             application_id};\n  BackgroundContentsOpened(&details);\n  content::NotificationService::current()->Notify(\n      chrome::NOTIFICATION_BACKGROUND_CONTENTS_OPENED,\n      content::Source<Profile>(profile),\n      content::Details<BackgroundContentsOpenedDetails>(&details));\n  return contents;\n}\n", "target": 0, "idx": 115081}
{"func": "std::string GetDialogTypeAsString(\n    ui::SelectFileDialog::Type dialog_type) {\n  std::string type_str;\n  switch (dialog_type) {\n    case ui::SelectFileDialog::SELECT_NONE:\n      type_str = \"full-page\";\n      break;\n\n    case ui::SelectFileDialog::SELECT_FOLDER:\n      type_str = \"folder\";\n      break;\n\n    case ui::SelectFileDialog::SELECT_UPLOAD_FOLDER:\n      type_str = \"upload-folder\";\n      break;\n\n    case ui::SelectFileDialog::SELECT_SAVEAS_FILE:\n      type_str = \"saveas-file\";\n      break;\n\n    case ui::SelectFileDialog::SELECT_OPEN_FILE:\n      type_str = \"open-file\";\n      break;\n\n    case ui::SelectFileDialog::SELECT_OPEN_MULTI_FILE:\n      type_str = \"open-multi-file\";\n      break;\n\n    default:\n      NOTREACHED();\n  }\n\n  return type_str;\n}\n", "target": 0, "idx": 120053}
{"func": "GfxImageColorMap::~GfxImageColorMap() {\n  int i;\n\n  delete colorSpace;\n  for (i = 0; i < gfxColorMaxComps; ++i) {\n    gfree(lookup[i]);\n  }\n  gfree(byte_lookup);\n}\n", "target": 0, "idx": 1138}
{"func": " SynchronousCompositorImpl::SynchronousCompositorImpl(WebContents* contents)\n    : compositor_client_(NULL),\n      output_surface_(NULL),\n       begin_frame_source_(nullptr),\n       contents_(contents),\n       routing_id_(contents->GetRoutingID()),\n      input_handler_(NULL),\n      is_active_(false),\n       renderer_needs_begin_frames_(false),\n       weak_ptr_factory_(this) {\n   DCHECK(contents);\n  DCHECK_NE(routing_id_, MSG_ROUTING_NONE);\n}\n", "target": 1, "idx": 185593}
{"func": "static void __intel_pmu_pebs_event(struct perf_event *event,\n\t\t\t\t   struct pt_regs *iregs, void *__pebs)\n{\n\t/*\n\t * We cast to pebs_record_core since that is a subset of\n\t * both formats and we don't use the other fields in this\n\t * routine.\n\t */\n\tstruct pebs_record_core *pebs = __pebs;\n\tstruct perf_sample_data data;\n\tstruct pt_regs regs;\n\n\tif (!intel_pmu_save_and_restart(event))\n\t\treturn;\n\n\tperf_sample_data_init(&data, 0);\n\tdata.period = event->hw.last_period;\n\n\t/*\n\t * We use the interrupt regs as a base because the PEBS record\n\t * does not contain a full regs set, specifically it seems to\n\t * lack segment descriptors, which get used by things like\n\t * user_mode().\n\t *\n\t * In the simple case fix up only the IP and BP,SP regs, for\n\t * PERF_SAMPLE_IP and PERF_SAMPLE_CALLCHAIN to function properly.\n\t * A possible PERF_SAMPLE_REGS will have to transfer all regs.\n\t */\n\tregs = *iregs;\n\tregs.ip = pebs->ip;\n\tregs.bp = pebs->bp;\n\tregs.sp = pebs->sp;\n\n\tif (event->attr.precise_ip > 1 && intel_pmu_pebs_fixup_ip(&regs))\n\t\tregs.flags |= PERF_EFLAGS_EXACT;\n \telse\n \t\tregs.flags &= ~PERF_EFLAGS_EXACT;\n \n\tif (perf_event_overflow(event, 1, &data, &regs))\n \t\tx86_pmu_stop(event, 0);\n }\n", "target": 1, "idx": 178992}
{"func": "bool ExtensionPrefs::ReadExtensionPrefStringSet(\n    const std::string& extension_id,\n    const std::string& pref_key,\n    std::set<std::string>* result) {\n  const ListValue* value = NULL;\n  if (!ReadExtensionPrefList(extension_id, pref_key, &value))\n    return false;\n\n  result->clear();\n\n  for (size_t i = 0; i < value->GetSize(); ++i) {\n    std::string item;\n    if (!value->GetString(i, &item))\n      return false;\n    result->insert(item);\n  }\n\n  return true;\n}\n", "target": 0, "idx": 103295}
{"func": "WORD32 ih264d_video_decode(iv_obj_t *dec_hdl, void *pv_api_ip, void *pv_api_op)\n{\n /* ! */\n\n dec_struct_t * ps_dec = (dec_struct_t *)(dec_hdl->pv_codec_handle);\n\n    WORD32 i4_err_status = 0;\n    UWORD8 *pu1_buf = NULL;\n    WORD32 buflen;\n    UWORD32 u4_max_ofst, u4_length_of_start_code = 0;\n\n    UWORD32 bytes_consumed = 0;\n    UWORD32 cur_slice_is_nonref = 0;\n    UWORD32 u4_next_is_aud;\n    UWORD32 u4_first_start_code_found = 0;\n    WORD32 ret = 0,api_ret_value = IV_SUCCESS;\n    WORD32 header_data_left = 0,frame_data_left = 0;\n    UWORD8 *pu1_bitstrm_buf;\n ivd_video_decode_ip_t *ps_dec_ip;\n ivd_video_decode_op_t *ps_dec_op;\n\n    ithread_set_name((void*)\"Parse_thread\");\n\n    ps_dec_ip = (ivd_video_decode_ip_t *)pv_api_ip;\n    ps_dec_op = (ivd_video_decode_op_t *)pv_api_op;\n\n {\n        UWORD32 u4_size;\n        u4_size = ps_dec_op->u4_size;\n        memset(ps_dec_op, 0, sizeof(ivd_video_decode_op_t));\n        ps_dec_op->u4_size = u4_size;\n }\n\n    ps_dec->pv_dec_out = ps_dec_op;\n    ps_dec->process_called = 1;\n if(ps_dec->init_done != 1)\n {\n return IV_FAIL;\n }\n\n /*Data memory barries instruction,so that bitstream write by the application is complete*/\n    DATA_SYNC();\n\n if(0 == ps_dec->u1_flushfrm)\n {\n if(ps_dec_ip->pv_stream_buffer == NULL)\n {\n            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n            ps_dec_op->u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL;\n return IV_FAIL;\n }\n if(ps_dec_ip->u4_num_Bytes <= 0)\n {\n            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n            ps_dec_op->u4_error_code |= IVD_DEC_NUMBYTES_INV;\n return IV_FAIL;\n\n }\n }\n    ps_dec->u1_pic_decode_done = 0;\n\n    ps_dec_op->u4_num_bytes_consumed = 0;\n\n    ps_dec->ps_out_buffer = NULL;\n\n if(ps_dec_ip->u4_size\n >= offsetof(ivd_video_decode_ip_t, s_out_buffer))\n        ps_dec->ps_out_buffer = &ps_dec_ip->s_out_buffer;\n\n    ps_dec->u4_fmt_conv_cur_row = 0;\n\n    ps_dec->u4_output_present = 0;\n    ps_dec->s_disp_op.u4_error_code = 1;\n    ps_dec->u4_fmt_conv_num_rows = FMT_CONV_NUM_ROWS;\n    ps_dec->u4_stop_threads = 0;\n if(0 == ps_dec->u4_share_disp_buf\n && ps_dec->i4_decode_header == 0)\n {\n        UWORD32 i;\n if(ps_dec->ps_out_buffer->u4_num_bufs == 0)\n {\n            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n            ps_dec_op->u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS;\n return IV_FAIL;\n }\n\n for(i = 0; i < ps_dec->ps_out_buffer->u4_num_bufs; i++)\n {\n if(ps_dec->ps_out_buffer->pu1_bufs[i] == NULL)\n {\n                ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n                ps_dec_op->u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL;\n return IV_FAIL;\n }\n\n if(ps_dec->ps_out_buffer->u4_min_out_buf_size[i] == 0)\n {\n                ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n                ps_dec_op->u4_error_code |=\n                                IVD_DISP_FRM_ZERO_OP_BUF_SIZE;\n return IV_FAIL;\n }\n }\n }\n\n if(ps_dec->u4_total_frames_decoded >= NUM_FRAMES_LIMIT)\n {\n        ps_dec_op->u4_error_code = ERROR_FRAME_LIMIT_OVER;\n return IV_FAIL;\n }\n\n /* ! */\n    ps_dec->u4_ts = ps_dec_ip->u4_ts;\n\n    ps_dec_op->u4_error_code = 0;\n    ps_dec_op->e_pic_type = -1;\n    ps_dec_op->u4_output_present = 0;\n    ps_dec_op->u4_frame_decoded_flag = 0;\n\n    ps_dec->i4_frametype = -1;\n    ps_dec->i4_content_type = -1;\n\n    ps_dec->u4_slice_start_code_found = 0;\n\n /* In case the deocder is not in flush mode(in shared mode),\n     then decoder has to pick up a buffer to write current frame.\n     Check if a frame is available in such cases */\n\n if(ps_dec->u1_init_dec_flag == 1 && ps_dec->u4_share_disp_buf == 1\n && ps_dec->u1_flushfrm == 0)\n {\n        UWORD32 i;\n\n        WORD32 disp_avail = 0, free_id;\n\n /* Check if at least one buffer is available with the codec */\n /* If not then return to application with error */\n for(i = 0; i < ps_dec->u1_pic_bufs; i++)\n {\n if(0 == ps_dec->u4_disp_buf_mapping[i]\n || 1 == ps_dec->u4_disp_buf_to_be_freed[i])\n {\n                disp_avail = 1;\n break;\n }\n\n }\n\n if(0 == disp_avail)\n {\n /* If something is queued for display wait for that buffer to be returned */\n\n            ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;\n            ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);\n return (IV_FAIL);\n }\n\n while(1)\n {\n pic_buffer_t *ps_pic_buf;\n            ps_pic_buf = (pic_buffer_t *)ih264_buf_mgr_get_next_free(\n (buf_mgr_t *)ps_dec->pv_pic_buf_mgr, &free_id);\n\n if(ps_pic_buf == NULL)\n {\n                UWORD32 i, display_queued = 0;\n\n /* check if any buffer was given for display which is not returned yet */\n for(i = 0; i < (MAX_DISP_BUFS_NEW); i++)\n {\n if(0 != ps_dec->u4_disp_buf_mapping[i])\n {\n                        display_queued = 1;\n break;\n }\n }\n /* If some buffer is queued for display, then codec has to singal an error and wait\n                 for that buffer to be returned.\n                 If nothing is queued for display then codec has ownership of all display buffers\n                 and it can reuse any of the existing buffers and continue decoding */\n\n if(1 == display_queued)\n {\n /* If something is queued for display wait for that buffer to be returned */\n                    ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;\n                    ps_dec_op->u4_error_code |= (1\n << IVD_UNSUPPORTEDPARAM);\n return (IV_FAIL);\n }\n }\n else\n {\n /* If the buffer is with display, then mark it as in use and then look for a buffer again */\n if(1 == ps_dec->u4_disp_buf_mapping[free_id])\n {\n                    ih264_buf_mgr_set_status(\n (buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n                                    free_id,\n                                    BUF_MGR_IO);\n }\n else\n {\n /**\n                     *  Found a free buffer for present call. Release it now.\n                     *  Will be again obtained later.\n                     */\n                    ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n                                          free_id,\n                                          BUF_MGR_IO);\n break;\n }\n }\n }\n\n }\n\n if(ps_dec->u1_flushfrm && ps_dec->u1_init_dec_flag)\n {\n\n        ih264d_get_next_display_field(ps_dec, ps_dec->ps_out_buffer,\n &(ps_dec->s_disp_op));\n if(0 == ps_dec->s_disp_op.u4_error_code)\n {\n            ps_dec->u4_fmt_conv_cur_row = 0;\n            ps_dec->u4_fmt_conv_num_rows = ps_dec->s_disp_frame_info.u4_y_ht;\n            ih264d_format_convert(ps_dec, &(ps_dec->s_disp_op),\n                                  ps_dec->u4_fmt_conv_cur_row,\n                                  ps_dec->u4_fmt_conv_num_rows);\n            ps_dec->u4_fmt_conv_cur_row += ps_dec->u4_fmt_conv_num_rows;\n            ps_dec->u4_output_present = 1;\n\n }\n        ih264d_release_display_field(ps_dec, &(ps_dec->s_disp_op));\n\n        ps_dec_op->u4_pic_wd = (UWORD32)ps_dec->u2_disp_width;\n        ps_dec_op->u4_pic_ht = (UWORD32)ps_dec->u2_disp_height;\n\n        ps_dec_op->u4_new_seq = 0;\n\n        ps_dec_op->u4_output_present = ps_dec->u4_output_present;\n        ps_dec_op->u4_progressive_frame_flag =\n                        ps_dec->s_disp_op.u4_progressive_frame_flag;\n        ps_dec_op->e_output_format =\n                        ps_dec->s_disp_op.e_output_format;\n        ps_dec_op->s_disp_frm_buf = ps_dec->s_disp_op.s_disp_frm_buf;\n        ps_dec_op->e4_fld_type = ps_dec->s_disp_op.e4_fld_type;\n        ps_dec_op->u4_ts = ps_dec->s_disp_op.u4_ts;\n        ps_dec_op->u4_disp_buf_id = ps_dec->s_disp_op.u4_disp_buf_id;\n\n /*In the case of flush ,since no frame is decoded set pic type as invalid*/\n        ps_dec_op->u4_is_ref_flag = -1;\n        ps_dec_op->e_pic_type = IV_NA_FRAME;\n        ps_dec_op->u4_frame_decoded_flag = 0;\n\n if(0 == ps_dec->s_disp_op.u4_error_code)\n {\n return (IV_SUCCESS);\n }\n else\n return (IV_FAIL);\n\n }\n if(ps_dec->u1_res_changed == 1)\n {\n /*if resolution has changed and all buffers have been flushed, reset decoder*/\n        ih264d_init_decoder(ps_dec);\n }\n\n    ps_dec->u4_prev_nal_skipped = 0;\n\n    ps_dec->u2_cur_mb_addr = 0;\n    ps_dec->u2_total_mbs_coded = 0;\n\n     ps_dec->u2_cur_slice_num = 0;\n     ps_dec->cur_dec_mb_num = 0;\n     ps_dec->cur_recon_mb_num = 0;\n    ps_dec->u4_first_slice_in_pic = 2;\n     ps_dec->u1_first_pb_nal_in_pic = 1;\n     ps_dec->u1_slice_header_done = 0;\n     ps_dec->u1_dangling_field = 0;\n\n    ps_dec->u4_dec_thread_created = 0;\n    ps_dec->u4_bs_deblk_thread_created = 0;\n    ps_dec->u4_cur_bs_mb_num = 0;\n    ps_dec->u4_start_recon_deblk  = 0;\n\n    DEBUG_THREADS_PRINTF(\" Starting process call\\n\");\n\n    ps_dec->u4_pic_buf_got = 0;\n\n do\n {\n\n        pu1_buf = (UWORD8*)ps_dec_ip->pv_stream_buffer\n + ps_dec_op->u4_num_bytes_consumed;\n\n        u4_max_ofst = ps_dec_ip->u4_num_Bytes\n - ps_dec_op->u4_num_bytes_consumed;\n        pu1_bitstrm_buf = ps_dec->ps_mem_tab[MEM_REC_BITSBUF].pv_base;\n\n        u4_next_is_aud = 0;\n\n        buflen = ih264d_find_start_code(pu1_buf, 0, u4_max_ofst,\n &u4_length_of_start_code,\n &u4_next_is_aud);\n\n if(buflen == -1)\n            buflen = 0;\n /* Ignore bytes beyond the allocated size of intermediate buffer */\n /* Since 8 bytes are read ahead, ensure 8 bytes are free at the\n        end of the buffer, which will be memset to 0 after emulation prevention */\n        buflen = MIN(buflen, (WORD32)(ps_dec->ps_mem_tab[MEM_REC_BITSBUF].u4_mem_size - 8));\n\n        bytes_consumed = buflen + u4_length_of_start_code;\n        ps_dec_op->u4_num_bytes_consumed += bytes_consumed;\n\n if(buflen >= MAX_NAL_UNIT_SIZE)\n {\n\n            ih264d_fill_output_struct_from_context(ps_dec, ps_dec_op);\n            H264_DEC_DEBUG_PRINT(\n \"\\nNal Size exceeded %d, Processing Stopped..\\n\",\n                            MAX_NAL_UNIT_SIZE);\n            ps_dec->i4_error_code = 1 << IVD_CORRUPTEDDATA;\n\n            ps_dec_op->e_pic_type = -1;\n /*signal the decode thread*/\n            ih264d_signal_decode_thread(ps_dec);\n /*signal end of frame decode for curren frame*/\n\n if(ps_dec->u4_pic_buf_got == 0)\n {\n if(ps_dec->i4_header_decoded == 3)\n {\n                    ps_dec->u2_total_mbs_coded =\n                                    ps_dec->ps_cur_sps->u2_max_mb_addr + 1;\n }\n\n /* close deblock thread if it is not closed yet*/\n if(ps_dec->u4_num_cores == 3)\n {\n                    ih264d_signal_bs_deblk_thread(ps_dec);\n }\n return IV_FAIL;\n }\n else\n {\n                ps_dec->u1_pic_decode_done = 1;\n continue;\n }\n }\n\n {\n            UWORD8 u1_firstbyte, u1_nal_ref_idc;\n\n if(ps_dec->i4_app_skip_mode == IVD_SKIP_B)\n {\n                u1_firstbyte = *(pu1_buf + u4_length_of_start_code);\n                u1_nal_ref_idc = (UWORD8)(NAL_REF_IDC(u1_firstbyte));\n if(u1_nal_ref_idc == 0)\n {\n /*skip non reference frames*/\n                    cur_slice_is_nonref = 1;\n continue;\n }\n else\n {\n if(1 == cur_slice_is_nonref)\n {\n /*We have encountered a referenced frame,return to app*/\n                        ps_dec_op->u4_num_bytes_consumed -=\n                                        bytes_consumed;\n                        ps_dec_op->e_pic_type = IV_B_FRAME;\n                        ps_dec_op->u4_error_code =\n                                        IVD_DEC_FRM_SKIPPED;\n                        ps_dec_op->u4_error_code |= (1\n << IVD_UNSUPPORTEDPARAM);\n                        ps_dec_op->u4_frame_decoded_flag = 0;\n                        ps_dec_op->u4_size =\n sizeof(ivd_video_decode_op_t);\n /*signal the decode thread*/\n                        ih264d_signal_decode_thread(ps_dec);\n /* close deblock thread if it is not closed yet*/\n if(ps_dec->u4_num_cores == 3)\n {\n                            ih264d_signal_bs_deblk_thread(ps_dec);\n }\n\n return (IV_FAIL);\n }\n }\n\n }\n\n }\n\n\n if(buflen)\n {\n            memcpy(pu1_bitstrm_buf, pu1_buf + u4_length_of_start_code,\n                   buflen);\n            u4_first_start_code_found = 1;\n\n }\n else\n {\n /*start code not found*/\n\n if(u4_first_start_code_found == 0)\n {\n /*no start codes found in current process call*/\n\n                ps_dec->i4_error_code = ERROR_START_CODE_NOT_FOUND;\n                ps_dec_op->u4_error_code |= 1 << IVD_INSUFFICIENTDATA;\n\n if(ps_dec->u4_pic_buf_got == 0)\n {\n\n                    ih264d_fill_output_struct_from_context(ps_dec,\n                                                           ps_dec_op);\n\n                    ps_dec_op->u4_error_code = ps_dec->i4_error_code;\n                    ps_dec_op->u4_frame_decoded_flag = 0;\n\n return (IV_FAIL);\n }\n else\n {\n                    ps_dec->u1_pic_decode_done = 1;\n continue;\n }\n }\n else\n {\n /* a start code has already been found earlier in the same process call*/\n                frame_data_left = 0;\n                header_data_left = 0;\n continue;\n }\n\n }\n\n        ps_dec->u4_return_to_app = 0;\n        ret = ih264d_parse_nal_unit(dec_hdl, ps_dec_op,\n                              pu1_bitstrm_buf, buflen);\n if(ret != OK)\n {\n            UWORD32 error =  ih264d_map_error(ret);\n            ps_dec_op->u4_error_code = error | ret;\n            api_ret_value = IV_FAIL;\n\n if((ret == IVD_RES_CHANGED)\n || (ret == IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED)\n || (ret == ERROR_UNAVAIL_PICBUF_T)\n || (ret == ERROR_UNAVAIL_MVBUF_T)\n || (ret == ERROR_INV_SPS_PPS_T))\n {\n                ps_dec->u4_slice_start_code_found = 0;\n break;\n }\n\n if((ret == ERROR_INCOMPLETE_FRAME) || (ret == ERROR_DANGLING_FIELD_IN_PIC))\n {\n                ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;\n                api_ret_value = IV_FAIL;\n break;\n }\n\n if(ret == ERROR_IN_LAST_SLICE_OF_PIC)\n {\n                api_ret_value = IV_FAIL;\n break;\n }\n\n }\n\n if(ps_dec->u4_return_to_app)\n {\n /*We have encountered a referenced frame,return to app*/\n            ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;\n            ps_dec_op->u4_error_code = IVD_DEC_FRM_SKIPPED;\n            ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);\n            ps_dec_op->u4_frame_decoded_flag = 0;\n            ps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);\n /*signal the decode thread*/\n            ih264d_signal_decode_thread(ps_dec);\n /* close deblock thread if it is not closed yet*/\n if(ps_dec->u4_num_cores == 3)\n {\n                ih264d_signal_bs_deblk_thread(ps_dec);\n }\n return (IV_FAIL);\n\n }\n\n\n\n        header_data_left = ((ps_dec->i4_decode_header == 1)\n && (ps_dec->i4_header_decoded != 3)\n && (ps_dec_op->u4_num_bytes_consumed\n < ps_dec_ip->u4_num_Bytes));\n        frame_data_left = (((ps_dec->i4_decode_header == 0)\n && ((ps_dec->u1_pic_decode_done == 0)\n || (u4_next_is_aud == 1)))\n && (ps_dec_op->u4_num_bytes_consumed\n < ps_dec_ip->u4_num_Bytes));\n }\n while(( header_data_left == 1)||(frame_data_left == 1));\n\n if((ps_dec->u4_slice_start_code_found == 1)\n && ps_dec->u2_total_mbs_coded < ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n {\n        WORD32 num_mb_skipped;\n        WORD32 prev_slice_err;\n pocstruct_t temp_poc;\n        WORD32 ret1;\n        WORD32 ht_in_mbs;\n        ht_in_mbs = ps_dec->u2_pic_ht >> (4 + ps_dec->ps_cur_slice->u1_field_pic_flag);\n        num_mb_skipped = (ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n - ps_dec->u2_total_mbs_coded;\n\n if(ps_dec->u4_first_slice_in_pic && (ps_dec->u4_pic_buf_got == 0))\n            prev_slice_err = 1;\n else\n            prev_slice_err = 2;\n\n if(ps_dec->u4_first_slice_in_pic && (ps_dec->u2_total_mbs_coded == 0))\n            prev_slice_err = 1;\n\n        ret1 = ih264d_mark_err_slice_skip(ps_dec, num_mb_skipped, ps_dec->u1_nal_unit_type == IDR_SLICE_NAL, ps_dec->ps_cur_slice->u2_frame_num,\n &temp_poc, prev_slice_err);\n\n if((ret1 == ERROR_UNAVAIL_PICBUF_T) || (ret1 == ERROR_UNAVAIL_MVBUF_T) ||\n (ret1 == ERROR_INV_SPS_PPS_T))\n {\n            ret = ret1;\n }\n }\n\n if((ret == IVD_RES_CHANGED)\n || (ret == IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED)\n || (ret == ERROR_UNAVAIL_PICBUF_T)\n || (ret == ERROR_UNAVAIL_MVBUF_T)\n || (ret == ERROR_INV_SPS_PPS_T))\n {\n\n /* signal the decode thread */\n        ih264d_signal_decode_thread(ps_dec);\n /* close deblock thread if it is not closed yet */\n if(ps_dec->u4_num_cores == 3)\n {\n            ih264d_signal_bs_deblk_thread(ps_dec);\n }\n /* dont consume bitstream for change in resolution case */\n if(ret == IVD_RES_CHANGED)\n {\n            ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;\n }\n return IV_FAIL;\n }\n\n\n if(ps_dec->u1_separate_parse)\n {\n /* If Format conversion is not complete,\n         complete it here */\n if(ps_dec->u4_num_cores == 2)\n {\n\n /*do deblocking of all mbs*/\n if((ps_dec->u4_nmb_deblk == 0) &&(ps_dec->u4_start_recon_deblk == 1) && (ps_dec->ps_cur_sps->u1_mb_aff_flag == 0))\n {\n                UWORD32 u4_num_mbs,u4_max_addr;\n tfr_ctxt_t s_tfr_ctxt;\n tfr_ctxt_t *ps_tfr_cxt = &s_tfr_ctxt;\n pad_mgr_t *ps_pad_mgr = &ps_dec->s_pad_mgr;\n\n /*BS is done for all mbs while parsing*/\n                u4_max_addr = (ps_dec->u2_frm_wd_in_mbs * ps_dec->u2_frm_ht_in_mbs) - 1;\n                ps_dec->u4_cur_bs_mb_num = u4_max_addr + 1;\n\n\n                ih264d_init_deblk_tfr_ctxt(ps_dec, ps_pad_mgr, ps_tfr_cxt,\n                                           ps_dec->u2_frm_wd_in_mbs, 0);\n\n\n                u4_num_mbs = u4_max_addr\n - ps_dec->u4_cur_deblk_mb_num + 1;\n\n                DEBUG_PERF_PRINTF(\"mbs left for deblocking= %d \\n\",u4_num_mbs);\n\n if(u4_num_mbs != 0)\n                    ih264d_check_mb_map_deblk(ps_dec, u4_num_mbs,\n                                                   ps_tfr_cxt,1);\n\n                ps_dec->u4_start_recon_deblk  = 0;\n\n }\n\n }\n\n /*signal the decode thread*/\n        ih264d_signal_decode_thread(ps_dec);\n /* close deblock thread if it is not closed yet*/\n if(ps_dec->u4_num_cores == 3)\n {\n            ih264d_signal_bs_deblk_thread(ps_dec);\n }\n }\n\n\n    DATA_SYNC();\n\n\n if((ps_dec_op->u4_error_code & 0xff)\n != ERROR_DYNAMIC_RESOLUTION_NOT_SUPPORTED)\n {\n        ps_dec_op->u4_pic_wd = (UWORD32)ps_dec->u2_disp_width;\n        ps_dec_op->u4_pic_ht = (UWORD32)ps_dec->u2_disp_height;\n }\n\n if(ps_dec->i4_header_decoded != 3)\n {\n        ps_dec_op->u4_error_code |= (1 << IVD_INSUFFICIENTDATA);\n\n }\n\n if(ps_dec->i4_decode_header == 1 && ps_dec->i4_header_decoded != 3)\n {\n        ps_dec_op->u4_error_code |= (1 << IVD_INSUFFICIENTDATA);\n\n }\n if(ps_dec->u4_prev_nal_skipped)\n {\n /*We have encountered a referenced frame,return to app*/\n        ps_dec_op->u4_error_code = IVD_DEC_FRM_SKIPPED;\n        ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);\n        ps_dec_op->u4_frame_decoded_flag = 0;\n        ps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);\n /* close deblock thread if it is not closed yet*/\n if(ps_dec->u4_num_cores == 3)\n {\n            ih264d_signal_bs_deblk_thread(ps_dec);\n }\n return (IV_FAIL);\n\n }\n\n if((ps_dec->u4_slice_start_code_found == 1)\n && (ERROR_DANGLING_FIELD_IN_PIC != i4_err_status))\n {\n /*\n         * For field pictures, set the bottom and top picture decoded u4_flag correctly.\n         */\n\n if(ps_dec->ps_cur_slice->u1_field_pic_flag)\n {\n if(1 == ps_dec->ps_cur_slice->u1_bottom_field_flag)\n {\n                ps_dec->u1_top_bottom_decoded |= BOT_FIELD_ONLY;\n }\n else\n {\n                ps_dec->u1_top_bottom_decoded |= TOP_FIELD_ONLY;\n }\n }\n\n /* if new frame in not found (if we are still getting slices from previous frame)\n         * ih264d_deblock_display is not called. Such frames will not be added to reference /display\n         */\n if (((ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC) == 0)\n && (ps_dec->u4_pic_buf_got == 1))\n {\n /* Calling Function to deblock Picture and Display */\n            ret = ih264d_deblock_display(ps_dec);\n }\n\n\n /*set to complete ,as we dont support partial frame decode*/\n if(ps_dec->i4_header_decoded == 3)\n {\n            ps_dec->u2_total_mbs_coded = ps_dec->ps_cur_sps->u2_max_mb_addr + 1;\n }\n\n /*Update the i4_frametype at the end of picture*/\n if(ps_dec->ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL)\n {\n            ps_dec->i4_frametype = IV_IDR_FRAME;\n }\n else if(ps_dec->i4_pic_type == B_SLICE)\n {\n            ps_dec->i4_frametype = IV_B_FRAME;\n }\n else if(ps_dec->i4_pic_type == P_SLICE)\n {\n            ps_dec->i4_frametype = IV_P_FRAME;\n }\n else if(ps_dec->i4_pic_type == I_SLICE)\n {\n            ps_dec->i4_frametype = IV_I_FRAME;\n }\n else\n {\n            H264_DEC_DEBUG_PRINT(\"Shouldn't come here\\n\");\n }\n\n        ps_dec->i4_content_type = ps_dec->ps_cur_slice->u1_field_pic_flag;\n\n        ps_dec->u4_total_frames_decoded = ps_dec->u4_total_frames_decoded + 2;\n        ps_dec->u4_total_frames_decoded = ps_dec->u4_total_frames_decoded\n - ps_dec->ps_cur_slice->u1_field_pic_flag;\n\n }\n\n /* close deblock thread if it is not closed yet*/\n if(ps_dec->u4_num_cores == 3)\n {\n        ih264d_signal_bs_deblk_thread(ps_dec);\n }\n\n\n {\n /* In case the decoder is configured to run in low delay mode,\n         * then get display buffer and then format convert.\n         * Note in this mode, format conversion does not run paralelly in a thread and adds to the codec cycles\n         */\n\n if((0 == ps_dec->u4_num_reorder_frames_at_init)\n && ps_dec->u1_init_dec_flag)\n {\n\n            ih264d_get_next_display_field(ps_dec, ps_dec->ps_out_buffer,\n &(ps_dec->s_disp_op));\n if(0 == ps_dec->s_disp_op.u4_error_code)\n {\n                ps_dec->u4_fmt_conv_cur_row = 0;\n                ps_dec->u4_output_present = 1;\n }\n }\n\n        ih264d_fill_output_struct_from_context(ps_dec, ps_dec_op);\n\n /* If Format conversion is not complete,\n         complete it here */\n if(ps_dec->u4_output_present &&\n (ps_dec->u4_fmt_conv_cur_row < ps_dec->s_disp_frame_info.u4_y_ht))\n {\n            ps_dec->u4_fmt_conv_num_rows = ps_dec->s_disp_frame_info.u4_y_ht\n - ps_dec->u4_fmt_conv_cur_row;\n            ih264d_format_convert(ps_dec, &(ps_dec->s_disp_op),\n                                  ps_dec->u4_fmt_conv_cur_row,\n                                  ps_dec->u4_fmt_conv_num_rows);\n            ps_dec->u4_fmt_conv_cur_row += ps_dec->u4_fmt_conv_num_rows;\n }\n\n        ih264d_release_display_field(ps_dec, &(ps_dec->s_disp_op));\n }\n\n if(ps_dec->i4_decode_header == 1 && (ps_dec->i4_header_decoded & 1) == 1)\n {\n        ps_dec_op->u4_progressive_frame_flag = 1;\n if((NULL != ps_dec->ps_cur_sps) && (1 == (ps_dec->ps_cur_sps->u1_is_valid)))\n {\n if((0 == ps_dec->ps_sps->u1_frame_mbs_only_flag)\n && (0 == ps_dec->ps_sps->u1_mb_aff_flag))\n                ps_dec_op->u4_progressive_frame_flag = 0;\n\n }\n }\n\n if((TOP_FIELD_ONLY | BOT_FIELD_ONLY) == ps_dec->u1_top_bottom_decoded)\n {\n        ps_dec->u1_top_bottom_decoded = 0;\n }\n /*--------------------------------------------------------------------*/\n /* Do End of Pic processing.                                          */\n /* Should be called only if frame was decoded in previous process call*/\n /*--------------------------------------------------------------------*/\n if(ps_dec->u4_pic_buf_got == 1)\n {\n if(1 == ps_dec->u1_last_pic_not_decoded)\n {\n            ret = ih264d_end_of_pic_dispbuf_mgr(ps_dec);\n\n if(ret != OK)\n return ret;\n\n            ret = ih264d_end_of_pic(ps_dec);\n if(ret != OK)\n return ret;\n }\n else\n {\n            ret = ih264d_end_of_pic(ps_dec);\n if(ret != OK)\n return ret;\n }\n\n }\n\n\n /*Data memory barrier instruction,so that yuv write by the library is complete*/\n    DATA_SYNC();\n\n    H264_DEC_DEBUG_PRINT(\"The num bytes consumed: %d\\n\",\n                         ps_dec_op->u4_num_bytes_consumed);\n return api_ret_value;\n}\n", "target": 1, "idx": 188059}
{"func": " bool DebuggerFunction::InitAgentHost() {\n   if (debuggee_.tab_id) {\n     WebContents* web_contents = NULL;\n     bool result = ExtensionTabUtil::GetTabById(*debuggee_.tab_id,\n                                               GetProfile(),\n                                               include_incognito(),\n                                               NULL,\n                                               NULL,\n                                                &web_contents,\n                                                NULL);\n     if (result && web_contents) {\n      if (content::HasWebUIScheme(web_contents->GetURL())) {\n        error_ = ErrorUtils::FormatErrorMessage(\n            keys::kAttachToWebUIError,\n            web_contents->GetURL().scheme());\n         return false;\n      }\n       agent_host_ = DevToolsAgentHost::GetOrCreateFor(web_contents);\n     }\n   } else if (debuggee_.extension_id) {\n    ExtensionHost* extension_host =\n        ExtensionSystem::Get(GetProfile())\n             ->process_manager()\n             ->GetBackgroundHostForExtension(*debuggee_.extension_id);\n     if (extension_host) {\n       agent_host_ = DevToolsAgentHost::GetOrCreateFor(\n           extension_host->render_view_host());\n     }\n  } else if (debuggee_.target_id) {\n    agent_host_ = DevToolsAgentHost::GetForId(*debuggee_.target_id);\n  } else {\n    error_ = keys::kInvalidTargetError;\n    return false;\n  }\n\n  if (!agent_host_.get()) {\n    FormatErrorMessage(keys::kNoTargetError);\n    return false;\n  }\n  return true;\n}\n", "target": 1, "idx": 185357}
{"func": "bool IsValidSymbolicLink(const FilePath& file_path,\n                         GDataCache::CacheSubDirectoryType sub_dir_type,\n                         const std::vector<FilePath>& cache_paths,\n                         std::string* reason) {\n  DCHECK(sub_dir_type == GDataCache::CACHE_TYPE_PINNED ||\n         sub_dir_type == GDataCache::CACHE_TYPE_OUTGOING);\n  FilePath destination;\n  if (!file_util::ReadSymbolicLink(file_path, &destination)) {\n    *reason = \"failed to read the symlink (maybe not a symlink)\";\n    return false;\n  }\n  if (!file_util::PathExists(destination)) {\n    *reason = \"pointing to a non-existent file\";\n    return false;\n  }\n  if (sub_dir_type == GDataCache::CACHE_TYPE_PINNED &&\n      destination == FilePath::FromUTF8Unsafe(util::kSymLinkToDevNull)) {\n    return true;\n  }\n  if (!cache_paths[GDataCache::CACHE_TYPE_PERSISTENT].IsParent(destination)) {\n    *reason = \"pointing to a file outside of persistent directory\";\n    return false;\n  }\n  return true;\n}\n", "target": 1, "idx": 184440}
{"func": "nautilus_directory_cancel_callback_internal (NautilusDirectory         *directory,\n                                             NautilusFile              *file,\n                                             NautilusDirectoryCallback  directory_callback,\n                                             NautilusFileCallback       file_callback,\n                                             gpointer                   callback_data)\n{\n    ReadyCallback callback;\n    GList *node;\n\n    if (directory == NULL)\n    {\n        return;\n    }\n\n    g_assert (NAUTILUS_IS_DIRECTORY (directory));\n    g_assert (file == NULL || NAUTILUS_IS_FILE (file));\n    g_assert (file != NULL || directory_callback != NULL);\n    g_assert (file == NULL || file_callback != NULL);\n\n    /* Construct a callback object. */\n    callback.file = file;\n    if (file == NULL)\n    {\n        callback.callback.directory = directory_callback;\n    }\n    else\n    {\n        callback.callback.file = file_callback;\n    }\n    callback.callback_data = callback_data;\n\n    /* Remove all queued callback from the list (including non-active). */\n    do\n    {\n        node = g_list_find_custom (directory->details->call_when_ready_list,\n                                   &callback,\n                                   ready_callback_key_compare);\n        if (node != NULL)\n        {\n            remove_callback_link (directory, node);\n\n            nautilus_directory_async_state_changed (directory);\n        }\n    }\n    while (node != NULL);\n}\n", "target": 0, "idx": 60963}
{"func": "static void get_icu_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAMETERS) \n {\n \n \tconst char* loc_name        \t= NULL;\n\tint         loc_name_len    \t= 0;\n\n\tchar*       tag_value\t\t= NULL;\n\tchar*       empty_result\t= \"\";\n\n\tint         result    \t\t= 0;\n\tchar*       msg        \t\t= NULL;\n\n\tUErrorCode  status          \t= U_ZERO_ERROR;\n\n\tintl_error_reset( NULL TSRMLS_CC );\n\n\tif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, \"s\",\n\t&loc_name ,&loc_name_len ) == FAILURE) {\n\t\tspprintf(&msg , 0, \"locale_get_%s : unable to parse input params\", tag_name );\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,  msg , 1 TSRMLS_CC );\n\t\tefree(msg);\n\n\t\tRETURN_FALSE;\n    }\n\n\tif(loc_name_len == 0) {\n\t\tloc_name = intl_locale_get_default(TSRMLS_C);\n\t}\n\n\t/* Call ICU get */\n\ttag_value = get_icu_value_internal( loc_name , tag_name , &result ,0);\n\n\t/* No value found */\n\tif( result == -1 ) {\n\t\tif( tag_value){\n\t\t\tefree( tag_value);\n\t\t}\n\t\tRETURN_STRING( empty_result , TRUE);\n\t}\n\n\t/* value found */\n\tif( tag_value){\n\t\tRETURN_STRING( tag_value , FALSE);\n\t}\n\n\t/* Error encountered while fetching the value */\n\tif( result ==0) {\n\t\tspprintf(&msg , 0, \"locale_get_%s : unable to get locale %s\", tag_name , tag_name );\n\t\tintl_error_set( NULL, status, msg , 1 TSRMLS_CC );\n\t\tefree(msg);\n\t\tRETURN_NULL();\n\t}\n\n }\n", "target": 1, "idx": 180378}
{"func": "void DocumentLoader::DidInstallNewDocument(Document* document) {\n   document->SetReadyState(Document::kLoading);\n   if (content_security_policy_) {\n    document->InitContentSecurityPolicy(content_security_policy_.Release());\n   }\n \n   if (history_item_ && IsBackForwardLoadType(load_type_))\n    document->SetStateForNewFormElements(history_item_->GetDocumentState());\n\n  DCHECK(document->GetFrame());\n  document->GetFrame()->GetClientHintsPreferences().UpdateFrom(\n      client_hints_preferences_);\n\n  Settings* settings = document->GetSettings();\n  fetcher_->SetImagesEnabled(settings->GetImagesEnabled());\n  fetcher_->SetAutoLoadImages(settings->GetLoadsImagesAutomatically());\n\n  const AtomicString& dns_prefetch_control =\n      response_.HttpHeaderField(HTTPNames::X_DNS_Prefetch_Control);\n  if (!dns_prefetch_control.IsEmpty())\n    document->ParseDNSPrefetchControlHeader(dns_prefetch_control);\n\n  String header_content_language =\n      response_.HttpHeaderField(HTTPNames::Content_Language);\n  if (!header_content_language.IsEmpty()) {\n    size_t comma_index = header_content_language.find(',');\n    header_content_language.Truncate(comma_index);\n    header_content_language =\n        header_content_language.StripWhiteSpace(IsHTMLSpace<UChar>);\n    if (!header_content_language.IsEmpty())\n      document->SetContentLanguage(AtomicString(header_content_language));\n  }\n\n  String referrer_policy_header =\n      response_.HttpHeaderField(HTTPNames::Referrer_Policy);\n  if (!referrer_policy_header.IsNull()) {\n    UseCounter::Count(*document, WebFeature::kReferrerPolicyHeader);\n    document->ParseAndSetReferrerPolicy(referrer_policy_header);\n  }\n\n  if (response_.IsSignedExchangeInnerResponse())\n    UseCounter::Count(*document, WebFeature::kSignedExchangeInnerResponse);\n\n  GetLocalFrameClient().DidCreateNewDocument();\n}\n", "target": 1, "idx": 186594}
{"func": " static void locationAttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)\n {\n     TestObject* proxyImp = V8TestObject::toNative(info.Holder());\n    TestNode* imp = WTF::getPtr(proxyImp->location());\n     if (!imp)\n         return;\n     V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID(V8StringResource<>, cppValue, jsValue);\n    imp->setHref(cppValue);\n}\n", "target": 1, "idx": 185462}
{"func": "void BackgroundContentsService::LoadBackgroundContentsFromManifests(\n    Profile* profile) {\n  const ExtensionSet* extensions =\n      profile->GetExtensionService()->extensions();\n   ExtensionSet::const_iterator iter = extensions->begin();\n   for (; iter != extensions->end(); ++iter) {\n     const Extension* extension = *iter;\n    if (extension->is_hosted_app() &&\n        extension->background_url().is_valid()) {\n       LoadBackgroundContents(profile,\n                             extension->background_url(),\n                              ASCIIToUTF16(\"background\"),\n                              UTF8ToUTF16(extension->id()));\n     }\n  }\n}\n", "target": 1, "idx": 184591}
{"func": "static MagickBooleanType WriteTXTImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  char\n    buffer[MagickPathExtent],\n    colorspace[MagickPathExtent],\n    tuple[MagickPathExtent];\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  PixelInfo\n    pixel;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    y;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  scene=0;\n  do\n  {\n    ComplianceType\n      compliance;\n\n    const char\n      *value;\n\n    (void) CopyMagickString(colorspace,CommandOptionToMnemonic(\n      MagickColorspaceOptions,(ssize_t) image->colorspace),MagickPathExtent);\n    LocaleLower(colorspace);\n    image->depth=GetImageQuantumDepth(image,MagickTrue);\n    if (image->alpha_trait != UndefinedPixelTrait)\n      (void) ConcatenateMagickString(colorspace,\"a\",MagickPathExtent);\n    compliance=NoCompliance;\n    value=GetImageOption(image_info,\"txt:compliance\");\n    if (value != (char *) NULL)\n      compliance=(ComplianceType) ParseCommandOption(MagickComplianceOptions,\n        MagickFalse,value);\n    if (LocaleCompare(image_info->magick,\"SPARSE-COLOR\") != 0)\n      {\n        size_t\n          depth;\n\n        depth=compliance == SVGCompliance ? image->depth :\n          MAGICKCORE_QUANTUM_DEPTH;\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"# ImageMagick pixel enumeration: %.20g,%.20g,%.20g,%s\\n\",(double)\n          image->columns,(double) image->rows,(double) ((MagickOffsetType)\n          GetQuantumRange(depth)),colorspace);\n        (void) WriteBlobString(image,buffer);\n      }\n    GetPixelInfo(image,&pixel);\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n      if (p == (const Quantum *) NULL)\n        break;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        GetPixelInfoPixel(image,p,&pixel);\n        if (pixel.colorspace == LabColorspace)\n          {\n            pixel.green-=(QuantumRange+1)/2.0;\n            pixel.blue-=(QuantumRange+1)/2.0;\n          }\n        if (LocaleCompare(image_info->magick,\"SPARSE-COLOR\") == 0)\n          {\n            /*\n              Sparse-color format.\n            */\n            if (GetPixelAlpha(image,p) == (Quantum) OpaqueAlpha)\n              {\n                GetColorTuple(&pixel,MagickFalse,tuple);\n                (void) FormatLocaleString(buffer,MagickPathExtent,\n                  \"%.20g,%.20g,\",(double) x,(double) y);\n                (void) WriteBlobString(image,buffer);\n                (void) WriteBlobString(image,tuple);\n                (void) WriteBlobString(image,\" \");\n              }\n            p+=GetPixelChannels(image);\n            continue;\n          }\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g,%.20g: \",\n          (double) x,(double) y);\n         (void) WriteBlobString(image,buffer);\n         (void) CopyMagickString(tuple,\"(\",MagickPathExtent);\n         if (pixel.colorspace == GRAYColorspace)\n          ConcatenateColorComponent(&pixel,GrayPixelChannel,compliance,\n            tuple);\n         else\n           {\n             ConcatenateColorComponent(&pixel,RedPixelChannel,compliance,tuple);\n            (void) ConcatenateMagickString(tuple,\",\",MagickPathExtent);\n            ConcatenateColorComponent(&pixel,GreenPixelChannel,compliance,\n              tuple);\n            (void) ConcatenateMagickString(tuple,\",\",MagickPathExtent);\n            ConcatenateColorComponent(&pixel,BluePixelChannel,compliance,tuple);\n          }\n        if (pixel.colorspace == CMYKColorspace)\n          {\n            (void) ConcatenateMagickString(tuple,\",\",MagickPathExtent);\n            ConcatenateColorComponent(&pixel,BlackPixelChannel,compliance,\n              tuple);\n          }\n        if (pixel.alpha_trait != UndefinedPixelTrait)\n          {\n            (void) ConcatenateMagickString(tuple,\",\",MagickPathExtent);\n            ConcatenateColorComponent(&pixel,AlphaPixelChannel,compliance,\n              tuple);\n          }\n        (void) ConcatenateMagickString(tuple,\")\",MagickPathExtent);\n        (void) WriteBlobString(image,tuple);\n        (void) WriteBlobString(image,\"  \");\n        GetColorTuple(&pixel,MagickTrue,tuple);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"%s\",tuple);\n        (void) WriteBlobString(image,buffer);\n        (void) WriteBlobString(image,\"  \");\n        (void) QueryColorname(image,&pixel,SVGCompliance,tuple,exception);\n        (void) WriteBlobString(image,tuple);\n        (void) WriteBlobString(image,\"\\n\");\n        p+=GetPixelChannels(image);\n      }\n      status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n        image->rows);\n      if (status == MagickFalse)\n        break;\n    }\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n", "target": 1, "idx": 181852}
{"func": "void ChunkedUploadDataStream::AppendData(\n    const char* data, int data_len, bool is_done) {\n  DCHECK(!all_data_appended_);\n  DCHECK(data_len > 0 || is_done);\n   if (data_len > 0) {\n     DCHECK(data);\n     upload_data_.push_back(\n        base::MakeUnique<std::vector<char>>(data, data + data_len));\n   }\n   all_data_appended_ = is_done;\n \n  if (!read_buffer_.get())\n    return;\n\n  int result = ReadChunk(read_buffer_.get(), read_buffer_len_);\n  DCHECK_GE(result, 0);\n  read_buffer_ = NULL;\n  read_buffer_len_ = 0;\n  OnReadCompleted(result);\n}\n", "target": 1, "idx": 187282}
{"func": "void RenderViewImpl::CreateFrameTree(WebKit::WebFrame* frame,\n                                     DictionaryValue* frame_tree) {\n  DCHECK(false);\n  NavigateToSwappedOutURL(frame);\n\n  string16 name;\n  if (frame_tree->GetString(kFrameTreeNodeNameKey, &name) && !name.empty())\n    frame->setName(name);\n\n  int remote_id;\n  if (frame_tree->GetInteger(kFrameTreeNodeIdKey, &remote_id))\n    active_frame_id_map_.insert(std::pair<int, int>(frame->identifier(),\n                                                    remote_id));\n\n  ListValue* children;\n  if (!frame_tree->GetList(kFrameTreeNodeSubtreeKey, &children))\n    return;\n\n  base::DictionaryValue* child;\n  for (size_t i = 0; i < children->GetSize(); ++i) {\n    if (!children->GetDictionary(i, &child))\n      continue;\n    WebElement element = frame->document().createElement(\"iframe\");\n    element.setAttribute(\"width\", \"0\");\n    element.setAttribute(\"height\", \"0\");\n    element.setAttribute(\"frameBorder\", \"0\");\n    if (frame->document().body().appendChild(element)) {\n      WebFrame* subframe = WebFrame::fromFrameOwnerElement(element);\n      if (subframe)\n        CreateFrameTree(subframe, child);\n    } else {\n      LOG(ERROR) << \"Failed to append created iframe element.\";\n    }\n  }\n}\n", "target": 0, "idx": 125267}
{"func": "unsigned int arpt_do_table(struct sk_buff *skb,\n\t\t\t   const struct nf_hook_state *state,\n\t\t\t   struct xt_table *table)\n{\n\tunsigned int hook = state->hook;\n\tstatic const char nulldevname[IFNAMSIZ] __attribute__((aligned(sizeof(long))));\n\tunsigned int verdict = NF_DROP;\n\tconst struct arphdr *arp;\n\tstruct arpt_entry *e, **jumpstack;\n\tconst char *indev, *outdev;\n\tconst void *table_base;\n\tunsigned int cpu, stackidx = 0;\n\tconst struct xt_table_info *private;\n\tstruct xt_action_param acpar;\n\tunsigned int addend;\n\n\tif (!pskb_may_pull(skb, arp_hdr_len(skb->dev)))\n\t\treturn NF_DROP;\n\n\tindev = state->in ? state->in->name : nulldevname;\n\toutdev = state->out ? state->out->name : nulldevname;\n\n\tlocal_bh_disable();\n\taddend = xt_write_recseq_begin();\n\tprivate = READ_ONCE(table->private); /* Address dependency. */\n\tcpu     = smp_processor_id();\n\ttable_base = private->entries;\n\tjumpstack  = (struct arpt_entry **)private->jumpstack[cpu];\n\n\t/* No TEE support for arptables, so no need to switch to alternate\n\t * stack.  All targets that reenter must return absolute verdicts.\n\t */\n\te = get_entry(table_base, private->hook_entry[hook]);\n\n\tacpar.state   = state;\n\tacpar.hotdrop = false;\n\n\tarp = arp_hdr(skb);\n\tdo {\n\t\tconst struct xt_entry_target *t;\n\t\tstruct xt_counters *counter;\n\n\t\tif (!arp_packet_match(arp, skb->dev, indev, outdev, &e->arp)) {\n\t\t\te = arpt_next_entry(e);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcounter = xt_get_this_cpu_counter(&e->counters);\n\t\tADD_COUNTER(*counter, arp_hdr_len(skb->dev), 1);\n\n\t\tt = arpt_get_target_c(e);\n\n\t\t/* Standard target? */\n\t\tif (!t->u.kernel.target->target) {\n\t\t\tint v;\n\n\t\t\tv = ((struct xt_standard_target *)t)->verdict;\n\t\t\tif (v < 0) {\n\t\t\t\t/* Pop from stack? */\n\t\t\t\tif (v != XT_RETURN) {\n\t\t\t\t\tverdict = (unsigned int)(-v) - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (stackidx == 0) {\n\t\t\t\t\te = get_entry(table_base,\n\t\t\t\t\t\t      private->underflow[hook]);\n\t\t\t\t} else {\n\t\t\t\t\te = jumpstack[--stackidx];\n\t\t\t\t\te = arpt_next_entry(e);\n\t\t\t\t}\n\t\t\t\tcontinue;\n \t\t\t}\n \t\t\tif (table_base + v\n \t\t\t    != arpt_next_entry(e)) {\n \t\t\t\tjumpstack[stackidx++] = e;\n \t\t\t}\n \n\t\t\te = get_entry(table_base, v);\n\t\t\tcontinue;\n\t\t}\n\n\t\tacpar.target   = t->u.kernel.target;\n\t\tacpar.targinfo = t->data;\n\t\tverdict = t->u.kernel.target->target(skb, &acpar);\n\n\t\tif (verdict == XT_CONTINUE) {\n\t\t\t/* Target might have changed stuff. */\n\t\t\tarp = arp_hdr(skb);\n\t\t\te = arpt_next_entry(e);\n\t\t} else {\n\t\t\t/* Verdict */\n\t\t\tbreak;\n\t\t}\n\t} while (!acpar.hotdrop);\n\txt_write_recseq_end(addend);\n\tlocal_bh_enable();\n\n\tif (acpar.hotdrop)\n\t\treturn NF_DROP;\n\telse\n\t\treturn verdict;\n}\n", "target": 1, "idx": 182534}
{"func": "bool HeapAllocator::backingExpand(void* address, size_t newSize) {\n  if (!address)\n    return false;\n\n  ThreadState* state = ThreadState::current();\n  if (state->sweepForbidden())\n    return false;\n  ASSERT(!state->isInGC());\n  ASSERT(state->isAllocationAllowed());\n  DCHECK_EQ(&state->heap(), &ThreadState::fromObject(address)->heap());\n\n  BasePage* page = pageFromObject(address);\n  if (page->isLargeObjectPage() || page->arena()->getThreadState() != state)\n     return false;\n \n   HeapObjectHeader* header = HeapObjectHeader::fromPayload(address);\n  ASSERT(header->checkHeader());\n   NormalPageArena* arena = static_cast<NormalPage*>(page)->arenaForNormalPage();\n   bool succeed = arena->expandObject(header, newSize);\n   if (succeed)\n    state->allocationPointAdjusted(arena->arenaIndex());\n  return succeed;\n}\n", "target": 1, "idx": 186682}
{"func": "void V8TestObject::InstallConditionalFeatures(\n    v8::Local<v8::Context> context,\n    const DOMWrapperWorld& world,\n    v8::Local<v8::Object> instance_object,\n    v8::Local<v8::Object> prototype_object,\n    v8::Local<v8::Function> interface_object,\n    v8::Local<v8::FunctionTemplate> interface_template) {\n  CHECK(!interface_template.IsEmpty());\n  DCHECK((!prototype_object.IsEmpty() && !interface_object.IsEmpty()) ||\n         !instance_object.IsEmpty());\n\n  v8::Isolate* isolate = context->GetIsolate();\n\n  if (!prototype_object.IsEmpty()) {\n    v8::Local<v8::Name> unscopables_symbol(v8::Symbol::GetUnscopables(isolate));\n    v8::Local<v8::Object> unscopables;\n    bool has_unscopables;\n    if (prototype_object->HasOwnProperty(context, unscopables_symbol)\n        .To(&has_unscopables) && has_unscopables) {\n      unscopables = prototype_object->Get(context, unscopables_symbol)\n                    .ToLocalChecked().As<v8::Object>();\n    } else {\n      unscopables = v8::Object::New(isolate);\n      unscopables->SetPrototype(context, v8::Null(isolate)).ToChecked();\n    }\n    unscopables->CreateDataProperty(\n        context, V8AtomicString(isolate, \"unscopableLongAttribute\"), v8::True(isolate))\n        .FromJust();\n    unscopables->CreateDataProperty(\n        context, V8AtomicString(isolate, \"unscopableOriginTrialEnabledLongAttribute\"), v8::True(isolate))\n        .FromJust();\n    if (RuntimeEnabledFeatures::RuntimeFeatureEnabled()) {\n      unscopables->CreateDataProperty(\n          context, V8AtomicString(isolate, \"unscopableRuntimeEnabledLongAttribute\"), v8::True(isolate))\n          .FromJust();\n    }\n    if (RuntimeEnabledFeatures::RuntimeFeatureEnabled()) {\n      unscopables->CreateDataProperty(\n          context, V8AtomicString(isolate, \"unscopableRuntimeEnabledVoidMethod\"), v8::True(isolate))\n          .FromJust();\n    }\n    unscopables->CreateDataProperty(\n        context, V8AtomicString(isolate, \"unscopableVoidMethod\"), v8::True(isolate))\n        .FromJust();\n    prototype_object->CreateDataProperty(\n        context, unscopables_symbol, unscopables).FromJust();\n  }\n}\n", "target": 0, "idx": 147453}
{"func": "static int ext4_ext_split(handle_t *handle, struct inode *inode,\n\t\t\t  unsigned int flags,\n\t\t\t  struct ext4_ext_path *path,\n\t\t\t  struct ext4_extent *newext, int at)\n{\n\tstruct buffer_head *bh = NULL;\n\tint depth = ext_depth(inode);\n\tstruct ext4_extent_header *neh;\n\tstruct ext4_extent_idx *fidx;\n\tint i = at, k, m, a;\n\text4_fsblk_t newblock, oldblock;\n \t__le32 border;\n \text4_fsblk_t *ablocks = NULL; /* array of allocated blocks */\n \tint err = 0;\n \n \t/* make decision: where to split? */\n \t/* FIXME: now decision is simplest: at current extent */\n\n\t/* if current leaf will be split, then we should use\n\t * border from split point */\n\tif (unlikely(path[depth].p_ext > EXT_MAX_EXTENT(path[depth].p_hdr))) {\n\t\tEXT4_ERROR_INODE(inode, \"p_ext > EXT_MAX_EXTENT!\");\n\t\treturn -EFSCORRUPTED;\n\t}\n\tif (path[depth].p_ext != EXT_MAX_EXTENT(path[depth].p_hdr)) {\n\t\tborder = path[depth].p_ext[1].ee_block;\n\t\text_debug(\"leaf will be split.\"\n\t\t\t\t\" next leaf starts at %d\\n\",\n\t\t\t\t  le32_to_cpu(border));\n\t} else {\n\t\tborder = newext->ee_block;\n\t\text_debug(\"leaf will be added.\"\n\t\t\t\t\" next leaf starts at %d\\n\",\n\t\t\t\tle32_to_cpu(border));\n\t}\n\n\t/*\n\t * If error occurs, then we break processing\n\t * and mark filesystem read-only. index won't\n\t * be inserted and tree will be in consistent\n\t * state. Next mount will repair buffers too.\n\t */\n\n\t/*\n\t * Get array to track all allocated blocks.\n\t * We need this to handle errors and free blocks\n\t * upon them.\n\t */\n\tablocks = kcalloc(depth, sizeof(ext4_fsblk_t), GFP_NOFS);\n\tif (!ablocks)\n\t\treturn -ENOMEM;\n\n\t/* allocate all needed blocks */\n\text_debug(\"allocate %d blocks for indexes/leaf\\n\", depth - at);\n\tfor (a = 0; a < depth - at; a++) {\n\t\tnewblock = ext4_ext_new_meta_block(handle, inode, path,\n\t\t\t\t\t\t   newext, &err, flags);\n\t\tif (newblock == 0)\n\t\t\tgoto cleanup;\n\t\tablocks[a] = newblock;\n\t}\n\n\t/* initialize new leaf */\n\tnewblock = ablocks[--a];\n\tif (unlikely(newblock == 0)) {\n\t\tEXT4_ERROR_INODE(inode, \"newblock == 0!\");\n\t\terr = -EFSCORRUPTED;\n\t\tgoto cleanup;\n\t}\n\tbh = sb_getblk_gfp(inode->i_sb, newblock, __GFP_MOVABLE | GFP_NOFS);\n\tif (unlikely(!bh)) {\n\t\terr = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\tlock_buffer(bh);\n\n\terr = ext4_journal_get_create_access(handle, bh);\n\tif (err)\n\t\tgoto cleanup;\n\n\tneh = ext_block_hdr(bh);\n\tneh->eh_entries = 0;\n\tneh->eh_max = cpu_to_le16(ext4_ext_space_block(inode, 0));\n\tneh->eh_magic = EXT4_EXT_MAGIC;\n\tneh->eh_depth = 0;\n\n\t/* move remainder of path[depth] to the new leaf */\n\tif (unlikely(path[depth].p_hdr->eh_entries !=\n\t\t     path[depth].p_hdr->eh_max)) {\n\t\tEXT4_ERROR_INODE(inode, \"eh_entries %d != eh_max %d!\",\n\t\t\t\t path[depth].p_hdr->eh_entries,\n\t\t\t\t path[depth].p_hdr->eh_max);\n\t\terr = -EFSCORRUPTED;\n\t\tgoto cleanup;\n\t}\n\t/* start copy from next extent */\n\tm = EXT_MAX_EXTENT(path[depth].p_hdr) - path[depth].p_ext++;\n\text4_ext_show_move(inode, path, newblock, depth);\n\tif (m) {\n\t\tstruct ext4_extent *ex;\n\t\tex = EXT_FIRST_EXTENT(neh);\n\t\tmemmove(ex, path[depth].p_ext, sizeof(struct ext4_extent) * m);\n \t\tle16_add_cpu(&neh->eh_entries, m);\n \t}\n \n \text4_extent_block_csum_set(inode, neh);\n \tset_buffer_uptodate(bh);\n \tunlock_buffer(bh);\n\n\terr = ext4_handle_dirty_metadata(handle, inode, bh);\n\tif (err)\n\t\tgoto cleanup;\n\tbrelse(bh);\n\tbh = NULL;\n\n\t/* correct old leaf */\n\tif (m) {\n\t\terr = ext4_ext_get_access(handle, inode, path + depth);\n\t\tif (err)\n\t\t\tgoto cleanup;\n\t\tle16_add_cpu(&path[depth].p_hdr->eh_entries, -m);\n\t\terr = ext4_ext_dirty(handle, inode, path + depth);\n\t\tif (err)\n\t\t\tgoto cleanup;\n\n\t}\n\n\t/* create intermediate indexes */\n\tk = depth - at - 1;\n\tif (unlikely(k < 0)) {\n\t\tEXT4_ERROR_INODE(inode, \"k %d < 0!\", k);\n\t\terr = -EFSCORRUPTED;\n\t\tgoto cleanup;\n\t}\n\tif (k)\n\t\text_debug(\"create %d intermediate indices\\n\", k);\n\t/* insert new index into current index block */\n\t/* current depth stored in i var */\n\ti = depth - 1;\n\twhile (k--) {\n\t\toldblock = newblock;\n\t\tnewblock = ablocks[--a];\n\t\tbh = sb_getblk(inode->i_sb, newblock);\n\t\tif (unlikely(!bh)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tlock_buffer(bh);\n\n\t\terr = ext4_journal_get_create_access(handle, bh);\n\t\tif (err)\n\t\t\tgoto cleanup;\n\n\t\tneh = ext_block_hdr(bh);\n\t\tneh->eh_entries = cpu_to_le16(1);\n\t\tneh->eh_magic = EXT4_EXT_MAGIC;\n\t\tneh->eh_max = cpu_to_le16(ext4_ext_space_block_idx(inode, 0));\n\t\tneh->eh_depth = cpu_to_le16(depth - i);\n\t\tfidx = EXT_FIRST_INDEX(neh);\n\t\tfidx->ei_block = border;\n\t\text4_idx_store_pblock(fidx, oldblock);\n\n\t\text_debug(\"int.index at %d (block %llu): %u -> %llu\\n\",\n\t\t\t\ti, newblock, le32_to_cpu(border), oldblock);\n\n\t\t/* move remainder of path[i] to the new index block */\n\t\tif (unlikely(EXT_MAX_INDEX(path[i].p_hdr) !=\n\t\t\t\t\tEXT_LAST_INDEX(path[i].p_hdr))) {\n\t\t\tEXT4_ERROR_INODE(inode,\n\t\t\t\t\t \"EXT_MAX_INDEX != EXT_LAST_INDEX ee_block %d!\",\n\t\t\t\t\t le32_to_cpu(path[i].p_ext->ee_block));\n\t\t\terr = -EFSCORRUPTED;\n\t\t\tgoto cleanup;\n\t\t}\n\t\t/* start copy indexes */\n\t\tm = EXT_MAX_INDEX(path[i].p_hdr) - path[i].p_idx++;\n\t\text_debug(\"cur 0x%p, last 0x%p\\n\", path[i].p_idx,\n\t\t\t\tEXT_MAX_INDEX(path[i].p_hdr));\n\t\text4_ext_show_move(inode, path, newblock, i);\n\t\tif (m) {\n\t\t\tmemmove(++fidx, path[i].p_idx,\n \t\t\t\tsizeof(struct ext4_extent_idx) * m);\n \t\t\tle16_add_cpu(&neh->eh_entries, m);\n \t\t}\n \t\text4_extent_block_csum_set(inode, neh);\n \t\tset_buffer_uptodate(bh);\n \t\tunlock_buffer(bh);\n\n\t\terr = ext4_handle_dirty_metadata(handle, inode, bh);\n\t\tif (err)\n\t\t\tgoto cleanup;\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\n\t\t/* correct old index */\n\t\tif (m) {\n\t\t\terr = ext4_ext_get_access(handle, inode, path + i);\n\t\t\tif (err)\n\t\t\t\tgoto cleanup;\n\t\t\tle16_add_cpu(&path[i].p_hdr->eh_entries, -m);\n\t\t\terr = ext4_ext_dirty(handle, inode, path + i);\n\t\t\tif (err)\n\t\t\t\tgoto cleanup;\n\t\t}\n\n\t\ti--;\n\t}\n\n\t/* insert new index */\n\terr = ext4_ext_insert_index(handle, inode, path + at,\n\t\t\t\t    le32_to_cpu(border), newblock);\n\ncleanup:\n\tif (bh) {\n\t\tif (buffer_locked(bh))\n\t\t\tunlock_buffer(bh);\n\t\tbrelse(bh);\n\t}\n\n\tif (err) {\n\t\t/* free all allocated blocks in error case */\n\t\tfor (i = 0; i < depth; i++) {\n\t\t\tif (!ablocks[i])\n\t\t\t\tcontinue;\n\t\t\text4_free_blocks(handle, inode, NULL, ablocks[i], 1,\n\t\t\t\t\t EXT4_FREE_BLOCKS_METADATA);\n\t\t}\n\t}\n\tkfree(ablocks);\n\n\treturn err;\n}\n", "target": 1, "idx": 182850}
{"func": "Utterance::~Utterance() {\n  DCHECK_EQ(completion_task_, static_cast<Task *>(NULL));\n}\n", "target": 1, "idx": 183854}
{"func": "void OfflineAudioDestinationHandler::FinishOfflineRendering() {\n  DCHECK(!IsMainThread());\n\n  PostCrossThreadTask(\n      *main_thread_task_runner_, FROM_HERE,\n      CrossThreadBind(&OfflineAudioDestinationHandler::NotifyComplete,\n                      WrapRefCounted(this)));\n}\n", "target": 0, "idx": 143084}
{"func": "void RenderProcessHostImpl::RegisterProcessHostForSite(\n    BrowserContext* browser_context,\n    RenderProcessHost* process,\n    const GURL& url) {\n  SiteProcessMap* map =\n      GetSiteProcessMapForBrowserContext(browser_context);\n\n  std::string site = SiteInstanceImpl::GetSiteForURL(browser_context, url)\n      .possibly_invalid_spec();\n  map->RegisterProcess(site, process);\n}\n", "target": 0, "idx": 122902}
{"func": "void CLASS merror (void *ptr, const char *where)\n{\n  if (ptr) return;\n  dcraw_message (DCRAW_ERROR,_(\"%s: Out of memory in %s\\n\"), ifname_display, where);\n  longjmp (failure, 1);\n}\n", "target": 0, "idx": 43321}
{"func": "WORD32 ih264d_start_of_pic(dec_struct_t *ps_dec,\n                         WORD32 i4_poc,\n pocstruct_t *ps_temp_poc,\n                         UWORD16 u2_frame_num,\n dec_pic_params_t *ps_pps)\n{\n pocstruct_t *ps_prev_poc = &ps_dec->s_cur_pic_poc;\n pocstruct_t *ps_cur_poc = ps_temp_poc;\n\n pic_buffer_t *pic_buf;\n\n ivd_video_decode_op_t * ps_dec_output =\n (ivd_video_decode_op_t *)ps_dec->pv_dec_out;\n dec_slice_params_t *ps_cur_slice = ps_dec->ps_cur_slice;\n dec_seq_params_t *ps_seq = ps_pps->ps_sps;\n    UWORD8 u1_bottom_field_flag = ps_cur_slice->u1_bottom_field_flag;\n    UWORD8 u1_field_pic_flag = ps_cur_slice->u1_field_pic_flag;\n /* high profile related declarations */\n high_profile_tools_t s_high_profile;\n    WORD32 ret;\n\n    H264_MUTEX_LOCK(&ps_dec->process_disp_mutex);\n\n /* check output buffer size given by the application */\n if(check_app_out_buf_size(ps_dec) != IV_SUCCESS)\n return IVD_DISP_FRM_ZERO_OP_BUF_SIZE;\n\n    ps_prev_poc->i4_pic_order_cnt_lsb = ps_cur_poc->i4_pic_order_cnt_lsb;\n    ps_prev_poc->i4_pic_order_cnt_msb = ps_cur_poc->i4_pic_order_cnt_msb;\n    ps_prev_poc->i4_delta_pic_order_cnt_bottom =\n                    ps_cur_poc->i4_delta_pic_order_cnt_bottom;\n    ps_prev_poc->i4_delta_pic_order_cnt[0] =\n                    ps_cur_poc->i4_delta_pic_order_cnt[0];\n    ps_prev_poc->i4_delta_pic_order_cnt[1] =\n                    ps_cur_poc->i4_delta_pic_order_cnt[1];\n    ps_prev_poc->u1_bot_field = ps_dec->ps_cur_slice->u1_bottom_field_flag;\n    ps_prev_poc->i4_prev_frame_num_ofst = ps_cur_poc->i4_prev_frame_num_ofst;\n    ps_prev_poc->u2_frame_num = u2_frame_num;\n    ps_dec->i1_prev_mb_qp_delta = 0;\n    ps_dec->i1_next_ctxt_idx = 0;\n\n\n    ps_dec->u4_nmb_deblk = 0;\n if(ps_dec->u4_num_cores == 1)\n       ps_dec->u4_nmb_deblk = 1;\n\n\n\n if(ps_seq->u1_mb_aff_flag == 1)\n {\n        ps_dec->u4_nmb_deblk = 0;\n if(ps_dec->u4_num_cores > 2)\n            ps_dec->u4_num_cores = 2;\n }\n\n        ps_dec->u4_use_intrapred_line_copy = 0;\n\n\n\n if (ps_seq->u1_mb_aff_flag == 0)\n {\n        ps_dec->u4_use_intrapred_line_copy = 1;\n }\n\n    ps_dec->u4_app_disable_deblk_frm = 0;\n /* If degrade is enabled, set the degrade flags appropriately */\n if(ps_dec->i4_degrade_type && ps_dec->i4_degrade_pics)\n {\n        WORD32 degrade_pic;\n        ps_dec->i4_degrade_pic_cnt++;\n        degrade_pic = 0;\n\n /* If degrade is to be done in all frames, then do not check further */\n switch(ps_dec->i4_degrade_pics)\n {\n case 4:\n {\n                degrade_pic = 1;\n break;\n }\n case 3:\n {\n if(ps_cur_slice->u1_slice_type != I_SLICE)\n                    degrade_pic = 1;\n\n break;\n }\n case 2:\n {\n\n /* If pic count hits non-degrade interval or it is an islice, then do not degrade */\n if((ps_cur_slice->u1_slice_type != I_SLICE)\n && (ps_dec->i4_degrade_pic_cnt\n != ps_dec->i4_nondegrade_interval))\n                    degrade_pic = 1;\n\n break;\n }\n case 1:\n {\n /* Check if the current picture is non-ref */\n if(0 == ps_cur_slice->u1_nal_ref_idc)\n {\n                    degrade_pic = 1;\n }\n break;\n }\n\n }\n if(degrade_pic)\n {\n if(ps_dec->i4_degrade_type & 0x2)\n                ps_dec->u4_app_disable_deblk_frm = 1;\n\n /* MC degrading is done only for non-ref pictures */\n if(0 == ps_cur_slice->u1_nal_ref_idc)\n {\n if(ps_dec->i4_degrade_type & 0x4)\n                    ps_dec->i4_mv_frac_mask = 0;\n\n if(ps_dec->i4_degrade_type & 0x8)\n                    ps_dec->i4_mv_frac_mask = 0;\n }\n }\n else\n            ps_dec->i4_degrade_pic_cnt = 0;\n }\n\n {\n dec_err_status_t * ps_err = ps_dec->ps_dec_err_status;\n if((ps_cur_slice->u1_slice_type == I_SLICE)\n || (ps_cur_slice->u1_slice_type == SI_SLICE))\n            ps_err->u1_cur_pic_type = PIC_TYPE_I;\n else\n            ps_err->u1_cur_pic_type = PIC_TYPE_UNKNOWN;\n\n if(ps_err->u1_pic_aud_i == PIC_TYPE_I)\n {\n            ps_err->u1_cur_pic_type = PIC_TYPE_I;\n            ps_err->u1_pic_aud_i = PIC_TYPE_UNKNOWN;\n }\n\n if(ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL)\n {\n if(ps_err->u1_err_flag)\n                ih264d_reset_ref_bufs(ps_dec->ps_dpb_mgr);\n            ps_err->u1_err_flag = ACCEPT_ALL_PICS;\n }\n }\n\n if(ps_dec->u1_init_dec_flag && ps_dec->s_prev_seq_params.u1_eoseq_pending)\n {\n /* Reset the decoder picture buffers */\n        WORD32 j;\n for(j = 0; j < MAX_DISP_BUFS_NEW; j++)\n {\n\n            ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n                                  j,\n                                  BUF_MGR_REF);\n            ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,\n                                  ps_dec->au1_pic_buf_id_mv_buf_id_map[j],\n                                  BUF_MGR_REF);\n            ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n                                  j,\n                                  BUF_MGR_IO);\n }\n\n /* reset the decoder structure parameters related to buffer handling */\n        ps_dec->u1_second_field = 0;\n        ps_dec->i4_cur_display_seq = 0;\n\n /********************************************************************/\n /* indicate in the decoder output i4_status that some frames are being */\n /* dropped, so that it resets timestamp and wait for a new sequence */\n /********************************************************************/\n\n        ps_dec->s_prev_seq_params.u1_eoseq_pending = 0;\n }\n    ret = ih264d_init_pic(ps_dec, u2_frame_num, i4_poc, ps_pps);\n if(ret != OK)\n return ret;\n\n    ps_dec->pv_parse_tu_coeff_data = ps_dec->pv_pic_tu_coeff_data;\n    ps_dec->pv_proc_tu_coeff_data  = ps_dec->pv_pic_tu_coeff_data;\n    ps_dec->ps_nmb_info = ps_dec->ps_frm_mb_info;\n if(ps_dec->u1_separate_parse)\n {\n        UWORD16 pic_wd;\n        UWORD16 pic_ht;\n        UWORD32 num_mbs;\n\n        pic_wd = ps_dec->u2_pic_wd;\n        pic_ht = ps_dec->u2_pic_ht;\n        num_mbs = (pic_wd * pic_ht) >> 8;\n\n if(ps_dec->pu1_dec_mb_map)\n {\n            memset((void *)ps_dec->pu1_dec_mb_map, 0, num_mbs);\n }\n\n if(ps_dec->pu1_recon_mb_map)\n {\n\n            memset((void *)ps_dec->pu1_recon_mb_map, 0, num_mbs);\n }\n\n if(ps_dec->pu2_slice_num_map)\n {\n            memset((void *)ps_dec->pu2_slice_num_map, 0,\n (num_mbs * sizeof(UWORD16)));\n }\n\n }\n\n    ps_dec->ps_parse_cur_slice = &(ps_dec->ps_dec_slice_buf[0]);\n    ps_dec->ps_decode_cur_slice = &(ps_dec->ps_dec_slice_buf[0]);\n    ps_dec->ps_computebs_cur_slice = &(ps_dec->ps_dec_slice_buf[0]);\n    ps_dec->u2_cur_slice_num = 0;\n\n /* Initialize all the HP toolsets to zero */\n    ps_dec->s_high_profile.u1_scaling_present = 0;\n    ps_dec->s_high_profile.u1_transform8x8_present = 0;\n\n /* Get Next Free Picture */\n if(1 == ps_dec->u4_share_disp_buf)\n {\n        UWORD32 i;\n /* Free any buffer that is in the queue to be freed */\n for(i = 0; i < MAX_DISP_BUFS_NEW; i++)\n {\n if(0 == ps_dec->u4_disp_buf_to_be_freed[i])\n continue;\n            ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr, i,\n            BUF_MGR_IO);\n            ps_dec->u4_disp_buf_to_be_freed[i] = 0;\n            ps_dec->u4_disp_buf_mapping[i] = 0;\n\n }\n }\n if(!(u1_field_pic_flag && 0 != ps_dec->u1_top_bottom_decoded)) //ps_dec->u1_second_field))\n {\n pic_buffer_t *ps_cur_pic;\n        WORD32 cur_pic_buf_id, cur_mv_buf_id;\n col_mv_buf_t *ps_col_mv;\n while(1)\n {\n            ps_cur_pic = (pic_buffer_t *)ih264_buf_mgr_get_next_free(\n (buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n &cur_pic_buf_id);\n if(ps_cur_pic == NULL)\n {\n                ps_dec->i4_error_code = ERROR_UNAVAIL_PICBUF_T;\n return ERROR_UNAVAIL_PICBUF_T;\n }\n if(0 == ps_dec->u4_disp_buf_mapping[cur_pic_buf_id])\n {\n break;\n }\n\n }\n        ps_col_mv = (col_mv_buf_t *)ih264_buf_mgr_get_next_free((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,\n &cur_mv_buf_id);\n if(ps_col_mv == NULL)\n {\n            ps_dec->i4_error_code = ERROR_UNAVAIL_MVBUF_T;\n return ERROR_UNAVAIL_MVBUF_T;\n }\n\n        ps_dec->ps_cur_pic = ps_cur_pic;\n        ps_dec->u1_pic_buf_id = cur_pic_buf_id;\n        ps_cur_pic->u4_ts = ps_dec->u4_ts;\n\n\n        ps_cur_pic->u1_mv_buf_id = cur_mv_buf_id;\n        ps_dec->au1_pic_buf_id_mv_buf_id_map[cur_pic_buf_id] = cur_mv_buf_id;\n\n        ps_cur_pic->pu1_col_zero_flag = (UWORD8 *)ps_col_mv->pv_col_zero_flag;\n        ps_cur_pic->ps_mv = (mv_pred_t *)ps_col_mv->pv_mv;\n        ps_dec->au1_pic_buf_ref_flag[cur_pic_buf_id] = 0;\n\n {\n /*make first entry of list0 and list1 point to cur pic,\n             *so that if first slice is in error, ref pic struct will have valid entries*/\n            ps_dec->ps_ref_pic_buf_lx[0] = ps_dec->ps_dpb_mgr->ps_init_dpb[0];\n            ps_dec->ps_ref_pic_buf_lx[1] = ps_dec->ps_dpb_mgr->ps_init_dpb[1];\n *(ps_dec->ps_dpb_mgr->ps_init_dpb[0][0]) = *ps_cur_pic;\n /* Initialize for field reference as well */\n *(ps_dec->ps_dpb_mgr->ps_init_dpb[0][MAX_REF_BUFS]) = *ps_cur_pic;\n\n *(ps_dec->ps_dpb_mgr->ps_mod_dpb[0][0]) = *ps_cur_pic;\n /* Initialize for field reference as well */\n *(ps_dec->ps_dpb_mgr->ps_mod_dpb[0][MAX_REF_BUFS]) = *ps_cur_pic;\n *(ps_dec->ps_dpb_mgr->ps_init_dpb[1][0]) = *ps_cur_pic;\n /* Initialize for field reference as well */\n *(ps_dec->ps_dpb_mgr->ps_init_dpb[1][MAX_REF_BUFS]) = *ps_cur_pic;\n *(ps_dec->ps_dpb_mgr->ps_mod_dpb[1][0]) = *ps_cur_pic;\n /* Initialize for field reference as well */\n *(ps_dec->ps_dpb_mgr->ps_mod_dpb[1][MAX_REF_BUFS]) = *ps_cur_pic;\n }\n\n if(!ps_dec->ps_cur_pic)\n {\n            WORD32 j;\n            H264_DEC_DEBUG_PRINT(\"------- Display Buffers Reset --------\\n\");\n for(j = 0; j < MAX_DISP_BUFS_NEW; j++)\n {\n\n                ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n                                      j,\n                                      BUF_MGR_REF);\n                ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,\n                                      ps_dec->au1_pic_buf_id_mv_buf_id_map[j],\n                                      BUF_MGR_REF);\n                ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n                                      j,\n                                      BUF_MGR_IO);\n }\n\n            ps_dec->i4_cur_display_seq = 0;\n            ps_dec->i4_prev_max_display_seq = 0;\n            ps_dec->i4_max_poc = 0;\n\n            ps_cur_pic = (pic_buffer_t *)ih264_buf_mgr_get_next_free(\n (buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n &cur_pic_buf_id);\n if(ps_cur_pic == NULL)\n {\n                ps_dec->i4_error_code = ERROR_UNAVAIL_PICBUF_T;\n return ERROR_UNAVAIL_PICBUF_T;\n }\n\n            ps_col_mv = (col_mv_buf_t *)ih264_buf_mgr_get_next_free((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,\n &cur_mv_buf_id);\n if(ps_col_mv == NULL)\n {\n                ps_dec->i4_error_code = ERROR_UNAVAIL_MVBUF_T;\n return ERROR_UNAVAIL_MVBUF_T;\n }\n\n            ps_dec->ps_cur_pic = ps_cur_pic;\n            ps_dec->u1_pic_buf_id = cur_pic_buf_id;\n            ps_cur_pic->u4_ts = ps_dec->u4_ts;\n            ps_dec->apv_buf_id_pic_buf_map[cur_pic_buf_id] = (void *)ps_cur_pic;\n\n            ps_cur_pic->u1_mv_buf_id = cur_mv_buf_id;\n            ps_dec->au1_pic_buf_id_mv_buf_id_map[cur_pic_buf_id] = cur_mv_buf_id;\n\n            ps_cur_pic->pu1_col_zero_flag = (UWORD8 *)ps_col_mv->pv_col_zero_flag;\n            ps_cur_pic->ps_mv = (mv_pred_t *)ps_col_mv->pv_mv;\n            ps_dec->au1_pic_buf_ref_flag[cur_pic_buf_id] = 0;\n\n }\n\n        ps_dec->ps_cur_pic->u1_picturetype = u1_field_pic_flag;\n        ps_dec->ps_cur_pic->u4_pack_slc_typ = SKIP_NONE;\n        H264_DEC_DEBUG_PRINT(\"got a buffer\\n\");\n }\n else\n {\n        H264_DEC_DEBUG_PRINT(\"did not get a buffer\\n\");\n }\n\n    ps_dec->u4_pic_buf_got = 1;\n\n    ps_dec->ps_cur_pic->i4_poc = i4_poc;\n    ps_dec->ps_cur_pic->i4_frame_num = u2_frame_num;\n    ps_dec->ps_cur_pic->i4_pic_num = u2_frame_num;\n    ps_dec->ps_cur_pic->i4_top_field_order_cnt = ps_pps->i4_top_field_order_cnt;\n    ps_dec->ps_cur_pic->i4_bottom_field_order_cnt =\n                    ps_pps->i4_bottom_field_order_cnt;\n    ps_dec->ps_cur_pic->i4_avg_poc = ps_pps->i4_avg_poc;\n    ps_dec->ps_cur_pic->u4_time_stamp = ps_dec->u4_pts;\n\n    ps_dec->s_cur_pic = *(ps_dec->ps_cur_pic);\n if(u1_field_pic_flag && u1_bottom_field_flag)\n {\n        WORD32 i4_temp_poc;\n        WORD32 i4_top_field_order_poc, i4_bot_field_order_poc;\n /* Point to odd lines, since it's bottom field */\n        ps_dec->s_cur_pic.pu1_buf1 += ps_dec->s_cur_pic.u2_frm_wd_y;\n        ps_dec->s_cur_pic.pu1_buf2 += ps_dec->s_cur_pic.u2_frm_wd_uv;\n        ps_dec->s_cur_pic.pu1_buf3 += ps_dec->s_cur_pic.u2_frm_wd_uv;\n        ps_dec->s_cur_pic.ps_mv +=\n ((ps_dec->u2_pic_ht * ps_dec->u2_pic_wd) >> 5);\n        ps_dec->s_cur_pic.pu1_col_zero_flag += ((ps_dec->u2_pic_ht\n * ps_dec->u2_pic_wd) >> 5);\n        ps_dec->ps_cur_pic->u1_picturetype |= BOT_FLD;\n        i4_top_field_order_poc = ps_dec->ps_cur_pic->i4_top_field_order_cnt;\n        i4_bot_field_order_poc = ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;\n        i4_temp_poc = MIN(i4_top_field_order_poc,\n                                 i4_bot_field_order_poc);\n        ps_dec->ps_cur_pic->i4_avg_poc = i4_temp_poc;\n }\n\n    ps_cur_slice->u1_mbaff_frame_flag = ps_seq->u1_mb_aff_flag\n && (!u1_field_pic_flag);\n\n    ps_dec->ps_cur_pic->u1_picturetype |= (ps_cur_slice->u1_mbaff_frame_flag\n << 2);\n\n    ps_dec->ps_cur_mb_row = ps_dec->ps_nbr_mb_row; //[0];\n    ps_dec->ps_cur_mb_row += 2;\n    ps_dec->ps_top_mb_row = ps_dec->ps_nbr_mb_row;\n    ps_dec->ps_top_mb_row += ((ps_dec->u2_frm_wd_in_mbs + 2) << (1 - ps_dec->ps_cur_sps->u1_frame_mbs_only_flag));\n    ps_dec->ps_top_mb_row += 2;\n\n /* CHANGED CODE */\n    ps_dec->ps_mv_cur = ps_dec->s_cur_pic.ps_mv;\n    ps_dec->ps_mv_top = ps_dec->ps_mv_top_p[0];\n /* CHANGED CODE */\n    ps_dec->u1_mv_top_p = 0;\n    ps_dec->u1_mb_idx = 0;\n /* CHANGED CODE */\n    ps_dec->ps_mv_left = ps_dec->s_cur_pic.ps_mv;\n    ps_dec->u2_total_mbs_coded = 0;\n    ps_dec->i4_submb_ofst = -(SUB_BLK_SIZE);\n    ps_dec->u4_pred_info_idx = 0;\n    ps_dec->u4_pred_info_pkd_idx = 0;\n    ps_dec->u4_dma_buf_idx = 0;\n    ps_dec->ps_mv = ps_dec->s_cur_pic.ps_mv;\n    ps_dec->ps_mv_bank_cur = ps_dec->s_cur_pic.ps_mv;\n    ps_dec->pu1_col_zero_flag = ps_dec->s_cur_pic.pu1_col_zero_flag;\n    ps_dec->ps_part = ps_dec->ps_parse_part_params;\n    ps_dec->i2_prev_slice_mbx = -1;\n    ps_dec->i2_prev_slice_mby = 0;\n    ps_dec->u2_mv_2mb[0] = 0;\n    ps_dec->u2_mv_2mb[1] = 0;\n    ps_dec->u1_last_pic_not_decoded = 0;\n\n    ps_dec->u2_cur_slice_num_dec_thread = 0;\n    ps_dec->u2_cur_slice_num_bs = 0;\n    ps_dec->u4_intra_pred_line_ofst = 0;\n    ps_dec->pu1_cur_y_intra_pred_line = ps_dec->pu1_y_intra_pred_line;\n    ps_dec->pu1_cur_u_intra_pred_line = ps_dec->pu1_u_intra_pred_line;\n    ps_dec->pu1_cur_v_intra_pred_line = ps_dec->pu1_v_intra_pred_line;\n\n    ps_dec->pu1_cur_y_intra_pred_line_base = ps_dec->pu1_y_intra_pred_line;\n    ps_dec->pu1_cur_u_intra_pred_line_base = ps_dec->pu1_u_intra_pred_line;\n    ps_dec->pu1_cur_v_intra_pred_line_base = ps_dec->pu1_v_intra_pred_line;\n\n\n\n\n\n    ps_dec->pu1_prev_y_intra_pred_line = ps_dec->pu1_y_intra_pred_line\n + (ps_dec->u2_frm_wd_in_mbs * MB_SIZE);\n\n    ps_dec->pu1_prev_u_intra_pred_line = ps_dec->pu1_u_intra_pred_line\n + ps_dec->u2_frm_wd_in_mbs * BLK8x8SIZE * YUV420SP_FACTOR;\n    ps_dec->pu1_prev_v_intra_pred_line = ps_dec->pu1_v_intra_pred_line\n + ps_dec->u2_frm_wd_in_mbs * BLK8x8SIZE;\n\n    ps_dec->ps_deblk_mbn = ps_dec->ps_deblk_pic;\n /* Initialize The Function Pointer Depending Upon the Entropy and MbAff Flag */\n {\n if(ps_cur_slice->u1_mbaff_frame_flag)\n {\n            ps_dec->pf_compute_bs = ih264d_compute_bs_mbaff;\n            ps_dec->pf_mvpred = ih264d_mvpred_mbaff;\n }\n else\n {\n            ps_dec->pf_compute_bs = ih264d_compute_bs_non_mbaff;\n            ps_dec->u1_cur_mb_fld_dec_flag = ps_cur_slice->u1_field_pic_flag;\n }\n }\n /* Set up the Parameter for DMA transfer */\n {\n        UWORD8 u1_field_pic_flag = ps_dec->ps_cur_slice->u1_field_pic_flag;\n\n        UWORD8 u1_mbaff = ps_cur_slice->u1_mbaff_frame_flag;\n\n        UWORD8 uc_lastmbs = (((ps_dec->u2_pic_wd) >> 4)\n % (ps_dec->u1_recon_mb_grp >> u1_mbaff));\n        UWORD16 ui16_lastmbs_widthY =\n (uc_lastmbs ? (uc_lastmbs << 4) : ((ps_dec->u1_recon_mb_grp\n >> u1_mbaff) << 4));\n        UWORD16 ui16_lastmbs_widthUV =\n                        uc_lastmbs ? (uc_lastmbs << 3) : ((ps_dec->u1_recon_mb_grp\n >> u1_mbaff) << 3);\n\n        ps_dec->s_tran_addrecon.pu1_dest_y = ps_dec->s_cur_pic.pu1_buf1;\n        ps_dec->s_tran_addrecon.pu1_dest_u = ps_dec->s_cur_pic.pu1_buf2;\n        ps_dec->s_tran_addrecon.pu1_dest_v = ps_dec->s_cur_pic.pu1_buf3;\n\n        ps_dec->s_tran_addrecon.u2_frm_wd_y = ps_dec->u2_frm_wd_y\n << u1_field_pic_flag;\n        ps_dec->s_tran_addrecon.u2_frm_wd_uv = ps_dec->u2_frm_wd_uv\n << u1_field_pic_flag;\n\n if(u1_field_pic_flag)\n {\n            ui16_lastmbs_widthY += ps_dec->u2_frm_wd_y;\n            ui16_lastmbs_widthUV += ps_dec->u2_frm_wd_uv;\n }\n\n /* Normal Increment of Pointer */\n        ps_dec->s_tran_addrecon.u4_inc_y[0] = ((ps_dec->u1_recon_mb_grp << 4)\n >> u1_mbaff);\n        ps_dec->s_tran_addrecon.u4_inc_uv[0] = ((ps_dec->u1_recon_mb_grp << 4)\n >> u1_mbaff);\n\n /* End of Row Increment */\n        ps_dec->s_tran_addrecon.u4_inc_y[1] = (ui16_lastmbs_widthY\n + (PAD_LEN_Y_H << 1)\n + ps_dec->s_tran_addrecon.u2_frm_wd_y\n * ((15 << u1_mbaff) + u1_mbaff));\n        ps_dec->s_tran_addrecon.u4_inc_uv[1] = (ui16_lastmbs_widthUV\n + (PAD_LEN_UV_H << 2)\n + ps_dec->s_tran_addrecon.u2_frm_wd_uv\n * ((15 << u1_mbaff) + u1_mbaff));\n\n /* Assign picture numbers to each frame/field  */\n /* only once per picture.                      */\n        ih264d_assign_pic_num(ps_dec);\n        ps_dec->s_tran_addrecon.u2_mv_top_left_inc = (ps_dec->u1_recon_mb_grp\n << 2) - 1 - (u1_mbaff << 2);\n        ps_dec->s_tran_addrecon.u2_mv_left_inc = ((ps_dec->u1_recon_mb_grp\n >> u1_mbaff) - 1) << (4 + u1_mbaff);\n }\n /**********************************************************************/\n /* High profile related initialization at pictrue level               */\n /**********************************************************************/\n if(ps_seq->u1_profile_idc == HIGH_PROFILE_IDC)\n {\n if((ps_seq->i4_seq_scaling_matrix_present_flag)\n || (ps_pps->i4_pic_scaling_matrix_present_flag))\n {\n            ih264d_form_scaling_matrix_picture(ps_seq, ps_pps, ps_dec);\n            ps_dec->s_high_profile.u1_scaling_present = 1;\n }\n else\n {\n            ih264d_form_default_scaling_matrix(ps_dec);\n }\n\n if(ps_pps->i4_transform_8x8_mode_flag)\n {\n            ps_dec->s_high_profile.u1_transform8x8_present = 1;\n }\n }\n else\n {\n        ih264d_form_default_scaling_matrix(ps_dec);\n }\n\n /* required while reading the transform_size_8x8 u4_flag */\n    ps_dec->s_high_profile.u1_direct_8x8_inference_flag =\n                    ps_seq->u1_direct_8x8_inference_flag;\n    ps_dec->s_high_profile.s_cavlc_ctxt = ps_dec->s_cavlc_ctxt;\n\n    ps_dec->i1_recon_in_thread3_flag = 1;\n    ps_dec->ps_frame_buf_ip_recon = &ps_dec->s_tran_addrecon;\n if(ps_dec->u1_separate_parse)\n {\n        memcpy(&ps_dec->s_tran_addrecon_parse, &ps_dec->s_tran_addrecon,\n sizeof(tfr_ctxt_t));\n if(ps_dec->u4_num_cores >= 3 && ps_dec->i1_recon_in_thread3_flag)\n {\n            memcpy(&ps_dec->s_tran_iprecon, &ps_dec->s_tran_addrecon,\n sizeof(tfr_ctxt_t));\n            ps_dec->ps_frame_buf_ip_recon = &ps_dec->s_tran_iprecon;\n }\n }\n\n\n    ih264d_init_deblk_tfr_ctxt(ps_dec,&(ps_dec->s_pad_mgr), &(ps_dec->s_tran_addrecon),\n                               ps_dec->u2_frm_wd_in_mbs, 0);\n\n    ps_dec->ps_cur_deblk_mb = ps_dec->ps_deblk_pic;\n    ps_dec->u4_cur_deblk_mb_num = 0;\n\n    ps_dec->u4_deblk_mb_x = 0;\n    ps_dec->u4_deblk_mb_y = 0;\n    ps_dec->pu4_wt_ofsts = ps_dec->pu4_wts_ofsts_mat;\n\n    ps_dec->u4_first_slice_in_pic = 0;\n    H264_MUTEX_UNLOCK(&ps_dec->process_disp_mutex);\n return OK;\n}\n", "target": 0, "idx": 176503}
{"func": "WindowStateType TabletModeWindowState::GetMaximizedOrCenteredWindowType(\n    wm::WindowState* window_state) {\n  return (window_state->CanMaximize() &&\n          ::wm::GetTransientParent(window_state->window()) == nullptr)\n             ? WindowStateType::kMaximized\n             : WindowStateType::kNormal;\n}\n", "target": 0, "idx": 150238}
{"func": "static void pdf_run_cs(fz_context *ctx, pdf_processor *proc, const char *name, fz_colorspace *colorspace)\n{\n\tpdf_run_processor *pr = (pdf_run_processor *)proc;\n\tpr->dev->flags &= ~FZ_DEVFLAG_FILLCOLOR_UNDEFINED;\n\tif (!strcmp(name, \"Pattern\"))\n\t\tpdf_set_pattern(ctx, pr, PDF_FILL, NULL, NULL);\n\telse\n\t\tpdf_set_colorspace(ctx, pr, PDF_FILL, colorspace);\n}\n", "target": 0, "idx": 514}
{"func": "ExecuteCodeInTabFunction::~ExecuteCodeInTabFunction() {}\n", "target": 0, "idx": 121531}
{"func": "void ntlm_print_message_fields(NTLM_MESSAGE_FIELDS* fields, const char* name)\n {\n \tWLog_DBG(TAG, \"%s (Len: %\"PRIu16\" MaxLen: %\"PRIu16\" BufferOffset: %\"PRIu32\")\",\n \t         name, fields->Len, fields->MaxLen, fields->BufferOffset);\n\n\tif (fields->Len > 0)\n\t\twinpr_HexDump(TAG, WLOG_DEBUG, fields->Buffer, fields->Len);\n}\n", "target": 1, "idx": 182446}
{"func": "int ceph_pre_init_acls(struct inode *dir, umode_t *mode,\n\t\t       struct ceph_acls_info *info)\n{\n\tstruct posix_acl *acl, *default_acl;\n\tsize_t val_size1 = 0, val_size2 = 0;\n\tstruct ceph_pagelist *pagelist = NULL;\n\tvoid *tmp_buf = NULL;\n\tint err;\n\n\terr = posix_acl_create(dir, mode, &default_acl, &acl);\n\tif (err)\n\t\treturn err;\n\n\tif (acl) {\n\t\tint ret = posix_acl_equiv_mode(acl, mode);\n\t\tif (ret < 0)\n\t\t\tgoto out_err;\n\t\tif (ret == 0) {\n\t\t\tposix_acl_release(acl);\n\t\t\tacl = NULL;\n\t\t}\n\t}\n\n\tif (!default_acl && !acl)\n\t\treturn 0;\n\n\tif (acl)\n\t\tval_size1 = posix_acl_xattr_size(acl->a_count);\n\tif (default_acl)\n\t\tval_size2 = posix_acl_xattr_size(default_acl->a_count);\n\n\terr = -ENOMEM;\n\ttmp_buf = kmalloc(max(val_size1, val_size2), GFP_KERNEL);\n\tif (!tmp_buf)\n\t\tgoto out_err;\n\tpagelist = kmalloc(sizeof(struct ceph_pagelist), GFP_KERNEL);\n\tif (!pagelist)\n\t\tgoto out_err;\n\tceph_pagelist_init(pagelist);\n\n\terr = ceph_pagelist_reserve(pagelist, PAGE_SIZE);\n\tif (err)\n\t\tgoto out_err;\n\n\tceph_pagelist_encode_32(pagelist, acl && default_acl ? 2 : 1);\n\n\tif (acl) {\n\t\tsize_t len = strlen(XATTR_NAME_POSIX_ACL_ACCESS);\n\t\terr = ceph_pagelist_reserve(pagelist, len + val_size1 + 8);\n\t\tif (err)\n\t\t\tgoto out_err;\n\t\tceph_pagelist_encode_string(pagelist, XATTR_NAME_POSIX_ACL_ACCESS,\n\t\t\t\t\t    len);\n\t\terr = posix_acl_to_xattr(&init_user_ns, acl,\n\t\t\t\t\t tmp_buf, val_size1);\n\t\tif (err < 0)\n\t\t\tgoto out_err;\n\t\tceph_pagelist_encode_32(pagelist, val_size1);\n\t\tceph_pagelist_append(pagelist, tmp_buf, val_size1);\n\t}\n\tif (default_acl) {\n\t\tsize_t len = strlen(XATTR_NAME_POSIX_ACL_DEFAULT);\n\t\terr = ceph_pagelist_reserve(pagelist, len + val_size2 + 8);\n\t\tif (err)\n\t\t\tgoto out_err;\n\t\terr = ceph_pagelist_encode_string(pagelist,\n\t\t\t\t\t\t  XATTR_NAME_POSIX_ACL_DEFAULT, len);\n\t\terr = posix_acl_to_xattr(&init_user_ns, default_acl,\n\t\t\t\t\t tmp_buf, val_size2);\n\t\tif (err < 0)\n\t\t\tgoto out_err;\n\t\tceph_pagelist_encode_32(pagelist, val_size2);\n\t\tceph_pagelist_append(pagelist, tmp_buf, val_size2);\n\t}\n\n\tkfree(tmp_buf);\n\n\tinfo->acl = acl;\n\tinfo->default_acl = default_acl;\n\tinfo->pagelist = pagelist;\n\treturn 0;\n\nout_err:\n\tposix_acl_release(acl);\n\tposix_acl_release(default_acl);\n\tkfree(tmp_buf);\n\tif (pagelist)\n\t\tceph_pagelist_release(pagelist);\n\treturn err;\n}\n", "target": 0, "idx": 50319}
{"func": "static void follow_to_parent(struct path *path)\n{\n\tstruct dentry *dp;\n\n\twhile (path->dentry == path->mnt->mnt_root && follow_up(path))\n\t\t;\n\tdp = dget_parent(path->dentry);\n\tdput(path->dentry);\n\tpath->dentry = dp;\n}\n", "target": 0, "idx": 65874}
{"func": "__weak int kvm_arch_mmu_notifier_invalidate_range(struct kvm *kvm,\n\t\tunsigned long start, unsigned long end, bool blockable)\n{\n\treturn 0;\n}\n", "target": 0, "idx": 91551}
{"func": "static int StreamTcp4WHSTest02 (void)\n{\n    int ret = 0;\n    Packet *p = SCMalloc(SIZE_OF_PACKET);\n    if (unlikely(p == NULL))\n        return 0;\n    Flow f;\n    ThreadVars tv;\n    StreamTcpThread stt;\n    TCPHdr tcph;\n    memset(p, 0, SIZE_OF_PACKET);\n    PacketQueue pq;\n    memset(&pq,0,sizeof(PacketQueue));\n    memset (&f, 0, sizeof(Flow));\n    memset(&tv, 0, sizeof (ThreadVars));\n    memset(&stt, 0, sizeof (StreamTcpThread));\n    memset(&tcph, 0, sizeof (TCPHdr));\n    FLOW_INITIALIZE(&f);\n    p->flow = &f;\n\n    StreamTcpUTInit(&stt.ra_ctx);\n\n    tcph.th_win = htons(5480);\n    tcph.th_seq = htonl(10);\n    tcph.th_ack = 0;\n    tcph.th_flags = TH_SYN;\n    p->tcph = &tcph;\n\n    if (StreamTcpPacket(&tv, p, &stt, &pq) == -1)\n        goto end;\n\n    p->tcph->th_seq = htonl(20);\n    p->tcph->th_ack = 0;\n    p->tcph->th_flags = TH_SYN;\n    p->flowflags = FLOW_PKT_TOCLIENT;\n\n    if (StreamTcpPacket(&tv, p, &stt, &pq) == -1)\n        goto end;\n\n    if ((!(((TcpSession *)(p->flow->protoctx))->flags & STREAMTCP_FLAG_4WHS))) {\n        printf(\"STREAMTCP_FLAG_4WHS flag not set: \");\n        goto end;\n    }\n\n    p->tcph->th_seq = htonl(30);\n    p->tcph->th_ack = htonl(21); /* the SYN/ACK uses the SEQ from the first SYN pkt */\n    p->tcph->th_flags = TH_SYN|TH_ACK;\n    p->flowflags = FLOW_PKT_TOSERVER;\n\n    if (StreamTcpPacket(&tv, p, &stt, &pq) != -1) {\n        printf(\"SYN/ACK pkt not rejected but it should have: \");\n        goto end;\n    }\n\n    ret = 1;\nend:\n    StreamTcpSessionClear(p->flow->protoctx);\n    SCFree(p);\n    FLOW_DESTROY(&f);\n    StreamTcpUTDeinit(stt.ra_ctx);\n    return ret;\n}\n", "target": 0, "idx": 79179}
{"func": "static int __init sha512_ssse3_mod_init(void)\n{\n\t/* test for SSSE3 first */\n\tif (cpu_has_ssse3)\n\t\tsha512_transform_asm = sha512_transform_ssse3;\n\n#ifdef CONFIG_AS_AVX\n\t/* allow AVX to override SSSE3, it's a little faster */\n\tif (avx_usable()) {\n#ifdef CONFIG_AS_AVX2\n\t\tif (boot_cpu_has(X86_FEATURE_AVX2))\n\t\t\tsha512_transform_asm = sha512_transform_rorx;\n\t\telse\n#endif\n\t\t\tsha512_transform_asm = sha512_transform_avx;\n\t}\n#endif\n\n\tif (sha512_transform_asm) {\n#ifdef CONFIG_AS_AVX\n\t\tif (sha512_transform_asm == sha512_transform_avx)\n\t\t\tpr_info(\"Using AVX optimized SHA-512 implementation\\n\");\n#ifdef CONFIG_AS_AVX2\n\t\telse if (sha512_transform_asm == sha512_transform_rorx)\n\t\t\tpr_info(\"Using AVX2 optimized SHA-512 implementation\\n\");\n#endif\n\t\telse\n#endif\n\t\t\tpr_info(\"Using SSSE3 optimized SHA-512 implementation\\n\");\n\t\treturn crypto_register_shashes(algs, ARRAY_SIZE(algs));\n\t}\n\tpr_info(\"Neither AVX nor SSSE3 is available/usable.\\n\");\n\n\treturn -ENODEV;\n}\n", "target": 0, "idx": 47057}
{"func": "WebConnectionType ToWebConnectionType(const String& connection_type) {\n  if (connection_type == protocol::Network::ConnectionTypeEnum::None)\n    return kWebConnectionTypeNone;\n  if (connection_type == protocol::Network::ConnectionTypeEnum::Cellular2g)\n    return kWebConnectionTypeCellular2G;\n  if (connection_type == protocol::Network::ConnectionTypeEnum::Cellular3g)\n    return kWebConnectionTypeCellular3G;\n  if (connection_type == protocol::Network::ConnectionTypeEnum::Cellular4g)\n    return kWebConnectionTypeCellular4G;\n  if (connection_type == protocol::Network::ConnectionTypeEnum::Bluetooth)\n    return kWebConnectionTypeBluetooth;\n  if (connection_type == protocol::Network::ConnectionTypeEnum::Ethernet)\n    return kWebConnectionTypeEthernet;\n  if (connection_type == protocol::Network::ConnectionTypeEnum::Wifi)\n    return kWebConnectionTypeWifi;\n  if (connection_type == protocol::Network::ConnectionTypeEnum::Wimax)\n    return kWebConnectionTypeWimax;\n  if (connection_type == protocol::Network::ConnectionTypeEnum::Other)\n    return kWebConnectionTypeOther;\n  return kWebConnectionTypeUnknown;\n}\n", "target": 0, "idx": 151202}
{"func": "CJSON_PUBLIC(cJSON_bool) cJSON_IsString(const cJSON * const item)\n{\n    if (item == NULL)\n    {\n        return false;\n    }\n\n    return (item->type & 0xFF) == cJSON_String;\n}\n", "target": 0, "idx": 87078}
{"func": "static void overloadedActivityLoggedMethod2Method(const v8::FunctionCallbackInfo<v8::Value>& info)\n{\n    ExceptionState exceptionState(ExceptionState::ExecutionContext, \"overloadedActivityLoggedMethod\", \"TestObject\", info.Holder(), info.GetIsolate());\n    if (UNLIKELY(info.Length() < 2)) {\n        exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(2, info.Length()));\n        exceptionState.throwIfNeeded();\n        return;\n    }\n    TestObject* imp = V8TestObject::toNative(info.Holder());\n    V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID(V8StringResource<>, strArg, info[0]);\n    V8TRYCATCH_EXCEPTION_VOID(int, longArg, toInt32(info[1], exceptionState), exceptionState);\n    imp->overloadedActivityLoggedMethod(strArg, longArg);\n}\n", "target": 0, "idx": 130922}
{"func": "job_new (DBusGMethodInvocation *context,\n         const char *job_id,\n         gboolean is_cancellable,\n         Device *device,\n         char **argv,\n         const char *stdin_str,\n         JobCompletedFunc job_completed_func,\n         gboolean udev_settle, /* if TRUE, runs udevsettle before returning if the command succeeded */\n         gpointer user_data,\n         GDestroyNotify user_data_destroy_func)\n{\n  Job *job;\n  gboolean ret;\n  GError *error;\n\n  ret = FALSE;\n  job = NULL;\n\n  PROFILE (\"job_new(id=%s, device=%s): start\", job_id ? job_id : argv[0], device ? device->priv->device_file : \"none\");\n\n  if (device != NULL)\n    {\n      if (device->priv->job != NULL || device->priv->job_in_progress)\n        {\n          throw_error (context, ERROR_BUSY, \"There is already a job running\");\n          goto out;\n        }\n    }\n\n  job = g_new0 (Job, 1);\n  job->context = context;\n  job->device = device != NULL ? DEVICE (g_object_ref (device)) : NULL;\n  job->job_completed_func = job_completed_func;\n  job->user_data = user_data;\n  job->user_data_destroy_func = user_data_destroy_func;\n  job->stderr_fd = -1;\n  job->stdout_fd = -1;\n  job->stdin_fd = -1;\n  job->stdin_str = g_strdup (stdin_str);\n  job->stdin_cursor = job->stdin_str;\n  job->stdout_string = g_string_sized_new (1024);\n  job->job_id = g_strdup (job_id);\n  job->udev_settle = udev_settle;\n\n  if (device != NULL && job_id != NULL)\n    {\n      g_free (job->device->priv->job_id);\n      job->device->priv->job_id = g_strdup (job_id);\n    }\n\n  error = NULL;\n  if (!g_spawn_async_with_pipes (NULL,\n                                 argv,\n                                 NULL,\n                                 G_SPAWN_SEARCH_PATH | G_SPAWN_DO_NOT_REAP_CHILD,\n                                 NULL,\n                                 NULL,\n                                 &(job->pid),\n                                 stdin_str != NULL ? &(job->stdin_fd) : NULL,\n                                 &(job->stdout_fd),\n                                 &(job->stderr_fd),\n                                 &error))\n    {\n      throw_error (context, ERROR_FAILED, \"Error starting job: %s\", error->message);\n      g_error_free (error);\n      goto out;\n    }\n\n  g_child_watch_add (job->pid, job_child_watch_cb, job);\n\n  job->error_string = g_string_new (\"\");\n  job->error_channel = g_io_channel_unix_new (job->stderr_fd);\n  error = NULL;\n  if (g_io_channel_set_flags (job->error_channel, G_IO_FLAG_NONBLOCK, &error) != G_IO_STATUS_NORMAL)\n    {\n      g_warning (\"Cannon set stderr fd for child to be non blocking: %s\", error->message);\n      g_error_free (error);\n    }\n  job->error_channel_source_id = g_io_add_watch (job->error_channel, G_IO_IN, job_read_error, job);\n\n  job->out_channel = g_io_channel_unix_new (job->stdout_fd);\n  error = NULL;\n  if (g_io_channel_set_flags (job->out_channel, G_IO_FLAG_NONBLOCK, &error) != G_IO_STATUS_NORMAL)\n    {\n      g_warning (\"Cannon set stdout fd for child to be non blocking: %s\", error->message);\n      g_error_free (error);\n    }\n  job->out_channel_source_id = g_io_add_watch (job->out_channel, G_IO_IN, job_read_out, job);\n\n  if (job->stdin_fd >= 0)\n    {\n      job->in_channel = g_io_channel_unix_new (job->stdin_fd);\n      if (g_io_channel_set_flags (job->in_channel, G_IO_FLAG_NONBLOCK, &error) != G_IO_STATUS_NORMAL)\n        {\n          g_warning (\"Cannon set stdin fd for child to be non blocking: %s\", error->message);\n          g_error_free (error);\n        }\n      job->in_channel_source_id = g_io_add_watch (job->in_channel, G_IO_OUT, job_write_in, job);\n    }\n\n  ret = TRUE;\n\n  if (device != NULL && job_id != NULL)\n    {\n      device->priv->job_in_progress = TRUE;\n      device->priv->job_is_cancellable = is_cancellable;\n      device->priv->job_percentage = -1.0;\n      device->priv->job_initiated_by_uid = 0;\n      if (context != NULL)\n        {\n          daemon_local_get_uid (device->priv->daemon, &(device->priv->job_initiated_by_uid), context);\n        }\n\n      device->priv->job = job;\n\n      emit_job_changed (device);\n    }\n\n  if (device != NULL)\n    {\n      g_print (\"helper(pid %5d): launched job %s on %s\\n\", job->pid, argv[0], device->priv->device_file);\n    }\n  else\n    {\n      g_print (\"helper(pid %5d): launched job %s on daemon\\n\", job->pid, argv[0]);\n    }\n\n out:\n  if (!ret && job != NULL)\n    job_free (job);\n  PROFILE (\"job_new(id=%s, device=%s): end\", job_id, device ? device->priv->device_file : \"none\");\n  return ret;\n}\n", "target": 0, "idx": 11728}
{"func": "static int ndp_sock_open(struct ndp *ndp)\n{\n\tint sock;\n\tint ret;\n\tint err;\n\tint val;\n\n\tsock = socket(PF_INET6, SOCK_RAW, IPPROTO_ICMPV6);\n\tif (sock == -1) {\n\t\terr(ndp, \"Failed to create ICMP6 socket.\");\n\t\treturn -errno;\n\t}\n\n\tval = 1;\n\tret = setsockopt(sock, IPPROTO_IPV6, IPV6_RECVPKTINFO,\n\t\t\t &val, sizeof(val));\n\tif (ret == -1) {\n\t\terr(ndp, \"Failed to setsockopt IPV6_RECVPKTINFO.\");\n\t\terr = -errno;\n\t\tgoto close_sock;\n\t}\n\n\tval = 255;\n\tret = setsockopt(sock, IPPROTO_IPV6, IPV6_MULTICAST_HOPS,\n\t\t\t &val, sizeof(val));\n\tif (ret == -1) {\n\t\terr(ndp, \"Failed to setsockopt IPV6_MULTICAST_HOPS.\");\n\t\terr = -errno;\n \t\tgoto close_sock;\n \t}\n \n \tndp->sock = sock;\n \treturn 0;\n close_sock:\n\tclose(sock);\n\treturn err;\n}\n", "target": 1, "idx": 180521}
{"func": " void UserSelectionScreen::FillUserDictionary(\n    user_manager::User* user,\n     bool is_owner,\n     bool is_signin_to_add,\n     proximity_auth::mojom::AuthType auth_type,\n    const std::vector<std::string>* public_session_recommended_locales,\n    base::DictionaryValue* user_dict) {\n  const bool is_public_session =\n      user->GetType() == user_manager::USER_TYPE_PUBLIC_ACCOUNT;\n  const bool is_legacy_supervised_user =\n      user->GetType() == user_manager::USER_TYPE_SUPERVISED;\n  const bool is_child_user = user->GetType() == user_manager::USER_TYPE_CHILD;\n\n  user_dict->SetString(kKeyUsername, user->GetAccountId().Serialize());\n  user_dict->SetString(kKeyEmailAddress, user->display_email());\n  user_dict->SetString(kKeyDisplayName, user->GetDisplayName());\n  user_dict->SetBoolean(kKeyPublicAccount, is_public_session);\n  user_dict->SetBoolean(kKeyLegacySupervisedUser, is_legacy_supervised_user);\n  user_dict->SetBoolean(kKeyChildUser, is_child_user);\n  user_dict->SetBoolean(kKeyDesktopUser, false);\n  user_dict->SetInteger(kKeyInitialAuthType, static_cast<int>(auth_type));\n  user_dict->SetBoolean(kKeySignedIn, user->is_logged_in());\n  user_dict->SetBoolean(kKeyIsOwner, is_owner);\n  user_dict->SetBoolean(kKeyIsActiveDirectory, user->IsActiveDirectoryUser());\n  user_dict->SetBoolean(kKeyAllowFingerprint, AllowFingerprintForUser(user));\n\n  FillMultiProfileUserPrefs(user, user_dict, is_signin_to_add);\n\n  if (is_public_session) {\n    AddPublicSessionDetailsToUserDictionaryEntry(\n        user_dict, public_session_recommended_locales);\n  }\n}\n", "target": 1, "idx": 186168}
{"func": "static struct netdev_queue *dev_pick_tx(struct net_device *dev,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tu16 queue_index;\n\tstruct sock *sk = skb->sk;\n\n\tif (sk_tx_queue_recorded(sk)) {\n\t\tqueue_index = sk_tx_queue_get(sk);\n\t} else {\n\t\tconst struct net_device_ops *ops = dev->netdev_ops;\n\n\t\tif (ops->ndo_select_queue) {\n\t\t\tqueue_index = ops->ndo_select_queue(dev, skb);\n\t\t\tqueue_index = dev_cap_txqueue(dev, queue_index);\n\t\t} else {\n\t\t\tqueue_index = 0;\n\t\t\tif (dev->real_num_tx_queues > 1)\n\t\t\t\tqueue_index = skb_tx_hash(dev, skb);\n\n\t\t\tif (sk) {\n\t\t\t\tstruct dst_entry *dst = rcu_dereference_bh(sk->sk_dst_cache);\n\n\t\t\t\tif (dst && skb_dst(skb) == dst)\n\t\t\t\t\tsk_tx_queue_set(sk, queue_index);\n\t\t\t}\n\t\t}\n\t}\n\n\tskb_set_queue_mapping(skb, queue_index);\n\treturn netdev_get_tx_queue(dev, queue_index);\n}\n", "target": 0, "idx": 32132}
{"func": "void V8TestObject::DocumentAttributeAttributeSetterCallback(\n    const v8::FunctionCallbackInfo<v8::Value>& info) {\n  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), \"Blink_TestObject_documentAttribute_Setter\");\n\n  v8::Local<v8::Value> v8_value = info[0];\n\n  test_object_v8_internal::DocumentAttributeAttributeSetter(v8_value, info);\n}\n", "target": 0, "idx": 147351}
{"func": " PassRefPtrWillBeRawPtr<File> DOMFileSystemSync::createFile(const FileEntrySync* fileEntry, ExceptionState& exceptionState)\n {\n     KURL fileSystemURL = createFileSystemURL(fileEntry);\n    RefPtrWillBeRawPtr<CreateFileHelper::CreateFileResult> result(CreateFileHelper::CreateFileResult::create());\n     fileSystem()->createSnapshotFileAndReadMetadata(fileSystemURL, CreateFileHelper::create(result, fileEntry->name(), fileSystemURL, type()));\n     if (result->m_failed) {\n         exceptionState.throwDOMException(result->m_code, \"Could not create '\" + fileEntry->name() + \"'.\");\n        return nullptr;\n    }\n    return result->m_file.get();\n}\n", "target": 1, "idx": 185113}
{"func": "void* sspi_SecureHandleGetUpperPointer(SecHandle* handle)\n {\n \tvoid* pointer;\n \n\tif (!handle)\n \t\treturn NULL;\n \n \tpointer = (void*) ~((size_t) handle->dwUpper);\n\n\treturn pointer;\n}\n", "target": 1, "idx": 180777}
{"func": " void InitializeOriginStatFromOriginRequestSummary(\n     OriginStat* origin,\n     const OriginRequestSummary& summary) {\n  origin->set_origin(summary.origin.spec());\n   origin->set_number_of_hits(1);\n   origin->set_average_position(summary.first_occurrence + 1);\n   origin->set_always_access_network(summary.always_access_network);\n  origin->set_accessed_network(summary.accessed_network);\n}\n", "target": 1, "idx": 186347}
{"func": "bool VaapiVideoDecodeAccelerator::Initialize(media::VideoCodecProfile profile,\n                                             Client* client) {\n  DCHECK_EQ(message_loop_, base::MessageLoop::current());\n\n  client_ptr_factory_.reset(new base::WeakPtrFactory<Client>(client));\n  client_ = client_ptr_factory_->GetWeakPtr();\n\n  base::AutoLock auto_lock(lock_);\n  DCHECK_EQ(state_, kUninitialized);\n  DVLOG(2) << \"Initializing VAVDA, profile: \" << profile;\n\n#if defined(USE_X11)\n  if (gfx::GetGLImplementation() != gfx::kGLImplementationDesktopGL) {\n    DVLOG(1) << \"HW video decode acceleration not available without \"\n                \"DesktopGL (GLX).\";\n    return false;\n  }\n#elif defined(USE_OZONE)\n  if (gfx::GetGLImplementation() != gfx::kGLImplementationEGLGLES2) {\n    DVLOG(1) << \"HW video decode acceleration not available without \"\n             << \"EGLGLES2.\";\n    return false;\n  }\n#endif  // USE_X11\n\n  vaapi_wrapper_ = VaapiWrapper::CreateForVideoCodec(\n      VaapiWrapper::kDecode, profile, base::Bind(&ReportToUMA, VAAPI_ERROR));\n\n  if (!vaapi_wrapper_.get()) {\n    DVLOG(1) << \"Failed initializing VAAPI for profile \" << profile;\n    return false;\n  }\n\n  if (profile >= media::H264PROFILE_MIN && profile <= media::H264PROFILE_MAX) {\n    h264_accelerator_.reset(\n        new VaapiH264Accelerator(this, vaapi_wrapper_.get()));\n    decoder_.reset(new H264Decoder(h264_accelerator_.get()));\n  } else if (profile >= media::VP8PROFILE_MIN &&\n              profile <= media::VP8PROFILE_MAX) {\n     vp8_accelerator_.reset(new VaapiVP8Accelerator(this, vaapi_wrapper_.get()));\n     decoder_.reset(new VP8Decoder(vp8_accelerator_.get()));\n  } else if (profile >= media::VP9PROFILE_MIN &&\n             profile <= media::VP9PROFILE_MAX) {\n    vp9_accelerator_.reset(new VaapiVP9Accelerator(this, vaapi_wrapper_.get()));\n    decoder_.reset(new VP9Decoder(vp9_accelerator_.get()));\n   } else {\n     DLOG(ERROR) << \"Unsupported profile \" << profile;\n     return false;\n  }\n\n  CHECK(decoder_thread_.Start());\n  decoder_thread_task_runner_ = decoder_thread_.task_runner();\n\n  state_ = kIdle;\n  return true;\n}\n", "target": 1, "idx": 183519}
{"func": "juniper_mlfr_print(netdissect_options *ndo,\n                   const struct pcap_pkthdr *h, register const u_char *p)\n{\n        struct juniper_l2info_t l2info;\n\n        l2info.pictype = DLT_JUNIPER_MLFR;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n\n        p+=l2info.header_len;\n\n        /* suppress Bundle-ID if frame was captured on a child-link */\n        if (ndo->ndo_eflag && EXTRACT_32BITS(l2info.cookie) != 1)\n            ND_PRINT((ndo, \"Bundle-ID %u, \", l2info.bundle));\n         switch (l2info.proto) {\n         case (LLC_UI):\n         case (LLC_UI<<8):\n            isoclns_print(ndo, p, l2info.length, l2info.caplen);\n             break;\n         case (LLC_UI<<8 | NLPID_Q933):\n         case (LLC_UI<<8 | NLPID_IP):\n         case (LLC_UI<<8 | NLPID_IP6):\n             /* pass IP{4,6} to the OSI layer for proper link-layer printing */\n            isoclns_print(ndo, p - 1, l2info.length + 1, l2info.caplen + 1);\n             break;\n         default:\n             ND_PRINT((ndo, \"unknown protocol 0x%04x, length %u\", l2info.proto, l2info.length));\n        }\n\n        return l2info.header_len;\n}\n", "target": 1, "idx": 181123}
{"func": "ipv6_dup_options(struct sock *sk, struct ipv6_txoptions *opt)\n{\n\tstruct ipv6_txoptions *opt2;\n\n\topt2 = sock_kmalloc(sk, opt->tot_len, GFP_ATOMIC);\n\tif (opt2) {\n\t\tlong dif = (char *)opt2 - (char *)opt;\n\t\tmemcpy(opt2, opt, opt->tot_len);\n\t\tif (opt2->hopopt)\n\t\t\t*((char **)&opt2->hopopt) += dif;\n\t\tif (opt2->dst0opt)\n\t\t\t*((char **)&opt2->dst0opt) += dif;\n\t\tif (opt2->dst1opt)\n \t\t\t*((char **)&opt2->dst1opt) += dif;\n \t\tif (opt2->srcrt)\n \t\t\t*((char **)&opt2->srcrt) += dif;\n \t}\n \treturn opt2;\n }\n", "target": 1, "idx": 180502}
{"func": "static int ohci_service_iso_td(OHCIState *ohci, struct ohci_ed *ed,\n                               int completion)\n{\n    int dir;\n    size_t len = 0;\n    const char *str = NULL;\n    int pid;\n    int ret;\n    int i;\n    USBDevice *dev;\n    USBEndpoint *ep;\n    struct ohci_iso_td iso_td;\n    uint32_t addr;\n    uint16_t starting_frame;\n    int16_t relative_frame_number;\n    int frame_count;\n    uint32_t start_offset, next_offset, end_offset = 0;\n    uint32_t start_addr, end_addr;\n\n    addr = ed->head & OHCI_DPTR_MASK;\n\n    if (ohci_read_iso_td(ohci, addr, &iso_td)) {\n        trace_usb_ohci_iso_td_read_failed(addr);\n        ohci_die(ohci);\n        return 0;\n    }\n\n    starting_frame = OHCI_BM(iso_td.flags, TD_SF);\n    frame_count = OHCI_BM(iso_td.flags, TD_FC);\n    relative_frame_number = USUB(ohci->frame_number, starting_frame); \n\n    trace_usb_ohci_iso_td_head(\n           ed->head & OHCI_DPTR_MASK, ed->tail & OHCI_DPTR_MASK,\n           iso_td.flags, iso_td.bp, iso_td.next, iso_td.be,\n           ohci->frame_number, starting_frame,\n           frame_count, relative_frame_number);\n    trace_usb_ohci_iso_td_head_offset(\n           iso_td.offset[0], iso_td.offset[1],\n           iso_td.offset[2], iso_td.offset[3],\n           iso_td.offset[4], iso_td.offset[5],\n           iso_td.offset[6], iso_td.offset[7]);\n\n    if (relative_frame_number < 0) {\n        trace_usb_ohci_iso_td_relative_frame_number_neg(relative_frame_number);\n        return 1;\n    } else if (relative_frame_number > frame_count) {\n        /* ISO TD expired - retire the TD to the Done Queue and continue with\n           the next ISO TD of the same ED */\n        trace_usb_ohci_iso_td_relative_frame_number_big(relative_frame_number,\n                                                        frame_count);\n        OHCI_SET_BM(iso_td.flags, TD_CC, OHCI_CC_DATAOVERRUN);\n        ed->head &= ~OHCI_DPTR_MASK;\n        ed->head |= (iso_td.next & OHCI_DPTR_MASK);\n        iso_td.next = ohci->done;\n        ohci->done = addr;\n        i = OHCI_BM(iso_td.flags, TD_DI);\n        if (i < ohci->done_count)\n            ohci->done_count = i;\n        if (ohci_put_iso_td(ohci, addr, &iso_td)) {\n            ohci_die(ohci);\n            return 1;\n        }\n        return 0;\n    }\n\n    dir = OHCI_BM(ed->flags, ED_D);\n    switch (dir) {\n    case OHCI_TD_DIR_IN:\n        str = \"in\";\n        pid = USB_TOKEN_IN;\n        break;\n    case OHCI_TD_DIR_OUT:\n        str = \"out\";\n        pid = USB_TOKEN_OUT;\n        break;\n    case OHCI_TD_DIR_SETUP:\n        str = \"setup\";\n        pid = USB_TOKEN_SETUP;\n        break;\n    default:\n        trace_usb_ohci_iso_td_bad_direction(dir);\n        return 1;\n    }\n\n    if (!iso_td.bp || !iso_td.be) {\n        trace_usb_ohci_iso_td_bad_bp_be(iso_td.bp, iso_td.be);\n        return 1;\n    }\n\n    start_offset = iso_td.offset[relative_frame_number];\n    next_offset = iso_td.offset[relative_frame_number + 1];\n\n    if (!(OHCI_BM(start_offset, TD_PSW_CC) & 0xe) || \n        ((relative_frame_number < frame_count) && \n         !(OHCI_BM(next_offset, TD_PSW_CC) & 0xe))) {\n        trace_usb_ohci_iso_td_bad_cc_not_accessed(start_offset, next_offset);\n        return 1;\n    }\n\n    if ((relative_frame_number < frame_count) && (start_offset > next_offset)) {\n        trace_usb_ohci_iso_td_bad_cc_overrun(start_offset, next_offset);\n        return 1;\n    }\n\n    if ((start_offset & 0x1000) == 0) {\n        start_addr = (iso_td.bp & OHCI_PAGE_MASK) |\n            (start_offset & OHCI_OFFSET_MASK);\n    } else {\n        start_addr = (iso_td.be & OHCI_PAGE_MASK) |\n            (start_offset & OHCI_OFFSET_MASK);\n    }\n\n    if (relative_frame_number < frame_count) {\n        end_offset = next_offset - 1;\n        if ((end_offset & 0x1000) == 0) {\n            end_addr = (iso_td.bp & OHCI_PAGE_MASK) |\n                (end_offset & OHCI_OFFSET_MASK);\n        } else {\n            end_addr = (iso_td.be & OHCI_PAGE_MASK) |\n                (end_offset & OHCI_OFFSET_MASK);\n        }\n    } else {\n        /* Last packet in the ISO TD */\n        end_addr = iso_td.be;\n    }\n\n    if ((start_addr & OHCI_PAGE_MASK) != (end_addr & OHCI_PAGE_MASK)) {\n        len = (end_addr & OHCI_OFFSET_MASK) + 0x1001\n            - (start_addr & OHCI_OFFSET_MASK);\n    } else {\n        len = end_addr - start_addr + 1;\n    }\n\n    if (len && dir != OHCI_TD_DIR_IN) {\n        if (ohci_copy_iso_td(ohci, start_addr, end_addr, ohci->usb_buf, len,\n                             DMA_DIRECTION_TO_DEVICE)) {\n            ohci_die(ohci);\n            return 1;\n        }\n    }\n\n    if (!completion) {\n        bool int_req = relative_frame_number == frame_count &&\n                       OHCI_BM(iso_td.flags, TD_DI) == 0;\n        dev = ohci_find_device(ohci, OHCI_BM(ed->flags, ED_FA));\n        ep = usb_ep_get(dev, pid, OHCI_BM(ed->flags, ED_EN));\n        usb_packet_setup(&ohci->usb_packet, pid, ep, 0, addr, false, int_req);\n        usb_packet_addbuf(&ohci->usb_packet, ohci->usb_buf, len);\n        usb_handle_packet(dev, &ohci->usb_packet);\n        if (ohci->usb_packet.status == USB_RET_ASYNC) {\n            usb_device_flush_ep_queue(dev, ep);\n            return 1;\n        }\n    }\n    if (ohci->usb_packet.status == USB_RET_SUCCESS) {\n        ret = ohci->usb_packet.actual_length;\n    } else {\n        ret = ohci->usb_packet.status;\n    }\n\n    trace_usb_ohci_iso_td_so(start_offset, end_offset, start_addr, end_addr,\n                             str, len, ret);\n\n    /* Writeback */\n    if (dir == OHCI_TD_DIR_IN && ret >= 0 && ret <= len) {\n        /* IN transfer succeeded */\n        if (ohci_copy_iso_td(ohci, start_addr, end_addr, ohci->usb_buf, ret,\n                             DMA_DIRECTION_FROM_DEVICE)) {\n            ohci_die(ohci);\n            return 1;\n        }\n        OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n                    OHCI_CC_NOERROR);\n        OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE, ret);\n    } else if (dir == OHCI_TD_DIR_OUT && ret == len) {\n        /* OUT transfer succeeded */\n        OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n                    OHCI_CC_NOERROR);\n        OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE, 0);\n    } else {\n        if (ret > (ssize_t) len) {\n            trace_usb_ohci_iso_td_data_overrun(ret, len);\n            OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n                        OHCI_CC_DATAOVERRUN);\n            OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE,\n                        len);\n        } else if (ret >= 0) {\n            trace_usb_ohci_iso_td_data_underrun(ret);\n            OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n                        OHCI_CC_DATAUNDERRUN);\n        } else {\n            switch (ret) {\n            case USB_RET_IOERROR:\n            case USB_RET_NODEV:\n                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n                            OHCI_CC_DEVICENOTRESPONDING);\n                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE,\n                            0);\n                break;\n            case USB_RET_NAK:\n            case USB_RET_STALL:\n                trace_usb_ohci_iso_td_nak(ret);\n                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n                            OHCI_CC_STALL);\n                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE,\n                            0);\n                break;\n            default:\n                trace_usb_ohci_iso_td_bad_response(ret);\n                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n                            OHCI_CC_UNDEXPETEDPID);\n                break;\n            }\n        }\n    }\n\n    if (relative_frame_number == frame_count) {\n        /* Last data packet of ISO TD - retire the TD to the Done Queue */\n        OHCI_SET_BM(iso_td.flags, TD_CC, OHCI_CC_NOERROR);\n        ed->head &= ~OHCI_DPTR_MASK;\n        ed->head |= (iso_td.next & OHCI_DPTR_MASK);\n        iso_td.next = ohci->done;\n        ohci->done = addr;\n        i = OHCI_BM(iso_td.flags, TD_DI);\n        if (i < ohci->done_count)\n            ohci->done_count = i;\n    }\n    if (ohci_put_iso_td(ohci, addr, &iso_td)) {\n        ohci_die(ohci);\n    }\n    return 1;\n}\n", "target": 0, "idx": 12618}
{"func": "static Image *ReadSGIImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  MemoryInfo\n    *pixel_info;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *p;\n\n  SGIInfo\n    iris_info;\n\n  size_t\n    bytes_per_pixel,\n    quantum;\n\n  ssize_t\n    count,\n    y,\n    z;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read SGI raster header.\n  */\n  iris_info.magic=ReadBlobMSBShort(image);\n  do\n  {\n    /*\n      Verify SGI identifier.\n    */\n    if (iris_info.magic != 0x01DA)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    iris_info.storage=(unsigned char) ReadBlobByte(image);\n    switch (iris_info.storage)\n    {\n      case 0x00: image->compression=NoCompression; break;\n      case 0x01: image->compression=RLECompression; break;\n      default:\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n    iris_info.bytes_per_pixel=(unsigned char) ReadBlobByte(image);\n    if ((iris_info.bytes_per_pixel == 0) || (iris_info.bytes_per_pixel > 2))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    iris_info.dimension=ReadBlobMSBShort(image);\n    iris_info.columns=ReadBlobMSBShort(image);\n    iris_info.rows=ReadBlobMSBShort(image);\n    iris_info.depth=ReadBlobMSBShort(image);\n    if ((iris_info.depth == 0) || (iris_info.depth > 4))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n     iris_info.minimum_value=ReadBlobMSBLong(image);\n     iris_info.maximum_value=ReadBlobMSBLong(image);\n     iris_info.sans=ReadBlobMSBLong(image);\n    (void) ReadBlob(image,sizeof(iris_info.name),(unsigned char *)\n       iris_info.name);\n     iris_info.name[sizeof(iris_info.name)-1]='\\0';\n     if (*iris_info.name != '\\0')\n       (void) SetImageProperty(image,\"label\",iris_info.name,exception);\n     iris_info.pixel_format=ReadBlobMSBLong(image);\n     if (iris_info.pixel_format != 0)\n       ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n     count=ReadBlob(image,sizeof(iris_info.filler),iris_info.filler);\n    (void) count;\n     image->columns=iris_info.columns;\n     image->rows=iris_info.rows;\n     image->depth=(size_t) MagickMin(iris_info.depth,MAGICKCORE_QUANTUM_DEPTH);\n    if (iris_info.pixel_format == 0)\n      image->depth=(size_t) MagickMin((size_t) 8*iris_info.bytes_per_pixel,\n        MAGICKCORE_QUANTUM_DEPTH);\n    if (iris_info.depth < 3)\n      {\n         image->storage_class=PseudoClass;\n         image->colors=iris_info.bytes_per_pixel > 1 ? 65535 : 256;\n       }\n    if (EOFBlob(image) != MagickFalse)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((image_info->ping != MagickFalse)  && (image_info->number_scenes != 0))\n       if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n         break;\n     status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    /*\n      Allocate SGI pixels.\n    */\n    bytes_per_pixel=(size_t) iris_info.bytes_per_pixel;\n    number_pixels=(MagickSizeType) iris_info.columns*iris_info.rows;\n    if ((4*bytes_per_pixel*number_pixels) != ((MagickSizeType) (size_t)\n        (4*bytes_per_pixel*number_pixels)))\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixel_info=AcquireVirtualMemory(iris_info.columns,iris_info.rows*4*\n      bytes_per_pixel*sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    if ((int) iris_info.storage != 0x01)\n      {\n        unsigned char\n          *scanline;\n\n        /*\n          Read standard image format.\n        */\n        scanline=(unsigned char *) AcquireQuantumMemory(iris_info.columns,\n          bytes_per_pixel*sizeof(*scanline));\n        if (scanline == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        for (z=0; z < (ssize_t) iris_info.depth; z++)\n        {\n          p=pixels+bytes_per_pixel*z;\n          for (y=0; y < (ssize_t) iris_info.rows; y++)\n          {\n            count=ReadBlob(image,bytes_per_pixel*iris_info.columns,scanline);\n            if (EOFBlob(image) != MagickFalse)\n              break;\n            if (bytes_per_pixel == 2)\n              for (x=0; x < (ssize_t) iris_info.columns; x++)\n              {\n                *p=scanline[2*x];\n                *(p+1)=scanline[2*x+1];\n                p+=8;\n              }\n            else\n              for (x=0; x < (ssize_t) iris_info.columns; x++)\n              {\n                *p=scanline[x];\n                p+=4;\n              }\n          }\n        }\n        scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n      }\n    else\n      {\n        MemoryInfo\n          *packet_info;\n\n        size_t\n          *runlength;\n\n        ssize_t\n          offset,\n          *offsets;\n\n        unsigned char\n          *packets;\n\n        unsigned int\n          data_order;\n\n        /*\n          Read runlength-encoded image format.\n        */\n        offsets=(ssize_t *) AcquireQuantumMemory((size_t) iris_info.rows,\n          iris_info.depth*sizeof(*offsets));\n        runlength=(size_t *) AcquireQuantumMemory(iris_info.rows,\n          iris_info.depth*sizeof(*runlength));\n        packet_info=AcquireVirtualMemory((size_t) iris_info.columns+10UL,4UL*\n          sizeof(*packets));\n        if ((offsets == (ssize_t *) NULL) ||\n            (runlength == (size_t *) NULL) ||\n            (packet_info == (MemoryInfo *) NULL))\n          {\n            if (offsets == (ssize_t *) NULL)\n              offsets=(ssize_t *) RelinquishMagickMemory(offsets);\n            if (runlength == (size_t *) NULL)\n              runlength=(size_t *) RelinquishMagickMemory(runlength);\n            if (packet_info == (MemoryInfo *) NULL)\n              packet_info=RelinquishVirtualMemory(packet_info);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        packets=(unsigned char *) GetVirtualMemoryBlob(packet_info);\n        for (i=0; i < (ssize_t) (iris_info.rows*iris_info.depth); i++)\n          offsets[i]=ReadBlobMSBSignedLong(image);\n        for (i=0; i < (ssize_t) (iris_info.rows*iris_info.depth); i++)\n        {\n          runlength[i]=ReadBlobMSBLong(image);\n          if (runlength[i] > (4*(size_t) iris_info.columns+10))\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        }\n        /*\n          Check data order.\n        */\n        offset=0;\n        data_order=0;\n        for (y=0; ((y < (ssize_t) iris_info.rows) && (data_order == 0)); y++)\n          for (z=0; ((z < (ssize_t) iris_info.depth) && (data_order == 0)); z++)\n          {\n            if (offsets[y+z*iris_info.rows] < offset)\n              data_order=1;\n            offset=offsets[y+z*iris_info.rows];\n          }\n        offset=(ssize_t) TellBlob(image);\n        if (data_order == 1)\n          {\n            for (z=0; z < (ssize_t) iris_info.depth; z++)\n            {\n              p=pixels;\n              for (y=0; y < (ssize_t) iris_info.rows; y++)\n              {\n                if (offset != offsets[y+z*iris_info.rows])\n                  {\n                    offset=offsets[y+z*iris_info.rows];\n                    offset=(ssize_t) SeekBlob(image,(ssize_t) offset,SEEK_SET);\n                  }\n                count=ReadBlob(image,(size_t) runlength[y+z*iris_info.rows],\n                  packets);\n                if (EOFBlob(image) != MagickFalse)\n                  break;\n                offset+=(ssize_t) runlength[y+z*iris_info.rows];\n                status=SGIDecode(bytes_per_pixel,(ssize_t)\n                  (runlength[y+z*iris_info.rows]/bytes_per_pixel),packets,\n                  1L*iris_info.columns,p+bytes_per_pixel*z);\n                if (status == MagickFalse)\n                  ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n                p+=(iris_info.columns*4*bytes_per_pixel);\n              }\n            }\n          }\n        else\n          {\n            MagickOffsetType\n              position;\n           \n            position=TellBlob(image);\n            p=pixels;\n            for (y=0; y < (ssize_t) iris_info.rows; y++)\n            {\n              for (z=0; z < (ssize_t) iris_info.depth; z++)\n              {\n                if (offset != offsets[y+z*iris_info.rows])\n                  {\n                    offset=offsets[y+z*iris_info.rows];\n                    offset=(ssize_t) SeekBlob(image,(ssize_t) offset,SEEK_SET);\n                  }\n                count=ReadBlob(image,(size_t) runlength[y+z*iris_info.rows],\n                  packets);\n                if (EOFBlob(image) != MagickFalse)\n                  break;\n                offset+=(ssize_t) runlength[y+z*iris_info.rows];\n                status=SGIDecode(bytes_per_pixel,(ssize_t)\n                  (runlength[y+z*iris_info.rows]/bytes_per_pixel),packets,\n                  1L*iris_info.columns,p+bytes_per_pixel*z);\n                if (status == MagickFalse)\n                  ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              }\n              p+=(iris_info.columns*4*bytes_per_pixel);\n            }\n            offset=(ssize_t) SeekBlob(image,position,SEEK_SET);\n          }\n        packet_info=RelinquishVirtualMemory(packet_info);\n        runlength=(size_t *) RelinquishMagickMemory(runlength);\n        offsets=(ssize_t *) RelinquishMagickMemory(offsets);\n      }\n    /*\n      Initialize image structure.\n    */\n    image->alpha_trait=iris_info.depth == 4 ? BlendPixelTrait : \n      UndefinedPixelTrait;\n    image->columns=iris_info.columns;\n    image->rows=iris_info.rows;\n    /*\n      Convert SGI raster image to pixel packets.\n    */\n    if (image->storage_class == DirectClass)\n      {\n        /*\n          Convert SGI image to DirectClass pixel packets.\n        */\n        if (bytes_per_pixel == 2)\n          {\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=pixels+(image->rows-y-1)*8*image->columns;\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                SetPixelRed(image,ScaleShortToQuantum((unsigned short)\n                  ((*(p+0) << 8) | (*(p+1)))),q);\n                SetPixelGreen(image,ScaleShortToQuantum((unsigned short)\n                  ((*(p+2) << 8) | (*(p+3)))),q);\n                SetPixelBlue(image,ScaleShortToQuantum((unsigned short)\n                  ((*(p+4) << 8) | (*(p+5)))),q);\n                SetPixelAlpha(image,OpaqueAlpha,q);\n                if (image->alpha_trait != UndefinedPixelTrait)\n                  SetPixelAlpha(image,ScaleShortToQuantum((unsigned short)\n                    ((*(p+6) << 8) | (*(p+7)))),q);\n                p+=8;\n                q+=GetPixelChannels(image);\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n        else\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=pixels+(image->rows-y-1)*4*image->columns;\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelRed(image,ScaleCharToQuantum(*p),q);\n              SetPixelGreen(image,ScaleCharToQuantum(*(p+1)),q);\n              SetPixelBlue(image,ScaleCharToQuantum(*(p+2)),q);\n              SetPixelAlpha(image,OpaqueAlpha,q);\n              if (image->alpha_trait != UndefinedPixelTrait)\n                SetPixelAlpha(image,ScaleCharToQuantum(*(p+3)),q);\n              p+=4;\n              q+=GetPixelChannels(image);\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                  image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n      }\n    else\n      {\n        /*\n          Create grayscale map.\n        */\n        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        /*\n          Convert SGI image to PseudoClass pixel packets.\n        */\n        if (bytes_per_pixel == 2)\n          {\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=pixels+(image->rows-y-1)*8*image->columns;\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                quantum=(*p << 8);\n                quantum|=(*(p+1));\n                SetPixelIndex(image,(Quantum) quantum,q);\n                p+=8;\n                q+=GetPixelChannels(image);\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n        else\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=pixels+(image->rows-y-1)*4*image->columns;\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelIndex(image,*p,q);\n              p+=4;\n              q+=GetPixelChannels(image);\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        (void) SyncImage(image,exception);\n      }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    iris_info.magic=ReadBlobMSBShort(image);\n    if (iris_info.magic == 0x01DA)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (iris_info.magic == 0x01DA);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n", "target": 1, "idx": 183291}
{"func": "static int xfrm_get_sa(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_usersa_id *p = nlmsg_data(nlh);\n\tstruct xfrm_state *x;\n\tstruct sk_buff *resp_skb;\n\tint err = -ESRCH;\n\n\tx = xfrm_user_state_lookup(net, p, attrs, &err);\n\tif (x == NULL)\n\t\tgoto out_noput;\n\n\tresp_skb = xfrm_state_netlink(skb, x, nlh->nlmsg_seq);\n\tif (IS_ERR(resp_skb)) {\n\t\terr = PTR_ERR(resp_skb);\n\t} else {\n\t\terr = nlmsg_unicast(net->xfrm.nlsk, resp_skb, NETLINK_CB(skb).portid);\n\t}\n\txfrm_state_put(x);\nout_noput:\n\treturn err;\n}\n", "target": 0, "idx": 59367}
{"func": "bool IDNSpoofChecker::Check(base::StringPiece16 label) {\n   UErrorCode status = U_ZERO_ERROR;\n   int32_t result = uspoof_check(checker_, label.data(),\n                                 base::checked_cast<int32_t>(label.size()),\n                                NULL, &status);\n  if (U_FAILURE(status) || (result & USPOOF_ALL_CHECKS))\n    return false;\n\n  icu::UnicodeString label_string(FALSE, label.data(),\n                                  base::checked_cast<int32_t>(label.size()));\n\n  if (deviation_characters_.containsSome(label_string))\n     return false;\n \n   result &= USPOOF_RESTRICTION_LEVEL_MASK;\n  if (result == USPOOF_ASCII ||\n      (result == USPOOF_SINGLE_SCRIPT_RESTRICTIVE &&\n       kana_letters_exceptions_.containsNone(label_string)))\n    return true;\n \n  if (non_ascii_latin_letters_.containsSome(label_string))\n    return false;\n\n  if (!tls_index.initialized())\n    tls_index.Initialize(&OnThreadTermination);\n  icu::RegexMatcher* dangerous_pattern =\n      reinterpret_cast<icu::RegexMatcher*>(tls_index.Get());\n  if (!dangerous_pattern) {\n    dangerous_pattern = new icu::RegexMatcher(\n        icu::UnicodeString(\n            \"[^\\\\p{scx=kana}\\\\p{scx=hira}\\\\p{scx=hani}]\"\n            \"[\\\\u30ce\\\\u30f3\\\\u30bd\\\\u30be]\"\n            \"[^\\\\p{scx=kana}\\\\p{scx=hira}\\\\p{scx=hani}]|\"\n            \"[^\\\\p{scx=kana}\\\\p{scx=hira}]\\\\u30fc|\"\n            \"\\\\u30fc[^\\\\p{scx=kana}\\\\p{scx=hira}]|\"\n            \"^[\\\\p{scx=kana}]+[\\\\u3078-\\\\u307a][\\\\p{scx=kana}]+$|\"\n            \"^[\\\\p{scx=hira}]+[\\\\u30d8-\\\\u30da][\\\\p{scx=hira}]+$|\"\n            \"[a-z]\\\\u30fb|\\\\u30fb[a-z]|\"\n            \"^[\\\\u0585\\\\u0581]+[a-z]|[a-z][\\\\u0585\\\\u0581]+$|\"\n            \"[a-z][\\\\u0585\\\\u0581]+[a-z]|\"\n            \"^[og]+[\\\\p{scx=armn}]|[\\\\p{scx=armn}][og]+$|\"\n            \"[\\\\p{scx=armn}][og]+[\\\\p{scx=armn}]\", -1, US_INV),\n        0, status);\n    tls_index.Set(dangerous_pattern);\n  }\n  dangerous_pattern->reset(label_string);\n   return !dangerous_pattern->find();\n }\n", "target": 1, "idx": 186356}
{"func": "spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n \t\t       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n \t\t       int iov_count)\n {\n    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,\n \t\t\t   iov_count);\n }\n", "target": 1, "idx": 179829}
{"func": "static int Elf_(fix_symbols)(ELFOBJ *bin, int nsym, int type, RBinElfSymbol **sym) {\n\tint count = 0;\n\tRBinElfSymbol *ret = *sym;\n\tRBinElfSymbol *phdr_symbols = (type == R_BIN_ELF_SYMBOLS)\n\t\t\t\t? Elf_(r_bin_elf_get_phdr_symbols) (bin)\n\t\t\t\t: Elf_(r_bin_elf_get_phdr_imports) (bin);\n\tRBinElfSymbol *tmp, *p;\n\tif (phdr_symbols) {\n\t\tRBinElfSymbol *d = ret;\n\t\twhile (!d->last) {\n\t\t\t/* find match in phdr */\n\t\t\tp = phdr_symbols;\n\t\t\twhile (!p->last) {\n\t\t\t\tif (p->offset && d->offset == p->offset) {\n\t\t\t\t\tp->in_shdr = true;\n\t\t\t\t\tif (*p->name && strcmp (d->name, p->name)) {\n\t\t\t\t\t\tstrcpy (d->name, p->name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t}\n\t\t\td++;\n\t\t}\n\t\tp = phdr_symbols;\n\t\twhile (!p->last) {\n\t\t\tif (!p->in_shdr) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tp++;\n\t\t}\n\t\t/*Take those symbols that are not present in the shdr but yes in phdr*/\n\t\t/*This should only should happen with fucked up binaries*/\n\t\tif (count > 0) {\n\t\t\t/*what happens if a shdr says it has only one symbol? we should look anyway into phdr*/\n\t\t\ttmp = (RBinElfSymbol*)realloc (ret, (nsym + count + 1) * sizeof (RBinElfSymbol));\n\t\t\tif (!tmp) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tret = tmp;\n\t\t\tret[nsym--].last = 0;\n\t\t\tp = phdr_symbols;\n\t\t\twhile (!p->last) {\n\t\t\t\tif (!p->in_shdr) {\n\t\t\t\t\tmemcpy (&ret[++nsym], p, sizeof (RBinElfSymbol));\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t}\n\t\t\tret[nsym + 1].last = 1;\n\t\t}\n\t\t*sym = ret;\n\t\treturn nsym + 1;\n\t}\n\treturn nsym;\n}\n", "target": 0, "idx": 60032}
{"func": "php_stream *php_stream_zip_open(char *filename, char *path, char *mode STREAMS_DC TSRMLS_DC)\n{\n\tstruct zip_file *zf = NULL;\n\tint err = 0;\n\n\tphp_stream *stream = NULL;\n\tstruct php_zip_stream_data_t *self;\n\tstruct zip *stream_za;\n\n\tif (strncmp(mode,\"r\", strlen(\"r\")) != 0) {\n\t\treturn NULL;\n\t}\n\n\tif (filename) {\n\t\tif (ZIP_OPENBASEDIR_CHECKPATH(filename)) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* duplicate to make the stream za independent (esp. for MSHUTDOWN) */\n\t\tstream_za = zip_open(filename, ZIP_CREATE, &err);\n\t\tif (!stream_za) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tzf = zip_fopen(stream_za, path, 0);\n\t\tif (zf) {\n                        self = emalloc(sizeof(*self));\n \n                        self->za = stream_za;\n                       self->zf = zf; \n                        self->stream = NULL;\n                        self->cursor = 0;\n                        stream = php_stream_alloc(&php_stream_zipio_ops, self, NULL, mode);\n\t\t\tstream->orig_path = estrdup(path);\n\t\t} else {\n\t\t\tzip_close(stream_za);\n\t\t}\n\t}\n\n\tif (!stream) {\n\t\treturn NULL;\n\t} else {\n\t\treturn stream;\n\t}\n\n}\n", "target": 1, "idx": 178140}
{"func": "void InputHandler::OnSwapCompositorFrame(\n    const viz::CompositorFrameMetadata& frame_metadata) {\n  page_scale_factor_ = frame_metadata.page_scale_factor;\n  scrollable_viewport_size_ = frame_metadata.scrollable_viewport_size;\n}\n", "target": 0, "idx": 161284}
{"func": "xsltNumberFormat(xsltTransformContextPtr ctxt,\n\t\t xsltNumberDataPtr data,\n\t\t xmlNodePtr node)\n{\n    xmlBufferPtr output = NULL;\n     int amount, i;\n     double number;\n     xsltFormat tokens;\n    int tempformat = 0;\n \n    if ((data->format == NULL) && (data->has_format != 0)) {\n\tdata->format = xsltEvalAttrValueTemplate(ctxt, data->node,\n \t\t\t\t\t     (const xmlChar *) \"format\",\n \t\t\t\t\t     XSLT_NAMESPACE);\n\ttempformat = 1;\n    }\n    if (data->format == NULL) {\n\treturn;\n     }\n \n     output = xmlBufferCreate();\n     if (output == NULL)\n \tgoto XSLT_NUMBER_FORMAT_END;\n \n    xsltNumberFormatTokenize(data->format, &tokens);\n     /*\n      * Evaluate the XPath expression to find the value(s)\n      */\n    if (data->value) {\n\tamount = xsltNumberFormatGetValue(ctxt->xpathCtxt,\n\t\t\t\t\t  node,\n\t\t\t\t\t  data->value,\n\t\t\t\t\t  &number);\n\tif (amount == 1) {\n\t    xsltNumberFormatInsertNumbers(data,\n\t\t\t\t\t  &number,\n\t\t\t\t\t  1,\n\t\t\t\t\t  &tokens,\n\t\t\t\t\t  output);\n\t}\n\n    } else if (data->level) {\n\n\tif (xmlStrEqual(data->level, (const xmlChar *) \"single\")) {\n\t    amount = xsltNumberFormatGetMultipleLevel(ctxt,\n\t\t\t\t\t\t      node,\n \t\t\t\t\t\t      data->countPat,\n \t\t\t\t\t\t      data->fromPat,\n \t\t\t\t\t\t      &number,\n\t\t\t\t\t\t      1,\n\t\t\t\t\t\t      data->doc,\n\t\t\t\t\t\t      data->node);\n \t    if (amount == 1) {\n \t\txsltNumberFormatInsertNumbers(data,\n \t\t\t\t\t      &number,\n\t\t\t\t\t      1,\n\t\t\t\t\t      &tokens,\n\t\t\t\t\t      output);\n\t    }\n\t} else if (xmlStrEqual(data->level, (const xmlChar *) \"multiple\")) {\n\t    double numarray[1024];\n\t    int max = sizeof(numarray)/sizeof(numarray[0]);\n\t    amount = xsltNumberFormatGetMultipleLevel(ctxt,\n\t\t\t\t\t\t      node,\n \t\t\t\t\t\t      data->countPat,\n \t\t\t\t\t\t      data->fromPat,\n \t\t\t\t\t\t      numarray,\n\t\t\t\t\t\t      max,\n\t\t\t\t\t\t      data->doc,\n\t\t\t\t\t\t      data->node);\n \t    if (amount > 0) {\n \t\txsltNumberFormatInsertNumbers(data,\n \t\t\t\t\t      numarray,\n\t\t\t\t\t      amount,\n\t\t\t\t\t      &tokens,\n\t\t\t\t\t      output);\n\t    }\n\t} else if (xmlStrEqual(data->level, (const xmlChar *) \"any\")) {\n\t    amount = xsltNumberFormatGetAnyLevel(ctxt,\n \t\t\t\t\t\t node,\n \t\t\t\t\t\t data->countPat,\n \t\t\t\t\t\t data->fromPat,\n\t\t\t\t\t\t &number,\n\t\t\t\t\t\t data->doc,\n\t\t\t\t\t\t data->node);\n \t    if (amount > 0) {\n \t\txsltNumberFormatInsertNumbers(data,\n \t\t\t\t\t      &number,\n\t\t\t\t\t      1,\n\t\t\t\t\t      &tokens,\n\t\t\t\t\t      output);\n\t    }\n\t}\n    }\n     /* Insert number as text node */\n     xsltCopyTextString(ctxt, ctxt->insert, xmlBufferContent(output), 0);\n \n     if (tokens.start != NULL)\n \txmlFree(tokens.start);\n     if (tokens.end != NULL)\n\txmlFree(tokens.end);\n    for (i = 0;i < tokens.nTokens;i++) {\n \tif (tokens.tokens[i].separator != NULL)\n \t    xmlFree(tokens.tokens[i].separator);\n     }\nXSLT_NUMBER_FORMAT_END:\n    if (tempformat == 1) {\n\t/* The format need to be recomputed each time */\n\tdata->format = NULL;\n    }\n    if (output != NULL)\n\txmlBufferFree(output);\n }\n", "target": 1, "idx": 187328}
{"func": " bool IsHighDPIEnabled() {\n  if (CommandLine::ForCurrentProcess()->HasSwitch(\n      switches::kHighDPISupport)) {\n    return CommandLine::ForCurrentProcess()->GetSwitchValueASCII(\n        switches::kHighDPISupport).compare(\"1\") == 0;\n  }\n  return false;\n }\n", "target": 1, "idx": 185603}
{"func": "gsm_xsmp_client_disconnect (GsmXSMPClient *client)\n{\n        if (client->priv->watch_id > 0) {\n                g_source_remove (client->priv->watch_id);\n        }\n\n        if (client->priv->conn != NULL) {\n                SmsCleanUp (client->priv->conn);\n        }\n\n        if (client->priv->ice_connection != NULL) {\n                 IceSetShutdownNegotiation (client->priv->ice_connection, FALSE);\n                 IceCloseConnection (client->priv->ice_connection);\n         }\n        if (client->priv->protocol_timeout > 0) {\n                g_source_remove (client->priv->protocol_timeout);\n        }\n }\n", "target": 1, "idx": 181222}
{"func": "static void m_stop(struct seq_file *m, void *v)\n{\n \tstruct proc_maps_private *priv = m->private;\n \tstruct vm_area_struct *vma = v;\n \n\tvma_stop(priv, vma);\n \tif (priv->task)\n \t\tput_task_struct(priv->task);\n }\n", "target": 1, "idx": 178916}
{"func": "static BOOLEAN btif_hl_find_peer_mdep_id(UINT8 app_id, BD_ADDR bd_addr,\n                                         tBTA_HL_MDEP_ROLE local_mdep_role,\n                                         UINT16 data_type,\n                                         tBTA_HL_MDEP_ID *p_peer_mdep_id){\n    UINT8               app_idx, mcl_idx;\n btif_hl_mcl_cb_t *p_mcb;\n    tBTA_HL_SDP_REC     *p_rec;\n    UINT8               i, num_mdeps;\n    BOOLEAN             found = FALSE;\n    tBTA_HL_MDEP_ROLE   peer_mdep_role;\n\n\n    BTIF_TRACE_DEBUG(\"%s app_id=%d local_mdep_role=%d, data_type=%d\",\n                      __FUNCTION__, app_id, local_mdep_role, data_type);\n\n    BTIF_TRACE_DEBUG(\"DB [%02x:%02x:%02x:%02x:%02x:%02x]\",\n                      bd_addr[0],  bd_addr[1],\n                      bd_addr[2],  bd_addr[3],\n                      bd_addr[4],  bd_addr[5]);\n\n\n    BTIF_TRACE_DEBUG(\"local_mdep_role=%d\", local_mdep_role);\n    BTIF_TRACE_DEBUG(\"data_type=%d\", data_type);\n\n if (local_mdep_role == BTA_HL_MDEP_ROLE_SINK)\n        peer_mdep_role = BTA_HL_MDEP_ROLE_SOURCE;\n else\n        peer_mdep_role = BTA_HL_MDEP_ROLE_SINK;\n\n if (btif_hl_find_app_idx(app_id, &app_idx) )\n {\n        BTIF_HL_GET_APP_CB_PTR(app_idx);\n if (btif_hl_find_mcl_idx(app_idx, bd_addr, &mcl_idx))\n {\n            p_mcb  =BTIF_HL_GET_MCL_CB_PTR(app_idx, mcl_idx);\n\n            BTIF_TRACE_DEBUG(\"app_idx=%d mcl_idx=%d\",app_idx, mcl_idx);\n            BTIF_TRACE_DEBUG(\"valid_spd_idx=%d sdp_idx=%d\",p_mcb->valid_sdp_idx, p_mcb->sdp_idx);\n if (p_mcb->valid_sdp_idx)\n {\n                p_rec = &p_mcb->sdp.sdp_rec[p_mcb->sdp_idx];\n                num_mdeps = p_rec->num_mdeps;\n                BTIF_TRACE_DEBUG(\"num_mdeps=%d\", num_mdeps);\n\n for (i=0; i< num_mdeps; i++)\n {\n                    BTIF_TRACE_DEBUG(\"p_rec->mdep_cfg[%d].mdep_role=%d\",i, p_rec->mdep_cfg[i].mdep_role);\n                    BTIF_TRACE_DEBUG(\"p_rec->mdep_cfg[%d].data_type =%d\",i, p_rec->mdep_cfg[i].data_type );\n if ((p_rec->mdep_cfg[i].mdep_role == peer_mdep_role) &&\n (p_rec->mdep_cfg[i].data_type == data_type))\n {\n                        found = TRUE;\n *p_peer_mdep_id = p_rec->mdep_cfg[i].mdep_id;\n break;\n }\n }\n }\n }\n }\n\n    BTIF_TRACE_DEBUG(\"found =%d  *p_peer_mdep_id=%d\", found, *p_peer_mdep_id);\n\n return found;\n}\n", "target": 0, "idx": 171867}
{"func": "void WebContentsImpl::ShowCreatedFullscreenWidget(int route_id) {\n  ShowCreatedWidget(route_id, true, gfx::Rect());\n}\n", "target": 0, "idx": 119045}
{"func": "static char* get_private_subtags(const char* loc_name)\n {\n \tchar* \tresult =NULL;\n \tint \tsingletonPos = 0;\n\tint \tlen =0; \n \tconst char* \tmod_loc_name =NULL;\n \n \tif( loc_name && (len = strlen(loc_name)>0 ) ){\n\t\tmod_loc_name = loc_name ; \n \t\tlen   = strlen(mod_loc_name);\n \t\twhile( (singletonPos = getSingletonPos(mod_loc_name))!= -1){\n \n\t\t\tif( singletonPos!=-1){ \n\t\t\t\tif( (*(mod_loc_name+singletonPos)=='x') || (*(mod_loc_name+singletonPos)=='X') ){\t\t\n \t\t\t\t\t/* private subtag start found */\n \t\t\t\t\tif( singletonPos + 2 ==  len){\n \t\t\t\t\t\t/* loc_name ends with '-x-' ; return  NULL */\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\t/* result = mod_loc_name + singletonPos +2; */\n\t\t\t\t\t\tresult = estrndup(mod_loc_name + singletonPos+2  , (len -( singletonPos +2) ) );\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif( singletonPos + 1 >=  len){\n\t\t\t\t\t\t/* String end */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* singleton found but not a private subtag , hence check further in the string for the private subtag */\n\t\t\t\t\t\tmod_loc_name = mod_loc_name + singletonPos +1;\n\t\t\t\t\t\tlen = strlen(mod_loc_name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n \n \t\t} /* end of while */\n \t}\n \treturn result;\n }\n", "target": 1, "idx": 180379}
{"func": " l2tp_q931_cc_print(netdissect_options *ndo, const u_char *dat, u_int length)\n {\n \tprint_16bits_val(ndo, (const uint16_t *)dat);\n \tND_PRINT((ndo, \", %02x\", dat[2]));\n\tif (length > 3) {\n \t\tND_PRINT((ndo, \" \"));\n\t\tprint_string(ndo, dat+3, length-3);\n \t}\n }\n", "target": 1, "idx": 181073}
{"func": "static uint16_t transmit_data(serial_data_type_t type, uint8_t *data, uint16_t length) {\n  assert(data != NULL);\n  assert(length > 0);\n\n if (type < DATA_TYPE_COMMAND || type > DATA_TYPE_SCO) {\n    LOG_ERROR(\"%s invalid data type: %d\", __func__, type);\n return 0;\n }\n\n --data;\n uint8_t previous_byte = *data;\n *(data) = type;\n ++length;\n\n \n   uint16_t transmitted_length = 0;\n   while (length > 0) {\n    ssize_t ret = write(uart_fd, data + transmitted_length, length);\n     switch (ret) {\n       case -1:\n         LOG_ERROR(\"In %s, error writing to the uart serial port: %s\", __func__, strerror(errno));\n goto done;\n case 0:\n goto done;\n default:\n        transmitted_length += ret;\n        length -= ret;\n break;\n }\n }\n\ndone:;\n *(data) = previous_byte;\n\n if (transmitted_length > 0)\n --transmitted_length;\n\n return transmitted_length;\n}\n", "target": 1, "idx": 187498}
{"func": "void WebGL2RenderingContextBase::texSubImage3D(GLenum target,\n                                               GLint level,\n                                               GLint xoffset,\n                                               GLint yoffset,\n                                               GLint zoffset,\n                                               GLsizei width,\n                                               GLsizei height,\n                                               GLsizei depth,\n                                               GLenum format,\n                                               GLenum type,\n                                               GLintptr offset) {\n  if (isContextLost())\n    return;\n  if (!ValidateTexture3DBinding(\"texSubImage3D\", target))\n    return;\n  if (!bound_pixel_unpack_buffer_) {\n    SynthesizeGLError(GL_INVALID_OPERATION, \"texSubImage3D\",\n                       \"no bound PIXEL_UNPACK_BUFFER\");\n     return;\n   }\n   if (!ValidateTexFunc(\"texSubImage3D\", kTexSubImage, kSourceUnpackBuffer,\n                        target, level, 0, width, height, depth, 0, format, type,\n                        xoffset, yoffset, zoffset))\n    return;\n  if (!ValidateValueFitNonNegInt32(\"texSubImage3D\", \"offset\", offset))\n    return;\n\n  ContextGL()->TexSubImage3D(target, level, xoffset, yoffset, zoffset, width,\n                             height, depth, format, type,\n                             reinterpret_cast<const void*>(offset));\n}\n", "target": 1, "idx": 186657}
{"func": "node_get_verbose_nickname(const node_t *node,\n                          char *verbose_name_out)\n{\n  const char *nickname = node_get_nickname(node);\n  int is_named = node_is_named(node);\n  verbose_name_out[0] = '$';\n  base16_encode(verbose_name_out+1, HEX_DIGEST_LEN+1, node->identity,\n                DIGEST_LEN);\n  if (!nickname)\n    return;\n  verbose_name_out[1+HEX_DIGEST_LEN] = is_named ? '=' : '~';\n  strlcpy(verbose_name_out+1+HEX_DIGEST_LEN+1, nickname, MAX_NICKNAME_LEN+1);\n}\n", "target": 0, "idx": 69796}
{"func": "void RenderBox::styleDidChange(StyleDifference diff, const RenderStyle* oldStyle)\n{\n    bool oldHorizontalWritingMode = isHorizontalWritingMode();\n\n    RenderBoxModelObject::styleDidChange(diff, oldStyle);\n\n    RenderStyle* newStyle = style();\n    if (needsLayout() && oldStyle) {\n        RenderBlock::removePercentHeightDescendantIfNeeded(this);\n\n        if (isOutOfFlowPositioned() && newStyle->hasStaticBlockPosition(isHorizontalWritingMode()) && oldStyle->marginBefore() != newStyle->marginBefore()\n            && parent() && !parent()->normalChildNeedsLayout())\n            parent()->setChildNeedsLayout();\n    }\n\n    if (RenderBlock::hasPercentHeightContainerMap() && firstChild()\n        && oldHorizontalWritingMode != isHorizontalWritingMode())\n        RenderBlock::clearPercentHeightDescendantsFrom(this);\n\n    if (hasOverflowClip() && oldStyle && newStyle && oldStyle->effectiveZoom() != newStyle->effectiveZoom() && layer()) {\n        if (int left = layer()->scrollableArea()->scrollXOffset()) {\n            left = (left / oldStyle->effectiveZoom()) * newStyle->effectiveZoom();\n            layer()->scrollableArea()->scrollToXOffset(left);\n        }\n        if (int top = layer()->scrollableArea()->scrollYOffset()) {\n            top = (top / oldStyle->effectiveZoom()) * newStyle->effectiveZoom();\n            layer()->scrollableArea()->scrollToYOffset(top);\n        }\n     }\n \n    if (diff == StyleDifferenceRepaint || diff == StyleDifferenceRepaintLayer) {\n         RenderObject* parentToInvalidate = parent();\n         for (unsigned i = 0; i < backgroundObscurationTestMaxDepth && parentToInvalidate; ++i) {\n             parentToInvalidate->invalidateBackgroundObscurationStatus();\n            parentToInvalidate = parentToInvalidate->parent();\n        }\n    }\n\n    if (isDocumentElement() || isBody())\n        document().view()->recalculateScrollbarOverlayStyle();\n\n    updateShapeOutsideInfoAfterStyleChange(*style(), oldStyle);\n    updateGridPositionAfterStyleChange(oldStyle);\n}\n", "target": 1, "idx": 185162}
{"func": "void netdev_run_todo(void)\n{\n\tstruct list_head list;\n\n\t/* Snapshot list, allow later requests */\n\tlist_replace_init(&net_todo_list, &list);\n\n\t__rtnl_unlock();\n\n\n\t/* Wait for rcu callbacks to finish before next phase */\n\tif (!list_empty(&list))\n\t\trcu_barrier();\n\n\twhile (!list_empty(&list)) {\n\t\tstruct net_device *dev\n\t\t\t= list_first_entry(&list, struct net_device, todo_list);\n\t\tlist_del(&dev->todo_list);\n\n\t\trtnl_lock();\n\t\tcall_netdevice_notifiers(NETDEV_UNREGISTER_FINAL, dev);\n\t\t__rtnl_unlock();\n\n\t\tif (unlikely(dev->reg_state != NETREG_UNREGISTERING)) {\n\t\t\tpr_err(\"network todo '%s' but state %d\\n\",\n\t\t\t       dev->name, dev->reg_state);\n\t\t\tdump_stack();\n\t\t\tcontinue;\n\t\t}\n\n\t\tdev->reg_state = NETREG_UNREGISTERED;\n\n\t\tnetdev_wait_allrefs(dev);\n\n\t\t/* paranoia */\n\t\tBUG_ON(netdev_refcnt_read(dev));\n\t\tBUG_ON(!list_empty(&dev->ptype_all));\n\t\tBUG_ON(!list_empty(&dev->ptype_specific));\n\t\tWARN_ON(rcu_access_pointer(dev->ip_ptr));\n\t\tWARN_ON(rcu_access_pointer(dev->ip6_ptr));\n\t\tWARN_ON(dev->dn_ptr);\n\n\t\tif (dev->priv_destructor)\n\t\t\tdev->priv_destructor(dev);\n\t\tif (dev->needs_free_netdev)\n\t\t\tfree_netdev(dev);\n\n\t\t/* Report a network device has been unregistered */\n\t\trtnl_lock();\n\t\tdev_net(dev)->dev_unreg_count--;\n\t\t__rtnl_unlock();\n\t\twake_up(&netdev_unregistering_wq);\n\n\t\t/* Free network device */\n\t\tkobject_put(&dev->dev.kobj);\n\t}\n}\n", "target": 0, "idx": 93429}
{"func": "int get_rock_ridge_filename(struct iso_directory_record *de,\n\t\t\t    char *retname, struct inode *inode)\n{\n\tstruct rock_state rs;\n\tstruct rock_ridge *rr;\n\tint sig;\n \tint retnamlen = 0;\n \tint truncate = 0;\n \tint ret = 0;\n \n \tif (!ISOFS_SB(inode->i_sb)->s_rock)\n \t\treturn 0;\n\t*retname = 0;\n\n\tinit_rock_state(&rs, inode);\n\tsetup_rock_ridge(de, inode, &rs);\nrepeat:\n\n\twhile (rs.len > 2) { /* There may be one byte for padding somewhere */\n\t\trr = (struct rock_ridge *)rs.chr;\n\t\t/*\n\t\t * Ignore rock ridge info if rr->len is out of range, but\n\t\t * don't return -EIO because that would make the file\n\t\t * invisible.\n\t\t */\n\t\tif (rr->len < 3)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\t\tsig = isonum_721(rs.chr);\n\t\tif (rock_check_overflow(&rs, sig))\n\t\t\tgoto eio;\n\t\trs.chr += rr->len;\n\t\trs.len -= rr->len;\n\t\t/*\n\t\t * As above, just ignore the rock ridge info if rr->len\n\t\t * is bogus.\n\t\t */\n\t\tif (rs.len < 0)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\n\t\tswitch (sig) {\n\t\tcase SIG('R', 'R'):\n\t\t\tif ((rr->u.RR.flags[0] & RR_NM) == 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('S', 'P'):\n\t\t\tif (check_sp(rr, inode))\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('C', 'E'):\n\t\t\trs.cont_extent = isonum_733(rr->u.CE.extent);\n\t\t\trs.cont_offset = isonum_733(rr->u.CE.offset);\n\t\t\trs.cont_size = isonum_733(rr->u.CE.size);\n\t\t\tbreak;\n\t\tcase SIG('N', 'M'):\n\t\t\tif (truncate)\n\t\t\t\tbreak;\n\t\t\tif (rr->len < 5)\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * If the flags are 2 or 4, this indicates '.' or '..'.\n\t\t\t * We don't want to do anything with this, because it\n\t\t\t * screws up the code that calls us.  We don't really\n\t\t\t * care anyways, since we can just use the non-RR\n\t\t\t * name.\n\t\t\t */\n\t\t\tif (rr->u.NM.flags & 6)\n\t\t\t\tbreak;\n\n\t\t\tif (rr->u.NM.flags & ~1) {\n\t\t\t\tprintk(\"Unsupported NM flag settings (%d)\\n\",\n \t\t\t\t\trr->u.NM.flags);\n \t\t\t\tbreak;\n \t\t\t}\n\t\t\tif ((strlen(retname) + rr->len - 5) >= 254) {\n \t\t\t\ttruncate = 1;\n \t\t\t\tbreak;\n \t\t\t}\n\t\t\tstrncat(retname, rr->u.NM.name, rr->len - 5);\n\t\t\tretnamlen += rr->len - 5;\n \t\t\tbreak;\n \t\tcase SIG('R', 'E'):\n \t\t\tkfree(rs.buffer);\n\t\t\treturn -1;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tret = rock_continue(&rs);\n\tif (ret == 0)\n\t\tgoto repeat;\n\tif (ret == 1)\n\t\treturn retnamlen; /* If 0, this file did not have a NM field */\nout:\n\tkfree(rs.buffer);\n\treturn ret;\neio:\n\tret = -EIO;\n\tgoto out;\n}\n", "target": 1, "idx": 180396}
{"func": " SProcXFixesSelectCursorInput(ClientPtr client)\n {\n     REQUEST(xXFixesSelectCursorInputReq);\n \n     swaps(&stuff->length);\n     swapl(&stuff->window);\n    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);\n}\n", "target": 1, "idx": 178613}
{"func": "void AutocompleteEditModel::SetInputInProgress(bool in_progress) {\n  if (user_input_in_progress_ == in_progress)\n    return;\n\n  user_input_in_progress_ = in_progress;\n  if (user_input_in_progress_)\n    time_user_first_modified_omnibox_ = base::TimeTicks::Now();\n  controller_->OnInputInProgress(in_progress);\n}\n", "target": 0, "idx": 110812}
{"func": "create_attr_list(gpointer name, gpointer value, gpointer data)\n{\n    int i;\n    const char *filt_str[] = FILTER_STR;\n\n    CRM_CHECK(name != NULL, return);\n\n    /* filtering automatic attributes */\n    for (i = 0; filt_str[i] != NULL; i++) {\n        if (g_str_has_prefix(name, filt_str[i])) {\n            return;\n        }\n    }\n\n    attr_list = g_list_insert_sorted(attr_list, name, compare_attribute);\n}\n", "target": 0, "idx": 33934}
{"func": "static int test_unsigned_long_formatting(void)\n{\n  int i, j;\n  int num_ulong_tests;\n  int failed = 0;\n\n#if (CURL_SIZEOF_LONG == 2)\n\n  i=1; ul_test[i].num = 0xFFFFUL; ul_test[i].expected = \"65535\";\n  i++; ul_test[i].num = 0xFF00UL; ul_test[i].expected = \"65280\";\n  i++; ul_test[i].num = 0x00FFUL; ul_test[i].expected = \"255\";\n\n  i++; ul_test[i].num = 0xF000UL; ul_test[i].expected = \"61440\";\n  i++; ul_test[i].num = 0x0F00UL; ul_test[i].expected = \"3840\";\n  i++; ul_test[i].num = 0x00F0UL; ul_test[i].expected = \"240\";\n  i++; ul_test[i].num = 0x000FUL; ul_test[i].expected = \"15\";\n\n  i++; ul_test[i].num = 0xC000UL; ul_test[i].expected = \"49152\";\n  i++; ul_test[i].num = 0x0C00UL; ul_test[i].expected = \"3072\";\n  i++; ul_test[i].num = 0x00C0UL; ul_test[i].expected = \"192\";\n  i++; ul_test[i].num = 0x000CUL; ul_test[i].expected = \"12\";\n\n  i++; ul_test[i].num = 0x0001UL; ul_test[i].expected = \"1\";\n  i++; ul_test[i].num = 0x0000UL; ul_test[i].expected = \"0\";\n\n  num_ulong_tests = i;\n\n#elif (CURL_SIZEOF_LONG == 4)\n\n  i=1; ul_test[i].num = 0xFFFFFFFFUL; ul_test[i].expected = \"4294967295\";\n  i++; ul_test[i].num = 0xFFFF0000UL; ul_test[i].expected = \"4294901760\";\n  i++; ul_test[i].num = 0x0000FFFFUL; ul_test[i].expected = \"65535\";\n\n  i++; ul_test[i].num = 0xFF000000UL; ul_test[i].expected = \"4278190080\";\n  i++; ul_test[i].num = 0x00FF0000UL; ul_test[i].expected = \"16711680\";\n  i++; ul_test[i].num = 0x0000FF00UL; ul_test[i].expected = \"65280\";\n  i++; ul_test[i].num = 0x000000FFUL; ul_test[i].expected = \"255\";\n\n  i++; ul_test[i].num = 0xF0000000UL; ul_test[i].expected = \"4026531840\";\n  i++; ul_test[i].num = 0x0F000000UL; ul_test[i].expected = \"251658240\";\n  i++; ul_test[i].num = 0x00F00000UL; ul_test[i].expected = \"15728640\";\n  i++; ul_test[i].num = 0x000F0000UL; ul_test[i].expected = \"983040\";\n  i++; ul_test[i].num = 0x0000F000UL; ul_test[i].expected = \"61440\";\n  i++; ul_test[i].num = 0x00000F00UL; ul_test[i].expected = \"3840\";\n  i++; ul_test[i].num = 0x000000F0UL; ul_test[i].expected = \"240\";\n  i++; ul_test[i].num = 0x0000000FUL; ul_test[i].expected = \"15\";\n\n  i++; ul_test[i].num = 0xC0000000UL; ul_test[i].expected = \"3221225472\";\n  i++; ul_test[i].num = 0x0C000000UL; ul_test[i].expected = \"201326592\";\n  i++; ul_test[i].num = 0x00C00000UL; ul_test[i].expected = \"12582912\";\n  i++; ul_test[i].num = 0x000C0000UL; ul_test[i].expected = \"786432\";\n  i++; ul_test[i].num = 0x0000C000UL; ul_test[i].expected = \"49152\";\n  i++; ul_test[i].num = 0x00000C00UL; ul_test[i].expected = \"3072\";\n  i++; ul_test[i].num = 0x000000C0UL; ul_test[i].expected = \"192\";\n  i++; ul_test[i].num = 0x0000000CUL; ul_test[i].expected = \"12\";\n\n  i++; ul_test[i].num = 0x00000001UL; ul_test[i].expected = \"1\";\n  i++; ul_test[i].num = 0x00000000UL; ul_test[i].expected = \"0\";\n\n  num_ulong_tests = i;\n\n#elif (CURL_SIZEOF_LONG == 8)\n\n  i=1; ul_test[i].num = 0xFFFFFFFFFFFFFFFFUL; ul_test[i].expected = \"18446744073709551615\";\n  i++; ul_test[i].num = 0xFFFFFFFF00000000UL; ul_test[i].expected = \"18446744069414584320\";\n  i++; ul_test[i].num = 0x00000000FFFFFFFFUL; ul_test[i].expected = \"4294967295\";\n\n  i++; ul_test[i].num = 0xFFFF000000000000UL; ul_test[i].expected = \"18446462598732840960\";\n  i++; ul_test[i].num = 0x0000FFFF00000000UL; ul_test[i].expected = \"281470681743360\";\n  i++; ul_test[i].num = 0x00000000FFFF0000UL; ul_test[i].expected = \"4294901760\";\n  i++; ul_test[i].num = 0x000000000000FFFFUL; ul_test[i].expected = \"65535\";\n\n  i++; ul_test[i].num = 0xFF00000000000000UL; ul_test[i].expected = \"18374686479671623680\";\n  i++; ul_test[i].num = 0x00FF000000000000UL; ul_test[i].expected = \"71776119061217280\";\n  i++; ul_test[i].num = 0x0000FF0000000000UL; ul_test[i].expected = \"280375465082880\";\n  i++; ul_test[i].num = 0x000000FF00000000UL; ul_test[i].expected = \"1095216660480\";\n  i++; ul_test[i].num = 0x00000000FF000000UL; ul_test[i].expected = \"4278190080\";\n  i++; ul_test[i].num = 0x0000000000FF0000UL; ul_test[i].expected = \"16711680\";\n  i++; ul_test[i].num = 0x000000000000FF00UL; ul_test[i].expected = \"65280\";\n  i++; ul_test[i].num = 0x00000000000000FFUL; ul_test[i].expected = \"255\";\n\n  i++; ul_test[i].num = 0xF000000000000000UL; ul_test[i].expected = \"17293822569102704640\";\n  i++; ul_test[i].num = 0x0F00000000000000UL; ul_test[i].expected = \"1080863910568919040\";\n  i++; ul_test[i].num = 0x00F0000000000000UL; ul_test[i].expected = \"67553994410557440\";\n  i++; ul_test[i].num = 0x000F000000000000UL; ul_test[i].expected = \"4222124650659840\";\n  i++; ul_test[i].num = 0x0000F00000000000UL; ul_test[i].expected = \"263882790666240\";\n  i++; ul_test[i].num = 0x00000F0000000000UL; ul_test[i].expected = \"16492674416640\";\n  i++; ul_test[i].num = 0x000000F000000000UL; ul_test[i].expected = \"1030792151040\";\n  i++; ul_test[i].num = 0x0000000F00000000UL; ul_test[i].expected = \"64424509440\";\n  i++; ul_test[i].num = 0x00000000F0000000UL; ul_test[i].expected = \"4026531840\";\n  i++; ul_test[i].num = 0x000000000F000000UL; ul_test[i].expected = \"251658240\";\n  i++; ul_test[i].num = 0x0000000000F00000UL; ul_test[i].expected = \"15728640\";\n  i++; ul_test[i].num = 0x00000000000F0000UL; ul_test[i].expected = \"983040\";\n  i++; ul_test[i].num = 0x000000000000F000UL; ul_test[i].expected = \"61440\";\n  i++; ul_test[i].num = 0x0000000000000F00UL; ul_test[i].expected = \"3840\";\n  i++; ul_test[i].num = 0x00000000000000F0UL; ul_test[i].expected = \"240\";\n  i++; ul_test[i].num = 0x000000000000000FUL; ul_test[i].expected = \"15\";\n\n  i++; ul_test[i].num = 0xC000000000000000UL; ul_test[i].expected = \"13835058055282163712\";\n  i++; ul_test[i].num = 0x0C00000000000000UL; ul_test[i].expected = \"864691128455135232\";\n  i++; ul_test[i].num = 0x00C0000000000000UL; ul_test[i].expected = \"54043195528445952\";\n  i++; ul_test[i].num = 0x000C000000000000UL; ul_test[i].expected = \"3377699720527872\";\n  i++; ul_test[i].num = 0x0000C00000000000UL; ul_test[i].expected = \"211106232532992\";\n  i++; ul_test[i].num = 0x00000C0000000000UL; ul_test[i].expected = \"13194139533312\";\n  i++; ul_test[i].num = 0x000000C000000000UL; ul_test[i].expected = \"824633720832\";\n  i++; ul_test[i].num = 0x0000000C00000000UL; ul_test[i].expected = \"51539607552\";\n  i++; ul_test[i].num = 0x00000000C0000000UL; ul_test[i].expected = \"3221225472\";\n  i++; ul_test[i].num = 0x000000000C000000UL; ul_test[i].expected = \"201326592\";\n  i++; ul_test[i].num = 0x0000000000C00000UL; ul_test[i].expected = \"12582912\";\n  i++; ul_test[i].num = 0x00000000000C0000UL; ul_test[i].expected = \"786432\";\n  i++; ul_test[i].num = 0x000000000000C000UL; ul_test[i].expected = \"49152\";\n  i++; ul_test[i].num = 0x0000000000000C00UL; ul_test[i].expected = \"3072\";\n  i++; ul_test[i].num = 0x00000000000000C0UL; ul_test[i].expected = \"192\";\n  i++; ul_test[i].num = 0x000000000000000CUL; ul_test[i].expected = \"12\";\n\n  i++; ul_test[i].num = 0x00000001UL; ul_test[i].expected = \"1\";\n  i++; ul_test[i].num = 0x00000000UL; ul_test[i].expected = \"0\";\n\n  num_ulong_tests = i;\n\n#endif\n\n  for(i=1; i<=num_ulong_tests; i++) {\n\n    for(j=0; j<BUFSZ; j++)\n      ul_test[i].result[j] = 'X';\n    ul_test[i].result[BUFSZ-1] = '\\0';\n\n    (void)curl_msprintf(ul_test[i].result, \"%lu\", ul_test[i].num);\n\n    if(memcmp(ul_test[i].result,\n               ul_test[i].expected,\n               strlen(ul_test[i].expected))) {\n      printf(\"unsigned long test #%.2d: Failed (Expected: %s Got: %s)\\n\",\n             i, ul_test[i].expected, ul_test[i].result);\n      failed++;\n    }\n\n  }\n\n  if(!failed)\n    printf(\"All curl_mprintf() unsigned long tests OK!\\n\");\n  else\n    printf(\"Some curl_mprintf() unsigned long tests Failed!\\n\");\n\n  return failed;\n}\n", "target": 0, "idx": 86529}
{"func": " bool WebMediaPlayerImpl::HasSingleSecurityOrigin() const {\n   if (data_source_)\n     return data_source_->HasSingleOrigin();\n   return true;\n}\n", "target": 1, "idx": 187169}
{"func": "status_t OMXNodeInstance::useGraphicBuffer2_l(\n        OMX_U32 portIndex, const sp<GraphicBuffer>& graphicBuffer,\n        OMX::buffer_id *buffer) {\n\n    OMX_PARAM_PORTDEFINITIONTYPE def;\n InitOMXParams(&def);\n    def.nPortIndex = portIndex;\n    OMX_ERRORTYPE err = OMX_GetParameter(mHandle, OMX_IndexParamPortDefinition, &def);\n if (err != OMX_ErrorNone) {\n        OMX_INDEXTYPE index = OMX_IndexParamPortDefinition;\n        CLOG_ERROR(getParameter, err, \"%s(%#x): %s:%u\",\n                asString(index), index, portString(portIndex), portIndex);\n\n         return UNKNOWN_ERROR;\n     }\n \n    BufferMeta *bufferMeta = new BufferMeta(graphicBuffer);\n \n     OMX_BUFFERHEADERTYPE *header = NULL;\n     OMX_U8* bufferHandle = const_cast<OMX_U8*>(\n reinterpret_cast<const OMX_U8*>(graphicBuffer->handle));\n\n    err = OMX_UseBuffer(\n            mHandle,\n &header,\n            portIndex,\n            bufferMeta,\n            def.nBufferSize,\n            bufferHandle);\n\n if (err != OMX_ErrorNone) {\n        CLOG_ERROR(useBuffer, err, BUFFER_FMT(portIndex, \"%u@%p\", def.nBufferSize, bufferHandle));\n delete bufferMeta;\n        bufferMeta = NULL;\n *buffer = 0;\n return StatusFromOMXError(err);\n }\n\n    CHECK_EQ(header->pBuffer, bufferHandle);\n    CHECK_EQ(header->pAppPrivate, bufferMeta);\n\n *buffer = makeBufferID(header);\n\n    addActiveBuffer(portIndex, *buffer);\n    CLOG_BUFFER(useGraphicBuffer2, NEW_BUFFER_FMT(\n *buffer, portIndex, \"%u@%p\", def.nBufferSize, bufferHandle));\n return OK;\n}\n", "target": 1, "idx": 187557}
{"func": " xmlParseMisc(xmlParserCtxtPtr ctxt) {\n    while (((RAW == '<') && (NXT(1) == '?')) ||\n           (CMP4(CUR_PTR, '<', '!', '-', '-')) ||\n           IS_BLANK_CH(CUR)) {\n         if ((RAW == '<') && (NXT(1) == '?')) {\n \t    xmlParsePI(ctxt);\n \t} else if (IS_BLANK_CH(CUR)) {\n\t    NEXT;\n\t} else\n\t    xmlParseComment(ctxt);\n    }\n}\n", "target": 1, "idx": 184986}
{"func": "SPL_METHOD(SplFileObject, fread)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tlong length = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &length) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (length <= 0) {\n \t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Length parameter must be greater than 0\");\n \t\tRETURN_FALSE;\n \t}\n \n \tZ_STRVAL_P(return_value) = emalloc(length + 1);\n \tZ_STRLEN_P(return_value) = php_stream_read(intern->u.file.stream, Z_STRVAL_P(return_value), length);\n\n\t/* needed because recv/read/gzread doesnt put a null at the end*/\n\tZ_STRVAL_P(return_value)[Z_STRLEN_P(return_value)] = 0;\n\tZ_TYPE_P(return_value) = IS_STRING;\n}\n", "target": 1, "idx": 180239}
{"func": "   bool ContainOnlyOneKeyboardLayout(\n      const ImeConfigValue& value) {\n    return (value.type == ImeConfigValue::kValueTypeStringList &&\n             value.string_list_value.size() == 1 &&\n            chromeos::input_method::IsKeyboardLayout(\n                 value.string_list_value[0]));\n   }\n", "target": 1, "idx": 183940}
{"func": "std::unique_ptr<content::BluetoothChooser> Browser::RunBluetoothChooser(\n    content::RenderFrameHost* frame,\n    const content::BluetoothChooser::EventHandler& event_handler) {\n  std::unique_ptr<BluetoothChooserController> bluetooth_chooser_controller(\n      new BluetoothChooserController(frame, event_handler));\n\n  std::unique_ptr<BluetoothChooserDesktop> bluetooth_chooser_desktop(\n      new BluetoothChooserDesktop(bluetooth_chooser_controller.get()));\n\n  std::unique_ptr<ChooserBubbleDelegate> chooser_bubble_delegate(\n      new ChooserBubbleDelegate(frame,\n                                std::move(bluetooth_chooser_controller)));\n\n  Browser* browser = chrome::FindBrowserWithWebContents(\n       WebContents::FromRenderFrameHost(frame));\n   BubbleReference bubble_reference = browser->GetBubbleManager()->ShowBubble(\n       std::move(chooser_bubble_delegate));\n \n   return std::move(bluetooth_chooser_desktop);\n }\n", "target": 1, "idx": 187194}
{"func": "static int ras_getint(jas_stream_t *in, int_fast32_t *val)\n{\n\tint x;\n\tint c;\n\tint i;\n\n\tx = 0;\n\tfor (i = 0; i < 4; i++) {\n\t\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t\tx = (x << 8) | (c & 0xff);\n\t}\n\n\t*val = x;\n\treturn 0;\n}\n", "target": 0, "idx": 73013}
{"func": "status_t BnCrypto::onTransact(\n uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {\n switch (code) {\n case INIT_CHECK:\n {\n            CHECK_INTERFACE(ICrypto, data, reply);\n            reply->writeInt32(initCheck());\n\n return OK;\n }\n\n case IS_CRYPTO_SUPPORTED:\n {\n            CHECK_INTERFACE(ICrypto, data, reply);\n uint8_t uuid[16];\n            data.read(uuid, sizeof(uuid));\n            reply->writeInt32(isCryptoSchemeSupported(uuid));\n\n return OK;\n }\n\n case CREATE_PLUGIN:\n {\n            CHECK_INTERFACE(ICrypto, data, reply);\n\n uint8_t uuid[16];\n            data.read(uuid, sizeof(uuid));\n\n size_t opaqueSize = data.readInt32();\n void *opaqueData = NULL;\n\n if (opaqueSize > 0) {\n                opaqueData = malloc(opaqueSize);\n                data.read(opaqueData, opaqueSize);\n }\n\n            reply->writeInt32(createPlugin(uuid, opaqueData, opaqueSize));\n\n if (opaqueData != NULL) {\n                free(opaqueData);\n                opaqueData = NULL;\n }\n\n return OK;\n }\n\n case DESTROY_PLUGIN:\n {\n            CHECK_INTERFACE(ICrypto, data, reply);\n            reply->writeInt32(destroyPlugin());\n\n return OK;\n }\n\n case REQUIRES_SECURE_COMPONENT:\n {\n            CHECK_INTERFACE(ICrypto, data, reply);\n\n const char *mime = data.readCString();\n            reply->writeInt32(requiresSecureDecoderComponent(mime));\n\n return OK;\n }\n\n case DECRYPT:\n {\n            CHECK_INTERFACE(ICrypto, data, reply);\n\n bool secure = data.readInt32() != 0;\n CryptoPlugin::Mode mode = (CryptoPlugin::Mode)data.readInt32();\n\n uint8_t key[16];\n            data.read(key, sizeof(key));\n\n uint8_t iv[16];\n            data.read(iv, sizeof(iv));\n\n size_t totalSize = data.readInt32();\n            sp<IMemory> sharedBuffer =\n                interface_cast<IMemory>(data.readStrongBinder());\n int32_t offset = data.readInt32();\n\n int32_t numSubSamples = data.readInt32();\n\n CryptoPlugin::SubSample *subSamples =\n new CryptoPlugin::SubSample[numSubSamples];\n\n            data.read(\n                    subSamples,\n sizeof(CryptoPlugin::SubSample) * numSubSamples);\n\n void *secureBufferId, *dstPtr;\n if (secure) {\n                secureBufferId = reinterpret_cast<void *>(static_cast<uintptr_t>(data.readInt64()));\n } else {\n                dstPtr = calloc(1, totalSize);\n }\n\n AString errorDetailMsg;\n ssize_t result;\n\n size_t sumSubsampleSizes = 0;\n bool overflow = false;\n for (int32_t i = 0; i < numSubSamples; ++i) {\n CryptoPlugin::SubSample &ss = subSamples[i];\n if (sumSubsampleSizes <= SIZE_MAX - ss.mNumBytesOfEncryptedData) {\n                    sumSubsampleSizes += ss.mNumBytesOfEncryptedData;\n } else {\n                    overflow = true;\n }\n if (sumSubsampleSizes <= SIZE_MAX - ss.mNumBytesOfClearData) {\n                    sumSubsampleSizes += ss.mNumBytesOfClearData;\n } else {\n                    overflow = true;\n }\n }\n\n \n             if (overflow || sumSubsampleSizes != totalSize) {\n                 result = -EINVAL;\n            } else if (offset + totalSize > sharedBuffer->size()) {\n                 result = -EINVAL;\n             } else {\n                 result = decrypt(\n                    secure,\n                    key,\n                    iv,\n                    mode,\n                    sharedBuffer, offset,\n                    subSamples, numSubSamples,\n                    secure ? secureBufferId : dstPtr,\n &errorDetailMsg);\n }\n\n            reply->writeInt32(result);\n\n if (isCryptoError(result)) {\n                reply->writeCString(errorDetailMsg.c_str());\n }\n\n if (!secure) {\n if (result >= 0) {\n                    CHECK_LE(result, static_cast<ssize_t>(totalSize));\n                    reply->write(dstPtr, result);\n }\n                free(dstPtr);\n                dstPtr = NULL;\n }\n\n delete[] subSamples;\n            subSamples = NULL;\n\n return OK;\n }\n\n case NOTIFY_RESOLUTION:\n {\n            CHECK_INTERFACE(ICrypto, data, reply);\n\n int32_t width = data.readInt32();\n int32_t height = data.readInt32();\n            notifyResolution(width, height);\n\n return OK;\n }\n\n case SET_MEDIADRM_SESSION:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n Vector<uint8_t> sessionId;\n            readVector(data, sessionId);\n            reply->writeInt32(setMediaDrmSession(sessionId));\n return OK;\n }\n\n default:\n return BBinder::onTransact(code, data, reply, flags);\n }\n}\n", "target": 1, "idx": 187981}
{"func": "static void relocs_by_sym_free(HtKv *kv) {\n\tfree (kv->key);\n\tfree (kv->value);\n}\n", "target": 0, "idx": 82942}
{"func": "NeXTDecode(TIFF* tif, uint8* buf, tmsize_t occ, uint16 s)\n{\n\tstatic const char module[] = \"NeXTDecode\";\n\tunsigned char *bp, *op;\n\ttmsize_t cc;\n\tuint8* row;\n\ttmsize_t scanline, n;\n\n\t(void) s;\n\t/*\n\t * Each scanline is assumed to start off as all\n\t * white (we assume a PhotometricInterpretation\n\t * of ``min-is-black'').\n\t */\n\tfor (op = (unsigned char*) buf, cc = occ; cc-- > 0;)\n\t\t*op++ = 0xff;\n\n\tbp = (unsigned char *)tif->tif_rawcp;\n\tcc = tif->tif_rawcc;\n\tscanline = tif->tif_scanlinesize;\n\tif (occ % scanline)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"Fractional scanlines cannot be read\");\n\t\treturn (0);\n\t}\n\tfor (row = buf; cc > 0 && occ > 0; occ -= scanline, row += scanline) {\n\t\tn = *bp++, cc--;\n\t\tswitch (n) {\n\t\tcase LITERALROW:\n\t\t\t/*\n\t\t\t * The entire scanline is given as literal values.\n\t\t\t */\n\t\t\tif (cc < scanline)\n\t\t\t\tgoto bad;\n\t\t\t_TIFFmemcpy(row, bp, scanline);\n\t\t\tbp += scanline;\n\t\t\tcc -= scanline;\n\t\t\tbreak;\n\t\tcase LITERALSPAN: {\n\t\t\ttmsize_t off;\n\t\t\t/*\n\t\t\t * The scanline has a literal span that begins at some\n\t\t\t * offset.\n\t\t\t */\n\t\t\tif( cc < 4 )\n\t\t\t\tgoto bad;\n\t\t\toff = (bp[0] * 256) + bp[1];\n\t\t\tn = (bp[2] * 256) + bp[3];\n\t\t\tif (cc < 4+n || off+n > scanline)\n\t\t\t\tgoto bad;\n\t\t\t_TIFFmemcpy(row+off, bp+4, n);\n\t\t\tbp += 4+n;\n\t\t\tcc -= 4+n;\n\t\t\tbreak;\n\t\t}\n\t\tdefault: {\n\t\t\tuint32 npixels = 0, grey;\n \t\t\tuint32 imagewidth = tif->tif_dir.td_imagewidth;\n             if( isTiled(tif) )\n                 imagewidth = tif->tif_dir.td_tilewidth;\n \n \t\t\t/*\n \t\t\t * The scanline is composed of a sequence of constant\n\t\t\t * color ``runs''.  We shift into ``run mode'' and\n\t\t\t * interpret bytes as codes of the form\n\t\t\t * <color><npixels> until we've filled the scanline.\n\t\t\t */\n\t\t\top = row;\n\t\t\tfor (;;) {\n\t\t\t\tgrey = (uint32)((n>>6) & 0x3);\n\t\t\t\tn &= 0x3f;\n\t\t\t\t/*\n\t\t\t\t * Ensure the run does not exceed the scanline\n \t\t\t\t * bounds, potentially resulting in a security\n \t\t\t\t * issue.\n \t\t\t\t */\n\t\t\t\twhile (n-- > 0 && npixels < imagewidth)\n \t\t\t\t\tSETPIXEL(op, grey);\n \t\t\t\tif (npixels >= imagewidth)\n \t\t\t\t\tbreak;\n \t\t\t\tif (cc == 0)\n \t\t\t\t\tgoto bad;\n \t\t\t\tn = *bp++, cc--;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t}\n\ttif->tif_rawcp = (uint8*) bp;\n\ttif->tif_rawcc = cc;\n\treturn (1);\nbad:\n\tTIFFErrorExt(tif->tif_clientdata, module, \"Not enough data for scanline %ld\",\n\t    (long) tif->tif_row);\n\treturn (0);\n}\n", "target": 1, "idx": 180671}
{"func": "static bool vmxnet_tx_pkt_parse_headers(struct VmxnetTxPkt *pkt)\n{\n    struct iovec *l2_hdr, *l3_hdr;\n    size_t bytes_read;\n    size_t full_ip6hdr_len;\n    uint16_t l3_proto;\n\n    assert(pkt);\n\n    l2_hdr = &pkt->vec[VMXNET_TX_PKT_L2HDR_FRAG];\n    l3_hdr = &pkt->vec[VMXNET_TX_PKT_L3HDR_FRAG];\n\n    bytes_read = iov_to_buf(pkt->raw, pkt->raw_frags, 0, l2_hdr->iov_base,\n                            ETH_MAX_L2_HDR_LEN);\n    if (bytes_read < sizeof(struct eth_header)) {\n        l2_hdr->iov_len = 0;\n        return false;\n    }\n\n    l2_hdr->iov_len = sizeof(struct eth_header);\n    switch (be16_to_cpu(PKT_GET_ETH_HDR(l2_hdr->iov_base)->h_proto)) {\n    case ETH_P_VLAN:\n        l2_hdr->iov_len += sizeof(struct vlan_header);\n        break;\n    case ETH_P_DVLAN:\n        l2_hdr->iov_len += 2 * sizeof(struct vlan_header);\n        break;\n    }\n\n    if (bytes_read < l2_hdr->iov_len) {\n        l2_hdr->iov_len = 0;\n        return false;\n    }\n\n    l3_proto = eth_get_l3_proto(l2_hdr->iov_base, l2_hdr->iov_len);\n\n    switch (l3_proto) {\n    case ETH_P_IP:\n        l3_hdr->iov_base = g_malloc(ETH_MAX_IP4_HDR_LEN);\n\n        bytes_read = iov_to_buf(pkt->raw, pkt->raw_frags, l2_hdr->iov_len,\n                                l3_hdr->iov_base, sizeof(struct ip_header));\n\n        if (bytes_read < sizeof(struct ip_header)) {\n            l3_hdr->iov_len = 0;\n            return false;\n         }\n \n         l3_hdr->iov_len = IP_HDR_GET_LEN(l3_hdr->iov_base);\n         pkt->l4proto = ((struct ip_header *) l3_hdr->iov_base)->ip_p;\n \n         /* copy optional IPv4 header data */\n            l3_hdr->iov_len = 0;\n            return false;\n        }\n        break;\n\n    case ETH_P_IPV6:\n        if (!eth_parse_ipv6_hdr(pkt->raw, pkt->raw_frags, l2_hdr->iov_len,\n                               &pkt->l4proto, &full_ip6hdr_len)) {\n            l3_hdr->iov_len = 0;\n            return false;\n        }\n\n        l3_hdr->iov_base = g_malloc(full_ip6hdr_len);\n\n        bytes_read = iov_to_buf(pkt->raw, pkt->raw_frags, l2_hdr->iov_len,\n                                l3_hdr->iov_base, full_ip6hdr_len);\n\n        if (bytes_read < full_ip6hdr_len) {\n            l3_hdr->iov_len = 0;\n            return false;\n        } else {\n            l3_hdr->iov_len = full_ip6hdr_len;\n        }\n        break;\n\n    default:\n        l3_hdr->iov_len = 0;\n        break;\n    }\n", "target": 1, "idx": 178122}
{"func": "void SocketStreamDispatcherHost::OnReceivedData(\n    net::SocketStream* socket, const char* data, int len) {\n  int socket_id = SocketStreamHost::SocketIdFromSocketStream(socket);\n  DVLOG(1) << \"SocketStreamDispatcherHost::OnReceiveData socket_id=\"\n           << socket_id;\n  if (socket_id == content::kNoSocketId) {\n    LOG(ERROR) << \"NoSocketId in OnReceivedData\";\n    return;\n  }\n  if (!Send(new SocketStreamMsg_ReceivedData(\n          socket_id, std::vector<char>(data, data + len)))) {\n    LOG(ERROR) << \"SocketStreamMsg_ReceivedData failed.\";\n    DeleteSocketStreamHost(socket_id);\n  }\n}\n", "target": 0, "idx": 116182}
{"func": "static void key_gc_timer_func(unsigned long data)\n{\n\tkenter(\"\");\n\tkey_gc_next_run = LONG_MAX;\n\tkey_schedule_gc_links();\n}\n", "target": 0, "idx": 41976}
{"func": "X509_ATTRIBUTE *X509_REQ_delete_attr(X509_REQ *req, int loc)\n{\n    return X509at_delete_attr(req->req_info->attributes, loc);\n}\n", "target": 0, "idx": 6202}
{"func": "error::Error GLES2DecoderPassthroughImpl::HandleSetActiveURLCHROMIUM(\n    uint32_t immediate_data_size,\n    const volatile void* cmd_data) {\n  const volatile cmds::SetActiveURLCHROMIUM& c =\n      *static_cast<const volatile cmds::SetActiveURLCHROMIUM*>(cmd_data);\n  Bucket* url_bucket = GetBucket(c.url_bucket_id);\n  static constexpr size_t kMaxStrLen = 1024;\n  if (!url_bucket || url_bucket->size() == 0 ||\n      url_bucket->size() > kMaxStrLen + 1) {\n    return error::kInvalidArguments;\n  }\n\n  size_t size = url_bucket->size() - 1;\n  const char* url_str = url_bucket->GetDataAs<const char*>(0, size);\n  if (!url_str)\n    return error::kInvalidArguments;\n\n  GURL url(base::StringPiece(url_str, size));\n  client()->SetActiveURL(std::move(url));\n  return error::kNoError;\n}\n", "target": 0, "idx": 154471}
{"func": "kg_seal(minor_status, context_handle, conf_req_flag, qop_req,\n        input_message_buffer, conf_state, output_message_buffer, toktype)\n    OM_uint32 *minor_status;\n    gss_ctx_id_t context_handle;\n    int conf_req_flag;\n    gss_qop_t qop_req;\n    gss_buffer_t input_message_buffer;\n    int *conf_state;\n    gss_buffer_t output_message_buffer;\n    int toktype;\n{\n    krb5_gss_ctx_id_rec *ctx;\n    krb5_error_code code;\n    krb5_context context;\n\n    output_message_buffer->length = 0;\n    output_message_buffer->value = NULL;\n\n    /* Only default qop or matching established cryptosystem is allowed.\n\n       There are NO EXTENSIONS to this set for AES and friends!  The\n       new spec says \"just use 0\".  The old spec plus extensions would\n       actually allow for certain non-zero values.  Fix this to handle\n       them later.  */\n    if (qop_req != 0) {\n        *minor_status = (OM_uint32) G_UNKNOWN_QOP;\n        return GSS_S_FAILURE;\n    }\n \n     ctx = (krb5_gss_ctx_id_rec *) context_handle;\n \n    if (! ctx->established) {\n         *minor_status = KG_CTX_INCOMPLETE;\n         return(GSS_S_NO_CONTEXT);\n     }\n\n    context = ctx->k5_context;\n    switch (ctx->proto)\n    {\n    case 0:\n        code = make_seal_token_v1(context, ctx->enc, ctx->seq,\n                                  &ctx->seq_send, ctx->initiate,\n                                  input_message_buffer, output_message_buffer,\n                                  ctx->signalg, ctx->cksum_size, ctx->sealalg,\n                                  conf_req_flag, toktype, ctx->mech_used);\n        break;\n    case 1:\n        code = gss_krb5int_make_seal_token_v3(context, ctx,\n                                              input_message_buffer,\n                                              output_message_buffer,\n                                              conf_req_flag, toktype);\n        break;\n    default:\n        code = G_UNKNOWN_QOP;   /* XXX */\n        break;\n    }\n\n    if (code) {\n        *minor_status = code;\n        save_error_info(*minor_status, context);\n        return(GSS_S_FAILURE);\n    }\n\n    if (conf_state)\n        *conf_state = conf_req_flag;\n\n    *minor_status = 0;\n    return(GSS_S_COMPLETE);\n}\n", "target": 1, "idx": 179989}
{"func": "unsigned int munlock_vma_page(struct page *page)\n{\n \tunsigned int nr_pages;\n \tstruct zone *zone = page_zone(page);\n \n \tBUG_ON(!PageLocked(page));\n \n \t/*\n\t * Serialize with any parallel __split_huge_page_refcount() which\n\t * might otherwise copy PageMlocked to part of the tail pages before\n\t * we clear it in the head page. It also stabilizes hpage_nr_pages().\n\t */\n\tspin_lock_irq(&zone->lru_lock);\n\n\tnr_pages = hpage_nr_pages(page);\n\tif (!TestClearPageMlocked(page))\n\t\tgoto unlock_out;\n\n\t__mod_zone_page_state(zone, NR_MLOCK, -nr_pages);\n\n\tif (__munlock_isolate_lru_page(page, true)) {\n\t\tspin_unlock_irq(&zone->lru_lock);\n\t\t__munlock_isolated_page(page);\n\t\tgoto out;\n\t}\n\t__munlock_isolation_failed(page);\n\nunlock_out:\n\tspin_unlock_irq(&zone->lru_lock);\n\nout:\n\treturn nr_pages - 1;\n}\n", "target": 1, "idx": 179558}
{"func": "__be32 ipv6_select_ident(struct net *net,\n \t\t\t const struct in6_addr *daddr,\n \t\t\t const struct in6_addr *saddr)\n {\n\tstatic u32 ip6_idents_hashrnd __read_mostly;\n \tu32 id;\n \n\tnet_get_random_once(&ip6_idents_hashrnd, sizeof(ip6_idents_hashrnd));\n\tid = __ipv6_select_ident(net, ip6_idents_hashrnd, daddr, saddr);\n \treturn htonl(id);\n }\n", "target": 1, "idx": 182891}
{"func": "WORD32 ixheaacd_complex_anal_filt(ia_esbr_hbe_txposer_struct *ptr_hbe_txposer) {\n  WORD32 idx;\n  WORD32 anal_size = 2 * ptr_hbe_txposer->synth_size;\n  WORD32 N = (10 * anal_size);\n\n for (idx = 0; idx < (ptr_hbe_txposer->no_bins >> 1); idx++) {\n    WORD32 i, j, k, l;\n    FLOAT32 window_output[640];\n    FLOAT32 u[128], u_in[256], u_out[256];\n    FLOAT32 accu_r, accu_i;\n const FLOAT32 *inp_signal;\n    FLOAT32 *anal_buf;\n\n    FLOAT32 *analy_cos_sin_tab = ptr_hbe_txposer->analy_cos_sin_tab;\n const FLOAT32 *interp_window_coeff = ptr_hbe_txposer->analy_wind_coeff;\n    FLOAT32 *x = ptr_hbe_txposer->analy_buf;\n\n    memset(ptr_hbe_txposer->qmf_in_buf[idx + HBE_OPER_WIN_LEN - 1], 0,\n           TWICE_QMF_SYNTH_CHANNELS_NUM * sizeof(FLOAT32));\n\n    inp_signal = ptr_hbe_txposer->ptr_input_buf +\n                 idx * 2 * ptr_hbe_txposer->synth_size + 1;\n    anal_buf = &ptr_hbe_txposer->qmf_in_buf[idx + HBE_OPER_WIN_LEN - 1]\n [4 * ptr_hbe_txposer->k_start];\n\n for (i = N - 1; i >= anal_size; i--) {\n      x[i] = x[i - anal_size];\n }\n\n for (i = anal_size - 1; i >= 0; i--) {\n      x[i] = inp_signal[anal_size - 1 - i];\n }\n\n for (i = 0; i < N; i++) {\n      window_output[i] = x[i] * interp_window_coeff[i];\n }\n\n for (i = 0; i < 2 * anal_size; i++) {\n      accu_r = 0.0;\n for (j = 0; j < 5; j++) {\n        accu_r = accu_r + window_output[i + j * 2 * anal_size];\n }\n      u[i] = accu_r;\n }\n\n if (anal_size == 40) {\n for (i = 1; i < anal_size; i++) {\n        FLOAT32 temp1 = u[i] + u[2 * anal_size - i];\n        FLOAT32 temp2 = u[i] - u[2 * anal_size - i];\n        u[i] = temp1;\n        u[2 * anal_size - i] = temp2;\n }\n\n for (k = 0; k < anal_size; k++) {\n        accu_r = u[anal_size];\n if (k & 1)\n          accu_i = u[0];\n else\n          accu_i = -u[0];\n for (l = 1; l < anal_size; l++) {\n          accu_r = accu_r + u[0 + l] * analy_cos_sin_tab[2 * l + 0];\n          accu_i = accu_i + u[2 * anal_size - l] * analy_cos_sin_tab[2 * l + 1];\n }\n        analy_cos_sin_tab += (2 * anal_size);\n *anal_buf++ = (FLOAT32)accu_r;\n *anal_buf++ = (FLOAT32)accu_i;\n }\n } else {\n      FLOAT32 *ptr_u = u_in;\n      FLOAT32 *ptr_v = u_out;\n for (k = 0; k < anal_size * 2; k++) {\n\n         *ptr_u++ = ((*analy_cos_sin_tab++) * u[k]);\n         *ptr_u++ = ((*analy_cos_sin_tab++) * u[k]);\n       }\n      if (ixheaacd_cmplx_anal_fft != NULL)\n        (*ixheaacd_cmplx_anal_fft)(u_in, u_out, anal_size * 2);\n       else\n         return -1;\n \n for (k = 0; k < anal_size / 2; k++) {\n *(anal_buf + 1) = -*ptr_v++;\n *anal_buf = *ptr_v++;\n\n        anal_buf += 2;\n\n *(anal_buf + 1) = *ptr_v++;\n *anal_buf = -*ptr_v++;\n\n        anal_buf += 2;\n }\n }\n }\n return 0;\n}\n", "target": 1, "idx": 188112}
{"func": "static int p4_pmu_handle_irq(struct pt_regs *regs)\n{\n\tstruct perf_sample_data data;\n\tstruct cpu_hw_events *cpuc;\n\tstruct perf_event *event;\n\tstruct hw_perf_event *hwc;\n\tint idx, handled = 0;\n\tu64 val;\n\n\tperf_sample_data_init(&data, 0);\n\n\tcpuc = &__get_cpu_var(cpu_hw_events);\n\n\tfor (idx = 0; idx < x86_pmu.num_counters; idx++) {\n\t\tint overflow;\n\n\t\tif (!test_bit(idx, cpuc->active_mask)) {\n\t\t\t/* catch in-flight IRQs */\n\t\t\tif (__test_and_clear_bit(idx, cpuc->running))\n\t\t\t\thandled++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tevent = cpuc->events[idx];\n\t\thwc = &event->hw;\n\n\t\tWARN_ON_ONCE(hwc->idx != idx);\n\n\t\t/* it might be unflagged overflow */\n\t\toverflow = p4_pmu_clear_cccr_ovf(hwc);\n\n\t\tval = x86_perf_event_update(event);\n\t\tif (!overflow && (val & (1ULL << (x86_pmu.cntval_bits - 1))))\n\t\t\tcontinue;\n\n\t\thandled += overflow;\n\n\t\t/* event overflow for sure */\n\t\tdata.period = event->hw.last_period;\n \n \t\tif (!x86_perf_event_set_period(event))\n \t\t\tcontinue;\n\t\tif (perf_event_overflow(event, 1, &data, regs))\n \t\t\tx86_pmu_stop(event, 0);\n \t}\n \n\tif (handled)\n\t\tinc_irq_stat(apic_perf_irqs);\n\n\t/*\n\t * When dealing with the unmasking of the LVTPC on P4 perf hw, it has\n\t * been observed that the OVF bit flag has to be cleared first _before_\n\t * the LVTPC can be unmasked.\n\t *\n\t * The reason is the NMI line will continue to be asserted while the OVF\n\t * bit is set.  This causes a second NMI to generate if the LVTPC is\n\t * unmasked before the OVF bit is cleared, leading to unknown NMI\n\t * messages.\n\t */\n\tapic_write(APIC_LVTPC, APIC_DM_NMI);\n\n\treturn handled;\n}\n", "target": 1, "idx": 178994}
{"func": " void MediaStreamManager::CancelRequest(int render_process_id,\n                                        int render_frame_id,\n                                        int page_request_id) {\n   DCHECK_CURRENTLY_ON(BrowserThread::IO);\n   for (const LabeledDeviceRequest& labeled_request : requests_) {\n     DeviceRequest* const request = labeled_request.second;\n     if (request->requesting_process_id == render_process_id &&\n         request->requesting_frame_id == render_frame_id &&\n         request->page_request_id == page_request_id) {\n       CancelRequest(labeled_request.first);\n       return;\n    }\n  }\n}\n", "target": 1, "idx": 187085}
{"func": "void WebMediaPlayerMS::SetRate(double rate) {\n  DCHECK(thread_checker_.CalledOnValidThread());\n}\n", "target": 0, "idx": 157006}
{"func": "tcpmss_mangle_packet(struct sk_buff *skb,\n\t\t     const struct xt_action_param *par,\n\t\t     unsigned int family,\n\t\t     unsigned int tcphoff,\n\t\t     unsigned int minlen)\n{\n\tconst struct xt_tcpmss_info *info = par->targinfo;\n\tstruct tcphdr *tcph;\n\tint len, tcp_hdrlen;\n\tunsigned int i;\n\t__be16 oldval;\n\tu16 newmss;\n\tu8 *opt;\n\n\t/* This is a fragment, no TCP header is available */\n\tif (par->fragoff != 0)\n\t\treturn 0;\n\n\tif (!skb_make_writable(skb, skb->len))\n\t\treturn -1;\n\n\tlen = skb->len - tcphoff;\n\tif (len < (int)sizeof(struct tcphdr))\n\t\treturn -1;\n\n \ttcph = (struct tcphdr *)(skb_network_header(skb) + tcphoff);\n \ttcp_hdrlen = tcph->doff * 4;\n \n\tif (len < tcp_hdrlen)\n \t\treturn -1;\n \n \tif (info->mss == XT_TCPMSS_CLAMP_PMTU) {\n\t\tstruct net *net = xt_net(par);\n\t\tunsigned int in_mtu = tcpmss_reverse_mtu(net, skb, family);\n\t\tunsigned int min_mtu = min(dst_mtu(skb_dst(skb)), in_mtu);\n\n\t\tif (min_mtu <= minlen) {\n\t\t\tnet_err_ratelimited(\"unknown or invalid path-MTU (%u)\\n\",\n\t\t\t\t\t    min_mtu);\n\t\t\treturn -1;\n\t\t}\n\t\tnewmss = min_mtu - minlen;\n\t} else\n\t\tnewmss = info->mss;\n\n\topt = (u_int8_t *)tcph;\n\tfor (i = sizeof(struct tcphdr); i <= tcp_hdrlen - TCPOLEN_MSS; i += optlen(opt, i)) {\n\t\tif (opt[i] == TCPOPT_MSS && opt[i+1] == TCPOLEN_MSS) {\n\t\t\tu_int16_t oldmss;\n\n\t\t\toldmss = (opt[i+2] << 8) | opt[i+3];\n\n\t\t\t/* Never increase MSS, even when setting it, as\n\t\t\t * doing so results in problems for hosts that rely\n\t\t\t * on MSS being set correctly.\n\t\t\t */\n\t\t\tif (oldmss <= newmss)\n\t\t\t\treturn 0;\n\n\t\t\topt[i+2] = (newmss & 0xff00) >> 8;\n\t\t\topt[i+3] = newmss & 0x00ff;\n\n\t\t\tinet_proto_csum_replace2(&tcph->check, skb,\n\t\t\t\t\t\t htons(oldmss), htons(newmss),\n\t\t\t\t\t\t false);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* There is data after the header so the option can't be added\n\t * without moving it, and doing so may make the SYN packet\n\t * itself too large. Accept the packet unmodified instead.\n\t */\n \tif (len > tcp_hdrlen)\n \t\treturn 0;\n \n \t/*\n \t * MSS Option not found ?! add it..\n \t */\n\tif (skb_tailroom(skb) < TCPOLEN_MSS) {\n\t\tif (pskb_expand_head(skb, 0,\n\t\t\t\t     TCPOLEN_MSS - skb_tailroom(skb),\n\t\t\t\t     GFP_ATOMIC))\n\t\t\treturn -1;\n\t\ttcph = (struct tcphdr *)(skb_network_header(skb) + tcphoff);\n\t}\n\n\tskb_put(skb, TCPOLEN_MSS);\n\n\t/*\n\t * IPv4: RFC 1122 states \"If an MSS option is not received at\n\t * connection setup, TCP MUST assume a default send MSS of 536\".\n\t * IPv6: RFC 2460 states IPv6 has a minimum MTU of 1280 and a minimum\n\t * length IPv6 header of 60, ergo the default MSS value is 1220\n\t * Since no MSS was provided, we must use the default values\n\t */\n\tif (xt_family(par) == NFPROTO_IPV4)\n\t\tnewmss = min(newmss, (u16)536);\n\telse\n\t\tnewmss = min(newmss, (u16)1220);\n\n\topt = (u_int8_t *)tcph + sizeof(struct tcphdr);\n\tmemmove(opt + TCPOLEN_MSS, opt, len - sizeof(struct tcphdr));\n\n\tinet_proto_csum_replace2(&tcph->check, skb,\n\t\t\t\t htons(len), htons(len + TCPOLEN_MSS), true);\n\topt[0] = TCPOPT_MSS;\n\topt[1] = TCPOLEN_MSS;\n\topt[2] = (newmss & 0xff00) >> 8;\n\topt[3] = newmss & 0x00ff;\n\n\tinet_proto_csum_replace4(&tcph->check, skb, 0, *((__be32 *)opt), false);\n\n\toldval = ((__be16 *)tcph)[6];\n\ttcph->doff += TCPOLEN_MSS/4;\n\tinet_proto_csum_replace2(&tcph->check, skb,\n\t\t\t\t oldval, ((__be16 *)tcph)[6], false);\n\treturn TCPOLEN_MSS;\n}\n", "target": 1, "idx": 182598}
{"func": "int main(int argc, char **argv) {\n const char *test_name = NULL;\n bool skip_sanity_suite = false;\n\n for (int i = 1; i < argc; ++i) {\n if (!strcmp(\"--help\", argv[i])) {\n      print_usage(argv[0]);\n return 0;\n }\n\n if (!strcmp(\"--insanity\", argv[i])) {\n      skip_sanity_suite = true;\n continue;\n }\n\n if (!is_valid(argv[i])) {\n      printf(\"Error: invalid test name.\\n\");\n      print_usage(argv[0]);\n return -1;\n }\n\n if (test_name != NULL) {\n      printf(\"Error: invalid arguments.\\n\");\n      print_usage(argv[0]);\n return -1;\n }\n\n    test_name = argv[i];\n }\n\n if (is_shell_running()) {\n    printf(\"Run 'adb shell stop' before running %s.\\n\", argv[0]);\n return -1;\n }\n\n config_t *config = config_new(CONFIG_FILE_PATH);\n if (!config) {\n    printf(\"Error: unable to open stack config file.\\n\");\n    print_usage(argv[0]);\n return -1;\n }\n\n for (const config_section_node_t *node = config_section_begin(config); node != config_section_end(config); node = config_section_next(node)) {\n const char *name = config_section_name(node);\n if (config_has_key(config, name, \"LinkKey\") && string_to_bdaddr(name, &bt_remote_bdaddr)) {\n break;\n }\n }\n\n  config_free(config);\n\n if (bdaddr_is_empty(&bt_remote_bdaddr)) {\n    printf(\"Error: unable to find paired device in config file.\\n\");\n    print_usage(argv[0]);\n return -1;\n }\n\n if (!hal_open(callbacks_get_adapter_struct())) {\n    printf(\"Unable to open Bluetooth HAL.\\n\");\n return 1;\n }\n\n if (!btsocket_init()) {\n    printf(\"Unable to initialize Bluetooth sockets.\\n\");\n return 2;\n }\n\n if (!pan_init()) {\n    printf(\"Unable to initialize PAN.\\n\");\n return 3;\n }\n\n if (!gatt_init()) {\n    printf(\"Unable to initialize GATT.\\n\");\n return 4;\n }\n\n  watchdog_running = true;\n  pthread_create(&watchdog_thread, NULL, watchdog_fn, NULL);\n\n static const char *DEFAULT  = \"\\x1b[0m\";\n static const char *GREEN = \"\\x1b[0;32m\";\n static const char *RED   = \"\\x1b[0;31m\";\n\n if (!isatty(fileno(stdout))) {\n    DEFAULT = GREEN = RED = \"\";\n }\n\n int pass = 0;\n int fail = 0;\n int case_num = 0;\n\n if (!skip_sanity_suite) {\n for (size_t i = 0; i < sanity_suite_size; ++i) {\n if (!test_name || !strcmp(test_name, sanity_suite[i].function_name)) {\n        callbacks_init();\n if (sanity_suite[i].function()) {\n          printf(\"[%4d] %-64s [%sPASS%s]\\n\", ++case_num, sanity_suite[i].function_name, GREEN, DEFAULT);\n ++pass;\n } else {\n          printf(\"[%4d] %-64s [%sFAIL%s]\\n\", ++case_num, sanity_suite[i].function_name, RED, DEFAULT);\n ++fail;\n }\n        callbacks_cleanup();\n ++watchdog_id;\n }\n }\n }\n\n if (fail) {\n    printf(\"\\n%sSanity suite failed with %d errors.%s\\n\", RED, fail, DEFAULT);\n    hal_close();\n return 4;\n }\n\n\n   for (size_t i = 0; i < test_suite_size; ++i) {\n     if (!test_name || !strcmp(test_name, test_suite[i].function_name)) {\n       callbacks_init();\n      CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);\n       if (test_suite[i].function()) {\n         printf(\"[%4d] %-64s [%sPASS%s]\\n\", ++case_num, test_suite[i].function_name, GREEN, DEFAULT);\n         ++pass;\n } else {\n        printf(\"[%4d] %-64s [%sFAIL%s]\\n\", ++case_num, test_suite[i].function_name, RED, DEFAULT);\n ++fail;\n }\n      CALL_AND_WAIT(bt_interface->disable(), adapter_state_changed);\n      callbacks_cleanup();\n ++watchdog_id;\n }\n }\n\n  printf(\"\\n\");\n\n if (fail) {\n    printf(\"%d/%d tests failed. See above for failed test cases.\\n\", fail, sanity_suite_size + test_suite_size);\n } else {\n    printf(\"All tests passed!\\n\");\n }\n\n  watchdog_running = false;\n  pthread_join(watchdog_thread, NULL);\n\n  hal_close();\n\n return 0;\n}\n", "target": 1, "idx": 187579}
{"func": "static int cm_alloc_id(struct cm_id_private *cm_id_priv)\n{\n\tunsigned long flags;\n\tint id;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock_irqsave(&cm.lock, flags);\n\n\tid = idr_alloc_cyclic(&cm.local_id_table, cm_id_priv, 0, 0, GFP_NOWAIT);\n\n\tspin_unlock_irqrestore(&cm.lock, flags);\n\tidr_preload_end();\n\n\tcm_id_priv->id.local_id = (__force __be32)id ^ cm.random_id_operand;\n\treturn id < 0 ? id : 0;\n}\n", "target": 0, "idx": 38344}
{"func": "pkinit_C_LoadModule(const char *modname, CK_FUNCTION_LIST_PTR_PTR p11p)\n{\n    void *handle;\n    CK_RV (*getflist)(CK_FUNCTION_LIST_PTR_PTR);\n\n    pkiDebug(\"loading module \\\"%s\\\"... \", modname);\n    handle = dlopen(modname, RTLD_NOW);\n    if (handle == NULL) {\n        pkiDebug(\"not found\\n\");\n        return NULL;\n    }\n    getflist = (CK_RV (*)(CK_FUNCTION_LIST_PTR_PTR)) dlsym(handle, \"C_GetFunctionList\");\n    if (getflist == NULL || (*getflist)(p11p) != CKR_OK) {\n        dlclose(handle);\n        pkiDebug(\"failed\\n\");\n        return NULL;\n    }\n    pkiDebug(\"ok\\n\");\n    return handle;\n}\n", "target": 0, "idx": 33648}
{"func": "void GDataFileSystem::OnGetDocumentEntry(const FilePath& cache_file_path,\n                                         const GetFileFromCacheParams& params,\n                                         GDataErrorCode status,\n                                         scoped_ptr<base::Value> data) {\n  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));\n\n  GDataFileError error = util::GDataToGDataFileError(status);\n\n  scoped_ptr<GDataEntry> fresh_entry;\n   if (error == GDATA_FILE_OK) {\n     scoped_ptr<DocumentEntry> doc_entry(DocumentEntry::ExtractAndParse(*data));\n     if (doc_entry.get()) {\n      fresh_entry.reset(\n          GDataEntry::FromDocumentEntry(NULL, doc_entry.get(),\n                                        directory_service_.get()));\n     }\n     if (!fresh_entry.get() || !fresh_entry->AsGDataFile()) {\n       LOG(ERROR) << \"Got invalid entry from server for \" << params.resource_id;\n      error = GDATA_FILE_ERROR_FAILED;\n    }\n  }\n\n  if (error != GDATA_FILE_OK) {\n    if (!params.get_file_callback.is_null()) {\n      params.get_file_callback.Run(error,\n                                   cache_file_path,\n                                   params.mime_type,\n                                   REGULAR_FILE);\n    }\n    return;\n  }\n\n  GURL content_url = fresh_entry->content_url();\n  int64 file_size = fresh_entry->file_info().size;\n\n  DCHECK_EQ(params.resource_id, fresh_entry->resource_id());\n  scoped_ptr<GDataFile> fresh_entry_as_file(\n      fresh_entry.release()->AsGDataFile());\n  directory_service_->RefreshFile(fresh_entry_as_file.Pass());\n\n  bool* has_enough_space = new bool(false);\n  util::PostBlockingPoolSequencedTaskAndReply(\n      FROM_HERE,\n      blocking_task_runner_,\n      base::Bind(&GDataCache::FreeDiskSpaceIfNeededFor,\n                 base::Unretained(cache_),\n                 file_size,\n                 has_enough_space),\n      base::Bind(&GDataFileSystem::StartDownloadFileIfEnoughSpace,\n                 ui_weak_ptr_,\n                 params,\n                 content_url,\n                 cache_file_path,\n                 base::Owned(has_enough_space)));\n}\n", "target": 1, "idx": 185185}
{"func": "SchedulerObject::submit(AttributeMapType &jobAdMap, std::string &id, std::string &text)\n{\n\tint cluster;\n\tint proc;\n\n    if (!m_codec) {\n        text = \"Codec has not been initialized\";\n        return false;\n    }\n\n\tconst char* required[] = {\n\t\t\t\tATTR_JOB_CMD,\n\t\t\t\tATTR_REQUIREMENTS,\n\t\t\t\tATTR_OWNER,\n\t\t\t\tATTR_JOB_IWD,\n\t\t\t\tNULL\n\t\t\t\t};\n\n\tBeginTransaction();\n\n\tif (-1 == (cluster = NewCluster())) {\n\t\tAbortTransaction();\n\t\ttext = \"Failed to create new cluster\";\n\t\treturn false;\n\t}\n\n\tif (-1 == (proc = NewProc(cluster))) {\n\t\tAbortTransaction();\n\t\ttext = \"Failed to create new proc\";\n\t\treturn false;\n\t}\n\n\n\n\n\n\tClassAd ad;\n\tint universe;\n\n    ad.Assign(ATTR_SHOULD_TRANSFER_FILES, \"NO\");\n\n\tif (!m_codec->mapToClassAd(jobAdMap, ad, text)) {\n\t\tAbortTransaction();\n\t\treturn false;\n\t}\n\n\tstd::string missing;\n\tif (!checkRequiredAttrs(ad, required, missing)) {\n\t\tAbortTransaction();\n\t\ttext = \"Job ad is missing required attributes: \" + missing;\n\t\treturn false;\n\t}\n\n\t::SetAttribute(cluster, proc, ATTR_JOB_STATUS, \"1\"); // 1 = idle\n\n\t::SetAttribute(cluster, proc, ATTR_JOB_REMOTE_USER_CPU, \"0.0\"); // float\n\t::SetAttribute(cluster, proc, ATTR_JOB_PRIO, \"0\");              // int\n\t::SetAttribute(cluster, proc, ATTR_IMAGE_SIZE, \"0\");            // int\n\n\tif (!ad.LookupInteger(ATTR_JOB_UNIVERSE, universe)) {\n\t\tchar* uni_str = param(\"DEFAULT_UNIVERSE\");\n\t\tif (!uni_str) {\n\t\t\tuniverse = CONDOR_UNIVERSE_VANILLA;\n\t\t}\n\t\telse {\n\t\t\tuniverse = CondorUniverseNumber(uni_str);\n\t\t}\n\t\t::SetAttributeInt(cluster, proc, ATTR_JOB_UNIVERSE, universe );\n\t}\n\tif ( universe != CONDOR_UNIVERSE_MPI && universe != CONDOR_UNIVERSE_PVM ) {\n\t\t::SetAttribute(cluster, proc, ATTR_MAX_HOSTS, \"1\");              // int\n\t\t::SetAttribute(cluster, proc, ATTR_MIN_HOSTS, \"1\");            // int\n\t}\n\t::SetAttribute(cluster, proc, ATTR_CURRENT_HOSTS, \"0\"); // int\n\n\tExprTree *expr;\n\tconst char *name;\n\tstd::string value;\n\tad.ResetExpr();\n\twhile (ad.NextExpr(name,expr)) {\n\n\t\tif (!(expr = ad.Lookup(name))) {\n\t\t\tdprintf(D_ALWAYS, \"Failed to lookup %s\\n\", name);\n\n\t\t\tAbortTransaction();\n\t\t\ttext = \"Failed to parse job ad attribute\";\n\t\t\treturn false;\n\t\t}\n\n        value = ExprTreeToString(expr);\n        ::SetAttribute(cluster, proc, name, value.c_str());\n\t}\n\n\tchar buf[22]; // 22 is max size for an id, 2^32 + . + 2^32 + \\0\n\tsnprintf(buf, 22, \"%d\", cluster);\n\t::SetAttribute(cluster, proc, ATTR_CLUSTER_ID, buf);\n\tsnprintf(buf, 22, \"%d\", proc);\n\t::SetAttribute(cluster, proc, ATTR_PROC_ID, buf);\n\tsnprintf(buf, 22, \"%ld\", time(NULL));\n\t::SetAttribute(cluster, proc, ATTR_Q_DATE, buf);\n\n\n\tCommitTransaction();\n\n\n\tscheduler.needReschedule();\n\n\n\tMyString tmp;\n\ttmp.sprintf(\"%d.%d\", cluster, proc);\n\tid = tmp.Value();\n\n\treturn true;\n}\n", "target": 0, "idx": 6649}
{"func": "void SessionModelAssociator::BlockUntilLocalChangeForTest(\n    int64 timeout_milliseconds) {\n  if (!test_method_factory_.empty())\n    return;\n  waiting_for_change_ = true;\n  MessageLoop::current()->PostDelayedTask(\n      FROM_HERE,\n      test_method_factory_.NewRunnableMethod(\n          &SessionModelAssociator::QuitLoopForSubtleTesting),\n      timeout_milliseconds);\n}\n", "target": 0, "idx": 101317}
{"func": "fbFetch_x1b5g5r5 (const FbBits *bits, int x, int width, CARD32 *buffer, miIndexedPtr indexed)\n{\n    const CARD16 *pixel = (const CARD16 *)bits + x;\n    const CARD16 *end = pixel + width;\n    while (pixel < end) {\n        CARD32  p = READ(pixel++);\n        CARD32  r,g,b;\n\n        b = ((p & 0x7c00) | ((p & 0x7000) >> 5)) >> 7;\n        g = ((p & 0x03e0) | ((p & 0x0380) >> 5)) << 6;\n        r = ((p & 0x001c) | ((p & 0x001f) << 5)) << 14;\n        WRITE(buffer++, (0xff000000 | r | g | b));\n    }\n}\n", "target": 0, "idx": 11459}
{"func": "void ipc_rcu_getref(void *ptr)\n {\n\tcontainer_of(ptr, struct ipc_rcu_hdr, data)->refcount++;\n }\n", "target": 1, "idx": 179156}
{"func": "static size_t get_num_req_pgts(struct user_ta_ctx *utc, vaddr_t *begin,\n\t\t\t       vaddr_t *end)\n{\n\tvaddr_t b;\n\tvaddr_t e;\n\n\tif (TAILQ_EMPTY(&utc->vm_info->regions)) {\n\t\tcore_mmu_get_user_va_range(&b, NULL);\n\t\te = b;\n\t} else {\n\t\tstruct vm_region *r;\n\n\t\tb = TAILQ_FIRST(&utc->vm_info->regions)->va;\n\t\tr = TAILQ_LAST(&utc->vm_info->regions, vm_region_head);\n\t\te = r->va + r->size;\n\t\tb = ROUNDDOWN(b, CORE_MMU_PGDIR_SIZE);\n\t\te = ROUNDUP(e, CORE_MMU_PGDIR_SIZE);\n\t}\n\n\tif (begin)\n\t\t*begin = b;\n\tif (end)\n\t\t*end = e;\n\treturn (e - b) >> CORE_MMU_PGDIR_SHIFT;\n}\n", "target": 0, "idx": 86967}
{"func": "  void StartOnIOThread(\n      std::unique_ptr<BuiltinManifestProvider> manifest_provider,\n      service_manager::mojom::ServicePtrInfo packaged_services_service_info) {\n    manifest_provider_ = std::move(manifest_provider);\n    service_manager_ = base::MakeUnique<service_manager::ServiceManager>(\n        base::MakeUnique<NullServiceProcessLauncherFactory>(), nullptr,\n        manifest_provider_.get());\n\n    service_manager::mojom::ServicePtr packaged_services_service;\n    packaged_services_service.Bind(std::move(packaged_services_service_info));\n    service_manager_->RegisterService(\n        service_manager::Identity(mojom::kPackagedServicesServiceName,\n                                  service_manager::mojom::kRootUserID),\n        std::move(packaged_services_service), nullptr);\n  }\n", "target": 0, "idx": 138353}
{"func": "  double visible_fraction() const { return visible_fraction_; }\n", "target": 0, "idx": 145869}
{"func": "  void Wait() { run_loop_.Run(); }\n", "target": 0, "idx": 142531}
{"func": "gss_unwrap_iov (minor_status,\n                context_handle,\n                conf_state,\n                qop_state,\n                iov,\n                iov_count)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\nint *\t\t\tconf_state;\ngss_qop_t\t\t*qop_state;\ngss_iov_buffer_desc  *\tiov;\nint\t\t\tiov_count;\n{\n /* EXPORT DELETE START */\n\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n\n    status = val_unwrap_iov_args(minor_status, context_handle,\n\t\t\t\t conf_state, qop_state, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {\n\tif (mech->gss_unwrap_iov) {\n\t    status = mech->gss_unwrap_iov(\n\t\t\t\t \t  minor_status,\n\t\t\t\t\t  ctx->internal_ctx_id,\n\t\t\t\t\t  conf_state,\n\t\t\t\t\t  qop_state,\n\t\t\t\t\t  iov,\n\t\t\t\t\t  iov_count);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\n\treturn(status);\n    }\n /* EXPORT DELETE END */\n\n    return (GSS_S_BAD_MECH);\n}\n", "target": 1, "idx": 181197}
{"func": "static void update_cursor_data_simple(VirtIOGPU *g,\n                                      struct virtio_gpu_scanout *s,\n                                      uint32_t resource_id)\n{\n    struct virtio_gpu_simple_resource *res;\n    uint32_t pixels;\n\n    res = virtio_gpu_find_resource(g, resource_id);\n    if (!res) {\n        return;\n    }\n\n    if (pixman_image_get_width(res->image)  != s->current_cursor->width ||\n        pixman_image_get_height(res->image) != s->current_cursor->height) {\n        return;\n    }\n\n    pixels = s->current_cursor->width * s->current_cursor->height;\n    memcpy(s->current_cursor->data,\n           pixman_image_get_data(res->image),\n           pixels * sizeof(uint32_t));\n}\n", "target": 0, "idx": 6229}
{"func": "OJPEGVSetField(TIFF* tif, uint32 tag, va_list ap)\n{\n\tstatic const char module[]=\"OJPEGVSetField\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint32 ma;\n\tuint64* mb;\n\tuint32 n;\n\tconst TIFFField* fip;\n\n\tswitch(tag)\n\t{\n\t\tcase TIFFTAG_JPEGIFOFFSET:\n\t\t\tsp->jpeg_interchange_format=(uint64)va_arg(ap,uint64);\n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGIFBYTECOUNT:\n\t\t\tsp->jpeg_interchange_format_length=(uint64)va_arg(ap,uint64);\n\t\t\tbreak;\n\t\tcase TIFFTAG_YCBCRSUBSAMPLING:\n\t\t\tsp->subsampling_tag=1;\n\t\t\tsp->subsampling_hor=(uint8)va_arg(ap,uint16_vap);\n\t\t\tsp->subsampling_ver=(uint8)va_arg(ap,uint16_vap);\n\t\t\ttif->tif_dir.td_ycbcrsubsampling[0]=sp->subsampling_hor;\n\t\t\ttif->tif_dir.td_ycbcrsubsampling[1]=sp->subsampling_ver;\n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGQTABLES:\n\t\t\tma=(uint32)va_arg(ap,uint32);\n\t\t\tif (ma!=0)\n\t\t\t{\n\t\t\t\tif (ma>3)\n\t\t\t\t{\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"JpegQTables tag has incorrect count\");\n\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t\tsp->qtable_offset_count=(uint8)ma;\n\t\t\t\tmb=(uint64*)va_arg(ap,uint64*);\n\t\t\t\tfor (n=0; n<ma; n++)\n\t\t\t\t\tsp->qtable_offset[n]=mb[n];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGDCTABLES:\n\t\t\tma=(uint32)va_arg(ap,uint32);\n\t\t\tif (ma!=0)\n\t\t\t{\n\t\t\t\tif (ma>3)\n\t\t\t\t{\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"JpegDcTables tag has incorrect count\");\n\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t\tsp->dctable_offset_count=(uint8)ma;\n\t\t\t\tmb=(uint64*)va_arg(ap,uint64*);\n\t\t\t\tfor (n=0; n<ma; n++)\n\t\t\t\t\tsp->dctable_offset[n]=mb[n];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGACTABLES:\n\t\t\tma=(uint32)va_arg(ap,uint32);\n\t\t\tif (ma!=0)\n\t\t\t{\n\t\t\t\tif (ma>3)\n\t\t\t\t{\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"JpegAcTables tag has incorrect count\");\n\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t\tsp->actable_offset_count=(uint8)ma;\n\t\t\t\tmb=(uint64*)va_arg(ap,uint64*);\n\t\t\t\tfor (n=0; n<ma; n++)\n\t\t\t\t\tsp->actable_offset[n]=mb[n];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGPROC:\n\t\t\tsp->jpeg_proc=(uint8)va_arg(ap,uint16_vap);\n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGRESTARTINTERVAL:\n\t\t\tsp->restart_interval=(uint16)va_arg(ap,uint16_vap);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn (*sp->vsetparent)(tif,tag,ap);\n\t}\n\tfip = TIFFFieldWithTag(tif,tag);\n\tif( fip == NULL ) /* shouldn't happen */\n\t    return(0);\n\tTIFFSetFieldBit(tif,fip->field_bit);\n\ttif->tif_flags|=TIFF_DIRTYDIRECT;\n\treturn(1);\n}\n", "target": 0, "idx": 70311}
{"func": "void WebRtcAudioRenderer::Stop() {\n  base::AutoLock auto_lock(lock_);\n  if (state_ == UNINITIALIZED)\n    return;\n\n  source_->RemoveRenderer(this);\n  source_ = NULL;\n  sink_->Stop();\n  state_ = UNINITIALIZED;\n}\n", "target": 0, "idx": 125855}
{"func": "void GLManager::InitializeWithWorkaroundsImpl(\n    const GLManager::Options& options,\n    const GpuDriverBugWorkarounds& workarounds) {\n  const SharedMemoryLimits limits;\n  const base::CommandLine& command_line =\n      *base::CommandLine::ForCurrentProcess();\n  DCHECK(!command_line.HasSwitch(switches::kDisableGLExtensions));\n   InitializeGpuPreferencesForTestingFromCommandLine(command_line,\n                                                     &gpu_preferences_);\n \n   if (options.share_mailbox_manager) {\n     mailbox_manager_ = options.share_mailbox_manager->mailbox_manager();\n   } else if (options.share_group_manager) {\n    mailbox_manager_ = options.share_group_manager->mailbox_manager();\n  } else {\n    mailbox_manager_ = &owned_mailbox_manager_;\n  }\n\n  gl::GLShareGroup* share_group = NULL;\n  if (options.share_group_manager) {\n    share_group = options.share_group_manager->share_group();\n  } else if (options.share_mailbox_manager) {\n    share_group = options.share_mailbox_manager->share_group();\n  }\n\n  gles2::ContextGroup* context_group = NULL;\n  scoped_refptr<gles2::ShareGroup> client_share_group;\n  if (options.share_group_manager) {\n    context_group = options.share_group_manager->decoder_->GetContextGroup();\n    client_share_group =\n      options.share_group_manager->gles2_implementation()->share_group();\n  }\n\n  gl::GLContext* real_gl_context = NULL;\n  if (options.virtual_manager &&\n      !gpu_preferences_.use_passthrough_cmd_decoder) {\n    real_gl_context = options.virtual_manager->context();\n  }\n\n  share_group_ = share_group ? share_group : new gl::GLShareGroup;\n\n  ContextCreationAttribs attribs;\n  attribs.red_size = 8;\n  attribs.green_size = 8;\n  attribs.blue_size = 8;\n  attribs.alpha_size = 8;\n  attribs.depth_size = 16;\n  attribs.stencil_size = 8;\n  attribs.context_type = options.context_type;\n  attribs.samples = options.multisampled ? 4 : 0;\n  attribs.sample_buffers = options.multisampled ? 1 : 0;\n  attribs.alpha_size = options.backbuffer_alpha ? 8 : 0;\n  attribs.should_use_native_gmb_for_backbuffer =\n      options.image_factory != nullptr;\n  attribs.offscreen_framebuffer_size = options.size;\n  attribs.buffer_preserved = options.preserve_backbuffer;\n  attribs.bind_generates_resource = options.bind_generates_resource;\n  translator_cache_ =\n      std::make_unique<gles2::ShaderTranslatorCache>(gpu_preferences_);\n\n  if (!context_group) {\n    scoped_refptr<gles2::FeatureInfo> feature_info =\n        new gles2::FeatureInfo(workarounds);\n    context_group = new gles2::ContextGroup(\n        gpu_preferences_, true, mailbox_manager_, nullptr /* memory_tracker */,\n        translator_cache_.get(), &completeness_cache_, feature_info,\n        options.bind_generates_resource, &image_manager_, options.image_factory,\n        nullptr /* progress_reporter */, GpuFeatureInfo(),\n        &discardable_manager_);\n  }\n\n  command_buffer_.reset(new CommandBufferCheckLostContext(\n      context_group->transfer_buffer_manager(), options.sync_point_manager,\n      options.context_lost_allowed));\n\n  decoder_.reset(::gpu::gles2::GLES2Decoder::Create(\n      command_buffer_.get(), command_buffer_->service(), &outputter_,\n      context_group));\n  if (options.force_shader_name_hashing) {\n    decoder_->SetForceShaderNameHashingForTest(true);\n  }\n\n  command_buffer_->set_handler(decoder_.get());\n\n  surface_ = gl::init::CreateOffscreenGLSurface(gfx::Size());\n  ASSERT_TRUE(surface_.get() != NULL) << \"could not create offscreen surface\";\n\n  if (base_context_) {\n    context_ = scoped_refptr<gl::GLContext>(new gpu::GLContextVirtual(\n        share_group_.get(), base_context_->get(), decoder_->AsWeakPtr()));\n    ASSERT_TRUE(context_->Initialize(\n        surface_.get(), GenerateGLContextAttribs(attribs, context_group)));\n  } else {\n    if (real_gl_context) {\n      context_ = scoped_refptr<gl::GLContext>(new gpu::GLContextVirtual(\n          share_group_.get(), real_gl_context, decoder_->AsWeakPtr()));\n      ASSERT_TRUE(context_->Initialize(\n          surface_.get(), GenerateGLContextAttribs(attribs, context_group)));\n    } else {\n      context_ = gl::init::CreateGLContext(\n          share_group_.get(), surface_.get(),\n          GenerateGLContextAttribs(attribs, context_group));\n      g_gpu_feature_info.ApplyToGLContext(context_.get());\n    }\n  }\n  ASSERT_TRUE(context_.get() != NULL) << \"could not create GL context\";\n\n  ASSERT_TRUE(context_->MakeCurrent(surface_.get()));\n\n  auto result =\n      decoder_->Initialize(surface_.get(), context_.get(), true,\n                           ::gpu::gles2::DisallowedFeatures(), attribs);\n  if (result != gpu::ContextResult::kSuccess)\n    return;\n  capabilities_ = decoder_->GetCapabilities();\n\n  gles2_helper_.reset(new gles2::GLES2CmdHelper(command_buffer_.get()));\n  ASSERT_EQ(gles2_helper_->Initialize(limits.command_buffer_size),\n            gpu::ContextResult::kSuccess);\n\n  transfer_buffer_.reset(new TransferBuffer(gles2_helper_.get()));\n\n  const bool support_client_side_arrays = true;\n  gles2_implementation_.reset(new gles2::GLES2Implementation(\n      gles2_helper_.get(), std::move(client_share_group),\n      transfer_buffer_.get(), options.bind_generates_resource,\n      options.lose_context_when_out_of_memory, support_client_side_arrays,\n      this));\n\n  ASSERT_EQ(gles2_implementation_->Initialize(limits),\n            gpu::ContextResult::kSuccess)\n      << \"Could not init GLES2Implementation\";\n\n  MakeCurrent();\n}\n", "target": 1, "idx": 186889}
{"func": "void Warn(v8::Isolate* isolate, const std::string& message) {\n  ScriptContext* script_context =\n      ScriptContextSet::GetContextByV8Context(isolate->GetCallingContext());\n  console::Warn(script_context ? script_context->GetRenderFrame() : nullptr,\n                message);\n}\n", "target": 0, "idx": 145756}
{"func": "static unsigned int udp4_portaddr_hash(struct net *net, __be32 saddr,\n\t\t\t\t       unsigned int port)\n{\n\treturn jhash_1word((__force u32)saddr, net_hash_mix(net)) ^ port;\n}\n", "target": 0, "idx": 19070}
{"func": "static int send_reply(struct svcxprt_rdma *rdma,\n\t\t      struct svc_rqst *rqstp,\n\t\t      struct page *page,\n\t\t      struct rpcrdma_msg *rdma_resp,\n\t\t      struct svc_rdma_req_map *vec,\n\t\t      int byte_count,\n\t\t      u32 inv_rkey)\n {\n \tstruct svc_rdma_op_ctxt *ctxt;\n\tstruct ib_send_wr send_wr;\n\tu32 xdr_off;\n\tint sge_no;\n\tint sge_bytes;\n\tint page_no;\n\tint pages;\n\tint ret = -EIO;\n\t/* Prepare the context */\n \tctxt = svc_rdma_get_context(rdma);\n\tctxt->direction = DMA_TO_DEVICE;\n\tctxt->pages[0] = page;\n\tctxt->count = 1;\n \n\t/* Prepare the SGE for the RPCRDMA Header */\n\tctxt->sge[0].lkey = rdma->sc_pd->local_dma_lkey;\n\tctxt->sge[0].length =\n\t    svc_rdma_xdr_get_reply_hdr_len((__be32 *)rdma_resp);\n\tctxt->sge[0].addr =\n\t    ib_dma_map_page(rdma->sc_cm_id->device, page, 0,\n\t\t\t    ctxt->sge[0].length, DMA_TO_DEVICE);\n\tif (ib_dma_mapping_error(rdma->sc_cm_id->device, ctxt->sge[0].addr))\n \t\tgoto err;\n\tsvc_rdma_count_mappings(rdma, ctxt);\n\tctxt->direction = DMA_TO_DEVICE;\n \n\t/* Map the payload indicated by 'byte_count' */\n\txdr_off = 0;\n\tfor (sge_no = 1; byte_count && sge_no < vec->count; sge_no++) {\n\t\tsge_bytes = min_t(size_t, vec->sge[sge_no].iov_len, byte_count);\n\t\tbyte_count -= sge_bytes;\n\t\tctxt->sge[sge_no].addr =\n\t\t\tdma_map_xdr(rdma, &rqstp->rq_res, xdr_off,\n\t\t\t\t    sge_bytes, DMA_TO_DEVICE);\n\t\txdr_off += sge_bytes;\n\t\tif (ib_dma_mapping_error(rdma->sc_cm_id->device,\n\t\t\t\t\t ctxt->sge[sge_no].addr))\n \t\t\tgoto err;\n\t\tsvc_rdma_count_mappings(rdma, ctxt);\n\t\tctxt->sge[sge_no].lkey = rdma->sc_pd->local_dma_lkey;\n\t\tctxt->sge[sge_no].length = sge_bytes;\n \t}\n\tif (byte_count != 0) {\n\t\tpr_err(\"svcrdma: Could not map %d bytes\\n\", byte_count);\n \t\tgoto err;\n\t}\n \n\t/* Save all respages in the ctxt and remove them from the\n\t * respages array. They are our pages until the I/O\n\t * completes.\n \t */\n\tpages = rqstp->rq_next_page - rqstp->rq_respages;\n\tfor (page_no = 0; page_no < pages; page_no++) {\n\t\tctxt->pages[page_no+1] = rqstp->rq_respages[page_no];\n\t\tctxt->count++;\n\t\trqstp->rq_respages[page_no] = NULL;\n\t}\n\trqstp->rq_next_page = rqstp->rq_respages + 1;\n \n\tif (sge_no > rdma->sc_max_sge) {\n\t\tpr_err(\"svcrdma: Too many sges (%d)\\n\", sge_no);\n \t\tgoto err;\n\t}\n\tmemset(&send_wr, 0, sizeof send_wr);\n\tctxt->cqe.done = svc_rdma_wc_send;\n\tsend_wr.wr_cqe = &ctxt->cqe;\n\tsend_wr.sg_list = ctxt->sge;\n\tsend_wr.num_sge = sge_no;\n\tif (inv_rkey) {\n\t\tsend_wr.opcode = IB_WR_SEND_WITH_INV;\n\t\tsend_wr.ex.invalidate_rkey = inv_rkey;\n\t} else\n\t\tsend_wr.opcode = IB_WR_SEND;\n\tsend_wr.send_flags =  IB_SEND_SIGNALED;\n \n\tret = svc_rdma_send(rdma, &send_wr);\n \tif (ret)\n \t\tgoto err;\n \n \treturn 0;\n \n err:\n \tsvc_rdma_unmap_dma(ctxt);\n \tsvc_rdma_put_context(ctxt, 1);\n \treturn ret;\n}\n", "target": 1, "idx": 181339}
{"func": "void CoordinatorImpl::UnregisterClientProcess(\n    mojom::ClientProcess* client_process) {\n  QueuedRequest* request = GetCurrentRequest();\n  if (request != nullptr) {\n    auto it = request->pending_responses.begin();\n    while (it != request->pending_responses.end()) {\n      std::set<QueuedRequest::PendingResponse>::iterator current = it++;\n      if (current->client != client_process)\n        continue;\n      RemovePendingResponse(client_process, current->type);\n      request->failed_memory_dump_count++;\n    }\n    FinalizeGlobalMemoryDumpIfAllManagersReplied();\n  }\n\n  for (auto& pair : in_progress_vm_region_requests_) {\n    QueuedVmRegionRequest* request = pair.second.get();\n    auto it = request->pending_responses.begin();\n    while (it != request->pending_responses.end()) {\n      auto current = it++;\n      if (*current == client_process) {\n        request->pending_responses.erase(current);\n      }\n    }\n  }\n\n  for (auto& pair : in_progress_vm_region_requests_) {\n    base::SequencedTaskRunnerHandle::Get()->PostTask(\n         FROM_HERE,\n         base::BindOnce(\n             &CoordinatorImpl::FinalizeVmRegionDumpIfAllManagersReplied,\n            base::Unretained(this), pair.second->dump_guid));\n   }\n \n   size_t num_deleted = clients_.erase(client_process);\n  DCHECK(num_deleted == 1);\n}\n", "target": 1, "idx": 187207}
{"func": "std::string HttpUtil::AssembleRawHeaders(const char* input_begin,\n                                         int input_len) {\n  std::string raw_headers;\n  raw_headers.reserve(input_len);\n\n  const char* input_end = input_begin + input_len;\n\n  int status_begin_offset = LocateStartOfStatusLine(input_begin, input_len);\n  if (status_begin_offset != -1)\n    input_begin += status_begin_offset;\n\n  const char* status_line_end = FindStatusLineEnd(input_begin, input_end);\n  raw_headers.append(input_begin, status_line_end);\n\n\n  CStringTokenizer lines(status_line_end, input_end, \"\\r\\n\");\n\n  bool prev_line_continuable = false;\n\n  while (lines.GetNext()) {\n    const char* line_begin = lines.token_begin();\n    const char* line_end = lines.token_end();\n\n    if (prev_line_continuable && IsLWS(*line_begin)) {\n      raw_headers.push_back(' ');\n       raw_headers.append(FindFirstNonLWS(line_begin, line_end), line_end);\n     } else {\n      raw_headers.push_back('\\0');\n \n       raw_headers.append(line_begin, line_end);\n\n      prev_line_continuable = IsLineSegmentContinuable(line_begin, line_end);\n     }\n   }\n \n  raw_headers.append(\"\\0\\0\", 2);\n   return raw_headers;\n }\n", "target": 1, "idx": 183637}
{"func": " void XMLHttpRequest::didFail(const ResourceError& error)\n {\n     if (m_error)\n         return;\n \n     if (error.isCancellation()) {\n        m_exceptionCode = AbortError;\n        abortError();\n         return;\n     }\n \n     if (error.isTimeout()) {\n        didTimeout();\n         return;\n     }\n \n     if (error.domain() == errorDomainWebKitInternal)\n         logConsoleError(scriptExecutionContext(), \"XMLHttpRequest cannot load \" + error.failingURL() + \". \" + error.localizedDescription());\n \n    m_exceptionCode = NetworkError;\n    networkError();\n }\n", "target": 1, "idx": 184857}
{"func": "static int store_xauthority(void) {\n\tfs_build_mnt_dir();\n\n\tchar *src;\n\tchar *dest = RUN_XAUTHORITY_FILE;\n\tFILE *fp = fopen(dest, \"w\");\n\tif (fp) {\n\t\tfprintf(fp, \"\\n\");\n\t\tSET_PERMS_STREAM(fp, getuid(), getgid(), 0600);\n\t\tfclose(fp);\n\t}\n\t\n\tif (asprintf(&src, \"%s/.Xauthority\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\t\n\tstruct stat s;\n\tif (stat(src, &s) == 0) {\n\t\tif (is_link(src)) {\n\t\t\tfprintf(stderr, \"Warning: invalid .Xauthority file\\n\");\n \t\t\treturn 0;\n \t\t}\n \n\t\tpid_t child = fork();\n\t\tif (child < 0)\n\t\t\terrExit(\"fork\");\n\t\tif (child == 0) {\n\t\t\tdrop_privs(0);\n\t\t\tint rv = copy_file(src, dest, getuid(), getgid(), 0600);\n\t\t\tif (rv)\n\t\t\t\tfprintf(stderr, \"Warning: cannot transfer .Xauthority in private home directory\\n\");\n\t\t\telse {\n\t\t\t\tfs_logger2(\"clone\", dest);\n\t\t\t}\n\t\t\t_exit(0);\n\t\t}\n\t\twaitpid(child, NULL, 0);\n \t\treturn 1; // file copied\n \t}\n \t\n\treturn 0;\n}\n", "target": 1, "idx": 183267}
{"func": "static int check_stack_read(struct bpf_verifier_env *env,\n\t\t\t    struct bpf_func_state *reg_state /* func where register points to */,\n\t\t\t    int off, int size, int value_regno)\n{\n\tstruct bpf_verifier_state *vstate = env->cur_state;\n\tstruct bpf_func_state *state = vstate->frame[vstate->curframe];\n\tint i, slot = -off - 1, spi = slot / BPF_REG_SIZE;\n\tu8 *stype;\n\n\tif (reg_state->allocated_stack <= slot) {\n\t\tverbose(env, \"invalid read from stack off %d+0 size %d\\n\",\n\t\t\toff, size);\n\t\treturn -EACCES;\n\t}\n\tstype = reg_state->stack[spi].slot_type;\n\n\tif (stype[0] == STACK_SPILL) {\n\t\tif (size != BPF_REG_SIZE) {\n\t\t\tverbose(env, \"invalid size of register spill\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tfor (i = 1; i < BPF_REG_SIZE; i++) {\n\t\t\tif (stype[(slot - i) % BPF_REG_SIZE] != STACK_SPILL) {\n\t\t\t\tverbose(env, \"corrupted spill memory\\n\");\n\t\t\t\treturn -EACCES;\n\t\t\t}\n\t\t}\n\n\t\tif (value_regno >= 0) {\n\t\t\t/* restore register state from stack */\n\t\t\tstate->regs[value_regno] = reg_state->stack[spi].spilled_ptr;\n\t\t\t/* mark reg as written since spilled pointer state likely\n\t\t\t * has its liveness marks cleared by is_state_visited()\n\t\t\t * which resets stack/reg liveness for state transitions\n\t\t\t */\n\t\t\tstate->regs[value_regno].live |= REG_LIVE_WRITTEN;\n\t\t}\n\t\tmark_reg_read(env, &reg_state->stack[spi].spilled_ptr,\n\t\t\t      reg_state->stack[spi].spilled_ptr.parent);\n\t\treturn 0;\n\t} else {\n\t\tint zeros = 0;\n\n\t\tfor (i = 0; i < size; i++) {\n\t\t\tif (stype[(slot - i) % BPF_REG_SIZE] == STACK_MISC)\n\t\t\t\tcontinue;\n\t\t\tif (stype[(slot - i) % BPF_REG_SIZE] == STACK_ZERO) {\n\t\t\t\tzeros++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tverbose(env, \"invalid read from stack off %d+%d size %d\\n\",\n\t\t\t\toff, i, size);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tmark_reg_read(env, &reg_state->stack[spi].spilled_ptr,\n\t\t\t      reg_state->stack[spi].spilled_ptr.parent);\n\t\tif (value_regno >= 0) {\n\t\t\tif (zeros == size) {\n\t\t\t\t/* any size read into register is zero extended,\n\t\t\t\t * so the whole register == const_zero\n\t\t\t\t */\n\t\t\t\t__mark_reg_const_zero(&state->regs[value_regno]);\n\t\t\t} else {\n\t\t\t\t/* have read misc data from the stack */\n\t\t\t\tmark_reg_unknown(env, state->regs, value_regno);\n\t\t\t}\n\t\t\tstate->regs[value_regno].live |= REG_LIVE_WRITTEN;\n\t\t}\n\t\treturn 0;\n\t}\n}\n", "target": 0, "idx": 91422}
{"func": "void Browser::OnTranslateEnabledChanged(content::WebContents* source) {\n  DCHECK(source);\n  if (tab_strip_model_->GetActiveWebContents() == source)\n    UpdateToolbar(false);\n}\n", "target": 0, "idx": 151708}
{"func": "nfsd4_encode_security_label(struct xdr_stream *xdr, struct svc_rqst *rqstp,\n\t\t\t    void *context, int len)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, len + 4 + 4 + 4);\n\tif (!p)\n\t\treturn nfserr_resource;\n\n\t/*\n\t * For now we use a 0 here to indicate the null translation; in\n\t * the future we may place a call to translation code here.\n\t */\n\t*p++ = cpu_to_be32(0); /* lfs */\n\t*p++ = cpu_to_be32(0); /* pi */\n\tp = xdr_encode_opaque(p, context, len);\n\treturn 0;\n}\n", "target": 0, "idx": 65832}
{"func": "TracingControllerImpl::TracingControllerImpl()\n    : delegate_(GetContentClient()->browser()->GetTracingDelegate()),\n      weak_ptr_factory_(this) {\n  DCHECK(!g_tracing_controller);\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n  base::FileTracing::SetProvider(new FileTracingProviderImpl);\n  AddAgents();\n   base::trace_event::TraceLog::GetInstance()->AddAsyncEnabledStateObserver(\n       weak_ptr_factory_.GetWeakPtr());\n   g_tracing_controller = this;\n }\n", "target": 1, "idx": 185970}
{"func": "void PushMessagingServiceImpl::DidHandleMessage(\n    const std::string& app_id,\n    const base::Closure& message_handled_closure) {\n  auto in_flight_iterator = in_flight_message_deliveries_.find(app_id);\n  DCHECK(in_flight_iterator != in_flight_message_deliveries_.end());\n\n  in_flight_message_deliveries_.erase(in_flight_iterator);\n\n#if BUILDFLAG(ENABLE_BACKGROUND)\n  if (in_flight_message_deliveries_.empty())\n    in_flight_keep_alive_.reset();\n#endif\n \n   message_handled_closure.Run();\n \n  if (push_messaging_service_observer_)\n    push_messaging_service_observer_->OnMessageHandled();\n }\n", "target": 1, "idx": 186918}
{"func": "static int __init init_sys32_ioctl(void)\n{\n\tsort(ioctl_pointer, ARRAY_SIZE(ioctl_pointer), sizeof(*ioctl_pointer),\n\t\tinit_sys32_ioctl_cmp, NULL);\n\treturn 0;\n}\n", "target": 0, "idx": 32820}
{"func": "  bool CheckDownloadFullPaths(Browser* browser,\n                              const base::FilePath& downloaded_file,\n                              const base::FilePath& origin_file) {\n    base::ScopedAllowBlockingForTesting allow_blocking;\n    bool origin_file_exists = base::PathExists(origin_file);\n    EXPECT_TRUE(origin_file_exists) << origin_file.value();\n    if (!origin_file_exists)\n      return false;\n\n    bool downloaded_file_exists = base::PathExists(downloaded_file);\n    EXPECT_TRUE(downloaded_file_exists) << downloaded_file.value();\n    if (!downloaded_file_exists)\n      return false;\n\n    int64_t origin_file_size = 0;\n    EXPECT_TRUE(base::GetFileSize(origin_file, &origin_file_size));\n    std::string original_file_contents;\n    EXPECT_TRUE(base::ReadFileToString(origin_file, &original_file_contents));\n    EXPECT_TRUE(\n        VerifyFile(downloaded_file, original_file_contents, origin_file_size));\n\n    bool downloaded_file_deleted = base::DieFileDie(downloaded_file, false);\n    EXPECT_TRUE(downloaded_file_deleted);\n    return downloaded_file_deleted;\n  }\n", "target": 0, "idx": 164813}
{"func": "static int g2m_init_buffers(G2MContext *c)\n{\n    int aligned_height;\n\n    if (!c->framebuf || c->old_width < c->width || c->old_height < c->height) {\n        c->framebuf_stride = FFALIGN(c->width * 3, 16);\n        aligned_height     = FFALIGN(c->height,    16);\n        av_free(c->framebuf);\n        c->framebuf = av_mallocz(c->framebuf_stride * aligned_height);\n        if (!c->framebuf)\n            return AVERROR(ENOMEM);\n    }\n     if (!c->synth_tile || !c->jpeg_tile ||\n         c->old_tile_w < c->tile_width ||\n         c->old_tile_h < c->tile_height) {\n        c->tile_stride = FFALIGN(c->tile_width * 3, 16);\n         aligned_height = FFALIGN(c->tile_height,    16);\n         av_free(c->synth_tile);\n         av_free(c->jpeg_tile);\n        av_free(c->kempf_buf);\n        av_free(c->kempf_flags);\n        c->synth_tile  = av_mallocz(c->tile_stride      * aligned_height);\n        c->jpeg_tile   = av_mallocz(c->tile_stride      * aligned_height);\n        c->kempf_buf   = av_mallocz((c->tile_width + 1) * aligned_height\n                                    + FF_INPUT_BUFFER_PADDING_SIZE);\n        c->kempf_flags = av_mallocz( c->tile_width      * aligned_height);\n        if (!c->synth_tile || !c->jpeg_tile ||\n            !c->kempf_buf || !c->kempf_flags)\n            return AVERROR(ENOMEM);\n    }\n\n    return 0;\n}\n", "target": 1, "idx": 179098}
{"func": "static int yam_info_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &yam_seqops);\n}\n", "target": 0, "idx": 39467}
{"func": "void Job::StartGetProxyForURL(const GURL& url,\n                              ProxyInfo* results,\n                              const CompletionCallback& callback) {\n  CheckIsOnOriginThread();\n\n  url_ = url;\n  user_results_ = results;\n\n  Start(GET_PROXY_FOR_URL, false /*non-blocking*/, callback);\n}\n", "target": 0, "idx": 143398}
{"func": " static void fwnet_receive_broadcast(struct fw_iso_context *context,\n \t\tu32 cycle, size_t header_length, void *header, void *data)\n {\n\tstruct fwnet_device *dev;\n\tstruct fw_iso_packet packet;\n\t__be16 *hdr_ptr;\n \t__be32 *buf_ptr;\n \tint retval;\n \tu32 length;\n\tu16 source_node_id;\n\tu32 specifier_id;\n\tu32 ver;\n \tunsigned long offset;\n \tunsigned long flags;\n \n\tdev = data;\n\thdr_ptr = header;\n\tlength = be16_to_cpup(hdr_ptr);\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\toffset = dev->rcv_buffer_size * dev->broadcast_rcv_next_ptr;\n\tbuf_ptr = dev->broadcast_rcv_buffer_ptrs[dev->broadcast_rcv_next_ptr++];\n\tif (dev->broadcast_rcv_next_ptr == dev->num_broadcast_rcv_ptrs)\n\t\tdev->broadcast_rcv_next_ptr = 0;\n \n \tspin_unlock_irqrestore(&dev->lock, flags);\n \n\tspecifier_id =    (be32_to_cpu(buf_ptr[0]) & 0xffff) << 8\n\t\t\t| (be32_to_cpu(buf_ptr[1]) & 0xff000000) >> 24;\n\tver = be32_to_cpu(buf_ptr[1]) & 0xffffff;\n\tsource_node_id = be32_to_cpu(buf_ptr[0]) >> 16;\n\tif (specifier_id == IANA_SPECIFIER_ID &&\n\t    (ver == RFC2734_SW_VERSION\n #if IS_ENABLED(CONFIG_IPV6)\n\t     || ver == RFC3146_SW_VERSION\n #endif\n\t    )) {\n\t\tbuf_ptr += 2;\n\t\tlength -= IEEE1394_GASP_HDR_SIZE;\n\t\tfwnet_incoming_packet(dev, buf_ptr, length, source_node_id,\n \t\t\t\t      context->card->generation, true);\n\t}\n \n \tpacket.payload_length = dev->rcv_buffer_size;\n \tpacket.interrupt = 1;\n\tpacket.skip = 0;\n\tpacket.tag = 3;\n\tpacket.sy = 0;\n\tpacket.header_length = IEEE1394_GASP_HDR_SIZE;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tretval = fw_iso_context_queue(dev->broadcast_rcv_context, &packet,\n\t\t\t\t      &dev->broadcast_rcv_buffer, offset);\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tif (retval >= 0)\n\t\tfw_iso_context_queue_flush(dev->broadcast_rcv_context);\n\telse\n\t\tdev_err(&dev->netdev->dev, \"requeue failed\\n\");\n}\n", "target": 1, "idx": 180089}
{"func": "  cf2_initGlobalRegionBuffer( CFF_Decoder*  decoder,\n                               CF2_UInt      idx,\n                               CF2_Buffer    buf )\n   {\n    FT_ASSERT( decoder && decoder->globals );\n \n     FT_ZERO( buf );\n \n    idx += decoder->globals_bias;\n     if ( idx >= decoder->num_globals )\n       return TRUE;     /* error */\n \n     buf->start =\n     buf->ptr   = decoder->globals[idx];\n     buf->end   = decoder->globals[idx + 1];\n  }\n", "target": 1, "idx": 178393}
{"func": "sf_open\t(const char *path, int mode, SF_INFO *sfinfo)\n{\tSF_PRIVATE \t*psf ;\n\n \t/* Ultimate sanity check. */\n \tassert (sizeof (sf_count_t) == 8) ;\n \n\tif ((psf = calloc (1, sizeof (SF_PRIVATE))) == NULL)\n \t{\tsf_errno = SFE_MALLOC_FAILED ;\n \t\treturn\tNULL ;\n \t\t} ;\n\n\tpsf_init_files (psf) ;\n\n\tpsf_log_printf (psf, \"File : %s\\n\", path) ;\n\n\tif (copy_filename (psf, path) != 0)\n\t{\tsf_errno = psf->error ;\n\t\treturn\tNULL ;\n\t\t} ;\n\n\tpsf->file.mode = mode ;\n\tif (strcmp (path, \"-\") == 0)\n\t\tpsf->error = psf_set_stdio (psf) ;\n\telse\n\t\tpsf->error = psf_fopen (psf) ;\n\n\treturn psf_open_file (psf, sfinfo) ;\n} /* sf_open */\n", "target": 1, "idx": 183239}
{"func": " void AcceleratedSurfaceBuffersSwappedCompleted(int host_id,\n                                                int route_id,\n                                                int surface_id,\n                                                bool alive,\n                                                base::TimeTicks timebase,\n                                                base::TimeDelta interval) {\n   AcceleratedSurfaceBuffersSwappedCompletedForGPU(host_id, route_id,\n                                                  alive, true /* presented */);\n   AcceleratedSurfaceBuffersSwappedCompletedForRenderer(surface_id, timebase,\n                                                        interval);\n }\n", "target": 1, "idx": 185051}
{"func": "static inline bool userfaultfd_huge_must_wait(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t struct vm_area_struct *vma,\n\t\t\t\t\t unsigned long address,\n\t\t\t\t\t unsigned long flags,\n\t\t\t\t\t unsigned long reason)\n{\n\treturn false;\t/* should never get here */\n}\n", "target": 0, "idx": 76456}
{"func": "static int __init michael_mic_init(void)\n{\n\treturn crypto_register_shash(&alg);\n}\n", "target": 0, "idx": 47298}
{"func": "v8::Handle<v8::Value> V8DataView::setInt8Callback(const v8::Arguments& args)\n {\n     INC_STATS(\"DOM.DataView.setInt8\");\n     if (args.Length() < 2)\n        return V8Proxy::throwNotEnoughArgumentsError();\n \n     DataView* imp = V8DataView::toNative(args.Holder());\n     ExceptionCode ec = 0;\n    EXCEPTION_BLOCK(unsigned, byteOffset, toUInt32(args[0]));\n    EXCEPTION_BLOCK(int, value, toInt32(args[1]));\n    imp->setInt8(byteOffset, static_cast<int8_t>(value), ec);\n    if (UNLIKELY(ec))\n        V8Proxy::setDOMException(ec, args.GetIsolate());\n    return v8::Handle<v8::Value>();\n}\n", "target": 1, "idx": 184806}
{"func": " static int jas_iccgetuint16(jas_stream_t *in, jas_iccuint16_t *val)\n {\n\tulonglong tmp;\n \tif (jas_iccgetuint(in, 2, &tmp))\n \t\treturn -1;\n \t*val = tmp;\n\treturn 0;\n}\n", "target": 1, "idx": 181857}
{"func": " void HeapObjectHeader::Finalize(Address object, size_t object_size) {\n   HeapAllocHooks::FreeHookIfEnabled(object);\n  const GCInfo* gc_info = ThreadHeap::GcInfo(GcInfoIndex());\n   if (gc_info->HasFinalizer())\n     gc_info->finalize_(object);\n \n  ASAN_RETIRE_CONTAINER_ANNOTATION(object, object_size);\n}\n", "target": 1, "idx": 187123}
{"func": " void HostCache::clear() {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   RecordEraseAll(ERASE_CLEAR, base::TimeTicks::Now());\n   entries_.clear();\n }\n", "target": 1, "idx": 185888}
{"func": "  Horizontal_Sweep_Span( RAS_ARGS Short       y,\n                                  FT_F26Dot6  x1,\n                                  FT_F26Dot6  x2,\n                                  PProfile    left,\n                                  PProfile    right )\n  {\n    FT_UNUSED( left );\n    FT_UNUSED( right );\n\n\n    if ( x2 - x1 < ras.precision )\n    {\n      Long  e1, e2;\n\n\n      e1 = CEILING( x1 );\n      e2 = FLOOR  ( x2 );\n\n      if ( e1 == e2 )\n      {\n        Byte   f1;\n        PByte  bits;\n\n\n        bits = ras.bTarget + ( y >> 3 );\n        f1   = (Byte)( 0x80 >> ( y & 7 ) );\n \n         e1 = TRUNC( e1 );\n \n        if ( e1 >= 0 && e1 < ras.target.rows )\n         {\n           PByte  p;\n \n\n          p = bits - e1 * ras.target.pitch;\n          if ( ras.target.pitch > 0 )\n            p += ( ras.target.rows - 1 ) * ras.target.pitch;\n\n          p[0] |= f1;\n        }\n      }\n    }\n  }\n", "target": 1, "idx": 178025}
{"func": "static void add_probe(const char *name)\n {\n \tstruct module_entry *m;\n \n \tm = get_or_add_modentry(name);\n \tif (!(option_mask32 & (OPT_REMOVE | OPT_SHOW_DEPS))\n \t && (m->flags & MODULE_FLAG_LOADED)\n\t && strncmp(m->modname, \"symbol:\", 7) == 0\n\t) {\n\t\tG.need_symbols = 1;\n\t}\n}\n", "target": 1, "idx": 178570}
{"func": "  FTC_SNode_Compare( FTC_SNode   snode,\n                     FTC_GQuery  gquery,\n                     FTC_Cache   cache,\n                     FT_Bool*    list_changed )\n  {\n    return ftc_snode_compare( FTC_NODE( snode ), gquery,\n                              cache, list_changed );\n  }\n", "target": 0, "idx": 7007}
{"func": "device_linux_md_add_spare_authorized_cb (Daemon *daemon,\n                                             Device *device,\n                                             DBusGMethodInvocation *context,\n                                             const gchar *action_id,\n                                             guint num_user_data,\n                                             gpointer *user_data_elements)\n{\n  char *component = user_data_elements[0];\n  /* TODO: use options */\n  int n;\n  char *argv[10];\n  GError *error;\n  Device *slave;\n\n  error = NULL;\n\n  slave = daemon_local_find_by_object_path (device->priv->daemon, component);\n  if (slave == NULL)\n    {\n      throw_error (context, ERROR_FAILED, \"Component doesn't exist\");\n      goto out;\n    }\n\n  /* it's fine if the given device isn't a Linux md component _yet_; think\n   * hot adding a new disk if an old one failed\n   */\n\n  if (device_local_is_busy (slave, TRUE, &error))\n    {\n      dbus_g_method_return_error (context, error);\n      g_error_free (error);\n      goto out;\n    }\n\n  /* TODO: check component size is OK */\n\n  n = 0;\n  argv[n++] = \"mdadm\";\n  argv[n++] = \"--manage\";\n  argv[n++] = device->priv->device_file;\n  argv[n++] = \"--add\";\n  argv[n++] = slave->priv->device_file;\n  argv[n++] = \"--force\";\n  argv[n++] = NULL;\n\n  if (!job_new (context,\n                \"LinuxMdAddSpare\",\n                TRUE,\n                device,\n                argv,\n                NULL,\n                linux_md_add_spare_completed_cb,\n                FALSE,\n                g_object_ref (slave),\n                g_object_unref))\n    {\n      goto out;\n    }\n\n out:\n  ;\n}\n", "target": 0, "idx": 11649}
{"func": "  HttpNetworkSession* CreateNetworkSession() {\n    return SpdySessionDependencies::SpdyCreateSessionDeterministic(\n        &session_deps_);\n  }\n", "target": 0, "idx": 121010}
{"func": "static void __update_open_stateid(struct nfs4_state *state, nfs4_stateid *open_stateid, const nfs4_stateid *deleg_stateid, int open_flags)\n {\n \t/*\n \t * Protect the call to nfs4_state_set_mode_locked and\n\t * serialise the stateid update\n\t */\n\twrite_seqlock(&state->seqlock);\n\tif (deleg_stateid != NULL) {\n\t\tmemcpy(state->stateid.data, deleg_stateid->data, sizeof(state->stateid.data));\n \t\tset_bit(NFS_DELEGATED_STATE, &state->flags);\n \t}\n \tif (open_stateid != NULL)\n\t\tnfs_set_open_stateid_locked(state, open_stateid, open_flags);\n \twrite_sequnlock(&state->seqlock);\n \tspin_lock(&state->owner->so_lock);\n\tupdate_open_stateflags(state, open_flags);\n \tspin_unlock(&state->owner->so_lock);\n }\n", "target": 1, "idx": 178855}
{"func": "int kvm_set_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tbool pr = false;\n\tu32 msr = msr_info->index;\n\tu64 data = msr_info->data;\n\n\tswitch (msr) {\n\tcase MSR_AMD64_NB_CFG:\n\tcase MSR_IA32_UCODE_REV:\n\tcase MSR_IA32_UCODE_WRITE:\n\tcase MSR_VM_HSAVE_PA:\n\tcase MSR_AMD64_PATCH_LOADER:\n\tcase MSR_AMD64_BU_CFG2:\n\t\tbreak;\n\n\tcase MSR_EFER:\n\t\treturn set_efer(vcpu, data);\n\tcase MSR_K7_HWCR:\n\t\tdata &= ~(u64)0x40;\t/* ignore flush filter disable */\n\t\tdata &= ~(u64)0x100;\t/* ignore ignne emulation enable */\n\t\tdata &= ~(u64)0x8;\t/* ignore TLB cache disable */\n\t\tif (data != 0) {\n\t\t\tvcpu_unimpl(vcpu, \"unimplemented HWCR wrmsr: 0x%llx\\n\",\n\t\t\t\t    data);\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tcase MSR_FAM10H_MMIO_CONF_BASE:\n\t\tif (data != 0) {\n\t\t\tvcpu_unimpl(vcpu, \"unimplemented MMIO_CONF_BASE wrmsr: \"\n\t\t\t\t    \"0x%llx\\n\", data);\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_DEBUGCTLMSR:\n\t\tif (!data) {\n\t\t\t/* We support the non-activated case already */\n\t\t\tbreak;\n\t\t} else if (data & ~(DEBUGCTLMSR_LBR | DEBUGCTLMSR_BTF)) {\n\t\t\t/* Values other than LBR and BTF are vendor-specific,\n\t\t\t   thus reserved and should throw a #GP */\n\t\t\treturn 1;\n\t\t}\n\t\tvcpu_unimpl(vcpu, \"%s: MSR_IA32_DEBUGCTLMSR 0x%llx, nop\\n\",\n\t\t\t    __func__, data);\n\t\tbreak;\n\tcase 0x200 ... 0x2ff:\n\t\treturn set_msr_mtrr(vcpu, msr, data);\n\tcase MSR_IA32_APICBASE:\n\t\tkvm_set_apic_base(vcpu, data);\n\t\tbreak;\n\tcase APIC_BASE_MSR ... APIC_BASE_MSR + 0x3ff:\n\t\treturn kvm_x2apic_msr_write(vcpu, msr, data);\n\tcase MSR_IA32_TSCDEADLINE:\n\t\tkvm_set_lapic_tscdeadline_msr(vcpu, data);\n\t\tbreak;\n\tcase MSR_IA32_TSC_ADJUST:\n\t\tif (guest_cpuid_has_tsc_adjust(vcpu)) {\n\t\t\tif (!msr_info->host_initiated) {\n\t\t\t\tu64 adj = data - vcpu->arch.ia32_tsc_adjust_msr;\n\t\t\t\tkvm_x86_ops->adjust_tsc_offset(vcpu, adj, true);\n\t\t\t}\n\t\t\tvcpu->arch.ia32_tsc_adjust_msr = data;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_MISC_ENABLE:\n\t\tvcpu->arch.ia32_misc_enable_msr = data;\n\t\tbreak;\n\tcase MSR_KVM_WALL_CLOCK_NEW:\n\tcase MSR_KVM_WALL_CLOCK:\n\t\tvcpu->kvm->arch.wall_clock = data;\n\t\tkvm_write_wall_clock(vcpu->kvm, data);\n\t\tbreak;\n\tcase MSR_KVM_SYSTEM_TIME_NEW:\n\tcase MSR_KVM_SYSTEM_TIME: {\n\t\tkvmclock_reset(vcpu);\n\n\t\tvcpu->arch.time = data;\n\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\n\t\t/* we verify if the enable bit is set... */\n\t\tif (!(data & 1))\n\t\t\tbreak;\n\n \t\t/* ...but clean it before doing the actual write */\n \t\tvcpu->arch.time_offset = data & ~(PAGE_MASK | 1);\n \n \t\tvcpu->arch.time_page =\n \t\t\t\tgfn_to_page(vcpu->kvm, data >> PAGE_SHIFT);\n \n\t\tif (is_error_page(vcpu->arch.time_page))\n\t\t\tvcpu->arch.time_page = NULL;\n\n\t\tbreak;\n\t}\n\tcase MSR_KVM_ASYNC_PF_EN:\n\t\tif (kvm_pv_enable_async_pf(vcpu, data))\n\t\t\treturn 1;\n\t\tbreak;\n\tcase MSR_KVM_STEAL_TIME:\n\n\t\tif (unlikely(!sched_info_on()))\n\t\t\treturn 1;\n\n\t\tif (data & KVM_STEAL_RESERVED_MASK)\n\t\t\treturn 1;\n\n\t\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm, &vcpu->arch.st.stime,\n\t\t\t\t\t\t\tdata & KVM_STEAL_VALID_BITS))\n\t\t\treturn 1;\n\n\t\tvcpu->arch.st.msr_val = data;\n\n\t\tif (!(data & KVM_MSR_ENABLED))\n\t\t\tbreak;\n\n\t\tvcpu->arch.st.last_steal = current->sched_info.run_delay;\n\n\t\tpreempt_disable();\n\t\taccumulate_steal_time(vcpu);\n\t\tpreempt_enable();\n\n\t\tkvm_make_request(KVM_REQ_STEAL_UPDATE, vcpu);\n\n\t\tbreak;\n\tcase MSR_KVM_PV_EOI_EN:\n\t\tif (kvm_lapic_enable_pv_eoi(vcpu, data))\n\t\t\treturn 1;\n\t\tbreak;\n\n\tcase MSR_IA32_MCG_CTL:\n\tcase MSR_IA32_MCG_STATUS:\n\tcase MSR_IA32_MC0_CTL ... MSR_IA32_MC0_CTL + 4 * KVM_MAX_MCE_BANKS - 1:\n\t\treturn set_msr_mce(vcpu, msr, data);\n\n\t/* Performance counters are not protected by a CPUID bit,\n\t * so we should check all of them in the generic path for the sake of\n\t * cross vendor migration.\n\t * Writing a zero into the event select MSRs disables them,\n\t * which we perfectly emulate ;-). Any other value should be at least\n\t * reported, some guests depend on them.\n\t */\n\tcase MSR_K7_EVNTSEL0:\n\tcase MSR_K7_EVNTSEL1:\n\tcase MSR_K7_EVNTSEL2:\n\tcase MSR_K7_EVNTSEL3:\n\t\tif (data != 0)\n\t\t\tvcpu_unimpl(vcpu, \"unimplemented perfctr wrmsr: \"\n\t\t\t\t    \"0x%x data 0x%llx\\n\", msr, data);\n\t\tbreak;\n\t/* at least RHEL 4 unconditionally writes to the perfctr registers,\n\t * so we ignore writes to make it happy.\n\t */\n\tcase MSR_K7_PERFCTR0:\n\tcase MSR_K7_PERFCTR1:\n\tcase MSR_K7_PERFCTR2:\n\tcase MSR_K7_PERFCTR3:\n\t\tvcpu_unimpl(vcpu, \"unimplemented perfctr wrmsr: \"\n\t\t\t    \"0x%x data 0x%llx\\n\", msr, data);\n\t\tbreak;\n\tcase MSR_P6_PERFCTR0:\n\tcase MSR_P6_PERFCTR1:\n\t\tpr = true;\n\tcase MSR_P6_EVNTSEL0:\n\tcase MSR_P6_EVNTSEL1:\n\t\tif (kvm_pmu_msr(vcpu, msr))\n\t\t\treturn kvm_pmu_set_msr(vcpu, msr, data);\n\n\t\tif (pr || data != 0)\n\t\t\tvcpu_unimpl(vcpu, \"disabled perfctr wrmsr: \"\n\t\t\t\t    \"0x%x data 0x%llx\\n\", msr, data);\n\t\tbreak;\n\tcase MSR_K7_CLK_CTL:\n\t\t/*\n\t\t * Ignore all writes to this no longer documented MSR.\n\t\t * Writes are only relevant for old K7 processors,\n\t\t * all pre-dating SVM, but a recommended workaround from\n\t\t * AMD for these chips. It is possible to specify the\n\t\t * affected processor models on the command line, hence\n\t\t * the need to ignore the workaround.\n\t\t */\n\t\tbreak;\n\tcase HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15:\n\t\tif (kvm_hv_msr_partition_wide(msr)) {\n\t\t\tint r;\n\t\t\tmutex_lock(&vcpu->kvm->lock);\n\t\t\tr = set_msr_hyperv_pw(vcpu, msr, data);\n\t\t\tmutex_unlock(&vcpu->kvm->lock);\n\t\t\treturn r;\n\t\t} else\n\t\t\treturn set_msr_hyperv(vcpu, msr, data);\n\t\tbreak;\n\tcase MSR_IA32_BBL_CR_CTL3:\n\t\t/* Drop writes to this legacy MSR -- see rdmsr\n\t\t * counterpart for further detail.\n\t\t */\n\t\tvcpu_unimpl(vcpu, \"ignored wrmsr: 0x%x data %llx\\n\", msr, data);\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_ID_LENGTH:\n\t\tif (!guest_cpuid_has_osvw(vcpu))\n\t\t\treturn 1;\n\t\tvcpu->arch.osvw.length = data;\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_STATUS:\n\t\tif (!guest_cpuid_has_osvw(vcpu))\n\t\t\treturn 1;\n\t\tvcpu->arch.osvw.status = data;\n\t\tbreak;\n\tdefault:\n\t\tif (msr && (msr == vcpu->kvm->arch.xen_hvm_config.msr))\n\t\t\treturn xen_hvm_config(vcpu, data);\n\t\tif (kvm_pmu_msr(vcpu, msr))\n\t\t\treturn kvm_pmu_set_msr(vcpu, msr, data);\n\t\tif (!ignore_msrs) {\n\t\t\tvcpu_unimpl(vcpu, \"unhandled wrmsr: 0x%x data %llx\\n\",\n\t\t\t\t    msr, data);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tvcpu_unimpl(vcpu, \"ignored wrmsr: 0x%x data %llx\\n\",\n\t\t\t\t    msr, data);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n", "target": 1, "idx": 179292}
{"func": "get_available_mechs(OM_uint32 *minor_status,\n\tgss_name_t name, gss_cred_usage_t usage,\n\tgss_const_key_value_set_t cred_store,\n\tgss_cred_id_t *creds, gss_OID_set *rmechs, OM_uint32 *time_rec)\n{\n\tunsigned int\ti;\n\tint\t\tfound = 0;\n\tOM_uint32 major_status = GSS_S_COMPLETE, tmpmin;\n\tgss_OID_set mechs, goodmechs;\n\tgss_OID_set_desc except_attrs;\n\tgss_OID_desc attr_oids[2];\n\n\tattr_oids[0] = *GSS_C_MA_DEPRECATED;\n\tattr_oids[1] = *GSS_C_MA_NOT_DFLT_MECH;\n\texcept_attrs.count = 2;\n\texcept_attrs.elements = attr_oids;\n\tmajor_status = gss_indicate_mechs_by_attrs(minor_status,\n\t\t\t\t\t\t   GSS_C_NO_OID_SET,\n\t\t\t\t\t\t   &except_attrs,\n\t\t\t\t\t\t   GSS_C_NO_OID_SET, &mechs);\n\n\tif (major_status != GSS_S_COMPLETE) {\n\t\treturn (major_status);\n\t}\n\n\tmajor_status = gss_create_empty_oid_set(minor_status, rmechs);\n\n\tif (major_status != GSS_S_COMPLETE) {\n\t\t(void) gss_release_oid_set(minor_status, &mechs);\n\t\treturn (major_status);\n\t}\n\n\tfor (i = 0; i < mechs->count && major_status == GSS_S_COMPLETE; i++) {\n\t\tif ((mechs->elements[i].length\n\t\t    != spnego_mechanism.mech_type.length) ||\n\t\t    memcmp(mechs->elements[i].elements,\n\t\t\tspnego_mechanism.mech_type.elements,\n\t\t\tspnego_mechanism.mech_type.length)) {\n\n\t\t\tmajor_status = gss_add_oid_set_member(minor_status,\n\t\t\t\t\t\t\t      &mechs->elements[i],\n\t\t\t\t\t\t\t      rmechs);\n\t\t\tif (major_status == GSS_S_COMPLETE)\n\t\t\t\tfound++;\n\t\t}\n\t}\n\n\t/*\n\t * If the caller wanted a list of creds returned,\n\t * trim the list of mechanisms down to only those\n\t * for which the creds are valid.\n\t */\n\tif (found > 0 && major_status == GSS_S_COMPLETE && creds != NULL) {\n\t\tmajor_status = gss_acquire_cred_from(minor_status, name,\n\t\t\t\t\t\t     GSS_C_INDEFINITE,\n\t\t\t\t\t\t     *rmechs, usage,\n\t\t\t\t\t\t     cred_store, creds,\n\t\t\t\t\t\t     &goodmechs, time_rec);\n\n\t\t/*\n\t\t * Drop the old list in favor of the new\n\t\t * \"trimmed\" list.\n\t\t */\n\t\t(void) gss_release_oid_set(&tmpmin, rmechs);\n\t\tif (major_status == GSS_S_COMPLETE) {\n\t\t\t(void) gssint_copy_oid_set(&tmpmin,\n\t\t\t\t\tgoodmechs, rmechs);\n\t\t\t(void) gss_release_oid_set(&tmpmin, &goodmechs);\n\t\t}\n\t}\n\n\t(void) gss_release_oid_set(&tmpmin, &mechs);\n\tif (found == 0 || major_status != GSS_S_COMPLETE) {\n\t\t*minor_status = ERR_SPNEGO_NO_MECHS_AVAILABLE;\n\t\tmap_errcode(minor_status);\n\t\tif (major_status == GSS_S_COMPLETE)\n\t\t\tmajor_status = GSS_S_FAILURE;\n\t}\n\n\treturn (major_status);\n}\n", "target": 0, "idx": 43814}
{"func": " EncodedJSValue JSC_HOST_CALL jsTestObjConstructorFunctionClassMethod2(ExecState* exec)\n {\n     if (exec->argumentCount() < 1)\n        return throwVMError(exec, createTypeError(exec, \"Not enough arguments\"));\n     return JSValue::encode(JSTestObj::classMethod2(exec));\n }\n", "target": 1, "idx": 184036}
{"func": "LockScreenMediaControlsView::LockScreenMediaControlsView(\n    service_manager::Connector* connector,\n    const Callbacks& callbacks)\n    : connector_(connector),\n      hide_controls_timer_(new base::OneShotTimer()),\n      media_controls_enabled_(callbacks.media_controls_enabled),\n      hide_media_controls_(callbacks.hide_media_controls),\n      show_media_controls_(callbacks.show_media_controls) {\n  DCHECK(callbacks.media_controls_enabled);\n  DCHECK(callbacks.hide_media_controls);\n  DCHECK(callbacks.show_media_controls);\n\n  Shell::Get()->media_controller()->SetMediaControlsDismissed(false);\n\n  middle_spacing_ = std::make_unique<NonAccessibleView>();\n  middle_spacing_->set_owned_by_client();\n\n  set_notify_enter_exit_on_child(true);\n \n   contents_view_ = AddChildView(std::make_unique<views::View>());\n   contents_view_->SetLayoutManager(std::make_unique<views::BoxLayout>(\n      views::BoxLayout::Orientation::kVertical));\n   contents_view_->SetBackground(views::CreateRoundedRectBackground(\n       kMediaControlsBackground, kMediaControlsCornerRadius));\n \n   contents_view_->SetPaintToLayer();  // Needed for opacity animation.\n   contents_view_->layer()->SetFillsBoundsOpaquely(false);\n \n  auto close_button_row = std::make_unique<NonAccessibleView>();\n  views::GridLayout* close_button_layout =\n      close_button_row->SetLayoutManager(std::make_unique<views::GridLayout>());\n  views::ColumnSet* columns = close_button_layout->AddColumnSet(0);\n  columns->AddPaddingColumn(0, kCloseButtonOffset);\n  columns->AddColumn(views::GridLayout::CENTER, views::GridLayout::CENTER, 0,\n                     views::GridLayout::USE_PREF, 0, 0);\n  close_button_layout->StartRowWithPadding(\n      0, 0, 0, 5 /* padding between close button and top of view */);\n  auto close_button = CreateVectorImageButton(this);\n  SetImageFromVectorIcon(close_button.get(), vector_icons::kCloseRoundedIcon,\n                         kCloseButtonIconSize, gfx::kGoogleGrey700);\n  close_button->SetPreferredSize(kCloseButtonSize);\n  close_button->SetFocusBehavior(View::FocusBehavior::ALWAYS);\n  base::string16 close_button_label(\n      l10n_util::GetStringUTF16(IDS_ASH_LOCK_SCREEN_MEDIA_CONTROLS_CLOSE));\n  close_button->SetAccessibleName(close_button_label);\n  close_button_ = close_button_layout->AddView(std::move(close_button));\n  close_button_->SetVisible(false);\n  contents_view_->AddChildView(std::move(close_button_row));\n  header_row_ =\n      contents_view_->AddChildView(std::make_unique<MediaControlsHeaderView>());\n \n   auto session_artwork = std::make_unique<views::ImageView>();\n  session_artwork->SetPreferredSize(\n      gfx::Size(kArtworkViewWidth, kArtworkViewHeight));\n  session_artwork->SetBorder(views::CreateEmptyBorder(kArtworkInsets));\n   session_artwork_ = contents_view_->AddChildView(std::move(session_artwork));\n \n   progress_ = contents_view_->AddChildView(\n      std::make_unique<media_message_center::MediaControlsProgressView>(\n          base::BindRepeating(&LockScreenMediaControlsView::SeekTo,\n                              base::Unretained(this))));\n\n  auto button_row = std::make_unique<NonAccessibleView>();\n  auto* button_row_layout =\n      button_row->SetLayoutManager(std::make_unique<views::BoxLayout>(\n          views::BoxLayout::Orientation::kHorizontal, kButtonRowInsets,\n          kMediaButtonRowSeparator));\n  button_row_layout->set_cross_axis_alignment(\n      views::BoxLayout::CrossAxisAlignment::kCenter);\n  button_row_layout->set_main_axis_alignment(\n      views::BoxLayout::MainAxisAlignment::kCenter);\n  button_row->SetPreferredSize(kMediaControlsButtonRowSize);\n  button_row_ = contents_view_->AddChildView(std::move(button_row));\n\n  CreateMediaButton(\n      kChangeTrackIconSize, MediaSessionAction::kPreviousTrack,\n      l10n_util::GetStringUTF16(\n          IDS_ASH_LOCK_SCREEN_MEDIA_CONTROLS_ACTION_PREVIOUS_TRACK));\n\n  CreateMediaButton(\n      kSeekingIconsSize, MediaSessionAction::kSeekBackward,\n      l10n_util::GetStringUTF16(\n          IDS_ASH_LOCK_SCREEN_MEDIA_CONTROLS_ACTION_SEEK_BACKWARD));\n\n  auto play_pause_button = views::CreateVectorToggleImageButton(this);\n  play_pause_button->set_tag(static_cast<int>(MediaSessionAction::kPause));\n  play_pause_button->SetPreferredSize(kMediaButtonSize);\n  play_pause_button->SetFocusBehavior(views::View::FocusBehavior::ALWAYS);\n  play_pause_button->SetTooltipText(l10n_util::GetStringUTF16(\n      IDS_ASH_LOCK_SCREEN_MEDIA_CONTROLS_ACTION_PAUSE));\n  play_pause_button->SetToggledTooltipText(l10n_util::GetStringUTF16(\n      IDS_ASH_LOCK_SCREEN_MEDIA_CONTROLS_ACTION_PLAY));\n  play_pause_button_ = button_row_->AddChildView(std::move(play_pause_button));\n\n  views::SetImageFromVectorIcon(\n      play_pause_button_,\n      GetVectorIconForMediaAction(MediaSessionAction::kPause),\n      kPlayPauseIconSize, kMediaButtonColor);\n  views::SetToggledImageFromVectorIcon(\n      play_pause_button_,\n      GetVectorIconForMediaAction(MediaSessionAction::kPlay),\n      kPlayPauseIconSize, kMediaButtonColor);\n\n  CreateMediaButton(\n      kSeekingIconsSize, MediaSessionAction::kSeekForward,\n      l10n_util::GetStringUTF16(\n          IDS_ASH_LOCK_SCREEN_MEDIA_CONTROLS_ACTION_SEEK_FORWARD));\n\n  CreateMediaButton(kChangeTrackIconSize, MediaSessionAction::kNextTrack,\n                    l10n_util::GetStringUTF16(\n                        IDS_ASH_LOCK_SCREEN_MEDIA_CONTROLS_ACTION_NEXT_TRACK));\n\n  MediaSessionMetadataChanged(base::nullopt);\n  MediaSessionPositionChanged(base::nullopt);\n  MediaControllerImageChanged(\n      media_session::mojom::MediaSessionImageType::kSourceIcon, SkBitmap());\n  SetArtwork(base::nullopt);\n\n  if (!connector_)\n    return;\n\n  mojo::Remote<media_session::mojom::MediaControllerManager>\n      controller_manager_remote;\n  connector_->Connect(media_session::mojom::kServiceName,\n                      controller_manager_remote.BindNewPipeAndPassReceiver());\n  controller_manager_remote->CreateActiveMediaController(\n      media_controller_remote_.BindNewPipeAndPassReceiver());\n\n  media_controller_remote_->AddObserver(\n      observer_receiver_.BindNewPipeAndPassRemote());\n\n  media_controller_remote_->ObserveImages(\n      media_session::mojom::MediaSessionImageType::kArtwork,\n      kMinimumArtworkSize, kDesiredArtworkSize,\n      artwork_observer_receiver_.BindNewPipeAndPassRemote());\n\n  media_controller_remote_->ObserveImages(\n      media_session::mojom::MediaSessionImageType::kSourceIcon,\n      kMinimumIconSize, kDesiredIconSize,\n      icon_observer_receiver_.BindNewPipeAndPassRemote());\n}\n", "target": 1, "idx": 186307}
{"func": "void PageHandler::PrintToPDF(Maybe<bool> landscape,\n                             Maybe<bool> display_header_footer,\n                             Maybe<bool> print_background,\n                             Maybe<double> scale,\n                             Maybe<double> paper_width,\n                             Maybe<double> paper_height,\n                             Maybe<double> margin_top,\n                             Maybe<double> margin_bottom,\n                             Maybe<double> margin_left,\n                              Maybe<double> margin_right,\n                              Maybe<String> page_ranges,\n                              Maybe<bool> ignore_invalid_page_ranges,\n                              std::unique_ptr<PrintToPDFCallback> callback) {\n   callback->sendFailure(Response::Error(\"PrintToPDF is not implemented\"));\n   return;\n}\n", "target": 1, "idx": 186877}
{"func": "xfs_attr3_leaf_flipflags(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf1;\n\tstruct xfs_attr_leafblock *leaf2;\n\tstruct xfs_attr_leaf_entry *entry1;\n\tstruct xfs_attr_leaf_entry *entry2;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_buf\t\t*bp1;\n\tstruct xfs_buf\t\t*bp2;\n\tint error;\n#ifdef DEBUG\n\tstruct xfs_attr3_icleaf_hdr ichdr1;\n\tstruct xfs_attr3_icleaf_hdr ichdr2;\n\txfs_attr_leaf_name_local_t *name_loc;\n\tint namelen1, namelen2;\n\tchar *name1, *name2;\n#endif /* DEBUG */\n\n\ttrace_xfs_attr_leaf_flipflags(args);\n\n\t/*\n\t * Read the block containing the \"old\" attr\n\t */\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp1);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Read the block containing the \"new\" attr, if it is different\n\t */\n\tif (args->blkno2 != args->blkno) {\n\t\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno2,\n\t\t\t\t\t   -1, &bp2);\n\t\tif (error)\n\t\t\treturn error;\n\t} else {\n\t\tbp2 = bp1;\n\t}\n\n\tleaf1 = bp1->b_addr;\n\tentry1 = &xfs_attr3_leaf_entryp(leaf1)[args->index];\n\n\tleaf2 = bp2->b_addr;\n\tentry2 = &xfs_attr3_leaf_entryp(leaf2)[args->index2];\n\n#ifdef DEBUG\n\txfs_attr3_leaf_hdr_from_disk(&ichdr1, leaf1);\n\tASSERT(args->index < ichdr1.count);\n\tASSERT(args->index >= 0);\n\n\txfs_attr3_leaf_hdr_from_disk(&ichdr2, leaf2);\n\tASSERT(args->index2 < ichdr2.count);\n\tASSERT(args->index2 >= 0);\n\n\tif (entry1->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf1, args->index);\n\t\tnamelen1 = name_loc->namelen;\n\t\tname1 = (char *)name_loc->nameval;\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf1, args->index);\n\t\tnamelen1 = name_rmt->namelen;\n\t\tname1 = (char *)name_rmt->name;\n\t}\n\tif (entry2->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf2, args->index2);\n\t\tnamelen2 = name_loc->namelen;\n\t\tname2 = (char *)name_loc->nameval;\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf2, args->index2);\n\t\tnamelen2 = name_rmt->namelen;\n\t\tname2 = (char *)name_rmt->name;\n\t}\n\tASSERT(be32_to_cpu(entry1->hashval) == be32_to_cpu(entry2->hashval));\n\tASSERT(namelen1 == namelen2);\n\tASSERT(memcmp(name1, name2, namelen1) == 0);\n#endif /* DEBUG */\n\n\tASSERT(entry1->flags & XFS_ATTR_INCOMPLETE);\n\tASSERT((entry2->flags & XFS_ATTR_INCOMPLETE) == 0);\n\n\tentry1->flags &= ~XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp1,\n\t\t\t  XFS_DA_LOGRANGE(leaf1, entry1, sizeof(*entry1)));\n\tif (args->rmtblkno) {\n \t\tASSERT((entry1->flags & XFS_ATTR_LOCAL) == 0);\n \t\tname_rmt = xfs_attr3_leaf_name_remote(leaf1, args->index);\n \t\tname_rmt->valueblk = cpu_to_be32(args->rmtblkno);\n\t\tname_rmt->valuelen = cpu_to_be32(args->valuelen);\n \t\txfs_trans_log_buf(args->trans, bp1,\n \t\t\t XFS_DA_LOGRANGE(leaf1, name_rmt, sizeof(*name_rmt)));\n \t}\n\n\tentry2->flags |= XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp2,\n\t\t\t  XFS_DA_LOGRANGE(leaf2, entry2, sizeof(*entry2)));\n\tif ((entry2->flags & XFS_ATTR_LOCAL) == 0) {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf2, args->index2);\n\t\tname_rmt->valueblk = 0;\n\t\tname_rmt->valuelen = 0;\n\t\txfs_trans_log_buf(args->trans, bp2,\n\t\t\t XFS_DA_LOGRANGE(leaf2, name_rmt, sizeof(*name_rmt)));\n\t}\n\n\t/*\n\t * Commit the flag value change and start the next trans in series.\n\t */\n\terror = xfs_trans_roll(&args->trans, args->dp);\n\n\treturn error;\n}\n", "target": 1, "idx": 179907}
{"func": "static void addEventListenerMethod(const v8::FunctionCallbackInfo<v8::Value>& info)\n{\n    ExceptionState exceptionState(ExceptionState::ExecutionContext, \"addEventListener\", \"TestObjectPython\", info.Holder(), info.GetIsolate());\n    EventTarget* impl = V8TestObjectPython::toNative(info.Holder());\n    if (DOMWindow* window = impl->toDOMWindow()) {\n        if (!BindingSecurity::shouldAllowAccessToFrame(info.GetIsolate(), window->frame(), exceptionState)) {\n            exceptionState.throwIfNeeded();\n            return;\n        }\n        if (!window->document())\n            return;\n    }\n    RefPtr<EventListener> listener = V8EventListenerList::getEventListener(info[1], false, ListenerFindOrCreate);\n    if (listener) {\n        V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID(V8StringResource<WithNullCheck>, eventName, info[0]);\n        impl->addEventListener(eventName, listener, info[2]->BooleanValue());\n        if (!impl->toNode())\n            addHiddenValueToArray(info.Holder(), info[1], V8TestObjectPython::eventListenerCacheIndex, info.GetIsolate());\n    }\n}\n", "target": 0, "idx": 131207}
{"func": "static unsigned long target_load(int cpu, int type)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tunsigned long total = weighted_cpuload(cpu);\n\n\tif (type == 0 || !sched_feat(LB_BIAS))\n\t\treturn total;\n\n\treturn max(rq->cpu_load[type-1], total);\n}\n", "target": 0, "idx": 22609}
{"func": " int main(int argc, char **argv) {\n   FILE *infile = NULL;\n  vpx_codec_ctx_t codec = {0};\n  vpx_codec_enc_cfg_t cfg = {0};\n   int frame_count = 0;\n  vpx_image_t raw = {0};\n   vpx_codec_err_t res;\n  VpxVideoInfo info = {0};\n   VpxVideoWriter *writer = NULL;\n   const VpxInterface *encoder = NULL;\n   const int fps = 2;        // TODO(dkovalev) add command line argument\n   const double bits_per_pixel_per_frame = 0.067;\n \n   exec_name = argv[0];\n   if (argc != 6)\n     die(\"Invalid number of arguments\");\n \n  encoder = get_vpx_encoder_by_name(argv[1]);\n  if (!encoder)\n    die(\"Unsupported codec.\");\n \n   info.codec_fourcc = encoder->fourcc;\n   info.frame_width = strtol(argv[2], NULL, 0);\n   info.frame_height = strtol(argv[3], NULL, 0);\n  info.time_base.numerator = 1;\n  info.time_base.denominator = fps;\n\n if (info.frame_width <= 0 ||\n      info.frame_height <= 0 ||\n (info.frame_width % 2) != 0 ||\n (info.frame_height % 2) != 0) {\n    die(\"Invalid frame size: %dx%d\", info.frame_width, info.frame_height);\n }\n\n if (!vpx_img_alloc(&raw, VPX_IMG_FMT_I420, info.frame_width,\n                                             info.frame_height, 1)) {\n\n     die(\"Failed to allocate image.\");\n   }\n \n  printf(\"Using %s\\n\", vpx_codec_iface_name(encoder->interface()));\n \n  res = vpx_codec_enc_config_default(encoder->interface(), &cfg, 0);\n   if (res)\n     die_codec(&codec, \"Failed to get default codec config.\");\n \n  cfg.g_w = info.frame_width;\n  cfg.g_h = info.frame_height;\n  cfg.g_timebase.num = info.time_base.numerator;\n  cfg.g_timebase.den = info.time_base.denominator;\n  cfg.rc_target_bitrate = (unsigned int)(bits_per_pixel_per_frame * cfg.g_w *\n                                         cfg.g_h * fps / 1000);\n  cfg.g_lag_in_frames = 0;\n\n  writer = vpx_video_writer_open(argv[5], kContainerIVF, &info);\n if (!writer)\n    die(\"Failed to open %s for writing.\", argv[5]);\n\n\n   if (!(infile = fopen(argv[4], \"rb\")))\n     die(\"Failed to open %s for reading.\", argv[4]);\n \n  if (vpx_codec_enc_init(&codec, encoder->interface(), &cfg, 0))\n     die_codec(&codec, \"Failed to initialize encoder\");\n \n   while (vpx_img_read(&raw, infile)) {\n     ++frame_count;\n \n if (frame_count == 22 && encoder->fourcc == VP8_FOURCC) {\n      set_roi_map(&cfg, &codec);\n } else if (frame_count == 33) {\n      set_active_map(&cfg, &codec);\n } else if (frame_count == 44) {\n      unset_active_map(&cfg, &codec);\n }\n\n \n     encode_frame(&codec, &raw, frame_count, writer);\n   }\n  encode_frame(&codec, NULL, -1, writer);\n   printf(\"\\n\");\n   fclose(infile);\n   printf(\"Processed %d frames.\\n\", frame_count);\n\n  vpx_img_free(&raw);\n if (vpx_codec_destroy(&codec))\n    die_codec(&codec, \"Failed to destroy codec.\");\n\n  vpx_video_writer_close(writer);\n\n return EXIT_SUCCESS;\n}\n", "target": 1, "idx": 188504}
{"func": "  MojoAudioInputStreamTest()\n      : foreign_socket_(std::make_unique<TestCancelableSyncSocket>()),\n        client_binding_(&client_, mojo::MakeRequest(&client_ptr_)) {}\n", "target": 0, "idx": 162351}
{"func": "WebMediaPlayer::CorsMode HTMLMediaElement::CorsMode() const {\n  const AtomicString& cross_origin_mode = FastGetAttribute(kCrossoriginAttr);\n  if (cross_origin_mode.IsNull())\n    return WebMediaPlayer::kCorsModeUnspecified;\n  if (DeprecatedEqualIgnoringCase(cross_origin_mode, \"use-credentials\"))\n    return WebMediaPlayer::kCorsModeUseCredentials;\n  return WebMediaPlayer::kCorsModeAnonymous;\n}\n", "target": 0, "idx": 142767}
{"func": "void copy_io_context(struct io_context **pdst, struct io_context **psrc)\n{\n\tstruct io_context *src = *psrc;\n\tstruct io_context *dst = *pdst;\n\n\tif (src) {\n\t\tBUG_ON(atomic_long_read(&src->refcount) == 0);\n\t\tatomic_long_inc(&src->refcount);\n\t\tput_io_context(dst);\n\t\t*pdst = src;\n\t}\n}\n", "target": 0, "idx": 21571}
{"func": "vips_foreign_save( VipsImage *in, const char *name, ... )\n{\n\tchar filename[VIPS_PATH_MAX];\n\tchar option_string[VIPS_PATH_MAX];\n\tconst char *operation_name;\n\tva_list ap;\n\tint result;\n\n\tvips__filename_split8( name, filename, option_string );\n\n\tif( !(operation_name = vips_foreign_find_save( filename )) )\n\t\treturn( -1 );\n\n\tva_start( ap, name );\n\tresult = vips_call_split_option_string( operation_name, option_string, \n\t\tap, in, filename );\n\tva_end( ap );\n\n\treturn( result );\n}\n", "target": 0, "idx": 83913}
{"func": "String FrameLoader::outgoingReferrer() const\n{\n    return m_outgoingReferrer;\n}\n", "target": 0, "idx": 97461}
{"func": "void V8TestObject::DeprecateAsSameValueMeasureAsOverloadedMethodMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), \"Blink_TestObject_deprecateAsSameValueMeasureAsOverloadedMethod\");\n\n  test_object_v8_internal::DeprecateAsSameValueMeasureAsOverloadedMethodMethod(info);\n}\n", "target": 0, "idx": 147331}
{"func": "int validation_checkfp(int count, int argc, char **argv)\n{\n int result;\n   checkfp_command command;\n   checkfp_control control;\n\n   command.number[0] = 0;\n   command.limit = 3;\n   command.verbose = verbose;\n   command.ctimes = 0;\n   command.cmillions = 0;\n   command.cinvalid = 0;\n   command.cnoaccept = 0;\n\n while (--argc > 0)\n {\n ++argv;\n if (argc > 1 && strcmp(*argv, \"-l\") == 0)\n {\n --argc;\n         command.limit = atoi(*++argv);\n }\n\n else\n {\n         fprintf(stderr, \"unknown argument %s\\n\", *argv);\n return 1;\n }\n }\n\n   control.cnumber = 0;\n   control.check_state = start;\n   control.at_start = 1;\n   control.cdigits_in_state = 0;\n   control.limit = command.limit;\n   control.state = 0;\n   control.is_negative = 0;\n   control.is_zero = 1;\n   control.number_was_valid = 0;\n\n   result = check_all_characters(&command, control);\n\n   printf(\"checkfp: %s: checked %d,%.3d,%.3d,%.3d strings (%d invalid)\\n\",\n      result ? \"pass\" : \"FAIL\", command.cmillions / 1000,\n      command.cmillions % 1000, command.ctimes / 1000, command.ctimes % 1000,\n      command.cinvalid);\n\n return result;\n}\n", "target": 0, "idx": 173272}
{"func": "void batchConfigureConstants(v8::Handle<v8::FunctionTemplate> functionDescriptor,\n                             v8::Handle<v8::ObjectTemplate> proto,\n                             const BatchedConstant* constants,\n                             size_t constantCount)\n{\n    for (size_t i = 0; i < constantCount; ++i) {\n        const BatchedConstant* constant = &constants[i];\n        functionDescriptor->Set(v8::String::New(constant->name), v8::Integer::New(constant->value), v8::ReadOnly);\n        proto->Set(v8::String::New(constant->name), v8::Integer::New(constant->value), v8::ReadOnly);\n    }\n}\n", "target": 0, "idx": 117977}
{"func": "KeyTypeCreate(xkb_atom_t name, VarDef *body)\n{\n    KeyTypeDef *def = malloc(sizeof(*def));\n    if (!def)\n        return NULL;\n\n    def->common.type = STMT_TYPE;\n    def->common.next = NULL;\n    def->merge = MERGE_DEFAULT;\n    def->name = name;\n    def->body = body;\n\n    return def;\n}\n", "target": 0, "idx": 79000}
{"func": "static void hidg_disable(struct usb_function *f)\n{\n\tstruct f_hidg *hidg = func_to_hidg(f);\n\tstruct f_hidg_req_list *list, *next;\n\tunsigned long flags;\n\n\tusb_ep_disable(hidg->in_ep);\n\tusb_ep_disable(hidg->out_ep);\n\n\tspin_lock_irqsave(&hidg->read_spinlock, flags);\n\tlist_for_each_entry_safe(list, next, &hidg->completed_out_req, list) {\n\t\tfree_ep_req(hidg->out_ep, list->req);\n\t\tlist_del(&list->list);\n\t\tkfree(list);\n\t}\n\tspin_unlock_irqrestore(&hidg->read_spinlock, flags);\n\n\tspin_lock_irqsave(&hidg->write_spinlock, flags);\n\tif (!hidg->write_pending) {\n\t\tfree_ep_req(hidg->in_ep, hidg->req);\n\t\thidg->write_pending = 1;\n\t}\n\n\thidg->req = NULL;\n\tspin_unlock_irqrestore(&hidg->write_spinlock, flags);\n}\n", "target": 0, "idx": 96683}
{"func": "static int override_release(char __user *release, int len)\n {\n \tint ret = 0;\n\tchar buf[65];\n \n \tif (current->personality & UNAME26) {\n\t\tchar *rest = UTS_RELEASE;\n \t\tint ndots = 0;\n \t\tunsigned v;\n \n \t\twhile (*rest) {\n \t\t\tif (*rest == '.' && ++ndots >= 3)\n\t\t\t\tbreak;\n\t\t\tif (!isdigit(*rest) && *rest != '.')\n\t\t\t\tbreak;\n \t\t\trest++;\n \t\t}\n \t\tv = ((LINUX_VERSION_CODE >> 8) & 0xff) + 40;\n\t\tsnprintf(buf, len, \"2.6.%u%s\", v, rest);\n\t\tret = copy_to_user(release, buf, len);\n \t}\n \treturn ret;\n }\n", "target": 1, "idx": 178819}
{"func": "OMX_ERRORTYPE  omx_video::use_output_buffer(\n        OMX_IN OMX_HANDLETYPE            hComp,\n        OMX_INOUT OMX_BUFFERHEADERTYPE** bufferHdr,\n        OMX_IN OMX_U32                   port,\n        OMX_IN OMX_PTR                   appData,\n        OMX_IN OMX_U32                   bytes,\n        OMX_IN OMX_U8*                   buffer)\n{\n (void)hComp, (void)port;\n    OMX_ERRORTYPE eRet = OMX_ErrorNone;\n    OMX_BUFFERHEADERTYPE       *bufHdr= NULL; // buffer header\n unsigned                         i= 0; // Temporary counter\n unsigned char *buf_addr = NULL;\n#ifdef _MSM8974_\n int align_size;\n#endif\n\n    DEBUG_PRINT_HIGH(\"Inside use_output_buffer()\");\n if (bytes != m_sOutPortDef.nBufferSize) {\n        DEBUG_PRINT_ERROR(\"ERROR: use_output_buffer: Size Mismatch!! \"\n \"bytes[%u] != Port.nBufferSize[%u]\", (unsigned int)bytes, (unsigned int)m_sOutPortDef.nBufferSize);\n return OMX_ErrorBadParameter;\n }\n\n if (!m_out_mem_ptr) {\n        output_use_buffer = true;\n int nBufHdrSize        = 0;\n\n        DEBUG_PRINT_LOW(\"Allocating First Output Buffer(%u)\",(unsigned int)m_sOutPortDef.nBufferCountActual);\n        nBufHdrSize        = m_sOutPortDef.nBufferCountActual * sizeof(OMX_BUFFERHEADERTYPE);\n /*\n         * Memory for output side involves the following:\n         * 1. Array of Buffer Headers\n         * 2. Bitmask array to hold the buffer allocation details\n         * In order to minimize the memory management entire allocation\n         * is done in one step.\n         */\n        m_out_mem_ptr = (OMX_BUFFERHEADERTYPE  *)calloc(nBufHdrSize,1);\n if (m_out_mem_ptr == NULL) {\n            DEBUG_PRINT_ERROR(\"ERROR: calloc() Failed for m_out_mem_ptr\");\n return OMX_ErrorInsufficientResources;\n }\n\n        m_pOutput_pmem = (struct pmem *) calloc(sizeof (struct pmem), m_sOutPortDef.nBufferCountActual);\n if (m_pOutput_pmem == NULL) {\n            DEBUG_PRINT_ERROR(\"ERROR: calloc() Failed for m_pOutput_pmem\");\n return OMX_ErrorInsufficientResources;\n }\n#ifdef USE_ION\n        m_pOutput_ion = (struct venc_ion *) calloc(sizeof (struct venc_ion), m_sOutPortDef.nBufferCountActual);\n if (m_pOutput_ion == NULL) {\n            DEBUG_PRINT_ERROR(\"ERROR: calloc() Failed for m_pOutput_ion\");\n return OMX_ErrorInsufficientResources;\n }\n#endif\n if (m_out_mem_ptr) {\n            bufHdr          =  m_out_mem_ptr;\n            DEBUG_PRINT_LOW(\"Memory Allocation Succeeded for OUT port%p\",m_out_mem_ptr);\n for (i=0; i < m_sOutPortDef.nBufferCountActual ; i++) {\n                bufHdr->nSize              = sizeof(OMX_BUFFERHEADERTYPE);\n                bufHdr->nVersion.nVersion  = OMX_SPEC_VERSION;\n                bufHdr->nAllocLen          = bytes;\n                bufHdr->nFilledLen         = 0;\n                bufHdr->pAppPrivate        = appData;\n                bufHdr->nOutputPortIndex   = PORT_INDEX_OUT;\n                bufHdr->pBuffer            = NULL;\n                bufHdr++;\n                m_pOutput_pmem[i].fd = -1;\n#ifdef USE_ION\n                m_pOutput_ion[i].ion_device_fd =-1;\n                m_pOutput_ion[i].fd_ion_data.fd=-1;\n                m_pOutput_ion[i].ion_alloc_data.handle = 0;\n#endif\n }\n } else {\n            DEBUG_PRINT_ERROR(\"ERROR: Output buf mem alloc failed[0x%p]\",m_out_mem_ptr);\n            eRet =  OMX_ErrorInsufficientResources;\n }\n }\n\n for (i=0; i< m_sOutPortDef.nBufferCountActual; i++) {\n if (BITMASK_ABSENT(&m_out_bm_count,i)) {\n break;\n }\n }\n\n if (eRet == OMX_ErrorNone) {\n if (i < m_sOutPortDef.nBufferCountActual) {\n *bufferHdr = (m_out_mem_ptr + i );\n (*bufferHdr)->pBuffer = (OMX_U8 *)buffer;\n (*bufferHdr)->pAppPrivate = appData;\n\n if (!m_use_output_pmem) {\n#ifdef USE_ION\n#ifdef _MSM8974_\n                align_size = (m_sOutPortDef.nBufferSize + (SZ_4K - 1)) & ~(SZ_4K - 1);\n                m_pOutput_ion[i].ion_device_fd = alloc_map_ion_memory(align_size,\n &m_pOutput_ion[i].ion_alloc_data,\n &m_pOutput_ion[i].fd_ion_data,0);\n#else\n                m_pOutput_ion[i].ion_device_fd = alloc_map_ion_memory(\n                        m_sOutPortDef.nBufferSize,\n &m_pOutput_ion[i].ion_alloc_data,\n &m_pOutput_ion[i].fd_ion_data,ION_FLAG_CACHED);\n#endif\n if (m_pOutput_ion[i].ion_device_fd < 0) {\n                    DEBUG_PRINT_ERROR(\"ERROR:ION device open() Failed\");\n return OMX_ErrorInsufficientResources;\n }\n                m_pOutput_pmem[i].fd = m_pOutput_ion[i].fd_ion_data.fd;\n#else\n                m_pOutput_pmem[i].fd = open (MEM_DEVICE,O_RDWR);\n\n if (m_pOutput_pmem[i].fd == 0) {\n                    m_pOutput_pmem[i].fd = open (MEM_DEVICE,O_RDWR);\n }\n\n if (m_pOutput_pmem[i].fd < 0) {\n                    DEBUG_PRINT_ERROR(\"ERROR: /dev/pmem_adsp open() Failed\");\n return OMX_ErrorInsufficientResources;\n }\n#endif\n\n                 m_pOutput_pmem[i].size = m_sOutPortDef.nBufferSize;\n                 m_pOutput_pmem[i].offset = 0;\n \n                m_pOutput_pmem[i].buffer = (OMX_U8 *)SECURE_BUFPTR;\n                 if(!secure_session) {\n #ifdef _MSM8974_\n                     m_pOutput_pmem[i].buffer = (unsigned char *)mmap(NULL,\n                        align_size,PROT_READ|PROT_WRITE,\n                        MAP_SHARED,m_pOutput_pmem[i].fd,0);\n#else\n                    m_pOutput_pmem[i].buffer = (unsigned char *)mmap(NULL,\n                        m_pOutput_pmem[i].size,PROT_READ|PROT_WRITE,\n                        MAP_SHARED,m_pOutput_pmem[i].fd,0);\n\n #endif\n                 if (m_pOutput_pmem[i].buffer == MAP_FAILED) {\n                         DEBUG_PRINT_ERROR(\"ERROR: mmap() Failed\");\n                     close(m_pOutput_pmem[i].fd);\n #ifdef USE_ION\n                     free_ion_memory(&m_pOutput_ion[i]);\n#endif\n return OMX_ErrorInsufficientResources;\n }\n }\n } else {\n                OMX_QCOM_PLATFORM_PRIVATE_PMEM_INFO *pParam = reinterpret_cast<OMX_QCOM_PLATFORM_PRIVATE_PMEM_INFO*>((*bufferHdr)->pAppPrivate);\n                DEBUG_PRINT_LOW(\"Inside qcom_ext pParam: %p\", pParam);\n\n if (pParam) {\n                    DEBUG_PRINT_LOW(\"Inside qcom_ext with luma:(fd:%lu,offset:0x%x)\", pParam->pmem_fd, (int)pParam->offset);\n                    m_pOutput_pmem[i].fd = pParam->pmem_fd;\n                    m_pOutput_pmem[i].offset = pParam->offset;\n                    m_pOutput_pmem[i].size = m_sOutPortDef.nBufferSize;\n                    m_pOutput_pmem[i].buffer = (unsigned char *)buffer;\n } else {\n                    DEBUG_PRINT_ERROR(\"ERROR: Invalid AppData given for PMEM o/p UseBuffer case\");\n return OMX_ErrorBadParameter;\n }\n                buf_addr = (unsigned char *)buffer;\n }\n\n            DEBUG_PRINT_LOW(\"use_out:: bufhdr = %p, pBuffer = %p, m_pOutput_pmem[i].buffer = %p\",\n (*bufferHdr), (*bufferHdr)->pBuffer, m_pOutput_pmem[i].buffer);\n if (dev_use_buf(&m_pOutput_pmem[i],PORT_INDEX_OUT,i) != true) {\n                DEBUG_PRINT_ERROR(\"ERROR: dev_use_buf Failed for o/p buf\");\n return OMX_ErrorInsufficientResources;\n }\n\n            BITMASK_SET(&m_out_bm_count,i);\n } else {\n            DEBUG_PRINT_ERROR(\"ERROR: All o/p Buffers have been Used, invalid use_buf call for \"\n \"index = %u\", i);\n            eRet = OMX_ErrorInsufficientResources;\n }\n }\n return eRet;\n}\n", "target": 1, "idx": 187526}
{"func": "int mlx4_register_vlan(struct mlx4_dev *dev, u8 port, u16 vlan, int *index)\n{\n\tstruct mlx4_vlan_table *table = &mlx4_priv(dev)->port[port].vlan_table;\n\tint i, err = 0;\n\tint free = -1;\n\n\tmutex_lock(&table->mutex);\n\tfor (i = MLX4_VLAN_REGULAR; i < MLX4_MAX_VLAN_NUM; i++) {\n\t\tif (free < 0 && (table->refs[i] == 0)) {\n\t\t\tfree = i;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (table->refs[i] &&\n\t\t    (vlan == (MLX4_VLAN_MASK &\n\t\t\t      be32_to_cpu(table->entries[i])))) {\n\t\t\t/* Vlan already registered, increase refernce count */\n\t\t\t*index = i;\n\t\t\t++table->refs[i];\n\t\t\tgoto out;\n \t\t}\n \t}\n \n \tif (table->total == table->max) {\n \t\t/* No free vlan entries */\n \t\terr = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t/* Register new MAC */\n\ttable->refs[free] = 1;\n\ttable->entries[free] = cpu_to_be32(vlan | MLX4_VLAN_VALID);\n\n\terr = mlx4_set_port_vlan_table(dev, port, table->entries);\n\tif (unlikely(err)) {\n\t\tmlx4_warn(dev, \"Failed adding vlan: %u\\n\", vlan);\n\t\ttable->refs[free] = 0;\n\t\ttable->entries[free] = 0;\n\t\tgoto out;\n\t}\n\n\t*index = free;\n\t++table->total;\nout:\n\tmutex_unlock(&table->mutex);\n\treturn err;\n}\n", "target": 1, "idx": 183044}
{"func": "TIFFComputeStrip(TIFF* tif, uint32 row, uint16 sample)\n{\n\tstatic const char module[] = \"TIFFComputeStrip\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint32 strip;\n\n\tstrip = row / td->td_rowsperstrip;\n\tif (td->td_planarconfig == PLANARCONFIG_SEPARATE) {\n\t\tif (sample >= td->td_samplesperpixel) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t    \"%lu: Sample out of range, max %lu\",\n\t\t\t    (unsigned long) sample, (unsigned long) td->td_samplesperpixel);\n\t\t\treturn (0);\n\t\t}\n\t\tstrip += (uint32)sample*td->td_stripsperimage;\n\t}\n\treturn (strip);\n}\n", "target": 0, "idx": 70210}
{"func": "static int try_to_unmap_cluster(unsigned long cursor, unsigned int *mapcount,\n\t\tstruct vm_area_struct *vma, struct page *check_page)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpmd_t *pmd;\n\tpte_t *pte;\n\tpte_t pteval;\n\tspinlock_t *ptl;\n\tstruct page *page;\n\tunsigned long address;\n\tunsigned long mmun_start;\t/* For mmu_notifiers */\n\tunsigned long mmun_end;\t\t/* For mmu_notifiers */\n\tunsigned long end;\n\tint ret = SWAP_AGAIN;\n\tint locked_vma = 0;\n\n\taddress = (vma->vm_start + cursor) & CLUSTER_MASK;\n\tend = address + CLUSTER_SIZE;\n\tif (address < vma->vm_start)\n\t\taddress = vma->vm_start;\n\tif (end > vma->vm_end)\n\t\tend = vma->vm_end;\n\n\tpmd = mm_find_pmd(mm, address);\n\tif (!pmd)\n\t\treturn ret;\n\n\tmmun_start = address;\n\tmmun_end   = end;\n\tmmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end);\n\n\t/*\n\t * If we can acquire the mmap_sem for read, and vma is VM_LOCKED,\n\t * keep the sem while scanning the cluster for mlocking pages.\n\t */\n\tif (down_read_trylock(&vma->vm_mm->mmap_sem)) {\n\t\tlocked_vma = (vma->vm_flags & VM_LOCKED);\n\t\tif (!locked_vma)\n\t\t\tup_read(&vma->vm_mm->mmap_sem); /* don't need it */\n\t}\n\n\tpte = pte_offset_map_lock(mm, pmd, address, &ptl);\n\n\t/* Update high watermark before we lower rss */\n\tupdate_hiwater_rss(mm);\n\n\tfor (; address < end; pte++, address += PAGE_SIZE) {\n\t\tif (!pte_present(*pte))\n\t\t\tcontinue;\n\t\tpage = vm_normal_page(vma, address, *pte);\n \t\tBUG_ON(!page || PageAnon(page));\n \n \t\tif (locked_vma) {\n\t\t\tmlock_vma_page(page);   /* no-op if already mlocked */\n\t\t\tif (page == check_page)\n \t\t\t\tret = SWAP_MLOCK;\n \t\t\tcontinue;\t/* don't unmap */\n \t\t}\n \n\t\tif (ptep_clear_flush_young_notify(vma, address, pte))\n\t\t\tcontinue;\n\n\t\t/* Nuke the page table entry. */\n\t\tflush_cache_page(vma, address, pte_pfn(*pte));\n\t\tpteval = ptep_clear_flush(vma, address, pte);\n\n\t\t/* If nonlinear, store the file page offset in the pte. */\n\t\tif (page->index != linear_page_index(vma, address)) {\n\t\t\tpte_t ptfile = pgoff_to_pte(page->index);\n\t\t\tif (pte_soft_dirty(pteval))\n\t\t\t\tpte_file_mksoft_dirty(ptfile);\n\t\t\tset_pte_at(mm, address, pte, ptfile);\n\t\t}\n\n\t\t/* Move the dirty bit to the physical page now the pte is gone. */\n\t\tif (pte_dirty(pteval))\n\t\t\tset_page_dirty(page);\n\n\t\tpage_remove_rmap(page);\n\t\tpage_cache_release(page);\n\t\tdec_mm_counter(mm, MM_FILEPAGES);\n\t\t(*mapcount)--;\n\t}\n\tpte_unmap_unlock(pte - 1, ptl);\n\tmmu_notifier_invalidate_range_end(mm, mmun_start, mmun_end);\n\tif (locked_vma)\n\t\tup_read(&vma->vm_mm->mmap_sem);\n\treturn ret;\n}\n", "target": 1, "idx": 179559}
{"func": "void server_connect_finished(SERVER_REC *server)\n{\n\tserver->connect_time = time(NULL);\n\n\tservers = g_slist_append(servers, server);\n\tsignal_emit(\"server connected\", 1, server);\n}\n", "target": 0, "idx": 18200}
{"func": "void Browser::RenderWidgetShowing() {\n  window_->DisableInactiveFrame();\n}\n", "target": 0, "idx": 101785}
{"func": "static int __net_init ipv6_frags_init_net(struct net *net)\n{\n\tnet->ipv6.frags.high_thresh = IPV6_FRAG_HIGH_THRESH;\n\tnet->ipv6.frags.low_thresh = IPV6_FRAG_LOW_THRESH;\n\tnet->ipv6.frags.timeout = IPV6_FRAG_TIMEOUT;\n\n\tinet_frags_init_net(&net->ipv6.frags);\n\n\treturn ip6_frags_ns_sysctl_register(net);\n}\n", "target": 0, "idx": 18737}
{"func": "void bitmap_writer_build(struct packing_data *to_pack)\n{\n\tstatic const double REUSE_BITMAP_THRESHOLD = 0.2;\n\n\tint i, reuse_after, need_reset;\n\tstruct bitmap *base = bitmap_new();\n\tstruct rev_info revs;\n\n\twriter.bitmaps = kh_init_sha1();\n\twriter.to_pack = to_pack;\n\n\tif (writer.show_progress)\n\t\twriter.progress = start_progress(\"Building bitmaps\", writer.selected_nr);\n\n\tinit_revisions(&revs, NULL);\n\trevs.tag_objects = 1;\n\trevs.tree_objects = 1;\n\trevs.blob_objects = 1;\n\trevs.no_walk = 0;\n\n\trevs.include_check = should_include;\n\treset_revision_walk();\n\n\treuse_after = writer.selected_nr * REUSE_BITMAP_THRESHOLD;\n\tneed_reset = 0;\n\n\tfor (i = writer.selected_nr - 1; i >= 0; --i) {\n\t\tstruct bitmapped_commit *stored;\n\t\tstruct object *object;\n\n\t\tkhiter_t hash_pos;\n\t\tint hash_ret;\n\n\t\tstored = &writer.selected[i];\n\t\tobject = (struct object *)stored->commit;\n\n\t\tif (stored->bitmap == NULL) {\n\t\t\tif (i < writer.selected_nr - 1 &&\n\t\t\t    (need_reset ||\n\t\t\t     !in_merge_bases(writer.selected[i + 1].commit,\n\t\t\t\t\t     stored->commit))) {\n\t\t\t    bitmap_reset(base);\n\t\t\t    reset_all_seen();\n\t\t\t}\n\n\t\t\tadd_pending_object(&revs, object, \"\");\n\t\t\trevs.include_check_data = base;\n\n\t\t\tif (prepare_revision_walk(&revs))\n\t\t\t\tdie(\"revision walk setup failed\");\n\n\t\t\ttraverse_commit_list(&revs, show_commit, show_object, base);\n\n\t\t\trevs.pending.nr = 0;\n\t\t\trevs.pending.alloc = 0;\n\t\t\trevs.pending.objects = NULL;\n\n\t\t\tstored->bitmap = bitmap_to_ewah(base);\n\t\t\tneed_reset = 0;\n\t\t} else\n\t\t\tneed_reset = 1;\n\n\t\tif (i >= reuse_after)\n\t\t\tstored->flags |= BITMAP_FLAG_REUSE;\n\n\t\thash_pos = kh_put_sha1(writer.bitmaps, object->oid.hash, &hash_ret);\n\t\tif (hash_ret == 0)\n\t\t\tdie(\"Duplicate entry when writing index: %s\",\n\t\t\t    oid_to_hex(&object->oid));\n\n\t\tkh_value(writer.bitmaps, hash_pos) = stored;\n\t\tdisplay_progress(writer.progress, writer.selected_nr - i);\n\t}\n\n\tbitmap_free(base);\n\tstop_progress(&writer.progress);\n\n\tcompute_xor_offsets();\n}\n", "target": 0, "idx": 54900}
{"func": "RenderFrameImpl* RenderFrameImpl::Create(\n    RenderViewImpl* render_view,\n    int32_t routing_id,\n    service_manager::mojom::InterfaceProviderPtr interface_provider,\n    const base::UnguessableToken& devtools_frame_token) {\n  DCHECK(routing_id != MSG_ROUTING_NONE);\n  CreateParams params(render_view, routing_id, std::move(interface_provider),\n                      devtools_frame_token);\n\n  if (g_create_render_frame_impl)\n    return g_create_render_frame_impl(std::move(params));\n  else\n    return new RenderFrameImpl(std::move(params));\n}\n", "target": 0, "idx": 160555}
{"func": "DEFINE_TRACE(ResourceFetcher) {\n  visitor->Trace(context_);\n  visitor->Trace(archive_);\n  visitor->Trace(loaders_);\n  visitor->Trace(non_blocking_loaders_);\n  visitor->Trace(document_resources_);\n  visitor->Trace(preloads_);\n  visitor->Trace(resource_timing_info_map_);\n}\n", "target": 0, "idx": 139717}
{"func": " static int em_ret_far(struct x86_emulate_ctxt *ctxt)\n {\n \tint rc;\n\tunsigned long cs;\n \tint cpl = ctxt->ops->cpl(ctxt);\n \n\trc = emulate_pop(ctxt, &ctxt->_eip, ctxt->op_bytes);\n \tif (rc != X86EMUL_CONTINUE)\n \t\treturn rc;\n\tif (ctxt->op_bytes == 4)\n\t\tctxt->_eip = (u32)ctxt->_eip;\n \trc = emulate_pop(ctxt, &cs, ctxt->op_bytes);\n \tif (rc != X86EMUL_CONTINUE)\n \t\treturn rc;\n \t/* Outer-privilege level return is not implemented */\n \tif (ctxt->mode >= X86EMUL_MODE_PROT16 && (cs & 3) > cpl)\n \t\treturn X86EMUL_UNHANDLEABLE;\n\trc = load_segment_descriptor(ctxt, (u16)cs, VCPU_SREG_CS);\n \treturn rc;\n }\n", "target": 1, "idx": 179512}
{"func": " WebstoreBindings::WebstoreBindings(ScriptContext* context)\n     : ObjectBackedNativeHandler(context) {\n  RouteFunction(\"Install\",\n                 base::Bind(&WebstoreBindings::Install, base::Unretained(this)));\n }\n", "target": 1, "idx": 186213}
{"func": "void BlockedPlugin::LoadPlugin() {\n  CHECK(plugin_);\n  if (hidden_)\n    return;\n  WebPluginContainer* container = plugin_->container();\n   WebPlugin* new_plugin =\n       render_view()->CreatePluginNoCheck(frame_, plugin_params_);\n   if (new_plugin && new_plugin->initialize(container)) {\n     container->setPlugin(new_plugin);\n     container->invalidate();\n     container->reportGeometry();\n    plugin_->ReplayReceivedData(new_plugin);\n    plugin_->destroy();\n  }\n}\n", "target": 1, "idx": 184184}
{"func": "int do_remount_sb(struct super_block *sb, int flags, void *data, int force)\n{\n\tint retval;\n\tint remount_ro;\n\n\tif (sb->s_writers.frozen != SB_UNFROZEN)\n\t\treturn -EBUSY;\n\n#ifdef CONFIG_BLOCK\n\tif (!(flags & MS_RDONLY) && bdev_read_only(sb->s_bdev))\n\t\treturn -EACCES;\n#endif\n\n\tif (flags & MS_RDONLY)\n\t\tacct_auto_close(sb);\n\tshrink_dcache_sb(sb);\n\tsync_filesystem(sb);\n\n\tremount_ro = (flags & MS_RDONLY) && !(sb->s_flags & MS_RDONLY);\n\n\t/* If we are remounting RDONLY and current sb is read/write,\n \t   make sure there are no rw files opened */\n \tif (remount_ro) {\n \t\tif (force) {\n\t\t\tmark_files_ro(sb);\n \t\t} else {\n \t\t\tretval = sb_prepare_remount_readonly(sb);\n \t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t}\n\t}\n\n\tif (sb->s_op->remount_fs) {\n\t\tretval = sb->s_op->remount_fs(sb, &flags, data);\n\t\tif (retval) {\n\t\t\tif (!force)\n\t\t\t\tgoto cancel_readonly;\n\t\t\t/* If forced remount, go ahead despite any errors */\n\t\t\tWARN(1, \"forced remount of a %s fs returned %i\\n\",\n\t\t\t     sb->s_type->name, retval);\n\t\t}\n\t}\n\tsb->s_flags = (sb->s_flags & ~MS_RMT_MASK) | (flags & MS_RMT_MASK);\n\t/* Needs to be ordered wrt mnt_is_readonly() */\n\tsmp_wmb();\n\tsb->s_readonly_remount = 0;\n\n\t/*\n\t * Some filesystems modify their metadata via some other path than the\n\t * bdev buffer cache (eg. use a private mapping, or directories in\n\t * pagecache, etc). Also file data modifications go via their own\n\t * mappings. So If we try to mount readonly then copy the filesystem\n\t * from bdev, we could get stale data, so invalidate it to give a best\n\t * effort at coherency.\n\t */\n\tif (remount_ro && sb->s_bdev)\n\t\tinvalidate_bdev(sb->s_bdev);\n\treturn 0;\n\ncancel_readonly:\n\tsb->s_readonly_remount = 0;\n\treturn retval;\n}\n", "target": 1, "idx": 179980}
{"func": " static v8::Handle<v8::Value> getNamedProperty(HTMLDocument* htmlDocument, const AtomicString& key, v8::Handle<v8::Object> creationContext, v8::Isolate* isolate)\n {\n    if (!htmlDocument->hasNamedItem(key.impl()) && !htmlDocument->hasExtraNamedItem(key.impl()))\n         return v8Undefined();\n \n     RefPtr<HTMLCollection> items = htmlDocument->documentNamedItems(key);\n    if (items->isEmpty())\n        return v8Undefined();\n\n    if (items->hasExactlyOneItem()) {\n        Node* node = items->item(0);\n        Frame* frame = 0;\n        if (node->hasTagName(HTMLNames::iframeTag) && (frame = toHTMLIFrameElement(node)->contentFrame()))\n            return toV8(frame->domWindow(), creationContext, isolate);\n        return toV8(node, creationContext, isolate);\n    }\n    return toV8(items.release(), creationContext, isolate);\n}\n", "target": 1, "idx": 184845}
{"func": "NOINLINE void TargetThread::SignalAndWaitUntilSignaled(\n     WaitableEvent* thread_started_event,\n     WaitableEvent* finish_event) {\n  thread_started_event->Signal();\n  volatile int x = 1;\n  finish_event->Wait();\n  x = 0;  // Prevent tail call to WaitableEvent::Wait().\n  ALLOW_UNUSED_LOCAL(x);\n }\n", "target": 1, "idx": 185404}
{"func": "UnacceleratedStaticBitmapImage::UnacceleratedStaticBitmapImage(\n     sk_sp<SkImage> image) {\n   CHECK(image);\n   DCHECK(!image->isLazyGenerated());\n   paint_image_ =\n       CreatePaintImageBuilder()\n           .set_image(std::move(image), cc::PaintImage::GetNextContentId())\n          .TakePaintImage();\n}\n", "target": 1, "idx": 186578}
{"func": "void TabStrip::StartResizeLayoutAnimation() {\n  PrepareForAnimation();\n  GenerateIdealBounds();\n  AnimateToIdealBounds();\n}\n", "target": 0, "idx": 134438}
{"func": "void RunSynchronousClosure(const base::Closure& closure,\n                           const char* trace_event_name,\n                           base::WaitableEvent* event) {\n  {\n    TRACE_EVENT0(\"webrtc\", trace_event_name);\n    closure.Run();\n  }\n  event->Signal();\n}\n", "target": 0, "idx": 166030}
{"func": "static int setpatternspace(i_ctx_t * i_ctx_p, ref *r, int *stage, int *cont, int CIESubst)\n{\n    gs_color_space *pcs;\n    gs_color_space *pcs_base;\n    uint edepth = ref_stack_count(&e_stack);\n    int code = 0;\n\n    if (i_ctx_p->language_level < 2)\n        return_error(gs_error_undefined);\n\n    *cont = 0;\n    pcs_base = NULL;\n    if (r_is_array(r)) {\n        check_read(*r);\n\n        switch (r_size(r)) {\n            case 1:\t\t/* no base space */\n                pcs_base = NULL;\n                break;\n            default:\n                return_error(gs_error_rangecheck);\n            case 2:\n                pcs_base = gs_currentcolorspace(igs);\n                if (cs_num_components(pcs_base) < 0)       /* i.e., Pattern space */\n                    return_error(gs_error_rangecheck);\n        }\n    }\n    pcs = gs_cspace_alloc(imemory, &gs_color_space_type_Pattern);\n    pcs->base_space = pcs_base;\n    pcs->params.pattern.has_base_space = (pcs_base != NULL);\n    rc_increment_cs(pcs_base);\n    code = gs_setcolorspace(igs, pcs);\n    /* release reference from construction */\n    rc_decrement_only_cs(pcs, \"zsetpatternspace\");\n    if (code < 0) {\n        ref_stack_pop_to(&e_stack, edepth);\n        return code;\n    }\n    make_null(&istate->pattern[0]); /* PLRM: initial color value is a null object */\n    *stage = 0;\n    return (ref_stack_count(&e_stack) == edepth ? 0 : o_push_estack);\t/* installation will load the caches */\n}\n", "target": 0, "idx": 3150}
{"func": "void RenderView::OnDragSourceEndedOrMoved(const gfx::Point& client_point,\n                                          const gfx::Point& screen_point,\n                                          bool ended,\n                                          WebDragOperation op) {\n  if (ended) {\n    webview()->dragSourceEndedAt(client_point, screen_point, op);\n  } else {\n    webview()->dragSourceMovedTo(client_point, screen_point, op);\n  }\n}\n", "target": 0, "idx": 97942}
{"func": "int ff_h264_decode_extradata(H264Context *h, const uint8_t *buf, int size)\n{\n    AVCodecContext *avctx = h->avctx;\n    int ret;\n\n    if (!buf || size <= 0)\n        return -1;\n\n    if (buf[0] == 1) {\n        int i, cnt, nalsize;\n        const unsigned char *p = buf;\n\n        h->is_avc = 1;\n\n        if (size < 7) {\n            av_log(avctx, AV_LOG_ERROR,\n                   \"avcC %d too short\\n\", size);\n            return AVERROR_INVALIDDATA;\n        }\n        /* sps and pps in the avcC always have length coded with 2 bytes,\n         * so put a fake nal_length_size = 2 while parsing them */\n        h->nal_length_size = 2;\n        cnt = *(p + 5) & 0x1f; // Number of sps\n        p  += 6;\n        for (i = 0; i < cnt; i++) {\n            nalsize = AV_RB16(p) + 2;\n            if(nalsize > size - (p-buf))\n                return AVERROR_INVALIDDATA;\n            ret = decode_nal_units(h, p, nalsize, 1);\n            if (ret < 0) {\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Decoding sps %d from avcC failed\\n\", i);\n                return ret;\n            }\n            p += nalsize;\n        }\n        cnt = *(p++); // Number of pps\n        for (i = 0; i < cnt; i++) {\n            nalsize = AV_RB16(p) + 2;\n            if(nalsize > size - (p-buf))\n                return AVERROR_INVALIDDATA;\n            ret = decode_nal_units(h, p, nalsize, 1);\n            if (ret < 0) {\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Decoding pps %d from avcC failed\\n\", i);\n                return ret;\n            }\n            p += nalsize;\n        }\n        h->nal_length_size = (buf[4] & 0x03) + 1;\n    } else {\n        h->is_avc = 0;\n        ret = decode_nal_units(h, buf, size, 1);\n        if (ret < 0)\n            return ret;\n    }\n    return size;\n}\n", "target": 0, "idx": 43409}
{"func": "PassRefPtr<TreeWalker> Document::createTreeWalker(Node* root, ExceptionState& es)\n{\n    if (!root) {\n        es.throwUninformativeAndGenericDOMException(NotSupportedError);\n        return 0;\n    }\n    return TreeWalker::create(root, NodeFilter::SHOW_ALL, PassRefPtr<NodeFilter>());\n}\n", "target": 0, "idx": 109622}
{"func": "static inline int sd_local_flags(int level)\n{\n\tif (sched_domains_numa_distance[level] > RECLAIM_DISTANCE)\n\t\treturn 0;\n\n\treturn SD_BALANCE_EXEC | SD_BALANCE_FORK | SD_WAKE_AFFINE;\n}\n", "target": 0, "idx": 58221}
{"func": "void Document::SetBaseURLOverride(const KURL& url) {\n  base_url_override_ = url;\n  UpdateBaseURL();\n}\n", "target": 0, "idx": 141218}
{"func": "void JSArray::put(ExecState* exec, const Identifier& propertyName, JSValue value, PutPropertySlot& slot)\n{\n    bool isArrayIndex;\n    unsigned i = propertyName.toArrayIndex(isArrayIndex);\n    if (isArrayIndex) {\n        put(exec, i, value);\n        return;\n    }\n\n    if (propertyName == exec->propertyNames().length) {\n        unsigned newLength = value.toUInt32(exec);\n        if (value.toNumber(exec) != static_cast<double>(newLength)) {\n            throwError(exec, createRangeError(exec, \"Invalid array length\"));\n            return;\n        }\n        setLength(newLength);\n        return;\n    }\n\n    JSObject::put(exec, propertyName, value, slot);\n}\n", "target": 0, "idx": 107440}
{"func": "LayoutUnit NGColumnLayoutAlgorithm::StretchColumnBlockSize(\n    LayoutUnit minimal_space_shortage,\n    LayoutUnit current_column_size,\n    LayoutUnit container_content_box_block_size) const {\n  if (!NeedsColumnBalancing(container_content_box_block_size, Style()))\n    return current_column_size;\n  LayoutUnit length = current_column_size + minimal_space_shortage;\n  return ConstrainColumnBlockSize(length);\n}\n", "target": 0, "idx": 152795}
{"func": "isoclns_print(netdissect_options *ndo,\n              const uint8_t *p, u_int length, u_int caplen)\n {\n\tif (caplen <= 1) { /* enough bytes on the wire ? */\n \t\tND_PRINT((ndo, \"|OSI\"));\n \t\treturn;\n \t}\n\n\tif (ndo->ndo_eflag)\n\t\tND_PRINT((ndo, \"OSI NLPID %s (0x%02x): \", tok2str(nlpid_values, \"Unknown\", *p), *p));\n\n\tswitch (*p) {\n \n \tcase NLPID_CLNP:\n \t\tif (!clnp_print(ndo, p, length))\n\t\t\tprint_unknown_data(ndo, p, \"\\n\\t\", caplen);\n \t\tbreak;\n \n \tcase NLPID_ESIS:\n\t\tesis_print(ndo, p, length);\n\t\treturn;\n \n \tcase NLPID_ISIS:\n \t\tif (!isis_print(ndo, p, length))\n\t\t\tprint_unknown_data(ndo, p, \"\\n\\t\", caplen);\n \t\tbreak;\n \n \tcase NLPID_NULLNS:\n\t\tND_PRINT((ndo, \"%slength: %u\", ndo->ndo_eflag ? \"\" : \", \", length));\n\t\tbreak;\n\n\tcase NLPID_Q933:\n\t\tq933_print(ndo, p + 1, length - 1);\n\t\tbreak;\n\n\tcase NLPID_IP:\n\t\tip_print(ndo, p + 1, length - 1);\n\t\tbreak;\n\n\tcase NLPID_IP6:\n\t\tip6_print(ndo, p + 1, length - 1);\n\t\tbreak;\n\n\tcase NLPID_PPP:\n\t\tppp_print(ndo, p + 1, length - 1);\n\t\tbreak;\n\n\tdefault:\n \t\tif (!ndo->ndo_eflag)\n \t\t\tND_PRINT((ndo, \"OSI NLPID 0x%02x unknown\", *p));\n \t\tND_PRINT((ndo, \"%slength: %u\", ndo->ndo_eflag ? \"\" : \", \", length));\n\t\tif (caplen > 1)\n\t\t\tprint_unknown_data(ndo, p, \"\\n\\t\", caplen);\n \t\tbreak;\n \t}\n }\n", "target": 1, "idx": 181119}
{"func": "bgp_attr_print(netdissect_options *ndo,\n               u_int atype, const u_char *pptr, u_int len)\n{\n\tint i;\n\tuint16_t af;\n\tuint8_t safi, snpa, nhlen;\n        union { /* copy buffer for bandwidth values */\n            float f;\n            uint32_t i;\n        } bw;\n\tint advance;\n\tu_int tlen;\n\tconst u_char *tptr;\n\tchar buf[MAXHOSTNAMELEN + 100];\n        int  as_size;\n\n        tptr = pptr;\n        tlen=len;\n\n\tswitch (atype) {\n\tcase BGPTYPE_ORIGIN:\n\t\tif (len != 1)\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\telse {\n\t\t\tND_TCHECK(*tptr);\n\t\t\tND_PRINT((ndo, \"%s\", tok2str(bgp_origin_values,\n\t\t\t\t\t\t\"Unknown Origin Typecode\",\n\t\t\t\t\t\ttptr[0])));\n\t\t}\n\t\tbreak;\n\n        /*\n         * Process AS4 byte path and AS2 byte path attributes here.\n         */\n\tcase BGPTYPE_AS4_PATH:\n\tcase BGPTYPE_AS_PATH:\n\t\tif (len % 2) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n                if (!len) {\n\t\t\tND_PRINT((ndo, \"empty\"));\n\t\t\tbreak;\n                }\n\n                /*\n                 * BGP updates exchanged between New speakers that support 4\n                 * byte AS, ASs are always encoded in 4 bytes. There is no\n                 * definitive way to find this, just by the packet's\n                 * contents. So, check for packet's TLV's sanity assuming\n                 * 2 bytes first, and it does not pass, assume that ASs are\n                 * encoded in 4 bytes format and move on.\n                 */\n                as_size = bgp_attr_get_as_size(ndo, atype, pptr, len);\n\n\t\twhile (tptr < pptr + len) {\n\t\t\tND_TCHECK(tptr[0]);\n                        ND_PRINT((ndo, \"%s\", tok2str(bgp_as_path_segment_open_values,\n\t\t\t\t\t\t\"?\", tptr[0])));\n\t\t\tND_TCHECK(tptr[1]);\n                        for (i = 0; i < tptr[1] * as_size; i += as_size) {\n                            ND_TCHECK2(tptr[2 + i], as_size);\n\t\t\t    ND_PRINT((ndo, \"%s \",\n\t\t\t\tas_printf(ndo, astostr, sizeof(astostr),\n\t\t\t\tas_size == 2 ?\n\t\t\t\tEXTRACT_16BITS(&tptr[2 + i]) :\n\t\t\t\tEXTRACT_32BITS(&tptr[2 + i]))));\n                        }\n\t\t\tND_TCHECK(tptr[0]);\n                        ND_PRINT((ndo, \"%s\", tok2str(bgp_as_path_segment_close_values,\n\t\t\t\t\t\t\"?\", tptr[0])));\n                        ND_TCHECK(tptr[1]);\n                        tptr += 2 + tptr[1] * as_size;\n\t\t}\n\t\tbreak;\n\tcase BGPTYPE_NEXT_HOP:\n\t\tif (len != 4)\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\telse {\n\t\t\tND_TCHECK2(tptr[0], 4);\n\t\t\tND_PRINT((ndo, \"%s\", ipaddr_string(ndo, tptr)));\n\t\t}\n\t\tbreak;\n\tcase BGPTYPE_MULTI_EXIT_DISC:\n\tcase BGPTYPE_LOCAL_PREF:\n\t\tif (len != 4)\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\telse {\n\t\t\tND_TCHECK2(tptr[0], 4);\n\t\t\tND_PRINT((ndo, \"%u\", EXTRACT_32BITS(tptr)));\n\t\t}\n\t\tbreak;\n\tcase BGPTYPE_ATOMIC_AGGREGATE:\n\t\tif (len != 0)\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\tbreak;\n        case BGPTYPE_AGGREGATOR:\n\n                /*\n                 * Depending on the AS encoded is of 2 bytes or of 4 bytes,\n                 * the length of this PA can be either 6 bytes or 8 bytes.\n                 */\n                if (len != 6 && len != 8) {\n                    ND_PRINT((ndo, \"invalid len\"));\n                    break;\n                }\n                ND_TCHECK2(tptr[0], len);\n                if (len == 6) {\n\t\t    ND_PRINT((ndo, \" AS #%s, origin %s\",\n\t\t\tas_printf(ndo, astostr, sizeof(astostr), EXTRACT_16BITS(tptr)),\n\t\t\tipaddr_string(ndo, tptr + 2)));\n                } else {\n\t\t    ND_PRINT((ndo, \" AS #%s, origin %s\",\n\t\t\tas_printf(ndo, astostr, sizeof(astostr),\n\t\t\tEXTRACT_32BITS(tptr)), ipaddr_string(ndo, tptr + 4)));\n                }\n                break;\n\tcase BGPTYPE_AGGREGATOR4:\n\t\tif (len != 8) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n\t\tND_TCHECK2(tptr[0], 8);\n\t\tND_PRINT((ndo, \" AS #%s, origin %s\",\n\t   \t    as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(tptr)),\n\t\t    ipaddr_string(ndo, tptr + 4)));\n\t\tbreak;\n\tcase BGPTYPE_COMMUNITIES:\n\t\tif (len % 4) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n\t\twhile (tlen>0) {\n\t\t\tuint32_t comm;\n\t\t\tND_TCHECK2(tptr[0], 4);\n\t\t\tcomm = EXTRACT_32BITS(tptr);\n\t\t\tswitch (comm) {\n\t\t\tcase BGP_COMMUNITY_NO_EXPORT:\n\t\t\t\tND_PRINT((ndo, \" NO_EXPORT\"));\n\t\t\t\tbreak;\n\t\t\tcase BGP_COMMUNITY_NO_ADVERT:\n\t\t\t\tND_PRINT((ndo, \" NO_ADVERTISE\"));\n\t\t\t\tbreak;\n\t\t\tcase BGP_COMMUNITY_NO_EXPORT_SUBCONFED:\n\t\t\t\tND_PRINT((ndo, \" NO_EXPORT_SUBCONFED\"));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tND_PRINT((ndo, \"%u:%u%s\",\n                                       (comm >> 16) & 0xffff,\n                                       comm & 0xffff,\n                                       (tlen>4) ? \", \" : \"\"));\n\t\t\t\tbreak;\n\t\t\t}\n                        tlen -=4;\n                        tptr +=4;\n\t\t}\n\t\tbreak;\n        case BGPTYPE_ORIGINATOR_ID:\n\t\tif (len != 4) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n\t\tND_TCHECK2(tptr[0], 4);\n                ND_PRINT((ndo, \"%s\",ipaddr_string(ndo, tptr)));\n                break;\n        case BGPTYPE_CLUSTER_LIST:\n\t\tif (len % 4) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n                while (tlen>0) {\n\t\t\tND_TCHECK2(tptr[0], 4);\n                        ND_PRINT((ndo, \"%s%s\",\n                               ipaddr_string(ndo, tptr),\n                                (tlen>4) ? \", \" : \"\"));\n                        tlen -=4;\n                        tptr +=4;\n                }\n                break;\n\tcase BGPTYPE_MP_REACH_NLRI:\n\t\tND_TCHECK2(tptr[0], 3);\n\t\taf = EXTRACT_16BITS(tptr);\n\t\tsafi = tptr[2];\n\n                ND_PRINT((ndo, \"\\n\\t    AFI: %s (%u), %sSAFI: %s (%u)\",\n                       tok2str(af_values, \"Unknown AFI\", af),\n                       af,\n                       (safi>128) ? \"vendor specific \" : \"\", /* 128 is meanwhile wellknown */\n                       tok2str(bgp_safi_values, \"Unknown SAFI\", safi),\n                       safi));\n\n                switch(af<<8 | safi) {\n                case (AFNUM_INET<<8 | SAFNUM_UNICAST):\n                case (AFNUM_INET<<8 | SAFNUM_MULTICAST):\n                case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):\n                case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):\n                case (AFNUM_INET<<8 | SAFNUM_RT_ROUTING_INFO):\n                case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):\n                case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):\n                case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):\n                case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN):\n\t\tcase (AFNUM_INET<<8 | SAFNUM_MDT):\n                case (AFNUM_INET6<<8 | SAFNUM_UNICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):\n                case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):\n                case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):\n                case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):\n                case (AFNUM_VPLS<<8 | SAFNUM_VPLS):\n                    break;\n                default:\n                    ND_TCHECK2(tptr[0], tlen);\n                    ND_PRINT((ndo, \"\\n\\t    no AFI %u / SAFI %u decoder\", af, safi));\n                    if (ndo->ndo_vflag <= 1)\n                        print_unknown_data(ndo, tptr, \"\\n\\t    \", tlen);\n                    goto done;\n                    break;\n                }\n\n                tptr +=3;\n\n\t\tND_TCHECK(tptr[0]);\n\t\tnhlen = tptr[0];\n                tlen = nhlen;\n                tptr++;\n\n\t\tif (tlen) {\n                    int nnh = 0;\n                    ND_PRINT((ndo, \"\\n\\t    nexthop: \"));\n                    while (tlen > 0) {\n                        if ( nnh++ > 0 ) {\n                            ND_PRINT((ndo,  \", \" ));\n                        }\n                        switch(af<<8 | safi) {\n                        case (AFNUM_INET<<8 | SAFNUM_UNICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_MULTICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_RT_ROUTING_INFO):\n                        case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN):\n                        case (AFNUM_INET<<8 | SAFNUM_MDT):\n\t\t\t    if (tlen < (int)sizeof(struct in_addr)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in_addr));\n                                ND_PRINT((ndo, \"%s\",ipaddr_string(ndo, tptr)));\n                                tlen -= sizeof(struct in_addr);\n                                tptr += sizeof(struct in_addr);\n                            }\n                            break;\n                        case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):\n                            if (tlen < (int)(sizeof(struct in_addr)+BGP_VPN_RD_LEN)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in_addr)+BGP_VPN_RD_LEN);\n                                ND_PRINT((ndo, \"RD: %s, %s\",\n                                       bgp_vpn_rd_print(ndo, tptr),\n                                       ipaddr_string(ndo, tptr+BGP_VPN_RD_LEN)));\n                                tlen -= (sizeof(struct in_addr)+BGP_VPN_RD_LEN);\n                                tptr += (sizeof(struct in_addr)+BGP_VPN_RD_LEN);\n                            }\n                            break;\n                        case (AFNUM_INET6<<8 | SAFNUM_UNICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):\n                            if (tlen < (int)sizeof(struct in6_addr)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in6_addr));\n                                ND_PRINT((ndo, \"%s\", ip6addr_string(ndo, tptr)));\n                                tlen -= sizeof(struct in6_addr);\n                                tptr += sizeof(struct in6_addr);\n                            }\n                            break;\n                        case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):\n                            if (tlen < (int)(sizeof(struct in6_addr)+BGP_VPN_RD_LEN)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in6_addr)+BGP_VPN_RD_LEN);\n                                ND_PRINT((ndo, \"RD: %s, %s\",\n                                       bgp_vpn_rd_print(ndo, tptr),\n                                       ip6addr_string(ndo, tptr+BGP_VPN_RD_LEN)));\n                                tlen -= (sizeof(struct in6_addr)+BGP_VPN_RD_LEN);\n                                tptr += (sizeof(struct in6_addr)+BGP_VPN_RD_LEN);\n                            }\n                            break;\n                        case (AFNUM_VPLS<<8 | SAFNUM_VPLS):\n                        case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):\n                        case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):\n                        case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):\n                            if (tlen < (int)sizeof(struct in_addr)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in_addr));\n                                ND_PRINT((ndo, \"%s\", ipaddr_string(ndo, tptr)));\n                                tlen -= (sizeof(struct in_addr));\n                                tptr += (sizeof(struct in_addr));\n                            }\n                            break;\n                        case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):\n                        case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):\n                        case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):\n                            ND_TCHECK2(tptr[0], tlen);\n                            ND_PRINT((ndo, \"%s\", isonsap_string(ndo, tptr, tlen)));\n                            tptr += tlen;\n                            tlen = 0;\n                            break;\n\n                        case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):\n                        case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):\n                        case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):\n                            if (tlen < BGP_VPN_RD_LEN+1) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], tlen);\n                                ND_PRINT((ndo, \"RD: %s, %s\",\n                                       bgp_vpn_rd_print(ndo, tptr),\n                                       isonsap_string(ndo, tptr+BGP_VPN_RD_LEN,tlen-BGP_VPN_RD_LEN)));\n                                /* rfc986 mapped IPv4 address ? */\n                                if (EXTRACT_32BITS(tptr+BGP_VPN_RD_LEN) ==  0x47000601)\n                                    ND_PRINT((ndo, \" = %s\", ipaddr_string(ndo, tptr+BGP_VPN_RD_LEN+4)));\n                                /* rfc1888 mapped IPv6 address ? */\n                                else if (EXTRACT_24BITS(tptr+BGP_VPN_RD_LEN) ==  0x350000)\n                                    ND_PRINT((ndo, \" = %s\", ip6addr_string(ndo, tptr+BGP_VPN_RD_LEN+3)));\n                                tptr += tlen;\n                                tlen = 0;\n                            }\n                            break;\n                        default:\n                            ND_TCHECK2(tptr[0], tlen);\n                            ND_PRINT((ndo, \"no AFI %u/SAFI %u decoder\", af, safi));\n                            if (ndo->ndo_vflag <= 1)\n                                print_unknown_data(ndo, tptr, \"\\n\\t    \", tlen);\n                            tptr += tlen;\n                            tlen = 0;\n                            goto done;\n                            break;\n                        }\n                    }\n\t\t}\n\t\tND_PRINT((ndo, \", nh-length: %u\", nhlen));\n\t\ttptr += tlen;\n\n\t\tND_TCHECK(tptr[0]);\n\t\tsnpa = tptr[0];\n\t\ttptr++;\n\n\t\tif (snpa) {\n\t\t\tND_PRINT((ndo, \"\\n\\t    %u SNPA\", snpa));\n\t\t\tfor (/*nothing*/; snpa > 0; snpa--) {\n\t\t\t\tND_TCHECK(tptr[0]);\n\t\t\t\tND_PRINT((ndo, \"\\n\\t      %d bytes\", tptr[0]));\n\t\t\t\ttptr += tptr[0] + 1;\n\t\t\t}\n\t\t} else {\n\t\t\tND_PRINT((ndo, \", no SNPA\"));\n                }\n\n\t\twhile (len - (tptr - pptr) > 0) {\n                    switch (af<<8 | safi) {\n                    case (AFNUM_INET<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_prefix4(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):\n                        advance = decode_labeled_prefix4(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_prefix4(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_RT_ROUTING_INFO):\n                        advance = decode_rt_routing_info(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN): /* fall through */\n                    case (AFNUM_INET6<<8 | SAFNUM_MULTICAST_VPN):\n                        advance = decode_multicast_vpn(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n\n\t\t    case (AFNUM_INET<<8 | SAFNUM_MDT):\n\t\t      advance = decode_mdt_vpn_nlri(ndo, tptr, buf, sizeof(buf));\n\t\t      if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n\t\t       break;\n                    case (AFNUM_INET6<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_prefix6(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):\n                        advance = decode_labeled_prefix6(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_prefix6(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_VPLS<<8 | SAFNUM_VPLS):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_l2(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_clnp_prefix(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_clnp_prefix(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    default:\n                        ND_TCHECK2(*tptr,tlen);\n                        ND_PRINT((ndo, \"\\n\\t    no AFI %u / SAFI %u decoder\", af, safi));\n                        if (ndo->ndo_vflag <= 1)\n                            print_unknown_data(ndo, tptr, \"\\n\\t    \", tlen);\n                        advance = 0;\n                        tptr = pptr + len;\n                        break;\n                    }\n                    if (advance < 0)\n                        break;\n                    tptr += advance;\n\t\t}\n        done:\n\t\tbreak;\n\n\tcase BGPTYPE_MP_UNREACH_NLRI:\n\t\tND_TCHECK2(tptr[0], BGP_MP_NLRI_MINSIZE);\n\t\taf = EXTRACT_16BITS(tptr);\n\t\tsafi = tptr[2];\n\n                ND_PRINT((ndo, \"\\n\\t    AFI: %s (%u), %sSAFI: %s (%u)\",\n                       tok2str(af_values, \"Unknown AFI\", af),\n                       af,\n                       (safi>128) ? \"vendor specific \" : \"\", /* 128 is meanwhile wellknown */\n                       tok2str(bgp_safi_values, \"Unknown SAFI\", safi),\n                       safi));\n\n                if (len == BGP_MP_NLRI_MINSIZE)\n                    ND_PRINT((ndo, \"\\n\\t      End-of-Rib Marker (empty NLRI)\"));\n\n\t\ttptr += 3;\n\n\t\twhile (len - (tptr - pptr) > 0) {\n                    switch (af<<8 | safi) {\n                    case (AFNUM_INET<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_prefix4(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):\n                        advance = decode_labeled_prefix4(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_prefix4(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_prefix6(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):\n                        advance = decode_labeled_prefix6(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_prefix6(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_VPLS<<8 | SAFNUM_VPLS):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_l2(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_clnp_prefix(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_clnp_prefix(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n\t\t    case (AFNUM_INET<<8 | SAFNUM_MDT):\n\t\t      advance = decode_mdt_vpn_nlri(ndo, tptr, buf, sizeof(buf));\n\t\t      if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n\t\t       break;\n                    case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN): /* fall through */\n                    case (AFNUM_INET6<<8 | SAFNUM_MULTICAST_VPN):\n                        advance = decode_multicast_vpn(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    default:\n                        ND_TCHECK2(*(tptr-3),tlen);\n                        ND_PRINT((ndo, \"no AFI %u / SAFI %u decoder\", af, safi));\n                        if (ndo->ndo_vflag <= 1)\n                            print_unknown_data(ndo, tptr-3, \"\\n\\t    \", tlen);\n                        advance = 0;\n                        tptr = pptr + len;\n                        break;\n                    }\n                    if (advance < 0)\n                        break;\n                    tptr += advance;\n\t\t}\n\t\tbreak;\n        case BGPTYPE_EXTD_COMMUNITIES:\n\t\tif (len % 8) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n                while (tlen>0) {\n                    uint16_t extd_comm;\n\n                    ND_TCHECK2(tptr[0], 2);\n                    extd_comm=EXTRACT_16BITS(tptr);\n\n\t\t    ND_PRINT((ndo, \"\\n\\t    %s (0x%04x), Flags [%s]\",\n\t\t\t   tok2str(bgp_extd_comm_subtype_values,\n\t\t\t\t      \"unknown extd community typecode\",\n\t\t\t\t      extd_comm),\n\t\t\t   extd_comm,\n\t\t\t   bittok2str(bgp_extd_comm_flag_values, \"none\", extd_comm)));\n\n                    ND_TCHECK2(*(tptr+2), 6);\n                    switch(extd_comm) {\n                    case BGP_EXT_COM_RT_0:\n                    case BGP_EXT_COM_RO_0:\n                    case BGP_EXT_COM_L2VPN_RT_0:\n                        ND_PRINT((ndo, \": %u:%u (= %s)\",\n                               EXTRACT_16BITS(tptr+2),\n                               EXTRACT_32BITS(tptr+4),\n                               ipaddr_string(ndo, tptr+4)));\n                        break;\n                    case BGP_EXT_COM_RT_1:\n                    case BGP_EXT_COM_RO_1:\n                    case BGP_EXT_COM_L2VPN_RT_1:\n                    case BGP_EXT_COM_VRF_RT_IMP:\n                        ND_PRINT((ndo, \": %s:%u\",\n                               ipaddr_string(ndo, tptr+2),\n                               EXTRACT_16BITS(tptr+6)));\n                        break;\n                    case BGP_EXT_COM_RT_2:\n                    case BGP_EXT_COM_RO_2:\n\t\t\tND_PRINT((ndo, \": %s:%u\",\n\t\t\t    as_printf(ndo, astostr, sizeof(astostr),\n\t\t\t    EXTRACT_32BITS(tptr+2)), EXTRACT_16BITS(tptr+6)));\n\t\t\tbreak;\n                    case BGP_EXT_COM_LINKBAND:\n\t\t        bw.i = EXTRACT_32BITS(tptr+2);\n                        ND_PRINT((ndo, \": bandwidth: %.3f Mbps\",\n                               bw.f*8/1000000));\n                        break;\n                    case BGP_EXT_COM_VPN_ORIGIN:\n                    case BGP_EXT_COM_VPN_ORIGIN2:\n                    case BGP_EXT_COM_VPN_ORIGIN3:\n                    case BGP_EXT_COM_VPN_ORIGIN4:\n                    case BGP_EXT_COM_OSPF_RID:\n                    case BGP_EXT_COM_OSPF_RID2:\n                        ND_PRINT((ndo, \"%s\", ipaddr_string(ndo, tptr+2)));\n                        break;\n                    case BGP_EXT_COM_OSPF_RTYPE:\n                    case BGP_EXT_COM_OSPF_RTYPE2:\n                        ND_PRINT((ndo, \": area:%s, router-type:%s, metric-type:%s%s\",\n                               ipaddr_string(ndo, tptr+2),\n                               tok2str(bgp_extd_comm_ospf_rtype_values,\n\t\t\t\t\t  \"unknown (0x%02x)\",\n\t\t\t\t\t  *(tptr+6)),\n                               (*(tptr+7) &  BGP_OSPF_RTYPE_METRIC_TYPE) ? \"E2\" : \"\",\n                               ((*(tptr+6) == BGP_OSPF_RTYPE_EXT) || (*(tptr+6) == BGP_OSPF_RTYPE_NSSA)) ? \"E1\" : \"\"));\n                        break;\n                    case BGP_EXT_COM_L2INFO:\n                        ND_PRINT((ndo, \": %s Control Flags [0x%02x]:MTU %u\",\n                               tok2str(l2vpn_encaps_values,\n\t\t\t\t\t  \"unknown encaps\",\n\t\t\t\t\t  *(tptr+2)),\n                                       *(tptr+3),\n                               EXTRACT_16BITS(tptr+4)));\n                        break;\n                    case BGP_EXT_COM_SOURCE_AS:\n                        ND_PRINT((ndo, \": AS %u\", EXTRACT_16BITS(tptr+2)));\n                        break;\n                    default:\n                        ND_TCHECK2(*tptr,8);\n                        print_unknown_data(ndo, tptr, \"\\n\\t      \", 8);\n                        break;\n                    }\n                    tlen -=8;\n                    tptr +=8;\n                }\n                break;\n\n        case BGPTYPE_PMSI_TUNNEL:\n        {\n                uint8_t tunnel_type, flags;\n\n                tunnel_type = *(tptr+1);\n                flags = *tptr;\n                tlen = len;\n\n                ND_TCHECK2(tptr[0], 5);\n                ND_PRINT((ndo, \"\\n\\t    Tunnel-type %s (%u), Flags [%s], MPLS Label %u\",\n                       tok2str(bgp_pmsi_tunnel_values, \"Unknown\", tunnel_type),\n                       tunnel_type,\n                       bittok2str(bgp_pmsi_flag_values, \"none\", flags),\n                       EXTRACT_24BITS(tptr+2)>>4));\n\n                tptr +=5;\n                tlen -= 5;\n\n                switch (tunnel_type) {\n                case BGP_PMSI_TUNNEL_PIM_SM: /* fall through */\n                case BGP_PMSI_TUNNEL_PIM_BIDIR:\n                    ND_TCHECK2(tptr[0], 8);\n                    ND_PRINT((ndo, \"\\n\\t      Sender %s, P-Group %s\",\n                           ipaddr_string(ndo, tptr),\n                           ipaddr_string(ndo, tptr+4)));\n                    break;\n\n                case BGP_PMSI_TUNNEL_PIM_SSM:\n                    ND_TCHECK2(tptr[0], 8);\n                    ND_PRINT((ndo, \"\\n\\t      Root-Node %s, P-Group %s\",\n                           ipaddr_string(ndo, tptr),\n                           ipaddr_string(ndo, tptr+4)));\n                    break;\n                case BGP_PMSI_TUNNEL_INGRESS:\n                    ND_TCHECK2(tptr[0], 4);\n                    ND_PRINT((ndo, \"\\n\\t      Tunnel-Endpoint %s\",\n                           ipaddr_string(ndo, tptr)));\n                    break;\n                case BGP_PMSI_TUNNEL_LDP_P2MP: /* fall through */\n                case BGP_PMSI_TUNNEL_LDP_MP2MP:\n                    ND_TCHECK2(tptr[0], 8);\n                    ND_PRINT((ndo, \"\\n\\t      Root-Node %s, LSP-ID 0x%08x\",\n                           ipaddr_string(ndo, tptr),\n                           EXTRACT_32BITS(tptr+4)));\n                    break;\n                case BGP_PMSI_TUNNEL_RSVP_P2MP:\n                    ND_TCHECK2(tptr[0], 8);\n                    ND_PRINT((ndo, \"\\n\\t      Extended-Tunnel-ID %s, P2MP-ID 0x%08x\",\n                           ipaddr_string(ndo, tptr),\n                           EXTRACT_32BITS(tptr+4)));\n                    break;\n                default:\n                    if (ndo->ndo_vflag <= 1) {\n                        print_unknown_data(ndo, tptr, \"\\n\\t      \", tlen);\n                    }\n                }\n                break;\n        }\n\tcase BGPTYPE_AIGP:\n\t{\n \t\tuint8_t type;\n \t\tuint16_t length;\n \n\t\tND_TCHECK2(tptr[0], 3);\n \t\ttlen = len;\n \n \t\twhile (tlen >= 3) {\n \n \t\t    type = *tptr;\n \t\t    length = EXTRACT_16BITS(tptr+1);\n \n \t\t    ND_PRINT((ndo, \"\\n\\t    %s TLV (%u), length %u\",\n \t\t\t      tok2str(bgp_aigp_values, \"Unknown\", type),\n \t\t\t      type, length));\n \n \t\t    /*\n \t\t     * Check if we can read the TLV data.\n \t\t     */\n\t\t    ND_TCHECK2(tptr[3], length - 3);\n \n \t\t    switch (type) {\n \n \t\t    case BGP_AIGP_TLV:\n\t\t        ND_TCHECK2(tptr[3], 8);\n \t\t\tND_PRINT((ndo, \", metric %\" PRIu64,\n\t\t\t\t  EXTRACT_64BITS(tptr+3)));\n \t\t\tbreak;\n \n \t\t    default:\n \t\t\tif (ndo->ndo_vflag <= 1) {\n\t\t\t    print_unknown_data(ndo, tptr+3,\"\\n\\t      \", length-3);\n \t\t\t}\n \t\t    }\n \n\t\t    tptr += length;\n\t\t    tlen -= length;\n\t\t}\n\t\tbreak;\n\t}\n        case BGPTYPE_ATTR_SET:\n                ND_TCHECK2(tptr[0], 4);\n                if (len < 4)\n                \tgoto trunc;\n\t\tND_PRINT((ndo, \"\\n\\t    Origin AS: %s\",\n\t\t    as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(tptr))));\n\t\ttptr+=4;\n                len -=4;\n\n                while (len) {\n                    u_int aflags, alenlen, alen;\n\n                    ND_TCHECK2(tptr[0], 2);\n                    if (len < 2)\n                        goto trunc;\n                    aflags = *tptr;\n                    atype = *(tptr + 1);\n                    tptr += 2;\n                    len -= 2;\n                    alenlen = bgp_attr_lenlen(aflags, tptr);\n                    ND_TCHECK2(tptr[0], alenlen);\n                    if (len < alenlen)\n                        goto trunc;\n                    alen = bgp_attr_len(aflags, tptr);\n                    tptr += alenlen;\n                    len -= alenlen;\n\n                    ND_PRINT((ndo, \"\\n\\t      %s (%u), length: %u\",\n                           tok2str(bgp_attr_values,\n                                      \"Unknown Attribute\", atype),\n                           atype,\n                           alen));\n\n                    if (aflags) {\n                        ND_PRINT((ndo, \", Flags [%s%s%s%s\",\n                               aflags & 0x80 ? \"O\" : \"\",\n                               aflags & 0x40 ? \"T\" : \"\",\n                               aflags & 0x20 ? \"P\" : \"\",\n                               aflags & 0x10 ? \"E\" : \"\"));\n                        if (aflags & 0xf)\n                            ND_PRINT((ndo, \"+%x\", aflags & 0xf));\n                        ND_PRINT((ndo, \"]: \"));\n                    }\n                    /* FIXME check for recursion */\n                    if (!bgp_attr_print(ndo, atype, tptr, alen))\n                        return 0;\n                    tptr += alen;\n                    len -= alen;\n\t\t}\n                break;\n\n\tcase BGPTYPE_LARGE_COMMUNITY:\n\t\tif (len == 0 || len % 12) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n\t\tND_PRINT((ndo, \"\\n\\t    \"));\n\t\twhile (len > 0) {\n\t\t\tND_TCHECK2(*tptr, 12);\n\t\t\tND_PRINT((ndo, \"%u:%u:%u%s\",\n\t\t\t\t EXTRACT_32BITS(tptr),\n\t\t\t\t EXTRACT_32BITS(tptr + 4),\n\t\t\t\t EXTRACT_32BITS(tptr + 8),\n\t\t\t\t (len > 12) ? \", \" : \"\"));\n                        tptr += 12;\n                        len -= 12;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t    ND_TCHECK2(*pptr,len);\n            ND_PRINT((ndo, \"\\n\\t    no Attribute %u decoder\", atype)); /* we have no decoder for the attribute */\n            if (ndo->ndo_vflag <= 1)\n                print_unknown_data(ndo, pptr, \"\\n\\t    \", len);\n            break;\n\t}\n        if (ndo->ndo_vflag > 1 && len) { /* omit zero length attributes*/\n            ND_TCHECK2(*pptr,len);\n            print_unknown_data(ndo, pptr, \"\\n\\t    \", len);\n        }\n        return 1;\n\ntrunc:\n        return 0;\n}\n", "target": 1, "idx": 181085}
{"func": "void RenderWidgetHostViewAura::FinishImeCompositionSession() {\n  if (!has_composition_text_)\n    return;\n  if (host_) {\n    host_->ImeConfirmComposition(base::string16(), gfx::Range::InvalidRange(),\n                                 false);\n  }\n  ImeCancelComposition();\n}\n", "target": 0, "idx": 132941}
{"func": "void RTCPeerConnectionHandlerChromium::didChangeICEState(WebKit::WebRTCPeerConnectionHandlerClient::ICEState state)\n{\n    m_client->didChangeIceState(static_cast<RTCPeerConnectionHandlerClient::IceState>(state));\n}\n", "target": 0, "idx": 104289}
{"func": "static int listen(struct socket *sock, int len)\n{\n\tstruct sock *sk = sock->sk;\n\tint res;\n\n\tlock_sock(sk);\n\n\tif (sock->state != SS_UNCONNECTED)\n\t\tres = -EINVAL;\n\telse {\n\t\tsock->state = SS_LISTENING;\n\t\tres = 0;\n\t}\n\n\trelease_sock(sk);\n\treturn res;\n}\n", "target": 0, "idx": 30456}
{"func": "const GDataFile* GDataEntry::AsGDataFileConst() const {\n  return const_cast<GDataEntry*>(this)->AsGDataFile();\n}\n", "target": 0, "idx": 111626}
{"func": "static void vmx_refresh_apicv_exec_ctrl(struct kvm_vcpu *vcpu)\n{\n \tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n \n \tvmcs_write32(PIN_BASED_VM_EXEC_CONTROL, vmx_pin_based_exec_ctrl(vmx));\n }\n", "target": 1, "idx": 180435}
{"func": "static void unsignedShortSequenceAttrAttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)\n{\n    INC_STATS(\"DOM.TestObj.unsignedShortSequenceAttr._set\");\n    TestObj* imp = V8TestObj::toNative(info.Holder());\n    Vector<unsigned short> v = toNativeArray<unsigned short>(value);\n    imp->setUnsignedShortSequenceAttr(v);\n    return;\n}\n", "target": 0, "idx": 117892}
{"func": "void sctp_generate_t3_rtx_event(unsigned long peer)\n{\n \tint error;\n \tstruct sctp_transport *transport = (struct sctp_transport *) peer;\n \tstruct sctp_association *asoc = transport->asoc;\n\tstruct net *net = sock_net(asoc->base.sk);\n \n \t/* Check whether a task is in the sock.  */\n \n\tbh_lock_sock(asoc->base.sk);\n\tif (sock_owned_by_user(asoc->base.sk)) {\n \t\tpr_debug(\"%s: sock is busy\\n\", __func__);\n \n \t\t/* Try again later.  */\n\t\tif (!mod_timer(&transport->T3_rtx_timer, jiffies + (HZ/20)))\n\t\t\tsctp_transport_hold(transport);\n\t\tgoto out_unlock;\n\t}\n\n\t/* Is this transport really dead and just waiting around for\n\t * the timer to let go of the reference?\n\t */\n\tif (transport->dead)\n\t\tgoto out_unlock;\n\n\t/* Run through the state machine.  */\n\terror = sctp_do_sm(net, SCTP_EVENT_T_TIMEOUT,\n\t\t\t   SCTP_ST_TIMEOUT(SCTP_EVENT_TIMEOUT_T3_RTX),\n\t\t\t   asoc->state,\n\t\t\t   asoc->ep, asoc,\n \t\t\t   transport, GFP_ATOMIC);\n \n \tif (error)\n\t\tasoc->base.sk->sk_err = -error;\n \n out_unlock:\n\tbh_unlock_sock(asoc->base.sk);\n \tsctp_transport_put(transport);\n }\n", "target": 1, "idx": 180674}
{"func": "int kvm_iommu_map_pages(struct kvm *kvm, struct kvm_memory_slot *slot)\n{\n\tgfn_t gfn, end_gfn;\n\tpfn_t pfn;\n\tint r = 0;\n\tstruct iommu_domain *domain = kvm->arch.iommu_domain;\n\tint flags;\n\n\t/* check if iommu exists and in use */\n\tif (!domain)\n\t\treturn 0;\n\n\tgfn     = slot->base_gfn;\n\tend_gfn = gfn + slot->npages;\n\n\tflags = IOMMU_READ;\n\tif (!(slot->flags & KVM_MEM_READONLY))\n\t\tflags |= IOMMU_WRITE;\n\tif (!kvm->arch.iommu_noncoherent)\n\t\tflags |= IOMMU_CACHE;\n\n\n\twhile (gfn < end_gfn) {\n\t\tunsigned long page_size;\n\n\t\t/* Check if already mapped */\n\t\tif (iommu_iova_to_phys(domain, gfn_to_gpa(gfn))) {\n\t\t\tgfn += 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Get the page size we could use to map */\n\t\tpage_size = kvm_host_page_size(kvm, gfn);\n\n\t\t/* Make sure the page_size does not exceed the memslot */\n\t\twhile ((gfn + (page_size >> PAGE_SHIFT)) > end_gfn)\n\t\t\tpage_size >>= 1;\n\n\t\t/* Make sure gfn is aligned to the page size we want to map */\n\t\twhile ((gfn << PAGE_SHIFT) & (page_size - 1))\n\t\t\tpage_size >>= 1;\n\n\t\t/* Make sure hva is aligned to the page size we want to map */\n\t\twhile (__gfn_to_hva_memslot(slot, gfn) & (page_size - 1))\n\t\t\tpage_size >>= 1;\n\n\t\t/*\n \t\t * Pin all pages we are about to map in memory. This is\n \t\t * important because we unmap and unpin in 4kb steps later.\n \t\t */\n\t\tpfn = kvm_pin_pages(slot, gfn, page_size);\n \t\tif (is_error_noslot_pfn(pfn)) {\n \t\t\tgfn += 1;\n \t\t\tcontinue;\n\t\t}\n\n\t\t/* Map into IO address space */\n\t\tr = iommu_map(domain, gfn_to_gpa(gfn), pfn_to_hpa(pfn),\n\t\t\t      page_size, flags);\n \t\tif (r) {\n \t\t\tprintk(KERN_ERR \"kvm_iommu_map_address:\"\n \t\t\t       \"iommu failed to map pfn=%llx\\n\", pfn);\n\t\t\tkvm_unpin_pages(kvm, pfn, page_size);\n \t\t\tgoto unmap_pages;\n \t\t}\n \n\t\tgfn += page_size >> PAGE_SHIFT;\n\n\n\t}\n\n\treturn 0;\n\nunmap_pages:\n\tkvm_iommu_put_pages(kvm, slot->base_gfn, gfn - slot->base_gfn);\n\treturn r;\n}\n", "target": 1, "idx": 179416}
{"func": "static inline bool cfs_rq_is_decayed(struct cfs_rq *cfs_rq)\n{\n\tif (cfs_rq->load.weight)\n\t\treturn false;\n\tif (cfs_rq->avg.load_sum)\n\t\treturn false;\n\tif (cfs_rq->avg.util_sum)\n\t\treturn false;\n\tif (cfs_rq->avg.runnable_load_sum)\n\t\treturn false;\n\treturn true;\n}\n", "target": 1, "idx": 182956}
{"func": "static int checkRangeLMN(i_ctx_t * i_ctx_p, ref *CIEdict)\n{\n    int code;\n    float value[6];\n    ref *tempref;\n\n    code = dict_find_string(CIEdict, \"RangeLMN\", &tempref);\n    if (code > 0 && !r_has_type(tempref, t_null)) {\n        if (!r_is_array(tempref))\n            return_error(gs_error_typecheck);\n        if (r_size(tempref) != 6)\n            return_error(gs_error_rangecheck);\n        code = get_cie_param_array(imemory, tempref, 6, value);\n        if (code < 0)\n            return code;\n        if (value[1] < value[0] || value[3] < value[2] || value[5] < value[4])\n            return_error(gs_error_rangecheck);\n    }\n    return 0;\n}\n", "target": 0, "idx": 3034}
{"func": "MagickExport Image *CloneImage(const Image *image,const size_t columns,\n  const size_t rows,const MagickBooleanType detach,ExceptionInfo *exception)\n{\n  Image\n    *clone_image;\n\n  double\n    scale;\n\n  size_t\n    length;\n\n  /*\n    Clone the image.\n  */\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if ((image->columns == 0) || (image->rows == 0))\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,\n        \"NegativeOrZeroImageSize\",\"`%s'\",image->filename);\n      return((Image *) NULL);\n    }\n  clone_image=(Image *) AcquireMagickMemory(sizeof(*clone_image));\n  if (clone_image == (Image *) NULL)\n    ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(clone_image,0,sizeof(*clone_image));\n  clone_image->signature=MagickCoreSignature;\n  clone_image->storage_class=image->storage_class;\n  clone_image->number_channels=image->number_channels;\n  clone_image->number_meta_channels=image->number_meta_channels;\n  clone_image->metacontent_extent=image->metacontent_extent;\n  clone_image->colorspace=image->colorspace;\n  clone_image->read_mask=image->read_mask;\n  clone_image->write_mask=image->write_mask;\n  clone_image->alpha_trait=image->alpha_trait;\n  clone_image->columns=image->columns;\n  clone_image->rows=image->rows;\n  clone_image->dither=image->dither;\n  if (image->colormap != (PixelInfo *) NULL)\n    {\n      /*\n        Allocate and copy the image colormap.\n      */\n      clone_image->colors=image->colors;\n      length=(size_t) image->colors;\n       clone_image->colormap=(PixelInfo *) AcquireQuantumMemory(length,\n         sizeof(*clone_image->colormap));\n       if (clone_image->colormap == (PixelInfo *) NULL)\n        ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\");\n       (void) CopyMagickMemory(clone_image->colormap,image->colormap,length*\n         sizeof(*clone_image->colormap));\n     }\n  clone_image->image_info=CloneImageInfo(image->image_info);\n  (void) CloneImageProfiles(clone_image,image);\n  (void) CloneImageProperties(clone_image,image);\n  (void) CloneImageArtifacts(clone_image,image);\n  GetTimerInfo(&clone_image->timer);\n  if (image->ascii85 != (void *) NULL)\n    Ascii85Initialize(clone_image);\n  clone_image->magick_columns=image->magick_columns;\n  clone_image->magick_rows=image->magick_rows;\n  clone_image->type=image->type;\n  clone_image->channel_mask=image->channel_mask;\n  clone_image->channel_map=ClonePixelChannelMap(image->channel_map);\n  (void) CopyMagickString(clone_image->magick_filename,image->magick_filename,\n    MagickPathExtent);\n  (void) CopyMagickString(clone_image->magick,image->magick,MagickPathExtent);\n  (void) CopyMagickString(clone_image->filename,image->filename,\n    MagickPathExtent);\n  clone_image->progress_monitor=image->progress_monitor;\n  clone_image->client_data=image->client_data;\n  clone_image->reference_count=1;\n  clone_image->next=image->next;\n  clone_image->previous=image->previous;\n  clone_image->list=NewImageList();\n  if (detach == MagickFalse)\n    clone_image->blob=ReferenceBlob(image->blob);\n  else\n    {\n      clone_image->next=NewImageList();\n      clone_image->previous=NewImageList();\n      clone_image->blob=CloneBlobInfo((BlobInfo *) NULL);\n    }\n  clone_image->ping=image->ping;\n  clone_image->debug=IsEventLogging();\n  clone_image->semaphore=AcquireSemaphoreInfo();\n  if ((columns == 0) || (rows == 0))\n    {\n      if (image->montage != (char *) NULL)\n        (void) CloneString(&clone_image->montage,image->montage);\n      if (image->directory != (char *) NULL)\n        (void) CloneString(&clone_image->directory,image->directory);\n      clone_image->cache=ReferencePixelCache(image->cache);\n      return(clone_image);\n    }\n  scale=1.0;\n  if (image->columns != 0)\n    scale=(double) columns/(double) image->columns;\n  clone_image->page.width=(size_t) floor(scale*image->page.width+0.5);\n  clone_image->page.x=(ssize_t) ceil(scale*image->page.x-0.5);\n  clone_image->tile_offset.x=(ssize_t) ceil(scale*image->tile_offset.x-0.5);\n  scale=1.0;\n  if (image->rows != 0)\n    scale=(double) rows/(double) image->rows;\n  clone_image->page.height=(size_t) floor(scale*image->page.height+0.5);\n  clone_image->page.y=(ssize_t) ceil(scale*image->page.y-0.5);\n  clone_image->tile_offset.y=(ssize_t) ceil(scale*image->tile_offset.y-0.5);\n  clone_image->columns=columns;\n  clone_image->rows=rows;\n  clone_image->cache=ClonePixelCache(image->cache);\n  return(clone_image);\n}\n", "target": 1, "idx": 183132}
{"func": "void SyncManager::MaybeSetSyncTabsInNigoriNode(\n    ModelTypeSet enabled_types) {\n  DCHECK(thread_checker_.CalledOnValidThread());\n  data_->MaybeSetSyncTabsInNigoriNode(enabled_types);\n}\n", "target": 1, "idx": 184368}
{"func": "enum dm_queue_mode dm_get_md_type(struct mapped_device *md)\n{\n\treturn md->type;\n}\n", "target": 0, "idx": 85893}
{"func": "void HTMLSelectElement::setRecalcListItems()\n{\n    m_shouldRecalcListItems = true;\n    m_activeSelectionAnchorIndex = -1;\n    setOptionsChangedOnRenderer();\n    setNeedsStyleRecalc();\n    if (!inDocument()) {\n        if (HTMLCollection* collection = cachedHTMLCollection(SelectOptions))\n            collection->invalidateCache();\n    }\n    if (!inDocument())\n        invalidateSelectedItems();\n    \n    if (renderer()) {\n        if (AXObjectCache* cache = renderer()->document()->existingAXObjectCache())\n            cache->childrenChanged(this);\n    }\n}\n", "target": 0, "idx": 110064}
{"func": "void ShellWindow::Observe(int type,\n                           const content::NotificationSource& source,\n                           const content::NotificationDetails& details) {\n   switch (type) {\n     case chrome::NOTIFICATION_EXTENSION_UNLOADED: {\n       const extensions::Extension* unloaded_extension =\n           content::Details<extensions::UnloadedExtensionInfo>(\n              details)->extension;\n      if (extension_ == unloaded_extension)\n        Close();\n      break;\n    }\n    case content::NOTIFICATION_APP_TERMINATING:\n      Close();\n      break;\n    default:\n      NOTREACHED() << \"Received unexpected notification\";\n  }\n}\n", "target": 1, "idx": 184387}
{"func": "void WebSettingsImpl::setSessionStorageEnabled(bool enabled)\n{\n    m_settings->setSessionStorageEnabled(enabled);\n}\n", "target": 0, "idx": 100484}
{"func": "unsigned char *ssl_add_serverhello_tlsext(SSL *s, unsigned char *buf,\n                                          unsigned char *limit, int *al)\n{\n    int extdatalen = 0;\n    unsigned char *orig = buf;\n    unsigned char *ret = buf;\n#ifndef OPENSSL_NO_NEXTPROTONEG\n    int next_proto_neg_seen;\n#endif\n#ifndef OPENSSL_NO_EC\n    unsigned long alg_k = s->s3->tmp.new_cipher->algorithm_mkey;\n    unsigned long alg_a = s->s3->tmp.new_cipher->algorithm_auth;\n    int using_ecc = (alg_k & SSL_kECDHE) || (alg_a & SSL_aECDSA);\n    using_ecc = using_ecc && (s->session->tlsext_ecpointformatlist != NULL);\n#endif\n\n    ret += 2;\n    if (ret >= limit)\n        return NULL;            /* this really never occurs, but ... */\n\n    if (s->s3->send_connection_binding) {\n        int el;\n\n        if (!ssl_add_serverhello_renegotiate_ext(s, 0, &el, 0)) {\n            SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n            return NULL;\n        }\n\n        /*-\n         * check for enough space.\n         * 4 bytes for the reneg type and extension length\n         * + reneg data length\n         */\n        if (CHECKLEN(ret, 4 + el, limit))\n            return NULL;\n\n        s2n(TLSEXT_TYPE_renegotiate, ret);\n        s2n(el, ret);\n\n        if (!ssl_add_serverhello_renegotiate_ext(s, ret, &el, el)) {\n            SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n            return NULL;\n        }\n\n        ret += el;\n    }\n\n    /* Only add RI for SSLv3 */\n    if (s->version == SSL3_VERSION)\n        goto done;\n\n    if (!s->hit && s->servername_done == 1\n        && s->session->tlsext_hostname != NULL) {\n        /*-\n         * check for enough space.\n         * 4 bytes for the server name type and extension length\n         */\n        if (CHECKLEN(ret, 4, limit))\n            return NULL;\n\n        s2n(TLSEXT_TYPE_server_name, ret);\n        s2n(0, ret);\n    }\n#ifndef OPENSSL_NO_EC\n    if (using_ecc) {\n        const unsigned char *plist;\n        size_t plistlen;\n        /*\n         * Add TLS extension ECPointFormats to the ServerHello message\n         */\n\n        tls1_get_formatlist(s, &plist, &plistlen);\n\n        if (plistlen > 255) {\n            SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n            return NULL;\n        }\n\n        /*-\n         * check for enough space.\n         * 4 bytes for the ec points format type and extension length\n         * 1 byte for the points format list length\n         * + length of points format list\n         */\n        if (CHECKLEN(ret, 5 + plistlen, limit))\n            return NULL;\n\n        s2n(TLSEXT_TYPE_ec_point_formats, ret);\n        s2n(plistlen + 1, ret);\n        *(ret++) = (unsigned char)plistlen;\n        memcpy(ret, plist, plistlen);\n        ret += plistlen;\n\n    }\n    /*\n     * Currently the server should not respond with a SupportedCurves\n     * extension\n     */\n#endif                          /* OPENSSL_NO_EC */\n\n    if (s->tlsext_ticket_expected && tls_use_ticket(s)) {\n        /*-\n         * check for enough space.\n         * 4 bytes for the Ticket type and extension length\n         */\n        if (CHECKLEN(ret, 4, limit))\n            return NULL;\n        s2n(TLSEXT_TYPE_session_ticket, ret);\n        s2n(0, ret);\n    } else {\n        /*\n         * if we don't add the above TLSEXT, we can't add a session ticket\n         * later\n         */\n        s->tlsext_ticket_expected = 0;\n    }\n\n    if (s->tlsext_status_expected) {\n        /*-\n         * check for enough space.\n         * 4 bytes for the Status request type and extension length\n         */\n        if (CHECKLEN(ret, 4, limit))\n            return NULL;\n        s2n(TLSEXT_TYPE_status_request, ret);\n        s2n(0, ret);\n    }\n#ifndef OPENSSL_NO_SRTP\n    if (SSL_IS_DTLS(s) && s->srtp_profile) {\n        int el;\n\n        /* Returns 0 on success!! */\n        if (ssl_add_serverhello_use_srtp_ext(s, 0, &el, 0)) {\n            SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n            return NULL;\n        }\n        /*-\n         * check for enough space.\n         * 4 bytes for the SRTP profiles type and extension length\n         * + length of the SRTP profiles list\n         */\n        if (CHECKLEN(ret, 4 + el, limit))\n            return NULL;\n\n        s2n(TLSEXT_TYPE_use_srtp, ret);\n        s2n(el, ret);\n\n        if (ssl_add_serverhello_use_srtp_ext(s, ret, &el, el)) {\n            SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n            return NULL;\n        }\n        ret += el;\n    }\n#endif\n\n    if (((s->s3->tmp.new_cipher->id & 0xFFFF) == 0x80\n         || (s->s3->tmp.new_cipher->id & 0xFFFF) == 0x81)\n        && (SSL_get_options(s) & SSL_OP_CRYPTOPRO_TLSEXT_BUG)) {\n        const unsigned char cryptopro_ext[36] = {\n            0xfd, 0xe8,         /* 65000 */\n            0x00, 0x20,         /* 32 bytes length */\n            0x30, 0x1e, 0x30, 0x08, 0x06, 0x06, 0x2a, 0x85,\n            0x03, 0x02, 0x02, 0x09, 0x30, 0x08, 0x06, 0x06,\n            0x2a, 0x85, 0x03, 0x02, 0x02, 0x16, 0x30, 0x08,\n            0x06, 0x06, 0x2a, 0x85, 0x03, 0x02, 0x02, 0x17\n        };\n\n        /* check for enough space. */\n        if (CHECKLEN(ret, sizeof(cryptopro_ext), limit))\n            return NULL;\n        memcpy(ret, cryptopro_ext, sizeof(cryptopro_ext));\n        ret += sizeof(cryptopro_ext);\n\n    }\n#ifndef OPENSSL_NO_HEARTBEATS\n    /* Add Heartbeat extension if we've received one */\n    if (SSL_IS_DTLS(s) && (s->tlsext_heartbeat & SSL_DTLSEXT_HB_ENABLED)) {\n        /*-\n         * check for enough space.\n         * 4 bytes for the Heartbeat type and extension length\n         * 1 byte for the mode\n         */\n        if (CHECKLEN(ret, 5, limit))\n            return NULL;\n        s2n(TLSEXT_TYPE_heartbeat, ret);\n        s2n(1, ret);\n        /*-\n         * Set mode:\n         * 1: peer may send requests\n         * 2: peer not allowed to send requests\n         */\n        if (s->tlsext_heartbeat & SSL_DTLSEXT_HB_DONT_RECV_REQUESTS)\n            *(ret++) = SSL_DTLSEXT_HB_DONT_SEND_REQUESTS;\n        else\n            *(ret++) = SSL_DTLSEXT_HB_ENABLED;\n\n    }\n#endif\n\n#ifndef OPENSSL_NO_NEXTPROTONEG\n    next_proto_neg_seen = s->s3->next_proto_neg_seen;\n    s->s3->next_proto_neg_seen = 0;\n    if (next_proto_neg_seen && s->ctx->next_protos_advertised_cb) {\n        const unsigned char *npa;\n        unsigned int npalen;\n        int r;\n\n        r = s->ctx->next_protos_advertised_cb(s, &npa, &npalen,\n                                              s->\n                                              ctx->next_protos_advertised_cb_arg);\n        if (r == SSL_TLSEXT_ERR_OK) {\n            /*-\n             * check for enough space.\n             * 4 bytes for the NPN type and extension length\n             * + length of protocols list\n             */\n            if (CHECKLEN(ret, 4 + npalen, limit))\n                return NULL;\n            s2n(TLSEXT_TYPE_next_proto_neg, ret);\n            s2n(npalen, ret);\n            memcpy(ret, npa, npalen);\n            ret += npalen;\n            s->s3->next_proto_neg_seen = 1;\n        }\n    }\n #endif\n     if (!custom_ext_add(s, 1, &ret, limit, al))\n         return NULL;\n    if (s->s3->flags & TLS1_FLAGS_ENCRYPT_THEN_MAC) {\n         /*\n          * Don't use encrypt_then_mac if AEAD or RC4 might want to disable\n          * for other cases too.\n         */\n        if (SSL_IS_DTLS(s) || s->s3->tmp.new_cipher->algorithm_mac == SSL_AEAD\n             || s->s3->tmp.new_cipher->algorithm_enc == SSL_RC4\n             || s->s3->tmp.new_cipher->algorithm_enc == SSL_eGOST2814789CNT\n             || s->s3->tmp.new_cipher->algorithm_enc == SSL_eGOST2814789CNT12)\n            s->s3->flags &= ~TLS1_FLAGS_ENCRYPT_THEN_MAC;\n         else {\n             /*-\n              * check for enough space.\n             * 4 bytes for the ETM type and extension length\n             */\n            if (CHECKLEN(ret, 4, limit))\n                return NULL;\n            s2n(TLSEXT_TYPE_encrypt_then_mac, ret);\n            s2n(0, ret);\n        }\n    }\n    if (s->s3->flags & TLS1_FLAGS_RECEIVED_EXTMS) {\n        /*-\n         * check for enough space.\n         * 4 bytes for the EMS type and extension length\n         */\n        if (CHECKLEN(ret, 4, limit))\n            return NULL;\n        s2n(TLSEXT_TYPE_extended_master_secret, ret);\n        s2n(0, ret);\n    }\n\n    if (s->s3->alpn_selected != NULL) {\n        const unsigned char *selected = s->s3->alpn_selected;\n        size_t len = s->s3->alpn_selected_len;\n\n        /*-\n         * check for enough space.\n         * 4 bytes for the ALPN type and extension length\n         * 2 bytes for ALPN data length\n         * 1 byte for selected protocol length\n         * + length of the selected protocol\n         */\n        if (CHECKLEN(ret, 7 + len, limit))\n            return NULL;\n        s2n(TLSEXT_TYPE_application_layer_protocol_negotiation, ret);\n        s2n(3 + len, ret);\n        s2n(1 + len, ret);\n        *ret++ = len;\n        memcpy(ret, selected, len);\n        ret += len;\n    }\n\n done:\n\n    if ((extdatalen = ret - orig - 2) == 0)\n        return orig;\n\n    s2n(extdatalen, orig);\n    return ret;\n}\n", "target": 1, "idx": 181599}
{"func": "void SerializerMarkupAccumulator::appendElement(StringBuilder& result, Element* element, Namespaces* namespaces)\n {\n     if (!shouldIgnoreElement(element))\n        MarkupAccumulator::appendElement(result, element, namespaces);\n \n        result.appendLiteral(\"<meta charset=\\\"\");\n        result.append(m_document->charset());\n        if (m_document->isXHTMLDocument())\n            result.appendLiteral(\"\\\" />\");\n        else\n            result.appendLiteral(\"\\\">\");\n     }\n \n }\n", "target": 1, "idx": 185270}
{"func": "static void __free_filter(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tfree_prog(filter);\n\tkfree(filter->filter_string);\n\tkfree(filter);\n}\n", "target": 0, "idx": 81549}
{"func": "reverseSamplesBytes (uint16 spp, uint16 bps, uint32 width, \n                     uint8 *src, uint8 *dst)\n  {\n  int i;\n  uint32  col, bytes_per_pixel, col_offset;\n  uint8   bytebuff1;\n  unsigned char swapbuff[32];\n  \n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"reverseSamplesBytes\",\"Invalid input or output buffer\");\n    return (1);\n     }\n \n   bytes_per_pixel  = ((bps * spp) + 7) / 8;\n   switch (bps / 8)\n      {\n      case 8:  /* Use memcpy for multiple bytes per sample data */\n     case 4:\n     case 3:\n     case 2: for (col = 0; col < (width / 2); col++)\n               {\n\t       col_offset = col * bytes_per_pixel;                     \n\t       _TIFFmemcpy (swapbuff, src + col_offset, bytes_per_pixel);\n\t       _TIFFmemcpy (src + col_offset, dst - col_offset - bytes_per_pixel, bytes_per_pixel);\n\t       _TIFFmemcpy (dst - col_offset - bytes_per_pixel, swapbuff, bytes_per_pixel);\n               }\n\t     break;\n     case 1: /* Use byte copy only for single byte per sample data */\n             for (col = 0; col < (width / 2); col++)\n               { \n\t       for (i = 0; i < spp; i++)\n                  {\n\t\t  bytebuff1 = *src;\n\t\t  *src++ = *(dst - spp + i);\n                  *(dst - spp + i) = bytebuff1;\n\t\t  }\n\t\tdst -= spp;\n                }\n\t     break;\n     default: TIFFError(\"reverseSamplesBytes\",\"Unsupported bit depth %d\", bps);\n       return (1);\n     }\n  return (0);\n  } /* end reverseSamplesBytes */\n", "target": 1, "idx": 180047}
{"func": "_tiffSeekProc(thandle_t fd, uint64 off, int whence)\n{\n\tLARGE_INTEGER offli;\n\tDWORD dwMoveMethod;\n\toffli.QuadPart = off;\n\tswitch(whence)\n\t{\n\t\tcase SEEK_SET:\n\t\t\tdwMoveMethod = FILE_BEGIN;\n\t\t\tbreak;\n\t\tcase SEEK_CUR:\n\t\t\tdwMoveMethod = FILE_CURRENT;\n\t\t\tbreak;\n\t\tcase SEEK_END:\n\t\t\tdwMoveMethod = FILE_END;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdwMoveMethod = FILE_BEGIN;\n\t\t\tbreak;\n\t}\n\toffli.LowPart=SetFilePointer(fd,offli.LowPart,&offli.HighPart,dwMoveMethod);\n\tif ((offli.LowPart==INVALID_SET_FILE_POINTER)&&(GetLastError()!=NO_ERROR))\n\t\toffli.QuadPart=0;\n\treturn(offli.QuadPart);\n}\n", "target": 0, "idx": 86811}
{"func": "void skb_complete_tx_timestamp(struct sk_buff *skb,\n\t\t\t       struct skb_shared_hwtstamps *hwtstamps)\n{\n\tstruct sock *sk = skb->sk;\n\n\tif (!skb_may_tx_timestamp(sk, false))\n\t\treturn;\n\n\t/* Take a reference to prevent skb_orphan() from freeing the socket,\n\t * but only if the socket refcount is not zero.\n \t */\n \tif (likely(atomic_inc_not_zero(&sk->sk_refcnt))) {\n \t\t*skb_hwtstamps(skb) = *hwtstamps;\n\t\t__skb_complete_tx_timestamp(skb, sk, SCM_TSTAMP_SND);\n \t\tsock_put(sk);\n \t}\n }\n", "target": 1, "idx": 183245}
{"func": "GLboolean WebGLRenderingContextBase::isTexture(WebGLTexture* texture) {\n  if (!texture || isContextLost())\n    return 0;\n\n  if (!texture->HasEverBeenBound())\n    return 0;\n  if (texture->IsDeleted())\n    return 0;\n\n  return ContextGL()->IsTexture(texture->Object());\n}\n", "target": 0, "idx": 146527}
{"func": "bool config_save(const config_t *config, const char *filename) {\n  assert(config != NULL);\n\n   assert(filename != NULL);\n   assert(*filename != '\\0');\n \n  char *temp_filename = osi_calloc(strlen(filename) + 5);\n  if (!temp_filename) {\n    LOG_ERROR(\"%s unable to allocate memory for filename.\", __func__);\n    return false;\n   }\n \n  strcpy(temp_filename, filename);\n  strcat(temp_filename, \".new\");\n \n  FILE *fp = fopen(temp_filename, \"wt\");\n   if (!fp) {\n     LOG_ERROR(\"%s unable to write file '%s': %s\", __func__, temp_filename, strerror(errno));\n     goto error;\n }\n\n \n   for (const list_node_t *node = list_begin(config->sections); node != list_end(config->sections); node = list_next(node)) {\n     const section_t *section = (const section_t *)list_node(node);\n    fprintf(fp, \"[%s]\\n\", section->name);\n \n     for (const list_node_t *enode = list_begin(section->entries); enode != list_end(section->entries); enode = list_next(enode)) {\n       const entry_t *entry = (const entry_t *)list_node(enode);\n      fprintf(fp, \"%s = %s\\n\", entry->key, entry->value);\n     }\n \n    if (list_next(node) != list_end(config->sections))\n      fputc('\\n', fp);\n   }\n \n  fflush(fp);\n  fclose(fp);\n \n   if (chmod(temp_filename, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP) == -1) {\n    LOG_ERROR(\"%s unable to change file permissions '%s': %s\", __func__, filename, strerror(errno));\n\n     goto error;\n   }\n \n   if (rename(temp_filename, filename) == -1) {\n     LOG_ERROR(\"%s unable to commit file '%s': %s\", __func__, filename, strerror(errno));\n     goto error;\n   }\n \n   osi_free(temp_filename);\n   return true;\n \nerror:;\n   unlink(temp_filename);\n   osi_free(temp_filename);\n   return false;\n }\n", "target": 1, "idx": 187501}
{"func": "void WebPluginImpl::InitiateHTTPRangeRequest(const char* url,\n                                             const char* range_info,\n                                             intptr_t existing_stream,\n                                             bool notify_needed,\n                                             intptr_t notify_data) {\n   unsigned long resource_id = GetNextResourceId();\n   if (!resource_id)\n     return;\n \n   GURL complete_url = CompleteURL(url);\n \n  WebPluginResourceClient* resource_client = delegate_->CreateResourceClient(\n      resource_id, complete_url, notify_needed, notify_data, existing_stream);\n   InitiateHTTPRequest(\n      resource_id, resource_client, \"GET\", NULL, 0, complete_url, range_info,\n       load_manually_ ? NO_REFERRER : PLUGIN_SRC);\n }\n", "target": 1, "idx": 183598}
{"func": " header_put_be_short (SF_PRIVATE *psf, int x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 2)\n\t{\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = x ;\n\t\t} ;\n } /* header_put_be_short */\n", "target": 1, "idx": 183224}
{"func": "MountLibrary* CrosLibrary::GetMountLibrary() {\n  return mount_lib_.GetDefaultImpl(use_stub_impl_);\n}\n", "target": 1, "idx": 184094}
{"func": "getHTTPResponse(int s, int * size)\n{\n\tchar buf[2048];\n\tint n;\n\tint endofheaders = 0;\n\tint chunked = 0;\n\tint content_length = -1;\n\tunsigned int chunksize = 0;\n\tunsigned int bytestocopy = 0;\n\t/* buffers : */\n\tchar * header_buf;\n\tunsigned int header_buf_len = 2048;\n\tunsigned int header_buf_used = 0;\n\tchar * content_buf;\n\tunsigned int content_buf_len = 2048;\n\tunsigned int content_buf_used = 0;\n\tchar chunksize_buf[32];\n\tunsigned int chunksize_buf_index;\n\n\theader_buf = malloc(header_buf_len);\n\tcontent_buf = malloc(content_buf_len);\n\tchunksize_buf[0] = '\\0';\n\tchunksize_buf_index = 0;\n\n\twhile((n = receivedata(s, buf, 2048, 5000, NULL)) > 0)\n\t{\n\t\tif(endofheaders == 0)\n\t\t{\n\t\t\tint i;\n\t\t\tint linestart=0;\n\t\t\tint colon=0;\n\t\t\tint valuestart=0;\n\t\t\tif(header_buf_used + n > header_buf_len) {\n\t\t\t\theader_buf = realloc(header_buf, header_buf_used + n);\n\t\t\t\theader_buf_len = header_buf_used + n;\n\t\t\t}\n\t\t\tmemcpy(header_buf + header_buf_used, buf, n);\n\t\t\theader_buf_used += n;\n\t\t\t/* search for CR LF CR LF (end of headers)\n\t\t\t * recognize also LF LF */\n\t\t\ti = 0;\n\t\t\twhile(i < ((int)header_buf_used-1) && (endofheaders == 0)) {\n\t\t\t\tif(header_buf[i] == '\\r') {\n\t\t\t\t\ti++;\n\t\t\t\t\tif(header_buf[i] == '\\n') {\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tif(i < (int)header_buf_used && header_buf[i] == '\\r') {\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\tif(i < (int)header_buf_used && header_buf[i] == '\\n') {\n\t\t\t\t\t\t\t\tendofheaders = i+1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if(header_buf[i] == '\\n') {\n\t\t\t\t\ti++;\n\t\t\t\t\tif(header_buf[i] == '\\n') {\n\t\t\t\t\t\tendofheaders = i+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif(endofheaders == 0)\n\t\t\t\tcontinue;\n\t\t\t/* parse header lines */\n\t\t\tfor(i = 0; i < endofheaders - 1; i++) {\n\t\t\t\tif(colon <= linestart && header_buf[i]==':')\n\t\t\t\t{\n\t\t\t\t\tcolon = i;\n\t\t\t\t\twhile(i < (endofheaders-1)\n\t\t\t\t\t      && (header_buf[i+1] == ' ' || header_buf[i+1] == '\\t'))\n\t\t\t\t\t\ti++;\n\t\t\t\t\tvaluestart = i + 1;\n\t\t\t\t}\n\t\t\t\t/* detecting end of line */\n\t\t\t\telse if(header_buf[i]=='\\r' || header_buf[i]=='\\n')\n\t\t\t\t{\n\t\t\t\t\tif(colon > linestart && valuestart > colon)\n\t\t\t\t\t{\n#ifdef DEBUG\n\t\t\t\t\t\tprintf(\"header='%.*s', value='%.*s'\\n\",\n\t\t\t\t\t\t       colon-linestart, header_buf+linestart,\n\t\t\t\t\t\t       i-valuestart, header_buf+valuestart);\n#endif\n\t\t\t\t\t\tif(0==strncasecmp(header_buf+linestart, \"content-length\", colon-linestart))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcontent_length = atoi(header_buf+valuestart);\n#ifdef DEBUG\n\t\t\t\t\t\t\tprintf(\"Content-Length: %d\\n\", content_length);\n#endif\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(0==strncasecmp(header_buf+linestart, \"transfer-encoding\", colon-linestart)\n\t\t\t\t\t\t   && 0==strncasecmp(header_buf+valuestart, \"chunked\", 7))\n\t\t\t\t\t\t{\n#ifdef DEBUG\n\t\t\t\t\t\t\tprintf(\"chunked transfer-encoding!\\n\");\n#endif\n \t\t\t\t\t\t\tchunked = 1;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n\t\t\t\t\twhile(header_buf[i]=='\\r' || header_buf[i] == '\\n')\n \t\t\t\t\t\ti++;\n \t\t\t\t\tlinestart = i;\n \t\t\t\t\tcolon = linestart;\n\t\t\t\t\tvaluestart = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* copy the remaining of the received data back to buf */\n\t\t\tn = header_buf_used - endofheaders;\n\t\t\tmemcpy(buf, header_buf + endofheaders, n);\n\t\t\t/* if(headers) */\n\t\t}\n\t\tif(endofheaders)\n\t\t{\n\t\t\t/* content */\n\t\t\tif(chunked)\n\t\t\t{\n\t\t\t\tint i = 0;\n\t\t\t\twhile(i < n)\n\t\t\t\t{\n\t\t\t\t\tif(chunksize == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* reading chunk size */\n\t\t\t\t\t\tif(chunksize_buf_index == 0) {\n\t\t\t\t\t\t\t/* skipping any leading CR LF */\n\t\t\t\t\t\t\tif(i<n && buf[i] == '\\r') i++;\n\t\t\t\t\t\t\tif(i<n && buf[i] == '\\n') i++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile(i<n && isxdigit(buf[i])\n\t\t\t\t\t\t     && chunksize_buf_index < (sizeof(chunksize_buf)-1))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tchunksize_buf[chunksize_buf_index++] = buf[i];\n\t\t\t\t\t\t\tchunksize_buf[chunksize_buf_index] = '\\0';\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile(i<n && buf[i] != '\\r' && buf[i] != '\\n')\n\t\t\t\t\t\t\ti++; /* discarding chunk-extension */\n\t\t\t\t\t\tif(i<n && buf[i] == '\\r') i++;\n\t\t\t\t\t\tif(i<n && buf[i] == '\\n') {\n\t\t\t\t\t\t\tunsigned int j;\n\t\t\t\t\t\t\tfor(j = 0; j < chunksize_buf_index; j++) {\n\t\t\t\t\t\t\tif(chunksize_buf[j] >= '0'\n\t\t\t\t\t\t\t   && chunksize_buf[j] <= '9')\n\t\t\t\t\t\t\t\tchunksize = (chunksize << 4) + (chunksize_buf[j] - '0');\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tchunksize = (chunksize << 4) + ((chunksize_buf[j] | 32) - 'a' + 10);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tchunksize_buf[0] = '\\0';\n\t\t\t\t\t\t\tchunksize_buf_index = 0;\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* not finished to get chunksize */\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n#ifdef DEBUG\n\t\t\t\t\t\tprintf(\"chunksize = %u (%x)\\n\", chunksize, chunksize);\n#endif\n\t\t\t\t\t\tif(chunksize == 0)\n\t\t\t\t\t\t{\n#ifdef DEBUG\n\t\t\t\t\t\t\tprintf(\"end of HTTP content - %d %d\\n\", i, n);\n\t\t\t\t\t\t\t/*printf(\"'%.*s'\\n\", n-i, buf+i);*/\n#endif\n\t\t\t\t\t\t\tgoto end_of_stream;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbytestocopy = ((int)chunksize < (n - i))?chunksize:(unsigned int)(n - i);\n\t\t\t\t\tif((content_buf_used + bytestocopy) > content_buf_len)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(content_length >= (int)(content_buf_used + bytestocopy)) {\n\t\t\t\t\t\t\tcontent_buf_len = content_length;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontent_buf_len = content_buf_used + bytestocopy;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontent_buf = (char *)realloc((void *)content_buf,\n\t\t\t\t\t\t                              content_buf_len);\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy(content_buf + content_buf_used, buf + i, bytestocopy);\n\t\t\t\t\tcontent_buf_used += bytestocopy;\n\t\t\t\t\ti += bytestocopy;\n\t\t\t\t\tchunksize -= bytestocopy;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* not chunked */\n\t\t\t\tif(content_length > 0\n\t\t\t\t   && (int)(content_buf_used + n) > content_length) {\n\t\t\t\t\t/* skipping additional bytes */\n\t\t\t\t\tn = content_length - content_buf_used;\n\t\t\t\t}\n\t\t\t\tif(content_buf_used + n > content_buf_len)\n\t\t\t\t{\n\t\t\t\t\tif(content_length >= (int)(content_buf_used + n)) {\n\t\t\t\t\t\tcontent_buf_len = content_length;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontent_buf_len = content_buf_used + n;\n\t\t\t\t\t}\n\t\t\t\t\tcontent_buf = (char *)realloc((void *)content_buf,\n\t\t\t\t\t                              content_buf_len);\n\t\t\t\t}\n\t\t\t\tmemcpy(content_buf + content_buf_used, buf, n);\n\t\t\t\tcontent_buf_used += n;\n\t\t\t}\n\t\t}\n\t\t/* use the Content-Length header value if available */\n\t\tif(content_length > 0 && (int)content_buf_used >= content_length)\n\t\t{\n#ifdef DEBUG\n\t\t\tprintf(\"End of HTTP content\\n\");\n#endif\n\t\t\tbreak;\n\t\t}\n\t}\nend_of_stream:\n\tfree(header_buf); header_buf = NULL;\n\t*size = content_buf_used;\n\tif(content_buf_used == 0)\n\t{\n\t\tfree(content_buf);\n\t\tcontent_buf = NULL;\n\t}\n\treturn content_buf;\n}\n", "target": 1, "idx": 179496}
{"func": "int ocfs2_update_inode_atime(struct inode *inode,\n\t\t\t     struct buffer_head *bh)\n{\n\tint ret;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\thandle_t *handle;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *) bh->b_data;\n\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\t/*\n\t * Don't use ocfs2_mark_inode_dirty() here as we don't always\n\t * have i_mutex to guard against concurrent changes to other\n\t * inode fields.\n\t */\n\tinode->i_atime = current_time(inode);\n\tdi->i_atime = cpu_to_le64(inode->i_atime.tv_sec);\n\tdi->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tocfs2_update_inode_fsync_trans(handle, inode, 0);\n\tocfs2_journal_dirty(handle, bh);\n\nout_commit:\n\tocfs2_commit_trans(OCFS2_SB(inode->i_sb), handle);\nout:\n\treturn ret;\n}\n", "target": 0, "idx": 85822}
{"func": "PageSerializer::PageSerializer(Vector<SerializedResource>* resources, LinkLocalPathMap* urls, String directory)\n     : m_resources(resources)\n    , m_URLs(urls)\n    , m_directory(directory)\n     , m_blankFrameCounter(0)\n {\n }\n", "target": 1, "idx": 185266}
{"func": "static int fm10k_poll(struct napi_struct *napi, int budget)\n{\n\tstruct fm10k_q_vector *q_vector =\n\t\t\t       container_of(napi, struct fm10k_q_vector, napi);\n\tstruct fm10k_ring *ring;\n\tint per_ring_budget, work_done = 0;\n\tbool clean_complete = true;\n\n\tfm10k_for_each_ring(ring, q_vector->tx) {\n\t\tif (!fm10k_clean_tx_irq(q_vector, ring, budget))\n\t\t\tclean_complete = false;\n\t}\n\n\t/* Handle case where we are called by netpoll with a budget of 0 */\n\tif (budget <= 0)\n\t\treturn budget;\n\n\t/* attempt to distribute budget to each queue fairly, but don't\n\t * allow the budget to go below 1 because we'll exit polling\n\t */\n\tif (q_vector->rx.count > 1)\n\t\tper_ring_budget = max(budget / q_vector->rx.count, 1);\n\telse\n\t\tper_ring_budget = budget;\n\n\tfm10k_for_each_ring(ring, q_vector->rx) {\n\t\tint work = fm10k_clean_rx_irq(q_vector, ring, per_ring_budget);\n\n\t\twork_done += work;\n\t\tif (work >= per_ring_budget)\n\t\t\tclean_complete = false;\n\t}\n\n\t/* If all work not completed, return budget and keep polling */\n\tif (!clean_complete)\n\t\treturn budget;\n\n\t/* Exit the polling mode, but don't re-enable interrupts if stack might\n\t * poll us due to busy-polling\n\t */\n\tif (likely(napi_complete_done(napi, work_done)))\n\t\tfm10k_qv_enable(q_vector);\n\n\treturn min(work_done, budget - 1);\n}\n", "target": 0, "idx": 87935}
{"func": " bool IsSystemModal(aura::Window* window) {\n  return window->transient_parent() &&\n      window->GetProperty(aura::client::kModalKey) == ui::MODAL_TYPE_SYSTEM;\n }\n", "target": 1, "idx": 184375}
{"func": "static int opfild(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tif ( op->operands[0].type & OT_WORD ) {\n\t\t\t\tdata[l++] = 0xdf;\n\t\t\t\tdata[l++] = 0x00 | op->operands[0].regs[0];\n\t\t\t} else if ( op->operands[0].type & OT_DWORD ) {\n\t\t\t\tdata[l++] = 0xdb;\n\t\t\t\tdata[l++] = 0x00 | op->operands[0].regs[0];\n\t\t\t} else if ( op->operands[0].type & OT_QWORD ) {\n\t\t\t\tdata[l++] = 0xdf;\n\t\t\t\tdata[l++] = 0x28 | op->operands[0].regs[0];\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n", "target": 0, "idx": 75399}
{"func": "smb_fdata(netdissect_options *ndo,\n          const u_char *buf, const char *fmt, const u_char *maxbuf,\n          int unicodestr)\n{\n    static int depth = 0;\n    char s[128];\n    char *p;\n\n    while (*fmt) {\n\tswitch (*fmt) {\n\tcase '*':\n\t    fmt++;\n \t    while (buf < maxbuf) {\n \t\tconst u_char *buf2;\n \t\tdepth++;\n\t\tbuf2 = smb_fdata(ndo, buf, fmt, maxbuf, unicodestr);\n \t\tdepth--;\n \t\tif (buf2 == NULL)\n \t\t    return(NULL);\n\t\tif (buf2 == buf)\n\t\t    return(buf);\n\t\tbuf = buf2;\n\t    }\n\t    return(buf);\n\n\tcase '|':\n\t    fmt++;\n\t    if (buf >= maxbuf)\n\t\treturn(buf);\n\t    break;\n\n\tcase '%':\n\t    fmt++;\n\t    buf = maxbuf;\n\t    break;\n\n\tcase '#':\n\t    fmt++;\n\t    return(buf);\n\t    break;\n\n\tcase '[':\n\t    fmt++;\n\t    if (buf >= maxbuf)\n\t\treturn(buf);\n\t    memset(s, 0, sizeof(s));\n\t    p = strchr(fmt, ']');\n\t    if ((size_t)(p - fmt + 1) > sizeof(s)) {\n\t\t/* overrun */\n\t\treturn(buf);\n\t    }\n\t    strncpy(s, fmt, p - fmt);\n\t    s[p - fmt] = '\\0';\n\t    fmt = p + 1;\n\t    buf = smb_fdata1(ndo, buf, s, maxbuf, unicodestr);\n\t    if (buf == NULL)\n\t\treturn(NULL);\n\t    break;\n\n\tdefault:\n\t    ND_PRINT((ndo, \"%c\", *fmt));\n\t    fmt++;\n\t    break;\n\t}\n    }\n    if (!depth && buf < maxbuf) {\n\tsize_t len = PTR_DIFF(maxbuf, buf);\n\tND_PRINT((ndo, \"Data: (%lu bytes)\\n\", (unsigned long)len));\n\tsmb_print_data(ndo, buf, len);\n\treturn(buf + len);\n    }\n    return(buf);\n}\n", "target": 1, "idx": 182986}
{"func": "void DraggedTabGtk::AnimateToBounds(const gfx::Rect& bounds,\n                                    AnimateToBoundsCallback* callback) {\n  animation_callback_.reset(callback);\n\n  gint x, y, width, height;\n  gdk_window_get_origin(container_->window, &x, &y);\n  gdk_window_get_geometry(container_->window, NULL, NULL,\n                          &width, &height, NULL);\n\n  animation_start_bounds_ = gfx::Rect(x, y, width, height);\n  animation_end_bounds_ = bounds;\n\n  close_animation_.SetSlideDuration(kAnimateToBoundsDurationMs);\n  close_animation_.SetTweenType(Tween::EASE_OUT);\n  if (!close_animation_.IsShowing()) {\n    close_animation_.Reset();\n    close_animation_.Show();\n  }\n}\n", "target": 0, "idx": 98586}
{"func": "_client_protocol_timeout (GsmXSMPClient *client)\n{\n        g_debug (\"GsmXSMPClient: client_protocol_timeout for client '%s' in ICE status %d\",\n                 client->priv->description,\n                 IceConnectionStatus (client->priv->ice_connection));\n        gsm_client_set_status (GSM_CLIENT (client), GSM_CLIENT_FAILED);\n        gsm_client_disconnected (GSM_CLIENT (client));\n        return FALSE;\n}\n", "target": 1, "idx": 181220}
{"func": "void MemoryInstrumentation::GetVmRegionsForHeapProfiler(\n    RequestGlobalDumpCallback callback) {\n  const auto& coordinator = GetCoordinatorBindingForCurrentThread();\n  coordinator->GetVmRegionsForHeapProfiler(callback);\n}\n", "target": 1, "idx": 186895}
{"func": "authentic_get_serialnr(struct sc_card *card, struct sc_serial_number *serial)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct authentic_private_data *prv_data = (struct authentic_private_data *) card->drv_data;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (!card->serialnr.len)   {\n\t\trv = authentic_get_cplc(card);\n\t\tLOG_TEST_RET(ctx, rv, \"get CPLC data error\");\n\n\t\tcard->serialnr.len = 4;\n\t\tmemcpy(card->serialnr.value, prv_data->cplc.value + 15, 4);\n\n\t\tsc_log(ctx, \"serial %02X%02X%02X%02X\",\n\t\t\t\tcard->serialnr.value[0], card->serialnr.value[1],\n\t\t\t\tcard->serialnr.value[2], card->serialnr.value[3]);\n\t}\n\n\tif (serial)\n\t\tmemcpy(serial, &card->serialnr, sizeof(*serial));\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}\n", "target": 0, "idx": 78188}
{"func": "int imap_subscribe(char *path, bool subscribe)\n{\n  struct ImapData *idata = NULL;\n  char buf[LONG_STRING];\n  char mbox[LONG_STRING];\n   char errstr[STRING];\n   struct Buffer err, token;\n   struct ImapMbox mx;\n \n   if (!mx_is_imap(path) || imap_parse_path(path, &mx) || !mx.mbox)\n   {\n    mutt_error(_(\"Bad mailbox name\"));\n    return -1;\n  }\n  idata = imap_conn_find(&(mx.account), 0);\n  if (!idata)\n    goto fail;\n\n  imap_fix_path(idata, mx.mbox, buf, sizeof(buf));\n  if (!*buf)\n    mutt_str_strfcpy(buf, \"INBOX\", sizeof(buf));\n\n  if (ImapCheckSubscribed)\n  {\n    mutt_buffer_init(&token);\n     mutt_buffer_init(&err);\n     err.data = errstr;\n     err.dsize = sizeof(errstr);\n    snprintf(mbox, sizeof(mbox), \"%smailboxes \\\"%s\\\"\", subscribe ? \"\" : \"un\", path);\n     if (mutt_parse_rc_line(mbox, &token, &err))\n       mutt_debug(1, \"Error adding subscribed mailbox: %s\\n\", errstr);\n     FREE(&token.data);\n  }\n\n  if (subscribe)\n    mutt_message(_(\"Subscribing to %s...\"), buf);\n  else\n    mutt_message(_(\"Unsubscribing from %s...\"), buf);\n  imap_munge_mbox_name(idata, mbox, sizeof(mbox), buf);\n\n  snprintf(buf, sizeof(buf), \"%sSUBSCRIBE %s\", subscribe ? \"\" : \"UN\", mbox);\n\n  if (imap_exec(idata, buf, 0) < 0)\n    goto fail;\n\n  imap_unmunge_mbox_name(idata, mx.mbox);\n  if (subscribe)\n    mutt_message(_(\"Subscribed to %s\"), mx.mbox);\n  else\n    mutt_message(_(\"Unsubscribed from %s\"), mx.mbox);\n  FREE(&mx.mbox);\n  return 0;\n\nfail:\n  FREE(&mx.mbox);\n  return -1;\n}\n", "target": 1, "idx": 182309}
{"func": "static Resource* createResource(Resource::Type type, const ResourceRequest& request, const String& charset)\n{\n    switch (type) {\n    case Resource::Image:\n        return new ImageResource(request);\n    case Resource::CSSStyleSheet:\n        return new CSSStyleSheetResource(request, charset);\n    case Resource::Script:\n        return new ScriptResource(request, charset);\n    case Resource::SVGDocument:\n        return new DocumentResource(request, Resource::SVGDocument);\n    case Resource::Font:\n        return new FontResource(request);\n    case Resource::MainResource:\n    case Resource::Raw:\n    case Resource::TextTrack:\n    case Resource::Media:\n        return new RawResource(request, type);\n    case Resource::XSLStyleSheet:\n        return new XSLStyleSheetResource(request, charset);\n    case Resource::LinkPrefetch:\n        return new Resource(request, Resource::LinkPrefetch);\n    case Resource::LinkSubresource:\n        return new Resource(request, Resource::LinkSubresource);\n    case Resource::ImportResource:\n        return new RawResource(request, type);\n    }\n\n    ASSERT_NOT_REACHED();\n    return 0;\n}\n", "target": 0, "idx": 129685}
{"func": "SpoolssRFFPCNEX_q(tvbuff_t *tvb, int offset,\n\t\t\t     packet_info *pinfo, proto_tree *tree,\n\t\t\t     dcerpc_info *di, guint8 *drep _U_)\n{\n\tguint32 flags;\n\tstatic const int * hf_flags[] = {\n\t\t&hf_rffpcnex_flags_timeout,\n\t\t&hf_rffpcnex_flags_delete_driver,\n\t\t&hf_rffpcnex_flags_set_driver,\n\t\t&hf_rffpcnex_flags_add_driver,\n\t\t&hf_rffpcnex_flags_delete_print_processor,\n\t\t&hf_rffpcnex_flags_add_print_processor,\n\t\t&hf_rffpcnex_flags_delete_port,\n\t\t&hf_rffpcnex_flags_configure_port,\n\t\t&hf_rffpcnex_flags_add_port,\n\t\t&hf_rffpcnex_flags_delete_form,\n\t\t&hf_rffpcnex_flags_set_form,\n\t\t&hf_rffpcnex_flags_add_form,\n\t\t&hf_rffpcnex_flags_write_job,\n\t\t&hf_rffpcnex_flags_delete_job,\n\t\t&hf_rffpcnex_flags_set_job,\n\t\t&hf_rffpcnex_flags_add_job,\n\t\t&hf_rffpcnex_flags_failed_printer_connection,\n\t\t&hf_rffpcnex_flags_delete_printer,\n\t\t&hf_rffpcnex_flags_set_printer,\n\t\t&hf_rffpcnex_flags_add_printer,\n\t\tNULL\n\t};\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tFALSE, FALSE);\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, NULL, di, drep, -1, &flags);\n\n\tproto_tree_add_bitmask_value(tree, tvb, offset - 4, hf_rffpcnex_flags,\n\t\t\t\t\tett_rffpcnex_flags, hf_flags, flags);\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\n\t\t\t\t    hf_rffpcnex_options, NULL);\n\n\toffset = dissect_ndr_str_pointer_item(\n\t\ttvb, offset, pinfo, tree, di, drep, NDR_POINTER_UNIQUE,\n\t\t\"Server\", hf_servername, 0);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_printerlocal, NULL);\n\n\toffset = dissect_ndr_pointer(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\tdissect_NOTIFY_OPTIONS_ARRAY_CTR, NDR_POINTER_UNIQUE,\n\t\t\"Notify Options Container\", -1);\n\n\treturn offset;\n}\n", "target": 0, "idx": 51972}
{"func": "bool JSArray::increaseVectorPrefixLength(unsigned newLength)\n{\n    \n    ArrayStorage* storage = m_storage;\n    \n    unsigned vectorLength = m_vectorLength;\n    ASSERT(newLength > vectorLength);\n    ASSERT(newLength <= MAX_STORAGE_VECTOR_INDEX);\n    unsigned newVectorLength = getNewVectorLength(newLength);\n\n    void* newBaseStorage = fastMalloc(storageSize(newVectorLength + m_indexBias));\n    if (!newBaseStorage)\n        return false;\n    \n    m_indexBias += newVectorLength - newLength;\n    \n    m_storage = reinterpret_cast_ptr<ArrayStorage*>(static_cast<char*>(newBaseStorage) + m_indexBias * sizeof(JSValue));\n\n    memcpy(m_storage, storage, storageSize(0));\n    memcpy(&m_storage->m_vector[newLength - m_vectorLength], &storage->m_vector[0], vectorLength * sizeof(JSValue));\n    \n    m_storage->m_allocBase = newBaseStorage;\n     m_vectorLength = newLength;\n     \n     fastFree(storage->m_allocBase);\n     Heap::heap(this)->reportExtraMemoryCost(storageSize(newVectorLength) - storageSize(vectorLength));\n     \n     return true;\n}\n", "target": 1, "idx": 184134}
{"func": " Response StorageHandler::TrackIndexedDBForOrigin(const std::string& origin) {\n  if (!process_)\n     return Response::InternalError();\n \n   GURL origin_url(origin);\n  if (!origin_url.is_valid())\n    return Response::InvalidParams(origin + \" is not a valid URL\");\n\n  GetIndexedDBObserver()->TaskRunner()->PostTask(\n      FROM_HERE, base::BindOnce(&IndexedDBObserver::TrackOriginOnIDBThread,\n                                base::Unretained(GetIndexedDBObserver()),\n                                url::Origin::Create(origin_url)));\n  return Response::OK();\n }\n", "target": 1, "idx": 186754}
{"func": "png_have_neon(png_structp png_ptr)\n{\n FILE *f = fopen(\"/proc/cpuinfo\", \"rb\");\n\n if (f != NULL)\n {\n /* This is a simple state machine which reads the input byte-by-byte until\n       * it gets a match on the 'neon' feature or reaches the end of the stream.\n       */\n static const char ch_feature[] = { 70, 69, 65, 84, 85, 82, 69, 83 };\n static const char ch_neon[] = { 78, 69, 79, 78 };\n\n enum\n {\n StartLine, Feature, Colon, StartTag, Neon, HaveNeon, SkipTag, SkipLine\n }  state;\n int counter;\n\n for (state=StartLine, counter=0;;)\n {\n int ch = fgetc(f);\n\n if (ch == EOF)\n {\n /* EOF means error or end-of-file, return false; neon at EOF is\n             * assumed to be a mistake.\n             */\n            fclose(f);\n return 0;\n }\n\n switch (state)\n {\n case StartLine:\n /* Match spaces at the start of line */\n if (ch <= 32) /* skip control characters and space */\n break;\n\n               counter=0;\n               state = Feature;\n /* FALL THROUGH */\n\n case Feature:\n /* Match 'FEATURE', ASCII case insensitive. */\n if ((ch & ~0x20) == ch_feature[counter])\n {\n if (++counter == (sizeof ch_feature))\n\n                      state = Colon;\n                   break;\n                }\n                /* did not match 'feature' */\n                state = SkipLine;\n                /* FALL THROUGH */\n\n case SkipLine:\n            skipLine:\n /* Skip everything until we see linefeed or carriage return */\n if (ch != 10 && ch != 13)\n break;\n\n               state = StartLine;\n break;\n\n case Colon:\n /* Match any number of space or tab followed by ':' */\n if (ch == 32 || ch == 9)\n break;\n\n if (ch == 58) /* i.e. ':' */\n {\n                  state = StartTag;\n break;\n }\n\n /* Either a bad line format or a 'feature' prefix followed by\n                * other characters.\n                */\n               state = SkipLine;\n goto skipLine;\n\n case StartTag:\n /* Skip space characters before a tag */\n if (ch == 32 || ch == 9)\n break;\n\n               state = Neon;\n               counter = 0;\n /* FALL THROUGH */\n\n case Neon:\n /* Look for 'neon' tag */\n if ((ch & ~0x20) == ch_neon[counter])\n {\n if (++counter == (sizeof ch_neon))\n                     state = HaveNeon;\n break;\n }\n\n               state = SkipTag;\n /* FALL THROUGH */\n\n case SkipTag:\n /* Skip non-space characters */\n if (ch == 10 || ch == 13)\n                  state = StartLine;\n\n else if (ch == 32 || ch == 9)\n                  state = StartTag;\n break;\n\n case HaveNeon:\n /* Have seen a 'neon' prefix, but there must be a space or new\n                * line character to terminate it.\n                */\n if (ch == 10 || ch == 13 || ch == 32 || ch == 9)\n {\n                  fclose(f);\n return 1;\n }\n\n               state = SkipTag;\n break;\n\n default:\n               png_error(png_ptr, \"png_have_neon: internal error (bug)\");\n }\n\n       }\n    }\n \n    else\n       png_warning(png_ptr, \"/proc/cpuinfo open failed\");\n \n    return 0;\n }\n", "target": 1, "idx": 187587}
{"func": "static int crypto_rfc4106_setkey(struct crypto_aead *parent, const u8 *key,\n\t\t\t\t unsigned int keylen)\n{\n\tstruct crypto_rfc4106_ctx *ctx = crypto_aead_ctx(parent);\n\tstruct crypto_aead *child = ctx->child;\n\tint err;\n\n\tif (keylen < 4)\n\t\treturn -EINVAL;\n\n\tkeylen -= 4;\n\tmemcpy(ctx->nonce, key + keylen, 4);\n\n\tcrypto_aead_clear_flags(child, CRYPTO_TFM_REQ_MASK);\n\tcrypto_aead_set_flags(child, crypto_aead_get_flags(parent) &\n\t\t\t\t     CRYPTO_TFM_REQ_MASK);\n\terr = crypto_aead_setkey(child, key, keylen);\n\tcrypto_aead_set_flags(parent, crypto_aead_get_flags(child) &\n\t\t\t\t      CRYPTO_TFM_RES_MASK);\n\n\treturn err;\n}\n", "target": 0, "idx": 45754}
{"func": " SPL_METHOD(SplFileObject, rewind)\n {\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n\n\tspl_filesystem_file_rewind(getThis(), intern TSRMLS_CC);\n} /* }}} */\n\n/* {{{ proto void SplFileObject::eof()\n", "target": 1, "idx": 180223}
{"func": "sysapi_translate_arch( const char *machine, const char *)\n{\n\tchar tmp[64];\n\tchar *tmparch;\n\n#if defined(AIX)\n\t/* AIX machines have a ton of different models encoded into the uname\n\t\tstructure, so go to some other function to decode and group the\n\t\tarchitecture together */\n\tstruct utsname buf;\n\n\tif( uname(&buf) < 0 ) {\n\t\treturn NULL;\n\t}\n\n\treturn( get_aix_arch( &buf ) );\n\n#elif defined(HPUX)\n\n\treturn( get_hpux_arch( ) );\n#else\n\n\tif( !strcmp(machine, \"alpha\") ) {\n\t\tsprintf( tmp, \"ALPHA\" );\n\t}\n\telse if( !strcmp(machine, \"i86pc\") ) {\n\t\tsprintf( tmp, \"INTEL\" );\n\t}\n\telse if( !strcmp(machine, \"i686\") ) {\n\t\tsprintf( tmp, \"INTEL\" );\n\t}\n\telse if( !strcmp(machine, \"i586\") ) {\n\t\tsprintf( tmp, \"INTEL\" );\n\t}\n\telse if( !strcmp(machine, \"i486\") ) {\n\t\tsprintf( tmp, \"INTEL\" );\n\t}\n\telse if( !strcmp(machine, \"i386\") ) { //LDAP entry\n#if defined(Darwin)\n\t\t/* Mac OS X often claims to be i386 in uname, even if the\n\t\t * hardware is x86_64 and the OS can run 64-bit binaries.\n\t\t * We'll base our architecture name on the default build\n\t\t * target for gcc. In 10.5 and earlier, that's i386.\n\t\t * On 10.6, it's x86_64.\n\t\t * The value we're querying is the kernel version.\n\t\t * 10.6 kernels have a version that starts with \"10.\"\n\t\t * Older versions have a lower first number.\n\t\t */\n\t\tint ret;\n\t\tchar val[32];\n\t\tsize_t len = sizeof(val);\n\n\t\t/* assume x86 */\n\t\tsprintf( tmp, \"INTEL\" );\n\t\tret = sysctlbyname(\"kern.osrelease\", &val, &len, NULL, 0);\n\t\tif (ret == 0 && strncmp(val, \"10.\", 3) == 0) {\n\t\t\t/* but we could be proven wrong */\n\t\t\tsprintf( tmp, \"X86_64\" );\n\t\t}\n#else\n\t\tsprintf( tmp, \"INTEL\" );\n#endif\n\t}\n\telse if( !strcmp(machine, \"ia64\") ) {\n\t\tsprintf( tmp, \"IA64\" );\n\t}\n\telse if( !strcmp(machine, \"x86_64\") ) {\n\t\tsprintf( tmp, \"X86_64\" );\n\t}\n\telse if( !strcmp(machine, \"amd64\") ) {\n\t\tsprintf( tmp, \"X86_64\" );\n\t}\n\telse if( !strcmp(machine, \"sun4u\") ) {\n\t\tsprintf( tmp, \"SUN4u\" );\n\t}\n\telse if( !strcmp(machine, \"sun4m\") ) {\n\t\tsprintf( tmp, \"SUN4x\" );\n\t}\n\telse if( !strcmp(machine, \"sun4c\") ) {\n\t\tsprintf( tmp, \"SUN4x\" );\n\t}\n\telse if( !strcmp(machine, \"sparc\") ) { //LDAP entry\n\t\tsprintf( tmp, \"SUN4x\" );\n\t}\n\telse if( !strcmp(machine, \"Power Macintosh\") ) { //LDAP entry\n\t\tsprintf( tmp, \"PPC\" );\n\t}\n\telse if( !strcmp(machine, \"ppc\") ) {\n\t\tsprintf( tmp, \"PPC\" );\n\t}\n\telse if( !strcmp(machine, \"ppc32\") ) {\n\t\tsprintf( tmp, \"PPC\" );\n\t}\n\telse if( !strcmp(machine, \"ppc64\") ) {\n\t\tsprintf( tmp, \"PPC64\" );\n        }\n        else {\n               sprintf( tmp, machine );\n        }\n \n        tmparch = strdup( tmp );\n\tif( !tmparch ) {\n\t\tEXCEPT( \"Out of memory!\" );\n\t}\n\treturn( tmparch );\n#endif /* if HPUX else */\n}\n", "target": 1, "idx": 178552}
{"func": "static void print_disabled(struct seq_file *m)\n{\n\tseq_puts(m, \"#\\n\"\n\t\t \"#  Stack tracer disabled\\n\"\n\t\t \"#\\n\"\n\t\t \"# To enable the stack tracer, either add 'stacktrace' to the\\n\"\n\t\t \"# kernel command line\\n\"\n\t\t \"# or 'echo 1 > /proc/sys/kernel/stack_tracer_enabled'\\n\"\n\t\t \"#\\n\");\n}\n", "target": 0, "idx": 30297}
{"func": "static int ipv6_generate_eui64(u8 *eui, struct net_device *dev)\n{\n\tswitch (dev->type) {\n\tcase ARPHRD_ETHER:\n\tcase ARPHRD_FDDI:\n\t\treturn addrconf_ifid_eui48(eui, dev);\n\tcase ARPHRD_ARCNET:\n\t\treturn addrconf_ifid_arcnet(eui, dev);\n\tcase ARPHRD_INFINIBAND:\n\t\treturn addrconf_ifid_infiniband(eui, dev);\n\tcase ARPHRD_SIT:\n\t\treturn addrconf_ifid_sit(eui, dev);\n\tcase ARPHRD_IPGRE:\n\t\treturn addrconf_ifid_gre(eui, dev);\n\tcase ARPHRD_6LOWPAN:\n\tcase ARPHRD_IEEE802154:\n\t\treturn addrconf_ifid_eui64(eui, dev);\n\tcase ARPHRD_IEEE1394:\n\t\treturn addrconf_ifid_ieee1394(eui, dev);\n\tcase ARPHRD_TUNNEL6:\n\t\treturn addrconf_ifid_ip6tnl(eui, dev);\n\t}\n\treturn -1;\n}\n", "target": 0, "idx": 41871}
{"func": " static long perf_compat_ioctl(struct file *file, unsigned int cmd,\n \t\t\t\tunsigned long arg)\n{\n\tswitch (_IOC_NR(cmd)) {\n\tcase _IOC_NR(PERF_EVENT_IOC_SET_FILTER):\n\tcase _IOC_NR(PERF_EVENT_IOC_ID):\n\t\t/* Fix up pointer size (usually 4 -> 8 in 32-on-64-bit case */\n\t\tif (_IOC_SIZE(cmd) == sizeof(compat_uptr_t)) {\n\t\t\tcmd &= ~IOCSIZE_MASK;\n\t\t\tcmd |= sizeof(void *) << IOCSIZE_SHIFT;\n\t\t}\n\t\tbreak;\n\t}\n\treturn perf_ioctl(file, cmd, arg);\n}\n", "target": 0, "idx": 50456}
{"func": " static void __exit xfrm6_tunnel_fini(void)\n {\n\tunregister_pernet_subsys(&xfrm6_tunnel_net_ops);\n\txfrm6_tunnel_spi_fini();\n \txfrm6_tunnel_deregister(&xfrm46_tunnel_handler, AF_INET);\n \txfrm6_tunnel_deregister(&xfrm6_tunnel_handler, AF_INET6);\n \txfrm_unregister_type(&xfrm6_tunnel_type, AF_INET6);\n }\n", "target": 1, "idx": 179051}
{"func": "int ssl3_get_client_hello(SSL *s)\n\t{\n\tint i,j,ok,al=SSL_AD_INTERNAL_ERROR,ret= -1;\n\tunsigned int cookie_len;\n\tlong n;\n\tunsigned long id;\n\tunsigned char *p,*d;\n\tSSL_CIPHER *c;\n#ifndef OPENSSL_NO_COMP\n\tunsigned char *q;\n\tSSL_COMP *comp=NULL;\n#endif\n\tSTACK_OF(SSL_CIPHER) *ciphers=NULL;\n\n\tif (s->state == SSL3_ST_SR_CLNT_HELLO_C && !s->first_packet)\n\t\tgoto retry_cert;\n\n\t/* We do this so that we will respond with our native type.\n\t * If we are TLSv1 and we get SSLv3, we will respond with TLSv1,\n\t * This down switching should be handled by a different method.\n\t * If we are SSLv3, we will respond with SSLv3, even if prompted with\n\t * TLSv1.\n\t */\n\tif (s->state == SSL3_ST_SR_CLNT_HELLO_A\n\t\t)\n\t\t{\n\t\ts->state=SSL3_ST_SR_CLNT_HELLO_B;\n\t\t}\n\ts->first_packet=1;\n\tn=s->method->ssl_get_message(s,\n\t\tSSL3_ST_SR_CLNT_HELLO_B,\n\t\tSSL3_ST_SR_CLNT_HELLO_C,\n\t\tSSL3_MT_CLIENT_HELLO,\n\t\tSSL3_RT_MAX_PLAIN_LENGTH,\n\t\t&ok);\n\n\tif (!ok) return((int)n);\n\ts->first_packet=0;\n\td=p=(unsigned char *)s->init_msg;\n\n\t/* use version from inside client hello, not from record header\n\t * (may differ: see RFC 2246, Appendix E, second paragraph) */\n\ts->client_version=(((int)p[0])<<8)|(int)p[1];\n\tp+=2;\n\n\tif (SSL_IS_DTLS(s)  ?\t(s->client_version > s->version &&\n\t\t\t\t s->method->version != DTLS_ANY_VERSION)\n\t\t\t    :\t(s->client_version < s->version))\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_WRONG_VERSION_NUMBER);\n\t\tif ((s->client_version>>8) == SSL3_VERSION_MAJOR &&\n\t\t\t!s->enc_write_ctx && !s->write_hash)\n\t\t\t{\n\t\t\t/* similar to ssl3_get_record, send alert using remote version number */\n\t\t\ts->version = s->client_version;\n\t\t\t}\n\t\tal = SSL_AD_PROTOCOL_VERSION;\n\t\tgoto f_err;\n\t\t}\n\n\t/* If we require cookies and this ClientHello doesn't\n\t * contain one, just return since we do not want to\n\t * allocate any memory yet. So check cookie length...\n\t */\n\tif (SSL_get_options(s) & SSL_OP_COOKIE_EXCHANGE)\n\t\t{\n\t\tunsigned int session_length, cookie_length;\n\t\t\n\t\tsession_length = *(p + SSL3_RANDOM_SIZE);\n\t\tcookie_length = *(p + SSL3_RANDOM_SIZE + session_length + 1);\n\n\t\tif (cookie_length == 0)\n\t\t\treturn 1;\n\t\t}\n\n\t/* load the client random */\n\tmemcpy(s->s3->client_random,p,SSL3_RANDOM_SIZE);\n\tp+=SSL3_RANDOM_SIZE;\n\n\t/* get the session-id */\n\tj= *(p++);\n\n\ts->hit=0;\n\t/* Versions before 0.9.7 always allow clients to resume sessions in renegotiation.\n\t * 0.9.7 and later allow this by default, but optionally ignore resumption requests\n\t * with flag SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION (it's a new flag rather\n\t * than a change to default behavior so that applications relying on this for security\n\t * won't even compile against older library versions).\n\t *\n\t * 1.0.1 and later also have a function SSL_renegotiate_abbreviated() to request\n\t * renegotiation but not a new session (s->new_session remains unset): for servers,\n\t * this essentially just means that the SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION\n\t * setting will be ignored.\n\t */\n\tif ((s->new_session && (s->options & SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION)))\n\t\t{\n\t\tif (!ssl_get_new_session(s,1))\n\t\t\tgoto err;\n\t\t}\n\telse\n\t\t{\n\t\ti=ssl_get_prev_session(s, p, j, d + n);\n\t\t/*\n\t\t * Only resume if the session's version matches the negotiated\n\t\t * version.\n\t\t * RFC 5246 does not provide much useful advice on resumption\n\t\t * with a different protocol version. It doesn't forbid it but\n\t\t * the sanity of such behaviour would be questionable.\n\t\t * In practice, clients do not accept a version mismatch and\n\t\t * will abort the handshake with an error.\n\t\t */\n\t\tif (i == 1 && s->version == s->session->ssl_version)\n\t\t\t{ /* previous session */\n\t\t\ts->hit=1;\n\t\t\t}\n\t\telse if (i == -1)\n\t\t\tgoto err;\n\t\telse /* i == 0 */\n\t\t\t{\n\t\t\tif (!ssl_get_new_session(s,1))\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\n\tp+=j;\n\n\tif (SSL_IS_DTLS(s))\n\t\t{\n\t\t/* cookie stuff */\n\t\tcookie_len = *(p++);\n\n\t\t/* \n\t\t * The ClientHello may contain a cookie even if the\n\t\t * HelloVerify message has not been sent--make sure that it\n\t\t * does not cause an overflow.\n\t\t */\n\t\tif ( cookie_len > sizeof(s->d1->rcvd_cookie))\n\t\t\t{\n\t\t\t/* too much data */\n\t\t\tal = SSL_AD_DECODE_ERROR;\n\t\t\tSSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_COOKIE_MISMATCH);\n\t\t\tgoto f_err;\n\t\t\t}\n\n\t\t/* verify the cookie if appropriate option is set. */\n\t\tif ((SSL_get_options(s) & SSL_OP_COOKIE_EXCHANGE) &&\n\t\t\tcookie_len > 0)\n\t\t\t{\n\t\t\tmemcpy(s->d1->rcvd_cookie, p, cookie_len);\n\n\t\t\tif ( s->ctx->app_verify_cookie_cb != NULL)\n\t\t\t\t{\n\t\t\t\tif ( s->ctx->app_verify_cookie_cb(s, s->d1->rcvd_cookie,\n\t\t\t\t\tcookie_len) == 0)\n\t\t\t\t\t{\n\t\t\t\t\tal=SSL_AD_HANDSHAKE_FAILURE;\n\t\t\t\t\tSSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, \n\t\t\t\t\t\tSSL_R_COOKIE_MISMATCH);\n\t\t\t\t\tgoto f_err;\n\t\t\t\t\t}\n\t\t\t\t/* else cookie verification succeeded */\n\t\t\t\t}\n\t\t\telse if ( memcmp(s->d1->rcvd_cookie, s->d1->cookie, \n\t\t\t\t\t\t  s->d1->cookie_len) != 0) /* default verification */\n\t\t\t\t{\n\t\t\t\t\tal=SSL_AD_HANDSHAKE_FAILURE;\n\t\t\t\t\tSSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, \n\t\t\t\t\t\tSSL_R_COOKIE_MISMATCH);\n\t\t\t\t\tgoto f_err;\n\t\t\t\t}\n\t\t\t/* Set to -2 so if successful we return 2 */\n\t\t\tret = -2;\n\t\t\t}\n\n\t\tp += cookie_len;\n\t\tif (s->method->version == DTLS_ANY_VERSION)\n\t\t\t{\n\t\t\t/* Select version to use */\n\t\t\tif (s->client_version <= DTLS1_2_VERSION &&\n\t\t\t\t!(s->options & SSL_OP_NO_DTLSv1_2))\n\t\t\t\t{\n\t\t\t\ts->version = DTLS1_2_VERSION;\n\t\t\t\ts->method = DTLSv1_2_server_method();\n\t\t\t\t}\n\t\t\telse if (tls1_suiteb(s))\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_ONLY_DTLS_1_2_ALLOWED_IN_SUITEB_MODE);\n\t\t\t\ts->version = s->client_version;\n\t\t\t\tal = SSL_AD_PROTOCOL_VERSION;\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n\t\t\telse if (s->client_version <= DTLS1_VERSION &&\n\t\t\t\t!(s->options & SSL_OP_NO_DTLSv1))\n\t\t\t\t{\n\t\t\t\ts->version = DTLS1_VERSION;\n\t\t\t\ts->method = DTLSv1_server_method();\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_WRONG_VERSION_NUMBER);\n\t\t\t\ts->version = s->client_version;\n\t\t\t\tal = SSL_AD_PROTOCOL_VERSION;\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n\t\t\ts->session->ssl_version = s->version;\n\t\t\t}\n\t\t}\n\n\tn2s(p,i);\n\tif ((i == 0) && (j != 0))\n\t\t{\n\t\t/* we need a cipher if we are not resuming a session */\n\t\tal=SSL_AD_ILLEGAL_PARAMETER;\n\t\tSSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_NO_CIPHERS_SPECIFIED);\n\t\tgoto f_err;\n\t\t}\n\tif ((p+i) >= (d+n))\n\t\t{\n\t\t/* not enough data */\n\t\tal=SSL_AD_DECODE_ERROR;\n\t\tSSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_LENGTH_MISMATCH);\n\t\tgoto f_err;\n\t\t}\n\tif ((i > 0) && (ssl_bytes_to_cipher_list(s,p,i,&(ciphers))\n\t\t== NULL))\n\t\t{\n\t\tgoto err;\n\t\t}\n\tp+=i;\n\n\t/* If it is a hit, check that the cipher is in the list */\n\tif ((s->hit) && (i > 0))\n\t\t{\n\t\tj=0;\n\t\tid=s->session->cipher->id;\n\n#ifdef CIPHER_DEBUG\n\t\tfprintf(stderr,\"client sent %d ciphers\\n\",sk_SSL_CIPHER_num(ciphers));\n#endif\n\t\tfor (i=0; i<sk_SSL_CIPHER_num(ciphers); i++)\n\t\t\t{\n\t\t\tc=sk_SSL_CIPHER_value(ciphers,i);\n#ifdef CIPHER_DEBUG\n\t\t\tfprintf(stderr,\"client [%2d of %2d]:%s\\n\",\n\t\t\t\ti,sk_SSL_CIPHER_num(ciphers),\n\t\t\t\tSSL_CIPHER_get_name(c));\n#endif\n\t\t\tif (c->id == id)\n\t\t\t\t{\n\t\t\t\tj=1;\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n/* Disabled because it can be used in a ciphersuite downgrade\n * attack: CVE-2010-4180.\n */\n#if 0\n\t\tif (j == 0 && (s->options & SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG) && (sk_SSL_CIPHER_num(ciphers) == 1))\n\t\t\t{\n\t\t\t/* Special case as client bug workaround: the previously used cipher may\n\t\t\t * not be in the current list, the client instead might be trying to\n\t\t\t * continue using a cipher that before wasn't chosen due to server\n\t\t\t * preferences.  We'll have to reject the connection if the cipher is not\n\t\t\t * enabled, though. */\n\t\t\tc = sk_SSL_CIPHER_value(ciphers, 0);\n\t\t\tif (sk_SSL_CIPHER_find(SSL_get_ciphers(s), c) >= 0)\n\t\t\t\t{\n\t\t\t\ts->session->cipher = c;\n\t\t\t\tj = 1;\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\tif (j == 0)\n\t\t\t{\n\t\t\t/* we need to have the cipher in the cipher\n\t\t\t * list if we are asked to reuse it */\n\t\t\tal=SSL_AD_ILLEGAL_PARAMETER;\n\t\t\tSSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_REQUIRED_CIPHER_MISSING);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t}\n\n\t/* compression */\n\ti= *(p++);\n\tif ((p+i) > (d+n))\n\t\t{\n\t\t/* not enough data */\n\t\tal=SSL_AD_DECODE_ERROR;\n\t\tSSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_LENGTH_MISMATCH);\n\t\tgoto f_err;\n\t\t}\n#ifndef OPENSSL_NO_COMP\n\tq=p;\n#endif\n\tfor (j=0; j<i; j++)\n\t\t{\n\t\tif (p[j] == 0) break;\n\t\t}\n\n\tp+=i;\n\tif (j >= i)\n\t\t{\n\t\t/* no compress */\n\t\tal=SSL_AD_DECODE_ERROR;\n\t\tSSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_NO_COMPRESSION_SPECIFIED);\n\t\tgoto f_err;\n\t\t}\n\n#ifndef OPENSSL_NO_TLSEXT\n\t/* TLS extensions*/\n\tif (s->version >= SSL3_VERSION)\n\t\t{\n\t\tif (!ssl_parse_clienthello_tlsext(s,&p,d,n))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_PARSE_TLSEXT);\n\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\n\t/* Check if we want to use external pre-shared secret for this\n\t * handshake for not reused session only. We need to generate\n\t * server_random before calling tls_session_secret_cb in order to allow\n\t * SessionTicket processing to use it in key derivation. */\n\t{\n\t\tunsigned char *pos;\n\t\tpos=s->s3->server_random;\n\t\tif (ssl_fill_hello_random(s, 1, pos, SSL3_RANDOM_SIZE) <= 0)\n\t\t\t{\n\t\t\tgoto f_err;\n\t\t\t}\n\t}\n\n\tif (!s->hit && s->version >= TLS1_VERSION && s->tls_session_secret_cb)\n\t\t{\n\t\tSSL_CIPHER *pref_cipher=NULL;\n\n\t\ts->session->master_key_length=sizeof(s->session->master_key);\n\t\tif(s->tls_session_secret_cb(s, s->session->master_key, &s->session->master_key_length,\n\t\t\tciphers, &pref_cipher, s->tls_session_secret_cb_arg))\n\t\t\t{\n\t\t\ts->hit=1;\n\t\t\ts->session->ciphers=ciphers;\n\t\t\ts->session->verify_result=X509_V_OK;\n\n\t\t\tciphers=NULL;\n\n\t\t\t/* check if some cipher was preferred by call back */\n\t\t\tpref_cipher=pref_cipher ? pref_cipher : ssl3_choose_cipher(s, s->session->ciphers, SSL_get_ciphers(s));\n\t\t\tif (pref_cipher == NULL)\n\t\t\t\t{\n\t\t\t\tal=SSL_AD_HANDSHAKE_FAILURE;\n\t\t\t\tSSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_NO_SHARED_CIPHER);\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n\n\t\t\ts->session->cipher=pref_cipher;\n\n\t\t\tif (s->cipher_list)\n\t\t\t\tsk_SSL_CIPHER_free(s->cipher_list);\n\n\t\t\tif (s->cipher_list_by_id)\n\t\t\t\tsk_SSL_CIPHER_free(s->cipher_list_by_id);\n\n\t\t\ts->cipher_list = sk_SSL_CIPHER_dup(s->session->ciphers);\n\t\t\ts->cipher_list_by_id = sk_SSL_CIPHER_dup(s->session->ciphers);\n\t\t\t}\n\t\t}\n#endif\n\n\t/* Worst case, we will use the NULL compression, but if we have other\n\t * options, we will now look for them.  We have i-1 compression\n\t * algorithms from the client, starting at q. */\n\ts->s3->tmp.new_compression=NULL;\n#ifndef OPENSSL_NO_COMP\n\t/* This only happens if we have a cache hit */\n\tif (s->session->compress_meth != 0)\n\t\t{\n\t\tint m, comp_id = s->session->compress_meth;\n\t\t/* Perform sanity checks on resumed compression algorithm */\n\t\t/* Can't disable compression */\n\t\tif (!ssl_allow_compression(s))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_INCONSISTENT_COMPRESSION);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t/* Look for resumed compression method */\n\t\tfor (m = 0; m < sk_SSL_COMP_num(s->ctx->comp_methods); m++)\n\t\t\t{\n\t\t\tcomp=sk_SSL_COMP_value(s->ctx->comp_methods,m);\n\t\t\tif (comp_id == comp->id)\n\t\t\t\t{\n\t\t\t\ts->s3->tmp.new_compression=comp;\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\tif (s->s3->tmp.new_compression == NULL)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_INVALID_COMPRESSION_ALGORITHM);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t/* Look for resumed method in compression list */\n\t\tfor (m = 0; m < i; m++)\n\t\t\t{\n\t\t\tif (q[m] == comp_id)\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (m >= i)\n\t\t\t{\n\t\t\tal=SSL_AD_ILLEGAL_PARAMETER;\n\t\t\tSSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_REQUIRED_COMPRESSSION_ALGORITHM_MISSING);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t}\n\telse if (s->hit)\n\t\tcomp = NULL;\n\telse if (ssl_allow_compression(s) && s->ctx->comp_methods)\n\t\t{ /* See if we have a match */\n\t\tint m,nn,o,v,done=0;\n\n\t\tnn=sk_SSL_COMP_num(s->ctx->comp_methods);\n\t\tfor (m=0; m<nn; m++)\n\t\t\t{\n\t\t\tcomp=sk_SSL_COMP_value(s->ctx->comp_methods,m);\n\t\t\tv=comp->id;\n\t\t\tfor (o=0; o<i; o++)\n\t\t\t\t{\n\t\t\t\tif (v == q[o])\n\t\t\t\t\t{\n\t\t\t\t\tdone=1;\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tif (done) break;\n\t\t\t}\n\t\tif (done)\n\t\t\ts->s3->tmp.new_compression=comp;\n\t\telse\n\t\t\tcomp=NULL;\n\t\t}\n#else\n\t/* If compression is disabled we'd better not try to resume a session\n\t * using compression.\n\t */\n\tif (s->session->compress_meth != 0)\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_INCONSISTENT_COMPRESSION);\n\t\tgoto f_err;\n\t\t}\n#endif\n\n\t/* Given s->session->ciphers and SSL_get_ciphers, we must\n\t * pick a cipher */\n\n\tif (!s->hit)\n\t\t{\n#ifdef OPENSSL_NO_COMP\n\t\ts->session->compress_meth=0;\n#else\n\t\ts->session->compress_meth=(comp == NULL)?0:comp->id;\n#endif\n\t\tif (s->session->ciphers != NULL)\n\t\t\tsk_SSL_CIPHER_free(s->session->ciphers);\n\t\ts->session->ciphers=ciphers;\n\t\tif (ciphers == NULL)\n\t\t\t{\n\t\t\tal=SSL_AD_ILLEGAL_PARAMETER;\n\t\t\tSSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_NO_CIPHERS_PASSED);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tciphers=NULL;\n\t\tif (!tls1_set_server_sigalgs(s))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_CLIENTHELLO_TLSEXT);\n\t\t\tgoto err;\n\t\t\t}\n\t\t/* Let cert callback update server certificates if required */\n\t\tretry_cert:\t\t\n\t\tif (s->cert->cert_cb)\n\t\t\t{\n\t\t\tint rv = s->cert->cert_cb(s, s->cert->cert_cb_arg);\n\t\t\tif (rv == 0)\n\t\t\t\t{\n\t\t\t\tal=SSL_AD_INTERNAL_ERROR;\n\t\t\t\tSSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_CERT_CB_ERROR);\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n\t\t\tif (rv < 0)\n\t\t\t\t{\n\t\t\t\ts->rwstate=SSL_X509_LOOKUP;\n\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\ts->rwstate = SSL_NOTHING;\n\t\t\t}\n\t\tc=ssl3_choose_cipher(s,s->session->ciphers,\n\t\t\t\t     SSL_get_ciphers(s));\n\n\t\tif (c == NULL)\n\t\t\t{\n\t\t\tal=SSL_AD_HANDSHAKE_FAILURE;\n\t\t\tSSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_NO_SHARED_CIPHER);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\ts->s3->tmp.new_cipher=c;\n\t\t/* check whether we should disable session resumption */\n\t\tif (s->not_resumable_session_cb != NULL)\n\t\t\ts->session->not_resumable=s->not_resumable_session_cb(s,\n\t\t\t\t((c->algorithm_mkey & (SSL_kDHE | SSL_kECDHE)) != 0));\n\t\tif (s->session->not_resumable)\n\t\t\t/* do not send a session ticket */\n\t\t\ts->tlsext_ticket_expected = 0;\n\t\t}\n\telse\n\t\t{\n\t\t/* Session-id reuse */\n#ifdef REUSE_CIPHER_BUG\n\t\tSTACK_OF(SSL_CIPHER) *sk;\n\t\tSSL_CIPHER *nc=NULL;\n\t\tSSL_CIPHER *ec=NULL;\n\n\t\tif (s->options & SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG)\n\t\t\t{\n\t\t\tsk=s->session->ciphers;\n\t\t\tfor (i=0; i<sk_SSL_CIPHER_num(sk); i++)\n\t\t\t\t{\n\t\t\t\tc=sk_SSL_CIPHER_value(sk,i);\n\t\t\t\tif (c->algorithm_enc & SSL_eNULL)\n\t\t\t\t\tnc=c;\n\t\t\t\tif (SSL_C_IS_EXPORT(c))\n\t\t\t\t\tec=c;\n\t\t\t\t}\n\t\t\tif (nc != NULL)\n\t\t\t\ts->s3->tmp.new_cipher=nc;\n\t\t\telse if (ec != NULL)\n\t\t\t\ts->s3->tmp.new_cipher=ec;\n\t\t\telse\n\t\t\t\ts->s3->tmp.new_cipher=s->session->cipher;\n\t\t\t}\n\t\telse\n#endif\n\t\ts->s3->tmp.new_cipher=s->session->cipher;\n\t\t}\n\n\tif (!SSL_USE_SIGALGS(s) || !(s->verify_mode & SSL_VERIFY_PEER))\n\t\t{\n\t\tif (!ssl3_digest_cached_records(s))\n\t\t\tgoto f_err;\n\t\t}\n\t\n\t/*-\n\t * we now have the following setup. \n\t * client_random\n\t * cipher_list \t\t- our prefered list of ciphers\n\t * ciphers \t\t- the clients prefered list of ciphers\n\t * compression\t\t- basically ignored right now\n\t * ssl version is set\t- sslv3\n\t * s->session\t\t- The ssl session has been setup.\n\t * s->hit\t\t- session reuse flag\n\t * s->s3->tmp.new_cipher- the new cipher to use.\n\t */\n\n\t/* Handles TLS extensions that we couldn't check earlier */\n\tif (s->version >= SSL3_VERSION)\n\t\t{\n\t\tif (ssl_check_clienthello_tlsext_late(s) <= 0)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_CLIENTHELLO_TLSEXT);\n\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\n\tif (ret < 0) ret=-ret;\n\tif (0)\n\t\t{\nf_err:\n\t\tssl3_send_alert(s,SSL3_AL_FATAL,al);\n\t\t}\nerr:\n\tif (ciphers != NULL) sk_SSL_CIPHER_free(ciphers);\n\treturn ret < 0 ? -1 : ret;\n\t}\n", "target": 0, "idx": 45177}
{"func": "LayoutUnit RenderFlexibleBox::autoMarginOffsetInMainAxis(const OrderedFlexItemList& children, LayoutUnit& availableFreeSpace)\n{\n    if (availableFreeSpace <= 0)\n        return 0;\n\n    int numberOfAutoMargins = 0;\n    bool isHorizontal = isHorizontalFlow();\n    for (size_t i = 0; i < children.size(); ++i) {\n        RenderBox* child = children[i];\n        if (child->isOutOfFlowPositioned())\n            continue;\n        if (isHorizontal) {\n            if (child->style()->marginLeft().isAuto())\n                ++numberOfAutoMargins;\n            if (child->style()->marginRight().isAuto())\n                ++numberOfAutoMargins;\n        } else {\n            if (child->style()->marginTop().isAuto())\n                ++numberOfAutoMargins;\n            if (child->style()->marginBottom().isAuto())\n                ++numberOfAutoMargins;\n        }\n    }\n    if (!numberOfAutoMargins)\n        return 0;\n\n    LayoutUnit sizeOfAutoMargin = availableFreeSpace / numberOfAutoMargins;\n    availableFreeSpace = 0;\n    return sizeOfAutoMargin;\n}\n", "target": 0, "idx": 124986}
{"func": "static void RunAutofocusTask(ExecutionContext* context) {\n  if (!context)\n    return;\n\n  Document* document = ToDocument(context);\n  if (Element* element = document->AutofocusElement()) {\n    document->SetAutofocusElement(nullptr);\n    element->focus();\n  }\n}\n", "target": 0, "idx": 159581}
{"func": "bgp_attr_parse_ret_t bgp_attr_parse(struct peer *peer, struct attr *attr,\n\t\t\t\t    bgp_size_t size, struct bgp_nlri *mp_update,\n\t\t\t\t    struct bgp_nlri *mp_withdraw)\n{\n\tbgp_attr_parse_ret_t ret;\n\tuint8_t flag = 0;\n\tuint8_t type = 0;\n\tbgp_size_t length;\n\tuint8_t *startp, *endp;\n\tuint8_t *attr_endp;\n\tuint8_t seen[BGP_ATTR_BITMAP_SIZE];\n\t/* we need the as4_path only until we have synthesized the as_path with\n\t * it */\n\t/* same goes for as4_aggregator */\n\tstruct aspath *as4_path = NULL;\n\tas_t as4_aggregator = 0;\n\tstruct in_addr as4_aggregator_addr = {.s_addr = 0};\n\n\t/* Initialize bitmap. */\n\tmemset(seen, 0, BGP_ATTR_BITMAP_SIZE);\n\n\t/* End pointer of BGP attribute. */\n\tendp = BGP_INPUT_PNT(peer) + size;\n\n\t/* Get attributes to the end of attribute length. */\n\twhile (BGP_INPUT_PNT(peer) < endp) {\n\t\t/* Check remaining length check.*/\n\t\tif (endp - BGP_INPUT_PNT(peer) < BGP_ATTR_MIN_LEN) {\n\t\t\t/* XXX warning: long int format, int arg (arg 5) */\n\t\t\tflog_warn(\n\t\t\t\tEC_BGP_ATTRIBUTE_TOO_SMALL,\n\t\t\t\t\"%s: error BGP attribute length %lu is smaller than min len\",\n\t\t\t\tpeer->host,\n\t\t\t\t(unsigned long)(endp\n\t\t\t\t\t\t- stream_pnt(BGP_INPUT(peer))));\n\n\t\t\tbgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\t\tBGP_NOTIFY_UPDATE_ATTR_LENG_ERR);\n\t\t\treturn BGP_ATTR_PARSE_ERROR;\n\t\t}\n\n\t\t/* Fetch attribute flag and type. */\n\t\tstartp = BGP_INPUT_PNT(peer);\n\t\t/* \"The lower-order four bits of the Attribute Flags octet are\n\t\t   unused.  They MUST be zero when sent and MUST be ignored when\n\t\t   received.\" */\n\t\tflag = 0xF0 & stream_getc(BGP_INPUT(peer));\n\t\ttype = stream_getc(BGP_INPUT(peer));\n\n\t\t/* Check whether Extended-Length applies and is in bounds */\n\t\tif (CHECK_FLAG(flag, BGP_ATTR_FLAG_EXTLEN)\n\t\t    && ((endp - startp) < (BGP_ATTR_MIN_LEN + 1))) {\n\t\t\tflog_warn(\n\t\t\t\tEC_BGP_EXT_ATTRIBUTE_TOO_SMALL,\n\t\t\t\t\"%s: Extended length set, but just %lu bytes of attr header\",\n\t\t\t\tpeer->host,\n\t\t\t\t(unsigned long)(endp\n\t\t\t\t\t\t- stream_pnt(BGP_INPUT(peer))));\n\n\t\t\tbgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\t\tBGP_NOTIFY_UPDATE_ATTR_LENG_ERR);\n\t\t\treturn BGP_ATTR_PARSE_ERROR;\n\t\t}\n\n\t\t/* Check extended attribue length bit. */\n\t\tif (CHECK_FLAG(flag, BGP_ATTR_FLAG_EXTLEN))\n\t\t\tlength = stream_getw(BGP_INPUT(peer));\n\t\telse\n\t\t\tlength = stream_getc(BGP_INPUT(peer));\n\n\t\t/* If any attribute appears more than once in the UPDATE\n\t\t   message, then the Error Subcode is set to Malformed Attribute\n\t\t   List. */\n\n\t\tif (CHECK_BITMAP(seen, type)) {\n\t\t\tflog_warn(\n\t\t\t\tEC_BGP_ATTRIBUTE_REPEATED,\n\t\t\t\t\"%s: error BGP attribute type %d appears twice in a message\",\n\t\t\t\tpeer->host, type);\n\n\t\t\tbgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\t\tBGP_NOTIFY_UPDATE_MAL_ATTR);\n\t\t\treturn BGP_ATTR_PARSE_ERROR;\n\t\t}\n\n\t\t/* Set type to bitmap to check duplicate attribute.  `type' is\n\t\t   unsigned char so it never overflow bitmap range. */\n\n\t\tSET_BITMAP(seen, type);\n\n\t\t/* Overflow check. */\n\t\tattr_endp = BGP_INPUT_PNT(peer) + length;\n\n\t\tif (attr_endp > endp) {\n\t\t\tflog_warn(\n\t\t\t\tEC_BGP_ATTRIBUTE_TOO_LARGE,\n\t\t\t\t\"%s: BGP type %d length %d is too large, attribute total length is %d.  attr_endp is %p.  endp is %p\",\n\t\t\t\tpeer->host, type, length, size, attr_endp,\n\t\t\t\tendp);\n\t\t\t/*\n\t\t\t * RFC 4271 6.3\n\t\t\t * If any recognized attribute has an Attribute\n\t\t\t * Length that conflicts with the expected length\n\t\t\t * (based on the attribute type code), then the\n\t\t\t * Error Subcode MUST be set to Attribute Length\n\t\t\t * Error.  The Data field MUST contain the erroneous\n\t\t\t * attribute (type, length, and value).\n\t\t\t * ----------\n\t\t\t * We do not currently have a good way to determine the\n\t\t\t * length of the attribute independent of the length\n\t\t\t * received in the message. Instead we send the\n\t\t\t * minimum between the amount of data we have and the\n\t\t\t * amount specified by the attribute length field.\n\t\t\t *\n\t\t\t * Instead of directly passing in the packet buffer and\n\t\t\t * offset we use the stream_get* functions to read into\n\t\t\t * a stack buffer, since they perform bounds checking\n\t\t\t * and we are working with untrusted data.\n\t\t\t */\n\t\t\tunsigned char ndata[BGP_MAX_PACKET_SIZE];\n\t\t\tmemset(ndata, 0x00, sizeof(ndata));\n\t\t\tsize_t lfl =\n\t\t\t\tCHECK_FLAG(flag, BGP_ATTR_FLAG_EXTLEN) ? 2 : 1;\n\t\t\t/* Rewind to end of flag field */\n\t\t\tstream_forward_getp(BGP_INPUT(peer), -(1 + lfl));\n\t\t\t/* Type */\n\t\t\tstream_get(&ndata[0], BGP_INPUT(peer), 1);\n\t\t\t/* Length */\n\t\t\tstream_get(&ndata[1], BGP_INPUT(peer), lfl);\n\t\t\t/* Value */\n\t\t\tsize_t atl = attr_endp - startp;\n\t\t\tsize_t ndl = MIN(atl, STREAM_READABLE(BGP_INPUT(peer)));\n\t\t\tstream_get(&ndata[lfl + 1], BGP_INPUT(peer), ndl);\n\n\t\t\tbgp_notify_send_with_data(\n\t\t\t\tpeer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\tBGP_NOTIFY_UPDATE_ATTR_LENG_ERR, ndata,\n\t\t\t\tndl + lfl + 1);\n\n\t\t\treturn BGP_ATTR_PARSE_ERROR;\n\t\t}\n\n\t\tstruct bgp_attr_parser_args attr_args = {\n\t\t\t.peer = peer,\n\t\t\t.length = length,\n\t\t\t.attr = attr,\n\t\t\t.type = type,\n\t\t\t.flags = flag,\n\t\t\t.startp = startp,\n\t\t\t.total = attr_endp - startp,\n\t\t};\n\n\n\t\t/* If any recognized attribute has Attribute Flags that conflict\n\t\t   with the Attribute Type Code, then the Error Subcode is set\n\t\t   to\n\t\t   Attribute Flags Error.  The Data field contains the erroneous\n\t\t   attribute (type, length and value). */\n\t\tif (bgp_attr_flag_invalid(&attr_args)) {\n\t\t\tret = bgp_attr_malformed(\n\t\t\t\t&attr_args, BGP_NOTIFY_UPDATE_ATTR_FLAG_ERR,\n\t\t\t\tattr_args.total);\n\t\t\tif (ret == BGP_ATTR_PARSE_PROCEED)\n\t\t\t\tcontinue;\n\t\t\treturn ret;\n\t\t}\n\n\t\t/* OK check attribute and store it's value. */\n\t\tswitch (type) {\n\t\tcase BGP_ATTR_ORIGIN:\n\t\t\tret = bgp_attr_origin(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_AS_PATH:\n\t\t\tret = bgp_attr_aspath(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_AS4_PATH:\n\t\t\tret = bgp_attr_as4_path(&attr_args, &as4_path);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_NEXT_HOP:\n\t\t\tret = bgp_attr_nexthop(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_MULTI_EXIT_DISC:\n\t\t\tret = bgp_attr_med(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_LOCAL_PREF:\n\t\t\tret = bgp_attr_local_pref(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_ATOMIC_AGGREGATE:\n\t\t\tret = bgp_attr_atomic(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_AGGREGATOR:\n\t\t\tret = bgp_attr_aggregator(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_AS4_AGGREGATOR:\n\t\t\tret = bgp_attr_as4_aggregator(&attr_args,\n\t\t\t\t\t\t      &as4_aggregator,\n\t\t\t\t\t\t      &as4_aggregator_addr);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_COMMUNITIES:\n\t\t\tret = bgp_attr_community(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_LARGE_COMMUNITIES:\n\t\t\tret = bgp_attr_large_community(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_ORIGINATOR_ID:\n\t\t\tret = bgp_attr_originator_id(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_CLUSTER_LIST:\n\t\t\tret = bgp_attr_cluster_list(&attr_args);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_MP_REACH_NLRI:\n\t\t\tret = bgp_mp_reach_parse(&attr_args, mp_update);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_MP_UNREACH_NLRI:\n\t\t\tret = bgp_mp_unreach_parse(&attr_args, mp_withdraw);\n\t\t\tbreak;\n \t\tcase BGP_ATTR_EXT_COMMUNITIES:\n \t\t\tret = bgp_attr_ext_communities(&attr_args);\n \t\t\tbreak;\n#if ENABLE_BGP_VNC\n \t\tcase BGP_ATTR_VNC:\n #endif\n \t\tcase BGP_ATTR_ENCAP:\n\t\t\tret = bgp_attr_encap(type, peer, length, attr, flag,\n\t\t\t\t\t     startp);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_PREFIX_SID:\n\t\t\tret = bgp_attr_prefix_sid(length,\n\t\t\t\t\t\t  &attr_args, mp_update);\n\t\t\tbreak;\n\t\tcase BGP_ATTR_PMSI_TUNNEL:\n\t\t\tret = bgp_attr_pmsi_tunnel(&attr_args);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = bgp_attr_unknown(&attr_args);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ret == BGP_ATTR_PARSE_ERROR_NOTIFYPLS) {\n\t\t\tbgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\t\tBGP_NOTIFY_UPDATE_MAL_ATTR);\n\t\t\tret = BGP_ATTR_PARSE_ERROR;\n\t\t}\n\n\t\tif (ret == BGP_ATTR_PARSE_EOR) {\n\t\t\tif (as4_path)\n\t\t\t\taspath_unintern(&as4_path);\n\t\t\treturn ret;\n\t\t}\n\n\t\t/* If hard error occurred immediately return to the caller. */\n\t\tif (ret == BGP_ATTR_PARSE_ERROR) {\n\t\t\tflog_warn(EC_BGP_ATTRIBUTE_PARSE_ERROR,\n\t\t\t\t  \"%s: Attribute %s, parse error\", peer->host,\n\t\t\t\t  lookup_msg(attr_str, type, NULL));\n\t\t\tif (as4_path)\n\t\t\t\taspath_unintern(&as4_path);\n\t\t\treturn ret;\n\t\t}\n\t\tif (ret == BGP_ATTR_PARSE_WITHDRAW) {\n\n\t\t\tflog_warn(\n\t\t\t\tEC_BGP_ATTRIBUTE_PARSE_WITHDRAW,\n\t\t\t\t\"%s: Attribute %s, parse error - treating as withdrawal\",\n\t\t\t\tpeer->host, lookup_msg(attr_str, type, NULL));\n\t\t\tif (as4_path)\n\t\t\t\taspath_unintern(&as4_path);\n\t\t\treturn ret;\n\t\t}\n\n\t\t/* Check the fetched length. */\n\t\tif (BGP_INPUT_PNT(peer) != attr_endp) {\n\t\t\tflog_warn(EC_BGP_ATTRIBUTE_FETCH_ERROR,\n\t\t\t\t  \"%s: BGP attribute %s, fetch error\",\n\t\t\t\t  peer->host, lookup_msg(attr_str, type, NULL));\n\t\t\tbgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\t\tBGP_NOTIFY_UPDATE_ATTR_LENG_ERR);\n\t\t\tif (as4_path)\n\t\t\t\taspath_unintern(&as4_path);\n\t\t\treturn BGP_ATTR_PARSE_ERROR;\n\t\t}\n\t}\n\n\t/* Check final read pointer is same as end pointer. */\n\tif (BGP_INPUT_PNT(peer) != endp) {\n\t\tflog_warn(EC_BGP_ATTRIBUTES_MISMATCH,\n\t\t\t  \"%s: BGP attribute %s, length mismatch\", peer->host,\n\t\t\t  lookup_msg(attr_str, type, NULL));\n\t\tbgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\tBGP_NOTIFY_UPDATE_ATTR_LENG_ERR);\n\t\tif (as4_path)\n\t\t\taspath_unintern(&as4_path);\n\t\treturn BGP_ATTR_PARSE_ERROR;\n\t}\n\n\t/* Check all mandatory well-known attributes are present */\n\tif ((ret = bgp_attr_check(peer, attr)) < 0) {\n\t\tif (as4_path)\n\t\t\taspath_unintern(&as4_path);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * At this place we can see whether we got AS4_PATH and/or\n\t * AS4_AGGREGATOR from a 16Bit peer and act accordingly.\n\t * We can not do this before we've read all attributes because\n\t * the as4 handling does not say whether AS4_PATH has to be sent\n\t * after AS_PATH or not - and when AS4_AGGREGATOR will be send\n\t * in relationship to AGGREGATOR.\n\t * So, to be defensive, we are not relying on any order and read\n\t * all attributes first, including these 32bit ones, and now,\n\t * afterwards, we look what and if something is to be done for as4.\n\t *\n\t * It is possible to not have AS_PATH, e.g. GR EoR and sole\n\t * MP_UNREACH_NLRI.\n\t */\n\t/* actually... this doesn't ever return failure currently, but\n\t * better safe than sorry */\n\tif (CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_AS_PATH))\n\t    && bgp_attr_munge_as4_attrs(peer, attr, as4_path, as4_aggregator,\n\t\t\t\t\t&as4_aggregator_addr)) {\n\t\tbgp_notify_send(peer, BGP_NOTIFY_UPDATE_ERR,\n\t\t\t\tBGP_NOTIFY_UPDATE_MAL_ATTR);\n\t\tif (as4_path)\n\t\t\taspath_unintern(&as4_path);\n\t\treturn BGP_ATTR_PARSE_ERROR;\n\t}\n\n\t/* At this stage, we have done all fiddling with as4, and the\n\t * resulting info is in attr->aggregator resp. attr->aspath\n\t * so we can chuck as4_aggregator and as4_path alltogether in\n\t * order to save memory\n\t */\n\tif (as4_path) {\n\t\taspath_unintern(&as4_path); /* unintern - it is in the hash */\n\t\t/* The flag that we got this is still there, but that does not\n\t\t * do any trouble\n\t\t */\n\t}\n\t/*\n\t * The \"rest\" of the code does nothing with as4_aggregator.\n\t * there is no memory attached specifically which is not part\n\t * of the attr.\n\t * so ignoring just means do nothing.\n\t */\n\t/*\n\t * Finally do the checks on the aspath we did not do yet\n\t * because we waited for a potentially synthesized aspath.\n\t */\n\tif (attr->flag & (ATTR_FLAG_BIT(BGP_ATTR_AS_PATH))) {\n\t\tret = bgp_attr_aspath_check(peer, attr);\n\t\tif (ret != BGP_ATTR_PARSE_PROCEED)\n\t\t\treturn ret;\n\t}\n\t/* Finally intern unknown attribute. */\n\tif (attr->transit)\n\t\tattr->transit = transit_intern(attr->transit);\n\tif (attr->encap_subtlvs)\n\t\tattr->encap_subtlvs =\n\t\t\tencap_intern(attr->encap_subtlvs, ENCAP_SUBTLV_TYPE);\n#if ENABLE_BGP_VNC\n\tif (attr->vnc_subtlvs)\n\t\tattr->vnc_subtlvs =\n\t\t\tencap_intern(attr->vnc_subtlvs, VNC_SUBTLV_TYPE);\n#endif\n\n\treturn BGP_ATTR_PARSE_PROCEED;\n}\n", "target": 1, "idx": 182914}
{"func": "SPL_METHOD(SplHeap, count)\n{\n\tlong count;\n\tspl_heap_object *intern = (spl_heap_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"\") == FAILURE) {\n\t\treturn;\n\t}\n\n\tcount = spl_ptr_heap_count(intern->heap);\n\tRETURN_LONG(count);\n}\n", "target": 0, "idx": 14875}
{"func": "GF_Err chpl_Read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_ChapterEntry *ce;\n\tu32 nb_chaps, len, i, count;\n\tGF_ChapterListBox *ptr = (GF_ChapterListBox *)s;\n\n\t/*reserved or ???*/\n\tgf_bs_read_u32(bs);\n\tnb_chaps = gf_bs_read_u8(bs);\n\n\tcount = 0;\n\twhile (nb_chaps) {\n\t\tGF_SAFEALLOC(ce, GF_ChapterEntry);\n\t\tif (!ce) return GF_OUT_OF_MEM;\n\t\tce->start_time = gf_bs_read_u64(bs);\n\t\tlen = gf_bs_read_u8(bs);\n\t\tif (len) {\n\t\t\tce->name = (char *)gf_malloc(sizeof(char)*(len+1));\n\t\t\tgf_bs_read_data(bs, ce->name, len);\n\t\t\tce->name[len] = 0;\n\t\t} else {\n\t\t\tce->name = gf_strdup(\"\");\n\t\t}\n\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_ChapterEntry *ace = (GF_ChapterEntry *) gf_list_get(ptr->list, i);\n\t\t\tif (ace->start_time >= ce->start_time) {\n\t\t\t\tgf_list_insert(ptr->list, ce, i);\n\t\t\t\tce = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ce) gf_list_add(ptr->list, ce);\n\t\tcount++;\n\t\tnb_chaps--;\n\t}\n\treturn GF_OK;\n}\n", "target": 0, "idx": 80006}
{"func": "int cipso_v4_validate(const struct sk_buff *skb, unsigned char **option)\n{\n\tunsigned char *opt = *option;\n\tunsigned char *tag;\n\tunsigned char opt_iter;\n\tunsigned char err_offset = 0;\n\tu8 opt_len;\n\tu8 tag_len;\n\tstruct cipso_v4_doi *doi_def = NULL;\n\tu32 tag_iter;\n\n\t/* caller already checks for length values that are too large */\n\topt_len = opt[1];\n\tif (opt_len < 8) {\n\t\terr_offset = 1;\n\t\tgoto validate_return;\n\t}\n\n\trcu_read_lock();\n\tdoi_def = cipso_v4_doi_search(get_unaligned_be32(&opt[2]));\n\tif (doi_def == NULL) {\n\t\terr_offset = 2;\n\t\tgoto validate_return_locked;\n\t}\n\n\topt_iter = CIPSO_V4_HDR_LEN;\n\ttag = opt + opt_iter;\n\twhile (opt_iter < opt_len) {\n\t\tfor (tag_iter = 0; doi_def->tags[tag_iter] != tag[0];)\n\t\t\tif (doi_def->tags[tag_iter] == CIPSO_V4_TAG_INVALID ||\n\t\t\t    ++tag_iter == CIPSO_V4_TAG_MAXCNT) {\n\t\t\t\terr_offset = opt_iter;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\n\t\ttag_len = tag[1];\n\t\tif (tag_len > (opt_len - opt_iter)) {\n\t\t\terr_offset = opt_iter + 1;\n\t\t\tgoto validate_return_locked;\n\t\t}\n\n\t\tswitch (tag[0]) {\n\t\tcase CIPSO_V4_TAG_RBITMAP:\n\t\t\tif (tag_len < CIPSO_V4_TAG_RBM_BLEN) {\n\t\t\t\terr_offset = opt_iter + 1;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\n\t\t\t/* We are already going to do all the verification\n\t\t\t * necessary at the socket layer so from our point of\n\t\t\t * view it is safe to turn these checks off (and less\n\t\t\t * work), however, the CIPSO draft says we should do\n\t\t\t * all the CIPSO validations here but it doesn't\n\t\t\t * really specify _exactly_ what we need to validate\n\t\t\t * ... so, just make it a sysctl tunable. */\n\t\t\tif (cipso_v4_rbm_strictvalid) {\n\t\t\t\tif (cipso_v4_map_lvl_valid(doi_def,\n\t\t\t\t\t\t\t   tag[3]) < 0) {\n\t\t\t\t\terr_offset = opt_iter + 3;\n\t\t\t\t\tgoto validate_return_locked;\n\t\t\t\t}\n\t\t\t\tif (tag_len > CIPSO_V4_TAG_RBM_BLEN &&\n\t\t\t\t    cipso_v4_map_cat_rbm_valid(doi_def,\n\t\t\t\t\t\t\t    &tag[4],\n\t\t\t\t\t\t\t    tag_len - 4) < 0) {\n\t\t\t\t\terr_offset = opt_iter + 4;\n\t\t\t\t\tgoto validate_return_locked;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CIPSO_V4_TAG_ENUM:\n\t\t\tif (tag_len < CIPSO_V4_TAG_ENUM_BLEN) {\n\t\t\t\terr_offset = opt_iter + 1;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\n\t\t\tif (cipso_v4_map_lvl_valid(doi_def,\n\t\t\t\t\t\t   tag[3]) < 0) {\n\t\t\t\terr_offset = opt_iter + 3;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\t\t\tif (tag_len > CIPSO_V4_TAG_ENUM_BLEN &&\n\t\t\t    cipso_v4_map_cat_enum_valid(doi_def,\n\t\t\t\t\t\t\t&tag[4],\n\t\t\t\t\t\t\ttag_len - 4) < 0) {\n\t\t\t\terr_offset = opt_iter + 4;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CIPSO_V4_TAG_RANGE:\n\t\t\tif (tag_len < CIPSO_V4_TAG_RNG_BLEN) {\n\t\t\t\terr_offset = opt_iter + 1;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\n\t\t\tif (cipso_v4_map_lvl_valid(doi_def,\n\t\t\t\t\t\t   tag[3]) < 0) {\n\t\t\t\terr_offset = opt_iter + 3;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\t\t\tif (tag_len > CIPSO_V4_TAG_RNG_BLEN &&\n\t\t\t    cipso_v4_map_cat_rng_valid(doi_def,\n\t\t\t\t\t\t       &tag[4],\n\t\t\t\t\t\t       tag_len - 4) < 0) {\n\t\t\t\terr_offset = opt_iter + 4;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\t\t\tbreak;\n \t\tcase CIPSO_V4_TAG_LOCAL:\n \t\t\t/* This is a non-standard tag that we only allow for\n \t\t\t * local connections, so if the incoming interface is\n\t\t\t * not the loopback device drop the packet. */\n\t\t\tif (!(skb->dev->flags & IFF_LOOPBACK)) {\n \t\t\t\terr_offset = opt_iter;\n \t\t\t\tgoto validate_return_locked;\n \t\t\t}\n\t\t\tif (tag_len != CIPSO_V4_TAG_LOC_BLEN) {\n\t\t\t\terr_offset = opt_iter + 1;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr_offset = opt_iter;\n\t\t\tgoto validate_return_locked;\n\t\t}\n\n\t\ttag += tag_len;\n\t\topt_iter += tag_len;\n\t}\n\nvalidate_return_locked:\n\trcu_read_unlock();\nvalidate_return:\n\t*option = opt + err_offset;\n\treturn err_offset;\n}\n", "target": 1, "idx": 179315}
{"func": "bool ExtensionViewGuest::NavigateGuest(const std::string& src,\n                                       bool force_navigation) {\n  GURL url = extension_url_.Resolve(src);\n \n  bool url_not_allowed = (url != GURL(url::kAboutBlankURL)) &&\n      (url.GetOrigin() != extension_url_.GetOrigin());\n   if (!url.is_valid() || url_not_allowed)\n     return NavigateGuest(url::kAboutBlankURL, true /* force_navigation */);\n \n  if (!force_navigation && (url_ == url))\n    return false;\n\n  web_contents()->GetRenderProcessHost()->FilterURL(false, &url);\n  web_contents()->GetController().LoadURL(url, content::Referrer(),\n                                          ui::PAGE_TRANSITION_AUTO_TOPLEVEL,\n                                          std::string());\n\n  url_ = url;\n  return true;\n}\n", "target": 1, "idx": 186252}
{"func": "my_object_get_value (MyObject *obj, guint *ret, GError **error)\n{\n  *ret = obj->val;\n  return TRUE;\n}\n", "target": 1, "idx": 178276}
{"func": "int call_netdevice_notifiers(unsigned long val, struct net_device *dev)\n{\n\tASSERT_RTNL();\n\treturn raw_notifier_call_chain(&netdev_chain, val, dev);\n}\n", "target": 0, "idx": 35236}
{"func": "void CrosLibrary::TestApi::SetScreenLockLibrary(\n    ScreenLockLibrary* library, bool own) {\n  library_->screen_lock_lib_.SetImpl(library, own);\n}\n", "target": 1, "idx": 184112}
{"func": "static int mboxlist_do_find(struct find_rock *rock, const strarray_t *patterns)\n{\n    const char *userid = rock->userid;\n    int isadmin = rock->isadmin;\n\n    int crossdomains = config_getswitch(IMAPOPT_CROSSDOMAINS);\n    char inbox[MAX_MAILBOX_BUFFER];\n    size_t inboxlen = 0;\n    size_t prefixlen, len;\n    size_t domainlen = 0;\n    size_t userlen = userid ? strlen(userid) : 0;\n    char domainpat[MAX_MAILBOX_BUFFER]; /* do intra-domain fetches only */\n    char commonpat[MAX_MAILBOX_BUFFER];\n    int r = 0;\n    int i;\n    const char *p;\n\n    if (patterns->count < 1) return 0; /* nothing to do */\n\n    for (i = 0; i < patterns->count; i++) {\n        glob *g = glob_init(strarray_nth(patterns, i), rock->namespace->hier_sep);\n        ptrarray_append(&rock->globs, g);\n    }\n\n    if (config_virtdomains && userid && (p = strchr(userid, '@'))) {\n        userlen = p - userid;\n        domainlen = strlen(p); /* includes separator */\n        snprintf(domainpat, sizeof(domainpat), \"%s!\", p+1);\n    }\n    else\n        domainpat[0] = '\\0';\n\n    /* calculate the inbox (with trailing .INBOX. for later use) */\n    if (userid && (!(p = strchr(userid, rock->namespace->hier_sep)) ||\n        ((p - userid) > (int)userlen)) &&\n        strlen(userid)+7 < MAX_MAILBOX_BUFFER) {\n        char *t, *tmpuser = NULL;\n        const char *inboxuser;\n\n        if (domainlen)\n            snprintf(inbox, sizeof(inbox), \"%s!\", userid+userlen+1);\n        if (rock->namespace->hier_sep == '/' && (p = strchr(userid, '.'))) {\n            tmpuser = xmalloc(userlen);\n            memcpy(tmpuser, userid, userlen);\n            t = tmpuser + (p - userid);\n            while(t < (tmpuser + userlen)) {\n                if (*t == '.')\n                    *t = '^';\n                t++;\n            }\n            inboxuser = tmpuser;\n        } else\n            inboxuser = userid;\n        snprintf(inbox+domainlen, sizeof(inbox)-domainlen,\n                 \"user.%.*s.INBOX.\", (int)userlen, inboxuser);\n        free(tmpuser);\n        inboxlen = strlen(inbox) - 7;\n    }\n    else {\n        userid = 0;\n    }\n\n    /* Find the common search prefix of all patterns */\n    const char *firstpat = strarray_nth(patterns, 0);\n    for (prefixlen = 0; firstpat[prefixlen]; prefixlen++) {\n        if (prefixlen >= MAX_MAILBOX_NAME) {\n            r = IMAP_MAILBOX_BADNAME;\n            goto done;\n        }\n        char c = firstpat[prefixlen];\n        for (i = 1; i < patterns->count; i++) {\n            const char *pat = strarray_nth(patterns, i);\n            if (pat[prefixlen] != c) break;\n        }\n        if (i < patterns->count) break;\n        if (c == '*' || c == '%' || c == '?') break;\n        commonpat[prefixlen] = c;\n    }\n    commonpat[prefixlen] = '\\0';\n\n    if (patterns->count == 1) {\n        /* Skip pattern which matches shared namespace prefix */\n        if (!strcmp(firstpat+prefixlen, \"%\"))\n            rock->singlepercent = 2;\n        /* output prefix regardless */\n        if (!strcmp(firstpat+prefixlen, \"*%\"))\n            rock->singlepercent = 1;\n    }\n\n    /*\n     * Personal (INBOX) namespace (only if not admin)\n     */\n    if (userid && !isadmin) {\n        /* first the INBOX */\n        rock->mb_category = MBNAME_INBOX;\n        r = cyrusdb_forone(rock->db, inbox, inboxlen, &find_p, &find_cb, rock, NULL);\n        if (r == CYRUSDB_DONE) r = 0;\n        if (r) goto done;\n\n        if (rock->namespace->isalt) {\n            /* do exact INBOX subs before resetting the namebuffer */\n            rock->mb_category = MBNAME_INBOXSUB;\n            r = cyrusdb_foreach(rock->db, inbox, inboxlen+7, &find_p, &find_cb, rock, NULL);\n            if (r == CYRUSDB_DONE) r = 0;\n            if (r) goto done;\n\n            /* reset the the namebuffer */\n            r = (*rock->proc)(NULL, rock->procrock);\n            if (r) goto done;\n        }\n\n        /* iterate through all the mailboxes under the user's inbox */\n        rock->mb_category = MBNAME_OWNER;\n        r = cyrusdb_foreach(rock->db, inbox, inboxlen+1, &find_p, &find_cb, rock, NULL);\n        if (r == CYRUSDB_DONE) r = 0;\n        if (r) goto done;\n\n        /* \"Alt Prefix\" folders */\n        if (rock->namespace->isalt) {\n            /* reset the the namebuffer */\n            r = (*rock->proc)(NULL, rock->procrock);\n            if (r) goto done;\n\n            rock->mb_category = MBNAME_ALTINBOX;\n\n            /* special case user.foo.INBOX.  If we're singlepercent == 2, this could\n             return DONE, in which case we don't need to foreach the rest of the\n             altprefix space */\n            r = cyrusdb_forone(rock->db, inbox, inboxlen+6, &find_p, &find_cb, rock, NULL);\n            if (r == CYRUSDB_DONE) goto skipalt;\n            if (r) goto done;\n\n            /* special case any other altprefix stuff */\n            rock->mb_category = MBNAME_ALTPREFIX;\n            r = cyrusdb_foreach(rock->db, inbox, inboxlen+1, &find_p, &find_cb, rock, NULL);\n        skipalt: /* we got a done, so skip out of the foreach early */\n            if (r == CYRUSDB_DONE) r = 0;\n            if (r) goto done;\n        }\n    }\n\n    /*\n     * Other Users namespace\n     *\n     * If \"Other Users*\" can match pattern, search for those mailboxes next\n     */\n    if (isadmin || rock->namespace->accessible[NAMESPACE_USER]) {\n        len = strlen(rock->namespace->prefix[NAMESPACE_USER]);\n         if (len) len--; // trailing separator\n \n         if (!strncmp(rock->namespace->prefix[NAMESPACE_USER], commonpat, MIN(len, prefixlen))) {\n            if (prefixlen < len) {\n                 /* we match all users */\n                 strlcpy(domainpat+domainlen, \"user.\", sizeof(domainpat)-domainlen);\n             }\n            else {\n                /* just those in this prefix */\n                strlcpy(domainpat+domainlen, \"user.\", sizeof(domainpat)-domainlen);\n                strlcpy(domainpat+domainlen+5, commonpat+len+1, sizeof(domainpat)-domainlen-5);\n            }\n\n            rock->mb_category = MBNAME_OTHERUSER;\n\n            /* because of how domains work, with crossdomains or admin you can't prefix at all :( */\n            size_t thislen = (isadmin || crossdomains) ? 0 : strlen(domainpat);\n\n            /* reset the the namebuffer */\n            r = (*rock->proc)(NULL, rock->procrock);\n            if (r) goto done;\n\n            r = mboxlist_find_category(rock, domainpat, thislen);\n            if (r) goto done;\n        }\n    }\n\n    /*\n     * Shared namespace\n     *\n     * search for all remaining mailboxes.\n     * just bother looking at the ones that have the same pattern prefix.\n     */\n    if (isadmin || rock->namespace->accessible[NAMESPACE_SHARED]) {\n        len = strlen(rock->namespace->prefix[NAMESPACE_SHARED]);\n        if (len) len--; // trailing separator\n\n        if (!strncmp(rock->namespace->prefix[NAMESPACE_SHARED], commonpat, MIN(len, prefixlen))) {\n            rock->mb_category = MBNAME_SHARED;\n\n            /* reset the the namebuffer */\n            r = (*rock->proc)(NULL, rock->procrock);\n            if (r) goto done;\n\n            /* iterate through all the non-user folders on the server */\n            r = mboxlist_find_category(rock, domainpat, domainlen);\n            if (r) goto done;\n        }\n    }\n\n    /* finish with a reset call always */\n    r = (*rock->proc)(NULL, rock->procrock);\n\n done:\n    for (i = 0; i < rock->globs.count; i++) {\n        glob *g = ptrarray_nth(&rock->globs, i);\n        glob_free(&g);\n    }\n    ptrarray_fini(&rock->globs);\n\n    return r;\n}\n", "target": 1, "idx": 180929}
{"func": " virtual bool isCryptoSchemeSupported(const uint8_t uuid[16], const String8 &mimeType) {\n Parcel data, reply;\n        data.writeInterfaceToken(IDrm::getInterfaceDescriptor());\n        data.write(uuid, 16);\n        data.writeString8(mimeType);\n status_t status = remote()->transact(IS_CRYPTO_SUPPORTED, data, &reply);\n if (status != OK) {\n            ALOGE(\"isCryptoSchemeSupported: binder call failed: %d\", status);\n return false;\n }\n\n return reply.readInt32() != 0;\n }\n", "target": 0, "idx": 174464}
{"func": "bool UsbChooserContext::HasDevicePermission(\n    const GURL& requesting_origin,\n    const GURL& embedding_origin,\n    const device::mojom::UsbDeviceInfo& device_info) {\n   if (UsbBlocklist::Get().IsExcluded(device_info))\n     return false;\n \n   if (!CanRequestObjectPermission(requesting_origin, embedding_origin))\n     return false;\n \n  auto it = ephemeral_devices_.find(\n      std::make_pair(requesting_origin, embedding_origin));\n  if (it != ephemeral_devices_.end() &&\n      base::ContainsKey(it->second, device_info.guid)) {\n    return true;\n  }\n\n  std::vector<std::unique_ptr<base::DictionaryValue>> device_list =\n      GetGrantedObjects(requesting_origin, embedding_origin);\n  for (const std::unique_ptr<base::DictionaryValue>& device_dict :\n       device_list) {\n    int vendor_id;\n    int product_id;\n    base::string16 serial_number;\n    if (device_dict->GetInteger(kVendorIdKey, &vendor_id) &&\n        device_info.vendor_id == vendor_id &&\n        device_dict->GetInteger(kProductIdKey, &product_id) &&\n        device_info.product_id == product_id &&\n        device_dict->GetString(kSerialNumberKey, &serial_number) &&\n        device_info.serial_number == serial_number) {\n      return true;\n    }\n  }\n\n  return false;\n}\n", "target": 1, "idx": 187357}
{"func": "void RootWindow::SetGestureRecognizerForTesting(ui::GestureRecognizer* gr) {\n  gesture_recognizer_.reset(gr);\n}\n", "target": 0, "idx": 110920}
{"func": "static NTSTATUS do_connect(TALLOC_CTX *ctx,\n\t\t\t\t\tconst char *server,\n\t\t\t\t\tconst char *share,\n\t\t\t\t\tconst struct user_auth_info *auth_info,\n\t\t\t\t\tbool show_sessetup,\n\t\t\t\t\tbool force_encrypt,\n\t\t\t\t\tint max_protocol,\n\t\t\t\t\tint port,\n\t\t\t\t\tint name_type,\n\t\t\t\t\tstruct cli_state **pcli)\n{\n\tstruct cli_state *c = NULL;\n\tchar *servicename;\n\tchar *sharename;\n\tchar *newserver, *newshare;\n\tconst char *username;\n\tconst char *password;\n        const char *domain;\n        NTSTATUS status;\n        int flags = 0;\n \n        /* make a copy so we don't modify the global string 'service' */\n        servicename = talloc_strdup(ctx,share);\n\t\tsharename += 2;\n\t\tif (server == NULL) {\n\t\t\tserver = sharename;\n\t\t}\n\t\tsharename = strchr_m(sharename,'\\\\');\n\t\tif (!sharename) {\n\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t}\n\t\t*sharename = 0;\n\t\tsharename++;\n\t}\n", "target": 1, "idx": 177848}
{"func": "void ResourceMessageFilter::OnClipboardWriteObjectsAsync(\n    const Clipboard::ObjectMap& objects) {\n   Clipboard::ObjectMap* long_living_objects = new Clipboard::ObjectMap(objects);\n \n   ChromeThread::PostTask(\n       ChromeThread::UI,\n       FROM_HERE,\n      new WriteClipboardTask(long_living_objects));\n}\n", "target": 1, "idx": 183512}
{"func": " void BluetoothOptionsHandler::GenerateFakeDeviceList() {\n  GenerateFakeDiscoveredDevice(\n     \"Fake Wireless Keyboard\",\n     \"01-02-03-04-05-06\",\n     \"input-keyboard\",\n     true,\n    true);\n  GenerateFakeDiscoveredDevice(\n     \"Fake Wireless Mouse\",\n     \"02-03-04-05-06-01\",\n     \"input-mouse\",\n     true,\n    false);\n  GenerateFakeDiscoveredDevice(\n     \"Fake Wireless Headset\",\n     \"03-04-05-06-01-02\",\n     \"headset\",\n     false,\n    false);\n  GenerateFakePairing(\n     \"Fake Connecting Keyboard\",\n     \"04-05-06-01-02-03\",\n     \"input-keyboard\",\n     \"bluetoothRemotePasskey\");\n  GenerateFakePairing(\n     \"Fake Connecting Phone\",\n     \"05-06-01-02-03-04\",\n     \"phone\",\n     \"bluetoothConfirmPasskey\");\n  GenerateFakePairing(\n     \"Fake Connecting Headset\",\n     \"06-01-02-03-04-05\",\n     \"headset\",\n     \"bluetoothEnterPasskey\");\n \n   web_ui_->CallJavascriptFunction(\n       \"options.SystemOptions.notifyBluetoothSearchComplete\");\n }\n", "target": 1, "idx": 184599}
{"func": " TestNativeHandler::TestNativeHandler(ScriptContext* context)\n     : ObjectBackedNativeHandler(context) {\n   RouteFunction(\n      \"GetWakeEventPage\",\n       base::Bind(&TestNativeHandler::GetWakeEventPage, base::Unretained(this)));\n }\n", "target": 1, "idx": 186223}
{"func": " void LiveSyncTest::SetupMockGaiaResponses() {\n   username_ = \"user@gmail.com\";\n   password_ = \"password\";\n  factory_.reset(new FakeURLFetcherFactory());\n   factory_->SetFakeResponse(kClientLoginUrl, \"SID=sid\\nLSID=lsid\", true);\n   factory_->SetFakeResponse(kGetUserInfoUrl, \"email=user@gmail.com\", true);\n   factory_->SetFakeResponse(kIssueAuthTokenUrl, \"auth\", true);\n  factory_->SetFakeResponse(kSearchDomainCheckUrl, \".google.com\", true);\n  URLFetcher::set_factory(factory_.get());\n}\n", "target": 1, "idx": 183887}
{"func": " void ChromotingHost::OnScreenRecorderStopped() {\n  if (MessageLoop::current() != context_->main_message_loop()) {\n    context_->main_message_loop()->PostTask(\n         FROM_HERE, base::Bind(&ChromotingHost::OnScreenRecorderStopped, this));\n     return;\n   }\n \n   --stopping_recorders_;\n   DCHECK_GE(stopping_recorders_, 0);\n \n  bool stopping;\n  {\n    base::AutoLock auto_lock(lock_);\n    stopping = state_ == kStopping;\n  }\n  if (!stopping_recorders_ && stopping)\n     ShutdownFinish();\n }\n", "target": 1, "idx": 184626}
{"func": "static void coroutine_fn v9fs_wstat(void *opaque)\n{\n    int32_t fid;\n    int err = 0;\n    int16_t unused;\n    V9fsStat v9stat;\n    size_t offset = 7;\n     struct stat stbuf;\n     V9fsFidState *fidp;\n     V9fsPDU *pdu = opaque;\n \n     v9fs_stat_init(&v9stat);\n     err = pdu_unmarshal(pdu, offset, \"dwS\", &fid, &unused, &v9stat);\n        goto out_nofid;\n    }\n", "target": 1, "idx": 177805}
{"func": "void BrowserInit::LaunchWithProfile::AddUniqueURLs(\n    const std::vector<GURL>& urls,\n    std::vector<Tab>* tabs) {\n  size_t num_existing_tabs = tabs->size();\n  for (size_t i = 0; i < urls.size(); ++i) {\n    bool in_tabs = false;\n    for (size_t j = 0; j < num_existing_tabs; ++j) {\n      if (urls[i] == (*tabs)[j].url) {\n        in_tabs = true;\n        break;\n      }\n    }\n    if (!in_tabs) {\n      BrowserInit::LaunchWithProfile::Tab tab;\n      tab.is_pinned = false;\n      tab.url = urls[i];\n      tabs->push_back(tab);\n    }\n  }\n}\n", "target": 0, "idx": 117614}
{"func": "event_create(void)\n{\n\treturn (void *)CreateEvent(NULL, FALSE, FALSE, NULL);\n}\n", "target": 0, "idx": 81655}
{"func": "bool mkvparser::Match(IMkvReader* pReader, long long& pos, unsigned long id_,\n                      unsigned char*& buf, size_t& buflen) {\n  assert(pReader);\n  assert(pos >= 0);\n  long long total, available;\n  long status = pReader->Length(&total, &available);\n  assert(status >= 0);\n  assert((total < 0) || (available <= total));\n  if (status < 0)\n     return false;\n \n  long len;\n  const long long id = ReadUInt(pReader, pos, len);\n  assert(id >= 0);\n  assert(len > 0);\n  assert(len <= 8);\n  assert((pos + len) <= available);\n \n  if ((unsigned long)id != id_)\n     return false;\n \n   pos += len;  // consume id\n \n  const long long size_ = ReadUInt(pReader, pos, len);\n  assert(size_ >= 0);\n  assert(len > 0);\n  assert(len <= 8);\n  assert((pos + len) <= available);\n \n   pos += len;  // consume length of size of payload\n  assert((pos + size_) <= available);\n \n  const long buflen_ = static_cast<long>(size_);\n \n  buf = new (std::nothrow) unsigned char[buflen_];\n  assert(buf);  // TODO\n \n   status = pReader->Read(pos, buflen_, buf);\n  assert(status == 0);  // TODO\n \n   buflen = buflen_;\n \n  pos += size_;  // consume size of payload\n   return true;\n }\n", "target": 1, "idx": 187855}
{"func": "static int sco_sock_getsockopt(struct socket *sock, int level, int optname, char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tint len, err = 0;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (level == SOL_SCO)\n\t\treturn sco_sock_getsockopt_old(sock, optname, optval, optlen);\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\n\tcase BT_DEFER_SETUP:\n\t\tif (sk->sk_state != BT_BOUND && sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (put_user(test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags),\n\t\t\t     (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n", "target": 0, "idx": 30714}
{"func": "LayoutObject* ImageInputType::createLayoutObject(const ComputedStyle& style) const\n{\n    if (m_useFallbackContent)\n        return new LayoutBlockFlow(&element());\n    LayoutImage* image = new LayoutImage(&element());\n    image->setImageResource(LayoutImageResource::create());\n    return image;\n}\n", "target": 0, "idx": 145682}
{"func": "void InspectorController::inspectedPageDestroyed()\n{\n    disconnectFrontend();\n    m_injectedScriptManager->disconnect();\n    m_inspectorClient = 0;\n    m_page = 0;\n}\n", "target": 0, "idx": 109203}
{"func": "static int readSeparateStripsIntoBuffer (TIFF *in, uint8 *obuf, uint32 length, \n                                          uint32 width, uint16 spp,\n                                          struct dump_opts *dump)\n   {\n  int i, j, bytes_per_sample, bytes_per_pixel, shift_width, result = 1;\n   int32  bytes_read = 0;\n  uint16 bps, nstrips, planar, strips_per_sample;\n   uint32 src_rowsize, dst_rowsize, rows_processed, rps;\n   uint32 rows_this_strip = 0;\n   tsample_t s;\n  tstrip_t  strip;\n  tsize_t scanlinesize = TIFFScanlineSize(in);\n  tsize_t stripsize    = TIFFStripSize(in);\n  unsigned char *srcbuffs[MAX_SAMPLES];\n  unsigned char *buff = NULL;\n  unsigned char *dst = NULL;\n\n  if (obuf == NULL)\n    {\n    TIFFError(\"readSeparateStripsIntoBuffer\",\"Invalid buffer argument\");\n    return (0);\n    }\n\n  memset (srcbuffs, '\\0', sizeof(srcbuffs));\n  TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bps);\n  TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &planar);\n  TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);\n  if (rps > length)\n    rps = length;\n\n  bytes_per_sample = (bps + 7) / 8; \n  bytes_per_pixel  = ((bps * spp) + 7) / 8;\n  if (bytes_per_pixel < (bytes_per_sample + 1))\n    shift_width = bytes_per_pixel;\n  else\n    shift_width = bytes_per_sample + 1;\n\n  src_rowsize = ((bps * width) + 7) / 8;\n  dst_rowsize = ((bps * width * spp) + 7) / 8;\n  dst = obuf;\n\n  if ((dump->infile != NULL) && (dump->level == 3))\n    {\n    dump_info  (dump->infile, dump->format, \"\", \n                \"Image width %d, length %d, Scanline size, %4d bytes\",\n                width, length,  scanlinesize);\n    dump_info  (dump->infile, dump->format, \"\", \n                \"Bits per sample %d, Samples per pixel %d, Shift width %d\",\n\t\tbps, spp, shift_width);\n    }\n\n  /* Libtiff seems to assume/require that data for separate planes are \n   * written one complete plane after another and not interleaved in any way.\n   * Multiple scanlines and possibly strips of the same plane must be \n   * written before data for any other plane.\n   */\n  nstrips = TIFFNumberOfStrips(in);\n  strips_per_sample = nstrips /spp;\n\n  for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n    {\n    srcbuffs[s] = NULL;\n    buff = _TIFFmalloc(stripsize);\n    if (!buff)\n      {\n      TIFFError (\"readSeparateStripsIntoBuffer\", \n                 \"Unable to allocate strip read buffer for sample %d\", s);\n      for (i = 0; i < s; i++)\n        _TIFFfree (srcbuffs[i]);\n      return 0;\n      }\n    srcbuffs[s] = buff;\n    }\n\n  rows_processed = 0;\n  for (j = 0; (j < strips_per_sample) && (result == 1); j++)\n    {\n    for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n      {\n      buff = srcbuffs[s];\n      strip = (s * strips_per_sample) + j; \n      bytes_read = TIFFReadEncodedStrip (in, strip, buff, stripsize);\n      rows_this_strip = bytes_read / src_rowsize;\n      if (bytes_read < 0 && !ignore)\n        {\n        TIFFError(TIFFFileName(in),\n\t          \"Error, can't read strip %lu for sample %d\",\n         \t   (unsigned long) strip, s + 1);\n        result = 0;\n        break;\n        }\n#ifdef DEVELMODE\n      TIFFError(\"\", \"Strip %2d, read %5d bytes for %4d scanlines, shift width %d\", \n\t\tstrip, bytes_read, rows_this_strip, shift_width);\n#endif\n      }\n\n    if (rps > rows_this_strip)\n      rps = rows_this_strip;\n    dst = obuf + (dst_rowsize * rows_processed);\n    if ((bps % 8) == 0)\n      {\n      if (combineSeparateSamplesBytes (srcbuffs, dst, width, rps,\n                                       spp, bps, dump->infile, \n                                       dump->format, dump->level))\n        {\n        result = 0;\n        break;\n\t}\n      }\n    else\n      {\n      switch (shift_width)\n        {\n        case 1: if (combineSeparateSamples8bits (srcbuffs, dst, width, rps,\n                                                 spp, bps, dump->infile,\n                                                 dump->format, dump->level))\n\t          {\n                  result = 0;\n                  break;\n      \t          }\n\t        break;\n        case 2: if (combineSeparateSamples16bits (srcbuffs, dst, width, rps,\n                                                  spp, bps, dump->infile,\n                                                  dump->format, dump->level))\n\t          {\n                  result = 0;\n                  break;\n\t\t  }\n\t        break;\n        case 3: if (combineSeparateSamples24bits (srcbuffs, dst, width, rps,\n                                                  spp, bps, dump->infile,\n                                                  dump->format, dump->level))\n\t          {\n                  result = 0;\n                  break;\n       \t          }\n                break;\n        case 4: \n        case 5:\n        case 6:\n        case 7:\n        case 8: if (combineSeparateSamples32bits (srcbuffs, dst, width, rps,\n                                                  spp, bps, dump->infile,\n                                                  dump->format, dump->level))\n\t          {\n                  result = 0;\n                  break;\n\t\t  }\n\t        break;\n        default: TIFFError (\"readSeparateStripsIntoBuffer\", \"Unsupported bit depth: %d\", bps);\n                  result = 0;\n                  break;\n        }\n      }\n \n    if ((rows_processed + rps) > length)\n      {\n      rows_processed = length;\n      rps = length - rows_processed;\n      }\n    else\n      rows_processed += rps;\n    }\n\n  /* free any buffers allocated for each plane or scanline and \n   * any temporary buffers \n   */\n  for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n    {\n    buff = srcbuffs[s];\n    if (buff != NULL)\n      _TIFFfree(buff);\n    }\n\n  return (result);\n  } /* end readSeparateStripsIntoBuffer */\n", "target": 1, "idx": 180039}
{"func": "static bool snd_ctl_remove_numid_conflict(struct snd_card *card,\n\t\t\t\t\t  unsigned int count)\n {\n \tstruct snd_kcontrol *kctl;\n \n \tlist_for_each_entry(kctl, &card->controls, list) {\n \t\tif (kctl->id.numid < card->last_numid + 1 + count &&\n \t\t    kctl->id.numid + kctl->count > card->last_numid + 1) {\n\t\t    \tcard->last_numid = kctl->id.numid + kctl->count - 1;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n", "target": 1, "idx": 179462}
{"func": "static int jas_iccputuint(jas_stream_t *out, int n, ulonglong val)\n {\n \tint i;\n \tint c;\n\tfor (i = n; i > 0; --i) {\n\t\tc = (val >> (8 * (i - 1))) & 0xff;\n\t\tif (jas_stream_putc(out, c) == EOF)\n\t\t\treturn -1;\n\t}\n \treturn 0;\n }\n", "target": 1, "idx": 181862}
{"func": "AuthenticatorGenericErrorSheetModel::ForMissingUserVerificationSupport(\n    AuthenticatorRequestDialogModel* dialog_model) {\n  return base::WrapUnique(new AuthenticatorGenericErrorSheetModel(\n      dialog_model,\n      l10n_util::GetStringUTF16(IDS_WEBAUTHN_ERROR_MISSING_CAPABILITY_TITLE),\n      l10n_util::GetStringFUTF16(IDS_WEBAUTHN_MISSING_USER_VERIFICATION_DESC,\n                                 GetRelyingPartyIdString(dialog_model))));\n}\n", "target": 0, "idx": 155536}
{"func": "static void mpage_put_bnr_to_bhs(struct mpage_da_data *mpd, sector_t logical,\n\t\t\t\t struct buffer_head *exbh)\n{\n\tstruct inode *inode = mpd->inode;\n\tstruct address_space *mapping = inode->i_mapping;\n\tint blocks = exbh->b_size >> inode->i_blkbits;\n\tsector_t pblock = exbh->b_blocknr, cur_logical;\n\tstruct buffer_head *head, *bh;\n\tpgoff_t index, end;\n\tstruct pagevec pvec;\n\tint nr_pages, i;\n\n\tindex = logical >> (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\tend = (logical + blocks - 1) >> (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\tcur_logical = index << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\n\tpagevec_init(&pvec, 0);\n\n\twhile (index <= end) {\n\t\t/* XXX: optimize tail */\n\t\tnr_pages = pagevec_lookup(&pvec, mapping, index, PAGEVEC_SIZE);\n\t\tif (nr_pages == 0)\n\t\t\tbreak;\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\tindex = page->index;\n\t\t\tif (index > end)\n\t\t\t\tbreak;\n\t\t\tindex++;\n\n\t\t\tBUG_ON(!PageLocked(page));\n\t\t\tBUG_ON(PageWriteback(page));\n\t\t\tBUG_ON(!page_has_buffers(page));\n\n\t\t\tbh = page_buffers(page);\n\t\t\thead = bh;\n\n\t\t\t/* skip blocks out of the range */\n\t\t\tdo {\n\t\t\t\tif (cur_logical >= logical)\n\t\t\t\t\tbreak;\n\t\t\t\tcur_logical++;\n\t\t\t} while ((bh = bh->b_this_page) != head);\n\n\t\t\tdo {\n\t\t\t\tif (cur_logical >= logical + blocks)\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (buffer_delay(bh) ||\n\t\t\t\t\t\tbuffer_unwritten(bh)) {\n\n\t\t\t\t\tBUG_ON(bh->b_bdev != inode->i_sb->s_bdev);\n\n\t\t\t\t\tif (buffer_delay(bh)) {\n\t\t\t\t\t\tclear_buffer_delay(bh);\n\t\t\t\t\t\tbh->b_blocknr = pblock;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * unwritten already should have\n\t\t\t\t\t\t * blocknr assigned. Verify that\n\t\t\t\t\t\t */\n\t\t\t\t\t\tclear_buffer_unwritten(bh);\n\t\t\t\t\t\tBUG_ON(bh->b_blocknr != pblock);\n\t\t\t\t\t}\n\n \t\t\t\t} else if (buffer_mapped(bh))\n \t\t\t\t\tBUG_ON(bh->b_blocknr != pblock);\n \n \t\t\t\tcur_logical++;\n \t\t\t\tpblock++;\n \t\t\t} while ((bh = bh->b_this_page) != head);\n\t\t}\n\t\tpagevec_release(&pvec);\n\t}\n}\n", "target": 1, "idx": 180724}
{"func": "void RecordDailyContentLengthHistograms(\n    int64 original_length,\n    int64 received_length,\n     int64 original_length_with_data_reduction_enabled,\n     int64 received_length_with_data_reduction_enabled,\n     int64 original_length_via_data_reduction_proxy,\n    int64 received_length_via_data_reduction_proxy) {\n   if (original_length <= 0 || received_length <= 0)\n     return;\n\n  UMA_HISTOGRAM_COUNTS(\n      \"Net.DailyOriginalContentLength\", original_length >> 10);\n  UMA_HISTOGRAM_COUNTS(\n      \"Net.DailyContentLength\", received_length >> 10);\n  int percent = 0;\n  if (original_length > received_length) {\n    percent = (100 * (original_length - received_length)) / original_length;\n  }\n  UMA_HISTOGRAM_PERCENTAGE(\"Net.DailyContentSavingPercent\", percent);\n\n  if (original_length_with_data_reduction_enabled <= 0 ||\n      received_length_with_data_reduction_enabled <= 0) {\n    return;\n  }\n\n  UMA_HISTOGRAM_COUNTS(\n      \"Net.DailyOriginalContentLength_DataReductionProxyEnabled\",\n      original_length_with_data_reduction_enabled >> 10);\n  UMA_HISTOGRAM_COUNTS(\n      \"Net.DailyContentLength_DataReductionProxyEnabled\",\n      received_length_with_data_reduction_enabled >> 10);\n\n  int percent_data_reduction_proxy_enabled = 0;\n  if (original_length_with_data_reduction_enabled >\n      received_length_with_data_reduction_enabled) {\n    percent_data_reduction_proxy_enabled =\n        100 * (original_length_with_data_reduction_enabled -\n               received_length_with_data_reduction_enabled) /\n        original_length_with_data_reduction_enabled;\n  }\n  UMA_HISTOGRAM_PERCENTAGE(\n      \"Net.DailyContentSavingPercent_DataReductionProxyEnabled\",\n      percent_data_reduction_proxy_enabled);\n\n  UMA_HISTOGRAM_PERCENTAGE(\n       \"Net.DailyContentPercent_DataReductionProxyEnabled\",\n       (100 * received_length_with_data_reduction_enabled) / received_length);\n \n   if (original_length_via_data_reduction_proxy <= 0 ||\n       received_length_via_data_reduction_proxy <= 0) {\n     return;\n  }\n\n  UMA_HISTOGRAM_COUNTS(\n      \"Net.DailyOriginalContentLength_ViaDataReductionProxy\",\n      original_length_via_data_reduction_proxy >> 10);\n  UMA_HISTOGRAM_COUNTS(\n      \"Net.DailyContentLength_ViaDataReductionProxy\",\n      received_length_via_data_reduction_proxy >> 10);\n  int percent_via_data_reduction_proxy = 0;\n  if (original_length_via_data_reduction_proxy >\n      received_length_via_data_reduction_proxy) {\n    percent_via_data_reduction_proxy =\n        100 * (original_length_via_data_reduction_proxy -\n               received_length_via_data_reduction_proxy) /\n        original_length_via_data_reduction_proxy;\n  }\n  UMA_HISTOGRAM_PERCENTAGE(\n      \"Net.DailyContentSavingPercent_ViaDataReductionProxy\",\n      percent_via_data_reduction_proxy);\n  UMA_HISTOGRAM_PERCENTAGE(\n      \"Net.DailyContentPercent_ViaDataReductionProxy\",\n      (100 * received_length_via_data_reduction_proxy) / received_length);\n}\n", "target": 1, "idx": 185024}
{"func": "void Browser::ToggleFullscreenModeForTab(TabContents* tab,\n    bool enter_fullscreen) {\n  if (tab != GetSelectedTabContents())\n     return;\n   fullscreened_tab_ = enter_fullscreen ?\n       TabContentsWrapper::GetCurrentWrapperForContents(tab) : NULL;\n  if (enter_fullscreen && !window_->IsFullscreen())\n     tab_caused_fullscreen_ = true;\n  if (tab_caused_fullscreen_)\n     ToggleFullscreenMode();\n }\n", "target": 1, "idx": 183691}
{"func": "int my_csr_reader( const char*           i_csr_file_in,\n                    unsigned int**        o_row_idx,\n                    unsigned int**        o_column_idx,\n                    REALTYPE**            o_values,\n                    unsigned int*         o_row_count,\n                    unsigned int*         o_column_count,\n                    unsigned int*         o_element_count ) {\n  FILE *l_csr_file_handle;\n  const unsigned int l_line_length = 512;\n  char l_line[512/*l_line_length*/+1];\n  unsigned int l_header_read = 0;\n  unsigned int* l_row_idx_id = NULL;\n  unsigned int l_i = 0;\n\n  l_csr_file_handle = fopen( i_csr_file_in, \"r\" );\n  if ( l_csr_file_handle == NULL ) {\n    fprintf( stderr, \"cannot open CSR file!\\n\" );\n    return -1;\n  }\n\n  while (fgets(l_line, l_line_length, l_csr_file_handle) != NULL) {\n    if ( strlen(l_line) == l_line_length ) {\n      fprintf( stderr, \"could not read file length!\\n\" );\n      return -1;\n    }\n    /* check if we are still reading comments header */\n    if ( l_line[0] == '%' ) {\n      continue;\n     } else {\n       /* if we are the first line after comment header, we allocate our data structures */\n       if ( l_header_read == 0 ) {\n        if ( sscanf(l_line, \"%u %u %u\", o_row_count, o_column_count, o_element_count) == 3 ) {\n           /* allocate CSC datastructure matching mtx file */\n           *o_column_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_element_count));\n           *o_row_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_row_count + 1));\n          *o_values = (REALTYPE*) malloc(sizeof(double) * (*o_element_count));\n          l_row_idx_id = (unsigned int*) malloc(sizeof(unsigned int) * (*o_row_count));\n\n          /* check if mallocs were successful */\n          if ( ( *o_row_idx == NULL )      ||\n               ( *o_column_idx == NULL )   ||\n               ( *o_values == NULL )       ||\n               ( l_row_idx_id == NULL ) ) {\n            fprintf( stderr, \"could not allocate sp data!\\n\" );\n            return -1;\n          }\n\n          /* set everything to zero for init */\n          memset(*o_row_idx, 0, sizeof(unsigned int)*(*o_row_count + 1));\n          memset(*o_column_idx, 0, sizeof(unsigned int)*(*o_element_count));\n          memset(*o_values, 0, sizeof(double)*(*o_element_count));\n          memset(l_row_idx_id, 0, sizeof(unsigned int)*(*o_row_count));\n\n          /* init column idx */\n          for ( l_i = 0; l_i < (*o_row_count + 1); l_i++)\n            (*o_row_idx)[l_i] = (*o_element_count);\n\n          /* init */\n          (*o_row_idx)[0] = 0;\n          l_i = 0;\n          l_header_read = 1;\n        } else {\n          fprintf( stderr, \"could not csr description!\\n\" );\n          return -1;\n        }\n      /* now we read the actual content */\n      } else {\n        unsigned int l_row, l_column;\n        REALTYPE l_value;\n        /* read a line of content */\n        if ( sscanf(l_line, \"%u %u %lf\", &l_row, &l_column, &l_value) != 3 ) {\n          fprintf( stderr, \"could not read element!\\n\" );\n          return -1;\n        }\n        /* adjust numbers to zero termination */\n        l_row--;\n        l_column--;\n        /* add these values to row and value structure */\n        (*o_column_idx)[l_i] = l_column;\n        (*o_values)[l_i] = l_value;\n        l_i++;\n        /* handle columns, set id to own for this column, yeah we need to handle empty columns */\n        l_row_idx_id[l_row] = 1;\n        (*o_row_idx)[l_row+1] = l_i;\n      }\n    }\n  }\n\n  /* close mtx file */\n  fclose( l_csr_file_handle );\n\n  /* check if we read a file which was consistent */\n  if ( l_i != (*o_element_count) ) {\n    fprintf( stderr, \"we were not able to read all elements!\\n\" );\n    return -1;\n  }\n\n  /* let's handle empty rows */\n  for ( l_i = 0; l_i < (*o_row_count); l_i++) {\n    if ( l_row_idx_id[l_i] == 0 ) {\n      (*o_row_idx)[l_i+1] = (*o_row_idx)[l_i];\n    }\n  }\n\n  /* free helper data structure */\n  if ( l_row_idx_id != NULL ) {\n    free( l_row_idx_id );\n  }\n  return 0;\n}\n", "target": 1, "idx": 182121}
{"func": "static TEE_Result get_prop_tee_dev_id(struct tee_ta_session *sess __unused,\n\t\t\t\t      void *buf, size_t *blen)\n{\n\tTEE_Result res;\n\tTEE_UUID uuid;\n\tconst size_t nslen = 5;\n\tuint8_t data[5 + FVR_DIE_ID_NUM_REGS * sizeof(uint32_t)] = {\n\t    'O', 'P', 'T', 'E', 'E' };\n\n\tif (*blen < sizeof(uuid)) {\n\t\t*blen = sizeof(uuid);\n\t\treturn TEE_ERROR_SHORT_BUFFER;\n\t}\n\t*blen = sizeof(uuid);\n\n\tif (tee_otp_get_die_id(data + nslen, sizeof(data) - nslen))\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tres = tee_hash_createdigest(TEE_ALG_SHA256, data, sizeof(data),\n\t\t\t\t    (uint8_t *)&uuid, sizeof(uuid));\n\tif (res != TEE_SUCCESS)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\t/*\n\t * Changes the random value into and UUID as specifiec\n\t * in RFC 4122. The magic values are from the example\n\t * code in the RFC.\n\t *\n\t * TEE_UUID is defined slightly different from the RFC,\n\t * but close enough for our purpose.\n\t */\n\n\tuuid.timeHiAndVersion &= 0x0fff;\n\tuuid.timeHiAndVersion |= 5 << 12;\n\n\t/* uuid.clock_seq_hi_and_reserved in the RFC */\n\tuuid.clockSeqAndNode[0] &= 0x3f;\n\tuuid.clockSeqAndNode[0] |= 0x80;\n\n\treturn tee_svc_copy_to_user(buf, &uuid, sizeof(TEE_UUID));\n}\n", "target": 0, "idx": 86908}
{"func": "static int check_id_error(X509_STORE_CTX *ctx, int errcode)\n{\n    ctx->error = errcode;\n    ctx->current_cert = ctx->cert;\n    ctx->error_depth = 0;\n    return ctx->verify_cb(0, ctx);\n}\n", "target": 0, "idx": 8730}
{"func": "WebPage* WebFrame::page() const\n{ \n    if (!m_coreFrame)\n        return 0;\n    \n    if (WebCore::Page* page = m_coreFrame->page())\n        return static_cast<WebChromeClient*>(page->chrome()->client())->page();\n\n    return 0;\n}\n", "target": 0, "idx": 98262}
{"func": "SYSCALL_DEFINE2(io_setup, unsigned, nr_events, aio_context_t __user *, ctxp)\n{\n\tstruct kioctx *ioctx = NULL;\n\tunsigned long ctx;\n\tlong ret;\n\n\tret = get_user(ctx, ctxp);\n\tif (unlikely(ret))\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tif (unlikely(ctx || nr_events == 0)) {\n\t\tpr_debug(\"EINVAL: io_setup: ctx %lu nr_events %u\\n\",\n\t\t         ctx, nr_events);\n\t\tgoto out;\n\t}\n\n\tioctx = ioctx_alloc(nr_events);\n\tret = PTR_ERR(ioctx);\n\tif (!IS_ERR(ioctx)) {\n\t\tret = put_user(ioctx->user_id, ctxp);\n\t\tif (ret)\n\t\t\tkill_ioctx(current->mm, ioctx);\n\t\tpercpu_ref_put(&ioctx->users);\n\t}\n\nout:\n\treturn ret;\n}\n", "target": 0, "idx": 40087}
{"func": "static void CreateShader(\n    GLuint program, GLenum type, const char* source, int size) {\n  GLuint shader = glCreateShader(type);\n  glShaderSource(shader, 1, &source, &size);\n  glCompileShader(shader);\n  int result = GL_FALSE;\n  glGetShaderiv(shader, GL_COMPILE_STATUS, &result);\n  if (!result) {\n    char log[4096];\n    glGetShaderInfoLog(shader, arraysize(log), NULL, log);\n    LOG(FATAL) << log;\n  }\n  glAttachShader(program, shader);\n  glDeleteShader(shader);\n  CHECK_EQ(static_cast<int>(glGetError()), GL_NO_ERROR);\n}\n", "target": 0, "idx": 114460}
{"func": "static void snd_timer_user_ccallback(struct snd_timer_instance *timeri,\n\t\t\t\t     int event,\n\t\t\t\t     struct timespec *tstamp,\n\t\t\t\t     unsigned long resolution)\n{\n\tstruct snd_timer_user *tu = timeri->callback_data;\n\tstruct snd_timer_tread r1;\n\tunsigned long flags;\n\n\tif (event >= SNDRV_TIMER_EVENT_START &&\n\t    event <= SNDRV_TIMER_EVENT_PAUSE)\n \t\ttu->tstamp = *tstamp;\n \tif ((tu->filter & (1 << event)) == 0 || !tu->tread)\n \t\treturn;\n \tr1.event = event;\n \tr1.tstamp = *tstamp;\n \tr1.val = resolution;\n\tspin_lock_irqsave(&tu->qlock, flags);\n\tsnd_timer_user_append_to_tqueue(tu, &r1);\n\tspin_unlock_irqrestore(&tu->qlock, flags);\n\tkill_fasync(&tu->fasync, SIGIO, POLL_IN);\n\twake_up(&tu->qchange_sleep);\n}\n", "target": 1, "idx": 183141}
{"func": "  virtual bool OnMessageReceived(const IPC::Message& message) {\n    DCHECK(context_->ui_task_runner()->BelongsToCurrentThread());\n\n#if defined(REMOTING_MULTI_PROCESS)\n    bool handled = true;\n    IPC_BEGIN_MESSAGE_MAP(HostProcess, message)\n        IPC_MESSAGE_HANDLER(ChromotingDaemonNetworkMsg_Configuration,\n                            OnConfigUpdated)\n        IPC_MESSAGE_UNHANDLED(handled = false)\n    IPC_END_MESSAGE_MAP()\n    return handled;\n#else  // !defined(REMOTING_MULTI_PROCESS)\n    return false;\n#endif  // !defined(REMOTING_MULTI_PROCESS)\n  }\n", "target": 0, "idx": 122029}
{"func": "void efx_link_set_advertising(struct efx_nic *efx, u32 advertising)\n{\n\tefx->link_advertising = advertising;\n\tif (advertising) {\n\t\tif (advertising & ADVERTISED_Pause)\n\t\t\tefx->wanted_fc |= (EFX_FC_TX | EFX_FC_RX);\n\t\telse\n\t\t\tefx->wanted_fc &= ~(EFX_FC_TX | EFX_FC_RX);\n\t\tif (advertising & ADVERTISED_Asym_Pause)\n\t\t\tefx->wanted_fc ^= EFX_FC_TX;\n\t}\n}\n", "target": 0, "idx": 19385}
{"func": "static unsigned int ipv4_default_advmss(const struct dst_entry *dst)\n{\n\tunsigned int header_size = sizeof(struct tcphdr) + sizeof(struct iphdr);\n\tunsigned int advmss = max_t(unsigned int, ipv4_mtu(dst) - header_size,\n\t\t\t\t    ip_rt_min_advmss);\n\n\treturn min(advmss, IPV4_MAX_PMTU - header_size);\n}\n", "target": 0, "idx": 91136}
{"func": "chdlc_print(netdissect_options *ndo, register const u_char *p, u_int length)\n{\n\tu_int proto;\n\tconst u_char *bp = p;\n\n\tif (length < CHDLC_HDRLEN)\n\t\tgoto trunc;\n\tND_TCHECK2(*p, CHDLC_HDRLEN);\n\tproto = EXTRACT_16BITS(&p[2]);\n\tif (ndo->ndo_eflag) {\n                ND_PRINT((ndo, \"%s, ethertype %s (0x%04x), length %u: \",\n                       tok2str(chdlc_cast_values, \"0x%02x\", p[0]),\n                       tok2str(ethertype_values, \"Unknown\", proto),\n                       proto,\n                       length));\n\t}\n\n\tlength -= CHDLC_HDRLEN;\n\tp += CHDLC_HDRLEN;\n\n\tswitch (proto) {\n\tcase ETHERTYPE_IP:\n\t\tip_print(ndo, p, length);\n\t\tbreak;\n\tcase ETHERTYPE_IPV6:\n\t\tip6_print(ndo, p, length);\n\t\tbreak;\n\tcase CHDLC_TYPE_SLARP:\n\t\tchdlc_slarp_print(ndo, p, length);\n\t\tbreak;\n#if 0\n\tcase CHDLC_TYPE_CDP:\n\t\tchdlc_cdp_print(p, length);\n\t\tbreak;\n#endif\n        case ETHERTYPE_MPLS:\n        case ETHERTYPE_MPLS_MULTI:\n                mpls_print(ndo, p, length);\n\t\tbreak;\n        case ETHERTYPE_ISO:\n                /* is the fudge byte set ? lets verify by spotting ISO headers */\n                if (length < 2)\n                    goto trunc;\n                ND_TCHECK_16BITS(p);\n                 if (*(p+1) == 0x81 ||\n                     *(p+1) == 0x82 ||\n                     *(p+1) == 0x83)\n                    isoclns_print(ndo, p + 1, length - 1, ndo->ndo_snapend - p - 1);\n                 else\n                    isoclns_print(ndo, p, length, ndo->ndo_snapend - p);\n                 break;\n \tdefault:\n                 if (!ndo->ndo_eflag)\n                        ND_PRINT((ndo, \"unknown CHDLC protocol (0x%04x)\", proto));\n                break;\n\t}\n\n\treturn (CHDLC_HDRLEN);\n\ntrunc:\n\tND_PRINT((ndo, \"[|chdlc]\"));\n\treturn ndo->ndo_snapend - bp;\n}\n", "target": 1, "idx": 181115}
{"func": " static void sctp_generate_timeout_event(struct sctp_association *asoc,\n \t\t\t\t\tsctp_event_timeout_t timeout_type)\n {\n\tstruct net *net = sock_net(asoc->base.sk);\n \tint error = 0;\n \n\tbh_lock_sock(asoc->base.sk);\n\tif (sock_owned_by_user(asoc->base.sk)) {\n \t\tpr_debug(\"%s: sock is busy: timer %d\\n\", __func__,\n \t\t\t timeout_type);\n \n\t\t/* Try again later.  */\n\t\tif (!mod_timer(&asoc->timers[timeout_type], jiffies + (HZ/20)))\n\t\t\tsctp_association_hold(asoc);\n\t\tgoto out_unlock;\n\t}\n\n\t/* Is this association really dead and just waiting around for\n\t * the timer to let go of the reference?\n\t */\n\tif (asoc->base.dead)\n\t\tgoto out_unlock;\n\n\t/* Run through the state machine.  */\n\terror = sctp_do_sm(net, SCTP_EVENT_T_TIMEOUT,\n\t\t\t   SCTP_ST_TIMEOUT(timeout_type),\n\t\t\t   asoc->state, asoc->ep, asoc,\n \t\t\t   (void *)timeout_type, GFP_ATOMIC);\n \n \tif (error)\n\t\tasoc->base.sk->sk_err = -error;\n \n out_unlock:\n\tbh_unlock_sock(asoc->base.sk);\n \tsctp_association_put(asoc);\n }\n", "target": 1, "idx": 180675}
{"func": " cib_remote_perform_op(cib_t * cib, const char *op, const char *host, const char *section,\n                       xmlNode * data, xmlNode ** output_data, int call_options, const char *name)\n {\n     int rc = pcmk_ok;\n \n     xmlNode *op_msg = NULL;\n     xmlNode *op_reply = NULL;\n \n     cib_remote_opaque_t *private = cib->variant_opaque;\n \n    if (sync_timer == NULL) {\n        sync_timer = calloc(1, sizeof(struct timer_rec_s));\n    }\n     if (cib->state == cib_disconnected) {\n         return -ENOTCONN;\n     }\n\n    if (output_data != NULL) {\n        *output_data = NULL;\n    }\n\n    if (op == NULL) {\n        crm_err(\"No operation specified\");\n        return -EINVAL;\n    }\n\n    cib->call_id++;\n    /* prevent call_id from being negative (or zero) and conflicting\n     *    with the cib_errors enum\n     * use 2 because we use it as (cib->call_id - 1) below\n     */\n    if (cib->call_id < 1) {\n        cib->call_id = 1;\n    }\n\n    op_msg =\n        cib_create_op(cib->call_id, private->callback.token, op, host, section, data, call_options,\n                      NULL);\n    if (op_msg == NULL) {\n        return -EPROTO;\n     }\n \n     crm_trace(\"Sending %s message to CIB service\", op);\n    crm_send_remote_msg(private->command.session, op_msg, private->command.encrypted);\n     free_xml(op_msg);\n \n     if ((call_options & cib_discard_reply)) {\n        crm_trace(\"Discarding reply\");\n        return pcmk_ok;\n\n    } else if (!(call_options & cib_sync_call)) {\n        return cib->call_id;\n    }\n \n     crm_trace(\"Waiting for a syncronous reply\");\n \n    if (cib->call_timeout > 0) {\n        /* We need this, even with msgfromIPC_timeout(), because we might\n         * get other/older replies that don't match the active request\n         */\n        timer_expired = FALSE;\n        sync_timer->call_id = cib->call_id;\n        sync_timer->timeout = cib->call_timeout * 1000;\n        sync_timer->ref = g_timeout_add(sync_timer->timeout, cib_timeout_handler, sync_timer);\n    }\n \n    while (timer_expired == FALSE) {\n         int reply_id = -1;\n         int msg_id = cib->call_id;\n \n        op_reply = crm_recv_remote_msg(private->command.session, private->command.encrypted);\n        if (op_reply == NULL) {\n             break;\n         }\n \n         crm_element_value_int(op_reply, F_CIB_CALLID, &reply_id);\n        CRM_CHECK(reply_id > 0, free_xml(op_reply);\n                  if (sync_timer->ref > 0) {\n                  g_source_remove(sync_timer->ref); sync_timer->ref = 0;}\n                  return -ENOMSG) ;\n \n         if (reply_id == msg_id) {\n             break;\n\n        } else if (reply_id < msg_id) {\n            crm_debug(\"Received old reply: %d (wanted %d)\", reply_id, msg_id);\n            crm_log_xml_trace(op_reply, \"Old reply\");\n\n        } else if ((reply_id - 10000) > msg_id) {\n            /* wrap-around case */\n            crm_debug(\"Received old reply: %d (wanted %d)\", reply_id, msg_id);\n            crm_log_xml_trace(op_reply, \"Old reply\");\n        } else {\n            crm_err(\"Received a __future__ reply:\" \" %d (wanted %d)\", reply_id, msg_id);\n        }\n \n         free_xml(op_reply);\n         op_reply = NULL;\n    }\n    if (sync_timer->ref > 0) {\n        g_source_remove(sync_timer->ref);\n        sync_timer->ref = 0;\n    }\n \n    if (timer_expired) {\n        return -ETIME;\n     }\n \n     /* if(IPC_ISRCONN(native->command_channel) == FALSE) { */\n    /*      crm_err(\"CIB disconnected: %d\",  */\n    /*              native->command_channel->ch_status); */\n     /*      cib->state = cib_disconnected; */\n     /* } */\n \n    if (op_reply == NULL) {\n         crm_err(\"No reply message - empty\");\n         return -ENOMSG;\n     }\n\n    crm_trace(\"Syncronous reply received\");\n\n    /* Start processing the reply... */\n    if (crm_element_value_int(op_reply, F_CIB_RC, &rc) != 0) {\n        rc = -EPROTO;\n    }\n\n    if (rc == -pcmk_err_diff_resync) {\n        /* This is an internal value that clients do not and should not care about */\n        rc = pcmk_ok;\n    }\n\n    if (rc == pcmk_ok || rc == -EPERM) {\n        crm_log_xml_debug(op_reply, \"passed\");\n\n    } else {\n/* \t} else if(rc == -ETIME) { */\n        crm_err(\"Call failed: %s\", pcmk_strerror(rc));\n        crm_log_xml_warn(op_reply, \"failed\");\n    }\n\n    if (output_data == NULL) {\n        /* do nothing more */\n\n    } else if (!(call_options & cib_discard_reply)) {\n        xmlNode *tmp = get_message_xml(op_reply, F_CIB_CALLDATA);\n\n        if (tmp == NULL) {\n            crm_trace(\"No output in reply to \\\"%s\\\" command %d\", op, cib->call_id - 1);\n        } else {\n            *output_data = copy_xml(tmp);\n        }\n    }\n\n    free_xml(op_reply);\n\n    return rc;\n}\n", "target": 1, "idx": 179324}
{"func": "setPath(JsonbIterator **it, Datum *path_elems,\n\t\tbool *path_nulls, int path_len,\n\t\tJsonbParseState **st, int level, Jsonb *newval, bool create)\n{\n\tJsonbValue\tv;\n    JsonbValue *res = NULL;\n    int         r;\n \n    if (path_nulls[level])\n        elog(ERROR, \"path element at the position %d is NULL\", level + 1);\n\tswitch (r)\n\t{\n\t\tcase WJB_BEGIN_ARRAY:\n\t\t\t(void) pushJsonbValue(st, r, NULL);\n\t\t\tsetPathArray(it, path_elems, path_nulls, path_len, st, level,\n\t\t\t\t\t\t newval, v.val.array.nElems, create);\n\t\t\tr = JsonbIteratorNext(it, &v, false);\n\t\t\tAssert(r == WJB_END_ARRAY);\n\t\t\tres = pushJsonbValue(st, r, NULL);\n\n\t\t\tbreak;\n\t\tcase WJB_BEGIN_OBJECT:\n\t\t\t(void) pushJsonbValue(st, r, NULL);\n\t\t\tsetPathObject(it, path_elems, path_nulls, path_len, st, level,\n\t\t\t\t\t\t  newval, v.val.object.nPairs, create);\n\t\t\tr = JsonbIteratorNext(it, &v, true);\n\t\t\tAssert(r == WJB_END_OBJECT);\n\t\t\tres = pushJsonbValue(st, r, NULL);\n\n\t\t\tbreak;\n\t\tcase WJB_ELEM:\n\t\tcase WJB_VALUE:\n\t\t\tres = pushJsonbValue(st, r, &v);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"impossible state\");\n\t}\n\n\treturn res;\n}\n", "target": 1, "idx": 177853}
{"func": "static int svm_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tu32 ecx = msr->index;\n\tu64 data = msr->data;\n\tswitch (ecx) {\n\tcase MSR_IA32_TSC:\n\t\tkvm_write_tsc(vcpu, msr);\n\t\tbreak;\n\tcase MSR_STAR:\n\t\tsvm->vmcb->save.star = data;\n\t\tbreak;\n#ifdef CONFIG_X86_64\n\tcase MSR_LSTAR:\n\t\tsvm->vmcb->save.lstar = data;\n\t\tbreak;\n\tcase MSR_CSTAR:\n\t\tsvm->vmcb->save.cstar = data;\n\t\tbreak;\n\tcase MSR_KERNEL_GS_BASE:\n\t\tsvm->vmcb->save.kernel_gs_base = data;\n\t\tbreak;\n\tcase MSR_SYSCALL_MASK:\n\t\tsvm->vmcb->save.sfmask = data;\n\t\tbreak;\n#endif\n\tcase MSR_IA32_SYSENTER_CS:\n\t\tsvm->vmcb->save.sysenter_cs = data;\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_EIP:\n\t\tsvm->sysenter_eip = data;\n\t\tsvm->vmcb->save.sysenter_eip = data;\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_ESP:\n\t\tsvm->sysenter_esp = data;\n\t\tsvm->vmcb->save.sysenter_esp = data;\n\t\tbreak;\n\tcase MSR_IA32_DEBUGCTLMSR:\n\t\tif (!boot_cpu_has(X86_FEATURE_LBRV)) {\n\t\t\tvcpu_unimpl(vcpu, \"%s: MSR_IA32_DEBUGCTL 0x%llx, nop\\n\",\n\t\t\t\t    __func__, data);\n\t\t\tbreak;\n\t\t}\n\t\tif (data & DEBUGCTL_RESERVED_BITS)\n\t\t\treturn 1;\n\n\t\tsvm->vmcb->save.dbgctl = data;\n\t\tmark_dirty(svm->vmcb, VMCB_LBR);\n\t\tif (data & (1ULL<<0))\n\t\t\tsvm_enable_lbrv(svm);\n\t\telse\n\t\t\tsvm_disable_lbrv(svm);\n\t\tbreak;\n\tcase MSR_VM_HSAVE_PA:\n\t\tsvm->nested.hsave_msr = data;\n\t\tbreak;\n\tcase MSR_VM_CR:\n\t\treturn svm_set_vm_cr(vcpu, data);\n\tcase MSR_VM_IGNNE:\n\t\tvcpu_unimpl(vcpu, \"unimplemented wrmsr: 0x%x data 0x%llx\\n\", ecx, data);\n\t\tbreak;\n\tdefault:\n\t\treturn kvm_set_msr_common(vcpu, msr);\n\t}\n\treturn 0;\n}\n", "target": 0, "idx": 37897}
{"func": "void BinaryUploadService::OnUploadComplete(Request* request,\n                                           bool success,\n                                           const std::string& response_data) {\n  if (!IsActive(request))\n    return;\n\n  if (!success) {\n    FinishRequest(request, Result::UPLOAD_FAILURE,\n                  DeepScanningClientResponse());\n    return;\n  }\n\n  DeepScanningClientResponse response;\n  if (!response.ParseFromString(response_data)) {\n    FinishRequest(request, Result::UPLOAD_FAILURE,\n                  DeepScanningClientResponse());\n    return;\n  }\n\n  active_uploads_.erase(request);\n\n  OnGetResponse(request, response);\n}\n", "target": 0, "idx": 149356}
{"func": "void DevToolsHttpHandler::OnJsonRequest(\n    int connection_id,\n    const net::HttpServerRequestInfo& info) {\n  std::string path = info.path.substr(5);\n\n  std::string query;\n  size_t query_pos = path.find(\"?\");\n  if (query_pos != std::string::npos) {\n    query = path.substr(query_pos + 1);\n    path = path.substr(0, query_pos);\n  }\n\n  size_t fragment_pos = path.find(\"#\");\n  if (fragment_pos != std::string::npos)\n    path = path.substr(0, fragment_pos);\n\n  std::string command;\n  std::string target_id;\n  if (!ParseJsonPath(path, &command, &target_id)) {\n    SendJson(connection_id, net::HTTP_NOT_FOUND, nullptr,\n             \"Malformed query: \" + info.path);\n    return;\n  }\n\n  if (command == \"version\") {\n    base::DictionaryValue version;\n    version.SetString(\"Protocol-Version\",\n                      DevToolsAgentHost::GetProtocolVersion());\n    version.SetString(\"WebKit-Version\", GetWebKitVersion());\n    version.SetString(\"Browser\", GetContentClient()->GetProduct());\n    version.SetString(\"User-Agent\", GetContentClient()->GetUserAgent());\n    version.SetString(\"V8-Version\", V8_VERSION_STRING);\n    std::string host = info.headers[\"host\"];\n    version.SetString(\n        kTargetWebSocketDebuggerUrlField,\n        base::StringPrintf(\"ws://%s%s\", host.c_str(), browser_guid_.c_str()));\n#if defined(OS_ANDROID)\n    version.SetString(\n        \"Android-Package\",\n        base::android::BuildInfo::GetInstance()->host_package_name());\n#endif\n    SendJson(connection_id, net::HTTP_OK, &version, std::string());\n    return;\n  }\n\n  if (command == \"protocol\") {\n    DecompressAndSendJsonProtocol(connection_id);\n    return;\n  }\n\n  if (command == \"list\") {\n    DevToolsManager* manager = DevToolsManager::GetInstance();\n    DevToolsAgentHost::List list =\n        manager->delegate() ? manager->delegate()->RemoteDebuggingTargets()\n                            : DevToolsAgentHost::GetOrCreateAll();\n    RespondToJsonList(connection_id, info.headers[\"host\"], std::move(list));\n    return;\n  }\n\n  if (command == \"new\") {\n    GURL url(net::UnescapeURLComponent(\n        query, net::UnescapeRule::URL_SPECIAL_CHARS_EXCEPT_PATH_SEPARATORS |\n                   net::UnescapeRule::PATH_SEPARATORS));\n    if (!url.is_valid())\n      url = GURL(url::kAboutBlankURL);\n    scoped_refptr<DevToolsAgentHost> agent_host = nullptr;\n    agent_host = delegate_->CreateNewTarget(url);\n    if (!agent_host) {\n      SendJson(connection_id, net::HTTP_INTERNAL_SERVER_ERROR, nullptr,\n               \"Could not create new page\");\n      return;\n    }\n    std::string host = info.headers[\"host\"];\n    std::unique_ptr<base::DictionaryValue> dictionary(\n        SerializeDescriptor(agent_host, host));\n    SendJson(connection_id, net::HTTP_OK, dictionary.get(), std::string());\n    return;\n  }\n\n  if (command == \"activate\" || command == \"close\") {\n    scoped_refptr<DevToolsAgentHost> agent_host =\n        DevToolsAgentHost::GetForId(target_id);\n    if (!agent_host) {\n      SendJson(connection_id, net::HTTP_NOT_FOUND, nullptr,\n               \"No such target id: \" + target_id);\n      return;\n    }\n\n    if (command == \"activate\") {\n      if (agent_host->Activate()) {\n        SendJson(connection_id, net::HTTP_OK, nullptr, \"Target activated\");\n      } else {\n        SendJson(connection_id, net::HTTP_INTERNAL_SERVER_ERROR, nullptr,\n                 \"Could not activate target id: \" + target_id);\n      }\n      return;\n    }\n\n    if (command == \"close\") {\n      if (agent_host->Close()) {\n        SendJson(connection_id, net::HTTP_OK, nullptr, \"Target is closing\");\n      } else {\n        SendJson(connection_id, net::HTTP_INTERNAL_SERVER_ERROR, nullptr,\n                 \"Could not close target id: \" + target_id);\n      }\n      return;\n    }\n  }\n  SendJson(connection_id, net::HTTP_NOT_FOUND, nullptr,\n           \"Unknown command: \" + command);\n  return;\n}\n", "target": 0, "idx": 161068}
{"func": "void SoftOpus::initPorts() {\n    OMX_PARAM_PORTDEFINITIONTYPE def;\n InitOMXParams(&def);\n\n    def.nPortIndex = 0;\n    def.eDir = OMX_DirInput;\n    def.nBufferCountMin = kNumBuffers;\n    def.nBufferCountActual = def.nBufferCountMin;\n    def.nBufferSize = 960 * 6;\n    def.bEnabled = OMX_TRUE;\n    def.bPopulated = OMX_FALSE;\n    def.eDomain = OMX_PortDomainAudio;\n    def.bBuffersContiguous = OMX_FALSE;\n    def.nBufferAlignment = 1;\n\n    def.format.audio.cMIMEType =\n const_cast<char *>(MEDIA_MIMETYPE_AUDIO_OPUS);\n\n    def.format.audio.pNativeRender = NULL;\n    def.format.audio.bFlagErrorConcealment = OMX_FALSE;\n    def.format.audio.eEncoding =\n (OMX_AUDIO_CODINGTYPE)OMX_AUDIO_CodingAndroidOPUS;\n\n    addPort(def);\n\n    def.nPortIndex = 1;\n    def.eDir = OMX_DirOutput;\n    def.nBufferCountMin = kNumBuffers;\n    def.nBufferCountActual = def.nBufferCountMin;\n    def.nBufferSize = kMaxNumSamplesPerBuffer * sizeof(int16_t) * kMaxChannels;\n    def.bEnabled = OMX_TRUE;\n    def.bPopulated = OMX_FALSE;\n    def.eDomain = OMX_PortDomainAudio;\n    def.bBuffersContiguous = OMX_FALSE;\n    def.nBufferAlignment = 2;\n\n    def.format.audio.cMIMEType = const_cast<char *>(\"audio/raw\");\n    def.format.audio.pNativeRender = NULL;\n    def.format.audio.bFlagErrorConcealment = OMX_FALSE;\n    def.format.audio.eEncoding = OMX_AUDIO_CodingPCM;\n\n    addPort(def);\n}\n", "target": 0, "idx": 173781}
{"func": "BrightnessLibrary* CrosLibrary::GetBrightnessLibrary() {\n  return brightness_lib_.GetDefaultImpl(use_stub_impl_);\n}\n", "target": 1, "idx": 184088}
{"func": "pdf14_buf_new(gs_int_rect *rect, bool has_tags, bool has_alpha_g,\n              bool has_shape, bool idle, int n_chan, int num_spots,\n              gs_memory_t *memory)\n{\n\n    /* Note that alpha_g is the alpha for the GROUP */\n    /* This is distinct from the alpha that may also exist */\n    /* for the objects within the group.  Hence it can introduce */\n    /* yet another plane */\n\n    pdf14_buf *result;\n    pdf14_parent_color_t *new_parent_color;\n    int rowstride = (rect->q.x - rect->p.x + 3) & -4;\n    int height = (rect->q.y - rect->p.y);\n    int n_planes = n_chan + (has_shape ? 1 : 0) + (has_alpha_g ? 1 : 0) +\n                   (has_tags ? 1 : 0);\n    int planestride;\n    double dsize = (((double) rowstride) * height) * n_planes;\n\n    if (dsize > (double)max_uint)\n      return NULL;\n\n    result = gs_alloc_struct(memory, pdf14_buf, &st_pdf14_buf,\n                             \"pdf14_buf_new\");\n    if (result == NULL)\n        return result;\n\n    result->memory = memory;\n    result->backdrop = NULL;\n    result->saved = NULL;\n    result->isolated = false;\n    result->knockout = false;\n    result->has_alpha_g = has_alpha_g;\n    result->has_shape = has_shape;\n    result->has_tags = has_tags;\n    result->rect = *rect;\n    result->n_chan = n_chan;\n    result->n_planes = n_planes;\n    result->rowstride = rowstride;\n    result->transfer_fn = NULL;\n    result->matte_num_comps = 0;\n    result->matte = NULL;\n    result->mask_stack = NULL;\n    result->idle = idle;\n    result->mask_id = 0;\n    result->num_spots = num_spots;\n    new_parent_color = gs_alloc_struct(memory, pdf14_parent_color_t, &st_pdf14_clr,\n                                                \"pdf14_buf_new\");\n    if (new_parent_color == NULL) {\n        gs_free_object(memory, result, \"pdf14_buf_new\");\n        return NULL;\n    }\n\n    result->parent_color_info_procs = new_parent_color;\n    result->parent_color_info_procs->get_cmap_procs = NULL;\n    result->parent_color_info_procs->parent_color_mapping_procs = NULL;\n    result->parent_color_info_procs->parent_color_comp_index = NULL;\n    result->parent_color_info_procs->icc_profile = NULL;\n    result->parent_color_info_procs->previous = NULL;\n    result->parent_color_info_procs->encode = NULL;\n    result->parent_color_info_procs->decode = NULL;\n    if (idle || height <= 0) {\n        /* Empty clipping - will skip all drawings. */\n        result->planestride = 0;\n        result->data = 0;\n    } else {\n        planestride = rowstride * height;\n        result->planestride = planestride;\n        result->data = gs_alloc_bytes(memory, planestride * n_planes,\n                                        \"pdf14_buf_new\");\n        if (result->data == NULL) {\n            gs_free_object(memory, result, \"pdf14_buf_new\");\n            return NULL;\n        }\n        if (has_alpha_g) {\n            int alpha_g_plane = n_chan + (has_shape ? 1 : 0);\n            memset (result->data + alpha_g_plane * planestride, 0, planestride);\n        }\n        if (has_tags) {\n            int tags_plane = n_chan + (has_shape ? 1 : 0) + (has_alpha_g ? 1 : 0);\n            memset (result->data + tags_plane * planestride,\n                    GS_UNTOUCHED_TAG, planestride);\n        }\n    }\n    /* Initialize dirty box with an invalid rectangle (the reversed rectangle).\n     * Any future drawing will make it valid again, so we won't blend back\n     * more than we need. */\n    result->dirty.p.x = rect->q.x;\n    result->dirty.p.y = rect->q.y;\n    result->dirty.q.x = rect->p.x;\n    result->dirty.q.y = rect->p.y;\n    return result;\n}\n", "target": 0, "idx": 2934}
{"func": "static void vmsvga_fifo_run(struct vmsvga_state_s *s)\n{\n    uint32_t cmd, colour;\n    int args, len, maxloop = 1024;\n    int x, y, dx, dy, width, height;\n    struct vmsvga_cursor_definition_s cursor;\n    uint32_t cmd_start;\n\n    len = vmsvga_fifo_length(s);\n    while (len > 0 && --maxloop > 0) {\n        /* May need to go back to the start of the command if incomplete */\n        cmd_start = s->fifo_stop;\n\n        switch (cmd = vmsvga_fifo_read(s)) {\n        case SVGA_CMD_UPDATE:\n        case SVGA_CMD_UPDATE_VERBOSE:\n            len -= 5;\n            if (len < 0) {\n                goto rewind;\n            }\n\n            x = vmsvga_fifo_read(s);\n            y = vmsvga_fifo_read(s);\n            width = vmsvga_fifo_read(s);\n            height = vmsvga_fifo_read(s);\n            vmsvga_update_rect_delayed(s, x, y, width, height);\n            break;\n\n        case SVGA_CMD_RECT_FILL:\n            len -= 6;\n            if (len < 0) {\n                goto rewind;\n            }\n\n            colour = vmsvga_fifo_read(s);\n            x = vmsvga_fifo_read(s);\n            y = vmsvga_fifo_read(s);\n            width = vmsvga_fifo_read(s);\n            height = vmsvga_fifo_read(s);\n#ifdef HW_FILL_ACCEL\n            if (vmsvga_fill_rect(s, colour, x, y, width, height) == 0) {\n                break;\n            }\n#endif\n            args = 0;\n            goto badcmd;\n\n        case SVGA_CMD_RECT_COPY:\n            len -= 7;\n            if (len < 0) {\n                goto rewind;\n            }\n\n            x = vmsvga_fifo_read(s);\n            y = vmsvga_fifo_read(s);\n            dx = vmsvga_fifo_read(s);\n            dy = vmsvga_fifo_read(s);\n            width = vmsvga_fifo_read(s);\n            height = vmsvga_fifo_read(s);\n#ifdef HW_RECT_ACCEL\n            if (vmsvga_copy_rect(s, x, y, dx, dy, width, height) == 0) {\n                break;\n            }\n#endif\n            args = 0;\n            goto badcmd;\n\n        case SVGA_CMD_DEFINE_CURSOR:\n            len -= 8;\n            if (len < 0) {\n                goto rewind;\n            }\n\n            cursor.id = vmsvga_fifo_read(s);\n            cursor.hot_x = vmsvga_fifo_read(s);\n            cursor.hot_y = vmsvga_fifo_read(s);\n            cursor.width = x = vmsvga_fifo_read(s);\n            cursor.height = y = vmsvga_fifo_read(s);\n            vmsvga_fifo_read(s);\n             cursor.bpp = vmsvga_fifo_read(s);\n \n             args = SVGA_BITMAP_SIZE(x, y) + SVGA_PIXMAP_SIZE(x, y, cursor.bpp);\n            if (cursor.width > 256 ||\n                cursor.height > 256 ||\n                cursor.bpp > 32 ||\n                SVGA_BITMAP_SIZE(x, y) > sizeof cursor.mask ||\n                SVGA_PIXMAP_SIZE(x, y, cursor.bpp) > sizeof cursor.image) {\n                     goto badcmd;\n             }\n                goto rewind;\n            }\n\n            for (args = 0; args < SVGA_BITMAP_SIZE(x, y); args++) {\n                cursor.mask[args] = vmsvga_fifo_read_raw(s);\n            }\n            for (args = 0; args < SVGA_PIXMAP_SIZE(x, y, cursor.bpp); args++) {\n                cursor.image[args] = vmsvga_fifo_read_raw(s);\n            }\n#ifdef HW_MOUSE_ACCEL\n            vmsvga_cursor_define(s, &cursor);\n            break;\n#else\n            args = 0;\n            goto badcmd;\n#endif\n\n        /*\n         * Other commands that we at least know the number of arguments\n         * for so we can avoid FIFO desync if driver uses them illegally.\n         */\n        case SVGA_CMD_DEFINE_ALPHA_CURSOR:\n            len -= 6;\n            if (len < 0) {\n                goto rewind;\n            }\n            vmsvga_fifo_read(s);\n            vmsvga_fifo_read(s);\n            vmsvga_fifo_read(s);\n            x = vmsvga_fifo_read(s);\n            y = vmsvga_fifo_read(s);\n            args = x * y;\n            goto badcmd;\n        case SVGA_CMD_RECT_ROP_FILL:\n            args = 6;\n            goto badcmd;\n        case SVGA_CMD_RECT_ROP_COPY:\n            args = 7;\n            goto badcmd;\n        case SVGA_CMD_DRAW_GLYPH_CLIPPED:\n            len -= 4;\n            if (len < 0) {\n                goto rewind;\n            }\n            vmsvga_fifo_read(s);\n            vmsvga_fifo_read(s);\n            args = 7 + (vmsvga_fifo_read(s) >> 2);\n            goto badcmd;\n        case SVGA_CMD_SURFACE_ALPHA_BLEND:\n            args = 12;\n            goto badcmd;\n\n        /*\n         * Other commands that are not listed as depending on any\n         * CAPABILITIES bits, but are not described in the README either.\n         */\n        case SVGA_CMD_SURFACE_FILL:\n        case SVGA_CMD_SURFACE_COPY:\n        case SVGA_CMD_FRONT_ROP_FILL:\n        case SVGA_CMD_FENCE:\n        case SVGA_CMD_INVALID_CMD:\n            break; /* Nop */\n\n        default:\n            args = 0;\n        badcmd:\n            len -= args;\n            if (len < 0) {\n                goto rewind;\n            }\n            while (args--) {\n                vmsvga_fifo_read(s);\n            }\n            printf(\"%s: Unknown command 0x%02x in SVGA command FIFO\\n\",\n                   __func__, cmd);\n            break;\n\n        rewind:\n            s->fifo_stop = cmd_start;\n            s->fifo[SVGA_FIFO_STOP] = cpu_to_le32(s->fifo_stop);\n            break;\n        }\n    }\n", "target": 1, "idx": 178104}
{"func": "bool HTMLMediaElement::shouldShowControls(\n    const RecordMetricsBehavior recordMetrics) const {\n  if (fastHasAttribute(controlsAttr)) {\n    if (recordMetrics == RecordMetricsBehavior::DoRecord)\n      showControlsHistogram().count(MediaControlsShowAttribute);\n    return true;\n  }\n\n  if (isFullscreen()) {\n    if (recordMetrics == RecordMetricsBehavior::DoRecord)\n      showControlsHistogram().count(MediaControlsShowFullscreen);\n    return true;\n  }\n\n  LocalFrame* frame = document().frame();\n  if (frame && !document().canExecuteScripts(NotAboutToExecuteScript)) {\n    if (recordMetrics == RecordMetricsBehavior::DoRecord)\n      showControlsHistogram().count(MediaControlsShowNoScript);\n    return true;\n  }\n\n  if (recordMetrics == RecordMetricsBehavior::DoRecord)\n    showControlsHistogram().count(MediaControlsShowNotShown);\n  return false;\n}\n", "target": 0, "idx": 140115}
{"func": "static Image *ReadSGIImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  MemoryInfo\n    *pixel_info;\n\n  register IndexPacket\n    *indexes;\n\n  register PixelPacket\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *p;\n\n  SGIInfo\n    iris_info;\n\n  size_t\n    bytes_per_pixel,\n    quantum;\n\n  ssize_t\n    count,\n    y,\n    z;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read SGI raster header.\n  */\n  iris_info.magic=ReadBlobMSBShort(image);\n  do\n  {\n    /*\n      Verify SGI identifier.\n    */\n    if (iris_info.magic != 0x01DA)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    iris_info.storage=(unsigned char) ReadBlobByte(image);\n    switch (iris_info.storage)\n    {\n      case 0x00: image->compression=NoCompression; break;\n      case 0x01: image->compression=RLECompression; break;\n      default:\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n    iris_info.bytes_per_pixel=(unsigned char) ReadBlobByte(image);\n    if ((iris_info.bytes_per_pixel == 0) || (iris_info.bytes_per_pixel > 2))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    iris_info.dimension=ReadBlobMSBShort(image);\n    iris_info.columns=ReadBlobMSBShort(image);\n    iris_info.rows=ReadBlobMSBShort(image);\n    iris_info.depth=ReadBlobMSBShort(image);\n    if ((iris_info.depth == 0) || (iris_info.depth > 4))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    iris_info.minimum_value=ReadBlobMSBLong(image);\n    iris_info.maximum_value=ReadBlobMSBLong(image);\n    iris_info.sans=ReadBlobMSBLong(image);\n    (void) ReadBlob(image,sizeof(iris_info.name),(unsigned char *)\n      iris_info.name);\n    iris_info.name[sizeof(iris_info.name)-1]='\\0';\n    if (*iris_info.name != '\\0')\n      (void) SetImageProperty(image,\"label\",iris_info.name);\n    iris_info.pixel_format=ReadBlobMSBLong(image);\n    if (iris_info.pixel_format != 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    count=ReadBlob(image,sizeof(iris_info.filler),iris_info.filler);\n    (void) count;\n    image->columns=iris_info.columns;\n    image->rows=iris_info.rows;\n    image->depth=(size_t) MagickMin(iris_info.depth,MAGICKCORE_QUANTUM_DEPTH);\n    if (iris_info.pixel_format == 0)\n      image->depth=(size_t) MagickMin((size_t) 8*\n        iris_info.bytes_per_pixel,MAGICKCORE_QUANTUM_DEPTH);\n    if (iris_info.depth < 3)\n      {\n        image->storage_class=PseudoClass;\n        image->colors=iris_info.bytes_per_pixel > 1 ? 65535 : 256;\n      }\n     if ((image_info->ping != MagickFalse)  && (image_info->number_scenes != 0))\n       if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n         break;\n     /*\n       Allocate SGI pixels.\n     */\n    bytes_per_pixel=(size_t) iris_info.bytes_per_pixel;\n    number_pixels=(MagickSizeType) iris_info.columns*iris_info.rows;\n    if ((4*bytes_per_pixel*number_pixels) != ((MagickSizeType) (size_t)\n        (4*bytes_per_pixel*number_pixels)))\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixel_info=AcquireVirtualMemory(iris_info.columns,iris_info.rows*4*\n      bytes_per_pixel*sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    if ((int) iris_info.storage != 0x01)\n      {\n        unsigned char\n          *scanline;\n\n        /*\n          Read standard image format.\n        */\n        scanline=(unsigned char *) AcquireQuantumMemory(iris_info.columns,\n          bytes_per_pixel*sizeof(*scanline));\n        if (scanline == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        for (z=0; z < (ssize_t) iris_info.depth; z++)\n        {\n          p=pixels+bytes_per_pixel*z;\n          for (y=0; y < (ssize_t) iris_info.rows; y++)\n          {\n            count=ReadBlob(image,bytes_per_pixel*iris_info.columns,scanline);\n            if (EOFBlob(image) != MagickFalse)\n              break;\n            if (bytes_per_pixel == 2)\n              for (x=0; x < (ssize_t) iris_info.columns; x++)\n              {\n                *p=scanline[2*x];\n                *(p+1)=scanline[2*x+1];\n                p+=8;\n              }\n            else\n              for (x=0; x < (ssize_t) iris_info.columns; x++)\n              {\n                *p=scanline[x];\n                p+=4;\n              }\n          }\n        }\n        scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n      }\n    else\n      {\n        MemoryInfo\n          *packet_info;\n\n        size_t\n          *runlength;\n\n        ssize_t\n          offset,\n          *offsets;\n\n        unsigned char\n          *packets;\n\n        unsigned int\n          data_order;\n\n        /*\n          Read runlength-encoded image format.\n        */\n        offsets=(ssize_t *) AcquireQuantumMemory((size_t) iris_info.rows,\n          iris_info.depth*sizeof(*offsets));\n        runlength=(size_t *) AcquireQuantumMemory(iris_info.rows,\n          iris_info.depth*sizeof(*runlength));\n        packet_info=AcquireVirtualMemory((size_t) iris_info.columns+10UL,4UL*\n          sizeof(*packets));\n        if ((offsets == (ssize_t *) NULL) ||\n            (runlength == (size_t *) NULL) ||\n            (packet_info == (MemoryInfo *) NULL))\n          {\n            if (offsets == (ssize_t *) NULL)\n              offsets=(ssize_t *) RelinquishMagickMemory(offsets);\n            if (runlength == (size_t *) NULL)\n              runlength=(size_t *) RelinquishMagickMemory(runlength);\n            if (packet_info == (MemoryInfo *) NULL)\n              packet_info=RelinquishVirtualMemory(packet_info);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        packets=(unsigned char *) GetVirtualMemoryBlob(packet_info);\n        for (i=0; i < (ssize_t) (iris_info.rows*iris_info.depth); i++)\n          offsets[i]=(int) ReadBlobMSBLong(image);\n        for (i=0; i < (ssize_t) (iris_info.rows*iris_info.depth); i++)\n        {\n          runlength[i]=ReadBlobMSBLong(image);\n          if (runlength[i] > (4*(size_t) iris_info.columns+10))\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        }\n        /*\n          Check data order.\n        */\n        offset=0;\n        data_order=0;\n        for (y=0; ((y < (ssize_t) iris_info.rows) && (data_order == 0)); y++)\n          for (z=0; ((z < (ssize_t) iris_info.depth) && (data_order == 0)); z++)\n          {\n            if (offsets[y+z*iris_info.rows] < offset)\n              data_order=1;\n            offset=offsets[y+z*iris_info.rows];\n          }\n        offset=(ssize_t) TellBlob(image);\n        if (data_order == 1)\n          {\n            for (z=0; z < (ssize_t) iris_info.depth; z++)\n            {\n              p=pixels;\n              for (y=0; y < (ssize_t) iris_info.rows; y++)\n              {\n                if (offset != offsets[y+z*iris_info.rows])\n                  {\n                    offset=offsets[y+z*iris_info.rows];\n                    offset=(ssize_t) SeekBlob(image,(ssize_t) offset,SEEK_SET);\n                  }\n                count=ReadBlob(image,(size_t) runlength[y+z*iris_info.rows],\n                  packets);\n                if (EOFBlob(image) != MagickFalse)\n                  break;\n                offset+=(ssize_t) runlength[y+z*iris_info.rows];\n                status=SGIDecode(bytes_per_pixel,(ssize_t)\n                  (runlength[y+z*iris_info.rows]/bytes_per_pixel),packets,\n                  1L*iris_info.columns,p+bytes_per_pixel*z);\n                if (status == MagickFalse)\n                  ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n                p+=(iris_info.columns*4*bytes_per_pixel);\n              }\n            }\n          }\n        else\n          {\n            MagickOffsetType\n              position;\n\n            position=TellBlob(image);\n            p=pixels;\n            for (y=0; y < (ssize_t) iris_info.rows; y++)\n            {\n              for (z=0; z < (ssize_t) iris_info.depth; z++)\n              {\n                if (offset != offsets[y+z*iris_info.rows])\n                  {\n                    offset=offsets[y+z*iris_info.rows];\n                    offset=(ssize_t) SeekBlob(image,(ssize_t) offset,SEEK_SET);\n                  }\n                count=ReadBlob(image,(size_t) runlength[y+z*iris_info.rows],\n                  packets);\n                if (EOFBlob(image) != MagickFalse)\n                  break;\n                offset+=(ssize_t) runlength[y+z*iris_info.rows];\n                status=SGIDecode(bytes_per_pixel,(ssize_t)\n                  (runlength[y+z*iris_info.rows]/bytes_per_pixel),packets,\n                  1L*iris_info.columns,p+bytes_per_pixel*z);\n                if (status == MagickFalse)\n                  ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              }\n              p+=(iris_info.columns*4*bytes_per_pixel);\n            }\n            offset=(ssize_t) SeekBlob(image,position,SEEK_SET);\n          }\n        packet_info=RelinquishVirtualMemory(packet_info);\n        runlength=(size_t *) RelinquishMagickMemory(runlength);\n        offsets=(ssize_t *) RelinquishMagickMemory(offsets);\n      }\n    /*\n      Initialize image structure.\n    */\n    image->matte=iris_info.depth == 4 ? MagickTrue : MagickFalse;\n    image->columns=iris_info.columns;\n    image->rows=iris_info.rows;\n    /*\n      Convert SGI raster image to pixel packets.\n    */\n    if (image->storage_class == DirectClass)\n      {\n        /*\n          Convert SGI image to DirectClass pixel packets.\n        */\n        if (bytes_per_pixel == 2)\n          {\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=pixels+(image->rows-y-1)*8*image->columns;\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (PixelPacket *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                SetPixelRed(q,ScaleShortToQuantum((unsigned short)\n                  ((*(p+0) << 8) | (*(p+1)))));\n                SetPixelGreen(q,ScaleShortToQuantum((unsigned short)\n                  ((*(p+2) << 8) | (*(p+3)))));\n                SetPixelBlue(q,ScaleShortToQuantum((unsigned short)\n                  ((*(p+4) << 8) | (*(p+5)))));\n                SetPixelOpacity(q,OpaqueOpacity);\n                if (image->matte != MagickFalse)\n                  SetPixelAlpha(q,ScaleShortToQuantum((unsigned short)\n                    ((*(p+6) << 8) | (*(p+7)))));\n                p+=8;\n                q++;\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n        else\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=pixels+(image->rows-y-1)*4*image->columns;\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (PixelPacket *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelRed(q,ScaleCharToQuantum(*p));\n              q->green=ScaleCharToQuantum(*(p+1));\n              q->blue=ScaleCharToQuantum(*(p+2));\n              SetPixelOpacity(q,OpaqueOpacity);\n              if (image->matte != MagickFalse)\n                SetPixelAlpha(q,ScaleCharToQuantum(*(p+3)));\n              p+=4;\n              q++;\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n      }\n    else\n      {\n        /*\n          Create grayscale map.\n        */\n        if (AcquireImageColormap(image,image->colors) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        /*\n          Convert SGI image to PseudoClass pixel packets.\n        */\n        if (bytes_per_pixel == 2)\n          {\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=pixels+(image->rows-y-1)*8*image->columns;\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (PixelPacket *) NULL)\n                break;\n              indexes=GetAuthenticIndexQueue(image);\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                quantum=(*p << 8);\n                quantum|=(*(p+1));\n                SetPixelIndex(indexes+x,quantum);\n                p+=8;\n                q++;\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n        else\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=pixels+(image->rows-y-1)*4*image->columns;\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (PixelPacket *) NULL)\n              break;\n            indexes=GetAuthenticIndexQueue(image);\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelIndex(indexes+x,*p);\n              p+=4;\n              q++;\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        (void) SyncImage(image);\n      }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    iris_info.magic=ReadBlobMSBShort(image);\n    if (iris_info.magic == 0x01DA)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (iris_info.magic == 0x01DA);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n", "target": 1, "idx": 181776}
{"func": "ikev1_nonce_print(netdissect_options *ndo, u_char tpay _U_,\n\t\t  const struct isakmp_gen *ext,\n\t\t  u_int item_len _U_,\n\t\t  const u_char *ep,\n\t\t  uint32_t phase _U_, uint32_t doi _U_,\n\t\t  uint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_NONCE)));\n \n \tND_TCHECK(*ext);\n \tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tND_PRINT((ndo,\" n len=%d\", ntohs(e.len) - 4));\n\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t} else if (1 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!ike_show_somedata(ndo, (const u_char *)(const uint8_t *)(ext + 1), ep))\n\t\t\tgoto trunc;\n \t}\n \treturn (const u_char *)ext + ntohs(e.len);\n trunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_NONCE)));\n\treturn NULL;\n}\n", "target": 1, "idx": 181097}
{"func": "void RendererSchedulerImpl::DidAnimateForInputOnCompositorThread() {\n  TRACE_EVENT0(TRACE_DISABLED_BY_DEFAULT(\"renderer.scheduler\"),\n               \"RendererSchedulerImpl::DidAnimateForInputOnCompositorThread\");\n  base::AutoLock lock(any_thread_lock_);\n  any_thread().fling_compositor_escalation_deadline =\n      helper_.NowTicks() +\n      base::TimeDelta::FromMilliseconds(kFlingEscalationLimitMillis);\n}\n", "target": 0, "idx": 156185}
{"func": "static int mov_write_loci_tag(AVFormatContext *s, AVIOContext *pb)\n{\n    int lang;\n    int64_t pos = avio_tell(pb);\n    double latitude, longitude, altitude;\n    int32_t latitude_fix, longitude_fix, altitude_fix;\n    AVDictionaryEntry *t = get_metadata_lang(s, \"location\", &lang);\n    const char *ptr, *place = \"\";\n    char *end;\n    static const char *astronomical_body = \"earth\";\n    if (!t)\n        return 0;\n\n    ptr = t->value;\n    longitude = strtod(ptr, &end);\n    if (end == ptr) {\n        av_log(s, AV_LOG_WARNING, \"malformed location metadata\\n\");\n        return 0;\n    }\n    ptr = end;\n    latitude = strtod(ptr, &end);\n    if (end == ptr) {\n        av_log(s, AV_LOG_WARNING, \"malformed location metadata\\n\");\n        return 0;\n    }\n    ptr = end;\n    altitude = strtod(ptr, &end);\n    /* If no altitude was present, the default 0 should be fine */\n    if (*end == '/')\n        place = end + 1;\n\n    latitude_fix  = (int32_t) ((1 << 16) * latitude);\n    longitude_fix = (int32_t) ((1 << 16) * longitude);\n    altitude_fix  = (int32_t) ((1 << 16) * altitude);\n\n    avio_wb32(pb, 0);         /* size */\n    ffio_wfourcc(pb, \"loci\"); /* type */\n    avio_wb32(pb, 0);         /* version + flags */\n    avio_wb16(pb, lang);\n    avio_write(pb, place, strlen(place) + 1);\n    avio_w8(pb, 0);           /* role of place (0 == shooting location, 1 == real location, 2 == fictional location) */\n    avio_wb32(pb, latitude_fix);\n    avio_wb32(pb, longitude_fix);\n    avio_wb32(pb, altitude_fix);\n    avio_write(pb, astronomical_body, strlen(astronomical_body) + 1);\n    avio_w8(pb, 0);           /* additional notes, null terminated string */\n\n    return update_size(pb, pos);\n}\n", "target": 0, "idx": 79366}
{"func": "std::unique_ptr<HistogramBase> PersistentHistogramAllocator::AllocateHistogram(\n    HistogramType histogram_type,\n    const std::string& name,\n    int minimum,\n    int maximum,\n    const BucketRanges* bucket_ranges,\n    int32_t flags,\n    Reference* ref_ptr) {\n  if (memory_allocator_->IsCorrupt()) {\n    RecordCreateHistogramResult(CREATE_HISTOGRAM_ALLOCATOR_CORRUPT);\n     return nullptr;\n  }\n \n  PersistentHistogramData* histogram_data =\n      memory_allocator_->New<PersistentHistogramData>(\n          offsetof(PersistentHistogramData, name) + name.length() + 1);\n  if (histogram_data) {\n    memcpy(histogram_data->name, name.c_str(), name.size() + 1);\n    histogram_data->histogram_type = histogram_type;\n    histogram_data->flags = flags | HistogramBase::kIsPersistent;\n  }\n\n  if (histogram_type != SPARSE_HISTOGRAM) {\n    size_t bucket_count = bucket_ranges->bucket_count();\n    size_t counts_bytes = CalculateRequiredCountsBytes(bucket_count);\n    if (counts_bytes == 0) {\n      NOTREACHED();\n      return nullptr;\n    }\n\n    DCHECK_EQ(this, GlobalHistogramAllocator::Get());\n\n    PersistentMemoryAllocator::Reference ranges_ref =\n        bucket_ranges->persistent_reference();\n    if (!ranges_ref) {\n      size_t ranges_count = bucket_count + 1;\n      size_t ranges_bytes = ranges_count * sizeof(HistogramBase::Sample);\n      ranges_ref =\n          memory_allocator_->Allocate(ranges_bytes, kTypeIdRangesArray);\n      if (ranges_ref) {\n        HistogramBase::Sample* ranges_data =\n            memory_allocator_->GetAsArray<HistogramBase::Sample>(\n                ranges_ref, kTypeIdRangesArray, ranges_count);\n        if (ranges_data) {\n          for (size_t i = 0; i < bucket_ranges->size(); ++i)\n            ranges_data[i] = bucket_ranges->range(i);\n          bucket_ranges->set_persistent_reference(ranges_ref);\n        } else {\n          NOTREACHED();\n          ranges_ref = PersistentMemoryAllocator::kReferenceNull;\n        }\n      }\n    } else {\n      DCHECK_EQ(kTypeIdRangesArray, memory_allocator_->GetType(ranges_ref));\n    }\n\n\n    if (ranges_ref && histogram_data) {\n      histogram_data->minimum = minimum;\n      histogram_data->maximum = maximum;\n      histogram_data->bucket_count = static_cast<uint32_t>(bucket_count);\n      histogram_data->ranges_ref = ranges_ref;\n      histogram_data->ranges_checksum = bucket_ranges->checksum();\n    } else {\n      histogram_data = nullptr;  // Clear this for proper handling below.\n    }\n  }\n\n  if (histogram_data) {\n    std::unique_ptr<HistogramBase> histogram = CreateHistogram(histogram_data);\n    DCHECK(histogram);\n    DCHECK_NE(0U, histogram_data->samples_metadata.id);\n    DCHECK_NE(0U, histogram_data->logged_metadata.id);\n\n    PersistentMemoryAllocator::Reference histogram_ref =\n        memory_allocator_->GetAsReference(histogram_data);\n    if (ref_ptr != nullptr)\n      *ref_ptr = histogram_ref;\n\n    subtle::NoBarrier_Store(&last_created_, histogram_ref);\n     return histogram;\n   }\n \n  CreateHistogramResultType result;\n  if (memory_allocator_->IsCorrupt()) {\n    RecordCreateHistogramResult(CREATE_HISTOGRAM_ALLOCATOR_NEWLY_CORRUPT);\n    result = CREATE_HISTOGRAM_ALLOCATOR_CORRUPT;\n  } else if (memory_allocator_->IsFull()) {\n    result = CREATE_HISTOGRAM_ALLOCATOR_FULL;\n  } else {\n    result = CREATE_HISTOGRAM_ALLOCATOR_ERROR;\n  }\n  RecordCreateHistogramResult(result);\n  if (result != CREATE_HISTOGRAM_ALLOCATOR_FULL)\n    NOTREACHED() << memory_allocator_->Name() << \", error=\" << result;\n \n   return nullptr;\n }\n", "target": 1, "idx": 186099}
{"func": "bool ChildProcessSecurityPolicyImpl::GetMatchingIsolatedOrigin(\n    const url::Origin& origin,\n    url::Origin* result) {\n  return GetMatchingIsolatedOrigin(\n      origin, SiteInstanceImpl::GetSiteForOrigin(origin), result);\n}\n", "target": 0, "idx": 156536}
{"func": "void WebContentsImpl::ShowCreatedWidget(int route_id,\n                                        bool is_fullscreen,\n                                        const gfx::Rect& initial_rect) {\n  RenderWidgetHostViewBase* widget_host_view =\n      static_cast<RenderWidgetHostViewBase*>(GetCreatedWidget(route_id));\n  if (!widget_host_view)\n    return;\n\n  RenderWidgetHostView* view = NULL;\n  BrowserPluginGuest* guest = GetBrowserPluginGuest();\n  if (guest && guest->embedder_web_contents()) {\n    view = guest->embedder_web_contents()->GetRenderWidgetHostView();\n  } else {\n    view = GetRenderWidgetHostView();\n  }\n\n  if (is_fullscreen) {\n    DCHECK_EQ(MSG_ROUTING_NONE, fullscreen_widget_routing_id_);\n    view_->StoreFocus();\n    fullscreen_widget_routing_id_ = route_id;\n    if (delegate_ && delegate_->EmbedsFullscreenWidget()) {\n      widget_host_view->InitAsChild(GetRenderWidgetHostView()->GetNativeView());\n      delegate_->EnterFullscreenModeForTab(this, GURL());\n    } else {\n      widget_host_view->InitAsFullscreen(view);\n    }\n    FOR_EACH_OBSERVER(WebContentsObserver,\n                      observers_,\n                      DidShowFullscreenWidget(route_id));\n    if (!widget_host_view->HasFocus())\n      widget_host_view->Focus();\n  } else {\n    widget_host_view->InitAsPopup(view, initial_rect);\n  }\n\n  RenderWidgetHostImpl* render_widget_host_impl =\n      RenderWidgetHostImpl::From(widget_host_view->GetRenderWidgetHost());\n  render_widget_host_impl->Init();\n  render_widget_host_impl->set_allow_privileged_mouse_lock(is_fullscreen);\n\n#if defined(OS_MACOSX)\n  base::mac::NSObjectRelease(widget_host_view->GetNativeView());\n#endif\n}\n", "target": 0, "idx": 144685}
{"func": "void DownloadRequestLimiter::TabDownloadState::DidFinishNavigation(\n    content::NavigationHandle* navigation_handle) {\n  if (!navigation_handle->IsInMainFrame())\n    return;\n\n   if (status_ == ALLOW_ONE_DOWNLOAD ||\n       (status_ == PROMPT_BEFORE_DOWNLOAD &&\n       !navigation_handle->IsRendererInitiated())) {\n    NotifyCallbacks(false);\n    host_->Remove(this, web_contents());\n  }\n}\n", "target": 1, "idx": 187179}
{"func": "  bool UseOpenGLRenderer() {\n    return cmd_line_.GetSwitchValueASCII(switches::kUseGL) ==\n           gl::kGLImplementationDesktopName;\n  }\n", "target": 0, "idx": 145187}
{"func": "MagickExport MagickBooleanType ContrastStretchImage(Image *image,\n  const double black_point,const double white_point,ExceptionInfo *exception)\n{\n#define MaxRange(color)  ((double) ScaleQuantumToMap((Quantum) (color)))\n#define ContrastStretchImageTag  \"ContrastStretch/Image\"\n\n  CacheView\n    *image_view;\n\n  double\n    *black,\n    *histogram,\n    *stretch_map,\n    *white;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    y;\n\n  /*\n    Allocate histogram and stretch map.\n  */\n  assert(image != (Image *) NULL);\n   assert(image->signature == MagickCoreSignature);\n   if (image->debug != MagickFalse)\n     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n   if (SetImageGray(image,exception) != MagickFalse)\n     (void) SetImageColorspace(image,GRAYColorspace,exception);\n   black=(double *) AcquireQuantumMemory(GetPixelChannels(image),sizeof(*black));\n  white=(double *) AcquireQuantumMemory(GetPixelChannels(image),sizeof(*white));\n  histogram=(double *) AcquireQuantumMemory(MaxMap+1UL,GetPixelChannels(image)*\n    sizeof(*histogram));\n  stretch_map=(double *) AcquireQuantumMemory(MaxMap+1UL,\n    GetPixelChannels(image)*sizeof(*stretch_map));\n  if ((black == (double *) NULL) || (white == (double *) NULL) ||\n      (histogram == (double *) NULL) || (stretch_map == (double *) NULL))\n    {\n      if (stretch_map != (double *) NULL)\n        stretch_map=(double *) RelinquishMagickMemory(stretch_map);\n      if (histogram != (double *) NULL)\n        histogram=(double *) RelinquishMagickMemory(histogram);\n      if (white != (double *) NULL)\n        white=(double *) RelinquishMagickMemory(white);\n      if (black != (double *) NULL)\n        black=(double *) RelinquishMagickMemory(black);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n  /*\n    Form histogram.\n  */\n  status=MagickTrue;\n  (void) ResetMagickMemory(histogram,0,(MaxMap+1)*GetPixelChannels(image)*\n    sizeof(*histogram));\n  image_view=AcquireVirtualCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const Quantum\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        pixel;\n\n      pixel=GetPixelIntensity(image,p);\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        if (image->channel_mask != DefaultChannels)\n          pixel=(double) p[i];\n        histogram[GetPixelChannels(image)*ScaleQuantumToMap(\n          ClampToQuantum(pixel))+i]++;\n      }\n      p+=GetPixelChannels(image);\n    }\n  }\n  image_view=DestroyCacheView(image_view);\n  /*\n    Find the histogram boundaries by locating the black/white levels.\n  */\n  for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n  {\n    double\n      intensity;\n\n    register ssize_t\n      j;\n\n    black[i]=0.0;\n    white[i]=MaxRange(QuantumRange);\n    intensity=0.0;\n    for (j=0; j <= (ssize_t) MaxMap; j++)\n    {\n      intensity+=histogram[GetPixelChannels(image)*j+i];\n      if (intensity > black_point)\n        break;\n    }\n    black[i]=(double) j;\n    intensity=0.0;\n    for (j=(ssize_t) MaxMap; j != 0; j--)\n    {\n      intensity+=histogram[GetPixelChannels(image)*j+i];\n      if (intensity > ((double) image->columns*image->rows-white_point))\n        break;\n    }\n    white[i]=(double) j;\n  }\n  histogram=(double *) RelinquishMagickMemory(histogram);\n  /*\n    Stretch the histogram to create the stretched image mapping.\n  */\n  (void) ResetMagickMemory(stretch_map,0,(MaxMap+1)*GetPixelChannels(image)*\n    sizeof(*stretch_map));\n  for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n  {\n    register ssize_t\n      j;\n\n    for (j=0; j <= (ssize_t) MaxMap; j++)\n    {\n      double\n        gamma;\n\n      gamma=PerceptibleReciprocal(white[i]-black[i]);\n      if (j < (ssize_t) black[i])\n        stretch_map[GetPixelChannels(image)*j+i]=0.0;\n      else\n        if (j > (ssize_t) white[i])\n          stretch_map[GetPixelChannels(image)*j+i]=(double) QuantumRange;\n        else\n          if (black[i] != white[i])\n            stretch_map[GetPixelChannels(image)*j+i]=(double) ScaleMapToQuantum(\n              (double) (MaxMap*gamma*(j-black[i])));\n    }\n  }\n  if (image->storage_class == PseudoClass)\n    {\n      register ssize_t\n        j;\n\n      /*\n        Stretch-contrast colormap.\n      */\n      for (j=0; j < (ssize_t) image->colors; j++)\n      {\n        if ((GetPixelRedTraits(image) & UpdatePixelTrait) != 0)\n          {\n            i=GetPixelChannelOffset(image,RedPixelChannel);\n            image->colormap[j].red=stretch_map[GetPixelChannels(image)*\n              ScaleQuantumToMap(ClampToQuantum(image->colormap[j].red))+i];\n          }\n        if ((GetPixelGreenTraits(image) & UpdatePixelTrait) != 0)\n          {\n            i=GetPixelChannelOffset(image,GreenPixelChannel);\n            image->colormap[j].green=stretch_map[GetPixelChannels(image)*\n              ScaleQuantumToMap(ClampToQuantum(image->colormap[j].green))+i];\n          }\n        if ((GetPixelBlueTraits(image) & UpdatePixelTrait) != 0)\n          {\n            i=GetPixelChannelOffset(image,BluePixelChannel);\n            image->colormap[j].blue=stretch_map[GetPixelChannels(image)*\n              ScaleQuantumToMap(ClampToQuantum(image->colormap[j].blue))+i];\n          }\n        if ((GetPixelAlphaTraits(image) & UpdatePixelTrait) != 0)\n          {\n            i=GetPixelChannelOffset(image,AlphaPixelChannel);\n            image->colormap[j].alpha=stretch_map[GetPixelChannels(image)*\n              ScaleQuantumToMap(ClampToQuantum(image->colormap[j].alpha))+i];\n          }\n      }\n    }\n  /*\n    Stretch-contrast image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      register ssize_t\n        j;\n\n      if (GetPixelWriteMask(image,q) == 0)\n        {\n          q+=GetPixelChannels(image);\n          continue;\n        }\n      for (j=0; j < (ssize_t) GetPixelChannels(image); j++)\n      {\n        PixelChannel channel=GetPixelChannelChannel(image,j);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        if ((traits & UpdatePixelTrait) == 0)\n          continue;\n        if (black[j] == white[j])\n          continue;\n        q[j]=ClampToQuantum(stretch_map[GetPixelChannels(image)*\n          ScaleQuantumToMap(q[j])+j]);\n      }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_ContrastStretchImage)\n#endif\n        proceed=SetImageProgress(image,ContrastStretchImageTag,progress++,\n          image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  stretch_map=(double *) RelinquishMagickMemory(stretch_map);\n  white=(double *) RelinquishMagickMemory(white);\n  black=(double *) RelinquishMagickMemory(black);\n  return(status);\n}\n", "target": 1, "idx": 181135}
{"func": "int inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n \tif ((ia_valid & ATTR_UID) &&\n \t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n \t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !inode_capable(inode, CAP_CHOWN))\n \t\treturn -EPERM;\n \n \t/* Make sure caller can chgrp. */\n \tif ((ia_valid & ATTR_GID) &&\n \t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n \t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !inode_capable(inode, CAP_CHOWN))\n \t\treturn -EPERM;\n \n \t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n \t\t/* Also check the setgid bit! */\n \t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n \t\t\t\tinode->i_gid) &&\n\t\t    !inode_capable(inode, CAP_FSETID))\n \t\t\tattr->ia_mode &= ~S_ISGID;\n \t}\n \n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}\n", "target": 1, "idx": 179489}
{"func": " int ff_h263_decode_picture_header(MpegEncContext *s)\n {\n    int format, width, height, i;\n     uint32_t startcode;\n \n     align_get_bits(&s->gb);\n    startcode= get_bits(&s->gb, 22-8);\n\n    for(i= get_bits_left(&s->gb); i>24; i-=8) {\n        startcode = ((startcode << 8) | get_bits(&s->gb, 8)) & 0x003FFFFF;\n\n        if(startcode == 0x20)\n            break;\n    }\n\n    if (startcode != 0x20) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Bad picture start code\\n\");\n        return -1;\n    }\n    /* temporal reference */\n    i = get_bits(&s->gb, 8); /* picture timestamp */\n    if( (s->picture_number&~0xFF)+i < s->picture_number)\n        i+= 256;\n    s->picture_number= (s->picture_number&~0xFF) + i;\n\n    /* PTYPE starts here */\n    if (get_bits1(&s->gb) != 1) {\n        /* marker */\n        av_log(s->avctx, AV_LOG_ERROR, \"Bad marker\\n\");\n        return -1;\n    }\n    if (get_bits1(&s->gb) != 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Bad H263 id\\n\");\n        return -1;      /* h263 id */\n    }\n    skip_bits1(&s->gb);         /* split screen off */\n    skip_bits1(&s->gb);         /* camera  off */\n    skip_bits1(&s->gb);         /* freeze picture release off */\n\n    format = get_bits(&s->gb, 3);\n    /*\n        0    forbidden\n        1    sub-QCIF\n        10   QCIF\n        7       extended PTYPE (PLUSPTYPE)\n    */\n\n    if (format != 7 && format != 6) {\n        s->h263_plus = 0;\n        /* H.263v1 */\n         /* H.263v1 */\n         width = ff_h263_format[format][0];\n         height = ff_h263_format[format][1];\n        if (!width)\n            return -1;\n \n         s->pict_type = AV_PICTURE_TYPE_I + get_bits1(&s->gb);\n \n\n        s->h263_long_vectors = get_bits1(&s->gb);\n\n        if (get_bits1(&s->gb) != 0) {\n            av_log(s->avctx, AV_LOG_ERROR, \"H263 SAC not supported\\n\");\n            return -1; /* SAC: off */\n        }\n        s->obmc= get_bits1(&s->gb); /* Advanced prediction mode */\n        s->unrestricted_mv = s->h263_long_vectors || s->obmc;\n\n        s->pb_frame = get_bits1(&s->gb);\n        s->chroma_qscale= s->qscale = get_bits(&s->gb, 5);\n        skip_bits1(&s->gb); /* Continuous Presence Multipoint mode: off */\n\n        s->width = width;\n        s->height = height;\n        s->avctx->sample_aspect_ratio= (AVRational){12,11};\n        s->avctx->framerate = (AVRational){ 30000, 1001 };\n    } else {\n        int ufep;\n\n        /* H.263v2 */\n        s->h263_plus = 1;\n        ufep = get_bits(&s->gb, 3); /* Update Full Extended PTYPE */\n\n        /* ufep other than 0 and 1 are reserved */\n        if (ufep == 1) {\n            /* OPPTYPE */\n            format = get_bits(&s->gb, 3);\n            ff_dlog(s->avctx, \"ufep=1, format: %d\\n\", format);\n            s->custom_pcf= get_bits1(&s->gb);\n            s->umvplus = get_bits1(&s->gb); /* Unrestricted Motion Vector */\n            if (get_bits1(&s->gb) != 0) {\n                av_log(s->avctx, AV_LOG_ERROR, \"Syntax-based Arithmetic Coding (SAC) not supported\\n\");\n            }\n            s->obmc= get_bits1(&s->gb); /* Advanced prediction mode */\n            s->h263_aic = get_bits1(&s->gb); /* Advanced Intra Coding (AIC) */\n            s->loop_filter= get_bits1(&s->gb);\n            s->unrestricted_mv = s->umvplus || s->obmc || s->loop_filter;\n\n            s->h263_slice_structured= get_bits1(&s->gb);\n            if (get_bits1(&s->gb) != 0) {\n                av_log(s->avctx, AV_LOG_ERROR, \"Reference Picture Selection not supported\\n\");\n            }\n            if (get_bits1(&s->gb) != 0) {\n                av_log(s->avctx, AV_LOG_ERROR, \"Independent Segment Decoding not supported\\n\");\n            }\n            s->alt_inter_vlc= get_bits1(&s->gb);\n            s->modified_quant= get_bits1(&s->gb);\n            if(s->modified_quant)\n                s->chroma_qscale_table= ff_h263_chroma_qscale_table;\n\n            skip_bits(&s->gb, 1); /* Prevent start code emulation */\n\n            skip_bits(&s->gb, 3); /* Reserved */\n        } else if (ufep != 0) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Bad UFEP type (%d)\\n\", ufep);\n            return -1;\n        }\n\n        /* MPPTYPE */\n        s->pict_type = get_bits(&s->gb, 3);\n        switch(s->pict_type){\n        case 0: s->pict_type= AV_PICTURE_TYPE_I;break;\n        case 1: s->pict_type= AV_PICTURE_TYPE_P;break;\n        case 2: s->pict_type= AV_PICTURE_TYPE_P;s->pb_frame = 3;break;\n        case 3: s->pict_type= AV_PICTURE_TYPE_B;break;\n        case 7: s->pict_type= AV_PICTURE_TYPE_I;break; //ZYGO\n        default:\n            return -1;\n        }\n        skip_bits(&s->gb, 2);\n        s->no_rounding = get_bits1(&s->gb);\n        skip_bits(&s->gb, 4);\n\n        /* Get the picture dimensions */\n        if (ufep) {\n            if (format == 6) {\n                /* Custom Picture Format (CPFMT) */\n                s->aspect_ratio_info = get_bits(&s->gb, 4);\n                ff_dlog(s->avctx, \"aspect: %d\\n\", s->aspect_ratio_info);\n                /* aspect ratios:\n                0 - forbidden\n                1 - 1:1\n                2 - 12:11 (CIF 4:3)\n                3 - 10:11 (525-type 4:3)\n                4 - 16:11 (CIF 16:9)\n                5 - 40:33 (525-type 16:9)\n                6-14 - reserved\n                */\n                width = (get_bits(&s->gb, 9) + 1) * 4;\n                skip_bits1(&s->gb);\n                height = get_bits(&s->gb, 9) * 4;\n                ff_dlog(s->avctx, \"\\nH.263+ Custom picture: %dx%d\\n\",width,height);\n                if (s->aspect_ratio_info == FF_ASPECT_EXTENDED) {\n                    /* aspected dimensions */\n                    s->avctx->sample_aspect_ratio.num= get_bits(&s->gb, 8);\n                    s->avctx->sample_aspect_ratio.den= get_bits(&s->gb, 8);\n                }else{\n                    s->avctx->sample_aspect_ratio= ff_h263_pixel_aspect[s->aspect_ratio_info];\n                }\n            } else {\n                width = ff_h263_format[format][0];\n                height = ff_h263_format[format][1];\n                s->avctx->sample_aspect_ratio= (AVRational){12,11};\n            }\n            if ((width == 0) || (height == 0))\n                return -1;\n            s->width = width;\n            s->height = height;\n\n            if(s->custom_pcf){\n                int gcd;\n                s->avctx->framerate.num  = 1800000;\n                s->avctx->framerate.den  = 1000 + get_bits1(&s->gb);\n                s->avctx->framerate.den *= get_bits(&s->gb, 7);\n                if(s->avctx->framerate.den == 0){\n                    av_log(s, AV_LOG_ERROR, \"zero framerate\\n\");\n                    return -1;\n                }\n                gcd= av_gcd(s->avctx->framerate.den, s->avctx->framerate.num);\n                s->avctx->framerate.den /= gcd;\n                s->avctx->framerate.num /= gcd;\n            }else{\n                s->avctx->framerate = (AVRational){ 30000, 1001 };\n            }\n        }\n\n        if(s->custom_pcf){\n            skip_bits(&s->gb, 2); //extended Temporal reference\n        }\n\n        if (ufep) {\n            if (s->umvplus) {\n                if(get_bits1(&s->gb)==0) /* Unlimited Unrestricted Motion Vectors Indicator (UUI) */\n                    skip_bits1(&s->gb);\n            }\n            if(s->h263_slice_structured){\n                if (get_bits1(&s->gb) != 0) {\n                    av_log(s->avctx, AV_LOG_ERROR, \"rectangular slices not supported\\n\");\n                }\n                if (get_bits1(&s->gb) != 0) {\n                    av_log(s->avctx, AV_LOG_ERROR, \"unordered slices not supported\\n\");\n                }\n            }\n        }\n         s->qscale = get_bits(&s->gb, 5);\n     }\n \n     s->mb_width = (s->width  + 15) / 16;\n     s->mb_height = (s->height  + 15) / 16;\n     s->mb_num = s->mb_width * s->mb_height;\n        skip_bits(&s->gb, 3); /* Temporal reference for B-pictures */\n        if (s->custom_pcf)\n            skip_bits(&s->gb, 2); //extended Temporal reference\n        skip_bits(&s->gb, 2); /* Quantization information for B-pictures */\n    }\n", "target": 1, "idx": 178470}
{"func": "static void __sctp_write_space(struct sctp_association *asoc)\n{\n\tstruct sock *sk = asoc->base.sk;\n\n\tif (sctp_wspace(asoc) <= 0)\n\t\treturn;\n\n\tif (waitqueue_active(&asoc->wait))\n\t\twake_up_interruptible(&asoc->wait);\n\n\tif (sctp_writeable(sk)) {\n\t\tstruct socket_wq *wq;\n\n\t\trcu_read_lock();\n\t\twq = rcu_dereference(sk->sk_wq);\n\t\tif (wq) {\n\t\t\tif (waitqueue_active(&wq->wait))\n\t\t\t\twake_up_interruptible(&wq->wait);\n\n\t\t\t/* Note that we try to include the Async I/O support\n\t\t\t * here by modeling from the current TCP/UDP code.\n\t\t\t * We have not tested with it yet.\n\t\t\t */\n\t\t\tif (!(sk->sk_shutdown & SEND_SHUTDOWN))\n\t\t\t\tsock_wake_async(wq, SOCK_WAKE_SPACE, POLL_OUT);\n\t\t}\n\t\trcu_read_unlock();\n\t}\n}\n", "target": 0, "idx": 60646}
{"func": " Resource::~Resource() {\n }\n", "target": 1, "idx": 183872}
{"func": "gss_pseudo_random (OM_uint32 *minor_status,\n\t           gss_ctx_id_t context_handle,\n\t           int prf_key,\n\t           const gss_buffer_t prf_in,\n\t           ssize_t desired_output_len,\n\t           gss_buffer_t prf_out)\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n\n    if (minor_status == NULL)\n\treturn GSS_S_CALL_INACCESSIBLE_WRITE;\n\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT;\n\n    if (prf_in == GSS_C_NO_BUFFER)\n\treturn GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT;\n\n    if (prf_out == GSS_C_NO_BUFFER)\n\treturn GSS_S_CALL_INACCESSIBLE_WRITE | GSS_S_NO_CONTEXT;\n\n    prf_out->length = 0;\n    prf_out->value = NULL;\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech != NULL) {\n\tif (mech->gss_pseudo_random != NULL) {\n\t    status = mech->gss_pseudo_random(minor_status,\n\t\t\t\t\t     ctx->internal_ctx_id,\n\t\t\t\t\t     prf_key,\n\t\t\t\t\t     prf_in,\n\t\t\t\t\t     desired_output_len,\n\t\t\t\t\t     prf_out);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\n\treturn status;\n    }\n\n    return GSS_S_BAD_MECH;\n}\n", "target": 1, "idx": 181190}
{"func": "void ProfileSyncComponentsFactoryImpl::RegisterDesktopDataTypes(\n    ProfileSyncService* pss) {\n  if (!command_line_->HasSwitch(switches::kDisableSyncApps)) {\n    pss->RegisterDataTypeController(\n        new ExtensionDataTypeController(syncer::APPS, this, profile_, pss));\n  }\n\n  if (!command_line_->HasSwitch(switches::kDisableSyncExtensions)) {\n    pss->RegisterDataTypeController(\n        new ExtensionDataTypeController(syncer::EXTENSIONS,\n                                        this, profile_, pss));\n  }\n\n  if (!command_line_->HasSwitch(switches::kDisableSyncPreferences)) {\n    pss->RegisterDataTypeController(\n        new UIDataTypeController(syncer::PREFERENCES, this, profile_, pss));\n  }\n\n#if defined(ENABLE_THEMES)\n  if (!command_line_->HasSwitch(switches::kDisableSyncThemes)) {\n    pss->RegisterDataTypeController(\n        new ThemeDataTypeController(this, profile_, pss));\n  }\n#endif\n\n  if (!command_line_->HasSwitch(switches::kDisableSyncSearchEngines)) {\n    pss->RegisterDataTypeController(\n        new SearchEngineDataTypeController(this, profile_, pss));\n  }\n\n  if (!command_line_->HasSwitch(switches::kDisableSyncExtensionSettings)) {\n    pss->RegisterDataTypeController(\n        new ExtensionSettingDataTypeController(\n            syncer::EXTENSION_SETTINGS, this, profile_, pss));\n  }\n\n  if (!command_line_->HasSwitch(switches::kDisableSyncAppSettings)) {\n    pss->RegisterDataTypeController(\n        new ExtensionSettingDataTypeController(\n            syncer::APP_SETTINGS, this, profile_, pss));\n  }\n \n  if (command_line_->HasSwitch(switches::kEnableSyncSyncedNotifications)) {\n#if !defined(OS_ANDROID)\n    pss->RegisterDataTypeController(\n        new UIDataTypeController(\n            syncer::SYNCED_NOTIFICATIONS, this, profile_, pss));\n#endif\n   }\n \n #if defined(OS_LINUX) || defined(OS_WIN) || defined(OS_CHROMEOS)\n  if (!command_line_->HasSwitch(switches::kDisableSyncDictionary)) {\n    pss->RegisterDataTypeController(\n        new UIDataTypeController(syncer::DICTIONARY, this, profile_, pss));\n  }\n#endif\n\n}\n", "target": 1, "idx": 183425}
{"func": "void RenderViewImpl::AcceleratedSurfaceFreeTransportDIB(\n    TransportDIB::Id dib_id) {\n  Send(new ViewHostMsg_FreeTransportDIB(dib_id));\n}\n", "target": 0, "idx": 108830}
{"func": "parse_wbxml_tag (proto_tree *tree, tvbuff_t *tvb, guint32 offset,\n\t\t guint32 str_tbl, guint8 *level,\n \t\t guint8 *codepage_stag, guint8 *codepage_attr)\n {\n \tguint32     tvb_len             = tvb_reported_length (tvb);\n\tguint32     off                 = offset;\n \tguint32     len;\n \tguint       str_len;\n \tguint32     ent;\n\tguint32     idx;\n\tguint8      peek;\n\tguint32     tag_len;                     /* Length of the idx (uintvar) from a LITERAL tag */\n\tguint8      tag_save_known      = 0;     /* Will contain peek & 0x3F (tag identity) */\n\tguint8      tag_new_known       = 0;     /* Will contain peek & 0x3F (tag identity) */\n\tconst char *tag_save_literal;            /* Will contain the LITERAL tag identity */\n\tconst char *tag_new_literal;             /* Will contain the LITERAL tag identity */\n\tchar       *tag_save_buf        = NULL;  /* Will contain \"tag_0x%02X\" */\n\tchar       *tag_new_buf         = NULL;  /* Will contain \"tag_0x%02X\" */\n\tguint8      parsing_tag_content = FALSE; /* Are we parsing content from a\n\t\t\t\t\t            tag with content: <x>Content</x>\n\n\t\t\t\t\t            The initial state is FALSE.\n\t\t\t\t\t            This state will trigger recursion. */\n \ttag_save_literal = NULL;                 /* Prevents compiler warning */\n \n \tDebugLog((\"parse_wbxml_tag (level = %u, offset = %u)\\n\", *level, offset));\n \twhile (off < tvb_len) {\n \t\tpeek = tvb_get_guint8 (tvb, off);\n \t\tDebugLog((\"STAG: (top of while) level = %3u, peek = 0x%02X, off = %u, tvb_len = %u\\n\", *level, peek, off, tvb_len));\n\t\tif ((peek & 0x3F) < 4) switch (peek) { /* Global tokens in state = STAG\n\t\t\t\t\t\t\t  but not the LITERAL tokens */\n\t\tcase 0x00: /* SWITCH_PAGE */\n\t\t\t*codepage_stag = tvb_get_guint8 (tvb, off+1);\n\t\t\tproto_tree_add_text (tree, tvb, off, 2,\n\t\t\t\t\t     \"      | Tag   | T -->%3d \"\n\t\t\t\t\t     \"| SWITCH_PAGE (Tag code page)     \"\n\t\t\t\t\t     \"|\",\n\t\t\t\t\t     *codepage_stag);\n\t\t\toff += 2;\n\t\t\tbreak;\n\t\tcase 0x01: /* END: only possible for Tag with Content */\n\t\t\tif (tag_save_known) { /* Known TAG */\n\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t     \"| END (Known Tag 0x%02X)            \"\n\t\t\t\t\t\t     \"| %s</%s>\",\n\t\t\t\t\t\t     *level, *codepage_stag, tag_save_known,\n\t\t\t\t\t\t     Indent (*level),\n\t\t\t\t\t\t     tag_save_literal); /* We already looked it up! */\n\t\t\t} else { /* Literal TAG */\n\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t     \"| END (Literal Tag)               \"\n\t\t\t\t\t\t     \"| %s</%s>\",\n\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level),\n\t\t\t\t\t\t     tag_save_literal ? tag_save_literal : \"\");\n\t\t\t}\n\t\t\t(*level)--;\n\t\t\toff++;\n\t\t\t/* Reset code page: not needed as return from recursion */\n\t\t\tDebugLog((\"STAG: level = %u, Return: len = %u\\n\",\n\t\t\t\t  *level, off - offset));\n\t\t\treturn (off - offset);\n\t\tcase 0x02: /* ENTITY */\n\t\t\tent = tvb_get_guintvar (tvb, off+1, &len);\n\t\t\tproto_tree_add_text (tree, tvb, off, 1+len,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t     \"| ENTITY                          \"\n\t\t\t\t\t     \"| %s'&#%u;'\",\n\t\t\t\t\t     *level, *codepage_stag, Indent (*level), ent);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x03: /* STR_I */\n\t\t\tlen = tvb_strsize (tvb, off+1);\n\t\t\tproto_tree_add_text (tree, tvb, off, 1+len,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t     \"| STR_I (Inline string)           \"\n\t\t\t\t\t     \"| %s\\'%s\\'\",\n\t\t\t\t\t     *level, *codepage_stag, Indent(*level),\n\t\t\t\t\t     tvb_format_text (tvb, off+1, len-1));\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x40: /* EXT_I_0 */\n\t\tcase 0x41: /* EXT_I_1 */\n\t\tcase 0x42: /* EXT_I_2 */\n\t\t\t/* Extension tokens */\n\t\t\tlen = tvb_strsize (tvb, off+1);\n\t\t\tproto_tree_add_text (tree, tvb, off, 1+len,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t     \"| EXT_I_%1x    (Extension Token)    \"\n\t\t\t\t\t     \"| %s(Inline string extension: \\'%s\\')\",\n\t\t\t\t\t     *level, *codepage_stag, peek & 0x0f, Indent (*level),\n\t\t\t\t\t     tvb_format_text (tvb, off+1, len-1));\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x43: /* PI */\n\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t     \"| PI (XML Processing Instruction) \"\n\t\t\t\t\t     \"| %s<?xml\",\n\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\tlen = parse_wbxml_attribute_list (tree, tvb, off, str_tbl,\n\t\t\t\t\t\t\t  *level, codepage_attr);\n\t\t\t/* Check that there is still room in packet */\n\t\t\toff += len;\n\t\t\tif (off >= tvb_len) {\n\t\t\t\tDebugLog((\"STAG: level = %u, ThrowException: len = %u (short frame)\\n\",\n\t\t\t\t\t  *level, off - offset));\n\t\t\t\t/*\n\t\t\t\t * TODO - Do we need to free g_malloc()ed memory?\n\t\t\t\t */\n\t\t\t\tTHROW(ReportedBoundsError);\n\t\t\t}\n\t\t\tproto_tree_add_text (tree, tvb, off-1, 1,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t     \"| END (PI)                        \"\n\t\t\t\t\t     \"| %s?>\",\n\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\tbreak;\n\t\tcase 0x80: /* EXT_T_0 */\n\t\tcase 0x81: /* EXT_T_1 */\n\t\tcase 0x82: /* EXT_T_2 */\n\t\t\t/* Extension tokens */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len);\n\t\t\tproto_tree_add_text (tree, tvb, off, 1+len,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t     \"| EXT_T_%1x    (Extension Token)    \"\n\t\t\t\t\t     \"| %s(Extension Token, integer value: %u)\",\n\t\t\t\t\t     *level, *codepage_stag, peek & 0x0f, Indent (*level),\n\t\t\t\t\t     idx);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x83: /* STR_T */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len);\n\t\t\tstr_len = tvb_strsize (tvb, str_tbl+idx);\n\t\t\tproto_tree_add_text (tree, tvb, off, 1+len,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t     \"| STR_T (Tableref string)         \"\n\t\t\t\t\t     \"| %s\\'%s\\'\",\n\t\t\t\t\t     *level, *codepage_stag, Indent (*level),\n\t\t\t\t\t     tvb_format_text (tvb, str_tbl+idx, str_len-1));\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0xC0: /* EXT_0 */\n\t\tcase 0xC1: /* EXT_1 */\n\t\tcase 0xC2: /* EXT_2 */\n\t\t\t/* Extension tokens */\n\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t     \"| EXT_%1x      (Extension Token)    \"\n\t\t\t\t\t     \"| %s(Single-byte extension)\",\n\t\t\t\t\t     *level, *codepage_stag, peek & 0x0f, Indent (*level));\n\t\t\toff++;\n\t\t\tbreak;\n\t\tcase 0xC3: /* OPAQUE - WBXML 1.1 and newer */\n\t\t\tif (tvb_get_guint8 (tvb, 0)) { /* WBXML 1.x (x > 0) */\n\t\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len);\n\t\t\t\tproto_tree_add_text (tree, tvb, off, 1 + len + idx,\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t     \"| OPAQUE (Opaque data)            \"\n\t\t\t\t\t\t     \"| %s(%d bytes of opaque data)\",\n\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level), idx);\n\t\t\t\toff += 1+len+idx;\n\t\t\t} else { /* WBXML 1.0 - RESERVED_2 token (invalid) */\n\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t     \"| RESERVED_2     (Invalid Token!) \"\n\t\t\t\t\t\t     \"| WBXML 1.0 parsing stops here.\",\n\t\t\t\t\t\t     *level, *codepage_stag);\n\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\toff = tvb_len;\n\t\t\t\tDebugLog((\"STAG: level = %u, Return: len = %u\\n\",\n\t\t\t\t\t  *level, off - offset));\n\t\t\t\treturn (off - offset);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\t/* No default clause, as all cases have been treated */\n\t\t} else { /* LITERAL or Known TAG */\n\t\t\t/* We must store the initial tag, and also retrieve the new tag.\n\t\t\t * For efficiency reasons, we store the literal tag representation\n\t\t\t * for known tags too, so we can easily close the tag without the\n\t\t\t * need of a new lookup and avoiding storage of token codepage.\n\t\t\t *\n\t\t\t * There are 4 possibilities:\n\t\t\t *\n\t\t\t *  1. Known tag followed by a known tag\n\t\t\t *  2. Known tag followed by a LITERAL tag\n\t\t\t *  3. LITERAL tag followed by Known tag\n\t\t\t *  4. LITERAL tag followed by LITERAL tag\n\t\t\t */\n\n\t\t\t/* Store the new tag */\n\t\t\ttag_len = 0;\n\t\t\tif ((peek & 0x3F) == 4) { /* LITERAL */\n\t\t\t\tDebugLog((\"STAG: LITERAL tag (peek = 0x%02X, off = %u)\"\n\t\t\t\t\t  \" - TableRef follows!\\n\", peek, off));\n\t\t\t\tidx = tvb_get_guintvar (tvb, off+1, &tag_len);\n\t\t\t\tstr_len = tvb_strsize (tvb, str_tbl+idx);\n\t\t\t\ttag_new_literal = (const gchar*)tvb_get_ptr (tvb, str_tbl+idx, str_len);\n\t\t\t\ttag_new_known = 0; /* invalidate known tag_new */\n\t\t\t} else { /* Known tag */\n\t\t\t\ttag_new_known = peek & 0x3F;\n\t\t\t\ttag_new_buf=wmem_strdup_printf(wmem_packet_scope(), \"Tag_0x%02X\",\n\t\t\t\t\t    tag_new_known);\n\t\t\t\ttag_new_literal = tag_new_buf;\n\t\t\t\t/* Stored looked up tag name string */\n\t\t\t}\n\n\t\t\t/* Parsing of TAG starts HERE */\n\t\t\tif (peek & 0x40) { /* Content present */\n\t\t\t\t/* Content follows\n\t\t\t\t * [!] An explicit END token is expected in these cases!\n\t\t\t\t * ==> Recursion possible if we encounter a tag with content;\n\t\t\t\t *     recursion will return at the explicit END token.\n\t\t\t\t */\n\t\t\t\tif (parsing_tag_content) { /* Recurse */\n\t\t\t\t\tDebugLog((\"STAG: Tag in Tag - RECURSE! (off = %u)\\n\", off));\n\t\t\t\t\t/* Do not process the attribute list:\n\t\t\t\t\t * recursion will take care of it */\n\t\t\t\t\t(*level)++;\n\t\t\t\t\tlen = parse_wbxml_tag (tree, tvb, off, str_tbl, level,\n\t\t\t\t\t\t\t       codepage_stag, codepage_attr);\n\t\t\t\t\toff += len;\n\t\t\t\t} else { /* Now we will have content to parse */\n\t\t\t\t\t/* Save the start tag so we can properly close it later. */\n\t\t\t\t\tif ((peek & 0x3F) == 4) { /* Literal tag */\n\t\t\t\t\t\ttag_save_literal = tag_new_literal;\n\t\t\t\t\t\ttag_save_known = 0;\n\t\t\t\t\t} else { /* Known tag */\n\t\t\t\t\t\ttag_save_known = tag_new_known;\n\t\t\t\t\t\ttag_save_buf=wmem_strdup_printf(wmem_packet_scope(), \"Tag_0x%02X\",\n\t\t\t\t\t\t\t    tag_new_known);\n\t\t\t\t\t\ttag_save_literal = tag_save_buf;\n\t\t\t\t\t\t/* The last statement avoids needless lookups */\n\t\t\t\t\t}\n\t\t\t\t\t/* Process the attribute list if present */\n\t\t\t\t\tif (peek & 0x80) { /* Content and Attribute list present */\n\t\t\t\t\t\tif (tag_new_known) { /* Known tag */\n\t\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t\t     \"|   Known Tag 0x%02X           (AC) \"\n\t\t\t\t\t\t\t\t\t     \"| %s<%s\",\n\t\t\t\t\t\t\t\t\t     *level, *codepage_stag, tag_new_known,\n\t\t\t\t\t\t\t\t\t     Indent (*level), tag_new_literal);\n\t\t\t\t\t\t\t/* Tag string already looked up earlier! */\n\t\t\t\t\t\t\toff++;\n\t\t\t\t\t\t} else { /* LITERAL tag */\n\t\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t\t     \"| LITERAL_AC (Literal tag)   (AC) \"\n\t\t\t\t\t\t\t\t\t     \"| %s<%s\",\n\t\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level),\n\t\t\t\t\t\t\t\t\t     tag_new_literal);\n\t\t\t\t\t\t\toff += 1 + tag_len;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlen = parse_wbxml_attribute_list (tree, tvb,\n\t\t\t\t\t\t\t\t\t\t  off, str_tbl, *level, codepage_attr);\n\t\t\t\t\t\t/* Check that there is still room in packet */\n\t\t\t\t\t\toff += len;\n\t\t\t\t\t\tif (off >= tvb_len) {\n\t\t\t\t\t\t\tDebugLog((\"STAG: level = %u, ThrowException: \"\n\t\t\t\t\t\t\t\t  \"len = %u (short frame)\\n\",\n\t\t\t\t\t\t\t\t  *level, off - offset));\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * TODO - Do we need to free g_malloc()ed memory?\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tTHROW(ReportedBoundsError);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off-1, 1,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t     \"| END (attribute list)            \"\n\t\t\t\t\t\t\t\t     \"| %s>\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\t\t\t} else { /* Content, no Attribute list */\n\t\t\t\t\t\tif (tag_new_known) { /* Known tag */\n\t\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t\t     \"|   Known Tag 0x%02X           (.C) \"\n\t\t\t\t\t\t\t\t\t     \"| %s<%s>\",\n\t\t\t\t\t\t\t\t\t     *level, *codepage_stag, tag_new_known,\n\t\t\t\t\t\t\t\t\t     Indent (*level), tag_new_literal);\n\t\t\t\t\t\t\t/* Tag string already looked up earlier! */\n\t\t\t\t\t\t\toff++;\n\t\t\t\t\t\t} else { /* LITERAL tag */\n\t\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t\t     \"| LITERAL_C  (Literal Tag)   (.C) \"\n\t\t\t\t\t\t\t\t\t     \"| %s<%s>\",\n\t\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level),\n\t\t\t\t\t\t\t\t\t     tag_new_literal);\n\t\t\t\t\t\t\toff += 1 + tag_len;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/* The data that follows in the parsing process\n\t\t\t\t\t * represents content for the opening tag\n\t\t\t\t\t * we've just processed in the lines above.\n\t\t\t\t\t * Next time we encounter a tag with content: recurse\n\t\t\t\t\t */\n\t\t\t\t\tparsing_tag_content = TRUE;\n\t\t\t\t\tDebugLog((\"Tag in Tag - No recursion this time! \"\n\t\t\t\t\t\t  \"(off = %u)\\n\", off));\n\t\t\t\t}\n\t\t\t} else { /* No Content */\n\t\t\t\tDebugLog((\"<Tag/> in Tag - No recursion! (off = %u)\\n\", off));\n\t\t\t\t(*level)++;\n\t\t\t\tif (peek & 0x80) { /* No Content, Attribute list present */\n\t\t\t\t\tif (tag_new_known) { /* Known tag */\n\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t     \"|   Known Tag 0x%02X           (A.) \"\n\t\t\t\t\t\t\t\t     \"| %s<%s\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, tag_new_known,\n\t\t\t\t\t\t\t\t     Indent (*level), tag_new_literal);\n\t\t\t\t\t\t/* Tag string already looked up earlier! */\n\t\t\t\t\t\toff++;\n\t\t\t\t\t\tlen = parse_wbxml_attribute_list (tree, tvb,\n\t\t\t\t\t\t\t\t\t\t  off, str_tbl, *level, codepage_attr);\n\t\t\t\t\t\t/* Check that there is still room in packet */\n\t\t\t\t\t\toff += len;\n\t\t\t\t\t\tif (off >= tvb_len) {\n\t\t\t\t\t\t\tDebugLog((\"STAG: level = %u, ThrowException: \"\n\t\t\t\t\t\t\t\t  \"len = %u (short frame)\\n\",\n\t\t\t\t\t\t\t\t  *level, off - offset));\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * TODO - Do we need to free g_malloc()ed memory?\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tTHROW(ReportedBoundsError);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off-1, 1,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t     \"| END (Known Tag)                 \"\n\t\t\t\t\t\t\t\t     \"| %s/>\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\t\t\t} else { /* LITERAL tag */\n\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t     \"| LITERAL_A  (Literal Tag)   (A.) \"\n\t\t\t\t\t\t\t\t     \"| %s<%s\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level),\n\t\t\t\t\t\t\t\t     tag_new_literal);\n\t\t\t\t\t\toff += 1 + tag_len;\n\t\t\t\t\t\tlen = parse_wbxml_attribute_list (tree, tvb,\n\t\t\t\t\t\t\t\t\t\t  off, str_tbl, *level, codepage_attr);\n\t\t\t\t\t\t/* Check that there is still room in packet */\n\t\t\t\t\t\toff += len;\n\t\t\t\t\t\tif (off >= tvb_len) {\n\t\t\t\t\t\t\tDebugLog((\"STAG: level = %u, ThrowException: \"\n\t\t\t\t\t\t\t\t  \"len = %u (short frame)\\n\",\n\t\t\t\t\t\t\t\t  *level, off - offset));\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * TODO - Do we need to free g_malloc()ed memory?\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tTHROW(ReportedBoundsError);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off-1, 1,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t     \"| END (Literal Tag)               \"\n\t\t\t\t\t\t\t\t     \"| %s/>\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\t\t\t}\n\t\t\t\t} else { /* No Content, No Attribute list */\n\t\t\t\t\tif (tag_new_known) { /* Known tag */\n\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t     \"|   Known Tag 0x%02x           (..) \"\n\t\t\t\t\t\t\t\t     \"| %s<%s />\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, tag_new_known,\n\t\t\t\t\t\t\t\t     Indent (*level), tag_new_literal);\n\t\t\t\t\t\t/* Tag string already looked up earlier! */\n\t\t\t\t\t\toff++;\n\t\t\t\t\t} else { /* LITERAL tag */\n\t\t\t\t\t\tproto_tree_add_text (tree, tvb, off, 1,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    \"\n\t\t\t\t\t\t\t\t     \"| LITERAL    (Literal Tag)   (..) \"\n\t\t\t\t\t\t\t\t     \"| %s<%s />\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level),\n\t\t\t\t\t\t\t\t     tag_new_literal);\n\t\t\t\t\t\toff += 1 + tag_len;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t(*level)--;\n \t\t\t\t/* TODO: Do I have to reset code page here? */\n \t\t\t}\n \t\t} /* if (tag & 0x3F) >= 5 */\n \t} /* while */\n \tDebugLog((\"STAG: level = %u, Return: len = %u (end of function body)\\n\",\n \t\t  *level, off - offset));\n\treturn (off - offset);\n}\n", "target": 1, "idx": 180313}
{"func": "static u32 alpha(struct illinois *ca, u32 da, u32 dm)\n{\n\tu32 d1 = dm / 100;\t/* Low threshold */\n\n\tif (da <= d1) {\n\t\t/* If never got out of low delay zone, then use max */\n\t\tif (!ca->rtt_above)\n\t\t\treturn ALPHA_MAX;\n\n\t\t/* Wait for 5 good RTT's before allowing alpha to go alpha max.\n\t\t * This prevents one good RTT from causing sudden window increase.\n\t\t */\n\t\tif (++ca->rtt_low < theta)\n\t\t\treturn ca->alpha;\n\n\t\tca->rtt_low = 0;\n\t\tca->rtt_above = 0;\n\t\treturn ALPHA_MAX;\n\t}\n\n\tca->rtt_above = 1;\n\n\t/*\n\t * Based on:\n\t *\n\t *      (dm - d1) amin amax\n\t * k1 = -------------------\n\t *         amax - amin\n\t *\n\t *       (dm - d1) amin\n\t * k2 = ----------------  - d1\n\t *        amax - amin\n\t *\n\t *             k1\n\t * alpha = ----------\n\t *          k2 + da\n\t */\n\n\tdm -= d1;\n\tda -= d1;\n\treturn (dm * ALPHA_MAX) /\n\t\t(dm + (da  * (ALPHA_MAX - ALPHA_MIN)) / ALPHA_MIN);\n}\n", "target": 0, "idx": 18524}
{"func": "bool GLES2DecoderImpl::CheckSubscriptionTarget(GLint location,\n                                               GLenum subscription,\n                                               const char* function_name) {\n  if (!CheckCurrentProgramForUniform(location, function_name)) {\n    return false;\n  }\n  GLint real_location = -1;\n  GLint array_index = -1;\n  const Program::UniformInfo* info =\n      state_.current_program->GetUniformInfoByFakeLocation(\n          location, &real_location, &array_index);\n  if (!info) {\n    LOCAL_SET_GL_ERROR(GL_INVALID_OPERATION, function_name, \"unknown location\");\n    return false;\n  }\n  if ((ValuebufferManager::ApiTypeForSubscriptionTarget(subscription) &\n       info->accepts_api_type) == 0) {\n    LOCAL_SET_GL_ERROR(GL_INVALID_OPERATION, function_name,\n                       \"wrong type for subscription\");\n    return false;\n  }\n  return true;\n}\n", "target": 0, "idx": 140707}
{"func": "CMD_FUNC(m_authenticate)\n{\n\taClient *agent_p = NULL;\n\n\t/* Failing to use CAP REQ for sasl is a protocol violation. */\n\tif (!SASL_SERVER || !MyConnect(sptr) || BadPtr(parv[1]) || !CHECKPROTO(sptr, PROTO_SASL))\n\t\treturn 0;\n\n\tif (sptr->local->sasl_complete)\n\t{\n\t\tsendto_one(sptr, err_str(ERR_SASLALREADY), me.name, BadPtr(sptr->name) ? \"*\" : sptr->name);\n \t\treturn 0;\n \t}\n \n \tif (strlen(parv[1]) > 400)\n \t{\n \t\tsendto_one(sptr, err_str(ERR_SASLTOOLONG), me.name, BadPtr(sptr->name) ? \"*\" : sptr->name);\n\t\treturn 0;\n\t}\n\n\tif (*sptr->local->sasl_agent)\n\t\tagent_p = find_client(sptr->local->sasl_agent, NULL);\n\n\tif (agent_p == NULL)\n\t{\n\t\tchar *addr = BadPtr(sptr->ip) ? \"0\" : sptr->ip;\n\t\tchar *certfp = moddata_client_get(sptr, \"certfp\");\n\n\t\tsendto_server(NULL, 0, 0, \":%s SASL %s %s H %s %s\",\n\t\t    me.name, SASL_SERVER, encode_puid(sptr), addr, addr);\n\n\t\tif (certfp)\n\t\t\tsendto_server(NULL, 0, 0, \":%s SASL %s %s S %s %s\",\n\t\t\t    me.name, SASL_SERVER, encode_puid(sptr), parv[1], certfp);\n\t\telse\n\t\t\tsendto_server(NULL, 0, 0, \":%s SASL %s %s S %s\",\n\t\t\t    me.name, SASL_SERVER, encode_puid(sptr), parv[1]);\n\t}\n\telse\n\t\tsendto_server(NULL, 0, 0, \":%s SASL %s %s C %s\",\n\t\t    me.name, AGENT_SID(agent_p), encode_puid(sptr), parv[1]);\n\n\tsptr->local->sasl_out++;\n\n\treturn 0;\n}\n", "target": 1, "idx": 181986}
{"func": "static void adapter_properties_callback(bt_status_t status, int num_properties,\n bt_property_t *properties) {\n    jobjectArray props;\n    jintArray types;\n    jbyteArray val;\n    jclass mclass;\n\n if (!checkCallbackThread()) {\n       ALOGE(\"Callback: '%s' is not called on the correct thread\", __FUNCTION__);\n return;\n }\n\n    ALOGV(\"%s: Status is: %d, Properties: %d\", __FUNCTION__, status, num_properties);\n\n if (status != BT_STATUS_SUCCESS) {\n        ALOGE(\"%s: Status %d is incorrect\", __FUNCTION__, status);\n return;\n }\n\n    val = (jbyteArray) callbackEnv->NewByteArray(num_properties);\n if (val == NULL) {\n        ALOGE(\"%s: Error allocating byteArray\", __FUNCTION__);\n return;\n }\n\n    mclass = callbackEnv->GetObjectClass(val);\n\n /* (BT) Initialize the jobjectArray and jintArray here itself and send the\n     initialized array pointers alone to get_properties */\n\n    props = callbackEnv->NewObjectArray(num_properties, mclass,\n                                             NULL);\n if (props == NULL) {\n        ALOGE(\"%s: Error allocating object Array for properties\", __FUNCTION__);\n return;\n }\n\n    types = (jintArray)callbackEnv->NewIntArray(num_properties);\n\n if (types == NULL) {\n        ALOGE(\"%s: Error allocating int Array for values\", __FUNCTION__);\n return;\n }\n    callbackEnv->DeleteLocalRef(mclass);\n    callbackEnv->DeleteLocalRef(val);\n\n if (get_properties(num_properties, properties, &types, &props) < 0) {\n if (props) callbackEnv->DeleteLocalRef(props);\n if (types) callbackEnv->DeleteLocalRef(types);\n return;\n }\n\n    callbackEnv->CallVoidMethod(sJniCallbacksObj, method_adapterPropertyChangedCallback, types,\n                                props);\n    checkAndClearExceptionFromCallback(callbackEnv, __FUNCTION__);\n    callbackEnv->DeleteLocalRef(props);\n    callbackEnv->DeleteLocalRef(types);\n return;\n\n}\n", "target": 0, "idx": 176833}
{"func": "void Browser::CloseContents(TabContents* source) {\n  if (is_attempting_to_close_browser_) {\n    ClearUnloadState(source);\n     return;\n   }\n \n  int index = tab_handler_->GetTabStripModel()->GetWrapperIndex(source);\n  if (index == TabStripModel::kNoTab) {\n    NOTREACHED() << \"CloseContents called for tab not in our strip\";\n    return;\n  }\n  tab_handler_->GetTabStripModel()->CloseTabContentsAt(\n      index,\n      TabStripModel::CLOSE_CREATE_HISTORICAL_TAB);\n}\n", "target": 1, "idx": 184177}
{"func": "struct sctp_chunk *sctp_make_abort_no_data(\n\tconst struct sctp_association *asoc,\n\tconst struct sctp_chunk *chunk, __u32 tsn)\n{\n\tstruct sctp_chunk *retval;\n\t__be32 payload;\n\n\tretval = sctp_make_abort(asoc, chunk, sizeof(sctp_errhdr_t)\n\t\t\t\t + sizeof(tsn));\n\n\tif (!retval)\n\t\tgoto no_mem;\n\n\t/* Put the tsn back into network byte order.  */\n\tpayload = htonl(tsn);\n\tsctp_init_cause(retval, SCTP_ERROR_NO_DATA, sizeof(payload));\n\tsctp_addto_chunk(retval, sizeof(payload), (const void *)&payload);\n\n\t/* RFC 2960 6.4 Multi-homed SCTP Endpoints\n\t *\n\t * An endpoint SHOULD transmit reply chunks (e.g., SACK,\n\t * HEARTBEAT ACK, * etc.) to the same destination transport\n\t * address from which it * received the DATA or control chunk\n\t * to which it is replying.\n\t *\n\t * [ABORT back to where the offender came from.]\n\t */\n\tif (chunk)\n\t\tretval->transport = chunk->transport;\n\nno_mem:\n\treturn retval;\n}\n", "target": 0, "idx": 35851}
{"func": "int unregister_ftrace_export(struct trace_export *export)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_export_lock);\n\n\tret = rm_ftrace_export(&ftrace_exports_list, export);\n\n\tmutex_unlock(&ftrace_export_lock);\n\n\treturn ret;\n}\n", "target": 0, "idx": 81544}
{"func": "void smp_wait_for_both_public_keys(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n  SMP_TRACE_DEBUG(\"%s\", __func__);\n\n if ((p_cb->flags & SMP_PAIR_FLAG_HAVE_PEER_PUBL_KEY) &&\n (p_cb->flags & SMP_PAIR_FLAG_HAVE_LOCAL_PUBL_KEY)) {\n if ((p_cb->role == HCI_ROLE_SLAVE) &&\n ((p_cb->req_oob_type == SMP_OOB_LOCAL) ||\n (p_cb->req_oob_type == SMP_OOB_BOTH))) {\n      smp_set_state(SMP_STATE_PUBLIC_KEY_EXCH);\n }\n    smp_sm_event(p_cb, SMP_BOTH_PUBL_KEYS_RCVD_EVT, NULL);\n }\n}\n", "target": 0, "idx": 175968}
{"func": "void NavigationControllerImpl::DiscardNonCommittedEntries() {\n  bool transient = transient_entry_index_ != -1;\n  DiscardNonCommittedEntriesInternal();\n\n  if (transient) {\n    delegate_->NotifyNavigationStateChanged(INVALIDATE_TYPE_ALL);\n  }\n}\n", "target": 0, "idx": 150445}
{"func": " bool AXObject::isLiveRegion() const {\n   const AtomicString& liveRegion = liveRegionStatus();\n  return equalIgnoringCase(liveRegion, \"polite\") ||\n         equalIgnoringCase(liveRegion, \"assertive\");\n }\n", "target": 1, "idx": 185805}
{"func": "process_extra(struct archive_read *a, const char *p, size_t extra_length, struct zip_entry* zip_entry)\n{\n\tunsigned offset = 0;\n\n\tif (extra_length == 0) {\n\t\treturn ARCHIVE_OK;\n\t}\n\n\tif (extra_length < 4) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Too-small extra data: Need at least 4 bytes, but only found %d bytes\", (int)extra_length);\n\t\treturn ARCHIVE_FAILED;\n\t}\n\twhile (offset <= extra_length - 4) {\n\t\tunsigned short headerid = archive_le16dec(p + offset);\n\t\tunsigned short datasize = archive_le16dec(p + offset + 2);\n\n\t\toffset += 4;\n\t\tif (offset + datasize > extra_length) {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Extra data overflow: Need %d bytes but only found %d bytes\",\n\t\t\t    (int)datasize, (int)(extra_length - offset));\n\t\t\treturn ARCHIVE_FAILED;\n\t\t}\n#ifdef DEBUG\n\t\tfprintf(stderr, \"Header id 0x%04x, length %d\\n\",\n\t\t    headerid, datasize);\n#endif\n\t\tswitch (headerid) {\n\t\tcase 0x0001:\n\t\t\t/* Zip64 extended information extra field. */\n\t\t\tzip_entry->flags |= LA_USED_ZIP64;\n\t\t\tif (zip_entry->uncompressed_size == 0xffffffff) {\n\t\t\t\tuint64_t t = 0;\n\t\t\t\tif (datasize < 8\n\t\t\t\t    || (t = archive_le64dec(p + offset)) > INT64_MAX) {\n\t\t\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t\t    \"Malformed 64-bit uncompressed size\");\n\t\t\t\t\treturn ARCHIVE_FAILED;\n\t\t\t\t}\n\t\t\t\tzip_entry->uncompressed_size = t;\n\t\t\t\toffset += 8;\n\t\t\t\tdatasize -= 8;\n\t\t\t}\n\t\t\tif (zip_entry->compressed_size == 0xffffffff) {\n\t\t\t\tuint64_t t = 0;\n\t\t\t\tif (datasize < 8\n\t\t\t\t    || (t = archive_le64dec(p + offset)) > INT64_MAX) {\n\t\t\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t\t    \"Malformed 64-bit compressed size\");\n\t\t\t\t\treturn ARCHIVE_FAILED;\n\t\t\t\t}\n\t\t\t\tzip_entry->compressed_size = t;\n\t\t\t\toffset += 8;\n\t\t\t\tdatasize -= 8;\n\t\t\t}\n\t\t\tif (zip_entry->local_header_offset == 0xffffffff) {\n\t\t\t\tuint64_t t = 0;\n\t\t\t\tif (datasize < 8\n\t\t\t\t    || (t = archive_le64dec(p + offset)) > INT64_MAX) {\n\t\t\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t\t    \"Malformed 64-bit local header offset\");\n\t\t\t\t\treturn ARCHIVE_FAILED;\n\t\t\t\t}\n\t\t\t\tzip_entry->local_header_offset = t;\n\t\t\t\toffset += 8;\n\t\t\t\tdatasize -= 8;\n\t\t\t}\n\t\t\t/* archive_le32dec(p + offset) gives disk\n\t\t\t * on which file starts, but we don't handle\n\t\t\t * multi-volume Zip files. */\n\t\t\tbreak;\n#ifdef DEBUG\n\t\tcase 0x0017:\n\t\t{\n\t\t\t/* Strong encryption field. */\n\t\t\tif (archive_le16dec(p + offset) == 2) {\n\t\t\t\tunsigned algId =\n\t\t\t\t\tarchive_le16dec(p + offset + 2);\n\t\t\t\tunsigned bitLen =\n\t\t\t\t\tarchive_le16dec(p + offset + 4);\n\t\t\t\tint\t flags =\n\t\t\t\t\tarchive_le16dec(p + offset + 6);\n\t\t\t\tfprintf(stderr, \"algId=0x%04x, bitLen=%u, \"\n\t\t\t\t    \"flgas=%d\\n\", algId, bitLen,flags);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tcase 0x5455:\n\t\t{\n\t\t\t/* Extended time field \"UT\". */\n\t\t\tint flags;\n\t\t\tif (datasize == 0) {\n\t\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Incomplete extended time field\");\n\t\t\t\treturn ARCHIVE_FAILED;\n\t\t\t}\n\t\t\tflags = p[offset];\n\t\t\toffset++;\n\t\t\tdatasize--;\n\t\t\t/* Flag bits indicate which dates are present. */\n\t\t\tif (flags & 0x01)\n\t\t\t{\n#ifdef DEBUG\n\t\t\t\tfprintf(stderr, \"mtime: %lld -> %d\\n\",\n\t\t\t\t    (long long)zip_entry->mtime,\n\t\t\t\t    archive_le32dec(p + offset));\n#endif\n\t\t\t\tif (datasize < 4)\n\t\t\t\t\tbreak;\n\t\t\t\tzip_entry->mtime = archive_le32dec(p + offset);\n\t\t\t\toffset += 4;\n\t\t\t\tdatasize -= 4;\n\t\t\t}\n\t\t\tif (flags & 0x02)\n\t\t\t{\n\t\t\t\tif (datasize < 4)\n\t\t\t\t\tbreak;\n\t\t\t\tzip_entry->atime = archive_le32dec(p + offset);\n\t\t\t\toffset += 4;\n\t\t\t\tdatasize -= 4;\n\t\t\t}\n\t\t\tif (flags & 0x04)\n\t\t\t{\n\t\t\t\tif (datasize < 4)\n\t\t\t\t\tbreak;\n\t\t\t\tzip_entry->ctime = archive_le32dec(p + offset);\n\t\t\t\toffset += 4;\n\t\t\t\tdatasize -= 4;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 0x5855:\n\t\t{\n\t\t\t/* Info-ZIP Unix Extra Field (old version) \"UX\". */\n\t\t\tif (datasize >= 8) {\n\t\t\t\tzip_entry->atime = archive_le32dec(p + offset);\n\t\t\t\tzip_entry->mtime =\n\t\t\t\t    archive_le32dec(p + offset + 4);\n\t\t\t}\n\t\t\tif (datasize >= 12) {\n\t\t\t\tzip_entry->uid =\n\t\t\t\t    archive_le16dec(p + offset + 8);\n\t\t\t\tzip_entry->gid =\n\t\t\t\t    archive_le16dec(p + offset + 10);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 0x6c78:\n\t\t{\n\t\t\t/* Experimental 'xl' field */\n\t\t\t/*\n\t\t\t * Introduced Dec 2013 to provide a way to\n\t\t\t * include external file attributes (and other\n\t\t\t * fields that ordinarily appear only in\n\t\t\t * central directory) in local file header.\n\t\t\t * This provides file type and permission\n\t\t\t * information necessary to support full\n\t\t\t * streaming extraction.  Currently being\n\t\t\t * discussed with other Zip developers\n\t\t\t * ... subject to change.\n\t\t\t *\n\t\t\t * Format:\n\t\t\t *  The field starts with a bitmap that specifies\n\t\t\t *  which additional fields are included.  The\n\t\t\t *  bitmap is variable length and can be extended in\n\t\t\t *  the future.\n\t\t\t *\n\t\t\t *  n bytes - feature bitmap: first byte has low-order\n\t\t\t *    7 bits.  If high-order bit is set, a subsequent\n\t\t\t *    byte holds the next 7 bits, etc.\n\t\t\t *\n\t\t\t *  if bitmap & 1, 2 byte \"version made by\"\n\t\t\t *  if bitmap & 2, 2 byte \"internal file attributes\"\n\t\t\t *  if bitmap & 4, 4 byte \"external file attributes\"\n\t\t\t *  if bitmap & 8, 2 byte comment length + n byte comment\n\t\t\t */\n\t\t\tint bitmap, bitmap_last;\n\n\t\t\tif (datasize < 1)\n\t\t\t\tbreak;\n\t\t\tbitmap_last = bitmap = 0xff & p[offset];\n\t\t\toffset += 1;\n\t\t\tdatasize -= 1;\n\n\t\t\t/* We only support first 7 bits of bitmap; skip rest. */\n\t\t\twhile ((bitmap_last & 0x80) != 0\n\t\t\t    && datasize >= 1) {\n\t\t\t\tbitmap_last = p[offset];\n\t\t\t\toffset += 1;\n\t\t\t\tdatasize -= 1;\n\t\t\t}\n\n\t\t\tif (bitmap & 1) {\n\t\t\t\t/* 2 byte \"version made by\" */\n\t\t\t\tif (datasize < 2)\n\t\t\t\t\tbreak;\n\t\t\t\tzip_entry->system\n\t\t\t\t    = archive_le16dec(p + offset) >> 8;\n\t\t\t\toffset += 2;\n\t\t\t\tdatasize -= 2;\n\t\t\t}\n\t\t\tif (bitmap & 2) {\n\t\t\t\t/* 2 byte \"internal file attributes\" */\n\t\t\t\tuint32_t internal_attributes;\n\t\t\t\tif (datasize < 2)\n\t\t\t\t\tbreak;\n\t\t\t\tinternal_attributes\n\t\t\t\t    = archive_le16dec(p + offset);\n\t\t\t\t/* Not used by libarchive at present. */\n\t\t\t\t(void)internal_attributes; /* UNUSED */\n\t\t\t\toffset += 2;\n\t\t\t\tdatasize -= 2;\n\t\t\t}\n\t\t\tif (bitmap & 4) {\n\t\t\t\t/* 4 byte \"external file attributes\" */\n\t\t\t\tuint32_t external_attributes;\n\t\t\t\tif (datasize < 4)\n\t\t\t\t\tbreak;\n\t\t\t\texternal_attributes\n\t\t\t\t    = archive_le32dec(p + offset);\n\t\t\t\tif (zip_entry->system == 3) {\n\t\t\t\t\tzip_entry->mode\n\t\t\t\t\t    = external_attributes >> 16;\n\t\t\t\t} else if (zip_entry->system == 0) {\n\t\t\t\t\tif (0x10 == (external_attributes & 0x10)) {\n\t\t\t\t\t\tzip_entry->mode = AE_IFDIR | 0775;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tzip_entry->mode = AE_IFREG | 0664;\n\t\t\t\t\t}\n\t\t\t\t\tif (0x01 == (external_attributes & 0x01)) {\n\t\t\t\t\t\tzip_entry->mode &= 0555;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tzip_entry->mode = 0;\n\t\t\t\t}\n\t\t\t\toffset += 4;\n\t\t\t\tdatasize -= 4;\n\t\t\t}\n\t\t\tif (bitmap & 8) {\n\t\t\t\t/* 2 byte comment length + comment */\n\t\t\t\tuint32_t comment_length;\n\t\t\t\tif (datasize < 2)\n\t\t\t\t\tbreak;\n\t\t\t\tcomment_length\n\t\t\t\t    = archive_le16dec(p + offset);\n\t\t\t\toffset += 2;\n\t\t\t\tdatasize -= 2;\n\n\t\t\t\tif (datasize < comment_length)\n\t\t\t\t\tbreak;\n\t\t\t\t/* Comment is not supported by libarchive */\n\t\t\t\toffset += comment_length;\n\t\t\t\tdatasize -= comment_length;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 0x7855:\n\t\t\t/* Info-ZIP Unix Extra Field (type 2) \"Ux\". */\n#ifdef DEBUG\n\t\t\tfprintf(stderr, \"uid %d gid %d\\n\",\n\t\t\t    archive_le16dec(p + offset),\n\t\t\t    archive_le16dec(p + offset + 2));\n#endif\n\t\t\tif (datasize >= 2)\n\t\t\t\tzip_entry->uid = archive_le16dec(p + offset);\n\t\t\tif (datasize >= 4)\n\t\t\t\tzip_entry->gid =\n\t\t\t\t    archive_le16dec(p + offset + 2);\n\t\t\tbreak;\n\t\tcase 0x7875:\n\t\t{\n\t\t\t/* Info-Zip Unix Extra Field (type 3) \"ux\". */\n\t\t\tint uidsize = 0, gidsize = 0;\n\n\t\t\t/* TODO: support arbitrary uidsize/gidsize. */\n\t\t\tif (datasize >= 1 && p[offset] == 1) {/* version=1 */\n\t\t\t\tif (datasize >= 4) {\n\t\t\t\t\t/* get a uid size. */\n\t\t\t\t\tuidsize = 0xff & (int)p[offset+1];\n\t\t\t\t\tif (uidsize == 2)\n\t\t\t\t\t\tzip_entry->uid =\n\t\t\t\t\t\t    archive_le16dec(\n\t\t\t\t\t\t        p + offset + 2);\n\t\t\t\t\telse if (uidsize == 4 && datasize >= 6)\n\t\t\t\t\t\tzip_entry->uid =\n\t\t\t\t\t\t    archive_le32dec(\n\t\t\t\t\t\t        p + offset + 2);\n\t\t\t\t}\n\t\t\t\tif (datasize >= (2 + uidsize + 3)) {\n\t\t\t\t\t/* get a gid size. */\n\t\t\t\t\tgidsize = 0xff & (int)p[offset+2+uidsize];\n\t\t\t\t\tif (gidsize == 2)\n\t\t\t\t\t\tzip_entry->gid =\n\t\t\t\t\t\t    archive_le16dec(\n\t\t\t\t\t\t        p+offset+2+uidsize+1);\n\t\t\t\t\telse if (gidsize == 4 &&\n\t\t\t\t\t    datasize >= (2 + uidsize + 5))\n\t\t\t\t\t\tzip_entry->gid =\n\t\t\t\t\t\t    archive_le32dec(\n\t\t\t\t\t\t        p+offset+2+uidsize+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 0x9901:\n\t\t\t/* WinZip AES extra data field. */\n\t\t\tif (datasize < 6) {\n\t\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Incomplete AES field\");\n\t\t\t\treturn ARCHIVE_FAILED;\n\t\t\t}\n\t\t\tif (p[offset + 2] == 'A' && p[offset + 3] == 'E') {\n\t\t\t\t/* Vendor version. */\n\t\t\t\tzip_entry->aes_extra.vendor =\n\t\t\t\t    archive_le16dec(p + offset);\n\t\t\t\t/* AES encryption strength. */\n\t\t\t\tzip_entry->aes_extra.strength = p[offset + 4];\n\t\t\t\t/* Actual compression method. */\n\t\t\t\tzip_entry->aes_extra.compression =\n\t\t\t\t    p[offset + 5];\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\toffset += datasize;\n\t}\n\tif (offset != extra_length) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Malformed extra data: Consumed %d bytes of %d bytes\",\n\t\t    (int)offset, (int)extra_length);\n\t\treturn ARCHIVE_FAILED;\n\t}\n\treturn ARCHIVE_OK;\n}\n", "target": 0, "idx": 90629}
{"func": "setup_efi_state(struct boot_params *params, unsigned long params_load_addr,\n\t\tunsigned int efi_map_offset, unsigned int efi_map_sz,\n\t\tunsigned int efi_setup_data_offset)\n{\n\tstruct efi_info *current_ei = &boot_params.efi_info;\n\tstruct efi_info *ei = &params->efi_info;\n\n\tif (!current_ei->efi_memmap_size)\n\t\treturn 0;\n\n\t/*\n\t * If 1:1 mapping is not enabled, second kernel can not setup EFI\n\t * and use EFI run time services. User space will have to pass\n\t * acpi_rsdp=<addr> on kernel command line to make second kernel boot\n\t * without efi.\n\t */\n \tif (efi_enabled(EFI_OLD_MEMMAP))\n \t\treturn 0;\n \n \tei->efi_loader_signature = current_ei->efi_loader_signature;\n \tei->efi_systab = current_ei->efi_systab;\n \tei->efi_systab_hi = current_ei->efi_systab_hi;\n\n\tei->efi_memdesc_version = current_ei->efi_memdesc_version;\n\tei->efi_memdesc_size = efi_get_runtime_map_desc_size();\n\n\tsetup_efi_info_memmap(params, params_load_addr, efi_map_offset,\n\t\t\t      efi_map_sz);\n\tprepare_add_efi_setup_data(params, params_load_addr,\n\t\t\t\t   efi_setup_data_offset);\n\treturn 0;\n}\n", "target": 1, "idx": 182040}
{"func": "static int do_one_broadcast(struct sock *sk,\n\t\t\t\t   struct netlink_broadcast_data *p)\n{\n\tstruct netlink_sock *nlk = nlk_sk(sk);\n\tint val;\n\n\tif (p->exclude_sk == sk)\n\t\tgoto out;\n\n\tif (nlk->portid == p->portid || p->group - 1 >= nlk->ngroups ||\n\t    !test_bit(p->group - 1, nlk->groups))\n\t\tgoto out;\n\n\tif (!net_eq(sock_net(sk), p->net))\n\t\tgoto out;\n\n\tif (p->failure) {\n\t\tnetlink_overrun(sk);\n\t\tgoto out;\n\t}\n\n\tsock_hold(sk);\n\tif (p->skb2 == NULL) {\n\t\tif (skb_shared(p->skb)) {\n\t\t\tp->skb2 = skb_clone(p->skb, p->allocation);\n\t\t} else {\n\t\t\tp->skb2 = skb_get(p->skb);\n\t\t\t/*\n\t\t\t * skb ownership may have been set when\n\t\t\t * delivered to a previous socket.\n\t\t\t */\n\t\t\tskb_orphan(p->skb2);\n\t\t}\n\t}\n\tif (p->skb2 == NULL) {\n\t\tnetlink_overrun(sk);\n\t\t/* Clone failed. Notify ALL listeners. */\n\t\tp->failure = 1;\n\t\tif (nlk->flags & NETLINK_BROADCAST_SEND_ERROR)\n\t\t\tp->delivery_failure = 1;\n\t} else if (p->tx_filter && p->tx_filter(sk, p->skb2, p->tx_data)) {\n\t\tkfree_skb(p->skb2);\n\t\tp->skb2 = NULL;\n\t} else if (sk_filter(sk, p->skb2)) {\n\t\tkfree_skb(p->skb2);\n\t\tp->skb2 = NULL;\n\t} else if ((val = netlink_broadcast_deliver(sk, p->skb2)) < 0) {\n\t\tnetlink_overrun(sk);\n\t\tif (nlk->flags & NETLINK_BROADCAST_SEND_ERROR)\n\t\t\tp->delivery_failure = 1;\n\t} else {\n\t\tp->congested |= val;\n\t\tp->delivered = 1;\n\t\tp->skb2 = NULL;\n\t}\n\tsock_put(sk);\n\nout:\n\treturn 0;\n}\n", "target": 0, "idx": 40505}
{"func": " ContentEncoding::ContentCompression::~ContentCompression() {\n  delete [] settings;\n }\n", "target": 1, "idx": 188481}
{"func": "void AddInputMethodNames(const GList* engines, InputMethodDescriptors* out) {\n  DCHECK(out);\n  for (; engines; engines = g_list_next(engines)) {\n    IBusEngineDesc* engine_desc = IBUS_ENGINE_DESC(engines->data);\n    const gchar* name = ibus_engine_desc_get_name(engine_desc);\n    const gchar* longname = ibus_engine_desc_get_longname(engine_desc);\n    const gchar* layout = ibus_engine_desc_get_layout(engine_desc);\n    const gchar* language = ibus_engine_desc_get_language(engine_desc);\n    if (InputMethodIdIsWhitelisted(name)) {\n      out->push_back(CreateInputMethodDescriptor(name,\n                                                  longname,\n                                                  layout,\n                                                  language));\n      DLOG(INFO) << name << \" (preloaded)\";\n     }\n   }\n }\n", "target": 1, "idx": 183974}
{"func": " bool inode_owner_or_capable(const struct inode *inode)\n {\n \tif (uid_eq(current_fsuid(), inode->i_uid))\n \t\treturn true;\n\tif (inode_capable(inode, CAP_FOWNER))\n \t\treturn true;\n \treturn false;\n }\n", "target": 1, "idx": 179491}
{"func": "static u32 get_ccsidr(u32 csselr)\n{\n\tu32 ccsidr;\n\n\t/* Make sure noone else changes CSSELR during this! */\n\tlocal_irq_disable();\n\twrite_sysreg(csselr, csselr_el1);\n\tisb();\n\tccsidr = read_sysreg(ccsidr_el1);\n\tlocal_irq_enable();\n\n\treturn ccsidr;\n}\n", "target": 0, "idx": 62884}
{"func": "bool FileSystemPolicy::GenerateRules(const wchar_t* name,\n                                     TargetPolicy::Semantics semantics,\n                                     LowLevelPolicy* policy) {\n  std::wstring mod_name(name);\n  if (mod_name.empty()) {\n     return false;\n   }\n \n   if (!PreProcessName(mod_name, &mod_name)) {\n    NOTREACHED();\n    return false;\n  }\n\n  if (0 != mod_name.compare(0, kNTPrefixLen, kNTPrefix)) {\n    mod_name.insert(0, L\"\\\\/?/?\\\\\");\n    name = mod_name.c_str();\n  }\n\n  EvalResult result = ASK_BROKER;\n\n  const unsigned kCallNtCreateFile = 0x1;\n  const unsigned kCallNtOpenFile = 0x2;\n  const unsigned kCallNtQueryAttributesFile = 0x4;\n  const unsigned kCallNtQueryFullAttributesFile = 0x8;\n  const unsigned kCallNtSetInfoRename = 0x10;\n\n  DWORD  rule_to_add = kCallNtOpenFile | kCallNtCreateFile |\n                       kCallNtQueryAttributesFile |\n                       kCallNtQueryFullAttributesFile | kCallNtSetInfoRename;\n\n  PolicyRule create(result);\n  PolicyRule open(result);\n  PolicyRule query(result);\n  PolicyRule query_full(result);\n  PolicyRule rename(result);\n\n  switch (semantics) {\n    case TargetPolicy::FILES_ALLOW_DIR_ANY: {\n      open.AddNumberMatch(IF, OpenFile::OPTIONS, FILE_DIRECTORY_FILE, AND);\n      create.AddNumberMatch(IF, OpenFile::OPTIONS, FILE_DIRECTORY_FILE, AND);\n      break;\n    }\n    case TargetPolicy::FILES_ALLOW_READONLY: {\n      DWORD allowed_flags = FILE_READ_DATA | FILE_READ_ATTRIBUTES |\n                            FILE_READ_EA | SYNCHRONIZE | FILE_EXECUTE |\n                            GENERIC_READ | GENERIC_EXECUTE | READ_CONTROL;\n      DWORD restricted_flags = ~allowed_flags;\n      open.AddNumberMatch(IF_NOT, OpenFile::ACCESS, restricted_flags, AND);\n      create.AddNumberMatch(IF_NOT, OpenFile::ACCESS, restricted_flags, AND);\n\n      rule_to_add &= ~kCallNtSetInfoRename;\n      break;\n    }\n    case TargetPolicy::FILES_ALLOW_QUERY: {\n      rule_to_add &= ~(kCallNtOpenFile | kCallNtCreateFile |\n                       kCallNtSetInfoRename);\n      break;\n    }\n    case TargetPolicy::FILES_ALLOW_ANY: {\n      break;\n    }\n    default: {\n      NOTREACHED();\n      return false;\n    }\n  }\n\n  if ((rule_to_add & kCallNtCreateFile) &&\n      (!create.AddStringMatch(IF, OpenFile::NAME, name, CASE_INSENSITIVE) ||\n       !policy->AddRule(IPC_NTCREATEFILE_TAG, &create))) {\n    return false;\n  }\n\n  if ((rule_to_add & kCallNtOpenFile) &&\n      (!open.AddStringMatch(IF, OpenFile::NAME, name, CASE_INSENSITIVE) ||\n       !policy->AddRule(IPC_NTOPENFILE_TAG, &open))) {\n    return false;\n  }\n\n  if ((rule_to_add & kCallNtQueryAttributesFile) &&\n      (!query.AddStringMatch(IF, FileName::NAME, name, CASE_INSENSITIVE) ||\n       !policy->AddRule(IPC_NTQUERYATTRIBUTESFILE_TAG, &query))) {\n    return false;\n  }\n\n  if ((rule_to_add & kCallNtQueryFullAttributesFile) &&\n      (!query_full.AddStringMatch(IF, FileName::NAME, name, CASE_INSENSITIVE)\n       || !policy->AddRule(IPC_NTQUERYFULLATTRIBUTESFILE_TAG,\n                           &query_full))) {\n    return false;\n  }\n\n  if ((rule_to_add & kCallNtSetInfoRename) &&\n      (!rename.AddStringMatch(IF, FileName::NAME, name, CASE_INSENSITIVE) ||\n       !policy->AddRule(IPC_NTSETINFO_RENAME_TAG, &rename))) {\n    return false;\n  }\n\n  return true;\n}\n", "target": 1, "idx": 183553}
{"func": "GC_API void * GC_CALL GC_generic_malloc(size_t lb, int k)\n{\n    void * result;\n    DCL_LOCK_STATE;\n\n    if (EXPECT(GC_have_errors, FALSE))\n      GC_print_all_errors();\n    GC_INVOKE_FINALIZERS();\n    if (SMALL_OBJ(lb)) {\n        LOCK();\n        result = GC_generic_malloc_inner((word)lb, k);\n        UNLOCK();\n    } else {\n        size_t lg;\n        size_t lb_rounded;\n        word n_blocks;\n         GC_bool init;\n         lg = ROUNDED_UP_GRANULES(lb);\n         lb_rounded = GRANULES_TO_BYTES(lg);\n         n_blocks = OBJ_SZ_TO_BLOCKS(lb_rounded);\n         init = GC_obj_kinds[k].ok_init;\n         LOCK();\n        result = (ptr_t)GC_alloc_large(lb_rounded, k, 0);\n        if (0 != result) {\n          if (GC_debugging_started) {\n            BZERO(result, n_blocks * HBLKSIZE);\n          } else {\n#           ifdef THREADS\n              /* Clear any memory that might be used for GC descriptors */\n              /* before we release the lock.                            */\n                ((word *)result)[0] = 0;\n                ((word *)result)[1] = 0;\n                ((word *)result)[GRANULES_TO_WORDS(lg)-1] = 0;\n                ((word *)result)[GRANULES_TO_WORDS(lg)-2] = 0;\n#           endif\n          }\n        }\n        GC_bytes_allocd += lb_rounded;\n        UNLOCK();\n        if (init && !GC_debugging_started && 0 != result) {\n            BZERO(result, n_blocks * HBLKSIZE);\n        }\n    }\n    if (0 == result) {\n        return((*GC_get_oom_fn())(lb));\n    } else {\n        return(result);\n    }\n}\n", "target": 1, "idx": 183050}
{"func": "PlatformFileForTransit GetFileHandleForProcess(base::PlatformFile handle,\n                                               base::ProcessHandle process,\n                                               bool close_source_handle) {\n  IPC::PlatformFileForTransit out_handle;\n#if defined(OS_WIN)\n   DWORD options = DUPLICATE_SAME_ACCESS;\n   if (close_source_handle)\n     options |= DUPLICATE_CLOSE_SOURCE;\n  if (!::DuplicateHandle(::GetCurrentProcess(),\n                          handle,\n                          process,\n                          &out_handle,\n                         0,\n                         FALSE,\n                         options)) {\n    out_handle = IPC::InvalidPlatformFileForTransit();\n  }\n#elif defined(OS_POSIX)\n  int fd = close_source_handle ? handle : ::dup(handle);\n  out_handle = base::FileDescriptor(fd, true);\n#else\n  #error Not implemented.\n#endif\n  return out_handle;\n}\n", "target": 1, "idx": 185012}
{"func": "int ext4_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tstruct page *page = vmf->page;\n\tloff_t size;\n\tunsigned long len;\n\tint ret;\n\tstruct file *file = vma->vm_file;\n\tstruct inode *inode = file_inode(file);\n\tstruct address_space *mapping = inode->i_mapping;\n\thandle_t *handle;\n\tget_block_t *get_block;\n\tint retries = 0;\n \n \tsb_start_pagefault(inode->i_sb);\n \tfile_update_time(vma->vm_file);\n \t/* Delalloc case is easy... */\n \tif (test_opt(inode->i_sb, DELALLOC) &&\n \t    !ext4_should_journal_data(inode) &&\n\t    !ext4_nonda_switch(inode->i_sb)) {\n\t\tdo {\n\t\t\tret = block_page_mkwrite(vma, vmf,\n\t\t\t\t\t\t   ext4_da_get_block_prep);\n\t\t} while (ret == -ENOSPC &&\n\t\t       ext4_should_retry_alloc(inode->i_sb, &retries));\n\t\tgoto out_ret;\n\t}\n\n\tlock_page(page);\n\tsize = i_size_read(inode);\n\t/* Page got truncated from under us? */\n\tif (page->mapping != mapping || page_offset(page) > size) {\n\t\tunlock_page(page);\n\t\tret = VM_FAULT_NOPAGE;\n\t\tgoto out;\n\t}\n\n\tif (page->index == size >> PAGE_CACHE_SHIFT)\n\t\tlen = size & ~PAGE_CACHE_MASK;\n\telse\n\t\tlen = PAGE_CACHE_SIZE;\n\t/*\n\t * Return if we have all the buffers mapped. This avoids the need to do\n\t * journal_start/journal_stop which can block and take a long time\n\t */\n\tif (page_has_buffers(page)) {\n\t\tif (!ext4_walk_page_buffers(NULL, page_buffers(page),\n\t\t\t\t\t    0, len, NULL,\n\t\t\t\t\t    ext4_bh_unmapped)) {\n\t\t\t/* Wait so that we don't change page under IO */\n\t\t\twait_for_stable_page(page);\n\t\t\tret = VM_FAULT_LOCKED;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tunlock_page(page);\n\t/* OK, we need to fill the hole... */\n\tif (ext4_should_dioread_nolock(inode))\n\t\tget_block = ext4_get_block_write;\n\telse\n\t\tget_block = ext4_get_block;\nretry_alloc:\n\thandle = ext4_journal_start(inode, EXT4_HT_WRITE_PAGE,\n\t\t\t\t    ext4_writepage_trans_blocks(inode));\n\tif (IS_ERR(handle)) {\n\t\tret = VM_FAULT_SIGBUS;\n\t\tgoto out;\n\t}\n\tret = block_page_mkwrite(vma, vmf, get_block);\n\tif (!ret && ext4_should_journal_data(inode)) {\n\t\tif (ext4_walk_page_buffers(handle, page_buffers(page), 0,\n\t\t\t  PAGE_CACHE_SIZE, NULL, do_journal_get_write_access)) {\n\t\t\tunlock_page(page);\n\t\t\tret = VM_FAULT_SIGBUS;\n\t\t\text4_journal_stop(handle);\n\t\t\tgoto out;\n\t\t}\n\t\text4_set_inode_state(inode, EXT4_STATE_JDATA);\n\t}\n\text4_journal_stop(handle);\n\tif (ret == -ENOSPC && ext4_should_retry_alloc(inode->i_sb, &retries))\n\t\tgoto retry_alloc;\n out_ret:\n \tret = block_page_mkwrite_return(ret);\n out:\n \tsb_end_pagefault(inode->i_sb);\n \treturn ret;\n }\n", "target": 1, "idx": 180661}
{"func": "void PrintJobWorker::GetSettingsWithUI(gfx::NativeWindow parent_window,\n                                        int document_page_count,\n                                        bool has_selection) {\n   DCHECK(ChromeThread::CurrentlyOn(ChromeThread::UI));\n \n   PrintingContext::Result result = printing_context_.AskUserForSettings(\n      parent_window, document_page_count, has_selection);\n   message_loop()->PostTask(FROM_HERE, NewRunnableMethod(\n       this, &PrintJobWorker::GetSettingsDone, result));\n }\n", "target": 1, "idx": 183502}
{"func": "mrb_mod_instance_methods(mrb_state *mrb, mrb_value mod)\n{\n  struct RClass *c = mrb_class_ptr(mod);\n  mrb_bool recur = TRUE;\n  mrb_get_args(mrb, \"|b\", &recur);\n  return mrb_class_instance_method_list(mrb, recur, c, 0);\n}\n", "target": 0, "idx": 82119}
{"func": " void BluetoothDeviceChromeOS::SetPasskey(uint32 passkey) {\n  if (!agent_.get() || passkey_callback_.is_null())\n     return;\n \n  passkey_callback_.Run(SUCCESS, passkey);\n  passkey_callback_.Reset();\n }\n", "target": 1, "idx": 184931}
{"func": " void FindBarController::Observe(NotificationType type,\n                                 const NotificationSource& source,\n                                 const NotificationDetails& details) {\n  FindManager* find_manager = tab_contents_->GetFindManager();\n   if (type == NotificationType::FIND_RESULT_AVAILABLE) {\n     if (Source<TabContents>(source).ptr() == tab_contents_->tab_contents()) {\n       UpdateFindBarForCurrentResult();\n      if (find_manager->find_result().final_update() &&\n          find_manager->find_result().number_of_matches() == 0) {\n        const string16& last_search = find_manager->previous_find_text();\n        const string16& current_search = find_manager->find_text();\n         if (last_search.find(current_search) != 0)\n           find_bar_->AudibleAlert();\n       }\n    }\n  } else if (type == NotificationType::NAV_ENTRY_COMMITTED) {\n    NavigationController* source_controller =\n        Source<NavigationController>(source).ptr();\n    if (source_controller == &tab_contents_->controller()) {\n      NavigationController::LoadCommittedDetails* commit_details =\n          Details<NavigationController::LoadCommittedDetails>(details).ptr();\n      PageTransition::Type transition_type =\n          commit_details->entry->transition_type();\n      if (find_bar_->IsFindBarVisible()) {\n        if (PageTransition::StripQualifier(transition_type) !=\n            PageTransition::RELOAD) {\n          EndFindSession(kKeepSelection);\n         } else {\n          find_manager->set_find_op_aborted(true);\n         }\n       }\n     }\n  }\n}\n", "target": 1, "idx": 184128}
{"func": "void GLES2DecoderPassthroughImpl::OnDebugMessage(GLenum source,\n                                                 GLenum type,\n                                                 GLuint id,\n                                                 GLenum severity,\n                                                 GLsizei length,\n                                                 const GLchar* message) {\n  if (type == GL_DEBUG_TYPE_ERROR && source == GL_DEBUG_SOURCE_API) {\n    had_error_callback_ = true;\n  }\n}\n", "target": 0, "idx": 154483}
{"func": "ResourceRequestInfoImpl* ResourceDispatcherHostImpl::CreateRequestInfo(\n    int child_id,\n    int render_view_route_id,\n    int render_frame_route_id,\n    bool download,\n    ResourceContext* context) {\n  return new ResourceRequestInfoImpl(\n      PROCESS_TYPE_RENDERER,\n      child_id,\n      render_view_route_id,\n      -1,  // frame_tree_node_id\n      0,\n      request_id_,\n      render_frame_route_id,\n      false,             // is_main_frame\n      false,             // parent_is_main_frame\n      RESOURCE_TYPE_SUB_RESOURCE,\n      ui::PAGE_TRANSITION_LINK,\n      false,     // should_replace_current_entry\n      download,  // is_download\n      false,     // is_stream\n      download,  // allow_download\n      false,     // has_user_gesture\n      false,     // enable_load_timing\n      false,     // enable_upload_progress\n      false,     // do_not_prompt_for_login\n      blink::WebReferrerPolicyDefault,\n      blink::WebPageVisibilityStateVisible,\n      context,\n      base::WeakPtr<ResourceMessageFilter>(),  // filter\n      false,                                   // report_raw_headers\n      true,                                    // is_async\n      false,                                   // is_using_lofi\n      std::string());                          // original_headers\n}\n", "target": 0, "idx": 145485}
{"func": "void TabStrip::SetIdealBoundsFromPositions(const std::vector<int>& positions) {\n  if (static_cast<size_t>(tab_count()) != positions.size())\n    return;\n\n  for (int i = 0; i < tab_count(); ++i) {\n    gfx::Rect bounds(ideal_bounds(i));\n    bounds.set_x(positions[i]);\n    set_ideal_bounds(i, bounds);\n  }\n}\n", "target": 0, "idx": 134419}
{"func": " void FindBarController::Show() {\n  FindManager* find_manager = tab_contents_->GetFindManager();\n \n  if (!find_manager->find_ui_active()) {\n     MaybeSetPrepopulateText();\n \n    find_manager->set_find_ui_active(true);\n     find_bar_->Show(true);\n   }\n   find_bar_->SetFocusAndSelection();\n}\n", "target": 1, "idx": 184129}
