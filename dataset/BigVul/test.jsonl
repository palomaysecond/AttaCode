{"func": "ext4_xattr_block_get(struct inode *inode, int name_index, const char *name,\n\t\t     void *buffer, size_t buffer_size)\n{\n\tstruct buffer_head *bh = NULL;\n \tstruct ext4_xattr_entry *entry;\n \tsize_t size;\n \tint error;\n\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n \n \tea_idebug(inode, \"name=%d.%s, buffer=%p, buffer_size=%ld\",\n \t\t  name_index, name, buffer, (long)buffer_size);\n\n\terror = -ENODATA;\n\tif (!EXT4_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tea_idebug(inode, \"reading block %llu\",\n\t\t  (unsigned long long)EXT4_I(inode)->i_file_acl);\n\tbh = sb_bread(inode->i_sb, EXT4_I(inode)->i_file_acl);\n\tif (!bh)\n\t\tgoto cleanup;\n\tea_bdebug(bh, \"b_count=%d, refcount=%d\",\n\t\tatomic_read(&(bh->b_count)), le32_to_cpu(BHDR(bh)->h_refcount));\n\tif (ext4_xattr_check_block(inode, bh)) {\nbad_block:\n\t\tEXT4_ERROR_INODE(inode, \"bad block %llu\",\n\t\t\t\t EXT4_I(inode)->i_file_acl);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto cleanup;\n\t}\n\text4_xattr_cache_insert(ext4_mb_cache, bh);\n\tentry = BFIRST(bh);\n\terror = ext4_xattr_find_entry(&entry, name_index, name, bh->b_size, 1);\n\tif (error == -EFSCORRUPTED)\n\t\tgoto bad_block;\n\tif (error)\n\t\tgoto cleanup;\n\tsize = le32_to_cpu(entry->e_value_size);\n\tif (buffer) {\n\t\terror = -ERANGE;\n\t\tif (size > buffer_size)\n\t\t\tgoto cleanup;\n\t\tmemcpy(buffer, bh->b_data + le16_to_cpu(entry->e_value_offs),\n\t\t       size);\n\t}\n\terror = size;\n\ncleanup:\n\tbrelse(bh);\n\treturn error;\n}\n", "target": 1, "idx": 183160}
{"func": "static int mptsas_process_scsi_io_request(MPTSASState *s,\n                                          MPIMsgSCSIIORequest *scsi_io,\n                                          hwaddr addr)\n{\n    MPTSASRequest *req;\n    MPIMsgSCSIIOReply reply;\n    SCSIDevice *sdev;\n    int status;\n\n    mptsas_fix_scsi_io_endianness(scsi_io);\n\n    trace_mptsas_process_scsi_io_request(s, scsi_io->Bus, scsi_io->TargetID,\n                                         scsi_io->LUN[1], scsi_io->DataLength);\n\n    status = mptsas_scsi_device_find(s, scsi_io->Bus, scsi_io->TargetID,\n                                     scsi_io->LUN, &sdev);\n    if (status) {\n         goto bad;\n     }\n \n    req = g_new(MPTSASRequest, 1);\n     QTAILQ_INSERT_TAIL(&s->pending, req, next);\n     req->scsi_io = *scsi_io;\n     req->dev = s;\n\n    status = mptsas_build_sgl(s, req, addr);\n    if (status) {\n        goto free_bad;\n    }\n\n    if (req->qsg.size < scsi_io->DataLength) {\n        trace_mptsas_sgl_overflow(s, scsi_io->MsgContext, scsi_io->DataLength,\n                                  req->qsg.size);\n        status = MPI_IOCSTATUS_INVALID_SGL;\n        goto free_bad;\n    }\n\n    req->sreq = scsi_req_new(sdev, scsi_io->MsgContext,\n                            scsi_io->LUN[1], scsi_io->CDB, req);\n\n    if (req->sreq->cmd.xfer > scsi_io->DataLength) {\n        goto overrun;\n    }\n    switch (scsi_io->Control & MPI_SCSIIO_CONTROL_DATADIRECTION_MASK) {\n    case MPI_SCSIIO_CONTROL_NODATATRANSFER:\n        if (req->sreq->cmd.mode != SCSI_XFER_NONE) {\n            goto overrun;\n        }\n        break;\n\n    case MPI_SCSIIO_CONTROL_WRITE:\n        if (req->sreq->cmd.mode != SCSI_XFER_TO_DEV) {\n            goto overrun;\n        }\n        break;\n\n    case MPI_SCSIIO_CONTROL_READ:\n        if (req->sreq->cmd.mode != SCSI_XFER_FROM_DEV) {\n            goto overrun;\n        }\n        break;\n    }\n\n    if (scsi_req_enqueue(req->sreq)) {\n        scsi_req_continue(req->sreq);\n    }\n    return 0;\n\noverrun:\n    trace_mptsas_scsi_overflow(s, scsi_io->MsgContext, req->sreq->cmd.xfer,\n                               scsi_io->DataLength);\n    status = MPI_IOCSTATUS_SCSI_DATA_OVERRUN;\nfree_bad:\n    mptsas_free_request(req);\nbad:\n    memset(&reply, 0, sizeof(reply));\n    reply.TargetID          = scsi_io->TargetID;\n    reply.Bus               = scsi_io->Bus;\n    reply.MsgLength         = sizeof(reply) / 4;\n    reply.Function          = scsi_io->Function;\n    reply.CDBLength         = scsi_io->CDBLength;\n    reply.SenseBufferLength = scsi_io->SenseBufferLength;\n    reply.MsgContext        = scsi_io->MsgContext;\n    reply.SCSIState         = MPI_SCSI_STATE_NO_SCSI_STATUS;\n    reply.IOCStatus         = status;\n\n    mptsas_fix_scsi_io_reply_endianness(&reply);\n    mptsas_reply(s, (MPIDefaultReply *)&reply);\n\n    return 0;\n}\n", "target": 1, "idx": 178100}
{"func": "void RenderFrameImpl::OnCopyToFindPboard() {\n  if (frame_->HasSelection()) {\n    if (!clipboard_host_) {\n      auto* platform = RenderThreadImpl::current_blink_platform_impl();\n      platform->GetConnector()->BindInterface(platform->GetBrowserServiceName(),\n                                              &clipboard_host_);\n    }\n    base::string16 selection = frame_->SelectionAsText().Utf16();\n    clipboard_host_->WriteStringToFindPboard(selection);\n  }\n}\n", "target": 0, "idx": 160650}
{"func": "PHP_FUNCTION(grapheme_strpos)\n{\n\tunsigned char *haystack, *needle;\n        int haystack_len, needle_len;\n        unsigned char *found;\n        long loffset = 0;\n       int32_t offset = 0;\n        int ret_pos;\n \n        if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ss|l\", (char **)&haystack, &haystack_len, (char **)&needle, &needle_len, &loffset) == FAILURE) {\n\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\t \"grapheme_strpos: unable to parse input param\", 0 TSRMLS_CC );\n\n\t\tRETURN_FALSE;\n\t}\n\n\tif ( OUTSIDE_STRING(loffset, haystack_len) ) {\n\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR, \"grapheme_strpos: Offset not contained in string\", 1 TSRMLS_CC );\n\n\t\tRETURN_FALSE;\n\t}\n \n        /* we checked that it will fit: */\n        offset = (int32_t) loffset;\n \n        /* the offset is 'grapheme count offset' so it still might be invalid - we'll check it later */\n \n\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR, \"grapheme_strpos: Empty delimiter\", 1 TSRMLS_CC );\n\n\t\tRETURN_FALSE;\n\t}\n", "target": 1, "idx": 178206}
{"func": "int kvm_arch_vcpu_init(struct kvm_vcpu *vcpu)\n{\n\tstruct page *page;\n\tstruct kvm *kvm;\n\tint r;\n\n\tBUG_ON(vcpu->kvm == NULL);\n\tkvm = vcpu->kvm;\n\n\tvcpu->arch.emulate_ctxt.ops = &emulate_ops;\n\tif (!irqchip_in_kernel(kvm) || kvm_vcpu_is_bsp(vcpu))\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\telse\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_UNINITIALIZED;\n\n\tpage = alloc_page(GFP_KERNEL | __GFP_ZERO);\n\tif (!page) {\n\t\tr = -ENOMEM;\n\t\tgoto fail;\n\t}\n\tvcpu->arch.pio_data = page_address(page);\n\n\tkvm_set_tsc_khz(vcpu, max_tsc_khz);\n\n\tr = kvm_mmu_create(vcpu);\n\tif (r < 0)\n\t\tgoto fail_free_pio_data;\n\n\tif (irqchip_in_kernel(kvm)) {\n\t\tr = kvm_create_lapic(vcpu);\n\t\tif (r < 0)\n\t\t\tgoto fail_mmu_destroy;\n\t} else\n\t\tstatic_key_slow_inc(&kvm_no_apic_vcpu);\n\n\tvcpu->arch.mce_banks = kzalloc(KVM_MAX_MCE_BANKS * sizeof(u64) * 4,\n\t\t\t\t       GFP_KERNEL);\n\tif (!vcpu->arch.mce_banks) {\n\t\tr = -ENOMEM;\n\t\tgoto fail_free_lapic;\n\t}\n\tvcpu->arch.mcg_cap = KVM_MAX_MCE_BANKS;\n\n\tif (!zalloc_cpumask_var(&vcpu->arch.wbinvd_dirty_mask, GFP_KERNEL))\n\t\tgoto fail_free_mce_banks;\n\n\tr = fx_init(vcpu);\n\tif (r)\n \t\tgoto fail_free_wbinvd_dirty_mask;\n \n \tvcpu->arch.ia32_tsc_adjust_msr = 0x0;\n \tkvm_async_pf_hash_reset(vcpu);\n \tkvm_pmu_init(vcpu);\n \n\treturn 0;\nfail_free_wbinvd_dirty_mask:\n\tfree_cpumask_var(vcpu->arch.wbinvd_dirty_mask);\nfail_free_mce_banks:\n\tkfree(vcpu->arch.mce_banks);\nfail_free_lapic:\n\tkvm_free_lapic(vcpu);\nfail_mmu_destroy:\n\tkvm_mmu_destroy(vcpu);\nfail_free_pio_data:\n\tfree_page((unsigned long)vcpu->arch.pio_data);\nfail:\n\treturn r;\n}\n", "target": 1, "idx": 179287}
{"func": " static void addDataToStreamTask(void* context)\n {\n     OwnPtr<BlobRegistryContext> blobRegistryContext = adoptPtr(static_cast<BlobRegistryContext*>(context));\n    blobRegistry().addDataToStream(blobRegistryContext->url, blobRegistryContext->streamData);\n }\n", "target": 1, "idx": 184255}
{"func": "v8::Handle<v8::Value> V8XMLHttpRequest::openCallback(const v8::Arguments& args)\n{\n    INC_STATS(\"DOM.XMLHttpRequest.open()\");\n \n     if (args.Length() < 2)\n        return V8Proxy::throwNotEnoughArgumentsError();\n \n     XMLHttpRequest* xmlHttpRequest = V8XMLHttpRequest::toNative(args.Holder());\n \n    String method = toWebCoreString(args[0]);\n    String urlstring = toWebCoreString(args[1]);\n    ScriptExecutionContext* context = getScriptExecutionContext();\n    if (!context)\n        return v8::Undefined();\n\n    KURL url = context->completeURL(urlstring);\n\n    ExceptionCode ec = 0;\n\n    if (args.Length() >= 3) {\n        bool async = args[2]->BooleanValue();\n\n        if (args.Length() >= 4 && !args[3]->IsUndefined()) {\n            String user = toWebCoreStringWithNullCheck(args[3]);\n            \n            if (args.Length() >= 5 && !args[4]->IsUndefined()) {\n                String passwd = toWebCoreStringWithNullCheck(args[4]);\n                xmlHttpRequest->open(method, url, async, user, passwd, ec);\n            } else\n                xmlHttpRequest->open(method, url, async, user, ec);\n        } else\n            xmlHttpRequest->open(method, url, async, ec);\n    } else\n        xmlHttpRequest->open(method, url, ec);\n\n    if (ec)\n        return throwError(ec, args.GetIsolate());\n\n    return v8::Undefined();\n}\n", "target": 1, "idx": 184827}
{"func": "int inode_init_always(struct super_block *sb, struct inode *inode)\n{\n\tstatic const struct inode_operations empty_iops;\n\tstatic const struct file_operations empty_fops;\n\tstruct address_space *const mapping = &inode->i_data;\n\n\tinode->i_sb = sb;\n\tinode->i_blkbits = sb->s_blocksize_bits;\n\tinode->i_flags = 0;\n\tatomic_set(&inode->i_count, 1);\n\tinode->i_op = &empty_iops;\n\tinode->i_fop = &empty_fops;\n\tinode->__i_nlink = 1;\n\tinode->i_opflags = 0;\n\ti_uid_write(inode, 0);\n\ti_gid_write(inode, 0);\n\tatomic_set(&inode->i_writecount, 0);\n\tinode->i_size = 0;\n\tinode->i_blocks = 0;\n\tinode->i_bytes = 0;\n\tinode->i_generation = 0;\n#ifdef CONFIG_QUOTA\n\tmemset(&inode->i_dquot, 0, sizeof(inode->i_dquot));\n#endif\n\tinode->i_pipe = NULL;\n\tinode->i_bdev = NULL;\n\tinode->i_cdev = NULL;\n\tinode->i_rdev = 0;\n\tinode->dirtied_when = 0;\n\n\tif (security_inode_alloc(inode))\n\t\tgoto out;\n\tspin_lock_init(&inode->i_lock);\n\tlockdep_set_class(&inode->i_lock, &sb->s_type->i_lock_key);\n\n\tmutex_init(&inode->i_mutex);\n\tlockdep_set_class(&inode->i_mutex, &sb->s_type->i_mutex_key);\n\n\tatomic_set(&inode->i_dio_count, 0);\n\n\tmapping->a_ops = &empty_aops;\n\tmapping->host = inode;\n\tmapping->flags = 0;\n\tmapping_set_gfp_mask(mapping, GFP_HIGHUSER_MOVABLE);\n\tmapping->private_data = NULL;\n\tmapping->backing_dev_info = &default_backing_dev_info;\n\tmapping->writeback_index = 0;\n\n\t/*\n\t * If the block_device provides a backing_dev_info for client\n\t * inodes then use that.  Otherwise the inode share the bdev's\n\t * backing_dev_info.\n\t */\n\tif (sb->s_bdev) {\n\t\tstruct backing_dev_info *bdi;\n\n\t\tbdi = sb->s_bdev->bd_inode->i_mapping->backing_dev_info;\n\t\tmapping->backing_dev_info = bdi;\n\t}\n\tinode->i_private = NULL;\n\tinode->i_mapping = mapping;\n\tINIT_HLIST_HEAD(&inode->i_dentry);\t/* buggered by rcu freeing */\n#ifdef CONFIG_FS_POSIX_ACL\n\tinode->i_acl = inode->i_default_acl = ACL_NOT_CACHED;\n#endif\n\n#ifdef CONFIG_FSNOTIFY\n\tinode->i_fsnotify_mask = 0;\n#endif\n\n\tthis_cpu_inc(nr_inodes);\n\n\treturn 0;\nout:\n\treturn -ENOMEM;\n}\n", "target": 0, "idx": 36867}
{"func": " static int fanout_add(struct sock *sk, u16 id, u16 type_flags)\n {\n \tstruct packet_sock *po = pkt_sk(sk);\n \tstruct packet_fanout *f, *match;\n \tu8 type = type_flags & 0xff;\n\tu8 flags = type_flags >> 8;\n\tint err;\n\n\tswitch (type) {\n\tcase PACKET_FANOUT_ROLLOVER:\n\t\tif (type_flags & PACKET_FANOUT_FLAG_ROLLOVER)\n\t\t\treturn -EINVAL;\n\tcase PACKET_FANOUT_HASH:\n\tcase PACKET_FANOUT_LB:\n\tcase PACKET_FANOUT_CPU:\n\tcase PACKET_FANOUT_RND:\n\tcase PACKET_FANOUT_QM:\n\tcase PACKET_FANOUT_CBPF:\n\tcase PACKET_FANOUT_EBPF:\n\t\tbreak;\n\tdefault:\n \t\treturn -EINVAL;\n \t}\n \n \tif (!po->running)\n\t\treturn -EINVAL;\n \n \tif (po->fanout)\n\t\treturn -EALREADY;\n \n \tif (type == PACKET_FANOUT_ROLLOVER ||\n \t    (type_flags & PACKET_FANOUT_FLAG_ROLLOVER)) {\n\t\tpo->rollover = kzalloc(sizeof(*po->rollover), GFP_KERNEL);\n\t\tif (!po->rollover)\n\t\t\treturn -ENOMEM;\n\t\tatomic_long_set(&po->rollover->num, 0);\n\t\tatomic_long_set(&po->rollover->num_huge, 0);\n\t\tatomic_long_set(&po->rollover->num_failed, 0);\n \t}\n \n\tmutex_lock(&fanout_mutex);\n \tmatch = NULL;\n \tlist_for_each_entry(f, &fanout_list, list) {\n \t\tif (f->id == id &&\n\t\t    read_pnet(&f->net) == sock_net(sk)) {\n\t\t\tmatch = f;\n\t\t\tbreak;\n\t\t}\n\t}\n\terr = -EINVAL;\n\tif (match && match->flags != flags)\n\t\tgoto out;\n\tif (!match) {\n\t\terr = -ENOMEM;\n\t\tmatch = kzalloc(sizeof(*match), GFP_KERNEL);\n\t\tif (!match)\n\t\t\tgoto out;\n\t\twrite_pnet(&match->net, sock_net(sk));\n\t\tmatch->id = id;\n\t\tmatch->type = type;\n\t\tmatch->flags = flags;\n\t\tINIT_LIST_HEAD(&match->list);\n\t\tspin_lock_init(&match->lock);\n\t\tatomic_set(&match->sk_ref, 0);\n\t\tfanout_init_data(match);\n\t\tmatch->prot_hook.type = po->prot_hook.type;\n\t\tmatch->prot_hook.dev = po->prot_hook.dev;\n\t\tmatch->prot_hook.func = packet_rcv_fanout;\n\t\tmatch->prot_hook.af_packet_priv = match;\n\t\tmatch->prot_hook.id_match = match_fanout_group;\n\t\tdev_add_pack(&match->prot_hook);\n\t\tlist_add(&match->list, &fanout_list);\n\t}\n\terr = -EINVAL;\n\tif (match->type == type &&\n\t    match->prot_hook.type == po->prot_hook.type &&\n\t    match->prot_hook.dev == po->prot_hook.dev) {\n\t\terr = -ENOSPC;\n\t\tif (atomic_read(&match->sk_ref) < PACKET_FANOUT_MAX) {\n\t\t\t__dev_remove_pack(&po->prot_hook);\n\t\t\tpo->fanout = match;\n\t\t\tatomic_inc(&match->sk_ref);\n\t\t\t__fanout_link(sk, po);\n\t\t\terr = 0;\n \t\t}\n \t}\n out:\n\tmutex_unlock(&fanout_mutex);\n\tif (err) {\n\t\tkfree(po->rollover);\n \t\tpo->rollover = NULL;\n \t}\n \treturn err;\n }\n", "target": 1, "idx": 181518}
{"func": "bool TopSitesImpl::IsKnownURL(const GURL& url) {\n  return loaded_ && cache_->IsKnownURL(url);\n}\n", "target": 0, "idx": 159886}
{"func": "wb_print(netdissect_options *ndo,\n         register const void *hdr, register u_int len)\n{\n\tregister const struct pkt_hdr *ph;\n\n\tph = (const struct pkt_hdr *)hdr;\n\tif (len < sizeof(*ph) || !ND_TTEST(*ph)) {\n\t\tND_PRINT((ndo, \"%s\", tstr));\n\t\treturn;\n\t}\n\tlen -= sizeof(*ph);\n\n\tif (ph->ph_flags)\n\t\tND_PRINT((ndo, \"*\"));\n\tswitch (ph->ph_type) {\n\n\tcase PT_KILL:\n\t\tND_PRINT((ndo, \" wb-kill\"));\n\t\treturn;\n\n \tcase PT_ID:\n \t\tif (wb_id(ndo, (const struct pkt_id *)(ph + 1), len) >= 0)\n \t\t\treturn;\n \t\tbreak;\n \n \tcase PT_RREQ:\n \t\tif (wb_rreq(ndo, (const struct pkt_rreq *)(ph + 1), len) >= 0)\n \t\t\treturn;\n \t\tbreak;\n \n \tcase PT_RREP:\n \t\tif (wb_rrep(ndo, (const struct pkt_rrep *)(ph + 1), len) >= 0)\n \t\t\treturn;\n \t\tbreak;\n \n \tcase PT_DRAWOP:\n \t\tif (wb_drawop(ndo, (const struct pkt_dop *)(ph + 1), len) >= 0)\n \t\t\treturn;\n \t\tbreak;\n \n \tcase PT_PREQ:\n \t\tif (wb_preq(ndo, (const struct pkt_preq *)(ph + 1), len) >= 0)\n \t\t\treturn;\n \t\tbreak;\n \n \tcase PT_PREP:\n \t\tif (wb_prep(ndo, (const struct pkt_prep *)(ph + 1), len) >= 0)\n \t\t\treturn;\n \t\tbreak;\n \n \tdefault:\n\t\tND_PRINT((ndo, \" wb-%d!\", ph->ph_type));\n\t\treturn;\n\t}\n}\n", "target": 1, "idx": 181051}
{"func": "\t\tvoid CWebServer::Cmd_GetAuth(WebEmSession & session, const request& req, Json::Value &root)\n\t\t{\n\t\t\troot[\"status\"] = \"OK\";\n\t\t\troot[\"title\"] = \"GetAuth\";\n\t\t\tif (session.rights != -1)\n\t\t\t{\n\t\t\t\troot[\"version\"] = szAppVersion;\n\t\t\t}\n\t\t\troot[\"user\"] = session.username;\n\t\t\troot[\"rights\"] = session.rights;\n\t\t}\n", "target": 0, "idx": 90988}
{"func": "static int srpt_ch_qp_rtr(struct srpt_rdma_ch *ch, struct ib_qp *qp)\n{\n\tstruct ib_qp_attr qp_attr;\n\tint attr_mask;\n\tint ret;\n\n\tqp_attr.qp_state = IB_QPS_RTR;\n\tret = ib_cm_init_qp_attr(ch->cm_id, &qp_attr, &attr_mask);\n\tif (ret)\n\t\tgoto out;\n\n\tqp_attr.max_dest_rd_atomic = 4;\n\n\tret = ib_modify_qp(qp, &qp_attr, attr_mask);\n\nout:\n\treturn ret;\n}\n", "target": 0, "idx": 50630}
{"func": "long Track::GetFirst(const BlockEntry*& pBlockEntry) const {\n const Cluster* pCluster = m_pSegment->GetFirst();\n\n for (int i = 0;;) {\n if (pCluster == NULL) {\n      pBlockEntry = GetEOS();\n return 1;\n }\n\n if (pCluster->EOS()) {\n if (m_pSegment->DoneParsing()) {\n        pBlockEntry = GetEOS();\n return 1;\n }\n\n      pBlockEntry = 0;\n return E_BUFFER_NOT_FULL;\n }\n\n long status = pCluster->GetFirst(pBlockEntry);\n\n if (status < 0) // error\n return status;\n\n if (pBlockEntry == 0) { // empty cluster\n      pCluster = m_pSegment->GetNext(pCluster);\n continue;\n }\n\n for (;;) {\n const Block* const pBlock = pBlockEntry->GetBlock();\n      assert(pBlock);\n\n const long long tn = pBlock->GetTrackNumber();\n\n if ((tn == m_info.number) && VetEntry(pBlockEntry))\n return 0;\n\n const BlockEntry* pNextEntry;\n\n      status = pCluster->GetNext(pBlockEntry, pNextEntry);\n\n if (status < 0) // error\n return status;\n\n if (pNextEntry == 0)\n break;\n\n      pBlockEntry = pNextEntry;\n }\n\n ++i;\n\n if (i >= 100)\n break;\n\n    pCluster = m_pSegment->GetNext(pCluster);\n }\n\n\n  pBlockEntry = GetEOS(); // so we can return a non-NULL value\n return 1;\n}\n", "target": 0, "idx": 177399}
{"func": "ConflictResolver::ProcessSimpleConflict(WriteTransaction* trans,\n                                        const Id& id,\n                                        const Cryptographer* cryptographer,\n                                        StatusController* status) {\n  MutableEntry entry(trans, syncable::GET_BY_ID, id);\n  CHECK(entry.good());\n\n  if (!entry.Get(syncable::IS_UNAPPLIED_UPDATE) ||\n      !entry.Get(syncable::IS_UNSYNCED)) {\n    return NO_SYNC_PROGRESS;\n  }\n\n  if (entry.Get(syncable::IS_DEL) && entry.Get(syncable::SERVER_IS_DEL)) {\n    entry.Put(syncable::IS_UNSYNCED, false);\n    entry.Put(syncable::IS_UNAPPLIED_UPDATE, false);\n    return NO_SYNC_PROGRESS;\n  }\n\n  if (!entry.Get(syncable::SERVER_IS_DEL)) {\n    bool name_matches = entry.Get(syncable::NON_UNIQUE_NAME) ==\n                        entry.Get(syncable::SERVER_NON_UNIQUE_NAME);\n    bool parent_matches = entry.Get(syncable::PARENT_ID) ==\n                          entry.Get(syncable::SERVER_PARENT_ID);\n    bool entry_deleted = entry.Get(syncable::IS_DEL);\n\n    syncable::Id server_prev_id = entry.ComputePrevIdFromServerPosition(\n        entry.Get(syncable::SERVER_PARENT_ID));\n    bool needs_reinsertion = !parent_matches ||\n         server_prev_id != entry.Get(syncable::PREV_ID);\n    DVLOG_IF(1, needs_reinsertion) << \"Insertion needed, server prev id \"\n        << \" is \" << server_prev_id << \", local prev id is \"\n        << entry.Get(syncable::PREV_ID);\n    const sync_pb::EntitySpecifics& specifics =\n        entry.Get(syncable::SPECIFICS);\n    const sync_pb::EntitySpecifics& server_specifics =\n        entry.Get(syncable::SERVER_SPECIFICS);\n    const sync_pb::EntitySpecifics& base_server_specifics =\n        entry.Get(syncable::BASE_SERVER_SPECIFICS);\n    std::string decrypted_specifics, decrypted_server_specifics;\n    bool specifics_match = false;\n    bool server_encrypted_with_default_key = false;\n    if (specifics.has_encrypted()) {\n      DCHECK(cryptographer->CanDecryptUsingDefaultKey(specifics.encrypted()));\n      decrypted_specifics = cryptographer->DecryptToString(\n          specifics.encrypted());\n    } else {\n      decrypted_specifics = specifics.SerializeAsString();\n    }\n    if (server_specifics.has_encrypted()) {\n      server_encrypted_with_default_key =\n          cryptographer->CanDecryptUsingDefaultKey(\n              server_specifics.encrypted());\n      decrypted_server_specifics = cryptographer->DecryptToString(\n          server_specifics.encrypted());\n    } else {\n      decrypted_server_specifics = server_specifics.SerializeAsString();\n    }\n    if (decrypted_server_specifics == decrypted_specifics &&\n        server_encrypted_with_default_key == specifics.has_encrypted()) {\n      specifics_match = true;\n    }\n    bool base_server_specifics_match = false;\n    if (server_specifics.has_encrypted() &&\n        IsRealDataType(GetModelTypeFromSpecifics(base_server_specifics))) {\n      std::string decrypted_base_server_specifics;\n      if (!base_server_specifics.has_encrypted()) {\n        decrypted_base_server_specifics =\n            base_server_specifics.SerializeAsString();\n      } else {\n        decrypted_base_server_specifics = cryptographer->DecryptToString(\n            base_server_specifics.encrypted());\n      }\n      if (decrypted_server_specifics == decrypted_base_server_specifics)\n          base_server_specifics_match = true;\n    }\n\n    if (entry.GetModelType() == syncable::NIGORI) {\n      sync_pb::EntitySpecifics specifics =\n          entry.Get(syncable::SERVER_SPECIFICS);\n      sync_pb::NigoriSpecifics* server_nigori = specifics.mutable_nigori();\n      cryptographer->UpdateNigoriFromEncryptedTypes(server_nigori);\n      if (cryptographer->is_ready()) {\n        cryptographer->GetKeys(server_nigori->mutable_encrypted());\n        server_nigori->set_using_explicit_passphrase(\n             entry.Get(syncable::SPECIFICS).nigori().\n                 using_explicit_passphrase());\n       }\n      if (entry.Get(syncable::SPECIFICS).nigori().sync_tabs()) {\n        server_nigori->set_sync_tabs(true);\n      }\n       entry.Put(syncable::SPECIFICS, specifics);\n      DVLOG(1) << \"Resolving simple conflict, merging nigori nodes: \" << entry;\n      status->increment_num_server_overwrites();\n      OverwriteServerChanges(trans, &entry);\n      UMA_HISTOGRAM_ENUMERATION(\"Sync.ResolveSimpleConflict\",\n                                NIGORI_MERGE,\n                                CONFLICT_RESOLUTION_SIZE);\n    } else if (!entry_deleted && name_matches && parent_matches &&\n               specifics_match && !needs_reinsertion) {\n      DVLOG(1) << \"Resolving simple conflict, everything matches, ignoring \"\n               << \"changes for: \" << entry;\n      OverwriteServerChanges(trans, &entry);\n      IgnoreLocalChanges(&entry);\n      UMA_HISTOGRAM_ENUMERATION(\"Sync.ResolveSimpleConflict\",\n                                CHANGES_MATCH,\n                                CONFLICT_RESOLUTION_SIZE);\n    } else if (base_server_specifics_match) {\n      DVLOG(1) << \"Resolving simple conflict, ignoring server encryption \"\n               << \" changes for: \" << entry;\n      status->increment_num_server_overwrites();\n      OverwriteServerChanges(trans, &entry);\n      UMA_HISTOGRAM_ENUMERATION(\"Sync.ResolveSimpleConflict\",\n                                IGNORE_ENCRYPTION,\n                                CONFLICT_RESOLUTION_SIZE);\n    } else if (entry_deleted || !name_matches || !parent_matches) {\n      OverwriteServerChanges(trans, &entry);\n      status->increment_num_server_overwrites();\n      DVLOG(1) << \"Resolving simple conflict, overwriting server changes \"\n               << \"for: \" << entry;\n      UMA_HISTOGRAM_ENUMERATION(\"Sync.ResolveSimpleConflict\",\n                                OVERWRITE_SERVER,\n                                CONFLICT_RESOLUTION_SIZE);\n    } else {\n      DVLOG(1) << \"Resolving simple conflict, ignoring local changes for: \"\n               << entry;\n      IgnoreLocalChanges(&entry);\n      status->increment_num_local_overwrites();\n      UMA_HISTOGRAM_ENUMERATION(\"Sync.ResolveSimpleConflict\",\n                                OVERWRITE_LOCAL,\n                                CONFLICT_RESOLUTION_SIZE);\n    }\n    entry.Put(syncable::BASE_SERVER_SPECIFICS, sync_pb::EntitySpecifics());\n    return SYNC_PROGRESS;\n  } else {  // SERVER_IS_DEL is true\n    if (entry.Get(syncable::IS_DIR)) {\n      Directory::ChildHandles children;\n      trans->directory()->GetChildHandlesById(trans,\n                                              entry.Get(syncable::ID),\n                                              &children);\n      if (0 != children.size()) {\n        DVLOG(1) << \"Entry is a server deleted directory with local contents, \"\n                 << \"should be a hierarchy conflict. (race condition).\";\n        return NO_SYNC_PROGRESS;\n      }\n    }\n\n    if (!entry.Get(syncable::UNIQUE_CLIENT_TAG).empty()) {\n      DCHECK_EQ(entry.Get(syncable::SERVER_VERSION), 0) << \"For the server to \"\n          \"know to re-create, client-tagged items should revert to version 0 \"\n          \"when server-deleted.\";\n      OverwriteServerChanges(trans, &entry);\n      status->increment_num_server_overwrites();\n      DVLOG(1) << \"Resolving simple conflict, undeleting server entry: \"\n               << entry;\n      UMA_HISTOGRAM_ENUMERATION(\"Sync.ResolveSimpleConflict\",\n                                OVERWRITE_SERVER,\n                                CONFLICT_RESOLUTION_SIZE);\n      entry.Put(syncable::SERVER_VERSION, 0);\n      entry.Put(syncable::BASE_VERSION, 0);\n    } else {\n      SyncerUtil::SplitServerInformationIntoNewEntry(trans, &entry);\n\n      MutableEntry server_update(trans, syncable::GET_BY_ID, id);\n      CHECK(server_update.good());\n      CHECK(server_update.Get(syncable::META_HANDLE) !=\n            entry.Get(syncable::META_HANDLE))\n          << server_update << entry;\n      UMA_HISTOGRAM_ENUMERATION(\"Sync.ResolveSimpleConflict\",\n                                UNDELETE,\n                                CONFLICT_RESOLUTION_SIZE);\n    }\n    return SYNC_PROGRESS;\n  }\n}\n", "target": 1, "idx": 184365}
{"func": "static long futex_wait_restart(struct restart_block *restart)\n{\n\tu32 __user *uaddr = restart->futex.uaddr;\n\tktime_t t, *tp = NULL;\n\n\tif (restart->futex.flags & FLAGS_HAS_TIMEOUT) {\n\t\tt.tv64 = restart->futex.time;\n\t\ttp = &t;\n\t}\n\trestart->fn = do_no_restart_syscall;\n\n\treturn (long)futex_wait(uaddr, restart->futex.flags,\n\t\t\t\trestart->futex.val, tp, restart->futex.bitset);\n}\n", "target": 0, "idx": 38210}
{"func": "status_t MediaPlayer::setDataSource(\n const sp<IMediaHTTPService> &httpService,\n const char *url, const KeyedVector<String8, String8> *headers)\n{\n\n     ALOGV(\"setDataSource(%s)\", url);\n     status_t err = BAD_VALUE;\n     if (url != NULL) {\n        const sp<IMediaPlayerService>& service(getMediaPlayerService());\n         if (service != 0) {\n             sp<IMediaPlayer> player(service->create(this, mAudioSessionId));\n             if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||\n (NO_ERROR != player->setDataSource(httpService, url, headers))) {\n                player.clear();\n }\n            err = attachNewPlayer(player);\n }\n }\n return err;\n}\n", "target": 1, "idx": 187559}
{"func": " void ExtensionViewGuest::DidNavigateMainFrame(\n     const content::LoadCommittedDetails& details,\n     const content::FrameNavigateParams& params) {\n  if (attached() && (params.url.GetOrigin() != url_.GetOrigin())) {\n     bad_message::ReceivedBadMessage(web_contents()->GetRenderProcessHost(),\n                                     bad_message::EVG_BAD_ORIGIN);\n   }\n}\n", "target": 1, "idx": 186251}
{"func": "static ssize_t show_ibdev(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tstruct ib_ucm_device *ucm_dev;\n\n\tucm_dev = container_of(dev, struct ib_ucm_device, dev);\n\treturn sprintf(buf, \"%s\\n\", ucm_dev->ib_dev->name);\n}\n", "target": 0, "idx": 52820}
{"func": "bool SocketStream::is_secure() const {\n  return url_.SchemeIs(\"wss\");\n }\n", "target": 0, "idx": 120972}
{"func": "void MockWebRTCPeerConnectionHandler::setRemoteDescription(const WebRTCVoidRequest& request, const WebRTCSessionDescriptionDescriptor& remoteDescription)\n{\n    if (!remoteDescription.isNull() && remoteDescription.type() == \"answer\") {\n        m_remoteDescription = remoteDescription;\n        postTask(new RTCVoidRequestTask(this, request, true));\n     } else\n        postTask(new RTCVoidRequestTask(this, request, false));\n}\n", "target": 1, "idx": 183820}
{"func": "void setSerifFontFamilyWrapper(WebSettings* settings,\n                               const string16& font,\n                               UScriptCode script) {\n  settings->setSerifFontFamily(font, script);\n}\n", "target": 0, "idx": 124416}
{"func": " void GpuVideoDecodeAccelerator::OnDecode(\n    base::SharedMemoryHandle handle, int32 id, int32 size) {\n   DCHECK(video_decode_accelerator_.get());\n   video_decode_accelerator_->Decode(media::BitstreamBuffer(id, handle, size));\n }\n", "target": 1, "idx": 185105}
{"func": "xmlXPathParseNameComplex(xmlXPathParserContextPtr ctxt, int qualified) {\n    xmlChar buf[XML_MAX_NAMELEN + 5];\n    int len = 0, l;\n    int c;\n\n    /*\n     * Handler for more complex cases\n     */\n    c = CUR_CHAR(l);\n    if ((c == ' ') || (c == '>') || (c == '/') || /* accelerators */\n        (c == '[') || (c == ']') || (c == '@') || /* accelerators */\n        (c == '*') || /* accelerators */\n\t(!IS_LETTER(c) && (c != '_') &&\n         ((qualified) && (c != ':')))) {\n\treturn(NULL);\n    }\n\n    while ((c != ' ') && (c != '>') && (c != '/') && /* test bigname.xml */\n\t   ((IS_LETTER(c)) || (IS_DIGIT(c)) ||\n            (c == '.') || (c == '-') ||\n\t    (c == '_') || ((qualified) && (c == ':')) ||\n\t    (IS_COMBINING(c)) ||\n\t    (IS_EXTENDER(c)))) {\n\tCOPY_BUF(l,buf,len,c);\n\tNEXTL(l);\n\tc = CUR_CHAR(l);\n\tif (len >= XML_MAX_NAMELEN) {\n\t    /*\n\t     * Okay someone managed to make a huge name, so he's ready to pay\n\t     * for the processing speed.\n\t     */\n\t    xmlChar *buffer;\n\t    int max = len * 2;\n\n\t    buffer = (xmlChar *) xmlMallocAtomic(max * sizeof(xmlChar));\n\t    if (buffer == NULL) {\n\t\tXP_ERRORNULL(XPATH_MEMORY_ERROR);\n\t    }\n\t    memcpy(buffer, buf, len);\n\t    while ((IS_LETTER(c)) || (IS_DIGIT(c)) || /* test bigname.xml */\n\t\t   (c == '.') || (c == '-') ||\n\t\t   (c == '_') || ((qualified) && (c == ':')) ||\n\t\t   (IS_COMBINING(c)) ||\n\t\t   (IS_EXTENDER(c))) {\n\t\tif (len + 10 > max) {\n\t\t    max *= 2;\n\t\t    buffer = (xmlChar *) xmlRealloc(buffer,\n\t\t\t                            max * sizeof(xmlChar));\n\t\t    if (buffer == NULL) {\n\t\t\tXP_ERRORNULL(XPATH_MEMORY_ERROR);\n\t\t    }\n\t\t}\n\t\tCOPY_BUF(l,buffer,len,c);\n\t\tNEXTL(l);\n\t\tc = CUR_CHAR(l);\n\t    }\n\t    buffer[len] = 0;\n\t    return(buffer);\n\t}\n    }\n    if (len == 0)\n\treturn(NULL);\n    return(xmlStrndup(buf, len));\n}\n", "target": 0, "idx": 97761}
{"func": "bool Vp9Parser::ParseSuperframe() {\n  const uint8_t* stream = stream_;\n  off_t bytes_left = bytes_left_;\n  DCHECK(frames_.empty());\n  stream_ = nullptr;\n  bytes_left_ = 0;\n  if (bytes_left < 1)\n    return false;\n  uint8_t marker = *(stream + bytes_left - 1);\n  if ((marker & 0xe0) != 0xc0) {\n    frames_.push_back(FrameInfo(stream, bytes_left));\n    return true;\n  }\n  DVLOG(1) << \"Parsing a superframe\";\n  size_t num_frames = (marker & 0x7) + 1;\n  size_t mag = ((marker >> 3) & 0x3) + 1;\n  off_t index_size = 2 + mag * num_frames;\n \n  if (bytes_left < index_size)\n     return false;\n \n  const uint8_t* index_ptr = stream + bytes_left - index_size;\n  if (marker != *index_ptr)\n    return false;\n  ++index_ptr;\n  bytes_left -= index_size;\n  for (size_t i = 0; i < num_frames; ++i) {\n    uint32_t size = 0;\n    for (size_t j = 0; j < mag; ++j) {\n      size |= *index_ptr << (j * 8);\n      ++index_ptr;\n    }\n    if (base::checked_cast<off_t>(size) > bytes_left) {\n      DVLOG(1) << \"Not enough data in the buffer for frame \" << i;\n      return false;\n    }\n    frames_.push_back(FrameInfo(stream, size));\n    stream += size;\n    bytes_left -= size;\n    DVLOG(1) << \"Frame \" << i << \", size: \" << size;\n  }\n \n   return true;\n }\n", "target": 1, "idx": 183533}
{"func": "static void nfs4_open_confirm_release(void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\tstruct nfs4_state *state = NULL;\n\n\t/* If this request hasn't been cancelled, do nothing */\n\tif (data->cancelled == 0)\n\t\tgoto out_free;\n\t/* In case of error, no cleanup! */\n\tif (!data->rpc_done)\n \t\tgoto out_free;\n \tstate = nfs4_opendata_to_nfs4_state(data);\n \tif (!IS_ERR(state))\n\t\tnfs4_close_state(&data->path, state, data->o_arg.open_flags);\n out_free:\n \tnfs4_opendata_put(data);\n }\n", "target": 1, "idx": 178866}
{"func": "mrb_vm_exec(mrb_state *mrb, struct RProc *proc, mrb_code *pc)\n{\n  /* mrb_assert(mrb_proc_cfunc_p(proc)) */\n  mrb_irep *irep = proc->body.irep;\n  mrb_value *pool = irep->pool;\n  mrb_sym *syms = irep->syms;\n  mrb_code i;\n  int ai = mrb_gc_arena_save(mrb);\n  struct mrb_jmpbuf *prev_jmp = mrb->jmp;\n  struct mrb_jmpbuf c_jmp;\n\n#ifdef DIRECT_THREADED\n  static void *optable[] = {\n    &&L_OP_NOP, &&L_OP_MOVE,\n    &&L_OP_LOADL, &&L_OP_LOADI, &&L_OP_LOADSYM, &&L_OP_LOADNIL,\n    &&L_OP_LOADSELF, &&L_OP_LOADT, &&L_OP_LOADF,\n    &&L_OP_GETGLOBAL, &&L_OP_SETGLOBAL, &&L_OP_GETSPECIAL, &&L_OP_SETSPECIAL,\n    &&L_OP_GETIV, &&L_OP_SETIV, &&L_OP_GETCV, &&L_OP_SETCV,\n    &&L_OP_GETCONST, &&L_OP_SETCONST, &&L_OP_GETMCNST, &&L_OP_SETMCNST,\n    &&L_OP_GETUPVAR, &&L_OP_SETUPVAR,\n    &&L_OP_JMP, &&L_OP_JMPIF, &&L_OP_JMPNOT,\n    &&L_OP_ONERR, &&L_OP_RESCUE, &&L_OP_POPERR, &&L_OP_RAISE, &&L_OP_EPUSH, &&L_OP_EPOP,\n    &&L_OP_SEND, &&L_OP_SENDB, &&L_OP_FSEND,\n    &&L_OP_CALL, &&L_OP_SUPER, &&L_OP_ARGARY, &&L_OP_ENTER,\n    &&L_OP_KARG, &&L_OP_KDICT, &&L_OP_RETURN, &&L_OP_TAILCALL, &&L_OP_BLKPUSH,\n    &&L_OP_ADD, &&L_OP_ADDI, &&L_OP_SUB, &&L_OP_SUBI, &&L_OP_MUL, &&L_OP_DIV,\n    &&L_OP_EQ, &&L_OP_LT, &&L_OP_LE, &&L_OP_GT, &&L_OP_GE,\n    &&L_OP_ARRAY, &&L_OP_ARYCAT, &&L_OP_ARYPUSH, &&L_OP_AREF, &&L_OP_ASET, &&L_OP_APOST,\n    &&L_OP_STRING, &&L_OP_STRCAT, &&L_OP_HASH,\n    &&L_OP_LAMBDA, &&L_OP_RANGE, &&L_OP_OCLASS,\n    &&L_OP_CLASS, &&L_OP_MODULE, &&L_OP_EXEC,\n    &&L_OP_METHOD, &&L_OP_SCLASS, &&L_OP_TCLASS,\n    &&L_OP_DEBUG, &&L_OP_STOP, &&L_OP_ERR,\n  };\n#endif\n\n  mrb_bool exc_catched = FALSE;\nRETRY_TRY_BLOCK:\n\n  MRB_TRY(&c_jmp) {\n\n  if (exc_catched) {\n    exc_catched = FALSE;\n    if (mrb->exc && mrb->exc->tt == MRB_TT_BREAK)\n      goto L_BREAK;\n    goto L_RAISE;\n  }\n  mrb->jmp = &c_jmp;\n  mrb->c->ci->proc = proc;\n  mrb->c->ci->nregs = irep->nregs;\n\n#define regs (mrb->c->stack)\n  INIT_DISPATCH {\n    CASE(OP_NOP) {\n      /* do nothing */\n      NEXT;\n    }\n\n    CASE(OP_MOVE) {\n      /* A B    R(A) := R(B) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      regs[a] = regs[b];\n      NEXT;\n    }\n\n    CASE(OP_LOADL) {\n      /* A Bx   R(A) := Pool(Bx) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n#ifdef MRB_WORD_BOXING\n      mrb_value val = pool[bx];\n#ifndef MRB_WITHOUT_FLOAT\n      if (mrb_float_p(val)) {\n        val = mrb_float_value(mrb, mrb_float(val));\n      }\n#endif\n      regs[a] = val;\n#else\n      regs[a] = pool[bx];\n#endif\n      NEXT;\n    }\n\n    CASE(OP_LOADI) {\n      /* A sBx  R(A) := sBx */\n      int a = GETARG_A(i);\n      mrb_int bx = GETARG_sBx(i);\n      SET_INT_VALUE(regs[a], bx);\n      NEXT;\n    }\n\n    CASE(OP_LOADSYM) {\n      /* A Bx   R(A) := Syms(Bx) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      SET_SYM_VALUE(regs[a], syms[bx]);\n      NEXT;\n    }\n\n    CASE(OP_LOADSELF) {\n      /* A      R(A) := self */\n      int a = GETARG_A(i);\n      regs[a] = regs[0];\n      NEXT;\n    }\n\n    CASE(OP_LOADT) {\n      /* A      R(A) := true */\n      int a = GETARG_A(i);\n      SET_TRUE_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_LOADF) {\n      /* A      R(A) := false */\n      int a = GETARG_A(i);\n      SET_FALSE_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETGLOBAL) {\n      /* A Bx   R(A) := getglobal(Syms(Bx)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_value val = mrb_gv_get(mrb, syms[bx]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETGLOBAL) {\n      /* A Bx   setglobal(Syms(Bx), R(A)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_gv_set(mrb, syms[bx], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETSPECIAL) {\n      /* A Bx   R(A) := Special[Bx] */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_value val = mrb_vm_special_get(mrb, bx);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETSPECIAL) {\n      /* A Bx   Special[Bx] := R(A) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_vm_special_set(mrb, bx, regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETIV) {\n      /* A Bx   R(A) := ivget(Bx) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_value val = mrb_vm_iv_get(mrb, syms[bx]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETIV) {\n      /* A Bx   ivset(Syms(Bx),R(A)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_vm_iv_set(mrb, syms[bx], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETCV) {\n      /* A Bx   R(A) := cvget(Syms(Bx)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_value val;\n      ERR_PC_SET(mrb, pc);\n      val = mrb_vm_cv_get(mrb, syms[bx]);\n      ERR_PC_CLR(mrb);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETCV) {\n      /* A Bx   cvset(Syms(Bx),R(A)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_vm_cv_set(mrb, syms[bx], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETCONST) {\n      /* A Bx    R(A) := constget(Syms(Bx)) */\n      mrb_value val;\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_sym sym = syms[bx];\n\n      ERR_PC_SET(mrb, pc);\n      val = mrb_vm_const_get(mrb, sym);\n      ERR_PC_CLR(mrb);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETCONST) {\n      /* A Bx   constset(Syms(Bx),R(A)) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_vm_const_set(mrb, syms[bx], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETMCNST) {\n      /* A Bx   R(A) := R(A)::Syms(Bx) */\n      mrb_value val;\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n\n      ERR_PC_SET(mrb, pc);\n      val = mrb_const_get(mrb, regs[a], syms[bx]);\n      ERR_PC_CLR(mrb);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETMCNST) {\n      /* A Bx    R(A+1)::Syms(Bx) := R(A) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_const_set(mrb, regs[a+1], syms[bx], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETUPVAR) {\n      /* A B C  R(A) := uvget(B,C) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n       mrb_value *regs_a = regs + a;\n       struct REnv *e = uvenv(mrb, c);\n \n      if (!e) {\n        *regs_a = mrb_nil_value();\n       }\n       else {\n        *regs_a = e->stack[b];\n       }\n       NEXT;\n     }\n\n    CASE(OP_SETUPVAR) {\n      /* A B C  uvset(B,C,R(A)) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n\n      struct REnv *e = uvenv(mrb, c);\n\n      if (e) {\n        mrb_value *regs_a = regs + a;\n\n        if (b < MRB_ENV_STACK_LEN(e)) {\n          e->stack[b] = *regs_a;\n          mrb_write_barrier(mrb, (struct RBasic*)e);\n        }\n      }\n      NEXT;\n    }\n\n    CASE(OP_JMP) {\n      /* sBx    pc+=sBx */\n      int sbx = GETARG_sBx(i);\n      pc += sbx;\n      JUMP;\n    }\n\n    CASE(OP_JMPIF) {\n      /* A sBx  if R(A) pc+=sBx */\n      int a = GETARG_A(i);\n      int sbx = GETARG_sBx(i);\n      if (mrb_test(regs[a])) {\n        pc += sbx;\n        JUMP;\n      }\n      NEXT;\n    }\n\n    CASE(OP_JMPNOT) {\n      /* A sBx  if !R(A) pc+=sBx */\n      int a = GETARG_A(i);\n      int sbx = GETARG_sBx(i);\n      if (!mrb_test(regs[a])) {\n        pc += sbx;\n        JUMP;\n      }\n      NEXT;\n    }\n\n    CASE(OP_ONERR) {\n      /* sBx    pc+=sBx on exception */\n      int sbx = GETARG_sBx(i);\n      if (mrb->c->rsize <= mrb->c->ci->ridx) {\n        if (mrb->c->rsize == 0) mrb->c->rsize = RESCUE_STACK_INIT_SIZE;\n        else mrb->c->rsize *= 2;\n        mrb->c->rescue = (mrb_code **)mrb_realloc(mrb, mrb->c->rescue, sizeof(mrb_code*) * mrb->c->rsize);\n      }\n      mrb->c->rescue[mrb->c->ci->ridx++] = pc + sbx;\n      NEXT;\n    }\n\n    CASE(OP_RESCUE) {\n      /* A B    R(A) := exc; clear(exc); R(B) := matched (bool) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n      mrb_value exc;\n\n      if (c == 0) {\n        exc = mrb_obj_value(mrb->exc);\n        mrb->exc = 0;\n      }\n      else {           /* continued; exc taken from R(A) */\n        exc = regs[a];\n      }\n      if (b != 0) {\n        mrb_value e = regs[b];\n        struct RClass *ec;\n\n        switch (mrb_type(e)) {\n        case MRB_TT_CLASS:\n        case MRB_TT_MODULE:\n          break;\n        default:\n          {\n            mrb_value exc;\n\n            exc = mrb_exc_new_str_lit(mrb, E_TYPE_ERROR,\n                  \"class or module required for rescue clause\");\n            mrb_exc_set(mrb, exc);\n            goto L_RAISE;\n          }\n        }\n        ec = mrb_class_ptr(e);\n        regs[b] = mrb_bool_value(mrb_obj_is_kind_of(mrb, exc, ec));\n      }\n      if (a != 0 && c == 0) {\n        regs[a] = exc;\n      }\n      NEXT;\n    }\n\n    CASE(OP_POPERR) {\n      /* A      A.times{rescue_pop()} */\n      int a = GETARG_A(i);\n\n      mrb->c->ci->ridx -= a;\n      NEXT;\n    }\n\n    CASE(OP_RAISE) {\n      /* A      raise(R(A)) */\n      int a = GETARG_A(i);\n\n      mrb_exc_set(mrb, regs[a]);\n      goto L_RAISE;\n    }\n\n    CASE(OP_EPUSH) {\n      /* Bx     ensure_push(SEQ[Bx]) */\n      int bx = GETARG_Bx(i);\n      struct RProc *p;\n\n      p = mrb_closure_new(mrb, irep->reps[bx]);\n      /* push ensure_stack */\n      if (mrb->c->esize <= mrb->c->eidx+1) {\n        if (mrb->c->esize == 0) mrb->c->esize = ENSURE_STACK_INIT_SIZE;\n        else mrb->c->esize *= 2;\n        mrb->c->ensure = (struct RProc **)mrb_realloc(mrb, mrb->c->ensure, sizeof(struct RProc*) * mrb->c->esize);\n      }\n      mrb->c->ensure[mrb->c->eidx++] = p;\n      mrb->c->ensure[mrb->c->eidx] = NULL;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_EPOP) {\n      /* A      A.times{ensure_pop().call} */\n      int a = GETARG_A(i);\n      mrb_callinfo *ci = mrb->c->ci;\n      int n, epos = ci->epos;\n      mrb_value self = regs[0];\n      struct RClass *target_class = ci->target_class;\n\n      if (mrb->c->eidx <= epos) {\n        NEXT;\n      }\n\n      if (a > mrb->c->eidx - epos)\n        a = mrb->c->eidx - epos;\n      pc = pc + 1;\n      for (n=0; n<a; n++) {\n        proc = mrb->c->ensure[epos+n];\n        mrb->c->ensure[epos+n] = NULL;\n        if (proc == NULL) continue;\n        irep = proc->body.irep;\n        ci = cipush(mrb);\n        ci->mid = ci[-1].mid;\n        ci->argc = 0;\n        ci->proc = proc;\n        ci->stackent = mrb->c->stack;\n        ci->nregs = irep->nregs;\n        ci->target_class = target_class;\n        ci->pc = pc;\n        ci->acc = ci[-1].nregs;\n        mrb->c->stack += ci->acc;\n        stack_extend(mrb, ci->nregs);\n        regs[0] = self;\n        pc = irep->iseq;\n      }\n      pool = irep->pool;\n      syms = irep->syms;\n      mrb->c->eidx = epos;\n      JUMP;\n    }\n\n    CASE(OP_LOADNIL) {\n      /* A     R(A) := nil */\n      int a = GETARG_A(i);\n\n      SET_NIL_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_SENDB) {\n      /* A B C  R(A) := call(R(A),Syms(B),R(A+1),...,R(A+C),&R(A+C+1))*/\n      /* fall through */\n    };\n\n  L_SEND:\n    CASE(OP_SEND) {\n      /* A B C  R(A) := call(R(A),Syms(B),R(A+1),...,R(A+C)) */\n      int a = GETARG_A(i);\n      int n = GETARG_C(i);\n      int argc = (n == CALL_MAXARGS) ? -1 : n;\n      int bidx = (argc < 0) ? a+2 : a+n+1;\n      mrb_method_t m;\n      struct RClass *c;\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_value recv, blk;\n      mrb_sym mid = syms[GETARG_B(i)];\n\n      mrb_assert(bidx < ci->nregs);\n\n      recv = regs[a];\n      if (GET_OPCODE(i) != OP_SENDB) {\n        SET_NIL_VALUE(regs[bidx]);\n        blk = regs[bidx];\n      }\n      else {\n        blk = regs[bidx];\n        if (!mrb_nil_p(blk) && mrb_type(blk) != MRB_TT_PROC) {\n          blk = mrb_convert_type(mrb, blk, MRB_TT_PROC, \"Proc\", \"to_proc\");\n          /* The stack might have been reallocated during mrb_convert_type(),\n             see #3622 */\n          regs[bidx] = blk;\n        }\n      }\n      c = mrb_class(mrb, recv);\n      m = mrb_method_search_vm(mrb, &c, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        mrb_sym missing = mrb_intern_lit(mrb, \"method_missing\");\n        m = mrb_method_search_vm(mrb, &c, missing);\n        if (MRB_METHOD_UNDEF_P(m) || (missing == mrb->c->ci->mid && mrb_obj_eq(mrb, regs[0], recv))) {\n          mrb_value args = (argc < 0) ? regs[a+1] : mrb_ary_new_from_values(mrb, n, regs+a+1);\n          ERR_PC_SET(mrb, pc);\n          mrb_method_missing(mrb, mid, recv, args);\n        }\n        if (argc >= 0) {\n          if (a+2 >= irep->nregs) {\n            stack_extend(mrb, a+3);\n          }\n          regs[a+1] = mrb_ary_new_from_values(mrb, n, regs+a+1);\n          regs[a+2] = blk;\n          argc = -1;\n        }\n        mrb_ary_unshift(mrb, regs[a+1], mrb_symbol_value(mid));\n        mid = missing;\n      }\n\n      /* push callinfo */\n      ci = cipush(mrb);\n      ci->mid = mid;\n      ci->stackent = mrb->c->stack;\n      ci->target_class = c;\n      ci->argc = argc;\n\n      ci->pc = pc + 1;\n      ci->acc = a;\n\n      /* prepare stack */\n      mrb->c->stack += a;\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        ci->nregs = (argc < 0) ? 3 : n+2;\n        if (MRB_METHOD_PROC_P(m)) {\n          struct RProc *p = MRB_METHOD_PROC(m);\n\n          ci->proc = p;\n          recv = p->body.func(mrb, recv);\n        }\n        else {\n          recv = MRB_METHOD_FUNC(m)(mrb, recv);\n        }\n        mrb_gc_arena_restore(mrb, ai);\n        mrb_gc_arena_shrink(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        ci = mrb->c->ci;\n        if (GET_OPCODE(i) == OP_SENDB) {\n          if (mrb_type(blk) == MRB_TT_PROC) {\n            struct RProc *p = mrb_proc_ptr(blk);\n            if (p && !MRB_PROC_STRICT_P(p) && MRB_PROC_ENV(p) == ci[-1].env) {\n              p->flags |= MRB_PROC_ORPHAN;\n            }\n          }\n        }\n        if (!ci->target_class) { /* return from context modifying method (resume/yield) */\n          if (ci->acc == CI_ACC_RESUMED) {\n            mrb->jmp = prev_jmp;\n            return recv;\n          }\n          else {\n            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n            proc = ci[-1].proc;\n            irep = proc->body.irep;\n            pool = irep->pool;\n            syms = irep->syms;\n          }\n        }\n        mrb->c->stack[0] = recv;\n        /* pop stackpos */\n        mrb->c->stack = ci->stackent;\n        pc = ci->pc;\n        cipop(mrb);\n        JUMP;\n      }\n      else {\n        /* setup environment for calling method */\n        proc = ci->proc = MRB_METHOD_PROC(m);\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        ci->nregs = irep->nregs;\n        stack_extend(mrb, (argc < 0 && ci->nregs < 3) ? 3 : ci->nregs);\n        pc = irep->iseq;\n        JUMP;\n      }\n    }\n\n    CASE(OP_FSEND) {\n      /* A B C  R(A) := fcall(R(A),Syms(B),R(A+1),... ,R(A+C-1)) */\n      /* not implemented yet */\n      NEXT;\n    }\n\n    CASE(OP_CALL) {\n      /* A      R(A) := self.call(frame.argc, frame.argv) */\n      mrb_callinfo *ci;\n      mrb_value recv = mrb->c->stack[0];\n      struct RProc *m = mrb_proc_ptr(recv);\n\n      /* replace callinfo */\n      ci = mrb->c->ci;\n      ci->target_class = MRB_PROC_TARGET_CLASS(m);\n      ci->proc = m;\n      if (MRB_PROC_ENV_P(m)) {\n        mrb_sym mid;\n        struct REnv *e = MRB_PROC_ENV(m);\n\n        mid = e->mid;\n        if (mid) ci->mid = mid;\n        if (!e->stack) {\n          e->stack = mrb->c->stack;\n        }\n      }\n\n      /* prepare stack */\n      if (MRB_PROC_CFUNC_P(m)) {\n        recv = MRB_PROC_CFUNC(m)(mrb, recv);\n        mrb_gc_arena_restore(mrb, ai);\n        mrb_gc_arena_shrink(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        /* pop stackpos */\n        ci = mrb->c->ci;\n        mrb->c->stack = ci->stackent;\n        regs[ci->acc] = recv;\n        pc = ci->pc;\n        cipop(mrb);\n        irep = mrb->c->ci->proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        JUMP;\n      }\n      else {\n        /* setup environment for calling method */\n        proc = m;\n        irep = m->body.irep;\n        if (!irep) {\n          mrb->c->stack[0] = mrb_nil_value();\n          goto L_RETURN;\n        }\n        pool = irep->pool;\n        syms = irep->syms;\n        ci->nregs = irep->nregs;\n        stack_extend(mrb, ci->nregs);\n        if (ci->argc < 0) {\n          if (irep->nregs > 3) {\n            stack_clear(regs+3, irep->nregs-3);\n          }\n        }\n        else if (ci->argc+2 < irep->nregs) {\n          stack_clear(regs+ci->argc+2, irep->nregs-ci->argc-2);\n        }\n        if (MRB_PROC_ENV_P(m)) {\n          regs[0] = MRB_PROC_ENV(m)->stack[0];\n        }\n        pc = irep->iseq;\n        JUMP;\n      }\n    }\n\n    CASE(OP_SUPER) {\n      /* A C  R(A) := super(R(A+1),... ,R(A+C+1)) */\n      int a = GETARG_A(i);\n      int n = GETARG_C(i);\n      int argc = (n == CALL_MAXARGS) ? -1 : n;\n      int bidx = (argc < 0) ? a+2 : a+n+1;\n      mrb_method_t m;\n      struct RClass *c;\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_value recv, blk;\n      mrb_sym mid = ci->mid;\n      struct RClass* target_class = MRB_PROC_TARGET_CLASS(ci->proc);\n\n      mrb_assert(bidx < ci->nregs);\n\n      if (mid == 0 || !target_class) {\n        mrb_value exc = mrb_exc_new_str_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if (target_class->tt == MRB_TT_MODULE) {\n        target_class = ci->target_class;\n        if (target_class->tt != MRB_TT_ICLASS) {\n          mrb_value exc = mrb_exc_new_str_lit(mrb, E_RUNTIME_ERROR, \"superclass info lost [mruby limitations]\");\n          mrb_exc_set(mrb, exc);\n          goto L_RAISE;\n        }\n      }\n      recv = regs[0];\n      if (!mrb_obj_is_kind_of(mrb, recv, target_class)) {\n        mrb_value exc = mrb_exc_new_str_lit(mrb, E_TYPE_ERROR,\n                                            \"self has wrong type to call super in this context\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      blk = regs[bidx];\n      if (!mrb_nil_p(blk) && mrb_type(blk) != MRB_TT_PROC) {\n        blk = mrb_convert_type(mrb, blk, MRB_TT_PROC, \"Proc\", \"to_proc\");\n        /* The stack or ci stack might have been reallocated during\n           mrb_convert_type(), see #3622 and #3784 */\n        regs[bidx] = blk;\n        ci = mrb->c->ci;\n      }\n      c = target_class->super;\n      m = mrb_method_search_vm(mrb, &c, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        mrb_sym missing = mrb_intern_lit(mrb, \"method_missing\");\n\n        if (mid != missing) {\n          c = mrb_class(mrb, recv);\n        }\n        m = mrb_method_search_vm(mrb, &c, missing);\n        if (MRB_METHOD_UNDEF_P(m)) {\n          mrb_value args = (argc < 0) ? regs[a+1] : mrb_ary_new_from_values(mrb, n, regs+a+1);\n          ERR_PC_SET(mrb, pc);\n          mrb_method_missing(mrb, mid, recv, args);\n        }\n        mid = missing;\n        if (argc >= 0) {\n          if (a+2 >= ci->nregs) {\n            stack_extend(mrb, a+3);\n          }\n          regs[a+1] = mrb_ary_new_from_values(mrb, n, regs+a+1);\n          regs[a+2] = blk;\n          argc = -1;\n        }\n        mrb_ary_unshift(mrb, regs[a+1], mrb_symbol_value(ci->mid));\n      }\n\n      /* push callinfo */\n      ci = cipush(mrb);\n      ci->mid = mid;\n      ci->stackent = mrb->c->stack;\n      ci->target_class = c;\n      ci->pc = pc + 1;\n      ci->argc = argc;\n\n      /* prepare stack */\n      mrb->c->stack += a;\n      mrb->c->stack[0] = recv;\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        mrb_value v;\n        ci->nregs = (argc < 0) ? 3 : n+2;\n        if (MRB_METHOD_PROC_P(m)) {\n          ci->proc = MRB_METHOD_PROC(m);\n        }\n        v = MRB_METHOD_CFUNC(m)(mrb, recv);\n        mrb_gc_arena_restore(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        ci = mrb->c->ci;\n        if (!ci->target_class) { /* return from context modifying method (resume/yield) */\n          if (ci->acc == CI_ACC_RESUMED) {\n            mrb->jmp = prev_jmp;\n            return v;\n          }\n          else {\n            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n            proc = ci[-1].proc;\n            irep = proc->body.irep;\n            pool = irep->pool;\n            syms = irep->syms;\n          }\n        }\n        mrb->c->stack[0] = v;\n        /* pop stackpos */\n        mrb->c->stack = ci->stackent;\n        pc = ci->pc;\n        cipop(mrb);\n        JUMP;\n      }\n      else {\n        /* fill callinfo */\n        ci->acc = a;\n\n        /* setup environment for calling method */\n        proc = ci->proc = MRB_METHOD_PROC(m);\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        ci->nregs = irep->nregs;\n        stack_extend(mrb, (argc < 0 && ci->nregs < 3) ? 3 : ci->nregs);\n        pc = irep->iseq;\n        JUMP;\n      }\n    }\n\n    CASE(OP_ARGARY) {\n      /* A Bx   R(A) := argument array (16=6:1:5:4) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      int m1 = (bx>>10)&0x3f;\n      int r  = (bx>>9)&0x1;\n      int m2 = (bx>>4)&0x1f;\n      int lv = (bx>>0)&0xf;\n      mrb_value *stack;\n\n      if (mrb->c->ci->mid == 0 || mrb->c->ci->target_class == NULL) {\n        mrb_value exc;\n\n      L_NOSUPER:\n        exc = mrb_exc_new_str_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if (lv == 0) stack = regs + 1;\n      else {\n        struct REnv *e = uvenv(mrb, lv-1);\n        if (!e) goto L_NOSUPER;\n        if (MRB_ENV_STACK_LEN(e) <= m1+r+m2+1)\n          goto L_NOSUPER;\n        stack = e->stack + 1;\n      }\n      if (r == 0) {\n        regs[a] = mrb_ary_new_from_values(mrb, m1+m2, stack);\n      }\n      else {\n        mrb_value *pp = NULL;\n        struct RArray *rest;\n        int len = 0;\n\n        if (mrb_array_p(stack[m1])) {\n          struct RArray *ary = mrb_ary_ptr(stack[m1]);\n\n          pp = ARY_PTR(ary);\n          len = (int)ARY_LEN(ary);\n        }\n        regs[a] = mrb_ary_new_capa(mrb, m1+len+m2);\n        rest = mrb_ary_ptr(regs[a]);\n        if (m1 > 0) {\n          stack_copy(ARY_PTR(rest), stack, m1);\n        }\n        if (len > 0) {\n          stack_copy(ARY_PTR(rest)+m1, pp, len);\n        }\n        if (m2 > 0) {\n          stack_copy(ARY_PTR(rest)+m1+len, stack+m1+1, m2);\n        }\n        ARY_SET_LEN(rest, m1+len+m2);\n      }\n      regs[a+1] = stack[m1+r+m2];\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ENTER) {\n      /* Ax             arg setup according to flags (23=5:5:1:5:5:1:1) */\n      /* number of optional arguments times OP_JMP should follow */\n      mrb_aspec ax = GETARG_Ax(i);\n      int m1 = MRB_ASPEC_REQ(ax);\n      int o  = MRB_ASPEC_OPT(ax);\n      int r  = MRB_ASPEC_REST(ax);\n      int m2 = MRB_ASPEC_POST(ax);\n      /* unused\n      int k  = MRB_ASPEC_KEY(ax);\n      int kd = MRB_ASPEC_KDICT(ax);\n      int b  = MRB_ASPEC_BLOCK(ax);\n      */\n      int argc = mrb->c->ci->argc;\n      mrb_value *argv = regs+1;\n      mrb_value *argv0 = argv;\n      int len = m1 + o + r + m2;\n      mrb_value *blk = &argv[argc < 0 ? 1 : argc];\n\n      if (argc < 0) {\n        struct RArray *ary = mrb_ary_ptr(regs[1]);\n        argv = ARY_PTR(ary);\n        argc = (int)ARY_LEN(ary);\n        mrb_gc_protect(mrb, regs[1]);\n      }\n      if (mrb->c->ci->proc && MRB_PROC_STRICT_P(mrb->c->ci->proc)) {\n        if (argc >= 0) {\n          if (argc < m1 + m2 || (r == 0 && argc > len)) {\n            argnum_error(mrb, m1+m2);\n            goto L_RAISE;\n          }\n        }\n      }\n      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {\n        mrb_gc_protect(mrb, argv[0]);\n        argc = (int)RARRAY_LEN(argv[0]);\n        argv = RARRAY_PTR(argv[0]);\n      }\n      if (argc < len) {\n        int mlen = m2;\n        if (argc < m1+m2) {\n          if (m1 < argc)\n            mlen = argc - m1;\n          else\n            mlen = 0;\n        }\n        regs[len+1] = *blk; /* move block */\n        SET_NIL_VALUE(regs[argc+1]);\n        if (argv0 != argv) {\n          value_move(&regs[1], argv, argc-mlen); /* m1 + o */\n        }\n        if (argc < m1) {\n          stack_clear(&regs[argc+1], m1-argc);\n        }\n        if (mlen) {\n          value_move(&regs[len-m2+1], &argv[argc-mlen], mlen);\n        }\n        if (mlen < m2) {\n          stack_clear(&regs[len-m2+mlen+1], m2-mlen);\n        }\n        if (r) {\n          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);\n        }\n        if (o == 0 || argc < m1+m2) pc++;\n        else\n          pc += argc - m1 - m2 + 1;\n      }\n      else {\n        int rnum = 0;\n        if (argv0 != argv) {\n          regs[len+1] = *blk; /* move block */\n          value_move(&regs[1], argv, m1+o);\n        }\n        if (r) {\n          rnum = argc-m1-o-m2;\n          regs[m1+o+1] = mrb_ary_new_from_values(mrb, rnum, argv+m1+o);\n        }\n        if (m2) {\n          if (argc-m2 > m1) {\n            value_move(&regs[m1+o+r+1], &argv[m1+o+rnum], m2);\n          }\n        }\n        if (argv0 == argv) {\n          regs[len+1] = *blk; /* move block */\n        }\n        pc += o + 1;\n      }\n      mrb->c->ci->argc = len;\n      /* clear local (but non-argument) variables */\n      if (irep->nlocals-len-2 > 0) {\n        stack_clear(&regs[len+2], irep->nlocals-len-2);\n      }\n      JUMP;\n    }\n\n    CASE(OP_KARG) {\n      /* A B C          R(A) := kdict[Syms(B)]; if C kdict.rm(Syms(B)) */\n      /* if C == 2; raise unless kdict.empty? */\n      /* OP_JMP should follow to skip init code */\n      NEXT;\n    }\n\n    CASE(OP_KDICT) {\n      /* A C            R(A) := kdict */\n      NEXT;\n    }\n\n    L_RETURN:\n      i = MKOP_AB(OP_RETURN, GETARG_A(i), OP_R_NORMAL);\n      /* fall through */\n    CASE(OP_RETURN) {\n      /* A B     return R(A) (B=normal,in-block return/break) */\n      mrb_callinfo *ci;\n\n#define ecall_adjust() do {\\\n  ptrdiff_t cioff = ci - mrb->c->cibase;\\\n  ecall(mrb);\\\n  ci = mrb->c->cibase + cioff;\\\n} while (0)\n\n      ci = mrb->c->ci;\n      if (ci->mid) {\n        mrb_value blk;\n\n        if (ci->argc < 0) {\n          blk = regs[2];\n        }\n        else {\n          blk = regs[ci->argc+1];\n        }\n        if (mrb_type(blk) == MRB_TT_PROC) {\n          struct RProc *p = mrb_proc_ptr(blk);\n\n          if (!MRB_PROC_STRICT_P(p) &&\n              ci > mrb->c->cibase && MRB_PROC_ENV(p) == ci[-1].env) {\n            p->flags |= MRB_PROC_ORPHAN;\n          }\n        }\n      }\n\n      if (mrb->exc) {\n        mrb_callinfo *ci0;\n\n      L_RAISE:\n        ci0 = ci = mrb->c->ci;\n        if (ci == mrb->c->cibase) {\n          if (ci->ridx == 0) goto L_FTOP;\n          goto L_RESCUE;\n        }\n        while (ci[0].ridx == ci[-1].ridx) {\n          cipop(mrb);\n          mrb->c->stack = ci->stackent;\n          if (ci->acc == CI_ACC_SKIP && prev_jmp) {\n            mrb->jmp = prev_jmp;\n            MRB_THROW(prev_jmp);\n          }\n          ci = mrb->c->ci;\n          if (ci == mrb->c->cibase) {\n            if (ci->ridx == 0) {\n            L_FTOP:             /* fiber top */\n              if (mrb->c == mrb->root_c) {\n                mrb->c->stack = mrb->c->stbase;\n                goto L_STOP;\n              }\n              else {\n                struct mrb_context *c = mrb->c;\n\n                while (c->eidx > ci->epos) {\n                  ecall_adjust();\n                }\n                if (c->fib) {\n                  mrb_write_barrier(mrb, (struct RBasic*)c->fib);\n                }\n                mrb->c->status = MRB_FIBER_TERMINATED;\n                mrb->c = c->prev;\n                c->prev = NULL;\n                goto L_RAISE;\n              }\n            }\n            break;\n          }\n          /* call ensure only when we skip this callinfo */\n          if (ci[0].ridx == ci[-1].ridx) {\n            while (mrb->c->eidx > ci->epos) {\n              ecall_adjust();\n            }\n          }\n        }\n      L_RESCUE:\n        if (ci->ridx == 0) goto L_STOP;\n        proc = ci->proc;\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        if (ci < ci0) {\n          mrb->c->stack = ci[1].stackent;\n        }\n        stack_extend(mrb, irep->nregs);\n        pc = mrb->c->rescue[--ci->ridx];\n      }\n      else {\n        int acc;\n        mrb_value v;\n        struct RProc *dst;\n\n        ci = mrb->c->ci;\n        v = regs[GETARG_A(i)];\n        mrb_gc_protect(mrb, v);\n        switch (GETARG_B(i)) {\n        case OP_R_RETURN:\n          /* Fall through to OP_R_NORMAL otherwise */\n          if (ci->acc >=0 && MRB_PROC_ENV_P(proc) && !MRB_PROC_STRICT_P(proc)) {\n            mrb_callinfo *cibase = mrb->c->cibase;\n            dst = top_proc(mrb, proc);\n\n            if (MRB_PROC_ENV_P(dst)) {\n              struct REnv *e = MRB_PROC_ENV(dst);\n\n              if (!MRB_ENV_STACK_SHARED_P(e) || e->cxt != mrb->c) {\n                localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                goto L_RAISE;\n              }\n            }\n            while (cibase <= ci && ci->proc != dst) {\n              if (ci->acc < 0) {\n                localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                goto L_RAISE;\n              }\n              ci--;\n            }\n            if (ci <= cibase) {\n              localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n              goto L_RAISE;\n            }\n            break;\n          }\n        case OP_R_NORMAL:\n        NORMAL_RETURN:\n          if (ci == mrb->c->cibase) {\n            struct mrb_context *c;\n\n            if (!mrb->c->prev) { /* toplevel return */\n              localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n              goto L_RAISE;\n            }\n            if (mrb->c->prev->ci == mrb->c->prev->cibase) {\n              mrb_value exc = mrb_exc_new_str_lit(mrb, E_FIBER_ERROR, \"double resume\");\n              mrb_exc_set(mrb, exc);\n              goto L_RAISE;\n            }\n            while (mrb->c->eidx > 0) {\n              ecall(mrb);\n            }\n            /* automatic yield at the end */\n            c = mrb->c;\n            c->status = MRB_FIBER_TERMINATED;\n            mrb->c = c->prev;\n            c->prev = NULL;\n            mrb->c->status = MRB_FIBER_RUNNING;\n            ci = mrb->c->ci;\n          }\n          break;\n        case OP_R_BREAK:\n          if (MRB_PROC_STRICT_P(proc)) goto NORMAL_RETURN;\n          if (MRB_PROC_ORPHAN_P(proc)) { \n            mrb_value exc;\n\n          L_BREAK_ERROR:\n            exc = mrb_exc_new_str_lit(mrb, E_LOCALJUMP_ERROR,\n                                      \"break from proc-closure\");\n            mrb_exc_set(mrb, exc);\n            goto L_RAISE;\n          }\n          if (!MRB_PROC_ENV_P(proc) || !MRB_ENV_STACK_SHARED_P(MRB_PROC_ENV(proc))) {\n            goto L_BREAK_ERROR;\n          }\n          else {\n            struct REnv *e = MRB_PROC_ENV(proc);\n\n            if (e == mrb->c->cibase->env && proc != mrb->c->cibase->proc) {\n              goto L_BREAK_ERROR;\n            }\n            if (e->cxt != mrb->c) {\n              goto L_BREAK_ERROR;\n            }\n          }\n          while (mrb->c->eidx > mrb->c->ci->epos) {\n            ecall_adjust();\n          }\n          /* break from fiber block */\n          if (ci == mrb->c->cibase && ci->pc) {\n            struct mrb_context *c = mrb->c;\n\n            mrb->c = c->prev;\n            c->prev = NULL;\n            ci = mrb->c->ci;\n          }\n          if (ci->acc < 0) {\n            mrb_gc_arena_restore(mrb, ai);\n            mrb->c->vmexec = FALSE;\n            mrb->exc = (struct RObject*)break_new(mrb, proc, v);\n            mrb->jmp = prev_jmp;\n            MRB_THROW(prev_jmp);\n          }\n          if (FALSE) {\n          L_BREAK:\n            v = ((struct RBreak*)mrb->exc)->val;\n            proc = ((struct RBreak*)mrb->exc)->proc;\n            mrb->exc = NULL;\n            ci = mrb->c->ci;\n          }\n          mrb->c->stack = ci->stackent;\n          proc = proc->upper;\n          while (mrb->c->cibase < ci &&  ci[-1].proc != proc) {\n            if (ci[-1].acc == CI_ACC_SKIP) {\n              while (ci < mrb->c->ci) {\n                cipop(mrb);\n              }\n              goto L_BREAK_ERROR;\n            }\n            ci--;\n          }\n          if (ci == mrb->c->cibase) {\n            goto L_BREAK_ERROR;\n          }\n          break;\n        default:\n          /* cannot happen */\n          break;\n        }\n        while (ci < mrb->c->ci) {\n          cipop(mrb);\n        }\n        ci[0].ridx = ci[-1].ridx;\n        while (mrb->c->eidx > ci->epos) {\n          ecall_adjust();\n        }\n        if (mrb->c->vmexec && !ci->target_class) {\n          mrb_gc_arena_restore(mrb, ai);\n          mrb->c->vmexec = FALSE;\n          mrb->jmp = prev_jmp;\n          return v;\n        }\n        acc = ci->acc;\n        mrb->c->stack = ci->stackent;\n        cipop(mrb);\n        if (acc == CI_ACC_SKIP || acc == CI_ACC_DIRECT) {\n          mrb_gc_arena_restore(mrb, ai);\n          mrb->jmp = prev_jmp;\n          return v;\n        }\n        pc = ci->pc;\n        ci = mrb->c->ci;\n        DEBUG(fprintf(stderr, \"from :%s\\n\", mrb_sym2name(mrb, ci->mid)));\n        proc = mrb->c->ci->proc;\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n\n        regs[acc] = v;\n        mrb_gc_arena_restore(mrb, ai);\n      }\n      JUMP;\n    }\n\n    CASE(OP_TAILCALL) {\n      /* A B C  return call(R(A),Syms(B),R(A+1),... ,R(A+C+1)) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int n = GETARG_C(i);\n      mrb_method_t m;\n      struct RClass *c;\n      mrb_callinfo *ci;\n      mrb_value recv;\n      mrb_sym mid = syms[b];\n\n      recv = regs[a];\n      c = mrb_class(mrb, recv);\n      m = mrb_method_search_vm(mrb, &c, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        mrb_value sym = mrb_symbol_value(mid);\n        mrb_sym missing = mrb_intern_lit(mrb, \"method_missing\");\n        m = mrb_method_search_vm(mrb, &c, missing);\n        if (MRB_METHOD_UNDEF_P(m)) {\n          mrb_value args;\n\n          if (n == CALL_MAXARGS) {\n            args = regs[a+1];\n          }\n          else {\n            args = mrb_ary_new_from_values(mrb, n, regs+a+1);\n          }\n          ERR_PC_SET(mrb, pc);\n          mrb_method_missing(mrb, mid, recv, args);\n        }\n        mid = missing;\n        if (n == CALL_MAXARGS) {\n          mrb_ary_unshift(mrb, regs[a+1], sym);\n        }\n        else {\n          value_move(regs+a+2, regs+a+1, ++n);\n          regs[a+1] = sym;\n        }\n      }\n\n      /* replace callinfo */\n      ci = mrb->c->ci;\n      ci->mid = mid;\n      ci->target_class = c;\n      if (n == CALL_MAXARGS) {\n        ci->argc = -1;\n      }\n      else {\n        ci->argc = n;\n      }\n\n      /* move stack */\n      value_move(mrb->c->stack, &regs[a], ci->argc+1);\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        mrb_value v = MRB_METHOD_CFUNC(m)(mrb, recv);\n        mrb->c->stack[0] = v;\n        mrb_gc_arena_restore(mrb, ai);\n        goto L_RETURN;\n      }\n      else {\n        /* setup environment for calling method */\n        struct RProc *p = MRB_METHOD_PROC(m);\n        irep = p->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        if (ci->argc < 0) {\n          stack_extend(mrb, (irep->nregs < 3) ? 3 : irep->nregs);\n        }\n        else {\n          stack_extend(mrb, irep->nregs);\n        }\n        pc = irep->iseq;\n      }\n      JUMP;\n    }\n\n    CASE(OP_BLKPUSH) {\n      /* A Bx   R(A) := block (16=6:1:5:4) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      int m1 = (bx>>10)&0x3f;\n      int r  = (bx>>9)&0x1;\n      int m2 = (bx>>4)&0x1f;\n      int lv = (bx>>0)&0xf;\n      mrb_value *stack;\n\n      if (lv == 0) stack = regs + 1;\n      else {\n        struct REnv *e = uvenv(mrb, lv-1);\n        if (!e || (!MRB_ENV_STACK_SHARED_P(e) && e->mid == 0) ||\n            MRB_ENV_STACK_LEN(e) <= m1+r+m2+1) {\n          localjump_error(mrb, LOCALJUMP_ERROR_YIELD);\n          goto L_RAISE;\n        }\n        stack = e->stack + 1;\n      }\n      if (mrb_nil_p(stack[m1+r+m2])) {\n        localjump_error(mrb, LOCALJUMP_ERROR_YIELD);\n        goto L_RAISE;\n      }\n      regs[a] = stack[m1+r+m2];\n      NEXT;\n    }\n\n#define TYPES2(a,b) ((((uint16_t)(a))<<8)|(((uint16_t)(b))&0xff))\n#define OP_MATH_BODY(op,v1,v2) do {\\\n  v1(regs[a]) = v1(regs[a]) op v2(regs[a+1]);\\\n} while(0)\n\n    CASE(OP_ADD) {\n      /* A B C  R(A) := R(A)+R(A+1) (Syms[B]=:+,C=1)*/\n      int a = GETARG_A(i);\n\n      /* need to check if op is overridden */\n      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\n        {\n          mrb_int x, y, z;\n          mrb_value *regs_a = regs + a;\n\n          x = mrb_fixnum(regs_a[0]);\n          y = mrb_fixnum(regs_a[1]);\n          if (mrb_int_add_overflow(x, y, &z)) {\n#ifndef MRB_WITHOUT_FLOAT\n            SET_FLOAT_VALUE(mrb, regs_a[0], (mrb_float)x + (mrb_float)y);\n            break;\n#endif\n          }\n          SET_INT_VALUE(regs[a], z);\n        }\n        break;\n#ifndef MRB_WITHOUT_FLOAT\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):\n        {\n          mrb_int x = mrb_fixnum(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x + y);\n        }\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_int y = mrb_fixnum(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x + y);\n        }\n#else\n        OP_MATH_BODY(+,mrb_float,mrb_fixnum);\n#endif\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x + y);\n        }\n#else\n        OP_MATH_BODY(+,mrb_float,mrb_float);\n#endif\n        break;\n#endif\n      case TYPES2(MRB_TT_STRING,MRB_TT_STRING):\n        regs[a] = mrb_str_plus(mrb, regs[a], regs[a+1]);\n        break;\n      default:\n        goto L_SEND;\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_SUB) {\n      /* A B C  R(A) := R(A)-R(A+1) (Syms[B]=:-,C=1)*/\n      int a = GETARG_A(i);\n\n      /* need to check if op is overridden */\n      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\n        {\n          mrb_int x, y, z;\n\n          x = mrb_fixnum(regs[a]);\n          y = mrb_fixnum(regs[a+1]);\n          if (mrb_int_sub_overflow(x, y, &z)) {\n#ifndef MRB_WITHOUT_FLOAT\n            SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x - (mrb_float)y);\n            break;\n#endif\n          }\n          SET_INT_VALUE(regs[a], z);\n        }\n        break;\n#ifndef MRB_WITHOUT_FLOAT\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):\n        {\n          mrb_int x = mrb_fixnum(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x - y);\n        }\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_int y = mrb_fixnum(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x - y);\n        }\n#else\n        OP_MATH_BODY(-,mrb_float,mrb_fixnum);\n#endif\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x - y);\n        }\n#else\n        OP_MATH_BODY(-,mrb_float,mrb_float);\n#endif\n        break;\n#endif\n      default:\n        goto L_SEND;\n      }\n      NEXT;\n    }\n\n    CASE(OP_MUL) {\n      /* A B C  R(A) := R(A)*R(A+1) (Syms[B]=:*,C=1)*/\n      int a = GETARG_A(i);\n\n      /* need to check if op is overridden */\n      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\n        {\n          mrb_int x, y, z;\n\n          x = mrb_fixnum(regs[a]);\n          y = mrb_fixnum(regs[a+1]);\n          if (mrb_int_mul_overflow(x, y, &z)) {\n#ifndef MRB_WITHOUT_FLOAT\n            SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x * (mrb_float)y);\n            break;\n#endif\n          }\n          SET_INT_VALUE(regs[a], z);\n        }\n        break;\n#ifndef MRB_WITHOUT_FLOAT\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):\n        {\n          mrb_int x = mrb_fixnum(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x * y);\n        }\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_int y = mrb_fixnum(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x * y);\n        }\n#else\n        OP_MATH_BODY(*,mrb_float,mrb_fixnum);\n#endif\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          mrb_float y = mrb_float(regs[a+1]);\n          SET_FLOAT_VALUE(mrb, regs[a], x * y);\n        }\n#else\n        OP_MATH_BODY(*,mrb_float,mrb_float);\n#endif\n        break;\n#endif\n      default:\n        goto L_SEND;\n      }\n      NEXT;\n    }\n\n    CASE(OP_DIV) {\n      /* A B C  R(A) := R(A)/R(A+1) (Syms[B]=:/,C=1)*/\n      int a = GETARG_A(i);\n#ifndef MRB_WITHOUT_FLOAT\n      double x, y, f;\n#endif\n\n      /* need to check if op is overridden */\n      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\n#ifdef MRB_WITHOUT_FLOAT\n        {\n          mrb_int x = mrb_fixnum(regs[a]);\n          mrb_int y = mrb_fixnum(regs[a+1]);\n          SET_INT_VALUE(regs[a], y ? x / y : 0);\n        }\n        break;\n#else\n        x = (mrb_float)mrb_fixnum(regs[a]);\n        y = (mrb_float)mrb_fixnum(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):\n        x = (mrb_float)mrb_fixnum(regs[a]);\n        y = mrb_float(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):\n        x = mrb_float(regs[a]);\n        y = (mrb_float)mrb_fixnum(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n        x = mrb_float(regs[a]);\n        y = mrb_float(regs[a+1]);\n        break;\n#endif\n      default:\n        goto L_SEND;\n      }\n\n#ifndef MRB_WITHOUT_FLOAT\n      if (y == 0) {\n        if (x > 0) f = INFINITY;\n        else if (x < 0) f = -INFINITY;\n        else /* if (x == 0) */ f = NAN;\n      }\n      else {\n        f = x / y;\n      }\n      SET_FLOAT_VALUE(mrb, regs[a], f);\n#endif\n      NEXT;\n    }\n\n    CASE(OP_ADDI) {\n      /* A B C  R(A) := R(A)+C (Syms[B]=:+)*/\n      int a = GETARG_A(i);\n\n      /* need to check if + is overridden */\n      switch (mrb_type(regs[a])) {\n      case MRB_TT_FIXNUM:\n        {\n          mrb_int x = mrb_fixnum(regs[a]);\n          mrb_int y = GETARG_C(i);\n          mrb_int z;\n\n          if (mrb_int_add_overflow(x, y, &z)) {\n#ifndef MRB_WITHOUT_FLOAT\n            SET_FLOAT_VALUE(mrb, regs[a], (mrb_float)x + (mrb_float)y);\n            break;\n#endif\n          }\n          SET_INT_VALUE(regs[a], z);\n        }\n        break;\n#ifndef MRB_WITHOUT_FLOAT\n      case MRB_TT_FLOAT:\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          SET_FLOAT_VALUE(mrb, regs[a], x + GETARG_C(i));\n        }\n#else\n        mrb_float(regs[a]) += GETARG_C(i);\n#endif\n        break;\n#endif\n      default:\n        SET_INT_VALUE(regs[a+1], GETARG_C(i));\n        i = MKOP_ABC(OP_SEND, a, GETARG_B(i), 1);\n        goto L_SEND;\n      }\n      NEXT;\n    }\n\n    CASE(OP_SUBI) {\n      /* A B C  R(A) := R(A)-C (Syms[B]=:-)*/\n      int a = GETARG_A(i);\n      mrb_value *regs_a = regs + a;\n\n      /* need to check if + is overridden */\n      switch (mrb_type(regs_a[0])) {\n      case MRB_TT_FIXNUM:\n        {\n          mrb_int x = mrb_fixnum(regs_a[0]);\n          mrb_int y = GETARG_C(i);\n          mrb_int z;\n\n          if (mrb_int_sub_overflow(x, y, &z)) {\n#ifndef MRB_WITHOUT_FLOAT\n            SET_FLOAT_VALUE(mrb, regs_a[0], (mrb_float)x - (mrb_float)y);\n            break;\n#endif\n          }\n          SET_INT_VALUE(regs_a[0], z);\n        }\n        break;\n#ifndef MRB_WITHOUT_FLOAT\n      case MRB_TT_FLOAT:\n#ifdef MRB_WORD_BOXING\n        {\n          mrb_float x = mrb_float(regs[a]);\n          SET_FLOAT_VALUE(mrb, regs[a], x - GETARG_C(i));\n        }\n#else\n        mrb_float(regs_a[0]) -= GETARG_C(i);\n#endif\n        break;\n#endif\n      default:\n        SET_INT_VALUE(regs_a[1], GETARG_C(i));\n        i = MKOP_ABC(OP_SEND, a, GETARG_B(i), 1);\n        goto L_SEND;\n      }\n      NEXT;\n    }\n\n#define OP_CMP_BODY(op,v1,v2) (v1(regs[a]) op v2(regs[a+1]))\n\n#ifdef MRB_WITHOUT_FLOAT\n#define OP_CMP(op) do {\\\n  int result;\\\n  /* need to check if - is overridden */\\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\\\n  case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\\\n    break;\\\n  default:\\\n    goto L_SEND;\\\n  }\\\n  if (result) {\\\n    SET_TRUE_VALUE(regs[a]);\\\n  }\\\n  else {\\\n    SET_FALSE_VALUE(regs[a]);\\\n  }\\\n} while(0)\n#else\n#define OP_CMP(op) do {\\\n  int result;\\\n  /* need to check if - is overridden */\\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\\\n  case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\\\n    break;\\\n  case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_float);\\\n    break;\\\n  case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):\\\n    result = OP_CMP_BODY(op,mrb_float,mrb_fixnum);\\\n    break;\\\n  case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\\\n    result = OP_CMP_BODY(op,mrb_float,mrb_float);\\\n    break;\\\n  default:\\\n    goto L_SEND;\\\n  }\\\n  if (result) {\\\n    SET_TRUE_VALUE(regs[a]);\\\n  }\\\n  else {\\\n    SET_FALSE_VALUE(regs[a]);\\\n  }\\\n} while(0)\n#endif\n\n    CASE(OP_EQ) {\n      /* A B C  R(A) := R(A)==R(A+1) (Syms[B]=:==,C=1)*/\n      int a = GETARG_A(i);\n      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {\n        SET_TRUE_VALUE(regs[a]);\n      }\n      else {\n        OP_CMP(==);\n      }\n      NEXT;\n    }\n\n    CASE(OP_LT) {\n      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/\n      int a = GETARG_A(i);\n      OP_CMP(<);\n      NEXT;\n    }\n\n    CASE(OP_LE) {\n      /* A B C  R(A) := R(A)<=R(A+1) (Syms[B]=:<=,C=1)*/\n      int a = GETARG_A(i);\n      OP_CMP(<=);\n      NEXT;\n    }\n\n    CASE(OP_GT) {\n      /* A B C  R(A) := R(A)>R(A+1) (Syms[B]=:>,C=1)*/\n      int a = GETARG_A(i);\n      OP_CMP(>);\n      NEXT;\n    }\n\n    CASE(OP_GE) {\n      /* A B C  R(A) := R(A)>=R(A+1) (Syms[B]=:>=,C=1)*/\n      int a = GETARG_A(i);\n      OP_CMP(>=);\n      NEXT;\n    }\n\n    CASE(OP_ARRAY) {\n      /* A B C          R(A) := ary_new(R(B),R(B+1)..R(B+C)) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n      mrb_value v = mrb_ary_new_from_values(mrb, c, &regs[b]);\n      regs[a] = v;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ARYCAT) {\n      /* A B            mrb_ary_concat(R(A),R(B)) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      mrb_value splat = mrb_ary_splat(mrb, regs[b]);\n      mrb_ary_concat(mrb, regs[a], splat);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ARYPUSH) {\n      /* A B            R(A).push(R(B)) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      mrb_ary_push(mrb, regs[a], regs[b]);\n      NEXT;\n    }\n\n    CASE(OP_AREF) {\n      /* A B C          R(A) := R(B)[C] */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n      mrb_value v = regs[b];\n\n      if (!mrb_array_p(v)) {\n        if (c == 0) {\n          regs[a] = v;\n        }\n        else {\n          SET_NIL_VALUE(regs[a]);\n        }\n      }\n      else {\n        v = mrb_ary_ref(mrb, v, c);\n        regs[a] = v;\n      }\n      NEXT;\n    }\n\n    CASE(OP_ASET) {\n      /* A B C          R(B)[C] := R(A) */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n      mrb_ary_set(mrb, regs[b], c, regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_APOST) {\n      /* A B C  *R(A),R(A+1)..R(A+C) := R(A) */\n      int a = GETARG_A(i);\n      mrb_value v = regs[a];\n      int pre  = GETARG_B(i);\n      int post = GETARG_C(i);\n      struct RArray *ary;\n      int len, idx;\n\n      if (!mrb_array_p(v)) {\n        v = mrb_ary_new_from_values(mrb, 1, &regs[a]);\n      }\n      ary = mrb_ary_ptr(v);\n      len = (int)ARY_LEN(ary);\n      if (len > pre + post) {\n        v = mrb_ary_new_from_values(mrb, len - pre - post, ARY_PTR(ary)+pre);\n        regs[a++] = v;\n        while (post--) {\n          regs[a++] = ARY_PTR(ary)[len-post-1];\n        }\n      }\n      else {\n        v = mrb_ary_new_capa(mrb, 0);\n        regs[a++] = v;\n        for (idx=0; idx+pre<len; idx++) {\n          regs[a+idx] = ARY_PTR(ary)[pre+idx];\n        }\n        while (idx < post) {\n          SET_NIL_VALUE(regs[a+idx]);\n          idx++;\n        }\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_STRING) {\n      /* A Bx           R(A) := str_new(Lit(Bx)) */\n      mrb_int a = GETARG_A(i);\n      mrb_int bx = GETARG_Bx(i);\n      mrb_value str = mrb_str_dup(mrb, pool[bx]);\n\n      regs[a] = str;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_STRCAT) {\n      /* A B    R(A).concat(R(B)) */\n      mrb_int a = GETARG_A(i);\n      mrb_int b = GETARG_B(i);\n\n      mrb_str_concat(mrb, regs[a], regs[b]);\n      NEXT;\n    }\n\n    CASE(OP_HASH) {\n      /* A B C   R(A) := hash_new(R(B),R(B+1)..R(B+C)) */\n      int b = GETARG_B(i);\n      int c = GETARG_C(i);\n      int lim = b+c*2;\n      mrb_value hash = mrb_hash_new_capa(mrb, c);\n\n      while (b < lim) {\n        mrb_hash_set(mrb, hash, regs[b], regs[b+1]);\n        b+=2;\n      }\n      regs[GETARG_A(i)] = hash;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_LAMBDA) {\n      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */\n      struct RProc *p;\n      int a = GETARG_A(i);\n      int b = GETARG_b(i);\n      int c = GETARG_c(i);\n      mrb_irep *nirep = irep->reps[b];\n\n      if (c & OP_L_CAPTURE) {\n        p = mrb_closure_new(mrb, nirep);\n      }\n      else {\n        p = mrb_proc_new(mrb, nirep);\n        p->flags |= MRB_PROC_SCOPE;\n      }\n      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;\n      regs[a] = mrb_obj_value(p);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_OCLASS) {\n      /* A      R(A) := ::Object */\n      regs[GETARG_A(i)] = mrb_obj_value(mrb->object_class);\n      NEXT;\n    }\n\n    CASE(OP_CLASS) {\n      /* A B    R(A) := newclass(R(A),Syms(B),R(A+1)) */\n      struct RClass *c = 0, *baseclass;\n      int a = GETARG_A(i);\n      mrb_value base, super;\n      mrb_sym id = syms[GETARG_B(i)];\n\n      base = regs[a];\n      super = regs[a+1];\n      if (mrb_nil_p(base)) {\n        baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);\n        base = mrb_obj_value(baseclass);\n      }\n      c = mrb_vm_define_class(mrb, base, super, id);\n      regs[a] = mrb_obj_value(c);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_MODULE) {\n      /* A B            R(A) := newmodule(R(A),Syms(B)) */\n      struct RClass *c = 0, *baseclass;\n      int a = GETARG_A(i);\n      mrb_value base;\n      mrb_sym id = syms[GETARG_B(i)];\n\n      base = regs[a];\n      if (mrb_nil_p(base)) {\n        baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);\n        base = mrb_obj_value(baseclass);\n      }\n      c = mrb_vm_define_module(mrb, base, id);\n      regs[a] = mrb_obj_value(c);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_EXEC) {\n      /* A Bx   R(A) := blockexec(R(A),SEQ[Bx]) */\n      int a = GETARG_A(i);\n      int bx = GETARG_Bx(i);\n      mrb_callinfo *ci;\n      mrb_value recv = regs[a];\n      struct RProc *p;\n      mrb_irep *nirep = irep->reps[bx];\n\n      /* prepare closure */\n      p = mrb_proc_new(mrb, nirep);\n      p->c = NULL;\n      mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)proc);\n      MRB_PROC_SET_TARGET_CLASS(p, mrb_class_ptr(recv));\n      p->flags |= MRB_PROC_SCOPE;\n\n      /* prepare call stack */\n      ci = cipush(mrb);\n      ci->pc = pc + 1;\n      ci->acc = a;\n      ci->mid = 0;\n      ci->stackent = mrb->c->stack;\n      ci->argc = 0;\n      ci->target_class = mrb_class_ptr(recv);\n\n      /* prepare stack */\n      mrb->c->stack += a;\n\n      /* setup block to call */\n      ci->proc = p;\n\n      irep = p->body.irep;\n      pool = irep->pool;\n      syms = irep->syms;\n      ci->nregs = irep->nregs;\n      stack_extend(mrb, ci->nregs);\n      stack_clear(regs+1, ci->nregs-1);\n      pc = irep->iseq;\n      JUMP;\n    }\n\n    CASE(OP_METHOD) {\n      /* A B            R(A).newmethod(Syms(B),R(A+1)) */\n      int a = GETARG_A(i);\n      struct RClass *c = mrb_class_ptr(regs[a]);\n      struct RProc *p = mrb_proc_ptr(regs[a+1]);\n      mrb_method_t m;\n\n      MRB_METHOD_FROM_PROC(m, p);\n      mrb_define_method_raw(mrb, c, syms[GETARG_B(i)], m);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_SCLASS) {\n      /* A B    R(A) := R(B).singleton_class */\n      int a = GETARG_A(i);\n      int b = GETARG_B(i);\n\n      regs[a] = mrb_singleton_class(mrb, regs[b]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_TCLASS) {\n      /* A      R(A) := target_class */\n      if (!mrb->c->ci->target_class) {\n        mrb_value exc = mrb_exc_new_str_lit(mrb, E_TYPE_ERROR, \"no target class or module\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      regs[GETARG_A(i)] = mrb_obj_value(mrb->c->ci->target_class);\n      NEXT;\n    }\n\n    CASE(OP_RANGE) {\n      /* A B C  R(A) := range_new(R(B),R(B+1),C) */\n      int b = GETARG_B(i);\n      mrb_value val = mrb_range_new(mrb, regs[b], regs[b+1], GETARG_C(i));\n      regs[GETARG_A(i)] = val;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_DEBUG) {\n      /* A B C    debug print R(A),R(B),R(C) */\n#ifdef MRB_ENABLE_DEBUG_HOOK\n      mrb->debug_op_hook(mrb, irep, pc, regs);\n#else\n#ifndef MRB_DISABLE_STDIO\n      printf(\"OP_DEBUG %d %d %d\\n\", GETARG_A(i), GETARG_B(i), GETARG_C(i));\n#else\n      abort();\n#endif\n#endif\n      NEXT;\n    }\n\n    CASE(OP_STOP) {\n      /*        stop VM */\n    L_STOP:\n      while (mrb->c->eidx > 0) {\n        ecall(mrb);\n      }\n      ERR_PC_CLR(mrb);\n      mrb->jmp = prev_jmp;\n      if (mrb->exc) {\n        return mrb_obj_value(mrb->exc);\n      }\n      return regs[irep->nlocals];\n    }\n\n    CASE(OP_ERR) {\n      /* Bx     raise RuntimeError with message Lit(Bx) */\n      mrb_value msg = mrb_str_dup(mrb, pool[GETARG_Bx(i)]);\n      mrb_value exc;\n\n      if (GETARG_A(i) == 0) {\n        exc = mrb_exc_new_str(mrb, E_RUNTIME_ERROR, msg);\n      }\n      else {\n        exc = mrb_exc_new_str(mrb, E_LOCALJUMP_ERROR, msg);\n      }\n      ERR_PC_SET(mrb, pc);\n      mrb_exc_set(mrb, exc);\n      goto L_RAISE;\n    }\n  }\n  END_DISPATCH;\n#undef regs\n\n  }\n  MRB_CATCH(&c_jmp) {\n    exc_catched = TRUE;\n    goto RETRY_TRY_BLOCK;\n  }\n  MRB_END_EXC(&c_jmp);\n}\n", "target": 1, "idx": 182428}
{"func": "status_t Parcel::readPointer(uintptr_t *pArg) const\n{\n status_t ret;\n binder_uintptr_t ptr;\n    ret = readAligned(&ptr);\n if (!ret)\n *pArg = ptr;\n return ret;\n}\n", "target": 0, "idx": 170481}
{"func": "static struct extent_map *create_pinned_em(struct inode *inode, u64 start,\n\t\t\t\t\t   u64 len, u64 orig_start,\n\t\t\t\t\t   u64 block_start, u64 block_len,\n\t\t\t\t\t   u64 orig_block_len, int type)\n{\n\tstruct extent_map_tree *em_tree;\n\tstruct extent_map *em;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tint ret;\n\n\tem_tree = &BTRFS_I(inode)->extent_tree;\n\tem = alloc_extent_map();\n\tif (!em)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tem->start = start;\n\tem->orig_start = orig_start;\n\tem->len = len;\n\tem->block_len = block_len;\n\tem->block_start = block_start;\n\tem->bdev = root->fs_info->fs_devices->latest_bdev;\n\tem->orig_block_len = orig_block_len;\n\tem->generation = -1;\n\tset_bit(EXTENT_FLAG_PINNED, &em->flags);\n\tif (type == BTRFS_ORDERED_PREALLOC)\n\t\tset_bit(EXTENT_FLAG_FILLING, &em->flags);\n\n\tdo {\n\t\tbtrfs_drop_extent_cache(inode, em->start,\n\t\t\t\tem->start + em->len - 1, 0);\n\t\twrite_lock(&em_tree->lock);\n\t\tret = add_extent_mapping(em_tree, em);\n\t\tif (!ret)\n\t\t\tlist_move(&em->list,\n\t\t\t\t  &em_tree->modified_extents);\n\t\twrite_unlock(&em_tree->lock);\n\t} while (ret == -EEXIST);\n\n\tif (ret) {\n\t\tfree_extent_map(em);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn em;\n}\n", "target": 0, "idx": 34376}
{"func": "void comps_mrtree_unite(COMPS_MRTree *rt1, COMPS_MRTree *rt2) {\n    COMPS_HSList *tmplist, *tmp_subnodes;\n    COMPS_HSListItem *it, *it2;\n     struct Pair {\n         COMPS_HSList * subnodes;\n         char * key;\n        char added;\n     } *pair, *parent_pair;\n \n     pair = malloc(sizeof(struct Pair));\n    pair->subnodes = rt2->subnodes;\n    pair->key = NULL;\n\n    tmplist = comps_hslist_create();\n    comps_hslist_init(tmplist, NULL, NULL, &free);\n    comps_hslist_append(tmplist, pair, 0);\n\n    while (tmplist->first != NULL) {\n        it = tmplist->first;\n        comps_hslist_remove(tmplist, tmplist->first);\n        tmp_subnodes = ((struct Pair*)it->data)->subnodes;\n         parent_pair = (struct Pair*) it->data;\n         free(it);\n \n        pair->added = 0;\n         for (it = tmp_subnodes->first; it != NULL; it=it->next) {\n             pair = malloc(sizeof(struct Pair));\n             pair->subnodes = ((COMPS_MRTreeData*)it->data)->subnodes;\n\n            if (parent_pair->key != NULL) {\n                pair->key =\n                    malloc(sizeof(char)\n                           * (strlen(((COMPS_MRTreeData*)it->data)->key)\n                           + strlen(parent_pair->key) + 1));\n                memcpy(pair->key, parent_pair->key,\n                       sizeof(char) * strlen(parent_pair->key));\n                memcpy(pair->key+strlen(parent_pair->key),\n                       ((COMPS_MRTreeData*)it->data)->key,\n                       sizeof(char)*(strlen(((COMPS_MRTreeData*)it->data)->key)+1));\n            } else {\n                pair->key = malloc(sizeof(char)*\n                                (strlen(((COMPS_MRTreeData*)it->data)->key) +\n                                1));\n                memcpy(pair->key, ((COMPS_MRTreeData*)it->data)->key,\n                       sizeof(char)*(strlen(((COMPS_MRTreeData*)it->data)->key)+1));\n            }\n            /* current node has data */\n            if (((COMPS_MRTreeData*)it->data)->data->first != NULL) {\n                for (it2 = ((COMPS_MRTreeData*)it->data)->data->first;\n                     it2 != NULL; it2 = it2->next) {\n                    comps_mrtree_set(rt1, pair->key, it2->data);\n                }\n\n                if (((COMPS_MRTreeData*)it->data)->subnodes->first) {\n                    comps_hslist_append(tmplist, pair, 0);\n                } else {\n                    free(pair->key);\n                    free(pair);\n                }\n            /* current node hasn't data */\n            } else {\n                if (((COMPS_MRTreeData*)it->data)->subnodes->first) {\n                    comps_hslist_append(tmplist, pair, 0);\n                } else {\n                    free(pair->key);\n                    free(pair);\n                }\n            }\n        }\n        free(parent_pair->key);\n        free(parent_pair);\n    }\n    comps_hslist_destroy(&tmplist);\n}\n", "target": 1, "idx": 182922}
{"func": "set_string_2_svc(sstring_arg *arg, struct svc_req *rqstp)\n {\n     static generic_ret              ret;\n     char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n     OM_uint32                       minor_stat;\n     kadm5_server_handle_t           handle;\n     const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (CHANGEPW_SERVICE(rqstp)\n        || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_MODIFY,\n                               arg->princ, NULL)) {\n        ret.code = KADM5_AUTH_MODIFY;\n        log_unauth(\"kadm5_mod_strings\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_set_string((void *)handle, arg->princ, arg->key,\n                                    arg->value);\n        if (ret.code != 0)\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_mod_strings\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n             krb5_free_error_message(handle->context, errmsg);\n     }\n     free(prime_arg);\n     gss_release_buffer(&minor_stat, &client_name);\n     gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n     free_server_handle(handle);\n     return &ret;\n }\n", "target": 1, "idx": 180696}
{"func": " void HttpAuthFilterWhitelist::SetWhitelist(\n     const std::string& server_whitelist) {\n  rules_.ParseFromString(server_whitelist);\n }\n", "target": 1, "idx": 186621}
{"func": " safecat_color_encoding(char *buffer, size_t bufsize, size_t pos,\n   PNG_CONST color_encoding *e, double encoding_gamma)\n {\n    if (e != 0)\n    {\n if (encoding_gamma != 0)\n         pos = safecat(buffer, bufsize, pos, \"(\");\n      pos = safecat(buffer, bufsize, pos, \"R(\");\n      pos = safecatd(buffer, bufsize, pos, e->red.X, 4);\n      pos = safecat(buffer, bufsize, pos, \",\");\n      pos = safecatd(buffer, bufsize, pos, e->red.Y, 4);\n      pos = safecat(buffer, bufsize, pos, \",\");\n      pos = safecatd(buffer, bufsize, pos, e->red.Z, 4);\n      pos = safecat(buffer, bufsize, pos, \"),G(\");\n      pos = safecatd(buffer, bufsize, pos, e->green.X, 4);\n      pos = safecat(buffer, bufsize, pos, \",\");\n      pos = safecatd(buffer, bufsize, pos, e->green.Y, 4);\n      pos = safecat(buffer, bufsize, pos, \",\");\n      pos = safecatd(buffer, bufsize, pos, e->green.Z, 4);\n      pos = safecat(buffer, bufsize, pos, \"),B(\");\n      pos = safecatd(buffer, bufsize, pos, e->blue.X, 4);\n      pos = safecat(buffer, bufsize, pos, \",\");\n      pos = safecatd(buffer, bufsize, pos, e->blue.Y, 4);\n      pos = safecat(buffer, bufsize, pos, \",\");\n      pos = safecatd(buffer, bufsize, pos, e->blue.Z, 4);\n      pos = safecat(buffer, bufsize, pos, \")\");\n if (encoding_gamma != 0)\n         pos = safecat(buffer, bufsize, pos, \")\");\n }\n\n if (encoding_gamma != 0)\n {\n      pos = safecat(buffer, bufsize, pos, \"^\");\n      pos = safecatd(buffer, bufsize, pos, encoding_gamma, 5);\n }\n\n \n    return pos;\n }\n", "target": 1, "idx": 187712}
{"func": "mm_sshpam_init_ctx(Authctxt *authctxt)\n{\n\tBuffer m;\n\tint success;\n \n \tdebug3(\"%s\", __func__);\n \tbuffer_init(&m);\n\tbuffer_put_cstring(&m, authctxt->user);\n \tmm_request_send(pmonitor->m_recvfd, MONITOR_REQ_PAM_INIT_CTX, &m);\n \tdebug3(\"%s: waiting for MONITOR_ANS_PAM_INIT_CTX\", __func__);\n \tmm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_PAM_INIT_CTX, &m);\n\tsuccess = buffer_get_int(&m);\n\tif (success == 0) {\n\t\tdebug3(\"%s: pam_init_ctx failed\", __func__);\n\t\tbuffer_free(&m);\n\t\treturn (NULL);\n\t}\n\tbuffer_free(&m);\n\treturn (authctxt);\n}\n", "target": 1, "idx": 179758}
{"func": "bgp_nlri_parse_vpnv4 (struct peer *peer, struct attr *attr, \n\t\t      struct bgp_nlri *packet)\n{\n  u_char *pnt;\n  u_char *lim;\n  struct prefix p;\n  int psize;\n  int prefixlen;\n  u_int16_t type;\n  struct rd_as rd_as;\n  struct rd_ip rd_ip;\n  struct prefix_rd prd;\n  u_char *tagpnt;\n\n  /* Check peer status. */\n  if (peer->status != Established)\n    return 0;\n  \n  /* Make prefix_rd */\n  prd.family = AF_UNSPEC;\n  prd.prefixlen = 64;\n\n   pnt = packet->nlri;\n   lim = pnt + packet->length;\n \n   for (; pnt < lim; pnt += psize)\n     {\n       /* Clear prefix structure. */\n\n \n       /* Fetch prefix length. */\n       prefixlen = *pnt++;\n      p.family = AF_INET;\n       psize = PSIZE (prefixlen);\n      if (prefixlen < 88)\n\t{\n\t  zlog_err (\"prefix length is less than 88: %d\", prefixlen);\n\t  return -1;\n\t}\n       /* Copyr label to prefix. */\n      tagpnt = pnt;;\n \n       /* Copy routing distinguisher to rd. */\n       memcpy (&prd.val, pnt + 3, 8);\n      else if (type == RD_TYPE_IP)\n\tzlog_info (\"prefix %ld:%s:%ld:%s/%d\", label, inet_ntoa (rd_ip.ip),\n\t\t   rd_ip.val, inet_ntoa (p.u.prefix4), p.prefixlen);\n#endif /* 0 */\n\n      if (pnt + psize > lim)\n\treturn -1;\n\n      if (attr)\n\tbgp_update (peer, &p, attr, AFI_IP, SAFI_MPLS_VPN,\n\t\t    ZEBRA_ROUTE_BGP, BGP_ROUTE_NORMAL, &prd, tagpnt, 0);\n      else\n \t  return -1;\n \t}\n \n      p.prefixlen = prefixlen - 88;\n      memcpy (&p.u.prefix, pnt + 11, psize - 11);\n \n #if 0\n       if (type == RD_TYPE_AS)\n}\n", "target": 1, "idx": 178361}
{"func": "void ieee80211_sta_expire(struct ieee80211_sub_if_data *sdata,\n\t\t\t  unsigned long exp_time)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sta_info *sta, *tmp;\n\n\tmutex_lock(&local->sta_mtx);\n\n\tlist_for_each_entry_safe(sta, tmp, &local->sta_list, list) {\n\t\tif (sdata != sta->sdata)\n\t\t\tcontinue;\n\n\t\tif (time_after(jiffies, sta->last_rx + exp_time)) {\n\t\t\tsta_dbg(sta->sdata, \"expiring inactive STA %pM\\n\",\n\t\t\t\tsta->sta.addr);\n\n\t\t\tif (ieee80211_vif_is_mesh(&sdata->vif) &&\n\t\t\t    test_sta_flag(sta, WLAN_STA_PS_STA))\n\t\t\t\tatomic_dec(&sdata->u.mesh.ps.num_sta_ps);\n\n\t\t\tWARN_ON(__sta_info_destroy(sta));\n\t\t}\n\t}\n\n\tmutex_unlock(&local->sta_mtx);\n}\n", "target": 0, "idx": 38577}
{"func": "int ipc_addid(struct ipc_ids *ids, struct kern_ipc_perm *new, int size)\n{\n\tkuid_t euid;\n\tkgid_t egid;\n\tint id;\n\tint next_id = ids->next_id;\n\n\tif (size > IPCMNI)\n\t\tsize = IPCMNI;\n\n\tif (ids->in_use >= size)\n\t\treturn -ENOSPC;\n\n\tidr_preload(GFP_KERNEL);\n\n\tspin_lock_init(&new->lock);\n\tnew->deleted = false;\n \trcu_read_lock();\n \tspin_lock(&new->lock);\n \n \tid = idr_alloc(&ids->ipcs_idr, new,\n \t\t       (next_id < 0) ? 0 : ipcid_to_idx(next_id), 0,\n \t\t       GFP_NOWAIT);\n\tidr_preload_end();\n\tif (id < 0) {\n\t\tspin_unlock(&new->lock);\n\t\trcu_read_unlock();\n\t\treturn id;\n\t}\n \n \tids->in_use++;\n \n\tcurrent_euid_egid(&euid, &egid);\n\tnew->cuid = new->uid = euid;\n\tnew->gid = new->cgid = egid;\n \tif (next_id < 0) {\n \t\tnew->seq = ids->seq++;\n \t\tif (ids->seq > IPCID_SEQ_MAX)\n\t\t\tids->seq = 0;\n\t} else {\n\t\tnew->seq = ipcid_to_seqx(next_id);\n\t\tids->next_id = -1;\n\t}\n\n\tnew->id = ipc_buildid(id, new->seq);\n\treturn id;\n}\n", "target": 1, "idx": 179752}
{"func": "gplotAddPlot(GPLOT       *gplot,\n             NUMA        *nax,\n             NUMA        *nay,\n              l_int32      plotstyle,\n              const char  *plottitle)\n {\nchar       buf[L_BUF_SIZE];\n char       emptystring[] = \"\";\n char      *datastr, *title;\n l_int32    n, i;\nl_float32  valx, valy, startx, delx;\nSARRAY    *sa;\n\n    PROCNAME(\"gplotAddPlot\");\n\n    if (!gplot)\n        return ERROR_INT(\"gplot not defined\", procName, 1);\n    if (!nay)\n        return ERROR_INT(\"nay not defined\", procName, 1);\n    if (plotstyle < 0 || plotstyle >= NUM_GPLOT_STYLES)\n        return ERROR_INT(\"invalid plotstyle\", procName, 1);\n\n    if ((n = numaGetCount(nay)) == 0)\n        return ERROR_INT(\"no points to plot\", procName, 1);\n    if (nax && (n != numaGetCount(nax)))\n        return ERROR_INT(\"nax and nay sizes differ\", procName, 1);\n    if (n == 1 && plotstyle == GPLOT_LINES) {\n        L_INFO(\"only 1 pt; changing style to points\\n\", procName);\n        plotstyle = GPLOT_POINTS;\n    }\n\n        /* Save plotstyle and plottitle */\n    numaGetParameters(nay, &startx, &delx);\n    numaAddNumber(gplot->plotstyles, plotstyle);\n    if (plottitle) {\n        title = stringNew(plottitle);\n        sarrayAddString(gplot->plottitles, title, L_INSERT);\n    } else {\n        sarrayAddString(gplot->plottitles, emptystring, L_COPY);\n    }\n \n         /* Generate and save data filename */\n     gplot->nplots++;\n    snprintf(buf, L_BUF_SIZE, \"%s.data.%d\", gplot->rootname, gplot->nplots);\n     sarrayAddString(gplot->datanames, buf, L_COPY);\n \n         /* Generate data and save as a string */\n    sa = sarrayCreate(n);\n    for (i = 0; i < n; i++) {\n        if (nax)\n            numaGetFValue(nax, i, &valx);\n         else\n             valx = startx + i * delx;\n         numaGetFValue(nay, i, &valy);\n        snprintf(buf, L_BUF_SIZE, \"%f %f\\n\", valx, valy);\n         sarrayAddString(sa, buf, L_COPY);\n     }\n     datastr = sarrayToString(sa, 0);\n    sarrayAddString(gplot->plotdata, datastr, L_INSERT);\n    sarrayDestroy(&sa);\n\n    return 0;\n}\n", "target": 1, "idx": 182495}
{"func": " void ServiceWorkerPaymentInstrument::OnPaymentAppInvoked(\n     mojom::PaymentHandlerResponsePtr response) {\n  DCHECK(delegate_);\n   if (delegate_ != nullptr) {\n     delegate_->OnInstrumentDetailsReady(response->method_name,\n                                         response->stringified_details);\n    delegate_ = nullptr;\n  }\n}\n", "target": 1, "idx": 186942}
{"func": "static int __rds_rdma_map(struct rds_sock *rs, struct rds_get_mr_args *args,\n\t\t\t\tu64 *cookie_ret, struct rds_mr **mr_ret)\n{\n\tstruct rds_mr *mr = NULL, *found;\n\tunsigned int nr_pages;\n\tstruct page **pages = NULL;\n\tstruct scatterlist *sg;\n\tvoid *trans_private;\n\tunsigned long flags;\n\trds_rdma_cookie_t cookie;\n\tunsigned int nents;\n \tlong i;\n \tint ret;\n \n\tif (rs->rs_bound_addr == 0) {\n \t\tret = -ENOTCONN; /* XXX not a great errno */\n \t\tgoto out;\n \t}\n\n\tif (!rs->rs_transport->get_mr) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tnr_pages = rds_pages_in_vec(&args->vec);\n\tif (nr_pages == 0) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* Restrict the size of mr irrespective of underlying transport\n\t * To account for unaligned mr regions, subtract one from nr_pages\n\t */\n\tif ((nr_pages - 1) > (RDS_MAX_MSG_SIZE >> PAGE_SHIFT)) {\n\t\tret = -EMSGSIZE;\n\t\tgoto out;\n\t}\n\n\trdsdebug(\"RDS: get_mr addr %llx len %llu nr_pages %u\\n\",\n\t\targs->vec.addr, args->vec.bytes, nr_pages);\n\n\t/* XXX clamp nr_pages to limit the size of this alloc? */\n\tpages = kcalloc(nr_pages, sizeof(struct page *), GFP_KERNEL);\n\tif (!pages) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmr = kzalloc(sizeof(struct rds_mr), GFP_KERNEL);\n\tif (!mr) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\trefcount_set(&mr->r_refcount, 1);\n\tRB_CLEAR_NODE(&mr->r_rb_node);\n\tmr->r_trans = rs->rs_transport;\n\tmr->r_sock = rs;\n\n\tif (args->flags & RDS_RDMA_USE_ONCE)\n\t\tmr->r_use_once = 1;\n\tif (args->flags & RDS_RDMA_INVALIDATE)\n\t\tmr->r_invalidate = 1;\n\tif (args->flags & RDS_RDMA_READWRITE)\n\t\tmr->r_write = 1;\n\n\t/*\n\t * Pin the pages that make up the user buffer and transfer the page\n\t * pointers to the mr's sg array.  We check to see if we've mapped\n\t * the whole region after transferring the partial page references\n\t * to the sg array so that we can have one page ref cleanup path.\n\t *\n\t * For now we have no flag that tells us whether the mapping is\n\t * r/o or r/w. We need to assume r/w, or we'll do a lot of RDMA to\n\t * the zero page.\n\t */\n\tret = rds_pin_pages(args->vec.addr, nr_pages, pages, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tnents = ret;\n\tsg = kcalloc(nents, sizeof(*sg), GFP_KERNEL);\n\tif (!sg) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tWARN_ON(!nents);\n\tsg_init_table(sg, nents);\n\n\t/* Stick all pages into the scatterlist */\n\tfor (i = 0 ; i < nents; i++)\n\t\tsg_set_page(&sg[i], pages[i], PAGE_SIZE, 0);\n\n\trdsdebug(\"RDS: trans_private nents is %u\\n\", nents);\n\n\t/* Obtain a transport specific MR. If this succeeds, the\n\t * s/g list is now owned by the MR.\n\t * Note that dma_map() implies that pending writes are\n\t * flushed to RAM, so no dma_sync is needed here. */\n\ttrans_private = rs->rs_transport->get_mr(sg, nents, rs,\n\t\t\t\t\t\t &mr->r_key);\n\n\tif (IS_ERR(trans_private)) {\n\t\tfor (i = 0 ; i < nents; i++)\n\t\t\tput_page(sg_page(&sg[i]));\n\t\tkfree(sg);\n\t\tret = PTR_ERR(trans_private);\n\t\tgoto out;\n\t}\n\n\tmr->r_trans_private = trans_private;\n\n\trdsdebug(\"RDS: get_mr put_user key is %x cookie_addr %p\\n\",\n\t       mr->r_key, (void *)(unsigned long) args->cookie_addr);\n\n\t/* The user may pass us an unaligned address, but we can only\n\t * map page aligned regions. So we keep the offset, and build\n\t * a 64bit cookie containing <R_Key, offset> and pass that\n\t * around. */\n\tcookie = rds_rdma_make_cookie(mr->r_key, args->vec.addr & ~PAGE_MASK);\n\tif (cookie_ret)\n\t\t*cookie_ret = cookie;\n\n\tif (args->cookie_addr && put_user(cookie, (u64 __user *)(unsigned long) args->cookie_addr)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\t/* Inserting the new MR into the rbtree bumps its\n\t * reference count. */\n\tspin_lock_irqsave(&rs->rs_rdma_lock, flags);\n\tfound = rds_mr_tree_walk(&rs->rs_rdma_keys, mr->r_key, mr);\n\tspin_unlock_irqrestore(&rs->rs_rdma_lock, flags);\n\n\tBUG_ON(found && found != mr);\n\n\trdsdebug(\"RDS: get_mr key is %x\\n\", mr->r_key);\n\tif (mr_ret) {\n\t\trefcount_inc(&mr->r_refcount);\n\t\t*mr_ret = mr;\n\t}\n\n\tret = 0;\nout:\n\tkfree(pages);\n\tif (mr)\n\t\trds_mr_put(mr);\n\treturn ret;\n}\n", "target": 1, "idx": 182481}
{"func": " php_http_url_t *php_http_url_parse(const char *str, size_t len, unsigned flags TSRMLS_DC)\n {\n\tsize_t maxlen = 3 * len;\n \tstruct parse_state *state = ecalloc(1, sizeof(*state) + maxlen);\n \n \tstate->end = str + len;\n\tstate->ptr = str;\n\tstate->flags = flags;\n\tstate->maxlen = maxlen;\n\tTSRMLS_SET_CTX(state->ts);\n\n\tif (!parse_scheme(state)) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Failed to parse URL scheme: '%s'\", state->ptr);\n\t\tefree(state);\n\t\treturn NULL;\n\t}\n\n\tif (!parse_hier(state)) {\n\t\tefree(state);\n\t\treturn NULL;\n\t}\n\n\tif (!parse_query(state)) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Failed to parse URL query: '%s'\", state->ptr);\n\t\tefree(state);\n\t\treturn NULL;\n\t}\n\n\tif (!parse_fragment(state)) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Failed to parse URL fragment: '%s'\", state->ptr);\n\t\tefree(state);\n\t\treturn NULL;\n\t}\n\n\treturn (php_http_url_t *) state;\n}\n", "target": 1, "idx": 182006}
{"func": "static int ocfs2_dio_get_block(struct inode *inode, sector_t iblock,\n \t\t\t       struct buffer_head *bh_result, int create)\n {\n \tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_write_ctxt *wc;\n\tstruct ocfs2_write_cluster_desc *desc = NULL;\n\tstruct ocfs2_dio_write_ctxt *dwc = NULL;\n\tstruct buffer_head *di_bh = NULL;\n\tu64 p_blkno;\n\tloff_t pos = iblock << inode->i_sb->s_blocksize_bits;\n\tunsigned len, total_len = bh_result->b_size;\n\tint ret = 0, first_get_block = 0;\n\n\tlen = osb->s_clustersize - (pos & (osb->s_clustersize - 1));\n\tlen = min(total_len, len);\n\n\tmlog(0, \"get block of %lu at %llu:%u req %u\\n\",\n\t\t\tinode->i_ino, pos, len, total_len);\n\n\t/*\n\t * Because we need to change file size in ocfs2_dio_end_io_write(), or\n\t * we may need to add it to orphan dir. So can not fall to fast path\n \t * while file size will be changed.\n \t */\n \tif (pos + total_len <= i_size_read(inode)) {\n\t\tdown_read(&oi->ip_alloc_sem);\n\t\t/* This is the fast path for re-write. */\n\t\tret = ocfs2_get_block(inode, iblock, bh_result, create);\n\t\tup_read(&oi->ip_alloc_sem);\n \n \t\tif (buffer_mapped(bh_result) &&\n \t\t    !buffer_new(bh_result) &&\n \t\t    ret == 0)\n\t\t\tgoto out;\n\n\t\t/* Clear state set by ocfs2_get_block. */\n\t\tbh_result->b_state = 0;\n\t}\n\n\tdwc = ocfs2_dio_alloc_write_ctx(bh_result, &first_get_block);\n\tif (unlikely(dwc == NULL)) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (ocfs2_clusters_for_bytes(inode->i_sb, pos + total_len) >\n\t    ocfs2_clusters_for_bytes(inode->i_sb, i_size_read(inode)) &&\n\t    !dwc->dw_orphaned) {\n\t\t/*\n\t\t * when we are going to alloc extents beyond file size, add the\n\t\t * inode to orphan dir, so we can recall those spaces when\n\t\t * system crashed during write.\n\t\t */\n\t\tret = ocfs2_add_inode_to_orphan(osb, inode);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tdwc->dw_orphaned = 1;\n\t}\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdown_write(&oi->ip_alloc_sem);\n\n\tif (first_get_block) {\n\t\tif (ocfs2_sparse_alloc(OCFS2_SB(inode->i_sb)))\n\t\t\tret = ocfs2_zero_tail(inode, di_bh, pos);\n\t\telse\n\t\t\tret = ocfs2_expand_nonsparse_inode(inode, di_bh, pos,\n\t\t\t\t\t\t\t   total_len, NULL);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tret = ocfs2_write_begin_nolock(inode->i_mapping, pos, len,\n\t\t\t\t       OCFS2_WRITE_DIRECT, NULL,\n\t\t\t\t       (void **)&wc, di_bh, NULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto unlock;\n\t}\n\n\tdesc = &wc->w_desc[0];\n\n\tp_blkno = ocfs2_clusters_to_blocks(inode->i_sb, desc->c_phys);\n\tBUG_ON(p_blkno == 0);\n\tp_blkno += iblock & (u64)(ocfs2_clusters_to_blocks(inode->i_sb, 1) - 1);\n\n\tmap_bh(bh_result, inode->i_sb, p_blkno);\n\tbh_result->b_size = len;\n\tif (desc->c_needs_zero)\n\t\tset_buffer_new(bh_result);\n\n\t/* May sleep in end_io. It should not happen in a irq context. So defer\n\t * it to dio work queue. */\n\tset_buffer_defer_completion(bh_result);\n\n\tif (!list_empty(&wc->w_unwritten_list)) {\n\t\tstruct ocfs2_unwritten_extent *ue = NULL;\n\n\t\tue = list_first_entry(&wc->w_unwritten_list,\n\t\t\t\t      struct ocfs2_unwritten_extent,\n\t\t\t\t      ue_node);\n\t\tBUG_ON(ue->ue_cpos != desc->c_cpos);\n\t\t/* The physical address may be 0, fill it. */\n\t\tue->ue_phys = desc->c_phys;\n\n\t\tlist_splice_tail_init(&wc->w_unwritten_list, &dwc->dw_zero_list);\n\t\tdwc->dw_zero_count++;\n\t}\n\n\tret = ocfs2_write_end_nolock(inode->i_mapping, pos, len, len, wc);\n\tBUG_ON(ret != len);\n\tret = 0;\nunlock:\n\tup_write(&oi->ip_alloc_sem);\n\tocfs2_inode_unlock(inode, 1);\n\tbrelse(di_bh);\nout:\n\tif (ret < 0)\n\t\tret = -EIO;\n\treturn ret;\n}\n", "target": 1, "idx": 182568}
{"func": "static UINT drdynvc_order_recv(drdynvcPlugin* drdynvc, wStream* s)\n{\n\tint value;\n \tint Cmd;\n \tint Sp;\n \tint cbChId;\n \tStream_Read_UINT8(s, value);\n \tCmd = (value & 0xf0) >> 4;\n \tSp = (value & 0x0c) >> 2;\n\tcbChId = (value & 0x03) >> 0;\n\tWLog_Print(drdynvc->log, WLOG_DEBUG, \"order_recv: Cmd=0x%x, Sp=%d cbChId=%d\", Cmd, Sp, cbChId);\n\n\tswitch (Cmd)\n\t{\n\t\tcase CAPABILITY_REQUEST_PDU:\n\t\t\treturn drdynvc_process_capability_request(drdynvc, Sp, cbChId, s);\n\n\t\tcase CREATE_REQUEST_PDU:\n\t\t\treturn drdynvc_process_create_request(drdynvc, Sp, cbChId, s);\n\n\t\tcase DATA_FIRST_PDU:\n\t\t\treturn drdynvc_process_data_first(drdynvc, Sp, cbChId, s);\n\n\t\tcase DATA_PDU:\n\t\t\treturn drdynvc_process_data(drdynvc, Sp, cbChId, s);\n\n\t\tcase CLOSE_REQUEST_PDU:\n\t\t\treturn drdynvc_process_close_request(drdynvc, Sp, cbChId, s);\n\n\t\tdefault:\n\t\t\tWLog_Print(drdynvc->log, WLOG_ERROR, \"unknown drdynvc cmd 0x%x\", Cmd);\n\t\t\treturn ERROR_INTERNAL_ERROR;\n\t}\n}\n", "target": 1, "idx": 182105}
{"func": "raptor_rdfxml_comment_handler(void *user_data, raptor_xml_element* xml_element,\n                              const unsigned char *s)\n{\n  raptor_parser* rdf_parser = (raptor_parser*)user_data;\n  raptor_rdfxml_parser* rdf_xml_parser;\n  raptor_rdfxml_element* element;\n\n  if(rdf_parser->failed || !xml_element)\n    return;\n\n  rdf_xml_parser = (raptor_rdfxml_parser*)rdf_parser->context;\n  element = rdf_xml_parser->current_element;\n\n  if(element) {\n    if(element->child_content_type == RAPTOR_RDFXML_ELEMENT_CONTENT_TYPE_XML_LITERAL)\n      raptor_xml_writer_comment(rdf_xml_parser->xml_writer, s);\n  }\n  \n\n#ifdef RAPTOR_DEBUG_VERBOSE\n  RAPTOR_DEBUG2(\"XML Comment '%s'\\n\", s);\n#endif\n}\n", "target": 0, "idx": 22005}
{"func": "void V8TestObject::DoubleAttributeAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), \"Blink_TestObject_doubleAttribute_Getter\");\n\n  test_object_v8_internal::DoubleAttributeAttributeGetter(info);\n}\n", "target": 0, "idx": 147362}
{"func": "Init_ossl_cipher(void)\n{\n#if 0\n    mOSSL = rb_define_module(\"OpenSSL\");\n    eOSSLError = rb_define_class_under(mOSSL, \"OpenSSLError\", rb_eStandardError);\n#endif\n\n    /* Document-class: OpenSSL::Cipher\n     *\n     * Provides symmetric algorithms for encryption and decryption. The\n     * algorithms that are available depend on the particular version\n     * of OpenSSL that is installed.\n     *\n     * === Listing all supported algorithms\n     *\n     * A list of supported algorithms can be obtained by\n     *\n     *   puts OpenSSL::Cipher.ciphers\n     *\n     * === Instantiating a Cipher\n     *\n     * There are several ways to create a Cipher instance. Generally, a\n     * Cipher algorithm is categorized by its name, the key length in bits\n     * and the cipher mode to be used. The most generic way to create a\n     * Cipher is the following\n     *\n     *   cipher = OpenSSL::Cipher.new('<name>-<key length>-<mode>')\n     *\n     * That is, a string consisting of the hyphenated concatenation of the\n     * individual components name, key length and mode. Either all uppercase\n     * or all lowercase strings may be used, for example:\n     *\n     *  cipher = OpenSSL::Cipher.new('AES-128-CBC')\n     *\n     * For each algorithm supported, there is a class defined under the\n     * Cipher class that goes by the name of the cipher, e.g. to obtain an\n     * instance of AES, you could also use\n     *\n     *   # these are equivalent\n     *   cipher = OpenSSL::Cipher::AES.new(128, :CBC)\n     *   cipher = OpenSSL::Cipher::AES.new(128, 'CBC')\n     *   cipher = OpenSSL::Cipher::AES.new('128-CBC')\n     *\n     * Finally, due to its wide-spread use, there are also extra classes\n     * defined for the different key sizes of AES\n     *\n     *   cipher = OpenSSL::Cipher::AES128.new(:CBC)\n     *   cipher = OpenSSL::Cipher::AES192.new(:CBC)\n     *   cipher = OpenSSL::Cipher::AES256.new(:CBC)\n     *\n     * === Choosing either encryption or decryption mode\n     *\n     * Encryption and decryption are often very similar operations for\n     * symmetric algorithms, this is reflected by not having to choose\n     * different classes for either operation, both can be done using the\n     * same class. Still, after obtaining a Cipher instance, we need to\n     * tell the instance what it is that we intend to do with it, so we\n     * need to call either\n     *\n     *   cipher.encrypt\n     *\n     * or\n     *\n     *   cipher.decrypt\n     *\n     * on the Cipher instance. This should be the first call after creating\n     * the instance, otherwise configuration that has already been set could\n     * get lost in the process.\n     *\n     * === Choosing a key\n     *\n     * Symmetric encryption requires a key that is the same for the encrypting\n     * and for the decrypting party and after initial key establishment should\n     * be kept as private information. There are a lot of ways to create\n     * insecure keys, the most notable is to simply take a password as the key\n     * without processing the password further. A simple and secure way to\n     * create a key for a particular Cipher is\n     *\n     *  cipher = OpenSSL::AES256.new(:CFB)\n     *  cipher.encrypt\n     *  key = cipher.random_key # also sets the generated key on the Cipher\n     *\n     * If you absolutely need to use passwords as encryption keys, you\n     * should use Password-Based Key Derivation Function 2 (PBKDF2) by\n     * generating the key with the help of the functionality provided by\n     * OpenSSL::PKCS5.pbkdf2_hmac_sha1 or OpenSSL::PKCS5.pbkdf2_hmac.\n     *\n     * Although there is Cipher#pkcs5_keyivgen, its use is deprecated and\n     * it should only be used in legacy applications because it does not use\n     * the newer PKCS#5 v2 algorithms.\n     *\n     * === Choosing an IV\n     *\n     * The cipher modes CBC, CFB, OFB and CTR all need an \"initialization\n     * vector\", or short, IV. ECB mode is the only mode that does not require\n     * an IV, but there is almost no legitimate use case for this mode\n     * because of the fact that it does not sufficiently hide plaintext\n     * patterns. Therefore\n     *\n     * <b>You should never use ECB mode unless you are absolutely sure that\n     * you absolutely need it</b>\n     *\n     * Because of this, you will end up with a mode that explicitly requires\n     * an IV in any case. Note that for backwards compatibility reasons,\n     * setting an IV is not explicitly mandated by the Cipher API. If not\n     * set, OpenSSL itself defaults to an all-zeroes IV (\"\\\\0\", not the\n     * character). Although the IV can be seen as public information, i.e.\n     * it may be transmitted in public once generated, it should still stay\n     * unpredictable to prevent certain kinds of attacks. Therefore, ideally\n     *\n     * <b>Always create a secure random IV for every encryption of your\n     * Cipher</b>\n     *\n     * A new, random IV should be created for every encryption of data. Think\n     * of the IV as a nonce (number used once) - it's public but random and\n     * unpredictable. A secure random IV can be created as follows\n     *\n     *   cipher = ...\n     *   cipher.encrypt\n     *   key = cipher.random_key\n     *   iv = cipher.random_iv # also sets the generated IV on the Cipher\n     *\n     * Although the key is generally a random value, too, it is a bad choice\n     * as an IV. There are elaborate ways how an attacker can take advantage\n     * of such an IV. As a general rule of thumb, exposing the key directly\n     * or indirectly should be avoided at all cost and exceptions only be\n     * made with good reason.\n     *\n     * === Calling Cipher#final\n     *\n     * ECB (which should not be used) and CBC are both block-based modes.\n     * This means that unlike for the other streaming-based modes, they\n     * operate on fixed-size blocks of data, and therefore they require a\n     * \"finalization\" step to produce or correctly decrypt the last block of\n     * data by appropriately handling some form of padding. Therefore it is\n     * essential to add the output of OpenSSL::Cipher#final to your\n     * encryption/decryption buffer or you will end up with decryption errors\n     * or truncated data.\n     *\n     * Although this is not really necessary for streaming-mode ciphers, it is\n     * still recommended to apply the same pattern of adding the output of\n     * Cipher#final there as well - it also enables you to switch between\n     * modes more easily in the future.\n     *\n     * === Encrypting and decrypting some data\n     *\n     *   data = \"Very, very confidential data\"\n     *\n     *   cipher = OpenSSL::Cipher::AES.new(128, :CBC)\n     *   cipher.encrypt\n     *   key = cipher.random_key\n     *   iv = cipher.random_iv\n     *\n     *   encrypted = cipher.update(data) + cipher.final\n     *   ...\n     *   decipher = OpenSSL::Cipher::AES.new(128, :CBC)\n     *   decipher.decrypt\n     *   decipher.key = key\n     *   decipher.iv = iv\n     *\n     *   plain = decipher.update(encrypted) + decipher.final\n     *\n     *   puts data == plain #=> true\n     *\n     * === Authenticated Encryption and Associated Data (AEAD)\n     *\n     * If the OpenSSL version used supports it, an Authenticated Encryption\n     * mode (such as GCM or CCM) should always be preferred over any\n     * unauthenticated mode. Currently, OpenSSL supports AE only in combination\n     * with Associated Data (AEAD) where additional associated data is included\n     * in the encryption process to compute a tag at the end of the encryption.\n     * This tag will also be used in the decryption process and by verifying\n     * its validity, the authenticity of a given ciphertext is established.\n     *\n     * This is superior to unauthenticated modes in that it allows to detect\n     * if somebody effectively changed the ciphertext after it had been\n     * encrypted. This prevents malicious modifications of the ciphertext that\n     * could otherwise be exploited to modify ciphertexts in ways beneficial to\n     * potential attackers.\n     *\n     * An associated data is used where there is additional information, such as\n     * headers or some metadata, that must be also authenticated but not\n     * necessarily need to be encrypted. If no associated data is needed for\n     * encryption and later decryption, the OpenSSL library still requires a\n     * value to be set - \"\" may be used in case none is available.\n     *\n     * An example using the GCM (Galois/Counter Mode). You have 16 bytes +key+,\n     * 12 bytes (96 bits) +nonce+ and the associated data +auth_data+. Be sure\n     * not to reuse the +key+ and +nonce+ pair. Reusing an nonce ruins the\n     * security gurantees of GCM mode.\n     *\n     *   cipher = OpenSSL::Cipher::AES.new(128, :GCM).encrypt\n     *   cipher.key = key\n     *   cipher.iv = nonce\n     *   cipher.auth_data = auth_data\n     *\n     *   encrypted = cipher.update(data) + cipher.final\n     *   tag = cipher.auth_tag # produces 16 bytes tag by default\n     *\n     * Now you are the receiver. You know the +key+ and have received +nonce+,\n     * +auth_data+, +encrypted+ and +tag+ through an untrusted network. Note\n     * that GCM accepts an arbitrary length tag between 1 and 16 bytes. You may\n     * additionally need to check that the received tag has the correct length,\n     * or you allow attackers to forge a valid single byte tag for the tampered\n     * ciphertext with a probability of 1/256.\n     *\n     *   raise \"tag is truncated!\" unless tag.bytesize == 16\n     *   decipher = OpenSSL::Cipher::AES.new(128, :GCM).decrypt\n     *   decipher.key = key\n     *   decipher.iv = nonce\n     *   decipher.auth_tag = tag\n     *   decipher.auth_data = auth_data\n     *\n     *   decrypted = decipher.update(encrypted) + decipher.final\n     *\n     *   puts data == decrypted #=> true\n     */\n    cCipher = rb_define_class_under(mOSSL, \"Cipher\", rb_cObject);\n    eCipherError = rb_define_class_under(cCipher, \"CipherError\", eOSSLError);\n\n    rb_define_alloc_func(cCipher, ossl_cipher_alloc);\n    rb_define_copy_func(cCipher, ossl_cipher_copy);\n    rb_define_module_function(cCipher, \"ciphers\", ossl_s_ciphers, 0);\n    rb_define_method(cCipher, \"initialize\", ossl_cipher_initialize, 1);\n    rb_define_method(cCipher, \"reset\", ossl_cipher_reset, 0);\n    rb_define_method(cCipher, \"encrypt\", ossl_cipher_encrypt, -1);\n    rb_define_method(cCipher, \"decrypt\", ossl_cipher_decrypt, -1);\n    rb_define_method(cCipher, \"pkcs5_keyivgen\", ossl_cipher_pkcs5_keyivgen, -1);\n    rb_define_method(cCipher, \"update\", ossl_cipher_update, -1);\n    rb_define_method(cCipher, \"final\", ossl_cipher_final, 0);\n    rb_define_method(cCipher, \"name\", ossl_cipher_name, 0);\n    rb_define_method(cCipher, \"key=\", ossl_cipher_set_key, 1);\n    rb_define_method(cCipher, \"auth_data=\", ossl_cipher_set_auth_data, 1);\n    rb_define_method(cCipher, \"auth_tag=\", ossl_cipher_set_auth_tag, 1);\n    rb_define_method(cCipher, \"auth_tag\", ossl_cipher_get_auth_tag, -1);\n    rb_define_method(cCipher, \"auth_tag_len=\", ossl_cipher_set_auth_tag_len, 1);\n    rb_define_method(cCipher, \"authenticated?\", ossl_cipher_is_authenticated, 0);\n    rb_define_method(cCipher, \"key_len=\", ossl_cipher_set_key_length, 1);\n    rb_define_method(cCipher, \"key_len\", ossl_cipher_key_length, 0);\n    rb_define_method(cCipher, \"iv=\", ossl_cipher_set_iv, 1);\n    rb_define_method(cCipher, \"iv_len=\", ossl_cipher_set_iv_length, 1);\n    rb_define_method(cCipher, \"iv_len\", ossl_cipher_iv_length, 0);\n    rb_define_method(cCipher, \"block_size\", ossl_cipher_block_size, 0);\n     rb_define_method(cCipher, \"padding=\", ossl_cipher_set_padding, 1);\n \n     id_auth_tag_len = rb_intern_const(\"auth_tag_len\");\n }\n", "target": 1, "idx": 181950}
{"func": "struct sk_buff *sock_wmalloc(struct sock *sk, unsigned long size, int force,\n\t\t\t     gfp_t priority)\n{\n\tif (force || atomic_read(&sk->sk_wmem_alloc) < sk->sk_sndbuf) {\n\t\tstruct sk_buff *skb = alloc_skb(size, priority);\n\t\tif (skb) {\n\t\t\tskb_set_owner_w(skb, sk);\n\t\t\treturn skb;\n\t\t}\n\t}\n\treturn NULL;\n}\n", "target": 0, "idx": 20208}
{"func": "status_t OMXNodeInstance::getConfig(\n\n         OMX_INDEXTYPE index, void *params, size_t /* size */) {\n     Mutex::Autolock autoLock(mLock);\n \n     OMX_ERRORTYPE err = OMX_GetConfig(mHandle, index, params);\n     OMX_INDEXEXTTYPE extIndex = (OMX_INDEXEXTTYPE)index;\n if (err != OMX_ErrorNoMore) {\n        CLOG_IF_ERROR(getConfig, err, \"%s(%#x)\", asString(extIndex), index);\n }\n return StatusFromOMXError(err);\n}\n", "target": 1, "idx": 188156}
{"func": "void RenderFrameDevToolsAgentHost::InspectElement(\n    DevToolsSession* session,\n    int x,\n    int y) {\n\n  if (frame_tree_node_) {\n    if (auto* main_view =\n            frame_tree_node_->frame_tree()->GetMainFrame()->GetView()) {\n      gfx::Point transformed_point = gfx::ToRoundedPoint(\n          main_view->TransformRootPointToViewCoordSpace(gfx::PointF(x, y)));\n      x = transformed_point.x();\n      y = transformed_point.y();\n    }\n  }\n\n  session->InspectElement(gfx::Point(x, y));\n}\n", "target": 0, "idx": 161506}
{"func": "  static void CloudPrintInfoCallback(bool enabled,\n                                     const std::string& email,\n                                     const std::string& proxy_id) {\n    QuitMessageLoop();\n   }\n", "target": 1, "idx": 185961}
{"func": "static int rt_fill_info(struct net *net,  __be32 dst, __be32 src,\n\t\t\tstruct flowi4 *fl4, struct sk_buff *skb, u32 portid,\n\t\t\tu32 seq, int event, int nowait, unsigned int flags)\n{\n\tstruct rtable *rt = skb_rtable(skb);\n\tstruct rtmsg *r;\n\tstruct nlmsghdr *nlh;\n\tunsigned long expires = 0;\n\tu32 error;\n\tu32 metrics[RTAX_MAX];\n\n\tnlh = nlmsg_put(skb, portid, seq, event, sizeof(*r), flags);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tr = nlmsg_data(nlh);\n\tr->rtm_family\t = AF_INET;\n\tr->rtm_dst_len\t= 32;\n\tr->rtm_src_len\t= 0;\n\tr->rtm_tos\t= fl4->flowi4_tos;\n\tr->rtm_table\t= RT_TABLE_MAIN;\n\tif (nla_put_u32(skb, RTA_TABLE, RT_TABLE_MAIN))\n\t\tgoto nla_put_failure;\n\tr->rtm_type\t= rt->rt_type;\n\tr->rtm_scope\t= RT_SCOPE_UNIVERSE;\n\tr->rtm_protocol = RTPROT_UNSPEC;\n \tr->rtm_flags\t= (rt->rt_flags & ~0xFFFF) | RTM_F_CLONED;\n \tif (rt->rt_flags & RTCF_NOTIFY)\n \t\tr->rtm_flags |= RTM_F_NOTIFY;\n \n \tif (nla_put_be32(skb, RTA_DST, dst))\n \t\tgoto nla_put_failure;\n\tif (src) {\n\t\tr->rtm_src_len = 32;\n\t\tif (nla_put_be32(skb, RTA_SRC, src))\n\t\t\tgoto nla_put_failure;\n\t}\n\tif (rt->dst.dev &&\n\t    nla_put_u32(skb, RTA_OIF, rt->dst.dev->ifindex))\n\t\tgoto nla_put_failure;\n#ifdef CONFIG_IP_ROUTE_CLASSID\n\tif (rt->dst.tclassid &&\n\t    nla_put_u32(skb, RTA_FLOW, rt->dst.tclassid))\n\t\tgoto nla_put_failure;\n#endif\n\tif (!rt_is_input_route(rt) &&\n\t    fl4->saddr != src) {\n\t\tif (nla_put_be32(skb, RTA_PREFSRC, fl4->saddr))\n\t\t\tgoto nla_put_failure;\n\t}\n\tif (rt->rt_uses_gateway &&\n\t    nla_put_be32(skb, RTA_GATEWAY, rt->rt_gateway))\n\t\tgoto nla_put_failure;\n\n\texpires = rt->dst.expires;\n\tif (expires) {\n\t\tunsigned long now = jiffies;\n\n\t\tif (time_before(now, expires))\n\t\t\texpires -= now;\n\t\telse\n\t\t\texpires = 0;\n\t}\n\n\tmemcpy(metrics, dst_metrics_ptr(&rt->dst), sizeof(metrics));\n\tif (rt->rt_pmtu && expires)\n\t\tmetrics[RTAX_MTU - 1] = rt->rt_pmtu;\n\tif (rtnetlink_put_metrics(skb, metrics) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (fl4->flowi4_mark &&\n\t    nla_put_u32(skb, RTA_MARK, fl4->flowi4_mark))\n\t\tgoto nla_put_failure;\n\n\terror = rt->dst.error;\n\n\tif (rt_is_input_route(rt)) {\n#ifdef CONFIG_IP_MROUTE\n\t\tif (ipv4_is_multicast(dst) && !ipv4_is_local_multicast(dst) &&\n\t\t    IPV4_DEVCONF_ALL(net, MC_FORWARDING)) {\n\t\t\tint err = ipmr_get_route(net, skb,\n\t\t\t\t\t\t fl4->saddr, fl4->daddr,\n\t\t\t\t\t\t r, nowait);\n\t\t\tif (err <= 0) {\n\t\t\t\tif (!nowait) {\n\t\t\t\t\tif (err == 0)\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\tgoto nla_put_failure;\n\t\t\t\t} else {\n\t\t\t\t\tif (err == -EMSGSIZE)\n\t\t\t\t\t\tgoto nla_put_failure;\n\t\t\t\t\terror = err;\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n#endif\n\t\t\tif (nla_put_u32(skb, RTA_IIF, skb->dev->ifindex))\n\t\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (rtnl_put_cacheinfo(skb, &rt->dst, 0, expires, error) < 0)\n\t\tgoto nla_put_failure;\n\n\treturn nlmsg_end(skb, nlh);\n\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n", "target": 1, "idx": 179871}
{"func": "bool GpuProcessPolicy::PreSandboxHook() {\n  const bool chromeos_arm_gpu = IsChromeOS() && IsArchitectureArm();\n  DCHECK(!chromeos_arm_gpu);\n\n  DCHECK(!broker_process());\n  InitGpuBrokerProcess(\n      GpuBrokerProcessPolicy::Create,\n      std::vector<BrokerFilePermission>());  // No extra files in whitelist.\n\n  if (IsArchitectureX86_64() || IsArchitectureI386()) {\n     if (IsAcceleratedVaapiVideoEncodeEnabled() ||\n         IsAcceleratedVideoDecodeEnabled()) {\n       const char* I965DrvVideoPath = NULL;\n      const char* I965HybridDrvVideoPath = NULL;\n \n       if (IsArchitectureX86_64()) {\n         I965DrvVideoPath = \"/usr/lib64/va/drivers/i965_drv_video.so\";\n        I965HybridDrvVideoPath = \"/usr/lib64/va/drivers/hybrid_drv_video.so\";\n       } else if (IsArchitectureI386()) {\n         I965DrvVideoPath = \"/usr/lib/va/drivers/i965_drv_video.so\";\n       }\n \n       dlopen(I965DrvVideoPath, RTLD_NOW|RTLD_GLOBAL|RTLD_NODELETE);\n      if (I965HybridDrvVideoPath)\n        dlopen(I965HybridDrvVideoPath, RTLD_NOW|RTLD_GLOBAL|RTLD_NODELETE);\n       dlopen(\"libva.so.1\", RTLD_NOW|RTLD_GLOBAL|RTLD_NODELETE);\n #if defined(USE_OZONE)\n       dlopen(\"libva-drm.so.1\", RTLD_NOW|RTLD_GLOBAL|RTLD_NODELETE);\n#elif defined(USE_X11)\n      dlopen(\"libva-x11.so.1\", RTLD_NOW|RTLD_GLOBAL|RTLD_NODELETE);\n#endif\n    }\n  }\n\n  return true;\n}\n", "target": 1, "idx": 183528}
{"func": "WORD32 ih264d_parse_decode_slice(UWORD8 u1_is_idr_slice,\n                                 UWORD8 u1_nal_ref_idc,\n dec_struct_t *ps_dec /* Decoder parameters */\n )\n{\n dec_bit_stream_t * ps_bitstrm = ps_dec->ps_bitstrm;\n dec_pic_params_t *ps_pps;\n dec_seq_params_t *ps_seq;\n dec_slice_params_t *ps_cur_slice = ps_dec->ps_cur_slice;\n pocstruct_t s_tmp_poc;\n    WORD32 i_delta_poc[2];\n    WORD32 i4_poc = 0;\n    UWORD16 u2_first_mb_in_slice, u2_frame_num;\n    UWORD8 u1_field_pic_flag, u1_redundant_pic_cnt = 0, u1_slice_type;\n    UWORD32 u4_idr_pic_id = 0;\n    UWORD8 u1_bottom_field_flag, u1_pic_order_cnt_type;\n\n    UWORD8 u1_nal_unit_type;\n    UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;\n    UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;\n    WORD8 i1_is_end_of_poc;\n\n    WORD32 ret, end_of_frame;\n    WORD32 prev_slice_err, num_mb_skipped;\n    UWORD8 u1_mbaff;\n pocstruct_t *ps_cur_poc;\n\n    UWORD32 u4_temp;\n    WORD32 i_temp;\n    UWORD32 u4_call_end_of_pic = 0;\n\n /* read FirstMbInSlice  and slice type*/\n    ps_dec->ps_dpb_cmds->u1_dpb_commands_read_slc = 0;\n    u2_first_mb_in_slice = ih264d_uev(pu4_bitstrm_ofst,\n                                     pu4_bitstrm_buf);\n if(u2_first_mb_in_slice\n > (ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs))\n {\n\n return ERROR_CORRUPTED_SLICE;\n }\n\n /*we currently don not support ASO*/\n if(((u2_first_mb_in_slice << ps_cur_slice->u1_mbaff_frame_flag)\n <= ps_dec->u2_cur_mb_addr) && (ps_dec->u4_first_slice_in_pic == 0))\n {\n return ERROR_CORRUPTED_SLICE;\n }\n\n    COPYTHECONTEXT(\"SH: first_mb_in_slice\",u2_first_mb_in_slice);\n\n    u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);\n\n if(u4_temp > 9)\n return ERROR_INV_SLC_TYPE_T;\n\n    u1_slice_type = u4_temp;\n    COPYTHECONTEXT(\"SH: slice_type\",(u1_slice_type));\n    ps_dec->u1_sl_typ_5_9 = 0;\n /* Find Out the Slice Type is 5 to 9 or not then Set the Flag   */\n /* u1_sl_typ_5_9 = 1 .Which tells that all the slices in the Pic*/\n /* will be of same type of current                            */\n if(u1_slice_type > 4)\n {\n        u1_slice_type -= 5;\n        ps_dec->u1_sl_typ_5_9 = 1;\n }\n\n {\n        UWORD32 skip;\n\n if((ps_dec->i4_app_skip_mode == IVD_SKIP_PB)\n || (ps_dec->i4_dec_skip_mode == IVD_SKIP_PB))\n {\n            UWORD32 u4_bit_stream_offset = 0;\n\n if(ps_dec->u1_nal_unit_type == IDR_SLICE_NAL)\n {\n                skip = 0;\n\n                ps_dec->i4_dec_skip_mode = IVD_SKIP_NONE;\n }\n else if((I_SLICE == u1_slice_type)\n && (1 >= ps_dec->ps_cur_sps->u1_num_ref_frames))\n {\n                skip = 0;\n\n                ps_dec->i4_dec_skip_mode = IVD_SKIP_NONE;\n }\n else\n {\n                skip = 1;\n }\n\n /* If one frame worth of data is already skipped, do not skip the next one */\n if((0 == u2_first_mb_in_slice) && (1 == ps_dec->u4_prev_nal_skipped))\n {\n                skip = 0;\n }\n\n if(skip)\n {\n                ps_dec->u4_prev_nal_skipped = 1;\n                ps_dec->i4_dec_skip_mode = IVD_SKIP_PB;\n return 0;\n }\n else\n {\n /* If the previous NAL was skipped, then\n                 do not process that buffer in this call.\n                 Return to app and process it in the next call.\n                 This is necessary to handle cases where I/IDR is not complete in\n                 the current buffer and application intends to fill the remaining part of the bitstream\n                 later. This ensures we process only frame worth of data in every call */\n if(1 == ps_dec->u4_prev_nal_skipped)\n {\n                    ps_dec->u4_return_to_app = 1;\n return 0;\n }\n }\n }\n\n }\n\n    u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);\n if(u4_temp & MASK_ERR_PIC_SET_ID)\n return ERROR_INV_SLICE_HDR_T;\n /* discard slice if pic param is invalid */\n    COPYTHECONTEXT(\"SH: pic_parameter_set_id\", u4_temp);\n    ps_pps = &ps_dec->ps_pps[u4_temp];\n if(FALSE == ps_pps->u1_is_valid)\n {\n return ERROR_INV_SLICE_HDR_T;\n }\n    ps_seq = ps_pps->ps_sps;\n if(!ps_seq)\n return ERROR_INV_SLICE_HDR_T;\n if(FALSE == ps_seq->u1_is_valid)\n return ERROR_INV_SLICE_HDR_T;\n\n /* Get the frame num */\n    u2_frame_num = ih264d_get_bits_h264(ps_bitstrm,\n                                         ps_seq->u1_bits_in_frm_num);\n\n \n     COPYTHECONTEXT(\"SH: frame_num\", u2_frame_num);\n \n     /* Get the field related flags  */\n     if(!ps_seq->u1_frame_mbs_only_flag)\n     {\n\n        u1_field_pic_flag = ih264d_get_bit_h264(ps_bitstrm);\n        COPYTHECONTEXT(\"SH: field_pic_flag\", u1_field_pic_flag);\n        u1_bottom_field_flag = 0;\n\n if(u1_field_pic_flag)\n {\n            ps_dec->pu1_inv_scan = (UWORD8 *)gau1_ih264d_inv_scan_fld;\n            u1_bottom_field_flag = ih264d_get_bit_h264(ps_bitstrm);\n            COPYTHECONTEXT(\"SH: bottom_field_flag\", u1_bottom_field_flag);\n\n }\n else\n {\n            ps_dec->pu1_inv_scan = (UWORD8 *)gau1_ih264d_inv_scan;\n }\n }\n else\n {\n        u1_field_pic_flag = 0;\n        u1_bottom_field_flag = 0;\n\n        ps_dec->pu1_inv_scan = (UWORD8 *)gau1_ih264d_inv_scan;\n }\n\n    u1_nal_unit_type = SLICE_NAL;\n if(u1_is_idr_slice)\n {\n if(0 == u1_field_pic_flag)\n {\n            ps_dec->u1_top_bottom_decoded = TOP_FIELD_ONLY | BOT_FIELD_ONLY;\n }\n        u1_nal_unit_type = IDR_SLICE_NAL;\n        u4_idr_pic_id = ih264d_uev(pu4_bitstrm_ofst,\n                                   pu4_bitstrm_buf);\n if(u4_idr_pic_id > 65535)\n return ERROR_INV_SLICE_HDR_T;\n        COPYTHECONTEXT(\"SH:  \", u4_idr_pic_id);\n }\n\n /* read delta pic order count information*/\n    i_delta_poc[0] = i_delta_poc[1] = 0;\n    s_tmp_poc.i4_pic_order_cnt_lsb = 0;\n    s_tmp_poc.i4_delta_pic_order_cnt_bottom = 0;\n    u1_pic_order_cnt_type = ps_seq->u1_pic_order_cnt_type;\n if(u1_pic_order_cnt_type == 0)\n {\n        i_temp = ih264d_get_bits_h264(\n                        ps_bitstrm,\n                        ps_seq->u1_log2_max_pic_order_cnt_lsb_minus);\n if(i_temp < 0 || i_temp >= ps_seq->i4_max_pic_order_cntLsb)\n return ERROR_INV_SLICE_HDR_T;\n        s_tmp_poc.i4_pic_order_cnt_lsb = i_temp;\n        COPYTHECONTEXT(\"SH: pic_order_cnt_lsb\", s_tmp_poc.i4_pic_order_cnt_lsb);\n\n if((ps_pps->u1_pic_order_present_flag == 1) && (!u1_field_pic_flag))\n {\n            s_tmp_poc.i4_delta_pic_order_cnt_bottom = ih264d_sev(\n                            pu4_bitstrm_ofst, pu4_bitstrm_buf);\n            COPYTHECONTEXT(\"SH: delta_pic_order_cnt_bottom\",\n                            s_tmp_poc.i4_delta_pic_order_cnt_bottom);\n }\n }\n\n    s_tmp_poc.i4_delta_pic_order_cnt[0] = 0;\n    s_tmp_poc.i4_delta_pic_order_cnt[1] = 0;\n if(u1_pic_order_cnt_type == 1\n && (!ps_seq->u1_delta_pic_order_always_zero_flag))\n {\n        s_tmp_poc.i4_delta_pic_order_cnt[0] = ih264d_sev(pu4_bitstrm_ofst,\n                                                         pu4_bitstrm_buf);\n        COPYTHECONTEXT(\"SH: delta_pic_order_cnt[0]\",\n                        s_tmp_poc.i4_delta_pic_order_cnt[0]);\n\n if(ps_pps->u1_pic_order_present_flag && !u1_field_pic_flag)\n {\n            s_tmp_poc.i4_delta_pic_order_cnt[1] = ih264d_sev(\n                            pu4_bitstrm_ofst, pu4_bitstrm_buf);\n            COPYTHECONTEXT(\"SH: delta_pic_order_cnt[1]\",\n                            s_tmp_poc.i4_delta_pic_order_cnt[1]);\n }\n }\n\n if(ps_pps->u1_redundant_pic_cnt_present_flag)\n {\n        u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);\n if(u4_temp > MAX_REDUNDANT_PIC_CNT)\n return ERROR_INV_SLICE_HDR_T;\n        u1_redundant_pic_cnt = u4_temp;\n        COPYTHECONTEXT(\"SH: redundant_pic_cnt\", u1_redundant_pic_cnt);\n }\n\n /*--------------------------------------------------------------------*/\n /* Check if the slice is part of new picture                          */\n /*--------------------------------------------------------------------*/\n /* First slice of a picture is always considered as part of new picture */\n    i1_is_end_of_poc = 1;\n    ps_dec->ps_dec_err_status->u1_err_flag &= MASK_REJECT_CUR_PIC;\n\n if(ps_dec->u4_first_slice_in_pic != 2)\n {\n        i1_is_end_of_poc = ih264d_is_end_of_pic(u2_frame_num, u1_nal_ref_idc,\n &s_tmp_poc, &ps_dec->s_cur_pic_poc,\n                                            ps_cur_slice, u1_pic_order_cnt_type,\n\n                                             u1_nal_unit_type, u4_idr_pic_id,\n                                             u1_field_pic_flag,\n                                             u1_bottom_field_flag);\n     }\n \n     /*--------------------------------------------------------------------*/\n /* Check for error in slice and parse the missing/corrupted MB's      */\n /* as skip-MB's in an inserted P-slice                                */\n /*--------------------------------------------------------------------*/\n    u1_mbaff = ps_seq->u1_mb_aff_flag && (!u1_field_pic_flag);\n    prev_slice_err = 0;\n\n if(i1_is_end_of_poc || ps_dec->u1_first_slice_in_stream)\n {\n if(u2_frame_num != ps_dec->u2_prv_frame_num\n && ps_dec->u1_top_bottom_decoded != 0\n && ps_dec->u1_top_bottom_decoded\n != (TOP_FIELD_ONLY | BOT_FIELD_ONLY))\n {\n            ps_dec->u1_dangling_field = 1;\n if(ps_dec->u4_first_slice_in_pic)\n {\n                prev_slice_err = 1;\n }\n else\n {\n                prev_slice_err = 2;\n }\n\n if(ps_dec->u1_top_bottom_decoded ==TOP_FIELD_ONLY)\n                ps_cur_slice->u1_bottom_field_flag = 1;\n else\n                ps_cur_slice->u1_bottom_field_flag = 0;\n\n            num_mb_skipped = (ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n - ps_dec->u2_total_mbs_coded;\n            ps_cur_poc = &ps_dec->s_cur_pic_poc;\n\n            u1_is_idr_slice = ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL;\n }\n else if(ps_dec->u4_first_slice_in_pic == 2)\n {\n if(u2_first_mb_in_slice > 0)\n {\n                prev_slice_err = 1;\n                num_mb_skipped = u2_first_mb_in_slice << u1_mbaff;\n                ps_cur_poc = &s_tmp_poc;\n\n                ps_cur_slice->u4_idr_pic_id = u4_idr_pic_id;\n                ps_cur_slice->u1_field_pic_flag = u1_field_pic_flag;\n                ps_cur_slice->u1_bottom_field_flag = u1_bottom_field_flag;\n                ps_cur_slice->i4_pic_order_cnt_lsb =\n                        s_tmp_poc.i4_pic_order_cnt_lsb;\n                ps_cur_slice->u1_nal_unit_type = u1_nal_unit_type;\n                ps_cur_slice->u1_redundant_pic_cnt = u1_redundant_pic_cnt;\n                ps_cur_slice->u1_nal_ref_idc = u1_nal_ref_idc;\n                ps_cur_slice->u1_pic_order_cnt_type = u1_pic_order_cnt_type;\n                ps_cur_slice->u1_mbaff_frame_flag = ps_seq->u1_mb_aff_flag\n && (!u1_field_pic_flag);\n }\n }\n else\n {\n\n if(ps_dec->u4_first_slice_in_pic)\n {\n /* if valid slice header is not decoded do start of pic processing\n                 * since in the current process call, frame num is not updated in the slice structure yet\n                 * ih264d_is_end_of_pic is checked with valid frame num of previous process call,\n                 * although i1_is_end_of_poc is set there could be  more slices in the frame,\n                 * so conceal only till cur slice */\n                prev_slice_err = 1;\n                num_mb_skipped = u2_first_mb_in_slice << u1_mbaff;\n }\n else\n {\n /* since i1_is_end_of_poc is set ,means new frame num is encountered. so conceal the current frame\n                 * completely */\n                prev_slice_err = 2;\n                num_mb_skipped = (ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n - ps_dec->u2_total_mbs_coded;\n }\n            ps_cur_poc = &s_tmp_poc;\n }\n }\n else\n {\n if((u2_first_mb_in_slice << u1_mbaff) > ps_dec->u2_total_mbs_coded)\n {\n            prev_slice_err = 2;\n            num_mb_skipped = (u2_first_mb_in_slice << u1_mbaff)\n - ps_dec->u2_total_mbs_coded;\n            ps_cur_poc = &s_tmp_poc;\n }\n else if((u2_first_mb_in_slice << u1_mbaff) < ps_dec->u2_total_mbs_coded)\n {\n return ERROR_CORRUPTED_SLICE;\n }\n }\n\n if(prev_slice_err)\n {\n        ret = ih264d_mark_err_slice_skip(ps_dec, num_mb_skipped, u1_is_idr_slice, u2_frame_num, ps_cur_poc, prev_slice_err);\n\n if(ps_dec->u1_dangling_field == 1)\n {\n            ps_dec->u1_second_field = 1 - ps_dec->u1_second_field;\n            ps_cur_slice->u1_bottom_field_flag = u1_bottom_field_flag;\n            ps_dec->u2_prv_frame_num = u2_frame_num;\n            ps_dec->u1_first_slice_in_stream = 0;\n return ERROR_DANGLING_FIELD_IN_PIC;\n }\n\n if(prev_slice_err == 2)\n {\n            ps_dec->u1_first_slice_in_stream = 0;\n return ERROR_INCOMPLETE_FRAME;\n }\n\n if(ps_dec->u2_total_mbs_coded\n >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n {\n /* return if all MBs in frame are parsed*/\n            ps_dec->u1_first_slice_in_stream = 0;\n return ERROR_IN_LAST_SLICE_OF_PIC;\n }\n\n if(ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC)\n {\n            ih264d_err_pic_dispbuf_mgr(ps_dec);\n return ERROR_NEW_FRAME_EXPECTED;\n }\n\n if(ret != OK)\n return ret;\n\n        i1_is_end_of_poc = 0;\n }\n\n if (ps_dec->u4_first_slice_in_pic == 0)\n {\n        ps_dec->ps_parse_cur_slice++;\n        ps_dec->u2_cur_slice_num++;\n }\n\n if((ps_dec->u1_separate_parse == 0) && (ps_dec->u4_first_slice_in_pic == 0))\n {\n        ps_dec->ps_decode_cur_slice++;\n\n     }\n     ps_dec->u1_slice_header_done = 0;\n \n    /*--------------------------------------------------------------------*/\n    /* If the slice is part of new picture, do End of Pic processing.     */\n    /*--------------------------------------------------------------------*/\n    if(!ps_dec->u1_first_slice_in_stream)\n    {\n        UWORD8 uc_mbs_exceed = 0;\n        if(ps_dec->u2_total_mbs_coded\n                        == (ps_dec->ps_cur_sps->u2_max_mb_addr + 1))\n        {\n            /*u2_total_mbs_coded is forced  to u2_max_mb_addr+ 1 at the end of decode ,so\n             ,if it is first slice in pic dont consider u2_total_mbs_coded to detect new picture */\n            if(ps_dec->u4_first_slice_in_pic == 0)\n                uc_mbs_exceed = 1;\n        }\n        if(i1_is_end_of_poc || uc_mbs_exceed)\n        {\n            if(1 == ps_dec->u1_last_pic_not_decoded)\n            {\n                ret = ih264d_end_of_pic_dispbuf_mgr(ps_dec);\n                if(ret != OK)\n                    return ret;\n                ret = ih264d_end_of_pic(ps_dec, u1_is_idr_slice, u2_frame_num);\n                if(ret != OK)\n                    return ret;\n#if WIN32\n                H264_DEC_DEBUG_PRINT(\" ------ PIC SKIPPED ------\\n\");\n#endif\n                return RET_LAST_SKIP;\n            }\n            else\n            {\n                ret = ih264d_end_of_pic(ps_dec, u1_is_idr_slice, u2_frame_num);\n                if(ret != OK)\n                    return ret;\n            }\n        }\n    }\n \n     if(u1_field_pic_flag)\n     {\n        ps_dec->u2_prv_frame_num = u2_frame_num;\n }\n\n if(ps_cur_slice->u1_mmco_equalto5)\n {\n        WORD32 i4_temp_poc;\n        WORD32 i4_top_field_order_poc, i4_bot_field_order_poc;\n\n if(!ps_cur_slice->u1_field_pic_flag) // or a complementary field pair\n {\n            i4_top_field_order_poc = ps_dec->ps_cur_pic->i4_top_field_order_cnt;\n            i4_bot_field_order_poc =\n                            ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;\n            i4_temp_poc = MIN(i4_top_field_order_poc,\n                                     i4_bot_field_order_poc);\n }\n else if(!ps_cur_slice->u1_bottom_field_flag)\n            i4_temp_poc = ps_dec->ps_cur_pic->i4_top_field_order_cnt;\n else\n            i4_temp_poc = ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;\n\n        ps_dec->ps_cur_pic->i4_top_field_order_cnt = i4_temp_poc\n - ps_dec->ps_cur_pic->i4_top_field_order_cnt;\n        ps_dec->ps_cur_pic->i4_bottom_field_order_cnt = i4_temp_poc\n - ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;\n        ps_dec->ps_cur_pic->i4_poc = i4_temp_poc;\n        ps_dec->ps_cur_pic->i4_avg_poc = i4_temp_poc;\n }\n if(ps_dec->u4_first_slice_in_pic == 2)\n {\n        ret = ih264d_decode_pic_order_cnt(u1_is_idr_slice, u2_frame_num,\n &ps_dec->s_prev_pic_poc,\n &s_tmp_poc, ps_cur_slice, ps_pps,\n                                          u1_nal_ref_idc,\n                                          u1_bottom_field_flag,\n                                          u1_field_pic_flag, &i4_poc);\n if(ret != OK)\n return ret;\n /* Display seq no calculations */\n if(i4_poc >= ps_dec->i4_max_poc)\n            ps_dec->i4_max_poc = i4_poc;\n /* IDR Picture or POC wrap around */\n if(i4_poc == 0)\n {\n            ps_dec->i4_prev_max_display_seq = ps_dec->i4_prev_max_display_seq\n + ps_dec->i4_max_poc\n + ps_dec->u1_max_dec_frame_buffering + 1;\n            ps_dec->i4_max_poc = 0;\n }\n }\n\n /*--------------------------------------------------------------------*/\n /* Copy the values read from the bitstream to the slice header and then*/\n /* If the slice is first slice in picture, then do Start of Picture   */\n /* processing.                                                        */\n /*--------------------------------------------------------------------*/\n    ps_cur_slice->i4_delta_pic_order_cnt[0] = i_delta_poc[0];\n    ps_cur_slice->i4_delta_pic_order_cnt[1] = i_delta_poc[1];\n    ps_cur_slice->u4_idr_pic_id = u4_idr_pic_id;\n    ps_cur_slice->u2_first_mb_in_slice = u2_first_mb_in_slice;\n    ps_cur_slice->u1_field_pic_flag = u1_field_pic_flag;\n    ps_cur_slice->u1_bottom_field_flag = u1_bottom_field_flag;\n    ps_cur_slice->u1_slice_type = u1_slice_type;\n    ps_cur_slice->i4_pic_order_cnt_lsb = s_tmp_poc.i4_pic_order_cnt_lsb;\n\n    ps_cur_slice->u1_nal_unit_type = u1_nal_unit_type;\n    ps_cur_slice->u1_redundant_pic_cnt = u1_redundant_pic_cnt;\n    ps_cur_slice->u1_nal_ref_idc = u1_nal_ref_idc;\n    ps_cur_slice->u1_pic_order_cnt_type = u1_pic_order_cnt_type;\n\n if(ps_seq->u1_frame_mbs_only_flag)\n        ps_cur_slice->u1_direct_8x8_inference_flag =\n                        ps_seq->u1_direct_8x8_inference_flag;\n else\n        ps_cur_slice->u1_direct_8x8_inference_flag = 1;\n\n if(u1_slice_type == B_SLICE)\n {\n        ps_cur_slice->u1_direct_spatial_mv_pred_flag = ih264d_get_bit_h264(\n                        ps_bitstrm);\n        COPYTHECONTEXT(\"SH: direct_spatial_mv_pred_flag\",\n                        ps_cur_slice->u1_direct_spatial_mv_pred_flag);\n\n if(ps_cur_slice->u1_direct_spatial_mv_pred_flag)\n            ps_cur_slice->pf_decodeDirect = ih264d_decode_spatial_direct;\n else\n            ps_cur_slice->pf_decodeDirect = ih264d_decode_temporal_direct;\n if(!((ps_pps->ps_sps->u1_mb_aff_flag) && (!u1_field_pic_flag)))\n            ps_dec->pf_mvpred = ih264d_mvpred_nonmbaffB;\n }\n else\n {\n if(!((ps_pps->ps_sps->u1_mb_aff_flag) && (!u1_field_pic_flag)))\n            ps_dec->pf_mvpred = ih264d_mvpred_nonmbaff;\n }\n\n if(ps_dec->u4_first_slice_in_pic == 2)\n {\n if(u2_first_mb_in_slice == 0)\n {\n            ret = ih264d_start_of_pic(ps_dec, i4_poc, &s_tmp_poc, u2_frame_num, ps_pps);\n if(ret != OK)\n return ret;\n }\n\n        ps_dec->u4_output_present = 0;\n\n {\n            ih264d_get_next_display_field(ps_dec,\n                                          ps_dec->ps_out_buffer,\n &(ps_dec->s_disp_op));\n /* If error code is non-zero then there is no buffer available for display,\n             hence avoid format conversion */\n\n if(0 != ps_dec->s_disp_op.u4_error_code)\n {\n                ps_dec->u4_fmt_conv_cur_row = ps_dec->s_disp_frame_info.u4_y_ht;\n }\n else\n                ps_dec->u4_output_present = 1;\n }\n if(ps_dec->u1_separate_parse == 1)\n {\n if(ps_dec->u4_dec_thread_created == 0)\n {\n                ithread_create(ps_dec->pv_dec_thread_handle, NULL,\n (void *)ih264d_decode_picture_thread,\n (void *)ps_dec);\n\n                ps_dec->u4_dec_thread_created = 1;\n }\n\n if((ps_dec->u4_num_cores == 3) &&\n ((ps_dec->u4_app_disable_deblk_frm == 0) || ps_dec->i1_recon_in_thread3_flag)\n && (ps_dec->u4_bs_deblk_thread_created == 0))\n {\n                ps_dec->u4_start_recon_deblk = 0;\n                ithread_create(ps_dec->pv_bs_deblk_thread_handle, NULL,\n (void *)ih264d_recon_deblk_thread,\n (void *)ps_dec);\n                ps_dec->u4_bs_deblk_thread_created = 1;\n }\n }\n\n }\n\n /* INITIALIZATION of fn ptrs for MC and formMbPartInfo functions */\n {\n        UWORD8 uc_nofield_nombaff;\n\n\n\n        uc_nofield_nombaff = ((ps_dec->ps_cur_slice->u1_field_pic_flag == 0)\n && (ps_dec->ps_cur_slice->u1_mbaff_frame_flag == 0)\n && (u1_slice_type != B_SLICE)\n && (ps_dec->ps_cur_pps->u1_wted_pred_flag == 0));\n\n /* Initialise MC and formMbPartInfo fn ptrs one time based on profile_idc */\n\n if(uc_nofield_nombaff)\n {\n            ps_dec->p_form_mb_part_info = ih264d_form_mb_part_info_bp;\n            ps_dec->p_motion_compensate = ih264d_motion_compensate_bp;\n }\n else\n {\n            ps_dec->p_form_mb_part_info = ih264d_form_mb_part_info_mp;\n            ps_dec->p_motion_compensate = ih264d_motion_compensate_mp;\n }\n\n\n }\n\n /*\n     * Decide whether to decode the current picture or not\n     */\n {\n dec_err_status_t * ps_err = ps_dec->ps_dec_err_status;\n if(ps_err->u4_frm_sei_sync == u2_frame_num)\n {\n            ps_err->u1_err_flag = ACCEPT_ALL_PICS;\n            ps_err->u4_frm_sei_sync = SYNC_FRM_DEFAULT;\n }\n        ps_err->u4_cur_frm = u2_frame_num;\n }\n\n /* Decision for decoding if the picture is to be skipped */\n {\n        WORD32 i4_skip_b_pic, i4_skip_p_pic;\n\n        i4_skip_b_pic = (ps_dec->u4_skip_frm_mask & B_SLC_BIT)\n && (B_SLICE == u1_slice_type) && (0 == u1_nal_ref_idc);\n\n        i4_skip_p_pic = (ps_dec->u4_skip_frm_mask & P_SLC_BIT)\n && (P_SLICE == u1_slice_type) && (0 == u1_nal_ref_idc);\n\n /**************************************************************/\n /* Skip the B picture if skip mask is set for B picture and   */\n /* Current B picture is a non reference B picture or there is */\n /* no user for reference B picture                            */\n /**************************************************************/\n if(i4_skip_b_pic)\n {\n            ps_dec->ps_cur_pic->u4_pack_slc_typ |= B_SLC_BIT;\n /* Don't decode the picture in SKIP-B mode if that picture is B */\n /* and also it is not to be used as a reference picture         */\n            ps_dec->u1_last_pic_not_decoded = 1;\n\n return OK;\n }\n /**************************************************************/\n /* Skip the P picture if skip mask is set for P picture and   */\n /* Current P picture is a non reference P picture or there is */\n /* no user for reference P picture                            */\n /**************************************************************/\n if(i4_skip_p_pic)\n {\n            ps_dec->ps_cur_pic->u4_pack_slc_typ |= P_SLC_BIT;\n /* Don't decode the picture in SKIP-P mode if that picture is P */\n /* and also it is not to be used as a reference picture         */\n            ps_dec->u1_last_pic_not_decoded = 1;\n\n return OK;\n }\n }\n\n {\n        UWORD16 u2_mb_x, u2_mb_y;\n\n        ps_dec->i4_submb_ofst = ((u2_first_mb_in_slice\n << ps_cur_slice->u1_mbaff_frame_flag) * SUB_BLK_SIZE)\n - SUB_BLK_SIZE;\n if(u2_first_mb_in_slice)\n {\n            UWORD8 u1_mb_aff;\n            UWORD8 u1_field_pic;\n            UWORD16 u2_frm_wd_in_mbs;\n            u2_frm_wd_in_mbs = ps_seq->u2_frm_wd_in_mbs;\n            u1_mb_aff = ps_cur_slice->u1_mbaff_frame_flag;\n            u1_field_pic = ps_cur_slice->u1_field_pic_flag;\n\n {\n                UWORD32 x_offset;\n                UWORD32 y_offset;\n                UWORD32 u4_frame_stride;\n tfr_ctxt_t *ps_trns_addr; // = &ps_dec->s_tran_addrecon_parse;\n\n if(ps_dec->u1_separate_parse)\n {\n                    ps_trns_addr = &ps_dec->s_tran_addrecon_parse;\n }\n else\n {\n                    ps_trns_addr = &ps_dec->s_tran_addrecon;\n }\n                u2_mb_x = MOD(u2_first_mb_in_slice, u2_frm_wd_in_mbs);\n                u2_mb_y = DIV(u2_first_mb_in_slice, u2_frm_wd_in_mbs);\n\n                u2_mb_y <<= u1_mb_aff;\n\n if((u2_mb_x > u2_frm_wd_in_mbs - 1)\n || (u2_mb_y > ps_dec->u2_frm_ht_in_mbs - 1))\n {\n return ERROR_CORRUPTED_SLICE;\n }\n\n                u4_frame_stride = ps_dec->u2_frm_wd_y << u1_field_pic;\n                x_offset = u2_mb_x << 4;\n                y_offset = (u2_mb_y * u4_frame_stride) << 4;\n\n                ps_trns_addr->pu1_dest_y = ps_dec->s_cur_pic.pu1_buf1 + x_offset\n + y_offset;\n\n                u4_frame_stride = ps_dec->u2_frm_wd_uv << u1_field_pic;\n                x_offset >>= 1;\n                y_offset = (u2_mb_y * u4_frame_stride) << 3;\n\n                x_offset *= YUV420SP_FACTOR;\n\n                ps_trns_addr->pu1_dest_u = ps_dec->s_cur_pic.pu1_buf2 + x_offset\n + y_offset;\n                ps_trns_addr->pu1_dest_v = ps_dec->s_cur_pic.pu1_buf3 + x_offset\n + y_offset;\n\n                ps_trns_addr->pu1_mb_y = ps_trns_addr->pu1_dest_y;\n                ps_trns_addr->pu1_mb_u = ps_trns_addr->pu1_dest_u;\n                ps_trns_addr->pu1_mb_v = ps_trns_addr->pu1_dest_v;\n\n\n if(ps_dec->u1_separate_parse == 1)\n {\n                    ps_dec->ps_deblk_mbn = ps_dec->ps_deblk_pic\n + (u2_first_mb_in_slice << u1_mb_aff);\n }\n else\n {\n                        ps_dec->ps_deblk_mbn = ps_dec->ps_deblk_pic\n + (u2_first_mb_in_slice << u1_mb_aff);\n }\n\n                ps_dec->u2_cur_mb_addr = (u2_first_mb_in_slice << u1_mb_aff);\n\n                ps_dec->ps_mv_cur = ps_dec->s_cur_pic.ps_mv\n + ((u2_first_mb_in_slice << u1_mb_aff) << 4);\n }\n }\n else\n {\n tfr_ctxt_t *ps_trns_addr;\n\n if(ps_dec->u1_separate_parse)\n {\n                ps_trns_addr = &ps_dec->s_tran_addrecon_parse;\n }\n else\n {\n                ps_trns_addr = &ps_dec->s_tran_addrecon;\n }\n\n            u2_mb_x = 0xffff;\n            u2_mb_y = 0;\n            ps_dec->u2_cur_mb_addr = 0;\n            ps_dec->ps_deblk_mbn = ps_dec->ps_deblk_pic;\n            ps_dec->ps_mv_cur = ps_dec->s_cur_pic.ps_mv;\n            ps_trns_addr->pu1_dest_y = ps_dec->s_cur_pic.pu1_buf1;\n            ps_trns_addr->pu1_dest_u = ps_dec->s_cur_pic.pu1_buf2;\n            ps_trns_addr->pu1_dest_v = ps_dec->s_cur_pic.pu1_buf3;\n\n            ps_trns_addr->pu1_mb_y = ps_trns_addr->pu1_dest_y;\n            ps_trns_addr->pu1_mb_u = ps_trns_addr->pu1_dest_u;\n            ps_trns_addr->pu1_mb_v = ps_trns_addr->pu1_dest_v;\n\n }\n\n        ps_dec->ps_part = ps_dec->ps_parse_part_params;\n\n        ps_dec->u2_mbx =\n (MOD(u2_first_mb_in_slice - 1, ps_seq->u2_frm_wd_in_mbs));\n        ps_dec->u2_mby =\n (DIV(u2_first_mb_in_slice - 1, ps_seq->u2_frm_wd_in_mbs));\n        ps_dec->u2_mby <<= ps_cur_slice->u1_mbaff_frame_flag;\n        ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;\n        ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;\n }\n\n /* RBSP stop bit is used for CABAC decoding*/\n    ps_bitstrm->u4_max_ofst += ps_dec->ps_cur_pps->u1_entropy_coding_mode;\n\n    ps_dec->u1_B = (u1_slice_type == B_SLICE);\n    ps_dec->u4_next_mb_skip = 0;\n\n    ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice =\n                    ps_dec->ps_cur_slice->u2_first_mb_in_slice;\n    ps_dec->ps_parse_cur_slice->slice_type =\n                    ps_dec->ps_cur_slice->u1_slice_type;\n\n\n    ps_dec->u4_start_recon_deblk = 1;\n {\n        WORD32 num_entries;\n        WORD32 size;\n        UWORD8 *pu1_buf;\n\n        num_entries = MIN(MAX_FRAMES, ps_dec->u4_num_ref_frames_at_init);\n        num_entries = 2 * ((2 * num_entries) + 1);\n\n        size = num_entries * sizeof(void *);\n        size += PAD_MAP_IDX_POC * sizeof(void *);\n\n        pu1_buf = (UWORD8 *)ps_dec->pv_map_ref_idx_to_poc_buf;\n        pu1_buf += size * ps_dec->u2_cur_slice_num;\n        ps_dec->ps_parse_cur_slice->ppv_map_ref_idx_to_poc = ( void *)pu1_buf;\n }\n\n if(ps_dec->u1_separate_parse)\n {\n        ps_dec->ps_parse_cur_slice->pv_tu_coeff_data_start = ps_dec->pv_parse_tu_coeff_data;\n }\n else\n {\n        ps_dec->pv_proc_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;\n }\n\n if(u1_slice_type == I_SLICE)\n {\n        ps_dec->ps_cur_pic->u4_pack_slc_typ |= I_SLC_BIT;\n\n        ret = ih264d_parse_islice(ps_dec, u2_first_mb_in_slice);\n\n if(ps_dec->i4_pic_type != B_SLICE && ps_dec->i4_pic_type != P_SLICE)\n            ps_dec->i4_pic_type = I_SLICE;\n\n }\n else if(u1_slice_type == P_SLICE)\n {\n        ps_dec->ps_cur_pic->u4_pack_slc_typ |= P_SLC_BIT;\n        ret = ih264d_parse_pslice(ps_dec, u2_first_mb_in_slice);\n        ps_dec->u1_pr_sl_type = u1_slice_type;\n if(ps_dec->i4_pic_type != B_SLICE)\n            ps_dec->i4_pic_type = P_SLICE;\n }\n else if(u1_slice_type == B_SLICE)\n {\n        ps_dec->ps_cur_pic->u4_pack_slc_typ |= B_SLC_BIT;\n        ret = ih264d_parse_bslice(ps_dec, u2_first_mb_in_slice);\n        ps_dec->u1_pr_sl_type = u1_slice_type;\n        ps_dec->i4_pic_type = B_SLICE;\n }\n else\n return ERROR_INV_SLC_TYPE_T;\n\n if(ps_dec->u1_slice_header_done)\n {\n /* set to zero to indicate a valid slice has been decoded */\n /* first slice header successfully decoded */\n        ps_dec->u4_first_slice_in_pic = 0;\n        ps_dec->u1_first_slice_in_stream = 0;\n }\n\n if(ret != OK)\n return ret;\n\n /* storing last Mb X and MbY of the slice */\n    ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;\n    ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;\n\n /* End of Picture detection */\n\n if(ps_dec->u2_total_mbs_coded >= (ps_seq->u2_max_mb_addr + 1))\n {\n        ps_dec->u1_pic_decode_done = 1;\n\n }\n\n {\n dec_err_status_t * ps_err = ps_dec->ps_dec_err_status;\n if((ps_err->u1_err_flag & REJECT_PB_PICS)\n && (ps_err->u1_cur_pic_type == PIC_TYPE_I))\n {\n            ps_err->u1_err_flag = ACCEPT_ALL_PICS;\n }\n }\n\n    PRINT_BIN_BIT_RATIO(ps_dec)\n\n return ret;\n}\n", "target": 1, "idx": 188079}
{"func": "extern \"C\" void RIL_setcallbacks (const RIL_RadioFunctions *callbacks) {\n    memcpy(&s_callbacks, callbacks, sizeof (RIL_RadioFunctions));\n}\n", "target": 0, "idx": 175249}
{"func": "inline void PulseAudioMixer::MainloopLock() const {\n   pa_threaded_mainloop_lock(pa_mainloop_);\n   ++mainloop_lock_count_;\n }\n", "target": 1, "idx": 184162}
{"func": "ModuleExport size_t RegisterPSImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"PS\",\"EPI\",\n    \"Encapsulated PostScript Interchange format\");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/postscript\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PS\",\"EPS\",\"Encapsulated PostScript\");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/postscript\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PS\",\"EPSF\",\"Encapsulated PostScript\");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/postscript\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PS\",\"EPSI\",\n    \"Encapsulated PostScript Interchange format\");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/postscript\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PS\",\"PS\",\"PostScript\");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->mime_type=ConstantString(\"application/postscript\");\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n", "target": 0, "idx": 96749}
{"func": "static MagickBooleanType SkipDXTMipmaps(Image *image,DDSInfo *dds_info,\n  int texel_size,ExceptionInfo *exception)\n{\n  register ssize_t\n    i;\n\n  MagickOffsetType\n    offset;\n\n  size_t\n    h,\n    w;\n\n  /*\n    Only skip mipmaps for textures and cube maps\n  */\n  if (EOFBlob(image) != MagickFalse)\n    {\n      ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n        image->filename);\n      return(MagickFalse);\n    }\n  if (dds_info->ddscaps1 & DDSCAPS_MIPMAP\n      && (dds_info->ddscaps1 & DDSCAPS_TEXTURE\n          || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))\n    {\n      w = DIV2(dds_info->width);\n      h = DIV2(dds_info->height);\n\n      /*\n        Mipmapcount includes the main image, so start from one\n      */\n       for (i = 1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)\n       {\n         offset = (MagickOffsetType) ((w + 3) / 4) * ((h + 3) / 4) * texel_size;\n        (void) SeekBlob(image, offset, SEEK_CUR);\n         w = DIV2(w);\n         h = DIV2(h);\n       }\n    }\n  return(MagickTrue);\n}\n", "target": 1, "idx": 182025}
{"func": " SPL_METHOD(GlobIterator, count)\n {\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n\n\tif (php_stream_is(intern->u.dir.dirp ,&php_glob_stream_ops)) {\n\t\tRETURN_LONG(php_glob_stream_get_count(intern->u.dir.dirp, NULL));\n\t} else {\n\t\t/* should not happen */\n\t\tphp_error_docref(NULL TSRMLS_CC, E_ERROR, \"GlobIterator lost glob state\");\n\t}\n}\n", "target": 1, "idx": 180220}
{"func": "  void CreateProgramInfo(GLuint client_id, GLuint service_id) {\n    program_manager()->CreateProgramInfo(client_id, service_id);\n  }\n", "target": 0, "idx": 108045}
{"func": "void FrameFetchContext::ProvideDocumentToContext(FetchContext& context,\n                                                 Document* document) {\n  DCHECK(document);\n  CHECK(context.IsFrameFetchContext());\n  static_cast<FrameFetchContext&>(context).document_ = document;\n  static_cast<FrameFetchContext&>(context).fetch_client_settings_object_ =\n      new FetchClientSettingsObjectImpl(*document);\n}\n", "target": 0, "idx": 158631}
{"func": "armv6_pmcr_has_overflowed(unsigned long pmcr)\n{\n\treturn pmcr & ARMV6_PMCR_OVERFLOWED_MASK;\n}\n", "target": 0, "idx": 25240}
{"func": "key_ref_t key_create_or_update(key_ref_t keyring_ref,\n\t\t\t       const char *type,\n\t\t\t       const char *description,\n\t\t\t       const void *payload,\n\t\t\t       size_t plen,\n\t\t\t       key_perm_t perm,\n\t\t\t       unsigned long flags)\n{\n\tstruct keyring_index_key index_key = {\n\t\t.description\t= description,\n\t};\n\tstruct key_preparsed_payload prep;\n\tstruct assoc_array_edit *edit;\n\tconst struct cred *cred = current_cred();\n\tstruct key *keyring, *key = NULL;\n\tkey_ref_t key_ref;\n\tint ret;\n\n\t/* look up the key type to see if it's one of the registered kernel\n\t * types */\n\tindex_key.type = key_type_lookup(type);\n\tif (IS_ERR(index_key.type)) {\n\t\tkey_ref = ERR_PTR(-ENODEV);\n\t\tgoto error;\n \t}\n \n \tkey_ref = ERR_PTR(-EINVAL);\n\tif (!index_key.type->match || !index_key.type->instantiate ||\n \t    (!index_key.description && !index_key.type->preparse))\n \t\tgoto error_put_type;\n \n\tkeyring = key_ref_to_ptr(keyring_ref);\n\n\tkey_check(keyring);\n\n\tkey_ref = ERR_PTR(-ENOTDIR);\n\tif (keyring->type != &key_type_keyring)\n\t\tgoto error_put_type;\n\n\tmemset(&prep, 0, sizeof(prep));\n\tprep.data = payload;\n\tprep.datalen = plen;\n\tprep.quotalen = index_key.type->def_datalen;\n\tprep.trusted = flags & KEY_ALLOC_TRUSTED;\n\tprep.expiry = TIME_T_MAX;\n\tif (index_key.type->preparse) {\n\t\tret = index_key.type->preparse(&prep);\n\t\tif (ret < 0) {\n\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\tgoto error_free_prep;\n\t\t}\n\t\tif (!index_key.description)\n\t\t\tindex_key.description = prep.description;\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (!index_key.description)\n\t\t\tgoto error_free_prep;\n\t}\n\tindex_key.desc_len = strlen(index_key.description);\n\n\tkey_ref = ERR_PTR(-EPERM);\n\tif (!prep.trusted && test_bit(KEY_FLAG_TRUSTED_ONLY, &keyring->flags))\n\t\tgoto error_free_prep;\n\tflags |= prep.trusted ? KEY_ALLOC_TRUSTED : 0;\n\n\tret = __key_link_begin(keyring, &index_key, &edit);\n\tif (ret < 0) {\n\t\tkey_ref = ERR_PTR(ret);\n\t\tgoto error_free_prep;\n\t}\n\n\t/* if we're going to allocate a new key, we're going to have\n\t * to modify the keyring */\n\tret = key_permission(keyring_ref, KEY_NEED_WRITE);\n\tif (ret < 0) {\n\t\tkey_ref = ERR_PTR(ret);\n\t\tgoto error_link_end;\n\t}\n\n\t/* if it's possible to update this type of key, search for an existing\n\t * key of the same type and description in the destination keyring and\n\t * update that instead if possible\n\t */\n\tif (index_key.type->update) {\n\t\tkey_ref = find_key_to_update(keyring_ref, &index_key);\n\t\tif (key_ref)\n\t\t\tgoto found_matching_key;\n\t}\n\n\t/* if the client doesn't provide, decide on the permissions we want */\n\tif (perm == KEY_PERM_UNDEF) {\n\t\tperm = KEY_POS_VIEW | KEY_POS_SEARCH | KEY_POS_LINK | KEY_POS_SETATTR;\n\t\tperm |= KEY_USR_VIEW;\n\n\t\tif (index_key.type->read)\n\t\t\tperm |= KEY_POS_READ;\n\n\t\tif (index_key.type == &key_type_keyring ||\n\t\t    index_key.type->update)\n\t\t\tperm |= KEY_POS_WRITE;\n\t}\n\n\t/* allocate a new key */\n\tkey = key_alloc(index_key.type, index_key.description,\n\t\t\tcred->fsuid, cred->fsgid, cred, perm, flags);\n\tif (IS_ERR(key)) {\n\t\tkey_ref = ERR_CAST(key);\n\t\tgoto error_link_end;\n\t}\n\n\t/* instantiate it and link it into the target keyring */\n\tret = __key_instantiate_and_link(key, &prep, keyring, NULL, &edit);\n\tif (ret < 0) {\n\t\tkey_put(key);\n\t\tkey_ref = ERR_PTR(ret);\n\t\tgoto error_link_end;\n\t}\n\n\tkey_ref = make_key_ref(key, is_key_possessed(keyring_ref));\n\nerror_link_end:\n\t__key_link_end(keyring, &index_key, edit);\nerror_free_prep:\n\tif (index_key.type->preparse)\n\t\tindex_key.type->free_preparse(&prep);\nerror_put_type:\n\tkey_type_put(index_key.type);\nerror:\n\treturn key_ref;\n\n found_matching_key:\n\t/* we found a matching key, so we're going to try to update it\n\t * - we can drop the locks first as we have the key pinned\n\t */\n\t__key_link_end(keyring, &index_key, edit);\n\n\tkey_ref = __key_update(key_ref, &prep);\n\tgoto error_free_prep;\n}\n", "target": 1, "idx": 181611}
{"func": "isoent_gen_joliet_identifier(struct archive_write *a, struct isoent *isoent,\n    struct idr *idr)\n{\n\tstruct iso9660 *iso9660;\n\tstruct isoent *np;\n \tunsigned char *p;\n \tsize_t l;\n \tint r;\n\tint ffmax, parent_len;\n \tstatic const struct archive_rb_tree_ops rb_ops = {\n \t\tisoent_cmp_node_joliet, isoent_cmp_key_joliet\n \t};\n\n\tif (isoent->children.cnt == 0)\n\t\treturn (0);\n\n\tiso9660 = a->format_data;\n\tif (iso9660->opt.joliet == OPT_JOLIET_LONGNAME)\n\t\tffmax = 206;\n \telse\n \t\tffmax = 128;\n \n\tr = idr_start(a, idr, isoent->children.cnt, ffmax, 6, 2, &rb_ops);\n \tif (r < 0)\n \t\treturn (r);\n \n\tparent_len = 1;\n\tfor (np = isoent; np->parent != np; np = np->parent)\n\t\tparent_len += np->mb_len + 1;\n\n\tfor (np = isoent->children.first; np != NULL; np = np->chnext) {\n\t\tunsigned char *dot;\n \t\tint ext_off, noff, weight;\n \t\tsize_t lt;\n \n\t\tif ((int)(l = np->file->basename_utf16.length) > ffmax)\n \t\t\tl = ffmax;\n \n \t\tp = malloc((l+1)*2);\n\t\tif (p == NULL) {\n\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t    \"Can't allocate memory\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tmemcpy(p, np->file->basename_utf16.s, l);\n\t\tp[l] = 0;\n\t\tp[l+1] = 0;\n\n\t\tnp->identifier = (char *)p;\n\t\tlt = l;\n\t\tdot = p + l;\n\t\tweight = 0;\n\t\twhile (lt > 0) {\n\t\t\tif (!joliet_allowed_char(p[0], p[1]))\n\t\t\t\tarchive_be16enc(p, 0x005F); /* '_' */\n\t\t\telse if (p[0] == 0 && p[1] == 0x2E) /* '.' */\n\t\t\t\tdot = p;\n\t\t\tp += 2;\n\t\t\tlt -= 2;\n\t\t}\n\t\text_off = (int)(dot - (unsigned char *)np->identifier);\n\t\tnp->ext_off = ext_off;\n\t\tnp->ext_len = (int)l - ext_off;\n\t\tnp->id_len = (int)l;\n\n \t\t/*\n \t\t * Get a length of MBS of a full-pathname.\n \t\t */\n\t\tif ((int)np->file->basename_utf16.length > ffmax) {\n \t\t\tif (archive_strncpy_l(&iso9660->mbs,\n \t\t\t    (const char *)np->identifier, l,\n \t\t\t\tiso9660->sconv_from_utf16be) != 0 &&\n\t\t\t    errno == ENOMEM) {\n\t\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\t    \"No memory\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t\tnp->mb_len = (int)iso9660->mbs.length;\n\t\t\tif (np->mb_len != (int)np->file->basename.length)\n\t\t\t\tweight = np->mb_len;\n\t\t} else\n\t\t\tnp->mb_len = (int)np->file->basename.length;\n \n \t\t/* If a length of full-pathname is longer than 240 bytes,\n \t\t * it violates Joliet extensions regulation. */\n\t\tif (parent_len + np->mb_len > 240) {\n \t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n \t\t\t    \"The regulation of Joliet extensions;\"\n \t\t\t    \" A length of a full-pathname of `%s' is \"\n\t\t\t    \"longer than 240 bytes, (p=%d, b=%d)\",\n\t\t\t    archive_entry_pathname(np->file->entry),\n\t\t\t    (int)parent_len, (int)np->mb_len);\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n \n \t\t/* Make an offset of the number which is used to be set\n \t\t * hexadecimal number to avoid duplicate identifier. */\n\t\tif ((int)l == ffmax)\n \t\t\tnoff = ext_off - 6;\n\t\telse if ((int)l == ffmax-2)\n \t\t\tnoff = ext_off - 4;\n\t\telse if ((int)l == ffmax-4)\n \t\t\tnoff = ext_off - 2;\n \t\telse\n \t\t\tnoff = ext_off;\n\t\t/* Register entry to the identifier resolver. */\n\t\tidr_register(idr, np, weight, noff);\n\t}\n\n\t/* Resolve duplicate identifier with Joliet Volume. */\n\tidr_resolve(idr, idr_set_num_beutf16);\n\n\treturn (ARCHIVE_OK);\n}\n", "target": 1, "idx": 180175}
{"func": "my_object_many_args (MyObject *obj, guint32 x, const char *str, double trouble, double *d_ret, char **str_ret, GError **error)\n{\n  *d_ret = trouble + (x * 2);\n  *str_ret = g_ascii_strup (str, -1);\n  return TRUE;\n}\n", "target": 1, "idx": 178282}
{"func": "void PreconnectManager::Start(const GURL& url,\n                              std::vector<PreconnectRequest> requests) {\n  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n  const std::string host = url.host();\n  if (preresolve_info_.find(host) != preresolve_info_.end())\n    return;\n\n  auto iterator_and_whether_inserted = preresolve_info_.emplace(\n      host, std::make_unique<PreresolveInfo>(url, requests.size()));\n  PreresolveInfo* info = iterator_and_whether_inserted.first->second.get();\n \n   for (auto request_it = requests.begin(); request_it != requests.end();\n        ++request_it) {\n    DCHECK(request_it->origin.GetOrigin() == request_it->origin);\n     PreresolveJobId job_id = preresolve_jobs_.Add(\n         std::make_unique<PreresolveJob>(std::move(*request_it), info));\n     queued_jobs_.push_back(job_id);\n  }\n\n  TryToLaunchPreresolveJobs();\n}\n", "target": 1, "idx": 186345}
{"func": " void WtsSessionProcessDelegate::Core::KillProcess(DWORD exit_code) {\n   DCHECK(main_task_runner_->BelongsToCurrentThread());\n \n   channel_.reset();\n \n   if (launch_elevated_) {\n     if (job_.IsValid()) {\n      TerminateJobObject(job_, exit_code);\n    }\n  } else {\n    if (worker_process_.IsValid()) {\n      TerminateProcess(worker_process_, exit_code);\n    }\n  }\n}\n", "target": 1, "idx": 185262}
{"func": "int dtls1_get_record(SSL *s)\n\t{\n\tint ssl_major,ssl_minor;\n\tint i,n;\n\tSSL3_RECORD *rr;\n\tunsigned char *p = NULL;\n\tunsigned short version;\n\tDTLS1_BITMAP *bitmap;\n\tunsigned int is_next_epoch;\n\n\trr= &(s->s3->rrec);\n\n\t/* The epoch may have changed.  If so, process all the\n\t * pending records.  This is a non-blocking operation. */\n\tdtls1_process_buffered_records(s);\n\n\t/* if we're renegotiating, then there may be buffered records */\n\tif (dtls1_get_processed_record(s))\n\t\treturn 1;\n\n\t/* get something from the wire */\nagain:\n\t/* check if we have the header */\n\tif (\t(s->rstate != SSL_ST_READ_BODY) ||\n\t\t(s->packet_length < DTLS1_RT_HEADER_LENGTH)) \n\t\t{\n\t\tn=ssl3_read_n(s, DTLS1_RT_HEADER_LENGTH, s->s3->rbuf.len, 0);\n\t\t/* read timeout is handled by dtls1_read_bytes */\n\t\tif (n <= 0) return(n); /* error or non-blocking */\n\n\t\t/* this packet contained a partial record, dump it */\n\t\tif (s->packet_length != DTLS1_RT_HEADER_LENGTH)\n\t\t\t{\n\t\t\ts->packet_length = 0;\n\t\t\tgoto again;\n\t\t\t}\n\n\t\ts->rstate=SSL_ST_READ_BODY;\n\n\t\tp=s->packet;\n\n\t\tif (s->msg_callback)\n\t\t\ts->msg_callback(0, 0, SSL3_RT_HEADER, p, DTLS1_RT_HEADER_LENGTH, s, s->msg_callback_arg);\n\n\t\t/* Pull apart the header into the DTLS1_RECORD */\n\t\trr->type= *(p++);\n\t\tssl_major= *(p++);\n\t\tssl_minor= *(p++);\n\t\tversion=(ssl_major<<8)|ssl_minor;\n\n\t\t/* sequence number is 64 bits, with top 2 bytes = epoch */ \n\t\tn2s(p,rr->epoch);\n\n\t\tmemcpy(&(s->s3->read_sequence[2]), p, 6);\n\t\tp+=6;\n\n\t\tn2s(p,rr->length);\n\n\t\t/* Lets check version */\n\t\tif (!s->first_packet)\n\t\t\t{\n\t\t\tif (version != s->version)\n\t\t\t\t{\n\t\t\t\t/* unexpected version, silently discard */\n\t\t\t\trr->length = 0;\n\t\t\t\ts->packet_length = 0;\n\t\t\t\tgoto again;\n\t\t\t\t}\n\t\t\t}\n\n\t\tif ((version & 0xff00) != (s->version & 0xff00))\n\t\t\t{\n\t\t\t/* wrong version, silently discard record */\n\t\t\trr->length = 0;\n\t\t\ts->packet_length = 0;\n\t\t\tgoto again;\n\t\t\t}\n\n\t\tif (rr->length > SSL3_RT_MAX_ENCRYPTED_LENGTH)\n\t\t\t{\n\t\t\t/* record too long, silently discard it */\n\t\t\trr->length = 0;\n\t\t\ts->packet_length = 0;\n\t\t\tgoto again;\n\t\t\t}\n\n\t\t/* now s->rstate == SSL_ST_READ_BODY */\n\t\t}\n\n\t/* s->rstate == SSL_ST_READ_BODY, get and decode the data */\n\n\tif (rr->length > s->packet_length-DTLS1_RT_HEADER_LENGTH)\n\t\t{\n\t\t/* now s->packet_length == DTLS1_RT_HEADER_LENGTH */\n\t\ti=rr->length;\n\t\tn=ssl3_read_n(s,i,i,1);\n\t\t/* this packet contained a partial record, dump it */\n\t\tif ( n != i)\n\t\t\t{\n\t\t\trr->length = 0;\n\t\t\ts->packet_length = 0;\n\t\t\tgoto again;\n\t\t\t}\n\n\t\t/* now n == rr->length,\n\t\t * and s->packet_length == DTLS1_RT_HEADER_LENGTH + rr->length */\n\t\t}\n\ts->rstate=SSL_ST_READ_HEADER; /* set state for later operations */\n\n\t/* match epochs.  NULL means the packet is dropped on the floor */\n\tbitmap = dtls1_get_bitmap(s, rr, &is_next_epoch);\n\tif ( bitmap == NULL)\n\t\t{\n\t\trr->length = 0;\n\t\ts->packet_length = 0;  /* dump this record */\n\t\tgoto again;   /* get another record */\n\t\t}\n\n#ifndef OPENSSL_NO_SCTP\n\t/* Only do replay check if no SCTP bio */\n\tif (!BIO_dgram_is_sctp(SSL_get_rbio(s)))\n  \t\t{\n#endif\n\t\t/* Check whether this is a repeat, or aged record.\n\t\t * Don't check if we're listening and this message is\n\t\t * a ClientHello. They can look as if they're replayed,\n\t\t * since they arrive from different connections and\n \t\t * would be dropped unnecessarily.\n \t\t */\n \t\tif (!(s->d1->listen && rr->type == SSL3_RT_HANDSHAKE &&\n\t\t    *p == SSL3_MT_CLIENT_HELLO) &&\n \t\t    !dtls1_record_replay_check(s, bitmap))\n \t\t\t{\n \t\t\trr->length = 0;\n\t\t\ts->packet_length=0; /* dump this record */\n\t\t\tgoto again;     /* get another record */\n\t\t\t}\n#ifndef OPENSSL_NO_SCTP\n  \t\t}\n#endif\n\n\t/* just read a 0 length packet */\n\tif (rr->length == 0) goto again;\n\n\t/* If this record is from the next epoch (either HM or ALERT),\n\t * and a handshake is currently in progress, buffer it since it\n\t * cannot be processed at this time. However, do not buffer\n\t * anything while listening.\n\t */\n\tif (is_next_epoch)\n\t\t{\n\t\tif ((SSL_in_init(s) || s->in_handshake) && !s->d1->listen)\n\t\t\t{\n\t\t\tdtls1_buffer_record(s, &(s->d1->unprocessed_rcds), rr->seq_num);\n\t\t\t}\n\t\trr->length = 0;\n\t\ts->packet_length = 0;\n\t\tgoto again;\n\t\t}\n\n\tif (!dtls1_process_record(s))\n\t\t{\n\t\trr->length = 0;\n\t\ts->packet_length = 0;  /* dump this record */\n\t\tgoto again;   /* get another record */\n\t\t}\n\n\treturn(1);\n\n\t}\n", "target": 1, "idx": 179999}
{"func": "static void pdf_run_v(fz_context *ctx, pdf_processor *proc, float x2, float y2, float x3, float y3)\n{\n\tpdf_run_processor *pr = (pdf_run_processor *)proc;\n\tfz_curvetov(ctx, pr->path, x2, y2, x3, y3);\n}\n", "target": 0, "idx": 548}
{"func": "FrameView::FrameView(LocalFrame* frame)\n    : m_frame(frame)\n    , m_canHaveScrollbars(true)\n    , m_slowRepaintObjectCount(0)\n    , m_hasPendingLayout(false)\n    , m_layoutSubtreeRoot(0)\n    , m_inSynchronousPostLayout(false)\n    , m_postLayoutTasksTimer(this, &FrameView::postLayoutTimerFired)\n    , m_updateWidgetsTimer(this, &FrameView::updateWidgetsTimerFired)\n    , m_isTransparent(false)\n    , m_baseBackgroundColor(Color::white)\n    , m_mediaType(\"screen\")\n    , m_overflowStatusDirty(true)\n    , m_viewportRenderer(0)\n    , m_wasScrolledByUser(false)\n    , m_inProgrammaticScroll(false)\n    , m_safeToPropagateScrollToParent(true)\n    , m_isTrackingPaintInvalidations(false)\n    , m_scrollCorner(nullptr)\n    , m_hasSoftwareFilters(false)\n    , m_visibleContentScaleFactor(1)\n     , m_inputEventsScaleFactorForEmulation(1)\n     , m_layoutSizeFixedToFrameSize(true)\n     , m_didScrollTimer(this, &FrameView::didScrollTimerFired)\n {\n     ASSERT(m_frame);\n     init();\n\n    if (!m_frame->isMainFrame())\n        return;\n\n    ScrollableArea::setVerticalScrollElasticity(ScrollElasticityAllowed);\n    ScrollableArea::setHorizontalScrollElasticity(ScrollElasticityAllowed);\n}\n", "target": 1, "idx": 185338}
{"func": "static inline int vmcs12_write_any(struct kvm_vcpu *vcpu,\n\t\t\t\t   unsigned long field, u64 field_value){\n\tshort offset = vmcs_field_to_offset(field);\n\tchar *p = ((char *) get_vmcs12(vcpu)) + offset;\n\tif (offset < 0)\n\t\treturn offset;\n\n\tswitch (vmcs_field_width(field)) {\n\tcase VMCS_FIELD_WIDTH_U16:\n\t\t*(u16 *)p = field_value;\n\t\treturn 0;\n\tcase VMCS_FIELD_WIDTH_U32:\n\t\t*(u32 *)p = field_value;\n\t\treturn 0;\n\tcase VMCS_FIELD_WIDTH_U64:\n\t\t*(u64 *)p = field_value;\n\t\treturn 0;\n\tcase VMCS_FIELD_WIDTH_NATURAL_WIDTH:\n\t\t*(natural_width *)p = field_value;\n\t\treturn 0;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -ENOENT;\n\t}\n\n}\n", "target": 0, "idx": 81004}
{"func": "OMX_ERRORTYPE SoftAACEncoder2::internalGetParameter(\n        OMX_INDEXTYPE index, OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamAudioPortFormat:\n {\n\n             OMX_AUDIO_PARAM_PORTFORMATTYPE *formatParams =\n                 (OMX_AUDIO_PARAM_PORTFORMATTYPE *)params;\n \n             if (formatParams->nPortIndex > 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n if (formatParams->nIndex > 0) {\n return OMX_ErrorNoMore;\n }\n\n            formatParams->eEncoding =\n (formatParams->nPortIndex == 0)\n ? OMX_AUDIO_CodingPCM : OMX_AUDIO_CodingAAC;\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioAac:\n {\n\n             OMX_AUDIO_PARAM_AACPROFILETYPE *aacParams =\n                 (OMX_AUDIO_PARAM_AACPROFILETYPE *)params;\n \n             if (aacParams->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            aacParams->nBitRate = mBitRate;\n            aacParams->nAudioBandWidth = 0;\n            aacParams->nAACtools = 0;\n            aacParams->nAACERtools = 0;\n            aacParams->eAACProfile = (OMX_AUDIO_AACPROFILETYPE) mAACProfile;\n            aacParams->eAACStreamFormat = OMX_AUDIO_AACStreamFormatMP4FF;\n            aacParams->eChannelMode = OMX_AUDIO_ChannelModeStereo;\n\n            aacParams->nChannels = mNumChannels;\n            aacParams->nSampleRate = mSampleRate;\n            aacParams->nFrameLength = 0;\n\n switch (mSBRMode) {\n case 1: // sbr on\n switch (mSBRRatio) {\n case 0:\n                    aacParams->nAACtools |= OMX_AUDIO_AACToolAndroidSSBR;\n                    aacParams->nAACtools |= OMX_AUDIO_AACToolAndroidDSBR;\n break;\n case 1:\n                    aacParams->nAACtools |= OMX_AUDIO_AACToolAndroidSSBR;\n                    aacParams->nAACtools &= ~OMX_AUDIO_AACToolAndroidDSBR;\n break;\n case 2:\n                    aacParams->nAACtools &= ~OMX_AUDIO_AACToolAndroidSSBR;\n                    aacParams->nAACtools |= OMX_AUDIO_AACToolAndroidDSBR;\n break;\n default:\n                    ALOGE(\"invalid SBR ratio %d\", mSBRRatio);\n                    TRESPASS();\n }\n break;\n case 0: // sbr off\n case -1: // sbr undefined\n                aacParams->nAACtools &= ~OMX_AUDIO_AACToolAndroidSSBR;\n                aacParams->nAACtools &= ~OMX_AUDIO_AACToolAndroidDSBR;\n break;\n default:\n                ALOGE(\"invalid SBR mode %d\", mSBRMode);\n                TRESPASS();\n }\n\n\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioPcm:\n {\n\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex != 0) {\n                 return OMX_ErrorUndefined;\n             }\n\n            pcmParams->eNumData = OMX_NumericalDataSigned;\n            pcmParams->eEndian = OMX_EndianBig;\n            pcmParams->bInterleaved = OMX_TRUE;\n            pcmParams->nBitPerSample = 16;\n            pcmParams->ePCMMode = OMX_AUDIO_PCMModeLinear;\n            pcmParams->eChannelMapping[0] = OMX_AUDIO_ChannelLF;\n            pcmParams->eChannelMapping[1] = OMX_AUDIO_ChannelRF;\n\n            pcmParams->nChannels = mNumChannels;\n            pcmParams->nSamplingRate = mSampleRate;\n\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalGetParameter(index, params);\n }\n}\n", "target": 1, "idx": 188212}
{"func": "void FragmentPaintPropertyTreeBuilder::UpdateFragmentClip() {\n  DCHECK(properties_);\n\n   if (NeedsPaintPropertyUpdate()) {\n     if (context_.fragment_clip) {\n       OnUpdateClip(properties_->UpdateFragmentClip(\n          context_.current.clip,\n           ClipPaintPropertyNode::State{context_.current.transform,\n                                        ToClipRect(*context_.fragment_clip)}));\n     } else {\n      OnClearClip(properties_->ClearFragmentClip());\n    }\n  }\n\n  if (properties_->FragmentClip())\n    context_.current.clip = properties_->FragmentClip();\n}\n", "target": 1, "idx": 185674}
{"func": "ProcessIdToFilterMap* GetProcessIdToFilterMap() {\n  static base::NoDestructor<ProcessIdToFilterMap> instance;\n  return instance.get();\n}\n", "target": 1, "idx": 187023}
{"func": "int wasm_dis(WasmOp *op, const unsigned char *buf, int buf_len) {\n\top->len = 1;\n\top->op = buf[0];\n\tif (op->op > 0xbf) {\n\t\treturn 1;\n\t}\n\tWasmOpDef *opdef = &opcodes[op->op];\n\tswitch (op->op) {\n\tcase WASM_OP_TRAP:\n\tcase WASM_OP_NOP:\n\tcase WASM_OP_ELSE:\n\tcase WASM_OP_RETURN:\n\tcase WASM_OP_DROP:\n\tcase WASM_OP_SELECT:\n\tcase WASM_OP_I32EQZ:\n\tcase WASM_OP_I32EQ:\n\tcase WASM_OP_I32NE:\n\tcase WASM_OP_I32LTS:\n\tcase WASM_OP_I32LTU:\n\tcase WASM_OP_I32GTS:\n\tcase WASM_OP_I32GTU:\n\tcase WASM_OP_I32LES:\n\tcase WASM_OP_I32LEU:\n\tcase WASM_OP_I32GES:\n\tcase WASM_OP_I32GEU:\n\tcase WASM_OP_I64EQZ:\n\tcase WASM_OP_I64EQ:\n\tcase WASM_OP_I64NE:\n\tcase WASM_OP_I64LTS:\n\tcase WASM_OP_I64LTU:\n\tcase WASM_OP_I64GTS:\n\tcase WASM_OP_I64GTU:\n\tcase WASM_OP_I64LES:\n\tcase WASM_OP_I64LEU:\n\tcase WASM_OP_I64GES:\n\tcase WASM_OP_I64GEU:\n\tcase WASM_OP_F32EQ:\n\tcase WASM_OP_F32NE:\n\tcase WASM_OP_F32LT:\n\tcase WASM_OP_F32GT:\n\tcase WASM_OP_F32LE:\n\tcase WASM_OP_F32GE:\n\tcase WASM_OP_F64EQ:\n\tcase WASM_OP_F64NE:\n\tcase WASM_OP_F64LT:\n\tcase WASM_OP_F64GT:\n\tcase WASM_OP_F64LE:\n\tcase WASM_OP_F64GE:\n\tcase WASM_OP_I32CLZ:\n\tcase WASM_OP_I32CTZ:\n\tcase WASM_OP_I32POPCNT:\n\tcase WASM_OP_I32ADD:\n\tcase WASM_OP_I32SUB:\n\tcase WASM_OP_I32MUL:\n\tcase WASM_OP_I32DIVS:\n\tcase WASM_OP_I32DIVU:\n\tcase WASM_OP_I32REMS:\n\tcase WASM_OP_I32REMU:\n\tcase WASM_OP_I32AND:\n\tcase WASM_OP_I32OR:\n\tcase WASM_OP_I32XOR:\n\tcase WASM_OP_I32SHL:\n\tcase WASM_OP_I32SHRS:\n\tcase WASM_OP_I32SHRU:\n\tcase WASM_OP_I32ROTL:\n\tcase WASM_OP_I32ROTR:\n\tcase WASM_OP_I64CLZ:\n\tcase WASM_OP_I64CTZ:\n\tcase WASM_OP_I64POPCNT:\n\tcase WASM_OP_I64ADD:\n\tcase WASM_OP_I64SUB:\n\tcase WASM_OP_I64MUL:\n\tcase WASM_OP_I64DIVS:\n\tcase WASM_OP_I64DIVU:\n\tcase WASM_OP_I64REMS:\n\tcase WASM_OP_I64REMU:\n\tcase WASM_OP_I64AND:\n\tcase WASM_OP_I64OR:\n\tcase WASM_OP_I64XOR:\n\tcase WASM_OP_I64SHL:\n\tcase WASM_OP_I64SHRS:\n\tcase WASM_OP_I64SHRU:\n\tcase WASM_OP_I64ROTL:\n\tcase WASM_OP_I64ROTR:\n\tcase WASM_OP_F32ABS:\n\tcase WASM_OP_F32NEG:\n\tcase WASM_OP_F32CEIL:\n\tcase WASM_OP_F32FLOOR:\n\tcase WASM_OP_F32TRUNC:\n\tcase WASM_OP_F32NEAREST:\n\tcase WASM_OP_F32SQRT:\n\tcase WASM_OP_F32ADD:\n\tcase WASM_OP_F32SUB:\n\tcase WASM_OP_F32MUL:\n\tcase WASM_OP_F32DIV:\n\tcase WASM_OP_F32MIN:\n\tcase WASM_OP_F32MAX:\n\tcase WASM_OP_F32COPYSIGN:\n\tcase WASM_OP_F64ABS:\n\tcase WASM_OP_F64NEG:\n\tcase WASM_OP_F64CEIL:\n\tcase WASM_OP_F64FLOOR:\n\tcase WASM_OP_F64TRUNC:\n\tcase WASM_OP_F64NEAREST:\n\tcase WASM_OP_F64SQRT:\n\tcase WASM_OP_F64ADD:\n\tcase WASM_OP_F64SUB:\n\tcase WASM_OP_F64MUL:\n\tcase WASM_OP_F64DIV:\n\tcase WASM_OP_F64MIN:\n\tcase WASM_OP_F64MAX:\n\tcase WASM_OP_F64COPYSIGN:\n\tcase WASM_OP_I32WRAPI64:\n\tcase WASM_OP_I32TRUNCSF32:\n\tcase WASM_OP_I32TRUNCUF32:\n\tcase WASM_OP_I32TRUNCSF64:\n\tcase WASM_OP_I32TRUNCUF64:\n\tcase WASM_OP_I64EXTENDSI32:\n\tcase WASM_OP_I64EXTENDUI32:\n\tcase WASM_OP_I64TRUNCSF32:\n\tcase WASM_OP_I64TRUNCUF32:\n\tcase WASM_OP_I64TRUNCSF64:\n\tcase WASM_OP_I64TRUNCUF64:\n\tcase WASM_OP_F32CONVERTSI32:\n\tcase WASM_OP_F32CONVERTUI32:\n\tcase WASM_OP_F32CONVERTSI64:\n\tcase WASM_OP_F32CONVERTUI64:\n\tcase WASM_OP_F32DEMOTEF64:\n\tcase WASM_OP_F64CONVERTSI32:\n\tcase WASM_OP_F64CONVERTUI32:\n\tcase WASM_OP_F64CONVERTSI64:\n\tcase WASM_OP_F64CONVERTUI64:\n\tcase WASM_OP_F64PROMOTEF32:\n\tcase WASM_OP_I32REINTERPRETF32:\n\tcase WASM_OP_I64REINTERPRETF64:\n\tcase WASM_OP_F32REINTERPRETI32:\n\tcase WASM_OP_F64REINTERPRETI64:\n\tcase WASM_OP_END:\n\t\t{\n\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s\", opdef->txt);\n\t\t}\n\t\tbreak;\n\tcase WASM_OP_BLOCK:\n\tcase WASM_OP_LOOP:\n\tcase WASM_OP_IF:\n\t\t{\n\t\t\tst32 val = 0;\n\t\t\tsize_t n = read_i32_leb128 (buf + 1, buf + buf_len, &val);\n\t\t\tif (!(n > 0 && n < buf_len)) goto err;\n\t\t\tswitch (0x80 - val) {\n\t\t\tcase R_BIN_WASM_VALUETYPE_EMPTY:\n\t\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s\", opdef->txt);\n\t\t\t\tbreak;\n\t\t\tcase R_BIN_WASM_VALUETYPE_i32:\n\t\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s (result i32)\", opdef->txt);\n\t\t\t\tbreak;\n\t\t\tcase R_BIN_WASM_VALUETYPE_i64:\n\t\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s (result i64)\", opdef->txt);\n\t\t\t\tbreak;\n\t\t\tcase R_BIN_WASM_VALUETYPE_f32:\n\t\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s (result f32)\", opdef->txt);\n\t\t\t\tbreak;\n\t\t\tcase R_BIN_WASM_VALUETYPE_f64:\n\t\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s (result f64)\", opdef->txt);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s (result ?)\", opdef->txt);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\top->len += n;\n\t\t}\n\t\tbreak;\n\tcase WASM_OP_BR:\n\tcase WASM_OP_BRIF:\n\tcase WASM_OP_CALL:\n\t\t{\n\t\t\tut32 val = 0;\n\t\t\tsize_t n = read_u32_leb128 (buf + 1, buf + buf_len, &val);\n\t\t\tif (!(n > 0 && n < buf_len)) goto err;\n\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s %d\", opdef->txt, val);\n\t\t\top->len += n;\n\t\t}\n\t\tbreak;\n\tcase WASM_OP_BRTABLE:\n\t\t{\n\t\t\tut32 count = 0, *table = NULL, def = 0;\n\t\t\tsize_t n = read_u32_leb128 (buf + 1, buf + buf_len, &count);\n\t\t\tif (!(n > 0 && n < buf_len)) {\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tif (!(table = calloc (count, sizeof (ut32)))) {\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tint i = 0;\n\t\t\top->len += n;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tn = read_u32_leb128 (buf + op->len, buf + buf_len, &table[i]);\n\t\t\t\tif (!(op->len + n <= buf_len)) {\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\top->len += n;\n\t\t\t}\n\t\t\tn = read_u32_leb128 (buf + op->len, buf + buf_len, &def);\n\t\t\tif (!(n > 0 && n + op->len < buf_len)) {\n\t\t\t\tgoto beach;\n \t\t\t}\n \t\t\top->len += n;\n \t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s %d \", opdef->txt, count);\n\t\t\tfor (i = 0; i < count && strlen (op->txt) + 10 < R_ASM_BUFSIZE; i++) {\n\t\t\t\tint optxtlen = strlen (op->txt);\n\t\t\t\tsnprintf (op->txt + optxtlen, R_ASM_BUFSIZE - optxtlen, \"%d \", table[i]);\n \t\t\t}\n\t\t\tsnprintf (op->txt + strlen (op->txt), R_ASM_BUFSIZE, \"%d\", def);\n \t\t\tfree (table);\n \t\t\tbreak;\n\t\t\tbeach:\n \t\t\tfree (table);\n \t\t\tgoto err;\n \t\t}\n\t\tbreak;\n\tcase WASM_OP_CALLINDIRECT:\n\t\t{\n\t\t\tut32 val = 0, reserved = 0;\n\t\t\tsize_t n = read_u32_leb128 (buf + 1, buf + buf_len, &val);\n\t\t\tif (!(n > 0 && n < buf_len)) goto err;\n\t\t\top->len += n;\n\t\t\tn = read_u32_leb128 (buf + op->len, buf + buf_len, &reserved);\n\t\t\tif (!(n == 1 && op->len + n <= buf_len)) goto err;\n\t\t\treserved &= 0x1;\n\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s %d %d\", opdef->txt, val, reserved);\n\t\t\top->len += n;\n\t\t}\n\t\tbreak;\n\tcase WASM_OP_GETLOCAL:\n\tcase WASM_OP_SETLOCAL:\n\tcase WASM_OP_TEELOCAL:\n\tcase WASM_OP_GETGLOBAL:\n\tcase WASM_OP_SETGLOBAL:\n\t\t{\n\t\t\tut32 val = 0;\n\t\t\tsize_t n = read_u32_leb128 (buf + 1, buf + buf_len, &val);\n\t\t\tif (!(n > 0 && n < buf_len)) goto err;\n\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s %d\", opdef->txt, val);\n\t\t\top->len += n;\n\t\t}\n\t\tbreak;\n\tcase WASM_OP_I32LOAD:\n\tcase WASM_OP_I64LOAD:\n\tcase WASM_OP_F32LOAD:\n\tcase WASM_OP_F64LOAD:\n\tcase WASM_OP_I32LOAD8S:\n\tcase WASM_OP_I32LOAD8U:\n\tcase WASM_OP_I32LOAD16S:\n\tcase WASM_OP_I32LOAD16U:\n\tcase WASM_OP_I64LOAD8S:\n\tcase WASM_OP_I64LOAD8U:\n\tcase WASM_OP_I64LOAD16S:\n\tcase WASM_OP_I64LOAD16U:\n\tcase WASM_OP_I64LOAD32S:\n\tcase WASM_OP_I64LOAD32U:\n\tcase WASM_OP_I32STORE:\n\tcase WASM_OP_I64STORE:\n\tcase WASM_OP_F32STORE:\n\tcase WASM_OP_F64STORE:\n\tcase WASM_OP_I32STORE8:\n\tcase WASM_OP_I32STORE16:\n\tcase WASM_OP_I64STORE8:\n\tcase WASM_OP_I64STORE16:\n\tcase WASM_OP_I64STORE32:\n\t\t{\n\t\t\tut32 flag = 0, offset = 0;\n\t\t\tsize_t n = read_u32_leb128 (buf + 1, buf + buf_len, &flag);\n\t\t\tif (!(n > 0 && n < buf_len)) goto err;\n\t\t\top->len += n;\n\t\t\tn = read_u32_leb128 (buf + op->len, buf + buf_len, &offset);\n\t\t\tif (!(n > 0 && op->len + n <= buf_len)) goto err;\n\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s %d %d\", opdef->txt, flag, offset);\n\t\t\top->len += n;\n\t\t}\n\t\tbreak;\n\tcase WASM_OP_CURRENTMEMORY:\n\tcase WASM_OP_GROWMEMORY:\n\t\t{\n\t\t\tut32 reserved = 0;\n\t\t\tsize_t n = read_u32_leb128 (buf + 1, buf + buf_len, &reserved);\n\t\t\tif (!(n == 1 && n < buf_len)) goto err;\n\t\t\treserved &= 0x1;\n\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s %d\", opdef->txt, reserved);\n\t\t\top->len += n;\n\t\t}\n\t\tbreak;\n\n\tcase WASM_OP_I32CONST:\n\t\t{\n\t\t\tst32 val = 0;\n\t\t\tsize_t n = read_i32_leb128 (buf + 1, buf + buf_len, &val);\n\t\t\tif (!(n > 0 && n < buf_len)) goto err;\n\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s %\" PFMT32d, opdef->txt, val);\n\t\t\top->len += n;\n\t\t}\n\t\tbreak;\n\tcase WASM_OP_I64CONST:\n\t\t{\n\t\t\tst64 val = 0;\n\t\t\tsize_t n = read_i64_leb128 (buf + 1, buf + buf_len, &val);\n\t\t\tif (!(n > 0 && n < buf_len)) goto err;\n\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s %\" PFMT64d, opdef->txt, val);\n\t\t\top->len += n;\n\t\t}\n\t\tbreak;\n\tcase WASM_OP_F32CONST:\n\t\t{\n\t\t\tut32 val = 0;\n\t\t\tsize_t n = read_u32_leb128 (buf + 1, buf + buf_len, &val);\n\t\t\tif (!(n > 0 && n < buf_len)) goto err;\n\t\t\tlong double d =  (long double)val;\n\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s %\" LDBLFMT, opdef->txt, d);\n\t\t\top->len += n;\n\t\t}\n\t\tbreak;\n\tcase WASM_OP_F64CONST:\n\t\t{\n\t\t\tut64 val = 0;\n\t\t\tsize_t n = read_u64_leb128 (buf + 1, buf + buf_len, &val);\n\t\t\tif (!(n > 0 && n < buf_len)) goto err;\n\t\t\tlong double d =  (long double)val;\n\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s %\" LDBLFMT, opdef->txt, d);\n\t\t\top->len += n;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tgoto err;\n\t}\n\n\treturn op->len;\n\nerr:\n\top->len = 1;\n\tsnprintf (op->txt, R_ASM_BUFSIZE, \"invalid\");\n\treturn op->len;\n}\n", "target": 1, "idx": 182402}
{"func": "static Image *ReadGROUP4Image(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent];\n\n  FILE\n    *file;\n\n  Image\n    *image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  size_t\n    length;\n\n  ssize_t\n    offset,\n    strip_offset;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Write raw CCITT Group 4 wrapped as a TIFF image file.\n  */\n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(filename);\n  if (unique_file != -1)\n    file=fdopen(unique_file,\"wb\");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    ThrowImageException(FileOpenError,\"UnableToCreateTemporaryFile\");\n  length=fwrite(\"\\111\\111\\052\\000\\010\\000\\000\\000\\016\\000\",1,10,file);\n  length=fwrite(\"\\376\\000\\003\\000\\001\\000\\000\\000\\000\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\000\\001\\004\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,image->columns);\n  length=fwrite(\"\\001\\001\\004\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,image->rows);\n  length=fwrite(\"\\002\\001\\003\\000\\001\\000\\000\\000\\001\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\003\\001\\003\\000\\001\\000\\000\\000\\004\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\006\\001\\003\\000\\001\\000\\000\\000\\000\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\021\\001\\003\\000\\001\\000\\000\\000\",1,8,file);\n  strip_offset=10+(12*14)+4+8;\n  length=WriteLSBLong(file,(size_t) strip_offset);\n  length=fwrite(\"\\022\\001\\003\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(size_t) image_info->orientation);\n  length=fwrite(\"\\025\\001\\003\\000\\001\\000\\000\\000\\001\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\026\\001\\004\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,image->rows);\n  length=fwrite(\"\\027\\001\\004\\000\\001\\000\\000\\000\\000\\000\\000\\000\",1,12,file);\n  offset=(ssize_t) ftell(file)-4;\n  length=fwrite(\"\\032\\001\\005\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(size_t) (strip_offset-8));\n  length=fwrite(\"\\033\\001\\005\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(size_t) (strip_offset-8));\n  length=fwrite(\"\\050\\001\\003\\000\\001\\000\\000\\000\\002\\000\\000\\000\",1,12,file);\n   length=fwrite(\"\\000\\000\\000\\000\",1,4,file);\n   length=WriteLSBLong(file,(long) image->resolution.x);\n   length=WriteLSBLong(file,1);\n   for (length=0; (c=ReadBlobByte(image)) != EOF; length++)\n    (void) fputc(c,file);\n   offset=(ssize_t) fseek(file,(ssize_t) offset,SEEK_SET);\n   length=WriteLSBLong(file,(unsigned int) length);\n   (void) fclose(file);\n  (void) CloseBlob(image);\n  image=DestroyImage(image);\n  /*\n    Read TIFF image.\n  */\n  read_info=CloneImageInfo((ImageInfo *) NULL);\n  (void) FormatLocaleString(read_info->filename,MagickPathExtent,\"%s\",filename);\n  image=ReadTIFFImage(read_info,exception);\n  read_info=DestroyImageInfo(read_info);\n  if (image != (Image *) NULL)\n    {\n      (void) CopyMagickString(image->filename,image_info->filename,\n        MagickPathExtent);\n      (void) CopyMagickString(image->magick_filename,image_info->filename,\n        MagickPathExtent);\n       (void) CopyMagickString(image->magick,\"GROUP4\",MagickPathExtent);\n     }\n   (void) RelinquishUniqueFileResource(filename);\n   return(image);\n }\n", "target": 1, "idx": 181799}
{"func": "static int encrypt(struct blkcipher_desc *desc,\n\t\t   struct scatterlist *dst, struct scatterlist *src,\n\t\t   unsigned int nbytes)\n{\n\tstruct blkcipher_walk walk;\n\tstruct crypto_blkcipher *tfm = desc->tfm;\n\tstruct salsa20_ctx *ctx = crypto_blkcipher_ctx(tfm);\n\tint err;\n\n\tblkcipher_walk_init(&walk, dst, src, nbytes);\n\terr = blkcipher_walk_virt_block(desc, &walk, 64);\n \n \tsalsa20_ivsetup(ctx, walk.iv);\n \n\tif (likely(walk.nbytes == nbytes))\n\t{\n\t\tsalsa20_encrypt_bytes(ctx, walk.dst.virt.addr,\n\t\t\t\t      walk.src.virt.addr, nbytes);\n\t\treturn blkcipher_walk_done(desc, &walk, 0);\n\t}\n \twhile (walk.nbytes >= 64) {\n \t\tsalsa20_encrypt_bytes(ctx, walk.dst.virt.addr,\n \t\t\t\t      walk.src.virt.addr,\n\t\t\t\t      walk.nbytes - (walk.nbytes % 64));\n\t\terr = blkcipher_walk_done(desc, &walk, walk.nbytes % 64);\n\t}\n\n\tif (walk.nbytes) {\n\t\tsalsa20_encrypt_bytes(ctx, walk.dst.virt.addr,\n\t\t\t\t      walk.src.virt.addr, walk.nbytes);\n\t\terr = blkcipher_walk_done(desc, &walk, 0);\n\t}\n\n\treturn err;\n}\n", "target": 1, "idx": 180824}
{"func": "static bool vmxnet3_interrupt_asserted(VMXNET3State *s, int lidx)\n{\n    return s->interrupt_states[lidx].is_asserted;\n}\n", "target": 0, "idx": 9011}
{"func": "  CacheThread() : base::Thread(\"CacheThread_BlockFile\") {\n    CHECK(\n        StartWithOptions(base::Thread::Options(base::MessageLoop::TYPE_IO, 0)));\n  }\n", "target": 0, "idx": 160005}
{"func": "ia64_patch_vtop (unsigned long start, unsigned long end)\n{\n\ts32 *offp = (s32 *) start;\n\tu64 ip;\n\n\twhile (offp < (s32 *) end) {\n\t\tip = (u64) offp + *offp;\n\n\t\t/* replace virtual address with corresponding physical address: */\n\t\tia64_patch_imm64(ip, ia64_tpa(get_imm64(ip)));\n\t\tia64_fc((void *) ip);\n\t\t++offp;\n\t}\n\tia64_sync_i();\n \tia64_srlz_i();\n }\n", "target": 0, "idx": 74756}
{"func": "int _our_safe_pcap_next_ex(pcap_t *pcap, struct pcap_pkthdr **pkthdr,\n        const u_char **pktdata, const char *funcname,\n        const int line, const char *file)\n{\n    int res = pcap_next_ex(pcap, pkthdr, pktdata);\n\n    if (*pktdata && *pkthdr) {\n        if ((*pkthdr)->len > MAXPACKET) {\n            fprintf(stderr, \"safe_pcap_next_ex ERROR: Invalid packet length in %s:%s() line %d: %u is greater than maximum %u\\n\",\n                    file, funcname, line, (*pkthdr)->len, MAXPACKET);\n             exit(-1);\n         }\n \n        if ((*pkthdr)->len < (*pkthdr)->caplen) {\n            fprintf(stderr, \"safe_pcap_next_ex ERROR: Invalid packet length in %s:%s() line %d: packet length %u is less than capture length %u\\n\",\n                     file, funcname, line, (*pkthdr)->len, (*pkthdr)->caplen);\n             exit(-1);\n         }\n    }\n\n    return res;\n}\n", "target": 1, "idx": 182119}
{"func": "load(ImlibImage * im, ImlibProgressFunction progress,\n     char progress_granularity, char immediate_load)\n{\n   int                 rc;\n   char                p = ' ', numbers = 3, count = 0;\n   int                 w = 0, h = 0, v = 255, c = 0;\n   char                buf[256];\n   FILE               *f = NULL;\n\n   if (im->data)\n      return 0;\n   f = fopen(im->real_file, \"rb\");\n   if (!f)\n      return 0;\n\n   /* can't use fgets(), because there might be\n    * binary data after the header and there\n    * needn't be a newline before the data, so\n    * no chance to distinguish between end of buffer\n    * and a binary 0.\n    */\n\n   /* read the header info */\n\n   rc = 0;                      /* Error */\n\n   c = fgetc(f);\n   if (c != 'P')\n      goto quit;\n\n   p = fgetc(f);\n   if (p == '1' || p == '4')\n      numbers = 2;              /* bitimages don't have max value */\n\n   if ((p < '1') || (p > '8'))\n      goto quit;\n\n   count = 0;\n   while (count < numbers)\n     {\n        c = fgetc(f);\n\n        if (c == EOF)\n           goto quit;\n\n        /* eat whitespace */\n        while (isspace(c))\n           c = fgetc(f);\n        /* if comment, eat that */\n        if (c == '#')\n          {\n             do\n                c = fgetc(f);\n             while (c != '\\n' && c != EOF);\n          }\n        /* no comment -> proceed */\n        else\n          {\n             int                 i = 0;\n\n             /* read numbers */\n             while (c != EOF && !isspace(c) && (i < 255))\n               {\n                  buf[i++] = c;\n                  c = fgetc(f);\n               }\n             if (i)\n               {\n                  buf[i] = 0;\n                  count++;\n                  switch (count)\n                    {\n                       /* width */\n                    case 1:\n                       w = atoi(buf);\n                       break;\n                       /* height */\n                    case 2:\n                       h = atoi(buf);\n                       break;\n                       /* max value, only for color and greyscale */\n                    case 3:\n                       v = atoi(buf);\n                       break;\n                    }\n               }\n          }\n     }\n   if ((v < 0) || (v > 255))\n      goto quit;\n\n   im->w = w;\n   im->h = h;\n   if (!IMAGE_DIMENSIONS_OK(w, h))\n      goto quit;\n\n   if (!im->format)\n     {\n        if (p == '8')\n           SET_FLAG(im->flags, F_HAS_ALPHA);\n        else\n           UNSET_FLAG(im->flags, F_HAS_ALPHA);\n        im->format = strdup(\"pnm\");\n     }\n\n   rc = 1;                      /* Ok */\n\n   if (((!im->data) && (im->loader)) || (immediate_load) || (progress))\n     {\n        DATA8              *data = NULL;        /* for the binary versions */\n        DATA8              *ptr = NULL;\n        int                *idata = NULL;       /* for the ASCII versions */\n        int                *iptr;\n        char                buf2[256];\n        DATA32             *ptr2;\n        int                 i, j, x, y, pl = 0;\n        char                pper = 0;\n\n        /* must set the im->data member before callign progress function */\n        ptr2 = im->data = malloc(w * h * sizeof(DATA32));\n        if (!im->data)\n           goto quit_error;\n\n        /* start reading the data */\n        switch (p)\n          {\n          case '1':            /* ASCII monochrome */\n             buf[0] = 0;\n             i = 0;\n             for (y = 0; y < h; y++)\n               {\n                  x = 0;\n                  while (x < w)\n                    {\n                       if (!buf[i])     /* fill buffer */\n                         {\n                            if (!fgets(buf, 255, f))\n                               goto quit_error;\n                            i = 0;\n                         }\n                       while (buf[i] && isspace(buf[i]))\n                          i++;\n                       if (buf[i])\n                         {\n                            if (buf[i] == '1')\n                               *ptr2 = 0xff000000;\n                            else if (buf[i] == '0')\n                               *ptr2 = 0xffffffff;\n                            else\n                               goto quit_error;\n                            ptr2++;\n                            i++;\n                         }\n                    }\n                  if (progress &&\n                      do_progress(im, progress, progress_granularity,\n                                  &pper, &pl, y))\n                     goto quit_progress;\n               }\n             break;\n          case '2':            /* ASCII greyscale */\n             idata = malloc(sizeof(int) * w);\n             if (!idata)\n                goto quit_error;\n\n             buf[0] = 0;\n             i = 0;\n             j = 0;\n             for (y = 0; y < h; y++)\n               {\n                  iptr = idata;\n                  x = 0;\n                  while (x < w)\n                    {\n                       int                 k;\n\n                       /* check 4 chars ahead to see if we need to\n                        * fill the buffer */\n                       for (k = 0; k < 4; k++)\n                         {\n                            if (!buf[i + k])    /* fill buffer */\n                              {\n                                 if (fseek(f, -k, SEEK_CUR) == -1 ||\n                                     !fgets(buf, 255, f))\n                                    goto quit_error;\n                                 i = 0;\n                                 break;\n                              }\n                         }\n                       while (buf[i] && isspace(buf[i]))\n                          i++;\n                       while (buf[i] && !isspace(buf[i]))\n                          buf2[j++] = buf[i++];\n                       if (j)\n                         {\n                            buf2[j] = 0;\n                            *(iptr++) = atoi(buf2);\n                            j = 0;\n                            x++;\n                          }\n                     }\n                   iptr = idata;\n                  if (v == 255)\n                     {\n                        for (x = 0; x < w; x++)\n                          {\n                            *ptr2 =\n                               0xff000000 | (iptr[0] << 16) | (iptr[0] << 8)\n                               | iptr[0];\n                            ptr2++;\n                            iptr++;\n                         }\n                    }\n                  else\n                    {\n                       for (x = 0; x < w; x++)\n                         {\n                            *ptr2 =\n                               0xff000000 |\n                               (((iptr[0] * 255) / v) << 16) |\n                               (((iptr[0] * 255) / v) << 8) |\n                               ((iptr[0] * 255) / v);\n                            ptr2++;\n                            iptr++;\n                         }\n                    }\n                  if (progress &&\n                      do_progress(im, progress, progress_granularity,\n                                  &pper, &pl, y))\n                     goto quit_progress;\n               }\n             break;\n          case '3':            /* ASCII RGB */\n             idata = malloc(3 * sizeof(int) * w);\n             if (!idata)\n                goto quit_error;\n\n             buf[0] = 0;\n             i = 0;\n             j = 0;\n             for (y = 0; y < h; y++)\n               {\n                  int                 w3 = 3 * w;\n\n                  iptr = idata;\n                  x = 0;\n                  while (x < w3)\n                    {\n                       int                 k;\n\n                       /* check 4 chars ahead to see if we need to\n                        * fill the buffer */\n                       for (k = 0; k < 4; k++)\n                         {\n                            if (!buf[i + k])    /* fill buffer */\n                              {\n                                 if (fseek(f, -k, SEEK_CUR) == -1 ||\n                                     !fgets(buf, 255, f))\n                                    goto quit_error;\n                                 i = 0;\n                                 break;\n                              }\n                         }\n                       while (buf[i] && isspace(buf[i]))\n                          i++;\n                       while (buf[i] && !isspace(buf[i]))\n                          buf2[j++] = buf[i++];\n                       if (j)\n                         {\n                            buf2[j] = 0;\n                            *(iptr++) = atoi(buf2);\n                            j = 0;\n                            x++;\n                          }\n                     }\n                   iptr = idata;\n                  if (v == 255)\n                     {\n                        for (x = 0; x < w; x++)\n                          {\n                            *ptr2 =\n                               0xff000000 | (iptr[0] << 16) | (iptr[1] << 8)\n                               | iptr[2];\n                            ptr2++;\n                            iptr += 3;\n                         }\n                    }\n                  else\n                    {\n                       for (x = 0; x < w; x++)\n                         {\n                            *ptr2 =\n                               0xff000000 |\n                               (((iptr[0] * 255) / v) << 16) |\n                               (((iptr[1] * 255) / v) << 8) |\n                               ((iptr[2] * 255) / v);\n                            ptr2++;\n                            iptr += 3;\n                         }\n                    }\n                  if (progress &&\n                      do_progress(im, progress, progress_granularity,\n                                  &pper, &pl, y))\n                     goto quit_progress;\n               }\n             break;\n          case '4':            /* binary 1bit monochrome */\n             data = malloc((w + 7) / 8 * sizeof(DATA8));\n             if (!data)\n                goto quit_error;\n\n             ptr2 = im->data;\n             for (y = 0; y < h; y++)\n               {\n                  if (!fread(data, (w + 7) / 8, 1, f))\n                     goto quit_error;\n\n                  ptr = data;\n                  for (x = 0; x < w; x += 8)\n                    {\n                       j = (w - x >= 8) ? 8 : w - x;\n                       for (i = 0; i < j; i++)\n                         {\n                            if (ptr[0] & (0x80 >> i))\n                               *ptr2 = 0xff000000;\n                            else\n                               *ptr2 = 0xffffffff;\n                            ptr2++;\n                         }\n                       ptr++;\n                    }\n                  if (progress &&\n                      do_progress(im, progress, progress_granularity,\n                                  &pper, &pl, y))\n                     goto quit_progress;\n               }\n             break;\n          case '5':            /* binary 8bit grayscale GGGGGGGG */\n             data = malloc(1 * sizeof(DATA8) * w);\n             if (!data)\n                goto quit_error;\n\n             ptr2 = im->data;\n             for (y = 0; y < h; y++)\n               {\n                  if (!fread(data, w * 1, 1, f))\n                      break;\n \n                   ptr = data;\n                  if (v == 255)\n                     {\n                        for (x = 0; x < w; x++)\n                          {\n                            *ptr2 =\n                               0xff000000 | (ptr[0] << 16) | (ptr[0] << 8) |\n                               ptr[0];\n                            ptr2++;\n                            ptr++;\n                         }\n                    }\n                  else\n                    {\n                       for (x = 0; x < w; x++)\n                         {\n                            *ptr2 =\n                               0xff000000 |\n                               (((ptr[0] * 255) / v) << 16) |\n                               (((ptr[0] * 255) / v) << 8) |\n                               ((ptr[0] * 255) / v);\n                            ptr2++;\n                            ptr++;\n                         }\n                    }\n                  if (progress &&\n                      do_progress(im, progress, progress_granularity,\n                                  &pper, &pl, y))\n                     goto quit_progress;\n               }\n             break;\n          case '6':            /* 24bit binary RGBRGBRGB */\n             data = malloc(3 * sizeof(DATA8) * w);\n             if (!data)\n                goto quit_error;\n\n             ptr2 = im->data;\n             for (y = 0; y < h; y++)\n               {\n                  if (!fread(data, w * 3, 1, f))\n                      break;\n \n                   ptr = data;\n                  if (v == 255)\n                     {\n                        for (x = 0; x < w; x++)\n                          {\n                            *ptr2 =\n                               0xff000000 | (ptr[0] << 16) | (ptr[1] << 8) |\n                               ptr[2];\n                            ptr2++;\n                            ptr += 3;\n                         }\n                    }\n                  else\n                    {\n                       for (x = 0; x < w; x++)\n                         {\n                            *ptr2 =\n                               0xff000000 |\n                               (((ptr[0] * 255) / v) << 16) |\n                               (((ptr[1] * 255) / v) << 8) |\n                               ((ptr[2] * 255) / v);\n                            ptr2++;\n                            ptr += 3;\n                         }\n                    }\n                  if (progress &&\n                      do_progress(im, progress, progress_granularity,\n                                  &pper, &pl, y))\n                     goto quit_progress;\n               }\n             break;\n          case '7':            /* XV's 8bit 332 format */\n             data = malloc(1 * sizeof(DATA8) * w);\n             if (!data)\n                goto quit_error;\n\n             ptr2 = im->data;\n             for (y = 0; y < h; y++)\n               {\n                  if (!fread(data, w * 1, 1, f))\n                     break;\n\n                  ptr = data;\n                  for (x = 0; x < w; x++)\n                    {\n                       int                 r, g, b;\n\n                       r = (*ptr >> 5) & 0x7;\n                       g = (*ptr >> 2) & 0x7;\n                       b = (*ptr) & 0x3;\n                       *ptr2 =\n                          0xff000000 |\n                          (((r << 21) | (r << 18) | (r << 15)) & 0xff0000) |\n                          (((g << 13) | (g << 10) | (g << 7)) & 0xff00) |\n                          ((b << 6) | (b << 4) | (b << 2) | (b << 0));\n                       ptr2++;\n                       ptr++;\n                    }\n                  if (progress &&\n                      do_progress(im, progress, progress_granularity,\n                                  &pper, &pl, y))\n                     goto quit_progress;\n               }\n             break;\n          case '8':            /* 24bit binary RGBARGBARGBA */\n             data = malloc(4 * sizeof(DATA8) * w);\n             if (!data)\n                goto quit_error;\n\n             ptr2 = im->data;\n             for (y = 0; y < h; y++)\n               {\n                  if (!fread(data, w * 4, 1, f))\n                      break;\n \n                   ptr = data;\n                  if (v == 255)\n                     {\n                        for (x = 0; x < w; x++)\n                          {\n                            *ptr2 =\n                               (ptr[3] << 24) | (ptr[0] << 16) |\n                               (ptr[1] << 8) | ptr[2];\n                            ptr2++;\n                            ptr += 4;\n                         }\n                    }\n                  else\n                    {\n                       for (x = 0; x < w; x++)\n                         {\n                            *ptr2 =\n                               (((ptr[3] * 255) / v) << 24) |\n                               (((ptr[0] * 255) / v) << 16) |\n                               (((ptr[1] * 255) / v) << 8) |\n                               ((ptr[2] * 255) / v);\n                            ptr2++;\n                            ptr += 4;\n                         }\n                    }\n                  if (progress &&\n                      do_progress(im, progress, progress_granularity,\n                                  &pper, &pl, y))\n                     goto quit_progress;\n               }\n             break;\n          default:\n           quit_error:\n             rc = 0;\n             break;\n           quit_progress:\n             rc = 2;\n             break;\n          }\n        if (idata)\n           free(idata);\n        if (data)\n           free(data);\n     }\n quit:\n   fclose(f);\n   return rc;\n}\n", "target": 1, "idx": 178511}
{"func": "void OmniboxEditModel::OnWillKillFocus(gfx::NativeView view_gaining_focus) {\n  if (user_input_in_progress_ || !in_revert_)\n    delegate_->OnInputStateChanged();\n}\n", "target": 0, "idx": 119350}
{"func": "static int em_sysenter(struct x86_emulate_ctxt *ctxt)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tstruct desc_struct cs, ss;\n\tu64 msr_data;\n\tu16 cs_sel, ss_sel;\n\tu64 efer = 0;\n\n\tops->get_msr(ctxt, MSR_EFER, &efer);\n\t/* inject #GP if in real mode */\n\tif (ctxt->mode == X86EMUL_MODE_REAL)\n\t\treturn emulate_gp(ctxt, 0);\n\n\t/*\n \t * Not recognized on AMD in compat mode (but is recognized in legacy\n \t * mode).\n \t */\n\tif ((ctxt->mode == X86EMUL_MODE_PROT32) && (efer & EFER_LMA)\n \t    && !vendor_intel(ctxt))\n \t\treturn emulate_ud(ctxt);\n \n\t/* sysenter/sysexit have not been tested in 64bit mode. */\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\treturn X86EMUL_UNHANDLEABLE;\n\n \tsetup_syscalls_segments(ctxt, &cs, &ss);\n \n \tops->get_msr(ctxt, MSR_IA32_SYSENTER_CS, &msr_data);\n\tswitch (ctxt->mode) {\n\tcase X86EMUL_MODE_PROT32:\n\t\tif ((msr_data & 0xfffc) == 0x0)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tbreak;\n\tcase X86EMUL_MODE_PROT64:\n\t\tif (msr_data == 0x0)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n \n \tctxt->eflags &= ~(EFLG_VM | EFLG_IF);\n\tcs_sel = (u16)msr_data;\n\tcs_sel &= ~SELECTOR_RPL_MASK;\n \tss_sel = cs_sel + 8;\n\tss_sel &= ~SELECTOR_RPL_MASK;\n\tif (ctxt->mode == X86EMUL_MODE_PROT64 || (efer & EFER_LMA)) {\n \t\tcs.d = 0;\n \t\tcs.l = 1;\n \t}\n\n\tops->set_segment(ctxt, cs_sel, &cs, 0, VCPU_SREG_CS);\n \tops->set_segment(ctxt, ss_sel, &ss, 0, VCPU_SREG_SS);\n \n \tops->get_msr(ctxt, MSR_IA32_SYSENTER_EIP, &msr_data);\n\tctxt->_eip = msr_data;\n \n \tops->get_msr(ctxt, MSR_IA32_SYSENTER_ESP, &msr_data);\n\t*reg_write(ctxt, VCPU_REGS_RSP) = msr_data;\n \n \treturn X86EMUL_CONTINUE;\n }\n", "target": 1, "idx": 179914}
{"func": "Plugin::~Plugin() {\n  int64_t shutdown_start = NaClGetTimeOfDayMicroseconds();\n\n  PLUGIN_PRINTF((\"Plugin::~Plugin (this=%p, scriptable_plugin=%p)\\n\",\n                 static_cast<void*>(this),\n                 static_cast<void*>(scriptable_plugin())));\n  pnacl_coordinator_.reset(NULL);\n  if (ppapi_proxy_ != NULL) {\n    HistogramTimeLarge(\n        \"NaCl.ModuleUptime.Normal\",\n        (shutdown_start - ready_time_) / NACL_MICROS_PER_MILLI);\n  }\n\n  url_downloaders_.erase(url_downloaders_.begin(), url_downloaders_.end());\n\n  ShutdownProxy();\n  ScriptablePlugin* scriptable_plugin_ = scriptable_plugin();\n  ScriptablePlugin::Unref(&scriptable_plugin_);\n\n  ShutDownSubprocesses();\n\n  delete wrapper_factory_;\n  delete[] argv_;\n  delete[] argn_;\n\n  HistogramTimeSmall(\n      \"NaCl.Perf.ShutdownTime.Total\",\n      (NaClGetTimeOfDayMicroseconds() - shutdown_start)\n          / NACL_MICROS_PER_MILLI);\n\n  PLUGIN_PRINTF((\"Plugin::~Plugin (this=%p, return)\\n\",\n                 static_cast<void*>(this)));\n}\n", "target": 0, "idx": 110361}
{"func": "std::string GetStoreIdFromProfile(Profile* profile) {\n   DCHECK(profile);\n   return profile->IsOffTheRecord() ?\n       kOffTheRecordProfileStoreId : kOriginalProfileStoreId;\n}\n", "target": 1, "idx": 183475}
{"func": "gfx::Size GLES2DecoderImpl::GetBoundReadFrameBufferSize() {\n  Framebuffer* framebuffer =\n      GetFramebufferInfoForTarget(GL_READ_FRAMEBUFFER_EXT);\n  if (framebuffer != NULL) {\n    const Framebuffer::Attachment* attachment =\n        framebuffer->GetAttachment(GL_COLOR_ATTACHMENT0);\n    if (attachment) {\n      return gfx::Size(attachment->width(), attachment->height());\n    }\n    return gfx::Size(0, 0);\n  } else if (offscreen_target_frame_buffer_.get()) {\n    return offscreen_size_;\n  } else {\n    return surface_->GetSize();\n  }\n}\n", "target": 0, "idx": 129364}
{"func": "void AppControllerImpl::LaunchApp(const std::string& app_id) {\n   app_service_proxy_->Launch(app_id, ui::EventFlags::EF_NONE,\n                              apps::mojom::LaunchSource::kFromAppListGrid,\n                              display::kDefaultDisplayId);\n }\n", "target": 1, "idx": 185997}
{"func": "v8::Local<v8::Object> V8InjectedScriptHost::create(v8::Local<v8::Context> context, V8InspectorImpl* inspector)\n {\n     v8::Isolate* isolate = inspector->isolate();\n     v8::Local<v8::Object> injectedScriptHost = v8::Object::New(isolate);\n     v8::Local<v8::External> debuggerExternal = v8::External::New(isolate, inspector);\n     setFunctionProperty(context, injectedScriptHost, \"internalConstructorName\", V8InjectedScriptHost::internalConstructorNameCallback, debuggerExternal);\n     setFunctionProperty(context, injectedScriptHost, \"formatAccessorsAsProperties\", V8InjectedScriptHost::formatAccessorsAsProperties, debuggerExternal);\n    setFunctionProperty(context, injectedScriptHost, \"subtype\", V8InjectedScriptHost::subtypeCallback, debuggerExternal);\n    setFunctionProperty(context, injectedScriptHost, \"getInternalProperties\", V8InjectedScriptHost::getInternalPropertiesCallback, debuggerExternal);\n    setFunctionProperty(context, injectedScriptHost, \"objectHasOwnProperty\", V8InjectedScriptHost::objectHasOwnPropertyCallback, debuggerExternal);\n    setFunctionProperty(context, injectedScriptHost, \"bind\", V8InjectedScriptHost::bindCallback, debuggerExternal);\n    setFunctionProperty(context, injectedScriptHost, \"proxyTargetValue\", V8InjectedScriptHost::proxyTargetValueCallback, debuggerExternal);\n    return injectedScriptHost;\n}\n", "target": 1, "idx": 185982}
{"func": "dns_resolver_match(const struct key *key,\n\t\t   const struct key_match_data *match_data)\n {\n \tint slen, dlen, ret = 0;\n \tconst char *src = key->description, *dsp = match_data->raw_data;\n\n\tkenter(\"%s,%s\", src, dsp);\n\n\tif (!src || !dsp)\n\t\tgoto no_match;\n\n\tif (strcasecmp(src, dsp) == 0)\n\t\tgoto matched;\n\n\tslen = strlen(src);\n\tdlen = strlen(dsp);\n\tif (slen <= 0 || dlen <= 0)\n\t\tgoto no_match;\n\tif (src[slen - 1] == '.')\n\t\tslen--;\n\tif (dsp[dlen - 1] == '.')\n\t\tdlen--;\n\tif (slen != dlen || strncasecmp(src, dsp, slen) != 0)\n\t\tgoto no_match;\n\nmatched:\n\tret = 1;\nno_match:\n\tkleave(\" = %d\", ret);\n \treturn ret;\n }\n", "target": 1, "idx": 181610}
{"func": "int WebContentsImpl::DownloadImage(\n    const GURL& url,\n    bool is_favicon,\n    uint32_t max_bitmap_size,\n    bool bypass_cache,\n    const WebContents::ImageDownloadCallback& callback) {\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n  static int next_image_download_id = 0;\n  const image_downloader::ImageDownloaderPtr& mojo_image_downloader =\n      GetMainFrame()->GetMojoImageDownloader();\n  const int download_id = ++next_image_download_id;\n  if (!mojo_image_downloader) {\n     BrowserThread::PostTask(\n         BrowserThread::UI, FROM_HERE,\n        base::Bind(&WebContents::ImageDownloadCallback::Run,\n                   base::Owned(new ImageDownloadCallback(callback)),\n                   download_id, 400, url, std::vector<SkBitmap>(),\n                   std::vector<gfx::Size>()));\n     return download_id;\n   }\n \n  image_downloader::DownloadRequestPtr req =\n      image_downloader::DownloadRequest::New();\n\n  req->url = mojo::String::From(url);\n  req->is_favicon = is_favicon;\n  req->max_bitmap_size = max_bitmap_size;\n   req->bypass_cache = bypass_cache;\n \n   mojo_image_downloader->DownloadImage(\n      std::move(req),\n      base::Bind(&DidDownloadImage, callback, download_id, url));\n   return download_id;\n }\n", "target": 1, "idx": 186178}
{"func": "error_detected(uint32_t errnum, char *errstr, ...)\n{\n    va_list args;\n\n    va_start(args, errstr);\n\n    {\n        TSK_ERROR_INFO *errInfo = tsk_error_get_info();\n        char *loc_errstr = errInfo->errstr;\n\n        if (errInfo->t_errno == 0)\n            errInfo->t_errno = errnum;\n        else {\n            size_t sl = strlen(errstr);\n            snprintf(loc_errstr + sl, TSK_ERROR_STRING_MAX_LENGTH - sl,\n                \" Next errnum: 0x%x \", errnum);\n        }\n        if (errstr != NULL) {\n            size_t sl = strlen(loc_errstr);\n            vsnprintf(loc_errstr + sl, TSK_ERROR_STRING_MAX_LENGTH - sl,\n                errstr, args);\n        }\n    }\n\n    va_end(args);\n\n}\n", "target": 0, "idx": 75665}
{"func": "static int rfcomm_sock_create(struct net *net, struct socket *sock,\n\t\t\t      int protocol, int kern)\n{\n\tstruct sock *sk;\n\n\tBT_DBG(\"sock %p\", sock);\n\n\tsock->state = SS_UNCONNECTED;\n\n\tif (sock->type != SOCK_STREAM && sock->type != SOCK_RAW)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tsock->ops = &rfcomm_sock_ops;\n\n\tsk = rfcomm_sock_alloc(net, sock, protocol, GFP_ATOMIC);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\n\trfcomm_sock_init(sk, NULL);\n\treturn 0;\n}\n", "target": 0, "idx": 30734}
{"func": "error::Error GLES2DecoderPassthroughImpl::DoGetAttribLocation(GLuint program,\n                                                              const char* name,\n                                                              GLint* result) {\n  *result = api()->glGetAttribLocationFn(\n      GetProgramServiceID(program, resources_), name);\n  return error::kNoError;\n}\n", "target": 0, "idx": 154678}
{"func": " SPL_METHOD(RecursiveDirectoryIterator, getSubPath)\n {\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n\n\tif (intern->u.dir.sub_path) {\n\t\tRETURN_STRINGL(intern->u.dir.sub_path, intern->u.dir.sub_path_len, 1);\n\t} else {\n\t\tRETURN_STRINGL(\"\", 0, 1);\n\t}\n}\n", "target": 1, "idx": 180218}
{"func": "static int inet6_create(struct net *net, struct socket *sock, int protocol,\n\t\t\tint kern)\n{\n\tstruct inet_sock *inet;\n\tstruct ipv6_pinfo *np;\n\tstruct sock *sk;\n\tstruct inet_protosw *answer;\n\tstruct proto *answer_prot;\n\tunsigned char answer_flags;\n \tint try_loading_module = 0;\n \tint err;\n \n \t/* Look for the requested type/protocol pair. */\n lookup_protocol:\n \terr = -ESOCKTNOSUPPORT;\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(answer, &inetsw6[sock->type], list) {\n\n\t\terr = 0;\n\t\t/* Check the non-wild match. */\n\t\tif (protocol == answer->protocol) {\n\t\t\tif (protocol != IPPROTO_IP)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t/* Check for the two wild cases. */\n\t\t\tif (IPPROTO_IP == protocol) {\n\t\t\t\tprotocol = answer->protocol;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (IPPROTO_IP == answer->protocol)\n\t\t\t\tbreak;\n\t\t}\n\t\terr = -EPROTONOSUPPORT;\n\t}\n\n\tif (err) {\n\t\tif (try_loading_module < 2) {\n\t\t\trcu_read_unlock();\n\t\t\t/*\n\t\t\t * Be more specific, e.g. net-pf-10-proto-132-type-1\n\t\t\t * (net-pf-PF_INET6-proto-IPPROTO_SCTP-type-SOCK_STREAM)\n\t\t\t */\n\t\t\tif (++try_loading_module == 1)\n\t\t\t\trequest_module(\"net-pf-%d-proto-%d-type-%d\",\n\t\t\t\t\t\tPF_INET6, protocol, sock->type);\n\t\t\t/*\n\t\t\t * Fall back to generic, e.g. net-pf-10-proto-132\n\t\t\t * (net-pf-PF_INET6-proto-IPPROTO_SCTP)\n\t\t\t */\n\t\t\telse\n\t\t\t\trequest_module(\"net-pf-%d-proto-%d\",\n\t\t\t\t\t\tPF_INET6, protocol);\n\t\t\tgoto lookup_protocol;\n\t\t} else\n\t\t\tgoto out_rcu_unlock;\n\t}\n\n\terr = -EPERM;\n\tif (sock->type == SOCK_RAW && !kern &&\n\t    !ns_capable(net->user_ns, CAP_NET_RAW))\n\t\tgoto out_rcu_unlock;\n\n\tsock->ops = answer->ops;\n\tanswer_prot = answer->prot;\n\tanswer_flags = answer->flags;\n\trcu_read_unlock();\n\n\tWARN_ON(!answer_prot->slab);\n\n\terr = -ENOBUFS;\n\tsk = sk_alloc(net, PF_INET6, GFP_KERNEL, answer_prot, kern);\n\tif (!sk)\n\t\tgoto out;\n\n\tsock_init_data(sock, sk);\n\n\terr = 0;\n\tif (INET_PROTOSW_REUSE & answer_flags)\n\t\tsk->sk_reuse = SK_CAN_REUSE;\n\n\tinet = inet_sk(sk);\n\tinet->is_icsk = (INET_PROTOSW_ICSK & answer_flags) != 0;\n\n\tif (SOCK_RAW == sock->type) {\n\t\tinet->inet_num = protocol;\n\t\tif (IPPROTO_RAW == protocol)\n\t\t\tinet->hdrincl = 1;\n\t}\n\n\tsk->sk_destruct\t\t= inet_sock_destruct;\n\tsk->sk_family\t\t= PF_INET6;\n\tsk->sk_protocol\t\t= protocol;\n\n\tsk->sk_backlog_rcv\t= answer->prot->backlog_rcv;\n\n\tinet_sk(sk)->pinet6 = np = inet6_sk_generic(sk);\n\tnp->hop_limit\t= -1;\n\tnp->mcast_hops\t= IPV6_DEFAULT_MCASTHOPS;\n\tnp->mc_loop\t= 1;\n\tnp->pmtudisc\t= IPV6_PMTUDISC_WANT;\n\tnp->autoflowlabel = ip6_default_np_autolabel(sock_net(sk));\n\tsk->sk_ipv6only\t= net->ipv6.sysctl.bindv6only;\n\n\t/* Init the ipv4 part of the socket since we can have sockets\n\t * using v6 API for ipv4.\n\t */\n\tinet->uc_ttl\t= -1;\n\n\tinet->mc_loop\t= 1;\n\tinet->mc_ttl\t= 1;\n\tinet->mc_index\t= 0;\n\tinet->mc_list\t= NULL;\n\tinet->rcv_tos\t= 0;\n\n\tif (net->ipv4.sysctl_ip_no_pmtu_disc)\n\t\tinet->pmtudisc = IP_PMTUDISC_DONT;\n\telse\n\t\tinet->pmtudisc = IP_PMTUDISC_WANT;\n\t/*\n\t * Increment only the relevant sk_prot->socks debug field, this changes\n\t * the previous behaviour of incrementing both the equivalent to\n\t * answer->prot->socks (inet6_sock_nr) and inet_sock_nr.\n\t *\n\t * This allows better debug granularity as we'll know exactly how many\n\t * UDPv6, TCPv6, etc socks were allocated, not the sum of all IPv6\n\t * transport protocol socks. -acme\n\t */\n\tsk_refcnt_debug_inc(sk);\n\n\tif (inet->inet_num) {\n\t\t/* It assumes that any protocol which allows\n\t\t * the user to assign a number at socket\n\t\t * creation time automatically shares.\n\t\t */\n\t\tinet->inet_sport = htons(inet->inet_num);\n\t\tsk->sk_prot->hash(sk);\n\t}\n\tif (sk->sk_prot->init) {\n\t\terr = sk->sk_prot->init(sk);\n\t\tif (err) {\n\t\t\tsk_common_release(sk);\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\treturn err;\nout_rcu_unlock:\n\trcu_read_unlock();\n\tgoto out;\n}\n", "target": 1, "idx": 179737}
{"func": "bool GLES2Decoder::GetServiceTextureId(uint32_t client_texture_id,\n                                       uint32_t* service_texture_id) {\n  return false;\n}\n", "target": 0, "idx": 154182}
{"func": " static int inotify_release(struct inode *ignored, struct file *file)\n {\n \tstruct fsnotify_group *group = file->private_data;\n\tstruct user_struct *user = group->inotify_data.user;\n \n \tpr_debug(\"%s: group=%p\\n\", __func__, group);\n \n\tfsnotify_clear_marks_by_group(group);\n\n \t/* free this group, matching get was inotify_init->fsnotify_obtain_group */\n \tfsnotify_put_group(group);\n \n\tatomic_dec(&user->inotify_devs);\n \treturn 0;\n }\n", "target": 1, "idx": 179061}
{"func": "  bool StopInputMethodProcess() {\n     if (!IBusConnectionsAreAlive()) {\n       LOG(ERROR) << \"StopInputMethodProcess: IBus connection is not alive\";\n       return false;\n    }\n\n    ibus_bus_exit_async(ibus_,\n                        FALSE  /* do not restart */,\n                        -1  /* timeout */,\n                        NULL  /* cancellable */,\n                        NULL  /* callback */,\n                        NULL  /* user_data */);\n\n    if (ibus_config_) {\n      g_object_unref(ibus_config_);\n      ibus_config_ = NULL;\n    }\n     return true;\n   }\n", "target": 1, "idx": 184006}
{"func": "  static void UpdatePropertyCallback(IBusPanelService* panel,\n                                     IBusProperty* ibus_prop,\n                                     gpointer user_data) {\n    g_return_if_fail(user_data);\n    InputMethodStatusConnection* self\n        = static_cast<InputMethodStatusConnection*>(user_data);\n    self->UpdateProperty(ibus_prop);\n   }\n", "target": 1, "idx": 184008}
{"func": "void HostPortAllocatorSession::OnSessionRequestDone(\n    UrlFetcher* url_fetcher,\n    const net::URLRequestStatus& status,\n    int response_code,\n    const std::string& response) {\n  url_fetchers_.erase(url_fetcher);\n  delete url_fetcher;\n \n  if (response_code != net::HTTP_OK) {\n     LOG(WARNING) << \"Received error when allocating relay session: \"\n                 << response_code;\n     TryCreateRelaySession();\n     return;\n   }\n \n   ReceiveSessionResponse(response);\n }\n", "target": 1, "idx": 184384}
{"func": "static void nonpaging_invlpg(struct kvm_vcpu *vcpu, gva_t gva)\n{\n}\n", "target": 0, "idx": 37555}
{"func": "void AffineTransform::recompose(const DecomposedType& decomp)\n{\n    this->setA(decomp.remainderA);\n    this->setB(decomp.remainderB);\n    this->setC(decomp.remainderC);\n    this->setD(decomp.remainderD);\n    this->setE(decomp.translateX);\n    this->setF(decomp.translateY);\n    this->rotateRadians(decomp.angle);\n    this->scale(decomp.scaleX, decomp.scaleY);\n}\n", "target": 0, "idx": 129662}
{"func": "bool LayerTreeHost::PaintContent(const LayerList& update_layer_list,\n                                 bool* content_is_suitable_for_gpu) {\n  base::AutoReset<bool> painting(&in_paint_layer_contents_, true);\n  bool did_paint_content = false;\n  for (const auto& layer : update_layer_list) {\n    did_paint_content |= layer->Update();\n    *content_is_suitable_for_gpu &= layer->IsSuitableForGpuRasterization();\n  }\n  return did_paint_content;\n}\n", "target": 0, "idx": 149814}
{"func": "inline gl::GLApi* BackTexture::api() const {\n  return decoder_->api();\n}\n", "target": 0, "idx": 154396}
{"func": "PHP_FUNCTION(openssl_verify)\n{\n\tzval **key;\n\tEVP_PKEY *pkey;\n\tint err;\n\tEVP_MD_CTX     md_ctx;\n\tconst EVP_MD *mdtype;\n\tlong keyresource = -1;\n\tchar * data;\tint data_len;\n\tchar * signature;\tint signature_len;\n\tzval *method = NULL;\n\tlong signature_algo = OPENSSL_ALGO_SHA1;\n\t\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ssZ|z\", &data, &data_len, &signature, &signature_len, &key, &method) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (method == NULL || Z_TYPE_P(method) == IS_LONG) {\n\t\tif (method != NULL) {\n\t\t\tsignature_algo = Z_LVAL_P(method);\n\t\t}\n\t\tmdtype = php_openssl_get_evp_md_from_algo(signature_algo);\n\t} else if (Z_TYPE_P(method) == IS_STRING) {\n\t\tmdtype = EVP_get_digestbyname(Z_STRVAL_P(method));\n\t} else {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unknown signature algorithm.\");\n\t\tRETURN_FALSE;\n\t}\n\tif (!mdtype) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unknown signature algorithm.\");\n\t\tRETURN_FALSE;\n\t}\n\n\tpkey = php_openssl_evp_from_zval(key, 1, NULL, 0, &keyresource TSRMLS_CC);\n\tif (pkey == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"supplied key param cannot be coerced into a public key\");\n\t\tRETURN_FALSE;\n\t}\n\n\tEVP_VerifyInit   (&md_ctx, mdtype);\n\tEVP_VerifyUpdate (&md_ctx, data, data_len);\n\terr = EVP_VerifyFinal (&md_ctx, (unsigned char *)signature, signature_len, pkey);\n\tEVP_MD_CTX_cleanup(&md_ctx);\n\n\tif (keyresource == -1) {\n\t\tEVP_PKEY_free(pkey);\n\t}\n\tRETURN_LONG(err);\n}\n", "target": 0, "idx": 127}
{"func": "void InspectorTraceEvents::Did(const probe::ParseHTML& probe) {\n  TRACE_EVENT_END1(\n      \"devtools.timeline\", \"ParseHTML\", \"endData\",\n      InspectorParseHtmlEndData(probe.parser->LineNumber().ZeroBasedInt() - 1));\n  TRACE_EVENT_INSTANT1(TRACE_DISABLED_BY_DEFAULT(\"devtools.timeline\"),\n                       \"UpdateCounters\", TRACE_EVENT_SCOPE_THREAD, \"data\",\n                       InspectorUpdateCountersEvent::Data());\n}\n", "target": 0, "idx": 151338}
{"func": "bool ChromeClientImpl::AcceptsLoadDrops() const {\n  return !web_view_->Client() || web_view_->Client()->AcceptsLoadDrops();\n}\n", "target": 0, "idx": 160924}
{"func": "PP_InputEvent_Type ConvertEventTypes(WebInputEvent::Type wetype) {\n  switch (wetype) {\n    case WebInputEvent::MouseDown:\n      return PP_INPUTEVENT_TYPE_MOUSEDOWN;\n    case WebInputEvent::MouseUp:\n      return PP_INPUTEVENT_TYPE_MOUSEUP;\n    case WebInputEvent::MouseMove:\n      return PP_INPUTEVENT_TYPE_MOUSEMOVE;\n    case WebInputEvent::MouseEnter:\n       return PP_INPUTEVENT_TYPE_MOUSEENTER;\n     case WebInputEvent::MouseLeave:\n       return PP_INPUTEVENT_TYPE_MOUSELEAVE;\n     case WebInputEvent::MouseWheel:\n       return PP_INPUTEVENT_TYPE_MOUSEWHEEL;\n     case WebInputEvent::RawKeyDown:\n      return PP_INPUTEVENT_TYPE_RAWKEYDOWN;\n    case WebInputEvent::KeyDown:\n      return PP_INPUTEVENT_TYPE_KEYDOWN;\n    case WebInputEvent::KeyUp:\n      return PP_INPUTEVENT_TYPE_KEYUP;\n    case WebInputEvent::Char:\n      return PP_INPUTEVENT_TYPE_CHAR;\n    case WebInputEvent::Undefined:\n    default:\n      return PP_INPUTEVENT_TYPE_UNDEFINED;\n  }\n}\n", "target": 1, "idx": 184075}
{"func": "static double abserr(PNG_CONST png_modifier *pm, int in_depth, int out_depth)\n {\n    /* Absolute error permitted in linear values - affected by the bit depth of\n     * the calculations.\n    */\n if (pm->assume_16_bit_calculations ||\n (pm->calculations_use_input_precision ? in_depth : out_depth) == 16)\n return pm->maxabs16;\n else\n\n       return pm->maxabs8;\n }\n", "target": 1, "idx": 187625}
{"func": " static inline void sem_getref_and_unlock(struct sem_array *sma)\n {\n\tipc_rcu_getref(sma);\n\tipc_unlock(&(sma)->sem_perm);\n }\n", "target": 1, "idx": 179146}
{"func": "static EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionOverloadedMethod6(ExecState* exec)\n{\n    JSValue thisValue = exec->hostThisValue();\n    if (!thisValue.inherits(&JSTestObj::s_info))\n        return throwVMTypeError(exec);\n    JSTestObj* castedThis = jsCast<JSTestObj*>(asObject(thisValue));\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\n     TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n     if (exec->argumentCount() < 1)\n        return throwVMError(exec, createTypeError(exec, \"Not enough arguments\"));\n     DOMStringList* listArg(toDOMStringList(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined)));\n     if (exec->hadException())\n         return JSValue::encode(jsUndefined());\n    impl->overloadedMethod(listArg);\n    return JSValue::encode(jsUndefined());\n}\n", "target": 1, "idx": 184062}
{"func": "void drop_privileges(char *username) {\n\tstruct passwd *user = (struct passwd *) getpwnam(username);\n\tif (user == NULL) {\n\t\tfprintf(stderr, _(\"Failed dropping privileges. The user %s is not a valid username on local system.\\n\"), username);\n\t\texit(1);\n\t}\n\tif (getuid() == 0) {\n\t\t/* process is running as root, drop privileges */\n\t\tif (setgid(user->pw_gid) != 0) {\n\t\t\tfprintf(stderr, _(\"setgid: Error dropping group privileges\\n\"));\n\t\t\texit(1);\n\t\t}\n\t\tif (setuid(user->pw_uid) != 0) {\n\t\t\tfprintf(stderr, _(\"setuid: Error dropping user privileges\\n\"));\n\t\t\texit(1);\n\t\t}\n\t\t/* Verify if the privileges were developed. */\n\t\tif (setuid(0) != -1) {\n\t\t\tfprintf(stderr, _(\"Failed to drop privileges\\n\"));\n\t\t\texit(1);\n\t\t}\n\t}\n}\n", "target": 0, "idx": 50284}
{"func": "static struct mt_connection *list_find_connection(unsigned short seskey, unsigned char *srcmac) {\n\tstruct mt_connection *p;\n\n\tDL_FOREACH(connections_head, p) {\n\t\tif (p->seskey == seskey && memcmp(srcmac, p->srcmac, ETH_ALEN) == 0) {\n\t\t\treturn p;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n", "target": 0, "idx": 50295}
{"func": "void TaskManagerHandler::HandleActivatePage(const ListValue* unique_ids) {\n  for (ListValue::const_iterator i = unique_ids->begin();\n       i != unique_ids->end(); ++i) {\n    int unique_id = parseIndex(*i);\n    int resource_index = model_->GetResourceIndexByUniqueId(unique_id);\n    if (resource_index == -1)\n      continue;\n\n    task_manager_->ActivateProcess(resource_index);\n    break;\n  }\n}\n", "target": 0, "idx": 100910}
{"func": "TestBrowserWindow::~TestBrowserWindow() {}\n", "target": 0, "idx": 168433}
{"func": "png_set_tIME(png_structp png_ptr, png_infop info_ptr, png_timep mod_time)\n{\n   png_debug1(1, \"in %s storage function\", \"tIME\");\n\n   if (png_ptr == NULL || info_ptr == NULL ||\n        (png_ptr->mode & PNG_WROTE_tIME))\n       return;\n \n    png_memcpy(&(info_ptr->mod_time), mod_time, png_sizeof(png_time));\n    info_ptr->valid |= PNG_INFO_tIME;\n }\n", "target": 1, "idx": 186152}
{"func": "static void calc_coeff(double mu[4], const int index[4], int prefilter, double r2, double mul)\n{\n    double mul2 = mul * mul, mul3 = mul2 * mul;\n    double kernel[] = {\n        (5204 + 2520 * mul + 1092 * mul2 + 3280 * mul3) / 12096,\n        (2943 -  210 * mul -  273 * mul2 - 2460 * mul3) / 12096,\n        ( 486 -  924 * mul -  546 * mul2 +  984 * mul3) / 12096,\n         (  17 -  126 * mul +  273 * mul2 -  164 * mul3) / 12096,\n     };\n \n    double mat_freq[13];\n     memcpy(mat_freq, kernel, sizeof(kernel));\n     memset(mat_freq + 4, 0, sizeof(mat_freq) - sizeof(kernel));\n     int n = 6;\n    coeff_filter(mat_freq, n, kernel);\n    for (int k = 0; k < 2 * prefilter; ++k)\n        coeff_blur121(mat_freq, ++n);\n\n    double vec_freq[13];\n    n = index[3] + prefilter + 3;\n    calc_gauss(vec_freq, n, r2);\n    memset(vec_freq + n + 1, 0, sizeof(vec_freq) - (n + 1) * sizeof(vec_freq[0]));\n    n -= 3;\n    coeff_filter(vec_freq, n, kernel);\n    for (int k = 0; k < prefilter; ++k)\n        coeff_blur121(vec_freq, --n);\n\n    double mat[4][4];\n    calc_matrix(mat, mat_freq, index);\n\n    double vec[4];\n    for (int i = 0; i < 4; ++i)\n        vec[i] = mat_freq[0] - mat_freq[index[i]] - vec_freq[0] + vec_freq[index[i]];\n\n    for (int i = 0; i < 4; ++i) {\n        double res = 0;\n        for (int j = 0; j < 4; ++j)\n            res += mat[i][j] * vec[j];\n        mu[i] = FFMAX(0, res);\n    }\n}\n", "target": 1, "idx": 181947}
{"func": "const char* Track::GetLanguage() const\n{\n    return m_info.language;\n}\n", "target": 1, "idx": 188359}
{"func": "static void write_exception(struct pstore *ps,\n\t\t\t    uint32_t index, struct core_exception *e)\n{\n\tstruct disk_exception *de = get_exception(ps, index);\n\n\t/* copy it */\n\tde->old_chunk = cpu_to_le64(e->old_chunk);\n\tde->new_chunk = cpu_to_le64(e->new_chunk);\n}\n", "target": 0, "idx": 29686}
{"func": "static int php_stream_temp_seek(php_stream *stream, off_t offset, int whence, off_t *newoffs TSRMLS_DC)\n{\n\tphp_stream_temp_data *ts = (php_stream_temp_data*)stream->abstract;\n\tint ret;\n\n\tassert(ts != NULL);\n\n\tif (!ts->innerstream) {\n\t\t*newoffs = -1;\n\t\treturn -1;\n\t}\n        ret = php_stream_seek(ts->innerstream, offset, whence);\n        *newoffs = php_stream_tell(ts->innerstream);\n        stream->eof = ts->innerstream->eof;\n        return ret;\n }\n", "target": 1, "idx": 178653}
{"func": "xps_parse_glyphs(xps_document *doc, const fz_matrix *ctm,\n\t\tchar *base_uri, xps_resource *dict, fz_xml *root)\n{\n\tfz_xml *node;\n\n\tchar *fill_uri;\n\tchar *opacity_mask_uri;\n\n\tchar *bidi_level_att;\n\tchar *fill_att;\n\tchar *font_size_att;\n\tchar *font_uri_att;\n\tchar *origin_x_att;\n\tchar *origin_y_att;\n\tchar *is_sideways_att;\n\tchar *indices_att;\n\tchar *unicode_att;\n\tchar *style_att;\n\tchar *transform_att;\n\tchar *clip_att;\n\tchar *opacity_att;\n\tchar *opacity_mask_att;\n\tchar *navigate_uri_att;\n\n\tfz_xml *transform_tag = NULL;\n\tfz_xml *clip_tag = NULL;\n\tfz_xml *fill_tag = NULL;\n\tfz_xml *opacity_mask_tag = NULL;\n\n\tchar *fill_opacity_att = NULL;\n\n\txps_part *part;\n\tfz_font *font;\n\n\tchar partname[1024];\n\tchar fakename[1024];\n\tchar *subfont;\n\n\tfloat font_size = 10;\n\tint subfontid = 0;\n\tint is_sideways = 0;\n\tint bidi_level = 0;\n\n\tfz_text *text;\n\tfz_rect area;\n\n\tfz_matrix local_ctm = *ctm;\n\n\t/*\n\t * Extract attributes and extended attributes.\n\t */\n\n\tbidi_level_att = fz_xml_att(root, \"BidiLevel\");\n\tfill_att = fz_xml_att(root, \"Fill\");\n\tfont_size_att = fz_xml_att(root, \"FontRenderingEmSize\");\n\tfont_uri_att = fz_xml_att(root, \"FontUri\");\n\torigin_x_att = fz_xml_att(root, \"OriginX\");\n\torigin_y_att = fz_xml_att(root, \"OriginY\");\n\tis_sideways_att = fz_xml_att(root, \"IsSideways\");\n\tindices_att = fz_xml_att(root, \"Indices\");\n\tunicode_att = fz_xml_att(root, \"UnicodeString\");\n\tstyle_att = fz_xml_att(root, \"StyleSimulations\");\n\ttransform_att = fz_xml_att(root, \"RenderTransform\");\n\tclip_att = fz_xml_att(root, \"Clip\");\n\topacity_att = fz_xml_att(root, \"Opacity\");\n\topacity_mask_att = fz_xml_att(root, \"OpacityMask\");\n\tnavigate_uri_att = fz_xml_att(root, \"FixedPage.NavigateUri\");\n\n\tfor (node = fz_xml_down(root); node; node = fz_xml_next(node))\n\t{\n\t\tif (!strcmp(fz_xml_tag(node), \"Glyphs.RenderTransform\"))\n\t\t\ttransform_tag = fz_xml_down(node);\n\t\tif (!strcmp(fz_xml_tag(node), \"Glyphs.OpacityMask\"))\n\t\t\topacity_mask_tag = fz_xml_down(node);\n\t\tif (!strcmp(fz_xml_tag(node), \"Glyphs.Clip\"))\n\t\t\tclip_tag = fz_xml_down(node);\n\t\tif (!strcmp(fz_xml_tag(node), \"Glyphs.Fill\"))\n\t\t\tfill_tag = fz_xml_down(node);\n\t}\n\n\tfill_uri = base_uri;\n\topacity_mask_uri = base_uri;\n\n\txps_resolve_resource_reference(doc, dict, &transform_att, &transform_tag, NULL);\n\txps_resolve_resource_reference(doc, dict, &clip_att, &clip_tag, NULL);\n\txps_resolve_resource_reference(doc, dict, &fill_att, &fill_tag, &fill_uri);\n\txps_resolve_resource_reference(doc, dict, &opacity_mask_att, &opacity_mask_tag, &opacity_mask_uri);\n\n\t/*\n\t * Check that we have all the necessary information.\n\t */\n\n\tif (!font_size_att || !font_uri_att || !origin_x_att || !origin_y_att) {\n\t\tfz_warn(doc->ctx, \"missing attributes in glyphs element\");\n\t\treturn;\n\t}\n\n\tif (!indices_att && !unicode_att)\n\t\treturn; /* nothing to draw */\n\n\tif (is_sideways_att)\n\t\tis_sideways = !strcmp(is_sideways_att, \"true\");\n\n\tif (bidi_level_att)\n\t\tbidi_level = atoi(bidi_level_att);\n\n\t/*\n\t * Find and load the font resource\n\t */\n\n\txps_resolve_url(partname, base_uri, font_uri_att, sizeof partname);\n\tsubfont = strrchr(partname, '#');\n\tif (subfont)\n\t{\n\t\tsubfontid = atoi(subfont + 1);\n\t\t*subfont = 0;\n\t}\n\n\t/* Make a new part name for font with style simulation applied */\n\tfz_strlcpy(fakename, partname, sizeof fakename);\n\tif (style_att)\n\t{\n\t\tif (!strcmp(style_att, \"BoldSimulation\"))\n\t\t\tfz_strlcat(fakename, \"#Bold\", sizeof fakename);\n\t\telse if (!strcmp(style_att, \"ItalicSimulation\"))\n\t\t\tfz_strlcat(fakename, \"#Italic\", sizeof fakename);\n\t\telse if (!strcmp(style_att, \"BoldItalicSimulation\"))\n\t\t\tfz_strlcat(fakename, \"#BoldItalic\", sizeof fakename);\n\t}\n\n\tfont = xps_lookup_font(doc, fakename);\n\tif (!font)\n\t{\n\t\tfz_try(doc->ctx)\n\t\t{\n\t\t\tpart = xps_read_part(doc, partname);\n\t\t}\n\t\tfz_catch(doc->ctx)\n\t\t{\n\t\t\tfz_rethrow_if(doc->ctx, FZ_ERROR_TRYLATER);\n\t\t\tfz_warn(doc->ctx, \"cannot find font resource part '%s'\", partname);\n\t\t\treturn;\n\t\t}\n\n\t\t/* deobfuscate if necessary */\n\t\tif (strstr(part->name, \".odttf\"))\n\t\t\txps_deobfuscate_font_resource(doc, part);\n\t\tif (strstr(part->name, \".ODTTF\"))\n\t\t\txps_deobfuscate_font_resource(doc, part);\n\n\t\tfz_try(doc->ctx)\n\t\t{\n\t\t\tfz_buffer *buf = fz_new_buffer_from_data(doc->ctx, part->data, part->size);\n\t\t\tfont = fz_new_font_from_buffer(doc->ctx, NULL, buf, subfontid, 1);\n\t\t\tfz_drop_buffer(doc->ctx, buf);\n\t\t}\n\t\tfz_catch(doc->ctx)\n\t\t{\n\t\t\tfz_rethrow_if(doc->ctx, FZ_ERROR_TRYLATER);\n\t\t\tfz_warn(doc->ctx, \"cannot load font resource '%s'\", partname);\n\t\t\txps_free_part(doc, part);\n\t\t\treturn;\n\t\t}\n\n\t\tif (style_att)\n\t\t{\n\t\t\tfont->ft_bold = !!strstr(style_att, \"Bold\");\n\t\t\tfont->ft_italic = !!strstr(style_att, \"Italic\");\n\t\t}\n\n\t\txps_select_best_font_encoding(doc, font);\n\n\t\txps_insert_font(doc, fakename, font);\n\n\t\t/* NOTE: we already saved part->data in the buffer in the font */\n\t\tfz_free(doc->ctx, part->name);\n\t\tfz_free(doc->ctx, part);\n\t}\n\n\t/*\n\t * Set up graphics state.\n\t */\n\n\tif (transform_att || transform_tag)\n\t{\n\t\tfz_matrix transform;\n\t\tif (transform_att)\n\t\t\txps_parse_render_transform(doc, transform_att, &transform);\n\t\tif (transform_tag)\n\t\t\txps_parse_matrix_transform(doc, transform_tag, &transform);\n\t\tfz_concat(&local_ctm, &transform, &local_ctm);\n\t}\n\n\tif (clip_att || clip_tag)\n\t\txps_clip(doc, &local_ctm, dict, clip_att, clip_tag);\n\n\tfont_size = fz_atof(font_size_att);\n\n\ttext = xps_parse_glyphs_imp(doc, &local_ctm, font, font_size,\n\t\t\tfz_atof(origin_x_att), fz_atof(origin_y_att),\n\t\t\tis_sideways, bidi_level, indices_att, unicode_att);\n\n\tfz_bound_text(doc->ctx, text, NULL, &local_ctm, &area);\n\n\tif (navigate_uri_att)\n\t\txps_add_link(doc, &area, base_uri, navigate_uri_att);\n\n\txps_begin_opacity(doc, &local_ctm, &area, opacity_mask_uri, dict, opacity_att, opacity_mask_tag);\n\n\t/* If it's a solid color brush fill/stroke do a simple fill */\n\n\tif (fill_tag && !strcmp(fz_xml_tag(fill_tag), \"SolidColorBrush\"))\n\t{\n\t\tfill_opacity_att = fz_xml_att(fill_tag, \"Opacity\");\n\t\tfill_att = fz_xml_att(fill_tag, \"Color\");\n\t\tfill_tag = NULL;\n\t}\n \n        if (fill_att)\n        {\n               float samples[32];\n                fz_colorspace *colorspace;\n \n                xps_parse_color(doc, base_uri, fill_att, &colorspace, samples);\n\t\tif (fill_opacity_att)\n\t\t\tsamples[0] *= fz_atof(fill_opacity_att);\n\t\txps_set_color(doc, colorspace, samples);\n\n\t\tfz_fill_text(doc->dev, text, &local_ctm,\n\t\t\tdoc->colorspace, doc->color, doc->alpha);\n\t}\n\n\t/* If it's a complex brush, use the charpath as a clip mask */\n\n\tif (fill_tag)\n\t{\n\t\tfz_clip_text(doc->dev, text, &local_ctm, 0);\n\t\txps_parse_brush(doc, &local_ctm, &area, fill_uri, dict, fill_tag);\n\t\tfz_pop_clip(doc->dev);\n\t}\n\n\txps_end_opacity(doc, opacity_mask_uri, dict, opacity_att, opacity_mask_tag);\n\n\tfz_free_text(doc->ctx, text);\n\n\tif (clip_att || clip_tag)\n\t\tfz_pop_clip(doc->dev);\n\n\tfz_drop_font(doc->ctx, font);\n}\n", "target": 1, "idx": 178401}
{"func": "hash_foreach_mangle_dict_of_strings (gpointer key, gpointer val, gpointer user_data)\n{\n  GHashTable *out = (GHashTable*) user_data;\n  GHashTable *in_dict = (GHashTable *) val;\n  HashAndString *data = g_new0 (HashAndString, 1);\n  data->string = (gchar*) key;\n  data->hash = g_hash_table_new_full (g_str_hash, g_str_equal,\n                                            g_free, g_free);\n  g_hash_table_foreach (in_dict, hash_foreach_prepend_string, data);\n  g_hash_table_insert(out, g_strdup ((gchar*) key), data->hash);\n}\n", "target": 1, "idx": 178257}
{"func": "xmlPopInput(xmlParserCtxtPtr ctxt) {\n if ((ctxt == NULL) || (ctxt->inputNr <= 1)) return(0);\n if (xmlParserDebugEntities)\n\txmlGenericError(xmlGenericErrorContext,\n \"Popping input %d\\n\", ctxt->inputNr);\n    xmlFreeInputStream(inputPop(ctxt));\n if ((*ctxt->input->cur == 0) &&\n (xmlParserInputGrow(ctxt->input, INPUT_CHUNK) <= 0))\n return(xmlPopInput(ctxt));\n return(CUR);\n}\n", "target": 0, "idx": 176681}
{"func": "  void DidReceiveData(const char* buffer, int length, int data_offset) {\n    DCHECK(channel_ != NULL);\n    DCHECK_GT(length, 0);\n    std::vector<char> data;\n    data.resize(static_cast<size_t>(length));\n    memcpy(&data.front(), buffer, length);\n    scoped_refptr<PluginChannelHost> channel_ref(channel_);\n    channel_->Send(new PluginMsg_DidReceiveData(instance_id_, resource_id_,\n                                                data, data_offset));\n  }\n", "target": 0, "idx": 98767}
{"func": "bool JSTestInterfaceConstructor::getOwnPropertySlot(JSCell* cell, ExecState* exec, const Identifier& propertyName, PropertySlot& slot)\n{\n    return getStaticPropertySlot<JSTestInterfaceConstructor, JSDOMWrapper>(exec, &JSTestInterfaceConstructorTable, jsCast<JSTestInterfaceConstructor*>(cell), propertyName, slot);\n}\n", "target": 0, "idx": 106005}
{"func": "static v8::Handle<v8::Value> methodWithCallbackArgCallback(const v8::Arguments& args)\n {\n     INC_STATS(\"DOM.TestObj.methodWithCallbackArg\");\n     if (args.Length() < 1)\n        return V8Proxy::throwNotEnoughArgumentsError();\n     TestObj* imp = V8TestObj::toNative(args.Holder());\n     if (args.Length() <= 0 || !args[0]->IsFunction())\n         return throwError(TYPE_MISMATCH_ERR, args.GetIsolate());\n    RefPtr<TestCallback> callback = V8TestCallback::create(args[0], getScriptExecutionContext());\n    imp->methodWithCallbackArg(callback);\n    return v8::Handle<v8::Value>();\n}\n", "target": 1, "idx": 184780}
{"func": "free_client(struct nfs4_client *clp)\n{\n\twhile (!list_empty(&clp->cl_sessions)) {\n\t\tstruct nfsd4_session *ses;\n\t\tses = list_entry(clp->cl_sessions.next, struct nfsd4_session,\n\t\t\t\tse_perclnt);\n\t\tlist_del(&ses->se_perclnt);\n\t\tWARN_ON_ONCE(atomic_read(&ses->se_ref));\n\t\tfree_session(ses);\n\t}\n\trpc_destroy_wait_queue(&clp->cl_cb_waitq);\n\tfree_svc_cred(&clp->cl_cred);\n\tkfree(clp->cl_ownerstr_hashtbl);\n\tkfree(clp->cl_name.data);\n\tidr_destroy(&clp->cl_stateids);\n\tkfree(clp);\n}\n", "target": 0, "idx": 65469}
{"func": "long ContentEncoding::ParseContentEncodingEntry(long long start,\n                                                long long size,\n                                                 IMkvReader* pReader) {\n   assert(pReader);\n \n long long pos = start;\n const long long stop = start + size;\n\n int compression_count = 0;\n int encryption_count = 0;\n\n \n   while (pos < stop) {\n     long long id, size;\n    const long status = ParseElementHeader(pReader,\n                                           pos,\n                                           stop,\n                                           id,\n                                           size);\n    if (status < 0)  //error\n       return status;\n \n     if (id == 0x1034)  // ContentCompression ID\n ++compression_count;\n\n\n     if (id == 0x1035)  // ContentEncryption ID\n       ++encryption_count;\n \n    pos += size;  //consume payload\n     assert(pos <= stop);\n   }\n \n if (compression_count <= 0 && encryption_count <= 0)\n return -1;\n\n \n   if (compression_count > 0) {\n     compression_entries_ =\n        new (std::nothrow) ContentCompression*[compression_count];\n     if (!compression_entries_)\n       return -1;\n     compression_entries_end_ = compression_entries_;\n }\n\n \n   if (encryption_count > 0) {\n     encryption_entries_ =\n        new (std::nothrow) ContentEncryption*[encryption_count];\n     if (!encryption_entries_) {\n      delete [] compression_entries_;\n       return -1;\n     }\n     encryption_entries_end_ = encryption_entries_;\n }\n\n\n   pos = start;\n   while (pos < stop) {\n     long long id, size;\n    long status = ParseElementHeader(pReader,\n                                     pos,\n                                     stop,\n                                     id,\n                                     size);\n    if (status < 0)  //error\n       return status;\n \n     if (id == 0x1031) {\n      encoding_order_ = UnserializeUInt(pReader, pos, size);\n } else if (id == 0x1032) {\n      encoding_scope_ = UnserializeUInt(pReader, pos, size);\n if (encoding_scope_ < 1)\n return -1;\n } else if (id == 0x1033) {\n      encoding_type_ = UnserializeUInt(pReader, pos, size);\n\n     } else if (id == 0x1034) {\n       ContentCompression* const compression =\n        new (std::nothrow) ContentCompression();\n       if (!compression)\n         return -1;\n \n      status = ParseCompressionEntry(pos, size, pReader, compression);\n if (status) {\n delete compression;\n return status;\n }\n *compression_entries_end_++ = compression;\n } else if (id == 0x1035) {\n ContentEncryption* const encryption =\n new (std::nothrow) ContentEncryption();\n if (!encryption)\n return -1;\n\n      status = ParseEncryptionEntry(pos, size, pReader, encryption);\n if (status) {\n delete encryption;\n return status;\n }\n\n       *encryption_entries_end_++ = encryption;\n     }\n \n    pos += size;  //consume payload\n     assert(pos <= stop);\n   }\n \n  assert(pos == stop);\n\n   return 0;\n }\n", "target": 1, "idx": 188441}
{"func": "static int l2tp_ip6_backlog_recv(struct sock *sk, struct sk_buff *skb)\n{\n\tint rc;\n\n\t/* Charge it to the socket, dropping if the queue is full. */\n\trc = sock_queue_rcv_skb(sk, skb);\n\tif (rc < 0)\n\t\tgoto drop;\n\n\treturn 0;\n\ndrop:\n\tIP_INC_STATS(&init_net, IPSTATS_MIB_INDISCARDS);\n\tkfree_skb(skb);\n\treturn -1;\n}\n", "target": 0, "idx": 30557}
{"func": "long Chapters::Parse()\n{\n    IMkvReader* const pReader = m_pSegment->m_pReader;\n    long long pos = m_start;  // payload start\n    const long long stop = pos + m_size;  // payload stop\n    while (pos < stop)\n    {\n        long long id, size;\n        long status = ParseElementHeader(\n                        pReader,\n                        pos,\n                        stop,\n                        id,\n                        size);\n        if (status < 0)  // error\n            return status;\n        if (size == 0)  // weird\n            continue;\n        if (id == 0x05B9)  // EditionEntry ID\n        {\n            status = ParseEdition(pos, size);\n            if (status < 0)  // error\n                return status;\n        }\n        pos += size;\n        assert(pos <= stop);\n     }\n \n    assert(pos == stop);\n    return 0;\n }\n", "target": 1, "idx": 188422}
{"func": " static void ReconfigureImpl(Handle<JSObject> object,\n Handle<FixedArrayBase> store, uint32_t entry,\n Handle<Object> value,\n PropertyAttributes attributes) {\n Handle<SeededNumberDictionary> dictionary =\n JSObject::NormalizeElements(object);\n FixedArray::cast(*store)->set(1, *dictionary);\n uint32_t length = static_cast<uint32_t>(store->length()) - 2;\n if (entry >= length) {\n      entry = dictionary->FindEntry(entry - length) + length;\n }\n SlowSloppyArgumentsElementsAccessor::ReconfigureImpl(object, store, entry,\n                                                         value, attributes);\n }\n", "target": 0, "idx": 176341}
{"func": "media::AudioParameters GetDeviceParametersOnDeviceThread(\n    media::AudioManager* audio_manager,\n    const std::string& unique_id) {\n  DCHECK(audio_manager->GetTaskRunner()->BelongsToCurrentThread());\n  return media::AudioDeviceDescription::IsDefaultDevice(unique_id)\n             ? audio_manager->GetDefaultOutputStreamParameters()\n             : audio_manager->GetOutputStreamParameters(unique_id);\n}\n", "target": 1, "idx": 185860}
{"func": "SQLWCHAR* _multi_string_alloc_and_expand( LPCSTR in )\n{\n    SQLWCHAR *chr;\n    int len = 0;\n \n     if ( !in )\n     {\n        return in;\n     }\n     \n     while ( in[ len ] != 0 || in[ len + 1 ] != 0 )\n    {\n        len ++;\n    }\n\n    chr = malloc(sizeof( SQLWCHAR ) * ( len + 2 ));\n\n    len = 0;\n    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )\n    {\n        chr[ len ] = in[ len ];\n        len ++;\n    }\n    chr[ len ++ ] = 0;\n    chr[ len ++ ] = 0;\n\n    return chr;\n}\n", "target": 1, "idx": 182486}
{"func": " OJPEGDecode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)\n {\n \tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n \t(void)s;\n \tif (sp->libjpeg_jpeg_query_style==0)\n \t{\n \t\tif (OJPEGDecodeRaw(tif,buf,cc)==0)\n\t\t\treturn(0);\n\t}\n\telse\n\t{\n\t\tif (OJPEGDecodeScanlines(tif,buf,cc)==0)\n\t\t\treturn(0);\n\t}\n\treturn(1);\n}\n", "target": 1, "idx": 181640}
{"func": " virtual void allocateBuffers(bool async, uint32_t width, uint32_t height,\n PixelFormat format, uint32_t usage) {\n Parcel data, reply;\n        data.writeInterfaceToken(IGraphicBufferProducer::getInterfaceDescriptor());\n        data.writeInt32(static_cast<int32_t>(async));\n        data.writeUint32(width);\n        data.writeUint32(height);\n        data.writeInt32(static_cast<int32_t>(format));\n        data.writeUint32(usage);\n status_t result = remote()->transact(ALLOCATE_BUFFERS, data, &reply);\n if (result != NO_ERROR) {\n            ALOGE(\"allocateBuffers failed to transact: %d\", result);\n }\n }\n", "target": 0, "idx": 174094}
{"func": "xmlXPathNextDescendant(xmlXPathParserContextPtr ctxt, xmlNodePtr cur) {\n    if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);\n    if (cur == NULL) {\n\tif (ctxt->context->node == NULL)\n\t    return(NULL);\n\tif ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||\n\t    (ctxt->context->node->type == XML_NAMESPACE_DECL))\n\t    return(NULL);\n\n        if (ctxt->context->node == (xmlNodePtr) ctxt->context->doc)\n\t    return(ctxt->context->doc->children);\n        return(ctxt->context->node->children);\n    }\n\n    if (cur->children != NULL) {\n\t/*\n\t * Do not descend on entities declarations\n\t */\n\tif (cur->children->type != XML_ENTITY_DECL) {\n\t    cur = cur->children;\n\t    /*\n\t     * Skip DTDs\n\t     */\n\t    if (cur->type != XML_DTD_NODE)\n\t\treturn(cur);\n\t}\n    }\n\n    if (cur == ctxt->context->node) return(NULL);\n\n    while (cur->next != NULL) {\n\tcur = cur->next;\n\tif ((cur->type != XML_ENTITY_DECL) &&\n\t    (cur->type != XML_DTD_NODE))\n\t    return(cur);\n    }\n\n    do {\n        cur = cur->parent;\n\tif (cur == NULL) break;\n\tif (cur == ctxt->context->node) return(NULL);\n\tif (cur->next != NULL) {\n\t    cur = cur->next;\n\t    return(cur);\n\t}\n    } while (cur != NULL);\n    return(cur);\n}\n", "target": 0, "idx": 97722}
{"func": "XRRGetMonitors(Display *dpy, Window window, Bool get_active, int *nmonitors)\n{\n    XExtDisplayInfo\t    *info = XRRFindDisplay(dpy);\n    xRRGetMonitorsReply\t    rep;\n    xRRGetMonitorsReq\t    *req;\n    int\t\t\t    nbytes, nbytesRead, rbytes;\n    int\t\t\t    nmon, noutput;\n    int\t\t\t    m, o;\n    char\t\t    *buf, *buf_head;\n    xRRMonitorInfo\t    *xmon;\n    CARD32\t\t    *xoutput;\n    XRRMonitorInfo\t    *mon = NULL;\n    RROutput\t\t    *output;\n\n    RRCheckExtension (dpy, info, NULL);\n\n    *nmonitors = -1;\n\n    LockDisplay (dpy);\n    GetReq (RRGetMonitors, req);\n    req->reqType = info->codes->major_opcode;\n    req->randrReqType = X_RRGetMonitors;\n    req->window = window;\n    req->get_active = get_active;\n\n    if (!_XReply (dpy, (xReply *) &rep, 0, xFalse))\n    {\n\tUnlockDisplay (dpy);\n\tSyncHandle ();\n\treturn NULL;\n \treturn NULL;\n     }\n \n     nbytes = (long) rep.length << 2;\n     nmon = rep.nmonitors;\n     noutput = rep.noutputs;\n\trbytes = nmon * sizeof (XRRMonitorInfo) + noutput * sizeof(RROutput);\n\n\tbuf = buf_head = Xmalloc (nbytesRead);\n\tmon = Xmalloc (rbytes);\n\n\tif (buf == NULL || mon == NULL) {\n\t    Xfree(buf);\n\t    Xfree(mon);\n\t    _XEatDataWords (dpy, rep.length);\n\t    UnlockDisplay (dpy);\n\t    SyncHandle ();\n\t    return NULL;\n\t}\n\n\t_XReadPad(dpy, buf, nbytesRead);\n\n\toutput = (RROutput *) (mon + nmon);\n\n\tfor (m = 0; m < nmon; m++) {\n\t    xmon = (xRRMonitorInfo *) buf;\n\t    mon[m].name = xmon->name;\n\t    mon[m].primary = xmon->primary;\n\t    mon[m].automatic = xmon->automatic;\n\t    mon[m].noutput = xmon->noutput;\n\t    mon[m].x = xmon->x;\n\t    mon[m].y = xmon->y;\n\t    mon[m].width = xmon->width;\n\t    mon[m].height = xmon->height;\n\t    mon[m].mwidth = xmon->widthInMillimeters;\n\t    mon[m].mheight = xmon->heightInMillimeters;\n\t    mon[m].outputs = output;\n\t    buf += SIZEOF (xRRMonitorInfo);\n\t    xoutput = (CARD32 *) buf;\n\t    for (o = 0; o < xmon->noutput; o++)\n\t\toutput[o] = xoutput[o];\n\t    output += xmon->noutput;\n\t    buf += xmon->noutput * 4;\n\t}\n\tXfree(buf_head);\n    }\n", "target": 1, "idx": 178086}
{"func": "static int ext4_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tchar *orig_data = kstrdup(data, GFP_KERNEL);\n\tstruct buffer_head *bh;\n\tstruct ext4_super_block *es = NULL;\n\tstruct ext4_sb_info *sbi;\n\text4_fsblk_t block;\n\text4_fsblk_t sb_block = get_sb_block(&data);\n\text4_fsblk_t logical_sb_block;\n\tunsigned long offset = 0;\n\tunsigned long journal_devnum = 0;\n\tunsigned long def_mount_opts;\n\tstruct inode *root;\n\tconst char *descr;\n\tint ret = -ENOMEM;\n\tint blocksize, clustersize;\n\tunsigned int db_count;\n\tunsigned int i;\n\tint needs_recovery, has_huge_files, has_bigalloc;\n\t__u64 blocks_count;\n\tint err = 0;\n\tunsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO;\n\text4_group_t first_not_zeroed;\n\n\tsbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\tif (!sbi)\n\t\tgoto out_free_orig;\n\n\tsbi->s_blockgroup_lock =\n\t\tkzalloc(sizeof(struct blockgroup_lock), GFP_KERNEL);\n\tif (!sbi->s_blockgroup_lock) {\n\t\tkfree(sbi);\n\t\tgoto out_free_orig;\n\t}\n\tsb->s_fs_info = sbi;\n\tsbi->s_sb = sb;\n\tsbi->s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS;\n\tsbi->s_sb_block = sb_block;\n\tif (sb->s_bdev->bd_part)\n\t\tsbi->s_sectors_written_start =\n\t\t\tpart_stat_read(sb->s_bdev->bd_part, sectors[1]);\n\n\t/* Cleanup superblock name */\n\tstrreplace(sb->s_id, '/', '!');\n\n\t/* -EINVAL is default */\n\tret = -EINVAL;\n\tblocksize = sb_min_blocksize(sb, EXT4_MIN_BLOCK_SIZE);\n\tif (!blocksize) {\n\t\text4_msg(sb, KERN_ERR, \"unable to set blocksize\");\n\t\tgoto out_fail;\n\t}\n\n\t/*\n\t * The ext4 superblock will not be buffer aligned for other than 1kB\n\t * block sizes.  We need to calculate the offset from buffer start.\n\t */\n\tif (blocksize != EXT4_MIN_BLOCK_SIZE) {\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t} else {\n\t\tlogical_sb_block = sb_block;\n\t}\n\n\tif (!(bh = sb_bread_unmovable(sb, logical_sb_block))) {\n\t\text4_msg(sb, KERN_ERR, \"unable to read superblock\");\n\t\tgoto out_fail;\n\t}\n\t/*\n\t * Note: s_es must be initialized as soon as possible because\n\t *       some ext4 macro-instructions depend on its value\n\t */\n\tes = (struct ext4_super_block *) (bh->b_data + offset);\n\tsbi->s_es = es;\n\tsb->s_magic = le16_to_cpu(es->s_magic);\n\tif (sb->s_magic != EXT4_SUPER_MAGIC)\n\t\tgoto cantfind_ext4;\n\tsbi->s_kbytes_written = le64_to_cpu(es->s_kbytes_written);\n\n\t/* Warn if metadata_csum and gdt_csum are both set. */\n\tif (ext4_has_feature_metadata_csum(sb) &&\n\t    ext4_has_feature_gdt_csum(sb))\n\t\text4_warning(sb, \"metadata_csum and uninit_bg are \"\n\t\t\t     \"redundant flags; please run fsck.\");\n\n\t/* Check for a known checksum algorithm */\n\tif (!ext4_verify_csum_type(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"unknown checksum algorithm.\");\n\t\tsilent = 1;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Load the checksum driver */\n\tif (ext4_has_feature_metadata_csum(sb)) {\n\t\tsbi->s_chksum_driver = crypto_alloc_shash(\"crc32c\", 0, 0);\n\t\tif (IS_ERR(sbi->s_chksum_driver)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Cannot load crc32c driver.\");\n\t\t\tret = PTR_ERR(sbi->s_chksum_driver);\n\t\t\tsbi->s_chksum_driver = NULL;\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/* Check superblock checksum */\n\tif (!ext4_superblock_csum_verify(sb, es)) {\n\t\text4_msg(sb, KERN_ERR, \"VFS: Found ext4 filesystem with \"\n\t\t\t \"invalid superblock checksum.  Run e2fsck?\");\n\t\tsilent = 1;\n\t\tret = -EFSBADCRC;\n\t\tgoto cantfind_ext4;\n\t}\n\n\t/* Precompute checksum seed for all metadata */\n\tif (ext4_has_feature_csum_seed(sb))\n\t\tsbi->s_csum_seed = le32_to_cpu(es->s_checksum_seed);\n\telse if (ext4_has_metadata_csum(sb))\n\t\tsbi->s_csum_seed = ext4_chksum(sbi, ~0, es->s_uuid,\n\t\t\t\t\t       sizeof(es->s_uuid));\n\n\t/* Set defaults before we parse the mount options */\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\tset_opt(sb, INIT_INODE_TABLE);\n\tif (def_mount_opts & EXT4_DEFM_DEBUG)\n\t\tset_opt(sb, DEBUG);\n\tif (def_mount_opts & EXT4_DEFM_BSDGROUPS)\n\t\tset_opt(sb, GRPID);\n\tif (def_mount_opts & EXT4_DEFM_UID16)\n\t\tset_opt(sb, NO_UID32);\n\t/* xattr user namespace & acls are now defaulted on */\n\tset_opt(sb, XATTR_USER);\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\tset_opt(sb, POSIX_ACL);\n#endif\n\t/* don't forget to enable journal_csum when metadata_csum is enabled. */\n\tif (ext4_has_metadata_csum(sb))\n\t\tset_opt(sb, JOURNAL_CHECKSUM);\n\n\tif ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_DATA)\n\t\tset_opt(sb, JOURNAL_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_ORDERED)\n\t\tset_opt(sb, ORDERED_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_WBACK)\n\t\tset_opt(sb, WRITEBACK_DATA);\n\n\tif (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_PANIC)\n\t\tset_opt(sb, ERRORS_PANIC);\n\telse if (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_CONTINUE)\n\t\tset_opt(sb, ERRORS_CONT);\n\telse\n\t\tset_opt(sb, ERRORS_RO);\n\t/* block_validity enabled by default; disable with noblock_validity */\n\tset_opt(sb, BLOCK_VALIDITY);\n\tif (def_mount_opts & EXT4_DEFM_DISCARD)\n\t\tset_opt(sb, DISCARD);\n\n\tsbi->s_resuid = make_kuid(&init_user_ns, le16_to_cpu(es->s_def_resuid));\n\tsbi->s_resgid = make_kgid(&init_user_ns, le16_to_cpu(es->s_def_resgid));\n\tsbi->s_commit_interval = JBD2_DEFAULT_MAX_COMMIT_AGE * HZ;\n\tsbi->s_min_batch_time = EXT4_DEF_MIN_BATCH_TIME;\n\tsbi->s_max_batch_time = EXT4_DEF_MAX_BATCH_TIME;\n\n\tif ((def_mount_opts & EXT4_DEFM_NOBARRIER) == 0)\n\t\tset_opt(sb, BARRIER);\n\n\t/*\n\t * enable delayed allocation by default\n\t * Use -o nodelalloc to turn it off\n\t */\n\tif (!IS_EXT3_SB(sb) && !IS_EXT2_SB(sb) &&\n\t    ((def_mount_opts & EXT4_DEFM_NODELALLOC) == 0))\n\t\tset_opt(sb, DELALLOC);\n\n\t/*\n\t * set default s_li_wait_mult for lazyinit, for the case there is\n\t * no mount option specified.\n\t */\n\tsbi->s_li_wait_mult = EXT4_DEF_LI_WAIT_MULT;\n\n\tif (!parse_options((char *) sbi->s_es->s_mount_opts, sb,\n\t\t\t   &journal_devnum, &journal_ioprio, 0)) {\n\t\text4_msg(sb, KERN_WARNING,\n\t\t\t \"failed to parse options in superblock: %s\",\n\t\t\t sbi->s_es->s_mount_opts);\n\t}\n\tsbi->s_def_mount_opt = sbi->s_mount_opt;\n\tif (!parse_options((char *) data, sb, &journal_devnum,\n\t\t\t   &journal_ioprio, 0))\n\t\tgoto failed_mount;\n\n\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA) {\n\t\tprintk_once(KERN_WARNING \"EXT4-fs: Warning: mounting \"\n\t\t\t    \"with data=journal disables delayed \"\n\t\t\t    \"allocation and O_DIRECT support!\\n\");\n\t\tif (test_opt2(sb, EXPLICIT_DELALLOC)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and delalloc\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DIOREAD_NOLOCK)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dioread_nolock\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DAX)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dax\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (test_opt(sb, DELALLOC))\n\t\t\tclear_opt(sb, DELALLOC);\n\t} else {\n\t\tsb->s_iflags |= SB_I_CGROUPWB;\n\t}\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t(test_opt(sb, POSIX_ACL) ? MS_POSIXACL : 0);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV &&\n\t    (ext4_has_compat_features(sb) ||\n\t     ext4_has_ro_compat_features(sb) ||\n\t     ext4_has_incompat_features(sb)))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t       \"feature flags set on rev 0 fs, \"\n\t\t       \"running e2fsck is recommended\");\n\n\tif (es->s_creator_os == cpu_to_le32(EXT4_OS_HURD)) {\n\t\tset_opt2(sb, HURD_COMPAT);\n\t\tif (ext4_has_feature_64bit(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"The Hurd can't support 64-bit file systems\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT2_SB(sb)) {\n\t\tif (ext2_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext2 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext2 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (IS_EXT3_SB(sb)) {\n\t\tif (ext3_feature_set_ok(sb))\n\t\t\text4_msg(sb, KERN_INFO, \"mounting ext3 file system \"\n\t\t\t\t \"using the ext4 subsystem\");\n\t\telse {\n\t\t\text4_msg(sb, KERN_ERR, \"couldn't mount as ext3 due \"\n\t\t\t\t \"to feature incompatibilities\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/*\n\t * Check feature flags regardless of the revision level, since we\n\t * previously didn't change the revision level when setting the flags,\n\t * so there is a chance incompat flags are set on a rev 0 filesystem.\n\t */\n\tif (!ext4_feature_set_ok(sb, (sb->s_flags & MS_RDONLY)))\n\t\tgoto failed_mount;\n\n\tblocksize = BLOCK_SIZE << le32_to_cpu(es->s_log_block_size);\n\tif (blocksize < EXT4_MIN_BLOCK_SIZE ||\n\t    blocksize > EXT4_MAX_BLOCK_SIZE) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t       \"Unsupported filesystem blocksize %d\", blocksize);\n\t\tgoto failed_mount;\n\t}\n\n\tif (sbi->s_mount_opt & EXT4_MOUNT_DAX) {\n\t\tif (blocksize != PAGE_SIZE) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t\t\"error: unsupported blocksize for dax\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (!sb->s_bdev->bd_disk->fops->direct_access) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t\t\"error: device does not support dax\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tif (ext4_has_feature_encrypt(sb) && es->s_encryption_level) {\n\t\text4_msg(sb, KERN_ERR, \"Unsupported encryption level %d\",\n\t\t\t es->s_encryption_level);\n\t\tgoto failed_mount;\n\t}\n\n\tif (sb->s_blocksize != blocksize) {\n\t\t/* Validate the filesystem blocksize */\n\t\tif (!sb_set_blocksize(sb, blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR, \"bad block size %d\",\n\t\t\t\t\tblocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t\tbh = sb_bread_unmovable(sb, logical_sb_block);\n\t\tif (!bh) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Can't read superblock on 2nd try\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tes = (struct ext4_super_block *)(bh->b_data + offset);\n\t\tsbi->s_es = es;\n\t\tif (es->s_magic != cpu_to_le16(EXT4_SUPER_MAGIC)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Magic mismatch, very weird!\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\thas_huge_files = ext4_has_feature_huge_file(sb);\n\tsbi->s_bitmap_maxbytes = ext4_max_bitmap_size(sb->s_blocksize_bits,\n\t\t\t\t\t\t      has_huge_files);\n\tsb->s_maxbytes = ext4_max_size(sb->s_blocksize_bits, has_huge_files);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV) {\n\t\tsbi->s_inode_size = EXT4_GOOD_OLD_INODE_SIZE;\n\t\tsbi->s_first_ino = EXT4_GOOD_OLD_FIRST_INO;\n\t} else {\n\t\tsbi->s_inode_size = le16_to_cpu(es->s_inode_size);\n\t\tsbi->s_first_ino = le32_to_cpu(es->s_first_ino);\n\t\tif ((sbi->s_inode_size < EXT4_GOOD_OLD_INODE_SIZE) ||\n\t\t    (!is_power_of_2(sbi->s_inode_size)) ||\n\t\t    (sbi->s_inode_size > blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported inode size: %d\",\n\t\t\t       sbi->s_inode_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE)\n\t\t\tsb->s_time_gran = 1 << (EXT4_EPOCH_BITS - 2);\n\t}\n\n\tsbi->s_desc_size = le16_to_cpu(es->s_desc_size);\n\tif (ext4_has_feature_64bit(sb)) {\n\t\tif (sbi->s_desc_size < EXT4_MIN_DESC_SIZE_64BIT ||\n\t\t    sbi->s_desc_size > EXT4_MAX_DESC_SIZE ||\n\t\t    !is_power_of_2(sbi->s_desc_size)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported descriptor size %lu\",\n\t\t\t       sbi->s_desc_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else\n\t\tsbi->s_desc_size = EXT4_MIN_DESC_SIZE;\n\n\tsbi->s_blocks_per_group = le32_to_cpu(es->s_blocks_per_group);\n\tsbi->s_inodes_per_group = le32_to_cpu(es->s_inodes_per_group);\n\tif (EXT4_INODE_SIZE(sb) == 0 || EXT4_INODES_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext4;\n\n\tsbi->s_inodes_per_block = blocksize / EXT4_INODE_SIZE(sb);\n\tif (sbi->s_inodes_per_block == 0)\n\t\tgoto cantfind_ext4;\n\tsbi->s_itb_per_group = sbi->s_inodes_per_group /\n\t\t\t\t\tsbi->s_inodes_per_block;\n\tsbi->s_desc_per_block = blocksize / EXT4_DESC_SIZE(sb);\n\tsbi->s_sbh = bh;\n\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\tsbi->s_addr_per_block_bits = ilog2(EXT4_ADDR_PER_BLOCK(sb));\n\tsbi->s_desc_per_block_bits = ilog2(EXT4_DESC_PER_BLOCK(sb));\n\n\tfor (i = 0; i < 4; i++)\n\t\tsbi->s_hash_seed[i] = le32_to_cpu(es->s_hash_seed[i]);\n\tsbi->s_def_hash_version = es->s_def_hash_version;\n\tif (ext4_has_feature_dir_index(sb)) {\n\t\ti = le32_to_cpu(es->s_flags);\n\t\tif (i & EXT2_FLAGS_UNSIGNED_HASH)\n\t\t\tsbi->s_hash_unsigned = 3;\n\t\telse if ((i & EXT2_FLAGS_SIGNED_HASH) == 0) {\n#ifdef __CHAR_UNSIGNED__\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_UNSIGNED_HASH);\n\t\t\tsbi->s_hash_unsigned = 3;\n#else\n\t\t\tif (!(sb->s_flags & MS_RDONLY))\n\t\t\t\tes->s_flags |=\n\t\t\t\t\tcpu_to_le32(EXT2_FLAGS_SIGNED_HASH);\n#endif\n\t\t}\n\t}\n\n\t/* Handle clustersize */\n\tclustersize = BLOCK_SIZE << le32_to_cpu(es->s_log_cluster_size);\n\thas_bigalloc = ext4_has_feature_bigalloc(sb);\n\tif (has_bigalloc) {\n\t\tif (clustersize < blocksize) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"cluster size (%d) smaller than \"\n\t\t\t\t \"block size (%d)\", clustersize, blocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_cluster_bits = le32_to_cpu(es->s_log_cluster_size) -\n\t\t\tle32_to_cpu(es->s_log_block_size);\n\t\tsbi->s_clusters_per_group =\n\t\t\tle32_to_cpu(es->s_clusters_per_group);\n\t\tif (sbi->s_clusters_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#clusters per group too big: %lu\",\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_blocks_per_group !=\n\t\t    (sbi->s_clusters_per_group * (clustersize / blocksize))) {\n\t\t\text4_msg(sb, KERN_ERR, \"blocks per group (%lu) and \"\n\t\t\t\t \"clusters per group (%lu) inconsistent\",\n\t\t\t\t sbi->s_blocks_per_group,\n\t\t\t\t sbi->s_clusters_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else {\n\t\tif (clustersize != blocksize) {\n\t\t\text4_warning(sb, \"fragment/cluster size (%d) != \"\n\t\t\t\t     \"block size (%d)\", clustersize,\n\t\t\t\t     blocksize);\n\t\t\tclustersize = blocksize;\n\t\t}\n\t\tif (sbi->s_blocks_per_group > blocksize * 8) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"#blocks per group too big: %lu\",\n\t\t\t\t sbi->s_blocks_per_group);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tsbi->s_clusters_per_group = sbi->s_blocks_per_group;\n\t\tsbi->s_cluster_bits = 0;\n\t}\n\tsbi->s_cluster_ratio = clustersize / blocksize;\n\n\tif (sbi->s_inodes_per_group > blocksize * 8) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t       \"#inodes per group too big: %lu\",\n\t\t       sbi->s_inodes_per_group);\n\t\tgoto failed_mount;\n\t}\n\n\t/* Do we have standard group size of clustersize * 8 blocks ? */\n\tif (sbi->s_blocks_per_group == clustersize << 3)\n\t\tset_opt2(sb, STD_GROUP_SIZE);\n\n\t/*\n\t * Test whether we have more sectors than will fit in sector_t,\n\t * and whether the max offset is addressable by the page cache.\n\t */\n\terr = generic_check_addressable(sb->s_blocksize_bits,\n\t\t\t\t\text4_blocks_count(es));\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"filesystem\"\n\t\t\t \" too large to mount safely on this system\");\n\t\tif (sizeof(sector_t) < 8)\n\t\t\text4_msg(sb, KERN_WARNING, \"CONFIG_LBDAF not enabled\");\n\t\tgoto failed_mount;\n\t}\n\n\tif (EXT4_BLOCKS_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext4;\n\n\t/* check blocks count against device size */\n\tblocks_count = sb->s_bdev->bd_inode->i_size >> sb->s_blocksize_bits;\n\tif (blocks_count && ext4_blocks_count(es) > blocks_count) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: block count %llu \"\n\t\t       \"exceeds size of device (%llu blocks)\",\n\t\t       ext4_blocks_count(es), blocks_count);\n\t\tgoto failed_mount;\n\t}\n\n\t/*\n\t * It makes no sense for the first data block to be beyond the end\n\t * of the filesystem.\n\t */\n\tif (le32_to_cpu(es->s_first_data_block) >= ext4_blocks_count(es)) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: first data \"\n\t\t\t \"block %u is beyond end of filesystem (%llu)\",\n\t\t\t le32_to_cpu(es->s_first_data_block),\n\t\t\t ext4_blocks_count(es));\n\t\tgoto failed_mount;\n\t}\n\tblocks_count = (ext4_blocks_count(es) -\n\t\t\tle32_to_cpu(es->s_first_data_block) +\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb) - 1);\n\tdo_div(blocks_count, EXT4_BLOCKS_PER_GROUP(sb));\n\tif (blocks_count > ((uint64_t)1<<32) - EXT4_DESC_PER_BLOCK(sb)) {\n\t\text4_msg(sb, KERN_WARNING, \"groups count too large: %u \"\n\t\t       \"(block count %llu, first data block %u, \"\n\t\t       \"blocks per group %lu)\", sbi->s_groups_count,\n\t\t       ext4_blocks_count(es),\n\t\t       le32_to_cpu(es->s_first_data_block),\n\t\t       EXT4_BLOCKS_PER_GROUP(sb));\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_groups_count = blocks_count;\n\tsbi->s_blockfile_groups = min_t(ext4_group_t, sbi->s_groups_count,\n\t\t\t(EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP(sb)));\n\tdb_count = (sbi->s_groups_count + EXT4_DESC_PER_BLOCK(sb) - 1) /\n\t\t   EXT4_DESC_PER_BLOCK(sb);\n\tsbi->s_group_desc = ext4_kvmalloc(db_count *\n\t\t\t\t\t  sizeof(struct buffer_head *),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (sbi->s_group_desc == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount;\n\t}\n\n\tbgl_lock_init(sbi->s_blockgroup_lock);\n\n\tfor (i = 0; i < db_count; i++) {\n\t\tblock = descriptor_loc(sb, logical_sb_block, i);\n\t\tsbi->s_group_desc[i] = sb_bread_unmovable(sb, block);\n\t\tif (!sbi->s_group_desc[i]) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"can't read group descriptor %d\", i);\n\t\t\tdb_count = i;\n\t\t\tgoto failed_mount2;\n\t\t}\n\t}\n\tif (!ext4_check_descriptors(sb, &first_not_zeroed)) {\n\t\text4_msg(sb, KERN_ERR, \"group descriptors corrupted!\");\n\t\tret = -EFSCORRUPTED;\n\t\tgoto failed_mount2;\n\t}\n\n\tsbi->s_gdb_count = db_count;\n\tget_random_bytes(&sbi->s_next_generation, sizeof(u32));\n\tspin_lock_init(&sbi->s_next_gen_lock);\n\n\tsetup_timer(&sbi->s_err_report, print_daily_error_info,\n\t\t(unsigned long) sb);\n\n\t/* Register extent status tree shrinker */\n\tif (ext4_es_register_shrinker(sbi))\n\t\tgoto failed_mount3;\n\n\tsbi->s_stripe = ext4_get_stripe_size(sbi);\n\tsbi->s_extent_max_zeroout_kb = 32;\n\n\t/*\n\t * set up enough so that it can read an inode\n\t */\n\tsb->s_op = &ext4_sops;\n\tsb->s_export_op = &ext4_export_ops;\n\tsb->s_xattr = ext4_xattr_handlers;\n#ifdef CONFIG_QUOTA\n\tsb->dq_op = &ext4_quota_operations;\n\tif (ext4_has_feature_quota(sb))\n\t\tsb->s_qcop = &dquot_quotactl_sysfile_ops;\n\telse\n\t\tsb->s_qcop = &ext4_qctl_operations;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP | QTYPE_MASK_PRJ;\n#endif\n\tmemcpy(sb->s_uuid, es->s_uuid, sizeof(es->s_uuid));\n\n\tINIT_LIST_HEAD(&sbi->s_orphan); /* unlinked but open files */\n\tmutex_init(&sbi->s_orphan_lock);\n\n\tsb->s_root = NULL;\n\n\tneeds_recovery = (es->s_last_orphan != 0 ||\n\t\t\t  ext4_has_feature_journal_needs_recovery(sb));\n\n\tif (ext4_has_feature_mmp(sb) && !(sb->s_flags & MS_RDONLY))\n\t\tif (ext4_multi_mount_protect(sb, le64_to_cpu(es->s_mmp_block)))\n\t\t\tgoto failed_mount3a;\n\n\t/*\n\t * The first inode we look at is the journal inode.  Don't try\n\t * root first: it may be modified in the journal!\n\t */\n\tif (!test_opt(sb, NOLOAD) && ext4_has_feature_journal(sb)) {\n\t\tif (ext4_load_journal(sb, es, journal_devnum))\n\t\t\tgoto failed_mount3a;\n\t} else if (test_opt(sb, NOLOAD) && !(sb->s_flags & MS_RDONLY) &&\n\t\t   ext4_has_feature_journal_needs_recovery(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"required journal recovery \"\n\t\t       \"suppressed and not mounted read-only\");\n\t\tgoto failed_mount_wq;\n\t} else {\n\t\t/* Nojournal mode, all journal mount options are illegal */\n\t\tif (test_opt2(sb, EXPLICIT_JOURNAL_CHECKSUM)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_checksum, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"journal_async_commit, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (sbi->s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE*HZ) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"commit=%lu, fs mounted w/o journal\",\n\t\t\t\t sbi->s_commit_interval / HZ);\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tif (EXT4_MOUNT_DATA_FLAGS &\n\t\t    (sbi->s_mount_opt ^ sbi->s_def_mount_opt)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"data=, fs mounted w/o journal\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\t\tsbi->s_def_mount_opt &= EXT4_MOUNT_JOURNAL_CHECKSUM;\n\t\tclear_opt(sb, JOURNAL_CHECKSUM);\n\t\tclear_opt(sb, DATA_FLAGS);\n\t\tsbi->s_journal = NULL;\n\t\tneeds_recovery = 0;\n\t\tgoto no_journal;\n\t}\n\n\tif (ext4_has_feature_64bit(sb) &&\n\t    !jbd2_journal_set_features(EXT4_SB(sb)->s_journal, 0, 0,\n\t\t\t\t       JBD2_FEATURE_INCOMPAT_64BIT)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set 64-bit journal feature\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (!set_journal_csum_feature_set(sb)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set journal checksum \"\n\t\t\t \"feature set\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\t/* We have now updated the journal if required, so we can\n\t * validate the data journaling mode. */\n\tswitch (test_opt(sb, DATA_FLAGS)) {\n\tcase 0:\n\t\t/* No mode set, assume a default based on the journal\n\t\t * capabilities: ORDERED_DATA if the journal can\n\t\t * cope, else JOURNAL_DATA\n\t\t */\n\t\tif (jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE))\n\t\t\tset_opt(sb, ORDERED_DATA);\n\t\telse\n\t\t\tset_opt(sb, JOURNAL_DATA);\n\t\tbreak;\n\n\tcase EXT4_MOUNT_ORDERED_DATA:\n\tcase EXT4_MOUNT_WRITEBACK_DATA:\n\t\tif (!jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Journal does not support \"\n\t\t\t       \"requested data journaling mode\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\tdefault:\n\t\tbreak;\n\t}\n\tset_task_ioprio(sbi->s_journal->j_task, journal_ioprio);\n\n\tsbi->s_journal->j_commit_callback = ext4_journal_commit_callback;\n \n no_journal:\n \tif (ext4_mballoc_ready) {\n\t\tsbi->s_mb_cache = ext4_xattr_create_cache(sb->s_id);\n \t\tif (!sbi->s_mb_cache) {\n \t\t\text4_msg(sb, KERN_ERR, \"Failed to create an mb_cache\");\n \t\t\tgoto failed_mount_wq;\n\t\t}\n\t}\n\n\tif ((DUMMY_ENCRYPTION_ENABLED(sbi) || ext4_has_feature_encrypt(sb)) &&\n\t    (blocksize != PAGE_CACHE_SIZE)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t \"Unsupported blocksize for fs encryption\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (DUMMY_ENCRYPTION_ENABLED(sbi) && !(sb->s_flags & MS_RDONLY) &&\n\t    !ext4_has_feature_encrypt(sb)) {\n\t\text4_set_feature_encrypt(sb);\n\t\text4_commit_super(sb, 1);\n\t}\n\n\t/*\n\t * Get the # of file system overhead blocks from the\n\t * superblock if present.\n\t */\n\tif (es->s_overhead_clusters)\n\t\tsbi->s_overhead = le32_to_cpu(es->s_overhead_clusters);\n\telse {\n\t\terr = ext4_calculate_overhead(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount_wq;\n\t}\n\n\t/*\n\t * The maximum number of concurrent works can be high and\n\t * concurrency isn't really necessary.  Limit it to 1.\n\t */\n\tEXT4_SB(sb)->rsv_conversion_wq =\n\t\talloc_workqueue(\"ext4-rsv-conversion\", WQ_MEM_RECLAIM | WQ_UNBOUND, 1);\n\tif (!EXT4_SB(sb)->rsv_conversion_wq) {\n\t\tprintk(KERN_ERR \"EXT4-fs: failed to create workqueue\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\t/*\n\t * The jbd2_journal_load will have done any necessary log recovery,\n\t * so we can safely mount the rest of the filesystem now.\n\t */\n\n\troot = ext4_iget(sb, EXT4_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\text4_msg(sb, KERN_ERR, \"get root inode failed\");\n\t\tret = PTR_ERR(root);\n\t\troot = NULL;\n\t\tgoto failed_mount4;\n\t}\n\tif (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {\n\t\text4_msg(sb, KERN_ERR, \"corrupt root inode, run e2fsck\");\n\t\tiput(root);\n\t\tgoto failed_mount4;\n\t}\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\text4_msg(sb, KERN_ERR, \"get root dentry failed\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\tif (ext4_setup_super(sb, es, sb->s_flags & MS_RDONLY))\n\t\tsb->s_flags |= MS_RDONLY;\n\n\t/* determine the minimum size of new large inodes, if present */\n\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t     EXT4_GOOD_OLD_INODE_SIZE;\n\t\tif (ext4_has_feature_extra_isize(sb)) {\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_want_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_want_extra_isize);\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_min_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_min_extra_isize);\n\t\t}\n\t}\n\t/* Check if enough inode space is available */\n\tif (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >\n\t\t\t\t\t\t\tsbi->s_inode_size) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t       EXT4_GOOD_OLD_INODE_SIZE;\n\t\text4_msg(sb, KERN_INFO, \"required extra inode space not\"\n\t\t\t \"available\");\n\t}\n\n\text4_set_resv_clusters(sb);\n\n\terr = ext4_setup_system_zone(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize system \"\n\t\t\t \"zone (%d)\", err);\n\t\tgoto failed_mount4a;\n\t}\n\n\text4_ext_init(sb);\n\terr = ext4_mb_init(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize mballoc (%d)\",\n\t\t\t err);\n\t\tgoto failed_mount5;\n\t}\n\n\tblock = ext4_count_free_clusters(sb);\n\text4_free_blocks_count_set(sbi->s_es, \n\t\t\t\t   EXT4_C2B(sbi, block));\n\terr = percpu_counter_init(&sbi->s_freeclusters_counter, block,\n\t\t\t\t  GFP_KERNEL);\n\tif (!err) {\n\t\tunsigned long freei = ext4_count_free_inodes(sb);\n\t\tsbi->s_es->s_free_inodes_count = cpu_to_le32(freei);\n\t\terr = percpu_counter_init(&sbi->s_freeinodes_counter, freei,\n\t\t\t\t\t  GFP_KERNEL);\n\t}\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirs_counter,\n\t\t\t\t\t  ext4_count_dirs(sb), GFP_KERNEL);\n\tif (!err)\n\t\terr = percpu_counter_init(&sbi->s_dirtyclusters_counter, 0,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"insufficient memory\");\n\t\tgoto failed_mount6;\n\t}\n\n\tif (ext4_has_feature_flex_bg(sb))\n\t\tif (!ext4_fill_flex_info(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unable to initialize \"\n\t\t\t       \"flex_bg meta info!\");\n\t\t\tgoto failed_mount6;\n\t\t}\n\n\terr = ext4_register_li_request(sb, first_not_zeroed);\n\tif (err)\n\t\tgoto failed_mount6;\n\n\terr = ext4_register_sysfs(sb);\n\tif (err)\n\t\tgoto failed_mount7;\n\n#ifdef CONFIG_QUOTA\n\t/* Enable quota usage during mount. */\n\tif (ext4_has_feature_quota(sb) && !(sb->s_flags & MS_RDONLY)) {\n\t\terr = ext4_enable_quotas(sb);\n\t\tif (err)\n\t\t\tgoto failed_mount8;\n\t}\n#endif  /* CONFIG_QUOTA */\n\n\tEXT4_SB(sb)->s_mount_state |= EXT4_ORPHAN_FS;\n\text4_orphan_cleanup(sb, es);\n\tEXT4_SB(sb)->s_mount_state &= ~EXT4_ORPHAN_FS;\n\tif (needs_recovery) {\n\t\text4_msg(sb, KERN_INFO, \"recovery complete\");\n\t\text4_mark_recovery_complete(sb, es);\n\t}\n\tif (EXT4_SB(sb)->s_journal) {\n\t\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)\n\t\t\tdescr = \" journalled data mode\";\n\t\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)\n\t\t\tdescr = \" ordered data mode\";\n\t\telse\n\t\t\tdescr = \" writeback data mode\";\n\t} else\n\t\tdescr = \"out journal\";\n\n\tif (test_opt(sb, DISCARD)) {\n\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\tif (!blk_queue_discard(q))\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"mounting with \\\"discard\\\" option, but \"\n\t\t\t\t \"the device does not support discard\");\n\t}\n\n\tif (___ratelimit(&ext4_mount_msg_ratelimit, \"EXT4-fs mount\"))\n\t\text4_msg(sb, KERN_INFO, \"mounted filesystem with%s. \"\n\t\t\t \"Opts: %s%s%s\", descr, sbi->s_es->s_mount_opts,\n\t\t\t *sbi->s_es->s_mount_opts ? \"; \" : \"\", orig_data);\n\n\tif (es->s_error_count)\n\t\tmod_timer(&sbi->s_err_report, jiffies + 300*HZ); /* 5 minutes */\n\n\t/* Enable message ratelimiting. Default is 10 messages per 5 secs. */\n\tratelimit_state_init(&sbi->s_err_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_warning_ratelimit_state, 5 * HZ, 10);\n\tratelimit_state_init(&sbi->s_msg_ratelimit_state, 5 * HZ, 10);\n\n\tkfree(orig_data);\n\treturn 0;\n\ncantfind_ext4:\n\tif (!silent)\n\t\text4_msg(sb, KERN_ERR, \"VFS: Can't find ext4 filesystem\");\n\tgoto failed_mount;\n\n#ifdef CONFIG_QUOTA\nfailed_mount8:\n\text4_unregister_sysfs(sb);\n#endif\nfailed_mount7:\n\text4_unregister_li_request(sb);\nfailed_mount6:\n\text4_mb_release(sb);\n\tif (sbi->s_flex_groups)\n\t\tkvfree(sbi->s_flex_groups);\n\tpercpu_counter_destroy(&sbi->s_freeclusters_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tpercpu_counter_destroy(&sbi->s_dirtyclusters_counter);\nfailed_mount5:\n\text4_ext_release(sb);\n\text4_release_system_zone(sb);\nfailed_mount4a:\n\tdput(sb->s_root);\n\tsb->s_root = NULL;\nfailed_mount4:\n\text4_msg(sb, KERN_ERR, \"mount failed\");\n \tif (EXT4_SB(sb)->rsv_conversion_wq)\n \t\tdestroy_workqueue(EXT4_SB(sb)->rsv_conversion_wq);\n failed_mount_wq:\n \tif (sbi->s_journal) {\n \t\tjbd2_journal_destroy(sbi->s_journal);\n \t\tsbi->s_journal = NULL;\n\t}\nfailed_mount3a:\n\text4_es_unregister_shrinker(sbi);\nfailed_mount3:\n\tdel_timer_sync(&sbi->s_err_report);\n\tif (sbi->s_mmp_tsk)\n\t\tkthread_stop(sbi->s_mmp_tsk);\nfailed_mount2:\n\tfor (i = 0; i < db_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\n\tkvfree(sbi->s_group_desc);\nfailed_mount:\n\tif (sbi->s_chksum_driver)\n\t\tcrypto_free_shash(sbi->s_chksum_driver);\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\text4_blkdev_remove(sbi);\n\tbrelse(bh);\nout_fail:\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\n\tkfree(sbi);\nout_free_orig:\n\tkfree(orig_data);\n\treturn err ? err : ret;\n}\n", "target": 1, "idx": 183158}
{"func": "cib_shutdown(int nsig)\n{\n    struct qb_ipcs_stats srv_stats;\n    if (cib_shutdown_flag == FALSE) {\n        int disconnects = 0;\n        qb_ipcs_connection_t *c = NULL;\n\n        cib_shutdown_flag = TRUE;\n\n        c = qb_ipcs_connection_first_get(ipcs_rw);\n        while(c != NULL) {\n            qb_ipcs_connection_t *last = c;\n            c = qb_ipcs_connection_next_get(ipcs_rw, last);\n\n            crm_debug(\"Disconnecting r/w client %p...\", last);\n            qb_ipcs_disconnect(last);\n            qb_ipcs_connection_unref(last);\n            disconnects++;\n        }\n\n        c = qb_ipcs_connection_first_get(ipcs_ro);\n        while(c != NULL) {\n            qb_ipcs_connection_t *last = c;\n            c = qb_ipcs_connection_next_get(ipcs_ro, last);\n\n            crm_debug(\"Disconnecting r/o client %p...\", last);\n            qb_ipcs_disconnect(last);\n            qb_ipcs_connection_unref(last);\n            disconnects++;\n        }\n\n        c = qb_ipcs_connection_first_get(ipcs_shm);\n        while(c != NULL) {\n            qb_ipcs_connection_t *last = c;\n            c = qb_ipcs_connection_next_get(ipcs_shm, last);\n\n            crm_debug(\"Disconnecting non-blocking r/w client %p...\", last);\n            qb_ipcs_disconnect(last);\n            qb_ipcs_connection_unref(last);\n            disconnects++;\n        }\n\n        disconnects += g_hash_table_size(client_list);\n\n        crm_debug(\"Disconnecting %d remote clients\", g_hash_table_size(client_list));\n        g_hash_table_foreach(client_list, disconnect_remote_client, NULL);\n        crm_info(\"Disconnected %d clients\", disconnects);\n    }\n\n    qb_ipcs_stats_get(ipcs_rw, &srv_stats, QB_FALSE);\n    \n    if(g_hash_table_size(client_list) == 0) {\n        crm_info(\"All clients disconnected (%d)\", srv_stats.active_connections);\n        initiate_exit();\n        \n    } else {\n        crm_info(\"Waiting on %d clients to disconnect (%d)\", g_hash_table_size(client_list), srv_stats.active_connections);\n    }\n}\n", "target": 0, "idx": 33866}
{"func": "PassRefPtrWillBeRawPtr<Node> ContainerNode::replaceChild(PassRefPtrWillBeRawPtr<Node> newChild, PassRefPtrWillBeRawPtr<Node> oldChild, ExceptionState& exceptionState)\n{\n#if !ENABLE(OILPAN)\n    ASSERT(refCount() || parentOrShadowHostNode());\n#endif\n\n    RefPtrWillBeRawPtr<Node> protect(this);\n\n    if (oldChild == newChild) // Nothing to do.\n        return oldChild;\n\n    if (!oldChild) {\n        exceptionState.throwDOMException(NotFoundError, \"The node to be replaced is null.\");\n        return nullptr;\n    }\n\n    RefPtrWillBeRawPtr<Node> child = oldChild;\n\n    if (!checkAcceptChild(newChild.get(), child.get(), exceptionState)) {\n        if (exceptionState.hadException())\n            return nullptr;\n        return child;\n    }\n\n    if (child->parentNode() != this) {\n        exceptionState.throwDOMException(NotFoundError, \"The node to be replaced is not a child of this node.\");\n        return nullptr;\n    }\n\n    ChildListMutationScope mutation(*this);\n\n    RefPtrWillBeRawPtr<Node> next = child->nextSibling();\n\n    removeChild(child, exceptionState);\n    if (exceptionState.hadException())\n        return nullptr;\n\n    if (next && (next->previousSibling() == newChild || next == newChild)) // nothing to do\n        return child;\n\n    if (!checkAcceptChild(newChild.get(), child.get(), exceptionState)) {\n        if (exceptionState.hadException())\n            return nullptr;\n        return child;\n    }\n\n    NodeVector targets;\n    collectChildrenAndRemoveFromOldParent(*newChild, targets, exceptionState);\n    if (exceptionState.hadException())\n        return nullptr;\n\n    if (!checkAcceptChild(newChild.get(), child.get(), exceptionState)) {\n        if (exceptionState.hadException())\n            return nullptr;\n        return child;\n    }\n\n    InspectorInstrumentation::willInsertDOMNode(this);\n\n    for (const auto& targetNode : targets) {\n        ASSERT(targetNode);\n        Node& child = *targetNode;\n\n        if (next && next->parentNode() != this)\n            break;\n        if (child.parentNode())\n            break;\n\n        treeScope().adoptIfNeeded(child);\n\n        {\n            EventDispatchForbiddenScope assertNoEventDispatch;\n            if (next)\n                insertBeforeCommon(*next, child);\n            else\n                appendChildCommon(child);\n        }\n\n        updateTreeAfterInsertion(child);\n    }\n\n    dispatchSubtreeModifiedEvent();\n    return child;\n}\n", "target": 0, "idx": 135969}
{"func": "int ipmi_destroy_user(struct ipmi_user *user)\n {\n \t_ipmi_destroy_user(user);\n \n\tcleanup_srcu_struct(&user->release_barrier);\n \tkref_put(&user->refcount, free_user);\n \n \treturn 0;\n}\n", "target": 1, "idx": 182898}
{"func": "static int php_stream_temp_cast(php_stream *stream, int castas, void **ret TSRMLS_DC)\n{\n\tphp_stream_temp_data *ts = (php_stream_temp_data*)stream->abstract;\n\tphp_stream *file;\n\tsize_t memsize;\n\tchar *membuf;\n\toff_t pos;\n\n\tassert(ts != NULL);\n\n\tif (!ts->innerstream) {\n\t\treturn FAILURE;\n\t}\n\tif (php_stream_is(ts->innerstream, PHP_STREAM_IS_STDIO)) {\n\t\treturn php_stream_cast(ts->innerstream, castas, ret, 0);\n\t}\n\n\t/* we are still using a memory based backing. If they are if we can be\n\t * a FILE*, say yes because we can perform the conversion.\n\t * If they actually want to perform the conversion, we need to switch\n\t * the memory stream to a tmpfile stream */\n\n\tif (ret == NULL && castas == PHP_STREAM_AS_STDIO) {\n\t\treturn SUCCESS;\n\t}\n\n\t/* say \"no\" to other stream forms */\n\tif (ret == NULL) {\n\t\treturn FAILURE;\n\t}\n\n\t/* perform the conversion and then pass the request on to the innerstream */\n\tmembuf = php_stream_memory_get_buffer(ts->innerstream, &memsize);\n        file = php_stream_fopen_tmpfile();\n        php_stream_write(file, membuf, memsize);\n        pos = php_stream_tell(ts->innerstream);\n        php_stream_free_enclosed(ts->innerstream, PHP_STREAM_FREE_CLOSE);\n        ts->innerstream = file;\n        php_stream_encloses(stream, ts->innerstream);\n\tphp_stream_seek(ts->innerstream, pos, SEEK_SET);\n\n\treturn php_stream_cast(ts->innerstream, castas, ret, 1);\n}\n", "target": 1, "idx": 178650}
{"func": "void FrameLoader::clear(bool clearWindowProperties, bool clearScriptObjects, bool clearFrameView)\n{\n    m_frame->editor()->clear();\n\n    if (!m_needsClear)\n        return;\n    m_needsClear = false;\n    \n    if (!m_frame->document()->inPageCache()) {\n        m_frame->document()->cancelParsing();\n        m_frame->document()->stopActiveDOMObjects();\n        if (m_frame->document()->attached()) {\n            m_frame->document()->willRemove();\n            m_frame->document()->detach();\n            \n            m_frame->document()->removeFocusedNodeOfSubtree(m_frame->document());\n        }\n    }\n\n    if (clearWindowProperties) {\n        m_frame->clearDOMWindow();\n        m_frame->script()->clearWindowShell();\n    }\n\n    m_frame->selection()->clear();\n    m_frame->eventHandler()->clear();\n    if (clearFrameView && m_frame->view())\n        m_frame->view()->clear();\n\n    m_frame->setSelectionGranularity(CharacterGranularity);\n\n    m_frame->setDocument(0);\n    m_decoder = 0;\n\n    m_containsPlugIns = false;\n\n    if (clearScriptObjects)\n        m_frame->script()->clearScriptObjects();\n\n    m_frame->redirectScheduler()->clear();\n\n    m_checkTimer.stop();\n    m_shouldCallCheckCompleted = false;\n    m_shouldCallCheckLoadComplete = false;\n\n    m_receivedData = false;\n    m_isDisplayingInitialEmptyDocument = false;\n\n    if (!m_encodingWasChosenByUser)\n        m_encoding = String();\n}\n", "target": 0, "idx": 97369}
{"func": "void RenderFrameHostImpl::RegisterMojoInterfaces() {\n#if !defined(OS_ANDROID)\n  registry_->AddInterface(base::Bind(&InstalledAppProviderImplDefault::Create));\n#endif  // !defined(OS_ANDROID)\n\n  PermissionManager* permission_manager =\n      GetProcess()->GetBrowserContext()->GetPermissionManager();\n\n  if (delegate_) {\n    auto* geolocation_context = delegate_->GetGeolocationContext();\n    if (geolocation_context && permission_manager) {\n      geolocation_service_.reset(new GeolocationServiceImpl(\n          geolocation_context, permission_manager, this));\n      registry_->AddInterface(\n          base::Bind(&GeolocationServiceImpl::Bind,\n                     base::Unretained(geolocation_service_.get())));\n    }\n  }\n\n  registry_->AddInterface<device::mojom::WakeLock>(base::Bind(\n      &RenderFrameHostImpl::BindWakeLockRequest, base::Unretained(this)));\n\n#if defined(OS_ANDROID)\n  if (base::FeatureList::IsEnabled(features::kWebNfc)) {\n    registry_->AddInterface<device::mojom::NFC>(base::Bind(\n        &RenderFrameHostImpl::BindNFCRequest, base::Unretained(this)));\n  }\n#endif\n\n  if (!permission_service_context_)\n    permission_service_context_.reset(new PermissionServiceContext(this));\n\n  registry_->AddInterface(\n      base::Bind(&PermissionServiceContext::CreateService,\n                 base::Unretained(permission_service_context_.get())));\n\n  registry_->AddInterface(\n      base::Bind(&RenderFrameHostImpl::BindPresentationServiceRequest,\n                 base::Unretained(this)));\n\n  registry_->AddInterface(\n      base::Bind(&MediaSessionServiceImpl::Create, base::Unretained(this)));\n\n#if defined(OS_ANDROID)\n  registry_->AddInterface<media::mojom::Renderer>(\n      base::Bind(&content::CreateMediaPlayerRenderer, GetProcess()->GetID(),\n                 GetRoutingID(), delegate_));\n#endif  // defined(OS_ANDROID)\n\n  registry_->AddInterface(base::Bind(\n      base::IgnoreResult(&RenderFrameHostImpl::CreateWebBluetoothService),\n      base::Unretained(this)));\n\n  registry_->AddInterface(base::BindRepeating(\n      &RenderFrameHostImpl::CreateUsbDeviceManager, base::Unretained(this)));\n\n  registry_->AddInterface(base::BindRepeating(\n      &RenderFrameHostImpl::CreateUsbChooserService, base::Unretained(this)));\n\n  registry_->AddInterface<media::mojom::InterfaceFactory>(\n      base::Bind(&RenderFrameHostImpl::BindMediaInterfaceFactoryRequest,\n                 base::Unretained(this)));\n\n  registry_->AddInterface(base::Bind(&WebSocketManager::CreateWebSocket,\n                                     process_->GetID(), routing_id_));\n\n  registry_->AddInterface(base::Bind(&SharedWorkerConnectorImpl::Create,\n                                     process_->GetID(), routing_id_));\n\n  registry_->AddInterface<device::mojom::VRService>(base::Bind(\n      &WebvrServiceProvider::BindWebvrService, base::Unretained(this)));\n\n  if (RenderFrameAudioInputStreamFactory::UseMojoFactories()) {\n    registry_->AddInterface(\n        base::BindRepeating(&RenderFrameHostImpl::CreateAudioInputStreamFactory,\n                            base::Unretained(this)));\n  }\n\n  if (RendererAudioOutputStreamFactoryContextImpl::UseMojoFactories()) {\n    registry_->AddInterface(base::BindRepeating(\n        &RenderFrameHostImpl::CreateAudioOutputStreamFactory,\n        base::Unretained(this)));\n  }\n\n  if (resource_coordinator::IsResourceCoordinatorEnabled()) {\n    registry_->AddInterface(\n        base::Bind(&CreateFrameResourceCoordinator, base::Unretained(this)));\n  }\n\n#if BUILDFLAG(ENABLE_WEBRTC)\n  if (BrowserMainLoop::GetInstance()) {\n    MediaStreamManager* media_stream_manager =\n        BrowserMainLoop::GetInstance()->media_stream_manager();\n    registry_->AddInterface(\n        base::Bind(&MediaDevicesDispatcherHost::Create, GetProcess()->GetID(),\n                   GetRoutingID(),\n                   base::Unretained(media_stream_manager)),\n        BrowserThread::GetTaskRunnerForThread(BrowserThread::IO));\n  }\n#endif\n\n#if BUILDFLAG(ENABLE_MEDIA_REMOTING)\n  registry_->AddInterface(base::Bind(&RemoterFactoryImpl::Bind,\n                                     GetProcess()->GetID(), GetRoutingID()));\n#endif  // BUILDFLAG(ENABLE_MEDIA_REMOTING)\n\n  registry_->AddInterface(base::Bind(\n      &KeyboardLockServiceImpl::CreateMojoService, base::Unretained(this)));\n\n  registry_->AddInterface(base::Bind(&ImageCaptureImpl::Create));\n\n#if !defined(OS_ANDROID)\n  if (base::FeatureList::IsEnabled(features::kWebAuth)) {\n    registry_->AddInterface(\n        base::Bind(&RenderFrameHostImpl::BindAuthenticatorRequest,\n                   base::Unretained(this)));\n  }\n#endif  // !defined(OS_ANDROID)\n\n  if (permission_manager) {\n    sensor_provider_proxy_.reset(\n        new SensorProviderProxyImpl(permission_manager, this));\n    registry_->AddInterface(\n        base::Bind(&SensorProviderProxyImpl::Bind,\n                   base::Unretained(sensor_provider_proxy_.get())));\n  }\n\n  registry_->AddInterface(base::BindRepeating(\n      &media::MediaMetricsProvider::Create,\n      GetSiteInstance()->GetBrowserContext()->IsOffTheRecord()\n          ? nullptr\n          : GetSiteInstance()\n                ->GetBrowserContext()\n                ->GetVideoDecodePerfHistory()));\n\n  if (base::CommandLine::ForCurrentProcess()->HasSwitch(\n          cc::switches::kEnableGpuBenchmarking)) {\n    registry_->AddInterface(\n        base::Bind(&InputInjectorImpl::Create, weak_ptr_factory_.GetWeakPtr()));\n  }\n\n  registry_->AddInterface(\n      base::BindRepeating(GetRestrictedCookieManager, base::Unretained(this)));\n\n  registry_->AddInterface(base::BindRepeating(\n      &QuotaDispatcherHost::CreateForFrame, GetProcess(), routing_id_));\n}\n", "target": 0, "idx": 160476}
{"func": "void page_put_link(void *arg)\n{\n\tput_page(arg);\n}\n", "target": 0, "idx": 51037}
{"func": "base::FilePath ChromeContentBrowserClient::GetShaderDiskCacheDirectory() {\n  base::FilePath user_data_dir;\n  base::PathService::Get(chrome::DIR_USER_DATA, &user_data_dir);\n  DCHECK(!user_data_dir.empty());\n  return user_data_dir.Append(FILE_PATH_LITERAL(\"ShaderCache\"));\n}\n", "target": 0, "idx": 155368}
{"func": "static int transport_read_nonblocking(rdpTransport* transport)\n{\n\tint status;\n\n\tstatus = transport_read(transport, transport->ReceiveBuffer);\n\n\tif (status <= 0)\n\t\treturn status;\n\n\tStream_Seek(transport->ReceiveBuffer, status);\n\n\treturn status;\n}\n", "target": 0, "idx": 58565}
{"func": "ftp_readline(ftpbuf_t *ftp)\n{\n\tlong\t\tsize, rcvd;\n\tchar\t\t*data, *eol;\n\n\t/* shift the extra to the front */\n\tsize = FTP_BUFSIZE;\n\trcvd = 0;\n\tif (ftp->extra) {\n\t\tmemmove(ftp->inbuf, ftp->extra, ftp->extralen);\n\t\trcvd = ftp->extralen;\n\t}\n\n\tdata = ftp->inbuf;\n\n\tdo {\n\t\tsize -= rcvd;\n\t\tfor (eol = data; rcvd; rcvd--, eol++) {\n\t\t\tif (*eol == '\\r') {\n\t\t\t\t*eol = 0;\n\t\t\t\tftp->extra = eol + 1;\n\t\t\t\tif (rcvd > 1 && *(eol + 1) == '\\n') {\n\t\t\t\t\tftp->extra++;\n\t\t\t\t\trcvd--;\n\t\t\t\t}\n\t\t\t\tif ((ftp->extralen = --rcvd) == 0) {\n\t\t\t\t\tftp->extra = NULL;\n\t\t\t\t}\n\t\t\t\treturn 1;\n\t\t\t} else if (*eol == '\\n') {\n\t\t\t\t*eol = 0;\n\t\t\t\tftp->extra = eol + 1;\n\t\t\t\tif ((ftp->extralen = --rcvd) == 0) {\n\t\t\t\t\tftp->extra = NULL;\n\t\t\t\t}\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\tdata = eol;\n\t\tif ((rcvd = my_recv(ftp, ftp->fd, data, size)) < 1) {\n\t\t\treturn 0;\n\t\t}\n\t} while (size);\n\n\treturn 0;\n}\n", "target": 0, "idx": 14806}
{"func": "parse_netscreen_hex_dump(FILE_T fh, int pkt_len, const char *cap_int,\n    const char *cap_dst, struct wtap_pkthdr *phdr, Buffer* buf,\n    int *err, gchar **err_info)\n{\n\tguint8\t*pd;\n\tgchar\tline[NETSCREEN_LINE_LENGTH];\n\tgchar\t*p;\n\tint\tn, i = 0, offset = 0;\n\tgchar\tdststr[13];\n \t/* Make sure we have enough room for the packet */\n\tws_buffer_assure_space(buf, NETSCREEN_MAX_PACKET_LEN);\n \tpd = ws_buffer_start_ptr(buf);\n \n \twhile(1) {\n\n\t\t/* The last packet is not delimited by an empty line, but by EOF\n\t\t * So accept EOF as a valid delimiter too\n\t\t */\n\t\tif (file_gets(line, NETSCREEN_LINE_LENGTH, fh) == NULL) {\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Skip blanks.\n\t\t * The number of blanks is not fixed - for wireless\n\t\t * interfaces, there may be 14 extra spaces before\n\t\t * the hex data.\n\t\t */\n\t\tfor (p = &line[0]; g_ascii_isspace(*p); p++)\n\t\t\t;\n\t\t/* packets are delimited with empty lines */\n\t\tif (*p == '\\0') {\n\t\t\tbreak;\n\t\t}\n\n\t\tn = parse_single_hex_dump_line(p, pd, offset);\n\n\t\t/* the smallest packet has a length of 6 bytes, if\n\t\t * the first hex-data is less then check whether\n\t\t * it is a info-line and act accordingly\n\t\t */\n\t\tif (offset == 0 && n < 6) {\n\t\t\tif (info_line(line)) {\n\t\t\t\tif (++i <= NETSCREEN_MAX_INFOLINES) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t\t\t*err_info = g_strdup(\"netscreen: cannot parse hex-data\");\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\n \t\t/* If there is no more data and the line was not empty,\n \t\t * then there must be an error in the file\n \t\t */\n\t\tif(n == -1) {\n \t\t\t*err = WTAP_ERR_BAD_FILE;\n \t\t\t*err_info = g_strdup(\"netscreen: cannot parse hex-data\");\n \t\t\treturn FALSE;\n\t\t}\n\n\t\t/* Adjust the offset to the data that was just added to the buffer */\n\t\toffset += n;\n\n \t\t/* If there was more hex-data than was announced in the len=x\n \t\t * header, then then there must be an error in the file\n \t\t */\n\t\tif(offset > pkt_len) {\n \t\t\t*err = WTAP_ERR_BAD_FILE;\n \t\t\t*err_info = g_strdup(\"netscreen: too much hex-data\");\n \t\t\treturn FALSE;\n\t\t}\n\t}\n\n\t/*\n\t * Determine the encapsulation type, based on the\n\t * first 4 characters of the interface name\n\t *\n\t * XXX\tconvert this to a 'case' structure when adding more\n\t *\t(non-ethernet) interfacetypes\n\t */\n\tif (strncmp(cap_int, \"adsl\", 4) == 0) {\n\t\t/* The ADSL interface can be bridged with or without\n\t\t * PPP encapsulation. Check whether the first six bytes\n\t\t * of the hex data are the same as the destination mac\n\t\t * address in the header. If they are, assume ethernet\n\t\t * LinkLayer or else PPP\n\t\t */\n\t\tg_snprintf(dststr, 13, \"%02x%02x%02x%02x%02x%02x\",\n\t\t   pd[0], pd[1], pd[2], pd[3], pd[4], pd[5]);\n\t\tif (strncmp(dststr, cap_dst, 12) == 0)\n\t\t\tphdr->pkt_encap = WTAP_ENCAP_ETHERNET;\n\t\telse\n\t\t\tphdr->pkt_encap = WTAP_ENCAP_PPP;\n\t\t}\n\telse if (strncmp(cap_int, \"seri\", 4) == 0)\n\t\tphdr->pkt_encap = WTAP_ENCAP_PPP;\n\telse\n\t\tphdr->pkt_encap = WTAP_ENCAP_ETHERNET;\n\n\tphdr->caplen = offset;\n\n\treturn TRUE;\n}\n", "target": 1, "idx": 180320}
{"func": "static void bs_open_read (Bitstream *bs, void *buffer_start, void *buffer_end)\n{\n    bs->error = bs->sr = bs->bc = 0;\n    bs->ptr = (bs->buf = buffer_start) - 1;\n    bs->end = buffer_end;\n    bs->wrap = bs_read;\n}\n", "target": 0, "idx": 70885}
{"func": "vips_malloc( VipsObject *object, size_t size )\n {\n \tvoid *buf;\n \n\tbuf = g_malloc( size );\n \n         if( object ) {\n \t\tg_signal_connect( object, \"postclose\", \n\t\t\tG_CALLBACK( vips_malloc_cb ), buf );\n\t\tobject->local_memory += size;\n\t}\n\n\treturn( buf );\n}\n", "target": 1, "idx": 182911}
{"func": "main(int argc, char **argv)\n{\n\tint ch, fflag, tflag, status, n;\n\tchar **newargv;\n\tconst char *errstr;\n\textern char *optarg;\n\textern int optind;\n\n\t/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */\n\tsanitise_stdfd();\n\n\tmsetlocale();\n\n\t/* Copy argv, because we modify it */\n\tnewargv = xcalloc(MAXIMUM(argc + 1, 1), sizeof(*newargv));\n\tfor (n = 0; n < argc; n++)\n\t\tnewargv[n] = xstrdup(argv[n]);\n\targv = newargv;\n\n\t__progname = ssh_get_progname(argv[0]);\n\n\tmemset(&args, '\\0', sizeof(args));\n\tmemset(&remote_remote_args, '\\0', sizeof(remote_remote_args));\n\targs.list = remote_remote_args.list = NULL;\n\taddargs(&args, \"%s\", ssh_program);\n\taddargs(&args, \"-x\");\n\taddargs(&args, \"-oForwardAgent=no\");\n\taddargs(&args, \"-oPermitLocalCommand=no\");\n\taddargs(&args, \"-oClearAllForwardings=yes\");\n\taddargs(&args, \"-oRemoteCommand=none\");\n\taddargs(&args, \"-oRequestTTY=no\");\n\n\tfflag = tflag = 0;\n\twhile ((ch = getopt(argc, argv, \"dfl:prtvBCc:i:P:q12346S:o:F:\")) != -1)\n\t\tswitch (ch) {\n\t\t/* User-visible flags. */\n\t\tcase '1':\n\t\t\tfatal(\"SSH protocol v.1 is no longer supported\");\n\t\t\tbreak;\n\t\tcase '2':\n\t\t\t/* Ignored */\n\t\t\tbreak;\n\t\tcase '4':\n\t\tcase '6':\n\t\tcase 'C':\n\t\t\taddargs(&args, \"-%c\", ch);\n\t\t\taddargs(&remote_remote_args, \"-%c\", ch);\n\t\t\tbreak;\n\t\tcase '3':\n\t\t\tthroughlocal = 1;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\tcase 'c':\n\t\tcase 'i':\n\t\tcase 'F':\n\t\t\taddargs(&remote_remote_args, \"-%c\", ch);\n\t\t\taddargs(&remote_remote_args, \"%s\", optarg);\n\t\t\taddargs(&args, \"-%c\", ch);\n\t\t\taddargs(&args, \"%s\", optarg);\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tsshport = a2port(optarg);\n\t\t\tif (sshport <= 0)\n\t\t\t\tfatal(\"bad port \\\"%s\\\"\\n\", optarg);\n\t\t\tbreak;\n\t\tcase 'B':\n\t\t\taddargs(&remote_remote_args, \"-oBatchmode=yes\");\n\t\t\taddargs(&args, \"-oBatchmode=yes\");\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tlimit_kbps = strtonum(optarg, 1, 100 * 1024 * 1024,\n\t\t\t    &errstr);\n\t\t\tif (errstr != NULL)\n\t\t\t\tusage();\n\t\t\tlimit_kbps *= 1024; /* kbps */\n\t\t\tbandwidth_limit_init(&bwlimit, limit_kbps, COPY_BUFLEN);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tpflag = 1;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tiamrecursive = 1;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tssh_program = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\taddargs(&args, \"-v\");\n\t\t\taddargs(&remote_remote_args, \"-v\");\n\t\t\tverbose_mode = 1;\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\taddargs(&args, \"-q\");\n\t\t\taddargs(&remote_remote_args, \"-q\");\n\t\t\tshowprogress = 0;\n\t\t\tbreak;\n\n\t\t/* Server options. */\n\t\tcase 'd':\n\t\t\ttargetshouldbedirectory = 1;\n\t\t\tbreak;\n\t\tcase 'f':\t/* \"from\" */\n\t\t\tiamremote = 1;\n\t\t\tfflag = 1;\n\t\t\tbreak;\n\t\tcase 't':\t/* \"to\" */\n\t\t\tiamremote = 1;\n\t\t\ttflag = 1;\n#ifdef HAVE_CYGWIN\n\t\t\tsetmode(0, O_BINARY);\n#endif\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t}\n\targc -= optind;\n\targv += optind;\n\n\tif ((pwd = getpwuid(userid = getuid())) == NULL)\n\t\tfatal(\"unknown user %u\", (u_int) userid);\n\n\tif (!isatty(STDOUT_FILENO))\n\t\tshowprogress = 0;\n\n\tif (pflag) {\n\t\t/* Cannot pledge: -p allows setuid/setgid files... */\n\t} else {\n\t\tif (pledge(\"stdio rpath wpath cpath fattr tty proc exec\",\n\t\t    NULL) == -1) {\n\t\t\tperror(\"pledge\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tremin = STDIN_FILENO;\n\tremout = STDOUT_FILENO;\n\n\tif (fflag) {\n\t\t/* Follow \"protocol\", send data. */\n\t\t(void) response();\n\t\tsource(argc, argv);\n\t\texit(errs != 0);\n\t}\n\tif (tflag) {\n\t\t/* Receive data. */\n\t\tsink(argc, argv);\n\t\texit(errs != 0);\n\t}\n\tif (argc < 2)\n\t\tusage();\n\tif (argc > 2)\n\t\ttargetshouldbedirectory = 1;\n\n\tremin = remout = -1;\n\tdo_cmd_pid = -1;\n\t/* Command to be executed on remote system using \"ssh\". */\n\t(void) snprintf(cmd, sizeof cmd, \"scp%s%s%s%s\",\n\t    verbose_mode ? \" -v\" : \"\",\n\t    iamrecursive ? \" -r\" : \"\", pflag ? \" -p\" : \"\",\n\t    targetshouldbedirectory ? \" -d\" : \"\");\n\n\t(void) signal(SIGPIPE, lostconn);\n\n\tif (colon(argv[argc - 1]))\t/* Dest is remote host. */\n\t\ttoremote(argc, argv);\n\telse {\n\t\tif (targetshouldbedirectory)\n\t\t\tverifydir(argv[argc - 1]);\n\t\ttolocal(argc, argv);\t/* Dest is local host. */\n\t}\n\t/*\n\t * Finally check the exit status of the ssh process, if one was forked\n\t * and no error has occurred yet\n\t */\n\tif (do_cmd_pid != -1 && errs == 0) {\n\t\tif (remin != -1)\n\t\t    (void) close(remin);\n\t\tif (remout != -1)\n\t\t    (void) close(remout);\n\t\tif (waitpid(do_cmd_pid, &status, 0) == -1)\n\t\t\terrs = 1;\n\t\telse {\n\t\t\tif (!WIFEXITED(status) || WEXITSTATUS(status) != 0)\n\t\t\t\terrs = 1;\n\t\t}\n\t}\n\texit(errs != 0);\n}\n", "target": 0, "idx": 92903}
{"func": " void SynchronousCompositorImpl::PostInvalidate() {\n   DCHECK(CalledOnValidThread());\n   DCHECK(compositor_client_);\n  compositor_client_->PostInvalidate();\n }\n", "target": 1, "idx": 185591}
{"func": "int gdTransformAffineGetImage(gdImagePtr *dst,\n\t\t  const gdImagePtr src,\n\t\t  gdRectPtr src_area,\n\t\t  const double affine[6])\n{\n\tint res;\n\tdouble m[6];\n\tgdRect bbox;\n\tgdRect area_full;\n\n\tif (src_area == NULL) {\n\t\tarea_full.x = 0;\n\t\tarea_full.y = 0;\n\t\tarea_full.width  = gdImageSX(src);\n\t\tarea_full.height = gdImageSY(src);\n\t\tsrc_area = &area_full;\n\t}\n\n\tgdTransformAffineBoundingBox(src_area, affine, &bbox);\n\n\t*dst = gdImageCreateTrueColor(bbox.width, bbox.height);\n\tif (*dst == NULL) {\n\t\treturn GD_FALSE;\n\t}\n\t(*dst)->saveAlphaFlag = 1;\n\n \tif (!src->trueColor) {\n \t\tgdImagePaletteToTrueColor(src);\n \t}\n \t/* Translate to dst origin (0,0) */\n \tgdAffineTranslate(m, -bbox.x, -bbox.y);\n \tgdAffineConcat(m, affine, m);\n\n\tgdImageAlphaBlending(*dst, 0);\n\n\tres = gdTransformAffineCopy(*dst,\n\t\t  0,0,\n\t\t  src,\n\t\t  src_area,\n\t\t  m);\n\n\tif (res != GD_TRUE) {\n\t\tgdImageDestroy(*dst);\n\t\tdst = NULL;\n\t\treturn GD_FALSE;\n\t} else {\n\t\treturn GD_TRUE;\n\t}\n}\n", "target": 1, "idx": 183179}
{"func": "gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\t   gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n\t\t   int iov_count)\n{\n    OM_uint32 status;\n    gss_union_ctx_id_t ctx;\n    gss_mechanism mech;\n\n    status = val_unwrap_iov_args(minor_status, context_handle, NULL,\n\t\t\t\t qop_state, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\treturn status;\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;\n    if (mech->gss_verify_mic_iov == NULL)\n\treturn GSS_S_UNAVAILABLE;\n    status = mech->gss_verify_mic_iov(minor_status, ctx->internal_ctx_id,\n\t\t\t\t      qop_state, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\tmap_error(minor_status, mech);\n    return status;\n}\n", "target": 1, "idx": 181198}
{"func": "int Reverb_command(effect_handle_t  self,\n uint32_t            cmdCode,\n uint32_t            cmdSize,\n void *pCmdData,\n uint32_t *replySize,\n void *pReplyData){\n    android::ReverbContext * pContext = (android::ReverbContext *) self;\n int retsize;\n    LVREV_ControlParams_st    ActiveParams; /* Current control Parameters */\n    LVREV_ReturnStatus_en     LvmStatus=LVREV_SUCCESS; /* Function call status */\n\n\n if (pContext == NULL){\n        ALOGV(\"\\tLVM_ERROR : Reverb_command ERROR pContext == NULL\");\n return -EINVAL;\n }\n\n\n switch (cmdCode){\n case EFFECT_CMD_INIT:\n\n if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)){\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_INIT: ERROR\");\n return -EINVAL;\n }\n *(int *) pReplyData = 0;\n break;\n\n case EFFECT_CMD_SET_CONFIG:\n if (pCmdData == NULL || cmdSize != sizeof(effect_config_t) ||\n                    pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_SET_CONFIG: ERROR\");\n return -EINVAL;\n }\n *(int *) pReplyData = android::Reverb_setConfig(pContext,\n (effect_config_t *) pCmdData);\n break;\n\n case EFFECT_CMD_GET_CONFIG:\n if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(effect_config_t)) {\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_GET_CONFIG: ERROR\");\n return -EINVAL;\n }\n\n            android::Reverb_getConfig(pContext, (effect_config_t *)pReplyData);\n break;\n\n case EFFECT_CMD_RESET:\n Reverb_setConfig(pContext, &pContext->config);\n break;\n\n case EFFECT_CMD_GET_PARAM:{\n\n             effect_param_t *p = (effect_param_t *)pCmdData;\n             if (pCmdData == NULL || cmdSize < sizeof(effect_param_t) ||\n                     cmdSize < (sizeof(effect_param_t) + p->psize) ||\n                     pReplyData == NULL || replySize == NULL ||\n *replySize < (sizeof(effect_param_t) + p->psize)) {\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_GET_PARAM: ERROR\");\n return -EINVAL;\n }\n\n            memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + p->psize);\n\n            p = (effect_param_t *)pReplyData;\n\n int voffset = ((p->psize - 1) / sizeof(int32_t) + 1) * sizeof(int32_t);\n\n            p->status = android::Reverb_getParameter(pContext,\n (void *)p->data,\n (size_t *)&p->vsize,\n                                                          p->data + voffset);\n\n *replySize = sizeof(effect_param_t) + voffset + p->vsize;\n\n\n } break;\n case EFFECT_CMD_SET_PARAM:{\n\n\n if (pCmdData == NULL || (cmdSize < (sizeof(effect_param_t) + sizeof(int32_t))) ||\n                    pReplyData == NULL ||  replySize == NULL || *replySize != sizeof(int32_t)) {\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_SET_PARAM: ERROR\");\n return -EINVAL;\n }\n\n effect_param_t *p = (effect_param_t *) pCmdData;\n\n if (p->psize != sizeof(int32_t)){\n                ALOGV(\"\\t4LVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_SET_PARAM: ERROR, psize is not sizeof(int32_t)\");\n return -EINVAL;\n }\n\n\n *(int *)pReplyData = android::Reverb_setParameter(pContext,\n (void *)p->data,\n                                                              p->data + p->psize);\n } break;\n\n case EFFECT_CMD_ENABLE:\n\n if (pReplyData == NULL || *replySize != sizeof(int)){\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_ENABLE: ERROR\");\n return -EINVAL;\n }\n if(pContext->bEnabled == LVM_TRUE){\n                 ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_ENABLE: ERROR-Effect is already enabled\");\n return -EINVAL;\n }\n *(int *)pReplyData = 0;\n            pContext->bEnabled = LVM_TRUE;\n /* Get the current settings */\n LvmStatus = LVREV_GetControlParameters(pContext->hInstance, &ActiveParams);\n            LVM_ERROR_CHECK(LvmStatus, \"LVREV_GetControlParameters\", \"EFFECT_CMD_ENABLE\")\n            pContext->SamplesToExitCount =\n (ActiveParams.T60 * pContext->config.inputCfg.samplingRate)/1000;\n            pContext->volumeMode = android::REVERB_VOLUME_FLAT;\n break;\n case EFFECT_CMD_DISABLE:\n\n if (pReplyData == NULL || *replySize != sizeof(int)){\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_DISABLE: ERROR\");\n return -EINVAL;\n }\n if(pContext->bEnabled == LVM_FALSE){\n                 ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_DISABLE: ERROR-Effect is not yet enabled\");\n return -EINVAL;\n }\n *(int *)pReplyData = 0;\n            pContext->bEnabled = LVM_FALSE;\n break;\n\n case EFFECT_CMD_SET_VOLUME:\n if (pCmdData == NULL ||\n                cmdSize != 2 * sizeof(uint32_t)) {\n                ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"EFFECT_CMD_SET_VOLUME: ERROR\");\n return -EINVAL;\n }\n\n\n if (pReplyData != NULL) { // we have volume control\n                pContext->leftVolume = (LVM_INT16)((*(uint32_t *)pCmdData + (1 << 11)) >> 12);\n                pContext->rightVolume = (LVM_INT16)((*((uint32_t *)pCmdData + 1) + (1 << 11)) >> 12);\n *(uint32_t *)pReplyData = (1 << 24);\n *((uint32_t *)pReplyData + 1) = (1 << 24);\n if (pContext->volumeMode == android::REVERB_VOLUME_OFF) {\n                    pContext->volumeMode = android::REVERB_VOLUME_FLAT;\n }\n } else { // we don't have volume control\n                pContext->leftVolume = REVERB_UNIT_VOLUME;\n                pContext->rightVolume = REVERB_UNIT_VOLUME;\n                pContext->volumeMode = android::REVERB_VOLUME_OFF;\n }\n            ALOGV(\"EFFECT_CMD_SET_VOLUME left %d, right %d mode %d\",\n                    pContext->leftVolume, pContext->rightVolume,  pContext->volumeMode);\n break;\n\n case EFFECT_CMD_SET_DEVICE:\n case EFFECT_CMD_SET_AUDIO_MODE:\n break;\n\n default:\n            ALOGV(\"\\tLVM_ERROR : Reverb_command cmdCode Case: \"\n \"DEFAULT start %d ERROR\",cmdCode);\n return -EINVAL;\n }\n\n return 0;\n} /* end Reverb_command */\n", "target": 1, "idx": 187957}
{"func": "void PrintPreviewMessageHandler::OnInvalidPrinterSettings(int document_cookie) {\n  StopWorker(document_cookie);\n  PrintPreviewUI* print_preview_ui = GetPrintPreviewUI();\n  if (!print_preview_ui)\n    return;\n  print_preview_ui->OnInvalidPrinterSettings();\n}\n", "target": 0, "idx": 137691}
{"func": "static ssize_t handle_readlink(FsContext *fs_ctx, V9fsPath *fs_path,\n                               char *buf, size_t bufsz)\n{\n    int fd, ret;\n    struct handle_data *data = (struct handle_data *)fs_ctx->private;\n\n    fd = open_by_handle(data->mountfd, fs_path->data, O_PATH);\n    if (fd < 0) {\n        return fd;\n    }\n    ret = readlinkat(fd, \"\", buf, bufsz);\n    close(fd);\n    return ret;\n}\n", "target": 0, "idx": 7688}
{"func": " static void shm_destroy(struct ipc_namespace *ns, struct shmid_kernel *shp)\n {\n \tns->shm_tot -= (shp->shm_segsz + PAGE_SIZE - 1) >> PAGE_SHIFT;\n \tshm_rmid(ns, shp);\n \tshm_unlock(shp);\n\tif (!is_file_hugepages(shp->shm_file))\n\t\tshmem_lock(shp->shm_file, 0, shp->mlock_user);\n \telse if (shp->mlock_user)\n\t\tuser_shm_unlock(file_inode(shp->shm_file)->i_size,\n\t\t\t\t\t\tshp->mlock_user);\n\tfput (shp->shm_file);\n \tipc_rcu_putref(shp, shm_rcu_free);\n }\n", "target": 1, "idx": 179084}
{"func": "__imlib_MergeUpdate(ImlibUpdate * u, int w, int h, int hgapmax)\n{\n   ImlibUpdate        *nu = NULL, *uu;\n   struct _tile       *t;\n   int                 tw, th, x, y, i;\n   int                *gaps = NULL;\n\n   /* if theres no rects to process.. return NULL */\n   if (!u)\n      return NULL;\n   tw = w >> TB;\n   if (w & TM)\n      tw++;\n   th = h >> TB;\n   if (h & TM)\n      th++;\n   t = malloc(tw * th * sizeof(struct _tile));\n   /* fill in tiles to be all not used */\n   for (i = 0, y = 0; y < th; y++)\n     {\n        for (x = 0; x < tw; x++)\n           t[i++].used = T_UNUSED;\n     }\n   /* fill in all tiles */\n   for (uu = u; uu; uu = uu->next)\n     {\n        CLIP(uu->x, uu->y, uu->w, uu->h, 0, 0, w, h);\n        for (y = uu->y >> TB; y <= ((uu->y + uu->h - 1) >> TB); y++)\n          {\n             for (x = uu->x >> TB; x <= ((uu->x + uu->w - 1) >> TB); x++)\n                T(x, y).used = T_USED;\n          }\n     }\n   /* scan each line - if > hgapmax gaps between tiles, then fill smallest */\n   gaps = malloc(tw * sizeof(int));\n   for (y = 0; y < th; y++)\n     {\n        int                 hgaps = 0, start = -1, min;\n        char                have = 1, gap = 0;\n\n        for (x = 0; x < tw; x++)\n           gaps[x] = 0;\n        for (x = 0; x < tw; x++)\n          {\n             if ((have) && (T(x, y).used == T_UNUSED))\n               {\n                  start = x;\n                  gap = 1;\n                  have = 0;\n               }\n             else if ((!have) && (gap) && (T(x, y).used & T_USED))\n               {\n                  gap = 0;\n                  hgaps++;\n                  have = 1;\n                  gaps[start] = x - start;\n               }\n             else if (T(x, y).used & T_USED)\n                have = 1;\n          }\n        while (hgaps > hgapmax)\n          {\n             start = -1;\n             min = tw;\n\n             for (x = 0; x < tw; x++)\n               {\n                  if ((gaps[x] > 0) && (gaps[x] < min))\n                    {\n                       start = x;\n                       min = gaps[x];\n                    }\n               }\n             if (start >= 0)\n               {\n                  gaps[start] = 0;\n                  for (x = start;\n                       T(x, y).used == T_UNUSED; T(x++, y).used = T_USED);\n                  hgaps--;\n               }\n          }\n     }\n   free(gaps);\n   /* coalesce tiles into larger blocks and make new rect list */\n   for (y = 0; y < th; y++)\n     {\n        for (x = 0; x < tw; x++)\n          {\n             if (T(x, y).used & T_USED)\n               {\n                   int                 xx, yy, ww, hh, ok, xww;\n \n                   for (xx = x + 1, ww = 1;\n                       (T(xx, y).used & T_USED) && (xx < tw); xx++, ww++);\n                   xww = x + ww;\n                   for (yy = y + 1, hh = 1, ok = 1;\n                        (yy < th) && (ok); yy++, hh++)\n                    {\n                       for (xx = x; xx < xww; xx++)\n                         {\n                            if (!(T(xx, yy).used & T_USED))\n                              {\n                                 ok = 0;\n                                 hh--;\n                                 break;\n                              }\n                         }\n                    }\n                  for (yy = y; yy < (y + hh); yy++)\n                    {\n                       for (xx = x; xx < xww; xx++)\n                          T(xx, yy).used = T_UNUSED;\n                    }\n                  nu = __imlib_AddUpdate(nu, (x << TB), (y << TB),\n                                         (ww << TB), (hh << TB));\n               }\n          }\n     }\n   free(t);\n   __imlib_FreeUpdates(u);\n   return nu;\n}\n", "target": 1, "idx": 178252}
{"func": "bool xmp_init()\n{\n     RESET_ERROR;\n     try {\n         bool result = SXMPFiles::Initialize(kXMPFiles_IgnoreLocalText);\n         SXMPMeta::SetDefaultErrorCallback(&_xmp_error_callback, nullptr, 1);\n         return result;\n        SXMPMeta::SetDefaultErrorCallback(&_xmp_error_callback, nullptr, 1);\n        return result;\n    }\n    catch (const XMP_Error &e) {\n        set_error(e);\n    }\n    return false;\n}\n", "target": 1, "idx": 178540}
{"func": " PP_Bool LaunchSelLdr(PP_Instance instance,\n                     const char* alleged_url,\n                     int socket_count,\n                      void* imc_handles) {\n   std::vector<nacl::FileDescriptor> sockets;\n   IPC::Sender* sender = content::RenderThread::Get();\n   if (sender == NULL)\n     sender = g_background_thread_sender.Pointer()->get();\n \n  IPC::ChannelHandle channel_handle;\n   if (!sender->Send(new ChromeViewHostMsg_LaunchNaCl(\n          GURL(alleged_url), socket_count, &sockets,\n          &channel_handle))) {\n     return PP_FALSE;\n  }\n  bool invalid_handle = channel_handle.name.empty();\n#if defined(OS_POSIX)\n  if (!invalid_handle)\n    invalid_handle = (channel_handle.socket.fd == -1);\n#endif\n  if (!invalid_handle)\n    g_channel_handle_map.Get()[instance] = channel_handle;\n \n   CHECK(static_cast<int>(sockets.size()) == socket_count);\n   for (int i = 0; i < socket_count; i++) {\n    static_cast<nacl::Handle*>(imc_handles)[i] =\n        nacl::ToNativeHandle(sockets[i]);\n  }\n\n   return PP_TRUE;\n }\n", "target": 1, "idx": 184310}
{"func": "static int ipgre_close(struct net_device *dev)\n{\n\tstruct ip_tunnel *t = netdev_priv(dev);\n\n\tif (ipv4_is_multicast(t->parms.iph.daddr) && t->mlink) {\n\t\tstruct in_device *in_dev;\n\t\tin_dev = inetdev_by_index(dev_net(dev), t->mlink);\n\t\tif (in_dev) {\n\t\t\tip_mc_dec_group(in_dev, t->parms.iph.daddr);\n\t\t\tin_dev_put(in_dev);\n\t\t}\n\t}\n\treturn 0;\n}\n", "target": 0, "idx": 27479}
{"func": "void svc_rdma_xdr_encode_reply_array(struct rpcrdma_write_array *ary,\n\t\t\t\t int chunks)\n{\n\tary->wc_discrim = xdr_one;\n\tary->wc_nchunks = cpu_to_be32(chunks);\n}\n", "target": 1, "idx": 181333}
{"func": "static inline int qeth_get_initial_mtu_for_card(struct qeth_card *card)\n{\n\tswitch (card->info.type) {\n\tcase QETH_CARD_TYPE_UNKNOWN:\n\t\treturn 1500;\n\tcase QETH_CARD_TYPE_IQD:\n\t\treturn card->info.max_mtu;\n\tcase QETH_CARD_TYPE_OSD:\n\t\tswitch (card->info.link_type) {\n\t\tcase QETH_LINK_TYPE_HSTR:\n\t\tcase QETH_LINK_TYPE_LANE_TR:\n\t\t\treturn 2000;\n\t\tdefault:\n\t\t\treturn card->options.layer2 ? 1500 : 1492;\n\t\t}\n\tcase QETH_CARD_TYPE_OSM:\n\tcase QETH_CARD_TYPE_OSX:\n\t\treturn card->options.layer2 ? 1500 : 1492;\n\tdefault:\n\t\treturn 1500;\n\t}\n}\n", "target": 0, "idx": 28561}
{"func": "void BluetoothDeviceChooserController::GetDevice(\n    blink::mojom::WebBluetoothRequestDeviceOptionsPtr options,\n    const SuccessCallback& success_callback,\n    const ErrorCallback& error_callback) {\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n\n  DCHECK(success_callback_.is_null());\n  DCHECK(error_callback_.is_null());\n\n  success_callback_ = success_callback;\n  error_callback_ = error_callback;\n  options_ = std::move(options);\n  LogRequestDeviceOptions(options_);\n\n  if (options_->filters &&\n       BluetoothBlocklist::Get().IsExcluded(options_->filters.value())) {\n     RecordRequestDeviceOutcome(\n         UMARequestDeviceOutcome::BLOCKLISTED_SERVICE_IN_FILTER);\n    PostErrorCallback(\n        blink::mojom::WebBluetoothResult::REQUEST_DEVICE_WITH_BLOCKLISTED_UUID);\n     return;\n   }\n   BluetoothBlocklist::Get().RemoveExcludedUUIDs(options_.get());\n \n  const url::Origin requesting_origin =\n      render_frame_host_->GetLastCommittedOrigin();\n  const url::Origin embedding_origin =\n      web_contents_->GetMainFrame()->GetLastCommittedOrigin();\n  if (!embedding_origin.IsSameOriginWith(requesting_origin)) {\n    PostErrorCallback(blink::mojom::WebBluetoothResult::\n                          REQUEST_DEVICE_FROM_CROSS_ORIGIN_IFRAME);\n     return;\n   }\n  DCHECK(!requesting_origin.opaque());\n \n   if (!adapter_->IsPresent()) {\n     DVLOG(1) << \"Bluetooth Adapter not present. Can't serve requestDevice.\";\n     RecordRequestDeviceOutcome(\n         UMARequestDeviceOutcome::BLUETOOTH_ADAPTER_NOT_PRESENT);\n    PostErrorCallback(blink::mojom::WebBluetoothResult::NO_BLUETOOTH_ADAPTER);\n     return;\n   }\n \n  switch (GetContentClient()->browser()->AllowWebBluetooth(\n      web_contents_->GetBrowserContext(), requesting_origin,\n      embedding_origin)) {\n    case ContentBrowserClient::AllowWebBluetoothResult::BLOCK_POLICY: {\n      RecordRequestDeviceOutcome(\n          UMARequestDeviceOutcome::BLUETOOTH_CHOOSER_POLICY_DISABLED);\n      PostErrorCallback(blink::mojom::WebBluetoothResult::\n                            CHOOSER_NOT_SHOWN_API_LOCALLY_DISABLED);\n      return;\n    }\n    case ContentBrowserClient::AllowWebBluetoothResult::\n        BLOCK_GLOBALLY_DISABLED: {\n      web_contents_->GetMainFrame()->AddMessageToConsole(\n          blink::mojom::ConsoleMessageLevel::kInfo,\n          \"Bluetooth permission has been blocked.\");\n      RecordRequestDeviceOutcome(\n          UMARequestDeviceOutcome::BLUETOOTH_GLOBALLY_DISABLED);\n      PostErrorCallback(blink::mojom::WebBluetoothResult::\n                            CHOOSER_NOT_SHOWN_API_GLOBALLY_DISABLED);\n      return;\n    }\n    case ContentBrowserClient::AllowWebBluetoothResult::ALLOW:\n      break;\n  }\n   BluetoothChooser::EventHandler chooser_event_handler =\n       base::Bind(&BluetoothDeviceChooserController::OnBluetoothChooserEvent,\n                  base::Unretained(this));\n\n  if (WebContentsDelegate* delegate = web_contents_->GetDelegate()) {\n    chooser_ = delegate->RunBluetoothChooser(render_frame_host_,\n                                             std::move(chooser_event_handler));\n   }\n \n   if (!chooser_.get()) {\n    PostErrorCallback(\n        blink::mojom::WebBluetoothResult::WEB_BLUETOOTH_NOT_SUPPORTED);\n     return;\n   }\n \n  if (!chooser_->CanAskForScanningPermission()) {\n    DVLOG(1) << \"Closing immediately because Chooser cannot obtain permission.\";\n    OnBluetoothChooserEvent(BluetoothChooser::Event::DENIED_PERMISSION,\n                            \"\" /* device_address */);\n    return;\n  }\n\n  device_ids_.clear();\n  PopulateConnectedDevices();\n  if (!chooser_.get()) {\n    return;\n  }\n\n  if (!adapter_->IsPowered()) {\n    chooser_->SetAdapterPresence(\n        BluetoothChooser::AdapterPresence::POWERED_OFF);\n    return;\n  }\n\n  StartDeviceDiscovery();\n}\n", "target": 1, "idx": 186411}
{"func": "my_object_dict_of_dicts (MyObject *obj, GHashTable *in,\n                                GHashTable **out, GError **error)\n{\n  *out = g_hash_table_new_full (g_str_hash, g_str_equal,\n\t\t\t\t(GDestroyNotify) g_free,\n                                (GDestroyNotify) g_hash_table_destroy);\n  g_hash_table_foreach (in, hash_foreach_mangle_dict_of_strings, *out);\n  return TRUE;\n}\n", "target": 1, "idx": 178263}
{"func": "static int l2tp_ip6_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t    int *uaddr_len, int peer)\n{\n\tstruct sockaddr_l2tpip6 *lsa = (struct sockaddr_l2tpip6 *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct l2tp_ip6_sock *lsk = l2tp_ip6_sk(sk);\n\n \tlsa->l2tp_family = AF_INET6;\n \tlsa->l2tp_flowinfo = 0;\n \tlsa->l2tp_scope_id = 0;\n \tif (peer) {\n \t\tif (!lsk->peer_conn_id)\n \t\t\treturn -ENOTCONN;\n\t\tlsa->l2tp_conn_id = lsk->peer_conn_id;\n\t\tlsa->l2tp_addr = np->daddr;\n\t\tif (np->sndflow)\n\t\t\tlsa->l2tp_flowinfo = np->flow_label;\n\t} else {\n\t\tif (ipv6_addr_any(&np->rcv_saddr))\n\t\t\tlsa->l2tp_addr = np->saddr;\n\t\telse\n\t\t\tlsa->l2tp_addr = np->rcv_saddr;\n\n\t\tlsa->l2tp_conn_id = lsk->conn_id;\n\t}\n\tif (ipv6_addr_type(&lsa->l2tp_addr) & IPV6_ADDR_LINKLOCAL)\n\t\tlsa->l2tp_scope_id = sk->sk_bound_dev_if;\n\t*uaddr_len = sizeof(*lsa);\n\treturn 0;\n}\n", "target": 1, "idx": 179355}
{"func": "static ssize_t f_hidg_write(struct file *file, const char __user *buffer,\n\t\t\t    size_t count, loff_t *offp)\n{\n\tstruct f_hidg *hidg  = file->private_data;\n\tstruct usb_request *req;\n\tunsigned long flags;\n\tssize_t status = -ENOMEM;\n\n\tif (!access_ok(buffer, count))\n\t\treturn -EFAULT;\n\n\tspin_lock_irqsave(&hidg->write_spinlock, flags);\n\n#define WRITE_COND (!hidg->write_pending)\ntry_again:\n\t/* write queue */\n\twhile (!WRITE_COND) {\n\t\tspin_unlock_irqrestore(&hidg->write_spinlock, flags);\n\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\n\t\tif (wait_event_interruptible_exclusive(\n\t\t\t\thidg->write_queue, WRITE_COND))\n\t\t\treturn -ERESTARTSYS;\n\n\t\tspin_lock_irqsave(&hidg->write_spinlock, flags);\n\t}\n\n\thidg->write_pending = 1;\n\treq = hidg->req;\n\tcount  = min_t(unsigned, count, hidg->report_length);\n\n\tspin_unlock_irqrestore(&hidg->write_spinlock, flags);\n\tstatus = copy_from_user(req->buf, buffer, count);\n\n\tif (status != 0) {\n\t\tERROR(hidg->func.config->cdev,\n\t\t\t\"copy_from_user error\\n\");\n\t\tstatus = -EINVAL;\n\t\tgoto release_write_pending;\n\t}\n\n\tspin_lock_irqsave(&hidg->write_spinlock, flags);\n\n\t/* when our function has been disabled by host */\n\tif (!hidg->req) {\n\t\tfree_ep_req(hidg->in_ep, req);\n\t\t/*\n\t\t * TODO\n\t\t * Should we fail with error here?\n\t\t */\n\t\tgoto try_again;\n\t}\n\n\treq->status   = 0;\n\treq->zero     = 0;\n\treq->length   = count;\n \treq->complete = f_hidg_req_complete;\n \treq->context  = hidg;\n \n \tstatus = usb_ep_queue(hidg->in_ep, req, GFP_ATOMIC);\n \tif (status < 0) {\n \t\tERROR(hidg->func.config->cdev,\n \t\t\t\"usb_ep_queue error on int endpoint %zd\\n\", status);\n\t\tgoto release_write_pending_unlocked;\n \t} else {\n \t\tstatus = count;\n \t}\n\tspin_unlock_irqrestore(&hidg->write_spinlock, flags);\n \n \treturn status;\n release_write_pending:\n \tspin_lock_irqsave(&hidg->write_spinlock, flags);\nrelease_write_pending_unlocked:\n \thidg->write_pending = 0;\n \tspin_unlock_irqrestore(&hidg->write_spinlock, flags);\n \n\twake_up(&hidg->write_queue);\n\n\treturn status;\n}\n", "target": 1, "idx": 183363}
{"func": "static inline int object_common2(UNSERIALIZE_PARAMETER, long elements)\n{\n\tzval *retval_ptr = NULL;\n\tzval fname;\n\n\tif (Z_TYPE_PP(rval) != IS_OBJECT) {\n\t\treturn 0;\n\t}\n\n\tif (!process_nested_data(UNSERIALIZE_PASSTHRU, Z_OBJPROP_PP(rval), elements, 1)) {\n\t    /* We've got partially constructed object on our hands here. Wipe it. */\n\t    if(Z_TYPE_PP(rval) == IS_OBJECT) {\n\t       zend_hash_clean(Z_OBJPROP_PP(rval));\n\t       zend_object_store_ctor_failed(*rval TSRMLS_CC);\n\t    }\n\t    ZVAL_NULL(*rval);\n\t\treturn 0;\n\t}\n\n    if (Z_TYPE_PP(rval) != IS_OBJECT) {\n        return 0;\n    }\n\n\tif (Z_OBJCE_PP(rval) != PHP_IC_ENTRY &&\n\t\tzend_hash_exists(&Z_OBJCE_PP(rval)->function_table, \"__wakeup\", sizeof(\"__wakeup\"))) {\n\t\tINIT_PZVAL(&fname);\n\t\tZVAL_STRINGL(&fname, \"__wakeup\", sizeof(\"__wakeup\") - 1, 0);\n\t\tBG(serialize_lock)++;\n\t\tcall_user_function_ex(CG(function_table), rval, &fname, &retval_ptr, 0, 0, 1, NULL TSRMLS_CC);\n\t\tBG(serialize_lock)--;\n\t}\n\n\tif (retval_ptr) {\n\t\tzval_ptr_dtor(&retval_ptr);\n\t}\n\n\tif (EG(exception)) {\n\t\treturn 0;\n\t}\n\n\treturn finish_nested_data(UNSERIALIZE_PASSTHRU);\n\n}\n", "target": 0, "idx": 71130}
{"func": "gx_dc_colored_masked_get_dev_halftone(const gx_device_color * pdevc)\n{\n    return pdevc->colors.colored.c_ht;\n}\n", "target": 0, "idx": 1668}
{"func": "  views::ImageButton* close_button() const {\n    return media_controls_view_->close_button_;\n  }\n", "target": 1, "idx": 186311}
{"func": " static grub_err_t read_foo (struct grub_disk *disk, grub_disk_addr_t sector, grub_size_t size, char *buf) {\n\tif (disk != NULL) {\n\t\tconst int blocksize = 512; // unhardcode 512\n\t\tint ret;\n\t\tRIOBind *iob = disk->data;\n\t\tif (bio) iob = bio;\n\t\tret = iob->read_at (iob->io, delta+(blocksize*sector),\n\t\t\t(ut8*)buf, size*blocksize);\n\t\tif (ret == -1)\n\t\t\treturn 1;\n\t} else eprintf (\"oops. no disk\\n\");\n\treturn 0; // 0 is ok\n }\n", "target": 1, "idx": 181263}
{"func": "static int nfs_idmap_read_and_verify_message(struct idmap_msg *im,\n\t\tstruct idmap_msg *upcall,\n\t\tstruct key *key, struct key *authkey)\n{\n\tchar id_str[NFS_UINT_MAXLEN];\n\tsize_t len;\n\tint ret = -ENOKEY;\n\n\t/* ret = -ENOKEY */\n\tif (upcall->im_type != im->im_type || upcall->im_conv != im->im_conv)\n\t\tgoto out;\n\tswitch (im->im_conv) {\n\tcase IDMAP_CONV_NAMETOID:\n\t\tif (strcmp(upcall->im_name, im->im_name) != 0)\n\t\t\tbreak;\n\t\t/* Note: here we store the NUL terminator too */\n\t\tlen = sprintf(id_str, \"%d\", im->im_id) + 1;\n\t\tret = nfs_idmap_instantiate(key, authkey, id_str, len);\n\t\tbreak;\n\tcase IDMAP_CONV_IDTONAME:\n\t\tif (upcall->im_id != im->im_id)\n\t\t\tbreak;\n\t\tlen = strlen(im->im_name);\n\t\tret = nfs_idmap_instantiate(key, authkey, im->im_name, len);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\nout:\n\treturn ret;\n}\n", "target": 0, "idx": 69469}
{"func": "ScreenLockLibrary* CrosLibrary::GetScreenLockLibrary() {\n  return screen_lock_lib_.GetDefaultImpl(use_stub_impl_);\n}\n", "target": 1, "idx": 184097}
{"func": "bool BrowserCommandController::IsCommandEnabled(int id) const {\n  return command_updater_.IsCommandEnabled(id);\n}\n", "target": 0, "idx": 166542}
{"func": "static int is_hugetlb_entry_hwpoisoned(pte_t pte)\n{\n\tswp_entry_t swp;\n\n\tif (huge_pte_none(pte) || pte_present(pte))\n\t\treturn 0;\n\tswp = pte_to_swp_entry(pte);\n\tif (non_swap_entry(swp) && is_hwpoison_entry(swp))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n", "target": 0, "idx": 19726}
{"func": " long Cluster::HasBlockEntries(\n     const Segment* pSegment,\n    long long off,  //relative to start of segment payload\n    long long& pos,\n    long& len)\n{\n    assert(pSegment);\n    assert(off >= 0);  //relative to segment\n \n    IMkvReader* const pReader = pSegment->m_pReader;\n \n    long long total, avail;\n \n    long status = pReader->Length(&total, &avail);\n \n    if (status < 0)  //error\n        return status;\n \n    assert((total < 0) || (avail <= total));\n \n    pos = pSegment->m_start + off;  //absolute\n \n    if ((total >= 0) && (pos >= total))\n        return 0;  //we don't even have a complete cluster\n \n    const long long segment_stop =\n        (pSegment->m_size < 0) ? -1 : pSegment->m_start + pSegment->m_size;\n \n    long long cluster_stop = -1;  //interpreted later to mean \"unknown size\"\n \n    {\n        if ((pos + 1) > avail)\n        {\n            len = 1;\n            return E_BUFFER_NOT_FULL;\n        }\n        long long result = GetUIntLength(pReader, pos, len);\n        if (result < 0)  //error\n            return static_cast<long>(result);\n        if (result > 0)  //need more data\n            return E_BUFFER_NOT_FULL;\n        if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n            return E_FILE_FORMAT_INVALID;\n        if ((total >= 0) && ((pos + len) > total))\n            return 0;\n        if ((pos + len) > avail)\n            return E_BUFFER_NOT_FULL;\n        const long long id = ReadUInt(pReader, pos, len);\n        if (id < 0)  //error\n            return static_cast<long>(id);\n        if (id != 0x0F43B675)  //weird: not cluster ID\n            return -1;         //generic error\n        pos += len;  //consume Cluster ID field\n        if ((pos + 1) > avail)\n        {\n            len = 1;\n            return E_BUFFER_NOT_FULL;\n        }\n        result = GetUIntLength(pReader, pos, len);\n        if (result < 0)  //error\n            return static_cast<long>(result);\n        if (result > 0)  //weird\n            return E_BUFFER_NOT_FULL;\n        if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n            return E_FILE_FORMAT_INVALID;\n        if ((total >= 0) && ((pos + len) > total))\n            return 0;\n        if ((pos + len) > avail)\n            return E_BUFFER_NOT_FULL;\n        const long long size = ReadUInt(pReader, pos, len);\n        if (size < 0)  //error\n            return static_cast<long>(size);\n        if (size == 0)\n            return 0;  //cluster does not have entries\n        pos += len;  //consume size field\n        const long long unknown_size = (1LL << (7 * len)) - 1;\n        if (size != unknown_size)\n        {\n            cluster_stop = pos + size;\n            assert(cluster_stop >= 0);\n            if ((segment_stop >= 0) && (cluster_stop > segment_stop))\n                return E_FILE_FORMAT_INVALID;\n            if ((total >= 0) && (cluster_stop > total))\n                return 0;  //cluster does not have any entries\n        }\n     }\n \n    for (;;)\n    {\n        if ((cluster_stop >= 0) && (pos >= cluster_stop))\n            return 0;  //no entries detected\n \n        if ((pos + 1) > avail)\n        {\n            len = 1;\n            return E_BUFFER_NOT_FULL;\n        }\n \n        long long result = GetUIntLength(pReader, pos, len);\n \n        if (result < 0)  //error\n            return static_cast<long>(result);\n \n        if (result > 0)  //need more data\n            return E_BUFFER_NOT_FULL;\n \n        if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))\n            return E_FILE_FORMAT_INVALID;\n \n        if ((pos + len) > avail)\n            return E_BUFFER_NOT_FULL;\n \n        const long long id = ReadUInt(pReader, pos, len);\n \n        if (id < 0)  //error\n            return static_cast<long>(id);\n \n \n        if (id == 0x0F43B675)  //Cluster ID\n            return 0;  //no entries found\n \n        if (id == 0x0C53BB6B)  //Cues ID\n            return 0;  //no entries found\n        pos += len;  //consume id field\n        if ((cluster_stop >= 0) && (pos >= cluster_stop))\n            return E_FILE_FORMAT_INVALID;\n        if ((pos + 1) > avail)\n        {\n            len = 1;\n            return E_BUFFER_NOT_FULL;\n        }\n        result = GetUIntLength(pReader, pos, len);\n        if (result < 0)  //error\n            return static_cast<long>(result);\n        if (result > 0)  //underflow\n            return E_BUFFER_NOT_FULL;\n        if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))\n            return E_FILE_FORMAT_INVALID;\n        if ((pos + len) > avail)\n            return E_BUFFER_NOT_FULL;\n        const long long size = ReadUInt(pReader, pos, len);\n        if (size < 0)  //error\n            return static_cast<long>(size);\n        pos += len;  //consume size field\n        if ((cluster_stop >= 0) && (pos > cluster_stop))\n            return E_FILE_FORMAT_INVALID;\n        if (size == 0)  //weird\n            continue;\n        const long long unknown_size = (1LL << (7 * len)) - 1;\n        if (size == unknown_size)\n            return E_FILE_FORMAT_INVALID;  //not supported inside cluster\n        if ((cluster_stop >= 0) && ((pos + size) > cluster_stop))\n            return E_FILE_FORMAT_INVALID;\n        if (id == 0x20)  //BlockGroup ID\n            return 1;    //have at least one entry\n        if (id == 0x23)  //SimpleBlock ID\n            return 1;    //have at least one entry\n        pos += size;  //consume payload\n        assert((cluster_stop < 0) || (pos <= cluster_stop));\n     }\n }\n", "target": 1, "idx": 188406}
{"func": "ossl_cipher_initialize(VALUE self, VALUE str)\n{\n     EVP_CIPHER_CTX *ctx;\n     const EVP_CIPHER *cipher;\n     char *name;\n    unsigned char dummy_key[EVP_MAX_KEY_LENGTH] = { 0 };\n \n     name = StringValueCStr(str);\n     GetCipherInit(self, ctx);\n    if (ctx) {\n\tossl_raise(rb_eRuntimeError, \"Cipher already inititalized!\");\n    }\n    AllocCipher(self, ctx);\n     if (!(cipher = EVP_get_cipherbyname(name))) {\n \tossl_raise(rb_eRuntimeError, \"unsupported cipher algorithm (%\"PRIsVALUE\")\", str);\n     }\n    /*\n     * EVP_CipherInit_ex() allows to specify NULL to key and IV, however some\n     * ciphers don't handle well (OpenSSL's bug). [Bug #2768]\n     *\n     * The EVP which has EVP_CIPH_RAND_KEY flag (such as DES3) allows\n     * uninitialized key, but other EVPs (such as AES) does not allow it.\n     * Calling EVP_CipherUpdate() without initializing key causes SEGV so we\n     * set the data filled with \"\\0\" as the key by default.\n     */\n    if (EVP_CipherInit_ex(ctx, cipher, NULL, dummy_key, NULL, -1) != 1)\n \tossl_raise(eCipherError, NULL);\n \n     return self;\n}\n", "target": 1, "idx": 181952}
{"func": "int WebContentsImpl::CreateOpenerRenderViewsForRenderManager(\n    SiteInstance* instance) {\n  if (!opener_)\n    return MSG_ROUTING_NONE;\n\n  return opener_->CreateOpenerRenderViews(instance);\n}\n", "target": 0, "idx": 118831}
{"func": " static int get_default_root(pool *p, int allow_symlinks, char **root) {\n   config_rec *c = NULL;\n   char *dir = NULL;\n  int res;\n\n  c = find_config(main_server->conf, CONF_PARAM, \"DefaultRoot\", FALSE);\n  while (c) {\n    pr_signals_handle();\n\n    /* Check the groups acl */\n    if (c->argc < 2) {\n      dir = c->argv[0];\n      break;\n    }\n\n    res = pr_expr_eval_group_and(((char **) c->argv)+1);\n    if (res) {\n      dir = c->argv[0];\n      break;\n    }\n\n    c = find_config_next(c, c->next, CONF_PARAM, \"DefaultRoot\", FALSE);\n  }\n\n  if (dir) {\n    char *new_dir;\n\n    /* Check for any expandable variables. */\n    new_dir = path_subst_uservar(p, &dir);\n    if (new_dir != NULL) {\n      dir = new_dir;\n    }\n\n    if (strncmp(dir, \"/\", 2) == 0) {\n      dir = NULL;\n\n    } else {\n      char *realdir;\n      int xerrno = 0;\n \n       if (allow_symlinks == FALSE) {\n         char *path, target_path[PR_TUNABLE_PATH_MAX + 1];\n        struct stat st;\n         size_t pathlen;\n \n         /* First, deal with any possible interpolation.  dir_realpath() will\n         * do this for us, but dir_realpath() ALSO automatically follows\n         * symlinks, which is what we do NOT want to do here.\n         */\n\n        path = dir;\n        if (*path != '/') {\n          if (*path == '~') {\n            if (pr_fs_interpolate(dir, target_path,\n                sizeof(target_path)-1) < 0) {\n              return -1;\n            }\n\n            path = target_path;\n          }\n        }\n\n        /* Note: lstat(2) is sensitive to the presence of a trailing slash on\n         * the path, particularly in the case of a symlink to a directory.\n         * Thus to get the correct test, we need to remove any trailing slash\n         * that might be present.  Subtle.\n         */\n        pathlen = strlen(path);\n        if (pathlen > 1 &&\n            path[pathlen-1] == '/') {\n           path[pathlen-1] = '\\0';\n         }\n \n        pr_fs_clear_cache();\n        res = pr_fsio_lstat(path, &st);\n         if (res < 0) {\n          xerrno = errno;\n          pr_log_pri(PR_LOG_WARNING, \"error: unable to check %s: %s\", path,\n            strerror(xerrno));\n          errno = xerrno;\n          return -1;\n        }\n \n        if (S_ISLNK(st.st_mode)) {\n          pr_log_pri(PR_LOG_WARNING,\n            \"error: DefaultRoot %s is a symlink (denied by AllowChrootSymlinks \"\n            \"config)\", path);\n           errno = EPERM;\n           return -1;\n         }\n      }\n\n      /* We need to be the final user here so that if the user has their home\n       * directory with a mode the user proftpd is running (i.e. the User\n       * directive) as can not traverse down, we can still have the default\n       * root.\n       */\n\n      PRIVS_USER\n      realdir = dir_realpath(p, dir);\n      xerrno = errno;\n      PRIVS_RELINQUISH\n\n      if (realdir) {\n        dir = realdir;\n\n      } else {\n        /* Try to provide a more informative message. */\n        char interp_dir[PR_TUNABLE_PATH_MAX + 1];\n\n        memset(interp_dir, '\\0', sizeof(interp_dir));\n        (void) pr_fs_interpolate(dir, interp_dir, sizeof(interp_dir)-1); \n\n        pr_log_pri(PR_LOG_NOTICE,\n          \"notice: unable to use DefaultRoot '%s' [resolved to '%s']: %s\",\n          dir, interp_dir, strerror(xerrno));\n\n        errno = xerrno;\n      }\n    }\n  }\n\n  *root = dir;\n  return 0;\n}\n", "target": 1, "idx": 183242}
{"func": "getnetnum(\n\tconst char *num,\n\tsockaddr_u *addr,\n\tint complain,\n\tenum gnn_type a_type\t/* ignored */\n\t)\n{\n\tNTP_REQUIRE(AF_UNSPEC == AF(addr) ||\n\t\t    AF_INET == AF(addr) ||\n\t\t    AF_INET6 == AF(addr));\n\n\tif (!is_ip_address(num, AF(addr), addr))\n\t\treturn 0;\n\n\tif (IS_IPV6(addr) && !ipv6_works)\n\t\treturn -1;\n\n# ifdef ISC_PLATFORM_HAVESALEN\n\taddr->sa.sa_len = SIZEOF_SOCKADDR(AF(addr));\n# endif\n\tSET_PORT(addr, NTP_PORT);\n\n\tDPRINTF(2, (\"getnetnum given %s, got %s\\n\", num, stoa(addr)));\n\n\treturn 1;\n}\n", "target": 0, "idx": 74206}
{"func": "static Image *ReadSCREENSHOTImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=(Image *) NULL;\n#if defined(MAGICKCORE_WINGDI32_DELEGATE)\n  {\n    BITMAPINFO\n      bmi;\n\n    DISPLAY_DEVICE\n      device;\n\n    HBITMAP\n      bitmap,\n      bitmapOld;\n\n    HDC\n      bitmapDC,\n      hDC;\n\n    Image\n      *screen;\n\n     int\n       i;\n \n     register PixelPacket\n       *q;\n \n    register ssize_t\n      x;\n\n    RGBTRIPLE\n      *p;\n\n    ssize_t\n      y;\n\n    assert(image_info != (const ImageInfo *) NULL);\n    i=0;\n    device.cb = sizeof(device);\n    image=(Image *) NULL;\n    while(EnumDisplayDevices(NULL,i,&device,0) && ++i)\n    {\n      if ((device.StateFlags & DISPLAY_DEVICE_ACTIVE) != DISPLAY_DEVICE_ACTIVE)\n        continue;\n\n      hDC=CreateDC(device.DeviceName,device.DeviceName,NULL,NULL);\n      if (hDC == (HDC) NULL)\n        ThrowReaderException(CoderError,\"UnableToCreateDC\");\n\n      screen=AcquireImage(image_info);\n       screen->columns=(size_t) GetDeviceCaps(hDC,HORZRES);\n       screen->rows=(size_t) GetDeviceCaps(hDC,VERTRES);\n       screen->storage_class=DirectClass;\n       if (image == (Image *) NULL)\n         image=screen;\n       else\n        AppendImageToList(&image,screen);\n\n      bitmapDC=CreateCompatibleDC(hDC);\n      if (bitmapDC == (HDC) NULL)\n        {\n          DeleteDC(hDC);\n          ThrowReaderException(CoderError,\"UnableToCreateDC\");\n        }\n      (void) ResetMagickMemory(&bmi,0,sizeof(BITMAPINFO));\n      bmi.bmiHeader.biSize=sizeof(BITMAPINFOHEADER);\n      bmi.bmiHeader.biWidth=(LONG) screen->columns;\n      bmi.bmiHeader.biHeight=(-1)*(LONG) screen->rows;\n      bmi.bmiHeader.biPlanes=1;\n      bmi.bmiHeader.biBitCount=24;\n      bmi.bmiHeader.biCompression=BI_RGB;\n      bitmap=CreateDIBSection(hDC,&bmi,DIB_RGB_COLORS,(void **) &p,NULL,0);\n      if (bitmap == (HBITMAP) NULL)\n        {\n          DeleteDC(hDC);\n          DeleteDC(bitmapDC);\n          ThrowReaderException(CoderError,\"UnableToCreateBitmap\");\n        }\n      bitmapOld=(HBITMAP) SelectObject(bitmapDC,bitmap);\n      if (bitmapOld == (HBITMAP) NULL)\n        {\n          DeleteDC(hDC);\n          DeleteDC(bitmapDC);\n          DeleteObject(bitmap);\n          ThrowReaderException(CoderError,\"UnableToCreateBitmap\");\n        }\n      BitBlt(bitmapDC,0,0,(int) screen->columns,(int) screen->rows,hDC,0,0,\n        SRCCOPY);\n      (void) SelectObject(bitmapDC,bitmapOld);\n\n      for (y=0; y < (ssize_t) screen->rows; y++)\n      {\n        q=QueueAuthenticPixels(screen,0,y,screen->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n          break;\n        for (x=0; x < (ssize_t) screen->columns; x++)\n        {\n          SetPixelRed(q,ScaleCharToQuantum(p->rgbtRed));\n          SetPixelGreen(q,ScaleCharToQuantum(p->rgbtGreen));\n          SetPixelBlue(q,ScaleCharToQuantum(p->rgbtBlue));\n          SetPixelOpacity(q,OpaqueOpacity);\n          p++;\n          q++;\n        }\n        if (SyncAuthenticPixels(screen,exception) == MagickFalse)\n          break;\n      }\n\n      DeleteDC(hDC);\n      DeleteDC(bitmapDC);\n      DeleteObject(bitmap);\n    }\n  }\n#elif defined(MAGICKCORE_X11_DELEGATE)\n  {\n    const char\n      *option;\n\n    XImportInfo\n      ximage_info;\n\n    (void) exception;\n    XGetImportInfo(&ximage_info);\n    option=GetImageOption(image_info,\"x:screen\");\n    if (option != (const char *) NULL)\n      ximage_info.screen=IsMagickTrue(option);\n    option=GetImageOption(image_info,\"x:silent\");\n    if (option != (const char *) NULL)\n      ximage_info.silent=IsMagickTrue(option);\n    image=XImportImage(image_info,&ximage_info);\n  }\n#endif\n  return(image);\n}\n", "target": 1, "idx": 181774}
{"func": "void HTMLFormControlElement::AssociateWith(HTMLFormElement* form) {\n  AssociateByParser(form);\n}\n", "target": 0, "idx": 149217}
{"func": "static int mov_read_ares(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    if (c->fc->nb_streams >= 1) {\n        AVCodecParameters *par = c->fc->streams[c->fc->nb_streams-1]->codecpar;\n        if (par->codec_tag == MKTAG('A', 'V', 'i', 'n') &&\n            par->codec_id == AV_CODEC_ID_H264 &&\n            atom.size > 11) {\n            int cid;\n            avio_skip(pb, 10);\n            cid = avio_rb16(pb);\n            /* For AVID AVCI50, force width of 1440 to be able to select the correct SPS and PPS */\n            if (cid == 0xd4d || cid == 0xd4e)\n                par->width = 1440;\n            return 0;\n        } else if ((par->codec_tag == MKTAG('A', 'V', 'd', '1') ||\n                    par->codec_tag == MKTAG('A', 'V', 'd', 'n')) &&\n                   atom.size >= 24) {\n            int num, den;\n            avio_skip(pb, 12);\n            num = avio_rb32(pb);\n            den = avio_rb32(pb);\n            if (num <= 0 || den <= 0)\n                return 0;\n            switch (avio_rb32(pb)) {\n            case 2:\n                if (den >= INT_MAX / 2)\n                    return 0;\n                den *= 2;\n            case 1:\n                c->fc->streams[c->fc->nb_streams-1]->display_aspect_ratio.num = num;\n                c->fc->streams[c->fc->nb_streams-1]->display_aspect_ratio.den = den;\n            default:\n                return 0;\n            }\n        }\n    }\n\n    return mov_read_avid(c, pb, atom);\n}\n", "target": 0, "idx": 61408}
{"func": "WebInputEvent* CreateWebInputEvent(const PP_InputEvent& event) {\n  scoped_ptr<WebInputEvent> web_input_event;\n  switch (event.type) {\n    case PP_INPUTEVENT_TYPE_UNDEFINED:\n      return NULL;\n    case PP_INPUTEVENT_TYPE_MOUSEDOWN:\n    case PP_INPUTEVENT_TYPE_MOUSEUP:\n     case PP_INPUTEVENT_TYPE_MOUSEMOVE:\n     case PP_INPUTEVENT_TYPE_MOUSEENTER:\n     case PP_INPUTEVENT_TYPE_MOUSELEAVE:\n       web_input_event.reset(BuildMouseEvent(event));\n       break;\n     case PP_INPUTEVENT_TYPE_MOUSEWHEEL:\n      web_input_event.reset(BuildMouseWheelEvent(event));\n      break;\n    case PP_INPUTEVENT_TYPE_RAWKEYDOWN:\n    case PP_INPUTEVENT_TYPE_KEYDOWN:\n    case PP_INPUTEVENT_TYPE_KEYUP:\n      web_input_event.reset(BuildKeyEvent(event));\n      break;\n    case PP_INPUTEVENT_TYPE_CHAR:\n      web_input_event.reset(BuildCharEvent(event));\n      break;\n  }\n \n   return web_input_event.release();\n }\n", "target": 1, "idx": 184077}
{"func": "process(struct magic_set *ms, const char *inname, int wid)\n{\n\tconst char *type;\n\tint std_in = strcmp(inname, \"-\") == 0;\n\n\tif (wid > 0 && !bflag) {\n\t\t(void)printf(\"%s\", std_in ? \"/dev/stdin\" : inname);\n\t\tif (nulsep)\n\t\t\t(void)putc('\\0', stdout);\n\t\t(void)printf(\"%s\", separator);\n\t\t(void)printf(\"%*s \",\n\t\t    (int) (nopad ? 0 : (wid - file_mbswidth(inname))), \"\");\n\t}\n\n\ttype = magic_file(ms, std_in ? NULL : inname);\n\tif (type == NULL) {\n\t\t(void)printf(\"ERROR: %s\\n\", magic_error(ms));\n\t\treturn 1;\n\t} else {\n\t\t(void)printf(\"%s\\n\", type);\n\t\treturn 0;\n\t}\n}\n", "target": 0, "idx": 45965}
{"func": "ext4_xattr_create_cache(char *name)\n {\n\treturn mb_cache_create(name, HASH_BUCKET_BITS);\n }\n", "target": 1, "idx": 183165}
{"func": "static inline void invalidate_cursor1(CirrusVGAState *s)\n{\n    if (s->last_hw_cursor_size) {\n        vga_invalidate_scanlines(&s->vga,\n                                 s->last_hw_cursor_y + s->last_hw_cursor_y_start,\n                                 s->last_hw_cursor_y + s->last_hw_cursor_y_end);\n    }\n}\n", "target": 0, "idx": 7615}
{"func": "void Preferences::NotifyPrefChanged(const std::wstring* pref_name) {\n  if (!pref_name || *pref_name == prefs::kTapToClickEnabled) {\n    CrosLibrary::Get()->GetSynapticsLibrary()->SetBoolParameter(\n        PARAM_BOOL_TAP_TO_CLICK,\n        tap_to_click_enabled_.GetValue());\n  }\n  if (!pref_name || *pref_name == prefs::kVertEdgeScrollEnabled) {\n    CrosLibrary::Get()->GetSynapticsLibrary()->SetBoolParameter(\n        PARAM_BOOL_VERTICAL_EDGE_SCROLLING,\n        vert_edge_scroll_enabled_.GetValue());\n  }\n  if (!pref_name || *pref_name == prefs::kTouchpadSpeedFactor) {\n    CrosLibrary::Get()->GetSynapticsLibrary()->SetRangeParameter(\n        PARAM_RANGE_SPEED_SENSITIVITY,\n        speed_factor_.GetValue());\n  }\n  if (!pref_name || *pref_name == prefs::kTouchpadSensitivity) {\n    CrosLibrary::Get()->GetSynapticsLibrary()->SetRangeParameter(\n          PARAM_RANGE_TOUCH_SENSITIVITY,\n          sensitivity_.GetValue());\n  }\n\n\n  if (!pref_name || *pref_name == prefs::kLanguageHotkeyNextEngineInMenu) {\n    SetLanguageConfigStringListAsCSV(\n        kHotKeySectionName,\n        kNextEngineInMenuConfigName,\n        language_hotkey_next_engine_in_menu_.GetValue());\n  }\n  if (!pref_name || *pref_name == prefs::kLanguageHotkeyPreviousEngine) {\n    SetLanguageConfigStringListAsCSV(\n        kHotKeySectionName,\n        kPreviousEngineConfigName,\n        language_hotkey_previous_engine_.GetValue());\n  }\n  if (!pref_name || *pref_name == prefs::kLanguagePreloadEngines) {\n    SetLanguageConfigStringListAsCSV(kGeneralSectionName,\n                                     kPreloadEnginesConfigName,\n                                     language_preload_engines_.GetValue());\n  }\n  for (size_t i = 0; i < kNumChewingBooleanPrefs; ++i) {\n    if (!pref_name || *pref_name == kChewingBooleanPrefs[i].pref_name) {\n      SetLanguageConfigBoolean(kChewingSectionName,\n                               kChewingBooleanPrefs[i].ibus_config_name,\n                               language_chewing_boolean_prefs_[i].GetValue());\n    }\n  }\n  for (size_t i = 0; i < kNumChewingMultipleChoicePrefs; ++i) {\n    if (!pref_name || *pref_name == kChewingMultipleChoicePrefs[i].pref_name) {\n      SetLanguageConfigString(\n          kChewingSectionName,\n          kChewingMultipleChoicePrefs[i].ibus_config_name,\n          language_chewing_multiple_choice_prefs_[i].GetValue());\n    }\n  }\n  if (!pref_name || *pref_name == kChewingHsuSelKeyType.pref_name) {\n    SetLanguageConfigInteger(\n        kChewingSectionName,\n        kChewingHsuSelKeyType.ibus_config_name,\n        language_chewing_hsu_sel_key_type_.GetValue());\n  }\n  for (size_t i = 0; i < kNumChewingIntegerPrefs; ++i) {\n    if (!pref_name || *pref_name == kChewingIntegerPrefs[i].pref_name) {\n      SetLanguageConfigInteger(kChewingSectionName,\n                               kChewingIntegerPrefs[i].ibus_config_name,\n                               language_chewing_integer_prefs_[i].GetValue());\n    }\n  }\n  if (!pref_name || *pref_name == prefs::kLanguageHangulKeyboard) {\n     SetLanguageConfigString(kHangulSectionName, kHangulKeyboardConfigName,\n                             language_hangul_keyboard_.GetValue());\n   }\n   for (size_t i = 0; i < kNumPinyinBooleanPrefs; ++i) {\n     if (!pref_name || *pref_name == kPinyinBooleanPrefs[i].pref_name) {\n       SetLanguageConfigBoolean(kPinyinSectionName,\n                               kPinyinBooleanPrefs[i].ibus_config_name,\n                               language_pinyin_boolean_prefs_[i].GetValue());\n    }\n  }\n  for (size_t i = 0; i < kNumPinyinIntegerPrefs; ++i) {\n    if (!pref_name || *pref_name == kPinyinIntegerPrefs[i].pref_name) {\n      SetLanguageConfigInteger(kPinyinSectionName,\n                               kPinyinIntegerPrefs[i].ibus_config_name,\n                               language_pinyin_int_prefs_[i].GetValue());\n    }\n  }\n  if (!pref_name || *pref_name == kPinyinDoublePinyinSchema.pref_name) {\n    SetLanguageConfigInteger(\n        kPinyinSectionName,\n        kPinyinDoublePinyinSchema.ibus_config_name,\n        language_pinyin_double_pinyin_schema_.GetValue());\n  }\n  for (size_t i = 0; i < kNumMozcBooleanPrefs; ++i) {\n    if (!pref_name || *pref_name == kMozcBooleanPrefs[i].pref_name) {\n      SetLanguageConfigBoolean(kMozcSectionName,\n                               kMozcBooleanPrefs[i].ibus_config_name,\n                               language_mozc_boolean_prefs_[i].GetValue());\n    }\n  }\n  for (size_t i = 0; i < kNumMozcMultipleChoicePrefs; ++i) {\n    if (!pref_name || *pref_name == kMozcMultipleChoicePrefs[i].pref_name) {\n      SetLanguageConfigString(\n          kMozcSectionName,\n          kMozcMultipleChoicePrefs[i].ibus_config_name,\n          language_mozc_multiple_choice_prefs_[i].GetValue());\n    }\n  }\n  for (size_t i = 0; i < kNumMozcIntegerPrefs; ++i) {\n    if (!pref_name || *pref_name == kMozcIntegerPrefs[i].pref_name) {\n      SetLanguageConfigInteger(kMozcSectionName,\n                               kMozcIntegerPrefs[i].ibus_config_name,\n                               language_mozc_integer_prefs_[i].GetValue());\n    }\n  }\n}\n", "target": 1, "idx": 183451}
{"func": "static inline int pipelined_send(struct msg_queue *msq, struct msg_msg *msg)\n{\n\tstruct msg_receiver *msr, *t;\n\n\tlist_for_each_entry_safe(msr, t, &msq->q_receivers, r_list) {\n\t\tif (testmsg(msg, msr->r_msgtype, msr->r_mode) &&\n\t\t    !security_msg_queue_msgrcv(msq, msg, msr->r_tsk,\n\t\t\t\t\t       msr->r_msgtype, msr->r_mode)) {\n\n\t\t\tlist_del(&msr->r_list);\n\t\t\tif (msr->r_maxsize < msg->m_ts) {\n\t\t\t\t/* initialize pipelined send ordering */\n\t\t\t\tmsr->r_msg = NULL;\n\t\t\t\twake_up_process(msr->r_tsk);\n\t\t\t\t/* barrier (B) see barrier comment below */\n\t\t\t\tsmp_wmb();\n\t\t\t\tmsr->r_msg = ERR_PTR(-E2BIG);\n\t\t\t} else {\n\t\t\t\tmsr->r_msg = NULL;\n\t\t\t\tmsq->q_lrpid = task_pid_vnr(msr->r_tsk);\n\t\t\t\tmsq->q_rtime = get_seconds();\n\t\t\t\twake_up_process(msr->r_tsk);\n\t\t\t\t/*\n\t\t\t\t * Ensure that the wakeup is visible before\n\t\t\t\t * setting r_msg, as the receiving can otherwise\n\t\t\t\t * exit - once r_msg is set, the receiver can\n\t\t\t\t * continue. See lockless receive part 1 and 2\n\t\t\t\t * in do_msgrcv(). Barrier (B).\n\t\t\t\t */\n\t\t\t\tsmp_wmb();\n\t\t\t\tmsr->r_msg = msg;\n\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n", "target": 0, "idx": 42007}
{"func": "int udhcpc_main(int argc UNUSED_PARAM, char **argv)\n{\n\tuint8_t *message;\n\tconst char *str_V, *str_h, *str_F, *str_r;\n\tIF_FEATURE_UDHCPC_ARPING(const char *str_a = \"2000\";)\n\tIF_FEATURE_UDHCP_PORT(char *str_P;)\n\tvoid *clientid_mac_ptr;\n\tllist_t *list_O = NULL;\n\tllist_t *list_x = NULL;\n\tint tryagain_timeout = 20;\n\tint discover_timeout = 3;\n\tint discover_retries = 3;\n\tuint32_t server_addr = server_addr; /* for compiler */\n\tuint32_t requested_ip = 0;\n\tuint32_t xid = xid; /* for compiler */\n\tint packet_num;\n\tint timeout; /* must be signed */\n\tunsigned already_waited_sec;\n\tunsigned opt;\n\tIF_FEATURE_UDHCPC_ARPING(unsigned arpping_ms;)\n\tint retval;\n\n\tsetup_common_bufsiz();\n\n\t/* Default options */\n\tIF_FEATURE_UDHCP_PORT(SERVER_PORT = 67;)\n\tIF_FEATURE_UDHCP_PORT(CLIENT_PORT = 68;)\n\tclient_config.interface = \"eth0\";\n\tclient_config.script = CONFIG_UDHCPC_DEFAULT_SCRIPT;\n\tstr_V = \"udhcp \"BB_VER;\n\n\t/* Parse command line */\n\topt = getopt32long(argv, \"^\"\n\t\t/* O,x: list; -T,-t,-A take numeric param */\n\t\t\"CV:H:h:F:i:np:qRr:s:T:+t:+SA:+O:*ox:*fB\"\n\t\tUSE_FOR_MMU(\"b\")\n\t\tIF_FEATURE_UDHCPC_ARPING(\"a::\")\n\t\tIF_FEATURE_UDHCP_PORT(\"P:\")\n\t\t\"v\"\n\t\t\"\\0\" IF_UDHCP_VERBOSE(\"vv\") /* -v is a counter */\n\t\t, udhcpc_longopts\n\t\t, &str_V, &str_h, &str_h, &str_F\n\t\t, &client_config.interface, &client_config.pidfile /* i,p */\n\t\t, &str_r /* r */\n\t\t, &client_config.script /* s */\n\t\t, &discover_timeout, &discover_retries, &tryagain_timeout /* T,t,A */\n\t\t, &list_O\n\t\t, &list_x\n\t\tIF_FEATURE_UDHCPC_ARPING(, &str_a)\n\t\tIF_FEATURE_UDHCP_PORT(, &str_P)\n\t\tIF_UDHCP_VERBOSE(, &dhcp_verbose)\n\t);\n\tif (opt & (OPT_h|OPT_H)) {\n\t\tbb_error_msg(\"option -h NAME is deprecated, use -x hostname:NAME\");\n\t\tclient_config.hostname = alloc_dhcp_option(DHCP_HOST_NAME, str_h, 0);\n\t}\n\tif (opt & OPT_F) {\n\t\t/* FQDN option format: [0x51][len][flags][0][0]<fqdn> */\n\t\tclient_config.fqdn = alloc_dhcp_option(DHCP_FQDN, str_F, 3);\n\t\t/* Flag bits: 0000NEOS\n\t\t * S: 1 = Client requests server to update A RR in DNS as well as PTR\n\t\t * O: 1 = Server indicates to client that DNS has been updated regardless\n\t\t * E: 1 = Name is in DNS format, i.e. <4>host<6>domain<3>com<0>,\n\t\t *    not \"host.domain.com\". Format 0 is obsolete.\n\t\t * N: 1 = Client requests server to not update DNS (S must be 0 then)\n\t\t * Two [0] bytes which follow are deprecated and must be 0.\n\t\t */\n\t\tclient_config.fqdn[OPT_DATA + 0] = 0x1;\n\t\t/*client_config.fqdn[OPT_DATA + 1] = 0; - xzalloc did it */\n\t\t/*client_config.fqdn[OPT_DATA + 2] = 0; */\n\t}\n\tif (opt & OPT_r)\n\t\trequested_ip = inet_addr(str_r);\n#if ENABLE_FEATURE_UDHCP_PORT\n\tif (opt & OPT_P) {\n\t\tCLIENT_PORT = xatou16(str_P);\n\t\tSERVER_PORT = CLIENT_PORT - 1;\n\t}\n#endif\n\tIF_FEATURE_UDHCPC_ARPING(arpping_ms = xatou(str_a);)\n\twhile (list_O) {\n\t\tchar *optstr = llist_pop(&list_O);\n\t\tunsigned n = bb_strtou(optstr, NULL, 0);\n\t\tif (errno || n > 254) {\n\t\t\tn = udhcp_option_idx(optstr, dhcp_option_strings);\n\t\t\tn = dhcp_optflags[n].code;\n\t\t}\n\t\tclient_config.opt_mask[n >> 3] |= 1 << (n & 7);\n\t}\n\tif (!(opt & OPT_o)) {\n\t\tunsigned i, n;\n\t\tfor (i = 0; (n = dhcp_optflags[i].code) != 0; i++) {\n\t\t\tif (dhcp_optflags[i].flags & OPTION_REQ) {\n\t\t\t\tclient_config.opt_mask[n >> 3] |= 1 << (n & 7);\n\t\t\t}\n\t\t}\n\t}\n\twhile (list_x) {\n\t\tchar *optstr = xstrdup(llist_pop(&list_x));\n\t\tudhcp_str2optset(optstr, &client_config.options,\n\t\t\t\tdhcp_optflags, dhcp_option_strings,\n\t\t\t\t/*dhcpv6:*/ 0\n\t\t);\n\t\tfree(optstr);\n\t}\n\n\tif (udhcp_read_interface(client_config.interface,\n\t\t\t&client_config.ifindex,\n\t\t\tNULL,\n\t\t\tclient_config.client_mac)\n\t) {\n\t\treturn 1;\n\t}\n\n\tclientid_mac_ptr = NULL;\n\tif (!(opt & OPT_C) && !udhcp_find_option(client_config.options, DHCP_CLIENT_ID)) {\n\t\t/* not suppressed and not set, set the default client ID */\n\t\tclient_config.clientid = alloc_dhcp_option(DHCP_CLIENT_ID, \"\", 7);\n\t\tclient_config.clientid[OPT_DATA] = 1; /* type: ethernet */\n\t\tclientid_mac_ptr = client_config.clientid + OPT_DATA+1;\n\t\tmemcpy(clientid_mac_ptr, client_config.client_mac, 6);\n\t}\n\tif (str_V[0] != '\\0') {\n\t\tclient_config.vendorclass = alloc_dhcp_option(DHCP_VENDOR, str_V, 0);\n\t}\n\n#if !BB_MMU\n\t/* on NOMMU reexec (i.e., background) early */\n\tif (!(opt & OPT_f)) {\n\t\tbb_daemonize_or_rexec(0 /* flags */, argv);\n\t\tlogmode = LOGMODE_NONE;\n\t}\n#endif\n\tif (opt & OPT_S) {\n\t\topenlog(applet_name, LOG_PID, LOG_DAEMON);\n\t\tlogmode |= LOGMODE_SYSLOG;\n\t}\n\n\t/* Make sure fd 0,1,2 are open */\n\tbb_sanitize_stdio();\n\t/* Create pidfile */\n\twrite_pidfile(client_config.pidfile);\n\t/* Goes to stdout (unless NOMMU) and possibly syslog */\n\tbb_error_msg(\"started, v\"BB_VER);\n\t/* Set up the signal pipe */\n\tudhcp_sp_setup();\n\t/* We want random_xid to be random... */\n\tsrand(monotonic_us());\n\n\tstate = INIT_SELECTING;\n\tudhcp_run_script(NULL, \"deconfig\");\n\tchange_listen_mode(LISTEN_RAW);\n\tpacket_num = 0;\n\ttimeout = 0;\n\talready_waited_sec = 0;\n\n\t/* Main event loop. select() waits on signal pipe and possibly\n\t * on sockfd.\n\t * \"continue\" statements in code below jump to the top of the loop.\n\t */\n\tfor (;;) {\n\t\tint tv;\n\t\tstruct pollfd pfds[2];\n\t\tstruct dhcp_packet packet;\n\t\t/* silence \"uninitialized!\" warning */\n\t\tunsigned timestamp_before_wait = timestamp_before_wait;\n\n\n\t\t/* Was opening raw or udp socket here\n\t\t * if (listen_mode != LISTEN_NONE && sockfd < 0),\n\t\t * but on fast network renew responses return faster\n\t\t * than we open sockets. Thus this code is moved\n\t\t * to change_listen_mode(). Thus we open listen socket\n\t\t * BEFORE we send renew request (see \"case BOUND:\"). */\n\n\t\tudhcp_sp_fd_set(pfds, sockfd);\n\n\t\ttv = timeout - already_waited_sec;\n\t\tretval = 0;\n\t\t/* If we already timed out, fall through with retval = 0, else... */\n\t\tif (tv > 0) {\n\t\t\tlog1(\"waiting %u seconds\", tv);\n\t\t\ttimestamp_before_wait = (unsigned)monotonic_sec();\n\t\t\tretval = poll(pfds, 2, tv < INT_MAX/1000 ? tv * 1000 : INT_MAX);\n\t\t\tif (retval < 0) {\n\t\t\t\t/* EINTR? A signal was caught, don't panic */\n\t\t\t\tif (errno == EINTR) {\n\t\t\t\t\talready_waited_sec += (unsigned)monotonic_sec() - timestamp_before_wait;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* Else: an error occurred, panic! */\n\t\t\t\tbb_perror_msg_and_die(\"poll\");\n\t\t\t}\n\t\t}\n\n\t\t/* If timeout dropped to zero, time to become active:\n\t\t * resend discover/renew/whatever\n\t\t */\n\t\tif (retval == 0) {\n\t\t\t/* When running on a bridge, the ifindex may have changed\n\t\t\t * (e.g. if member interfaces were added/removed\n\t\t\t * or if the status of the bridge changed).\n\t\t\t * Refresh ifindex and client_mac:\n\t\t\t */\n\t\t\tif (udhcp_read_interface(client_config.interface,\n\t\t\t\t\t&client_config.ifindex,\n\t\t\t\t\tNULL,\n\t\t\t\t\tclient_config.client_mac)\n\t\t\t) {\n\t\t\t\tgoto ret0; /* iface is gone? */\n\t\t\t}\n\t\t\tif (clientid_mac_ptr)\n\t\t\t\tmemcpy(clientid_mac_ptr, client_config.client_mac, 6);\n\n\t\t\t/* We will restart the wait in any case */\n\t\t\talready_waited_sec = 0;\n\n\t\t\tswitch (state) {\n\t\t\tcase INIT_SELECTING:\n\t\t\t\tif (!discover_retries || packet_num < discover_retries) {\n\t\t\t\t\tif (packet_num == 0)\n\t\t\t\t\t\txid = random_xid();\n\t\t\t\t\t/* broadcast */\n\t\t\t\t\tsend_discover(xid, requested_ip);\n\t\t\t\t\ttimeout = discover_timeout;\n\t\t\t\t\tpacket_num++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n leasefail:\n\t\t\t\tudhcp_run_script(NULL, \"leasefail\");\n#if BB_MMU /* -b is not supported on NOMMU */\n\t\t\t\tif (opt & OPT_b) { /* background if no lease */\n\t\t\t\t\tbb_error_msg(\"no lease, forking to background\");\n\t\t\t\t\tclient_background();\n\t\t\t\t\t/* do not background again! */\n\t\t\t\t\topt = ((opt & ~OPT_b) | OPT_f);\n\t\t\t\t} else\n#endif\n\t\t\t\tif (opt & OPT_n) { /* abort if no lease */\n\t\t\t\t\tbb_error_msg(\"no lease, failing\");\n\t\t\t\t\tretval = 1;\n\t\t\t\t\tgoto ret;\n\t\t\t\t}\n\t\t\t\t/* wait before trying again */\n\t\t\t\ttimeout = tryagain_timeout;\n\t\t\t\tpacket_num = 0;\n\t\t\t\tcontinue;\n\t\t\tcase REQUESTING:\n\t\t\t\tif (packet_num < 3) {\n\t\t\t\t\t/* send broadcast select packet */\n\t\t\t\t\tsend_select(xid, server_addr, requested_ip);\n\t\t\t\t\ttimeout = discover_timeout;\n\t\t\t\t\tpacket_num++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* Timed out, go back to init state.\n\t\t\t\t * \"discover...select...discover...\" loops\n\t\t\t\t * were seen in the wild. Treat them similarly\n\t\t\t\t * to \"no response to discover\" case */\n\t\t\t\tchange_listen_mode(LISTEN_RAW);\n\t\t\t\tstate = INIT_SELECTING;\n\t\t\t\tgoto leasefail;\n\t\t\tcase BOUND:\n\t\t\t\t/* 1/2 lease passed, enter renewing state */\n\t\t\t\tstate = RENEWING;\n\t\t\t\tclient_config.first_secs = 0; /* make secs field count from 0 */\n\t\t\t\tchange_listen_mode(LISTEN_KERNEL);\n\t\t\t\tlog1(\"entering renew state\");\n\t\t\t\t/* fall right through */\n\t\t\tcase RENEW_REQUESTED: /* manual (SIGUSR1) renew */\n\t\t\tcase_RENEW_REQUESTED:\n\t\t\tcase RENEWING:\n\t\t\t\tif (timeout >= 60) {\n\t\t\t\t\t/* send an unicast renew request */\n\t\t\t/* Sometimes observed to fail (EADDRNOTAVAIL) to bind\n\t\t\t * a new UDP socket for sending inside send_renew.\n\t\t\t * I hazard to guess existing listening socket\n\t\t\t * is somehow conflicting with it, but why is it\n\t\t\t * not deterministic then?! Strange.\n\t\t\t * Anyway, it does recover by eventually failing through\n\t\t\t * into INIT_SELECTING state.\n\t\t\t */\n\t\t\t\t\tif (send_renew(xid, server_addr, requested_ip) >= 0) {\n\t\t\t\t\t\ttimeout >>= 1;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t/* else: error sending.\n\t\t\t\t\t * example: ENETUNREACH seen with server\n\t\t\t\t\t * which gave us bogus server ID 1.1.1.1\n\t\t\t\t\t * which wasn't reachable (and probably did not exist).\n\t\t\t\t\t */\n\t\t\t\t}\n\t\t\t\t/* Timed out or error, enter rebinding state */\n\t\t\t\tlog1(\"entering rebinding state\");\n\t\t\t\tstate = REBINDING;\n\t\t\t\t/* fall right through */\n\t\t\tcase REBINDING:\n\t\t\t\t/* Switch to bcast receive */\n\t\t\t\tchange_listen_mode(LISTEN_RAW);\n\t\t\t\t/* Lease is *really* about to run out,\n\t\t\t\t * try to find DHCP server using broadcast */\n\t\t\t\tif (timeout > 0) {\n\t\t\t\t\t/* send a broadcast renew request */\n\t\t\t\t\tsend_renew(xid, 0 /*INADDR_ANY*/, requested_ip);\n\t\t\t\t\ttimeout >>= 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* Timed out, enter init state */\n\t\t\t\tbb_error_msg(\"lease lost, entering init state\");\n\t\t\t\tudhcp_run_script(NULL, \"deconfig\");\n\t\t\t\tstate = INIT_SELECTING;\n\t\t\t\tclient_config.first_secs = 0; /* make secs field count from 0 */\n\t\t\t\t/*timeout = 0; - already is */\n\t\t\t\tpacket_num = 0;\n\t\t\t\tcontinue;\n\t\t\t/* case RELEASED: */\n\t\t\t}\n\t\t\t/* yah, I know, *you* say it would never happen */\n\t\t\ttimeout = INT_MAX;\n\t\t\tcontinue; /* back to main loop */\n\t\t} /* if poll timed out */\n\n\t\t/* poll() didn't timeout, something happened */\n\n\t\t/* Is it a signal? */\n\t\tswitch (udhcp_sp_read()) {\n\t\tcase SIGUSR1:\n\t\t\tclient_config.first_secs = 0; /* make secs field count from 0 */\n\t\t\talready_waited_sec = 0;\n\t\t\tperform_renew();\n\t\t\tif (state == RENEW_REQUESTED) {\n\t\t\t\t/* We might be either on the same network\n\t\t\t\t * (in which case renew might work),\n\t\t\t\t * or we might be on a completely different one\n\t\t\t\t * (in which case renew won't ever succeed).\n\t\t\t\t * For the second case, must make sure timeout\n\t\t\t\t * is not too big, or else we can send\n\t\t\t\t * futile renew requests for hours.\n\t\t\t\t */\n\t\t\t\tif (timeout > 60)\n\t\t\t\t\ttimeout = 60;\n\t\t\t\tgoto case_RENEW_REQUESTED;\n\t\t\t}\n\t\t\t/* Start things over */\n\t\t\tpacket_num = 0;\n\t\t\t/* Kill any timeouts, user wants this to hurry along */\n\t\t\ttimeout = 0;\n\t\t\tcontinue;\n\t\tcase SIGUSR2:\n\t\t\tperform_release(server_addr, requested_ip);\n\t\t\ttimeout = INT_MAX;\n\t\t\tcontinue;\n\t\tcase SIGTERM:\n\t\t\tbb_error_msg(\"received %s\", \"SIGTERM\");\n\t\t\tgoto ret0;\n\t\t}\n\n\t\t/* Is it a packet? */\n\t\tif (!pfds[1].revents)\n\t\t\tcontinue; /* no */\n\n\t\t{\n\t\t\tint len;\n\n\t\t\t/* A packet is ready, read it */\n\t\t\tif (listen_mode == LISTEN_KERNEL)\n\t\t\t\tlen = udhcp_recv_kernel_packet(&packet, sockfd);\n\t\t\telse\n\t\t\t\tlen = udhcp_recv_raw_packet(&packet, sockfd);\n\t\t\tif (len == -1) {\n\t\t\t\t/* Error is severe, reopen socket */\n\t\t\t\tbb_error_msg(\"read error: \"STRERROR_FMT\", reopening socket\" STRERROR_ERRNO);\n\t\t\t\tsleep(discover_timeout); /* 3 seconds by default */\n\t\t\t\tchange_listen_mode(listen_mode); /* just close and reopen */\n\t\t\t}\n\t\t\t/* If this packet will turn out to be unrelated/bogus,\n\t\t\t * we will go back and wait for next one.\n\t\t\t * Be sure timeout is properly decreased. */\n\t\t\talready_waited_sec += (unsigned)monotonic_sec() - timestamp_before_wait;\n\t\t\tif (len < 0)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (packet.xid != xid) {\n\t\t\tlog1(\"xid %x (our is %x), ignoring packet\",\n\t\t\t\t(unsigned)packet.xid, (unsigned)xid);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Ignore packets that aren't for us */\n\t\tif (packet.hlen != 6\n\t\t || memcmp(packet.chaddr, client_config.client_mac, 6) != 0\n\t\t) {\n\t\t\tlog1(\"chaddr does not match, ignoring packet\"); // log2?\n\t\t\tcontinue;\n\t\t}\n\n\t\tmessage = udhcp_get_option(&packet, DHCP_MESSAGE_TYPE);\n\t\tif (message == NULL) {\n\t\t\tbb_error_msg(\"no message type option, ignoring packet\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (state) {\n\t\tcase INIT_SELECTING:\n\t\t\t/* Must be a DHCPOFFER */\n\t\t\tif (*message == DHCPOFFER) {\n\t\t\t\tuint8_t *temp;\n\n/* What exactly is server's IP? There are several values.\n * Example DHCP offer captured with tchdump:\n *\n * 10.34.25.254:67 > 10.34.25.202:68 // IP header's src\n * BOOTP fields:\n * Your-IP 10.34.25.202\n * Server-IP 10.34.32.125   // \"next server\" IP\n * Gateway-IP 10.34.25.254  // relay's address (if DHCP relays are in use)\n * DHCP options:\n * DHCP-Message Option 53, length 1: Offer\n * Server-ID Option 54, length 4: 10.34.255.7       // \"server ID\"\n * Default-Gateway Option 3, length 4: 10.34.25.254 // router\n *\n * We think that real server IP (one to use in renew/release)\n * is one in Server-ID option. But I am not 100% sure.\n * IP header's src and Gateway-IP (same in this example)\n * might work too.\n * \"Next server\" and router are definitely wrong ones to use, though...\n */\n/* We used to ignore pcakets without DHCP_SERVER_ID.\n * I've got user reports from people who run \"address-less\" servers.\n * They either supply DHCP_SERVER_ID of 0.0.0.0 or don't supply it at all.\n  * They say ISC DHCP client supports this case.\n  */\n \t\t\t\tserver_addr = 0;\n\t\t\t\ttemp = udhcp_get_option(&packet, DHCP_SERVER_ID);\n \t\t\t\tif (!temp) {\n \t\t\t\t\tbb_error_msg(\"no server ID, using 0.0.0.0\");\n \t\t\t\t} else {\n\t\t\t\t\t/* it IS unaligned sometimes, don't \"optimize\" */\n\t\t\t\t\tmove_from_unaligned32(server_addr, temp);\n\t\t\t\t}\n\t\t\t\t/*xid = packet.xid; - already is */\n\t\t\t\trequested_ip = packet.yiaddr;\n\n\t\t\t\t/* enter requesting state */\n\t\t\t\tstate = REQUESTING;\n\t\t\t\ttimeout = 0;\n\t\t\t\tpacket_num = 0;\n\t\t\t\talready_waited_sec = 0;\n\t\t\t}\n\t\t\tcontinue;\n\t\tcase REQUESTING:\n\t\tcase RENEWING:\n\t\tcase RENEW_REQUESTED:\n\t\tcase REBINDING:\n\t\t\tif (*message == DHCPACK) {\n\t\t\t\tunsigned start;\n\t\t\t\tuint32_t lease_seconds;\n \t\t\t\tstruct in_addr temp_addr;\n \t\t\t\tuint8_t *temp;\n \n\t\t\t\ttemp = udhcp_get_option(&packet, DHCP_LEASE_TIME);\n \t\t\t\tif (!temp) {\n \t\t\t\t\tbb_error_msg(\"no lease time with ACK, using 1 hour lease\");\n \t\t\t\t\tlease_seconds = 60 * 60;\n\t\t\t\t} else {\n\t\t\t\t\t/* it IS unaligned sometimes, don't \"optimize\" */\n\t\t\t\t\tmove_from_unaligned32(lease_seconds, temp);\n\t\t\t\t\tlease_seconds = ntohl(lease_seconds);\n\t\t\t\t\t/* paranoia: must not be too small and not prone to overflows */\n\t\t\t\t\t/* timeout > 60 - ensures at least one unicast renew attempt */\n\t\t\t\t\tif (lease_seconds < 2 * 61)\n\t\t\t\t\t\tlease_seconds = 2 * 61;\n\t\t\t\t}\n#if ENABLE_FEATURE_UDHCPC_ARPING\n\t\t\t\tif (opt & OPT_a) {\n/* RFC 2131 3.1 paragraph 5:\n * \"The client receives the DHCPACK message with configuration\n * parameters. The client SHOULD perform a final check on the\n * parameters (e.g., ARP for allocated network address), and notes\n * the duration of the lease specified in the DHCPACK message. At this\n * point, the client is configured. If the client detects that the\n * address is already in use (e.g., through the use of ARP),\n * the client MUST send a DHCPDECLINE message to the server and restarts\n * the configuration process...\" */\n\t\t\t\t\tif (!arpping(packet.yiaddr,\n\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t(uint32_t) 0,\n\t\t\t\t\t\t\tclient_config.client_mac,\n\t\t\t\t\t\t\tclient_config.interface,\n\t\t\t\t\t\t\tarpping_ms)\n\t\t\t\t\t) {\n\t\t\t\t\t\tbb_error_msg(\"offered address is in use \"\n\t\t\t\t\t\t\t\"(got ARP reply), declining\");\n\t\t\t\t\t\tsend_decline(/*xid,*/ server_addr, packet.yiaddr);\n\n\t\t\t\t\t\tif (state != REQUESTING)\n\t\t\t\t\t\t\tudhcp_run_script(NULL, \"deconfig\");\n\t\t\t\t\t\tchange_listen_mode(LISTEN_RAW);\n\t\t\t\t\t\tstate = INIT_SELECTING;\n\t\t\t\t\t\tclient_config.first_secs = 0; /* make secs field count from 0 */\n\t\t\t\t\t\trequested_ip = 0;\n\t\t\t\t\t\ttimeout = tryagain_timeout;\n\t\t\t\t\t\tpacket_num = 0;\n\t\t\t\t\t\talready_waited_sec = 0;\n\t\t\t\t\t\tcontinue; /* back to main loop */\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t\t/* enter bound state */\n\t\t\t\ttemp_addr.s_addr = packet.yiaddr;\n\t\t\t\tbb_error_msg(\"lease of %s obtained, lease time %u\",\n\t\t\t\t\tinet_ntoa(temp_addr), (unsigned)lease_seconds);\n\t\t\t\trequested_ip = packet.yiaddr;\n\n\t\t\t\tstart = monotonic_sec();\n\t\t\t\tudhcp_run_script(&packet, state == REQUESTING ? \"bound\" : \"renew\");\n\t\t\t\talready_waited_sec = (unsigned)monotonic_sec() - start;\n\t\t\t\ttimeout = lease_seconds / 2;\n\t\t\t\tif ((unsigned)timeout < already_waited_sec) {\n\t\t\t\t\t/* Something went wrong. Back to discover state */\n\t\t\t\t\ttimeout = already_waited_sec = 0;\n\t\t\t\t}\n\n\t\t\t\tstate = BOUND;\n\t\t\t\tchange_listen_mode(LISTEN_NONE);\n\t\t\t\tif (opt & OPT_q) { /* quit after lease */\n\t\t\t\t\tgoto ret0;\n\t\t\t\t}\n\t\t\t\t/* future renew failures should not exit (JM) */\n\t\t\t\topt &= ~OPT_n;\n#if BB_MMU /* NOMMU case backgrounded earlier */\n\t\t\t\tif (!(opt & OPT_f)) {\n\t\t\t\t\tclient_background();\n\t\t\t\t\t/* do not background again! */\n\t\t\t\t\topt = ((opt & ~OPT_b) | OPT_f);\n\t\t\t\t}\n#endif\n\t\t\t\t/* make future renew packets use different xid */\n\t\t\t\t/* xid = random_xid(); ...but why bother? */\n\n\t\t\t\tcontinue; /* back to main loop */\n\t\t\t}\n\t\t\tif (*message == DHCPNAK) {\n\t\t\t\t/* If network has more than one DHCP server,\n\t\t\t\t * \"wrong\" server can reply first, with a NAK.\n\t\t\t\t * Do not interpret it as a NAK from \"our\" server.\n\t\t\t\t */\n\t\t\t\tif (server_addr != 0) {\n \t\t\t\t\tuint32_t svid;\n \t\t\t\t\tuint8_t *temp;\n \n\t\t\t\t\ttemp = udhcp_get_option(&packet, DHCP_SERVER_ID);\n \t\t\t\t\tif (!temp) {\n  non_matching_svid:\n \t\t\t\t\t\tlog1(\"received DHCP NAK with wrong\"\n\t\t\t\t\t\t\t\" server ID, ignoring packet\");\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tmove_from_unaligned32(svid, temp);\n\t\t\t\t\tif (svid != server_addr)\n\t\t\t\t\t\tgoto non_matching_svid;\n\t\t\t\t}\n\t\t\t\t/* return to init state */\n\t\t\t\tbb_error_msg(\"received %s\", \"DHCP NAK\");\n\t\t\t\tudhcp_run_script(&packet, \"nak\");\n\t\t\t\tif (state != REQUESTING)\n\t\t\t\t\tudhcp_run_script(NULL, \"deconfig\");\n\t\t\t\tchange_listen_mode(LISTEN_RAW);\n\t\t\t\tsleep(3); /* avoid excessive network traffic */\n\t\t\t\tstate = INIT_SELECTING;\n\t\t\t\tclient_config.first_secs = 0; /* make secs field count from 0 */\n\t\t\t\trequested_ip = 0;\n\t\t\t\ttimeout = 0;\n\t\t\t\tpacket_num = 0;\n\t\t\t\talready_waited_sec = 0;\n\t\t\t}\n\t\t\tcontinue;\n\t\t/* case BOUND: - ignore all packets */\n\t\t/* case RELEASED: - ignore all packets */\n\t\t}\n\t\t/* back to main loop */\n\t} /* for (;;) - main loop ends */\n\n ret0:\n\tif (opt & OPT_R) /* release on quit */\n\t\tperform_release(server_addr, requested_ip);\n\tretval = 0;\n ret:\n\t/*if (client_config.pidfile) - remove_pidfile has its own check */\n\t\tremove_pidfile(client_config.pidfile);\n\treturn retval;\n}\n", "target": 1, "idx": 178396}
{"func": "void PDFiumEngine::OnDocumentComplete() {\n  if (!doc_ || !form_) {\n    file_access_.m_FileLen = doc_loader_.document_size();\n    if (!fpdf_availability_) {\n      fpdf_availability_ = FPDFAvail_Create(&file_availability_, &file_access_);\n      DCHECK(fpdf_availability_);\n    }\n    LoadDocument();\n    return;\n  }\n\n  FinishLoadingDocument();\n}\n", "target": 0, "idx": 153071}
{"func": "RenderThreadImpl::HostAllocateSharedMemoryBuffer(size_t size) {\n  return ChildThreadImpl::AllocateSharedMemory(size);\n}\n", "target": 0, "idx": 163345}
{"func": " static void sas_scsi_clear_queue_lu(struct list_head *error_q, struct scsi_cmnd *my_cmd)\n {\n \tstruct scsi_cmnd *cmd, *n;\n \n \tlist_for_each_entry_safe(cmd, n, error_q, eh_entry) {\n \t\tif (cmd->device->sdev_target == my_cmd->device->sdev_target &&\n \t\t    cmd->device->lun == my_cmd->device->lun)\n\t\t\tsas_eh_defer_cmd(cmd);\n \t}\n }\n", "target": 1, "idx": 182435}
{"func": "bool BrowserView::HasClientEdge() const {\n  return frame()->GetFrameView()->HasClientEdge();\n}\n", "target": 0, "idx": 168299}
{"func": "void WebPluginDelegateProxy::Paint(WebKit::WebCanvas* canvas,\n                                   const gfx::Rect& damaged_rect) {\n  gfx::Rect rect = damaged_rect.Intersect(plugin_rect_);\n\n  if (!channel_host_ || !channel_host_->channel_valid()) {\n    PaintSadPlugin(canvas, rect);\n    return;\n  }\n\n  if (!uses_shared_bitmaps_)\n    return;\n\n  if (!front_buffer_canvas())\n    return;\n\n#if WEBKIT_USING_SKIA\n  if (!skia::SupportsPlatformPaint(canvas)) {\n    DLOG(WARNING) << \"Could not paint plugin\";\n    return;\n  }\n  skia::ScopedPlatformPaint scoped_platform_paint(canvas);\n  gfx::NativeDrawingContext context =\n      scoped_platform_paint.GetPlatformSurface();\n#elif WEBKIT_USING_CG\n  gfx::NativeDrawingContext context = canvas;\n#endif\n\n  gfx::Rect offset_rect = rect;\n  offset_rect.Offset(-plugin_rect_.x(), -plugin_rect_.y());\n  gfx::Rect canvas_rect = offset_rect;\n#if defined(OS_MACOSX)\n  FlipRectVerticallyWithHeight(&canvas_rect, plugin_rect_.height());\n#endif\n\n  bool background_changed = false;\n  if (background_store_.canvas.get() && BackgroundChanged(context, rect)) {\n    background_changed = true;\n    BlitContextToCanvas(background_store_.canvas.get(), canvas_rect,\n                        context, rect.origin());\n  }\n\n  if (background_changed ||\n      !transport_store_painted_.Contains(offset_rect)) {\n    Send(new PluginMsg_Paint(instance_id_, offset_rect));\n    UpdateFrontBuffer(offset_rect, false);\n  }\n\n#if defined(OS_MACOSX)\n  CGContextSaveGState(context);\n  CGContextScaleCTM(context, 1, -1);\n  rect.set_y(-rect.bottom());\n#endif\n  BlitCanvasToContext(context,\n                      rect,\n                      front_buffer_canvas(),\n                      offset_rect.origin());\n#if defined(OS_MACOSX)\n  CGContextRestoreGState(context);\n#endif\n\n  if (invalidate_pending_) {\n    invalidate_pending_ = false;\n    Send(new PluginMsg_DidPaint(instance_id_));\n  }\n}\n", "target": 0, "idx": 114647}
{"func": "int send_event (int fd, uint16_t type, uint16_t code, int32_t value)\n{\n struct uinput_event event;\n    BTIF_TRACE_DEBUG(\"%s type:%u code:%u value:%d\", __FUNCTION__,\n        type, code, value);\n    memset(&event, 0, sizeof(event));\n    event.type  = type;\n\n     event.code  = code;\n     event.value = value;\n \n    return write(fd, &event, sizeof(event));\n }\n", "target": 1, "idx": 187473}
{"func": "bool FlagsState::IsRestartNeededToCommitChanges() {\n  return needs_restart_;\n}\n", "target": 0, "idx": 111764}
{"func": "make_error(png_store* volatile psIn, png_byte PNG_CONST colour_type,\n     png_byte bit_depth, int interlace_type, int test, png_const_charp name)\n {\n   png_store * volatile ps = psIn;\n    context(ps, fault);\n \n    check_interlace_type(interlace_type);\n \n    Try\n    {\n      png_structp pp;\n       png_infop pi;\n      pp = set_store_for_write(ps, &pi, name);\n \n       if (pp == NULL)\n          Throw ps;\n \n      png_set_IHDR(pp, pi, transform_width(pp, colour_type, bit_depth),\n         transform_height(pp, colour_type, bit_depth), bit_depth, colour_type,\n         interlace_type, PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);\n \n       if (colour_type == 3) /* palette */\n          init_standard_palette(ps, pp, pi, 1U << bit_depth, 0/*do tRNS*/);\n\n /* Time for a few errors; these are in various optional chunks, the\n       * standard tests test the standard chunks pretty well.\n       */\n#     define exception__prev exception_prev_1\n\n #     define exception__env exception_env_1\n       Try\n       {\n          /* Expect this to throw: */\n          ps->expect_error = !error_test[test].warning;\n          ps->expect_warning = error_test[test].warning;\n         ps->saw_warning = 0;\n         error_test[test].fn(pp, pi);\n\n /* Normally the error is only detected here: */\n         png_write_info(pp, pi);\n\n /* And handle the case where it was only a warning: */\n if (ps->expect_warning && ps->saw_warning)\n Throw ps;\n\n /* If we get here there is a problem, we have success - no error or\n          * no warning - when we shouldn't have success.  Log an error.\n          */\n         store_log(ps, pp, error_test[test].msg, 1 /*error*/);\n\n       }\n \n       Catch (fault)\n         ps = fault; /* expected exit, make sure ps is not clobbered */\n #undef exception__prev\n #undef exception__env\n \n /* And clear these flags */\n      ps->expect_error = 0;\n      ps->expect_warning = 0;\n\n /* Now write the whole image, just to make sure that the detected, or\n       * undetected, errro has not created problems inside libpng.\n       */\n if (png_get_rowbytes(pp, pi) !=\n          transform_rowsize(pp, colour_type, bit_depth))\n         png_error(pp, \"row size incorrect\");\n\n \n       else\n       {\n         png_uint_32 h = transform_height(pp, colour_type, bit_depth);\n         int npasses = png_set_interlace_handling(pp);\n          int pass;\n \n          if (npasses != npasses_from_interlace_type(pp, interlace_type))\n            png_error(pp, \"write: png_set_interlace_handling failed\");\n\n for (pass=0; pass<npasses; ++pass)\n {\n            png_uint_32 y;\n\n for (y=0; y<h; ++y)\n {\n\n                png_byte buffer[TRANSFORM_ROWMAX];\n \n                transform_row(pp, buffer, colour_type, bit_depth, y);\n                png_write_row(pp, buffer);\n             }\n          }\n }\n\n      png_write_end(pp, pi);\n\n /* The following deletes the file that was just written. */\n      store_write_reset(ps);\n }\n\n Catch(fault)\n {\n      store_write_reset(fault);\n }\n\n }\n", "target": 1, "idx": 187683}
{"func": "static const char *func_id_name(int id)\n{\n\tBUILD_BUG_ON(ARRAY_SIZE(func_id_str) != __BPF_FUNC_MAX_ID);\n\n\tif (id >= 0 && id < __BPF_FUNC_MAX_ID && func_id_str[id])\n\t\treturn func_id_str[id];\n\telse\n\t\treturn \"unknown\";\n}\n", "target": 0, "idx": 65062}
{"func": "static MagickBooleanType OpenPixelCache(Image *image,const MapMode mode,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info,\n    source_info;\n\n  char\n    format[MagickPathExtent],\n    message[MagickPathExtent];\n\n  const char\n    *type;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    length,\n    number_pixels;\n\n  size_t\n    columns,\n    packet_size;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if ((image->columns == 0) || (image->rows == 0))\n    ThrowBinaryException(CacheError,\"NoPixelsDefinedInCache\",image->filename);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  if ((AcquireMagickResource(WidthResource,image->columns) == MagickFalse) ||\n      (AcquireMagickResource(HeightResource,image->rows) == MagickFalse))\n    ThrowBinaryException(ImageError,\"WidthOrHeightExceedsLimit\",\n      image->filename);\n  source_info=(*cache_info);\n  source_info.file=(-1);\n  (void) FormatLocaleString(cache_info->filename,MagickPathExtent,\"%s[%.20g]\",\n    image->filename,(double) GetImageIndexInList(image));\n  cache_info->storage_class=image->storage_class;\n  cache_info->colorspace=image->colorspace;\n  cache_info->alpha_trait=image->alpha_trait;\n  cache_info->read_mask=image->read_mask;\n  cache_info->write_mask=image->write_mask;\n  cache_info->rows=image->rows;\n  cache_info->columns=image->columns;\n  InitializePixelChannelMap(image);\n  cache_info->number_channels=GetPixelChannels(image);\n  (void) memcpy(cache_info->channel_map,image->channel_map,MaxPixelChannels*\n    sizeof(*image->channel_map));\n  cache_info->metacontent_extent=image->metacontent_extent;\n  cache_info->mode=mode;\n  number_pixels=(MagickSizeType) cache_info->columns*cache_info->rows;\n  packet_size=cache_info->number_channels*sizeof(Quantum);\n  if (image->metacontent_extent != 0)\n    packet_size+=cache_info->metacontent_extent;\n  length=number_pixels*packet_size;\n  columns=(size_t) (length/cache_info->rows/packet_size);\n  if ((cache_info->columns != columns) || ((ssize_t) cache_info->columns < 0) ||\n      ((ssize_t) cache_info->rows < 0))\n    ThrowBinaryException(ResourceLimitError,\"PixelCacheAllocationFailed\",\n      image->filename);\n  cache_info->length=length;\n  if (image->ping != MagickFalse)\n    {\n      cache_info->storage_class=image->storage_class;\n      cache_info->colorspace=image->colorspace;\n      cache_info->type=PingCache;\n      return(MagickTrue);\n    }\n  status=AcquireMagickResource(AreaResource,cache_info->length);\n  length=number_pixels*(cache_info->number_channels*sizeof(Quantum)+\n    cache_info->metacontent_extent);\n  if ((status != MagickFalse) && (length == (MagickSizeType) ((size_t) length)))\n    {\n      status=AcquireMagickResource(MemoryResource,cache_info->length);\n      if (((cache_info->type == UndefinedCache) && (status != MagickFalse)) ||\n          (cache_info->type == MemoryCache))\n        {\n          cache_info->mapped=MagickFalse;\n          cache_info->pixels=(Quantum *) MagickAssumeAligned(\n            AcquireAlignedMemory(1,(size_t) cache_info->length));\n          if (cache_info->pixels == (Quantum *) NULL)\n            cache_info->pixels=source_info.pixels;\n          else\n            {\n              /*\n                Create memory pixel cache.\n              */\n              status=MagickTrue;\n              cache_info->type=MemoryCache;\n              cache_info->metacontent=(void *) NULL;\n              if (cache_info->metacontent_extent != 0)\n                cache_info->metacontent=(void *) (cache_info->pixels+\n                  number_pixels*cache_info->number_channels);\n              if ((source_info.storage_class != UndefinedClass) &&\n                  (mode != ReadMode))\n                {\n                  status=ClonePixelCacheRepository(cache_info,&source_info,\n                    exception);\n                  RelinquishPixelCachePixels(&source_info);\n                }\n              if (image->debug != MagickFalse)\n                {\n                  (void) FormatMagickSize(cache_info->length,MagickTrue,\"B\",\n                    MagickPathExtent,format);\n                  type=CommandOptionToMnemonic(MagickCacheOptions,(ssize_t)\n                    cache_info->type);\n                  (void) FormatLocaleString(message,MagickPathExtent,\n                    \"open %s (%s %s, %.20gx%.20gx%.20g %s)\",\n                    cache_info->filename,cache_info->mapped != MagickFalse ?\n                    \"Anonymous\" : \"Heap\",type,(double) cache_info->columns,\n                    (double) cache_info->rows,(double)\n                    cache_info->number_channels,format);\n                  (void) LogMagickEvent(CacheEvent,GetMagickModule(),\"%s\",\n                    message);\n                }\n              return(status);\n            }\n        }\n      RelinquishMagickResource(MemoryResource,cache_info->length);\n    }\n  /*\n    Create pixel cache on disk.\n  */\n  status=AcquireMagickResource(DiskResource,cache_info->length);\n  if ((status == MagickFalse) || (cache_info->type == DistributedCache))\n    {\n      DistributeCacheInfo\n        *server_info;\n\n      if (cache_info->type == DistributedCache)\n        RelinquishMagickResource(DiskResource,cache_info->length);\n      server_info=AcquireDistributeCacheInfo(exception);\n      if (server_info != (DistributeCacheInfo *) NULL)\n        {\n          status=OpenDistributePixelCache(server_info,image);\n          if (status == MagickFalse)\n            {\n              ThrowFileException(exception,CacheError,\"UnableToOpenPixelCache\",\n                GetDistributeCacheHostname(server_info));\n              server_info=DestroyDistributeCacheInfo(server_info);\n            }\n          else\n            {\n              /*\n                Create a distributed pixel cache.\n              */\n              cache_info->type=DistributedCache;\n              cache_info->server_info=server_info;\n              (void) FormatLocaleString(cache_info->cache_filename,\n                MagickPathExtent,\"%s:%d\",GetDistributeCacheHostname(\n                (DistributeCacheInfo *) cache_info->server_info),\n                GetDistributeCachePort((DistributeCacheInfo *)\n                cache_info->server_info));\n              if ((source_info.storage_class != UndefinedClass) &&\n                  (mode != ReadMode))\n                {\n                  status=ClonePixelCacheRepository(cache_info,&source_info,\n                    exception);\n                  RelinquishPixelCachePixels(&source_info);\n                }\n              if (image->debug != MagickFalse)\n                {\n                  (void) FormatMagickSize(cache_info->length,MagickFalse,\"B\",\n                    MagickPathExtent,format);\n                  type=CommandOptionToMnemonic(MagickCacheOptions,(ssize_t)\n                    cache_info->type);\n                  (void) FormatLocaleString(message,MagickPathExtent,\n                    \"open %s (%s[%d], %s, %.20gx%.20gx%.20g %s)\",\n                    cache_info->filename,cache_info->cache_filename,\n                    GetDistributeCacheFile((DistributeCacheInfo *)\n                    cache_info->server_info),type,(double) cache_info->columns,\n                    (double) cache_info->rows,(double)\n                    cache_info->number_channels,format);\n                  (void) LogMagickEvent(CacheEvent,GetMagickModule(),\"%s\",\n                    message);\n                }\n              return(MagickTrue);\n             }\n         }\n       RelinquishMagickResource(DiskResource,cache_info->length);\n       (void) ThrowMagickException(exception,GetMagickModule(),CacheError,\n         \"CacheResourcesExhausted\",\"`%s'\",image->filename);\n       return(MagickFalse);\n    }\n  if ((source_info.storage_class != UndefinedClass) && (mode != ReadMode))\n    {\n      (void) ClosePixelCacheOnDisk(cache_info);\n      *cache_info->cache_filename='\\0';\n    }\n   if (OpenPixelCacheOnDisk(cache_info,mode) == MagickFalse)\n     {\n       RelinquishMagickResource(DiskResource,cache_info->length);\n       ThrowFileException(exception,CacheError,\"UnableToOpenPixelCache\",\n         image->filename);\n       return(MagickFalse);\n    }\n  status=SetPixelCacheExtent(image,(MagickSizeType) cache_info->offset+\n     cache_info->length);\n   if (status == MagickFalse)\n     {\n       ThrowFileException(exception,CacheError,\"UnableToExtendCache\",\n         image->filename);\n       return(MagickFalse);\n    }\n  length=number_pixels*(cache_info->number_channels*sizeof(Quantum)+\n    cache_info->metacontent_extent);\n  if (length != (MagickSizeType) ((size_t) length))\n    cache_info->type=DiskCache;\n  else\n    {\n      status=AcquireMagickResource(MapResource,cache_info->length);\n      if ((status == MagickFalse) && (cache_info->type != MapCache) &&\n          (cache_info->type != MemoryCache))\n        cache_info->type=DiskCache;\n      else\n        {\n          cache_info->pixels=(Quantum *) MapBlob(cache_info->file,mode,\n            cache_info->offset,(size_t) cache_info->length);\n          if (cache_info->pixels == (Quantum *) NULL)\n            {\n              cache_info->type=DiskCache;\n              cache_info->pixels=source_info.pixels;\n            }\n          else\n            {\n              /*\n                Create file-backed memory-mapped pixel cache.\n              */\n              status=MagickTrue;\n              (void) ClosePixelCacheOnDisk(cache_info);\n              cache_info->type=MapCache;\n              cache_info->mapped=MagickTrue;\n              cache_info->metacontent=(void *) NULL;\n              if (cache_info->metacontent_extent != 0)\n                cache_info->metacontent=(void *) (cache_info->pixels+\n                  number_pixels*cache_info->number_channels);\n              if ((source_info.storage_class != UndefinedClass) &&\n                  (mode != ReadMode))\n                {\n                  status=ClonePixelCacheRepository(cache_info,&source_info,\n                    exception);\n                  RelinquishPixelCachePixels(&source_info);\n                }\n              if (image->debug != MagickFalse)\n                {\n                  (void) FormatMagickSize(cache_info->length,MagickTrue,\"B\",\n                    MagickPathExtent,format);\n                  type=CommandOptionToMnemonic(MagickCacheOptions,(ssize_t)\n                    cache_info->type);\n                  (void) FormatLocaleString(message,MagickPathExtent,\n                    \"open %s (%s[%d], %s, %.20gx%.20gx%.20g %s)\",\n                    cache_info->filename,cache_info->cache_filename,\n                    cache_info->file,type,(double) cache_info->columns,(double)\n                    cache_info->rows,(double) cache_info->number_channels,\n                    format);\n                   (void) LogMagickEvent(CacheEvent,GetMagickModule(),\"%s\",\n                     message);\n                 }\n               return(status);\n             }\n         }\n      RelinquishMagickResource(MapResource,cache_info->length);\n    }\n  status=MagickTrue;\n  if ((source_info.storage_class != UndefinedClass) && (mode != ReadMode))\n    {\n      status=ClonePixelCacheRepository(cache_info,&source_info,exception);\n      RelinquishPixelCachePixels(&source_info);\n    }\n  if (image->debug != MagickFalse)\n    {\n      (void) FormatMagickSize(cache_info->length,MagickFalse,\"B\",\n        MagickPathExtent,format);\n      type=CommandOptionToMnemonic(MagickCacheOptions,(ssize_t)\n        cache_info->type);\n      (void) FormatLocaleString(message,MagickPathExtent,\n        \"open %s (%s[%d], %s, %.20gx%.20gx%.20g %s)\",cache_info->filename,\n        cache_info->cache_filename,cache_info->file,type,(double)\n        cache_info->columns,(double) cache_info->rows,(double)\n         cache_info->number_channels,format);\n       (void) LogMagickEvent(CacheEvent,GetMagickModule(),\"%s\",message);\n     }\n   return(status);\n }\n", "target": 1, "idx": 183131}
{"func": "void BackendImpl::CleanupCache() {\n  DCHECK(background_queue_.BackgroundIsCurrentSequence());\n  Trace(\"Backend Cleanup\");\n  eviction_.Stop();\n  timer_.reset();\n\n  if (init_) {\n    StoreStats();\n    if (data_)\n      data_->header.crash = 0;\n\n    if (user_flags_ & kNoRandom) {\n      File::WaitForPendingIO(&num_pending_io_);\n      DCHECK(!num_refs_);\n    } else {\n      File::DropPendingIO();\n    }\n  }\n  block_files_.CloseFiles();\n  FlushIndex();\n  index_ = NULL;\n  ptr_factory_.InvalidateWeakPtrs();\n  done_.Signal();\n}\n", "target": 0, "idx": 160010}
{"func": "xmlFatalErrMsg(xmlParserCtxtPtr ctxt, xmlParserErrors error,\n const char *msg)\n{\n if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&\n (ctxt->instate == XML_PARSER_EOF))\n return;\n if (ctxt != NULL)\n\tctxt->errNo = error;\n    __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,\n                    XML_ERR_FATAL, NULL, 0, NULL, NULL, NULL, 0, 0, \"%s\", msg);\n if (ctxt != NULL) {\n\tctxt->wellFormed = 0;\n if (ctxt->recovery == 0)\n\t    ctxt->disableSAX = 1;\n }\n}\n", "target": 0, "idx": 176584}
{"func": "bool  PrintWebViewHelper::PrintPreviewContext::IsFinalPageRendered() const {\n  return static_cast<size_t>(current_page_index_) == pages_to_render_.size();\n}\n", "target": 0, "idx": 101962}
{"func": "  virtual void TabMoved(\n      TabContentsWrapper* contents, int from_index, int to_index) {\n    State* s = new State(contents, to_index, MOVE);\n    s->src_index = from_index;\n    states_.push_back(s);\n  }\n", "target": 0, "idx": 103055}
{"func": "static void disk_seqf_stop(struct seq_file *seqf, void *v)\n{\n\tstruct class_dev_iter *iter = seqf->private;\n\n\t/* stop is called even after start failed :-( */\n \tif (iter) {\n \t\tclass_dev_iter_exit(iter);\n \t\tkfree(iter);\n \t}\n }\n", "target": 1, "idx": 180098}
{"func": "static u8 vhost_scsi_get_fabric_proto_ident(struct se_portal_group *se_tpg)\n{\n\tstruct vhost_scsi_tpg *tpg = container_of(se_tpg,\n\t\t\t\tstruct vhost_scsi_tpg, se_tpg);\n\tstruct vhost_scsi_tport *tport = tpg->tport;\n\n\tswitch (tport->tport_proto_id) {\n\tcase SCSI_PROTOCOL_SAS:\n\t\treturn sas_get_fabric_proto_ident(se_tpg);\n\tcase SCSI_PROTOCOL_FCP:\n\t\treturn fc_get_fabric_proto_ident(se_tpg);\n\tcase SCSI_PROTOCOL_ISCSI:\n\t\treturn iscsi_get_fabric_proto_ident(se_tpg);\n\tdefault:\n\t\tpr_err(\"Unknown tport_proto_id: 0x%02x, using\"\n\t\t\t\" SAS emulation\\n\", tport->tport_proto_id);\n\t\tbreak;\n\t}\n\n\treturn sas_get_fabric_proto_ident(se_tpg);\n}\n", "target": 0, "idx": 43097}
{"func": "int dns_packet_is_reply_for(DnsPacket *p, const DnsResourceKey *key) {\n        int r;\n\n        assert(p);\n        assert(key);\n\n        /* Checks if the specified packet is a reply for the specified\n         * key and the specified key is the only one in the question\n         * section. */\n\n        if (DNS_PACKET_QR(p) != 1)\n                return 0;\n\n        /* Let's unpack the packet, if that hasn't happened yet. */\n        r = dns_packet_extract(p);\n         if (r < 0)\n                 return r;\n \n         if (p->question->n_keys != 1)\n                 return 0;\n \n        return dns_resource_key_equal(p->question->keys[0], key);\n}\n", "target": 1, "idx": 181283}
{"func": "ZEND_API int zend_declare_property_double(zend_class_entry *ce, const char *name, int name_length, double value, int access_type TSRMLS_DC) /* {{{ */\n{\n\tzval *property;\n\n\tif (ce->type & ZEND_INTERNAL_CLASS) {\n\t\tALLOC_PERMANENT_ZVAL(property);\n\t} else {\n\t\tALLOC_ZVAL(property);\n\t}\n\tINIT_PZVAL(property);\n\tZVAL_DOUBLE(property, value);\n\treturn zend_declare_property(ce, name, name_length, property, access_type TSRMLS_CC);\n}\n/* }}} */\n", "target": 0, "idx": 13782}
{"func": "void __init proc_caches_init(void)\n{\n\tsighand_cachep = kmem_cache_create(\"sighand_cache\",\n\t\t\tsizeof(struct sighand_struct), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_DESTROY_BY_RCU|\n\t\t\tSLAB_NOTRACK, sighand_ctor);\n\tsignal_cachep = kmem_cache_create(\"signal_cache\",\n\t\t\tsizeof(struct signal_struct), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_NOTRACK, NULL);\n\tfiles_cachep = kmem_cache_create(\"files_cache\",\n\t\t\tsizeof(struct files_struct), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_NOTRACK, NULL);\n\tfs_cachep = kmem_cache_create(\"fs_cache\",\n\t\t\tsizeof(struct fs_struct), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_NOTRACK, NULL);\n\tmm_cachep = kmem_cache_create(\"mm_struct\",\n\t\t\tsizeof(struct mm_struct), ARCH_MIN_MMSTRUCT_ALIGN,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_NOTRACK, NULL);\n\tvm_area_cachep = KMEM_CACHE(vm_area_struct, SLAB_PANIC);\n\tmmap_init();\n}\n", "target": 0, "idx": 22279}
{"func": "void mon_st_callback(stonith_t *st, stonith_event_t *e)\n{\n    char *desc = g_strdup_printf(\n        \"Operation %s requested by %s for peer %s: %s (ref=%s)\",\n        e->operation, e->origin, e->target, pcmk_strerror(e->result), e->id); \n\n    if (snmp_target) {\n        send_snmp_trap(e->target, NULL, e->operation, pcmk_ok, e->result, 0, desc);\n    }\n    if (crm_mail_to) {\n        send_smtp_trap(e->target, NULL, e->operation, pcmk_ok, e->result, 0, desc);\n    }\n    if (external_agent) {\n        send_custom_trap(e->target, NULL, e->operation, pcmk_ok, e->result, 0, desc);\n    }\n    g_free(desc);\n}\n", "target": 0, "idx": 33943}
{"func": "LayoutUnit RenderFlexibleBox::crossAxisExtentForChild(RenderBox* child) const\n{\n    return isHorizontalFlow() ? child->height() : child->width();\n}\n", "target": 0, "idx": 125001}
{"func": "void GLSurfaceOzoneSurfacelessSurfaceImpl::Destroy() {\n  if (!context_)\n    return;\n  scoped_refptr<gfx::GLContext> previous_context = gfx::GLContext::GetCurrent();\n  scoped_refptr<gfx::GLSurface> previous_surface;\n\n  bool was_current = previous_context && previous_context->IsCurrent(nullptr) &&\n                     gfx::GLSurface::GetCurrent() == this;\n  if (!was_current) {\n    previous_surface = gfx::GLSurface::GetCurrent();\n    context_->MakeCurrent(this);\n  }\n\n  glBindFramebufferEXT(GL_FRAMEBUFFER, 0);\n  if (fbo_) {\n    glDeleteTextures(arraysize(textures_), textures_);\n    for (auto& texture : textures_)\n      texture = 0;\n    glDeleteFramebuffersEXT(1, &fbo_);\n    fbo_ = 0;\n  }\n  for (auto image : images_) {\n    if (image)\n      image->Destroy(true);\n   }\n \n   if (!was_current) {\n    previous_context->MakeCurrent(previous_surface.get());\n  } else {\n    context_->ReleaseCurrent(this);\n   }\n }\n", "target": 1, "idx": 185352}
{"func": "static struct sock *dccp_v6_request_recv_sock(const struct sock *sk,\n\t\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t\t      struct request_sock *req,\n\t\t\t\t\t      struct dst_entry *dst,\n\t\t\t\t\t      struct request_sock *req_unhash,\n\t\t\t\t\t      bool *own_req)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\tstruct ipv6_pinfo *newnp;\n\tconst struct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct ipv6_txoptions *opt;\n\tstruct inet_sock *newinet;\n\tstruct dccp6_sock *newdp6;\n\tstruct sock *newsk;\n\n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\t/*\n\t\t *\tv6 mapped\n\t\t */\n\t\tnewsk = dccp_v4_request_recv_sock(sk, skb, req, dst,\n\t\t\t\t\t\t  req_unhash, own_req);\n\t\tif (newsk == NULL)\n\t\t\treturn NULL;\n\n\t\tnewdp6 = (struct dccp6_sock *)newsk;\n\t\tnewinet = inet_sk(newsk);\n\t\tnewinet->pinet6 = &newdp6->inet6;\n\t\tnewnp = inet6_sk(newsk);\n\n\t\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\t\tnewnp->saddr = newsk->sk_v6_rcv_saddr;\n\n\t\tinet_csk(newsk)->icsk_af_ops = &dccp_ipv6_mapped;\n \t\tnewsk->sk_backlog_rcv = dccp_v4_do_rcv;\n \t\tnewnp->pktoptions  = NULL;\n \t\tnewnp->opt\t   = NULL;\n \t\tnewnp->mcast_oif   = inet6_iif(skb);\n \t\tnewnp->mcast_hops  = ipv6_hdr(skb)->hop_limit;\n \n\t\t/*\n\t\t * No need to charge this sock to the relevant IPv6 refcnt debug socks count\n\t\t * here, dccp_create_openreq_child now does this for us, see the comment in\n\t\t * that function for the gory details. -acme\n\t\t */\n\n\t\t/* It is tricky place. Until this moment IPv4 tcp\n\t\t   worked with IPv6 icsk.icsk_af_ops.\n\t\t   Sync it now.\n\t\t */\n\t\tdccp_sync_mss(newsk, inet_csk(newsk)->icsk_pmtu_cookie);\n\n\t\treturn newsk;\n\t}\n\n\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto out_overflow;\n\n\tif (!dst) {\n\t\tstruct flowi6 fl6;\n\n\t\tdst = inet6_csk_route_req(sk, &fl6, req, IPPROTO_DCCP);\n\t\tif (!dst)\n\t\t\tgoto out;\n\t}\n\n\tnewsk = dccp_create_openreq_child(sk, req, skb);\n\tif (newsk == NULL)\n\t\tgoto out_nonewsk;\n\n\t/*\n\t * No need to charge this sock to the relevant IPv6 refcnt debug socks\n\t * count here, dccp_create_openreq_child now does this for us, see the\n\t * comment in that function for the gory details. -acme\n\t */\n\n\tip6_dst_store(newsk, dst, NULL, NULL);\n\tnewsk->sk_route_caps = dst->dev->features & ~(NETIF_F_IP_CSUM |\n\t\t\t\t\t\t      NETIF_F_TSO);\n\tnewdp6 = (struct dccp6_sock *)newsk;\n\tnewinet = inet_sk(newsk);\n\tnewinet->pinet6 = &newdp6->inet6;\n\tnewnp = inet6_sk(newsk);\n\n\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\tnewsk->sk_v6_daddr\t= ireq->ir_v6_rmt_addr;\n\tnewnp->saddr\t\t= ireq->ir_v6_loc_addr;\n\tnewsk->sk_v6_rcv_saddr\t= ireq->ir_v6_loc_addr;\n\tnewsk->sk_bound_dev_if\t= ireq->ir_iif;\n\n\t/* Now IPv6 options...\n\n\t   First: no IPv4 options.\n\t */\n\tnewinet->inet_opt = NULL;\n\n \t/* Clone RX bits */\n \tnewnp->rxopt.all = np->rxopt.all;\n \n \tnewnp->pktoptions = NULL;\n \tnewnp->opt\t  = NULL;\n \tnewnp->mcast_oif  = inet6_iif(skb);\n\tnewnp->mcast_hops = ipv6_hdr(skb)->hop_limit;\n\n\t/*\n\t * Clone native IPv6 options from listening socket (if any)\n\t *\n\t * Yes, keeping reference count would be much more clever, but we make\n\t * one more one thing there: reattach optmem to newsk.\n\t */\n\topt = ireq->ipv6_opt;\n\tif (!opt)\n\t\topt = rcu_dereference(np->opt);\n\tif (opt) {\n\t\topt = ipv6_dup_options(newsk, opt);\n\t\tRCU_INIT_POINTER(newnp->opt, opt);\n\t}\n\tinet_csk(newsk)->icsk_ext_hdr_len = 0;\n\tif (opt)\n\t\tinet_csk(newsk)->icsk_ext_hdr_len = opt->opt_nflen +\n\t\t\t\t\t\t    opt->opt_flen;\n\n\tdccp_sync_mss(newsk, dst_mtu(dst));\n\n\tnewinet->inet_daddr = newinet->inet_saddr = LOOPBACK4_IPV6;\n\tnewinet->inet_rcv_saddr = LOOPBACK4_IPV6;\n\n\tif (__inet_inherit_port(sk, newsk) < 0) {\n\t\tinet_csk_prepare_forced_close(newsk);\n\t\tdccp_done(newsk);\n\t\tgoto out;\n\t}\n\t*own_req = inet_ehash_nolisten(newsk, req_to_sk(req_unhash));\n\t/* Clone pktoptions received with SYN, if we own the req */\n\tif (*own_req && ireq->pktopts) {\n\t\tnewnp->pktoptions = skb_clone(ireq->pktopts, GFP_ATOMIC);\n\t\tconsume_skb(ireq->pktopts);\n\t\tireq->pktopts = NULL;\n\t\tif (newnp->pktoptions)\n\t\t\tskb_set_owner_r(newnp->pktoptions, newsk);\n\t}\n\n\treturn newsk;\n\nout_overflow:\n\t__NET_INC_STATS(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nout_nonewsk:\n\tdst_release(dst);\nout:\n\t__NET_INC_STATS(sock_net(sk), LINUX_MIB_LISTENDROPS);\n\treturn NULL;\n}\n", "target": 1, "idx": 181299}
{"func": "static void srpt_cm_rep_error(struct ib_cm_id *cm_id)\n{\n\tpr_info(\"Received IB REP error for cm_id %p.\\n\", cm_id);\n\tsrpt_drain_channel(cm_id);\n}\n", "target": 0, "idx": 50641}
{"func": "void GetIntersection (uint64 start1, uint32 length1, uint64 start2, uint64 end2, uint64 *intersectStart, uint32 *intersectLength)\n{\n\tuint64 end1 = start1 + length1 - 1;\n\tuint64 intersectEnd = (end1 <= end2) ? end1 : end2;\n\n\t*intersectStart = (start1 >= start2) ? start1 : start2;\n\t*intersectLength = (uint32) ((*intersectStart > intersectEnd) ? 0 : intersectEnd + 1 - *intersectStart);\n\n\tif (*intersectLength == 0)\n\t\t*intersectStart = start1;\n}\n", "target": 0, "idx": 87176}
{"func": " tiffcp(TIFF* in, TIFF* out)\n {\n\tuint16 bitspersample, samplesperpixel = 1;\n \tuint16 input_compression, input_photometric = PHOTOMETRIC_MINISBLACK;\n \tcopyFunc cf;\n \tuint32 width, length;\n\tstruct cpTag* p;\n\n\tCopyField(TIFFTAG_IMAGEWIDTH, width);\n\tCopyField(TIFFTAG_IMAGELENGTH, length);\n\tCopyField(TIFFTAG_BITSPERSAMPLE, bitspersample);\n\tCopyField(TIFFTAG_SAMPLESPERPIXEL, samplesperpixel);\n\tif (compression != (uint16)-1)\n\t\tTIFFSetField(out, TIFFTAG_COMPRESSION, compression);\n\telse\n\t\tCopyField(TIFFTAG_COMPRESSION, compression);\n\tTIFFGetFieldDefaulted(in, TIFFTAG_COMPRESSION, &input_compression);\n\tTIFFGetFieldDefaulted(in, TIFFTAG_PHOTOMETRIC, &input_photometric);\n\tif (input_compression == COMPRESSION_JPEG) {\n\t\t/* Force conversion to RGB */\n\t\tTIFFSetField(in, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n\t} else if (input_photometric == PHOTOMETRIC_YCBCR) {\n\t\t/* Otherwise, can't handle subsampled input */\n\t\tuint16 subsamplinghor,subsamplingver;\n\n\t\tTIFFGetFieldDefaulted(in, TIFFTAG_YCBCRSUBSAMPLING,\n\t\t\t\t      &subsamplinghor, &subsamplingver);\n\t\tif (subsamplinghor!=1 || subsamplingver!=1) {\n\t\t\tfprintf(stderr, \"tiffcp: %s: Can't copy/convert subsampled image.\\n\",\n\t\t\t\tTIFFFileName(in));\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\tif (compression == COMPRESSION_JPEG) {\n\t\tif (input_photometric == PHOTOMETRIC_RGB &&\n\t\t    jpegcolormode == JPEGCOLORMODE_RGB)\n\t\t  TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);\n\t\telse\n\t\t  TIFFSetField(out, TIFFTAG_PHOTOMETRIC, input_photometric);\n\t}\n\telse if (compression == COMPRESSION_SGILOG\n\t    || compression == COMPRESSION_SGILOG24)\n\t\tTIFFSetField(out, TIFFTAG_PHOTOMETRIC,\n\t\t    samplesperpixel == 1 ?\n\t\t    PHOTOMETRIC_LOGL : PHOTOMETRIC_LOGLUV);\n\telse if (input_compression == COMPRESSION_JPEG &&\n\t\t\t samplesperpixel == 3 ) {\n\t\t/* RGB conversion was forced above\n\t\thence the output will be of the same type */\n\t\tTIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n\t}\n\telse\n\t\tCopyTag(TIFFTAG_PHOTOMETRIC, 1, TIFF_SHORT);\n\tif (fillorder != 0)\n\t\tTIFFSetField(out, TIFFTAG_FILLORDER, fillorder);\n\telse\n\t\tCopyTag(TIFFTAG_FILLORDER, 1, TIFF_SHORT);\n\t/*\n\t * Will copy `Orientation' tag from input image\n\t */\n\tTIFFGetFieldDefaulted(in, TIFFTAG_ORIENTATION, &orientation);\n\tswitch (orientation) {\n\t\tcase ORIENTATION_BOTRIGHT:\n\t\tcase ORIENTATION_RIGHTBOT:\t/* XXX */\n\t\t\tTIFFWarning(TIFFFileName(in), \"using bottom-left orientation\");\n\t\t\torientation = ORIENTATION_BOTLEFT;\n\t\t/* fall thru... */\n\t\tcase ORIENTATION_LEFTBOT:\t/* XXX */\n\t\tcase ORIENTATION_BOTLEFT:\n\t\t\tbreak;\n\t\tcase ORIENTATION_TOPRIGHT:\n\t\tcase ORIENTATION_RIGHTTOP:\t/* XXX */\n\t\tdefault:\n\t\t\tTIFFWarning(TIFFFileName(in), \"using top-left orientation\");\n\t\t\torientation = ORIENTATION_TOPLEFT;\n\t\t/* fall thru... */\n\t\tcase ORIENTATION_LEFTTOP:\t/* XXX */\n\t\tcase ORIENTATION_TOPLEFT:\n\t\t\tbreak;\n\t}\n\tTIFFSetField(out, TIFFTAG_ORIENTATION, orientation);\n\t/*\n\t * Choose tiles/strip for the output image according to\n\t * the command line arguments (-tiles, -strips) and the\n\t * structure of the input image.\n\t */\n\tif (outtiled == -1)\n\t\touttiled = TIFFIsTiled(in);\n\tif (outtiled) {\n\t\t/*\n\t\t * Setup output file's tile width&height.  If either\n\t\t * is not specified, use either the value from the\n\t\t * input image or, if nothing is defined, use the\n\t\t * library default.\n\t\t */\n\t\tif (tilewidth == (uint32) -1)\n\t\t\tTIFFGetField(in, TIFFTAG_TILEWIDTH, &tilewidth);\n\t\tif (tilelength == (uint32) -1)\n\t\t\tTIFFGetField(in, TIFFTAG_TILELENGTH, &tilelength);\n\t\tTIFFDefaultTileSize(out, &tilewidth, &tilelength);\n\t\tTIFFSetField(out, TIFFTAG_TILEWIDTH, tilewidth);\n\t\tTIFFSetField(out, TIFFTAG_TILELENGTH, tilelength);\n\t} else {\n\t\t/*\n\t\t * RowsPerStrip is left unspecified: use either the\n\t\t * value from the input image or, if nothing is defined,\n\t\t * use the library default.\n\t\t */\n\t\tif (rowsperstrip == (uint32) 0) {\n\t\t\tif (!TIFFGetField(in, TIFFTAG_ROWSPERSTRIP,\n\t\t\t    &rowsperstrip)) {\n\t\t\t\trowsperstrip =\n\t\t\t\t    TIFFDefaultStripSize(out, rowsperstrip);\n\t\t\t}\n\t\t\tif (rowsperstrip > length && rowsperstrip != (uint32)-1)\n\t\t\t\trowsperstrip = length;\n\t\t}\n\t\telse if (rowsperstrip == (uint32) -1)\n\t\t\trowsperstrip = length;\n\t\tTIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\n\t}\n\tif (config != (uint16) -1)\n\t\tTIFFSetField(out, TIFFTAG_PLANARCONFIG, config);\n\telse\n\t\tCopyField(TIFFTAG_PLANARCONFIG, config);\n\tif (samplesperpixel <= 4)\n\t\tCopyTag(TIFFTAG_TRANSFERFUNCTION, 4, TIFF_SHORT);\n\tCopyTag(TIFFTAG_COLORMAP, 4, TIFF_SHORT);\n/* SMinSampleValue & SMaxSampleValue */\n\tswitch (compression) {\n\t\tcase COMPRESSION_JPEG:\n\t\t\tTIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);\n\t\t\tTIFFSetField(out, TIFFTAG_JPEGCOLORMODE, jpegcolormode);\n\t\t\tbreak;\n\t\tcase COMPRESSION_JBIG:\n\t\t\tCopyTag(TIFFTAG_FAXRECVPARAMS, 1, TIFF_LONG);\n\t\t\tCopyTag(TIFFTAG_FAXRECVTIME, 1, TIFF_LONG);\n\t\t\tCopyTag(TIFFTAG_FAXSUBADDRESS, 1, TIFF_ASCII);\n\t\t\tCopyTag(TIFFTAG_FAXDCS, 1, TIFF_ASCII);\n\t\t\tbreak;\n\t\tcase COMPRESSION_LZW:\n\t\tcase COMPRESSION_ADOBE_DEFLATE:\n\t\tcase COMPRESSION_DEFLATE:\n                case COMPRESSION_LZMA:\n\t\t\tif (predictor != (uint16)-1)\n\t\t\t\tTIFFSetField(out, TIFFTAG_PREDICTOR, predictor);\n\t\t\telse\n\t\t\t\tCopyField(TIFFTAG_PREDICTOR, predictor);\n\t\t\tif (preset != -1) {\n                                if (compression == COMPRESSION_ADOBE_DEFLATE\n                                         || compression == COMPRESSION_DEFLATE)\n                                        TIFFSetField(out, TIFFTAG_ZIPQUALITY, preset);\n\t\t\t\telse if (compression == COMPRESSION_LZMA)\n\t\t\t\t\tTIFFSetField(out, TIFFTAG_LZMAPRESET, preset);\n                        }\n\t\t\tbreak;\n\t\tcase COMPRESSION_CCITTFAX3:\n\t\tcase COMPRESSION_CCITTFAX4:\n\t\t\tif (compression == COMPRESSION_CCITTFAX3) {\n\t\t\t\tif (g3opts != (uint32) -1)\n\t\t\t\t\tTIFFSetField(out, TIFFTAG_GROUP3OPTIONS,\n\t\t\t\t\t    g3opts);\n\t\t\t\telse\n\t\t\t\t\tCopyField(TIFFTAG_GROUP3OPTIONS, g3opts);\n\t\t\t} else\n\t\t\t\tCopyTag(TIFFTAG_GROUP4OPTIONS, 1, TIFF_LONG);\n\t\t\tCopyTag(TIFFTAG_BADFAXLINES, 1, TIFF_LONG);\n\t\t\tCopyTag(TIFFTAG_CLEANFAXDATA, 1, TIFF_LONG);\n\t\t\tCopyTag(TIFFTAG_CONSECUTIVEBADFAXLINES, 1, TIFF_LONG);\n\t\t\tCopyTag(TIFFTAG_FAXRECVPARAMS, 1, TIFF_LONG);\n\t\t\tCopyTag(TIFFTAG_FAXRECVTIME, 1, TIFF_LONG);\n\t\t\tCopyTag(TIFFTAG_FAXSUBADDRESS, 1, TIFF_ASCII);\n\t\t\tbreak;\n\t}\n\t{\n\t\tuint32 len32;\n\t\tvoid** data;\n\t\tif (TIFFGetField(in, TIFFTAG_ICCPROFILE, &len32, &data))\n\t\t\tTIFFSetField(out, TIFFTAG_ICCPROFILE, len32, data);\n\t}\n\t{\n\t\tuint16 ninks;\n\t\tconst char* inknames;\n\t\tif (TIFFGetField(in, TIFFTAG_NUMBEROFINKS, &ninks)) {\n\t\t\tTIFFSetField(out, TIFFTAG_NUMBEROFINKS, ninks);\n\t\t\tif (TIFFGetField(in, TIFFTAG_INKNAMES, &inknames)) {\n\t\t\t\tint inknameslen = strlen(inknames) + 1;\n\t\t\t\tconst char* cp = inknames;\n\t\t\t\twhile (ninks > 1) {\n\t\t\t\t\tcp = strchr(cp, '\\0');\n                                        cp++;\n                                        inknameslen += (strlen(cp) + 1);\n\t\t\t\t\tninks--;\n\t\t\t\t}\n\t\t\t\tTIFFSetField(out, TIFFTAG_INKNAMES, inknameslen, inknames);\n\t\t\t}\n\t\t}\n\t}\n\t{\n\t\tunsigned short pg0, pg1;\n\n\t\tif (pageInSeq == 1) {\n\t\t\tif (pageNum < 0) /* only one input file */ {\n\t\t\t\tif (TIFFGetField(in, TIFFTAG_PAGENUMBER, &pg0, &pg1))\n\t\t\t\t\tTIFFSetField(out, TIFFTAG_PAGENUMBER, pg0, pg1);\n\t\t\t} else\n\t\t\t\tTIFFSetField(out, TIFFTAG_PAGENUMBER, pageNum++, 0);\n\n\t\t} else {\n\t\t\tif (TIFFGetField(in, TIFFTAG_PAGENUMBER, &pg0, &pg1)) {\n\t\t\t\tif (pageNum < 0) /* only one input file */\n\t\t\t\t\tTIFFSetField(out, TIFFTAG_PAGENUMBER, pg0, pg1);\n\t\t\t\telse\n\t\t\t\t\tTIFFSetField(out, TIFFTAG_PAGENUMBER, pageNum++, 0);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (p = tags; p < &tags[NTAGS]; p++)\n\t\tCopyTag(p->tag, p->count, p->type);\n\n\tcf = pickCopyFunc(in, out, bitspersample, samplesperpixel);\n\treturn (cf ? (*cf)(in, out, length, width, samplesperpixel) : FALSE);\n}\n", "target": 1, "idx": 181587}
{"func": "void WebPage::loadString(const BlackBerry::Platform::String& string, const BlackBerry::Platform::String& baseURL, const BlackBerry::Platform::String& mimeType, const BlackBerry::Platform::String& failingURL)\n{\n    d->loadString(string, baseURL, mimeType, failingURL);\n}\n", "target": 0, "idx": 111206}
{"func": "static int do_ipv6_setsockopt(struct sock *sk, int level, int optname,\n\t\t    char __user *optval, unsigned int optlen)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct net *net = sock_net(sk);\n\tint val, valbool;\n\tint retv = -ENOPROTOOPT;\n\tbool needs_rtnl = setsockopt_needs_rtnl(optname);\n\n\tif (!optval)\n\t\tval = 0;\n\telse {\n\t\tif (optlen >= sizeof(int)) {\n\t\t\tif (get_user(val, (int __user *) optval))\n\t\t\t\treturn -EFAULT;\n\t\t} else\n\t\t\tval = 0;\n\t}\n\n\tvalbool = (val != 0);\n\n\tif (ip6_mroute_opt(optname))\n\t\treturn ip6_mroute_setsockopt(sk, optname, optval, optlen);\n\n\tif (needs_rtnl)\n\t\trtnl_lock();\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\n\tcase IPV6_ADDRFORM:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val == PF_INET) {\n\t\t\tstruct ipv6_txoptions *opt;\n\t\t\tstruct sk_buff *pktopt;\n\n\t\t\tif (sk->sk_type == SOCK_RAW)\n\t\t\t\tbreak;\n\n\t\t\tif (sk->sk_protocol == IPPROTO_UDP ||\n\t\t\t    sk->sk_protocol == IPPROTO_UDPLITE) {\n\t\t\t\tstruct udp_sock *up = udp_sk(sk);\n\t\t\t\tif (up->pending == AF_INET6) {\n\t\t\t\t\tretv = -EBUSY;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (sk->sk_protocol != IPPROTO_TCP)\n\t\t\t\tbreak;\n\n\t\t\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\t\t\tretv = -ENOTCONN;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (ipv6_only_sock(sk) ||\n\t\t\t    !ipv6_addr_v4mapped(&sk->sk_v6_daddr)) {\n\t\t\t\tretv = -EADDRNOTAVAIL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfl6_free_socklist(sk);\n\t\t\tipv6_sock_mc_close(sk);\n\n\t\t\t/*\n\t\t\t * Sock is moving from IPv6 to IPv4 (sk_prot), so\n\t\t\t * remove it from the refcnt debug socks count in the\n\t\t\t * original family...\n\t\t\t */\n\t\t\tsk_refcnt_debug_dec(sk);\n\n\t\t\tif (sk->sk_protocol == IPPROTO_TCP) {\n\t\t\t\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\t\t\t\tlocal_bh_disable();\n\t\t\t\tsock_prot_inuse_add(net, sk->sk_prot, -1);\n\t\t\t\tsock_prot_inuse_add(net, &tcp_prot, 1);\n\t\t\t\tlocal_bh_enable();\n\t\t\t\tsk->sk_prot = &tcp_prot;\n\t\t\t\ticsk->icsk_af_ops = &ipv4_specific;\n\t\t\t\tsk->sk_socket->ops = &inet_stream_ops;\n\t\t\t\tsk->sk_family = PF_INET;\n\t\t\t\ttcp_sync_mss(sk, icsk->icsk_pmtu_cookie);\n\t\t\t} else {\n\t\t\t\tstruct proto *prot = &udp_prot;\n\n\t\t\t\tif (sk->sk_protocol == IPPROTO_UDPLITE)\n\t\t\t\t\tprot = &udplite_prot;\n\t\t\t\tlocal_bh_disable();\n\t\t\t\tsock_prot_inuse_add(net, sk->sk_prot, -1);\n\t\t\t\tsock_prot_inuse_add(net, prot, 1);\n\t\t\t\tlocal_bh_enable();\n\t\t\t\tsk->sk_prot = prot;\n \t\t\t\tsk->sk_socket->ops = &inet_dgram_ops;\n \t\t\t\tsk->sk_family = PF_INET;\n \t\t\t}\n\t\t\topt = xchg(&np->opt, NULL);\n\t\t\tif (opt)\n\t\t\t\tsock_kfree_s(sk, opt, opt->tot_len);\n \t\t\tpktopt = xchg(&np->pktoptions, NULL);\n \t\t\tkfree_skb(pktopt);\n \n\t\t\tsk->sk_destruct = inet_sock_destruct;\n\t\t\t/*\n\t\t\t * ... and add it to the refcnt debug socks count\n\t\t\t * in the new family. -acme\n\t\t\t */\n\t\t\tsk_refcnt_debug_inc(sk);\n\t\t\tmodule_put(THIS_MODULE);\n\t\t\tretv = 0;\n\t\t\tbreak;\n\t\t}\n\t\tgoto e_inval;\n\n\tcase IPV6_V6ONLY:\n\t\tif (optlen < sizeof(int) ||\n\t\t    inet_sk(sk)->inet_num)\n\t\t\tgoto e_inval;\n\t\tsk->sk_ipv6only = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_RECVPKTINFO:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.rxinfo = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_2292PKTINFO:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.rxoinfo = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_RECVHOPLIMIT:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.rxhlim = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_2292HOPLIMIT:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.rxohlim = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_RECVRTHDR:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.srcrt = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_2292RTHDR:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.osrcrt = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_RECVHOPOPTS:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.hopopts = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_2292HOPOPTS:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.ohopopts = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_RECVDSTOPTS:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.dstopts = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_2292DSTOPTS:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.odstopts = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_TCLASS:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val < -1 || val > 0xff)\n\t\t\tgoto e_inval;\n\t\t/* RFC 3542, 6.5: default traffic class of 0x0 */\n\t\tif (val == -1)\n\t\t\tval = 0;\n\t\tnp->tclass = val;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_RECVTCLASS:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.rxtclass = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_FLOWINFO:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.rxflow = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_RECVPATHMTU:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.rxpmtu = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_TRANSPARENT:\n\t\tif (valbool && !ns_capable(net->user_ns, CAP_NET_ADMIN) &&\n\t\t    !ns_capable(net->user_ns, CAP_NET_RAW)) {\n\t\t\tretv = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\t/* we don't have a separate transparent bit for IPV6 we use the one in the IPv4 socket */\n\t\tinet_sk(sk)->transparent = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_RECVORIGDSTADDR:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.rxorigdstaddr = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_HOPOPTS:\n\tcase IPV6_RTHDRDSTOPTS:\n\tcase IPV6_RTHDR:\n\tcase IPV6_DSTOPTS:\n\t{\n\t\tstruct ipv6_txoptions *opt;\n\n\t\t/* remove any sticky options header with a zero option\n\t\t * length, per RFC3542.\n\t\t */\n\t\tif (optlen == 0)\n\t\t\toptval = NULL;\n\t\telse if (!optval)\n\t\t\tgoto e_inval;\n\t\telse if (optlen < sizeof(struct ipv6_opt_hdr) ||\n\t\t\t optlen & 0x7 || optlen > 8 * 255)\n\t\t\tgoto e_inval;\n\n\t\t/* hop-by-hop / destination options are privileged option */\n\t\tretv = -EPERM;\n \t\tif (optname != IPV6_RTHDR && !ns_capable(net->user_ns, CAP_NET_RAW))\n \t\t\tbreak;\n \n\t\topt = ipv6_renew_options(sk, np->opt, optname,\n \t\t\t\t\t (struct ipv6_opt_hdr __user *)optval,\n \t\t\t\t\t optlen);\n \t\tif (IS_ERR(opt)) {\n\t\t\tretv = PTR_ERR(opt);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* routing header option needs extra check */\n\t\tretv = -EINVAL;\n\t\tif (optname == IPV6_RTHDR && opt && opt->srcrt) {\n\t\t\tstruct ipv6_rt_hdr *rthdr = opt->srcrt;\n\t\t\tswitch (rthdr->type) {\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\t\t\tcase IPV6_SRCRT_TYPE_2:\n\t\t\t\tif (rthdr->hdrlen != 2 ||\n\t\t\t\t    rthdr->segments_left != 1)\n\t\t\t\t\tgoto sticky_done;\n\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tgoto sticky_done;\n\t\t\t}\n\t\t}\n\n \t\tretv = 0;\n \t\topt = ipv6_update_options(sk, opt);\n sticky_done:\n\t\tif (opt)\n\t\t\tsock_kfree_s(sk, opt, opt->tot_len);\n \t\tbreak;\n \t}\n \n\tcase IPV6_PKTINFO:\n\t{\n\t\tstruct in6_pktinfo pkt;\n\n\t\tif (optlen == 0)\n\t\t\tgoto e_inval;\n\t\telse if (optlen < sizeof(struct in6_pktinfo) || !optval)\n\t\t\tgoto e_inval;\n\n\t\tif (copy_from_user(&pkt, optval, sizeof(struct in6_pktinfo))) {\n\t\t\t\tretv = -EFAULT;\n\t\t\t\tbreak;\n\t\t}\n\t\tif (sk->sk_bound_dev_if && pkt.ipi6_ifindex != sk->sk_bound_dev_if)\n\t\t\tgoto e_inval;\n\n\t\tnp->sticky_pktinfo.ipi6_ifindex = pkt.ipi6_ifindex;\n\t\tnp->sticky_pktinfo.ipi6_addr = pkt.ipi6_addr;\n\t\tretv = 0;\n\t\tbreak;\n\t}\n\n\tcase IPV6_2292PKTOPTIONS:\n\t{\n\t\tstruct ipv6_txoptions *opt = NULL;\n\t\tstruct msghdr msg;\n\t\tstruct flowi6 fl6;\n\t\tint junk;\n\n\t\tmemset(&fl6, 0, sizeof(fl6));\n\t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\t\tfl6.flowi6_mark = sk->sk_mark;\n\n\t\tif (optlen == 0)\n\t\t\tgoto update;\n\n\t\t/* 1K is probably excessive\n\t\t * 1K is surely not enough, 2K per standard header is 16K.\n\t\t */\n\t\tretv = -EINVAL;\n\t\tif (optlen > 64*1024)\n\t\t\tbreak;\n\n\t\topt = sock_kmalloc(sk, sizeof(*opt) + optlen, GFP_KERNEL);\n\t\tretv = -ENOBUFS;\n\t\tif (!opt)\n \t\t\tbreak;\n \n \t\tmemset(opt, 0, sizeof(*opt));\n \t\topt->tot_len = sizeof(*opt) + optlen;\n \t\tretv = -EFAULT;\n \t\tif (copy_from_user(opt+1, optval, optlen))\n\t\t\tgoto done;\n\n\t\tmsg.msg_controllen = optlen;\n\t\tmsg.msg_control = (void *)(opt+1);\n\n\t\tretv = ip6_datagram_send_ctl(net, sk, &msg, &fl6, opt, &junk,\n\t\t\t\t\t     &junk, &junk);\n\t\tif (retv)\n\t\t\tgoto done;\nupdate:\n \t\tretv = 0;\n \t\topt = ipv6_update_options(sk, opt);\n done:\n\t\tif (opt)\n\t\t\tsock_kfree_s(sk, opt, opt->tot_len);\n \t\tbreak;\n \t}\n \tcase IPV6_UNICAST_HOPS:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val > 255 || val < -1)\n\t\t\tgoto e_inval;\n\t\tnp->hop_limit = val;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_MULTICAST_HOPS:\n\t\tif (sk->sk_type == SOCK_STREAM)\n\t\t\tbreak;\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val > 255 || val < -1)\n\t\t\tgoto e_inval;\n\t\tnp->mcast_hops = (val == -1 ? IPV6_DEFAULT_MCASTHOPS : val);\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_MULTICAST_LOOP:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val != valbool)\n\t\t\tgoto e_inval;\n\t\tnp->mc_loop = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_UNICAST_IF:\n\t{\n\t\tstruct net_device *dev = NULL;\n\t\tint ifindex;\n\n\t\tif (optlen != sizeof(int))\n\t\t\tgoto e_inval;\n\n\t\tifindex = (__force int)ntohl((__force __be32)val);\n\t\tif (ifindex == 0) {\n\t\t\tnp->ucast_oif = 0;\n\t\t\tretv = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tdev = dev_get_by_index(net, ifindex);\n\t\tretv = -EADDRNOTAVAIL;\n\t\tif (!dev)\n\t\t\tbreak;\n\t\tdev_put(dev);\n\n\t\tretv = -EINVAL;\n\t\tif (sk->sk_bound_dev_if)\n\t\t\tbreak;\n\n\t\tnp->ucast_oif = ifindex;\n\t\tretv = 0;\n\t\tbreak;\n\t}\n\n\tcase IPV6_MULTICAST_IF:\n\t\tif (sk->sk_type == SOCK_STREAM)\n\t\t\tbreak;\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\n\t\tif (val) {\n\t\t\tstruct net_device *dev;\n\n\t\t\tif (sk->sk_bound_dev_if && sk->sk_bound_dev_if != val)\n\t\t\t\tgoto e_inval;\n\n\t\t\tdev = dev_get_by_index(net, val);\n\t\t\tif (!dev) {\n\t\t\t\tretv = -ENODEV;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdev_put(dev);\n\t\t}\n\t\tnp->mcast_oif = val;\n\t\tretv = 0;\n\t\tbreak;\n\tcase IPV6_ADD_MEMBERSHIP:\n\tcase IPV6_DROP_MEMBERSHIP:\n\t{\n\t\tstruct ipv6_mreq mreq;\n\n\t\tif (optlen < sizeof(struct ipv6_mreq))\n\t\t\tgoto e_inval;\n\n\t\tretv = -EPROTO;\n\t\tif (inet_sk(sk)->is_icsk)\n\t\t\tbreak;\n\n\t\tretv = -EFAULT;\n\t\tif (copy_from_user(&mreq, optval, sizeof(struct ipv6_mreq)))\n\t\t\tbreak;\n\n\t\tif (optname == IPV6_ADD_MEMBERSHIP)\n\t\t\tretv = ipv6_sock_mc_join(sk, mreq.ipv6mr_ifindex, &mreq.ipv6mr_multiaddr);\n\t\telse\n\t\t\tretv = ipv6_sock_mc_drop(sk, mreq.ipv6mr_ifindex, &mreq.ipv6mr_multiaddr);\n\t\tbreak;\n\t}\n\tcase IPV6_JOIN_ANYCAST:\n\tcase IPV6_LEAVE_ANYCAST:\n\t{\n\t\tstruct ipv6_mreq mreq;\n\n\t\tif (optlen < sizeof(struct ipv6_mreq))\n\t\t\tgoto e_inval;\n\n\t\tretv = -EFAULT;\n\t\tif (copy_from_user(&mreq, optval, sizeof(struct ipv6_mreq)))\n\t\t\tbreak;\n\n\t\tif (optname == IPV6_JOIN_ANYCAST)\n\t\t\tretv = ipv6_sock_ac_join(sk, mreq.ipv6mr_ifindex, &mreq.ipv6mr_acaddr);\n\t\telse\n\t\t\tretv = ipv6_sock_ac_drop(sk, mreq.ipv6mr_ifindex, &mreq.ipv6mr_acaddr);\n\t\tbreak;\n\t}\n\tcase MCAST_JOIN_GROUP:\n\tcase MCAST_LEAVE_GROUP:\n\t{\n\t\tstruct group_req greq;\n\t\tstruct sockaddr_in6 *psin6;\n\n\t\tif (optlen < sizeof(struct group_req))\n\t\t\tgoto e_inval;\n\n\t\tretv = -EFAULT;\n\t\tif (copy_from_user(&greq, optval, sizeof(struct group_req)))\n\t\t\tbreak;\n\t\tif (greq.gr_group.ss_family != AF_INET6) {\n\t\t\tretv = -EADDRNOTAVAIL;\n\t\t\tbreak;\n\t\t}\n\t\tpsin6 = (struct sockaddr_in6 *)&greq.gr_group;\n\t\tif (optname == MCAST_JOIN_GROUP)\n\t\t\tretv = ipv6_sock_mc_join(sk, greq.gr_interface,\n\t\t\t\t\t\t &psin6->sin6_addr);\n\t\telse\n\t\t\tretv = ipv6_sock_mc_drop(sk, greq.gr_interface,\n\t\t\t\t\t\t &psin6->sin6_addr);\n\t\tbreak;\n\t}\n\tcase MCAST_JOIN_SOURCE_GROUP:\n\tcase MCAST_LEAVE_SOURCE_GROUP:\n\tcase MCAST_BLOCK_SOURCE:\n\tcase MCAST_UNBLOCK_SOURCE:\n\t{\n\t\tstruct group_source_req greqs;\n\t\tint omode, add;\n\n\t\tif (optlen < sizeof(struct group_source_req))\n\t\t\tgoto e_inval;\n\t\tif (copy_from_user(&greqs, optval, sizeof(greqs))) {\n\t\t\tretv = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (greqs.gsr_group.ss_family != AF_INET6 ||\n\t\t    greqs.gsr_source.ss_family != AF_INET6) {\n\t\t\tretv = -EADDRNOTAVAIL;\n\t\t\tbreak;\n\t\t}\n\t\tif (optname == MCAST_BLOCK_SOURCE) {\n\t\t\tomode = MCAST_EXCLUDE;\n\t\t\tadd = 1;\n\t\t} else if (optname == MCAST_UNBLOCK_SOURCE) {\n\t\t\tomode = MCAST_EXCLUDE;\n\t\t\tadd = 0;\n\t\t} else if (optname == MCAST_JOIN_SOURCE_GROUP) {\n\t\t\tstruct sockaddr_in6 *psin6;\n\n\t\t\tpsin6 = (struct sockaddr_in6 *)&greqs.gsr_group;\n\t\t\tretv = ipv6_sock_mc_join(sk, greqs.gsr_interface,\n\t\t\t\t\t\t &psin6->sin6_addr);\n\t\t\t/* prior join w/ different source is ok */\n\t\t\tif (retv && retv != -EADDRINUSE)\n\t\t\t\tbreak;\n\t\t\tomode = MCAST_INCLUDE;\n\t\t\tadd = 1;\n\t\t} else /* MCAST_LEAVE_SOURCE_GROUP */ {\n\t\t\tomode = MCAST_INCLUDE;\n\t\t\tadd = 0;\n\t\t}\n\t\tretv = ip6_mc_source(add, omode, sk, &greqs);\n\t\tbreak;\n\t}\n\tcase MCAST_MSFILTER:\n\t{\n\t\tstruct group_filter *gsf;\n\n\t\tif (optlen < GROUP_FILTER_SIZE(0))\n\t\t\tgoto e_inval;\n\t\tif (optlen > sysctl_optmem_max) {\n\t\t\tretv = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\tgsf = kmalloc(optlen, GFP_KERNEL);\n\t\tif (!gsf) {\n\t\t\tretv = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\tretv = -EFAULT;\n\t\tif (copy_from_user(gsf, optval, optlen)) {\n\t\t\tkfree(gsf);\n\t\t\tbreak;\n\t\t}\n\t\t/* numsrc >= (4G-140)/128 overflow in 32 bits */\n\t\tif (gsf->gf_numsrc >= 0x1ffffffU ||\n\t\t    gsf->gf_numsrc > sysctl_mld_max_msf) {\n\t\t\tkfree(gsf);\n\t\t\tretv = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\tif (GROUP_FILTER_SIZE(gsf->gf_numsrc) > optlen) {\n\t\t\tkfree(gsf);\n\t\t\tretv = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tretv = ip6_mc_msfilter(sk, gsf);\n\t\tkfree(gsf);\n\n\t\tbreak;\n\t}\n\tcase IPV6_ROUTER_ALERT:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tretv = ip6_ra_control(sk, val);\n\t\tbreak;\n\tcase IPV6_MTU_DISCOVER:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val < IPV6_PMTUDISC_DONT || val > IPV6_PMTUDISC_OMIT)\n\t\t\tgoto e_inval;\n\t\tnp->pmtudisc = val;\n\t\tretv = 0;\n\t\tbreak;\n\tcase IPV6_MTU:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val && val < IPV6_MIN_MTU)\n\t\t\tgoto e_inval;\n\t\tnp->frag_size = val;\n\t\tretv = 0;\n\t\tbreak;\n\tcase IPV6_RECVERR:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->recverr = valbool;\n\t\tif (!val)\n\t\t\tskb_queue_purge(&sk->sk_error_queue);\n\t\tretv = 0;\n\t\tbreak;\n\tcase IPV6_FLOWINFO_SEND:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->sndflow = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\tcase IPV6_FLOWLABEL_MGR:\n\t\tretv = ipv6_flowlabel_opt(sk, optval, optlen);\n\t\tbreak;\n\tcase IPV6_IPSEC_POLICY:\n\tcase IPV6_XFRM_POLICY:\n\t\tretv = -EPERM;\n\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\tbreak;\n\t\tretv = xfrm_user_policy(sk, optname, optval, optlen);\n\t\tbreak;\n\n\tcase IPV6_ADDR_PREFERENCES:\n\t    {\n\t\tunsigned int pref = 0;\n\t\tunsigned int prefmask = ~0;\n\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\n\t\tretv = -EINVAL;\n\n\t\t/* check PUBLIC/TMP/PUBTMP_DEFAULT conflicts */\n\t\tswitch (val & (IPV6_PREFER_SRC_PUBLIC|\n\t\t\t       IPV6_PREFER_SRC_TMP|\n\t\t\t       IPV6_PREFER_SRC_PUBTMP_DEFAULT)) {\n\t\tcase IPV6_PREFER_SRC_PUBLIC:\n\t\t\tpref |= IPV6_PREFER_SRC_PUBLIC;\n\t\t\tbreak;\n\t\tcase IPV6_PREFER_SRC_TMP:\n\t\t\tpref |= IPV6_PREFER_SRC_TMP;\n\t\t\tbreak;\n\t\tcase IPV6_PREFER_SRC_PUBTMP_DEFAULT:\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tgoto pref_skip_pubtmp;\n\t\tdefault:\n\t\t\tgoto e_inval;\n\t\t}\n\n\t\tprefmask &= ~(IPV6_PREFER_SRC_PUBLIC|\n\t\t\t      IPV6_PREFER_SRC_TMP);\npref_skip_pubtmp:\n\n\t\t/* check HOME/COA conflicts */\n\t\tswitch (val & (IPV6_PREFER_SRC_HOME|IPV6_PREFER_SRC_COA)) {\n\t\tcase IPV6_PREFER_SRC_HOME:\n\t\t\tbreak;\n\t\tcase IPV6_PREFER_SRC_COA:\n\t\t\tpref |= IPV6_PREFER_SRC_COA;\n\t\tcase 0:\n\t\t\tgoto pref_skip_coa;\n\t\tdefault:\n\t\t\tgoto e_inval;\n\t\t}\n\n\t\tprefmask &= ~IPV6_PREFER_SRC_COA;\npref_skip_coa:\n\n\t\t/* check CGA/NONCGA conflicts */\n\t\tswitch (val & (IPV6_PREFER_SRC_CGA|IPV6_PREFER_SRC_NONCGA)) {\n\t\tcase IPV6_PREFER_SRC_CGA:\n\t\tcase IPV6_PREFER_SRC_NONCGA:\n\t\tcase 0:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto e_inval;\n\t\t}\n\n\t\tnp->srcprefs = (np->srcprefs & prefmask) | pref;\n\t\tretv = 0;\n\n\t\tbreak;\n\t    }\n\tcase IPV6_MINHOPCOUNT:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val < 0 || val > 255)\n\t\t\tgoto e_inval;\n\t\tnp->min_hopcount = val;\n\t\tretv = 0;\n\t\tbreak;\n\tcase IPV6_DONTFRAG:\n\t\tnp->dontfrag = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\tcase IPV6_AUTOFLOWLABEL:\n\t\tnp->autoflowlabel = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\tif (needs_rtnl)\n\t\trtnl_unlock();\n\n\treturn retv;\n\ne_inval:\n\trelease_sock(sk);\n\tif (needs_rtnl)\n\t\trtnl_unlock();\n\treturn -EINVAL;\n}\n", "target": 1, "idx": 180508}
{"func": "int svc_rdma_recvfrom(struct svc_rqst *rqstp)\n{\n\tstruct svc_xprt *xprt = rqstp->rq_xprt;\n\tstruct svcxprt_rdma *rdma_xprt =\n\t\tcontainer_of(xprt, struct svcxprt_rdma, sc_xprt);\n\tstruct svc_rdma_op_ctxt *ctxt = NULL;\n\tstruct rpcrdma_msg *rmsgp;\n\tint ret = 0;\n\n\tdprintk(\"svcrdma: rqstp=%p\\n\", rqstp);\n\n\tspin_lock(&rdma_xprt->sc_rq_dto_lock);\n\tif (!list_empty(&rdma_xprt->sc_read_complete_q)) {\n\t\tctxt = list_first_entry(&rdma_xprt->sc_read_complete_q,\n\t\t\t\t\tstruct svc_rdma_op_ctxt, list);\n\t\tlist_del(&ctxt->list);\n\t\tspin_unlock(&rdma_xprt->sc_rq_dto_lock);\n\t\trdma_read_complete(rqstp, ctxt);\n\t\tgoto complete;\n\t} else if (!list_empty(&rdma_xprt->sc_rq_dto_q)) {\n\t\tctxt = list_first_entry(&rdma_xprt->sc_rq_dto_q,\n\t\t\t\t\tstruct svc_rdma_op_ctxt, list);\n\t\tlist_del(&ctxt->list);\n\t} else {\n\t\tatomic_inc(&rdma_stat_rq_starve);\n\t\tclear_bit(XPT_DATA, &xprt->xpt_flags);\n\t\tctxt = NULL;\n\t}\n\tspin_unlock(&rdma_xprt->sc_rq_dto_lock);\n\tif (!ctxt) {\n\t\t/* This is the EAGAIN path. The svc_recv routine will\n\t\t * return -EAGAIN, the nfsd thread will go to call into\n\t\t * svc_recv again and we shouldn't be on the active\n\t\t * transport list\n\t\t */\n\t\tif (test_bit(XPT_CLOSE, &xprt->xpt_flags))\n\t\t\tgoto defer;\n\t\tgoto out;\n\t}\n\tdprintk(\"svcrdma: processing ctxt=%p on xprt=%p, rqstp=%p\\n\",\n\t\tctxt, rdma_xprt, rqstp);\n\tatomic_inc(&rdma_stat_recv);\n\n\t/* Build up the XDR from the receive buffers. */\n\trdma_build_arg_xdr(rqstp, ctxt, ctxt->byte_len);\n\n\t/* Decode the RDMA header. */\n\trmsgp = (struct rpcrdma_msg *)rqstp->rq_arg.head[0].iov_base;\n\tret = svc_rdma_xdr_decode_req(&rqstp->rq_arg);\n\tif (ret < 0)\n\t\tgoto out_err;\n\tif (ret == 0)\n \t\tgoto out_drop;\n \trqstp->rq_xprt_hlen = ret;\n \n\tif (svc_rdma_is_backchannel_reply(xprt, rmsgp)) {\n\t\tret = svc_rdma_handle_bc_reply(xprt->xpt_bc_xprt, rmsgp,\n \t\t\t\t\t       &rqstp->rq_arg);\n \t\tsvc_rdma_put_context(ctxt, 0);\n \t\tif (ret)\n\t\t\tgoto repost;\n\t\treturn ret;\n\t}\n\n\t/* Read read-list data. */\n\tret = rdma_read_chunks(rdma_xprt, rmsgp, rqstp, ctxt);\n\tif (ret > 0) {\n\t\t/* read-list posted, defer until data received from client. */\n\t\tgoto defer;\n\t} else if (ret < 0) {\n\t\t/* Post of read-list failed, free context. */\n\t\tsvc_rdma_put_context(ctxt, 1);\n\t\treturn 0;\n\t}\n\ncomplete:\n\tret = rqstp->rq_arg.head[0].iov_len\n\t\t+ rqstp->rq_arg.page_len\n\t\t+ rqstp->rq_arg.tail[0].iov_len;\n\tsvc_rdma_put_context(ctxt, 0);\n out:\n\tdprintk(\"svcrdma: ret=%d, rq_arg.len=%u, \"\n\t\t\"rq_arg.head[0].iov_base=%p, rq_arg.head[0].iov_len=%zd\\n\",\n\t\tret, rqstp->rq_arg.len,\n\t\trqstp->rq_arg.head[0].iov_base,\n\t\trqstp->rq_arg.head[0].iov_len);\n\trqstp->rq_prot = IPPROTO_MAX;\n\tsvc_xprt_copy_addrs(rqstp, xprt);\n \treturn ret;\n \n out_err:\n\tsvc_rdma_send_error(rdma_xprt, rmsgp, ret);\n \tsvc_rdma_put_context(ctxt, 0);\n \treturn 0;\n \ndefer:\n\treturn 0;\n\nout_drop:\n\tsvc_rdma_put_context(ctxt, 1);\nrepost:\n\treturn svc_rdma_repost_recv(rdma_xprt, GFP_KERNEL);\n}\n", "target": 1, "idx": 181337}
{"func": "mrb_vm_define_class(mrb_state *mrb, mrb_value outer, mrb_value super, mrb_sym id)\n{\n  struct RClass *s;\n  struct RClass *c;\n\n  if (!mrb_nil_p(super)) {\n    if (mrb_type(super) != MRB_TT_CLASS) {\n      mrb_raisef(mrb, E_TYPE_ERROR, \"superclass must be a Class (%S given)\",\n                 mrb_inspect(mrb, super));\n    }\n    s = mrb_class_ptr(super);\n  }\n  else {\n    s = 0;\n  }\n  check_if_class_or_module(mrb, outer);\n  if (mrb_const_defined_at(mrb, outer, id)) {\n    mrb_value old = mrb_const_get(mrb, outer, id);\n\n    if (mrb_type(old) != MRB_TT_CLASS) {\n      mrb_raisef(mrb, E_TYPE_ERROR, \"%S is not a class\", mrb_inspect(mrb, old));\n    }\n    c = mrb_class_ptr(old);\n    if (s) {\n      /* check super class */\n      if (mrb_class_real(c->super) != s) {\n        mrb_raisef(mrb, E_TYPE_ERROR, \"superclass mismatch for class %S\", old);\n      }\n    }\n    return c;\n  }\n  c = define_class(mrb, id, s, mrb_class_ptr(outer));\n  mrb_class_inherited(mrb, mrb_class_real(c->super), c);\n\n  return c;\n}\n", "target": 0, "idx": 82143}
{"func": " void install_local_socket(asocket* s) {\n    adb_mutex_lock(&socket_list_lock);\n \n     s->id = local_socket_next_id++;\n \n     if (local_socket_next_id == 0) {\n        local_socket_next_id = 1;\n     }\n \n     insert_local_socket(s, &local_socket_list);\n    adb_mutex_unlock(&socket_list_lock);\n }\n", "target": 1, "idx": 188174}
{"func": "vhost_scsi_make_tpg(struct se_wwn *wwn,\n\t\t   struct config_group *group,\n\t\t   const char *name)\n{\n\tstruct vhost_scsi_tport *tport = container_of(wwn,\n \t\t\tstruct vhost_scsi_tport, tport_wwn);\n \n \tstruct vhost_scsi_tpg *tpg;\n\tunsigned long tpgt;\n \tint ret;\n \n \tif (strstr(name, \"tpgt_\") != name)\n \t\treturn ERR_PTR(-EINVAL);\n\tif (kstrtoul(name + 5, 10, &tpgt) || tpgt > UINT_MAX)\n \t\treturn ERR_PTR(-EINVAL);\n \n \ttpg = kzalloc(sizeof(struct vhost_scsi_tpg), GFP_KERNEL);\n\tif (!tpg) {\n\t\tpr_err(\"Unable to allocate struct vhost_scsi_tpg\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tmutex_init(&tpg->tv_tpg_mutex);\n\tINIT_LIST_HEAD(&tpg->tv_tpg_list);\n\ttpg->tport = tport;\n\ttpg->tport_tpgt = tpgt;\n\n\tret = core_tpg_register(&vhost_scsi_fabric_configfs->tf_ops, wwn,\n\t\t\t\t&tpg->se_tpg, tpg, TRANSPORT_TPG_TYPE_NORMAL);\n\tif (ret < 0) {\n\t\tkfree(tpg);\n\t\treturn NULL;\n\t}\n\tmutex_lock(&vhost_scsi_mutex);\n\tlist_add_tail(&tpg->tv_tpg_list, &vhost_scsi_list);\n\tmutex_unlock(&vhost_scsi_mutex);\n\n\treturn &tpg->se_tpg;\n}\n", "target": 1, "idx": 179787}
{"func": "void ImageLoader::DecodeRequest::Reject() {\n  resolver_->Reject(DOMException::Create(\n      kEncodingError, \"The source image cannot be decoded.\"));\n  loader_ = nullptr;\n}\n", "target": 0, "idx": 160313}
{"func": "static int ssl3_read_internal(SSL *s, void *buf, int len, int peek)\n\t{\n\tint ret;\n\t\n\tclear_sys_error();\n\tif (s->s3->renegotiate) ssl3_renegotiate_check(s);\n\ts->s3->in_read_app_data=1;\n\tret=s->method->ssl_read_bytes(s,SSL3_RT_APPLICATION_DATA,buf,len,peek);\n\tif ((ret == -1) && (s->s3->in_read_app_data == 2))\n\t\t{\n\t\t/* ssl3_read_bytes decided to call s->handshake_func, which\n\t\t * called ssl3_read_bytes to read handshake data.\n\t\t * However, ssl3_read_bytes actually found application data\n\t\t * and thinks that application data makes sense here; so disable\n\t\t * handshake processing and try to read application data again. */\n\t\ts->in_handshake++;\n\t\tret=s->method->ssl_read_bytes(s,SSL3_RT_APPLICATION_DATA,buf,len,peek);\n\t\ts->in_handshake--;\n\t\t}\n\telse\n\t\ts->s3->in_read_app_data=0;\n\n\treturn(ret);\n\t}\n", "target": 0, "idx": 94}
{"func": "aodv_extension(netdissect_options *ndo,\n               const struct aodv_ext *ep, u_int length)\n {\n \tconst struct aodv_hello *ah;\n \n \tswitch (ep->type) {\n \tcase AODV_EXT_HELLO:\n \t\tah = (const struct aodv_hello *)(const void *)ep;\n \t\tND_TCHECK(*ah);\n \t\tif (length < sizeof(struct aodv_hello))\n \t\t\tgoto trunc;\n \t\tND_PRINT((ndo, \"\\n\\text HELLO %ld ms\",\n \t\t    (unsigned long)EXTRACT_32BITS(&ah->interval)));\n \t\tbreak;\n\n\tdefault:\n\t\tND_PRINT((ndo, \"\\n\\text %u %u\", ep->type, ep->length));\n\t\tbreak;\n\t}\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \" [|hello]\"));\n}\n", "target": 1, "idx": 181077}
{"func": "void kvm_register_target_sys_reg_table(unsigned int target,\n\t\t\t\t       struct kvm_sys_reg_target_table *table)\n{\n\ttarget_tables[target] = table;\n}\n", "target": 0, "idx": 62904}
{"func": " void DistillerNativeJavaScript::EnsureServiceConnected() {\n  if (!distiller_js_service_) {\n     render_frame_->GetServiceRegistry()->ConnectToRemoteService(\n         mojo::GetProxy(&distiller_js_service_));\n   }\n }\n", "target": 1, "idx": 185398}
{"func": "MagickExport void *RelinquishAlignedMemory(void *memory)\n{\n  if (memory == (void *) NULL)\n    return((void *) NULL);\n#if defined(MAGICKCORE_HAVE_POSIX_MEMALIGN)\n  free(memory);\n#elif defined(MAGICKCORE_HAVE__ALIGNED_MALLOC)\n  _aligned_free(memory);\n#else\n  free(*((void **) memory-1));\n#endif\n  return(NULL);\n}\n", "target": 0, "idx": 71435}
{"func": "bool effect_exists(effect_context_t *context)\n{\n struct listnode *node;\n\n    list_for_each(node, &created_effects_list) {\n effect_context_t *fx_ctxt = node_to_item(node,\n effect_context_t,\n                                                 effects_list_node);\n if (fx_ctxt == context) {\n return true;\n }\n }\n return false;\n}\n", "target": 0, "idx": 173521}
{"func": "xfs_attr_rmtval_set(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_bmbt_irec\tmap;\n\txfs_dablk_t\t\tlblkno;\n\txfs_fileoff_t\t\tlfileoff = 0;\n\t__uint8_t\t\t*src = args->value;\n\tint\t\t\tblkcnt;\n\tint\t\t\tvaluelen;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\tint\t\t\toffset = 0;\n\n\ttrace_xfs_attr_rmtval_set(args);\n\n\t/*\n\t * Find a \"hole\" in the attribute address space large enough for\n\t * us to drop the new attribute's value into. Because CRC enable\n \t * attributes have headers, we can't just do a straight byte to FSB\n \t * conversion and have to take the header space into account.\n \t */\n\tblkcnt = xfs_attr3_rmt_blocks(mp, args->valuelen);\n \terror = xfs_bmap_first_unused(args->trans, args->dp, blkcnt, &lfileoff,\n \t\t\t\t\t\t   XFS_ATTR_FORK);\n \tif (error)\n\t\treturn error;\n\n\targs->rmtblkno = lblkno = (xfs_dablk_t)lfileoff;\n\targs->rmtblkcnt = blkcnt;\n\n\t/*\n\t * Roll through the \"value\", allocating blocks on disk as required.\n\t */\n\twhile (blkcnt > 0) {\n\t\tint\tcommitted;\n\n\t\t/*\n\t\t * Allocate a single extent, up to the size of the value.\n\t\t */\n\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\tnmap = 1;\n\t\terror = xfs_bmapi_write(args->trans, dp, (xfs_fileoff_t)lblkno,\n\t\t\t\t  blkcnt,\n\t\t\t\t  XFS_BMAPI_ATTRFORK | XFS_BMAPI_METADATA,\n\t\t\t\t  args->firstblock, args->total, &map, &nmap,\n\t\t\t\t  args->flist);\n\t\tif (!error) {\n\t\t\terror = xfs_bmap_finish(&args->trans, args->flist,\n\t\t\t\t\t\t&committed);\n\t\t}\n\t\tif (error) {\n\t\t\tASSERT(committed);\n\t\t\targs->trans = NULL;\n\t\t\txfs_bmap_cancel(args->flist);\n\t\t\treturn(error);\n\t\t}\n\n\t\t/*\n\t\t * bmap_finish() may have committed the last trans and started\n\t\t * a new one.  We need the inode to be in all transactions.\n\t\t */\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\n\t\tASSERT(nmap == 1);\n\t\tASSERT((map.br_startblock != DELAYSTARTBLOCK) &&\n\t\t       (map.br_startblock != HOLESTARTBLOCK));\n\t\tlblkno += map.br_blockcount;\n\t\tblkcnt -= map.br_blockcount;\n\n\t\t/*\n\t\t * Start the next trans in the chain.\n\t\t */\n\t\terror = xfs_trans_roll(&args->trans, dp);\n\t\tif (error)\n\t\t\treturn (error);\n\t}\n\n\t/*\n\t * Roll through the \"value\", copying the attribute value to the\n\t * already-allocated blocks.  Blocks are written synchronously\n\t * so that we can know they are all on disk before we turn off\n\t * the INCOMPLETE flag.\n \t */\n \tlblkno = args->rmtblkno;\n \tblkcnt = args->rmtblkcnt;\n\tvaluelen = args->valuelen;\n \twhile (valuelen > 0) {\n \t\tstruct xfs_buf\t*bp;\n \t\txfs_daddr_t\tdblkno;\n\t\tint\t\tdblkcnt;\n\n\t\tASSERT(blkcnt > 0);\n\n\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\tnmap = 1;\n\t\terror = xfs_bmapi_read(dp, (xfs_fileoff_t)lblkno,\n\t\t\t\t       blkcnt, &map, &nmap,\n\t\t\t\t       XFS_BMAPI_ATTRFORK);\n\t\tif (error)\n\t\t\treturn(error);\n\t\tASSERT(nmap == 1);\n\t\tASSERT((map.br_startblock != DELAYSTARTBLOCK) &&\n\t\t       (map.br_startblock != HOLESTARTBLOCK));\n\n\t\tdblkno = XFS_FSB_TO_DADDR(mp, map.br_startblock),\n\t\tdblkcnt = XFS_FSB_TO_BB(mp, map.br_blockcount);\n\n\t\tbp = xfs_buf_get(mp->m_ddev_targp, dblkno, dblkcnt, 0);\n\t\tif (!bp)\n\t\t\treturn ENOMEM;\n\t\tbp->b_ops = &xfs_attr3_rmt_buf_ops;\n\n\t\txfs_attr_rmtval_copyin(mp, bp, args->dp->i_ino, &offset,\n\t\t\t\t       &valuelen, &src);\n\n\t\terror = xfs_bwrite(bp);\t/* GROT: NOTE: synchronous write */\n\t\txfs_buf_relse(bp);\n\t\tif (error)\n\t\t\treturn error;\n\n\n\t\t/* roll attribute extent map forwards */\n\t\tlblkno += map.br_blockcount;\n\t\tblkcnt -= map.br_blockcount;\n\t}\n\tASSERT(valuelen == 0);\n\treturn 0;\n}\n", "target": 1, "idx": 179912}
{"func": "base::string16 AuthenticatorBlePairingBeginSheetModel::GetStepDescription()\n    const {\n  return l10n_util::GetStringUTF16(IDS_WEBAUTHN_BLE_PAIRING_BEGIN_DESCRIPTION);\n}\n", "target": 0, "idx": 155572}
{"func": "bool WebGLRenderingContextBase::ValidateHTMLImageElement(\n    const SecurityOrigin* security_origin,\n    const char* function_name,\n    HTMLImageElement* image,\n    ExceptionState& exception_state) {\n  if (!image || !image->CachedImage()) {\n    SynthesizeGLError(GL_INVALID_VALUE, function_name, \"no image\");\n    return false;\n  }\n  const KURL& url = image->CachedImage()->GetResponse().Url();\n  if (url.IsNull() || url.IsEmpty() || !url.IsValid()) {\n    SynthesizeGLError(GL_INVALID_VALUE, function_name, \"invalid image\");\n    return false;\n   }\n \n   if (WouldTaintOrigin(image, security_origin)) {\n    exception_state.ThrowSecurityError(\"The cross-origin image at \" +\n                                       url.ElidedString() +\n                                       \" may not be loaded.\");\n     return false;\n   }\n   return true;\n}\n", "target": 1, "idx": 186667}
{"func": "static void perf_event_reset(struct perf_event *event)\n {\n \t(void)perf_event_read(event);\n \tlocal64_set(&event->count, 0);\n\tperf_event_update_userpage(event);\n}\n", "target": 1, "idx": 180160}
{"func": "PHP_FUNCTION(imagesetstyle)\n{\n\tzval *IM, *styles;\n\tgdImagePtr im;\n\tint * stylearr;\n\tint index;\n\tHashPosition pos;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ra\", &IM, &styles) == FAILURE)  {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\t/* copy the style values in the stylearr */\n\tstylearr = safe_emalloc(sizeof(int), zend_hash_num_elements(HASH_OF(styles)), 0);\n\n\tzend_hash_internal_pointer_reset_ex(HASH_OF(styles), &pos);\n\n\tfor (index = 0;; zend_hash_move_forward_ex(HASH_OF(styles), &pos))\t{\n\t\tzval ** item;\n\n\t\tif (zend_hash_get_current_data_ex(HASH_OF(styles), (void **) &item, &pos) == FAILURE) {\n \t\t\tbreak;\n \t\t}\n \n\t\tconvert_to_long_ex(item);\n\t\tstylearr[index++] = Z_LVAL_PP(item);\n \t}\n \n \tgdImageSetStyle(im, stylearr, index);\n\n\tefree(stylearr);\n\n\tRETURN_TRUE;\n}\n", "target": 1, "idx": 179597}
{"func": "static int cx24116_sleep(struct dvb_frontend *fe)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\tstruct cx24116_cmd cmd;\n\tint ret;\n\n\tdprintk(\"%s()\\n\", __func__);\n\n\t/* Firmware CMD 36: Power config */\n\tcmd.args[0x00] = CMD_TUNERSLEEP;\n\tcmd.args[0x01] = 1;\n\tcmd.len = 0x02;\n\tret = cx24116_cmd_execute(fe, &cmd);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t/* Power off (Shutdown clocks) */\n\tcx24116_writereg(state, 0xea, 0xff);\n\tcx24116_writereg(state, 0xe1, 1);\n\tcx24116_writereg(state, 0xe0, 1);\n\n\treturn 0;\n}\n", "target": 0, "idx": 94069}
{"func": "void WebPage::removeCompositingThreadOverlay(WebOverlay* overlay)\n{\n#if USE(ACCELERATED_COMPOSITING)\n    ASSERT(Platform::userInterfaceThreadMessageClient()->isCurrentThread());\n    if (d->compositor())\n        d->compositor()->removeOverlay(overlay->d->layerCompositingThread());\n    overlay->d->clear();\n    overlay->d->setPage(0);\n#endif\n}\n", "target": 0, "idx": 111299}
{"func": "int snd_timer_close(struct snd_timer_instance *timeri)\n{\n\tstruct snd_timer *timer = NULL;\n\tstruct snd_timer_instance *slave, *tmp;\n\n\tif (snd_BUG_ON(!timeri))\n\t\treturn -ENXIO;\n\n\t/* force to stop the timer */\n\tsnd_timer_stop(timeri);\n\n\tif (timeri->flags & SNDRV_TIMER_IFLG_SLAVE) {\n\t\t/* wait, until the active callback is finished */\n\t\tspin_lock_irq(&slave_active_lock);\n\t\twhile (timeri->flags & SNDRV_TIMER_IFLG_CALLBACK) {\n\t\t\tspin_unlock_irq(&slave_active_lock);\n\t\t\tudelay(10);\n\t\t\tspin_lock_irq(&slave_active_lock);\n\t\t}\n\t\tspin_unlock_irq(&slave_active_lock);\n\t\tmutex_lock(&register_mutex);\n\t\tlist_del(&timeri->open_list);\n\t\tmutex_unlock(&register_mutex);\n\t} else {\n\t\ttimer = timeri->timer;\n\t\tif (snd_BUG_ON(!timer))\n\t\t\tgoto out;\n\t\t/* wait, until the active callback is finished */\n\t\tspin_lock_irq(&timer->lock);\n\t\twhile (timeri->flags & SNDRV_TIMER_IFLG_CALLBACK) {\n\t\t\tspin_unlock_irq(&timer->lock);\n\t\t\tudelay(10);\n\t\t\tspin_lock_irq(&timer->lock);\n\t\t}\n\t\tspin_unlock_irq(&timer->lock);\n\t\tmutex_lock(&register_mutex);\n\t\tlist_del(&timeri->open_list);\n\t\tif (timer && list_empty(&timer->open_list_head) &&\n \t\t    timer->hw.close)\n \t\t\ttimer->hw.close(timer);\n \t\t/* remove slave links */\n \t\tlist_for_each_entry_safe(slave, tmp, &timeri->slave_list_head,\n \t\t\t\t\t open_list) {\n\t\t\tspin_lock_irq(&slave_active_lock);\n\t\t\t_snd_timer_stop(slave, 1, SNDRV_TIMER_EVENT_RESOLUTION);\n \t\t\tlist_move_tail(&slave->open_list, &snd_timer_slave_list);\n \t\t\tslave->master = NULL;\n \t\t\tslave->timer = NULL;\n\t\t\tspin_unlock_irq(&slave_active_lock);\n \t\t}\n \t\tmutex_unlock(&register_mutex);\n \t}\n  out:\n\tif (timeri->private_free)\n\t\ttimeri->private_free(timeri);\n\tkfree(timeri->owner);\n\tkfree(timeri);\n\tif (timer)\n\t\tmodule_put(timer->module);\n\treturn 0;\n}\n", "target": 1, "idx": 180574}
{"func": "static Bool leap_year(u32 year) {\n\tyear += 1900;\n\treturn (year % 4) == 0 && ((year % 100) != 0 || (year % 400) == 0) ? GF_TRUE : GF_FALSE;\n}\n", "target": 0, "idx": 90850}
{"func": "static void enforcedRangeLongLongAttrAttributeSetterCallback(v8::Local<v8::String>, v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)\n{\n    TRACE_EVENT_SET_SAMPLING_STATE(\"Blink\", \"DOMSetter\");\n    TestObjectV8Internal::enforcedRangeLongLongAttrAttributeSetter(jsValue, info);\n    TRACE_EVENT_SET_SAMPLING_STATE(\"V8\", \"V8Execution\");\n}\n", "target": 0, "idx": 130756}
{"func": "  gray_render_span( int             y,\n                    int             count,\n                    const FT_Span*  spans,\n                    PWorker         worker )\n  {\n    unsigned char*  p;\n    FT_Bitmap*      map = &worker->target;\n\n\n     /* first of all, compute the scanline offset */\n     p = (unsigned char*)map->buffer - y * map->pitch;\n     if ( map->pitch >= 0 )\n      p += ( map->rows - 1 ) * map->pitch;\n \n     for ( ; count > 0; count--, spans++ )\n     {\n      unsigned char  coverage = spans->coverage;\n\n\n      if ( coverage )\n      {\n        /* For small-spans it is faster to do it by ourselves than\n         * calling `memset'.  This is mainly due to the cost of the\n         * function call.\n         */\n        if ( spans->len >= 8 )\n          FT_MEM_SET( p + spans->x, (unsigned char)coverage, spans->len );\n        else\n        {\n          unsigned char*  q = p + spans->x;\n\n\n          switch ( spans->len )\n          {\n          case 7: *q++ = (unsigned char)coverage;\n          case 6: *q++ = (unsigned char)coverage;\n          case 5: *q++ = (unsigned char)coverage;\n          case 4: *q++ = (unsigned char)coverage;\n          case 3: *q++ = (unsigned char)coverage;\n          case 2: *q++ = (unsigned char)coverage;\n          case 1: *q   = (unsigned char)coverage;\n          default:\n            ;\n          }\n        }\n      }\n    }\n  }\n", "target": 1, "idx": 178176}
{"func": "static inline bool nested_svm_nmi(struct vcpu_svm *svm)\n{\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn true;\n\n\tif (!(svm->nested.intercept & (1ULL << INTERCEPT_NMI)))\n\t\treturn true;\n\n\tsvm->vmcb->control.exit_code = SVM_EXIT_NMI;\n\tsvm->nested.exit_required = true;\n\n\treturn false;\n}\n", "target": 0, "idx": 37791}
{"func": "GBool ArthurOutputDev::beginType3Char(GfxState *state, double x, double y,\n\t\t\t\t      double dx, double dy,\n\t\t\t\t      CharCode code, Unicode *u, int uLen)\n{\n  return gFalse;\n}\n", "target": 0, "idx": 845}
{"func": "error::Error GLES2DecoderPassthroughImpl::DoEndQueryEXT(GLenum target,\n                                                        uint32_t submit_count) {\n  if (IsEmulatedQueryTarget(target)) {\n    auto active_query_iter = active_queries_.find(target);\n    if (active_query_iter == active_queries_.end()) {\n      InsertError(GL_INVALID_OPERATION, \"No active query on target.\");\n      return error::kNoError;\n    }\n    if (target == GL_ASYNC_PIXEL_PACK_COMPLETED_CHROMIUM &&\n        !pending_read_pixels_.empty()) {\n      GLuint query_service_id = active_query_iter->second.service_id;\n      pending_read_pixels_.back().waiting_async_pack_queries.insert(\n          query_service_id);\n    }\n  } else {\n    CheckErrorCallbackState();\n\n    api()->glEndQueryFn(target);\n\n    if (CheckErrorCallbackState()) {\n      return error::kNoError;\n    }\n  }\n\n  DCHECK(active_queries_.find(target) != active_queries_.end());\n  ActiveQuery active_query = std::move(active_queries_[target]);\n  active_queries_.erase(target);\n\n  PendingQuery pending_query;\n  pending_query.target = target;\n  pending_query.service_id = active_query.service_id;\n  pending_query.shm = std::move(active_query.shm);\n  pending_query.sync = active_query.sync;\n  pending_query.submit_count = submit_count;\n  switch (target) {\n    case GL_COMMANDS_COMPLETED_CHROMIUM:\n      pending_query.commands_completed_fence = gl::GLFence::Create();\n      break;\n\n    case GL_READBACK_SHADOW_COPIES_UPDATED_CHROMIUM:\n      pending_query.buffer_shadow_update_fence = gl::GLFence::Create();\n      pending_query.buffer_shadow_updates = std::move(buffer_shadow_updates_);\n       buffer_shadow_updates_.clear();\n       break;\n \n     default:\n       break;\n   }\n  pending_queries_.push_back(std::move(pending_query));\n  return ProcessQueries(false);\n}\n", "target": 1, "idx": 186502}
{"func": "calc_delta_mine(unsigned long delta_exec, unsigned long weight,\n\t\tstruct load_weight *lw)\n{\n\tu64 tmp;\n\n\t/*\n\t * weight can be less than 2^SCHED_LOAD_RESOLUTION for task group sched\n\t * entities since MIN_SHARES = 2. Treat weight as 1 if less than\n\t * 2^SCHED_LOAD_RESOLUTION.\n\t */\n\tif (likely(weight > (1UL << SCHED_LOAD_RESOLUTION)))\n\t\ttmp = (u64)delta_exec * scale_load_down(weight);\n\telse\n\t\ttmp = (u64)delta_exec;\n\n\tif (!lw->inv_weight) {\n\t\tunsigned long w = scale_load_down(lw->weight);\n\n\t\tif (BITS_PER_LONG > 32 && unlikely(w >= WMULT_CONST))\n\t\t\tlw->inv_weight = 1;\n\t\telse if (unlikely(!w))\n\t\t\tlw->inv_weight = WMULT_CONST;\n\t\telse\n\t\t\tlw->inv_weight = WMULT_CONST / w;\n\t}\n\n\t/*\n\t * Check whether we'd overflow the 64-bit multiplication:\n\t */\n\tif (unlikely(tmp > WMULT_CONST))\n\t\ttmp = SRR(SRR(tmp, WMULT_SHIFT/2) * lw->inv_weight,\n\t\t\tWMULT_SHIFT/2);\n\telse\n\t\ttmp = SRR(tmp * lw->inv_weight, WMULT_SHIFT);\n\n\treturn (unsigned long)min(tmp, (u64)(unsigned long)LONG_MAX);\n}\n", "target": 0, "idx": 26261}
{"func": "write_stats(void)\n{\n\tFILE\t*fp;\n#ifdef DOSYNCTODR\n\tstruct timeval tv;\n#if !defined(VMS)\n\tint\tprio_set;\n#endif\n#ifdef HAVE_GETCLOCK\n\tstruct timespec ts;\n#endif\n\tint\to_prio;\n\n\t/*\n\t * Sometimes having a Sun can be a drag.\n\t *\n\t * The kernel variable dosynctodr controls whether the system's\n\t * soft clock is kept in sync with the battery clock. If it\n\t * is zero, then the soft clock is not synced, and the battery\n\t * clock is simply left to rot. That means that when the system\n\t * reboots, the battery clock (which has probably gone wacky)\n\t * sets the soft clock. That means ntpd starts off with a very\n\t * confused idea of what time it is. It then takes a large\n\t * amount of time to figure out just how wacky the battery clock\n\t * has made things drift, etc, etc. The solution is to make the\n\t * battery clock sync up to system time. The way to do THAT is\n\t * to simply set the time of day to the current time of day, but\n\t * as quickly as possible. This may, or may not be a sensible\n\t * thing to do.\n\t *\n\t * CAVEAT: settimeofday() steps the sun clock by about 800 us,\n\t *\t   so setting DOSYNCTODR seems a bad idea in the\n\t *\t   case of us resolution\n\t */\n\n#if !defined(VMS)\n\t/*\n\t * (prr) getpriority returns -1 on error, but -1 is also a valid\n\t * return value (!), so instead we have to zero errno before the\n\t * call and check it for non-zero afterwards.\n\t */\n\terrno = 0;\n\tprio_set = 0;\n\to_prio = getpriority(PRIO_PROCESS,0); /* Save setting */\n\n\t/*\n\t * (prr) if getpriority succeeded, call setpriority to raise\n\t * scheduling priority as high as possible.  If that succeeds\n\t * as well, set the prio_set flag so we remember to reset\n\t * priority to its previous value below.  Note that on Solaris\n\t * 2.6 (and beyond?), both getpriority and setpriority will fail\n\t * with ESRCH, because sched_setscheduler (called from main) put\n\t * us in the real-time scheduling class which setpriority\n\t * doesn't know about. Being in the real-time class is better\n\t * than anything setpriority can do, anyhow, so this error is\n\t * silently ignored.\n\t */\n\tif ((errno == 0) && (setpriority(PRIO_PROCESS,0,-20) == 0))\n\t\tprio_set = 1;\t/* overdrive */\n#endif /* VMS */\n#ifdef HAVE_GETCLOCK\n\t(void) getclock(TIMEOFDAY, &ts);\n\ttv.tv_sec = ts.tv_sec;\n\ttv.tv_usec = ts.tv_nsec / 1000;\n#else /*  not HAVE_GETCLOCK */\n\tGETTIMEOFDAY(&tv,(struct timezone *)NULL);\n#endif /* not HAVE_GETCLOCK */\n\tif (ntp_set_tod(&tv,(struct timezone *)NULL) != 0)\n\t\tmsyslog(LOG_ERR, \"can't sync battery time: %m\");\n#if !defined(VMS)\n\tif (prio_set)\n\t\tsetpriority(PRIO_PROCESS, 0, o_prio); /* downshift */\n#endif /* VMS */\n#endif /* DOSYNCTODR */\n\trecord_sys_stats();\n\tif (stats_drift_file != 0) {\n\n\t\t/*\n\t\t * When the frequency file is written, initialize the\n\t\t * prev_drift_comp and wander_resid. Thereafter,\n\t\t * reduce the wander_resid by half each hour. When\n\t\t * the difference between the prev_drift_comp and\n\t\t * drift_comp is less than the wander_resid, update\n\t\t * the frequncy file. This minimizes the file writes to\n\t\t * nonvolaile storage.\n\t\t */\n#ifdef DEBUG\n\t\tif (debug)\n\t\t\tprintf(\"write_stats: frequency %.6lf thresh %.6lf, freq %.6lf\\n\",\n\t\t\t    (prev_drift_comp - drift_comp) * 1e6, wander_resid *\n\t\t\t    1e6, drift_comp * 1e6);\n#endif\n\t\tif (fabs(prev_drift_comp - drift_comp) < wander_resid) {\n\t\t\twander_resid *= 0.5;\n\t\t\treturn;\n\t\t}\n\t\tprev_drift_comp = drift_comp;\n\t\twander_resid = wander_threshold;\n\t\tif ((fp = fopen(stats_temp_file, \"w\")) == NULL) {\n\t\t\tmsyslog(LOG_ERR, \"frequency file %s: %m\",\n\t\t\t    stats_temp_file);\n\t\t\treturn;\n\t\t}\n\t\tfprintf(fp, \"%.3f\\n\", drift_comp * 1e6);\n\t\t(void)fclose(fp);\n\t\t/* atomic */\n#ifdef SYS_WINNT\n\t\tif (_unlink(stats_drift_file)) /* rename semantics differ under NT */\n\t\t\tmsyslog(LOG_WARNING, \n\t\t\t\t\"Unable to remove prior drift file %s, %m\", \n\t\t\t\tstats_drift_file);\n#endif /* SYS_WINNT */\n\n#ifndef NO_RENAME\n\t\tif (rename(stats_temp_file, stats_drift_file))\n\t\t\tmsyslog(LOG_WARNING, \n\t\t\t\t\"Unable to rename temp drift file %s to %s, %m\", \n\t\t\t\tstats_temp_file, stats_drift_file);\n#else\n\t\t/* we have no rename NFS of ftp in use */\n\t\tif ((fp = fopen(stats_drift_file, \"w\")) ==\n\t\t    NULL) {\n\t\t\tmsyslog(LOG_ERR,\n\t\t\t    \"frequency file %s: %m\",\n\t\t\t    stats_drift_file);\n\t\t\treturn;\n\t\t}\n#endif\n\n#if defined(VMS)\n\t\t/* PURGE */\n\t\t{\n\t\t\t$DESCRIPTOR(oldvers,\";-1\");\n\t\t\tstruct dsc$descriptor driftdsc = {\n\t\t\t\tstrlen(stats_drift_file), 0, 0,\n\t\t\t\t    stats_drift_file };\n\t\t\twhile(lib$delete_file(&oldvers,\n\t\t\t    &driftdsc) & 1);\n\t\t}\n#endif\n\t}\n}\n", "target": 0, "idx": 74233}
{"func": "void SkippedMBMotionComp(\n VideoDecData *video\n)\n{\n Vop *prev = video->prevVop;\n Vop *comp;\n int ypos, xpos;\n    PIXEL *c_comp, *c_prev;\n    PIXEL *cu_comp, *cu_prev;\n    PIXEL *cv_comp, *cv_prev;\n int width, width_uv;\n int32 offset;\n#ifdef PV_POSTPROC_ON // 2/14/2001      \n int imv;\n int32 size = (int32) video->nTotalMB << 8;\n uint8 *pp_dec_y, *pp_dec_u;\n uint8 *pp_prev1;\n int mvwidth = video->nMBPerRow << 1;\n#endif\n\n    width = video->width;\n    width_uv  = width >> 1;\n    ypos = video->mbnum_row << 4 ;\n    xpos = video->mbnum_col << 4 ;\n    offset = (int32)ypos * width + xpos;\n\n\n \n     /* zero motion compensation for previous frame */\n     /*mby*width + mbx;*/\n    c_prev  = prev->yChan + offset;\n     /*by*width_uv + bx;*/\n     cu_prev = prev->uChan + (offset >> 2) + (xpos >> 2);\n     /*by*width_uv + bx;*/\n    cv_prev = prev->vChan + (offset >> 2) + (xpos >> 2);\n\n    comp = video->currVop;\n\n    c_comp  = comp->yChan + offset;\n    cu_comp = comp->uChan + (offset >> 2) + (xpos >> 2);\n    cv_comp = comp->vChan + (offset >> 2) + (xpos >> 2);\n\n\n /* Copy previous reconstructed frame into the current frame */\n PutSKIPPED_MB(c_comp,  c_prev, width);\n PutSKIPPED_B(cu_comp, cu_prev, width_uv);\n PutSKIPPED_B(cv_comp, cv_prev, width_uv);\n\n /*  10/24/2000 post_processing semaphore generation */\n#ifdef PV_POSTPROC_ON // 2/14/2001\n if (video->postFilterType != PV_NO_POST_PROC)\n {\n        imv = (offset >> 6) - (xpos >> 6) + (xpos >> 3);\n /* Post-processing mode (copy previous MB) */\n        pp_prev1 = video->pstprcTypPrv + imv;\n        pp_dec_y = video->pstprcTypCur + imv;\n *pp_dec_y = *pp_prev1;\n *(pp_dec_y + 1) = *(pp_prev1 + 1);\n *(pp_dec_y + mvwidth) = *(pp_prev1 + mvwidth);\n *(pp_dec_y + mvwidth + 1) = *(pp_prev1 + mvwidth + 1);\n\n /* chrominance */\n /*4*MB_in_width*MB_in_height*/\n        pp_prev1 = video->pstprcTypPrv + (size >> 6) +\n ((imv + (xpos >> 3)) >> 2);\n        pp_dec_u = video->pstprcTypCur + (size >> 6) +\n ((imv + (xpos >> 3)) >> 2);\n *pp_dec_u = *pp_prev1;\n        pp_dec_u[size>>8] = pp_prev1[size>>8];\n }\n#endif\n /*----------------------------------------------------------------------------\n    ; Return nothing or data or data pointer\n    ----------------------------------------------------------------------------*/\n\n return;\n}\n", "target": 1, "idx": 188027}
{"func": "static void display_motd() {\n\tFILE *fp;\n\tint c;\n\n\tif ((fp = fopen(\"/etc/motd\", \"r\"))) {\n\t\twhile ((c = getc(fp)) != EOF) {\n\t\t\tputchar(c);\n\t\t}\n\t\tfclose(fp);\n\t}\n}\n", "target": 0, "idx": 50290}
{"func": "static bool is_ereg(u32 reg)\n{\n\treturn (1 << reg) & (BIT(BPF_REG_5) |\n\t\t\t     BIT(AUX_REG) |\n\t\t\t     BIT(BPF_REG_7) |\n\t\t\t     BIT(BPF_REG_8) |\n\t\t\t     BIT(BPF_REG_9));\n}\n", "target": 0, "idx": 43031}
{"func": "unsigned long nr_iowait(void)\n{\n\tunsigned long i, sum = 0;\n\n\tfor_each_possible_cpu(i)\n\t\tsum += atomic_read(&cpu_rq(i)->nr_iowait);\n\n\treturn sum;\n}\n", "target": 0, "idx": 22494}
{"func": " static MagickBooleanType ReadDXT5(Image *image, DDSInfo *dds_info,\n  ExceptionInfo *exception)\n{\n  DDSColors\n    colors;\n\n  ssize_t\n    j,\n    y;\n\n  MagickSizeType\n    alpha_bits;\n\n  PixelPacket\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  unsigned char\n    a0,\n    a1;\n\n  size_t\n    alpha,\n    bits,\n    code,\n    alpha_code;\n\n  unsigned short\n    c0,\n    c1;\n\n  for (y = 0; y < (ssize_t) dds_info->height; y += 4)\n  {\n     for (x = 0; x < (ssize_t) dds_info->width; x += 4)\n     {\n       /* Get 4x4 patch of pixels to write on */\n      q = QueueAuthenticPixels(image, x, y, Min(4, dds_info->width - x),\n                         Min(4, dds_info->height - y),exception);\n \n       if (q == (PixelPacket *) NULL)\n         return MagickFalse;\n\n      /* Read alpha values (8 bytes) */\n      a0 = (unsigned char) ReadBlobByte(image);\n      a1 = (unsigned char) ReadBlobByte(image);\n\n      alpha_bits = (MagickSizeType)ReadBlobLSBLong(image);\n      alpha_bits = alpha_bits | ((MagickSizeType)ReadBlobLSBShort(image) << 32);\n\n      /* Read 8 bytes of data from the image */\n      c0 = ReadBlobLSBShort(image);\n      c1 = ReadBlobLSBShort(image);\n      bits = ReadBlobLSBLong(image);\n\n      CalculateColors(c0, c1, &colors, MagickTrue);\n\n      /* Write the pixels */\n      for (j = 0; j < 4; j++)\n      {\n        for (i = 0; i < 4; i++)\n        {\n          if ((x + i) < (ssize_t) dds_info->width && (y + j) < (ssize_t) dds_info->height)\n            {\n              code = (bits >> ((4*j+i)*2)) & 0x3;\n              SetPixelRed(q,ScaleCharToQuantum(colors.r[code]));\n              SetPixelGreen(q,ScaleCharToQuantum(colors.g[code]));\n              SetPixelBlue(q,ScaleCharToQuantum(colors.b[code]));\n              /* Extract alpha value */\n              alpha_code = (size_t) (alpha_bits >> (3*(4*j+i))) & 0x7;\n              if (alpha_code == 0)\n                alpha = a0;\n              else if (alpha_code == 1)\n                alpha = a1;\n              else if (a0 > a1)\n                alpha = ((8-alpha_code) * a0 + (alpha_code-1) * a1) / 7;\n              else if (alpha_code == 6)\n                alpha = 0;\n              else if (alpha_code == 7)\n                alpha = 255;\n              else\n                alpha = (((6-alpha_code) * a0 + (alpha_code-1) * a1) / 5);\n              SetPixelAlpha(q,ScaleCharToQuantum((unsigned char)\n                alpha));\n              q++;\n            }\n        }\n      }\n\n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        return MagickFalse;\n     }\n   }\n \n  SkipDXTMipmaps(image, dds_info, 16);\n  return MagickTrue;\n }\n", "target": 1, "idx": 182073}
{"func": "static NetworkRoamingState ParseRoamingState(\n    const std::string& roaming_state) {\n    if (roaming_state == kRoamingStateHome)\n    return ROAMING_STATE_HOME;\n  if (roaming_state == kRoamingStateRoaming)\n    return ROAMING_STATE_ROAMING;\n  if (roaming_state == kRoamingStateUnknown)\n    return ROAMING_STATE_UNKNOWN;\n  return ROAMING_STATE_UNKNOWN;\n}\n", "target": 0, "idx": 100280}
{"func": "static int kvm_vm_ioctl_reinject(struct kvm *kvm,\n\t\t\t\t struct kvm_reinject_control *control)\n{\n\tif (!kvm->arch.vpit)\n\t\treturn -ENXIO;\n\tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n\tkvm->arch.vpit->pit_state.pit_timer.reinject = control->pit_reinject;\n\tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n\treturn 0;\n}\n", "target": 0, "idx": 20848}
{"func": "DefaultAudioDestinationNode* DefaultAudioDestinationNode::Create(\n    BaseAudioContext* context,\n    const WebAudioLatencyHint& latency_hint) {\n  return MakeGarbageCollected<DefaultAudioDestinationNode>(*context,\n                                                           latency_hint);\n}\n", "target": 0, "idx": 143061}
{"func": "static void vmx_complete_atomic_exit(struct vcpu_vmx *vmx)\n{\n\tu32 exit_intr_info;\n\n\tif (!(vmx->exit_reason == EXIT_REASON_MCE_DURING_VMENTRY\n\t      || vmx->exit_reason == EXIT_REASON_EXCEPTION_NMI))\n\t\treturn;\n\n\tvmx->exit_intr_info = vmcs_read32(VM_EXIT_INTR_INFO);\n\texit_intr_info = vmx->exit_intr_info;\n\n\t/* Handle machine checks before interrupts are enabled */\n\tif (is_machine_check(exit_intr_info))\n \t\tkvm_machine_check();\n \n \t/* We need to handle NMIs before interrupts are enabled */\n\tif ((exit_intr_info & INTR_INFO_INTR_TYPE_MASK) == INTR_TYPE_NMI_INTR &&\n\t    (exit_intr_info & INTR_INFO_VALID_MASK)) {\n \t\tkvm_before_handle_nmi(&vmx->vcpu);\n \t\tasm(\"int $2\");\n \t\tkvm_after_handle_nmi(&vmx->vcpu);\n\t}\n}\n", "target": 1, "idx": 180029}
{"func": "static int peer_recv_callback(rdpTransport* transport, wStream* s, void* extra)\n{\n\tfreerdp_peer* client = (freerdp_peer*) extra;\n\trdpRdp* rdp = client->context->rdp;\n\n\tswitch (rdp->state)\n\t{\n\t\tcase CONNECTION_STATE_INITIAL:\n\t\t\tif (!rdp_server_accept_nego(rdp, s))\n\t\t\t\treturn -1;\n\n\t\t\tif (rdp->nego->selected_protocol & PROTOCOL_NLA)\n\t\t\t{\n \t\t\t\tsspi_CopyAuthIdentity(&client->identity, &(rdp->nego->transport->credssp->identity));\n \t\t\t\tIFCALLRET(client->Logon, client->authenticated, client, &client->identity, TRUE);\n \t\t\t\tcredssp_free(rdp->nego->transport->credssp);\n \t\t\t}\n \t\t\telse\n \t\t\t{\n\t\t\t\tIFCALLRET(client->Logon, client->authenticated, client, &client->identity, FALSE);\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_NEGO:\n\t\t\tif (!rdp_server_accept_mcs_connect_initial(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_CONNECT:\n\t\t\tif (!rdp_server_accept_mcs_erect_domain_request(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_ERECT_DOMAIN:\n\t\t\tif (!rdp_server_accept_mcs_attach_user_request(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_ATTACH_USER:\n\t\t\tif (!rdp_server_accept_mcs_channel_join_request(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_CHANNEL_JOIN:\n\t\t\tif (rdp->settings->DisableEncryption)\n\t\t\t{\n\t\t\t\tif (!rdp_server_accept_client_keys(rdp, s))\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trdp->state = CONNECTION_STATE_ESTABLISH_KEYS;\n\t\t\t/* FALLTHROUGH */\n\n\t\tcase CONNECTION_STATE_ESTABLISH_KEYS:\n\t\t\tif (!rdp_server_accept_client_info(rdp, s))\n\t\t\t\treturn -1;\n\n\t\t\tIFCALL(client->Capabilities, client);\n\n\t\t\tif (!rdp_send_demand_active(rdp))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_LICENSE:\n\t\t\tif (!rdp_server_accept_confirm_active(rdp, s))\n\t\t\t{\n\t\t\t\t/**\n\t\t\t\t * During reactivation sequence the client might sent some input or channel data\n\t\t\t\t * before receiving the Deactivate All PDU. We need to process them as usual.\n\t\t\t\t */\n\t\t\t\tStream_SetPosition(s, 0);\n\t\t\t\treturn peer_recv_pdu(client, s);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_ACTIVE:\n\t\t\tif (peer_recv_pdu(client, s) < 0)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Invalid state %d\\n\", rdp->state);\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n", "target": 1, "idx": 180772}
{"func": "void simulatePageScale(WebViewImpl* webViewImpl, float& scale)\n{\n    WebCore::IntSize scrollDelta = webViewImpl->fakePageScaleAnimationTargetPositionForTesting() - webViewImpl->mainFrameImpl()->frameView()->scrollPosition();\n    float scaleDelta = webViewImpl->fakePageScaleAnimationPageScaleForTesting() / webViewImpl->pageScaleFactor();\n    webViewImpl->applyScrollAndScale(scrollDelta, scaleDelta);\n    scale = webViewImpl->pageScaleFactor();\n}\n", "target": 0, "idx": 119541}
{"func": "static inline void mark_all_clean(struct vmcb *vmcb)\n{\n\tvmcb->control.clean = ((1 << VMCB_DIRTY_MAX) - 1)\n\t\t\t       & ~VMCB_ALWAYS_DIRTY_MASK;\n}\n", "target": 0, "idx": 37771}
{"func": "static int key_notify_policy_flush(const struct km_event *c)\n{\n\tstruct sk_buff *skb_out;\n\tstruct sadb_msg *hdr;\n\n\tskb_out = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);\n\tif (!skb_out)\n\t\treturn -ENOBUFS;\n\thdr = (struct sadb_msg *) skb_put(skb_out, sizeof(struct sadb_msg));\n\thdr->sadb_msg_type = SADB_X_SPDFLUSH;\n\thdr->sadb_msg_seq = c->seq;\n \thdr->sadb_msg_pid = c->portid;\n \thdr->sadb_msg_version = PF_KEY_V2;\n \thdr->sadb_msg_errno = (uint8_t) 0;\n \thdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));\n \tpfkey_broadcast(skb_out, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);\n \treturn 0;\n\n}\n", "target": 1, "idx": 179245}
{"func": " static MagickBooleanType CheckMemoryOverflow(const size_t count,\n   const size_t quantum)\n {\n  size_t\n    size;\n\n  size=count*quantum;\n  if ((count == 0) || (quantum != (size/count)))\n    {\n      errno=ENOMEM;\n      return(MagickTrue);\n    }\n  return(MagickFalse);\n}\n", "target": 0, "idx": 71857}
{"func": "long Track::GetNumber() const\n{\n    return m_info.number;\n}\n", "target": 1, "idx": 188371}
{"func": "LayoutBlockFlow::~LayoutBlockFlow()\n{\n}\n", "target": 0, "idx": 132138}
{"func": "ikev1_n_print(netdissect_options *ndo, u_char tpay _U_,\n\t      const struct isakmp_gen *ext, u_int item_len,\n\t      const u_char *ep, uint32_t phase _U_, uint32_t doi0 _U_,\n\t      uint32_t proto0 _U_, int depth _U_)\n{\n\tconst struct ikev1_pl_n *p;\n\tstruct ikev1_pl_n n;\n\tconst u_char *cp;\n\tconst u_char *ep2;\n\tuint32_t doi;\n\tuint32_t proto;\n\tstatic const char *notify_error_str[] = {\n\t\tNULL,\t\t\t\t\"INVALID-PAYLOAD-TYPE\",\n\t\t\"DOI-NOT-SUPPORTED\",\t\t\"SITUATION-NOT-SUPPORTED\",\n\t\t\"INVALID-COOKIE\",\t\t\"INVALID-MAJOR-VERSION\",\n\t\t\"INVALID-MINOR-VERSION\",\t\"INVALID-EXCHANGE-TYPE\",\n\t\t\"INVALID-FLAGS\",\t\t\"INVALID-MESSAGE-ID\",\n\t\t\"INVALID-PROTOCOL-ID\",\t\t\"INVALID-SPI\",\n\t\t\"INVALID-TRANSFORM-ID\",\t\t\"ATTRIBUTES-NOT-SUPPORTED\",\n\t\t\"NO-PROPOSAL-CHOSEN\",\t\t\"BAD-PROPOSAL-SYNTAX\",\n\t\t\"PAYLOAD-MALFORMED\",\t\t\"INVALID-KEY-INFORMATION\",\n\t\t\"INVALID-ID-INFORMATION\",\t\"INVALID-CERT-ENCODING\",\n\t\t\"INVALID-CERTIFICATE\",\t\t\"CERT-TYPE-UNSUPPORTED\",\n\t\t\"INVALID-CERT-AUTHORITY\",\t\"INVALID-HASH-INFORMATION\",\n\t\t\"AUTHENTICATION-FAILED\",\t\"INVALID-SIGNATURE\",\n\t\t\"ADDRESS-NOTIFICATION\",\t\t\"NOTIFY-SA-LIFETIME\",\n\t\t\"CERTIFICATE-UNAVAILABLE\",\t\"UNSUPPORTED-EXCHANGE-TYPE\",\n\t\t\"UNEQUAL-PAYLOAD-LENGTHS\",\n\t};\n\tstatic const char *ipsec_notify_error_str[] = {\n\t\t\"RESERVED\",\n\t};\n\tstatic const char *notify_status_str[] = {\n\t\t\"CONNECTED\",\n\t};\n\tstatic const char *ipsec_notify_status_str[] = {\n\t\t\"RESPONDER-LIFETIME\",\t\t\"REPLAY-STATUS\",\n\t\t\"INITIAL-CONTACT\",\n\t};\n/* NOTE: these macro must be called with x in proper range */\n\n/* 0 - 8191 */\n#define NOTIFY_ERROR_STR(x) \\\n\tSTR_OR_ID((x), notify_error_str)\n\n/* 8192 - 16383 */\n#define IPSEC_NOTIFY_ERROR_STR(x) \\\n\tSTR_OR_ID((u_int)((x) - 8192), ipsec_notify_error_str)\n\n/* 16384 - 24575 */\n#define NOTIFY_STATUS_STR(x) \\\n\tSTR_OR_ID((u_int)((x) - 16384), notify_status_str)\n\n/* 24576 - 32767 */\n#define IPSEC_NOTIFY_STATUS_STR(x) \\\n\tSTR_OR_ID((u_int)((x) - 24576), ipsec_notify_status_str)\n\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_N)));\n\n\tp = (const struct ikev1_pl_n *)ext;\n\tND_TCHECK(*p);\n\tUNALIGNED_MEMCPY(&n, ext, sizeof(n));\n\tdoi = ntohl(n.doi);\n\tproto = n.prot_id;\n\tif (doi != 1) {\n\t\tND_PRINT((ndo,\" doi=%d\", doi));\n\t\tND_PRINT((ndo,\" proto=%d\", proto));\n\t\tif (ntohs(n.type) < 8192)\n\t\t\tND_PRINT((ndo,\" type=%s\", NOTIFY_ERROR_STR(ntohs(n.type))));\n\t\telse if (ntohs(n.type) < 16384)\n\t\t\tND_PRINT((ndo,\" type=%s\", numstr(ntohs(n.type))));\n\t\telse if (ntohs(n.type) < 24576)\n\t\t\tND_PRINT((ndo,\" type=%s\", NOTIFY_STATUS_STR(ntohs(n.type))));\n\t\telse\n\t\t\tND_PRINT((ndo,\" type=%s\", numstr(ntohs(n.type))));\n\t\tif (n.spi_size) {\n\t\t\tND_PRINT((ndo,\" spi=\"));\n\t\t\tif (!rawprint(ndo, (const uint8_t *)(p + 1), n.spi_size))\n\t\t\t\tgoto trunc;\n\t\t}\n\t\treturn (const u_char *)(p + 1) + n.spi_size;\n\t}\n\n\tND_PRINT((ndo,\" doi=ipsec\"));\n\tND_PRINT((ndo,\" proto=%s\", PROTOIDSTR(proto)));\n\tif (ntohs(n.type) < 8192)\n\t\tND_PRINT((ndo,\" type=%s\", NOTIFY_ERROR_STR(ntohs(n.type))));\n\telse if (ntohs(n.type) < 16384)\n\t\tND_PRINT((ndo,\" type=%s\", IPSEC_NOTIFY_ERROR_STR(ntohs(n.type))));\n\telse if (ntohs(n.type) < 24576)\n\t\tND_PRINT((ndo,\" type=%s\", NOTIFY_STATUS_STR(ntohs(n.type))));\n\telse if (ntohs(n.type) < 32768)\n\t\tND_PRINT((ndo,\" type=%s\", IPSEC_NOTIFY_STATUS_STR(ntohs(n.type))));\n\telse\n\t\tND_PRINT((ndo,\" type=%s\", numstr(ntohs(n.type))));\n\tif (n.spi_size) {\n\t\tND_PRINT((ndo,\" spi=\"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(p + 1), n.spi_size))\n\t\t\tgoto trunc;\n\t}\n\n\tcp = (const u_char *)(p + 1) + n.spi_size;\n\tep2 = (const u_char *)p + item_len;\n\n\tif (cp < ep) {\n\t\tswitch (ntohs(n.type)) {\n\t\tcase IPSECDOI_NTYPE_RESPONDER_LIFETIME:\n\t\t    {\n\t\t\tconst struct attrmap *map = oakley_t_map;\n\t\t\tsize_t nmap = sizeof(oakley_t_map)/sizeof(oakley_t_map[0]);\n\t\t\tND_PRINT((ndo,\" attrs=(\"));\n\t\t\twhile (cp < ep && cp < ep2) {\n\t\t\t\tcp = ikev1_attrmap_print(ndo, cp, ep2, map, nmap);\n\t\t\t\tif (cp == NULL) {\n\t\t\t\t\tND_PRINT((ndo,\")\"));\n\t\t\t\t\tgoto trunc;\n\t\t\t\t}\n\t\t\t}\n\t\t\tND_PRINT((ndo,\")\"));\n\t\t\tbreak;\n\t\t    }\n\t\tcase IPSECDOI_NTYPE_REPLAY_STATUS:\n\t\t\tND_PRINT((ndo,\" status=(\"));\n\t\t\tND_PRINT((ndo,\"replay detection %sabled\",\n\t\t\t\t  EXTRACT_32BITS(cp) ? \"en\" : \"dis\"));\n\t\t\tND_PRINT((ndo,\")\"));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/*\n\t\t\t * XXX - fill in more types here; see, for example,\n\t\t\t * draft-ietf-ipsec-notifymsg-04.\n\t\t\t */\n\t\t\tif (ndo->ndo_vflag > 3) {\n\t\t\t\tND_PRINT((ndo,\" data=(\"));\n\t\t\t\tif (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))\n\t\t\t\t\tgoto trunc;\n\t\t\t\tND_PRINT((ndo,\")\"));\n\t\t\t} else {\n\t\t\t\tif (!ike_show_somedata(ndo, cp, ep))\n\t\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (const u_char *)ext + item_len;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_N)));\n\treturn NULL;\n}\n", "target": 0, "idx": 61994}
{"func": "static inline __u32 __peek_user_per_compat(struct task_struct *child,\n\t\t\t\t\t   addr_t addr)\n{\n\tstruct compat_per_struct_kernel *dummy32 = NULL;\n\n\tif (addr == (addr_t) &dummy32->cr9)\n\t\t/* Control bits of the active per set. */\n\t\treturn (__u32) test_thread_flag(TIF_SINGLE_STEP) ?\n\t\t\tPER_EVENT_IFETCH : child->thread.per_user.control;\n\telse if (addr == (addr_t) &dummy32->cr10)\n\t\t/* Start address of the active per set. */\n\t\treturn (__u32) test_thread_flag(TIF_SINGLE_STEP) ?\n\t\t\t0 : child->thread.per_user.start;\n\telse if (addr == (addr_t) &dummy32->cr11)\n\t\t/* End address of the active per set. */\n\t\treturn test_thread_flag(TIF_SINGLE_STEP) ?\n\t\t\tPSW32_ADDR_INSN : child->thread.per_user.end;\n\telse if (addr == (addr_t) &dummy32->bits)\n\t\t/* Single-step bit. */\n\t\treturn (__u32) test_thread_flag(TIF_SINGLE_STEP) ?\n\t\t\t0x80000000 : 0;\n\telse if (addr == (addr_t) &dummy32->starting_addr)\n\t\t/* Start address of the user specified per set. */\n\t\treturn (__u32) child->thread.per_user.start;\n\telse if (addr == (addr_t) &dummy32->ending_addr)\n\t\t/* End address of the user specified per set. */\n\t\treturn (__u32) child->thread.per_user.end;\n\telse if (addr == (addr_t) &dummy32->perc_atmid)\n\t\t/* PER code, ATMID and AI of the last PER trap */\n\t\treturn (__u32) child->thread.per_event.cause << 16;\n\telse if (addr == (addr_t) &dummy32->address)\n\t\t/* Address of the last PER trap */\n\t\treturn (__u32) child->thread.per_event.address;\n\telse if (addr == (addr_t) &dummy32->access_id)\n\t\t/* Access id of the last PER trap */\n\t\treturn (__u32) child->thread.per_event.paid << 24;\n\treturn 0;\n}\n", "target": 0, "idx": 38016}
{"func": "     void makeCurrent()\n     {\n#if PLATFORM(QT)\n        m_detachedContext = QOpenGLContext::currentContext();\n        if (m_detachedContext)\n            m_detachedSurface = m_detachedContext->surface();\n        if (m_surface && m_glContext)\n            m_glContext->makeCurrent(m_surface.get());\n#elif PLATFORM(EFL)\n         m_detachedContext = glXGetCurrentContext();\n         m_detachedSurface = glXGetCurrentDrawable();\n         if (m_surface && m_glContext)\n             glXMakeCurrent(m_display, m_surface, m_glContext);\n#endif\n     }\n", "target": 1, "idx": 183712}
{"func": "static int asn1_decode_p15_object(sc_context_t *ctx, const u8 *in,\n\t\t\t\t  size_t len, struct sc_asn1_pkcs15_object *obj,\n\t\t\t\t  int depth)\n{\n\tstruct sc_pkcs15_object *p15_obj = obj->p15_obj;\n\tstruct sc_asn1_entry asn1_c_attr[6], asn1_p15_obj[5];\n\tstruct sc_asn1_entry asn1_ac_rules[SC_PKCS15_MAX_ACCESS_RULES + 1], asn1_ac_rule[SC_PKCS15_MAX_ACCESS_RULES][3];\n\tsize_t flags_len = sizeof(p15_obj->flags);\n\tsize_t label_len = sizeof(p15_obj->label);\n\tsize_t access_mode_len = sizeof(p15_obj->access_rules[0].access_mode);\n\tint r, ii;\n\n\tfor (ii=0; ii<SC_PKCS15_MAX_ACCESS_RULES; ii++)\n\t\tsc_copy_asn1_entry(c_asn1_access_control_rule, asn1_ac_rule[ii]);\n\tsc_copy_asn1_entry(c_asn1_access_control_rules, asn1_ac_rules);\n\n\n\tsc_copy_asn1_entry(c_asn1_com_obj_attr, asn1_c_attr);\n\tsc_copy_asn1_entry(c_asn1_p15_obj, asn1_p15_obj);\n\tsc_format_asn1_entry(asn1_c_attr + 0, p15_obj->label, &label_len, 0);\n\tsc_format_asn1_entry(asn1_c_attr + 1, &p15_obj->flags, &flags_len, 0);\n\tsc_format_asn1_entry(asn1_c_attr + 2, &p15_obj->auth_id, NULL, 0);\n\tsc_format_asn1_entry(asn1_c_attr + 3, &p15_obj->user_consent, NULL, 0);\n\n\tfor (ii=0; ii<SC_PKCS15_MAX_ACCESS_RULES; ii++)   {\n\t\tsc_format_asn1_entry(asn1_ac_rule[ii] + 0, &p15_obj->access_rules[ii].access_mode, &access_mode_len, 0);\n\t\tsc_format_asn1_entry(asn1_ac_rule[ii] + 1, &p15_obj->access_rules[ii].auth_id, NULL, 0);\n\t\tsc_format_asn1_entry(asn1_ac_rules + ii, asn1_ac_rule[ii], NULL, 0);\n\t}\n\tsc_format_asn1_entry(asn1_c_attr + 4, asn1_ac_rules, NULL, 0);\n\n\tsc_format_asn1_entry(asn1_p15_obj + 0, asn1_c_attr, NULL, 0);\n\tsc_format_asn1_entry(asn1_p15_obj + 1, obj->asn1_class_attr, NULL, 0);\n\tsc_format_asn1_entry(asn1_p15_obj + 2, obj->asn1_subclass_attr, NULL, 0);\n\tsc_format_asn1_entry(asn1_p15_obj + 3, obj->asn1_type_attr, NULL, 0);\n\n\tr = asn1_decode(ctx, asn1_p15_obj, in, len, NULL, NULL, 0, depth + 1);\n\treturn r;\n}\n", "target": 0, "idx": 78102}
{"func": "int invalidate_partition(struct gendisk *disk, int partno)\n{\n\tint res = 0;\n\tstruct block_device *bdev = bdget_disk(disk, partno);\n\tif (bdev) {\n\t\tfsync_bdev(bdev);\n\t\tres = __invalidate_device(bdev, true);\n\t\tbdput(bdev);\n\t}\n\treturn res;\n}\n", "target": 0, "idx": 49708}
{"func": "void RenderFrameImpl::OnGetSerializedHtmlWithLocalLinks(\n    const std::map<GURL, base::FilePath>& url_to_local_path,\n    const std::map<int, base::FilePath>& frame_routing_id_to_local_path) {\n  LinkRewritingDelegate delegate(url_to_local_path,\n                                 frame_routing_id_to_local_path);\n\n  WebFrameSerializer::Serialize(GetWebFrame(),\n                                this,  // WebFrameSerializerClient.\n                                &delegate);\n}\n", "target": 0, "idx": 160663}
{"func": " static int atusb_get_and_show_revision(struct atusb *atusb)\n {\n \tstruct usb_device *usb_dev = atusb->usb_dev;\n\tunsigned char buffer[3];\n \tint ret;\n \n \t/* Get a couple of the ATMega Firmware values */\n \tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n \t\t\t\tATUSB_ID, ATUSB_REQ_FROM_DEV, 0, 0,\n\t\t\t\tbuffer, 3, 1000);\n\tif (ret >= 0) {\n\t\tatusb->fw_ver_maj = buffer[0];\n\t\tatusb->fw_ver_min = buffer[1];\n\t\tatusb->fw_hw_type = buffer[2];\n\n\t\tdev_info(&usb_dev->dev,\n\t\t\t \"Firmware: major: %u, minor: %u, hardware type: %u\\n\",\n\t\t\t atusb->fw_ver_maj, atusb->fw_ver_min, atusb->fw_hw_type);\n\t}\n\tif (atusb->fw_ver_maj == 0 && atusb->fw_ver_min < 2) {\n\t\tdev_info(&usb_dev->dev,\n\t\t\t \"Firmware version (%u.%u) predates our first public release.\",\n\t\t\t atusb->fw_ver_maj, atusb->fw_ver_min);\n \t\tdev_info(&usb_dev->dev, \"Please update to version 0.2 or newer\");\n \t}\n \n \treturn ret;\n }\n", "target": 1, "idx": 181563}
{"func": "void svc_rdma_send_error(struct svcxprt_rdma *xprt, struct rpcrdma_msg *rmsgp,\n\t\t\t int status)\n{\n\tstruct ib_send_wr err_wr;\n\tstruct page *p;\n\tstruct svc_rdma_op_ctxt *ctxt;\n\tenum rpcrdma_errcode err;\n\t__be32 *va;\n\tint length;\n\tint ret;\n\tret = svc_rdma_repost_recv(xprt, GFP_KERNEL);\n\tif (ret)\n\t\treturn;\n\tp = alloc_page(GFP_KERNEL);\n\tif (!p)\n\t\treturn;\n\tva = page_address(p);\n\t/* XDR encode an error reply */\n\terr = ERR_CHUNK;\n\tif (status == -EPROTONOSUPPORT)\n\t\terr = ERR_VERS;\n\tlength = svc_rdma_xdr_encode_error(xprt, rmsgp, err, va);\n\tctxt = svc_rdma_get_context(xprt);\n\tctxt->direction = DMA_TO_DEVICE;\n\tctxt->count = 1;\n\tctxt->pages[0] = p;\n\t/* Prepare SGE for local address */\n\tctxt->sge[0].lkey = xprt->sc_pd->local_dma_lkey;\n\tctxt->sge[0].length = length;\n\tctxt->sge[0].addr = ib_dma_map_page(xprt->sc_cm_id->device,\n\t\t\t\t\t    p, 0, length, DMA_TO_DEVICE);\n\tif (ib_dma_mapping_error(xprt->sc_cm_id->device, ctxt->sge[0].addr)) {\n\t\tdprintk(\"svcrdma: Error mapping buffer for protocol error\\n\");\n\t\tsvc_rdma_put_context(ctxt, 1);\n\t\treturn;\n\t}\n\tsvc_rdma_count_mappings(xprt, ctxt);\n\t/* Prepare SEND WR */\n\tmemset(&err_wr, 0, sizeof(err_wr));\n\tctxt->cqe.done = svc_rdma_wc_send;\n\terr_wr.wr_cqe = &ctxt->cqe;\n\terr_wr.sg_list = ctxt->sge;\n\terr_wr.num_sge = 1;\n\terr_wr.opcode = IB_WR_SEND;\n\terr_wr.send_flags = IB_SEND_SIGNALED;\n\t/* Post It */\n\tret = svc_rdma_send(xprt, &err_wr);\n\tif (ret) {\n\t\tdprintk(\"svcrdma: Error %d posting send for protocol error\\n\",\n\t\t\tret);\n\t\tsvc_rdma_unmap_dma(ctxt);\n\t\tsvc_rdma_put_context(ctxt, 1);\n\t}\n}\n", "target": 1, "idx": 181346}
{"func": "rar_read_ahead(struct archive_read *a, size_t min, ssize_t *avail)\n{\n  struct rar *rar = (struct rar *)(a->format->data);\n  const void *h = __archive_read_ahead(a, min, avail);\n  int ret;\n  if (avail)\n  {\n    if (a->archive.read_data_is_posix_read && *avail > (ssize_t)a->archive.read_data_requested)\n      *avail = a->archive.read_data_requested;\n    if (*avail > rar->bytes_remaining)\n      *avail = (ssize_t)rar->bytes_remaining;\n    if (*avail < 0)\n      return NULL;\n     else if (*avail == 0 && rar->main_flags & MHD_VOLUME &&\n       rar->file_flags & FHD_SPLIT_AFTER)\n     {\n       ret = archive_read_format_rar_read_header(a, a->entry);\n       if (ret == (ARCHIVE_EOF))\n       {\n         rar->has_endarc_header = 1;\n         ret = archive_read_format_rar_read_header(a, a->entry);\n       }\n       if (ret != (ARCHIVE_OK))\n         return NULL;\n       return rar_read_ahead(a, min, avail);\n    }\n  }\n  return h;\n}\n", "target": 1, "idx": 182102}
{"func": "status_t SampleIterator::seekTo(uint32_t sampleIndex) {\n    ALOGV(\"seekTo(%d)\", sampleIndex);\n\n if (sampleIndex >= mTable->mNumSampleSizes) {\n return ERROR_END_OF_STREAM;\n }\n\n if (mTable->mSampleToChunkOffset < 0\n || mTable->mChunkOffsetOffset < 0\n || mTable->mSampleSizeOffset < 0\n || mTable->mTimeToSampleCount == 0) {\n\n return ERROR_MALFORMED;\n }\n\n if (mInitialized && mCurrentSampleIndex == sampleIndex) {\n return OK;\n }\n\n if (!mInitialized || sampleIndex < mFirstChunkSampleIndex) {\n        reset();\n }\n\n if (sampleIndex >= mStopChunkSampleIndex) {\n status_t err;\n if ((err = findChunkRange(sampleIndex)) != OK) {\n            ALOGE(\"findChunkRange failed\");\n return err;\n }\n }\n\n \n     CHECK(sampleIndex < mStopChunkSampleIndex);\n \n     uint32_t chunk =\n         (sampleIndex - mFirstChunkSampleIndex) / mSamplesPerChunk\n         + mFirstChunk;\n\n if (!mInitialized || chunk != mCurrentChunkIndex) {\n        mCurrentChunkIndex = chunk;\n\n status_t err;\n if ((err = getChunkOffset(chunk, &mCurrentChunkOffset)) != OK) {\n            ALOGE(\"getChunkOffset return error\");\n return err;\n }\n\n        mCurrentChunkSampleSizes.clear();\n\n uint32_t firstChunkSampleIndex =\n            mFirstChunkSampleIndex\n + mSamplesPerChunk * (mCurrentChunkIndex - mFirstChunk);\n\n for (uint32_t i = 0; i < mSamplesPerChunk; ++i) {\n size_t sampleSize;\n if ((err = getSampleSizeDirect(\n                            firstChunkSampleIndex + i, &sampleSize)) != OK) {\n                ALOGE(\"getSampleSizeDirect return error\");\n return err;\n }\n\n            mCurrentChunkSampleSizes.push(sampleSize);\n }\n }\n\n uint32_t chunkRelativeSampleIndex =\n (sampleIndex - mFirstChunkSampleIndex) % mSamplesPerChunk;\n\n    mCurrentSampleOffset = mCurrentChunkOffset;\n for (uint32_t i = 0; i < chunkRelativeSampleIndex; ++i) {\n        mCurrentSampleOffset += mCurrentChunkSampleSizes[i];\n }\n\n    mCurrentSampleSize = mCurrentChunkSampleSizes[chunkRelativeSampleIndex];\n if (sampleIndex < mTTSSampleIndex) {\n        mTimeToSampleIndex = 0;\n        mTTSSampleIndex = 0;\n        mTTSSampleTime = 0;\n        mTTSCount = 0;\n        mTTSDuration = 0;\n }\n\n status_t err;\n if ((err = findSampleTimeAndDuration(\n            sampleIndex, &mCurrentSampleTime, &mCurrentSampleDuration)) != OK) {\n        ALOGE(\"findSampleTime return error\");\n return err;\n }\n\n    mCurrentSampleIndex = sampleIndex;\n\n    mInitialized = true;\n\n return OK;\n}\n", "target": 1, "idx": 187788}
{"func": "parse_escapes(char *src, struct mtree_entry *mentry)\n{\n\tchar *dest = src;\n\tchar c;\n\n\tif (mentry != NULL && strcmp(src, \".\") == 0)\n\t\tmentry->full = 1;\n\n\twhile (*src != '\\0') {\n\t\tc = *src++;\n\t\tif (c == '/' && mentry != NULL)\n\t\t\tmentry->full = 1;\n\t\tif (c == '\\\\') {\n\t\t\tswitch (src[0]) {\n\t\t\tcase '0':\n\t\t\t\tif (src[1] < '0' || src[1] > '7') {\n\t\t\t\t\tc = 0;\n\t\t\t\t\t++src;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase '1':\n\t\t\tcase '2':\n\t\t\tcase '3':\n\t\t\t\tif (src[1] >= '0' && src[1] <= '7' &&\n\t\t\t\t    src[2] >= '0' && src[2] <= '7') {\n\t\t\t\t\tc = (src[0] - '0') << 6;\n\t\t\t\t\tc |= (src[1] - '0') << 3;\n\t\t\t\t\tc |= (src[2] - '0');\n\t\t\t\t\tsrc += 3;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'a':\n\t\t\t\tc = '\\a';\n\t\t\t\t++src;\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\t\tc = '\\b';\n\t\t\t\t++src;\n\t\t\t\tbreak;\n\t\t\tcase 'f':\n\t\t\t\tc = '\\f';\n\t\t\t\t++src;\n\t\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\tc = '\\n';\n\t\t\t\t++src;\n\t\t\t\tbreak;\n\t\t\tcase 'r':\n\t\t\t\tc = '\\r';\n\t\t\t\t++src;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\tc = ' ';\n\t\t\t\t++src;\n\t\t\t\tbreak;\n\t\t\tcase 't':\n\t\t\t\tc = '\\t';\n\t\t\t\t++src;\n\t\t\t\tbreak;\n\t\t\tcase 'v':\n\t\t\t\tc = '\\v';\n\t\t\t\t++src;\n\t\t\t\tbreak;\n\t\t\tcase '\\\\':\n\t\t\t\tc = '\\\\';\n\t\t\t\t++src;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t*dest++ = c;\n\t}\n\t*dest = '\\0';\n}\n", "target": 0, "idx": 53518}
{"func": "ikev2_auth_print(netdissect_options *ndo, u_char tpay,\n\t\tconst struct isakmp_gen *ext,\n\t\tu_int item_len _U_, const u_char *ep,\n\t\tuint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tstruct ikev2_auth a;\n\tconst char *v2_auth[]={ \"invalid\", \"rsasig\",\n\t\t\t\t\"shared-secret\", \"dsssig\" };\n \tconst u_char *authdata = (const u_char*)ext + sizeof(a);\n \tunsigned int len;\n \n\tND_TCHECK(*ext);\n \tUNALIGNED_MEMCPY(&a, ext, sizeof(a));\n \tikev2_pay_print(ndo, NPSTR(tpay), a.h.critical);\n \tlen = ntohs(a.h.len);\n\n\t/*\n\t * Our caller has ensured that the length is >= 4.\n\t */\n\tND_PRINT((ndo,\" len=%u method=%s\", len-4,\n\t\t  STR_OR_ID(a.auth_method, v2_auth)));\n\tif (len > 4) {\n\t\tif (ndo->ndo_vflag > 1) {\n\t\t\tND_PRINT((ndo, \" authdata=(\"));\n\t\t\tif (!rawprint(ndo, (const uint8_t *)authdata, len - sizeof(a)))\n\t\t\t\tgoto trunc;\n\t\t\tND_PRINT((ndo, \") \"));\n\t\t} else if (ndo->ndo_vflag) {\n\t\t\tif (!ike_show_somedata(ndo, authdata, ep))\n\t\t\t\tgoto trunc;\n\t\t}\n\t}\n\n\treturn (const u_char *)ext + len;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(tpay)));\n\treturn NULL;\n}\n", "target": 1, "idx": 180969}
{"func": "IMPEG2D_ERROR_CODES_T impeg2d_dec_seq_hdr(dec_state_t *ps_dec)\n{\n stream_t *ps_stream;\n    ps_stream = &ps_dec->s_bit_stream;\n    UWORD16 u2_height;\n    UWORD16 u2_width;\n\n if (impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != SEQUENCE_HEADER_CODE)\n {\n        impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n return IMPEG2D_FRM_HDR_START_CODE_NOT_FOUND;\n\n }\n    impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n\n    u2_width    = impeg2d_bit_stream_get(ps_stream,12);\n    u2_height   = impeg2d_bit_stream_get(ps_stream,12);\n\n if (0 == u2_width || 0 == u2_height)\n {\n        IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_FRM_HDR_DECODE_ERR;\n return e_error;\n }\n\n if ((u2_width != ps_dec->u2_horizontal_size)\n || (u2_height != ps_dec->u2_vertical_size))\n {\n if (0 == ps_dec->u2_header_done)\n {\n\n             /* This is the first time we are reading the resolution */\n             ps_dec->u2_horizontal_size = u2_width;\n             ps_dec->u2_vertical_size = u2_height;\n            if (0 == ps_dec->u4_frm_buf_stride)\n            {\n                ps_dec->u4_frm_buf_stride  = (UWORD32) (u2_width);\n            }\n         }\n         else\n         {\n if (0 == ps_dec->i4_pic_count)\n {\n /* Decoder has not decoded a single frame since the last\n                 * reset/init. This implies that we have two headers in the\n                 * input stream. So, do not indicate a resolution change, since\n                 * this can take the decoder into an infinite loop.\n                 */\n return (IMPEG2D_ERROR_CODES_T) IMPEG2D_FRM_HDR_DECODE_ERR;\n }\n else if((u2_width > ps_dec->u2_create_max_width)\n || (u2_height > ps_dec->u2_create_max_height))\n {\n                IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS;\n\n                ps_dec->u2_reinit_max_height   = u2_height;\n                ps_dec->u2_reinit_max_width    = u2_width;\n\n \n                 return e_error;\n             }\n             else\n             {\n                 /* The resolution has changed */\n return (IMPEG2D_ERROR_CODES_T)IVD_RES_CHANGED;\n }\n }\n }\n\n if((ps_dec->u2_horizontal_size > ps_dec->u2_create_max_width)\n || (ps_dec->u2_vertical_size > ps_dec->u2_create_max_height))\n {\n        IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS;\n        ps_dec->u2_reinit_max_height   = ps_dec->u2_vertical_size;\n        ps_dec->u2_reinit_max_width    = ps_dec->u2_horizontal_size;\n\n         return e_error;\n     }\n \n \n     /*------------------------------------------------------------------------*/\n     /* Flush the following as they are not being used                         */\n /* aspect_ratio_info (4 bits)                                             */\n /*------------------------------------------------------------------------*/\n    ps_dec->u2_aspect_ratio_info = impeg2d_bit_stream_get(ps_stream,4);\n\n /*------------------------------------------------------------------------*/\n /* Frame rate code(4 bits)                                                */\n /*------------------------------------------------------------------------*/\n    ps_dec->u2_frame_rate_code = impeg2d_bit_stream_get(ps_stream,4);\n if (ps_dec->u2_frame_rate_code > MPEG2_MAX_FRAME_RATE_CODE)\n {\n return IMPEG2D_FRM_HDR_DECODE_ERR;\n }\n /*------------------------------------------------------------------------*/\n /* Flush the following as they are not being used                         */\n /* bit_rate_value (18 bits)                                               */\n /*------------------------------------------------------------------------*/\n    impeg2d_bit_stream_flush(ps_stream,18);\n    GET_MARKER_BIT(ps_dec,ps_stream);\n /*------------------------------------------------------------------------*/\n /* Flush the following as they are not being used                         */\n /* vbv_buffer_size_value(10 bits), constrained_parameter_flag (1 bit)     */\n /*------------------------------------------------------------------------*/\n    impeg2d_bit_stream_flush(ps_stream,11);\n\n /*------------------------------------------------------------------------*/\n /* Quantization matrix for the intra blocks                               */\n /*------------------------------------------------------------------------*/\n if(impeg2d_bit_stream_get_bit(ps_stream) == 1)\n {\n        UWORD16 i;\n for(i = 0; i < NUM_PELS_IN_BLOCK; i++)\n {\n            ps_dec->au1_intra_quant_matrix[gau1_impeg2_inv_scan_zig_zag[i]] = (UWORD8)impeg2d_bit_stream_get(ps_stream,8);\n }\n\n }\n else\n {\n        memcpy(ps_dec->au1_intra_quant_matrix,gau1_impeg2_intra_quant_matrix_default,\n                NUM_PELS_IN_BLOCK);\n }\n\n /*------------------------------------------------------------------------*/\n /* Quantization matrix for the inter blocks                               */\n /*------------------------------------------------------------------------*/\n if(impeg2d_bit_stream_get_bit(ps_stream) == 1)\n {\n        UWORD16 i;\n for(i = 0; i < NUM_PELS_IN_BLOCK; i++)\n {\n            ps_dec->au1_inter_quant_matrix[gau1_impeg2_inv_scan_zig_zag[i]] = (UWORD8)impeg2d_bit_stream_get(ps_stream,8);\n }\n }\n else\n {\n        memcpy(ps_dec->au1_inter_quant_matrix,gau1_impeg2_inter_quant_matrix_default,\n            NUM_PELS_IN_BLOCK);\n }\n    impeg2d_next_start_code(ps_dec);\n\n return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;\n}\n", "target": 1, "idx": 188107}
{"func": "_tiffReadProc(thandle_t fd, tdata_t buf, tsize_t size)\n{\n\treturn (read((int) fd, buf, size));\n}\n", "target": 0, "idx": 86791}
{"func": "static Image *ReadJPEGImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    value[MaxTextExtent];\n\n  const char\n    *option;\n\n  ErrorManager\n    error_manager;\n\n  Image\n    *image;\n\n  IndexPacket\n    index;\n\n  JSAMPLE\n    *volatile jpeg_pixels;\n\n  JSAMPROW\n    scanline[1];\n\n  MagickBooleanType\n    debug,\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  MemoryInfo\n    *memory_info;\n\n  register ssize_t\n    i;\n\n  struct jpeg_decompress_struct\n    jpeg_info;\n\n  struct jpeg_error_mgr\n    jpeg_error;\n\n  register JSAMPLE\n    *p;\n\n  size_t\n    units;\n\n  ssize_t\n    y;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  debug=IsEventLogging();\n  (void) debug;\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n       image=DestroyImageList(image);\n       return((Image *) NULL);\n     }\n   /*\n     Initialize JPEG parameters.\n   */\n  (void) ResetMagickMemory(&error_manager,0,sizeof(error_manager));\n  (void) ResetMagickMemory(&jpeg_info,0,sizeof(jpeg_info));\n  (void) ResetMagickMemory(&jpeg_error,0,sizeof(jpeg_error));\n  jpeg_info.err=jpeg_std_error(&jpeg_error);\n  jpeg_info.err->emit_message=(void (*)(j_common_ptr,int)) JPEGWarningHandler;\n  jpeg_info.err->error_exit=(void (*)(j_common_ptr)) JPEGErrorHandler;\n  memory_info=(MemoryInfo *) NULL;\n  error_manager.image=image;\n  if (setjmp(error_manager.error_recovery) != 0)\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      if (error_manager.profile != (StringInfo *) NULL)\n        error_manager.profile=DestroyStringInfo(error_manager.profile);\n      (void) CloseBlob(image);\n      number_pixels=(MagickSizeType) image->columns*image->rows;\n      if (number_pixels != 0)\n        return(GetFirstImageInList(image));\n      InheritException(exception,&image->exception);\n      return(DestroyImage(image));\n    }\n  jpeg_info.client_data=(void *) &error_manager;\n  jpeg_create_decompress(&jpeg_info);\n  JPEGSourceManager(&jpeg_info,image);\n  jpeg_set_marker_processor(&jpeg_info,JPEG_COM,ReadComment);\n  option=GetImageOption(image_info,\"profile:skip\");\n  if (IsOptionMember(\"ICC\",option) == MagickFalse)\n    jpeg_set_marker_processor(&jpeg_info,ICC_MARKER,ReadICCProfile);\n  if (IsOptionMember(\"IPTC\",option) == MagickFalse)\n    jpeg_set_marker_processor(&jpeg_info,IPTC_MARKER,ReadIPTCProfile);\n  for (i=1; i < 16; i++)\n    if ((i != 2) && (i != 13) && (i != 14))\n      if (IsOptionMember(\"APP\",option) == MagickFalse)\n        jpeg_set_marker_processor(&jpeg_info,(int) (JPEG_APP0+i),ReadProfile);\n  i=(ssize_t) jpeg_read_header(&jpeg_info,TRUE);\n  if ((image_info->colorspace == YCbCrColorspace) ||\n      (image_info->colorspace == Rec601YCbCrColorspace) ||\n      (image_info->colorspace == Rec709YCbCrColorspace))\n    jpeg_info.out_color_space=JCS_YCbCr;\n  /*\n    Set image resolution.\n  */\n  units=0;\n  if ((jpeg_info.saw_JFIF_marker != 0) && (jpeg_info.X_density != 1) &&\n      (jpeg_info.Y_density != 1))\n    {\n      image->x_resolution=(double) jpeg_info.X_density;\n      image->y_resolution=(double) jpeg_info.Y_density;\n      units=(size_t) jpeg_info.density_unit;\n    }\n  if (units == 1)\n    image->units=PixelsPerInchResolution;\n  if (units == 2)\n    image->units=PixelsPerCentimeterResolution;\n  number_pixels=(MagickSizeType) image->columns*image->rows;\n  option=GetImageOption(image_info,\"jpeg:size\");\n  if ((option != (const char *) NULL) &&\n      (jpeg_info.out_color_space != JCS_YCbCr))\n    {\n      double\n        scale_factor;\n\n      GeometryInfo\n        geometry_info;\n\n      MagickStatusType\n        flags;\n\n      /*\n        Scale the image.\n      */\n      flags=ParseGeometry(option,&geometry_info);\n      if ((flags & SigmaValue) == 0)\n        geometry_info.sigma=geometry_info.rho;\n      jpeg_calc_output_dimensions(&jpeg_info);\n      image->magick_columns=jpeg_info.output_width;\n      image->magick_rows=jpeg_info.output_height;\n      scale_factor=1.0;\n      if (geometry_info.rho != 0.0)\n        scale_factor=jpeg_info.output_width/geometry_info.rho;\n      if ((geometry_info.sigma != 0.0) &&\n          (scale_factor > (jpeg_info.output_height/geometry_info.sigma)))\n        scale_factor=jpeg_info.output_height/geometry_info.sigma;\n      jpeg_info.scale_num=1U;\n      jpeg_info.scale_denom=(unsigned int) scale_factor;\n      jpeg_calc_output_dimensions(&jpeg_info);\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Scale factor: %.20g\",(double) scale_factor);\n    }\n#if (JPEG_LIB_VERSION >= 61) && defined(D_PROGRESSIVE_SUPPORTED)\n#if defined(D_LOSSLESS_SUPPORTED)\n  image->interlace=jpeg_info.process == JPROC_PROGRESSIVE ?\n    JPEGInterlace : NoInterlace;\n  image->compression=jpeg_info.process == JPROC_LOSSLESS ?\n    LosslessJPEGCompression : JPEGCompression;\n  if (jpeg_info.data_precision > 8)\n    (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n      \"12-bit JPEG not supported. Reducing pixel data to 8 bits\",\"`%s'\",\n      image->filename);\n  if (jpeg_info.data_precision == 16)\n    jpeg_info.data_precision=12;\n#else\n  image->interlace=jpeg_info.progressive_mode != 0 ? JPEGInterlace :\n    NoInterlace;\n  image->compression=JPEGCompression;\n#endif\n#else\n  image->compression=JPEGCompression;\n  image->interlace=JPEGInterlace;\n#endif\n  option=GetImageOption(image_info,\"jpeg:colors\");\n  if (option != (const char *) NULL)\n    {\n      /*\n        Let the JPEG library quantize for us.\n      */\n      jpeg_info.quantize_colors=TRUE;\n      jpeg_info.desired_number_of_colors=(int) StringToUnsignedLong(option);\n    }\n  option=GetImageOption(image_info,\"jpeg:block-smoothing\");\n  if (option != (const char *) NULL)\n    jpeg_info.do_block_smoothing=IsStringTrue(option) != MagickFalse ? TRUE :\n      FALSE;\n  jpeg_info.dct_method=JDCT_FLOAT;\n  option=GetImageOption(image_info,\"jpeg:dct-method\");\n  if (option != (const char *) NULL)\n    switch (*option)\n    {\n      case 'D':\n      case 'd':\n      {\n        if (LocaleCompare(option,\"default\") == 0)\n          jpeg_info.dct_method=JDCT_DEFAULT;\n        break;\n      }\n      case 'F':\n      case 'f':\n      {\n        if (LocaleCompare(option,\"fastest\") == 0)\n          jpeg_info.dct_method=JDCT_FASTEST;\n        if (LocaleCompare(option,\"float\") == 0)\n          jpeg_info.dct_method=JDCT_FLOAT;\n        break;\n      }\n      case 'I':\n      case 'i':\n      {\n        if (LocaleCompare(option,\"ifast\") == 0)\n          jpeg_info.dct_method=JDCT_IFAST;\n        if (LocaleCompare(option,\"islow\") == 0)\n          jpeg_info.dct_method=JDCT_ISLOW;\n        break;\n      }\n    }\n  option=GetImageOption(image_info,\"jpeg:fancy-upsampling\");\n  if (option != (const char *) NULL)\n    jpeg_info.do_fancy_upsampling=IsStringTrue(option) != MagickFalse ? TRUE :\n      FALSE;\n  (void) jpeg_start_decompress(&jpeg_info);\n  image->columns=jpeg_info.output_width;\n  image->rows=jpeg_info.output_height;\n  image->depth=(size_t) jpeg_info.data_precision;\n  switch (jpeg_info.out_color_space)\n  {\n    case JCS_RGB:\n    default:\n    {\n      (void) SetImageColorspace(image,sRGBColorspace);\n      break;\n    }\n    case JCS_GRAYSCALE:\n    {\n      (void) SetImageColorspace(image,GRAYColorspace);\n      break;\n    }\n    case JCS_YCbCr:\n    {\n      (void) SetImageColorspace(image,YCbCrColorspace);\n      break;\n    }\n    case JCS_CMYK:\n    {\n      (void) SetImageColorspace(image,CMYKColorspace);\n      break;\n    }\n  }\n  if (IsITUFaxImage(image) != MagickFalse)\n    {\n      (void) SetImageColorspace(image,LabColorspace);\n      jpeg_info.out_color_space=JCS_YCbCr;\n    }\n  option=GetImageOption(image_info,\"jpeg:colors\");\n  if (option != (const char *) NULL)\n    if (AcquireImageColormap(image,StringToUnsignedLong(option)) == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n  if ((jpeg_info.output_components == 1) && (jpeg_info.quantize_colors == 0))\n    {\n      size_t\n        colors;\n\n      colors=(size_t) GetQuantumRange(image->depth)+1;\n      if (AcquireImageColormap(image,colors) == MagickFalse)\n        {\n          InheritException(exception,&image->exception);\n          return(DestroyImageList(image));\n        }\n    }\n  if (image->debug != MagickFalse)\n    {\n      if (image->interlace != NoInterlace)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Interlace: progressive\");\n      else\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Interlace: nonprogressive\");\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Data precision: %d\",\n        (int) jpeg_info.data_precision);\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Geometry: %dx%d\",\n        (int) jpeg_info.output_width,(int) jpeg_info.output_height);\n    }\n  JPEGSetImageQuality(&jpeg_info,image);\n  JPEGSetImageSamplingFactor(&jpeg_info,image);\n  (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",(double)\n    jpeg_info.out_color_space);\n  (void) SetImageProperty(image,\"jpeg:colorspace\",value);\n  if (image_info->ping != MagickFalse)\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  if ((jpeg_info.output_components != 1) &&\n      (jpeg_info.output_components != 3) && (jpeg_info.output_components != 4))\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      ThrowReaderException(CorruptImageError,\"ImageTypeNotSupported\");\n    }\n  memory_info=AcquireVirtualMemory((size_t) image->columns,\n    jpeg_info.output_components*sizeof(*jpeg_pixels));\n  if (memory_info == (MemoryInfo *) NULL)\n    {\n      jpeg_destroy_decompress(&jpeg_info);\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  jpeg_pixels=(JSAMPLE *) GetVirtualMemoryBlob(memory_info);\n  /*\n    Convert JPEG pixels to pixel packets.\n  */\n  if (setjmp(error_manager.error_recovery) != 0)\n    {\n      if (memory_info != (MemoryInfo *) NULL)\n        memory_info=RelinquishVirtualMemory(memory_info);\n      jpeg_destroy_decompress(&jpeg_info);\n      (void) CloseBlob(image);\n      number_pixels=(MagickSizeType) image->columns*image->rows;\n      if (number_pixels != 0)\n        return(GetFirstImageInList(image));\n      return(DestroyImage(image));\n    }\n  if (jpeg_info.quantize_colors != 0)\n    {\n      image->colors=(size_t) jpeg_info.actual_number_of_colors;\n      if (jpeg_info.out_color_space == JCS_GRAYSCALE)\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          image->colormap[i].red=ScaleCharToQuantum(jpeg_info.colormap[0][i]);\n          image->colormap[i].green=image->colormap[i].red;\n          image->colormap[i].blue=image->colormap[i].red;\n          image->colormap[i].opacity=OpaqueOpacity;\n        }\n      else\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          image->colormap[i].red=ScaleCharToQuantum(jpeg_info.colormap[0][i]);\n          image->colormap[i].green=ScaleCharToQuantum(jpeg_info.colormap[1][i]);\n          image->colormap[i].blue=ScaleCharToQuantum(jpeg_info.colormap[2][i]);\n          image->colormap[i].opacity=OpaqueOpacity;\n        }\n    }\n  scanline[0]=(JSAMPROW) jpeg_pixels;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register IndexPacket\n      *magick_restrict indexes;\n\n    register ssize_t\n      x;\n\n    register PixelPacket\n      *magick_restrict q;\n\n    if (jpeg_read_scanlines(&jpeg_info,scanline,1) != 1)\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          CorruptImageWarning,\"SkipToSyncByte\",\"`%s'\",image->filename);\n        continue;\n      }\n    p=jpeg_pixels;\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      break;\n    indexes=GetAuthenticIndexQueue(image);\n    if (jpeg_info.data_precision > 8)\n      {\n        unsigned short\n          scale;\n\n        scale=65535/(unsigned short) GetQuantumRange((size_t)\n          jpeg_info.data_precision);\n        if (jpeg_info.output_components == 1)\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            size_t\n              pixel;\n\n            pixel=(size_t) (scale*GETJSAMPLE(*p));\n            index=ConstrainColormapIndex(image,pixel);\n            SetPixelIndex(indexes+x,index);\n            SetPixelRGBO(q,image->colormap+(ssize_t) index);\n            p++;\n            q++;\n          }\n        else\n          if (image->colorspace != CMYKColorspace)\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelRed(q,ScaleShortToQuantum((unsigned short)\n                (scale*GETJSAMPLE(*p++))));\n              SetPixelGreen(q,ScaleShortToQuantum((unsigned short)\n                (scale*GETJSAMPLE(*p++))));\n              SetPixelBlue(q,ScaleShortToQuantum((unsigned short)\n                (scale*GETJSAMPLE(*p++))));\n              SetPixelOpacity(q,OpaqueOpacity);\n              q++;\n            }\n          else\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelCyan(q,QuantumRange-ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))));\n              SetPixelMagenta(q,QuantumRange-ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))));\n              SetPixelYellow(q,QuantumRange-ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))));\n              SetPixelBlack(indexes+x,QuantumRange-ScaleShortToQuantum(\n                (unsigned short) (scale*GETJSAMPLE(*p++))));\n              SetPixelOpacity(q,OpaqueOpacity);\n              q++;\n            }\n      }\n    else\n      if (jpeg_info.output_components == 1)\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          index=ConstrainColormapIndex(image,(size_t) GETJSAMPLE(*p));\n          SetPixelIndex(indexes+x,index);\n          SetPixelRGBO(q,image->colormap+(ssize_t) index);\n          p++;\n          q++;\n        }\n      else\n        if (image->colorspace != CMYKColorspace)\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(q,ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)));\n            SetPixelGreen(q,ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)));\n            SetPixelBlue(q,ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)));\n            SetPixelOpacity(q,OpaqueOpacity);\n            q++;\n          }\n        else\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelCyan(q,QuantumRange-ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)));\n            SetPixelMagenta(q,QuantumRange-ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)));\n            SetPixelYellow(q,QuantumRange-ScaleCharToQuantum((unsigned char)\n              GETJSAMPLE(*p++)));\n            SetPixelBlack(indexes+x,QuantumRange-ScaleCharToQuantum(\n              (unsigned char) GETJSAMPLE(*p++)));\n            SetPixelOpacity(q,OpaqueOpacity);\n            q++;\n          }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      {\n        jpeg_abort_decompress(&jpeg_info);\n        break;\n      }\n  }\n  if (status != MagickFalse)\n    {\n      error_manager.finished=MagickTrue;\n      if (setjmp(error_manager.error_recovery) == 0)\n        (void) jpeg_finish_decompress(&jpeg_info);\n    }\n  /*\n    Free jpeg resources.\n  */\n  jpeg_destroy_decompress(&jpeg_info);\n  memory_info=RelinquishVirtualMemory(memory_info);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n", "target": 1, "idx": 181205}
{"func": "static unsigned int stack_maxrandom_size(void)\n {\n\tunsigned int max = 0;\n \tif ((current->flags & PF_RANDOMIZE) &&\n \t\t!(current->personality & ADDR_NO_RANDOMIZE)) {\n\t\tmax = ((-1U) & STACK_RND_MASK) << PAGE_SHIFT;\n \t}\n \n \treturn max;\n}\n", "target": 1, "idx": 179867}
{"func": "  virtual void SetImePropertyActivated(const std::string& key,\n                                       bool activated) {\n    if (!initialized_successfully_)\n       return;\n \n     DCHECK(!key.empty());\n    chromeos::SetImePropertyActivated(\n        input_method_status_connection_, key.c_str(), activated);\n   }\n", "target": 1, "idx": 183964}
{"func": "WKURLRequestRef InjectedBundlePage::willSendRequestForFrame(WKBundlePageRef, WKBundleFrameRef frame, uint64_t identifier, WKURLRequestRef request, WKURLResponseRef response)\n{\n    if (InjectedBundle::shared().isTestRunning()\n        && InjectedBundle::shared().testRunner()->shouldDumpResourceLoadCallbacks()) {\n        StringBuilder stringBuilder;\n        dumpResourceURL(identifier, stringBuilder);\n        stringBuilder.appendLiteral(\" - willSendRequest \");\n        dumpRequestDescriptionSuitableForTestResult(request, stringBuilder);\n        stringBuilder.appendLiteral(\" redirectResponse \");\n        dumpResponseDescriptionSuitableForTestResult(response, stringBuilder);\n        stringBuilder.append('\\n');\n        InjectedBundle::shared().outputText(stringBuilder.toString());\n    }\n\n    if (InjectedBundle::shared().isTestRunning() && InjectedBundle::shared().testRunner()->willSendRequestReturnsNull())\n        return 0;\n\n    WKRetainPtr<WKURLRef> redirectURL = adoptWK(WKURLResponseCopyURL(response));\n    if (InjectedBundle::shared().isTestRunning() && InjectedBundle::shared().testRunner()->willSendRequestReturnsNullOnRedirect() && redirectURL) {\n        InjectedBundle::shared().outputText(\"Returning null for this redirect\\n\");\n        return 0;\n    }\n\n    WKRetainPtr<WKURLRef> url = adoptWK(WKURLRequestCopyURL(request));\n    WKRetainPtr<WKStringRef> host = adoptWK(WKURLCopyHostName(url.get()));\n    WKRetainPtr<WKStringRef> scheme = adoptWK(WKURLCopyScheme(url.get()));\n    WKRetainPtr<WKStringRef> urlString = adoptWK(WKURLCopyString(url.get()));\n    if (host && !WKStringIsEmpty(host.get())\n        && isHTTPOrHTTPSScheme(scheme.get())\n        && !WKStringIsEqualToUTF8CString(host.get(), \"255.255.255.255\") // Used in some tests that expect to get back an error.\n        && !isLocalHost(host.get())) {\n        bool mainFrameIsExternal = false;\n        if (InjectedBundle::shared().isTestRunning()) {\n            WKBundleFrameRef mainFrame = InjectedBundle::shared().topLoadingFrame();\n            WKRetainPtr<WKURLRef> mainFrameURL = adoptWK(WKBundleFrameCopyURL(mainFrame));\n            if (!mainFrameURL || WKStringIsEqualToUTF8CString(adoptWK(WKURLCopyString(mainFrameURL.get())).get(), \"about:blank\"))\n                mainFrameURL = adoptWK(WKBundleFrameCopyProvisionalURL(mainFrame));\n\n            WKRetainPtr<WKStringRef> mainFrameHost = WKURLCopyHostName(mainFrameURL.get());\n            WKRetainPtr<WKStringRef> mainFrameScheme = WKURLCopyScheme(mainFrameURL.get());\n            mainFrameIsExternal = isHTTPOrHTTPSScheme(mainFrameScheme.get()) && !isLocalHost(mainFrameHost.get());\n        }\n        if (!mainFrameIsExternal) {\n            StringBuilder stringBuilder;\n            stringBuilder.appendLiteral(\"Blocked access to external URL \");\n            stringBuilder.append(toWTFString(urlString));\n            stringBuilder.append('\\n');\n            InjectedBundle::shared().outputText(stringBuilder.toString());\n            return 0;\n        }\n    }\n\n    WKRetain(request);\n    return request;\n}\n", "target": 0, "idx": 115488}
{"func": " static int get_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)\n {\n\treturn usb_control_msg(dev->udev, usb_rcvctrlpipe(dev->udev, 0),\n\t\t\t       RTL8150_REQ_GET_REGS, RTL8150_REQT_READ,\n\t\t\t       indx, 0, data, size, 500);\n }\n", "target": 1, "idx": 181386}
{"func": "static void mptsas_free_request(MPTSASRequest *req)\n{\n    MPTSASState *s = req->dev;\n\n    if (req->sreq != NULL) {\n        req->sreq->hba_private = NULL;\n        scsi_req_unref(req->sreq);\n        req->sreq = NULL;\n        QTAILQ_REMOVE(&s->pending, req, next);\n    }\n    qemu_sglist_destroy(&req->qsg);\n    g_free(req);\n}\n", "target": 0, "idx": 8361}
{"func": " fbOver (CARD32 x, CARD32 y)\n {\n\t\t\t\t  PicturePtr pDst,\n\t\t\t\t  INT16      xSrc,\n\t\t\t\t  INT16      ySrc,\n\t\t\t\t  INT16      xMask,\n                                  INT16      yMask,\n\t\t\t\t  INT16      xDst,\n\t\t\t\t  INT16      yDst,\n\t\t\t\t  CARD16     width,\n\t\t\t\t  CARD16     height);\n\nCARD32\nfbOver (CARD32 x, CARD32 y)\n{\n    CARD16  a = ~x >> 24;\n    CARD16  t;\n    CARD32  m,n,o,p;\n\n    m = FbOverU(x,y,0,a,t);\n    n = FbOverU(x,y,8,a,t);\n    o = FbOverU(x,y,16,a,t);\n    p = FbOverU(x,y,24,a,t);\n    return m|n|o|p;\n}\n\nCARD32\nfbOver24 (CARD32 x, CARD32 y)\n{\n    CARD16  a = ~x >> 24;\n    CARD16  t;\n    CARD32  m,n,o;\n\n    m = FbOverU(x,y,0,a,t);\n    n = FbOverU(x,y,8,a,t);\n    o = FbOverU(x,y,16,a,t);\n    return m|n|o;\n}\n\nCARD32\nfbIn (CARD32 x, CARD8 y)\n{\n    CARD16  a = y;\n    CARD16  t;\n    CARD32  m,n,o,p;\n\n    m = FbInU(x,0,a,t);\n    n = FbInU(x,8,a,t);\n    o = FbInU(x,16,a,t);\n    p = FbInU(x,24,a,t);\n    return m|n|o|p;\n}\n\n#define genericCombine24(a,b,c,d) (((a)*(c)+(b)*(d)))\n\n/*\n * This macro does src IN mask OVER dst when src and dst are 0888.\n * If src has alpha, this will not work\n */\n#define inOver0888(alpha, source, destval, dest) { \\\n \tCARD32 dstrb=destval&0xFF00FF; CARD32 dstag=(destval>>8)&0xFF00FF; \\\n \tCARD32 drb=((source&0xFF00FF)-dstrb)*alpha; CARD32 dag=(((source>>8)&0xFF00FF)-dstag)*alpha; \\\n\tWRITE(dest, ((((drb>>8) + dstrb) & 0x00FF00FF) | ((((dag>>8) + dstag) << 8) & 0xFF00FF00))); \\\n    }\n\n/*\n * This macro does src IN mask OVER dst when src and dst are 0565 and\n * mask is a 5-bit alpha value.  Again, if src has alpha, this will not\n * work.\n */\n#define inOver0565(alpha, source, destval, dest) { \\\n \tCARD16 dstrb = destval & 0xf81f; CARD16 dstg  = destval & 0x7e0; \\\n \tCARD32 drb = ((source&0xf81f)-dstrb)*alpha; CARD32 dg=((source & 0x7e0)-dstg)*alpha; \\\n\tWRITE(dest, ((((drb>>5) + dstrb)&0xf81f) | (((dg>>5)  + dstg) & 0x7e0))); \\\n    }\n\n\n#define inOver2x0565(alpha, source, destval, dest) { \\\n \tCARD32 dstrb = destval & 0x07e0f81f; CARD32 dstg  = (destval & 0xf81f07e0)>>5; \\\n \tCARD32 drb = ((source&0x07e0f81f)-dstrb)*alpha; CARD32 dg=(((source & 0xf81f07e0)>>5)-dstg)*alpha; \\\n\tWRITE(dest, ((((drb>>5) + dstrb)&0x07e0f81f) | ((((dg>>5)  + dstg)<<5) & 0xf81f07e0))); \\\n    }\n\n\n#if IMAGE_BYTE_ORDER == LSBFirst\n#define setupPackedReader(count,temp,where,workingWhere,workingVal) count=(long)where; \\\n\t\t\t\t\ttemp=count&3; \\\n\t\t\t\t\twhere-=temp; \\\n\t\t\t\t\tworkingWhere=(CARD32 *)where; \\\n                                        workingVal=READ(workingWhere++); \\\n\t\t\t\t\tcount=4-temp; \\\n\t\t\t\t\tworkingVal>>=(8*temp)\n        #define readPacked(where,x,y,z) {if(!(x)) { (x)=4; y = READ(z++); } where=(y)&0xff; (y)>>=8; (x)--;}\n\t#define readPackedSource(where) readPacked(where,ws,workingSource,wsrc)\n\t#define readPackedDest(where) readPacked(where,wd,workingiDest,widst)\n        #define writePacked(what) workingoDest>>=8; workingoDest|=(what<<24); ww--; if(!ww) { ww=4; WRITE (wodst++, workingoDest); } \n#else\n\t#warning \"I havn't tested fbCompositeTrans_0888xnx0888() on big endian yet!\"\n\t#define setupPackedReader(count,temp,where,workingWhere,workingVal) count=(long)where; \\\n\t\t\t\t\ttemp=count&3; \\\n\t\t\t\t\twhere-=temp; \\\n\t\t\t\t\tworkingWhere=(CARD32 *)where; \\\n                                        workingVal=READ(workingWhere++); \\\n\t\t\t\t\tcount=4-temp; \\\n\t\t\t\t\tworkingVal<<=(8*temp)\n        #define readPacked(where,x,y,z) {if(!(x)) { (x)=4; y = READ(z++); } where=(y)>>24; (y)<<=8; (x)--;}\n\t#define readPackedSource(where) readPacked(where,ws,workingSource,wsrc)\n\t#define readPackedDest(where) readPacked(where,wd,workingiDest,widst)\n        #define writePacked(what) workingoDest<<=8; workingoDest|=what; ww--; if(!ww) { ww=4; WRITE(wodst++, workingoDest); } \n#endif\n\n/*\n * Naming convention:\n *\n *  opSRCxMASKxDST\n */\n\nvoid\nfbCompositeSolidMask_nx8x8888 (CARD8      op,\n\t\t\t       PicturePtr pSrc,\n\t\t\t       PicturePtr pMask,\n\t\t\t       PicturePtr pDst,\n\t\t\t       INT16      xSrc,\n\t\t\t       INT16      ySrc,\n\t\t\t       INT16      xMask,\n\t\t\t       INT16      yMask,\n\t\t\t       INT16      xDst,\n\t\t\t       INT16      yDst,\n\t\t\t       CARD16     width,\n\t\t\t       CARD16     height)\n{\n    CARD32\tsrc, srca;\n    CARD32\t*dstLine, *dst, d, dstMask;\n    CARD8\t*maskLine, *mask, m;\n    FbStride\tdstStride, maskStride;\n    CARD16\tw;\n\n    fbComposeGetSolid(pSrc, src, pDst->format);\n\n    dstMask = FbFullMask (pDst->pDrawable->depth);\n    srca = src >> 24;\n    if (src == 0)\n\treturn;\n\n    fbComposeGetStart (pDst, xDst, yDst, CARD32, dstStride, dstLine, 1);\n    fbComposeGetStart (pMask, xMask, yMask, CARD8, maskStride, maskLine, 1);\n\n    while (height--)\n    {\n\tdst = dstLine;\n\tdstLine += dstStride;\n\tmask = maskLine;\n\tmaskLine += maskStride;\n\tw = width;\n\n\twhile (w--)\n\t{\n\t    m = READ(mask++);\n\t    if (m == 0xff)\n\t    {\n\t\tif (srca == 0xff)\n\t\t    WRITE(dst, src & dstMask);\n\t\telse\n\t\t    WRITE(dst, fbOver (src, READ(dst)) & dstMask);\n\t    }\n\t    else if (m)\n\t    {\n\t\td = fbIn (src, m);\n\t\tWRITE(dst, fbOver (d, READ(dst)) & dstMask);\n\t    }\n\t    dst++;\n\t}\n    }\n\n    fbFinishAccess (pMask->pDrawable);\n    fbFinishAccess (pDst->pDrawable);\n}\n\nvoid\nfbCompositeSolidMask_nx8888x8888C (CARD8      op,\n\t\t\t\t   PicturePtr pSrc,\n\t\t\t\t   PicturePtr pMask,\n\t\t\t\t   PicturePtr pDst,\n\t\t\t\t   INT16      xSrc,\n\t\t\t\t   INT16      ySrc,\n\t\t\t\t   INT16      xMask,\n\t\t\t\t   INT16      yMask,\n\t\t\t\t   INT16      xDst,\n\t\t\t\t   INT16      yDst,\n\t\t\t\t   CARD16     width,\n\t\t\t\t   CARD16     height)\n{\n    CARD32\tsrc, srca;\n    CARD32\t*dstLine, *dst, d, dstMask;\n    CARD32\t*maskLine, *mask, ma;\n    FbStride\tdstStride, maskStride;\n    CARD16\tw;\n    CARD32\tm, n, o, p;\n\n    fbComposeGetSolid(pSrc, src, pDst->format);\n\n    dstMask = FbFullMask (pDst->pDrawable->depth);\n    srca = src >> 24;\n    if (src == 0)\n\treturn;\n\n    fbComposeGetStart (pDst, xDst, yDst, CARD32, dstStride, dstLine, 1);\n    fbComposeGetStart (pMask, xMask, yMask, CARD32, maskStride, maskLine, 1);\n\n    while (height--)\n    {\n\tdst = dstLine;\n\tdstLine += dstStride;\n\tmask = maskLine;\n\tmaskLine += maskStride;\n\tw = width;\n\n\twhile (w--)\n\t{\n\t    ma = READ(mask++);\n\t    if (ma == 0xffffffff)\n\t    {\n\t\tif (srca == 0xff)\n\t\t    WRITE(dst, src & dstMask);\n\t\telse\n\t\t    WRITE(dst, fbOver (src, READ(dst)) & dstMask);\n\t    }\n\t    else if (ma)\n\t    {\n\t\td = READ(dst);\n#define FbInOverC(src,srca,msk,dst,i,result) { \\\n    CARD16  __a = FbGet8(msk,i); \\\n    CARD32  __t, __ta; \\\n    CARD32  __i; \\\n    __t = FbIntMult (FbGet8(src,i), __a,__i); \\\n    __ta = (CARD8) ~FbIntMult (srca, __a,__i); \\\n    __t = __t + FbIntMult(FbGet8(dst,i),__ta,__i); \\\n    __t = (CARD32) (CARD8) (__t | (-(__t >> 8))); \\\n    result = __t << (i); \\\n}\n\t\tFbInOverC (src, srca, ma, d, 0, m);\n\t\tFbInOverC (src, srca, ma, d, 8, n);\n\t\tFbInOverC (src, srca, ma, d, 16, o);\n\t\tFbInOverC (src, srca, ma, d, 24, p);\n\t\tWRITE(dst, m|n|o|p);\n\t    }\n\t    dst++;\n\t}\n    }\n\n    fbFinishAccess (pMask->pDrawable);\n    fbFinishAccess (pDst->pDrawable);\n}\n\n#define srcAlphaCombine24(a,b) genericCombine24(a,b,srca,srcia)\nvoid\nfbCompositeSolidMask_nx8x0888 (CARD8      op,\n\t\t\t       PicturePtr pSrc,\n\t\t\t       PicturePtr pMask,\n\t\t\t       PicturePtr pDst,\n\t\t\t       INT16      xSrc,\n\t\t\t       INT16      ySrc,\n\t\t\t       INT16      xMask,\n\t\t\t       INT16      yMask,\n\t\t\t       INT16      xDst,\n\t\t\t       INT16      yDst,\n\t\t\t       CARD16     width,\n\t\t\t       CARD16     height)\n{\n    CARD32\tsrc, srca, srcia;\n    CARD8\t*dstLine, *dst, *edst;\n    CARD8\t*maskLine, *mask, m;\n    FbStride\tdstStride, maskStride;\n    CARD16\tw;\n    CARD32 rs,gs,bs,rd,gd,bd;\n\n    fbComposeGetSolid(pSrc, src, pDst->format);\n\n    srca = src >> 24;\n    srcia = 255-srca;\n    if (src == 0)\n\treturn;\n\n    rs=src&0xff;\n    gs=(src>>8)&0xff;\n    bs=(src>>16)&0xff;\n      \n    fbComposeGetStart (pDst, xDst, yDst, CARD8, dstStride, dstLine, 3);\n    fbComposeGetStart (pMask, xMask, yMask, CARD8, maskStride, maskLine, 1);\n\n    while (height--)\n    {\n\t/* fixme: cleanup unused */\n\tunsigned long wt, wd;\n\tCARD32 workingiDest;\n\tCARD32 *widst;\n \t\n\tedst = dst = dstLine;\n\tdstLine += dstStride;\n\tmask = maskLine;\n\tmaskLine += maskStride;\n\tw = width;\n \t\n#ifndef NO_MASKED_PACKED_READ\n\tsetupPackedReader(wd,wt,edst,widst,workingiDest);\n#endif\n \t\n\twhile (w--)\n\t{\n#ifndef NO_MASKED_PACKED_READ\n\t    readPackedDest(rd);\n\t    readPackedDest(gd);\n\t    readPackedDest(bd);\n#else\n\t    rd = READ(edst++);\n\t    gd = READ(edst++);\n\t    bd = READ(edst++);\n#endif\n\t    m = READ(mask++);\n\t    if (m == 0xff)\n\t    {\n\t\tif (srca == 0xff)\n\t\t{\n\t\t    WRITE(dst++, rs);\n\t\t    WRITE(dst++, gs);\n\t\t    WRITE(dst++, bs);\n\t\t}\n\t\telse\n\t\t{\n\t\t    WRITE(dst++, (srcAlphaCombine24(rs, rd)>>8));\n\t\t    WRITE(dst++, (srcAlphaCombine24(gs, gd)>>8));\n\t\t    WRITE(dst++, (srcAlphaCombine24(bs, bd)>>8));\n\t\t}\n\t    }\n\t    else if (m)\n\t    {\n\t\tint na=(srca*(int)m)>>8;\n\t\tint nia=255-na;\n\t\tWRITE(dst++, (genericCombine24(rs, rd, na, nia)>>8));\n\t\tWRITE(dst++, (genericCombine24(gs, gd, na, nia)>>8));\n\t\tWRITE(dst++, (genericCombine24(bs, bd, na, nia)>>8));\n\t    }\n\t    else\n\t    {\n\t\tdst+=3;\n\t    }\n\t}\n    }\n    \n    fbFinishAccess (pMask->pDrawable);\n    fbFinishAccess (pDst->pDrawable);\n}\n\nvoid\nfbCompositeSolidMask_nx8x0565 (CARD8      op,\n\t\t\t\t  PicturePtr pSrc,\n\t\t\t\t  PicturePtr pMask,\n\t\t\t\t  PicturePtr pDst,\n\t\t\t\t  INT16      xSrc,\n\t\t\t\t  INT16      ySrc,\n\t\t\t\t  INT16      xMask,\n\t\t\t\t  INT16      yMask,\n\t\t\t\t  INT16      xDst,\n\t\t\t\t  INT16      yDst,\n\t\t\t\t  CARD16     width,\n\t\t\t\t  CARD16     height)\n{\n    CARD32\tsrc, srca8, srca5;\n    CARD16\t*dstLine, *dst;\n    CARD16\td;\n    CARD32\tt;\n    CARD8\t*maskLine, *mask, m;\n    FbStride\tdstStride, maskStride;\n    CARD16\tw,src16;\n    \n    fbComposeGetSolid(pSrc, src, pDst->format);\n    \n    if (src == 0)\n\treturn;\n      \n    srca8 = (src >> 24);\n    srca5 = (srca8 >> 3);\n    src16 = cvt8888to0565(src);\n     \n    fbComposeGetStart (pDst, xDst, yDst, CARD16, dstStride, dstLine, 1);\n    fbComposeGetStart (pMask, xMask, yMask, CARD8, maskStride, maskLine, 1);\n    \n    while (height--)\n    {\n\tdst = dstLine;\n\tdstLine += dstStride;\n\tmask = maskLine;\n\tmaskLine += maskStride;\n\tw = width;\n \n\twhile (w--)\n\t{\n\t    m = READ(mask++);\n\t    if (m == 0)\n\t\tdst++;\n\t    else if (srca5 == (0xff >> 3))\n\t    {\n\t\tif (m == 0xff)\n\t\t    WRITE(dst++, src16);\n\t\telse \n \t\t{\n\t\t    d = READ(dst);\n\t\t    m >>= 3;\n\t\t    inOver0565 (m, src16, d, dst++);\n \t\t}\n\t    }\n\t    else\n\t    {\n\t\td = READ(dst);\n\t\tif (m == 0xff) \n\t\t{\n\t\t    t = fbOver24 (src, cvt0565to0888 (d));\n\t\t}\n\t\telse\n\t\t{\n\t\t    t = fbIn (src, m);\n\t\t    t = fbOver (t, cvt0565to0888 (d));\n\t\t}\n\t\tWRITE(dst++, cvt8888to0565 (t));\n\t    }\n\t}\n    }\n    \n    fbFinishAccess (pMask->pDrawable);\n    fbFinishAccess (pDst->pDrawable);\n}\n\nstatic void\nfbCompositeSolidMask_nx8888x0565 (CARD8      op,\n\t\t\t\t  PicturePtr pSrc,\n\t\t\t\t  PicturePtr pMask,\n\t\t\t\t  PicturePtr pDst,\n\t\t\t\t  INT16      xSrc,\n\t\t\t\t  INT16      ySrc,\n\t\t\t\t  INT16      xMask,\n\t\t\t\t  INT16      yMask,\n\t\t\t\t  INT16      xDst,\n\t\t\t\t  INT16      yDst,\n\t\t\t\t  CARD16     width,\n\t\t\t\t  CARD16     height)\n{\n    CARD32\tsrc, srca8, srca5;\n    CARD16\t*dstLine, *dst;\n    CARD16\td;\n    CARD32\t*maskLine, *mask;\n    CARD32\tt;\n    CARD8\tm;\n    FbStride\tdstStride, maskStride;\n    CARD16\tw, src16;\n\n    fbComposeGetSolid(pSrc, src, pDst->format);\n\n    if (src == 0)\n\treturn;\n\n    srca8 = src >> 24;\n    srca5 = srca8 >> 3;\n    src16 = cvt8888to0565(src);\n\n    fbComposeGetStart (pDst, xDst, yDst, CARD16, dstStride, dstLine, 1);\n    fbComposeGetStart (pMask, xMask, yMask, CARD32, maskStride, maskLine, 1);\n\n    while (height--)\n    {\n\tdst = dstLine;\n\tdstLine += dstStride;\n\tmask = maskLine;\n\tmaskLine += maskStride;\n\tw = width;\n\n\twhile (w--)\n\t{\n\t    m = READ(mask++) >> 24;\n\t    if (m == 0)\n\t\tdst++;\n\t    else if (srca5 == (0xff >> 3))\n\t    {\n\t\tif (m == 0xff)\n\t\t    WRITE(dst++, src16);\n\t\telse\n\t\t{\n\t\t    d = READ(dst);\n\t\t    m >>= 3;\n\t\t    inOver0565 (m, src16, d, dst++);\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tif (m == 0xff) \n\t\t{\n\t\t    d = READ(dst);\n\t\t    t = fbOver24 (src, cvt0565to0888 (d));\n\t\t    WRITE(dst++, cvt8888to0565 (t));\n\t\t}\n\t\telse\n\t\t{\n\t\t    d = READ(dst);\n\t\t    t = fbIn (src, m);\n\t\t    t = fbOver (t, cvt0565to0888 (d));\n\t\t    WRITE(dst++, cvt8888to0565 (t));\n\t\t}\n\t    }\n\t}\n    }\n}\n\nvoid\nfbCompositeSolidMask_nx8888x0565C (CARD8      op,\n\t\t\t\t   PicturePtr pSrc,\n\t\t\t\t   PicturePtr pMask,\n\t\t\t\t   PicturePtr pDst,\n\t\t\t\t   INT16      xSrc,\n\t\t\t\t   INT16      ySrc,\n\t\t\t\t   INT16      xMask,\n\t\t\t\t   INT16      yMask,\n\t\t\t\t   INT16      xDst,\n\t\t\t\t   INT16      yDst,\n\t\t\t\t   CARD16     width,\n\t\t\t\t   CARD16     height)\n{\n    CARD32\tsrc, srca;\n    CARD16\tsrc16;\n    CARD16\t*dstLine, *dst;\n    CARD32\td;\n    CARD32\t*maskLine, *mask, ma;\n    FbStride\tdstStride, maskStride;\n    CARD16\tw;\n    CARD32\tm, n, o;\n\n    fbComposeGetSolid(pSrc, src, pDst->format);\n\n    srca = src >> 24;\n    if (src == 0)\n\treturn;\n\n    src16 = cvt8888to0565(src);\n\n    fbComposeGetStart (pDst, xDst, yDst, CARD16, dstStride, dstLine, 1);\n    fbComposeGetStart (pMask, xMask, yMask, CARD32, maskStride, maskLine, 1);\n\n    while (height--)\n    {\n\tdst = dstLine;\n\tdstLine += dstStride;\n\tmask = maskLine;\n\tmaskLine += maskStride;\n\tw = width;\n\n\twhile (w--)\n\t{\n\t    ma = READ(mask++);\n\t    if (ma == 0xffffffff)\n\t    {\n\t\tif (srca == 0xff)\n\t\t{\n\t\t    WRITE(dst, src16);\n\t\t}\n\t\telse\n\t\t{\n\t\t    d = READ(dst);\n\t\t    d = fbOver24 (src, cvt0565to0888(d));\n\t\t    WRITE(dst, cvt8888to0565(d));\n\t\t}\n\t    }\n\t    else if (ma)\n\t    {\n\t\td = READ(dst);\n\t\td = cvt0565to0888(d);\n\t\tFbInOverC (src, srca, ma, d, 0, m);\n\t\tFbInOverC (src, srca, ma, d, 8, n);\n\t\tFbInOverC (src, srca, ma, d, 16, o);\n\t\td = m|n|o;\n\t\tWRITE(dst, cvt8888to0565(d));\n\t    }\n\t    dst++;\n\t}\n    }\n\n    fbFinishAccess (pMask->pDrawable);\n    fbFinishAccess (pDst->pDrawable);\n}\n\nvoid\nfbCompositeSrc_8888x8888 (CARD8      op,\n\t\t\t PicturePtr pSrc,\n\t\t\t PicturePtr pMask,\n\t\t\t PicturePtr pDst,\n\t\t\t INT16      xSrc,\n\t\t\t INT16      ySrc,\n\t\t\t INT16      xMask,\n\t\t\t INT16      yMask,\n\t\t\t INT16      xDst,\n\t\t\t INT16      yDst,\n\t\t\t CARD16     width,\n\t\t\t CARD16     height)\n{\n    CARD32\t*dstLine, *dst, dstMask;\n    CARD32\t*srcLine, *src, s;\n    FbStride\tdstStride, srcStride;\n    CARD8\ta;\n    CARD16\tw;\n\n    fbComposeGetStart (pDst, xDst, yDst, CARD32, dstStride, dstLine, 1);\n    fbComposeGetStart (pSrc, xSrc, ySrc, CARD32, srcStride, srcLine, 1);\n\n    dstMask = FbFullMask (pDst->pDrawable->depth);\n\n    while (height--)\n    {\n\tdst = dstLine;\n\tdstLine += dstStride;\n\tsrc = srcLine;\n\tsrcLine += srcStride;\n\tw = width;\n\n\twhile (w--)\n\t{\n\t    s = READ(src++);\n\t    a = s >> 24;\n\t    if (a == 0xff)\n\t\tWRITE(dst, s & dstMask);\n\t    else if (a)\n\t\tWRITE(dst, fbOver (s, READ(dst)) & dstMask);\n\t    dst++;\n\t}\n    }\n\n    fbFinishAccess (pSrc->pDrawable);\n    fbFinishAccess (pDst->pDrawable);\n}\n\nvoid\nfbCompositeSrc_8888x0888 (CARD8      op,\n\t\t\t PicturePtr pSrc,\n\t\t\t PicturePtr pMask,\n\t\t\t PicturePtr pDst,\n\t\t\t INT16      xSrc,\n\t\t\t INT16      ySrc,\n\t\t\t INT16      xMask,\n\t\t\t INT16      yMask,\n\t\t\t INT16      xDst,\n\t\t\t INT16      yDst,\n\t\t\t CARD16     width,\n\t\t\t CARD16     height)\n{\n    CARD8\t*dstLine, *dst;\n    CARD32\td;\n    CARD32\t*srcLine, *src, s;\n    CARD8\ta;\n    FbStride\tdstStride, srcStride;\n    CARD16\tw;\n\n    fbComposeGetStart (pDst, xDst, yDst, CARD8, dstStride, dstLine, 3);\n    fbComposeGetStart (pSrc, xSrc, ySrc, CARD32, srcStride, srcLine, 1);\n\n    while (height--)\n    {\n\tdst = dstLine;\n\tdstLine += dstStride;\n\tsrc = srcLine;\n\tsrcLine += srcStride;\n\tw = width;\n\n\twhile (w--)\n\t{\n\t    s = READ(src++);\n\t    a = s >> 24;\n\t    if (a)\n\t    {\n\t\tif (a == 0xff)\n\t\t    d = s;\n\t\telse\n\t\t    d = fbOver24 (s, Fetch24(dst));\n\t\tStore24(dst,d);\n\t    }\n\t    dst += 3;\n\t}\n    }\n\n    fbFinishAccess (pSrc->pDrawable);\n    fbFinishAccess (pDst->pDrawable);\n}\n\nvoid\nfbCompositeSrc_8888x0565 (CARD8      op,\n\t\t\t PicturePtr pSrc,\n\t\t\t PicturePtr pMask,\n\t\t\t PicturePtr pDst,\n\t\t\t INT16      xSrc,\n\t\t\t INT16      ySrc,\n\t\t\t INT16      xMask,\n\t\t\t INT16      yMask,\n\t\t\t INT16      xDst,\n\t\t\t INT16      yDst,\n\t\t\t CARD16     width,\n\t\t\t CARD16     height)\n{\n    CARD16\t*dstLine, *dst;\n    CARD32\td;\n    CARD32\t*srcLine, *src, s;\n    CARD8\ta;\n    FbStride\tdstStride, srcStride;\n    CARD16\tw;\n\n    fbComposeGetStart (pSrc, xSrc, ySrc, CARD32, srcStride, srcLine, 1);\n    fbComposeGetStart (pDst, xDst, yDst, CARD16, dstStride, dstLine, 1);\n\n    while (height--)\n    {\n\tdst = dstLine;\n\tdstLine += dstStride;\n\tsrc = srcLine;\n\tsrcLine += srcStride;\n\tw = width;\n\n\twhile (w--)\n\t{\n\t    s = READ(src++);\n\t    a = s >> 24;\n\t    if (a)\n\t    {\n\t\tif (a == 0xff)\n\t\t    d = s;\n\t\telse\n\t\t{\n\t\t    d = READ(dst);\n\t\t    d = fbOver24 (s, cvt0565to0888(d));\n\t\t}\n\t\tWRITE(dst, cvt8888to0565(d));\n\t    }\n\t    dst++;\n\t}\n    }\n\n    fbFinishAccess (pDst->pDrawable);\n    fbFinishAccess (pSrc->pDrawable);\n}\n\nvoid\nfbCompositeSrcAdd_8000x8000 (CARD8\top,\n\t\t\t     PicturePtr pSrc,\n\t\t\t     PicturePtr pMask,\n\t\t\t     PicturePtr pDst,\n\t\t\t     INT16      xSrc,\n\t\t\t     INT16      ySrc,\n\t\t\t     INT16      xMask,\n\t\t\t     INT16      yMask,\n\t\t\t     INT16      xDst,\n\t\t\t     INT16      yDst,\n\t\t\t     CARD16     width,\n\t\t\t     CARD16     height)\n{\n    CARD8\t*dstLine, *dst;\n    CARD8\t*srcLine, *src;\n    FbStride\tdstStride, srcStride;\n    CARD16\tw;\n    CARD8\ts, d;\n    CARD16\tt;\n\n    fbComposeGetStart (pSrc, xSrc, ySrc, CARD8, srcStride, srcLine, 1);\n    fbComposeGetStart (pDst, xDst, yDst, CARD8, dstStride, dstLine, 1);\n\n    while (height--)\n    {\n\tdst = dstLine;\n\tdstLine += dstStride;\n\tsrc = srcLine;\n\tsrcLine += srcStride;\n\tw = width;\n\n\twhile (w--)\n\t{\n\t    s = READ(src++);\n\t    if (s)\n\t    {\n\t\tif (s != 0xff)\n\t\t{\n\t\t    d = READ(dst);\n\t\t    t = d + s;\n\t\t    s = t | (0 - (t >> 8));\n\t\t}\n\t\tWRITE(dst, s);\n\t    }\n\t    dst++;\n\t}\n    }\n\n    fbFinishAccess (pDst->pDrawable);\n    fbFinishAccess (pSrc->pDrawable);\n}\n\nvoid\nfbCompositeSrcAdd_8888x8888 (CARD8\top,\n\t\t\t     PicturePtr pSrc,\n\t\t\t     PicturePtr pMask,\n\t\t\t     PicturePtr pDst,\n\t\t\t     INT16      xSrc,\n\t\t\t     INT16      ySrc,\n\t\t\t     INT16      xMask,\n\t\t\t     INT16      yMask,\n\t\t\t     INT16      xDst,\n\t\t\t     INT16      yDst,\n\t\t\t     CARD16     width,\n\t\t\t     CARD16     height)\n{\n    CARD32\t*dstLine, *dst;\n    CARD32\t*srcLine, *src;\n    FbStride\tdstStride, srcStride;\n    CARD16\tw;\n    CARD32\ts, d;\n    CARD16\tt;\n    CARD32\tm,n,o,p;\n\n    fbComposeGetStart (pSrc, xSrc, ySrc, CARD32, srcStride, srcLine, 1);\n    fbComposeGetStart (pDst, xDst, yDst, CARD32, dstStride, dstLine, 1);\n\n    while (height--)\n    {\n\tdst = dstLine;\n\tdstLine += dstStride;\n\tsrc = srcLine;\n\tsrcLine += srcStride;\n\tw = width;\n\n\twhile (w--)\n\t{\n\t    s = READ(src++);\n\t    if (s)\n\t    {\n\t\tif (s != 0xffffffff)\n\t\t{\n\t\t    d = READ(dst);\n\t\t    if (d)\n\t\t    {\n\t\t\tm = FbAdd(s,d,0,t);\n\t\t\tn = FbAdd(s,d,8,t);\n\t\t\to = FbAdd(s,d,16,t);\n\t\t\tp = FbAdd(s,d,24,t);\n\t\t\ts = m|n|o|p;\n\t\t    }\n\t\t}\n\t\tWRITE(dst, s);\n\t    }\n\t    dst++;\n\t}\n    }\n\n    fbFinishAccess (pDst->pDrawable);\n    fbFinishAccess (pSrc->pDrawable);\n}\n\nstatic void\nfbCompositeSrcAdd_8888x8x8 (CARD8      op,\n\t\t\t    PicturePtr pSrc,\n\t\t\t    PicturePtr pMask,\n\t\t\t    PicturePtr pDst,\n\t\t\t    INT16      xSrc,\n\t\t\t    INT16      ySrc,\n\t\t\t    INT16      xMask,\n\t\t\t    INT16      yMask,\n\t\t\t    INT16      xDst,\n\t\t\t    INT16      yDst,\n\t\t\t    CARD16     width,\n\t\t\t    CARD16     height)\n{\n    CARD8\t*dstLine, *dst;\n    CARD8\t*maskLine, *mask;\n    FbStride\tdstStride, maskStride;\n    CARD16\tw;\n    CARD32\tsrc;\n    CARD8\tsa;\n\n    fbComposeGetStart (pDst, xDst, yDst, CARD8, dstStride, dstLine, 1);\n    fbComposeGetStart (pMask, xMask, yMask, CARD8, maskStride, maskLine, 1);\n    fbComposeGetSolid (pSrc, src, pDst->format);\n    sa = (src >> 24);\n\n    while (height--)\n    {\n\tdst = dstLine;\n\tdstLine += dstStride;\n\tmask = maskLine;\n\tmaskLine += maskStride;\n\tw = width;\n\n\twhile (w--)\n\t{\n\t    CARD16\ttmp;\n\t    CARD16\ta;\n\t    CARD32\tm, d;\n\t    CARD32\tr;\n\n\t    a = READ(mask++);\n\t    d = READ(dst);\n\n\t    m = FbInU (sa, 0, a, tmp);\n\t    r = FbAdd (m, d, 0, tmp);\n\n\t    WRITE(dst++, r);\n\t}\n    }\n    \n    fbFinishAccess(pDst->pDrawable);\n    fbFinishAccess(pMask->pDrawable);\n}\n\nvoid\nfbCompositeSrcAdd_1000x1000 (CARD8\top,\n\t\t\t     PicturePtr pSrc,\n\t\t\t     PicturePtr pMask,\n\t\t\t     PicturePtr pDst,\n\t\t\t     INT16      xSrc,\n\t\t\t     INT16      ySrc,\n\t\t\t     INT16      xMask,\n\t\t\t     INT16      yMask,\n\t\t\t     INT16      xDst,\n\t\t\t     INT16      yDst,\n\t\t\t     CARD16     width,\n\t\t\t     CARD16     height)\n{\n    FbBits\t*dstBits, *srcBits;\n    FbStride\tdstStride, srcStride;\n    int\t\tdstBpp, srcBpp;\n    int\t\tdstXoff, dstYoff;\n    int\t\tsrcXoff, srcYoff;\n\n    fbGetDrawable(pSrc->pDrawable, srcBits, srcStride, srcBpp, srcXoff, srcYoff);\n\n    fbGetDrawable(pDst->pDrawable, dstBits, dstStride, dstBpp, dstXoff, dstYoff);\n\n    fbBlt (srcBits + srcStride * (ySrc + srcYoff),\n\t   srcStride,\n\t   xSrc + srcXoff,\n\n\t   dstBits + dstStride * (yDst + dstYoff),\n\t   dstStride,\n\t   xDst + dstXoff,\n\n\t   width,\n\t   height,\n\n\t   GXor,\n\t   FB_ALLONES,\n\t   srcBpp,\n\n\t   FALSE,\n\t   FALSE);\n\n    fbFinishAccess(pDst->pDrawable);\n    fbFinishAccess(pSrc->pDrawable);\n}\n\nvoid\nfbCompositeSolidMask_nx1xn (CARD8      op,\n\t\t\t    PicturePtr pSrc,\n\t\t\t    PicturePtr pMask,\n\t\t\t    PicturePtr pDst,\n\t\t\t    INT16      xSrc,\n\t\t\t    INT16      ySrc,\n\t\t\t    INT16      xMask,\n\t\t\t    INT16      yMask,\n\t\t\t    INT16      xDst,\n\t\t\t    INT16      yDst,\n\t\t\t    CARD16     width,\n\t\t\t    CARD16     height)\n{\n    FbBits\t*dstBits;\n    FbStip\t*maskBits;\n    FbStride\tdstStride, maskStride;\n    int\t\tdstBpp, maskBpp;\n    int\t\tdstXoff, dstYoff;\n    int\t\tmaskXoff, maskYoff;\n    FbBits\tsrc;\n\n    fbComposeGetSolid(pSrc, src, pDst->format);\n    fbGetStipDrawable (pMask->pDrawable, maskBits, maskStride, maskBpp, maskXoff, maskYoff);\n    fbGetDrawable (pDst->pDrawable, dstBits, dstStride, dstBpp, dstXoff, dstYoff);\n\n    switch (dstBpp) {\n    case 32:\n\tbreak;\n    case 24:\n\tbreak;\n    case 16:\n\tsrc = cvt8888to0565(src);\n\tbreak;\n    }\n\n    src = fbReplicatePixel (src, dstBpp);\n\n    fbBltOne (maskBits + maskStride * (yMask + maskYoff),\n\t      maskStride,\n\t      xMask + maskXoff,\n\n\t      dstBits + dstStride * (yDst + dstYoff),\n\t      dstStride,\n\t      (xDst + dstXoff) * dstBpp,\n\t      dstBpp,\n\n\t      width * dstBpp,\n\t      height,\n\n\t      0x0,\n\t      src,\n\t      FB_ALLONES,\n\t      0x0);\n\n    fbFinishAccess (pDst->pDrawable);\n    fbFinishAccess (pMask->pDrawable);\n}\n\n# define mod(a,b)\t((b) == 1 ? 0 : (a) >= 0 ? (a) % (b) : (b) - (-a) % (b))\n\n/*\n * Apply a constant alpha value in an over computation\n */\nstatic void\nfbCompositeSrcSrc_nxn  (CARD8\t   op,\n\t\t\tPicturePtr pSrc,\n\t\t\tPicturePtr pMask,\n\t\t\tPicturePtr pDst,\n\t\t\tINT16      xSrc,\n\t\t\tINT16      ySrc,\n\t\t\tINT16      xMask,\n\t\t\tINT16      yMask,\n\t\t\tINT16      xDst,\n\t\t\tINT16      yDst,\n\t\t\tCARD16     width,\n\t\t\tCARD16     height);\n\nstatic void\nfbCompositeTrans_0565xnx0565(CARD8      op,\n\t\t\t     PicturePtr pSrc,\n\t\t\t     PicturePtr pMask,\n\t\t\t     PicturePtr pDst,\n\t\t\t     INT16      xSrc,\n\t\t\t     INT16      ySrc,\n\t\t\t     INT16      xMask,\n\t\t\t     INT16      yMask,\n\t\t\t     INT16      xDst,\n\t\t\t     INT16      yDst,\n\t\t\t     CARD16     width,\n\t\t\t     CARD16     height)\n{\n    CARD16\t*dstLine, *dst;\n    CARD16\t*srcLine, *src;\n    FbStride\tdstStride, srcStride;\n    CARD16\tw;\n    FbBits\tmask;\n    CARD8\tmaskAlpha;\n    CARD16\ts_16, d_16;\n    CARD32\ts_32, d_32;\n    \n    fbComposeGetSolid (pMask, mask, pDst->format);\n    maskAlpha = mask >> 27;\n    \n    if (!maskAlpha)\n\treturn;\n    if (maskAlpha == 0xff)\n    {\n\tfbCompositeSrcSrc_nxn (PictOpSrc, pSrc, pMask, pDst,\n\t\t\t       xSrc, ySrc, xMask, yMask, xDst, yDst, \n\t\t\t       width, height);\n\treturn;\n    }\n\n    fbComposeGetStart (pSrc, xSrc, ySrc, CARD16, srcStride, srcLine, 1);\n    fbComposeGetStart (pDst, xDst, yDst, CARD16, dstStride, dstLine, 1);\n\n    while (height--)\n    {\n\tCARD32 *isrc, *idst;\n\tdst = dstLine;\n\tdstLine += dstStride;\n\tsrc = srcLine;\n\tsrcLine += srcStride;\n\tw = width;\n\t\n\tif(((long)src&1)==1)\n\t{\n\t    s_16 = READ(src++);\n\t    d_16 = READ(dst);\n\t    inOver0565(maskAlpha, s_16, d_16, dst++);\n\t    w--;\n\t}\n\tisrc=(CARD32 *)src;\n\tif(((long)dst&1)==0)\n\t{\n\t    idst=(CARD32 *)dst;\n\t    while (w>1)\n\t    {\n\t\ts_32 = READ(isrc++);\n\t\td_32 = READ(idst);\n\t\tinOver2x0565(maskAlpha, s_32, d_32, idst++);\n\t\tw-=2;\n\t    }\n\t    dst=(CARD16 *)idst;\n\t}\n\telse\n\t{\n\t    while (w > 1)\n\t    {\n\t\ts_32 = READ(isrc++);\n#if IMAGE_BYTE_ORDER == LSBFirst\n\t\ts_16=s_32&0xffff;\n#else\n\t\ts_16=s_32>>16;\n#endif\n\t\td_16 = READ(dst);\n\t\tinOver0565 (maskAlpha, s_16, d_16, dst++);\n#if IMAGE_BYTE_ORDER == LSBFirst\n\t\ts_16=s_32>>16;\n#else\n\t\ts_16=s_32&0xffff;\n#endif\n\t\td_16 = READ(dst);\n\t\tinOver0565(maskAlpha, s_16, d_16, dst++);\n\t\tw-=2;\n\t    }\n\t}\n\tsrc=(CARD16 *)isrc;\n\tif(w!=0)\n\t{\n\t    s_16 = READ(src);\n\t    d_16 = READ(dst);\n\t    inOver0565(maskAlpha, s_16, d_16, dst);\n\t}\n    }\n    \n    fbFinishAccess (pSrc->pDrawable);\n    fbFinishAccess (pDst->pDrawable);\n}\n\n/* macros for \"i can't believe it's not fast\" packed pixel handling */\n#define alphamaskCombine24(a,b) genericCombine24(a,b,maskAlpha,maskiAlpha)\n\nstatic void\nfbCompositeTrans_0888xnx0888(CARD8      op,\n \t\t\t     PicturePtr pSrc,\n \t\t\t     PicturePtr pMask,\n \t\t\t     PicturePtr pDst,\n \t\t\t     INT16      xSrc,\n \t\t\t     INT16      ySrc,\n \t\t\t     INT16      xMask,\n \t\t\t     INT16      yMask,\n \t\t\t     INT16      xDst,\n \t\t\t     INT16      yDst,\n \t\t\t     CARD16     width,\n \t\t\t     CARD16     height)\n{\n    CARD8\t*dstLine, *dst,*idst;\n    CARD8\t*srcLine, *src;\n    FbStride\tdstStride, srcStride;\n    CARD16\tw;\n    FbBits\tmask;\n    CARD16\tmaskAlpha,maskiAlpha;\n    \n    fbComposeGetSolid (pMask, mask, pDst->format);\n    maskAlpha = mask >> 24;\n    maskiAlpha= 255-maskAlpha;\n    \n    if (!maskAlpha)\n \treturn;\n    /*\n      if (maskAlpha == 0xff)\n      {\n      fbCompositeSrc_0888x0888 (op, pSrc, pMask, pDst,\n      xSrc, ySrc, xMask, yMask, xDst, yDst, \n      width, height);\n      return;\n      }\n    */\n    \n    fbComposeGetStart (pSrc, xSrc, ySrc, CARD8, srcStride, srcLine, 3);\n    fbComposeGetStart (pDst, xDst, yDst, CARD8, dstStride, dstLine, 3);\n    \n    {\n\tunsigned long ws,wt;\n\tCARD32 workingSource;\n\tCARD32 *wsrc, *wdst, *widst;\n\tCARD32 rs, rd, nd;\n\tCARD8 *isrc;\n\t\n\t\n\t/* are xSrc and xDst at the same alignment?  if not, we need to be complicated :) */\n\t/* if(0==0) */\n\tif ((((xSrc * 3) & 3) != ((xDst * 3) & 3)) ||\n\t    ((srcStride & 3) != (dstStride & 3)))\n\t{\n\t    while (height--)\n\t    {\n\t\tdst = dstLine;\n\t\tdstLine += dstStride;\n\t\tisrc = src = srcLine;\n\t\tsrcLine += srcStride;\n\t\tw = width*3;\n\t\t\n\t\tsetupPackedReader(ws,wt,isrc,wsrc,workingSource);\n\t\t\n\t\t/* get to word aligned */\n\t\tswitch(~(long)dst&3)\n\t\t{\n\t\tcase 1:\n\t\t    readPackedSource(rs);\n\t\t    /* *dst++=alphamaskCombine24(rs, *dst)>>8; */\n\t\t    rd = READ(dst);  /* make gcc happy.  hope it doens't cost us too much performance*/\n\t\t    WRITE(dst++, alphamaskCombine24(rs, rd) >> 8);\n\t\t    w--; if(w==0) break;\n\t\tcase 2:\n\t\t    readPackedSource(rs);\n\t\t    rd = READ(dst);\n\t\t    WRITE(dst++, alphamaskCombine24(rs, rd) >> 8);\n\t\t    w--; if(w==0) break;\n\t\tcase 3:\n\t\t    readPackedSource(rs);\n\t\t    rd = READ(dst);\n\t\t    WRITE(dst++,alphamaskCombine24(rs, rd) >> 8);\n\t\t    w--; if(w==0) break;\n\t\t}\n\t\twdst=(CARD32 *)dst;\n\t\twhile (w>3)\n\t\t{\n\t\t    rs=READ(wsrc++);\n\t\t    /* FIXME: write a special readPackedWord macro, which knows how to \n\t\t     * halfword combine\n\t\t     */\n#if IMAGE_BYTE_ORDER == LSBFirst\n\t\t    rd=READ(wdst);\n\t\t    readPackedSource(nd);\n\t\t    readPackedSource(rs);\n\t\t    nd|=rs<<8;\n\t\t    readPackedSource(rs);\n\t\t    nd|=rs<<16;\n\t\t    readPackedSource(rs);\n\t\t    nd|=rs<<24;\n#else\n\t\t    readPackedSource(nd);\n\t\t    nd<<=24;\n\t\t    readPackedSource(rs);\n\t\t    nd|=rs<<16;\n\t\t    readPackedSource(rs);\n\t\t    nd|=rs<<8;\n\t\t    readPackedSource(rs);\n\t\t    nd|=rs;\n#endif\n\t\t    inOver0888(maskAlpha, nd, rd, wdst++);\n\t\t    w-=4;\n\t\t}\n\t\tsrc=(CARD8 *)wdst;\n\t\tswitch(w)\n\t\t{\n\t\tcase 3:\n\t\t    readPackedSource(rs);\n\t\t    rd=READ(dst);\n\t\t    WRITE(dst++,alphamaskCombine24(rs, rd)>>8);\n\t\tcase 2:\n\t\t    readPackedSource(rs);\n\t\t    rd = READ(dst);  \n\t\t    WRITE(dst++, alphamaskCombine24(rs, rd)>>8);\n\t\tcase 1:\n\t\t    readPackedSource(rs);\n\t\t    rd = READ(dst);  \n\t\t    WRITE(dst++, alphamaskCombine24(rs, rd)>>8);\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    while (height--)\n\t    {\n\t\tidst=dst = dstLine;\n\t\tdstLine += dstStride;\n\t\tsrc = srcLine;\n\t\tsrcLine += srcStride;\n\t\tw = width*3;\n\t\t/* get to word aligned */\n\t\tswitch(~(long)src&3)\n\t\t{\n\t\tcase 1:\n\t\t    rd=alphamaskCombine24(READ(src++), READ(dst))>>8;\n\t\t    WRITE(dst++, rd);\n\t\t    w--; if(w==0) break;\n\t\tcase 2:\n\t\t    rd=alphamaskCombine24(READ(src++), READ(dst))>>8;\n\t\t    WRITE(dst++, rd);\n\t\t    w--; if(w==0) break;\n\t\tcase 3:\n\t\t    rd=alphamaskCombine24(READ(src++), READ(dst))>>8;\n\t\t    WRITE(dst++, rd);\n\t\t    w--; if(w==0) break;\n\t\t}\n\t\twsrc=(CARD32 *)src;\n\t\twidst=(CARD32 *)dst;\n\t\twhile(w>3)\n\t\t{\n\t\t    rs = READ(wsrc++);\n\t\t    rd = READ(widst);\n\t\t    inOver0888 (maskAlpha, rs, rd, widst++);\n\t\t    w-=4;\n\t\t}\n\t\tsrc=(CARD8 *)wsrc;\n\t\tdst=(CARD8 *)widst;\n\t\tswitch(w)\n\t\t{\n\t\tcase 3:\n\t\t    rd=alphamaskCombine24(READ(src++), READ(dst))>>8;\n\t\t    WRITE(dst++, rd);\n\t\tcase 2:\n\t\t    rd=alphamaskCombine24(READ(src++), READ(dst))>>8;\n\t\t    WRITE(dst++, rd);\n\t\tcase 1:\n\t\t    rd=alphamaskCombine24(READ(src++), READ(dst))>>8;\n\t\t    WRITE(dst++, rd);\n\t\t}\n\t    }\n\t}\n    }\n}\n\n/*\n * Simple bitblt\n */\n\nstatic void\nfbCompositeSrcSrc_nxn  (CARD8\t   op,\n\t\t\tPicturePtr pSrc,\n\t\t\tPicturePtr pMask,\n\t\t\tPicturePtr pDst,\n\t\t\tINT16      xSrc,\n\t\t\tINT16      ySrc,\n\t\t\tINT16      xMask,\n\t\t\tINT16      yMask,\n\t\t\tINT16      xDst,\n\t\t\tINT16      yDst,\n\t\t\tCARD16     width,\n\t\t\tCARD16     height)\n{\n    FbBits\t*dst;\n    FbBits\t*src;\n    FbStride\tdstStride, srcStride;\n    int\t\tsrcXoff, srcYoff;\n    int\t\tdstXoff, dstYoff;\n    int\t\tsrcBpp;\n    int\t\tdstBpp;\n    Bool\treverse = FALSE;\n    Bool\tupsidedown = FALSE;\n    \n    fbGetDrawable(pSrc->pDrawable,src,srcStride,srcBpp,srcXoff,srcYoff);\n    fbGetDrawable(pDst->pDrawable,dst,dstStride,dstBpp,dstXoff,dstYoff);\n\t\n    fbBlt (src + (ySrc + srcYoff) * srcStride,\n\t   srcStride,\n\t   (xSrc + srcXoff) * srcBpp,\n \n\t   dst + (yDst + dstYoff) * dstStride,\n\t   dstStride,\n\t   (xDst + dstXoff) * dstBpp,\n\n\t   (width) * dstBpp,\n\t   (height),\n\n\t   GXcopy,\n\t   FB_ALLONES,\n\t   dstBpp,\n\n\t   reverse,\n\t   upsidedown);\n    \n    fbFinishAccess(pSrc->pDrawable);\n    fbFinishAccess(pDst->pDrawable);\n}\n\n/*\n * Solid fill\nvoid\nfbCompositeSolidSrc_nxn  (CARD8\top,\n\t\t\t  PicturePtr pSrc,\n\t\t\t  PicturePtr pMask,\n\t\t\t  PicturePtr pDst,\n\t\t\t  INT16      xSrc,\n\t\t\t  INT16      ySrc,\n\t\t\t  INT16      xMask,\n\t\t\t  INT16      yMask,\n\t\t\t  INT16      xDst,\n\t\t\t  INT16      yDst,\n\t\t\t  CARD16     width,\n\t\t\t  CARD16     height)\n{\n    \n}\n */\n\n#define SCANLINE_BUFFER_LENGTH 2048\n \nstatic void\nfbCompositeRectWrapper  (CARD8\t   op,\n\t\t\t PicturePtr pSrc,\n\t\t\t PicturePtr pMask,\n\t\t\t PicturePtr pDst,\n\t\t\t INT16      xSrc,\n\t\t\t INT16      ySrc,\n\t\t\t INT16      xMask,\n\t\t\t INT16      yMask,\n\t\t\t INT16      xDst,\n\t\t\t INT16      yDst,\n\t\t\t CARD16     width,\n\t\t\t CARD16     height)\n{\n    CARD32 _scanline_buffer[SCANLINE_BUFFER_LENGTH * 3];\n    CARD32 *scanline_buffer = _scanline_buffer;\n    FbComposeData data;\n\n    data.op = op;\n    data.src = pSrc;\n    data.mask = pMask;\n    data.dest = pDst;\n    data.xSrc = xSrc;\n    data.ySrc = ySrc;\n    data.xMask = xMask;\n }\n \n void\n fbComposite (CARD8      op,\n \t     PicturePtr pSrc,\n \t     PicturePtr pMask,\n\t\t\tcase PICT_x8r8g8b8:\n\t\t\tcase PICT_a8b8g8r8:\n\t\t\tcase PICT_x8b8g8r8:\n#ifdef USE_MMX\n\t\t\t    if (fbHaveMMX())\n\t\t\t\tfunc = fbCompositeSolidMask_nx8x8888mmx;\n\t\t\t    else\n \t     CARD16     width,\n \t     CARD16     height)\n {\n    RegionRec\t    region;\n    int\t\t    n;\n    BoxPtr\t    pbox;\n    CompositeFunc   func = NULL;\n     Bool\t    srcRepeat = pSrc->pDrawable && pSrc->repeatType == RepeatNormal;\n     Bool\t    maskRepeat = FALSE;\n     Bool\t    srcTransform = pSrc->transform != 0;\n\t\t\tbreak;\n     Bool\t    srcAlphaMap = pSrc->alphaMap != 0;\n     Bool\t    maskAlphaMap = FALSE;\n     Bool\t    dstAlphaMap = pDst->alphaMap != 0;\n    int\t\t    x_msk, y_msk, x_src, y_src, x_dst, y_dst;\n    int\t\t    w, h, w_this, h_this;\n \n #ifdef USE_MMX\n     static Bool mmx_setup = FALSE;\n\t\t\t\t    func = fbCompositeSolidMask_nx8888x8888Cmmx;\n\t\t\t\telse\n#endif\n     }\n #endif\n \n    xDst += pDst->pDrawable->x;\n    yDst += pDst->pDrawable->y;\n    if (pSrc->pDrawable) {\n        xSrc += pSrc->pDrawable->x;\n        ySrc += pSrc->pDrawable->y;\n    }\n     if (srcRepeat && srcTransform &&\n \tpSrc->pDrawable->width == 1 &&\n \tpSrc->pDrawable->height == 1)\n\t\t\t\telse\n     \n     if (pMask && pMask->pDrawable)\n     {\n\txMask += pMask->pDrawable->x;\n\tyMask += pMask->pDrawable->y;\n \tmaskRepeat = pMask->repeatType == RepeatNormal;\n \n \tif (pMask->filter == PictFilterConvolution)\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    switch (pDst->format) {\n                            case PICT_r5g6b5:\n                                func = fbCompositeSolidMask_nx8888x0565;\n                                break;\n\t\t\t    default:\n\t\t\t\tbreak;\n                            }\n\t\t\t}\n\t\t\tbreak;\n\t\t    case PICT_a8b8g8r8:\n\t\t\tif (pMask->componentAlpha) {\n\t\t\t    switch (pDst->format) {\n\t\t\t    case PICT_a8b8g8r8:\n\t\t\t    case PICT_x8b8g8r8:\n#ifdef USE_MMX\n\t\t\t\tif (fbHaveMMX())\n\t\t\t\t    func = fbCompositeSolidMask_nx8888x8888Cmmx;\n\t\t\t\telse\n#endif\n\t\t\t\t    func = fbCompositeSolidMask_nx8888x8888C;\n\t\t\t\tbreak;\n\t\t\t    case PICT_b5g6r5:\n#ifdef USE_MMX\n\t\t\t\tif (fbHaveMMX())\n\t\t\t\t    func = fbCompositeSolidMask_nx8888x0565Cmmx;\n\t\t\t\telse\n#endif\n\t\t\t\t    func = fbCompositeSolidMask_nx8888x0565C;\n\t\t\t\tbreak;\n\t\t\t    default:\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    switch (pDst->format) {\n                            case PICT_b5g6r5:\n                                func = fbCompositeSolidMask_nx8888x0565;\n                                break;\n\t\t\t    default:\n\t\t\t\tbreak;\n                            }\n\t\t\t}\n\t\t\tbreak;\n\t\t    case PICT_a1:\n\t\t\tswitch (pDst->format) {\n\t\t\tcase PICT_r5g6b5:\n\t\t\tcase PICT_b5g6r5:\n\t\t\tcase PICT_r8g8b8:\n\t\t\tcase PICT_b8g8r8:\n\t\t\tcase PICT_a8r8g8b8:\n\t\t\tcase PICT_x8r8g8b8:\n\t\t\tcase PICT_a8b8g8r8:\n\t\t\tcase PICT_x8b8g8r8:\n\t\t\t{\n\t\t\t    FbBits src;\n\n\t\t\t    fbComposeGetSolid(pSrc, src, pDst->format);\n\t\t\t    if ((src & 0xff000000) == 0xff000000)\n\t\t\t\tfunc = fbCompositeSolidMask_nx1xn;\n\t\t\t    break;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t    break;\n\t\t\t}\n\t\t\tbreak;\n\t\t    default:\n\t\t\tbreak;\n\t\t    }\n", "target": 1, "idx": 178301}
{"func": "bool ATSParser::PTSTimeDeltaEstablished() {\n if (mPrograms.isEmpty()) {\n return false;\n }\n\n return mPrograms.editItemAt(0)->PTSTimeDeltaEstablished();\n}\n", "target": 0, "idx": 173646}
{"func": "static int store_xauthority(void) {\n\tfs_build_mnt_dir();\n \n \tchar *src;\n \tchar *dest = RUN_XAUTHORITY_FILE;\n \tFILE *fp = fopen(dest, \"w\");\n \tif (fp) {\n \t\tfprintf(fp, \"\\n\");\n\t\tSET_PERMS_STREAM(fp, getuid(), getgid(), 0600);\n\t\tfclose(fp);\n\t}\n\t\n\tif (asprintf(&src, \"%s/.Xauthority\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\t\n\tstruct stat s;\n\tif (stat(src, &s) == 0) {\n\t\tif (is_link(src)) {\n\t\t\tfprintf(stderr, \"Warning: invalid .Xauthority file\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tcopy_file_as_user(src, dest, getuid(), getgid(), 0600);\n\t\tfs_logger2(\"clone\", dest);\n\t\treturn 1; // file copied\n\t}\n\t\n\treturn 0;\n}\n", "target": 1, "idx": 181545}
{"func": "acc_ctx_cont(OM_uint32 *minstat,\n\t     gss_buffer_t buf,\n\t     gss_ctx_id_t *ctx,\n\t     gss_buffer_t *responseToken,\n\t     gss_buffer_t *mechListMIC,\n\t     OM_uint32 *negState,\n\t     send_token_flag *return_token)\n{\n\tOM_uint32 ret, tmpmin;\n\tgss_OID supportedMech;\n\tspnego_gss_ctx_id_t sc;\n\tunsigned int len;\n\tunsigned char *ptr, *bufstart;\n\n\tsc = (spnego_gss_ctx_id_t)*ctx;\n\tret = GSS_S_DEFECTIVE_TOKEN;\n\t*negState = REJECT;\n\t*minstat = 0;\n\tsupportedMech = GSS_C_NO_OID;\n\t*return_token = ERROR_TOKEN_SEND;\n\t*responseToken = *mechListMIC = GSS_C_NO_BUFFER;\n \n \tptr = bufstart = buf->value;\n #define REMAIN (buf->length - (ptr - bufstart))\n\tif (REMAIN > INT_MAX)\n \t\treturn GSS_S_DEFECTIVE_TOKEN;\n \n \t/*\n\t * Attempt to work with old Sun SPNEGO.\n\t */\n\tif (*ptr == HEADER_ID) {\n\t\tret = g_verify_token_header(gss_mech_spnego,\n\t\t\t\t\t    &len, &ptr, 0, REMAIN);\n\t\tif (ret) {\n\t\t\t*minstat = ret;\n\t\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t\t}\n\t}\n\tif (*ptr != (CONTEXT | 0x01)) {\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t}\n\tret = get_negTokenResp(minstat, ptr, REMAIN,\n\t\t\t       negState, &supportedMech,\n\t\t\t       responseToken, mechListMIC);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\n\tif (*responseToken == GSS_C_NO_BUFFER &&\n\t    *mechListMIC == GSS_C_NO_BUFFER) {\n\n\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\tgoto cleanup;\n\t}\n\tif (supportedMech != GSS_C_NO_OID) {\n\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\tgoto cleanup;\n\t}\n\tsc->firstpass = 0;\n\t*negState = ACCEPT_INCOMPLETE;\n\t*return_token = CONT_TOKEN_SEND;\ncleanup:\n\tif (supportedMech != GSS_C_NO_OID) {\n\t\tgeneric_gss_release_oid(&tmpmin, &supportedMech);\n\t}\n\treturn ret;\n#undef REMAIN\n}\n", "target": 1, "idx": 179482}
{"func": "BOOL pnm2png (FILE *pnm_file, FILE *png_file, FILE *alpha_file, BOOL interlace, BOOL alpha)\n {\n   png_struct    *png_ptr = NULL;\n   png_info      *info_ptr = NULL;\n   png_byte      *png_pixels = NULL;\n   png_byte      **row_pointers = NULL;\n   png_byte      *pix_ptr = NULL;\n  png_uint_32   row_bytes;\n \n   char          type_token[16];\n   char          width_token[16];\n   char          height_token[16];\n   char          maxval_token[16];\n  int           color_type;\n   unsigned long   ul_width=0, ul_alpha_width=0;\n   unsigned long   ul_height=0, ul_alpha_height=0;\n   unsigned long   ul_maxval=0;\n  png_uint_32   width, alpha_width;\n  png_uint_32   height, alpha_height;\n   png_uint_32   maxval;\n  int           bit_depth = 0;\n  int           channels;\n   int           alpha_depth = 0;\n  int           alpha_present;\n   int           row, col;\n   BOOL          raw, alpha_raw = FALSE;\n #if defined(PNG_WRITE_INVERT_SUPPORTED) || defined(PNG_WRITE_PACK_SUPPORTED)\n  BOOL          packed_bitmap = FALSE;\n#endif\n  png_uint_32   tmp16;\n int           i;\n\n /* read header of PNM file */\n\n  get_token(pnm_file, type_token);\n if (type_token[0] != 'P')\n {\n return FALSE;\n }\n else if ((type_token[1] == '1') || (type_token[1] == '4'))\n {\n#if defined(PNG_WRITE_INVERT_SUPPORTED) || defined(PNG_WRITE_PACK_SUPPORTED)\n    raw = (type_token[1] == '4');\n    color_type = PNG_COLOR_TYPE_GRAY;\n    get_token(pnm_file, width_token);\n    sscanf (width_token, \"%lu\", &ul_width);\n    width = (png_uint_32) ul_width;\n    get_token(pnm_file, height_token);\n    sscanf (height_token, \"%lu\", &ul_height);\n    height = (png_uint_32) ul_height;\n    bit_depth = 1;\n    packed_bitmap = TRUE;\n#else\n    fprintf (stderr, \"PNM2PNG built without PNG_WRITE_INVERT_SUPPORTED and \\n\");\n    fprintf (stderr, \"PNG_WRITE_PACK_SUPPORTED can't read PBM (P1,P4) files\\n\");\n#endif\n }\n else if ((type_token[1] == '2') || (type_token[1] == '5'))\n {\n    raw = (type_token[1] == '5');\n    color_type = PNG_COLOR_TYPE_GRAY;\n    get_token(pnm_file, width_token);\n    sscanf (width_token, \"%lu\", &ul_width);\n    width = (png_uint_32) ul_width;\n    get_token(pnm_file, height_token);\n    sscanf (height_token, \"%lu\", &ul_height);\n    height = (png_uint_32) ul_height;\n    get_token(pnm_file, maxval_token);\n    sscanf (maxval_token, \"%lu\", &ul_maxval);\n    maxval = (png_uint_32) ul_maxval;\n\n if (maxval <= 1)\n      bit_depth = 1;\n else if (maxval <= 3)\n      bit_depth = 2;\n else if (maxval <= 15)\n      bit_depth = 4;\n else if (maxval <= 255)\n      bit_depth = 8;\n else /* if (maxval <= 65535) */\n      bit_depth = 16;\n }\n else if ((type_token[1] == '3') || (type_token[1] == '6'))\n {\n    raw = (type_token[1] == '6');\n    color_type = PNG_COLOR_TYPE_RGB;\n    get_token(pnm_file, width_token);\n    sscanf (width_token, \"%lu\", &ul_width);\n    width = (png_uint_32) ul_width;\n    get_token(pnm_file, height_token);\n    sscanf (height_token, \"%lu\", &ul_height);\n    height = (png_uint_32) ul_height;\n    get_token(pnm_file, maxval_token);\n    sscanf (maxval_token, \"%lu\", &ul_maxval);\n    maxval = (png_uint_32) ul_maxval;\n if (maxval <= 1)\n      bit_depth = 1;\n else if (maxval <= 3)\n      bit_depth = 2;\n else if (maxval <= 15)\n      bit_depth = 4;\n else if (maxval <= 255)\n      bit_depth = 8;\n else /* if (maxval <= 65535) */\n      bit_depth = 16;\n }\n else\n {\n return FALSE;\n }\n\n /* read header of PGM file with alpha channel */\n\n if (alpha)\n {\n if (color_type == PNG_COLOR_TYPE_GRAY)\n      color_type = PNG_COLOR_TYPE_GRAY_ALPHA;\n if (color_type == PNG_COLOR_TYPE_RGB)\n      color_type = PNG_COLOR_TYPE_RGB_ALPHA;\n\n    get_token(alpha_file, type_token);\n if (type_token[0] != 'P')\n {\n return FALSE;\n }\n else if ((type_token[1] == '2') || (type_token[1] == '5'))\n {\n      alpha_raw = (type_token[1] == '5');\n      get_token(alpha_file, width_token);\n      sscanf (width_token, \"%lu\", &ul_alpha_width);\n      alpha_width=(png_uint_32) ul_alpha_width;\n if (alpha_width != width)\n return FALSE;\n      get_token(alpha_file, height_token);\n      sscanf (height_token, \"%lu\", &ul_alpha_height);\n      alpha_height = (png_uint_32) ul_alpha_height;\n if (alpha_height != height)\n return FALSE;\n      get_token(alpha_file, maxval_token);\n      sscanf (maxval_token, \"%lu\", &ul_maxval);\n      maxval = (png_uint_32) ul_maxval;\n if (maxval <= 1)\n        alpha_depth = 1;\n else if (maxval <= 3)\n        alpha_depth = 2;\n else if (maxval <= 15)\n        alpha_depth = 4;\n else if (maxval <= 255)\n        alpha_depth = 8;\n else /* if (maxval <= 65535) */\n        alpha_depth = 16;\n if (alpha_depth != bit_depth)\n return FALSE;\n }\n else\n {\n return FALSE;\n }\n } /* end if alpha */\n\n /* calculate the number of channels and store alpha-presence */\n if (color_type == PNG_COLOR_TYPE_GRAY)\n    channels = 1;\n else if (color_type == PNG_COLOR_TYPE_GRAY_ALPHA)\n    channels = 2;\n else if (color_type == PNG_COLOR_TYPE_RGB)\n\n     channels = 3;\n   else if (color_type == PNG_COLOR_TYPE_RGB_ALPHA)\n     channels = 4;\n   else\n    channels = 0; /* should not happen */\n \n   alpha_present = (channels - 1) % 2;\n \n#if defined(PNG_WRITE_INVERT_SUPPORTED) || defined(PNG_WRITE_PACK_SUPPORTED)\n if (packed_bitmap)\n /* row data is as many bytes as can fit width x channels x bit_depth */\n    row_bytes = (width * channels * bit_depth + 7) / 8;\n else\n#endif\n\n     /* row_bytes is the width x number of channels x (bit-depth / 8) */\n     row_bytes = width * channels * ((bit_depth <= 8) ? 1 : 2);\n \n  if ((png_pixels = (png_byte *) malloc (row_bytes * height * sizeof (png_byte))) == NULL)\n     return FALSE;\n \n   /* read data from PNM file */\n   pix_ptr = png_pixels;\n \n  for (row = 0; row < height; row++)\n   {\n #if defined(PNG_WRITE_INVERT_SUPPORTED) || defined(PNG_WRITE_PACK_SUPPORTED)\n     if (packed_bitmap) {\n      for (i = 0; i < row_bytes; i++)\n         /* png supports this format natively so no conversion is needed */\n         *pix_ptr++ = get_data (pnm_file, 8);\n     } else\n #endif\n     {\n      for (col = 0; col < width; col++)\n       {\n         for (i = 0; i < (channels - alpha_present); i++)\n         {\n if (raw)\n *pix_ptr++ = get_data (pnm_file, bit_depth);\n else\n if (bit_depth <= 8)\n *pix_ptr++ = get_value (pnm_file, bit_depth);\n else\n {\n              tmp16 = get_value (pnm_file, bit_depth);\n *pix_ptr = (png_byte) ((tmp16 >> 8) & 0xFF);\n              pix_ptr++;\n *pix_ptr = (png_byte) (tmp16 & 0xFF);\n              pix_ptr++;\n }\n }\n\n if (alpha) /* read alpha-channel from pgm file */\n {\n if (alpha_raw)\n *pix_ptr++ = get_data (alpha_file, alpha_depth);\n else\n if (alpha_depth <= 8)\n *pix_ptr++ = get_value (alpha_file, bit_depth);\n else\n {\n              tmp16 = get_value (alpha_file, bit_depth);\n *pix_ptr++ = (png_byte) ((tmp16 >> 8) & 0xFF);\n *pix_ptr++ = (png_byte) (tmp16 & 0xFF);\n }\n } /* if alpha */\n } /* if packed_bitmap */\n } /* end for col */\n\n   } /* end for row */\n \n   /* prepare the standard PNG structures */\n  png_ptr = png_create_write_struct (PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);\n   if (!png_ptr)\n   {\n     return FALSE;\n   }\n   info_ptr = png_create_info_struct (png_ptr);\n   if (!info_ptr)\n   {\n     png_destroy_write_struct (&png_ptr, (png_infopp) NULL);\n     return FALSE;\n   }\n \n#if defined(PNG_WRITE_INVERT_SUPPORTED) || defined(PNG_WRITE_PACK_SUPPORTED)\n if (packed_bitmap == TRUE)\n {\n    png_set_packing (png_ptr);\n    png_set_invert_mono (png_ptr);\n }\n#endif\n\n\n   /* setjmp() must be called in every function that calls a PNG-reading libpng function */\n   if (setjmp (png_jmpbuf(png_ptr)))\n   {\n    png_destroy_write_struct (&png_ptr, (png_infopp) NULL);\n     return FALSE;\n   }\n \n /* initialize the png structure */\n  png_init_io (png_ptr, png_file);\n\n /* we're going to write more or less the same PNG as the input file */\n  png_set_IHDR (png_ptr, info_ptr, width, height, bit_depth, color_type,\n (!interlace) ? PNG_INTERLACE_NONE : PNG_INTERLACE_ADAM7,\n    PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);\n\n /* write the file header information */\n  png_write_info (png_ptr, info_ptr);\n\n\n   /* if needed we will allocate memory for an new array of row-pointers */\n   if (row_pointers == (unsigned char**) NULL)\n   {\n    if ((row_pointers = (png_byte **) malloc (height * sizeof (png_bytep))) == NULL)\n     {\n      png_destroy_write_struct (&png_ptr, (png_infopp) NULL);\n       return FALSE;\n     }\n   }\n \n   /* set the individual row_pointers to point at the correct offsets */\n  for (i = 0; i < (height); i++)\n     row_pointers[i] = png_pixels + i * row_bytes;\n \n   /* write out the entire image data in one call */\n   png_write_image (png_ptr, row_pointers);\n \n  /* write the additional chuncks to the PNG file (not really needed) */\n   png_write_end (png_ptr, info_ptr);\n \n   /* clean up after the write, and free any memory allocated */\n  png_destroy_write_struct (&png_ptr, (png_infopp) NULL);\n \n   if (row_pointers != (unsigned char**) NULL)\n     free (row_pointers);\n if (png_pixels != (unsigned char*) NULL)\n    free (png_pixels);\n\n return TRUE;\n} /* end of pnm2png */\n", "target": 1, "idx": 187747}
{"func": "int32_t InputHandler::finishComposition()\n{\n    if (!isActiveTextEdit())\n        return -1;\n\n    if (!compositionActive())\n        return 0;\n\n    removeAttributedTextMarker();\n\n    InputLog(LogLevelInfo, \"InputHandler::finishComposition completed\");\n\n    return 0;\n}\n", "target": 0, "idx": 111468}
{"func": "uint32 PluginInstance::ScheduleTimer(uint32 interval,\n                                     NPBool repeat,\n                                     void (*func)(NPP id, uint32 timer_id)) {\n  uint32 timer_id;\n  timer_id = next_timer_id_;\n  ++next_timer_id_;\n  DCHECK(next_timer_id_ != 0);\n\n  TimerInfo info;\n  info.interval = interval;\n  info.repeat = repeat;\n   timers_[timer_id] = info;\n \n  message_loop_->PostDelayedTask(FROM_HERE,\n                                 NewRunnableMethod(this,\n                                                   &PluginInstance::OnTimerCall,\n                                                   func,\n                                                   npp_,\n                                                   timer_id),\n                                 interval);\n   return timer_id;\n }\n", "target": 1, "idx": 183591}
{"func": "DOMWindow* Document::open(v8::Isolate* isolate,\n                          const USVStringOrTrustedURL& string_or_url,\n                          const AtomicString& name,\n                          const AtomicString& features,\n                          ExceptionState& exception_state) {\n  if (!domWindow()) {\n    exception_state.ThrowDOMException(DOMExceptionCode::kInvalidAccessError,\n                                      \"The document has no window associated.\");\n    return nullptr;\n  }\n\n  return domWindow()->open(isolate, string_or_url, name, features,\n                           exception_state);\n}\n", "target": 0, "idx": 141349}
{"func": "  void SendRequest() {\n    DCHECK_CURRENTLY_ON(BrowserThread::UI);\n\n    if (!service_)\n      return;\n    bool is_extended_reporting = false;\n    if (item_->GetBrowserContext()) {\n      Profile* profile =\n          Profile::FromBrowserContext(item_->GetBrowserContext());\n      is_extended_reporting = profile &&\n                              profile->GetPrefs()->GetBoolean(\n                                  prefs::kSafeBrowsingExtendedReportingEnabled);\n    }\n\n    ClientDownloadRequest request;\n    if (is_extended_reporting) {\n      request.mutable_population()->set_user_population(\n          ChromeUserPopulation::EXTENDED_REPORTING);\n    } else {\n      request.mutable_population()->set_user_population(\n          ChromeUserPopulation::SAFE_BROWSING);\n    }\n    request.set_url(SanitizeUrl(item_->GetUrlChain().back()));\n    request.mutable_digests()->set_sha256(item_->GetHash());\n    request.set_length(item_->GetReceivedBytes());\n    for (size_t i = 0; i < item_->GetUrlChain().size(); ++i) {\n      ClientDownloadRequest::Resource* resource = request.add_resources();\n      resource->set_url(SanitizeUrl(item_->GetUrlChain()[i]));\n      if (i == item_->GetUrlChain().size() - 1) {\n        resource->set_type(ClientDownloadRequest::DOWNLOAD_URL);\n        resource->set_referrer(SanitizeUrl(item_->GetReferrerUrl()));\n        DVLOG(2) << \"dl url \" << resource->url();\n        if (!item_->GetRemoteAddress().empty()) {\n          resource->set_remote_ip(item_->GetRemoteAddress());\n          DVLOG(2) << \"  dl url remote addr: \" << resource->remote_ip();\n        }\n        DVLOG(2) << \"dl referrer \" << resource->referrer();\n      } else {\n        DVLOG(2) << \"dl redirect \" << i << \" \" << resource->url();\n        resource->set_type(ClientDownloadRequest::DOWNLOAD_REDIRECT);\n      }\n    }\n    for (size_t i = 0; i < tab_redirects_.size(); ++i) {\n      ClientDownloadRequest::Resource* resource = request.add_resources();\n      DVLOG(2) << \"tab redirect \" << i << \" \" << tab_redirects_[i].spec();\n      resource->set_url(SanitizeUrl(tab_redirects_[i]));\n      resource->set_type(ClientDownloadRequest::TAB_REDIRECT);\n    }\n    if (tab_url_.is_valid()) {\n      ClientDownloadRequest::Resource* resource = request.add_resources();\n      resource->set_url(SanitizeUrl(tab_url_));\n      DVLOG(2) << \"tab url \" << resource->url();\n      resource->set_type(ClientDownloadRequest::TAB_URL);\n      if (tab_referrer_url_.is_valid()) {\n        resource->set_referrer(SanitizeUrl(tab_referrer_url_));\n        DVLOG(2) << \"tab referrer \" << resource->referrer();\n      }\n    }\n\n    request.set_user_initiated(item_->HasUserGesture());\n    request.set_file_basename(\n        item_->GetTargetFilePath().BaseName().AsUTF8Unsafe());\n    request.set_download_type(type_);\n     request.mutable_signature()->CopyFrom(signature_info_);\n     if (image_headers_)\n       request.set_allocated_image_headers(image_headers_.release());\n    if (zipped_executable_)\n       request.mutable_archived_binary()->Swap(&archived_binary_);\n     if (!request.SerializeToString(&client_download_request_data_)) {\n       FinishRequest(UNKNOWN, REASON_INVALID_REQUEST_PROTO);\n      return;\n    }\n    service_->client_download_request_callbacks_.Notify(item_, &request);\n \n     DVLOG(2) << \"Sending a request for URL: \"\n              << item_->GetUrlChain().back();\n     fetcher_ = net::URLFetcher::Create(0 /* ID used for testing */,\n                                        GetDownloadRequestUrl(),\n                                        net::URLFetcher::POST, this);\n    fetcher_->SetLoadFlags(net::LOAD_DISABLE_CACHE);\n    fetcher_->SetAutomaticallyRetryOn5xx(false);  // Don't retry on error.\n    fetcher_->SetRequestContext(service_->request_context_getter_.get());\n    fetcher_->SetUploadData(\"application/octet-stream\",\n                            client_download_request_data_);\n    request_start_time_ = base::TimeTicks::Now();\n    UMA_HISTOGRAM_COUNTS(\"SBClientDownload.DownloadRequestPayloadSize\",\n                         client_download_request_data_.size());\n    fetcher_->Start();\n  }\n", "target": 1, "idx": 185544}
{"func": "ASN1_OBJECT *OBJ_txt2obj(const char *s, int no_name)\n\t{\n\tint nid = NID_undef;\n\tASN1_OBJECT *op=NULL;\n\tunsigned char *buf;\n\tunsigned char *p;\n\tconst unsigned char *cp;\n\tint i, j;\n\n\tif(!no_name) {\n\t\tif( ((nid = OBJ_sn2nid(s)) != NID_undef) ||\n\t\t\t((nid = OBJ_ln2nid(s)) != NID_undef) ) \n\t\t\t\t\treturn OBJ_nid2obj(nid);\n\t}\n\n\t/* Work out size of content octets */\n\ti=a2d_ASN1_OBJECT(NULL,0,s,-1);\n\tif (i <= 0) {\n\t\t/* Don't clear the error */\n\t\t/*ERR_clear_error();*/\n\t\treturn NULL;\n\t}\n\t/* Work out total size */\n\tj = ASN1_object_size(0,i,V_ASN1_OBJECT);\n\n\tif((buf=(unsigned char *)OPENSSL_malloc(j)) == NULL) return NULL;\n\n\tp = buf;\n\t/* Write out tag+length */\n\tASN1_put_object(&p,0,i,V_ASN1_OBJECT,V_ASN1_UNIVERSAL);\n\t/* Write out contents */\n\ta2d_ASN1_OBJECT(p,i,s,-1);\n\n\tcp=buf;\n\top=d2i_ASN1_OBJECT(NULL,&cp,j);\n\tOPENSSL_free(buf);\n\treturn op;\n\t}\n", "target": 0, "idx": 12477}
{"func": "mm_create(struct mm_master *mmalloc, size_t size)\n{\n\tvoid *address;\n\tstruct mm_master *mm;\n\n\tif (mmalloc == NULL)\n\t\tmm = xcalloc(1, sizeof(struct mm_master));\n\telse\n\t\tmm = mm_xmalloc(mmalloc, sizeof(struct mm_master));\n\n\t/*\n\t * If the memory map has a mm_master it can be completely\n\t * shared including authentication between the child\n\t * and the client.\n\t */\n\tmm->mmalloc = mmalloc;\n\n\taddress = mmap(NULL, size, PROT_WRITE|PROT_READ, MAP_ANON|MAP_SHARED,\n\t    -1, 0);\n\tif (address == MAP_FAILED)\n\t\tfatal(\"mmap(%zu): %s\", size, strerror(errno));\n\n\tmm->address = address;\n\tmm->size = size;\n\n\tRB_INIT(&mm->rb_free);\n\tRB_INIT(&mm->rb_allocated);\n\n\tmm_make_entry(mm, &mm->rb_free, address, size);\n\n\treturn (mm);\n}\n", "target": 0, "idx": 72189}
{"func": " int validate_camera_metadata_structure(const camera_metadata_t *metadata,\n                                        const size_t *expected_size) {\n \n if (metadata == NULL) {\n        ALOGE(\"%s: metadata is null!\", __FUNCTION__);\n return ERROR;\n }\n\n {\n static const struct {\n const char *name;\n size_t alignment;\n } alignments[] = {\n {\n .name = \"camera_metadata\",\n .alignment = METADATA_ALIGNMENT\n },\n {\n .name = \"camera_metadata_buffer_entry\",\n .alignment = ENTRY_ALIGNMENT\n },\n {\n .name = \"camera_metadata_data\",\n .alignment = DATA_ALIGNMENT\n },\n };\n\n for (size_t i = 0; i < sizeof(alignments)/sizeof(alignments[0]); ++i) {\n uintptr_t aligned_ptr = ALIGN_TO(metadata, alignments[i].alignment);\n\n if ((uintptr_t)metadata != aligned_ptr) {\n                ALOGE(\"%s: Metadata pointer is not aligned (actual %p, \"\n \"expected %p) to type %s\",\n                      __FUNCTION__, metadata,\n (void*)aligned_ptr, alignments[i].name);\n return ERROR;\n }\n }\n }\n\n /**\n     * Check that the metadata contents are correct\n     */\n\n if (expected_size != NULL && metadata->size > *expected_size) {\n        ALOGE(\"%s: Metadata size (%\" PRIu32 \") should be <= expected size (%zu)\",\n              __FUNCTION__, metadata->size, *expected_size);\n return ERROR;\n }\n\n if (metadata->entry_count > metadata->entry_capacity) {\n        ALOGE(\"%s: Entry count (%\" PRIu32 \") should be <= entry capacity \"\n \"(%\" PRIu32 \")\",\n              __FUNCTION__, metadata->entry_count, metadata->entry_capacity);\n return ERROR;\n }\n\n const metadata_uptrdiff_t entries_end =\n        metadata->entries_start + metadata->entry_capacity;\n if (entries_end < metadata->entries_start || // overflow check\n        entries_end > metadata->data_start) {\n\n        ALOGE(\"%s: Entry start + capacity (%\" PRIu32 \") should be <= data start \"\n \"(%\" PRIu32 \")\",\n               __FUNCTION__,\n (metadata->entries_start + metadata->entry_capacity),\n              metadata->data_start);\n return ERROR;\n }\n\n const metadata_uptrdiff_t data_end =\n        metadata->data_start + metadata->data_capacity;\n if (data_end < metadata->data_start || // overflow check\n        data_end > metadata->size) {\n\n        ALOGE(\"%s: Data start + capacity (%\" PRIu32 \") should be <= total size \"\n \"(%\" PRIu32 \")\",\n               __FUNCTION__,\n (metadata->data_start + metadata->data_capacity),\n              metadata->size);\n return ERROR;\n }\n\n const metadata_size_t entry_count = metadata->entry_count;\n camera_metadata_buffer_entry_t *entries = get_entries(metadata);\n\n for (size_t i = 0; i < entry_count; ++i) {\n\n if ((uintptr_t)&entries[i] != ALIGN_TO(&entries[i], ENTRY_ALIGNMENT)) {\n            ALOGE(\"%s: Entry index %zu had bad alignment (address %p),\"\n \" expected alignment %zu\",\n                  __FUNCTION__, i, &entries[i], ENTRY_ALIGNMENT);\n return ERROR;\n }\n\n camera_metadata_buffer_entry_t entry = entries[i];\n\n if (entry.type >= NUM_TYPES) {\n            ALOGE(\"%s: Entry index %zu had a bad type %d\",\n                  __FUNCTION__, i, entry.type);\n return ERROR;\n }\n\n uint32_t tag_section = entry.tag >> 16;\n int tag_type = get_camera_metadata_tag_type(entry.tag);\n if (tag_type != (int)entry.type && tag_section < VENDOR_SECTION) {\n            ALOGE(\"%s: Entry index %zu had tag type %d, but the type was %d\",\n                  __FUNCTION__, i, tag_type, entry.type);\n\n             return ERROR;\n         }\n \n        size_t data_size =\n                calculate_camera_metadata_entry_data_size(entry.type,\n                                                          entry.count);\n \n         if (data_size != 0) {\n             camera_metadata_data_t *data =\n (camera_metadata_data_t*) (get_data(metadata) +\n                                               entry.data.offset);\n\n if ((uintptr_t)data != ALIGN_TO(data, DATA_ALIGNMENT)) {\n                ALOGE(\"%s: Entry index %zu had bad data alignment (address %p),\"\n \" expected align %zu, (tag name %s, data size %zu)\",\n                      __FUNCTION__, i, data, DATA_ALIGNMENT,\n                      get_camera_metadata_tag_name(entry.tag) ?: \"unknown\",\n                      data_size);\n return ERROR;\n }\n\n size_t data_entry_end = entry.data.offset + data_size;\n if (data_entry_end < entry.data.offset || // overflow check\n                data_entry_end > metadata->data_capacity) {\n\n                ALOGE(\"%s: Entry index %zu data ends (%zu) beyond the capacity \"\n \"%\" PRIu32, __FUNCTION__, i, data_entry_end,\n                      metadata->data_capacity);\n return ERROR;\n }\n\n } else if (entry.count == 0) {\n if (entry.data.offset != 0) {\n                ALOGE(\"%s: Entry index %zu had 0 items, but offset was non-0 \"\n \"(%\" PRIu32 \"), tag name: %s\", __FUNCTION__, i, entry.data.offset,\n                        get_camera_metadata_tag_name(entry.tag) ?: \"unknown\");\n return ERROR;\n }\n } // else data stored inline, so we look at value which can be anything.\n }\n\n return OK;\n}\n", "target": 1, "idx": 187417}
{"func": "void AppCacheUpdateJob::StartUpdate(AppCacheHost* host,\n                                    const GURL& new_master_resource) {\n  DCHECK(group_->update_job() == this);\n  DCHECK(!group_->is_obsolete());\n\n  bool is_new_pending_master_entry = false;\n  if (!new_master_resource.is_empty()) {\n    DCHECK(new_master_resource == host->pending_master_entry_url());\n     DCHECK(!new_master_resource.has_ref());\n     DCHECK(new_master_resource.GetOrigin() == manifest_url_.GetOrigin());\n \n     if (IsTerminating()) {\n       group_->QueueUpdate(host, new_master_resource);\n      return;\n    }\n\n    std::pair<PendingMasters::iterator, bool> ret =\n        pending_master_entries_.insert(\n            PendingMasters::value_type(new_master_resource, PendingHosts()));\n    is_new_pending_master_entry = ret.second;\n    ret.first->second.push_back(host);\n    host->AddObserver(this);\n  }\n\n  AppCacheGroup::UpdateAppCacheStatus update_status = group_->update_status();\n  if (update_status == AppCacheGroup::CHECKING ||\n      update_status == AppCacheGroup::DOWNLOADING) {\n    if (host) {\n      NotifySingleHost(host, APPCACHE_CHECKING_EVENT);\n      if (update_status == AppCacheGroup::DOWNLOADING)\n        NotifySingleHost(host, APPCACHE_DOWNLOADING_EVENT);\n\n      if (!new_master_resource.is_empty()) {\n        AddMasterEntryToFetchList(host, new_master_resource,\n                                  is_new_pending_master_entry);\n      }\n    }\n    return;\n  }\n\n  MadeProgress();\n  group_->SetUpdateAppCacheStatus(AppCacheGroup::CHECKING);\n  if (group_->HasCache()) {\n    base::TimeDelta kFullUpdateInterval = base::TimeDelta::FromHours(24);\n    update_type_ = UPGRADE_ATTEMPT;\n    base::TimeDelta time_since_last_check =\n        base::Time::Now() - group_->last_full_update_check_time();\n    doing_full_update_check_ = time_since_last_check > kFullUpdateInterval;\n    NotifyAllAssociatedHosts(APPCACHE_CHECKING_EVENT);\n  } else {\n    update_type_ = CACHE_ATTEMPT;\n    doing_full_update_check_ = true;\n    DCHECK(host);\n    NotifySingleHost(host, APPCACHE_CHECKING_EVENT);\n  }\n\n  if (!new_master_resource.is_empty()) {\n    AddMasterEntryToFetchList(host, new_master_resource,\n                              is_new_pending_master_entry);\n  }\n\n  BrowserThread::PostAfterStartupTask(\n      FROM_HERE, base::ThreadTaskRunnerHandle::Get(),\n      base::Bind(&AppCacheUpdateJob::FetchManifest, weak_factory_.GetWeakPtr(),\n                 true));\n}\n", "target": 1, "idx": 185610}
{"func": "SampleTable::SampleTable(const sp<DataSource> &source)\n : mDataSource(source),\n      mChunkOffsetOffset(-1),\n      mChunkOffsetType(0),\n      mNumChunkOffsets(0),\n      mSampleToChunkOffset(-1),\n      mNumSampleToChunkOffsets(0),\n      mSampleSizeOffset(-1),\n\n       mSampleSizeFieldSize(0),\n       mDefaultSampleSize(0),\n       mNumSampleSizes(0),\n       mTimeToSampleCount(0),\n       mTimeToSample(),\n       mSampleTimeEntries(NULL),\n      mCompositionTimeDeltaEntries(NULL),\n      mNumCompositionTimeDeltaEntries(0),\n      mCompositionDeltaLookup(new CompositionDeltaLookup),\n      mSyncSampleOffset(-1),\n      mNumSyncSamples(0),\n      mSyncSamples(NULL),\n      mLastSyncSampleIndex(0),\n      mSampleToChunkEntries(NULL) {\n    mSampleIterator = new SampleIterator(this);\n}\n", "target": 1, "idx": 187793}
{"func": "nfssvc_decode_writeargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_writeargs *args)\n{\n\tunsigned int len, hdr, dlen;\n\tstruct kvec *head = rqstp->rq_arg.head;\n\tint v;\n\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\n\tp++;\t\t\t\t/* beginoffset */\n\targs->offset = ntohl(*p++);\t/* offset */\n\tp++;\t\t\t\t/* totalcount */\n\tlen = args->len = ntohl(*p++);\n\t/*\n\t * The protocol specifies a maximum of 8192 bytes.\n\t */\n\tif (len > NFSSVC_MAXBLKSIZE_V2)\n\t\treturn 0;\n\n\t/*\n\t * Check to make sure that we got the right number of\n \t * bytes.\n \t */\n \thdr = (void*)p - head->iov_base;\n \tdlen = head->iov_len + rqstp->rq_arg.page_len - hdr;\n \n \t/*\n\t * Round the length of the data which was specified up to\n\t * the next multiple of XDR units and then compare that\n\t * against the length which was actually received.\n\t * Note that when RPCSEC/GSS (for example) is used, the\n\t * data buffer can be padded so dlen might be larger\n\t * than required.  It must never be smaller.\n\t */\n\tif (dlen < XDR_QUADLEN(len)*4)\n\t\treturn 0;\n\n\trqstp->rq_vec[0].iov_base = (void*)p;\n\trqstp->rq_vec[0].iov_len = head->iov_len - hdr;\n\tv = 0;\n\twhile (len > rqstp->rq_vec[v].iov_len) {\n\t\tlen -= rqstp->rq_vec[v].iov_len;\n\t\tv++;\n\t\trqstp->rq_vec[v].iov_base = page_address(rqstp->rq_pages[v]);\n\t\trqstp->rq_vec[v].iov_len = PAGE_SIZE;\n\t}\n\trqstp->rq_vec[v].iov_len = len;\n\targs->vlen = v + 1;\n\treturn 1;\n}\n", "target": 1, "idx": 181412}
{"func": "WebContents* GetEmbedderForGuest(content::WebContents* guest) {\n  CHECK(guest);\n  return static_cast<content::WebContentsImpl*>(guest)->GetOuterWebContents();\n}\n", "target": 0, "idx": 169244}
{"func": "static void ifb_setup(struct net_device *dev)\n{\n\t/* Initialize the device structure. */\n\tdev->destructor = free_netdev;\n\tdev->netdev_ops = &ifb_netdev_ops;\n\n\t/* Fill in device structure with ethernet-generic values. */\n\tether_setup(dev);\n\tdev->tx_queue_len = TX_Q_LIMIT;\n\n\tdev->features |= IFB_FEATURES;\n\tdev->vlan_features |= IFB_FEATURES;\n \n \tdev->flags |= IFF_NOARP;\n \tdev->flags &= ~IFF_MULTICAST;\n\tdev->priv_flags &= ~IFF_XMIT_DST_RELEASE;\n \trandom_ether_addr(dev->dev_addr);\n }\n", "target": 1, "idx": 178900}
{"func": "bool SiteInstanceImpl::ShouldLockToOrigin(BrowserContext* browser_context,\n                                          GURL site_url) {\n  if (RenderProcessHost::run_renderer_in_process())\n    return false;\n\n  if (!DoesSiteRequireDedicatedProcess(browser_context, site_url))\n    return false;\n\n   if (site_url.SchemeIs(content::kGuestScheme))\n     return false;\n \n  if (site_url.SchemeIs(content::kChromeUIScheme))\n    return false;\n  if (!GetContentClient()->browser()->ShouldLockToOrigin(browser_context,\n                                                         site_url)) {\n    return false;\n  }\n\n  return true;\n}\n", "target": 1, "idx": 187304}
{"func": "MagickExport char *GetNextImageProfile(const Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->profiles == (SplayTreeInfo *) NULL)\n    return((char *) NULL);\n  return((char *) GetNextKeyInSplayTree((SplayTreeInfo *) image->profiles));\n}\n", "target": 0, "idx": 73392}
{"func": "i915_gem_execbuffer2(struct drm_device *dev, void *data,\n\t\t     struct drm_file *file)\n{\n\tstruct drm_i915_gem_execbuffer2 *args = data;\n \tstruct drm_i915_gem_exec_object2 *exec2_list = NULL;\n \tint ret;\n \n\tif (args->buffer_count < 1) {\n \t\tDRM_DEBUG(\"execbuf2 with %d buffers\\n\", args->buffer_count);\n \t\treturn -EINVAL;\n \t}\n\n\texec2_list = kmalloc(sizeof(*exec2_list)*args->buffer_count,\n\t\t\t     GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY);\n\tif (exec2_list == NULL)\n\t\texec2_list = drm_malloc_ab(sizeof(*exec2_list),\n\t\t\t\t\t   args->buffer_count);\n\tif (exec2_list == NULL) {\n\t\tDRM_DEBUG(\"Failed to allocate exec list for %d buffers\\n\",\n\t\t\t  args->buffer_count);\n\t\treturn -ENOMEM;\n\t}\n\tret = copy_from_user(exec2_list,\n\t\t\t     (struct drm_i915_relocation_entry __user *)\n\t\t\t     (uintptr_t) args->buffers_ptr,\n\t\t\t     sizeof(*exec2_list) * args->buffer_count);\n\tif (ret != 0) {\n\t\tDRM_DEBUG(\"copy %d exec entries failed %d\\n\",\n\t\t\t  args->buffer_count, ret);\n\t\tdrm_free_large(exec2_list);\n\t\treturn -EFAULT;\n\t}\n\n\tret = i915_gem_do_execbuffer(dev, data, file, args, exec2_list);\n\tif (!ret) {\n\t\t/* Copy the new buffer offsets back to the user's exec list. */\n\t\tret = copy_to_user((struct drm_i915_relocation_entry __user *)\n\t\t\t\t   (uintptr_t) args->buffers_ptr,\n\t\t\t\t   exec2_list,\n\t\t\t\t   sizeof(*exec2_list) * args->buffer_count);\n\t\tif (ret) {\n\t\t\tret = -EFAULT;\n\t\t\tDRM_DEBUG(\"failed to copy %d exec entries \"\n\t\t\t\t  \"back to user (%d)\\n\",\n\t\t\t\t  args->buffer_count, ret);\n\t\t}\n\t}\n\n\tdrm_free_large(exec2_list);\n\treturn ret;\n}\n", "target": 1, "idx": 178769}
{"func": "bool AppCacheDatabase::FindEntriesForCache(int64_t cache_id,\n                                           std::vector<EntryRecord>* records) {\n  DCHECK(records && records->empty());\n  if (!LazyOpen(kDontCreate))\n     return false;\n \n   static const char kSql[] =\n      \"SELECT cache_id, url, flags, response_id, response_size FROM Entries\"\n       \"  WHERE cache_id = ?\";\n \n   sql::Statement statement(db_->GetCachedStatement(SQL_FROM_HERE, kSql));\n  statement.BindInt64(0, cache_id);\n\n  while (statement.Step()) {\n    records->push_back(EntryRecord());\n    ReadEntryRecord(statement, &records->back());\n    DCHECK(records->back().cache_id == cache_id);\n  }\n\n  return statement.Succeeded();\n}\n", "target": 1, "idx": 186953}
{"func": "static void vc1_put_blocks_clamped(VC1Context *v, int put_signed)\n{\n    MpegEncContext *s = &v->s;\n    uint8_t *dest;\n    int block_count = CONFIG_GRAY && (s->avctx->flags & AV_CODEC_FLAG_GRAY) ? 4 : 6;\n    int fieldtx = 0;\n    int i;\n\n    /* The put pixels loop is one MB row and one MB column behind the decoding\n     * loop because we can only put pixels when overlap filtering is done. For\n     * interlaced frame pictures, however, the put pixels loop is only one\n     * column behind the decoding loop as interlaced frame pictures only need\n     * horizontal overlap filtering. */\n    if (!s->first_slice_line && v->fcm != ILACE_FRAME) {\n        if (s->mb_x) {\n            for (i = 0; i < block_count; i++) {\n                if (i > 3 ? v->mb_type[0][s->block_index[i] - s->block_wrap[i] - 1] :\n                            v->mb_type[0][s->block_index[i] - 2 * s->block_wrap[i] - 2]) {\n                    dest = s->dest[0] + ((i & 2) - 4) * 4 * s->linesize + ((i & 1) - 2) * 8;\n                    if (put_signed)\n                        s->idsp.put_signed_pixels_clamped(v->block[v->topleft_blk_idx][block_map[i]],\n                                                          i > 3 ? s->dest[i - 3] - 8 * s->uvlinesize - 8 : dest,\n                                                          i > 3 ? s->uvlinesize : s->linesize);\n                    else\n                        s->idsp.put_pixels_clamped(v->block[v->topleft_blk_idx][block_map[i]],\n                                                   i > 3 ? s->dest[i - 3] - 8 * s->uvlinesize - 8 : dest,\n                                                   i > 3 ? s->uvlinesize : s->linesize);\n                }\n            }\n        }\n        if (s->mb_x == v->end_mb_x - 1) {\n            for (i = 0; i < block_count; i++) {\n                if (i > 3 ? v->mb_type[0][s->block_index[i] - s->block_wrap[i]] :\n                            v->mb_type[0][s->block_index[i] - 2 * s->block_wrap[i]]) {\n                    dest = s->dest[0] + ((i & 2) - 4) * 4 * s->linesize + (i & 1) * 8;\n                    if (put_signed)\n                        s->idsp.put_signed_pixels_clamped(v->block[v->top_blk_idx][block_map[i]],\n                                                          i > 3 ? s->dest[i - 3] - 8 * s->uvlinesize : dest,\n                                                          i > 3 ? s->uvlinesize : s->linesize);\n                    else\n                        s->idsp.put_pixels_clamped(v->block[v->top_blk_idx][block_map[i]],\n                                                   i > 3 ? s->dest[i - 3] - 8 * s->uvlinesize : dest,\n                                                   i > 3 ? s->uvlinesize : s->linesize);\n                }\n            }\n        }\n    }\n    if (s->mb_y == s->end_mb_y - 1 || v->fcm == ILACE_FRAME) {\n        if (s->mb_x) {\n            if (v->fcm == ILACE_FRAME)\n                fieldtx = v->fieldtx_plane[s->mb_y * s->mb_stride + s->mb_x - 1];\n            for (i = 0; i < block_count; i++) {\n                if (i > 3 ? v->mb_type[0][s->block_index[i] - 1] :\n                            v->mb_type[0][s->block_index[i] - 2]) {\n                    if (fieldtx)\n                        dest = s->dest[0] + ((i & 2) >> 1) * s->linesize + ((i & 1) - 2) * 8;\n                    else\n                        dest = s->dest[0] + (i & 2) * 4 * s->linesize + ((i & 1) - 2) * 8;\n                    if (put_signed)\n                        s->idsp.put_signed_pixels_clamped(v->block[v->left_blk_idx][block_map[i]],\n                                                          i > 3 ? s->dest[i - 3] - 8 : dest,\n                                                          i > 3 ? s->uvlinesize : s->linesize << fieldtx);\n                    else\n                        s->idsp.put_pixels_clamped(v->block[v->left_blk_idx][block_map[i]],\n                                                   i > 3 ? s->dest[i - 3] - 8 : dest,\n                                                   i > 3 ? s->uvlinesize : s->linesize << fieldtx);\n                }\n            }\n        }\n        if (s->mb_x == v->end_mb_x - 1) {\n            if (v->fcm == ILACE_FRAME)\n                fieldtx = v->fieldtx_plane[s->mb_y * s->mb_stride + s->mb_x];\n            for (i = 0; i < block_count; i++) {\n                if (v->mb_type[0][s->block_index[i]]) {\n                    if (fieldtx)\n                        dest = s->dest[0] + ((i & 2) >> 1) * s->linesize + (i & 1) * 8;\n                    else\n                        dest = s->dest[0] + (i & 2) * 4 * s->linesize + (i & 1) * 8;\n                    if (put_signed)\n                        s->idsp.put_signed_pixels_clamped(v->block[v->cur_blk_idx][block_map[i]],\n                                                          i > 3 ? s->dest[i - 3] : dest,\n                                                          i > 3 ? s->uvlinesize : s->linesize << fieldtx);\n                    else\n                        s->idsp.put_pixels_clamped(v->block[v->cur_blk_idx][block_map[i]],\n                                                   i > 3 ? s->dest[i - 3] : dest,\n                                                   i > 3 ? s->uvlinesize : s->linesize << fieldtx);\n                }\n            }\n        }\n    }\n}\n", "target": 0, "idx": 79865}
{"func": "int create_flush_cmd_control(struct f2fs_sb_info *sbi)\n{\n\tdev_t dev = sbi->sb->s_bdev->bd_dev;\n\tstruct flush_cmd_control *fcc;\n\tint err = 0;\n\n\tif (SM_I(sbi)->fcc_info) {\n\t\tfcc = SM_I(sbi)->fcc_info;\n\t\tgoto init_thread;\n\t}\n\n\tfcc = kzalloc(sizeof(struct flush_cmd_control), GFP_KERNEL);\n\tif (!fcc)\n\t\treturn -ENOMEM;\n\tatomic_set(&fcc->issued_flush, 0);\n\tatomic_set(&fcc->issing_flush, 0);\n \tinit_waitqueue_head(&fcc->flush_wait_queue);\n \tinit_llist_head(&fcc->issue_list);\n \tSM_I(sbi)->fcc_info = fcc;\n init_thread:\n \tfcc->f2fs_issue_flush = kthread_run(issue_flush_thread, sbi,\n \t\t\t\t\"f2fs_flush-%u:%u\", MAJOR(dev), MINOR(dev));\n\tif (IS_ERR(fcc->f2fs_issue_flush)) {\n\t\terr = PTR_ERR(fcc->f2fs_issue_flush);\n\t\tkfree(fcc);\n\t\tSM_I(sbi)->fcc_info = NULL;\n\t\treturn err;\n\t}\n\n\treturn err;\n}\n", "target": 1, "idx": 182554}
{"func": "void ide_dma_cb(void *opaque, int ret)\n{\n    IDEState *s = opaque;\n    int n;\n    int64_t sector_num;\n    bool stay_active = false;\n\n    if (ret == -ECANCELED) {\n        return;\n    }\n    if (ret < 0) {\n        int op = IDE_RETRY_DMA;\n\n        if (s->dma_cmd == IDE_DMA_READ)\n            op |= IDE_RETRY_READ;\n        else if (s->dma_cmd == IDE_DMA_TRIM)\n            op |= IDE_RETRY_TRIM;\n\n        if (ide_handle_rw_error(s, -ret, op)) {\n            return;\n        }\n    }\n\n    n = s->io_buffer_size >> 9;\n    if (n > s->nsector) {\n        /* The PRDs were longer than needed for this request. Shorten them so\n         * we don't get a negative remainder. The Active bit must remain set\n         * after the request completes. */\n        n = s->nsector;\n        stay_active = true;\n    }\n\n    sector_num = ide_get_sector(s);\n    if (n > 0) {\n        assert(s->io_buffer_size == s->sg.size);\n        dma_buf_commit(s, s->io_buffer_size);\n        sector_num += n;\n        ide_set_sector(s, sector_num);\n        s->nsector -= n;\n    }\n\n    /* end of transfer ? */\n    if (s->nsector == 0) {\n        s->status = READY_STAT | SEEK_STAT;\n        ide_set_irq(s->bus);\n        goto eot;\n    }\n\n    /* launch next transfer */\n     n = s->nsector;\n     s->io_buffer_index = 0;\n     s->io_buffer_size = n * 512;\n    if (s->bus->dma->ops->prepare_buf(s->bus->dma, ide_cmd_is_read(s)) == 0) {\n         /* The PRDs were too short. Reset the Active bit, but don't raise an\n          * interrupt. */\n         s->status = READY_STAT | SEEK_STAT;\n         goto eot;\n     }\n \n    printf(\"ide_dma_cb: sector_num=%\" PRId64 \" n=%d, cmd_cmd=%d\\n\",\n           sector_num, n, s->dma_cmd);\n#endif\n\n    if ((s->dma_cmd == IDE_DMA_READ || s->dma_cmd == IDE_DMA_WRITE) &&\n        !ide_sect_range_ok(s, sector_num, n)) {\n        ide_dma_error(s);\n        return;\n    }\n\n    switch (s->dma_cmd) {\n    case IDE_DMA_READ:\n        s->bus->dma->aiocb = dma_blk_read(s->blk, &s->sg, sector_num,\n                                          ide_dma_cb, s);\n        break;\n    case IDE_DMA_WRITE:\n        s->bus->dma->aiocb = dma_blk_write(s->blk, &s->sg, sector_num,\n                                           ide_dma_cb, s);\n        break;\n    case IDE_DMA_TRIM:\n        s->bus->dma->aiocb = dma_blk_io(s->blk, &s->sg, sector_num,\n                                        ide_issue_trim, ide_dma_cb, s,\n                                        DMA_DIRECTION_TO_DEVICE);\n        break;\n    }\n    return;\n\neot:\n    if (s->dma_cmd == IDE_DMA_READ || s->dma_cmd == IDE_DMA_WRITE) {\n        block_acct_done(blk_get_stats(s->blk), &s->acct);\n    }\n    ide_set_inactive(s, stay_active);\n}\n", "target": 1, "idx": 178011}
{"func": "   bool ReceiverWasAdded(const RtpTransceiverState& transceiver_state) {\n     uintptr_t receiver_id = RTCRtpReceiver::getId(\n         transceiver_state.receiver_state()->webrtc_receiver().get());\n     for (const auto& receiver : handler_->rtp_receivers_) {\n      if (receiver->Id() == receiver_id)\n        return false;\n    }\n    return true;\n  }\n", "target": 1, "idx": 187060}
{"func": "bool Instance::HandleInputEvent(const pp::InputEvent& event) {\n  pp::InputEvent event_device_res(event);\n  {\n    pp::MouseInputEvent mouse_event(event);\n    if (!mouse_event.is_null()) {\n      pp::Point point = mouse_event.GetPosition();\n      pp::Point movement = mouse_event.GetMovement();\n      ScalePoint(device_scale_, &point);\n      ScalePoint(device_scale_, &movement);\n      mouse_event = pp::MouseInputEvent(\n          this,\n          event.GetType(),\n          event.GetTimeStamp(),\n          event.GetModifiers(),\n          mouse_event.GetButton(),\n          point,\n          mouse_event.GetClickCount(),\n          movement);\n      event_device_res = mouse_event;\n    }\n  }\n\n  if (event.GetType() == PP_INPUTEVENT_TYPE_MOUSEMOVE &&\n     (event.GetModifiers() & PP_INPUTEVENT_MODIFIER_MIDDLEBUTTONDOWN)) {\n    pp::MouseInputEvent mouse_event(event_device_res);\n    pp::Point pos = mouse_event.GetPosition();\n    EnableAutoscroll(pos);\n    UpdateCursor(CalculateAutoscroll(pos));\n    return true;\n  } else {\n    DisableAutoscroll();\n  }\n\n#ifdef ENABLE_THUMBNAILS\n  if (event.GetType() == PP_INPUTEVENT_TYPE_MOUSELEAVE)\n    thumbnails_.SlideOut();\n\n  if (thumbnails_.HandleEvent(event_device_res))\n    return true;\n#endif\n\n  if (toolbar_->HandleEvent(event_device_res))\n    return true;\n\n#ifdef ENABLE_THUMBNAILS\n  if (v_scrollbar_.get() && event.GetType() == PP_INPUTEVENT_TYPE_MOUSEMOVE) {\n    pp::MouseInputEvent mouse_event(event);\n    pp::Point pt = mouse_event.GetPosition();\n    pp::Rect v_scrollbar_rc;\n    v_scrollbar_->GetLocation(&v_scrollbar_rc);\n    if (v_scrollbar_rc.Contains(pt) &&\n        (event.GetModifiers() & PP_INPUTEVENT_MODIFIER_LEFTBUTTONDOWN)) {\n      thumbnails_.SlideIn();\n    }\n\n    if (!v_scrollbar_rc.Contains(pt) && thumbnails_.visible() &&\n        !(event.GetModifiers() & PP_INPUTEVENT_MODIFIER_LEFTBUTTONDOWN) &&\n        !thumbnails_.rect().Contains(pt)) {\n      thumbnails_.SlideOut();\n    }\n  }\n#endif\n\n  pp::InputEvent offset_event(event_device_res);\n  bool try_engine_first = true;\n  switch (offset_event.GetType()) {\n    case PP_INPUTEVENT_TYPE_MOUSEDOWN:\n    case PP_INPUTEVENT_TYPE_MOUSEUP:\n    case PP_INPUTEVENT_TYPE_MOUSEMOVE:\n    case PP_INPUTEVENT_TYPE_MOUSEENTER:\n    case PP_INPUTEVENT_TYPE_MOUSELEAVE: {\n      pp::MouseInputEvent mouse_event(event_device_res);\n      pp::MouseInputEvent mouse_event_dip(event);\n      pp::Point point = mouse_event.GetPosition();\n      point.set_x(point.x() - available_area_.x());\n      offset_event = pp::MouseInputEvent(\n          this,\n          event.GetType(),\n          event.GetTimeStamp(),\n          event.GetModifiers(),\n          mouse_event.GetButton(),\n          point,\n          mouse_event.GetClickCount(),\n          mouse_event.GetMovement());\n      if (!engine_->IsSelecting()) {\n        if (!IsOverlayScrollbar() &&\n            !available_area_.Contains(mouse_event.GetPosition())) {\n          try_engine_first = false;\n        } else if (IsOverlayScrollbar()) {\n          pp::Rect temp;\n          if ((v_scrollbar_.get() && v_scrollbar_->GetLocation(&temp) &&\n              temp.Contains(mouse_event_dip.GetPosition())) ||\n              (h_scrollbar_.get() && h_scrollbar_->GetLocation(&temp) &&\n              temp.Contains(mouse_event_dip.GetPosition()))) {\n            try_engine_first = false;\n          }\n        }\n      }\n      break;\n    }\n    default:\n      break;\n  }\n  if (try_engine_first && engine_->HandleEvent(offset_event))\n    return true;\n\n  if (v_scrollbar_.get() && event.GetType() == PP_INPUTEVENT_TYPE_KEYDOWN) {\n    pp::KeyboardInputEvent keyboard_event(event);\n    bool no_h_scrollbar = !h_scrollbar_.get();\n    uint32_t key_code = keyboard_event.GetKeyCode();\n    bool page_down = no_h_scrollbar && key_code == ui::VKEY_RIGHT;\n    bool page_up = no_h_scrollbar && key_code == ui::VKEY_LEFT;\n    if (zoom_mode_ == ZOOM_FIT_TO_PAGE) {\n      bool has_shift =\n          keyboard_event.GetModifiers() & PP_INPUTEVENT_MODIFIER_SHIFTKEY;\n      bool key_is_space = key_code == ui::VKEY_SPACE;\n      page_down |= key_is_space || key_code == ui::VKEY_NEXT;\n      page_up |= (key_is_space && has_shift) || (key_code == ui::VKEY_PRIOR);\n     }\n     if (page_down) {\n       int page = engine_->GetFirstVisiblePage();\n      if (engine_->GetPageRect(page).bottom() * zoom_ <=\n          v_scrollbar_->GetValue())\n        page++;\n      ScrollToPage(page + 1);\n      UpdateCursor(PP_CURSORTYPE_POINTER);\n       return true;\n     } else if (page_up) {\n       int page = engine_->GetFirstVisiblePage();\n       if (engine_->GetPageRect(page).y() * zoom_ >= v_scrollbar_->GetValue())\n         page--;\n       ScrollToPage(page);\n      UpdateCursor(PP_CURSORTYPE_POINTER);\n      return true;\n    }\n  }\n\n  if (v_scrollbar_.get() && v_scrollbar_->HandleEvent(event)) {\n    UpdateCursor(PP_CURSORTYPE_POINTER);\n    return true;\n  }\n\n  if (h_scrollbar_.get() && h_scrollbar_->HandleEvent(event)) {\n    UpdateCursor(PP_CURSORTYPE_POINTER);\n    return true;\n  }\n\n  if (timer_pending_ &&\n      (event.GetType() == PP_INPUTEVENT_TYPE_MOUSEUP ||\n       event.GetType() == PP_INPUTEVENT_TYPE_MOUSEMOVE)) {\n    timer_factory_.CancelAll();\n    timer_pending_ = false;\n  } else if (event.GetType() == PP_INPUTEVENT_TYPE_MOUSEMOVE &&\n             engine_->IsSelecting()) {\n    bool set_timer = false;\n    pp::MouseInputEvent mouse_event(event);\n    if (v_scrollbar_.get() &&\n        (mouse_event.GetPosition().y() <= 0 ||\n         mouse_event.GetPosition().y() >= (plugin_dip_size_.height() - 1))) {\n      v_scrollbar_->ScrollBy(\n          PP_SCROLLBY_LINE, mouse_event.GetPosition().y() >= 0 ? 1: -1);\n      set_timer = true;\n    }\n    if (h_scrollbar_.get() &&\n        (mouse_event.GetPosition().x() <= 0 ||\n         mouse_event.GetPosition().x() >= (plugin_dip_size_.width() - 1))) {\n      h_scrollbar_->ScrollBy(PP_SCROLLBY_LINE,\n          mouse_event.GetPosition().x() >= 0 ? 1: -1);\n      set_timer = true;\n    }\n\n    if (set_timer) {\n      last_mouse_event_ = pp::MouseInputEvent(event);\n\n      pp::CompletionCallback callback =\n          timer_factory_.NewCallback(&Instance::OnTimerFired);\n      pp::Module::Get()->core()->CallOnMainThread(kDragTimerMs, callback);\n      timer_pending_ = true;\n    }\n  }\n\n  if (event.GetType() == PP_INPUTEVENT_TYPE_KEYDOWN &&\n      event.GetModifiers() & kDefaultKeyModifier) {\n    pp::KeyboardInputEvent keyboard_event(event);\n    switch (keyboard_event.GetKeyCode()) {\n      case 'A':\n        engine_->SelectAll();\n        return true;\n    }\n  }\n\n  return (event.GetType() == PP_INPUTEVENT_TYPE_MOUSEDOWN);\n}\n", "target": 1, "idx": 185343}
{"func": "void red_channel_push(RedChannel *channel)\n{\n    RingItem *link;\n    RingItem *next;\n    RedChannelClient *rcc;\n\n    if (!channel) {\n        return;\n    }\n    RING_FOREACH_SAFE(link, next, &channel->clients) {\n        rcc = SPICE_CONTAINEROF(link, RedChannelClient, channel_link);\n        red_channel_client_push(rcc);\n    }\n}\n", "target": 0, "idx": 2171}
{"func": " av_cold void ff_mpv_idct_init(MpegEncContext *s)\n {\n     ff_idctdsp_init(&s->idsp, s->avctx);\n \n     /* load & permutate scantables\n     * note: only wmv uses different ones\n     */\n    if (s->alternate_scan) {\n        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable, ff_alternate_vertical_scan);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, ff_alternate_vertical_scan);\n    } else {\n        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable, ff_zigzag_direct);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, ff_zigzag_direct);\n    }\n    ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_horizontal_scan);\n    ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);\n}\n", "target": 1, "idx": 182362}
{"func": "static Image *ReadOneJNGImage(MngInfo *mng_info,\n    const ImageInfo *image_info, ExceptionInfo *exception)\n{\n  Image\n    *alpha_image,\n    *color_image,\n    *image,\n    *jng_image;\n\n  ImageInfo\n    *alpha_image_info,\n    *color_image_info;\n\n  MagickBooleanType\n    logging;\n\n  int\n    unique_filenames;\n\n  ssize_t\n    y;\n\n  MagickBooleanType\n    status;\n\n  png_uint_32\n    jng_height,\n    jng_width;\n\n  png_byte\n    jng_color_type,\n    jng_image_sample_depth,\n    jng_image_compression_method,\n    jng_image_interlace_method,\n    jng_alpha_sample_depth,\n    jng_alpha_compression_method,\n    jng_alpha_filter_method,\n    jng_alpha_interlace_method;\n\n  register const PixelPacket\n    *s;\n\n  register ssize_t\n    i,\n    x;\n\n  register PixelPacket\n    *q;\n\n  register unsigned char\n    *p;\n\n  unsigned int\n    read_JSEP,\n    reading_idat;\n\n  size_t\n    length;\n\n  jng_alpha_compression_method=0;\n  jng_alpha_sample_depth=8;\n  jng_color_type=0;\n  jng_height=0;\n  jng_width=0;\n  alpha_image=(Image *) NULL;\n  color_image=(Image *) NULL;\n  alpha_image_info=(ImageInfo *) NULL;\n  color_image_info=(ImageInfo *) NULL;\n  unique_filenames=0;\n\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  Enter ReadOneJNGImage()\");\n\n  image=mng_info->image;\n\n  if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL)\n    {\n      /*\n        Allocate next image structure.\n      */\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"  AcquireNextImage()\");\n\n      AcquireNextImage(image_info,image);\n\n      if (GetNextImageInList(image) == (Image *) NULL)\n        return(DestroyImageList(image));\n\n      image=SyncNextImageInList(image);\n    }\n  mng_info->image=image;\n\n  /*\n    Signature bytes have already been read.\n  */\n\n  read_JSEP=MagickFalse;\n  reading_idat=MagickFalse;\n  for (;;)\n  {\n    char\n      type[MaxTextExtent];\n\n    unsigned char\n      *chunk;\n\n    unsigned int\n      count;\n\n    /*\n      Read a new JNG chunk.\n    */\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n      2*GetBlobSize(image));\n\n    if (status == MagickFalse)\n      break;\n\n    type[0]='\\0';\n    (void) ConcatenateMagickString(type,\"errr\",MaxTextExtent);\n    length=ReadBlobMSBLong(image);\n    count=(unsigned int) ReadBlob(image,4,(unsigned char *) type);\n\n    if (logging != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Reading JNG chunk type %c%c%c%c, length: %.20g\",\n        type[0],type[1],type[2],type[3],(double) length);\n\n    if (length > PNG_UINT_31_MAX || count == 0)\n      ThrowReaderException(CorruptImageError,\"CorruptImage\");\n\n    p=NULL;\n    chunk=(unsigned char *) NULL;\n \n     if (length != 0)\n       {\n         chunk=(unsigned char *) AcquireQuantumMemory(length+MagickPathExtent,\n           sizeof(*chunk));\n \n        if (chunk == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        for (i=0; i < (ssize_t) length; i++)\n        {\n          int\n            c;\n\n          c=ReadBlobByte(image);\n          if (c == EOF)\n            break;\n          chunk[i]=(unsigned char) c;\n        }\n\n        p=chunk;\n      }\n\n    (void) ReadBlobMSBLong(image);  /* read crc word */\n\n    if (memcmp(type,mng_JHDR,4) == 0)\n      {\n        if (length == 16)\n          {\n            jng_width=(size_t) ((p[0] << 24) | (p[1] << 16) |\n              (p[2] << 8) | p[3]);\n            jng_height=(size_t) ((p[4] << 24) | (p[5] << 16) |\n              (p[6] << 8) | p[7]);\n            if ((jng_width == 0) || (jng_height == 0))\n              ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n            jng_color_type=p[8];\n            jng_image_sample_depth=p[9];\n            jng_image_compression_method=p[10];\n            jng_image_interlace_method=p[11];\n\n            image->interlace=jng_image_interlace_method != 0 ? PNGInterlace :\n              NoInterlace;\n\n            jng_alpha_sample_depth=p[12];\n            jng_alpha_compression_method=p[13];\n            jng_alpha_filter_method=p[14];\n            jng_alpha_interlace_method=p[15];\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_width:      %16lu,    jng_height:     %16lu\\n\"\n                  \"    jng_color_type: %16d,     jng_image_sample_depth: %3d\\n\"\n                  \"    jng_image_compression_method:%3d\",\n                  (unsigned long) jng_width, (unsigned long) jng_height,\n                  jng_color_type, jng_image_sample_depth,\n                  jng_image_compression_method);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_image_interlace_method:  %3d\"\n                  \"    jng_alpha_sample_depth:      %3d\",\n                  jng_image_interlace_method,\n                  jng_alpha_sample_depth);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_alpha_compression_method:%3d\\n\"\n                  \"    jng_alpha_filter_method:     %3d\\n\"\n                  \"    jng_alpha_interlace_method:  %3d\",\n                  jng_alpha_compression_method,\n                  jng_alpha_filter_method,\n                  jng_alpha_interlace_method);\n              }\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n\n    if ((reading_idat == MagickFalse) && (read_JSEP == MagickFalse) &&\n        ((memcmp(type,mng_JDAT,4) == 0) || (memcmp(type,mng_JdAA,4) == 0) ||\n         (memcmp(type,mng_IDAT,4) == 0) || (memcmp(type,mng_JDAA,4) == 0)))\n      {\n        /*\n           o create color_image\n           o open color_blob, attached to color_image\n           o if (color type has alpha)\n               open alpha_blob, attached to alpha_image\n        */\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Creating color_blob.\");\n\n        color_image_info=(ImageInfo *)AcquireMagickMemory(sizeof(ImageInfo));\n\n        if (color_image_info == (ImageInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        GetImageInfo(color_image_info);\n        color_image=AcquireImage(color_image_info);\n\n        if (color_image == (Image *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        (void) AcquireUniqueFilename(color_image->filename);\n        unique_filenames++;\n        status=OpenBlob(color_image_info,color_image,WriteBinaryBlobMode,\n          exception);\n\n        if (status == MagickFalse)\n          {\n            color_image=DestroyImage(color_image);\n            return(DestroyImageList(image));\n          }\n\n        if ((image_info->ping == MagickFalse) && (jng_color_type >= 12))\n          {\n            alpha_image_info=(ImageInfo *)\n              AcquireMagickMemory(sizeof(ImageInfo));\n\n            if (alpha_image_info == (ImageInfo *) NULL)\n              {\n                color_image=DestroyImage(color_image);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n\n            GetImageInfo(alpha_image_info);\n            alpha_image=AcquireImage(alpha_image_info);\n\n            if (alpha_image == (Image *) NULL)\n              {\n                alpha_image_info=DestroyImageInfo(alpha_image_info);\n                color_image=DestroyImage(color_image);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Creating alpha_blob.\");\n\n            (void) AcquireUniqueFilename(alpha_image->filename);\n            unique_filenames++;\n            status=OpenBlob(alpha_image_info,alpha_image,WriteBinaryBlobMode,\n              exception);\n\n            if (status == MagickFalse)\n              {\n                alpha_image=DestroyImage(alpha_image);\n                alpha_image_info=DestroyImageInfo(alpha_image_info);\n                color_image=DestroyImage(color_image);\n                return(DestroyImageList(image));\n              }\n\n            if (jng_alpha_compression_method == 0)\n              {\n                unsigned char\n                  data[18];\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Writing IHDR chunk to alpha_blob.\");\n\n                (void) WriteBlob(alpha_image,8,(const unsigned char *)\n                  \"\\211PNG\\r\\n\\032\\n\");\n\n                (void) WriteBlobMSBULong(alpha_image,13L);\n                PNGType(data,mng_IHDR);\n                LogPNGChunk(logging,mng_IHDR,13L);\n                PNGLong(data+4,jng_width);\n                PNGLong(data+8,jng_height);\n                data[12]=jng_alpha_sample_depth;\n                data[13]=0; /* color_type gray */\n                data[14]=0; /* compression method 0 */\n                data[15]=0; /* filter_method 0 */\n                data[16]=0; /* interlace_method 0 */\n                (void) WriteBlob(alpha_image,17,data);\n                (void) WriteBlobMSBULong(alpha_image,crc32(0,data,17));\n              }\n          }\n        reading_idat=MagickTrue;\n      }\n\n    if (memcmp(type,mng_JDAT,4) == 0)\n      {\n        /* Copy chunk to color_image->blob */\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Copying JDAT chunk data to color_blob.\");\n\n        if (length != 0)\n          {\n            (void) WriteBlob(color_image,length,chunk);\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n          }\n\n        continue;\n      }\n\n    if (memcmp(type,mng_IDAT,4) == 0)\n      {\n        png_byte\n           data[5];\n\n        /* Copy IDAT header and chunk data to alpha_image->blob */\n\n        if (alpha_image != NULL && image_info->ping == MagickFalse)\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Copying IDAT chunk data to alpha_blob.\");\n\n            (void) WriteBlobMSBULong(alpha_image,(size_t) length);\n            PNGType(data,mng_IDAT);\n            LogPNGChunk(logging,mng_IDAT,length);\n            (void) WriteBlob(alpha_image,4,data);\n            (void) WriteBlob(alpha_image,length,chunk);\n            (void) WriteBlobMSBULong(alpha_image,\n              crc32(crc32(0,data,4),chunk,(uInt) length));\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if ((memcmp(type,mng_JDAA,4) == 0) || (memcmp(type,mng_JdAA,4) == 0))\n      {\n        /* Copy chunk data to alpha_image->blob */\n\n        if (alpha_image != NULL && image_info->ping == MagickFalse)\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Copying JDAA chunk data to alpha_blob.\");\n\n            (void) WriteBlob(alpha_image,length,chunk);\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_JSEP,4) == 0)\n      {\n        read_JSEP=MagickTrue;\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_bKGD,4) == 0)\n      {\n        if (length == 2)\n          {\n            image->background_color.red=ScaleCharToQuantum(p[1]);\n            image->background_color.green=image->background_color.red;\n            image->background_color.blue=image->background_color.red;\n          }\n\n        if (length == 6)\n          {\n            image->background_color.red=ScaleCharToQuantum(p[1]);\n            image->background_color.green=ScaleCharToQuantum(p[3]);\n            image->background_color.blue=ScaleCharToQuantum(p[5]);\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_gAMA,4) == 0)\n      {\n        if (length == 4)\n          image->gamma=((float) mng_get_long(p))*0.00001;\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_cHRM,4) == 0)\n      {\n        if (length == 32)\n          {\n            image->chromaticity.white_point.x=0.00001*mng_get_long(p);\n            image->chromaticity.white_point.y=0.00001*mng_get_long(&p[4]);\n            image->chromaticity.red_primary.x=0.00001*mng_get_long(&p[8]);\n            image->chromaticity.red_primary.y=0.00001*mng_get_long(&p[12]);\n            image->chromaticity.green_primary.x=0.00001*mng_get_long(&p[16]);\n            image->chromaticity.green_primary.y=0.00001*mng_get_long(&p[20]);\n            image->chromaticity.blue_primary.x=0.00001*mng_get_long(&p[24]);\n            image->chromaticity.blue_primary.y=0.00001*mng_get_long(&p[28]);\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_sRGB,4) == 0)\n      {\n        if (length == 1)\n          {\n            image->rendering_intent=\n              Magick_RenderingIntent_from_PNG_RenderingIntent(p[0]);\n            image->gamma=1.000f/2.200f;\n            image->chromaticity.red_primary.x=0.6400f;\n            image->chromaticity.red_primary.y=0.3300f;\n            image->chromaticity.green_primary.x=0.3000f;\n            image->chromaticity.green_primary.y=0.6000f;\n            image->chromaticity.blue_primary.x=0.1500f;\n            image->chromaticity.blue_primary.y=0.0600f;\n            image->chromaticity.white_point.x=0.3127f;\n            image->chromaticity.white_point.y=0.3290f;\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_oFFs,4) == 0)\n      {\n        if (length > 8)\n          {\n            image->page.x=(ssize_t) mng_get_long(p);\n            image->page.y=(ssize_t) mng_get_long(&p[4]);\n\n            if ((int) p[8] != 0)\n              {\n                image->page.x/=10000;\n                image->page.y/=10000;\n              }\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_pHYs,4) == 0)\n      {\n        if (length > 8)\n          {\n            image->x_resolution=(double) mng_get_long(p);\n            image->y_resolution=(double) mng_get_long(&p[4]);\n            if ((int) p[8] == PNG_RESOLUTION_METER)\n              {\n                image->units=PixelsPerCentimeterResolution;\n                image->x_resolution=image->x_resolution/100.0f;\n                image->y_resolution=image->y_resolution/100.0f;\n              }\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n#if 0\n    if (memcmp(type,mng_iCCP,4) == 0)\n      {\n        /* To do: */\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n#endif\n\n    if (length != 0)\n      chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n    if (memcmp(type,mng_IEND,4))\n      continue;\n\n    break;\n  }\n\n\n  /* IEND found */\n\n  /*\n    Finish up reading image data:\n\n       o read main image from color_blob.\n\n       o close color_blob.\n\n       o if (color_type has alpha)\n            if alpha_encoding is PNG\n               read secondary image from alpha_blob via ReadPNG\n            if alpha_encoding is JPEG\n               read secondary image from alpha_blob via ReadJPEG\n\n       o close alpha_blob.\n\n       o copy intensity of secondary image into\n         opacity samples of main image.\n\n       o destroy the secondary image.\n  */\n\n  if (color_image_info == (ImageInfo *) NULL)\n    {\n      assert(color_image == (Image *) NULL);\n      assert(alpha_image == (Image *) NULL);\n      return(DestroyImageList(image));\n    }\n\n  if (color_image == (Image *) NULL)\n    {\n      assert(alpha_image == (Image *) NULL);\n      return(DestroyImageList(image));\n    }\n\n  (void) SeekBlob(color_image,0,SEEK_SET);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Reading jng_image from color_blob.\");\n\n  assert(color_image_info != (ImageInfo *) NULL);\n  (void) FormatLocaleString(color_image_info->filename,MaxTextExtent,\"%s\",\n    color_image->filename);\n\n  color_image_info->ping=MagickFalse;   /* To do: avoid this */\n  jng_image=ReadImage(color_image_info,exception);\n\n  (void) RelinquishUniqueFileResource(color_image->filename);\n  unique_filenames--;\n  color_image=DestroyImage(color_image);\n  color_image_info=DestroyImageInfo(color_image_info);\n\n  if (jng_image == (Image *) NULL)\n    return(DestroyImageList(image));\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Copying jng_image pixels to main image.\");\n  image->columns=jng_width;\n  image->rows=jng_height;\n  length=image->columns*sizeof(PixelPacket);\n\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    s=GetVirtualPixels(jng_image,0,y,image->columns,1,&image->exception);\n    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    (void) CopyMagickMemory(q,s,length);\n\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n  }\n\n  jng_image=DestroyImage(jng_image);\n\n  if (image_info->ping == MagickFalse)\n    {\n     if (jng_color_type >= 12)\n       {\n         if (jng_alpha_compression_method == 0)\n           {\n             png_byte\n               data[5];\n             (void) WriteBlobMSBULong(alpha_image,0x00000000L);\n             PNGType(data,mng_IEND);\n             LogPNGChunk(logging,mng_IEND,0L);\n             (void) WriteBlob(alpha_image,4,data);\n             (void) WriteBlobMSBULong(alpha_image,crc32(0,data,4));\n           }\n\n         (void) SeekBlob(alpha_image,0,SEEK_SET);\n\n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"    Reading opacity from alpha_blob.\");\n\n         (void) FormatLocaleString(alpha_image_info->filename,MaxTextExtent,\n           \"%s\",alpha_image->filename);\n\n         jng_image=ReadImage(alpha_image_info,exception);\n\n         if (jng_image != (Image *) NULL)\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             s=GetVirtualPixels(jng_image,0,y,image->columns,1,\n                &image->exception);\n             q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n             if (image->matte != MagickFalse)\n               for (x=(ssize_t) image->columns; x != 0; x--,q++,s++)\n                  SetPixelOpacity(q,QuantumRange-\n                      GetPixelRed(s));\n\n             else\n               for (x=(ssize_t) image->columns; x != 0; x--,q++,s++)\n               {\n                  SetPixelAlpha(q,GetPixelRed(s));\n                  if (GetPixelOpacity(q) != OpaqueOpacity)\n                    image->matte=MagickTrue;\n               }\n\n             if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               break;\n           }\n         (void) RelinquishUniqueFileResource(alpha_image->filename);\n         unique_filenames--;\n         alpha_image=DestroyImage(alpha_image);\n         alpha_image_info=DestroyImageInfo(alpha_image_info);\n         if (jng_image != (Image *) NULL)\n           jng_image=DestroyImage(jng_image);\n       }\n    }\n\n  /* Read the JNG image.  */\n\n  if (mng_info->mng_type == 0)\n    {\n      mng_info->mng_width=jng_width;\n      mng_info->mng_height=jng_height;\n    }\n\n  if (image->page.width == 0 && image->page.height == 0)\n    {\n      image->page.width=jng_width;\n      image->page.height=jng_height;\n    }\n\n  if (image->page.x == 0 && image->page.y == 0)\n    {\n      image->page.x=mng_info->x_off[mng_info->object_id];\n      image->page.y=mng_info->y_off[mng_info->object_id];\n    }\n\n  else\n    {\n      image->page.y=mng_info->y_off[mng_info->object_id];\n    }\n\n  mng_info->image_found++;\n  status=SetImageProgress(image,LoadImagesTag,2*TellBlob(image),\n    2*GetBlobSize(image));\n\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  exit ReadOneJNGImage(); unique_filenames=%d\",unique_filenames);\n\n  return(image);\n}\n", "target": 1, "idx": 181151}
{"func": "nfsd4_close(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t    struct nfsd4_close *close)\n{\n\t__be32 status;\n\tstruct nfs4_ol_stateid *stp;\n\tstruct net *net = SVC_NET(rqstp);\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tdprintk(\"NFSD: nfsd4_close on file %pd\\n\", \n\t\t\tcstate->current_fh.fh_dentry);\n\n\tstatus = nfs4_preprocess_seqid_op(cstate, close->cl_seqid,\n\t\t\t\t\t&close->cl_stateid,\n\t\t\t\t\tNFS4_OPEN_STID|NFS4_CLOSED_STID,\n\t\t\t\t\t&stp, nn);\n\tnfsd4_bump_seqid(cstate, status);\n\tif (status)\n\t\tgoto out; \n\tnfs4_inc_and_copy_stateid(&close->cl_stateid, &stp->st_stid);\n\tmutex_unlock(&stp->st_mutex);\n\n\tnfsd4_close_open_stateid(stp);\n\n\t/* put reference from nfs4_preprocess_seqid_op */\n\tnfs4_put_stid(&stp->st_stid);\nout:\n\treturn status;\n}\n", "target": 0, "idx": 65570}
{"func": "net::BackoffEntry* DataReductionProxyConfigServiceClient::GetBackoffEntry() {\n  DCHECK(thread_checker_.CalledOnValidThread());\n  return &backoff_entry_;\n}\n", "target": 0, "idx": 150576}
{"func": "std::string ExtractResourceId(const GURL& url) {\n  return net::UnescapeURLComponent(url.ExtractFileName(),\n                                   net::UnescapeRule::URL_SPECIAL_CHARS);\n}\n", "target": 0, "idx": 111633}
{"func": "static int collationMatch(const char *zColl, Index *pIndex){\n  int i;\n  assert( zColl!=0 );\n  for(i=0; i<pIndex->nColumn; i++){\n    const char *z = pIndex->azColl[i];\n    assert( z!=0 || pIndex->aiColumn[i]<0 );\n    if( pIndex->aiColumn[i]>=0 && 0==sqlite3StrICmp(z, zColl) ){\n      return 1;\n    }\n  }\n  return 0;\n}\n", "target": 0, "idx": 149098}
{"func": "GLES2Implementation::SingleThreadChecker::~SingleThreadChecker() {\n  --gles2_implementation_->use_count_;\n  CHECK_EQ(0, gles2_implementation_->use_count_);\n}\n", "target": 0, "idx": 153860}
{"func": "INST_HANDLER (muls) {\t// MULS Rd, Rr\n\tint d = (buf[0] >> 4 & 0x0f) + 16;\n\tint r = (buf[0] & 0x0f) + 16;\n\n\tESIL_A (\"r%d,DUP,0x80,&,?{,0xffff00,|,},\", r);\t// sign extension Rr\n\tESIL_A (\"r%d,DUP,0x80,&,?{,0xffff00,|,},\", d);\t// sign extension Rd\n\tESIL_A (\"*,\");\t\t\t\t\t// 0: (Rd*Rr)\n\tESIL_A (\"DUP,0xff,&,r0,=,\");\t\t\t// r0 = LO(0)\n\tESIL_A (\"8,0,RPICK,>>,0xff,&,r1,=,\");\t\t// r1 = HI(0)\n\tESIL_A (\"DUP,0x8000,&,!,!,cf,=,\");\t\t// C = R/15\n\tESIL_A (\"DUP,!,zf,=,\");\t\t\t\t// Z = !R\n}\n", "target": 0, "idx": 82740}
{"func": "parse_post_op_attr(netdissect_options *ndo,\n                   const uint32_t *dp, int verbose)\n{\n\tND_TCHECK(dp[0]);\n\tif (!EXTRACT_32BITS(&dp[0]))\n\t\treturn (dp + 1);\n\tdp++;\n\tif (verbose) {\n\t\treturn parsefattr(ndo, dp, verbose, 1);\n\t} else\n\t\treturn (dp + (NFSX_V3FATTR / sizeof (uint32_t)));\ntrunc:\n\treturn (NULL);\n}\n", "target": 0, "idx": 62446}
{"func": "static int su3000_frontend_attach(struct dvb_usb_adapter *d)\n {\n\tu8 obuf[3] = { 0xe, 0x80, 0 };\n\tu8 ibuf[] = { 0 };\n \n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n \t\terr(\"command 0x0e transfer failed.\");\n \n\tobuf[0] = 0xe;\n\tobuf[1] = 0x02;\n\tobuf[2] = 1;\n \n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n \t\terr(\"command 0x0e transfer failed.\");\n \tmsleep(300);\n \n\tobuf[0] = 0xe;\n\tobuf[1] = 0x83;\n\tobuf[2] = 0;\n \n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n \t\terr(\"command 0x0e transfer failed.\");\n \n\tobuf[0] = 0xe;\n\tobuf[1] = 0x83;\n\tobuf[2] = 1;\n \n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n \t\terr(\"command 0x0e transfer failed.\");\n \n\tobuf[0] = 0x51;\n \n\tif (dvb_usb_generic_rw(d->dev, obuf, 1, ibuf, 1, 0) < 0)\n \t\terr(\"command 0x51 transfer failed.\");\n \n\td->fe_adap[0].fe = dvb_attach(ds3000_attach, &su3000_ds3000_config,\n\t\t\t\t\t&d->dev->i2c_adap);\n\tif (d->fe_adap[0].fe == NULL)\n \t\treturn -EIO;\n \n\tif (dvb_attach(ts2020_attach, d->fe_adap[0].fe,\n \t\t\t\t&dw2104_ts2020_config,\n\t\t\t\t&d->dev->i2c_adap)) {\n \t\tinfo(\"Attached DS3000/TS2020!\");\n \t\treturn 0;\n \t}\n\n\tinfo(\"Failed to attach DS3000/TS2020!\");\n \treturn -EIO;\n }\n", "target": 1, "idx": 181397}
{"func": " bool BluetoothDeviceChromeOS::ExpectingConfirmation() const {\n  return !confirmation_callback_.is_null();\n }\n", "target": 1, "idx": 184916}
{"func": " bool SoundPool::unload(int sampleID)\n{\n    ALOGV(\"unload: sampleID=%d\", sampleID);\n Mutex::Autolock lock(&mLock);\n return mSamples.removeItem(sampleID);\n}\n", "target": 0, "idx": 175100}
{"func": "static int dynamicGetbuf(gdIOCtxPtr ctx, void *buf, int len)\n{\n\tint rlen, remain;\n\tdpIOCtxPtr dctx;\n\tdynamicPtr *dp;\n\n\tdctx = (dpIOCtxPtr) ctx;\n\tdp = dctx->dp;\n\n\tremain = dp->logicalSize - dp->pos;\n \tif(remain >= len) {\n \t\trlen = len;\n \t} else {\n\t\tif(remain == 0) {\n \t\t\t/* 2.0.34: EOF is incorrect. We use 0 for\n \t\t\t * errors and EOF, just like fileGetbuf,\n \t\t\t * which is a simple fread() wrapper.\n\t\t\t * TBB. Original bug report: Daniel Cowgill. */\n\t\t\treturn 0; /* NOT EOF */\n\t\t}\n\n\t\trlen = remain;\n\t}\n\n\tmemcpy(buf, (void *) ((char *)dp->data + dp->pos), rlen);\n\tdp->pos += rlen;\n\n\treturn rlen;\n}\n", "target": 1, "idx": 181941}
{"func": " ServiceWorkerHandler::ServiceWorkerHandler()\n     : DevToolsDomainHandler(ServiceWorker::Metainfo::domainName),\n       enabled_(false),\n      process_(nullptr),\n       weak_factory_(this) {}\n", "target": 1, "idx": 186745}
{"func": "  void CheckMaybeActivateDataReductionProxy(bool initially_enabled,\n                                            bool request_succeeded,\n                                            bool expected_enabled,\n                                            bool expected_restricted,\n                                            bool expected_fallback_restricted) {\n    test_context_->SetDataReductionProxyEnabled(initially_enabled);\n    test_context_->config()->UpdateConfigForTesting(initially_enabled,\n                                                    request_succeeded, true);\n    ExpectSetProxyPrefs(expected_enabled, false);\n     settings_->MaybeActivateDataReductionProxy(false);\n     test_context_->RunUntilIdle();\n   }\n", "target": 0, "idx": 155522}
{"func": "void Chunk::changesAndSize( RIFF_MetaHandler* handler )\n{\n\thasChange = false; // unknown chunk ==> no change, naturally\n\tthis->newSize = this->oldSize;\n}\n", "target": 0, "idx": 16071}
{"func": " void OffscreenCanvasSurfaceImpl::Create(\n    mojo::InterfaceRequest<blink::mojom::OffscreenCanvasSurface> request) {\n  mojo::MakeStrongBinding(base::MakeUnique<OffscreenCanvasSurfaceImpl>(),\n                          std::move(request));\n}\n", "target": 0, "idx": 139766}
{"func": "void Dispatcher::OnShouldSuspend(const std::string& extension_id,\n                                 uint64_t sequence_id) {\n  RenderThread::Get()->Send(\n      new ExtensionHostMsg_ShouldSuspendAck(extension_id, sequence_id));\n}\n", "target": 0, "idx": 145243}
{"func": "static void fpu_init(struct sh_fpu_soft_struct *fpu)\n{\n\tint i;\n\n\tfpu->fpscr = FPSCR_INIT;\n\tfpu->fpul = 0;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tfpu->fp_regs[i] = 0;\n\t\tfpu->xfp_regs[i]= 0;\n\t}\n}\n", "target": 0, "idx": 25611}
{"func": " static void sycc422_to_rgb(opj_image_t *img)\n {\t\n \tint *d0, *d1, *d2, *r, *g, *b;\n \tconst int *y, *cb, *cr;\n\tunsigned int maxw, maxh, max;\n \tint offset, upb;\n\tunsigned int i, j;\n \n \tupb = (int)img->comps[0].prec;\n \toffset = 1<<(upb - 1); upb = (1<<upb)-1;\n \n\tmaxw = (unsigned int)img->comps[0].w; maxh = (unsigned int)img->comps[0].h;\n \tmax = maxw * maxh;\n \n \ty = img->comps[0].data;\n \tcb = img->comps[1].data;\n \tcr = img->comps[2].data;\n \n\td0 = r = (int*)malloc(sizeof(int) * (size_t)max);\n\td1 = g = (int*)malloc(sizeof(int) * (size_t)max);\n\td2 = b = (int*)malloc(sizeof(int) * (size_t)max);\n \n \tif(r == NULL || g == NULL || b == NULL) goto fails;\n \n \tfor(i=0U; i < maxh; ++i)\n \t{\n\t\tfor(j=0U; j < (maxw & ~(unsigned int)1U); j += 2U)\n \t\t{\n \t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n \t\t\t++y; ++r; ++g; ++b;\n \t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n \t\t\t++y; ++r; ++g; ++b; ++cb; ++cr;\n \t\t}\n\t\tif (j < maxw) {\n \t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n \t\t\t++y; ++r; ++g; ++b; ++cb; ++cr;\n \t\t}\n \t}\n \tfree(img->comps[0].data); img->comps[0].data = d0;\n \tfree(img->comps[1].data); img->comps[1].data = d1;\n \tfree(img->comps[2].data); img->comps[2].data = d2;\n \n#if defined(USE_JPWL) || defined(USE_MJ2)\n\timg->comps[1].w = maxw; img->comps[1].h = maxh;\n\timg->comps[2].w = maxw; img->comps[2].h = maxh;\n#else\n\timg->comps[1].w = (OPJ_UINT32)maxw; img->comps[1].h = (OPJ_UINT32)maxh;\n\timg->comps[2].w = (OPJ_UINT32)maxw; img->comps[2].h = (OPJ_UINT32)maxh;\n#endif\n\timg->comps[1].dx = img->comps[0].dx;\n\timg->comps[2].dx = img->comps[0].dx;\n\timg->comps[1].dy = img->comps[0].dy;\n\timg->comps[2].dy = img->comps[0].dy;\n \treturn;\n \n fails:\n\tif(r) free(r);\n\tif(g) free(g);\n\tif(b) free(b);\n }/* sycc422_to_rgb() */\n", "target": 1, "idx": 182012}
{"func": "R_API RConfigNode* r_config_set(RConfig *cfg, const char *name, const char *value) {\n\tRConfigNode *node = NULL;\n\tchar *ov = NULL;\n\tut64 oi;\n\tif (!cfg || STRNULL (name)) {\n\t\treturn NULL;\n\t}\n\tnode = r_config_node_get (cfg, name);\n\tif (node) {\n\t\tif (node->flags & CN_RO) {\n\t\t\teprintf (\"(error: '%s' config key is read only)\\n\", name);\n\t\t\treturn node;\n\t\t}\n\t\toi = node->i_value;\n\t\tif (node->value) {\n\t\t\tov = strdup (node->value);\n\t\t\tif (!ov) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t} else {\n\t\t\tfree (node->value);\n\t\t\tnode->value = strdup (\"\");\n\t\t}\n\t\tif (node->flags & CN_BOOL) {\n\t\t\tbool b = is_true (value);\n\t\t\tnode->i_value = (ut64) b? 1: 0;\n\t\t\tchar *value = strdup (r_str_bool (b));\n\t\t\tif (value) {\n\t\t\t\tfree (node->value);\n\t\t\t\tnode->value = value;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!value) {\n\t\t\t\tfree (node->value);\n\t\t\t\tnode->value = strdup (\"\");\n\t\t\t\tnode->i_value = 0;\n\t\t\t} else {\n \t\t\t\tif (node->value == value) {\n \t\t\t\t\tgoto beach;\n \t\t\t\t}\n\t\t\t\tfree (node->value);\n \t\t\t\tnode->value = strdup (value);\n \t\t\t\tif (IS_DIGIT (*value)) {\n \t\t\t\t\tif (strchr (value, '/')) {\n \t\t\t\t\t\tnode->i_value = r_num_get (cfg->num, value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnode->i_value = r_num_math (cfg->num, value);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnode->i_value = 0;\n\t\t\t\t}\n\t\t\t\tnode->flags |= CN_INT;\n\t\t\t}\n\t\t}\n\t} else { // Create a new RConfigNode\n\t\toi = UT64_MAX;\n\t\tif (!cfg->lock) {\n\t\t\tnode = r_config_node_new (name, value);\n\t\t\tif (node) {\n\t\t\t\tif (value && is_bool (value)) {\n\t\t\t\t\tnode->flags |= CN_BOOL;\n\t\t\t\t\tnode->i_value = is_true (value)? 1: 0;\n\t\t\t\t}\n\t\t\t\tif (cfg->ht) {\n\t\t\t\t\tht_insert (cfg->ht, node->name, node);\n\t\t\t\t\tr_list_append (cfg->nodes, node);\n\t\t\t\t\tcfg->n_nodes++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\teprintf (\"r_config_set: unable to create a new RConfigNode\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"r_config_set: variable '%s' not found\\n\", name);\n\t\t}\n\t}\n\n\tif (node && node->setter) {\n\t\tint ret = node->setter (cfg->user, node);\n\t\tif (ret == false) {\n\t\t\tif (oi != UT64_MAX) {\n\t\t\t\tnode->i_value = oi;\n\t\t\t}\n\t\t\tfree (node->value);\n\t\t\tnode->value = strdup (ov? ov: \"\");\n\t\t}\n\t}\nbeach:\n\tfree (ov);\n\treturn node;\n}\n", "target": 1, "idx": 181267}
{"func": " static struct page *alloc_huge_page(struct vm_area_struct *vma,\n \t\t\t\t    unsigned long addr, int avoid_reserve)\n {\n \tstruct hstate *h = hstate_vma(vma);\n \tstruct page *page;\n\tstruct address_space *mapping = vma->vm_file->f_mapping;\n\tstruct inode *inode = mapping->host;\n \tlong chg;\n \n \t/*\n\t * Processes that did not create the mapping will have no reserves and\n\t * will not have accounted against quota. Check that the quota can be\n\t * made before satisfying the allocation\n\t * MAP_NORESERVE mappings may also need pages and quota allocated\n\t * if no reserve mapping overlaps.\n \t */\n \tchg = vma_needs_reservation(h, vma, addr);\n \tif (chg < 0)\n \t\treturn ERR_PTR(-VM_FAULT_OOM);\n \tif (chg)\n\t\tif (hugetlb_get_quota(inode->i_mapping, chg))\n \t\t\treturn ERR_PTR(-VM_FAULT_SIGBUS);\n \n \tspin_lock(&hugetlb_lock);\n\tpage = dequeue_huge_page_vma(h, vma, addr, avoid_reserve);\n\tspin_unlock(&hugetlb_lock);\n\n \tif (!page) {\n \t\tpage = alloc_buddy_huge_page(h, NUMA_NO_NODE);\n \t\tif (!page) {\n\t\t\thugetlb_put_quota(inode->i_mapping, chg);\n \t\t\treturn ERR_PTR(-VM_FAULT_SIGBUS);\n \t\t}\n \t}\n \n\tset_page_private(page, (unsigned long) mapping);\n \n \tvma_commit_reservation(h, vma, addr);\n \n\treturn page;\n}\n", "target": 1, "idx": 178780}
{"func": " static inline void VectorClamp3(DDSVector3 *value)\n {\n  value->x = MinF(1.0f,MaxF(0.0f,value->x));\n  value->y = MinF(1.0f,MaxF(0.0f,value->y));\n  value->z = MinF(1.0f,MaxF(0.0f,value->z));\n }\n", "target": 1, "idx": 182079}
{"func": "static int __meminit __add_zone(struct zone *zone, unsigned long phys_start_pfn)\n{\n\tstruct pglist_data *pgdat = zone->zone_pgdat;\n\tint nr_pages = PAGES_PER_SECTION;\n\tint nid = pgdat->node_id;\n\tint zone_type;\n\tunsigned long flags;\n\n\tzone_type = zone - pgdat->node_zones;\n\tif (!zone->wait_table) {\n\t\tint ret;\n\n\t\tret = init_currently_empty_zone(zone, phys_start_pfn,\n\t\t\t\t\t\tnr_pages, MEMMAP_HOTPLUG);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tpgdat_resize_lock(zone->zone_pgdat, &flags);\n\tgrow_zone_span(zone, phys_start_pfn, phys_start_pfn + nr_pages);\n\tgrow_pgdat_span(zone->zone_pgdat, phys_start_pfn,\n\t\t\tphys_start_pfn + nr_pages);\n\tpgdat_resize_unlock(zone->zone_pgdat, &flags);\n\tmemmap_init_zone(nr_pages, nid, zone_type,\n\t\t\t phys_start_pfn, MEMMAP_HOTPLUG);\n\treturn 0;\n}\n", "target": 0, "idx": 18486}
{"func": "SPL_METHOD(RecursiveDirectoryIterator, getChildren)\n{\n\tzval *zpath, *zflags;\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n \tspl_filesystem_object *subdir;\n \tchar slash = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_UNIXPATHS) ? '/' : DEFAULT_SLASH;\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n \tspl_filesystem_object_get_file_name(intern TSRMLS_CC);\n \n \tMAKE_STD_ZVAL(zflags);\n\tMAKE_STD_ZVAL(zpath);\n\tZVAL_LONG(zflags, intern->flags);\n\tZVAL_STRINGL(zpath, intern->file_name, intern->file_name_len, 1);\n\tspl_instantiate_arg_ex2(Z_OBJCE_P(getThis()), &return_value, 0, zpath, zflags TSRMLS_CC);\n\tzval_ptr_dtor(&zpath);\n\tzval_ptr_dtor(&zflags);\n\n\tsubdir = (spl_filesystem_object*)zend_object_store_get_object(return_value TSRMLS_CC);\n\tif (subdir) {\n\t\tif (intern->u.dir.sub_path && intern->u.dir.sub_path[0]) {\n\t\t\tsubdir->u.dir.sub_path_len = spprintf(&subdir->u.dir.sub_path, 0, \"%s%c%s\", intern->u.dir.sub_path, slash, intern->u.dir.entry.d_name);\n\t\t} else {\n\t\t\tsubdir->u.dir.sub_path_len = strlen(intern->u.dir.entry.d_name);\n\t\t\tsubdir->u.dir.sub_path = estrndup(intern->u.dir.entry.d_name, subdir->u.dir.sub_path_len);\n\t\t}\n\t\tsubdir->info_class = intern->info_class;\n\t\tsubdir->file_class = intern->file_class;\n\t\tsubdir->oth = intern->oth;\n\t}\n}\n", "target": 1, "idx": 180217}
{"func": "QQuickWebViewPrivate::~QQuickWebViewPrivate()\n{\n    webPageProxy->close();\n}\n", "target": 0, "idx": 107093}
{"func": "const PPB_NaCl_Private* GetNaclInterface() {\n  pp::Module *module = pp::Module::Get();\n  CHECK(module);\n  return static_cast<const PPB_NaCl_Private*>(\n      module->GetBrowserInterface(PPB_NACL_PRIVATE_INTERFACE));\n}\n", "target": 1, "idx": 184315}
{"func": "void xmlrpc_char_encode(char *outbuffer, const char *s1)\n{\n\tlong unsigned int i;\n\tunsigned char c;\n\tchar buf2[15];\n\tmowgli_string_t *s = mowgli_string_create();\n\t*buf2 = '\\0';\n\t*outbuffer = '\\0';\n\n\tif ((!(s1) || (*(s1) == '\\0')))\n\t{\n\t\treturn;\n\t}\n\n\tfor (i = 0; s1[i] != '\\0'; i++)\n\t{\n\t\tc = s1[i];\n\t\tif (c > 127)\n\t\t{\n\t\t\tsnprintf(buf2, sizeof buf2, \"&#%d;\", c);\n\t\t\ts->append(s, buf2, strlen(buf2));\n\t\t}\n\t\telse if (c == '&')\n\t\t{\n\t\t\ts->append(s, \"&amp;\", 5);\n\t\t}\n\t\telse if (c == '<')\n\t\t{\n\t\t\ts->append(s, \"&lt;\", 4);\n\t\t}\n\t\telse if (c == '>')\n\t\t{\n\t\t\ts->append(s, \"&gt;\", 4);\n\t\t}\n\t\telse if (c == '\"')\n\t\t{\n\t\t\ts->append(s, \"&quot;\", 6);\n\t\t}\n\t\telse\n\t\t{\n \t\t\ts->append_char(s, c);\n \t\t}\n \t}\n \n\tmemcpy(outbuffer, s->str, XMLRPC_BUFSIZE);\n }\n", "target": 1, "idx": 180432}
{"func": "xfs_attr3_leaf_compact(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_attr3_icleaf_hdr *ichdr_dst,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_attr_leafblock *leaf_src;\n\tstruct xfs_attr_leafblock *leaf_dst;\n\tstruct xfs_attr3_icleaf_hdr ichdr_src;\n\tstruct xfs_trans\t*trans = args->trans;\n\tchar\t\t\t*tmpbuffer;\n\n\ttrace_xfs_attr_leaf_compact(args);\n\n\ttmpbuffer = kmem_alloc(args->geo->blksize, KM_SLEEP);\n\tmemcpy(tmpbuffer, bp->b_addr, args->geo->blksize);\n\tmemset(bp->b_addr, 0, args->geo->blksize);\n\tleaf_src = (xfs_attr_leafblock_t *)tmpbuffer;\n\tleaf_dst = bp->b_addr;\n\n\t/*\n\t * Copy the on-disk header back into the destination buffer to ensure\n\t * all the information in the header that is not part of the incore\n\t * header structure is preserved.\n\t */\n\tmemcpy(bp->b_addr, tmpbuffer, xfs_attr3_leaf_hdr_size(leaf_src));\n\n\t/* Initialise the incore headers */\n\tichdr_src = *ichdr_dst;\t/* struct copy */\n\tichdr_dst->firstused = args->geo->blksize;\n\tichdr_dst->usedbytes = 0;\n\tichdr_dst->count = 0;\n\tichdr_dst->holes = 0;\n\tichdr_dst->freemap[0].base = xfs_attr3_leaf_hdr_size(leaf_src);\n\tichdr_dst->freemap[0].size = ichdr_dst->firstused -\n\t\t\t\t\t\tichdr_dst->freemap[0].base;\n\n\t/* write the header back to initialise the underlying buffer */\n\txfs_attr3_leaf_hdr_to_disk(args->geo, leaf_dst, ichdr_dst);\n\n\t/*\n\t * Copy all entry's in the same (sorted) order,\n\t * but allocate name/value pairs packed and in sequence.\n\t */\n\txfs_attr3_leaf_moveents(args, leaf_src, &ichdr_src, 0,\n\t\t\t\tleaf_dst, ichdr_dst, 0, ichdr_src.count);\n\t/*\n\t * this logs the entire buffer, but the caller must write the header\n\t * back to the buffer when it is finished modifying it.\n\t */\n\txfs_trans_log_buf(trans, bp, 0, args->geo->blksize - 1);\n\n\tkmem_free(tmpbuffer);\n}\n", "target": 0, "idx": 79910}
{"func": "lldp_private_8021_print(netdissect_options *ndo,\n                        const u_char *tptr, u_int tlv_len)\n{\n     int subtype, hexdump = FALSE;\n     u_int sublen;\n     u_int tval;\n    uint8_t i;\n \n     if (tlv_len < 4) {\n         return hexdump;\n    }\n    subtype = *(tptr+3);\n\n    ND_PRINT((ndo, \"\\n\\t  %s Subtype (%u)\",\n           tok2str(lldp_8021_subtype_values, \"unknown\", subtype),\n           subtype));\n\n    switch (subtype) {\n    case LLDP_PRIVATE_8021_SUBTYPE_PORT_VLAN_ID:\n        if (tlv_len < 6) {\n            return hexdump;\n        }\n        ND_PRINT((ndo, \"\\n\\t    port vlan id (PVID): %u\",\n               EXTRACT_16BITS(tptr + 4)));\n        break;\n    case LLDP_PRIVATE_8021_SUBTYPE_PROTOCOL_VLAN_ID:\n        if (tlv_len < 7) {\n            return hexdump;\n        }\n        ND_PRINT((ndo, \"\\n\\t    port and protocol vlan id (PPVID): %u, flags [%s] (0x%02x)\",\n               EXTRACT_16BITS(tptr+5),\n\t       bittok2str(lldp_8021_port_protocol_id_values, \"none\", *(tptr+4)),\n\t       *(tptr + 4)));\n        break;\n    case LLDP_PRIVATE_8021_SUBTYPE_VLAN_NAME:\n        if (tlv_len < 6) {\n            return hexdump;\n        }\n        ND_PRINT((ndo, \"\\n\\t    vlan id (VID): %u\", EXTRACT_16BITS(tptr + 4)));\n        if (tlv_len < 7) {\n            return hexdump;\n        }\n        sublen = *(tptr+6);\n        if (tlv_len < 7+sublen) {\n            return hexdump;\n        }\n        ND_PRINT((ndo, \"\\n\\t    vlan name: \"));\n        safeputs(ndo, tptr + 7, sublen);\n        break;\n    case LLDP_PRIVATE_8021_SUBTYPE_PROTOCOL_IDENTITY:\n        if (tlv_len < 5) {\n            return hexdump;\n        }\n        sublen = *(tptr+4);\n        if (tlv_len < 5+sublen) {\n            return hexdump;\n        }\n        ND_PRINT((ndo, \"\\n\\t    protocol identity: \"));\n        safeputs(ndo, tptr + 5, sublen);\n        break;\n    case LLDP_PRIVATE_8021_SUBTYPE_CONGESTION_NOTIFICATION:\n        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_CONGESTION_NOTIFICATION_LENGTH){\n        \treturn hexdump;\n        }\n        tval=*(tptr+4);\n        ND_PRINT((ndo, \"\\n\\t    Pre-Priority CNPV Indicator\"));\n        ND_PRINT((ndo, \"\\n\\t     Priority : 0  1  2  3  4  5  6  7\"));\n        ND_PRINT((ndo, \"\\n\\t     Value    : \"));\n        for(i=0;i<NO_OF_BITS;i++)\n            ND_PRINT((ndo, \"%-2d \", (tval >> i) & 0x01));\n        tval=*(tptr+5);\n        ND_PRINT((ndo, \"\\n\\t    Pre-Priority Ready Indicator\"));\n        ND_PRINT((ndo, \"\\n\\t     Priority : 0  1  2  3  4  5  6  7\"));\n        ND_PRINT((ndo, \"\\n\\t     Value    : \"));\n        for(i=0;i<NO_OF_BITS;i++)\n            ND_PRINT((ndo, \"%-2d \", (tval >> i) & 0x01));\n        break;\n\n    case LLDP_PRIVATE_8021_SUBTYPE_ETS_CONFIGURATION:\n        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_ETS_CONFIGURATION_LENGTH) {\n            return hexdump;\n        }\n        tval=*(tptr+4);\n        ND_PRINT((ndo, \"\\n\\t    Willing:%d, CBS:%d, RES:%d, Max TCs:%d\",\n        \ttval >> 7, (tval >> 6) & 0x02, (tval >> 3) & 0x07, tval & 0x07));\n\n        /*Print Priority Assignment Table*/\n        print_ets_priority_assignment_table(ndo, tptr + 5);\n\n        /*Print TC Bandwidth Table*/\n        print_tc_bandwidth_table(ndo, tptr + 9);\n\n        /* Print TSA Assignment Table */\n        print_tsa_assignment_table(ndo, tptr + 17);\n\n        break;\n\n    case LLDP_PRIVATE_8021_SUBTYPE_ETS_RECOMMENDATION:\n        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_ETS_RECOMMENDATION_LENGTH) {\n        \treturn hexdump;\n        }\n        ND_PRINT((ndo, \"\\n\\t    RES: %d\", *(tptr + 4)));\n        /*Print Priority Assignment Table */\n        print_ets_priority_assignment_table(ndo, tptr + 5);\n        /*Print TC Bandwidth Table */\n        print_tc_bandwidth_table(ndo, tptr + 9);\n        /* Print TSA Assignment Table */\n        print_tsa_assignment_table(ndo, tptr + 17);\n        break;\n\n    case LLDP_PRIVATE_8021_SUBTYPE_PFC_CONFIGURATION:\n        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_PFC_CONFIGURATION_LENGTH) {\n            return hexdump;\n        }\n        tval=*(tptr+4);\n        ND_PRINT((ndo, \"\\n\\t    Willing: %d, MBC: %d, RES: %d, PFC cap:%d \",\n        \ttval >> 7, (tval >> 6) & 0x01, (tval >> 4) & 0x03, (tval & 0x0f)));\n        ND_PRINT((ndo, \"\\n\\t    PFC Enable\"));\n        tval=*(tptr+5);\n        ND_PRINT((ndo, \"\\n\\t     Priority : 0  1  2  3  4  5  6  7\"));\n        ND_PRINT((ndo, \"\\n\\t     Value    : \"));\n        for(i=0;i<NO_OF_BITS;i++)\n            ND_PRINT((ndo, \"%-2d \", (tval >> i) & 0x01));\n        break;\n\n    case LLDP_PRIVATE_8021_SUBTYPE_APPLICATION_PRIORITY:\n        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_APPLICATION_PRIORITY_MIN_LENGTH) {\n            return hexdump;\n        }\n        ND_PRINT((ndo, \"\\n\\t    RES: %d\", *(tptr + 4)));\n        if(tlv_len<=LLDP_PRIVATE_8021_SUBTYPE_APPLICATION_PRIORITY_MIN_LENGTH){\n        \treturn hexdump;\n        }\n        /*  Length of Application Priority Table */\n        sublen=tlv_len-5;\n        if(sublen%3!=0){\n        \treturn hexdump;\n        }\n        i=0;\n         ND_PRINT((ndo, \"\\n\\t    Application Priority Table\"));\n         while(i<sublen) {\n         \ttval=*(tptr+i+5);\n        \tND_PRINT((ndo, \"\\n\\t      Priority: %d, RES: %d, Sel: %d\",\n        \t\t tval >> 5, (tval >> 3) & 0x03, (tval & 0x07)));\n        \tND_PRINT((ndo, \"Protocol ID: %d\", EXTRACT_16BITS(tptr + i + 5)));\n         \ti=i+3;\n         }\n         break;\n    case LLDP_PRIVATE_8021_SUBTYPE_EVB:\n        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_EVB_LENGTH){\n        \treturn hexdump;\n        }\n        ND_PRINT((ndo, \"\\n\\t    EVB Bridge Status\"));\n        tval=*(tptr+4);\n        ND_PRINT((ndo, \"\\n\\t      RES: %d, BGID: %d, RRCAP: %d, RRCTR: %d\",\n        \ttval >> 3, (tval >> 2) & 0x01, (tval >> 1) & 0x01, tval & 0x01));\n        ND_PRINT((ndo, \"\\n\\t    EVB Station Status\"));\n        tval=*(tptr+5);\n        ND_PRINT((ndo, \"\\n\\t      RES: %d, SGID: %d, RRREQ: %d,RRSTAT: %d\",\n        \ttval >> 4, (tval >> 3) & 0x01, (tval >> 2) & 0x01, tval & 0x03));\n        tval=*(tptr+6);\n        ND_PRINT((ndo, \"\\n\\t    R: %d, RTE: %d, \",tval >> 5, tval & 0x1f));\n        tval=*(tptr+7);\n        ND_PRINT((ndo, \"EVB Mode: %s [%d]\",\n        \ttok2str(lldp_evb_mode_values, \"unknown\", tval >> 6), tval >> 6));\n        ND_PRINT((ndo, \"\\n\\t    ROL: %d, RWD: %d, \", (tval >> 5) & 0x01, tval & 0x1f));\n        tval=*(tptr+8);\n        ND_PRINT((ndo, \"RES: %d, ROL: %d, RKA: %d\", tval >> 6, (tval >> 5) & 0x01, tval & 0x1f));\n        break;\n\n    case LLDP_PRIVATE_8021_SUBTYPE_CDCP:\n        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_CDCP_MIN_LENGTH){\n        \treturn hexdump;\n        }\n        tval=*(tptr+4);\n        ND_PRINT((ndo, \"\\n\\t    Role: %d, RES: %d, Scomp: %d \",\n        \ttval >> 7, (tval >> 4) & 0x07, (tval >> 3) & 0x01));\n        ND_PRINT((ndo, \"ChnCap: %d\", EXTRACT_16BITS(tptr + 6) & 0x0fff));\n        sublen=tlv_len-8;\n        if(sublen%3!=0) {\n        \treturn hexdump;\n        }\n        i=0;\n        while(i<sublen) {\n        \ttval=EXTRACT_24BITS(tptr+i+8);\n        \tND_PRINT((ndo, \"\\n\\t    SCID: %d, SVID: %d\",\n        \t\ttval >> 12, tval & 0x000fff));\n        \ti=i+3;\n        }\n        break;\n\n    default:\n        hexdump = TRUE;\n        break;\n    }\n\n    return hexdump;\n}\n", "target": 1, "idx": 181082}
{"func": "IPC::PlatformFileForTransit ProxyChannelDelegate::ShareHandleWithRemote(\n    base::PlatformFile handle,\n    const IPC::SyncChannel& channel,\n    bool should_close_source) {\n  return content::BrokerGetFileHandleForProcess(handle, channel.peer_pid(),\n                                                should_close_source);\n}\n", "target": 1, "idx": 184312}
{"func": " image_transform_png_set_expand_16_add(image_transform *this,\n    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)\n {\n    UNUSED(colour_type)\n \n this->next = *that;\n *that = this;\n\n /* expand_16 does something unless the bit depth is already 16. */\n return bit_depth < 16;\n}\n", "target": 1, "idx": 187648}
{"func": "void WebGL2RenderingContextBase::texImage3D(\n    GLenum target,\n    GLint level,\n    GLint internalformat,\n    GLsizei width,\n    GLsizei height,\n    GLsizei depth,\n    GLint border,\n    GLenum format,\n    GLenum type,\n    MaybeShared<DOMArrayBufferView> pixels,\n    GLuint src_offset) {\n  if (isContextLost())\n    return;\n  if (bound_pixel_unpack_buffer_) {\n    SynthesizeGLError(GL_INVALID_OPERATION, \"texImage3D\",\n                       \"a buffer is bound to PIXEL_UNPACK_BUFFER\");\n     return;\n   }\n   TexImageHelperDOMArrayBufferView(\n       kTexImage3D, target, level, internalformat, width, height, depth, border,\n       format, type, 0, 0, 0, pixels.View(), kNullNotReachable, src_offset);\n}\n", "target": 1, "idx": 186653}
{"func": "static void ipgre_tap_setup(struct net_device *dev)\n{\n\n\tether_setup(dev);\n\n\tdev->netdev_ops\t\t= &ipgre_tap_netdev_ops;\n\tdev->destructor \t= ipgre_dev_free;\n\n\tdev->iflink\t\t= 0;\n\tdev->features\t\t|= NETIF_F_NETNS_LOCAL;\n}\n", "target": 0, "idx": 35326}
{"func": "_ksba_name_new_from_der (ksba_name_t *r_name,\n                         const unsigned char *image, size_t imagelen)\n{\n  gpg_error_t err;\n  ksba_name_t name;\n  struct tag_info ti;\n  const unsigned char *der;\n  size_t derlen;\n  int n;\n  char *p;\n\n  if (!r_name || !image)\n    return gpg_error (GPG_ERR_INV_VALUE);\n \n   *r_name = NULL;\n \n  /* count and check for encoding errors - we won;t do this again\n      during the second pass */\n   der = image;\n   derlen = imagelen;\n  n = 0;\n  while (derlen)\n    {\n      err = _ksba_ber_parse_tl (&der, &derlen, &ti);\n      if (err)\n        return err;\n      if (ti.class != CLASS_CONTEXT)\n        return gpg_error (GPG_ERR_INV_CERT_OBJ); /* we expected a tag */\n      if (ti.ndef)\n        return gpg_error (GPG_ERR_NOT_DER_ENCODED);\n      if (derlen < ti.length)\n        return gpg_error (GPG_ERR_BAD_BER);\n      switch (ti.tag)\n        {\n        case 1: /* rfc822Name - this is an imlicit IA5_STRING */\n        case 4: /* Name */\n        case 6: /* URI */\n          n++;\n          break;\n        default:\n          break;\n        }\n\n      /* advance pointer */\n      der += ti.length;\n      derlen -= ti.length;\n    }\n\n  /* allocate array and set all slots to NULL for easier error recovery */\n  err = ksba_name_new (&name);\n  if (err)\n    return err;\n  if (!n)\n    return 0; /* empty GeneralNames */\n  name->names = xtrycalloc (n, sizeof *name->names);\n  if (!name->names)\n    {\n      ksba_name_release (name);\n      return gpg_error (GPG_ERR_ENOMEM);\n    }\n  name->n_names = n;\n\n  /* start the second pass */\n  der = image;\n  derlen = imagelen;\n  n = 0;\n  while (derlen)\n    {\n      char numbuf[21];\n\n      err = _ksba_ber_parse_tl (&der, &derlen, &ti);\n      assert (!err);\n      switch (ti.tag)\n        {\n        case 1: /* rfc822Name - this is an imlicit IA5_STRING */\n          p = name->names[n] = xtrymalloc (ti.length+3);\n          if (!p)\n            {\n              ksba_name_release (name);\n              return gpg_error (GPG_ERR_ENOMEM);\n            }\n          *p++ = '<';\n          memcpy (p, der, ti.length);\n          p += ti.length;\n          *p++ = '>';\n          *p = 0;\n          n++;\n          break;\n        case 4: /* Name */\n          err = _ksba_derdn_to_str (der, ti.length, &p);\n          if (err)\n            return err; /* FIXME: we need to release some of the memory */\n          name->names[n++] = p;\n          break;\n        case 6: /* URI */\n          sprintf (numbuf, \"%u:\", (unsigned int)ti.length);\n          p = name->names[n] = xtrymalloc (1+5+strlen (numbuf)\n                                           + ti.length +1+1);\n          if (!p)\n            {\n              ksba_name_release (name);\n              return gpg_error (GPG_ERR_ENOMEM);\n            }\n          p = stpcpy (p, \"(3:uri\");\n          p = stpcpy (p, numbuf);\n          memcpy (p, der, ti.length);\n          p += ti.length;\n          *p++ = ')';\n          *p = 0; /* extra safeguard null */\n          n++;\n          break;\n        default:\n          break;\n        }\n\n      /* advance pointer */\n      der += ti.length;\n      derlen -= ti.length;\n    }\n  *r_name = name;\n  return 0;\n}\n", "target": 1, "idx": 178201}
{"func": "struct in6_addr *ndp_msg_opt_route_prefix(struct ndp_msg *msg, int offset)\n{\n\tstatic struct in6_addr prefix;\n\tstruct __nd_opt_route_info *ri =\n\t\t\tndp_msg_payload_opts_offset(msg, offset);\n\n\tmemset(&prefix, 0, sizeof(prefix));\n\tmemcpy(&prefix, &ri->nd_opt_ri_prefix, (ri->nd_opt_ri_len - 1) << 3);\n\treturn &prefix;\n}\n", "target": 0, "idx": 53937}
{"func": "vmnc_handle_wmvi_rectangle (GstVMncDec * dec, struct RfbRectangle *rect,\n    const guint8 * data, int len, gboolean decode)\n{\n  GstVideoFormat format;\n  gint bpp, tc;\n  guint32 redmask, greenmask, bluemask;\n  guint32 endianness, dataendianness;\n  GstVideoCodecState *state;\n\n  /* A WMVi rectangle has a 16byte payload */\n  if (len < 16) {\n    GST_DEBUG_OBJECT (dec, \"Bad WMVi rect: too short\");\n    return ERROR_INSUFFICIENT_DATA;\n  }\n\n  /* We only compare 13 bytes; ignoring the 3 padding bytes at the end */\n  if (dec->have_format && memcmp (data, dec->format.descriptor, 13) == 0) {\n    /* Nothing changed, so just exit */\n    return 16;\n  }\n\n  /* Store the whole block for simple comparison later */\n  memcpy (dec->format.descriptor, data, 16);\n\n  if (rect->x != 0 || rect->y != 0) {\n    GST_WARNING_OBJECT (dec, \"Bad WMVi rect: wrong coordinates\");\n    return ERROR_INVALID;\n  }\n\n  bpp = data[0];\n  dec->format.depth = data[1];\n  dec->format.big_endian = data[2];\n  dataendianness = data[2] ? G_BIG_ENDIAN : G_LITTLE_ENDIAN;\n  tc = data[3];\n\n  if (bpp != 8 && bpp != 16 && bpp != 32) {\n    GST_WARNING_OBJECT (dec, \"Bad bpp value: %d\", bpp);\n    return ERROR_INVALID;\n  }\n\n  if (!tc) {\n    GST_WARNING_OBJECT (dec, \"Paletted video not supported\");\n    return ERROR_INVALID;\n  }\n\n  dec->format.bytes_per_pixel = bpp / 8;\n  dec->format.width = rect->width;\n  dec->format.height = rect->height;\n\n  redmask = (guint32) (RFB_GET_UINT16 (data + 4)) << data[10];\n  greenmask = (guint32) (RFB_GET_UINT16 (data + 6)) << data[11];\n  bluemask = (guint32) (RFB_GET_UINT16 (data + 8)) << data[12];\n\n  GST_DEBUG_OBJECT (dec, \"Red: mask %d, shift %d\",\n      RFB_GET_UINT16 (data + 4), data[10]);\n  GST_DEBUG_OBJECT (dec, \"Green: mask %d, shift %d\",\n      RFB_GET_UINT16 (data + 6), data[11]);\n  GST_DEBUG_OBJECT (dec, \"Blue: mask %d, shift %d\",\n      RFB_GET_UINT16 (data + 8), data[12]);\n  GST_DEBUG_OBJECT (dec, \"BPP: %d. endianness: %s\", bpp,\n      data[2] ? \"big\" : \"little\");\n\n  /* GStreamer's RGB caps are a bit weird. */\n  if (bpp == 8) {\n    endianness = G_BYTE_ORDER;  /* Doesn't matter */\n  } else if (bpp == 16) {\n    /* We require host-endian. */\n    endianness = G_BYTE_ORDER;\n  } else {                      /* bpp == 32 */\n    /* We require big endian */\n    endianness = G_BIG_ENDIAN;\n    if (endianness != dataendianness) {\n      redmask = GUINT32_SWAP_LE_BE (redmask);\n      greenmask = GUINT32_SWAP_LE_BE (greenmask);\n      bluemask = GUINT32_SWAP_LE_BE (bluemask);\n    }\n  }\n\n  format = gst_video_format_from_masks (dec->format.depth, bpp, endianness,\n      redmask, greenmask, bluemask, 0);\n\n  GST_DEBUG_OBJECT (dec, \"From depth: %d bpp: %u endianess: %s redmask: %X \"\n      \"greenmask: %X bluemask: %X got format %s\",\n      dec->format.depth, bpp, endianness == G_BIG_ENDIAN ? \"BE\" : \"LE\",\n      GUINT32_FROM_BE (redmask), GUINT32_FROM_BE (greenmask),\n      GUINT32_FROM_BE (bluemask),\n      format == GST_VIDEO_FORMAT_UNKNOWN ? \"UNKOWN\" :\n      gst_video_format_to_string (format));\n\n  if (format == GST_VIDEO_FORMAT_UNKNOWN) {\n    GST_WARNING_OBJECT (dec, \"Video format unknown to GStreamer\");\n    return ERROR_INVALID;\n  }\n\n  dec->have_format = TRUE;\n  if (!decode) {\n    GST_LOG_OBJECT (dec, \"Parsing, not setting caps\");\n    return 16;\n  }\n\n\n  state = gst_video_decoder_set_output_state (GST_VIDEO_DECODER (dec), format,\n      rect->width, rect->height, dec->input_state);\n   gst_video_codec_state_unref (state);\n \n   g_free (dec->imagedata);\n  dec->imagedata = g_malloc (dec->format.width * dec->format.height *\n       dec->format.bytes_per_pixel);\n   GST_DEBUG_OBJECT (dec, \"Allocated image data at %p\", dec->imagedata);\n \n  dec->format.stride = dec->format.width * dec->format.bytes_per_pixel;\n\n  return 16;\n}\n", "target": 1, "idx": 178424}
{"func": "static int complete_emulated_mmio(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *run = vcpu->run;\n\tstruct kvm_mmio_fragment *frag;\n\tunsigned len;\n\n\tBUG_ON(!vcpu->mmio_needed);\n\n\t/* Complete previous fragment */\n\tfrag = &vcpu->mmio_fragments[vcpu->mmio_cur_fragment];\n\tlen = min(8u, frag->len);\n\tif (!vcpu->mmio_is_write)\n\t\tmemcpy(frag->data, run->mmio.data, len);\n\n\tif (frag->len <= 8) {\n\t\t/* Switch to the next fragment. */\n\t\tfrag++;\n\t\tvcpu->mmio_cur_fragment++;\n\t} else {\n\t\t/* Go forward to the next mmio piece. */\n\t\tfrag->data += len;\n\t\tfrag->gpa += len;\n \t\tfrag->len -= len;\n \t}\n \n\tif (vcpu->mmio_cur_fragment == vcpu->mmio_nr_fragments) {\n \t\tvcpu->mmio_needed = 0;\n \n \t\t/* FIXME: return into emulator if single-stepping.  */\n\t\tif (vcpu->mmio_is_write)\n\t\t\treturn 1;\n\t\tvcpu->mmio_read_completed = 1;\n\t\treturn complete_emulated_io(vcpu);\n\t}\n\n\trun->exit_reason = KVM_EXIT_MMIO;\n\trun->mmio.phys_addr = frag->gpa;\n\tif (vcpu->mmio_is_write)\n\t\tmemcpy(run->mmio.data, frag->data, min(8u, frag->len));\n\trun->mmio.len = min(8u, frag->len);\n\trun->mmio.is_write = vcpu->mmio_is_write;\n\tvcpu->arch.complete_userspace_io = complete_emulated_mmio;\n\treturn 0;\n}\n", "target": 1, "idx": 179638}
{"func": "static int crypto_report_cipher(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_cipher rcipher;\n \n\tsnprintf(rcipher.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"cipher\");\n \n \trcipher.blocksize = alg->cra_blocksize;\n \trcipher.min_keysize = alg->cra_cipher.cia_min_keysize;\n\trcipher.max_keysize = alg->cra_cipher.cia_max_keysize;\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_CIPHER,\n\t\t    sizeof(struct crypto_report_cipher), &rcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n", "target": 1, "idx": 179239}
{"func": "void TypingCommand::forwardDeleteKeyPressed(TextGranularity granularity,\n                                            bool killRing,\n                                            EditingState* editingState) {\n  LocalFrame* frame = document().frame();\n  if (!frame)\n    return;\n\n  frame->spellChecker().updateMarkersForWordsAffectedByEditing(false);\n\n  VisibleSelection selectionToDelete;\n  VisibleSelection selectionAfterUndo;\n\n  switch (endingSelection().getSelectionType()) {\n    case RangeSelection:\n      selectionToDelete = endingSelection();\n      selectionAfterUndo = selectionToDelete;\n      break;\n    case CaretSelection: {\n      m_smartDelete = false;\n      document().updateStyleAndLayoutIgnorePendingStylesheets();\n\n      SelectionModifier selectionModifier(*frame, endingSelection());\n      selectionModifier.modify(FrameSelection::AlterationExtend,\n                               DirectionForward, granularity);\n      if (killRing && selectionModifier.selection().isCaret() &&\n          granularity != CharacterGranularity)\n        selectionModifier.modify(FrameSelection::AlterationExtend,\n                                 DirectionForward, CharacterGranularity);\n\n      Position downstreamEnd =\n          mostForwardCaretPosition(endingSelection().end());\n      VisiblePosition visibleEnd = endingSelection().visibleEnd();\n      Node* enclosingTableCell =\n          enclosingNodeOfType(visibleEnd.deepEquivalent(), &isTableCell);\n      if (enclosingTableCell &&\n          visibleEnd.deepEquivalent() ==\n              VisiblePosition::lastPositionInNode(enclosingTableCell)\n                  .deepEquivalent())\n        return;\n      if (visibleEnd.deepEquivalent() ==\n          endOfParagraph(visibleEnd).deepEquivalent())\n        downstreamEnd = mostForwardCaretPosition(\n            nextPositionOf(visibleEnd, CannotCrossEditingBoundary)\n                .deepEquivalent());\n      if (isDisplayInsideTable(downstreamEnd.computeContainerNode()) &&\n          downstreamEnd.computeOffsetInContainerNode() <=\n              caretMinOffset(downstreamEnd.computeContainerNode())) {\n        setEndingSelection(\n            SelectionInDOMTree::Builder()\n                .setBaseAndExtentDeprecated(\n                    endingSelection().end(),\n                    Position::afterNode(downstreamEnd.computeContainerNode()))\n                .setIsDirectional(endingSelection().isDirectional())\n                .build());\n        typingAddedToOpenCommand(ForwardDeleteKey);\n        return;\n      }\n\n      if (granularity == ParagraphBoundary &&\n          selectionModifier.selection().isCaret() &&\n          isEndOfParagraph(selectionModifier.selection().visibleEnd()))\n        selectionModifier.modify(FrameSelection::AlterationExtend,\n                                 DirectionForward, CharacterGranularity);\n\n      selectionToDelete = selectionModifier.selection();\n      if (!startingSelection().isRange() ||\n          selectionToDelete.base() != startingSelection().start()) {\n        selectionAfterUndo = selectionToDelete;\n      } else {\n        Position extent = startingSelection().end();\n        if (extent.computeContainerNode() !=\n            selectionToDelete.end().computeContainerNode()) {\n          extent = selectionToDelete.extent();\n        } else {\n          int extraCharacters;\n          if (selectionToDelete.start().computeContainerNode() ==\n              selectionToDelete.end().computeContainerNode())\n            extraCharacters =\n                selectionToDelete.end().computeOffsetInContainerNode() -\n                selectionToDelete.start().computeOffsetInContainerNode();\n          else\n            extraCharacters =\n                selectionToDelete.end().computeOffsetInContainerNode();\n          extent =\n              Position(extent.computeContainerNode(),\n                       extent.computeOffsetInContainerNode() + extraCharacters);\n        }\n        selectionAfterUndo.setWithoutValidation(startingSelection().start(),\n                                                extent);\n      }\n      break;\n    }\n    case NoSelection:\n      NOTREACHED();\n      break;\n  }\n\n  DCHECK(!selectionToDelete.isNone());\n  if (selectionToDelete.isNone())\n    return;\n\n  if (selectionToDelete.isCaret())\n    return;\n\n  if (killRing)\n    frame->editor().addToKillRing(\n        selectionToDelete.toNormalizedEphemeralRange());\n  if (frame->editor().behavior().shouldUndoOfDeleteSelectText())\n    setStartingSelection(selectionAfterUndo);\n  deleteSelectionIfRange(selectionToDelete, editingState, m_smartDelete);\n  if (editingState->isAborted())\n    return;\n  setSmartDelete(false);\n  typingAddedToOpenCommand(ForwardDeleteKey);\n}\n", "target": 0, "idx": 140396}
{"func": "static void calcstepsizes(uint_fast16_t refstepsize, int numrlvls,\n  uint_fast16_t *stepsizes)\n{\n\tint bandno;\n\tint numbands;\n\tuint_fast16_t expn;\n\tuint_fast16_t mant;\n\texpn = JPC_QCX_GETEXPN(refstepsize);\n \tmant = JPC_QCX_GETMANT(refstepsize);\n \tnumbands = 3 * numrlvls - 2;\n \tfor (bandno = 0; bandno < numbands; ++bandno) {\n////jas_eprintf(\"DEBUG %d %d %d %d %d\\n\", bandno, expn, numrlvls, bandno, ((numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0)))));\n \t\tstepsizes[bandno] = JPC_QCX_MANT(mant) | JPC_QCX_EXPN(expn +\n \t\t  (numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0))));\n \t}\n}\n", "target": 1, "idx": 181907}
{"func": "void WebGraphicsContext3DCommandBufferImpl::OnMemoryAllocationChanged(\n    const GpuMemoryAllocation& allocation) {\n  if (memory_allocation_changed_callback_)\n    memory_allocation_changed_callback_->onMemoryAllocationChanged(\n        allocation.gpu_resource_size_in_bytes);\n}\n", "target": 0, "idx": 117440}
{"func": "int ff_mms_asf_header_parser(MMSContext *mms)\n{\n    uint8_t *p = mms->asf_header;\n    uint8_t *end;\n    int flags, stream_id;\n    mms->stream_num = 0;\n\n    if (mms->asf_header_size < sizeof(ff_asf_guid) * 2 + 22 ||\n        memcmp(p, ff_asf_header, sizeof(ff_asf_guid))) {\n        av_log(NULL, AV_LOG_ERROR,\n               \"Corrupt stream (invalid ASF header, size=%d)\\n\",\n               mms->asf_header_size);\n        return AVERROR_INVALIDDATA;\n    }\n\n    end = mms->asf_header + mms->asf_header_size;\n\n    p += sizeof(ff_asf_guid) + 14;\n    while(end - p >= sizeof(ff_asf_guid) + 8) {\n        uint64_t chunksize;\n        if (!memcmp(p, ff_asf_data_header, sizeof(ff_asf_guid))) {\n            chunksize = 50; // see Reference [2] section 5.1\n        } else {\n            chunksize = AV_RL64(p + sizeof(ff_asf_guid));\n        }\n        if (!chunksize || chunksize > end - p) {\n            av_log(NULL, AV_LOG_ERROR,\n                   \"Corrupt stream (header chunksize %\"PRId64\" is invalid)\\n\",\n                   chunksize);\n            return AVERROR_INVALIDDATA;\n        }\n        if (!memcmp(p, ff_asf_file_header, sizeof(ff_asf_guid))) {\n            /* read packet size */\n            if (end - p > sizeof(ff_asf_guid) * 2 + 68) {\n                mms->asf_packet_len = AV_RL32(p + sizeof(ff_asf_guid) * 2 + 64);\n                if (mms->asf_packet_len <= 0 || mms->asf_packet_len > sizeof(mms->in_buffer)) {\n                    av_log(NULL, AV_LOG_ERROR,\n                           \"Corrupt stream (too large pkt_len %d)\\n\",\n                           mms->asf_packet_len);\n                    return AVERROR_INVALIDDATA;\n                 }\n             }\n         } else if (!memcmp(p, ff_asf_stream_header, sizeof(ff_asf_guid))) {\n            flags     = AV_RL16(p + sizeof(ff_asf_guid)*3 + 24);\n            stream_id = flags & 0x7F;\n            if (mms->stream_num < MMS_MAX_STREAMS &&\n                    46 + mms->stream_num * 6 < sizeof(mms->out_buffer)) {\n                mms->streams = av_fast_realloc(mms->streams,\n                                   &mms->nb_streams_allocated,\n                                   (mms->stream_num + 1) * sizeof(MMSStream));\n                if (!mms->streams)\n                    return AVERROR(ENOMEM);\n                mms->streams[mms->stream_num].id = stream_id;\n                mms->stream_num++;\n            } else {\n                av_log(NULL, AV_LOG_ERROR,\n                       \"Corrupt stream (too many A/V streams)\\n\");\n                return AVERROR_INVALIDDATA;\n             }\n         } else if (!memcmp(p, ff_asf_ext_stream_header, sizeof(ff_asf_guid))) {\n             if (end - p >= 88) {\n                int stream_count = AV_RL16(p + 84), ext_len_count = AV_RL16(p + 86);\n                uint64_t skip_bytes = 88;\n                while (stream_count--) {\n                    if (end - p < skip_bytes + 4) {\n                        av_log(NULL, AV_LOG_ERROR,\n                               \"Corrupt stream (next stream name length is not in the buffer)\\n\");\n                        return AVERROR_INVALIDDATA;\n                    }\n                    skip_bytes += 4 + AV_RL16(p + skip_bytes + 2);\n                }\n                while (ext_len_count--) {\n                    if (end - p < skip_bytes + 22) {\n                        av_log(NULL, AV_LOG_ERROR,\n                               \"Corrupt stream (next extension system info length is not in the buffer)\\n\");\n                        return AVERROR_INVALIDDATA;\n                    }\n                    skip_bytes += 22 + AV_RL32(p + skip_bytes + 18);\n                }\n                if (end - p < skip_bytes) {\n                    av_log(NULL, AV_LOG_ERROR,\n                           \"Corrupt stream (the last extension system info length is invalid)\\n\");\n                    return AVERROR_INVALIDDATA;\n                }\n                if (chunksize - skip_bytes > 24)\n                    chunksize = skip_bytes;\n             }\n         } else if (!memcmp(p, ff_asf_head1_guid, sizeof(ff_asf_guid))) {\n             chunksize = 46; // see references [2] section 3.4. This should be set 46.\n         }\n         p += chunksize;\n     }\n\n    return 0;\n}\n", "target": 1, "idx": 182099}
{"func": "void GLES2DecoderImpl::DoBindTexture(GLenum target, GLuint client_id) {\n  TextureRef* texture_ref = nullptr;\n  GLuint service_id = 0;\n  if (client_id != 0) {\n    texture_ref = GetTexture(client_id);\n    if (!texture_ref) {\n      if (!group_->bind_generates_resource()) {\n        LOCAL_SET_GL_ERROR(GL_INVALID_OPERATION,\n                           \"glBindTexture\",\n                           \"id not generated by glGenTextures\");\n        return;\n      }\n\n      api()->glGenTexturesFn(1, &service_id);\n      DCHECK_NE(0u, service_id);\n      CreateTexture(client_id, service_id);\n      texture_ref = GetTexture(client_id);\n    }\n  } else {\n    texture_ref = texture_manager()->GetDefaultTextureInfo(target);\n  }\n\n  if (texture_ref) {\n    Texture* texture = texture_ref->texture();\n    if (texture->target() != 0 && texture->target() != target) {\n      LOCAL_SET_GL_ERROR(GL_INVALID_OPERATION,\n                         \"glBindTexture\",\n                         \"texture bound to more than 1 target.\");\n      return;\n    }\n    LogClientServiceForInfo(texture, client_id, \"glBindTexture\");\n    api()->glBindTextureFn(target, texture->service_id());\n    if (texture->target() == 0) {\n      texture_manager()->SetTarget(texture_ref, target);\n      if (!gl_version_info().BehavesLikeGLES() &&\n          gl_version_info().IsAtLeastGL(3, 2)) {\n        api()->glTexParameteriFn(target, GL_DEPTH_TEXTURE_MODE, GL_RED);\n      }\n    }\n  } else {\n    api()->glBindTextureFn(target, 0);\n  }\n\n  TextureUnit& unit = state_.texture_units[state_.active_texture_unit];\n  unit.bind_target = target;\n  unit.SetInfoForTarget(target, texture_ref);\n}\n", "target": 0, "idx": 153959}
{"func": "void TEMPLATE(process_block_dec)(decoder_info_t *decoder_info,int size,int yposY,int xposY,int sub)\n{\n  int width = decoder_info->width;\n  int height = decoder_info->height;\n  stream_t *stream = decoder_info->stream;\n  frame_type_t frame_type = decoder_info->frame_info.frame_type;\n  int split_flag = 0;\n\n  if (yposY >= height || xposY >= width)\n    return;\n\n  int decode_this_size = (yposY + size <= height) && (xposY + size <= width);\n  int decode_rectangular_size = !decode_this_size && frame_type != I_FRAME;\n\n  int bit_start = stream->bitcnt;\n\n  int mode = MODE_SKIP;\n \n  block_context_t block_context;\n  TEMPLATE(find_block_contexts)(yposY, xposY, height, width, size, decoder_info->deblock_data, &block_context, decoder_info->use_block_contexts);\n  decoder_info->block_context = &block_context;\n\n  split_flag = decode_super_mode(decoder_info,size,decode_this_size);\n  mode = decoder_info->mode;\n  \n  /* Read delta_qp and set block-level qp */\n  if (size == (1<<decoder_info->log2_sb_size) && (split_flag || mode != MODE_SKIP) && decoder_info->max_delta_qp > 0) {\n    /* Read delta_qp */\n    int delta_qp = read_delta_qp(stream);\n    int prev_qp;\n    if (yposY == 0 && xposY == 0)\n      prev_qp = decoder_info->frame_info.qp;\n    else\n      prev_qp = decoder_info->frame_info.qpb;\n    decoder_info->frame_info.qpb = prev_qp + delta_qp;\n  }\n \n   decoder_info->bit_count.super_mode[decoder_info->bit_count.stat_frame_type] += (stream->bitcnt - bit_start);\n \n  if (split_flag){\n     int new_size = size/2;\n     TEMPLATE(process_block_dec)(decoder_info,new_size,yposY+0*new_size,xposY+0*new_size,sub);\n     TEMPLATE(process_block_dec)(decoder_info,new_size,yposY+1*new_size,xposY+0*new_size,sub);\n    TEMPLATE(process_block_dec)(decoder_info,new_size,yposY+0*new_size,xposY+1*new_size,sub);\n    TEMPLATE(process_block_dec)(decoder_info,new_size,yposY+1*new_size,xposY+1*new_size,sub);\n  }\n  else if (decode_this_size || decode_rectangular_size){\n    decode_block(decoder_info,size,yposY,xposY,sub);\n  }\n}\n", "target": 1, "idx": 182538}
{"func": "static int tg3_set_pauseparam(struct net_device *dev, struct ethtool_pauseparam *epause)\n{\n\tstruct tg3 *tp = netdev_priv(dev);\n\tint err = 0;\n\n\tif (tg3_flag(tp, USE_PHYLIB)) {\n\t\tu32 newadv;\n\t\tstruct phy_device *phydev;\n\n\t\tphydev = tp->mdio_bus->phy_map[TG3_PHY_MII_ADDR];\n\n\t\tif (!(phydev->supported & SUPPORTED_Pause) ||\n\t\t    (!(phydev->supported & SUPPORTED_Asym_Pause) &&\n\t\t     (epause->rx_pause != epause->tx_pause)))\n\t\t\treturn -EINVAL;\n\n\t\ttp->link_config.flowctrl = 0;\n\t\tif (epause->rx_pause) {\n\t\t\ttp->link_config.flowctrl |= FLOW_CTRL_RX;\n\n\t\t\tif (epause->tx_pause) {\n\t\t\t\ttp->link_config.flowctrl |= FLOW_CTRL_TX;\n\t\t\t\tnewadv = ADVERTISED_Pause;\n\t\t\t} else\n\t\t\t\tnewadv = ADVERTISED_Pause |\n\t\t\t\t\t ADVERTISED_Asym_Pause;\n\t\t} else if (epause->tx_pause) {\n\t\t\ttp->link_config.flowctrl |= FLOW_CTRL_TX;\n\t\t\tnewadv = ADVERTISED_Asym_Pause;\n\t\t} else\n\t\t\tnewadv = 0;\n\n\t\tif (epause->autoneg)\n\t\t\ttg3_flag_set(tp, PAUSE_AUTONEG);\n\t\telse\n\t\t\ttg3_flag_clear(tp, PAUSE_AUTONEG);\n\n\t\tif (tp->phy_flags & TG3_PHYFLG_IS_CONNECTED) {\n\t\t\tu32 oldadv = phydev->advertising &\n\t\t\t\t     (ADVERTISED_Pause | ADVERTISED_Asym_Pause);\n\t\t\tif (oldadv != newadv) {\n\t\t\t\tphydev->advertising &=\n\t\t\t\t\t~(ADVERTISED_Pause |\n\t\t\t\t\t  ADVERTISED_Asym_Pause);\n\t\t\t\tphydev->advertising |= newadv;\n\t\t\t\tif (phydev->autoneg) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Always renegotiate the link to\n\t\t\t\t\t * inform our link partner of our\n\t\t\t\t\t * flow control settings, even if the\n\t\t\t\t\t * flow control is forced.  Let\n\t\t\t\t\t * tg3_adjust_link() do the final\n\t\t\t\t\t * flow control setup.\n\t\t\t\t\t */\n\t\t\t\t\treturn phy_start_aneg(phydev);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!epause->autoneg)\n\t\t\t\ttg3_setup_flow_control(tp, 0, 0);\n\t\t} else {\n\t\t\ttp->link_config.advertising &=\n\t\t\t\t\t~(ADVERTISED_Pause |\n\t\t\t\t\t  ADVERTISED_Asym_Pause);\n\t\t\ttp->link_config.advertising |= newadv;\n\t\t}\n\t} else {\n\t\tint irq_sync = 0;\n\n\t\tif (netif_running(dev)) {\n\t\t\ttg3_netif_stop(tp);\n\t\t\tirq_sync = 1;\n\t\t}\n\n\t\ttg3_full_lock(tp, irq_sync);\n\n\t\tif (epause->autoneg)\n\t\t\ttg3_flag_set(tp, PAUSE_AUTONEG);\n\t\telse\n\t\t\ttg3_flag_clear(tp, PAUSE_AUTONEG);\n\t\tif (epause->rx_pause)\n\t\t\ttp->link_config.flowctrl |= FLOW_CTRL_RX;\n\t\telse\n\t\t\ttp->link_config.flowctrl &= ~FLOW_CTRL_RX;\n\t\tif (epause->tx_pause)\n\t\t\ttp->link_config.flowctrl |= FLOW_CTRL_TX;\n\t\telse\n\t\t\ttp->link_config.flowctrl &= ~FLOW_CTRL_TX;\n\n\t\tif (netif_running(dev)) {\n\t\t\ttg3_halt(tp, RESET_KIND_SHUTDOWN, 1);\n\t\t\terr = tg3_restart_hw(tp, 1);\n\t\t\tif (!err)\n\t\t\t\ttg3_netif_start(tp);\n\t\t}\n\n\t\ttg3_full_unlock(tp);\n\t}\n\n\treturn err;\n}\n", "target": 0, "idx": 32752}
{"func": "void WebContentsImpl::CreateNewWidget(int32_t render_process_id,\n                                      int32_t route_id,\n                                      bool is_fullscreen,\n                                      mojom::WidgetPtr widget,\n                                      blink::WebPopupType popup_type) {\n  RenderProcessHost* process = RenderProcessHost::FromID(render_process_id);\n  if (!HasMatchingProcess(&frame_tree_, render_process_id)) {\n    ReceivedBadMessage(process, bad_message::WCI_NEW_WIDGET_PROCESS_MISMATCH);\n    return;\n  }\n\n  RenderWidgetHostImpl* widget_host = new RenderWidgetHostImpl(\n      this, process, route_id, std::move(widget), IsHidden());\n\n  RenderWidgetHostViewBase* widget_view =\n      static_cast<RenderWidgetHostViewBase*>(\n          view_->CreateViewForPopupWidget(widget_host));\n  if (!widget_view)\n    return;\n  if (!is_fullscreen) {\n    widget_view->SetPopupType(popup_type);\n  }\n  pending_widget_views_[GlobalRoutingID(render_process_id, route_id)] =\n      widget_view;\n}\n", "target": 0, "idx": 158893}
{"func": "bool BaseAudioContext::WouldTaintOrigin(const KURL& url) const {\n  if (url.ProtocolIsData()) {\n    return false;\n  }\n  Document* document = GetDocument();\n  if (document && document->GetSecurityOrigin()) {\n    return !document->GetSecurityOrigin()->CanRequest(url);\n  }\n  return true;\n}\n", "target": 1, "idx": 186610}
{"func": "vrrp_state_handler(vector_t *strvec)\n{\n\tchar *str = strvec_slot(strvec, 1);\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\n\tif (!strcmp(str, \"MASTER\"))\n\t\tvrrp->wantstate = VRRP_STATE_MAST;\n\telse if (!strcmp(str, \"BACKUP\"))\n\t{\n\t\tif (vrrp->wantstate == VRRP_STATE_MAST)\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s) state previously set as MASTER - ignoring BACKUP\", vrrp->iname);\n\t\telse\n\t\t\tvrrp->wantstate = VRRP_STATE_BACK;\n\t}\n\telse {\n\t\treport_config_error(CONFIG_GENERAL_ERROR,\"(%s) unknown state '%s', defaulting to BACKUP\", vrrp->iname, str);\n\t\tvrrp->wantstate = VRRP_STATE_BACK;\n\t}\n}\n", "target": 0, "idx": 76035}
{"func": "ChromeContentBrowserClient::CreateThrottlesForNavigation(\n    content::NavigationHandle* handle) {\n  std::vector<std::unique_ptr<content::NavigationThrottle>> throttles;\n\n  if (handle->IsInMainFrame()) {\n    throttles.push_back(\n        page_load_metrics::MetricsNavigationThrottle::Create(handle));\n  }\n\n#if BUILDFLAG(ENABLE_PLUGINS)\n  std::unique_ptr<content::NavigationThrottle> flash_url_throttle =\n      FlashDownloadInterception::MaybeCreateThrottleFor(handle);\n  if (flash_url_throttle)\n    throttles.push_back(std::move(flash_url_throttle));\n#endif\n\n#if BUILDFLAG(ENABLE_SUPERVISED_USERS)\n  std::unique_ptr<content::NavigationThrottle> supervised_user_throttle =\n      SupervisedUserNavigationThrottle::MaybeCreateThrottleFor(handle);\n  if (supervised_user_throttle)\n    throttles.push_back(std::move(supervised_user_throttle));\n#endif\n\n#if defined(OS_ANDROID)\n  prerender::PrerenderContents* prerender_contents =\n      prerender::PrerenderContents::FromWebContents(handle->GetWebContents());\n  if (!prerender_contents && handle->IsInMainFrame()) {\n    throttles.push_back(\n        navigation_interception::InterceptNavigationDelegate::CreateThrottleFor(\n            handle));\n  }\n  throttles.push_back(InterceptOMADownloadNavigationThrottle::Create(handle));\n#elif BUILDFLAG(ENABLE_EXTENSIONS)\n  if (handle->IsInMainFrame()) {\n    auto url_to_app_throttle =\n        PlatformAppNavigationRedirector::MaybeCreateThrottleFor(handle);\n    if (url_to_app_throttle)\n      throttles.push_back(std::move(url_to_app_throttle));\n  }\n\n  if (base::FeatureList::IsEnabled(features::kDesktopPWAWindowing)) {\n    if (base::FeatureList::IsEnabled(features::kDesktopPWAsLinkCapturing)) {\n      auto bookmark_app_experimental_throttle =\n          extensions::BookmarkAppExperimentalNavigationThrottle::\n              MaybeCreateThrottleFor(handle);\n      if (bookmark_app_experimental_throttle)\n        throttles.push_back(std::move(bookmark_app_experimental_throttle));\n    } else if (!base::FeatureList::IsEnabled(\n                   features::kDesktopPWAsStayInWindow)) {\n      auto bookmark_app_throttle =\n          extensions::BookmarkAppNavigationThrottle::MaybeCreateThrottleFor(\n              handle);\n      if (bookmark_app_throttle)\n        throttles.push_back(std::move(bookmark_app_throttle));\n    }\n  }\n   if (base::FeatureList::IsEnabled(\n           features::kMimeHandlerViewInCrossProcessFrame)) {\n     auto plugin_frame_attach_throttle =\n        extensions::ExtensionsGuestViewMessageFilter::MaybeCreateThrottle(\n            handle);\n     if (plugin_frame_attach_throttle)\n       throttles.push_back(std::move(plugin_frame_attach_throttle));\n   }\n#endif\n\n#if defined(OS_CHROMEOS)\n  if (handle->IsInMainFrame()) {\n    if (merge_session_throttling_utils::ShouldAttachNavigationThrottle() &&\n        !merge_session_throttling_utils::AreAllSessionMergedAlready() &&\n        handle->GetURL().SchemeIsHTTPOrHTTPS()) {\n      throttles.push_back(MergeSessionNavigationThrottle::Create(handle));\n    }\n\n    auto url_to_apps_throttle =\n        chromeos::AppsNavigationThrottle::MaybeCreate(handle);\n    if (url_to_apps_throttle)\n      throttles.push_back(std::move(url_to_apps_throttle));\n  }\n#endif\n\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n  throttles.push_back(\n      std::make_unique<extensions::ExtensionNavigationThrottle>(handle));\n\n  std::unique_ptr<content::NavigationThrottle> user_script_throttle =\n      extensions::ExtensionsBrowserClient::Get()\n          ->GetUserScriptListener()\n          ->CreateNavigationThrottle(handle);\n  if (user_script_throttle)\n    throttles.push_back(std::move(user_script_throttle));\n#endif\n\n#if BUILDFLAG(ENABLE_SUPERVISED_USERS)\n  std::unique_ptr<content::NavigationThrottle> supervised_user_nav_throttle =\n      SupervisedUserGoogleAuthNavigationThrottle::MaybeCreate(handle);\n  if (supervised_user_nav_throttle)\n    throttles.push_back(std::move(supervised_user_nav_throttle));\n#endif\n\n  content::WebContents* web_contents = handle->GetWebContents();\n  if (auto* subresource_filter_client =\n          ChromeSubresourceFilterClient::FromWebContents(web_contents)) {\n    subresource_filter_client->MaybeAppendNavigationThrottles(handle,\n                                                              &throttles);\n  }\n\n#if !defined(OS_ANDROID)\n  std::unique_ptr<content::NavigationThrottle>\n      background_tab_navigation_throttle = resource_coordinator::\n          BackgroundTabNavigationThrottle::MaybeCreateThrottleFor(handle);\n  if (background_tab_navigation_throttle)\n    throttles.push_back(std::move(background_tab_navigation_throttle));\n#endif\n\n#if defined(SAFE_BROWSING_DB_LOCAL)\n  std::unique_ptr<content::NavigationThrottle>\n      password_protection_navigation_throttle =\n          safe_browsing::MaybeCreateNavigationThrottle(handle);\n  if (password_protection_navigation_throttle) {\n    throttles.push_back(std::move(password_protection_navigation_throttle));\n  }\n#endif\n\n  std::unique_ptr<content::NavigationThrottle> pdf_iframe_throttle =\n      PDFIFrameNavigationThrottle::MaybeCreateThrottleFor(handle);\n  if (pdf_iframe_throttle)\n    throttles.push_back(std::move(pdf_iframe_throttle));\n\n  std::unique_ptr<content::NavigationThrottle> tab_under_throttle =\n      TabUnderNavigationThrottle::MaybeCreate(handle);\n  if (tab_under_throttle)\n    throttles.push_back(std::move(tab_under_throttle));\n\n  throttles.push_back(std::make_unique<PolicyBlacklistNavigationThrottle>(\n      handle, handle->GetWebContents()->GetBrowserContext()));\n\n  if (base::FeatureList::IsEnabled(features::kSSLCommittedInterstitials)) {\n    throttles.push_back(std::make_unique<SSLErrorNavigationThrottle>(\n        handle,\n        std::make_unique<CertificateReportingServiceCertReporter>(web_contents),\n        base::Bind(&SSLErrorHandler::HandleSSLError)));\n  }\n\n  std::unique_ptr<content::NavigationThrottle> https_upgrade_timing_throttle =\n      TypedNavigationTimingThrottle::MaybeCreateThrottleFor(handle);\n  if (https_upgrade_timing_throttle)\n    throttles.push_back(std::move(https_upgrade_timing_throttle));\n\n#if !defined(OS_ANDROID)\n  std::unique_ptr<content::NavigationThrottle> devtools_throttle =\n      DevToolsWindow::MaybeCreateNavigationThrottle(handle);\n  if (devtools_throttle)\n    throttles.push_back(std::move(devtools_throttle));\n\n  std::unique_ptr<content::NavigationThrottle> new_tab_page_throttle =\n      NewTabPageNavigationThrottle::MaybeCreateThrottleFor(handle);\n  if (new_tab_page_throttle)\n    throttles.push_back(std::move(new_tab_page_throttle));\n\n  std::unique_ptr<content::NavigationThrottle>\n      google_password_manager_throttle =\n          GooglePasswordManagerNavigationThrottle::MaybeCreateThrottleFor(\n              handle);\n  if (google_password_manager_throttle)\n    throttles.push_back(std::move(google_password_manager_throttle));\n#endif\n\n  std::unique_ptr<content::NavigationThrottle> previews_lite_page_throttle =\n      PreviewsLitePageDecider::MaybeCreateThrottleFor(handle);\n  if (previews_lite_page_throttle)\n    throttles.push_back(std::move(previews_lite_page_throttle));\n  if (base::FeatureList::IsEnabled(safe_browsing::kCommittedSBInterstitials)) {\n    throttles.push_back(\n        std::make_unique<safe_browsing::SafeBrowsingNavigationThrottle>(\n            handle));\n  }\n\n#if defined(OS_WIN) || defined(OS_MACOSX) || \\\n    (defined(OS_LINUX) && !defined(OS_CHROMEOS))\n  std::unique_ptr<content::NavigationThrottle> browser_switcher_throttle =\n      browser_switcher::BrowserSwitcherNavigationThrottle ::\n          MaybeCreateThrottleFor(handle);\n  if (browser_switcher_throttle)\n    throttles.push_back(std::move(browser_switcher_throttle));\n#endif\n\n  return throttles;\n}\n", "target": 1, "idx": 187015}
{"func": "void Editor::pasteAsPlainText(EditorCommandSource source) {\n  if (tryDHTMLPaste(PlainTextOnly))\n    return;\n  if (!canPaste())\n    return;\n  spellChecker().updateMarkersForWordsAffectedByEditing(false);\n  pasteAsPlainTextWithPasteboard(Pasteboard::generalPasteboard());\n}\n", "target": 0, "idx": 140347}
{"func": "static void webkitWebViewBaseContainerAdd(GtkContainer* container, GtkWidget* widget)\n{\n    WebKitWebViewBase* webView = WEBKIT_WEB_VIEW_BASE(container);\n    WebKitWebViewBasePrivate* priv = webView->priv;\n\n    if (WEBKIT_IS_WEB_VIEW_BASE(widget)\n         && WebInspectorProxy::isInspectorPage(WEBKIT_WEB_VIEW_BASE(widget)->priv->pageProxy.get())) {\n         ASSERT(!priv->inspectorView);\n         priv->inspectorView = widget;\n        priv->inspectorViewHeight = gMinimumAttachedInspectorHeight;\n     } else {\n         GtkAllocation childAllocation;\n         gtk_widget_get_allocation(widget, &childAllocation);\n        priv->children.set(widget, childAllocation);\n    }\n\n    gtk_widget_set_parent(widget, GTK_WIDGET(container));\n}\n", "target": 1, "idx": 184744}
{"func": "static void put_crypt_info(struct fscrypt_info *ci)\n{\n \tif (!ci)\n \t\treturn;\n \n\tkey_put(ci->ci_keyring_key);\n \tcrypto_free_skcipher(ci->ci_ctfm);\n \tkmem_cache_free(fscrypt_info_cachep, ci);\n }\n", "target": 1, "idx": 181455}
{"func": "AP_DECLARE(int) ap_some_auth_required(request_rec *r)\n{\n    /* Is there a require line configured for the type of *this* req? */\n    if (ap__authz_ap_some_auth_required) {\n        return ap__authz_ap_some_auth_required(r);\n    }\n    else\n        return 0;\n}\n", "target": 0, "idx": 43608}
{"func": "void acpi_os_printf(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tacpi_os_vprintf(fmt, args);\n\tva_end(args);\n}\n", "target": 0, "idx": 53859}
{"func": " PassRefPtr<DocumentFragment> Range::createContextualFragment(const String& markup, ExceptionCode& ec)\n {\n     if (!m_start.container()) {\n        ec = INVALID_STATE_ERR;\n        return 0;\n    }\n\n    Node* element = m_start.container()->isElementNode() ? m_start.container() : m_start.container()->parentNode();\n    if (!element || !element->isHTMLElement()) {\n        ec = NOT_SUPPORTED_ERR;\n         return 0;\n     }\n \n    RefPtr<DocumentFragment> fragment = createDocumentFragmentForElement(markup, toElement(element), AllowScriptingContentAndDoNotMarkAlreadyStarted);\n \n     if (!fragment) {\n         ec = NOT_SUPPORTED_ERR;\n        return 0;\n    }\n\n    return fragment.release();\n}\n", "target": 1, "idx": 183891}
{"func": "bdfReadCharacters(FontFilePtr file, FontPtr pFont, bdfFileState *pState,\n\t\t  int bit, int byte, int glyph, int scan)\n{\n    unsigned char *line;\n    register CharInfoPtr ci;\n    int         i,\n                ndx,\n                nchars,\n                nignored;\n    unsigned int char_row, char_col;\n    int         numEncodedGlyphs = 0;\n    CharInfoPtr *bdfEncoding[256];\n    BitmapFontPtr  bitmapFont;\n    BitmapExtraPtr bitmapExtra;\n    CARD32     *bitmapsSizes;\n    unsigned char        lineBuf[BDFLINELEN];\n    int         nencoding;\n\n    bitmapFont = (BitmapFontPtr) pFont->fontPrivate;\n    bitmapExtra = (BitmapExtraPtr) bitmapFont->bitmapExtra;\n\n    if (bitmapExtra) {\n\tbitmapsSizes = bitmapExtra->bitmapsSizes;\n\tfor (i = 0; i < GLYPHPADOPTIONS; i++)\n\t    bitmapsSizes[i] = 0;\n    } else\n\tbitmapsSizes = NULL;\n\n    bzero(bdfEncoding, sizeof(bdfEncoding));\n    bitmapFont->metrics = NULL;\n    ndx = 0;\n\n    line = bdfGetLine(file, lineBuf, BDFLINELEN);\n\n    if ((!line) || (sscanf((char *) line, \"CHARS %d\", &nchars) != 1)) {\n\tbdfError(\"bad 'CHARS' in bdf file\\n\");\n\treturn (FALSE);\n    }\n    if (nchars < 1) {\n\tbdfError(\"invalid number of CHARS in BDF file\\n\");\n\treturn (FALSE);\n    }\n    if (nchars > INT32_MAX / sizeof(CharInfoRec)) {\n\tbdfError(\"Couldn't allocate pCI (%d*%d)\\n\", nchars,\n\t\t (int) sizeof(CharInfoRec));\n\tgoto BAILOUT;\n    }\n    ci = calloc(nchars, sizeof(CharInfoRec));\n    if (!ci) {\n\tbdfError(\"Couldn't allocate pCI (%d*%d)\\n\", nchars,\n\t\t (int) sizeof(CharInfoRec));\n\tgoto BAILOUT;\n    }\n    bitmapFont->metrics = ci;\n\n    if (bitmapExtra) {\n\tbitmapExtra->glyphNames = malloc(nchars * sizeof(Atom));\n\tif (!bitmapExtra->glyphNames) {\n\t    bdfError(\"Couldn't allocate glyphNames (%d*%d)\\n\",\n\t\t     nchars, (int) sizeof(Atom));\n\t    goto BAILOUT;\n\t}\n    }\n    if (bitmapExtra) {\n\tbitmapExtra->sWidths = malloc(nchars * sizeof(int));\n\tif (!bitmapExtra->sWidths) {\n\t    bdfError(\"Couldn't allocate sWidth (%d *%d)\\n\",\n\t\t     nchars, (int) sizeof(int));\n\t    return FALSE;\n\t}\n    }\n    line = bdfGetLine(file, lineBuf, BDFLINELEN);\n    pFont->info.firstRow = 256;\n    pFont->info.lastRow = 0;\n    pFont->info.firstCol = 256;\n    pFont->info.lastCol = 0;\n    nignored = 0;\n    for (ndx = 0; (ndx < nchars) && (line) && (bdfIsPrefix(line, \"STARTCHAR\"));) {\n\tint         t;\n\tint         wx;\t\t/* x component of width */\n\tint         wy;\t\t/* y component of width */\n\tint         bw;\t\t/* bounding-box width */\n\tint         bh;\t\t/* bounding-box height */\n\tint         bl;\t\t/* bounding-box left */\n\tint         bb;\t\t/* bounding-box bottom */\n\tint         enc,\n\t            enc2;\t/* encoding */\n\tunsigned char *p;\t/* temp pointer into line */\n \tchar        charName[100];\n \tint         ignore;\n \n\tif (sscanf((char *) line, \"STARTCHAR %s\", charName) != 1) {\n \t    bdfError(\"bad character name in BDF file\\n\");\n \t    goto BAILOUT;\t/* bottom of function, free and return error */\n \t}\n\tif (bitmapExtra)\n\t    bitmapExtra->glyphNames[ndx] = bdfForceMakeAtom(charName, NULL);\n\n\tline = bdfGetLine(file, lineBuf, BDFLINELEN);\n\tif (!line || (t = sscanf((char *) line, \"ENCODING %d %d\", &enc, &enc2)) < 1) {\n\t    bdfError(\"bad 'ENCODING' in BDF file\\n\");\n\t    goto BAILOUT;\n\t}\n\tif (enc < -1 || (t == 2 && enc2 < -1)) {\n\t    bdfError(\"bad ENCODING value\");\n\t    goto BAILOUT;\n\t}\n\tif (t == 2 && enc == -1)\n\t    enc = enc2;\n\tignore = 0;\n\tif (enc == -1) {\n\t    if (!bitmapExtra) {\n\t\tnignored++;\n\t\tignore = 1;\n\t    }\n\t} else if (enc > MAXENCODING) {\n\t    bdfError(\"char '%s' has encoding too large (%d)\\n\",\n\t\t     charName, enc);\n\t} else {\n\t    char_row = (enc >> 8) & 0xFF;\n\t    char_col = enc & 0xFF;\n\t    if (char_row < pFont->info.firstRow)\n\t\tpFont->info.firstRow = char_row;\n\t    if (char_row > pFont->info.lastRow)\n\t\tpFont->info.lastRow = char_row;\n\t    if (char_col < pFont->info.firstCol)\n\t\tpFont->info.firstCol = char_col;\n\t    if (char_col > pFont->info.lastCol)\n\t\tpFont->info.lastCol = char_col;\n\t    if (bdfEncoding[char_row] == (CharInfoPtr *) NULL) {\n\t\tbdfEncoding[char_row] = malloc(256 * sizeof(CharInfoPtr));\n\t\tif (!bdfEncoding[char_row]) {\n\t\t    bdfError(\"Couldn't allocate row %d of encoding (%d*%d)\\n\",\n\t\t\t     char_row, INDICES, (int) sizeof(CharInfoPtr));\n\t\t    goto BAILOUT;\n\t\t}\n\t\tfor (i = 0; i < 256; i++)\n\t\t    bdfEncoding[char_row][i] = (CharInfoPtr) NULL;\n\t    }\n\t    if (bdfEncoding[char_row] != NULL) {\n\t\tbdfEncoding[char_row][char_col] = ci;\n\t\tnumEncodedGlyphs++;\n\t    }\n\t}\n\n\tline = bdfGetLine(file, lineBuf, BDFLINELEN);\n\tif ((!line) || (sscanf((char *) line, \"SWIDTH %d %d\", &wx, &wy) != 2)) {\n\t    bdfError(\"bad 'SWIDTH'\\n\");\n\t    goto BAILOUT;\n\t}\n\tif (wy != 0) {\n\t    bdfError(\"SWIDTH y value must be zero\\n\");\n\t    goto BAILOUT;\n\t}\n\tif (bitmapExtra)\n\t    bitmapExtra->sWidths[ndx] = wx;\n\n/* 5/31/89 (ef) -- we should be able to ditch the character and recover */\n/*\t\tfrom all of these.\t\t\t\t\t*/\n\n\tline = bdfGetLine(file, lineBuf, BDFLINELEN);\n\tif ((!line) || (sscanf((char *) line, \"DWIDTH %d %d\", &wx, &wy) != 2)) {\n\t    bdfError(\"bad 'DWIDTH'\\n\");\n\t    goto BAILOUT;\n\t}\n\tif (wy != 0) {\n\t    bdfError(\"DWIDTH y value must be zero\\n\");\n\t    goto BAILOUT;\n\t}\n\tline = bdfGetLine(file, lineBuf, BDFLINELEN);\n\tif ((!line) || (sscanf((char *) line, \"BBX %d %d %d %d\", &bw, &bh, &bl, &bb) != 4)) {\n\t    bdfError(\"bad 'BBX'\\n\");\n\t    goto BAILOUT;\n\t}\n\tif ((bh < 0) || (bw < 0)) {\n\t    bdfError(\"character '%s' has a negative sized bitmap, %dx%d\\n\",\n\t\t     charName, bw, bh);\n\t    goto BAILOUT;\n\t}\n\tline = bdfGetLine(file, lineBuf, BDFLINELEN);\n\tif ((line) && (bdfIsPrefix(line, \"ATTRIBUTES\"))) {\n\t    for (p = line + strlen(\"ATTRIBUTES \");\n\t\t    (*p == ' ') || (*p == '\\t');\n\t\t    p++)\n\t\t /* empty for loop */ ;\n\t    ci->metrics.attributes = (bdfHexByte(p) << 8) + bdfHexByte(p + 2);\n\t    line = bdfGetLine(file, lineBuf, BDFLINELEN);\n\t} else\n\t    ci->metrics.attributes = 0;\n\n\tif (!line || !bdfIsPrefix(line, \"BITMAP\")) {\n\t    bdfError(\"missing 'BITMAP'\\n\");\n\t    goto BAILOUT;\n\t}\n\t/* collect data for generated properties */\n\tif ((strlen(charName) == 1)) {\n\t    if ((charName[0] >= '0') && (charName[0] <= '9')) {\n\t\tpState->digitWidths += wx;\n\t\tpState->digitCount++;\n\t    } else if (charName[0] == 'x') {\n\t\tpState->exHeight = (bh + bb) <= 0 ? bh : bh + bb;\n\t    }\n\t}\n\tif (!ignore) {\n\t    ci->metrics.leftSideBearing = bl;\n\t    ci->metrics.rightSideBearing = bl + bw;\n\t    ci->metrics.ascent = bh + bb;\n\t    ci->metrics.descent = -bb;\n\t    ci->metrics.characterWidth = wx;\n\t    ci->bits = NULL;\n\t    bdfReadBitmap(ci, file, bit, byte, glyph, scan, bitmapsSizes);\n\t    ci++;\n\t    ndx++;\n\t} else\n\t    bdfSkipBitmap(file, bh);\n\n\tline = bdfGetLine(file, lineBuf, BDFLINELEN);\t/* get STARTCHAR or\n\t\t\t\t\t\t\t * ENDFONT */\n    }\n\n    if (ndx + nignored != nchars) {\n\tbdfError(\"%d too few characters\\n\", nchars - (ndx + nignored));\n\tgoto BAILOUT;\n    }\n    nchars = ndx;\n    bitmapFont->num_chars = nchars;\n    if ((line) && (bdfIsPrefix(line, \"STARTCHAR\"))) {\n\tbdfError(\"more characters than specified\\n\");\n\tgoto BAILOUT;\n    }\n    if ((!line) || (!bdfIsPrefix(line, \"ENDFONT\"))) {\n\tbdfError(\"missing 'ENDFONT'\\n\");\n\tgoto BAILOUT;\n    }\n    if (numEncodedGlyphs == 0)\n\tbdfWarning(\"No characters with valid encodings\\n\");\n\n    nencoding = (pFont->info.lastRow - pFont->info.firstRow + 1) *\n\t(pFont->info.lastCol - pFont->info.firstCol + 1);\n    bitmapFont->encoding = calloc(NUM_SEGMENTS(nencoding),sizeof(CharInfoPtr*));\n    if (!bitmapFont->encoding) {\n\tbdfError(\"Couldn't allocate ppCI (%d,%d)\\n\",\n                 NUM_SEGMENTS(nencoding),\n                 (int) sizeof(CharInfoPtr*));\n\tgoto BAILOUT;\n    }\n    pFont->info.allExist = TRUE;\n    i = 0;\n    for (char_row = pFont->info.firstRow;\n\t    char_row <= pFont->info.lastRow;\n\t    char_row++) {\n\tif (bdfEncoding[char_row] == (CharInfoPtr *) NULL) {\n\t    pFont->info.allExist = FALSE;\n            i += pFont->info.lastCol - pFont->info.firstCol + 1;\n\t} else {\n\t    for (char_col = pFont->info.firstCol;\n\t\t    char_col <= pFont->info.lastCol;\n\t\t    char_col++) {\n\t\tif (!bdfEncoding[char_row][char_col])\n\t\t    pFont->info.allExist = FALSE;\n                else {\n                    if (!bitmapFont->encoding[SEGMENT_MAJOR(i)]) {\n                        bitmapFont->encoding[SEGMENT_MAJOR(i)]=\n                            calloc(BITMAP_FONT_SEGMENT_SIZE,\n                                   sizeof(CharInfoPtr));\n                        if (!bitmapFont->encoding[SEGMENT_MAJOR(i)])\n                            goto BAILOUT;\n                    }\n                    ACCESSENCODINGL(bitmapFont->encoding,i) =\n                        bdfEncoding[char_row][char_col];\n                }\n                i++;\n            }\n\t}\n    }\n    for (i = 0; i < 256; i++)\n\tif (bdfEncoding[i])\n\t    free(bdfEncoding[i]);\n    return (TRUE);\nBAILOUT:\n    for (i = 0; i < 256; i++)\n\tif (bdfEncoding[i])\n\t    free(bdfEncoding[i]);\n    /* bdfFreeFontBits will clean up the rest */\n    return (FALSE);\n}\n", "target": 1, "idx": 178505}
{"func": "snap_print(netdissect_options *ndo, const u_char *p, u_int length, u_int caplen,\n\tconst struct lladdr_info *src, const struct lladdr_info *dst,\n\tu_int bridge_pad)\n{\n\tuint32_t orgcode;\n\tregister u_short et;\n\tregister int ret;\n\n\tND_TCHECK2(*p, 5);\n\tif (caplen < 5 || length < 5)\n\t\tgoto trunc;\n\torgcode = EXTRACT_24BITS(p);\n\tet = EXTRACT_16BITS(p + 3);\n\n\tif (ndo->ndo_eflag) {\n\t\t/*\n\t\t * Somebody's already printed the MAC addresses, if there\n\t\t * are any, so just print the SNAP header, not the MAC\n\t\t * addresses.\n\t\t */\n\t\tND_PRINT((ndo, \"oui %s (0x%06x), %s %s (0x%04x), length %u: \",\n\t\t     tok2str(oui_values, \"Unknown\", orgcode),\n\t\t     orgcode,\n\t\t     (orgcode == 0x000000 ? \"ethertype\" : \"pid\"),\n\t\t     tok2str(oui_to_struct_tok(orgcode), \"Unknown\", et),\n\t\t     et, length - 5));\n\t}\n\tp += 5;\n\tlength -= 5;\n\tcaplen -= 5;\n\n\tswitch (orgcode) {\n\tcase OUI_ENCAP_ETHER:\n\tcase OUI_CISCO_90:\n\t\t/*\n\t\t * This is an encapsulated Ethernet packet,\n\t\t * or a packet bridged by some piece of\n\t\t * Cisco hardware; the protocol ID is\n\t\t * an Ethernet protocol type.\n\t\t */\n\t\tret = ethertype_print(ndo, et, p, length, caplen, src, dst);\n\t\tif (ret)\n\t\t\treturn (ret);\n\t\tbreak;\n\n\tcase OUI_APPLETALK:\n\t\tif (et == ETHERTYPE_ATALK) {\n\t\t\t/*\n\t\t\t * No, I have no idea why Apple used one\n\t\t\t * of their own OUIs, rather than\n\t\t\t * 0x000000, and an Ethernet packet\n\t\t\t * type, for Appletalk data packets,\n\t\t\t * but used 0x000000 and an Ethernet\n\t\t\t * packet type for AARP packets.\n\t\t\t */\n\t\t\tret = ethertype_print(ndo, et, p, length, caplen, src, dst);\n\t\t\tif (ret)\n\t\t\t\treturn (ret);\n\t\t}\n\t\tbreak;\n\n\tcase OUI_CISCO:\n                switch (et) {\n                case PID_CISCO_CDP:\n                        cdp_print(ndo, p, length, caplen);\n                        return (1);\n                case PID_CISCO_DTP:\n                        dtp_print(ndo, p, length);\n                        return (1);\n                case PID_CISCO_UDLD:\n                        udld_print(ndo, p, length);\n                        return (1);\n                case PID_CISCO_VTP:\n                        vtp_print(ndo, p, length);\n                        return (1);\n                case PID_CISCO_PVST:\n                case PID_CISCO_VLANBRIDGE:\n                        stp_print(ndo, p, length);\n                        return (1);\n                default:\n                        break;\n                }\n\t\tbreak;\n\n\tcase OUI_RFC2684:\n\t\tswitch (et) {\n\n\t\tcase PID_RFC2684_ETH_FCS:\n\t\tcase PID_RFC2684_ETH_NOFCS:\n\t\t\t/*\n\t\t\t * XXX - remove the last two bytes for\n\t\t\t * PID_RFC2684_ETH_FCS?\n\t\t\t */\n\t\t\t/*\n\t\t\t * Skip the padding.\n\t\t\t */\n\t\t\tND_TCHECK2(*p, bridge_pad);\n\t\t\tcaplen -= bridge_pad;\n\t\t\tlength -= bridge_pad;\n\t\t\tp += bridge_pad;\n\n\t\t\t/*\n\t\t\t * What remains is an Ethernet packet.\n\t\t\t */\n\t\t\tether_print(ndo, p, length, caplen, NULL, NULL);\n\t\t\treturn (1);\n\n\t\tcase PID_RFC2684_802_5_FCS:\n\t\tcase PID_RFC2684_802_5_NOFCS:\n\t\t\t/*\n\t\t\t * XXX - remove the last two bytes for\n\t\t\t * PID_RFC2684_ETH_FCS?\n\t\t\t */\n\t\t\t/*\n\t\t\t * Skip the padding, but not the Access\n\t\t\t * Control field.\n\t\t\t */\n\t\t\tND_TCHECK2(*p, bridge_pad);\n\t\t\tcaplen -= bridge_pad;\n\t\t\tlength -= bridge_pad;\n\t\t\tp += bridge_pad;\n\n\t\t\t/*\n\t\t\t * What remains is an 802.5 Token Ring\n\t\t\t * packet.\n\t\t\t */\n\t\t\ttoken_print(ndo, p, length, caplen);\n\t\t\treturn (1);\n\n\t\tcase PID_RFC2684_FDDI_FCS:\n\t\tcase PID_RFC2684_FDDI_NOFCS:\n\t\t\t/*\n\t\t\t * XXX - remove the last two bytes for\n\t\t\t * PID_RFC2684_ETH_FCS?\n\t\t\t */\n\t\t\t/*\n\t\t\t * Skip the padding.\n\t\t\t */\n\t\t\tND_TCHECK2(*p, bridge_pad + 1);\n\t\t\tcaplen -= bridge_pad + 1;\n\t\t\tlength -= bridge_pad + 1;\n\t\t\tp += bridge_pad + 1;\n\n\t\t\t/*\n\t\t\t * What remains is an FDDI packet.\n\t\t\t */\n\t\t\tfddi_print(ndo, p, length, caplen);\n\t\t\treturn (1);\n\n\t\tcase PID_RFC2684_BPDU:\n\t\t\tstp_print(ndo, p, length);\n\t\t\treturn (1);\n\t\t}\n\t}\n\tif (!ndo->ndo_eflag) {\n\t\t/*\n\t\t * Nobody printed the link-layer addresses, so print them, if\n\t\t * we have any.\n\t\t */\n\t\tif (src != NULL && dst != NULL) {\n\t\t\tND_PRINT((ndo, \"%s > %s \",\n\t\t\t\t(src->addr_string)(ndo, src->addr),\n\t\t\t\t(dst->addr_string)(ndo, dst->addr)));\n\t\t}\n\t\t/*\n\t\t * Print the SNAP header, but if the OUI is 000000, don't\n\t\t * bother printing it, and report the PID as being an\n\t\t * ethertype.\n\t\t */\n\t\tif (orgcode == 0x000000) {\n\t\t\tND_PRINT((ndo, \"SNAP, ethertype %s (0x%04x), length %u: \",\n\t\t\t     tok2str(ethertype_values, \"Unknown\", et),\n\t\t\t     et, length));\n\t\t} else {\n\t\t\tND_PRINT((ndo, \"SNAP, oui %s (0x%06x), pid %s (0x%04x), length %u: \",\n\t\t\t     tok2str(oui_values, \"Unknown\", orgcode),\n\t\t\t     orgcode,\n\t\t\t     tok2str(oui_to_struct_tok(orgcode), \"Unknown\", et),\n\t\t\t     et, length));\n\t\t}\n\t}\n\treturn (0);\n\ntrunc:\n\tND_PRINT((ndo, \"[|snap]\"));\n\treturn (1);\n}\n", "target": 0, "idx": 62584}
{"func": "bool RenderViewHostManager::ShouldReuseWebUI(\n    const NavigationEntry* curr_entry,\n    const NavigationEntryImpl* new_entry) const {\n  NavigationControllerImpl& controller =\n      delegate_->GetControllerForRenderManager();\n  return curr_entry && web_ui_.get() &&\n      (WebUIControllerFactoryRegistry::GetInstance()->GetWebUIType(\n          controller.GetBrowserContext(), curr_entry->GetURL()) ==\n       WebUIControllerFactoryRegistry::GetInstance()->GetWebUIType(\n          controller.GetBrowserContext(), new_entry->GetURL()));\n}\n", "target": 0, "idx": 124167}
{"func": "megasas_ld_list_query(struct megasas_instance *instance, u8 query_type)\n{\n\tint ret = 0, ld_index = 0, ids = 0;\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\tstruct MR_LD_TARGETID_LIST *ci;\n\tdma_addr_t ci_h = 0;\n\tu32 tgtid_count;\n\n\tci = instance->ld_targetid_list_buf;\n\tci_h = instance->ld_targetid_list_buf_h;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd) {\n\t\tdev_warn(&instance->pdev->dev,\n\t\t         \"megasas_ld_list_query: Failed to get cmd\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tmemset(ci, 0, sizeof(*ci));\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tdcmd->mbox.b[0] = query_type;\n\tif (instance->supportmax256vd)\n\t\tdcmd->mbox.b[2] = 1;\n\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = MFI_STAT_INVALID_STATUS;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = MFI_FRAME_DIR_READ;\n\tdcmd->timeout = 0;\n\tdcmd->data_xfer_len = cpu_to_le32(sizeof(struct MR_LD_TARGETID_LIST));\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_LD_LIST_QUERY);\n\tdcmd->pad_0  = 0;\n\n\tmegasas_set_dma_settings(instance, dcmd, ci_h,\n\t\t\t\t sizeof(struct MR_LD_TARGETID_LIST));\n\n\tif ((instance->adapter_type != MFI_SERIES) &&\n\t    !instance->mask_interrupts)\n\t\tret = megasas_issue_blocked_cmd(instance, cmd, MFI_IO_TIMEOUT_SECS);\n\telse\n\t\tret = megasas_issue_polled(instance, cmd);\n\n\tswitch (ret) {\n\tcase DCMD_FAILED:\n\t\tdev_info(&instance->pdev->dev,\n\t\t\t\"DCMD not supported by firmware - %s %d\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\tret = megasas_get_ld_list(instance);\n\t\tbreak;\n\tcase DCMD_TIMEOUT:\n\t\tswitch (dcmd_timeout_ocr_possible(instance)) {\n\t\tcase INITIATE_OCR:\n\t\t\tcmd->flags |= DRV_DCMD_SKIP_REFIRE;\n\t\t\t/*\n\t\t\t * DCMD failed from AEN path.\n\t\t\t * AEN path already hold reset_mutex to avoid PCI access\n\t\t\t * while OCR is in progress.\n\t\t\t */\n\t\t\tmutex_unlock(&instance->reset_mutex);\n\t\t\tmegasas_reset_fusion(instance->host,\n\t\t\t\t\t\tMFI_IO_TIMEOUT_OCR);\n\t\t\tmutex_lock(&instance->reset_mutex);\n\t\t\tbreak;\n\t\tcase KILL_ADAPTER:\n\t\t\tmegaraid_sas_kill_hba(instance);\n\t\t\tbreak;\n\t\tcase IGNORE_TIMEOUT:\n\t\t\tdev_info(&instance->pdev->dev, \"Ignore DCMD timeout: %s %d\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\tcase DCMD_SUCCESS:\n\t\ttgtid_count = le32_to_cpu(ci->count);\n\n\t\tif ((tgtid_count > (instance->fw_supported_vd_count)))\n\t\t\tbreak;\n\n\t\tmemset(instance->ld_ids, 0xff, MEGASAS_MAX_LD_IDS);\n\t\tfor (ld_index = 0; ld_index < tgtid_count; ld_index++) {\n\t\t\tids = ci->targetId[ld_index];\n\t\t\tinstance->ld_ids[ids] = ci->targetId[ld_index];\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tif (ret != DCMD_TIMEOUT)\n\t\tmegasas_return_cmd(instance, cmd);\n\n\treturn ret;\n}\n", "target": 0, "idx": 90374}
{"func": "char *path_name(const struct name_path *path, const char *name)\n{\n\tconst struct name_path *p;\n\tchar *n, *m;\n\tint nlen = strlen(name);\n\tint len = nlen + 1;\n\n\tfor (p = path; p; p = p->up) {\n\t\tif (p->elem_len)\n\t\t\tlen += p->elem_len + 1;\n \t}\n \tn = xmalloc(len);\n \tm = n + len - (nlen + 1);\n\tstrcpy(m, name);\n \tfor (p = path; p; p = p->up) {\n \t\tif (p->elem_len) {\n \t\t\tm -= p->elem_len + 1;\n\t\t\tmemcpy(m, p->elem, p->elem_len);\n\t\t\tm[p->elem_len] = '/';\n\t\t}\n\t}\n\treturn n;\n}\n", "target": 1, "idx": 180601}
{"func": "static int ssh_channelcmp(void *av, void *bv)\n{\n    struct ssh_channel *a = (struct ssh_channel *) av;\n    struct ssh_channel *b = (struct ssh_channel *) bv;\n    if (a->localid < b->localid)\n\treturn -1;\n    if (a->localid > b->localid)\n\treturn +1;\n    return 0;\n}\n", "target": 0, "idx": 8554}
{"func": "jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)\n{\n\tjas_image_t *image;\n\tbmp_hdr_t hdr;\n\tbmp_info_t *info;\n\tuint_fast16_t cmptno;\n\tjas_image_cmptparm_t cmptparms[3];\n\tjas_image_cmptparm_t *cmptparm;\n \tuint_fast16_t numcmpts;\n \tlong n;\n \n \tif (optstr) {\n \t\tjas_eprintf(\"warning: ignoring BMP decoder options\\n\");\n \t}\n\n\tjas_eprintf(\n\t  \"THE BMP FORMAT IS NOT FULLY SUPPORTED!\\n\"\n\t  \"THAT IS, THE JASPER SOFTWARE CANNOT DECODE ALL TYPES OF BMP DATA.\\n\"\n\t  \"IF YOU HAVE ANY PROBLEMS, PLEASE TRY CONVERTING YOUR IMAGE DATA\\n\"\n\t  \"TO THE PNM FORMAT, AND USING THIS FORMAT INSTEAD.\\n\"\n\t  );\n\n \t/* Read the bitmap header. */\n \tif (bmp_gethdr(in, &hdr)) {\n \t\tjas_eprintf(\"cannot get header\\n\");\n\t\treturn 0;\n \t}\n \tJAS_DBGLOG(1, (\n \t  \"BMP header: magic 0x%x; siz %d; res1 %d; res2 %d; off %d\\n\",\n\t  hdr.magic, hdr.siz, hdr.reserved1, hdr.reserved2, hdr.off\n\t  ));\n\n \t/* Read the bitmap information. */\n \tif (!(info = bmp_getinfo(in))) {\n \t\tjas_eprintf(\"cannot get info\\n\");\n\t\treturn 0;\n \t}\n \tJAS_DBGLOG(1,\n\t  (\"BMP information: len %d; width %d; height %d; numplanes %d; \"\n\t  \"depth %d; enctype %d; siz %d; hres %d; vres %d; numcolors %d; \"\n\t  \"mincolors %d\\n\", info->len, info->width, info->height, info->numplanes,\n\t  info->depth, info->enctype, info->siz, info->hres, info->vres,\n\t  info->numcolors, info->mincolors));\n \n \t/* Ensure that we support this type of BMP file. */\n \tif (!bmp_issupported(&hdr, info)) {\n \t\tjas_eprintf(\"error: unsupported BMP encoding\\n\");\n\t\tbmp_info_destroy(info);\n\t\treturn 0;\n \t}\n \n \t/* Skip over any useless data between the end of the palette\n \t  and start of the bitmap data. */\n \tif ((n = hdr.off - (BMP_HDRLEN + BMP_INFOLEN + BMP_PALLEN(info))) < 0) {\n \t\tjas_eprintf(\"error: possibly bad bitmap offset?\\n\");\n\t\treturn 0;\n \t}\n \tif (n > 0) {\n \t\tjas_eprintf(\"skipping unknown data in BMP file\\n\");\n \t\tif (bmp_gobble(in, n)) {\n\t\t\tbmp_info_destroy(info);\n\t\t\treturn 0;\n \t\t}\n \t}\n \n\t/* Get the number of components. */\n\tnumcmpts = bmp_numcmpts(info);\n\n\tfor (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,\n\t  ++cmptparm) {\n\t\tcmptparm->tlx = 0;\n\t\tcmptparm->tly = 0;\n\t\tcmptparm->hstep = 1;\n\t\tcmptparm->vstep = 1;\n\t\tcmptparm->width = info->width;\n\t\tcmptparm->height = info->height;\n\t\tcmptparm->prec = 8;\n\t\tcmptparm->sgnd = false;\n\t}\n\n \t/* Create image object. */\n \tif (!(image = jas_image_create(numcmpts, cmptparms,\n \t  JAS_CLRSPC_UNKNOWN))) {\n\t\tbmp_info_destroy(info);\n\t\treturn 0;\n \t}\n \n \tif (numcmpts == 3) {\n\t\tjas_image_setclrspc(image, JAS_CLRSPC_SRGB);\n\t\tjas_image_setcmpttype(image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R));\n\t\tjas_image_setcmpttype(image, 1,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G));\n\t\tjas_image_setcmpttype(image, 2,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B));\n\t} else {\n\t\tjas_image_setclrspc(image, JAS_CLRSPC_SGRAY);\n\t\tjas_image_setcmpttype(image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y));\n\t}\n \n \t/* Read the bitmap data. */\n \tif (bmp_getdata(in, info, image)) {\n\t\tbmp_info_destroy(info);\n\t\tjas_image_destroy(image);\n\t\treturn 0;\n \t}\n \n \tbmp_info_destroy(info);\n \n \treturn image;\n }\n", "target": 1, "idx": 181928}
{"func": "cJSON *cJSON_DetachItemFromArray( cJSON *array, int which )\n{\n\tcJSON *c = array->child;\n\twhile ( c && which > 0 ) {\n\t\tc = c->next;\n\t\t--which;\n\t}\n\tif ( ! c )\n\t\treturn 0;\n\tif ( c->prev )\n\t\tc->prev->next = c->next;\n\tif ( c->next ) c->next->prev = c->prev;\n\tif ( c == array->child )\n\t\tarray->child = c->next;\n\tc->prev = c->next = 0;\n\treturn c;\n}\n", "target": 1, "idx": 180456}
{"func": "process_pa_data_to_key(krb5_context context,\n\t\t       krb5_get_init_creds_ctx *ctx,\n\t\t       krb5_creds *creds,\n\t\t       AS_REQ *a,\n\t\t       AS_REP *rep,\n\t\t       const krb5_krbhst_info *hi,\n\t\t       krb5_keyblock **key)\n{\n    struct pa_info_data paid, *ppaid = NULL;\n    krb5_error_code ret;\n    krb5_enctype etype;\n    PA_DATA *pa;\n\n    memset(&paid, 0, sizeof(paid));\n\n    etype = rep->enc_part.etype;\n\n    if (rep->padata) {\n\tpaid.etype = etype;\n\tppaid = process_pa_info(context, creds->client, a, &paid,\n\t\t\t\trep->padata);\n    }\n    if (ppaid == NULL)\n\tppaid = ctx->ppaid;\n    if (ppaid == NULL) {\n\tret = krb5_get_pw_salt (context, creds->client, &paid.salt);\n\tif (ret)\n\t    return ret;\n\tpaid.etype = etype;\n\tpaid.s2kparams = NULL;\n\tppaid = &paid;\n    }\n\n    pa = NULL;\n    if (rep->padata) {\n\tint idx = 0;\n\tpa = krb5_find_padata(rep->padata->val,\n\t\t\t      rep->padata->len,\n\t\t\t      KRB5_PADATA_PK_AS_REP,\n\t\t\t      &idx);\n\tif (pa == NULL) {\n\t    idx = 0;\n\t    pa = krb5_find_padata(rep->padata->val,\n\t\t\t\t  rep->padata->len,\n\t\t\t\t  KRB5_PADATA_PK_AS_REP_19,\n\t\t\t\t  &idx);\n\t}\n    }\n    if (pa && ctx->pk_init_ctx) {\n#ifdef PKINIT\n\t_krb5_debug(context, 5, \"krb5_get_init_creds: using PKINIT\");\n\n\tret = _krb5_pk_rd_pa_reply(context,\n\t\t\t\t   a->req_body.realm,\n\t\t\t\t   ctx->pk_init_ctx,\n\t\t\t\t   etype,\n\t\t\t\t   hi,\n\t\t\t\t   ctx->pk_nonce,\n\t\t\t\t   &ctx->req_buffer,\n\t\t\t\t   pa,\n\t\t\t\t   key);\n#else\n\tret = EINVAL;\n\tkrb5_set_error_message(context, ret, N_(\"no support for PKINIT compiled in\", \"\"));\n#endif\n    } else if (ctx->keyseed) {\n \t_krb5_debug(context, 5, \"krb5_get_init_creds: using keyproc\");\n\tret = pa_data_to_key_plain(context, creds->client, ctx,\n\t\t\t\t   ppaid->salt, ppaid->s2kparams, etype, key);\n    } else {\n\tret = EINVAL;\n\tkrb5_set_error_message(context, ret, N_(\"No usable pa data type\", \"\"));\n    }\n\n    free_paid(context, &paid);\n    return ret;\n}\n", "target": 0, "idx": 89941}
{"func": "static void spl_filesystem_object_free_storage(void *object TSRMLS_DC) /* {{{ */\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)object;\n\n \tif (intern->oth_handler && intern->oth_handler->dtor) {\n \t\tintern->oth_handler->dtor(intern TSRMLS_CC);\n \t}\n \tzend_object_std_dtor(&intern->std TSRMLS_CC);\n \tif (intern->_path) {\n \t\tefree(intern->_path);\n \t}\n\tif (intern->file_name) {\n\t\tefree(intern->file_name);\n\t}\n\tswitch(intern->type) {\n\tcase SPL_FS_INFO:\n\t\tbreak;\n\tcase SPL_FS_DIR:\n\t\tif (intern->u.dir.dirp) {\n\t\t\tphp_stream_close(intern->u.dir.dirp);\n\t\t\tintern->u.dir.dirp = NULL;\n \t\t}\n \t\tif (intern->u.dir.sub_path) {\n \t\t\tefree(intern->u.dir.sub_path);\n\t\t}\t\t\n \t\tbreak;\n \tcase SPL_FS_FILE:\n \t\tif (intern->u.file.stream) {\n\t\t\tif (intern->u.file.zcontext) {\n/*\t\t\t\tzend_list_delref(Z_RESVAL_P(intern->zcontext));*/\n\t\t\t}\n\t\t\tif (!intern->u.file.stream->is_persistent) {\n\t\t\t\tphp_stream_free(intern->u.file.stream, PHP_STREAM_FREE_CLOSE);\n\t\t\t} else {\n\t\t\t\tphp_stream_free(intern->u.file.stream, PHP_STREAM_FREE_CLOSE_PERSISTENT);\n\t\t\t}\n\t\t\tif (intern->u.file.open_mode) {\n\t\t\t\tefree(intern->u.file.open_mode);\n\t\t\t}\n\t\t\tif (intern->orig_path) {\n\t\t\t\tefree(intern->orig_path);\n\t\t\t}\n\t\t}\n\t\tspl_filesystem_file_free_line(intern TSRMLS_CC);\n\t\tbreak;\n\t}\n\n\t{\n\t\tzend_object_iterator *iterator;\n\t\titerator = (zend_object_iterator*)\n\t\t\t\tspl_filesystem_object_to_iterator(intern);\n\t\tif (iterator->data != NULL) {\n\t\t\titerator->data = NULL;\n\t\t\titerator->funcs->dtor(iterator TSRMLS_CC);\n\t\t}\n\t}\n\tefree(object);\n } /* }}} */\n", "target": 1, "idx": 180255}
{"func": "XGetDeviceControl(\n    register Display\t*dpy,\n    XDevice\t\t*dev,\n    int\t\t\t control)\n{\n    XDeviceControl *Device = NULL;\n    XDeviceControl *Sav = NULL;\n    xDeviceState *d = NULL;\n    xDeviceState *sav = NULL;\n    xGetDeviceControlReq *req;\n    xGetDeviceControlReply rep;\n    XExtDisplayInfo *info = XInput_find_display(dpy);\n\n    LockDisplay(dpy);\n    if (_XiCheckExtInit(dpy, XInput_Add_XChangeDeviceControl, info) == -1)\n        return NULL;\n\n    GetReq(GetDeviceControl, req);\n    req->reqType = info->codes->major_opcode;\n    req->ReqType = X_GetDeviceControl;\n    req->deviceid = dev->device_id;\n    req->control = control;\n\n    if (!_XReply(dpy, (xReply *) & rep, 0, xFalse))\n\tgoto out;\n\n     if (rep.length > 0) {\n \tunsigned long nbytes;\n \tsize_t size = 0;\n\tif (rep.length < (INT_MAX >> 2)) {\n \t    nbytes = (unsigned long) rep.length << 2;\n \t    d = Xmalloc(nbytes);\n \t}\n\t    _XEatDataWords(dpy, rep.length);\n\t    goto out;\n\t}\n\tsav = d;\n\t_XRead(dpy, (char *)d, nbytes);\n\n        /* In theory, we should just be able to use d->length to get the size.\n         * Turns out that a number of X servers (up to and including server\n         * 1.4) sent the wrong length value down the wire. So to not break\n         * apps that run against older servers, we have to calculate the size\n         * manually.\n         */\n\tswitch (d->control) {\n\tcase DEVICE_RESOLUTION:\n\t{\n\t    xDeviceResolutionState *r;\n\t    size_t val_size;\n \t    size_t val_size;\n \n \t    r = (xDeviceResolutionState *) d;\n\t    if (r->num_valuators >= (INT_MAX / (3 * sizeof(int))))\n \t\tgoto out;\n \t    val_size = 3 * sizeof(int) * r->num_valuators;\n \t    if ((sizeof(xDeviceResolutionState) + val_size) > nbytes)\n\t    break;\n\t}\n        case DEVICE_ABS_CALIB:\n        {\n            if (sizeof(xDeviceAbsCalibState) > nbytes)\n                goto out;\n            size = sizeof(XDeviceAbsCalibState);\n            break;\n        }\n        case DEVICE_ABS_AREA:\n        {\n            if (sizeof(xDeviceAbsAreaState) > nbytes)\n                goto out;\n            size = sizeof(XDeviceAbsAreaState);\n            break;\n        }\n        case DEVICE_CORE:\n        {\n            if (sizeof(xDeviceCoreState) > nbytes)\n                goto out;\n            size = sizeof(XDeviceCoreState);\n            break;\n        }\n\tdefault:\n\t    if (d->length > nbytes)\n\t\tgoto out;\n\t    size = d->length;\n\t    break;\n\t}\n\n\tDevice = Xmalloc(size);\n\tif (!Device)\n\t    goto out;\n\n\tSav = Device;\n\n\td = sav;\n\tswitch (control) {\n\tcase DEVICE_RESOLUTION:\n\t{\n\t    int *iptr, *iptr2;\n\t    xDeviceResolutionState *r;\n\t    XDeviceResolutionState *R;\n\t    unsigned int i;\n\n\t    r = (xDeviceResolutionState *) d;\n\t    R = (XDeviceResolutionState *) Device;\n\n\t    R->control = DEVICE_RESOLUTION;\n\t    R->length = sizeof(XDeviceResolutionState);\n\t    R->num_valuators = r->num_valuators;\n\t    iptr = (int *)(R + 1);\n\t    iptr2 = (int *)(r + 1);\n\t    R->resolutions = iptr;\n\t    R->min_resolutions = iptr + R->num_valuators;\n\t    R->max_resolutions = iptr + (2 * R->num_valuators);\n\t    for (i = 0; i < (3 * R->num_valuators); i++)\n\t\t*iptr++ = *iptr2++;\n\t    break;\n\t}\n        case DEVICE_ABS_CALIB:\n        {\n            xDeviceAbsCalibState *c = (xDeviceAbsCalibState *) d;\n            XDeviceAbsCalibState *C = (XDeviceAbsCalibState *) Device;\n\n            C->control = DEVICE_ABS_CALIB;\n            C->length = sizeof(XDeviceAbsCalibState);\n            C->min_x = c->min_x;\n            C->max_x = c->max_x;\n            C->min_y = c->min_y;\n            C->max_y = c->max_y;\n            C->flip_x = c->flip_x;\n            C->flip_y = c->flip_y;\n            C->rotation = c->rotation;\n            C->button_threshold = c->button_threshold;\n\n            break;\n        }\n        case DEVICE_ABS_AREA:\n        {\n            xDeviceAbsAreaState *a = (xDeviceAbsAreaState *) d;\n            XDeviceAbsAreaState *A = (XDeviceAbsAreaState *) Device;\n\n            A->control = DEVICE_ABS_AREA;\n            A->length = sizeof(XDeviceAbsAreaState);\n            A->offset_x = a->offset_x;\n            A->offset_y = a->offset_y;\n            A->width = a->width;\n            A->height = a->height;\n            A->screen = a->screen;\n            A->following = a->following;\n\n            break;\n        }\n        case DEVICE_CORE:\n        {\n            xDeviceCoreState *c = (xDeviceCoreState *) d;\n            XDeviceCoreState *C = (XDeviceCoreState *) Device;\n\n            C->control = DEVICE_CORE;\n            C->length = sizeof(XDeviceCoreState);\n            C->status = c->status;\n            C->iscore = c->iscore;\n\n            break;\n        }\n        case DEVICE_ENABLE:\n        {\n            xDeviceEnableState *e = (xDeviceEnableState *) d;\n            XDeviceEnableState *E = (XDeviceEnableState *) Device;\n\n            E->control = DEVICE_ENABLE;\n            E->length = sizeof(E);\n            E->enable = e->enable;\n\n            break;\n        }\n\tdefault:\n\t    break;\n\t}\n    }\n", "target": 1, "idx": 178090}
{"func": "void WebContentsImpl::OnDidDownloadImage(\n    int id,\n    int http_status_code,\n    const GURL& image_url,\n    int requested_size,\n    const std::vector<SkBitmap>& bitmaps) {\n  ImageDownloadMap::iterator iter = image_download_map_.find(id);\n  if (iter == image_download_map_.end()) {\n    return;\n  }\n  if (!iter->second.is_null()) {\n    iter->second.Run(id, http_status_code, image_url, requested_size, bitmaps);\n  }\n  image_download_map_.erase(id);\n}\n", "target": 0, "idx": 119852}
{"func": "static int start_decoder(vorb *f)\n{\n   uint8 header[6], x,y;\n   int len,i,j,k, max_submaps = 0;\n   int longest_floorlist=0;\n\n\n   if (!start_page(f))                              return FALSE;\n   if (!(f->page_flag & PAGEFLAG_first_page))       return error(f, VORBIS_invalid_first_page);\n   if (f->page_flag & PAGEFLAG_last_page)           return error(f, VORBIS_invalid_first_page);\n   if (f->page_flag & PAGEFLAG_continued_packet)    return error(f, VORBIS_invalid_first_page);\n   if (f->segment_count != 1)                       return error(f, VORBIS_invalid_first_page);\n   if (f->segments[0] != 30)                        return error(f, VORBIS_invalid_first_page);\n   if (get8(f) != VORBIS_packet_id)                 return error(f, VORBIS_invalid_first_page);\n   if (!getn(f, header, 6))                         return error(f, VORBIS_unexpected_eof);\n   if (!vorbis_validate(header))                    return error(f, VORBIS_invalid_first_page);\n   if (get32(f) != 0)                               return error(f, VORBIS_invalid_first_page);\n   f->channels = get8(f); if (!f->channels)         return error(f, VORBIS_invalid_first_page);\n   if (f->channels > STB_VORBIS_MAX_CHANNELS)       return error(f, VORBIS_too_many_channels);\n   f->sample_rate = get32(f); if (!f->sample_rate)  return error(f, VORBIS_invalid_first_page);\n   get32(f); // bitrate_maximum\n   get32(f); // bitrate_nominal\n   get32(f); // bitrate_minimum\n   x = get8(f);\n   {\n      int log0,log1;\n      log0 = x & 15;\n      log1 = x >> 4;\n      f->blocksize_0 = 1 << log0;\n      f->blocksize_1 = 1 << log1;\n      if (log0 < 6 || log0 > 13)                       return error(f, VORBIS_invalid_setup);\n      if (log1 < 6 || log1 > 13)                       return error(f, VORBIS_invalid_setup);\n      if (log0 > log1)                                 return error(f, VORBIS_invalid_setup);\n   }\n\n   x = get8(f);\n   if (!(x & 1))                                    return error(f, VORBIS_invalid_first_page);\n\n   if (!start_page(f))                              return FALSE;\n\n   if (!start_packet(f))                            return FALSE;\n   do {\n      len = next_segment(f);\n      skip(f, len);\n      f->bytes_in_seg = 0;\n   } while (len);\n\n   if (!start_packet(f))                            return FALSE;\n\n   #ifndef STB_VORBIS_NO_PUSHDATA_API\n   if (IS_PUSH_MODE(f)) {\n      if (!is_whole_packet_present(f, TRUE)) {\n         if (f->error == VORBIS_invalid_stream)\n            f->error = VORBIS_invalid_setup;\n         return FALSE;\n      }\n   }\n   #endif\n\n   crc32_init(); // always init it, to avoid multithread race conditions\n\n   if (get8_packet(f) != VORBIS_packet_setup)       return error(f, VORBIS_invalid_setup);\n   for (i=0; i < 6; ++i) header[i] = get8_packet(f);\n   if (!vorbis_validate(header))                    return error(f, VORBIS_invalid_setup);\n\n\n   f->codebook_count = get_bits(f,8) + 1;\n   f->codebooks = (Codebook *) setup_malloc(f, sizeof(*f->codebooks) * f->codebook_count);\n   if (f->codebooks == NULL)                        return error(f, VORBIS_outofmem);\n   memset(f->codebooks, 0, sizeof(*f->codebooks) * f->codebook_count);\n   for (i=0; i < f->codebook_count; ++i) {\n      uint32 *values;\n      int ordered, sorted_count;\n      int total=0;\n      uint8 *lengths;\n      Codebook *c = f->codebooks+i;\n      CHECK(f);\n      x = get_bits(f, 8); if (x != 0x42)            return error(f, VORBIS_invalid_setup);\n      x = get_bits(f, 8); if (x != 0x43)            return error(f, VORBIS_invalid_setup);\n      x = get_bits(f, 8); if (x != 0x56)            return error(f, VORBIS_invalid_setup);\n      x = get_bits(f, 8);\n      c->dimensions = (get_bits(f, 8)<<8) + x;\n      x = get_bits(f, 8);\n      y = get_bits(f, 8);\n      c->entries = (get_bits(f, 8)<<16) + (y<<8) + x;\n      ordered = get_bits(f,1);\n      c->sparse = ordered ? 0 : get_bits(f,1);\n\n      if (c->dimensions == 0 && c->entries != 0)    return error(f, VORBIS_invalid_setup);\n\n      if (c->sparse)\n         lengths = (uint8 *) setup_temp_malloc(f, c->entries);\n      else\n         lengths = c->codeword_lengths = (uint8 *) setup_malloc(f, c->entries);\n\n      if (!lengths) return error(f, VORBIS_outofmem);\n\n      if (ordered) {\n         int current_entry = 0;\n         int current_length = get_bits(f,5) + 1;\n         while (current_entry < c->entries) {\n            int limit = c->entries - current_entry;\n            int n = get_bits(f, ilog(limit));\n            if (current_entry + n > (int) c->entries) { return error(f, VORBIS_invalid_setup); }\n            memset(lengths + current_entry, current_length, n);\n            current_entry += n;\n            ++current_length;\n         }\n      } else {\n         for (j=0; j < c->entries; ++j) {\n            int present = c->sparse ? get_bits(f,1) : 1;\n            if (present) {\n               lengths[j] = get_bits(f, 5) + 1;\n               ++total;\n               if (lengths[j] == 32)\n                  return error(f, VORBIS_invalid_setup);\n            } else {\n               lengths[j] = NO_CODE;\n            }\n         }\n      }\n\n      if (c->sparse && total >= c->entries >> 2) {\n         if (c->entries > (int) f->setup_temp_memory_required)\n            f->setup_temp_memory_required = c->entries;\n\n         c->codeword_lengths = (uint8 *) setup_malloc(f, c->entries);\n         if (c->codeword_lengths == NULL) return error(f, VORBIS_outofmem);\n         memcpy(c->codeword_lengths, lengths, c->entries);\n         setup_temp_free(f, lengths, c->entries); // note this is only safe if there have been no intervening temp mallocs!\n         lengths = c->codeword_lengths;\n         c->sparse = 0;\n      }\n\n      if (c->sparse) {\n         sorted_count = total;\n      } else {\n         sorted_count = 0;\n         #ifndef STB_VORBIS_NO_HUFFMAN_BINARY_SEARCH\n         for (j=0; j < c->entries; ++j)\n            if (lengths[j] > STB_VORBIS_FAST_HUFFMAN_LENGTH && lengths[j] != NO_CODE)\n               ++sorted_count;\n         #endif\n      }\n\n      c->sorted_entries = sorted_count;\n      values = NULL;\n\n      CHECK(f);\n      if (!c->sparse) {\n         c->codewords = (uint32 *) setup_malloc(f, sizeof(c->codewords[0]) * c->entries);\n         if (!c->codewords)                  return error(f, VORBIS_outofmem);\n      } else {\n         unsigned int size;\n         if (c->sorted_entries) {\n            c->codeword_lengths = (uint8 *) setup_malloc(f, c->sorted_entries);\n            if (!c->codeword_lengths)           return error(f, VORBIS_outofmem);\n            c->codewords = (uint32 *) setup_temp_malloc(f, sizeof(*c->codewords) * c->sorted_entries);\n            if (!c->codewords)                  return error(f, VORBIS_outofmem);\n            values = (uint32 *) setup_temp_malloc(f, sizeof(*values) * c->sorted_entries);\n            if (!values)                        return error(f, VORBIS_outofmem);\n         }\n         size = c->entries + (sizeof(*c->codewords) + sizeof(*values)) * c->sorted_entries;\n         if (size > f->setup_temp_memory_required)\n            f->setup_temp_memory_required = size;\n      }\n\n      if (!compute_codewords(c, lengths, c->entries, values)) {\n         if (c->sparse) setup_temp_free(f, values, 0);\n         return error(f, VORBIS_invalid_setup);\n      }\n\n      if (c->sorted_entries) {\n         c->sorted_codewords = (uint32 *) setup_malloc(f, sizeof(*c->sorted_codewords) * (c->sorted_entries+1));\n         if (c->sorted_codewords == NULL) return error(f, VORBIS_outofmem);\n         c->sorted_values    = ( int   *) setup_malloc(f, sizeof(*c->sorted_values   ) * (c->sorted_entries+1));\n         if (c->sorted_values == NULL) return error(f, VORBIS_outofmem);\n         ++c->sorted_values;\n         c->sorted_values[-1] = -1;\n         compute_sorted_huffman(c, lengths, values);\n      }\n\n      if (c->sparse) {\n         setup_temp_free(f, values, sizeof(*values)*c->sorted_entries);\n         setup_temp_free(f, c->codewords, sizeof(*c->codewords)*c->sorted_entries);\n         setup_temp_free(f, lengths, c->entries);\n         c->codewords = NULL;\n      }\n\n      compute_accelerated_huffman(c);\n\n      CHECK(f);\n      c->lookup_type = get_bits(f, 4);\n      if (c->lookup_type > 2) return error(f, VORBIS_invalid_setup);\n      if (c->lookup_type > 0) {\n         uint16 *mults;\n         c->minimum_value = float32_unpack(get_bits(f, 32));\n         c->delta_value = float32_unpack(get_bits(f, 32));\n         c->value_bits = get_bits(f, 4)+1;\n         c->sequence_p = get_bits(f,1);\n         if (c->lookup_type == 1) {\n            c->lookup_values = lookup1_values(c->entries, c->dimensions);\n         } else {\n            c->lookup_values = c->entries * c->dimensions;\n         }\n         if (c->lookup_values == 0) return error(f, VORBIS_invalid_setup);\n         mults = (uint16 *) setup_temp_malloc(f, sizeof(mults[0]) * c->lookup_values);\n         if (mults == NULL) return error(f, VORBIS_outofmem);\n         for (j=0; j < (int) c->lookup_values; ++j) {\n            int q = get_bits(f, c->value_bits);\n            if (q == EOP) { setup_temp_free(f,mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_invalid_setup); }\n            mults[j] = q;\n         }\n\n#ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK\n         if (c->lookup_type == 1) {\n            int len, sparse = c->sparse;\n            float last=0;\n            if (sparse) {\n               if (c->sorted_entries == 0) goto skip;\n               c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->sorted_entries * c->dimensions);\n            } else\n               c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->entries        * c->dimensions);\n            if (c->multiplicands == NULL) { setup_temp_free(f,mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_outofmem); }\n            len = sparse ? c->sorted_entries : c->entries;\n            for (j=0; j < len; ++j) {\n               unsigned int z = sparse ? c->sorted_values[j] : j;\n               unsigned int div=1;\n               for (k=0; k < c->dimensions; ++k) {\n                  int off = (z / div) % c->lookup_values;\n                  float val = mults[off];\n                  val = mults[off]*c->delta_value + c->minimum_value + last;\n                  c->multiplicands[j*c->dimensions + k] = val;\n                  if (c->sequence_p)\n                     last = val;\n                  if (k+1 < c->dimensions) {\n                     if (div > UINT_MAX / (unsigned int) c->lookup_values) {\n                        setup_temp_free(f, mults,sizeof(mults[0])*c->lookup_values);\n                        return error(f, VORBIS_invalid_setup);\n                     }\n                     div *= c->lookup_values;\n                  }\n               }\n            }\n            c->lookup_type = 2;\n         }\n         else\n#endif\n         {\n            float last=0;\n            CHECK(f);\n            c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->lookup_values);\n            if (c->multiplicands == NULL) { setup_temp_free(f, mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_outofmem); }\n            for (j=0; j < (int) c->lookup_values; ++j) {\n               float val = mults[j] * c->delta_value + c->minimum_value + last;\n               c->multiplicands[j] = val;\n               if (c->sequence_p)\n                  last = val;\n            }\n         }\n#ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK\n        skip:;\n#endif\n         setup_temp_free(f, mults, sizeof(mults[0])*c->lookup_values);\n\n         CHECK(f);\n      }\n      CHECK(f);\n   }\n\n\n   x = get_bits(f, 6) + 1;\n   for (i=0; i < x; ++i) {\n      uint32 z = get_bits(f, 16);\n      if (z != 0) return error(f, VORBIS_invalid_setup);\n   }\n\n   f->floor_count = get_bits(f, 6)+1;\n   f->floor_config = (Floor *)  setup_malloc(f, f->floor_count * sizeof(*f->floor_config));\n   if (f->floor_config == NULL) return error(f, VORBIS_outofmem);\n   for (i=0; i < f->floor_count; ++i) {\n      f->floor_types[i] = get_bits(f, 16);\n      if (f->floor_types[i] > 1) return error(f, VORBIS_invalid_setup);\n      if (f->floor_types[i] == 0) {\n         Floor0 *g = &f->floor_config[i].floor0;\n         g->order = get_bits(f,8);\n         g->rate = get_bits(f,16);\n         g->bark_map_size = get_bits(f,16);\n         g->amplitude_bits = get_bits(f,6);\n         g->amplitude_offset = get_bits(f,8);\n         g->number_of_books = get_bits(f,4) + 1;\n         for (j=0; j < g->number_of_books; ++j)\n            g->book_list[j] = get_bits(f,8);\n         return error(f, VORBIS_feature_not_supported);\n      } else {\n         stbv__floor_ordering p[31*8+2];\n         Floor1 *g = &f->floor_config[i].floor1;\n         int max_class = -1; \n         g->partitions = get_bits(f, 5);\n         for (j=0; j < g->partitions; ++j) {\n            g->partition_class_list[j] = get_bits(f, 4);\n            if (g->partition_class_list[j] > max_class)\n               max_class = g->partition_class_list[j];\n         }\n         for (j=0; j <= max_class; ++j) {\n            g->class_dimensions[j] = get_bits(f, 3)+1;\n            g->class_subclasses[j] = get_bits(f, 2);\n            if (g->class_subclasses[j]) {\n               g->class_masterbooks[j] = get_bits(f, 8);\n               if (g->class_masterbooks[j] >= f->codebook_count) return error(f, VORBIS_invalid_setup);\n            }\n            for (k=0; k < 1 << g->class_subclasses[j]; ++k) {\n               g->subclass_books[j][k] = get_bits(f,8)-1;\n               if (g->subclass_books[j][k] >= f->codebook_count) return error(f, VORBIS_invalid_setup);\n            }\n         }\n         g->floor1_multiplier = get_bits(f,2)+1;\n         g->rangebits = get_bits(f,4);\n         g->Xlist[0] = 0;\n         g->Xlist[1] = 1 << g->rangebits;\n         g->values = 2;\n         for (j=0; j < g->partitions; ++j) {\n            int c = g->partition_class_list[j];\n            for (k=0; k < g->class_dimensions[c]; ++k) {\n               g->Xlist[g->values] = get_bits(f, g->rangebits);\n               ++g->values;\n            }\n         }\n         for (j=0; j < g->values; ++j) {\n            p[j].x = g->Xlist[j];\n            p[j].id = j;\n         }\n         qsort(p, g->values, sizeof(p[0]), point_compare);\n         for (j=0; j < g->values; ++j)\n            g->sorted_order[j] = (uint8) p[j].id;\n         for (j=2; j < g->values; ++j) {\n            int low,hi;\n            neighbors(g->Xlist, j, &low,&hi);\n            g->neighbors[j][0] = low;\n            g->neighbors[j][1] = hi;\n         }\n\n         if (g->values > longest_floorlist)\n            longest_floorlist = g->values;\n      }\n   }\n\n   f->residue_count = get_bits(f, 6)+1;\n   f->residue_config = (Residue *) setup_malloc(f, f->residue_count * sizeof(f->residue_config[0]));\n   if (f->residue_config == NULL) return error(f, VORBIS_outofmem);\n   memset(f->residue_config, 0, f->residue_count * sizeof(f->residue_config[0]));\n   for (i=0; i < f->residue_count; ++i) {\n      uint8 residue_cascade[64];\n      Residue *r = f->residue_config+i;\n      f->residue_types[i] = get_bits(f, 16);\n      if (f->residue_types[i] > 2) return error(f, VORBIS_invalid_setup);\n      r->begin = get_bits(f, 24);\n      r->end = get_bits(f, 24);\n      if (r->end < r->begin) return error(f, VORBIS_invalid_setup);\n      r->part_size = get_bits(f,24)+1;\n      r->classifications = get_bits(f,6)+1;\n      r->classbook = get_bits(f,8);\n      if (r->classbook >= f->codebook_count) return error(f, VORBIS_invalid_setup);\n      for (j=0; j < r->classifications; ++j) {\n         uint8 high_bits=0;\n         uint8 low_bits=get_bits(f,3);\n         if (get_bits(f,1))\n            high_bits = get_bits(f,5);\n         residue_cascade[j] = high_bits*8 + low_bits;\n      }\n      r->residue_books = (short (*)[8]) setup_malloc(f, sizeof(r->residue_books[0]) * r->classifications);\n      if (r->residue_books == NULL) return error(f, VORBIS_outofmem);\n      for (j=0; j < r->classifications; ++j) {\n         for (k=0; k < 8; ++k) {\n            if (residue_cascade[j] & (1 << k)) {\n               r->residue_books[j][k] = get_bits(f, 8);\n               if (r->residue_books[j][k] >= f->codebook_count) return error(f, VORBIS_invalid_setup);\n            } else {\n               r->residue_books[j][k] = -1;\n            }\n         }\n      }\n      r->classdata = (uint8 **) setup_malloc(f, sizeof(*r->classdata) * f->codebooks[r->classbook].entries);\n      if (!r->classdata) return error(f, VORBIS_outofmem);\n      memset(r->classdata, 0, sizeof(*r->classdata) * f->codebooks[r->classbook].entries);\n      for (j=0; j < f->codebooks[r->classbook].entries; ++j) {\n         int classwords = f->codebooks[r->classbook].dimensions;\n         int temp = j;\n         r->classdata[j] = (uint8 *) setup_malloc(f, sizeof(r->classdata[j][0]) * classwords);\n         if (r->classdata[j] == NULL) return error(f, VORBIS_outofmem);\n         for (k=classwords-1; k >= 0; --k) {\n            r->classdata[j][k] = temp % r->classifications;\n            temp /= r->classifications;\n         }\n      }\n   }\n\n   f->mapping_count = get_bits(f,6)+1;\n   f->mapping = (Mapping *) setup_malloc(f, f->mapping_count * sizeof(*f->mapping));\n   if (f->mapping == NULL) return error(f, VORBIS_outofmem);\n   memset(f->mapping, 0, f->mapping_count * sizeof(*f->mapping));\n   for (i=0; i < f->mapping_count; ++i) {\n      Mapping *m = f->mapping + i;      \n      int mapping_type = get_bits(f,16);\n      if (mapping_type != 0) return error(f, VORBIS_invalid_setup);\n      m->chan = (MappingChannel *) setup_malloc(f, f->channels * sizeof(*m->chan));\n      if (m->chan == NULL) return error(f, VORBIS_outofmem);\n      if (get_bits(f,1))\n         m->submaps = get_bits(f,4)+1;\n      else\n         m->submaps = 1;\n      if (m->submaps > max_submaps)\n         max_submaps = m->submaps;\n      if (get_bits(f,1)) {\n         m->coupling_steps = get_bits(f,8)+1;\n         for (k=0; k < m->coupling_steps; ++k) {\n            m->chan[k].magnitude = get_bits(f, ilog(f->channels-1));\n            m->chan[k].angle = get_bits(f, ilog(f->channels-1));\n            if (m->chan[k].magnitude >= f->channels)        return error(f, VORBIS_invalid_setup);\n            if (m->chan[k].angle     >= f->channels)        return error(f, VORBIS_invalid_setup);\n            if (m->chan[k].magnitude == m->chan[k].angle)   return error(f, VORBIS_invalid_setup);\n         }\n      } else\n         m->coupling_steps = 0;\n\n      if (get_bits(f,2)) return error(f, VORBIS_invalid_setup);\n      if (m->submaps > 1) {\n         for (j=0; j < f->channels; ++j) {\n            m->chan[j].mux = get_bits(f, 4);\n            if (m->chan[j].mux >= m->submaps)                return error(f, VORBIS_invalid_setup);\n         }\n      } else\n         for (j=0; j < f->channels; ++j)\n            m->chan[j].mux = 0;\n\n      for (j=0; j < m->submaps; ++j) {\n         get_bits(f,8); // discard\n         m->submap_floor[j] = get_bits(f,8);\n         m->submap_residue[j] = get_bits(f,8);\n         if (m->submap_floor[j] >= f->floor_count)      return error(f, VORBIS_invalid_setup);\n         if (m->submap_residue[j] >= f->residue_count)  return error(f, VORBIS_invalid_setup);\n      }\n   }\n\n   f->mode_count = get_bits(f, 6)+1;\n   for (i=0; i < f->mode_count; ++i) {\n      Mode *m = f->mode_config+i;\n      m->blockflag = get_bits(f,1);\n      m->windowtype = get_bits(f,16);\n      m->transformtype = get_bits(f,16);\n      m->mapping = get_bits(f,8);\n      if (m->windowtype != 0)                 return error(f, VORBIS_invalid_setup);\n      if (m->transformtype != 0)              return error(f, VORBIS_invalid_setup);\n      if (m->mapping >= f->mapping_count)     return error(f, VORBIS_invalid_setup);\n   }\n\n   flush_packet(f);\n\n   f->previous_length = 0;\n\n   for (i=0; i < f->channels; ++i) {\n      f->channel_buffers[i] = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1);\n      f->previous_window[i] = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1/2);\n      f->finalY[i]          = (int16 *) setup_malloc(f, sizeof(int16) * longest_floorlist);\n      if (f->channel_buffers[i] == NULL || f->previous_window[i] == NULL || f->finalY[i] == NULL) return error(f, VORBIS_outofmem);\n      #ifdef STB_VORBIS_NO_DEFER_FLOOR\n      f->floor_buffers[i]   = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1/2);\n      if (f->floor_buffers[i] == NULL) return error(f, VORBIS_outofmem);\n      #endif\n   }\n\n   if (!init_blocksize(f, 0, f->blocksize_0)) return FALSE;\n   if (!init_blocksize(f, 1, f->blocksize_1)) return FALSE;\n   f->blocksize[0] = f->blocksize_0;\n   f->blocksize[1] = f->blocksize_1;\n\n#ifdef STB_VORBIS_DIVIDE_TABLE\n   if (integer_divide_table[1][1]==0)\n      for (i=0; i < DIVTAB_NUMER; ++i)\n         for (j=1; j < DIVTAB_DENOM; ++j)\n            integer_divide_table[i][j] = i / j;\n#endif\n\n\n   {\n      uint32 imdct_mem = (f->blocksize_1 * sizeof(float) >> 1);\n      uint32 classify_mem;\n       int i,max_part_read=0;\n       for (i=0; i < f->residue_count; ++i) {\n          Residue *r = f->residue_config + i;\n         int n_read = r->end - r->begin;\n          int part_read = n_read / r->part_size;\n          if (part_read > max_part_read)\n             max_part_read = part_read;\n      }\n      #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE\n      classify_mem = f->channels * (sizeof(void*) + max_part_read * sizeof(uint8 *));\n      #else\n       classify_mem = f->channels * (sizeof(void*) + max_part_read * sizeof(int *));\n       #endif\n \n       f->temp_memory_required = classify_mem;\n       if (imdct_mem > f->temp_memory_required)\n          f->temp_memory_required = imdct_mem;\n   }\n\n   f->first_decode = TRUE;\n\n   if (f->alloc.alloc_buffer) {\n      assert(f->temp_offset == f->alloc.alloc_buffer_length_in_bytes);\n      if (f->setup_offset + sizeof(*f) + f->temp_memory_required > (unsigned) f->temp_offset)\n         return error(f, VORBIS_outofmem);\n   }\n\n   f->first_audio_page_offset = stb_vorbis_get_file_offset(f);\n\n   return TRUE;\n}\n", "target": 1, "idx": 182117}
{"func": "OMX_ERRORTYPE omx_vdec::set_buffer_req(vdec_allocatorproperty *buffer_prop)\n{\n    OMX_ERRORTYPE eRet = OMX_ErrorNone;\n unsigned buf_size = 0;\n struct v4l2_format fmt;\n struct v4l2_requestbuffers bufreq;\n int ret;\n    DEBUG_PRINT_LOW(\"SetBufReq IN: ActCnt(%d) Size(%u)\",\n            buffer_prop->actualcount, (unsigned int)buffer_prop->buffer_size);\n    buf_size = (buffer_prop->buffer_size + buffer_prop->alignment - 1)&(~(buffer_prop->alignment - 1));\n if (buf_size != buffer_prop->buffer_size) {\n        DEBUG_PRINT_ERROR(\"Buffer size alignment error: Requested(%u) Required(%d)\",\n (unsigned int)buffer_prop->buffer_size, buf_size);\n        eRet = OMX_ErrorBadParameter;\n } else {\n        memset(&fmt, 0x0, sizeof(struct v4l2_format));\n        fmt.fmt.pix_mp.height = drv_ctx.video_resolution.frame_height;\n        fmt.fmt.pix_mp.width = drv_ctx.video_resolution.frame_width;\n\n if (buffer_prop->buffer_type == VDEC_BUFFER_TYPE_INPUT) {\n            fmt.type =V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\n            fmt.fmt.pix_mp.pixelformat = output_capability;\n            fmt.fmt.pix_mp.plane_fmt[0].sizeimage = buf_size;\n } else if (buffer_prop->buffer_type == VDEC_BUFFER_TYPE_OUTPUT) {\n            fmt.type =V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n            fmt.fmt.pix_mp.pixelformat = capture_capability;\n } else {\n            eRet = OMX_ErrorBadParameter;\n }\n\n        ret = ioctl(drv_ctx.video_driver_fd, VIDIOC_S_FMT, &fmt);\n if (ret) {\n /*TODO: How to handle this case */\n            DEBUG_PRINT_ERROR(\"Setting buffer requirements (format) failed %d\", ret);\n            eRet = OMX_ErrorInsufficientResources;\n }\n\n        bufreq.memory = V4L2_MEMORY_USERPTR;\n        bufreq.count = buffer_prop->actualcount;\n if (buffer_prop->buffer_type == VDEC_BUFFER_TYPE_INPUT) {\n            bufreq.type=V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\n } else if (buffer_prop->buffer_type == VDEC_BUFFER_TYPE_OUTPUT) {\n            bufreq.type=V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n } else {\n            eRet = OMX_ErrorBadParameter;\n }\n\n if (eRet==OMX_ErrorNone) {\n            ret = ioctl(drv_ctx.video_driver_fd,VIDIOC_REQBUFS, &bufreq);\n }\n\n if (ret) {\n            DEBUG_PRINT_ERROR(\"Setting buffer requirements (reqbufs) failed %d\", ret);\n /*TODO: How to handle this case */\n            eRet = OMX_ErrorInsufficientResources;\n } else if (bufreq.count < buffer_prop->actualcount) {\n            DEBUG_PRINT_ERROR(\"Driver refused to change the number of buffers\"\n \" on v4l2 port %d to %d (prefers %d)\", bufreq.type,\n                    buffer_prop->actualcount, bufreq.count);\n            eRet = OMX_ErrorInsufficientResources;\n } else {\n if (!client_buffers.update_buffer_req()) {\n                DEBUG_PRINT_ERROR(\"Setting c2D buffer requirements failed\");\n                eRet = OMX_ErrorInsufficientResources;\n }\n }\n }\n return eRet;\n}\n", "target": 0, "idx": 173496}
{"func": " parse_rock_ridge_inode_internal(struct iso_directory_record *de,\n\t\t\t\tstruct inode *inode, int regard_xa)\n {\n \tint symlink_len = 0;\n \tint cnt, sig;\n \tstruct inode *reloc;\n \tstruct rock_ridge *rr;\n \tint rootflag;\n\tstruct rock_state rs;\n\tint ret = 0;\n\n\tif (!ISOFS_SB(inode->i_sb)->s_rock)\n\t\treturn 0;\n \n \tinit_rock_state(&rs, inode);\n \tsetup_rock_ridge(de, inode, &rs);\n\tif (regard_xa) {\n \t\trs.chr += 14;\n \t\trs.len -= 14;\n \t\tif (rs.len < 0)\n\t\t\trs.len = 0;\n\t}\n\nrepeat:\n\twhile (rs.len > 2) { /* There may be one byte for padding somewhere */\n\t\trr = (struct rock_ridge *)rs.chr;\n\t\t/*\n\t\t * Ignore rock ridge info if rr->len is out of range, but\n\t\t * don't return -EIO because that would make the file\n\t\t * invisible.\n\t\t */\n\t\tif (rr->len < 3)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\t\tsig = isonum_721(rs.chr);\n\t\tif (rock_check_overflow(&rs, sig))\n\t\t\tgoto eio;\n\t\trs.chr += rr->len;\n\t\trs.len -= rr->len;\n\t\t/*\n\t\t * As above, just ignore the rock ridge info if rr->len\n\t\t * is bogus.\n\t\t */\n\t\tif (rs.len < 0)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\n\t\tswitch (sig) {\n#ifndef CONFIG_ZISOFS\t\t/* No flag for SF or ZF */\n\t\tcase SIG('R', 'R'):\n\t\t\tif ((rr->u.RR.flags[0] &\n\t\t\t     (RR_PX | RR_TF | RR_SL | RR_CL)) == 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n#endif\n\t\tcase SIG('S', 'P'):\n\t\t\tif (check_sp(rr, inode))\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('C', 'E'):\n\t\t\trs.cont_extent = isonum_733(rr->u.CE.extent);\n\t\t\trs.cont_offset = isonum_733(rr->u.CE.offset);\n\t\t\trs.cont_size = isonum_733(rr->u.CE.size);\n\t\t\tbreak;\n\t\tcase SIG('E', 'R'):\n\t\t\tISOFS_SB(inode->i_sb)->s_rock = 1;\n\t\t\tprintk(KERN_DEBUG \"ISO 9660 Extensions: \");\n\t\t\t{\n\t\t\t\tint p;\n\t\t\t\tfor (p = 0; p < rr->u.ER.len_id; p++)\n\t\t\t\t\tprintk(\"%c\", rr->u.ER.data[p]);\n\t\t\t}\n\t\t\tprintk(\"\\n\");\n\t\t\tbreak;\n\t\tcase SIG('P', 'X'):\n\t\t\tinode->i_mode = isonum_733(rr->u.PX.mode);\n\t\t\tset_nlink(inode, isonum_733(rr->u.PX.n_links));\n\t\t\ti_uid_write(inode, isonum_733(rr->u.PX.uid));\n\t\t\ti_gid_write(inode, isonum_733(rr->u.PX.gid));\n\t\t\tbreak;\n\t\tcase SIG('P', 'N'):\n\t\t\t{\n\t\t\t\tint high, low;\n\t\t\t\thigh = isonum_733(rr->u.PN.dev_high);\n\t\t\t\tlow = isonum_733(rr->u.PN.dev_low);\n\t\t\t\t/*\n\t\t\t\t * The Rock Ridge standard specifies that if\n\t\t\t\t * sizeof(dev_t) <= 4, then the high field is\n\t\t\t\t * unused, and the device number is completely\n\t\t\t\t * stored in the low field.  Some writers may\n\t\t\t\t * ignore this subtlety,\n\t\t\t\t * and as a result we test to see if the entire\n\t\t\t\t * device number is\n\t\t\t\t * stored in the low field, and use that.\n\t\t\t\t */\n\t\t\t\tif ((low & ~0xff) && high == 0) {\n\t\t\t\t\tinode->i_rdev =\n\t\t\t\t\t    MKDEV(low >> 8, low & 0xff);\n\t\t\t\t} else {\n\t\t\t\t\tinode->i_rdev =\n\t\t\t\t\t    MKDEV(high, low);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SIG('T', 'F'):\n\t\t\t/*\n\t\t\t * Some RRIP writers incorrectly place ctime in the\n\t\t\t * TF_CREATE field. Try to handle this correctly for\n\t\t\t * either case.\n\t\t\t */\n\t\t\t/* Rock ridge never appears on a High Sierra disk */\n\t\t\tcnt = 0;\n\t\t\tif (rr->u.TF.flags & TF_CREATE) {\n\t\t\t\tinode->i_ctime.tv_sec =\n\t\t\t\t    iso_date(rr->u.TF.times[cnt++].time,\n\t\t\t\t\t     0);\n\t\t\t\tinode->i_ctime.tv_nsec = 0;\n\t\t\t}\n\t\t\tif (rr->u.TF.flags & TF_MODIFY) {\n\t\t\t\tinode->i_mtime.tv_sec =\n\t\t\t\t    iso_date(rr->u.TF.times[cnt++].time,\n\t\t\t\t\t     0);\n\t\t\t\tinode->i_mtime.tv_nsec = 0;\n\t\t\t}\n\t\t\tif (rr->u.TF.flags & TF_ACCESS) {\n\t\t\t\tinode->i_atime.tv_sec =\n\t\t\t\t    iso_date(rr->u.TF.times[cnt++].time,\n\t\t\t\t\t     0);\n\t\t\t\tinode->i_atime.tv_nsec = 0;\n\t\t\t}\n\t\t\tif (rr->u.TF.flags & TF_ATTRIBUTES) {\n\t\t\t\tinode->i_ctime.tv_sec =\n\t\t\t\t    iso_date(rr->u.TF.times[cnt++].time,\n\t\t\t\t\t     0);\n\t\t\t\tinode->i_ctime.tv_nsec = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SIG('S', 'L'):\n\t\t\t{\n\t\t\t\tint slen;\n\t\t\t\tstruct SL_component *slp;\n\t\t\t\tstruct SL_component *oldslp;\n\t\t\t\tslen = rr->len - 5;\n\t\t\t\tslp = &rr->u.SL.link;\n\t\t\t\tinode->i_size = symlink_len;\n\t\t\t\twhile (slen > 1) {\n\t\t\t\t\trootflag = 0;\n\t\t\t\t\tswitch (slp->flags & ~1) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tinode->i_size +=\n\t\t\t\t\t\t    slp->len;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tinode->i_size += 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tinode->i_size += 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 8:\n\t\t\t\t\t\trootflag = 1;\n\t\t\t\t\t\tinode->i_size += 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tprintk(\"Symlink component flag \"\n\t\t\t\t\t\t\t\"not implemented\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tslen -= slp->len + 2;\n\t\t\t\t\toldslp = slp;\n\t\t\t\t\tslp = (struct SL_component *)\n\t\t\t\t\t\t(((char *)slp) + slp->len + 2);\n\n\t\t\t\t\tif (slen < 2) {\n\t\t\t\t\t\tif (((rr->u.SL.\n\t\t\t\t\t\t      flags & 1) != 0)\n\t\t\t\t\t\t    &&\n\t\t\t\t\t\t    ((oldslp->\n\t\t\t\t\t\t      flags & 1) == 0))\n\t\t\t\t\t\t\tinode->i_size +=\n\t\t\t\t\t\t\t    1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * If this component record isn't\n\t\t\t\t\t * continued, then append a '/'.\n\t\t\t\t\t */\n\t\t\t\t\tif (!rootflag\n\t\t\t\t\t    && (oldslp->flags & 1) == 0)\n\t\t\t\t\t\tinode->i_size += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsymlink_len = inode->i_size;\n\t\t\tbreak;\n\t\tcase SIG('R', 'E'):\n\t\t\tprintk(KERN_WARNING \"Attempt to read inode for \"\n \t\t\t\t\t\"relocated directory\\n\");\n \t\t\tgoto out;\n \t\tcase SIG('C', 'L'):\n\t\t\tISOFS_I(inode)->i_first_extent =\n\t\t\t    isonum_733(rr->u.CL.location);\n\t\t\treloc =\n\t\t\t    isofs_iget(inode->i_sb,\n\t\t\t\t       ISOFS_I(inode)->i_first_extent,\n\t\t\t\t       0);\n \t\t\tif (IS_ERR(reloc)) {\n \t\t\t\tret = PTR_ERR(reloc);\n \t\t\t\tgoto out;\n\t\t\t}\n\t\t\tinode->i_mode = reloc->i_mode;\n\t\t\tset_nlink(inode, reloc->i_nlink);\n\t\t\tinode->i_uid = reloc->i_uid;\n\t\t\tinode->i_gid = reloc->i_gid;\n\t\t\tinode->i_rdev = reloc->i_rdev;\n\t\t\tinode->i_size = reloc->i_size;\n\t\t\tinode->i_blocks = reloc->i_blocks;\n\t\t\tinode->i_atime = reloc->i_atime;\n\t\t\tinode->i_ctime = reloc->i_ctime;\n\t\t\tinode->i_mtime = reloc->i_mtime;\n\t\t\tiput(reloc);\n\t\t\tbreak;\n#ifdef CONFIG_ZISOFS\n\t\tcase SIG('Z', 'F'): {\n\t\t\tint algo;\n\n\t\t\tif (ISOFS_SB(inode->i_sb)->s_nocompress)\n\t\t\t\tbreak;\n\t\t\talgo = isonum_721(rr->u.ZF.algorithm);\n\t\t\tif (algo == SIG('p', 'z')) {\n\t\t\t\tint block_shift =\n\t\t\t\t\tisonum_711(&rr->u.ZF.parms[1]);\n\t\t\t\tif (block_shift > 17) {\n\t\t\t\t\tprintk(KERN_WARNING \"isofs: \"\n\t\t\t\t\t\t\"Can't handle ZF block \"\n\t\t\t\t\t\t\"size of 2^%d\\n\",\n\t\t\t\t\t\tblock_shift);\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t * Note: we don't change\n\t\t\t\t\t * i_blocks here\n\t\t\t\t\t */\n\t\t\t\t\tISOFS_I(inode)->i_file_format =\n\t\t\t\t\t\tisofs_file_compressed;\n\t\t\t\t\t/*\n\t\t\t\t\t * Parameters to compression\n\t\t\t\t\t * algorithm (header size,\n\t\t\t\t\t * block size)\n\t\t\t\t\t */\n\t\t\t\t\tISOFS_I(inode)->i_format_parm[0] =\n\t\t\t\t\t\tisonum_711(&rr->u.ZF.parms[0]);\n\t\t\t\t\tISOFS_I(inode)->i_format_parm[1] =\n\t\t\t\t\t\tisonum_711(&rr->u.ZF.parms[1]);\n\t\t\t\t\tinode->i_size =\n\t\t\t\t\t    isonum_733(rr->u.ZF.\n\t\t\t\t\t\t       real_size);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t       \"isofs: Unknown ZF compression \"\n\t\t\t\t\t\t\"algorithm: %c%c\\n\",\n\t\t\t\t       rr->u.ZF.algorithm[0],\n\t\t\t\t       rr->u.ZF.algorithm[1]);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tret = rock_continue(&rs);\n\tif (ret == 0)\n\t\tgoto repeat;\n\tif (ret == 1)\n\t\tret = 0;\nout:\n\tkfree(rs.buffer);\n\treturn ret;\neio:\n\tret = -EIO;\n\tgoto out;\n}\n", "target": 1, "idx": 179443}
{"func": "void Segment::PreloadCluster(Cluster* pCluster, ptrdiff_t idx)\n{\n    assert(pCluster);\n    assert(pCluster->m_index < 0);\n    assert(idx >= m_clusterCount);\n    const long count = m_clusterCount + m_clusterPreloadCount;\n    long& size = m_clusterSize;\n    assert(size >= count);\n    if (count >= size)\n    {\n        const long n = (size <= 0) ? 2048 : 2*size;\n        Cluster** const qq = new Cluster*[n];\n        Cluster** q = qq;\n        Cluster** p = m_clusters;\n        Cluster** const pp = p + count;\n        while (p != pp)\n            *q++ = *p++;\n        delete[] m_clusters;\n        m_clusters = qq;\n        size = n;\n    }\n     assert(m_clusters);\n \n    Cluster** const p = m_clusters + idx;\n \n    Cluster** q = m_clusters + count;\n    assert(q >= p);\n     assert(q < (m_clusters + size));\n \n    while (q > p)\n    {\n        Cluster** const qq = q - 1;\n        assert((*qq)->m_index < 0);\n \n        *q = *qq;\n        q = qq;\n     }\n \n    m_clusters[idx] = pCluster;\n    ++m_clusterPreloadCount;\n }\n", "target": 1, "idx": 188453}
{"func": "static int sd_ioctl(struct block_device *bdev, fmode_t mode,\n\t\t    unsigned int cmd, unsigned long arg)\n{\n\tstruct gendisk *disk = bdev->bd_disk;\n\tstruct scsi_disk *sdkp = scsi_disk(disk);\n\tstruct scsi_device *sdp = sdkp->device;\n\tvoid __user *p = (void __user *)arg;\n\tint error;\n    \n \tSCSI_LOG_IOCTL(1, sd_printk(KERN_INFO, sdkp, \"sd_ioctl: disk=%s, \"\n \t\t\t\t    \"cmd=0x%x\\n\", disk->disk_name, cmd));\n \n \t/*\n \t * If we are in the middle of error recovery, don't let anyone\n \t * else try and use this device.  Also, if error recovery fails, it\n\t * may try and take the device offline, in which case all further\n\t * access to the device is prohibited.\n\t */\n\terror = scsi_nonblockable_ioctl(sdp, cmd, p,\n\t\t\t\t\t(mode & FMODE_NDELAY) != 0);\n\tif (!scsi_block_when_processing_errors(sdp) || !error)\n\t\tgoto out;\n\n\t/*\n\t * Send SCSI addressing ioctls directly to mid level, send other\n\t * ioctls to block level and then onto mid level if they can't be\n\t * resolved.\n\t */\n\tswitch (cmd) {\n\t\tcase SCSI_IOCTL_GET_IDLUN:\n\t\tcase SCSI_IOCTL_GET_BUS_NUMBER:\n\t\t\terror = scsi_ioctl(sdp, cmd, p);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror = scsi_cmd_blk_ioctl(bdev, mode, cmd, p);\n\t\t\tif (error != -ENOTTY)\n\t\t\t\tbreak;\n\t\t\terror = scsi_ioctl(sdp, cmd, p);\n\t\t\tbreak;\n\t}\nout:\n\treturn error;\n}\n", "target": 1, "idx": 183063}
{"func": "AtomicString GetInputModeAttribute(Element* element) {\n  if (!element)\n    return AtomicString();\n\n  bool query_attribute = false;\n  if (isHTMLInputElement(*element)) {\n    query_attribute = toHTMLInputElement(*element).SupportsInputModeAttribute();\n  } else if (isHTMLTextAreaElement(*element)) {\n    query_attribute = true;\n  } else {\n    element->GetDocument().UpdateStyleAndLayoutTree();\n    if (HasEditableStyle(*element))\n      query_attribute = true;\n  }\n\n  if (!query_attribute)\n    return AtomicString();\n\n  return element->FastGetAttribute(HTMLNames::inputmodeAttr).DeprecatedLower();\n}\n", "target": 0, "idx": 135743}
{"func": "void HTMLMediaElement::setPlaybackRate(double rate,\n                                       ExceptionState& exception_state) {\n  BLINK_MEDIA_LOG << \"setPlaybackRate(\" << (void*)this << \", \" << rate << \")\";\n  if (GetLoadType() == WebMediaPlayer::kLoadTypeMediaStream)\n    return;\n\n  if (rate != 0.0 && (rate < kMinRate || rate > kMaxRate)) {\n    UseCounter::Count(GetDocument(),\n                      WebFeature::kHTMLMediaElementMediaPlaybackRateOutOfRange);\n\n    exception_state.ThrowDOMException(\n        DOMExceptionCode::kNotSupportedError,\n        \"The provided playback rate (\" + String::Number(rate) +\n            \") is not in the \" + \"supported playback range.\");\n\n    return;\n  }\n\n  if (playback_rate_ != rate) {\n    playback_rate_ = rate;\n    ScheduleEvent(event_type_names::kRatechange);\n  }\n\n  UpdatePlaybackRate();\n}\n", "target": 0, "idx": 142970}
{"func": " void PrintWebViewHelper::OnPrintForSystemDialog() {\n   blink::WebLocalFrame* frame = print_preview_context_.source_frame();\n   if (!frame) {\n     NOTREACHED();\n    return;\n  }\n  Print(frame, print_preview_context_.source_node(), false);\n}\n", "target": 1, "idx": 185752}
{"func": " static void ieee80211_if_setup(struct net_device *dev)\n {\n \tether_setup(dev);\n \tdev->netdev_ops = &ieee80211_dataif_ops;\n \tdev->destructor = free_netdev;\n }\n", "target": 1, "idx": 178911}
{"func": "static void RelinquishZIPMemory(voidpf context,voidpf memory)\n{\n  (void) context;\n  memory=RelinquishMagickMemory(memory);\n}\n", "target": 0, "idx": 62094}
{"func": "compile_bag_node(BagNode* node, regex_t* reg, ScanEnv* env)\n{\n  int r, len;\n\n  switch (node->type) {\n  case BAG_MEMORY:\n    r = compile_bag_memory_node(node, reg, env);\n    break;\n\n  case BAG_OPTION:\n    r = compile_option_node(node, reg, env);\n    break;\n\n  case BAG_STOP_BACKTRACK:\n    if (NODE_IS_STOP_BT_SIMPLE_REPEAT(node)) {\n      QuantNode* qn = QUANT_(NODE_BAG_BODY(node));\n      r = compile_tree_n_times(NODE_QUANT_BODY(qn), qn->lower, reg, env);\n      if (r != 0) return r;\n\n      len = compile_length_tree(NODE_QUANT_BODY(qn), reg);\n      if (len < 0) return len;\n\n      r = add_op(reg, OP_PUSH);\n      if (r != 0) return r;\n      COP(reg)->push.addr = SIZE_INC_OP + len + SIZE_OP_POP_OUT + SIZE_OP_JUMP;\n\n      r = compile_tree(NODE_QUANT_BODY(qn), reg, env);\n      if (r != 0) return r;\n      r = add_op(reg, OP_POP_OUT);\n      if (r != 0) return r;\n\n      r = add_op(reg, OP_JUMP);\n      if (r != 0) return r;\n      COP(reg)->jump.addr = -((int )SIZE_OP_PUSH + len + (int )SIZE_OP_POP_OUT);\n    }\n    else {\n      r = add_op(reg, OP_ATOMIC_START);\n      if (r != 0) return r;\n      r = compile_tree(NODE_BAG_BODY(node), reg, env);\n      if (r != 0) return r;\n      r = add_op(reg, OP_ATOMIC_END);\n    }\n    break;\n \n   case BAG_IF_ELSE:\n     {\n      int cond_len, then_len, jump_len;\n       Node* cond = NODE_BAG_BODY(node);\n       Node* Then = node->te.Then;\n       Node* Else = node->te.Else;\n\n      r = add_op(reg, OP_ATOMIC_START);\n      if (r != 0) return r;\n\n      cond_len = compile_length_tree(cond, reg);\n      if (cond_len < 0) return cond_len;\n      if (IS_NOT_NULL(Then)) {\n        then_len = compile_length_tree(Then, reg);\n        if (then_len < 0) return then_len;\n      }\n       else\n         then_len = 0;\n \n      jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END;\n      if (IS_NOT_NULL(Else)) jump_len += SIZE_OP_JUMP;\n \n       r = add_op(reg, OP_PUSH);\n       if (r != 0) return r;\n      COP(reg)->push.addr = SIZE_INC_OP + jump_len;\n\n      r = compile_tree(cond, reg, env);\n      if (r != 0) return r;\n      r = add_op(reg, OP_ATOMIC_END);\n      if (r != 0) return r;\n\n      if (IS_NOT_NULL(Then)) {\n        r = compile_tree(Then, reg, env);\n        if (r != 0) return r;\n       }\n \n       if (IS_NOT_NULL(Else)) {\n        int else_len = compile_length_tree(Else, reg);\n        r = add_op(reg, OP_JUMP);\n        if (r != 0) return r;\n        COP(reg)->jump.addr = else_len + SIZE_INC_OP;\n \n         r = compile_tree(Else, reg, env);\n       }\n     }\n    break;\n  }\n\n  return r;\n}\n", "target": 1, "idx": 182783}
{"func": "static int sapi_fcgi_read_post(char *buffer, uint count_bytes TSRMLS_DC)\n{\n\tuint read_bytes = 0;\n\tint tmp_read_bytes;\n\tfcgi_request *request = (fcgi_request*) SG(server_context);\n\n\tcount_bytes = MIN(count_bytes, (uint) SG(request_info).content_length - SG(read_post_bytes));\n\twhile (read_bytes < count_bytes) {\n\t\ttmp_read_bytes = fcgi_read(request, buffer + read_bytes, count_bytes - read_bytes);\n\t\tif (tmp_read_bytes <= 0) {\n\t\t\tbreak;\n\t\t}\n\t\tread_bytes += tmp_read_bytes;\n\t}\n\treturn read_bytes;\n}\n", "target": 0, "idx": 7274}
{"func": "NaClProcessHost::NaClProcessHost(const GURL& manifest_url, bool off_the_record)\n    : manifest_url_(manifest_url),\n#if defined(OS_WIN)\n      process_launched_by_broker_(false),\n#elif defined(OS_LINUX)\n      wait_for_nacl_gdb_(false),\n#endif\n      reply_msg_(NULL),\n#if defined(OS_WIN)\n      debug_exception_handler_requested_(false),\n#endif\n      internal_(new NaClInternal()),\n      ALLOW_THIS_IN_INITIALIZER_LIST(weak_factory_(this)),\n      enable_exception_handling_(false),\n      off_the_record_(off_the_record) {\n  process_.reset(content::BrowserChildProcessHost::Create(\n      content::PROCESS_TYPE_NACL_LOADER, this));\n\n  process_->SetName(net::FormatUrl(manifest_url_, std::string()));\n\n  if (CommandLine::ForCurrentProcess()->HasSwitch(\n          switches::kEnableNaClExceptionHandling) ||\n       getenv(\"NACL_UNTRUSTED_EXCEPTION_HANDLING\") != NULL) {\n     enable_exception_handling_ = true;\n   }\n  enable_ipc_proxy_ = CommandLine::ForCurrentProcess()->HasSwitch(\n      switches::kEnableNaClIPCProxy);\n }\n", "target": 1, "idx": 184298}
{"func": "static void sctp_sock_migrate(struct sock *oldsk, struct sock *newsk,\n\t\t\t      struct sctp_association *assoc,\n\t\t\t      sctp_socket_type_t type)\n{\n\tstruct sctp_sock *oldsp = sctp_sk(oldsk);\n\tstruct sctp_sock *newsp = sctp_sk(newsk);\n\tstruct sctp_bind_bucket *pp; /* hash list port iterator */\n\tstruct sctp_endpoint *newep = newsp->ep;\n \tstruct sk_buff *skb, *tmp;\n \tstruct sctp_ulpevent *event;\n \tstruct sctp_bind_hashbucket *head;\n\tstruct list_head tmplist;\n \n \t/* Migrate socket buffer sizes and all the socket level options to the\n \t * new socket.\n \t */\n \tnewsk->sk_sndbuf = oldsk->sk_sndbuf;\n \tnewsk->sk_rcvbuf = oldsk->sk_rcvbuf;\n \t/* Brute force copy old sctp opt. */\n\tif (oldsp->do_auto_asconf) {\n\t\tmemcpy(&tmplist, &newsp->auto_asconf_list, sizeof(tmplist));\n\t\tinet_sk_copy_descendant(newsk, oldsk);\n\t\tmemcpy(&newsp->auto_asconf_list, &tmplist, sizeof(tmplist));\n\t} else\n\t\tinet_sk_copy_descendant(newsk, oldsk);\n \n \t/* Restore the ep value that was overwritten with the above structure\n \t * copy.\n\t */\n\tnewsp->ep = newep;\n\tnewsp->hmac = NULL;\n\n\t/* Hook this new socket in to the bind_hash list. */\n\thead = &sctp_port_hashtable[sctp_phashfn(sock_net(oldsk),\n\t\t\t\t\t\t inet_sk(oldsk)->inet_num)];\n\tlocal_bh_disable();\n\tspin_lock(&head->lock);\n\tpp = sctp_sk(oldsk)->bind_hash;\n\tsk_add_bind_node(newsk, &pp->owner);\n\tsctp_sk(newsk)->bind_hash = pp;\n\tinet_sk(newsk)->inet_num = inet_sk(oldsk)->inet_num;\n\tspin_unlock(&head->lock);\n\tlocal_bh_enable();\n\n\t/* Copy the bind_addr list from the original endpoint to the new\n\t * endpoint so that we can handle restarts properly\n\t */\n\tsctp_bind_addr_dup(&newsp->ep->base.bind_addr,\n\t\t\t\t&oldsp->ep->base.bind_addr, GFP_KERNEL);\n\n\t/* Move any messages in the old socket's receive queue that are for the\n\t * peeled off association to the new socket's receive queue.\n\t */\n\tsctp_skb_for_each(skb, &oldsk->sk_receive_queue, tmp) {\n\t\tevent = sctp_skb2event(skb);\n\t\tif (event->asoc == assoc) {\n\t\t\t__skb_unlink(skb, &oldsk->sk_receive_queue);\n\t\t\t__skb_queue_tail(&newsk->sk_receive_queue, skb);\n\t\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n\t\t}\n\t}\n\n\t/* Clean up any messages pending delivery due to partial\n\t * delivery.   Three cases:\n\t * 1) No partial deliver;  no work.\n\t * 2) Peeling off partial delivery; keep pd_lobby in new pd_lobby.\n\t * 3) Peeling off non-partial delivery; move pd_lobby to receive_queue.\n\t */\n\tskb_queue_head_init(&newsp->pd_lobby);\n\tatomic_set(&sctp_sk(newsk)->pd_mode, assoc->ulpq.pd_mode);\n\n\tif (atomic_read(&sctp_sk(oldsk)->pd_mode)) {\n\t\tstruct sk_buff_head *queue;\n\n\t\t/* Decide which queue to move pd_lobby skbs to. */\n\t\tif (assoc->ulpq.pd_mode) {\n\t\t\tqueue = &newsp->pd_lobby;\n\t\t} else\n\t\t\tqueue = &newsk->sk_receive_queue;\n\n\t\t/* Walk through the pd_lobby, looking for skbs that\n\t\t * need moved to the new socket.\n\t\t */\n\t\tsctp_skb_for_each(skb, &oldsp->pd_lobby, tmp) {\n\t\t\tevent = sctp_skb2event(skb);\n\t\t\tif (event->asoc == assoc) {\n\t\t\t\t__skb_unlink(skb, &oldsp->pd_lobby);\n\t\t\t\t__skb_queue_tail(queue, skb);\n\t\t\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n\t\t\t}\n\t\t}\n\n\t\t/* Clear up any skbs waiting for the partial\n\t\t * delivery to finish.\n\t\t */\n\t\tif (assoc->ulpq.pd_mode)\n\t\t\tsctp_clear_pd(oldsk, NULL);\n\n\t}\n\n\tsctp_skb_for_each(skb, &assoc->ulpq.reasm, tmp)\n\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n\n\tsctp_skb_for_each(skb, &assoc->ulpq.lobby, tmp)\n\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n\n\t/* Set the type of socket to indicate that it is peeled off from the\n\t * original UDP-style socket or created with the accept() call on a\n\t * TCP-style socket..\n\t */\n\tnewsp->type = type;\n\n\t/* Mark the new socket \"in-use\" by the user so that any packets\n\t * that may arrive on the association after we've moved it are\n\t * queued to the backlog.  This prevents a potential race between\n\t * backlog processing on the old socket and new-packet processing\n\t * on the new socket.\n\t *\n\t * The caller has just allocated newsk so we can guarantee that other\n\t * paths won't try to lock it and then oldsk.\n\t */\n\tlock_sock_nested(newsk, SINGLE_DEPTH_NESTING);\n\tsctp_assoc_migrate(assoc, newsk);\n\n\t/* If the association on the newsk is already closed before accept()\n\t * is called, set RCV_SHUTDOWN flag.\n\t */\n\tif (sctp_state(assoc, CLOSED) && sctp_style(newsk, TCP))\n\t\tnewsk->sk_shutdown |= RCV_SHUTDOWN;\n\n\tnewsk->sk_state = SCTP_SS_ESTABLISHED;\n\trelease_sock(newsk);\n}\n", "target": 1, "idx": 179803}
{"func": "status_t SoundTriggerHwService::Module::startRecognition(sound_model_handle_t handle,\n const sp<IMemory>& dataMemory)\n{\n    ALOGV(\"startRecognition() model handle %d\", handle);\n if (!captureHotwordAllowed()) {\n\n         return PERMISSION_DENIED;\n     }\n \n    if (dataMemory != 0 && dataMemory->pointer() == NULL) {\n        ALOGE(\"startRecognition() dataMemory is non-0 but has NULL pointer()\");\n         return BAD_VALUE;\n \n     }\n     AutoMutex lock(mLock);\n     if (mServiceState == SOUND_TRIGGER_STATE_DISABLED) {\n         return INVALID_OPERATION;\n }\n    sp<Model> model = getModel(handle);\n\n     if (model == 0) {\n         return BAD_VALUE;\n     }\n    if ((dataMemory == 0) ||\n            (dataMemory->size() < sizeof(struct sound_trigger_recognition_config))) {\n        return BAD_VALUE;\n    }\n \n     if (model->mState == Model::STATE_ACTIVE) {\n         return INVALID_OPERATION;\n     }\n \n    struct sound_trigger_recognition_config *config =\n            (struct sound_trigger_recognition_config *)dataMemory->pointer();\n \n     config->capture_handle = model->mCaptureIOHandle;\n    config->capture_device = model->mCaptureDevice;\n status_t status = mHwDevice->start_recognition(mHwDevice, handle, config,\n SoundTriggerHwService::recognitionCallback,\n this);\n\n if (status == NO_ERROR) {\n        model->mState = Model::STATE_ACTIVE;\n        model->mConfig = *config;\n }\n\n return status;\n}\n", "target": 1, "idx": 187422}
{"func": "inline void DialogHandler::dialogCreated(DOMWindow* dialogFrame)\n{\n    m_dialogContext = dialogFrame->frame() ? dialogFrame->frame()->script()->currentWorldContext() : v8::Local<v8::Context>();\n    if (m_dialogContext.IsEmpty())\n        return;\n    if (m_dialogArguments.IsEmpty())\n        return;\n    v8::Context::Scope scope(m_dialogContext);\n    m_dialogContext->Global()->Set(v8::String::NewSymbol(\"dialogArguments\"), m_dialogArguments);\n}\n", "target": 0, "idx": 118702}
{"func": "bool AsyncPixelTransfersCompletedQuery::End(\n    base::subtle::Atomic32 submit_count) {\n  AsyncMemoryParams mem_params;\n  Buffer buffer = manager()->decoder()->GetSharedMemoryBuffer(shm_id());\n  if (!buffer.shared_memory)\n    return false;\n  mem_params.shared_memory = buffer.shared_memory;\n   mem_params.shm_size = buffer.size;\n   mem_params.shm_data_offset = shm_offset();\n   mem_params.shm_data_size = sizeof(QuerySync);\n \n   observer_ = new AsyncPixelTransferCompletionObserverImpl(submit_count);\n \n  manager()->decoder()->GetAsyncPixelTransferManager()\n      ->AsyncNotifyCompletion(mem_params, observer_);\n\n  return AddToPendingTransferQueue(submit_count);\n}\n", "target": 1, "idx": 185457}
{"func": "grub_ext2_read_block (grub_fshelp_node_t node, grub_disk_addr_t fileblock)\n{\n  struct grub_ext2_data *data = node->data;\n  struct grub_ext2_inode *inode = &node->inode;\n  int blknr = -1;\n  unsigned int blksz = EXT2_BLOCK_SIZE (data);\n  int log2_blksz = LOG2_EXT2_BLOCK_SIZE (data);\n\n  if (grub_le_to_cpu32(inode->flags) & EXT4_EXTENTS_FLAG)\n    {\n#ifndef _MSC_VER\n\t  char buf[EXT2_BLOCK_SIZE (data)];\n#else\n\t  char * buf = grub_malloc (EXT2_BLOCK_SIZE(data));\n#endif\n      struct grub_ext4_extent_header *leaf;\n      struct grub_ext4_extent *ext;\n      int i;\n\n      leaf = grub_ext4_find_leaf (data, buf,\n\t\t  (struct grub_ext4_extent_header *) inode->blocks.dir_blocks,\n\t\t  fileblock);\n      if (! leaf)\n        {\n          grub_error (GRUB_ERR_BAD_FS, \"invalid extent\");\n          return -1;\n        }\n\n      ext = (struct grub_ext4_extent *) (leaf + 1);\n      for (i = 0; i < grub_le_to_cpu16 (leaf->entries); i++)\n        {\n          if (fileblock < grub_le_to_cpu32 (ext[i].block))\n            break;\n        }\n\n      if (--i >= 0)\n        {\n          fileblock -= grub_le_to_cpu32 (ext[i].block);\n          if (fileblock >= grub_le_to_cpu16 (ext[i].len))\n            return 0;\n          else\n            {\n              grub_disk_addr_t start;\n\n              start = grub_le_to_cpu16 (ext[i].start_hi);\n              start = (start << 32) + grub_le_to_cpu32 (ext[i].start);\n\n              return fileblock + start;\n            }\n        }\n      else\n        {\n          grub_error (GRUB_ERR_BAD_FS, \"something wrong with extent\");\n          return -1;\n         }\n     }\n   /* Direct blocks.  */\n  if (fileblock < INDIRECT_BLOCKS)\n     blknr = grub_le_to_cpu32 (inode->blocks.dir_blocks[fileblock]);\n   /* Indirect.  */\n  else if (fileblock < INDIRECT_BLOCKS + blksz / 4)\n     {\n       grub_uint32_t *indir;\n \n      indir = grub_malloc (blksz);\n      if (! indir)\n\treturn grub_errno;\n\n      if (grub_disk_read (data->disk,\n\t\t\t  ((grub_disk_addr_t)\n\t\t\t   grub_le_to_cpu32 (inode->blocks.indir_block))\n\t\t\t  << log2_blksz,\n\t\t\t  0, blksz, indir))\n\treturn grub_errno;\n\n      blknr = grub_le_to_cpu32 (indir[fileblock - INDIRECT_BLOCKS]);\n      grub_free (indir);\n    }\n  /* Double indirect.  */\n  else if (fileblock < (grub_disk_addr_t)(INDIRECT_BLOCKS + blksz / 4) \\\n\t\t  * (grub_disk_addr_t)(blksz / 4 + 1))\n    {\n      unsigned int perblock = blksz / 4;\n      unsigned int rblock = fileblock - (INDIRECT_BLOCKS\n\t\t\t\t\t + blksz / 4);\n      grub_uint32_t *indir;\n\n      indir = grub_malloc (blksz);\n      if (! indir)\n\treturn grub_errno;\n\n      if (grub_disk_read (data->disk,\n\t\t\t  ((grub_disk_addr_t)\n\t\t\t   grub_le_to_cpu32 (inode->blocks.double_indir_block))\n\t\t\t  << log2_blksz,\n\t\t\t  0, blksz, indir))\n\treturn grub_errno;\n\n      if (grub_disk_read (data->disk,\n\t\t\t  ((grub_disk_addr_t)\n\t\t\t   grub_le_to_cpu32 (indir[rblock / perblock]))\n\t\t\t  << log2_blksz,\n\t\t\t  0, blksz, indir))\n\treturn grub_errno;\n\n      blknr = grub_le_to_cpu32 (indir[rblock % perblock]);\n            grub_free (indir);\n    }\n  /* triple indirect.  */\n  else\n    {\n      grub_error (GRUB_ERR_NOT_IMPLEMENTED_YET,\n\t\t  \"ext2fs doesn't support triple indirect blocks\");\n    }\n\n  return blknr;\n}\n", "target": 1, "idx": 181255}
{"func": "void mp_encode_lua_table_as_map(lua_State *L, mp_buf *buf, int level) {\n    size_t len = 0;\n\n    /* First step: count keys into table. No other way to do it with the\n      * Lua API, we need to iterate a first time. Note that an alternative\n      * would be to do a single run, and then hack the buffer to insert the\n      * map opcodes for message pack. Too hackish for this lib. */\n     lua_pushnil(L);\n     while(lua_next(L,-2)) {\n         lua_pop(L,1); /* remove value, keep key for next iteration. */\n        len++;\n    }\n\n    /* Step two: actually encoding of the map. */\n    mp_encode_map(L,buf,len);\n    lua_pushnil(L);\n    while(lua_next(L,-2)) {\n        /* Stack: ... key value */\n        lua_pushvalue(L,-2); /* Stack: ... key value key */\n        mp_encode_lua_type(L,buf,level+1); /* encode key */\n        mp_encode_lua_type(L,buf,level+1); /* encode val */\n    }\n}\n", "target": 1, "idx": 182412}
{"func": "int fastcall __lock_page_killable(struct page *page)\n{\n\tDEFINE_WAIT_BIT(wait, &page->flags, PG_locked);\n\n\treturn __wait_on_bit_lock(page_waitqueue(page), &wait,\n\t\t\t\t\tsync_page_killable, TASK_KILLABLE);\n}\n", "target": 0, "idx": 58784}
{"func": "void LargeObjectPage::RemoveFromHeap() {\n  static_cast<LargeObjectArena*>(Arena())->FreeLargeObjectPage(this);\n}\n", "target": 0, "idx": 166773}
{"func": " FileStream::FileStream(base::File file,\n                        const scoped_refptr<base::TaskRunner>& task_runner)\n    : context_(base::MakeUnique<Context>(std::move(file), task_runner)) {}\n", "target": 1, "idx": 187285}
{"func": "xmlParseDocTypeDecl(xmlParserCtxtPtr ctxt) {\n    const xmlChar *name = NULL;\n    xmlChar *ExternalID = NULL;\n    xmlChar *URI = NULL;\n\n    /*\n     * We know that '<!DOCTYPE' has been detected.\n     */\n    SKIP(9);\n\n    SKIP_BLANKS;\n\n    /*\n     * Parse the DOCTYPE name.\n     */\n    name = xmlParseName(ctxt);\n    if (name == NULL) {\n\txmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n\t\t       \"xmlParseDocTypeDecl : no DOCTYPE name !\\n\");\n    }\n    ctxt->intSubName = name;\n\n    SKIP_BLANKS;\n\n    /*\n     * Check for SystemID and ExternalID\n     */\n    URI = xmlParseExternalID(ctxt, &ExternalID, 1);\n\n    if ((URI != NULL) || (ExternalID != NULL)) {\n        ctxt->hasExternalSubset = 1;\n    }\n    ctxt->extSubURI = URI;\n    ctxt->extSubSystem = ExternalID;\n\n    SKIP_BLANKS;\n\n    /*\n     * Create and update the internal subset.\n     */\n    if ((ctxt->sax != NULL) && (ctxt->sax->internalSubset != NULL) &&\n\t(!ctxt->disableSAX))\n\tctxt->sax->internalSubset(ctxt->userData, name, ExternalID, URI);\n    if (ctxt->instate == XML_PARSER_EOF)\n\treturn;\n\n    /*\n     * Is there any internal subset declarations ?\n     * they are handled separately in xmlParseInternalSubset()\n     */\n    if (RAW == '[')\n\treturn;\n\n    /*\n     * We should be at the end of the DOCTYPE declaration.\n     */\n    if (RAW != '>') {\n\txmlFatalErr(ctxt, XML_ERR_DOCTYPE_NOT_FINISHED, NULL);\n    }\n    NEXT;\n}\n", "target": 0, "idx": 59472}
{"func": "void PrintMsg_Print_Params::Reset() {\n  page_size = gfx::Size();\n  content_size = gfx::Size();\n  printable_area = gfx::Rect();\n  margin_top = 0;\n  margin_left = 0;\n  dpi = 0;\n  scale_factor = 1.0f;\n  rasterize_pdf = false;\n  document_cookie = 0;\n  selection_only = false;\n  supports_alpha_blend = false;\n  preview_ui_id = -1;\n  preview_request_id = 0;\n  is_first_request = false;\n  print_scaling_option = blink::kWebPrintScalingOptionSourceSize;\n  print_to_pdf = false;\n   display_header_footer = false;\n   title = base::string16();\n   url = base::string16();\n   should_print_backgrounds = false;\n   printed_doc_type = printing::SkiaDocumentType::PDF;\n }\n", "target": 1, "idx": 186875}
{"func": "xfs_attr_refillstate(xfs_da_state_t *state)\n{\n\txfs_da_state_path_t *path;\n\txfs_da_state_blk_t *blk;\n\tint level, error;\n\n\ttrace_xfs_attr_refillstate(state->args);\n\n\t/*\n\t * Roll down the \"path\" in the state structure, storing the on-disk\n\t * block number for those buffers in the \"path\".\n\t */\n\tpath = &state->path;\n\tASSERT((path->active >= 0) && (path->active < XFS_DA_NODE_MAXDEPTH));\n\tfor (blk = path->blk, level = 0; level < path->active; blk++, level++) {\n\t\tif (blk->disk_blkno) {\n\t\t\terror = xfs_da3_node_read(state->args->trans,\n\t\t\t\t\t\tstate->args->dp,\n\t\t\t\t\t\tblk->blkno, blk->disk_blkno,\n\t\t\t\t\t\t&blk->bp, XFS_ATTR_FORK);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t} else {\n\t\t\tblk->bp = NULL;\n\t\t}\n\t}\n\n\t/*\n\t * Roll down the \"altpath\" in the state structure, storing the on-disk\n\t * block number for those buffers in the \"altpath\".\n\t */\n\tpath = &state->altpath;\n\tASSERT((path->active >= 0) && (path->active < XFS_DA_NODE_MAXDEPTH));\n\tfor (blk = path->blk, level = 0; level < path->active; blk++, level++) {\n\t\tif (blk->disk_blkno) {\n\t\t\terror = xfs_da3_node_read(state->args->trans,\n\t\t\t\t\t\tstate->args->dp,\n\t\t\t\t\t\tblk->blkno, blk->disk_blkno,\n\t\t\t\t\t\t&blk->bp, XFS_ATTR_FORK);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t} else {\n\t\t\tblk->bp = NULL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n", "target": 0, "idx": 76324}
{"func": "NetworkThrottleManagerImpl::NetworkThrottleManagerImpl()\n     : lifetime_median_estimate_(PercentileEstimator::kMedianPercentile,\n                                 kInitialMedianInMs),\n       outstanding_recomputation_timer_(\n          base::MakeUnique<base::Timer>(false /* retain_user_task */,\n                                         false /* is_repeating */)),\n       tick_clock_(new base::DefaultTickClock()),\n       weak_ptr_factory_(this) {}\n", "target": 1, "idx": 187288}
{"func": "void InspectorResourceAgent::frameScheduledNavigation(Frame* frame, double)\n{\n    RefPtr<TypeBuilder::Network::Initiator> initiator = buildInitiatorObject(frame->document(), FetchInitiatorInfo());\n    m_frameNavigationInitiatorMap.set(m_pageAgent->frameId(frame), initiator);\n}\n", "target": 0, "idx": 109382}
{"func": "void Editor::RevealSelectionAfterEditingOperation(\n    const ScrollAlignment& alignment,\n    RevealExtentOption reveal_extent_option) {\n  if (prevent_reveal_selection_)\n    return;\n  if (!GetFrame().Selection().IsAvailable())\n    return;\n   GetFrame().Selection().RevealSelection(alignment, reveal_extent_option);\n }\n", "target": 0, "idx": 139372}
{"func": "get_caller_uid (GDBusMethodInvocation *context, gint *uid)\n {\n        PolkitSubject *subject;\n        PolkitSubject *process;\n \n        subject = polkit_system_bus_name_new (g_dbus_method_invocation_get_sender (context));\n        process = polkit_system_bus_name_get_process_sync (POLKIT_SYSTEM_BUS_NAME (subject), NULL, NULL);\n        if (!process) {\n                g_object_unref (subject);\n                 return FALSE;\n         }\n \n        *uid = polkit_unix_process_get_uid (POLKIT_UNIX_PROCESS (process));\n        g_object_unref (subject);\n        g_object_unref (process);\n \n         return TRUE;\n }\n", "target": 1, "idx": 178183}
{"func": "static v8::Handle<v8::Value> acceptTransferListCallback(const v8::Arguments& args)\n {\n     INC_STATS(\"DOM.TestSerializedScriptValueInterface.acceptTransferList\");\n     if (args.Length() < 1)\n        return V8Proxy::throwNotEnoughArgumentsError();\n     TestSerializedScriptValueInterface* imp = V8TestSerializedScriptValueInterface::toNative(args.Holder());\n     MessagePortArray messagePortArrayTransferList;\n     ArrayBufferArray arrayBufferArrayTransferList;\n    if (args.Length() > 1) {\n        if (!extractTransferables(args[1], messagePortArrayTransferList, arrayBufferArrayTransferList))\n            return V8Proxy::throwTypeError(\"Could not extract transferables\");\n    }\n    bool dataDidThrow = false;\n    RefPtr<SerializedScriptValue> data = SerializedScriptValue::create(args[0], &messagePortArrayTransferList, &arrayBufferArrayTransferList, dataDidThrow, args.GetIsolate());\n    if (dataDidThrow)\n        return v8::Undefined();\n    if (args.Length() <= 1) {\n        imp->acceptTransferList(data);\n        return v8::Handle<v8::Value>();\n    }\n    imp->acceptTransferList(data, messagePortArrayTransferList);\n    return v8::Handle<v8::Value>();\n}\n", "target": 1, "idx": 184799}
{"func": "pdf14_forward_device_procs(gx_device * dev)\n{\n    gx_device_forward * pdev = (gx_device_forward *)dev;\n\n    /*\n     * We are using gx_device_forward_fill_in_procs to set the various procs.\n     * This will ensure that any new device procs are also set.  However that\n     * routine only changes procs which are NULL.  Thus we start by setting all\n     * procs to NULL.\n     */\n    memset(&(pdev->procs), 0, size_of(pdev->procs));\n    gx_device_forward_fill_in_procs(pdev);\n    /*\n     * gx_device_forward_fill_in_procs does not forward all procs.\n     * Set the remainding procs to also forward.\n     */\n    set_dev_proc(dev, close_device, gx_forward_close_device);\n    set_dev_proc(dev, fill_rectangle, gx_forward_fill_rectangle);\n    set_dev_proc(dev, fill_rectangle_hl_color, gx_forward_fill_rectangle_hl_color);\n    set_dev_proc(dev, tile_rectangle, gx_forward_tile_rectangle);\n    set_dev_proc(dev, copy_mono, gx_forward_copy_mono);\n    set_dev_proc(dev, copy_color, gx_forward_copy_color);\n    set_dev_proc(dev, get_page_device, gx_forward_get_page_device);\n    set_dev_proc(dev, strip_tile_rectangle, gx_forward_strip_tile_rectangle);\n    set_dev_proc(dev, copy_alpha, gx_forward_copy_alpha);\n    set_dev_proc(dev, get_profile, gx_forward_get_profile);\n    set_dev_proc(dev, set_graphics_type_tag, gx_forward_set_graphics_type_tag);\n    /* These are forwarding devices with minor tweaks. */\n    set_dev_proc(dev, open_device, pdf14_forward_open_device);\n    set_dev_proc(dev, put_params, pdf14_forward_put_params);\n}\n", "target": 0, "idx": 2953}
{"func": "static void vrend_renderer_init_blit_ctx(struct vrend_blitter_ctx *blit_ctx)\n{\n   struct virgl_gl_ctx_param ctx_params;\n   int i;\n   if (blit_ctx->initialised) {\n      vrend_clicbs->make_current(0, blit_ctx->gl_context);\n       return;\n    }\n \n    ctx_params.shared = true;\n    ctx_params.major_ver = VREND_GL_VER_MAJOR;\n    ctx_params.minor_ver = VREND_GL_VER_MINOR;\n\n   vrend_clicbs->make_current(0, blit_ctx->gl_context);\n   glGenVertexArrays(1, &blit_ctx->vaoid);\n   glGenFramebuffers(1, &blit_ctx->fb_id);\n\n   glGenBuffers(1, &blit_ctx->vbo_id);\n   blit_build_vs_passthrough(blit_ctx);\n\n   for (i = 0; i < 4; i++)\n      blit_ctx->vertices[i][0][3] = 1; /*v.w*/\n   glBindVertexArray(blit_ctx->vaoid);\n   glBindBuffer(GL_ARRAY_BUFFER, blit_ctx->vbo_id);\n}\n", "target": 1, "idx": 178127}
{"func": "struct symbol_t* MACH0_(get_symbols)(struct MACH0_(obj_t)* bin) {\n\tconst char *symstr;\n\tstruct symbol_t *symbols;\n\tint from, to, i, j, s, stridx, symbols_size, symbols_count;\n\tSdbHash *hash;\n\n\tif (!bin || !bin->symtab || !bin->symstr) {\n\t\treturn NULL;\n\t}\n\t/* parse symbol table */\n\t/* parse dynamic symbol table */\n\tsymbols_count = (bin->dysymtab.nextdefsym + \\\n\t\t\tbin->dysymtab.nlocalsym + \\\n\t\t\tbin->dysymtab.nundefsym );\n\tsymbols_count += bin->nsymtab;\n\tsymbols_size = (symbols_count + 1) * 2 * sizeof (struct symbol_t);\n\n\tif (symbols_size < 1) {\n\t\treturn NULL;\n\t}\n\tif (!(symbols = calloc (1, symbols_size))) {\n\t\treturn NULL;\n\t}\n\thash = sdb_ht_new ();\n\tj = 0; // symbol_idx\n\tfor (s = 0; s < 2; s++) {\n\t\tswitch (s) {\n\t\tcase 0:\n\t\t\tfrom = bin->dysymtab.iextdefsym;\n\t\t\tto = from + bin->dysymtab.nextdefsym;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tfrom = bin->dysymtab.ilocalsym;\n\t\t\tto = from + bin->dysymtab.nlocalsym;\n\t\t\tbreak;\n#if NOT_USED\n\t\tcase 2:\n\t\t\tfrom = bin->dysymtab.iundefsym;\n\t\t\tto = from + bin->dysymtab.nundefsym;\n\t\t\tbreak;\n#endif\n\t\t}\n\t\tif (from == to) {\n\t\t\tcontinue;\n\t\t}\n#define OLD 1\n#if OLD\n\t\tfrom = R_MIN (R_MAX (0, from), symbols_size / sizeof (struct symbol_t));\n\t\tto = R_MIN (to , symbols_size / sizeof (struct symbol_t));\n\t\tto = R_MIN (to, bin->nsymtab);\n#else\n\t\tfrom = R_MIN (R_MAX (0, from), symbols_size/sizeof (struct symbol_t));\n\t\tto = symbols_count; //symbols_size/sizeof(struct symbol_t);\n#endif\n\t\tint maxsymbols = symbols_size / sizeof (struct symbol_t);\n\t\tif (to > 0x500000) {\n\t\t\tbprintf (\"WARNING: corrupted mach0 header: symbol table is too big %d\\n\", to);\n\t\t\tfree (symbols);\n\t\t\tsdb_ht_free (hash);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (symbols_count >= maxsymbols) {\n\t\t\tsymbols_count = maxsymbols - 1;\n\t\t}\n\t\tfor (i = from; i < to && j < symbols_count; i++, j++) {\n\t\t\tsymbols[j].offset = addr_to_offset (bin, bin->symtab[i].n_value);\n\t\t\tsymbols[j].addr = bin->symtab[i].n_value;\n\t\t\tsymbols[j].size = 0; /* TODO: Is it anywhere? */\n\t\t\tif (bin->symtab[i].n_type & N_EXT) {\n\t\t\t\tsymbols[j].type = R_BIN_MACH0_SYMBOL_TYPE_EXT;\n\t\t\t} else {\n\t\t\t\tsymbols[j].type = R_BIN_MACH0_SYMBOL_TYPE_LOCAL;\n\t\t\t}\n\t\t\tstridx = bin->symtab[i].n_strx;\n\t\t\tif (stridx >= 0 && stridx < bin->symstrlen) {\n\t\t\t\tsymstr = (char*)bin->symstr + stridx;\n\t\t\t} else {\n\t\t\t\tsymstr = \"???\";\n\t\t\t}\n\t\t\t{\n\t\t\t\tint i = 0;\n\t\t\t\tint len = 0;\n\t\t\t\tlen = bin->symstrlen - stridx;\n\t\t\t\tif (len > 0) {\n\t\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\t\tif ((ut8)(symstr[i] & 0xff) == 0xff || !symstr[i]) {\n\t\t\t\t\t\t\tlen = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tchar *symstr_dup = NULL;\n\t\t\t\t\tif (len > 0) {\n\t\t\t\t\t\tsymstr_dup = r_str_ndup (symstr, len);\n\t\t\t\t\t}\n\t\t\t\t\tif (!symstr_dup) {\n\t\t\t\t\t\tsymbols[j].name[0] = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_str_ncpy (symbols[j].name, symstr_dup, R_BIN_MACH0_STRING_LENGTH);\n\t\t\t\t\t\tr_str_filter (symbols[j].name, -1);\n\t\t\t\t\t\tsymbols[j].name[R_BIN_MACH0_STRING_LENGTH - 2] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tfree (symstr_dup);\n\t\t\t\t} else {\n\t\t\t\t\tsymbols[j].name[0] = 0;\n\t\t\t\t}\n\t\t\t\tsymbols[j].last = 0;\n\t\t\t}\n\t\t\tif (inSymtab (hash, symbols, symbols[j].name, symbols[j].addr)) {\n\t\t\t\tsymbols[j].name[0] = 0;\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t}\n\tto = R_MIN (bin->nsymtab, bin->dysymtab.iundefsym + bin->dysymtab.nundefsym);\n\tfor (i = bin->dysymtab.iundefsym; i < to; i++) {\n\t\tif (j > symbols_count) {\n \t\t\tbprintf (\"mach0-get-symbols: error\\n\");\n \t\t\tbreak;\n \t\t}\n\t\tif (parse_import_stub(bin, &symbols[j], i))\n \t\t\tsymbols[j++].last = 0;\n \t}\n \n #if 1\n\tfor (i = 0; i < bin->nsymtab; i++) {\n\t\tstruct MACH0_(nlist) *st = &bin->symtab[i];\n#if 0\n\t\tbprintf (\"stridx %d -> section %d type %d value = %d\\n\",\n\t\t\tst->n_strx, st->n_sect, st->n_type, st->n_value);\n#endif\n\t\tstridx = st->n_strx;\n\t\tif (stridx >= 0 && stridx < bin->symstrlen) {\n\t\t\tsymstr = (char*)bin->symstr + stridx;\n\t\t} else {\n\t\t\tsymstr = \"???\";\n\t\t}\n\t\tint section = st->n_sect;\n\t\tif (section == 1 && j < symbols_count) { // text ??st->n_type == 1)\n\t\t\t/* is symbol */\n\t\t\tsymbols[j].addr = st->n_value; // + text_base;\n\t\t\tsymbols[j].offset = addr_to_offset (bin, symbols[j].addr);\n\t\t\tsymbols[j].size = 0; /* find next symbol and crop */\n\t\t\tif (st->n_type & N_EXT) {\n\t\t\t\tsymbols[j].type = R_BIN_MACH0_SYMBOL_TYPE_EXT;\n\t\t\t} else {\n\t\t\t\tsymbols[j].type = R_BIN_MACH0_SYMBOL_TYPE_LOCAL;\n\t\t\t}\n\t\t\tstrncpy (symbols[j].name, symstr, R_BIN_MACH0_STRING_LENGTH);\n\t\t\tsymbols[j].name[R_BIN_MACH0_STRING_LENGTH - 1] = 0;\n\t\t\tsymbols[j].last = 0;\n\t\t\tif (inSymtab (hash, symbols, symbols[j].name, symbols[j].addr)) {\n\t\t\t\tsymbols[j].name[0] = 0;\n\t\t\t} else {\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\tsdb_ht_free (hash);\n\tsymbols[j].last = 1;\n\treturn symbols;\n}\n", "target": 1, "idx": 182398}
{"func": "xsltGetNamespace(xsltTransformContextPtr ctxt, xmlNodePtr cur, xmlNsPtr ns,\n\t         xmlNodePtr out)\n{\n\n    if (ns == NULL)\n\treturn(NULL);\n\n#ifdef XSLT_REFACTORED\n    /*\n    * Namespace exclusion and ns-aliasing is performed at\n    * compilation-time in the refactored code.\n    * Additionally, aliasing is not intended for non Literal\n    * Result Elements.\n    */\n    return(xsltGetSpecialNamespace(ctxt, cur, ns->href, ns->prefix, out));\n#else\n    {\n\txsltStylesheetPtr style;\n\tconst xmlChar *URI = NULL; /* the replacement URI */\n\n\tif ((ctxt == NULL) || (cur == NULL) || (out == NULL))\n\t    return(NULL);\n\n\tstyle = ctxt->style;\n\twhile (style != NULL) {\n\t    if (style->nsAliases != NULL)\n\t\tURI = (const xmlChar *)\n\t\txmlHashLookup(style->nsAliases, ns->href);\n\t    if (URI != NULL)\n\t\tbreak;\n\n\t    style = xsltNextImport(style);\n\t}\n\n\n\tif (URI == UNDEFINED_DEFAULT_NS) {\n\t    return(xsltGetSpecialNamespace(ctxt, cur, NULL, NULL, out));\n#if 0\n\t    /*\n\t    * TODO: Removed, since wrong. If there was no default\n\t    * namespace in the stylesheet then this must resolve to\n\t    * the NULL namespace.\n\t    */\n\t    xmlNsPtr dflt;\n\t    dflt = xmlSearchNs(cur->doc, cur, NULL);\n\t    if (dflt != NULL)\n\t\tURI = dflt->href;\n\t    else\n\t\treturn NULL;\n#endif\n\t} else if (URI == NULL)\n\t    URI = ns->href;\n\n\treturn(xsltGetSpecialNamespace(ctxt, cur, URI, ns->prefix, out));\n    }\n#endif\n}\n", "target": 0, "idx": 169923}
{"func": "status_t ACodec::setupAACCodec(\n bool encoder, int32_t numChannels, int32_t sampleRate,\n int32_t bitRate, int32_t aacProfile, bool isADTS, int32_t sbrMode,\n int32_t maxOutputChannelCount, const drcParams_t& drc,\n int32_t pcmLimiterEnable) {\n if (encoder && isADTS) {\n return -EINVAL;\n }\n\n status_t err = setupRawAudioFormat(\n            encoder ? kPortIndexInput : kPortIndexOutput,\n            sampleRate,\n            numChannels);\n\n if (err != OK) {\n return err;\n }\n\n if (encoder) {\n        err = selectAudioPortFormat(kPortIndexOutput, OMX_AUDIO_CodingAAC);\n\n if (err != OK) {\n return err;\n }\n\n        OMX_PARAM_PORTDEFINITIONTYPE def;\n InitOMXParams(&def);\n        def.nPortIndex = kPortIndexOutput;\n\n        err = mOMX->getParameter(\n                mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));\n\n if (err != OK) {\n return err;\n }\n\n        def.format.audio.bFlagErrorConcealment = OMX_TRUE;\n        def.format.audio.eEncoding = OMX_AUDIO_CodingAAC;\n\n        err = mOMX->setParameter(\n                mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));\n\n if (err != OK) {\n return err;\n }\n\n        OMX_AUDIO_PARAM_AACPROFILETYPE profile;\n InitOMXParams(&profile);\n        profile.nPortIndex = kPortIndexOutput;\n\n        err = mOMX->getParameter(\n                mNode, OMX_IndexParamAudioAac, &profile, sizeof(profile));\n\n if (err != OK) {\n return err;\n }\n\n        profile.nChannels = numChannels;\n\n        profile.eChannelMode =\n (numChannels == 1)\n ? OMX_AUDIO_ChannelModeMono: OMX_AUDIO_ChannelModeStereo;\n\n        profile.nSampleRate = sampleRate;\n        profile.nBitRate = bitRate;\n        profile.nAudioBandWidth = 0;\n        profile.nFrameLength = 0;\n        profile.nAACtools = OMX_AUDIO_AACToolAll;\n        profile.nAACERtools = OMX_AUDIO_AACERNone;\n        profile.eAACProfile = (OMX_AUDIO_AACPROFILETYPE) aacProfile;\n        profile.eAACStreamFormat = OMX_AUDIO_AACStreamFormatMP4FF;\n switch (sbrMode) {\n case 0:\n            profile.nAACtools &= ~OMX_AUDIO_AACToolAndroidSSBR;\n            profile.nAACtools &= ~OMX_AUDIO_AACToolAndroidDSBR;\n break;\n case 1:\n            profile.nAACtools |= OMX_AUDIO_AACToolAndroidSSBR;\n            profile.nAACtools &= ~OMX_AUDIO_AACToolAndroidDSBR;\n break;\n case 2:\n            profile.nAACtools &= ~OMX_AUDIO_AACToolAndroidSSBR;\n            profile.nAACtools |= OMX_AUDIO_AACToolAndroidDSBR;\n break;\n case -1:\n            profile.nAACtools |= OMX_AUDIO_AACToolAndroidSSBR;\n            profile.nAACtools |= OMX_AUDIO_AACToolAndroidDSBR;\n break;\n default:\n return BAD_VALUE;\n }\n\n\n        err = mOMX->setParameter(\n                mNode, OMX_IndexParamAudioAac, &profile, sizeof(profile));\n\n if (err != OK) {\n return err;\n }\n\n return err;\n }\n\n    OMX_AUDIO_PARAM_AACPROFILETYPE profile;\n InitOMXParams(&profile);\n    profile.nPortIndex = kPortIndexInput;\n\n    err = mOMX->getParameter(\n            mNode, OMX_IndexParamAudioAac, &profile, sizeof(profile));\n\n if (err != OK) {\n return err;\n }\n\n    profile.nChannels = numChannels;\n    profile.nSampleRate = sampleRate;\n\n    profile.eAACStreamFormat =\n        isADTS\n ? OMX_AUDIO_AACStreamFormatMP4ADTS\n\n             : OMX_AUDIO_AACStreamFormatMP4FF;\n \n     OMX_AUDIO_PARAM_ANDROID_AACPRESENTATIONTYPE presentation;\n     presentation.nMaxOutputChannels = maxOutputChannelCount;\n     presentation.nDrcCut = drc.drcCut;\n     presentation.nDrcBoost = drc.drcBoost;\n    presentation.nHeavyCompression = drc.heavyCompression;\n    presentation.nTargetReferenceLevel = drc.targetRefLevel;\n    presentation.nEncodedTargetLevel = drc.encodedTargetLevel;\n    presentation.nPCMLimiterEnable = pcmLimiterEnable;\n\n status_t res = mOMX->setParameter(mNode, OMX_IndexParamAudioAac, &profile, sizeof(profile));\n if (res == OK) {\n        mOMX->setParameter(mNode, (OMX_INDEXTYPE)OMX_IndexParamAudioAndroidAacPresentation,\n &presentation, sizeof(presentation));\n } else {\n        ALOGW(\"did not set AudioAndroidAacPresentation due to error %d when setting AudioAac\", res);\n }\n return res;\n}\n", "target": 1, "idx": 188250}
{"func": "onig_free_body(regex_t* reg)\n{\n  if (IS_NOT_NULL(reg)) {\n    ops_free(reg);\n    if (IS_NOT_NULL(reg->string_pool)) {\n      xfree(reg->string_pool);\n      reg->string_pool_end = reg->string_pool = 0;\n    }\n    if (IS_NOT_NULL(reg->exact))            xfree(reg->exact);\n    if (IS_NOT_NULL(reg->repeat_range))     xfree(reg->repeat_range);\n    if (IS_NOT_NULL(reg->extp)) {\n      free_regex_ext(reg->extp);\n      reg->extp = 0;\n    }\n\n    onig_names_free(reg);\n  }\n}\n", "target": 0, "idx": 89187}
{"func": "PasswordStoreLoginsChangedObserver::PasswordStoreLoginsChangedObserver(\n    AutomationProvider* automation,\n    IPC::Message* reply_message,\n    PasswordStoreChange::Type expected_type,\n    const std::string& result_key)\n    : automation_(automation->AsWeakPtr()),\n      reply_message_(reply_message),\n      expected_type_(expected_type),\n      result_key_(result_key),\n      done_event_(false, false) {\n  AddRef();\n}\n", "target": 0, "idx": 126034}
{"func": "scoped_refptr<PrintBackend> PrintBackend::CreateInstance(\n    const base::DictionaryValue* print_backend_settings) {\n  return new PrintBackendWin;\n}\n", "target": 0, "idx": 130206}
{"func": "DGACreateColormap(int index, ClientPtr client, int id, int mode, int alloc)\n{\n    ScreenPtr pScreen = screenInfo.screens[index];\n    DGAScreenPtr pScreenPriv = DGA_GET_SCREEN_PRIV(pScreen);\n    FakedVisualList *fvlp;\n    VisualPtr pVisual;\n    DGAModePtr pMode;\n    ColormapPtr pmap;\n\n    if (!mode || (mode > pScreenPriv->numModes))\n        return BadValue;\n\n    if ((alloc != AllocNone) && (alloc != AllocAll))\n        return BadValue;\n\n    pMode = &(pScreenPriv->modes[mode - 1]);\n\n    if (!(pVisual = malloc(sizeof(VisualRec))))\n        return BadAlloc;\n\n    pVisual->vid = FakeClientID(0);\n    pVisual->class = pMode->visualClass;\n    pVisual->nplanes = pMode->depth;\n    pVisual->ColormapEntries = 1 << pMode->depth;\n    pVisual->bitsPerRGBValue = (pMode->depth + 2) / 3;\n\n    switch (pVisual->class) {\n    case PseudoColor:\n    case GrayScale:\n    case StaticGray:\n        pVisual->bitsPerRGBValue = 8;   /* not quite */\n        pVisual->redMask = 0;\n        pVisual->greenMask = 0;\n        pVisual->blueMask = 0;\n        pVisual->offsetRed = 0;\n        pVisual->offsetGreen = 0;\n        pVisual->offsetBlue = 0;\n        break;\n    case DirectColor:\n    case TrueColor:\n        pVisual->ColormapEntries = 1 << pVisual->bitsPerRGBValue;\n        /* fall through */\n    case StaticColor:\n        pVisual->redMask = pMode->red_mask;\n        pVisual->greenMask = pMode->green_mask;\n        pVisual->blueMask = pMode->blue_mask;\n        pVisual->offsetRed = BitsClear(pVisual->redMask);\n        pVisual->offsetGreen = BitsClear(pVisual->greenMask);\n        pVisual->offsetBlue = BitsClear(pVisual->blueMask);\n    }\n\n    if (!(fvlp = malloc(sizeof(FakedVisualList)))) {\n        free(pVisual);\n        return BadAlloc;\n    }\n\n    fvlp->free = FALSE;\n    fvlp->pVisual = pVisual;\n    fvlp->next = pScreenPriv->fakedVisuals;\n    pScreenPriv->fakedVisuals = fvlp;\n\n    LEGAL_NEW_RESOURCE(id, client);\n\n    return CreateColormap(id, pScreen, pVisual, &pmap, alloc, client->index);\n}\n", "target": 0, "idx": 17703}
{"func": "store_current_palette(png_store *ps, int *npalette)\n{\n /* This is an internal error (the call has been made outside a read\n\n     * operation.)\n     */\n    if (ps->current == NULL)\n       store_log(ps, ps->pread, \"no current stream for palette\", 1);\n \n    /* The result may be null if there is no palette. */\n    *npalette = ps->current->npalette;\n return ps->current->palette;\n}\n", "target": 1, "idx": 187725}
{"func": "EncodedJSValue JSC_HOST_CALL jsTestInterfacePrototypeFunctionSupplementalMethod2(ExecState* exec)\n{\n    JSValue thisValue = exec->hostThisValue();\n    if (!thisValue.inherits(&JSTestInterface::s_info))\n        return throwVMTypeError(exec);\n    JSTestInterface* castedThis = jsCast<JSTestInterface*>(asObject(thisValue));\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestInterface::s_info);\n     TestInterface* impl = static_cast<TestInterface*>(castedThis->impl());\n     if (exec->argumentCount() < 2)\n        return throwVMError(exec, createTypeError(exec, \"Not enough arguments\"));\n     ExceptionCode ec = 0;\n     ScriptExecutionContext* scriptContext = jsCast<JSDOMGlobalObject*>(exec->lexicalGlobalObject())->scriptExecutionContext();\n     if (!scriptContext)\n        return JSValue::encode(jsUndefined());\n    const String& strArg(ustringToString(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).isEmpty() ? UString() : MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toString(exec)->value(exec)));\n    if (exec->hadException())\n        return JSValue::encode(jsUndefined());\n    TestObj* objArg(toTestObj(MAYBE_MISSING_PARAMETER(exec, 1, DefaultIsUndefined)));\n    if (exec->hadException())\n        return JSValue::encode(jsUndefined());\n\n    JSC::JSValue result = toJS(exec, castedThis->globalObject(), WTF::getPtr(TestSupplemental::supplementalMethod2(impl, scriptContext, strArg, objArg, ec)));\n    setDOMException(exec, ec);\n    return JSValue::encode(result);\n}\n", "target": 1, "idx": 184032}
{"func": "void InterstitialPageImpl::InterstitialPageRVHDelegateView::ShowPopupMenu(\n    RenderFrameHost* render_frame_host,\n    const gfx::Rect& bounds,\n    int item_height,\n    double item_font_size,\n    int selected_item,\n    const std::vector<MenuItem>& items,\n    bool right_aligned,\n    bool allow_multiple_selection) {\n  NOTREACHED() << \"InterstitialPage does not support showing popup menus.\";\n}\n", "target": 0, "idx": 148814}
{"func": "status_t SampleTable::setChunkOffsetParams(\n uint32_t type, off64_t data_offset, size_t data_size) {\n if (mChunkOffsetOffset >= 0) {\n return ERROR_MALFORMED;\n }\n\n    CHECK(type == kChunkOffsetType32 || type == kChunkOffsetType64);\n\n    mChunkOffsetOffset = data_offset;\n    mChunkOffsetType = type;\n\n if (data_size < 8) {\n return ERROR_MALFORMED;\n }\n\n uint8_t header[8];\n if (mDataSource->readAt(\n                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {\n return ERROR_IO;\n }\n\n if (U32_AT(header) != 0) {\n return ERROR_MALFORMED;\n }\n\n    mNumChunkOffsets = U32_AT(&header[4]);\n\n if (mChunkOffsetType == kChunkOffsetType32) {\n if ((data_size - 8) / 4 < mNumChunkOffsets) {\n return ERROR_MALFORMED;\n }\n } else {\n if ((data_size - 8) / 8 < mNumChunkOffsets) {\n return ERROR_MALFORMED;\n }\n }\n\n return OK;\n}\n", "target": 0, "idx": 175404}
{"func": "map_id_range_down_base(unsigned extents, struct uid_gid_map *map, u32 id, u32 count)\n{\n\tunsigned idx;\n\tu32 first, last, id2;\n\n\tid2 = id + count - 1;\n\n\t/* Find the matching extent */\n\tfor (idx = 0; idx < extents; idx++) {\n\t\tfirst = map->extent[idx].first;\n\t\tlast = first + map->extent[idx].count - 1;\n\t\tif (id >= first && id <= last &&\n\t\t    (id2 >= first && id2 <= last))\n\t\t\treturn &map->extent[idx];\n\t}\n\treturn NULL;\n}\n", "target": 0, "idx": 76185}
{"func": "TIFFFetchSubjectDistance(TIFF* tif, TIFFDirEntry* dir)\n{\n\tstatic const char module[] = \"TIFFFetchSubjectDistance\";\n\tenum TIFFReadDirEntryErr err;\n\tUInt64Aligned_t m;\n    m.l=0;\n\tassert(sizeof(double)==8);\n\tassert(sizeof(uint64)==8);\n\tassert(sizeof(uint32)==4);\n\tif (dir->tdir_count!=1)\n\t\terr=TIFFReadDirEntryErrCount;\n\telse if (dir->tdir_type!=TIFF_RATIONAL)\n\t\terr=TIFFReadDirEntryErrType;\n\telse\n\t{\n\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t{\n\t\t\tuint32 offset;\n\t\t\toffset=*(uint32*)(&dir->tdir_offset);\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong(&offset);\n\t\t\terr=TIFFReadDirEntryData(tif,offset,8,m.i);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm.l=dir->tdir_offset.toff_long8;\n\t\t\terr=TIFFReadDirEntryErrOk;\n\t\t}\n\t}\n\tif (err==TIFFReadDirEntryErrOk)\n\t{\n\t\tdouble n;\n\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\tTIFFSwabArrayOfLong(m.i,2);\n\t\tif (m.i[0]==0)\n\t\t\tn=0.0;\n\t\telse if (m.i[0]==0xFFFFFFFF)\n\t\t\t/*\n\t\t\t * XXX: Numerator 0xFFFFFFFF means that we have infinite\n\t\t\t * distance. Indicate that with a negative floating point\n\t\t\t * SubjectDistance value.\n\t\t\t */\n\t\t\tn=-1.0;\n\t\telse\n\t\t\tn=(double)m.i[0]/(double)m.i[1];\n\t\treturn(TIFFSetField(tif,dir->tdir_tag,n));\n\t}\n\telse\n\t{\n\t\tTIFFReadDirEntryOutputErr(tif,err,module,\"SubjectDistance\",TRUE);\n\t\treturn(0);\n\t}\n}\n", "target": 0, "idx": 70129}
{"func": "OMX_ERRORTYPE SoftAMR::internalGetParameter(\n        OMX_INDEXTYPE index, OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamAudioAmr:\n {\n\n             OMX_AUDIO_PARAM_AMRTYPE *amrParams =\n                 (OMX_AUDIO_PARAM_AMRTYPE *)params;\n \n             if (amrParams->nPortIndex != 0) {\n                 return OMX_ErrorUndefined;\n             }\n\n            amrParams->nChannels = 1;\n            amrParams->eAMRDTXMode = OMX_AUDIO_AMRDTXModeOff;\n            amrParams->eAMRFrameFormat = OMX_AUDIO_AMRFrameFormatFSF;\n\n if (!isConfigured()) {\n                amrParams->nBitRate = 0;\n                amrParams->eAMRBandMode = OMX_AUDIO_AMRBandModeUnused;\n } else {\n                amrParams->nBitRate = 0;\n                amrParams->eAMRBandMode =\n                    mMode == MODE_NARROW\n ? OMX_AUDIO_AMRBandModeNB0 : OMX_AUDIO_AMRBandModeWB0;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioPcm:\n {\n\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            pcmParams->nChannels = 1;\n            pcmParams->eNumData = OMX_NumericalDataSigned;\n            pcmParams->eEndian = OMX_EndianBig;\n            pcmParams->bInterleaved = OMX_TRUE;\n            pcmParams->nBitPerSample = 16;\n\n            pcmParams->nSamplingRate =\n (mMode == MODE_NARROW) ? kSampleRateNB : kSampleRateWB;\n\n            pcmParams->ePCMMode = OMX_AUDIO_PCMModeLinear;\n            pcmParams->eChannelMapping[0] = OMX_AUDIO_ChannelLF;\n            pcmParams->eChannelMapping[1] = OMX_AUDIO_ChannelRF;\n\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalGetParameter(index, params);\n }\n}\n", "target": 1, "idx": 188214}
{"func": " void RTCSessionDescriptionRequestImpl::requestFailed(const String& error)\n {\n     if (m_errorCallback)\n        m_errorCallback->handleEvent(error);\n \n     clear();\n }\n", "target": 1, "idx": 183800}
{"func": "SYSCALL_DEFINE6(move_pages, pid_t, pid, unsigned long, nr_pages,\n\t\tconst void __user * __user *, pages,\n \t\tconst int __user *, nodes,\n \t\tint __user *, status, int, flags)\n {\n\tconst struct cred *cred = current_cred(), *tcred;\n \tstruct task_struct *task;\n \tstruct mm_struct *mm;\n \tint err;\n\tnodemask_t task_nodes;\n\n\t/* Check flags */\n\tif (flags & ~(MPOL_MF_MOVE|MPOL_MF_MOVE_ALL))\n\t\treturn -EINVAL;\n\n\tif ((flags & MPOL_MF_MOVE_ALL) && !capable(CAP_SYS_NICE))\n\t\treturn -EPERM;\n\n\t/* Find the mm_struct */\n\trcu_read_lock();\n\ttask = pid ? find_task_by_vpid(pid) : current;\n\tif (!task) {\n\t\trcu_read_unlock();\n\t\treturn -ESRCH;\n\t}\n\tget_task_struct(task);\n \n \t/*\n \t * Check if this process has the right to modify the specified\n\t * process. The right exists if the process has administrative\n\t * capabilities, superuser privileges or the same\n\t * userid as the target process.\n \t */\n\ttcred = __task_cred(task);\n\tif (!uid_eq(cred->euid, tcred->suid) && !uid_eq(cred->euid, tcred->uid) &&\n\t    !uid_eq(cred->uid,  tcred->suid) && !uid_eq(cred->uid,  tcred->uid) &&\n\t    !capable(CAP_SYS_NICE)) {\n \t\trcu_read_unlock();\n \t\terr = -EPERM;\n \t\tgoto out;\n\t}\n\trcu_read_unlock();\n\n \terr = security_task_movememory(task);\n \tif (err)\n\t\tgoto out;\n\n\ttask_nodes = cpuset_mems_allowed(task);\n\tmm = get_task_mm(task);\n\tput_task_struct(task);\n\n\tif (!mm)\n\t\treturn -EINVAL;\n\n\tif (nodes)\n\t\terr = do_pages_move(mm, task_nodes, nr_pages, pages,\n\t\t\t\t    nodes, status, flags);\n\telse\n\t\terr = do_pages_stat(mm, nr_pages, pages, status);\n\n\tmmput(mm);\n\treturn err;\n\nout:\n\tput_task_struct(task);\n\treturn err;\n}\n", "target": 1, "idx": 180942}
{"func": "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list)\n{\n#if DEBUG\n\tvoid *next = *list;\n\tvoid *objp;\n\n\twhile (next) {\n\t\tobjp = next - obj_offset(cachep);\n\t\tnext = *(void **)next;\n\t\tpoison_obj(cachep, objp, POISON_FREE);\n\t}\n#endif\n}\n", "target": 0, "idx": 68877}
{"func": "bool isUserInteractionEventForSlider(Event* event, LayoutObject* layoutObject) {\n  if (isUserInteractionEvent(event))\n    return true;\n\n  LayoutSliderItem slider = LayoutSliderItem(toLayoutSlider(layoutObject));\n  if (!slider.isNull() && !slider.inDragMode())\n    return false;\n \n   const AtomicString& type = event->type();\n   return type == EventTypeNames::mouseover ||\n         type == EventTypeNames::mouseout || type == EventTypeNames::mousemove;\n }\n", "target": 1, "idx": 185778}
{"func": "Compositor::Compositor(const viz::FrameSinkId& frame_sink_id,\n                       ui::ContextFactory* context_factory,\n                       ui::ContextFactoryPrivate* context_factory_private,\n                       scoped_refptr<base::SingleThreadTaskRunner> task_runner,\n                       bool enable_surface_synchronization,\n                       bool enable_pixel_canvas,\n                       bool external_begin_frames_enabled,\n                       bool force_software_compositor,\n                       const char* trace_environment_name)\n    : context_factory_(context_factory),\n      context_factory_private_(context_factory_private),\n      frame_sink_id_(frame_sink_id),\n      task_runner_(task_runner),\n      vsync_manager_(new CompositorVSyncManager()),\n      external_begin_frames_enabled_(external_begin_frames_enabled),\n      force_software_compositor_(force_software_compositor),\n      layer_animator_collection_(this),\n      is_pixel_canvas_(enable_pixel_canvas),\n      lock_manager_(task_runner),\n      trace_environment_name_(trace_environment_name\n                                  ? trace_environment_name\n                                  : kDefaultTraceEnvironmentName),\n      context_creation_weak_ptr_factory_(this) {\n  if (context_factory_private) {\n     auto* host_frame_sink_manager =\n         context_factory_private_->GetHostFrameSinkManager();\n     host_frame_sink_manager->RegisterFrameSinkId(\n        frame_sink_id_, this, viz::ReportFirstSurfaceActivation::kYes);\n     host_frame_sink_manager->SetFrameSinkDebugLabel(frame_sink_id_,\n                                                     \"Compositor\");\n   }\n  root_web_layer_ = cc::Layer::Create();\n\n  base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();\n\n  cc::LayerTreeSettings settings;\n\n  settings.layers_always_allowed_lcd_text = true;\n  settings.use_occlusion_for_tile_prioritization = true;\n  refresh_rate_ = context_factory_->GetRefreshRate();\n  settings.main_frame_before_activation_enabled = false;\n  settings.delegated_sync_points_required =\n      context_factory_->SyncTokensRequiredForDisplayCompositor();\n\n  settings.enable_edge_anti_aliasing = false;\n\n  if (command_line->HasSwitch(switches::kLimitFps)) {\n    std::string fps_str =\n        command_line->GetSwitchValueASCII(switches::kLimitFps);\n    double fps;\n    if (base::StringToDouble(fps_str, &fps) && fps > 0) {\n      forced_refresh_rate_ = fps;\n    }\n  }\n\n  if (command_line->HasSwitch(cc::switches::kUIShowCompositedLayerBorders)) {\n    std::string layer_borders_string = command_line->GetSwitchValueASCII(\n        cc::switches::kUIShowCompositedLayerBorders);\n    std::vector<base::StringPiece> entries = base::SplitStringPiece(\n        layer_borders_string, \",\", base::TRIM_WHITESPACE, base::SPLIT_WANT_ALL);\n    if (entries.empty()) {\n      settings.initial_debug_state.show_debug_borders.set();\n    } else {\n      for (const auto& entry : entries) {\n        const struct {\n          const char* name;\n          cc::DebugBorderType type;\n        } kBorders[] = {{cc::switches::kCompositedRenderPassBorders,\n                         cc::DebugBorderType::RENDERPASS},\n                        {cc::switches::kCompositedSurfaceBorders,\n                         cc::DebugBorderType::SURFACE},\n                        {cc::switches::kCompositedLayerBorders,\n                         cc::DebugBorderType::LAYER}};\n        for (const auto& border : kBorders) {\n          if (border.name == entry) {\n            settings.initial_debug_state.show_debug_borders.set(border.type);\n            break;\n          }\n        }\n      }\n    }\n  }\n  settings.initial_debug_state.show_fps_counter =\n      command_line->HasSwitch(cc::switches::kUIShowFPSCounter);\n  settings.initial_debug_state.show_layer_animation_bounds_rects =\n      command_line->HasSwitch(cc::switches::kUIShowLayerAnimationBounds);\n  settings.initial_debug_state.show_paint_rects =\n      command_line->HasSwitch(switches::kUIShowPaintRects);\n  settings.initial_debug_state.show_property_changed_rects =\n      command_line->HasSwitch(cc::switches::kUIShowPropertyChangedRects);\n  settings.initial_debug_state.show_surface_damage_rects =\n      command_line->HasSwitch(cc::switches::kUIShowSurfaceDamageRects);\n  settings.initial_debug_state.show_screen_space_rects =\n      command_line->HasSwitch(cc::switches::kUIShowScreenSpaceRects);\n\n  settings.initial_debug_state.SetRecordRenderingStats(\n      command_line->HasSwitch(cc::switches::kEnableGpuBenchmarking));\n  settings.enable_surface_synchronization = enable_surface_synchronization;\n  settings.build_hit_test_data = features::IsVizHitTestingSurfaceLayerEnabled();\n\n  settings.use_zero_copy = IsUIZeroCopyEnabled();\n\n  settings.use_layer_lists =\n      command_line->HasSwitch(cc::switches::kUIEnableLayerLists);\n\n  settings.use_partial_raster = !settings.use_zero_copy;\n\n  settings.use_rgba_4444 =\n      command_line->HasSwitch(switches::kUIEnableRGBA4444Textures);\n\n#if defined(OS_MACOSX)\n  settings.resource_settings.use_gpu_memory_buffer_resources =\n      settings.use_zero_copy;\n  settings.enable_elastic_overscroll = true;\n#endif\n\n  settings.memory_policy.bytes_limit_when_visible = 512 * 1024 * 1024;\n  settings.memory_policy.priority_cutoff_when_visible =\n      gpu::MemoryAllocation::CUTOFF_ALLOW_NICE_TO_HAVE;\n\n  settings.disallow_non_exact_resource_reuse =\n      command_line->HasSwitch(switches::kDisallowNonExactResourceReuse);\n\n  if (command_line->HasSwitch(switches::kRunAllCompositorStagesBeforeDraw)) {\n    settings.wait_for_all_pipeline_stages_before_draw = true;\n    settings.enable_latency_recovery = false;\n  }\n\n  settings.always_request_presentation_time =\n      command_line->HasSwitch(cc::switches::kAlwaysRequestPresentationTime);\n\n  animation_host_ = cc::AnimationHost::CreateMainInstance();\n\n  cc::LayerTreeHost::InitParams params;\n  params.client = this;\n  params.task_graph_runner = context_factory_->GetTaskGraphRunner();\n  params.settings = &settings;\n  params.main_task_runner = task_runner_;\n  params.mutator_host = animation_host_.get();\n  host_ = cc::LayerTreeHost::CreateSingleThreaded(this, std::move(params));\n\n  if (base::FeatureList::IsEnabled(features::kUiCompositorScrollWithLayers) &&\n      host_->GetInputHandler()) {\n    scroll_input_handler_.reset(\n        new ScrollInputHandler(host_->GetInputHandler()));\n  }\n\n  animation_timeline_ =\n      cc::AnimationTimeline::Create(cc::AnimationIdProvider::NextTimelineId());\n  animation_host_->AddAnimationTimeline(animation_timeline_.get());\n\n  host_->SetHasGpuRasterizationTrigger(features::IsUiGpuRasterizationEnabled());\n  host_->SetRootLayer(root_web_layer_);\n  host_->SetVisible(true);\n\n  if (command_line->HasSwitch(switches::kUISlowAnimations)) {\n    slow_animations_ = std::make_unique<ScopedAnimationDurationScaleMode>(\n        ScopedAnimationDurationScaleMode::SLOW_DURATION);\n  }\n}\n", "target": 1, "idx": 186537}
{"func": "bool CopyDirectory(const FilePath& from_path,\n                   const FilePath& to_path,\n                   bool recursive) {\n  base::ThreadRestrictions::AssertIOAllowed();\n  DCHECK(to_path.value().find('*') == std::string::npos);\n  DCHECK(from_path.value().find('*') == std::string::npos);\n\n  char top_dir[PATH_MAX];\n  if (base::strlcpy(top_dir, from_path.value().c_str(),\n                    arraysize(top_dir)) >= arraysize(top_dir)) {\n    return false;\n  }\n\n  FilePath real_to_path = to_path;\n  if (PathExists(real_to_path)) {\n    if (!AbsolutePath(&real_to_path))\n      return false;\n  } else {\n    real_to_path = real_to_path.DirName();\n    if (!AbsolutePath(&real_to_path))\n      return false;\n  }\n  FilePath real_from_path = from_path;\n  if (!AbsolutePath(&real_from_path))\n    return false;\n  if (real_to_path.value().size() >= real_from_path.value().size() &&\n      real_to_path.value().compare(0, real_from_path.value().size(),\n      real_from_path.value()) == 0)\n    return false;\n\n  bool success = true;\n  int traverse_type = FileEnumerator::FILES | FileEnumerator::SHOW_SYM_LINKS;\n  if (recursive)\n    traverse_type |= FileEnumerator::DIRECTORIES;\n  FileEnumerator traversal(from_path, recursive, traverse_type);\n\n  FileEnumerator::FindInfo info;\n  FilePath current = from_path;\n  if (stat(from_path.value().c_str(), &info.stat) < 0) {\n    DLOG(ERROR) << \"CopyDirectory() couldn't stat source directory: \"\n                << from_path.value() << \" errno = \" << errno;\n    success = false;\n  }\n  struct stat to_path_stat;\n  FilePath from_path_base = from_path;\n  if (recursive && stat(to_path.value().c_str(), &to_path_stat) == 0 &&\n      S_ISDIR(to_path_stat.st_mode)) {\n    from_path_base = from_path.DirName();\n  }\n\n   DCHECK(recursive || S_ISDIR(info.stat.st_mode));\n \n   while (success && !current.empty()) {\n    std::string suffix(&current.value().c_str()[from_path_base.value().size()]);\n    if (!suffix.empty()) {\n      DCHECK_EQ('/', suffix[0]);\n      suffix.erase(0, 1);\n     }\n    const FilePath target_path = to_path.Append(suffix);\n \n     if (S_ISDIR(info.stat.st_mode)) {\n       if (mkdir(target_path.value().c_str(), info.stat.st_mode & 01777) != 0 &&\n          errno != EEXIST) {\n        DLOG(ERROR) << \"CopyDirectory() couldn't create directory: \"\n                    << target_path.value() << \" errno = \" << errno;\n        success = false;\n      }\n    } else if (S_ISREG(info.stat.st_mode)) {\n      if (!CopyFile(current, target_path)) {\n        DLOG(ERROR) << \"CopyDirectory() couldn't create file: \"\n                    << target_path.value();\n        success = false;\n      }\n    } else {\n      DLOG(WARNING) << \"CopyDirectory() skipping non-regular file: \"\n                    << current.value();\n    }\n\n    current = traversal.Next();\n    traversal.GetFindInfo(&info);\n  }\n\n  return success;\n}\n", "target": 1, "idx": 185107}
{"func": "int ext4_insert_range(struct inode *inode, loff_t offset, loff_t len)\n{\n\tstruct super_block *sb = inode->i_sb;\n\thandle_t *handle;\n\tstruct ext4_ext_path *path;\n\tstruct ext4_extent *extent;\n\text4_lblk_t offset_lblk, len_lblk, ee_start_lblk = 0;\n\tunsigned int credits, ee_len;\n\tint ret = 0, depth, split_flag = 0;\n\tloff_t ioffset;\n\n\t/*\n\t * We need to test this early because xfstests assumes that an\n\t * insert range of (0, 1) will return EOPNOTSUPP if the file\n\t * system does not support insert range.\n\t */\n\tif (!ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\treturn -EOPNOTSUPP;\n\n\t/* Insert range works only on fs block size aligned offsets. */\n\tif (offset & (EXT4_CLUSTER_SIZE(sb) - 1) ||\n\t\t\tlen & (EXT4_CLUSTER_SIZE(sb) - 1))\n\t\treturn -EINVAL;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\n\ttrace_ext4_insert_range(inode, offset, len);\n\n\toffset_lblk = offset >> EXT4_BLOCK_SIZE_BITS(sb);\n\tlen_lblk = len >> EXT4_BLOCK_SIZE_BITS(sb);\n\n\t/* Call ext4_force_commit to flush all data in case of data=journal */\n\tif (ext4_should_journal_data(inode)) {\n\t\tret = ext4_force_commit(inode->i_sb);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * Need to round down to align start offset to page size boundary\n\t * for page size > block size.\n\t */\n\tioffset = round_down(offset, PAGE_SIZE);\n\n\t/* Write out all dirty pages */\n\tret = filemap_write_and_wait_range(inode->i_mapping, ioffset,\n\t\t\tLLONG_MAX);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Take mutex lock */\n\tmutex_lock(&inode->i_mutex);\n\n\t/* Currently just for extent based files */\n\tif (!ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out_mutex;\n\t}\n\n\t/* Check for wrap through zero */\n\tif (inode->i_size + len > inode->i_sb->s_maxbytes) {\n\t\tret = -EFBIG;\n\t\tgoto out_mutex;\n\t}\n\n\t/* Offset should be less than i_size */\n\tif (offset >= i_size_read(inode)) {\n\t\tret = -EINVAL;\n \t\tgoto out_mutex;\n \t}\n \n\ttruncate_pagecache(inode, ioffset);\n \t/* Wait for existing dio to complete */\n \text4_inode_block_unlocked_dio(inode);\n \tinode_dio_wait(inode);\n \n \tcredits = ext4_writepage_trans_blocks(inode);\n \thandle = ext4_journal_start(inode, EXT4_HT_TRUNCATE, credits);\n \tif (IS_ERR(handle)) {\n \t\tret = PTR_ERR(handle);\n\t\tgoto out_dio;\n \t}\n \n \t/* Expand file to avoid data loss if there is error while shifting */\n\tinode->i_size += len;\n\tEXT4_I(inode)->i_disksize += len;\n\tinode->i_mtime = inode->i_ctime = ext4_current_time(inode);\n\tret = ext4_mark_inode_dirty(handle, inode);\n\tif (ret)\n\t\tgoto out_stop;\n\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\text4_discard_preallocations(inode);\n\n\tpath = ext4_find_extent(inode, offset_lblk, NULL, 0);\n\tif (IS_ERR(path)) {\n\t\tup_write(&EXT4_I(inode)->i_data_sem);\n\t\tgoto out_stop;\n\t}\n\n\tdepth = ext_depth(inode);\n\textent = path[depth].p_ext;\n\tif (extent) {\n\t\tee_start_lblk = le32_to_cpu(extent->ee_block);\n\t\tee_len = ext4_ext_get_actual_len(extent);\n\n\t\t/*\n\t\t * If offset_lblk is not the starting block of extent, split\n\t\t * the extent @offset_lblk\n\t\t */\n\t\tif ((offset_lblk > ee_start_lblk) &&\n\t\t\t\t(offset_lblk < (ee_start_lblk + ee_len))) {\n\t\t\tif (ext4_ext_is_unwritten(extent))\n\t\t\t\tsplit_flag = EXT4_EXT_MARK_UNWRIT1 |\n\t\t\t\t\tEXT4_EXT_MARK_UNWRIT2;\n\t\t\tret = ext4_split_extent_at(handle, inode, &path,\n\t\t\t\t\toffset_lblk, split_flag,\n\t\t\t\t\tEXT4_EX_NOCACHE |\n\t\t\t\t\tEXT4_GET_BLOCKS_PRE_IO |\n\t\t\t\t\tEXT4_GET_BLOCKS_METADATA_NOFAIL);\n\t\t}\n\n\t\text4_ext_drop_refs(path);\n\t\tkfree(path);\n\t\tif (ret < 0) {\n\t\t\tup_write(&EXT4_I(inode)->i_data_sem);\n\t\t\tgoto out_stop;\n\t\t}\n\t}\n\n\tret = ext4_es_remove_extent(inode, offset_lblk,\n\t\t\tEXT_MAX_BLOCKS - offset_lblk);\n\tif (ret) {\n\t\tup_write(&EXT4_I(inode)->i_data_sem);\n\t\tgoto out_stop;\n\t}\n\n\t/*\n\t * if offset_lblk lies in a hole which is at start of file, use\n\t * ee_start_lblk to shift extents\n\t */\n\tret = ext4_ext_shift_extents(inode, handle,\n\t\tee_start_lblk > offset_lblk ? ee_start_lblk : offset_lblk,\n\t\tlen_lblk, SHIFT_RIGHT);\n\n\tup_write(&EXT4_I(inode)->i_data_sem);\n\tif (IS_SYNC(inode))\n\t\text4_handle_sync(handle);\n \n out_stop:\n \text4_journal_stop(handle);\nout_dio:\n \text4_inode_resume_unlocked_dio(inode);\n out_mutex:\n \tmutex_unlock(&inode->i_mutex);\n\treturn ret;\n}\n", "target": 1, "idx": 180656}
{"func": "static void picolcd_remove(struct hid_device *hdev)\n{\n\tstruct picolcd_data *data = hid_get_drvdata(hdev);\n\tunsigned long flags;\n\n\tdbg_hid(PICOLCD_NAME \" hardware remove...\\n\");\n\tspin_lock_irqsave(&data->lock, flags);\n\tdata->status |= PICOLCD_FAILED;\n\tspin_unlock_irqrestore(&data->lock, flags);\n\n\tpicolcd_exit_devfs(data);\n\tdevice_remove_file(&hdev->dev, &dev_attr_operation_mode);\n\tdevice_remove_file(&hdev->dev, &dev_attr_operation_mode_delay);\n\thid_hw_close(hdev);\n\thid_hw_stop(hdev);\n\n\t/* Shortcut potential pending reply that will never arrive */\n\tspin_lock_irqsave(&data->lock, flags);\n\tif (data->pending)\n\t\tcomplete(&data->pending->ready);\n\tspin_unlock_irqrestore(&data->lock, flags);\n\n\t/* Cleanup LED */\n\tpicolcd_exit_leds(data);\n\t/* Clean up the framebuffer */\n\tpicolcd_exit_backlight(data);\n\tpicolcd_exit_lcd(data);\n\tpicolcd_exit_framebuffer(data);\n\t/* Cleanup input */\n\tpicolcd_exit_cir(data);\n\tpicolcd_exit_keys(data);\n\n\thid_set_drvdata(hdev, NULL);\n\tmutex_destroy(&data->mutex);\n\t/* Finally, clean up the picolcd data itself */\n\tkfree(data);\n}\n", "target": 0, "idx": 38076}
{"func": "void SyncBackendHost::HandleConnectionStatusChangeOnFrontendLoop(\n    sync_api::ConnectionStatus status) {\n  if (!frontend_)\n    return;\n\n  DCHECK_EQ(MessageLoop::current(), frontend_loop_);\n\n  frontend_->OnConnectionStatusChange(status);\n}\n", "target": 0, "idx": 111801}
{"func": "static MagickBooleanType WriteJBIGImage(const ImageInfo *image_info,\n  Image *image)\n{\n  double\n    version;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  MemoryInfo\n    *pixel_info;\n\n  register const PixelPacket\n    *p;\n\n  register ssize_t\n    x;\n\n  register unsigned char\n    *q;\n\n  size_t\n    number_packets;\n\n  ssize_t\n    y;\n\n  struct jbg_enc_state\n    jbig_info;\n\n  unsigned char\n    bit,\n    byte,\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(status);\n  version=StringToDouble(JBG_VERSION,(char **) NULL);\n  scene=0;\n  do\n  {\n    /*\n      Allocate pixel data.\n    */\n    (void) TransformImageColorspace(image,sRGBColorspace);\n    number_packets=(image->columns+7)/8;\n    pixel_info=AcquireVirtualMemory(number_packets,image->rows*sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    /*\n      Convert pixels to a bitmap.\n    */\n    (void) SetImageType(image,BilevelType);\n    q=pixels;\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n      if (p == (const PixelPacket *) NULL)\n        break;\n      bit=0;\n      byte=0;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        byte<<=1;\n        if (GetPixelLuma(image,p) < (QuantumRange/2.0))\n          byte|=0x01;\n        bit++;\n        if (bit == 8)\n          {\n            *q++=byte;\n            bit=0;\n            byte=0;\n          }\n        p++;\n      }\n      if (bit != 0)\n        *q++=byte << (8-bit);\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n    /*\n      Initialize JBIG info structure.\n    */\n    jbg_enc_init(&jbig_info,(unsigned long) image->columns,(unsigned long)\n      image->rows,1,&pixels,(void (*)(unsigned char *,size_t,void *))\n      JBIGEncode,image);\n    if (image_info->scene != 0)\n      jbg_enc_layers(&jbig_info,(int) image_info->scene);\n    else\n      {\n        size_t\n          x_resolution,\n          y_resolution;\n\n        x_resolution=640;\n        y_resolution=480;\n        if (image_info->density != (char *) NULL)\n          {\n            GeometryInfo\n              geometry_info;\n\n            MagickStatusType\n              flags;\n\n            flags=ParseGeometry(image_info->density,&geometry_info);\n            x_resolution=geometry_info.rho;\n            y_resolution=geometry_info.sigma;\n            if ((flags & SigmaValue) == 0)\n              y_resolution=x_resolution;\n          }\n        if (image->units == PixelsPerCentimeterResolution)\n          {\n            x_resolution=(size_t) (100.0*2.54*x_resolution+0.5)/100.0;\n            y_resolution=(size_t) (100.0*2.54*y_resolution+0.5)/100.0;\n          }\n        (void) jbg_enc_lrlmax(&jbig_info,(unsigned long) x_resolution,\n          (unsigned long) y_resolution);\n      }\n    (void) jbg_enc_lrange(&jbig_info,-1,-1);\n    jbg_enc_options(&jbig_info,JBG_ILEAVE | JBG_SMID,JBG_TPDON | JBG_TPBON |\n      JBG_DPON,version < 1.6 ? -1 : 0,-1,-1);\n    /*\n      Write JBIG image.\n    */\n    jbg_enc_out(&jbig_info);\n    jbg_enc_free(&jbig_info);\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n", "target": 0, "idx": 71581}
{"func": " bool IsSiteMuted(const TabStripModel& tab_strip, const int index) {\n   content::WebContents* web_contents = tab_strip.GetWebContentsAt(index);\n   GURL url = web_contents->GetLastCommittedURL();\n \n  if (url.SchemeIs(content::kChromeUIScheme)) {\n    return web_contents->IsAudioMuted() &&\n           GetTabAudioMutedReason(web_contents) ==\n               TabMutedReason::CONTENT_SETTING_CHROME;\n  }\n\n  Profile* profile =\n      Profile::FromBrowserContext(web_contents->GetBrowserContext());\n  HostContentSettingsMap* settings =\n      HostContentSettingsMapFactory::GetForProfile(profile);\n  return settings->GetContentSetting(url, url, CONTENT_SETTINGS_TYPE_SOUND,\n                                     std::string()) == CONTENT_SETTING_BLOCK;\n}\n", "target": 1, "idx": 185775}
{"func": "parse_group_prop_ntr_selection_method(struct ofpbuf *payload,\n                                      enum ofp11_group_type group_type,\n                                      enum ofp15_group_mod_command group_cmd,\n                                      struct ofputil_group_props *gp)\n{\n    struct ntr_group_prop_selection_method *prop = payload->data;\n    size_t fields_len, method_len;\n    enum ofperr error;\n\n    switch (group_type) {\n    case OFPGT11_SELECT:\n        break;\n    case OFPGT11_ALL:\n    case OFPGT11_INDIRECT:\n    case OFPGT11_FF:\n        OFPPROP_LOG(&bad_ofmsg_rl, false, \"ntr selection method property is \"\n                     \"only allowed for select groups\");\n         return OFPERR_OFPBPC_BAD_VALUE;\n     default:\n        OVS_NOT_REACHED();\n     }\n \n     switch (group_cmd) {\n    case OFPGC15_ADD:\n    case OFPGC15_MODIFY:\n    case OFPGC15_ADD_OR_MOD:\n        break;\n    case OFPGC15_DELETE:\n    case OFPGC15_INSERT_BUCKET:\n    case OFPGC15_REMOVE_BUCKET:\n        OFPPROP_LOG(&bad_ofmsg_rl, false, \"ntr selection method property is \"\n                     \"only allowed for add and delete group modifications\");\n         return OFPERR_OFPBPC_BAD_VALUE;\n     default:\n        OVS_NOT_REACHED();\n     }\n \n     if (payload->size < sizeof *prop) {\n        OFPPROP_LOG(&bad_ofmsg_rl, false, \"ntr selection method property \"\n                    \"length %u is not valid\", payload->size);\n        return OFPERR_OFPBPC_BAD_LEN;\n    }\n\n    method_len = strnlen(prop->selection_method, NTR_MAX_SELECTION_METHOD_LEN);\n\n    if (method_len == NTR_MAX_SELECTION_METHOD_LEN) {\n        OFPPROP_LOG(&bad_ofmsg_rl, false,\n                    \"ntr selection method is not null terminated\");\n        return OFPERR_OFPBPC_BAD_VALUE;\n    }\n\n    if (strcmp(\"hash\", prop->selection_method)\n        && strcmp(\"dp_hash\", prop->selection_method)) {\n        OFPPROP_LOG(&bad_ofmsg_rl, false,\n                    \"ntr selection method '%s' is not supported\",\n                    prop->selection_method);\n        return OFPERR_OFPBPC_BAD_VALUE;\n    }\n    /* 'method_len' is now non-zero. */\n\n    strcpy(gp->selection_method, prop->selection_method);\n    gp->selection_method_param = ntohll(prop->selection_method_param);\n\n    ofpbuf_pull(payload, sizeof *prop);\n\n    fields_len = ntohs(prop->length) - sizeof *prop;\n    if (fields_len && strcmp(\"hash\", gp->selection_method)) {\n        OFPPROP_LOG(&bad_ofmsg_rl, false, \"ntr selection method %s \"\n                    \"does not support fields\", gp->selection_method);\n        return OFPERR_OFPBPC_BAD_VALUE;\n    }\n\n    error = oxm_pull_field_array(payload->data, fields_len,\n                                 &gp->fields);\n    if (error) {\n        OFPPROP_LOG(&bad_ofmsg_rl, false,\n                    \"ntr selection method fields are invalid\");\n        return error;\n    }\n\n    return 0;\n}\n", "target": 1, "idx": 182197}
{"func": "void AppCacheUpdateJob::OnResponseInfoLoaded(\n    AppCacheResponseInfo* response_info, int64 response_id) {\n  const net::HttpResponseInfo* http_info = response_info ?\n      response_info->http_response_info() : NULL;\n\n  if (internal_state_ == FETCH_MANIFEST) {\n    if (http_info)\n      manifest_fetcher_->set_existing_response_headers(\n          http_info->headers.get());\n    manifest_fetcher_->Start();\n    return;\n  }\n\n  LoadingResponses::iterator found = loading_responses_.find(response_id);\n  DCHECK(found != loading_responses_.end());\n  const GURL& url = found->second;\n\n  if (!http_info) {\n    LoadFromNewestCacheFailed(url, NULL);  // no response found\n  } else {\n    const std::string name = \"vary\";\n    std::string value;\n    void* iter = NULL;\n    if (!http_info->headers.get() ||\n        http_info->headers->RequiresValidation(http_info->request_time,\n                                               http_info->response_time,\n                                               base::Time::Now()) ||\n        http_info->headers->EnumerateHeader(&iter, name, &value)) {\n      LoadFromNewestCacheFailed(url, response_info);\n    } else {\n      DCHECK(group_->newest_complete_cache());\n      AppCacheEntry* copy_me = group_->newest_complete_cache()->GetEntry(url);\n      DCHECK(copy_me);\n      DCHECK(copy_me->response_id() == response_id);\n\n      AppCache::EntryMap::iterator it = url_file_list_.find(url);\n      DCHECK(it != url_file_list_.end());\n      AppCacheEntry& entry = it->second;\n      entry.set_response_id(response_id);\n      entry.set_response_size(copy_me->response_size());\n      inprogress_cache_->AddOrModifyEntry(url, entry);\n      NotifyAllProgress(url);\n      ++url_fetches_completed_;\n    }\n  }\n  loading_responses_.erase(found);\n\n  MaybeCompleteUpdate();\n}\n", "target": 0, "idx": 135027}
{"func": "void exit_creds(struct task_struct *tsk)\n{\n\tstruct cred *cred;\n\n\tkdebug(\"exit_creds(%u,%p,%p,{%d,%d})\", tsk->pid, tsk->real_cred, tsk->cred,\n\t       atomic_read(&tsk->cred->usage),\n\t       read_cred_subscribers(tsk->cred));\n\n\tcred = (struct cred *) tsk->real_cred;\n\ttsk->real_cred = NULL;\n\tvalidate_creds(cred);\n\talter_cred_subscribers(cred, -1);\n\tput_cred(cred);\n\n\tcred = (struct cred *) tsk->cred;\n\ttsk->cred = NULL;\n\tvalidate_creds(cred);\n\talter_cred_subscribers(cred, -1);\n\tput_cred(cred);\n\n\tcred = (struct cred *) tsk->replacement_session_keyring;\n\tif (cred) {\n\t\ttsk->replacement_session_keyring = NULL;\n\t\tvalidate_creds(cred);\n\t\tput_cred(cred);\n\t}\n}\n", "target": 0, "idx": 19605}
{"func": "cdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h,\n    uint32_t offs, cdf_property_info_t **info, size_t *count, size_t *maxcount)\n{\n\tconst cdf_section_header_t *shp;\n\tcdf_section_header_t sh;\n\tconst uint8_t *p, *q, *e;\n\tint16_t s16;\n\tint32_t s32;\n\tuint32_t u32;\n\tint64_t s64;\n\tuint64_t u64;\n\tcdf_timestamp_t tp;\n\tsize_t i, o, o4, nelements, j;\n\tcdf_property_info_t *inp;\n\n\tif (offs > UINT32_MAX / 4) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tshp = CAST(const cdf_section_header_t *, (const void *)\n\t    ((const char *)sst->sst_tab + offs));\n\tif (cdf_check_stream_offset(sst, h, shp, sizeof(*shp), __LINE__) == -1)\n\t\tgoto out;\n\tsh.sh_len = CDF_TOLE4(shp->sh_len);\n#define CDF_SHLEN_LIMIT (UINT32_MAX / 8)\n\tif (sh.sh_len > CDF_SHLEN_LIMIT) {\n\t\terrno = EFTYPE;\n\t\tgoto out;\n\t}\n\tsh.sh_properties = CDF_TOLE4(shp->sh_properties);\n#define CDF_PROP_LIMIT (UINT32_MAX / (4 * sizeof(*inp)))\n\tif (sh.sh_properties > CDF_PROP_LIMIT)\n\t\tgoto out;\n\tDPRINTF((\"section len: %u properties %u\\n\", sh.sh_len,\n\t    sh.sh_properties));\n\tif (*maxcount) {\n\t\tif (*maxcount > CDF_PROP_LIMIT)\n\t\t\tgoto out;\n\t\t*maxcount += sh.sh_properties;\n\t\tinp = CAST(cdf_property_info_t *,\n\t\t    realloc(*info, *maxcount * sizeof(*inp)));\n\t} else {\n\t\t*maxcount = sh.sh_properties;\n\t\tinp = CAST(cdf_property_info_t *,\n\t\t    malloc(*maxcount * sizeof(*inp)));\n\t}\n\tif (inp == NULL)\n\t\tgoto out;\n\t*info = inp;\n\tinp += *count;\n\t*count += sh.sh_properties;\n\tp = CAST(const uint8_t *, (const void *)\n\t    ((const char *)(const void *)sst->sst_tab +\n\t    offs + sizeof(sh)));\n\te = CAST(const uint8_t *, (const void *)\n\t    (((const char *)(const void *)shp) + sh.sh_len));\n\tif (cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1)\n\t\tgoto out;\n\tfor (i = 0; i < sh.sh_properties; i++) {\n\t\tq = (const uint8_t *)(const void *)\n\t\t    ((const char *)(const void *)p +\n\t\t    CDF_GETUINT32(p, (i << 1) + 1)) - 2 * sizeof(uint32_t);\n\t\tif (q > e) {\n\t\t\tDPRINTF((\"Ran of the end %p > %p\\n\", q, e));\n\t\t\tgoto out;\n\t\t}\n\t\tinp[i].pi_id = CDF_GETUINT32(p, i << 1);\n\t\tinp[i].pi_type = CDF_GETUINT32(q, 0);\n\t\tDPRINTF((\"%d) id=%x type=%x offs=%x,%d\\n\", i, inp[i].pi_id,\n\t\t    inp[i].pi_type, q - p, CDF_GETUINT32(p, (i << 1) + 1)));\n\t\tif (inp[i].pi_type & CDF_VECTOR) {\n\t\t\tnelements = CDF_GETUINT32(q, 1);\n\t\t\to = 2;\n\t\t} else {\n\t\t\tnelements = 1;\n\t\t\to = 1;\n\t\t}\n\t\to4 = o * sizeof(uint32_t);\n\t\tif (inp[i].pi_type & (CDF_ARRAY|CDF_BYREF|CDF_RESERVED))\n\t\t\tgoto unknown;\n\t\tswitch (inp[i].pi_type & CDF_TYPEMASK) {\n\t\tcase CDF_NULL:\n\t\tcase CDF_EMPTY:\n\t\t\tbreak;\n\t\tcase CDF_SIGNED16:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s16, &q[o4], sizeof(s16));\n\t\t\tinp[i].pi_s16 = CDF_TOLE2(s16);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED32:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s32, &q[o4], sizeof(s32));\n\t\t\tinp[i].pi_s32 = CDF_TOLE4((uint32_t)s32);\n\t\t\tbreak;\n\t\tcase CDF_BOOL:\n\t\tcase CDF_UNSIGNED32:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u32, &q[o4], sizeof(u32));\n\t\t\tinp[i].pi_u32 = CDF_TOLE4(u32);\n\t\t\tbreak;\n\t\tcase CDF_SIGNED64:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&s64, &q[o4], sizeof(s64));\n\t\t\tinp[i].pi_s64 = CDF_TOLE8((uint64_t)s64);\n\t\t\tbreak;\n\t\tcase CDF_UNSIGNED64:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&u64, &q[o4], sizeof(u64));\n\t\t\tinp[i].pi_u64 = CDF_TOLE8((uint64_t)u64);\n\t\t\tbreak;\n\t\tcase CDF_LENGTH32_STRING:\n\t\tcase CDF_LENGTH32_WSTRING:\n\t\t\tif (nelements > 1) {\n\t\t\t\tsize_t nelem = inp - *info;\n\t\t\t\tif (*maxcount > CDF_PROP_LIMIT\n\t\t\t\t    || nelements > CDF_PROP_LIMIT)\n\t\t\t\t\tgoto out;\n\t\t\t\t*maxcount += nelements;\n\t\t\t\tinp = CAST(cdf_property_info_t *,\n\t\t\t\t    realloc(*info, *maxcount * sizeof(*inp)));\n\t\t\t\tif (inp == NULL)\n\t\t\t\t\tgoto out;\n\t\t\t\t*info = inp;\n\t\t\t\tinp = *info + nelem;\n\t\t\t}\n\t\t\tDPRINTF((\"nelements = %d\\n\", nelements));\n\t\t\tfor (j = 0; j < nelements; j++, i++) {\n\t\t\t\tuint32_t l = CDF_GETUINT32(q, o);\n\t\t\t\tinp[i].pi_str.s_len = l;\n\t\t\t\tinp[i].pi_str.s_buf = (const char *)\n\t\t\t\t    (const void *)(&q[o4 + sizeof(l)]);\n\t\t\t\tDPRINTF((\"l = %d, r = %d, s = %s\\n\", l,\n\t\t\t\t    CDF_ROUND(l, sizeof(l)),\n \t\t\t\t    inp[i].pi_str.s_buf));\n \t\t\t\tl = 4 + (uint32_t)CDF_ROUND(l, sizeof(l));\n \t\t\t\to += l >> 2;\n \t\t\t\to4 = o * sizeof(uint32_t);\n \t\t\t}\n \t\t\ti--;\n\t\t\tbreak;\n\t\tcase CDF_FILETIME:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\t(void)memcpy(&tp, &q[o4], sizeof(tp));\n\t\t\tinp[i].pi_tp = CDF_TOLE8((uint64_t)tp);\n\t\t\tbreak;\n\t\tcase CDF_CLIPBOARD:\n\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n\t\t\t\tgoto unknown;\n\t\t\tbreak;\n\t\tdefault:\n\t\tunknown:\n\t\t\tDPRINTF((\"Don't know how to deal with %x\\n\",\n\t\t\t    inp[i].pi_type));\n\t\t\tgoto out;\n\t\t}\n\t}\n\treturn 0;\nout:\n\tfree(*info);\n\treturn -1;\n}\n", "target": 1, "idx": 183054}
{"func": "void br_netfilter_rtable_init(struct net_bridge *br)\n{\n\tstruct rtable *rt = &br->fake_rtable;\n\n\tatomic_set(&rt->dst.__refcnt, 1);\n\trt->dst.dev = br->dev;\n\trt->dst.path = &rt->dst;\n\tdst_metric_set(&rt->dst, RTAX_MTU, 1500);\n\trt->dst.flags\t= DST_NOXFRM;\n\trt->dst.ops = &fake_dst_ops;\n}\n", "target": 0, "idx": 34706}
{"func": "int orangefs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tstruct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);\n\tint error = 0;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tconst char *name = NULL;\n\n\tswitch (type) {\n \tcase ACL_TYPE_ACCESS:\n \t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n\t\t\tumode_t mode = inode->i_mode;\n\t\t\t/*\n\t\t\t * can we represent this with the traditional file\n\t\t\t * mode permission bits?\n\t\t\t */\n\t\t\terror = posix_acl_equiv_mode(acl, &mode);\n\t\t\tif (error < 0) {\n\t\t\t\tgossip_err(\"%s: posix_acl_equiv_mode err: %d\\n\",\n \t\t\t\t\t   __func__,\n \t\t\t\t\t   error);\n \t\t\t\treturn error;\n\t\t\t}\n\n\t\t\tif (inode->i_mode != mode)\n \t\t\t\tSetModeFlag(orangefs_inode);\n \t\t\tinode->i_mode = mode;\n \t\t\tmark_inode_dirty_sync(inode);\n\t\t\tif (error == 0)\n\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \tcase ACL_TYPE_DEFAULT:\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tgossip_err(\"%s: invalid type %d!\\n\", __func__, type);\n\t\treturn -EINVAL;\n\t}\n\n\tgossip_debug(GOSSIP_ACL_DEBUG,\n\t\t     \"%s: inode %pU, key %s type %d\\n\",\n\t\t     __func__, get_khandle_from_ino(inode),\n\t\t     name,\n\t\t     type);\n\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmalloc(size, GFP_KERNEL);\n\t\tif (!value)\n\t\t\treturn -ENOMEM;\n\n\t\terror = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (error < 0)\n\t\t\tgoto out;\n\t}\n\n\tgossip_debug(GOSSIP_ACL_DEBUG,\n\t\t     \"%s: name %s, value %p, size %zd, acl %p\\n\",\n\t\t     __func__, name, value, size, acl);\n\t/*\n\t * Go ahead and set the extended attribute now. NOTE: Suppose acl\n\t * was NULL, then value will be NULL and size will be 0 and that\n\t * will xlate to a removexattr. However, we don't want removexattr\n\t * complain if attributes does not exist.\n\t */\n\terror = orangefs_inode_setxattr(inode, name, value, size, 0);\n\nout:\n\tkfree(value);\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\treturn error;\n}\n", "target": 1, "idx": 180149}
{"func": "void RenderFrameHostImpl::OnJavaScriptExecuteResponse(\n    int id, const base::ListValue& result) {\n  const base::Value* result_value;\n  if (!result.Get(0, &result_value)) {\n    NOTREACHED() << \"Got bad arguments for OnJavaScriptExecuteResponse\";\n    return;\n  }\n\n  auto it = javascript_callbacks_.find(id);\n  if (it != javascript_callbacks_.end()) {\n    it->second.Run(result_value);\n    javascript_callbacks_.erase(it);\n  } else {\n    NOTREACHED() << \"Received script response for unknown request\";\n  }\n}\n", "target": 0, "idx": 166146}
{"func": "GahpServer::RemoveGahpClient()\n{\n\tm_reference_count--;\n\n\tif ( m_reference_count <= 0 ) {\n\t\tm_deleteMeTid = daemonCore->Register_Timer( 30,\n\t\t\t\t\t\t\t\t(TimerHandlercpp)&GahpServer::DeleteMe,\n\t\t\t\t\t\t\t\t\"GahpServer::DeleteMe\", (Service*)this );\n\t}\n}\n", "target": 0, "idx": 16122}
{"func": "static int entersafe_process_fci(struct sc_card *card, struct sc_file *file,\n\t\t\t\t\t\t  const u8 *buf, size_t buflen)\n{\n\t int r;\n\n\t assert(file);\n\t SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\t r = iso_ops->process_fci(card,file,buf,buflen);\n\t SC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"Process fci failed\");\n\n\t if(file->namelen)\n\t {\n\t\t  file->type = SC_FILE_TYPE_DF;\n\t\t  file->ef_structure = SC_FILE_EF_UNKNOWN;\n\t }\n\t else\n\t {\n\t\t  file->type = SC_FILE_TYPE_WORKING_EF;\n\t\t  file->ef_structure = SC_FILE_EF_TRANSPARENT;\n\t }\n\n\t SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);\n}\n", "target": 0, "idx": 78351}
{"func": "static int handle_cmd(AHCIState *s, int port, uint8_t slot)\n{\n    IDEState *ide_state;\n    uint64_t tbl_addr;\n    AHCICmdHdr *cmd;\n    uint8_t *cmd_fis;\n    dma_addr_t cmd_len;\n\n    if (s->dev[port].port.ifs[0].status & (BUSY_STAT|DRQ_STAT)) {\n        /* Engine currently busy, try again later */\n        DPRINTF(port, \"engine busy\\n\");\n        return -1;\n    }\n\n    if (!s->dev[port].lst) {\n        DPRINTF(port, \"error: lst not given but cmd handled\");\n        return -1;\n    }\n    cmd = get_cmd_header(s, port, slot);\n    /* remember current slot handle for later */\n    s->dev[port].cur_cmd = cmd;\n\n    /* The device we are working for */\n    ide_state = &s->dev[port].port.ifs[0];\n    if (!ide_state->blk) {\n        DPRINTF(port, \"error: guest accessed unused port\");\n        return -1;\n    }\n\n    tbl_addr = le64_to_cpu(cmd->tbl_addr);\n    cmd_len = 0x80;\n    cmd_fis = dma_memory_map(s->as, tbl_addr, &cmd_len,\n                             DMA_DIRECTION_FROM_DEVICE);\n    if (!cmd_fis) {\n        DPRINTF(port, \"error: guest passed us an invalid cmd fis\\n\");\n        return -1;\n    } else if (cmd_len != 0x80) {\n        ahci_trigger_irq(s, &s->dev[port], PORT_IRQ_HBUS_ERR);\n        DPRINTF(port, \"error: dma_memory_map failed: \"\n                \"(len(%02\"PRIx64\") != 0x80)\\n\",\n                cmd_len);\n        goto out;\n    }\n    debug_print_fis(cmd_fis, 0x80);\n\n    switch (cmd_fis[0]) {\n        case SATA_FIS_TYPE_REGISTER_H2D:\n            handle_reg_h2d_fis(s, port, slot, cmd_fis);\n            break;\n        default:\n            DPRINTF(port, \"unknown command cmd_fis[0]=%02x cmd_fis[1]=%02x \"\n                          \"cmd_fis[2]=%02x\\n\", cmd_fis[0], cmd_fis[1],\n                          cmd_fis[2]);\n            break;\n    }\n\nout:\n    dma_memory_unmap(s->as, cmd_fis, cmd_len, DMA_DIRECTION_FROM_DEVICE,\n                     cmd_len);\n\n    if (s->dev[port].port.ifs[0].status & (BUSY_STAT|DRQ_STAT)) {\n        /* async command, complete later */\n        s->dev[port].busy_slot = slot;\n        return -1;\n    }\n\n    /* done handling the command */\n    return 0;\n}\n", "target": 0, "idx": 5892}
{"func": "static int authenticate_and_decrypt_nss_2_0 (\n\tstruct crypto_instance *instance,\n\tunsigned char *buf,\n\tint *buf_len)\n{\n\tif (hash_to_nss[instance->crypto_hash_type]) {\n\t\tunsigned char\ttmp_hash[hash_len[instance->crypto_hash_type]];\n\t\tunsigned char\t*hash = buf;\n\t\tunsigned char\t*data = hash + hash_len[instance->crypto_hash_type];\n\t\tint\t\tdatalen = *buf_len - hash_len[instance->crypto_hash_type];\n\n\t\tif (calculate_nss_hash(instance, data, datalen, tmp_hash) < 0) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (memcmp(tmp_hash, hash, hash_len[instance->crypto_hash_type]) != 0) {\n\t\t\tlog_printf(instance->log_level_error, \"Digest does not match\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tmemmove(buf, data, datalen);\n\t\t*buf_len = datalen;\n\t}\n\n\tif (decrypt_nss(instance, buf, buf_len) < 0) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n", "target": 0, "idx": 41052}
{"func": "static void parse_error(struct filter_parse_error *pe, int err, int pos)\n{\n\tpe->lasterr = err;\n\tpe->lasterr_pos = pos;\n}\n", "target": 0, "idx": 81593}
{"func": "void RenderFrameImpl::OnJavaScriptExecuteRequestInIsolatedWorld(\n    const base::string16& jscript,\n    int id,\n    bool notify_result,\n    int world_id) {\n  TRACE_EVENT_INSTANT0(\"test_tracing\",\n                       \"OnJavaScriptExecuteRequestInIsolatedWorld\",\n                       TRACE_EVENT_SCOPE_THREAD);\n\n  if (world_id <= ISOLATED_WORLD_ID_GLOBAL ||\n      world_id > ISOLATED_WORLD_ID_MAX) {\n    NOTREACHED();\n    return;\n  }\n\n  v8::HandleScope handle_scope(v8::Isolate::GetCurrent());\n  WebScriptSource script = WebScriptSource(jscript);\n  JavaScriptIsolatedWorldRequest* request = new JavaScriptIsolatedWorldRequest(\n      id, notify_result, routing_id_, weak_factory_.GetWeakPtr());\n  frame_->requestExecuteScriptInIsolatedWorld(world_id, &script, 1, 0, false,\n                                              request);\n}\n", "target": 0, "idx": 132242}
{"func": "int jas_stream_write(jas_stream_t *stream, const void *buf, int cnt)\n{\n\tint n;\n\tconst char *bufptr;\n\n\tJAS_DBGLOG(100, (\"jas_stream_write(%p, %p, %d)\\n\", stream, buf, cnt));\n\n\tif (cnt < 0) {\n\t\tjas_deprecated(\"negative count for jas_stream_write\");\n\t}\n\n\tbufptr = buf;\n\n\tn = 0;\n\twhile (n < cnt) {\n\t\tif (jas_stream_putc(stream, *bufptr) == EOF) {\n\t\t\treturn n;\n\t\t}\n\t\t++bufptr;\n\t\t++n;\n\t}\n\n\treturn n;\n}\n", "target": 0, "idx": 72801}
{"func": "void ResourceMessageFilter::OnGetCookies(const GURL& url,\n                                         const GURL& first_party_for_cookies,\n                                         IPC::Message* reply_msg) {\n  URLRequestContext* context = GetRequestContextForURL(url);\n\n  GetCookiesCompletion* callback =\n      new GetCookiesCompletion(url, reply_msg, this, context);\n\n  int policy = net::OK;\n  if (context->cookie_policy()) {\n    policy = context->cookie_policy()->CanGetCookies(\n        url, first_party_for_cookies, callback);\n    if (policy == net::ERR_IO_PENDING) {\n      Send(new ViewMsg_SignalCookiePromptEvent());\n      return;\n    }\n  }\n  callback->Run(policy);\n}\n", "target": 0, "idx": 99297}
{"func": "bool BrowserRenderProcessHost::Send(IPC::Message* msg) {\n  if (!channel_.get()) {\n    delete msg;\n    return false;\n  }\n  return channel_->Send(msg);\n}\n", "target": 0, "idx": 100392}
{"func": "  Ins_OR( INS_ARG )\n  {\n    DO_OR\n  }\n", "target": 0, "idx": 10145}
{"func": "_tiffMapProc(thandle_t fd, tdata_t* pbase, toff_t* psize)\n{\n\treturn (0);\n}\n", "target": 0, "idx": 86790}
{"func": "TEE_Result tee_mmu_check_access_rights(const struct user_ta_ctx *utc,\n\t\t\t\t       uint32_t flags, uaddr_t uaddr,\n \t\t\t\t       size_t len)\n {\n \tuaddr_t a;\n \tsize_t addr_incr = MIN(CORE_MMU_USER_CODE_SIZE,\n \t\t\t       CORE_MMU_USER_PARAM_SIZE);\n \n\tif (ADD_OVERFLOW(uaddr, len, &a))\n \t\treturn TEE_ERROR_ACCESS_DENIED;\n \n \tif ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&\n\t    (flags & TEE_MEMORY_ACCESS_SECURE))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\n\t/*\n\t * Rely on TA private memory test to check if address range is private\n\t * to TA or not.\n\t */\n\tif (!(flags & TEE_MEMORY_ACCESS_ANY_OWNER) &&\n \t   !tee_mmu_is_vbuf_inside_ta_private(utc, (void *)uaddr, len))\n \t\treturn TEE_ERROR_ACCESS_DENIED;\n \n\tfor (a = uaddr; a < (uaddr + len); a += addr_incr) {\n \t\tuint32_t attr;\n \t\tTEE_Result res;\n \n\t\tres = tee_mmu_user_va2pa_attr(utc, (void *)a, NULL, &attr);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\n\t\tif ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&\n\t\t    (attr & TEE_MATTR_SECURE))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\n\t\tif ((flags & TEE_MEMORY_ACCESS_SECURE) &&\n\t\t    !(attr & TEE_MATTR_SECURE))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\n\t\tif ((flags & TEE_MEMORY_ACCESS_WRITE) && !(attr & TEE_MATTR_UW))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t\tif ((flags & TEE_MEMORY_ACCESS_READ) && !(attr & TEE_MATTR_UR))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t}\n\n\treturn TEE_SUCCESS;\n}\n", "target": 1, "idx": 182645}
{"func": "void AXObjectCacheImpl::handleAriaSelectedChanged(Node* node) {\n  AXObject* obj = get(node);\n  if (!obj)\n    return;\n\n  postNotification(obj, AXCheckedStateChanged);\n\n  AXObject* listbox = obj->parentObjectUnignored();\n  if (listbox && listbox->roleValue() == ListBoxRole)\n    postNotification(listbox, AXSelectedChildrenChanged);\n}\n", "target": 0, "idx": 138246}
{"func": "static bool cgroupfs_mount_cgroup(void *hdata, const char *root, int type)\n{\n\tsize_t bufsz = strlen(root) + sizeof(\"/sys/fs/cgroup\");\n\tchar *path = NULL;\n\tchar **parts = NULL;\n\tchar *dirname = NULL;\n\tchar *abs_path = NULL;\n\tchar *abs_path2 = NULL;\n\tstruct cgfs_data *cgfs_d;\n\tstruct cgroup_process_info *info, *base_info;\n\tint r, saved_errno = 0;\n\n\tcgfs_d = hdata;\n\tif (!cgfs_d)\n\t\treturn false;\n\tbase_info = cgfs_d->info;\n\n\t/* If we get passed the _NOSPEC types, we default to _MIXED, since we don't\n\t * have access to the lxc_conf object at this point. It really should be up\n\t * to the caller to fix this, but this doesn't really hurt.\n\t */\n\tif (type == LXC_AUTO_CGROUP_FULL_NOSPEC)\n\t\ttype = LXC_AUTO_CGROUP_FULL_MIXED;\n\telse if (type == LXC_AUTO_CGROUP_NOSPEC)\n\t\ttype = LXC_AUTO_CGROUP_MIXED;\n\n\tif (type < LXC_AUTO_CGROUP_RO || type > LXC_AUTO_CGROUP_FULL_MIXED) {\n\t\tERROR(\"could not mount cgroups into container: invalid type specified internally\");\n\t\terrno = EINVAL;\n\t\treturn false;\n\t}\n\n\tpath = calloc(1, bufsz);\n \tif (!path)\n \t\treturn false;\n \tsnprintf(path, bufsz, \"%s/sys/fs/cgroup\", root);\n\tr = mount(\"cgroup_root\", path, \"tmpfs\", MS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME, \"size=10240k,mode=755\");\n \tif (r < 0) {\n \t\tSYSERROR(\"could not mount tmpfs to /sys/fs/cgroup in the container\");\n \t\treturn false;\n\t}\n\n\t/* now mount all the hierarchies we care about */\n\tfor (info = base_info; info; info = info->next) {\n\t\tsize_t subsystem_count, i;\n\t\tstruct cgroup_mount_point *mp = info->designated_mount_point;\n\t\tif (!mp)\n\t\t\tmp = lxc_cgroup_find_mount_point(info->hierarchy, info->cgroup_path, true);\n\t\tif (!mp) {\n\t\t\tSYSERROR(\"could not find original mount point for cgroup hierarchy while trying to mount cgroup filesystem\");\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tsubsystem_count = lxc_array_len((void **)info->hierarchy->subsystems);\n\t\tparts = calloc(subsystem_count + 1, sizeof(char *));\n\t\tif (!parts)\n\t\t\tgoto out_error;\n\n\t\tfor (i = 0; i < subsystem_count; i++) {\n\t\t\tif (!strncmp(info->hierarchy->subsystems[i], \"name=\", 5))\n\t\t\t\tparts[i] = info->hierarchy->subsystems[i] + 5;\n\t\t\telse\n\t\t\t\tparts[i] = info->hierarchy->subsystems[i];\n\t\t}\n\t\tdirname = lxc_string_join(\",\", (const char **)parts, false);\n\t\tif (!dirname)\n\t\t\tgoto out_error;\n\n\t\t/* create subsystem directory */\n\t\tabs_path = lxc_append_paths(path, dirname);\n\t\tif (!abs_path)\n\t\t\tgoto out_error;\n\t\tr = mkdir_p(abs_path, 0755);\n\t\tif (r < 0 && errno != EEXIST) {\n\t\t\tSYSERROR(\"could not create cgroup subsystem directory /sys/fs/cgroup/%s\", dirname);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tabs_path2 = lxc_append_paths(abs_path, info->cgroup_path);\n\t\tif (!abs_path2)\n\t\t\tgoto out_error;\n\n\t\tif (type == LXC_AUTO_CGROUP_FULL_RO || type == LXC_AUTO_CGROUP_FULL_RW || type == LXC_AUTO_CGROUP_FULL_MIXED) {\n\t\t\t/* bind-mount the cgroup entire filesystem there */\n\t\t\tif (strcmp(mp->mount_prefix, \"/\") != 0) {\n\t\t\t\t/* FIXME: maybe we should just try to remount the entire hierarchy\n\t\t\t\t *        with a regular mount command? may that works? */\n\t\t\t\tERROR(\"could not automatically mount cgroup-full to /sys/fs/cgroup/%s: host has no mount point for this cgroup filesystem that has access to the root cgroup\", dirname);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tr = mount(mp->mount_point, abs_path, \"none\", MS_BIND, 0);\n\t\t\tif (r < 0) {\n\t\t\t\tSYSERROR(\"error bind-mounting %s to %s\", mp->mount_point, abs_path);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\t/* main cgroup path should be read-only */\n\t\t\tif (type == LXC_AUTO_CGROUP_FULL_RO || type == LXC_AUTO_CGROUP_FULL_MIXED) {\n\t\t\t\tr = mount(NULL, abs_path, NULL, MS_REMOUNT|MS_BIND|MS_RDONLY, NULL);\n\t\t\t\tif (r < 0) {\n\t\t\t\t\tSYSERROR(\"error re-mounting %s readonly\", abs_path);\n\t\t\t\t\tgoto out_error;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* own cgroup should be read-write */\n\t\t\tif (type == LXC_AUTO_CGROUP_FULL_MIXED) {\n\t\t\t\tr = mount(abs_path2, abs_path2, NULL, MS_BIND, NULL);\n\t\t\t\tif (r < 0) {\n\t\t\t\t\tSYSERROR(\"error bind-mounting %s onto itself\", abs_path2);\n\t\t\t\t\tgoto out_error;\n\t\t\t\t}\n\t\t\t\tr = mount(NULL, abs_path2, NULL, MS_REMOUNT|MS_BIND, NULL);\n\t\t\t\tif (r < 0) {\n\t\t\t\t\tSYSERROR(\"error re-mounting %s readwrite\", abs_path2);\n\t\t\t\t\tgoto out_error;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t/* create path for container's cgroup */\n\t\t\tr = mkdir_p(abs_path2, 0755);\n\t\t\tif (r < 0 && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"could not create cgroup directory /sys/fs/cgroup/%s%s\", dirname, info->cgroup_path);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\n\t\t\t/* for read-only and mixed cases, we have to bind-mount the tmpfs directory\n\t\t\t * that points to the hierarchy itself (i.e. /sys/fs/cgroup/cpu etc.) onto\n\t\t\t * itself and then bind-mount it read-only, since we keep the tmpfs itself\n\t\t\t * read-write (see comment below)\n\t\t\t */\n\t\t\tif (type == LXC_AUTO_CGROUP_MIXED || type == LXC_AUTO_CGROUP_RO) {\n\t\t\t\tr = mount(abs_path, abs_path, NULL, MS_BIND, NULL);\n\t\t\t\tif (r < 0) {\n\t\t\t\t\tSYSERROR(\"error bind-mounting %s onto itself\", abs_path);\n\t\t\t\t\tgoto out_error;\n\t\t\t\t}\n\t\t\t\tr = mount(NULL, abs_path, NULL, MS_REMOUNT|MS_BIND|MS_RDONLY, NULL);\n\t\t\t\tif (r < 0) {\n\t\t\t\t\tSYSERROR(\"error re-mounting %s readonly\", abs_path);\n\t\t\t\t\tgoto out_error;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfree(abs_path);\n\t\t\tabs_path = NULL;\n\n\t\t\t/* bind-mount container's cgroup to that directory */\n\t\t\tabs_path = cgroup_to_absolute_path(mp, info->cgroup_path, NULL);\n\t\t\tif (!abs_path)\n\t\t\t\tgoto out_error;\n\t\t\tr = mount(abs_path, abs_path2, \"none\", MS_BIND, 0);\n\t\t\tif (r < 0) {\n\t\t\t\tSYSERROR(\"error bind-mounting %s to %s\", abs_path, abs_path2);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tif (type == LXC_AUTO_CGROUP_RO) {\n\t\t\t\tr = mount(NULL, abs_path2, NULL, MS_REMOUNT|MS_BIND|MS_RDONLY, NULL);\n\t\t\t\tif (r < 0) {\n\t\t\t\t\tSYSERROR(\"error re-mounting %s readonly\", abs_path2);\n\t\t\t\t\tgoto out_error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfree(abs_path);\n\t\tfree(abs_path2);\n\t\tabs_path = NULL;\n\t\tabs_path2 = NULL;\n\n\t\t/* add symlinks for every single subsystem */\n\t\tif (subsystem_count > 1) {\n\t\t\tfor (i = 0; i < subsystem_count; i++) {\n\t\t\t\tabs_path = lxc_append_paths(path, parts[i]);\n\t\t\t\tif (!abs_path)\n\t\t\t\t\tgoto out_error;\n\t\t\t\tr = symlink(dirname, abs_path);\n\t\t\t\tif (r < 0)\n\t\t\t\t\tWARN(\"could not create symlink %s -> %s in /sys/fs/cgroup of container\", parts[i], dirname);\n\t\t\t\tfree(abs_path);\n\t\t\t\tabs_path = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(dirname);\n\t\tfree(parts);\n\t\tdirname = NULL;\n\t\tparts = NULL;\n\t}\n\n\t/* We used to remount the entire tmpfs readonly if any :ro or\n\t * :mixed mode was specified. However, Ubuntu's mountall has the\n\t * unfortunate behavior to block bootup if /sys/fs/cgroup is\n\t * mounted read-only and cannot be remounted read-write.\n\t * (mountall reads /lib/init/fstab and tries to (re-)mount all of\n\t * these if they are not already mounted with the right options;\n\t * it contains an entry for /sys/fs/cgroup. In case it can't do\n\t * that, it prompts for the user to either manually fix it or\n\t * boot anyway. But without user input, booting of the container\n\t * hangs.)\n\t *\n\t * Instead of remounting the entire tmpfs readonly, we only\n\t * remount the paths readonly that are part of the cgroup\n\t * hierarchy.\n\t */\n\n\tfree(path);\n\n\treturn true;\n\nout_error:\n\tsaved_errno = errno;\n\tfree(path);\n\tfree(dirname);\n\tfree(parts);\n\tfree(abs_path);\n\tfree(abs_path2);\n\terrno = saved_errno;\n\treturn false;\n}\n", "target": 1, "idx": 179881}
{"func": "xsltDocumentElem(xsltTransformContextPtr ctxt, xmlNodePtr node,\n                 xmlNodePtr inst, xsltStylePreCompPtr castedComp)\n{\n#ifdef XSLT_REFACTORED\n    xsltStyleItemDocumentPtr comp = (xsltStyleItemDocumentPtr) castedComp;\n#else\n    xsltStylePreCompPtr comp = castedComp;\n#endif\n    xsltStylesheetPtr style = NULL;\n    int ret;\n    xmlChar *filename = NULL, *prop, *elements;\n    xmlChar *element, *end;\n    xmlDocPtr res = NULL;\n    xmlDocPtr oldOutput;\n    xmlNodePtr oldInsert, root;\n    const char *oldOutputFile;\n    xsltOutputType oldType;\n    xmlChar *URL = NULL;\n    const xmlChar *method;\n    const xmlChar *doctypePublic;\n    const xmlChar *doctypeSystem;\n    const xmlChar *version;\n    const xmlChar *encoding;\n    int redirect_write_append = 0;\n\n    if ((ctxt == NULL) || (node == NULL) || (inst == NULL) || (comp == NULL))\n        return;\n\n    if (comp->filename == NULL) {\n\n        if (xmlStrEqual(inst->name, (const xmlChar *) \"output\")) {\n\t    /*\n\t    * The element \"output\" is in the namespace XSLT_SAXON_NAMESPACE\n\t    *   (http://icl.com/saxon)\n\t    * The @file is in no namespace.\n\t    */\n#ifdef WITH_XSLT_DEBUG_EXTRA\n            xsltGenericDebug(xsltGenericDebugContext,\n                             \"Found saxon:output extension\\n\");\n#endif\n            URL = xsltEvalAttrValueTemplate(ctxt, inst,\n                                                 (const xmlChar *) \"file\",\n                                                 XSLT_SAXON_NAMESPACE);\n\n\t    if (URL == NULL)\n\t\tURL = xsltEvalAttrValueTemplate(ctxt, inst,\n                                                 (const xmlChar *) \"href\",\n                                                 XSLT_SAXON_NAMESPACE);\n        } else if (xmlStrEqual(inst->name, (const xmlChar *) \"write\")) {\n#ifdef WITH_XSLT_DEBUG_EXTRA\n            xsltGenericDebug(xsltGenericDebugContext,\n                             \"Found xalan:write extension\\n\");\n#endif\n            URL = xsltEvalAttrValueTemplate(ctxt, inst,\n                                                 (const xmlChar *)\n                                                 \"select\",\n                                                 XSLT_XALAN_NAMESPACE);\n\t    if (URL != NULL) {\n\t\txmlXPathCompExprPtr cmp;\n\t\txmlChar *val;\n\n\t\t/*\n\t\t * Trying to handle bug #59212\n\t\t * The value of the \"select\" attribute is an\n\t\t * XPath expression.\n\t\t * (see http://xml.apache.org/xalan-j/extensionslib.html#redirect)\n\t\t */\n\t\tcmp = xmlXPathCompile(URL);\n                val = xsltEvalXPathString(ctxt, cmp);\n\t\txmlXPathFreeCompExpr(cmp);\n\t\txmlFree(URL);\n\t\tURL = val;\n\t    }\n\t    if (URL == NULL)\n\t\tURL = xsltEvalAttrValueTemplate(ctxt, inst,\n\t\t\t\t\t\t     (const xmlChar *)\n\t\t\t\t\t\t     \"file\",\n\t\t\t\t\t\t     XSLT_XALAN_NAMESPACE);\n\t    if (URL == NULL)\n\t\tURL = xsltEvalAttrValueTemplate(ctxt, inst,\n\t\t\t\t\t\t     (const xmlChar *)\n\t\t\t\t\t\t     \"href\",\n\t\t\t\t\t\t     XSLT_XALAN_NAMESPACE);\n        } else if (xmlStrEqual(inst->name, (const xmlChar *) \"document\")) {\n            URL = xsltEvalAttrValueTemplate(ctxt, inst,\n                                                 (const xmlChar *) \"href\",\n                                                 NULL);\n        }\n\n    } else {\n        URL = xmlStrdup(comp->filename);\n    }\n\n    if (URL == NULL) {\n\txsltTransformError(ctxt, NULL, inst,\n\t\t         \"xsltDocumentElem: href/URI-Reference not found\\n\");\n\treturn;\n    }\n\n    /*\n     * If the computation failed, it's likely that the URL wasn't escaped\n     */\n    filename = xmlBuildURI(URL, (const xmlChar *) ctxt->outputFile);\n    if (filename == NULL) {\n\txmlChar *escURL;\n\n\tescURL=xmlURIEscapeStr(URL, BAD_CAST \":/.?,\");\n\tif (escURL != NULL) {\n\t    filename = xmlBuildURI(escURL, (const xmlChar *) ctxt->outputFile);\n\t    xmlFree(escURL);\n\t}\n    }\n\n    if (filename == NULL) {\n\txsltTransformError(ctxt, NULL, inst,\n\t\t         \"xsltDocumentElem: URL computation failed for %s\\n\",\n\t\t\t URL);\n\txmlFree(URL);\n\treturn;\n    }\n\n    /*\n     * Security checking: can we write to this resource\n     */\n    if (ctxt->sec != NULL) {\n\tret = xsltCheckWrite(ctxt->sec, ctxt, filename);\n\tif (ret == 0) {\n\t    xsltTransformError(ctxt, NULL, inst,\n\t\t \"xsltDocumentElem: write rights for %s denied\\n\",\n\t\t\t     filename);\n\t    xmlFree(URL);\n\t    xmlFree(filename);\n\t    return;\n\t}\n    }\n\n    oldOutputFile = ctxt->outputFile;\n    oldOutput = ctxt->output;\n    oldInsert = ctxt->insert;\n    oldType = ctxt->type;\n    ctxt->outputFile = (const char *) filename;\n\n    style = xsltNewStylesheet();\n    if (style == NULL) {\n\txsltTransformError(ctxt, NULL, inst,\n                         \"xsltDocumentElem: out of memory\\n\");\n        goto error;\n    }\n\n    /*\n     * Version described in 1.1 draft allows full parameterization\n     * of the output.\n     */\n    prop = xsltEvalAttrValueTemplate(ctxt, inst,\n\t\t\t\t     (const xmlChar *) \"version\",\n\t\t\t\t     NULL);\n    if (prop != NULL) {\n\tif (style->version != NULL)\n\t    xmlFree(style->version);\n\tstyle->version = prop;\n    }\n    prop = xsltEvalAttrValueTemplate(ctxt, inst,\n\t\t\t\t     (const xmlChar *) \"encoding\",\n\t\t\t\t     NULL);\n    if (prop != NULL) {\n\tif (style->encoding != NULL)\n\t    xmlFree(style->encoding);\n\tstyle->encoding = prop;\n    }\n    prop = xsltEvalAttrValueTemplate(ctxt, inst,\n\t\t\t\t     (const xmlChar *) \"method\",\n\t\t\t\t     NULL);\n    if (prop != NULL) {\n\tconst xmlChar *URI;\n\n\tif (style->method != NULL)\n\t    xmlFree(style->method);\n\tstyle->method = NULL;\n\tif (style->methodURI != NULL)\n\t    xmlFree(style->methodURI);\n\tstyle->methodURI = NULL;\n\n\tURI = xsltGetQNameURI(inst, &prop);\n\tif (prop == NULL) {\n\t    if (style != NULL) style->errors++;\n\t} else if (URI == NULL) {\n\t    if ((xmlStrEqual(prop, (const xmlChar *) \"xml\")) ||\n\t\t(xmlStrEqual(prop, (const xmlChar *) \"html\")) ||\n\t\t(xmlStrEqual(prop, (const xmlChar *) \"text\"))) {\n\t\tstyle->method = prop;\n\t    } else {\n\t\txsltTransformError(ctxt, NULL, inst,\n\t\t\t\t \"invalid value for method: %s\\n\", prop);\n\t\tif (style != NULL) style->warnings++;\n\t    }\n\t} else {\n\t    style->method = prop;\n\t    style->methodURI = xmlStrdup(URI);\n\t}\n    }\n    prop = xsltEvalAttrValueTemplate(ctxt, inst,\n\t\t\t\t     (const xmlChar *)\n\t\t\t\t     \"doctype-system\", NULL);\n    if (prop != NULL) {\n\tif (style->doctypeSystem != NULL)\n\t    xmlFree(style->doctypeSystem);\n\tstyle->doctypeSystem = prop;\n    }\n    prop = xsltEvalAttrValueTemplate(ctxt, inst,\n\t\t\t\t     (const xmlChar *)\n\t\t\t\t     \"doctype-public\", NULL);\n    if (prop != NULL) {\n\tif (style->doctypePublic != NULL)\n\t    xmlFree(style->doctypePublic);\n\tstyle->doctypePublic = prop;\n    }\n    prop = xsltEvalAttrValueTemplate(ctxt, inst,\n\t\t\t\t     (const xmlChar *) \"standalone\",\n\t\t\t\t     NULL);\n    if (prop != NULL) {\n\tif (xmlStrEqual(prop, (const xmlChar *) \"yes\")) {\n\t    style->standalone = 1;\n\t} else if (xmlStrEqual(prop, (const xmlChar *) \"no\")) {\n\t    style->standalone = 0;\n\t} else {\n\t    xsltTransformError(ctxt, NULL, inst,\n\t\t\t     \"invalid value for standalone: %s\\n\",\n\t\t\t     prop);\n\t    if (style != NULL) style->warnings++;\n\t}\n\txmlFree(prop);\n    }\n\n    prop = xsltEvalAttrValueTemplate(ctxt, inst,\n\t\t\t\t     (const xmlChar *) \"indent\",\n\t\t\t\t     NULL);\n    if (prop != NULL) {\n\tif (xmlStrEqual(prop, (const xmlChar *) \"yes\")) {\n\t    style->indent = 1;\n\t} else if (xmlStrEqual(prop, (const xmlChar *) \"no\")) {\n\t    style->indent = 0;\n\t} else {\n\t    xsltTransformError(ctxt, NULL, inst,\n\t\t\t     \"invalid value for indent: %s\\n\", prop);\n\t    if (style != NULL) style->warnings++;\n\t}\n\txmlFree(prop);\n    }\n\n    prop = xsltEvalAttrValueTemplate(ctxt, inst,\n\t\t\t\t     (const xmlChar *)\n\t\t\t\t     \"omit-xml-declaration\",\n\t\t\t\t     NULL);\n    if (prop != NULL) {\n\tif (xmlStrEqual(prop, (const xmlChar *) \"yes\")) {\n\t    style->omitXmlDeclaration = 1;\n\t} else if (xmlStrEqual(prop, (const xmlChar *) \"no\")) {\n\t    style->omitXmlDeclaration = 0;\n\t} else {\n\t    xsltTransformError(ctxt, NULL, inst,\n\t\t\t     \"invalid value for omit-xml-declaration: %s\\n\",\n\t\t\t     prop);\n\t    if (style != NULL) style->warnings++;\n\t}\n\txmlFree(prop);\n    }\n\n    elements = xsltEvalAttrValueTemplate(ctxt, inst,\n\t\t\t\t\t (const xmlChar *)\n\t\t\t\t\t \"cdata-section-elements\",\n\t\t\t\t\t NULL);\n    if (elements != NULL) {\n\tif (style->stripSpaces == NULL)\n\t    style->stripSpaces = xmlHashCreate(10);\n\tif (style->stripSpaces == NULL)\n\t    return;\n\n\telement = elements;\n\twhile (*element != 0) {\n\t    while (IS_BLANK_CH(*element))\n\t\telement++;\n\t    if (*element == 0)\n\t\tbreak;\n\t    end = element;\n\t    while ((*end != 0) && (!IS_BLANK_CH(*end)))\n\t\tend++;\n\t    element = xmlStrndup(element, end - element);\n\t    if (element) {\n\t\tconst xmlChar *URI;\n\n#ifdef WITH_XSLT_DEBUG_PARSING\n\t\txsltGenericDebug(xsltGenericDebugContext,\n\t\t\t\t \"add cdata section output element %s\\n\",\n\t\t\t\t element);\n#endif\n                URI = xsltGetQNameURI(inst, &element);\n\n\t\txmlHashAddEntry2(style->stripSpaces, element, URI,\n\t\t\t        (xmlChar *) \"cdata\");\n\t\txmlFree(element);\n\t    }\n\t    element = end;\n\t}\n\txmlFree(elements);\n    }\n\n    /*\n     * Create a new document tree and process the element template\n     */\n    XSLT_GET_IMPORT_PTR(method, style, method)\n    XSLT_GET_IMPORT_PTR(doctypePublic, style, doctypePublic)\n    XSLT_GET_IMPORT_PTR(doctypeSystem, style, doctypeSystem)\n    XSLT_GET_IMPORT_PTR(version, style, version)\n    XSLT_GET_IMPORT_PTR(encoding, style, encoding)\n\n    if ((method != NULL) &&\n\t(!xmlStrEqual(method, (const xmlChar *) \"xml\"))) {\n\tif (xmlStrEqual(method, (const xmlChar *) \"html\")) {\n\t    ctxt->type = XSLT_OUTPUT_HTML;\n\t    if (((doctypePublic != NULL) || (doctypeSystem != NULL)))\n\t\tres = htmlNewDoc(doctypeSystem, doctypePublic);\n\t    else {\n\t\tif (version != NULL) {\n#ifdef XSLT_GENERATE_HTML_DOCTYPE\n\t\t    xsltGetHTMLIDs(version, &doctypePublic, &doctypeSystem);\n#endif\n                }\n\t\tres = htmlNewDocNoDtD(doctypeSystem, doctypePublic);\n\t    }\n\t    if (res == NULL)\n\t\tgoto error;\n\t    res->dict = ctxt->dict;\n \t    xmlDictReference(res->dict);\n \t} else if (xmlStrEqual(method, (const xmlChar *) \"xhtml\")) {\n \t    xsltTransformError(ctxt, NULL, inst,\n\t     \"xsltDocumentElem: unsupported method xhtml\\n\",\n\t\t             style->method);\n \t    ctxt->type = XSLT_OUTPUT_HTML;\n \t    res = htmlNewDocNoDtD(doctypeSystem, doctypePublic);\n \t    if (res == NULL)\n\t\tgoto error;\n\t    res->dict = ctxt->dict;\n\t    xmlDictReference(res->dict);\n\t} else if (xmlStrEqual(method, (const xmlChar *) \"text\")) {\n\t    ctxt->type = XSLT_OUTPUT_TEXT;\n\t    res = xmlNewDoc(style->version);\n\t    if (res == NULL)\n\t\tgoto error;\n\t    res->dict = ctxt->dict;\n\t    xmlDictReference(res->dict);\n#ifdef WITH_XSLT_DEBUG\n\t    xsltGenericDebug(xsltGenericDebugContext,\n                     \"reusing transformation dict for output\\n\");\n #endif\n \t} else {\n \t    xsltTransformError(ctxt, NULL, inst,\n\t\t\t     \"xsltDocumentElem: unsupported method %s\\n\",\n\t\t             style->method);\n \t    goto error;\n \t}\n     } else {\n\tctxt->type = XSLT_OUTPUT_XML;\n\tres = xmlNewDoc(style->version);\n\tif (res == NULL)\n\t    goto error;\n\tres->dict = ctxt->dict;\n\txmlDictReference(res->dict);\n#ifdef WITH_XSLT_DEBUG\n\txsltGenericDebug(xsltGenericDebugContext,\n                     \"reusing transformation dict for output\\n\");\n#endif\n    }\n    res->charset = XML_CHAR_ENCODING_UTF8;\n    if (encoding != NULL)\n\tres->encoding = xmlStrdup(encoding);\n    ctxt->output = res;\n    ctxt->insert = (xmlNodePtr) res;\n    xsltApplySequenceConstructor(ctxt, node, inst->children, NULL);\n\n    /*\n     * Do some post processing work depending on the generated output\n     */\n    root = xmlDocGetRootElement(res);\n    if (root != NULL) {\n        const xmlChar *doctype = NULL;\n\n        if ((root->ns != NULL) && (root->ns->prefix != NULL))\n\t    doctype = xmlDictQLookup(ctxt->dict, root->ns->prefix, root->name);\n\tif (doctype == NULL)\n\t    doctype = root->name;\n\n        /*\n         * Apply the default selection of the method\n         */\n        if ((method == NULL) &&\n            (root->ns == NULL) &&\n            (!xmlStrcasecmp(root->name, (const xmlChar *) \"html\"))) {\n            xmlNodePtr tmp;\n\n            tmp = res->children;\n            while ((tmp != NULL) && (tmp != root)) {\n                if (tmp->type == XML_ELEMENT_NODE)\n                    break;\n                if ((tmp->type == XML_TEXT_NODE) && (!xmlIsBlankNode(tmp)))\n                    break;\n\t\ttmp = tmp->next;\n            }\n            if (tmp == root) {\n                ctxt->type = XSLT_OUTPUT_HTML;\n                res->type = XML_HTML_DOCUMENT_NODE;\n                if (((doctypePublic != NULL) || (doctypeSystem != NULL))) {\n                    res->intSubset = xmlCreateIntSubset(res, doctype,\n                                                        doctypePublic,\n                                                        doctypeSystem);\n#ifdef XSLT_GENERATE_HTML_DOCTYPE\n\t\t} else if (version != NULL) {\n                    xsltGetHTMLIDs(version, &doctypePublic,\n                                   &doctypeSystem);\n                    if (((doctypePublic != NULL) || (doctypeSystem != NULL)))\n                        res->intSubset =\n                            xmlCreateIntSubset(res, doctype,\n                                               doctypePublic,\n                                               doctypeSystem);\n#endif\n                }\n            }\n\n        }\n        if (ctxt->type == XSLT_OUTPUT_XML) {\n            XSLT_GET_IMPORT_PTR(doctypePublic, style, doctypePublic)\n                XSLT_GET_IMPORT_PTR(doctypeSystem, style, doctypeSystem)\n                if (((doctypePublic != NULL) || (doctypeSystem != NULL)))\n                res->intSubset = xmlCreateIntSubset(res, doctype,\n                                                    doctypePublic,\n                                                    doctypeSystem);\n        }\n    }\n\n    /*\n     * Calls to redirect:write also take an optional attribute append.\n     * Attribute append=\"true|yes\" which will attempt to simply append\n     * to an existing file instead of always opening a new file. The\n     * default behavior of always overwriting the file still happens\n     * if we do not specify append.\n     * Note that append use will forbid use of remote URI target.\n     */\n    prop = xsltEvalAttrValueTemplate(ctxt, inst, (const xmlChar *)\"append\",\n\t\t\t\t     NULL);\n    if (prop != NULL) {\n\tif (xmlStrEqual(prop, (const xmlChar *) \"true\") ||\n\t    xmlStrEqual(prop, (const xmlChar *) \"yes\")) {\n\t    style->omitXmlDeclaration = 1;\n\t    redirect_write_append = 1;\n\t} else\n\t    style->omitXmlDeclaration = 0;\n\txmlFree(prop);\n    }\n\n    if (redirect_write_append) {\n        FILE *f;\n\n\tf = fopen((const char *) filename, \"ab\");\n\tif (f == NULL) {\n\t    ret = -1;\n\t} else {\n\t    ret = xsltSaveResultToFile(f, res, style);\n\t    fclose(f);\n\t}\n    } else {\n\tret = xsltSaveResultToFilename((const char *) filename, res, style, 0);\n    }\n    if (ret < 0) {\n\txsltTransformError(ctxt, NULL, inst,\n                         \"xsltDocumentElem: unable to save to %s\\n\",\n                         filename);\n\tctxt->state = XSLT_STATE_ERROR;\n#ifdef WITH_XSLT_DEBUG_EXTRA\n    } else {\n        xsltGenericDebug(xsltGenericDebugContext,\n                         \"Wrote %d bytes to %s\\n\", ret, filename);\n#endif\n    }\n\n  error:\n    ctxt->output = oldOutput;\n    ctxt->insert = oldInsert;\n    ctxt->type = oldType;\n    ctxt->outputFile = oldOutputFile;\n    if (URL != NULL)\n        xmlFree(URL);\n    if (filename != NULL)\n        xmlFree(filename);\n    if (style != NULL)\n        xsltFreeStylesheet(style);\n    if (res != NULL)\n        xmlFreeDoc(res);\n}\n", "target": 1, "idx": 187347}
{"func": "static int store_asoundrc(void) {\n\tfs_build_mnt_dir();\n \n \tchar *src;\n \tchar *dest = RUN_ASOUNDRC_FILE;\n \tFILE *fp = fopen(dest, \"w\");\n \tif (fp) {\n \t\tfprintf(fp, \"\\n\");\n\t\tSET_PERMS_STREAM(fp, getuid(), getgid(), 0644);\n\t\tfclose(fp);\n\t}\n\t\n\tif (asprintf(&src, \"%s/.asoundrc\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\t\n\tstruct stat s;\n\tif (stat(src, &s) == 0) {\n\t\tif (is_link(src)) {\n\t\t\t/* coverity[toctou] */\n\t\t\tchar* rp = realpath(src, NULL);\n\t\t\tif (!rp) {\n\t\t\t\tfprintf(stderr, \"Error: Cannot access %s\\n\", src);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (strncmp(rp, cfg.homedir, strlen(cfg.homedir)) != 0) {\n\t\t\t\tfprintf(stderr, \"Error: .asoundrc is a symbolic link pointing to a file outside home directory\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tfree(rp);\n\t\t}\n\n\t\tcopy_file_as_user(src, dest, getuid(), getgid(), 0644);\n\t\tfs_logger2(\"clone\", dest);\n\t\treturn 1; // file copied\n\t}\n\t\n\treturn 0;\n}\n", "target": 1, "idx": 181544}
{"func": " bool ClipboardUtil::HasFilenames(IDataObject* data_object) {\n   DCHECK(data_object);\n  return HasData(data_object, Clipboard::GetCFHDropFormatType());\n }\n", "target": 1, "idx": 185440}
{"func": "    virtual bool detach()\n    {\n        m_events.append(Detach);\n        return TRUE;\n    }\n", "target": 0, "idx": 117172}
{"func": "void ptrace_triggered(struct perf_event *bp, int nmi,\n \t\t      struct perf_sample_data *data, struct pt_regs *regs)\n {\n \tstruct perf_event_attr attr;\n\n\t/*\n\t * Disable the breakpoint request here since ptrace has defined a\n\t * one-shot behaviour for breakpoint exceptions in PPC64.\n\t * The SIGTRAP signal is generated automatically for us in do_dabr().\n\t * We don't have to do anything about that here\n\t */\n\tattr = bp->attr;\n\tattr.disabled = true;\n\tmodify_user_hw_breakpoint(bp, &attr);\n}\n", "target": 1, "idx": 178964}
{"func": "void* JSArray::subclassData() const\n{\n    return m_storage->subclassData;\n}\n", "target": 0, "idx": 107453}
{"func": "int main(int argc, char *argv[])\n{\n\tint ret;\n\tstruct lxc_lock *lock;\n\n\tlock = lxc_newlock(NULL, NULL);\n\tif (!lock) {\n\t\tfprintf(stderr, \"%d: failed to get unnamed lock\\n\", __LINE__);\n\t\texit(1);\n\t}\n\tret = lxclock(lock, 0);\n\tif (ret) {\n\t\tfprintf(stderr, \"%d: failed to take unnamed lock (%d)\\n\", __LINE__, ret);\n\t\texit(1);\n\t}\n\n\tret = lxcunlock(lock);\n\tif (ret) {\n\t\tfprintf(stderr, \"%d: failed to put unnamed lock (%d)\\n\", __LINE__, ret);\n\t\texit(1);\n\t}\n\tlxc_putlock(lock);\n\n\tlock = lxc_newlock(\"/var/lib/lxc\", mycontainername);\n\tif (!lock) {\n\t\tfprintf(stderr, \"%d: failed to get lock\\n\", __LINE__);\n \t\texit(1);\n \t}\n \tstruct stat sb;\n\tchar *pathname = RUNTIME_PATH \"/lock/lxc/var/lib/lxc/\";\n \tret = stat(pathname, &sb);\n \tif (ret != 0) {\n \t\tfprintf(stderr, \"%d: filename %s not created\\n\", __LINE__,\n\t\t\tpathname);\n\t\texit(1);\n\t}\n\tlxc_putlock(lock);\n\n\ttest_two_locks();\n\n\tfprintf(stderr, \"all tests passed\\n\");\n\n\texit(ret);\n}\n", "target": 1, "idx": 179898}
{"func": "parse_field(netdissect_options *ndo, const char **pptr, int *len)\n {\n     const char *s;\n \n    if (*len <= 0 || !pptr || !*pptr)\n\treturn NULL;\n    if (*pptr > (const char *) ndo->ndo_snapend)\n\treturn NULL;\n     s = *pptr;\n    while (*pptr <= (const char *) ndo->ndo_snapend && *len >= 0 && **pptr) {\n \t(*pptr)++;\n \t(*len)--;\n     }\n     (*pptr)++;\n     (*len)--;\n    if (*len < 0 || *pptr > (const char *) ndo->ndo_snapend)\n\treturn NULL;\n     return s;\n }\n", "target": 1, "idx": 181107}
{"func": "cib_remote_dispatch(gpointer user_data)\n {\n     cib_t *cib = user_data;\n     cib_remote_opaque_t *private = cib->variant_opaque;\n \n     xmlNode *msg = NULL;\n    const char *type = NULL;\n \n     crm_info(\"Message on callback channel\");\n    msg = crm_recv_remote_msg(private->callback.session, private->callback.encrypted);\n \n    type = crm_element_value(msg, F_TYPE);\n    crm_trace(\"Activating %s callbacks...\", type);\n \n    if (safe_str_eq(type, T_CIB)) {\n        cib_native_callback(cib, msg, 0, 0);\n \n    } else if (safe_str_eq(type, T_CIB_NOTIFY)) {\n        g_list_foreach(cib->notify_list, cib_native_notify, msg);\n \n    } else {\n        crm_err(\"Unknown message type: %s\", type);\n    }\n \n    if (msg != NULL) {\n         free_xml(msg);\n        return 0;\n     }\n    return -1;\n }\n", "target": 1, "idx": 179323}
{"func": "usage (int ecode, FILE *out)\n{\n  fprintf (out, \"usage: %s [OPTIONS...] [--] COMMAND [ARGS...]\\n\\n\", argv0);\n\n  fprintf (out,\n           \"    --help                       Print this help\\n\"\n           \"    --version                    Print version\\n\"\n           \"    --args FD                    Parse NUL-separated args from FD\\n\"\n           \"    --unshare-all                Unshare every namespace we support by default\\n\"\n           \"    --share-net                  Retain the network namespace (can only combine with --unshare-all)\\n\"\n           \"    --unshare-user               Create new user namespace (may be automatically implied if not setuid)\\n\"\n           \"    --unshare-user-try           Create new user namespace if possible else continue by skipping it\\n\"\n           \"    --unshare-ipc                Create new ipc namespace\\n\"\n           \"    --unshare-pid                Create new pid namespace\\n\"\n           \"    --unshare-net                Create new network namespace\\n\"\n           \"    --unshare-uts                Create new uts namespace\\n\"\n           \"    --unshare-cgroup             Create new cgroup namespace\\n\"\n           \"    --unshare-cgroup-try         Create new cgroup namespace if possible else continue by skipping it\\n\"\n           \"    --uid UID                    Custom uid in the sandbox (requires --unshare-user)\\n\"\n           \"    --gid GID                    Custom gid in the sandbox (requires --unshare-user)\\n\"\n           \"    --hostname NAME              Custom hostname in the sandbox (requires --unshare-uts)\\n\"\n           \"    --chdir DIR                  Change directory to DIR\\n\"\n           \"    --setenv VAR VALUE           Set an environment variable\\n\"\n           \"    --unsetenv VAR               Unset an environment variable\\n\"\n           \"    --lock-file DEST             Take a lock on DEST while sandbox is running\\n\"\n           \"    --sync-fd FD                 Keep this fd open while sandbox is running\\n\"\n           \"    --bind SRC DEST              Bind mount the host path SRC on DEST\\n\"\n           \"    --bind-try SRC DEST          Equal to --bind but ignores non-existent SRC\\n\"\n           \"    --dev-bind SRC DEST          Bind mount the host path SRC on DEST, allowing device access\\n\"\n           \"    --dev-bind-try SRC DEST      Equal to --dev-bind but ignores non-existent SRC\\n\"\n           \"    --ro-bind SRC DEST           Bind mount the host path SRC readonly on DEST\\n\"\n           \"    --ro-bind-try SRC DEST       Equal to --ro-bind but ignores non-existent SRC\\n\"\n           \"    --remount-ro DEST            Remount DEST as readonly; does not recursively remount\\n\"\n           \"    --exec-label LABEL           Exec label for the sandbox\\n\"\n           \"    --file-label LABEL           File label for temporary sandbox content\\n\"\n           \"    --proc DEST                  Mount new procfs on DEST\\n\"\n           \"    --dev DEST                   Mount new dev on DEST\\n\"\n           \"    --tmpfs DEST                 Mount new tmpfs on DEST\\n\"\n           \"    --mqueue DEST                Mount new mqueue on DEST\\n\"\n           \"    --dir DEST                   Create dir at DEST\\n\"\n           \"    --file FD DEST               Copy from FD to destination DEST\\n\"\n           \"    --bind-data FD DEST          Copy from FD to file which is bind-mounted on DEST\\n\"\n           \"    --ro-bind-data FD DEST       Copy from FD to file which is readonly bind-mounted on DEST\\n\"\n           \"    --symlink SRC DEST           Create symlink at DEST with target SRC\\n\"\n           \"    --seccomp FD                 Load and use seccomp rules from FD\\n\"\n           \"    --block-fd FD                Block on FD until some data to read is available\\n\"\n           \"    --userns-block-fd FD         Block on FD until the user namespace is ready\\n\"\n           \"    --info-fd FD                 Write information about the running container to FD\\n\"\n           \"    --json-status-fd FD          Write container status to FD as multiple JSON documents\\n\"\n           \"    --new-session                Create a new terminal session\\n\"\n           \"    --die-with-parent            Kills with SIGKILL child process (COMMAND) when bwrap or bwrap's parent dies.\\n\"\n           \"    --as-pid-1                   Do not install a reaper process with PID=1\\n\"\n           \"    --cap-add CAP                Add cap CAP when running as privileged user\\n\"\n           \"    --cap-drop CAP               Drop cap CAP when running as privileged user\\n\"\n          );\n  exit (ecode);\n}\n", "target": 0, "idx": 89789}
{"func": "rfc1048_print(netdissect_options *ndo,\n\t      register const u_char *bp)\n{\n\tregister uint16_t tag;\n\tregister u_int len;\n\tregister const char *cp;\n\tregister char c;\n\tint first, idx;\n\tuint32_t ul;\n\tuint16_t us;\n\tuint8_t uc, subopt, suboptlen;\n\n\tND_PRINT((ndo, \"\\n\\t  Vendor-rfc1048 Extensions\"));\n\n\t/* Step over magic cookie */\n\tND_PRINT((ndo, \"\\n\\t    Magic Cookie 0x%08x\", EXTRACT_32BITS(bp)));\n\tbp += sizeof(int32_t);\n\n\t/* Loop while we there is a tag left in the buffer */\n\twhile (ND_TTEST2(*bp, 1)) {\n\t\ttag = *bp++;\n\t\tif (tag == TAG_PAD && ndo->ndo_vflag < 3)\n\t\t\tcontinue;\n\t\tif (tag == TAG_END && ndo->ndo_vflag < 3)\n\t\t\treturn;\n\t\tif (tag == TAG_EXTENDED_OPTION) {\n\t\t\tND_TCHECK2(*(bp + 1), 2);\n\t\t\ttag = EXTRACT_16BITS(bp + 1);\n\t\t\t/* XXX we don't know yet if the IANA will\n\t\t\t * preclude overlap of 1-byte and 2-byte spaces.\n\t\t\t * If not, we need to offset tag after this step.\n\t\t\t */\n\t\t\tcp = tok2str(xtag2str, \"?xT%u\", tag);\n\t\t} else\n\t\t\tcp = tok2str(tag2str, \"?T%u\", tag);\n\t\tc = *cp++;\n\n\t\tif (tag == TAG_PAD || tag == TAG_END)\n\t\t\tlen = 0;\n\t\telse {\n\t\t\t/* Get the length; check for truncation */\n\t\t\tND_TCHECK2(*bp, 1);\n\t\t\tlen = *bp++;\n\t\t}\n\n\t\tND_PRINT((ndo, \"\\n\\t    %s Option %u, length %u%s\", cp, tag, len,\n\t\t\t  len > 0 ? \": \" : \"\"));\n\n\t\tif (tag == TAG_PAD && ndo->ndo_vflag > 2) {\n\t\t\tu_int ntag = 1;\n\t\t\twhile (ND_TTEST2(*bp, 1) && *bp == TAG_PAD) {\n\t\t\t\tbp++;\n\t\t\t\tntag++;\n\t\t\t}\n\t\t\tif (ntag > 1)\n\t\t\t\tND_PRINT((ndo, \", occurs %u\", ntag));\n\t\t}\n\n\t\tif (!ND_TTEST2(*bp, len)) {\n\t\t\tND_PRINT((ndo, \"[|rfc1048 %u]\", len));\n\t\t\treturn;\n\t\t}\n\n\t\tif (tag == TAG_DHCP_MESSAGE && len == 1) {\n\t\t\tuc = *bp++;\n\t\t\tND_PRINT((ndo, \"%s\", tok2str(dhcp_msg_values, \"Unknown (%u)\", uc)));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (tag == TAG_PARM_REQUEST) {\n\t\t\tidx = 0;\n\t\t\twhile (len-- > 0) {\n\t\t\t\tuc = *bp++;\n\t\t\t\tcp = tok2str(tag2str, \"?Option %u\", uc);\n\t\t\t\tif (idx % 4 == 0)\n\t\t\t\t\tND_PRINT((ndo, \"\\n\\t      \"));\n\t\t\t\telse\n\t\t\t\t\tND_PRINT((ndo, \", \"));\n\t\t\t\tND_PRINT((ndo, \"%s\", cp + 1));\n\t\t\t\tidx++;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (tag == TAG_EXTENDED_REQUEST) {\n\t\t\tfirst = 1;\n\t\t\twhile (len > 1) {\n\t\t\t\tlen -= 2;\n\t\t\t\tus = EXTRACT_16BITS(bp);\n\t\t\t\tbp += 2;\n\t\t\t\tcp = tok2str(xtag2str, \"?xT%u\", us);\n\t\t\t\tif (!first)\n\t\t\t\t\tND_PRINT((ndo, \"+\"));\n\t\t\t\tND_PRINT((ndo, \"%s\", cp + 1));\n\t\t\t\tfirst = 0;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Print data */\n\t\tif (c == '?') {\n\t\t\t/* Base default formats for unknown tags on data size */\n\t\t\tif (len & 1)\n\t\t\t\tc = 'b';\n\t\t\telse if (len & 2)\n\t\t\t\tc = 's';\n\t\t\telse\n\t\t\t\tc = 'l';\n\t\t}\n\t\tfirst = 1;\n\t\tswitch (c) {\n\n\t\tcase 'a':\n\t\t\t/* ASCII strings */\n\t\t\tND_PRINT((ndo, \"\\\"\"));\n\t\t\tif (fn_printn(ndo, bp, len, ndo->ndo_snapend)) {\n\t\t\t\tND_PRINT((ndo, \"\\\"\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \"\\\"\"));\n\t\t\tbp += len;\n\t\t\tlen = 0;\n\t\t\tbreak;\n\n\t\tcase 'i':\n\t\tcase 'l':\n\t\tcase 'L':\n\t\t\t/* ip addresses/32-bit words */\n\t\t\twhile (len >= sizeof(ul)) {\n\t\t\t\tif (!first)\n\t\t\t\t\tND_PRINT((ndo, \",\"));\n\t\t\t\tul = EXTRACT_32BITS(bp);\n\t\t\t\tif (c == 'i') {\n\t\t\t\t\tul = htonl(ul);\n\t\t\t\t\tND_PRINT((ndo, \"%s\", ipaddr_string(ndo, &ul)));\n\t\t\t\t} else if (c == 'L')\n\t\t\t\t\tND_PRINT((ndo, \"%d\", ul));\n\t\t\t\telse\n\t\t\t\t\tND_PRINT((ndo, \"%u\", ul));\n\t\t\t\tbp += sizeof(ul);\n\t\t\t\tlen -= sizeof(ul);\n\t\t\t\tfirst = 0;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'p':\n\t\t\t/* IP address pairs */\n\t\t\twhile (len >= 2*sizeof(ul)) {\n\t\t\t\tif (!first)\n\t\t\t\t\tND_PRINT((ndo, \",\"));\n\t\t\t\tmemcpy((char *)&ul, (const char *)bp, sizeof(ul));\n\t\t\t\tND_PRINT((ndo, \"(%s:\", ipaddr_string(ndo, &ul)));\n\t\t\t\tbp += sizeof(ul);\n\t\t\t\tmemcpy((char *)&ul, (const char *)bp, sizeof(ul));\n\t\t\t\tND_PRINT((ndo, \"%s)\", ipaddr_string(ndo, &ul)));\n\t\t\t\tbp += sizeof(ul);\n\t\t\t\tlen -= 2*sizeof(ul);\n\t\t\t\tfirst = 0;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 's':\n\t\t\t/* shorts */\n\t\t\twhile (len >= sizeof(us)) {\n\t\t\t\tif (!first)\n\t\t\t\t\tND_PRINT((ndo, \",\"));\n\t\t\t\tus = EXTRACT_16BITS(bp);\n\t\t\t\tND_PRINT((ndo, \"%u\", us));\n\t\t\t\tbp += sizeof(us);\n\t\t\t\tlen -= sizeof(us);\n\t\t\t\tfirst = 0;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'B':\n\t\t\t/* boolean */\n\t\t\twhile (len > 0) {\n\t\t\t\tif (!first)\n\t\t\t\t\tND_PRINT((ndo, \",\"));\n\t\t\t\tswitch (*bp) {\n\t\t\t\tcase 0:\n\t\t\t\t\tND_PRINT((ndo, \"N\"));\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tND_PRINT((ndo, \"Y\"));\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tND_PRINT((ndo, \"%u?\", *bp));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t++bp;\n\t\t\t\t--len;\n\t\t\t\tfirst = 0;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'b':\n\t\tcase 'x':\n\t\tdefault:\n\t\t\t/* Bytes */\n\t\t\twhile (len > 0) {\n\t\t\t\tif (!first)\n\t\t\t\t\tND_PRINT((ndo, c == 'x' ? \":\" : \".\"));\n\t\t\t\tif (c == 'x')\n\t\t\t\t\tND_PRINT((ndo, \"%02x\", *bp));\n\t\t\t\telse\n\t\t\t\t\tND_PRINT((ndo, \"%u\", *bp));\n\t\t\t\t++bp;\n\t\t\t\t--len;\n\t\t\t\tfirst = 0;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase '$':\n\t\t\t/* Guys we can't handle with one of the usual cases */\n\t\t\tswitch (tag) {\n\n\t\t\tcase TAG_NETBIOS_NODE:\n\t\t\t\t/* this option should be at least 1 byte long */\n\t\t\t\tif (len < 1) {\n\t\t\t\t\tND_PRINT((ndo, \"ERROR: length < 1 bytes\"));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttag = *bp++;\n\t\t\t\t--len;\n\t\t\t\tND_PRINT((ndo, \"%s\", tok2str(nbo2str, NULL, tag)));\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_OPT_OVERLOAD:\n\t\t\t\t/* this option should be at least 1 byte long */\n\t\t\t\tif (len < 1) {\n\t\t\t\t\tND_PRINT((ndo, \"ERROR: length < 1 bytes\"));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttag = *bp++;\n\t\t\t\t--len;\n\t\t\t\tND_PRINT((ndo, \"%s\", tok2str(oo2str, NULL, tag)));\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_CLIENT_FQDN:\n\t\t\t\t/* this option should be at least 3 bytes long */\n\t\t\t\tif (len < 3) {\n\t\t\t\t\tND_PRINT((ndo, \"ERROR: length < 3 bytes\"));\n\t\t\t\t\tbp += len;\n\t\t\t\t\tlen = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (*bp)\n\t\t\t\t\tND_PRINT((ndo, \"[%s] \", client_fqdn_flags(*bp)));\n\t\t\t\tbp++;\n\t\t\t\tif (*bp || *(bp+1))\n\t\t\t\t\tND_PRINT((ndo, \"%u/%u \", *bp, *(bp+1)));\n\t\t\t\tbp += 2;\n\t\t\t\tND_PRINT((ndo, \"\\\"\"));\n\t\t\t\tif (fn_printn(ndo, bp, len - 3, ndo->ndo_snapend)) {\n\t\t\t\t\tND_PRINT((ndo, \"\\\"\"));\n\t\t\t\t\tgoto trunc;\n\t\t\t\t}\n\t\t\t\tND_PRINT((ndo, \"\\\"\"));\n\t\t\t\tbp += len - 3;\n\t\t\t\tlen = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_CLIENT_ID:\n\t\t\t    {\n\t\t\t\tint type;\n\n\t\t\t\t/* this option should be at least 1 byte long */\n\t\t\t\tif (len < 1) {\n\t\t\t\t\tND_PRINT((ndo, \"ERROR: length < 1 bytes\"));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttype = *bp++;\n\t\t\t\tlen--;\n\t\t\t\tif (type == 0) {\n\t\t\t\t\tND_PRINT((ndo, \"\\\"\"));\n\t\t\t\t\tif (fn_printn(ndo, bp, len, ndo->ndo_snapend)) {\n\t\t\t\t\t\tND_PRINT((ndo, \"\\\"\"));\n\t\t\t\t\t\tgoto trunc;\n\t\t\t\t\t}\n\t\t\t\t\tND_PRINT((ndo, \"\\\"\"));\n\t\t\t\t\tbp += len;\n\t\t\t\t\tlen = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tND_PRINT((ndo, \"%s \", tok2str(arp2str, \"hardware-type %u,\", type)));\n\t\t\t\t\twhile (len > 0) {\n\t\t\t\t\t\tif (!first)\n\t\t\t\t\t\t\tND_PRINT((ndo, \":\"));\n\t\t\t\t\t\tND_PRINT((ndo, \"%02x\", *bp));\n\t\t\t\t\t\t++bp;\n\t\t\t\t\t\t--len;\n\t\t\t\t\t\tfirst = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t    }\n\n\t\t\tcase TAG_AGENT_CIRCUIT:\n\t\t\t\twhile (len >= 2) {\n\t\t\t\t\tsubopt = *bp++;\n\t\t\t\t\tsuboptlen = *bp++;\n\t\t\t\t\tlen -= 2;\n\t\t\t\t\tif (suboptlen > len) {\n\t\t\t\t\t\tND_PRINT((ndo, \"\\n\\t      %s SubOption %u, length %u: length goes past end of option\",\n\t\t\t\t\t\t\t  tok2str(agent_suboption_values, \"Unknown\", subopt),\n\t\t\t\t\t\t\t  subopt,\n\t\t\t\t\t\t\t  suboptlen));\n\t\t\t\t\t\tbp += len;\n\t\t\t\t\t\tlen = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tND_PRINT((ndo, \"\\n\\t      %s SubOption %u, length %u: \",\n\t\t\t\t\t\t  tok2str(agent_suboption_values, \"Unknown\", subopt),\n\t\t\t\t\t\t  subopt,\n\t\t\t\t\t\t  suboptlen));\n\t\t\t\t\tswitch (subopt) {\n\n\t\t\t\t\tcase AGENT_SUBOPTION_CIRCUIT_ID: /* fall through */\n\t\t\t\t\tcase AGENT_SUBOPTION_REMOTE_ID:\n\t\t\t\t\tcase AGENT_SUBOPTION_SUBSCRIBER_ID:\n\t\t\t\t\t\tif (fn_printn(ndo, bp, suboptlen, ndo->ndo_snapend))\n\t\t\t\t\t\t\tgoto trunc;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tprint_unknown_data(ndo, bp, \"\\n\\t\\t\", suboptlen);\n\t\t\t\t\t}\n\n\t\t\t\t\tlen -= suboptlen;\n\t\t\t\t\tbp += suboptlen;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_CLASSLESS_STATIC_RT:\n\t\t\tcase TAG_CLASSLESS_STA_RT_MS:\n\t\t\t    {\n\t\t\t\tu_int mask_width, significant_octets, i;\n\n\t\t\t\t/* this option should be at least 5 bytes long */\n\t\t\t\tif (len < 5) {\n\t\t\t\t\tND_PRINT((ndo, \"ERROR: length < 5 bytes\"));\n\t\t\t\t\tbp += len;\n\t\t\t\t\tlen = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\twhile (len > 0) {\n\t\t\t\t\tif (!first)\n\t\t\t\t\t\tND_PRINT((ndo, \",\"));\n\t\t\t\t\tmask_width = *bp++;\n\t\t\t\t\tlen--;\n\t\t\t\t\t/* mask_width <= 32 */\n\t\t\t\t\tif (mask_width > 32) {\n\t\t\t\t\t\tND_PRINT((ndo, \"[ERROR: Mask width (%d) > 32]\", mask_width));\n\t\t\t\t\t\tbp += len;\n\t\t\t\t\t\tlen = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsignificant_octets = (mask_width + 7) / 8;\n\t\t\t\t\t/* significant octets + router(4) */\n\t\t\t\t\tif (len < significant_octets + 4) {\n\t\t\t\t\t\tND_PRINT((ndo, \"[ERROR: Remaining length (%u) < %u bytes]\", len, significant_octets + 4));\n\t\t\t\t\t\tbp += len;\n\t\t\t\t\t\tlen = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tND_PRINT((ndo, \"(\"));\n\t\t\t\t\tif (mask_width == 0)\n\t\t\t\t\t\tND_PRINT((ndo, \"default\"));\n\t\t\t\t\telse {\n\t\t\t\t\t\tfor (i = 0; i < significant_octets ; i++) {\n\t\t\t\t\t\t\tif (i > 0)\n\t\t\t\t\t\t\t\tND_PRINT((ndo, \".\"));\n\t\t\t\t\t\t\tND_PRINT((ndo, \"%d\", *bp++));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (i = significant_octets ; i < 4 ; i++)\n\t\t\t\t\t\t\tND_PRINT((ndo, \".0\"));\n\t\t\t\t\t\tND_PRINT((ndo, \"/%d\", mask_width));\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy((char *)&ul, (const char *)bp, sizeof(ul));\n\t\t\t\t\tND_PRINT((ndo, \":%s)\", ipaddr_string(ndo, &ul)));\n\t\t\t\t\tbp += sizeof(ul);\n\t\t\t\t\tlen -= (significant_octets + 4);\n\t\t\t\t\tfirst = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t    }\n\n\t\t\tcase TAG_USER_CLASS:\n\t\t\t    {\n\t\t\t\tu_int suboptnumber = 1;\n\n\t\t\t\tfirst = 1;\n\t\t\t\tif (len < 2) {\n\t\t\t\t\tND_PRINT((ndo, \"ERROR: length < 2 bytes\"));\n\t\t\t\t\tbp += len;\n\t\t\t\t\tlen = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\twhile (len > 0) {\n\t\t\t\t\tsuboptlen = *bp++;\n\t\t\t\t\tlen--;\n\t\t\t\t\tND_PRINT((ndo, \"\\n\\t      \"));\n\t\t\t\t\tND_PRINT((ndo, \"instance#%u: \", suboptnumber));\n\t\t\t\t\tif (suboptlen == 0) {\n\t\t\t\t\t\tND_PRINT((ndo, \"ERROR: suboption length must be non-zero\"));\n\t\t\t\t\t\tbp += len;\n\t\t\t\t\t\tlen = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (len < suboptlen) {\n\t\t\t\t\t\tND_PRINT((ndo, \"ERROR: invalid option\"));\n\t\t\t\t\t\tbp += len;\n\t\t\t\t\t\tlen = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tND_PRINT((ndo, \"\\\"\"));\n\t\t\t\t\tif (fn_printn(ndo, bp, suboptlen, ndo->ndo_snapend)) {\n\t\t\t\t\t\tND_PRINT((ndo, \"\\\"\"));\n\t\t\t\t\t\tgoto trunc;\n\t\t\t\t\t}\n\t\t\t\t\tND_PRINT((ndo, \"\\\"\"));\n\t\t\t\t\tND_PRINT((ndo, \", length %d\", suboptlen));\n\t\t\t\t\tsuboptnumber++;\n\t\t\t\t\tlen -= suboptlen;\n\t\t\t\t\tbp += suboptlen;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t    }\n\n\t\t\tdefault:\n\t\t\t\tND_PRINT((ndo, \"[unknown special tag %u, size %u]\",\n\t\t\t\t\t  tag, len));\n\t\t\t\tbp += len;\n\t\t\t\tlen = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t/* Data left over? */\n\t\tif (len) {\n\t\t\tND_PRINT((ndo, \"\\n\\t  trailing data length %u\", len));\n\t\t\tbp += len;\n\t\t}\n\t}\n\treturn;\ntrunc:\n\tND_PRINT((ndo, \"|[rfc1048]\"));\n}\n", "target": 0, "idx": 95092}
{"func": "GC_INNER void * GC_generic_malloc_ignore_off_page(size_t lb, int k)\n{\n    void *result;\n    size_t lg;\n    size_t lb_rounded;\n    word n_blocks;\n    GC_bool init;\n    DCL_LOCK_STATE;\n\n    if (SMALL_OBJ(lb))\n         return(GC_generic_malloc((word)lb, k));\n     lg = ROUNDED_UP_GRANULES(lb);\n     lb_rounded = GRANULES_TO_BYTES(lg);\n     n_blocks = OBJ_SZ_TO_BLOCKS(lb_rounded);\n     init = GC_obj_kinds[k].ok_init;\n     if (EXPECT(GC_have_errors, FALSE))\n      GC_print_all_errors();\n    GC_INVOKE_FINALIZERS();\n    LOCK();\n    result = (ptr_t)GC_alloc_large(ADD_SLOP(lb), k, IGNORE_OFF_PAGE);\n    if (0 != result) {\n        if (GC_debugging_started) {\n            BZERO(result, n_blocks * HBLKSIZE);\n        } else {\n#           ifdef THREADS\n              /* Clear any memory that might be used for GC descriptors */\n              /* before we release the lock.                          */\n                ((word *)result)[0] = 0;\n                ((word *)result)[1] = 0;\n                ((word *)result)[GRANULES_TO_WORDS(lg)-1] = 0;\n                ((word *)result)[GRANULES_TO_WORDS(lg)-2] = 0;\n#           endif\n        }\n    }\n    GC_bytes_allocd += lb_rounded;\n    if (0 == result) {\n        GC_oom_func oom_fn = GC_oom_fn;\n        UNLOCK();\n        return((*oom_fn)(lb));\n    } else {\n        UNLOCK();\n        if (init && !GC_debugging_started) {\n            BZERO(result, n_blocks * HBLKSIZE);\n        }\n        return(result);\n    }\n}\n", "target": 1, "idx": 183051}
{"func": "const char *string_of_NPNVariable(int variable)\n{\n  const char *str;\n\n  switch (variable) {\n#define _(VAL) case VAL: str = #VAL; break;\n\t_(NPNVxDisplay);\n\t_(NPNVxtAppContext);\n\t_(NPNVnetscapeWindow);\n\t_(NPNVjavascriptEnabledBool);\n\t_(NPNVasdEnabledBool);\n\t_(NPNVisOfflineBool);\n\t_(NPNVserviceManager);\n\t_(NPNVDOMElement);\n\t_(NPNVDOMWindow);\n\t_(NPNVToolkit);\n\t_(NPNVSupportsXEmbedBool);\n \t_(NPNVWindowNPObject);\n \t_(NPNVPluginElementNPObject);\n \t_(NPNVSupportsWindowless);\n #undef _\n   default:\n \tswitch (variable & 0xff) {\n#define _(VAL, VAR) case VAL: str = #VAR; break\n\t  _(10, NPNVserviceManager);\n\t  _(11, NPNVDOMElement);\n\t  _(12, NPNVDOMWindow);\n\t  _(13, NPNVToolkit);\n#undef _\n\tdefault:\n\t  str = \"<unknown variable>\";\n\t  break;\n\t}\n\tbreak;\n  }\n\n  return str;\n}\n", "target": 1, "idx": 179037}
{"func": "   void DoTest(ExternalProtocolHandler::BlockState block_state,\n               shell_integration::DefaultWebClientState os_state,\n               Action expected_action) {\n    GURL url(\"mailto:test@test.com\");\n     EXPECT_FALSE(delegate_.has_prompted());\n     EXPECT_FALSE(delegate_.has_launched());\n     EXPECT_FALSE(delegate_.has_blocked());\n\n    delegate_.set_block_state(block_state);\n    delegate_.set_os_state(os_state);\n    ExternalProtocolHandler::LaunchUrlWithDelegate(\n        url, 0, 0, ui::PAGE_TRANSITION_LINK, true, &delegate_);\n    content::RunAllTasksUntilIdle();\n\n    EXPECT_EQ(expected_action == Action::PROMPT, delegate_.has_prompted());\n    EXPECT_EQ(expected_action == Action::LAUNCH, delegate_.has_launched());\n    EXPECT_EQ(expected_action == Action::BLOCK, delegate_.has_blocked());\n  }\n", "target": 1, "idx": 186665}
{"func": "static BOOL nsc_context_initialize_encode(NSC_CONTEXT* context)\n{\n\tint i;\n\tUINT32 length;\n\tUINT32 tempWidth;\n\tUINT32 tempHeight;\n\ttempWidth = ROUND_UP_TO(context->width, 8);\n\ttempHeight = ROUND_UP_TO(context->height, 2);\n\t/* The maximum length a decoded plane can reach in all cases */\n\tlength = tempWidth * tempHeight + 16;\n\n\tif (length > context->priv->PlaneBuffersLength)\n\t{\n \t\tfor (i = 0; i < 5; i++)\n \t\t{\n \t\t\tBYTE* tmp = (BYTE*) realloc(context->priv->PlaneBuffers[i], length);\n \t\t\tif (!tmp)\n \t\t\t\tgoto fail;\n \n\t\t\tcontext->priv->PlaneBuffers[i] = tmp;\n\t\t}\n\n\t\tcontext->priv->PlaneBuffersLength = length;\n\t}\n\n\tif (context->ChromaSubsamplingLevel)\n\t{\n\t\tcontext->OrgByteCount[0] = tempWidth * context->height;\n\t\tcontext->OrgByteCount[1] = tempWidth * tempHeight / 4;\n\t\tcontext->OrgByteCount[2] = tempWidth * tempHeight / 4;\n\t\tcontext->OrgByteCount[3] = context->width * context->height;\n\t}\n\telse\n\t{\n\t\tcontext->OrgByteCount[0] = context->width * context->height;\n\t\tcontext->OrgByteCount[1] = context->width * context->height;\n\t\tcontext->OrgByteCount[2] = context->width * context->height;\n\t\tcontext->OrgByteCount[3] = context->width * context->height;\n\t}\n\n\treturn TRUE;\nfail:\n\n\tif (length > context->priv->PlaneBuffersLength)\n\t{\n\t\tfor (i = 0; i < 5; i++)\n\t\t\tfree(context->priv->PlaneBuffers[i]);\n\t}\n\n \treturn FALSE;\n }\n", "target": 1, "idx": 182458}
{"func": "static int snd_timer_user_tselect(struct file *file,\n\t\t\t\t  struct snd_timer_select __user *_tselect)\n{\n\tstruct snd_timer_user *tu;\n\tstruct snd_timer_select tselect;\n\tchar str[32];\n\tint err = 0;\n\n\ttu = file->private_data;\n\tif (tu->timeri) {\n\t\tsnd_timer_close(tu->timeri);\n\t\ttu->timeri = NULL;\n\t}\n\tif (copy_from_user(&tselect, _tselect, sizeof(tselect))) {\n\t\terr = -EFAULT;\n\t\tgoto __err;\n\t}\n\tsprintf(str, \"application %i\", current->pid);\n\tif (tselect.id.dev_class != SNDRV_TIMER_CLASS_SLAVE)\n\t\ttselect.id.dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION;\n\terr = snd_timer_open(&tu->timeri, str, &tselect.id, current->pid);\n \tif (err < 0)\n \t\tgoto __err;\n \n \tkfree(tu->queue);\n \ttu->queue = NULL;\n \tkfree(tu->tqueue);\n\ttu->tqueue = NULL;\n\tif (tu->tread) {\n\t\ttu->tqueue = kmalloc(tu->queue_size * sizeof(struct snd_timer_tread),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (tu->tqueue == NULL)\n\t\t\terr = -ENOMEM;\n\t} else {\n\t\ttu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),\n\t\t\t\t    GFP_KERNEL);\n\t\tif (tu->queue == NULL)\n\t\t\terr = -ENOMEM;\n\t}\n\n      \tif (err < 0) {\n\t\tsnd_timer_close(tu->timeri);\n      \t\ttu->timeri = NULL;\n      \t} else {\n\t\ttu->timeri->flags |= SNDRV_TIMER_IFLG_FAST;\n\t\ttu->timeri->callback = tu->tread\n\t\t\t? snd_timer_user_tinterrupt : snd_timer_user_interrupt;\n\t\ttu->timeri->ccallback = snd_timer_user_ccallback;\n\t\ttu->timeri->callback_data = (void *)tu;\n\t\ttu->timeri->disconnect = snd_timer_user_disconnect;\n\t}\n\n      __err:\n\treturn err;\n}\n", "target": 1, "idx": 180791}
{"func": "GF_Err name_Size(GF_Box *s)\n{\n\tGF_NameBox *ptr = (GF_NameBox *)s;\n\tif (ptr->string) ptr->size += strlen(ptr->string) + 1;\n\treturn GF_OK;\n}\n", "target": 0, "idx": 80284}
{"func": "asmlinkage long compat_sys_recvmmsg(int fd, struct compat_mmsghdr __user *mmsg,\n\t\t\t\t    unsigned int vlen, unsigned int flags,\n\t\t\t\t    struct compat_timespec __user *timeout)\n{\n\tint datagrams;\n\tstruct timespec ktspec;\n\n \tif (flags & MSG_CMSG_COMPAT)\n \t\treturn -EINVAL;\n \n\tif (COMPAT_USE_64BIT_TIME)\n\t\treturn __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t      flags | MSG_CMSG_COMPAT,\n\t\t\t\t      (struct timespec *) timeout);\n \tif (timeout == NULL)\n \t\treturn __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n \t\t\t\t      flags | MSG_CMSG_COMPAT, NULL);\n \n\tif (get_compat_timespec(&ktspec, timeout))\n \t\treturn -EFAULT;\n \n \tdatagrams = __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n \t\t\t\t   flags | MSG_CMSG_COMPAT, &ktspec);\n\tif (datagrams > 0 && put_compat_timespec(&ktspec, timeout))\n \t\tdatagrams = -EFAULT;\n \n \treturn datagrams;\n}\n", "target": 1, "idx": 179639}
{"func": "NO_INLINE JsVar *jspeFactorFunctionCall() {\n  /* The parent if we're executing a method call */\n  bool isConstructor = false;\n  if (lex->tk==LEX_R_NEW) {\n    JSP_ASSERT_MATCH(LEX_R_NEW);\n    isConstructor = true;\n\n    if (lex->tk==LEX_R_NEW) {\n      jsExceptionHere(JSET_ERROR, \"Nesting 'new' operators is unsupported\");\n      jspSetError(false);\n      return 0;\n    }\n  }\n\n  JsVar *parent = 0;\n#ifndef SAVE_ON_FLASH\n  bool wasSuper = lex->tk==LEX_R_SUPER;\n#endif\n  JsVar *a = jspeFactorMember(jspeFactor(), &parent);\n#ifndef SAVE_ON_FLASH\n  if (wasSuper) {\n    /* if this was 'super.something' then we need\n     * to overwrite the parent, because it'll be\n     * set to the prototype otherwise.\n     */\n    jsvUnLock(parent);\n    parent = jsvLockAgainSafe(execInfo.thisVar);\n  }\n#endif\n\n  while ((lex->tk=='(' || (isConstructor && JSP_SHOULD_EXECUTE)) && !jspIsInterrupted()) {\n    JsVar *funcName = a;\n    JsVar *func = jsvSkipName(funcName);\n\n    /* The constructor function doesn't change parsing, so if we're\n     * not executing, just short-cut it. */\n    if (isConstructor && JSP_SHOULD_EXECUTE) {\n      bool parseArgs = lex->tk=='(';\n      a = jspeConstruct(func, funcName, parseArgs);\n      isConstructor = false; // don't treat subsequent brackets as constructors\n    } else\n      a = jspeFunctionCall(func, funcName, parent, true, 0, 0);\n\n    jsvUnLock3(funcName, func, parent);\n    parent=0;\n    a = jspeFactorMember(a, &parent);\n  }\n#ifndef SAVE_ON_FLASH\n  /* If we've got something that we care about the parent of (eg. a getter/setter)\n   * then we repackage it into a 'NewChild' name that references the parent before\n   * we leave. Note: You can't do this on everything because normally NewChild\n   * forces a new child to be blindly created. It works on Getters/Setters because\n   * we *always* run those rather than adding them.\n   */\n  if (parent && jsvIsName(a) && !jsvIsNewChild(a)) {\n    JsVar *value = jsvGetValueOfName(a);\n    if (jsvIsGetterOrSetter(value)) { // no need to do this for functions since we've just executed whatever we needed to\n      JsVar *nameVar = jsvCopyNameOnly(a,false,true);\n      JsVar *newChild = jsvCreateNewChild(parent, nameVar, value);\n      jsvUnLock2(nameVar, a);\n      a = newChild;\n    }\n    jsvUnLock(value);\n  }\n#endif\n  jsvUnLock(parent);\n  return a;\n}\n", "target": 0, "idx": 82347}
{"func": "void ThreadableBlobRegistry::registerBlobURL(SecurityOrigin* origin, const KURL& url, const KURL& srcURL)\n {\n     if (origin && BlobURL::getOrigin(url) == \"null\")\n         originMap()->add(url.string(), origin);\n \n    if (isMainThread())\n        blobRegistry().registerBlobURL(url, srcURL);\n    else {\n         OwnPtr<BlobRegistryContext> context = adoptPtr(new BlobRegistryContext(url, srcURL));\n         callOnMainThread(&registerBlobURLFromTask, context.leakPtr());\n     }\n}\n", "target": 1, "idx": 184259}
{"func": "PHP_FUNCTION(openssl_x509_check_private_key)\n{\n\tzval ** zcert, **zkey;\n\tX509 * cert = NULL;\n\tEVP_PKEY * key = NULL;\n\tlong certresource = -1, keyresource = -1;\n\n\tRETVAL_FALSE;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ZZ\", &zcert, &zkey) == FAILURE) {\n\t\treturn;\n\t}\n\tcert = php_openssl_x509_from_zval(zcert, 0, &certresource TSRMLS_CC);\n\tif (cert == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tkey = php_openssl_evp_from_zval(zkey, 0, \"\", 1, &keyresource TSRMLS_CC);\n\tif (key) {\n\t\tRETVAL_BOOL(X509_check_private_key(cert, key));\n\t}\n\n\tif (keyresource == -1 && key) {\n\t\tEVP_PKEY_free(key);\n\t}\n\tif (certresource == -1 && cert) {\n\t\tX509_free(cert);\n\t}\n }\n", "target": 0, "idx": 2020}
{"func": " queue_unlock(struct futex_q *q, struct futex_hash_bucket *hb)\n {\n \tspin_unlock(&hb->lock);\n\tdrop_futex_key_refs(&q->key);\n }\n", "target": 1, "idx": 179624}
{"func": "static int asepcos_build_pin_apdu(sc_card_t *card, sc_apdu_t *apdu,\n\tstruct sc_pin_cmd_data *data, u8 *buf, size_t buf_len,\n\tunsigned int cmd, int is_puk)\n{\n\tint r, fileid;\n\tu8  *p = buf;\n\tsc_cardctl_asepcos_akn2fileid_t st;\n\n\tswitch (cmd) {\n\tcase SC_PIN_CMD_VERIFY:\n\t\tst.akn = data->pin_reference;\n\t\tr = asepcos_akn_to_fileid(card, &st);\n\t\tif (r != SC_SUCCESS)\n\t\t\treturn r;\n\t\tfileid = st.fileid;\n\t\t/* the fileid of the puk is the fileid of the pin + 1 */\n\t\tif (is_puk != 0)\n\t\t\tfileid++;\n\t\tsc_format_apdu(card, apdu, SC_APDU_CASE_3_SHORT, 0x20, 0x02, 0x80);\n\t\t*p++ = (fileid >> 24) & 0xff;\n\t\t*p++ = (fileid >> 16) & 0xff;\n\t\t*p++ = (fileid >> 8 ) & 0xff;\n\t\t*p++ = fileid & 0xff;\n\t\tmemcpy(p, data->pin1.data, data->pin1.len);\n\t\tp += data->pin1.len;\n\t\tapdu->lc       = p - buf;\n\t\tapdu->datalen  = p - buf;\n\t\tapdu->data     = buf;\n\t\tbreak;\n\tcase SC_PIN_CMD_CHANGE:\n\t\t/* build the CHANGE KEY apdu. Note: the PIN file is implicitly\n\t\t * selected by its SFID */\n\t\t*p++ = 0x81;\n\t\t*p++ = data->pin2.len & 0xff;\n\t\tmemcpy(p, data->pin2.data, data->pin2.len);\n\t\tp   += data->pin2.len;\n\t\tst.akn = data->pin_reference;\n\t\tr = asepcos_akn_to_fileid(card, &st);\n\t\tif (r != SC_SUCCESS)\n\t\t\treturn r;\n\t\tfileid = 0x80 | (st.fileid & 0x1f);\n\t\tsc_format_apdu(card, apdu, SC_APDU_CASE_3_SHORT, 0x24, 0x01, fileid);\n\t\tapdu->lc       = p - buf;\n\t\tapdu->datalen  = p - buf;\n\t\tapdu->data     = buf;\n\t\tbreak;\n\tcase SC_PIN_CMD_UNBLOCK:\n\t\t/* build the UNBLOCK KEY apdu. The PIN file is implicitly \n\t\t * selected by its SFID. The new PIN is provided in the\n\t\t * data field of the UNBLOCK KEY command. */\n\t\t*p++ = 0x81;\n\t\t*p++ = data->pin2.len & 0xff;\n\t\tmemcpy(p, data->pin2.data, data->pin2.len);\n\t\tp   += data->pin2.len;\n\t\tst.akn = data->pin_reference;\n\t\tr = asepcos_akn_to_fileid(card, &st);\n\t\tif (r != SC_SUCCESS)\n\t\t\treturn r;\n\t\tfileid = 0x80 | (st.fileid & 0x1f);\n\t\tsc_format_apdu(card, apdu, SC_APDU_CASE_3_SHORT, 0x2C, 0x02, fileid);\n\t\tapdu->lc       = p - buf;\n\t\tapdu->datalen  = p - buf;\n\t\tapdu->data     = buf;\n\t\tbreak;\n\tdefault:\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t}\n\treturn SC_SUCCESS;\n}\n", "target": 0, "idx": 78153}
{"func": "int t2p_process_jpeg_strip(\n\tunsigned char* strip, \n\ttsize_t* striplength, \n\tunsigned char* buffer, \n    tsize_t buffersize,\n\ttsize_t* bufferoffset, \n\ttstrip_t no, \n\tuint32 height){\n\n\ttsize_t i=0;\n\n\twhile (i < *striplength) {\n\t\ttsize_t datalen;\n\t\tuint16 ri;\n\t\tuint16 v_samp;\n\t\tuint16 h_samp;\n\t\tint j;\n\t\tint ncomp;\n\n\t\t/* marker header: one or more FFs */\n\t\tif (strip[i] != 0xff)\n\t\t\treturn(0);\n\t\ti++;\n\t\twhile (i < *striplength && strip[i] == 0xff)\n\t\t\ti++;\n\t\tif (i >= *striplength)\n\t\t\treturn(0);\n\t\t/* SOI is the only pre-SOS marker without a length word */\n\t\tif (strip[i] == 0xd8)\n\t\t\tdatalen = 0;\n\t\telse {\n\t\t\tif ((*striplength - i) <= 2)\n\t\t\t\treturn(0);\n\t\t\tdatalen = (strip[i+1] << 8) | strip[i+2];\n\t\t\tif (datalen < 2 || datalen >= (*striplength - i))\n\t\t\t\treturn(0);\n\t\t}\n\t\tswitch( strip[i] ){\n\t\t\tcase 0xd8:\t/* SOI - start of image */\n                if( *bufferoffset + 2 > buffersize )\n                    return(0);\n\t\t\t\t_TIFFmemcpy(&(buffer[*bufferoffset]), &(strip[i-1]), 2);\n\t\t\t\t*bufferoffset+=2;\n\t\t\t\tbreak;\n\t\t\tcase 0xc0:\t/* SOF0 */\n\t\t\tcase 0xc1:\t/* SOF1 */\n\t\t\tcase 0xc3:\t/* SOF3 */\n\t\t\tcase 0xc9:\t/* SOF9 */\n\t\t\tcase 0xca:\t/* SOF10 */\n\t\t\t\tif(no==0){\n                    if( *bufferoffset + datalen + 2 + 6 > buffersize )\n                        return(0);\n\t\t\t\t\t_TIFFmemcpy(&(buffer[*bufferoffset]), &(strip[i-1]), datalen+2);\n                    if( *bufferoffset + 9 >= buffersize )\n                        return(0);\n\t\t\t\t\tncomp = buffer[*bufferoffset+9];\n\t\t\t\t\tif (ncomp < 1 || ncomp > 4)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t\tv_samp=1;\n\t\t\t\t\th_samp=1;\n                    if( *bufferoffset + 11 + 3*(ncomp-1) >= buffersize )\n                        return(0);\n\t\t\t\t\tfor(j=0;j<ncomp;j++){\n\t\t\t\t\t\tuint16 samp = buffer[*bufferoffset+11+(3*j)];\n\t\t\t\t\t\tif( (samp>>4) > h_samp) \n\t\t\t\t\t\t\th_samp = (samp>>4);\n\t\t\t\t\t\tif( (samp & 0x0f) > v_samp) \n\t\t\t\t\t\t\tv_samp = (samp & 0x0f);\n\t\t\t\t\t}\n\t\t\t\t\tv_samp*=8;\n\t\t\t\t\th_samp*=8;\n\t\t\t\t\tri=((( ((uint16)(buffer[*bufferoffset+5])<<8) | \n\t\t\t\t\t(uint16)(buffer[*bufferoffset+6]) )+v_samp-1)/ \n\t\t\t\t\tv_samp);\n\t\t\t\t\tri*=((( ((uint16)(buffer[*bufferoffset+7])<<8) | \n\t\t\t\t\t(uint16)(buffer[*bufferoffset+8]) )+h_samp-1)/ \n\t\t\t\t\th_samp);\n\t\t\t\t\tbuffer[*bufferoffset+5]=\n                                          (unsigned char) ((height>>8) & 0xff);\n\t\t\t\t\tbuffer[*bufferoffset+6]=\n                                            (unsigned char) (height & 0xff);\n\t\t\t\t\t*bufferoffset+=datalen+2;\n\t\t\t\t\t/* insert a DRI marker */\n\t\t\t\t\tbuffer[(*bufferoffset)++]=0xff;\n\t\t\t\t\tbuffer[(*bufferoffset)++]=0xdd;\n\t\t\t\t\tbuffer[(*bufferoffset)++]=0x00;\n\t\t\t\t\tbuffer[(*bufferoffset)++]=0x04;\n\t\t\t\t\tbuffer[(*bufferoffset)++]=(ri >> 8) & 0xff;\n\t\t\t\t\tbuffer[(*bufferoffset)++]= ri & 0xff;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 0xc4: /* DHT */\n\t\t\tcase 0xdb: /* DQT */\n                if( *bufferoffset + datalen + 2 > buffersize )\n                    return(0);\n\t\t\t\t_TIFFmemcpy(&(buffer[*bufferoffset]), &(strip[i-1]), datalen+2);\n\t\t\t\t*bufferoffset+=datalen+2;\n\t\t\t\tbreak;\n\t\t\tcase 0xda: /* SOS */\n\t\t\t\tif(no==0){\n                    if( *bufferoffset + datalen + 2 > buffersize )\n                        return(0);\n\t\t\t\t\t_TIFFmemcpy(&(buffer[*bufferoffset]), &(strip[i-1]), datalen+2);\n\t\t\t\t\t*bufferoffset+=datalen+2;\n\t\t\t\t} else {\n                    if( *bufferoffset + 2 > buffersize )\n                        return(0);\n\t\t\t\t\tbuffer[(*bufferoffset)++]=0xff;\n\t\t\t\t\tbuffer[(*bufferoffset)++]=\n                                            (unsigned char)(0xd0 | ((no-1)%8));\n\t\t\t\t}\n\t\t\t\ti += datalen + 1;\n\t\t\t\t/* copy remainder of strip */\n                if( *bufferoffset + *striplength - i > buffersize )\n                    return(0);\n\t\t\t\t_TIFFmemcpy(&(buffer[*bufferoffset]), &(strip[i]), *striplength - i);\n\t\t\t\t*bufferoffset+= *striplength - i;\n\t\t\t\treturn(1);\n\t\t\tdefault:\n\t\t\t\t/* ignore any other marker */\n\t\t\t\tbreak;\n\t\t}\n\t\ti += datalen + 1;\n\t}\n\n\t/* failed to find SOS marker */\n\treturn(0);\n}\n", "target": 0, "idx": 71378}
{"func": "static netdev_tx_t hns_nic_net_xmit(struct sk_buff *skb,\n \t\t\t\t    struct net_device *ndev)\n {\n \tstruct hns_nic_priv *priv = netdev_priv(ndev);\n\tint ret;\n \n \tassert(skb->queue_mapping < ndev->ae_handle->q_num);\n\tret = hns_nic_net_xmit_hw(ndev, skb,\n\t\t\t\t  &tx_ring_data(priv, skb->queue_mapping));\n\tif (ret == NETDEV_TX_OK) {\n\t\tnetif_trans_update(ndev);\n\t\tndev->stats.tx_bytes += skb->len;\n\t\tndev->stats.tx_packets++;\n\t}\n\treturn (netdev_tx_t)ret;\n }\n", "target": 1, "idx": 182575}
{"func": "static SharedMemorySupport DoQuerySharedMemorySupport(Display* dpy) {\n  int dummy;\n  Bool pixmaps_supported;\n  if (!XShmQueryVersion(dpy, &dummy, &dummy, &pixmaps_supported))\n    return SHARED_MEMORY_NONE;\n\n#if defined(OS_FREEBSD)\n  int allow_removed;\n  size_t length = sizeof(allow_removed);\n\n  if ((sysctlbyname(\"kern.ipc.shm_allow_removed\", &allow_removed, &length,\n      NULL, 0) < 0) || allow_removed < 1) {\n    return SHARED_MEMORY_NONE;\n  }\n #endif\n \n  int shmkey = shmget(IPC_PRIVATE, 1, 0666);\n  if (shmkey == -1)\n     return SHARED_MEMORY_NONE;\n   void* address = shmat(shmkey, NULL, 0);\n   shmctl(shmkey, IPC_RMID, NULL);\n\n  XShmSegmentInfo shminfo;\n  memset(&shminfo, 0, sizeof(shminfo));\n  shminfo.shmid = shmkey;\n \n   gdk_error_trap_push();\n   bool result = XShmAttach(dpy, &shminfo);\n   XSync(dpy, False);\n   if (gdk_error_trap_pop())\n     result = false;\n   shmdt(address);\n  if (!result)\n     return SHARED_MEMORY_NONE;\n \n   XShmDetach(dpy, &shminfo);\n   return pixmaps_supported ? SHARED_MEMORY_PIXMAP : SHARED_MEMORY_PUTIMAGE;\n}\n", "target": 1, "idx": 185297}
{"func": "static inline void unmap_mapping_range_tree(struct rb_root *root,\n\t\t\t\t\t    struct zap_details *details)\n{\n\tstruct vm_area_struct *vma;\n\tpgoff_t vba, vea, zba, zea;\n\n\tvma_interval_tree_foreach(vma, root,\n\t\t\tdetails->first_index, details->last_index) {\n\n\t\tvba = vma->vm_pgoff;\n\t\tvea = vba + vma_pages(vma) - 1;\n\t\t/* Assume for now that PAGE_CACHE_SHIFT == PAGE_SHIFT */\n\t\tzba = details->first_index;\n\t\tif (zba < vba)\n\t\t\tzba = vba;\n\t\tzea = details->last_index;\n\t\tif (zea > vea)\n\t\t\tzea = vea;\n\n\t\tunmap_mapping_range_vma(vma,\n\t\t\t((zba - vba) << PAGE_SHIFT) + vma->vm_start,\n\t\t\t((zea - vba + 1) << PAGE_SHIFT) + vma->vm_start,\n\t\t\t\tdetails);\n\t}\n}\n", "target": 0, "idx": 57893}
{"func": "ikev1_n_print(netdissect_options *ndo, u_char tpay _U_,\n\t      const struct isakmp_gen *ext, u_int item_len,\n\t      const u_char *ep, uint32_t phase _U_, uint32_t doi0 _U_,\n\t      uint32_t proto0 _U_, int depth _U_)\n{\n\tconst struct ikev1_pl_n *p;\n\tstruct ikev1_pl_n n;\n\tconst u_char *cp;\n\tconst u_char *ep2;\n\tuint32_t doi;\n\tuint32_t proto;\n\tstatic const char *notify_error_str[] = {\n\t\tNULL,\t\t\t\t\"INVALID-PAYLOAD-TYPE\",\n\t\t\"DOI-NOT-SUPPORTED\",\t\t\"SITUATION-NOT-SUPPORTED\",\n\t\t\"INVALID-COOKIE\",\t\t\"INVALID-MAJOR-VERSION\",\n\t\t\"INVALID-MINOR-VERSION\",\t\"INVALID-EXCHANGE-TYPE\",\n\t\t\"INVALID-FLAGS\",\t\t\"INVALID-MESSAGE-ID\",\n\t\t\"INVALID-PROTOCOL-ID\",\t\t\"INVALID-SPI\",\n\t\t\"INVALID-TRANSFORM-ID\",\t\t\"ATTRIBUTES-NOT-SUPPORTED\",\n\t\t\"NO-PROPOSAL-CHOSEN\",\t\t\"BAD-PROPOSAL-SYNTAX\",\n\t\t\"PAYLOAD-MALFORMED\",\t\t\"INVALID-KEY-INFORMATION\",\n\t\t\"INVALID-ID-INFORMATION\",\t\"INVALID-CERT-ENCODING\",\n\t\t\"INVALID-CERTIFICATE\",\t\t\"CERT-TYPE-UNSUPPORTED\",\n\t\t\"INVALID-CERT-AUTHORITY\",\t\"INVALID-HASH-INFORMATION\",\n\t\t\"AUTHENTICATION-FAILED\",\t\"INVALID-SIGNATURE\",\n\t\t\"ADDRESS-NOTIFICATION\",\t\t\"NOTIFY-SA-LIFETIME\",\n\t\t\"CERTIFICATE-UNAVAILABLE\",\t\"UNSUPPORTED-EXCHANGE-TYPE\",\n\t\t\"UNEQUAL-PAYLOAD-LENGTHS\",\n\t};\n\tstatic const char *ipsec_notify_error_str[] = {\n\t\t\"RESERVED\",\n\t};\n\tstatic const char *notify_status_str[] = {\n\t\t\"CONNECTED\",\n\t};\n\tstatic const char *ipsec_notify_status_str[] = {\n\t\t\"RESPONDER-LIFETIME\",\t\t\"REPLAY-STATUS\",\n\t\t\"INITIAL-CONTACT\",\n\t};\n/* NOTE: these macro must be called with x in proper range */\n\n/* 0 - 8191 */\n#define NOTIFY_ERROR_STR(x) \\\n\tSTR_OR_ID((x), notify_error_str)\n\n/* 8192 - 16383 */\n#define IPSEC_NOTIFY_ERROR_STR(x) \\\n\tSTR_OR_ID((u_int)((x) - 8192), ipsec_notify_error_str)\n\n/* 16384 - 24575 */\n#define NOTIFY_STATUS_STR(x) \\\n\tSTR_OR_ID((u_int)((x) - 16384), notify_status_str)\n\n/* 24576 - 32767 */\n#define IPSEC_NOTIFY_STATUS_STR(x) \\\n\tSTR_OR_ID((u_int)((x) - 24576), ipsec_notify_status_str)\n\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_N)));\n\n\tp = (const struct ikev1_pl_n *)ext;\n\tND_TCHECK(*p);\n\tUNALIGNED_MEMCPY(&n, ext, sizeof(n));\n\tdoi = ntohl(n.doi);\n\tproto = n.prot_id;\n\tif (doi != 1) {\n\t\tND_PRINT((ndo,\" doi=%d\", doi));\n\t\tND_PRINT((ndo,\" proto=%d\", proto));\n\t\tif (ntohs(n.type) < 8192)\n\t\t\tND_PRINT((ndo,\" type=%s\", NOTIFY_ERROR_STR(ntohs(n.type))));\n\t\telse if (ntohs(n.type) < 16384)\n\t\t\tND_PRINT((ndo,\" type=%s\", numstr(ntohs(n.type))));\n\t\telse if (ntohs(n.type) < 24576)\n\t\t\tND_PRINT((ndo,\" type=%s\", NOTIFY_STATUS_STR(ntohs(n.type))));\n\t\telse\n\t\t\tND_PRINT((ndo,\" type=%s\", numstr(ntohs(n.type))));\n\t\tif (n.spi_size) {\n\t\t\tND_PRINT((ndo,\" spi=\"));\n\t\t\tif (!rawprint(ndo, (const uint8_t *)(p + 1), n.spi_size))\n\t\t\t\tgoto trunc;\n\t\t}\n\t\treturn (const u_char *)(p + 1) + n.spi_size;\n\t}\n\n\tND_PRINT((ndo,\" doi=ipsec\"));\n\tND_PRINT((ndo,\" proto=%s\", PROTOIDSTR(proto)));\n\tif (ntohs(n.type) < 8192)\n\t\tND_PRINT((ndo,\" type=%s\", NOTIFY_ERROR_STR(ntohs(n.type))));\n\telse if (ntohs(n.type) < 16384)\n\t\tND_PRINT((ndo,\" type=%s\", IPSEC_NOTIFY_ERROR_STR(ntohs(n.type))));\n\telse if (ntohs(n.type) < 24576)\n\t\tND_PRINT((ndo,\" type=%s\", NOTIFY_STATUS_STR(ntohs(n.type))));\n\telse if (ntohs(n.type) < 32768)\n\t\tND_PRINT((ndo,\" type=%s\", IPSEC_NOTIFY_STATUS_STR(ntohs(n.type))));\n\telse\n\t\tND_PRINT((ndo,\" type=%s\", numstr(ntohs(n.type))));\n\tif (n.spi_size) {\n\t\tND_PRINT((ndo,\" spi=\"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(p + 1), n.spi_size))\n\t\t\tgoto trunc;\n\t}\n\n\tcp = (const u_char *)(p + 1) + n.spi_size;\n\tep2 = (const u_char *)p + item_len;\n\n\tif (cp < ep) {\n\t\tswitch (ntohs(n.type)) {\n\t\tcase IPSECDOI_NTYPE_RESPONDER_LIFETIME:\n\t\t    {\n\t\t\tconst struct attrmap *map = oakley_t_map;\n \t\t\tsize_t nmap = sizeof(oakley_t_map)/sizeof(oakley_t_map[0]);\n \t\t\tND_PRINT((ndo,\" attrs=(\"));\n \t\t\twhile (cp < ep && cp < ep2) {\n\t\t\t\tcp = ikev1_attrmap_print(ndo, cp,\n\t\t\t\t\t(ep < ep2) ? ep : ep2, map, nmap);\n \t\t\t}\n \t\t\tND_PRINT((ndo,\")\"));\n \t\t\tbreak;\n\t\t    }\n\t\tcase IPSECDOI_NTYPE_REPLAY_STATUS:\n\t\t\tND_PRINT((ndo,\" status=(\"));\n\t\t\tND_PRINT((ndo,\"replay detection %sabled\",\n\t\t\t\t  EXTRACT_32BITS(cp) ? \"en\" : \"dis\"));\n\t\t\tND_PRINT((ndo,\")\"));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/*\n\t\t\t * XXX - fill in more types here; see, for example,\n\t\t\t * draft-ietf-ipsec-notifymsg-04.\n\t\t\t */\n\t\t\tif (ndo->ndo_vflag > 3) {\n\t\t\t\tND_PRINT((ndo,\" data=(\"));\n\t\t\t\tif (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))\n\t\t\t\t\tgoto trunc;\n\t\t\t\tND_PRINT((ndo,\")\"));\n\t\t\t} else {\n\t\t\t\tif (!ike_show_somedata(ndo, cp, ep))\n\t\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (const u_char *)ext + item_len;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_N)));\n\treturn NULL;\n}\n", "target": 1, "idx": 181013}
{"func": "int udp6_seq_show(struct seq_file *seq, void *v)\n{\n\tif (v == SEQ_START_TOKEN)\n\t\tseq_printf(seq,\n\t\t\t   \"  sl  \"\n\t\t\t   \"local_address                         \"\n\t\t\t   \"remote_address                        \"\n\t\t\t   \"st tx_queue rx_queue tr tm->when retrnsmt\"\n\t\t\t   \"   uid  timeout inode ref pointer drops\\n\");\n\telse\n\t\tudp6_sock_seq_show(seq, v, ((struct udp_iter_state *)seq->private)->bucket);\n\treturn 0;\n}\n", "target": 0, "idx": 22757}
{"func": "WORD32 ih264d_video_decode(iv_obj_t *dec_hdl, void *pv_api_ip, void *pv_api_op)\n{\n /* ! */\n\n dec_struct_t * ps_dec = (dec_struct_t *)(dec_hdl->pv_codec_handle);\n\n    WORD32 i4_err_status = 0;\n    UWORD8 *pu1_buf = NULL;\n    WORD32 buflen;\n    UWORD32 u4_max_ofst, u4_length_of_start_code = 0;\n\n    UWORD32 bytes_consumed = 0;\n    UWORD32 cur_slice_is_nonref = 0;\n    UWORD32 u4_next_is_aud;\n    UWORD32 u4_first_start_code_found = 0;\n    WORD32 ret = 0,api_ret_value = IV_SUCCESS;\n    WORD32 header_data_left = 0,frame_data_left = 0;\n    UWORD8 *pu1_bitstrm_buf;\n ivd_video_decode_ip_t *ps_dec_ip;\n ivd_video_decode_op_t *ps_dec_op;\n\n    ithread_set_name((void*)\"Parse_thread\");\n\n    ps_dec_ip = (ivd_video_decode_ip_t *)pv_api_ip;\n    ps_dec_op = (ivd_video_decode_op_t *)pv_api_op;\n\n {\n        UWORD32 u4_size;\n        u4_size = ps_dec_op->u4_size;\n        memset(ps_dec_op, 0, sizeof(ivd_video_decode_op_t));\n        ps_dec_op->u4_size = u4_size;\n }\n\n    ps_dec->pv_dec_out = ps_dec_op;\n if(ps_dec->init_done != 1)\n {\n return IV_FAIL;\n }\n\n /*Data memory barries instruction,so that bitstream write by the application is complete*/\n    DATA_SYNC();\n\n if(0 == ps_dec->u1_flushfrm)\n {\n if(ps_dec_ip->pv_stream_buffer == NULL)\n {\n            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n            ps_dec_op->u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL;\n return IV_FAIL;\n }\n if(ps_dec_ip->u4_num_Bytes <= 0)\n {\n            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n            ps_dec_op->u4_error_code |= IVD_DEC_NUMBYTES_INV;\n return IV_FAIL;\n\n }\n }\n    ps_dec->u1_pic_decode_done = 0;\n\n    ps_dec_op->u4_num_bytes_consumed = 0;\n\n    ps_dec->ps_out_buffer = NULL;\n\n if(ps_dec_ip->u4_size\n >= offsetof(ivd_video_decode_ip_t, s_out_buffer))\n        ps_dec->ps_out_buffer = &ps_dec_ip->s_out_buffer;\n\n    ps_dec->u4_fmt_conv_cur_row = 0;\n\n    ps_dec->u4_output_present = 0;\n    ps_dec->s_disp_op.u4_error_code = 1;\n    ps_dec->u4_fmt_conv_num_rows = FMT_CONV_NUM_ROWS;\n if(0 == ps_dec->u4_share_disp_buf\n && ps_dec->i4_decode_header == 0)\n {\n        UWORD32 i;\n if((ps_dec->ps_out_buffer->u4_num_bufs == 0) ||\n (ps_dec->ps_out_buffer->u4_num_bufs > IVD_VIDDEC_MAX_IO_BUFFERS))\n {\n            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n            ps_dec_op->u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS;\n return IV_FAIL;\n }\n\n for(i = 0; i < ps_dec->ps_out_buffer->u4_num_bufs; i++)\n {\n if(ps_dec->ps_out_buffer->pu1_bufs[i] == NULL)\n {\n                ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n                ps_dec_op->u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL;\n return IV_FAIL;\n }\n\n if(ps_dec->ps_out_buffer->u4_min_out_buf_size[i] == 0)\n {\n                ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n                ps_dec_op->u4_error_code |=\n                                IVD_DISP_FRM_ZERO_OP_BUF_SIZE;\n return IV_FAIL;\n }\n }\n }\n\n if(ps_dec->u4_total_frames_decoded >= NUM_FRAMES_LIMIT)\n {\n        ps_dec_op->u4_error_code = ERROR_FRAME_LIMIT_OVER;\n return IV_FAIL;\n }\n\n /* ! */\n    ps_dec->u4_ts = ps_dec_ip->u4_ts;\n\n    ps_dec_op->u4_error_code = 0;\n    ps_dec_op->e_pic_type = -1;\n    ps_dec_op->u4_output_present = 0;\n    ps_dec_op->u4_frame_decoded_flag = 0;\n\n    ps_dec->i4_frametype = -1;\n    ps_dec->i4_content_type = -1;\n\n    ps_dec->u4_slice_start_code_found = 0;\n\n /* In case the deocder is not in flush mode(in shared mode),\n     then decoder has to pick up a buffer to write current frame.\n     Check if a frame is available in such cases */\n\n if(ps_dec->u1_init_dec_flag == 1 && ps_dec->u4_share_disp_buf == 1\n && ps_dec->u1_flushfrm == 0)\n {\n        UWORD32 i;\n\n        WORD32 disp_avail = 0, free_id;\n\n /* Check if at least one buffer is available with the codec */\n /* If not then return to application with error */\n for(i = 0; i < ps_dec->u1_pic_bufs; i++)\n {\n if(0 == ps_dec->u4_disp_buf_mapping[i]\n || 1 == ps_dec->u4_disp_buf_to_be_freed[i])\n {\n                disp_avail = 1;\n break;\n }\n\n }\n\n if(0 == disp_avail)\n {\n /* If something is queued for display wait for that buffer to be returned */\n\n            ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;\n            ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);\n return (IV_FAIL);\n }\n\n while(1)\n {\n pic_buffer_t *ps_pic_buf;\n            ps_pic_buf = (pic_buffer_t *)ih264_buf_mgr_get_next_free(\n (buf_mgr_t *)ps_dec->pv_pic_buf_mgr, &free_id);\n\n if(ps_pic_buf == NULL)\n {\n                UWORD32 i, display_queued = 0;\n\n /* check if any buffer was given for display which is not returned yet */\n for(i = 0; i < (MAX_DISP_BUFS_NEW); i++)\n {\n if(0 != ps_dec->u4_disp_buf_mapping[i])\n {\n                        display_queued = 1;\n break;\n }\n }\n /* If some buffer is queued for display, then codec has to singal an error and wait\n                 for that buffer to be returned.\n                 If nothing is queued for display then codec has ownership of all display buffers\n                 and it can reuse any of the existing buffers and continue decoding */\n\n if(1 == display_queued)\n {\n /* If something is queued for display wait for that buffer to be returned */\n                    ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;\n                    ps_dec_op->u4_error_code |= (1\n << IVD_UNSUPPORTEDPARAM);\n return (IV_FAIL);\n }\n }\n else\n {\n /* If the buffer is with display, then mark it as in use and then look for a buffer again */\n if(1 == ps_dec->u4_disp_buf_mapping[free_id])\n {\n                    ih264_buf_mgr_set_status(\n (buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n                                    free_id,\n                                    BUF_MGR_IO);\n }\n else\n {\n /**\n                     *  Found a free buffer for present call. Release it now.\n                     *  Will be again obtained later.\n                     */\n                    ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n                                          free_id,\n                                          BUF_MGR_IO);\n break;\n }\n }\n }\n\n }\n\n if(ps_dec->u1_flushfrm)\n {\n if(ps_dec->u1_init_dec_flag == 0)\n {\n /*Come out of flush mode and return*/\n            ps_dec->u1_flushfrm = 0;\n return (IV_FAIL);\n }\n\n\n\n        ih264d_get_next_display_field(ps_dec, ps_dec->ps_out_buffer,\n &(ps_dec->s_disp_op));\n if(0 == ps_dec->s_disp_op.u4_error_code)\n {\n /* check output buffer size given by the application */\n if(check_app_out_buf_size(ps_dec) != IV_SUCCESS)\n {\n                ps_dec_op->u4_error_code= IVD_DISP_FRM_ZERO_OP_BUF_SIZE;\n return (IV_FAIL);\n }\n\n            ps_dec->u4_fmt_conv_cur_row = 0;\n            ps_dec->u4_fmt_conv_num_rows = ps_dec->s_disp_frame_info.u4_y_ht;\n            ih264d_format_convert(ps_dec, &(ps_dec->s_disp_op),\n                                  ps_dec->u4_fmt_conv_cur_row,\n                                  ps_dec->u4_fmt_conv_num_rows);\n            ps_dec->u4_fmt_conv_cur_row += ps_dec->u4_fmt_conv_num_rows;\n            ps_dec->u4_output_present = 1;\n\n }\n        ih264d_release_display_field(ps_dec, &(ps_dec->s_disp_op));\n\n        ps_dec_op->u4_pic_wd = (UWORD32)ps_dec->u2_disp_width;\n        ps_dec_op->u4_pic_ht = (UWORD32)ps_dec->u2_disp_height;\n\n        ps_dec_op->u4_new_seq = 0;\n\n        ps_dec_op->u4_output_present = ps_dec->u4_output_present;\n        ps_dec_op->u4_progressive_frame_flag =\n                        ps_dec->s_disp_op.u4_progressive_frame_flag;\n        ps_dec_op->e_output_format =\n                        ps_dec->s_disp_op.e_output_format;\n        ps_dec_op->s_disp_frm_buf = ps_dec->s_disp_op.s_disp_frm_buf;\n        ps_dec_op->e4_fld_type = ps_dec->s_disp_op.e4_fld_type;\n        ps_dec_op->u4_ts = ps_dec->s_disp_op.u4_ts;\n        ps_dec_op->u4_disp_buf_id = ps_dec->s_disp_op.u4_disp_buf_id;\n\n /*In the case of flush ,since no frame is decoded set pic type as invalid*/\n        ps_dec_op->u4_is_ref_flag = -1;\n        ps_dec_op->e_pic_type = IV_NA_FRAME;\n        ps_dec_op->u4_frame_decoded_flag = 0;\n\n if(0 == ps_dec->s_disp_op.u4_error_code)\n {\n return (IV_SUCCESS);\n }\n else\n return (IV_FAIL);\n\n }\n if(ps_dec->u1_res_changed == 1)\n {\n /*if resolution has changed and all buffers have been flushed, reset decoder*/\n        ih264d_init_decoder(ps_dec);\n }\n\n    ps_dec->u4_prev_nal_skipped = 0;\n\n    ps_dec->u2_cur_mb_addr = 0;\n    ps_dec->u2_total_mbs_coded = 0;\n    ps_dec->u2_cur_slice_num = 0;\n    ps_dec->cur_dec_mb_num = 0;\n    ps_dec->cur_recon_mb_num = 0;\n    ps_dec->u4_first_slice_in_pic = 1;\n    ps_dec->u1_slice_header_done = 0;\n    ps_dec->u1_dangling_field = 0;\n\n    ps_dec->u4_dec_thread_created = 0;\n    ps_dec->u4_bs_deblk_thread_created = 0;\n    ps_dec->u4_cur_bs_mb_num = 0;\n    ps_dec->u4_start_recon_deblk  = 0;\n    ps_dec->u4_sps_cnt_in_process = 0;\n\n    DEBUG_THREADS_PRINTF(\" Starting process call\\n\");\n\n\n    ps_dec->u4_pic_buf_got = 0;\n\n do\n {\n        WORD32 buf_size;\n\n        pu1_buf = (UWORD8*)ps_dec_ip->pv_stream_buffer\n + ps_dec_op->u4_num_bytes_consumed;\n\n        u4_max_ofst = ps_dec_ip->u4_num_Bytes\n - ps_dec_op->u4_num_bytes_consumed;\n\n /* If dynamic bitstream buffer is not allocated and\n         * header decode is done, then allocate dynamic bitstream buffer\n         */\n if((NULL == ps_dec->pu1_bits_buf_dynamic) &&\n (ps_dec->i4_header_decoded & 1))\n {\n            WORD32 size;\n\n\n             void *pv_buf;\n             void *pv_mem_ctxt = ps_dec->pv_mem_ctxt;\n             size = MAX(256000, ps_dec->u2_pic_wd * ps_dec->u2_pic_ht * 3 / 2);\n            pv_buf = ps_dec->pf_aligned_alloc(pv_mem_ctxt, 128, size);\n             RETURN_IF((NULL == pv_buf), IV_FAIL);\n             ps_dec->pu1_bits_buf_dynamic = pv_buf;\n             ps_dec->u4_dynamic_bits_buf_size = size;\n }\n\n if(ps_dec->pu1_bits_buf_dynamic)\n {\n            pu1_bitstrm_buf = ps_dec->pu1_bits_buf_dynamic;\n            buf_size = ps_dec->u4_dynamic_bits_buf_size;\n }\n else\n {\n            pu1_bitstrm_buf = ps_dec->pu1_bits_buf_static;\n            buf_size = ps_dec->u4_static_bits_buf_size;\n }\n\n        u4_next_is_aud = 0;\n\n        buflen = ih264d_find_start_code(pu1_buf, 0, u4_max_ofst,\n &u4_length_of_start_code,\n &u4_next_is_aud);\n\n if(buflen == -1)\n            buflen = 0;\n /* Ignore bytes beyond the allocated size of intermediate buffer */\n /* Since 8 bytes are read ahead, ensure 8 bytes are free at the\n        end of the buffer, which will be memset to 0 after emulation prevention */\n        buflen = MIN(buflen, buf_size - 8);\n\n        bytes_consumed = buflen + u4_length_of_start_code;\n        ps_dec_op->u4_num_bytes_consumed += bytes_consumed;\n\n {\n            UWORD8 u1_firstbyte, u1_nal_ref_idc;\n\n if(ps_dec->i4_app_skip_mode == IVD_SKIP_B)\n {\n                u1_firstbyte = *(pu1_buf + u4_length_of_start_code);\n                u1_nal_ref_idc = (UWORD8)(NAL_REF_IDC(u1_firstbyte));\n if(u1_nal_ref_idc == 0)\n {\n /*skip non reference frames*/\n                    cur_slice_is_nonref = 1;\n continue;\n }\n else\n {\n if(1 == cur_slice_is_nonref)\n {\n /*We have encountered a referenced frame,return to app*/\n                        ps_dec_op->u4_num_bytes_consumed -=\n                                        bytes_consumed;\n                        ps_dec_op->e_pic_type = IV_B_FRAME;\n                        ps_dec_op->u4_error_code =\n                                        IVD_DEC_FRM_SKIPPED;\n                        ps_dec_op->u4_error_code |= (1\n << IVD_UNSUPPORTEDPARAM);\n                        ps_dec_op->u4_frame_decoded_flag = 0;\n                        ps_dec_op->u4_size =\n sizeof(ivd_video_decode_op_t);\n /*signal the decode thread*/\n                        ih264d_signal_decode_thread(ps_dec);\n /* close deblock thread if it is not closed yet*/\n if(ps_dec->u4_num_cores == 3)\n {\n                            ih264d_signal_bs_deblk_thread(ps_dec);\n }\n\n return (IV_FAIL);\n }\n }\n\n }\n\n }\n\n\n if(buflen)\n {\n            memcpy(pu1_bitstrm_buf, pu1_buf + u4_length_of_start_code,\n                   buflen);\n /* Decoder may read extra 8 bytes near end of the frame */\n if((buflen + 8) < buf_size)\n {\n                memset(pu1_bitstrm_buf + buflen, 0, 8);\n }\n            u4_first_start_code_found = 1;\n\n }\n else\n {\n /*start code not found*/\n\n if(u4_first_start_code_found == 0)\n {\n /*no start codes found in current process call*/\n\n                ps_dec->i4_error_code = ERROR_START_CODE_NOT_FOUND;\n                ps_dec_op->u4_error_code |= 1 << IVD_INSUFFICIENTDATA;\n\n if(ps_dec->u4_pic_buf_got == 0)\n {\n\n                    ih264d_fill_output_struct_from_context(ps_dec,\n                                                           ps_dec_op);\n\n                    ps_dec_op->u4_error_code = ps_dec->i4_error_code;\n                    ps_dec_op->u4_frame_decoded_flag = 0;\n\n return (IV_FAIL);\n }\n else\n {\n                    ps_dec->u1_pic_decode_done = 1;\n continue;\n }\n }\n else\n {\n /* a start code has already been found earlier in the same process call*/\n                frame_data_left = 0;\n                header_data_left = 0;\n continue;\n }\n\n }\n\n        ps_dec->u4_return_to_app = 0;\n        ret = ih264d_parse_nal_unit(dec_hdl, ps_dec_op,\n                              pu1_bitstrm_buf, buflen);\n if(ret != OK)\n {\n            UWORD32 error =  ih264d_map_error(ret);\n            ps_dec_op->u4_error_code = error | ret;\n            api_ret_value = IV_FAIL;\n\n if((ret == IVD_RES_CHANGED)\n || (ret == IVD_MEM_ALLOC_FAILED)\n || (ret == ERROR_UNAVAIL_PICBUF_T)\n || (ret == ERROR_UNAVAIL_MVBUF_T)\n || (ret == ERROR_INV_SPS_PPS_T)\n || (ret == IVD_DISP_FRM_ZERO_OP_BUF_SIZE))\n {\n                ps_dec->u4_slice_start_code_found = 0;\n break;\n }\n\n if((ret == ERROR_INCOMPLETE_FRAME) || (ret == ERROR_DANGLING_FIELD_IN_PIC))\n {\n                ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;\n                api_ret_value = IV_FAIL;\n break;\n }\n\n if(ret == ERROR_IN_LAST_SLICE_OF_PIC)\n {\n                api_ret_value = IV_FAIL;\n break;\n }\n\n }\n\n if(ps_dec->u4_return_to_app)\n {\n /*We have encountered a referenced frame,return to app*/\n            ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;\n            ps_dec_op->u4_error_code = IVD_DEC_FRM_SKIPPED;\n            ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);\n            ps_dec_op->u4_frame_decoded_flag = 0;\n            ps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);\n /*signal the decode thread*/\n            ih264d_signal_decode_thread(ps_dec);\n /* close deblock thread if it is not closed yet*/\n if(ps_dec->u4_num_cores == 3)\n {\n                ih264d_signal_bs_deblk_thread(ps_dec);\n }\n return (IV_FAIL);\n\n }\n\n\n\n        header_data_left = ((ps_dec->i4_decode_header == 1)\n && (ps_dec->i4_header_decoded != 3)\n && (ps_dec_op->u4_num_bytes_consumed\n < ps_dec_ip->u4_num_Bytes));\n        frame_data_left = (((ps_dec->i4_decode_header == 0)\n && ((ps_dec->u1_pic_decode_done == 0)\n || (u4_next_is_aud == 1)))\n && (ps_dec_op->u4_num_bytes_consumed\n < ps_dec_ip->u4_num_Bytes));\n }\n while(( header_data_left == 1)||(frame_data_left == 1));\n\n if((ps_dec->u4_pic_buf_got == 1)\n && (ret != IVD_MEM_ALLOC_FAILED)\n && ps_dec->u2_total_mbs_coded < ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n {\n        WORD32 num_mb_skipped;\n        WORD32 prev_slice_err;\n pocstruct_t temp_poc;\n        WORD32 ret1;\n        WORD32 ht_in_mbs;\n        ht_in_mbs = ps_dec->u2_pic_ht >> (4 + ps_dec->ps_cur_slice->u1_field_pic_flag);\n        num_mb_skipped = (ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n - ps_dec->u2_total_mbs_coded;\n\n if(ps_dec->u4_first_slice_in_pic && (ps_dec->u4_pic_buf_got == 0))\n            prev_slice_err = 1;\n else\n            prev_slice_err = 2;\n\n if(ps_dec->u4_first_slice_in_pic && (ps_dec->u2_total_mbs_coded == 0))\n            prev_slice_err = 1;\n\n        ret1 = ih264d_mark_err_slice_skip(ps_dec, num_mb_skipped, ps_dec->u1_nal_unit_type == IDR_SLICE_NAL, ps_dec->ps_cur_slice->u2_frame_num,\n &temp_poc, prev_slice_err);\n\n if((ret1 == ERROR_UNAVAIL_PICBUF_T) || (ret1 == ERROR_UNAVAIL_MVBUF_T) ||\n (ret1 == ERROR_INV_SPS_PPS_T))\n {\n            ret = ret1;\n }\n }\n\n if((ret == IVD_RES_CHANGED)\n || (ret == IVD_MEM_ALLOC_FAILED)\n || (ret == ERROR_UNAVAIL_PICBUF_T)\n || (ret == ERROR_UNAVAIL_MVBUF_T)\n || (ret == ERROR_INV_SPS_PPS_T))\n {\n\n /* signal the decode thread */\n        ih264d_signal_decode_thread(ps_dec);\n /* close deblock thread if it is not closed yet */\n if(ps_dec->u4_num_cores == 3)\n {\n            ih264d_signal_bs_deblk_thread(ps_dec);\n }\n /* dont consume bitstream for change in resolution case */\n if(ret == IVD_RES_CHANGED)\n {\n            ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;\n }\n return IV_FAIL;\n }\n\n\n if(ps_dec->u1_separate_parse)\n {\n /* If Format conversion is not complete,\n         complete it here */\n if(ps_dec->u4_num_cores == 2)\n {\n\n /*do deblocking of all mbs*/\n if((ps_dec->u4_nmb_deblk == 0) &&(ps_dec->u4_start_recon_deblk == 1) && (ps_dec->ps_cur_sps->u1_mb_aff_flag == 0))\n {\n                UWORD32 u4_num_mbs,u4_max_addr;\n tfr_ctxt_t s_tfr_ctxt;\n tfr_ctxt_t *ps_tfr_cxt = &s_tfr_ctxt;\n pad_mgr_t *ps_pad_mgr = &ps_dec->s_pad_mgr;\n\n /*BS is done for all mbs while parsing*/\n                u4_max_addr = (ps_dec->u2_frm_wd_in_mbs * ps_dec->u2_frm_ht_in_mbs) - 1;\n                ps_dec->u4_cur_bs_mb_num = u4_max_addr + 1;\n\n\n                ih264d_init_deblk_tfr_ctxt(ps_dec, ps_pad_mgr, ps_tfr_cxt,\n                                           ps_dec->u2_frm_wd_in_mbs, 0);\n\n\n                u4_num_mbs = u4_max_addr\n - ps_dec->u4_cur_deblk_mb_num + 1;\n\n                DEBUG_PERF_PRINTF(\"mbs left for deblocking= %d \\n\",u4_num_mbs);\n\n if(u4_num_mbs != 0)\n                    ih264d_check_mb_map_deblk(ps_dec, u4_num_mbs,\n                                                   ps_tfr_cxt,1);\n\n                ps_dec->u4_start_recon_deblk  = 0;\n\n }\n\n }\n\n /*signal the decode thread*/\n        ih264d_signal_decode_thread(ps_dec);\n /* close deblock thread if it is not closed yet*/\n if(ps_dec->u4_num_cores == 3)\n {\n            ih264d_signal_bs_deblk_thread(ps_dec);\n }\n }\n\n\n    DATA_SYNC();\n\n\n if((ps_dec_op->u4_error_code & 0xff)\n != ERROR_DYNAMIC_RESOLUTION_NOT_SUPPORTED)\n {\n        ps_dec_op->u4_pic_wd = (UWORD32)ps_dec->u2_disp_width;\n        ps_dec_op->u4_pic_ht = (UWORD32)ps_dec->u2_disp_height;\n }\n\n if(ps_dec->i4_header_decoded != 3)\n {\n        ps_dec_op->u4_error_code |= (1 << IVD_INSUFFICIENTDATA);\n\n }\n\n if(ps_dec->i4_decode_header == 1 && ps_dec->i4_header_decoded != 3)\n {\n        ps_dec_op->u4_error_code |= (1 << IVD_INSUFFICIENTDATA);\n\n }\n if(ps_dec->u4_prev_nal_skipped)\n {\n /*We have encountered a referenced frame,return to app*/\n        ps_dec_op->u4_error_code = IVD_DEC_FRM_SKIPPED;\n        ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);\n        ps_dec_op->u4_frame_decoded_flag = 0;\n        ps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);\n /* close deblock thread if it is not closed yet*/\n if(ps_dec->u4_num_cores == 3)\n {\n            ih264d_signal_bs_deblk_thread(ps_dec);\n }\n return (IV_FAIL);\n\n }\n\n if((ps_dec->u4_pic_buf_got == 1)\n && (ERROR_DANGLING_FIELD_IN_PIC != i4_err_status))\n {\n /*\n         * For field pictures, set the bottom and top picture decoded u4_flag correctly.\n         */\n\n if(ps_dec->ps_cur_slice->u1_field_pic_flag)\n {\n if(1 == ps_dec->ps_cur_slice->u1_bottom_field_flag)\n {\n                ps_dec->u1_top_bottom_decoded |= BOT_FIELD_ONLY;\n }\n else\n {\n                ps_dec->u1_top_bottom_decoded |= TOP_FIELD_ONLY;\n }\n }\n else\n {\n                ps_dec->u1_top_bottom_decoded = TOP_FIELD_ONLY | BOT_FIELD_ONLY;\n }\n\n /* if new frame in not found (if we are still getting slices from previous frame)\n         * ih264d_deblock_display is not called. Such frames will not be added to reference /display\n         */\n if ((ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC) == 0)\n {\n /* Calling Function to deblock Picture and Display */\n            ret = ih264d_deblock_display(ps_dec);\n }\n\n\n /*set to complete ,as we dont support partial frame decode*/\n if(ps_dec->i4_header_decoded == 3)\n {\n            ps_dec->u2_total_mbs_coded = ps_dec->ps_cur_sps->u2_max_mb_addr + 1;\n }\n\n /*Update the i4_frametype at the end of picture*/\n if(ps_dec->ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL)\n {\n            ps_dec->i4_frametype = IV_IDR_FRAME;\n }\n else if(ps_dec->i4_pic_type == B_SLICE)\n {\n            ps_dec->i4_frametype = IV_B_FRAME;\n }\n else if(ps_dec->i4_pic_type == P_SLICE)\n {\n            ps_dec->i4_frametype = IV_P_FRAME;\n }\n else if(ps_dec->i4_pic_type == I_SLICE)\n {\n            ps_dec->i4_frametype = IV_I_FRAME;\n }\n else\n {\n            H264_DEC_DEBUG_PRINT(\"Shouldn't come here\\n\");\n }\n\n        ps_dec->i4_content_type = ps_dec->ps_cur_slice->u1_field_pic_flag;\n\n        ps_dec->u4_total_frames_decoded = ps_dec->u4_total_frames_decoded + 2;\n        ps_dec->u4_total_frames_decoded = ps_dec->u4_total_frames_decoded\n - ps_dec->ps_cur_slice->u1_field_pic_flag;\n\n }\n\n /* close deblock thread if it is not closed yet*/\n if(ps_dec->u4_num_cores == 3)\n {\n        ih264d_signal_bs_deblk_thread(ps_dec);\n }\n\n\n {\n /* In case the decoder is configured to run in low delay mode,\n         * then get display buffer and then format convert.\n         * Note in this mode, format conversion does not run paralelly in a thread and adds to the codec cycles\n         */\n\n if((IVD_DECODE_FRAME_OUT == ps_dec->e_frm_out_mode)\n && ps_dec->u1_init_dec_flag)\n {\n\n            ih264d_get_next_display_field(ps_dec, ps_dec->ps_out_buffer,\n &(ps_dec->s_disp_op));\n if(0 == ps_dec->s_disp_op.u4_error_code)\n {\n                ps_dec->u4_fmt_conv_cur_row = 0;\n                ps_dec->u4_output_present = 1;\n }\n }\n\n        ih264d_fill_output_struct_from_context(ps_dec, ps_dec_op);\n\n /* If Format conversion is not complete,\n         complete it here */\n if(ps_dec->u4_output_present &&\n (ps_dec->u4_fmt_conv_cur_row < ps_dec->s_disp_frame_info.u4_y_ht))\n {\n            ps_dec->u4_fmt_conv_num_rows = ps_dec->s_disp_frame_info.u4_y_ht\n - ps_dec->u4_fmt_conv_cur_row;\n            ih264d_format_convert(ps_dec, &(ps_dec->s_disp_op),\n                                  ps_dec->u4_fmt_conv_cur_row,\n                                  ps_dec->u4_fmt_conv_num_rows);\n            ps_dec->u4_fmt_conv_cur_row += ps_dec->u4_fmt_conv_num_rows;\n }\n\n        ih264d_release_display_field(ps_dec, &(ps_dec->s_disp_op));\n }\n\n if(ps_dec->i4_decode_header == 1 && (ps_dec->i4_header_decoded & 1) == 1)\n {\n        ps_dec_op->u4_progressive_frame_flag = 1;\n if((NULL != ps_dec->ps_cur_sps) && (1 == (ps_dec->ps_cur_sps->u1_is_valid)))\n {\n if((0 == ps_dec->ps_sps->u1_frame_mbs_only_flag)\n && (0 == ps_dec->ps_sps->u1_mb_aff_flag))\n                ps_dec_op->u4_progressive_frame_flag = 0;\n\n }\n }\n\n if((TOP_FIELD_ONLY | BOT_FIELD_ONLY) == ps_dec->u1_top_bottom_decoded)\n {\n        ps_dec->u1_top_bottom_decoded = 0;\n }\n /*--------------------------------------------------------------------*/\n /* Do End of Pic processing.                                          */\n /* Should be called only if frame was decoded in previous process call*/\n /*--------------------------------------------------------------------*/\n if(ps_dec->u4_pic_buf_got == 1)\n {\n if(1 == ps_dec->u1_last_pic_not_decoded)\n {\n            ret = ih264d_end_of_pic_dispbuf_mgr(ps_dec);\n\n if(ret != OK)\n return ret;\n\n            ret = ih264d_end_of_pic(ps_dec);\n if(ret != OK)\n return ret;\n }\n else\n {\n            ret = ih264d_end_of_pic(ps_dec);\n if(ret != OK)\n return ret;\n }\n\n }\n\n\n /*Data memory barrier instruction,so that yuv write by the library is complete*/\n    DATA_SYNC();\n\n    H264_DEC_DEBUG_PRINT(\"The num bytes consumed: %d\\n\",\n                         ps_dec_op->u4_num_bytes_consumed);\n return api_ret_value;\n}\n", "target": 1, "idx": 188128}
{"func": "flush_signal_handlers(struct task_struct *t, int force_default)\n{\n\tint i;\n\tstruct k_sigaction *ka = &t->sighand->action[0];\n\tfor (i = _NSIG ; i != 0 ; i--) {\n \t\tif (force_default || ka->sa.sa_handler != SIG_IGN)\n \t\t\tka->sa.sa_handler = SIG_DFL;\n \t\tka->sa.sa_flags = 0;\n \t\tsigemptyset(&ka->sa.sa_mask);\n \t\tka++;\n \t}\n}\n", "target": 1, "idx": 179306}
{"func": "PasswordGenerationUIData GetTestGenerationUIData2() {\n  PasswordForm form;\n  form.form_data = autofill::FormData();\n  form.form_data.action = GURL(\"http://www.example2.com/accounts/Login\");\n  form.form_data.origin = GURL(\"http://www.example2.com/accounts/LoginAuth\");\n  PasswordGenerationUIData data;\n  data.password_form = form;\n  data.generation_element = ASCIIToUTF16(\"testelement2\");\n  data.max_length = 11;\n  return data;\n}\n", "target": 1, "idx": 186036}
{"func": " static int hns_xgmac_get_sset_count(int stringset)\n {\n\tif (stringset == ETH_SS_STATS)\n \t\treturn ARRAY_SIZE(g_xgmac_stats_string);\n \n \treturn 0;\n}\n", "target": 1, "idx": 182573}
{"func": "void BrowserViewRenderer::DidDestroyCompositor(\n     content::SynchronousCompositor* compositor) {\n   TRACE_EVENT0(\"android_webview\", \"BrowserViewRenderer::DidDestroyCompositor\");\n   DCHECK(compositor_);\n   compositor_ = NULL;\n }\n", "target": 1, "idx": 185581}
{"func": "GF_Err tfxd_dump(GF_Box *a, FILE * trace)\n{\n\tGF_MSSTimeExtBox *ptr = (GF_MSSTimeExtBox*)a;\n\tif (!a) return GF_BAD_PARAM;\n\tgf_isom_box_dump_start(a, \"MSSTimeExtensionBox\", trace);\n\tfprintf(trace, \"AbsoluteTime=\\\"\"LLU\"\\\" FragmentDuration=\\\"\"LLU\"\\\">\\n\", ptr->absolute_time_in_track_timescale, ptr->fragment_duration_in_track_timescale);\n\tfprintf(trace, \"<FullBoxInfo Version=\\\"%d\\\" Flags=\\\"%d\\\"/>\\n\", ptr->version, ptr->flags);\n\tgf_isom_box_dump_done(\"MSSTimeExtensionBox\", a, trace);\n\treturn GF_OK;\n}\n", "target": 0, "idx": 80868}
{"func": "void TypingCommand::insertText(Document& document,\n                               const String& text,\n                               Options options,\n                               TextCompositionType composition,\n                               const bool isIncrementalInsertion) {\n  LocalFrame* frame = document.frame();\n  DCHECK(frame);\n\n  if (!text.isEmpty())\n     document.frame()->spellChecker().updateMarkersForWordsAffectedByEditing(\n         isSpaceOrNewline(text[0]));\n \n  insertText(document, text,\n             frame->selection().computeVisibleSelectionInDOMTreeDeprecated(),\n             options, composition, isIncrementalInsertion);\n }\n", "target": 1, "idx": 185940}
{"func": "void jpc_quantize(jas_matrix_t *data, jpc_fix_t stepsize)\n{\n\tint i;\n\tint j;\n\tjpc_fix_t t;\n\n\tif (stepsize == jpc_inttofix(1)) {\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < jas_matrix_numrows(data); ++i) {\n\t\tfor (j = 0; j < jas_matrix_numcols(data); ++j) {\n\t\t\tt = jas_matrix_get(data, i, j);\n\n{\n\tif (t < 0) {\n\t\tt = jpc_fix_neg(jpc_fix_div(jpc_fix_neg(t), stepsize));\n\t} else {\n\t\tt = jpc_fix_div(t, stepsize);\n\t}\n}\n\n\t\t\tjas_matrix_set(data, i, j, t);\n\t\t}\n\t}\n}\n", "target": 0, "idx": 72924}
{"func": "void BinaryUploadService::IsAuthorized(AuthorizationCallback callback) {\n  if (!timer_.IsRunning()) {\n    timer_.Start(FROM_HERE, base::TimeDelta::FromHours(24), this,\n                 &BinaryUploadService::ResetAuthorizationData);\n  }\n\n   if (!can_upload_data_.has_value()) {\n     if (!pending_validate_data_upload_request_) {\n      std::string dm_token = GetDMToken();\n      if (dm_token.empty()) {\n         std::move(callback).Run(false);\n         return;\n       }\n\n      pending_validate_data_upload_request_ = true;\n       auto request = std::make_unique<ValidateDataUploadRequest>(base::BindOnce(\n           &BinaryUploadService::ValidateDataUploadRequestCallback,\n           weakptr_factory_.GetWeakPtr()));\n      request->set_dm_token(dm_token);\n       UploadForDeepScanning(std::move(request));\n     }\n     authorization_callbacks_.push_back(std::move(callback));\n    return;\n  }\n  std::move(callback).Run(can_upload_data_.value());\n}\n", "target": 1, "idx": 186323}
{"func": "bool GLES2DecoderImpl::DoIsProgram(GLuint client_id) {\n  const ProgramManager::ProgramInfo* program = GetProgramInfo(client_id);\n  return program != NULL && !program->IsDeleted();\n}\n", "target": 0, "idx": 110491}
{"func": " int __glXDispSwap_CreateContext(__GLXclientState *cl, GLbyte *pc)\n {\n     xGLXCreateContextReq *req = (xGLXCreateContextReq *) pc;\n     __GLX_DECLARE_SWAP_VARIABLES;\n \n     __GLX_SWAP_SHORT(&req->length);\n     __GLX_SWAP_INT(&req->context);\n     __GLX_SWAP_INT(&req->visual);\n    return __glXDisp_CreateContext(cl, pc);\n}\n", "target": 1, "idx": 178441}
{"func": "void PreconnectManager::StartPreconnectUrl(\n    const GURL& url,\n    bool allow_credentials,\n    net::NetworkIsolationKey network_isolation_key) {\n  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n  if (!url.SchemeIsHTTPOrHTTPS())\n    return;\n  PreresolveJobId job_id = preresolve_jobs_.Add(std::make_unique<PreresolveJob>(\n      url.GetOrigin(), 1, allow_credentials, std::move(network_isolation_key),\n      nullptr));\n  queued_jobs_.push_front(job_id);\n\n  TryToLaunchPreresolveJobs();\n}\n", "target": 0, "idx": 149606}
{"func": " void PrintPreviewUI::ClearAllPreviewData() {\n  print_preview_data_service()->RemoveEntry(preview_ui_addr_str_);\n }\n", "target": 1, "idx": 184403}
{"func": "PS_SERIALIZER_DECODE_FUNC(php_serialize) /* {{{ */\n{\n\tconst char *endptr = val + vallen;\n\tzval *session_vars;\n\tphp_unserialize_data_t var_hash;\n\n\tPHP_VAR_UNSERIALIZE_INIT(var_hash);\n\tALLOC_INIT_ZVAL(session_vars);\n        if (php_var_unserialize(&session_vars, &val, endptr, &var_hash TSRMLS_CC)) {\n                var_push_dtor(&var_hash, &session_vars);\n        }\n        PHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n        if (PS(http_session_vars)) {\n                zval_ptr_dtor(&PS(http_session_vars));\n\t}\n\tif (Z_TYPE_P(session_vars) == IS_NULL) {\n\t\tarray_init(session_vars);\n\t}\n\tPS(http_session_vars) = session_vars;\n\tZEND_SET_GLOBAL_VAR_WITH_LENGTH(\"_SESSION\", sizeof(\"_SESSION\"), PS(http_session_vars), Z_REFCOUNT_P(PS(http_session_vars)) + 1, 1);\n\treturn SUCCESS;\n}\n/* }}} */\n", "target": 1, "idx": 178152}
{"func": "l2tp_proto_ver_print(netdissect_options *ndo, const uint16_t *dat)\n {\n \tND_PRINT((ndo, \"%u.%u\", (EXTRACT_16BITS(dat) >> 8),\n \t    (EXTRACT_16BITS(dat) & 0xff)));\n }\n", "target": 1, "idx": 181070}
{"func": "int drm_mode_dirtyfb_ioctl(struct drm_device *dev,\n\t\t\t   void *data, struct drm_file *file_priv)\n{\n\tstruct drm_clip_rect __user *clips_ptr;\n\tstruct drm_clip_rect *clips = NULL;\n\tstruct drm_mode_fb_dirty_cmd *r = data;\n\tstruct drm_mode_object *obj;\n\tstruct drm_framebuffer *fb;\n\tunsigned flags;\n\tint num_clips;\n\tint ret = 0;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dev->mode_config.mutex);\n\tobj = drm_mode_object_find(dev, r->fb_id, DRM_MODE_OBJECT_FB);\n\tif (!obj) {\n\t\tDRM_ERROR(\"invalid framebuffer id\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_err1;\n\t}\n\tfb = obj_to_fb(obj);\n\n\tnum_clips = r->num_clips;\n\tclips_ptr = (struct drm_clip_rect *)(unsigned long)r->clips_ptr;\n\n\tif (!num_clips != !clips_ptr) {\n\t\tret = -EINVAL;\n\t\tgoto out_err1;\n\t}\n\n\tflags = DRM_MODE_FB_DIRTY_FLAGS & r->flags;\n\n\t/* If userspace annotates copy, clips must come in pairs */\n\tif (flags & DRM_MODE_FB_DIRTY_ANNOTATE_COPY && (num_clips % 2)) {\n\t\tret = -EINVAL;\n\t\tgoto out_err1;\n \t}\n \n \tif (num_clips && clips_ptr) {\n \t\tclips = kzalloc(num_clips * sizeof(*clips), GFP_KERNEL);\n \t\tif (!clips) {\n \t\t\tret = -ENOMEM;\n\t\t\tgoto out_err1;\n\t\t}\n\n\t\tret = copy_from_user(clips, clips_ptr,\n\t\t\t\t     num_clips * sizeof(*clips));\n\t\tif (ret) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out_err2;\n\t\t}\n\t}\n\n\tif (fb->funcs->dirty) {\n\t\tret = fb->funcs->dirty(fb, file_priv, flags, r->color,\n\t\t\t\t       clips, num_clips);\n\t} else {\n\t\tret = -ENOSYS;\n\t\tgoto out_err2;\n\t}\n\nout_err2:\n\tkfree(clips);\nout_err1:\n\tmutex_unlock(&dev->mode_config.mutex);\n\treturn ret;\n}\n", "target": 1, "idx": 178827}
{"func": "static OPJ_BOOL opj_pi_next_rlcp(opj_pi_iterator_t * pi) {\n\topj_pi_comp_t *comp = NULL;\n\topj_pi_resolution_t *res = NULL;\n\tOPJ_UINT32 index = 0;\n\n\tif (!pi->first) {\n\t\tcomp = &pi->comps[pi->compno];\n\t\tres = &comp->resolutions[pi->resno];\n\t\tgoto LABEL_SKIP;\n\t} else {\n\t\tpi->first = 0;\n\t}\n\n\tfor (pi->resno = pi->poc.resno0; pi->resno < pi->poc.resno1; pi->resno++) {\n\t\tfor (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n\t\t\tfor (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n\t\t\t\tcomp = &pi->comps[pi->compno];\n\t\t\t\tif (pi->resno >= comp->numresolutions) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tres = &comp->resolutions[pi->resno];\n\t\t\t\tif(!pi->tp_on){\n\t\t\t\t\tpi->poc.precno1 = res->pw * res->ph;\n\t\t\t\t}\n\t\t\t\tfor (pi->precno = pi->poc.precno0; pi->precno < pi->poc.precno1; pi->precno++) {\n\t\t\t\t\tindex = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno * pi->step_c + pi->precno * pi->step_p;\n\t\t\t\t\tif (!pi->include[index]) {\n\t\t\t\t\t\tpi->include[index] = 1;\n\t\t\t\t\t\treturn OPJ_TRUE;\n\t\t\t\t\t}\nLABEL_SKIP:;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn OPJ_FALSE;\n}\n", "target": 0, "idx": 50053}
{"func": "   void TestPlaybackRate(double playback_rate) {\n    static const int kDefaultBufferSize = kSamplesPerSecond / 10;\n    static const int kDefaultFramesRequested = 5 * kSamplesPerSecond;\n \n     TestPlaybackRate(playback_rate, kDefaultBufferSize,\n                      kDefaultFramesRequested);\n  }\n", "target": 1, "idx": 185238}
{"func": "void WebPluginImpl::didFinishLoadingFrameRequest(\n     const WebURL& url, void* notify_data) {\n   if (delegate_) {\n     delegate_->DidFinishLoadWithReason(\n        url, NPRES_DONE, reinterpret_cast<intptr_t>(notify_data));\n   }\n }\n", "target": 1, "idx": 183603}
{"func": "static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOptionType options, int is_callable)\n{\n\tzval **arg_pattern_zval;\n\n\tchar *arg_pattern;\n\tint arg_pattern_len;\n\n\tchar *replace;\n\tint replace_len;\n\n\tzend_fcall_info arg_replace_fci;\n\tzend_fcall_info_cache arg_replace_fci_cache;\n\n\tchar *string;\n\tint string_len;\n\n\tchar *p;\n\tphp_mb_regex_t *re;\n\tOnigSyntaxType *syntax;\n\tOnigRegion *regs = NULL;\n\tsmart_str out_buf = { 0 };\n\tsmart_str eval_buf = { 0 };\n\tsmart_str *pbuf;\n\tint i, err, eval, n;\n\tOnigUChar *pos;\n\tOnigUChar *string_lim;\n\tchar *description = NULL;\n\tchar pat_buf[2];\n\n\tconst mbfl_encoding *enc;\n\n\t{\n\t\tconst char *current_enc_name;\n\t\tcurrent_enc_name = _php_mb_regex_mbctype2name(MBREX(current_mbctype));\n\t\tif (current_enc_name == NULL ||\n\t\t\t(enc = mbfl_name2encoding(current_enc_name)) == NULL) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unknown error\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\t}\n\teval = 0;\n\t{\n\t\tchar *option_str = NULL;\n\t\tint option_str_len = 0;\n\n\t\tif (!is_callable) {\n\t\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"Zss|s\",\n\t\t\t\t\t\t&arg_pattern_zval,\n\t\t\t\t\t\t&replace, &replace_len,\n\t\t\t\t\t\t&string, &string_len,\n\t\t\t\t\t\t&option_str, &option_str_len) == FAILURE) {\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t} else {\n\t\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"Zfs|s\",\n\t\t\t\t\t\t&arg_pattern_zval,\n\t\t\t\t\t\t&arg_replace_fci, &arg_replace_fci_cache,\n\t\t\t\t\t\t&string, &string_len,\n\t\t\t\t\t\t&option_str, &option_str_len) == FAILURE) {\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t}\n\n\t\tif (option_str != NULL) {\n\t\t\t_php_mb_regex_init_options(option_str, option_str_len, &options, &syntax, &eval);\n\t\t} else {\n\t\t\toptions |= MBREX(regex_default_options);\n\t\t\tsyntax = MBREX(regex_default_syntax);\n\t\t}\n\t}\n\tif (Z_TYPE_PP(arg_pattern_zval) == IS_STRING) {\n\t\targ_pattern = Z_STRVAL_PP(arg_pattern_zval);\n\t\targ_pattern_len = Z_STRLEN_PP(arg_pattern_zval);\n \t} else {\n \t\t/* FIXME: this code is not multibyte aware! */\n \t\tconvert_to_long_ex(arg_pattern_zval);\n\t\tpat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);\t\n \t\tpat_buf[1] = '\\0';\n \n \t\targ_pattern = pat_buf;\n\t\targ_pattern_len = 1;\t\n \t}\n \t/* create regex pattern buffer */\n \tre = php_mbregex_compile_pattern(arg_pattern, arg_pattern_len, options, MBREX(current_mbctype), syntax TSRMLS_CC);\n\tif (re == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (eval || is_callable) {\n\t\tpbuf = &eval_buf;\n\t\tdescription = zend_make_compiled_string_description(\"mbregex replace\" TSRMLS_CC);\n\t} else {\n\t\tpbuf = &out_buf;\n\t\tdescription = NULL;\n\t}\n\n\tif (is_callable) {\n\t\tif (eval) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Option 'e' cannot be used with replacement callback\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\t}\n\n\t/* do the actual work */\n\terr = 0;\n\tpos = (OnigUChar *)string;\n\tstring_lim = (OnigUChar*)(string + string_len);\n\tregs = onig_region_new();\n\twhile (err >= 0) {\n\t\terr = onig_search(re, (OnigUChar *)string, (OnigUChar *)string_lim, pos, (OnigUChar *)string_lim, regs, 0);\n\t\tif (err <= -2) {\n\t\t\tOnigUChar err_str[ONIG_MAX_ERROR_MESSAGE_LEN];\n\t\t\tonig_error_code_to_str(err_str, err);\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"mbregex search failure in php_mbereg_replace_exec(): %s\", err_str);\n\t\t\tbreak;\n\t\t}\n\t\tif (err >= 0) {\n#if moriyoshi_0\n\t\t\tif (regs->beg[0] == regs->end[0]) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Empty regular expression\");\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n\t\t\t/* copy the part of the string before the match */\n\t\t\tsmart_str_appendl(&out_buf, pos, (size_t)((OnigUChar *)(string + regs->beg[0]) - pos));\n\n\t\t\tif (!is_callable) {\n\t\t\t\t/* copy replacement and backrefs */\n\t\t\t\ti = 0;\n\t\t\t\tp = replace;\n\t\t\t\twhile (i < replace_len) {\n\t\t\t\t\tint fwd = (int) php_mb_mbchar_bytes_ex(p, enc);\n\t\t\t\t\tn = -1;\n\t\t\t\t\tif ((replace_len - i) >= 2 && fwd == 1 &&\n\t\t\t\t\tp[0] == '\\\\' && p[1] >= '0' && p[1] <= '9') {\n\t\t\t\t\t\tn = p[1] - '0';\n\t\t\t\t\t}\n\t\t\t\t\tif (n >= 0 && n < regs->num_regs) {\n\t\t\t\t\t\tif (regs->beg[n] >= 0 && regs->beg[n] < regs->end[n] && regs->end[n] <= string_len) {\n\t\t\t\t\t\t\tsmart_str_appendl(pbuf, string + regs->beg[n], regs->end[n] - regs->beg[n]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tp += 2;\n\t\t\t\t\t\ti += 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsmart_str_appendl(pbuf, p, fwd);\n\t\t\t\t\t\tp += fwd;\n\t\t\t\t\t\ti += fwd;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (eval) {\n \t\t\t\tzval v;\n \t\t\t\t/* null terminate buffer */\n\t\t\t\tsmart_str_0(&eval_buf);\n\t\t\t\t/* do eval */\n\t\t\t\tif (zend_eval_stringl(eval_buf.c, eval_buf.len, &v, description TSRMLS_CC) == FAILURE) {\n\t\t\t\t\tefree(description);\n\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC,E_ERROR, \"Failed evaluating code: %s%s\", PHP_EOL, eval_buf.c);\n\t\t\t\t\t/* zend_error() does not return in this case */\n\t\t\t\t}\n\n\t\t\t\t/* result of eval */\n\t\t\t\tconvert_to_string(&v);\n\t\t\t\tsmart_str_appendl(&out_buf, Z_STRVAL(v), Z_STRLEN(v));\n\t\t\t\t/* Clean up */\n \t\t\t\teval_buf.len = 0;\n \t\t\t\tzval_dtor(&v);\n \t\t\t} else if (is_callable) {\n\t\t\t\tzval *retval_ptr;\n \t\t\t\tzval **args[1];\n \t\t\t\tzval *subpats;\n \t\t\t\tint i;\n \t\t\t\tMAKE_STD_ZVAL(subpats);\n \t\t\t\tarray_init(subpats);\n \t\t\t\tfor (i = 0; i < regs->num_regs; i++) {\n \t\t\t\t\tadd_next_index_stringl(subpats, string + regs->beg[i], regs->end[i] - regs->beg[i], 1);\n\t\t\t\t}\t\t\t\t\n \t\t\t\targs[0] = &subpats;\n \t\t\t\t/* null terminate buffer */\n \t\t\t\tsmart_str_0(&eval_buf);\n \t\t\t\targ_replace_fci.param_count = 1;\n \t\t\t\targ_replace_fci.params = args;\n \t\t\t\targ_replace_fci.retval_ptr_ptr = &retval_ptr;\n\t\t\t\tif (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr) {\n \t\t\t\t\tconvert_to_string_ex(&retval_ptr);\n \t\t\t\t\tsmart_str_appendl(&out_buf, Z_STRVAL_P(retval_ptr), Z_STRLEN_P(retval_ptr));\n \t\t\t\t\teval_buf.len = 0;\n \t\t\t\t\tzval_ptr_dtor(&retval_ptr);\n \t\t\t\t} else {\n\t\t\t\t\tefree(description);\n \t\t\t\t\tif (!EG(exception)) {\n \t\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to call custom replacement function\");\n \t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tzval_ptr_dtor(&subpats);\n\t\t\t}\n\n\t\t\tn = regs->end[0];\n\t\t\tif ((pos - (OnigUChar *)string) < n) {\n \t\t\t\tpos = (OnigUChar *)string + n;\n \t\t\t} else {\n \t\t\t\tif (pos < string_lim) {\n\t\t\t\t\tsmart_str_appendl(&out_buf, pos, 1); \n \t\t\t\t}\n \t\t\t\tpos++;\n \t\t\t}\n\t\t} else { /* nomatch */\n\t\t\t/* stick that last bit of string on our output */\n\t\t\tif (string_lim - pos > 0) {\n\t\t\t\tsmart_str_appendl(&out_buf, pos, string_lim - pos);\n\t\t\t}\n\t\t}\n\t\tonig_region_free(regs, 0);\n\t}\n\n\tif (description) {\n\t\tefree(description);\n\t}\n\tif (regs != NULL) {\n\t\tonig_region_free(regs, 1);\n\t}\n \tsmart_str_free(&eval_buf);\n \n \tif (err <= -2) {\n\t\tsmart_str_free(&out_buf);\t\n \t\tRETVAL_FALSE;\n \t} else {\n \t\tsmart_str_appendc(&out_buf, '\\0');\n\t\tRETVAL_STRINGL((char *)out_buf.c, out_buf.len - 1, 0);\n\t}\n}\n", "target": 1, "idx": 180289}
{"func": "    virtual void TearDown()\n    {\n        Platform::current()->unitTestSupport()->unregisterAllMockedURLs();\n    }\n", "target": 0, "idx": 119503}
{"func": "static ssize_t o2nm_node_ipv4_address_store(struct config_item *item,\n\t\t\t\t\t    const char *page,\n \t\t\t\t\t    size_t count)\n {\n \tstruct o2nm_node *node = to_o2nm_node(item);\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);\n \tint ret, i;\n \tstruct rb_node **p, *parent;\n \tunsigned int octets[4];\n\t__be32 ipv4_addr = 0;\n\n\tret = sscanf(page, \"%3u.%3u.%3u.%3u\", &octets[3], &octets[2],\n\t\t     &octets[1], &octets[0]);\n\tif (ret != 4)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ARRAY_SIZE(octets); i++) {\n\t\tif (octets[i] > 255)\n\t\t\treturn -ERANGE;\n \t\tbe32_add_cpu(&ipv4_addr, octets[i] << (i * 8));\n \t}\n \n \tret = 0;\n \twrite_lock(&cluster->cl_nodes_lock);\n \tif (o2nm_node_ip_tree_lookup(cluster, ipv4_addr, &p, &parent))\n\t\tret = -EEXIST;\n\telse if (test_and_set_bit(O2NM_NODE_ATTR_ADDRESS,\n\t\t\t&node->nd_set_attributes))\n\t\tret = -EBUSY;\n\telse {\n\t\trb_link_node(&node->nd_ip_node, parent, p);\n \t\trb_insert_color(&node->nd_ip_node, &cluster->cl_node_ip_tree);\n \t}\n \twrite_unlock(&cluster->cl_nodes_lock);\n \tif (ret)\n \t\treturn ret;\n \n\tmemcpy(&node->nd_ipv4_address, &ipv4_addr, sizeof(ipv4_addr));\n\n\treturn count;\n}\n", "target": 1, "idx": 182577}
{"func": "void IndexedDBCursor::RemoveCursorFromTransaction() {\n  if (transaction_)\n    transaction_->UnregisterOpenCursor(this);\n}\n", "target": 1, "idx": 186275}
{"func": " static int zrle_send_framebuffer_update(VncState *vs, int x, int y,\n                                         int w, int h)\n {\n    bool be = !!(vs->clientds.flags & QEMU_BIG_ENDIAN_FLAG);\n     size_t bytes;\n     int zywrle_level;\n \n    if (vs->zrle.type == VNC_ENCODING_ZYWRLE) {\n        if (!vs->vd->lossy || vs->tight.quality == (uint8_t)-1\n            || vs->tight.quality == 9) {\n            zywrle_level = 0;\n            vs->zrle.type = VNC_ENCODING_ZRLE;\n        } else if (vs->tight.quality < 3) {\n            zywrle_level = 3;\n        } else if (vs->tight.quality < 6) {\n            zywrle_level = 2;\n        } else {\n            zywrle_level = 1;\n        }\n    } else {\n        zywrle_level = 0;\n    }\n \n     vnc_zrle_start(vs);\n \n    switch(vs->clientds.pf.bytes_per_pixel) {\n     case 1:\n         zrle_encode_8ne(vs, x, y, w, h, zywrle_level);\n         break;\n \n     case 2:\n        if (vs->clientds.pf.gmax > 0x1F) {\n             if (be) {\n                 zrle_encode_16be(vs, x, y, w, h, zywrle_level);\n             } else {\n                zrle_encode_16le(vs, x, y, w, h, zywrle_level);\n            }\n        } else {\n            if (be) {\n                zrle_encode_15be(vs, x, y, w, h, zywrle_level);\n            } else {\n                zrle_encode_15le(vs, x, y, w, h, zywrle_level);\n            }\n        }\n        break;\n\n    case 4:\n    {\n        bool fits_in_ls3bytes;\n         bool fits_in_ms3bytes;\n \n         fits_in_ls3bytes =\n            ((vs->clientds.pf.rmax << vs->clientds.pf.rshift) < (1 << 24) &&\n             (vs->clientds.pf.gmax << vs->clientds.pf.gshift) < (1 << 24) &&\n             (vs->clientds.pf.bmax << vs->clientds.pf.bshift) < (1 << 24));\n \n        fits_in_ms3bytes = (vs->clientds.pf.rshift > 7 &&\n                            vs->clientds.pf.gshift > 7 &&\n                            vs->clientds.pf.bshift > 7);\n \n         if ((fits_in_ls3bytes && !be) || (fits_in_ms3bytes && be)) {\n             if (be) {\n                zrle_encode_24abe(vs, x, y, w, h, zywrle_level);\n            } else {\n                zrle_encode_24ale(vs, x, y, w, h, zywrle_level);\n          }\n        } else if ((fits_in_ls3bytes && be) || (fits_in_ms3bytes && !be)) {\n            if (be) {\n                zrle_encode_24bbe(vs, x, y, w, h, zywrle_level);\n            } else {\n                zrle_encode_24ble(vs, x, y, w, h, zywrle_level);\n            }\n        } else {\n            if (be) {\n                zrle_encode_32be(vs, x, y, w, h, zywrle_level);\n            } else {\n                zrle_encode_32le(vs, x, y, w, h, zywrle_level);\n            }\n        }\n    }\n    break;\n    }\n\n    vnc_zrle_stop(vs);\n    bytes = zrle_compress_data(vs, Z_DEFAULT_COMPRESSION);\n    vnc_framebuffer_update(vs, x, y, w, h, vs->zrle.type);\n    vnc_write_u32(vs, bytes);\n    vnc_write(vs, vs->zrle.zlib.buffer, vs->zrle.zlib.offset);\n    return 1;\n}\n", "target": 1, "idx": 178640}
{"func": "  void RegisterProperties(IBusPropList* ibus_prop_list) {\n    DLOG(INFO) << \"RegisterProperties\" << (ibus_prop_list ? \"\" : \" (clear)\");\n \n     ImePropertyList prop_list;  // our representation.\n     if (ibus_prop_list) {\n       if (!FlattenPropertyList(ibus_prop_list, &prop_list)) {\n        RegisterProperties(NULL);\n         return;\n       }\n     }\n    register_ime_properties_(language_library_, prop_list);\n  }\n", "target": 1, "idx": 184001}
{"func": "ProcRenderCreateConicalGradient(ClientPtr client)\n{\n    PicturePtr pPicture;\n    int len;\n    int error = 0;\n    xFixed *stops;\n    xRenderColor *colors;\n\n    REQUEST(xRenderCreateConicalGradientReq);\n\n    REQUEST_AT_LEAST_SIZE(xRenderCreateConicalGradientReq);\n\n    LEGAL_NEW_RESOURCE(stuff->pid, client);\n\n    len = (client->req_len << 2) - sizeof(xRenderCreateConicalGradientReq);\n    if (stuff->nStops > UINT32_MAX / (sizeof(xFixed) + sizeof(xRenderColor)))\n        return BadLength;\n    if (len != stuff->nStops * (sizeof(xFixed) + sizeof(xRenderColor)))\n        return BadLength;\n\n    stops = (xFixed *) (stuff + 1);\n    colors = (xRenderColor *) (stops + stuff->nStops);\n\n    pPicture =\n        CreateConicalGradientPicture(stuff->pid, &stuff->center, stuff->angle,\n                                     stuff->nStops, stops, colors, &error);\n    if (!pPicture)\n        return error;\n    /* security creation/labeling check */\n    error = XaceHook(XACE_RESOURCE_ACCESS, client, stuff->pid, PictureType,\n                     pPicture, RT_NONE, NULL, DixCreateAccess);\n    if (error != Success)\n        return error;\n    if (!AddResource(stuff->pid, PictureType, (void *) pPicture))\n        return BadAlloc;\n    return Success;\n}\n", "target": 0, "idx": 17578}
{"func": "RenderWidgetHostViewAura::RenderWidgetHostViewAura(RenderWidgetHost* host,\n                                                   bool is_guest_view_hack)\n    : host_(RenderWidgetHostImpl::From(host)),\n      window_(nullptr),\n      in_shutdown_(false),\n      in_bounds_changed_(false),\n      popup_parent_host_view_(nullptr),\n      popup_child_host_view_(nullptr),\n      is_loading_(false),\n      has_composition_text_(false),\n      background_color_(SK_ColorWHITE),\n      needs_begin_frames_(false),\n      needs_flush_input_(false),\n      added_frame_observer_(false),\n      cursor_visibility_state_in_renderer_(UNKNOWN),\n#if defined(OS_WIN)\n      legacy_render_widget_host_HWND_(nullptr),\n      legacy_window_destroyed_(false),\n      virtual_keyboard_requested_(false),\n#endif\n      has_snapped_to_boundary_(false),\n       is_guest_view_hack_(is_guest_view_hack),\n       device_scale_factor_(0.0f),\n       event_handler_(new RenderWidgetHostViewEventHandler(host_, this, this)),\n       weak_ptr_factory_(this) {\n   if (!is_guest_view_hack_)\n     host_->SetView(this);\n\n  if (GetTextInputManager())\n    GetTextInputManager()->AddObserver(this);\n\n  bool overscroll_enabled = base::CommandLine::ForCurrentProcess()->\n      GetSwitchValueASCII(switches::kOverscrollHistoryNavigation) != \"0\";\n  SetOverscrollControllerEnabled(overscroll_enabled);\n\n  selection_controller_client_.reset(\n      new TouchSelectionControllerClientAura(this));\n  CreateSelectionController();\n\n  RenderViewHost* rvh = RenderViewHost::From(host_);\n  if (rvh) {\n    ignore_result(rvh->GetWebkitPreferences());\n  }\n}\n", "target": 1, "idx": 186203}
{"func": "PHP_METHOD(Phar, getSupportedCompression)\n{\n        if (zend_parse_parameters_none() == FAILURE) {\n                return;\n        }\n        array_init(return_value);\n        phar_request_initialize(TSRMLS_C);\n \n\tif (PHAR_G(has_zlib)) {\n\t\tadd_next_index_stringl(return_value, \"GZ\", 2, 1);\n\t}\n\n\tif (PHAR_G(has_bz2)) {\n\t\tadd_next_index_stringl(return_value, \"BZIP2\", 5, 1);\n\t}\n}\n", "target": 1, "idx": 178465}
{"func": "  CurrentThreadMock()\n      : task_runner_delegate_(\n            scheduler::LazySchedulerMessageLoopDelegateForTests::Create()),\n        scheduler_(\n            new scheduler::RendererSchedulerImpl(task_runner_delegate_.get())),\n        web_scheduler_(\n            new scheduler::RendererWebSchedulerImpl(scheduler_.get())),\n        web_task_runner_(\n            new scheduler::WebTaskRunnerImpl(scheduler_->DefaultTaskRunner())) {\n  }\n", "target": 0, "idx": 145052}
{"func": "void WebLocalFrameImpl::BindDevToolsAgentRequest(\n    mojom::blink::DevToolsAgentAssociatedRequest request) {\n  if (!dev_tools_agent_)\n    dev_tools_agent_ = WebDevToolsAgentImpl::CreateForFrame(this);\n  dev_tools_agent_->BindRequest(std::move(request));\n}\n", "target": 0, "idx": 158501}
{"func": "static int setup_dev_console(const struct lxc_rootfs *rootfs,\n\t\t\t const struct lxc_console *console)\n{\n\tchar path[MAXPATHLEN];\n\tstruct stat s;\n\tint ret;\n\n\tret = snprintf(path, sizeof(path), \"%s/dev/console\", rootfs->mount);\n\tif (ret >= sizeof(path)) {\n\t\tERROR(\"console path too long\");\n\t\treturn -1;\n\t}\n\n\tif (access(path, F_OK)) {\n\t\tWARN(\"rootfs specified but no console found at '%s'\", path);\n\t\treturn 0;\n\t}\n\n\tif (console->master < 0) {\n\t\tINFO(\"no console\");\n\t\treturn 0;\n\t}\n\n\tif (stat(path, &s)) {\n\t\tSYSERROR(\"failed to stat '%s'\", path);\n\t\treturn -1;\n\t}\n\n\tif (chmod(console->name, s.st_mode)) {\n\t\tSYSERROR(\"failed to set mode '0%o' to '%s'\",\n\t\t\t s.st_mode, console->name);\n \t\treturn -1;\n \t}\n \n\tif (mount(console->name, path, \"none\", MS_BIND, 0)) {\n \t\tERROR(\"failed to mount '%s' on '%s'\", console->name, path);\n \t\treturn -1;\n \t}\n\n\tINFO(\"console has been setup\");\n\treturn 0;\n}\n", "target": 1, "idx": 179892}
{"func": "  void UpdateNetworkManagerStatus() {\n    if (!BrowserThread::CurrentlyOn(BrowserThread::UI)) {\n      BrowserThread::PostTask(\n          BrowserThread::UI, FROM_HERE,\n          NewRunnableMethod(this,\n                            &NetworkLibraryImpl::UpdateNetworkManagerStatus));\n      return;\n    }\n\n    SystemInfo* system = GetSystemInfo();\n    if (!system)\n      return;\n\n\n    std::string prev_cellular_service_path = cellular_ ?\n        cellular_->service_path() : std::string();\n\n    ClearNetworks();\n\n    ParseSystem(system, &ethernet_, &wifi_networks_, &cellular_networks_,\n                &remembered_wifi_networks_);\n\n    wifi_ = NULL;\n    for (size_t i = 0; i < wifi_networks_.size(); i++) {\n      if (wifi_networks_[i]->connecting_or_connected()) {\n        wifi_ = wifi_networks_[i];\n        break;  // There is only one connected or connecting wifi network.\n      }\n    }\n    cellular_ = NULL;\n     for (size_t i = 0; i < cellular_networks_.size(); i++) {\n       if (cellular_networks_[i]->connecting_or_connected()) {\n         cellular_ = cellular_networks_[i];\n         if (cellular_networks_[i]->service_path() !=\n                 prev_cellular_service_path) {\n          CellularDataPlanList* list = RetrieveCellularDataPlans(\n              cellular_->service_path().c_str());\n          UpdateCellularDataPlan(list);\n          FreeCellularDataPlanList(list);\n         }\n         break;  // There is only one connected or connecting cellular network.\n       }\n    }\n\n    available_devices_ = system->available_technologies;\n    enabled_devices_ = system->enabled_technologies;\n    connected_devices_ = system->connected_technologies;\n    offline_mode_ = system->offline_mode;\n\n    NotifyNetworkManagerChanged();\n    FreeSystemInfo(system);\n  }\n", "target": 1, "idx": 183616}
{"func": "void RenderWidgetHostImpl::ForwardMouseEvent(const WebMouseEvent& mouse_event) {\n  if (GetView()->IsInVR() &&\n      (is_in_gesture_scroll_[blink::kWebGestureDeviceTouchpad] ||\n       is_in_touchpad_gesture_fling_)) {\n    return;\n  }\n\n  ForwardMouseEventWithLatencyInfo(mouse_event,\n                                   ui::LatencyInfo(ui::SourceEventType::MOUSE));\n  if (owner_delegate_)\n    owner_delegate_->RenderWidgetDidForwardMouseEvent(mouse_event);\n}\n", "target": 0, "idx": 158270}
{"func": "static int raw_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct net *net = sock_net(sk);\n\tstruct ipcm_cookie ipc;\n\tstruct rtable *rt = NULL;\n\tstruct flowi4 fl4;\n\tint free = 0;\n\t__be32 daddr;\n\t__be32 saddr;\n\tu8  tos;\n \tint err;\n \tstruct ip_options_data opt_copy;\n \tstruct raw_frag_vec rfv;\n \n \terr = -EMSGSIZE;\n \tif (len > 0xFFFF)\n \t\tgoto out;\n \n \t/*\n \t *\tCheck the flags.\n \t */\n\n\terr = -EOPNOTSUPP;\n\tif (msg->msg_flags & MSG_OOB)\t/* Mirror BSD error message */\n\t\tgoto out;               /* compatibility */\n\n\t/*\n\t *\tGet and verify the address.\n\t */\n\n\tif (msg->msg_namelen) {\n\t\tDECLARE_SOCKADDR(struct sockaddr_in *, usin, msg->msg_name);\n\t\terr = -EINVAL;\n\t\tif (msg->msg_namelen < sizeof(*usin))\n\t\t\tgoto out;\n\t\tif (usin->sin_family != AF_INET) {\n\t\t\tpr_info_once(\"%s: %s forgot to set AF_INET. Fix it!\\n\",\n\t\t\t\t     __func__, current->comm);\n\t\t\terr = -EAFNOSUPPORT;\n\t\t\tif (usin->sin_family)\n\t\t\t\tgoto out;\n\t\t}\n\t\tdaddr = usin->sin_addr.s_addr;\n\t\t/* ANK: I did not forget to get protocol from port field.\n\t\t * I just do not know, who uses this weirdness.\n\t\t * IP_HDRINCL is much more convenient.\n\t\t */\n\t} else {\n\t\terr = -EDESTADDRREQ;\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out;\n\t\tdaddr = inet->inet_daddr;\n\t}\n\n\tipc.sockc.tsflags = sk->sk_tsflags;\n\tipc.addr = inet->inet_saddr;\n\tipc.opt = NULL;\n\tipc.tx_flags = 0;\n\tipc.ttl = 0;\n\tipc.tos = -1;\n\tipc.oif = sk->sk_bound_dev_if;\n\n\tif (msg->msg_controllen) {\n\t\terr = ip_cmsg_send(sk, msg, &ipc, false);\n\t\tif (unlikely(err)) {\n\t\t\tkfree(ipc.opt);\n\t\t\tgoto out;\n\t\t}\n\t\tif (ipc.opt)\n\t\t\tfree = 1;\n\t}\n\n\tsaddr = ipc.addr;\n\tipc.addr = daddr;\n\n\tif (!ipc.opt) {\n\t\tstruct ip_options_rcu *inet_opt;\n\n\t\trcu_read_lock();\n\t\tinet_opt = rcu_dereference(inet->inet_opt);\n\t\tif (inet_opt) {\n\t\t\tmemcpy(&opt_copy, inet_opt,\n\t\t\t       sizeof(*inet_opt) + inet_opt->opt.optlen);\n\t\t\tipc.opt = &opt_copy.opt;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tif (ipc.opt) {\n\t\terr = -EINVAL;\n \t\t/* Linux does not mangle headers on raw sockets,\n \t\t * so that IP options + IP_HDRINCL is non-sense.\n \t\t */\n\t\tif (inet->hdrincl)\n \t\t\tgoto done;\n \t\tif (ipc.opt->opt.srr) {\n \t\t\tif (!daddr)\n\t\t\t\tgoto done;\n\t\t\tdaddr = ipc.opt->opt.faddr;\n\t\t}\n\t}\n\ttos = get_rtconn_flags(&ipc, sk);\n\tif (msg->msg_flags & MSG_DONTROUTE)\n\t\ttos |= RTO_ONLINK;\n\n\tif (ipv4_is_multicast(daddr)) {\n\t\tif (!ipc.oif)\n\t\t\tipc.oif = inet->mc_index;\n\t\tif (!saddr)\n\t\t\tsaddr = inet->mc_addr;\n\t} else if (!ipc.oif)\n\t\tipc.oif = inet->uc_index;\n \n \tflowi4_init_output(&fl4, ipc.oif, sk->sk_mark, tos,\n \t\t\t   RT_SCOPE_UNIVERSE,\n\t\t\t   inet->hdrincl ? IPPROTO_RAW : sk->sk_protocol,\n \t\t\t   inet_sk_flowi_flags(sk) |\n\t\t\t    (inet->hdrincl ? FLOWI_FLAG_KNOWN_NH : 0),\n \t\t\t   daddr, saddr, 0, 0, sk->sk_uid);\n \n\tif (!inet->hdrincl) {\n \t\trfv.msg = msg;\n \t\trfv.hlen = 0;\n \n\t\terr = raw_probe_proto_opt(&rfv, &fl4);\n\t\tif (err)\n\t\t\tgoto done;\n\t}\n\n\tsecurity_sk_classify_flow(sk, flowi4_to_flowi(&fl4));\n\trt = ip_route_output_flow(net, &fl4, sk);\n\tif (IS_ERR(rt)) {\n\t\terr = PTR_ERR(rt);\n\t\trt = NULL;\n\t\tgoto done;\n\t}\n\n\terr = -EACCES;\n\tif (rt->rt_flags & RTCF_BROADCAST && !sock_flag(sk, SOCK_BROADCAST))\n\t\tgoto done;\n\n\tif (msg->msg_flags & MSG_CONFIRM)\n \t\tgoto do_confirm;\n back_from_confirm:\n \n\tif (inet->hdrincl)\n \t\terr = raw_send_hdrinc(sk, &fl4, msg, len,\n \t\t\t\t      &rt, msg->msg_flags, &ipc.sockc);\n \n\t else {\n\t\tsock_tx_timestamp(sk, ipc.sockc.tsflags, &ipc.tx_flags);\n\n\t\tif (!ipc.addr)\n\t\t\tipc.addr = fl4.daddr;\n\t\tlock_sock(sk);\n\t\terr = ip_append_data(sk, &fl4, raw_getfrag,\n\t\t\t\t     &rfv, len, 0,\n\t\t\t\t     &ipc, &rt, msg->msg_flags);\n\t\tif (err)\n\t\t\tip_flush_pending_frames(sk);\n\t\telse if (!(msg->msg_flags & MSG_MORE)) {\n\t\t\terr = ip_push_pending_frames(sk, &fl4);\n\t\t\tif (err == -ENOBUFS && !inet->recverr)\n\t\t\t\terr = 0;\n\t\t}\n\t\trelease_sock(sk);\n\t}\ndone:\n\tif (free)\n\t\tkfree(ipc.opt);\n\tip_rt_put(rt);\n\nout:\n\tif (err < 0)\n\t\treturn err;\n\treturn len;\n\ndo_confirm:\n\tif (msg->msg_flags & MSG_PROBE)\n\t\tdst_confirm_neigh(&rt->dst, &fl4.daddr);\n\tif (!(msg->msg_flags & MSG_PROBE) || len)\n\t\tgoto back_from_confirm;\n\terr = 0;\n\tgoto done;\n}\n", "target": 1, "idx": 180825}
{"func": "void NetworkReaderProxy::OnGetContent(scoped_ptr<std::string> data) {\n   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));\n   DCHECK(data && !data->empty());\n \n   pending_data_.push_back(data.release());\n   if (!buffer_) {\n    return;\n  }\n\n  int result = ReadInternal(&pending_data_, buffer_.get(), buffer_length_);\n  remaining_content_length_ -= result;\n  DCHECK_GE(remaining_content_length_, 0);\n\n  buffer_ = NULL;\n  buffer_length_ = 0;\n  DCHECK(!callback_.is_null());\n  base::ResetAndReturn(&callback_).Run(result);\n}\n", "target": 1, "idx": 185005}
{"func": "InlineBoxPosition ComputeInlineBoxPositionTemplate(\n    const PositionTemplate<Strategy>& position,\n    TextAffinity affinity,\n    TextDirection primary_direction) {\n  int caret_offset = position.ComputeEditingOffset();\n  Node* const anchor_node = position.AnchorNode();\n  LayoutObject* layout_object =\n      anchor_node->IsShadowRoot()\n          ? ToShadowRoot(anchor_node)->host().GetLayoutObject()\n          : anchor_node->GetLayoutObject();\n\n  DCHECK(layout_object) << position;\n\n  if (layout_object->IsText()) {\n    return ComputeInlineBoxPositionForTextNode(layout_object, caret_offset,\n                                                affinity, primary_direction);\n   }\n \n  if (layout_object->IsLayoutBlockFlow()) {\n    if (CanHaveChildrenForEditing(anchor_node) &&\n        HasRenderedNonAnonymousDescendantsWithHeight(layout_object)) {\n      const PositionTemplate<Strategy>& downstream_equivalent =\n          DownstreamIgnoringEditingBoundaries(position);\n      if (downstream_equivalent != position) {\n        return ComputeInlineBoxPosition(\n            downstream_equivalent, TextAffinity::kUpstream, primary_direction);\n      }\n      const PositionTemplate<Strategy>& upstream_equivalent =\n          UpstreamIgnoringEditingBoundaries(position);\n      if (upstream_equivalent == position ||\n          DownstreamIgnoringEditingBoundaries(upstream_equivalent) == position)\n        return InlineBoxPosition();\n      return ComputeInlineBoxPosition(\n          upstream_equivalent, TextAffinity::kUpstream, primary_direction);\n    }\n   }\n \n  if (!layout_object->IsAtomicInlineLevel())\n     return InlineBoxPosition();\n  if (!layout_object->IsBox())\n     return InlineBoxPosition();\n  InlineBox* const inline_box = ToLayoutBox(layout_object)->InlineBoxWrapper();\n  if (!inline_box)\n     return InlineBoxPosition();\n  if ((caret_offset > inline_box->CaretMinOffset() &&\n       caret_offset < inline_box->CaretMaxOffset()))\n    return InlineBoxPosition(inline_box, caret_offset);\n  return AdjustInlineBoxPositionForTextDirection(\n      inline_box, caret_offset, layout_object->Style()->GetUnicodeBidi(),\n      primary_direction);\n }\n", "target": 1, "idx": 186941}
{"func": "void PDFiumEngine::Form_Beep(IPDF_JSPLATFORM* param, int type) {\n}\n", "target": 0, "idx": 152974}
{"func": "void QuotaManager::GetUsageAndQuotaForEviction(\n    const GetUsageAndQuotaForEvictionCallback& callback) {\n  DCHECK(io_thread_->BelongsToCurrentThread());\n  GetUsageAndQuotaInternal(\n      GURL(), kStorageTypeTemporary, true /* global */, callback);\n}\n", "target": 0, "idx": 108510}
{"func": " static unsigned int seedsize(struct crypto_alg *alg)\n {\n \tstruct rng_alg *ralg = container_of(alg, struct rng_alg, base);\n \n\treturn alg->cra_rng.rng_make_random ?\n\t       alg->cra_rng.seedsize : ralg->seedsize;\n }\n", "target": 1, "idx": 180907}
{"func": "PHP_FUNCTION(imagecopyresampled)\n{\n\tzval *SIM, *DIM;\n\tlong SX, SY, SW, SH, DX, DY, DW, DH;\n\tgdImagePtr im_dst, im_src;\n\tint srcH, srcW, dstH, dstW, srcY, srcX, dstY, dstX;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rrllllllll\", &DIM, &SIM, &DX, &DY, &SX, &SY, &DW, &DH, &SW, &SH) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im_dst, gdImagePtr, &DIM, -1, \"Image\", le_gd);\n\tZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, \"Image\", le_gd);\n\n\tsrcX = SX;\n\tsrcY = SY;\n\tsrcH = SH;\n\tsrcW = SW;\n\tdstX = DX;\n\tdstY = DY;\n\tdstH = DH;\n\tdstW = DW;\n\n\tgdImageCopyResampled(im_dst, im_src, dstX, dstY, srcX, srcY, dstW, dstH, srcW, srcH);\n\n\tRETURN_TRUE;\n}\n", "target": 0, "idx": 15103}
{"func": "int git_index__changed_relative_to(\n\tgit_index *index, const git_oid *checksum)\n{\n\t/* attempt to update index (ignoring errors) */\n\tif (git_index_read(index, false) < 0)\n\t\tgiterr_clear();\n\n\treturn !!git_oid_cmp(&index->checksum, checksum);\n}\n", "target": 0, "idx": 83650}
{"func": " static bool HasElementImpl(Isolate* isolate, Handle<JSObject> holder,\n uint32_t index,\n Handle<FixedArrayBase> backing_store,\n PropertyFilter filter = ALL_PROPERTIES) {\n return Subclass::GetEntryForIndexImpl(isolate, *holder, *backing_store,\n                                          index, filter) != kMaxUInt32;\n }\n", "target": 0, "idx": 176303}
{"func": "int hugetlb_reserve_pages(struct inode *inode,\n\t\t\t\t\tlong from, long to,\n\t\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\t\tvm_flags_t vm_flags)\n{\n\tlong ret, chg;\n\tstruct hstate *h = hstate_inode(inode);\n\tstruct hugepage_subpool *spool = subpool_inode(inode);\n\n\t/*\n\t * Only apply hugepage reservation if asked. At fault time, an\n\t * attempt will be made for VM_NORESERVE to allocate a page\n\t * without using reserves\n\t */\n\tif (vm_flags & VM_NORESERVE)\n\t\treturn 0;\n\n\t/*\n\t * Shared mappings base their reservation on the number of pages that\n\t * are already allocated on behalf of the file. Private mappings need\n\t * to reserve the full area even if read-only as mprotect() may be\n\t * called to make the mapping read-write. Assume !vma is a shm mapping\n\t */\n\tif (!vma || vma->vm_flags & VM_MAYSHARE)\n\t\tchg = region_chg(&inode->i_mapping->private_list, from, to);\n\telse {\n\t\tstruct resv_map *resv_map = resv_map_alloc();\n\t\tif (!resv_map)\n\t\t\treturn -ENOMEM;\n\n\t\tchg = to - from;\n\n\t\tset_vma_resv_map(vma, resv_map);\n \t\tset_vma_resv_flags(vma, HPAGE_RESV_OWNER);\n \t}\n \n\tif (chg < 0)\n\t\treturn chg;\n \n \t/* There must be enough pages in the subpool for the mapping */\n\tif (hugepage_subpool_get_pages(spool, chg))\n\t\treturn -ENOSPC;\n \n \t/*\n \t * Check enough hugepages are available for the reservation.\n\t * Hand the pages back to the subpool if there are not\n\t */\n \tret = hugetlb_acct_memory(h, chg);\n \tif (ret < 0) {\n \t\thugepage_subpool_put_pages(spool, chg);\n\t\treturn ret;\n \t}\n \n \t/*\n\t * Account for the reservations made. Shared mappings record regions\n\t * that have reservations as they are shared by multiple VMAs.\n\t * When the last VMA disappears, the region map says how much\n\t * the reservation was and the page cache tells how much of\n\t * the reservation was consumed. Private mappings are per-VMA and\n\t * only the consumed reservations are tracked. When the VMA\n\t * disappears, the original reservation is the VMA size and the\n\t * consumed reservations are stored in the map. Hence, nothing\n\t * else has to be done for private mappings here\n\t */\n \tif (!vma || vma->vm_flags & VM_MAYSHARE)\n \t\tregion_add(&inode->i_mapping->private_list, from, to);\n \treturn 0;\n }\n", "target": 1, "idx": 178766}
{"func": "void WebGLRenderingContextBase::TexImageHelperHTMLVideoElement(\n    SecurityOrigin* security_origin,\n    TexImageFunctionID function_id,\n    GLenum target,\n    GLint level,\n    GLint internalformat,\n    GLenum format,\n    GLenum type,\n    GLint xoffset,\n    GLint yoffset,\n    GLint zoffset,\n    HTMLVideoElement* video,\n    const IntRect& source_image_rect,\n    GLsizei depth,\n    GLint unpack_image_height,\n    ExceptionState& exception_state) {\n  const char* func_name = GetTexImageFunctionName(function_id);\n  if (isContextLost())\n    return;\n\n  if (!ValidateHTMLVideoElement(security_origin, func_name, video,\n                                exception_state))\n    return;\n  WebGLTexture* texture =\n      ValidateTexImageBinding(func_name, function_id, target);\n  if (!texture)\n    return;\n  TexImageFunctionType function_type;\n  if (function_id == kTexImage2D || function_id == kTexImage3D)\n    function_type = kTexImage;\n  else\n    function_type = kTexSubImage;\n  if (!ValidateTexFunc(func_name, function_type, kSourceHTMLVideoElement,\n                       target, level, internalformat, video->videoWidth(),\n                       video->videoHeight(), 1, 0, format, type, xoffset,\n                       yoffset, zoffset))\n    return;\n\n  bool source_image_rect_is_default =\n      source_image_rect == SentinelEmptyRect() ||\n      source_image_rect ==\n          IntRect(0, 0, video->videoWidth(), video->videoHeight());\n  const bool use_copyTextureCHROMIUM = function_id == kTexImage2D &&\n                                       source_image_rect_is_default &&\n                                       depth == 1 && GL_TEXTURE_2D == target &&\n                                       CanUseTexImageByGPU(format, type);\n  if (use_copyTextureCHROMIUM) {\n    DCHECK_EQ(xoffset, 0);\n    DCHECK_EQ(yoffset, 0);\n    DCHECK_EQ(zoffset, 0);\n\n    if (video->CopyVideoTextureToPlatformTexture(\n            ContextGL(), target, texture->Object(), internalformat, format,\n            type, level, unpack_premultiply_alpha_, unpack_flip_y_)) {\n      texture->UpdateLastUploadedVideo(video->GetWebMediaPlayer());\n      return;\n    }\n  }\n\n  if (source_image_rect_is_default) {\n    ScopedUnpackParametersResetRestore(\n        this, unpack_flip_y_ || unpack_premultiply_alpha_);\n    if (video->TexImageImpl(\n            static_cast<WebMediaPlayer::TexImageFunctionID>(function_id),\n            target, ContextGL(), texture->Object(), level,\n            ConvertTexInternalFormat(internalformat, type), format, type,\n            xoffset, yoffset, zoffset, unpack_flip_y_,\n            unpack_premultiply_alpha_ &&\n                unpack_colorspace_conversion_ == GL_NONE)) {\n      texture->UpdateLastUploadedVideo(video->GetWebMediaPlayer());\n      return;\n    }\n  }\n\n  if (use_copyTextureCHROMIUM) {\n    std::unique_ptr<ImageBufferSurface> surface =\n        WTF::WrapUnique(new AcceleratedImageBufferSurface(\n            IntSize(video->videoWidth(), video->videoHeight())));\n    if (surface->IsValid()) {\n      std::unique_ptr<ImageBuffer> image_buffer(\n          ImageBuffer::Create(std::move(surface)));\n      if (image_buffer) {\n        video->PaintCurrentFrame(\n            image_buffer->Canvas(),\n            IntRect(0, 0, video->videoWidth(), video->videoHeight()), nullptr);\n\n\n        TexImage2DBase(target, level, internalformat, video->videoWidth(),\n                       video->videoHeight(), 0, format, type, nullptr);\n\n        if (image_buffer->CopyToPlatformTexture(\n                FunctionIDToSnapshotReason(function_id), ContextGL(), target,\n                texture->Object(), unpack_premultiply_alpha_, unpack_flip_y_,\n                IntPoint(0, 0),\n                IntRect(0, 0, video->videoWidth(), video->videoHeight()))) {\n          texture->UpdateLastUploadedVideo(video->GetWebMediaPlayer());\n          return;\n        }\n      }\n    }\n  }\n\n  RefPtr<Image> image = VideoFrameToImage(video);\n  if (!image)\n    return;\n  TexImageImpl(function_id, target, level, internalformat, xoffset, yoffset,\n               zoffset, format, type, image.Get(),\n               WebGLImageConversion::kHtmlDomVideo, unpack_flip_y_,\n               unpack_premultiply_alpha_, source_image_rect, depth,\n               unpack_image_height);\n  texture->UpdateLastUploadedVideo(video->GetWebMediaPlayer());\n}\n", "target": 0, "idx": 146388}
{"func": "const CuePoint* Cues::GetFirst() const {\n if (m_cue_points == NULL || m_count == 0)\n return NULL;\n\n CuePoint* const* const pp = m_cue_points;\n if (pp == NULL)\n return NULL;\n\n CuePoint* const pCP = pp[0];\n if (pCP == NULL || pCP->GetTimeCode() < 0)\n return NULL;\n\n return pCP;\n}\n", "target": 0, "idx": 177397}
{"func": "xfs_da_map_covers_blocks(\n\tint\t\tnmap,\n\txfs_bmbt_irec_t\t*mapp,\n\txfs_dablk_t\tbno,\n\tint\t\tcount)\n{\n\tint\t\ti;\n\txfs_fileoff_t\toff;\n\n\tfor (i = 0, off = bno; i < nmap; i++) {\n\t\tif (mapp[i].br_startblock == HOLESTARTBLOCK ||\n\t\t    mapp[i].br_startblock == DELAYSTARTBLOCK) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (off != mapp[i].br_startoff) {\n\t\t\treturn 0;\n\t\t}\n\t\toff += mapp[i].br_blockcount;\n\t}\n\treturn off == bno + count;\n}\n", "target": 0, "idx": 35959}
{"func": "RenderFrameImpl::createWorkerPermissionClientProxy(\n    blink::WebLocalFrame* frame) {\n  if (!frame || !frame->view())\n    return NULL;\n  DCHECK(!frame_ || frame_ == frame);\n  return GetContentClient()->renderer()->CreateWorkerPermissionClientProxy(\n      this, frame);\n}\n", "target": 0, "idx": 118483}
{"func": "  void SendAlternateCut() {\n    if (TestingNativeMac())\n      SendKeyEvent(ui::VKEY_X, false, true);\n    else\n      SendKeyEvent(ui::VKEY_DELETE, true, false);\n  }\n", "target": 0, "idx": 137356}
{"func": "void ServiceWorkerDevToolsAgentHost::AttachSession(DevToolsSession* session) {\n  if (state_ == WORKER_READY) {\n    if (sessions().size() == 1) {\n      BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,\n                               base::BindOnce(&SetDevToolsAttachedOnIO,\n                                              context_weak_, version_id_, true));\n     }\n    session->SetRenderer(RenderProcessHost::FromID(worker_process_id_),\n                         nullptr);\n     session->AttachToAgent(agent_ptr_);\n   }\n   session->AddHandler(base::WrapUnique(new protocol::InspectorHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::NetworkHandler(GetId())));\n  session->AddHandler(base::WrapUnique(new protocol::SchemaHandler()));\n}\n", "target": 1, "idx": 186760}
{"func": "cJSON *cJSON_CreateBool(int b)\t\t\t\t\t{cJSON *item=cJSON_New_Item();if(item)item->type=b?cJSON_True:cJSON_False;return item;}\n", "target": 0, "idx": 93696}
{"func": "static ssize_t WritePSDChannels(const PSDInfo *psd_info,\n  const ImageInfo *image_info,Image *image,Image *next_image,\n  MagickOffsetType size_offset,const MagickBooleanType separate)\n{\n  Image\n    *mask;\n\n  MagickOffsetType\n    rows_offset;\n\n  size_t\n    channels,\n    count,\n    length,\n    offset_length;\n\n  unsigned char\n    *compact_pixels;\n\n  count=0;\n  offset_length=0;\n  rows_offset=0;\n   compact_pixels=(unsigned char *) NULL;\n   if (next_image->compression == RLECompression)\n     {\n      compact_pixels=AcquireCompactPixels(image);\n       if (compact_pixels == (unsigned char *) NULL)\n         return(0);\n     }\n  channels=1;\n  if (separate == MagickFalse)\n    {\n      if (next_image->storage_class != PseudoClass)\n        {\n          if (IsGrayImage(next_image,&next_image->exception) == MagickFalse)\n            channels=next_image->colorspace == CMYKColorspace ? 4 : 3;\n          if (next_image->matte != MagickFalse)\n            channels++;\n        }\n      rows_offset=TellBlob(image)+2;\n      count+=WriteCompressionStart(psd_info,image,next_image,channels);\n      offset_length=(next_image->rows*(psd_info->version == 1 ? 2 : 4));\n    }\n  size_offset+=2;\n  if (next_image->storage_class == PseudoClass)\n    {\n      length=WritePSDChannel(psd_info,image_info,image,next_image,\n        IndexQuantum,compact_pixels,rows_offset,separate);\n      if (separate != MagickFalse)\n        size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;\n      else\n        rows_offset+=offset_length;\n      count+=length;\n    }\n  else\n    {\n      if (IsGrayImage(next_image,&next_image->exception) != MagickFalse)\n        {\n          length=WritePSDChannel(psd_info,image_info,image,next_image,\n            GrayQuantum,compact_pixels,rows_offset,separate);\n          if (separate != MagickFalse)\n            size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;\n          else\n            rows_offset+=offset_length;\n          count+=length;\n        }\n      else\n        {\n          if (next_image->colorspace == CMYKColorspace)\n            (void) NegateImage(next_image,MagickFalse);\n\n          length=WritePSDChannel(psd_info,image_info,image,next_image,\n            RedQuantum,compact_pixels,rows_offset,separate);\n          if (separate != MagickFalse)\n            size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;\n          else\n            rows_offset+=offset_length;\n          count+=length;\n\n          length=WritePSDChannel(psd_info,image_info,image,next_image,\n            GreenQuantum,compact_pixels,rows_offset,separate);\n          if (separate != MagickFalse)\n            size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;\n          else\n            rows_offset+=offset_length;\n          count+=length;\n\n          length=WritePSDChannel(psd_info,image_info,image,next_image,\n            BlueQuantum,compact_pixels,rows_offset,separate);\n          if (separate != MagickFalse)\n            size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;\n          else\n            rows_offset+=offset_length;\n          count+=length;\n\n          if (next_image->colorspace == CMYKColorspace)\n            {\n              length=WritePSDChannel(psd_info,image_info,image,next_image,\n                BlackQuantum,compact_pixels,rows_offset,separate);\n              if (separate != MagickFalse)\n                size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;\n              else\n                rows_offset+=offset_length;\n              count+=length;\n            }\n        }\n      if (next_image->matte != MagickFalse)\n        {\n          length=WritePSDChannel(psd_info,image_info,image,next_image,\n            AlphaQuantum,compact_pixels,rows_offset,separate);\n          if (separate != MagickFalse)\n            size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;\n          else\n            rows_offset+=offset_length;\n          count+=length;\n        }\n    }\n  compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);\n  if (next_image->colorspace == CMYKColorspace)\n    (void) NegateImage(next_image,MagickFalse);\n  if (separate != MagickFalse)\n    {\n      const char\n        *property;\n\n      property=GetImageArtifact(next_image,\"psd:opacity-mask\");\n      if (property != (const char *) NULL)\n        {\n          mask=(Image *) GetImageRegistry(ImageRegistryType,property,\n            &image->exception);\n          if (mask != (Image *) NULL)\n            {\n              if (mask->compression == RLECompression)\n                {\n                  compact_pixels=AcquireCompactPixels(mask);\n                  if (compact_pixels == (unsigned char *) NULL)\n                    return(0);\n                }\n              length=WritePSDChannel(psd_info,image_info,image,mask,\n                RedQuantum,compact_pixels,rows_offset,MagickTrue);\n              (void) WritePSDSize(psd_info,image,length,size_offset);\n              count+=length;\n              compact_pixels=(unsigned char *) RelinquishMagickMemory(\n                compact_pixels);\n            }\n        }\n    }\n  return(count);\n}\n", "target": 1, "idx": 183275}
{"func": "void VideoCaptureImpl::OnBufferCreated(int32_t buffer_id,\n                                       mojo::ScopedSharedBufferHandle handle) {\n  DVLOG(1) << __func__ << \" buffer_id: \" << buffer_id;\n  DCHECK(io_thread_checker_.CalledOnValidThread());\n  DCHECK(handle.is_valid());\n \n   base::SharedMemoryHandle memory_handle;\n   size_t memory_size = 0;\n  bool read_only_flag = false;\n \n   const MojoResult result = mojo::UnwrapSharedMemoryHandle(\n      std::move(handle), &memory_handle, &memory_size, &read_only_flag);\n   DCHECK_EQ(MOJO_RESULT_OK, result);\n   DCHECK_GT(memory_size, 0u);\n \n   std::unique_ptr<base::SharedMemory> shm(\n       new base::SharedMemory(memory_handle, true /* read_only */));\n   if (!shm->Map(memory_size)) {\n    DLOG(ERROR) << \"OnBufferCreated: Map failed.\";\n    return;\n  }\n  const bool inserted =\n      client_buffers_\n          .insert(std::make_pair(buffer_id,\n                                 new ClientBuffer(std::move(shm), memory_size)))\n          .second;\n  DCHECK(inserted);\n}\n", "target": 1, "idx": 186842}
{"func": "static void vapic_exit(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tint idx;\n\n\tif (!apic || !apic->vapic_addr)\n\t\treturn;\n\n\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\tkvm_release_page_dirty(apic->vapic_page);\n\tmark_page_dirty(vcpu->kvm, apic->vapic_addr >> PAGE_SHIFT);\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n}\n", "target": 0, "idx": 20890}
{"func": "s32 brcmf_vif_set_mgmt_ie(struct brcmf_cfg80211_vif *vif, s32 pktflag,\n\t\t\t  const u8 *vndr_ie_buf, u32 vndr_ie_len)\n{\n\tstruct brcmf_if *ifp;\n\tstruct vif_saved_ie *saved_ie;\n\ts32 err = 0;\n\tu8  *iovar_ie_buf;\n\tu8  *curr_ie_buf;\n\tu8  *mgmt_ie_buf = NULL;\n\tint mgmt_ie_buf_len;\n\tu32 *mgmt_ie_len;\n\tu32 del_add_ie_buf_len = 0;\n\tu32 total_ie_buf_len = 0;\n\tu32 parsed_ie_buf_len = 0;\n\tstruct parsed_vndr_ies old_vndr_ies;\n\tstruct parsed_vndr_ies new_vndr_ies;\n\tstruct parsed_vndr_ie_info *vndrie_info;\n\ts32 i;\n\tu8 *ptr;\n\tint remained_buf_len;\n\n\tif (!vif)\n\t\treturn -ENODEV;\n\tifp = vif->ifp;\n\tsaved_ie = &vif->saved_ie;\n\n\tbrcmf_dbg(TRACE, \"bsscfgidx %d, pktflag : 0x%02X\\n\", ifp->bsscfgidx,\n\t\t  pktflag);\n\tiovar_ie_buf = kzalloc(WL_EXTRA_BUF_MAX, GFP_KERNEL);\n\tif (!iovar_ie_buf)\n\t\treturn -ENOMEM;\n\tcurr_ie_buf = iovar_ie_buf;\n\tswitch (pktflag) {\n\tcase BRCMF_VNDR_IE_PRBREQ_FLAG:\n\t\tmgmt_ie_buf = saved_ie->probe_req_ie;\n\t\tmgmt_ie_len = &saved_ie->probe_req_ie_len;\n\t\tmgmt_ie_buf_len = sizeof(saved_ie->probe_req_ie);\n\t\tbreak;\n\tcase BRCMF_VNDR_IE_PRBRSP_FLAG:\n\t\tmgmt_ie_buf = saved_ie->probe_res_ie;\n\t\tmgmt_ie_len = &saved_ie->probe_res_ie_len;\n\t\tmgmt_ie_buf_len = sizeof(saved_ie->probe_res_ie);\n\t\tbreak;\n\tcase BRCMF_VNDR_IE_BEACON_FLAG:\n\t\tmgmt_ie_buf = saved_ie->beacon_ie;\n\t\tmgmt_ie_len = &saved_ie->beacon_ie_len;\n\t\tmgmt_ie_buf_len = sizeof(saved_ie->beacon_ie);\n\t\tbreak;\n\tcase BRCMF_VNDR_IE_ASSOCREQ_FLAG:\n\t\tmgmt_ie_buf = saved_ie->assoc_req_ie;\n\t\tmgmt_ie_len = &saved_ie->assoc_req_ie_len;\n\t\tmgmt_ie_buf_len = sizeof(saved_ie->assoc_req_ie);\n\t\tbreak;\n\tdefault:\n\t\terr = -EPERM;\n\t\tbrcmf_err(\"not suitable type\\n\");\n\t\tgoto exit;\n\t}\n\n\tif (vndr_ie_len > mgmt_ie_buf_len) {\n\t\terr = -ENOMEM;\n\t\tbrcmf_err(\"extra IE size too big\\n\");\n\t\tgoto exit;\n\t}\n\n\t/* parse and save new vndr_ie in curr_ie_buff before comparing it */\n\tif (vndr_ie_buf && vndr_ie_len && curr_ie_buf) {\n\t\tptr = curr_ie_buf;\n\t\tbrcmf_parse_vndr_ies(vndr_ie_buf, vndr_ie_len, &new_vndr_ies);\n\t\tfor (i = 0; i < new_vndr_ies.count; i++) {\n\t\t\tvndrie_info = &new_vndr_ies.ie_info[i];\n\t\t\tmemcpy(ptr + parsed_ie_buf_len, vndrie_info->ie_ptr,\n\t\t\t       vndrie_info->ie_len);\n\t\t\tparsed_ie_buf_len += vndrie_info->ie_len;\n\t\t}\n\t}\n\n\tif (mgmt_ie_buf && *mgmt_ie_len) {\n\t\tif (parsed_ie_buf_len && (parsed_ie_buf_len == *mgmt_ie_len) &&\n\t\t    (memcmp(mgmt_ie_buf, curr_ie_buf,\n\t\t\t    parsed_ie_buf_len) == 0)) {\n\t\t\tbrcmf_dbg(TRACE, \"Previous mgmt IE equals to current IE\\n\");\n\t\t\tgoto exit;\n\t\t}\n\n\t\t/* parse old vndr_ie */\n\t\tbrcmf_parse_vndr_ies(mgmt_ie_buf, *mgmt_ie_len, &old_vndr_ies);\n\n\t\t/* make a command to delete old ie */\n\t\tfor (i = 0; i < old_vndr_ies.count; i++) {\n\t\t\tvndrie_info = &old_vndr_ies.ie_info[i];\n\n\t\t\tbrcmf_dbg(TRACE, \"DEL ID : %d, Len: %d , OUI:%02x:%02x:%02x\\n\",\n\t\t\t\t  vndrie_info->vndrie.id,\n\t\t\t\t  vndrie_info->vndrie.len,\n\t\t\t\t  vndrie_info->vndrie.oui[0],\n\t\t\t\t  vndrie_info->vndrie.oui[1],\n\t\t\t\t  vndrie_info->vndrie.oui[2]);\n\n\t\t\tdel_add_ie_buf_len = brcmf_vndr_ie(curr_ie_buf, pktflag,\n\t\t\t\t\t\t\t   vndrie_info->ie_ptr,\n\t\t\t\t\t\t\t   vndrie_info->ie_len,\n\t\t\t\t\t\t\t   \"del\");\n\t\t\tcurr_ie_buf += del_add_ie_buf_len;\n\t\t\ttotal_ie_buf_len += del_add_ie_buf_len;\n\t\t}\n\t}\n\n\t*mgmt_ie_len = 0;\n\t/* Add if there is any extra IE */\n\tif (mgmt_ie_buf && parsed_ie_buf_len) {\n\t\tptr = mgmt_ie_buf;\n\n\t\tremained_buf_len = mgmt_ie_buf_len;\n\n\t\t/* make a command to add new ie */\n\t\tfor (i = 0; i < new_vndr_ies.count; i++) {\n\t\t\tvndrie_info = &new_vndr_ies.ie_info[i];\n\n\t\t\t/* verify remained buf size before copy data */\n\t\t\tif (remained_buf_len < (vndrie_info->vndrie.len +\n\t\t\t\t\t\t\tVNDR_IE_VSIE_OFFSET)) {\n\t\t\t\tbrcmf_err(\"no space in mgmt_ie_buf: len left %d\",\n\t\t\t\t\t  remained_buf_len);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tremained_buf_len -= (vndrie_info->ie_len +\n\t\t\t\t\t     VNDR_IE_VSIE_OFFSET);\n\n\t\t\tbrcmf_dbg(TRACE, \"ADDED ID : %d, Len: %d, OUI:%02x:%02x:%02x\\n\",\n\t\t\t\t  vndrie_info->vndrie.id,\n\t\t\t\t  vndrie_info->vndrie.len,\n\t\t\t\t  vndrie_info->vndrie.oui[0],\n\t\t\t\t  vndrie_info->vndrie.oui[1],\n\t\t\t\t  vndrie_info->vndrie.oui[2]);\n\n\t\t\tdel_add_ie_buf_len = brcmf_vndr_ie(curr_ie_buf, pktflag,\n\t\t\t\t\t\t\t   vndrie_info->ie_ptr,\n\t\t\t\t\t\t\t   vndrie_info->ie_len,\n\t\t\t\t\t\t\t   \"add\");\n\n\t\t\t/* save the parsed IE in wl struct */\n\t\t\tmemcpy(ptr + (*mgmt_ie_len), vndrie_info->ie_ptr,\n\t\t\t       vndrie_info->ie_len);\n\t\t\t*mgmt_ie_len += vndrie_info->ie_len;\n\n\t\t\tcurr_ie_buf += del_add_ie_buf_len;\n\t\t\ttotal_ie_buf_len += del_add_ie_buf_len;\n\t\t}\n\t}\n\tif (total_ie_buf_len) {\n\t\terr  = brcmf_fil_bsscfg_data_set(ifp, \"vndr_ie\", iovar_ie_buf,\n\t\t\t\t\t\t total_ie_buf_len);\n\t\tif (err)\n\t\t\tbrcmf_err(\"vndr ie set error : %d\\n\", err);\n\t}\n\nexit:\n\tkfree(iovar_ie_buf);\n\treturn err;\n}\n", "target": 0, "idx": 49133}
{"func": "ForeignSessionHelper::ForeignSessionHelper(Profile* profile)\n    : profile_(profile) {\n  sync_sessions::SessionSyncService* service =\n      SessionSyncServiceFactory::GetInstance()->GetForProfile(profile);\n\n  if (service) {\n    foreign_session_updated_subscription_ =\n        service->SubscribeToForeignSessionsChanged(base::BindRepeating(\n            &ForeignSessionHelper::FireForeignSessionCallback,\n            base::Unretained(this)));\n  }\n}\n", "target": 0, "idx": 141574}
{"func": "error::Error GLES2DecoderPassthroughImpl::DoBindFragmentInputLocationCHROMIUM(\n    GLuint program,\n    GLint location,\n    const char* name) {\n  NOTIMPLEMENTED();\n  return error::kNoError;\n}\n", "target": 0, "idx": 154564}
{"func": " static MagickBooleanType ReadUncompressedRGB(Image *image, DDSInfo *dds_info,\n  ExceptionInfo *exception)\n{\n  PixelPacket\n    *q;\n\n  ssize_t\n    x, y;\n\n  unsigned short\n    color;\n\n  if (dds_info->pixelformat.rgb_bitcount == 8)\n    (void) SetImageType(image,GrayscaleType);\n  else if (dds_info->pixelformat.rgb_bitcount == 16 && !IsBitMask(\n    dds_info->pixelformat,0xf800,0x07e0,0x001f,0x0000))\n    ThrowBinaryException(CorruptImageError,\"ImageTypeNotSupported\",\n      image->filename);\n\n  for (y = 0; y < (ssize_t) dds_info->height; y++)\n  {\n    q = QueueAuthenticPixels(image, 0, y, dds_info->width, 1,exception);\n\n    if (q == (PixelPacket *) NULL)\n      return MagickFalse;\n\n    for (x = 0; x < (ssize_t) dds_info->width; x++)\n    {\n      if (dds_info->pixelformat.rgb_bitcount == 8)\n        SetPixelGray(q,ScaleCharToQuantum(ReadBlobByte(image)));\n      else if (dds_info->pixelformat.rgb_bitcount == 16)\n        {\n           color=ReadBlobShort(image);\n           SetPixelRed(q,ScaleCharToQuantum((unsigned char)\n             (((color >> 11)/31.0)*255)));\n           SetPixelGreen(q,ScaleCharToQuantum((unsigned char)\n             ((((unsigned short)(color << 5) >> 10)/63.0)*255)));\n           SetPixelBlue(q,ScaleCharToQuantum((unsigned char)\n             ((((unsigned short)(color << 11) >> 11)/31.0)*255)));\n        }\n      else\n        {\n          SetPixelBlue(q,ScaleCharToQuantum((unsigned char)\n            ReadBlobByte(image)));\n          SetPixelGreen(q,ScaleCharToQuantum((unsigned char)\n            ReadBlobByte(image)));\n          SetPixelRed(q,ScaleCharToQuantum((unsigned char)\n            ReadBlobByte(image)));\n          if (dds_info->pixelformat.rgb_bitcount == 32)\n            (void) ReadBlobByte(image);\n        }\n      SetPixelAlpha(q,QuantumRange);\n      q++;\n    }\n \n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n       return MagickFalse;\n   }\n \n  SkipRGBMipmaps(image, dds_info, 3);\n  return MagickTrue;\n }\n", "target": 1, "idx": 182074}
{"func": "std::unique_ptr<BlobDataHandle> BlobStorageContext::GetBlobDataFromPublicURL(\n    const GURL& url) {\n  std::string uuid;\n  BlobEntry* entry = registry_.GetEntryFromURL(url, &uuid);\n  if (!entry)\n    return nullptr;\n  return CreateHandle(uuid, entry);\n}\n", "target": 0, "idx": 163099}
{"func": "static void SortByDimension(\n  Rtree *pRtree,\n  int *aIdx,\n  int nIdx,\n  int iDim,\n  RtreeCell *aCell,\n  int *aSpare\n){\n  if( nIdx>1 ){\n\n    int iLeft = 0;\n    int iRight = 0;\n\n    int nLeft = nIdx/2;\n    int nRight = nIdx-nLeft;\n    int *aLeft = aIdx;\n    int *aRight = &aIdx[nLeft];\n\n    SortByDimension(pRtree, aLeft, nLeft, iDim, aCell, aSpare);\n    SortByDimension(pRtree, aRight, nRight, iDim, aCell, aSpare);\n\n    memcpy(aSpare, aLeft, sizeof(int)*nLeft);\n    aLeft = aSpare;\n    while( iLeft<nLeft || iRight<nRight ){\n      RtreeDValue xleft1 = DCOORD(aCell[aLeft[iLeft]].aCoord[iDim*2]);\n      RtreeDValue xleft2 = DCOORD(aCell[aLeft[iLeft]].aCoord[iDim*2+1]);\n      RtreeDValue xright1 = DCOORD(aCell[aRight[iRight]].aCoord[iDim*2]);\n      RtreeDValue xright2 = DCOORD(aCell[aRight[iRight]].aCoord[iDim*2+1]);\n      if( (iLeft!=nLeft) && ((iRight==nRight)\n       || (xleft1<xright1)\n       || (xleft1==xright1 && xleft2<xright2)\n      )){\n        aIdx[iLeft+iRight] = aLeft[iLeft];\n        iLeft++;\n      }else{\n        aIdx[iLeft+iRight] = aRight[iRight];\n        iRight++;\n      }\n    }\n\n#if 0\n    /* Check that the sort worked */\n    {\n      int jj;\n      for(jj=1; jj<nIdx; jj++){\n        RtreeDValue xleft1 = aCell[aIdx[jj-1]].aCoord[iDim*2];\n        RtreeDValue xleft2 = aCell[aIdx[jj-1]].aCoord[iDim*2+1];\n        RtreeDValue xright1 = aCell[aIdx[jj]].aCoord[iDim*2];\n        RtreeDValue xright2 = aCell[aIdx[jj]].aCoord[iDim*2+1];\n        assert( xleft1<=xright1 && (xleft1<xright1 || xleft2<=xright2) );\n      }\n    }\n#endif\n  }\n}\n", "target": 0, "idx": 164441}
{"func": "static void tcp_data_queue_ofo(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct sk_buff *skb1;\n\tu32 seq, end_seq;\n\n\ttcp_ecn_check_ce(tp, skb);\n\n\tif (unlikely(tcp_try_rmem_schedule(sk, skb, skb->truesize))) {\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPOFODROP);\n\t\ttcp_drop(sk, skb);\n\t\treturn;\n\t}\n\n\t/* Disable header prediction. */\n\ttp->pred_flags = 0;\n\tinet_csk_schedule_ack(sk);\n\n\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPOFOQUEUE);\n\tSOCK_DEBUG(sk, \"out of order segment: rcv_next %X seq %X - %X\\n\",\n\t\t   tp->rcv_nxt, TCP_SKB_CB(skb)->seq, TCP_SKB_CB(skb)->end_seq);\n\n\tskb1 = skb_peek_tail(&tp->out_of_order_queue);\n\tif (!skb1) {\n\t\t/* Initial out of order segment, build 1 SACK. */\n\t\tif (tcp_is_sack(tp)) {\n\t\t\ttp->rx_opt.num_sacks = 1;\n\t\t\ttp->selective_acks[0].start_seq = TCP_SKB_CB(skb)->seq;\n\t\t\ttp->selective_acks[0].end_seq =\n\t\t\t\t\t\tTCP_SKB_CB(skb)->end_seq;\n\t\t}\n\t\t__skb_queue_head(&tp->out_of_order_queue, skb);\n\t\tgoto end;\n\t}\n\n\tseq = TCP_SKB_CB(skb)->seq;\n\tend_seq = TCP_SKB_CB(skb)->end_seq;\n\n\tif (seq == TCP_SKB_CB(skb1)->end_seq) {\n\t\tbool fragstolen;\n\n\t\tif (!tcp_try_coalesce(sk, skb1, skb, &fragstolen)) {\n\t\t\t__skb_queue_after(&tp->out_of_order_queue, skb1, skb);\n\t\t} else {\n\t\t\ttcp_grow_window(sk, skb);\n\t\t\tkfree_skb_partial(skb, fragstolen);\n\t\t\tskb = NULL;\n\t\t}\n\n\t\tif (!tp->rx_opt.num_sacks ||\n\t\t    tp->selective_acks[0].end_seq != seq)\n\t\t\tgoto add_sack;\n\n\t\t/* Common case: data arrive in order after hole. */\n\t\ttp->selective_acks[0].end_seq = end_seq;\n\t\tgoto end;\n\t}\n\n\t/* Find place to insert this segment. */\n\twhile (1) {\n\t\tif (!after(TCP_SKB_CB(skb1)->seq, seq))\n\t\t\tbreak;\n\t\tif (skb_queue_is_first(&tp->out_of_order_queue, skb1)) {\n\t\t\tskb1 = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tskb1 = skb_queue_prev(&tp->out_of_order_queue, skb1);\n\t}\n\n\t/* Do skb overlap to previous one? */\n\tif (skb1 && before(seq, TCP_SKB_CB(skb1)->end_seq)) {\n\t\tif (!after(end_seq, TCP_SKB_CB(skb1)->end_seq)) {\n\t\t\t/* All the bits are present. Drop. */\n\t\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPOFOMERGE);\n\t\t\ttcp_drop(sk, skb);\n\t\t\tskb = NULL;\n\t\t\ttcp_dsack_set(sk, seq, end_seq);\n\t\t\tgoto add_sack;\n\t\t}\n\t\tif (after(seq, TCP_SKB_CB(skb1)->seq)) {\n\t\t\t/* Partial overlap. */\n\t\t\ttcp_dsack_set(sk, seq,\n\t\t\t\t      TCP_SKB_CB(skb1)->end_seq);\n\t\t} else {\n\t\t\tif (skb_queue_is_first(&tp->out_of_order_queue,\n\t\t\t\t\t       skb1))\n\t\t\t\tskb1 = NULL;\n\t\t\telse\n\t\t\t\tskb1 = skb_queue_prev(\n\t\t\t\t\t&tp->out_of_order_queue,\n\t\t\t\t\tskb1);\n\t\t}\n\t}\n\tif (!skb1)\n\t\t__skb_queue_head(&tp->out_of_order_queue, skb);\n\telse\n\t\t__skb_queue_after(&tp->out_of_order_queue, skb1, skb);\n\n\t/* And clean segments covered by new one as whole. */\n\twhile (!skb_queue_is_last(&tp->out_of_order_queue, skb)) {\n\t\tskb1 = skb_queue_next(&tp->out_of_order_queue, skb);\n\n\t\tif (!after(end_seq, TCP_SKB_CB(skb1)->seq))\n\t\t\tbreak;\n\t\tif (before(end_seq, TCP_SKB_CB(skb1)->end_seq)) {\n\t\t\ttcp_dsack_extend(sk, TCP_SKB_CB(skb1)->seq,\n\t\t\t\t\t end_seq);\n\t\t\tbreak;\n\t\t}\n\t\t__skb_unlink(skb1, &tp->out_of_order_queue);\n\t\ttcp_dsack_extend(sk, TCP_SKB_CB(skb1)->seq,\n\t\t\t\t TCP_SKB_CB(skb1)->end_seq);\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPOFOMERGE);\n\t\ttcp_drop(sk, skb1);\n\t}\n\nadd_sack:\n\tif (tcp_is_sack(tp))\n\t\ttcp_sack_new_ofo_skb(sk, seq, end_seq);\nend:\n\tif (skb) {\n\t\ttcp_grow_window(sk, skb);\n\t\tskb_set_owner_r(skb, sk);\n\t}\n}\n", "target": 0, "idx": 51533}
{"func": "void StoreAccumulatedContentLength(int received_content_length,\n                                   int original_content_length,\n                                   bool data_reduction_proxy_was_used) {\n   BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,\n       base::Bind(&UpdateContentLengthPrefs,\n                  received_content_length, original_content_length,\n                 data_reduction_proxy_was_used));\n }\n", "target": 1, "idx": 185031}
{"func": "static MagickStatusType ReadPSDChannel(Image *image,const PSDInfo *psd_info,\n  const LayerInfo* layer_info,const size_t channel,\n  const PSDCompressionType compression,ExceptionInfo *exception)\n{\n  MagickOffsetType\n    offset;\n\n  MagickStatusType\n    status;\n\n  if (layer_info->channel_info[channel].type < -1)\n  {\n    /* ignore user supplied layer mask */\n    SeekBlob(image,layer_info->channel_info[channel].size-2,SEEK_CUR);\n    return(MagickTrue);\n  }\n\n  offset=TellBlob(image);\n  status=MagickTrue;\n  switch(compression)\n  {\n    case Raw:\n      return(ReadPSDChannelRaw(image,psd_info->channels,\n        layer_info->channel_info[channel].type,exception));\n    case RLE:\n      {\n        MagickOffsetType\n          *offsets;\n\n        offsets=ReadPSDRLEOffsets(image,psd_info,image->rows);\n        if (offsets == (MagickOffsetType *) NULL)\n          ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n            image->filename);\n        status=ReadPSDChannelRLE(image,psd_info,\n                 layer_info->channel_info[channel].type,offsets,exception);\n        offsets=(MagickOffsetType *) RelinquishMagickMemory(offsets);\n      }\n      break;\n    case ZipWithPrediction:\n    case ZipWithoutPrediction:\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n      status=ReadPSDChannelZip(image,layer_info->channels,\n        layer_info->channel_info[channel].type,compression,\n        layer_info->channel_info[channel].size-2,exception);\n#else\n      SeekBlob(image,offset+layer_info->channel_info[channel].size-2,SEEK_SET);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n          MissingDelegateWarning,\"DelegateLibrarySupportNotBuiltIn\",\n            \"'%s' (ZLIB)\",image->filename);\n#endif\n      break;\n    default:\n      SeekBlob(image,offset+layer_info->channel_info[channel].size-2,SEEK_SET);\n      (void) ThrowMagickException(exception,GetMagickModule(),TypeWarning,\n        \"CompressionNotSupported\",\"'%.20g'\",(double) compression);\n      break;\n  }\n\n  if (status == MagickFalse)\n    SeekBlob(image,offset+layer_info->channel_info[channel].size-2,SEEK_SET);\n\n  return(status);\n}\n", "target": 0, "idx": 71652}
{"func": "void WorkerThread::shutdown()\n{\n    ASSERT(isCurrentThread());\n    {\n        MutexLocker lock(m_threadStateMutex);\n        ASSERT(!m_shutdown);\n        m_shutdown = true;\n    }\n\n    PlatformThreadData::current().threadTimers().setSharedTimer(nullptr);\n    workerGlobalScope()->dispose();\n    willDestroyIsolate();\n\n    workerReportingProxy().willDestroyWorkerGlobalScope();\n\n#if !ENABLE(OILPAN)\n    ASSERT(m_workerGlobalScope->hasOneRef());\n#endif\n    m_workerGlobalScope->notifyContextDestroyed();\n    m_workerGlobalScope = nullptr;\n\n    backingThread().removeTaskObserver(m_microtaskRunner.get());\n    backingThread().shutdown();\n    destroyIsolate();\n\n    m_microtaskRunner = nullptr;\n\n    workerReportingProxy().workerThreadTerminated();\n\n    m_terminationEvent->signal();\n\n    PlatformThreadData::current().destroy();\n}\n", "target": 0, "idx": 138517}
{"func": " static void fpm_child_init(struct fpm_worker_pool_s *wp) /* {{{ */\n {\n \tfpm_globals.max_requests = wp->config->pm_max_requests;\n \n \tif (0 > fpm_stdio_init_child(wp)  ||\n \t    0 > fpm_log_init_child(wp)    ||\n\t    0 > fpm_status_init_child(wp) ||\n\t    0 > fpm_unix_init_child(wp)   ||\n\t    0 > fpm_signals_init_child()  ||\n\t    0 > fpm_env_init_child(wp)    ||\n\t    0 > fpm_php_init_child(wp)) {\n\n\t\tzlog(ZLOG_ERROR, \"[pool %s] child failed to initialize\", wp->config->name);\n\t\texit(FPM_EXIT_SOFTWARE);\n\t}\n}\n/* }}} */\n", "target": 1, "idx": 182623}
{"func": "static int r_bin_mdmp_init(struct r_bin_mdmp_obj *obj) {\n\tr_bin_mdmp_init_parsing (obj);\n\n\tif (!r_bin_mdmp_init_hdr (obj)) {\n\t\teprintf (\"[ERROR] Failed to initialise header\\n\");\n\t\treturn false;\n\t}\n\n\tif (!r_bin_mdmp_init_directory (obj)) {\n\t\teprintf (\"[ERROR] Failed to initialise directory structures!\\n\");\n\t\treturn false;\n\t}\n\n\tif (!r_bin_mdmp_init_pe_bins (obj)) {\n\t\teprintf (\"[ERROR] Failed to initialise pe binaries!\\n\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n", "target": 0, "idx": 79707}
{"func": " void ImageBitmapFactories::ImageBitmapLoader::Trace(blink::Visitor* visitor) {\n   visitor->Trace(factory_);\n   visitor->Trace(resolver_);\n   visitor->Trace(options_);\n}\n", "target": 1, "idx": 187055}
{"func": "static int writeWepKeyRid(struct airo_info *ai, WepKeyRid *wkr, int perm, int lock)\n{\n\tint rc;\n\trc = PC4500_writerid(ai, RID_WEP_TEMP, wkr, sizeof(*wkr), lock);\n\tif (rc!=SUCCESS)\n\t\tairo_print_err(ai->dev->name, \"WEP_TEMP set %x\", rc);\n\tif (perm) {\n\t\trc = PC4500_writerid(ai, RID_WEP_PERM, wkr, sizeof(*wkr), lock);\n\t\tif (rc!=SUCCESS)\n\t\t\tairo_print_err(ai->dev->name, \"WEP_PERM set %x\", rc);\n\t}\n\treturn rc;\n}\n", "target": 0, "idx": 24094}
{"func": "R_API void r_core_cmd_init(RCore *core) {\n\tstruct {\n\t\tconst char *cmd;\n\t\tconst char *description;\n\t\tr_cmd_callback (cb);\n\t\tvoid (*descriptor_init)(RCore *core);\n\t} cmds[] = {\n\t\t{\"!\",        \"run system command\", cmd_system},\n\t\t{\"_\",        \"print last output\", cmd_last},\n\t\t{\"#\",        \"calculate hash\", cmd_hash},\n\t\t{\"$\",        \"alias\", cmd_alias},\n\t\t{\"%\",        \"short version of 'env' command\", cmd_env},\n\t\t{\"&\",        \"tasks\", cmd_tasks},\n\t\t{\"(\",        \"macro\", cmd_macro, cmd_macro_init},\n\t\t{\"*\",        \"pointer read/write\", cmd_pointer},\n\t\t{\"-\",        \"open cfg.editor and run script\", cmd_stdin},\n\t\t{\".\",        \"interpret\", cmd_interpret},\n\t\t{\"/\",        \"search kw, pattern aes\", cmd_search, cmd_search_init},\n\t\t{\"=\",        \"io pipe\", cmd_rap},\n\t\t{\"?\",        \"help message\", cmd_help, cmd_help_init},\n\t\t{\"\\\\\",       \"alias for =!\", cmd_rap_run},\n\t\t{\"'\",        \"alias for =!\", cmd_rap_run},\n\t\t{\"0x\",       \"alias for s 0x\", cmd_ox},\n\t\t{\"analysis\", \"analysis\", cmd_anal, cmd_anal_init},\n\t\t{\"bsize\",    \"change block size\", cmd_bsize},\n\t\t{\"cmp\",      \"compare memory\", cmd_cmp, cmd_cmp_init},\n\t\t{\"Code\",     \"code metadata\", cmd_meta, cmd_meta_init},\n\t\t{\"debug\",    \"debugger operations\", cmd_debug, cmd_debug_init},\n\t\t{\"eval\",     \"evaluate configuration variable\", cmd_eval, cmd_eval_init},\n\t\t{\"flag\",     \"get/set flags\", cmd_flag, cmd_flag_init},\n\t\t{\"g\",        \"egg manipulation\", cmd_egg, cmd_egg_init},\n\t\t{\"info\",     \"get file info\", cmd_info, cmd_info_init},\n\t\t{\"kuery\",    \"perform sdb query\", cmd_kuery},\n\t\t{\"l\",       \"list files and directories\", cmd_ls},\n\t\t{\"join\",    \"join the contents of the two files\", cmd_join},\n\t\t{\"head\",    \"show the top n number of line in file\", cmd_head},\n\t\t{\"L\",        \"manage dynamically loaded plugins\", cmd_plugins},\n\t\t{\"mount\",    \"mount filesystem\", cmd_mount, cmd_mount_init},\n\t\t{\"open\",     \"open or map file\", cmd_open, cmd_open_init},\n\t\t{\"print\",    \"print current block\", cmd_print, cmd_print_init},\n\t\t{\"Project\",  \"project\", cmd_project, cmd_project_init},\n\t\t{\"quit\",     \"exit program session\", cmd_quit, cmd_quit_init},\n\t\t{\"Q\",        \"alias for q!\", cmd_Quit},\n\t\t{\":\",        \"long commands starting with :\", cmd_colon},\n\t\t{\"resize\",   \"change file size\", cmd_resize},\n\t\t{\"seek\",     \"seek to an offset\", cmd_seek, cmd_seek_init},\n\t\t{\"t\",        \"type information (cparse)\", cmd_type, cmd_type_init},\n\t\t{\"Text\",     \"Text log utility\", cmd_log, cmd_log_init},\n\t\t{\"u\",        \"uname/undo\", cmd_uname},\n\t\t{\"<\",        \"pipe into RCons.readChar\", cmd_pipein},\n\t\t{\"Visual\",   \"enter visual mode\", cmd_visual},\n\t\t{\"visualPanels\",   \"enter visual mode\", cmd_panels},\n\t\t{\"write\",    \"write bytes\", cmd_write, cmd_write_init},\n\t\t{\"x\",        \"alias for px\", cmd_hexdump},\n\t\t{\"yank\",     \"yank bytes\", cmd_yank},\n\t\t{\"zign\",     \"zignatures\", cmd_zign, cmd_zign_init},\n\t};\n\n\tcore->rcmd = r_cmd_new ();\n\tcore->rcmd->macro.user = core;\n\tcore->rcmd->macro.num = core->num;\n\tcore->rcmd->macro.cmd = core_cmd0_wrapper;\n\tcore->rcmd->nullcallback = r_core_cmd_nullcallback;\n\tcore->rcmd->macro.cb_printf = (PrintfCallback)r_cons_printf;\n\tr_cmd_set_data (core->rcmd, core);\n\tcore->cmd_descriptors = r_list_newf (free);\n\tint i;\n\tfor (i = 0; i < R_ARRAY_SIZE (cmds); i++) {\n\t\tr_cmd_add (core->rcmd, cmds[i].cmd, cmds[i].description, cmds[i].cb);\n\t\tif (cmds[i].descriptor_init) {\n\t\t\tcmds[i].descriptor_init (core);\n\t\t}\n\t}\n\tDEFINE_CMD_DESCRIPTOR_SPECIAL (core, $, dollar);\n\tDEFINE_CMD_DESCRIPTOR_SPECIAL (core, %, percent);\n\tDEFINE_CMD_DESCRIPTOR_SPECIAL (core, *, star);\n\tDEFINE_CMD_DESCRIPTOR_SPECIAL (core, ., dot);\n\tDEFINE_CMD_DESCRIPTOR_SPECIAL (core, =, equal);\n\tDEFINE_CMD_DESCRIPTOR (core, b);\n\tDEFINE_CMD_DESCRIPTOR (core, k);\n\tDEFINE_CMD_DESCRIPTOR (core, r);\n\tDEFINE_CMD_DESCRIPTOR (core, u);\n\tDEFINE_CMD_DESCRIPTOR (core, y);\n\tcmd_descriptor_init (core);\n}\n", "target": 0, "idx": 87816}
{"func": "void ResourceMessageFilter::OnClipboardIsFormatAvailable(\n    Clipboard::FormatType format, Clipboard::Buffer buffer,\n    IPC::Message* reply) {\n  const bool result = GetClipboard()->IsFormatAvailable(format, buffer);\n  ViewHostMsg_ClipboardIsFormatAvailable::WriteReplyParams(reply, result);\n  Send(reply);\n}\n", "target": 0, "idx": 99276}
{"func": "WORD32 ih264d_cavlc_4x4res_block_totalcoeff_2to10(UWORD32 u4_isdc,\n                                               UWORD32 u4_total_coeff_trail_one, /*!<TotalCoefficients<<16+trailingones*/\n dec_bit_stream_t *ps_bitstrm)\n{\n    UWORD32 u4_total_zeroes;\n    WORD32 i;\n    UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;\n\n     UWORD32 u4_bitstream_offset = ps_bitstrm->u4_ofst;\n     UWORD32 u4_trailing_ones = u4_total_coeff_trail_one & 0xFFFF;\n     UWORD32 u4_total_coeff = u4_total_coeff_trail_one >> 16;\n    WORD16 i2_level_arr[16];\n \n     tu_sblk4x4_coeff_data_t *ps_tu_4x4;\n     WORD16 *pi2_coeff_data;\n dec_struct_t *ps_dec = (dec_struct_t *)ps_bitstrm->pv_codec_handle;\n\n    ps_tu_4x4 = (tu_sblk4x4_coeff_data_t *)ps_dec->pv_parse_tu_coeff_data;\n    ps_tu_4x4->u2_sig_coeff_map = 0;\n    pi2_coeff_data = &ps_tu_4x4->ai2_level[0];\n\n    i = u4_total_coeff - 1;\n\n if(u4_trailing_ones)\n {\n /*********************************************************************/\n /* Decode Trailing Ones                                              */\n /* read the sign of T1's and put them in level array                 */\n /*********************************************************************/\n        UWORD32 u4_signs, u4_cnt = u4_trailing_ones;\n        WORD16 (*ppi2_trlone_lkup)[3] =\n (WORD16 (*)[3])gai2_ih264d_trailing_one_level;\n        WORD16 *pi2_trlone_lkup;\n\n        GETBITS(u4_signs, u4_bitstream_offset, pu4_bitstrm_buf, u4_cnt);\n\n        pi2_trlone_lkup = ppi2_trlone_lkup[(1 << u4_cnt) - 2 + u4_signs];\n\n while(u4_cnt--)\n            i2_level_arr[i--] = *pi2_trlone_lkup++;\n }\n\n /****************************************************************/\n /* Decoding Levels Begins                                       */\n /****************************************************************/\n if(i >= 0)\n {\n /****************************************************************/\n /* First level is decoded outside the loop as it has lot of     */\n /* special cases.                                               */\n /****************************************************************/\n        UWORD32 u4_lev_suffix, u4_suffix_len, u4_lev_suffix_size;\n        WORD32 u2_lev_code, u2_abs_value;\n        UWORD32 u4_lev_prefix;\n\n /***************************************************************/\n /* u4_suffix_len = 0,  Find leading zeros in next 32 bits      */\n /***************************************************************/\n        FIND_ONE_IN_STREAM_32(u4_lev_prefix, u4_bitstream_offset,\n                              pu4_bitstrm_buf);\n\n /*********************************************************/\n /* Special decoding case when trailing ones are 3        */\n /*********************************************************/\n        u2_lev_code = MIN(15, u4_lev_prefix);\n\n        u2_lev_code += (3 == u4_trailing_ones) ? 0 : 2;\n\n if(14 == u4_lev_prefix)\n            u4_lev_suffix_size = 4;\n else if(15 <= u4_lev_prefix)\n {\n            u2_lev_code += 15;\n            u4_lev_suffix_size = u4_lev_prefix - 3;\n }\n else\n            u4_lev_suffix_size = 0;\n\n if(16 <= u4_lev_prefix)\n {\n            u2_lev_code += ((1 << (u4_lev_prefix - 3)) - 4096);\n }\n if(u4_lev_suffix_size)\n {\n            GETBITS(u4_lev_suffix, u4_bitstream_offset, pu4_bitstrm_buf,\n                    u4_lev_suffix_size);\n            u2_lev_code += u4_lev_suffix;\n }\n\n        u2_abs_value = (u2_lev_code + 2) >> 1;\n /*********************************************************/\n /* If Level code is odd, level is negative else positive */\n /*********************************************************/\n        i2_level_arr[i--] = (u2_lev_code & 1) ? -u2_abs_value : u2_abs_value;\n\n        u4_suffix_len = (u2_abs_value > 3) ? 2 : 1;\n\n /*********************************************************/\n /* Now loop over the remaining levels                    */\n /*********************************************************/\n while(i >= 0)\n {\n\n /***************************************************************/\n /* Find leading zeros in next 32 bits                          */\n /***************************************************************/\n            FIND_ONE_IN_STREAM_32(u4_lev_prefix, u4_bitstream_offset,\n                                  pu4_bitstrm_buf);\n\n            u4_lev_suffix_size =\n (15 <= u4_lev_prefix) ?\n (u4_lev_prefix - 3) : u4_suffix_len;\n\n /*********************************************************/\n /* Compute level code using prefix and suffix            */\n /*********************************************************/\n            GETBITS(u4_lev_suffix, u4_bitstream_offset, pu4_bitstrm_buf,\n                    u4_lev_suffix_size);\n            u2_lev_code = (MIN(15,u4_lev_prefix) << u4_suffix_len)\n + u4_lev_suffix;\n\n if(16 <= u4_lev_prefix)\n {\n                u2_lev_code += ((1 << (u4_lev_prefix - 3)) - 4096);\n }\n            u2_abs_value = (u2_lev_code + 2) >> 1;\n\n /*********************************************************/\n /* If Level code is odd, level is negative else positive */\n /*********************************************************/\n            i2_level_arr[i--] =\n (u2_lev_code & 1) ? -u2_abs_value : u2_abs_value;\n\n /*********************************************************/\n /* Increment suffix length if required                   */\n /*********************************************************/\n            u4_suffix_len +=\n (u4_suffix_len < 6) ?\n (u2_abs_value\n > (3\n << (u4_suffix_len\n - 1))) :\n 0;\n }\n\n /****************************************************************/\n /* Decoding Levels Ends                                         */\n /****************************************************************/\n }\n\n /****************************************************************/\n /* Decoding total zeros as in section 9.2.3, table 9.7          */\n /****************************************************************/\n {\n        UWORD32 u4_index;\n const UWORD8 (*ppu1_total_zero_lkup)[64] =\n (const UWORD8 (*)[64])gau1_ih264d_table_total_zero_2to10;\n\n        NEXTBITS(u4_index, u4_bitstream_offset, pu4_bitstrm_buf, 6);\n        u4_total_zeroes = ppu1_total_zero_lkup[u4_total_coeff - 2][u4_index];\n\n        FLUSHBITS(u4_bitstream_offset, (u4_total_zeroes >> 4));\n        u4_total_zeroes &= 0xf;\n }\n\n /**************************************************************/\n /* Decode the runs and form the coefficient buffer            */\n /**************************************************************/\n {\n const UWORD8 *pu1_table_runbefore;\n        UWORD32 u4_run;\n        WORD32 k;\n        UWORD32 u4_scan_pos = u4_total_coeff + u4_total_zeroes - 1 + u4_isdc;\n        WORD32 u4_zeroes_left = u4_total_zeroes;\n        k = u4_total_coeff - 1;\n\n /**************************************************************/\n /* Decoding Runs Begin for zeros left > 6                     */\n /**************************************************************/\n while((u4_zeroes_left > 6) && k)\n {\n            UWORD32 u4_code;\n\n            NEXTBITS(u4_code, u4_bitstream_offset, pu4_bitstrm_buf, 3);\n\n if(u4_code != 0)\n {\n                FLUSHBITS(u4_bitstream_offset, 3);\n                u4_run = (7 - u4_code);\n }\n else\n {\n\n                FIND_ONE_IN_STREAM_LEN(u4_code, u4_bitstream_offset,\n                                       pu4_bitstrm_buf, 11);\n                u4_run = (4 + u4_code);\n }\n\n            SET_BIT(ps_tu_4x4->u2_sig_coeff_map, u4_scan_pos);\n *pi2_coeff_data++ = i2_level_arr[k--];\n            u4_zeroes_left -= u4_run;\n            u4_scan_pos -= (u4_run + 1);\n }\n\n /**************************************************************/\n /* Decoding Runs for 0 < zeros left <=6                       */\n /**************************************************************/\n        pu1_table_runbefore = (UWORD8 *)gau1_ih264d_table_run_before;\n while((u4_zeroes_left > 0) && k)\n {\n            UWORD32 u4_code;\n            NEXTBITS(u4_code, u4_bitstream_offset, pu4_bitstrm_buf, 3);\n\n            u4_code = pu1_table_runbefore[u4_code + (u4_zeroes_left << 3)];\n            u4_run = u4_code >> 2;\n\n            FLUSHBITS(u4_bitstream_offset, (u4_code & 0x03));\n\n            SET_BIT(ps_tu_4x4->u2_sig_coeff_map, u4_scan_pos);\n *pi2_coeff_data++ = i2_level_arr[k--];\n            u4_zeroes_left -= u4_run;\n            u4_scan_pos -= (u4_run + 1);\n }\n /**************************************************************/\n /* Decoding Runs End                                          */\n /**************************************************************/\n\n /**************************************************************/\n /* Copy the remaining coefficients                            */\n /**************************************************************/\n if(u4_zeroes_left < 0)\n return -1;\n while(k >= 0)\n {\n\n            SET_BIT(ps_tu_4x4->u2_sig_coeff_map, u4_scan_pos);\n *pi2_coeff_data++ = i2_level_arr[k--];\n            u4_scan_pos--;\n }\n }\n\n {\n        WORD32 offset;\n        offset = (UWORD8 *)pi2_coeff_data - (UWORD8 *)ps_tu_4x4;\n        offset = ALIGN4(offset);\n        ps_dec->pv_parse_tu_coeff_data = (void *)((UWORD8 *)ps_dec->pv_parse_tu_coeff_data + offset);\n }\n\n    ps_bitstrm->u4_ofst = u4_bitstream_offset;\n return 0;\n}\n", "target": 1, "idx": 187936}
{"func": "void impeg2d_dec_hdr(void *pv_dec,impeg2d_video_decode_ip_t *ps_ip,\n impeg2d_video_decode_op_t *ps_op)\n{\n\n    UWORD32 u4_bits_read;\n dec_state_t *ps_dec;\n    UWORD32 u4_size = ps_ip->s_ivd_video_decode_ip_t.u4_num_Bytes;\n\n    ps_dec = (dec_state_t *)pv_dec;\n    ps_op->s_ivd_video_decode_op_t.u4_error_code = 0;\n if (u4_size > MAX_BITSTREAM_BUFFER_SIZE)\n {\n        u4_size = MAX_BITSTREAM_BUFFER_SIZE;\n }\n\n    memcpy(ps_dec->pu1_input_buffer, ps_ip->s_ivd_video_decode_ip_t.pv_stream_buffer, u4_size);\n\n    impeg2d_bit_stream_init(&(ps_dec->s_bit_stream), ps_dec->pu1_input_buffer,\n        u4_size);\n\n {\n {\n            IMPEG2D_ERROR_CODES_T e_error;\n            e_error = impeg2d_process_video_header(ps_dec);\n if ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE != e_error)\n {\n                ps_op->s_ivd_video_decode_op_t.u4_error_code    = e_error;\n\n                u4_bits_read     = impeg2d_bit_stream_num_bits_read(&ps_dec->s_bit_stream);\n\n                ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed = u4_bits_read>> 3;\n if(ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed > ps_ip->s_ivd_video_decode_ip_t.u4_num_Bytes)\n {\n                    ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed = ps_ip->s_ivd_video_decode_ip_t.u4_num_Bytes;\n }\n if(ps_op->s_ivd_video_decode_op_t.u4_error_code == 0)\n                    ps_op->s_ivd_video_decode_op_t.u4_error_code = e_error;\n\n if (IMPEG2D_UNSUPPORTED_DIMENSIONS == e_error)\n {\n                    ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed = 0;\n                    ps_dec->u2_header_done = 0;\n\n                    ps_op->s_ivd_video_decode_op_t.u4_pic_ht = ps_dec->u2_reinit_max_height;\n                    ps_op->s_ivd_video_decode_op_t.u4_pic_wd = ps_dec->u2_reinit_max_width;\n }\n                impeg2d_next_code(ps_dec, SEQUENCE_HEADER_CODE);\n return;\n }\n }\n        ps_op->s_ivd_video_decode_op_t.u4_pic_ht = ps_dec->u2_vertical_size;\n        ps_op->s_ivd_video_decode_op_t.u4_pic_wd = ps_dec->u2_horizontal_size;\n\n        ps_op->s_ivd_video_decode_op_t.e_pic_type            = IV_NA_FRAME;\n        ps_op->s_ivd_video_decode_op_t.u4_error_code        = IV_SUCCESS;\n\n        u4_bits_read     = impeg2d_bit_stream_num_bits_read(&ps_dec->s_bit_stream);\n        ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed = u4_bits_read>> 3;\n if(ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed > ps_ip->s_ivd_video_decode_ip_t.u4_num_Bytes)\n {\n\n             ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed = ps_ip->s_ivd_video_decode_ip_t.u4_num_Bytes;\n         }\n         ps_op->s_ivd_video_decode_op_t.u4_frame_decoded_flag = 0;\n         /* MOD */\n         ps_dec->u2_header_done = 1;\n \n }\n}\n", "target": 1, "idx": 188108}
{"func": "  virtual void SetUpCommandLine(CommandLine* command_line) {\n    GpuFeatureTest::SetUpCommandLine(command_line);\n    command_line->AppendSwitch(switches::kDisableExperimentalWebGL);\n  }\n", "target": 0, "idx": 114726}
{"func": "status_t IPCThreadState::requestDeathNotification(int32_t handle, BpBinder* proxy)\n{\n    mOut.writeInt32(BC_REQUEST_DEATH_NOTIFICATION);\n    mOut.writeInt32((int32_t)handle);\n    mOut.writePointer((uintptr_t)proxy);\n return NO_ERROR;\n}\n", "target": 0, "idx": 174330}
{"func": " virtual void ResetModel() {\n    last_pts_ = 0;\n    bits_in_buffer_model_ = cfg_.rc_target_bitrate * cfg_.rc_buf_initial_sz;\n    frame_number_ = 0;\n\n     tot_frame_number_ = 0;\n     first_drop_ = 0;\n     num_drops_ = 0;\n     for (int i = 0; i < 3; ++i) {\n       bits_total_[i] = 0;\n     }\n   }\n", "target": 1, "idx": 188540}
{"func": "BGD_DECLARE(gdImagePtr) gdImageCropThreshold(gdImagePtr im, const unsigned int color, const float threshold)\n{\n\tconst int width = gdImageSX(im);\n\tconst int height = gdImageSY(im);\n\n\tint x,y;\n\tint match;\n\tgdRect crop;\n\n\tcrop.x = 0;\n\tcrop.y = 0;\n\tcrop.width = 0;\n\tcrop.height = 0;\n\n\t/* Pierre: crop everything sounds bad */\n\tif (threshold > 100.0) {\n \t\treturn NULL;\n \t}\n \n \t/* TODO: Add gdImageGetRowPtr and works with ptr at the row level\n \t * for the true color and palette images\n \t * new formats will simply work with ptr\n\t */\n\tmatch = 1;\n\tfor (y = 0; match && y < height; y++) {\n\t\tfor (x = 0; match && x < width; x++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\n\t/* Pierre\n\t * Nothing to do > bye\n\t * Duplicate the image?\n\t */\n\tif (y == height - 1) {\n\t\treturn NULL;\n\t}\n\n\tcrop.y = y -1;\n\tmatch = 1;\n\tfor (y = height - 1; match && y >= 0; y--) {\n\t\tfor (x = 0; match && x < width; x++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x, y), threshold)) > 0;\n\t\t}\n\t}\n\n\tif (y == 0) {\n\t\tcrop.height = height - crop.y + 1;\n\t} else {\n\t\tcrop.height = y - crop.y + 2;\n\t}\n\n\tmatch = 1;\n\tfor (x = 0; match && x < width; x++) {\n\t\tfor (y = 0; match && y < crop.y + crop.height - 1; y++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\tcrop.x = x - 1;\n\n\tmatch = 1;\n\tfor (x = width - 1; match && x >= 0; x--) {\n\t\tfor (y = 0; match &&  y < crop.y + crop.height - 1; y++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\tcrop.width = x - crop.x + 2;\n\n\treturn gdImageCrop(im, &crop);\n}\n", "target": 1, "idx": 183116}
{"func": "WebPreferences RenderViewHostDelegateHelper::GetWebkitPrefs(\n    PrefService* prefs, bool is_dom_ui) {\n\n  WebPreferences web_prefs;\n\n  web_prefs.fixed_font_family =\n      prefs->GetString(prefs::kWebKitFixedFontFamily);\n  web_prefs.serif_font_family =\n      prefs->GetString(prefs::kWebKitSerifFontFamily);\n  web_prefs.sans_serif_font_family =\n      prefs->GetString(prefs::kWebKitSansSerifFontFamily);\n  if (prefs->GetBoolean(prefs::kWebKitStandardFontIsSerif))\n    web_prefs.standard_font_family = web_prefs.serif_font_family;\n  else\n    web_prefs.standard_font_family = web_prefs.sans_serif_font_family;\n  web_prefs.cursive_font_family =\n      prefs->GetString(prefs::kWebKitCursiveFontFamily);\n  web_prefs.fantasy_font_family =\n      prefs->GetString(prefs::kWebKitFantasyFontFamily);\n\n  web_prefs.default_font_size =\n      prefs->GetInteger(prefs::kWebKitDefaultFontSize);\n  web_prefs.default_fixed_font_size =\n      prefs->GetInteger(prefs::kWebKitDefaultFixedFontSize);\n  web_prefs.minimum_font_size =\n      prefs->GetInteger(prefs::kWebKitMinimumFontSize);\n  web_prefs.minimum_logical_font_size =\n      prefs->GetInteger(prefs::kWebKitMinimumLogicalFontSize);\n\n  web_prefs.default_encoding =\n      WideToASCII(prefs->GetString(prefs::kDefaultCharset));\n\n  web_prefs.javascript_can_open_windows_automatically =\n      prefs->GetBoolean(prefs::kWebKitJavascriptCanOpenWindowsAutomatically);\n  web_prefs.dom_paste_enabled =\n      prefs->GetBoolean(prefs::kWebKitDomPasteEnabled);\n  web_prefs.shrinks_standalone_images_to_fit =\n      prefs->GetBoolean(prefs::kWebKitShrinksStandaloneImagesToFit);\n  web_prefs.inspector_settings = WideToUTF8(\n      prefs->GetString(prefs::kWebKitInspectorSettings));\n\n  {  // Command line switches are used for preferences with no user interface.\n    const CommandLine& command_line = *CommandLine::ForCurrentProcess();\n    web_prefs.developer_extras_enabled =\n        !command_line.HasSwitch(switches::kDisableDevTools);\n    web_prefs.javascript_enabled =\n        !command_line.HasSwitch(switches::kDisableJavaScript) &&\n        prefs->GetBoolean(prefs::kWebKitJavascriptEnabled);\n    web_prefs.web_security_enabled =\n        !command_line.HasSwitch(switches::kDisableWebSecurity) &&\n        prefs->GetBoolean(prefs::kWebKitWebSecurityEnabled);\n    web_prefs.plugins_enabled =\n        !command_line.HasSwitch(switches::kDisablePlugins) &&\n        prefs->GetBoolean(prefs::kWebKitPluginsEnabled);\n    web_prefs.java_enabled =\n        !command_line.HasSwitch(switches::kDisableJava) &&\n        prefs->GetBoolean(prefs::kWebKitJavaEnabled);\n    web_prefs.loads_images_automatically =\n        !command_line.HasSwitch(switches::kDisableImages) &&\n        prefs->GetBoolean(prefs::kWebKitLoadsImagesAutomatically);\n    web_prefs.uses_page_cache =\n        command_line.HasSwitch(switches::kEnableFastback);\n    web_prefs.remote_fonts_enabled =\n        command_line.HasSwitch(switches::kEnableRemoteFonts);\n    web_prefs.xss_auditor_enabled =\n        !command_line.HasSwitch(switches::kDisableXSSAuditor);\n    web_prefs.application_cache_enabled =\n        command_line.HasSwitch(switches::kEnableApplicationCache);\n\n    web_prefs.local_storage_enabled =\n      command_line.HasSwitch(switches::kEnableLocalStorage);\n    web_prefs.databases_enabled =\n      command_line.HasSwitch(switches::kEnableDatabases);\n    web_prefs.session_storage_enabled =\n       command_line.HasSwitch(switches::kEnableSessionStorage);\n     web_prefs.experimental_webgl_enabled =\n       command_line.HasSwitch(switches::kEnableExperimentalWebGL);\n    web_prefs.experimental_notifications_enabled =\n      command_line.HasSwitch(switches::kEnableDesktopNotifications);\n   }\n \n   web_prefs.uses_universal_detector =\n      prefs->GetBoolean(prefs::kWebKitUsesUniversalDetector);\n  web_prefs.text_areas_are_resizable =\n      prefs->GetBoolean(prefs::kWebKitTextAreasAreResizable);\n\n\n  web_prefs.default_encoding =\n      CharacterEncoding::GetCanonicalEncodingNameByAliasName(\n          web_prefs.default_encoding);\n  if (web_prefs.default_encoding.empty()) {\n    prefs->ClearPref(prefs::kDefaultCharset);\n    web_prefs.default_encoding = WideToASCII(\n        prefs->GetString(prefs::kDefaultCharset));\n  }\n  DCHECK(!web_prefs.default_encoding.empty());\n\n  if (is_dom_ui) {\n    web_prefs.loads_images_automatically = true;\n    web_prefs.javascript_enabled = true;\n  }\n\n  return web_prefs;\n}\n", "target": 1, "idx": 183618}
{"func": "  bool focused() const { return focused_; }\n", "target": 0, "idx": 150746}
{"func": " Blob::Blob(PassOwnPtr<BlobData> blobData, long long size)\n    : m_type(blobData->contentType())\n    , m_size(size)\n{\n    ASSERT(blobData);\n    ScriptWrappable::init(this);\n \n     m_internalURL = BlobURL::createInternalURL();\n    ThreadableBlobRegistry::registerBlobURL(m_internalURL, blobData);\n }\n", "target": 1, "idx": 184249}
{"func": "  void SetMetrics(OomInterventionMetrics metrics) {\n    metrics_ = std::make_unique<OomInterventionMetrics>();\n    *metrics_ = metrics;\n  }\n", "target": 0, "idx": 143594}
{"func": "  int64 host_quota() const { return host_quota_; }\n", "target": 0, "idx": 108549}
{"func": "EncodedJSValue JSC_HOST_CALL JSTestObjConstructor::constructJSTestObj(ExecState* exec)\n {\n     JSTestObjConstructor* castedThis = jsCast<JSTestObjConstructor*>(exec->callee());\n     if (exec->argumentCount() < 1)\n        return throwVMError(exec, createTypeError(exec, \"Not enough arguments\"));\n     if (exec->argumentCount() <= 0 || !exec->argument(0).isFunction()) {\n         setDOMException(exec, TYPE_MISMATCH_ERR);\n         return JSValue::encode(jsUndefined());\n    }\n    RefPtr<TestCallback> testCallback = JSTestCallback::create(asObject(exec->argument(0)), castedThis->globalObject());\n    RefPtr<TestObj> object = TestObj::create(testCallback);\n    return JSValue::encode(asObject(toJS(exec, castedThis->globalObject(), object.get())));\n}\n", "target": 1, "idx": 184035}
{"func": "static void _close_pgsql_plink(zend_rsrc_list_entry *rsrc TSRMLS_DC)\n{\n\tPGconn *link = (PGconn *)rsrc->ptr;\n\tPGresult *res;\n\n\twhile ((res = PQgetResult(link))) {\n\t\tPQclear(res);\n\t}\n\tPQfinish(link);\n\tPGG(num_persistent)--;\n\tPGG(num_links)--;\n}\n", "target": 0, "idx": 14772}
{"func": "BrowserInit::LaunchWithProfile::~LaunchWithProfile() {\n}\n", "target": 0, "idx": 117672}
{"func": "void TextIterator::handleTextNodeFirstLetter(RenderTextFragment* renderer)\n{\n    if (renderer->firstLetter()) {\n        RenderObject* r = renderer->firstLetter();\n        if (r->style()->visibility() != VISIBLE && !m_ignoresStyleVisibility)\n            return;\n        if (RenderText* firstLetter = firstRenderTextInFirstLetter(r)) {\n            m_handledFirstLetter = true;\n            m_remainingTextBox = m_textBox;\n            m_textBox = firstLetter->firstTextBox();\n            m_sortedTextBoxes.clear();\n            m_firstLetterText = firstLetter;\n        }\n    }\n    m_handledFirstLetter = true;\n}\n", "target": 0, "idx": 121606}
{"func": "int MSG_ReadBits( msg_t *msg, int bits ) {\n\tint\t\t\tvalue;\n\tint\t\t\tget;\n\tqboolean\tsgn;\n \tint\t\t\ti, nbits;\n \n \tvalue = 0;\n \n \tif ( bits < 0 ) {\n\t\tbits = -bits;\n\t\tsgn = qtrue;\n\t} else {\n\t\tsgn = qfalse;\n \t}\n \n \tif (msg->oob) {\n \t\tif(bits==8)\n \t\t{\n \t\t\tvalue = msg->data[msg->readcount];\n\t\t\tmsg->readcount += 1;\n\t\t\tmsg->bit += 8;\n\t\t}\n\t\telse if(bits==16)\n\t\t{\n\t\t\tshort temp;\n\t\t\t\n\t\t\tCopyLittleShort(&temp, &msg->data[msg->readcount]);\n\t\t\tvalue = temp;\n\t\t\tmsg->readcount += 2;\n\t\t\tmsg->bit += 16;\n\t\t}\n\t\telse if(bits==32)\n\t\t{\n\t\t\tCopyLittleLong(&value, &msg->data[msg->readcount]);\n\t\t\tmsg->readcount += 4;\n\t\t\tmsg->bit += 32;\n\t\t}\n\t\telse\n\t\t\tCom_Error(ERR_DROP, \"can't read %d bits\", bits);\n\t} else {\n \t\tnbits = 0;\n \t\tif (bits&7) {\n \t\t\tnbits = bits&7;\n \t\t\tfor(i=0;i<nbits;i++) {\n \t\t\t\tvalue |= (Huff_getBit(msg->data, &msg->bit)<<i);\n \t\t\t}\n\t\t\tbits = bits - nbits;\n\t\t}\n \t\tif (bits) {\n \t\t\tfor(i=0;i<bits;i+=8) {\n\t\t\t\tHuff_offsetReceive (msgHuff.decompressor.tree, &get, msg->data, &msg->bit);\n \t\t\t\tvalue |= (get<<(i+nbits));\n \t\t\t}\n \t\t}\n\t\tmsg->readcount = (msg->bit>>3)+1;\n\t}\n\tif ( sgn && bits > 0 && bits < 32 ) {\n\t\tif ( value & ( 1 << ( bits - 1 ) ) ) {\n\t\t\tvalue |= -1 ^ ( ( 1 << bits ) - 1 );\n\t\t}\n\t}\n\n\treturn value;\n}\n", "target": 1, "idx": 181170}
{"func": " SPL_METHOD(SplFileObject, getMaxLineLen)\n {\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n\n\tRETURN_LONG((long)intern->u.file.max_line_len);\n} /* }}} */\n\n/* {{{ proto bool SplFileObject::hasChildren()\n", "target": 1, "idx": 180231}
{"func": "pgp_free_blob(pgp_blob_t *blob)\n{\n\tif (blob) {\n\t\tif (blob->parent) {\n\t\t\tpgp_blob_t **p;\n\n\t\t\t/* remove blob from list of parent's children */\n\t\t\tfor (p = &blob->parent->files; *p != NULL && *p != blob; p = &(*p)->next)\n\t\t\t\t;\n\t\t\tif (*p == blob)\n\t\t\t\t*p = blob->next;\n\t\t}\n\n\t\tsc_file_free(blob->file);\n\t\tif (blob->data)\n\t\t\tfree(blob->data);\n\t\tfree(blob);\n\t}\n}\n", "target": 0, "idx": 78585}
{"func": "int rds_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,\n\t\tsize_t size, int msg_flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rds_sock *rs = rds_sk_to_rs(sk);\n\tlong timeo;\n\tint ret = 0, nonblock = msg_flags & MSG_DONTWAIT;\n\tstruct sockaddr_in *sin;\n\tstruct rds_incoming *inc = NULL;\n\n\t/* udp_recvmsg()->sock_recvtimeo() gets away without locking too.. */\n\ttimeo = sock_rcvtimeo(sk, nonblock);\n \n \trdsdebug(\"size %zu flags 0x%x timeo %ld\\n\", size, msg_flags, timeo);\n \n \tif (msg_flags & MSG_OOB)\n \t\tgoto out;\n \n\twhile (1) {\n\t\t/* If there are pending notifications, do those - and nothing else */\n\t\tif (!list_empty(&rs->rs_notify_queue)) {\n\t\t\tret = rds_notify_queue_get(rs, msg);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rs->rs_cong_notify) {\n\t\t\tret = rds_notify_cong(rs, msg);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!rds_next_incoming(rs, &inc)) {\n\t\t\tif (nonblock) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ttimeo = wait_event_interruptible_timeout(*sk_sleep(sk),\n\t\t\t\t\t(!list_empty(&rs->rs_notify_queue) ||\n\t\t\t\t\t rs->rs_cong_notify ||\n\t\t\t\t\t rds_next_incoming(rs, &inc)), timeo);\n\t\t\trdsdebug(\"recvmsg woke inc %p timeo %ld\\n\", inc,\n\t\t\t\t timeo);\n\t\t\tif (timeo > 0 || timeo == MAX_SCHEDULE_TIMEOUT)\n\t\t\t\tcontinue;\n\n\t\t\tret = timeo;\n\t\t\tif (ret == 0)\n\t\t\t\tret = -ETIMEDOUT;\n\t\t\tbreak;\n\t\t}\n\n\t\trdsdebug(\"copying inc %p from %pI4:%u to user\\n\", inc,\n\t\t\t &inc->i_conn->c_faddr,\n\t\t\t ntohs(inc->i_hdr.h_sport));\n\t\tret = inc->i_conn->c_trans->inc_copy_to_user(inc, msg->msg_iov,\n\t\t\t\t\t\t\t     size);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * if the message we just copied isn't at the head of the\n\t\t * recv queue then someone else raced us to return it, try\n\t\t * to get the next message.\n\t\t */\n\t\tif (!rds_still_queued(rs, inc, !(msg_flags & MSG_PEEK))) {\n\t\t\trds_inc_put(inc);\n\t\t\tinc = NULL;\n\t\t\trds_stats_inc(s_recv_deliver_raced);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ret < be32_to_cpu(inc->i_hdr.h_len)) {\n\t\t\tif (msg_flags & MSG_TRUNC)\n\t\t\t\tret = be32_to_cpu(inc->i_hdr.h_len);\n\t\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\t}\n\n\t\tif (rds_cmsg_recv(inc, msg)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\trds_stats_inc(s_recv_delivered);\n\n\t\tsin = (struct sockaddr_in *)msg->msg_name;\n\t\tif (sin) {\n\t\t\tsin->sin_family = AF_INET;\n \t\t\tsin->sin_port = inc->i_hdr.h_sport;\n \t\t\tsin->sin_addr.s_addr = inc->i_saddr;\n \t\t\tmemset(sin->sin_zero, 0, sizeof(sin->sin_zero));\n \t\t}\n \t\tbreak;\n \t}\n\n\tif (inc)\n\t\trds_inc_put(inc);\n\nout:\n\treturn ret;\n}\n", "target": 1, "idx": 178755}
{"func": "static void kgdb_hw_overflow_handler(struct perf_event *event, int nmi,\n \t\tstruct perf_sample_data *data, struct pt_regs *regs)\n {\n \tstruct task_struct *tsk = current;\n\tint i;\n\n\tfor (i = 0; i < 4; i++)\n\t\tif (breakinfo[i].enabled)\n\t\t\ttsk->thread.debugreg6 |= (DR_TRAP0 << i);\n}\n", "target": 1, "idx": 178995}
{"func": "static void reflectUnsignedShortAttributeAttributeSetterCallback(v8::Local<v8::String>, v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)\n{\n    TRACE_EVENT_SET_SAMPLING_STATE(\"Blink\", \"DOMSetter\");\n    CustomElementCallbackDispatcher::CallbackDeliveryScope deliveryScope;\n    TestObjectPythonV8Internal::reflectUnsignedShortAttributeAttributeSetter(jsValue, info);\n    TRACE_EVENT_SET_SAMPLING_STATE(\"V8\", \"V8Execution\");\n}\n", "target": 0, "idx": 131673}
{"func": "static int command_read(struct pci_dev *dev, int offset, u16 *value, void *data)\n {\n\tint i;\n\tint ret;\n\tret = xen_pcibk_read_config_word(dev, offset, value, data);\n\tif (!pci_is_enabled(dev))\n\t\treturn ret;\n\tfor (i = 0; i < PCI_ROM_RESOURCE; i++) {\n\t\tif (dev->resource[i].flags & IORESOURCE_IO)\n\t\t\t*value |= PCI_COMMAND_IO;\n\t\tif (dev->resource[i].flags & IORESOURCE_MEM)\n\t\t\t*value |= PCI_COMMAND_MEMORY;\n \t}\n \n \treturn ret;\n }\n", "target": 1, "idx": 179854}
{"func": "_zip_cdir_new(int nentry, struct zip_error *error)\n{\n    struct zip_cdir *cd;\n    \n    if ((cd=(struct zip_cdir *)malloc(sizeof(*cd))) == NULL) {\n\t_zip_error_set(error, ZIP_ER_MEMORY, 0);\n        return NULL;\n     }\n \n    if ((cd->entry=(struct zip_dirent *)malloc(sizeof(*(cd->entry))*nentry))\n        == NULL) {\n        _zip_error_set(error, ZIP_ER_MEMORY, 0);\n        free(cd);\n\treturn NULL;\n    }\n\n    /* entries must be initialized by caller */\n\n    cd->nentry = nentry;\n    cd->size = cd->offset = 0;\n    cd->comment = NULL;\n    cd->comment_len = 0;\n\n    return cd;\n}\n", "target": 1, "idx": 177924}
{"func": "xmlParseConditionalSections(xmlParserCtxtPtr ctxt) {\n    int id = ctxt->input->id;\n\n    SKIP(3);\n    SKIP_BLANKS;\n    if (CMP7(CUR_PTR, 'I', 'N', 'C', 'L', 'U', 'D', 'E')) {\n\tSKIP(7);\n\tSKIP_BLANKS;\n\tif (RAW != '[') {\n\t    xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID, NULL);\n\t} else {\n\t    if (ctxt->input->id != id) {\n\t\txmlValidityError(ctxt, XML_ERR_ENTITY_BOUNDARY,\n\t    \"All markup of the conditional section is not in the same entity\\n\",\n\t\t\t\t     NULL, NULL);\n\t    }\n\t    NEXT;\n\t}\n\tif (xmlParserDebugEntities) {\n\t    if ((ctxt->input != NULL) && (ctxt->input->filename))\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"%s(%d): \", ctxt->input->filename,\n\t\t\tctxt->input->line);\n\t    xmlGenericError(xmlGenericErrorContext,\n \t\t    \"Entering INCLUDE Conditional Section\\n\");\n \t}\n \n\twhile ((RAW != 0) && ((RAW != ']') || (NXT(1) != ']') ||\n\t       (NXT(2) != '>'))) {\n \t    const xmlChar *check = CUR_PTR;\n \t    unsigned int cons = ctxt->input->consumed;\n \n\t    if ((RAW == '<') && (NXT(1) == '!') && (NXT(2) == '[')) {\n\t\txmlParseConditionalSections(ctxt);\n\t    } else if (IS_BLANK_CH(CUR)) {\n\t\tNEXT;\n\t    } else if (RAW == '%') {\n\t\txmlParsePEReference(ctxt);\n\t    } else\n\t\txmlParseMarkupDecl(ctxt);\n\n\t    /*\n\t     * Pop-up of finished entities.\n\t     */\n\t    while ((RAW == 0) && (ctxt->inputNr > 1))\n\t\txmlPopInput(ctxt);\n\n\t    if ((CUR_PTR == check) && (cons == ctxt->input->consumed)) {\n\t\txmlFatalErr(ctxt, XML_ERR_EXT_SUBSET_NOT_FINISHED, NULL);\n\t\tbreak;\n\t    }\n\t}\n\tif (xmlParserDebugEntities) {\n\t    if ((ctxt->input != NULL) && (ctxt->input->filename))\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"%s(%d): \", ctxt->input->filename,\n\t\t\tctxt->input->line);\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"Leaving INCLUDE Conditional Section\\n\");\n\t}\n\n    } else if (CMP6(CUR_PTR, 'I', 'G', 'N', 'O', 'R', 'E')) {\n\tint state;\n\txmlParserInputState instate;\n\tint depth = 0;\n\n\tSKIP(6);\n\tSKIP_BLANKS;\n\tif (RAW != '[') {\n\t    xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID, NULL);\n\t} else {\n\t    if (ctxt->input->id != id) {\n\t\txmlValidityError(ctxt, XML_ERR_ENTITY_BOUNDARY,\n\t    \"All markup of the conditional section is not in the same entity\\n\",\n\t\t\t\t     NULL, NULL);\n\t    }\n\t    NEXT;\n\t}\n\tif (xmlParserDebugEntities) {\n\t    if ((ctxt->input != NULL) && (ctxt->input->filename))\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"%s(%d): \", ctxt->input->filename,\n\t\t\tctxt->input->line);\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"Entering IGNORE Conditional Section\\n\");\n\t}\n\n\t/*\n\t * Parse up to the end of the conditional section\n\t * But disable SAX event generating DTD building in the meantime\n\t */\n\tstate = ctxt->disableSAX;\n\tinstate = ctxt->instate;\n \tif (ctxt->recovery == 0) ctxt->disableSAX = 1;\n \tctxt->instate = XML_PARSER_IGNORE;\n \n\twhile ((depth >= 0) && (RAW != 0)) {\n \t  if ((RAW == '<') && (NXT(1) == '!') && (NXT(2) == '[')) {\n \t    depth++;\n \t    SKIP(3);\n\t    continue;\n\t  }\n\t  if ((RAW == ']') && (NXT(1) == ']') && (NXT(2) == '>')) {\n\t    if (--depth >= 0) SKIP(3);\n\t    continue;\n\t  }\n\t  NEXT;\n\t  continue;\n\t}\n\n\tctxt->disableSAX = state;\n\tctxt->instate = instate;\n\n\tif (xmlParserDebugEntities) {\n\t    if ((ctxt->input != NULL) && (ctxt->input->filename))\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"%s(%d): \", ctxt->input->filename,\n\t\t\tctxt->input->line);\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"Leaving IGNORE Conditional Section\\n\");\n\t}\n\n    } else {\n\txmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID_KEYWORD, NULL);\n    }\n\n    if (RAW == 0)\n        SHRINK;\n\n    if (RAW == 0) {\n\txmlFatalErr(ctxt, XML_ERR_CONDSEC_NOT_FINISHED, NULL);\n    } else {\n\tif (ctxt->input->id != id) {\n\t    xmlValidityError(ctxt, XML_ERR_ENTITY_BOUNDARY,\n\t\"All markup of the conditional section is not in the same entity\\n\",\n\t\t\t\t NULL, NULL);\n\t}\n        SKIP(3);\n    }\n}\n", "target": 1, "idx": 184972}
{"func": "    LRUCanvasResourceProviderCache(wtf_size_t capacity)\n    : resource_providers_(capacity) {}\n", "target": 0, "idx": 154963}
{"func": "bgp_attr_print(netdissect_options *ndo,\n               u_int atype, const u_char *pptr, u_int len)\n{\n\tint i;\n\tuint16_t af;\n\tuint8_t safi, snpa, nhlen;\n        union { /* copy buffer for bandwidth values */\n            float f;\n            uint32_t i;\n        } bw;\n\tint advance;\n\tu_int tlen;\n\tconst u_char *tptr;\n\tchar buf[MAXHOSTNAMELEN + 100];\n        int  as_size;\n\n        tptr = pptr;\n        tlen=len;\n\n\tswitch (atype) {\n\tcase BGPTYPE_ORIGIN:\n\t\tif (len != 1)\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\telse {\n\t\t\tND_TCHECK(*tptr);\n\t\t\tND_PRINT((ndo, \"%s\", tok2str(bgp_origin_values,\n\t\t\t\t\t\t\"Unknown Origin Typecode\",\n\t\t\t\t\t\ttptr[0])));\n\t\t}\n\t\tbreak;\n\n        /*\n         * Process AS4 byte path and AS2 byte path attributes here.\n         */\n\tcase BGPTYPE_AS4_PATH:\n\tcase BGPTYPE_AS_PATH:\n\t\tif (len % 2) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n                if (!len) {\n\t\t\tND_PRINT((ndo, \"empty\"));\n\t\t\tbreak;\n                }\n\n                /*\n                 * BGP updates exchanged between New speakers that support 4\n                 * byte AS, ASs are always encoded in 4 bytes. There is no\n                 * definitive way to find this, just by the packet's\n                 * contents. So, check for packet's TLV's sanity assuming\n                 * 2 bytes first, and it does not pass, assume that ASs are\n                 * encoded in 4 bytes format and move on.\n                 */\n                as_size = bgp_attr_get_as_size(ndo, atype, pptr, len);\n\n\t\twhile (tptr < pptr + len) {\n\t\t\tND_TCHECK(tptr[0]);\n                        ND_PRINT((ndo, \"%s\", tok2str(bgp_as_path_segment_open_values,\n\t\t\t\t\t\t\"?\", tptr[0])));\n\t\t\tND_TCHECK(tptr[1]);\n                        for (i = 0; i < tptr[1] * as_size; i += as_size) {\n                            ND_TCHECK2(tptr[2 + i], as_size);\n\t\t\t    ND_PRINT((ndo, \"%s \",\n\t\t\t\tas_printf(ndo, astostr, sizeof(astostr),\n\t\t\t\tas_size == 2 ?\n\t\t\t\tEXTRACT_16BITS(&tptr[2 + i]) :\n\t\t\t\tEXTRACT_32BITS(&tptr[2 + i]))));\n                        }\n\t\t\tND_TCHECK(tptr[0]);\n                        ND_PRINT((ndo, \"%s\", tok2str(bgp_as_path_segment_close_values,\n\t\t\t\t\t\t\"?\", tptr[0])));\n                        ND_TCHECK(tptr[1]);\n                        tptr += 2 + tptr[1] * as_size;\n\t\t}\n\t\tbreak;\n\tcase BGPTYPE_NEXT_HOP:\n\t\tif (len != 4)\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\telse {\n\t\t\tND_TCHECK2(tptr[0], 4);\n\t\t\tND_PRINT((ndo, \"%s\", ipaddr_string(ndo, tptr)));\n\t\t}\n\t\tbreak;\n\tcase BGPTYPE_MULTI_EXIT_DISC:\n\tcase BGPTYPE_LOCAL_PREF:\n\t\tif (len != 4)\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\telse {\n\t\t\tND_TCHECK2(tptr[0], 4);\n\t\t\tND_PRINT((ndo, \"%u\", EXTRACT_32BITS(tptr)));\n\t\t}\n\t\tbreak;\n\tcase BGPTYPE_ATOMIC_AGGREGATE:\n\t\tif (len != 0)\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\tbreak;\n        case BGPTYPE_AGGREGATOR:\n\n                /*\n                 * Depending on the AS encoded is of 2 bytes or of 4 bytes,\n                 * the length of this PA can be either 6 bytes or 8 bytes.\n                 */\n                if (len != 6 && len != 8) {\n                    ND_PRINT((ndo, \"invalid len\"));\n                    break;\n                }\n                ND_TCHECK2(tptr[0], len);\n                if (len == 6) {\n\t\t    ND_PRINT((ndo, \" AS #%s, origin %s\",\n\t\t\tas_printf(ndo, astostr, sizeof(astostr), EXTRACT_16BITS(tptr)),\n\t\t\tipaddr_string(ndo, tptr + 2)));\n                } else {\n\t\t    ND_PRINT((ndo, \" AS #%s, origin %s\",\n\t\t\tas_printf(ndo, astostr, sizeof(astostr),\n\t\t\tEXTRACT_32BITS(tptr)), ipaddr_string(ndo, tptr + 4)));\n                }\n                break;\n\tcase BGPTYPE_AGGREGATOR4:\n\t\tif (len != 8) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n\t\tND_TCHECK2(tptr[0], 8);\n\t\tND_PRINT((ndo, \" AS #%s, origin %s\",\n\t   \t    as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(tptr)),\n\t\t    ipaddr_string(ndo, tptr + 4)));\n\t\tbreak;\n\tcase BGPTYPE_COMMUNITIES:\n\t\tif (len % 4) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n\t\twhile (tlen>0) {\n\t\t\tuint32_t comm;\n\t\t\tND_TCHECK2(tptr[0], 4);\n\t\t\tcomm = EXTRACT_32BITS(tptr);\n\t\t\tswitch (comm) {\n\t\t\tcase BGP_COMMUNITY_NO_EXPORT:\n\t\t\t\tND_PRINT((ndo, \" NO_EXPORT\"));\n\t\t\t\tbreak;\n\t\t\tcase BGP_COMMUNITY_NO_ADVERT:\n\t\t\t\tND_PRINT((ndo, \" NO_ADVERTISE\"));\n\t\t\t\tbreak;\n\t\t\tcase BGP_COMMUNITY_NO_EXPORT_SUBCONFED:\n\t\t\t\tND_PRINT((ndo, \" NO_EXPORT_SUBCONFED\"));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tND_PRINT((ndo, \"%u:%u%s\",\n                                       (comm >> 16) & 0xffff,\n                                       comm & 0xffff,\n                                       (tlen>4) ? \", \" : \"\"));\n\t\t\t\tbreak;\n\t\t\t}\n                        tlen -=4;\n                        tptr +=4;\n\t\t}\n\t\tbreak;\n        case BGPTYPE_ORIGINATOR_ID:\n\t\tif (len != 4) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n\t\tND_TCHECK2(tptr[0], 4);\n                ND_PRINT((ndo, \"%s\",ipaddr_string(ndo, tptr)));\n                break;\n        case BGPTYPE_CLUSTER_LIST:\n\t\tif (len % 4) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n                while (tlen>0) {\n\t\t\tND_TCHECK2(tptr[0], 4);\n                        ND_PRINT((ndo, \"%s%s\",\n                               ipaddr_string(ndo, tptr),\n                                (tlen>4) ? \", \" : \"\"));\n                        tlen -=4;\n                        tptr +=4;\n                }\n                break;\n\tcase BGPTYPE_MP_REACH_NLRI:\n\t\tND_TCHECK2(tptr[0], 3);\n\t\taf = EXTRACT_16BITS(tptr);\n\t\tsafi = tptr[2];\n\n                ND_PRINT((ndo, \"\\n\\t    AFI: %s (%u), %sSAFI: %s (%u)\",\n                       tok2str(af_values, \"Unknown AFI\", af),\n                       af,\n                       (safi>128) ? \"vendor specific \" : \"\", /* 128 is meanwhile wellknown */\n                       tok2str(bgp_safi_values, \"Unknown SAFI\", safi),\n                       safi));\n\n                switch(af<<8 | safi) {\n                case (AFNUM_INET<<8 | SAFNUM_UNICAST):\n                case (AFNUM_INET<<8 | SAFNUM_MULTICAST):\n                case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):\n                case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):\n                case (AFNUM_INET<<8 | SAFNUM_RT_ROUTING_INFO):\n                case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):\n                case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):\n                case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):\n                case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN):\n\t\tcase (AFNUM_INET<<8 | SAFNUM_MDT):\n                case (AFNUM_INET6<<8 | SAFNUM_UNICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):\n                case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):\n                case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):\n                case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):\n                case (AFNUM_VPLS<<8 | SAFNUM_VPLS):\n                    break;\n                default:\n                    ND_TCHECK2(tptr[0], tlen);\n                    ND_PRINT((ndo, \"\\n\\t    no AFI %u / SAFI %u decoder\", af, safi));\n                    if (ndo->ndo_vflag <= 1)\n                        print_unknown_data(ndo, tptr, \"\\n\\t    \", tlen);\n                    goto done;\n                    break;\n                }\n\n                tptr +=3;\n\n\t\tND_TCHECK(tptr[0]);\n\t\tnhlen = tptr[0];\n                tlen = nhlen;\n                tptr++;\n\n\t\tif (tlen) {\n                    int nnh = 0;\n                    ND_PRINT((ndo, \"\\n\\t    nexthop: \"));\n                    while (tlen > 0) {\n                        if ( nnh++ > 0 ) {\n                            ND_PRINT((ndo,  \", \" ));\n                        }\n                        switch(af<<8 | safi) {\n                        case (AFNUM_INET<<8 | SAFNUM_UNICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_MULTICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_RT_ROUTING_INFO):\n                        case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN):\n                        case (AFNUM_INET<<8 | SAFNUM_MDT):\n\t\t\t    if (tlen < (int)sizeof(struct in_addr)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in_addr));\n                                ND_PRINT((ndo, \"%s\",ipaddr_string(ndo, tptr)));\n                                tlen -= sizeof(struct in_addr);\n                                tptr += sizeof(struct in_addr);\n                            }\n                            break;\n                        case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):\n                            if (tlen < (int)(sizeof(struct in_addr)+BGP_VPN_RD_LEN)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in_addr)+BGP_VPN_RD_LEN);\n                                ND_PRINT((ndo, \"RD: %s, %s\",\n                                       bgp_vpn_rd_print(ndo, tptr),\n                                       ipaddr_string(ndo, tptr+BGP_VPN_RD_LEN)));\n                                tlen -= (sizeof(struct in_addr)+BGP_VPN_RD_LEN);\n                                tptr += (sizeof(struct in_addr)+BGP_VPN_RD_LEN);\n                            }\n                            break;\n                        case (AFNUM_INET6<<8 | SAFNUM_UNICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):\n                            if (tlen < (int)sizeof(struct in6_addr)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in6_addr));\n                                ND_PRINT((ndo, \"%s\", ip6addr_string(ndo, tptr)));\n                                tlen -= sizeof(struct in6_addr);\n                                tptr += sizeof(struct in6_addr);\n                            }\n                            break;\n                        case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):\n                            if (tlen < (int)(sizeof(struct in6_addr)+BGP_VPN_RD_LEN)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in6_addr)+BGP_VPN_RD_LEN);\n                                ND_PRINT((ndo, \"RD: %s, %s\",\n                                       bgp_vpn_rd_print(ndo, tptr),\n                                       ip6addr_string(ndo, tptr+BGP_VPN_RD_LEN)));\n                                tlen -= (sizeof(struct in6_addr)+BGP_VPN_RD_LEN);\n                                tptr += (sizeof(struct in6_addr)+BGP_VPN_RD_LEN);\n                            }\n                            break;\n                        case (AFNUM_VPLS<<8 | SAFNUM_VPLS):\n                        case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):\n                        case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):\n                        case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):\n                            if (tlen < (int)sizeof(struct in_addr)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in_addr));\n                                ND_PRINT((ndo, \"%s\", ipaddr_string(ndo, tptr)));\n                                tlen -= (sizeof(struct in_addr));\n                                tptr += (sizeof(struct in_addr));\n                            }\n                            break;\n                        case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):\n                        case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):\n                        case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):\n                            ND_TCHECK2(tptr[0], tlen);\n                            ND_PRINT((ndo, \"%s\", isonsap_string(ndo, tptr, tlen)));\n                            tptr += tlen;\n                            tlen = 0;\n                            break;\n\n                        case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):\n                        case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):\n                        case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):\n                            if (tlen < BGP_VPN_RD_LEN+1) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], tlen);\n                                ND_PRINT((ndo, \"RD: %s, %s\",\n                                       bgp_vpn_rd_print(ndo, tptr),\n                                       isonsap_string(ndo, tptr+BGP_VPN_RD_LEN,tlen-BGP_VPN_RD_LEN)));\n                                /* rfc986 mapped IPv4 address ? */\n                                if (EXTRACT_32BITS(tptr+BGP_VPN_RD_LEN) ==  0x47000601)\n                                    ND_PRINT((ndo, \" = %s\", ipaddr_string(ndo, tptr+BGP_VPN_RD_LEN+4)));\n                                /* rfc1888 mapped IPv6 address ? */\n                                else if (EXTRACT_24BITS(tptr+BGP_VPN_RD_LEN) ==  0x350000)\n                                    ND_PRINT((ndo, \" = %s\", ip6addr_string(ndo, tptr+BGP_VPN_RD_LEN+3)));\n                                tptr += tlen;\n                                tlen = 0;\n                            }\n                            break;\n                        default:\n                            ND_TCHECK2(tptr[0], tlen);\n                            ND_PRINT((ndo, \"no AFI %u/SAFI %u decoder\", af, safi));\n                            if (ndo->ndo_vflag <= 1)\n                                print_unknown_data(ndo, tptr, \"\\n\\t    \", tlen);\n                            tptr += tlen;\n                            tlen = 0;\n                            goto done;\n                            break;\n                        }\n                    }\n\t\t}\n\t\tND_PRINT((ndo, \", nh-length: %u\", nhlen));\n\t\ttptr += tlen;\n\n\t\tND_TCHECK(tptr[0]);\n\t\tsnpa = tptr[0];\n\t\ttptr++;\n\n\t\tif (snpa) {\n\t\t\tND_PRINT((ndo, \"\\n\\t    %u SNPA\", snpa));\n\t\t\tfor (/*nothing*/; snpa > 0; snpa--) {\n\t\t\t\tND_TCHECK(tptr[0]);\n\t\t\t\tND_PRINT((ndo, \"\\n\\t      %d bytes\", tptr[0]));\n\t\t\t\ttptr += tptr[0] + 1;\n\t\t\t}\n\t\t} else {\n\t\t\tND_PRINT((ndo, \", no SNPA\"));\n                }\n\n\t\twhile (tptr < pptr + len) {\n                    switch (af<<8 | safi) {\n                    case (AFNUM_INET<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_prefix4(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):\n                        advance = decode_labeled_prefix4(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_prefix4(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_RT_ROUTING_INFO):\n                        advance = decode_rt_routing_info(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN): /* fall through */\n                    case (AFNUM_INET6<<8 | SAFNUM_MULTICAST_VPN):\n                        advance = decode_multicast_vpn(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n\n\t\t    case (AFNUM_INET<<8 | SAFNUM_MDT):\n\t\t      advance = decode_mdt_vpn_nlri(ndo, tptr, buf, sizeof(buf));\n\t\t      if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n\t\t       break;\n                    case (AFNUM_INET6<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_prefix6(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):\n                        advance = decode_labeled_prefix6(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_prefix6(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_VPLS<<8 | SAFNUM_VPLS):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_l2(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_clnp_prefix(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_clnp_prefix(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    default:\n                        ND_TCHECK2(*tptr,tlen);\n                        ND_PRINT((ndo, \"\\n\\t    no AFI %u / SAFI %u decoder\", af, safi));\n                        if (ndo->ndo_vflag <= 1)\n                            print_unknown_data(ndo, tptr, \"\\n\\t    \", tlen);\n                        advance = 0;\n                        tptr = pptr + len;\n                        break;\n                    }\n                    if (advance < 0)\n                        break;\n                    tptr += advance;\n\t\t}\n        done:\n\t\tbreak;\n\n\tcase BGPTYPE_MP_UNREACH_NLRI:\n\t\tND_TCHECK2(tptr[0], BGP_MP_NLRI_MINSIZE);\n\t\taf = EXTRACT_16BITS(tptr);\n\t\tsafi = tptr[2];\n\n                ND_PRINT((ndo, \"\\n\\t    AFI: %s (%u), %sSAFI: %s (%u)\",\n                       tok2str(af_values, \"Unknown AFI\", af),\n                       af,\n                       (safi>128) ? \"vendor specific \" : \"\", /* 128 is meanwhile wellknown */\n                       tok2str(bgp_safi_values, \"Unknown SAFI\", safi),\n                       safi));\n\n                if (len == BGP_MP_NLRI_MINSIZE)\n                    ND_PRINT((ndo, \"\\n\\t      End-of-Rib Marker (empty NLRI)\"));\n\n\t\ttptr += 3;\n\n\t\twhile (tptr < pptr + len) {\n                    switch (af<<8 | safi) {\n                    case (AFNUM_INET<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_prefix4(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):\n                        advance = decode_labeled_prefix4(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_prefix4(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_prefix6(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):\n                        advance = decode_labeled_prefix6(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_prefix6(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_VPLS<<8 | SAFNUM_VPLS):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_l2(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_clnp_prefix(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_clnp_prefix(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n\t\t    case (AFNUM_INET<<8 | SAFNUM_MDT):\n\t\t      advance = decode_mdt_vpn_nlri(ndo, tptr, buf, sizeof(buf));\n\t\t      if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n\t\t       break;\n                    case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN): /* fall through */\n                    case (AFNUM_INET6<<8 | SAFNUM_MULTICAST_VPN):\n                        advance = decode_multicast_vpn(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    default:\n                        ND_TCHECK2(*(tptr-3),tlen);\n                        ND_PRINT((ndo, \"no AFI %u / SAFI %u decoder\", af, safi));\n                        if (ndo->ndo_vflag <= 1)\n                            print_unknown_data(ndo, tptr-3, \"\\n\\t    \", tlen);\n                        advance = 0;\n                        tptr = pptr + len;\n                        break;\n                    }\n                    if (advance < 0)\n                        break;\n                    tptr += advance;\n\t\t}\n\t\tbreak;\n        case BGPTYPE_EXTD_COMMUNITIES:\n\t\tif (len % 8) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n                while (tlen>0) {\n                    uint16_t extd_comm;\n\n                    ND_TCHECK2(tptr[0], 2);\n                    extd_comm=EXTRACT_16BITS(tptr);\n\n\t\t    ND_PRINT((ndo, \"\\n\\t    %s (0x%04x), Flags [%s]\",\n\t\t\t   tok2str(bgp_extd_comm_subtype_values,\n\t\t\t\t      \"unknown extd community typecode\",\n\t\t\t\t      extd_comm),\n\t\t\t   extd_comm,\n\t\t\t   bittok2str(bgp_extd_comm_flag_values, \"none\", extd_comm)));\n\n                    ND_TCHECK2(*(tptr+2), 6);\n                    switch(extd_comm) {\n                    case BGP_EXT_COM_RT_0:\n                    case BGP_EXT_COM_RO_0:\n                    case BGP_EXT_COM_L2VPN_RT_0:\n                        ND_PRINT((ndo, \": %u:%u (= %s)\",\n                               EXTRACT_16BITS(tptr+2),\n                               EXTRACT_32BITS(tptr+4),\n                               ipaddr_string(ndo, tptr+4)));\n                        break;\n                    case BGP_EXT_COM_RT_1:\n                    case BGP_EXT_COM_RO_1:\n                    case BGP_EXT_COM_L2VPN_RT_1:\n                    case BGP_EXT_COM_VRF_RT_IMP:\n                        ND_PRINT((ndo, \": %s:%u\",\n                               ipaddr_string(ndo, tptr+2),\n                               EXTRACT_16BITS(tptr+6)));\n                        break;\n                    case BGP_EXT_COM_RT_2:\n                    case BGP_EXT_COM_RO_2:\n\t\t\tND_PRINT((ndo, \": %s:%u\",\n\t\t\t    as_printf(ndo, astostr, sizeof(astostr),\n\t\t\t    EXTRACT_32BITS(tptr+2)), EXTRACT_16BITS(tptr+6)));\n\t\t\tbreak;\n                    case BGP_EXT_COM_LINKBAND:\n\t\t        bw.i = EXTRACT_32BITS(tptr+2);\n                        ND_PRINT((ndo, \": bandwidth: %.3f Mbps\",\n                               bw.f*8/1000000));\n                        break;\n                    case BGP_EXT_COM_VPN_ORIGIN:\n                    case BGP_EXT_COM_VPN_ORIGIN2:\n                    case BGP_EXT_COM_VPN_ORIGIN3:\n                    case BGP_EXT_COM_VPN_ORIGIN4:\n                    case BGP_EXT_COM_OSPF_RID:\n                    case BGP_EXT_COM_OSPF_RID2:\n                        ND_PRINT((ndo, \"%s\", ipaddr_string(ndo, tptr+2)));\n                        break;\n                    case BGP_EXT_COM_OSPF_RTYPE:\n                    case BGP_EXT_COM_OSPF_RTYPE2:\n                        ND_PRINT((ndo, \": area:%s, router-type:%s, metric-type:%s%s\",\n                               ipaddr_string(ndo, tptr+2),\n                               tok2str(bgp_extd_comm_ospf_rtype_values,\n\t\t\t\t\t  \"unknown (0x%02x)\",\n\t\t\t\t\t  *(tptr+6)),\n                               (*(tptr+7) &  BGP_OSPF_RTYPE_METRIC_TYPE) ? \"E2\" : \"\",\n                               ((*(tptr+6) == BGP_OSPF_RTYPE_EXT) || (*(tptr+6) == BGP_OSPF_RTYPE_NSSA)) ? \"E1\" : \"\"));\n                        break;\n                    case BGP_EXT_COM_L2INFO:\n                        ND_PRINT((ndo, \": %s Control Flags [0x%02x]:MTU %u\",\n                               tok2str(l2vpn_encaps_values,\n\t\t\t\t\t  \"unknown encaps\",\n\t\t\t\t\t  *(tptr+2)),\n                                       *(tptr+3),\n                               EXTRACT_16BITS(tptr+4)));\n                        break;\n                    case BGP_EXT_COM_SOURCE_AS:\n                        ND_PRINT((ndo, \": AS %u\", EXTRACT_16BITS(tptr+2)));\n                        break;\n                    default:\n                        ND_TCHECK2(*tptr,8);\n                        print_unknown_data(ndo, tptr, \"\\n\\t      \", 8);\n                        break;\n                    }\n                    tlen -=8;\n                    tptr +=8;\n                }\n                break;\n\n        case BGPTYPE_PMSI_TUNNEL:\n         {\n                 uint8_t tunnel_type, flags;\n \n                 tunnel_type = *(tptr+1);\n                 flags = *tptr;\n                 tlen = len;\n \n                ND_TCHECK2(tptr[0], 5);\n                 ND_PRINT((ndo, \"\\n\\t    Tunnel-type %s (%u), Flags [%s], MPLS Label %u\",\n                        tok2str(bgp_pmsi_tunnel_values, \"Unknown\", tunnel_type),\n                        tunnel_type,\n                       bittok2str(bgp_pmsi_flag_values, \"none\", flags),\n                       EXTRACT_24BITS(tptr+2)>>4));\n\n                tptr +=5;\n                tlen -= 5;\n\n                switch (tunnel_type) {\n                case BGP_PMSI_TUNNEL_PIM_SM: /* fall through */\n                case BGP_PMSI_TUNNEL_PIM_BIDIR:\n                    ND_TCHECK2(tptr[0], 8);\n                    ND_PRINT((ndo, \"\\n\\t      Sender %s, P-Group %s\",\n                           ipaddr_string(ndo, tptr),\n                           ipaddr_string(ndo, tptr+4)));\n                    break;\n\n                case BGP_PMSI_TUNNEL_PIM_SSM:\n                    ND_TCHECK2(tptr[0], 8);\n                    ND_PRINT((ndo, \"\\n\\t      Root-Node %s, P-Group %s\",\n                           ipaddr_string(ndo, tptr),\n                           ipaddr_string(ndo, tptr+4)));\n                    break;\n                case BGP_PMSI_TUNNEL_INGRESS:\n                    ND_TCHECK2(tptr[0], 4);\n                    ND_PRINT((ndo, \"\\n\\t      Tunnel-Endpoint %s\",\n                           ipaddr_string(ndo, tptr)));\n                    break;\n                case BGP_PMSI_TUNNEL_LDP_P2MP: /* fall through */\n                case BGP_PMSI_TUNNEL_LDP_MP2MP:\n                    ND_TCHECK2(tptr[0], 8);\n                    ND_PRINT((ndo, \"\\n\\t      Root-Node %s, LSP-ID 0x%08x\",\n                           ipaddr_string(ndo, tptr),\n                           EXTRACT_32BITS(tptr+4)));\n                    break;\n                case BGP_PMSI_TUNNEL_RSVP_P2MP:\n                    ND_TCHECK2(tptr[0], 8);\n                    ND_PRINT((ndo, \"\\n\\t      Extended-Tunnel-ID %s, P2MP-ID 0x%08x\",\n                           ipaddr_string(ndo, tptr),\n                           EXTRACT_32BITS(tptr+4)));\n                    break;\n                default:\n                    if (ndo->ndo_vflag <= 1) {\n                        print_unknown_data(ndo, tptr, \"\\n\\t      \", tlen);\n                    }\n                }\n                break;\n        }\n\tcase BGPTYPE_AIGP:\n\t{\n\t\tuint8_t type;\n\t\tuint16_t length;\n\n\t\ttlen = len;\n\n\t\twhile (tlen >= 3) {\n\n\t\t    ND_TCHECK2(tptr[0], 3);\n\n\t\t    type = *tptr;\n\t\t    length = EXTRACT_16BITS(tptr+1);\n\t\t    tptr += 3;\n\t\t    tlen -= 3;\n\n\t\t    ND_PRINT((ndo, \"\\n\\t    %s TLV (%u), length %u\",\n\t\t\t      tok2str(bgp_aigp_values, \"Unknown\", type),\n\t\t\t      type, length));\n\n\t\t    if (length < 3)\n\t\t\tgoto trunc;\n\t\t    length -= 3;\n\n\t\t    /*\n\t\t     * Check if we can read the TLV data.\n\t\t     */\n\t\t    ND_TCHECK2(tptr[3], length);\n\n\t\t    switch (type) {\n\n\t\t    case BGP_AIGP_TLV:\n\t\t        if (length < 8)\n\t\t            goto trunc;\n\t\t\tND_PRINT((ndo, \", metric %\" PRIu64,\n\t\t\t\t  EXTRACT_64BITS(tptr)));\n\t\t\tbreak;\n\n\t\t    default:\n\t\t\tif (ndo->ndo_vflag <= 1) {\n\t\t\t    print_unknown_data(ndo, tptr,\"\\n\\t      \", length);\n\t\t\t}\n\t\t    }\n\n\t\t    tptr += length;\n\t\t    tlen -= length;\n\t\t}\n\t\tbreak;\n\t}\n        case BGPTYPE_ATTR_SET:\n                ND_TCHECK2(tptr[0], 4);\n                if (len < 4)\n                \tgoto trunc;\n\t\tND_PRINT((ndo, \"\\n\\t    Origin AS: %s\",\n\t\t    as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(tptr))));\n\t\ttptr+=4;\n                len -=4;\n\n                while (len) {\n                    u_int aflags, alenlen, alen;\n\n                    ND_TCHECK2(tptr[0], 2);\n                    if (len < 2)\n                        goto trunc;\n                    aflags = *tptr;\n                    atype = *(tptr + 1);\n                    tptr += 2;\n                    len -= 2;\n                    alenlen = bgp_attr_lenlen(aflags, tptr);\n                    ND_TCHECK2(tptr[0], alenlen);\n                    if (len < alenlen)\n                        goto trunc;\n                    alen = bgp_attr_len(aflags, tptr);\n                    tptr += alenlen;\n                    len -= alenlen;\n\n                    ND_PRINT((ndo, \"\\n\\t      %s (%u), length: %u\",\n                           tok2str(bgp_attr_values,\n                                      \"Unknown Attribute\", atype),\n                           atype,\n                           alen));\n\n                    if (aflags) {\n                        ND_PRINT((ndo, \", Flags [%s%s%s%s\",\n                               aflags & 0x80 ? \"O\" : \"\",\n                               aflags & 0x40 ? \"T\" : \"\",\n                               aflags & 0x20 ? \"P\" : \"\",\n                               aflags & 0x10 ? \"E\" : \"\"));\n                        if (aflags & 0xf)\n                            ND_PRINT((ndo, \"+%x\", aflags & 0xf));\n                        ND_PRINT((ndo, \"]: \"));\n                    }\n                    /* FIXME check for recursion */\n                    if (!bgp_attr_print(ndo, atype, tptr, alen))\n                        return 0;\n                    tptr += alen;\n                    len -= alen;\n\t\t}\n                break;\n\n\tcase BGPTYPE_LARGE_COMMUNITY:\n\t\tif (len == 0 || len % 12) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n\t\tND_PRINT((ndo, \"\\n\\t    \"));\n\t\twhile (len > 0) {\n\t\t\tND_TCHECK2(*tptr, 12);\n\t\t\tND_PRINT((ndo, \"%u:%u:%u%s\",\n\t\t\t\t EXTRACT_32BITS(tptr),\n\t\t\t\t EXTRACT_32BITS(tptr + 4),\n\t\t\t\t EXTRACT_32BITS(tptr + 8),\n\t\t\t\t (len > 12) ? \", \" : \"\"));\n                        tptr += 12;\n                        len -= 12;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t    ND_TCHECK2(*pptr,len);\n            ND_PRINT((ndo, \"\\n\\t    no Attribute %u decoder\", atype)); /* we have no decoder for the attribute */\n            if (ndo->ndo_vflag <= 1)\n                print_unknown_data(ndo, pptr, \"\\n\\t    \", len);\n            break;\n\t}\n        if (ndo->ndo_vflag > 1 && len) { /* omit zero length attributes*/\n            ND_TCHECK2(*pptr,len);\n            print_unknown_data(ndo, pptr, \"\\n\\t    \", len);\n        }\n        return 1;\n\ntrunc:\n        return 0;\n}\n", "target": 1, "idx": 181001}
{"func": "static EAS_I16 ConvertLFOPhaseIncrement (EAS_I32 pitchCents)\n{\n\n /* check range */\n if (pitchCents > MAX_LFO_FREQUENCY_IN_PITCHCENTS)\n        pitchCents = MAX_LFO_FREQUENCY_IN_PITCHCENTS;\n if (pitchCents < MIN_LFO_FREQUENCY_IN_PITCHCENTS)\n        pitchCents = MIN_LFO_FREQUENCY_IN_PITCHCENTS;\n\n /* double the rate and divide by frame rate by subtracting in log domain */\n    pitchCents = pitchCents - dlsLFOFrequencyConvert;\n\n /* convert to phase increment */\n return (EAS_I16) EAS_Calculate2toX(pitchCents);\n}\n", "target": 0, "idx": 170677}
{"func": "static bool tailmatch(const char *little, const char *bigone)\n {\n  size_t littlelen = strlen(little);\n  size_t biglen = strlen(bigone);\n \n  if(littlelen > biglen)\n     return FALSE;\n \n  return Curl_raw_equal(little, bigone+biglen-littlelen) ? TRUE : FALSE;\n }\n", "target": 1, "idx": 179270}
{"func": "void vfio_pci_intx_mask(struct vfio_pci_device *vdev)\n{\n\tstruct pci_dev *pdev = vdev->pdev;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&vdev->irqlock, flags);\n\n\t/*\n\t * Masking can come from interrupt, ioctl, or config space\n\t * via INTx disable.  The latter means this can get called\n\t * even when not using intx delivery.  In this case, just\n\t * try to have the physical bit follow the virtual bit.\n\t */\n\tif (unlikely(!is_intx(vdev))) {\n\t\tif (vdev->pci_2_3)\n\t\t\tpci_intx(pdev, 0);\n\t} else if (!vdev->ctx[0].masked) {\n\t\t/*\n\t\t * Can't use check_and_mask here because we always want to\n\t\t * mask, not just when something is pending.\n\t\t */\n\t\tif (vdev->pci_2_3)\n\t\t\tpci_intx(pdev, 0);\n\t\telse\n\t\t\tdisable_irq_nosync(pdev->irq);\n\n\t\tvdev->ctx[0].masked = true;\n\t}\n\n\tspin_unlock_irqrestore(&vdev->irqlock, flags);\n}\n", "target": 0, "idx": 48617}
{"func": "void FrameLoader::Trace(blink::Visitor* visitor) {\n  visitor->Trace(frame_);\n   visitor->Trace(progress_tracker_);\n   visitor->Trace(document_loader_);\n   visitor->Trace(provisional_document_loader_);\n }\n", "target": 1, "idx": 187043}
{"func": "int dtls_get_message(SSL *s, int *mt, unsigned long *len)\n{\n    struct hm_header_st *msg_hdr;\n    unsigned char *p;\n    unsigned long msg_len;\n    int ok;\n    long tmplen;\n\n    msg_hdr = &s->d1->r_msg_hdr;\n    memset(msg_hdr, 0, sizeof(*msg_hdr));\n\n again:\n    ok = dtls_get_reassembled_message(s, &tmplen);\n    if (tmplen == DTLS1_HM_BAD_FRAGMENT || tmplen == DTLS1_HM_FRAGMENT_RETRY) {\n        /* bad fragment received */\n        goto again;\n    } else if (tmplen <= 0 && !ok) {\n        return 0;\n    }\n\n    *mt = s->s3->tmp.message_type;\n\n    p = (unsigned char *)s->init_buf->data;\n\n    if (*mt == SSL3_MT_CHANGE_CIPHER_SPEC) {\n        if (s->msg_callback) {\n            s->msg_callback(0, s->version, SSL3_RT_CHANGE_CIPHER_SPEC,\n                            p, 1, s, s->msg_callback_arg);\n        }\n        /*\n         * This isn't a real handshake message so skip the processing below.\n         */\n        *len = (unsigned long)tmplen;\n        return 1;\n    }\n\n    msg_len = msg_hdr->msg_len;\n\n    /* reconstruct message header */\n    *(p++) = msg_hdr->type;\n    l2n3(msg_len, p);\n    s2n(msg_hdr->seq, p);\n    l2n3(0, p);\n    l2n3(msg_len, p);\n    if (s->version != DTLS1_BAD_VER) {\n        p -= DTLS1_HM_HEADER_LENGTH;\n        msg_len += DTLS1_HM_HEADER_LENGTH;\n    }\n\n    if (!ssl3_finish_mac(s, p, msg_len))\n        return 0;\n    if (s->msg_callback)\n        s->msg_callback(0, s->version, SSL3_RT_HANDSHAKE,\n                        p, msg_len, s, s->msg_callback_arg);\n\n    memset(msg_hdr, 0, sizeof(*msg_hdr));\n\n    s->d1->handshake_read_seq++;\n\n    s->init_msg = s->init_buf->data + DTLS1_HM_HEADER_LENGTH;\n    *len = s->init_num;\n\n    return 1;\n}\n", "target": 0, "idx": 12715}
{"func": " static int omninet_open(struct tty_struct *tty, struct usb_serial_port *port)\n {\n\tstruct usb_serial\t*serial = port->serial;\n\tstruct usb_serial_port\t*wport;\n\twport = serial->port[1];\n\ttty_port_tty_set(&wport->port, tty);\n \treturn usb_serial_generic_open(tty, port);\n }\n", "target": 1, "idx": 181360}
{"func": "static void close_table_device(struct table_device *td, struct mapped_device *md)\n{\n\tif (!td->dm_dev.bdev)\n\t\treturn;\n\n\tbd_unlink_disk_holder(td->dm_dev.bdev, dm_disk(md));\n\tblkdev_put(td->dm_dev.bdev, td->dm_dev.mode | FMODE_EXCL);\n\tput_dax(td->dm_dev.dax_dev);\n\ttd->dm_dev.bdev = NULL;\n\ttd->dm_dev.dax_dev = NULL;\n}\n", "target": 0, "idx": 85863}
{"func": "MagickExport Image *ComplexImages(const Image *images,const ComplexOperator op,\n  ExceptionInfo *exception)\n{\n#define ComplexImageTag  \"Complex/Image\"\n\n  CacheView\n    *Ai_view,\n    *Ar_view,\n    *Bi_view,\n    *Br_view,\n    *Ci_view,\n    *Cr_view;\n\n  const char\n    *artifact;\n\n  const Image\n    *Ai_image,\n    *Ar_image,\n    *Bi_image,\n    *Br_image;\n\n  double\n    snr;\n\n  Image\n    *Ci_image,\n    *complex_images,\n    *Cr_image,\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  ssize_t\n    y;\n\n  assert(images != (Image *) NULL);\n  assert(images->signature == MagickCoreSignature);\n  if (images->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",images->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if (images->next == (Image *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ImageSequenceRequired\",\"`%s'\",images->filename);\n      return((Image *) NULL);\n    }\n  image=CloneImage(images,0,0,MagickTrue,exception);\n  if (image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return(image);\n    }\n  image->depth=32UL;\n  complex_images=NewImageList();\n  AppendImageToList(&complex_images,image);\n  image=CloneImage(images,0,0,MagickTrue,exception);\n  if (image == (Image *) NULL)\n    {\n      complex_images=DestroyImageList(complex_images);\n      return(complex_images);\n    }\n  AppendImageToList(&complex_images,image);\n  /*\n    Apply complex mathematics to image pixels.\n  */\n  artifact=GetImageArtifact(image,\"complex:snr\");\n  snr=0.0;\n  if (artifact != (const char *) NULL)\n    snr=StringToDouble(artifact,(char **) NULL);\n  Ar_image=images;\n  Ai_image=images->next;\n  Br_image=images;\n  Bi_image=images->next;\n  if ((images->next->next != (Image *) NULL) &&\n      (images->next->next->next != (Image *) NULL))\n    {\n      Br_image=images->next->next;\n      Bi_image=images->next->next->next;\n    }\n  Cr_image=complex_images;\n  Ci_image=complex_images->next;\n  Ar_view=AcquireVirtualCacheView(Ar_image,exception);\n  Ai_view=AcquireVirtualCacheView(Ai_image,exception);\n  Br_view=AcquireVirtualCacheView(Br_image,exception);\n  Bi_view=AcquireVirtualCacheView(Bi_image,exception);\n  Cr_view=AcquireAuthenticCacheView(Cr_image,exception);\n  Ci_view=AcquireAuthenticCacheView(Ci_image,exception);\n  status=MagickTrue;\n   progress=0;\n #if defined(MAGICKCORE_OPENMP_SUPPORT)\n   #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(images,complex_images,images->rows,1L)\n #endif\n  for (y=0; y < (ssize_t) images->rows; y++)\n   {\n     register const Quantum\n       *magick_restrict Ai,\n      *magick_restrict Ar,\n      *magick_restrict Bi,\n      *magick_restrict Br;\n\n    register Quantum\n      *magick_restrict Ci,\n      *magick_restrict Cr;\n\n    register ssize_t\n      x;\n \n     if (status == MagickFalse)\n       continue;\n    Ar=GetCacheViewVirtualPixels(Ar_view,0,y,\n      MagickMax(Ar_image->columns,Cr_image->columns),1,exception);\n    Ai=GetCacheViewVirtualPixels(Ai_view,0,y,\n      MagickMax(Ai_image->columns,Ci_image->columns),1,exception);\n    Br=GetCacheViewVirtualPixels(Br_view,0,y,\n      MagickMax(Br_image->columns,Cr_image->columns),1,exception);\n    Bi=GetCacheViewVirtualPixels(Bi_view,0,y,\n      MagickMax(Bi_image->columns,Ci_image->columns),1,exception);\n     Cr=QueueCacheViewAuthenticPixels(Cr_view,0,y,Cr_image->columns,1,exception);\n     Ci=QueueCacheViewAuthenticPixels(Ci_view,0,y,Ci_image->columns,1,exception);\n     if ((Ar == (const Quantum *) NULL) || (Ai == (const Quantum *) NULL) || \n        (Br == (const Quantum *) NULL) || (Bi == (const Quantum *) NULL) ||\n        (Cr == (Quantum *) NULL) || (Ci == (Quantum *) NULL))\n      {\n         status=MagickFalse;\n         continue;\n       }\n    for (x=0; x < (ssize_t) images->columns; x++)\n     {\n       register ssize_t\n         i;\n \n      for (i=0; i < (ssize_t) GetPixelChannels(images); i++)\n       {\n         switch (op)\n         {\n          case AddComplexOperator:\n          {\n            Cr[i]=Ar[i]+Br[i];\n            Ci[i]=Ai[i]+Bi[i];\n            break;\n          }\n          case ConjugateComplexOperator:\n          default:\n          {\n            Cr[i]=Ar[i];\n            Ci[i]=(-Bi[i]);\n            break;\n          }\n          case DivideComplexOperator:\n          {\n             double\n               gamma;\n \n            gamma=PerceptibleReciprocal(Br[i]*Br[i]+Bi[i]*Bi[i]+snr);\n            Cr[i]=gamma*(Ar[i]*Br[i]+Ai[i]*Bi[i]);\n            Ci[i]=gamma*(Ai[i]*Br[i]-Ar[i]*Bi[i]);\n             break;\n           }\n           case MagnitudePhaseComplexOperator:\n           {\n            Cr[i]=sqrt(Ar[i]*Ar[i]+Ai[i]*Ai[i]);\n            Ci[i]=atan2(Ai[i],Ar[i])/(2.0*MagickPI)+0.5;\n             break;\n           }\n           case MultiplyComplexOperator:\n           {\n            Cr[i]=QuantumScale*(Ar[i]*Br[i]-Ai[i]*Bi[i]);\n            Ci[i]=QuantumScale*(Ai[i]*Br[i]+Ar[i]*Bi[i]);\n             break;\n           }\n           case RealImaginaryComplexOperator:\n          {\n            Cr[i]=Ar[i]*cos(2.0*MagickPI*(Ai[i]-0.5));\n            Ci[i]=Ar[i]*sin(2.0*MagickPI*(Ai[i]-0.5));\n            break;\n          }\n          case SubtractComplexOperator:\n          {\n            Cr[i]=Ar[i]-Br[i];\n            Ci[i]=Ai[i]-Bi[i];\n            break;\n          }\n        }\n      }\n      Ar+=GetPixelChannels(Ar_image);\n      Ai+=GetPixelChannels(Ai_image);\n      Br+=GetPixelChannels(Br_image);\n      Bi+=GetPixelChannels(Bi_image);\n      Cr+=GetPixelChannels(Cr_image);\n      Ci+=GetPixelChannels(Ci_image);\n    }\n    if (SyncCacheViewAuthenticPixels(Ci_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (SyncCacheViewAuthenticPixels(Cr_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (images->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n#endif\n        progress++;\n        proceed=SetImageProgress(images,ComplexImageTag,progress,images->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  Cr_view=DestroyCacheView(Cr_view);\n  Ci_view=DestroyCacheView(Ci_view);\n  Br_view=DestroyCacheView(Br_view);\n  Bi_view=DestroyCacheView(Bi_view);\n  Ar_view=DestroyCacheView(Ar_view);\n  Ai_view=DestroyCacheView(Ai_view);\n  if (status == MagickFalse)\n    complex_images=DestroyImageList(complex_images);\n  return(complex_images);\n}\n", "target": 1, "idx": 183371}
{"func": "void DiceResponseHandler::DeleteTokenFetcher(DiceTokenFetcher* token_fetcher) {\n  for (auto it = token_fetchers_.begin(); it != token_fetchers_.end(); ++it) {\n    if (it->get() == token_fetcher) {\n      token_fetchers_.erase(it);\n      return;\n    }\n  }\n  NOTREACHED();\n}\n", "target": 0, "idx": 155778}
{"func": "cifs_mount(struct super_block *sb, struct cifs_sb_info *cifs_sb,\n\t\tchar *mount_data_global, const char *devname)\n{\n\tint rc;\n\tint xid;\n\tstruct smb_vol *volume_info;\n\tstruct cifsSesInfo *pSesInfo;\n\tstruct cifsTconInfo *tcon;\n\tstruct TCP_Server_Info *srvTcp;\n\tchar   *full_path;\n\tchar *mount_data = mount_data_global;\n\tstruct tcon_link *tlink;\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\tstruct dfs_info3_param *referrals = NULL;\n\tunsigned int num_referrals = 0;\n\tint referral_walks_count = 0;\ntry_mount_again:\n#endif\n\trc = 0;\n\ttcon = NULL;\n\tpSesInfo = NULL;\n\tsrvTcp = NULL;\n\tfull_path = NULL;\n\ttlink = NULL;\n\n\txid = GetXid();\n\n\tvolume_info = kzalloc(sizeof(struct smb_vol), GFP_KERNEL);\n\tif (!volume_info) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (cifs_parse_mount_options(mount_data, devname, volume_info)) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (volume_info->nullauth) {\n\t\tcFYI(1, \"null user\");\n\t\tvolume_info->username = \"\";\n\t} else if (volume_info->username) {\n\t\t/* BB fixme parse for domain name here */\n\t\tcFYI(1, \"Username: %s\", volume_info->username);\n\t} else {\n\t\tcifserror(\"No username specified\");\n\t/* In userspace mount helper we can get user name from alternate\n\t   locations such as env variables and files on disk */\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* this is needed for ASCII cp to Unicode converts */\n\tif (volume_info->iocharset == NULL) {\n\t\t/* load_nls_default cannot return null */\n\t\tvolume_info->local_nls = load_nls_default();\n\t} else {\n\t\tvolume_info->local_nls = load_nls(volume_info->iocharset);\n\t\tif (volume_info->local_nls == NULL) {\n\t\t\tcERROR(1, \"CIFS mount error: iocharset %s not found\",\n\t\t\t\t volume_info->iocharset);\n\t\t\trc = -ELIBACC;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tcifs_sb->local_nls = volume_info->local_nls;\n\n\t/* get a reference to a tcp session */\n\tsrvTcp = cifs_get_tcp_session(volume_info);\n\tif (IS_ERR(srvTcp)) {\n\t\trc = PTR_ERR(srvTcp);\n\t\tgoto out;\n\t}\n\n\t/* get a reference to a SMB session */\n\tpSesInfo = cifs_get_smb_ses(srvTcp, volume_info);\n\tif (IS_ERR(pSesInfo)) {\n\t\trc = PTR_ERR(pSesInfo);\n\t\tpSesInfo = NULL;\n\t\tgoto mount_fail_check;\n\t}\n\n\tsetup_cifs_sb(volume_info, cifs_sb);\n\tif (pSesInfo->capabilities & CAP_LARGE_FILES)\n\t\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\telse\n\t\tsb->s_maxbytes = MAX_NON_LFS;\n\n\t/* BB FIXME fix time_gran to be larger for LANMAN sessions */\n\tsb->s_time_gran = 100;\n\n\t/* search for existing tcon to this server share */\n\ttcon = cifs_get_tcon(pSesInfo, volume_info);\n\tif (IS_ERR(tcon)) {\n\t\trc = PTR_ERR(tcon);\n\t\ttcon = NULL;\n\t\tgoto remote_path_check;\n\t}\n\n\t/* do not care if following two calls succeed - informational */\n\tif (!tcon->ipc) {\n\t\tCIFSSMBQFSDeviceInfo(xid, tcon);\n\t\tCIFSSMBQFSAttributeInfo(xid, tcon);\n\t}\n\n\t/* tell server which Unix caps we support */\n\tif (tcon->ses->capabilities & CAP_UNIX)\n\t\t/* reset of caps checks mount to see if unix extensions\n\t\t   disabled for just this mount */\n\t\treset_cifs_unix_caps(xid, tcon, sb, volume_info);\n\telse\n\t\ttcon->unix_ext = 0; /* server does not support them */\n\n\t/* convert forward to back slashes in prepath here if needed */\n\tif ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) == 0)\n\t\tconvert_delimiter(cifs_sb->prepath, CIFS_DIR_SEP(cifs_sb));\n\n\tif ((tcon->unix_ext == 0) && (cifs_sb->rsize > (1024 * 127))) {\n\t\tcifs_sb->rsize = 1024 * 127;\n\t\tcFYI(DBG2, \"no very large read support, rsize now 127K\");\n\t}\n\tif (!(tcon->ses->capabilities & CAP_LARGE_WRITE_X))\n\t\tcifs_sb->wsize = min(cifs_sb->wsize,\n\t\t\t       (tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE));\n\tif (!(tcon->ses->capabilities & CAP_LARGE_READ_X))\n\t\tcifs_sb->rsize = min(cifs_sb->rsize,\n\t\t\t       (tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE));\n \n remote_path_check:\n \t/* check if a whole path (including prepath) is not remote */\n\tif (!rc && cifs_sb->prepathlen && tcon) {\n \t\t/* build_path_to_root works only when we have a valid tcon */\n \t\tfull_path = cifs_build_path_to_root(cifs_sb, tcon);\n \t\tif (full_path == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto mount_fail_check;\n\t\t}\n\t\trc = is_path_accessible(xid, tcon, cifs_sb, full_path);\n\t\tif (rc != 0 && rc != -EREMOTE) {\n\t\t\tkfree(full_path);\n\t\t\tgoto mount_fail_check;\n\t\t}\n\t\tkfree(full_path);\n\t}\n\n\t/* get referral if needed */\n\tif (rc == -EREMOTE) {\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\t\tif (referral_walks_count > MAX_NESTED_LINKS) {\n\t\t\t/*\n\t\t\t * BB: when we implement proper loop detection,\n\t\t\t *     we will remove this check. But now we need it\n\t\t\t *     to prevent an indefinite loop if 'DFS tree' is\n\t\t\t *     misconfigured (i.e. has loops).\n\t\t\t */\n\t\t\trc = -ELOOP;\n\t\t\tgoto mount_fail_check;\n\t\t}\n\t\t/* convert forward to back slashes in prepath here if needed */\n\t\tif ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) == 0)\n\t\t\tconvert_delimiter(cifs_sb->prepath,\n\t\t\t\t\tCIFS_DIR_SEP(cifs_sb));\n\t\tfull_path = build_unc_path_to_root(volume_info, cifs_sb);\n\t\tif (IS_ERR(full_path)) {\n\t\t\trc = PTR_ERR(full_path);\n\t\t\tgoto mount_fail_check;\n\t\t}\n\n\t\tcFYI(1, \"Getting referral for: %s\", full_path);\n\t\trc = get_dfs_path(xid, pSesInfo , full_path + 1,\n\t\t\tcifs_sb->local_nls, &num_referrals, &referrals,\n\t\t\tcifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR);\n\t\tif (!rc && num_referrals > 0) {\n\t\t\tchar *fake_devname = NULL;\n\n\t\t\tif (mount_data != mount_data_global)\n\t\t\t\tkfree(mount_data);\n\n\t\t\tmount_data = cifs_compose_mount_options(\n\t\t\t\t\tcifs_sb->mountdata, full_path + 1,\n\t\t\t\t\treferrals, &fake_devname);\n\n\t\t\tfree_dfs_info_array(referrals, num_referrals);\n\t\t\tkfree(fake_devname);\n\t\t\tkfree(full_path);\n\n\t\t\tif (IS_ERR(mount_data)) {\n\t\t\t\trc = PTR_ERR(mount_data);\n\t\t\t\tmount_data = NULL;\n\t\t\t\tgoto mount_fail_check;\n\t\t\t}\n\n\t\t\tif (tcon)\n\t\t\t\tcifs_put_tcon(tcon);\n\t\t\telse if (pSesInfo)\n\t\t\t\tcifs_put_smb_ses(pSesInfo);\n\n\t\t\tcleanup_volume_info(&volume_info);\n\t\t\treferral_walks_count++;\n\t\t\tFreeXid(xid);\n\t\t\tgoto try_mount_again;\n\t\t}\n#else /* No DFS support, return error on mount */\n\t\trc = -EOPNOTSUPP;\n#endif\n\t}\n\n\tif (rc)\n\t\tgoto mount_fail_check;\n\n\t/* now, hang the tcon off of the superblock */\n\ttlink = kzalloc(sizeof *tlink, GFP_KERNEL);\n\tif (tlink == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto mount_fail_check;\n\t}\n\n\ttlink->tl_uid = pSesInfo->linux_uid;\n\ttlink->tl_tcon = tcon;\n\ttlink->tl_time = jiffies;\n\tset_bit(TCON_LINK_MASTER, &tlink->tl_flags);\n\tset_bit(TCON_LINK_IN_TREE, &tlink->tl_flags);\n\n\tcifs_sb->master_tlink = tlink;\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tqueue_delayed_work(system_nrt_wq, &cifs_sb->prune_tlinks,\n\t\t\t\tTLINK_IDLE_EXPIRE);\n\nmount_fail_check:\n\t/* on error free sesinfo and tcon struct if needed */\n\tif (rc) {\n\t\tif (mount_data != mount_data_global)\n\t\t\tkfree(mount_data);\n\t\t/* If find_unc succeeded then rc == 0 so we can not end */\n\t\t/* up accidentally freeing someone elses tcon struct */\n\t\tif (tcon)\n\t\t\tcifs_put_tcon(tcon);\n\t\telse if (pSesInfo)\n\t\t\tcifs_put_smb_ses(pSesInfo);\n\t\telse\n\t\t\tcifs_put_tcp_session(srvTcp);\n\t\tgoto out;\n\t}\n\n\t/* volume_info->password is freed above when existing session found\n\t(in which case it is not needed anymore) but when new sesion is created\n\tthe password ptr is put in the new session structure (in which case the\n\tpassword will be freed at unmount time) */\nout:\n\t/* zero out password before freeing */\n\tcleanup_volume_info(&volume_info);\n\tFreeXid(xid);\n\treturn rc;\n}\n", "target": 1, "idx": 178917}
{"func": "status_t MPEG4Extractor::readMetaData() {\n if (mInitCheck != NO_INIT) {\n return mInitCheck;\n }\n\n off64_t offset = 0;\n status_t err;\n while (true) {\n off64_t orig_offset = offset;\n        err = parseChunk(&offset, 0);\n\n if (err != OK && err != UNKNOWN_ERROR) {\n break;\n } else if (offset <= orig_offset) {\n            ALOGE(\"did not advance: 0x%lld->0x%lld\", orig_offset, offset);\n            err = ERROR_MALFORMED;\n break;\n } else if (err == OK) {\n continue;\n }\n\n uint32_t hdr[2];\n if (mDataSource->readAt(offset, hdr, 8) < 8) {\n break;\n }\n uint32_t chunk_type = ntohl(hdr[1]);\n if (chunk_type == FOURCC('m', 'o', 'o', 'f')) {\n            mMoofOffset = offset;\n } else if (chunk_type != FOURCC('m', 'd', 'a', 't')) {\n continue;\n }\n break;\n }\n\n if (mInitCheck == OK) {\n if (mHasVideo) {\n            mFileMetaData->setCString(\n                    kKeyMIMEType, MEDIA_MIMETYPE_CONTAINER_MPEG4);\n } else {\n            mFileMetaData->setCString(kKeyMIMEType, \"audio/mp4\");\n }\n } else {\n        mInitCheck = err;\n }\n\n    CHECK_NE(err, (status_t)NO_INIT);\n\n int psshsize = 0;\n for (size_t i = 0; i < mPssh.size(); i++) {\n        psshsize += 20 + mPssh[i].datalen;\n }\n if (psshsize) {\n char *buf = (char*)malloc(psshsize);\n char *ptr = buf;\n for (size_t i = 0; i < mPssh.size(); i++) {\n            memcpy(ptr, mPssh[i].uuid, 20); // uuid + length\n            memcpy(ptr + 20, mPssh[i].data, mPssh[i].datalen);\n            ptr += (20 + mPssh[i].datalen);\n }\n        mFileMetaData->setData(kKeyPssh, 'pssh', buf, psshsize);\n        free(buf);\n }\n return mInitCheck;\n}\n", "target": 0, "idx": 170379}
{"func": "BGD_DECLARE(gdImagePtr) gdImageCreateFromWebpPtr (int size, void *data)\n{\n\tgdImagePtr im;\n\tgdIOCtx *in = gdNewDynamicCtxEx(size, data, 0);\n\tif (!in)\n\t\treturn 0;\n\tim = gdImageCreateFromWebpCtx(in);\n\tin->gd_free(in);\n\treturn im;\n}\n", "target": 0, "idx": 49724}
{"func": "PHP_FUNCTION(imageconvolution)\n{\n\tzval *SIM, *hash_matrix;\n\tzval **var = NULL, **var2 = NULL;\n\tgdImagePtr im_src = NULL;\n\tdouble div, offset;\n\tint nelem, i, j, res;\n\tfloat matrix[3][3] = {{0,0,0}, {0,0,0}, {0,0,0}};\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"radd\", &SIM, &hash_matrix, &div, &offset) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, \"Image\", le_gd);\n\n\tnelem = zend_hash_num_elements(Z_ARRVAL_P(hash_matrix));\n\tif (nelem != 3) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"You must have 3x3 array\");\n\t\tRETURN_FALSE;\n\t}\n\n\tfor (i=0; i<3; i++) {\n\t\tif (zend_hash_index_find(Z_ARRVAL_P(hash_matrix), (i), (void **) &var) == SUCCESS && Z_TYPE_PP(var) == IS_ARRAY) {\n\t\t\tif (Z_TYPE_PP(var) != IS_ARRAY || zend_hash_num_elements(Z_ARRVAL_PP(var)) != 3 ) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"You must have 3x3 array\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n \n \t\t\tfor (j=0; j<3; j++) {\n \t\t\t\tif (zend_hash_index_find(Z_ARRVAL_PP(var), (j), (void **) &var2) == SUCCESS) {\n\t\t\t\t\tSEPARATE_ZVAL(var2);\n\t\t\t\t\tconvert_to_double(*var2);\n\t\t\t\t\tmatrix[i][j] = (float)Z_DVAL_PP(var2);\n \t\t\t\t} else {\n \t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"You must have a 3x3 matrix\");\n \t\t\t\t\tRETURN_FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tres = gdImageConvolution(im_src, matrix, (float)div, (float)offset);\n\n\tif (res) {\n\t\tRETURN_TRUE;\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n", "target": 1, "idx": 179598}
{"func": "void setAnimationUpdateIfNeeded(StyleResolverState& state, Element& element)\n{\n    if (RuntimeEnabledFeatures::webAnimationsCSSEnabled() && state.animationUpdate())\n        element.ensureActiveAnimations()->cssAnimations().setPendingUpdate(state.takeAnimationUpdate());\n}\n", "target": 0, "idx": 127409}
{"func": "krb5_gss_process_context_token(minor_status, context_handle,\n                               token_buffer)\n    OM_uint32 *minor_status;\n    gss_ctx_id_t context_handle;\n    gss_buffer_t token_buffer;\n{\n    krb5_gss_ctx_id_rec *ctx;\n    OM_uint32 majerr;\n \n     ctx = (krb5_gss_ctx_id_t) context_handle;\n \n    if (! ctx->established) {\n         *minor_status = KG_CTX_INCOMPLETE;\n         return(GSS_S_NO_CONTEXT);\n     }\n \n     /* \"unseal\" the token */\n \n     if (GSS_ERROR(majerr = kg_unseal(minor_status, context_handle,\n                                     token_buffer,\n                                     GSS_C_NO_BUFFER, NULL, NULL,\n                                      KG_TOK_DEL_CTX)))\n         return(majerr);\n \n    /* that's it.  delete the context */\n    return(krb5_gss_delete_sec_context(minor_status, &context_handle,\n                                       GSS_C_NO_BUFFER));\n }\n", "target": 1, "idx": 179995}
{"func": "EntryInfoResult::EntryInfoResult() : error(GDATA_FILE_ERROR_FAILED) {\n}\n", "target": 0, "idx": 125496}
{"func": "bool OSExchangeData::HasAnyFormat(\n    int formats,\n    const std::set<CustomFormat>& custom_formats) const {\n  if ((formats & STRING) != 0 && HasString())\n    return true;\n  if ((formats & URL) != 0 && HasURL())\n    return true;\n#if defined(OS_WIN)\n  if ((formats & FILE_CONTENTS) != 0 && provider_->HasFileContents())\n    return true;\n#endif\n#if defined(OS_WIN) || defined(USE_AURA)\n  if ((formats & HTML) != 0 && provider_->HasHtml())\n    return true;\n#endif\n  if ((formats & FILE_NAME) != 0 && provider_->HasFile())\n    return true;\n  for (std::set<CustomFormat>::const_iterator i = custom_formats.begin();\n       i != custom_formats.end(); ++i) {\n    if (HasCustomFormat(*i))\n      return true;\n  }\n  return false;\n}\n", "target": 0, "idx": 134588}
{"func": " static char *ps_files_path_create(char *buf, size_t buflen, ps_files *data, const char *key)\n {\n{\n\tsize_t len;\n\tconst char *p;\n\tchar c;\n\tint ret = 1;\n\n\tfor (p = key; (c = *p); p++) {\n\t\t/* valid characters are a..z,A..Z,0..9 */\n\t\tif (!((c >= 'a' && c <= 'z')\n\t\t\t\t|| (c >= 'A' && c <= 'Z')\n\t\t\t\t|| (c >= '0' && c <= '9')\n\t\t\t\t|| c == ','\n\t\t\t\t|| c == '-')) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tlen = p - key;\n\n\t/* Somewhat arbitrary length limit here, but should be way more than\n\t   anyone needs and avoids file-level warnings later on if we exceed MAX_PATH */\n\tif (len == 0 || len > 128) {\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\nstatic char *ps_files_path_create(char *buf, size_t buflen, ps_files *data, const char *key)\n{\n\tsize_t key_len;\n\tconst char *p;\n\tint i;\n\tint n;\n\n\tkey_len = strlen(key);\n\tif (key_len <= data->dirdepth ||\n\t\tbuflen < (strlen(data->basedir) + 2 * data->dirdepth + key_len + 5 + sizeof(FILE_PREFIX))) {\n\t\treturn NULL;\n\t}\n\n\tp = key;\n\tmemcpy(buf, data->basedir, data->basedir_len);\n\tn = data->basedir_len;\n\tbuf[n++] = PHP_DIR_SEPARATOR;\n\tfor (i = 0; i < (int)data->dirdepth; i++) {\n\t\tbuf[n++] = *p++;\n\t\tbuf[n++] = PHP_DIR_SEPARATOR;\n\t}\n\tmemcpy(buf + n, FILE_PREFIX, sizeof(FILE_PREFIX) - 1);\n\tn += sizeof(FILE_PREFIX) - 1;\n\tmemcpy(buf + n, key, key_len);\n\tn += key_len;\n \n                ps_files_close(data);\n \n               if (!ps_files_valid_key(key)) {\n                        php_error_docref(NULL TSRMLS_CC, E_WARNING, \"The session id is too long or contains illegal characters, valid characters are a-z, A-Z, 0-9 and '-,'\");\n                       PS(invalid_session_id) = 1;\n                        return;\n                }\n                if (!ps_files_path_create(buf, sizeof(buf), data, key)) {\n                        return;\n                }\n\tif (data->fd != -1) {\n#ifdef PHP_WIN32\n\t\t/* On Win32 locked files that are closed without being explicitly unlocked\n\t\t   will be unlocked only when \"system resources become available\". */\n\t\tflock(data->fd, LOCK_UN);\n#endif\n\t\tclose(data->fd);\n\t\tdata->fd = -1;\n\t}\n}\n\nstatic void ps_files_open(ps_files *data, const char *key TSRMLS_DC)\n{\n\tchar buf[MAXPATHLEN];\n\n\tif (data->fd < 0 || !data->lastkey || strcmp(key, data->lastkey)) {\n\t\tif (data->lastkey) {\n\t\t\tefree(data->lastkey);\n\t\t\tdata->lastkey = NULL;\n\t\t}\n\n\t\tps_files_close(data);\n\n\t\tif (!ps_files_valid_key(key)) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"The session id is too long or contains illegal characters, valid characters are a-z, A-Z, 0-9 and '-,'\");\n\t\t\tPS(invalid_session_id) = 1;\n\t\t\treturn;\n\t\t}\n\t\tif (!ps_files_path_create(buf, sizeof(buf), data, key)) {\n\t\t\treturn;\n\t\t}\n\n\t\tdata->lastkey = estrdup(key);\n\n\t\tdata->fd = VCWD_OPEN_MODE(buf, O_CREAT | O_RDWR | O_BINARY, data->filemode);\n\n\t\tif (data->fd != -1) {\n#ifndef PHP_WIN32\n\t\t\t/* check to make sure that the opened file is not a symlink, linking to data outside of allowable dirs */\n\t\t\tif (PG(open_basedir)) {\n\t\t\t\tstruct stat sbuf;\n\n\t\t\t\tif (fstat(data->fd, &sbuf)) {\n\t\t\t\t\tclose(data->fd);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (S_ISLNK(sbuf.st_mode) && php_check_open_basedir(buf TSRMLS_CC)) {\n\t\t\t\t\tclose(data->fd);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\tflock(data->fd, LOCK_EX);\n\n#ifdef F_SETFD\n# ifndef FD_CLOEXEC\n#  define FD_CLOEXEC 1\n# endif\n\t\t\tif (fcntl(data->fd, F_SETFD, FD_CLOEXEC)) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"fcntl(%d, F_SETFD, FD_CLOEXEC) failed: %s (%d)\", data->fd, strerror(errno), errno);\n\t\t\t}\n#endif\n\t\t} else {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"open(%s, O_RDWR) failed: %s (%d)\", buf, strerror(errno), errno);\n\t\t}\n\t}\n}\n\nstatic int ps_files_cleanup_dir(const char *dirname, int maxlifetime TSRMLS_DC)\n{\n\tDIR *dir;\n\tchar dentry[sizeof(struct dirent) + MAXPATHLEN];\n\tstruct dirent *entry = (struct dirent *) &dentry;\n\tstruct stat sbuf;\n\tchar buf[MAXPATHLEN];\n\ttime_t now;\n\tint nrdels = 0;\n\tsize_t dirname_len;\n\n\tdir = opendir(dirname);\n\tif (!dir) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"ps_files_cleanup_dir: opendir(%s) failed: %s (%d)\", dirname, strerror(errno), errno);\n\t\treturn (0);\n\t}\n\n\ttime(&now);\n\n        return (nrdels);\n }\n \n #define PS_FILES_DATA ps_files *data = PS_GET_MOD_DATA()\n \n PS_OPEN_FUNC(files)\n\t\t\t\t\t\t(now - sbuf.st_mtime) > maxlifetime) {\n\t\t\t\t\tVCWD_UNLINK(buf);\n\t\t\t\t\tnrdels++;\n\t\t\t\t}\n\t\t\t}\n", "target": 1, "idx": 178042}
{"func": "bool IsFormSubmit(const NavigationEntry* entry) {\n  return (ui::PageTransitionStripQualifier(entry->GetTransitionType()) ==\n          ui::PAGE_TRANSITION_FORM_SUBMIT);\n}\n", "target": 0, "idx": 130382}
{"func": "void ResourceDispatcherHostImpl::BeginRequest(\n    int request_id,\n    const ResourceHostMsg_Request& request_data,\n    IPC::Message* sync_result,  // only valid for sync\n    int route_id) {\n   int process_type = filter_->process_type();\n   int child_id = filter_->child_id();\n \n   if (IsBrowserSideNavigationEnabled() &&\n       IsResourceTypeFrame(request_data.resource_type) &&\n      !request_data.url.SchemeIs(url::kBlobScheme)) {\n    bad_message::ReceivedBadMessage(filter_, bad_message::RDH_INVALID_URL);\n    return;\n  }\n\n  if (request_data.priority < net::MINIMUM_PRIORITY ||\n      request_data.priority > net::MAXIMUM_PRIORITY) {\n    bad_message::ReceivedBadMessage(filter_, bad_message::RDH_INVALID_PRIORITY);\n    return;\n  }\n\n  char url_buf[128];\n  base::strlcpy(url_buf, request_data.url.spec().c_str(), arraysize(url_buf));\n  base::debug::Alias(url_buf);\n\n  LoaderMap::iterator it = pending_loaders_.find(\n      GlobalRequestID(request_data.transferred_request_child_id,\n                      request_data.transferred_request_request_id));\n  if (it != pending_loaders_.end()) {\n    if (it->second->is_transferring()) {\n      ResourceLoader* deferred_loader = it->second.get();\n      UpdateRequestForTransfer(child_id, route_id, request_id,\n                               request_data, it);\n      deferred_loader->CompleteTransfer();\n    } else {\n      bad_message::ReceivedBadMessage(\n          filter_, bad_message::RDH_REQUEST_NOT_TRANSFERRING);\n    }\n    return;\n  }\n\n  ResourceContext* resource_context = NULL;\n  net::URLRequestContext* request_context = NULL;\n  filter_->GetContexts(request_data.resource_type, request_data.origin_pid,\n                       &resource_context, &request_context);\n  CHECK(ContainsKey(active_resource_contexts_, resource_context));\n\n  net::HttpRequestHeaders headers;\n  headers.AddHeadersFromString(request_data.headers);\n\n  if (is_shutdown_ ||\n      !ShouldServiceRequest(process_type, child_id, request_data, headers,\n                            filter_, resource_context)) {\n    AbortRequestBeforeItStarts(filter_, sync_result, request_id);\n    return;\n  }\n\n  if (delegate_ && !delegate_->ShouldBeginRequest(request_data.method,\n                                                  request_data.url,\n                                                  request_data.resource_type,\n                                                  resource_context)) {\n    AbortRequestBeforeItStarts(filter_, sync_result, request_id);\n    return;\n  }\n\n  scoped_ptr<net::URLRequest> new_request = request_context->CreateRequest(\n      request_data.url, request_data.priority, NULL);\n\n  new_request->set_method(request_data.method);\n  new_request->set_first_party_for_cookies(\n      request_data.first_party_for_cookies);\n  new_request->set_initiator(request_data.request_initiator);\n\n  if (request_data.resource_type == RESOURCE_TYPE_MAIN_FRAME) {\n    new_request->set_first_party_url_policy(\n        net::URLRequest::UPDATE_FIRST_PARTY_URL_ON_REDIRECT);\n  }\n\n  const Referrer referrer(request_data.referrer, request_data.referrer_policy);\n  SetReferrerForRequest(new_request.get(), referrer);\n\n  new_request->SetExtraRequestHeaders(headers);\n\n  storage::BlobStorageContext* blob_context =\n      GetBlobStorageContext(filter_->blob_storage_context());\n  if (request_data.request_body.get()) {\n    if (blob_context) {\n      AttachRequestBodyBlobDataHandles(\n          request_data.request_body.get(),\n          blob_context);\n    }\n    new_request->set_upload(UploadDataStreamBuilder::Build(\n        request_data.request_body.get(),\n        blob_context,\n        filter_->file_system_context(),\n        BrowserThread::GetMessageLoopProxyForThread(BrowserThread::FILE)\n            .get()));\n  }\n\n  bool allow_download = request_data.allow_download &&\n      IsResourceTypeFrame(request_data.resource_type);\n  bool do_not_prompt_for_login = request_data.do_not_prompt_for_login;\n  bool is_sync_load = sync_result != NULL;\n\n  ChildProcessSecurityPolicyImpl* policy =\n      ChildProcessSecurityPolicyImpl::GetInstance();\n  bool report_raw_headers = request_data.report_raw_headers;\n  if (report_raw_headers && !policy->CanReadRawCookies(child_id)) {\n    VLOG(1) << \"Denied unauthorized request for raw headers\";\n    report_raw_headers = false;\n  }\n  int load_flags =\n      BuildLoadFlagsForRequest(request_data, child_id, is_sync_load);\n  if (request_data.resource_type == RESOURCE_TYPE_PREFETCH ||\n      request_data.resource_type == RESOURCE_TYPE_FAVICON) {\n    do_not_prompt_for_login = true;\n  }\n  if (request_data.resource_type == RESOURCE_TYPE_IMAGE &&\n      HTTP_AUTH_RELATION_BLOCKED_CROSS ==\n          HttpAuthRelationTypeOf(request_data.url,\n                                 request_data.first_party_for_cookies)) {\n    do_not_prompt_for_login = true;\n    load_flags |= net::LOAD_DO_NOT_USE_EMBEDDED_IDENTITY;\n  }\n\n  bool support_async_revalidation =\n      !is_sync_load && async_revalidation_manager_ &&\n      AsyncRevalidationManager::QualifiesForAsyncRevalidation(request_data);\n\n  if (support_async_revalidation)\n    load_flags |= net::LOAD_SUPPORT_ASYNC_REVALIDATION;\n\n  if (is_sync_load) {\n    DCHECK_EQ(request_data.priority, net::MAXIMUM_PRIORITY);\n    DCHECK_NE(load_flags & net::LOAD_IGNORE_LIMITS, 0);\n  } else {\n    DCHECK_EQ(load_flags & net::LOAD_IGNORE_LIMITS, 0);\n  }\n  new_request->SetLoadFlags(load_flags);\n\n  ResourceRequestInfoImpl* extra_info = new ResourceRequestInfoImpl(\n      process_type, child_id, route_id,\n      -1,  // frame_tree_node_id\n      request_data.origin_pid, request_id, request_data.render_frame_id,\n      request_data.is_main_frame, request_data.parent_is_main_frame,\n      request_data.resource_type, request_data.transition_type,\n      request_data.should_replace_current_entry,\n      false,  // is download\n      false,  // is stream\n      allow_download, request_data.has_user_gesture,\n      request_data.enable_load_timing, request_data.enable_upload_progress,\n      do_not_prompt_for_login, request_data.referrer_policy,\n      request_data.visiblity_state, resource_context, filter_->GetWeakPtr(),\n      report_raw_headers, !is_sync_load,\n      IsUsingLoFi(request_data.lofi_state, delegate_, *new_request,\n                  resource_context,\n                  request_data.resource_type == RESOURCE_TYPE_MAIN_FRAME),\n      support_async_revalidation ? request_data.headers : std::string());\n  extra_info->AssociateWithRequest(new_request.get());\n\n  if (new_request->url().SchemeIs(url::kBlobScheme)) {\n    storage::BlobProtocolHandler::SetRequestedBlobDataHandle(\n        new_request.get(),\n        filter_->blob_storage_context()->context()->GetBlobDataFromPublicURL(\n            new_request->url()));\n  }\n\n  const bool should_skip_service_worker =\n      request_data.skip_service_worker || is_sync_load;\n  ServiceWorkerRequestHandler::InitializeHandler(\n      new_request.get(), filter_->service_worker_context(), blob_context,\n      child_id, request_data.service_worker_provider_id,\n      should_skip_service_worker,\n      request_data.fetch_request_mode, request_data.fetch_credentials_mode,\n      request_data.fetch_redirect_mode, request_data.resource_type,\n      request_data.fetch_request_context_type, request_data.fetch_frame_type,\n      request_data.request_body);\n\n  if (base::CommandLine::ForCurrentProcess()->HasSwitch(\n          switches::kEnableExperimentalWebPlatformFeatures)) {\n    ForeignFetchRequestHandler::InitializeHandler(\n        new_request.get(), filter_->service_worker_context(), blob_context,\n        child_id, request_data.service_worker_provider_id,\n        should_skip_service_worker,\n        request_data.fetch_request_mode, request_data.fetch_credentials_mode,\n        request_data.fetch_redirect_mode, request_data.resource_type,\n        request_data.fetch_request_context_type, request_data.fetch_frame_type,\n        request_data.request_body);\n  }\n\n  AppCacheInterceptor::SetExtraRequestInfo(\n      new_request.get(), filter_->appcache_service(), child_id,\n      request_data.appcache_host_id, request_data.resource_type,\n      request_data.should_reset_appcache);\n\n  scoped_ptr<ResourceHandler> handler(\n       CreateResourceHandler(\n           new_request.get(),\n           request_data, sync_result, route_id, process_type, child_id,\n           resource_context));\n\n  if (handler)\n    BeginRequestInternal(std::move(new_request), std::move(handler));\n}\n", "target": 1, "idx": 186239}
{"func": "SMB2_sess_auth_rawntlmssp_authenticate(struct SMB2_sess_data *sess_data)\n{\n\tint rc;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tstruct smb2_sess_setup_req *req;\n\tstruct smb2_sess_setup_rsp *rsp = NULL;\n\tunsigned char *ntlmssp_blob = NULL;\n\tbool use_spnego = false; /* else use raw ntlmssp */\n\tu16 blob_length = 0;\n\n\trc = SMB2_sess_alloc_buffer(sess_data);\n\tif (rc)\n\t\tgoto out;\n\n\treq = (struct smb2_sess_setup_req *) sess_data->iov[0].iov_base;\n\treq->hdr.sync_hdr.SessionId = ses->Suid;\n\n\trc = build_ntlmssp_auth_blob(&ntlmssp_blob, &blob_length, ses,\n\t\t\t\t\tsess_data->nls_cp);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"build_ntlmssp_auth_blob failed %d\\n\", rc);\n\t\tgoto out;\n\t}\n\n\tif (use_spnego) {\n\t\t/* BB eventually need to add this */\n\t\tcifs_dbg(VFS, \"spnego not supported for SMB2 yet\\n\");\n\t\trc = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\tsess_data->iov[1].iov_base = ntlmssp_blob;\n\tsess_data->iov[1].iov_len = blob_length;\n\n\trc = SMB2_sess_sendreceive(sess_data);\n\tif (rc)\n\t\tgoto out;\n\n\trsp = (struct smb2_sess_setup_rsp *)sess_data->iov[0].iov_base;\n\n\tses->Suid = rsp->hdr.sync_hdr.SessionId;\n\tses->session_flags = le16_to_cpu(rsp->SessionFlags);\n\tif (ses->session_flags & SMB2_SESSION_FLAG_ENCRYPT_DATA)\n\t\tcifs_dbg(VFS, \"SMB3 encryption not supported yet\\n\");\n\n\trc = SMB2_sess_establish_session(sess_data);\nout:\n\tkfree(ntlmssp_blob);\n\tSMB2_sess_free_buffer(sess_data);\n\tkfree(ses->ntlmssp);\n\tses->ntlmssp = NULL;\n\tsess_data->result = rc;\n\tsess_data->func = NULL;\n}\n", "target": 0, "idx": 84920}
{"func": "static void lg_remove(struct hid_device *hdev)\n{\n\tstruct lg_drv_data *drv_data = hid_get_drvdata(hdev);\n\tif (drv_data->quirks & LG_FF4)\n\t\tlg4ff_deinit(hdev);\n\n\thid_hw_stop(hdev);\n\tkfree(drv_data);\n}\n", "target": 0, "idx": 38116}
{"func": "void EnterpriseEnrollmentScreen::OnPolicyStateChanged(\n    policy::CloudPolicySubsystem::PolicySubsystemState state,\n    policy::CloudPolicySubsystem::ErrorDetails error_details) {\n\n  if (is_showing_) {\n    switch (state) {\n      case policy::CloudPolicySubsystem::UNENROLLED:\n        return;\n      case policy::CloudPolicySubsystem::BAD_GAIA_TOKEN:\n      case policy::CloudPolicySubsystem::LOCAL_ERROR:\n        actor_->ShowFatalEnrollmentError();\n        break;\n      case policy::CloudPolicySubsystem::UNMANAGED:\n        actor_->ShowAccountError();\n        break;\n      case policy::CloudPolicySubsystem::NETWORK_ERROR:\n        actor_->ShowNetworkEnrollmentError();\n        break;\n      case policy::CloudPolicySubsystem::TOKEN_FETCHED:\n        WriteInstallAttributesData();\n        return;\n      case policy::CloudPolicySubsystem::SUCCESS:\n        registrar_.reset();\n        UMA_HISTOGRAM_ENUMERATION(policy::kMetricEnrollment,\n                                  policy::kMetricEnrollmentOK,\n                                  policy::kMetricEnrollmentSize);\n        actor_->ShowConfirmationScreen();\n        return;\n    }\n    if (state == policy::CloudPolicySubsystem::UNMANAGED) {\n      UMA_HISTOGRAM_ENUMERATION(policy::kMetricEnrollment,\n                                policy::kMetricEnrollmentNotSupported,\n                                policy::kMetricEnrollmentSize);\n    } else {\n      UMA_HISTOGRAM_ENUMERATION(policy::kMetricEnrollment,\n                                policy::kMetricEnrollmentPolicyFailed,\n                                policy::kMetricEnrollmentSize);\n    }\n    LOG(WARNING) << \"Policy subsystem error during enrollment: \" << state\n                 << \" details: \" << error_details;\n  }\n \n   registrar_.reset();\n  g_browser_process->browser_policy_connector()->DeviceStopAutoRetry();\n }\n", "target": 1, "idx": 183734}
{"func": "TIFFWriteEncodedStrip(TIFF* tif, uint32 strip, void* data, tmsize_t cc)\n{\n\tstatic const char module[] = \"TIFFWriteEncodedStrip\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint16 sample;\n\n\tif (!WRITECHECKSTRIPS(tif, module))\n\t\treturn ((tmsize_t) -1);\n\t/*\n\t * Check strip array to make sure there's space.\n\t * We don't support dynamically growing files that\n\t * have data organized in separate bitplanes because\n\t * it's too painful.  In that case we require that\n\t * the imagelength be set properly before the first\n\t * write (so that the strips array will be fully\n\t * allocated above).\n\t */\n\tif (strip >= td->td_nstrips) {\n\t\tif (td->td_planarconfig == PLANARCONFIG_SEPARATE) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t    \"Can not grow image by strips when using separate planes\");\n\t\t\treturn ((tmsize_t) -1);\n\t\t}\n\t\tif (!TIFFGrowStrips(tif, 1, module))\n\t\t\treturn ((tmsize_t) -1);\n\t\ttd->td_stripsperimage =\n\t\t    TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);  \n\t}\n\t/*\n\t * Handle delayed allocation of data buffer.  This\n\t * permits it to be sized according to the directory\n\t * info.\n\t */\n\tif (!BUFFERCHECK(tif))\n\t\treturn ((tmsize_t) -1);\n\n        tif->tif_flags |= TIFF_BUF4WRITE;\n\ttif->tif_curstrip = strip;\n\n        if (td->td_stripsperimage == 0) {\n                TIFFErrorExt(tif->tif_clientdata, module, \"Zero strips per image\");\n                return ((tmsize_t) -1);\n        }\n\n\ttif->tif_row = (strip % td->td_stripsperimage) * td->td_rowsperstrip;\n\tif ((tif->tif_flags & TIFF_CODERSETUP) == 0) {\n\t\tif (!(*tif->tif_setupencode)(tif))\n\t\t\treturn ((tmsize_t) -1);\n\t\ttif->tif_flags |= TIFF_CODERSETUP;\n\t}\n\n\tif( td->td_stripbytecount[strip] > 0 )\n        {\n            /* Make sure that at the first attempt of rewriting the tile, we will have */\n            /* more bytes available in the output buffer than the previous byte count, */\n            /* so that TIFFAppendToStrip() will detect the overflow when it is called the first */\n            /* time if the new compressed tile is bigger than the older one. (GDAL #4771) */\n            if( tif->tif_rawdatasize <= (tmsize_t)td->td_stripbytecount[strip] )\n            {\n                if( !(TIFFWriteBufferSetup(tif, NULL,\n                    (tmsize_t)TIFFroundup_64((uint64)(td->td_stripbytecount[strip] + 1), 1024))) )\n                    return ((tmsize_t)(-1));\n            }\n\n\t    /* Force TIFFAppendToStrip() to consider placing data at end\n               of file. */\n            tif->tif_curoff = 0;\n        }\n\n    tif->tif_rawcc = 0;\n    tif->tif_rawcp = tif->tif_rawdata;\n\n\ttif->tif_flags &= ~TIFF_POSTENCODE;\n\n    /* shortcut to avoid an extra memcpy() */\n    if( td->td_compression == COMPRESSION_NONE )\n    {\n        /* swab if needed - note that source buffer will be altered */\n        tif->tif_postdecode( tif, (uint8*) data, cc );\n\n        if (!isFillOrder(tif, td->td_fillorder) &&\n            (tif->tif_flags & TIFF_NOBITREV) == 0)\n            TIFFReverseBits((uint8*) data, cc);\n\n        if (cc > 0 &&\n            !TIFFAppendToStrip(tif, strip, (uint8*) data, cc))\n            return ((tmsize_t) -1);\n        return (cc);\n    }\n\n\tsample = (uint16)(strip / td->td_stripsperimage);\n\tif (!(*tif->tif_preencode)(tif, sample))\n\t\treturn ((tmsize_t) -1);\n\n        /* swab if needed - note that source buffer will be altered */\n\ttif->tif_postdecode( tif, (uint8*) data, cc );\n\n\tif (!(*tif->tif_encodestrip)(tif, (uint8*) data, cc, sample))\n\t\treturn ((tmsize_t) -1);\n\tif (!(*tif->tif_postencode)(tif))\n\t\treturn ((tmsize_t) -1);\n\tif (!isFillOrder(tif, td->td_fillorder) &&\n\t    (tif->tif_flags & TIFF_NOBITREV) == 0)\n\t\tTIFFReverseBits(tif->tif_rawdata, tif->tif_rawcc);\n\tif (tif->tif_rawcc > 0 &&\n\t    !TIFFAppendToStrip(tif, strip, tif->tif_rawdata, tif->tif_rawcc))\n\t\treturn ((tmsize_t) -1);\n\ttif->tif_rawcc = 0;\n\ttif->tif_rawcp = tif->tif_rawdata;\n\treturn (cc);\n}\n", "target": 0, "idx": 48326}
{"func": "static int ovl_readlink(struct dentry *dentry, char __user *buf, int bufsiz)\n{\n\tstruct path realpath;\n\tstruct inode *realinode;\n\n\tovl_path_real(dentry, &realpath);\n\trealinode = realpath.dentry->d_inode;\n\n\tif (!realinode->i_op->readlink)\n\t\treturn -EINVAL;\n\n\ttouch_atime(&realpath);\n\n\treturn realinode->i_op->readlink(realpath.dentry, buf, bufsiz);\n}\n", "target": 0, "idx": 41435}
{"func": "LayoutUnit RenderBox::computeReplacedLogicalWidthRespectingMinMaxWidth(LayoutUnit logicalWidth, ShouldComputePreferred shouldComputePreferred) const\n{\n    LayoutUnit minLogicalWidth = (shouldComputePreferred == ComputePreferred && style()->logicalMinWidth().isPercent()) || style()->logicalMinWidth().isUndefined() ? logicalWidth : computeReplacedLogicalWidthUsing(style()->logicalMinWidth());\n    LayoutUnit maxLogicalWidth = (shouldComputePreferred == ComputePreferred && style()->logicalMaxWidth().isPercent()) || style()->logicalMaxWidth().isUndefined() ? logicalWidth : computeReplacedLogicalWidthUsing(style()->logicalMaxWidth());\n    return max(minLogicalWidth, min(logicalWidth, maxLogicalWidth));\n}\n", "target": 0, "idx": 124850}
{"func": "static bool cmd_ibm_sense_condition(IDEState *s, uint8_t cmd)\n{\n    switch (s->feature) {\n    case 0x01:  /* sense temperature in device */\n        s->nsector = 0x50;      /* +20 C */\n        break;\n    default:\n        ide_abort_command(s);\n        return true;\n    }\n\n    return true;\n}\n", "target": 0, "idx": 6693}
{"func": "void AXObject::tokenVectorFromAttribute(Vector<String>& tokens,\n                                        const QualifiedName& attribute) const {\n  Node* node = this->getNode();\n  if (!node || !node->isElementNode())\n    return;\n\n  String attributeValue = getAttribute(attribute).getString();\n  if (attributeValue.isEmpty())\n    return;\n\n  attributeValue.simplifyWhiteSpace();\n  attributeValue.split(' ', tokens);\n}\n", "target": 0, "idx": 138210}
{"func": "void InlineSigninHelper::OnClientOAuthSuccessAndBrowserOpened(\n    const ClientOAuthResult& result,\n    Profile* profile,\n    Profile::CreateStatus status) {\n  if (is_force_sign_in_with_usermanager_)\n    UnlockProfileAndHideLoginUI(profile_->GetPath(), handler_.get());\n  Browser* browser = NULL;\n  if (handler_) {\n    browser = handler_->GetDesktopBrowser();\n  }\n\n  AboutSigninInternals* about_signin_internals =\n      AboutSigninInternalsFactory::GetForProfile(profile_);\n  about_signin_internals->OnRefreshTokenReceived(\"Successful\");\n\n  std::string account_id =\n      AccountTrackerServiceFactory::GetForProfile(profile_)\n          ->SeedAccountInfo(gaia_id_, email_);\n\n  signin_metrics::AccessPoint access_point =\n      signin::GetAccessPointForPromoURL(current_url_);\n  signin_metrics::Reason reason =\n      signin::GetSigninReasonForPromoURL(current_url_);\n\n  SigninManager* signin_manager = SigninManagerFactory::GetForProfile(profile_);\n  std::string primary_email =\n      signin_manager->GetAuthenticatedAccountInfo().email;\n  if (gaia::AreEmailsSame(email_, primary_email) &&\n      (reason == signin_metrics::Reason::REASON_REAUTHENTICATION ||\n       reason == signin_metrics::Reason::REASON_UNLOCK) &&\n      !password_.empty() && profiles::IsLockAvailable(profile_)) {\n    LocalAuth::SetLocalAuthCredentials(profile_, password_);\n  }\n\n#if defined(SYNC_PASSWORD_REUSE_DETECTION_ENABLED)\n  if (!password_.empty()) {\n    scoped_refptr<password_manager::PasswordStore> password_store =\n        PasswordStoreFactory::GetForProfile(profile_,\n                                            ServiceAccessType::EXPLICIT_ACCESS);\n    if (password_store && !primary_email.empty()) {\n      password_store->SaveGaiaPasswordHash(\n          primary_email, base::UTF8ToUTF16(password_),\n          password_manager::metrics_util::SyncPasswordHashChange::\n              SAVED_ON_CHROME_SIGNIN);\n    }\n  }\n#endif\n\n   if (reason == signin_metrics::Reason::REASON_REAUTHENTICATION ||\n       reason == signin_metrics::Reason::REASON_UNLOCK ||\n       reason == signin_metrics::Reason::REASON_ADD_SECONDARY_ACCOUNT) {\n    ProfileOAuth2TokenServiceFactory::GetForProfile(profile_)->\n        UpdateCredentials(account_id, result.refresh_token);\n \n     if (signin::IsAutoCloseEnabledInURL(current_url_)) {\n      bool show_account_management = ShouldShowAccountManagement(\n          current_url_,\n          AccountConsistencyModeManager::IsMirrorEnabledForProfile(profile_));\n      base::ThreadTaskRunnerHandle::Get()->PostTask(\n          FROM_HERE, base::BindOnce(&InlineLoginHandlerImpl::CloseTab, handler_,\n                                    show_account_management));\n    }\n\n    if (reason == signin_metrics::Reason::REASON_REAUTHENTICATION ||\n        reason == signin_metrics::Reason::REASON_UNLOCK) {\n      signin_manager->MergeSigninCredentialIntoCookieJar();\n    }\n    LogSigninReason(reason);\n  } else {\n    browser_sync::ProfileSyncService* sync_service =\n        ProfileSyncServiceFactory::GetForProfile(profile_);\n    SigninErrorController* error_controller =\n        SigninErrorControllerFactory::GetForProfile(profile_);\n\n    OneClickSigninSyncStarter::StartSyncMode start_mode =\n        OneClickSigninSyncStarter::CONFIRM_SYNC_SETTINGS_FIRST;\n    if (access_point == signin_metrics::AccessPoint::ACCESS_POINT_SETTINGS ||\n        choose_what_to_sync_) {\n      bool show_settings_without_configure =\n          error_controller->HasError() && sync_service &&\n          sync_service->IsFirstSetupComplete();\n      if (!show_settings_without_configure)\n        start_mode = OneClickSigninSyncStarter::CONFIGURE_SYNC_FIRST;\n    }\n\n    OneClickSigninSyncStarter::ConfirmationRequired confirmation_required =\n        confirm_untrusted_signin_ ?\n            OneClickSigninSyncStarter::CONFIRM_UNTRUSTED_SIGNIN :\n            OneClickSigninSyncStarter::CONFIRM_AFTER_SIGNIN;\n\n    bool start_signin = !HandleCrossAccountError(\n        result.refresh_token, confirmation_required, start_mode);\n    if (start_signin) {\n      CreateSyncStarter(browser, current_url_, result.refresh_token,\n                        OneClickSigninSyncStarter::CURRENT_PROFILE, start_mode,\n                        confirmation_required);\n      base::ThreadTaskRunnerHandle::Get()->DeleteSoon(FROM_HERE, this);\n    }\n  }\n}\n", "target": 1, "idx": 186550}
{"func": "void SocketStreamDispatcherHost::ContinueSSLRequest(\n    const content::GlobalRequestID& id) {\n  int socket_id = id.request_id;\n  DVLOG(1) << \"SocketStreamDispatcherHost::ContinueSSLRequest socket_id=\"\n           << socket_id;\n  DCHECK_NE(content::kNoSocketId, socket_id);\n  SocketStreamHost* socket_stream_host = hosts_.Lookup(socket_id);\n  DCHECK(socket_stream_host);\n  socket_stream_host->ContinueDespiteError();\n}\n", "target": 0, "idx": 116175}
{"func": "static struct cm_timewait_info * cm_create_timewait_info(__be32 local_id)\n{\n\tstruct cm_timewait_info *timewait_info;\n\n\ttimewait_info = kzalloc(sizeof *timewait_info, GFP_KERNEL);\n\tif (!timewait_info)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttimewait_info->work.local_id = local_id;\n\tINIT_DELAYED_WORK(&timewait_info->work.work, cm_work_handler);\n\ttimewait_info->work.cm_event.event = IB_CM_TIMEWAIT_EXIT;\n\treturn timewait_info;\n}\n", "target": 0, "idx": 38354}
{"func": "long AudioTrack::Parse(Segment* pSegment, const Info& info,\n long long element_start, long long element_size,\n AudioTrack*& pResult) {\n if (pResult)\n return -1;\n\n if (info.type != Track::kAudio)\n return -1;\n\n IMkvReader* const pReader = pSegment->m_pReader;\n\n const Settings& s = info.settings;\n  assert(s.start >= 0);\n  assert(s.size >= 0);\n\n long long pos = s.start;\n  assert(pos >= 0);\n\n const long long stop = pos + s.size;\n\n double rate = 8000.0; // MKV default\n long long channels = 1;\n long long bit_depth = 0;\n\n while (pos < stop) {\n long long id, size;\n\n long status = ParseElementHeader(pReader, pos, stop, id, size);\n\n if (status < 0) // error\n return status;\n\n if (id == 0x35) { // Sample Rate\n      status = UnserializeFloat(pReader, pos, size, rate);\n\n if (status < 0)\n return status;\n\n if (rate <= 0)\n return E_FILE_FORMAT_INVALID;\n } else if (id == 0x1F) { // Channel Count\n      channels = UnserializeUInt(pReader, pos, size);\n\n if (channels <= 0)\n return E_FILE_FORMAT_INVALID;\n } else if (id == 0x2264) { // Bit Depth\n      bit_depth = UnserializeUInt(pReader, pos, size);\n\n if (bit_depth <= 0)\n return E_FILE_FORMAT_INVALID;\n\n     }\n \n     pos += size;  // consume payload\n    assert(pos <= stop);\n   }\n \n  assert(pos == stop);\n \n   AudioTrack* const pTrack =\n       new (std::nothrow) AudioTrack(pSegment, element_start, element_size);\n\n if (pTrack == NULL)\n return -1; // generic error\n\n const int status = info.Copy(pTrack->m_info);\n\n if (status) {\n delete pTrack;\n return status;\n }\n\n  pTrack->m_rate = rate;\n  pTrack->m_channels = channels;\n  pTrack->m_bitDepth = bit_depth;\n\n  pResult = pTrack;\n return 0; // success\n}\n", "target": 1, "idx": 187866}
{"func": " static void locationWithCallWithAttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)\n {\n     TestObjectPython* proxyImp = V8TestObjectPython::toNative(info.Holder());\n    TestNode* imp = WTF::getPtr(proxyImp->locationWithCallWith());\n     if (!imp)\n         return;\n     V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID(V8StringResource<>, cppValue, jsValue);\n    imp->setHrefCallWith(callingDOMWindow(info.GetIsolate()), enteredDOMWindow(info.GetIsolate()), cppValue);\n}\n", "target": 1, "idx": 185466}
{"func": "void EventBindings::AttachFilteredEvent(\n    const v8::FunctionCallbackInfo<v8::Value>& args) {\n  CHECK_EQ(2, args.Length());\n  CHECK(args[0]->IsString());\n  CHECK(args[1]->IsObject());\n\n  std::string event_name = *v8::String::Utf8Value(args[0]);\n  if (!context()->HasAccessOrThrowError(event_name))\n    return;\n\n  std::unique_ptr<base::DictionaryValue> filter;\n  {\n    std::unique_ptr<content::V8ValueConverter> converter(\n        content::V8ValueConverter::create());\n    std::unique_ptr<base::Value> filter_value(converter->FromV8Value(\n        v8::Local<v8::Object>::Cast(args[1]), context()->v8_context()));\n    if (!filter_value || !filter_value->IsType(base::Value::TYPE_DICTIONARY)) {\n      args.GetReturnValue().Set(static_cast<int32_t>(-1));\n      return;\n    }\n     filter = base::DictionaryValue::From(std::move(filter_value));\n   }\n \n  base::DictionaryValue* filter_weak = filter.get();\n   int id = g_event_filter.Get().AddEventMatcher(\n       event_name, ParseEventMatcher(std::move(filter)));\n   attached_matcher_ids_.insert(id);\n \n   std::string extension_id = context()->GetExtensionID();\n   if (AddFilter(event_name, extension_id, *filter_weak)) {\n     bool lazy = ExtensionFrameHelper::IsContextForEventPage(context());\n    content::RenderThread::Get()->Send(new ExtensionHostMsg_AddFilteredListener(\n        extension_id, event_name, *filter_weak, lazy));\n  }\n\n  args.GetReturnValue().Set(static_cast<int32_t>(id));\n}\n", "target": 1, "idx": 185973}
{"func": "gst_vorbis_tag_add_coverart (GstTagList * tags, const gchar * img_data_base64,\n     gint base64_len)\n {\n   GstBuffer *img;\n  guchar *img_data;\n   gsize img_len;\n   guint save = 0;\n   gint state = 0;\n \n   if (base64_len < 2)\n     goto not_enough_data;\n \n  img_data = g_try_malloc0 (base64_len * 3 / 4);\n  if (img_data == NULL)\n    goto alloc_failed;\n  img_len = g_base64_decode_step (img_data_base64, base64_len, img_data,\n      &state, &save);\n \n   if (img_len == 0)\n     goto decode_failed;\n \n  img = gst_tag_image_data_to_image_buffer (img_data, img_len,\n       GST_TAG_IMAGE_TYPE_NONE);\n \n   if (img == NULL)\n  gst_tag_list_add (tags, GST_TAG_MERGE_APPEND,\n      GST_TAG_PREVIEW_IMAGE, img, NULL);\n\n       GST_TAG_PREVIEW_IMAGE, img, NULL);\n \n   gst_buffer_unref (img);\n  g_free (img_data);\n   return;\n \n /* ERRORS */\n  {\n    GST_WARNING (\"COVERART tag with too little base64-encoded data\");\n     GST_WARNING (\"COVERART tag with too little base64-encoded data\");\n     return;\n   }\nalloc_failed:\n  {\n    GST_WARNING (\"Couldn't allocate enough memory to decode COVERART tag\");\n    return;\n  }\n decode_failed:\n   {\n    GST_WARNING (\"Couldn't decode bas64 image data from COVERART tag\");\n    g_free (img_data);\n     return;\n   }\n convert_failed:\n   {\n     GST_WARNING (\"Couldn't extract image or image type from COVERART tag\");\n    g_free (img_data);\n     return;\n   }\n }\n", "target": 1, "idx": 177926}
{"func": "Eina_Bool ewk_frame_back(Evas_Object* ewkFrame)\n{\n    return ewk_frame_navigate(ewkFrame, -1);\n}\n", "target": 0, "idx": 115887}
{"func": "int wc_ecc_make_key(WC_RNG* rng, int keysize, ecc_key* key)\n{\n    return wc_ecc_make_key_ex(rng, keysize, key, ECC_CURVE_DEF);\n}\n", "target": 0, "idx": 81907}
{"func": "drive_eject_completed_cb (DBusGMethodInvocation *context,\n                          Device *device,\n                          gboolean job_was_cancelled,\n                          int status,\n                          const char *stderr,\n                          const char *stdout,\n                          gpointer user_data)\n{\n  if (WEXITSTATUS (status) == 0 && !job_was_cancelled)\n    {\n      /* TODO: probably wait for has_media to change to FALSE */\n      dbus_g_method_return (context);\n    }\n  else\n    {\n      if (job_was_cancelled)\n        {\n          throw_error (context, ERROR_CANCELLED, \"Job was cancelled\");\n        }\n      else\n        {\n          throw_error (context,\n                       ERROR_FAILED,\n                       \"Error ejecting: eject exited with exit code %d: %s\",\n                       WEXITSTATUS (status),\n                       stderr);\n        }\n    }\n}\n", "target": 0, "idx": 11687}
{"func": " static int set_register(pegasus_t *pegasus, __u16 indx, __u8 data)\n {\n \tint ret;\n \n \tret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),\n \t\t\t      PEGASUS_REQ_SET_REG, PEGASUS_REQT_WRITE, data,\n\t\t\t      indx, &data, 1, 1000);\n \tif (ret < 0)\n \t\tnetif_dbg(pegasus, drv, pegasus->net,\n \t\t\t  \"%s returned %d\\n\", __func__, ret);\n \treturn ret;\n }\n", "target": 1, "idx": 181389}
{"func": " DeviceOrientationData* InspectorPageAgent::overrideDeviceOrientation(DeviceOrientationData* deviceOrientation)\n{\n    if (m_deviceOrientation)\n        deviceOrientation = m_deviceOrientation.get();\n    return deviceOrientation;\n}\n", "target": 0, "idx": 109313}
{"func": " PageInfoUI::IdentityInfo::IdentityInfo()\n     : identity_status(PageInfo::SITE_IDENTITY_STATUS_UNKNOWN),\n      safe_browsing_status(PageInfo::SAFE_BROWSING_STATUS_NONE),\n       connection_status(PageInfo::SITE_CONNECTION_STATUS_UNKNOWN),\n       show_ssl_decision_revoke_button(false),\n       show_change_password_buttons(false) {}\n", "target": 1, "idx": 186409}
{"func": "HTMLAllCollection* Document::all() {\n  return EnsureCachedCollection<HTMLAllCollection>(kDocAll);\n}\n", "target": 0, "idx": 141302}
{"func": "static inline u64 __scale_tsc(u64 ratio, u64 tsc)\n{\n\treturn mul_u64_u64_shr(tsc, ratio, kvm_tsc_scaling_ratio_frac_bits);\n}\n", "target": 0, "idx": 57664}
{"func": "void RenderViewImpl::DidFlushPaint() {\n  pepper_helper_->ViewFlushedPaint();\n\n  if (!webview())\n    return;\n\n  WebFrame* main_frame = webview()->mainFrame();\n\n  if (!main_frame->provisionalDataSource()) {\n    WebDataSource* ds = main_frame->dataSource();\n    DocumentState* document_state = DocumentState::FromDataSource(ds);\n\n    Time now = Time::Now();\n    if (document_state->first_paint_time().is_null()) {\n      document_state->set_first_paint_time(now);\n    }\n    if (document_state->first_paint_after_load_time().is_null() &&\n        !document_state->finish_load_time().is_null()) {\n      document_state->set_first_paint_after_load_time(now);\n    }\n  }\n}\n", "target": 0, "idx": 123849}
{"func": "gst_pngdec_base_init (gpointer g_class)\n{\n  GstElementClass *element_class = GST_ELEMENT_CLASS (g_class);\n\n  gst_element_class_add_pad_template (element_class,\n      gst_static_pad_template_get (&gst_pngdec_src_pad_template));\n  gst_element_class_add_pad_template (element_class,\n      gst_static_pad_template_get (&gst_pngdec_sink_pad_template));\n  gst_element_class_set_details (element_class, &gst_pngdec_details);\n}\n", "target": 0, "idx": 2852}
{"func": "PlatformSensorFusion::~PlatformSensorFusion() {\n  for (const auto& pair : source_sensors_)\n    pair.second->RemoveClient(this);\n}\n", "target": 0, "idx": 161770}
{"func": "static int acm_tty_put_char(struct tty_struct *tty, unsigned char ch)\n{\n\tstruct acm *acm = tty->driver_data;\n\tstruct acm_wb *cur;\n\tint wbn;\n\tunsigned long flags;\n\noverflow:\n\tcur = acm->putbuffer;\n\tif (!cur) {\n\t\tspin_lock_irqsave(&acm->write_lock, flags);\n\t\twbn = acm_wb_alloc(acm);\n\t\tif (wbn >= 0) {\n\t\t\tcur = &acm->wb[wbn];\n\t\t\tacm->putbuffer = cur;\n\t\t}\n\t\tspin_unlock_irqrestore(&acm->write_lock, flags);\n\t\tif (!cur)\n\t\t\treturn 0;\n\t}\n\n\tif (cur->len == acm->writesize) {\n\t\tacm_tty_flush_chars(tty);\n\t\tgoto overflow;\n\t}\n\n\tcur->buf[cur->len++] = ch;\n\treturn 1;\n}\n", "target": 0, "idx": 54211}
{"func": "void DownloadResourceHandler::OnRequestRedirected(\n    const net::RedirectInfo& redirect_info,\n    network::ResourceResponse* response,\n    std::unique_ptr<ResourceController> controller) {\n  url::Origin new_origin(url::Origin::Create(redirect_info.new_url));\n  if (!follow_cross_origin_redirects_ &&\n      !first_origin_.IsSameOriginWith(new_origin)) {\n    base::PostTaskWithTraits(\n        FROM_HERE, {BrowserThread::UI},\n        base::BindOnce(\n            &NavigateOnUIThread, redirect_info.new_url, request()->url_chain(),\n            Referrer(GURL(redirect_info.new_referrer),\n                      Referrer::NetReferrerPolicyToBlinkReferrerPolicy(\n                          redirect_info.new_referrer_policy)),\n             GetRequestInfo()->HasUserGesture(),\n            GetRequestInfo()->GetWebContentsGetterForRequest()));\n     controller->Cancel();\n     return;\n   }\n  if (core_.OnRequestRedirected()) {\n    controller->Resume();\n  } else {\n    controller->Cancel();\n  }\n}\n", "target": 1, "idx": 187005}
{"func": "bool WebRuntimeFeatures::isPrefixedEncryptedMediaEnabled()\n{\n    return RuntimeEnabledFeatures::prefixedEncryptedMediaEnabled();\n}\n", "target": 0, "idx": 124464}
{"func": "void SynchronousCompositorImpl::UpdateFrameMetaData(\n    const cc::CompositorFrameMetadata& frame_metadata) {\n  RenderWidgetHostViewAndroid* rwhv = static_cast<RenderWidgetHostViewAndroid*>(\n      contents_->GetRenderWidgetHostView());\n  if (rwhv)\n    rwhv->SynchronousFrameMetadata(frame_metadata);\n  DeliverMessages();\n}\n", "target": 0, "idx": 134704}
{"func": "bool AXNodeObject::isMenu() const {\n  return roleValue() == MenuRole;\n}\n", "target": 0, "idx": 138072}
{"func": "static u8 *crypto_authenc_ahash(struct aead_request *req, unsigned int flags)\n{\n\tstruct crypto_aead *authenc = crypto_aead_reqtfm(req);\n\tstruct crypto_authenc_ctx *ctx = crypto_aead_ctx(authenc);\n\tstruct crypto_ahash *auth = ctx->auth;\n\tstruct authenc_request_ctx *areq_ctx = aead_request_ctx(req);\n\tstruct ahash_request *ahreq = (void *)(areq_ctx->tail + ctx->reqoff);\n\tu8 *hash = areq_ctx->tail;\n\tint err;\n\n\thash = (u8 *)ALIGN((unsigned long)hash + crypto_ahash_alignmask(auth),\n\t\t\t   crypto_ahash_alignmask(auth) + 1);\n\n\tahash_request_set_tfm(ahreq, auth);\n\tahash_request_set_crypt(ahreq, areq_ctx->sg, hash,\n\t\t\t\tareq_ctx->cryptlen);\n\tahash_request_set_callback(ahreq, aead_request_flags(req) & flags,\n\t\t\t\t   areq_ctx->complete, req);\n\n\terr = crypto_ahash_digest(ahreq);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn hash;\n}\n", "target": 0, "idx": 45517}
{"func": "void *hns_xgmac_config(struct hns_mac_cb *mac_cb, struct mac_params *mac_param)\n{\n\tstruct mac_driver *mac_drv;\n\n\tmac_drv = devm_kzalloc(mac_cb->dev, sizeof(*mac_drv), GFP_KERNEL);\n\tif (!mac_drv)\n\t\treturn NULL;\n\n\tmac_drv->mac_init = hns_xgmac_init;\n\tmac_drv->mac_enable = hns_xgmac_enable;\n\tmac_drv->mac_disable = hns_xgmac_disable;\n\n\tmac_drv->mac_id = mac_param->mac_id;\n\tmac_drv->mac_mode = mac_param->mac_mode;\n\tmac_drv->io_base = mac_param->vaddr;\n\tmac_drv->dev = mac_param->dev;\n\tmac_drv->mac_cb = mac_cb;\n\n\tmac_drv->set_mac_addr = hns_xgmac_set_pausefrm_mac_addr;\n\tmac_drv->set_an_mode = NULL;\n\tmac_drv->config_loopback = NULL;\n\tmac_drv->config_pad_and_crc = hns_xgmac_config_pad_and_crc;\n\tmac_drv->config_half_duplex = NULL;\n\tmac_drv->set_rx_ignore_pause_frames =\n\t\thns_xgmac_set_rx_ignore_pause_frames;\n\tmac_drv->mac_free = hns_xgmac_free;\n\tmac_drv->adjust_link = NULL;\n\tmac_drv->set_tx_auto_pause_frames = hns_xgmac_set_tx_auto_pause_frames;\n\tmac_drv->config_max_frame_length = hns_xgmac_config_max_frame_length;\n\tmac_drv->mac_pausefrm_cfg = hns_xgmac_pausefrm_cfg;\n\tmac_drv->autoneg_stat = NULL;\n\tmac_drv->get_info = hns_xgmac_get_info;\n\tmac_drv->get_pause_enable = hns_xgmac_get_pausefrm_cfg;\n\tmac_drv->get_link_status = hns_xgmac_get_link_status;\n\tmac_drv->get_regs = hns_xgmac_get_regs;\n\tmac_drv->get_ethtool_stats = hns_xgmac_get_stats;\n\tmac_drv->get_sset_count = hns_xgmac_get_sset_count;\n\tmac_drv->get_regs_count = hns_xgmac_get_regs_count;\n\tmac_drv->get_strings = hns_xgmac_get_strings;\n\tmac_drv->update_stats = hns_xgmac_update_stats;\n\n\treturn (void *)mac_drv;\n}\n", "target": 0, "idx": 85626}
{"func": " static int ohci_bus_start(OHCIState *ohci)\n {\n    ohci->eof_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,\n                    ohci_frame_boundary,\n                    ohci);\n    if (ohci->eof_timer == NULL) {\n        trace_usb_ohci_bus_eof_timer_failed(ohci->name);\n        ohci_die(ohci);\n        return 0;\n    }\n     trace_usb_ohci_start(ohci->name);\n \n     /* Delay the first SOF event by one frame time as\n\n    if (ohci->eof_timer == NULL) {\n        trace_usb_ohci_bus_eof_timer_failed(ohci->name);\n        ohci_die(ohci);\n        return 0;\n    }\n\n    trace_usb_ohci_start(ohci->name);\n\n    /* Delay the first SOF event by one frame time as\n static void ohci_bus_stop(OHCIState *ohci)\n {\n     trace_usb_ohci_stop(ohci->name);\n    if (ohci->eof_timer) {\n        timer_del(ohci->eof_timer);\n        timer_free(ohci->eof_timer);\n    }\n    ohci->eof_timer = NULL;\n }\n \n /* Sets a flag in a port status register but only set it if the port is\n}\n", "target": 1, "idx": 178360}
{"func": "void ImageCapture::SetMediaTrackConstraints(\n    ScriptPromiseResolver* resolver,\n    const HeapVector<MediaTrackConstraintSet>& constraints_vector) {\n  DCHECK_GT(constraints_vector.size(), 0u);\n  if (!service_) {\n    resolver->Reject(DOMException::Create(kNotFoundError, kNoServiceError));\n    return;\n  }\n  auto constraints = constraints_vector[0];\n\n  if ((constraints.hasWhiteBalanceMode() &&\n       !capabilities_.hasWhiteBalanceMode()) ||\n      (constraints.hasExposureMode() && !capabilities_.hasExposureMode()) ||\n      (constraints.hasFocusMode() && !capabilities_.hasFocusMode()) ||\n      (constraints.hasExposureCompensation() &&\n       !capabilities_.hasExposureCompensation()) ||\n      (constraints.hasColorTemperature() &&\n       !capabilities_.hasColorTemperature()) ||\n      (constraints.hasIso() && !capabilities_.hasIso()) ||\n      (constraints.hasBrightness() && !capabilities_.hasBrightness()) ||\n      (constraints.hasContrast() && !capabilities_.hasContrast()) ||\n      (constraints.hasSaturation() && !capabilities_.hasSaturation()) ||\n      (constraints.hasSharpness() && !capabilities_.hasSharpness()) ||\n      (constraints.hasZoom() && !capabilities_.hasZoom()) ||\n      (constraints.hasTorch() && !capabilities_.hasTorch())) {\n    resolver->Reject(\n        DOMException::Create(kNotSupportedError, \"Unsupported constraint(s)\"));\n    return;\n  }\n\n  auto settings = media::mojom::blink::PhotoSettings::New();\n  MediaTrackConstraintSet temp_constraints = current_constraints_;\n\n  settings->has_white_balance_mode = constraints.hasWhiteBalanceMode() &&\n                                     constraints.whiteBalanceMode().IsString();\n  if (settings->has_white_balance_mode) {\n    const auto white_balance_mode =\n        constraints.whiteBalanceMode().GetAsString();\n    if (capabilities_.whiteBalanceMode().Find(white_balance_mode) ==\n        kNotFound) {\n      resolver->Reject(DOMException::Create(kNotSupportedError,\n                                            \"Unsupported whiteBalanceMode.\"));\n      return;\n    }\n    temp_constraints.setWhiteBalanceMode(constraints.whiteBalanceMode());\n    settings->white_balance_mode = ParseMeteringMode(white_balance_mode);\n  }\n  settings->has_exposure_mode =\n      constraints.hasExposureMode() && constraints.exposureMode().IsString();\n  if (settings->has_exposure_mode) {\n    const auto exposure_mode = constraints.exposureMode().GetAsString();\n    if (capabilities_.exposureMode().Find(exposure_mode) == kNotFound) {\n      resolver->Reject(DOMException::Create(kNotSupportedError,\n                                            \"Unsupported exposureMode.\"));\n      return;\n    }\n    temp_constraints.setExposureMode(constraints.exposureMode());\n    settings->exposure_mode = ParseMeteringMode(exposure_mode);\n  }\n\n  settings->has_focus_mode =\n      constraints.hasFocusMode() && constraints.focusMode().IsString();\n  if (settings->has_focus_mode) {\n    const auto focus_mode = constraints.focusMode().GetAsString();\n    if (capabilities_.focusMode().Find(focus_mode) == kNotFound) {\n      resolver->Reject(\n          DOMException::Create(kNotSupportedError, \"Unsupported focusMode.\"));\n      return;\n    }\n    temp_constraints.setFocusMode(constraints.focusMode());\n    settings->focus_mode = ParseMeteringMode(focus_mode);\n  }\n\n  if (constraints.hasPointsOfInterest() &&\n      constraints.pointsOfInterest().IsPoint2DSequence()) {\n    for (const auto& point :\n         constraints.pointsOfInterest().GetAsPoint2DSequence()) {\n      auto mojo_point = media::mojom::blink::Point2D::New();\n      mojo_point->x = point.x();\n      mojo_point->y = point.y();\n      settings->points_of_interest.push_back(std::move(mojo_point));\n    }\n    temp_constraints.setPointsOfInterest(constraints.pointsOfInterest());\n  }\n\n  settings->has_exposure_compensation =\n      constraints.hasExposureCompensation() &&\n      constraints.exposureCompensation().IsDouble();\n  if (settings->has_exposure_compensation) {\n    const auto exposure_compensation =\n        constraints.exposureCompensation().GetAsDouble();\n    if (exposure_compensation < capabilities_.exposureCompensation()->min() ||\n        exposure_compensation > capabilities_.exposureCompensation()->max()) {\n      resolver->Reject(DOMException::Create(\n          kNotSupportedError, \"exposureCompensation setting out of range\"));\n      return;\n    }\n    temp_constraints.setExposureCompensation(\n        constraints.exposureCompensation());\n    settings->exposure_compensation = exposure_compensation;\n  }\n  settings->has_color_temperature = constraints.hasColorTemperature() &&\n                                    constraints.colorTemperature().IsDouble();\n  if (settings->has_color_temperature) {\n    const auto color_temperature = constraints.colorTemperature().GetAsDouble();\n    if (color_temperature < capabilities_.colorTemperature()->min() ||\n        color_temperature > capabilities_.colorTemperature()->max()) {\n      resolver->Reject(DOMException::Create(\n          kNotSupportedError, \"colorTemperature setting out of range\"));\n      return;\n    }\n    temp_constraints.setColorTemperature(constraints.colorTemperature());\n    settings->color_temperature = color_temperature;\n  }\n  settings->has_iso = constraints.hasIso() && constraints.iso().IsDouble();\n  if (settings->has_iso) {\n    const auto iso = constraints.iso().GetAsDouble();\n    if (iso < capabilities_.iso()->min() || iso > capabilities_.iso()->max()) {\n      resolver->Reject(\n          DOMException::Create(kNotSupportedError, \"iso setting out of range\"));\n      return;\n    }\n    temp_constraints.setIso(constraints.iso());\n    settings->iso = iso;\n  }\n\n  settings->has_brightness =\n      constraints.hasBrightness() && constraints.brightness().IsDouble();\n  if (settings->has_brightness) {\n    const auto brightness = constraints.brightness().GetAsDouble();\n    if (brightness < capabilities_.brightness()->min() ||\n        brightness > capabilities_.brightness()->max()) {\n      resolver->Reject(DOMException::Create(kNotSupportedError,\n                                            \"brightness setting out of range\"));\n      return;\n    }\n    temp_constraints.setBrightness(constraints.brightness());\n    settings->brightness = brightness;\n  }\n  settings->has_contrast =\n      constraints.hasContrast() && constraints.contrast().IsDouble();\n  if (settings->has_contrast) {\n    const auto contrast = constraints.contrast().GetAsDouble();\n    if (contrast < capabilities_.contrast()->min() ||\n        contrast > capabilities_.contrast()->max()) {\n      resolver->Reject(DOMException::Create(kNotSupportedError,\n                                            \"contrast setting out of range\"));\n      return;\n    }\n    temp_constraints.setContrast(constraints.contrast());\n    settings->contrast = contrast;\n  }\n  settings->has_saturation =\n      constraints.hasSaturation() && constraints.saturation().IsDouble();\n  if (settings->has_saturation) {\n    const auto saturation = constraints.saturation().GetAsDouble();\n    if (saturation < capabilities_.saturation()->min() ||\n        saturation > capabilities_.saturation()->max()) {\n      resolver->Reject(DOMException::Create(kNotSupportedError,\n                                            \"saturation setting out of range\"));\n      return;\n    }\n    temp_constraints.setSaturation(constraints.saturation());\n    settings->saturation = saturation;\n  }\n  settings->has_sharpness =\n      constraints.hasSharpness() && constraints.sharpness().IsDouble();\n  if (settings->has_sharpness) {\n    const auto sharpness = constraints.sharpness().GetAsDouble();\n    if (sharpness < capabilities_.sharpness()->min() ||\n        sharpness > capabilities_.sharpness()->max()) {\n      resolver->Reject(DOMException::Create(kNotSupportedError,\n                                            \"sharpness setting out of range\"));\n      return;\n    }\n    temp_constraints.setSharpness(constraints.sharpness());\n    settings->sharpness = sharpness;\n  }\n\n  settings->has_zoom = constraints.hasZoom() && constraints.zoom().IsDouble();\n  if (settings->has_zoom) {\n    const auto zoom = constraints.zoom().GetAsDouble();\n    if (zoom < capabilities_.zoom()->min() ||\n        zoom > capabilities_.zoom()->max()) {\n      resolver->Reject(DOMException::Create(kNotSupportedError,\n                                            \"zoom setting out of range\"));\n      return;\n    }\n    temp_constraints.setZoom(constraints.zoom());\n    settings->zoom = zoom;\n  }\n\n  settings->has_torch =\n      constraints.hasTorch() && constraints.torch().IsBoolean();\n  if (settings->has_torch) {\n    const auto torch = constraints.torch().GetAsBoolean();\n    if (torch && !capabilities_.torch()) {\n      resolver->Reject(\n          DOMException::Create(kNotSupportedError, \"torch not supported\"));\n      return;\n    }\n    temp_constraints.setTorch(constraints.torch());\n    settings->torch = torch;\n  }\n\n  current_constraints_ = temp_constraints;\n\n  service_requests_.insert(resolver);\n \n   MediaTrackConstraints resolver_constraints;\n   resolver_constraints.setAdvanced(constraints_vector);\n  auto resolver_cb = WTF::Bind(&ImageCapture::ResolveWithMediaTrackConstraints,\n                               WrapPersistent(this), resolver_constraints);\n \n   service_->SetOptions(\n       stream_track_->Component()->Source()->Id(), std::move(settings),\n      ConvertToBaseCallback(WTF::Bind(\n          &ImageCapture::OnMojoSetOptions, WrapPersistent(this),\n          WrapPersistent(resolver), WTF::Passed(std::move(resolver_cb)),\n          false /* trigger_take_photo */)));\n}\n", "target": 1, "idx": 186940}
{"func": "static void bt_for_each(struct blk_mq_hw_ctx *hctx,\n\t\tstruct blk_mq_bitmap_tags *bt, unsigned int off,\n\t\tbusy_iter_fn *fn, void *data, bool reserved)\n{\n\tstruct request *rq;\n\tint bit, i;\n\n\tfor (i = 0; i < bt->map_nr; i++) {\n\t\tstruct blk_align_bitmap *bm = &bt->map[i];\n\n \t\tfor (bit = find_first_bit(&bm->word, bm->depth);\n \t\t     bit < bm->depth;\n \t\t     bit = find_next_bit(&bm->word, bm->depth, bit + 1)) {\n\t\t     \trq = blk_mq_tag_to_rq(hctx->tags, off + bit);\n \t\t\tif (rq->q == hctx->queue)\n \t\t\t\tfn(hctx, rq, data, reserved);\n \t\t}\n\n\t\toff += (1 << bt->bits_per_word);\n\t}\n}\n", "target": 1, "idx": 182627}
{"func": "xdr_dpol_arg(XDR *xdrs, dpol_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_nullstring(xdrs, &objp->name)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n", "target": 0, "idx": 46049}
{"func": "void Vp9Parser::ReadSegmentationMap() {\n   for (size_t i = 0; i < Vp9Segmentation::kNumTreeProbs; i++) {\n    segmentation_.tree_probs[i] =\n         reader_.ReadBool() ? reader_.ReadLiteral(8) : kVp9MaxProb;\n   }\n \n   for (size_t i = 0; i < Vp9Segmentation::kNumPredictionProbs; i++)\n    segmentation_.pred_probs[i] = kVp9MaxProb;\n \n  segmentation_.temporal_update = reader_.ReadBool();\n  if (segmentation_.temporal_update) {\n     for (size_t i = 0; i < Vp9Segmentation::kNumPredictionProbs; i++) {\n       if (reader_.ReadBool())\n        segmentation_.pred_probs[i] = reader_.ReadLiteral(8);\n     }\n   }\n }\n", "target": 1, "idx": 183539}
{"func": "PS_SERIALIZER_DECODE_FUNC(php_binary) /* {{{ */\n{\n\tconst char *p;\n\tchar *name;\n\tconst char *endptr = val + vallen;\n\tzval *current;\n\tint namelen;\n\tint has_value;\n\tphp_unserialize_data_t var_hash;\n\n\tPHP_VAR_UNSERIALIZE_INIT(var_hash);\n\n\tfor (p = val; p < endptr; ) {\n\t\tzval **tmp;\n                namelen = ((unsigned char)(*p)) & (~PS_BIN_UNDEF);\n \n                if (namelen < 0 || namelen > PS_BIN_MAX || (p + namelen) >= endptr) {\n                        return FAILURE;\n                }\n\n\t\tname = estrndup(p + 1, namelen);\n\n\t\tp += namelen + 1;\n\n\t\tif (zend_hash_find(&EG(symbol_table), name, namelen + 1, (void **) &tmp) == SUCCESS) {\n\t\t\tif ((Z_TYPE_PP(tmp) == IS_ARRAY && Z_ARRVAL_PP(tmp) == &EG(symbol_table)) || *tmp == PS(http_session_vars)) {\n\t\t\t\tefree(name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (has_value) {\n\t\t\tALLOC_INIT_ZVAL(current);\n\t\t\tif (php_var_unserialize(&current, (const unsigned char **) &p, (const unsigned char *) endptr, &var_hash TSRMLS_CC)) {\n\t\t\t\tphp_set_session_var(name, namelen, current, &var_hash  TSRMLS_CC);\n\t\t\t} else {\n\t\t\t\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tvar_push_dtor_no_addref(&var_hash, &current);\n\t\t}\n\t\tPS_ADD_VARL(name, namelen);\n\t\tefree(name);\n\t}\n\n\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\n\treturn SUCCESS;\n}\n/* }}} */\n", "target": 1, "idx": 178153}
{"func": " static void parse_cfg(int flags, int argc, const char **argv, cfg_t *cfg) {\n   int i;\n   memset(cfg, 0, sizeof(cfg_t));\n   cfg->debug_file = stderr;\n \n  for (i = 0; i < argc; i++) {\n    if (strncmp(argv[i], \"max_devices=\", 12) == 0)\n      sscanf(argv[i], \"max_devices=%u\", &cfg->max_devs);\n    if (strcmp(argv[i], \"manual\") == 0)\n      cfg->manual = 1;\n    if (strcmp(argv[i], \"debug\") == 0)\n      cfg->debug = 1;\n    if (strcmp(argv[i], \"nouserok\") == 0)\n      cfg->nouserok = 1;\n    if (strcmp(argv[i], \"openasuser\") == 0)\n      cfg->openasuser = 1;\n    if (strcmp(argv[i], \"alwaysok\") == 0)\n      cfg->alwaysok = 1;\n    if (strcmp(argv[i], \"interactive\") == 0)\n      cfg->interactive = 1;\n    if (strcmp(argv[i], \"cue\") == 0)\n      cfg->cue = 1;\n    if (strcmp(argv[i], \"nodetect\") == 0)\n      cfg->nodetect = 1;\n    if (strncmp(argv[i], \"authfile=\", 9) == 0)\n      cfg->auth_file = argv[i] + 9;\n    if (strncmp(argv[i], \"authpending_file=\", 17) == 0)\n      cfg->authpending_file = argv[i] + 17;\n    if (strncmp(argv[i], \"origin=\", 7) == 0)\n      cfg->origin = argv[i] + 7;\n    if (strncmp(argv[i], \"appid=\", 6) == 0)\n      cfg->appid = argv[i] + 6;\n    if (strncmp(argv[i], \"prompt=\", 7) == 0)\n      cfg->prompt = argv[i] + 7;\n    if (strncmp (argv[i], \"debug_file=\", 11) == 0) {\n      const char *filename = argv[i] + 11;\n      if(strncmp (filename, \"stdout\", 6) == 0) {\n        cfg->debug_file = stdout;\n      }\n      else if(strncmp (filename, \"stderr\", 6) == 0) {\n        cfg->debug_file = stderr;\n      }\n      else if( strncmp (filename, \"syslog\", 6) == 0) {\n         cfg->debug_file = (FILE *)-1;\n       }\n       else {\n        struct stat st;\n        FILE *file;\n        if(lstat(filename, &st) == 0) {\n          if(S_ISREG(st.st_mode)) {\n            file = fopen(filename, \"a\");\n            if(file != NULL) {\n              cfg->debug_file = file;\n            }\n           }\n         }\n       }\n    }\n  }\n\n  if (cfg->debug) {\n    D(cfg->debug_file, \"called.\");\n    D(cfg->debug_file, \"flags %d argc %d\", flags, argc);\n    for (i = 0; i < argc; i++) {\n      D(cfg->debug_file, \"argv[%d]=%s\", i, argv[i]);\n    }\n    D(cfg->debug_file, \"max_devices=%d\", cfg->max_devs);\n    D(cfg->debug_file, \"debug=%d\", cfg->debug);\n    D(cfg->debug_file, \"interactive=%d\", cfg->interactive);\n    D(cfg->debug_file, \"cue=%d\", cfg->cue);\n    D(cfg->debug_file, \"nodetect=%d\", cfg->nodetect);\n    D(cfg->debug_file, \"manual=%d\", cfg->manual);\n    D(cfg->debug_file, \"nouserok=%d\", cfg->nouserok);\n    D(cfg->debug_file, \"openasuser=%d\", cfg->openasuser);\n    D(cfg->debug_file, \"alwaysok=%d\", cfg->alwaysok);\n    D(cfg->debug_file, \"authfile=%s\", cfg->auth_file ? cfg->auth_file : \"(null)\");\n    D(cfg->debug_file, \"authpending_file=%s\", cfg->authpending_file ? cfg->authpending_file : \"(null)\");\n    D(cfg->debug_file, \"origin=%s\", cfg->origin ? cfg->origin : \"(null)\");\n     D(cfg->debug_file, \"appid=%s\", cfg->appid ? cfg->appid : \"(null)\");\n     D(cfg->debug_file, \"prompt=%s\", cfg->prompt ? cfg->prompt : \"(null)\");\n   }\n }\n", "target": 1, "idx": 182834}
{"func": "static int __driver_rfc4106_decrypt(struct aead_request *req)\n{\n\tu8 one_entry_in_sg = 0;\n\tu8 *src, *dst, *assoc;\n\tunsigned long tempCipherLen = 0;\n\t__be32 counter = cpu_to_be32(1);\n\tint retval = 0;\n\tstruct crypto_aead *tfm = crypto_aead_reqtfm(req);\n\tstruct aesni_rfc4106_gcm_ctx *ctx = aesni_rfc4106_gcm_ctx_get(tfm);\n\tu32 key_len = ctx->aes_key_expanded.key_length;\n\tvoid *aes_ctx = &(ctx->aes_key_expanded);\n\tunsigned long auth_tag_len = crypto_aead_authsize(tfm);\n\tu8 iv_and_authTag[32+AESNI_ALIGN];\n\tu8 *iv = (u8 *) PTR_ALIGN((u8 *)iv_and_authTag, AESNI_ALIGN);\n\tu8 *authTag = iv + 16;\n\tstruct scatter_walk src_sg_walk;\n\tstruct scatter_walk assoc_sg_walk;\n\tstruct scatter_walk dst_sg_walk;\n\tunsigned int i;\n\n\tif (unlikely((req->cryptlen < auth_tag_len) ||\n\t\t(req->assoclen != 8 && req->assoclen != 12)))\n\t\treturn -EINVAL;\n\tif (unlikely(auth_tag_len != 8 && auth_tag_len != 12 && auth_tag_len != 16))\n\t        return -EINVAL;\n\tif (unlikely(key_len != AES_KEYSIZE_128 &&\n\t             key_len != AES_KEYSIZE_192 &&\n\t             key_len != AES_KEYSIZE_256))\n\t        return -EINVAL;\n\n\t/* Assuming we are supporting rfc4106 64-bit extended */\n\t/* sequence numbers We need to have the AAD length */\n\t/* equal to 8 or 12 bytes */\n\n\ttempCipherLen = (unsigned long)(req->cryptlen - auth_tag_len);\n\t/* IV below built */\n\tfor (i = 0; i < 4; i++)\n\t\t*(iv+i) = ctx->nonce[i];\n\tfor (i = 0; i < 8; i++)\n\t\t*(iv+4+i) = req->iv[i];\n\t*((__be32 *)(iv+12)) = counter;\n\n\tif ((sg_is_last(req->src)) && (sg_is_last(req->assoc))) {\n\t\tone_entry_in_sg = 1;\n\t\tscatterwalk_start(&src_sg_walk, req->src);\n\t\tscatterwalk_start(&assoc_sg_walk, req->assoc);\n\t\tsrc = scatterwalk_map(&src_sg_walk);\n\t\tassoc = scatterwalk_map(&assoc_sg_walk);\n\t\tdst = src;\n\t\tif (unlikely(req->src != req->dst)) {\n\t\t\tscatterwalk_start(&dst_sg_walk, req->dst);\n\t\t\tdst = scatterwalk_map(&dst_sg_walk);\n\t\t}\n\n\t} else {\n\t\t/* Allocate memory for src, dst, assoc */\n \t\tsrc = kmalloc(req->cryptlen + req->assoclen, GFP_ATOMIC);\n \t\tif (!src)\n \t\t\treturn -ENOMEM;\n\t\tassoc = (src + req->cryptlen + auth_tag_len);\n \t\tscatterwalk_map_and_copy(src, req->src, 0, req->cryptlen, 0);\n \t\tscatterwalk_map_and_copy(assoc, req->assoc, 0,\n \t\t\treq->assoclen, 0);\n\t\tdst = src;\n\t}\n\n\taesni_gcm_dec_tfm(aes_ctx, dst, src, tempCipherLen, iv,\n\t\tctx->hash_subkey, assoc, (unsigned long)req->assoclen,\n\t\tauthTag, auth_tag_len);\n\n\t/* Compare generated tag with passed in tag. */\n\tretval = crypto_memneq(src + tempCipherLen, authTag, auth_tag_len) ?\n\t\t-EBADMSG : 0;\n\n\tif (one_entry_in_sg) {\n\t\tif (unlikely(req->src != req->dst)) {\n\t\t\tscatterwalk_unmap(dst);\n\t\t\tscatterwalk_done(&dst_sg_walk, 0, 0);\n\t\t}\n\t\tscatterwalk_unmap(src);\n\t\tscatterwalk_unmap(assoc);\n \t\tscatterwalk_done(&src_sg_walk, 0, 0);\n \t\tscatterwalk_done(&assoc_sg_walk, 0, 0);\n \t} else {\n\t\tscatterwalk_map_and_copy(dst, req->dst, 0, req->cryptlen, 1);\n \t\tkfree(src);\n \t}\n \treturn retval;\n}\n", "target": 1, "idx": 179798}
{"func": "  void FireInvalidateUnknownVersion(const char* type_name) {\n    const invalidation::ObjectId object_id(\n        ipc::invalidation::ObjectSource::CHROME_SYNC, type_name);\n    invalidation::AckHandle ack_handle(\"fakedata\");\n    EXPECT_CALL(mock_invalidation_client_, Acknowledge(ack_handle));\n    client_.InvalidateUnknownVersion(&mock_invalidation_client_, object_id,\n                                      ack_handle);\n   }\n", "target": 1, "idx": 184522}
{"func": " void WebPluginDelegateProxy::OnGetWindowScriptNPObject(\n    int route_id, bool* success, intptr_t* npobject_ptr) {\n   *success = false;\n   NPObject* npobject = NULL;\n   if (plugin_)\n    npobject = plugin_->GetWindowScriptNPObject();\n\n  if (!npobject)\n    return;\n\n   window_script_object_ = (new NPObjectStub(\n       npobject, channel_host_.get(), route_id, 0, page_url_))->AsWeakPtr();\n   *success = true;\n  *npobject_ptr = reinterpret_cast<intptr_t>(npobject);\n }\n", "target": 1, "idx": 183576}
{"func": "static unsigned char *DecodeImage(Image *blob,Image *image,\n  size_t bytes_per_line,const unsigned int bits_per_pixel,size_t *extent)\n{\n  MagickSizeType\n    number_pixels;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p,\n    *q;\n\n  size_t\n    bytes_per_pixel,\n    length,\n    row_bytes,\n    scanline_length,\n    width;\n\n  ssize_t\n    count,\n    j,\n    y;\n\n  unsigned char\n    *pixels,\n    *scanline;\n\n  /*\n    Determine pixel buffer size.\n  */\n  if (bits_per_pixel <= 8)\n    bytes_per_line&=0x7fff;\n  width=image->columns;\n  bytes_per_pixel=1;\n  if (bits_per_pixel == 16)\n    {\n      bytes_per_pixel=2;\n      width*=2;\n    }\n  else\n    if (bits_per_pixel == 32)\n      width*=image->matte != MagickFalse ? 4 : 3;\n  if (bytes_per_line == 0)\n    bytes_per_line=width;\n  row_bytes=(size_t) (image->columns | 0x8000);\n  if (image->storage_class == DirectClass)\n    row_bytes=(size_t) ((4*image->columns) | 0x8000);\n  /*\n    Allocate pixel and scanline buffer.\n  */\n  pixels=(unsigned char *) AcquireQuantumMemory(image->rows,row_bytes*\n    sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    return((unsigned char *) NULL);\n  *extent=row_bytes*image->rows*sizeof(*pixels);\n  (void) ResetMagickMemory(pixels,0,*extent);\n  scanline=(unsigned char *) AcquireQuantumMemory(row_bytes,2*\n    sizeof(*scanline));\n  if (scanline == (unsigned char *) NULL)\n    return((unsigned char *) NULL);\n  if (bytes_per_line < 8)\n    {\n      /*\n        Pixels are already uncompressed.\n      */\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=pixels+y*width;\n        number_pixels=bytes_per_line;\n        count=ReadBlob(blob,(size_t) number_pixels,scanline);\n        if (count != (ssize_t) number_pixels)\n          {\n            (void) ThrowMagickException(&image->exception,GetMagickModule(),\n              CorruptImageError,\"UnableToUncompressImage\",\"`%s'\",\n              image->filename);\n            break;\n          }\n        p=ExpandBuffer(scanline,&number_pixels,bits_per_pixel);\n        if ((q+number_pixels) > (pixels+(*extent)))\n          {\n            (void) ThrowMagickException(&image->exception,GetMagickModule(),\n              CorruptImageError,\"UnableToUncompressImage\",\"`%s'\",\n              image->filename);\n            break;\n          }\n        (void) CopyMagickMemory(q,p,(size_t) number_pixels);\n      }\n      scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n      return(pixels);\n    }\n  /*\n    Uncompress RLE pixels into uncompressed pixel buffer.\n  */\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    q=pixels+y*width;\n    if (bytes_per_line > 200)\n      scanline_length=ReadBlobMSBShort(blob);\n    else\n      scanline_length=1UL*ReadBlobByte(blob);\n    if (scanline_length >= row_bytes)\n      {\n        (void) ThrowMagickException(&image->exception,GetMagickModule(),\n          CorruptImageError,\"UnableToUncompressImage\",\"`%s'\",image->filename);\n        break;\n      }\n    count=ReadBlob(blob,scanline_length,scanline);\n    if (count != (ssize_t) scanline_length)\n      {\n        (void) ThrowMagickException(&image->exception,GetMagickModule(),\n          CorruptImageError,\"UnableToUncompressImage\",\"`%s'\",image->filename);\n        break;\n      }\n    for (j=0; j < (ssize_t) scanline_length; )\n      if ((scanline[j] & 0x80) == 0)\n        {\n          length=(size_t) ((scanline[j] & 0xff)+1);\n          number_pixels=length*bytes_per_pixel;\n          p=ExpandBuffer(scanline+j+1,&number_pixels,bits_per_pixel);\n          if ((q-pixels+number_pixels) <= *extent)\n            (void) CopyMagickMemory(q,p,(size_t) number_pixels);\n          q+=number_pixels;\n          j+=(ssize_t) (length*bytes_per_pixel+1);\n        }\n      else\n        {\n          length=(size_t) (((scanline[j] ^ 0xff) & 0xff)+2);\n          number_pixels=bytes_per_pixel;\n          p=ExpandBuffer(scanline+j+1,&number_pixels,bits_per_pixel);\n          for (i=0; i < (ssize_t) length; i++)\n          {\n            if ((q-pixels+number_pixels) <= *extent)\n              (void) CopyMagickMemory(q,p,(size_t) number_pixels);\n            q+=number_pixels;\n          }\n          j+=(ssize_t) bytes_per_pixel+1;\n        }\n  }\n  scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n  return(pixels);\n}\n", "target": 0, "idx": 62682}
{"func": "struct sock *llc_sk_alloc(struct net *net, int family, gfp_t priority, struct proto *prot, int kern)\n{\n\tstruct sock *sk = sk_alloc(net, family, priority, prot, kern);\n\n\tif (!sk)\n\t\tgoto out;\n\tllc_sk_init(sk);\n\tsock_init_data(NULL, sk);\n#ifdef LLC_REFCNT_DEBUG\n\tatomic_inc(&llc_sock_nr);\n\tprintk(KERN_DEBUG \"LLC socket %p created in %s, now we have %d alive\\n\", sk,\n\t\t__func__, atomic_read(&llc_sock_nr));\n#endif\nout:\n\treturn sk;\n}\n", "target": 0, "idx": 68211}
{"func": "static uint32_t kvm_get_exit_reason(struct kvm_vcpu *vcpu)\n{\n\tstruct exit_ctl_data *p_exit_data;\n\n\tp_exit_data = kvm_get_exit_data(vcpu);\n\treturn p_exit_data->exit_reason;\n}\n", "target": 0, "idx": 20622}
{"func": "static MagickBooleanType WritePNMImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  char\n    buffer[MagickPathExtent],\n    format,\n    magick[MagickPathExtent];\n\n  const char\n    *value;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  Quantum\n    index;\n\n  QuantumAny\n    pixel;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  register unsigned char\n    *q;\n\n  size_t\n    extent,\n    imageListLength,\n    packet_size;\n\n  ssize_t\n    count,\n    y;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  scene=0;\n  imageListLength=GetImageListLength(image);\n  do\n  {\n    QuantumAny\n      max_value;\n\n    /*\n      Write PNM file header.\n    */\n    packet_size=3;\n    quantum_type=RGBQuantum;\n    (void) CopyMagickString(magick,image_info->magick,MagickPathExtent);\n    max_value=GetQuantumRange(image->depth);\n    switch (magick[1])\n    {\n      case 'A':\n      case 'a':\n      {\n        format='7';\n        break;\n      }\n      case 'B':\n      case 'b':\n      {\n        format='4';\n        if (image_info->compression == NoCompression)\n          format='1';\n        break;\n      }\n      case 'F':\n      case 'f':\n      {\n        format='F';\n        if (SetImageGray(image,exception) != MagickFalse)\n          format='f';\n        break;\n      }\n      case 'G':\n      case 'g':\n      {\n        format='5';\n        if (image_info->compression == NoCompression)\n          format='2';\n        break;\n      }\n      case 'N':\n      case 'n':\n      {\n        if ((image_info->type != TrueColorType) &&\n            (SetImageGray(image,exception) != MagickFalse))\n          {\n            format='5';\n            if (image_info->compression == NoCompression)\n              format='2';\n            if (SetImageMonochrome(image,exception) != MagickFalse)\n              {\n                format='4';\n                if (image_info->compression == NoCompression)\n                  format='1';\n              }\n            break;\n          }\n      }\n      default:\n      {\n        format='6';\n        if (image_info->compression == NoCompression)\n          format='3';\n        break;\n      }\n    }\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"P%c\\n\",format);\n    (void) WriteBlobString(image,buffer);\n    value=GetImageProperty(image,\"comment\",exception);\n    if (value != (const char *) NULL)\n      {\n        register const char\n          *p;\n\n        /*\n          Write comments to file.\n        */\n        (void) WriteBlobByte(image,'#');\n        for (p=value; *p != '\\0'; p++)\n        {\n          (void) WriteBlobByte(image,(unsigned char) *p);\n          if ((*p == '\\n') || (*p == '\\r'))\n            (void) WriteBlobByte(image,'#');\n        }\n        (void) WriteBlobByte(image,'\\n');\n      }\n    if (format != '7')\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g %.20g\\n\",\n          (double) image->columns,(double) image->rows);\n        (void) WriteBlobString(image,buffer);\n      }\n    else\n      {\n        char\n          type[MagickPathExtent];\n\n        /*\n          PAM header.\n        */\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"WIDTH %.20g\\nHEIGHT %.20g\\n\",(double) image->columns,(double)\n          image->rows);\n        (void) WriteBlobString(image,buffer);\n        quantum_type=GetQuantumType(image,exception);\n        switch (quantum_type)\n        {\n          case CMYKQuantum:\n          case CMYKAQuantum:\n          {\n            packet_size=4;\n            (void) CopyMagickString(type,\"CMYK\",MagickPathExtent);\n            break;\n          }\n          case GrayQuantum:\n          case GrayAlphaQuantum:\n          {\n            packet_size=1;\n            (void) CopyMagickString(type,\"GRAYSCALE\",MagickPathExtent);\n            if (IdentifyImageMonochrome(image,exception) != MagickFalse)\n              (void) CopyMagickString(type,\"BLACKANDWHITE\",MagickPathExtent);\n            break;\n          }\n          default:\n          {\n            quantum_type=RGBQuantum;\n            if (image->alpha_trait != UndefinedPixelTrait)\n              quantum_type=RGBAQuantum;\n            packet_size=3;\n            (void) CopyMagickString(type,\"RGB\",MagickPathExtent);\n            break;\n          }\n        }\n        if (image->alpha_trait != UndefinedPixelTrait)\n          {\n            packet_size++;\n            (void) ConcatenateMagickString(type,\"_ALPHA\",MagickPathExtent);\n          }\n        if (image->depth > 32)\n          image->depth=32;\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"DEPTH %.20g\\nMAXVAL %.20g\\n\",(double) packet_size,(double)\n          ((MagickOffsetType) GetQuantumRange(image->depth)));\n        (void) WriteBlobString(image,buffer);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"TUPLTYPE %s\\nENDHDR\\n\",type);\n        (void) WriteBlobString(image,buffer);\n      }\n    /*\n      Convert runextent encoded to PNM raster pixels.\n    */\n    switch (format)\n    {\n      case '1':\n      {\n        unsigned char\n          pixels[2048];\n\n        /*\n          Convert image to a PBM image.\n        */\n        (void) SetImageType(image,BilevelType,exception);\n        q=pixels;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n           {\n             *q++=(unsigned char) (GetPixelLuma(image,p) >= (QuantumRange/2.0) ?\n               '0' : '1');\n            *q++=' ';\n             if ((q-pixels+1) >= (ssize_t) sizeof(pixels))\n               {\n                 *q++='\\n';\n                 (void) WriteBlob(image,q-pixels,pixels);\n                 q=pixels;\n               }\n             p+=GetPixelChannels(image);\n           }\n           *q++='\\n';\n          (void) WriteBlob(image,q-pixels,pixels);\n          q=pixels;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        if (q != pixels)\n          {\n            *q++='\\n';\n            (void) WriteBlob(image,q-pixels,pixels);\n          }\n        break;\n      }\n      case '2':\n      {\n        unsigned char\n          pixels[2048];\n\n        /*\n          Convert image to a PGM image.\n        */\n        if (image->depth <= 8)\n          (void) WriteBlobString(image,\"255\\n\");\n        else\n          if (image->depth <= 16)\n            (void) WriteBlobString(image,\"65535\\n\");\n          else\n            (void) WriteBlobString(image,\"4294967295\\n\");\n        q=pixels;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            index=ClampToQuantum(GetPixelLuma(image,p));\n            if (image->depth <= 8)\n              count=(ssize_t) FormatLocaleString(buffer,MagickPathExtent,\"%u \",\n                ScaleQuantumToChar(index));\n            else\n              if (image->depth <= 16)\n                count=(ssize_t) FormatLocaleString(buffer,MagickPathExtent,\n                  \"%u \",ScaleQuantumToShort(index));\n              else\n                count=(ssize_t) FormatLocaleString(buffer,MagickPathExtent,\n                  \"%u \",ScaleQuantumToLong(index));\n            extent=(size_t) count;\n            if ((q-pixels+extent+1) >= sizeof(pixels))\n              {\n                *q++='\\n';\n                (void) WriteBlob(image,q-pixels,pixels);\n                q=pixels;\n              }\n            (void) strncpy((char *) q,buffer,extent);\n            q+=extent;\n            p+=GetPixelChannels(image);\n          }\n          *q++='\\n';\n          (void) WriteBlob(image,q-pixels,pixels);\n          q=pixels;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        if (q != pixels)\n          {\n            *q++='\\n';\n            (void) WriteBlob(image,q-pixels,pixels);\n          }\n        break;\n      }\n      case '3':\n      {\n        unsigned char\n          pixels[2048];\n\n        /*\n          Convert image to a PNM image.\n        */\n        (void) TransformImageColorspace(image,sRGBColorspace,exception);\n        if (image->depth <= 8)\n          (void) WriteBlobString(image,\"255\\n\");\n        else\n          if (image->depth <= 16)\n            (void) WriteBlobString(image,\"65535\\n\");\n          else\n            (void) WriteBlobString(image,\"4294967295\\n\");\n        q=pixels;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            if (image->depth <= 8)\n              count=(ssize_t) FormatLocaleString(buffer,MagickPathExtent,\n                \"%u %u %u \",ScaleQuantumToChar(GetPixelRed(image,p)),\n                ScaleQuantumToChar(GetPixelGreen(image,p)),\n                ScaleQuantumToChar(GetPixelBlue(image,p)));\n            else\n              if (image->depth <= 16)\n                count=(ssize_t) FormatLocaleString(buffer,MagickPathExtent,\n                  \"%u %u %u \",ScaleQuantumToShort(GetPixelRed(image,p)),\n                  ScaleQuantumToShort(GetPixelGreen(image,p)),\n                  ScaleQuantumToShort(GetPixelBlue(image,p)));\n              else\n                count=(ssize_t) FormatLocaleString(buffer,MagickPathExtent,\n                  \"%u %u %u \",ScaleQuantumToLong(GetPixelRed(image,p)),\n                  ScaleQuantumToLong(GetPixelGreen(image,p)),\n                  ScaleQuantumToLong(GetPixelBlue(image,p)));\n            extent=(size_t) count;\n            if ((q-pixels+extent+2) >= sizeof(pixels))\n              {\n                *q++='\\n';\n                (void) WriteBlob(image,q-pixels,pixels);\n                q=pixels;\n              }\n            (void) strncpy((char *) q,buffer,extent);\n            q+=extent;\n            p+=GetPixelChannels(image);\n          }\n          *q++='\\n';\n          (void) WriteBlob(image,q-pixels,pixels);\n          q=pixels;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        if (q != pixels)\n          {\n            *q++='\\n';\n            (void) WriteBlob(image,q-pixels,pixels);\n          }\n        break;\n      }\n      case '4':\n      {\n        register unsigned char\n          *pixels;\n\n        /*\n          Convert image to a PBM image.\n        */\n        (void) SetImageType(image,BilevelType,exception);\n        image->depth=1;\n        quantum_info=AcquireQuantumInfo(image_info,image);\n        if (quantum_info == (QuantumInfo *) NULL)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) SetQuantumEndian(image,quantum_info,MSBEndian);\n        quantum_info->min_is_white=MagickTrue;\n        pixels=GetQuantumPixels(quantum_info);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          extent=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            GrayQuantum,pixels,exception);\n          count=WriteBlob(image,extent,pixels);\n          if (count != (ssize_t) extent)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        quantum_info=DestroyQuantumInfo(quantum_info);\n        break;\n      }\n      case '5':\n      {\n        register unsigned char\n          *pixels;\n\n        /*\n          Convert image to a PGM image.\n        */\n        if (image->depth > 32)\n          image->depth=32;\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g\\n\",(double)\n          ((MagickOffsetType) GetQuantumRange(image->depth)));\n        (void) WriteBlobString(image,buffer);\n        quantum_info=AcquireQuantumInfo(image_info,image);\n        if (quantum_info == (QuantumInfo *) NULL)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) SetQuantumEndian(image,quantum_info,MSBEndian);\n        quantum_info->min_is_white=MagickTrue;\n        pixels=GetQuantumPixels(quantum_info);\n        extent=GetQuantumExtent(image,quantum_info,GrayQuantum);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels;\n          switch (image->depth)\n          {\n            case 8:\n            case 16:\n            case 32:\n            {\n              extent=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                GrayQuantum,pixels,exception);\n              break;\n            }\n            default:\n            {\n              if (image->depth <= 8)\n                {\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    if (IsPixelGray(image,p) == MagickFalse)\n                      pixel=ScaleQuantumToAny(ClampToQuantum(GetPixelLuma(\n                        image,p)),max_value);\n                    else\n                      {\n                        if (image->depth == 8)\n                          pixel=ScaleQuantumToChar(GetPixelRed(image,p));\n                        else\n                          pixel=ScaleQuantumToAny(GetPixelRed(image,p),\n                            max_value);\n                      }\n                    q=PopCharPixel((unsigned char) pixel,q);\n                    p+=GetPixelChannels(image);\n                  }\n                  extent=(size_t) (q-pixels);\n                  break;\n                }\n              if (image->depth <= 16)\n                {\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    if (IsPixelGray(image,p) == MagickFalse)\n                      pixel=ScaleQuantumToAny(ClampToQuantum(GetPixelLuma(image,\n                        p)),max_value);\n                    else\n                      {\n                        if (image->depth == 16)\n                          pixel=ScaleQuantumToShort(GetPixelRed(image,p));\n                        else\n                          pixel=ScaleQuantumToAny(GetPixelRed(image,p),\n                            max_value);\n                      }\n                    q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                    p+=GetPixelChannels(image);\n                  }\n                  extent=(size_t) (q-pixels);\n                  break;\n                }\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                if (IsPixelGray(image,p) == MagickFalse)\n                  pixel=ScaleQuantumToAny(ClampToQuantum(GetPixelLuma(image,p)),\n                    max_value);\n                else\n                  {\n                    if (image->depth == 16)\n                      pixel=ScaleQuantumToLong(GetPixelRed(image,p));\n                    else\n                      pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);\n                  }\n                q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                p+=GetPixelChannels(image);\n              }\n              extent=(size_t) (q-pixels);\n              break;\n            }\n          }\n          count=WriteBlob(image,extent,pixels);\n          if (count != (ssize_t) extent)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        quantum_info=DestroyQuantumInfo(quantum_info);\n        break;\n      }\n      case '6':\n      {\n        register unsigned char\n          *pixels;\n\n        /*\n          Convert image to a PNM image.\n        */\n        (void) TransformImageColorspace(image,sRGBColorspace,exception);\n        if (image->depth > 32)\n          image->depth=32;\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g\\n\",(double)\n          ((MagickOffsetType) GetQuantumRange(image->depth)));\n        (void) WriteBlobString(image,buffer);\n        quantum_info=AcquireQuantumInfo(image_info,image);\n        if (quantum_info == (QuantumInfo *) NULL)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) SetQuantumEndian(image,quantum_info,MSBEndian);\n        pixels=GetQuantumPixels(quantum_info);\n        extent=GetQuantumExtent(image,quantum_info,quantum_type);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels;\n          switch (image->depth)\n          {\n            case 8:\n            case 16:\n            case 32:\n            {\n              extent=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                quantum_type,pixels,exception);\n              break;\n            }\n            default:\n            {\n              if (image->depth <= 8)\n                {\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);\n                    q=PopCharPixel((unsigned char) pixel,q);\n                    pixel=ScaleQuantumToAny(GetPixelGreen(image,p),max_value);\n                    q=PopCharPixel((unsigned char) pixel,q);\n                    pixel=ScaleQuantumToAny(GetPixelBlue(image,p),max_value);\n                    q=PopCharPixel((unsigned char) pixel,q);\n                    p+=GetPixelChannels(image);\n                  }\n                  extent=(size_t) (q-pixels);\n                  break;\n                }\n              if (image->depth <= 16)\n                {\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);\n                    q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                    pixel=ScaleQuantumToAny(GetPixelGreen(image,p),max_value);\n                    q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                    pixel=ScaleQuantumToAny(GetPixelBlue(image,p),max_value);\n                    q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                    p+=GetPixelChannels(image);\n                  }\n                  extent=(size_t) (q-pixels);\n                  break;\n                }\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);\n                q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                pixel=ScaleQuantumToAny(GetPixelGreen(image,p),max_value);\n                q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                pixel=ScaleQuantumToAny(GetPixelBlue(image,p),max_value);\n                q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                p+=GetPixelChannels(image);\n              }\n              extent=(size_t) (q-pixels);\n              break;\n            }\n          }\n          count=WriteBlob(image,extent,pixels);\n          if (count != (ssize_t) extent)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        quantum_info=DestroyQuantumInfo(quantum_info);\n        break;\n      }\n      case '7':\n      {\n        register unsigned char\n          *pixels;\n\n        /*\n          Convert image to a PAM.\n        */\n        if (image->depth > 32)\n          image->depth=32;\n        quantum_info=AcquireQuantumInfo(image_info,image);\n        if (quantum_info == (QuantumInfo *) NULL)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) SetQuantumEndian(image,quantum_info,MSBEndian);\n        pixels=GetQuantumPixels(quantum_info);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          register ssize_t\n            x;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels;\n          switch (image->depth)\n          {\n            case 8:\n            case 16:\n            case 32:\n            {\n              extent=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                quantum_type,pixels,exception);\n              break;\n            }\n            default:\n            {\n              switch (quantum_type)\n              {\n                case GrayQuantum:\n                case GrayAlphaQuantum:\n                {\n                  if (image->depth <= 8)\n                    {\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        pixel=ScaleQuantumToAny(ClampToQuantum(GetPixelLuma(\n                          image,p)),max_value);\n                        q=PopCharPixel((unsigned char) pixel,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            pixel=(unsigned char) ScaleQuantumToAny(\n                              GetPixelAlpha(image,p),max_value);\n                            q=PopCharPixel((unsigned char) pixel,q);\n                          }\n                        p+=GetPixelChannels(image);\n                      }\n                      break;\n                    }\n                  if (image->depth <= 16)\n                    {\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        pixel=ScaleQuantumToAny(ClampToQuantum(GetPixelLuma(\n                          image,p)),max_value);\n                        q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            pixel=(unsigned char) ScaleQuantumToAny(\n                              GetPixelAlpha(image,p),max_value);\n                            q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                          }\n                        p+=GetPixelChannels(image);\n                      }\n                      break;\n                    }\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    pixel=ScaleQuantumToAny(ClampToQuantum(GetPixelLuma(image,\n                      p)),max_value);\n                    q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                    if (image->alpha_trait != UndefinedPixelTrait)\n                      {\n                        pixel=(unsigned char) ScaleQuantumToAny(\n                          GetPixelAlpha(image,p),max_value);\n                        q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                      }\n                    p+=GetPixelChannels(image);\n                  }\n                  break;\n                }\n                case CMYKQuantum:\n                case CMYKAQuantum:\n                {\n                  if (image->depth <= 8)\n                    {\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);\n                        q=PopCharPixel((unsigned char) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelGreen(image,p),\n                          max_value);\n                        q=PopCharPixel((unsigned char) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelBlue(image,p),\n                          max_value);\n                        q=PopCharPixel((unsigned char) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelBlack(image,p),\n                          max_value);\n                        q=PopCharPixel((unsigned char) pixel,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            pixel=ScaleQuantumToAny(GetPixelAlpha(image,p),\n                              max_value);\n                            q=PopCharPixel((unsigned char) pixel,q);\n                          }\n                        p+=GetPixelChannels(image);\n                      }\n                      break;\n                    }\n                  if (image->depth <= 16)\n                    {\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);\n                        q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelGreen(image,p),\n                          max_value);\n                        q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelBlue(image,p),\n                          max_value);\n                        q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelBlack(image,p),\n                          max_value);\n                        q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            pixel=ScaleQuantumToAny(GetPixelAlpha(image,p),\n                              max_value);\n                            q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                          }\n                        p+=GetPixelChannels(image);\n                      }\n                      break;\n                    }\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);\n                    q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                    pixel=ScaleQuantumToAny(GetPixelGreen(image,p),max_value);\n                    q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                    pixel=ScaleQuantumToAny(GetPixelBlue(image,p),max_value);\n                    q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                    pixel=ScaleQuantumToAny(GetPixelBlack(image,p),max_value);\n                    q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                    if (image->alpha_trait != UndefinedPixelTrait)\n                      {\n                        pixel=ScaleQuantumToAny(GetPixelAlpha(image,p),\n                          max_value);\n                        q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                      }\n                    p+=GetPixelChannels(image);\n                  }\n                  break;\n                }\n                default:\n                {\n                  if (image->depth <= 8)\n                    {\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);\n                        q=PopCharPixel((unsigned char) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelGreen(image,p),\n                          max_value);\n                        q=PopCharPixel((unsigned char) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelBlue(image,p),\n                          max_value);\n                        q=PopCharPixel((unsigned char) pixel,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            pixel=ScaleQuantumToAny(GetPixelAlpha(image,p),\n                              max_value);\n                            q=PopCharPixel((unsigned char) pixel,q);\n                          }\n                        p+=GetPixelChannels(image);\n                      }\n                      break;\n                    }\n                  if (image->depth <= 16)\n                    {\n                      for (x=0; x < (ssize_t) image->columns; x++)\n                      {\n                        pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);\n                        q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelGreen(image,p),\n                          max_value);\n                        q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                        pixel=ScaleQuantumToAny(GetPixelBlue(image,p),\n                          max_value);\n                        q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                        if (image->alpha_trait != UndefinedPixelTrait)\n                          {\n                            pixel=ScaleQuantumToAny(GetPixelAlpha(image,p),\n                              max_value);\n                            q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);\n                          }\n                        p+=GetPixelChannels(image);\n                      }\n                      break;\n                    }\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);\n                    q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                    pixel=ScaleQuantumToAny(GetPixelGreen(image,p),max_value);\n                    q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                    pixel=ScaleQuantumToAny(GetPixelBlue(image,p),max_value);\n                    q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                    if (image->alpha_trait != UndefinedPixelTrait)\n                      {\n                        pixel=ScaleQuantumToAny(GetPixelAlpha(image,p),\n                          max_value);\n                        q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);\n                      }\n                    p+=GetPixelChannels(image);\n                  }\n                  break;\n                }\n              }\n              extent=(size_t) (q-pixels);\n              break;\n            }\n          }\n          count=WriteBlob(image,extent,pixels);\n          if (count != (ssize_t) extent)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        quantum_info=DestroyQuantumInfo(quantum_info);\n        break;\n      }\n      case 'F':\n      case 'f':\n      {\n        register unsigned char\n          *pixels;\n\n        (void) WriteBlobString(image,image->endian == LSBEndian ? \"-1.0\\n\" :\n          \"1.0\\n\");\n        image->depth=32;\n        quantum_type=format == 'f' ? GrayQuantum : RGBQuantum;\n        quantum_info=AcquireQuantumInfo(image_info,image);\n        if (quantum_info == (QuantumInfo *) NULL)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);\n        if (status == MagickFalse)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        pixels=GetQuantumPixels(quantum_info);\n        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          extent=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            quantum_type,pixels,exception);\n          (void) WriteBlob(image,extent,pixels);\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        quantum_info=DestroyQuantumInfo(quantum_info);\n        break;\n      }\n    }\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,imageListLength);\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n", "target": 1, "idx": 182770}
{"func": "void ReleaseProcessIfNeeded() {\n  content::UtilityThread::Get()->ReleaseProcessIfNeeded();\n}\n", "target": 0, "idx": 133843}
{"func": "bool AXNodeObject::isModal() const {\n  if (roleValue() != DialogRole && roleValue() != AlertDialogRole)\n    return false;\n \n   if (hasAttribute(aria_modalAttr)) {\n     const AtomicString& modal = getAttribute(aria_modalAttr);\n    if (equalIgnoringCase(modal, \"true\"))\n       return true;\n    if (equalIgnoringCase(modal, \"false\"))\n       return false;\n   }\n \n  if (getNode() && isHTMLDialogElement(*getNode()))\n    return toElement(getNode())->isInTopLayer();\n\n  return false;\n}\n", "target": 1, "idx": 185794}
{"func": "  void OnDataReceivedFromPeer(const char* data, size_t data_len) {\n    DCHECK(delegate_);\n    delegate_->OnPacketDataReceived(data, data_len);\n  }\n", "target": 0, "idx": 145428}
{"func": "WebMediaPlayer* RenderViewImpl::createMediaPlayer(\n    WebFrame* frame, const WebKit::WebURL& url, WebMediaPlayerClient* client) {\n  FOR_EACH_OBSERVER(\n      RenderViewObserver, observers_, WillCreateMediaPlayer(frame, client));\n\n  const CommandLine* cmd_line = CommandLine::ForCurrentProcess();\n#if defined(ENABLE_WEBRTC)\n  if (MediaStreamImpl::CheckMediaStream(url)) {\n    EnsureMediaStreamImpl();\n    return new webkit_media::WebMediaPlayerMS(\n        frame, client, AsWeakPtr(), media_stream_impl_, new RenderMediaLog());\n  }\n#endif\n\n#if defined(OS_ANDROID)\n  GpuChannelHost* gpu_channel_host =\n      RenderThreadImpl::current()->EstablishGpuChannelSync(\n          CAUSE_FOR_GPU_LAUNCH_VIDEODECODEACCELERATOR_INITIALIZE);\n  if (!gpu_channel_host) {\n    LOG(ERROR) << \"Failed to establish GPU channel for media player\";\n    return NULL;\n  }\n\n  scoped_refptr<cc::ContextProvider> context_provider =\n      RenderThreadImpl::current()->OffscreenContextProviderForMainThread();\n  if (!context_provider->InitializeOnMainThread() ||\n      !context_provider->BindToCurrentThread()) {\n    LOG(ERROR) << \"Failed to get context3d for media player\";\n    return NULL;\n  }\n\n  if (cmd_line->HasSwitch(switches::kInProcessWebGL)) {\n    if (!media_bridge_manager_.get()) {\n      media_bridge_manager_.reset(\n          new webkit_media::MediaPlayerBridgeManagerImpl(1));\n    }\n    return new webkit_media::WebMediaPlayerInProcessAndroid(\n        frame,\n        client,\n        cookieJar(frame),\n        media_player_manager_.get(),\n        media_bridge_manager_.get(),\n        new StreamTextureFactoryImpl(\n            context_provider->Context3d(), gpu_channel_host, routing_id_),\n        cmd_line->HasSwitch(switches::kDisableMediaHistoryLogging));\n  }\n  if (!media_player_proxy_) {\n    media_player_proxy_ = new WebMediaPlayerProxyImplAndroid(\n        this, media_player_manager_.get());\n  }\n  return new webkit_media::WebMediaPlayerImplAndroid(\n      frame,\n      client,\n      media_player_manager_.get(),\n      media_player_proxy_,\n      new StreamTextureFactoryImpl(\n          context_provider->Context3d(), gpu_channel_host, routing_id_));\n#endif\n\n  scoped_refptr<media::AudioRendererSink> sink;\n  if (!cmd_line->HasSwitch(switches::kDisableAudio)) {\n    if (!cmd_line->HasSwitch(switches::kDisableRendererSideMixing)) {\n      sink = RenderThreadImpl::current()->GetAudioRendererMixerManager()->\n          CreateInput(routing_id_);\n      DVLOG(1) << \"Using AudioRendererMixerManager-provided sink: \" << sink;\n    } else {\n      scoped_refptr<RendererAudioOutputDevice> device =\n          AudioDeviceFactory::NewOutputDevice();\n      device->SetSourceRenderView(routing_id_);\n      sink = device;\n      DVLOG(1) << \"Using AudioDeviceFactory-provided sink: \" << sink;\n    }\n  }\n\n  scoped_refptr<media::GpuVideoDecoder::Factories> gpu_factories;\n  WebGraphicsContext3DCommandBufferImpl* context3d = NULL;\n  if (!cmd_line->HasSwitch(switches::kDisableAcceleratedVideoDecode))\n    context3d = RenderThreadImpl::current()->GetGpuVDAContext3D();\n  if (context3d) {\n    scoped_refptr<base::MessageLoopProxy> factories_loop =\n        RenderThreadImpl::current()->compositor_message_loop_proxy();\n    if (!factories_loop)\n      factories_loop = base::MessageLoopProxy::current();\n    GpuChannelHost* gpu_channel_host =\n        RenderThreadImpl::current()->EstablishGpuChannelSync(\n            CAUSE_FOR_GPU_LAUNCH_VIDEODECODEACCELERATOR_INITIALIZE);\n    gpu_factories = new RendererGpuVideoDecoderFactories(\n        gpu_channel_host, factories_loop, context3d);\n  }\n\n  webkit_media::WebMediaPlayerParams params(\n      sink, gpu_factories, new RenderMediaLog());\n  WebMediaPlayer* media_player =\n      GetContentClient()->renderer()->OverrideCreateWebMediaPlayer(\n          this, frame, client, AsWeakPtr(), params);\n  if (!media_player) {\n    media_player = new webkit_media::WebMediaPlayerImpl(\n        frame, client, AsWeakPtr(), params);\n  }\n  return media_player;\n}\n", "target": 0, "idx": 123958}
{"func": "authentic_get_challenge(struct sc_card *card, unsigned char *rnd, size_t len)\n{\n\t/* 'GET CHALLENGE' returns always 24 bytes */\n\tunsigned char rbuf[0x18];\n\tsize_t out_len;\n\tint r;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tr = iso_ops->get_challenge(card, rbuf, sizeof rbuf);\n\tLOG_TEST_RET(card->ctx, r, \"GET CHALLENGE cmd failed\");\n\n\tif (len < (size_t) r) {\n\t\tout_len = len;\n\t} else {\n\t\tout_len = (size_t) r;\n\t}\n\tmemcpy(rnd, rbuf, out_len);\n\n\tLOG_FUNC_RETURN(card->ctx, out_len);\n}\n", "target": 0, "idx": 78186}
{"func": " horDiff8(TIFF* tif, uint8* cp0, tmsize_t cc)\n {\n \tTIFFPredictorState* sp = PredictorState(tif);\n \ttmsize_t stride = sp->stride;\n \tunsigned char* cp = (unsigned char*) cp0;\n \n\tassert((cc%stride)==0);\n \n \tif (cc > stride) {\n \t\tcc -= stride;\n\t\t/*\n\t\t * Pipeline the most common cases.\n\t\t */\n\t\tif (stride == 3) {\n\t\t\tunsigned int r1, g1, b1;\n\t\t\tunsigned int r2 = cp[0];\n\t\t\tunsigned int g2 = cp[1];\n\t\t\tunsigned  int b2 = cp[2];\n\t\t\tdo {\n\t\t\t\tr1 = cp[3]; cp[3] = (unsigned char)((r1-r2)&0xff); r2 = r1;\n\t\t\t\tg1 = cp[4]; cp[4] = (unsigned char)((g1-g2)&0xff); g2 = g1;\n\t\t\t\tb1 = cp[5]; cp[5] = (unsigned char)((b1-b2)&0xff); b2 = b1;\n\t\t\t\tcp += 3;\n\t\t\t} while ((cc -= 3) > 0);\n\t\t} else if (stride == 4) {\n\t\t\tunsigned int r1, g1, b1, a1;\n\t\t\tunsigned int r2 = cp[0];\n\t\t\tunsigned int g2 = cp[1];\n\t\t\tunsigned int b2 = cp[2];\n\t\t\tunsigned int a2 = cp[3];\n\t\t\tdo {\n\t\t\t\tr1 = cp[4]; cp[4] = (unsigned char)((r1-r2)&0xff); r2 = r1;\n\t\t\t\tg1 = cp[5]; cp[5] = (unsigned char)((g1-g2)&0xff); g2 = g1;\n\t\t\t\tb1 = cp[6]; cp[6] = (unsigned char)((b1-b2)&0xff); b2 = b1;\n\t\t\t\ta1 = cp[7]; cp[7] = (unsigned char)((a1-a2)&0xff); a2 = a1;\n\t\t\t\tcp += 4;\n\t\t\t} while ((cc -= 4) > 0);\n\t\t} else {\n\t\t\tcp += cc - 1;\n\t\t\tdo {\n\t\t\t\tREPEAT4(stride, cp[stride] = (unsigned char)((cp[stride] - cp[0])&0xff); cp--)\n \t\t\t} while ((cc -= stride) > 0);\n \t\t}\n \t}\n }\n", "target": 1, "idx": 180059}
{"func": "static inline int nfs4_lock_type(struct file_lock *fl, int block)\n{\n\tif ((fl->fl_type & (F_RDLCK|F_WRLCK|F_UNLCK)) == F_RDLCK)\n\t\treturn block ? NFS4_READW_LT : NFS4_READ_LT;\n\treturn block ? NFS4_WRITEW_LT : NFS4_WRITE_LT;\n}\n", "target": 0, "idx": 23095}
{"func": "PaletteTool::~PaletteTool() {}\n", "target": 0, "idx": 133313}
{"func": "bool WebPagePrivate::dispatchTouchPointAsMouseEventToFullScreenPlugin(PluginView* pluginView, const Platform::TouchPoint& point)\n{\n     NPEvent npEvent;\n     NPMouseEvent mouse;\n \n    switch (point.m_state) {\n     case Platform::TouchPoint::TouchPressed:\n         mouse.type = MOUSE_BUTTON_DOWN;\n         break;\n    case Platform::TouchPoint::TouchReleased:\n        mouse.type = MOUSE_BUTTON_UP;\n        break;\n    case Platform::TouchPoint::TouchMoved:\n        mouse.type = MOUSE_MOTION;\n        break;\n    case Platform::TouchPoint::TouchStationary:\n         return true;\n     }\n \n    mouse.x = point.m_screenPos.x();\n    mouse.y = point.m_screenPos.y();\n     mouse.button = mouse.type != MOUSE_BUTTON_UP;\n     mouse.flags = 0;\n     npEvent.type = NP_MouseEvent;\n    npEvent.data = &mouse;\n\n    pluginView->dispatchFullScreenNPEvent(npEvent);\n    return true;\n}\n", "target": 1, "idx": 184339}
{"func": "PassRefPtr<DocumentFragment> XSLTProcessor::transformToFragment(Node* sourceNode, Document* outputDoc)\n{\n    String resultMIMEType;\n    String resultString;\n    String resultEncoding;\n\n    if (outputDoc->isHTMLDocument())\n        resultMIMEType = \"text/html\";\n \n     if (!transformToString(sourceNode, resultMIMEType, resultString, resultEncoding))\n         return 0;\n    return createFragmentFromSource(resultString, resultMIMEType, outputDoc);\n }\n", "target": 1, "idx": 183902}
{"func": "static Mutex& threadSetMutex()\n{\n    AtomicallyInitializedStaticReference(Mutex, mutex, new Mutex);\n    return mutex;\n}\n", "target": 0, "idx": 138527}
{"func": " bool ChildProcessSecurityPolicyImpl::CanSetAsOriginHeader(int child_id,\n                                                           const GURL& url) {\n   if (!url.is_valid())\n    return false;  // Can't set invalid URLs as origin headers.\n\n  if (url == kAboutSrcDocURL)\n    return false;\n \n  if (CanCommitURL(child_id, url))\n     return true;\n \n  {\n    base::AutoLock lock(lock_);\n    if (base::ContainsKey(schemes_okay_to_appear_as_origin_headers_,\n                          url.scheme())) {\n      return true;\n    }\n  }\n  return false;\n}\n", "target": 1, "idx": 186588}
{"func": "StateChangeReason DiscardReasonToStateChangeReason(DiscardReason reason) {\n  switch (reason) {\n    case DiscardReason::kExternal:\n      return StateChangeReason::EXTENSION_INITIATED;\n    case DiscardReason::kProactive:\n      return StateChangeReason::BROWSER_INITIATED;\n    case DiscardReason::kUrgent:\n      return StateChangeReason::SYSTEM_MEMORY_PRESSURE;\n   }\n }\n", "target": 0, "idx": 144776}
{"func": "static void cmd_parse_status(struct ImapData *idata, char *s)\n{\n  char *value = NULL;\n  struct Buffy *inc = NULL;\n  struct ImapMbox mx;\n  struct ImapStatus *status = NULL;\n  unsigned int olduv, oldun;\n  unsigned int litlen;\n  short new = 0;\n  short new_msg_count = 0;\n\n  char *mailbox = imap_next_word(s);\n\n  /* We need a real tokenizer. */\n  if (imap_get_literal_count(mailbox, &litlen) == 0)\n  {\n    if (imap_cmd_step(idata) != IMAP_CMD_CONTINUE)\n    {\n       idata->status = IMAP_FATAL;\n       return;\n     }\n     mailbox = idata->buf;\n     s = mailbox + litlen;\n     *s = '\\0';\n    s++;\n    SKIPWS(s);\n  }\n  else\n  {\n    s = imap_next_word(mailbox);\n    *(s - 1) = '\\0';\n    imap_unmunge_mbox_name(idata, mailbox);\n  }\n\n  status = imap_mboxcache_get(idata, mailbox, 1);\n  olduv = status->uidvalidity;\n  oldun = status->uidnext;\n\n  if (*s++ != '(')\n  {\n    mutt_debug(1, \"Error parsing STATUS\\n\");\n    return;\n  }\n  while (*s && *s != ')')\n  {\n    value = imap_next_word(s);\n\n    errno = 0;\n    const unsigned long ulcount = strtoul(value, &value, 10);\n    if (((errno == ERANGE) && (ulcount == ULONG_MAX)) || ((unsigned int) ulcount != ulcount))\n    {\n      mutt_debug(1, \"Error parsing STATUS number\\n\");\n      return;\n    }\n    const unsigned int count = (unsigned int) ulcount;\n\n    if (mutt_str_strncmp(\"MESSAGES\", s, 8) == 0)\n    {\n      status->messages = count;\n      new_msg_count = 1;\n    }\n    else if (mutt_str_strncmp(\"RECENT\", s, 6) == 0)\n      status->recent = count;\n    else if (mutt_str_strncmp(\"UIDNEXT\", s, 7) == 0)\n      status->uidnext = count;\n    else if (mutt_str_strncmp(\"UIDVALIDITY\", s, 11) == 0)\n      status->uidvalidity = count;\n    else if (mutt_str_strncmp(\"UNSEEN\", s, 6) == 0)\n      status->unseen = count;\n\n    s = value;\n    if (*s && *s != ')')\n      s = imap_next_word(s);\n  }\n  mutt_debug(3, \"%s (UIDVALIDITY: %u, UIDNEXT: %u) %d messages, %d recent, %d unseen\\n\",\n             status->name, status->uidvalidity, status->uidnext,\n             status->messages, status->recent, status->unseen);\n\n  /* caller is prepared to handle the result herself */\n  if (idata->cmddata && idata->cmdtype == IMAP_CT_STATUS)\n  {\n    memcpy(idata->cmddata, status, sizeof(struct ImapStatus));\n    return;\n  }\n\n  mutt_debug(3, \"Running default STATUS handler\\n\");\n\n  /* should perhaps move this code back to imap_buffy_check */\n  for (inc = Incoming; inc; inc = inc->next)\n  {\n    if (inc->magic != MUTT_IMAP)\n      continue;\n\n    if (imap_parse_path(inc->path, &mx) < 0)\n    {\n      mutt_debug(1, \"Error parsing mailbox %s, skipping\\n\", inc->path);\n      continue;\n    }\n\n    if (imap_account_match(&idata->conn->account, &mx.account))\n    {\n      if (mx.mbox)\n      {\n        value = mutt_str_strdup(mx.mbox);\n        imap_fix_path(idata, mx.mbox, value, mutt_str_strlen(value) + 1);\n        FREE(&mx.mbox);\n      }\n      else\n        value = mutt_str_strdup(\"INBOX\");\n\n      if (value && (imap_mxcmp(mailbox, value) == 0))\n      {\n        mutt_debug(3, \"Found %s in buffy list (OV: %u ON: %u U: %d)\\n\", mailbox,\n                   olduv, oldun, status->unseen);\n\n        if (MailCheckRecent)\n        {\n          if (olduv && olduv == status->uidvalidity)\n          {\n            if (oldun < status->uidnext)\n              new = (status->unseen > 0);\n          }\n          else if (!olduv && !oldun)\n          {\n            /* first check per session, use recent. might need a flag for this. */\n            new = (status->recent > 0);\n          }\n          else\n            new = (status->unseen > 0);\n        }\n        else\n          new = (status->unseen > 0);\n\n#ifdef USE_SIDEBAR\n        if ((inc->new != new) || (inc->msg_count != status->messages) ||\n            (inc->msg_unread != status->unseen))\n        {\n          mutt_menu_set_current_redraw(REDRAW_SIDEBAR);\n        }\n#endif\n        inc->new = new;\n        if (new_msg_count)\n          inc->msg_count = status->messages;\n        inc->msg_unread = status->unseen;\n\n        if (inc->new)\n        {\n          /* force back to keep detecting new mail until the mailbox is\n             opened */\n          status->uidnext = oldun;\n        }\n\n        FREE(&value);\n        return;\n      }\n\n      FREE(&value);\n    }\n\n    FREE(&mx.mbox);\n  }\n}\n", "target": 1, "idx": 182310}
{"func": "void InspectorPageAgent::Did(const probe::UpdateLayout&) {\n  PageLayoutInvalidated(false);\n}\n", "target": 0, "idx": 151232}
{"func": "UpdateLibrary* CrosLibrary::GetUpdateLibrary() {\n  return update_lib_.GetDefaultImpl(use_stub_impl_);\n}\n", "target": 1, "idx": 184102}
{"func": "void FileSystemOperation::GetUsageAndQuotaThenRunTask(\n    const GURL& origin, FileSystemType type,\n    const base::Closure& task,\n    const base::Closure& error_callback) {\n  quota::QuotaManagerProxy* quota_manager_proxy =\n      file_system_context()->quota_manager_proxy();\n  if (!quota_manager_proxy ||\n      !file_system_context()->GetQuotaUtil(type)) {\n    operation_context_.set_allowed_bytes_growth(kint64max);\n    task.Run();\n    return;\n  }\n\n  TaskParamsForDidGetQuota params;\n  params.origin = origin;\n  params.type = type;\n  params.task = task;\n  params.error_callback = error_callback;\n\n  DCHECK(quota_manager_proxy);\n  DCHECK(quota_manager_proxy->quota_manager());\n  quota_manager_proxy->quota_manager()->GetUsageAndQuota(\n       origin,\n       FileSystemTypeToQuotaStorageType(type),\n       base::Bind(&FileSystemOperation::DidGetUsageAndQuotaAndRunTask,\n                 base::Unretained(this), params));\n }\n", "target": 1, "idx": 184336}
{"func": "void WallpaperManager::InitializeRegisteredDeviceWallpaper() {\n  if (user_manager::UserManager::Get()->IsUserLoggedIn())\n    return;\n\n  bool disable_boot_animation =\n      GetCommandLine()->HasSwitch(switches::kDisableBootAnimation);\n  bool show_users = true;\n  bool result = CrosSettings::Get()->GetBoolean(\n      kAccountsPrefShowUserNamesOnSignIn, &show_users);\n  DCHECK(result) << \"Unable to fetch setting \"\n                 << kAccountsPrefShowUserNamesOnSignIn;\n  const user_manager::UserList& users =\n      user_manager::UserManager::Get()->GetUsers();\n  int public_session_user_index = FindPublicSession(users);\n  if ((!show_users && public_session_user_index == -1) ||\n      !HasNonDeviceLocalAccounts(users)) {\n    if (!SetDeviceWallpaperIfApplicable(user_manager::SignInAccountId()))\n      SetDefaultWallpaperDelayed(user_manager::SignInAccountId());\n    return;\n  }\n\n  if (!disable_boot_animation) {\n    int index = public_session_user_index != -1 ? public_session_user_index : 0;\n    SetUserWallpaperDelayed(users[index]->GetAccountId());\n  }\n}\n", "target": 0, "idx": 138887}
{"func": "static struct l2cap_chan *l2cap_sock_new_connection_cb(struct l2cap_chan *chan)\n{\n\tstruct sock *sk, *parent = chan->data;\n\n\t/* Check for backlog size */\n\tif (sk_acceptq_is_full(parent)) {\n\t\tBT_DBG(\"backlog full %d\", parent->sk_ack_backlog);\n\t\treturn NULL;\n\t}\n\n\tsk = l2cap_sock_alloc(sock_net(parent), NULL, BTPROTO_L2CAP,\n\t\t\t\t\t\t\t\tGFP_ATOMIC);\n\tif (!sk)\n\t\treturn NULL;\n\n\tbt_sock_reclassify_lock(sk, BTPROTO_L2CAP);\n\n\tl2cap_sock_init(sk, parent);\n\n\treturn l2cap_pi(sk)->chan;\n}\n", "target": 0, "idx": 94528}
{"func": " ImageBitmapFactories::ImageBitmapLoader::ImageBitmapLoader(\n     ImageBitmapFactories& factory,\n     base::Optional<IntRect> crop_rect,\n     ScriptState* script_state,\n     const ImageBitmapOptions* options)\n    : loader_(\n           FileReaderLoader::Create(FileReaderLoader::kReadAsArrayBuffer, this)),\n       factory_(&factory),\n       resolver_(ScriptPromiseResolver::Create(script_state)),\n       crop_rect_(crop_rect),\n       options_(options) {}\n", "target": 1, "idx": 187051}
{"func": "  explicit FrameURLLoaderFactory(base::WeakPtr<RenderFrameImpl> frame)\n      : frame_(std::move(frame)) {}\n", "target": 0, "idx": 152321}
{"func": "OMX_ERRORTYPE  omx_video::allocate_input_buffer(\n        OMX_IN OMX_HANDLETYPE            hComp,\n        OMX_INOUT OMX_BUFFERHEADERTYPE** bufferHdr,\n        OMX_IN OMX_U32                   port,\n        OMX_IN OMX_PTR                   appData,\n        OMX_IN OMX_U32                   bytes)\n{\n (void)hComp, (void)port;\n    OMX_ERRORTYPE eRet = OMX_ErrorNone;\n unsigned   i = 0;\n\n    DEBUG_PRINT_HIGH(\"allocate_input_buffer()::\");\n if (bytes != m_sInPortDef.nBufferSize) {\n        DEBUG_PRINT_ERROR(\"ERROR: Buffer size mismatch error: bytes[%u] != nBufferSize[%u]\",\n (unsigned int)bytes, (unsigned int)m_sInPortDef.nBufferSize);\n return OMX_ErrorBadParameter;\n }\n\n if (!m_inp_mem_ptr) {\n        DEBUG_PRINT_HIGH(\"%s: size = %u, actual cnt %u\", __FUNCTION__,\n (unsigned int)m_sInPortDef.nBufferSize, (unsigned int)m_sInPortDef.nBufferCountActual);\n        m_inp_mem_ptr = (OMX_BUFFERHEADERTYPE*) \\\n                        calloc( (sizeof(OMX_BUFFERHEADERTYPE)), m_sInPortDef.nBufferCountActual);\n if (m_inp_mem_ptr == NULL) {\n            DEBUG_PRINT_ERROR(\"ERROR: calloc() Failed for m_inp_mem_ptr\");\n return OMX_ErrorInsufficientResources;\n }\n\n        DEBUG_PRINT_LOW(\"Successfully allocated m_inp_mem_ptr = %p\", m_inp_mem_ptr);\n        m_pInput_pmem = (struct pmem *) calloc(sizeof (struct pmem), m_sInPortDef.nBufferCountActual);\n\n if (m_pInput_pmem == NULL) {\n            DEBUG_PRINT_ERROR(\"ERROR: calloc() Failed for m_pInput_pmem\");\n return OMX_ErrorInsufficientResources;\n }\n#ifdef USE_ION\n        m_pInput_ion = (struct venc_ion *) calloc(sizeof (struct venc_ion), m_sInPortDef.nBufferCountActual);\n if (m_pInput_ion == NULL) {\n            DEBUG_PRINT_ERROR(\"ERROR: calloc() Failed for m_pInput_ion\");\n return OMX_ErrorInsufficientResources;\n }\n#endif\n for (i=0; i< m_sInPortDef.nBufferCountActual; i++) {\n            m_pInput_pmem[i].fd = -1;\n#ifdef USE_ION\n            m_pInput_ion[i].ion_device_fd =-1;\n            m_pInput_ion[i].fd_ion_data.fd =-1;\n            m_pInput_ion[i].ion_alloc_data.handle = 0;\n#endif\n }\n }\n\n for (i=0; i< m_sInPortDef.nBufferCountActual; i++) {\n if (BITMASK_ABSENT(&m_inp_bm_count,i)) {\n break;\n }\n }\n if (i < m_sInPortDef.nBufferCountActual) {\n\n *bufferHdr = (m_inp_mem_ptr + i);\n (*bufferHdr)->nSize             = sizeof(OMX_BUFFERHEADERTYPE);\n (*bufferHdr)->nVersion.nVersion = OMX_SPEC_VERSION;\n (*bufferHdr)->nAllocLen         = m_sInPortDef.nBufferSize;\n (*bufferHdr)->pAppPrivate       = appData;\n (*bufferHdr)->nInputPortIndex   = PORT_INDEX_IN;\n (*bufferHdr)->pInputPortPrivate = (OMX_PTR)&m_pInput_pmem[i];\n\n#ifdef USE_ION\n#ifdef _MSM8974_\n        m_pInput_ion[i].ion_device_fd = alloc_map_ion_memory(m_sInPortDef.nBufferSize,\n &m_pInput_ion[i].ion_alloc_data,\n &m_pInput_ion[i].fd_ion_data,0);\n#else\n        m_pInput_ion[i].ion_device_fd = alloc_map_ion_memory(m_sInPortDef.nBufferSize,\n &m_pInput_ion[i].ion_alloc_data,\n &m_pInput_ion[i].fd_ion_data,ION_FLAG_CACHED);\n#endif\n if (m_pInput_ion[i].ion_device_fd < 0) {\n            DEBUG_PRINT_ERROR(\"ERROR:ION device open() Failed\");\n return OMX_ErrorInsufficientResources;\n }\n\n        m_pInput_pmem[i].fd = m_pInput_ion[i].fd_ion_data.fd;\n#else\n        m_pInput_pmem[i].fd = open (MEM_DEVICE,O_RDWR);\n\n if (m_pInput_pmem[i].fd == 0) {\n            m_pInput_pmem[i].fd = open (MEM_DEVICE,O_RDWR);\n }\n\n if (m_pInput_pmem[i].fd < 0) {\n            DEBUG_PRINT_ERROR(\"ERROR: /dev/pmem_adsp open() Failed\");\n return OMX_ErrorInsufficientResources;\n }\n#endif\n        m_pInput_pmem[i].size = m_sInPortDef.nBufferSize;\n        m_pInput_pmem[i].offset = 0;\n\n        m_pInput_pmem[i].buffer = (OMX_U8 *)SECURE_BUFPTR;\n if(!secure_session) {\n            m_pInput_pmem[i].buffer = (unsigned char *)mmap(NULL,\n                m_pInput_pmem[i].size,PROT_READ|PROT_WRITE,\n                MAP_SHARED,m_pInput_pmem[i].fd,0);\n if (m_pInput_pmem[i].buffer == MAP_FAILED) {\n                DEBUG_PRINT_ERROR(\"ERROR: mmap FAILED= %d\", errno);\n            close(m_pInput_pmem[i].fd);\n#ifdef USE_ION\n            free_ion_memory(&m_pInput_ion[i]);\n#endif\n return OMX_ErrorInsufficientResources;\n }\n } else {\n\n             m_pInput_pmem[i].buffer = malloc(sizeof(OMX_U32) + sizeof(native_handle_t*));\n         }\n \n         (*bufferHdr)->pBuffer           = (OMX_U8 *)m_pInput_pmem[i].buffer;\n        DEBUG_PRINT_LOW(\"Virtual address in allocate buffer is %p\", m_pInput_pmem[i].buffer);\n        BITMASK_SET(&m_inp_bm_count,i);\n if (!mUseProxyColorFormat && (dev_use_buf(&m_pInput_pmem[i],PORT_INDEX_IN,i) != true)) {\n            DEBUG_PRINT_ERROR(\"ERROR: dev_use_buf FAILED for i/p buf\");\n return OMX_ErrorInsufficientResources;\n }\n } else {\n        DEBUG_PRINT_ERROR(\"ERROR: All i/p buffers are allocated, invalid allocate buf call\"\n \"for index [%d]\", i);\n        eRet = OMX_ErrorInsufficientResources;\n }\n\n return eRet;\n}\n", "target": 1, "idx": 187541}
{"func": "  WebsiteSettings* website_settings() {\n     if (!website_settings_.get()) {\n       website_settings_.reset(new WebsiteSettings(\n           mock_ui(), profile(), tab_specific_content_settings(),\n          infobar_service(), url(), ssl(), cert_store()));\n     }\n     return website_settings_.get();\n   }\n", "target": 1, "idx": 185659}
{"func": "rx_cache_insert(netdissect_options *ndo,\n                const u_char *bp, const struct ip *ip, int dport)\n{\n\tstruct rx_cache_entry *rxent;\n\tconst struct rx_header *rxh = (const struct rx_header *) bp;\n\n\tif (ndo->ndo_snapend - bp + 1 <= (int)(sizeof(struct rx_header) + sizeof(int32_t)))\n\t\treturn;\n\n\trxent = &rx_cache[rx_cache_next];\n\n\tif (++rx_cache_next >= RX_CACHE_SIZE)\n\t\trx_cache_next = 0;\n\n\trxent->callnum = EXTRACT_32BITS(&rxh->callNumber);\n \tUNALIGNED_MEMCPY(&rxent->client, &ip->ip_src, sizeof(uint32_t));\n \tUNALIGNED_MEMCPY(&rxent->server, &ip->ip_dst, sizeof(uint32_t));\n \trxent->dport = dport;\n\trxent->serviceId = EXTRACT_32BITS(&rxh->serviceId);\n \trxent->opcode = EXTRACT_32BITS(bp + sizeof(struct rx_header));\n }\n", "target": 1, "idx": 183018}
{"func": "get_endpoints(struct usbtest_dev *dev, struct usb_interface *intf)\n{\n\tint\t\t\t\ttmp;\n\tstruct usb_host_interface\t*alt;\n\tstruct usb_host_endpoint\t*in, *out;\n\tstruct usb_host_endpoint\t*iso_in, *iso_out;\n\tstruct usb_host_endpoint\t*int_in, *int_out;\n\tstruct usb_device\t\t*udev;\n\n\tfor (tmp = 0; tmp < intf->num_altsetting; tmp++) {\n\t\tunsigned\tep;\n\n\t\tin = out = NULL;\n\t\tiso_in = iso_out = NULL;\n\t\tint_in = int_out = NULL;\n\t\talt = intf->altsetting + tmp;\n\n\t\tif (override_alt >= 0 &&\n\t\t\t\toverride_alt != alt->desc.bAlternateSetting)\n\t\t\tcontinue;\n\n\t\t/* take the first altsetting with in-bulk + out-bulk;\n\t\t * ignore other endpoints and altsettings.\n\t\t */\n\t\tfor (ep = 0; ep < alt->desc.bNumEndpoints; ep++) {\n\t\t\tstruct usb_host_endpoint\t*e;\n\t\t\tint edi;\n\n\t\t\te = alt->endpoint + ep;\n\t\t\tedi = usb_endpoint_dir_in(&e->desc);\n\n\t\t\tswitch (usb_endpoint_type(&e->desc)) {\n\t\t\tcase USB_ENDPOINT_XFER_BULK:\n\t\t\t\tendpoint_update(edi, &in, &out, e);\n\t\t\t\tcontinue;\n\t\t\tcase USB_ENDPOINT_XFER_INT:\n\t\t\t\tif (dev->info->intr)\n\t\t\t\t\tendpoint_update(edi, &int_in, &int_out, e);\n\t\t\t\tcontinue;\n\t\t\tcase USB_ENDPOINT_XFER_ISOC:\n\t\t\t\tif (dev->info->iso)\n\t\t\t\t\tendpoint_update(edi, &iso_in, &iso_out, e);\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tdefault:\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif ((in && out)  ||  iso_in || iso_out || int_in || int_out)\n\t\t\tgoto found;\n\t}\n\treturn -EINVAL;\n\nfound:\n\tudev = testdev_to_usbdev(dev);\n\tdev->info->alt = alt->desc.bAlternateSetting;\n\tif (alt->desc.bAlternateSetting != 0) {\n\t\ttmp = usb_set_interface(udev,\n\t\t\t\talt->desc.bInterfaceNumber,\n\t\t\t\talt->desc.bAlternateSetting);\n\t\tif (tmp < 0)\n \t\t\treturn tmp;\n \t}\n \n\tif (in) {\n \t\tdev->in_pipe = usb_rcvbulkpipe(udev,\n \t\t\tin->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);\n \t\tdev->out_pipe = usb_sndbulkpipe(udev,\n \t\t\tout->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);\n\t}\n \tif (iso_in) {\n \t\tdev->iso_in = &iso_in->desc;\n \t\tdev->in_iso_pipe = usb_rcvisocpipe(udev,\n\t\t\t\tiso_in->desc.bEndpointAddress\n\t\t\t\t\t& USB_ENDPOINT_NUMBER_MASK);\n\t}\n\n\tif (iso_out) {\n\t\tdev->iso_out = &iso_out->desc;\n\t\tdev->out_iso_pipe = usb_sndisocpipe(udev,\n\t\t\t\tiso_out->desc.bEndpointAddress\n\t\t\t\t\t& USB_ENDPOINT_NUMBER_MASK);\n\t}\n\n\tif (int_in) {\n\t\tdev->int_in = &int_in->desc;\n\t\tdev->in_int_pipe = usb_rcvintpipe(udev,\n\t\t\t\tint_in->desc.bEndpointAddress\n\t\t\t\t\t& USB_ENDPOINT_NUMBER_MASK);\n\t}\n\n\tif (int_out) {\n\t\tdev->int_out = &int_out->desc;\n\t\tdev->out_int_pipe = usb_sndintpipe(udev,\n\t\t\t\tint_out->desc.bEndpointAddress\n\t\t\t\t\t& USB_ENDPOINT_NUMBER_MASK);\n\t}\n\treturn 0;\n}\n", "target": 1, "idx": 180850}
{"func": "bool GDataDirectory::FromProto(const GDataDirectoryProto& proto) {\n  DCHECK(proto.gdata_entry().file_info().is_directory());\n   DCHECK(!proto.gdata_entry().has_file_specific_info());\n \n   for (int i = 0; i < proto.child_files_size(); ++i) {\n    scoped_ptr<GDataFile> file(new GDataFile(NULL, directory_service_));\n     if (!file->FromProto(proto.child_files(i))) {\n       RemoveChildren();\n       return false;\n     }\n     AddEntry(file.release());\n   }\n   for (int i = 0; i < proto.child_directories_size(); ++i) {\n    scoped_ptr<GDataDirectory> dir(new GDataDirectory(NULL,\n                                                      directory_service_));\n     if (!dir->FromProto(proto.child_directories(i))) {\n       RemoveChildren();\n       return false;\n    }\n    AddEntry(dir.release());\n  }\n\n  if (!GDataEntry::FromProto(proto.gdata_entry()))\n    return false;\n\n  return true;\n}\n", "target": 1, "idx": 185190}
{"func": "void SoftHEVC::onQueueFilled(OMX_U32 portIndex) {\n    UNUSED(portIndex);\n\n if (mSignalledError) {\n return;\n }\n if (mOutputPortSettingsChange != NONE) {\n return;\n }\n\n if (NULL == mCodecCtx) {\n if (OK != initDecoder()) {\n return;\n }\n }\n if (outputBufferWidth() != mStride) {\n /* Set the run-time (dynamic) parameters */\n        mStride = outputBufferWidth();\n        setParams(mStride);\n }\n\n List<BufferInfo *> &inQueue = getPortQueue(kInputPortIndex);\n List<BufferInfo *> &outQueue = getPortQueue(kOutputPortIndex);\n\n /* If input EOS is seen and decoder is not in flush mode,\n     * set the decoder in flush mode.\n     * There can be a case where EOS is sent along with last picture data\n     * In that case, only after decoding that input data, decoder has to be\n     * put in flush. This case is handled here  */\n\n if (mReceivedEOS && !mIsInFlush) {\n        setFlushMode();\n }\n\n while (!outQueue.empty()) {\n BufferInfo *inInfo;\n        OMX_BUFFERHEADERTYPE *inHeader;\n\n BufferInfo *outInfo;\n        OMX_BUFFERHEADERTYPE *outHeader;\n size_t timeStampIx;\n\n        inInfo = NULL;\n        inHeader = NULL;\n\n if (!mIsInFlush) {\n if (!inQueue.empty()) {\n                inInfo = *inQueue.begin();\n                inHeader = inInfo->mHeader;\n } else {\n break;\n }\n }\n\n        outInfo = *outQueue.begin();\n        outHeader = outInfo->mHeader;\n        outHeader->nFlags = 0;\n        outHeader->nTimeStamp = 0;\n        outHeader->nOffset = 0;\n\n if (inHeader != NULL && (inHeader->nFlags & OMX_BUFFERFLAG_EOS)) {\n            mReceivedEOS = true;\n if (inHeader->nFilledLen == 0) {\n                inQueue.erase(inQueue.begin());\n                inInfo->mOwnedByUs = false;\n                notifyEmptyBufferDone(inHeader);\n                inHeader = NULL;\n                setFlushMode();\n }\n }\n\n /* Get a free slot in timestamp array to hold input timestamp */\n {\n size_t i;\n            timeStampIx = 0;\n for (i = 0; i < MAX_TIME_STAMPS; i++) {\n if (!mTimeStampsValid[i]) {\n                    timeStampIx = i;\n break;\n }\n }\n if (inHeader != NULL) {\n                mTimeStampsValid[timeStampIx] = true;\n                mTimeStamps[timeStampIx] = inHeader->nTimeStamp;\n }\n }\n\n {\n ivd_video_decode_ip_t s_dec_ip;\n ivd_video_decode_op_t s_dec_op;\n\n             WORD32 timeDelay, timeTaken;\n             size_t sizeY, sizeUV;\n \n            setDecodeArgs(&s_dec_ip, &s_dec_op, inHeader, outHeader, timeStampIx);\n \n             GETTIME(&mTimeStart, NULL);\n             /* Compute time elapsed between end of previous decode()\n             * to start of current decode() */\n            TIME_DIFF(mTimeEnd, mTimeStart, timeDelay);\n\n            IV_API_CALL_STATUS_T status;\n            status = ivdec_api_function(mCodecCtx, (void *)&s_dec_ip, (void *)&s_dec_op);\n\n bool resChanged = (IVD_RES_CHANGED == (s_dec_op.u4_error_code & 0xFF));\n\n            GETTIME(&mTimeEnd, NULL);\n /* Compute time taken for decode() */\n            TIME_DIFF(mTimeStart, mTimeEnd, timeTaken);\n\n            ALOGV(\"timeTaken=%6d delay=%6d numBytes=%6d\", timeTaken, timeDelay,\n                   s_dec_op.u4_num_bytes_consumed);\n if (s_dec_op.u4_frame_decoded_flag && !mFlushNeeded) {\n                mFlushNeeded = true;\n }\n\n if ((inHeader != NULL) && (1 != s_dec_op.u4_frame_decoded_flag)) {\n /* If the input did not contain picture data, then ignore\n                 * the associated timestamp */\n                mTimeStampsValid[timeStampIx] = false;\n }\n\n if (mChangingResolution && !s_dec_op.u4_output_present) {\n                mChangingResolution = false;\n                resetDecoder();\n                resetPlugin();\n continue;\n }\n\n if (resChanged) {\n                mChangingResolution = true;\n if (mFlushNeeded) {\n                    setFlushMode();\n }\n continue;\n }\n\n if ((0 < s_dec_op.u4_pic_wd) && (0 < s_dec_op.u4_pic_ht)) {\n uint32_t width = s_dec_op.u4_pic_wd;\n uint32_t height = s_dec_op.u4_pic_ht;\n bool portWillReset = false;\n                handlePortSettingsChange(&portWillReset, width, height);\n\n if (portWillReset) {\n                    resetDecoder();\n return;\n }\n }\n\n if (s_dec_op.u4_output_present) {\n                outHeader->nFilledLen = (outputBufferWidth() * outputBufferHeight() * 3) / 2;\n\n                outHeader->nTimeStamp = mTimeStamps[s_dec_op.u4_ts];\n                mTimeStampsValid[s_dec_op.u4_ts] = false;\n\n                outInfo->mOwnedByUs = false;\n                outQueue.erase(outQueue.begin());\n                outInfo = NULL;\n                notifyFillBufferDone(outHeader);\n                outHeader = NULL;\n } else {\n /* If in flush mode and no output is returned by the codec,\n                 * then come out of flush mode */\n                mIsInFlush = false;\n\n /* If EOS was recieved on input port and there is no output\n                 * from the codec, then signal EOS on output port */\n if (mReceivedEOS) {\n                    outHeader->nFilledLen = 0;\n                    outHeader->nFlags |= OMX_BUFFERFLAG_EOS;\n\n                    outInfo->mOwnedByUs = false;\n                    outQueue.erase(outQueue.begin());\n                    outInfo = NULL;\n                    notifyFillBufferDone(outHeader);\n                    outHeader = NULL;\n                    resetPlugin();\n }\n }\n }\n\n if (inHeader != NULL) {\n            inInfo->mOwnedByUs = false;\n            inQueue.erase(inQueue.begin());\n            inInfo = NULL;\n            notifyEmptyBufferDone(inHeader);\n            inHeader = NULL;\n }\n }\n}\n", "target": 1, "idx": 188203}
{"func": "cJSON *cJSON_CreateObject( void )\n{\n\tcJSON *item = cJSON_New_Item();\n\tif ( item )\n\t\titem->type = cJSON_Object;\n\treturn item;\n}\n", "target": 1, "idx": 180449}
{"func": " void ChromeContentRendererClient::RenderViewCreated(RenderView* render_view) {\n   ContentSettingsObserver* content_settings =\n       new ContentSettingsObserver(render_view);\n  new DevToolsAgent(render_view);\n   new ExtensionHelper(render_view, extension_dispatcher_.get());\n   new PageLoadHistograms(render_view, histogram_snapshots_.get());\n   new PrintWebViewHelper(render_view);\n  new SearchBox(render_view);\n  new SpellCheckProvider(render_view, spellcheck_.get());\n#if defined(ENABLE_SAFE_BROWSING)\n  safe_browsing::MalwareDOMDetails::Create(render_view);\n#endif\n\n#if defined(OS_MACOSX)\n  new TextInputClientObserver(render_view);\n#endif  // defined(OS_MACOSX)\n\n  PasswordAutofillManager* password_autofill_manager =\n      new PasswordAutofillManager(render_view);\n  AutofillAgent* autofill_agent = new AutofillAgent(render_view,\n                                                    password_autofill_manager);\n  PageClickTracker* page_click_tracker = new PageClickTracker(render_view);\n  page_click_tracker->AddListener(password_autofill_manager);\n  page_click_tracker->AddListener(autofill_agent);\n\n  TranslateHelper* translate = new TranslateHelper(render_view, autofill_agent);\n  new ChromeRenderViewObserver(\n      render_view, content_settings, extension_dispatcher_.get(), translate);\n\n  if (CommandLine::ForCurrentProcess()->HasSwitch(\n          switches::kDomAutomationController)) {\n    new AutomationRendererHelper(render_view);\n  }\n}\n", "target": 1, "idx": 183781}
{"func": "static void set_maintenance_mode(void *send_info, bool enable)\n{\n\tstruct smi_info   *smi_info = send_info;\n\n\tif (!enable)\n\t\tatomic_set(&smi_info->req_events, 0);\n}\n", "target": 0, "idx": 90246}
{"func": "static inline unsigned long perf_ip_adjust(struct pt_regs *regs)\n{\n\tunsigned long mmcra = regs->dsisr;\n\n\tif ((mmcra & MMCRA_SAMPLE_ENABLE) && !(ppmu->flags & PPMU_ALT_SIPR)) {\n\t\tunsigned long slot = (mmcra & MMCRA_SLOT) >> MMCRA_SLOT_SHIFT;\n\t\tif (slot > 1)\n\t\t\treturn 4 * (slot - 1);\n\t}\n\treturn 0;\n}\n", "target": 0, "idx": 22688}
{"func": "void gdImageLine (gdImagePtr im, int x1, int y1, int x2, int y2, int color)\n{\n\tint dx, dy, incr1, incr2, d, x, y, xend, yend, xdirflag, ydirflag;\n\tint wid;\n\tint w, wstart;\n \tint thick = im->thick;\n \n \tif (color == gdAntiAliased) {\n\t\t/* \n \t\t   gdAntiAliased passed as color: use the much faster, much cheaper\n \t\t   and equally attractive gdImageAALine implementation. That\n \t\t   clips too, so don't clip twice.\n \t\t   */\n\t\tgdImageAALine(im, x1, y1, x2, y2, im->AA_color); \n \t\treturn;\n \t}\n \n\t/* 2.0.10: Nick Atty: clip to edges of drawing rectangle, return if no points need to be drawn */\n\tif (!clip_1d(&x1,&y1,&x2,&y2,gdImageSX(im)) || !clip_1d(&y1,&x1,&y2,&x2,gdImageSY(im))) {\n\t\treturn;\n\t}\n\n\tdx = abs (x2 - x1);\n\tdy = abs (y2 - y1);\n\n\tif (dx == 0) {\n\t\tgdImageVLine(im, x1, y1, y2, color);\n\t\treturn;\n\t} else if (dy == 0) {\n\t\tgdImageHLine(im, y1, x1, x2, color);\n\t\treturn;\n\t}\n\n\tif (dy <= dx) {\n\t\t/* More-or-less horizontal. use wid for vertical stroke */\n\t\t/* Doug Claar: watch out for NaN in atan2 (2.0.5) */\n\t\tif ((dx == 0) && (dy == 0)) {\n\t\t\twid = 1;\n\t\t} else {\n\t\t\t/* 2.0.12: Michael Schwartz: divide rather than multiply;\nTBB: but watch out for /0! */\n\t\t\tdouble ac = cos (atan2 (dy, dx));\n\t\t\tif (ac != 0) {\n\t\t\t\twid = thick / ac;\n\t\t\t} else {\n\t\t\t\twid = 1;\n\t\t\t}\n\t\t\tif (wid == 0) {\n\t\t\t\twid = 1;\n\t\t\t}\n\t\t}\n\t\td = 2 * dy - dx;\n\t\tincr1 = 2 * dy;\n\t\tincr2 = 2 * (dy - dx);\n\t\tif (x1 > x2) {\n\t\t\tx = x2;\n\t\t\ty = y2;\n\t\t\tydirflag = (-1);\n\t\t\txend = x1;\n\t\t} else {\n\t\t\tx = x1;\n\t\t\ty = y1;\n\t\t\tydirflag = 1;\n\t\t\txend = x2;\n\t\t}\n\n\t\t/* Set up line thickness */\n\t\twstart = y - wid / 2;\n\t\tfor (w = wstart; w < wstart + wid; w++) {\n\t\t\tgdImageSetPixel(im, x, w, color);\n\t\t}\n\n\t\tif (((y2 - y1) * ydirflag) > 0) {\n\t\t\twhile (x < xend) {\n\t\t\t\tx++;\n\t\t\t\tif (d < 0) {\n\t\t\t\t\td += incr1;\n\t\t\t\t} else {\n\t\t\t\t\ty++;\n\t\t\t\t\td += incr2;\n\t\t\t\t}\n\t\t\t\twstart = y - wid / 2;\n\t\t\t\tfor (w = wstart; w < wstart + wid; w++) {\n\t\t\t\t\tgdImageSetPixel (im, x, w, color);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\twhile (x < xend) {\n\t\t\t\tx++;\n\t\t\t\tif (d < 0) {\n\t\t\t\t\td += incr1;\n\t\t\t\t} else {\n\t\t\t\t\ty--;\n\t\t\t\t\td += incr2;\n\t\t\t\t}\n\t\t\t\twstart = y - wid / 2;\n\t\t\t\tfor (w = wstart; w < wstart + wid; w++) {\n\t\t\t\t\tgdImageSetPixel (im, x, w, color);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* More-or-less vertical. use wid for horizontal stroke */\n\t\t/* 2.0.12: Michael Schwartz: divide rather than multiply;\n\t\t   TBB: but watch out for /0! */\n\t\tdouble as = sin (atan2 (dy, dx));\n\t\tif (as != 0) {\n\t\t\twid = thick / as;\n\t\t} else {\n\t\t\twid = 1;\n\t\t}\n\t\tif (wid == 0) {\n\t\t\twid = 1;\n\t\t}\n\n\t\td = 2 * dx - dy;\n\t\tincr1 = 2 * dx;\n\t\tincr2 = 2 * (dx - dy);\n\t\tif (y1 > y2) {\n\t\t\ty = y2;\n\t\t\tx = x2;\n\t\t\tyend = y1;\n\t\t\txdirflag = (-1);\n\t\t} else {\n\t\t\ty = y1;\n\t\t\tx = x1;\n\t\t\tyend = y2;\n\t\t\txdirflag = 1;\n\t\t}\n\n\t\t/* Set up line thickness */\n\t\twstart = x - wid / 2;\n\t\tfor (w = wstart; w < wstart + wid; w++) {\n\t\t\tgdImageSetPixel (im, w, y, color);\n\t\t}\n\n\t\tif (((x2 - x1) * xdirflag) > 0) {\n\t\t\twhile (y < yend) {\n\t\t\t\ty++;\n\t\t\t\tif (d < 0) {\n\t\t\t\t\td += incr1;\n\t\t\t\t} else {\n\t\t\t\t\tx++;\n\t\t\t\t\td += incr2;\n\t\t\t\t}\n\t\t\t\twstart = x - wid / 2;\n\t\t\t\tfor (w = wstart; w < wstart + wid; w++) {\n\t\t\t\t\tgdImageSetPixel (im, w, y, color);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\twhile (y < yend) {\n\t\t\t\ty++;\n\t\t\t\tif (d < 0) {\n\t\t\t\t\td += incr1;\n\t\t\t\t} else {\n\t\t\t\t\tx--;\n\t\t\t\t\td += incr2;\n\t\t\t\t}\n\t\t\t\twstart = x - wid / 2;\n\t\t\t\tfor (w = wstart; w < wstart + wid; w++) {\n\t\t\t\t\tgdImageSetPixel (im, w, y, color);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n", "target": 1, "idx": 180301}
{"func": "const SeekHead* Segment::GetSeekHead() const\n{\n    return m_pSeekHead;\n}\n", "target": 1, "idx": 188375}
{"func": "static void emulator_set_cached_descriptor(struct desc_struct *desc, int seg,\n\t\t\t\t\t   struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment var;\n\n\t/* needed to preserve selector */\n\tkvm_get_segment(vcpu, &var, seg);\n\n\tvar.base = get_desc_base(desc);\n\tvar.limit = get_desc_limit(desc);\n\tif (desc->g)\n\t\tvar.limit = (var.limit << 12) | 0xfff;\n\tvar.type = desc->type;\n\tvar.present = desc->p;\n\tvar.dpl = desc->dpl;\n\tvar.db = desc->d;\n\tvar.s = desc->s;\n\tvar.l = desc->l;\n\tvar.g = desc->g;\n\tvar.avl = desc->avl;\n\tvar.present = desc->p;\n\tvar.unusable = !var.present;\n\tvar.padding = 0;\n\n\tkvm_set_segment(vcpu, &var, seg);\n\treturn;\n}\n", "target": 0, "idx": 41337}
{"func": " void AppShortcutManager::OnceOffCreateShortcuts() {\n  bool was_enabled = prefs_->GetBoolean(prefs::kAppShortcutsHaveBeenCreated);\n#if defined(OS_MACOSX)\n  bool is_now_enabled = apps::IsAppShimsEnabled();\n#else\n  bool is_now_enabled = true;\n#endif  // defined(OS_MACOSX)\n  if (was_enabled != is_now_enabled)\n    prefs_->SetBoolean(prefs::kAppShortcutsHaveBeenCreated, is_now_enabled);\n  if (was_enabled || !is_now_enabled)\n     return;\n \n   extensions::ExtensionSystem* extension_system;\n  ExtensionServiceInterface* extension_service;\n  if (!(extension_system = extensions::ExtensionSystem::Get(profile_)) ||\n      !(extension_service = extension_system->extension_service()))\n    return;\n\n  const extensions::ExtensionSet* apps = extension_service->extensions();\n  for (extensions::ExtensionSet::const_iterator it = apps->begin();\n       it != apps->end(); ++it) {\n    if (ShouldCreateShortcutFor(profile_, it->get()))\n      CreateShortcutsInApplicationsMenu(profile_, it->get());\n  }\n}\n", "target": 1, "idx": 184838}
{"func": "static void get_timewait4_sock(struct inet_timewait_sock *tw,\n\t\t\t       struct seq_file *f, int i, int *len)\n{\n\t__be32 dest, src;\n\t__u16 destp, srcp;\n\tint ttd = tw->tw_ttd - jiffies;\n\n\tif (ttd < 0)\n\t\tttd = 0;\n\n\tdest  = tw->tw_daddr;\n\tsrc   = tw->tw_rcv_saddr;\n\tdestp = ntohs(tw->tw_dport);\n\tsrcp  = ntohs(tw->tw_sport);\n\n\tseq_printf(f, \"%4d: %08X:%04X %08X:%04X\"\n\t\t\" %02X %08X:%08X %02X:%08lX %08X %5d %8d %d %d %p%n\",\n\t\ti, src, srcp, dest, destp, tw->tw_substate, 0, 0,\n\t\t3, jiffies_to_clock_t(ttd), 0, 0, 0, 0,\n\t\tatomic_read(&tw->tw_refcnt), tw, len);\n}\n", "target": 0, "idx": 18995}
{"func": "    LineLayoutState(bool fullLayout, LayoutUnit& repaintLogicalTop, LayoutUnit& repaintLogicalBottom, RenderFlowThread* flowThread)\n        : m_lastFloat(0)\n        , m_endLine(0)\n        , m_floatIndex(0)\n        , m_endLineLogicalTop(0)\n        , m_endLineMatched(false)\n        , m_checkForFloatsFromLastLine(false)\n        , m_isFullLayout(fullLayout)\n        , m_repaintLogicalTop(repaintLogicalTop)\n        , m_repaintLogicalBottom(repaintLogicalBottom)\n        , m_adjustedLogicalLineTop(0)\n        , m_usesRepaintBounds(false)\n        , m_flowThread(flowThread)\n    { }\n", "target": 0, "idx": 119556}
{"func": "XFixesFetchRegionAndBounds (Display\t    *dpy,\n\t\t\t    XserverRegion   region,\n\t\t\t    int\t\t    *nrectanglesRet,\n\t\t\t    XRectangle\t    *bounds)\n{\n    XFixesExtDisplayInfo\t*info = XFixesFindDisplay (dpy);\n    xXFixesFetchRegionReq\t*req;\n    xXFixesFetchRegionReply\trep;\n    XRectangle\t\t\t*rects;\n    int    \t\t\tnrects;\n    long    \t\t\tnbytes;\n    long\t\t\tnread;\n\n    XFixesCheckExtension (dpy, info, NULL);\n    LockDisplay (dpy);\n    GetReq (XFixesFetchRegion, req);\n    req->reqType = info->codes->major_opcode;\n    req->xfixesReqType = X_XFixesFetchRegion;\n    req->region = region;\n    *nrectanglesRet = 0;\n    if (!_XReply (dpy, (xReply *) &rep, 0, xFalse))\n    {\n\tUnlockDisplay (dpy);\n\tSyncHandle ();\n\treturn NULL;\n    }\n    bounds->x = rep.x;\n    bounds->y = rep.y;\n     bounds->y = rep.y;\n     bounds->width = rep.width;\n     bounds->height = rep.height;\n    nbytes = (long) rep.length << 2;\n    nrects = rep.length >> 1;\n    rects = Xmalloc (nrects * sizeof (XRectangle));\n     if (!rects)\n     {\n \t_XEatDataWords(dpy, rep.length);\n\t_XEatData (dpy, (unsigned long) (nbytes - nread));\n    }\n    UnlockDisplay (dpy);\n    SyncHandle();\n    *nrectanglesRet = nrects;\n    return rects;\n}\n", "target": 1, "idx": 178094}
{"func": "ofproto_port_get_stp_stats(struct ofproto *ofproto, ofp_port_t ofp_port,\n                           struct ofproto_port_stp_stats *s)\n{\n    struct ofport *ofport = ofproto_get_port(ofproto, ofp_port);\n    if (!ofport) {\n        VLOG_WARN_RL(&rl, \"%s: cannot get STP stats on nonexistent \"\n                     \"port %\"PRIu32, ofproto->name, ofp_port);\n        return ENODEV;\n    }\n\n    return (ofproto->ofproto_class->get_stp_port_stats\n            ? ofproto->ofproto_class->get_stp_port_stats(ofport, s)\n            : EOPNOTSUPP);\n}\n", "target": 0, "idx": 77356}
{"func": "static void tun_net_init(struct net_device *dev)\n{\n\tstruct tun_struct *tun = netdev_priv(dev);\n\n\tswitch (tun->flags & TUN_TYPE_MASK) {\n\tcase TUN_TUN_DEV:\n\t\tdev->netdev_ops = &tun_netdev_ops;\n\n\t\t/* Point-to-Point TUN Device */\n\t\tdev->hard_header_len = 0;\n\t\tdev->addr_len = 0;\n\t\tdev->mtu = 1500;\n\n\t\t/* Zero header length */\n\t\tdev->type = ARPHRD_NONE;\n\t\tdev->flags = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST;\n\t\tdev->tx_queue_len = TUN_READQ_SIZE;  /* We prefer our own queue length */\n\t\tbreak;\n\n\tcase TUN_TAP_DEV:\n \t\tdev->netdev_ops = &tap_netdev_ops;\n \t\t/* Ethernet TAP Device */\n \t\tether_setup(dev);\n \n \t\trandom_ether_addr(dev->dev_addr);\n \n\t\tdev->tx_queue_len = TUN_READQ_SIZE;  /* We prefer our own queue length */\n\t\tbreak;\n\t}\n}\n", "target": 1, "idx": 178902}
{"func": "base::FilePath DownloadPathReservationTrackerTest::GetPathInDownloadsDirectory(\n    const base::FilePath::CharType* suffix) {\n  return default_download_path().Append(suffix).NormalizePathSeparators();\n}\n", "target": 0, "idx": 127162}
{"func": "    StateBase* writeBlob(v8::Handle<v8::Value> value, StateBase* next)\n    {\n        Blob* blob = V8Blob::toNative(value.As<v8::Object>());\n        if (!blob)\n            return 0;\n         if (blob->hasBeenClosed())\n             return handleError(DataCloneError, \"A Blob object has been closed, and could therefore not be cloned.\", next);\n         int blobIndex = -1;\n        m_blobDataHandles.add(blob->uuid(), blob->blobDataHandle());\n         if (appendBlobInfo(blob->uuid(), blob->type(), blob->size(), &blobIndex))\n             m_writer.writeBlobIndex(blobIndex);\n         else\n            m_writer.writeBlob(blob->uuid(), blob->type(), blob->size());\n        return 0;\n    }\n", "target": 1, "idx": 185354}
{"func": " int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)\n {\n \tu16 offset = sizeof(struct ipv6hdr);\n\tstruct ipv6_opt_hdr *exthdr =\n\t\t\t\t(struct ipv6_opt_hdr *)(ipv6_hdr(skb) + 1);\n \tunsigned int packet_len = skb_tail_pointer(skb) -\n \t\tskb_network_header(skb);\n \tint found_rhdr = 0;\n \t*nexthdr = &ipv6_hdr(skb)->nexthdr;\n \n\twhile (offset + 1 <= packet_len) {\n \n \t\tswitch (**nexthdr) {\n \n\t\tcase NEXTHDR_HOP:\n\t\t\tbreak;\n\t\tcase NEXTHDR_ROUTING:\n\t\t\tfound_rhdr = 1;\n\t\t\tbreak;\n\t\tcase NEXTHDR_DEST:\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\t\t\tif (ipv6_find_tlv(skb, offset, IPV6_TLV_HAO) >= 0)\n\t\t\t\tbreak;\n#endif\n\t\t\tif (found_rhdr)\n\t\t\t\treturn offset;\n\t\t\tbreak;\n\t\tdefault:\n \t\t\treturn offset;\n \t\t}\n \n\t\toffset += ipv6_optlen(exthdr);\n\t\t*nexthdr = &exthdr->nexthdr;\n \t\texthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +\n \t\t\t\t\t\t offset);\n \t}\n \n\treturn offset;\n }\n", "target": 1, "idx": 181304}
{"func": " void VarianceTest<VarianceFunctionType>::ZeroTest() {\n   for (int i = 0; i <= 255; ++i) {\n    memset(src_, i, block_size_);\n     for (int j = 0; j <= 255; ++j) {\n      memset(ref_, j, block_size_);\n       unsigned int sse;\n       unsigned int var;\n      REGISTER_STATE_CHECK(var = variance_(src_, width_, ref_, width_, &sse));\n      EXPECT_EQ(0u, var) << \"src values: \" << i << \"ref values: \" << j;\n     }\n   }\n }\n", "target": 1, "idx": 188615}
{"func": "ProcEstablishConnection(ClientPtr client)\n{\n    const char *reason;\n    char *auth_proto, *auth_string;\n    xConnClientPrefix *prefix;\n\n    REQUEST(xReq);\n\n     prefix = (xConnClientPrefix *) ((char *) stuff + sz_xReq);\n     auth_proto = (char *) prefix + sz_xConnClientPrefix;\n     auth_string = auth_proto + pad_to_int32(prefix->nbytesAuthProto);\n    if ((prefix->majorVersion != X_PROTOCOL) ||\n         (prefix->minorVersion != X_PROTOCOL_REVISION))\n         reason = \"Protocol version mismatch\";\n     else\n\n    return (SendConnSetup(client, reason));\n}\n", "target": 1, "idx": 178620}
{"func": "bool LayoutSVGTransformableContainer::calculateLocalTransform()\n {\n     SVGGraphicsElement* element = toSVGGraphicsElement(this->element());\n     ASSERT(element);\n\n    SVGUseElement* useElement = nullptr;\n    if (isSVGUseElement(*element)) {\n        useElement = toSVGUseElement(element);\n    } else if (isSVGGElement(*element) && toSVGGElement(element)->inUseShadowTree()) {\n        SVGElement* correspondingElement = element->correspondingElement();\n        if (isSVGUseElement(correspondingElement))\n            useElement = toSVGUseElement(correspondingElement);\n    }\n\n    if (useElement) {\n        SVGLengthContext lengthContext(useElement);\n         FloatSize translation(\n             useElement->x()->currentValue()->value(lengthContext),\n             useElement->y()->currentValue()->value(lengthContext));\n         if (translation != m_additionalTranslation)\n            m_needsTransformUpdate = true;\n         m_additionalTranslation = translation;\n     }\n \n     if (!m_needsTransformUpdate)\n        return false;\n \n     m_localTransform = element->calculateAnimatedLocalTransform();\n     m_localTransform.translate(m_additionalTranslation.width(), m_additionalTranslation.height());\n     m_needsTransformUpdate = false;\n    return true;\n }\n", "target": 1, "idx": 185370}
{"func": "static ZIPARCHIVE_METHOD(addEmptyDir)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tchar *dirname;\n\tsize_t   dirname_len;\n\tint idx;\n\tstruct zip_stat sb;\n\tchar *s;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s\",\n\t\t\t\t&dirname, &dirname_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (dirname_len<1) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (dirname[dirname_len-1] != '/') {\n\t\ts=(char *)emalloc(dirname_len+2);\n\t\tstrcpy(s, dirname);\n\t\ts[dirname_len] = '/';\n\t\ts[dirname_len+1] = '\\0';\n\t} else {\n\t\ts = dirname;\n\t}\n\n\tidx = zip_stat(intern, s, 0, &sb);\n\tif (idx >= 0) {\n\t\tRETVAL_FALSE;\n\t} else {\n\t\tif (zip_add_dir(intern, (const char *)s) == -1) {\n\t\t\tRETVAL_FALSE;\n\t\t}\n\t\tzip_error_clear(intern);\n\t\tRETVAL_TRUE;\n\t}\n\n\tif (s != dirname) {\n\t\tefree(s);\n\t}\n}\n", "target": 0, "idx": 54390}
{"func": "static int generate_key(DH *dh)\n{\n     int ok = 0;\n     int generate_new_key = 0;\n     unsigned l;\n    BN_CTX *ctx;\n     BN_MONT_CTX *mont = NULL;\n     BIGNUM *pub_key = NULL, *priv_key = NULL;\n \n     ctx = BN_CTX_new();\n     if (ctx == NULL)\n         goto err;\n        generate_new_key = 1;\n    } else\n", "target": 1, "idx": 178504}
{"func": "static int save_avio_options(AVFormatContext *s)\n{\n    HLSContext *c = s->priv_data;\n    static const char *opts[] = {\n        \"headers\", \"http_proxy\", \"user_agent\", \"user-agent\", \"cookies\", NULL };\n    const char **opt = opts;\n    uint8_t *buf;\n    int ret = 0;\n\n    while (*opt) {\n        if (av_opt_get(s->pb, *opt, AV_OPT_SEARCH_CHILDREN | AV_OPT_ALLOW_NULL, &buf) >= 0) {\n            ret = av_dict_set(&c->avio_opts, *opt, buf,\n                              AV_DICT_DONT_STRDUP_VAL);\n            if (ret < 0)\n                return ret;\n        }\n        opt++;\n    }\n\n    return ret;\n}\n", "target": 0, "idx": 61817}
{"func": "val_wrap_iov_args(\n    OM_uint32 *minor_status,\n    gss_ctx_id_t context_handle,\n    int conf_req_flag,\n    gss_qop_t qop_req,\n    int *conf_state,\n    gss_iov_buffer_desc *iov,\n    int iov_count)\n{\n\n    /* Initialize outputs. */\n\n    if (minor_status != NULL)\n\t*minor_status = 0;\n\n    /* Validate arguments. */\n\n    if (minor_status == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n\n    if (iov == GSS_C_NO_IOV_BUFFER)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ);\n\n    return (GSS_S_COMPLETE);\n}\n", "target": 0, "idx": 63356}
{"func": "static long ion_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct ion_client *client = filp->private_data;\n\tstruct ion_device *dev = client->dev;\n\tstruct ion_handle *cleanup_handle = NULL;\n\tint ret = 0;\n\tunsigned int dir;\n\n\tunion {\n\t\tstruct ion_fd_data fd;\n\t\tstruct ion_allocation_data allocation;\n\t\tstruct ion_handle_data handle;\n\t\tstruct ion_custom_data custom;\n\t} data;\n\n\tdir = ion_ioctl_dir(cmd);\n\n\tif (_IOC_SIZE(cmd) > sizeof(data))\n\t\treturn -EINVAL;\n\n\tif (dir & _IOC_WRITE)\n\t\tif (copy_from_user(&data, (void __user *)arg, _IOC_SIZE(cmd)))\n\t\t\treturn -EFAULT;\n\n\tswitch (cmd) {\n\tcase ION_IOC_ALLOC:\n\t{\n\t\tstruct ion_handle *handle;\n\n\t\thandle = ion_alloc(client, data.allocation.len,\n\t\t\t\t\t\tdata.allocation.align,\n\t\t\t\t\t\tdata.allocation.heap_id_mask,\n\t\t\t\t\t\tdata.allocation.flags);\n\t\tif (IS_ERR(handle))\n\t\t\treturn PTR_ERR(handle);\n\n\t\tdata.allocation.handle = handle->id;\n\n\t\tcleanup_handle = handle;\n\t\tbreak;\n\t}\n\tcase ION_IOC_FREE:\n \t{\n \t\tstruct ion_handle *handle;\n \n\t\thandle = ion_handle_get_by_id(client, data.handle.handle);\n\t\tif (IS_ERR(handle))\n \t\t\treturn PTR_ERR(handle);\n\t\tion_free(client, handle);\n\t\tion_handle_put(handle);\n \t\tbreak;\n \t}\n \tcase ION_IOC_SHARE:\n\tcase ION_IOC_MAP:\n\t{\n\t\tstruct ion_handle *handle;\n\n\t\thandle = ion_handle_get_by_id(client, data.handle.handle);\n\t\tif (IS_ERR(handle))\n\t\t\treturn PTR_ERR(handle);\n\t\tdata.fd.fd = ion_share_dma_buf_fd(client, handle);\n\t\tion_handle_put(handle);\n\t\tif (data.fd.fd < 0)\n\t\t\tret = data.fd.fd;\n\t\tbreak;\n\t}\n\tcase ION_IOC_IMPORT:\n\t{\n\t\tstruct ion_handle *handle;\n\n\t\thandle = ion_import_dma_buf_fd(client, data.fd.fd);\n\t\tif (IS_ERR(handle))\n\t\t\tret = PTR_ERR(handle);\n\t\telse\n\t\t\tdata.handle.handle = handle->id;\n\t\tbreak;\n\t}\n\tcase ION_IOC_SYNC:\n\t{\n\t\tret = ion_sync_for_device(client, data.fd.fd);\n\t\tbreak;\n\t}\n\tcase ION_IOC_CUSTOM:\n\t{\n\t\tif (!dev->custom_ioctl)\n\t\t\treturn -ENOTTY;\n\t\tret = dev->custom_ioctl(client, data.custom.cmd,\n\t\t\t\t\t\tdata.custom.arg);\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n\n\tif (dir & _IOC_READ) {\n\t\tif (copy_to_user((void __user *)arg, &data, _IOC_SIZE(cmd))) {\n\t\t\tif (cleanup_handle)\n\t\t\t\tion_free(client, cleanup_handle);\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\treturn ret;\n}\n", "target": 1, "idx": 180071}
{"func": "static void update_group_shares_cpu(struct task_group *tg, int cpu,\n\t\t\t\t    unsigned long sd_shares,\n\t\t\t\t    unsigned long sd_rq_weight,\n\t\t\t\t    unsigned long *usd_rq_weight)\n{\n\tunsigned long shares, rq_weight;\n\tint boost = 0;\n\n\trq_weight = usd_rq_weight[cpu];\n\tif (!rq_weight) {\n\t\tboost = 1;\n\t\trq_weight = NICE_0_LOAD;\n\t}\n\n\t/*\n\t *             \\Sum_j shares_j * rq_weight_i\n\t * shares_i =  -----------------------------\n\t *                  \\Sum_j rq_weight_j\n\t */\n\tshares = (sd_shares * rq_weight) / sd_rq_weight;\n\tshares = clamp_t(unsigned long, shares, MIN_SHARES, MAX_SHARES);\n\n\tif (abs(shares - tg->se[cpu]->load.weight) >\n\t\t\tsysctl_sched_shares_thresh) {\n\t\tstruct rq *rq = cpu_rq(cpu);\n\t\tunsigned long flags;\n\n\t\traw_spin_lock_irqsave(&rq->lock, flags);\n\t\ttg->cfs_rq[cpu]->rq_weight = boost ? 0 : rq_weight;\n\t\ttg->cfs_rq[cpu]->shares = boost ? 0 : shares;\n\t\t__set_se_shares(tg->se[cpu], shares);\n\t\traw_spin_unlock_irqrestore(&rq->lock, flags);\n\t}\n}\n", "target": 0, "idx": 22649}
{"func": "static void sample_hbp_handler(struct perf_event *bp, int nmi,\n \t\t\t       struct perf_sample_data *data,\n \t\t\t       struct pt_regs *regs)\n {\n\tprintk(KERN_INFO \"%s value is changed\\n\", ksym_name);\n\tdump_stack();\n\tprintk(KERN_INFO \"Dump stack from sample_hbp_handler\\n\");\n}\n", "target": 1, "idx": 179017}
{"func": "group_sched_in(struct perf_event *group_event,\n\t       struct perf_cpu_context *cpuctx,\n\t       struct perf_event_context *ctx)\n{\n\tstruct perf_event *event, *partial_group = NULL;\n\tstruct pmu *pmu = group_event->pmu;\n\tu64 now = ctx->time;\n\tbool simulate = false;\n\n\tif (group_event->state == PERF_EVENT_STATE_OFF)\n\t\treturn 0;\n\n\tpmu->start_txn(pmu);\n\n\tif (event_sched_in(group_event, cpuctx, ctx)) {\n\t\tpmu->cancel_txn(pmu);\n\t\treturn -EAGAIN;\n\t}\n\n\t/*\n\t * Schedule in siblings as one group (if any):\n\t */\n\tlist_for_each_entry(event, &group_event->sibling_list, group_entry) {\n\t\tif (event_sched_in(event, cpuctx, ctx)) {\n\t\t\tpartial_group = event;\n\t\t\tgoto group_error;\n\t\t}\n\t}\n\n\tif (!pmu->commit_txn(pmu))\n\t\treturn 0;\n\ngroup_error:\n\t/*\n\t * Groups can be scheduled in as one unit only, so undo any\n\t * partial group before returning:\n\t * The events up to the failed event are scheduled out normally,\n\t * tstamp_stopped will be updated.\n\t *\n\t * The failed events and the remaining siblings need to have\n\t * their timings updated as if they had gone thru event_sched_in()\n\t * and event_sched_out(). This is required to get consistent timings\n\t * across the group. This also takes care of the case where the group\n\t * could never be scheduled by ensuring tstamp_stopped is set to mark\n\t * the time the event was actually stopped, such that time delta\n\t * calculation in update_event_times() is correct.\n\t */\n\tlist_for_each_entry(event, &group_event->sibling_list, group_entry) {\n\t\tif (event == partial_group)\n\t\t\tsimulate = true;\n\n\t\tif (simulate) {\n\t\t\tevent->tstamp_running += now - event->tstamp_stopped;\n\t\t\tevent->tstamp_stopped = now;\n\t\t} else {\n\t\t\tevent_sched_out(event, cpuctx, ctx);\n\t\t}\n\t}\n\tevent_sched_out(group_event, cpuctx, ctx);\n\n\tpmu->cancel_txn(pmu);\n\n\treturn -EAGAIN;\n}\n", "target": 0, "idx": 26010}
{"func": "void TaskManagerTableModel::GetGroupRangeForItem(int item,\n                                                 views::GroupRange* range) {\n  TaskManagerModel::GroupRange range_pair =\n      model_->GetGroupRangeForResource(item);\n  range->start = range_pair.first;\n  range->length = range_pair.second;\n}\n", "target": 0, "idx": 114045}
{"func": " int mif_validate(jas_stream_t *in)\n {\n\tuchar buf[MIF_MAGICLEN];\n \tuint_fast32_t magic;\n \tint i;\n \tint n;\n\n\tassert(JAS_STREAM_MAXPUTBACK >= MIF_MAGICLEN);\n\n\t/* Read the validation data (i.e., the data used for detecting\n\t  the format). */\n\tif ((n = jas_stream_read(in, buf, MIF_MAGICLEN)) < 0) {\n\t\treturn -1;\n\t}\n\n\t/* Put the validation data back onto the stream, so that the\n\t  stream position will not be changed. */\n\tfor (i = n - 1; i >= 0; --i) {\n\t\tif (jas_stream_ungetc(in, buf[i]) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Was enough data read? */\n\tif (n < MIF_MAGICLEN) {\n\t\treturn -1;\n\t}\n\n\t/* Compute the signature value. */\n\tmagic = (JAS_CAST(uint_fast32_t, buf[0]) << 24) |\n\t  (JAS_CAST(uint_fast32_t, buf[1]) << 16) |\n\t  (JAS_CAST(uint_fast32_t, buf[2]) << 8) |\n\t  buf[3];\n\n\t/* Ensure that the signature is correct for this format. */\n\tif (magic != MIF_MAGIC) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n", "target": 1, "idx": 181897}
{"func": "static void logi_dj_recv_add_djhid_device(struct dj_receiver_dev *djrcv_dev,\n\t\t\t\t\t  struct dj_report *dj_report)\n{\n\t/* Called in delayed work context */\n\tstruct hid_device *djrcv_hdev = djrcv_dev->hdev;\n\tstruct usb_interface *intf = to_usb_interface(djrcv_hdev->dev.parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(intf);\n\tstruct hid_device *dj_hiddev;\n\tstruct dj_device *dj_dev;\n\n\t/* Device index goes from 1 to 6, we need 3 bytes to store the\n\t * semicolon, the index, and a null terminator\n\t */\n\tunsigned char tmpstr[3];\n\n\tif (dj_report->report_params[DEVICE_PAIRED_PARAM_SPFUNCTION] &\n\t    SPFUNCTION_DEVICE_LIST_EMPTY) {\n\t\tdbg_hid(\"%s: device list is empty\\n\", __func__);\n\t\tdjrcv_dev->querying_devices = false;\n \t\treturn;\n \t}\n \n\tif ((dj_report->device_index < DJ_DEVICE_INDEX_MIN) ||\n\t    (dj_report->device_index > DJ_DEVICE_INDEX_MAX)) {\n\t\tdev_err(&djrcv_hdev->dev, \"%s: invalid device index:%d\\n\",\n\t\t\t__func__, dj_report->device_index);\n\t\treturn;\n\t}\n \tif (djrcv_dev->paired_dj_devices[dj_report->device_index]) {\n \t\t/* The device is already known. No need to reallocate it. */\n \t\tdbg_hid(\"%s: device is already known\\n\", __func__);\n\t\treturn;\n\t}\n\n\tdj_hiddev = hid_allocate_device();\n\tif (IS_ERR(dj_hiddev)) {\n\t\tdev_err(&djrcv_hdev->dev, \"%s: hid_allocate_device failed\\n\",\n\t\t\t__func__);\n\t\treturn;\n\t}\n\n\tdj_hiddev->ll_driver = &logi_dj_ll_driver;\n\n\tdj_hiddev->dev.parent = &djrcv_hdev->dev;\n\tdj_hiddev->bus = BUS_USB;\n\tdj_hiddev->vendor = le16_to_cpu(usbdev->descriptor.idVendor);\n\tdj_hiddev->product = le16_to_cpu(usbdev->descriptor.idProduct);\n\tsnprintf(dj_hiddev->name, sizeof(dj_hiddev->name),\n\t\t\"Logitech Unifying Device. Wireless PID:%02x%02x\",\n\t\tdj_report->report_params[DEVICE_PAIRED_PARAM_EQUAD_ID_MSB],\n\t\tdj_report->report_params[DEVICE_PAIRED_PARAM_EQUAD_ID_LSB]);\n\n\tusb_make_path(usbdev, dj_hiddev->phys, sizeof(dj_hiddev->phys));\n\tsnprintf(tmpstr, sizeof(tmpstr), \":%d\", dj_report->device_index);\n\tstrlcat(dj_hiddev->phys, tmpstr, sizeof(dj_hiddev->phys));\n\n\tdj_dev = kzalloc(sizeof(struct dj_device), GFP_KERNEL);\n\n\tif (!dj_dev) {\n\t\tdev_err(&djrcv_hdev->dev, \"%s: failed allocating dj_device\\n\",\n\t\t\t__func__);\n\t\tgoto dj_device_allocate_fail;\n\t}\n\n\tdj_dev->reports_supported = get_unaligned_le32(\n\t\tdj_report->report_params + DEVICE_PAIRED_RF_REPORT_TYPE);\n\tdj_dev->hdev = dj_hiddev;\n\tdj_dev->dj_receiver_dev = djrcv_dev;\n\tdj_dev->device_index = dj_report->device_index;\n\tdj_hiddev->driver_data = dj_dev;\n\n\tdjrcv_dev->paired_dj_devices[dj_report->device_index] = dj_dev;\n\n\tif (hid_add_device(dj_hiddev)) {\n\t\tdev_err(&djrcv_hdev->dev, \"%s: failed adding dj_device\\n\",\n\t\t\t__func__);\n\t\tgoto hid_add_device_fail;\n\t}\n\n\treturn;\n\nhid_add_device_fail:\n\tdjrcv_dev->paired_dj_devices[dj_report->device_index] = NULL;\n\tkfree(dj_dev);\ndj_device_allocate_fail:\n\thid_destroy_device(dj_hiddev);\n}\n", "target": 1, "idx": 179550}
{"func": " pvscsi_ring_init_data(PVSCSIRingInfo *m, PVSCSICmdDescSetupRings *ri)\n {\n     int i;\n    uint32_t txr_len_log2, rxr_len_log2;\n     uint32_t req_ring_size, cmp_ring_size;\n     m->rs_pa = ri->ringsStatePPN << VMW_PAGE_SHIFT;\n \n    if ((ri->reqRingNumPages > PVSCSI_SETUP_RINGS_MAX_NUM_PAGES)\n        || (ri->cmpRingNumPages > PVSCSI_SETUP_RINGS_MAX_NUM_PAGES)) {\n        return -1;\n    }\n     req_ring_size = ri->reqRingNumPages * PVSCSI_MAX_NUM_REQ_ENTRIES_PER_PAGE;\n     cmp_ring_size = ri->cmpRingNumPages * PVSCSI_MAX_NUM_CMP_ENTRIES_PER_PAGE;\n     txr_len_log2 = pvscsi_log2(req_ring_size - 1);\n    }\n", "target": 1, "idx": 178109}
{"func": "bool HTMLMediaElement::HasClosedCaptions() const {\n  if (!text_tracks_)\n    return false;\n\n  for (unsigned i = 0; i < text_tracks_->length(); ++i) {\n    if (text_tracks_->AnonymousIndexedGetter(i)->CanBeRendered())\n      return true;\n  }\n\n  return false;\n}\n", "target": 0, "idx": 142807}
{"func": "static gboolean irssi_ssl_verify(SSL *ssl, SSL_CTX *ctx, X509 *cert)\n {\n \tif (SSL_get_verify_result(ssl) != X509_V_OK) {\n \t\tunsigned char md[EVP_MAX_MD_SIZE];\n\t\tunsigned int n;\n\t\tchar *str;\n\n\t\tg_warning(\"Could not verify SSL servers certificate:\");\n\t\tif ((str = X509_NAME_oneline(X509_get_subject_name(cert), 0, 0)) == NULL)\n\t\t\tg_warning(\"  Could not get subject-name from peer certificate\");\n\t\telse {\n\t\t\tg_warning(\"  Subject : %s\", str);\n\t\t\tfree(str);\n\t\t}\n\t\tif ((str = X509_NAME_oneline(X509_get_issuer_name(cert), 0, 0)) == NULL)\n\t\t\tg_warning(\"  Could not get issuer-name from peer certificate\");\n\t\telse {\n\t\t\tg_warning(\"  Issuer  : %s\", str);\n\t\t\tfree(str);\n\t\t}\n\t\tif (! X509_digest(cert, EVP_md5(), md, &n))\n\t\t\tg_warning(\"  Could not get fingerprint from peer certificate\");\n\t\telse {\n\t\t\tchar hex[] = \"0123456789ABCDEF\";\n\t\t\tchar fp[EVP_MAX_MD_SIZE*3];\n\t\t\tif (n < sizeof(fp)) {\n\t\t\t\tunsigned int i;\n\t\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\t\tfp[i*3+0] = hex[(md[i] >> 4) & 0xF];\n\t\t\t\t\tfp[i*3+1] = hex[(md[i] >> 0) & 0xF];\n\t\t\t\t\tfp[i*3+2] = i == n - 1 ? '\\0' : ':';\n\t\t\t\t}\n\t\t\t\tg_warning(\"  MD5 Fingerprint : %s\", fp);\n \t\t\t}\n \t\t}\n \t\treturn FALSE;\n \t}\n \treturn TRUE;\n }\n", "target": 1, "idx": 178690}
{"func": "MagickExport int ErrorBlob(const Image *image)\n{\n  BlobInfo\n    *magick_restrict blob_info;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->blob != (BlobInfo *) NULL);\n  assert(image->blob->type != UndefinedStream);\n  blob_info=image->blob;\n  switch (blob_info->type)\n  {\n    case UndefinedStream:\n    case StandardStream:\n      break;\n    case FileStream:\n    case PipeStream:\n    {\n      blob_info->error=ferror(blob_info->file_info.file);\n      break;\n    }\n    case ZipStream:\n    {\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n      (void) gzerror(blob_info->file_info.gzfile,&blob_info->error);\n#endif\n      break;\n    }\n    case BZipStream:\n    {\n#if defined(MAGICKCORE_BZLIB_DELEGATE)\n      (void) BZ2_bzerror(blob_info->file_info.bzfile,&blob_info->error);\n#endif\n      break;\n    }\n    case FifoStream:\n    {\n      blob_info->error=0;\n      break;\n    }\n    case BlobStream:\n      break;\n  }\n  return(blob_info->error);\n}\n", "target": 0, "idx": 88514}
{"func": "OMX_ERRORTYPE SimpleSoftOMXComponent::internalSetParameter(\n        OMX_INDEXTYPE index, const OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamPortDefinition:\n {\n\n             OMX_PARAM_PORTDEFINITIONTYPE *defParams =\n                 (OMX_PARAM_PORTDEFINITIONTYPE *)params;\n \n             if (defParams->nPortIndex >= mPorts.size()) {\n                 return OMX_ErrorBadPortIndex;\n             }\n if (defParams->nSize != sizeof(OMX_PARAM_PORTDEFINITIONTYPE)) {\n return OMX_ErrorUnsupportedSetting;\n }\n\n PortInfo *port =\n &mPorts.editItemAt(defParams->nPortIndex);\n\n if (defParams->nBufferSize > port->mDef.nBufferSize) {\n                port->mDef.nBufferSize = defParams->nBufferSize;\n }\n\n if (defParams->nBufferCountActual < port->mDef.nBufferCountMin) {\n                ALOGW(\"component requires at least %u buffers (%u requested)\",\n                        port->mDef.nBufferCountMin, defParams->nBufferCountActual);\n return OMX_ErrorUnsupportedSetting;\n }\n\n            port->mDef.nBufferCountActual = defParams->nBufferCountActual;\n return OMX_ErrorNone;\n }\n\n default:\n return OMX_ErrorUnsupportedIndex;\n }\n}\n", "target": 1, "idx": 188245}
{"func": "SYSCALL_DEFINE2(listen, int, fd, int, backlog)\n{\n\tstruct socket *sock;\n\tint err, fput_needed;\n\tint somaxconn;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (sock) {\n\t\tsomaxconn = sock_net(sock->sk)->core.sysctl_somaxconn;\n\t\tif ((unsigned int)backlog > somaxconn)\n\t\t\tbacklog = somaxconn;\n\n\t\terr = security_socket_listen(sock, backlog);\n\t\tif (!err)\n\t\t\terr = sock->ops->listen(sock, backlog);\n\n\t\tfput_light(sock->file, fput_needed);\n\t}\n\treturn err;\n}\n", "target": 0, "idx": 18608}
{"func": "static int nbd_negotiate_drop_sync(QIOChannel *ioc, size_t size)\n{\n    ssize_t ret;\n    uint8_t *buffer = g_malloc(MIN(65536, size));\n    while (size > 0) {\n        size_t count = MIN(65536, size);\n        ret = nbd_negotiate_read(ioc, buffer, count);\n        if (ret < 0) {\n            g_free(buffer);\n            return ret;\n        }\n        size -= count;\n    }\n    g_free(buffer);\n    return 0;\n}\n", "target": 1, "idx": 178625}
{"func": "void SelectionEditor::DidSplitTextNode(const Text& old_node) {\n  if (selection_.IsNone() || !old_node.isConnected()) {\n    DidFinishDOMMutation();\n    return;\n  }\n  const Position& new_base =\n      UpdatePostionAfterAdoptingTextNodeSplit(selection_.base_, old_node);\n  const Position& new_extent =\n      UpdatePostionAfterAdoptingTextNodeSplit(selection_.extent_, old_node);\n  DidFinishTextChange(new_base, new_extent);\n}\n", "target": 0, "idx": 135825}
{"func": "  int clear_count() const { return clear_count_; }\n", "target": 0, "idx": 167385}
{"func": "  bool IsMultiByteResponseExpected() {\n    return multibyte_response_expected_;\n  }\n", "target": 0, "idx": 98781}
{"func": "static int cypress_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tstruct cypress_private *priv = usb_get_serial_port_data(port);\n\tstruct usb_serial *serial = port->serial;\n\tunsigned long flags;\n\tint result = 0;\n\n\tif (!priv->comm_is_ok)\n\t\treturn -EIO;\n\n\t/* clear halts before open */\n\tusb_clear_halt(serial->dev, 0x81);\n\tusb_clear_halt(serial->dev, 0x02);\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\t/* reset read/write statistics */\n\tpriv->bytes_in = 0;\n\tpriv->bytes_out = 0;\n\tpriv->cmd_count = 0;\n\tpriv->rx_flags = 0;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\t/* Set termios */\n\tcypress_send(port);\n\n\tif (tty)\n \t\tcypress_set_termios(tty, port, &priv->tmp_termios);\n \n \t/* setup the port and start reading from the device */\n\tif (!port->interrupt_in_urb) {\n\t\tdev_err(&port->dev, \"%s - interrupt_in_urb is empty!\\n\",\n\t\t\t__func__);\n\t\treturn -1;\n\t}\n \tusb_fill_int_urb(port->interrupt_in_urb, serial->dev,\n \t\tusb_rcvintpipe(serial->dev, port->interrupt_in_endpointAddress),\n \t\tport->interrupt_in_urb->transfer_buffer,\n\t\tport->interrupt_in_urb->transfer_buffer_length,\n\t\tcypress_read_int_callback, port, priv->read_urb_interval);\n\tresult = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);\n\n\tif (result) {\n\t\tdev_err(&port->dev,\n\t\t\t\"%s - failed submitting read urb, error %d\\n\",\n\t\t\t\t\t\t\t__func__, result);\n\t\tcypress_set_dead(port);\n\t}\n\n\treturn result;\n} /* cypress_open */\n", "target": 1, "idx": 180532}
{"func": "static bool IsValidElementName(Document* document, const String& name) {\n  bool is_valid_dom_name = Document::IsValidName(name);\n  bool is_valid_html_name = IsValidElementNamePerHTMLParser(name);\n  if (UNLIKELY(is_valid_html_name != is_valid_dom_name)) {\n    UseCounter::Count(document,\n                      is_valid_dom_name\n                          ? WebFeature::kElementNameDOMValidHTMLParserInvalid\n                          : WebFeature::kElementNameDOMInvalidHTMLParserValid);\n  }\n  return is_valid_dom_name;\n}\n", "target": 0, "idx": 141140}
{"func": "static inline void removeElementPreservingChildren(PassRefPtr<DocumentFragment> fragment, HTMLElement* element)\n{\n    ExceptionCode ignoredExceptionCode;\n    RefPtr<Node> nextChild;\n    for (RefPtr<Node> child = element->firstChild(); child; child = nextChild) {\n        nextChild = child->nextSibling();\n        element->removeChild(child.get(), ignoredExceptionCode);\n        ASSERT(!ignoredExceptionCode);\n        fragment->insertBefore(child, element, ignoredExceptionCode);\n        ASSERT(!ignoredExceptionCode);\n    }\n    fragment->removeChild(element, ignoredExceptionCode);\n    ASSERT(!ignoredExceptionCode);\n}\n", "target": 1, "idx": 183893}
{"func": " pdf_show_image(fz_context *ctx, pdf_run_processor *pr, fz_image *image)\n {\n        pdf_gstate *gstate = pr->gstate + pr->gtop;\n        fz_matrix image_ctm;\n        fz_rect bbox;\n       softmask_save softmask = { NULL };\n \n        if (pr->super.hidden)\n                return;\n\t\t\tbreak;\n\t\tcase PDF_MAT_SHADE:\n\t\t\tif (gstate->fill.shade)\n\t\t\t{\n\t\t\t\tfz_clip_image_mask(ctx, pr->dev, image, &image_ctm, &bbox);\n        bbox = fz_unit_rect;\n        fz_transform_rect(&bbox, &image_ctm);\n \n       if (image->mask)\n        {\n                /* apply blend group even though we skip the soft mask */\n               if (gstate->blendmode)\n                       fz_begin_group(ctx, pr->dev, &bbox, NULL, 0, 0, gstate->blendmode, 1);\n               fz_clip_image_mask(ctx, pr->dev, image->mask, &image_ctm, &bbox);\n       }\n       else\n               gstate = pdf_begin_group(ctx, pr, &bbox, &softmask);\n \n       if (!image->colorspace)\n       {\n               switch (gstate->fill.kind)\n                {\n               case PDF_MAT_NONE:\n                       break;\n               case PDF_MAT_COLOR:\n                       fz_fill_image_mask(ctx, pr->dev, image, &image_ctm,\n                               gstate->fill.colorspace, gstate->fill.v, gstate->fill.alpha, &gstate->fill.color_params);\n                       break;\n               case PDF_MAT_PATTERN:\n                       if (gstate->fill.pattern)\n                       {\n                               fz_clip_image_mask(ctx, pr->dev, image, &image_ctm, &bbox);\n                               pdf_show_pattern(ctx, pr, gstate->fill.pattern, &pr->gstate[gstate->fill.gstate_num], &bbox, PDF_FILL);\n                               fz_pop_clip(ctx, pr->dev);\n                       }\n                       break;\n               case PDF_MAT_SHADE:\n                       if (gstate->fill.shade)\n                       {\n                               fz_clip_image_mask(ctx, pr->dev, image, &image_ctm, &bbox);\n                               fz_fill_shade(ctx, pr->dev, gstate->fill.shade, &pr->gstate[gstate->fill.gstate_num].ctm, gstate->fill.alpha, &gstate->fill.color_params);\n                               fz_pop_clip(ctx, pr->dev);\n                       }\n                       break;\n                }\n        }\n       else\n        {\n               fz_fill_image(ctx, pr->dev, image, &image_ctm, gstate->fill.alpha, &gstate->fill.color_params);\n        }\n       if (image->mask)\n        {\n               fz_pop_clip(ctx, pr->dev);\n               if (gstate->blendmode)\n                       fz_end_group(ctx, pr->dev);\n        }\n       else\n               pdf_end_group(ctx, pr, &softmask);\n }\n \n static void\n\n\t\tif (pr->clip)\n\t\t{\n\t\t\tgstate->clip_depth++;\n\t\t\tfz_clip_path(ctx, pr->dev, path, pr->clip_even_odd, &gstate->ctm, &bbox);\n\t\t\tpr->clip = 0;\n\t\t}\n\n\t\tif (pr->super.hidden)\n\t\t\tdostroke = dofill = 0;\n\n\t\tif (dofill || dostroke)\n\t\t\tgstate = pdf_begin_group(ctx, pr, &bbox, &softmask);\n\n\t\tif (dofill && dostroke)\n\t\t{\n\t\t\t/* We may need to push a knockout group */\n\t\t\tif (gstate->stroke.alpha == 0)\n\t\t\t{\n\t\t\t\t/* No need for group, as stroke won't do anything */\n\t\t\t}\n\t\t\telse if (gstate->stroke.alpha == 1.0f && gstate->blendmode == FZ_BLEND_NORMAL)\n\t\t\t{\n\t\t\t\t/* No need for group, as stroke won't show up */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tknockout_group = 1;\n\t\t\t\tfz_begin_group(ctx, pr->dev, &bbox, NULL, 0, 1, FZ_BLEND_NORMAL, 1);\n\t\t\t}\n\t\t}\n\n\t\tif (dofill)\n\t\t{\n\t\t\tswitch (gstate->fill.kind)\n\t\t\t{\n\t\t\tcase PDF_MAT_NONE:\n\t\t\t\tbreak;\n\t\t\tcase PDF_MAT_COLOR:\n\t\t\t\tfz_fill_path(ctx, pr->dev, path, even_odd, &gstate->ctm,\n\t\t\t\t\tgstate->fill.colorspace, gstate->fill.v, gstate->fill.alpha, &gstate->fill.color_params);\n\t\t\t\tbreak;\n\t\t\tcase PDF_MAT_PATTERN:\n\t\t\t\tif (gstate->fill.pattern)\n\t\t\t\t{\n\t\t\t\t\tfz_clip_path(ctx, pr->dev, path, even_odd, &gstate->ctm, &bbox);\n\t\t\t\t\tpdf_show_pattern(ctx, pr, gstate->fill.pattern, &pr->gstate[gstate->fill.gstate_num], &bbox, PDF_FILL);\n\t\t\t\t\tfz_pop_clip(ctx, pr->dev);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PDF_MAT_SHADE:\n\t\t\t\tif (gstate->fill.shade)\n\t\t\t\t{\n\t\t\t\t\tfz_clip_path(ctx, pr->dev, path, even_odd, &gstate->ctm, &bbox);\n\t\t\t\t\t/* The cluster and page 2 of patterns.pdf shows that fz_fill_shade should NOT be called with gstate->ctm. */\n\t\t\t\t\tfz_fill_shade(ctx, pr->dev, gstate->fill.shade, &pr->gstate[gstate->fill.gstate_num].ctm, gstate->fill.alpha, &gstate->fill.color_params);\n\t\t\t\t\tfz_pop_clip(ctx, pr->dev);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (dostroke)\n\t\t{\n\t\t\tswitch (gstate->stroke.kind)\n\t\t\t{\n\t\t\tcase PDF_MAT_NONE:\n\t\t\t\tbreak;\n\t\t\tcase PDF_MAT_COLOR:\n\t\t\t\tfz_stroke_path(ctx, pr->dev, path, gstate->stroke_state, &gstate->ctm,\n\t\t\t\t\tgstate->stroke.colorspace, gstate->stroke.v, gstate->stroke.alpha, &gstate->stroke.color_params);\n\t\t\t\tbreak;\n\t\t\tcase PDF_MAT_PATTERN:\n\t\t\t\tif (gstate->stroke.pattern)\n\t\t\t\t{\n\t\t\t\t\tfz_clip_stroke_path(ctx, pr->dev, path, gstate->stroke_state, &gstate->ctm, &bbox);\n\t\t\t\t\tpdf_show_pattern(ctx, pr, gstate->stroke.pattern, &pr->gstate[gstate->stroke.gstate_num], &bbox, PDF_STROKE);\n\t\t\t\t\tfz_pop_clip(ctx, pr->dev);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PDF_MAT_SHADE:\n\t\t\t\tif (gstate->stroke.shade)\n\t\t\t\t{\n\t\t\t\t\tfz_clip_stroke_path(ctx, pr->dev, path, gstate->stroke_state, &gstate->ctm, &bbox);\n\t\t\t\t\tfz_fill_shade(ctx, pr->dev, gstate->stroke.shade, &pr->gstate[gstate->stroke.gstate_num].ctm, gstate->stroke.alpha, &gstate->stroke.color_params);\n\t\t\t\t\tfz_pop_clip(ctx, pr->dev);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (knockout_group)\n\t\t\tfz_end_group(ctx, pr->dev);\n\n\t\tif (dofill || dostroke)\n\t\t\tpdf_end_group(ctx, pr, &softmask);\n\t}\n", "target": 1, "idx": 177752}
{"func": "psf_close (SF_PRIVATE *psf)\n{\tuint32_t k ;\n\tint\terror = 0 ;\n\n\tif (psf->codec_close)\n\t{\terror = psf->codec_close (psf) ;\n\t\t/* To prevent it being called in psf->container_close(). */\n\t\tpsf->codec_close = NULL ;\n\t\t} ;\n\n\tif (psf->container_close)\n\t\terror = psf->container_close (psf) ;\n\n\terror = psf_fclose (psf) ;\n \tpsf_close_rsrc (psf) ;\n \n \t/* For an ISO C compliant implementation it is ok to free a NULL pointer. */\n \tfree (psf->container_data) ;\n \tfree (psf->codec_data) ;\n \tfree (psf->interleave) ;\n\tfree (psf->dither) ;\n\tfree (psf->peak_info) ;\n\tfree (psf->broadcast_16k) ;\n\tfree (psf->loop_info) ;\n\tfree (psf->instrument) ;\n\tfree (psf->cues) ;\n\tfree (psf->channel_map) ;\n\tfree (psf->format_desc) ;\n\tfree (psf->strings.storage) ;\n\n\tif (psf->wchunks.chunks)\n\t\tfor (k = 0 ; k < psf->wchunks.used ; k++)\n\t\t\tfree (psf->wchunks.chunks [k].data) ;\n\tfree (psf->rchunks.chunks) ;\n\tfree (psf->wchunks.chunks) ;\n\tfree (psf->iterator) ;\n\tfree (psf->cart_16k) ;\n\n\tmemset (psf, 0, sizeof (SF_PRIVATE)) ;\n\tfree (psf) ;\n\n\treturn error ;\n} /* psf_close */\n", "target": 1, "idx": 183238}
{"func": "  _bdf_list_join( _bdf_list_t*    list,\n                  int             c,\n                  unsigned long  *alen )\n  {\n    unsigned long  i, j;\n    char           *fp, *dp;\n\n\n    *alen = 0;\n\n    if ( list == 0 || list->used == 0 )\n      return 0;\n\n    dp = list->field[0];\n    for ( i = j = 0; i < list->used; i++ )\n    {\n      fp = list->field[i];\n      while ( *fp )\n        dp[j++] = *fp++;\n\n      if ( i + 1 < list->used )\n        dp[j++] = (char)c;\n    }\n    if ( dp != empty )\n      dp[j] = 0;\n\n    *alen = j;\n    return dp;\n  }\n", "target": 0, "idx": 6511}
{"func": "  TestResultCallback()\n      : callback_(base::Bind(&TestResultCallback::SetResult,\n                             base::Unretained(this))) {}\n", "target": 1, "idx": 185855}
{"func": "static void set_rx_flow_off(struct caifsock *cf_sk)\n{\n\t clear_bit(RX_FLOW_ON_BIT,\n\t\t (void *) &cf_sk->flow_state);\n}\n", "target": 0, "idx": 30686}
{"func": " void EnableHighDPISupport() {\n   if (IsHighDPIEnabled() &&\n      (base::win::GetVersion() < base::win::VERSION_WIN8_1)) {\n    if (!SetProcessDpiAwarenessWrapper(PROCESS_SYSTEM_DPI_AWARE)) {\n      SetProcessDPIAwareWrapper();\n    }\n   }\n }\n", "target": 1, "idx": 185602}
{"func": "void bnep_net_setup(struct net_device *dev)\n{\n\n\tmemset(dev->broadcast, 0xff, ETH_ALEN);\n \tdev->addr_len = ETH_ALEN;\n \n \tether_setup(dev);\n \tdev->netdev_ops = &bnep_netdev_ops;\n \n \tdev->watchdog_timeo  = HZ * 2;\n}\n", "target": 1, "idx": 178909}
{"func": "static int cannotBeFunction(Parse *pParse, struct SrcList_item *pFrom){\n  if( pFrom->fg.isTabFunc ){\n    sqlite3ErrorMsg(pParse, \"'%s' is not a function\", pFrom->zName);\n    return 1;\n  }\n  return 0;\n}\n", "target": 0, "idx": 149043}
{"func": "IndexedDBTransaction::Operation IndexedDBTransaction::TaskQueue::pop() {\n  DCHECK(!queue_.empty());\n  Operation task = std::move(queue_.front());\n  queue_.pop();\n  return task;\n}\n", "target": 0, "idx": 168665}
{"func": "  void RunScrollbarThumbDragLatencyTest() {\n#if !defined(OS_ANDROID)\n    blink::WebFloatPoint scrollbar_thumb(795, 30);\n    blink::WebMouseEvent mouse_down = SyntheticWebMouseEventBuilder::Build(\n        blink::WebInputEvent::kMouseDown, scrollbar_thumb.x, scrollbar_thumb.y,\n        0);\n    mouse_down.button = blink::WebMouseEvent::Button::kLeft;\n    mouse_down.SetTimeStamp(base::TimeTicks::Now());\n    GetWidgetHost()->ForwardMouseEvent(mouse_down);\n    blink::WebMouseEvent mouse_move = SyntheticWebMouseEventBuilder::Build(\n        blink::WebInputEvent::kMouseMove, scrollbar_thumb.x,\n        scrollbar_thumb.y + 10, 0);\n    mouse_move.button = blink::WebMouseEvent::Button::kLeft;\n    mouse_move.SetTimeStamp(base::TimeTicks::Now());\n    GetWidgetHost()->ForwardMouseEvent(mouse_move);\n    RunUntilInputProcessed(GetWidgetHost());\n    mouse_move.SetPositionInWidget(scrollbar_thumb.x, scrollbar_thumb.y + 20);\n    mouse_move.SetPositionInScreen(scrollbar_thumb.x, scrollbar_thumb.y + 20);\n    GetWidgetHost()->ForwardMouseEvent(mouse_move);\n    RunUntilInputProcessed(GetWidgetHost());\n    blink::WebMouseEvent mouse_up = SyntheticWebMouseEventBuilder::Build(\n        blink::WebInputEvent::kMouseUp, scrollbar_thumb.x,\n        scrollbar_thumb.y + 20, 0);\n    mouse_up.button = blink::WebMouseEvent::Button::kLeft;\n    mouse_up.SetTimeStamp(base::TimeTicks::Now());\n    GetWidgetHost()->ForwardMouseEvent(mouse_up);\n    RunUntilInputProcessed(GetWidgetHost());\n    FetchHistogramsFromChildProcesses();\n    const std::string scroll_types[] = {\"ScrollBegin\", \"ScrollUpdate\"};\n    for (const std::string& scroll_type : scroll_types) {\n      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n          1, \"Event.Latency.\" + scroll_type +\n                 \".Scrollbar.TimeToScrollUpdateSwapBegin4\"));\n      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n          1, \"Event.Latency.\" + scroll_type +\n                 \".Scrollbar.RendererSwapToBrowserNotified2\"));\n      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n          1, \"Event.Latency.\" + scroll_type +\n                 \".Scrollbar.BrowserNotifiedToBeforeGpuSwap2\"));\n      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n          1, \"Event.Latency.\" + scroll_type + \".Scrollbar.GpuSwap2\"));\n      std::string thread_name =\n          DoesScrollbarScrollOnMainThread() ? \"Main\" : \"Impl\";\n      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n          1, \"Event.Latency.\" + scroll_type + \".Scrollbar.TimeToHandled2_\" +\n                 thread_name));\n      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(\n          1, \"Event.Latency.\" + scroll_type +\n                 \".Scrollbar.HandledToRendererSwap2_\" + thread_name));\n    }\n#endif  // !defined(OS_ANDROID)\n  }\n", "target": 1, "idx": 186397}
{"func": "init_ext2_xattr(void)\n {\n\text2_xattr_cache = mb_cache_create(\"ext2_xattr\", 6);\n\tif (!ext2_xattr_cache)\n\t\treturn -ENOMEM;\n\treturn 0;\n }\n", "target": 1, "idx": 183157}
{"func": "SpoolssRFFPCNEX_r(tvbuff_t *tvb, int offset,\n\t\t\t     packet_info *pinfo, proto_tree *tree,\n\t\t\t     dcerpc_info *di, guint8 *drep _U_)\n{\n\t/* Parse packet */\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n", "target": 0, "idx": 51973}
{"func": "virDomainPMWakeup(virDomainPtr dom,\n                  unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(dom, \"flags=%x\", flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    conn = dom->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainPMWakeup) {\n        int ret;\n        ret = conn->driver->domainPMWakeup(dom, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return -1;\n}\n", "target": 0, "idx": 93893}
{"func": "std::unique_ptr<service_manager::Service> CreateDataDecoderService() {\n  content::UtilityThread::Get()->EnsureBlinkInitialized();\n  return data_decoder::DataDecoderService::Create();\n}\n", "target": 0, "idx": 138390}
{"func": "\t\tvoid CWebServer::Cmd_AddSceneCode(WebEmSession & session, const request& req, Json::Value &root)\n\t\t{\n\t\t\tif (session.rights != 2)\n\t\t\t{\n\t\t\t\tsession.reply_status = reply::forbidden;\n\t\t\t\treturn; //Only admin user allowed\n\t\t\t}\n\n\t\t\tstd::string sceneidx = request::findValue(&req, \"sceneidx\");\n\t\t\tstd::string idx = request::findValue(&req, \"idx\");\n\t\t\tstd::string cmnd = request::findValue(&req, \"cmnd\");\n\t\t\tif (\n\t\t\t\t(sceneidx.empty()) ||\n\t\t\t\t(idx.empty()) ||\n\t\t\t\t(cmnd.empty())\n\t\t\t\t)\n\t\t\t\treturn;\n\t\t\troot[\"status\"] = \"OK\";\n\t\t\troot[\"title\"] = \"AddSceneCode\";\n\n\t\t\tstd::vector<std::vector<std::string> > result;\n\t\t\tresult = m_sql.safe_query(\"SELECT Activators, SceneType FROM Scenes WHERE (ID==%q)\", sceneidx.c_str());\n\t\t\tif (result.empty())\n\t\t\t\treturn;\n\t\t\tstd::string Activators = result[0][0];\n\t\t\tunsigned char scenetype = atoi(result[0][1].c_str());\n\n\t\t\tif (!Activators.empty())\n\t\t\t{\n\t\t\t\tstd::vector<std::string> arrayActivators;\n\t\t\t\tStringSplit(Activators, \";\", arrayActivators);\n\t\t\t\tfor (const auto & ittAct : arrayActivators)\n\t\t\t\t{\n\t\t\t\t\tstd::string sCodeCmd = ittAct;\n\n\t\t\t\t\tstd::vector<std::string> arrayCode;\n\t\t\t\t\tStringSplit(sCodeCmd, \":\", arrayCode);\n\n\t\t\t\t\tstd::string sID = arrayCode[0];\n\t\t\t\t\tstd::string sCode = \"\";\n\t\t\t\t\tif (arrayCode.size() == 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tsCode = arrayCode[1];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (sID == idx)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (scenetype == 1)\n\t\t\t\t\t\t\treturn; //Group does not work with separate codes, so already there\n\t\t\t\t\t\tif (sCode == cmnd)\n\t\t\t\t\t\t\treturn; //same code, already there!\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!Activators.empty())\n\t\t\t\tActivators += \";\";\n\t\t\tActivators += idx;\n\t\t\tif (scenetype == 0)\n\t\t\t{\n\t\t\t\tActivators += \":\" + cmnd;\n\t\t\t}\n\t\t\tm_sql.safe_query(\"UPDATE Scenes SET Activators='%q' WHERE (ID==%q)\", Activators.c_str(), sceneidx.c_str());\n\t\t}\n", "target": 0, "idx": 90967}
{"func": "static void tcp_v4_reqsk_destructor(struct request_sock *req)\n{\n\tkfree(inet_rsk(req)->opt);\n}\n", "target": 0, "idx": 19040}
{"func": "reread_byte(struct file *file)\n /* Read a byte when an error is not expected to happen because the byte has\n    * been read before without error.\n    */\n{\n int ch = getc(file->file);\n\n if (errno != 0)\n      file->read_errno = errno;\n\n if (ch < 0 || ch > 255)\n      stop(file, UNEXPECTED_ERROR_CODE, \"reread\");\n\n return (png_byte)ch;\n}\n", "target": 0, "idx": 173315}
{"func": "static int cine_read_probe(AVProbeData *p)\n{\n    int HeaderSize;\n    if (p->buf[0] == 'C' && p->buf[1] == 'I' &&  // Type\n        (HeaderSize = AV_RL16(p->buf + 2)) >= 0x2C &&  // HeaderSize\n        AV_RL16(p->buf + 4) <= CC_UNINT &&       // Compression\n        AV_RL16(p->buf + 6) <= 1 &&              // Version\n        AV_RL32(p->buf + 20) &&                  // ImageCount\n        AV_RL32(p->buf + 24) >= HeaderSize &&    // OffImageHeader\n        AV_RL32(p->buf + 28) >= HeaderSize &&    // OffSetup\n        AV_RL32(p->buf + 32) >= HeaderSize)      // OffImageOffsets\n        return AVPROBE_SCORE_MAX;\n    return 0;\n}\n", "target": 0, "idx": 61774}
{"func": "static int futex_wait_requeue_pi(u32 __user *uaddr, int fshared,\n\t\t\t\t u32 val, ktime_t *abs_time, u32 bitset,\n\t\t\t\t int clockrt, u32 __user *uaddr2)\n{\n\tstruct hrtimer_sleeper timeout, *to = NULL;\n\tstruct rt_mutex_waiter rt_waiter;\n\tstruct rt_mutex *pi_mutex = NULL;\n\tstruct futex_hash_bucket *hb;\n\tunion futex_key key2;\n\tstruct futex_q q;\n\tint res, ret;\n\n\tif (!bitset)\n\t\treturn -EINVAL;\n\n\tif (abs_time) {\n\t\tto = &timeout;\n\t\thrtimer_init_on_stack(&to->timer, clockrt ? CLOCK_REALTIME :\n\t\t\t\t      CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\t\thrtimer_init_sleeper(to, current);\n\t\thrtimer_set_expires_range_ns(&to->timer, *abs_time,\n\t\t\t\t\t     current->timer_slack_ns);\n\t}\n\n\t/*\n\t * The waiter is allocated on our stack, manipulated by the requeue\n\t * code while we sleep on uaddr.\n\t */\n\tdebug_rt_mutex_init_waiter(&rt_waiter);\n\trt_waiter.task = NULL;\n\n\tkey2 = FUTEX_KEY_INIT;\n\tret = get_futex_key(uaddr2, fshared, &key2);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\n\tq.pi_state = NULL;\n\tq.bitset = bitset;\n \tq.rt_waiter = &rt_waiter;\n \tq.requeue_pi_key = &key2;\n \n\t/* Prepare to wait on uaddr. */\n \tret = futex_wait_setup(uaddr, val, fshared, &q, &hb);\n \tif (ret)\n \t\tgoto out_key2;\n\n\t/* Queue the futex_q, drop the hb lock, wait for wakeup. */\n\tfutex_wait_queue_me(hb, &q, to);\n\n\tspin_lock(&hb->lock);\n\tret = handle_early_requeue_pi_wakeup(hb, &q, &key2, to);\n\tspin_unlock(&hb->lock);\n\tif (ret)\n\t\tgoto out_put_keys;\n\n\t/*\n \t * In order for us to be here, we know our q.key == key2, and since\n \t * we took the hb->lock above, we also know that futex_requeue() has\n \t * completed and we no longer have to concern ourselves with a wakeup\n\t * race with the atomic proxy lock acquition by the requeue code.\n \t */\n \n \t/* Check if the requeue code acquired the second futex for us. */\n\tif (!q.rt_waiter) {\n\t\t/*\n\t\t * Got the lock. We might not be the anticipated owner if we\n\t\t * did a lock-steal - fix up the PI-state in that case.\n\t\t */\n\t\tif (q.pi_state && (q.pi_state->owner != current)) {\n\t\t\tspin_lock(q.lock_ptr);\n\t\t\tret = fixup_pi_state_owner(uaddr2, &q, current,\n\t\t\t\t\t\t   fshared);\n\t\t\tspin_unlock(q.lock_ptr);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * We have been woken up by futex_unlock_pi(), a timeout, or a\n\t\t * signal.  futex_unlock_pi() will not destroy the lock_ptr nor\n\t\t * the pi_state.\n\t\t */\n\t\tWARN_ON(!&q.pi_state);\n\t\tpi_mutex = &q.pi_state->pi_mutex;\n\t\tret = rt_mutex_finish_proxy_lock(pi_mutex, to, &rt_waiter, 1);\n\t\tdebug_rt_mutex_free_waiter(&rt_waiter);\n\n\t\tspin_lock(q.lock_ptr);\n\t\t/*\n\t\t * Fixup the pi_state owner and possibly acquire the lock if we\n\t\t * haven't already.\n\t\t */\n\t\tres = fixup_owner(uaddr2, fshared, &q, !ret);\n\t\t/*\n\t\t * If fixup_owner() returned an error, proprogate that.  If it\n\t\t * acquired the lock, clear -ETIMEDOUT or -EINTR.\n\t\t */\n\t\tif (res)\n\t\t\tret = (res < 0) ? res : 0;\n\n\t\t/* Unqueue and drop the lock. */\n\t\tunqueue_me_pi(&q);\n\t}\n\n\t/*\n\t * If fixup_pi_state_owner() faulted and was unable to handle the\n\t * fault, unlock the rt_mutex and return the fault to userspace.\n\t */\n\tif (ret == -EFAULT) {\n\t\tif (rt_mutex_owner(pi_mutex) == current)\n\t\t\trt_mutex_unlock(pi_mutex);\n\t} else if (ret == -EINTR) {\n\t\t/*\n\t\t * We've already been requeued, but cannot restart by calling\n\t\t * futex_lock_pi() directly. We could restart this syscall, but\n\t\t * it would detect that the user space \"val\" changed and return\n\t\t * -EWOULDBLOCK.  Save the overhead of the restart and return\n\t\t * -EWOULDBLOCK directly.\n\t\t */\n\t\tret = -EWOULDBLOCK;\n\t}\n\nout_put_keys:\n\tput_futex_key(fshared, &q.key);\nout_key2:\n\tput_futex_key(fshared, &key2);\n\nout:\n\tif (to) {\n\t\thrtimer_cancel(&to->timer);\n\t\tdestroy_hrtimer_on_stack(&to->timer);\n\t}\n\treturn ret;\n}\n", "target": 1, "idx": 179622}
{"func": " void UserSelectionScreen::OnBeforeUserRemoved(const AccountId& account_id) {\n  for (user_manager::UserList::iterator it = users_.begin(); it != users_.end();\n       ++it) {\n     if ((*it)->GetAccountId() == account_id) {\n       users_.erase(it);\n       break;\n    }\n  }\n}\n", "target": 1, "idx": 186170}
{"func": "service_is_single_onion_poisoned(const rend_service_t *service)\n{\n  char *poison_fname = NULL;\n  file_status_t fstatus;\n\n  /* Passing a NULL service is a bug */\n  if (BUG(!service)) {\n    return 0;\n  }\n\n  if (rend_service_is_ephemeral(service)) {\n    return 0;\n  }\n\n  poison_fname = rend_service_sos_poison_path(service);\n\n  fstatus = file_status(poison_fname);\n  tor_free(poison_fname);\n\n  /* If this fname is occupied, the hidden service has been poisoned.\n   * fstatus can be FN_ERROR if the service directory does not exist, in that\n   * case, there is obviously no private key. */\n  if (fstatus == FN_FILE || fstatus == FN_EMPTY) {\n    return 1;\n  }\n\n  return 0;\n}\n", "target": 0, "idx": 69650}
{"func": "void SafeBrowsingBlockingPageV2::PopulateStringDictionary(\n    DictionaryValue* strings,\n    const string16& title,\n    const string16& headline,\n    const string16& description1,\n    const string16& description2,\n    const string16& description3) {\n  strings->SetString(\"title\", title);\n  strings->SetString(\"headLine\", headline);\n  strings->SetString(\"description1\", description1);\n  strings->SetString(\"description2\", description2);\n  strings->SetString(\"description3\", description3);\n  strings->SetBoolean(\"proceedDisabled\",\n                      IsPrefEnabled(prefs::kSafeBrowsingProceedAnywayDisabled));\n  strings->SetBoolean(\"isMainFrame\", is_main_frame_load_blocked_);\n  strings->SetBoolean(\"isPhishing\", interstitial_type_ == TYPE_PHISHING);\n\n  strings->SetString(\"back_button\",\n      l10n_util::GetStringUTF16(IDS_SAFE_BROWSING_MALWARE_BACK_BUTTON));\n  strings->SetString(\"seeMore\", l10n_util::GetStringUTF16(\n      IDS_SAFE_BROWSING_MALWARE_V2_SEE_MORE));\n  strings->SetString(\"proceed\",\n      l10n_util::GetStringUTF16(IDS_SAFE_BROWSING_MALWARE_V2_PROCEED_LINK));\n\n  URLDataSource::SetFontAndTextDirection(strings);\n}\n", "target": 0, "idx": 123495}
{"func": "  virtual void AddObserver(Observer* observer) {\n     if (!observers_.size()) {\n       observer->FirstObserverIsAdded(this);\n     }\n     observers_.AddObserver(observer);\n   }\n", "target": 1, "idx": 183933}
{"func": "static int check_func_call(struct bpf_verifier_env *env, struct bpf_insn *insn,\n\t\t\t   int *insn_idx)\n{\n\tstruct bpf_verifier_state *state = env->cur_state;\n\tstruct bpf_func_state *caller, *callee;\n\tint i, subprog, target_insn;\n\n\tif (state->curframe + 1 >= MAX_CALL_FRAMES) {\n\t\tverbose(env, \"the call stack of %d frames is too deep\\n\",\n\t\t\tstate->curframe + 2);\n\t\treturn -E2BIG;\n\t}\n\n\ttarget_insn = *insn_idx + insn->imm;\n\tsubprog = find_subprog(env, target_insn + 1);\n\tif (subprog < 0) {\n\t\tverbose(env, \"verifier bug. No program starts at insn %d\\n\",\n\t\t\ttarget_insn + 1);\n\t\treturn -EFAULT;\n\t}\n\n\tcaller = state->frame[state->curframe];\n\tif (state->frame[state->curframe + 1]) {\n\t\tverbose(env, \"verifier bug. Frame %d already allocated\\n\",\n\t\t\tstate->curframe + 1);\n\t\treturn -EFAULT;\n\t}\n\n\tcallee = kzalloc(sizeof(*callee), GFP_KERNEL);\n\tif (!callee)\n\t\treturn -ENOMEM;\n\tstate->frame[state->curframe + 1] = callee;\n\n\t/* callee cannot access r0, r6 - r9 for reading and has to write\n\t * into its own stack before reading from it.\n\t * callee can read/write into caller's stack\n\t */\n\tinit_func_state(env, callee,\n\t\t\t/* remember the callsite, it will be used by bpf_exit */\n\t\t\t*insn_idx /* callsite */,\n\t\t\tstate->curframe + 1 /* frameno within this callchain */,\n\t\t\tsubprog /* subprog number within this prog */);\n\n\t/* copy r1 - r5 args that callee can access */\n\tfor (i = BPF_REG_1; i <= BPF_REG_5; i++)\n\t\tcallee->regs[i] = caller->regs[i];\n\n\t/* after the call regsiters r0 - r5 were scratched */\n\tfor (i = 0; i < CALLER_SAVED_REGS; i++) {\n\t\tmark_reg_not_init(env, caller->regs, caller_saved[i]);\n\t\tcheck_reg_arg(env, caller_saved[i], DST_OP_NO_MARK);\n\t}\n\n\t/* only increment it after check_reg_arg() finished */\n\tstate->curframe++;\n\n\t/* and go analyze first insn of the callee */\n\t*insn_idx = target_insn;\n\n\tif (env->log.level) {\n\t\tverbose(env, \"caller:\\n\");\n\t\tprint_verifier_state(env, caller);\n\t\tverbose(env, \"callee:\\n\");\n\t\tprint_verifier_state(env, callee);\n\t}\n\treturn 0;\n}\n", "target": 0, "idx": 76371}
{"func": "DecodeNumberField(int len, char *str, int fmask,\n\t\t\t\t  int *tmask, struct tm * tm, fsec_t *fsec, int *is2digits)\n{\n\tchar\t   *cp;\n\n\t/*\n\t * Have a decimal point? Then this is a date or something with a seconds\n\t * field...\n\t */\n \tif ((cp = strchr(str, '.')) != NULL)\n \t{\n #ifdef HAVE_INT64_TIMESTAMP\n\t\tchar\t\tfstr[MAXDATELEN + 1];\n \n \t\t/*\n \t\t * OK, we have at most six digits to care about. Let's construct a\n\t\t * string and then do the conversion to an integer.\n \t\t */\n\t\tstrcpy(fstr, (cp + 1));\n\t\tstrcpy(fstr + strlen(fstr), \"000000\");\n\t\t*(fstr + 6) = '\\0';\n \t\t*fsec = strtol(fstr, NULL, 10);\n #else\n \t\t*fsec = strtod(cp, NULL);\n#endif\n\t\t*cp = '\\0';\n\t\tlen = strlen(str);\n\t}\n\t/* No decimal point and no complete date yet? */\n\telse if ((fmask & DTK_DATE_M) != DTK_DATE_M)\n\t{\n\t\t/* yyyymmdd? */\n\t\tif (len == 8)\n\t\t{\n\t\t\t*tmask = DTK_DATE_M;\n\n\t\t\ttm->tm_mday = atoi(str + 6);\n\t\t\t*(str + 6) = '\\0';\n\t\t\ttm->tm_mon = atoi(str + 4);\n\t\t\t*(str + 4) = '\\0';\n\t\t\ttm->tm_year = atoi(str + 0);\n\n\t\t\treturn DTK_DATE;\n\t\t}\n\t\t/* yymmdd? */\n\t\telse if (len == 6)\n\t\t{\n\t\t\t*tmask = DTK_DATE_M;\n\t\t\ttm->tm_mday = atoi(str + 4);\n\t\t\t*(str + 4) = '\\0';\n\t\t\ttm->tm_mon = atoi(str + 2);\n\t\t\t*(str + 2) = '\\0';\n\t\t\ttm->tm_year = atoi(str + 0);\n\t\t\t*is2digits = TRUE;\n\n\t\t\treturn DTK_DATE;\n\t\t}\n\t\t/* yyddd? */\n\t\telse if (len == 5)\n\t\t{\n\t\t\t*tmask = DTK_DATE_M;\n\t\t\ttm->tm_mday = atoi(str + 2);\n\t\t\t*(str + 2) = '\\0';\n\t\t\ttm->tm_mon = 1;\n\t\t\ttm->tm_year = atoi(str + 0);\n\t\t\t*is2digits = TRUE;\n\n\t\t\treturn DTK_DATE;\n\t\t}\n\t}\n\n\t/* not all time fields are specified? */\n\tif ((fmask & DTK_TIME_M) != DTK_TIME_M)\n\t{\n\t\t/* hhmmss */\n\t\tif (len == 6)\n\t\t{\n\t\t\t*tmask = DTK_TIME_M;\n\t\t\ttm->tm_sec = atoi(str + 4);\n\t\t\t*(str + 4) = '\\0';\n\t\t\ttm->tm_min = atoi(str + 2);\n\t\t\t*(str + 2) = '\\0';\n\t\t\ttm->tm_hour = atoi(str + 0);\n\n\t\t\treturn DTK_TIME;\n\t\t}\n\t\t/* hhmm? */\n\t\telse if (len == 4)\n\t\t{\n\t\t\t*tmask = DTK_TIME_M;\n\t\t\ttm->tm_sec = 0;\n\t\t\ttm->tm_min = atoi(str + 2);\n\t\t\t*(str + 2) = '\\0';\n\t\t\ttm->tm_hour = atoi(str + 0);\n\n\t\t\treturn DTK_TIME;\n\t\t}\n\t}\n\n\treturn -1;\n}\t/* DecodeNumberField() */\n", "target": 1, "idx": 179636}
{"func": "static uint64_t ahci_mem_read_32(void *opaque, hwaddr addr)\n{\n    AHCIState *s = opaque;\n    uint32_t val = 0;\n\n    if (addr < AHCI_GENERIC_HOST_CONTROL_REGS_MAX_ADDR) {\n        switch (addr) {\n        case HOST_CAP:\n            val = s->control_regs.cap;\n            break;\n        case HOST_CTL:\n            val = s->control_regs.ghc;\n            break;\n        case HOST_IRQ_STAT:\n            val = s->control_regs.irqstatus;\n            break;\n        case HOST_PORTS_IMPL:\n            val = s->control_regs.impl;\n            break;\n        case HOST_VERSION:\n            val = s->control_regs.version;\n            break;\n        }\n\n        DPRINTF(-1, \"(addr 0x%08X), val 0x%08X\\n\", (unsigned) addr, val);\n    } else if ((addr >= AHCI_PORT_REGS_START_ADDR) &&\n               (addr < (AHCI_PORT_REGS_START_ADDR +\n                (s->ports * AHCI_PORT_ADDR_OFFSET_LEN)))) {\n        val = ahci_port_read(s, (addr - AHCI_PORT_REGS_START_ADDR) >> 7,\n                             addr & AHCI_PORT_ADDR_OFFSET_MASK);\n    }\n\n    return val;\n}\n", "target": 0, "idx": 5870}
{"func": "PHP_FUNCTION(time_nanosleep)\n{\n\tlong tv_sec, tv_nsec;\n\tstruct timespec php_req, php_rem;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ll\", &tv_sec, &tv_nsec) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (tv_sec < 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"The seconds value must be greater than 0\");\n\t\tRETURN_FALSE;\n\t}\n\tif (tv_nsec < 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"The nanoseconds value must be greater than 0\");\n\t\tRETURN_FALSE;\n\t}\n\n\tphp_req.tv_sec = (time_t) tv_sec;\n\tphp_req.tv_nsec = tv_nsec;\n\tif (!nanosleep(&php_req, &php_rem)) {\n\t\tRETURN_TRUE;\n\t} else if (errno == EINTR) {\n\t\tarray_init(return_value);\n\t\tadd_assoc_long_ex(return_value, \"seconds\", sizeof(\"seconds\"), php_rem.tv_sec);\n\t\tadd_assoc_long_ex(return_value, \"nanoseconds\", sizeof(\"nanoseconds\"), php_rem.tv_nsec);\n\t\treturn;\n\t} else if (errno == EINVAL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"nanoseconds was not in the range 0 to 999 999 999 or seconds was negative\");\n\t}\n\n\tRETURN_FALSE;\n}\n", "target": 0, "idx": 4260}
{"func": "MagickExport void *DetachBlob(BlobInfo *blob_info)\n{\n  void\n    *data;\n\n  assert(blob_info != (BlobInfo *) NULL);\n  if (blob_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n   if (blob_info->mapped != MagickFalse)\n     {\n       (void) UnmapBlob(blob_info->data,blob_info->length);\n       RelinquishMagickResource(MapResource,blob_info->length);\n     }\n   blob_info->mapped=MagickFalse;\n  blob_info->length=0;\n  blob_info->offset=0;\n  blob_info->eof=MagickFalse;\n  blob_info->error=0;\n  blob_info->exempt=MagickFalse;\n  blob_info->type=UndefinedStream;\n  blob_info->file_info.file=(FILE *) NULL;\n  data=blob_info->data;\n  blob_info->data=(unsigned char *) NULL;\n  blob_info->stream=(StreamHandler) NULL;\n  blob_info->custom_stream=(CustomStreamInfo *) NULL;\n  return(data);\n}\n", "target": 1, "idx": 183362}
{"func": "aura::Window* PartialMagnificationController::GetCurrentRootWindow() {\n  aura::Window::Windows root_windows = Shell::GetAllRootWindows();\n  for (aura::Window::Windows::const_iterator iter = root_windows.begin();\n       iter != root_windows.end(); ++iter) {\n    aura::Window* root_window = *iter;\n    if (root_window->ContainsPointInRoot(\n            root_window->GetHost()->dispatcher()->GetLastMouseLocationInRoot()))\n      return root_window;\n  }\n  return NULL;\n}\n", "target": 1, "idx": 185512}
{"func": "void ShelfLayoutManager::ProcessGestureEventOfAutoHideShelf(\n    ui::GestureEvent* event,\n    aura::Window* target) {\n  const bool is_shelf_window = IsShelfWindow(target);\n  if (IsVisible() || in_shutdown_) {\n    if (!is_shelf_window && !IsStatusAreaWindow(target) &&\n        visibility_state() == SHELF_AUTO_HIDE &&\n        state_.auto_hide_state == SHELF_AUTO_HIDE_SHOWN &&\n        event->type() == ui::ET_GESTURE_TAP) {\n      UpdateAutoHideState();\n    }\n    return;\n  }\n\n  if (is_shelf_window) {\n    ui::GestureEvent event_in_screen(*event);\n    gfx::Point location_in_screen(event->location());\n    ::wm::ConvertPointToScreen(target, &location_in_screen);\n    event_in_screen.set_location(location_in_screen);\n    if (ProcessGestureEvent(event_in_screen))\n      event->StopPropagation();\n  }\n}\n", "target": 0, "idx": 142476}
{"func": "void TabStripModel::SelectNextTab() {\n  SelectRelativeTab(true);\n}\n", "target": 0, "idx": 102998}
{"func": "struct sk_buff **udp_gro_receive(struct sk_buff **head, struct sk_buff *skb,\n\t\t\t\t struct udphdr *uh)\n{\n\tstruct udp_offload_priv *uo_priv;\n\tstruct sk_buff *p, **pp = NULL;\n\tstruct udphdr *uh2;\n \tunsigned int off = skb_gro_offset(skb);\n \tint flush = 1;\n \n\tif (NAPI_GRO_CB(skb)->udp_mark ||\n \t    (skb->ip_summed != CHECKSUM_PARTIAL &&\n \t     NAPI_GRO_CB(skb)->csum_cnt == 0 &&\n \t     !NAPI_GRO_CB(skb)->csum_valid))\n \t\tgoto out;\n \n\t/* mark that this skb passed once through the udp gro layer */\n\tNAPI_GRO_CB(skb)->udp_mark = 1;\n \n \trcu_read_lock();\n \tuo_priv = rcu_dereference(udp_offload_base);\n\tfor (; uo_priv != NULL; uo_priv = rcu_dereference(uo_priv->next)) {\n\t\tif (net_eq(read_pnet(&uo_priv->net), dev_net(skb->dev)) &&\n\t\t    uo_priv->offload->port == uh->dest &&\n\t\t    uo_priv->offload->callbacks.gro_receive)\n\t\t\tgoto unflush;\n\t}\n\tgoto out_unlock;\n\nunflush:\n\tflush = 0;\n\n\tfor (p = *head; p; p = p->next) {\n\t\tif (!NAPI_GRO_CB(p)->same_flow)\n\t\t\tcontinue;\n\n\t\tuh2 = (struct udphdr   *)(p->data + off);\n\n\t\t/* Match ports and either checksums are either both zero\n\t\t * or nonzero.\n\t\t */\n\t\tif ((*(u32 *)&uh->source != *(u32 *)&uh2->source) ||\n\t\t    (!uh->check ^ !uh2->check)) {\n\t\t\tNAPI_GRO_CB(p)->same_flow = 0;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tskb_gro_pull(skb, sizeof(struct udphdr)); /* pull encapsulating udp header */\n\tskb_gro_postpull_rcsum(skb, uh, sizeof(struct udphdr));\n\tNAPI_GRO_CB(skb)->proto = uo_priv->offload->ipproto;\n\tpp = uo_priv->offload->callbacks.gro_receive(head, skb,\n\t\t\t\t\t\t     uo_priv->offload);\n\nout_unlock:\n\trcu_read_unlock();\nout:\n\tNAPI_GRO_CB(skb)->flush |= flush;\n\treturn pp;\n}\n", "target": 1, "idx": 180079}
{"func": "static ssize_t driver_override_show(struct device *dev,\n \t\t\t\t    struct device_attribute *attr, char *buf)\n {\n \tstruct platform_device *pdev = to_platform_device(dev);\n \n\treturn sprintf(buf, \"%s\\n\", pdev->driver_override);\n }\n", "target": 1, "idx": 181163}
{"func": "entry_guard_obeys_restriction(const entry_guard_t *guard,\n                              const entry_guard_restriction_t *rst)\n{\n  tor_assert(guard);\n   if (! rst)\n     return 1; // No restriction?  No problem.\n \n   return tor_memneq(guard->identity, rst->exclude_id, DIGEST_LEN);\n }\n", "target": 1, "idx": 181622}
{"func": "error::Error GLES2DecoderPassthroughImpl::DoScheduleCALayerCHROMIUM(\n    GLuint contents_texture_id,\n    const GLfloat* contents_rect,\n    GLuint background_color,\n    GLuint edge_aa_mask,\n    const GLfloat* bounds_rect) {\n  NOTIMPLEMENTED();\n  return error::kNoError;\n}\n", "target": 0, "idx": 154786}
{"func": "WebContentsImpl* WebContentsImpl::FromFrameTreeNode(\n    FrameTreeNode* frame_tree_node) {\n  return static_cast<WebContentsImpl*>(\n      WebContents::FromRenderFrameHost(frame_tree_node->current_frame_host()));\n}\n", "target": 0, "idx": 144506}
{"func": " void DataReductionProxySettings::InitDataReductionProxySettings(\n     PrefService* prefs,\n    DataReductionProxyIOData* io_data,\n    std::unique_ptr<DataReductionProxyService> data_reduction_proxy_service) {\n  DCHECK(thread_checker_.CalledOnValidThread());\n  DCHECK(prefs);\n  DCHECK(io_data);\n  DCHECK(io_data->config());\n  DCHECK(data_reduction_proxy_service);\n  prefs_ = prefs;\n   config_ = io_data->config();\n   data_reduction_proxy_service_ = std::move(data_reduction_proxy_service);\n   data_reduction_proxy_service_->AddObserver(this);\n  InitPrefMembers();\n   RecordDataReductionInit();\n \n #if defined(OS_ANDROID)\n  if (spdy_proxy_auth_enabled_.GetValue()) {\n     data_reduction_proxy_service_->compression_stats()\n         ->SetDataUsageReportingEnabled(true);\n   }\n#endif  // defined(OS_ANDROID)\n\n  for (auto& observer : observers_)\n    observer.OnSettingsInitialized();\n}\n", "target": 1, "idx": 186521}
{"func": "SYSCALL_DEFINE3(sendmsg, int, fd, struct msghdr __user *, msg, unsigned int, flags)\n{\n\tif (flags & MSG_CMSG_COMPAT)\n\t\treturn -EINVAL;\n\treturn __sys_sendmsg(fd, msg, flags);\n}\n", "target": 0, "idx": 40677}
{"func": "tgs_make_reply(krb5_context context,\n\t       krb5_kdc_configuration *config,\n\t       KDC_REQ_BODY *b,\n\t       krb5_const_principal tgt_name,\n\t       const EncTicketPart *tgt,\n\t       const krb5_keyblock *replykey,\n\t       int rk_is_subkey,\n\t       const EncryptionKey *serverkey,\n\t       const krb5_keyblock *sessionkey,\n\t       krb5_kvno kvno,\n\t       AuthorizationData *auth_data,\n\t       hdb_entry_ex *server,\n\t       krb5_principal server_principal,\n \t       const char *server_name,\n \t       hdb_entry_ex *client,\n \t       krb5_principal client_principal,\n \t       hdb_entry_ex *krbtgt,\n \t       krb5_enctype krbtgt_etype,\n \t       krb5_principals spp,\n\t       const krb5_data *rspac,\n\t       const METHOD_DATA *enc_pa_data,\n\t       const char **e_text,\n\t       krb5_data *reply)\n{\n    KDC_REP rep;\n    EncKDCRepPart ek;\n    EncTicketPart et;\n    KDCOptions f = b->kdc_options;\n    krb5_error_code ret;\n    int is_weak = 0;\n\n    memset(&rep, 0, sizeof(rep));\n    memset(&et, 0, sizeof(et));\n    memset(&ek, 0, sizeof(ek));\n\n    rep.pvno = 5;\n    rep.msg_type = krb_tgs_rep;\n\n    et.authtime = tgt->authtime;\n    _kdc_fix_time(&b->till);\n    et.endtime = min(tgt->endtime, *b->till);\n    ALLOC(et.starttime);\n    *et.starttime = kdc_time;\n\n    ret = check_tgs_flags(context, config, b, tgt, &et);\n    if(ret)\n\tgoto out;\n\n    /* We should check the transited encoding if:\n       1) the request doesn't ask not to be checked\n       2) globally enforcing a check\n       3) principal requires checking\n       4) we allow non-check per-principal, but principal isn't marked as allowing this\n       5) we don't globally allow this\n    */\n\n#define GLOBAL_FORCE_TRANSITED_CHECK\t\t\\\n    (config->trpolicy == TRPOLICY_ALWAYS_CHECK)\n#define GLOBAL_ALLOW_PER_PRINCIPAL\t\t\t\\\n    (config->trpolicy == TRPOLICY_ALLOW_PER_PRINCIPAL)\n#define GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK\t\t\t\\\n    (config->trpolicy == TRPOLICY_ALWAYS_HONOUR_REQUEST)\n\n/* these will consult the database in future release */\n#define PRINCIPAL_FORCE_TRANSITED_CHECK(P)\t\t0\n#define PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK(P)\t0\n\n    ret = fix_transited_encoding(context, config,\n\t\t\t\t !f.disable_transited_check ||\n\t\t\t\t GLOBAL_FORCE_TRANSITED_CHECK ||\n\t\t\t\t PRINCIPAL_FORCE_TRANSITED_CHECK(server) ||\n\t\t\t\t !((GLOBAL_ALLOW_PER_PRINCIPAL &&\n\t\t\t\t    PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK(server)) ||\n\t\t\t\t   GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK),\n \t\t\t\t &tgt->transited, &et,\n \t\t\t\t krb5_principal_get_realm(context, client_principal),\n \t\t\t\t krb5_principal_get_realm(context, server->entry.principal),\n\t\t\t\t krb5_principal_get_realm(context, krbtgt->entry.principal));\n     if(ret)\n \tgoto out;\n \n    copy_Realm(&server_principal->realm, &rep.ticket.realm);\n    _krb5_principal2principalname(&rep.ticket.sname, server_principal);\n    copy_Realm(&tgt_name->realm, &rep.crealm);\n/*\n    if (f.request_anonymous)\n\t_kdc_make_anonymous_principalname (&rep.cname);\n    else */\n\n    copy_PrincipalName(&tgt_name->name, &rep.cname);\n    rep.ticket.tkt_vno = 5;\n\n    ek.caddr = et.caddr;\n\n    {\n\ttime_t life;\n\tlife = et.endtime - *et.starttime;\n\tif(client && client->entry.max_life)\n\t    life = min(life, *client->entry.max_life);\n\tif(server->entry.max_life)\n\t    life = min(life, *server->entry.max_life);\n\tet.endtime = *et.starttime + life;\n    }\n    if(f.renewable_ok && tgt->flags.renewable &&\n       et.renew_till == NULL && et.endtime < *b->till &&\n       tgt->renew_till != NULL)\n    {\n\tet.flags.renewable = 1;\n\tALLOC(et.renew_till);\n\t*et.renew_till = *b->till;\n    }\n    if(et.renew_till){\n\ttime_t renew;\n\trenew = *et.renew_till - *et.starttime;\n\tif(client && client->entry.max_renew)\n\t    renew = min(renew, *client->entry.max_renew);\n\tif(server->entry.max_renew)\n\t    renew = min(renew, *server->entry.max_renew);\n\t*et.renew_till = *et.starttime + renew;\n    }\n\n    if(et.renew_till){\n\t*et.renew_till = min(*et.renew_till, *tgt->renew_till);\n\t*et.starttime = min(*et.starttime, *et.renew_till);\n\tet.endtime = min(et.endtime, *et.renew_till);\n    }\n\n    *et.starttime = min(*et.starttime, et.endtime);\n\n    if(*et.starttime == et.endtime){\n\tret = KRB5KDC_ERR_NEVER_VALID;\n\tgoto out;\n    }\n    if(et.renew_till && et.endtime == *et.renew_till){\n\tfree(et.renew_till);\n\tet.renew_till = NULL;\n\tet.flags.renewable = 0;\n    }\n\n    et.flags.pre_authent = tgt->flags.pre_authent;\n    et.flags.hw_authent  = tgt->flags.hw_authent;\n    et.flags.anonymous   = tgt->flags.anonymous;\n    et.flags.ok_as_delegate = server->entry.flags.ok_as_delegate;\n\n    if(rspac->length) {\n\t/*\n\t * No not need to filter out the any PAC from the\n\t * auth_data since it's signed by the KDC.\n\t */\n\tret = _kdc_tkt_add_if_relevant_ad(context, &et,\n\t\t\t\t\t  KRB5_AUTHDATA_WIN2K_PAC, rspac);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (auth_data) {\n\tunsigned int i = 0;\n\n\t/* XXX check authdata */\n\n\tif (et.authorization_data == NULL) {\n\t    et.authorization_data = calloc(1, sizeof(*et.authorization_data));\n\t    if (et.authorization_data == NULL) {\n\t\tret = ENOMEM;\n\t\tkrb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t\tgoto out;\n\t    }\n\t}\n\tfor(i = 0; i < auth_data->len ; i++) {\n\t    ret = add_AuthorizationData(et.authorization_data, &auth_data->val[i]);\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t\tgoto out;\n\t    }\n\t}\n\n\t/* Filter out type KRB5SignedPath */\n\tret = find_KRB5SignedPath(context, et.authorization_data, NULL);\n\tif (ret == 0) {\n\t    if (et.authorization_data->len == 1) {\n\t\tfree_AuthorizationData(et.authorization_data);\n\t\tfree(et.authorization_data);\n\t\tet.authorization_data = NULL;\n\t    } else {\n\t\tAuthorizationData *ad = et.authorization_data;\n\t\tfree_AuthorizationDataElement(&ad->val[ad->len - 1]);\n\t\tad->len--;\n\t    }\n\t}\n    }\n\n    ret = krb5_copy_keyblock_contents(context, sessionkey, &et.key);\n    if (ret)\n\tgoto out;\n    et.crealm = tgt_name->realm;\n    et.cname = tgt_name->name;\n\n    ek.key = et.key;\n    /* MIT must have at least one last_req */\n    ek.last_req.val = calloc(1, sizeof(*ek.last_req.val));\n    if (ek.last_req.val == NULL) {\n\tret = ENOMEM;\n\tgoto out;\n    }\n    ek.last_req.len = 1; /* set after alloc to avoid null deref on cleanup */\n    ek.nonce = b->nonce;\n    ek.flags = et.flags;\n    ek.authtime = et.authtime;\n    ek.starttime = et.starttime;\n    ek.endtime = et.endtime;\n    ek.renew_till = et.renew_till;\n    ek.srealm = rep.ticket.realm;\n    ek.sname = rep.ticket.sname;\n\n    _kdc_log_timestamp(context, config, \"TGS-REQ\", et.authtime, et.starttime,\n\t\t       et.endtime, et.renew_till);\n\n    /* Don't sign cross realm tickets, they can't be checked anyway */\n    {\n\tchar *r = get_krbtgt_realm(&ek.sname);\n\n\tif (r == NULL || strcmp(r, ek.srealm) == 0) {\n\t    ret = _kdc_add_KRB5SignedPath(context,\n\t\t\t\t\t  config,\n\t\t\t\t\t  krbtgt,\n\t\t\t\t\t  krbtgt_etype,\n\t\t\t\t\t  client_principal,\n\t\t\t\t\t  NULL,\n\t\t\t\t\t  spp,\n\t\t\t\t\t  &et);\n\t    if (ret)\n\t\tgoto out;\n\t}\n    }\n\n    if (enc_pa_data->len) {\n\trep.padata = calloc(1, sizeof(*rep.padata));\n\tif (rep.padata == NULL) {\n\t    ret = ENOMEM;\n\t    goto out;\n\t}\n\tret = copy_METHOD_DATA(enc_pa_data, rep.padata);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (krb5_enctype_valid(context, serverkey->keytype) != 0\n\t&& _kdc_is_weak_exception(server->entry.principal, serverkey->keytype))\n    {\n\tkrb5_enctype_enable(context, serverkey->keytype);\n\tis_weak = 1;\n    }\n\n\n    /* It is somewhat unclear where the etype in the following\n       encryption should come from. What we have is a session\n       key in the passed tgt, and a list of preferred etypes\n       *for the new ticket*. Should we pick the best possible\n       etype, given the keytype in the tgt, or should we look\n       at the etype list here as well?  What if the tgt\n       session key is DES3 and we want a ticket with a (say)\n       CAST session key. Should the DES3 etype be added to the\n       etype list, even if we don't want a session key with\n       DES3? */\n    ret = _kdc_encode_reply(context, config, NULL, 0,\n\t\t\t    &rep, &et, &ek, serverkey->keytype,\n\t\t\t    kvno,\n\t\t\t    serverkey, 0, replykey, rk_is_subkey,\n\t\t\t    e_text, reply);\n    if (is_weak)\n\tkrb5_enctype_disable(context, serverkey->keytype);\n\nout:\n    free_TGS_REP(&rep);\n    free_TransitedEncoding(&et.transited);\n    if(et.starttime)\n\tfree(et.starttime);\n    if(et.renew_till)\n\tfree(et.renew_till);\n    if(et.authorization_data) {\n\tfree_AuthorizationData(et.authorization_data);\n\tfree(et.authorization_data);\n    }\n    free_LastReq(&ek.last_req);\n    memset(et.key.keyvalue.data, 0, et.key.keyvalue.length);\n    free_EncryptionKey(&et.key);\n    return ret;\n}\n", "target": 1, "idx": 181499}
{"func": " static int em_syscall(struct x86_emulate_ctxt *ctxt)\n {\n \tstruct x86_emulate_ops *ops = ctxt->ops;\n\tstruct desc_struct cs, ss;\n\tu64 msr_data;\n\tu16 cs_sel, ss_sel;\n\tu64 efer = 0;\n\n\t/* syscall is not available in real mode */\n\tif (ctxt->mode == X86EMUL_MODE_REAL ||\n \t    ctxt->mode == X86EMUL_MODE_VM86)\n \t\treturn emulate_ud(ctxt);\n \n \tops->get_msr(ctxt, MSR_EFER, &efer);\n \tsetup_syscalls_segments(ctxt, &cs, &ss);\n \n \tops->get_msr(ctxt, MSR_STAR, &msr_data);\n \tmsr_data >>= 32;\n \tcs_sel = (u16)(msr_data & 0xfffc);\n\tss_sel = (u16)(msr_data + 8);\n\n\tif (efer & EFER_LMA) {\n\t\tcs.d = 0;\n\t\tcs.l = 1;\n\t}\n\tops->set_segment(ctxt, cs_sel, &cs, 0, VCPU_SREG_CS);\n\tops->set_segment(ctxt, ss_sel, &ss, 0, VCPU_SREG_SS);\n\n\tctxt->regs[VCPU_REGS_RCX] = ctxt->_eip;\n\tif (efer & EFER_LMA) {\n#ifdef CONFIG_X86_64\n\t\tctxt->regs[VCPU_REGS_R11] = ctxt->eflags & ~EFLG_RF;\n\n\t\tops->get_msr(ctxt,\n\t\t\t     ctxt->mode == X86EMUL_MODE_PROT64 ?\n\t\t\t     MSR_LSTAR : MSR_CSTAR, &msr_data);\n\t\tctxt->_eip = msr_data;\n\n\t\tops->get_msr(ctxt, MSR_SYSCALL_MASK, &msr_data);\n\t\tctxt->eflags &= ~(msr_data | EFLG_RF);\n#endif\n\t} else {\n\t\t/* legacy mode */\n\t\tops->get_msr(ctxt, MSR_STAR, &msr_data);\n\t\tctxt->_eip = (u32)msr_data;\n\n\t\tctxt->eflags &= ~(EFLG_VM | EFLG_IF | EFLG_RF);\n\t}\n\n\treturn X86EMUL_CONTINUE;\n}\n", "target": 1, "idx": 178826}
{"func": "bool WebstoreStandaloneInstaller::EnsureUniqueInstall(\n    webstore_install::Result* reason,\n    std::string* error) {\n  InstallTracker* tracker = InstallTracker::Get(profile_);\n  DCHECK(tracker);\n\n  const ActiveInstallData* existing_install_data =\n       tracker->GetActiveInstall(id_);\n   if (existing_install_data) {\n     *reason = webstore_install::INSTALL_IN_PROGRESS;\n    *error = kInstallInProgressError;\n     return false;\n   }\n \n  ActiveInstallData install_data(id_);\n  InitInstallData(&install_data);\n  scoped_active_install_.reset(new ScopedActiveInstall(tracker, install_data));\n  return true;\n}\n", "target": 1, "idx": 186050}
{"func": "IDNSpoofChecker::IDNSpoofChecker() {\n  UErrorCode status = U_ZERO_ERROR;\n  checker_ = uspoof_open(&status);\n  if (U_FAILURE(status)) {\n    checker_ = nullptr;\n    return;\n  }\n\n\n  uspoof_setRestrictionLevel(checker_, USPOOF_HIGHLY_RESTRICTIVE);\n\n  SetAllowedUnicodeSet(&status);\n\n  int32_t checks = uspoof_getChecks(checker_, &status) | USPOOF_AUX_INFO;\n  uspoof_setChecks(checker_, checks, &status);\n\n  deviation_characters_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u00df\\\\u03c2\\\\u200c\\\\u200d]\"), status);\n  deviation_characters_.freeze();\n\n  non_ascii_latin_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Latin:] - [a-zA-Z]]\"), status);\n  non_ascii_latin_letters_.freeze();\n\n  kana_letters_exceptions_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[\\\\u3078-\\\\u307a\\\\u30d8-\\\\u30da\\\\u30fb-\\\\u30fe]\"),\n      status);\n  kana_letters_exceptions_.freeze();\n  combining_diacritics_exceptions_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[\\\\u0300-\\\\u0339]\"), status);\n  combining_diacritics_exceptions_.freeze();\n\n  cyrillic_letters_latin_alike_ = icu::UnicodeSet(\n      icu::UnicodeString::fromUTF8(\"[\u0430\u0441\u0501\u0435\u04bb\u0456\u0458\u04cf\u043e\u0440\u051b\u0455\u051d\u0445\u0443\u044a\u042c\u04bd\u043f\u0433\u0475\u0461]\"), status);\n  cyrillic_letters_latin_alike_.freeze();\n\n  cyrillic_letters_ =\n      icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Cyrl:]]\"), status);\n  cyrillic_letters_.freeze();\n\n  DCHECK(U_SUCCESS(status));\n  lgc_letters_n_ascii_ = icu::UnicodeSet(\n      UNICODE_STRING_SIMPLE(\"[[:Latin:][:Greek:][:Cyrillic:][0-9\\\\u002e_\"\n                            \"\\\\u002d][\\\\u0300-\\\\u0339]]\"),\n      status);\n  lgc_letters_n_ascii_.freeze();\n\n  UParseError parse_error;\n  diacritic_remover_.reset(icu::Transliterator::createFromRules(\n      UNICODE_STRING_SIMPLE(\"DropAcc\"),\n      icu::UnicodeString::fromUTF8(\"::NFD; ::[:Nonspacing Mark:] Remove; ::NFC;\"\n                                   \" \u0142 > l; \u00f8 > o; \u0111 > d;\"),\n      UTRANS_FORWARD, parse_error, status));\n\n   extra_confusable_mapper_.reset(icu::Transliterator::createFromRules(\n       UNICODE_STRING_SIMPLE(\"ExtraConf\"),\n      icu::UnicodeString::fromUTF8(\"[\u00fe\u03fc\u048f] > p; [\u0127\u043d\u045b\u04a3\u04a5\u04c8\u04ca\u0527\u0529] > h;\"\n                                   \"[\u0138\u03ba\u043a\u049b\u049d\u049f\u04a1\u04c4\u051f] > k; [\u014b\u043f] > n; [\u0167\u0442\u04ad] > t;\"\n                                    \"[\u0185\u044c\u048d\u0432] > b;  [\u03c9\u0448\u0449\u0e1f] > w; [\u043c\u04ce] > m;\"\n                                   \"[\u0454\u04bd\u04bf\u1054] > e; \u0491 > r; \u0493 > f; [\u04ab\u1004] > c;\"\n                                    \"\u04b1 > y; [\u03c7\u04b3\u04fd\u04ff] > x;\"\n #if defined(OS_WIN)\n                                    \"\u04cf > i;\"\n #else\n                                    \"\u04cf > l;\"\n #endif\n                                   \"\u0503  > d; [\u050d\u100c] > g; [\u0d1f\u0e23] > s; \u1042 > j\"),\n       UTRANS_FORWARD, parse_error, status));\n   DCHECK(U_SUCCESS(status))\n       << \"Spoofchecker initalization failed due to an error: \"\n      << u_errorName(status);\n}\n", "target": 1, "idx": 186713}
{"func": "int perf_event_refresh(struct perf_event *event, int refresh)\n{\n\t/*\n\t * not supported on inherited events\n\t */\n\tif (event->attr.inherit || !is_sampling_event(event))\n\t\treturn -EINVAL;\n\n\tatomic_add(refresh, &event->event_limit);\n\tperf_event_enable(event);\n\n\treturn 0;\n}\n", "target": 0, "idx": 31951}
{"func": "static u16 b43_dmacontroller_base(enum b43_dmatype type, int controller_idx)\n{\n\tstatic const u16 map64[] = {\n\t\tB43_MMIO_DMA64_BASE0,\n\t\tB43_MMIO_DMA64_BASE1,\n\t\tB43_MMIO_DMA64_BASE2,\n\t\tB43_MMIO_DMA64_BASE3,\n\t\tB43_MMIO_DMA64_BASE4,\n\t\tB43_MMIO_DMA64_BASE5,\n\t};\n\tstatic const u16 map32[] = {\n\t\tB43_MMIO_DMA32_BASE0,\n\t\tB43_MMIO_DMA32_BASE1,\n\t\tB43_MMIO_DMA32_BASE2,\n\t\tB43_MMIO_DMA32_BASE3,\n\t\tB43_MMIO_DMA32_BASE4,\n\t\tB43_MMIO_DMA32_BASE5,\n\t};\n\n\tif (type == B43_DMA_64BIT) {\n\t\tB43_WARN_ON(!(controller_idx >= 0 &&\n\t\t\t      controller_idx < ARRAY_SIZE(map64)));\n\t\treturn map64[controller_idx];\n\t}\n\tB43_WARN_ON(!(controller_idx >= 0 &&\n\t\t      controller_idx < ARRAY_SIZE(map32)));\n\treturn map32[controller_idx];\n}\n", "target": 0, "idx": 24538}
{"func": "void SyncBackendHost::Core::RouteJsEvent(\n    const std::string& name, const JsEventDetails& details) {\n  host_->frontend_loop_->PostTask(\n      FROM_HERE, NewRunnableMethod(\n          this, &Core::RouteJsEventOnFrontendLoop, name, details));\n}\n", "target": 0, "idx": 106350}
{"func": "static int _nfs4_proc_access(struct inode *inode, struct nfs_access_entry *entry)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs4_accessargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.bitmask = server->attr_bitmask,\n\t};\n\tstruct nfs4_accessres res = {\n\t\t.server = server,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_ACCESS],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t\t.rpc_cred = entry->cred,\n\t};\n\tint mode = entry->mask;\n\tint status;\n\n\t/*\n\t * Determine which access bits we want to ask for...\n\t */\n\tif (mode & MAY_READ)\n\t\targs.access |= NFS4_ACCESS_READ;\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tif (mode & MAY_WRITE)\n\t\t\targs.access |= NFS4_ACCESS_MODIFY | NFS4_ACCESS_EXTEND | NFS4_ACCESS_DELETE;\n\t\tif (mode & MAY_EXEC)\n\t\t\targs.access |= NFS4_ACCESS_LOOKUP;\n\t} else {\n\t\tif (mode & MAY_WRITE)\n\t\t\targs.access |= NFS4_ACCESS_MODIFY | NFS4_ACCESS_EXTEND;\n\t\tif (mode & MAY_EXEC)\n\t\t\targs.access |= NFS4_ACCESS_EXECUTE;\n\t}\n\n\tres.fattr = nfs_alloc_fattr();\n\tif (res.fattr == NULL)\n\t\treturn -ENOMEM;\n\n\tstatus = nfs4_call_sync(server->client, server, &msg, &args.seq_args, &res.seq_res, 0);\n\tif (!status) {\n\t\tentry->mask = 0;\n\t\tif (res.access & NFS4_ACCESS_READ)\n\t\t\tentry->mask |= MAY_READ;\n\t\tif (res.access & (NFS4_ACCESS_MODIFY | NFS4_ACCESS_EXTEND | NFS4_ACCESS_DELETE))\n\t\t\tentry->mask |= MAY_WRITE;\n\t\tif (res.access & (NFS4_ACCESS_LOOKUP|NFS4_ACCESS_EXECUTE))\n\t\t\tentry->mask |= MAY_EXEC;\n\t\tnfs_refresh_inode(inode, res.fattr);\n\t}\n\tnfs_free_fattr(res.fattr);\n\treturn status;\n}\n", "target": 0, "idx": 23171}
{"func": "pdf_load_version(fz_context *ctx, pdf_document *doc)\n{\n\tchar buf[20];\n\n\tfz_seek(ctx, doc->file, 0, SEEK_SET);\n\tfz_read_line(ctx, doc->file, buf, sizeof buf);\n\tif (memcmp(buf, \"%PDF-\", 5) != 0)\n\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"cannot recognize version marker\");\n\n\tdoc->version = 10 * (fz_atof(buf+5) + 0.05f);\n\tif (doc->version < 10 || doc->version > 17)\n\t\tif (doc->version != 20)\n\t\t\tfz_warn(ctx, \"unknown PDF version: %d.%d\", doc->version / 10, doc->version % 10);\n}\n", "target": 0, "idx": 16711}
{"func": "timeval_equals(struct timeval * tv0, struct timeval * tv1)\n{\n    if ( tv0->tv_sec == tv1->tv_sec && tv0->tv_usec == tv1->tv_usec )\n\treturn 1;\n    else\n\treturn 0;\n}\n", "target": 0, "idx": 53456}
{"func": "void RenderFrameDevToolsAgentHost::DestroyOnRenderFrameGone() {\n   scoped_refptr<RenderFrameDevToolsAgentHost> protect(this);\n   if (IsAttached())\n     RevokePolicy();\n  ForceDetachAllClients();\n   frame_host_ = nullptr;\n   agent_ptr_.reset();\n   SetFrameTreeNode(nullptr);\n  Release();\n}\n", "target": 1, "idx": 187271}
{"func": "static unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len)\n{\n   unsigned s1 = adler & 0xffff;\n   unsigned s2 = (adler >> 16) & 0xffff;\n\n  while(len > 0)\n  {\n    /*at least 5550 sums can be done before the sums overflow, saving a lot of module divisions*/\n    unsigned amount = len > 5550 ? 5550 : len;\n    len -= amount;\n    while(amount > 0)\n    {\n      s1 += (*data++);\n      s2 += s1;\n      amount--;\n    }\n    s1 %= 65521;\n    s2 %= 65521;\n  }\n\n  return (s2 << 16) | s1;\n}\n", "target": 0, "idx": 87616}
{"func": "static void update_task_scan_period(struct task_struct *p,\n\t\t\tunsigned long shared, unsigned long private)\n{\n\tunsigned int period_slot;\n\tint lr_ratio, ps_ratio;\n\tint diff;\n\n\tunsigned long remote = p->numa_faults_locality[0];\n\tunsigned long local = p->numa_faults_locality[1];\n\n\t/*\n\t * If there were no record hinting faults then either the task is\n\t * completely idle or all activity is areas that are not of interest\n\t * to automatic numa balancing. Related to that, if there were failed\n\t * migration then it implies we are migrating too quickly or the local\n\t * node is overloaded. In either case, scan slower\n\t */\n\tif (local + shared == 0 || p->numa_faults_locality[2]) {\n\t\tp->numa_scan_period = min(p->numa_scan_period_max,\n\t\t\tp->numa_scan_period << 1);\n\n\t\tp->mm->numa_next_scan = jiffies +\n\t\t\tmsecs_to_jiffies(p->numa_scan_period);\n\n\t\treturn;\n\t}\n\n\t/*\n\t * Prepare to scale scan period relative to the current period.\n\t *\t == NUMA_PERIOD_THRESHOLD scan period stays the same\n\t *       <  NUMA_PERIOD_THRESHOLD scan period decreases (scan faster)\n\t *\t >= NUMA_PERIOD_THRESHOLD scan period increases (scan slower)\n\t */\n\tperiod_slot = DIV_ROUND_UP(p->numa_scan_period, NUMA_PERIOD_SLOTS);\n\tlr_ratio = (local * NUMA_PERIOD_SLOTS) / (local + remote);\n\tps_ratio = (private * NUMA_PERIOD_SLOTS) / (private + shared);\n\n\tif (ps_ratio >= NUMA_PERIOD_THRESHOLD) {\n\t\t/*\n\t\t * Most memory accesses are local. There is no need to\n\t\t * do fast NUMA scanning, since memory is already local.\n\t\t */\n\t\tint slot = ps_ratio - NUMA_PERIOD_THRESHOLD;\n\t\tif (!slot)\n\t\t\tslot = 1;\n\t\tdiff = slot * period_slot;\n\t} else if (lr_ratio >= NUMA_PERIOD_THRESHOLD) {\n\t\t/*\n\t\t * Most memory accesses are shared with other tasks.\n\t\t * There is no point in continuing fast NUMA scanning,\n\t\t * since other tasks may just move the memory elsewhere.\n\t\t */\n\t\tint slot = lr_ratio - NUMA_PERIOD_THRESHOLD;\n\t\tif (!slot)\n\t\t\tslot = 1;\n\t\tdiff = slot * period_slot;\n\t} else {\n\t\t/*\n\t\t * Private memory faults exceed (SLOTS-THRESHOLD)/SLOTS,\n\t\t * yet they are not on the local NUMA node. Speed up\n\t\t * NUMA scanning to get the memory moved over.\n\t\t */\n\t\tint ratio = max(lr_ratio, ps_ratio);\n\t\tdiff = -(NUMA_PERIOD_THRESHOLD - ratio) * period_slot;\n\t}\n\n\tp->numa_scan_period = clamp(p->numa_scan_period + diff,\n\t\t\ttask_scan_min(p), task_scan_max(p));\n\tmemset(p->numa_faults_locality, 0, sizeof(p->numa_faults_locality));\n}\n", "target": 0, "idx": 92779}
{"func": "PHP_FUNCTION(money_format)\n{\n\tsize_t format_len = 0;\n\tchar *format, *p, *e;\n\tdouble value;\n\tzend_bool check = 0;\n\tzend_string *str;\n\tssize_t res_len;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"sd\", &format, &format_len, &value) == FAILURE) {\n\t\treturn;\n\t}\n\n\tp = format;\n\te = p + format_len;\n\twhile ((p = memchr(p, '%', (e - p)))) {\n\t\tif (*(p + 1) == '%') {\n\t\t\tp += 2;\n\t\t} else if (!check) {\n\t\t\tcheck = 1;\n\t\t\tp++;\n\t\t} else {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"Only a single %%i or %%n token can be used\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\t}\n\n\tstr = zend_string_alloc(format_len + 1024, 0);\n\tif ((res_len = strfmon(ZSTR_VAL(str), ZSTR_LEN(str), format, value)) < 0) {\n\t\tzend_string_free(str);\n\t\tRETURN_FALSE;\n\t}\n\tZSTR_LEN(str) = (size_t)res_len;\n\tZSTR_VAL(str)[ZSTR_LEN(str)] = '\\0';\n\n\tRETURN_NEW_STR(zend_string_truncate(str, ZSTR_LEN(str), 0));\n}\n", "target": 0, "idx": 14661}
{"func": "static int dnxhd_decode_header(DNXHDContext *ctx, AVFrame *frame,\n                               const uint8_t *buf, int buf_size,\n                               int first_field)\n{\n    int i, cid, ret;\n    int old_bit_depth = ctx->bit_depth, bitdepth;\n    uint64_t header_prefix;\n    if (buf_size < 0x280) {\n        av_log(ctx->avctx, AV_LOG_ERROR,\n               \"buffer too small (%d < 640).\\n\", buf_size);\n        return AVERROR_INVALIDDATA;\n    }\n\n    header_prefix = ff_dnxhd_parse_header_prefix(buf);\n    if (header_prefix == 0) {\n        av_log(ctx->avctx, AV_LOG_ERROR,\n               \"unknown header 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X\\n\",\n               buf[0], buf[1], buf[2], buf[3], buf[4]);\n        return AVERROR_INVALIDDATA;\n    }\n    if (buf[5] & 2) { /* interlaced */\n        ctx->cur_field = buf[5] & 1;\n        frame->interlaced_frame = 1;\n        frame->top_field_first  = first_field ^ ctx->cur_field;\n        av_log(ctx->avctx, AV_LOG_DEBUG,\n               \"interlaced %d, cur field %d\\n\", buf[5] & 3, ctx->cur_field);\n    } else {\n        ctx->cur_field = 0;\n    }\n    ctx->mbaff = (buf[0x6] >> 5) & 1;\n\n    ctx->height = AV_RB16(buf + 0x18);\n    ctx->width  = AV_RB16(buf + 0x1a);\n\n    switch(buf[0x21] >> 5) {\n    case 1: bitdepth = 8; break;\n    case 2: bitdepth = 10; break;\n    case 3: bitdepth = 12; break;\n    default:\n        av_log(ctx->avctx, AV_LOG_ERROR,\n               \"Unknown bitdepth indicator (%d)\\n\", buf[0x21] >> 5);\n        return AVERROR_INVALIDDATA;\n    }\n\n    cid = AV_RB32(buf + 0x28);\n\n    ctx->avctx->profile = dnxhd_get_profile(cid);\n\n    if ((ret = dnxhd_init_vlc(ctx, cid, bitdepth)) < 0)\n        return ret;\n    if (ctx->mbaff && ctx->cid_table->cid != 1260)\n        av_log(ctx->avctx, AV_LOG_WARNING,\n               \"Adaptive MB interlace flag in an unsupported profile.\\n\");\n\n    ctx->act = buf[0x2C] & 7;\n    if (ctx->act && ctx->cid_table->cid != 1256 && ctx->cid_table->cid != 1270)\n        av_log(ctx->avctx, AV_LOG_WARNING,\n               \"Adaptive color transform in an unsupported profile.\\n\");\n\n    ctx->is_444 = (buf[0x2C] >> 6) & 1;\n    if (ctx->is_444) {\n        if (bitdepth == 8) {\n            avpriv_request_sample(ctx->avctx, \"4:4:4 8 bits\");\n            return AVERROR_INVALIDDATA;\n        } else if (bitdepth == 10) {\n            ctx->decode_dct_block = dnxhd_decode_dct_block_10_444;\n            ctx->pix_fmt = ctx->act ? AV_PIX_FMT_YUV444P10\n                                    : AV_PIX_FMT_GBRP10;\n        } else {\n            ctx->decode_dct_block = dnxhd_decode_dct_block_12_444;\n            ctx->pix_fmt = ctx->act ? AV_PIX_FMT_YUV444P12\n                                    : AV_PIX_FMT_GBRP12;\n        }\n    } else if (bitdepth == 12) {\n        ctx->decode_dct_block = dnxhd_decode_dct_block_12;\n        ctx->pix_fmt = AV_PIX_FMT_YUV422P12;\n    } else if (bitdepth == 10) {\n        if (ctx->avctx->profile == FF_PROFILE_DNXHR_HQX)\n            ctx->decode_dct_block = dnxhd_decode_dct_block_10_444;\n        else\n            ctx->decode_dct_block = dnxhd_decode_dct_block_10;\n        ctx->pix_fmt = AV_PIX_FMT_YUV422P10;\n    } else {\n        ctx->decode_dct_block = dnxhd_decode_dct_block_8;\n        ctx->pix_fmt = AV_PIX_FMT_YUV422P;\n    }\n\n    ctx->avctx->bits_per_raw_sample = ctx->bit_depth = bitdepth;\n    if (ctx->bit_depth != old_bit_depth) {\n        ff_blockdsp_init(&ctx->bdsp, ctx->avctx);\n        ff_idctdsp_init(&ctx->idsp, ctx->avctx);\n        ff_init_scantable(ctx->idsp.idct_permutation, &ctx->scantable,\n                          ff_zigzag_direct);\n    }\n\n    if (ctx->width != ctx->cid_table->width &&\n        ctx->cid_table->width != DNXHD_VARIABLE) {\n        av_reduce(&ctx->avctx->sample_aspect_ratio.num,\n                  &ctx->avctx->sample_aspect_ratio.den,\n                  ctx->width, ctx->cid_table->width, 255);\n        ctx->width = ctx->cid_table->width;\n    }\n\n    if (buf_size < ctx->cid_table->coding_unit_size) {\n        av_log(ctx->avctx, AV_LOG_ERROR, \"incorrect frame size (%d < %u).\\n\",\n               buf_size, ctx->cid_table->coding_unit_size);\n        return AVERROR_INVALIDDATA;\n    }\n\n    ctx->mb_width  = (ctx->width + 15)>> 4;\n    ctx->mb_height = AV_RB16(buf + 0x16c);\n\n    if ((ctx->height + 15) >> 4 == ctx->mb_height && frame->interlaced_frame)\n        ctx->height <<= 1;\n\n    av_log(ctx->avctx, AV_LOG_VERBOSE, \"%dx%d, 4:%s %d bits, MBAFF=%d ACT=%d\\n\",\n           ctx->width, ctx->height, ctx->is_444 ? \"4:4\" : \"2:2\",\n           ctx->bit_depth, ctx->mbaff, ctx->act);\n\n     if (ctx->mb_height > 68 && ff_dnxhd_check_header_prefix_hr(header_prefix)) {\n         ctx->data_offset = 0x170 + (ctx->mb_height << 2);\n     } else {\n        if (ctx->mb_height > 68 ||\n            (ctx->mb_height << frame->interlaced_frame) > (ctx->height + 15) >> 4) {\n             av_log(ctx->avctx, AV_LOG_ERROR,\n                    \"mb height too big: %d\\n\", ctx->mb_height);\n             return AVERROR_INVALIDDATA;\n         }\n         ctx->data_offset = 0x280;\n     }\n \n     if (buf_size < ctx->data_offset) {\n         av_log(ctx->avctx, AV_LOG_ERROR,\n               \"buffer too small (%d < %d).\\n\", buf_size, ctx->data_offset);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (ctx->mb_height > FF_ARRAY_ELEMS(ctx->mb_scan_index)) {\n        av_log(ctx->avctx, AV_LOG_ERROR,\n               \"mb_height too big (%d > %\"SIZE_SPECIFIER\").\\n\", ctx->mb_height, FF_ARRAY_ELEMS(ctx->mb_scan_index));\n        return AVERROR_INVALIDDATA;\n    }\n\n    for (i = 0; i < ctx->mb_height; i++) {\n        ctx->mb_scan_index[i] = AV_RB32(buf + 0x170 + (i << 2));\n        ff_dlog(ctx->avctx, \"mb scan index %d, pos %d: %\"PRIu32\"\\n\",\n                i, 0x170 + (i << 2), ctx->mb_scan_index[i]);\n        if (buf_size - ctx->data_offset < ctx->mb_scan_index[i]) {\n            av_log(ctx->avctx, AV_LOG_ERROR,\n                   \"invalid mb scan index (%\"PRIu32\" vs %u).\\n\",\n                   ctx->mb_scan_index[i], buf_size - ctx->data_offset);\n            return AVERROR_INVALIDDATA;\n        }\n    }\n\n    return 0;\n}\n", "target": 1, "idx": 181172}
{"func": "void AppCacheUpdateJob::HandleMasterEntryFetchCompleted(\n    URLFetcher* fetcher) {\n  DCHECK(internal_state_ == NO_UPDATE || internal_state_ == DOWNLOADING);\n\n\n  net::URLRequest* request = fetcher->request();\n  const GURL& url = request->original_url();\n  master_entry_fetches_.erase(url);\n  ++master_entries_completed_;\n\n  int response_code = request->status().is_success()\n      ? request->GetResponseCode() : -1;\n\n  PendingMasters::iterator found = pending_master_entries_.find(url);\n  DCHECK(found != pending_master_entries_.end());\n  PendingHosts& hosts = found->second;\n\n  if (response_code / 100 == 2) {\n    AppCache* cache = inprogress_cache_.get() ? inprogress_cache_.get()\n                                              : group_->newest_complete_cache();\n    DCHECK(fetcher->response_writer());\n    AppCacheEntry master_entry(AppCacheEntry::MASTER,\n                               fetcher->response_writer()->response_id(),\n                               fetcher->response_writer()->amount_written());\n    if (cache->AddOrModifyEntry(url, master_entry))\n      added_master_entries_.push_back(url);\n    else\n      duplicate_response_ids_.push_back(master_entry.response_id());\n\n    if (!inprogress_cache_.get()) {\n      DCHECK(cache == group_->newest_complete_cache());\n      for (PendingHosts::iterator host_it = hosts.begin();\n           host_it != hosts.end(); ++host_it) {\n        (*host_it)->AssociateCompleteCache(cache);\n      }\n    }\n  } else {\n    HostNotifier host_notifier;\n    for (PendingHosts::iterator host_it = hosts.begin();\n         host_it != hosts.end(); ++host_it) {\n      AppCacheHost* host = *host_it;\n      host_notifier.AddHost(host);\n\n      if (inprogress_cache_.get())\n        host->AssociateNoCache(GURL());\n\n      host->RemoveObserver(this);\n     }\n     hosts.clear();\n \n     const char* kFormatString = \"Manifest fetch failed (%d) %s\";\n     std::string message = FormatUrlErrorMessage(\n         kFormatString, request->url(), fetcher->result(), response_code);\n    host_notifier.SendErrorNotifications(\n        AppCacheErrorDetails(message,\n                     APPCACHE_MANIFEST_ERROR,\n                     request->url(),\n                     response_code,\n                     false /*is_cross_origin*/));\n\n    if (inprogress_cache_.get()) {\n      pending_master_entries_.erase(found);\n      --master_entries_completed_;\n\n      if (update_type_ == CACHE_ATTEMPT && pending_master_entries_.empty()) {\n        HandleCacheFailure(AppCacheErrorDetails(message,\n                                        APPCACHE_MANIFEST_ERROR,\n                                        request->url(),\n                                        response_code,\n                                        false /*is_cross_origin*/),\n                           fetcher->result(),\n                           GURL());\n        return;\n      }\n    }\n  }\n\n  DCHECK(internal_state_ != CACHE_FAILURE);\n  FetchMasterEntries();\n  MaybeCompleteUpdate();\n}\n", "target": 1, "idx": 185609}
{"func": "report_error (const char *format, ...)\n#else\nreport_error (format, va_alist)\n     const char *format;\n     va_dcl\n#endif\n{\n  va_list args;\n\n  error_prolog (1);\n\n  SH_VA_START (args, format);\n\n  vfprintf (stderr, format, args);\n  fprintf (stderr, \"\\n\");\n \n   va_end (args);\n   if (exit_immediately_on_error)\n    exit_shell (1);\n }\n", "target": 1, "idx": 178602}
{"func": "WebMouseEvent* BuildMouseEvent(const PP_InputEvent& event) {\n  WebMouseEvent* mouse_event = new WebMouseEvent();\n  switch (event.type) {\n    case PP_INPUTEVENT_TYPE_MOUSEDOWN:\n      mouse_event->type = WebInputEvent::MouseDown;\n      break;\n    case PP_INPUTEVENT_TYPE_MOUSEUP:\n      mouse_event->type = WebInputEvent::MouseUp;\n      break;\n    case PP_INPUTEVENT_TYPE_MOUSEMOVE:\n      mouse_event->type = WebInputEvent::MouseMove;\n      break;\n    case PP_INPUTEVENT_TYPE_MOUSEENTER:\n      mouse_event->type = WebInputEvent::MouseEnter;\n      break;\n     case PP_INPUTEVENT_TYPE_MOUSELEAVE:\n       mouse_event->type = WebInputEvent::MouseLeave;\n       break;\n     default:\n       NOTREACHED();\n   }\n  mouse_event->timeStampSeconds = event.time_stamp;\n  mouse_event->modifiers = event.u.mouse.modifier;\n  mouse_event->button =\n      static_cast<WebMouseEvent::Button>(event.u.mouse.button);\n  mouse_event->x = static_cast<int>(event.u.mouse.x);\n  mouse_event->y = static_cast<int>(event.u.mouse.y);\n  mouse_event->clickCount = event.u.mouse.click_count;\n  return mouse_event;\n}\n", "target": 1, "idx": 184074}
{"func": "static Image *ReadSCRImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n    char zxscr[6144];\n    char zxattr[768];\n    int octetnr;\n    int octetline;\n    int zoneline;\n    int zonenr;\n    int octet_val;\n    int attr_nr;\n    int pix;\n    int piy;\n    int binar[8];\n    int attrbin[8];\n    int *pbin;\n    int *abin;\n    int z;\n    int one_nr;\n    int ink;\n    int paper;\n    int bright;\n\n  unsigned char colour_palette[] = {\n      0,  0,  0,\n      0,  0,192,\n    192,  0,  0,\n    192,  0,192,\n      0,192,  0,\n      0,192,192,\n    192,192,  0,\n    192,192,192,\n      0,  0,  0,\n      0,  0,255,\n    255,  0,  0,\n    255,  0,255,\n      0,255,  0,\n      0,255,255,\n    255,255,  0,\n    255,255,255\n  };\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  register PixelPacket\n    *q;\n\n  ssize_t\n    count;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n     }\n   image->columns = 256;\n   image->rows = 192;\n   count=ReadBlob(image,6144,(unsigned char *) zxscr);\n   (void) count;\n   count=ReadBlob(image,768,(unsigned char *) zxattr);\n  for(zonenr=0;zonenr<3;zonenr++)\n  {\n      for(zoneline=0;zoneline<8;zoneline++)\n        {\n        for(octetline=0;octetline<8;octetline++)\n      {\n          for(octetnr=(zoneline*32);octetnr<((zoneline*32)+32);octetnr++)\n            {\n            octet_val = zxscr[octetnr+(256*octetline)+(zonenr*2048)];\n            attr_nr = zxattr[octetnr+(256*zonenr)];\n\n            pix = (((8*octetnr)-(256*zoneline)));\n            piy = ((octetline+(8*zoneline)+(zonenr*64)));\n\n            pbin = binar;\n            abin = attrbin;\n\n            one_nr=1;\n\n            for(z=0;z<8;z++)\n          {\n              if(octet_val&one_nr)\n            {\n                *pbin = 1;\n            } else {\n                *pbin = 0;\n            }\n              one_nr=one_nr*2;\n              pbin++;\n          }\n\n            one_nr = 1;\n\n            for(z=0;z<8;z++)\n          {\n              if(attr_nr&one_nr)\n            {\n                *abin = 1;\n            } else {\n                *abin = 0;\n            }\n              one_nr=one_nr*2;\n              abin++;\n          }\n\n            ink = (attrbin[0]+(2*attrbin[1])+(4*attrbin[2]));\n            paper = (attrbin[3]+(2*attrbin[4])+(4*attrbin[5]));\n            bright = attrbin[6];\n\n            if(bright) { ink=ink+8; paper=paper+8; }\n\n            for(z=7;z>-1;z--)\n          {\n              q=QueueAuthenticPixels(image,pix,piy,1,1,exception);\n              if (q == (PixelPacket *) NULL)\n                break;\n\n              if(binar[z])\n            {\n                SetPixelRed(q,ScaleCharToQuantum(\n                  colour_palette[3*ink]));\n                SetPixelGreen(q,ScaleCharToQuantum(\n                  colour_palette[1+(3*ink)]));\n                SetPixelBlue(q,ScaleCharToQuantum(\n                  colour_palette[2+(3*ink)]));\n            } else {\n                SetPixelRed(q,ScaleCharToQuantum(\n                  colour_palette[3*paper]));\n                SetPixelGreen(q,ScaleCharToQuantum(\n                  colour_palette[1+(3*paper)]));\n                SetPixelBlue(q,ScaleCharToQuantum(\n                  colour_palette[2+(3*paper)]));\n            }\n\n              pix++;\n          }\n        }\n      }\n    }\n  }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n", "target": 1, "idx": 181773}
{"func": "long long Segment::CreateInstance(\n    IMkvReader* pReader,\n    long long pos,\n    Segment*& pSegment)\n{\n    assert(pReader);\n    assert(pos >= 0);\n \n    pSegment = NULL;\n \n    long long total, available;\n \n    const long status = pReader->Length(&total, &available);\n \n    if (status < 0) //error\n        return status;\n \n    if (available < 0)\n         return -1;\n \n    if ((total >= 0) && (available > total))\n         return -1;\n \n \n    for (;;)\n    {\n        if ((total >= 0) && (pos >= total))\n            return E_FILE_FORMAT_INVALID;\n        long len;\n        long long result = GetUIntLength(pReader, pos, len);\n        if (result)  //error, or too few available bytes\n            return result;\n        if ((total >= 0) && ((pos + len) > total))\n            return E_FILE_FORMAT_INVALID;\n        if ((pos + len) > available)\n            return pos + len;\n        const long long idpos = pos;\n        const long long id = ReadUInt(pReader, pos, len);\n        if (id < 0)  //error\n            return id;\n        pos += len;  //consume ID\n        result = GetUIntLength(pReader, pos, len);\n        if (result)  //error, or too few available bytes\n            return result;\n        if ((total >= 0) && ((pos + len) > total))\n            return E_FILE_FORMAT_INVALID;\n        if ((pos + len) > available)\n            return pos + len;\n        long long size = ReadUInt(pReader, pos, len);\n        if (size < 0)  //error\n            return size;\n        pos += len;  //consume length of size of element\n        const long long unknown_size = (1LL << (7 * len)) - 1;\n        if (id == 0x08538067)  //Segment ID\n        {\n            if (size == unknown_size)\n                size = -1;\n            else if (total < 0)\n                size = -1;\n            else if ((pos + size) > total)\n                size = -1;\n            pSegment = new (std::nothrow) Segment(\n                                            pReader,\n                                            idpos,\n                                            pos,\n                                            size);\n            if (pSegment == 0)\n                return -1;  //generic error\n            return 0;    //success\n        }\n        if (size == unknown_size)\n            return E_FILE_FORMAT_INVALID;\n        if ((total >= 0) && ((pos + size) > total))\n            return E_FILE_FORMAT_INVALID;\n        if ((pos + size) > available)\n            return pos + size;\n        pos += size;  //consume payload\n    }\n}\n", "target": 1, "idx": 188281}
{"func": "void RenderView::printPage(WebFrame* frame) {\n  DCHECK(frame);\n  Print(frame, true);\n}\n", "target": 0, "idx": 98117}
{"func": "long get_user_pages_remote(struct task_struct *tsk, struct mm_struct *mm,\n\t\tunsigned long start, unsigned long nr_pages,\n\t\tint write, int force, struct page **pages,\n\t\tstruct vm_area_struct **vmas)\n{\n\treturn __get_user_pages_locked(tsk, mm, start, nr_pages, write, force,\n\t\t\t\t       pages, vmas, NULL, false,\n\t\t\t\t       FOLL_TOUCH | FOLL_REMOTE);\n}\n", "target": 0, "idx": 52109}
{"func": " void ResourcePrefetchPredictor::LearnOrigins(\n     const std::string& host,\n     const GURL& main_frame_origin,\n    const std::map<GURL, OriginRequestSummary>& summaries) {\n   DCHECK_CURRENTLY_ON(BrowserThread::UI);\n   if (host.size() > ResourcePrefetchPredictorTables::kMaxStringLength)\n     return;\n\n  OriginData data;\n  bool exists = origin_data_->TryGetData(host, &data);\n  if (!exists) {\n    data.set_host(host);\n    data.set_last_visit_time(base::Time::Now().ToInternalValue());\n    size_t origins_size = summaries.size();\n    auto ordered_origins =\n        std::vector<const OriginRequestSummary*>(origins_size);\n    for (const auto& kv : summaries) {\n      size_t index = kv.second.first_occurrence;\n      DCHECK_LT(index, origins_size);\n      ordered_origins[index] = &kv.second;\n    }\n\n    for (const OriginRequestSummary* summary : ordered_origins) {\n      auto* origin_to_add = data.add_origins();\n      InitializeOriginStatFromOriginRequestSummary(origin_to_add, *summary);\n    }\n   } else {\n     data.set_last_visit_time(base::Time::Now().ToInternalValue());\n \n    std::map<GURL, int> old_index;\n     int old_size = static_cast<int>(data.origins_size());\n     for (int i = 0; i < old_size; ++i) {\n       bool is_new =\n          old_index.insert({GURL(data.origins(i).origin()), i}).second;\n       DCHECK(is_new);\n     }\n \n     for (int i = 0; i < old_size; ++i) {\n       auto* old_origin = data.mutable_origins(i);\n      GURL origin(old_origin->origin());\n       auto it = summaries.find(origin);\n       if (it == summaries.end()) {\n        old_origin->set_number_of_misses(old_origin->number_of_misses() + 1);\n        old_origin->set_consecutive_misses(old_origin->consecutive_misses() +\n                                           1);\n      } else {\n        const auto& new_origin = it->second;\n        old_origin->set_always_access_network(new_origin.always_access_network);\n        old_origin->set_accessed_network(new_origin.accessed_network);\n\n        int position = new_origin.first_occurrence + 1;\n        int total =\n            old_origin->number_of_hits() + old_origin->number_of_misses();\n        old_origin->set_average_position(\n            ((old_origin->average_position() * total) + position) /\n            (total + 1));\n        old_origin->set_number_of_hits(old_origin->number_of_hits() + 1);\n        old_origin->set_consecutive_misses(0);\n      }\n    }\n\n    for (const auto& kv : summaries) {\n      if (old_index.find(kv.first) != old_index.end())\n        continue;\n\n      auto* origin_to_add = data.add_origins();\n      InitializeOriginStatFromOriginRequestSummary(origin_to_add, kv.second);\n    }\n  }\n\n  ResourcePrefetchPredictorTables::TrimOrigins(&data,\n                                               config_.max_consecutive_misses);\n  ResourcePrefetchPredictorTables::SortOrigins(&data, main_frame_origin.spec());\n  if (data.origins_size() > static_cast<int>(config_.max_origins_per_entry)) {\n    data.mutable_origins()->DeleteSubrange(\n        config_.max_origins_per_entry,\n        data.origins_size() - config_.max_origins_per_entry);\n  }\n\n  if (data.origins_size() == 0)\n    origin_data_->DeleteData({host});\n  else\n    origin_data_->UpdateData(host, data);\n}\n", "target": 1, "idx": 186348}
{"func": " static __u8 *ch_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n \t\tunsigned int *rsize)\n {\n\tif (*rsize >= 17 && rdesc[11] == 0x3c && rdesc[12] == 0x02) {\n \t\thid_info(hdev, \"fixing up Cherry Cymotion report descriptor\\n\");\n \t\trdesc[11] = rdesc[16] = 0xff;\n \t\trdesc[12] = rdesc[17] = 0x03;\n\t}\n\treturn rdesc;\n}\n", "target": 1, "idx": 179542}
{"func": "void TIFF_MetaHandler::ProcessXMP()\n{\n\n\tthis->processedXMP = true;\t// Make sure we only come through here once.\n\n\n\n\tbool found;\n\tbool readOnly = ((this->parent->openFlags & kXMPFiles_OpenForUpdate) == 0);\n\n\tif ( readOnly ) {\n\t\tthis->psirMgr = new PSIR_MemoryReader();\n\t\tthis->iptcMgr = new IPTC_Reader();\n\t} else {\n\t\tthis->psirMgr = new PSIR_FileWriter();\n\t\tthis->iptcMgr = new IPTC_Writer();\t// ! Parse it later.\n\t}\n\n\tTIFF_Manager & tiff = this->tiffMgr;\t// Give the compiler help in recognizing non-aliases.\n\tPSIR_Manager & psir = *this->psirMgr;\n\tIPTC_Manager & iptc = *this->iptcMgr;\n\n\tTIFF_Manager::TagInfo psirInfo;\n\tbool havePSIR = tiff.GetTag ( kTIFF_PrimaryIFD, kTIFF_PSIR, &psirInfo );\n\n\tif ( havePSIR ) {\t// ! Do the Photoshop 6 integration before other legacy analysis.\n\t\tpsir.ParseMemoryResources ( psirInfo.dataPtr, psirInfo.dataLen );\n\t\tPSIR_Manager::ImgRsrcInfo buriedExif;\n\t\tfound = psir.GetImgRsrc ( kPSIR_Exif, &buriedExif );\n\t\tif ( found ) {\n\t\t\ttiff.IntegrateFromPShop6 ( buriedExif.dataPtr, buriedExif.dataLen );\n\t\t\tif ( ! readOnly ) psir.DeleteImgRsrc ( kPSIR_Exif );\n\t\t}\n\t}\n\n\tTIFF_Manager::TagInfo iptcInfo;\n\tbool haveIPTC = tiff.GetTag ( kTIFF_PrimaryIFD, kTIFF_IPTC, &iptcInfo );\t// The TIFF IPTC tag.\n\tint iptcDigestState = kDigestMatches;\n\n\tif ( haveIPTC ) {\n\n\t\tbool haveDigest = false;\n\t\tPSIR_Manager::ImgRsrcInfo digestInfo;\n\t\tif ( havePSIR ) haveDigest = psir.GetImgRsrc ( kPSIR_IPTCDigest, &digestInfo );\n\t\tif ( digestInfo.dataLen != 16 ) haveDigest = false;\n\n\t\tif ( ! haveDigest ) {\n\n\t\t\tiptcDigestState = kDigestMissing;\n\n\t\t} else {\n\n \n \t\t\tiptcDigestState = PhotoDataUtils::CheckIPTCDigest ( iptcInfo.dataPtr, iptcInfo.dataLen, digestInfo.dataPtr );\n\t\t\tif ( (iptcDigestState == kDigestDiffers) && (kTIFF_TypeSizes[iptcInfo.type] > 1) ) {\n \t\t\t\tXMP_Uns8 * endPtr = (XMP_Uns8*)iptcInfo.dataPtr + iptcInfo.dataLen - 1;\n \t\t\t\tXMP_Uns8 * minPtr = endPtr - kTIFF_TypeSizes[iptcInfo.type] + 1;\n \t\t\t\twhile ( (endPtr >= minPtr) && (*endPtr == 0) ) --endPtr;\n\t\t\t\tiptcDigestState = PhotoDataUtils::CheckIPTCDigest ( iptcInfo.dataPtr, unpaddedLen, digestInfo.dataPtr );\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tXMP_OptionBits options = k2XMP_FileHadExif;\t// TIFF files are presumed to have Exif legacy.\n\tif ( haveIPTC ) options |= k2XMP_FileHadIPTC;\n\tif ( this->containsXMP ) options |= k2XMP_FileHadXMP;\n\n\n\tbool haveXMP = false;\n\n\tif ( ! this->xmpPacket.empty() ) {\n\t\tXMP_Assert ( this->containsXMP );\n\t\tXMP_StringPtr packetStr = this->xmpPacket.c_str();\n\t\tXMP_StringLen packetLen = (XMP_StringLen)this->xmpPacket.size();\n\t\ttry {\n\t\t\tthis->xmpObj.ParseFromBuffer ( packetStr, packetLen );\n\t\t} catch ( ... ) { /* Ignore parsing failures, someday we hope to get partial XMP back. */ }\n\t\thaveXMP = true;\n\t}\n\n\n\tif ( haveIPTC && (! haveXMP) && (iptcDigestState == kDigestMatches) ) iptcDigestState = kDigestMissing;\n\tbool parseIPTC = (iptcDigestState != kDigestMatches) || (! readOnly);\n\tif ( parseIPTC ) iptc.ParseMemoryDataSets ( iptcInfo.dataPtr, iptcInfo.dataLen );\n\tImportPhotoData ( tiff, iptc, psir, iptcDigestState, &this->xmpObj, options );\n\n\tthis->containsXMP = true;\t// Assume we now have something in the XMP.\n\n}\t// TIFF_MetaHandler::ProcessXMP\n", "target": 1, "idx": 178168}
{"func": "Vector<GLuint> WebGL2RenderingContextBase::getUniformIndices(\n    WebGLProgram* program,\n    const Vector<String>& uniform_names) {\n  Vector<GLuint> result;\n  if (isContextLost() || !ValidateWebGLObject(\"getUniformIndices\", program))\n    return result;\n\n  Vector<CString> keep_alive;  // Must keep these instances alive while looking\n  Vector<const char*> uniform_strings;\n  for (size_t i = 0; i < uniform_names.size(); ++i) {\n    keep_alive.push_back(uniform_names[i].Ascii());\n    uniform_strings.push_back(keep_alive.back().data());\n  }\n\n  result.resize(uniform_names.size());\n  ContextGL()->GetUniformIndices(ObjectOrZero(program), uniform_strings.size(),\n                                 uniform_strings.data(), result.data());\n  return result;\n}\n", "target": 0, "idx": 146110}
{"func": "do_setup_env(Session *s, const char *shell)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\tchar buf[256];\n\tu_int i, envsize;\n\tchar **env, *laddr;\n\tstruct passwd *pw = s->pw;\n#if !defined (HAVE_LOGIN_CAP) && !defined (HAVE_CYGWIN)\n\tchar *path = NULL;\n#endif\n\n\t/* Initialize the environment. */\n\tenvsize = 100;\n\tenv = xcalloc(envsize, sizeof(char *));\n\tenv[0] = NULL;\n\n#ifdef HAVE_CYGWIN\n\t/*\n\t * The Windows environment contains some setting which are\n\t * important for a running system. They must not be dropped.\n\t */\n\t{\n\t\tchar **p;\n\n\t\tp = fetch_windows_environment();\n\t\tcopy_environment(p, &env, &envsize);\n\t\tfree_windows_environment(p);\n\t}\n#endif\n\n#ifdef GSSAPI\n\t/* Allow any GSSAPI methods that we've used to alter\n\t * the childs environment as they see fit\n\t */\n\tssh_gssapi_do_child(&env, &envsize);\n#endif\n\n\tif (!options.use_login) {\n\t\t/* Set basic environment. */\n\t\tfor (i = 0; i < s->num_env; i++)\n\t\t\tchild_set_env(&env, &envsize, s->env[i].name,\n\t\t\t    s->env[i].val);\n\n\t\tchild_set_env(&env, &envsize, \"USER\", pw->pw_name);\n\t\tchild_set_env(&env, &envsize, \"LOGNAME\", pw->pw_name);\n#ifdef _AIX\n\t\tchild_set_env(&env, &envsize, \"LOGIN\", pw->pw_name);\n#endif\n\t\tchild_set_env(&env, &envsize, \"HOME\", pw->pw_dir);\n#ifdef HAVE_LOGIN_CAP\n\t\tif (setusercontext(lc, pw, pw->pw_uid, LOGIN_SETPATH) < 0)\n\t\t\tchild_set_env(&env, &envsize, \"PATH\", _PATH_STDPATH);\n\t\telse\n\t\t\tchild_set_env(&env, &envsize, \"PATH\", getenv(\"PATH\"));\n#else /* HAVE_LOGIN_CAP */\n# ifndef HAVE_CYGWIN\n\t\t/*\n\t\t * There's no standard path on Windows. The path contains\n\t\t * important components pointing to the system directories,\n\t\t * needed for loading shared libraries. So the path better\n\t\t * remains intact here.\n\t\t */\n#  ifdef HAVE_ETC_DEFAULT_LOGIN\n\t\tread_etc_default_login(&env, &envsize, pw->pw_uid);\n\t\tpath = child_get_env(env, \"PATH\");\n#  endif /* HAVE_ETC_DEFAULT_LOGIN */\n\t\tif (path == NULL || *path == '\\0') {\n\t\t\tchild_set_env(&env, &envsize, \"PATH\",\n\t\t\t    s->pw->pw_uid == 0 ?\n\t\t\t\tSUPERUSER_PATH : _PATH_STDPATH);\n\t\t}\n# endif /* HAVE_CYGWIN */\n#endif /* HAVE_LOGIN_CAP */\n\n\t\tsnprintf(buf, sizeof buf, \"%.200s/%.50s\",\n\t\t\t _PATH_MAILDIR, pw->pw_name);\n\t\tchild_set_env(&env, &envsize, \"MAIL\", buf);\n\n\t\t/* Normal systems set SHELL by default. */\n\t\tchild_set_env(&env, &envsize, \"SHELL\", shell);\n\t}\n\tif (getenv(\"TZ\"))\n\t\tchild_set_env(&env, &envsize, \"TZ\", getenv(\"TZ\"));\n\n\t/* Set custom environment options from RSA authentication. */\n\tif (!options.use_login) {\n\t\twhile (custom_environment) {\n\t\t\tstruct envstring *ce = custom_environment;\n\t\t\tchar *str = ce->s;\n\n\t\t\tfor (i = 0; str[i] != '=' && str[i]; i++)\n\t\t\t\t;\n\t\t\tif (str[i] == '=') {\n\t\t\t\tstr[i] = 0;\n\t\t\t\tchild_set_env(&env, &envsize, str, str + i + 1);\n\t\t\t}\n\t\t\tcustom_environment = ce->next;\n\t\t\tfree(ce->s);\n\t\t\tfree(ce);\n\t\t}\n\t}\n\n\t/* SSH_CLIENT deprecated */\n\tsnprintf(buf, sizeof buf, \"%.50s %d %d\",\n\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),\n\t    ssh_local_port(ssh));\n\tchild_set_env(&env, &envsize, \"SSH_CLIENT\", buf);\n\n\tladdr = get_local_ipaddr(packet_get_connection_in());\n\tsnprintf(buf, sizeof buf, \"%.50s %d %.50s %d\",\n\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh),\n\t    laddr, ssh_local_port(ssh));\n\tfree(laddr);\n\tchild_set_env(&env, &envsize, \"SSH_CONNECTION\", buf);\n\n\tif (s->ttyfd != -1)\n\t\tchild_set_env(&env, &envsize, \"SSH_TTY\", s->tty);\n\tif (s->term)\n\t\tchild_set_env(&env, &envsize, \"TERM\", s->term);\n\tif (s->display)\n\t\tchild_set_env(&env, &envsize, \"DISPLAY\", s->display);\n\tif (original_command)\n\t\tchild_set_env(&env, &envsize, \"SSH_ORIGINAL_COMMAND\",\n\t\t    original_command);\n\n#ifdef _UNICOS\n\tif (cray_tmpdir[0] != '\\0')\n\t\tchild_set_env(&env, &envsize, \"TMPDIR\", cray_tmpdir);\n#endif /* _UNICOS */\n\n\t/*\n\t * Since we clear KRB5CCNAME at startup, if it's set now then it\n\t * must have been set by a native authentication method (eg AIX or\n\t * SIA), so copy it to the child.\n\t */\n\t{\n\t\tchar *cp;\n\n\t\tif ((cp = getenv(\"KRB5CCNAME\")) != NULL)\n\t\t\tchild_set_env(&env, &envsize, \"KRB5CCNAME\", cp);\n\t}\n\n#ifdef _AIX\n\t{\n\t\tchar *cp;\n\n\t\tif ((cp = getenv(\"AUTHSTATE\")) != NULL)\n\t\t\tchild_set_env(&env, &envsize, \"AUTHSTATE\", cp);\n\t\tread_environment_file(&env, &envsize, \"/etc/environment\");\n\t}\n#endif\n#ifdef KRB5\n\tif (s->authctxt->krb5_ccname)\n\t\tchild_set_env(&env, &envsize, \"KRB5CCNAME\",\n\t\t    s->authctxt->krb5_ccname);\n#endif\n#ifdef USE_PAM\n\t/*\n \t * Pull in any environment variables that may have\n \t * been set by PAM.\n \t */\n\tif (options.use_pam) {\n \t\tchar **p;\n \n \t\tp = fetch_pam_child_environment();\n\t\tcopy_environment(p, &env, &envsize);\n\t\tfree_pam_environment(p);\n\n\t\tp = fetch_pam_environment();\n\t\tcopy_environment(p, &env, &envsize);\n\t\tfree_pam_environment(p);\n\t}\n#endif /* USE_PAM */\n\n\tif (auth_sock_name != NULL)\n\t\tchild_set_env(&env, &envsize, SSH_AUTHSOCKET_ENV_NAME,\n\t\t    auth_sock_name);\n\n\t/* read $HOME/.ssh/environment. */\n\tif (options.permit_user_env && !options.use_login) {\n\t\tsnprintf(buf, sizeof buf, \"%.200s/.ssh/environment\",\n\t\t    strcmp(pw->pw_dir, \"/\") ? pw->pw_dir : \"\");\n\t\tread_environment_file(&env, &envsize, buf);\n\t}\n\tif (debug_flag) {\n\t\t/* dump the environment */\n\t\tfprintf(stderr, \"Environment:\\n\");\n\t\tfor (i = 0; env[i]; i++)\n\t\t\tfprintf(stderr, \"  %.200s\\n\", env[i]);\n\t}\n\treturn env;\n}\n", "target": 1, "idx": 178455}
{"func": "long Cluster::CreateBlock(\n    long long id,\n    long long pos,   //absolute pos of payload\n    long long size,\n    long long discard_padding)\n{\n    assert((id == 0x20) || (id == 0x23));  //BlockGroup or SimpleBlock\n    if (m_entries_count < 0)  //haven't parsed anything yet\n    {\n        assert(m_entries == NULL);\n        assert(m_entries_size == 0);\n        m_entries_size = 1024;\n        m_entries = new BlockEntry*[m_entries_size];\n        m_entries_count = 0;\n    }\n    else\n    {\n        assert(m_entries);\n        assert(m_entries_size > 0);\n        assert(m_entries_count <= m_entries_size);\n        if (m_entries_count >= m_entries_size)\n        {\n            const long entries_size = 2 * m_entries_size;\n            BlockEntry** const entries = new BlockEntry*[entries_size];\n            assert(entries);\n            BlockEntry** src = m_entries;\n            BlockEntry** const src_end = src + m_entries_count;\n            BlockEntry** dst = entries;\n            while (src != src_end)\n                *dst++ = *src++;\n            delete[] m_entries;\n            m_entries = entries;\n            m_entries_size = entries_size;\n        }\n     }\n \n    if (id == 0x20)  //BlockGroup ID\n        return CreateBlockGroup(pos, size, discard_padding);\n    else  //SimpleBlock ID\n        return CreateSimpleBlock(pos, size);\n }\n", "target": 1, "idx": 188279}
{"func": "int git_delta_apply(\n\tvoid **out,\n\tsize_t *out_len,\n\tconst unsigned char *base,\n\tsize_t base_len,\n\tconst unsigned char *delta,\n\tsize_t delta_len)\n{\n\tconst unsigned char *delta_end = delta + delta_len;\n\tsize_t base_sz, res_sz, alloc_sz;\n\tunsigned char *res_dp;\n\n\t*out = NULL;\n\t*out_len = 0;\n\n\t/*\n\t * Check that the base size matches the data we were given;\n\t * if not we would underflow while accessing data from the\n\t * base object, resulting in data corruption or segfault.\n\t */\n\tif ((hdr_sz(&base_sz, &delta, delta_end) < 0) || (base_sz != base_len)) {\n\t\tgiterr_set(GITERR_INVALID, \"failed to apply delta: base size does not match given data\");\n\t\treturn -1;\n\t}\n\n\tif (hdr_sz(&res_sz, &delta, delta_end) < 0) {\n\t\tgiterr_set(GITERR_INVALID, \"failed to apply delta: base size does not match given data\");\n\t\treturn -1;\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_sz, res_sz, 1);\n\tres_dp = git__malloc(alloc_sz);\n\tGITERR_CHECK_ALLOC(res_dp);\n\n\tres_dp[res_sz] = '\\0';\n\t*out = res_dp;\n\t*out_len = res_sz;\n\n\twhile (delta < delta_end) {\n\t\tunsigned char cmd = *delta++;\n\t\tif (cmd & 0x80) {\n \t\t\t/* cmd is a copy instruction; copy from the base. */\n \t\t\tsize_t off = 0, len = 0;\n \n\t\t\tif (cmd & 0x01) off = *delta++;\n\t\t\tif (cmd & 0x02) off |= *delta++ << 8UL;\n\t\t\tif (cmd & 0x04) off |= *delta++ << 16UL;\n\t\t\tif (cmd & 0x08) off |= ((unsigned) *delta++ << 24UL);\n\t\t\tif (cmd & 0x10) len = *delta++;\n\t\t\tif (cmd & 0x20) len |= *delta++ << 8UL;\n\t\t\tif (cmd & 0x40) len |= *delta++ << 16UL;\n \t\t\tif (!len)       len = 0x10000;\n \n \t\t\tif (base_len < off + len || res_sz < len)\n \t\t\t\tgoto fail;\n\t\t\tmemcpy(res_dp, base + off, len);\n\t\t\tres_dp += len;\n\t\t\tres_sz -= len;\n\n\t\t} else if (cmd) {\n\t\t\t/*\n\t\t\t * cmd is a literal insert instruction; copy from\n\t\t\t * the delta stream itself.\n\t\t\t */\n\t\t\tif (delta_end - delta < cmd || res_sz < cmd)\n\t\t\t\tgoto fail;\n\t\t\tmemcpy(res_dp, delta, cmd);\n\t\t\tdelta += cmd;\n\t\t\tres_dp += cmd;\n\t\t\tres_sz -= cmd;\n\n\t\t} else {\n\t\t\t/* cmd == 0 is reserved for future encodings. */\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (delta != delta_end || res_sz)\n\t\tgoto fail;\n\treturn 0;\n\nfail:\n\tgit__free(*out);\n\n\t*out = NULL;\n\t*out_len = 0;\n\n\tgiterr_set(GITERR_INVALID, \"failed to apply delta\");\n\treturn -1;\n}\n", "target": 1, "idx": 182416}
{"func": "static int sysMapFD(int fd, MemMapping* pMap)\n{\n off_t start;\n size_t length;\n void* memPtr;\n\n    assert(pMap != NULL);\n\n if (getFileStartAndLength(fd, &start, &length) < 0)\n return -1;\n\n    memPtr = mmap(NULL, length, PROT_READ, MAP_PRIVATE, fd, start);\n if (memPtr == MAP_FAILED) {\n        LOGW(\"mmap(%d, R, PRIVATE, %d, %d) failed: %s\\n\", (int) length,\n            fd, (int) start, strerror(errno));\n return -1;\n }\n\n    pMap->addr = memPtr;\n\n     pMap->length = length;\n     pMap->range_count = 1;\n     pMap->ranges = malloc(sizeof(MappedRange));\n     pMap->ranges[0].addr = memPtr;\n     pMap->ranges[0].length = length;\n \n return 0;\n}\n", "target": 1, "idx": 187926}
{"func": "void WebContentsImpl::UpdateRenderViewSizeForRenderManager(bool is_main_frame) {\n  gfx::Size size = GetSizeForNewRenderView(is_main_frame);\n  if (!size.IsEmpty())\n    view_->SizeContents(size);\n}\n", "target": 0, "idx": 157878}
{"func": "void WorkerProcessLauncher::Core::Send(IPC::Message* message) {\n  DCHECK(caller_task_runner_->BelongsToCurrentThread());\n\n  if (ipc_enabled_) {\n    launcher_delegate_->Send(message);\n  } else {\n    delete message;\n  }\n}\n", "target": 0, "idx": 127228}
{"func": "static void ept_set_mmio_spte_mask(void)\n{\n\t/*\n\t * EPT Misconfigurations can be generated if the value of bits 2:0\n\t * of an EPT paging-structure entry is 110b (write/execute).\n\t * Also, magic bits (0x3ull << 62) is set to quickly identify mmio\n\t * spte.\n\t */\n\tkvm_mmu_set_mmio_spte_mask((0x3ull << 62) | 0x6ull);\n}\n", "target": 0, "idx": 37041}
{"func": "void skb_queue_tail(struct sk_buff_head *list, struct sk_buff *newsk)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&list->lock, flags);\n\t__skb_queue_tail(list, newsk);\n\tspin_unlock_irqrestore(&list->lock, flags);\n}\n", "target": 0, "idx": 39914}
{"func": "static int proc_control_compat(struct usb_dev_state *ps,\n\t\t\t\tstruct usbdevfs_ctrltransfer32 __user *p32)\n{\n\tstruct usbdevfs_ctrltransfer __user *p;\n\t__u32 udata;\n\tp = compat_alloc_user_space(sizeof(*p));\n\tif (copy_in_user(p, p32, (sizeof(*p32) - sizeof(compat_caddr_t))) ||\n\t    get_user(udata, &p32->data) ||\n\t    put_user(compat_ptr(udata), &p->data))\n\t\treturn -EFAULT;\n\treturn proc_control(ps, p);\n}\n", "target": 0, "idx": 53219}
{"func": "analyze_stack(int cpu, struct task_struct *task, unsigned long *stack,\n\t      unsigned long **stack_end, unsigned long *irq_stack,\n\t      unsigned *used, char **id)\n{\n\tunsigned long addr;\n\n\taddr = ((unsigned long)stack & (~(THREAD_SIZE - 1)));\n\tif ((unsigned long)task_stack_page(task) == addr)\n\t\treturn STACK_IS_NORMAL;\n\n\t*stack_end = in_exception_stack(cpu, (unsigned long)stack,\n\t\t\t\t\tused, id);\n\tif (*stack_end)\n\t\treturn STACK_IS_EXCEPTION;\n\n\tif (!irq_stack)\n\t\treturn STACK_IS_NORMAL;\n\n\t*stack_end = irq_stack;\n\tirq_stack = irq_stack - irq_stack_size;\n\n\tif (in_irq_stack(stack, irq_stack, *stack_end))\n\t\treturn STACK_IS_IRQ;\n\n\treturn STACK_IS_UNKNOWN;\n}\n", "target": 0, "idx": 35399}
{"func": "void SoftMP3::onQueueFilled(OMX_U32 /* portIndex */) {\n if (mSignalledError || mOutputPortSettingsChange != NONE) {\n return;\n }\n\n List<BufferInfo *> &inQueue = getPortQueue(0);\n List<BufferInfo *> &outQueue = getPortQueue(1);\n\n while ((!inQueue.empty() || (mSawInputEos && !mSignalledOutputEos)) && !outQueue.empty()) {\n BufferInfo *inInfo = NULL;\n        OMX_BUFFERHEADERTYPE *inHeader = NULL;\n if (!inQueue.empty()) {\n            inInfo = *inQueue.begin();\n            inHeader = inInfo->mHeader;\n }\n\n BufferInfo *outInfo = *outQueue.begin();\n        OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;\n        outHeader->nFlags = 0;\n\n if (inHeader) {\n if (inHeader->nOffset == 0 && inHeader->nFilledLen) {\n                mAnchorTimeUs = inHeader->nTimeStamp;\n                mNumFramesOutput = 0;\n }\n\n if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {\n                mSawInputEos = true;\n }\n\n            mConfig->pInputBuffer =\n                inHeader->pBuffer + inHeader->nOffset;\n\n            mConfig->inputBufferCurrentLength = inHeader->nFilledLen;\n } else {\n            mConfig->pInputBuffer = NULL;\n            mConfig->inputBufferCurrentLength = 0;\n }\n        mConfig->inputBufferMaxLength = 0;\n\n         mConfig->inputBufferUsedLength = 0;\n \n         mConfig->outputFrameSize = kOutputBufferSize / sizeof(int16_t);\n \n         mConfig->pOutputBuffer =\n             reinterpret_cast<int16_t *>(outHeader->pBuffer);\n\n        ERROR_CODE decoderErr;\n if ((decoderErr = pvmp3_framedecoder(mConfig, mDecoderBuf))\n != NO_DECODING_ERROR) {\n            ALOGV(\"mp3 decoder returned error %d\", decoderErr);\n\n if (decoderErr != NO_ENOUGH_MAIN_DATA_ERROR\n && decoderErr != SIDE_INFO_ERROR) {\n                ALOGE(\"mp3 decoder returned error %d\", decoderErr);\n\n                notify(OMX_EventError, OMX_ErrorUndefined, decoderErr, NULL);\n                mSignalledError = true;\n return;\n }\n\n if (mConfig->outputFrameSize == 0) {\n                mConfig->outputFrameSize = kOutputBufferSize / sizeof(int16_t);\n }\n\n if (decoderErr == NO_ENOUGH_MAIN_DATA_ERROR && mSawInputEos) {\n if (!mIsFirst) {\n                    outHeader->nOffset = 0;\n                    outHeader->nFilledLen = kPVMP3DecoderDelay * mNumChannels * sizeof(int16_t);\n\n                    memset(outHeader->pBuffer, 0, outHeader->nFilledLen);\n }\n                outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n                mSignalledOutputEos = true;\n } else {\n\n                ALOGV_IF(mIsFirst, \"insufficient data for first frame, sending silence\");\n                memset(outHeader->pBuffer,\n 0,\n                       mConfig->outputFrameSize * sizeof(int16_t));\n\n if (inHeader) {\n                    mConfig->inputBufferUsedLength = inHeader->nFilledLen;\n }\n }\n } else if (mConfig->samplingRate != mSamplingRate\n || mConfig->num_channels != mNumChannels) {\n            mSamplingRate = mConfig->samplingRate;\n            mNumChannels = mConfig->num_channels;\n\n            notify(OMX_EventPortSettingsChanged, 1, 0, NULL);\n            mOutputPortSettingsChange = AWAITING_DISABLED;\n return;\n }\n\n if (mIsFirst) {\n            mIsFirst = false;\n            outHeader->nOffset =\n                kPVMP3DecoderDelay * mNumChannels * sizeof(int16_t);\n\n            outHeader->nFilledLen =\n                mConfig->outputFrameSize * sizeof(int16_t) - outHeader->nOffset;\n } else if (!mSignalledOutputEos) {\n            outHeader->nOffset = 0;\n            outHeader->nFilledLen = mConfig->outputFrameSize * sizeof(int16_t);\n }\n\n        outHeader->nTimeStamp =\n            mAnchorTimeUs + (mNumFramesOutput * 1000000ll) / mSamplingRate;\n\n if (inHeader) {\n            CHECK_GE(inHeader->nFilledLen, mConfig->inputBufferUsedLength);\n\n            inHeader->nOffset += mConfig->inputBufferUsedLength;\n            inHeader->nFilledLen -= mConfig->inputBufferUsedLength;\n\n\n if (inHeader->nFilledLen == 0) {\n                inInfo->mOwnedByUs = false;\n                inQueue.erase(inQueue.begin());\n                inInfo = NULL;\n                notifyEmptyBufferDone(inHeader);\n                inHeader = NULL;\n }\n }\n\n        mNumFramesOutput += mConfig->outputFrameSize / mNumChannels;\n\n        outInfo->mOwnedByUs = false;\n        outQueue.erase(outQueue.begin());\n        outInfo = NULL;\n        notifyFillBufferDone(outHeader);\n        outHeader = NULL;\n }\n}\n", "target": 1, "idx": 187799}
{"func": "void ObserverOnLogoAvailable(LogoObserver* observer,\n                             bool from_cache,\n                             LogoCallbackReason type,\n                             const base::Optional<Logo>& logo) {\n  switch (type) {\n    case LogoCallbackReason::DISABLED:\n    case LogoCallbackReason::CANCELED:\n    case LogoCallbackReason::FAILED:\n      break;\n    case LogoCallbackReason::REVALIDATED:\n      break;\n    case LogoCallbackReason::DETERMINED:\n      observer->OnLogoAvailable(logo ? &logo.value() : nullptr, from_cache);\n      break;\n  }\n  if (!from_cache) {\n    observer->OnObserverRemoved();\n  }\n}\n", "target": 1, "idx": 185834}
{"func": "static Position ComputePositionForChildrenRemoval(const Position& position,\n                                                  ContainerNode& container) {\n  Node* node = position.ComputeContainerNode();\n  if (container.ContainsIncludingHostElements(*node))\n    return Position::FirstPositionInNode(container);\n  return position;\n}\n", "target": 0, "idx": 135816}
{"func": "bool MdmEnrollmentEnabled() {\n  base::string16 mdm_url = GetMdmUrl();\n  return !mdm_url.empty();\n}\n", "target": 0, "idx": 142104}
{"func": " static inline ogg_uint32_t decode_packed_entry_number(codebook *book,\n\t\t\t\t\t\t      oggpack_buffer *b){\n   ogg_uint32_t chase=0;\n   int  read=book->dec_maxlength;\n   long lok = oggpack_look(b,read),i;\n\n while(lok<0 && read>1)\n    lok = oggpack_look(b, --read);\n\n if(lok<0){\n    oggpack_adv(b,1); /* force eop */\n return -1;\n }\n\n /* chase the tree with the bits we got */\n switch (book->dec_method)\n {\n case 0:\n {\n /* book->dec_nodeb==1, book->dec_leafw==1 */\n /* 8/8 - Used */\n\n       unsigned char *t=(unsigned char *)book->dec_table;\n \n       for(i=0;i<read;i++){\n\tchase=t[chase*2+((lok>>i)&1)];\n\tif(chase&0x80UL)break;\n       }\n       chase&=0x7fUL;\n       break;\n }\n case 1:\n {\n /* book->dec_nodeb==1, book->dec_leafw!=1 */\n\n       /* 8/16 - Used by infile2 */\n       unsigned char *t=(unsigned char *)book->dec_table;\n       for(i=0;i<read;i++){\n\tint bit=(lok>>i)&1;\n\tint next=t[chase+bit];\n\tif(next&0x80){\n\t  chase= (next<<8) | t[chase+bit+1+(!bit || t[chase]&0x80)];\n\t  break;\n\t}\n\tchase=next;\n       }\n       chase&=~0x8000UL;\n break;\n }\n case 2:\n {\n\n       /* book->dec_nodeb==2, book->dec_leafw==1 */\n       /* 16/16 - Used */\n       for(i=0;i<read;i++){\n\tchase=((ogg_uint16_t *)(book->dec_table))[chase*2+((lok>>i)&1)];\n\tif(chase&0x8000UL)break;\n       }\n       chase&=~0x8000UL;\n break;\n }\n case 3:\n {\n /* book->dec_nodeb==2, book->dec_leafw!=1 */\n\n       /* 16/32 - Used by infile2 */\n       ogg_uint16_t *t=(ogg_uint16_t *)book->dec_table;\n       for(i=0;i<read;i++){\n\tint bit=(lok>>i)&1;\n\tint next=t[chase+bit];\n\tif(next&0x8000){\n\t  chase= (next<<16) | t[chase+bit+1+(!bit || t[chase]&0x8000)];\n\t  break;\n\t}\n\tchase=next;\n       }\n       chase&=~0x80000000UL;\n break;\n }\n case 4:\n\n     {\n       for(i=0;i<read;i++){\n\tchase=((ogg_uint32_t *)(book->dec_table))[chase*2+((lok>>i)&1)];\n\tif(chase&0x80000000UL)break;\n       }\n       chase&=~0x80000000UL;\n break;\n }\n }\n\n if(i<read){\n    oggpack_adv(b,i+1);\n return chase;\n }\n  oggpack_adv(b,read+1);\n return(-1);\n}\n", "target": 1, "idx": 188006}
{"func": "process_open(u_int32_t id)\n{\n\tu_int32_t pflags;\n\tAttrib a;\n\tchar *name;\n\tint r, handle, fd, flags, mode, status = SSH2_FX_FAILURE;\n\n\tif ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0 ||\n\t    (r = sshbuf_get_u32(iqueue, &pflags)) != 0 || /* portable flags */\n\t    (r = decode_attrib(iqueue, &a)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"request %u: open flags %d\", id, pflags);\n\tflags = flags_from_portable(pflags);\n\tmode = (a.flags & SSH2_FILEXFER_ATTR_PERMISSIONS) ? a.perm : 0666;\n \tlogit(\"open \\\"%s\\\" flags %s mode 0%o\",\n \t    name, string_from_portable(pflags), mode);\n \tif (readonly &&\n\t    ((flags & O_ACCMODE) == O_WRONLY ||\n\t    (flags & O_ACCMODE) == O_RDWR)) {\n \t\tverbose(\"Refusing open request in read-only mode\");\n \t\tstatus = SSH2_FX_PERMISSION_DENIED;\n \t} else {\n\t\tfd = open(name, flags, mode);\n\t\tif (fd < 0) {\n\t\t\tstatus = errno_to_portable(errno);\n\t\t} else {\n\t\t\thandle = handle_new(HANDLE_FILE, name, fd, flags, NULL);\n\t\t\tif (handle < 0) {\n\t\t\t\tclose(fd);\n\t\t\t} else {\n\t\t\t\tsend_handle(id, handle);\n\t\t\t\tstatus = SSH2_FX_OK;\n\t\t\t}\n\t\t}\n\t}\n\tif (status != SSH2_FX_OK)\n\t\tsend_status(id, status);\n\tfree(name);\n}\n", "target": 1, "idx": 180887}
{"func": "ZEND_API void ZEND_FASTCALL _zend_hash_init(HashTable *ht, uint32_t nSize, dtor_func_t pDestructor, zend_bool persistent ZEND_FILE_LINE_DC)\n{\n \tGC_REFCOUNT(ht) = 1;\n \tGC_TYPE_INFO(ht) = IS_ARRAY;\n \tht->u.flags = (persistent ? HASH_FLAG_PERSISTENT : 0) | HASH_FLAG_APPLY_PROTECTION | HASH_FLAG_STATIC_KEYS;\n\tht->nTableSize = zend_hash_check_size(nSize);\n \tht->nTableMask = HT_MIN_MASK;\n \tHT_SET_DATA_ADDR(ht, &uninitialized_bucket);\n \tht->nNumUsed = 0;\n \tht->nNumOfElements = 0;\n \tht->nInternalPointer = HT_INVALID_IDX;\n \tht->nNextFreeElement = 0;\n \tht->pDestructor = pDestructor;\n }\n", "target": 1, "idx": 181582}
{"func": "void GfxPatternColorSpace::getRGB(GfxColor *color, GfxRGB *rgb) {\n  rgb->r = rgb->g = rgb->b = 0;\n}\n", "target": 0, "idx": 1070}
{"func": "static int snd_timer_user_open(struct inode *inode, struct file *file)\n{\n\tstruct snd_timer_user *tu;\n\tint err;\n\n\terr = nonseekable_open(inode, file);\n\tif (err < 0)\n\t\treturn err;\n\n\ttu = kzalloc(sizeof(*tu), GFP_KERNEL);\n\tif (tu == NULL)\n \t\treturn -ENOMEM;\n \tspin_lock_init(&tu->qlock);\n \tinit_waitqueue_head(&tu->qchange_sleep);\n\tmutex_init(&tu->tread_sem);\n \ttu->ticks = 1;\n \ttu->queue_size = 128;\n \ttu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),\n\t\t\t    GFP_KERNEL);\n\tif (tu->queue == NULL) {\n\t\tkfree(tu);\n\t\treturn -ENOMEM;\n\t}\n\tfile->private_data = tu;\n\treturn 0;\n}\n", "target": 1, "idx": 180577}
{"func": "int main(int argc, char **argv) {\n int frame_cnt = 0;\n FILE *outfile = NULL;\n vpx_codec_ctx_t codec;\n VpxVideoReader *reader = NULL;\n const VpxVideoInfo *info = NULL;\n const VpxInterface *decoder = NULL;\n\n  exec_name = argv[0];\n\n if (argc != 3)\n    die(\"Invalid number of arguments.\");\n\n  reader = vpx_video_reader_open(argv[1]);\n if (!reader)\n    die(\"Failed to open %s for reading.\", argv[1]);\n\n if (!(outfile = fopen(argv[2], \"wb\")))\n    die(\"Failed to open %s for writing.\", argv[2]);\n\n  info = vpx_video_reader_get_info(reader);\n\n  decoder = get_vpx_decoder_by_fourcc(info->codec_fourcc);\n\n   if (!decoder)\n     die(\"Unknown input codec.\");\n \n  printf(\"Using %s\\n\", vpx_codec_iface_name(decoder->interface()));\n \n  if (vpx_codec_dec_init(&codec, decoder->interface(), NULL, 0))\n     die_codec(&codec, \"Failed to initialize decoder\");\n \n   while (vpx_video_reader_read_frame(reader)) {\n vpx_codec_iter_t iter = NULL;\n vpx_image_t *img = NULL;\n size_t frame_size = 0;\n const unsigned char *frame = vpx_video_reader_get_frame(reader,\n &frame_size);\n if (vpx_codec_decode(&codec, frame, (unsigned int)frame_size, NULL, 0))\n      die_codec(&codec, \"Failed to decode frame\");\n\n while ((img = vpx_codec_get_frame(&codec, &iter)) != NULL) {\n unsigned char digest[16];\n\n      get_image_md5(img, digest);\n      print_md5(outfile, digest);\n      fprintf(outfile, \"  img-%dx%d-%04d.i420\\n\",\n              img->d_w, img->d_h, ++frame_cnt);\n }\n }\n\n  printf(\"Processed %d frames.\\n\", frame_cnt);\n if (vpx_codec_destroy(&codec))\n    die_codec(&codec, \"Failed to destroy codec.\");\n\n  vpx_video_reader_close(reader);\n\n  fclose(outfile);\n return EXIT_SUCCESS;\n}\n", "target": 1, "idx": 188496}
{"func": "void DistillerNativeJavaScript::BindFunctionToObject(\n    v8::Local<v8::Object> javascript_object,\n    const std::string& name,\n    const base::Callback<Sig> callback) {\n  v8::Isolate* isolate = javascript_object->GetIsolate();\n  javascript_object->Set(\n      gin::StringToSymbol(isolate, name),\n      gin::CreateFunctionTemplate(isolate, callback)->GetFunction());\n }\n", "target": 0, "idx": 129926}
{"func": "static int set_file_offset(stb_vorbis *f, unsigned int loc)\n{\n   #ifndef STB_VORBIS_NO_PUSHDATA_API\n   if (f->push_mode) return 0;\n   #endif\n   f->eof = 0;\n   if (USE_MEMORY(f)) {\n      if (f->stream_start + loc >= f->stream_end || f->stream_start + loc < f->stream_start) {\n         f->stream = f->stream_end;\n         f->eof = 1;\n         return 0;\n      } else {\n         f->stream = f->stream_start + loc;\n         return 1;\n      }\n   }\n   #ifndef STB_VORBIS_NO_STDIO\n   if (loc + f->f_start < loc || loc >= 0x80000000) {\n      loc = 0x7fffffff;\n      f->eof = 1;\n   } else {\n      loc += f->f_start;\n   }\n   if (!fseek(f->f, loc, SEEK_SET))\n      return 1;\n   f->eof = 1;\n   fseek(f->f, f->f_start, SEEK_END);\n   return 0;\n   #endif\n}\n", "target": 0, "idx": 75292}
{"func": " static int kvm_vm_ioctl_set_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)\n {\n \tint start = 0;\n \tu32 prev_legacy, cur_legacy;\n \tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n \tprev_legacy = kvm->arch.vpit->pit_state.flags & KVM_PIT_FLAGS_HPET_LEGACY;\n\tcur_legacy = ps->flags & KVM_PIT_FLAGS_HPET_LEGACY;\n\tif (!prev_legacy && cur_legacy)\n\t\tstart = 1;\n \tmemcpy(&kvm->arch.vpit->pit_state.channels, &ps->channels,\n \t       sizeof(kvm->arch.vpit->pit_state.channels));\n \tkvm->arch.vpit->pit_state.flags = ps->flags;\n\tkvm_pit_load_count(kvm, 0, kvm->arch.vpit->pit_state.channels[0].count, start);\n \tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n \treturn 0;\n }\n", "target": 1, "idx": 180733}
{"func": "INST_HANDLER (lac) {\t// LAC Z, Rd\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\n\t__generic_ld_st (op, \"ram\", 'z', 1, 0, 0, 0);\t// 0: Read (RAMPZ:Z)\n\tESIL_A (\"r%d,0xff,^,&,\", d);\t\t\t// 0: (Z) & ~Rd\n\tESIL_A (\"DUP,r%d,=,\", d);\t\t\t// Rd = [0]\n\t__generic_ld_st (op, \"ram\", 'z', 1, 0, 0, 1);\t// Store in RAM\n}\n", "target": 0, "idx": 82727}
{"func": "xmlXPathNextPrecedingInternal(xmlXPathParserContextPtr ctxt,\n                               xmlNodePtr cur)\n {\n     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);\n    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||\n\t(ctxt->context->node->type == XML_NAMESPACE_DECL))\n\treturn(NULL);\n     if (cur == NULL) {\n         cur = ctxt->context->node;\n         if (cur == NULL)\n             return (NULL);\n         ctxt->ancestor = cur->parent;\n     }\n     if ((cur->prev != NULL) && (cur->prev->type == XML_DTD_NODE))\n\tcur = cur->prev;\n    while (cur->prev == NULL) {\n        cur = cur->parent;\n        if (cur == NULL)\n            return (NULL);\n        if (cur == ctxt->context->doc->children)\n            return (NULL);\n        if (cur != ctxt->ancestor)\n            return (cur);\n        ctxt->ancestor = cur->parent;\n    }\n    cur = cur->prev;\n    while (cur->last != NULL)\n        cur = cur->last;\n    return (cur);\n}\n", "target": 1, "idx": 183429}
{"func": " ieee802_15_4_if_print(netdissect_options *ndo,\n                       const struct pcap_pkthdr *h, const u_char *p)\n {\n \tu_int caplen = h->caplen;\n\tint hdrlen;\n \tuint16_t fc;\n \tuint8_t seq;\n \n \tif (caplen < 3) {\n\t\tND_PRINT((ndo, \"[|802.15.4] %x\", caplen));\n \t\treturn caplen;\n \t}\n \n \tfc = EXTRACT_LE_16BITS(p);\n\thdrlen = extract_header_length(fc);\n \tseq = EXTRACT_LE_8BITS(p + 2);\n \n \tp += 3;\n \tcaplen -= 3;\n \n\tND_PRINT((ndo,\"IEEE 802.15.4 %s packet \", ftypes[fc & 0x7]));\n \tif (ndo->ndo_vflag)\n \t\tND_PRINT((ndo,\"seq %02x \", seq));\n\tif (hdrlen == -1) {\n\t\tND_PRINT((ndo,\"invalid! \"));\n\t\treturn caplen;\n\t}\n\tif (!ndo->ndo_vflag) {\n\t\tp+= hdrlen;\n\t\tcaplen -= hdrlen;\n\t} else {\n\t\tuint16_t panid = 0;\n \n\t\tswitch ((fc >> 10) & 0x3) {\n\t\tcase 0x00:\n \t\t\tND_PRINT((ndo,\"none \"));\n\t\t\tbreak;\n\t\tcase 0x01:\n \t\t\tND_PRINT((ndo,\"reserved destination addressing mode\"));\n\t\t\treturn 0;\n\t\tcase 0x02:\n\t\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\t\tp += 2;\n\t\t\tND_PRINT((ndo,\"%04x:%04x \", panid, EXTRACT_LE_16BITS(p)));\n\t\t\tp += 2;\n\t\t\tbreak;\n\t\tcase 0x03:\n\t\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\t\tp += 2;\n\t\t\tND_PRINT((ndo,\"%04x:%s \", panid, le64addr_string(ndo, p)));\n\t\t\tp += 8;\n\t\t\tbreak;\n \t\t}\n \t\tND_PRINT((ndo,\"< \"));\n \n\t\tswitch ((fc >> 14) & 0x3) {\n\t\tcase 0x00:\n \t\t\tND_PRINT((ndo,\"none \"));\n\t\t\tbreak;\n\t\tcase 0x01:\n \t\t\tND_PRINT((ndo,\"reserved source addressing mode\"));\n\t\t\treturn 0;\n\t\tcase 0x02:\n\t\t\tif (!(fc & (1 << 6))) {\n\t\t\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\t\t\tp += 2;\n \t\t\t}\n\t\t\tND_PRINT((ndo,\"%04x:%04x \", panid, EXTRACT_LE_16BITS(p)));\n \t\t\tp += 2;\n\t\t\tbreak;\n\t\tcase 0x03:\n\t\t\tif (!(fc & (1 << 6))) {\n\t\t\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\t\t\tp += 2;\n \t\t\t}\n                        ND_PRINT((ndo,\"%04x:%s \", panid, le64addr_string(ndo, p)));\n\t\t\tp += 8;\n\t\t\tbreak;\n \t\t}\n\t\tcaplen -= hdrlen;\n \t}\n \n \tif (!ndo->ndo_suppress_default_print)\n \t\tND_DEFAULTPRINT(p, caplen);\n \n\treturn 0;\n }\n", "target": 1, "idx": 183202}
{"func": "bool Textfield::GetTextRange(gfx::Range* range) const {\n  if (!ImeEditingAllowed())\n    return false;\n\n  model_->GetTextRange(range);\n  return true;\n}\n", "target": 0, "idx": 137220}
{"func": "static bool arg_type_is_refcounted(enum bpf_arg_type type)\n{\n\treturn type == ARG_PTR_TO_SOCKET;\n}\n", "target": 0, "idx": 91396}
{"func": "void AutofillManager::OnFormsSeen(const std::vector<FormData>& forms) {\n  bool enabled = IsAutofillEnabled();\n  if (!has_logged_autofill_enabled_) {\n    metric_logger_->LogIsAutofillEnabledAtPageLoad(enabled);\n    has_logged_autofill_enabled_ = true;\n  }\n\n  if (!enabled)\n    return;\n\n  ParseForms(forms);\n}\n", "target": 0, "idx": 105346}
{"func": "xfs_handlereq_to_dentry(\n\tstruct file\t\t*parfilp,\n\txfs_fsop_handlereq_t\t*hreq)\n{\n\treturn xfs_handle_to_dentry(parfilp, hreq->ihandle, hreq->ihandlen);\n}\n", "target": 0, "idx": 36914}
{"func": "static void ext2_put_super (struct super_block * sb)\n{\n\tint db_count;\n\tint i;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n \n \tdquot_disable(sb, -1, DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);\n \n\text2_xattr_put_super(sb);\n \tif (!(sb->s_flags & MS_RDONLY)) {\n \t\tstruct ext2_super_block *es = sbi->s_es;\n \n\t\tspin_lock(&sbi->s_lock);\n\t\tes->s_state = cpu_to_le16(sbi->s_mount_state);\n\t\tspin_unlock(&sbi->s_lock);\n\t\text2_sync_super(sb, es, 1);\n\t}\n\tdb_count = sbi->s_gdb_count;\n\tfor (i = 0; i < db_count; i++)\n\t\tif (sbi->s_group_desc[i])\n\t\t\tbrelse (sbi->s_group_desc[i]);\n\tkfree(sbi->s_group_desc);\n\tkfree(sbi->s_debts);\n\tpercpu_counter_destroy(&sbi->s_freeblocks_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tbrelse (sbi->s_sbh);\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\n\tkfree(sbi);\n}\n", "target": 1, "idx": 183146}
{"func": "void LinkChangeSerializerMarkupAccumulator::appendAttribute(StringBuilder& result, Element* element, const Attribute& attribute, Namespaces* namespaces)\n{\n    if (m_replaceLinks && element->isURLAttribute(attribute) && !element->isJavaScriptURLAttribute(attribute)) {\n        String completeURL = m_document->completeURL(attribute.value());\n        if (m_replaceLinks->contains(completeURL)) {\n            result.append(' ');\n            result.append(attribute.name().toString());\n            result.appendLiteral(\"=\\\"\");\n            if (!m_directoryName.isEmpty()) {\n                result.appendLiteral(\"./\");\n                result.append(m_directoryName);\n                result.append('/');\n            }\n            result.append(m_replaceLinks->get(completeURL));\n            result.appendLiteral(\"\\\"\");\n            return;\n        }\n    }\n    MarkupAccumulator::appendAttribute(result, element, attribute, namespaces);\n}\n", "target": 1, "idx": 185268}
{"func": "static int hci_sock_getname(struct socket *sock, struct sockaddr *addr,\n\t\t\t    int *addr_len, int peer)\n{\n\tstruct sockaddr_hci *haddr = (struct sockaddr_hci *) addr;\n\tstruct sock *sk = sock->sk;\n\tstruct hci_dev *hdev = hci_pi(sk)->hdev;\n\n\tBT_DBG(\"sock %p sk %p\", sock, sk);\n\n\tif (!hdev)\n\t\treturn -EBADFD;\n\n\tlock_sock(sk);\n\n \t*addr_len = sizeof(*haddr);\n \thaddr->hci_family = AF_BLUETOOTH;\n \thaddr->hci_dev    = hdev->id;\n \n \trelease_sock(sk);\n \treturn 0;\n}\n", "target": 1, "idx": 183072}
{"func": "void br_mdb_notify(struct net_device *dev, struct net_bridge_port *port,\n\t\t   struct br_ip *group, int type)\n {\n \tstruct br_mdb_entry entry;\n \n \tentry.ifindex = port->dev->ifindex;\n \tentry.addr.proto = group->proto;\n \tentry.addr.u.ip4 = group->u.ip4;\n#if IS_ENABLED(CONFIG_IPV6)\n\tentry.addr.u.ip6 = group->u.ip6;\n#endif\n\t__br_mdb_notify(dev, &entry, type);\n}\n", "target": 1, "idx": 179226}
{"func": "static void __update_nat_bits(struct f2fs_sb_info *sbi, nid_t start_nid,\n\t\t\t\t\t\tstruct page *page)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tunsigned int nat_index = start_nid / NAT_ENTRY_PER_BLOCK;\n\tstruct f2fs_nat_block *nat_blk = page_address(page);\n\tint valid = 0;\n\tint i;\n\n\tif (!enabled_nat_bits(sbi, NULL))\n\t\treturn;\n\n\tfor (i = 0; i < NAT_ENTRY_PER_BLOCK; i++) {\n\t\tif (start_nid == 0 && i == 0)\n\t\t\tvalid++;\n\t\tif (nat_blk->entries[i].block_addr)\n\t\t\tvalid++;\n\t}\n\tif (valid == 0) {\n\t\t__set_bit_le(nat_index, nm_i->empty_nat_bits);\n\t\t__clear_bit_le(nat_index, nm_i->full_nat_bits);\n\t\treturn;\n\t}\n\n\t__clear_bit_le(nat_index, nm_i->empty_nat_bits);\n\tif (valid == NAT_ENTRY_PER_BLOCK)\n\t\t__set_bit_le(nat_index, nm_i->full_nat_bits);\n\telse\n\t\t__clear_bit_le(nat_index, nm_i->full_nat_bits);\n}\n", "target": 0, "idx": 85247}
{"func": " const CuePoint* Cues::GetLast() const {\n  if (m_cue_points == NULL)\n     return NULL;\n \n  if (m_count <= 0)\n    return NULL;\n#if 0\n    LoadCuePoint();  //init cues\n    const size_t count = m_count + m_preload_count;\n    if (count == 0)  //weird\n        return NULL;\n    const size_t index = count - 1;\n    CuePoint* const* const pp = m_cue_points;\n    assert(pp);\n    CuePoint* const pCP = pp[index];\n    assert(pCP);\n    pCP->Load(m_pSegment->m_pReader);\n    assert(pCP->GetTimeCode() >= 0);\n#else\n   const long index = m_count - 1;\n \n   CuePoint* const* const pp = m_cue_points;\n  assert(pp);\n \n   CuePoint* const pCP = pp[index];\n  assert(pCP);\n  assert(pCP->GetTimeCode() >= 0);\n#endif\n \n   return pCP;\n }\n", "target": 1, "idx": 187842}
{"func": "xmlCtxtUseOptions(xmlParserCtxtPtr ctxt, int options)\n{\n   return(xmlCtxtUseOptionsInternal(ctxt, options, NULL));\n}\n", "target": 0, "idx": 59426}
{"func": "void PasswordAutofillAgent::UpdateStateForTextChange(\n    const WebInputElement& element) {\n  if (!element.IsTextField())\n    return;\n  WebInputElement mutable_element = element;  // We need a non-const.\n\n  const base::string16 element_value = element.Value().Utf16();\n  field_data_manager_.UpdateFieldDataMap(element, element_value,\n                                         FieldPropertiesFlags::USER_TYPED);\n\n  ProvisionallySavePassword(element.Form(), element, RESTRICTION_NONE);\n\n  if (element.IsPasswordFieldForAutofill()) {\n    auto iter = password_to_username_.find(element);\n    if (iter != password_to_username_.end()) {\n      web_input_to_password_info_[iter->second].password_was_edited_last = true;\n      mutable_element.SetAutofillState(WebAutofillState::kNotFilled);\n    }\n    GetPasswordManagerDriver()->UserModifiedPasswordField();\n  } else {\n    GetPasswordManagerDriver()->UserModifiedNonPasswordField(\n        element.UniqueRendererFormControlId(), element_value);\n  }\n}\n", "target": 0, "idx": 150343}
{"func": " void PartialMagnificationController::OnWindowDestroying(aura::Window* window) {\n   CloseMagnifierWindow();\n \n   aura::Window* new_root_window = GetCurrentRootWindow();\n   if (new_root_window != window)\n    SwitchTargetRootWindow(new_root_window);\n }\n", "target": 1, "idx": 185517}
{"func": "bool SendNativeKeyEventJSONRequest(\n    AutomationMessageSender* sender,\n    int browser_index,\n    int tab_index,\n    ui::KeyboardCode key_code,\n    int modifiers,\n    std::string* error_msg) {\n  DictionaryValue dict;\n  dict.SetString(\"command\", \"SendOSLevelKeyEventToTab\");\n  dict.SetInteger(\"windex\", browser_index);\n  dict.SetInteger(\"tab_index\", tab_index);\n  dict.SetInteger(\"keyCode\", key_code);\n  dict.SetInteger(\"modifiers\", modifiers);\n  DictionaryValue reply_dict;\n  return SendAutomationJSONRequest(sender, dict, &reply_dict, error_msg);\n}\n", "target": 0, "idx": 105557}
{"func": "bool RenderWidgetHostViewAura::NeedsMouseCapture() {\n#if defined(OS_LINUX) && !defined(OS_CHROMEOS)\n  return NeedsInputGrab();\n#endif\n  return false;\n}\n", "target": 0, "idx": 144938}
{"func": "static int udp_v6_push_pending_frames(struct sock *sk)\n{\n\tstruct sk_buff *skb;\n \tstruct udphdr *uh;\n \tstruct udp_sock  *up = udp_sk(sk);\n \tstruct inet_sock *inet = inet_sk(sk);\n\tstruct flowi6 *fl6 = &inet->cork.fl.u.ip6;\n \tint err = 0;\n \tint is_udplite = IS_UDPLITE(sk);\n \t__wsum csum = 0;\n \n \t/* Grab the skbuff where UDP header space exists. */\n \tif ((skb = skb_peek(&sk->sk_write_queue)) == NULL)\n \t\tgoto out;\n\n\t/*\n\t * Create a UDP header\n\t */\n\tuh = udp_hdr(skb);\n\tuh->source = fl6->fl6_sport;\n\tuh->dest = fl6->fl6_dport;\n\tuh->len = htons(up->len);\n\tuh->check = 0;\n\n\tif (is_udplite)\n\t\tcsum = udplite_csum_outgoing(sk, skb);\n\telse if (skb->ip_summed == CHECKSUM_PARTIAL) { /* UDP hardware csum */\n\t\tudp6_hwcsum_outgoing(sk, skb, &fl6->saddr, &fl6->daddr,\n\t\t\t\t     up->len);\n\t\tgoto send;\n\t} else\n\t\tcsum = udp_csum_outgoing(sk, skb);\n\n\t/* add protocol-dependent pseudo-header */\n\tuh->check = csum_ipv6_magic(&fl6->saddr, &fl6->daddr,\n\t\t\t\t    up->len, fl6->flowi6_proto, csum);\n\tif (uh->check == 0)\n\t\tuh->check = CSUM_MANGLED_0;\n\nsend:\n\terr = ip6_push_pending_frames(sk);\n\tif (err) {\n\t\tif (err == -ENOBUFS && !inet6_sk(sk)->recverr) {\n\t\t\tUDP6_INC_STATS_USER(sock_net(sk),\n\t\t\t\t\t    UDP_MIB_SNDBUFERRORS, is_udplite);\n\t\t\terr = 0;\n\t\t}\n\t} else\n\t\tUDP6_INC_STATS_USER(sock_net(sk),\n\t\t\t\t    UDP_MIB_OUTDATAGRAMS, is_udplite);\nout:\n\tup->len = 0;\n\tup->pending = 0;\n\treturn err;\n}\n", "target": 1, "idx": 179189}
{"func": "void MediaStreamManager::Aborted(MediaStreamType stream_type,\n                                 int capture_session_id) {\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n  DVLOG(1) << \"Aborted({stream_type = \" << stream_type << \"} \"\n           << \"{capture_session_id = \" << capture_session_id << \"})\";\n  StopDevice(stream_type, capture_session_id);\n}\n", "target": 0, "idx": 166191}
{"func": "int GetNetSSLVersion(SSL* ssl) {\n  switch (SSL_version(ssl)) {\n    case SSL2_VERSION:\n      return SSL_CONNECTION_VERSION_SSL2;\n    case SSL3_VERSION:\n      return SSL_CONNECTION_VERSION_SSL3;\n    case TLS1_VERSION:\n      return SSL_CONNECTION_VERSION_TLS1;\n    case 0x0302:\n      return SSL_CONNECTION_VERSION_TLS1_1;\n    case 0x0303:\n      return SSL_CONNECTION_VERSION_TLS1_2;\n    default:\n      return SSL_CONNECTION_VERSION_UNKNOWN;\n  }\n}\n", "target": 0, "idx": 133760}
{"func": "  void CancelUnlockOperation() { cancel_unlock_ = true; }\n", "target": 0, "idx": 133063}
{"func": "bool Vp9Parser::ParseUncompressedHeader(const uint8_t* stream,\n                                        off_t frame_size,\n                                        Vp9FrameHeader* fhdr) {\n  reader_.Initialize(stream, frame_size);\n  fhdr->data = stream;\n  fhdr->frame_size = frame_size;\n \n   if (reader_.ReadLiteral(2) != 0x2)\n    return false;\n\n  fhdr->profile = ReadProfile();\n  if (fhdr->profile >= kVp9MaxProfile) {\n    DVLOG(1) << \"Unsupported bitstream profile\";\n    return false;\n  }\n\n  fhdr->show_existing_frame = reader_.ReadBool();\n  if (fhdr->show_existing_frame) {\n    fhdr->frame_to_show = reader_.ReadLiteral(3);\n    fhdr->show_frame = true;\n\n    if (!reader_.IsValid()) {\n      DVLOG(1) << \"parser reads beyond the end of buffer\";\n      return false;\n    }\n    fhdr->uncompressed_header_size = reader_.GetBytesRead();\n    return true;\n  }\n\n  fhdr->frame_type = static_cast<Vp9FrameHeader::FrameType>(reader_.ReadBool());\n  fhdr->show_frame = reader_.ReadBool();\n  fhdr->error_resilient_mode = reader_.ReadBool();\n\n  if (fhdr->IsKeyframe()) {\n    if (!VerifySyncCode())\n      return false;\n\n     if (!ReadBitDepthColorSpaceSampling(fhdr))\n       return false;\n \n    fhdr->refresh_flags = 0xff;\n \n     ReadFrameSize(fhdr);\n     ReadDisplayFrameSize(fhdr);\n  } else {\n    if (!fhdr->show_frame)\n      fhdr->intra_only = reader_.ReadBool();\n\n    if (!fhdr->error_resilient_mode)\n      fhdr->reset_context = reader_.ReadLiteral(2);\n\n    if (fhdr->intra_only) {\n      if (!VerifySyncCode())\n        return false;\n\n      if (fhdr->profile > 0) {\n        if (!ReadBitDepthColorSpaceSampling(fhdr))\n          return false;\n      } else {\n        fhdr->bit_depth = 8;\n        fhdr->color_space = Vp9ColorSpace::BT_601;\n         fhdr->subsampling_x = fhdr->subsampling_y = 1;\n       }\n \n      fhdr->refresh_flags = reader_.ReadLiteral(8);\n       ReadFrameSize(fhdr);\n       ReadDisplayFrameSize(fhdr);\n     } else {\n      fhdr->refresh_flags = reader_.ReadLiteral(8);\n \n       for (size_t i = 0; i < kVp9NumRefsPerFrame; i++) {\n         fhdr->frame_refs[i] = reader_.ReadLiteral(kVp9NumRefFramesLog2);\n        fhdr->ref_sign_biases[i] = reader_.ReadBool();\n      }\n\n      if (!ReadFrameSizeFromRefs(fhdr))\n        return false;\n      ReadDisplayFrameSize(fhdr);\n\n      fhdr->allow_high_precision_mv = reader_.ReadBool();\n      fhdr->interp_filter = ReadInterpFilter();\n    }\n  }\n\n  if (fhdr->error_resilient_mode) {\n    fhdr->frame_parallel_decoding_mode = true;\n  } else {\n    fhdr->refresh_frame_context = reader_.ReadBool();\n    fhdr->frame_parallel_decoding_mode = reader_.ReadBool();\n  }\n \n   fhdr->frame_context_idx = reader_.ReadLiteral(2);\n \n  if (fhdr->IsKeyframe() || fhdr->intra_only)\n    SetupPastIndependence();\n  ReadLoopFilter();\n   ReadQuantization(&fhdr->quant_params);\n  ReadSegmentation();\n \n   ReadTiles(fhdr);\n \n  fhdr->first_partition_size = reader_.ReadLiteral(16);\n  if (fhdr->first_partition_size == 0) {\n    DVLOG(1) << \"invalid header size\";\n    return false;\n  }\n\n  if (!reader_.IsValid()) {\n    DVLOG(1) << \"parser reads beyond the end of buffer\";\n    return false;\n   }\n   fhdr->uncompressed_header_size = reader_.GetBytesRead();\n \n  SetupSegmentationDequant(fhdr->quant_params);\n  SetupLoopFilter();\n  UpdateSlots(fhdr);\n   return true;\n }\n", "target": 1, "idx": 183534}
{"func": "void Splash::scaleImageYdXd(SplashImageSource src, void *srcData,\n\t\t\t    SplashColorMode srcMode, int nComps,\n\t\t\t    GBool srcAlpha, int srcWidth, int srcHeight,\n\t\t\t    int scaledWidth, int scaledHeight,\n\t\t\t    SplashBitmap *dest) {\n  Guchar *lineBuf, *alphaLineBuf;\n  Guint *pixBuf, *alphaPixBuf;\n  Guint pix0, pix1, pix2;\n#if SPLASH_CMYK\n  Guint pix3;\n  Guint pix[SPOT_NCOMPS+4], cp;\n#endif\n  Guint alpha;\n  Guchar *destPtr, *destAlphaPtr;\n  int yp, yq, xp, xq, yt, y, yStep, xt, x, xStep, xx, xxa, d, d0, d1;\n  int i, j;\n\n  yp = srcHeight / scaledHeight;\n  yq = srcHeight % scaledHeight;\n\n  xp = srcWidth / scaledWidth;\n  xq = srcWidth % scaledWidth;\n\n  lineBuf = (Guchar *)gmallocn(srcWidth, nComps);\n  pixBuf = (Guint *)gmallocn(srcWidth, nComps * sizeof(int));\n  if (srcAlpha) {\n    alphaLineBuf = (Guchar *)gmalloc(srcWidth);\n    alphaPixBuf = (Guint *)gmallocn(srcWidth, sizeof(int));\n  } else {\n    alphaLineBuf = NULL;\n    alphaPixBuf = NULL;\n  }\n\n  yt = 0;\n\n  destPtr = dest->data;\n  destAlphaPtr = dest->alpha;\n  for (y = 0; y < scaledHeight; ++y) {\n\n    if ((yt += yq) >= scaledHeight) {\n      yt -= scaledHeight;\n      yStep = yp + 1;\n    } else {\n      yStep = yp;\n    }\n\n    memset(pixBuf, 0, srcWidth * nComps * sizeof(int));\n    if (srcAlpha) {\n      memset(alphaPixBuf, 0, srcWidth * sizeof(int));\n    }\n    for (i = 0; i < yStep; ++i) {\n      (*src)(srcData, lineBuf, alphaLineBuf);\n      for (j = 0; j < srcWidth * nComps; ++j) {\n\tpixBuf[j] += lineBuf[j];\n      }\n      if (srcAlpha) {\n\tfor (j = 0; j < srcWidth; ++j) {\n\t  alphaPixBuf[j] += alphaLineBuf[j];\n\t}\n      }\n    }\n\n    xt = 0;\n    d0 = (1 << 23) / (yStep * xp);\n    d1 = (1 << 23) / (yStep * (xp + 1));\n\n    xx = xxa = 0;\n    for (x = 0; x < scaledWidth; ++x) {\n\n      if ((xt += xq) >= scaledWidth) {\n\txt -= scaledWidth;\n\txStep = xp + 1;\n\td = d1;\n      } else {\n\txStep = xp;\n\td = d0;\n      }\n\n      switch (srcMode) {\n\n      case splashModeMono8:\n\n\tpix0 = 0;\n\tfor (i = 0; i < xStep; ++i) {\n\t  pix0 += pixBuf[xx++];\n\t}\n\tpix0 = (pix0 * d) >> 23;\n\n\t*destPtr++ = (Guchar)pix0;\n\tbreak;\n\n      case splashModeRGB8:\n\n\tpix0 = pix1 = pix2 = 0;\n\tfor (i = 0; i < xStep; ++i) {\n\t  pix0 += pixBuf[xx];\n\t  pix1 += pixBuf[xx+1];\n\t  pix2 += pixBuf[xx+2];\n\t  xx += 3;\n\t}\n\tpix0 = (pix0 * d) >> 23;\n\tpix1 = (pix1 * d) >> 23;\n\tpix2 = (pix2 * d) >> 23;\n\n\t*destPtr++ = (Guchar)pix0;\n\t*destPtr++ = (Guchar)pix1;\n\t*destPtr++ = (Guchar)pix2;\n\tbreak;\n\n      case splashModeXBGR8:\n\n\tpix0 = pix1 = pix2 = 0;\n\tfor (i = 0; i < xStep; ++i) {\n\t  pix0 += pixBuf[xx];\n\t  pix1 += pixBuf[xx+1];\n\t  pix2 += pixBuf[xx+2];\n\t  xx += 4;\n\t}\n\tpix0 = (pix0 * d) >> 23;\n\tpix1 = (pix1 * d) >> 23;\n\tpix2 = (pix2 * d) >> 23;\n\n\t*destPtr++ = (Guchar)pix2;\n\t*destPtr++ = (Guchar)pix1;\n\t*destPtr++ = (Guchar)pix0;\n\t*destPtr++ = (Guchar)255;\n\tbreak;\n\n      case splashModeBGR8:\n\n\tpix0 = pix1 = pix2 = 0;\n\tfor (i = 0; i < xStep; ++i) {\n\t  pix0 += pixBuf[xx];\n\t  pix1 += pixBuf[xx+1];\n\t  pix2 += pixBuf[xx+2];\n\t  xx += 3;\n\t}\n\tpix0 = (pix0 * d) >> 23;\n\tpix1 = (pix1 * d) >> 23;\n\tpix2 = (pix2 * d) >> 23;\n\n\t*destPtr++ = (Guchar)pix2;\n\t*destPtr++ = (Guchar)pix1;\n\t*destPtr++ = (Guchar)pix0;\n\tbreak;\n\n#if SPLASH_CMYK\n      case splashModeCMYK8:\n\n\tpix0 = pix1 = pix2 = pix3 = 0;\n\tfor (i = 0; i < xStep; ++i) {\n\t  pix0 += pixBuf[xx];\n\t  pix1 += pixBuf[xx+1];\n\t  pix2 += pixBuf[xx+2];\n\t  pix3 += pixBuf[xx+3];\n\t  xx += 4;\n\t}\n\tpix0 = (pix0 * d) >> 23;\n\tpix1 = (pix1 * d) >> 23;\n\tpix2 = (pix2 * d) >> 23;\n\tpix3 = (pix3 * d) >> 23;\n\n\t*destPtr++ = (Guchar)pix0;\n\t*destPtr++ = (Guchar)pix1;\n\t*destPtr++ = (Guchar)pix2;\n\t*destPtr++ = (Guchar)pix3;\n\tbreak;\n      case splashModeDeviceN8:\n\n  for (cp = 0; cp < SPOT_NCOMPS+4; cp++)\n    pix[cp] = 0;\n\tfor (i = 0; i < xStep; ++i) {\n    for (cp = 0; cp < SPOT_NCOMPS+4; cp++) {\n      pix[cp] += pixBuf[xx + cp];\n    }\n    xx += (SPOT_NCOMPS+4);\n\t}\n  for (cp = 0; cp < SPOT_NCOMPS+4; cp++)\n    pix[cp] = (pix[cp] * d) >> 23;\n\n  for (cp = 0; cp < SPOT_NCOMPS+4; cp++)\n    *destPtr++ = (Guchar)pix[cp];\n\tbreak;\n#endif\n\n\n      case splashModeMono1: // mono1 is not allowed\n      default:\n\tbreak;\n      }\n\n      if (srcAlpha) {\n\talpha = 0;\n\tfor (i = 0; i < xStep; ++i, ++xxa) {\n\t  alpha += alphaPixBuf[xxa];\n\t}\n\talpha = (alpha * d) >> 23;\n\t*destAlphaPtr++ = (Guchar)alpha;\n      }\n    }\n  }\n\n  gfree(alphaPixBuf);\n  gfree(alphaLineBuf);\n  gfree(pixBuf);\n  gfree(lineBuf);\n}\n", "target": 0, "idx": 4134}
{"func": "static int nl80211_valid_4addr(struct cfg80211_registered_device *rdev,\n\t\t\t       struct net_device *netdev, u8 use_4addr,\n\t\t\t       enum nl80211_iftype iftype)\n{\n\tif (!use_4addr) {\n\t\tif (netdev && (netdev->priv_flags & IFF_BRIDGE_PORT))\n\t\t\treturn -EBUSY;\n\t\treturn 0;\n\t}\n\n\tswitch (iftype) {\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tif (rdev->wiphy.flags & WIPHY_FLAG_4ADDR_AP)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (rdev->wiphy.flags & WIPHY_FLAG_4ADDR_STATION)\n\t\t\treturn 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n", "target": 0, "idx": 26781}
{"func": "encode_UNROLL_XLATE(const struct ofpact_unroll_xlate *unroll OVS_UNUSED,\n                    enum ofp_version ofp_version OVS_UNUSED,\n                    struct ofpbuf *out OVS_UNUSED)\n{\n    OVS_NOT_REACHED();\n}\n", "target": 0, "idx": 76908}
{"func": "static int jpeg_size(unsigned char* data, unsigned int data_size,\n                     int *width, int *height)\n{\n    int i = 0;\n    if (i + 3 < data_size && data[i] == 0xFF && data[i+1] == 0xD8 &&\n            data[i+2] == 0xFF && data[i+3] == 0xE0) {\n        i += 4;\n        if(i + 6 < data_size &&\n                data[i+2] == 'J' && data[i+3] == 'F' && data[i+4] == 'I' &&\n                data[i+5] == 'F' && data[i+6] == 0x00) {\n            unsigned short block_length = data[i] * 256 + data[i+1];\n            while(i<data_size) {\n                i+=block_length;\n                if((i + 1) >= data_size)\n                    return -1;\n                if(data[i] != 0xFF)\n                    return -1;\n                if(data[i+1] == 0xC0) {\n                    *height = data[i+5]*256 + data[i+6];\n                    *width = data[i+7]*256 + data[i+8];\n                     return 0;\n                 }\n                 i+=2;\n                block_length = data[i] * 256 + data[i+1];\n             }\n         }\n     }\n\n    return -1;\n}\n", "target": 1, "idx": 182407}
{"func": "static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env,\n\t\t\t\t      struct bpf_insn *insn,\n\t\t\t\t      struct bpf_reg_state *dst_reg,\n\t\t\t\t      struct bpf_reg_state src_reg)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tu8 opcode = BPF_OP(insn->code);\n\tbool src_known, dst_known;\n\ts64 smin_val, smax_val;\n\tu64 umin_val, umax_val;\n \n \tif (BPF_CLASS(insn->code) != BPF_ALU64) {\n \t\t/* 32-bit ALU ops are (32,32)->64 */\n\t\tcoerce_reg_to_32(dst_reg);\n\t\tcoerce_reg_to_32(&src_reg);\n \t}\n \tsmin_val = src_reg.smin_value;\n \tsmax_val = src_reg.smax_value;\n\tumin_val = src_reg.umin_value;\n\tumax_val = src_reg.umax_value;\n\tsrc_known = tnum_is_const(src_reg.var_off);\n\tdst_known = tnum_is_const(dst_reg->var_off);\n\n\tswitch (opcode) {\n\tcase BPF_ADD:\n\t\tif (signed_add_overflows(dst_reg->smin_value, smin_val) ||\n\t\t    signed_add_overflows(dst_reg->smax_value, smax_val)) {\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value += smin_val;\n\t\t\tdst_reg->smax_value += smax_val;\n\t\t}\n\t\tif (dst_reg->umin_value + umin_val < umin_val ||\n\t\t    dst_reg->umax_value + umax_val < umax_val) {\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\tdst_reg->umin_value += umin_val;\n\t\t\tdst_reg->umax_value += umax_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_add(dst_reg->var_off, src_reg.var_off);\n\t\tbreak;\n\tcase BPF_SUB:\n\t\tif (signed_sub_overflows(dst_reg->smin_value, smax_val) ||\n\t\t    signed_sub_overflows(dst_reg->smax_value, smin_val)) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value -= smax_val;\n\t\t\tdst_reg->smax_value -= smin_val;\n\t\t}\n\t\tif (dst_reg->umin_value < umax_val) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\t/* Cannot overflow (as long as bounds are consistent) */\n\t\t\tdst_reg->umin_value -= umax_val;\n\t\t\tdst_reg->umax_value -= umin_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_sub(dst_reg->var_off, src_reg.var_off);\n\t\tbreak;\n\tcase BPF_MUL:\n\t\tdst_reg->var_off = tnum_mul(dst_reg->var_off, src_reg.var_off);\n\t\tif (smin_val < 0 || dst_reg->smin_value < 0) {\n\t\t\t/* Ain't nobody got time to multiply that sign */\n\t\t\t__mark_reg_unbounded(dst_reg);\n\t\t\t__update_reg_bounds(dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* Both values are positive, so we can work with unsigned and\n\t\t * copy the result to signed (unless it exceeds S64_MAX).\n\t\t */\n\t\tif (umax_val > U32_MAX || dst_reg->umax_value > U32_MAX) {\n\t\t\t/* Potential overflow, we know nothing */\n\t\t\t__mark_reg_unbounded(dst_reg);\n\t\t\t/* (except what we can learn from the var_off) */\n\t\t\t__update_reg_bounds(dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\tdst_reg->umin_value *= umin_val;\n\t\tdst_reg->umax_value *= umax_val;\n\t\tif (dst_reg->umax_value > S64_MAX) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\tbreak;\n\tcase BPF_AND:\n\t\tif (src_known && dst_known) {\n\t\t\t__mark_reg_known(dst_reg, dst_reg->var_off.value &\n\t\t\t\t\t\t  src_reg.var_off.value);\n\t\t\tbreak;\n\t\t}\n\t\t/* We get our minimum from the var_off, since that's inherently\n\t\t * bitwise.  Our maximum is the minimum of the operands' maxima.\n\t\t */\n\t\tdst_reg->var_off = tnum_and(dst_reg->var_off, src_reg.var_off);\n\t\tdst_reg->umin_value = dst_reg->var_off.value;\n\t\tdst_reg->umax_value = min(dst_reg->umax_value, umax_val);\n\t\tif (dst_reg->smin_value < 0 || smin_val < 0) {\n\t\t\t/* Lose signed bounds when ANDing negative numbers,\n\t\t\t * ain't nobody got time for that.\n\t\t\t */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\t/* ANDing two positives gives a positive, so safe to\n\t\t\t * cast result into s64.\n\t\t\t */\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_OR:\n\t\tif (src_known && dst_known) {\n\t\t\t__mark_reg_known(dst_reg, dst_reg->var_off.value |\n\t\t\t\t\t\t  src_reg.var_off.value);\n\t\t\tbreak;\n\t\t}\n\t\t/* We get our maximum from the var_off, and our minimum is the\n\t\t * maximum of the operands' minima\n\t\t */\n\t\tdst_reg->var_off = tnum_or(dst_reg->var_off, src_reg.var_off);\n\t\tdst_reg->umin_value = max(dst_reg->umin_value, umin_val);\n\t\tdst_reg->umax_value = dst_reg->var_off.value |\n\t\t\t\t      dst_reg->var_off.mask;\n\t\tif (dst_reg->smin_value < 0 || smin_val < 0) {\n\t\t\t/* Lose signed bounds when ORing negative numbers,\n\t\t\t * ain't nobody got time for that.\n\t\t\t */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\t/* ORing two positives gives a positive, so safe to\n\t\t\t * cast result into s64.\n\t\t\t */\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_LSH:\n\t\tif (umax_val > 63) {\n\t\t\t/* Shifts greater than 63 are undefined.  This includes\n\t\t\t * shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* We lose all sign bit information (except what we can pick\n\t\t * up from var_off)\n\t\t */\n\t\tdst_reg->smin_value = S64_MIN;\n\t\tdst_reg->smax_value = S64_MAX;\n\t\t/* If we might shift our top bit out, then we know nothing */\n\t\tif (dst_reg->umax_value > 1ULL << (63 - umax_val)) {\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\tdst_reg->umin_value <<= umin_val;\n\t\t\tdst_reg->umax_value <<= umax_val;\n\t\t}\n\t\tif (src_known)\n\t\t\tdst_reg->var_off = tnum_lshift(dst_reg->var_off, umin_val);\n\t\telse\n\t\t\tdst_reg->var_off = tnum_lshift(tnum_unknown, umin_val);\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_RSH:\n\t\tif (umax_val > 63) {\n\t\t\t/* Shifts greater than 63 are undefined.  This includes\n\t\t\t * shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* BPF_RSH is an unsigned shift.  If the value in dst_reg might\n\t\t * be negative, then either:\n\t\t * 1) src_reg might be zero, so the sign bit of the result is\n\t\t *    unknown, so we lose our signed bounds\n\t\t * 2) it's known negative, thus the unsigned bounds capture the\n\t\t *    signed bounds\n\t\t * 3) the signed bounds cross zero, so they tell us nothing\n\t\t *    about the result\n\t\t * If the value in dst_reg is known nonnegative, then again the\n\t\t * unsigned bounts capture the signed bounds.\n\t\t * Thus, in all cases it suffices to blow away our signed bounds\n\t\t * and rely on inferring new ones from the unsigned bounds and\n\t\t * var_off of the result.\n\t\t */\n\t\tdst_reg->smin_value = S64_MIN;\n\t\tdst_reg->smax_value = S64_MAX;\n\t\tif (src_known)\n\t\t\tdst_reg->var_off = tnum_rshift(dst_reg->var_off,\n\t\t\t\t\t\t       umin_val);\n\t\telse\n\t\t\tdst_reg->var_off = tnum_rshift(tnum_unknown, umin_val);\n\t\tdst_reg->umin_value >>= umax_val;\n\t\tdst_reg->umax_value >>= umin_val;\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tdefault:\n\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\tbreak;\n\t}\n\n\t__reg_deduce_bounds(dst_reg);\n\t__reg_bound_offset(dst_reg);\n\treturn 0;\n}\n", "target": 1, "idx": 180829}
{"func": "bool VaapiVideoDecodeAccelerator::VaapiH264Accelerator::SubmitFrameMetadata(\n    const H264SPS* sps,\n    const H264PPS* pps,\n    const H264DPB& dpb,\n    const H264Picture::Vector& ref_pic_listp0,\n     const H264Picture::Vector& ref_pic_listb0,\n     const H264Picture::Vector& ref_pic_listb1,\n     const scoped_refptr<H264Picture>& pic) {\n   VAPictureParameterBufferH264 pic_param;\n   memset(&pic_param, 0, sizeof(pic_param));\n \n#define FROM_SPS_TO_PP(a) pic_param.a = sps->a\n#define FROM_SPS_TO_PP2(a, b) pic_param.b = sps->a\n  FROM_SPS_TO_PP2(pic_width_in_mbs_minus1, picture_width_in_mbs_minus1);\n  FROM_SPS_TO_PP2(pic_height_in_map_units_minus1, picture_height_in_mbs_minus1);\n  FROM_SPS_TO_PP(bit_depth_luma_minus8);\n  FROM_SPS_TO_PP(bit_depth_chroma_minus8);\n#undef FROM_SPS_TO_PP\n#undef FROM_SPS_TO_PP2\n\n#define FROM_SPS_TO_PP_SF(a) pic_param.seq_fields.bits.a = sps->a\n#define FROM_SPS_TO_PP_SF2(a, b) pic_param.seq_fields.bits.b = sps->a\n  FROM_SPS_TO_PP_SF(chroma_format_idc);\n  FROM_SPS_TO_PP_SF2(separate_colour_plane_flag,\n                     residual_colour_transform_flag);\n  FROM_SPS_TO_PP_SF(gaps_in_frame_num_value_allowed_flag);\n  FROM_SPS_TO_PP_SF(frame_mbs_only_flag);\n  FROM_SPS_TO_PP_SF(mb_adaptive_frame_field_flag);\n  FROM_SPS_TO_PP_SF(direct_8x8_inference_flag);\n  pic_param.seq_fields.bits.MinLumaBiPredSize8x8 = (sps->level_idc >= 31);\n  FROM_SPS_TO_PP_SF(log2_max_frame_num_minus4);\n  FROM_SPS_TO_PP_SF(pic_order_cnt_type);\n  FROM_SPS_TO_PP_SF(log2_max_pic_order_cnt_lsb_minus4);\n  FROM_SPS_TO_PP_SF(delta_pic_order_always_zero_flag);\n#undef FROM_SPS_TO_PP_SF\n#undef FROM_SPS_TO_PP_SF2\n\n#define FROM_PPS_TO_PP(a) pic_param.a = pps->a\n  FROM_PPS_TO_PP(pic_init_qp_minus26);\n  FROM_PPS_TO_PP(pic_init_qs_minus26);\n  FROM_PPS_TO_PP(chroma_qp_index_offset);\n  FROM_PPS_TO_PP(second_chroma_qp_index_offset);\n#undef FROM_PPS_TO_PP\n\n#define FROM_PPS_TO_PP_PF(a) pic_param.pic_fields.bits.a = pps->a\n#define FROM_PPS_TO_PP_PF2(a, b) pic_param.pic_fields.bits.b = pps->a\n  FROM_PPS_TO_PP_PF(entropy_coding_mode_flag);\n  FROM_PPS_TO_PP_PF(weighted_pred_flag);\n  FROM_PPS_TO_PP_PF(weighted_bipred_idc);\n  FROM_PPS_TO_PP_PF(transform_8x8_mode_flag);\n\n  pic_param.pic_fields.bits.field_pic_flag = 0;\n  FROM_PPS_TO_PP_PF(constrained_intra_pred_flag);\n  FROM_PPS_TO_PP_PF2(bottom_field_pic_order_in_frame_present_flag,\n                     pic_order_present_flag);\n  FROM_PPS_TO_PP_PF(deblocking_filter_control_present_flag);\n  FROM_PPS_TO_PP_PF(redundant_pic_cnt_present_flag);\n  pic_param.pic_fields.bits.reference_pic_flag = pic->ref;\n#undef FROM_PPS_TO_PP_PF\n#undef FROM_PPS_TO_PP_PF2\n\n  pic_param.frame_num = pic->frame_num;\n\n  InitVAPicture(&pic_param.CurrPic);\n  FillVAPicture(&pic_param.CurrPic, pic);\n\n  for (int i = 0; i < 16; ++i)\n    InitVAPicture(&pic_param.ReferenceFrames[i]);\n\n  FillVARefFramesFromDPB(dpb, pic_param.ReferenceFrames,\n                         arraysize(pic_param.ReferenceFrames));\n\n  pic_param.num_ref_frames = sps->max_num_ref_frames;\n\n  if (!vaapi_wrapper_->SubmitBuffer(VAPictureParameterBufferType,\n                                    sizeof(pic_param), &pic_param))\n    return false;\n\n  VAIQMatrixBufferH264 iq_matrix_buf;\n  memset(&iq_matrix_buf, 0, sizeof(iq_matrix_buf));\n\n  if (pps->pic_scaling_matrix_present_flag) {\n    for (int i = 0; i < 6; ++i) {\n      for (int j = 0; j < 16; ++j)\n        iq_matrix_buf.ScalingList4x4[i][kZigzagScan4x4[j]] =\n            pps->scaling_list4x4[i][j];\n    }\n\n    for (int i = 0; i < 2; ++i) {\n      for (int j = 0; j < 64; ++j)\n        iq_matrix_buf.ScalingList8x8[i][kZigzagScan8x8[j]] =\n            pps->scaling_list8x8[i][j];\n    }\n  } else {\n    for (int i = 0; i < 6; ++i) {\n      for (int j = 0; j < 16; ++j)\n        iq_matrix_buf.ScalingList4x4[i][kZigzagScan4x4[j]] =\n            sps->scaling_list4x4[i][j];\n    }\n\n    for (int i = 0; i < 2; ++i) {\n      for (int j = 0; j < 64; ++j)\n        iq_matrix_buf.ScalingList8x8[i][kZigzagScan8x8[j]] =\n            sps->scaling_list8x8[i][j];\n    }\n  }\n\n  return vaapi_wrapper_->SubmitBuffer(VAIQMatrixBufferType,\n                                      sizeof(iq_matrix_buf), &iq_matrix_buf);\n}\n", "target": 1, "idx": 186788}
{"func": "void RenderFrameImpl::FrameFocused() {\n  Send(new FrameHostMsg_FrameFocused(routing_id_));\n}\n", "target": 0, "idx": 152319}
{"func": "icmp_print(netdissect_options *ndo, const u_char *bp, u_int plen, const u_char *bp2,\n           int fragmented)\n{\n\tchar *cp;\n\tconst struct icmp *dp;\n        const struct icmp_ext_t *ext_dp;\n\tconst struct ip *ip;\n\tconst char *str, *fmt;\n\tconst struct ip *oip;\n\tconst struct udphdr *ouh;\n        const uint8_t *obj_tptr;\n        uint32_t raw_label;\n        const u_char *snapend_save;\n\tconst struct icmp_mpls_ext_object_header_t *icmp_mpls_ext_object_header;\n\tu_int hlen, dport, mtu, obj_tlen, obj_class_num, obj_ctype;\n\tchar buf[MAXHOSTNAMELEN + 100];\n\tstruct cksum_vec vec[1];\n\n\tdp = (const struct icmp *)bp;\n        ext_dp = (const struct icmp_ext_t *)bp;\n\tip = (const struct ip *)bp2;\n\tstr = buf;\n\n\tND_TCHECK(dp->icmp_code);\n\tswitch (dp->icmp_type) {\n\n\tcase ICMP_ECHO:\n\tcase ICMP_ECHOREPLY:\n\t\tND_TCHECK(dp->icmp_seq);\n\t\t(void)snprintf(buf, sizeof(buf), \"echo %s, id %u, seq %u\",\n                               dp->icmp_type == ICMP_ECHO ?\n                               \"request\" : \"reply\",\n                               EXTRACT_16BITS(&dp->icmp_id),\n                               EXTRACT_16BITS(&dp->icmp_seq));\n\t\tbreak;\n\n\tcase ICMP_UNREACH:\n\t\tND_TCHECK(dp->icmp_ip.ip_dst);\n\t\tswitch (dp->icmp_code) {\n\n\t\tcase ICMP_UNREACH_PROTOCOL:\n\t\t\tND_TCHECK(dp->icmp_ip.ip_p);\n\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t    \"%s protocol %d unreachable\",\n\t\t\t    ipaddr_string(ndo, &dp->icmp_ip.ip_dst),\n\t\t\t    dp->icmp_ip.ip_p);\n\t\t\tbreak;\n\n\t\tcase ICMP_UNREACH_PORT:\n\t\t\tND_TCHECK(dp->icmp_ip.ip_p);\n\t\t\toip = &dp->icmp_ip;\n\t\t\thlen = IP_HL(oip) * 4;\n\t\t\touh = (const struct udphdr *)(((const u_char *)oip) + hlen);\n\t\t\tND_TCHECK(ouh->uh_dport);\n\t\t\tdport = EXTRACT_16BITS(&ouh->uh_dport);\n\t\t\tswitch (oip->ip_p) {\n\n\t\t\tcase IPPROTO_TCP:\n\t\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t\t\t\"%s tcp port %s unreachable\",\n\t\t\t\t\tipaddr_string(ndo, &oip->ip_dst),\n\t\t\t\t\ttcpport_string(ndo, dport));\n\t\t\t\tbreak;\n\n\t\t\tcase IPPROTO_UDP:\n\t\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t\t\t\"%s udp port %s unreachable\",\n\t\t\t\t\tipaddr_string(ndo, &oip->ip_dst),\n\t\t\t\t\tudpport_string(ndo, dport));\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t\t\t\"%s protocol %d port %d unreachable\",\n\t\t\t\t\tipaddr_string(ndo, &oip->ip_dst),\n\t\t\t\t\toip->ip_p, dport);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ICMP_UNREACH_NEEDFRAG:\n\t\t    {\n\t\t\tregister const struct mtu_discovery *mp;\n\t\t\tmp = (const struct mtu_discovery *)(const u_char *)&dp->icmp_void;\n\t\t\tmtu = EXTRACT_16BITS(&mp->nexthopmtu);\n\t\t\tif (mtu) {\n\t\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t\t    \"%s unreachable - need to frag (mtu %d)\",\n\t\t\t\t    ipaddr_string(ndo, &dp->icmp_ip.ip_dst), mtu);\n\t\t\t} else {\n\t\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t\t    \"%s unreachable - need to frag\",\n\t\t\t\t    ipaddr_string(ndo, &dp->icmp_ip.ip_dst));\n\t\t\t}\n\t\t    }\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfmt = tok2str(unreach2str, \"#%d %%s unreachable\",\n\t\t\t    dp->icmp_code);\n\t\t\t(void)snprintf(buf, sizeof(buf), fmt,\n\t\t\t    ipaddr_string(ndo, &dp->icmp_ip.ip_dst));\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase ICMP_REDIRECT:\n\t\tND_TCHECK(dp->icmp_ip.ip_dst);\n\t\tfmt = tok2str(type2str, \"redirect-#%d %%s to net %%s\",\n\t\t    dp->icmp_code);\n\t\t(void)snprintf(buf, sizeof(buf), fmt,\n\t\t    ipaddr_string(ndo, &dp->icmp_ip.ip_dst),\n\t\t    ipaddr_string(ndo, &dp->icmp_gwaddr));\n\t\tbreak;\n\n\tcase ICMP_ROUTERADVERT:\n\t    {\n\t\tregister const struct ih_rdiscovery *ihp;\n\t\tregister const struct id_rdiscovery *idp;\n\t\tu_int lifetime, num, size;\n\n\t\t(void)snprintf(buf, sizeof(buf), \"router advertisement\");\n\t\tcp = buf + strlen(buf);\n\n\t\tihp = (const struct ih_rdiscovery *)&dp->icmp_void;\n\t\tND_TCHECK(*ihp);\n\t\t(void)strncpy(cp, \" lifetime \", sizeof(buf) - (cp - buf));\n\t\tcp = buf + strlen(buf);\n\t\tlifetime = EXTRACT_16BITS(&ihp->ird_lifetime);\n\t\tif (lifetime < 60) {\n\t\t\t(void)snprintf(cp, sizeof(buf) - (cp - buf), \"%u\",\n\t\t\t    lifetime);\n\t\t} else if (lifetime < 60 * 60) {\n\t\t\t(void)snprintf(cp, sizeof(buf) - (cp - buf), \"%u:%02u\",\n\t\t\t    lifetime / 60, lifetime % 60);\n\t\t} else {\n\t\t\t(void)snprintf(cp, sizeof(buf) - (cp - buf),\n\t\t\t    \"%u:%02u:%02u\",\n\t\t\t    lifetime / 3600,\n\t\t\t    (lifetime % 3600) / 60,\n\t\t\t    lifetime % 60);\n\t\t}\n\t\tcp = buf + strlen(buf);\n\n\t\tnum = ihp->ird_addrnum;\n\t\t(void)snprintf(cp, sizeof(buf) - (cp - buf), \" %d:\", num);\n\t\tcp = buf + strlen(buf);\n\n\t\tsize = ihp->ird_addrsiz;\n\t\tif (size != 2) {\n\t\t\t(void)snprintf(cp, sizeof(buf) - (cp - buf),\n\t\t\t    \" [size %d]\", size);\n\t\t\tbreak;\n\t\t}\n\t\tidp = (const struct id_rdiscovery *)&dp->icmp_data;\n\t\twhile (num-- > 0) {\n\t\t\tND_TCHECK(*idp);\n\t\t\t(void)snprintf(cp, sizeof(buf) - (cp - buf), \" {%s %u}\",\n\t\t\t    ipaddr_string(ndo, &idp->ird_addr),\n\t\t\t    EXTRACT_32BITS(&idp->ird_pref));\n\t\t\tcp = buf + strlen(buf);\n\t\t\t++idp;\n\t\t}\n\t    }\n\t\tbreak;\n\n\tcase ICMP_TIMXCEED:\n\t\tND_TCHECK(dp->icmp_ip.ip_dst);\n\t\tswitch (dp->icmp_code) {\n\n\t\tcase ICMP_TIMXCEED_INTRANS:\n\t\t\tstr = \"time exceeded in-transit\";\n\t\t\tbreak;\n\n\t\tcase ICMP_TIMXCEED_REASS:\n\t\t\tstr = \"ip reassembly time exceeded\";\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t(void)snprintf(buf, sizeof(buf), \"time exceeded-#%d\",\n\t\t\t    dp->icmp_code);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase ICMP_PARAMPROB:\n\t\tif (dp->icmp_code)\n\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t    \"parameter problem - code %d\", dp->icmp_code);\n\t\telse {\n\t\t\tND_TCHECK(dp->icmp_pptr);\n\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t    \"parameter problem - octet %d\", dp->icmp_pptr);\n\t\t}\n\t\tbreak;\n\n\tcase ICMP_MASKREPLY:\n\t\tND_TCHECK(dp->icmp_mask);\n\t\t(void)snprintf(buf, sizeof(buf), \"address mask is 0x%08x\",\n\t\t    EXTRACT_32BITS(&dp->icmp_mask));\n\t\tbreak;\n\n\tcase ICMP_TSTAMP:\n\t\tND_TCHECK(dp->icmp_seq);\n\t\t(void)snprintf(buf, sizeof(buf),\n\t\t    \"time stamp query id %u seq %u\",\n\t\t    EXTRACT_16BITS(&dp->icmp_id),\n\t\t    EXTRACT_16BITS(&dp->icmp_seq));\n\t\tbreak;\n\n\tcase ICMP_TSTAMPREPLY:\n\t\tND_TCHECK(dp->icmp_ttime);\n\t\t(void)snprintf(buf, sizeof(buf),\n\t\t    \"time stamp reply id %u seq %u: org %s\",\n                               EXTRACT_16BITS(&dp->icmp_id),\n                               EXTRACT_16BITS(&dp->icmp_seq),\n                               icmp_tstamp_print(EXTRACT_32BITS(&dp->icmp_otime)));\n\n                (void)snprintf(buf+strlen(buf),sizeof(buf)-strlen(buf),\", recv %s\",\n                         icmp_tstamp_print(EXTRACT_32BITS(&dp->icmp_rtime)));\n                (void)snprintf(buf+strlen(buf),sizeof(buf)-strlen(buf),\", xmit %s\",\n                         icmp_tstamp_print(EXTRACT_32BITS(&dp->icmp_ttime)));\n                break;\n\n\tdefault:\n\t\tstr = tok2str(icmp2str, \"type-#%d\", dp->icmp_type);\n\t\tbreak;\n\t}\n\tND_PRINT((ndo, \"ICMP %s, length %u\", str, plen));\n\tif (ndo->ndo_vflag && !fragmented) { /* don't attempt checksumming if this is a frag */\n\t\tuint16_t sum, icmp_sum;\n\n\t\tif (ND_TTEST2(*bp, plen)) {\n\t\t\tvec[0].ptr = (const uint8_t *)(const void *)dp;\n\t\t\tvec[0].len = plen;\n\t\t\tsum = in_cksum(vec, 1);\n\t\t\tif (sum != 0) {\n\t\t\t\ticmp_sum = EXTRACT_16BITS(&dp->icmp_cksum);\n\t\t\t\tND_PRINT((ndo, \" (wrong icmp cksum %x (->%x)!)\",\n\t\t\t\t\t     icmp_sum,\n\t\t\t\t\t     in_cksum_shouldbe(icmp_sum, sum)));\n\t\t\t}\n\t\t}\n\t}\n\n        /*\n         * print the remnants of the IP packet.\n         * save the snaplength as this may get overidden in the IP printer.\n         */\n\tif (ndo->ndo_vflag >= 1 && ICMP_ERRTYPE(dp->icmp_type)) {\n\t\tbp += 8;\n \t\tND_PRINT((ndo, \"\\n\\t\"));\n \t\tip = (const struct ip *)bp;\n                 snapend_save = ndo->ndo_snapend;\n \t\tip_print(ndo, bp, EXTRACT_16BITS(&ip->ip_len));\n                 ndo->ndo_snapend = snapend_save;\n \t}\n\n        /*\n         * Attempt to decode the MPLS extensions only for some ICMP types.\n         */\n        if (ndo->ndo_vflag >= 1 && plen > ICMP_EXTD_MINLEN && ICMP_MPLS_EXT_TYPE(dp->icmp_type)) {\n\n            ND_TCHECK(*ext_dp);\n\n            /*\n             * Check first if the mpls extension header shows a non-zero length.\n             * If the length field is not set then silently verify the checksum\n             * to check if an extension header is present. This is expedient,\n             * however not all implementations set the length field proper.\n             */\n            if (!ext_dp->icmp_length &&\n                ND_TTEST2(ext_dp->icmp_ext_version_res, plen - ICMP_EXTD_MINLEN)) {\n                vec[0].ptr = (const uint8_t *)(const void *)&ext_dp->icmp_ext_version_res;\n                vec[0].len = plen - ICMP_EXTD_MINLEN;\n                if (in_cksum(vec, 1)) {\n                    return;\n                }\n            }\n\n            ND_PRINT((ndo, \"\\n\\tMPLS extension v%u\",\n                   ICMP_MPLS_EXT_EXTRACT_VERSION(*(ext_dp->icmp_ext_version_res))));\n\n            /*\n             * Sanity checking of the header.\n             */\n            if (ICMP_MPLS_EXT_EXTRACT_VERSION(*(ext_dp->icmp_ext_version_res)) !=\n                ICMP_MPLS_EXT_VERSION) {\n                ND_PRINT((ndo, \" packet not supported\"));\n                return;\n            }\n\n            hlen = plen - ICMP_EXTD_MINLEN;\n            if (ND_TTEST2(ext_dp->icmp_ext_version_res, hlen)) {\n                vec[0].ptr = (const uint8_t *)(const void *)&ext_dp->icmp_ext_version_res;\n                vec[0].len = hlen;\n                ND_PRINT((ndo, \", checksum 0x%04x (%scorrect), length %u\",\n                       EXTRACT_16BITS(ext_dp->icmp_ext_checksum),\n                       in_cksum(vec, 1) ? \"in\" : \"\",\n                       hlen));\n            }\n\n            hlen -= 4; /* subtract common header size */\n            obj_tptr = (const uint8_t *)ext_dp->icmp_ext_data;\n\n            while (hlen > sizeof(struct icmp_mpls_ext_object_header_t)) {\n\n                icmp_mpls_ext_object_header = (const struct icmp_mpls_ext_object_header_t *)obj_tptr;\n                ND_TCHECK(*icmp_mpls_ext_object_header);\n                obj_tlen = EXTRACT_16BITS(icmp_mpls_ext_object_header->length);\n                obj_class_num = icmp_mpls_ext_object_header->class_num;\n                obj_ctype = icmp_mpls_ext_object_header->ctype;\n                obj_tptr += sizeof(struct icmp_mpls_ext_object_header_t);\n\n                ND_PRINT((ndo, \"\\n\\t  %s Object (%u), Class-Type: %u, length %u\",\n                       tok2str(icmp_mpls_ext_obj_values,\"unknown\",obj_class_num),\n                       obj_class_num,\n                       obj_ctype,\n                       obj_tlen));\n\n                hlen-=sizeof(struct icmp_mpls_ext_object_header_t); /* length field includes tlv header */\n\n                /* infinite loop protection */\n                if ((obj_class_num == 0) ||\n                    (obj_tlen < sizeof(struct icmp_mpls_ext_object_header_t))) {\n                    return;\n                }\n                obj_tlen-=sizeof(struct icmp_mpls_ext_object_header_t);\n\n                switch (obj_class_num) {\n                case 1:\n                    switch(obj_ctype) {\n                    case 1:\n                        ND_TCHECK2(*obj_tptr, 4);\n                        raw_label = EXTRACT_32BITS(obj_tptr);\n                        ND_PRINT((ndo, \"\\n\\t    label %u, exp %u\", MPLS_LABEL(raw_label), MPLS_EXP(raw_label)));\n                        if (MPLS_STACK(raw_label))\n                            ND_PRINT((ndo, \", [S]\"));\n                        ND_PRINT((ndo, \", ttl %u\", MPLS_TTL(raw_label)));\n                        break;\n                    default:\n                        print_unknown_data(ndo, obj_tptr, \"\\n\\t    \", obj_tlen);\n                    }\n                    break;\n\n               /*\n                *  FIXME those are the defined objects that lack a decoder\n                *  you are welcome to contribute code ;-)\n                */\n                case 2:\n                default:\n                    print_unknown_data(ndo, obj_tptr, \"\\n\\t    \", obj_tlen);\n                    break;\n                }\n                if (hlen < obj_tlen)\n                    break;\n                hlen -= obj_tlen;\n                obj_tptr += obj_tlen;\n            }\n        }\n\n\treturn;\ntrunc:\n\tND_PRINT((ndo, \"[|icmp]\"));\n}\n", "target": 1, "idx": 181054}
{"func": "static int raw_cmd_copyin(int cmd, void __user *param,\n\t\t\t\t struct floppy_raw_cmd **rcmd)\n{\n\tstruct floppy_raw_cmd *ptr;\n\tint ret;\n\tint i;\n\n\t*rcmd = NULL;\n\nloop:\n\tptr = kmalloc(sizeof(struct floppy_raw_cmd), GFP_USER);\n\tif (!ptr)\n \t\treturn -ENOMEM;\n \t*rcmd = ptr;\n \tret = copy_from_user(ptr, param, sizeof(*ptr));\n\tif (ret)\n\t\treturn -EFAULT;\n \tptr->next = NULL;\n \tptr->buffer_length = 0;\n \tparam += sizeof(struct floppy_raw_cmd);\n \tif (ptr->cmd_count > 33)\n \t\t\t/* the command may now also take up the space\n\t\t\t * initially intended for the reply & the\n\t\t\t * reply count. Needed for long 82078 commands\n\t\t\t * such as RESTORE, which takes ... 17 command\n\t\t\t * bytes. Murphy's law #137: When you reserve\n\t\t\t * 16 bytes for a structure, you'll one day\n\t\t\t * discover that you really need 17...\n\t\t\t */\n\t\treturn -EINVAL;\n\n \tfor (i = 0; i < 16; i++)\n \t\tptr->reply[i] = 0;\n \tptr->resultcode = 0;\n\tptr->kernel_data = NULL;\n \n \tif (ptr->flags & (FD_RAW_READ | FD_RAW_WRITE)) {\n \t\tif (ptr->length <= 0)\n\t\t\treturn -EINVAL;\n\t\tptr->kernel_data = (char *)fd_dma_mem_alloc(ptr->length);\n\t\tfallback_on_nodma_alloc(&ptr->kernel_data, ptr->length);\n\t\tif (!ptr->kernel_data)\n\t\t\treturn -ENOMEM;\n\t\tptr->buffer_length = ptr->length;\n\t}\n\tif (ptr->flags & FD_RAW_WRITE) {\n\t\tret = fd_copyin(ptr->data, ptr->kernel_data, ptr->length);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (ptr->flags & FD_RAW_MORE) {\n\t\trcmd = &(ptr->next);\n\t\tptr->rate &= 0x43;\n\t\tgoto loop;\n\t}\n\n\treturn 0;\n}\n", "target": 1, "idx": 179607}
{"func": "IDNConversionResult IDNToUnicodeWithAdjustmentsImpl(\n    base::StringPiece host,\n    base::OffsetAdjuster::Adjustments* adjustments,\n    bool enable_spoof_checks) {\n  if (adjustments)\n    adjustments->clear();\n  base::string16 input16;\n   input16.reserve(host.length());\n   input16.insert(input16.end(), host.begin(), host.end());\n \n  bool is_tld_ascii = true;\n   size_t last_dot = host.rfind('.');\n  if (last_dot != base::StringPiece::npos &&\n      host.substr(last_dot).starts_with(\".xn--\")) {\n    is_tld_ascii = false;\n   }\n \n   IDNConversionResult result;\n  base::string16 out16;\n  for (size_t component_start = 0, component_end;\n       component_start < input16.length();\n       component_start = component_end + 1) {\n    component_end = input16.find('.', component_start);\n    if (component_end == base::string16::npos)\n      component_end = input16.length();  // For getting the last component.\n    size_t component_length = component_end - component_start;\n    size_t new_component_start = out16.length();\n    bool converted_idn = false;\n    if (component_end > component_start) {\n       bool has_idn_component = false;\n       converted_idn = IDNToUnicodeOneComponent(\n          input16.data() + component_start, component_length, is_tld_ascii,\n           enable_spoof_checks, &out16, &has_idn_component);\n       result.has_idn_component |= has_idn_component;\n     }\n    size_t new_component_length = out16.length() - new_component_start;\n\n    if (converted_idn && adjustments) {\n      adjustments->push_back(base::OffsetAdjuster::Adjustment(\n          component_start, component_length, new_component_length));\n    }\n\n    if (component_end < input16.length())\n      out16.push_back('.');\n  }\n\n  result.result = out16;\n\n  if (result.has_idn_component) {\n    result.matching_top_domain =\n        g_idn_spoof_checker.Get().GetSimilarTopDomain(out16);\n    if (enable_spoof_checks && !result.matching_top_domain.domain.empty()) {\n      if (adjustments)\n        adjustments->clear();\n      result.result = input16;\n    }\n  }\n\n  return result;\n}\n", "target": 1, "idx": 186706}
{"func": "void DevToolsWindow::Inspect(scoped_refptr<content::DevToolsAgentHost> host) {\n  DevToolsWindow::OpenDevToolsWindow(host, profile_);\n}\n", "target": 0, "idx": 151077}
{"func": " void CastCastView::ButtonPressed(views::Button* sender,\n                                  const ui::Event& event) {\n   DCHECK(sender == stop_button_);\n  StopCast();\n }\n", "target": 1, "idx": 185326}
{"func": " chdlc_print(netdissect_options *ndo, register const u_char *p, u_int length)\n {\n \tu_int proto;\n \n \tproto = EXTRACT_16BITS(&p[2]);\n \tif (ndo->ndo_eflag) {\n                 ND_PRINT((ndo, \"%s, ethertype %s (0x%04x), length %u: \",\n                       tok2str(chdlc_cast_values, \"0x%02x\", p[0]),\n                       tok2str(ethertype_values, \"Unknown\", proto),\n                       proto,\n                       length));\n\t}\n\n\tlength -= CHDLC_HDRLEN;\n\tp += CHDLC_HDRLEN;\n\n\tswitch (proto) {\n\tcase ETHERTYPE_IP:\n\t\tip_print(ndo, p, length);\n\t\tbreak;\n\tcase ETHERTYPE_IPV6:\n\t\tip6_print(ndo, p, length);\n\t\tbreak;\n\tcase CHDLC_TYPE_SLARP:\n\t\tchdlc_slarp_print(ndo, p, length);\n\t\tbreak;\n#if 0\n\tcase CHDLC_TYPE_CDP:\n\t\tchdlc_cdp_print(p, length);\n\t\tbreak;\n#endif\n        case ETHERTYPE_MPLS:\n        case ETHERTYPE_MPLS_MULTI:\n                mpls_print(ndo, p, length);\n \t\tbreak;\n         case ETHERTYPE_ISO:\n                 /* is the fudge byte set ? lets verify by spotting ISO headers */\n                 if (*(p+1) == 0x81 ||\n                     *(p+1) == 0x82 ||\n                     *(p+1) == 0x83)\n                    isoclns_print(ndo, p + 1, length - 1, ndo->ndo_snapend - p - 1);\n                else\n                    isoclns_print(ndo, p, length, ndo->ndo_snapend - p);\n                break;\n\tdefault:\n                if (!ndo->ndo_eflag)\n                        ND_PRINT((ndo, \"unknown CHDLC protocol (0x%04x)\", proto));\n                break;\n \t}\n \n \treturn (CHDLC_HDRLEN);\n }\n", "target": 1, "idx": 183194}
{"func": "void WebContentsImpl::RenderViewForInterstitialPageCreated(\n    RenderViewHost* render_view_host) {\n  FOR_EACH_OBSERVER(WebContentsObserver, observers_,\n                    RenderViewForInterstitialPageCreated(render_view_host));\n}\n", "target": 0, "idx": 119012}
{"func": "bool UnprivilegedProcessDelegate::CreateConnectedIpcChannel(\n    const std::string& channel_name,\n    IPC::Listener* delegate,\n    ScopedHandle* client_out,\n    scoped_ptr<IPC::ChannelProxy>* server_out) {\n  scoped_ptr<IPC::ChannelProxy> server;\n  if (!CreateIpcChannel(channel_name, kDaemonIpcSecurityDescriptor,\n                        io_task_runner_, delegate, &server)) {\n    return false;\n  }\n  std::string pipe_name(kChromePipeNamePrefix);\n  pipe_name.append(channel_name);\n  SECURITY_ATTRIBUTES security_attributes;\n  security_attributes.nLength = sizeof(security_attributes);\n  security_attributes.lpSecurityDescriptor = NULL;\n  security_attributes.bInheritHandle = TRUE;\n  ScopedHandle client;\n  client.Set(CreateFile(UTF8ToUTF16(pipe_name).c_str(),\n                        GENERIC_READ | GENERIC_WRITE,\n                        0,\n                        &security_attributes,\n                        OPEN_EXISTING,\n                        SECURITY_SQOS_PRESENT | SECURITY_IDENTIFICATION |\n                            FILE_FLAG_OVERLAPPED,\n                        NULL));\n  if (!client.IsValid())\n    return false;\n  *client_out = client.Pass();\n  *server_out = server.Pass();\n  return true;\n}\n", "target": 1, "idx": 185247}
{"func": "static void rxrpc_destroy(struct key *key)\n{\n\trxrpc_free_token_list(key->payload.data);\n}\n", "target": 0, "idx": 69500}
{"func": "static int devicenrange(i_ctx_t * i_ctx_p, ref *space, float *ptr)\n{\n    int i, limit, code;\n    PS_colour_space_t *cspace;\n\n    ref altspace;\n\n    code = array_get(imemory, space, 1, &altspace);\n    if (code < 0)\n        return code;\n\n    code = get_space_object(i_ctx_p, &altspace, &cspace);\n    if (code < 0)\n        return code;\n\n    code = cspace->numcomponents(i_ctx_p, &altspace, &limit);\n    if (code < 0)\n        return code;\n\n    for (i = 0;i < limit * 2;i+=2) {\n        ptr[i] = 0;\n        ptr[i+1] = 1;\n    }\n    return 0;\n}\n", "target": 0, "idx": 3069}
{"func": "gboolean Shell::OnWindowDestroyed(GtkWidget* window) {\n  delete this;\n  return FALSE;  // Don't stop this message.\n}\n", "target": 0, "idx": 108596}
{"func": "rfc4106_set_hash_subkey(u8 *hash_subkey, const u8 *key, unsigned int key_len)\n{\n\tstruct crypto_ablkcipher *ctr_tfm;\n\tstruct ablkcipher_request *req;\n\tint ret = -EINVAL;\n\tstruct aesni_hash_subkey_req_data *req_data;\n\n\tctr_tfm = crypto_alloc_ablkcipher(\"ctr(aes)\", 0, 0);\n\tif (IS_ERR(ctr_tfm))\n\t\treturn PTR_ERR(ctr_tfm);\n\n\tcrypto_ablkcipher_clear_flags(ctr_tfm, ~0);\n\n\tret = crypto_ablkcipher_setkey(ctr_tfm, key, key_len);\n\tif (ret)\n\t\tgoto out_free_ablkcipher;\n\n\tret = -ENOMEM;\n\treq = ablkcipher_request_alloc(ctr_tfm, GFP_KERNEL);\n\tif (!req)\n\t\tgoto out_free_ablkcipher;\n\n\treq_data = kmalloc(sizeof(*req_data), GFP_KERNEL);\n\tif (!req_data)\n\t\tgoto out_free_request;\n\n\tmemset(req_data->iv, 0, sizeof(req_data->iv));\n\n\t/* Clear the data in the hash sub key container to zero.*/\n\t/* We want to cipher all zeros to create the hash sub key. */\n\tmemset(hash_subkey, 0, RFC4106_HASH_SUBKEY_SIZE);\n\n\tinit_completion(&req_data->result.completion);\n\tsg_init_one(&req_data->sg, hash_subkey, RFC4106_HASH_SUBKEY_SIZE);\n\tablkcipher_request_set_tfm(req, ctr_tfm);\n\tablkcipher_request_set_callback(req, CRYPTO_TFM_REQ_MAY_SLEEP |\n\t\t\t\t\tCRYPTO_TFM_REQ_MAY_BACKLOG,\n\t\t\t\t\trfc4106_set_hash_subkey_done,\n\t\t\t\t\t&req_data->result);\n\n\tablkcipher_request_set_crypt(req, &req_data->sg,\n\t\t&req_data->sg, RFC4106_HASH_SUBKEY_SIZE, req_data->iv);\n\n\tret = crypto_ablkcipher_encrypt(req);\n\tif (ret == -EINPROGRESS || ret == -EBUSY) {\n\t\tret = wait_for_completion_interruptible\n\t\t\t(&req_data->result.completion);\n\t\tif (!ret)\n\t\t\tret = req_data->result.err;\n\t}\n\tkfree(req_data);\nout_free_request:\n\tablkcipher_request_free(req);\nout_free_ablkcipher:\n\tcrypto_free_ablkcipher(ctr_tfm);\n\treturn ret;\n}\n", "target": 0, "idx": 43492}
{"func": "xmlXPathCompRelationalExpr(xmlXPathParserContextPtr ctxt) {\n    xmlXPathCompAdditiveExpr(ctxt);\n    CHECK_ERROR;\n    SKIP_BLANKS;\n    while ((CUR == '<') ||\n           (CUR == '>') ||\n           ((CUR == '<') && (NXT(1) == '=')) ||\n           ((CUR == '>') && (NXT(1) == '='))) {\n\tint inf, strict;\n\tint op1 = ctxt->comp->last;\n\n        if (CUR == '<') inf = 1;\n\telse inf = 0;\n\tif (NXT(1) == '=') strict = 0;\n\telse strict = 1;\n\tNEXT;\n\tif (!strict) NEXT;\n\tSKIP_BLANKS;\n        xmlXPathCompAdditiveExpr(ctxt);\n\tCHECK_ERROR;\n\tPUSH_BINARY_EXPR(XPATH_OP_CMP, op1, ctxt->comp->last, inf, strict);\n\tSKIP_BLANKS;\n    }\n}\n", "target": 0, "idx": 97616}
{"func": "int hugetlb_fault(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\t\tunsigned long address, unsigned int flags)\n{\n\tpte_t *ptep, entry;\n\tspinlock_t *ptl;\n\tint ret;\n\tu32 hash;\n\tpgoff_t idx;\n\tstruct page *page = NULL;\n\tstruct page *pagecache_page = NULL;\n\tstruct hstate *h = hstate_vma(vma);\n\tstruct address_space *mapping;\n\tint need_wait_lock = 0;\n\n\taddress &= huge_page_mask(h);\n\n\tptep = huge_pte_offset(mm, address, huge_page_size(h));\n\tif (ptep) {\n\t\tentry = huge_ptep_get(ptep);\n\t\tif (unlikely(is_hugetlb_entry_migration(entry))) {\n\t\t\tmigration_entry_wait_huge(vma, mm, ptep);\n\t\t\treturn 0;\n\t\t} else if (unlikely(is_hugetlb_entry_hwpoisoned(entry)))\n\t\t\treturn VM_FAULT_HWPOISON_LARGE |\n\t\t\t\tVM_FAULT_SET_HINDEX(hstate_index(h));\n\t} else {\n\t\tptep = huge_pte_alloc(mm, address, huge_page_size(h));\n\t\tif (!ptep)\n\t\t\treturn VM_FAULT_OOM;\n\t}\n\n\tmapping = vma->vm_file->f_mapping;\n\tidx = vma_hugecache_offset(h, vma, address);\n\n\t/*\n\t * Serialize hugepage allocation and instantiation, so that we don't\n\t * get spurious allocation failures if two CPUs race to instantiate\n\t * the same page in the page cache.\n\t */\n\thash = hugetlb_fault_mutex_hash(h, mm, vma, mapping, idx, address);\n\tmutex_lock(&hugetlb_fault_mutex_table[hash]);\n\n\tentry = huge_ptep_get(ptep);\n\tif (huge_pte_none(entry)) {\n\t\tret = hugetlb_no_page(mm, vma, mapping, idx, address, ptep, flags);\n\t\tgoto out_mutex;\n\t}\n\n\tret = 0;\n\n\t/*\n\t * entry could be a migration/hwpoison entry at this point, so this\n\t * check prevents the kernel from going below assuming that we have\n\t * a active hugepage in pagecache. This goto expects the 2nd page fault,\n\t * and is_hugetlb_entry_(migration|hwpoisoned) check will properly\n\t * handle it.\n\t */\n\tif (!pte_present(entry))\n\t\tgoto out_mutex;\n\n\t/*\n\t * If we are going to COW the mapping later, we examine the pending\n\t * reservations for this page now. This will ensure that any\n\t * allocations necessary to record that reservation occur outside the\n\t * spinlock. For private mappings, we also lookup the pagecache\n\t * page now as it is used to determine if a reservation has been\n\t * consumed.\n\t */\n\tif ((flags & FAULT_FLAG_WRITE) && !huge_pte_write(entry)) {\n\t\tif (vma_needs_reservation(h, vma, address) < 0) {\n\t\t\tret = VM_FAULT_OOM;\n\t\t\tgoto out_mutex;\n\t\t}\n\t\t/* Just decrements count, does not deallocate */\n\t\tvma_end_reservation(h, vma, address);\n\n\t\tif (!(vma->vm_flags & VM_MAYSHARE))\n\t\t\tpagecache_page = hugetlbfs_pagecache_page(h,\n\t\t\t\t\t\t\t\tvma, address);\n\t}\n\n\tptl = huge_pte_lock(h, mm, ptep);\n\n\t/* Check for a racing update before calling hugetlb_cow */\n\tif (unlikely(!pte_same(entry, huge_ptep_get(ptep))))\n\t\tgoto out_ptl;\n\n\t/*\n\t * hugetlb_cow() requires page locks of pte_page(entry) and\n\t * pagecache_page, so here we need take the former one\n\t * when page != pagecache_page or !pagecache_page.\n\t */\n\tpage = pte_page(entry);\n\tif (page != pagecache_page)\n\t\tif (!trylock_page(page)) {\n\t\t\tneed_wait_lock = 1;\n\t\t\tgoto out_ptl;\n\t\t}\n\n\tget_page(page);\n\n\tif (flags & FAULT_FLAG_WRITE) {\n\t\tif (!huge_pte_write(entry)) {\n\t\t\tret = hugetlb_cow(mm, vma, address, ptep,\n\t\t\t\t\t  pagecache_page, ptl);\n\t\t\tgoto out_put_page;\n\t\t}\n\t\tentry = huge_pte_mkdirty(entry);\n\t}\n\tentry = pte_mkyoung(entry);\n\tif (huge_ptep_set_access_flags(vma, address, ptep, entry,\n\t\t\t\t\t\tflags & FAULT_FLAG_WRITE))\n\t\tupdate_mmu_cache(vma, address, ptep);\nout_put_page:\n\tif (page != pagecache_page)\n\t\tunlock_page(page);\n\tput_page(page);\nout_ptl:\n\tspin_unlock(ptl);\n\n\tif (pagecache_page) {\n\t\tunlock_page(pagecache_page);\n\t\tput_page(pagecache_page);\n\t}\nout_mutex:\n\tmutex_unlock(&hugetlb_fault_mutex_table[hash]);\n\t/*\n\t * Generally it's safe to hold refcount during waiting page lock. But\n\t * here we just wait to defer the next page fault to avoid busy loop and\n\t * the page is not used after unlocked before returning from the current\n\t * page fault. So we are safe from accessing freed page, even if we wait\n\t * here without taking refcount.\n\t */\n\tif (need_wait_lock)\n\t\twait_on_page_locked(page);\n\treturn ret;\n}\n", "target": 0, "idx": 86373}
{"func": "int validate_camera_metadata_structure(const camera_metadata_t *metadata,\n const size_t *expected_size) {\n\n if (metadata == NULL) {\n        ALOGE(\"%s: metadata is null!\", __FUNCTION__);\n return ERROR;\n }\n\n {\n static const struct {\n const char *name;\n size_t alignment;\n } alignments[] = {\n {\n .name = \"camera_metadata\",\n .alignment = METADATA_ALIGNMENT\n },\n {\n .name = \"camera_metadata_buffer_entry\",\n .alignment = ENTRY_ALIGNMENT\n },\n {\n .name = \"camera_metadata_data\",\n .alignment = DATA_ALIGNMENT\n },\n };\n\n for (size_t i = 0; i < sizeof(alignments)/sizeof(alignments[0]); ++i) {\n uintptr_t aligned_ptr = ALIGN_TO(metadata, alignments[i].alignment);\n\n if ((uintptr_t)metadata != aligned_ptr) {\n                ALOGE(\"%s: Metadata pointer is not aligned (actual %p, \"\n \"expected %p) to type %s\",\n                      __FUNCTION__, metadata,\n (void*)aligned_ptr, alignments[i].name);\n return ERROR;\n }\n }\n }\n\n /**\n     * Check that the metadata contents are correct\n     */\n\n if (expected_size != NULL && metadata->size > *expected_size) {\n        ALOGE(\"%s: Metadata size (%\" PRIu32 \") should be <= expected size (%zu)\",\n              __FUNCTION__, metadata->size, *expected_size);\n return ERROR;\n }\n\n if (metadata->entry_count > metadata->entry_capacity) {\n        ALOGE(\"%s: Entry count (%\" PRIu32 \") should be <= entry capacity \"\n \"(%\" PRIu32 \")\",\n              __FUNCTION__, metadata->entry_count, metadata->entry_capacity);\n\n         return ERROR;\n     }\n \n    const metadata_uptrdiff_t entries_end =\n        metadata->entries_start + metadata->entry_capacity;\n     if (entries_end < metadata->entries_start || // overflow check\n         entries_end > metadata->data_start) {\n \n        ALOGE(\"%s: Entry start + capacity (%\" PRIu32 \") should be <= data start \"\n \"(%\" PRIu32 \")\",\n               __FUNCTION__,\n (metadata->entries_start + metadata->entry_capacity),\n              metadata->data_start);\n return ERROR;\n }\n\n const metadata_uptrdiff_t data_end =\n        metadata->data_start + metadata->data_capacity;\n if (data_end < metadata->data_start || // overflow check\n        data_end > metadata->size) {\n\n        ALOGE(\"%s: Data start + capacity (%\" PRIu32 \") should be <= total size \"\n \"(%\" PRIu32 \")\",\n               __FUNCTION__,\n (metadata->data_start + metadata->data_capacity),\n              metadata->size);\n return ERROR;\n }\n\n const metadata_size_t entry_count = metadata->entry_count;\n camera_metadata_buffer_entry_t *entries = get_entries(metadata);\n\n for (size_t i = 0; i < entry_count; ++i) {\n\n if ((uintptr_t)&entries[i] != ALIGN_TO(&entries[i], ENTRY_ALIGNMENT)) {\n            ALOGE(\"%s: Entry index %zu had bad alignment (address %p),\"\n \" expected alignment %zu\",\n                  __FUNCTION__, i, &entries[i], ENTRY_ALIGNMENT);\n return ERROR;\n }\n\n camera_metadata_buffer_entry_t entry = entries[i];\n\n if (entry.type >= NUM_TYPES) {\n            ALOGE(\"%s: Entry index %zu had a bad type %d\",\n                  __FUNCTION__, i, entry.type);\n return ERROR;\n }\n\n uint32_t tag_section = entry.tag >> 16;\n int tag_type = get_camera_metadata_tag_type(entry.tag);\n if (tag_type != (int)entry.type && tag_section < VENDOR_SECTION) {\n            ALOGE(\"%s: Entry index %zu had tag type %d, but the type was %d\",\n                  __FUNCTION__, i, tag_type, entry.type);\n return ERROR;\n }\n\n size_t data_size;\n if (validate_and_calculate_camera_metadata_entry_data_size(&data_size, entry.type,\n                entry.count) != OK) {\n            ALOGE(\"%s: Entry data size is invalid. type: %u count: %u\", __FUNCTION__, entry.type,\n                    entry.count);\n return ERROR;\n }\n\n if (data_size != 0) {\n camera_metadata_data_t *data =\n (camera_metadata_data_t*) (get_data(metadata) +\n                                               entry.data.offset);\n\n if ((uintptr_t)data != ALIGN_TO(data, DATA_ALIGNMENT)) {\n                ALOGE(\"%s: Entry index %zu had bad data alignment (address %p),\"\n \" expected align %zu, (tag name %s, data size %zu)\",\n                      __FUNCTION__, i, data, DATA_ALIGNMENT,\n                      get_camera_metadata_tag_name(entry.tag) ?: \"unknown\",\n                      data_size);\n return ERROR;\n }\n\n size_t data_entry_end = entry.data.offset + data_size;\n if (data_entry_end < entry.data.offset || // overflow check\n                data_entry_end > metadata->data_capacity) {\n\n                ALOGE(\"%s: Entry index %zu data ends (%zu) beyond the capacity \"\n \"%\" PRIu32, __FUNCTION__, i, data_entry_end,\n                      metadata->data_capacity);\n return ERROR;\n }\n\n } else if (entry.count == 0) {\n if (entry.data.offset != 0) {\n                ALOGE(\"%s: Entry index %zu had 0 items, but offset was non-0 \"\n \"(%\" PRIu32 \"), tag name: %s\", __FUNCTION__, i, entry.data.offset,\n                        get_camera_metadata_tag_name(entry.tag) ?: \"unknown\");\n return ERROR;\n }\n } // else data stored inline, so we look at value which can be anything.\n }\n\n return OK;\n}\n", "target": 1, "idx": 187419}
{"func": " static sk_sp<SkImage> unPremulSkImageToPremul(SkImage* input) {\n  SkImageInfo info = SkImageInfo::Make(input->width(), input->height(),\n                                       kN32_SkColorType, kPremul_SkAlphaType);\n  RefPtr<Uint8Array> dstPixels = copySkImageData(input, info);\n  if (!dstPixels)\n     return nullptr;\n   return newSkImageFromRaster(\n       info, std::move(dstPixels),\n      static_cast<size_t>(input->width()) * info.bytesPerPixel());\n }\n", "target": 1, "idx": 186476}
{"func": "static void __exit tcm_loop_fabric_exit(void)\n{\n\ttcm_loop_deregister_configfs();\n\ttcm_loop_release_core_bus();\n\tkmem_cache_destroy(tcm_loop_cmd_cache);\n}\n", "target": 0, "idx": 94127}
{"func": " bool GesturePoint::IsSecondClickInsideManhattanSquare(\n     const TouchEvent& event) const {\n   int manhattanDistance = abs(event.x() - last_tap_position_.x()) +\n                           abs(event.y() - last_tap_position_.y());\n  return manhattanDistance < kMaximumTouchMoveInPixelsForClick;\n }\n", "target": 1, "idx": 184738}
{"func": "static void didFinishLoadForFrame(WKPageRef page, WKFrameRef frame, WKTypeRef userData, const void* clientInfo)\n{\n    if (!WKFrameIsMainFrame(frame))\n        return;\n\n    webkitWebViewLoadChanged(WEBKIT_WEB_VIEW(clientInfo), WEBKIT_LOAD_FINISHED);\n}\n", "target": 0, "idx": 115337}
{"func": "static int __net_init nfnetlink_net_init(struct net *net)\n{\n\tstruct sock *nfnl;\n\tstruct netlink_kernel_cfg cfg = {\n\t\t.groups\t= NFNLGRP_MAX,\n\t\t.input\t= nfnetlink_rcv,\n#ifdef CONFIG_MODULES\n\t\t.bind\t= nfnetlink_bind,\n#endif\n\t};\n\n\tnfnl = netlink_kernel_create(net, NETLINK_NETFILTER, &cfg);\n\tif (!nfnl)\n\t\treturn -ENOMEM;\n\tnet->nfnl_stash = nfnl;\n\trcu_assign_pointer(net->nfnl, nfnl);\n\treturn 0;\n}\n", "target": 0, "idx": 49372}
{"func": "void HTMLFormControlElement::parseAttribute(const QualifiedName& name, const AtomicString& value)\n{\n    if (name == formAttr) {\n        formAttributeChanged();\n        UseCounter::count(document(), UseCounter::FormAttribute);\n    } else if (name == disabledAttr) {\n        bool oldDisabled = m_disabled;\n        m_disabled = !value.isNull();\n        if (oldDisabled != m_disabled)\n            disabledAttributeChanged();\n    } else if (name == readonlyAttr) {\n        bool wasReadOnly = m_isReadOnly;\n         m_isReadOnly = !value.isNull();\n         if (wasReadOnly != m_isReadOnly) {\n             setNeedsWillValidateCheck();\n            setNeedsStyleRecalc(SubtreeStyleChange, StyleChangeReasonForTracing::fromAttribute(name));\n             if (layoutObject())\n                 LayoutTheme::theme().controlStateChanged(*layoutObject(), ReadOnlyControlState);\n         }\n    } else if (name == requiredAttr) {\n        bool wasRequired = m_isRequired;\n        m_isRequired = !value.isNull();\n        if (wasRequired != m_isRequired)\n            requiredAttributeChanged();\n        UseCounter::count(document(), UseCounter::RequiredAttribute);\n    } else if (name == autofocusAttr) {\n        HTMLElement::parseAttribute(name, value);\n        UseCounter::count(document(), UseCounter::AutoFocusAttribute);\n    } else {\n        HTMLElement::parseAttribute(name, value);\n    }\n}\n", "target": 1, "idx": 185450}
{"func": " construct_command_line(struct manager_ctx *manager, struct server *server)\n {\n     static char cmd[BUF_SIZE];\n    char *method = manager->method;\n     int i;\n \n    build_config(working_dir, server);\n \n    if (server->method) method = server->method;\n     memset(cmd, 0, BUF_SIZE);\n     snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n \n     if (manager->acl != NULL) {\n         int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n    }\n    if (manager->timeout != NULL) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n    }\n#ifdef HAVE_SETRLIMIT\n    if (manager->nofile) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n    }\n#endif\n    if (manager->user != NULL) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n    }\n    if (manager->verbose) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n    }\n    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n    }\n    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n    }\n    if (server->fast_open[0] == 0 && manager->fast_open) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n    }\n    if (manager->ipv6first) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n    }\n    if (manager->mtu) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n    }\n    if (server->plugin == NULL && manager->plugin) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n    }\n    if (server->plugin_opts == NULL && manager->plugin_opts) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n    }\n    for (i = 0; i < manager->nameserver_num; i++) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n    }\n    for (i = 0; i < manager->host_num; i++) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n    }\n    {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n    }\n\n    if (verbose) {\n        LOGI(\"cmd: %s\", cmd);\n    }\n\n    return cmd;\n}\n", "target": 1, "idx": 180886}
{"func": "static bool check_underflow(const struct ip6t_entry *e)\n{\n \tconst struct xt_entry_target *t;\n \tunsigned int verdict;\n \n\tif (!unconditional(&e->ipv6))\n \t\treturn false;\n \tt = ip6t_get_target_c(e);\n \tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)\n\t\treturn false;\n\tverdict = ((struct xt_standard_target *)t)->verdict;\n\tverdict = -verdict - 1;\n\treturn verdict == NF_DROP || verdict == NF_ACCEPT;\n}\n", "target": 1, "idx": 180545}
{"func": "static void PerWorldBindingsRuntimeEnabledVoidMethodMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  TestObject* impl = V8TestObject::ToImpl(info.Holder());\n\n  impl->perWorldBindingsRuntimeEnabledVoidMethod();\n}\n", "target": 0, "idx": 147691}
{"func": "PaymentHandlerWebFlowViewController::CreateHeaderContentSeparatorView() {\n  if (show_progress_bar_)\n    return progress_bar_.get();\n  return separator_.get();\n}\n", "target": 0, "idx": 163939}
{"func": "static int __dn_setsockopt(struct socket *sock, int level,int optname, char __user *optval, unsigned int optlen, int flags)\n{\n\tstruct\tsock *sk = sock->sk;\n\tstruct dn_scp *scp = DN_SK(sk);\n\tlong timeo;\n\tunion {\n\t\tstruct optdata_dn opt;\n\t\tstruct accessdata_dn acc;\n\t\tint mode;\n\t\tunsigned long win;\n\t\tint val;\n\t\tunsigned char services;\n\t\tunsigned char info;\n\t} u;\n\tint err;\n\n\tif (optlen && !optval)\n\t\treturn -EINVAL;\n\n\tif (optlen > sizeof(u))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&u, optval, optlen))\n\t\treturn -EFAULT;\n\n\tswitch (optname) {\n\tcase DSO_CONDATA:\n\t\tif (sock->state == SS_CONNECTED)\n\t\t\treturn -EISCONN;\n\t\tif ((scp->state != DN_O) && (scp->state != DN_CR))\n\t\t\treturn -EINVAL;\n\n\t\tif (optlen != sizeof(struct optdata_dn))\n\t\t\treturn -EINVAL;\n\n\t\tif (le16_to_cpu(u.opt.opt_optl) > 16)\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(&scp->conndata_out, &u.opt, optlen);\n\t\tbreak;\n\n\tcase DSO_DISDATA:\n\t\tif (sock->state != SS_CONNECTED &&\n\t\t    scp->accept_mode == ACC_IMMED)\n\t\t\treturn -ENOTCONN;\n\n\t\tif (optlen != sizeof(struct optdata_dn))\n\t\t\treturn -EINVAL;\n\n\t\tif (le16_to_cpu(u.opt.opt_optl) > 16)\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(&scp->discdata_out, &u.opt, optlen);\n\t\tbreak;\n\n\tcase DSO_CONACCESS:\n\t\tif (sock->state == SS_CONNECTED)\n\t\t\treturn -EISCONN;\n\t\tif (scp->state != DN_O)\n\t\t\treturn -EINVAL;\n\n\t\tif (optlen != sizeof(struct accessdata_dn))\n\t\t\treturn -EINVAL;\n\n\t\tif ((u.acc.acc_accl > DN_MAXACCL) ||\n\t\t    (u.acc.acc_passl > DN_MAXACCL) ||\n\t\t    (u.acc.acc_userl > DN_MAXACCL))\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(&scp->accessdata, &u.acc, optlen);\n\t\tbreak;\n\n\tcase DSO_ACCEPTMODE:\n\t\tif (sock->state == SS_CONNECTED)\n\t\t\treturn -EISCONN;\n\t\tif (scp->state != DN_O)\n\t\t\treturn -EINVAL;\n\n\t\tif (optlen != sizeof(int))\n\t\t\treturn -EINVAL;\n\n\t\tif ((u.mode != ACC_IMMED) && (u.mode != ACC_DEFER))\n\t\t\treturn -EINVAL;\n\n\t\tscp->accept_mode = (unsigned char)u.mode;\n\t\tbreak;\n\n\tcase DSO_CONACCEPT:\n\t\tif (scp->state != DN_CR)\n\t\t\treturn -EINVAL;\n\t\ttimeo = sock_rcvtimeo(sk, 0);\n\t\terr = dn_confirm_accept(sk, &timeo, sk->sk_allocation);\n\t\treturn err;\n\n\tcase DSO_CONREJECT:\n\t\tif (scp->state != DN_CR)\n\t\t\treturn -EINVAL;\n\n\t\tscp->state = DN_DR;\n\t\tsk->sk_shutdown = SHUTDOWN_MASK;\n\t\tdn_nsp_send_disc(sk, 0x38, 0, sk->sk_allocation);\n\t\tbreak;\n\n\tdefault:\n#ifdef CONFIG_NETFILTER\n\t\treturn nf_setsockopt(sk, PF_DECnet, optname, optval, optlen);\n#endif\n\tcase DSO_LINKINFO:\n\tcase DSO_STREAM:\n\tcase DSO_SEQPACKET:\n\t\treturn -ENOPROTOOPT;\n\n\tcase DSO_MAXWINDOW:\n\t\tif (optlen != sizeof(unsigned long))\n\t\t\treturn -EINVAL;\n\t\tif (u.win > NSP_MAX_WINDOW)\n\t\t\tu.win = NSP_MAX_WINDOW;\n\t\tif (u.win == 0)\n\t\t\treturn -EINVAL;\n\t\tscp->max_window = u.win;\n\t\tif (scp->snd_window > u.win)\n\t\t\tscp->snd_window = u.win;\n\t\tbreak;\n\n\tcase DSO_NODELAY:\n\t\tif (optlen != sizeof(int))\n\t\t\treturn -EINVAL;\n\t\tif (scp->nonagle == 2)\n\t\t\treturn -EINVAL;\n\t\tscp->nonagle = (u.val == 0) ? 0 : 1;\n\t\t/* if (scp->nonagle == 1) { Push pending frames } */\n\t\tbreak;\n\n\tcase DSO_CORK:\n\t\tif (optlen != sizeof(int))\n\t\t\treturn -EINVAL;\n\t\tif (scp->nonagle == 1)\n\t\t\treturn -EINVAL;\n\t\tscp->nonagle = (u.val == 0) ? 0 : 2;\n\t\t/* if (scp->nonagle == 0) { Push pending frames } */\n\t\tbreak;\n\n\tcase DSO_SERVICES:\n\t\tif (optlen != sizeof(unsigned char))\n\t\t\treturn -EINVAL;\n\t\tif ((u.services & ~NSP_FC_MASK) != 0x01)\n\t\t\treturn -EINVAL;\n\t\tif ((u.services & NSP_FC_MASK) == NSP_FC_MASK)\n\t\t\treturn -EINVAL;\n\t\tscp->services_loc = u.services;\n\t\tbreak;\n\n\tcase DSO_INFO:\n\t\tif (optlen != sizeof(unsigned char))\n\t\t\treturn -EINVAL;\n\t\tif (u.info & 0xfc)\n\t\t\treturn -EINVAL;\n\t\tscp->info_loc = u.info;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n", "target": 0, "idx": 41466}
{"func": "get_princs_2_svc(gprincs_arg *arg, struct svc_req *rqstp)\n {\n     static gprincs_ret              ret;\n     char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n     OM_uint32                       minor_stat;\n     kadm5_server_handle_t           handle;\n     const char                      *errmsg = NULL;\n\n    xdr_free(xdr_gprincs_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->exp;\n    if (prime_arg == NULL)\n        prime_arg = \"*\";\n\n    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_LIST,\n                                                       NULL,\n                                                       NULL)) {\n        ret.code = KADM5_AUTH_LIST;\n        log_unauth(\"kadm5_get_principals\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code  = kadm5_get_principals((void *)handle,\n                                         arg->exp, &ret.princs,\n                                         &ret.count);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_get_principals\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n             krb5_free_error_message(handle->context, errmsg);\n \n     }\n     gss_release_buffer(&minor_stat, &client_name);\n     gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n     free_server_handle(handle);\n     return &ret;\n }\n", "target": 1, "idx": 180688}
{"func": "int kvm_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)\n{\n\tunsigned long old_cr4 = kvm_read_cr4(vcpu);\n\tunsigned long pdptr_bits = X86_CR4_PGE | X86_CR4_PSE |\n\t\t\t\t   X86_CR4_PAE | X86_CR4_SMEP;\n\tif (cr4 & CR4_RESERVED_BITS)\n\t\treturn 1;\n\n\tif (!guest_cpuid_has_xsave(vcpu) && (cr4 & X86_CR4_OSXSAVE))\n\t\treturn 1;\n\n\tif (!guest_cpuid_has_smep(vcpu) && (cr4 & X86_CR4_SMEP))\n\t\treturn 1;\n\n\tif (!guest_cpuid_has_fsgsbase(vcpu) && (cr4 & X86_CR4_RDWRGSFS))\n\t\treturn 1;\n\n\tif (is_long_mode(vcpu)) {\n\t\tif (!(cr4 & X86_CR4_PAE))\n\t\t\treturn 1;\n\t} else if (is_paging(vcpu) && (cr4 & X86_CR4_PAE)\n\t\t   && ((cr4 ^ old_cr4) & pdptr_bits)\n\t\t   && !load_pdptrs(vcpu, vcpu->arch.walk_mmu,\n\t\t\t\t   kvm_read_cr3(vcpu)))\n\t\treturn 1;\n\n\tif ((cr4 & X86_CR4_PCIDE) && !(old_cr4 & X86_CR4_PCIDE)) {\n\t\tif (!guest_cpuid_has_pcid(vcpu))\n\t\t\treturn 1;\n\n\t\t/* PCID can not be enabled when cr3[11:0]!=000H or EFER.LMA=0 */\n\t\tif ((kvm_read_cr3(vcpu) & X86_CR3_PCID_MASK) || !is_long_mode(vcpu))\n\t\t\treturn 1;\n\t}\n\n\tif (kvm_x86_ops->set_cr4(vcpu, cr4))\n\t\treturn 1;\n\n\tif (((cr4 ^ old_cr4) & pdptr_bits) ||\n\t    (!(cr4 & X86_CR4_PCIDE) && (old_cr4 & X86_CR4_PCIDE)))\n\t\tkvm_mmu_reset_context(vcpu);\n\n\tif ((cr4 ^ old_cr4) & X86_CR4_OSXSAVE)\n\t\tkvm_update_cpuid(vcpu);\n\n\treturn 0;\n}\n", "target": 0, "idx": 33287}
{"func": "static int mem_resize(jas_stream_memobj_t *m, int bufsize)\n {\n \tunsigned char *buf;\n \n\tassert(bufsize >= 0);\n \n\tJAS_DBGLOG(100, (\"mem_resize(%p, %d)\\n\", m, bufsize));\n \tif (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char))) &&\n \t  bufsize) {\n \t\tJAS_DBGLOG(100, (\"mem_resize realloc failed\\n\"));\n\t\treturn -1;\n\t}\n\tJAS_DBGLOG(100, (\"mem_resize realloc succeeded\\n\"));\n\tm->buf_ = buf;\n\tm->bufsize_ = bufsize;\n\treturn 0;\n}\n", "target": 1, "idx": 181922}
{"func": "Eina_Bool ewk_view_back(Evas_Object* ewkView)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, false);\n    return ewk_frame_back(smartData->main_frame);\n}\n", "target": 0, "idx": 107508}
{"func": "static void detach_task(struct task_struct *p, struct lb_env *env)\n{\n\tlockdep_assert_held(&env->src_rq->lock);\n\n\tp->on_rq = TASK_ON_RQ_MIGRATING;\n\tdeactivate_task(env->src_rq, p, DEQUEUE_NOCLOCK);\n\tset_task_cpu(p, env->dst_cpu);\n}\n", "target": 0, "idx": 92533}
{"func": "static int sctp_setsockopt_associnfo(struct sock *sk, char __user *optval, unsigned int optlen)\n{\n\n\tstruct sctp_assocparams assocparams;\n\tstruct sctp_association *asoc;\n\n\tif (optlen != sizeof(struct sctp_assocparams))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&assocparams, optval, optlen))\n\t\treturn -EFAULT;\n\n\tasoc = sctp_id2assoc(sk, assocparams.sasoc_assoc_id);\n\n\tif (!asoc && assocparams.sasoc_assoc_id && sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\t/* Set the values to the specific association */\n\tif (asoc) {\n\t\tif (assocparams.sasoc_asocmaxrxt != 0) {\n\t\t\t__u32 path_sum = 0;\n\t\t\tint   paths = 0;\n\t\t\tstruct sctp_transport *peer_addr;\n\n\t\t\tlist_for_each_entry(peer_addr, &asoc->peer.transport_addr_list,\n\t\t\t\t\ttransports) {\n\t\t\t\tpath_sum += peer_addr->pathmaxrxt;\n\t\t\t\tpaths++;\n\t\t\t}\n\n\t\t\t/* Only validate asocmaxrxt if we have more than\n\t\t\t * one path/transport.  We do this because path\n\t\t\t * retransmissions are only counted when we have more\n\t\t\t * then one path.\n\t\t\t */\n\t\t\tif (paths > 1 &&\n\t\t\t    assocparams.sasoc_asocmaxrxt > path_sum)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tasoc->max_retrans = assocparams.sasoc_asocmaxrxt;\n\t\t}\n\n\t\tif (assocparams.sasoc_cookie_life != 0) {\n\t\t\tasoc->cookie_life.tv_sec =\n\t\t\t\t\tassocparams.sasoc_cookie_life / 1000;\n\t\t\tasoc->cookie_life.tv_usec =\n\t\t\t\t\t(assocparams.sasoc_cookie_life % 1000)\n\t\t\t\t\t* 1000;\n\t\t}\n\t} else {\n\t\t/* Set the values to the endpoint */\n\t\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\t\tif (assocparams.sasoc_asocmaxrxt != 0)\n\t\t\tsp->assocparams.sasoc_asocmaxrxt =\n\t\t\t\t\t\tassocparams.sasoc_asocmaxrxt;\n\t\tif (assocparams.sasoc_cookie_life != 0)\n\t\t\tsp->assocparams.sasoc_cookie_life =\n\t\t\t\t\t\tassocparams.sasoc_cookie_life;\n\t}\n\treturn 0;\n}\n", "target": 0, "idx": 33038}
{"func": "   static void TearDownTestCase() {\n     vpx_free(input_ - 1);\n     input_ = NULL;\n     vpx_free(output_);\n     output_ = NULL;\n   }\n", "target": 1, "idx": 188529}
{"func": "void BlacklistAddOneDll(const wchar_t* module_name,\n                        bool check_in_browser,\n                        sandbox::TargetPolicy* policy) {\n  HMODULE module = check_in_browser ? ::GetModuleHandleW(module_name) : NULL;\n  if (!module) {\n    std::wstring name(module_name);\n    size_t period = name.rfind(L'.');\n    DCHECK_NE(std::string::npos, period);\n    DCHECK_LE(3U, (name.size() - period));\n    if (period <= 8)\n      return;\n    for (int ix = 0; ix < 3; ++ix) {\n      const wchar_t suffix[] = {'~', ('1' + ix), 0};\n      std::wstring alt_name = name.substr(0, 6) + suffix;\n      alt_name += name.substr(period, name.size());\n      if (check_in_browser) {\n        module = ::GetModuleHandleW(alt_name.c_str());\n        if (!module)\n          return;\n        if (!IsExpandedModuleName(module, module_name))\n          return;\n      }\n      policy->AddDllToUnload(alt_name.c_str());\n    }\n  }\n  policy->AddDllToUnload(module_name);\n  DVLOG(1) << \"dll to unload found: \" << module_name;\n  return;\n}\n", "target": 0, "idx": 113826}
{"func": " SendTabToSelfInfoBarDelegate::SendTabToSelfInfoBarDelegate(\n     const SendTabToSelfEntry* entry) {\n   entry_ = entry;\n }\n", "target": 1, "idx": 186511}
{"func": "ldp_pdu_print(netdissect_options *ndo,\n              register const u_char *pptr)\n{\n    const struct ldp_common_header *ldp_com_header;\n    const struct ldp_msg_header *ldp_msg_header;\n    const u_char *tptr,*msg_tptr;\n    u_short tlen;\n    u_short pdu_len,msg_len,msg_type,msg_tlen;\n    int hexdump,processed;\n\n    ldp_com_header = (const struct ldp_common_header *)pptr;\n    ND_TCHECK(*ldp_com_header);\n\n    /*\n     * Sanity checking of the header.\n     */\n    if (EXTRACT_16BITS(&ldp_com_header->version) != LDP_VERSION) {\n\tND_PRINT((ndo, \"%sLDP version %u packet not supported\",\n               (ndo->ndo_vflag < 1) ? \"\" : \"\\n\\t\",\n               EXTRACT_16BITS(&ldp_com_header->version)));\n\treturn 0;\n    }\n\n    pdu_len = EXTRACT_16BITS(&ldp_com_header->pdu_length);\n    if (pdu_len < sizeof(const struct ldp_common_header)-4) {\n        /* length too short */\n        ND_PRINT((ndo, \"%sLDP, pdu-length: %u (too short, < %u)\",\n               (ndo->ndo_vflag < 1) ? \"\" : \"\\n\\t\",\n               pdu_len,\n               (u_int)(sizeof(const struct ldp_common_header)-4)));\n        return 0;\n    }\n\n    /* print the LSR-ID, label-space & length */\n    ND_PRINT((ndo, \"%sLDP, Label-Space-ID: %s:%u, pdu-length: %u\",\n           (ndo->ndo_vflag < 1) ? \"\" : \"\\n\\t\",\n           ipaddr_string(ndo, &ldp_com_header->lsr_id),\n           EXTRACT_16BITS(&ldp_com_header->label_space),\n           pdu_len));\n\n    /* bail out if non-verbose */\n    if (ndo->ndo_vflag < 1)\n        return 0;\n\n    /* ok they seem to want to know everything - lets fully decode it */\n    tptr = pptr + sizeof(const struct ldp_common_header);\n    tlen = pdu_len - (sizeof(const struct ldp_common_header)-4);\t/* Type & Length fields not included */\n\n    while(tlen>0) {\n        /* did we capture enough for fully decoding the msg header ? */\n        ND_TCHECK2(*tptr, sizeof(struct ldp_msg_header));\n\n        ldp_msg_header = (const struct ldp_msg_header *)tptr;\n        msg_len=EXTRACT_16BITS(ldp_msg_header->length);\n        msg_type=LDP_MASK_MSG_TYPE(EXTRACT_16BITS(ldp_msg_header->type));\n\n        if (msg_len < sizeof(struct ldp_msg_header)-4) {\n            /* length too short */\n            /* FIXME vendor private / experimental check */\n            ND_PRINT((ndo, \"\\n\\t  %s Message (0x%04x), length: %u (too short, < %u)\",\n                   tok2str(ldp_msg_values,\n                           \"Unknown\",\n                           msg_type),\n                   msg_type,\n                   msg_len,\n                   (u_int)(sizeof(struct ldp_msg_header)-4)));\n            return 0;\n        }\n\n        /* FIXME vendor private / experimental check */\n        ND_PRINT((ndo, \"\\n\\t  %s Message (0x%04x), length: %u, Message ID: 0x%08x, Flags: [%s if unknown]\",\n               tok2str(ldp_msg_values,\n                       \"Unknown\",\n                       msg_type),\n               msg_type,\n               msg_len,\n               EXTRACT_32BITS(&ldp_msg_header->id),\n               LDP_MASK_U_BIT(EXTRACT_16BITS(&ldp_msg_header->type)) ? \"continue processing\" : \"ignore\"));\n\n        msg_tptr=tptr+sizeof(struct ldp_msg_header);\n        msg_tlen=msg_len-(sizeof(struct ldp_msg_header)-4); /* Type & Length fields not included */\n\n        /* did we capture enough for fully decoding the message ? */\n        ND_TCHECK2(*tptr, msg_len);\n        hexdump=FALSE;\n\n        switch(msg_type) {\n\n        case LDP_MSG_NOTIF:\n        case LDP_MSG_HELLO:\n        case LDP_MSG_INIT:\n        case LDP_MSG_KEEPALIVE:\n        case LDP_MSG_ADDRESS:\n        case LDP_MSG_LABEL_MAPPING:\n        case LDP_MSG_ADDRESS_WITHDRAW:\n        case LDP_MSG_LABEL_WITHDRAW:\n            while(msg_tlen >= 4) {\n                processed = ldp_tlv_print(ndo, msg_tptr, msg_tlen);\n                if (processed == 0)\n                    break;\n                msg_tlen-=processed;\n                msg_tptr+=processed;\n            }\n            break;\n\n        /*\n         *  FIXME those are the defined messages that lack a decoder\n         *  you are welcome to contribute code ;-)\n         */\n\n        case LDP_MSG_LABEL_REQUEST:\n        case LDP_MSG_LABEL_RELEASE:\n        case LDP_MSG_LABEL_ABORT_REQUEST:\n\n        default:\n            if (ndo->ndo_vflag <= 1)\n                print_unknown_data(ndo, msg_tptr, \"\\n\\t  \", msg_tlen);\n            break;\n        }\n        /* do we want to see an additionally hexdump ? */\n        if (ndo->ndo_vflag > 1 || hexdump==TRUE)\n            print_unknown_data(ndo, tptr+sizeof(struct ldp_msg_header), \"\\n\\t  \",\n                               msg_len);\n\n        tptr += msg_len+4;\n        tlen -= msg_len+4;\n     }\n     return pdu_len+4;\n trunc:\n    ND_PRINT((ndo, \"\\n\\t\\t packet exceeded snapshot\"));\n     return 0;\n }\n", "target": 1, "idx": 183024}
{"func": "v8::Handle<v8::Value> V8WebGLRenderingContext::getAttachedShadersCallback(const v8::Arguments& args)\n{\n     INC_STATS(\"DOM.WebGLRenderingContext.getAttachedShaders()\");\n \n     if (args.Length() < 1)\n        return V8Proxy::throwNotEnoughArgumentsError();\n \n     ExceptionCode ec = 0;\n     WebGLRenderingContext* context = V8WebGLRenderingContext::toNative(args.Holder());\n    if (args.Length() > 0 && !isUndefinedOrNull(args[0]) && !V8WebGLProgram::HasInstance(args[0])) {\n        V8Proxy::throwTypeError();\n        return notHandledByInterceptor();\n    }\n    WebGLProgram* program = V8WebGLProgram::HasInstance(args[0]) ? V8WebGLProgram::toNative(v8::Handle<v8::Object>::Cast(args[0])) : 0;\n    Vector<RefPtr<WebGLShader> > shaders;\n    bool succeed = context->getAttachedShaders(program, shaders, ec);\n    if (ec) {\n        V8Proxy::setDOMException(ec, args.GetIsolate());\n        return v8::Null();\n    }\n    if (!succeed)\n        return v8::Null();\n    v8::Local<v8::Array> array = v8::Array::New(shaders.size());\n    for (size_t ii = 0; ii < shaders.size(); ++ii)\n        array->Set(v8::Integer::New(ii), toV8(shaders[ii].get(), args.GetIsolate()));\n    return array;\n}\n", "target": 1, "idx": 184812}
{"func": "static int pn_recvmsg(struct kiocb *iocb, struct sock *sk,\n\t\t\tstruct msghdr *msg, size_t len, int noblock,\n\t\t\tint flags, int *addr_len)\n{\n\tstruct sk_buff *skb = NULL;\n\tstruct sockaddr_pn sa;\n\tint rval = -EOPNOTSUPP;\n\tint copylen;\n\n\tif (flags & ~(MSG_PEEK|MSG_TRUNC|MSG_DONTWAIT|MSG_NOSIGNAL|\n \t\t\tMSG_CMSG_COMPAT))\n \t\tgoto out_nofree;\n \n\tif (addr_len)\n\t\t*addr_len = sizeof(sa);\n \tskb = skb_recv_datagram(sk, flags, noblock, &rval);\n \tif (skb == NULL)\n \t\tgoto out_nofree;\n\n\tpn_skb_get_src_sockaddr(skb, &sa);\n\n\tcopylen = skb->len;\n\tif (len < copylen) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopylen = len;\n\t}\n\n\trval = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copylen);\n\tif (rval) {\n\t\trval = -EFAULT;\n\t\tgoto out;\n\t}\n \n \trval = (flags & MSG_TRUNC) ? skb->len : copylen;\n \n\tif (msg->msg_name != NULL)\n\t\tmemcpy(msg->msg_name, &sa, sizeof(struct sockaddr_pn));\n \n out:\n \tskb_free_datagram(sk, skb);\n\nout_nofree:\n\treturn rval;\n}\n", "target": 1, "idx": 179655}
{"func": "static int decode_frame_common(AVCodecContext *avctx, PNGDecContext *s,\n                               AVFrame *p, AVPacket *avpkt)\n{\n    AVDictionary *metadata  = NULL;\n    uint32_t tag, length;\n    int decode_next_dat = 0;\n    int ret;\n\n    for (;;) {\n        length = bytestream2_get_bytes_left(&s->gb);\n        if (length <= 0) {\n\n            if (avctx->codec_id == AV_CODEC_ID_PNG &&\n                avctx->skip_frame == AVDISCARD_ALL) {\n                av_frame_set_metadata(p, metadata);\n                return 0;\n            }\n\n            if (CONFIG_APNG_DECODER && avctx->codec_id == AV_CODEC_ID_APNG && length == 0) {\n                if (!(s->state & PNG_IDAT))\n                    return 0;\n                else\n                    goto exit_loop;\n            }\n            av_log(avctx, AV_LOG_ERROR, \"%d bytes left\\n\", length);\n            if (   s->state & PNG_ALLIMAGE\n                && avctx->strict_std_compliance <= FF_COMPLIANCE_NORMAL)\n                goto exit_loop;\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n\n        length = bytestream2_get_be32(&s->gb);\n        if (length > 0x7fffffff || length > bytestream2_get_bytes_left(&s->gb)) {\n            av_log(avctx, AV_LOG_ERROR, \"chunk too big\\n\");\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n        tag = bytestream2_get_le32(&s->gb);\n        if (avctx->debug & FF_DEBUG_STARTCODE)\n            av_log(avctx, AV_LOG_DEBUG, \"png: tag=%c%c%c%c length=%u\\n\",\n                (tag & 0xff),\n                ((tag >> 8) & 0xff),\n                ((tag >> 16) & 0xff),\n                ((tag >> 24) & 0xff), length);\n\n        if (avctx->codec_id == AV_CODEC_ID_PNG &&\n            avctx->skip_frame == AVDISCARD_ALL) {\n            switch(tag) {\n            case MKTAG('I', 'H', 'D', 'R'):\n            case MKTAG('p', 'H', 'Y', 's'):\n            case MKTAG('t', 'E', 'X', 't'):\n            case MKTAG('I', 'D', 'A', 'T'):\n            case MKTAG('t', 'R', 'N', 'S'):\n                break;\n            default:\n                goto skip_tag;\n            }\n        }\n\n        switch (tag) {\n        case MKTAG('I', 'H', 'D', 'R'):\n            if ((ret = decode_ihdr_chunk(avctx, s, length)) < 0)\n                goto fail;\n            break;\n        case MKTAG('p', 'H', 'Y', 's'):\n            if ((ret = decode_phys_chunk(avctx, s)) < 0)\n                goto fail;\n            break;\n        case MKTAG('f', 'c', 'T', 'L'):\n            if (!CONFIG_APNG_DECODER || avctx->codec_id != AV_CODEC_ID_APNG)\n                goto skip_tag;\n            if ((ret = decode_fctl_chunk(avctx, s, length)) < 0)\n                goto fail;\n            decode_next_dat = 1;\n            break;\n        case MKTAG('f', 'd', 'A', 'T'):\n            if (!CONFIG_APNG_DECODER || avctx->codec_id != AV_CODEC_ID_APNG)\n                goto skip_tag;\n            if (!decode_next_dat) {\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n            bytestream2_get_be32(&s->gb);\n            length -= 4;\n            /* fallthrough */\n        case MKTAG('I', 'D', 'A', 'T'):\n            if (CONFIG_APNG_DECODER && avctx->codec_id == AV_CODEC_ID_APNG && !decode_next_dat)\n                goto skip_tag;\n            if ((ret = decode_idat_chunk(avctx, s, length, p)) < 0)\n                goto fail;\n            break;\n        case MKTAG('P', 'L', 'T', 'E'):\n            if (decode_plte_chunk(avctx, s, length) < 0)\n                goto skip_tag;\n            break;\n        case MKTAG('t', 'R', 'N', 'S'):\n            if (decode_trns_chunk(avctx, s, length) < 0)\n                goto skip_tag;\n            break;\n        case MKTAG('t', 'E', 'X', 't'):\n            if (decode_text_chunk(s, length, 0, &metadata) < 0)\n                av_log(avctx, AV_LOG_WARNING, \"Broken tEXt chunk\\n\");\n            bytestream2_skip(&s->gb, length + 4);\n            break;\n        case MKTAG('z', 'T', 'X', 't'):\n            if (decode_text_chunk(s, length, 1, &metadata) < 0)\n                av_log(avctx, AV_LOG_WARNING, \"Broken zTXt chunk\\n\");\n            bytestream2_skip(&s->gb, length + 4);\n            break;\n        case MKTAG('s', 'T', 'E', 'R'): {\n            int mode = bytestream2_get_byte(&s->gb);\n            AVStereo3D *stereo3d = av_stereo3d_create_side_data(p);\n            if (!stereo3d)\n                goto fail;\n\n            if (mode == 0 || mode == 1) {\n                stereo3d->type  = AV_STEREO3D_SIDEBYSIDE;\n                stereo3d->flags = mode ? 0 : AV_STEREO3D_FLAG_INVERT;\n            } else {\n                 av_log(avctx, AV_LOG_WARNING,\n                        \"Unknown value in sTER chunk (%d)\\n\", mode);\n            }\n            bytestream2_skip(&s->gb, 4); /* crc */\n            break;\n        }\n        case MKTAG('I', 'E', 'N', 'D'):\n            if (!(s->state & PNG_ALLIMAGE))\n                av_log(avctx, AV_LOG_ERROR, \"IEND without all image\\n\");\n            if (!(s->state & (PNG_ALLIMAGE|PNG_IDAT))) {\n                ret = AVERROR_INVALIDDATA;\n                goto fail;\n            }\n            bytestream2_skip(&s->gb, 4); /* crc */\n            goto exit_loop;\n        default:\n            /* skip tag */\nskip_tag:\n            bytestream2_skip(&s->gb, length + 4);\n            break;\n        }\n    }\nexit_loop:\n    if (avctx->codec_id == AV_CODEC_ID_PNG &&\n        avctx->skip_frame == AVDISCARD_ALL) {\n        av_frame_set_metadata(p, metadata);\n        return 0;\n    }\n\n    if (s->bits_per_pixel <= 4)\n        handle_small_bpp(s, p);\n\n    /* apply transparency if needed */\n    if (s->has_trns && s->color_type != PNG_COLOR_TYPE_PALETTE) {\n        size_t byte_depth = s->bit_depth > 8 ? 2 : 1;\n         size_t raw_bpp = s->bpp - byte_depth;\n         unsigned x, y;\n \n         for (y = 0; y < s->height; ++y) {\n             uint8_t *row = &s->image_buf[s->image_linesize * y];\n \n            /* since we're updating in-place, we have to go from right to left */\n            for (x = s->width; x > 0; --x) {\n                uint8_t *pixel = &row[s->bpp * (x - 1)];\n                memmove(pixel, &row[raw_bpp * (x - 1)], raw_bpp);\n\n                if (!memcmp(pixel, s->transparent_color_be, raw_bpp)) {\n                    memset(&pixel[raw_bpp], 0, byte_depth);\n                } else {\n                    memset(&pixel[raw_bpp], 0xff, byte_depth);\n                }\n            }\n        }\n    }\n\n    /* handle P-frames only if a predecessor frame is available */\n    if (s->last_picture.f->data[0]) {\n        if (   !(avpkt->flags & AV_PKT_FLAG_KEY) && avctx->codec_tag != AV_RL32(\"MPNG\")\n            && s->last_picture.f->width == p->width\n            && s->last_picture.f->height== p->height\n            && s->last_picture.f->format== p->format\n         ) {\n            if (CONFIG_PNG_DECODER && avctx->codec_id != AV_CODEC_ID_APNG)\n                handle_p_frame_png(s, p);\n            else if (CONFIG_APNG_DECODER &&\n                     avctx->codec_id == AV_CODEC_ID_APNG &&\n                     (ret = handle_p_frame_apng(avctx, s, p)) < 0)\n                goto fail;\n        }\n    }\n    ff_thread_report_progress(&s->picture, INT_MAX, 0);\n    ff_thread_report_progress(&s->previous_picture, INT_MAX, 0);\n\n    av_frame_set_metadata(p, metadata);\n    metadata   = NULL;\n    return 0;\n\nfail:\n    av_dict_free(&metadata);\n    ff_thread_report_progress(&s->picture, INT_MAX, 0);\n    ff_thread_report_progress(&s->previous_picture, INT_MAX, 0);\n    return ret;\n}\n", "target": 1, "idx": 181419}
{"func": "static int update_open_stateid(struct nfs4_state *state, nfs4_stateid *open_stateid, nfs4_stateid *delegation, int open_flags)\n {\n \tstruct nfs_inode *nfsi = NFS_I(state->inode);\n \tstruct nfs_delegation *deleg_cur;\n \tint ret = 0;\n \n\topen_flags &= (FMODE_READ|FMODE_WRITE);\n \n \trcu_read_lock();\n \tdeleg_cur = rcu_dereference(nfsi->delegation);\n\tif (deleg_cur == NULL)\n\t\tgoto no_delegation;\n \n \tspin_lock(&deleg_cur->lock);\n \tif (nfsi->delegation != deleg_cur ||\n\t    (deleg_cur->type & open_flags) != open_flags)\n \t\tgoto no_delegation_unlock;\n \n \tif (delegation == NULL)\n\t\tdelegation = &deleg_cur->stateid;\n\telse if (memcmp(deleg_cur->stateid.data, delegation->data, NFS4_STATEID_SIZE) != 0)\n \t\tgoto no_delegation_unlock;\n \n \tnfs_mark_delegation_referenced(deleg_cur);\n\t__update_open_stateid(state, open_stateid, &deleg_cur->stateid, open_flags);\n \tret = 1;\n no_delegation_unlock:\n \tspin_unlock(&deleg_cur->lock);\n no_delegation:\n \trcu_read_unlock();\n \n \tif (!ret && open_stateid != NULL) {\n\t\t__update_open_stateid(state, open_stateid, NULL, open_flags);\n \t\tret = 1;\n \t}\n \n \treturn ret;\n }\n", "target": 1, "idx": 178880}
{"func": "  ~ConnectionFilterController() {}\n", "target": 0, "idx": 139236}
{"func": "static int set_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)\n {\n\treturn usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, 0),\n\t\t\t       RTL8150_REQ_SET_REGS, RTL8150_REQT_WRITE,\n\t\t\t       indx, 0, data, size, 500);\n }\n", "target": 1, "idx": 181387}
{"func": "void __init idt_setup_early_traps(void)\n{\n\tidt_setup_from_table(idt_table, early_idts, ARRAY_SIZE(early_idts),\n\t\t\t     true);\n\tload_idt(&idt_descr);\n}\n", "target": 0, "idx": 83477}
{"func": "void PPB_URLLoader_Impl::RunCallback(int32_t result) {\n  if (!pending_callback_.get()) {\n     CHECK(main_document_loader_);\n     return;\n   }\n   TrackedCallback::ClearAndRun(&pending_callback_, result);\n }\n", "target": 1, "idx": 184489}
{"func": "static void xen_netbk_tx_submit(struct xen_netbk *netbk)\n{\n\tstruct gnttab_copy *gop = netbk->tx_copy_ops;\n\tstruct sk_buff *skb;\n\n\twhile ((skb = __skb_dequeue(&netbk->tx_queue)) != NULL) {\n\t\tstruct xen_netif_tx_request *txp;\n\t\tstruct xenvif *vif;\n\t\tu16 pending_idx;\n\t\tunsigned data_len;\n\n\t\tpending_idx = *((u16 *)skb->data);\n\t\tvif = netbk->pending_tx_info[pending_idx].vif;\n\t\ttxp = &netbk->pending_tx_info[pending_idx].req;\n\n\t\t/* Check the remap error code. */\n\t\tif (unlikely(xen_netbk_tx_check_gop(netbk, skb, &gop))) {\n\t\t\tnetdev_dbg(vif->dev, \"netback grant failed.\\n\");\n\t\t\tskb_shinfo(skb)->nr_frags = 0;\n\t\t\tkfree_skb(skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdata_len = skb->len;\n\t\tmemcpy(skb->data,\n\t\t       (void *)(idx_to_kaddr(netbk, pending_idx)|txp->offset),\n\t\t       data_len);\n\t\tif (data_len < txp->size) {\n\t\t\t/* Append the packet payload as a fragment. */\n\t\t\ttxp->offset += data_len;\n\t\t\ttxp->size -= data_len;\n\t\t} else {\n\t\t\t/* Schedule a response immediately. */\n\t\t\txen_netbk_idx_release(netbk, pending_idx);\n\t\t}\n\n\t\tif (txp->flags & XEN_NETTXF_csum_blank)\n\t\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n\t\telse if (txp->flags & XEN_NETTXF_data_validated)\n\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\n\t\txen_netbk_fill_frags(netbk, skb);\n\n\t\t/*\n\t\t * If the initial fragment was < PKT_PROT_LEN then\n\t\t * pull through some bytes from the other fragments to\n\t\t * increase the linear region to PKT_PROT_LEN bytes.\n\t\t */\n\t\tif (skb_headlen(skb) < PKT_PROT_LEN && skb_is_nonlinear(skb)) {\n\t\t\tint target = min_t(int, skb->len, PKT_PROT_LEN);\n\t\t\t__pskb_pull_tail(skb, target - skb_headlen(skb));\n\t\t}\n\n\t\tskb->dev      = vif->dev;\n\t\tskb->protocol = eth_type_trans(skb, skb->dev);\n\n\t\tif (checksum_setup(vif, skb)) {\n\t\t\tnetdev_dbg(vif->dev,\n\t\t\t\t   \"Can't setup checksum in net_tx_action\\n\");\n\t\t\tkfree_skb(skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\tvif->dev->stats.rx_bytes += skb->len;\n\t\tvif->dev->stats.rx_packets++;\n\n\t\txenvif_receive_skb(vif, skb);\n\t}\n}\n", "target": 0, "idx": 34043}
{"func": "static int init_nss_hash(struct crypto_instance *instance)\n{\n\tPK11SlotInfo*\thash_slot = NULL;\n\tSECItem\t\thash_param;\n\n\tif (!hash_to_nss[instance->crypto_hash_type]) {\n\t\treturn 0;\n \t}\n \n \thash_param.type = siBuffer;\n\thash_param.data = 0;\n\thash_param.len = 0;\n \n \thash_slot = PK11_GetBestSlot(hash_to_nss[instance->crypto_hash_type], NULL);\n \tif (hash_slot == NULL) {\n\t\tlog_printf(instance->log_level_security, \"Unable to find security slot (err %d)\",\n\t\t\t   PR_GetError());\n\t\treturn -1;\n\t}\n\n\tinstance->nss_sym_key_sign = PK11_ImportSymKey(hash_slot,\n\t\t\t\t\t\t       hash_to_nss[instance->crypto_hash_type],\n\t\t\t\t\t\t       PK11_OriginUnwrap, CKA_SIGN,\n\t\t\t\t\t\t       &hash_param, NULL);\n\tif (instance->nss_sym_key_sign == NULL) {\n\t\tlog_printf(instance->log_level_security, \"Failure to import key into NSS (err %d)\",\n\t\t\t   PR_GetError());\n\t\treturn -1;\n\t}\n\n\tPK11_FreeSlot(hash_slot);\n\n\treturn 0;\n}\n", "target": 1, "idx": 179718}
{"func": "static void init_once(void *foo)\n{\n\tstruct ext4_inode_info *ei = (struct ext4_inode_info *) foo;\n\n \tINIT_LIST_HEAD(&ei->i_orphan);\n \tinit_rwsem(&ei->xattr_sem);\n \tinit_rwsem(&ei->i_data_sem);\n \tinode_init_once(&ei->vfs_inode);\n }\n", "target": 1, "idx": 180664}
{"func": "void ContainerNode::setFocus(bool received)\n{\n    if (ShadowRoot* root = containingShadowRoot()) {\n        if (root->type() != ShadowRootType::UserAgent)\n            shadowHost()->setFocus(received);\n    }\n\n    if (isElementNode() && document().focusedElement() && document().focusedElement() != this) {\n        if (toElement(this)->authorShadowRoot())\n            received = received && toElement(this)->authorShadowRoot()->delegatesFocus();\n    }\n\n    if (focused() == received)\n        return;\n\n    Node::setFocus(received);\n\n    focusStateChanged();\n\n    if (layoutObject() || received)\n        return;\n\n    if (isElementNode() && toElement(this)->childrenOrSiblingsAffectedByFocus() && styleChangeType() < SubtreeStyleChange)\n        document().styleEngine().pseudoStateChangedForElement(CSSSelector::PseudoFocus, *toElement(this));\n    else\n        setNeedsStyleRecalc(LocalStyleChange, StyleChangeReasonForTracing::createWithExtraData(StyleChangeReason::PseudoClass, StyleChangeExtraData::Focus));\n}\n", "target": 0, "idx": 135971}
{"func": "void ChromeDownloadManagerDelegate::RequestConfirmation(\n    DownloadItem* download,\n    const base::FilePath& suggested_path,\n    DownloadConfirmationReason reason,\n    const DownloadTargetDeterminerDelegate::ConfirmationCallback& callback) {\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n  DCHECK(!download->IsTransient());\n\n#if defined(OS_ANDROID)\n  switch (reason) {\n    case DownloadConfirmationReason::NONE:\n      NOTREACHED();\n      return;\n\n    case DownloadConfirmationReason::TARGET_PATH_NOT_WRITEABLE:\n      DownloadManagerService::OnDownloadCanceled(\n          download, DownloadController::CANCEL_REASON_NO_EXTERNAL_STORAGE);\n      callback.Run(DownloadConfirmationResult::CANCELED, base::FilePath());\n      return;\n\n    case DownloadConfirmationReason::NAME_TOO_LONG:\n    case DownloadConfirmationReason::TARGET_NO_SPACE:\n\n    case DownloadConfirmationReason::SAVE_AS:\n    case DownloadConfirmationReason::PREFERENCE:\n      callback.Run(DownloadConfirmationResult::CONTINUE_WITHOUT_CONFIRMATION,\n                   suggested_path);\n      return;\n\n    case DownloadConfirmationReason::TARGET_CONFLICT:\n      if (download->GetWebContents()) {\n        android::ChromeDuplicateDownloadInfoBarDelegate::Create(\n            InfoBarService::FromWebContents(download->GetWebContents()),\n            download, suggested_path, callback);\n        return;\n      }\n\n    case DownloadConfirmationReason::UNEXPECTED:\n      DownloadManagerService::OnDownloadCanceled(\n          download,\n          DownloadController::CANCEL_REASON_CANNOT_DETERMINE_DOWNLOAD_TARGET);\n      callback.Run(DownloadConfirmationResult::CANCELED, base::FilePath());\n      return;\n  }\n#else   // !OS_ANDROID\n  DownloadFilePicker::ShowFilePicker(download, suggested_path, callback);\n#endif  // !OS_ANDROID\n}\n", "target": 0, "idx": 159072}
{"func": "static int ip_error(struct sk_buff *skb)\n{\n\tstruct in_device *in_dev = __in_dev_get_rcu(skb->dev);\n\tstruct rtable *rt = skb_rtable(skb);\n\tstruct inet_peer *peer;\n\tunsigned long now;\n\tstruct net *net;\n\tbool send;\n\tint code;\n\n\t/* IP on this device is disabled. */\n\tif (!in_dev)\n\t\tgoto out;\n\n\tnet = dev_net(rt->dst.dev);\n\tif (!IN_DEV_FORWARD(in_dev)) {\n\t\tswitch (rt->dst.error) {\n\t\tcase EHOSTUNREACH:\n\t\t\t__IP_INC_STATS(net, IPSTATS_MIB_INADDRERRORS);\n\t\t\tbreak;\n\n\t\tcase ENETUNREACH:\n\t\t\t__IP_INC_STATS(net, IPSTATS_MIB_INNOROUTES);\n\t\t\tbreak;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tswitch (rt->dst.error) {\n\tcase EINVAL:\n\tdefault:\n\t\tgoto out;\n\tcase EHOSTUNREACH:\n\t\tcode = ICMP_HOST_UNREACH;\n\t\tbreak;\n\tcase ENETUNREACH:\n\t\tcode = ICMP_NET_UNREACH;\n\t\t__IP_INC_STATS(net, IPSTATS_MIB_INNOROUTES);\n\t\tbreak;\n\tcase EACCES:\n\t\tcode = ICMP_PKT_FILTERED;\n\t\tbreak;\n\t}\n\n\tpeer = inet_getpeer_v4(net->ipv4.peers, ip_hdr(skb)->saddr,\n\t\t\t       l3mdev_master_ifindex(skb->dev), 1);\n\n\tsend = true;\n\tif (peer) {\n\t\tnow = jiffies;\n\t\tpeer->rate_tokens += now - peer->rate_last;\n\t\tif (peer->rate_tokens > ip_rt_error_burst)\n\t\t\tpeer->rate_tokens = ip_rt_error_burst;\n\t\tpeer->rate_last = now;\n\t\tif (peer->rate_tokens >= ip_rt_error_cost)\n\t\t\tpeer->rate_tokens -= ip_rt_error_cost;\n\t\telse\n\t\t\tsend = false;\n\t\tinet_putpeer(peer);\n\t}\n\tif (send)\n\t\ticmp_send(skb, ICMP_DEST_UNREACH, code, 0);\n\nout:\tkfree_skb(skb);\n\treturn 0;\n}\n", "target": 0, "idx": 62050}
{"func": " lookup_bytestring(netdissect_options *ndo, register const u_char *bs,\n \t\t  const unsigned int nlen)\n {\n\tstruct enamemem *tp;\n \tregister u_int i, j, k;\n \n \tif (nlen >= 6) {\n\t\tk = (bs[0] << 8) | bs[1];\n\t\tj = (bs[2] << 8) | bs[3];\n\t\ti = (bs[4] << 8) | bs[5];\n\t} else if (nlen >= 4) {\n\t\tk = (bs[0] << 8) | bs[1];\n\t\tj = (bs[2] << 8) | bs[3];\n\t\ti = 0;\n\t} else\n \t\ti = j = k = 0;\n \n \ttp = &bytestringtable[(i ^ j) & (HASHNAMESIZE-1)];\n\twhile (tp->e_nxt)\n\t\tif (tp->e_addr0 == i &&\n\t\t    tp->e_addr1 == j &&\n\t\t    tp->e_addr2 == k &&\n\t\t    memcmp((const char *)bs, (const char *)(tp->e_bs), nlen) == 0)\n \t\t\treturn tp;\n \t\telse\n\t\t\ttp = tp->e_nxt;\n \n\ttp->e_addr0 = i;\n\ttp->e_addr1 = j;\n\ttp->e_addr2 = k;\n \n\ttp->e_bs = (u_char *) calloc(1, nlen + 1);\n\tif (tp->e_bs == NULL)\n \t\t(*ndo->ndo_error)(ndo, \"lookup_bytestring: calloc\");\n \n\tmemcpy(tp->e_bs, bs, nlen);\n\ttp->e_nxt = (struct enamemem *)calloc(1, sizeof(*tp));\n\tif (tp->e_nxt == NULL)\n \t\t(*ndo->ndo_error)(ndo, \"lookup_bytestring: calloc\");\n \n \treturn tp;\n}\n", "target": 1, "idx": 181132}
{"func": "static void checkListProperties(sqlite3 *db){\n  sqlite3 *p;\n  for(p=sqlite3BlockedList; p; p=p->pNextBlocked){\n    int seen = 0;\n    sqlite3 *p2;\n\n    /* Verify property (1) */\n    assert( p->pUnlockConnection || p->pBlockingConnection );\n\n    /* Verify property (2) */\n    for(p2=sqlite3BlockedList; p2!=p; p2=p2->pNextBlocked){\n      if( p2->xUnlockNotify==p->xUnlockNotify ) seen = 1;\n      assert( p2->xUnlockNotify==p->xUnlockNotify || !seen );\n      assert( db==0 || p->pUnlockConnection!=db );\n      assert( db==0 || p->pBlockingConnection!=db );\n    }\n  }\n}\n", "target": 0, "idx": 149061}
{"func": "static void raisesExceptionLongAttributeAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)\n{\n    TRACE_EVENT_SET_SAMPLING_STATE(\"Blink\", \"DOMGetter\");\n    TestObjectPythonV8Internal::raisesExceptionLongAttributeAttributeGetter(info);\n    TRACE_EVENT_SET_SAMPLING_STATE(\"V8\", \"V8Execution\");\n}\n", "target": 0, "idx": 131615}
{"func": " static void DeleteImpl(Handle<JSObject> obj, uint32_t entry) {\n Handle<SeededNumberDictionary> dict(\n SeededNumberDictionary::cast(obj->elements()));\n uint32_t index = GetIndexForEntryImpl(*dict, entry);\n Handle<Object> result = SeededNumberDictionary::DeleteProperty(dict, entry);\n    USE(result);\n    DCHECK(result->IsTrue(dict->GetIsolate()));\n Handle<FixedArray> new_elements =\n SeededNumberDictionary::Shrink(dict, index);\n    obj->set_elements(*new_elements);\n }\n", "target": 0, "idx": 176239}
{"func": "compute_nhash (uschar *subject, int value1, int value2, int *len)\n{\nuschar *s = subject;\nint i = 0;\nunsigned long int total = 0; /* no overflow */\n\nwhile (*s != 0)\n  {\n  if (i == 0) i = sizeof(prime)/sizeof(int) - 1;\n  total += prime[i--] * (unsigned int)(*s++);\n  }\n\n/* If value2 is unset, just compute one number */\n\nif (value2 < 0)\n  {\n  s = string_sprintf(\"%d\", total % value1);\n  }\n\n/* Otherwise do a div/mod hash */\n\nelse\n  {\n  total = total % (value1 * value2);\n  s = string_sprintf(\"%d/%d\", total/value2, total % value2);\n  }\n\n*len = Ustrlen(s);\nreturn s;\n}\n", "target": 0, "idx": 12644}
{"func": "bool RenderFrameImpl::ShouldDisplayErrorPageForFailedLoad(\n    int error_code,\n    const GURL& unreachable_url) {\n  if (error_code == net::ERR_ABORTED)\n    return false;\n\n  if (error_code == net::ERR_BLOCKED_BY_CLIENT &&\n      render_view_->renderer_preferences_.disable_client_blocked_error_page) {\n    return false;\n  }\n\n  if (GetContentClient()->renderer()->ShouldSuppressErrorPage(\n          this, unreachable_url)) {\n    return false;\n  }\n\n  if (RenderThreadImpl::current() &&\n      RenderThreadImpl::current()->layout_test_mode()) {\n    return false;\n  }\n\n  return true;\n}\n", "target": 0, "idx": 132271}
{"func": "format_STACK_POP(const struct ofpact_stack *a, struct ds *s)\n{\n    nxm_format_stack_pop(a, s);\n}\n", "target": 0, "idx": 76960}
{"func": "inline bool is_hsr_master(struct net_device *dev)\n{\n\treturn (dev->netdev_ops->ndo_start_xmit == hsr_dev_xmit);\n}\n", "target": 0, "idx": 87669}
{"func": "bool BookmarksGetFunction::RunImpl() {\n  scoped_ptr<bookmarks::GetRecent::Params> params(\n      bookmarks::GetRecent::Params::Create(*args_));\n  EXTENSION_FUNCTION_VALIDATE(params.get());\n  if (params->number_of_items < 1)\n    return false;\n\n  std::vector<const BookmarkNode*> nodes;\n  bookmark_utils::GetMostRecentlyAddedEntries(\n      BookmarkModelFactory::GetForProfile(profile()),\n      params->number_of_items,\n      &nodes);\n\n  std::vector<linked_ptr<BookmarkTreeNode> > tree_nodes;\n  std::vector<const BookmarkNode*>::iterator i = nodes.begin();\n  for (; i != nodes.end(); ++i) {\n    const BookmarkNode* node = *i;\n    bookmark_api_helpers::AddNode(node, &tree_nodes, false);\n  }\n\n  results_ = bookmarks::GetRecent::Results::Create(tree_nodes);\n  return true;\n}\n", "target": 0, "idx": 124048}
{"func": "int read_header_tga(gdIOCtx *ctx, oTga *tga)\n{\n\n\tunsigned char header[18];\n\n\tif (gdGetBuf(header, sizeof(header), ctx) < 18) {\n\t\tgd_error(\"fail to read header\");\n\t\treturn -1;\n\t}\n\n\ttga->identsize = header[0];\n\ttga->colormaptype = header[1];\n\ttga->imagetype = header[2];\n\ttga->colormapstart = header[3] + (header[4] << 8);\n\ttga->colormaplength = header[5] + (header[6] << 8);\n\ttga->colormapbits = header[7];\n\ttga->xstart = header[8] + (header[9] << 8);\n\ttga->ystart = header[10] + (header[11] << 8);\n\ttga->width = header[12] + (header[13] << 8);\n\ttga->height = header[14] + (header[15] << 8);\n\ttga->bits = header[16];\n\ttga->alphabits = header[17] & 0x0f;\n\ttga->fliph = (header[17] & 0x10) ? 1 : 0;\n\ttga->flipv = (header[17] & 0x20) ? 0 : 1;\n\n#if DEBUG\n\tprintf(\"format bps: %i\\n\", tga->bits);\n\tprintf(\"flip h/v: %i / %i\\n\", tga->fliph, tga->flipv);\n\tprintf(\"alpha: %i\\n\", tga->alphabits);\n \tprintf(\"wxh: %i %i\\n\", tga->width, tga->height);\n #endif\n \n\tswitch(tga->bits) {\n\tcase 8:\n\tcase 16:\n\tcase 24:\n\tcase 32:\n\t\tbreak;\n\tdefault:\n\t\tgd_error(\"bps %i not supported\", tga->bits);\n \t\treturn -1;\n\t\tbreak;\n \t}\n \n \ttga->ident = NULL;\n\n\tif (tga->identsize > 0) {\n\t\ttga->ident = (char *) gdMalloc(tga->identsize * sizeof(char));\n\t\tif(tga->ident == NULL) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tgdGetBuf(tga->ident, tga->identsize, ctx);\n\t}\n\n\treturn 1;\n}\n", "target": 1, "idx": 180177}
{"func": "void LoginDisplayHostWebUI::TryToPlayOobeStartupSound() {\n  if (is_voice_interaction_oobe_)\n    return;\n\n  if (oobe_startup_sound_played_ || login_prompt_visible_time_.is_null() ||\n      !CrasAudioHandler::Get()->GetPrimaryActiveOutputNode()) {\n    return;\n  }\n\n  oobe_startup_sound_played_ = true;\n\n  if (base::TimeTicks::Now() - login_prompt_visible_time_ >\n      base::TimeDelta::FromMilliseconds(kStartupSoundMaxDelayMs)) {\n    return;\n  }\n\n  AccessibilityManager::Get()->PlayEarcon(SOUND_STARTUP,\n                                          PlaySoundOption::ALWAYS);\n}\n", "target": 0, "idx": 144344}
{"func": "floor_at_intervals(int x, int step)\n{\n    int mo = x % step;\n    if (mo > 0)\n\tx -= mo;\n    else if (mo < 0)\n\tx += step - mo;\n    return x;\n}\n", "target": 0, "idx": 84627}
{"func": "acpi_os_create_cache(char *name, u16 size, u16 depth, acpi_cache_t ** cache)\n{\n\t*cache = kmem_cache_create(name, size, 0, 0, NULL);\n\tif (*cache == NULL)\n\t\treturn AE_ERROR;\n\telse\n\t\treturn AE_OK;\n}\n", "target": 0, "idx": 53834}
{"func": "GF_Err edts_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_EditBox *ptr = (GF_EditBox *)s;\n\n\tif (ptr->editList && gf_list_count(ptr->editList->entryList)) {\n\t\te = gf_isom_box_write_header(s, bs);\n\t\tif (e) return e;\n\t\te = gf_isom_box_write((GF_Box *) ptr->editList, bs);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n", "target": 0, "idx": 80080}
{"func": "void HTMLMediaElement::UpdateControlsVisibility() {\n  if (!isConnected())\n    return;\n\n  bool native_controls = ShouldShowControls(RecordMetricsBehavior::kDoRecord);\n\n  if (!RuntimeEnabledFeatures::LazyInitializeMediaControlsEnabled() ||\n      RuntimeEnabledFeatures::MediaCastOverlayButtonEnabled() ||\n      native_controls) {\n    EnsureMediaControls();\n\n    GetMediaControls()->Reset();\n  }\n\n  if (native_controls)\n    GetMediaControls()->MaybeShow();\n  else if (GetMediaControls())\n    GetMediaControls()->Hide();\n\n  if (web_media_player_)\n    web_media_player_->OnHasNativeControlsChanged(native_controls);\n}\n", "target": 0, "idx": 142935}
{"func": "void ExtensionInstallPrompt::ShowConfirmation() {\n  scoped_ptr<const PermissionSet> permissions_wrapper;\n  const PermissionSet* permissions_to_display = nullptr;\n  if (custom_permissions_.get()) {\n    permissions_to_display = custom_permissions_.get();\n  } else if (extension_) {\n    extensions::PermissionsUpdater(\n        profile_, extensions::PermissionsUpdater::INIT_FLAG_TRANSIENT)\n        .InitializePermissions(extension_);\n    permissions_to_display =\n        &extension_->permissions_data()->active_permissions();\n    if (prompt_->type() == DELEGATED_PERMISSIONS_PROMPT ||\n        prompt_->type() == DELEGATED_BUNDLE_PERMISSIONS_PROMPT) {\n      const PermissionSet& optional_permissions =\n          extensions::PermissionsParser::GetOptionalPermissions(extension_);\n      permissions_wrapper = PermissionSet::CreateUnion(*permissions_to_display,\n                                                       optional_permissions);\n      permissions_to_display = permissions_wrapper.get();\n    }\n  }\n\n  if (permissions_to_display &&\n      (!extension_ ||\n       !extensions::PermissionsData::ShouldSkipPermissionWarnings(\n           extension_->id()))) {\n    Manifest::Type type =\n        extension_ ? extension_->GetType() : Manifest::TYPE_UNKNOWN;\n    const extensions::PermissionMessageProvider* message_provider =\n        extensions::PermissionMessageProvider::Get();\n\n    prompt_->SetPermissions(message_provider->GetPermissionMessages(\n                                message_provider->GetAllPermissionIDs(\n                                    *permissions_to_display, type)),\n                            REGULAR_PERMISSIONS);\n\n    const PermissionSet* withheld =\n        extension_ ? &extension_->permissions_data()->withheld_permissions()\n                   : nullptr;\n    if (withheld && !withheld->IsEmpty()) {\n      prompt_->SetPermissions(\n          message_provider->GetPermissionMessages(\n              message_provider->GetAllPermissionIDs(*withheld, type)),\n          WITHHELD_PERMISSIONS);\n    }\n  }\n\n  switch (prompt_->type()) {\n    case PERMISSIONS_PROMPT:\n    case RE_ENABLE_PROMPT:\n    case INLINE_INSTALL_PROMPT:\n    case EXTERNAL_INSTALL_PROMPT:\n    case INSTALL_PROMPT:\n    case POST_INSTALL_PERMISSIONS_PROMPT:\n    case REMOTE_INSTALL_PROMPT:\n    case REPAIR_PROMPT:\n    case DELEGATED_PERMISSIONS_PROMPT: {\n      prompt_->set_extension(extension_);\n      break;\n    }\n    case BUNDLE_INSTALL_PROMPT:\n    case DELEGATED_BUNDLE_PERMISSIONS_PROMPT: {\n      prompt_->set_bundle(bundle_);\n      break;\n    }\n    case LAUNCH_PROMPT_DEPRECATED:\n    default:\n      NOTREACHED() << \"Unknown message\";\n      return;\n  }\n  prompt_->set_delegated_username(delegated_username_);\n  prompt_->set_icon(gfx::Image::CreateFrom1xBitmap(icon_));\n\n  g_last_prompt_type_for_tests = prompt_->type();\n\n  if (AutoConfirmPrompt(delegate_))\n    return;\n\n  if (show_params_->WasParentDestroyed()) {\n    delegate_->InstallUIAbort(false);\n    return;\n  }\n\n  if (show_dialog_callback_.is_null())\n    GetDefaultShowDialogCallback().Run(show_params_.get(), delegate_, prompt_);\n  else\n    show_dialog_callback_.Run(show_params_.get(), delegate_, prompt_);\n}\n", "target": 0, "idx": 144398}
{"func": "bool RenderFrameImpl::UniqueNameFrameAdapter::IsMainFrame() const {\n  return render_frame_->IsMainFrame();\n}\n", "target": 0, "idx": 152388}
{"func": "  T42_Open_Face( T42_Face  face )\n  {\n    T42_LoaderRec  loader;\n    T42_Parser     parser;\n    T1_Font        type1 = &face->type1;\n    FT_Memory      memory = face->root.memory;\n    FT_Error       error;\n\n    PSAux_Service  psaux  = (PSAux_Service)face->psaux;\n\n\n    t42_loader_init( &loader, face );\n\n    parser = &loader.parser;\n\n     if ( FT_ALLOC( face->ttf_data, 12 ) )\n       goto Exit;\n \n     error = t42_parser_init( parser,\n                              face->root.stream,\n                              memory,\n    if ( error )\n      goto Exit;\n\n    if ( type1->font_type != 42 )\n    {\n      FT_ERROR(( \"T42_Open_Face: cannot handle FontType %d\\n\",\n                 type1->font_type ));\n      error = FT_THROW( Unknown_File_Format );\n      goto Exit;\n    }\n\n    /* now, propagate the charstrings and glyphnames tables */\n    /* to the Type1 data                                    */\n    type1->num_glyphs = loader.num_glyphs;\n\n    if ( !loader.charstrings.init )\n    {\n      FT_ERROR(( \"T42_Open_Face: no charstrings array in face\\n\" ));\n      error = FT_THROW( Invalid_File_Format );\n    }\n\n    loader.charstrings.init  = 0;\n    type1->charstrings_block = loader.charstrings.block;\n    type1->charstrings       = loader.charstrings.elements;\n    type1->charstrings_len   = loader.charstrings.lengths;\n\n    /* we copy the glyph names `block' and `elements' fields; */\n    /* the `lengths' field must be released later             */\n    type1->glyph_names_block    = loader.glyph_names.block;\n    type1->glyph_names          = (FT_String**)loader.glyph_names.elements;\n    loader.glyph_names.block    = 0;\n    loader.glyph_names.elements = 0;\n\n    /* we must now build type1.encoding when we have a custom array */\n    if ( type1->encoding_type == T1_ENCODING_TYPE_ARRAY )\n    {\n      FT_Int    charcode, idx, min_char, max_char;\n      FT_Byte*  glyph_name;\n\n\n      /* OK, we do the following: for each element in the encoding   */\n      /* table, look up the index of the glyph having the same name  */\n      /* as defined in the CharStrings array.                        */\n      /* The index is then stored in type1.encoding.char_index, and  */\n      /* the name in type1.encoding.char_name                        */\n\n      min_char = 0;\n      max_char = 0;\n\n      charcode = 0;\n      for ( ; charcode < loader.encoding_table.max_elems; charcode++ )\n      {\n        FT_Byte*  char_name;\n\n\n        type1->encoding.char_index[charcode] = 0;\n        type1->encoding.char_name [charcode] = (char *)\".notdef\";\n\n        char_name = loader.encoding_table.elements[charcode];\n        if ( char_name )\n          for ( idx = 0; idx < type1->num_glyphs; idx++ )\n          {\n            glyph_name = (FT_Byte*)type1->glyph_names[idx];\n            if ( ft_strcmp( (const char*)char_name,\n                            (const char*)glyph_name ) == 0 )\n            {\n              type1->encoding.char_index[charcode] = (FT_UShort)idx;\n              type1->encoding.char_name [charcode] = (char*)glyph_name;\n\n              /* Change min/max encoded char only if glyph name is */\n              /* not /.notdef                                      */\n              if ( ft_strcmp( (const char*)\".notdef\",\n                              (const char*)glyph_name ) != 0 )\n              {\n                if ( charcode < min_char )\n                  min_char = charcode;\n                if ( charcode >= max_char )\n                  max_char = charcode + 1;\n              }\n              break;\n            }\n          }\n      }\n\n      type1->encoding.code_first = min_char;\n      type1->encoding.code_last  = max_char;\n      type1->encoding.num_chars  = loader.num_chars;\n    }\n\n  Exit:\n    t42_loader_done( &loader );\n    return error;\n  }\n", "target": 1, "idx": 178033}
{"func": " FrameImpl::FrameImpl(std::unique_ptr<content::WebContents> web_contents,\n                     chromium::web::FrameObserverPtr observer)\n    : web_contents_(std::move(web_contents)), observer_(std::move(observer)) {\n  Observe(web_contents.get());\n }\n", "target": 1, "idx": 186120}
{"func": "txid_snapshot_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tTxidSnapshot *snap;\n \ttxid\t\tlast = 0;\n \tint\t\t\tnxip;\n \tint\t\t\ti;\n\tint\t\t\tavail;\n\tint\t\t\texpect;\n \ttxid\t\txmin,\n \t\t\t\txmax;\n \n\t/*\n\t * load nxip and check for nonsense.\n\t *\n\t * (nxip > avail) check is against int overflows in 'expect'.\n\t */\n \tnxip = pq_getmsgint(buf, 4);\n\tavail = buf->len - buf->cursor;\n\texpect = 8 + 8 + nxip * 8;\n\tif (nxip < 0 || nxip > avail || expect > avail)\n \t\tgoto bad_format;\n \n \txmin = pq_getmsgint64(buf);\n\txmax = pq_getmsgint64(buf);\n\tif (xmin == 0 || xmax == 0 || xmin > xmax || xmax > MAX_TXID)\n\t\tgoto bad_format;\n\n\tsnap = palloc(TXID_SNAPSHOT_SIZE(nxip));\n\tsnap->xmin = xmin;\n\tsnap->xmax = xmax;\n\tsnap->nxip = nxip;\n\tSET_VARSIZE(snap, TXID_SNAPSHOT_SIZE(nxip));\n\n\tfor (i = 0; i < nxip; i++)\n\t{\n\t\ttxid\t\tcur = pq_getmsgint64(buf);\n\n\t\tif (cur <= last || cur < xmin || cur >= xmax)\n\t\t\tgoto bad_format;\n\t\tsnap->xip[i] = cur;\n\t\tlast = cur;\n\t}\n\tPG_RETURN_POINTER(snap);\n\nbad_format:\n\telog(ERROR, \"invalid snapshot data\");\n\treturn (Datum) NULL;\n}\n", "target": 1, "idx": 179588}
{"func": "static ssize_t eth_rx(NetClientState *nc, const uint8_t *buf, size_t size)\n{\n    struct xlx_ethlite *s = qemu_get_nic_opaque(nc);\n    unsigned int rxbase = s->rxbuf * (0x800 / 4);\n\n    /* DA filter.  */\n    if (!(buf[0] & 0x80) && memcmp(&s->conf.macaddr.a[0], buf, 6))\n        return size;\n\n    if (s->regs[rxbase + R_RX_CTRL0] & CTRL_S) {\n        D(qemu_log(\"ethlite lost packet %x\\n\", s->regs[R_RX_CTRL0]));\n        return -1;\n     }\n \n     D(qemu_log(\"%s %zd rxbase=%x\\n\", __func__, size, rxbase));\n     memcpy(&s->regs[rxbase + R_RX_BUF0], buf, size);\n \n     s->regs[rxbase + R_RX_CTRL0] |= CTRL_S;\n    /* If c_rx_pingpong was set flip buffers.  */\n    s->rxbuf ^= s->c_rx_pingpong;\n    return size;\n}\n", "target": 1, "idx": 178105}
{"func": "CSSStyleSheet* Document::createEmptyCSSStyleSheet(\n    ScriptState* script_state,\n    ExceptionState& exception_state) {\n  return Document::createEmptyCSSStyleSheet(\n      script_state, CSSStyleSheetInit::Create(), exception_state);\n}\n", "target": 0, "idx": 165470}
{"func": "static int parseOptions(int argc, char **argv) {\n    int i;\n\n    for (i = 1; i < argc; i++) {\n        int lastarg = i==argc-1;\n\n        if (!strcmp(argv[i],\"-h\") && !lastarg) {\n            sdsfree(config.hostip);\n            config.hostip = sdsnew(argv[++i]);\n        } else if (!strcmp(argv[i],\"-h\") && lastarg) {\n            usage();\n        } else if (!strcmp(argv[i],\"--help\")) {\n            usage();\n        } else if (!strcmp(argv[i],\"-x\")) {\n            config.stdinarg = 1;\n        } else if (!strcmp(argv[i],\"-p\") && !lastarg) {\n            config.hostport = atoi(argv[++i]);\n        } else if (!strcmp(argv[i],\"-s\") && !lastarg) {\n            config.hostsocket = argv[++i];\n        } else if (!strcmp(argv[i],\"-r\") && !lastarg) {\n            config.repeat = strtoll(argv[++i],NULL,10);\n        } else if (!strcmp(argv[i],\"-i\") && !lastarg) {\n            double seconds = atof(argv[++i]);\n            config.interval = seconds*1000000;\n        } else if (!strcmp(argv[i],\"-n\") && !lastarg) {\n            config.dbnum = atoi(argv[++i]);\n        } else if (!strcmp(argv[i],\"-a\") && !lastarg) {\n            fputs(\"Warning: Using a password with '-a' option on the command line interface may not be safe.\\n\", stderr);\n            config.auth = argv[++i];\n        } else if (!strcmp(argv[i],\"-u\") && !lastarg) {\n            parseRedisUri(argv[++i]);\n        } else if (!strcmp(argv[i],\"--raw\")) {\n            config.output = OUTPUT_RAW;\n        } else if (!strcmp(argv[i],\"--no-raw\")) {\n            config.output = OUTPUT_STANDARD;\n        } else if (!strcmp(argv[i],\"--csv\")) {\n            config.output = OUTPUT_CSV;\n        } else if (!strcmp(argv[i],\"--latency\")) {\n            config.latency_mode = 1;\n        } else if (!strcmp(argv[i],\"--latency-dist\")) {\n            config.latency_dist_mode = 1;\n        } else if (!strcmp(argv[i],\"--mono\")) {\n            spectrum_palette = spectrum_palette_mono;\n            spectrum_palette_size = spectrum_palette_mono_size;\n        } else if (!strcmp(argv[i],\"--latency-history\")) {\n            config.latency_mode = 1;\n            config.latency_history = 1;\n        } else if (!strcmp(argv[i],\"--lru-test\") && !lastarg) {\n            config.lru_test_mode = 1;\n            config.lru_test_sample_size = strtoll(argv[++i],NULL,10);\n        } else if (!strcmp(argv[i],\"--slave\")) {\n            config.slave_mode = 1;\n        } else if (!strcmp(argv[i],\"--stat\")) {\n            config.stat_mode = 1;\n        } else if (!strcmp(argv[i],\"--scan\")) {\n            config.scan_mode = 1;\n        } else if (!strcmp(argv[i],\"--pattern\") && !lastarg) {\n            config.pattern = argv[++i];\n        } else if (!strcmp(argv[i],\"--intrinsic-latency\") && !lastarg) {\n            config.intrinsic_latency_mode = 1;\n            config.intrinsic_latency_duration = atoi(argv[++i]);\n        } else if (!strcmp(argv[i],\"--rdb\") && !lastarg) {\n            config.getrdb_mode = 1;\n            config.rdb_filename = argv[++i];\n        } else if (!strcmp(argv[i],\"--pipe\")) {\n            config.pipe_mode = 1;\n        } else if (!strcmp(argv[i],\"--pipe-timeout\") && !lastarg) {\n            config.pipe_timeout = atoi(argv[++i]);\n        } else if (!strcmp(argv[i],\"--bigkeys\")) {\n            config.bigkeys = 1;\n        } else if (!strcmp(argv[i],\"--hotkeys\")) {\n            config.hotkeys = 1;\n        } else if (!strcmp(argv[i],\"--eval\") && !lastarg) {\n            config.eval = argv[++i];\n        } else if (!strcmp(argv[i],\"--ldb\")) {\n            config.eval_ldb = 1;\n            config.output = OUTPUT_RAW;\n        } else if (!strcmp(argv[i],\"--ldb-sync-mode\")) {\n            config.eval_ldb = 1;\n            config.eval_ldb_sync = 1;\n            config.output = OUTPUT_RAW;\n        } else if (!strcmp(argv[i],\"-c\")) {\n            config.cluster_mode = 1;\n        } else if (!strcmp(argv[i],\"-d\") && !lastarg) {\n            sdsfree(config.mb_delim);\n            config.mb_delim = sdsnew(argv[++i]);\n        } else if (!strcmp(argv[i],\"-v\") || !strcmp(argv[i], \"--version\")) {\n            sds version = cliVersion();\n            printf(\"redis-cli %s\\n\", version);\n            sdsfree(version);\n            exit(0);\n        } else {\n            if (argv[i][0] == '-') {\n                fprintf(stderr,\n                    \"Unrecognized option or bad number of args for: '%s'\\n\",\n                    argv[i]);\n                exit(1);\n            } else {\n                /* Likely the command name, stop here. */\n                break;\n            }\n        }\n    }\n\n    /* --ldb requires --eval. */\n    if (config.eval_ldb && config.eval == NULL) {\n        fprintf(stderr,\"Options --ldb and --ldb-sync-mode require --eval.\\n\");\n        fprintf(stderr,\"Try %s --help for more information.\\n\", argv[0]);\n        exit(1);\n    }\n    return i;\n}\n", "target": 0, "idx": 81977}
{"func": "bool RenderFrameHostManager::IsRendererTransferNeededForNavigation(\n    RenderFrameHostImpl* rfh,\n    const GURL& dest_url) {\n  if (!rfh->GetSiteInstance()->HasSite())\n    return false;\n\n  if (rfh->GetSiteInstance()->GetSiteURL().SchemeIs(kGuestScheme))\n    return false;\n\n  BrowserContext* context = rfh->GetSiteInstance()->GetBrowserContext();\n  if (IsCurrentlySameSite(rfh, dest_url)) {\n    return false;\n  }\n\n  if (rfh->GetSiteInstance()->RequiresDedicatedProcess() ||\n      SiteInstanceImpl::DoesSiteRequireDedicatedProcess(context,\n                                                        dest_url)) {\n    return true;\n  }\n\n  if (SiteIsolationPolicy::IsTopDocumentIsolationEnabled() &&\n      (!frame_tree_node_->IsMainFrame() ||\n       rfh->GetSiteInstance()->IsDefaultSubframeSiteInstance())) {\n    return true;\n  }\n\n  return false;\n}\n", "target": 0, "idx": 148893}
{"func": " rs_filter_graph(RSFilter *filter)\n {\n \tg_return_if_fail(RS_IS_FILTER(filter));\n \tGString *str = g_string_new(\"digraph G {\\n\");\n \n \trs_filter_graph_helper(str, filter);\n \n \tg_string_append_printf(str, \"}\\n\");\n\tg_file_set_contents(\"/tmp/rs-filter-graph\", str->str, str->len, NULL);\n \n\tif (0 != system(\"dot -Tpng >/tmp/rs-filter-graph.png </tmp/rs-filter-graph\"))\n \t\tg_warning(\"Calling dot failed\");\n\tif (0 != system(\"gnome-open /tmp/rs-filter-graph.png\"))\n \t\tg_warning(\"Calling gnome-open failed.\");\n \n \tg_string_free(str, TRUE);\n }\n", "target": 1, "idx": 182086}
{"func": "R_API int r_flag_rename(RFlag *f, RFlagItem *item, const char *name) {\n\tif (!f || !item || !name || !*name) {\n\t\treturn false;\n\t}\n#if 0\n\tut64 off = item->offset;\n\tint size = item->size;\n\tr_flag_unset (f, item);\n\tr_flag_set (f, name, off, size);\n\treturn true;\n#else\n\tht_delete (f->ht_name, item->name);\n\tif (!set_name (item, name)) {\n\t\treturn false;\n\t}\n\tht_insert (f->ht_name, item->name, item);\n#endif\n\treturn true;\n}\n", "target": 0, "idx": 60486}
{"func": "bool GLES2DecoderImpl::DoIsShader(GLuint client_id) {\n  return GetShaderInfo(client_id) != NULL;\n}\n", "target": 0, "idx": 104036}
{"func": "static int crypto_ccm_auth(struct aead_request *req, struct scatterlist *plain,\n\t\t\t   unsigned int cryptlen)\n{\n\tstruct crypto_ccm_req_priv_ctx *pctx = crypto_ccm_reqctx(req);\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\tstruct crypto_ccm_ctx *ctx = crypto_aead_ctx(aead);\n \tAHASH_REQUEST_ON_STACK(ahreq, ctx->mac);\n \tunsigned int assoclen = req->assoclen;\n \tstruct scatterlist sg[3];\n\tu8 odata[16];\n\tu8 idata[16];\n \tint ilen, err;\n \n \t/* format control data for input */\n\terr = format_input(odata, req, cryptlen);\n\tif (err)\n\t\tgoto out;\n\n\tsg_init_table(sg, 3);\n\tsg_set_buf(&sg[0], odata, 16);\n\n\t/* format associated data and compute into mac */\n\tif (assoclen) {\n\t\tilen = format_adata(idata, assoclen);\n\t\tsg_set_buf(&sg[1], idata, ilen);\n\t\tsg_chain(sg, 3, req->src);\n\t} else {\n\t\tilen = 0;\n\t\tsg_chain(sg, 2, req->src);\n\t}\n\n\tahash_request_set_tfm(ahreq, ctx->mac);\n\tahash_request_set_callback(ahreq, pctx->flags, NULL, NULL);\n\tahash_request_set_crypt(ahreq, sg, NULL, assoclen + ilen + 16);\n\terr = crypto_ahash_init(ahreq);\n\tif (err)\n\t\tgoto out;\n\terr = crypto_ahash_update(ahreq);\n\tif (err)\n\t\tgoto out;\n\n\t/* we need to pad the MAC input to a round multiple of the block size */\n\tilen = 16 - (assoclen + ilen) % 16;\n\tif (ilen < 16) {\n\t\tmemset(idata, 0, ilen);\n\t\tsg_init_table(sg, 2);\n\t\tsg_set_buf(&sg[0], idata, ilen);\n\t\tif (plain)\n\t\t\tsg_chain(sg, 2, plain);\n\t\tplain = sg;\n\t\tcryptlen += ilen;\n\t}\n\n\tahash_request_set_crypt(ahreq, plain, pctx->odata, cryptlen);\n\terr = crypto_ahash_finup(ahreq);\nout:\n\treturn err;\n}\n", "target": 1, "idx": 181393}
{"func": "mountpoint_last(struct nameidata *nd, struct path *path)\n{\n\tint error = 0;\n\tstruct dentry *dentry;\n\tstruct dentry *dir = nd->path.dentry;\n\n\t/* If we're in rcuwalk, drop out of it to handle last component */\n\tif (nd->flags & LOOKUP_RCU) {\n\t\tif (unlazy_walk(nd, NULL)) {\n\t\t\terror = -ECHILD;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tnd->flags &= ~LOOKUP_PARENT;\n\n\tif (unlikely(nd->last_type != LAST_NORM)) {\n\t\terror = handle_dots(nd, nd->last_type);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tdentry = dget(nd->path.dentry);\n\t\tgoto done;\n\t}\n\n\tmutex_lock(&dir->d_inode->i_mutex);\n\tdentry = d_lookup(dir, &nd->last);\n\tif (!dentry) {\n\t\t/*\n\t\t * No cached dentry. Mounted dentries are pinned in the cache,\n\t\t * so that means that this dentry is probably a symlink or the\n\t\t * path doesn't actually point to a mounted dentry.\n\t\t */\n\t\tdentry = d_alloc(dir, &nd->last);\n\t\tif (!dentry) {\n\t\t\terror = -ENOMEM;\n\t\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\t\t\tgoto out;\n\t\t}\n\t\tdentry = lookup_real(dir->d_inode, dentry, nd->flags);\n\t\terror = PTR_ERR(dentry);\n\t\tif (IS_ERR(dentry)) {\n\t\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\ndone:\n\tif (!dentry->d_inode || d_is_negative(dentry)) {\n\t\terror = -ENOENT;\n\t\tdput(dentry);\n \t\tgoto out;\n \t}\n \tpath->dentry = dentry;\n\tpath->mnt = mntget(nd->path.mnt);\n \tif (should_follow_link(dentry, nd->flags & LOOKUP_FOLLOW))\n \t\treturn 1;\n \tfollow_mount(path);\n \terror = 0;\n out:\n\tterminate_walk(nd);\n\treturn error;\n}\n", "target": 1, "idx": 179457}
{"func": "MagickExport PixelPacket *GetAuthenticPixelQueue(const Image *image)\n{\n  CacheInfo\n    *restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  if (cache_info->methods.get_authentic_pixels_from_handler !=\n       (GetAuthenticPixelsFromHandler) NULL)\n    return(cache_info->methods.get_authentic_pixels_from_handler(image));\n  assert(id < (int) cache_info->number_threads);\n  return(cache_info->nexus_info[id]->pixels);\n}\n", "target": 0, "idx": 73616}
{"func": "bool BaseSessionService::RestoreUpdateTabNavigationCommand(\n    const SessionCommand& command,\n    TabNavigation* navigation,\n    SessionID::id_type* tab_id) {\n  scoped_ptr<Pickle> pickle(command.PayloadAsPickle());\n  if (!pickle.get())\n    return false;\n  void* iterator = NULL;\n  std::string url_spec;\n  if (!pickle->ReadInt(&iterator, tab_id) ||\n      !pickle->ReadInt(&iterator, &(navigation->index_)) ||\n      !pickle->ReadString(&iterator, &url_spec) ||\n      !pickle->ReadString16(&iterator, &(navigation->title_)) ||\n      !pickle->ReadString(&iterator, &(navigation->state_)) ||\n      !pickle->ReadInt(&iterator,\n                       reinterpret_cast<int*>(&(navigation->transition_))))\n    return false;\n  bool has_type_mask = pickle->ReadInt(&iterator, &(navigation->type_mask_));\n\n  if (has_type_mask) {\n    std::string referrer_spec;\n    pickle->ReadString(&iterator, &referrer_spec);\n    int policy_int;\n    WebReferrerPolicy policy;\n    if (pickle->ReadInt(&iterator, &policy_int))\n      policy = static_cast<WebReferrerPolicy>(policy_int);\n    else\n      policy = WebKit::WebReferrerPolicyDefault;\n    navigation->referrer_ = content::Referrer(\n        referrer_spec.empty() ? GURL() : GURL(referrer_spec),\n         policy);\n \n     std::string content_state;\n     if (CompressDataHelper::ReadAndDecompressStringFromPickle(\n             *pickle.get(), &iterator, &content_state) &&\n         !content_state.empty()) {\n       navigation->state_ = content_state;\n     }\n   }\n \n   navigation->virtual_url_ = GURL(url_spec);\n  return true;\n}\n", "target": 1, "idx": 184742}
{"func": "void FrameSelection::MoveRangeSelection(const VisiblePosition& base_position,\n                                        const VisiblePosition& extent_position,\n                                        TextGranularity granularity) {\n  SelectionInDOMTree new_selection =\n      SelectionInDOMTree::Builder()\n           .SetBaseAndExtentDeprecated(base_position.DeepEquivalent(),\n                                       extent_position.DeepEquivalent())\n           .SetAffinity(base_position.Affinity())\n          .SetIsHandleVisible(IsHandleVisible())\n           .Build();\n \n   if (new_selection.IsNone())\n    return;\n\n  const VisibleSelection& visible_selection =\n      CreateVisibleSelectionWithGranularity(new_selection, granularity);\n  if (visible_selection.IsNone())\n    return;\n\n  SelectionInDOMTree::Builder builder;\n  if (visible_selection.IsBaseFirst()) {\n    builder.SetBaseAndExtent(visible_selection.Start(),\n                             visible_selection.End());\n  } else {\n    builder.SetBaseAndExtent(visible_selection.End(),\n                              visible_selection.Start());\n   }\n   builder.SetAffinity(visible_selection.Affinity());\n  builder.SetIsHandleVisible(IsHandleVisible());\n   SetSelection(builder.Build(), SetSelectionData::Builder()\n                                     .SetShouldCloseTyping(true)\n                                     .SetShouldClearTypingStyle(true)\n                                     .SetGranularity(granularity)\n                                     .Build());\n }\n", "target": 1, "idx": 185634}
{"func": " static size_t safecat(char *buffer, size_t bufsize, size_t pos,\n   PNG_CONST char *cat)\n {\n    while (pos < bufsize && cat != NULL && *cat != 0)\n       buffer[pos++] = *cat++;\n\n if (pos >= bufsize)\n      pos = bufsize-1;\n\n   buffer[pos] = 0;\n return pos;\n}\n", "target": 1, "idx": 187711}
{"func": "void StartupBrowserCreator::AddFirstRunTab(const GURL& url) {\n  first_run_tabs_.push_back(url);\n}\n", "target": 0, "idx": 150168}
{"func": "static int burl_normalize_2F_to_slash_fix (buffer *b, int qs, int i)\n{\n    char * const s = b->ptr;\n    const int blen = (int)buffer_string_length(b);\n    const int used = qs < 0 ? blen : qs;\n    int j = i;\n    for (; i < used; ++i, ++j) {\n        s[j] = s[i];\n        if (s[i] == '%' && s[i+1] == '2' && s[i+2] == 'F') {\n            s[j] = '/';\n            i+=2;\n         }\n     }\n     if (qs >= 0) {\n        memmove(s+j, s+qs, blen - qs);\n        j += blen - qs;\n     }\n     buffer_string_set_length(b, j);\n     return qs;\n}\n", "target": 1, "idx": 182881}
{"func": "void ExtensionTtsController::Stop() {\n  if (current_utterance_ && !current_utterance_->extension_id().empty()) {\n    current_utterance_->profile()->GetExtensionEventRouter()->\n        DispatchEventToExtension(\n            current_utterance_->extension_id(),\n            events::kOnStop,\n            \"[]\",\n            current_utterance_->profile(),\n            GURL());\n  } else {\n    GetPlatformImpl()->clear_error();\n    GetPlatformImpl()->StopSpeaking();\n   }\n \n  if (current_utterance_)\n    current_utterance_->set_error(kSpeechInterruptedError);\n  FinishCurrentUtterance();\n  ClearUtteranceQueue();\n}\n", "target": 1, "idx": 183848}
{"func": "base::PortProvider* BrowserChildProcessHost::GetPortProvider() {\n  return MachBroker::GetInstance();\n}\n", "target": 0, "idx": 162016}
{"func": "void HeapAllocator::backingFree(void* address) {\n  if (!address)\n    return;\n\n  ThreadState* state = ThreadState::current();\n  if (state->sweepForbidden())\n    return;\n  ASSERT(!state->isInGC());\n\n  BasePage* page = pageFromObject(address);\n  if (page->isLargeObjectPage() || page->arena()->getThreadState() != state)\n     return;\n \n   HeapObjectHeader* header = HeapObjectHeader::fromPayload(address);\n  ASSERT(header->checkHeader());\n   NormalPageArena* arena = static_cast<NormalPage*>(page)->arenaForNormalPage();\n   state->promptlyFreed(header->gcInfoIndex());\n   arena->promptlyFreeObject(header);\n}\n", "target": 1, "idx": 186683}
{"func": "void servers_init(void)\n{\n\tsettings_add_bool(\"server\", \"resolve_prefer_ipv6\", FALSE);\n\tsettings_add_bool(\"server\", \"resolve_reverse_lookup\", FALSE);\n\tlookup_servers = servers = NULL;\n\n\tsignal_add(\"chat protocol deinit\", (SIGNAL_FUNC) sig_chat_protocol_deinit);\n\n\tservers_reconnect_init();\n\tservers_setup_init();\n}\n", "target": 0, "idx": 18216}
{"func": "WebsiteSettingsPopupAndroid::~WebsiteSettingsPopupAndroid() {}\n", "target": 0, "idx": 136082}
{"func": "static int _gd2GetHeader(gdIOCtxPtr in, int *sx, int *sy, int *cs, int *vers, int *fmt, int *ncx, int *ncy, t_chunk_info ** chunkIdx)\n{\n\tint i;\n\tint ch;\n\tchar id[5];\n\tt_chunk_info *cidx;\n\tint sidx;\n\tint nc;\n\n\tGD2_DBG(php_gd_error(\"Reading gd2 header info\"));\n\n\tfor (i = 0; i < 4; i++) {\n\t\tch = gdGetC(in);\n\t\tif (ch == EOF) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tid[i] = ch;\n\t}\n\tid[4] = 0;\n\n\tGD2_DBG(php_gd_error(\"Got file code: %s\", id));\n\n\t/* Equiv. of 'magick'.  */\n\tif (strcmp(id, GD2_ID) != 0) {\n\t\tGD2_DBG(php_gd_error(\"Not a valid gd2 file\"));\n\t\tgoto fail1;\n\t}\n\n\t/* Version */\n\tif (gdGetWord(vers, in) != 1) {\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"Version: %d\", *vers));\n\n\tif ((*vers != 1) && (*vers != 2)) {\n\t\tGD2_DBG(php_gd_error(\"Bad version: %d\", *vers));\n\t\tgoto fail1;\n\t}\n\n\t/* Image Size */\n\tif (!gdGetWord(sx, in)) {\n\t\tGD2_DBG(php_gd_error(\"Could not get x-size\"));\n\t\tgoto fail1;\n\t}\n\tif (!gdGetWord(sy, in)) {\n\t\tGD2_DBG(php_gd_error(\"Could not get y-size\"));\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"Image is %dx%d\", *sx, *sy));\n\n\t/* Chunk Size (pixels, not bytes!) */\n\tif (gdGetWord(cs, in) != 1) {\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"ChunkSize: %d\", *cs));\n\n\tif ((*cs < GD2_CHUNKSIZE_MIN) || (*cs > GD2_CHUNKSIZE_MAX)) {\n\t\tGD2_DBG(php_gd_error(\"Bad chunk size: %d\", *cs));\n\t\tgoto fail1;\n\t}\n\n\t/* Data Format */\n\tif (gdGetWord(fmt, in) != 1) {\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"Format: %d\", *fmt));\n\n\tif ((*fmt != GD2_FMT_RAW) && (*fmt != GD2_FMT_COMPRESSED) && (*fmt != GD2_FMT_TRUECOLOR_RAW) && (*fmt != GD2_FMT_TRUECOLOR_COMPRESSED)) {\n\t\tGD2_DBG(php_gd_error(\"Bad data format: %d\", *fmt));\n\t\tgoto fail1;\n\t}\n\n\t/* # of chunks wide */\n\tif (gdGetWord(ncx, in) != 1) {\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"%d Chunks Wide\", *ncx));\n\n\t/* # of chunks high */\n\tif (gdGetWord(ncy, in) != 1) {\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"%d Chunks vertically\", *ncy));\n\n \tif (gd2_compressed(*fmt)) {\n \t\tnc = (*ncx) * (*ncy);\n \t\tGD2_DBG(php_gd_error(\"Reading %d chunk index entries\", nc));\n \t\tsidx = sizeof(t_chunk_info) * nc;\n \t\tif (sidx <= 0) {\n \t\t\tgoto fail1;\n \t\t}\n \t\tcidx = gdCalloc(sidx, 1);\n \t\tfor (i = 0; i < nc; i++) {\n \t\t\tif (gdGetInt(&cidx[i].offset, in) != 1) {\n \t\t\t\tgdFree(cidx);\n\t\t\t\tgoto fail1;\n\t\t\t}\n\t\t\tif (gdGetInt(&cidx[i].size, in) != 1) {\n\t\t\t\tgdFree(cidx);\n\t\t\t\tgoto fail1;\n\t\t\t}\n\t\t\tif (cidx[i].offset < 0 || cidx[i].size < 0) {\n\t\t\t\tgdFree(cidx);\n\t\t\t\tgoto fail1;\n\t\t\t}\n\t\t}\n\t\t*chunkIdx = cidx;\n\t}\n\n\tGD2_DBG(php_gd_error(\"gd2 header complete\"));\n\n\treturn 1;\n\nfail1:\n\treturn 0;\n}\n", "target": 1, "idx": 180303}
{"func": "static MagickBooleanType WriteTIFFImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  const char\n    *mode,\n    *option;\n\n  CompressionType\n    compression;\n\n  EndianType\n    endian_type;\n\n  MagickBooleanType\n    debug,\n    status;\n\n  MagickOffsetType\n    scene;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  register ssize_t\n    i;\n\n  size_t\n    length;\n\n  ssize_t\n    y;\n\n  TIFF\n    *tiff;\n\n  TIFFInfo\n    tiff_info;\n\n  uint16\n    bits_per_sample,\n    compress_tag,\n    endian,\n    photometric;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open TIFF file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) SetMagickThreadValue(tiff_exception,exception);\n  endian_type=UndefinedEndian;\n  option=GetImageOption(image_info,\"tiff:endian\");\n  if (option != (const char *) NULL)\n    {\n      if (LocaleNCompare(option,\"msb\",3) == 0)\n        endian_type=MSBEndian;\n      if (LocaleNCompare(option,\"lsb\",3) == 0)\n        endian_type=LSBEndian;;\n    }\n  switch (endian_type)\n  {\n    case LSBEndian: mode=\"wl\"; break;\n    case MSBEndian: mode=\"wb\"; break;\n    default: mode=\"w\"; break;\n  }\n#if defined(TIFF_VERSION_BIG)\n  if (LocaleCompare(image_info->magick,\"TIFF64\") == 0)\n    switch (endian_type)\n    {\n      case LSBEndian: mode=\"wl8\"; break;\n      case MSBEndian: mode=\"wb8\"; break;\n      default: mode=\"w8\"; break;\n    }\n#endif\n  tiff=TIFFClientOpen(image->filename,mode,(thandle_t) image,TIFFReadBlob,\n    TIFFWriteBlob,TIFFSeekBlob,TIFFCloseBlob,TIFFGetBlobSize,TIFFMapBlob,\n    TIFFUnmapBlob);\n  if (tiff == (TIFF *) NULL)\n    return(MagickFalse);\n  scene=0;\n  debug=IsEventLogging();\n  (void) debug;\n  do\n  {\n    /*\n      Initialize TIFF fields.\n    */\n    if ((image_info->type != UndefinedType) &&\n        (image_info->type != OptimizeType))\n      (void) SetImageType(image,image_info->type,exception);\n    compression=UndefinedCompression;\n    if (image->compression != JPEGCompression)\n      compression=image->compression;\n    if (image_info->compression != UndefinedCompression)\n      compression=image_info->compression;\n    switch (compression)\n    {\n      case FaxCompression:\n      case Group4Compression:\n      {\n        (void) SetImageType(image,BilevelType,exception);\n        (void) SetImageDepth(image,1,exception);\n        break;\n      }\n      case JPEGCompression:\n      {\n        (void) SetImageStorageClass(image,DirectClass,exception);\n        (void) SetImageDepth(image,8,exception);\n        break;\n      }\n      default:\n        break;\n    }\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if ((image->storage_class != PseudoClass) && (image->depth >= 32) &&\n        (quantum_info->format == UndefinedQuantumFormat) &&\n        (IsHighDynamicRangeImage(image,exception) != MagickFalse))\n      {\n        status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);\n        if (status == MagickFalse)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    if ((LocaleCompare(image_info->magick,\"PTIF\") == 0) &&\n        (GetPreviousImageInList(image) != (Image *) NULL))\n      (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_REDUCEDIMAGE);\n    if ((image->columns != (uint32) image->columns) ||\n        (image->rows != (uint32) image->rows))\n      ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n    (void) TIFFSetField(tiff,TIFFTAG_IMAGELENGTH,(uint32) image->rows);\n    (void) TIFFSetField(tiff,TIFFTAG_IMAGEWIDTH,(uint32) image->columns);\n    switch (compression)\n    {\n      case FaxCompression:\n      {\n        compress_tag=COMPRESSION_CCITTFAX3;\n        SetQuantumMinIsWhite(quantum_info,MagickTrue);\n        break;\n      }\n      case Group4Compression:\n      {\n        compress_tag=COMPRESSION_CCITTFAX4;\n        SetQuantumMinIsWhite(quantum_info,MagickTrue);\n        break;\n      }\n#if defined(COMPRESSION_JBIG)\n      case JBIG1Compression:\n      {\n        compress_tag=COMPRESSION_JBIG;\n        break;\n      }\n#endif\n      case JPEGCompression:\n      {\n        compress_tag=COMPRESSION_JPEG;\n        break;\n      }\n#if defined(COMPRESSION_LZMA)\n      case LZMACompression:\n      {\n        compress_tag=COMPRESSION_LZMA;\n        break;\n      }\n#endif\n      case LZWCompression:\n      {\n        compress_tag=COMPRESSION_LZW;\n        break;\n      }\n      case RLECompression:\n      {\n        compress_tag=COMPRESSION_PACKBITS;\n        break;\n      }\n      case ZipCompression:\n      {\n        compress_tag=COMPRESSION_ADOBE_DEFLATE;\n        break;\n      }\n      case NoCompression:\n      default:\n      {\n        compress_tag=COMPRESSION_NONE;\n        break;\n      }\n    }\n#if defined(MAGICKCORE_HAVE_TIFFISCODECCONFIGURED) || (TIFFLIB_VERSION > 20040919)\n    if ((compress_tag != COMPRESSION_NONE) &&\n        (TIFFIsCODECConfigured(compress_tag) == 0))\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\n          \"CompressionNotSupported\",\"`%s'\",CommandOptionToMnemonic(\n          MagickCompressOptions,(ssize_t) compression));\n        compress_tag=COMPRESSION_NONE;\n        compression=NoCompression;\n      }\n#else\n      switch (compress_tag)\n      {\n#if defined(CCITT_SUPPORT)\n        case COMPRESSION_CCITTFAX3:\n        case COMPRESSION_CCITTFAX4:\n#endif\n#if defined(YCBCR_SUPPORT) && defined(JPEG_SUPPORT)\n        case COMPRESSION_JPEG:\n#endif\n#if defined(LZMA_SUPPORT) && defined(COMPRESSION_LZMA)\n        case COMPRESSION_LZMA:\n#endif\n#if defined(LZW_SUPPORT)\n        case COMPRESSION_LZW:\n#endif\n#if defined(PACKBITS_SUPPORT)\n        case COMPRESSION_PACKBITS:\n#endif\n#if defined(ZIP_SUPPORT)\n        case COMPRESSION_ADOBE_DEFLATE:\n#endif\n        case COMPRESSION_NONE:\n          break;\n        default:\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\n            \"CompressionNotSupported\",\"`%s'\",CommandOptionToMnemonic(\n              MagickCompressOptions,(ssize_t) compression));\n          compress_tag=COMPRESSION_NONE;\n          compression=NoCompression;\n          break;\n        }\n      }\n#endif\n    if (image->colorspace == CMYKColorspace)\n      {\n        photometric=PHOTOMETRIC_SEPARATED;\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,4);\n        (void) TIFFSetField(tiff,TIFFTAG_INKSET,INKSET_CMYK);\n      }\n    else\n      {\n        /*\n          Full color TIFF raster.\n        */\n        if (image->colorspace == LabColorspace)\n          {\n            photometric=PHOTOMETRIC_CIELAB;\n            EncodeLabImage(image,exception);\n          }\n        else\n          if (image->colorspace == YCbCrColorspace)\n            {\n              photometric=PHOTOMETRIC_YCBCR;\n              (void) TIFFSetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,1,1);\n              (void) SetImageStorageClass(image,DirectClass,exception);\n              (void) SetImageDepth(image,8,exception);\n            }\n          else\n            photometric=PHOTOMETRIC_RGB;\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,3);\n        if ((image_info->type != TrueColorType) &&\n            (image_info->type != TrueColorAlphaType))\n          {\n            if ((image_info->type != PaletteType) &&\n                (SetImageGray(image,exception) != MagickFalse))\n              {\n                photometric=(uint16) (quantum_info->min_is_white !=\n                  MagickFalse ? PHOTOMETRIC_MINISWHITE :\n                  PHOTOMETRIC_MINISBLACK);\n                (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,1);\n                if ((image->depth == 1) &&\n                    (image->alpha_trait == UndefinedPixelTrait))\n                  SetImageMonochrome(image,exception);\n              }\n            else\n              if (image->storage_class == PseudoClass)\n                {\n                  size_t\n                    depth;\n\n                  /*\n                    Colormapped TIFF raster.\n                  */\n                  (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,1);\n                  photometric=PHOTOMETRIC_PALETTE;\n                  depth=1;\n                  while ((GetQuantumRange(depth)+1) < image->colors)\n                    depth<<=1;\n                  status=SetQuantumDepth(image,quantum_info,depth);\n                  if (status == MagickFalse)\n                    ThrowWriterException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                }\n          }\n      }\n    (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_FILLORDER,&endian);\n    if ((compress_tag == COMPRESSION_CCITTFAX3) &&\n        (photometric != PHOTOMETRIC_MINISWHITE))\n      {\n        compress_tag=COMPRESSION_NONE;\n        endian=FILLORDER_MSB2LSB;\n      }\n    else\n      if ((compress_tag == COMPRESSION_CCITTFAX4) &&\n         (photometric != PHOTOMETRIC_MINISWHITE))\n       {\n         compress_tag=COMPRESSION_NONE;\n         endian=FILLORDER_MSB2LSB;\n       }\n    option=GetImageOption(image_info,\"tiff:fill-order\");\n    if (option != (const char *) NULL)\n      {\n        if (LocaleNCompare(option,\"msb\",3) == 0)\n          endian=FILLORDER_MSB2LSB;\n        if (LocaleNCompare(option,\"lsb\",3) == 0)\n          endian=FILLORDER_LSB2MSB;\n      }\n    (void) TIFFSetField(tiff,TIFFTAG_COMPRESSION,compress_tag);\n    (void) TIFFSetField(tiff,TIFFTAG_FILLORDER,endian);\n    (void) TIFFSetField(tiff,TIFFTAG_BITSPERSAMPLE,quantum_info->depth);\n    if (image->alpha_trait != UndefinedPixelTrait)\n      {\n        uint16\n          extra_samples,\n          sample_info[1],\n          samples_per_pixel;\n\n        /*\n          TIFF has a matte channel.\n        */\n        extra_samples=1;\n        sample_info[0]=EXTRASAMPLE_UNASSALPHA;\n        option=GetImageOption(image_info,\"tiff:alpha\");\n        if (option != (const char *) NULL)\n          {\n            if (LocaleCompare(option,\"associated\") == 0)\n              sample_info[0]=EXTRASAMPLE_ASSOCALPHA;\n            else\n              if (LocaleCompare(option,\"unspecified\") == 0)\n                sample_info[0]=EXTRASAMPLE_UNSPECIFIED;\n          }\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLESPERPIXEL,\n          &samples_per_pixel);\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,samples_per_pixel+1);\n        (void) TIFFSetField(tiff,TIFFTAG_EXTRASAMPLES,extra_samples,\n          &sample_info);\n        if (sample_info[0] == EXTRASAMPLE_ASSOCALPHA)\n          SetQuantumAlphaType(quantum_info,AssociatedQuantumAlpha);\n      }\n    (void) TIFFSetField(tiff,TIFFTAG_PHOTOMETRIC,photometric);\n    switch (quantum_info->format)\n    {\n      case FloatingPointQuantumFormat:\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_IEEEFP);\n        (void) TIFFSetField(tiff,TIFFTAG_SMINSAMPLEVALUE,quantum_info->minimum);\n        (void) TIFFSetField(tiff,TIFFTAG_SMAXSAMPLEVALUE,quantum_info->maximum);\n        break;\n      }\n      case SignedQuantumFormat:\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_INT);\n        break;\n      }\n      case UnsignedQuantumFormat:\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_UINT);\n        break;\n      }\n      default:\n        break;\n    }\n    (void) TIFFSetField(tiff,TIFFTAG_ORIENTATION,ORIENTATION_TOPLEFT);\n    (void) TIFFSetField(tiff,TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);\n    if (photometric == PHOTOMETRIC_RGB)\n      if ((image_info->interlace == PlaneInterlace) ||\n          (image_info->interlace == PartitionInterlace))\n        (void) TIFFSetField(tiff,TIFFTAG_PLANARCONFIG,PLANARCONFIG_SEPARATE);\n    switch (compress_tag)\n    {\n      case COMPRESSION_JPEG:\n      {\n#if defined(JPEG_SUPPORT)\n        const char\n          *sampling_factor;\n\n        GeometryInfo\n          geometry_info;\n\n        MagickStatusType\n          flags;\n\n        if (image_info->quality != UndefinedCompressionQuality)\n          (void) TIFFSetField(tiff,TIFFTAG_JPEGQUALITY,image_info->quality);\n        (void) TIFFSetField(tiff,TIFFTAG_JPEGCOLORMODE,JPEGCOLORMODE_RAW);\n        if (IssRGBCompatibleColorspace(image->colorspace) != MagickFalse)\n          {\n            const char\n              *value;\n\n            (void) TIFFSetField(tiff,TIFFTAG_JPEGCOLORMODE,JPEGCOLORMODE_RGB);\n            sampling_factor=(const char *) NULL;\n            value=GetImageProperty(image,\"jpeg:sampling-factor\",exception);\n            if (value != (char *) NULL)\n              {\n                sampling_factor=value;\n                if (image->debug != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  Input sampling-factors=%s\",sampling_factor);\n              }\n            if (image_info->sampling_factor != (char *) NULL)\n              sampling_factor=image_info->sampling_factor;\n            if (sampling_factor != (const char *) NULL)\n              {\n                flags=ParseGeometry(sampling_factor,&geometry_info);\n                if ((flags & SigmaValue) == 0)\n                  geometry_info.sigma=geometry_info.rho;\n                if (image->colorspace == YCbCrColorspace)\n                  (void) TIFFSetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,(uint16)\n                    geometry_info.rho,(uint16) geometry_info.sigma);\n              }\n          }\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,\n          &bits_per_sample);\n        if (bits_per_sample == 12)\n          (void) TIFFSetField(tiff,TIFFTAG_JPEGTABLESMODE,JPEGTABLESMODE_QUANT);\n#endif\n        break;\n      }\n      case COMPRESSION_ADOBE_DEFLATE:\n      {\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,\n          &bits_per_sample);\n        if (((photometric == PHOTOMETRIC_RGB) ||\n             (photometric == PHOTOMETRIC_MINISBLACK)) &&\n            ((bits_per_sample == 8) || (bits_per_sample == 16)))\n          (void) TIFFSetField(tiff,TIFFTAG_PREDICTOR,PREDICTOR_HORIZONTAL);\n        (void) TIFFSetField(tiff,TIFFTAG_ZIPQUALITY,(long) (\n          image_info->quality == UndefinedCompressionQuality ? 7 :\n          MagickMin((ssize_t) image_info->quality/10,9)));\n        break;\n      }\n      case COMPRESSION_CCITTFAX3:\n      {\n        /*\n          Byte-aligned EOL.\n        */\n        (void) TIFFSetField(tiff,TIFFTAG_GROUP3OPTIONS,4);\n        break;\n      }\n      case COMPRESSION_CCITTFAX4:\n        break;\n#if defined(LZMA_SUPPORT) && defined(COMPRESSION_LZMA)\n      case COMPRESSION_LZMA:\n      {\n        if (((photometric == PHOTOMETRIC_RGB) ||\n             (photometric == PHOTOMETRIC_MINISBLACK)) &&\n            ((bits_per_sample == 8) || (bits_per_sample == 16)))\n          (void) TIFFSetField(tiff,TIFFTAG_PREDICTOR,PREDICTOR_HORIZONTAL);\n        (void) TIFFSetField(tiff,TIFFTAG_LZMAPRESET,(long) (\n          image_info->quality == UndefinedCompressionQuality ? 7 :\n          MagickMin((ssize_t) image_info->quality/10,9)));\n        break;\n      }\n#endif\n      case COMPRESSION_LZW:\n      {\n        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,\n          &bits_per_sample);\n        if (((photometric == PHOTOMETRIC_RGB) ||\n             (photometric == PHOTOMETRIC_MINISBLACK)) &&\n            ((bits_per_sample == 8) || (bits_per_sample == 16)))\n          (void) TIFFSetField(tiff,TIFFTAG_PREDICTOR,PREDICTOR_HORIZONTAL);\n        break;\n      }\n      default:\n        break;\n    }\n    if ((image->resolution.x != 0.0) && (image->resolution.y != 0.0))\n      {\n        unsigned short\n          units;\n\n        /*\n          Set image resolution.\n        */\n        units=RESUNIT_NONE;\n        if (image->units == PixelsPerInchResolution)\n          units=RESUNIT_INCH;\n        if (image->units == PixelsPerCentimeterResolution)\n          units=RESUNIT_CENTIMETER;\n        (void) TIFFSetField(tiff,TIFFTAG_RESOLUTIONUNIT,(uint16) units);\n        (void) TIFFSetField(tiff,TIFFTAG_XRESOLUTION,image->resolution.x);\n        (void) TIFFSetField(tiff,TIFFTAG_YRESOLUTION,image->resolution.y);\n        if ((image->page.x < 0) || (image->page.y < 0))\n          (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\n            \"TIFF: negative image positions unsupported\",\"%s\",image->filename);\n        if ((image->page.x > 0) && (image->resolution.x > 0.0))\n          {\n            /*\n              Set horizontal image position.\n            */\n            (void) TIFFSetField(tiff,TIFFTAG_XPOSITION,(float) image->page.x/\n              image->resolution.x);\n          }\n        if ((image->page.y > 0) && (image->resolution.y > 0.0))\n          {\n            /*\n              Set vertical image position.\n            */\n            (void) TIFFSetField(tiff,TIFFTAG_YPOSITION,(float) image->page.y/\n              image->resolution.y);\n          }\n      }\n    if (image->chromaticity.white_point.x != 0.0)\n      {\n        float\n          chromaticity[6];\n\n        /*\n          Set image chromaticity.\n        */\n        chromaticity[0]=(float) image->chromaticity.red_primary.x;\n        chromaticity[1]=(float) image->chromaticity.red_primary.y;\n        chromaticity[2]=(float) image->chromaticity.green_primary.x;\n        chromaticity[3]=(float) image->chromaticity.green_primary.y;\n        chromaticity[4]=(float) image->chromaticity.blue_primary.x;\n        chromaticity[5]=(float) image->chromaticity.blue_primary.y;\n        (void) TIFFSetField(tiff,TIFFTAG_PRIMARYCHROMATICITIES,chromaticity);\n        chromaticity[0]=(float) image->chromaticity.white_point.x;\n        chromaticity[1]=(float) image->chromaticity.white_point.y;\n        (void) TIFFSetField(tiff,TIFFTAG_WHITEPOINT,chromaticity);\n      }\n    if ((LocaleCompare(image_info->magick,\"PTIF\") != 0) &&\n        (image_info->adjoin != MagickFalse) && (GetImageListLength(image) > 1))\n      {\n        (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_PAGE);\n        if (image->scene != 0)\n          (void) TIFFSetField(tiff,TIFFTAG_PAGENUMBER,(uint16) image->scene,\n            GetImageListLength(image));\n      }\n    if (image->orientation != UndefinedOrientation)\n      (void) TIFFSetField(tiff,TIFFTAG_ORIENTATION,(uint16) image->orientation);\n    (void) TIFFSetProfiles(tiff,image);\n    {\n      uint16\n        page,\n        pages;\n\n      page=(uint16) scene;\n      pages=(uint16) GetImageListLength(image);\n      if ((LocaleCompare(image_info->magick,\"PTIF\") != 0) &&\n          (image_info->adjoin != MagickFalse) && (pages > 1))\n        (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_PAGE);\n      (void) TIFFSetField(tiff,TIFFTAG_PAGENUMBER,page,pages);\n    }\n    (void) TIFFSetProperties(tiff,image_info,image,exception);\nDisableMSCWarning(4127)\n    if (0)\nRestoreMSCWarning\n      (void) TIFFSetEXIFProperties(tiff,image,exception);\n    /*\n      Write image scanlines.\n    */\n    if (GetTIFFInfo(image_info,tiff,&tiff_info) == MagickFalse)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    quantum_info->endian=LSBEndian;\n    pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n    tiff_info.scanline=(unsigned char *) GetQuantumPixels(quantum_info);\n    switch (photometric)\n    {\n      case PHOTOMETRIC_CIELAB:\n      case PHOTOMETRIC_YCBCR:\n      case PHOTOMETRIC_RGB:\n      {\n        /*\n          RGB TIFF image.\n        */\n        switch (image_info->interlace)\n        {\n          case NoInterlace:\n          default:\n          {\n            quantum_type=RGBQuantum;\n            if (image->alpha_trait != UndefinedPixelTrait)\n              quantum_type=RGBAQuantum;\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              register const Quantum\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                quantum_type,pixels,exception);\n              (void) length;\n              if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            break;\n          }\n          case PlaneInterlace:\n          case PartitionInterlace:\n          {\n            /*\n              Plane interlacing:  RRRRRR...GGGGGG...BBBBBB...\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              register const Quantum\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                RedQuantum,pixels,exception);\n              if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n                break;\n            }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,100,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              register const Quantum\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                GreenQuantum,pixels,exception);\n              if (TIFFWritePixels(tiff,&tiff_info,y,1,image) == -1)\n                break;\n            }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,200,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              register const Quantum\n                *magick_restrict p;\n\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                BlueQuantum,pixels,exception);\n              if (TIFFWritePixels(tiff,&tiff_info,y,2,image) == -1)\n                break;\n            }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,300,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            if (image->alpha_trait != UndefinedPixelTrait)\n              for (y=0; y < (ssize_t) image->rows; y++)\n              {\n                register const Quantum\n                  *magick_restrict p;\n\n                p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n                if (p == (const Quantum *) NULL)\n                  break;\n                length=ExportQuantumPixels(image,(CacheView *) NULL,\n                  quantum_info,AlphaQuantum,pixels,exception);\n                if (TIFFWritePixels(tiff,&tiff_info,y,3,image) == -1)\n                  break;\n              }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,400,400);\n                if (status == MagickFalse)\n                  break;\n              }\n            break;\n          }\n        }\n        break;\n      }\n      case PHOTOMETRIC_SEPARATED:\n      {\n        /*\n          CMYK TIFF image.\n        */\n        quantum_type=CMYKQuantum;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          quantum_type=CMYKAQuantum;\n        if (image->colorspace != CMYKColorspace)\n          (void) TransformImageColorspace(image,CMYKColorspace,exception);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            quantum_type,pixels,exception);\n          if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case PHOTOMETRIC_PALETTE:\n      {\n        uint16\n          *blue,\n          *green,\n          *red;\n\n        /*\n          Colormapped TIFF image.\n        */\n        red=(uint16 *) AcquireQuantumMemory(65536,sizeof(*red));\n        green=(uint16 *) AcquireQuantumMemory(65536,sizeof(*green));\n        blue=(uint16 *) AcquireQuantumMemory(65536,sizeof(*blue));\n        if ((red == (uint16 *) NULL) || (green == (uint16 *) NULL) ||\n            (blue == (uint16 *) NULL))\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        /*\n          Initialize TIFF colormap.\n        */\n        (void) ResetMagickMemory(red,0,65536*sizeof(*red));\n        (void) ResetMagickMemory(green,0,65536*sizeof(*green));\n        (void) ResetMagickMemory(blue,0,65536*sizeof(*blue));\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          red[i]=ScaleQuantumToShort(image->colormap[i].red);\n          green[i]=ScaleQuantumToShort(image->colormap[i].green);\n          blue[i]=ScaleQuantumToShort(image->colormap[i].blue);\n        }\n        (void) TIFFSetField(tiff,TIFFTAG_COLORMAP,red,green,blue);\n        red=(uint16 *) RelinquishMagickMemory(red);\n        green=(uint16 *) RelinquishMagickMemory(green);\n        blue=(uint16 *) RelinquishMagickMemory(blue);\n      }\n      default:\n      {\n        /*\n          Convert PseudoClass packets to contiguous grayscale scanlines.\n        */\n        quantum_type=IndexQuantum;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          {\n            if (photometric != PHOTOMETRIC_PALETTE)\n              quantum_type=GrayAlphaQuantum;\n            else\n              quantum_type=IndexAlphaQuantum;\n           }\n         else\n           if (photometric != PHOTOMETRIC_PALETTE)\n             quantum_type=GrayQuantum;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          register const Quantum\n            *magick_restrict p;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            quantum_type,pixels,exception);\n          if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n    }\n    quantum_info=DestroyQuantumInfo(quantum_info);\n    if (image->colorspace == LabColorspace)\n      DecodeLabImage(image,exception);\n    DestroyTIFFInfo(&tiff_info);\nDisableMSCWarning(4127)\n    if (0 && (image_info->verbose != MagickFalse))\nRestoreMSCWarning\n      TIFFPrintDirectory(tiff,stdout,MagickFalse);\n    (void) TIFFWriteDirectory(tiff);\n    image=SyncNextImageInList(image);\n    if (image == (Image *) NULL)\n      break;\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  TIFFClose(tiff);\n  return(MagickTrue);\n}\n", "target": 0, "idx": 73243}
{"func": "NO_INLINE JsVar *jspeBlockOrStatement() {\n  if (lex->tk=='{') {\n    jspeBlock();\n    return 0;\n  } else {\n    JsVar *v = jspeStatement();\n    if (lex->tk==';') JSP_ASSERT_MATCH(';');\n    return v;\n  }\n}\n\n/** Parse using current lexer until we hit the end of\n * input or there was some problem. */\nNO_INLINE JsVar *jspParse() {\n  JsVar *v = 0;\n  while (!JSP_SHOULDNT_PARSE && lex->tk != LEX_EOF) {\n    jsvUnLock(v);\n    v = jspeBlockOrStatement();\n  }\n  return v;\n}\n\nNO_INLINE JsVar *jspeStatementVar() {\n  JsVar *lastDefined = 0;\n  /* variable creation. TODO - we need a better way of parsing the left\n   * hand side. Maybe just have a flag called can_create_var that we\n   * set and then we parse as if we're doing a normal equals.*/\n  assert(lex->tk==LEX_R_VAR || lex->tk==LEX_R_LET || lex->tk==LEX_R_CONST);\n  jslGetNextToken();\n  bool hasComma = true; // for first time in loop\n  while (hasComma && lex->tk == LEX_ID && !jspIsInterrupted()) {\n    JsVar *a = 0;\n    if (JSP_SHOULD_EXECUTE) {\n      a = jspeiFindOnTop(jslGetTokenValueAsString(lex), true);\n      if (!a) { // out of memory\n        jspSetError(false);\n        return lastDefined;\n      }\n    }\n    JSP_MATCH_WITH_CLEANUP_AND_RETURN(LEX_ID, jsvUnLock(a), lastDefined);\n    if (lex->tk == '=') {\n      JsVar *var;\n      JSP_MATCH_WITH_CLEANUP_AND_RETURN('=', jsvUnLock(a), lastDefined);\n      var = jsvSkipNameAndUnLock(jspeAssignmentExpression());\n      if (JSP_SHOULD_EXECUTE)\n        jsvReplaceWith(a, var);\n      jsvUnLock(var);\n    }\n    jsvUnLock(lastDefined);\n    lastDefined = a;\n    hasComma = lex->tk == ',';\n    if (hasComma) JSP_MATCH_WITH_RETURN(',', lastDefined);\n  }\n  return lastDefined;\n}\n\nNO_INLINE JsVar *jspeStatementIf() {\n  bool cond;\n  JsVar *var, *result = 0;\n  JSP_ASSERT_MATCH(LEX_R_IF);\n  JSP_MATCH('(');\n  var = jspeExpression();\n  if (JSP_SHOULDNT_PARSE) return var;\n  JSP_MATCH(')');\n  cond = JSP_SHOULD_EXECUTE && jsvGetBoolAndUnLock(jsvSkipName(var));\n  jsvUnLock(var);\n\n  JSP_SAVE_EXECUTE();\n  if (!cond) jspSetNoExecute();\n  JsVar *a = jspeBlockOrStatement();\n  if (!cond) {\n    jsvUnLock(a);\n    JSP_RESTORE_EXECUTE();\n  } else {\n    result = a;\n  }\n  if (lex->tk==LEX_R_ELSE) {\n    JSP_ASSERT_MATCH(LEX_R_ELSE);\n    JSP_SAVE_EXECUTE();\n    if (cond) jspSetNoExecute();\n    JsVar *a = jspeBlockOrStatement();\n    if (cond) {\n      jsvUnLock(a);\n      JSP_RESTORE_EXECUTE();\n    } else {\n      result = a;\n    }\n  }\n  return result;\n}\n\nNO_INLINE JsVar *jspeStatementSwitch() {\n  JSP_ASSERT_MATCH(LEX_R_SWITCH);\n  JSP_MATCH('(');\n  JsVar *switchOn = jspeExpression();\n  JSP_SAVE_EXECUTE();\n  bool execute = JSP_SHOULD_EXECUTE;\n  JSP_MATCH_WITH_CLEANUP_AND_RETURN(')', jsvUnLock(switchOn), 0);\n  if (!execute) { jsvUnLock(switchOn); jspeBlock(); return 0; }\n  JSP_MATCH_WITH_CLEANUP_AND_RETURN('{', jsvUnLock(switchOn), 0);\n\n  bool executeDefault = true;\n  if (execute) execInfo.execute=EXEC_NO|EXEC_IN_SWITCH;\n  while (lex->tk==LEX_R_CASE) {\n    JSP_MATCH_WITH_CLEANUP_AND_RETURN(LEX_R_CASE, jsvUnLock(switchOn), 0);\n    JsExecFlags oldFlags = execInfo.execute;\n    if (execute) execInfo.execute=EXEC_YES|EXEC_IN_SWITCH;\n    JsVar *test = jspeAssignmentExpression();\n    execInfo.execute = oldFlags|EXEC_IN_SWITCH;;\n    JSP_MATCH_WITH_CLEANUP_AND_RETURN(':', jsvUnLock2(switchOn, test), 0);\n    bool cond = false;\n    if (execute)\n      cond = jsvGetBoolAndUnLock(jsvMathsOpSkipNames(switchOn, test, LEX_TYPEEQUAL));\n    if (cond) executeDefault = false;\n    jsvUnLock(test);\n    if (cond && (execInfo.execute&EXEC_RUN_MASK)==EXEC_NO)\n      execInfo.execute=EXEC_YES|EXEC_IN_SWITCH;\n    while (!JSP_SHOULDNT_PARSE && lex->tk!=LEX_EOF && lex->tk!=LEX_R_CASE && lex->tk!=LEX_R_DEFAULT && lex->tk!='}')\n      jsvUnLock(jspeBlockOrStatement());\n    oldExecute |= execInfo.execute & (EXEC_ERROR_MASK|EXEC_RETURN); // copy across any errors/exceptions/returns\n  }\n  jsvUnLock(switchOn);\n  if (execute && (execInfo.execute&EXEC_RUN_MASK)==EXEC_BREAK) {\n    execInfo.execute=EXEC_YES|EXEC_IN_SWITCH;\n  } else {\n    executeDefault = true;\n  }\n  JSP_RESTORE_EXECUTE();\n\n  if (lex->tk==LEX_R_DEFAULT) {\n    JSP_ASSERT_MATCH(LEX_R_DEFAULT);\n    JSP_MATCH(':');\n    JSP_SAVE_EXECUTE();\n    if (!executeDefault) jspSetNoExecute();\n    else execInfo.execute |= EXEC_IN_SWITCH;\n    while (!JSP_SHOULDNT_PARSE && lex->tk!=LEX_EOF && lex->tk!='}')\n      jsvUnLock(jspeBlockOrStatement());\n    oldExecute |= execInfo.execute & (EXEC_ERROR_MASK|EXEC_RETURN); // copy across any errors/exceptions/returns\n    execInfo.execute = execInfo.execute & (JsExecFlags)~EXEC_BREAK;\n    JSP_RESTORE_EXECUTE();\n  }\n  JSP_MATCH('}');\n", "target": 0, "idx": 82344}
{"func": "const Chapters::Display* Chapters::Atom::GetDisplay(int index) const\n{\n    if (index < 0)\n        return NULL;\n    if (index >= m_displays_count)\n        return NULL;\n    return m_displays + index;\n}\n", "target": 1, "idx": 188326}
{"func": "static int gdImageTileGet (gdImagePtr im, int x, int y)\n{\n\tint srcx, srcy;\n\tint tileColor,p;\n\tif (!im->tile) {\n\t\treturn -1;\n\t}\n\tsrcx = x % gdImageSX(im->tile);\n\tsrcy = y % gdImageSY(im->tile);\n\tp = gdImageGetPixel(im->tile, srcx, srcy);\n\n\tif (im->trueColor) {\n\t\tif (im->tile->trueColor) {\n\t\t\ttileColor = p;\n\t\t} else {\n\t\t\ttileColor = gdTrueColorAlpha( gdImageRed(im->tile,p), gdImageGreen(im->tile,p), gdImageBlue (im->tile,p), gdImageAlpha (im->tile,p));\n\t\t}\n\t} else {\n\t\tif (im->tile->trueColor) {\n\t\t\ttileColor = gdImageColorResolveAlpha(im, gdTrueColorGetRed (p), gdTrueColorGetGreen (p), gdTrueColorGetBlue (p), gdTrueColorGetAlpha (p));\n\t\t} else {\n\t\t\ttileColor = p;\n\t\t\ttileColor = gdImageColorResolveAlpha(im, gdImageRed (im->tile,p), gdImageGreen (im->tile,p), gdImageBlue (im->tile,p), gdImageAlpha (im->tile,p));\n\t\t}\n\t}\n\treturn tileColor;\n}\n", "target": 0, "idx": 51460}
{"func": "ofputil_decode_port_stats(struct ofputil_port_stats *ps, struct ofpbuf *msg)\n{\n    enum ofperr error;\n    enum ofpraw raw;\n\n    memset(&(ps->stats), 0xFF, sizeof (ps->stats));\n\n    error = (msg->header ? ofpraw_decode(&raw, msg->header)\n             : ofpraw_pull(&raw, msg));\n    if (error) {\n        return error;\n    }\n\n    if (!msg->size) {\n        return EOF;\n    } else if (raw == OFPRAW_OFPST14_PORT_REPLY) {\n        return ofputil_pull_ofp14_port_stats(ps, msg);\n    } else if (raw == OFPRAW_OFPST13_PORT_REPLY) {\n        const struct ofp13_port_stats *ps13;\n        ps13 = ofpbuf_try_pull(msg, sizeof *ps13);\n        if (!ps13) {\n            goto bad_len;\n        }\n        return ofputil_port_stats_from_ofp13(ps, ps13);\n    } else if (raw == OFPRAW_OFPST11_PORT_REPLY) {\n        const struct ofp11_port_stats *ps11;\n\n        ps11 = ofpbuf_try_pull(msg, sizeof *ps11);\n        if (!ps11) {\n            goto bad_len;\n        }\n        return ofputil_port_stats_from_ofp11(ps, ps11);\n    } else if (raw == OFPRAW_OFPST10_PORT_REPLY) {\n        const struct ofp10_port_stats *ps10;\n\n        ps10 = ofpbuf_try_pull(msg, sizeof *ps10);\n        if (!ps10) {\n            goto bad_len;\n        }\n        return ofputil_port_stats_from_ofp10(ps, ps10);\n    } else {\n        OVS_NOT_REACHED();\n    }\n\n bad_len:\n    VLOG_WARN_RL(&bad_ofmsg_rl, \"OFPST_PORT reply has %\"PRIu32\" leftover \"\n                 \"bytes at end\", msg->size);\n    return OFPERR_OFPBRC_BAD_LEN;\n}\n", "target": 0, "idx": 77531}
{"func": "OMX_ERRORTYPE  omx_video::use_input_buffer(\n        OMX_IN OMX_HANDLETYPE            hComp,\n        OMX_INOUT OMX_BUFFERHEADERTYPE** bufferHdr,\n        OMX_IN OMX_U32                   port,\n        OMX_IN OMX_PTR                   appData,\n        OMX_IN OMX_U32                   bytes,\n        OMX_IN OMX_U8*                   buffer)\n{\n (void) hComp;\n    OMX_ERRORTYPE eRet = OMX_ErrorNone;\n\n unsigned   i = 0;\n unsigned char *buf_addr = NULL;\n\n    DEBUG_PRINT_HIGH(\"use_input_buffer: port = %u appData = %p bytes = %u buffer = %p\",(unsigned int)port,appData,(unsigned int)bytes,buffer);\n if (bytes != m_sInPortDef.nBufferSize) {\n        DEBUG_PRINT_ERROR(\"ERROR: use_input_buffer: Size Mismatch!! \"\n \"bytes[%u] != Port.nBufferSize[%u]\", (unsigned int)bytes, (unsigned int)m_sInPortDef.nBufferSize);\n return OMX_ErrorBadParameter;\n }\n\n if (!m_inp_mem_ptr) {\n        input_use_buffer = true;\n        m_inp_mem_ptr = (OMX_BUFFERHEADERTYPE*) \\\n                        calloc( (sizeof(OMX_BUFFERHEADERTYPE)), m_sInPortDef.nBufferCountActual);\n if (m_inp_mem_ptr == NULL) {\n            DEBUG_PRINT_ERROR(\"ERROR: calloc() Failed for m_inp_mem_ptr\");\n return OMX_ErrorInsufficientResources;\n }\n        DEBUG_PRINT_LOW(\"Successfully allocated m_inp_mem_ptr = %p\", m_inp_mem_ptr);\n\n\n        m_pInput_pmem = (struct pmem *) calloc(sizeof (struct pmem), m_sInPortDef.nBufferCountActual);\n if (m_pInput_pmem == NULL) {\n            DEBUG_PRINT_ERROR(\"ERROR: calloc() Failed for m_pInput_pmem\");\n return OMX_ErrorInsufficientResources;\n }\n#ifdef USE_ION\n        m_pInput_ion = (struct venc_ion *) calloc(sizeof (struct venc_ion), m_sInPortDef.nBufferCountActual);\n if (m_pInput_ion == NULL) {\n            DEBUG_PRINT_ERROR(\"ERROR: calloc() Failed for m_pInput_ion\");\n return OMX_ErrorInsufficientResources;\n }\n#endif\n\n for (i=0; i< m_sInPortDef.nBufferCountActual; i++) {\n            m_pInput_pmem[i].fd = -1;\n#ifdef USE_ION\n            m_pInput_ion[i].ion_device_fd =-1;\n            m_pInput_ion[i].fd_ion_data.fd =-1;\n            m_pInput_ion[i].ion_alloc_data.handle = 0;\n#endif\n }\n\n }\n\n for (i=0; i< m_sInPortDef.nBufferCountActual; i++) {\n if (BITMASK_ABSENT(&m_inp_bm_count,i)) {\n break;\n }\n }\n\n if (i < m_sInPortDef.nBufferCountActual) {\n\n *bufferHdr = (m_inp_mem_ptr + i);\n        BITMASK_SET(&m_inp_bm_count,i);\n\n (*bufferHdr)->pBuffer           = (OMX_U8 *)buffer;\n (*bufferHdr)->nSize             = sizeof(OMX_BUFFERHEADERTYPE);\n (*bufferHdr)->nVersion.nVersion = OMX_SPEC_VERSION;\n (*bufferHdr)->nAllocLen         = m_sInPortDef.nBufferSize;\n (*bufferHdr)->pAppPrivate       = appData;\n (*bufferHdr)->nInputPortIndex   = PORT_INDEX_IN;\n\n if (!m_use_input_pmem) {\n#ifdef USE_ION\n#ifdef _MSM8974_\n            m_pInput_ion[i].ion_device_fd = alloc_map_ion_memory(m_sInPortDef.nBufferSize,\n &m_pInput_ion[i].ion_alloc_data,\n &m_pInput_ion[i].fd_ion_data,0);\n#else\n            m_pInput_ion[i].ion_device_fd = alloc_map_ion_memory(m_sInPortDef.nBufferSize,\n &m_pInput_ion[i].ion_alloc_data,\n &m_pInput_ion[i].fd_ion_data,ION_FLAG_CACHED);\n#endif\n if (m_pInput_ion[i].ion_device_fd < 0) {\n                DEBUG_PRINT_ERROR(\"ERROR:ION device open() Failed\");\n return OMX_ErrorInsufficientResources;\n }\n            m_pInput_pmem[i].fd = m_pInput_ion[i].fd_ion_data.fd;\n#else\n            m_pInput_pmem[i].fd = open (MEM_DEVICE,O_RDWR);\n if (m_pInput_pmem[i].fd == 0) {\n                m_pInput_pmem[i].fd = open (MEM_DEVICE,O_RDWR);\n }\n\n if (m_pInput_pmem[i] .fd < 0) {\n                DEBUG_PRINT_ERROR(\"ERROR: /dev/pmem_adsp open() Failed\");\n return OMX_ErrorInsufficientResources;\n }\n#endif\n\n             m_pInput_pmem[i].size = m_sInPortDef.nBufferSize;\n             m_pInput_pmem[i].offset = 0;\n \n            m_pInput_pmem[i].buffer = (OMX_U8 *)SECURE_BUFPTR;\n             if(!secure_session) {\n                 m_pInput_pmem[i].buffer = (unsigned char *)mmap(\n                     NULL,m_pInput_pmem[i].size,PROT_READ|PROT_WRITE,\n                    MAP_SHARED,m_pInput_pmem[i].fd,0);\n\n \n             if (m_pInput_pmem[i].buffer == MAP_FAILED) {\n                     DEBUG_PRINT_ERROR(\"ERROR: mmap() Failed\");\n                 close(m_pInput_pmem[i].fd);\n #ifdef USE_ION\n                 free_ion_memory(&m_pInput_ion[i]);\n#endif\n return OMX_ErrorInsufficientResources;\n }\n }\n\n } else {\n            OMX_QCOM_PLATFORM_PRIVATE_PMEM_INFO *pParam = reinterpret_cast<OMX_QCOM_PLATFORM_PRIVATE_PMEM_INFO *>((*bufferHdr)->pAppPrivate);\n            DEBUG_PRINT_LOW(\"Inside qcom_ext with luma:(fd:%lu,offset:0x%x)\", pParam->pmem_fd, (unsigned)pParam->offset);\n\n if (pParam) {\n                m_pInput_pmem[i].fd = pParam->pmem_fd;\n                m_pInput_pmem[i].offset = pParam->offset;\n                m_pInput_pmem[i].size = m_sInPortDef.nBufferSize;\n                m_pInput_pmem[i].buffer = (unsigned char *)buffer;\n                DEBUG_PRINT_LOW(\"DBG:: pParam->pmem_fd = %u, pParam->offset = %u\",\n (unsigned int)pParam->pmem_fd, (unsigned int)pParam->offset);\n } else {\n                DEBUG_PRINT_ERROR(\"ERROR: Invalid AppData given for PMEM i/p UseBuffer case\");\n return OMX_ErrorBadParameter;\n }\n }\n\n        DEBUG_PRINT_LOW(\"use_inp:: bufhdr = %p, pBuffer = %p, m_pInput_pmem[i].buffer = %p\",\n (*bufferHdr), (*bufferHdr)->pBuffer, m_pInput_pmem[i].buffer);\n if ( dev_use_buf(&m_pInput_pmem[i],PORT_INDEX_IN,i) != true) {\n            DEBUG_PRINT_ERROR(\"ERROR: dev_use_buf() Failed for i/p buf\");\n return OMX_ErrorInsufficientResources;\n }\n } else {\n        DEBUG_PRINT_ERROR(\"ERROR: All buffers are already used, invalid use_buf call for \"\n \"index = %u\", i);\n        eRet = OMX_ErrorInsufficientResources;\n }\n\n return eRet;\n}\n", "target": 1, "idx": 187525}
{"func": "void ShelfWidget::DelegateView::UpdateOpaqueBackground() {\n  const gfx::Rect local_bounds = GetLocalBounds();\n  gfx::Rect opaque_background_bounds = local_bounds;\n\n  const Shelf* shelf = shelf_widget_->shelf();\n  const ShelfBackgroundType background_type =\n      shelf_widget_->GetBackgroundType();\n\n  if (background_type == SHELF_BACKGROUND_APP_LIST) {\n    opaque_background_.SetVisible(false);\n    UpdateBackgroundBlur();\n    return;\n  }\n\n  if (!opaque_background_.visible())\n    opaque_background_.SetVisible(true);\n\n  const int radius = kShelfRoundedCornerRadius;\n  const int safety_margin = 3 * radius;\n  opaque_background_bounds.Inset(\n      -shelf->SelectValueForShelfAlignment(0, safety_margin, 0), 0,\n       -shelf->SelectValueForShelfAlignment(0, 0, safety_margin),\n       -shelf->SelectValueForShelfAlignment(safety_margin, 0, 0));\n \n  if (background_type == SHELF_BACKGROUND_MAXIMIZED ||\n      background_type == SHELF_BACKGROUND_SPLIT_VIEW) {\n     mask_ = nullptr;\n     opaque_background_.SetMaskLayer(nullptr);\n   } else {\n    if (!mask_) {\n      mask_ = views::Painter::CreatePaintedLayer(\n          views::Painter::CreateSolidRoundRectPainter(SK_ColorBLACK, radius));\n      mask_->layer()->SetFillsBoundsOpaquely(false);\n      opaque_background_.SetMaskLayer(mask_->layer());\n    }\n    if (mask_->layer()->bounds() != opaque_background_bounds)\n      mask_->layer()->SetBounds(opaque_background_bounds);\n  }\n  opaque_background_.SetBounds(opaque_background_bounds);\n  UpdateBackgroundBlur();\n  SchedulePaint();\n}\n", "target": 1, "idx": 186044}
{"func": "static void unix_detach_fds(struct scm_cookie *scm, struct sk_buff *skb)\n{\n\tint i;\n\n\tscm->fp = UNIXCB(skb).fp;\n \tUNIXCB(skb).fp = NULL;\n \n \tfor (i = scm->fp->count-1; i >= 0; i--)\n\t\tunix_notinflight(scm->fp->fp[i]);\n }\n", "target": 1, "idx": 180567}
{"func": " static zval *xml_call_handler(xml_parser *parser, zval *handler, zend_function *function_ptr, int argc, zval **argv)\n {\n       int i;  \n        TSRMLS_FETCH();\n \n        if (parser && handler && !EG(exception)) {\n\t\tzval ***args;\n\t\tzval *retval;\n\t\tint result;\n\t\tzend_fcall_info fci;\n\n\t\targs = safe_emalloc(sizeof(zval **), argc, 0);\n                for (i = 0; i < argc; i++) {\n                        args[i] = &argv[i];\n                }\n                fci.size = sizeof(fci);\n                fci.function_table = EG(function_table);\n                fci.function_name = handler;\n\t\tfci.symbol_table = NULL;\n\t\tfci.object_ptr = parser->object;\n\t\tfci.retval_ptr_ptr = &retval;\n\t\tfci.param_count = argc;\n\t\tfci.params = args;\n\t\tfci.no_separation = 0;\n\t\t/*fci.function_handler_cache = &function_ptr;*/\n\n\t\tresult = zend_call_function(&fci, NULL TSRMLS_CC);\n\t\tif (result == FAILURE) {\n\t\t\tzval **method;\n\t\t\tzval **obj;\n\n\t\t\tif (Z_TYPE_P(handler) == IS_STRING) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to call handler %s()\", Z_STRVAL_P(handler));\n\t\t\t} else if (zend_hash_index_find(Z_ARRVAL_P(handler), 0, (void **) &obj) == SUCCESS &&\n\t\t\t\t\t   zend_hash_index_find(Z_ARRVAL_P(handler), 1, (void **) &method) == SUCCESS &&\n                                           Z_TYPE_PP(obj) == IS_OBJECT &&\n                                           Z_TYPE_PP(method) == IS_STRING) {\n                                php_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to call handler %s::%s()\", Z_OBJCE_PP(obj)->name, Z_STRVAL_PP(method));\n                       } else \n                                php_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to call handler\");\n                }\n \n\t\tfor (i = 0; i < argc; i++) {\n\t\t\tzval_ptr_dtor(args[i]);\n\t\t}\n\t\tefree(args);\n\n\t\tif (result == FAILURE) {\n\t\t\treturn NULL;\n\t\t} else {\n\t\t\treturn EG(exception) ? NULL : retval;\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < argc; i++) {\n\t\t\tzval_ptr_dtor(&argv[i]);\n\t\t}\n\t\treturn NULL;\n\t}\n}\n", "target": 1, "idx": 178218}
{"func": "  parse_cmdline( int*     argc,\n                 char***  argv )\n  {\n    char*  execname;\n    int    option;\n\n\n    execname = ft_basename( (*argv)[0] );\n\n    while ( 1 )\n    {\n      option = getopt( *argc, *argv, \"e:m:r:\" );\n\n      if ( option == -1 )\n        break;\n\n      switch ( option )\n      {\n      case 'e':\n        status.encoding = FTDemo_Make_Encoding_Tag( optarg );\n        break;\n\n      case 'r':\n        status.res = atoi( optarg );\n        if ( status.res < 1 )\n          usage( execname );\n        break;\n\n      case 'm':\n        if ( *argc < 3 )\n          usage( execname );\n        Text = optarg;\n        break;\n\n      default:\n        usage( execname );\n        break;\n      }\n    }\n\n    *argc -= optind;\n    *argv += optind;\n\n    if ( *argc <= 1 )\n      usage( execname );\n\n    status.ptsize = (int)(atof( *argv[0] ) * 64.0);\n    if ( status.ptsize == 0 )\n      status.ptsize = 64;\n\n    (*argc)--;\n    (*argv)++;\n  }\n", "target": 0, "idx": 10049}
{"func": "static int usb_enumerate_device_otg(struct usb_device *udev)\n{\n\tint err = 0;\n\n#ifdef\tCONFIG_USB_OTG\n\t/*\n\t * OTG-aware devices on OTG-capable root hubs may be able to use SRP,\n\t * to wake us after we've powered off VBUS; and HNP, switching roles\n\t * \"host\" to \"peripheral\".  The OTG descriptor helps figure this out.\n\t */\n\tif (!udev->bus->is_b_host\n\t\t\t&& udev->config\n\t\t\t&& udev->parent == udev->bus->root_hub) {\n\t\tstruct usb_otg_descriptor\t*desc = NULL;\n\t\tstruct usb_bus\t\t\t*bus = udev->bus;\n\t\tunsigned\t\t\tport1 = udev->portnum;\n\n \t\t/* descriptor may appear anywhere in config */\n \t\terr = __usb_get_extra_descriptor(udev->rawdescriptors[0],\n \t\t\t\tle16_to_cpu(udev->config[0].desc.wTotalLength),\n\t\t\t\tUSB_DT_OTG, (void **) &desc);\n \t\tif (err || !(desc->bmAttributes & USB_OTG_HNP))\n \t\t\treturn 0;\n \n\t\tdev_info(&udev->dev, \"Dual-Role OTG device on %sHNP port\\n\",\n\t\t\t\t\t(port1 == bus->otg_port) ? \"\" : \"non-\");\n\n\t\t/* enable HNP before suspend, it's simpler */\n\t\tif (port1 == bus->otg_port) {\n\t\t\tbus->b_hnp_enable = 1;\n\t\t\terr = usb_control_msg(udev,\n\t\t\t\tusb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_SET_FEATURE, 0,\n\t\t\t\tUSB_DEVICE_B_HNP_ENABLE,\n\t\t\t\t0, NULL, 0,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\t\t\tif (err < 0) {\n\t\t\t\t/*\n\t\t\t\t * OTG MESSAGE: report errors here,\n\t\t\t\t * customize to match your product.\n\t\t\t\t */\n\t\t\t\tdev_err(&udev->dev, \"can't set HNP mode: %d\\n\",\n\t\t\t\t\t\t\t\t\terr);\n\t\t\t\tbus->b_hnp_enable = 0;\n\t\t\t}\n\t\t} else if (desc->bLength == sizeof\n\t\t\t\t(struct usb_otg_descriptor)) {\n\t\t\t/* Set a_alt_hnp_support for legacy otg device */\n\t\t\terr = usb_control_msg(udev,\n\t\t\t\tusb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_SET_FEATURE, 0,\n\t\t\t\tUSB_DEVICE_A_ALT_HNP_SUPPORT,\n\t\t\t\t0, NULL, 0,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\t\t\tif (err < 0)\n\t\t\t\tdev_err(&udev->dev,\n\t\t\t\t\t\"set a_alt_hnp_support failed: %d\\n\",\n\t\t\t\t\terr);\n\t\t}\n\t}\n#endif\n\treturn err;\n}\n", "target": 1, "idx": 182131}
{"func": "int ext4_punch_hole(struct inode *inode, loff_t offset, loff_t length)\n{\n\tstruct super_block *sb = inode->i_sb;\n\text4_lblk_t first_block, stop_block;\n\tstruct address_space *mapping = inode->i_mapping;\n\tloff_t first_block_offset, last_block_offset;\n\thandle_t *handle;\n\tunsigned int credits;\n\tint ret = 0;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\n\ttrace_ext4_punch_hole(inode, offset, length, 0);\n\n\t/*\n\t * Write out all dirty pages to avoid race conditions\n\t * Then release them.\n\t */\n\tif (mapping->nrpages && mapping_tagged(mapping, PAGECACHE_TAG_DIRTY)) {\n\t\tret = filemap_write_and_wait_range(mapping, offset,\n\t\t\t\t\t\t   offset + length - 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tmutex_lock(&inode->i_mutex);\n\n\t/* No need to punch hole beyond i_size */\n\tif (offset >= inode->i_size)\n\t\tgoto out_mutex;\n\n\t/*\n\t * If the hole extends beyond i_size, set the hole\n\t * to end after the page that contains i_size\n\t */\n\tif (offset + length > inode->i_size) {\n\t\tlength = inode->i_size +\n\t\t   PAGE_CACHE_SIZE - (inode->i_size & (PAGE_CACHE_SIZE - 1)) -\n\t\t   offset;\n\t}\n\n\tif (offset & (sb->s_blocksize - 1) ||\n\t    (offset + length) & (sb->s_blocksize - 1)) {\n\t\t/*\n\t\t * Attach jinode to inode for jbd2 if we do any zeroing of\n\t\t * partial block\n\t\t */\n\t\tret = ext4_inode_attach_jinode(inode);\n\t\tif (ret < 0)\n\t\t\tgoto out_mutex;\n \n \t}\n \n \tfirst_block_offset = round_up(offset, sb->s_blocksize);\n \tlast_block_offset = round_down((offset + length), sb->s_blocksize) - 1;\n \n\t/* Now release the pages and zero block aligned part of pages*/\n\tif (last_block_offset > first_block_offset)\n \t\ttruncate_pagecache_range(inode, first_block_offset,\n \t\t\t\t\t last_block_offset);\n \n\t/* Wait all existing dio workers, newcomers will block on i_mutex */\n\text4_inode_block_unlocked_dio(inode);\n\tinode_dio_wait(inode);\n \tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n \t\tcredits = ext4_writepage_trans_blocks(inode);\n \telse\n\t\tcredits = ext4_blocks_for_truncate(inode);\n\thandle = ext4_journal_start(inode, EXT4_HT_TRUNCATE, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\text4_std_error(sb, ret);\n\t\tgoto out_dio;\n\t}\n\n\tret = ext4_zero_partial_blocks(handle, inode, offset,\n\t\t\t\t       length);\n\tif (ret)\n\t\tgoto out_stop;\n\n\tfirst_block = (offset + sb->s_blocksize - 1) >>\n\t\tEXT4_BLOCK_SIZE_BITS(sb);\n\tstop_block = (offset + length) >> EXT4_BLOCK_SIZE_BITS(sb);\n\n\t/* If there are no blocks to remove, return now */\n\tif (first_block >= stop_block)\n\t\tgoto out_stop;\n\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\text4_discard_preallocations(inode);\n\n\tret = ext4_es_remove_extent(inode, first_block,\n\t\t\t\t    stop_block - first_block);\n\tif (ret) {\n\t\tup_write(&EXT4_I(inode)->i_data_sem);\n\t\tgoto out_stop;\n\t}\n\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\tret = ext4_ext_remove_space(inode, first_block,\n\t\t\t\t\t    stop_block - 1);\n\telse\n\t\tret = ext4_ind_remove_space(handle, inode, first_block,\n\t\t\t\t\t    stop_block);\n\n\tup_write(&EXT4_I(inode)->i_data_sem);\n \tif (IS_SYNC(inode))\n \t\text4_handle_sync(handle);\n \n\t/* Now release the pages again to reduce race window */\n\tif (last_block_offset > first_block_offset)\n\t\ttruncate_pagecache_range(inode, first_block_offset,\n\t\t\t\t\t last_block_offset);\n \tinode->i_mtime = inode->i_ctime = ext4_current_time(inode);\n \text4_mark_inode_dirty(handle, inode);\n out_stop:\n \text4_journal_stop(handle);\n out_dio:\n \text4_inode_resume_unlocked_dio(inode);\n out_mutex:\n \tmutex_unlock(&inode->i_mutex);\n\treturn ret;\n}\n", "target": 1, "idx": 180662}
{"func": "int ldb_dn_set_component(struct ldb_dn *dn, int num,\n\t\t\t const char *name, const struct ldb_val val)\n{\n\tchar *n;\n\tstruct ldb_val v;\n\n\tif ( ! ldb_dn_validate(dn)) {\n\t\treturn LDB_ERR_OTHER;\n\t}\n\n\tif (num >= dn->comp_num) {\n\t\treturn LDB_ERR_OTHER;\n\t}\n\n\tn = talloc_strdup(dn, name);\n\tif ( ! n) {\n\t\treturn LDB_ERR_OTHER;\n\t}\n\n\tv.length = val.length;\n\tv.data = (uint8_t *)talloc_memdup(dn, val.data, v.length+1);\n\tif ( ! v.data) {\n\t\ttalloc_free(n);\n\t\treturn LDB_ERR_OTHER;\n\t}\n\n\ttalloc_free(dn->components[num].name);\n\ttalloc_free(dn->components[num].value.data);\n\tdn->components[num].name = n;\n\tdn->components[num].value = v;\n\n\tif (dn->valid_case) {\n\t\tunsigned int i;\n\t\tfor (i = 0; i < dn->comp_num; i++) {\n\t\t\tLDB_FREE(dn->components[i].cf_name);\n\t\t\tLDB_FREE(dn->components[i].cf_value.data);\n\t\t}\n\t\tdn->valid_case = false;\n\t}\n\tLDB_FREE(dn->casefold);\n\tLDB_FREE(dn->linearized);\n\n\t/* Wipe the ext_linearized DN,\n\t * the GUID and SID are almost certainly no longer valid */\n\tLDB_FREE(dn->ext_linearized);\n\tLDB_FREE(dn->ext_components);\n\tdn->ext_comp_num = 0;\n\n\treturn LDB_SUCCESS;\n}\n", "target": 0, "idx": 2361}
{"func": "Document* LocalDOMWindow::InstallNewDocument(const String& mime_type,\n                                             const DocumentInit& init,\n                                             bool force_xhtml) {\n  DCHECK_EQ(init.GetFrame(), GetFrame());\n\n  ClearDocument();\n\n  document_ = CreateDocument(mime_type, init, force_xhtml);\n  event_queue_ = DOMWindowEventQueue::Create(document_.Get());\n  document_->Initialize();\n\n  if (!GetFrame())\n    return document_;\n\n  GetFrame()->GetScriptController().UpdateDocument();\n  document_->UpdateViewportDescription();\n\n  if (GetFrame()->GetPage() && GetFrame()->View()) {\n    GetFrame()->GetPage()->GetChromeClient().InstallSupplements(*GetFrame());\n\n    if (ScrollingCoordinator* scrolling_coordinator =\n            GetFrame()->GetPage()->GetScrollingCoordinator()) {\n      scrolling_coordinator->ScrollableAreaScrollbarLayerDidChange(\n          GetFrame()->View(), kHorizontalScrollbar);\n      scrolling_coordinator->ScrollableAreaScrollbarLayerDidChange(\n          GetFrame()->View(), kVerticalScrollbar);\n      scrolling_coordinator->ScrollableAreaScrollLayerDidChange(\n          GetFrame()->View());\n     }\n   }\n \n  GetFrame()->Selection().UpdateSecureKeyboardEntryIfActive();\n   if (GetFrame()->IsCrossOriginSubframe())\n     document_->RecordDeferredLoadReason(WouldLoadReason::kCreated);\n \n  return document_;\n}\n", "target": 1, "idx": 185732}
{"func": " status_t SampleTable::setTimeToSampleParams(\n         off64_t data_offset, size_t data_size) {\n    if (!mTimeToSample.empty() || data_size < 8) {\n         return ERROR_MALFORMED;\n     }\n \n uint8_t header[8];\n if (mDataSource->readAt(\n                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {\n return ERROR_IO;\n }\n\n if (U32_AT(header) != 0) {\n return ERROR_MALFORMED;\n }\n\n    mTimeToSampleCount = U32_AT(&header[4]);\n if ((uint64_t)mTimeToSampleCount >\n (uint64_t)UINT32_MAX / (2 * sizeof(uint32_t))) {\n        ALOGE(\"  Error: Time-to-sample table size too large.\");\n\n return ERROR_OUT_OF_RANGE;\n }\n\n if (!mDataSource->getVector(data_offset + 8, &mTimeToSample,\n                                mTimeToSampleCount * 2)) {\n        ALOGE(\"  Error: Incomplete data read for time-to-sample table.\");\n return ERROR_IO;\n }\n\n\n     for (size_t i = 0; i < mTimeToSample.size(); ++i) {\n         mTimeToSample.editItemAt(i) = ntohl(mTimeToSample[i]);\n     }\n     return OK;\n }\n", "target": 1, "idx": 187795}
{"func": "standard_row_validate(standard_display *dp, png_const_structp pp,\n int iImage, int iDisplay, png_uint_32 y)\n{\n int where;\n   png_byte std[STANDARD_ROWMAX];\n\n /* The row must be pre-initialized to the magic number here for the size\n    * tests to pass:\n    */\n   memset(std, 178, sizeof std);\n   standard_row(pp, std, dp->id, y);\n\n /* At the end both the 'row' and 'display' arrays should end up identical.\n\n     * In earlier passes 'row' will be partially filled in, with only the pixels\n     * that have been read so far, but 'display' will have those pixels\n     * replicated to fill the unread pixels while reading an interlaced image.\n#if PNG_LIBPNG_VER < 10506\n    * The side effect inside the libpng sequential reader is that the 'row'\n    * array retains the correct values for unwritten pixels within the row\n    * bytes, while the 'display' array gets bits off the end of the image (in\n    * the last byte) trashed.  Unfortunately in the progressive reader the\n    * row bytes are always trashed, so we always do a pixel_cmp here even though\n    * a memcmp of all cbRow bytes will succeed for the sequential reader.\n#endif\n     */\n    if (iImage >= 0 &&\n       (where = pixel_cmp(std, store_image_row(dp->ps, pp, iImage, y),\n            dp->bit_width)) != 0)\n {\n char msg[64];\n      sprintf(msg, \"PNG image row[%lu][%d] changed from %.2x to %.2x\",\n (unsigned long)y, where-1, std[where-1],\n         store_image_row(dp->ps, pp, iImage, y)[where-1]);\n\n       png_error(pp, msg);\n    }\n \n#if PNG_LIBPNG_VER < 10506\n   /* In this case use pixel_cmp because we need to compare a partial\n    * byte at the end of the row if the row is not an exact multiple\n    * of 8 bits wide.  (This is fixed in libpng-1.5.6 and pixel_cmp is\n    * changed to match!)\n    */\n#endif\n    if (iDisplay >= 0 &&\n       (where = pixel_cmp(std, store_image_row(dp->ps, pp, iDisplay, y),\n          dp->bit_width)) != 0)\n    {\n       char msg[64];\n      sprintf(msg, \"display  row[%lu][%d] changed from %.2x to %.2x\",\n          (unsigned long)y, where-1, std[where-1],\n          store_image_row(dp->ps, pp, iDisplay, y)[where-1]);\n       png_error(pp, msg);\n }\n}\n", "target": 1, "idx": 187723}
{"func": " cleanup_pathname(struct archive_write_disk *a)\n{\n\tchar *dest, *src;\n\tchar separator = '\\0';\n\n\tdest = src = a->name;\n\tif (*src == '\\0') {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"Invalid empty pathname\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n#if defined(__CYGWIN__)\n \tcleanup_pathname_win(a);\n #endif\n \t/* Skip leading '/'. */\n\tif (*src == '/')\n \t\tseparator = *src++;\n \n \t/* Scan the pathname one element at a time. */\n \tfor (;;) {\n\t\t/* src points to first char after '/' */\n\t\tif (src[0] == '\\0') {\n\t\t\tbreak;\n\t\t} else if (src[0] == '/') {\n\t\t\t/* Found '//', ignore second one. */\n\t\t\tsrc++;\n\t\t\tcontinue;\n\t\t} else if (src[0] == '.') {\n\t\t\tif (src[1] == '\\0') {\n\t\t\t\t/* Ignore trailing '.' */\n\t\t\t\tbreak;\n\t\t\t} else if (src[1] == '/') {\n\t\t\t\t/* Skip './'. */\n\t\t\t\tsrc += 2;\n\t\t\t\tcontinue;\n\t\t\t} else if (src[1] == '.') {\n\t\t\t\tif (src[2] == '/' || src[2] == '\\0') {\n\t\t\t\t\t/* Conditionally warn about '..' */\n\t\t\t\t\tif (a->flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {\n\t\t\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t\t\t\t    \"Path contains '..'\");\n\t\t\t\t\t\treturn (ARCHIVE_FAILED);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Note: Under no circumstances do we\n\t\t\t\t * remove '..' elements.  In\n\t\t\t\t * particular, restoring\n\t\t\t\t * '/foo/../bar/' should create the\n\t\t\t\t * 'foo' dir as a side-effect.\n\t\t\t\t */\n\t\t\t}\n\t\t}\n\n\t\t/* Copy current element, including leading '/'. */\n\t\tif (separator)\n\t\t\t*dest++ = '/';\n\t\twhile (*src != '\\0' && *src != '/') {\n\t\t\t*dest++ = *src++;\n\t\t}\n\n\t\tif (*src == '\\0')\n\t\t\tbreak;\n\n\t\t/* Skip '/' separator. */\n\t\tseparator = *src++;\n\t}\n\t/*\n\t * We've just copied zero or more path elements, not including the\n\t * final '/'.\n\t */\n\tif (dest == a->name) {\n\t\t/*\n\t\t * Nothing got copied.  The path must have been something\n\t\t * like '.' or '/' or './' or '/././././/./'.\n\t\t */\n\t\tif (separator)\n\t\t\t*dest++ = '/';\n\t\telse\n\t\t\t*dest++ = '.';\n\t}\n\t/* Terminate the result. */\n\t*dest = '\\0';\n\treturn (ARCHIVE_OK);\n}\n", "target": 1, "idx": 179853}
{"func": "int BN_hex2bn(BIGNUM **bn, const char *a)\n{\n    BIGNUM *ret = NULL;\n    BN_ULONG l = 0;\n    int neg = 0, h, m, i, j, k, c;\n    int num;\n\n    if ((a == NULL) || (*a == '\\0'))\n        return (0);\n\n    if (*a == '-') {\n        neg = 1;\n        a++;\n         a++;\n     }\n \n    for (i = 0; isxdigit((unsigned char)a[i]); i++) ;\n \n     num = i + neg;\n     if (bn == NULL)\n            return (0);\n    } else {\n        ret = *bn;\n        BN_zero(ret);\n    }\n", "target": 1, "idx": 178422}
{"func": "WORD32 ih264d_mark_err_slice_skip(dec_struct_t * ps_dec,\n                                WORD32 num_mb_skip,\n                                UWORD8 u1_is_idr_slice,\n                                UWORD16 u2_frame_num,\n pocstruct_t *ps_cur_poc,\n                                WORD32 prev_slice_err)\n{\n    WORD32 i2_cur_mb_addr;\n    UWORD32 u1_num_mbs, u1_num_mbsNby2;\n    UWORD32 u1_mb_idx = ps_dec->u1_mb_idx;\n    UWORD32 i2_mb_skip_run;\n\n    UWORD32 u1_num_mbs_next, u1_end_of_row;\n const UWORD32 i2_pic_wdin_mbs = ps_dec->u2_frm_wd_in_mbs;\n    UWORD32 u1_slice_end;\n    UWORD32 u1_tfr_n_mb;\n    UWORD32 u1_decode_nmb;\n dec_bit_stream_t * const ps_bitstrm = ps_dec->ps_bitstrm;\n dec_slice_params_t * ps_slice = ps_dec->ps_cur_slice;\n    UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;\n    UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;\n deblk_mb_t *ps_cur_deblk_mb;\n dec_mb_info_t *ps_cur_mb_info;\n parse_pmbarams_t *ps_parse_mb_data;\n    UWORD32 u1_inter_mb_type;\n    UWORD32 u1_deblk_mb_type;\n    UWORD16 u2_total_mbs_coded;\n    UWORD32 u1_mbaff = ps_slice->u1_mbaff_frame_flag;\n parse_part_params_t *ps_part_info;\n    WORD32 ret;\n\n\n if(ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC)\n {\n        ih264d_err_pic_dispbuf_mgr(ps_dec);\n return 0;\n }\n\n if(prev_slice_err == 1)\n {\n /* first slice - missing/header corruption */\n        ps_dec->ps_cur_slice->u2_frame_num = u2_frame_num;\n\n\n if(!ps_dec->u1_first_slice_in_stream)\n {\n            ih264d_end_of_pic(ps_dec, u1_is_idr_slice,\n                ps_dec->ps_cur_slice->u2_frame_num);\n            ps_dec->s_cur_pic_poc.u2_frame_num =\n                ps_dec->ps_cur_slice->u2_frame_num;\n }\n\n {\n            WORD32 i, j, poc = 0;\n\n            ps_dec->ps_cur_slice->u2_first_mb_in_slice = 0;\n\n            ps_dec->pf_mvpred = ih264d_mvpred_nonmbaff;\n            ps_dec->p_form_mb_part_info = ih264d_form_mb_part_info_bp;\n            ps_dec->p_motion_compensate = ih264d_motion_compensate_bp;\n\n if(ps_dec->ps_cur_pic != NULL)\n                poc = ps_dec->ps_cur_pic->i4_poc + 2;\n\n            j = 0;\n for(i = 0; i < MAX_NUM_PIC_PARAMS; i++)\n if(ps_dec->ps_pps[i].u1_is_valid == TRUE)\n                       j = i;\n {\n                ret = ih264d_start_of_pic(ps_dec, poc, ps_cur_poc,\n                        ps_dec->ps_cur_slice->u2_frame_num,\n &ps_dec->ps_pps[j]);\n\n if(ret != OK)\n {\n return ret;\n }\n }\n\n            ps_dec->ps_ref_pic_buf_lx[0][0]->u1_pic_buf_id = 0;\n\n            ps_dec->u4_output_present = 0;\n\n {\n                ih264d_get_next_display_field(ps_dec,\n                                              ps_dec->ps_out_buffer,\n &(ps_dec->s_disp_op));\n /* If error code is non-zero then there is no buffer available for display,\n                 hence avoid format conversion */\n\n if(0 != ps_dec->s_disp_op.u4_error_code)\n {\n                    ps_dec->u4_fmt_conv_cur_row = ps_dec->s_disp_frame_info.u4_y_ht;\n }\n else\n                    ps_dec->u4_output_present = 1;\n }\n\n if(ps_dec->u1_separate_parse == 1)\n {\n if(ps_dec->u4_dec_thread_created == 0)\n {\n                    ithread_create(ps_dec->pv_dec_thread_handle, NULL,\n (void *)ih264d_decode_picture_thread,\n (void *)ps_dec);\n\n                    ps_dec->u4_dec_thread_created = 1;\n }\n\n if((ps_dec->u4_num_cores == 3) &&\n ((ps_dec->u4_app_disable_deblk_frm == 0) || ps_dec->i1_recon_in_thread3_flag)\n && (ps_dec->u4_bs_deblk_thread_created == 0))\n {\n                    ps_dec->u4_start_recon_deblk = 0;\n                    ithread_create(ps_dec->pv_bs_deblk_thread_handle, NULL,\n (void *)ih264d_recon_deblk_thread,\n (void *)ps_dec);\n                    ps_dec->u4_bs_deblk_thread_created = 1;\n }\n }\n }\n }\n else\n {\n\n dec_slice_struct_t *ps_parse_cur_slice;\n        ps_parse_cur_slice = ps_dec->ps_dec_slice_buf + ps_dec->u2_cur_slice_num;\n\n if(ps_dec->u1_slice_header_done\n && ps_parse_cur_slice == ps_dec->ps_parse_cur_slice)\n {\n            u1_num_mbs = ps_dec->u4_num_mbs_cur_nmb;\n\n if(u1_num_mbs)\n {\n                ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs - 1;\n }\n else\n {\n if(ps_dec->u1_separate_parse)\n {\n                    ps_cur_mb_info = ps_dec->ps_nmb_info - 1;\n }\n else\n {\n                    ps_cur_mb_info = ps_dec->ps_nmb_info\n + ps_dec->u4_num_mbs_prev_nmb - 1;\n }\n }\n\n            ps_dec->u2_mby = ps_cur_mb_info->u2_mby;\n            ps_dec->u2_mbx = ps_cur_mb_info->u2_mbx;\n\n            ps_dec->u1_mb_ngbr_availablity =\n                    ps_cur_mb_info->u1_mb_ngbr_availablity;\n\n            ps_dec->pv_parse_tu_coeff_data = ps_dec->pv_prev_mb_parse_tu_coeff_data;\n            ps_dec->u2_cur_mb_addr--;\n            ps_dec->i4_submb_ofst -= SUB_BLK_SIZE;\n\n if(u1_num_mbs)\n {\n if (ps_dec->u1_pr_sl_type == P_SLICE\n || ps_dec->u1_pr_sl_type == B_SLICE)\n {\n                    ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx,    u1_num_mbs);\n                    ps_dec->ps_part = ps_dec->ps_parse_part_params;\n }\n\n                u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;\n                u1_end_of_row = (!u1_num_mbs_next)\n && (!(u1_mbaff && (u1_num_mbs & 0x01)));\n                u1_slice_end = 1;\n                u1_tfr_n_mb = 1;\n                ps_cur_mb_info->u1_end_of_slice = u1_slice_end;\n\n if(ps_dec->u1_separate_parse)\n {\n                    ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n                            u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\n                    ps_dec->ps_nmb_info += u1_num_mbs;\n }\n else\n {\n\n                     ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n                             u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\n                 }\n                 ps_dec->u1_mb_idx = 0;\n                 ps_dec->u4_num_mbs_cur_nmb = 0;\n             }\n\n if(ps_dec->u2_total_mbs_coded\n >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n {\n                ps_dec->u1_pic_decode_done = 1;\n return 0;\n }\n\n            ps_dec->u2_cur_slice_num++;\n             ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;\n            ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;\n            ps_dec->ps_parse_cur_slice++;\n\n }\n else\n {\n            ps_dec->ps_parse_cur_slice = ps_dec->ps_dec_slice_buf\n + ps_dec->u2_cur_slice_num;\n }\n }\n\n /******************************************************/\n /* Initializations to new slice                       */\n /******************************************************/\n {\n        WORD32 num_entries;\n        WORD32 size;\n        UWORD8 *pu1_buf;\n\n        num_entries = MIN(MAX_FRAMES, ps_dec->u4_num_ref_frames_at_init);\n        num_entries = 2 * ((2 * num_entries) + 1);\n\n        size = num_entries * sizeof(void *);\n        size += PAD_MAP_IDX_POC * sizeof(void *);\n\n        pu1_buf = (UWORD8 *)ps_dec->pv_map_ref_idx_to_poc_buf;\n        pu1_buf += size * ps_dec->u2_cur_slice_num;\n        ps_dec->ps_parse_cur_slice->ppv_map_ref_idx_to_poc = (volatile void **)pu1_buf;\n }\n\n    ps_dec->ps_cur_slice->u2_first_mb_in_slice = ps_dec->u2_total_mbs_coded << u1_mbaff;\n if(ps_dec->ps_cur_slice->u1_field_pic_flag)\n        ps_dec->u2_prv_frame_num = ps_dec->ps_cur_slice->u2_frame_num;\n\n    ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice = ps_dec->u2_total_mbs_coded << u1_mbaff;\n    ps_dec->ps_parse_cur_slice->u2_log2Y_crwd =    ps_dec->ps_cur_slice->u2_log2Y_crwd;\n\n\n if(ps_dec->u1_separate_parse)\n {\n        ps_dec->ps_parse_cur_slice->pv_tu_coeff_data_start = ps_dec->pv_parse_tu_coeff_data;\n }\n else\n {\n        ps_dec->pv_proc_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;\n }\n\n /******************************************************/\n /* Initializations specific to P slice                */\n /******************************************************/\n    u1_inter_mb_type = P_MB;\n    u1_deblk_mb_type = D_INTER_MB;\n\n    ps_dec->ps_cur_slice->u1_slice_type = P_SLICE;\n    ps_dec->ps_parse_cur_slice->slice_type = P_SLICE;\n    ps_dec->pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb;\n    ps_dec->ps_part = ps_dec->ps_parse_part_params;\n\n /******************************************************/\n /* Parsing / decoding the slice                       */\n /******************************************************/\n    ps_dec->u1_slice_header_done = 2;\n    ps_dec->u1_qp = ps_slice->u1_slice_qp;\n    ih264d_update_qp(ps_dec, 0);\n    u1_mb_idx = ps_dec->u1_mb_idx;\n    ps_parse_mb_data = ps_dec->ps_parse_mb_data;\n    u1_num_mbs = u1_mb_idx;\n\n    u1_slice_end = 0;\n    u1_tfr_n_mb = 0;\n    u1_decode_nmb = 0;\n    u1_num_mbsNby2 = 0;\n    i2_cur_mb_addr = ps_dec->u2_total_mbs_coded;\n    i2_mb_skip_run = num_mb_skip;\n\n while(!u1_slice_end)\n {\n        UWORD8 u1_mb_type;\n\n if(i2_cur_mb_addr > ps_dec->ps_cur_sps->u2_max_mb_addr)\n break;\n\n        ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs;\n        ps_dec->u4_num_mbs_cur_nmb = u1_num_mbs;\n\n        ps_cur_mb_info->u1_Mux = 0;\n        ps_dec->u4_num_pmbair = (u1_num_mbs >> u1_mbaff);\n        ps_cur_deblk_mb = ps_dec->ps_deblk_mbn + u1_num_mbs;\n\n        ps_cur_mb_info->u1_end_of_slice = 0;\n\n /* Storing Default partition info */\n        ps_parse_mb_data->u1_num_part = 1;\n        ps_parse_mb_data->u1_isI_mb = 0;\n\n /**************************************************************/\n /* Get the required information for decoding of MB            */\n /**************************************************************/\n /* mb_x, mb_y, neighbor availablity, */\n if (u1_mbaff)\n            ih264d_get_mb_info_cavlc_mbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);\n else\n            ih264d_get_mb_info_cavlc_nonmbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);\n\n /* Set the deblocking parameters for this MB */\n if(ps_dec->u4_app_disable_deblk_frm == 0)\n {\n            ih264d_set_deblocking_parameters(ps_cur_deblk_mb, ps_slice,\n                                             ps_dec->u1_mb_ngbr_availablity,\n                                             ps_dec->u1_cur_mb_fld_dec_flag);\n }\n\n /* Set appropriate flags in ps_cur_mb_info and ps_dec */\n        ps_dec->i1_prev_mb_qp_delta = 0;\n        ps_dec->u1_sub_mb_num = 0;\n        ps_cur_mb_info->u1_mb_type = MB_SKIP;\n        ps_cur_mb_info->u1_mb_mc_mode = PRED_16x16;\n        ps_cur_mb_info->u1_cbp = 0;\n\n /* Storing Skip partition info */\n        ps_part_info = ps_dec->ps_part;\n        ps_part_info->u1_is_direct = PART_DIRECT_16x16;\n        ps_part_info->u1_sub_mb_num = 0;\n        ps_dec->ps_part++;\n\n /* Update Nnzs */\n        ih264d_update_nnz_for_skipmb(ps_dec, ps_cur_mb_info, CAVLC);\n\n        ps_cur_mb_info->ps_curmb->u1_mb_type = u1_inter_mb_type;\n        ps_cur_deblk_mb->u1_mb_type |= u1_deblk_mb_type;\n\n        i2_mb_skip_run--;\n\n        ps_cur_deblk_mb->u1_mb_qp = ps_dec->u1_qp;\n\n if (u1_mbaff)\n {\n            ih264d_update_mbaff_left_nnz(ps_dec, ps_cur_mb_info);\n }\n\n /**************************************************************/\n /* Get next Macroblock address                                */\n /**************************************************************/\n\n         i2_cur_mb_addr++;\n \n         u1_num_mbs++;\n        ps_dec->u2_total_mbs_coded++;\n         u1_num_mbsNby2++;\n         ps_parse_mb_data++;\n \n /****************************************************************/\n /* Check for End Of Row and other flags that determine when to  */\n /* do DMA setup for N/2-Mb, Decode for N-Mb, and Transfer for   */\n /* N-Mb                                                         */\n /****************************************************************/\n        u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;\n        u1_end_of_row = (!u1_num_mbs_next) && (!(u1_mbaff && (u1_num_mbs & 0x01)));\n        u1_slice_end = !i2_mb_skip_run;\n        u1_tfr_n_mb = (u1_num_mbs == ps_dec->u1_recon_mb_grp) || u1_end_of_row\n || u1_slice_end;\n        u1_decode_nmb = u1_tfr_n_mb || u1_slice_end;\n        ps_cur_mb_info->u1_end_of_slice = u1_slice_end;\n\n if(u1_decode_nmb)\n {\n            ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx, u1_num_mbs);\n            u1_num_mbsNby2 = 0;\n\n            ps_parse_mb_data = ps_dec->ps_parse_mb_data;\n            ps_dec->ps_part = ps_dec->ps_parse_part_params;\n\n if(ps_dec->u1_separate_parse)\n {\n                ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,\n                                     u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);\n                ps_dec->ps_nmb_info +=  u1_num_mbs;\n }\n else\n {\n\n                 ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs, u1_num_mbs_next,\n                                             u1_tfr_n_mb, u1_end_of_row);\n             }\n             if(u1_tfr_n_mb)\n                 u1_num_mbs = 0;\n             u1_mb_idx = u1_num_mbs;\n            ps_dec->u1_mb_idx = u1_num_mbs;\n }\n }\n\n    ps_dec->u4_num_mbs_cur_nmb = 0;\n    ps_dec->ps_cur_slice->u4_mbs_in_slice = i2_cur_mb_addr\n - ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice;\n\n    H264_DEC_DEBUG_PRINT(\"Mbs in slice: %d\\n\", ps_dec->ps_cur_slice->u4_mbs_in_slice);\n\n    ps_dec->u2_cur_slice_num++;\n\n /* incremented here only if first slice is inserted */\n if(ps_dec->u4_first_slice_in_pic != 0)\n        ps_dec->ps_parse_cur_slice++;\n\n    ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;\n    ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;\n\n if(ps_dec->u2_total_mbs_coded\n >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n {\n        ps_dec->u1_pic_decode_done = 1;\n }\n\n return 0;\n\n}\n", "target": 1, "idx": 187977}
{"func": " void TestingPlatformSupport::cryptographicallyRandomValues(unsigned char* buffer, size_t length)\n {\n }\n", "target": 1, "idx": 186207}
{"func": "status_t OMXNodeInstance::useBuffer(\n        OMX_U32 portIndex, const sp<IMemory> &params,\n        OMX::buffer_id *buffer, OMX_U32 allottedSize) {\n if (params == NULL || buffer == NULL) {\n        ALOGE(\"b/25884056\");\n return BAD_VALUE;\n\n     }\n \n     Mutex::Autolock autoLock(mLock);\n    if (allottedSize > params->size()) {\n         return BAD_VALUE;\n     }\n \n    BufferMeta *buffer_meta = new BufferMeta(params, portIndex);\n \n     OMX_BUFFERHEADERTYPE *header;\n \n     OMX_ERRORTYPE err = OMX_UseBuffer(\n             mHandle, &header, portIndex, buffer_meta,\n            allottedSize, static_cast<OMX_U8 *>(params->pointer()));\n \n     if (err != OMX_ErrorNone) {\n         CLOG_ERROR(useBuffer, err, SIMPLE_BUFFER(\n                portIndex, (size_t)allottedSize, params->pointer()));\n \n         delete buffer_meta;\n         buffer_meta = NULL;\n\n *buffer = 0;\n\n return StatusFromOMXError(err);\n }\n\n    CHECK_EQ(header->pAppPrivate, buffer_meta);\n\n *buffer = makeBufferID(header);\n\n    addActiveBuffer(portIndex, *buffer);\n\n    sp<GraphicBufferSource> bufferSource(getGraphicBufferSource());\n if (bufferSource != NULL && portIndex == kPortIndexInput) {\n        bufferSource->addCodecBuffer(header);\n }\n\n    CLOG_BUFFER(useBuffer, NEW_BUFFER_FMT(\n *buffer, portIndex, \"%u(%zu)@%p\", allottedSize, params->size(), params->pointer()));\n return OK;\n}\n", "target": 1, "idx": 188165}
{"func": "xmlParseCDSect(xmlParserCtxtPtr ctxt) {\n    xmlChar *buf = NULL;\n    int len = 0;\n    int size = XML_PARSER_BUFFER_SIZE;\n    int r, rl;\n    int\ts, sl;\n    int cur, l;\n    int count = 0;\n\n    /* Check 2.6.0 was NXT(0) not RAW */\n    if (CMP9(CUR_PTR, '<', '!', '[', 'C', 'D', 'A', 'T', 'A', '[')) {\n\tSKIP(9);\n    } else\n        return;\n\n    ctxt->instate = XML_PARSER_CDATA_SECTION;\n    r = CUR_CHAR(rl);\n    if (!IS_CHAR(r)) {\n\txmlFatalErr(ctxt, XML_ERR_CDATA_NOT_FINISHED, NULL);\n\tctxt->instate = XML_PARSER_CONTENT;\n        return;\n    }\n    NEXTL(rl);\n    s = CUR_CHAR(sl);\n    if (!IS_CHAR(s)) {\n\txmlFatalErr(ctxt, XML_ERR_CDATA_NOT_FINISHED, NULL);\n\tctxt->instate = XML_PARSER_CONTENT;\n        return;\n    }\n    NEXTL(sl);\n    cur = CUR_CHAR(l);\n    buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));\n    if (buf == NULL) {\n\txmlErrMemory(ctxt, NULL);\n\treturn;\n    }\n    while (IS_CHAR(cur) &&\n           ((r != ']') || (s != ']') || (cur != '>'))) {\n\tif (len + 5 >= size) {\n\t    xmlChar *tmp;\n\n\t    size *= 2;\n\t    tmp = (xmlChar *) xmlRealloc(buf, size * sizeof(xmlChar));\n\t    if (tmp == NULL) {\n\t        xmlFree(buf);\n\t\txmlErrMemory(ctxt, NULL);\n\t\treturn;\n\t    }\n\t    buf = tmp;\n\t}\n\tCOPY_BUF(rl,buf,len,r);\n\tr = s;\n\trl = sl;\n\ts = cur;\n\tsl = l;\n \tcount++;\n \tif (count > 50) {\n \t    GROW;\n \t    count = 0;\n \t}\n \tNEXTL(l);\n\tcur = CUR_CHAR(l);\n    }\n    buf[len] = 0;\n    ctxt->instate = XML_PARSER_CONTENT;\n    if (cur != '>') {\n\txmlFatalErrMsgStr(ctxt, XML_ERR_CDATA_NOT_FINISHED,\n\t                     \"CData section not finished\\n%.50s\\n\", buf);\n\txmlFree(buf);\n        return;\n    }\n    NEXTL(l);\n\n    /*\n     * OK the buffer is to be consumed as cdata.\n     */\n    if ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {\n\tif (ctxt->sax->cdataBlock != NULL)\n\t    ctxt->sax->cdataBlock(ctxt->userData, buf, len);\n\telse if (ctxt->sax->characters != NULL)\n\t    ctxt->sax->characters(ctxt->userData, buf, len);\n    }\n    xmlFree(buf);\n}\n", "target": 1, "idx": 184965}
{"func": "void HWNDMessageHandler::Init(HWND parent, const gfx::Rect& bounds) {\n  TRACE_EVENT0(\"views\", \"HWNDMessageHandler::Init\");\n  GetMonitorAndRects(bounds.ToRECT(), &last_monitor_, &last_monitor_rect_,\n                     &last_work_area_);\n \n   WindowImpl::Init(parent, bounds);\n }\n", "target": 1, "idx": 185493}
{"func": " e1000e_ring_empty(E1000ECore *core, const E1000E_RingInfo *r)\n {\n    return core->mac[r->dh] == core->mac[r->dt];\n }\n", "target": 1, "idx": 177971}
{"func": " nm_ip4_config_commit (const NMIP4Config *config, int ifindex, guint32 default_route_metric)\n {\n \tNMIP4ConfigPrivate *priv = NM_IP4_CONFIG_GET_PRIVATE (config);\n\tguint32 mtu = nm_ip4_config_get_mtu (config);\n \tint i;\n \n \tg_return_val_if_fail (ifindex > 0, FALSE);\n\tg_return_val_if_fail (ifindex > 0, FALSE);\n\tg_return_val_if_fail (config != NULL, FALSE);\n\n\t/* Addresses */\n\tnm_platform_ip4_address_sync (ifindex, priv->addresses, default_route_metric);\n\n\t/* Routes */\n\t{\n\t\tint count = nm_ip4_config_get_num_routes (config);\n\t\tGArray *routes = g_array_sized_new (FALSE, FALSE, sizeof (NMPlatformIP4Route), count);\n\t\tconst NMPlatformIP4Route *route;\n\t\tgboolean success;\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\troute = nm_ip4_config_get_route (config, i);\n\n\t\t\t/* Don't add the route if it's more specific than one of the subnets\n\t\t\t * the device already has an IP address on.\n\t\t\t */\n\t\t\tif (   route->gateway == 0\n\t\t\t    && nm_ip4_config_destination_is_direct (config, route->network, route->plen))\n\t\t\t\tcontinue;\n\n\t\t\tg_array_append_vals (routes, route, 1);\n\t\t}\n\n\t\tsuccess = nm_route_manager_ip4_route_sync (nm_route_manager_get (), ifindex, routes);\n\t\tg_array_unref (routes);\n \t\t\treturn FALSE;\n \t}\n \n\t/* MTU */\n\tif (mtu && mtu != nm_platform_link_get_mtu (ifindex))\n\t\tnm_platform_link_set_mtu (ifindex, mtu);\n \treturn TRUE;\n }\n", "target": 1, "idx": 177987}
{"func": "void RenderWidgetHostViewAura::ExtendSelectionAndDelete(\n    size_t before, size_t after) {\n  RenderFrameHostImpl* rfh = GetFocusedFrame();\n  if (rfh)\n    rfh->ExtendSelectionAndDelete(before, after);\n}\n", "target": 0, "idx": 144900}
{"func": "static int sctp_wait_for_sndbuf(struct sctp_association *asoc, long *timeo_p,\n\t\t\t\tsize_t msg_len)\n{\n\tstruct sock *sk = asoc->base.sk;\n\tint err = 0;\n\tlong current_timeo = *timeo_p;\n\tDEFINE_WAIT(wait);\n\n\tpr_debug(\"%s: asoc:%p, timeo:%ld, msg_len:%zu\\n\", __func__, asoc,\n\t\t *timeo_p, msg_len);\n\n\t/* Increment the association's refcnt.  */\n\tsctp_association_hold(asoc);\n\n\t/* Wait on the association specific sndbuf space. */\n\tfor (;;) {\n\t\tprepare_to_wait_exclusive(&asoc->wait, &wait,\n\t\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (!*timeo_p)\n\t\t\tgoto do_nonblock;\n\t\tif (sk->sk_err || asoc->state >= SCTP_STATE_SHUTDOWN_PENDING ||\n\t\t    asoc->base.dead)\n\t\t\tgoto do_error;\n\t\tif (signal_pending(current))\n\t\t\tgoto do_interrupted;\n\t\tif (msg_len <= sctp_wspace(asoc))\n\t\t\tbreak;\n\n\t\t/* Let another process have a go.  Since we are going\n\t\t * to sleep anyway.\n \t\t */\n \t\trelease_sock(sk);\n \t\tcurrent_timeo = schedule_timeout(current_timeo);\n\t\tBUG_ON(sk != asoc->base.sk);\n \t\tlock_sock(sk);\n \n \t\t*timeo_p = current_timeo;\n\t}\n\nout:\n\tfinish_wait(&asoc->wait, &wait);\n\n\t/* Release the association's refcnt.  */\n\tsctp_association_put(asoc);\n\n\treturn err;\n\ndo_error:\n\terr = -EPIPE;\n\tgoto out;\n\ndo_interrupted:\n\terr = sock_intr_errno(*timeo_p);\n\tgoto out;\n\ndo_nonblock:\n\terr = -EAGAIN;\n\tgoto out;\n}\n", "target": 1, "idx": 181540}
{"func": "static int adjust_insn_aux_data(struct bpf_verifier_env *env, u32 prog_len,\n\t\t\t\tu32 off, u32 cnt)\n{\n\tstruct bpf_insn_aux_data *new_data, *old_data = env->insn_aux_data;\n\n\tif (cnt == 1)\n\t\treturn 0;\n\tnew_data = vzalloc(sizeof(struct bpf_insn_aux_data) * prog_len);\n\tif (!new_data)\n\t\treturn -ENOMEM;\n\tmemcpy(new_data, old_data, sizeof(struct bpf_insn_aux_data) * off);\n\tmemcpy(new_data + off + cnt - 1, old_data + off,\n\t       sizeof(struct bpf_insn_aux_data) * (prog_len - off - cnt + 1));\n\tenv->insn_aux_data = new_data;\n\tvfree(old_data);\n\treturn 0;\n}\n", "target": 0, "idx": 65025}
{"func": "static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,\n\t\t\t\t   size_t count, loff_t *offset)\n{\n\tstruct snd_timer_user *tu;\n\tlong result = 0, unit;\n\tint qhead;\n\tint err = 0;\n \n \ttu = file->private_data;\n \tunit = tu->tread ? sizeof(struct snd_timer_tread) : sizeof(struct snd_timer_read);\n \tspin_lock_irq(&tu->qlock);\n \twhile ((long)count - result >= unit) {\n \t\twhile (!tu->qused) {\n\t\t\twait_queue_t wait;\n\n\t\t\tif ((file->f_flags & O_NONBLOCK) != 0 || result > 0) {\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tgoto _error;\n\t\t\t}\n\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tinit_waitqueue_entry(&wait, current);\n \t\t\tadd_wait_queue(&tu->qchange_sleep, &wait);\n \n \t\t\tspin_unlock_irq(&tu->qlock);\n \t\t\tschedule();\n \t\t\tspin_lock_irq(&tu->qlock);\n \n \t\t\tremove_wait_queue(&tu->qchange_sleep, &wait);\n\n\t\t\tif (tu->disconnected) {\n\t\t\t\terr = -ENODEV;\n\t\t\t\tgoto _error;\n\t\t\t}\n\t\t\tif (signal_pending(current)) {\n\t\t\t\terr = -ERESTARTSYS;\n\t\t\t\tgoto _error;\n\t\t\t}\n\t\t}\n\n\t\tqhead = tu->qhead++;\n\t\ttu->qhead %= tu->queue_size;\n \t\ttu->qused--;\n \t\tspin_unlock_irq(&tu->qlock);\n \n\t\tmutex_lock(&tu->ioctl_lock);\n \t\tif (tu->tread) {\n \t\t\tif (copy_to_user(buffer, &tu->tqueue[qhead],\n \t\t\t\t\t sizeof(struct snd_timer_tread)))\n\t\t\t\terr = -EFAULT;\n\t\t} else {\n\t\t\tif (copy_to_user(buffer, &tu->queue[qhead],\n \t\t\t\t\t sizeof(struct snd_timer_read)))\n \t\t\t\terr = -EFAULT;\n \t\t}\n\t\tmutex_unlock(&tu->ioctl_lock);\n \n \t\tspin_lock_irq(&tu->qlock);\n \t\tif (err < 0)\n\t\t\tgoto _error;\n\t\tresult += unit;\n\t\tbuffer += unit;\n \t}\n  _error:\n \tspin_unlock_irq(&tu->qlock);\n \treturn result > 0 ? result : err;\n }\n", "target": 1, "idx": 183180}
{"func": "context_length_arg (char const *str, int *out)\n {\n  uintmax_t value;\n  if (! (xstrtoumax (str, 0, 10, &value, \"\") == LONGINT_OK\n         && 0 <= (*out = value)\n         && *out == value))\n     {\n       error (EXIT_TROUBLE, 0, \"%s: %s\", str,\n              _(\"invalid context length argument\"));\n     }\n   page size, unless a read yields a partial page.  */\n\nstatic char *buffer;\t\t/* Base of buffer. */\nstatic size_t bufalloc;\t\t/* Allocated buffer size, counting slop. */\n#define INITIAL_BUFSIZE 32768\t/* Initial buffer size, not counting slop. */\nstatic int bufdesc;\t\t/* File descriptor. */\nstatic char *bufbeg;\t\t/* Beginning of user-visible stuff. */\nstatic char *buflim;\t\t/* Limit of user-visible stuff. */\nstatic size_t pagesize;\t\t/* alignment of memory pages */\nstatic off_t bufoffset;\t\t/* Read offset; defined on regular files.  */\nstatic off_t after_last_match;\t/* Pointer after last matching line that\n                                   would have been output if we were\n                                   outputting characters. */\n\n/* Return VAL aligned to the next multiple of ALIGNMENT.  VAL can be\n   an integer or a pointer.  Both args must be free of side effects.  */\n#define ALIGN_TO(val, alignment) \\\n  ((size_t) (val) % (alignment) == 0 \\\n   ? (val) \\\n   : (val) + ((alignment) - (size_t) (val) % (alignment)))\n\n/* Reset the buffer for a new file, returning zero if we should skip it.\n   Initialize on the first time through. */\nstatic int\nreset (int fd, char const *file, struct stats *stats)\n{\n  if (! pagesize)\n    {\n      pagesize = getpagesize ();\n      if (pagesize == 0 || 2 * pagesize + 1 <= pagesize)\n        abort ();\n      bufalloc = ALIGN_TO (INITIAL_BUFSIZE, pagesize) + pagesize + 1;\n      buffer = xmalloc (bufalloc);\n    }\n\n  bufbeg = buflim = ALIGN_TO (buffer + 1, pagesize);\n  bufbeg[-1] = eolbyte;\n  bufdesc = fd;\n\n  if (S_ISREG (stats->stat.st_mode))\n    {\n      if (file)\n        bufoffset = 0;\n      else\n        {\n          bufoffset = lseek (fd, 0, SEEK_CUR);\n          if (bufoffset < 0)\n            {\n              suppressible_error (_(\"lseek failed\"), errno);\n              return 0;\n            }\n        }\n    }\n  return 1;\n}\n\n/* Read new stuff into the buffer, saving the specified\n   amount of old stuff.  When we're done, 'bufbeg' points\n   to the beginning of the buffer contents, and 'buflim'\n   points just after the end.  Return zero if there's an error.  */\nstatic int\nfillbuf (size_t save, struct stats const *stats)\n{\n  size_t fillsize = 0;\n  int cc = 1;\n  char *readbuf;\n  size_t readsize;\n\n  /* Offset from start of buffer to start of old stuff\n     that we want to save.  */\n  size_t saved_offset = buflim - save - buffer;\n\n  if (pagesize <= buffer + bufalloc - buflim)\n    {\n      readbuf = buflim;\n      bufbeg = buflim - save;\n    }\n  else\n    {\n      size_t minsize = save + pagesize;\n      size_t newsize;\n      size_t newalloc;\n      char *newbuf;\n\n      /* Grow newsize until it is at least as great as minsize.  */\n      for (newsize = bufalloc - pagesize - 1; newsize < minsize; newsize *= 2)\n        if (newsize * 2 < newsize || newsize * 2 + pagesize + 1 < newsize * 2)\n          xalloc_die ();\n\n      /* Try not to allocate more memory than the file size indicates,\n         as that might cause unnecessary memory exhaustion if the file\n         is large.  However, do not use the original file size as a\n         heuristic if we've already read past the file end, as most\n         likely the file is growing.  */\n      if (S_ISREG (stats->stat.st_mode))\n        {\n          off_t to_be_read = stats->stat.st_size - bufoffset;\n          off_t maxsize_off = save + to_be_read;\n          if (0 <= to_be_read && to_be_read <= maxsize_off\n              && maxsize_off == (size_t) maxsize_off\n              && minsize <= (size_t) maxsize_off\n              && (size_t) maxsize_off < newsize)\n            newsize = maxsize_off;\n        }\n\n      /* Add enough room so that the buffer is aligned and has room\n         for byte sentinels fore and aft.  */\n      newalloc = newsize + pagesize + 1;\n\n      newbuf = bufalloc < newalloc ? xmalloc (bufalloc = newalloc) : buffer;\n      readbuf = ALIGN_TO (newbuf + 1 + save, pagesize);\n      bufbeg = readbuf - save;\n      memmove (bufbeg, buffer + saved_offset, save);\n      bufbeg[-1] = eolbyte;\n      if (newbuf != buffer)\n        {\n          free (buffer);\n          buffer = newbuf;\n        }\n    }\n\n  readsize = buffer + bufalloc - readbuf;\n  readsize -= readsize % pagesize;\n\n  if (! fillsize)\n    {\n      ssize_t bytesread;\n      while ((bytesread = read (bufdesc, readbuf, readsize)) < 0\n             && errno == EINTR)\n        continue;\n      if (bytesread < 0)\n        cc = 0;\n      else\n        fillsize = bytesread;\n    }\n\n  bufoffset += fillsize;\n#if defined HAVE_DOS_FILE_CONTENTS\n  if (fillsize)\n    fillsize = undossify_input (readbuf, fillsize);\n#endif\n  buflim = readbuf + fillsize;\n  return cc;\n}\n\n/* Flags controlling the style of output. */\nstatic enum\n{\n  BINARY_BINARY_FILES,\n  TEXT_BINARY_FILES,\n  WITHOUT_MATCH_BINARY_FILES\n} binary_files;\t\t/* How to handle binary files.  */\n\nstatic int filename_mask;\t/* If zero, output nulls after filenames.  */\nstatic int out_quiet;\t\t/* Suppress all normal output. */\nstatic int out_invert;\t\t/* Print nonmatching stuff. */\nstatic int out_file;\t\t/* Print filenames. */\nstatic int out_line;\t\t/* Print line numbers. */\nstatic int out_byte;\t\t/* Print byte offsets. */\nstatic int out_before;\t\t/* Lines of leading context. */\nstatic int out_after;\t\t/* Lines of trailing context. */\n static int out_file;\t\t/* Print filenames. */\n static int out_line;\t\t/* Print line numbers. */\n static int out_byte;\t\t/* Print byte offsets. */\nstatic int out_before;\t\t/* Lines of leading context. */\nstatic int out_after;\t\t/* Lines of trailing context. */\n static int count_matches;\t/* Count matching lines.  */\n static int list_files;\t\t/* List matching files.  */\n static int no_filenames;\t/* Suppress file names.  */\nstatic off_t max_count;\t\t/* Stop after outputting this many\n                                    lines from an input file.  */\n static int line_buffered;       /* If nonzero, use line buffering, i.e.\n                                    fflush everyline out.  */\nstatic char const *lastnl;\t/* Pointer after last newline counted. */\nstatic char const *lastout;\t/* Pointer after last character output;\n                                   NULL if no character has been output\n                                   or if it's conceptually before bufbeg. */\nstatic uintmax_t totalnl;\t/* Total newline count before lastnl. */\nstatic off_t outleft;\t\t/* Maximum number of lines to be output.  */\nstatic int pending;\t\t/* Pending lines of output.\n                                    NULL if no character has been output\n                                    or if it's conceptually before bufbeg. */\n static uintmax_t totalnl;\t/* Total newline count before lastnl. */\nstatic off_t outleft;\t\t/* Maximum number of lines to be output.  */\nstatic int pending;\t\t/* Pending lines of output.\n                                    Always kept 0 if out_quiet is true.  */\n static int done_on_match;\t/* Stop scanning file on first match.  */\n static int exit_on_match;\t/* Exit on first match.  */\n/* Add two numbers that count input bytes or lines, and report an\n   error if the addition overflows.  */\nstatic uintmax_t\nadd_count (uintmax_t a, uintmax_t b)\n{\n  uintmax_t sum = a + b;\n  if (sum < a)\n    error (EXIT_TROUBLE, 0, _(\"input is too large to count\"));\n  return sum;\n}\n\nstatic void\nnlscan (char const *lim)\n{\n  size_t newlines = 0;\n  char const *beg;\n  for (beg = lastnl; beg < lim; beg++)\n    {\n      beg = memchr (beg, eolbyte, lim - beg);\n      if (!beg)\n        break;\n      newlines++;\n    }\n  totalnl = add_count (totalnl, newlines);\n  lastnl = lim;\n}\n\n/* Print the current filename.  */\nstatic void\nprint_filename (void)\n{\n  pr_sgr_start_if (filename_color);\n  fputs (filename, stdout);\n  pr_sgr_end_if (filename_color);\n}\n\n/* Print a character separator.  */\nstatic void\nprint_sep (char sep)\n{\n  pr_sgr_start_if (sep_color);\n  fputc (sep, stdout);\n  pr_sgr_end_if (sep_color);\n}\n\n/* Print a line number or a byte offset.  */\nstatic void\nprint_offset (uintmax_t pos, int min_width, const char *color)\n{\n  /* Do not rely on printf to print pos, since uintmax_t may be longer\n     than long, and long long is not portable.  */\n\n  char buf[sizeof pos * CHAR_BIT];\n  char *p = buf + sizeof buf;\n\n  do\n    {\n      *--p = '0' + pos % 10;\n      --min_width;\n    }\n  while ((pos /= 10) != 0);\n\n  /* Do this to maximize the probability of alignment across lines.  */\n  if (align_tabs)\n    while (--min_width >= 0)\n      *--p = ' ';\n\n  pr_sgr_start_if (color);\n  fwrite (p, 1, buf + sizeof buf - p, stdout);\n  pr_sgr_end_if (color);\n}\n\n/* Print a whole line head (filename, line, byte).  */\nstatic void\nprint_line_head (char const *beg, char const *lim, int sep)\n{\n  int pending_sep = 0;\n\n  if (out_file)\n    {\n      print_filename ();\n      if (filename_mask)\n        pending_sep = 1;\n      else\n        fputc (0, stdout);\n    }\n\n  if (out_line)\n    {\n      if (lastnl < lim)\n        {\n          nlscan (beg);\n          totalnl = add_count (totalnl, 1);\n          lastnl = lim;\n        }\n      if (pending_sep)\n        print_sep (sep);\n      print_offset (totalnl, 4, line_num_color);\n      pending_sep = 1;\n    }\n\n  if (out_byte)\n    {\n      uintmax_t pos = add_count (totalcc, beg - bufbeg);\n#if defined HAVE_DOS_FILE_CONTENTS\n      pos = dossified_pos (pos);\n#endif\n      if (pending_sep)\n        print_sep (sep);\n      print_offset (pos, 6, byte_num_color);\n      pending_sep = 1;\n    }\n\n  if (pending_sep)\n    {\n      /* This assumes sep is one column wide.\n         Try doing this any other way with Unicode\n         (and its combining and wide characters)\n         filenames and you're wasting your efforts.  */\n      if (align_tabs)\n        fputs (\"\\t\\b\", stdout);\n\n      print_sep (sep);\n    }\n}\n\nstatic const char *\nprint_line_middle (const char *beg, const char *lim,\n                   const char *line_color, const char *match_color)\n{\n  size_t match_size;\n  size_t match_offset;\n  const char *cur = beg;\n  const char *mid = NULL;\n\n  while (cur < lim\n         && ((match_offset = execute (beg, lim - beg, &match_size,\n                                      beg + (cur - beg))) != (size_t) -1))\n    {\n      char const *b = beg + match_offset;\n\n      /* Avoid matching the empty line at the end of the buffer. */\n      if (b == lim)\n        break;\n\n      /* Avoid hanging on grep --color \"\" foo */\n      if (match_size == 0)\n        {\n          /* Make minimal progress; there may be further non-empty matches.  */\n          /* XXX - Could really advance by one whole multi-octet character.  */\n          match_size = 1;\n          if (!mid)\n            mid = cur;\n        }\n      else\n        {\n          /* This function is called on a matching line only,\n             but is it selected or rejected/context?  */\n          if (only_matching)\n            print_line_head (b, lim, (out_invert ? SEP_CHAR_REJECTED\n                                      : SEP_CHAR_SELECTED));\n          else\n            {\n              pr_sgr_start (line_color);\n              if (mid)\n                {\n                  cur = mid;\n                  mid = NULL;\n                }\n              fwrite (cur, sizeof (char), b - cur, stdout);\n            }\n\n          pr_sgr_start_if (match_color);\n          fwrite (b, sizeof (char), match_size, stdout);\n          pr_sgr_end_if (match_color);\n          if (only_matching)\n            fputs (\"\\n\", stdout);\n        }\n      cur = b + match_size;\n    }\n\n  if (only_matching)\n    cur = lim;\n  else if (mid)\n    cur = mid;\n\n  return cur;\n}\n\nstatic const char *\nprint_line_tail (const char *beg, const char *lim, const char *line_color)\n{\n  size_t eol_size;\n  size_t tail_size;\n\n  eol_size   = (lim > beg && lim[-1] == eolbyte);\n  eol_size  += (lim - eol_size > beg && lim[-(1 + eol_size)] == '\\r');\n  tail_size  =  lim - eol_size - beg;\n\n  if (tail_size > 0)\n    {\n      pr_sgr_start (line_color);\n      fwrite (beg, 1, tail_size, stdout);\n      beg += tail_size;\n      pr_sgr_end (line_color);\n    }\n\n  return beg;\n}\n\nstatic void\nprline (char const *beg, char const *lim, int sep)\n{\n  int matching;\n  const char *line_color;\n  const char *match_color;\n\n  if (!only_matching)\n    print_line_head (beg, lim, sep);\n\n  matching = (sep == SEP_CHAR_SELECTED) ^ !!out_invert;\n\n  if (color_option)\n    {\n      line_color = (((sep == SEP_CHAR_SELECTED)\n                     ^ (out_invert && (color_option < 0)))\n                    ? selected_line_color  : context_line_color);\n      match_color = (sep == SEP_CHAR_SELECTED\n                     ? selected_match_color : context_match_color);\n    }\n  else\n    line_color = match_color = NULL; /* Shouldn't be used.  */\n\n  if ((only_matching && matching)\n      || (color_option  && (*line_color || *match_color)))\n    {\n      /* We already know that non-matching lines have no match (to colorize).  */\n      if (matching && (only_matching || *match_color))\n        beg = print_line_middle (beg, lim, line_color, match_color);\n\n      /* FIXME: this test may be removable.  */\n      if (!only_matching && *line_color)\n        beg = print_line_tail (beg, lim, line_color);\n    }\n\n  if (!only_matching && lim > beg)\n    fwrite (beg, 1, lim - beg, stdout);\n\n  if (ferror (stdout))\n    {\n      write_error_seen = 1;\n      error (EXIT_TROUBLE, 0, _(\"write error\"));\n    }\n\n  lastout = lim;\n\n  if (line_buffered)\n    fflush (stdout);\n}\n\n/* Print pending lines of trailing context prior to LIM. Trailing context ends\n   at the next matching line when OUTLEFT is 0.  */\nstatic void\nprpending (char const *lim)\n{\n  if (!lastout)\n    lastout = bufbeg;\n  while (pending > 0 && lastout < lim)\n    {\n      char const *nl = memchr (lastout, eolbyte, lim - lastout);\n      size_t match_size;\n      --pending;\n      if (outleft\n          || ((execute (lastout, nl + 1 - lastout,\n                        &match_size, NULL) == (size_t) -1)\n              == !out_invert))\n        prline (lastout, nl + 1, SEP_CHAR_REJECTED);\n      else\n        pending = 0;\n    }\n}\n\n/* Print the lines between BEG and LIM.  Deal with context crap.\n   If NLINESP is non-null, store a count of lines between BEG and LIM.  */\nstatic void\nprtext (char const *beg, char const *lim, int *nlinesp)\n{\n /* Print the lines between BEG and LIM.  Deal with context crap.\n    If NLINESP is non-null, store a count of lines between BEG and LIM.  */\n static void\nprtext (char const *beg, char const *lim, int *nlinesp)\n {\n   static int used;\t/* avoid printing SEP_STR_GROUP before any output */\n   char const *bp, *p;\n   char eol = eolbyte;\n  int i, n;\n \n   if (!out_quiet && pending > 0)\n     prpending (beg);\n      /* Deal with leading context crap. */\n\n      bp = lastout ? lastout : bufbeg;\n      for (i = 0; i < out_before; ++i)\n        if (p > bp)\n          do\n            --p;\n          while (p[-1] != eol);\n\n      /* We print the SEP_STR_GROUP separator only if our output is\n         discontiguous from the last output in the file. */\n      if ((out_before || out_after) && used && p != lastout && group_separator)\n        {\n          pr_sgr_start_if (sep_color);\n          fputs (group_separator, stdout);\n          pr_sgr_end_if (sep_color);\n          fputc ('\\n', stdout);\n        }\n\n      while (p < beg)\n        {\n          char const *nl = memchr (p, eol, beg - p);\n          nl++;\n          prline (p, nl, SEP_CHAR_REJECTED);\n          p = nl;\n        }\n    }\n\n  if (nlinesp)\n    {\n      /* Caller wants a line count. */\n      for (n = 0; p < lim && n < outleft; n++)\n        {\n          char const *nl = memchr (p, eol, lim - p);\n          nl++;\n          if (!out_quiet)\n            prline (p, nl, SEP_CHAR_SELECTED);\n          p = nl;\n        }\n      *nlinesp = n;\n\n      /* relying on it that this function is never called when outleft = 0.  */\n      after_last_match = bufoffset - (buflim - p);\n    }\n  else if (!out_quiet)\n    prline (beg, lim, SEP_CHAR_SELECTED);\n\n  pending = out_quiet ? 0 : out_after;\n  used = 1;\n}\n\nstatic size_t\ndo_execute (char const *buf, size_t size, size_t *match_size, char const *start_ptr)\n{\n  size_t result;\n  const char *line_next;\n\n  /* With the current implementation, using --ignore-case with a multi-byte\n     character set is very inefficient when applied to a large buffer\n     containing many matches.  We can avoid much of the wasted effort\n     by matching line-by-line.\n\n     FIXME: this is just an ugly workaround, and it doesn't really\n     belong here.  Also, PCRE is always using this same per-line\n     matching algorithm.  Either we fix -i, or we should refactor\n     this code---for example, we could add another function pointer\n     to struct matcher to split the buffer passed to execute.  It would\n     perform the memchr if line-by-line matching is necessary, or just\n     return buf + size otherwise.  */\n  if (MB_CUR_MAX == 1 || !match_icase)\n    return execute (buf, size, match_size, start_ptr);\n\n  for (line_next = buf; line_next < buf + size; )\n    {\n      const char *line_buf = line_next;\n      const char *line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);\n      if (line_end == NULL)\n        line_next = line_end = buf + size;\n      else\n        line_next = line_end + 1;\n\n      if (start_ptr && start_ptr >= line_end)\n        continue;\n\n      result = execute (line_buf, line_next - line_buf, match_size, start_ptr);\n      if (result != (size_t) -1)\n        return (line_buf - buf) + result;\n    }\n\n  return (size_t) -1;\n}\n\n/* Scan the specified portion of the buffer, matching lines (or\n   between matching lines if OUT_INVERT is true).  Return a count of\n   lines printed. */\nstatic int\ngrepbuf (char const *beg, char const *lim)\n /* Scan the specified portion of the buffer, matching lines (or\n    between matching lines if OUT_INVERT is true).  Return a count of\n    lines printed. */\nstatic int\n grepbuf (char const *beg, char const *lim)\n {\n  int nlines, n;\n   char const *p;\n   size_t match_offset;\n   size_t match_size;\n    {\n      char const *b = p + match_offset;\n      char const *endp = b + match_size;\n      /* Avoid matching the empty line at the end of the buffer. */\n      if (b == lim)\n        break;\n      if (!out_invert)\n        {\n          prtext (b, endp, (int *) 0);\n          nlines++;\n         break;\n       if (!out_invert)\n         {\n          prtext (b, endp, (int *) 0);\n           nlines++;\n           outleft--;\n           if (!outleft || done_on_match)\n            }\n        }\n      else if (p < b)\n        {\n          prtext (p, b, &n);\n          nlines += n;\n          outleft -= n;\n          if (!outleft)\n            return nlines;\n        }\n      p = endp;\n    }\n  if (out_invert && p < lim)\n    {\n      prtext (p, lim, &n);\n      nlines += n;\n      outleft -= n;\n    }\n  return nlines;\n}\n\n/* Search a given file.  Normally, return a count of lines printed;\n   but if the file is a directory and we search it recursively, then\n   return -2 if there was a match, and -1 otherwise.  */\nstatic int\ngrep (int fd, char const *file, struct stats *stats)\n /* Search a given file.  Normally, return a count of lines printed;\n    but if the file is a directory and we search it recursively, then\n    return -2 if there was a match, and -1 otherwise.  */\nstatic int\n grep (int fd, char const *file, struct stats *stats)\n {\n  int nlines, i;\n   int not_text;\n   size_t residue, save;\n   char oldc;\n    return 0;\n\n  if (file && directories == RECURSE_DIRECTORIES\n      && S_ISDIR (stats->stat.st_mode))\n    {\n      /* Close fd now, so that we don't open a lot of file descriptors\n         when we recurse deeply.  */\n      if (close (fd) != 0)\n        suppressible_error (file, errno);\n      return grepdir (file, stats) - 2;\n    }\n\n  totalcc = 0;\n  lastout = 0;\n  totalnl = 0;\n  outleft = max_count;\n  after_last_match = 0;\n  pending = 0;\n\n  nlines = 0;\n  residue = 0;\n  save = 0;\n\n  if (! fillbuf (save, stats))\n    {\n      suppressible_error (filename, errno);\n      return 0;\n    }\n\n  not_text = (((binary_files == BINARY_BINARY_FILES && !out_quiet)\n               || binary_files == WITHOUT_MATCH_BINARY_FILES)\n              && memchr (bufbeg, eol ? '\\0' : '\\200', buflim - bufbeg));\n  if (not_text && binary_files == WITHOUT_MATCH_BINARY_FILES)\n    return 0;\n  done_on_match += not_text;\n  out_quiet += not_text;\n\n  for (;;)\n    {\n      lastnl = bufbeg;\n      if (lastout)\n        lastout = bufbeg;\n\n      beg = bufbeg + save;\n\n      /* no more data to scan (eof) except for maybe a residue -> break */\n      if (beg == buflim)\n        break;\n\n      /* Determine new residue (the length of an incomplete line at the end of\n         the buffer, 0 means there is no incomplete last line).  */\n      oldc = beg[-1];\n      beg[-1] = eol;\n      for (lim = buflim; lim[-1] != eol; lim--)\n        continue;\n      beg[-1] = oldc;\n      if (lim == beg)\n        lim = beg - residue;\n      beg -= residue;\n      residue = buflim - lim;\n\n      if (beg < lim)\n        {\n          if (outleft)\n            nlines += grepbuf (beg, lim);\n          if (pending)\n            prpending (lim);\n          if ((!outleft && !pending) || (nlines && done_on_match && !out_invert))\n            goto finish_grep;\n        }\n\n      /* The last OUT_BEFORE lines at the end of the buffer will be needed as\n         leading context if there is a matching line at the begin of the\n         next data. Make beg point to their begin.  */\n      i = 0;\n      beg = lim;\n      while (i < out_before && beg > bufbeg && beg != lastout)\n        {\n          ++i;\n          do\n            --beg;\n          while (beg[-1] != eol);\n        }\n\n      /* detect if leading context is discontinuous from last printed line.  */\n      if (beg != lastout)\n        lastout = 0;\n\n      /* Handle some details and read more data to scan.  */\n      save = residue + lim - beg;\n      if (out_byte)\n        totalcc = add_count (totalcc, buflim - bufbeg - save);\n      if (out_line)\n        nlscan (beg);\n      if (! fillbuf (save, stats))\n        {\n          suppressible_error (filename, errno);\n          goto finish_grep;\n        }\n    }\n  if (residue)\n    {\n      *buflim++ = eol;\n      if (outleft)\n        nlines += grepbuf (bufbeg + save - residue, buflim);\n      if (pending)\n        prpending (buflim);\n    }\n\n finish_grep:\n  done_on_match -= not_text;\n  out_quiet -= not_text;\n  if ((not_text & ~out_quiet) && nlines != 0)\n    printf (_(\"Binary file %s matches\\n\"), filename);\n  return nlines;\n}\n\nstatic int\ngrepfile (char const *file, struct stats *stats)\n{\n  int desc;\n  int count;\n  int status;\n grepfile (char const *file, struct stats *stats)\n {\n   int desc;\n  int count;\n   int status;\n \n   filename = (file ? file : label ? label : _(\"(standard input)\"));\n      /* Don't open yet, since that might have side effects on a device.  */\n      desc = -1;\n    }\n  else\n    {\n      /* When skipping directories, don't worry about directories\n         that can't be opened.  */\n      desc = open (file, O_RDONLY);\n      if (desc < 0 && directories != SKIP_DIRECTORIES)\n        {\n          suppressible_error (file, errno);\n          return 1;\n        }\n    }\n\n  if (desc < 0\n      ? stat (file, &stats->stat) != 0\n      : fstat (desc, &stats->stat) != 0)\n    {\n      suppressible_error (filename, errno);\n      if (file)\n        close (desc);\n      return 1;\n    }\n\n  if ((directories == SKIP_DIRECTORIES && S_ISDIR (stats->stat.st_mode))\n      || (devices == SKIP_DEVICES && (S_ISCHR (stats->stat.st_mode)\n                                      || S_ISBLK (stats->stat.st_mode)\n                                      || S_ISSOCK (stats->stat.st_mode)\n                                      || S_ISFIFO (stats->stat.st_mode))))\n    {\n      if (file)\n        close (desc);\n      return 1;\n    }\n\n  /* If there is a regular file on stdout and the current file refers\n     to the same i-node, we have to report the problem and skip it.\n     Otherwise when matching lines from some other input reach the\n     disk before we open this file, we can end up reading and matching\n     those lines and appending them to the file from which we're reading.\n     Then we'd have what appears to be an infinite loop that'd terminate\n     only upon filling the output file system or reaching a quota.\n     However, there is no risk of an infinite loop if grep is generating\n     no output, i.e., with --silent, --quiet, -q.\n     Similarly, with any of these:\n       --max-count=N (-m) (for N >= 2)\n       --files-with-matches (-l)\n       --files-without-match (-L)\n     there is no risk of trouble.\n     For --max-count=1, grep stops after printing the first match,\n     so there is no risk of malfunction.  But even --max-count=2, with\n     input==output, while there is no risk of infloop, there is a race\n     condition that could result in \"alternate\" output.  */\n  if (!out_quiet && list_files == 0 && 1 < max_count\n      && S_ISREG (out_stat.st_mode) && out_stat.st_ino\n      && SAME_INODE (stats->stat, out_stat))\n    {\n      if (! suppress_errors)\n        error (0, 0, _(\"input file %s is also the output\"), quote (filename));\n      errseen = 1;\n      if (file)\n        close (desc);\n      return 1;\n    }\n\n  if (desc < 0)\n    {\n      desc = open (file, O_RDONLY);\n      if (desc < 0)\n        {\n          suppressible_error (file, errno);\n          return 1;\n        }\n    }\n\n#if defined SET_BINARY\n  /* Set input to binary mode.  Pipes are simulated with files\n     on DOS, so this includes the case of \"foo | grep bar\".  */\n  if (!isatty (desc))\n    SET_BINARY (desc);\n#endif\n\n  count = grep (desc, file, stats);\n  if (count < 0)\n    status = count + 2;\n  else\n    {\n      if (count_matches)\n        {\n          if (out_file)\n            {\n              print_filename ();\n              if (filename_mask)\n                print_sep (SEP_CHAR_SELECTED);\n              else\n                fputc (0, stdout);\n            }\n          printf (\"%d\\n\", count);\n        }\n               else\n                 fputc (0, stdout);\n             }\n          printf (\"%d\\n\", count);\n         }\n \n       status = !count;\n\n      if (! file)\n        {\n          off_t required_offset = outleft ? bufoffset : after_last_match;\n          if (required_offset != bufoffset\n              && lseek (desc, required_offset, SEEK_SET) < 0\n              && S_ISREG (stats->stat.st_mode))\n            suppressible_error (filename, errno);\n        }\n      else\n        while (close (desc) != 0)\n          if (errno != EINTR)\n            {\n              suppressible_error (file, errno);\n              break;\n            }\n    }\n", "target": 1, "idx": 177996}
{"func": "int __hid_register_driver(struct hid_driver *hdrv, struct module *owner,\n\t\tconst char *mod_name)\n{\n\tint ret;\n\n\thdrv->driver.name = hdrv->name;\n\thdrv->driver.bus = &hid_bus_type;\n\thdrv->driver.owner = owner;\n\thdrv->driver.mod_name = mod_name;\n\n\tINIT_LIST_HEAD(&hdrv->dyn_list);\n\tspin_lock_init(&hdrv->dyn_lock);\n\n\tret = driver_register(&hdrv->driver);\n\tif (ret)\n\t\treturn ret;\n\n\tret = driver_create_file(&hdrv->driver, &driver_attr_new_id);\n\tif (ret)\n\t\tdriver_unregister(&hdrv->driver);\n\n\treturn ret;\n}\n", "target": 0, "idx": 49472}
{"func": "SPL_METHOD(Array, unserialize)\n{\n\tspl_array_object *intern = (spl_array_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tchar *buf;\n\tint buf_len;\n\tconst unsigned char *p, *s;\n\tphp_unserialize_data_t var_hash;\n\tzval *pmembers, *pflags = NULL;\n\tHashTable *aht;\n\tlong flags;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &buf, &buf_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (buf_len == 0) {\n\t\treturn;\n\t}\n\n\taht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);\n\tif (aht->nApplyCount > 0) {\n\t\tzend_error(E_WARNING, \"Modification of ArrayObject during sorting is prohibited\");\n\t\treturn;\n\t}\n\n\t/* storage */\n\ts = p = (const unsigned char*)buf;\n\tPHP_VAR_UNSERIALIZE_INIT(var_hash);\n\n\tif (*p!= 'x' || *++p != ':') {\n\t\tgoto outexcept;\n\t}\n\t++p;\n\n\tALLOC_INIT_ZVAL(pflags);\n\tif (!php_var_unserialize(&pflags, &p, s + buf_len, &var_hash TSRMLS_CC) || Z_TYPE_P(pflags) != IS_LONG) {\n\t\tgoto outexcept;\n\t}\n\n\tvar_push_dtor(&var_hash, &pflags);\n\t--p; /* for ';' */\n\tflags = Z_LVAL_P(pflags);\n\t/* flags needs to be verified and we also need to verify whether the next\n\t * thing we get is ';'. After that we require an 'm' or somethign else\n\t * where 'm' stands for members and anything else should be an array. If\n\t * neither 'a' or 'm' follows we have an error. */\n\n\tif (*p != ';') {\n\t\tgoto outexcept;\n\t}\n\t++p;\n\n\tif (*p!='m') {\n\t\tif (*p!='a' && *p!='O' && *p!='C' && *p!='r') {\n\t\t\tgoto outexcept;\n\t\t}\n\t\tintern->ar_flags &= ~SPL_ARRAY_CLONE_MASK;\n \t\tintern->ar_flags |= flags & SPL_ARRAY_CLONE_MASK;\n \t\tzval_ptr_dtor(&intern->array);\n \t\tALLOC_INIT_ZVAL(intern->array);\n\t\tif (!php_var_unserialize(&intern->array, &p, s + buf_len, &var_hash TSRMLS_CC)) {\n \t\t\tgoto outexcept;\n \t\t}\n \t\tvar_push_dtor(&var_hash, &intern->array);\n\t}\n\tif (*p != ';') {\n\t\tgoto outexcept;\n\t}\n\t++p;\n\n\t/* members */\n\tif (*p!= 'm' || *++p != ':') {\n\t\tgoto outexcept;\n\t}\n\t++p;\n\n\tALLOC_INIT_ZVAL(pmembers);\n\tif (!php_var_unserialize(&pmembers, &p, s + buf_len, &var_hash TSRMLS_CC) || Z_TYPE_P(pmembers) != IS_ARRAY) {\n\t\tzval_ptr_dtor(&pmembers);\n\t\tgoto outexcept;\n\t}\n\n\tvar_push_dtor(&var_hash, &pmembers);\n\t/* copy members */\n\tif (!intern->std.properties) {\n\t\trebuild_object_properties(&intern->std);\n\t}\n\tzend_hash_copy(intern->std.properties, Z_ARRVAL_P(pmembers), (copy_ctor_func_t) zval_add_ref, (void *) NULL, sizeof(zval *));\n\tzval_ptr_dtor(&pmembers);\n\n\t/* done reading $serialized */\n\n\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\tif (pflags) {\n\t\tzval_ptr_dtor(&pflags);\n\t}\n\treturn;\n\noutexcept:\n\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\tif (pflags) {\n\t\tzval_ptr_dtor(&pflags);\n\t}\n\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Error at offset %ld of %d bytes\", (long)((char*)p - buf), buf_len);\n\treturn;\n\n} /* }}} */\n\n/* {{{ arginfo and function table */\n", "target": 1, "idx": 180102}
{"func": "void ImageCapture::UpdateMediaTrackCapabilities(\n    media::mojom::blink::PhotoStatePtr photo_state) {\n  if (!photo_state)\n    return;\n\n  WTF::Vector<WTF::String> supported_white_balance_modes;\n  supported_white_balance_modes.ReserveInitialCapacity(\n      photo_state->supported_white_balance_modes.size());\n  for (const auto& supported_mode : photo_state->supported_white_balance_modes)\n    supported_white_balance_modes.push_back(ToString(supported_mode));\n  if (!supported_white_balance_modes.IsEmpty()) {\n    capabilities_.setWhiteBalanceMode(std::move(supported_white_balance_modes));\n    settings_.setWhiteBalanceMode(\n        ToString(photo_state->current_white_balance_mode));\n  }\n\n  WTF::Vector<WTF::String> supported_exposure_modes;\n  supported_exposure_modes.ReserveInitialCapacity(\n      photo_state->supported_exposure_modes.size());\n  for (const auto& supported_mode : photo_state->supported_exposure_modes)\n    supported_exposure_modes.push_back(ToString(supported_mode));\n  if (!supported_exposure_modes.IsEmpty()) {\n    capabilities_.setExposureMode(std::move(supported_exposure_modes));\n    settings_.setExposureMode(ToString(photo_state->current_exposure_mode));\n  }\n\n  WTF::Vector<WTF::String> supported_focus_modes;\n  supported_focus_modes.ReserveInitialCapacity(\n      photo_state->supported_focus_modes.size());\n  for (const auto& supported_mode : photo_state->supported_focus_modes)\n    supported_focus_modes.push_back(ToString(supported_mode));\n  if (!supported_focus_modes.IsEmpty()) {\n    capabilities_.setFocusMode(std::move(supported_focus_modes));\n    settings_.setFocusMode(ToString(photo_state->current_focus_mode));\n  }\n\n  HeapVector<Point2D> current_points_of_interest;\n  if (!photo_state->points_of_interest.IsEmpty()) {\n    for (const auto& point : photo_state->points_of_interest) {\n      Point2D web_point;\n      web_point.setX(point->x);\n      web_point.setY(point->y);\n      current_points_of_interest.push_back(mojo::Clone(web_point));\n    }\n  }\n  settings_.setPointsOfInterest(std::move(current_points_of_interest));\n\n  if (photo_state->exposure_compensation->max !=\n      photo_state->exposure_compensation->min) {\n    capabilities_.setExposureCompensation(\n        MediaSettingsRange::Create(*photo_state->exposure_compensation));\n    settings_.setExposureCompensation(\n        photo_state->exposure_compensation->current);\n  }\n  if (photo_state->color_temperature->max !=\n      photo_state->color_temperature->min) {\n    capabilities_.setColorTemperature(\n        MediaSettingsRange::Create(*photo_state->color_temperature));\n    settings_.setColorTemperature(photo_state->color_temperature->current);\n  }\n  if (photo_state->iso->max != photo_state->iso->min) {\n    capabilities_.setIso(MediaSettingsRange::Create(*photo_state->iso));\n    settings_.setIso(photo_state->iso->current);\n  }\n\n  if (photo_state->brightness->max != photo_state->brightness->min) {\n    capabilities_.setBrightness(\n        MediaSettingsRange::Create(*photo_state->brightness));\n    settings_.setBrightness(photo_state->brightness->current);\n  }\n  if (photo_state->contrast->max != photo_state->contrast->min) {\n    capabilities_.setContrast(\n        MediaSettingsRange::Create(*photo_state->contrast));\n    settings_.setContrast(photo_state->contrast->current);\n  }\n  if (photo_state->saturation->max != photo_state->saturation->min) {\n    capabilities_.setSaturation(\n        MediaSettingsRange::Create(*photo_state->saturation));\n    settings_.setSaturation(photo_state->saturation->current);\n  }\n  if (photo_state->sharpness->max != photo_state->sharpness->min) {\n    capabilities_.setSharpness(\n        MediaSettingsRange::Create(*photo_state->sharpness));\n    settings_.setSharpness(photo_state->sharpness->current);\n  }\n\n  if (photo_state->zoom->max != photo_state->zoom->min) {\n    capabilities_.setZoom(MediaSettingsRange::Create(*photo_state->zoom));\n    settings_.setZoom(photo_state->zoom->current);\n  }\n\n  if (photo_state->supports_torch)\n    capabilities_.setTorch(photo_state->supports_torch);\n  if (photo_state->supports_torch)\n    settings_.setTorch(photo_state->torch);\n}\n", "target": 0, "idx": 163914}
{"func": "Chapters::Chapters(\n    Segment* pSegment,\n    long long payload_start,\n    long long payload_size,\n    long long element_start,\n    long long element_size) :\n    m_pSegment(pSegment),\n    m_start(payload_start),\n    m_size(payload_size),\n    m_element_start(element_start),\n    m_element_size(element_size),\n    m_editions(NULL),\n    m_editions_size(0),\n    m_editions_count(0)\n{\n}\n", "target": 1, "idx": 188265}
{"func": "DownloadManagerDelegate::ApplicationClientIdForFileScanning() const {\n  return std::string();\n}\n", "target": 0, "idx": 159280}
{"func": "int ff_mov_write_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    MOVMuxContext *mov = s->priv_data;\n    AVIOContext *pb = s->pb;\n    MOVTrack *trk = &mov->tracks[pkt->stream_index];\n    AVCodecParameters *par = trk->par;\n    unsigned int samples_in_chunk = 0;\n    int size = pkt->size, ret = 0;\n    uint8_t *reformatted_data = NULL;\n\n    ret = check_pkt(s, pkt);\n    if (ret < 0)\n        return ret;\n\n    if (mov->flags & FF_MOV_FLAG_FRAGMENT) {\n        int ret;\n        if (mov->moov_written || mov->flags & FF_MOV_FLAG_EMPTY_MOOV) {\n            if (mov->frag_interleave && mov->fragments > 0) {\n                if (trk->entry - trk->entries_flushed >= mov->frag_interleave) {\n                    if ((ret = mov_flush_fragment_interleaving(s, trk)) < 0)\n                        return ret;\n                }\n            }\n\n            if (!trk->mdat_buf) {\n                if ((ret = avio_open_dyn_buf(&trk->mdat_buf)) < 0)\n                    return ret;\n            }\n            pb = trk->mdat_buf;\n        } else {\n            if (!mov->mdat_buf) {\n                if ((ret = avio_open_dyn_buf(&mov->mdat_buf)) < 0)\n                    return ret;\n            }\n            pb = mov->mdat_buf;\n        }\n    }\n\n    if (par->codec_id == AV_CODEC_ID_AMR_NB) {\n        /* We must find out how many AMR blocks there are in one packet */\n        static const uint16_t packed_size[16] =\n            {13, 14, 16, 18, 20, 21, 27, 32, 6, 0, 0, 0, 0, 0, 0, 1};\n        int len = 0;\n\n        while (len < size && samples_in_chunk < 100) {\n            len += packed_size[(pkt->data[len] >> 3) & 0x0F];\n            samples_in_chunk++;\n        }\n        if (samples_in_chunk > 1) {\n            av_log(s, AV_LOG_ERROR, \"fatal error, input is not a single packet, implement a AVParser for it\\n\");\n            return -1;\n        }\n    } else if (par->codec_id == AV_CODEC_ID_ADPCM_MS ||\n               par->codec_id == AV_CODEC_ID_ADPCM_IMA_WAV) {\n        samples_in_chunk = trk->par->frame_size;\n    } else if (trk->sample_size)\n        samples_in_chunk = size / trk->sample_size;\n     else\n         samples_in_chunk = 1;\n \n     /* copy extradata if it exists */\n     if (trk->vos_len == 0 && par->extradata_size > 0 &&\n         !TAG_IS_AVCI(trk->tag) &&\n        (par->codec_id != AV_CODEC_ID_DNXHD)) {\n        trk->vos_len  = par->extradata_size;\n        trk->vos_data = av_malloc(trk->vos_len);\n        if (!trk->vos_data) {\n            ret = AVERROR(ENOMEM);\n            goto err;\n        }\n        memcpy(trk->vos_data, par->extradata, trk->vos_len);\n    }\n\n    if (par->codec_id == AV_CODEC_ID_AAC && pkt->size > 2 &&\n        (AV_RB16(pkt->data) & 0xfff0) == 0xfff0) {\n        if (!s->streams[pkt->stream_index]->nb_frames) {\n            av_log(s, AV_LOG_ERROR, \"Malformed AAC bitstream detected: \"\n                   \"use the audio bitstream filter 'aac_adtstoasc' to fix it \"\n                   \"('-bsf:a aac_adtstoasc' option with ffmpeg)\\n\");\n            return -1;\n        }\n        av_log(s, AV_LOG_WARNING, \"aac bitstream error\\n\");\n    }\n    if (par->codec_id == AV_CODEC_ID_H264 && trk->vos_len > 0 && *(uint8_t *)trk->vos_data != 1 && !TAG_IS_AVCI(trk->tag)) {\n        /* from x264 or from bytestream H.264 */\n        /* NAL reformatting needed */\n        if (trk->hint_track >= 0 && trk->hint_track < mov->nb_streams) {\n            ff_avc_parse_nal_units_buf(pkt->data, &reformatted_data,\n                                       &size);\n            avio_write(pb, reformatted_data, size);\n        } else {\n            if (trk->cenc.aes_ctr) {\n                size = ff_mov_cenc_avc_parse_nal_units(&trk->cenc, pb, pkt->data, size);\n                if (size < 0) {\n                    ret = size;\n                    goto err;\n                }\n            } else {\n                size = ff_avc_parse_nal_units(pb, pkt->data, pkt->size);\n            }\n        }\n    } else if (par->codec_id == AV_CODEC_ID_HEVC && trk->vos_len > 6 &&\n               (AV_RB24(trk->vos_data) == 1 || AV_RB32(trk->vos_data) == 1)) {\n        /* extradata is Annex B, assume the bitstream is too and convert it */\n        if (trk->hint_track >= 0 && trk->hint_track < mov->nb_streams) {\n            ff_hevc_annexb2mp4_buf(pkt->data, &reformatted_data, &size, 0, NULL);\n            avio_write(pb, reformatted_data, size);\n        } else {\n            size = ff_hevc_annexb2mp4(pb, pkt->data, pkt->size, 0, NULL);\n        }\n#if CONFIG_AC3_PARSER\n    } else if (par->codec_id == AV_CODEC_ID_EAC3) {\n        size = handle_eac3(mov, pkt, trk);\n        if (size < 0)\n            return size;\n        else if (!size)\n            goto end;\n        avio_write(pb, pkt->data, size);\n#endif\n    } else {\n        if (trk->cenc.aes_ctr) {\n            if (par->codec_id == AV_CODEC_ID_H264 && par->extradata_size > 4) {\n                int nal_size_length = (par->extradata[4] & 0x3) + 1;\n                ret = ff_mov_cenc_avc_write_nal_units(s, &trk->cenc, nal_size_length, pb, pkt->data, size);\n            } else {\n                ret = ff_mov_cenc_write_packet(&trk->cenc, pb, pkt->data, size);\n            }\n\n            if (ret) {\n                goto err;\n            }\n        } else {\n            avio_write(pb, pkt->data, size);\n        }\n    }\n\n    if ((par->codec_id == AV_CODEC_ID_DNXHD ||\n         par->codec_id == AV_CODEC_ID_AC3) && !trk->vos_len) {\n        /* copy frame to create needed atoms */\n        trk->vos_len  = size;\n        trk->vos_data = av_malloc(size);\n        if (!trk->vos_data) {\n            ret = AVERROR(ENOMEM);\n            goto err;\n        }\n        memcpy(trk->vos_data, pkt->data, size);\n    }\n\n    if (trk->entry >= trk->cluster_capacity) {\n        unsigned new_capacity = 2 * (trk->entry + MOV_INDEX_CLUSTER_SIZE);\n        if (av_reallocp_array(&trk->cluster, new_capacity,\n                              sizeof(*trk->cluster))) {\n            ret = AVERROR(ENOMEM);\n            goto err;\n        }\n        trk->cluster_capacity = new_capacity;\n    }\n\n    trk->cluster[trk->entry].pos              = avio_tell(pb) - size;\n    trk->cluster[trk->entry].samples_in_chunk = samples_in_chunk;\n    trk->cluster[trk->entry].chunkNum         = 0;\n    trk->cluster[trk->entry].size             = size;\n    trk->cluster[trk->entry].entries          = samples_in_chunk;\n    trk->cluster[trk->entry].dts              = pkt->dts;\n    trk->cluster[trk->entry].pts              = pkt->pts;\n    if (!trk->entry && trk->start_dts != AV_NOPTS_VALUE) {\n        if (!trk->frag_discont) {\n            /* First packet of a new fragment. We already wrote the duration\n             * of the last packet of the previous fragment based on track_duration,\n             * which might not exactly match our dts. Therefore adjust the dts\n             * of this packet to be what the previous packets duration implies. */\n            trk->cluster[trk->entry].dts = trk->start_dts + trk->track_duration;\n            /* We also may have written the pts and the corresponding duration\n             * in sidx/tfrf/tfxd tags; make sure the sidx pts and duration match up with\n             * the next fragment. This means the cts of the first sample must\n             * be the same in all fragments, unless end_pts was updated by\n             * the packet causing the fragment to be written. */\n            if ((mov->flags & FF_MOV_FLAG_DASH && !(mov->flags & FF_MOV_FLAG_GLOBAL_SIDX)) ||\n                mov->mode == MODE_ISM)\n                pkt->pts = pkt->dts + trk->end_pts - trk->cluster[trk->entry].dts;\n        } else {\n            /* New fragment, but discontinuous from previous fragments.\n             * Pretend the duration sum of the earlier fragments is\n             * pkt->dts - trk->start_dts. */\n            trk->frag_start = pkt->dts - trk->start_dts;\n            trk->end_pts = AV_NOPTS_VALUE;\n            trk->frag_discont = 0;\n        }\n    }\n\n    if (!trk->entry && trk->start_dts == AV_NOPTS_VALUE && !mov->use_editlist &&\n        s->avoid_negative_ts == AVFMT_AVOID_NEG_TS_MAKE_ZERO) {\n        /* Not using edit lists and shifting the first track to start from zero.\n         * If the other streams start from a later timestamp, we won't be able\n         * to signal the difference in starting time without an edit list.\n         * Thus move the timestamp for this first sample to 0, increasing\n         * its duration instead. */\n        trk->cluster[trk->entry].dts = trk->start_dts = 0;\n    }\n    if (trk->start_dts == AV_NOPTS_VALUE) {\n        trk->start_dts = pkt->dts;\n        if (trk->frag_discont) {\n            if (mov->use_editlist) {\n                /* Pretend the whole stream started at pts=0, with earlier fragments\n                 * already written. If the stream started at pts=0, the duration sum\n                 * of earlier fragments would have been pkt->pts. */\n                trk->frag_start = pkt->pts;\n                trk->start_dts  = pkt->dts - pkt->pts;\n            } else {\n                /* Pretend the whole stream started at dts=0, with earlier fragments\n                 * already written, with a duration summing up to pkt->dts. */\n                trk->frag_start = pkt->dts;\n                trk->start_dts  = 0;\n            }\n            trk->frag_discont = 0;\n        } else if (pkt->dts && mov->moov_written)\n            av_log(s, AV_LOG_WARNING,\n                   \"Track %d starts with a nonzero dts %\"PRId64\", while the moov \"\n                   \"already has been written. Set the delay_moov flag to handle \"\n                   \"this case.\\n\",\n                   pkt->stream_index, pkt->dts);\n    }\n    trk->track_duration = pkt->dts - trk->start_dts + pkt->duration;\n    trk->last_sample_is_subtitle_end = 0;\n\n    if (pkt->pts == AV_NOPTS_VALUE) {\n        av_log(s, AV_LOG_WARNING, \"pts has no value\\n\");\n        pkt->pts = pkt->dts;\n    }\n    if (pkt->dts != pkt->pts)\n        trk->flags |= MOV_TRACK_CTTS;\n    trk->cluster[trk->entry].cts   = pkt->pts - pkt->dts;\n    trk->cluster[trk->entry].flags = 0;\n    if (trk->start_cts == AV_NOPTS_VALUE)\n        trk->start_cts = pkt->pts - pkt->dts;\n    if (trk->end_pts == AV_NOPTS_VALUE)\n        trk->end_pts = trk->cluster[trk->entry].dts +\n                       trk->cluster[trk->entry].cts + pkt->duration;\n    else\n        trk->end_pts = FFMAX(trk->end_pts, trk->cluster[trk->entry].dts +\n                                           trk->cluster[trk->entry].cts +\n                                           pkt->duration);\n\n    if (par->codec_id == AV_CODEC_ID_VC1) {\n        mov_parse_vc1_frame(pkt, trk);\n    } else if (pkt->flags & AV_PKT_FLAG_KEY) {\n        if (mov->mode == MODE_MOV && par->codec_id == AV_CODEC_ID_MPEG2VIDEO &&\n            trk->entry > 0) { // force sync sample for the first key frame\n            mov_parse_mpeg2_frame(pkt, &trk->cluster[trk->entry].flags);\n            if (trk->cluster[trk->entry].flags & MOV_PARTIAL_SYNC_SAMPLE)\n                trk->flags |= MOV_TRACK_STPS;\n        } else {\n            trk->cluster[trk->entry].flags = MOV_SYNC_SAMPLE;\n        }\n        if (trk->cluster[trk->entry].flags & MOV_SYNC_SAMPLE)\n            trk->has_keyframes++;\n    }\n    if (pkt->flags & AV_PKT_FLAG_DISPOSABLE) {\n        trk->cluster[trk->entry].flags |= MOV_DISPOSABLE_SAMPLE;\n        trk->has_disposable++;\n    }\n    trk->entry++;\n    trk->sample_count += samples_in_chunk;\n    mov->mdat_size    += size;\n\n    if (trk->hint_track >= 0 && trk->hint_track < mov->nb_streams)\n        ff_mov_add_hinted_packet(s, pkt, trk->hint_track, trk->entry,\n                                 reformatted_data, size);\n\nend:\nerr:\n\n    av_free(reformatted_data);\n    return ret;\n}\n", "target": 1, "idx": 182290}
{"func": "static ssize_t ib_uverbs_comp_event_read(struct file *filp, char __user *buf,\n\t\t\t\t\t size_t count, loff_t *pos)\n{\n\tstruct ib_uverbs_completion_event_file *comp_ev_file =\n\t\tfilp->private_data;\n\n\treturn ib_uverbs_event_read(&comp_ev_file->ev_queue,\n\t\t\t\t    comp_ev_file->uobj.ufile, filp,\n\t\t\t\t    buf, count, pos,\n\t\t\t\t    sizeof(struct ib_uverbs_comp_event_desc));\n}\n", "target": 0, "idx": 90450}
{"func": "static void conditionalAttr1AttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)\n{\n    ExceptionState exceptionState(ExceptionState::SetterContext, \"conditionalAttr1\", \"TestObject\", info.Holder(), info.GetIsolate());\n    TestObject* imp = V8TestObject::toNative(info.Holder());\n    V8TRYCATCH_EXCEPTION_VOID(int, cppValue, toInt32(jsValue, exceptionState), exceptionState);\n    imp->setConditionalAttr1(cppValue);\n}\n", "target": 0, "idx": 130680}
{"func": "void ChromeInvalidationClient::ReissueRegistrations(\n    invalidation::InvalidationClient* client,\n     const std::string& prefix,\n     int prefix_length) {\n   DCHECK(CalledOnValidThread());\n   DVLOG(1) << \"AllRegistrationsLost\";\n   registration_manager_->MarkAllRegistrationsLost();\n }\n", "target": 1, "idx": 184517}
{"func": " bool MediaElementAudioSourceHandler::WouldTaintOrigin() {\n  if (MediaElement()->GetWebMediaPlayer()->DidPassCORSAccessCheck()) {\n    return false;\n  }\n  if (!MediaElement()->HasSingleSecurityOrigin()) {\n    return true;\n  }\n  return Context()->WouldTaintOrigin(MediaElement()->currentSrc());\n }\n", "target": 1, "idx": 186611}
{"func": "long ContentEncoding::ParseCompressionEntry(\n    long long start,\n    long long size,\n    IMkvReader* pReader,\n    ContentCompression* compression) {\n   assert(pReader);\n   assert(compression);\n \n long long pos = start;\n const long long stop = start + size;\n\n bool valid = false;\n\n \n   while (pos < stop) {\n     long long id, size;\n    const long status = ParseElementHeader(pReader,\n                                           pos,\n                                           stop,\n                                           id,\n                                           size);\n    if (status < 0)  //error\n       return status;\n \n     if (id == 0x254) {\n long long algo = UnserializeUInt(pReader, pos, size);\n if (algo < 0)\n return E_FILE_FORMAT_INVALID;\n      compression->algo = algo;\n      valid = true;\n } else if (id == 0x255) {\n if (size <= 0)\n return E_FILE_FORMAT_INVALID;\n\n const size_t buflen = static_cast<size_t>(size);\n typedef unsigned char* buf_t;\n const buf_t buf = new (std::nothrow) unsigned char[buflen];\n\n       if (buf == NULL)\n         return -1;\n \n      const int read_status = pReader->Read(pos, buflen, buf);\n       if (read_status) {\n        delete [] buf;\n         return status;\n       }\n \n      compression->settings = buf;\n\n       compression->settings_len = buflen;\n     }\n \n    pos += size;  //consume payload\n     assert(pos <= stop);\n   }\n \n if (!valid)\n return E_FILE_FORMAT_INVALID;\n\n\n   return 0;\n }\n", "target": 1, "idx": 188439}
{"func": "void AppLauncherHandler::FillAppDictionary(base::DictionaryValue* dictionary) {\n  base::AutoReset<bool> auto_reset(&ignore_changes_, true);\n\n  base::ListValue* list = new base::ListValue();\n  Profile* profile = Profile::FromWebUI(web_ui());\n  PrefService* prefs = profile->GetPrefs();\n\n  for (std::set<std::string>::iterator it = visible_apps_.begin();\n       it != visible_apps_.end(); ++it) {\n    const Extension* extension = extension_service_->GetInstalledExtension(*it);\n    if (extension && extensions::ui_util::ShouldDisplayInNewTabPage(\n            extension, profile)) {\n      base::DictionaryValue* app_info = GetAppInfo(extension);\n      list->Append(app_info);\n    }\n  }\n \n   dictionary->Set(\"apps\", list);\n \n#if defined(OS_MACOSX)\n  dictionary->SetBoolean(\"disableAppWindowLaunch\", true);\n  dictionary->SetBoolean(\"disableCreateAppShortcut\", true);\n#endif\n#if defined(OS_CHROMEOS)\n  dictionary->SetBoolean(\"disableCreateAppShortcut\", true);\n#endif\n   const base::ListValue* app_page_names =\n       prefs->GetList(prefs::kNtpAppPageNames);\n   if (!app_page_names || !app_page_names->GetSize()) {\n    ListPrefUpdate update(prefs, prefs::kNtpAppPageNames);\n    base::ListValue* list = update.Get();\n    list->Set(0, new base::StringValue(\n        l10n_util::GetStringUTF16(IDS_APP_DEFAULT_PAGE_NAME)));\n    dictionary->Set(\"appPageNames\",\n                    static_cast<base::ListValue*>(list->DeepCopy()));\n  } else {\n    dictionary->Set(\"appPageNames\",\n                    static_cast<base::ListValue*>(app_page_names->DeepCopy()));\n  }\n}\n", "target": 1, "idx": 184839}
{"func": "static int iwch_l2t_send(struct t3cdev *tdev, struct sk_buff *skb, struct l2t_entry *l2e)\n{\n\tint\terror = 0;\n\tstruct cxio_rdev *rdev;\n\n\trdev = (struct cxio_rdev *)tdev->ulp;\n\tif (cxio_fatal_error(rdev)) {\n\t\tkfree_skb(skb);\n\t\treturn -EIO;\n\t}\n \terror = l2t_send(tdev, skb, l2e);\n \tif (error < 0)\n \t\tkfree_skb(skb);\n\treturn error;\n }\n", "target": 1, "idx": 180668}
{"func": "void read_sequence_header(decoder_info_t *decoder_info, stream_t *stream) {\n   decoder_info->width = get_flc(16, stream);\n   decoder_info->height = get_flc(16, stream);\n   decoder_info->log2_sb_size = get_flc(3, stream);\n   decoder_info->pb_split = get_flc(1, stream);\n   decoder_info->tb_split_enable = get_flc(1, stream);\n   decoder_info->max_num_ref = get_flc(2, stream) + 1;\n  decoder_info->interp_ref = get_flc(2, stream);\n  decoder_info->max_delta_qp = get_flc(1, stream);\n  decoder_info->deblocking = get_flc(1, stream);\n  decoder_info->clpf = get_flc(1, stream);\n  decoder_info->use_block_contexts = get_flc(1, stream);\n  decoder_info->bipred = get_flc(2, stream);\n  decoder_info->qmtx = get_flc(1, stream);\n  if (decoder_info->qmtx) {\n    decoder_info->qmtx_offset = get_flc(6, stream) - 32;\n  }\n  decoder_info->subsample = get_flc(2, stream);\n    decoder_info->subsample = // 0: 400  1: 420  2: 422  3: 444\n    (decoder_info->subsample & 1) * 20 + (decoder_info->subsample & 2) * 22 +\n    ((decoder_info->subsample & 3) == 3) * 2 + 400;\n  decoder_info->num_reorder_pics = get_flc(4, stream);\n  if (decoder_info->subsample != 400) {\n    decoder_info->cfl_intra = get_flc(1, stream);\n    decoder_info->cfl_inter = get_flc(1, stream);\n  }\n  decoder_info->bitdepth = get_flc(1, stream) ? 10 : 8;\n  if (decoder_info->bitdepth == 10)\n    decoder_info->bitdepth += 2 * get_flc(1, stream);\n  decoder_info->input_bitdepth = get_flc(1, stream) ? 10 : 8;\n  if (decoder_info->input_bitdepth == 10)\n    decoder_info->input_bitdepth += 2 * get_flc(1, stream);\n}\n", "target": 1, "idx": 182539}
{"func": "     CCLayerTreeHostTest()\n         : m_beginning(false)\n         , m_endWhenBeginReturns(false)\n        , m_running(false)\n         , m_timedOut(false)\n     {\n         m_webThread = adoptPtr(webKitPlatformSupport()->createThread(\"CCLayerTreeHostTest\"));\n         WebCompositor::setThread(m_webThread.get());\n#if USE(THREADED_COMPOSITING)\n        m_settings.enableCompositorThread = true;\n#else\n        m_settings.enableCompositorThread = false;\n #endif\n     }\n", "target": 1, "idx": 183747}
{"func": "static int xfrm_exp_policy_notify(struct xfrm_policy *xp, int dir, const struct km_event *c)\n{\n\tstruct net *net = xp_net(xp);\n\tstruct sk_buff *skb;\n\n\tskb = nlmsg_new(xfrm_polexpire_msgsize(xp), GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tif (build_polexpire(skb, xp, dir, c) < 0)\n\t\tBUG();\n\n\treturn xfrm_nlmsg_multicast(net, skb, 0, XFRMNLGRP_EXPIRE);\n}\n", "target": 0, "idx": 59361}
{"func": "fn_printzp(netdissect_options *ndo,\n           register const u_char *s, register u_int n,\n           register const u_char *ep)\n{\n\tregister int ret;\n\tregister u_char c;\n\n\tret = 1;\t\t\t/* assume truncated */\n\twhile (n > 0 && (ep == NULL || s < ep)) {\n\t\tn--;\n\t\tc = *s++;\n\t\tif (c == '\\0') {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (!ND_ISASCII(c)) {\n\t\t\tc = ND_TOASCII(c);\n\t\t\tND_PRINT((ndo, \"M-\"));\n\t\t}\n\t\tif (!ND_ISPRINT(c)) {\n\t\t\tc ^= 0x40;\t/* DEL to ?, others to alpha */\n\t\t\tND_PRINT((ndo, \"^\"));\n\t\t}\n\t\tND_PRINT((ndo, \"%c\", c));\n\t}\n\treturn (n == 0) ? 0 : ret;\n}\n", "target": 0, "idx": 62383}
{"func": "  explicit TestWindowObserver(aura::Window* window_to_observe)\n      : window_(window_to_observe) {\n    window_->AddObserver(this);\n  }\n", "target": 0, "idx": 158469}
{"func": "lrmd_remote_listen(gpointer data)\n{\n    int csock = 0;\n    int flag = 0;\n    unsigned laddr = 0;\n    struct sockaddr addr;\n    gnutls_session_t *session = NULL;\n    crm_client_t *new_client = NULL;\n\n    static struct mainloop_fd_callbacks lrmd_remote_fd_cb = {\n        .dispatch = lrmd_remote_client_msg,\n        .destroy = lrmd_remote_client_destroy,\n    };\n\n    laddr = sizeof(addr);\n    memset(&addr, 0, sizeof(addr));\n    getsockname(ssock, &addr, &laddr);\n\n    /* accept the connection */\n\n    if (addr.sa_family == AF_INET6) {\n        struct sockaddr_in6 sa;\n        char addr_str[INET6_ADDRSTRLEN];\n\n        laddr = sizeof(sa);\n        memset(&sa, 0, sizeof(sa));\n        csock = accept(ssock, &sa, &laddr);\n        get_ip_str((struct sockaddr *)&sa, addr_str, INET6_ADDRSTRLEN);\n        crm_info(\"New remote connection from %s\", addr_str);\n\n    } else {\n        struct sockaddr_in sa;\n        char addr_str[INET_ADDRSTRLEN];\n\n        laddr = sizeof(sa);\n        memset(&sa, 0, sizeof(sa));\n        csock = accept(ssock, &sa, &laddr);\n        get_ip_str((struct sockaddr *)&sa, addr_str, INET_ADDRSTRLEN);\n        crm_info(\"New remote connection from %s\", addr_str);\n    }\n\n    if (csock == -1) {\n        crm_err(\"accept socket failed\");\n        return TRUE;\n    }\n\n    if ((flag = fcntl(csock, F_GETFL)) >= 0) {\n        if (fcntl(csock, F_SETFL, flag | O_NONBLOCK) < 0) {\n            crm_err(\"fcntl() write failed\");\n            close(csock);\n            return TRUE;\n        }\n    } else {\n        crm_err(\"fcntl() read failed\");\n        close(csock);\n        return TRUE;\n    }\n\n    session = create_psk_tls_session(csock, GNUTLS_SERVER, psk_cred_s);\n    if (session == NULL) {\n        crm_err(\"TLS session creation failed\");\n        close(csock);\n        return TRUE;\n    }\n\n    new_client = calloc(1, sizeof(crm_client_t));\n    new_client->remote = calloc(1, sizeof(crm_remote_t));\n    new_client->kind = CRM_CLIENT_TLS;\n    new_client->remote->tls_session = session;\n    new_client->id = crm_generate_uuid();\n    new_client->remote->auth_timeout =\n        g_timeout_add(LRMD_REMOTE_AUTH_TIMEOUT, lrmd_auth_timeout_cb, new_client);\n    crm_notice(\"LRMD client connection established. %p id: %s\", new_client, new_client->id);\n\n    new_client->remote->source =\n        mainloop_add_fd(\"lrmd-remote-client\", G_PRIORITY_DEFAULT, csock, new_client,\n                         &lrmd_remote_fd_cb);\n     g_hash_table_insert(client_connections, new_client->id, new_client);\n \n    /* Alert other clients of the new connection */\n    notify_of_new_client(new_client);\n     return TRUE;\n }\n", "target": 1, "idx": 181957}
{"func": "decode_NXAST_RAW_OUTPUT_REG(const struct nx_action_output_reg *naor,\n                            enum ofp_version ofp_version OVS_UNUSED,\n                            const struct vl_mff_map *vl_mff_map,\n                            uint64_t *tlv_bitmap, struct ofpbuf *out)\n{\n    struct ofpact_output_reg *output_reg;\n    enum ofperr error;\n\n    if (!is_all_zeros(naor->zero, sizeof naor->zero)) {\n        return OFPERR_OFPBAC_BAD_ARGUMENT;\n    }\n\n    output_reg = ofpact_put_OUTPUT_REG(out);\n    output_reg->ofpact.raw = NXAST_RAW_OUTPUT_REG;\n    output_reg->src.ofs = nxm_decode_ofs(naor->ofs_nbits);\n    output_reg->src.n_bits = nxm_decode_n_bits(naor->ofs_nbits);\n    output_reg->max_len = ntohs(naor->max_len);\n    error = mf_vl_mff_mf_from_nxm_header(ntohl(naor->src), vl_mff_map,\n                                         &output_reg->src.field, tlv_bitmap);\n    if (error) {\n        return error;\n    }\n\n    return mf_check_src(&output_reg->src, NULL);\n}\n", "target": 0, "idx": 76803}
{"func": "void SoftAMR::onQueueFilled(OMX_U32 /* portIndex */) {\n List<BufferInfo *> &inQueue = getPortQueue(0);\n List<BufferInfo *> &outQueue = getPortQueue(1);\n\n if (mSignalledError || mOutputPortSettingsChange != NONE) {\n return;\n }\n\n while (!inQueue.empty() && !outQueue.empty()) {\n BufferInfo *inInfo = *inQueue.begin();\n        OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;\n\n BufferInfo *outInfo = *outQueue.begin();\n        OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;\n\n if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {\n            inQueue.erase(inQueue.begin());\n            inInfo->mOwnedByUs = false;\n            notifyEmptyBufferDone(inHeader);\n\n            outHeader->nFilledLen = 0;\n            outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n\n            outQueue.erase(outQueue.begin());\n            outInfo->mOwnedByUs = false;\n            notifyFillBufferDone(outHeader);\n return;\n }\n\n if (inHeader->nOffset == 0) {\n            mAnchorTimeUs = inHeader->nTimeStamp;\n            mNumSamplesOutput = 0;\n }\n\n const uint8_t *inputPtr = inHeader->pBuffer + inHeader->nOffset;\n\n         int32_t numBytesRead;\n \n         if (mMode == MODE_NARROW) {\n             numBytesRead =\n                 AMRDecode(mState,\n                   (Frame_Type_3GPP)((inputPtr[0] >> 3) & 0x0f),\n (UWord8 *)&inputPtr[1],\n reinterpret_cast<int16_t *>(outHeader->pBuffer),\n                  MIME_IETF);\n\n if (numBytesRead == -1) {\n                ALOGE(\"PV AMR decoder AMRDecode() call failed\");\n\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                mSignalledError = true;\n\n return;\n }\n\n ++numBytesRead; // Include the frame type header byte.\n\n if (static_cast<size_t>(numBytesRead) > inHeader->nFilledLen) {\n\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                mSignalledError = true;\n\n\n                 return;\n             }\n         } else {\n             int16 mode = ((inputPtr[0] >> 3) & 0x0f);\n \n             if (mode >= 10 && mode <= 13) {\n                ALOGE(\"encountered illegal frame type %d in AMR WB content.\",\n                      mode);\n\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                mSignalledError = true;\n\n return;\n }\n\n size_t frameSize = getFrameSize(mode);\n            CHECK_GE(inHeader->nFilledLen, frameSize);\n\n int16_t *outPtr = (int16_t *)outHeader->pBuffer;\n\n if (mode >= 9) {\n                memset(outPtr, 0, kNumSamplesPerFrameWB * sizeof(int16_t));\n } else if (mode < 9) {\n int16 frameType;\n                RX_State_wb rx_state;\n                mime_unsorting(\n const_cast<uint8_t *>(&inputPtr[1]),\n                        mInputSampleBuffer,\n &frameType, &mode, 1, &rx_state);\n\n int16_t numSamplesOutput;\n                pvDecoder_AmrWb(\n                        mode, mInputSampleBuffer,\n                        outPtr,\n &numSamplesOutput,\n                        mDecoderBuf, frameType, mDecoderCookie);\n\n                CHECK_EQ((int)numSamplesOutput, (int)kNumSamplesPerFrameWB);\n\n for (int i = 0; i < kNumSamplesPerFrameWB; ++i) {\n /* Delete the 2 LSBs (14-bit output) */\n                    outPtr[i] &= 0xfffC;\n }\n }\n\n            numBytesRead = frameSize;\n }\n\n        inHeader->nOffset += numBytesRead;\n        inHeader->nFilledLen -= numBytesRead;\n\n        outHeader->nFlags = 0;\n        outHeader->nOffset = 0;\n\n if (mMode == MODE_NARROW) {\n            outHeader->nFilledLen = kNumSamplesPerFrameNB * sizeof(int16_t);\n\n            outHeader->nTimeStamp =\n                mAnchorTimeUs\n + (mNumSamplesOutput * 1000000ll) / kSampleRateNB;\n\n            mNumSamplesOutput += kNumSamplesPerFrameNB;\n } else {\n            outHeader->nFilledLen = kNumSamplesPerFrameWB * sizeof(int16_t);\n\n            outHeader->nTimeStamp =\n                mAnchorTimeUs\n + (mNumSamplesOutput * 1000000ll) / kSampleRateWB;\n\n            mNumSamplesOutput += kNumSamplesPerFrameWB;\n }\n\n if (inHeader->nFilledLen == 0) {\n            inInfo->mOwnedByUs = false;\n            inQueue.erase(inQueue.begin());\n            inInfo = NULL;\n            notifyEmptyBufferDone(inHeader);\n            inHeader = NULL;\n }\n\n        outInfo->mOwnedByUs = false;\n        outQueue.erase(outQueue.begin());\n        outInfo = NULL;\n        notifyFillBufferDone(outHeader);\n        outHeader = NULL;\n\n ++mInputBufferCount;\n }\n}\n", "target": 1, "idx": 187901}
{"func": "void ManualFillingControllerImpl::Hide(FillingSource source) {\n  if (source == FillingSource::AUTOFILL &&\n      !base::FeatureList::IsEnabled(\n          autofill::features::kAutofillKeyboardAccessory)) {\n    return;\n  }\n  visible_sources_.erase(source);\n  if (visible_sources_.empty())\n    view_->Hide();\n}\n", "target": 0, "idx": 142253}
{"func": "bool_t xdr_krb5_tl_data(XDR *xdrs, krb5_tl_data **tl_data_head)\n{\n     krb5_tl_data *tl, *tl2;\n     bool_t more;\n     unsigned int len;\n\n     switch (xdrs->x_op) {\n     case XDR_FREE:\n\t  tl = tl2 = *tl_data_head;\n\t  while (tl) {\n\t       tl2 = tl->tl_data_next;\n\t       free(tl->tl_data_contents);\n \t       free(tl);\n \t       tl = tl2;\n \t  }\n \t  break;\n \n      case XDR_ENCODE:\n\t  tl = *tl_data_head;\n\t  while (1) {\n\t       more = (tl != NULL);\n\t       if (!xdr_bool(xdrs, &more))\n\t\t    return FALSE;\n\t       if (tl == NULL)\n\t\t    break;\n\t       if (!xdr_krb5_int16(xdrs, &tl->tl_data_type))\n\t\t    return FALSE;\n\t       len = tl->tl_data_length;\n\t       if (!xdr_bytes(xdrs, (char **) &tl->tl_data_contents, &len, ~0))\n\t\t    return FALSE;\n\t       tl = tl->tl_data_next;\n\t  }\n\t  break;\n\n     case XDR_DECODE:\n\t  tl = NULL;\n\t  while (1) {\n\t       if (!xdr_bool(xdrs, &more))\n\t\t    return FALSE;\n\t       if (more == FALSE)\n\t\t    break;\n\t       tl2 = (krb5_tl_data *) malloc(sizeof(krb5_tl_data));\n\t       if (tl2 == NULL)\n\t\t    return FALSE;\n\t       memset(tl2, 0, sizeof(krb5_tl_data));\n\t       if (!xdr_krb5_int16(xdrs, &tl2->tl_data_type))\n\t\t    return FALSE;\n\t       if (!xdr_bytes(xdrs, (char **)&tl2->tl_data_contents, &len, ~0))\n\t\t    return FALSE;\n\t       tl2->tl_data_length = len;\n\n\t       tl2->tl_data_next = tl;\n\t       tl = tl2;\n\t  }\n\n\t  *tl_data_head = tl;\n\t  break;\n     }\n\n     return TRUE;\n}\n", "target": 1, "idx": 179963}
{"func": "static INLINE void check_resync(vpx_codec_alg_priv_t *const ctx,\n const VP9Decoder *const pbi) {\n if (ctx->need_resync == 1 && pbi->need_resync == 0 &&\n (pbi->common.intra_only || pbi->common.frame_type == KEY_FRAME))\n    ctx->need_resync = 0;\n}\n", "target": 0, "idx": 171430}
{"func": "static void renew_lease(const struct nfs_server *server, unsigned long timestamp)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\n\tif (!nfs4_has_session(clp))\n\t\tdo_renew_lease(clp, timestamp);\n}\n", "target": 0, "idx": 57276}
{"func": " void qemu_spice_create_host_primary(SimpleSpiceDisplay *ssd)\n {\n     QXLDevSurfaceCreate surface;\n \n     memset(&surface, 0, sizeof(surface));\n \n    dprint(1, \"%s/%d: %dx%d\\n\", __func__, ssd->qxl.id,\n           surface_width(ssd->ds), surface_height(ssd->ds));\n \n     surface.format     = SPICE_SURFACE_FMT_32_xRGB;\n     surface.width      = surface_width(ssd->ds);\n{\n    dprint(1, \"%s/%d:\\n\", __func__, ssd->qxl.id);\n\n    qemu_spice_destroy_primary_surface(ssd, 0, QXL_SYNC);\n}\n\nvoid qemu_spice_display_init_common(SimpleSpiceDisplay *ssd)\n{\n    qemu_mutex_init(&ssd->lock);\n    QTAILQ_INIT(&ssd->updates);\n    ssd->mouse_x = -1;\n    ssd->mouse_y = -1;\n    if (ssd->num_surfaces == 0) {\n        ssd->num_surfaces = 1024;\n    }\n    ssd->bufsize = (16 * 1024 * 1024);\n    ssd->buf = g_malloc(ssd->bufsize);\n}\n\n/* display listener callbacks */\n\nvoid qemu_spice_display_update(SimpleSpiceDisplay *ssd,\n                               int x, int y, int w, int h)\n{\n     if (ssd->num_surfaces == 0) {\n         ssd->num_surfaces = 1024;\n     }\n    ssd->bufsize = (16 * 1024 * 1024);\n    ssd->buf = g_malloc(ssd->bufsize);\n }\n \n /* display listener callbacks */\n    update_area.top = y;\n    update_area.bottom = y + h;\n\n    if (qemu_spice_rect_is_empty(&ssd->dirty)) {\n        ssd->notify++;\n    }\n    qemu_spice_rect_union(&ssd->dirty, &update_area);\n}\n", "target": 1, "idx": 178323}
{"func": "ftrace_regex_lseek(struct file *file, loff_t offset, int whence)\n {\n \tloff_t ret;\n \n\tif (file->f_mode & FMODE_READ)\n\t\tret = seq_lseek(file, offset, whence);\n\telse\n\t\tfile->f_pos = ret = 1;\n\n\treturn ret;\n}\n", "target": 1, "idx": 179199}
{"func": "static int xc2028_get_reg(struct xc2028_data *priv, u16 reg, u16 *val)\n{\n\tunsigned char buf[2];\n\tunsigned char ibuf[2];\n\n\ttuner_dbg(\"%s %04x called\\n\", __func__, reg);\n\n\tbuf[0] = reg >> 8;\n\tbuf[1] = (unsigned char) reg;\n\n\tif (i2c_send_recv(priv, buf, 2, ibuf, 2) != 2)\n\t\treturn -EIO;\n\n\t*val = (ibuf[1]) | (ibuf[0] << 8);\n\treturn 0;\n}\n", "target": 0, "idx": 49551}
{"func": "static void pcrypt_fini_padata(struct padata_pcrypt *pcrypt)\n{\n\tfree_cpumask_var(pcrypt->cb_cpumask->mask);\n\tkfree(pcrypt->cb_cpumask);\n\n\tpadata_stop(pcrypt->pinst);\n\tpadata_unregister_cpumask_notifier(pcrypt->pinst, &pcrypt->nblock);\n\tdestroy_workqueue(pcrypt->wq);\n\tpadata_free(pcrypt->pinst);\n}\n", "target": 0, "idx": 45881}
{"func": "static int coroutine_fn v9fs_do_readdir_with_stat(V9fsPDU *pdu,\n                                                  V9fsFidState *fidp,\n                                                  uint32_t max_count)\n{\n    V9fsPath path;\n    V9fsStat v9stat;\n    int len, err = 0;\n    int32_t count = 0;\n    struct stat stbuf;\n    off_t saved_dir_pos;\n    struct dirent *dent;\n\n    /* save the directory position */\n    saved_dir_pos = v9fs_co_telldir(pdu, fidp);\n    if (saved_dir_pos < 0) {\n        return saved_dir_pos;\n    }\n\n    while (1) {\n        v9fs_path_init(&path);\n\n        v9fs_readdir_lock(&fidp->fs.dir);\n\n        err = v9fs_co_readdir(pdu, fidp, &dent);\n        if (err || !dent) {\n            break;\n        }\n        err = v9fs_co_name_to_path(pdu, &fidp->path, dent->d_name, &path);\n        if (err < 0) {\n            break;\n        }\n        err = v9fs_co_lstat(pdu, &path, &stbuf);\n        if (err < 0) {\n            break;\n        }\n        err = stat_to_v9stat(pdu, &path, &stbuf, &v9stat);\n        if (err < 0) {\n            break;\n        }\n        /* 11 = 7 + 4 (7 = start offset, 4 = space for storing count) */\n        len = pdu_marshal(pdu, 11 + count, \"S\", &v9stat);\n\n        v9fs_readdir_unlock(&fidp->fs.dir);\n\n        if ((len != (v9stat.size + 2)) || ((count + len) > max_count)) {\n            /* Ran out of buffer. Set dir back to old position and return */\n            v9fs_co_seekdir(pdu, fidp, saved_dir_pos);\n            v9fs_stat_free(&v9stat);\n            v9fs_path_free(&path);\n            return count;\n        }\n        count += len;\n        v9fs_stat_free(&v9stat);\n        v9fs_path_free(&path);\n        saved_dir_pos = dent->d_off;\n    }\n\n    v9fs_readdir_unlock(&fidp->fs.dir);\n\n    v9fs_path_free(&path);\n    if (err < 0) {\n        return err;\n    }\n    return count;\n}\n", "target": 0, "idx": 7715}
{"func": "static void strictFunctionMethod(const v8::FunctionCallbackInfo<v8::Value>& info)\n{\n    ExceptionState exceptionState(ExceptionState::ExecutionContext, \"strictFunction\", \"TestObject\", info.Holder(), info.GetIsolate());\n    if (UNLIKELY(info.Length() < 3)) {\n        exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));\n        exceptionState.throwIfNeeded();\n        return;\n    }\n    TestObject* imp = V8TestObject::toNative(info.Holder());\n    V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID(V8StringResource<>, str, info[0]);\n    V8TRYCATCH_VOID(float, a, static_cast<float>(info[1]->NumberValue()));\n    V8TRYCATCH_EXCEPTION_VOID(int, b, toInt32(info[2], exceptionState), exceptionState);\n    bool result = imp->strictFunction(str, a, b, exceptionState);\n    if (exceptionState.throwIfNeeded())\n        return;\n    v8SetReturnValueBool(info, result);\n}\n", "target": 0, "idx": 131069}
{"func": "static int __follow_pte(struct mm_struct *mm, unsigned long address,\n\t\tpte_t **ptepp, spinlock_t **ptlp)\n{\n\tpgd_t *pgd;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *ptep;\n\n\tpgd = pgd_offset(mm, address);\n\tif (pgd_none(*pgd) || unlikely(pgd_bad(*pgd)))\n\t\tgoto out;\n\n\tpud = pud_offset(pgd, address);\n\tif (pud_none(*pud) || unlikely(pud_bad(*pud)))\n\t\tgoto out;\n\n\tpmd = pmd_offset(pud, address);\n\tVM_BUG_ON(pmd_trans_huge(*pmd));\n\tif (pmd_none(*pmd) || unlikely(pmd_bad(*pmd)))\n\t\tgoto out;\n\n\t/* We cannot handle huge page PFN maps. Luckily they don't exist. */\n\tif (pmd_huge(*pmd))\n\t\tgoto out;\n\n\tptep = pte_offset_map_lock(mm, pmd, address, ptlp);\n\tif (!ptep)\n\t\tgoto out;\n\tif (!pte_present(*ptep))\n\t\tgoto unlock;\n\t*ptepp = ptep;\n\treturn 0;\nunlock:\n\tpte_unmap_unlock(ptep, *ptlp);\nout:\n\treturn -EINVAL;\n}\n", "target": 0, "idx": 21188}
{"func": "void NavigationControllerImpl::ReloadInternal(bool check_for_repost,\n                                              ReloadType reload_type) {\n  if (transient_entry_index_ != -1) {\n    NavigationEntryImpl* active_entry =\n        NavigationEntryImpl::FromNavigationEntry(GetActiveEntry());\n    if (!active_entry)\n      return;\n    LoadURL(active_entry->GetURL(),\n            Referrer(),\n            PAGE_TRANSITION_RELOAD,\n            active_entry->extra_headers());\n    return;\n  }\n\n  NavigationEntryImpl* entry = NULL;\n  int current_index = -1;\n\n  if (IsInitialNavigation() && pending_entry_) {\n    entry = pending_entry_;\n    current_index = pending_entry_index_;\n  } else {\n    DiscardNonCommittedEntriesInternal();\n    current_index = GetCurrentEntryIndex();\n    if (current_index != -1) {\n      entry = NavigationEntryImpl::FromNavigationEntry(\n          GetEntryAtIndex(current_index));\n    }\n  }\n\n  if (!entry)\n    return;\n\n  if (g_check_for_repost && check_for_repost &&\n      entry->GetHasPostData()) {\n    web_contents_->NotifyBeforeFormRepostWarningShow();\n\n    pending_reload_ = reload_type;\n    web_contents_->Activate();\n    web_contents_->GetDelegate()->ShowRepostFormWarningDialog(web_contents_);\n  } else {\n    if (!IsInitialNavigation())\n      DiscardNonCommittedEntriesInternal();\n\n    SiteInstanceImpl* site_instance = entry->site_instance();\n    if (site_instance &&\n        site_instance->HasWrongProcessForURL(entry->GetURL())) {\n      NavigationEntryImpl* nav_entry = NavigationEntryImpl::FromNavigationEntry(\n          CreateNavigationEntry(\n              entry->GetURL(), entry->GetReferrer(), entry->GetTransitionType(),\n              false, entry->extra_headers(), browser_context_));\n\n      reload_type = NavigationController::NO_RELOAD;\n\n      nav_entry->set_should_replace_entry(true);\n      pending_entry_ = nav_entry;\n    } else {\n      pending_entry_ = entry;\n      pending_entry_index_ = current_index;\n\n      pending_entry_->SetTitle(string16());\n\n      pending_entry_->SetTransitionType(PAGE_TRANSITION_RELOAD);\n    }\n\n    NavigateToPendingEntry(reload_type);\n  }\n}\n", "target": 0, "idx": 119808}
{"func": "DefragReverseSimpleTest(void)\n{\n    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;\n    Packet *reassembled = NULL;\n    int id = 12;\n    int i;\n    int ret = 0;\n \n     DefragInit();\n \n    p1 = BuildTestPacket(id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n    p2 = BuildTestPacket(id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n    p3 = BuildTestPacket(id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n    if (Defrag(NULL, NULL, p3, NULL) != NULL)\n        goto end;\n    if (Defrag(NULL, NULL, p2, NULL) != NULL)\n        goto end;\n\n    reassembled = Defrag(NULL, NULL, p1, NULL);\n    if (reassembled == NULL)\n        goto end;\n\n    if (IPV4_GET_HLEN(reassembled) != 20)\n        goto end;\n    if (IPV4_GET_IPLEN(reassembled) != 39)\n        goto end;\n\n    /* 20 bytes in we should find 8 bytes of A. */\n    for (i = 20; i < 20 + 8; i++) {\n        if (GET_PKT_DATA(reassembled)[i] != 'A')\n            goto end;\n    }\n\n    /* 28 bytes in we should find 8 bytes of B. */\n    for (i = 28; i < 28 + 8; i++) {\n        if (GET_PKT_DATA(reassembled)[i] != 'B')\n            goto end;\n    }\n\n    /* And 36 bytes in we should find 3 bytes of C. */\n    for (i = 36; i < 36 + 3; i++) {\n        if (GET_PKT_DATA(reassembled)[i] != 'C')\n            goto end;\n    }\n\n    ret = 1;\nend:\n    if (p1 != NULL)\n        SCFree(p1);\n    if (p2 != NULL)\n        SCFree(p2);\n    if (p3 != NULL)\n        SCFree(p3);\n    if (reassembled != NULL)\n        SCFree(reassembled);\n\n    DefragDestroy();\n    return ret;\n}\n", "target": 1, "idx": 181474}
{"func": "static inline void account_numa_dequeue(struct rq *rq, struct task_struct *p)\n{\n}\n", "target": 0, "idx": 92455}
{"func": "static int find_hole(void)\n{\n   unsigned x;\n   int      y, z;\n   for (z = -1, y = INT_MAX, x = 0; x < FP_ENTRIES; x++) {\n       if (fp_cache[x].lru_count < y && fp_cache[x].lock == 0) {\n          z = x;\n          y = fp_cache[x].lru_count;\n       }\n   }\n\n   /* decrease all */\n   for (x = 0; x < FP_ENTRIES; x++) {\n      if (fp_cache[x].lru_count > 3) {\n         --(fp_cache[x].lru_count);\n      }\n   }\n\n   /* free entry z */\n   if (z >= 0 && fp_cache[z].g) {\n      mp_clear(&fp_cache[z].mu);\n      wc_ecc_del_point(fp_cache[z].g);\n      fp_cache[z].g  = NULL;\n      for (x = 0; x < (1U<<FP_LUT); x++) {\n         wc_ecc_del_point(fp_cache[z].LUT[x]);\n         fp_cache[z].LUT[x] = NULL;\n      }\n      fp_cache[z].lru_count = 0;\n   }\n   return z;\n}\n", "target": 0, "idx": 81842}
{"func": "String PresentationConnection::binaryType() const {\n  switch (m_binaryType) {\n    case BinaryTypeBlob:\n      return \"blob\";\n    case BinaryTypeArrayBuffer:\n      return \"arraybuffer\";\n  }\n  ASSERT_NOT_REACHED();\n  return String();\n}\n", "target": 0, "idx": 140898}
{"func": "void AXTableCell::columnIndexRange(std::pair<unsigned, unsigned>& columnRange) {\n  if (!m_layoutObject || !m_layoutObject->isTableCell())\n    return;\n\n  LayoutTableCell* cell = toLayoutTableCell(m_layoutObject);\n  columnRange.first = cell->table()->absoluteColumnToEffectiveColumn(\n      cell->absoluteColumnIndex());\n  columnRange.second = cell->table()->absoluteColumnToEffectiveColumn(\n                           cell->absoluteColumnIndex() + cell->colSpan()) -\n                       columnRange.first;\n}\n", "target": 0, "idx": 138297}
{"func": "sctp_disposition_t sctp_sf_ootb(struct net *net,\n\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\tvoid *arg,\n\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sk_buff *skb = chunk->skb;\n\tsctp_chunkhdr_t *ch;\n\tsctp_errhdr_t *err;\n\t__u8 *ch_end;\n\tint ootb_shut_ack = 0;\n\tint ootb_cookie_ack = 0;\n\n\tSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\n\n\tch = (sctp_chunkhdr_t *) chunk->chunk_hdr;\n\tdo {\n\t\t/* Report violation if the chunk is less then minimal */\n\t\tif (ntohs(ch->length) < sizeof(sctp_chunkhdr_t))\n \t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n \t\t\t\t\t\t  commands);\n \n \t\t/* Now that we know we at least have a chunk header,\n \t\t * do things that are type appropriate.\n \t\t */\n\t\tif (SCTP_CID_SHUTDOWN_ACK == ch->type)\n\t\t\tootb_shut_ack = 1;\n\n\t\t/* RFC 2960, Section 3.3.7\n\t\t *   Moreover, under any circumstances, an endpoint that\n\t\t *   receives an ABORT  MUST NOT respond to that ABORT by\n\t\t *   sending an ABORT of its own.\n\t\t */\n\t\tif (SCTP_CID_ABORT == ch->type)\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t\t/* RFC 8.4, 7) If the packet contains a \"Stale cookie\" ERROR\n\t\t * or a COOKIE ACK the SCTP Packet should be silently\n\t\t * discarded.\n\t\t */\n\n\t\tif (SCTP_CID_COOKIE_ACK == ch->type)\n\t\t\tootb_cookie_ack = 1;\n\n\t\tif (SCTP_CID_ERROR == ch->type) {\n\t\t\tsctp_walk_errors(err, ch) {\n\t\t\t\tif (SCTP_ERROR_STALE_COOKIE == err->cause) {\n\t\t\t\t\tootb_cookie_ack = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n \t\t\t}\n \t\t}\n \n\t\t/* Report violation if chunk len overflows */\n\t\tch_end = ((__u8 *)ch) + SCTP_PAD4(ntohs(ch->length));\n\t\tif (ch_end > skb_tail_pointer(skb))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n \t\tch = (sctp_chunkhdr_t *) ch_end;\n \t} while (ch_end < skb_tail_pointer(skb));\n \n\tif (ootb_shut_ack)\n\t\treturn sctp_sf_shut_8_4_5(net, ep, asoc, type, arg, commands);\n\telse if (ootb_cookie_ack)\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\telse\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n}\n", "target": 1, "idx": 180033}
{"func": "posix_acl_to_xattr(struct user_namespace *user_ns, const struct posix_acl *acl,\n\t\t   void *buffer, size_t size)\n{\n\tposix_acl_xattr_header *ext_acl = (posix_acl_xattr_header *)buffer;\n\tposix_acl_xattr_entry *ext_entry;\n\tint real_size, n;\n\n\treal_size = posix_acl_xattr_size(acl->a_count);\n\tif (!buffer)\n\t\treturn real_size;\n\tif (real_size > size)\n\t\treturn -ERANGE;\n\n\text_entry = ext_acl->a_entries;\n\text_acl->a_version = cpu_to_le32(POSIX_ACL_XATTR_VERSION);\n\n\tfor (n=0; n < acl->a_count; n++, ext_entry++) {\n\t\tconst struct posix_acl_entry *acl_e = &acl->a_entries[n];\n\t\text_entry->e_tag  = cpu_to_le16(acl_e->e_tag);\n\t\text_entry->e_perm = cpu_to_le16(acl_e->e_perm);\n\t\tswitch(acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\t\text_entry->e_id =\n\t\t\t\tcpu_to_le32(from_kuid(user_ns, acl_e->e_uid));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\text_entry->e_id =\n\t\t\t\tcpu_to_le32(from_kgid(user_ns, acl_e->e_gid));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\text_entry->e_id = cpu_to_le32(ACL_UNDEFINED_ID);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn real_size;\n}\n", "target": 0, "idx": 50388}
{"func": "status_t SampleTable::setTimeToSampleParams(\n off64_t data_offset, size_t data_size) {\n if (mTimeToSample != NULL || data_size < 8) {\n return ERROR_MALFORMED;\n }\n\n uint8_t header[8];\n if (mDataSource->readAt(\n                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {\n return ERROR_IO;\n }\n\n if (U32_AT(header) != 0) {\n return ERROR_MALFORMED;\n\n     }\n \n     mTimeToSampleCount = U32_AT(&header[4]);\n    uint64_t allocSize = mTimeToSampleCount * 2 * sizeof(uint32_t);\n     if (allocSize > SIZE_MAX) {\n         return ERROR_OUT_OF_RANGE;\n     }\n    mTimeToSample = new uint32_t[mTimeToSampleCount * 2];\n\n size_t size = sizeof(uint32_t) * mTimeToSampleCount * 2;\n if (mDataSource->readAt(\n                data_offset + 8, mTimeToSample, size) < (ssize_t)size) {\n return ERROR_IO;\n }\n\n for (uint32_t i = 0; i < mTimeToSampleCount * 2; ++i) {\n        mTimeToSample[i] = ntohl(mTimeToSample[i]);\n }\n\n return OK;\n}\n", "target": 1, "idx": 187361}
{"func": "static const char *default_charset(void)\n{\n# if defined HAVE_LIBCHARSET_H && defined HAVE_LOCALE_CHARSET\n\treturn locale_charset();\n# elif defined HAVE_LANGINFO_H && defined HAVE_NL_LANGINFO\n\treturn nl_langinfo(CODESET);\n# else\n\treturn \"\"; /* Works with (at the very least) gnu iconv... */\n# endif\n}\n", "target": 0, "idx": 689}
{"func": "static void coroutine_fn v9fs_link(void *opaque)\n{\n    V9fsPDU *pdu = opaque;\n    int32_t dfid, oldfid;\n    V9fsFidState *dfidp, *oldfidp;\n    V9fsString name;\n    size_t offset = 7;\n    int err = 0;\n\n    v9fs_string_init(&name);\n    err = pdu_unmarshal(pdu, offset, \"dds\", &dfid, &oldfid, &name);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_link(pdu->tag, pdu->id, dfid, oldfid, name.data);\n\n    if (name_is_illegal(name.data)) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n\n    if (!strcmp(\".\", name.data) || !strcmp(\"..\", name.data)) {\n        err = -EEXIST;\n        goto out_nofid;\n    }\n\n    dfidp = get_fid(pdu, dfid);\n    if (dfidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n\n    oldfidp = get_fid(pdu, oldfid);\n    if (oldfidp == NULL) {\n        err = -ENOENT;\n        goto out;\n    }\n    err = v9fs_co_link(pdu, oldfidp, dfidp, &name);\n     if (!err) {\n         err = offset;\n     }\n out:\n     put_fid(pdu, dfidp);\n out_nofid:\n    pdu_complete(pdu, err);\n}\n", "target": 1, "idx": 178079}
{"func": "dbus_object_create_path_vrrp(void)\n{\n\treturn g_strconcat(DBUS_VRRP_OBJECT_ROOT,\n#if HAVE_DECL_CLONE_NEWNET\n\t\t\t  global_data->network_namespace ? \"/\" : \"\", global_data->network_namespace ? global_data->network_namespace : \"\",\n#endif\n\t\t\t  global_data->instance_name ? \"/\" : \"\", global_data->instance_name ? global_data->instance_name : \"\",\n\n\t\t\t  \"/Vrrp\", NULL);\n}\n", "target": 0, "idx": 75950}
{"func": " void DOMStorageContextWrapper::Shutdown() {\n  DCHECK(context_.get());\n  mojo_task_runner_->PostTask(\n      FROM_HERE, base::BindOnce(&LocalStorageContextMojo::ShutdownAndDelete,\n                                base::Unretained(mojo_state_)));\n  mojo_state_ = nullptr;\n   if (mojo_session_state_) {\n     mojo_task_runner_->PostTask(\n         FROM_HERE, base::BindOnce(&SessionStorageContextMojo::ShutdownAndDelete,\n                                   base::Unretained(mojo_session_state_)));\n     mojo_session_state_ = nullptr;\n   }\n   memory_pressure_listener_.reset();\n  context_->task_runner()->PostShutdownBlockingTask(\n      FROM_HERE, DOMStorageTaskRunner::PRIMARY_SEQUENCE,\n      base::BindOnce(&DOMStorageContextImpl::Shutdown, context_));\n }\n", "target": 1, "idx": 187034}
